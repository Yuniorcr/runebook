<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="nginx_lua_module">
    <body>
      <group id="nginx_lua_module">
        <trans-unit id="0776eab0e9d0f01c57a726b39f51c0f67e1ea474" translate="yes" xml:space="preserve">
          <source>&quot;Light threads&quot; are just a special kind of Lua coroutines that are scheduled by the ngx_lua module.</source>
          <target state="translated">&amp;ldquo;轻线程&amp;rdquo;只是ngx_lua模块安排的一种特殊的Lua协程。</target>
        </trans-unit>
        <trans-unit id="f8d5300899a95a6a1a6deaa3e9a32a1082261afa" translate="yes" xml:space="preserve">
          <source>&quot;Light threads&quot; are mostly useful for making concurrent upstream requests in a single Nginx request handler, much like a generalized version of &lt;a href=&quot;#ngxlocationcapture_multi&quot;&gt;ngx.location.capture_multi&lt;/a&gt; that can work with all the &lt;a href=&quot;#nginx-api-for-lua&quot;&gt;Nginx API for Lua&lt;/a&gt;. The following example demonstrates parallel requests to MySQL, Memcached, and upstream HTTP services in a single Lua handler, and outputting the results in the order that they actually return (similar to Facebook's BigPipe model):</source>
          <target state="translated">&amp;ldquo;轻线程&amp;rdquo;对于在单个Nginx请求处理程序中发出并发的上游请求最有用，非常类似于&lt;a href=&quot;#ngxlocationcapture_multi&quot;&gt;ngx.location.capture_multi&lt;/a&gt;的通用版本，该版本可以与&lt;a href=&quot;#nginx-api-for-lua&quot;&gt;Lua的&lt;/a&gt;所有Nginx API一起使用。以下示例演示了在单个Lua处理程序中对MySQL，Memcached和上游HTTP服务的并行请求，并按照它们实际返回的顺序输出结果（类似于Facebook的BigPipe模型）：</target>
        </trans-unit>
        <trans-unit id="7ae047dd7457f994786b238f319ddfbb7e626636" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2009&amp;ndash;2017 Xiaozhe Wang (chaoslawful)</source>
          <target state="translated">&amp;copy;2009&amp;ndash;2017 Wang Xiaozhe Wang（chaoslawful）</target>
        </trans-unit>
        <trans-unit id="a9200a21ce9744bc6e0630c30c1e8675277278ca" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2009&amp;ndash;2018 Yichun &quot;agentzh&quot; Zhang (章亦春), OpenResty Inc.</source>
          <target state="translated">&amp;copy;2009&amp;ndash;2018 Yichun&amp;ldquo; agentzh&amp;rdquo; Zhang（章亦春），OpenResty Inc.版权所有。</target>
        </trans-unit>
        <trans-unit id="9856017d8a5440c6f814f05c8e1f3bb4025346fb" translate="yes" xml:space="preserve">
          <source>1.10.x</source>
          <target state="translated">1.10.x</target>
        </trans-unit>
        <trans-unit id="690c631e6cda34be404f415b4dd75bb598db7169" translate="yes" xml:space="preserve">
          <source>1.11.x (last tested: 1.11.2)</source>
          <target state="translated">1.11.x (最后测试:1.11.2)</target>
        </trans-unit>
        <trans-unit id="44f6cd4d06a21c34068d9d365200b748937bf8dc" translate="yes" xml:space="preserve">
          <source>1.12.x</source>
          <target state="translated">1.12.x</target>
        </trans-unit>
        <trans-unit id="2c5f46dd90db75a26b290c0f7f04ed9148ec58f5" translate="yes" xml:space="preserve">
          <source>1.13.x (last tested: 1.13.6)</source>
          <target state="translated">1.13.x (最后测试:1.13.6)</target>
        </trans-unit>
        <trans-unit id="c547245d08ac55419baf6bdbc03da9196c55e45c" translate="yes" xml:space="preserve">
          <source>1.6.x</source>
          <target state="translated">1.6.x</target>
        </trans-unit>
        <trans-unit id="f08d7423628faabb5445f5fdced26849df29811d" translate="yes" xml:space="preserve">
          <source>1.7.x (last tested: 1.7.10)</source>
          <target state="translated">1.7.x (最后测试:1.7.10)</target>
        </trans-unit>
        <trans-unit id="b28ab85ad05e3b632943081b56c292bde1c5dcb7" translate="yes" xml:space="preserve">
          <source>1.8.x</source>
          <target state="translated">1.8.x</target>
        </trans-unit>
        <trans-unit id="6f14872b6da159dd0a7e84367a904052b54d0aa0" translate="yes" xml:space="preserve">
          <source>1.9.x (last tested: 1.9.15)</source>
          <target state="translated">1.9.x (最后测试:1.9.15)</target>
        </trans-unit>
        <trans-unit id="aec056bf0ad251b4e0986bb4084c8875ec9aa146" translate="yes" xml:space="preserve">
          <source>3rd-party Lua libraries:</source>
          <target state="translated">第三方Lua库。</target>
        </trans-unit>
        <trans-unit id="503a11ed76700de2094cf34ae5dd5f3410167160" translate="yes" xml:space="preserve">
          <source>400 (Bad Request)</source>
          <target state="translated">400(不良请求)</target>
        </trans-unit>
        <trans-unit id="c84440c052a21c702f1adcf0892d5247f44935ef" translate="yes" xml:space="preserve">
          <source>405 (Not Allowed)</source>
          <target state="translated">405(不允许)</target>
        </trans-unit>
        <trans-unit id="c42281e56f0ab290ad9ce9a93695464566cbdb95" translate="yes" xml:space="preserve">
          <source>408 (Request Timeout)</source>
          <target state="translated">408 (请求超时)</target>
        </trans-unit>
        <trans-unit id="c5767398e05097f2ffbac609dde4263b011ffebf" translate="yes" xml:space="preserve">
          <source>413 (Request Entity Too Large)</source>
          <target state="translated">413(请求实体太大)</target>
        </trans-unit>
        <trans-unit id="98ce288198119333122096d76ee1db36cc0180ca" translate="yes" xml:space="preserve">
          <source>414 (Request URI Too Large)</source>
          <target state="translated">414 (请求URI太大)</target>
        </trans-unit>
        <trans-unit id="9198279132d9113a13468193bfe0dde9653eaeba" translate="yes" xml:space="preserve">
          <source>494 (Request Headers Too Large)</source>
          <target state="translated">494 (请求头太大)</target>
        </trans-unit>
        <trans-unit id="bbdf877267accb1b067c3a866ba5bffe0733de4c" translate="yes" xml:space="preserve">
          <source>499 (Client Closed Request)</source>
          <target state="translated">499(客户关闭请求)</target>
        </trans-unit>
        <trans-unit id="ffbf39a10b9aa165ac2d010205f182831ad27a69" translate="yes" xml:space="preserve">
          <source>500 (Internal Server Error)</source>
          <target state="translated">500(内部服务器错误)</target>
        </trans-unit>
        <trans-unit id="a25fd04426741c3db80aff8da303aef1b4a5b990" translate="yes" xml:space="preserve">
          <source>501 (Not Implemented)</source>
          <target state="translated">501(未执行)</target>
        </trans-unit>
        <trans-unit id="8184add052ee55f00e07d52ab50f0b38222f9ebd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://mdounin.ru/files/ngx_http_auth_request_module-0.2.tar.gz&quot;&gt;ngx_auth_request&lt;/a&gt; (this is not needed if you're using Nginx 1.5.4+.</source>
          <target state="translated">&lt;a href=&quot;http://mdounin.ru/files/ngx_http_auth_request_module-0.2.tar.gz&quot;&gt;ngx_auth_request&lt;/a&gt;（如果您使用的是Nginx 1.5.4+，则不需要。</target>
        </trans-unit>
        <trans-unit id="1de3e814d4e9a343c5d027cb6a7db4a6f3dcaa13" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/cloudflare/lua-resty-cookie&quot;&gt;lua-resty-cookie&lt;/a&gt; library for HTTP cookie manipulation.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/cloudflare/lua-resty-cookie&quot;&gt;lua-resty-cookie&lt;/a&gt;库，用于HTTP cookie操作。</target>
        </trans-unit>
        <trans-unit id="a759ed1bd737f1daa7583d22dfc7550b7429f63b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/openresty/lua-resty-dns&quot;&gt;lua-resty-dns&lt;/a&gt; library based on ngx_lua cosocket.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/openresty/lua-resty-dns&quot;&gt;&lt;/a&gt;基于ngx_lua cosocket的lua-resty-dns库。</target>
        </trans-unit>
        <trans-unit id="1a8882a5265dbdde339d5bc52b1d4ad0135321a2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/openresty/lua-resty-lock&quot;&gt;lua-resty-lock&lt;/a&gt; library for a nonblocking simple lock API.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/openresty/lua-resty-lock&quot;&gt;lua-resty-lock&lt;/a&gt;库，用于无阻塞的简单锁定API。</target>
        </trans-unit>
        <trans-unit id="64a96bbbeb83988a836c62539f753f9c0325304f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/openresty/lua-resty-memcached&quot;&gt;lua-resty-memcached&lt;/a&gt; library based on ngx_lua cosocket.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/openresty/lua-resty-memcached&quot;&gt;&lt;/a&gt;基于ngx_lua cosocket的lua-resty-memcached库。</target>
        </trans-unit>
        <trans-unit id="1a6e1d7364481c25a627bf65cc582bf65839a442" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/openresty/lua-resty-mysql&quot;&gt;lua-resty-mysql&lt;/a&gt; library based on ngx_lua cosocket.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/openresty/lua-resty-mysql&quot;&gt;&lt;/a&gt;基于ngx_lua cosocket的lua-resty-mysql库。</target>
        </trans-unit>
        <trans-unit id="979a69517ee58c0ea3d1530a7ac876e132a781b8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/openresty/lua-resty-redis&quot;&gt;lua-resty-redis&lt;/a&gt; library based on ngx_lua cosocket.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/openresty/lua-resty-redis&quot;&gt;&lt;/a&gt;基于ngx_lua cosocket的lua-resty-redis库。</target>
        </trans-unit>
        <trans-unit id="4f7ba41e5bf14c88df52c04c8737e59852222b3e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/openresty/lua-resty-string&quot;&gt;lua-resty-string&lt;/a&gt; library based on &lt;a href=&quot;http://luajit.org/ext_ffi.html&quot;&gt;LuaJIT FFI&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/openresty/lua-resty-string&quot;&gt;&lt;/a&gt;基于&lt;a href=&quot;http://luajit.org/ext_ffi.html&quot;&gt;LuaJIT FFI的&lt;/a&gt;lua-resty-string库。</target>
        </trans-unit>
        <trans-unit id="ee443d0ee86721182108a4f79ec93db95b12b502" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/openresty/lua-resty-upload&quot;&gt;lua-resty-upload&lt;/a&gt; library based on ngx_lua cosocket.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/openresty/lua-resty-upload&quot;&gt;&lt;/a&gt;基于ngx_lua cosocket的lua-resty-upload库。</target>
        </trans-unit>
        <trans-unit id="8ce5d69528cd157f7b16afca42c34aaa66ae0572" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/openresty/lua-resty-websocket&quot;&gt;lua-resty-websocket&lt;/a&gt; library for both WebSocket server and client, based on ngx_lua cosocket.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/openresty/lua-resty-websocket&quot;&gt;&lt;/a&gt;用于WebSocket服务器和客户端的lua-resty-websocket库，基于ngx_lua cosocket。</target>
        </trans-unit>
        <trans-unit id="219d9037bdbfee60172efae3069b496f39a895d1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/openresty/stream-lua-nginx-module#readme&quot;&gt;ngx_stream_lua_module&lt;/a&gt; for an official port of this module for the NGINX &quot;stream&quot; subsystem (doing generic downstream TCP communications).</source>
          <target state="translated">&lt;a href=&quot;https://github.com/openresty/stream-lua-nginx-module#readme&quot;&gt;ngx_stream_lua_module&lt;/a&gt;，用于NGINX&amp;ldquo;流&amp;rdquo;子系统的此模块的正式端口（进行通用的下游TCP通信）。</target>
        </trans-unit>
        <trans-unit id="508fc71a7ad99447f77b5e5b6ef1b2c60e8de526" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'*a'&lt;/code&gt;: reads from the socket until the connection is closed. No end-of-line translation is performed;</source>
          <target state="translated">&lt;code&gt;'*a'&lt;/code&gt; ：从套接字读取直到连接关闭。不执行行尾翻译；</target>
        </trans-unit>
        <trans-unit id="79ab258a62a13886c264a9c0df336bc423c30ec0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'*l'&lt;/code&gt;: reads a line of text from the socket. The line is terminated by a &lt;code&gt;Line Feed&lt;/code&gt; (LF) character (ASCII 10), optionally preceded by a &lt;code&gt;Carriage Return&lt;/code&gt; (CR) character (ASCII 13). The CR and LF characters are not included in the returned line. In fact, all CR characters are ignored by the pattern.</source>
          <target state="translated">&lt;code&gt;'*l'&lt;/code&gt; ：从套接字读取一行文本。该行以换 &lt;code&gt;Line Feed&lt;/code&gt; （LF）字符（ASCII 10）终止，并可选地以 &lt;code&gt;Carriage Return&lt;/code&gt; （CR）字符（ASCII 13）结尾。CR和LF字符不包含在返回的行中。实际上，该模式会忽略所有CR字符。</target>
        </trans-unit>
        <trans-unit id="08a8a9724c4adca7536e467df0eaf5cb2cdd6c26" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;302&lt;/code&gt; (default)</source>
          <target state="translated">&lt;code&gt;302&lt;/code&gt; （预设）</target>
        </trans-unit>
        <trans-unit id="27afa4b9cc43722a437ec9f0962712c37c0b218f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;GET /foo/file.php?a=hello&lt;/code&gt; will return &quot;hello&quot; and not &quot;goodbye&quot; in the example below</source>
          <target state="translated">&lt;code&gt;GET /foo/file.php?a=hello&lt;/code&gt; 在下面的示例中将返回&amp;ldquo; hello&amp;rdquo;而不是&amp;ldquo;再见&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="ae7c59e21565373072ec878151dbd7dc60b56dcb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NGX_LUA_ABORT_AT_PANIC&lt;/code&gt; When the Lua/LuaJIT VM panics, ngx_lua will instruct the current nginx worker process to quit gracefully by default. By specifying this C macro, ngx_lua will abort the current nginx worker process (which usually result in a core dump file) immediately. This option is useful for debugging VM panics. This option was first introduced in the &lt;code&gt;v0.9.8&lt;/code&gt; release.</source>
          <target state="translated">&lt;code&gt;NGX_LUA_ABORT_AT_PANIC&lt;/code&gt; 当Lua / LuaJIT VM出现紧急情况时，ngx_lua将指示当前的nginx工作进程默认情况下正常退出。通过指定此C宏，ngx_lua将立即中止当前的nginx工作进程（通常会导致核心转储文件）。此选项对于调试VM紧急情况很有用。 &lt;code&gt;v0.9.8&lt;/code&gt; 版本中首次引入了此选项。</target>
        </trans-unit>
        <trans-unit id="4ad1c0290dfbe7c5aa56a90497b7680f76efcc0f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NGX_LUA_NO_FFI_API&lt;/code&gt; Excludes pure C API functions for FFI-based Lua API for NGINX (as required by &lt;a href=&quot;https://github.com/openresty/lua-resty-core#readme&quot;&gt;lua-resty-core&lt;/a&gt;, for example). Enabling this macro can make the resulting binary code size smaller.</source>
          <target state="translated">&lt;code&gt;NGX_LUA_NO_FFI_API&lt;/code&gt; 排除基于NGINX的基于FFI的Lua API的纯C API函数（例如，按&lt;a href=&quot;https://github.com/openresty/lua-resty-core#readme&quot;&gt;lua-resty-core的&lt;/a&gt;要求）。启用此宏可以使生成的二进制代码大小更小。</target>
        </trans-unit>
        <trans-unit id="f59f3b6f8cae6d05405d9c24ad7258993e46c5bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NGX_LUA_USE_ASSERT&lt;/code&gt; When defined, will enable assertions in the ngx_lua C code base. Recommended for debugging or testing builds. It can introduce some (small) runtime overhead when enabled. This macro was first introduced in the &lt;code&gt;v0.9.10&lt;/code&gt; release.</source>
          <target state="translated">&lt;code&gt;NGX_LUA_USE_ASSERT&lt;/code&gt; 定义后，将在ngx_lua C代码库中启用断言。建议用于调试或测试版本。启用后，可能会带来一些（小的）运行时开销。该宏最初是在 &lt;code&gt;v0.9.10&lt;/code&gt; 版本中引入的。</target>
        </trans-unit>
        <trans-unit id="522765e013c72ae07785141c5d3077fad39001af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;access&lt;/code&gt; for the context of &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua*&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;access&lt;/code&gt; &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua *&lt;/a&gt;的上下文。</target>
        </trans-unit>
        <trans-unit id="958538b1e59cc24cdfa26de5d7f60cf97a0ff23c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;always_forward_body&lt;/code&gt; when set to true, the current (parent) request's request body will always be forwarded to the subrequest being created if the &lt;code&gt;body&lt;/code&gt; option is not specified. The request body read by either &lt;a href=&quot;#ngxreqread_body&quot;&gt;ngx.req.read_body()&lt;/a&gt; or &lt;a href=&quot;#lua_need_request_body&quot;&gt;lua_need_request_body on&lt;/a&gt; will be directly forwarded to the subrequest without copying the whole request body data when creating the subrequest (no matter the request body data is buffered in memory buffers or temporary files). By default, this option is &lt;code&gt;false&lt;/code&gt; and when the &lt;code&gt;body&lt;/code&gt; option is not specified, the request body of the current (parent) request is only forwarded when the subrequest takes the &lt;code&gt;PUT&lt;/code&gt; or &lt;code&gt;POST&lt;/code&gt; request method.</source>
          <target state="translated">&lt;code&gt;always_forward_body&lt;/code&gt; 设置为true时，如果未指定 &lt;code&gt;body&lt;/code&gt; 选项，则当前（父）请求的请求主体将始终转发到正在创建的子请求。由&lt;a href=&quot;#ngxreqread_body&quot;&gt;ngx.req.read_body（）&lt;/a&gt;或&lt;a href=&quot;#lua_need_request_body&quot;&gt;lua_need_request_body&lt;/a&gt;读取的请求正文将直接转发到子请求，而无需在创建子请求时复制整个请求正文数据（无论请求正文数据是缓存在内存缓冲区还是临时文件中） 。默认情况下，此选项为 &lt;code&gt;false&lt;/code&gt; ，当未指定 &lt;code&gt;body&lt;/code&gt; 选项时，仅当子请求采用 &lt;code&gt;PUT&lt;/code&gt; 或 &lt;code&gt;POST&lt;/code&gt; 时才转发当前（父）请求的请求正文 请求方法。</target>
        </trans-unit>
        <trans-unit id="76d1cdb53abfa67c6805bfb2abb40c1ebd5bbb55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;args&lt;/code&gt; specify the subrequest's URI query arguments (both string value and Lua tables are accepted)</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; 指定子请求的URI查询参数（接受字符串值和Lua表）</target>
        </trans-unit>
        <trans-unit id="57014b5b7b33d6764ad668d2e40d747934a6eee4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;balancer&lt;/code&gt; for the context of &lt;a href=&quot;#balancer_by_lua_block&quot;&gt;balancer_by_lua*&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;balancer&lt;/code&gt; 的背景下&lt;a href=&quot;#balancer_by_lua_block&quot;&gt;balancer_by_lua *&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e2b1a35b0acebb658c271baf5f030a851716b9a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;body&lt;/code&gt; specify the subrequest's request body (string value only).</source>
          <target state="translated">&lt;code&gt;body&lt;/code&gt; 指定子请求的请求主体（仅字符串值）。</target>
        </trans-unit>
        <trans-unit id="065be0724a61f8e94c12ae8619c6110d33c10dee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;body_filter&lt;/code&gt; for the context of &lt;a href=&quot;#body_filter_by_lua&quot;&gt;body_filter_by_lua*&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;body_filter&lt;/code&gt; 的背景下&lt;a href=&quot;#body_filter_by_lua&quot;&gt;body_filter_by_lua *&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="feca8ce2366f88c6dc2854e6fe77a3a151cb8366" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;content&lt;/code&gt; for the context of &lt;a href=&quot;#content_by_lua&quot;&gt;content_by_lua*&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;content&lt;/code&gt; &lt;a href=&quot;#content_by_lua&quot;&gt;content_by_lua *&lt;/a&gt;上下文的内容。</target>
        </trans-unit>
        <trans-unit id="63b00c35a068bb9b7b378c5b153b7fb9aa798cfa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;copy_all_vars&lt;/code&gt; specify whether to copy over all the Nginx variable values of the current request to the subrequest in question. modifications of the nginx variables in the subrequest will not affect the current (parent) request. This option was first introduced in the &lt;code&gt;v0.3.1rc31&lt;/code&gt; release.</source>
          <target state="translated">&lt;code&gt;copy_all_vars&lt;/code&gt; 指定是否将当前请求的所有Nginx变量值复制到有问题的子请求。子请求中对nginx变量的修改不会影响当前（父）请求。 &lt;code&gt;v0.3.1rc31&lt;/code&gt; 发行版中首次引入了此选项。</target>
        </trans-unit>
        <trans-unit id="705e4c7a821ca3af4ca4fb7e8b6b7b07d3015b4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ctx&lt;/code&gt; specify a Lua table to be the &lt;a href=&quot;#ngxctx&quot;&gt;ngx.ctx&lt;/a&gt; table for the subrequest. It can be the current request's &lt;a href=&quot;#ngxctx&quot;&gt;ngx.ctx&lt;/a&gt; table, which effectively makes the parent and its subrequest to share exactly the same context table. This option was first introduced in the &lt;code&gt;v0.3.1rc25&lt;/code&gt; release.</source>
          <target state="translated">&lt;code&gt;ctx&lt;/code&gt; 将Lua表指定为子请求的&lt;a href=&quot;#ngxctx&quot;&gt;ngx.ctx&lt;/a&gt;表。它可以是当前请求的&lt;a href=&quot;#ngxctx&quot;&gt;ngx.ctx&lt;/a&gt;表，从而有效地使父项及其子请求共享完全相同的上下文表。 &lt;code&gt;v0.3.1rc25&lt;/code&gt; 版本中首次引入了此选项。</target>
        </trans-unit>
        <trans-unit id="5b6e08620ef3bf3c45bccddced2acc462ee1a0c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;delay&lt;/code&gt;&lt;em&gt;cannot&lt;/em&gt; be zero,</source>
          <target state="translated">&lt;code&gt;delay&lt;/code&gt; &lt;em&gt;不能&lt;/em&gt;为零</target>
        </trans-unit>
        <trans-unit id="282b23132d559bf8057bf7a864954d5b948039d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;err&lt;/code&gt;: textual error message, can be &lt;code&gt;&quot;no memory&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;err&lt;/code&gt; ：文本错误消息，可以是 &lt;code&gt;&quot;no memory&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a8025d119550e6438b08b3dd395c435c21ac39ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forcible&lt;/code&gt;: a boolean value to indicate whether other valid items have been removed forcibly when out of storage in the shared memory zone.</source>
          <target state="translated">&lt;code&gt;forcible&lt;/code&gt; ：一个布尔值，指示在共享内存区域中的存储空间不足时是否已强制删除其他有效项。</target>
        </trans-unit>
        <trans-unit id="bfce20f09ecda9e7892f4befe4299678e93db290" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;header_filter&lt;/code&gt; for the context of &lt;a href=&quot;#header_filter_by_lua&quot;&gt;header_filter_by_lua*&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;header_filter&lt;/code&gt; 的背景下&lt;a href=&quot;#header_filter_by_lua&quot;&gt;header_filter_by_lua *&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d6675123e313ac05987a5cb661fc584229acc294" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;init&lt;/code&gt; for the context of &lt;a href=&quot;#init_by_lua&quot;&gt;init_by_lua*&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;init&lt;/code&gt; 用于&lt;a href=&quot;#init_by_lua&quot;&gt;init_by_lua *&lt;/a&gt;的上下文。</target>
        </trans-unit>
        <trans-unit id="05d735bf97f11016f776aad440b27ab557e4df4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;init_worker&lt;/code&gt; for the context of &lt;a href=&quot;#init_worker_by_lua&quot;&gt;init_worker_by_lua*&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;init_worker&lt;/code&gt; 的背景下&lt;a href=&quot;#init_worker_by_lua&quot;&gt;init_worker_by_lua *&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c44559cc796c043585373733a5bad604d5103184" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log&lt;/code&gt; for the context of &lt;a href=&quot;#log_by_lua&quot;&gt;log_by_lua*&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;log&lt;/code&gt; &lt;a href=&quot;#log_by_lua&quot;&gt;log_by_lua *&lt;/a&gt;的上下文。</target>
        </trans-unit>
        <trans-unit id="68ee4757918c95c0f30e48bb7d7801e19ce341ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;method&lt;/code&gt; specify the subrequest's request method, which only accepts constants like &lt;code&gt;ngx.HTTP_POST&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;method&lt;/code&gt; 指定子请求的请求方法，该方法仅接受 &lt;code&gt;ngx.HTTP_POST&lt;/code&gt; 之类的常量。</target>
        </trans-unit>
        <trans-unit id="e8b3e02468193ca3dd65662326579146c891580e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ngx.flush&lt;/code&gt; accepts an optional boolean &lt;code&gt;wait&lt;/code&gt; argument (Default: &lt;code&gt;false&lt;/code&gt;) first introduced in the &lt;code&gt;v0.3.1rc34&lt;/code&gt; release. When called with the default argument, it issues an asynchronous call (Returns immediately without waiting for output data to be written into the system send buffer). Calling the function with the &lt;code&gt;wait&lt;/code&gt; argument set to &lt;code&gt;true&lt;/code&gt; switches to synchronous mode.</source>
          <target state="translated">&lt;code&gt;ngx.flush&lt;/code&gt; 接受 &lt;code&gt;v0.3.1rc34&lt;/code&gt; 发行版中首次引入的可选布尔 &lt;code&gt;wait&lt;/code&gt; 参数（默认值： &lt;code&gt;false&lt;/code&gt; ）。当使用默认参数调用时，它将发出异步调用（立即返回，而无需等待将输出数据写入系统发送缓冲区）。在 &lt;code&gt;wait&lt;/code&gt; 参数设置为 &lt;code&gt;true&lt;/code&gt; 的情况下调用该函数将切换到同步模式。</target>
        </trans-unit>
        <trans-unit id="b98b5d464bd147124c56885e7d249a2e7a462036" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pool&lt;/code&gt; specify a custom name for the connection pool being used. If omitted, then the connection pool name will be generated from the string template &lt;code&gt;&quot;&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;&quot;&lt;/code&gt; or &lt;code&gt;&quot;&amp;lt;unix-socket-path&amp;gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pool&lt;/code&gt; 为使用的连接池指定自定义名称。如果省略，则将从字符串模板 &lt;code&gt;&quot;&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;&amp;lt;unix-socket-path&amp;gt;&quot;&lt;/code&gt; 生成连接池名称。</target>
        </trans-unit>
        <trans-unit id="0bbb837ccdf2fabeb7b9281e6b9a713127e0289a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;res.body&lt;/code&gt; holds the subrequest's response body data, which might be truncated. You always need to check the &lt;code&gt;res.truncated&lt;/code&gt; boolean flag to see if &lt;code&gt;res.body&lt;/code&gt; contains truncated data. The data truncation here can only be caused by those unrecoverable errors in your subrequests like the cases that the remote end aborts the connection prematurely in the middle of the response body data stream or a read timeout happens when your subrequest is receiving the response body data from the remote.</source>
          <target state="translated">&lt;code&gt;res.body&lt;/code&gt; 保留子请求的响应正文数据，该数据可能会被截断。您始终需要检查 &lt;code&gt;res.truncated&lt;/code&gt; 布尔标志，以查看 &lt;code&gt;res.body&lt;/code&gt; 是否包含截断的数据。此处的数据截断只能由您的子请求中的那些不可恢复的错误引起，例如，远端在响应主体数据流的中间过早中止连接，或者当您的子请求从以下位置接收响应主体数据时发生读取超时：遥控器。</target>
        </trans-unit>
        <trans-unit id="81d4c90c5bc308385866f2fbc63b948f6cee13be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;res.header&lt;/code&gt; holds all the response headers of the subrequest and it is a normal Lua table. For multi-value response headers, the value is a Lua (array) table that holds all the values in the order that they appear. For instance, if the subrequest response headers contain the following lines:</source>
          <target state="translated">&lt;code&gt;res.header&lt;/code&gt; 保存着子请求的所有响应头，它是一个普通的Lua表。对于多值响应标头，该值是一个Lua（数组）表，该表按它们出现的顺序保存所有值。例如，如果子请求响应标头包含以下行：</target>
        </trans-unit>
        <trans-unit id="bfaea47beff9d3fe1af84c27e8d42ce95706660d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;res.status&lt;/code&gt; holds the response status code for the subrequest response.</source>
          <target state="translated">&lt;code&gt;res.status&lt;/code&gt; 保留子请求响应的响应状态代码。</target>
        </trans-unit>
        <trans-unit id="f6b59aa955a4da16d0484da7aac3161750f3059a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rewrite&lt;/code&gt; for the context of &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua*&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;rewrite&lt;/code&gt; 针对&lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua *&lt;/a&gt;的上下文进行重写。</target>
        </trans-unit>
        <trans-unit id="b2f293c9d2d7a61cb62272a2d322e03b0f0e6108" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set&lt;/code&gt; for the context of &lt;a href=&quot;#set_by_lua&quot;&gt;set_by_lua*&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; 为&lt;a href=&quot;#set_by_lua&quot;&gt;set_by_lua *&lt;/a&gt;的上下文设置。</target>
        </trans-unit>
        <trans-unit id="12d49e969d4bb023e2704b23b17b42319d017a91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;share_all_vars&lt;/code&gt; specify whether to share all the Nginx variables of the subrequest with the current (parent) request. modifications of the Nginx variables in the subrequest will affect the current (parent) request. Enabling this option may lead to hard-to-debug issues due to bad side-effects and is considered bad and harmful. Only enable this option when you completely know what you are doing.</source>
          <target state="translated">&lt;code&gt;share_all_vars&lt;/code&gt; 指定是否与当前（父）请求共享子请求的所有Nginx变量。子请求中对Nginx变量的修改将影响当前（父）请求。启用此选项可能会由于不良的副作用而导致难以调试的问题，并且被认为是有害的。仅在完全知道自己在做什么时才启用此选项。</target>
        </trans-unit>
        <trans-unit id="b5f7a6cd62d4b634857ddd10377960e288289637" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ssl_cert&lt;/code&gt; for the context of &lt;a href=&quot;#ssl_certificate_by_lua_block&quot;&gt;ssl_certificate_by_lua*&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ssl_cert&lt;/code&gt; 用于&lt;a href=&quot;#ssl_certificate_by_lua_block&quot;&gt;ssl_certificate_by_lua *&lt;/a&gt;的上下文。</target>
        </trans-unit>
        <trans-unit id="4e755abeadb3357ee393f1228432e6e195ba1ecd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ssl_session_fetch&lt;/code&gt; for the context of &lt;a href=&quot;#ssl_session_fetch_by_lua_block&quot;&gt;ssl_session_fetch_by_lua*&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ssl_session_fetch&lt;/code&gt; 的背景下&lt;a href=&quot;#ssl_session_fetch_by_lua_block&quot;&gt;ssl_session_fetch_by_lua *&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f6ce610bfefa97c2ed7877a70c3a9dcb304e727c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ssl_session_store&lt;/code&gt; for the context of &lt;a href=&quot;#ssl_session_store_by_lua_block&quot;&gt;ssl_session_store_by_lua*&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ssl_session_store&lt;/code&gt; 的背景下&lt;a href=&quot;#ssl_session_store_by_lua_block&quot;&gt;ssl_session_store_by_lua *&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="02488ce9cf358d30330fdae00832e64fa9469134" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;success&lt;/code&gt;: boolean value to indicate whether the key-value pair is stored or not.</source>
          <target state="translated">&lt;code&gt;success&lt;/code&gt; ：布尔值，指示是否存储键值对。</target>
        </trans-unit>
        <trans-unit id="686f6cfb1a878b598134c576a8c9e342f64538ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timer&lt;/code&gt; for the context of user callback functions for &lt;a href=&quot;#ngxtimerat&quot;&gt;ngx.timer.*&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;timer&lt;/code&gt; 用于&lt;a href=&quot;#ngxtimerat&quot;&gt;ngx.timer。*&lt;/a&gt;用户回调函数上下文的计时器。</target>
        </trans-unit>
        <trans-unit id="0944b43533c57e58503856103f29970cd6451c83" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;vars&lt;/code&gt; take a Lua table which holds the values to set the specified Nginx variables in the subrequest as this option's value. This option was first introduced in the &lt;code&gt;v0.3.1rc31&lt;/code&gt; release.</source>
          <target state="translated">&lt;code&gt;vars&lt;/code&gt; 使用一个Lua表，该表保存将子请求中指定的Nginx变量设置为该选项值的值。 &lt;code&gt;v0.3.1rc31&lt;/code&gt; 发行版中首次引入了此选项。</target>
        </trans-unit>
        <trans-unit id="ddd0f12337823ae1f8c185bf24b6f656c74c211b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;This module is not distributed with the Nginx source.&lt;/em&gt; See &lt;a href=&quot;#installation&quot;&gt;the installation instructions&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;该模块不随Nginx源一起分发。&lt;/em&gt;请参阅&lt;a href=&quot;#installation&quot;&gt;安装说明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9523bb257a2f80fd98cc2a7d0984a287fc3c6082" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CAUTION&lt;/strong&gt; Avoid calling this method on dictionaries with a very large number of keys as it may lock the dictionary for significant amount of time and block Nginx worker processes trying to access the dictionary.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;避免在具有大量键的字典上调用此方法，因为它可能会锁定字典相当长的时间，并阻止Nginx工作进程尝试访问字典。</target>
        </trans-unit>
        <trans-unit id="cab7beb3a867533343368e69adaa8b8743b792ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CAUTION&lt;/strong&gt; When reading from an Nginx variable, Nginx will allocate memory in the per-request memory pool which is freed only at request termination. So when you need to read from an Nginx variable repeatedly in your Lua code, cache the Nginx variable value to your own Lua variable, for example,</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;当从Nginx变量读取数据时，Nginx将在每个请求的内存池中分配内存，该内存池仅在请求终止时才释放。因此，当您需要在Lua代码中重复读取Nginx变量时，请将Nginx变量值缓存到您自己的Lua变量中，例如，</target>
        </trans-unit>
        <trans-unit id="602e025568eedb314baeb44f195d18984c499a3d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt; Following the &lt;code&gt;v0.9.17&lt;/code&gt; release, this pitfall can be avoided by using the &lt;code&gt;*_by_lua_block {}&lt;/code&gt; configuration directives.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;在 &lt;code&gt;v0.9.17&lt;/code&gt; 版本之后，可以使用 &lt;code&gt;*_by_lua_block {}&lt;/code&gt; 配置指令来避免这种陷阱。</target>
        </trans-unit>
        <trans-unit id="3108af88dfd491a7bba3b432c50ee09b400ac1d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt; Use of this directive is &lt;em&gt;discouraged&lt;/em&gt; following the &lt;code&gt;v0.9.17&lt;/code&gt; release. Use the &lt;a href=&quot;#access_by_lua_block&quot;&gt;access_by_lua_block&lt;/a&gt; directive instead.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;在 &lt;code&gt;v0.9.17&lt;/code&gt; 版本之后，&lt;em&gt;不建议&lt;/em&gt;使用此指令。请改用&lt;a href=&quot;#access_by_lua_block&quot;&gt;access_by_lua_block&lt;/a&gt;指令。</target>
        </trans-unit>
        <trans-unit id="a4ef937cbe86ba9e3441a2d68b6a72f87345d335" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt; Use of this directive is &lt;em&gt;discouraged&lt;/em&gt; following the &lt;code&gt;v0.9.17&lt;/code&gt; release. Use the &lt;a href=&quot;#body_filter_by_lua_block&quot;&gt;body_filter_by_lua_block&lt;/a&gt; directive instead.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;在 &lt;code&gt;v0.9.17&lt;/code&gt; 版本之后，&lt;em&gt;不建议&lt;/em&gt;使用此指令。请改用&lt;a href=&quot;#body_filter_by_lua_block&quot;&gt;body_filter_by_lua_block&lt;/a&gt;指令。</target>
        </trans-unit>
        <trans-unit id="b2e31102dc9d65ccfb16a549a2962de95c2982f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt; Use of this directive is &lt;em&gt;discouraged&lt;/em&gt; following the &lt;code&gt;v0.9.17&lt;/code&gt; release. Use the &lt;a href=&quot;#content_by_lua_block&quot;&gt;content_by_lua_block&lt;/a&gt; directive instead.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;在 &lt;code&gt;v0.9.17&lt;/code&gt; 版本之后，&lt;em&gt;不建议&lt;/em&gt;使用此指令。请改用&lt;a href=&quot;#content_by_lua_block&quot;&gt;content_by_lua_block&lt;/a&gt;指令。</target>
        </trans-unit>
        <trans-unit id="c7721503d012f5536aa9042c9912c0af156f0130" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt; Use of this directive is &lt;em&gt;discouraged&lt;/em&gt; following the &lt;code&gt;v0.9.17&lt;/code&gt; release. Use the &lt;a href=&quot;#header_filter_by_lua_block&quot;&gt;header_filter_by_lua_block&lt;/a&gt; directive instead.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;在 &lt;code&gt;v0.9.17&lt;/code&gt; 版本之后，&lt;em&gt;不建议&lt;/em&gt;使用此指令。请改用&lt;a href=&quot;#header_filter_by_lua_block&quot;&gt;header_filter_by_lua_block&lt;/a&gt;指令。</target>
        </trans-unit>
        <trans-unit id="91796efdd991e0d365183bd6ca9d738dd0242f9f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt; Use of this directive is &lt;em&gt;discouraged&lt;/em&gt; following the &lt;code&gt;v0.9.17&lt;/code&gt; release. Use the &lt;a href=&quot;#init_by_lua_block&quot;&gt;init_by_lua_block&lt;/a&gt; directive instead.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;在 &lt;code&gt;v0.9.17&lt;/code&gt; 版本之后，&lt;em&gt;不建议&lt;/em&gt;使用此指令。请改用&lt;a href=&quot;#init_by_lua_block&quot;&gt;init_by_lua_block&lt;/a&gt;指令。</target>
        </trans-unit>
        <trans-unit id="20706430ed50fd7b6a1c40b3abca6e512f2e4428" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt; Use of this directive is &lt;em&gt;discouraged&lt;/em&gt; following the &lt;code&gt;v0.9.17&lt;/code&gt; release. Use the &lt;a href=&quot;#init_worker_by_lua_block&quot;&gt;init_worker_by_lua_block&lt;/a&gt; directive instead.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;在 &lt;code&gt;v0.9.17&lt;/code&gt; 版本之后，&lt;em&gt;不建议&lt;/em&gt;使用此指令。请改用&lt;a href=&quot;#init_worker_by_lua_block&quot;&gt;init_worker_by_lua_block&lt;/a&gt;指令。</target>
        </trans-unit>
        <trans-unit id="abcd3257ca367fb8c3d7969f330073dcda2812e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt; Use of this directive is &lt;em&gt;discouraged&lt;/em&gt; following the &lt;code&gt;v0.9.17&lt;/code&gt; release. Use the &lt;a href=&quot;#log_by_lua_block&quot;&gt;log_by_lua_block&lt;/a&gt; directive instead.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;在 &lt;code&gt;v0.9.17&lt;/code&gt; 版本之后，&lt;em&gt;不建议&lt;/em&gt;使用此指令。请改用&lt;a href=&quot;#log_by_lua_block&quot;&gt;log_by_lua_block&lt;/a&gt;指令。</target>
        </trans-unit>
        <trans-unit id="a3c114a19a8433907e937d1d4eeabfd0800bff20" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt; Use of this directive is &lt;em&gt;discouraged&lt;/em&gt; following the &lt;code&gt;v0.9.17&lt;/code&gt; release. Use the &lt;a href=&quot;#rewrite_by_lua_block&quot;&gt;rewrite_by_lua_block&lt;/a&gt; directive instead.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;在 &lt;code&gt;v0.9.17&lt;/code&gt; 版本之后，&lt;em&gt;不建议&lt;/em&gt;使用此指令。请改用&lt;a href=&quot;#rewrite_by_lua_block&quot;&gt;rewrite_by_lua_block&lt;/a&gt;指令。</target>
        </trans-unit>
        <trans-unit id="ab94299b790e69ff42606adcb9be7b03a977d353" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt; Use of this directive is &lt;em&gt;discouraged&lt;/em&gt; following the &lt;code&gt;v0.9.17&lt;/code&gt; release. Use the &lt;a href=&quot;#set_by_lua_block&quot;&gt;set_by_lua_block&lt;/a&gt; directive instead.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;在 &lt;code&gt;v0.9.17&lt;/code&gt; 版本之后，&lt;em&gt;不建议&lt;/em&gt;使用此指令。请改用&lt;a href=&quot;#set_by_lua_block&quot;&gt;set_by_lua_block&lt;/a&gt;指令。</target>
        </trans-unit>
        <trans-unit id="fc8f66632154dfb1ecf82cf255aba8773e1af3d3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The memory for ngx.shared.DICT is allocated via the nginx slab allocator which has each slot for data size ranges like ~8, 9~16, 17~32, ..., 1025~2048, 2048~ bytes. And pages are assigned to a slot if there is no room in already assigned pages for the slot.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt; ngx.shared.DICT的内存是通过nginx slab分配器分配的，该分配器的每个插槽的数据大小范围约为〜8、9〜16、17〜32，...，1025〜2048、2048〜字节。如果已为该插槽分配的页面中没有空间，则会将页面分配给该插槽。</target>
        </trans-unit>
        <trans-unit id="9df395781dd6a73237a385096934c8f2d4bb5466" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This method requires the &lt;code&gt;resty.core.shdict&lt;/code&gt; or &lt;code&gt;resty.core&lt;/code&gt; modules from the &lt;a href=&quot;https://github.com/openresty/lua-resty-core&quot;&gt;lua-resty-core&lt;/a&gt; library.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;此方法需要&lt;a href=&quot;https://github.com/openresty/lua-resty-core&quot;&gt;lua-resty-core&lt;/a&gt;库中的 &lt;code&gt;resty.core.shdict&lt;/code&gt; 或 &lt;code&gt;resty.core&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="c117a8e1655c8859296d9e7457e88e2c16fd85be" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Usage of the &lt;code&gt;init_ttl&lt;/code&gt; argument requires the &lt;code&gt;resty.core.shdict&lt;/code&gt; or &lt;code&gt;resty.core&lt;/code&gt; modules from the &lt;a href=&quot;https://github.com/openresty/lua-resty-core&quot;&gt;lua-resty-core&lt;/a&gt; library. Example:</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;使用 &lt;code&gt;init_ttl&lt;/code&gt; 参数需要&lt;a href=&quot;https://github.com/openresty/lua-resty-core&quot;&gt;lua-resty-core&lt;/a&gt;库中的 &lt;code&gt;resty.core.shdict&lt;/code&gt; 或 &lt;code&gt;resty.core&lt;/code&gt; 模块。例：</target>
        </trans-unit>
        <trans-unit id="ade52cca976b6c0125e4bf226b4f5193058c1c92" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;http, server, location, location if&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;上下文：&lt;/strong&gt;&lt;em&gt;http，服务器，位置，位置（如果）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2ec5ccc6ede865ad6de431eb20b93681afd54d9d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;http, server, location, location-if&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;上下文：&lt;/strong&gt;&lt;em&gt;http，服务器，位置，位置（如果）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="28fde770cd23cbf2148c8964569ce69fb61dc2a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;http, server, location&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;上下文：&lt;/strong&gt;&lt;em&gt;http，服务器，位置&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c4ddd24271a21df0d75b8bfd4babaf47247c1d19" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;http&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;http&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e30d80c1c0066cb0df691dcd35ba04fb68cbb198" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;init_by_lua*, init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;上下文：&lt;/strong&gt;&lt;em&gt;init_by_lua *，init_worker_by_lua *，set_by_lua *，rewrite_by_lua *，access_by_lua *，content_by_lua *，header_filter_by_lua *，body_filter_by_lua *，log_by_lua *，ngx.timer。*。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9fc6b5ea1b381bc8f84ab22a660a4514187d00db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;init_by_lua*, init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;上下文：&lt;/strong&gt;&lt;em&gt;init_by_lua *，init_worker_by_lua *，set_by_lua *，rewrite_by_lua *，access_by_lua *，content_by_lua *，header_filter_by_lua *，body_filter_by_lua *，log_by_lua *，ngx.timer。**，balancer_ate&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="662ad0d242d37d96b7bd1b2fd12e6c75ff5591d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, *log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;上下文：&lt;/strong&gt;&lt;em&gt;init_by_lua *，set_by_lua *，rewrite_by_lua *，access_by_lua *，content_by_lua *，header_filter_by_lua *，body_filter_by_lua *，* log_by_lua *，ngx.timer。*，balancer_by_lua *，sby_session，sby_session，&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="135796c7a443365dcf5e0cd08a617f380088b3d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;上下文：&lt;/strong&gt;&lt;em&gt;init_by_lua *，set_by_lua *，rewrite_by_lua *，access_by_lua *，content_by_lua *，header_filter_by_lua *，body_filter_by_lua *，log_by_lua *，ngx.timer。*，balancer_by_lua *，sby_session_session_session_session_by_lua *，ssl_session_session&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5b4720d53688b0fdc2cfcc8cb6ae7d4575baa6aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;上下文：&lt;/strong&gt;&lt;em&gt;init_worker_by_lua *，set_by_lua *，rewrite_by_lua *，access_by_lua *，content_by_lua *，header_filter_by_lua *，body_filter_by_lua *，log_by_lua *，ngx.timer。*，balancer_by_lua_by_lus_by_lus_by_session_by_lus_by_slus_by_slus_by_lus_by_slus_by_lus_by_slus_by_slus_by_slua * session_by_slus * byss，&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="80ab129a27a8fd7550cc8884ffae5be356f5c5ee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;上下文：&lt;/strong&gt;&lt;em&gt;init_worker_by_lua *，set_by_lua *，rewrite_by_lua *，access_by_lua *，content_by_lua *，header_filter_by_lua *，body_filter_by_lua *，log_by_lua *，ngx.timer。*，balancer_by_lua *&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f781471ea9531245da6333d25380cbfa3709c912" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;location, location if&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;上下文：&lt;/strong&gt;&lt;em&gt;位置，位置，如果&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ad64e8d91d0fd4d8a4474031534c12c736b93f9c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;上下文：&lt;/strong&gt;&lt;em&gt;rewrite_by_lua *，access_by_lua *，content_by_lua *，header_filter_by_lua *，body_filter_by_lua *，log_by_lua *&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d1247c485ce41eea2b57c759449c6dd87e0fde3f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;上下文：&lt;/strong&gt;&lt;em&gt;rewrite_by_lua *，access_by_lua *，content_by_lua *，header_filter_by_lua *，ngx.timer。*，balancer_by_lua *，ssl_certificate_by_lua *，ssl_session_fetch_by_lua *，ssl_session_store_by_lua *&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="580d93183f00557c35f3b281031132b63fd72ed1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;rewrite_by_lua*, access_by_lua*, content_by_lua*, init_by_lua*, ngx.timer.*, header_filter_by_lua*, body_filter_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;上下文：&lt;/strong&gt;&lt;em&gt;rewrite_by_lua *，access_by_lua *，content_by_lua *，init_by_lua *，ngx.timer。*，header_filter_by_lua *，body_filter_by_lua *，ssl_certificate_by_lua *，ssl_session_fetch_by_lua *，ssl_session_fetch_by_lua *&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bbdc05b583cdcdb1aeca3508613275d8eb2ced3c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;rewrite_by_lua*, access_by_lua*, content_by_lua*, log_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;上下文：&lt;/strong&gt;&lt;em&gt;rewrite_by_lua *，access_by_lua *，content_by_lua *，log_by_lua *&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4a68914357ccc15e9764ade7b1aa36b6f76b2d3b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;上下文：&lt;/strong&gt;&lt;em&gt;rewrite_by_lua *，access_by_lua *，content_by_lua *，ngx.timer。*，ssl_certificate_by_lua *，ssl_session_fetch_by_lua *&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fda2feb781f539372163fd85f7c63276f714cca3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;上下文：&lt;/strong&gt;&lt;em&gt;rewrite_by_lua *，access_by_lua *，content_by_lua *，ngx.timer。*&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c73314d53be1d6921bef852af274c59d44a3f270" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;rewrite_by_lua*, access_by_lua*, content_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;上下文：&lt;/strong&gt;&lt;em&gt;rewrite_by_lua *，access_by_lua *，content_by_lua *&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1732b80c3ef85c27f0ce2b06c429b66367eef0a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;server, server if, location, location if&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;上下文：&lt;/strong&gt;&lt;em&gt;服务器，服务器是否，位置，位置是否&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dfe5964f15f2d19fccd2e112d8ba541c4df839af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;server&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;server&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1822323b78d80942ba412c0ffa55d7c1d5dc80d7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;set_by_lua*, body_filter_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;上下文：&lt;/strong&gt;&lt;em&gt;set_by_lua *，body_filter_by_lua *&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cfe9eed0aa40292fedb79de2498235ed4e3043c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, balancer_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;上下文：&lt;/strong&gt;&lt;em&gt;set_by_lua *，rewrite_by_lua *，access_by_lua *，content_by_lua *，header_filter_by_lua *，balancer_by_lua *&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="74a887e8cb2a29fcde327aded6c93d66e5440831" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, balancer_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;上下文：&lt;/strong&gt;&lt;em&gt;set_by_lua *，rewrite_by_lua *，access_by_lua *，content_by_lua *，header_filter_by_lua *，body_filter_by_lua *，log_by_lua *，balancer_by_lua *&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e7bb913e6dffd88e78f03baffcd5c8c80de01e9a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;上下文：&lt;/strong&gt;&lt;em&gt;set_by_lua *，rewrite_by_lua *，access_by_lua *，content_by_lua *，header_filter_by_lua *，body_filter_by_lua *，log_by_lua *，ngx.timer。*，balancer_by_lua *，ssl_certificate_by_luby *，ss_certificate_by_slby *，&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fa641c80e555fb25f43684bde663e69ea7a8d6a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;上下文：&lt;/strong&gt;&lt;em&gt;set_by_lua *，rewrite_by_lua *，access_by_lua *，content_by_lua *，header_filter_by_lua *，body_filter_by_lua *，log_by_lua *，ngx.timer。*，balancer_by_lua *，ssl_certificate_by_lua *&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f58340cd6038da611e6233091a829704d9e75ec5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*, init_worker_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;上下文：&lt;/strong&gt;&lt;em&gt;set_by_lua *，rewrite_by_lua *，access_by_lua *，content_by_lua *，header_filter_by_lua *，body_filter_by_lua *，log_by_lua *，ngx.timer。*，init_by_lua *，init_worker_by_lua *&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a19577126c833bf9495ddda33b5e2b35d7fb625e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;上下文：&lt;/strong&gt;&lt;em&gt;set_by_lua *，rewrite_by_lua *，access_by_lua *，content_by_lua *，header_filter_by_lua *，body_filter_by_lua *，log_by_lua *，ngx.timer。*，init_by_lua *&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="36483684be27fc578980ed7aac12a50e06c74e1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_worker_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;上下文：&lt;/strong&gt;&lt;em&gt;set_by_lua *，rewrite_by_lua *，access_by_lua *，content_by_lua *，header_filter_by_lua *，body_filter_by_lua *，log_by_lua *，ngx.timer。*，init_worker_by_lua *&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f2a738257d2663b0f10b6d1aea039752fc3a8464" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;上下文：&lt;/strong&gt;&lt;em&gt;set_by_lua *，rewrite_by_lua *，access_by_lua *，content_by_lua *，header_filter_by_lua *，body_filter_by_lua *，log_by_lua *&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5a0ce59a205d0d717544734b467fdec23d0a2ee9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;上下文：&lt;/strong&gt;&lt;em&gt;set_by_lua *，rewrite_by_lua *，access_by_lua *，content_by_lua *，header_filter_by_lua *，body_filter_by_lua *&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4cd7b666d763feebe102a043988a98dee382e6fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;上下文：&lt;/strong&gt;&lt;em&gt;set_by_lua *，rewrite_by_lua *，access_by_lua *，content_by_lua *，header_filter_by_lua *&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="515953e6011d7b7b57299fbb5e789a211be892eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;上下文：&lt;/strong&gt;&lt;em&gt;set_by_lua *，rewrite_by_lua *，access_by_lua *，content_by_lua *&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="596d2715f990420e738aeaf6e6b2acbffd3720af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;upstream&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;context:&lt;/strong&gt;&lt;em&gt;upstream&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9c222f2bc340b6acdddcfc1f6f935d370e581f44" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;The content of LUA_CPATH environment variable or Lua's compiled-in defaults.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;default：&lt;/strong&gt;&lt;em&gt;LUA_CPATH环境变量的内容或Lua内置的默认值。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="15b2935ec0184cd3b7418733f8be3612550a58db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;The content of LUA_PATH environment variable or Lua's compiled-in defaults.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;default：&lt;/strong&gt;&lt;em&gt;LUA_PATH环境变量的内容或Lua的内置默认值。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3e7b05c7ed3f14eb1d4d6945d8ff52dafaf92dc9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;access_by_lua_no_postpone off&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;默认值：&lt;/strong&gt;&lt;em&gt;access_by_lua_no_postpone关闭&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f1ec09bcf1767735e59fa31d077e735f3ebaae8a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_check_client_abort off&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;默认值：&lt;/strong&gt;&lt;em&gt;lua_check_client_abort关闭&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="05e66421217274c64c41d35e4bfb0fb7d234af66" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_code_cache on&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;默认值：&lt;/strong&gt;&lt;em&gt;lua_code_cache on&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8f4289fc26463fde7d174ae3cc94655d7dccb3e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_http10_buffering on&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;默认值：&lt;/strong&gt;&lt;em&gt;lua_http10_buffering on&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f04d0f16c41d1659e533f7ffdf3b4e31e19076e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_malloc_trim 1000&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;默认值：&lt;/strong&gt;&lt;em&gt;lua_malloc_trim 1000&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e92023a488ce5de52a1eb15828bd656513ff9931" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_max_pending_timers 1024&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;默认值：&lt;/strong&gt;&lt;em&gt;lua_max_pending_timers 1024&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bbee947eedb365efd22faba04914108113192227" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_max_running_timers 256&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;默认值：&lt;/strong&gt;&lt;em&gt;lua_max_running_timers 256&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="50f68fe09e85a64408fbac412964754d3feef240" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_regex_cache_max_entries 1024&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;默认值：&lt;/strong&gt;&lt;em&gt;lua_regex_cache_max_entries 1024&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6a2b9dabb511e0f1e05b328e9c63540b50283b29" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_regex_match_limit 0&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;默认值：&lt;/strong&gt;&lt;em&gt;lua_regex_match_limit 0&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3e6b25eba49eec1840a2249e12e1e22aa1bf22d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_socket_buffer_size 4k/8k&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;默认值：&lt;/strong&gt;&lt;em&gt;lua_socket_buffer_size 4k / 8k&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="856b6db73b5936ed8354c52a8f09eca344f0bea4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_socket_connect_timeout 60s&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;默认值：&lt;/strong&gt;&lt;em&gt;lua_socket_connect_timeout 60s&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="460245fa3724c36e2ec1143f2d45ef6a620512bf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_socket_keepalive_timeout 60s&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;默认值：&lt;/strong&gt;&lt;em&gt;lua_socket_keepalive_timeout 60s&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="593c2760a0e70a9e4f4660af041aaa2412cb9a55" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_socket_log_errors on&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;默认值：&lt;/strong&gt;&lt;em&gt;lua_socket_log_errors on&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3f32637daa3ba2242c3c64cac6b6addb1561e01f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_socket_pool_size 30&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;默认值：&lt;/strong&gt;&lt;em&gt;lua_socket_pool_size 30&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b90bb1634aa22092b9492d088f2dee42352bfa35" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_socket_read_timeout 60s&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;默认值：&lt;/strong&gt;&lt;em&gt;lua_socket_read_timeout 60s&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9752a467f619e314332eb3020626755dd28c81b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_socket_send_lowat 0&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;默认值：&lt;/strong&gt;&lt;em&gt;lua_socket_send_lowat 0&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7eb80a4a5ad69b1d36f249f4f25a5741f297ff36" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_socket_send_timeout 60s&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;默认值：&lt;/strong&gt;&lt;em&gt;lua_socket_send_timeout 60s&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2985b7f2c4f6db303cdf3b9c49c34a49409fa4aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_ssl_ciphers DEFAULT&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;默认值：&lt;/strong&gt;&lt;em&gt;lua_ssl_ciphers默认&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="87f6c96e4b0f4a2cb024bbc976dc25e11c39d0a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;默认值：&lt;/strong&gt;&lt;em&gt;lua_ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="469817314aceb9b664e63456976be7dc276b8085" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_ssl_verify_depth 1&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;默认值：&lt;/strong&gt;&lt;em&gt;lua_ssl_verify_depth 1&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="50004caa57dd0220f49ded7e44c082acbe2fbd44" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_transform_underscores_in_response_headers on&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;默认值：&lt;/strong&gt;&lt;em&gt;打开lua_transform_underscores_in_response_headers&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="77fbcaae2d4adf350abcd3cae3d61480e0428f4c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;lua_use_default_type on&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;默认值：&lt;/strong&gt;&lt;em&gt;lua_use_default_type on&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ec7f1dba0da5e143d8c13bd8df264204e96114e2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;no&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;no&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c9c54024b8806eb61b4cb4e5f5600245bfddb1e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;none&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;none&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="221ab2e3f7ad7e98888c8e7756c198ce44f4429d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;off&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;off&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="04c93fb18e655e87951123dd83aaea8584a88910" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default:&lt;/strong&gt;&lt;em&gt;rewrite_by_lua_no_postpone off&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;默认值：&lt;/strong&gt;&lt;em&gt;rewrite_by_lua_no_postpone关闭&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a8f9afc5f8a35a4ec179b0ca7f3b48be9f6dd777" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;optional requirement:&lt;/strong&gt;&lt;code&gt;resty.core.shdict&lt;/code&gt; or &lt;code&gt;resty.core&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;可选要求：&lt;/strong&gt; &lt;code&gt;resty.core.shdict&lt;/code&gt; 或 &lt;code&gt;resty.core&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="87b65dea68ad285d43162873715a960528e517e0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;access tail&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;阶段：&lt;/strong&gt;&lt;em&gt;接尾&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="11cf2f4f5ce7c7f355e9b6063e445fe4fac2f7ee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;content&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;content&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8b4e84c8fdee3f00da0fbd96e152b662a3d3e817" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;depends on usage&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;阶段：&lt;/strong&gt;&lt;em&gt;取决于用法&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cf825d2a1c1749e60096a40099f87b7b1d3272ea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;loading-config&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;loading-config&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4ecaaf91c1fb035e3a4b395a08c1a574ac59988d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;log&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;log&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d418a6df0cafbdd2ce578a3294ae9f2d405aa78e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;output-body-filter&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;output-body-filter&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="459860cf873bc87e2aaaa543ce2607db51f858f2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;output-header-filter&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;output-header-filter&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9232d7df1b0797bbd2ba00ae60d3e9083730d1d1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;rewrite tail&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;阶段：&lt;/strong&gt;&lt;em&gt;重写尾部&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f5535de0c6c0cfac9db50d15bde28da2bd88abb0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;rewrite&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;rewrite&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="60696083b06222a6ce52341c8f3e1de18f287a33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;right-after-SSL-handshake&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;right-after-SSL-handshake&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="39caa09c1338c9267193cce4b738b432477da7fa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;right-before-SSL-handshake&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;right-before-SSL-handshake&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b398522805602ec8e8aab0a670c55fb75da31829" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;starting-worker&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;phase:&lt;/strong&gt;&lt;em&gt;starting-worker&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5cf398d1ecf94338ae834af7fdfe39672f10c717" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;requires:&lt;/strong&gt;&lt;code&gt;resty.core.shdict&lt;/code&gt; or &lt;code&gt;resty.core&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;需要：&lt;/strong&gt; &lt;code&gt;resty.core.shdict&lt;/code&gt; 或 &lt;code&gt;resty.core&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="89336c9ea14910b3e81260a5964784a5504f1481" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;... = coroutine.yield(...)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;... = coroutine.yield（...）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="71e16786b9a5bc4913e74cd81d5994beb767ff20" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;access_by_lua &amp;lt;lua-script-str&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;access_by_lua &amp;lt;lua-script-str&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4d1a7c90b913fcba94965f8eb5a565c66358e7ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;access_by_lua_block { lua-script }&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;access_by_lua_block {lua-script}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="053963ef10137a03820c7a2e3c645fdbebfffa8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;access_by_lua_file &amp;lt;path-to-lua-script-file&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;access_by_lua_file &amp;lt;lua脚本文件路径&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1d2fa6e568ca6365808529bde15f48a6cad570e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;access_by_lua_no_postpone on|off&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;access_by_lua_no_postpone开|关&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8321cf9678815762027405a0fe406ce5138264a4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;args, err = ngx.req.get_post_args(max_args?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;args，err = ngx.req.get_post_args（max_args？）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="37edd68dab54d0bc6e7d2fa1b36ac96d7a1feed3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;args, err = ngx.req.get_uri_args(max_args?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;args，err = ngx.req.get_uri_args（max_args？）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="934567ae15c08064a627e94cc9a333ff045bb5a9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;balancer_by_lua_block { lua-script }&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;balancer_by_lua_block {lua-script}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="161e97059192d9ff2678f1f3b8f1694e36b17156" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;balancer_by_lua_file &amp;lt;path-to-lua-script-file&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;balancer_by_lua_file &amp;lt;lua脚本文件路径&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3fb78eb4c0958e9a86f59ce698840b93c7fc75da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;body_filter_by_lua &amp;lt;lua-script-str&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;body_filter_by_lua &amp;lt;lua-script-str&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9b49b3ec39e1948942595e2d91b91e9b7dcd9906" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;body_filter_by_lua_block { lua-script-str }&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;body_filter_by_lua_block {lua-script-str}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="17922540aef96060779a2fd7d897b1e21e84c111" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;body_filter_by_lua_file &amp;lt;path-to-lua-script-file&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;body_filter_by_lua_file &amp;lt;路径到lua脚本文件&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a99e2dba095475612fb450722fee0f60212d6c85" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;bytes, err = tcpsock:send(data)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;字节，错误= tcpsock：send（data）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b5a44dc474c2f5fa70462528050afab3cf2d0689" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;capacity_bytes = ngx.shared.DICT:capacity()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;Capacity_bytes = ngx.shared.DICT：capacity（）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ee7da351687fc07189da4a88723199a118239368" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;captures, err = ngx.re.match(subject, regex, options?, ctx?, res_table?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;捕获，错误= ngx.re.match（主题，正则表达式，选项？，ctx，res_table？）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e01cb6d5c8c311904c7d8663fcd2fd0b7dd7a5a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;co = coroutine.create(f)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;co = coroutine.create（f）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5b4252b1ae3b9b4d633b513d2bc75c56559b0fbc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;co = coroutine.running()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;co = coroutine.running（）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8091a86ad45f624d801265f23ab92977221209e0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;co = coroutine.wrap(f)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;co = coroutine.wrap（f）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2f9823bfeae10df941f50497209cdf018da9a598" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;co = ngx.thread.spawn(func, arg1, arg2, ...)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;co = ngx.thread.spawn（func，arg1，arg2，...）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9b61349bd4007492cb88b98b3fa733c20bef45ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;content_by_lua &amp;lt;lua-script-str&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;content_by_lua &amp;lt;lua-script-str&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3c6e66a39884fedd38e76e390a2c5be0b8819edb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;content_by_lua_block { lua-script }&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;content_by_lua_block {lua-script}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="96c462c68cc7f5fde2df4978937197685a19467b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;content_by_lua_file &amp;lt;path-to-lua-script-file&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;content_by_lua_file &amp;lt;lua脚本文件路径&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c3a34d5c8d8ce7d19f3cbb197489a40b887a74f1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;count = ngx.timer.pending_count()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;count = ngx.timer.pending_count（）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6e4b5c6334856fab2681989b4b281ebc79517e97" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;count = ngx.timer.running_count()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;count = ngx.timer.running_count（）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a8794918bf50a605db35c8287d37270a0d0d6f2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;count = ngx.worker.count()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;count = ngx.worker.count（）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fd42f5003fe32214356b090a1c1434cc72803d96" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;count = ngx.worker.id()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;count = ngx.worker.id（）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="07d49202784cc9fb9bf6fbe6fc366642e4a93d70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;count, err = tcpsock:getreusedtimes()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;count，err = tcpsock：getreusedtimes（）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b96b81313a0f31768908e5e8b122acaa821b2c9e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;data = ngx.req.get_body_data()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;data = ngx.req.get_body_data（）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5aadddad5374ba27030c7c1dce86f6090b09def6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;data, err = udpsock:receive(size?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;数据，错误= udpsock：receive（size？）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="70930490ee56ed61169c84fd365452957883c7f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;data, err, partial = tcpsock:receive(pattern?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;数据，错误，部分= tcpsock：receive（pattern？）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="348b7abec0e99eadcc3ed9fac19f6747af72a08d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;data, err, partial = tcpsock:receive(size)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;数据，错误，部分= tcpsock：receive（size）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b3e83ed30baf89c73d43e775b4cf8d32d26430f1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;debug = ngx.config.debug&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;debug = ngx.config.debug&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="538d31a0d239e5960a5e8dca13ff6f1ae806bd01" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;dict = ngx.shared.DICT&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;dict = ngx.shared.DICT&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a1a35a5bb269e68613feca27edad56704044beee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;dict = ngx.shared[name_var]&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;dict = ngx.shared [name_var]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6aa8fd891c7e0c063aeca8b1fec3ae27e92dc9b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;digest = ngx.hmac_sha1(secret_key, str)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;摘要= ngx.hmac_sha1（secret_key，str）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0dec30231fbdcbf82629a560d63c8a5caf48fc7e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;digest = ngx.md5(str)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;摘要= ngx.md5（str）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="56b7a8a45d40b4a0cf71e61489d1f6c8dfb87cd5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;digest = ngx.md5_bin(str)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;摘要= ngx.md5_bin（str）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a31ade5f450bd7d701d0a2e707b8272135ddd9c6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;digest = ngx.sha1_bin(str)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;摘要= ngx.sha1_bin（str）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0ffe6d239811dda77da6cb4f68db9c04ae7217c7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;exiting = ngx.worker.exiting()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;exiting = ngx.worker.exiting（）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="98152ac6430ef583287736fbc997c053d496e982" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;file_name = ngx.req.get_body_file()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;file_name = ngx.req.get_body_file（）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="31718b7c6a175d7a78a37ddc8c201038a0db2d92" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;flushed = ngx.shared.DICT:flush_expired(max_count?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;刷新= ngx.shared.DICT：flush_expired（max_count？）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ad0710db35301ab2f52fdf045a0b861b29846175" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;free_page_bytes = ngx.shared.DICT:free_space()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;free_page_bytes = ngx.shared.DICT：free_space（）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a8723a3a39d9ff0f21c3a7c617db7f85fcf02e16" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;from, to, err = ngx.re.find(subject, regex, options?, ctx?, nth?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;从，到err = ngx.re.find（主题，regex，options，ctx，nth）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ebcefeed4197f0542d3d7ffc4a896a326925b933" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;hdl, err = ngx.timer.at(delay, callback, user_arg1, user_arg2, ...)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;hdl，err = ngx.timer.at（延迟，回调，user_arg1，user_arg2等）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3e1c12873f350e082f71a28f41d75cf3fe0c3d65" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;hdl, err = ngx.timer.every(delay, callback, user_arg1, user_arg2, ...)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;hdl，err = ngx.timer.every（延迟，回调，user_arg1，user_arg2，...）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a0da7fe0767eefe76f1883b028ac59183db7132b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;header_filter_by_lua &amp;lt;lua-script-str&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;header_filter_by_lua &amp;lt;lua-script-str&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6f5fa43f046b2bfd53024dc3cea6e3648d7f7ed8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;header_filter_by_lua_block { lua-script }&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;header_filter_by_lua_block {lua-script}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="99d30246fa4e7bc18d86ea7dddb9ecd8da9f25a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;header_filter_by_lua_file &amp;lt;path-to-lua-script-file&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;header_filter_by_lua_file &amp;lt;lua脚本文件路径&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="40c80a9f382fd40f70061006844db8001b51178e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;headers, err = ngx.req.get_headers(max_headers?, raw?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;标头，错误= ngx.req.get_headers（max_headers ?，原始？）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="12383d8f82fc9dc937aea19500ada0cc383a8f61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;headers, err = ngx.resp.get_headers(max_headers?, raw?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;标头，错误= ngx.resp.get_headers（max_headers ?，原始？）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6fb8a0024307ed226ce2841a8c0e217ac132c6b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;init_by_lua &amp;lt;lua-script-str&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;init_by_lua &amp;lt;lua-script-str&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d468d5914725f11ef5d08766009f28f36ad2a16e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;init_by_lua_block { lua-script }&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;init_by_lua_block {lua-script}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="46a16b848eb59a908f1a2e485b744058087ebf7a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;init_by_lua_file &amp;lt;path-to-lua-script-file&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;init_by_lua_file &amp;lt;lua脚本文件路径&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="946f849d75ec091253b02bf1f6a7f8a016c561e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;init_worker_by_lua &amp;lt;lua-script-str&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;init_worker_by_lua &amp;lt;lua-script-str&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="102066d617540c69c287e49bc5c12d6a4f896de9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;init_worker_by_lua_block { lua-script }&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;init_worker_by_lua_block {lua-script}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="75541bb0decd4b5b964219586941bfd57724bf48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;init_worker_by_lua_file &amp;lt;lua-file-path&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;init_worker_by_lua_file &amp;lt;lua-file-path&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="76354a7b491b26b1ca014d1988b7bb21494397c4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;intval = ngx.crc32_long(str)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;intval = ngx.crc32_long（str）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5b8c19dab98c178fe725fa746464391568dd6772" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;intval = ngx.crc32_short(str)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;intval = ngx.crc32_short（str）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d15efd3265d0912c3fafdf9b41d26cde62211556" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;is_internal = ngx.req.is_internal()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;is_internal = ngx.req.is_internal（）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e6a694978e1a4cb3e23afa64edcbb781b2507484" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;iterator = tcpsock:receiveuntil(pattern, options?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;iterator = tcpsock：receiveuntil（pattern，options？）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0997ce24d7d66ffb6ee1831b32e5402c39168abd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;iterator, err = ngx.re.gmatch(subject, regex, options?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;迭代器，err = ngx.re.gmatch（主题，正则表达式，选项？）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8de9e763a6bc10cc039f71f6a4e4beff2dfb268f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;keys = ngx.shared.DICT:get_keys(max_count?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;keys = ngx.shared.DICT：get_keys（max_count？）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d543126a61d915f8fc05caf2aba3c2845ed5e64a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;len, err = ngx.shared.DICT:llen(key)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;len，err = ngx.shared.DICT：llen（key）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="738652545909d9aa66dd899349c579fdabbaf199" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;length, err = ngx.shared.DICT:lpush(key, value)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;长度，错误= ngx.shared.DICT：lpush（key，value）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ca7971b801bdae68548897db911e27a251de5cb7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;length, err = ngx.shared.DICT:rpush(key, value)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;长度，错误= ngx.shared.DICT：rpush（key，value）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bb469e83e6895b2249a5ec69be57d992d0321030" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;local balancer = require &quot;ngx.balancer&quot;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;本地平衡器=需要&amp;ldquo; ngx.balancer&amp;rdquo;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="08f361dd93db187d963ea9be7aef93ad0f54e191" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;local ocsp = require &quot;ngx.ocsp&quot;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;本地ocsp =要求&amp;ldquo; ngx.ocsp&amp;rdquo;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8ef500cdff0f3a38871b8a51f573418b9c139859" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;local semaphore = require &quot;ngx.semaphore&quot;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;本地信号量=需要&amp;ldquo; ngx.semaphore&amp;rdquo;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5271eb94f2fba51c9745c182fdac4c0ffb3d94c4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;local ssl = require &quot;ngx.ssl&quot;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;local ssl = require&amp;ldquo; ngx.ssl&amp;rdquo;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6cf2327f2c8cda7e51f1fcfd7b9ed5e0113338bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;log_by_lua &amp;lt;lua-script-str&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;log_by_lua &amp;lt;lua-script-str&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a0150bbc390b0e0a2c90fcbc021d7e355be74422" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;log_by_lua_block { lua-script }&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;log_by_lua_block {lua-script}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d9b176450264ccd7ffdc3ebf6d76bd9477e868c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;log_by_lua_file &amp;lt;path-to-lua-script-file&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;log_by_lua_file &amp;lt;路径到lua脚本文件&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6e0838a78e4cfec32332195218890c705e3bb0ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_capture_error_log size&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;lua_capture_error_log大小&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3db508b492f9fba14efd4e8972d7af4b2f095164" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_check_client_abort on|off&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;lua_check_client_abort开|关&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="415ddc56ec14bb8936b9b7dcf619dc7acde0d88f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_code_cache on | off&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;| lua_code_cache 关&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c58c456860940b5a7caacbb81fa121f680787f33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_http10_buffering on|off&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;lua_http10_buffering on | off&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fcb2dc8fe3f1657e6f68eef219740ced95cd2aa6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_malloc_trim &amp;lt;request-count&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;lua_malloc_trim &amp;lt;请求计数&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6cae8cb0d45cf9b8d2432d3836885957ec4a1cf4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_max_pending_timers &amp;lt;count&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;lua_max_pending_timers &amp;lt;计数&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d35bd977d83cb7c01b8c4477c9360db40c5bf765" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_max_running_timers &amp;lt;count&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;lua_max_running_timers &amp;lt;计数&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="31e3549fe454cf0ba75e50a4ef9df34989c23438" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_need_request_body &amp;lt;on|off&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;lua_need_request_body &amp;lt;on | off&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c1ad67dd913ba6b8e5b22dd3b8b3d104cd68411b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_package_cpath &amp;lt;lua-style-cpath-str&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;lua_package_cpath &amp;lt;lua-style-cpath-str&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6a528a6ac20f7e61b551eb0f19c5d40a9793b651" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_package_path &amp;lt;lua-style-path-str&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;lua_package_path &amp;lt;lua-style-path-str&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ba0c94cb931415312543c0744a71eff0a3edec67" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_regex_cache_max_entries &amp;lt;num&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;lua_regex_cache_max_entries &amp;lt;num&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="de3e7858300ee666e2bd910711c863a6eed83916" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_regex_match_limit &amp;lt;num&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;lua_regex_match_limit &amp;lt;num&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ec7c5a843ea69dc5df93c40cfabfe5f49d48ad30" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_shared_dict &amp;lt;name&amp;gt; &amp;lt;size&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;lua_shared_dict &amp;lt;名称&amp;gt; &amp;lt;大小&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a9e846b22026f8daa75441c1649993c416213c61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_socket_buffer_size &amp;lt;size&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;lua_socket_buffer_size &amp;lt;大小&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="615cec3143066ee39549862d4e3fdaf53b0908e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_socket_connect_timeout &amp;lt;time&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;lua_socket_connect_timeout &amp;lt;时间&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5c8bc2d24361c9ad6f1b5b16f73beb1f4644d6c1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_socket_keepalive_timeout &amp;lt;time&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;lua_socket_keepalive_timeout &amp;lt;时间&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="069d6b011c593b0f0256b6992eade73d873efdf8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_socket_log_errors on|off&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;lua_socket_log_errors on | off&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="928223239bd32fa1353360f04fe155b2cfe8e5d1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_socket_pool_size &amp;lt;size&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;lua_socket_pool_size &amp;lt;大小&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="898dd2d4c0a9ccd57ecaa7ada134e6539590fdc9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_socket_read_timeout &amp;lt;time&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;lua_socket_read_timeout &amp;lt;时间&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e0f4ebe8765aaf9d120be47046af731110bec688" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_socket_send_lowat &amp;lt;size&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;lua_socket_send_lowat &amp;lt;大小&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cfeddf7172d4dde1d787bdb9ca625a39b65db91e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_socket_send_timeout &amp;lt;time&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;lua_socket_send_timeout &amp;lt;时间&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="786d2d5819ae65e56731913bc41d7eaec35ccad8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_ssl_ciphers &amp;lt;ciphers&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;lua_ssl_ciphers &amp;lt;密码&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="702773f5ad14212e2ca2c027236f453b2adeae4a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_ssl_crl &amp;lt;file&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;lua_ssl_crl &amp;lt;文件&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5774e90b70107528b765073131d8ffc5a7218f3e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_ssl_protocols [SSLv2] [SSLv3] [TLSv1] [TLSv1.1] [TLSv1.2] [TLSv1.3]&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;lua_ssl_protocols [SSLv2] [SSLv3] [TLSv1] [TLSv1.1] [TLSv1.2] [TLSv1.3]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5b825b61932e753287f9c84763b8e288057b1d1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_ssl_trusted_certificate &amp;lt;file&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;lua_ssl_trusted_certificate &amp;lt;文件&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d26ea391a9b43840b9bc947bc176df4392ca6031" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_ssl_verify_depth &amp;lt;number&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;lua_ssl_verify_depth &amp;lt;数字&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9ee4b4000c1e27ae583edd2da9773cb6c1dca804" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_transform_underscores_in_response_headers on|off&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;lua_transform_underscores_in_response_headers开|关&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="84069949522e73f8f7ac15047c8f4878647e3e7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;lua_use_default_type on | off&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;| lua_use_default_type 关&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f26eea2f0eb865778708bada6c031413d2631bb9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;method_name = ngx.req.get_method()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;method_name = ngx.req.get_method（）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="df6188d6c02724386896b35df3c9057a7da6097d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;newstr = ngx.decode_base64(str)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;newstr = ngx.decode_base64（str）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1a69f2d1bd9cdba59c93eb41a985469a432f1973" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;newstr = ngx.encode_base64(str, no_padding?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;newstr = ngx.encode_base64（str，no_padding？）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0804797e9e313ada49166b4acbdc632ba2918580" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;newstr = ngx.escape_uri(str)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;newstr = ngx.escape_uri（str）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e02eef545e81bba4743fc51bb69f62c90be1db2e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;newstr = ngx.unescape_uri(str)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;newstr = ngx.unescape_uri（str）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="79242463735d27ddb1e70ae599e2a48462d1ca7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;newstr, n, err = ngx.re.gsub(subject, regex, replace, options?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;newstr，n，err = ngx.re.gsub（主题，正则表达式，替换，选项？）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0879df9a3b0144c6450985a024657d097255b81f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;newstr, n, err = ngx.re.sub(subject, regex, replace, options?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;newstr，n，err = ngx.re.sub（主题，正则表达式，替换，选项？）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6709d5d4e3e841df6d9bce11683fd07f920d5987" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;newval, err, forcible? = ngx.shared.DICT:incr(key, value, init?, init_ttl?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;newval，err，强制？= ngx.shared.DICT：incr（key，value，init ?, init_ttl？）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="656572c2da85684d98e82197441467f5f663f218" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.exec(uri, args?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;ngx.exec（uri，args？）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4b4c818f2aae94226b6c30951e21451b314cde9e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.exit(status)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.exit(status)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="09cf38887f26c8077887c5a6b5efe1a697e50c8f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.header.HEADER = VALUE&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;ngx.header.HEADER = VALUE&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2e4e1a3a1671d2e2088184cfa3e5c9d2fb46b1a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.log(log_level, ...)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;ngx.log（log_level，...）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8f4f95956b9b70b4d528ba7bef3d94ba3bd9e16f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.redirect(uri, status?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;ngx.redirect（uri，status？）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="de5b4553b3a6d7796fa6a79c8a90febb556f85f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.append_body(data_chunk)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.append_body(data_chunk)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f57e8645d36d28eacc551a6e0b9b0e9f7e0a6692" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.clear_header(header_name)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.clear_header(header_name)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fb403f6ccf56b4cf748b73bfdf0e5ae1d2fbafc0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.discard_body()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.discard_body()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cd191fa33b2810a98e7800f3ec1261bd9b775da0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.finish_body()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.finish_body()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a7be07cc9678b99dca79822e47e59f5e3783b5b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.init_body(buffer_size?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.init_body(buffer_size?)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2ccb7d325fd974da097b7f1b7e3314f9fb703f16" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.read_body()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.read_body()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a971f2ee416f4516de2272f6c308cd98d848359b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.set_body_data(data)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.set_body_data(data)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5ba4ec27c18c16c578a275bcdec4cbb15d337d53" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.set_body_file(file_name, auto_clean?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;ngx.req.set_body_file（file_name，auto_clean？）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ce116da7e8085ccf372353e2a07a203d90046db0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.set_header(header_name, header_value)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;ngx.req.set_header（标题名称，标题值）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e6eb5e5815a774f26ea20fd9dfeced392f5cdec1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.set_method(method_id)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.set_method(method_id)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="55d623d5981fb21fe70c915384a9f436e6140073" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.set_uri(uri, jump?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;ngx.req.set_uri（uri，jump？）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="699f3ed673166bcf8ba0bfe3d2816dbb7651438a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.set_uri_args(args)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.req.set_uri_args(args)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="421c31783da2b711ceb8133324ebaa09419f94f9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.shared.DICT:delete(key)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.shared.DICT:delete(key)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="03b8da6eab1d6d0b0c62baabfa84f24622e3c682" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.shared.DICT:flush_all()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.shared.DICT:flush_all()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dfb03139fe18e9188001832ec0ad58baa185fca4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.sleep(seconds)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.sleep(seconds)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="08f516fe12ef31a04a5bc712fd6f1b0304c285a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.update_time()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.update_time()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0a401cbf88fc40e958899ddfb571a55f206fb414" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.var.VAR_NAME&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ngx.var.VAR_NAME&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cec1d81451f78083635c2827766229d78a476fcf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;num = ngx.req.http_version()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;num = ngx.req.http_version（）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="69a0a8385cf20701ddd22e392b290559b49e2104" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ok, ... = coroutine.resume(co, ...)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;好的，... = coroutine.resume（co，...）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8d7b3484e1f731530976798eb1942caa031e6bc7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ok, err = ngx.eof()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;好的，错误= ngx.eof（）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d0781d407266aab8057194f8a8537664a23745ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ok, err = ngx.flush(wait?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;好的，错误= ngx.flush（等待？）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="516fc9cc9eab3d466d30c9b02a976e8f20995f7e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ok, err = ngx.on_abort(callback)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;好的，错误= ngx.on_abort（callback）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5790dbcc726a749d7acece3afa1393ecd761a0ca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ok, err = ngx.print(...)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;好的，错误= ngx.print（...）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="04ba7a41f97269eaa3a332bab704ed2cebbb1716" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ok, err = ngx.say(...)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;好的，错误= ngx.say（...）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6213ca173ad10602b6279e4c163e0d752f9ba4ee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ok, err = ngx.send_headers()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;好的，错误= ngx.send_headers（）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7c4555df965505df5f91a172aa71a7c6b6c88bee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ok, err = ngx.shared.DICT:safe_add(key, value, exptime?, flags?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;好的，错误= ngx.shared.DICT：safe_add（key，value，exptime ?, flags？）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="45263483f736355a4cfc4653982b2b4a96f04830" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ok, err = ngx.shared.DICT:safe_set(key, value, exptime?, flags?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;好的，错误= ngx.shared.DICT：safe_set（key，value，exptime ?, flags？）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1d726127cae183389d91e023af0b318c99e03d2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ok, err = ngx.thread.kill(thread)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;好的，错误= ngx.thread.kill（thread）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2a0418088703e203e060bc23bdb2c57d3183da55" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ok, err = tcpsock:close()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;好的，错误= tcpsock：close（）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b7fac3ce74b8b28a9c2c674882d716ed67eb1035" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ok, err = tcpsock:connect(&quot;unix:/path/to/unix-domain.socket&quot;, options_table?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;好的，错误= tcpsock：connect（&amp;ldquo; unix：/path/to/unix-domain.socket&amp;rdquo;，options_table？）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="517148cfe9987746f48fb4a36bde3aa028635c37" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ok, err = tcpsock:connect(host, port, options_table?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;好的，错误= tcpsock：connect（主机，端口，options_table？）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6d5473573e14f37d77de9dc9373c1cf53123b2d0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ok, err = tcpsock:setkeepalive(timeout?, size?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;好的，错误= tcpsock：setkeepalive（超时？，大小？）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="713bce89356d9d3d043064f74bc5c9ece4a60f91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ok, err = udpsock:close()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;好的，错误= udpsock：close（）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b0bedfbafbe6f722124660d4fe2131d0bd7dcf09" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ok, err = udpsock:send(data)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;好的，错误= udpsock：send（data）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cd8ca7c19f86044a09629e4e0bcfb5641b729272" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ok, err = udpsock:setpeername(&quot;unix:/path/to/unix-domain.socket&quot;)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;好的，错误= udpsock：setpeername（&amp;ldquo; unix：/path/to/unix-domain.socket&amp;rdquo;）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="03972164e623cc0459f13c12a467ecf97000d484" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ok, err = udpsock:setpeername(host, port)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;好的，错误= udpsock：setpeername（主机，端口）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="42d26a92d0c26d8be8f3dc2411806dec6ecfd910" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ok, res1, res2, ... = ngx.thread.wait(thread1, thread2, ...)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;ok，res1，res2，... = ngx.thread.wait（thread1，thread2，...）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bd6511cc7039449861e0eb17135051aaac513659" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;pid = ngx.worker.pid()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;pid = ngx.worker.pid（）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="44b4b785663ca4f7c8de7d34ccc71fcd9d4a1d2c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;prefix = ngx.config.prefix()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;前缀= ngx.config.prefix（）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d614b9b9c2166061e09f70c098ed9df5e0fd431c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;print(...)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;print(...)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="098ffa578ece7aa97c276d49979d0fb9b618a3e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;quoted_value = ngx.quote_sql_str(raw_value)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;quoted_value = ngx.quote_sql_str（raw_value）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="81926f009beba04b70aca991b8583cadff57f49e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;res = ndk.set_var.DIRECTIVE_NAME&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;res = ndk.set_var.DIRECTIVE_NAME&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b8a6de09143ae7c083512a6692fdea574983958c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;res = ngx.location.capture(uri, options?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;res = ngx.location.capture（uri，options？）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="51b259795845768504502d498872a65f0d0ec241" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;res1, res2, ... = ngx.location.capture_multi({ {uri, options?}, {uri, options?}, ... })&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;res1，res2，... = ngx.location.capture_multi（{{uri，options？}，{uri，options？}，...}）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2eb0da703db84e61c8d3a5817d521869b6273936" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;rewrite_by_lua &amp;lt;lua-script-str&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;rewrite_by_lua &amp;lt;lua-script-str&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d3b71bf71c6a34f1a8e8089cabc99de10757dc43" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;rewrite_by_lua_block { lua-script }&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;rewrite_by_lua_block {lua-script}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0cfc34addebdb0698754c5506cdbc7e117845f1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;rewrite_by_lua_file &amp;lt;path-to-lua-script-file&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;rewrite_by_lua_file &amp;lt;路径到lua脚本文件&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="470ca90ed4ec829e69ed8d114261b401522e7b46" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;rewrite_by_lua_no_postpone on|off&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;rewrite_by_lua_no_postpone开|关&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="30777f12f3e026b837a3ceb836e7a45cee1b8ba5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;sec = ngx.parse_http_time(str)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;sec = ngx.parse_http_time（str）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="234d42469ae72176234c7133f20a44a36bbc7aad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;secs = ngx.now()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;秒= ngx.now（）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="871ff0f2fba70b719e9e2b3a2108cbc0eecb4539" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;secs = ngx.req.start_time()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;秒= ngx.req.start_time（）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="72c0624bb0c50b26a305c6a75ca22fb8220914f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;secs = ngx.time()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;秒= ngx.time（）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="31f5779a2e6769595dd2153bdb012db7ba20cdf3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;session, err = tcpsock:sslhandshake(reused_session?, server_name?, ssl_verify?, send_status_req?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;会话，错误= tcpsock：sslhandshake（reused_session？，server_name？，ssl_verify？，send_status_req？）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bf57f39999890e4f19f975385aa2fae1005b525d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;set_by_lua $res &amp;lt;lua-script-str&amp;gt; [$arg1 $arg2 ...]&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;set_by_lua $ res &amp;lt;lua-script-str&amp;gt; [$ arg1 $ arg2 ...]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dbde975b17d8bed0954475edf7e35f0abf1d6d6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;set_by_lua_block $res { lua-script }&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;set_by_lua_block $ res {lua-script}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d673f592354ad6f1005658a1ec56c619a55a9dd4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;set_by_lua_file $res &amp;lt;path-to-lua-script-file&amp;gt; [$arg1 $arg2 ...]&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;set_by_lua_file $ res &amp;lt;路径-lua脚本文件&amp;gt; [$ arg1 $ arg2 ...]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="30cc281e5bca589d48b9af54ed7f30515be92da6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ssl_certificate_by_lua_block { lua-script }&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;ssl_certificate_by_lua_block {lua-script}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="13f8dabd88f81b9fdeb79fdd381ea3d1f3968a82" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ssl_certificate_by_lua_file &amp;lt;path-to-lua-script-file&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;ssl_certificate_by_lua_file &amp;lt;路径到lua脚本文件&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="384ec341de463656d237822940c3c6a53cf28905" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ssl_session_fetch_by_lua_block { lua-script }&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;ssl_session_fetch_by_lua_block {lua-script}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e5d318c7946f3c59e0303a0bfbfa1cedb4fd9c24" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ssl_session_fetch_by_lua_file &amp;lt;path-to-lua-script-file&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;ssl_session_fetch_by_lua_file &amp;lt;lua脚本文件路径&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="109446da89da8719e18e032b0f0b730e10ee387b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ssl_session_store_by_lua_block { lua-script }&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;ssl_session_store_by_lua_block {lua-script}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d5e3548b6b93ec9212b780889e06dc3a5568f48c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ssl_session_store_by_lua_file &amp;lt;path-to-lua-script-file&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;ssl_session_store_by_lua_file &amp;lt;路径到lua脚本文件&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b8bf35a68aa8712848dd28b1904dc0275d050b36" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;status = coroutine.status(co)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;状态= coroutine.status（co）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4564bcee5bb7e39c7baa259d1b4f9f3972ba5471" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;str = ngx.config.nginx_configure()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;str = ngx.config.nginx_configure（）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0cf436ee466c8985f347bdfacbcb403650628a34" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;str = ngx.cookie_time(sec)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;str = ngx.cookie_time（sec）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="79f9c3172cc79ef810333dc665a7d13dd2cc4117" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;str = ngx.encode_args(table)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;str = ngx.encode_args（table）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b490d332d8cd93dd83c595879f384a0ea15d4828" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;str = ngx.get_phase()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;str = ngx.get_phase（）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0d401ad75414af1135ba414378cf0a32da9feb67" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;str = ngx.http_time(sec)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;str = ngx.http_time（sec）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9e5aad2546f4ab1c92763ada5616364867b207a0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;str = ngx.localtime()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;str = ngx.localtime（）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="801974afc171f8bc64e7db9658c97c8d9035b57c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;str = ngx.req.raw_header(no_request_line?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;str = ngx.req.raw_header（no_request_line？）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b4c7bff297eef1406d9a0cb27ce6f85b611a3b9a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;str = ngx.today()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;str = ngx.today（）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8331b49a88af2d488a7fde3ae639e4b019482982" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;str = ngx.utctime()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;str = ngx.utctime（）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0b2288727830f3608303762dc5b05df58f9ea28b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;subsystem = ngx.config.subsystem&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;子系统= ngx.config.subsystem&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="93b3363c928c45731160ae3d34bcb16b559a7e48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;success, err = ngx.shared.DICT:expire(key, exptime)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;成功，错误= ngx.shared.DICT：expire（key，exptime）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f9a4bff44b8db05d77da1eead709432d22b6efe6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;success, err, forcible = ngx.shared.DICT:add(key, value, exptime?, flags?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;成功，错误，强制= ngx.shared.DICT：add（key，value，exptime ?, flags？）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1bce16780705a9be10e688709ea30dff9af864c6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;success, err, forcible = ngx.shared.DICT:replace(key, value, exptime?, flags?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;成功，错误，强制= ngx.shared.DICT：replace（key，value，exptime ?, flags？）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e4517a4ff32d0dd0f3bdd6ea337a2ef885053b84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;success, err, forcible = ngx.shared.DICT:set(key, value, exptime?, flags?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;成功，错误，强制= ngx.shared.DICT：set（key，value，exptime ?, flags？）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6317165d713a600da732b897a64252fdff3350f2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;table, err = ngx.decode_args(str, max_args?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;table，err = ngx.decode_args（str，max_args？）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="60ea8ae44b324aaeb92365a377dbaf508cfa8053" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;tcpsock = ngx.socket.tcp()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;tcpsock = ngx.socket.tcp（）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d882d2b59c9250c0d027d211a1134da8f386b11d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;tcpsock, err = ngx.req.socket()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;tcpsock，错误= ngx.req.socket（）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="86b777ba829769605f7ece8c4c6fc01c78428ec9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;tcpsock, err = ngx.req.socket(raw)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;tcpsock，错误= ngx.req.socket（原始）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="696ec2c885d2415e562a0437a6a9dc48561477a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;tcpsock, err = ngx.socket.connect(&quot;unix:/path/to/unix-domain.socket&quot;)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;tcpsock，错误= ngx.socket.connect（&amp;ldquo; unix：/path/to/unix-domain.socket&amp;rdquo;）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f0bb7008a24b94b79fb900a52b7a3ebc61794124" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;tcpsock, err = ngx.socket.connect(host, port)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;tcpsock，错误= ngx.socket.connect（主机，端口）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ab2c204579074fa176a45a286724cb7a288926e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;tcpsock:setoption(option, value?)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;tcpsock：setoption（option，value？）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9370c0db28e002272a5cd13ed13cb22fda4d986c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;tcpsock:settimeout(time)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;tcpsock:settimeout(time)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c56c5bd1c6a8b8e99e046eb18e5017530dd0fed8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;tcpsock:settimeouts(connect_timeout, send_timeout, read_timeout)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;tcpsock：settimeouts（connect_timeout，send_timeout，read_timeout）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="43a077e1fd4cba809e10d317c525daaad238d81b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ttl, err = ngx.shared.DICT:ttl(key)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;ttl，err = ngx.shared.DICT：ttl（key）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1be5c605fc210797c706afbbb0ae86c09b6c7e65" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;udpsock = ngx.socket.udp()&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;udpsock = ngx.socket.udp（）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="40cff8a96c5f71aec02f169d2378050064ebc1ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;udpsock:settimeout(time)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;udpsock:settimeout(time)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1c76604d99a9999391953615a0696da1ef73b70d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;val = ngx.arg[index]&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;val = ngx.arg [index]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7b8bb134273c5f01dd7644e86b90b9fee18fa568" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;val, err = ngx.shared.DICT:lpop(key)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;val，err = ngx.shared.DICT：lpop（key）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ea200478d6c3a657028e2446209a977d5bb54a94" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;val, err = ngx.shared.DICT:rpop(key)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;val，err = ngx.shared.DICT：rpop（key）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4522fa27bd74d4d7fc25b78f5443b9569a20a254" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;value = ngx.header.HEADER&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;值= ngx.header.HEADER&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fdc1c5bd4d315dff6510507c4c45aa25c6d6fcad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;value = ngx.headers_sent&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;值= ngx.headers_sent&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="685e94753d2365c4a0fd5efadfcdcd835db1a181" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;value = ngx.is_subrequest&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;值= ngx.is_subrequest&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ac69e75077b26e2af8380c73746f628669f61fe8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;value, flags = ngx.shared.DICT:get(key)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;值，标志= ngx.shared.DICT：get（key）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="69f53a5fc4dace9c7a300bf24c6c66d6c8ce77d0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;value, flags, stale = ngx.shared.DICT:get_stale(key)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;值，标志，陈旧= ngx.shared.DICT：get_stale（key）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cec31a19ad9a38299b13ea166cb44e6d44388bdd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ver = ngx.config.nginx_version&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;ver = ngx.config.nginx_version&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c394acdfffb47130b77d9d88803c21fb11c372d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;syntax:&lt;/strong&gt;&lt;em&gt;ver = ngx.config.ngx_lua_version&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt;&lt;em&gt;ver = ngx.config.ngx_lua_version&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1b2f9d7e62aa20926b6ce6275e83b38213722def" translate="yes" xml:space="preserve">
          <source>A better way to do background jobs is to use the &lt;a href=&quot;#ngxtimerat&quot;&gt;ngx.timer.at&lt;/a&gt; API.</source>
          <target state="translated">执行后台作业的更好方法是使用&lt;a href=&quot;#ngxtimerat&quot;&gt;ngx.timer.at&lt;/a&gt; API。</target>
        </trans-unit>
        <trans-unit id="44d05ea5a9ecfd859e268f3f79d3cd7f1ec56f2f" translate="yes" xml:space="preserve">
          <source>A lot of the Lua APIs for Nginx are enabled in the context of the timer callbacks, like stream/datagram cosockets (&lt;a href=&quot;#ngxsockettcp&quot;&gt;ngx.socket.tcp&lt;/a&gt; and &lt;a href=&quot;#ngxsocketudp&quot;&gt;ngx.socket.udp&lt;/a&gt;), shared memory dictionaries (&lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;), user coroutines (&lt;a href=&quot;#coroutinecreate&quot;&gt;coroutine.*&lt;/a&gt;), user &quot;light threads&quot; (&lt;a href=&quot;#ngxthreadspawn&quot;&gt;ngx.thread.*&lt;/a&gt;), &lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt;, &lt;a href=&quot;#ngxnow&quot;&gt;ngx.now&lt;/a&gt;/&lt;a href=&quot;#ngxtime&quot;&gt;ngx.time&lt;/a&gt;, &lt;a href=&quot;#ngxmd5&quot;&gt;ngx.md5&lt;/a&gt;/&lt;a href=&quot;#ngxsha1_bin&quot;&gt;ngx.sha1_bin&lt;/a&gt;, are all allowed. But the subrequest API (like &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt;), the &lt;a href=&quot;#ngxreqstart_time&quot;&gt;ngx.req.*&lt;/a&gt; API, the downstream output API (like &lt;a href=&quot;#ngxsay&quot;&gt;ngx.say&lt;/a&gt;, &lt;a href=&quot;#ngxprint&quot;&gt;ngx.print&lt;/a&gt;, and &lt;a href=&quot;#ngxflush&quot;&gt;ngx.flush&lt;/a&gt;) are explicitly disabled in this context.</source>
          <target state="translated">Nginx的许多Lua API在计时器回调的上下文中启用，例如流/数据报协同套接字（&lt;a href=&quot;#ngxsockettcp&quot;&gt;ngx.socket.tcp&lt;/a&gt;和&lt;a href=&quot;#ngxsocketudp&quot;&gt;ngx.socket.udp&lt;/a&gt;），共享内存字典（&lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;），用户协程（&lt;a href=&quot;#coroutinecreate&quot;&gt;coroutine。*&lt;/a&gt;），用户&amp;ldquo;轻线程&amp;rdquo;（&lt;a href=&quot;#ngxthreadspawn&quot;&gt;ngx.thread。*&lt;/a&gt;），&lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt;，&lt;a href=&quot;#ngxnow&quot;&gt;ngx.now&lt;/a&gt; / &lt;a href=&quot;#ngxtime&quot;&gt;ngx.time&lt;/a&gt;，&lt;a href=&quot;#ngxmd5&quot;&gt;ngx.md5&lt;/a&gt; / &lt;a href=&quot;#ngxsha1_bin&quot;&gt;ngx.sha1_bin&lt;/a&gt;都是允许的。但是子请求API（例如&lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt;），&lt;a href=&quot;#ngxreqstart_time&quot;&gt;ngx.req。*&lt;/a&gt; API，下游输出API（例如&lt;a href=&quot;#ngxsay&quot;&gt;ngx.say&lt;/a&gt;，&lt;a href=&quot;#ngxprint&quot;&gt;ngx.print&lt;/a&gt;和&lt;a href=&quot;#ngxflush&quot;&gt;ngx.flush）&lt;/a&gt;）在此情况下被明确禁用。</target>
        </trans-unit>
        <trans-unit id="19dbdb1f31e7869c1065d49847db502f487a4b94" translate="yes" xml:space="preserve">
          <source>A more sophisticated example involving regex substitutions is as follows</source>
          <target state="translated">一个更复杂的例子涉及到regex替换,如下所示</target>
        </trans-unit>
        <trans-unit id="e2f90081479faabde78e4be938ea12e0074bda6d" translate="yes" xml:space="preserve">
          <source>Accessing &lt;code&gt;/lua&lt;/code&gt; will yield the output</source>
          <target state="translated">访问 &lt;code&gt;/lua&lt;/code&gt; 将产生输出</target>
        </trans-unit>
        <trans-unit id="8994d334d874e1a7ba313de7714dfc9ef766f3cf" translate="yes" xml:space="preserve">
          <source>Accessing location &lt;code&gt;/lua&lt;/code&gt; gives</source>
          <target state="translated">访问位置 &lt;code&gt;/lua&lt;/code&gt; 给</target>
        </trans-unit>
        <trans-unit id="736021de18ac533b1900b238c3f33e77ec77ca85" translate="yes" xml:space="preserve">
          <source>According to the current implementation, each &quot;running timer&quot; will take one (fake) connection record from the global connection record list configured by the standard &lt;a href=&quot;http://nginx.org/en/docs/ngx_core_module.html#worker_connections&quot;&gt;worker_connections&lt;/a&gt; directive in &lt;code&gt;nginx.conf&lt;/code&gt;. So ensure that the &lt;a href=&quot;http://nginx.org/en/docs/ngx_core_module.html#worker_connections&quot;&gt;worker_connections&lt;/a&gt; directive is set to a large enough value that takes into account both the real connections and fake connections required by timer callbacks (as limited by the &lt;a href=&quot;#lua_max_running_timers&quot;&gt;lua_max_running_timers&lt;/a&gt; directive).</source>
          <target state="translated">根据当前的实现，每个&amp;ldquo;运行计时器&amp;rdquo;将从 &lt;code&gt;nginx.conf&lt;/code&gt; 中的标准&lt;a href=&quot;http://nginx.org/en/docs/ngx_core_module.html#worker_connections&quot;&gt;worker_connections&lt;/a&gt;指令配置的全局连接记录列表中获取一个（伪）连接记录。因此，请确保将&lt;a href=&quot;http://nginx.org/en/docs/ngx_core_module.html#worker_connections&quot;&gt;worker_connections&lt;/a&gt;指令设置为足够大的值，该值应同时考虑到计时器回调所需的实际连接和虚假连接（受&lt;a href=&quot;#lua_max_running_timers&quot;&gt;lua_max_running_timers&lt;/a&gt;指令限制）。</target>
        </trans-unit>
        <trans-unit id="36df347778ebed9addba2dc65ea73cee56a56f08" translate="yes" xml:space="preserve">
          <source>According to the current implementation, however, if the client closes the connection before the Lua code finishes reading the request body data via &lt;a href=&quot;#ngxreqsocket&quot;&gt;ngx.req.socket&lt;/a&gt;, then ngx_lua will neither stop all the running &quot;light threads&quot; nor call the user callback (if &lt;a href=&quot;#ngxon_abort&quot;&gt;ngx.on_abort&lt;/a&gt; has been called). Instead, the reading operation on &lt;a href=&quot;#ngxreqsocket&quot;&gt;ngx.req.socket&lt;/a&gt; will just return the error message &quot;client aborted&quot; as the second return value (the first return value is surely &lt;code&gt;nil&lt;/code&gt;).</source>
          <target state="translated">但是，根据当前的实现，如果客户端在Lua代码完成通过&lt;a href=&quot;#ngxreqsocket&quot;&gt;ngx.req.socket&lt;/a&gt;读取请求主体数据之前关闭连接，则ngx_lua既不会停止所有正在运行的&amp;ldquo;轻线程&amp;rdquo;，也不会调用用户回调（如果&lt;a href=&quot;#ngxon_abort&quot;&gt;ngx.on_abort&lt;/a&gt;已被调用）。取而代之的是，对&lt;a href=&quot;#ngxreqsocket&quot;&gt;ngx.req.socket&lt;/a&gt;的读取操作将仅返回错误消息&amp;ldquo;客户端已中止&amp;rdquo;作为第二个返回值（第一个返回值肯定为 &lt;code&gt;nil&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ff2eed6c4ed83cfc3a5f2bf7341c235edc945945" translate="yes" xml:space="preserve">
          <source>According to the current implementation, only the parent coroutine (or &quot;light thread&quot;) can kill a thread. Also, a running &quot;light thread&quot; with pending NGINX subrequests (initiated by &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt; for example) cannot be killed due to a limitation in the NGINX core.</source>
          <target state="translated">根据当前的实现，只有父协程（或&amp;ldquo;轻线程&amp;rdquo;）才能杀死线程。此外，由于NGINX核心的限制，无法杀死正在运行的带有未决NGINX子请求（例如，由&lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt;发起）的&amp;ldquo;轻线程&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="5485d527dcfe94cf83beda31fd899da662f891e3" translate="yes" xml:space="preserve">
          <source>According to the current implementation, this function can only be called once in a single request handler; subsequent calls will return the error message &quot;duplicate call&quot;.</source>
          <target state="translated">根据目前的实现,该函数在单个请求处理程序中只能调用一次,后续调用将返回错误信息 &quot;重复调用&quot;。</target>
        </trans-unit>
        <trans-unit id="a82446112292bfd78094871077664e48ccc200ac" translate="yes" xml:space="preserve">
          <source>Acts as a &quot;content handler&quot; and executes Lua code string specified in &lt;code&gt;&amp;lt;lua-script-str&amp;gt;&lt;/code&gt; for every request. The Lua code may make &lt;a href=&quot;#nginx-api-for-lua&quot;&gt;API calls&lt;/a&gt; and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).</source>
          <target state="translated">充当&amp;ldquo;内容处理程序&amp;rdquo;，并针对每个请求执行 &lt;code&gt;&amp;lt;lua-script-str&amp;gt;&lt;/code&gt; 中指定的Lua代码字符串。Lua代码可以进行&lt;a href=&quot;#nginx-api-for-lua&quot;&gt;API调用，&lt;/a&gt;并在独立的全局环境（即沙箱）中作为新生成的协程执行。</target>
        </trans-unit>
        <trans-unit id="ab78ec3cb23500dc84ad57ebac431b0cc3322da5" translate="yes" xml:space="preserve">
          <source>Acts as a rewrite phase handler and executes Lua code string specified in &lt;code&gt;&amp;lt;lua-script-str&amp;gt;&lt;/code&gt; for every request. The Lua code may make &lt;a href=&quot;#nginx-api-for-lua&quot;&gt;API calls&lt;/a&gt; and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).</source>
          <target state="translated">充当重写阶段处理程序，并针对每个请求执行 &lt;code&gt;&amp;lt;lua-script-str&amp;gt;&lt;/code&gt; 中指定的Lua代码字符串。Lua代码可以进行&lt;a href=&quot;#nginx-api-for-lua&quot;&gt;API调用，&lt;/a&gt;并在独立的全局环境（即沙箱）中作为新生成的协程执行。</target>
        </trans-unit>
        <trans-unit id="edab06aa80d252e0400fc7d719ad4028532320ba" translate="yes" xml:space="preserve">
          <source>Acts as an access phase handler and executes Lua code string specified in &lt;code&gt;&amp;lt;lua-script-str&amp;gt;&lt;/code&gt; for every request. The Lua code may make &lt;a href=&quot;#nginx-api-for-lua&quot;&gt;API calls&lt;/a&gt; and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).</source>
          <target state="translated">充当访问阶段处理程序，并针对每个请求执行 &lt;code&gt;&amp;lt;lua-script-str&amp;gt;&lt;/code&gt; 中指定的Lua代码字符串。Lua代码可以进行&lt;a href=&quot;#nginx-api-for-lua&quot;&gt;API调用，&lt;/a&gt;并在独立的全局环境（即沙箱）中作为新生成的协程执行。</target>
        </trans-unit>
        <trans-unit id="dd3ea021f2718dd67493fea783e7d50b3aee73fb" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;ngx.thread.spawn&lt;/code&gt; returns, the newly-created &quot;light thread&quot; will keep running asynchronously usually at various I/O events.</source>
          <target state="translated">之后 &lt;code&gt;ngx.thread.spawn&lt;/code&gt; 回报，新创建的&amp;ldquo;灯线&amp;rdquo;将继续在不同的I / O事件异步运行一般。</target>
        </trans-unit>
        <trans-unit id="3639ec0f50b0f9a9a60809dc558a8b5d72fef67b" translate="yes" xml:space="preserve">
          <source>All rights reserved.</source>
          <target state="translated">版权所有,不得转载。</target>
        </trans-unit>
        <trans-unit id="18a4b322a141062be4a3ae201c02ab8ab5f13f32" translate="yes" xml:space="preserve">
          <source>All the &lt;a href=&quot;#nginx-api-for-lua&quot;&gt;Nginx API for Lua&lt;/a&gt; can be used in the callback function because the function is run in a special &quot;light thread&quot;, just as those &quot;light threads&quot; created by &lt;a href=&quot;#ngxthreadspawn&quot;&gt;ngx.thread.spawn&lt;/a&gt;.</source>
          <target state="translated">所有&lt;a href=&quot;#nginx-api-for-lua&quot;&gt;用于Lua&lt;/a&gt;的Nginx API都可以在回调函数中使用，因为该函数在特殊的&amp;ldquo;轻线程&amp;rdquo;中运行，就像&lt;a href=&quot;#ngxthreadspawn&quot;&gt;ngx.thread.spawn&lt;/a&gt;创建的那些&amp;ldquo;轻线程&amp;rdquo; 一样。</target>
        </trans-unit>
        <trans-unit id="2b242e7045d7735db34c901ce4469ebd0013b2c7" translate="yes" xml:space="preserve">
          <source>All the Lua code chunks running by &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt;, &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua&lt;/a&gt;, and &lt;a href=&quot;#content_by_lua&quot;&gt;content_by_lua&lt;/a&gt; are in a boilerplate &quot;light thread&quot; created automatically by ngx_lua. Such boilerplate &quot;light thread&quot; are also called &quot;entry threads&quot;.</source>
          <target state="translated">由&lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt;，&lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua&lt;/a&gt;和&lt;a href=&quot;#content_by_lua&quot;&gt;content_by_lua&lt;/a&gt;运行的所有Lua代码块都在ngx_lua自动创建的样板&amp;ldquo;轻线程&amp;rdquo;中。这种样板&amp;ldquo;轻螺纹&amp;rdquo;也称为&amp;ldquo;入口螺纹&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="c336d94d3cc7119e4d2b17c7136a5111c2379aab" translate="yes" xml:space="preserve">
          <source>All these methods are &lt;em&gt;atomic&lt;/em&gt; operations, that is, safe from concurrent accesses from multiple nginx worker processes for the same &lt;code&gt;lua_shared_dict&lt;/code&gt; zone.</source>
          <target state="translated">所有这些方法都是&lt;em&gt;原子&lt;/em&gt;操作，也就是说，对于来自同一 &lt;code&gt;lua_shared_dict&lt;/code&gt; 区域的多个nginx工作进程，不能同时进行访问。</target>
        </trans-unit>
        <trans-unit id="13cff4d565255817db29011fa2c62a28b04b8ff3" translate="yes" xml:space="preserve">
          <source>Almost all the Nginx modules can be used with this ngx_lua module by means of &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt; or &lt;a href=&quot;#ngxlocationcapture_multi&quot;&gt;ngx.location.capture_multi&lt;/a&gt; but it is recommended to use those &lt;code&gt;lua-resty-*&lt;/code&gt; libraries instead of creating subrequests to access the Nginx upstream modules because the former is usually much more flexible and memory-efficient.</source>
          <target state="translated">几乎所有的Nginx模块都可以通过&lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt;或&lt;a href=&quot;#ngxlocationcapture_multi&quot;&gt;ngx.location.capture_multi&lt;/a&gt;与此ngx_lua模块一起使用，但是建议使用这些 &lt;code&gt;lua-resty-*&lt;/code&gt; 库而不是创建子请求来访问Nginx上游模块，因为前者通常更灵活且内存效率更高。</target>
        </trans-unit>
        <trans-unit id="b0fb71d001792f849f1256bf414a7bf2500e3b8e" translate="yes" xml:space="preserve">
          <source>Also note that subrequests just mimic the HTTP interface but there is &lt;em&gt;no&lt;/em&gt; extra HTTP/TCP traffic &lt;em&gt;nor&lt;/em&gt; IPC involved. Everything works internally, efficiently, on the C level.</source>
          <target state="translated">还要注意，子请求仅模仿HTTP接口，但&lt;em&gt;没有&lt;/em&gt;额外的HTTP / TCP通信&lt;em&gt;或&lt;/em&gt; IPC。一切都在C级别内部有效地进行。</target>
        </trans-unit>
        <trans-unit id="ca35fa7e36908a396a0901b9c466db8554c04d4e" translate="yes" xml:space="preserve">
          <source>Also note that this method call terminates the processing of the current request and that it &lt;em&gt;must&lt;/em&gt; be called before &lt;a href=&quot;#ngxsend_headers&quot;&gt;ngx.send_headers&lt;/a&gt; or explicit response body outputs by either &lt;a href=&quot;#ngxprint&quot;&gt;ngx.print&lt;/a&gt; or &lt;a href=&quot;#ngxsay&quot;&gt;ngx.say&lt;/a&gt;.</source>
          <target state="translated">还要注意，此方法调用会终止当前请求的处理，并且&lt;em&gt;必须&lt;/em&gt;在&lt;a href=&quot;#ngxsend_headers&quot;&gt;ngx.send_headers&lt;/a&gt;或显式响应主体输出之前被&lt;a href=&quot;#ngxprint&quot;&gt;ngx.print&lt;/a&gt;或&lt;a href=&quot;#ngxsay&quot;&gt;ngx.say &lt;/a&gt;调用。</target>
        </trans-unit>
        <trans-unit id="fe41a6752e86903d1dbb6173fc8c7aad6cb2317b" translate="yes" xml:space="preserve">
          <source>Also note that this method call terminates the processing of the current request and that it is recommended that a coding style that combines this method call with the &lt;code&gt;return&lt;/code&gt; statement, i.e., &lt;code&gt;return ngx.exit(...)&lt;/code&gt; be used to reinforce the fact that the request processing is being terminated.</source>
          <target state="translated">另请注意，此方法调用终止当前请求的处理，建议将此方法调用与 &lt;code&gt;return&lt;/code&gt; 语句结合使用的编码样式，即 &lt;code&gt;return ngx.exit(...)&lt;/code&gt; 可以用于增强以下事实：请求处理被终止。</target>
        </trans-unit>
        <trans-unit id="df525509004bff82313034478f794813c159141a" translate="yes" xml:space="preserve">
          <source>Also, by default, an &lt;code&gt;__index&lt;/code&gt; metamethod is added to the resulting Lua table and will normalize the keys to a pure lowercase form with all underscores converted to dashes in case of a lookup miss. For example, if a request header &lt;code&gt;My-Foo-Header&lt;/code&gt; is present, then the following invocations will all pick up the value of this header correctly:</source>
          <target state="translated">同样，默认情况下，会将 &lt;code&gt;__index&lt;/code&gt; 元方法添加到生成的Lua表中，并将把键归一化为纯小写形式，所有下划线在查找未命中时都转换为破折号。例如，如果存在请求标头 &lt;code&gt;My-Foo-Header&lt;/code&gt; ，则以下调用将正确地获取此标头的值：</target>
        </trans-unit>
        <trans-unit id="e79f20788c9b831a084b8454905c3f8ad5ba2da4" translate="yes" xml:space="preserve">
          <source>Also, the Lua load balancer can work with the standard upstream connection pool mechanism, i.e., the standard &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive&quot;&gt;keepalive&lt;/a&gt; directive. Just ensure that the &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive&quot;&gt;keepalive&lt;/a&gt; directive is used &lt;em&gt;after&lt;/em&gt; this &lt;code&gt;balancer_by_lua_block&lt;/code&gt; directive in a single &lt;code&gt;upstream {}&lt;/code&gt; configuration block.</source>
          <target state="translated">同样，Lua负载平衡器可以与标准上游连接池机制（即标准&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive&quot;&gt;keepalive&lt;/a&gt;指令）一起使用。只要确保在单个 &lt;code&gt;upstream {}&lt;/code&gt; 配置块中的此 &lt;code&gt;balancer_by_lua_block&lt;/code&gt; 指令&lt;em&gt;之后&lt;/em&gt;使用了&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive&quot;&gt;keepalive&lt;/a&gt;指令即可。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5bfd0d3bc10f0b0f49a46364458a52787db0dffb" translate="yes" xml:space="preserve">
          <source>Also, the bytecode files generated by LuaJIT 2.1 is &lt;em&gt;not&lt;/em&gt; compatible with LuaJIT 2.0, and vice versa. The support for LuaJIT 2.1 bytecode was first added in ngx_lua v0.9.3.</source>
          <target state="translated">另外，由LuaJIT 2.1生成的字节码文件与LuaJIT 2.0 &lt;em&gt;不&lt;/em&gt;兼容，反之亦然。最初在ngx_lua v0.9.3中添加了对LuaJIT 2.1字节码的支持。</target>
        </trans-unit>
        <trans-unit id="eea7425baea660c6b1d7aaf496f812b5548dc2ef" translate="yes" xml:space="preserve">
          <source>Alternatively, a Lua table can be passed for the &lt;code&gt;args&lt;/code&gt; argument for ngx_lua to carry out URI escaping and string concatenation.</source>
          <target state="translated">或者，可以将Lua表传递给ngx_lua 的 &lt;code&gt;args&lt;/code&gt; 参数，以执行URI转义和字符串连接。</target>
        </trans-unit>
        <trans-unit id="87506029fa64e54229dd009ec11b44f73fb5d7e8" translate="yes" xml:space="preserve">
          <source>Alternatively, ngx_lua can be manually compiled into Nginx:</source>
          <target state="translated">另外,ngx_lua也可以手动编译到Nginx中。</target>
        </trans-unit>
        <trans-unit id="07511376cfb7b769595317205037f74e003f07c6" translate="yes" xml:space="preserve">
          <source>Alternatively, the regex pattern can be presented as a long-bracketed Lua string literal by encasing it in &quot;long brackets&quot;, &lt;code&gt;[[...]]&lt;/code&gt;, in which case backslashes have to only be escaped once for the Nginx config file parser.</source>
          <target state="translated">另外，正则表达式模式可以通过在&amp;ldquo;长括号&amp;rdquo;，包裹它被呈现为长括号Lua的字符串字面 &lt;code&gt;[[...]]&lt;/code&gt; ，在这种情况下反斜杠必须只一次Nginx的配置文件分析器逃脱。</target>
        </trans-unit>
        <trans-unit id="7e93113cac1ceb4de1792e2692ac12fee3835591" translate="yes" xml:space="preserve">
          <source>An alternative approach to escaping PCRE sequences is to ensure that Lua code is placed in external script files and executed using the various &lt;code&gt;*_by_lua_file&lt;/code&gt; directives. With this approach, the backslashes are only stripped by the Lua language parser and therefore only need to be escaped once each.</source>
          <target state="translated">转义PCRE序列的另一种方法是确保将Lua代码放置在外部脚本文件中并使用各种 &lt;code&gt;*_by_lua_file&lt;/code&gt; 指令执行。使用这种方法，反斜杠仅由Lua语言解析器剥离，因此每个反斜杠仅需要转义一次。</target>
        </trans-unit>
        <trans-unit id="8ddebaa272efa6d97a34dc782d200f40e02b5a95" translate="yes" xml:space="preserve">
          <source>An optional Lua table can be specified as the last argument to this method to specify various connect options:</source>
          <target state="translated">可以指定一个可选的 Lua 表作为本方法的最后一个参数,以指定各种连接选项。</target>
        </trans-unit>
        <trans-unit id="f08ce6a7318c4d35a087f8fa725c16025cb3e2a6" translate="yes" xml:space="preserve">
          <source>An optional option table can be fed as the second argument, which supports the options:</source>
          <target state="translated">一个可选的选项表可以作为第二个参数输入,它支持选项。</target>
        </trans-unit>
        <trans-unit id="5ed61c282220a519aaaa4b55d1c3198b477d8fd3" translate="yes" xml:space="preserve">
          <source>And below is an example demonstrating the &quot;wait any&quot; model:</source>
          <target state="translated">而下面是一个例子,演示了 &quot;等任何 &quot;模式。</target>
        </trans-unit>
        <trans-unit id="e368f3680374a8553f5d58ef35767a50f2bf718e" translate="yes" xml:space="preserve">
          <source>And it will generate the following output:</source>
          <target state="translated">它将产生以下输出。</target>
        </trans-unit>
        <trans-unit id="765b18203e6db16ef8da296f5a808e316ab9dde2" translate="yes" xml:space="preserve">
          <source>And then we compile this &lt;code&gt;.lua&lt;/code&gt; file to &lt;code&gt;foo.o&lt;/code&gt; file:</source>
          <target state="translated">然后，我们将该 &lt;code&gt;.lua&lt;/code&gt; 文件编译为 &lt;code&gt;foo.o&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="6d14c4deb748a8614c8de8753b138c5367736ffd" translate="yes" xml:space="preserve">
          <source>And this piece of code no longer depends on the external &lt;code&gt;foo.lua&lt;/code&gt; file any more because it has already been compiled into the &lt;code&gt;nginx&lt;/code&gt; executable.</source>
          <target state="translated">而且这段代码不再依赖于外部 &lt;code&gt;foo.lua&lt;/code&gt; 文件，因为它已经被编译到 &lt;code&gt;nginx&lt;/code&gt; 可执行文件中了。</target>
        </trans-unit>
        <trans-unit id="73682d133f06993eecf52633d25512f776b2d6c6" translate="yes" xml:space="preserve">
          <source>Another typical use case is to do SSL handshake traffic control nonblockingly in this context, with the help of the &lt;a href=&quot;https://github.com/openresty/lua-resty-limit-traffic&quot;&gt;lua-resty-limit-traffic#readme&lt;/a&gt; library, for example.</source>
          <target state="translated">另一个典型的用例是在这种情况下，例如通过&lt;a href=&quot;https://github.com/openresty/lua-resty-limit-traffic&quot;&gt;lua-resty-limit-traffic＃readme&lt;/a&gt;库，无阻塞地进行SSL握手流量控制。</target>
        </trans-unit>
        <trans-unit id="7b66d7f631019205433228901f3bf8085dd73028" translate="yes" xml:space="preserve">
          <source>Append new data chunk specified by the &lt;code&gt;data_chunk&lt;/code&gt; argument onto the existing request body created by the &lt;a href=&quot;#ngxreqinit_body&quot;&gt;ngx.req.init_body&lt;/a&gt; call.</source>
          <target state="translated">将由 &lt;code&gt;data_chunk&lt;/code&gt; 参数指定的新数据块追加到&lt;a href=&quot;#ngxreqinit_body&quot;&gt;ngx.req.init_body&lt;/a&gt;调用创建的现有请求主体上。</target>
        </trans-unit>
        <trans-unit id="39511a77e2946857096d3c599882f4429646e6fc" translate="yes" xml:space="preserve">
          <source>Applications:</source>
          <target state="translated">Applications:</target>
        </trans-unit>
        <trans-unit id="b8afb2b558ed07935d5e9d319352159a30910324" translate="yes" xml:space="preserve">
          <source>Arbitrary data values, including Lua closures and nested tables, can be inserted into this &quot;magic&quot; table. It also allows the registration of custom meta methods.</source>
          <target state="translated">任意数据值,包括Lua闭包和嵌套表,都可以插入到这个 &quot;魔法 &quot;表中。它还允许注册自定义元方法。</target>
        </trans-unit>
        <trans-unit id="377cf7f1669cd80da0965a2ddbd03febc6edbf01" translate="yes" xml:space="preserve">
          <source>Arguments without the &lt;code&gt;=&amp;lt;value&amp;gt;&lt;/code&gt; parts are treated as boolean arguments. &lt;code&gt;GET /test?foo&amp;amp;bar&lt;/code&gt; will yield:</source>
          <target state="translated">不包含 &lt;code&gt;=&amp;lt;value&amp;gt;&lt;/code&gt; 部分的参数视为布尔参数。 &lt;code&gt;GET /test?foo&amp;amp;bar&lt;/code&gt; 将产生：</target>
        </trans-unit>
        <trans-unit id="b769f9a3141fd6f4566f46a81d75cff265f32bdd" translate="yes" xml:space="preserve">
          <source>Arguments without the &lt;code&gt;=&amp;lt;value&amp;gt;&lt;/code&gt; parts are treated as boolean arguments. &lt;code&gt;POST /test&lt;/code&gt; with the request body &lt;code&gt;foo&amp;amp;bar&lt;/code&gt; will yield:</source>
          <target state="translated">不包含 &lt;code&gt;=&amp;lt;value&amp;gt;&lt;/code&gt; 部分的参数视为布尔参数。带有请求正文 &lt;code&gt;foo&amp;amp;bar&lt;/code&gt; 的 &lt;code&gt;POST /test&lt;/code&gt; 将产生：</target>
        </trans-unit>
        <trans-unit id="74d1bff5631e418204d6a1e47283ea7d3223128b" translate="yes" xml:space="preserve">
          <source>As a rule of thumb, a 4KB buffer can usually hold about 20 typical error log messages. So do the maths!</source>
          <target state="translated">根据经验,一个4KB的缓冲区通常可以容纳大约20条典型的错误日志信息。所以,请计算一下吧</target>
        </trans-unit>
        <trans-unit id="4817bba79ca65e7d2af7671dfc8e87bf9464986c" translate="yes" xml:space="preserve">
          <source>As from the &lt;code&gt;v0.5.0rc29&lt;/code&gt; release, Nginx variable interpolation is disabled in the &lt;code&gt;&amp;lt;lua-script-str&amp;gt;&lt;/code&gt; argument of this directive and therefore, the dollar sign character (&lt;code&gt;$&lt;/code&gt;) can be used directly.</source>
          <target state="translated">从 &lt;code&gt;v0.5.0rc29&lt;/code&gt; 版本开始，此指令的 &lt;code&gt;&amp;lt;lua-script-str&amp;gt;&lt;/code&gt; 参数禁用了Nginx变量插值，因此，可以直接使用美元符号（ &lt;code&gt;$&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="3ac52a04d1597fb373b1a2a66f85c16131ec5c36" translate="yes" xml:space="preserve">
          <source>As from the &lt;code&gt;v0.5.0rc29&lt;/code&gt; release, the special notation &lt;code&gt;$prefix&lt;/code&gt; or &lt;code&gt;${prefix}&lt;/code&gt; can be used in the search path string to indicate the path of the &lt;code&gt;server prefix&lt;/code&gt; usually determined by the &lt;code&gt;-p PATH&lt;/code&gt; command-line option while starting the Nginx server.</source>
          <target state="translated">从 &lt;code&gt;v0.5.0rc29&lt;/code&gt; 版本开始，可以在搜索路径字符串中使用特殊符号 &lt;code&gt;$prefix&lt;/code&gt; 或 &lt;code&gt;${prefix}&lt;/code&gt; 来表示 &lt;code&gt;server prefix&lt;/code&gt; 的路径，该路径通常由 &lt;code&gt;-p PATH&lt;/code&gt; 命令行选项在启动Nginx时确定服务器。</target>
        </trans-unit>
        <trans-unit id="59ac593cfece82b9cf1be4e70bfce741f9160ce3" translate="yes" xml:space="preserve">
          <source>As from the &lt;code&gt;v0.5.0rc32&lt;/code&gt; release, all &lt;code&gt;*_by_lua_file&lt;/code&gt; configure directives (such as &lt;a href=&quot;#content_by_lua_file&quot;&gt;content_by_lua_file&lt;/a&gt;) support loading Lua 5.1 and LuaJIT 2.0/2.1 raw bytecode files directly.</source>
          <target state="translated">从 &lt;code&gt;v0.5.0rc32&lt;/code&gt; 版本开始，所有 &lt;code&gt;*_by_lua_file&lt;/code&gt; 配置指令（例如&lt;a href=&quot;#content_by_lua_file&quot;&gt;content_by_lua_file&lt;/a&gt;）都支持直接加载Lua 5.1和LuaJIT 2.0 / 2.1原始字节码文件。</target>
        </trans-unit>
        <trans-unit id="142cc5af18b62b921c724aa0bf9695a771687501" translate="yes" xml:space="preserve">
          <source>As from the &lt;code&gt;v0.5.1&lt;/code&gt; release, this method also takes an optional &lt;code&gt;options&lt;/code&gt; table argument to control the behavior. The following options are supported:</source>
          <target state="translated">从 &lt;code&gt;v0.5.1&lt;/code&gt; 版本开始，此方法还采用可选的 &lt;code&gt;options&lt;/code&gt; 表参数来控制行为。支持以下选项：</target>
        </trans-unit>
        <trans-unit id="6a814c35d562709f7d7e66211cc53c65df14f53e" translate="yes" xml:space="preserve">
          <source>As noted earlier, PCRE sequences presented within &lt;code&gt;*_by_lua_block {}&lt;/code&gt; directives (available following the &lt;code&gt;v0.9.17&lt;/code&gt; release) do not require modification.</source>
          <target state="translated">如前所述， &lt;code&gt;*_by_lua_block {}&lt;/code&gt; 指令中提供的PCRE序列（在 &lt;code&gt;v0.9.17&lt;/code&gt; 版本之后可用）不需要修改。</target>
        </trans-unit>
        <trans-unit id="02a250b80a6e00f49e90c9493ca850eb76dddf19" translate="yes" xml:space="preserve">
          <source>As the standard Lua 5.1 interpreter's VM is not fully resumable, the methods &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt;, &lt;a href=&quot;#ngxlocationcapture_multi&quot;&gt;ngx.location.capture_multi&lt;/a&gt;, &lt;a href=&quot;#ngxredirect&quot;&gt;ngx.redirect&lt;/a&gt;, &lt;a href=&quot;#ngxexec&quot;&gt;ngx.exec&lt;/a&gt;, and &lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt; cannot be used within the context of a Lua &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-pcall&quot;&gt;pcall()&lt;/a&gt; or &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-xpcall&quot;&gt;xpcall()&lt;/a&gt; or even the first line of the &lt;code&gt;for ... in ...&lt;/code&gt; statement when the standard Lua 5.1 interpreter is used and the &lt;code&gt;attempt to yield across metamethod/C-call boundary&lt;/code&gt; error will be produced. Please use LuaJIT 2.x, which supports a fully resumable VM, to avoid this.</source>
          <target state="translated">由于标准的Lua 5.1解释器的VM无法完全&lt;a href=&quot;#ngxlocationcapture&quot;&gt;恢复&lt;/a&gt;，&lt;a href=&quot;#ngxlocationcapture_multi&quot;&gt;因此&lt;/a&gt;ngx.location.capture，ngx.location.capture_multi，&lt;a href=&quot;#ngxredirect&quot;&gt;ngx.redirect&lt;/a&gt;，&lt;a href=&quot;#ngxexec&quot;&gt;ngx.exec&lt;/a&gt;和&lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt;方法不能在Lua &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-pcall&quot;&gt;pcall（）&lt;/a&gt;的上下文中使用。或&lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-xpcall&quot;&gt;xpcall（）&lt;/a&gt;或什至在使用标准Lua 5.1解释器时 &lt;code&gt;for ... in ...&lt;/code&gt; 语句的第一行，并且将 &lt;code&gt;attempt to yield across metamethod/C-call boundary&lt;/code&gt; 错误的结果。为了避免这种情况，请使用支持完全可恢复的VM的LuaJIT2.x。</target>
        </trans-unit>
        <trans-unit id="1ee79b73c99a603b36a28f4da8c38f526195ee3d" translate="yes" xml:space="preserve">
          <source>As with other access phase handlers, &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua&lt;/a&gt; will &lt;em&gt;not&lt;/em&gt; run in subrequests.</source>
          <target state="translated">与其他访问阶段处理程序一样，&lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua&lt;/a&gt;将&lt;em&gt;不会&lt;/em&gt;在子请求中运行。</target>
        </trans-unit>
        <trans-unit id="ff647d09b1fc120edc207e7745e7fae020e5a668" translate="yes" xml:space="preserve">
          <source>Asks the underlying &lt;code&gt;libc&lt;/code&gt; runtime library to release its cached free memory back to the operating system every &lt;code&gt;N&lt;/code&gt; requests processed by the NGINX core. By default, &lt;code&gt;N&lt;/code&gt; is 1000. You can configure the request count by using your own numbers. Smaller numbers mean more frequent releases, which may introduce higher CPU time consumption and smaller memory footprint while larger numbers usually lead to less CPU time overhead and relatively larger memory footprint. Just tune the number for your own use cases.</source>
          <target state="translated">要求基础 &lt;code&gt;libc&lt;/code&gt; 运行时库在NGINX内核处理的每 &lt;code&gt;N&lt;/code&gt; 个请求中将其缓存的空闲内存释放回操作系统。默认情况下， &lt;code&gt;N&lt;/code&gt; 为1000。您可以使用自己的数字配置请求计数。较小的数字表示更频繁的发布，这可能会导致较高的CPU时间消耗和较小的内存占用，而较大的数字通常会导致较少的CPU时间开销和相对较大的内存占用。只需调整您自己的用例的数量即可。</target>
        </trans-unit>
        <trans-unit id="e9c872802dede2829e1efc68a335c2e837d0871a" translate="yes" xml:space="preserve">
          <source>At least the following API functions are currently disabled within the context of &lt;code&gt;set_by_lua&lt;/code&gt;:</source>
          <target state="translated">当前至少在 &lt;code&gt;set_by_lua&lt;/code&gt; 上下文中禁用以下API函数：</target>
        </trans-unit>
        <trans-unit id="52269ff0fdd51a17c65d8330fbb4d84c845dbca6" translate="yes" xml:space="preserve">
          <source>At least the following Lua libraries and Nginx modules can be used with this ngx_lua module:</source>
          <target state="translated">至少有以下Lua库和Nginx模块可以和ngx_lua模块一起使用。</target>
        </trans-unit>
        <trans-unit id="d32f4a63defca3d4330f586d59cada672d86fffb" translate="yes" xml:space="preserve">
          <source>Attempts to connect a TCP socket object to a remote server or to a stream unix domain socket file without blocking.</source>
          <target state="translated">试图将TCP套接字对象连接到远程服务器或流unix域套接字文件而不被阻塞。</target>
        </trans-unit>
        <trans-unit id="5c2fdf03e3bcb8a9023c50548184c7a5dc1d93d7" translate="yes" xml:space="preserve">
          <source>Attempts to connect a UDP socket object to a remote server or to a datagram unix domain socket file. Because the datagram protocol is actually connection-less, this method does not really establish a &quot;connection&quot;, but only just set the name of the remote peer for subsequent read/write operations.</source>
          <target state="translated">试图将一个UDP套接字对象连接到远程服务器或数据报unix域套接字文件。因为数据报协议实际上是无连接的,所以这个方法并没有真正建立 &quot;连接&quot;,只是为后续的读/写操作设置远程对等体的名称。</target>
        </trans-unit>
        <trans-unit id="2298af62748ddc8565e6916c92f295142f7d2617" translate="yes" xml:space="preserve">
          <source>Attempts to load standard Lua 5.1 bytecode files into ngx_lua instances linked to LuaJIT 2.0/2.1 or vice versa, will result in an error message, such as that below, being logged into the Nginx &lt;code&gt;error.log&lt;/code&gt; file:</source>
          <target state="translated">尝试将标准Lua 5.1字节码文件加载到链接到LuaJIT 2.0 / 2.1的ngx_lua实例中（反之亦然），将导致错误消息（如下所示）被记录到Nginx &lt;code&gt;error.log&lt;/code&gt; 文件中：</target>
        </trans-unit>
        <trans-unit id="5cc6e7a370a6ae461ad4867e179276ccfbd9f17a" translate="yes" xml:space="preserve">
          <source>Basically you can safely use Lua libraries that do blocking I/O in this very context because blocking the master process during server start-up is completely okay. Even the Nginx core does blocking I/O (at least on resolving upstream's host names) at the configure-loading phase.</source>
          <target state="translated">基本上,你可以在这种情况下安全地使用做阻塞I/O的Lua库,因为在服务器启动时阻塞主进程是完全没问题的,即使是Nginx核心也会在configure-loading阶段做阻塞I/O(至少在解析上游主机名时)。甚至Nginx核心在配置加载阶段也会做阻塞I/O(至少在解析上游的主机名上)。</target>
        </trans-unit>
        <trans-unit id="6fec49ca638189d7ef0e8ba025f476ac935f4924" translate="yes" xml:space="preserve">
          <source>Basically you use the &lt;code&gt;luajit&lt;/code&gt; executable to compile &lt;code&gt;.lua&lt;/code&gt; Lua module files to &lt;code&gt;.o&lt;/code&gt; object files containing the exported bytecode data, and then link the &lt;code&gt;.o&lt;/code&gt; files directly in your Nginx build.</source>
          <target state="translated">基本上，您使用 &lt;code&gt;luajit&lt;/code&gt; 可执行文件将 &lt;code&gt;.lua&lt;/code&gt; Lua模块文件编译为包含导出的字节码数据的 &lt;code&gt;.o&lt;/code&gt; 目标文件，然后将 &lt;code&gt;.o&lt;/code&gt; 文件直接链接到您的Nginx构建中。</target>
        </trans-unit>
        <trans-unit id="a3e3dcf699574118a54b2f7517b617508eb38064" translate="yes" xml:space="preserve">
          <source>Because Lua's &lt;code&gt;dofile&lt;/code&gt; and &lt;code&gt;require&lt;/code&gt; builtins are currently implemented as C functions in both Lua 5.1 and LuaJIT 2.0/2.1, if the Lua file being loaded by &lt;code&gt;dofile&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt; invokes &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture*&lt;/a&gt;, &lt;a href=&quot;#ngxexec&quot;&gt;ngx.exec&lt;/a&gt;, &lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt;, or other API functions requiring yielding in the &lt;em&gt;top-level&lt;/em&gt; scope of the Lua file, then the Lua error &quot;attempt to yield across C-call boundary&quot; will be raised. To avoid this, put these calls requiring yielding into your own Lua functions in the Lua file instead of the top-level scope of the file.</source>
          <target state="translated">因为lua的 &lt;code&gt;dofile&lt;/code&gt; 处理和 &lt;code&gt;require&lt;/code&gt; 建宏目前作为C功能两者的Lua 5.1和2.0 LuaJIT / 2.1实施，如果lua的文件被装载 &lt;code&gt;dofile&lt;/code&gt; 处理或 &lt;code&gt;require&lt;/code&gt; 所调用&lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture *&lt;/a&gt;，&lt;a href=&quot;#ngxexec&quot;&gt;ngx.exec&lt;/a&gt;，&lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt;，或其他API函数需要在Lua文件的&lt;em&gt;顶级&lt;/em&gt;范围内进行屈服，然后会出现Lua错误&amp;ldquo;试图跨越C调用边界屈服&amp;rdquo;。为避免这种情况，请将这些需要屈服的调用放入Lua文件中的自己的Lua函数中，而不是文件的顶级范围中。</target>
        </trans-unit>
        <trans-unit id="28388ab663976d5bd8791cf32f69d11e930b9177" translate="yes" xml:space="preserve">
          <source>Because of the metamethod magic, never &quot;local&quot; the &lt;code&gt;ngx.ctx&lt;/code&gt; table outside your Lua function scope on the Lua module level due to &lt;a href=&quot;#data-sharing-within-an-nginx-worker&quot;&gt;worker-level data sharing&lt;/a&gt;. For example, the following is bad:</source>
          <target state="translated">由于元方法的魔力，由于&lt;a href=&quot;#data-sharing-within-an-nginx-worker&quot;&gt;工作人员级别的数据共享&lt;/a&gt;，永远不要在Lua模块级别的Lua函数作用域之外将 &lt;code&gt;ngx.ctx&lt;/code&gt; 表&amp;ldquo;本地化&amp;rdquo; 。例如，以下是不好的：</target>
        </trans-unit>
        <trans-unit id="cc085d42cb3c86bf7992490ce09f48337af2ea11" translate="yes" xml:space="preserve">
          <source>Because the Lua code in this context runs before Nginx forks its worker processes (if any), data or code loaded here will enjoy the &lt;a href=&quot;http://en.wikipedia.org/wiki/Copy-on-write&quot;&gt;Copy-on-write (COW)&lt;/a&gt; feature provided by many operating systems among all the worker processes, thus saving a lot of memory.</source>
          <target state="translated">由于在这种情况下，Lua代码在Nginx派生其工作进程（如果有）之前运行，因此在此处加载的数据或代码将享受所有操作系统在所有工作进程中提供&lt;a href=&quot;http://en.wikipedia.org/wiki/Copy-on-write&quot;&gt;的写时复制（COW）&lt;/a&gt;功能，从而节省了很多内存。</target>
        </trans-unit>
        <trans-unit id="f5605db73db672c4d88b10182faf4547b8c0ffd3" translate="yes" xml:space="preserve">
          <source>Because this API function does not create new Lua strings nor new Lua tables, it is much faster than &lt;a href=&quot;#ngxrematch&quot;&gt;ngx.re.match&lt;/a&gt;. It should be used wherever possible.</source>
          <target state="translated">由于此API函数不会创建新的Lua字符串或新的Lua表，因此它比&lt;a href=&quot;#ngxrematch&quot;&gt;ngx.re.match快得多&lt;/a&gt;。应尽可能使用它。</target>
        </trans-unit>
        <trans-unit id="0cdb737f889537d826ebf12f06995869afc269f6" translate="yes" xml:space="preserve">
          <source>Because timer callbacks run in the background and their running time will not add to any client request's response time, they can easily accumulate in the server and exhaust system resources due to either Lua programming mistakes or just too much client traffic. To prevent extreme consequences like crashing the Nginx server, there are built-in limitations on both the number of &quot;pending timers&quot; and the number of &quot;running timers&quot; in an Nginx worker process. The &quot;pending timers&quot; here mean timers that have not yet been expired and &quot;running timers&quot; are those whose user callbacks are currently running.</source>
          <target state="translated">由于定时器回调是在后台运行的,它们的运行时间不会增加任何客户端请求的响应时间,所以很容易因为Lua编程错误或者客户端流量过大而在服务器中累积,耗尽系统资源。为了防止出现Nginx服务器崩溃这样的极端后果,Nginx工作进程中的 &quot;待定时器 &quot;和 &quot;运行定时器 &quot;的数量都有内置限制。这里的 &quot;待定时器 &quot;是指尚未过期的定时器,&quot;正在运行的定时器 &quot;是指那些用户回调正在运行的定时器。</target>
        </trans-unit>
        <trans-unit id="7aa9a2875ef4c81f88c80d771a97469ef5422797" translate="yes" xml:space="preserve">
          <source>Before &lt;code&gt;ngx.thread.spawn&lt;/code&gt; returns, the &lt;code&gt;func&lt;/code&gt; will be called with those optional arguments until it returns, aborts with an error, or gets yielded due to I/O operations via the &lt;a href=&quot;#nginx-api-for-lua&quot;&gt;Nginx API for Lua&lt;/a&gt; (like &lt;a href=&quot;#tcpsockreceive&quot;&gt;tcpsock:receive&lt;/a&gt;).</source>
          <target state="translated">在 &lt;code&gt;ngx.thread.spawn&lt;/code&gt; 返回之前，将使用这些可选参数调用 &lt;code&gt;func&lt;/code&gt; ，直到它返回，由于错误而中止或由于通过&lt;a href=&quot;#nginx-api-for-lua&quot;&gt;Lua&lt;/a&gt;的Nginx API的 I / O操作而屈服（例如&lt;a href=&quot;#tcpsockreceive&quot;&gt;tcpsock：receive&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="5245d4cddd8bd64eda850eb993c419e25a8d8726" translate="yes" xml:space="preserve">
          <source>Before actually resolving the host name and connecting to the remote backend, this method will always look up the connection pool for matched idle connections created by previous calls of this method (or the &lt;a href=&quot;#ngxsocketconnect&quot;&gt;ngx.socket.connect&lt;/a&gt; function).</source>
          <target state="translated">在实际解析主机名并连接到远程后端之前，此方法将始终在连接池中查找由此方法（或&lt;a href=&quot;#ngxsocketconnect&quot;&gt;ngx.socket.connect&lt;/a&gt;函数）的先前调用创建的匹配的空闲连接。</target>
        </trans-unit>
        <trans-unit id="9b1ccfb282b9e36abe3e540f74d2b68d1c7be274" translate="yes" xml:space="preserve">
          <source>Behind the scene, it is just a thin wrapper around the &lt;code&gt;ngx_crc32_long&lt;/code&gt; function defined in the Nginx core.</source>
          <target state="translated">在幕后，它只是Nginx核心中定义的 &lt;code&gt;ngx_crc32_long&lt;/code&gt; 函数的薄包装。</target>
        </trans-unit>
        <trans-unit id="fb8e1b77b26209826931f5e18788890e539e2f52" translate="yes" xml:space="preserve">
          <source>Behind the scene, it is just a thin wrapper around the &lt;code&gt;ngx_crc32_short&lt;/code&gt; function defined in the Nginx core.</source>
          <target state="translated">在后台，它只是Nginx核心中定义的 &lt;code&gt;ngx_crc32_short&lt;/code&gt; 函数的一个瘦包装。</target>
        </trans-unit>
        <trans-unit id="3935a12ca0db1eedc35357022379e99b8a802bac" translate="yes" xml:space="preserve">
          <source>Behind the scene, the &quot;eof&quot; flag is just the &lt;code&gt;last_buf&lt;/code&gt; (for main requests) or &lt;code&gt;last_in_chain&lt;/code&gt; (for subrequests) flag of the Nginx chain link buffers. (Before the &lt;code&gt;v0.7.14&lt;/code&gt; release, the &quot;eof&quot; flag does not work at all in subrequests.)</source>
          <target state="translated">在幕后，&amp;ldquo; eof&amp;rdquo;标志只是Nginx链链接缓冲区的 &lt;code&gt;last_buf&lt;/code&gt; （对于主请求）或 &lt;code&gt;last_in_chain&lt;/code&gt; （对于子请求）标志。（在 &lt;code&gt;v0.7.14&lt;/code&gt; 发行版之前，&amp;ldquo; eof&amp;rdquo;标志在子请求中根本不起作用。）</target>
        </trans-unit>
        <trans-unit id="d579ee4c5c8c892e1012408f2840320a50fc6fd6" translate="yes" xml:space="preserve">
          <source>Behind the scene, this method makes use of the Nginx timers.</source>
          <target state="translated">在幕后,这个方法利用了Nginx的定时器。</target>
        </trans-unit>
        <trans-unit id="74784fcd147a7425449e502fe60db7f32d2485eb" translate="yes" xml:space="preserve">
          <source>Below is a trivial example to demonstrate this. Consider that we have the following &lt;code&gt;.lua&lt;/code&gt; file named &lt;code&gt;foo.lua&lt;/code&gt;:</source>
          <target state="translated">下面是一个简单的示例来说明这一点。考虑我们有以下名为 &lt;code&gt;foo.lua&lt;/code&gt; 的 &lt;code&gt;.lua&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="d2cf1e8afa6c4fa7f0608ac88cf472e1af3f8214" translate="yes" xml:space="preserve">
          <source>Below is a trivial example using the &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md&quot;&gt;ngx.ssl&lt;/a&gt; module at the same time:</source>
          <target state="translated">以下是同时使用&lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md&quot;&gt;ngx.ssl&lt;/a&gt;模块的简单示例：</target>
        </trans-unit>
        <trans-unit id="3a70d04c1ef62c14933cff1c5df6d13ef6a06dc8" translate="yes" xml:space="preserve">
          <source>Below is an example:</source>
          <target state="translated">下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="a6ee5b336df565b5a2920bfca52bbec159414950" translate="yes" xml:space="preserve">
          <source>Boolean argument values are also supported, for instance,</source>
          <target state="translated">例如,还支持布尔参数值。</target>
        </trans-unit>
        <trans-unit id="2c4013170b059320690d73b1cea3c90718747378" translate="yes" xml:space="preserve">
          <source>Both IP addresses and domain names can be specified as the &lt;code&gt;host&lt;/code&gt; argument. In case of domain names, this method will use Nginx core's dynamic resolver to parse the domain name without blocking and it is required to configure the &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#resolver&quot;&gt;resolver&lt;/a&gt; directive in the &lt;code&gt;nginx.conf&lt;/code&gt; file like this:</source>
          <target state="translated">IP地址和域名都可以指定为 &lt;code&gt;host&lt;/code&gt; 参数。如果是域名，此方法将使用Nginx核心的动态解析器​​来解析域名而不会阻塞，并且需要在 &lt;code&gt;nginx.conf&lt;/code&gt; 文件中配置&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#resolver&quot;&gt;解析器&lt;/a&gt;指令，如下所示：</target>
        </trans-unit>
        <trans-unit id="9b010286216cbc849fdecb1ec167816122fac8fa" translate="yes" xml:space="preserve">
          <source>Bugs and Patches</source>
          <target state="translated">漏洞和补丁</target>
        </trans-unit>
        <trans-unit id="e289b213785e349d7804f94803f1f350cd03409d" translate="yes" xml:space="preserve">
          <source>Build the source with this module:</source>
          <target state="translated">用这个模块构建源。</target>
        </trans-unit>
        <trans-unit id="777afebeea44fcd442afa109dfa8ae4ad6acff9f" translate="yes" xml:space="preserve">
          <source>Building as a dynamic module</source>
          <target state="translated">作为一个动态模块进行建设</target>
        </trans-unit>
        <trans-unit id="ef1c0d7fe324eb83fec61b3fd56030d2a57bfc05" translate="yes" xml:space="preserve">
          <source>But be very careful about malicious user inputs and always carefully validate or filter out the user-supplied path components.</source>
          <target state="translated">但要非常小心用户的恶意输入,一定要仔细验证或过滤掉用户提供的路径组件。</target>
        </trans-unit>
        <trans-unit id="13f3f8d695fb47e63f2879e1a140ffe7be2a9095" translate="yes" xml:space="preserve">
          <source>But do not forget to comment this line out before publishing your site to the world.</source>
          <target state="translated">但在向世界发布你的网站之前,不要忘记把这一行注释出来。</target>
        </trans-unit>
        <trans-unit id="76de2c4f5adeff8aa8d422f168e13846bb716a34" translate="yes" xml:space="preserve">
          <source>But if you create subrequests to access other locations configured by Nginx upstream modules, then you should configure those upstream modules to ignore client connection abortions if they are not by default. For example, by default the standard &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_proxy_module.html&quot;&gt;ngx_http_proxy_module&lt;/a&gt; will terminate both the subrequest and the main request as soon as the client closes the connection, so it is important to turn on the &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_ignore_client_abort&quot;&gt;proxy_ignore_client_abort&lt;/a&gt; directive in your location block configured by &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_proxy_module.html&quot;&gt;ngx_http_proxy_module&lt;/a&gt;:</source>
          <target state="translated">但是，如果您创建子请求以访问由Nginx上游模块配置的其他位置，则应将这些上游模块配置为忽略客户端连接中止（如果默认情况下不是）。例如，默认情况下，标准&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_proxy_module.html&quot;&gt;ngx_http_proxy_module&lt;/a&gt;会在客户端关闭连接后立即终止子请求和主请求，因此在&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_proxy_module.html&quot;&gt;ngx_http_proxy_module&lt;/a&gt;配置的位置块中打开&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_ignore_client_abort&quot;&gt;proxy_ignore_client_abort&lt;/a&gt;指令很重要：</target>
        </trans-unit>
        <trans-unit id="dc8605cdbf72dbe7967a34c8860108a861c33718" translate="yes" xml:space="preserve">
          <source>But note that, the &lt;a href=&quot;#lua_shared_dict&quot;&gt;lua_shared_dict&lt;/a&gt;'s shm storage will not be cleared through a config reload (via the &lt;code&gt;HUP&lt;/code&gt; signal, for example). So if you do &lt;em&gt;not&lt;/em&gt; want to re-initialize the shm storage in your &lt;code&gt;init_by_lua&lt;/code&gt; code in this case, then you just need to set a custom flag in the shm storage and always check the flag in your &lt;code&gt;init_by_lua&lt;/code&gt; code.</source>
          <target state="translated">但是请注意，不会通过配置重载（例如，通过 &lt;code&gt;HUP&lt;/code&gt; 信号）清除&lt;a href=&quot;#lua_shared_dict&quot;&gt;lua_shared_dict&lt;/a&gt;的shm存储。所以，如果你&lt;em&gt;不&lt;/em&gt;希望在您重新初始化SHM存储 &lt;code&gt;init_by_lua&lt;/code&gt; 在这种情况下的代码，那么你只需要设置在SHM存储自定义的标志和经常检查标志在 &lt;code&gt;init_by_lua&lt;/code&gt; 代码。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="025b165153131ffb429543ba496b3d5978d7e140" translate="yes" xml:space="preserve">
          <source>By default, all the subrequests subsequently initiated by &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt; and &lt;a href=&quot;#ngxlocationcapture_multi&quot;&gt;ngx.location.capture_multi&lt;/a&gt; will inherit the new header.</source>
          <target state="translated">默认情况下，随后由&lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt;和&lt;a href=&quot;#ngxlocationcapture_multi&quot;&gt;ngx.location.capture_multi&lt;/a&gt;发起的所有子请求都将继承新的标头。</target>
        </trans-unit>
        <trans-unit id="9cbb14b03c0cef3dfcea3433cf63f6dd828947dd" translate="yes" xml:space="preserve">
          <source>By default, only the first 1024 keys (if any) are returned. When the &lt;code&gt;&amp;lt;max_count&amp;gt;&lt;/code&gt; argument is given the value &lt;code&gt;0&lt;/code&gt;, then all the keys will be returned even there is more than 1024 keys in the dictionary.</source>
          <target state="translated">默认情况下，仅返回前1024个键（如果有）。当 &lt;code&gt;&amp;lt;max_count&amp;gt;&lt;/code&gt; 参数的值设置为 &lt;code&gt;0&lt;/code&gt; 时，即使字典中有1024个以上的键，也将返回所有键。</target>
        </trans-unit>
        <trans-unit id="38e01d9bc32ddfaf4bfb653b20d7a358a1bfbf95" translate="yes" xml:space="preserve">
          <source>By default, the corresponding Nginx handler (e.g., &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt; handler) will not terminate until</source>
          <target state="translated">默认情况下，相应的Nginx处理程序（例如&lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt;处理程序）将直到终止</target>
        </trans-unit>
        <trans-unit id="e934f7015591f2ded843d4d03c8339134b1608c7" translate="yes" xml:space="preserve">
          <source>By default, the request line and trailing &lt;code&gt;CR LF&lt;/code&gt; terminator will also be included. For example,</source>
          <target state="translated">默认情况下，还将包括请求行和尾随 &lt;code&gt;CR LF&lt;/code&gt; 终结符。例如，</target>
        </trans-unit>
        <trans-unit id="a77d4a1e4cb25b53cee3c37fcae44e5e96e80bbd" translate="yes" xml:space="preserve">
          <source>C Macro Configurations</source>
          <target state="translated">C 宏观配置</target>
        </trans-unit>
        <trans-unit id="fab120f4ade6616bdd48020953a15b3b89454c04" translate="yes" xml:space="preserve">
          <source>Calculates the CRC-32 (Cyclic Redundancy Code) digest for the &lt;code&gt;str&lt;/code&gt; argument.</source>
          <target state="translated">计算 &lt;code&gt;str&lt;/code&gt; 参数的CRC-32（循环冗余码）摘要。</target>
        </trans-unit>
        <trans-unit id="d4d7cb46ad6aade1ccd55675f7840010137217ca" translate="yes" xml:space="preserve">
          <source>Calling this method on an already connected socket object will cause the original connection to be closed first.</source>
          <target state="translated">在一个已经连接的套接字对象上调用这个方法,会使原来的连接先被关闭。</target>
        </trans-unit>
        <trans-unit id="a18622848f8695e4af301660d065221500bd5f67" translate="yes" xml:space="preserve">
          <source>Care must be taken when importing modules and this form should be used:</source>
          <target state="translated">导入模块时必须注意,应使用此表格。</target>
        </trans-unit>
        <trans-unit id="bec7eedab840089a1f91f66aade81eb04c294518" translate="yes" xml:space="preserve">
          <source>Care should be taken in using this option as variable scope sharing can have unexpected side effects. The &lt;code&gt;args&lt;/code&gt;, &lt;code&gt;vars&lt;/code&gt;, or &lt;code&gt;copy_all_vars&lt;/code&gt; options are generally preferable instead.</source>
          <target state="translated">使用此选项时应格外小心，因为可变范围共享可能会产生意外的副作用。通常最好使用 &lt;code&gt;args&lt;/code&gt; ， &lt;code&gt;vars&lt;/code&gt; 或 &lt;code&gt;copy_all_vars&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="205635e2d30f61579e630e686c4ab2986ac6e9ef" translate="yes" xml:space="preserve">
          <source>Certain Lua APIs provided by ngx_lua do not work in Nginx's SPDY mode yet: &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt;, &lt;a href=&quot;#ngxlocationcapture_multi&quot;&gt;ngx.location.capture_multi&lt;/a&gt;, and &lt;a href=&quot;#ngxreqsocket&quot;&gt;ngx.req.socket&lt;/a&gt;.</source>
          <target state="translated">ngx_lua提供的某些Lua API在Nginx的SPDY模式下尚不能使用：&lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt;，&lt;a href=&quot;#ngxlocationcapture_multi&quot;&gt;ngx.location.capture_multi&lt;/a&gt;和&lt;a href=&quot;#ngxreqsocket&quot;&gt;ngx.req.socket&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8aa57de6dce6ee1c35c6aba7426503281876b258" translate="yes" xml:space="preserve">
          <source>Changes</source>
          <target state="translated">Changes</target>
        </trans-unit>
        <trans-unit id="fa82f055bd9a8bd0bf293a05642b0f0c2c27fc2e" translate="yes" xml:space="preserve">
          <source>Chinese Mailing List</source>
          <target state="translated">中文邮件列表</target>
        </trans-unit>
        <trans-unit id="5adc3a0b1fa84612c05e854d94a26ce7445bce67" translate="yes" xml:space="preserve">
          <source>Clears the current request's request header named &lt;code&gt;header_name&lt;/code&gt;. None of the current request's existing subrequests will be affected but subsequently initiated subrequests will inherit the change by default.</source>
          <target state="translated">清除当前请求的请求标头 &lt;code&gt;header_name&lt;/code&gt; 。当前请求的现有子请求都不会受到影响，但是默认情况下，随后启动的子请求将继承更改。</target>
        </trans-unit>
        <trans-unit id="d490d21fceeea922082c55d291fb819a2aa1ef2d" translate="yes" xml:space="preserve">
          <source>Closes the current TCP or stream unix domain socket. It returns the &lt;code&gt;1&lt;/code&gt; in case of success and returns &lt;code&gt;nil&lt;/code&gt; with a string describing the error otherwise.</source>
          <target state="translated">关闭当前的TCP或流UNIX域套接字。它返回 &lt;code&gt;1&lt;/code&gt; 在成功的情况下，返回 &lt;code&gt;nil&lt;/code&gt; 与描述，否则错误的字符串。</target>
        </trans-unit>
        <trans-unit id="4fc1e8fa8bef29b7f64e2a84406b14acb2bd6091" translate="yes" xml:space="preserve">
          <source>Closes the current UDP or datagram unix domain socket. It returns the &lt;code&gt;1&lt;/code&gt; in case of success and returns &lt;code&gt;nil&lt;/code&gt; with a string describing the error otherwise.</source>
          <target state="translated">关闭当前的UDP或数据报Unix域套接字。它返回 &lt;code&gt;1&lt;/code&gt; 在成功的情况下，返回 &lt;code&gt;nil&lt;/code&gt; 与描述，否则错误的字符串。</target>
        </trans-unit>
        <trans-unit id="6d1aa7d812b27d79c0c1208eec7bebf471596c94" translate="yes" xml:space="preserve">
          <source>Code Repository</source>
          <target state="translated">代码库</target>
        </trans-unit>
        <trans-unit id="bfd58ee3a270f3a931009900e1008d549bbd7453" translate="yes" xml:space="preserve">
          <source>Community</source>
          <target state="translated">Community</target>
        </trans-unit>
        <trans-unit id="5faed13d1b9ec66ea4dd42b28f9aeb3e8291a197" translate="yes" xml:space="preserve">
          <source>Completes the construction process of the new request body created by the &lt;a href=&quot;#ngxreqinit_body&quot;&gt;ngx.req.init_body&lt;/a&gt; and &lt;a href=&quot;#ngxreqappend_body&quot;&gt;ngx.req.append_body&lt;/a&gt; calls.</source>
          <target state="translated">完成由&lt;a href=&quot;#ngxreqinit_body&quot;&gt;ngx.req.init_body&lt;/a&gt;和&lt;a href=&quot;#ngxreqappend_body&quot;&gt;ngx.req.append_body&lt;/a&gt;调用创建的新请求主体的构造过程。</target>
        </trans-unit>
        <trans-unit id="1ffdd76c61bd2bc1c63d37327c812517458b60a1" translate="yes" xml:space="preserve">
          <source>Computes the &lt;a href=&quot;http://en.wikipedia.org/wiki/HMAC&quot;&gt;HMAC-SHA1&lt;/a&gt; digest of the argument &lt;code&gt;str&lt;/code&gt; and turns the result using the secret key &lt;code&gt;&amp;lt;secret_key&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">计算参数 &lt;code&gt;str&lt;/code&gt; 的&lt;a href=&quot;http://en.wikipedia.org/wiki/HMAC&quot;&gt;HMAC-SHA1&lt;/a&gt;摘要，并使用密钥 &lt;code&gt;&amp;lt;secret_key&amp;gt;&lt;/code&gt; 转换结果。</target>
        </trans-unit>
        <trans-unit id="c2f96250746eda72a409d432d944a3717e9602df" translate="yes" xml:space="preserve">
          <source>Configuring the argument to &lt;code&gt;0&lt;/code&gt; essentially turns off the periodical memory trimming altogether.</source>
          <target state="translated">将参数配置为 &lt;code&gt;0&lt;/code&gt; 实际上将完全关闭定期内存调整。</target>
        </trans-unit>
        <trans-unit id="6446cd7e96cba73b9293c41aefb78a2216327d7f" translate="yes" xml:space="preserve">
          <source>Connecting to a Unix Domain Socket file is also possible:</source>
          <target state="translated">也可以连接到Unix域Socket文件。</target>
        </trans-unit>
        <trans-unit id="56b80af072fa83ee95788ec24e46c4595598d634" translate="yes" xml:space="preserve">
          <source>Consider the following example,</source>
          <target state="translated">请看下面的例子。</target>
        </trans-unit>
        <trans-unit id="ceca46f95767076b3e03327e09595cd0ff021e8e" translate="yes" xml:space="preserve">
          <source>Control API functions (e.g., &lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt; and &lt;a href=&quot;#ngxexec&quot;&gt;ngx.exec&lt;/a&gt;)</source>
          <target state="translated">控制API函数（例如&lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt;和&lt;a href=&quot;#ngxexec&quot;&gt;ngx.exec&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="f5c8417c95d29bf32371feee6f028188847b7242" translate="yes" xml:space="preserve">
          <source>Control API functions (e.g., &lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt;)</source>
          <target state="translated">控制API函数（例如&lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="a1aa985f5ba4298ca1ce081f6731fa62ac3235cd" translate="yes" xml:space="preserve">
          <source>Control API functions (e.g., &lt;a href=&quot;#ngxredirect&quot;&gt;ngx.redirect&lt;/a&gt; and &lt;a href=&quot;#ngxexec&quot;&gt;ngx.exec&lt;/a&gt;)</source>
          <target state="translated">控制API函数（例如&lt;a href=&quot;#ngxredirect&quot;&gt;ngx.redirect&lt;/a&gt;和&lt;a href=&quot;#ngxexec&quot;&gt;ngx.exec&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="5a129bc7ab81f3252b4dd4d835f81ccec26e010e" translate="yes" xml:space="preserve">
          <source>Controls the &lt;code&gt;lowat&lt;/code&gt; (low water) value for the cosocket send buffer.</source>
          <target state="translated">控制 &lt;code&gt;lowat&lt;/code&gt; 为cosocket发送缓冲区（低水）值。</target>
        </trans-unit>
        <trans-unit id="365bf88c43a7210eedc24410a257ae7e616dd607" translate="yes" xml:space="preserve">
          <source>Controls the default timeout value used in TCP/unix-domain socket object's &lt;a href=&quot;#tcpsocksend&quot;&gt;send&lt;/a&gt; method and can be overridden by the &lt;a href=&quot;#tcpsocksettimeout&quot;&gt;settimeout&lt;/a&gt; or &lt;a href=&quot;#tcpsocksettimeouts&quot;&gt;settimeouts&lt;/a&gt; methods.</source>
          <target state="translated">控制TCP / unix域套接字对象的&lt;a href=&quot;#tcpsocksend&quot;&gt;send&lt;/a&gt;方法中使用的默认超时值，并且可以被&lt;a href=&quot;#tcpsocksettimeout&quot;&gt;settimeout&lt;/a&gt;或&lt;a href=&quot;#tcpsocksettimeouts&quot;&gt;settimeouts&lt;/a&gt;方法覆盖。</target>
        </trans-unit>
        <trans-unit id="397940f42488c4420013f4dab2b05106c28a473e" translate="yes" xml:space="preserve">
          <source>Controls the maximum number of &quot;running timers&quot; allowed.</source>
          <target state="translated">控制允许的 &quot;运行计时器 &quot;的最大数量。</target>
        </trans-unit>
        <trans-unit id="56fefe02667d54aa2d72d50889f821605bae34a0" translate="yes" xml:space="preserve">
          <source>Controls the maximum number of pending timers allowed.</source>
          <target state="translated">控制允许的最大待定时间数。</target>
        </trans-unit>
        <trans-unit id="135abb501ad1b78711e51df9da32f441943c3cb2" translate="yes" xml:space="preserve">
          <source>Controls whether or not to disable postponing &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua*&lt;/a&gt; directives to run at the end of the &lt;code&gt;access&lt;/code&gt; request-processing phase. By default, this directive is turned off and the Lua code is postponed to run at the end of the &lt;code&gt;access&lt;/code&gt; phase.</source>
          <target state="translated">控制是否禁用延迟的&lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua *&lt;/a&gt;指令以在 &lt;code&gt;access&lt;/code&gt; 请求处理阶段结束时运行。默认情况下，此伪指令处于关闭状态，并且Lua代码被推迟在 &lt;code&gt;access&lt;/code&gt; 阶段结束时运行。</target>
        </trans-unit>
        <trans-unit id="d12a174326acbcfde0787b3b61f0b2d216c533db" translate="yes" xml:space="preserve">
          <source>Controls whether or not to disable postponing &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua*&lt;/a&gt; directives to run at the end of the &lt;code&gt;rewrite&lt;/code&gt; request-processing phase. By default, this directive is turned off and the Lua code is postponed to run at the end of the &lt;code&gt;rewrite&lt;/code&gt; phase.</source>
          <target state="translated">控制是否禁用延迟&lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua *&lt;/a&gt;指令以在 &lt;code&gt;rewrite&lt;/code&gt; 请求处理阶段结束时运行。默认情况下，此伪指令处于关闭状态，并且Lua代码推迟到 &lt;code&gt;rewrite&lt;/code&gt; 阶段结束时运行。</target>
        </trans-unit>
        <trans-unit id="909a9c3bd668cff95f6fcd8735560f894a264f73" translate="yes" xml:space="preserve">
          <source>Controls whether to transform underscores (&lt;code&gt;_&lt;/code&gt;) in the response header names specified in the &lt;a href=&quot;#ngxheaderheader&quot;&gt;ngx.header.HEADER&lt;/a&gt; API to hypens (&lt;code&gt;-&lt;/code&gt;).</source>
          <target state="translated">控制是否将&lt;a href=&quot;#ngxheaderheader&quot;&gt;ngx.header.HEADER&lt;/a&gt; API中指定的响应标头名称中的下划线（ &lt;code&gt;_&lt;/code&gt; ）转换为连字符（ &lt;code&gt;-&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="85d1e3919eeba35b19183dcfaaaef7a57a658492" translate="yes" xml:space="preserve">
          <source>Copyright (C) 2009-2017, by Xiaozhe Wang (chaoslawful) &lt;a href=&quot;mailto:chaoslawful@gmail.com&quot;&gt;chaoslawful@gmail.com&lt;/a&gt;.</source>
          <target state="translated">版权所有（C）2009-2017，由李晓哲王（chaoslawful）&lt;a href=&quot;mailto:chaoslawful@gmail.com&quot;&gt;chaoslawful@gmail.com&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a0ea5fb647bf6a547d5714554cf0d8359944d733" translate="yes" xml:space="preserve">
          <source>Copyright (C) 2009-2018, by Yichun &quot;agentzh&quot; Zhang (章亦春) &lt;a href=&quot;mailto:agentzh@gmail.com&quot;&gt;agentzh@gmail.com&lt;/a&gt;, OpenResty Inc.</source>
          <target state="translated">OpenResty Inc. 版权所有（C）2009-2018，作者是Yichun&amp;ldquo; agentzh&amp;rdquo; Zhang（章亦春）&lt;a href=&quot;mailto:agentzh@gmail.com&quot;&gt;agentzh@gmail.com&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4fc24471116f3e2d97602dd028f800b05cacef1a" translate="yes" xml:space="preserve">
          <source>Copyright and License</source>
          <target state="translated">版权和许可</target>
        </trans-unit>
        <trans-unit id="70b3bb876101904c3c0515924008e365a5c27cf9" translate="yes" xml:space="preserve">
          <source>Core constants</source>
          <target state="translated">核心常数</target>
        </trans-unit>
        <trans-unit id="4c48657a691e01318c2ec61c9823282bd50d9aad" translate="yes" xml:space="preserve">
          <source>Cosocket API functions (e.g., &lt;a href=&quot;#ngxsockettcp&quot;&gt;ngx.socket.tcp&lt;/a&gt; and &lt;a href=&quot;#ngxreqsocket&quot;&gt;ngx.req.socket&lt;/a&gt;).</source>
          <target state="translated">Cosocket API函数（例如&lt;a href=&quot;#ngxsockettcp&quot;&gt;ngx.socket.tcp&lt;/a&gt;和&lt;a href=&quot;#ngxreqsocket&quot;&gt;ngx.req.socket&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b400cfa6df4811fdd8291d2c4ab1dcddfb366e50" translate="yes" xml:space="preserve">
          <source>Cosockets Not Available Everywhere</source>
          <target state="translated">并非所有地方都有Cosockets</target>
        </trans-unit>
        <trans-unit id="c9a411eb35af3886593d4fc7e9a4ec3d74be3ad1" translate="yes" xml:space="preserve">
          <source>Creates a new blank request body for the current request and inializes the buffer for later request body data writing via the &lt;a href=&quot;#ngxreqappend_body&quot;&gt;ngx.req.append_body&lt;/a&gt; and &lt;a href=&quot;#ngxreqfinish_body&quot;&gt;ngx.req.finish_body&lt;/a&gt; APIs.</source>
          <target state="translated">为当前请求创建一个新的空白请求正文，并通过&lt;a href=&quot;#ngxreqappend_body&quot;&gt;ngx.req.append_body&lt;/a&gt;和&lt;a href=&quot;#ngxreqfinish_body&quot;&gt;ngx.req.finish_body&lt;/a&gt; API 将缓冲区初始化为以后的请求正文数据写入。</target>
        </trans-unit>
        <trans-unit id="f07632b66a22d40c20cd39dc95c453c672dd5728" translate="yes" xml:space="preserve">
          <source>Creates a user Lua coroutines with a Lua function, and returns a coroutine object.</source>
          <target state="translated">用Lua函数创建一个用户Lua coroutine,并返回一个coroutine对象。</target>
        </trans-unit>
        <trans-unit id="5d862e7bf0f690ca3f94b0070e00fa39e7dfbb38" translate="yes" xml:space="preserve">
          <source>Creates an Nginx timer with a user callback function as well as optional user arguments.</source>
          <target state="translated">创建一个带有用户回调函数的Nginx定时器,以及可选的用户参数。</target>
        </trans-unit>
        <trans-unit id="9ee4e559744243aec9e77c98e2242a78d443708d" translate="yes" xml:space="preserve">
          <source>Creates and returns a TCP or stream-oriented unix domain socket object (also known as one type of the &quot;cosocket&quot; objects). The following methods are supported on this object:</source>
          <target state="translated">创建并返回一个TCP或面向流的unix域套接字对象(也称为 &quot;cosocket &quot;对象的一种)。该对象支持以下方法。</target>
        </trans-unit>
        <trans-unit id="dbfe979fefa10cf7f6544c9214d1014badfe97fa" translate="yes" xml:space="preserve">
          <source>Creates and returns a UDP or datagram-oriented unix domain socket object (also known as one type of the &quot;cosocket&quot; objects). The following methods are supported on this object:</source>
          <target state="translated">创建并返回一个UDP或面向数据报的unix域套接字对象(也称为 &quot;cosocket &quot;对象的一种类型)。该对象支持以下方法。</target>
        </trans-unit>
        <trans-unit id="bb53329a3a7669fa398d8bf780e0c78fc936abd9" translate="yes" xml:space="preserve">
          <source>Curly braces can also be used to disambiguate variable names from the background string literals:</source>
          <target state="translated">大括号也可以用来区分变量名和背景字符串字面意思。</target>
        </trans-unit>
        <trans-unit id="e04fd81c5d27700a16cec223326b0820188887b4" translate="yes" xml:space="preserve">
          <source>Current possible values are 2.0, 1.0, 1.1, and 0.9. Returns &lt;code&gt;nil&lt;/code&gt; for unrecognized values.</source>
          <target state="translated">当前可能的值为2.0、1.0、1.1和0.9。对于无法识别的值，返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e55515195eb8a3e12ad16f0e25bf71c8e1b1993" translate="yes" xml:space="preserve">
          <source>Data Sharing within an Nginx Worker</source>
          <target state="translated">在Nginx Worker中共享数据</target>
        </trans-unit>
        <trans-unit id="09515d7ad679c206e461a48757870b58e578ce09" translate="yes" xml:space="preserve">
          <source>Declares a shared memory zone, &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;, to serve as storage for the shm based Lua dictionary &lt;code&gt;ngx.shared.&amp;lt;name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">声明共享内存区域 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; ，以用作基于shm的Lua字典 &lt;code&gt;ngx.shared.&amp;lt;name&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6f3b02d295dd6a6c2076e175a4a9e4a5e942f0e" translate="yes" xml:space="preserve">
          <source>Decodes a URI encoded query-string into a Lua table. This is the inverse function of &lt;a href=&quot;#ngxencode_args&quot;&gt;ngx.encode_args&lt;/a&gt;.</source>
          <target state="translated">将URI编码的查询字符串解码为Lua表。这是&lt;a href=&quot;#ngxencode_args&quot;&gt;ngx.encode_args&lt;/a&gt;的反函数。</target>
        </trans-unit>
        <trans-unit id="e0109e1f34e2fab3bc07f52b8ae7f809bcde0a42" translate="yes" xml:space="preserve">
          <source>Decodes the &lt;code&gt;str&lt;/code&gt; argument as a base64 digest to the raw form. Returns &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;str&lt;/code&gt; is not well formed.</source>
          <target state="translated">将 &lt;code&gt;str&lt;/code&gt; 参数解码为原始形式的base64摘要。如果 &lt;code&gt;str&lt;/code&gt; 格式不正确，则返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83626d3b06b38d1cc87af089e736d3f7b2b833af" translate="yes" xml:space="preserve">
          <source>Default to 30 connections for every pool.</source>
          <target state="translated">默认为每个池子有30个连接。</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="54750baa0787dc7ff0ee984d90855802e7c8be14" translate="yes" xml:space="preserve">
          <source>Determines whether to force the request body data to be read before running rewrite/access/access_by_lua* or not. The Nginx core does not read the client request body by default and if request body data is required, then this directive should be turned &lt;code&gt;on&lt;/code&gt; or the &lt;a href=&quot;#ngxreqread_body&quot;&gt;ngx.req.read_body&lt;/a&gt; function should be called within the Lua code.</source>
          <target state="translated">确定是否强制在运行rewrite / access / access_by_lua *之前强制读取请求主体数据。默认情况下，Nginx核心不会读取客户端请求主体，如果需要请求主体数据，则应 &lt;code&gt;on&lt;/code&gt; 此指令或在Lua代码中调用&lt;a href=&quot;#ngxreqread_body&quot;&gt;ngx.req.read_body&lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="28c82071e940360118b0611d5c912a71c32a0100" translate="yes" xml:space="preserve">
          <source>Directives</source>
          <target state="translated">Directives</target>
        </trans-unit>
        <trans-unit id="c59ab2b723662b2de5a29bff24948bebf43dad1d" translate="yes" xml:space="preserve">
          <source>Disabling the Lua code cache is strongly discouraged for production use and should only be used during development as it has a significant negative impact on overall performance. For example, the performance of a &quot;hello world&quot; Lua example can drop by an order of magnitude after disabling the Lua code cache.</source>
          <target state="translated">强烈不鼓励在生产使用中禁用Lua代码缓存,只应在开发过程中使用,因为它对整体性能有很大的负面影响。例如,&quot;hello world &quot;Lua例子的性能在禁用Lua代码缓存后会下降一个数量级。</target>
        </trans-unit>
        <trans-unit id="226be261389d03c098224fbb551ea625e21c9f90" translate="yes" xml:space="preserve">
          <source>Do &lt;em&gt;not&lt;/em&gt; initialize your own Lua global variables in this context because use of Lua global variables have performance penalties and can lead to global namespace pollution (see the &lt;a href=&quot;#lua-variable-scope&quot;&gt;Lua Variable Scope&lt;/a&gt; section for more details). The recommended way is to use proper &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#5.3&quot;&gt;Lua module&lt;/a&gt; files (but do not use the standard Lua function &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-module&quot;&gt;module()&lt;/a&gt; to define Lua modules because it pollutes the global namespace as well) and call &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-require&quot;&gt;require()&lt;/a&gt; to load your own module files in &lt;code&gt;init_by_lua&lt;/code&gt; or other contexts (&lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-require&quot;&gt;require()&lt;/a&gt; does cache the loaded Lua modules in the global &lt;code&gt;package.loaded&lt;/code&gt; table in the Lua registry so your modules will only loaded once for the whole Lua VM instance).</source>
          <target state="translated">千万&lt;em&gt;不能&lt;/em&gt;初始化自己的Lua的全局变量在这种情况下，因为使用Lua的全局变量有性能损失，并可能导致全局命名空间污染（见&lt;a href=&quot;#lua-variable-scope&quot;&gt;Lua的变量的作用域&lt;/a&gt;获取更多详细信息）。推荐的方法是使用适当的&lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#5.3&quot;&gt;Lua模块&lt;/a&gt;文件（但不要使用标准的Lua函数&lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-module&quot;&gt;module（）&lt;/a&gt;来定义Lua模块，因为它也会污染全局名称空间），并调用&lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-require&quot;&gt;require（）&lt;/a&gt;将自己的模块文件加载到 &lt;code&gt;init_by_lua&lt;/code&gt; 或其他文件中contexts（&lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-require&quot;&gt;require（）&lt;/a&gt;确实将加载的Lua模块缓存在全局 &lt;code&gt;package.loaded&lt;/code&gt; 表在Lua注册表中，因此您的模块对于整个Lua VM实例将仅加载一次）。</target>
        </trans-unit>
        <trans-unit id="df34d24999db01b1b2d79ab927d026249fdac918" translate="yes" xml:space="preserve">
          <source>Do not activate the &lt;code&gt;o&lt;/code&gt; option for regular expressions (and/or &lt;code&gt;replace&lt;/code&gt; string arguments for &lt;a href=&quot;#ngxresub&quot;&gt;ngx.re.sub&lt;/a&gt; and &lt;a href=&quot;#ngxregsub&quot;&gt;ngx.re.gsub&lt;/a&gt;) that are generated &lt;em&gt;on the fly&lt;/em&gt; and give rise to infinite variations to avoid hitting the specified limit.</source>
          <target state="translated">不要激活&lt;em&gt;即时&lt;/em&gt;生成的正则表达式的 &lt;code&gt;o&lt;/code&gt; 选项（和/或 &lt;code&gt;replace&lt;/code&gt; &lt;a href=&quot;#ngxresub&quot;&gt;ngx.re.sub&lt;/a&gt;和&lt;a href=&quot;#ngxregsub&quot;&gt;ngx.re.gsub的&lt;/a&gt;字符串参数），并引起无限的变化以避免达到指定的限制。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="87b53087c3f604e47b786a680f2de8abdf1bf277" translate="yes" xml:space="preserve">
          <source>Do not use backlashes to escape dollar signs; it will not work as expected.</source>
          <target state="translated">不要用反击来逃避美元符号,它不会有预期的效果。</target>
        </trans-unit>
        <trans-unit id="27fe54bb9fec7379d6ad43f2de7fdce9fb0149ae" translate="yes" xml:space="preserve">
          <source>Do not use this directive and other content handler directives in the same location. For example, this directive and the &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass&quot;&gt;proxy_pass&lt;/a&gt; directive should not be used in the same location.</source>
          <target state="translated">不要在同一位置使用此指令和其他内容处理程序指令。例如，此指令和&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass&quot;&gt;proxy_pass&lt;/a&gt;指令不应在同一位置使用。</target>
        </trans-unit>
        <trans-unit id="ccf0613f0197b9bbdd423e70af9e75fdaedae896" translate="yes" xml:space="preserve">
          <source>Does SSL/TLS handshake on the currently established connection.</source>
          <target state="translated">对当前建立的连接进行SSL/TLS握手。</target>
        </trans-unit>
        <trans-unit id="4fd7855f0a481f9ca860dd0c55ade18fa1c6fe55" translate="yes" xml:space="preserve">
          <source>Does an internal redirect to &lt;code&gt;uri&lt;/code&gt; with &lt;code&gt;args&lt;/code&gt; and is similar to the &lt;a href=&quot;http://github.com/openresty/echo-nginx-module#echo_exec&quot;&gt;echo_exec&lt;/a&gt; directive of the &lt;a href=&quot;http://github.com/openresty/echo-nginx-module&quot;&gt;echo-nginx-module&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;args&lt;/code&gt; 内部重定向到 &lt;code&gt;uri&lt;/code&gt; ，类似于&lt;a href=&quot;http://github.com/openresty/echo-nginx-module&quot;&gt;echo-nginx-module&lt;/a&gt;的&lt;a href=&quot;http://github.com/openresty/echo-nginx-module#echo_exec&quot;&gt;echo_exec&lt;/a&gt;指令。</target>
        </trans-unit>
        <trans-unit id="045d83da712ca79a4c6422d852804b994e647f90" translate="yes" xml:space="preserve">
          <source>Download the latest version of Nginx &lt;a href=&quot;http://nginx.org/&quot;&gt;HERE&lt;/a&gt; (See &lt;a href=&quot;#nginx-compatibility&quot;&gt;Nginx Compatibility&lt;/a&gt;)</source>
          <target state="translated">下载最新版本的Nginx &lt;a href=&quot;http://nginx.org/&quot;&gt;HERE&lt;/a&gt;（请参阅&lt;a href=&quot;#nginx-compatibility&quot;&gt;Nginx兼容性&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="5d40ecb5ccbedf533d02f870ffdd9ea9baf019eb" translate="yes" xml:space="preserve">
          <source>Download the latest version of ngx_lua &lt;a href=&quot;https://github.com/openresty/lua-nginx-module/tags&quot;&gt;HERE&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;https://github.com/openresty/lua-nginx-module/tags&quot;&gt;此处&lt;/a&gt;下载最新版本的ngx_lua 。</target>
        </trans-unit>
        <trans-unit id="0318d120477b77f197c8861318b9d222ce4f59d1" translate="yes" xml:space="preserve">
          <source>Download the latest version of the ngx_devel_kit (NDK) module &lt;a href=&quot;https://github.com/simplresty/ngx_devel_kit/tags&quot;&gt;HERE&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;https://github.com/simplresty/ngx_devel_kit/tags&quot;&gt;此处&lt;/a&gt;下载最新版本的ngx_devel_kit（NDK）模块。</target>
        </trans-unit>
        <trans-unit id="6c7f631291d7ba5f151c641b1207915b8dd977fc" translate="yes" xml:space="preserve">
          <source>Due to internal limitations in the nginx core, the cosocket API is disabled in the following contexts: &lt;a href=&quot;#set_by_lua&quot;&gt;set_by_lua*&lt;/a&gt;, &lt;a href=&quot;#log_by_lua&quot;&gt;log_by_lua*&lt;/a&gt;, &lt;a href=&quot;#header_filter_by_lua&quot;&gt;header_filter_by_lua*&lt;/a&gt;, and &lt;a href=&quot;#body_filter_by_lua&quot;&gt;body_filter_by_lua&lt;/a&gt;.</source>
          <target state="translated">由于nginx内核的内部限制，在以下情况下禁用了cosocket API：&lt;a href=&quot;#set_by_lua&quot;&gt;set_by_lua *&lt;/a&gt;，&lt;a href=&quot;#log_by_lua&quot;&gt;log_by_lua *&lt;/a&gt;，&lt;a href=&quot;#header_filter_by_lua&quot;&gt;header_filter_by_lua *&lt;/a&gt;和&lt;a href=&quot;#body_filter_by_lua&quot;&gt;body_filter_by_lua&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b9ad1ffff9a35f09f7908bd0a6d2f9d7f052bacc" translate="yes" xml:space="preserve">
          <source>Due to the limitation in the Nginx subrequest model, it is not allowed to abort a running Nginx subrequest in general. So it is also prohibited to abort a running &quot;light thread&quot; that is pending on one ore more Nginx subrequests. You must call &lt;a href=&quot;#ngxthreadwait&quot;&gt;ngx.thread.wait&lt;/a&gt; to wait for those &quot;light thread&quot; to terminate before quitting the &quot;world&quot;. A notable exception here is that you can abort pending subrequests by calling &lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt; with and only with the status code &lt;code&gt;ngx.ERROR&lt;/code&gt; (-1), &lt;code&gt;408&lt;/code&gt;, &lt;code&gt;444&lt;/code&gt;, or &lt;code&gt;499&lt;/code&gt;.</source>
          <target state="translated">由于Nginx子请求模型的限制，通常不允许中止正在运行的Nginx子请求。因此，也禁止中止正在一个或多个Nginx子请求上挂起的正在运行的&amp;ldquo;轻线程&amp;rdquo;。您必须调用&lt;a href=&quot;#ngxthreadwait&quot;&gt;ngx.thread.wait&lt;/a&gt;来等待那些&amp;ldquo;轻线程&amp;rdquo;终止，然后再退出&amp;ldquo;世界&amp;rdquo;。这里一个值得注意的例外是，您可以通过调用中止未决子请求&lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt;用，只与状态代码 &lt;code&gt;ngx.ERROR&lt;/code&gt; （-1）， &lt;code&gt;408&lt;/code&gt; ， &lt;code&gt;444&lt;/code&gt; ，或 &lt;code&gt;499&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29236bdfab72d0d4652e5f127c1abb6088f7a723" translate="yes" xml:space="preserve">
          <source>Dynamic Routing Based on Redis and Lua</source>
          <target state="translated">基于Redis和Lua的动态路由服务</target>
        </trans-unit>
        <trans-unit id="7a54f388572d656cf23a248ceb8957e858d23f7a" translate="yes" xml:space="preserve">
          <source>Emits arguments concatenated to the HTTP client (as response body). If response headers have not been sent, this function will send headers out first and then output body data.</source>
          <target state="translated">向HTTP客户端发出参数连接(作为响应体)。如果没有发送响应头信息,本函数将先发送头信息,然后再输出主体数据。</target>
        </trans-unit>
        <trans-unit id="848bd1d7829f4a2891e7ad23e5a3a735760ac53c" translate="yes" xml:space="preserve">
          <source>Empty key arguments are discarded. &lt;code&gt;GET /test?=hello&amp;amp;=world&lt;/code&gt; will yield an empty output for instance.</source>
          <target state="translated">空键参数将被丢弃。 &lt;code&gt;GET /test?=hello&amp;amp;=world&lt;/code&gt; 将产生一个空输出。</target>
        </trans-unit>
        <trans-unit id="29a4c565d886e2f1088c2bf4c92e2ae9ac98cb46" translate="yes" xml:space="preserve">
          <source>Empty key arguments are discarded. &lt;code&gt;POST /test&lt;/code&gt; with body &lt;code&gt;=hello&amp;amp;=world&lt;/code&gt; will yield empty outputs for instance.</source>
          <target state="translated">空键参数将被丢弃。 &lt;code&gt;POST /test&lt;/code&gt; ，body &lt;code&gt;=hello&amp;amp;=world&lt;/code&gt; 的POST / test将产生空输出。</target>
        </trans-unit>
        <trans-unit id="cc419b0b69c9aa6c694814bab7e2aebe8ddf6212" translate="yes" xml:space="preserve">
          <source>Enables a buffer of the specified &lt;code&gt;size&lt;/code&gt; for capturing all the nginx error log message data (not just those produced by this module or the nginx http subsystem, but everything) without touching files or disks.</source>
          <target state="translated">启用指定 &lt;code&gt;size&lt;/code&gt; 的缓冲区，以捕获所有nginx错误日志消息数据（不仅是此模块或nginx http子系统产生的数据，而且包括所有内容），而无需触摸文件或磁盘。</target>
        </trans-unit>
        <trans-unit id="5ca6b0f5c877b9e145b7d6521d38ce1c27401939" translate="yes" xml:space="preserve">
          <source>Enables or disables automatic response buffering for HTTP 1.0 (or older) requests. This buffering mechanism is mainly used for HTTP 1.0 keep-alive which relies on a proper &lt;code&gt;Content-Length&lt;/code&gt; response header.</source>
          <target state="translated">启用或禁用HTTP 1.0（或更旧版本）请求的自动响应缓冲。此缓冲机制主要用于HTTP 1.0保持活动，该活动依赖于适当的 &lt;code&gt;Content-Length&lt;/code&gt; 响应标头。</target>
        </trans-unit>
        <trans-unit id="d47e73453f9316d717aba75922430ed16aa911aa" translate="yes" xml:space="preserve">
          <source>Enables or disables the Lua code cache for Lua code in &lt;code&gt;*_by_lua_file&lt;/code&gt; directives (like &lt;a href=&quot;#set_by_lua_file&quot;&gt;set_by_lua_file&lt;/a&gt; and &lt;a href=&quot;#content_by_lua_file&quot;&gt;content_by_lua_file&lt;/a&gt;) and Lua modules.</source>
          <target state="translated">为 &lt;code&gt;*_by_lua_file&lt;/code&gt; 指令（例如&lt;a href=&quot;#set_by_lua_file&quot;&gt;set_by_lua_file&lt;/a&gt;和&lt;a href=&quot;#content_by_lua_file&quot;&gt;content_by_lua_file&lt;/a&gt;）和Lua模块中的Lua代码启用或禁用Lua代码缓存。</target>
        </trans-unit>
        <trans-unit id="4c965a9d008aee66f1903b81d52961dab4d946de" translate="yes" xml:space="preserve">
          <source>Enables the specified protocols for requests to a SSL/TLS server in the &lt;a href=&quot;#tcpsocksslhandshake&quot;&gt;tcpsock:sslhandshake&lt;/a&gt; method.</source>
          <target state="translated">在&lt;a href=&quot;#tcpsocksslhandshake&quot;&gt;tcpsock：sslhandshake&lt;/a&gt;方法中为对SSL / TLS服务器的请求启用指定的协议。</target>
        </trans-unit>
        <trans-unit id="0ca81a117829498e1df5519357caffe2c9733474" translate="yes" xml:space="preserve">
          <source>Encode the Lua table to a query args string according to the URI encoded rules.</source>
          <target state="translated">根据URI编码规则,将Lua表编码为查询args字符串。</target>
        </trans-unit>
        <trans-unit id="bca5e541da234316491f694f5205241ef47dc529" translate="yes" xml:space="preserve">
          <source>Encodes &lt;code&gt;str&lt;/code&gt; to a base64 digest.</source>
          <target state="translated">将 &lt;code&gt;str&lt;/code&gt; 编码为base64摘要。</target>
        </trans-unit>
        <trans-unit id="672deddd0ee057c0155b582ac943883e4a7afb83" translate="yes" xml:space="preserve">
          <source>English Mailing List</source>
          <target state="translated">英文邮件列表</target>
        </trans-unit>
        <trans-unit id="e441252616b6eb66b814c7ba77392af14981d806" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua&lt;/a&gt;, except that the file specified by &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; contains the Lua code, or, as from the &lt;code&gt;v0.5.0rc32&lt;/code&gt; release, the &lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;Lua/LuaJIT bytecode&lt;/a&gt; to be executed.</source>
          <target state="translated">与&lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua&lt;/a&gt;等效，除了 &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; 指定的文件包含Lua代码，或者从 &lt;code&gt;v0.5.0rc32&lt;/code&gt; 版本开始&lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;包含&lt;/a&gt;要执行的Lua / LuaJIT字节码。</target>
        </trans-unit>
        <trans-unit id="9823cebe38e894116a468c6035b7a854d221774f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#balancer_by_lua_block&quot;&gt;balancer_by_lua_block&lt;/a&gt;, except that the file specified by &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; contains the Lua code, or, as from the &lt;code&gt;v0.5.0rc32&lt;/code&gt; release, the &lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;Lua/LuaJIT bytecode&lt;/a&gt; to be executed.</source>
          <target state="translated">与&lt;a href=&quot;#balancer_by_lua_block&quot;&gt;balancer_by_lua_block&lt;/a&gt;等效，除了 &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; 指定的文件包含Lua代码，或者从 &lt;code&gt;v0.5.0rc32&lt;/code&gt; 版本开始&lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;包含&lt;/a&gt;要执行的Lua / LuaJIT字节码。</target>
        </trans-unit>
        <trans-unit id="601357c81b16cf532123ea4076e8b528852a928d" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#body_filter_by_lua&quot;&gt;body_filter_by_lua&lt;/a&gt;, except that the file specified by &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; contains the Lua code, or, as from the &lt;code&gt;v0.5.0rc32&lt;/code&gt; release, the &lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;Lua/LuaJIT bytecode&lt;/a&gt; to be executed.</source>
          <target state="translated">与&lt;a href=&quot;#body_filter_by_lua&quot;&gt;body_filter_by_lua&lt;/a&gt;等效，除了 &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; 指定的文件包含Lua代码，或者从 &lt;code&gt;v0.5.0rc32&lt;/code&gt; 版本开始&lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;包含&lt;/a&gt;要执行的Lua / LuaJIT字节码。</target>
        </trans-unit>
        <trans-unit id="dfb2f6ec767b197b70fe3640a9c169a98fd98341" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#content_by_lua&quot;&gt;content_by_lua&lt;/a&gt;, except that the file specified by &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; contains the Lua code, or, as from the &lt;code&gt;v0.5.0rc32&lt;/code&gt; release, the &lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;Lua/LuaJIT bytecode&lt;/a&gt; to be executed.</source>
          <target state="translated">与&lt;a href=&quot;#content_by_lua&quot;&gt;content_by_lua&lt;/a&gt;等效，除了 &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; 指定的文件包含Lua代码，或者从 &lt;code&gt;v0.5.0rc32&lt;/code&gt; 版本开始&lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;包含&lt;/a&gt;要执行的Lua / LuaJIT字节码。</target>
        </trans-unit>
        <trans-unit id="c11377b90e93b1905c50d4ece1c707a1cf5072b9" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#header_filter_by_lua&quot;&gt;header_filter_by_lua&lt;/a&gt;, except that the file specified by &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; contains the Lua code, or as from the &lt;code&gt;v0.5.0rc32&lt;/code&gt; release, the &lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;Lua/LuaJIT bytecode&lt;/a&gt; to be executed.</source>
          <target state="translated">与&lt;a href=&quot;#header_filter_by_lua&quot;&gt;header_filter_by_lua&lt;/a&gt;等效，除了 &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; 指定的文件包含Lua代码，或者从 &lt;code&gt;v0.5.0rc32&lt;/code&gt; 版本开始，包含要执行的&lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;Lua / LuaJIT字节码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fe6f4eee3b9f2e690c5d93a592edf2eb5ce11212" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#init_by_lua&quot;&gt;init_by_lua&lt;/a&gt;, except that the file specified by &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; contains the Lua code or &lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;Lua/LuaJIT bytecode&lt;/a&gt; to be executed.</source>
          <target state="translated">与&lt;a href=&quot;#init_by_lua&quot;&gt;init_by_lua&lt;/a&gt;等效，除了 &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; 指定的文件包含要执行的Lua代码或&lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;Lua / LuaJIT字节码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0ff2a3bed582cc2fe25c77e9b21ef2539db0486f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#log_by_lua&quot;&gt;log_by_lua&lt;/a&gt;, except that the file specified by &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; contains the Lua code, or, as from the &lt;code&gt;v0.5.0rc32&lt;/code&gt; release, the &lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;Lua/LuaJIT bytecode&lt;/a&gt; to be executed.</source>
          <target state="translated">与&lt;a href=&quot;#log_by_lua&quot;&gt;log_by_lua&lt;/a&gt;等效，除了 &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; 指定的文件包含Lua代码，或者从 &lt;code&gt;v0.5.0rc32&lt;/code&gt; 版本开始&lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;包含&lt;/a&gt;要执行的Lua / LuaJIT字节码。</target>
        </trans-unit>
        <trans-unit id="c9d7398a9b03b4863f098b37e65ea4a3677324c8" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt;, except that the file specified by &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; contains the Lua code, or, as from the &lt;code&gt;v0.5.0rc32&lt;/code&gt; release, the &lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;Lua/LuaJIT bytecode&lt;/a&gt; to be executed.</source>
          <target state="translated">与&lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt;等效，除了 &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; 指定的文件包含Lua代码，或者从 &lt;code&gt;v0.5.0rc32&lt;/code&gt; 版本开始&lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;包含&lt;/a&gt;要执行的Lua / LuaJIT字节码。</target>
        </trans-unit>
        <trans-unit id="b0575e053d64ca1c9ae92204cb31794bfa0be159" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#set_by_lua&quot;&gt;set_by_lua&lt;/a&gt;, except that the file specified by &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; contains the Lua code, or, as from the &lt;code&gt;v0.5.0rc32&lt;/code&gt; release, the &lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;Lua/LuaJIT bytecode&lt;/a&gt; to be executed.</source>
          <target state="translated">与&lt;a href=&quot;#set_by_lua&quot;&gt;set_by_lua&lt;/a&gt;等效，除了 &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; 指定的文件包含Lua代码，或者从 &lt;code&gt;v0.5.0rc32&lt;/code&gt; 版本开始&lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;包含&lt;/a&gt;要执行的Lua / LuaJIT字节码。</target>
        </trans-unit>
        <trans-unit id="7d1b305ee0951eb364c7af57db15fc447008035e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#ssl_certificate_by_lua_block&quot;&gt;ssl_certificate_by_lua_block&lt;/a&gt;, except that the file specified by &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; contains the Lua code, or, as from the &lt;code&gt;v0.5.0rc32&lt;/code&gt; release, the &lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;Lua/LuaJIT bytecode&lt;/a&gt; to be executed.</source>
          <target state="translated">与&lt;a href=&quot;#ssl_certificate_by_lua_block&quot;&gt;ssl_certificate_by_lua_block&lt;/a&gt;等效，除了 &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; 指定的文件包含Lua代码，或者从 &lt;code&gt;v0.5.0rc32&lt;/code&gt; 版本开始，包含要执行的&lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;Lua / LuaJIT字节码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2a4e104cd121a98a1337911f916013f47e095811" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#ssl_session_fetch_by_lua_block&quot;&gt;ssl_session_fetch_by_lua_block&lt;/a&gt;, except that the file specified by &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; contains the Lua code, or rather, the &lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;Lua/LuaJIT bytecode&lt;/a&gt; to be executed.</source>
          <target state="translated">与&lt;a href=&quot;#ssl_session_fetch_by_lua_block&quot;&gt;ssl_session_fetch_by_lua_block&lt;/a&gt;等效，除了 &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; 指定的文件包含Lua代码，或者更确切地说，是要执行的&lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;Lua / LuaJIT字节码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bdefe071dc6b790d2f2bcf9b7e02dbafc7c6f305" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#ssl_session_store_by_lua_block&quot;&gt;ssl_session_store_by_lua_block&lt;/a&gt;, except that the file specified by &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; contains the Lua code, or rather, the &lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;Lua/LuaJIT bytecode&lt;/a&gt; to be executed.</source>
          <target state="translated">与&lt;a href=&quot;#ssl_session_store_by_lua_block&quot;&gt;ssl_session_store_by_lua_block&lt;/a&gt;等效，除了 &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; 指定的文件包含Lua代码，或者更确切地说，是要执行的&lt;a href=&quot;#lualuajit-bytecode-support&quot;&gt;Lua / LuaJIT字节码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5c7718395e7fc56a6b0a753777273c639adf8883" translate="yes" xml:space="preserve">
          <source>Escape &lt;code&gt;str&lt;/code&gt; as a URI component.</source>
          <target state="translated">将 &lt;code&gt;str&lt;/code&gt; 转义为URI组件。</target>
        </trans-unit>
        <trans-unit id="1341ef48de08929843ab769ae8f7e6539554fd80" translate="yes" xml:space="preserve">
          <source>Even when the code cache is enabled, Lua files which are loaded by &lt;code&gt;dofile&lt;/code&gt; or &lt;code&gt;loadfile&lt;/code&gt; in *_by_lua_file cannot be cached (unless you cache the results yourself). Usually you can either use the &lt;a href=&quot;#init_by_lua&quot;&gt;init_by_lua&lt;/a&gt; or &lt;a href=&quot;#init-by_lua_file&quot;&gt;init_by_lua_file&lt;/a&gt; directives to load all such files or just make these Lua files true Lua modules and load them via &lt;code&gt;require&lt;/code&gt;.</source>
          <target state="translated">启用代码缓存即使，这是由加载的Lua文件 &lt;code&gt;dofile&lt;/code&gt; 处理或 &lt;code&gt;loadfile&lt;/code&gt; 在* _by_lua_file不能被缓存（除非你缓存结果你自己）。通常，您可以使用&lt;a href=&quot;#init_by_lua&quot;&gt;init_by_lua&lt;/a&gt;或&lt;a href=&quot;#init-by_lua_file&quot;&gt;init_by_lua_file&lt;/a&gt;指令加载所有此类文件，也可以仅使这些Lua文件成为真正的Lua模块并通过 &lt;code&gt;require&lt;/code&gt; 加载它们。</target>
        </trans-unit>
        <trans-unit id="174c4d77c963e9180bc79b90152f3deb03e7eede" translate="yes" xml:space="preserve">
          <source>Every request, including subrequests, has its own copy of the table. For example:</source>
          <target state="translated">每个请求,包括子请求,都有自己的表的副本。例如:</target>
        </trans-unit>
        <trans-unit id="4aedda1f12219002fc466d8e5f18bfe9175f41e0" translate="yes" xml:space="preserve">
          <source>Everything should be installed correctly, except for one small tweak.</source>
          <target state="translated">除了一个小的调整,一切都应该是正确的安装。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="3992fa3b93a6b5051f434706f88bed97617920b6" translate="yes" xml:space="preserve">
          <source>Executes code specified in &lt;code&gt;&amp;lt;lua-script-str&amp;gt;&lt;/code&gt; with optional input arguments &lt;code&gt;$arg1 $arg2 ...&lt;/code&gt;, and returns string output to &lt;code&gt;$res&lt;/code&gt;. The code in &lt;code&gt;&amp;lt;lua-script-str&amp;gt;&lt;/code&gt; can make &lt;a href=&quot;#nginx-api-for-lua&quot;&gt;API calls&lt;/a&gt; and can retrieve input arguments from the &lt;code&gt;ngx.arg&lt;/code&gt; table (index starts from &lt;code&gt;1&lt;/code&gt; and increases sequentially).</source>
          <target state="translated">使用可选的输入参数 &lt;code&gt;$arg1 $arg2 ...&lt;/code&gt; 执行 &lt;code&gt;&amp;lt;lua-script-str&amp;gt;&lt;/code&gt; 中指定的代码，并将字符串输出返回到 &lt;code&gt;$res&lt;/code&gt; 。 &lt;code&gt;&amp;lt;lua-script-str&amp;gt;&lt;/code&gt; 中的代码可以进行&lt;a href=&quot;#nginx-api-for-lua&quot;&gt;API调用，&lt;/a&gt;并且可以从 &lt;code&gt;ngx.arg&lt;/code&gt; 表中检索输入参数（索引从 &lt;code&gt;1&lt;/code&gt; 开始并依次增加）。</target>
        </trans-unit>
        <trans-unit id="1c12206113d2b57037d91f6489e2bbed1041dc1b" translate="yes" xml:space="preserve">
          <source>Explicitly discard the request body, i.e., read the data on the connection and throw it away immediately (without using the request body by any means).</source>
          <target state="translated">明确丢弃请求体,即读取连接上的数据并立即丢弃(不通过任何方式使用请求体)。</target>
        </trans-unit>
        <trans-unit id="f5814c9c7e3273369d1d62d8c845f804b67326ad" translate="yes" xml:space="preserve">
          <source>Explicitly send out the response headers.</source>
          <target state="translated">明确发送响应头。</target>
        </trans-unit>
        <trans-unit id="ca507048e6f0b797564f110900294aafce027666" translate="yes" xml:space="preserve">
          <source>Explicitly specify the end of the response output stream. In the case of HTTP 1.1 chunked encoded output, it will just trigger the Nginx core to send out the &quot;last chunk&quot;.</source>
          <target state="translated">明确指定响应输出流的结束。在HTTP 1.1分块编码输出的情况下,只会触发Nginx核心发送 &quot;最后一个分块&quot;。</target>
        </trans-unit>
        <trans-unit id="ab25e95ad23e40f6eb866bcbae94c86cf8068d65" translate="yes" xml:space="preserve">
          <source>Fatal errors in cosocket operations always automatically close the current connection (note that, read timeout error is the only error that is not fatal), and if you call &lt;a href=&quot;#tcpsockclose&quot;&gt;close&lt;/a&gt; on a closed connection, you will get the &quot;closed&quot; error.</source>
          <target state="translated">cosocket操作中的致命错误始终会自动关闭当前连接（请注意，读取超时错误是唯一不会致命的错误），如果在关闭的连接上调用&lt;a href=&quot;#tcpsockclose&quot;&gt;close&lt;/a&gt;，则会收到&amp;ldquo; closed&amp;rdquo;错误。</target>
        </trans-unit>
        <trans-unit id="835aa7ce5d740e606fa00ee0f91bc5cae8e84da8" translate="yes" xml:space="preserve">
          <source>Fetch a list of the keys from the dictionary, up to &lt;code&gt;&amp;lt;max_count&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">从字典中获取键列表，直到 &lt;code&gt;&amp;lt;max_count&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca997ba8650e8c2256c2941489e33c4f66ae673f" translate="yes" xml:space="preserve">
          <source>Fetching the shm-based Lua dictionary object for the shared memory zone named &lt;code&gt;DICT&lt;/code&gt; defined by the &lt;a href=&quot;#lua_shared_dict&quot;&gt;lua_shared_dict&lt;/a&gt; directive.</source>
          <target state="translated">为&lt;a href=&quot;#lua_shared_dict&quot;&gt;lua_shared_dict&lt;/a&gt;指令定义的名为 &lt;code&gt;DICT&lt;/code&gt; 的共享内存区域获取基于shm的Lua字典对象。</target>
        </trans-unit>
        <trans-unit id="d8efc283a60693ed74a3a3630cbf66e47031c184" translate="yes" xml:space="preserve">
          <source>Finally, you can just do the following in any Lua code run by ngx_lua:</source>
          <target state="translated">最后,你可以在任何由 ngx_lua 运行的 Lua 代码中执行以下操作。</target>
        </trans-unit>
        <trans-unit id="4a882477906a72a016763aaaedd8099e67a2ab03" translate="yes" xml:space="preserve">
          <source>Flushes out all the items in the dictionary. This method does not actuall free up all the memory blocks in the dictionary but just marks all the existing items as expired.</source>
          <target state="translated">清空字典中的所有项目。这个方法不会释放字典中的所有内存块,而只是将所有现有的项目标记为过期。</target>
        </trans-unit>
        <trans-unit id="3cc5eaad08c83373710debed7ee00745f4f8d182" translate="yes" xml:space="preserve">
          <source>Flushes out the expired items in the dictionary, up to the maximal number specified by the optional &lt;code&gt;max_count&lt;/code&gt; argument. When the &lt;code&gt;max_count&lt;/code&gt; argument is given &lt;code&gt;0&lt;/code&gt; or not given at all, then it means unlimited. Returns the number of items that have actually been flushed.</source>
          <target state="translated">清除字典中的过期项，直到由可选的 &lt;code&gt;max_count&lt;/code&gt; 参数指定的最大值。如果将 &lt;code&gt;max_count&lt;/code&gt; 参数设置为 &lt;code&gt;0&lt;/code&gt; 或根本不设置参数，则表示无限制。返回实际已刷新的项目数。</target>
        </trans-unit>
        <trans-unit id="129c1618975020c172306ba179594d500de058eb" translate="yes" xml:space="preserve">
          <source>Flushes response output to the client.</source>
          <target state="translated">将响应输出刷新到客户端。</target>
        </trans-unit>
        <trans-unit id="ec477f5bbf501d0b66178f3d4176a18efda8be4f" translate="yes" xml:space="preserve">
          <source>For connections that have already done SSL/TLS handshake, this method returns immediately.</source>
          <target state="translated">对于已经进行过SSL/TLS握手的连接,本方法立即返回。</target>
        </trans-unit>
        <trans-unit id="2038276fd97f85926c5a4b23ed50e50cf5439fe3" translate="yes" xml:space="preserve">
          <source>For every cosocket object's underlying connection, if you do not explicitly close it (via &lt;a href=&quot;#tcpsockclose&quot;&gt;close&lt;/a&gt;) or put it back to the connection pool (via &lt;a href=&quot;#tcpsocksetkeepalive&quot;&gt;setkeepalive&lt;/a&gt;), then it is automatically closed when one of the following two events happens:</source>
          <target state="translated">对于每个cosocket对象的基础连接，如果不显式关闭（通过&lt;a href=&quot;#tcpsockclose&quot;&gt;close&lt;/a&gt;）或将其放回连接池（通过&lt;a href=&quot;#tcpsocksetkeepalive&quot;&gt;setkeepalive&lt;/a&gt;），则在发生以下两个事件之一时，它将自动关闭：</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="132e22aaa89e3c51181cf591152b21565afcd701" translate="yes" xml:space="preserve">
          <source>For example, on Linux, you can configure the standard &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#listen&quot;&gt;listen&lt;/a&gt; directive in your &lt;code&gt;nginx.conf&lt;/code&gt; file like this:</source>
          <target state="translated">例如，在Linux上，您可以像下面这样在 &lt;code&gt;nginx.conf&lt;/code&gt; 文件中配置标准&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#listen&quot;&gt;监听&lt;/a&gt;指令：</target>
        </trans-unit>
        <trans-unit id="524deba8612f94c182a1072d829569a8b92cae95" translate="yes" xml:space="preserve">
          <source>For example, the following &lt;a href=&quot;http://github.com/openresty/set-misc-nginx-module&quot;&gt;set-misc-nginx-module&lt;/a&gt; directives can be invoked this way:</source>
          <target state="translated">例如，可以通过这种方式调用以下&lt;a href=&quot;http://github.com/openresty/set-misc-nginx-module&quot;&gt;set-misc-nginx-module&lt;/a&gt;指令：</target>
        </trans-unit>
        <trans-unit id="888ee1307c04ff5268bdb5c014c373a9f9e022d8" translate="yes" xml:space="preserve">
          <source>For example, the following nginx config snippet</source>
          <target state="translated">例如,下面是nginx的配置片段</target>
        </trans-unit>
        <trans-unit id="23b7041567e33cbc564ac905e83c0e92b5fee08b" translate="yes" xml:space="preserve">
          <source>For instance,</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="2243254b8d3334f140c01ed0f2fd04fdebc01c62" translate="yes" xml:space="preserve">
          <source>For large streaming output responses, it is important to disable the &lt;a href=&quot;#lua_http10_buffering&quot;&gt;lua_http10_buffering&lt;/a&gt; directive to minimise memory usage.</source>
          <target state="translated">对于大型流输出响应，重要的是禁用&lt;a href=&quot;#lua_http10_buffering&quot;&gt;lua_http10_buffering&lt;/a&gt;指令以最大程度地减少内存使用。</target>
        </trans-unit>
        <trans-unit id="5fa9bd6ca8ef2a9e5afbb12db75cbc330f4e7d25" translate="yes" xml:space="preserve">
          <source>For multi-value headers, all of the values of header will be collected in order and returned as a Lua table. For example, response headers</source>
          <target state="translated">对于多值头,所有头的值将被按顺序收集并以Lua表的形式返回。例如,响应头文件</target>
        </trans-unit>
        <trans-unit id="6b0305ec674b59e78fc78e9236b3cecc277de5be" translate="yes" xml:space="preserve">
          <source>For multiple instances of request headers such as:</source>
          <target state="translated">对于请求头的多个实例,如:</target>
        </trans-unit>
        <trans-unit id="a8b105e8a12da61107b0becbd1ea70e4e5b14dbe" translate="yes" xml:space="preserve">
          <source>For reading &lt;em&gt;request&lt;/em&gt; headers, use the &lt;a href=&quot;#ngxreqget_headers&quot;&gt;ngx.req.get_headers&lt;/a&gt; function instead.</source>
          <target state="translated">要读取&lt;em&gt;请求&lt;/em&gt;标头，请改用&lt;a href=&quot;#ngxreqget_headers&quot;&gt;ngx.req.get_headers&lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="0a4f898bb94fc02ef73f3690a54a97ee3d308065" translate="yes" xml:space="preserve">
          <source>For the first two cases, the &quot;light thread&quot; will usually be resumed later by the ngx_lua scheduler unless a &quot;stop-the-world&quot; event happens.</source>
          <target state="translated">对于前两种情况,&quot;轻线程 &quot;通常会在稍后被ngx_lua调度器恢复,除非发生 &quot;停止世界 &quot;事件。</target>
        </trans-unit>
        <trans-unit id="3308122160bc2877fdfdfcca4d2ab3689cd0648d" translate="yes" xml:space="preserve">
          <source>Forcibly updates the Nginx current time cache. This call involves a syscall and thus has some overhead, so do not abuse it.</source>
          <target state="translated">强制更新Nginx当前时间缓存。这个调用涉及到一个系统调用,因此有一些开销,所以不要滥用。</target>
        </trans-unit>
        <trans-unit id="c0a2d356e0e0d4d90067bb911e726f3eac7fdee9" translate="yes" xml:space="preserve">
          <source>Furthermore, one needs at least OpenSSL 1.0.2e for this directive to work.</source>
          <target state="translated">此外,这个指令至少需要OpenSSL 1.0.2e才行。</target>
        </trans-unit>
        <trans-unit id="834ae9e99b8b6a9826d729d0634f4fc5ab14acf9" translate="yes" xml:space="preserve">
          <source>HTTP 1.0 support</source>
          <target state="translated">支持HTTP 1.0</target>
        </trans-unit>
        <trans-unit id="1a4622e797b7743912ca2b88796464b6dcbe5f56" translate="yes" xml:space="preserve">
          <source>HTTP method constants</source>
          <target state="translated">HTTP方法常量</target>
        </trans-unit>
        <trans-unit id="28a0a7164e0b1418f1c3394ff78f4b046de17a3c" translate="yes" xml:space="preserve">
          <source>HTTP status constants</source>
          <target state="translated">HTTP状态常数</target>
        </trans-unit>
        <trans-unit id="87b503ee6f76be5b3f344961161f897b4c2e8a33" translate="yes" xml:space="preserve">
          <source>Here is a basic example:</source>
          <target state="translated">下面是一个基本的例子。</target>
        </trans-unit>
        <trans-unit id="e5727a1a012063f5d7f39cedf7dee4fa6e5d6fb4" translate="yes" xml:space="preserve">
          <source>Here is a complete small example:</source>
          <target state="translated">下面是一个完整的小例子。</target>
        </trans-unit>
        <trans-unit id="ea724b816190320574ae29c6484ba706b02e562b" translate="yes" xml:space="preserve">
          <source>Here is a simple example:</source>
          <target state="translated">下面是一个简单的例子。</target>
        </trans-unit>
        <trans-unit id="abf108a8df4414aaa34a5af0676733fd9f64d978" translate="yes" xml:space="preserve">
          <source>Here is a small example to demonstrate its basic usage:</source>
          <target state="translated">这里举一个小例子来演示它的基本用法。</target>
        </trans-unit>
        <trans-unit id="ab4601038071e90a3110c691f3d278bb312c50c8" translate="yes" xml:space="preserve">
          <source>Here is an example</source>
          <target state="translated">下面是一个例子</target>
        </trans-unit>
        <trans-unit id="7190b51d3af3f50398f760626d41f747c681ec72" translate="yes" xml:space="preserve">
          <source>Here is an example assuming the current server name is &lt;code&gt;localhost&lt;/code&gt; and that it is listening on port 1984:</source>
          <target state="translated">这是一个示例，假定当前服务器名称为 &lt;code&gt;localhost&lt;/code&gt; 且正在侦听端口1984：</target>
        </trans-unit>
        <trans-unit id="7ff1f55dc6eea9cf983ecb9a2754252e40f57471" translate="yes" xml:space="preserve">
          <source>Here is an example for connecting to a TCP server:</source>
          <target state="translated">下面是一个连接到TCP服务器的例子。</target>
        </trans-unit>
        <trans-unit id="16df324258cb4611dbfd62a6b207f20190f5f6c0" translate="yes" xml:space="preserve">
          <source>Here is an example for connecting to a UDP (memcached) server:</source>
          <target state="translated">下面是一个连接到UDP(memcached)服务器的例子。</target>
        </trans-unit>
        <trans-unit id="f4d22bdb4926576e6cb8442a48189a490820cdff" translate="yes" xml:space="preserve">
          <source>Here is an example for using this method to read a data stream with the boundary sequence &lt;code&gt;--abcedhb&lt;/code&gt;:</source>
          <target state="translated">这是使用此方法读取边界序列为 &lt;code&gt;--abcedhb&lt;/code&gt; 的数据流的示例：</target>
        </trans-unit>
        <trans-unit id="c06a9ee44a8aa1338a5f7412b1b34c328337dda4" translate="yes" xml:space="preserve">
          <source>Here is an example of gathering average data for &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_upstream_module.html#var_upstream_response_time&quot;&gt;$upstream_response_time&lt;/a&gt;:</source>
          <target state="translated">这是一个收集&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_upstream_module.html#var_upstream_response_time&quot;&gt;$ upstream_response_time的&lt;/a&gt;平均数据的示例：</target>
        </trans-unit>
        <trans-unit id="064f9b0b02634e2215035a4195d5910c0f16b45e" translate="yes" xml:space="preserve">
          <source>Here is an example of overriding a response header (or adding one if absent) in our Lua header filter:</source>
          <target state="translated">下面是一个在Lua头过滤器中覆盖响应头的例子(如果没有,则添加一个)。</target>
        </trans-unit>
        <trans-unit id="936eca4f242cdd82a38de414d305e2f31309d2fe" translate="yes" xml:space="preserve">
          <source>Here is an example of setting the &lt;code&gt;Content-Type&lt;/code&gt; header:</source>
          <target state="translated">这是设置 &lt;code&gt;Content-Type&lt;/code&gt; 标头的示例：</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="a6a11e9ba4fb83ee0ba0a48dfdf440be493f4277" translate="yes" xml:space="preserve">
          <source>Here is some examples:</source>
          <target state="translated">下面是一些例子。</target>
        </trans-unit>
        <trans-unit id="efaa732972663f1b7912dc2fce9e739444767f66" translate="yes" xml:space="preserve">
          <source>Here is the reason: by design, the global environment has exactly the same lifetime as the Nginx request handler associated with it. Each request handler has its own set of Lua global variables and that is the idea of request isolation. The Lua module is actually loaded by the first Nginx request handler and is cached by the &lt;code&gt;require()&lt;/code&gt; built-in in the &lt;code&gt;package.loaded&lt;/code&gt; table for later reference, and the &lt;code&gt;module()&lt;/code&gt; builtin used by some Lua modules has the side effect of setting a global variable to the loaded module table. But this global variable will be cleared at the end of the request handler, and every subsequent request handler all has its own (clean) global environment. So one will get Lua exception for accessing the &lt;code&gt;nil&lt;/code&gt; value.</source>
          <target state="translated">原因是：根据设计，全局环境的生存期与与其关联的Nginx请求处理程序完全相同。每个请求处理程序都有其自己的Lua全局变量集，这就是请求隔离的想法。 Lua模块实际上是由第一个Nginx请求处理程序加载的，并由 &lt;code&gt;package.loaded&lt;/code&gt; 表中内置的 &lt;code&gt;require()&lt;/code&gt; 缓存，以供以后参考，而某些Lua模块所使用的 &lt;code&gt;module()&lt;/code&gt; 内置有副作用加载的模块表的全局变量。但是，此全局变量将在请求处理程序的末尾清除，并且每个后续请求处理程序都有自己的（干净的）全局环境。因此，访问 &lt;code&gt;nil&lt;/code&gt; 值将导致Lua异常。</target>
        </trans-unit>
        <trans-unit id="7bcce11f878e044ead7760922e294b0ede073fe7" translate="yes" xml:space="preserve">
          <source>Here it essentially implements the &quot;wait all&quot; model.</source>
          <target state="translated">这里基本上实现了 &quot;全部等待 &quot;模式。</target>
        </trans-unit>
        <trans-unit id="f1319e81e84e6849c3f7a1e3a92eadfc193fc96a" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;args&lt;/code&gt; table will always look like</source>
          <target state="translated">在这里， &lt;code&gt;args&lt;/code&gt; 表将始终看起来像</target>
        </trans-unit>
        <trans-unit id="29fdd15f63d70dbdabc5fe387002bf8a40de4916" translate="yes" xml:space="preserve">
          <source>Here the Lua code &lt;code&gt;ngx.exit(503)&lt;/code&gt; will never run. This will be the case if &lt;code&gt;rewrite ^ /bar last&lt;/code&gt; is used as this will similarly initiate an internal redirection. If the &lt;code&gt;break&lt;/code&gt; modifier is used instead, there will be no internal redirection and the &lt;code&gt;rewrite_by_lua&lt;/code&gt; code will be executed.</source>
          <target state="translated">这里的Lua代码 &lt;code&gt;ngx.exit(503)&lt;/code&gt; 将永远不会运行。如果使用 &lt;code&gt;rewrite ^ /bar last&lt;/code&gt; 会是这种情况，因为这将类似地启动内部重定向。如果改用 &lt;code&gt;break&lt;/code&gt; 修饰符，则不会进行内部重定向，并且将执行 &lt;code&gt;rewrite_by_lua&lt;/code&gt; 代码。</target>
        </trans-unit>
        <trans-unit id="2a710c1c09c5bf83d52ca5927cfb832b53442915" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;[[\\d+]]&lt;/code&gt; is stripped down to &lt;code&gt;[[\d+]]&lt;/code&gt; by the Nginx config file parser and this is processed correctly.</source>
          <target state="translated">在这里， &lt;code&gt;[[\\d+]]&lt;/code&gt; 被Nginx配置文件解析器剥离为 &lt;code&gt;[[\d+]]&lt;/code&gt; ，并且已正确处理。</target>
        </trans-unit>
        <trans-unit id="d61d4f7c09eb6c109c3aecddb78bb107b4d4978d" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;\\\\d+&lt;/code&gt; is stripped down to &lt;code&gt;\\d+&lt;/code&gt; by the Nginx config file parser and this is further stripped down to &lt;code&gt;\d+&lt;/code&gt; by the Lua language parser before running.</source>
          <target state="translated">在这里，Nginx配置文件解析器将 &lt;code&gt;\\\\d+&lt;/code&gt; 简化为 &lt;code&gt;\\d+&lt;/code&gt; ，而在运行之前，Lua语言解析器会将其进一步简化为 &lt;code&gt;\d+&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="71e81a8c8ac4d5dbc873062e1734124d97de4de3" translate="yes" xml:space="preserve">
          <source>Here, modification of the &lt;code&gt;ngx.ctx.blah&lt;/code&gt; entry in the subrequest does not affect the one in the parent request. This is because they have two separate versions of &lt;code&gt;ngx.ctx.blah&lt;/code&gt;.</source>
          <target state="translated">在这里，子请求中 &lt;code&gt;ngx.ctx.blah&lt;/code&gt; 条目的修改不会影响父请求中的ngx.ctx.blah条目。这是因为它们有两个单独的 &lt;code&gt;ngx.ctx.blah&lt;/code&gt; 版本。</target>
        </trans-unit>
        <trans-unit id="9368bf706794ea693cb396265db206b3a85cb6f2" translate="yes" xml:space="preserve">
          <source>However, later attempts to manipulate the cosocket object will fail and return the actual error status message generated by the failed connect operation.</source>
          <target state="translated">但是,以后对cosocket对象的操作尝试将失败,并返回由失败的连接操作产生的实际错误状态消息。</target>
        </trans-unit>
        <trans-unit id="64b36a44792e92b2e62e16303bdc04165d6592a9" translate="yes" xml:space="preserve">
          <source>However, the optional &lt;code&gt;max_args&lt;/code&gt; function argument can be used to override this limit:</source>
          <target state="translated">但是，可以使用可选的 &lt;code&gt;max_args&lt;/code&gt; 函数参数来覆盖此限制：</target>
        </trans-unit>
        <trans-unit id="16476ba0f6439993e2a5cf1a2b564ff32097adee" translate="yes" xml:space="preserve">
          <source>However, the optional &lt;code&gt;max_headers&lt;/code&gt; function argument can be used to override this limit:</source>
          <target state="translated">但是，可以使用可选的 &lt;code&gt;max_headers&lt;/code&gt; 函数参数来覆盖此限制：</target>
        </trans-unit>
        <trans-unit id="33ca6682d96c11b2020f980cec3aefafbee8d44a" translate="yes" xml:space="preserve">
          <source>Identical to the standard Lua &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.running&quot;&gt;coroutine.running&lt;/a&gt; API.</source>
          <target state="translated">与标准Lua &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.running&quot;&gt;coroutine.running&lt;/a&gt; API 相同。</target>
        </trans-unit>
        <trans-unit id="baf73d9226c36ff807951a9eb684fd387d53fbf7" translate="yes" xml:space="preserve">
          <source>Identical to the standard Lua &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.status&quot;&gt;coroutine.status&lt;/a&gt; API.</source>
          <target state="translated">与标准Lua &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.status&quot;&gt;coroutine.status&lt;/a&gt; API 相同。</target>
        </trans-unit>
        <trans-unit id="6878ecfb6c510244611be91a3cc9a15d0bebd1a8" translate="yes" xml:space="preserve">
          <source>Idle connections in the pool will be monitored for any exceptional events like connection abortion or unexpected incoming data on the line, in which cases the connection in question will be closed and removed from the pool.</source>
          <target state="translated">池中的闲置连接将被监控,以防止发生任何特殊事件,如连接中止或线路上意外传入的数据,在这种情况下,有关连接将被关闭并从池中移除。</target>
        </trans-unit>
        <trans-unit id="40004bde4984f6de44357af2d2fabc4c36bff1ec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist, it is created as an empty list before performing the push operation. When the &lt;code&gt;key&lt;/code&gt; already takes a value that is not a list, it will return &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;&quot;value not a list&quot;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 不存在，则在执行推送操作之前将其创建为空列表。当 &lt;code&gt;key&lt;/code&gt; 已采用非列表值时，它将返回 &lt;code&gt;nil&lt;/code&gt; 和 &lt;code&gt;&quot;value not a list&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4505017ca3bde826de93b98e585f21f59b46d7f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist, it will return &lt;code&gt;nil&lt;/code&gt;. When the &lt;code&gt;key&lt;/code&gt; already takes a value that is not a list, it will return &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;&quot;value not a list&quot;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 不存在，它将返回 &lt;code&gt;nil&lt;/code&gt; 。当 &lt;code&gt;key&lt;/code&gt; 已采用非列表值时，它将返回 &lt;code&gt;nil&lt;/code&gt; 和 &lt;code&gt;&quot;value not a list&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a2a07772c34e8634d235bf9a4601943be99c7077" translate="yes" xml:space="preserve">
          <source>If a non-number-like string argument is specified, then it is interpreted as a &quot;pattern&quot;. The following patterns are supported:</source>
          <target state="translated">如果指定了一个非数字型字符串参数,那么它将被解释为 &quot;模式&quot;。支持以下模式:</target>
        </trans-unit>
        <trans-unit id="ea09aa6fff45ed8b081a30d931e1a055abcbaaf0" translate="yes" xml:space="preserve">
          <source>If a number-like argument is specified (including strings that look like numbers), then it is interpreted as a size. This method will not return until it reads exactly this size of data or an error occurs.</source>
          <target state="translated">如果指定了一个类似数字的参数(包括看起来像数字的字符串),那么它将被解释为一个大小。这个方法不会返回,直到它准确地读取这个大小的数据或发生错误。</target>
        </trans-unit>
        <trans-unit id="3562f4805f70337df0a3c1836f25652eefd8dc3e" translate="yes" xml:space="preserve">
          <source>If any request body data has been pre-read into the Nginx core request header buffer, the resulting cosocket object will take care of this to avoid potential data loss resulting from such pre-reading. Chunked request bodies are not yet supported in this API.</source>
          <target state="translated">如果任何请求体数据已经被预读到Nginx核心请求头缓冲区中,生成的cosocket对象将处理这个问题,以避免这种预读导致的潜在数据丢失。该API还不支持分块式请求体。</target>
        </trans-unit>
        <trans-unit id="bd3c3c79067b9e123a81f5493d5d75fbc01c9539" translate="yes" xml:space="preserve">
          <source>If key does not exist, it is interpreted as an empty list and 0 is returned. When the &lt;code&gt;key&lt;/code&gt; already takes a value that is not a list, it will return &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;&quot;value not a list&quot;&lt;/code&gt;.</source>
          <target state="translated">如果key不存在，则将其解释为空列表并返回0。当 &lt;code&gt;key&lt;/code&gt; 已采用非列表值时，它将返回 &lt;code&gt;nil&lt;/code&gt; 和 &lt;code&gt;&quot;value not a list&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="19ab7b9d1442f540c5aef9b2bd1d333ecffad992" translate="yes" xml:space="preserve">
          <source>If no argument is specified, then it is assumed to be the pattern &lt;code&gt;'*l'&lt;/code&gt;, that is, the line reading pattern.</source>
          <target state="translated">如果未指定任何参数，则假定其为模式 &lt;code&gt;'*l'&lt;/code&gt; ，即行读取模式。</target>
        </trans-unit>
        <trans-unit id="68ced9540eb5b96bf29e30c367fb2fdd6167c1ff" translate="yes" xml:space="preserve">
          <source>If no argument is specified, then the maximal buffer size, &lt;code&gt;8192&lt;/code&gt; is assumed.</source>
          <target state="translated">如果未指定任何参数，则假定最大缓冲区大小为 &lt;code&gt;8192&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7fc8985aa0e3ff420acceccfa0058e60b662d30b" translate="yes" xml:space="preserve">
          <source>If no match is found, this function just returns a &lt;code&gt;nil&lt;/code&gt; value.</source>
          <target state="translated">如果找不到匹配项，则此函数仅返回 &lt;code&gt;nil&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="75ca869a7146bac3959a49050799e3f56b4e42f6" translate="yes" xml:space="preserve">
          <source>If server-wide data sharing is required, then use one or more of the following approaches:</source>
          <target state="translated">如果需要在全服务器范围内共享数据,则使用以下一种或多种方法。</target>
        </trans-unit>
        <trans-unit id="4c0194760970731892880cca8ce9b02572fd4250" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_rewrite_module.html&quot;&gt;ngx_http_rewrite_module&lt;/a&gt;'s &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite&quot;&gt;rewrite&lt;/a&gt; directive is used to change the URI and initiate location re-lookups (internal redirections), then any &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt; or &lt;a href=&quot;#rewrite_by_lua_file&quot;&gt;rewrite_by_lua_file&lt;/a&gt; code sequences within the current location will not be executed. For example,</source>
          <target state="translated">如果使用&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_rewrite_module.html&quot;&gt;ngx_http_rewrite_module&lt;/a&gt;的&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite&quot;&gt;rewrite&lt;/a&gt;伪指令更改URI并启动位置重新查找（内部重定向），则将不执行当前位置内的任何&lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt;或&lt;a href=&quot;#rewrite_by_lua_file&quot;&gt;rewrite_by_lua_file&lt;/a&gt;代码序列。例如，</target>
        </trans-unit>
        <trans-unit id="26fdab53986200d577625b93f4ba51c258927eea" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;buffer_size&lt;/code&gt; argument is specified, then its value will be used for the size of the memory buffer for body writing with &lt;a href=&quot;#ngxreqappend_body&quot;&gt;ngx.req.append_body&lt;/a&gt;. If the argument is omitted, then the value specified by the standard &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size&quot;&gt;client_body_buffer_size&lt;/a&gt; directive will be used instead.</source>
          <target state="translated">如果指定了 &lt;code&gt;buffer_size&lt;/code&gt; 参数，则其值将用于通过&lt;a href=&quot;#ngxreqappend_body&quot;&gt;ngx.req.append_body&lt;/a&gt;进行主体写入的内存缓冲区的大小。如果省略该参数，则将使用标准&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size&quot;&gt;client_body_buffer_size&lt;/a&gt;指令指定的值。</target>
        </trans-unit>
        <trans-unit id="97ddceaa2265c38bb2f1c03973ee7b4ef7796a07" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; argument already exists in the dictionary (and not expired for sure), the &lt;code&gt;success&lt;/code&gt; return value will be &lt;code&gt;false&lt;/code&gt; and the &lt;code&gt;err&lt;/code&gt; return value will be &lt;code&gt;&quot;exists&quot;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 参数已经存在于字典中（并且肯定没有过期），则 &lt;code&gt;success&lt;/code&gt; 返回值将为 &lt;code&gt;false&lt;/code&gt; ，而 &lt;code&gt;err&lt;/code&gt; 返回值将为 &lt;code&gt;&quot;exists&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d363db88d3feab37e9126b2db9778728b54bae1d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; argument does &lt;em&gt;not&lt;/em&gt; exist in the dictionary (or expired already), the &lt;code&gt;success&lt;/code&gt; return value will be &lt;code&gt;false&lt;/code&gt; and the &lt;code&gt;err&lt;/code&gt; return value will be &lt;code&gt;&quot;not found&quot;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 参数在字典中&lt;em&gt;不&lt;/em&gt;存在（或已过期），则 &lt;code&gt;success&lt;/code&gt; 返回值将为 &lt;code&gt;false&lt;/code&gt; ，而 &lt;code&gt;err&lt;/code&gt; 返回值将为 &lt;code&gt;&quot;not found&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a55d02bbbc8e5fba7b4193e0585e5299372dec63" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;size&lt;/code&gt; argument is specified, then this method will use this size as the receive buffer size. But when this size is greater than &lt;code&gt;8192&lt;/code&gt;, then &lt;code&gt;8192&lt;/code&gt; will be used instead.</source>
          <target state="translated">如果指定了 &lt;code&gt;size&lt;/code&gt; 参数，则此方法将使用此大小作为接收缓冲区的大小。但是，当此大小大于 &lt;code&gt;8192&lt;/code&gt; 时，将使用 &lt;code&gt;8192&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="6238363d95a46a4c1f2816d246d0693b655148e6" translate="yes" xml:space="preserve">
          <source>If the Lua code explicitly sets a &lt;code&gt;Content-Length&lt;/code&gt; response header before sending the headers (either explicitly via &lt;a href=&quot;#ngxsend_headers&quot;&gt;ngx.send_headers&lt;/a&gt; or implicitly via the first &lt;a href=&quot;#ngxsay&quot;&gt;ngx.say&lt;/a&gt; or &lt;a href=&quot;#ngxprint&quot;&gt;ngx.print&lt;/a&gt; call), then the HTTP 1.0 response buffering will be disabled even when this directive is turned on.</source>
          <target state="translated">如果Lua代码在发送标头之前显式设置了 &lt;code&gt;Content-Length&lt;/code&gt; 响应标头（通过&lt;a href=&quot;#ngxsend_headers&quot;&gt;ngx.send_headers&lt;/a&gt;显式设置，或者通过第一个&lt;a href=&quot;#ngxsay&quot;&gt;ngx.say&lt;/a&gt;或&lt;a href=&quot;#ngxprint&quot;&gt;ngx.print&lt;/a&gt;隐式设置），则HTTP 1.0响应缓冲将被禁用，即使指令已打开。</target>
        </trans-unit>
        <trans-unit id="19cb3127687c1005e26ecf791e808f7f643f73a3" translate="yes" xml:space="preserve">
          <source>If the argument value is &lt;code&gt;false&lt;/code&gt;, then the effect is equivalent to the &lt;code&gt;nil&lt;/code&gt; value.</source>
          <target state="translated">如果参数值为 &lt;code&gt;false&lt;/code&gt; ，则效果等效于 &lt;code&gt;nil&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="9b6f09e61b081cbbea6b29a4a58173f21294051c" translate="yes" xml:space="preserve">
          <source>If the current connection does not come from the built-in connection pool, then this method always returns &lt;code&gt;0&lt;/code&gt;, that is, the connection has never been reused (yet). If the connection comes from the connection pool, then the return value is always non-zero. So this method can also be used to determine if the current connection comes from the pool.</source>
          <target state="translated">如果当前连接不是来自内置连接池，则此方法始终返回 &lt;code&gt;0&lt;/code&gt; ，即，该连接从未被重用（尚未）。如果连接来自连接池，则返回值始终为非零。因此，此方法还可用于确定当前连接是否来自池。</target>
        </trans-unit>
        <trans-unit id="22c6214b6890e522f9e10b060ae7a18d2a1c2af3" translate="yes" xml:space="preserve">
          <source>If the current location includes &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua*&lt;/a&gt; directives, then the request body will be read just before the &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua*&lt;/a&gt; code is run (and also at the &lt;code&gt;rewrite&lt;/code&gt; phase). Similarly, if only &lt;a href=&quot;#content_by_lua&quot;&gt;content_by_lua&lt;/a&gt; is specified, the request body will not be read until the content handler's Lua code is about to run (i.e., the request body will be read during the content phase).</source>
          <target state="translated">如果当前位置包括&lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua *&lt;/a&gt;指令，则将在运行&lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua *&lt;/a&gt;代码之前（以及在 &lt;code&gt;rewrite&lt;/code&gt; 阶段）读取请求正文。同样，如果仅指定&lt;a href=&quot;#content_by_lua&quot;&gt;content_by_lua&lt;/a&gt;，则在内容处理程序的Lua代码即将运行之前，将不读取请求正文（即，将在内容阶段读取请求正文）。</target>
        </trans-unit>
        <trans-unit id="90a8db7ecd2a387c69e72d8b63de9464e33e6d21" translate="yes" xml:space="preserve">
          <source>If the current request is an Nginx subrequest, then the subrequest's method name will be returned.</source>
          <target state="translated">如果当前请求是Nginx子请求,那么将返回子请求的方法名。</target>
        </trans-unit>
        <trans-unit id="1d2bc47f1d70b793560dea0ab5b18dfc9a509348" translate="yes" xml:space="preserve">
          <source>If the current request is an Nginx subrequest, then the subrequest's method will be overridden.</source>
          <target state="translated">如果当前请求是Nginx子请求,那么子请求的方法将被覆盖。</target>
        </trans-unit>
        <trans-unit id="389bee51266f11f959c19401f8517d13b4ec2d15" translate="yes" xml:space="preserve">
          <source>If the current request's request body has not been read, then it will be properly discarded. When the current request's request body has been read into memory or buffered into a disk file, then the old request body's memory will be freed or the disk file will be cleaned up immediately, respectively.</source>
          <target state="translated">如果当前请求的请求体还没有被读取,那么将被适当丢弃。当当前请求的请求体已被读入内存或缓冲到磁盘文件中时,则会分别立即释放旧请求体的内存或清理磁盘文件。</target>
        </trans-unit>
        <trans-unit id="dc8075ac8b97eaf72670a104d032ac2af234a37b" translate="yes" xml:space="preserve">
          <source>If the key does not exist (or has already expired), this method will return &lt;code&gt;nil&lt;/code&gt; and the error string &lt;code&gt;&quot;not found&quot;&lt;/code&gt;.</source>
          <target state="translated">如果密钥不存在（或已过期），则此方法将返回 &lt;code&gt;nil&lt;/code&gt; 并返回错误字符串 &lt;code&gt;&quot;not found&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0aa3ffd3930bc3f8c8298f3e8f6d91ab8402c96" translate="yes" xml:space="preserve">
          <source>If the key does not exist, this method will return &lt;code&gt;nil&lt;/code&gt; and the error string &lt;code&gt;&quot;not found&quot;&lt;/code&gt;.</source>
          <target state="translated">如果键不存在，则此方法将返回 &lt;code&gt;nil&lt;/code&gt; 并返回错误字符串 &lt;code&gt;&quot;not found&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="53d1584e9e515132cb0a50bece60b7082877307f" translate="yes" xml:space="preserve">
          <source>If the nameserver returns multiple IP addresses for the host name, this method will pick up one randomly.</source>
          <target state="translated">如果命名服务器为主机名返回多个IP地址,本方法将随机选取一个。</target>
        </trans-unit>
        <trans-unit id="f1806418371b6bf35324e34770835effa4399e6c" translate="yes" xml:space="preserve">
          <source>If the optional &lt;code&gt;auto_clean&lt;/code&gt; argument is given a &lt;code&gt;true&lt;/code&gt; value, then this file will be removed at request completion or the next time this function or &lt;a href=&quot;#ngxreqset_body_data&quot;&gt;ngx.req.set_body_data&lt;/a&gt; are called in the same request. The &lt;code&gt;auto_clean&lt;/code&gt; is default to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果为可选的 &lt;code&gt;auto_clean&lt;/code&gt; 参数提供了 &lt;code&gt;true&lt;/code&gt; 值，则此文件将在请求完成时或在下次在同一请求中调用此函数或&lt;a href=&quot;#ngxreqset_body_data&quot;&gt;ngx.req.set_body_data时删除&lt;/a&gt;。该 &lt;code&gt;auto_clean&lt;/code&gt; 默认为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1f843b5eb5551c8d5b0b6a364ae48099b903a876" translate="yes" xml:space="preserve">
          <source>If the original value is not a valid Lua number in the dictionary, it will return &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;&quot;not a number&quot;&lt;/code&gt;.</source>
          <target state="translated">如果原始值在字典中不是有效的Lua编号，则它将返回 &lt;code&gt;nil&lt;/code&gt; 和 &lt;code&gt;&quot;not a number&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="41cd58297b437ffe1b41752cc5797fa381384854" translate="yes" xml:space="preserve">
          <source>If the request body has already been explicitly discarded, either by the &lt;a href=&quot;#ngxreqdiscard_body&quot;&gt;ngx.req.discard_body&lt;/a&gt; function or other modules, this function does not run and returns immediately.</source>
          <target state="translated">如果&lt;a href=&quot;#ngxreqdiscard_body&quot;&gt;ngx.req.discard_body&lt;/a&gt;函数或其他模块已经明确舍弃了请求主体，则此函数将不运行并立即返回。</target>
        </trans-unit>
        <trans-unit id="008094ed8775cabe126ed59c6b85fe7fea9bd202" translate="yes" xml:space="preserve">
          <source>If the request body has already been read, this function does nothing and returns immediately.</source>
          <target state="translated">如果请求体已经被读取,这个函数什么也不做,立即返回。</target>
        </trans-unit>
        <trans-unit id="080d7f425676880165858290513bc1fee0805a4a" translate="yes" xml:space="preserve">
          <source>If the request body has been read into disk files, try calling the &lt;a href=&quot;#ngxreqget_body_file&quot;&gt;ngx.req.get_body_file&lt;/a&gt; function instead.</source>
          <target state="translated">如果请求正文已读入磁盘文件，请尝试调用&lt;a href=&quot;#ngxreqget_body_file&quot;&gt;ngx.req.get_body_file&lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="70ed23cec5f5e4594e5266bd4b7c88ae67c0fee6" translate="yes" xml:space="preserve">
          <source>If the request body has been read into memory, try calling the &lt;a href=&quot;#ngxreqget_body_data&quot;&gt;ngx.req.get_body_data&lt;/a&gt; function instead.</source>
          <target state="translated">如果请求主体已被读入内存，请尝试调用&lt;a href=&quot;#ngxreqget_body_data&quot;&gt;ngx.req.get_body_data&lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="edf28929152836d41cbf327c9c32c942d0499fd1" translate="yes" xml:space="preserve">
          <source>If the request body has not been read yet, call &lt;a href=&quot;#ngxreqread_body&quot;&gt;ngx.req.read_body&lt;/a&gt; first (or turned on &lt;a href=&quot;#lua_need_request_body&quot;&gt;lua_need_request_body&lt;/a&gt; to force this module to read the request body. This is not recommended however).</source>
          <target state="translated">如果尚未读取请求主体，请首先调用&lt;a href=&quot;#ngxreqread_body&quot;&gt;ngx.req.read_body&lt;/a&gt;（或打开&lt;a href=&quot;#lua_need_request_body&quot;&gt;lua_need_request_body&lt;/a&gt;强制此模块读取请求主体。但是，不建议这样做）。</target>
        </trans-unit>
        <trans-unit id="243f6d81ad0886073f9f6e7649f5a33edc435aed" translate="yes" xml:space="preserve">
          <source>If the request body is already read previously by turning on &lt;a href=&quot;#lua_need_request_body&quot;&gt;lua_need_request_body&lt;/a&gt; or by using other modules, then this function does not run and returns immediately.</source>
          <target state="translated">如果通过打开&lt;a href=&quot;#lua_need_request_body&quot;&gt;lua_need_request_body&lt;/a&gt;或使用其他模块已预先读取了请求正文，则此函数不会运行并立即返回。</target>
        </trans-unit>
        <trans-unit id="74498ce72b5020070467319d96628f81d1a50624" translate="yes" xml:space="preserve">
          <source>If the standard Lua 5.1 interpreter is required however, run the following command to install it from the Ubuntu repository:</source>
          <target state="translated">如果需要标准的Lua 5.1解释器,运行下面的命令从Ubuntu仓库中安装它。</target>
        </trans-unit>
        <trans-unit id="6b51b136869786e28e01758f4b32aa0c95de0467" translate="yes" xml:space="preserve">
          <source>If the user flags is &lt;code&gt;0&lt;/code&gt; (the default), then no flags value will be returned.</source>
          <target state="translated">如果用户标志为 &lt;code&gt;0&lt;/code&gt; （默认值），则不会返回任何标志值。</target>
        </trans-unit>
        <trans-unit id="53d587529d756db1aef53e849e4b4d97a387d2f8" translate="yes" xml:space="preserve">
          <source>If the value table is empty and the effect is equivalent to the &lt;code&gt;nil&lt;/code&gt; value.</source>
          <target state="translated">如果值表为空并且效果等于 &lt;code&gt;nil&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="cb6e47c07094c55368bff941d5a16f4932ecb094" translate="yes" xml:space="preserve">
          <source>If this method succeeds in storing the current item by forcibly removing other not-yet-expired items in the dictionary via LRU, the &lt;code&gt;forcible&lt;/code&gt; return value will be &lt;code&gt;true&lt;/code&gt;. If it stores the item without forcibly removing other valid items, then the return value &lt;code&gt;forcible&lt;/code&gt; will be &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果此方法通过通过LRU强制删除字典中其他尚未过期的项目成功地存储了当前项目，则 &lt;code&gt;forcible&lt;/code&gt; 返回值将为 &lt;code&gt;true&lt;/code&gt; 。如果在不强制删除其他有效项目的情况下存储该项目，则 &lt;code&gt;forcible&lt;/code&gt; 返回值将为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bbf81d43a2561a052178a78b671cb486cb42a995" translate="yes" xml:space="preserve">
          <source>If you are not using the NGINX core shipped with &lt;a href=&quot;https://openresty.org&quot;&gt;OpenResty&lt;/a&gt; 1.11.2.1 or later, then you need to apply the following patch to the standard NGINX core 1.11.2 or later:</source>
          <target state="translated">如果您未使用&lt;a href=&quot;https://openresty.org&quot;&gt;OpenResty&lt;/a&gt; 1.11.2.1或更高版本随附的NGINX内核，则需要将以下补丁应用于标准NGINX内核1.11.2或更高版本：</target>
        </trans-unit>
        <trans-unit id="27fb3820ddb4d9d480e974c0e4e6536ea39bc288" translate="yes" xml:space="preserve">
          <source>If you are using OpenSSL libraries not provided by &lt;a href=&quot;https://openresty.org&quot;&gt;OpenResty&lt;/a&gt;, then you need to apply the following patch for OpenSSL 1.0.2h or later:</source>
          <target state="translated">如果您使用的不是&lt;a href=&quot;https://openresty.org&quot;&gt;OpenResty&lt;/a&gt;提供的OpenSSL库，则需要为OpenSSL 1.0.2h或更高版本应用以下修补程序：</target>
        </trans-unit>
        <trans-unit id="413302d3c499d48d75063214c7b670f193f771a0" translate="yes" xml:space="preserve">
          <source>If you are using the &lt;a href=&quot;http://openresty.org/en/linux-packages.html&quot;&gt;official pre-built packages&lt;/a&gt; for &lt;a href=&quot;https://openresty.org/&quot;&gt;OpenResty&lt;/a&gt; 1.11.2.1 or later, then everything should work out of the box.</source>
          <target state="translated">如果您使用的是&lt;a href=&quot;https://openresty.org/&quot;&gt;OpenResty&lt;/a&gt; 1.11.2.1或更高版本的&lt;a href=&quot;http://openresty.org/en/linux-packages.html&quot;&gt;官方预编译软件包&lt;/a&gt;，则应立即使用所有功能。</target>
        </trans-unit>
        <trans-unit id="66d4ab64171ccd6fcfa24ef69863eb5f4231d67c" translate="yes" xml:space="preserve">
          <source>If you are using the &lt;code&gt;ngx.re.*&lt;/code&gt; implementation of &lt;a href=&quot;https://github.com/openresty/lua-resty-core&quot;&gt;lua-resty-core&lt;/a&gt; by loading the &lt;code&gt;resty.core.regex&lt;/code&gt; module (or just the &lt;code&gt;resty.core&lt;/code&gt; module), then an LRU cache is used for the regex cache being used here.</source>
          <target state="translated">如果通过加载 &lt;code&gt;resty.core.regex&lt;/code&gt; 模块（或只是 &lt;code&gt;resty.core&lt;/code&gt; 模块）来使用&lt;a href=&quot;https://github.com/openresty/lua-resty-core&quot;&gt;lua-resty-core&lt;/a&gt;的 &lt;code&gt;ngx.re.*&lt;/code&gt; 实现，则LRU缓存用于此处使用的regex缓存。</target>
        </trans-unit>
        <trans-unit id="f27497c767e134254218418d2eba69f16df5b04a" translate="yes" xml:space="preserve">
          <source>If you have just too many &lt;code&gt;.o&lt;/code&gt; files, then it might not be feasible to name them all in a single command. In this case, you can build a static library (or archive) for your &lt;code&gt;.o&lt;/code&gt; files, as in</source>
          <target state="translated">如果 &lt;code&gt;.o&lt;/code&gt; 文件太多，则在单个命令中将它们全部命名可能是不可行的。在这种情况下，您可以为 &lt;code&gt;.o&lt;/code&gt; 文件构建静态库（或存档），如下所示：</target>
        </trans-unit>
        <trans-unit id="7f048479ab0021ca0341874e956da0fd566de45f" translate="yes" xml:space="preserve">
          <source>If you want to access the system environment variable, say, &lt;code&gt;foo&lt;/code&gt;, in Lua via the standard Lua API &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-os.getenv&quot;&gt;os.getenv&lt;/a&gt;, then you should also list this environment variable name in your &lt;code&gt;nginx.conf&lt;/code&gt; file via the &lt;a href=&quot;http://nginx.org/en/docs/ngx_core_module.html#env&quot;&gt;env directive&lt;/a&gt;. For example,</source>
          <target state="translated">如果要通过标准Lua API &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-os.getenv&quot;&gt;os.getenv&lt;/a&gt;访问Lua中的系统环境变量 &lt;code&gt;foo&lt;/code&gt; ，则还应该通过&lt;a href=&quot;http://nginx.org/en/docs/ngx_core_module.html#env&quot;&gt;env指令&lt;/a&gt;在 &lt;code&gt;nginx.conf&lt;/code&gt; 文件中列出此环境变量名称。例如，</target>
        </trans-unit>
        <trans-unit id="d3345fe0380d28ca31796be10a97afe321dd4927" translate="yes" xml:space="preserve">
          <source>If you want to use dot in the Lua module name when calling &lt;code&gt;require&lt;/code&gt;, as in</source>
          <target state="translated">如果要在调用 &lt;code&gt;require&lt;/code&gt; 时在Lua模块名称中使用点号，例如</target>
        </trans-unit>
        <trans-unit id="a4d6b0ca63702450444cb702c9b56c73fe4d67b0" translate="yes" xml:space="preserve">
          <source>In addition to the two settings above, it is possible to specify values for variables in the subrequest using the &lt;code&gt;vars&lt;/code&gt; option. These variables are set after the sharing or copying of variables has been evaluated, and provides a more efficient method of passing specific values to a subrequest over encoding them as URL arguments and unescaping them in the Nginx config file.</source>
          <target state="translated">除了上面的两个设置，还可以使用 &lt;code&gt;vars&lt;/code&gt; 选项为子请求中的变量指定值。这些变量是在评估了变量的共享或复制之后设置的，并提供了一种更有效的方法，即通过将特定值编码为URL参数并将其转义到Nginx配置文件中，将特定值传递给子请求。</target>
        </trans-unit>
        <trans-unit id="4d2ba848e28f8c57af8d105a0bc48a32b2b9b450" translate="yes" xml:space="preserve">
          <source>In addition, note that this directive can only write out a value to a single Nginx variable at a time. However, a workaround is possible using the &lt;a href=&quot;#ngxvarvariable&quot;&gt;ngx.var.VARIABLE&lt;/a&gt; interface.</source>
          <target state="translated">另外，请注意，此伪指令一次只能将一个值写出到单个Nginx变量中。但是，可以使用&lt;a href=&quot;#ngxvarvariable&quot;&gt;ngx.var.VARIABLE&lt;/a&gt;接口来解决。</target>
        </trans-unit>
        <trans-unit id="6d0968ba8d73bccfff8b9ca559c1f62f79a152c4" translate="yes" xml:space="preserve">
          <source>In case of any connection errors, this method always automatically closes the current connection.</source>
          <target state="translated">如果出现任何连接错误,该方法总是自动关闭当前连接。</target>
        </trans-unit>
        <trans-unit id="311c4afeb45d698793bf7dc7ccc7ca9b2783980d" translate="yes" xml:space="preserve">
          <source>In case of error, &lt;code&gt;nil&lt;/code&gt; will be returned as well as a string describing the error.</source>
          <target state="translated">如果发生错误，将返回 &lt;code&gt;nil&lt;/code&gt; 以及描述错误的字符串。</target>
        </trans-unit>
        <trans-unit id="7393a8162db596df32803dcb6345a6ac55c34a0b" translate="yes" xml:space="preserve">
          <source>In case of error, the iterator function will return &lt;code&gt;nil&lt;/code&gt; along with a string describing the error and the partial data bytes that have been read so far.</source>
          <target state="translated">如果发生错误，则迭代器函数将返回 &lt;code&gt;nil&lt;/code&gt; 以及描述错误的字符串以及到目前为止已读取的部分数据字节。</target>
        </trans-unit>
        <trans-unit id="b0925789327ff6ba9c9418ce55d54b02e1c29600" translate="yes" xml:space="preserve">
          <source>In case of error, the method returns &lt;code&gt;nil&lt;/code&gt; followed by a string describing the error. In case of success, the method returns &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">如果发生错误，该方法将返回 &lt;code&gt;nil&lt;/code&gt; ,后跟描述错误的字符串。如果成功，则该方法返回 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c2134316a504c9aca49cc29645047815fb404fa7" translate="yes" xml:space="preserve">
          <source>In case of errors (like bad regexes or any PCRE runtime errors), this API function returns two &lt;code&gt;nil&lt;/code&gt; values followed by a string describing the error.</source>
          <target state="translated">如果出现错误（例如错误的正则表达式或任何PCRE运行时错误），此API函数将返回两个 &lt;code&gt;nil&lt;/code&gt; 值，后跟描述错误的字符串。</target>
        </trans-unit>
        <trans-unit id="1e76a49880543d9a2f3cfd64cc5b568bb19dea50" translate="yes" xml:space="preserve">
          <source>In case of errors, &lt;code&gt;nil&lt;/code&gt; and a string describing the error will be returned.</source>
          <target state="translated">如果发生错误，将返回 &lt;code&gt;nil&lt;/code&gt; 和描述错误的字符串。</target>
        </trans-unit>
        <trans-unit id="6821a30dddcaffd6871e483b4247616b17dd93e2" translate="yes" xml:space="preserve">
          <source>In case of errors, like seeing an ill-formed regular expression, &lt;code&gt;nil&lt;/code&gt; and a string describing the error will be returned.</source>
          <target state="translated">在出现错误的情况下，例如看到格式不正确的正则表达式，将返回 &lt;code&gt;nil&lt;/code&gt; 和描述错误的字符串。</target>
        </trans-unit>
        <trans-unit id="0e4141e5771983ca2351d0b1c34393a563d7181c" translate="yes" xml:space="preserve">
          <source>In case of errors, such as connection errors while reading the data, this method will throw out a Lua exception &lt;em&gt;or&lt;/em&gt; terminate the current request with a 500 status code immediately.</source>
          <target state="translated">如果出现错误（例如在读取数据时出现连接错误），则此方法将抛出Lua异常&lt;em&gt;或&lt;/em&gt;立即使用状态码500终止当前请求。</target>
        </trans-unit>
        <trans-unit id="0fe8c65efa85d898d964be287431d845c13e5813" translate="yes" xml:space="preserve">
          <source>In case of success, it returns &lt;code&gt;1&lt;/code&gt;. Otherwise, it returns &lt;code&gt;nil&lt;/code&gt; and a string describing the error.</source>
          <target state="translated">如果成功，则返回 &lt;code&gt;1&lt;/code&gt; 。否则，它返回 &lt;code&gt;nil&lt;/code&gt; 和描述错误的字符串。</target>
        </trans-unit>
        <trans-unit id="7742db78c2a593b5d719bcf5993594e82b9fbe46" translate="yes" xml:space="preserve">
          <source>In case of success, it returns the data received; in case of error, it returns &lt;code&gt;nil&lt;/code&gt; with a string describing the error and the partial data received so far.</source>
          <target state="translated">如果成功，它将返回接收到的数据。如果发生错误，它将返回 &lt;code&gt;nil&lt;/code&gt; 并带有描述错误的字符串和到目前为止接收到的部分数据。</target>
        </trans-unit>
        <trans-unit id="218ee506c35c3bc4c45279ef98625a498d0cfc99" translate="yes" xml:space="preserve">
          <source>In case of success, it returns the data received; in case of error, it returns &lt;code&gt;nil&lt;/code&gt; with a string describing the error.</source>
          <target state="translated">如果成功，它将返回接收到的数据。如果发生错误，它将返回 &lt;code&gt;nil&lt;/code&gt; 并带有描述错误的字符串。</target>
        </trans-unit>
        <trans-unit id="d127ab022b361338f8c136b692b125e7c48c1cd8" translate="yes" xml:space="preserve">
          <source>In case of success, it returns the total number of bytes that have been sent. Otherwise, it returns &lt;code&gt;nil&lt;/code&gt; and a string describing the error.</source>
          <target state="translated">如果成功，它将返回已发送的字节总数。否则，它返回 &lt;code&gt;nil&lt;/code&gt; 和描述错误的字符串。</target>
        </trans-unit>
        <trans-unit id="38ce78a1746b2febc95c4da1a98a0d3f76ad1b67" translate="yes" xml:space="preserve">
          <source>In case of success, this method returns &lt;code&gt;1&lt;/code&gt;; otherwise, it returns &lt;code&gt;nil&lt;/code&gt; and a string describing the error.</source>
          <target state="translated">如果成功，此方法返回 &lt;code&gt;1&lt;/code&gt; ; 否则，它返回 &lt;code&gt;nil&lt;/code&gt; 和描述错误的字符串。</target>
        </trans-unit>
        <trans-unit id="a7bce528c3904e1a460cb8fe08ff26a51f56807a" translate="yes" xml:space="preserve">
          <source>In cases where current request may have a request body and the request body data is not required, The &lt;a href=&quot;#ngxreqdiscard_body&quot;&gt;ngx.req.discard_body&lt;/a&gt; function must be used to explicitly discard the request body to avoid breaking things under HTTP 1.1 keepalive or HTTP 1.1 pipelining.</source>
          <target state="translated">如果当前请求可能具有请求主体，并且不需要该请求主体数据，则必须使用&lt;a href=&quot;#ngxreqdiscard_body&quot;&gt;ngx.req.discard_body&lt;/a&gt;函数显式丢弃该请求主体，以避免破坏HTTP 1.1 keepalive或HTTP 1.1流水线操作。</target>
        </trans-unit>
        <trans-unit id="4a73185e2f3a4040127d36d48b929d80df8bfaf2" translate="yes" xml:space="preserve">
          <source>In synchronous mode, the function will not return until all output data has been written into the system send buffer or until the &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#send_timeout&quot;&gt;send_timeout&lt;/a&gt; setting has expired. Note that using the Lua coroutine mechanism means that this function does not block the Nginx event loop even in the synchronous mode.</source>
          <target state="translated">在同步模式下，该功能将不会返回，除非所有输出数据都已写入系统发送缓冲区或&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#send_timeout&quot;&gt;send_timeout&lt;/a&gt;设置到期。请注意，使用Lua协程机制意味着即使在同步模式下，此功能也不会阻止Nginx事件循环。</target>
        </trans-unit>
        <trans-unit id="802426cce4f3045aa39317d15827a3ba9e7c29b0" translate="yes" xml:space="preserve">
          <source>Increments the (numerical) value for &lt;code&gt;key&lt;/code&gt; in the shm-based dictionary &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt; by the step value &lt;code&gt;value&lt;/code&gt;. Returns the new resulting number if the operation is successfully completed or &lt;code&gt;nil&lt;/code&gt; and an error message otherwise.</source>
          <target state="translated">将基于shm的字典&lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;中的 &lt;code&gt;key&lt;/code&gt; 的（数字）值增加step值 &lt;code&gt;value&lt;/code&gt; 。如果操作成功完成，则返回新的结果编号，否则返回 &lt;code&gt;nil&lt;/code&gt; ，否则返回错误消息。</target>
        </trans-unit>
        <trans-unit id="2fc2ad07eee1733026be591bbeedcad26b5b39bb" translate="yes" xml:space="preserve">
          <source>Inserts the specified (numerical or string) &lt;code&gt;value&lt;/code&gt; at the head of the list named &lt;code&gt;key&lt;/code&gt; in the shm-based dictionary &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;. Returns the number of elements in the list after the push operation.</source>
          <target state="translated">将指定的（数字或字符串） &lt;code&gt;value&lt;/code&gt; 插入基于shm的字典&lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;中名为 &lt;code&gt;key&lt;/code&gt; 的列表的开头。返回推送操作后列表中的元素数。</target>
        </trans-unit>
        <trans-unit id="590b0cababa8662b5343717a1ba8909d9c98efc2" translate="yes" xml:space="preserve">
          <source>Install LuaJIT 2.0 or 2.1 (recommended) or Lua 5.1 (Lua 5.2 is &lt;em&gt;not&lt;/em&gt; supported yet). LuaJIT can be downloaded from the &lt;a href=&quot;http://luajit.org/download.html&quot;&gt;LuaJIT project website&lt;/a&gt; and Lua 5.1, from the &lt;a href=&quot;http://www.lua.org/&quot;&gt;Lua project website&lt;/a&gt;. Some distribution package managers also distribute LuaJIT and/or Lua.</source>
          <target state="translated">安装LuaJIT 2.0或2.1（推荐）或Lua 5.1（&lt;em&gt;尚不&lt;/em&gt;支持Lua 5.2 ）。可以从&lt;a href=&quot;http://luajit.org/download.html&quot;&gt;LuaJIT项目网站&lt;/a&gt;下载LuaJIT，从&lt;a href=&quot;http://www.lua.org/&quot;&gt;Lua项目网站&lt;/a&gt;下载Lua 5.1 。一些分发包管理器还分发LuaJIT和/或Lua。</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="2cde7a2555a654be3a162ceea7abb83796dbd083" translate="yes" xml:space="preserve">
          <source>Installation on Ubuntu 11.10</source>
          <target state="translated">在Ubuntu 11.10上安装</target>
        </trans-unit>
        <trans-unit id="73952aabeb57ac87f4bba98bee5c27606429ace4" translate="yes" xml:space="preserve">
          <source>Internal redirection will destroy the original request &lt;code&gt;ngx.ctx&lt;/code&gt; data (if any) and the new request will have an empty &lt;code&gt;ngx.ctx&lt;/code&gt; table. For instance,</source>
          <target state="translated">内部重定向将破坏原始请求 &lt;code&gt;ngx.ctx&lt;/code&gt; 数据（如果有），而新请求将具有一个空的 &lt;code&gt;ngx.ctx&lt;/code&gt; 表。例如，</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="4dce3d43238a392c1241cdb3c7a5962b78297cc2" translate="yes" xml:space="preserve">
          <source>Introduction to ngx_lua</source>
          <target state="translated">ngx_lua简介</target>
        </trans-unit>
        <trans-unit id="5b1afcf1dbf33195a09d5aafc7fa07255aa44bbb" translate="yes" xml:space="preserve">
          <source>Issue an &lt;code&gt;HTTP 301&lt;/code&gt; or &lt;code&gt;302&lt;/code&gt; redirection to &lt;code&gt;uri&lt;/code&gt;.</source>
          <target state="translated">发出 &lt;code&gt;HTTP 301&lt;/code&gt; 或 &lt;code&gt;302&lt;/code&gt; 重定向到 &lt;code&gt;uri&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91ce8a01d926166c5706fe0776bc2a11b40147e2" translate="yes" xml:space="preserve">
          <source>Issues a synchronous but still non-blocking &lt;em&gt;Nginx Subrequest&lt;/em&gt; using &lt;code&gt;uri&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;uri&lt;/code&gt; 发出同步但仍非阻塞的&lt;em&gt;Nginx Subrequest&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="0760872ba23d0cde13af33b5304ba1d4cae4fe3c" translate="yes" xml:space="preserve">
          <source>Issuing a POST subrequest, for example, can be done as follows</source>
          <target state="translated">例如,发出一个POST子请求,可以按以下方式完成</target>
        </trans-unit>
        <trans-unit id="afc974545a490e483360ca2134cd7b6c71270ae0" translate="yes" xml:space="preserve">
          <source>It is &lt;code&gt;302&lt;/code&gt; (&lt;code&gt;ngx.HTTP_MOVED_TEMPORARILY&lt;/code&gt;) by default.</source>
          <target state="translated">默认为 &lt;code&gt;302&lt;/code&gt; （ &lt;code&gt;ngx.HTTP_MOVED_TEMPORARILY&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="4980218dbb51a70cacc02d4763a046d96c95cdfb" translate="yes" xml:space="preserve">
          <source>It is &lt;em&gt;highly&lt;/em&gt; recommended to use &lt;a href=&quot;http://openresty.org&quot;&gt;OpenResty releases&lt;/a&gt; which integrate Nginx, ngx_lua, LuaJIT 2.1, as well as other powerful companion Nginx modules and Lua libraries. It is discouraged to build this module with nginx yourself since it is tricky to set up exactly right. Also, the stock nginx cores have various limitations and long standing bugs that can make some of this modules' features become disabled, not work properly, or run slower. The same applies to LuaJIT as well. OpenResty includes its own version of LuaJIT which gets specifically optimized and enhanced for the OpenResty environment.</source>
          <target state="translated">这是&lt;em&gt;强烈&lt;/em&gt;建议使用&lt;a href=&quot;http://openresty.org&quot;&gt;OpenResty发布&lt;/a&gt;其整合的Nginx，ngx_lua，LuaJIT 2.1，以及其他强大的同伴Nginx的模块和Lua库。不建议您自己使用nginx来构建此模块，因为要正确地设置它很棘手。而且，现有的nginx内核具有各种局限性和长期存在的错误，这些错误可能导致该模块的某些功能被禁用，无法正常工作或运行缓慢。LuaJIT也是如此。OpenResty包含自己的LuaJIT版本，该版本针对OpenResty环境进行了专门优化和增强。</target>
        </trans-unit>
        <trans-unit id="182b3d046d25f95d8271b373f8b64c013f197a36" translate="yes" xml:space="preserve">
          <source>It is also possible to directly require the packages in external Lua modules:</source>
          <target state="translated">也可以直接要求外部Lua模块中的包。</target>
        </trans-unit>
        <trans-unit id="ea33926547830174fc18b5c412ab6934e6d74ce1" translate="yes" xml:space="preserve">
          <source>It is also possible to use this &lt;code&gt;ctx&lt;/code&gt; option to share the same &lt;a href=&quot;#ngxctx&quot;&gt;ngx.ctx&lt;/a&gt; table between the current (parent) request and the subrequest:</source>
          <target state="translated">也可以使用此 &lt;code&gt;ctx&lt;/code&gt; 选项在当前（父）请求和子请求之间共享相同的&lt;a href=&quot;#ngxctx&quot;&gt;ngx.ctx&lt;/a&gt;表：</target>
        </trans-unit>
        <trans-unit id="26cb0deebc5382597abfb9cef263ffa1378ccce5" translate="yes" xml:space="preserve">
          <source>It is equivalent to</source>
          <target state="translated">它相当于</target>
        </trans-unit>
        <trans-unit id="82da831557ca01d8af65fa32b24d5cef10269f05" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;ngx.shared.DICT:set(key, nil)&lt;/code&gt;.</source>
          <target state="translated">它等效于 &lt;code&gt;ngx.shared.DICT:set(key, nil)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ed65ff252528d5d5a0ee3292105232c05ec7e35" translate="yes" xml:space="preserve">
          <source>It is important here to call the &lt;a href=&quot;#tcpsocksettimeout&quot;&gt;settimeout&lt;/a&gt; method &lt;em&gt;before&lt;/em&gt; calling the iterator function (note that the &lt;code&gt;receiveuntil&lt;/code&gt; call is irrelevant here).</source>
          <target state="translated">重要的是&lt;em&gt;在&lt;/em&gt;调用迭代器函数&lt;em&gt;之前先&lt;/em&gt;调用&lt;a href=&quot;#tcpsocksettimeout&quot;&gt;settimeout&lt;/a&gt;方法（请注意， &lt;code&gt;receiveuntil&lt;/code&gt; 调用与此处无关）。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9747f557e27f2eeadb0651c707b695837e6bc2f3" translate="yes" xml:space="preserve">
          <source>It is important here to call the &lt;a href=&quot;#tcpsocksettimeout&quot;&gt;settimeout&lt;/a&gt; method &lt;em&gt;before&lt;/em&gt; calling this method.</source>
          <target state="translated">重要的是在这里调用&lt;a href=&quot;#tcpsocksettimeout&quot;&gt;setTimeout的&lt;/a&gt;方法&lt;em&gt;之前&lt;/em&gt;调用此方法。</target>
        </trans-unit>
        <trans-unit id="98d87dbeb06eca884ff458d86f3dfea33440e5c1" translate="yes" xml:space="preserve">
          <source>It is important here to call the &lt;a href=&quot;#udpsocksettimeout&quot;&gt;settimeout&lt;/a&gt; method &lt;em&gt;before&lt;/em&gt; calling this method.</source>
          <target state="translated">重要的是在这里调用&lt;a href=&quot;#udpsocksettimeout&quot;&gt;setTimeout的&lt;/a&gt;方法&lt;em&gt;之前&lt;/em&gt;调用此方法。</target>
        </trans-unit>
        <trans-unit id="9be5000189cee7a41f7d06b037f34d000ee14673" translate="yes" xml:space="preserve">
          <source>It is important to always call the &lt;a href=&quot;#ngxreqfinish_body&quot;&gt;ngx.req.finish_body&lt;/a&gt; after all the data has been appended onto the current request body.</source>
          <target state="translated">在将所有数据附加到当前请求正文之后，始终调用&lt;a href=&quot;#ngxreqfinish_body&quot;&gt;ngx.req.finish_body&lt;/a&gt;很重要。</target>
        </trans-unit>
        <trans-unit id="eb343e80808a2e43fa0534dd1e7f387ed22bed82" translate="yes" xml:space="preserve">
          <source>It is important to always call the &lt;a href=&quot;#ngxreqfinish_body&quot;&gt;ngx.req.finish_body&lt;/a&gt; after all the data has been appended onto the current request body. Also, when this function is used together with &lt;a href=&quot;#ngxreqsocket&quot;&gt;ngx.req.socket&lt;/a&gt;, it is required to call &lt;a href=&quot;#ngxreqsocket&quot;&gt;ngx.req.socket&lt;/a&gt;&lt;em&gt;before&lt;/em&gt; this function, or you will get the &quot;request body already exists&quot; error message.</source>
          <target state="translated">在将所有数据附加到当前请求正文之后，始终调用&lt;a href=&quot;#ngxreqfinish_body&quot;&gt;ngx.req.finish_body&lt;/a&gt;很重要。此外，当将此函数与&lt;a href=&quot;#ngxreqsocket&quot;&gt;ngx.req.socket&lt;/a&gt;一起使用时，需要&lt;em&gt;在&lt;/em&gt;此函数&lt;em&gt;之前&lt;/em&gt;调用&lt;a href=&quot;#ngxreqsocket&quot;&gt;ngx.req.socket&lt;/a&gt;，否则您将收到&amp;ldquo;请求主体已存在&amp;rdquo;错误消息。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="831a93a9266cbbd5c64b1570abbd0b8ed8dbf185" translate="yes" xml:space="preserve">
          <source>It is important to use exactly the same version of LuaJIT when compiling &lt;code&gt;.lua&lt;/code&gt; files to &lt;code&gt;.o&lt;/code&gt; files as building nginx + ngx_lua. This is because the LuaJIT bytecode format may be incompatible between different LuaJIT versions. When the bytecode format is incompatible, you will see a Lua runtime error saying that the Lua module is not found.</source>
          <target state="translated">将 &lt;code&gt;.lua&lt;/code&gt; 文件编译为 &lt;code&gt;.o&lt;/code&gt; 文件时，使用与构建nginx + ngx_lua 完全相同的LuaJIT版本非常重要。这是因为LuaJIT字节码格式可能在不同的LuaJIT版本之间不兼容。当字节码格式不兼容时，您将看到一个Lua运行时错误，指出未找到Lua模块。</target>
        </trans-unit>
        <trans-unit id="5bdeb4bb34c25239880d1f550257b58c8335625e" translate="yes" xml:space="preserve">
          <source>It is intended to be compatible with the TCP API of the &lt;a href=&quot;http://w3.impa.br/%7Ediego/software/luasocket/tcp.html&quot;&gt;LuaSocket&lt;/a&gt; library but is 100% nonblocking out of the box. Also, we introduce some new APIs to provide more functionalities.</source>
          <target state="translated">它旨在与&lt;a href=&quot;http://w3.impa.br/%7Ediego/software/luasocket/tcp.html&quot;&gt;LuaSocket&lt;/a&gt;库的TCP API兼容，但是100％无阻塞可用。另外，我们引入了一些新的API，以提供更多功能。</target>
        </trans-unit>
        <trans-unit id="392c1c7a70ba0e823bfe21f074df2e0a8645d048" translate="yes" xml:space="preserve">
          <source>It is intended to be compatible with the UDP API of the &lt;a href=&quot;http://w3.impa.br/%7Ediego/software/luasocket/udp.html&quot;&gt;LuaSocket&lt;/a&gt; library but is 100% nonblocking out of the box.</source>
          <target state="translated">它旨在与&lt;a href=&quot;http://w3.impa.br/%7Ediego/software/luasocket/udp.html&quot;&gt;LuaSocket&lt;/a&gt;库的UDP API兼容，但是100％无阻塞可用。</target>
        </trans-unit>
        <trans-unit id="f45e79b4c09d0ee14cdf200b012847db6d0932b1" translate="yes" xml:space="preserve">
          <source>It is particularly useful for setting the SSL certificate chain and the corresponding private key on a per-request basis. It is also useful to load such handshake configurations nonblockingly from the remote (for example, with the &lt;a href=&quot;#ngxsockettcp&quot;&gt;cosocket&lt;/a&gt; API). And one can also do per-request OCSP stapling handling in pure Lua here as well.</source>
          <target state="translated">在每个请求的基础上设置SSL证书链和相应的私钥特别有用。从远程无阻塞地（例如，使用&lt;a href=&quot;#ngxsockettcp&quot;&gt;cosocket&lt;/a&gt; API）加载此类握手配置也很有用。在这里，也可以在纯Lua中按请求执行OCSP装订处理。</target>
        </trans-unit>
        <trans-unit id="1dc0b2e52141616964fdb445ff870fd2fd41fc1b" translate="yes" xml:space="preserve">
          <source>It is recommended however, to use the &lt;a href=&quot;#ngxreqread_body&quot;&gt;ngx.req.read_body&lt;/a&gt; and &lt;a href=&quot;#ngxreqdiscard_body&quot;&gt;ngx.req.discard_body&lt;/a&gt; functions for finer control over the request body reading process instead.</source>
          <target state="translated">但是，建议使用&lt;a href=&quot;#ngxreqread_body&quot;&gt;ngx.req.read_body&lt;/a&gt;和&lt;a href=&quot;#ngxreqdiscard_body&quot;&gt;ngx.req.discard_body&lt;/a&gt;函数来更好地控制请求正文读取过程。</target>
        </trans-unit>
        <trans-unit id="271a83c7208d1b70559136d61431826dfba3afd3" translate="yes" xml:space="preserve">
          <source>It is recommended that a coding style that combines this method call with the &lt;code&gt;return&lt;/code&gt; statement, i.e., &lt;code&gt;return ngx.exec(...)&lt;/code&gt; be adopted when this method call is used in contexts other than &lt;a href=&quot;#header_filter_by_lua&quot;&gt;header_filter_by_lua*&lt;/a&gt; to reinforce the fact that the request processing is being terminated.</source>
          <target state="translated">当在&lt;a href=&quot;#header_filter_by_lua&quot;&gt;header_filter_by_lua *&lt;/a&gt;以外的上下文中使用此方法调用时，建议采用将此方法调用与 &lt;code&gt;return&lt;/code&gt; 语句相结合的编码样式，即 &lt;code&gt;return ngx.exec(...)&lt;/code&gt; ,以加强请求处理的事实正在终止。</target>
        </trans-unit>
        <trans-unit id="46536b06dafcf43a3332b8c34efe513e8a9f6966" translate="yes" xml:space="preserve">
          <source>It is recommended that a coding style that combines this method call with the &lt;code&gt;return&lt;/code&gt; statement, i.e., &lt;code&gt;return ngx.redirect(...)&lt;/code&gt; be adopted when this method call is used in contexts other than &lt;a href=&quot;#header_filter_by_lua&quot;&gt;header_filter_by_lua*&lt;/a&gt; to reinforce the fact that the request processing is being terminated.</source>
          <target state="translated">当在&lt;a href=&quot;#header_filter_by_lua&quot;&gt;header_filter_by_lua *&lt;/a&gt;以外的上下文中使用此方法调用时，建议采用将此方法调用与 &lt;code&gt;return&lt;/code&gt; 语句结合的编码样式，即 &lt;code&gt;return ngx.redirect(...)&lt;/code&gt; ,以加强请求处理的事实正在终止。</target>
        </trans-unit>
        <trans-unit id="1cfd652745464233964e6dbe816a6658c1decc26" translate="yes" xml:space="preserve">
          <source>It is recommended, however, to use the &lt;a href=&quot;#ngxtimerevery&quot;&gt;ngx.timer.every&lt;/a&gt; API function instead for creating recurring timers since it is more robust.</source>
          <target state="translated">但是，建议使用&lt;a href=&quot;#ngxtimerevery&quot;&gt;ngx.timer.every&lt;/a&gt; API函数来创建循环计时器，因为它更可靠。</target>
        </trans-unit>
        <trans-unit id="d4b48ac00161f1a8ce8bce14130fe772170862b4" translate="yes" xml:space="preserve">
          <source>It is therefore &lt;em&gt;highly&lt;/em&gt; recommended to always declare such within an appropriate local scope instead.</source>
          <target state="translated">因此，&lt;em&gt;强烈&lt;/em&gt;建议始终在适当的本地范围内声明此类内容。</target>
        </trans-unit>
        <trans-unit id="a146a425155dd2f1668bfb8dfa2d9ace4014d015" translate="yes" xml:space="preserve">
          <source>It is usually recommended to share read-only data this way. You can also share changeable data among all the concurrent requests of each nginx worker process as long as there is &lt;em&gt;no&lt;/em&gt; nonblocking I/O operations (including &lt;a href=&quot;#ngxsleep&quot;&gt;ngx.sleep&lt;/a&gt;) in the middle of your calculations. As long as you do not give the control back to the nginx event loop and ngx_lua's light thread scheduler (even implicitly), there can never be any race conditions in between. For this reason, always be very careful when you want to share changeable data on the worker level. Buggy optimizations can easily lead to hard-to-debug race conditions under load.</source>
          <target state="translated">通常建议以这种方式共享只读数据。只要在计算中间&lt;em&gt;没有&lt;/em&gt;非阻塞I / O操作（包括&lt;a href=&quot;#ngxsleep&quot;&gt;ngx.sleep&lt;/a&gt;），您还可以在每个nginx worker进程的所有并发请求之间共享可变数据。只要您不将控件还给nginx事件循环和ngx_lua的轻线程调度程序（即使是隐式的），它们之间就永远不会有任何竞争条件。因此，要在工作人员级别共享可变数据时，请务必格外小心。越野车优化很容易导致在负载下难以调试的竞赛条件。</target>
        </trans-unit>
        <trans-unit id="16406cede08a97c4ef51e625cc1932ecc9368323" translate="yes" xml:space="preserve">
          <source>It is worth noting that there is no way to capture the debugging logs without building OpenResty or NGINX with the &lt;code&gt;./configure&lt;/code&gt; option &lt;code&gt;--with-debug&lt;/code&gt;. And enabling debugging logs is strongly discouraged in production builds due to high overhead.</source>
          <target state="translated">值得注意的是，如果不使用 &lt;code&gt;./configure&lt;/code&gt; 选项 &lt;code&gt;--with-debug&lt;/code&gt; 构建OpenResty或NGINX，就无法捕获调试日志。由于高开销，强烈建议不要在生产版本中启用调试日志。</target>
        </trans-unit>
        <trans-unit id="caba899dc7d941617513a9ffa8c28f13127e69b3" translate="yes" xml:space="preserve">
          <source>It never overrides the (least recently used) unexpired items in the store when running out of storage in the shared memory zone. In this case, it will immediately return &lt;code&gt;nil&lt;/code&gt; and the string &quot;no memory&quot;.</source>
          <target state="translated">当共享内存区域中的存储空间用完时，它永远不会覆盖存储中（最近使用最少的）未过期项目。在这种情况下，它将立即返回 &lt;code&gt;nil&lt;/code&gt; 和字符串&amp;ldquo; no memory&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="abd2c9284683a341513f7145950e2da46ebf49db" translate="yes" xml:space="preserve">
          <source>Just an alias to &lt;a href=&quot;#ngxsockettcp&quot;&gt;ngx.socket.tcp&lt;/a&gt;. If the stream-typed cosocket may also connect to a unix domain socket, then this API name is preferred.</source>
          <target state="translated">只是&lt;a href=&quot;#ngxsockettcp&quot;&gt;ngx.socket.tcp&lt;/a&gt;的别名。如果流类型的套接字也可能连接到Unix域套接字，则首选此API名称。</target>
        </trans-unit>
        <trans-unit id="c885172911e8a34f2d9bb7b542fd8f94a013a962" translate="yes" xml:space="preserve">
          <source>Just as &lt;a href=&quot;#ngxprint&quot;&gt;ngx.print&lt;/a&gt; but also emit a trailing newline.</source>
          <target state="translated">就像&lt;a href=&quot;#ngxprint&quot;&gt;ngx.print一样&lt;/a&gt;，还会发出尾随的换行符。</target>
        </trans-unit>
        <trans-unit id="dad4e3c58c739716522706aa61d6008291203ebd" translate="yes" xml:space="preserve">
          <source>Just as any other rewrite phase handlers, &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt; also runs in subrequests.</source>
          <target state="translated">与其他任何重写阶段处理程序一样，&lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt;也在子请求中运行。</target>
        </trans-unit>
        <trans-unit id="5dec50ed5fba57c0c048b75bed03e02c0ec53065" translate="yes" xml:space="preserve">
          <source>Just like &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt;, but supports multiple subrequests running in parallel.</source>
          <target state="translated">就像&lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt;一样，但支持并行运行的多个子请求。</target>
        </trans-unit>
        <trans-unit id="30330751c517ec0c78031f290391df8628d2b9b0" translate="yes" xml:space="preserve">
          <source>Just like &lt;a href=&quot;#ngxresub&quot;&gt;ngx.re.sub&lt;/a&gt;, but does global substitution.</source>
          <target state="translated">就像&lt;a href=&quot;#ngxresub&quot;&gt;ngx.re.sub&lt;/a&gt;一样，但是进行全局替换。</target>
        </trans-unit>
        <trans-unit id="fdcab698e53e300d46deb56ea934f502da8f9b33" translate="yes" xml:space="preserve">
          <source>Just like the &lt;a href=&quot;#ngxshareddictset&quot;&gt;set&lt;/a&gt; method, but only stores the key-value pair into the dictionary &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt; if the key &lt;em&gt;does&lt;/em&gt; exist.</source>
          <target state="translated">就像&lt;a href=&quot;#ngxshareddictset&quot;&gt;set&lt;/a&gt;方法一样，但是仅在键&lt;em&gt;确实&lt;/em&gt;存在的情况下才将键值对存储到字典&lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT &lt;/a&gt;&lt;em&gt;中&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="208d172e22547ea6e5aeed2c6c4048d80cf6fb7f" translate="yes" xml:space="preserve">
          <source>Just like the &lt;a href=&quot;#ngxshareddictset&quot;&gt;set&lt;/a&gt; method, but only stores the key-value pair into the dictionary &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt; if the key does &lt;em&gt;not&lt;/em&gt; exist.</source>
          <target state="translated">就像&lt;a href=&quot;#ngxshareddictset&quot;&gt;一套&lt;/a&gt;方法，但只保存键-值对到字典&lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;如果该键也&lt;em&gt;不会&lt;/em&gt;存在。</target>
        </trans-unit>
        <trans-unit id="46a9daf8b26cf767246d05313a9e4defbe39056f" translate="yes" xml:space="preserve">
          <source>Just to name a few:</source>
          <target state="translated">仅举几例。</target>
        </trans-unit>
        <trans-unit id="7477a64f443c7e43a1cbca4c5ae06e44734b4be7" translate="yes" xml:space="preserve">
          <source>Keys and values are unescaped according to URI escaping rules. In the settings above, &lt;code&gt;GET /test?a%20b=1%61+2&lt;/code&gt; will yield:</source>
          <target state="translated">根据URI转义规则，键和值不转义。在上面的设置中， &lt;code&gt;GET /test?a%20b=1%61+2&lt;/code&gt; 将产生：</target>
        </trans-unit>
        <trans-unit id="787c0b6e20b6e8a04cba597e45d7f65b3384a7e4" translate="yes" xml:space="preserve">
          <source>Keys and values will be unescaped according to URI escaping rules.</source>
          <target state="translated">根据URI转义规则,键和值将不被转义。</target>
        </trans-unit>
        <trans-unit id="4f191bcbd3d4b3d0a53fe1f096b1b92a3bb6d7ce" translate="yes" xml:space="preserve">
          <source>Kills a running &quot;light thread&quot; created by &lt;a href=&quot;#ngxthreadspawn&quot;&gt;ngx.thread.spawn&lt;/a&gt;. Returns a true value when successful or &lt;code&gt;nil&lt;/code&gt; and a string describing the error otherwise.</source>
          <target state="translated">杀死&lt;a href=&quot;#ngxthreadspawn&quot;&gt;ngx.thread.spawn&lt;/a&gt;创建的正在运行的&amp;ldquo;轻线程&amp;rdquo; 。成功或为 &lt;code&gt;nil&lt;/code&gt; 时，返回一个真值，否则返回一个描述错误的字符串。</target>
        </trans-unit>
        <trans-unit id="f5025143a89e9b224781aa62468c0e2c91c66496" translate="yes" xml:space="preserve">
          <source>Known Issues</source>
          <target state="translated">已知问题</target>
        </trans-unit>
        <trans-unit id="9c0c0eecbdf8b8609b462711b4681e4c821d7607" translate="yes" xml:space="preserve">
          <source>Let us test it:</source>
          <target state="translated">让我们来测试一下。</target>
        </trans-unit>
        <trans-unit id="4da26479770dfe12cd77c3a29e0d80eb1fb85bb5" translate="yes" xml:space="preserve">
          <source>Library name &lt;code&gt;liblua.so&lt;/code&gt; has been changed in liblua5.1 package, it only comes with &lt;code&gt;liblua5.1.so&lt;/code&gt;, which needs to be symlinked to &lt;code&gt;/usr/lib&lt;/code&gt; so it could be found during the configuration process.</source>
          <target state="translated">库名 &lt;code&gt;liblua.so&lt;/code&gt; 已在liblua5.1软件包中进行了更改，仅随 &lt;code&gt;liblua5.1.so&lt;/code&gt; 一起提供，它需要符号链接到 &lt;code&gt;/usr/lib&lt;/code&gt; ,以便可以在配置过程中找到它。</target>
        </trans-unit>
        <trans-unit id="cc5b2a062f05dd148b4ef24c76639416ebcc59f3" translate="yes" xml:space="preserve">
          <source>Licensed under the BSD License.</source>
          <target state="translated">采用BSD授权许可。</target>
        </trans-unit>
        <trans-unit id="66b752ee483f366c956fca803594910b1246a48f" translate="yes" xml:space="preserve">
          <source>Like the &lt;a href=&quot;#ngxshareddictadd&quot;&gt;add&lt;/a&gt; method, it also overrides the (least recently used) unexpired items in the store when running out of storage in the shared memory zone.</source>
          <target state="translated">与&lt;a href=&quot;#ngxshareddictadd&quot;&gt;add&lt;/a&gt;方法一样，当共享内存区域中的存储空间用完时，它也会覆盖存储中（最近最少使用的）未过期项目。</target>
        </trans-unit>
        <trans-unit id="19a1d43944747a80761f7b71a7248d3bad465a35" translate="yes" xml:space="preserve">
          <source>Likewise, new &quot;eof&quot; flag can also be specified by setting a boolean value to &lt;a href=&quot;#ngxarg&quot;&gt;ngx.arg&lt;/a&gt;[2]. For example,</source>
          <target state="translated">同样，也可以通过将&lt;a href=&quot;#ngxarg&quot;&gt;ngx.arg&lt;/a&gt; [2] 设置为布尔值来指定新的&amp;ldquo; eof&amp;rdquo;标志。例如，</target>
        </trans-unit>
        <trans-unit id="62af63e4d50059ec446993ac54d11cb7137d41e2" translate="yes" xml:space="preserve">
          <source>Literal dollar sign characters (&lt;code&gt;$&lt;/code&gt;) in the &lt;code&gt;replace&lt;/code&gt; string argument can be escaped by another dollar sign, for instance,</source>
          <target state="translated">&lt;code&gt;replace&lt;/code&gt; 字符串参数中的文字美元符号字符（ &lt;code&gt;$&lt;/code&gt; ）可以由另一个美元符号转义，例如，</target>
        </trans-unit>
        <trans-unit id="50116a0653683b8c0e1ea1052615ecf727848962" translate="yes" xml:space="preserve">
          <source>Loaded Lua modules persist in the nginx worker process level resulting in a small memory footprint in Lua even when under heavy loads.</source>
          <target state="translated">加载的Lua模块持续存在于nginx Worker进程中,即使在重载的情况下,Lua的内存占用也很小。</target>
        </trans-unit>
        <trans-unit id="32da440e124def30c99af4c314587020578f50c2" translate="yes" xml:space="preserve">
          <source>Loading bytecode files via the Lua primitives like &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;dofile&lt;/code&gt; should always work as expected.</source>
          <target state="translated">通过Lua原语（如 &lt;code&gt;require&lt;/code&gt; 和 &lt;code&gt;dofile&lt;/code&gt; )加载字节码文件应始终按预期工作。</target>
        </trans-unit>
        <trans-unit id="c3b51e0cda2aacfcfca4096cfa8d50ae4d02f9e9" translate="yes" xml:space="preserve">
          <source>Location jump will not be triggered otherwise, and only the current request's URI will be modified, which is also the default behavior. This function will return but with no returned values when the &lt;code&gt;jump&lt;/code&gt; argument is &lt;code&gt;false&lt;/code&gt; or absent altogether.</source>
          <target state="translated">否则，不会触发位置跳转，并且只会修改当前请求的URI，这也是默认行为。当 &lt;code&gt;jump&lt;/code&gt; 参数为 &lt;code&gt;false&lt;/code&gt; 或完全不存在时，此函数将返回但没有返回值。</target>
        </trans-unit>
        <trans-unit id="fda8d60fb2838d1c5982f5cf20041deaa96b0093" translate="yes" xml:space="preserve">
          <source>Locations Configured by Subrequest Directives of Other Modules</source>
          <target state="translated">由其他模块的子请求指令配置的位置。</target>
        </trans-unit>
        <trans-unit id="703509601a9cf02923c4011f7de08efd66a2ee1f" translate="yes" xml:space="preserve">
          <source>Log arguments concatenated to error.log with the given logging level.</source>
          <target state="translated">日志参数与给定的日志级别连接到error.log。</target>
        </trans-unit>
        <trans-unit id="e0b2ee17ddb47b55f2f15406fd718bcfbf2c67bf" translate="yes" xml:space="preserve">
          <source>Logging APIs: &lt;a href=&quot;#ngxlog&quot;&gt;ngx.log&lt;/a&gt; and &lt;a href=&quot;#print&quot;&gt;print&lt;/a&gt;,</source>
          <target state="translated">记录API：&lt;a href=&quot;#ngxlog&quot;&gt;ngx.log&lt;/a&gt;和&lt;a href=&quot;#print&quot;&gt;print&lt;/a&gt;，</target>
        </trans-unit>
        <trans-unit id="62970aa98bcedc00e3c3d93365f65032997c5d59" translate="yes" xml:space="preserve">
          <source>Lua &lt;code&gt;nil&lt;/code&gt; arguments are accepted and result in literal &lt;code&gt;&quot;nil&quot;&lt;/code&gt; string while Lua booleans result in literal &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt; string outputs. And the &lt;code&gt;ngx.null&lt;/code&gt; constant will yield the &lt;code&gt;&quot;null&quot;&lt;/code&gt; string output.</source>
          <target state="translated">Lua &lt;code&gt;nil&lt;/code&gt; 参数被接受并产生文字 &lt;code&gt;&quot;nil&quot;&lt;/code&gt; 字符串，而Lua booleans产生文字 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 字符串输出。而 &lt;code&gt;ngx.null&lt;/code&gt; 不断将产生 &lt;code&gt;&quot;null&quot;&lt;/code&gt; 的字符串输出。</target>
        </trans-unit>
        <trans-unit id="67078b84e84353b0e7692388c85577550cb18243" translate="yes" xml:space="preserve">
          <source>Lua &lt;code&gt;nil&lt;/code&gt; arguments are accepted and result in literal &lt;code&gt;&quot;nil&quot;&lt;/code&gt; strings while Lua booleans result in literal &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt; strings. And the &lt;code&gt;ngx.null&lt;/code&gt; constant will yield the &lt;code&gt;&quot;null&quot;&lt;/code&gt; string output.</source>
          <target state="translated">Lua &lt;code&gt;nil&lt;/code&gt; 参数被接受并产生文字 &lt;code&gt;&quot;nil&quot;&lt;/code&gt; 字符串，而Lua booleans产生文字 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 字符串。而 &lt;code&gt;ngx.null&lt;/code&gt; 不断将产生 &lt;code&gt;&quot;null&quot;&lt;/code&gt; 的字符串输出。</target>
        </trans-unit>
        <trans-unit id="8a1a9f38e0a87f169c792988f824847e1f230d2e" translate="yes" xml:space="preserve">
          <source>Lua &lt;code&gt;nil&lt;/code&gt; values will output &lt;code&gt;&quot;nil&quot;&lt;/code&gt; strings and Lua boolean values will output &lt;code&gt;&quot;true&quot;&lt;/code&gt; and &lt;code&gt;&quot;false&quot;&lt;/code&gt; literal strings respectively.</source>
          <target state="translated">Lua &lt;code&gt;nil&lt;/code&gt; 值将输出 &lt;code&gt;&quot;nil&quot;&lt;/code&gt; 字符串，而Lua布尔值将分别输出 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 文字字符串。</target>
        </trans-unit>
        <trans-unit id="5be9d100b21ac9e5ad3be58666a59cb29059ad31" translate="yes" xml:space="preserve">
          <source>Lua APIs that may yield, like &lt;a href=&quot;#ngxsleep&quot;&gt;ngx.sleep&lt;/a&gt; and &lt;a href=&quot;#ngxsockettcp&quot;&gt;cosockets&lt;/a&gt;, are &lt;em&gt;disabled&lt;/em&gt; in this context. You can still, however, use the &lt;a href=&quot;#ngxtimerat&quot;&gt;ngx.timer.at&lt;/a&gt; API to create 0-delay timers to save the SSL session data asynchronously to external services (like &lt;code&gt;redis&lt;/code&gt; or &lt;code&gt;memcached&lt;/code&gt;).</source>
          <target state="translated">在这种情况下，可能会产生的Lua API（例如&lt;a href=&quot;#ngxsleep&quot;&gt;ngx.sleep&lt;/a&gt;和&lt;a href=&quot;#ngxsockettcp&quot;&gt;cosockets&lt;/a&gt;）被&lt;em&gt;禁用&lt;/em&gt;。但是，您仍然可以使用&lt;a href=&quot;#ngxtimerat&quot;&gt;ngx.timer.at&lt;/a&gt; API创建0延迟计时器，以将SSL会话数据异步保存到外部服务（如 &lt;code&gt;redis&lt;/code&gt; 或 &lt;code&gt;memcached&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b270537918fe3aefea5a6943042ccf7e5d6576ca" translate="yes" xml:space="preserve">
          <source>Lua APIs that may yield, like &lt;a href=&quot;#ngxsleep&quot;&gt;ngx.sleep&lt;/a&gt; and &lt;a href=&quot;#ngxsockettcp&quot;&gt;cosockets&lt;/a&gt;, are enabled in this context.</source>
          <target state="translated">在这种情况下启用了可能产生的Lua API，例如&lt;a href=&quot;#ngxsleep&quot;&gt;ngx.sleep&lt;/a&gt;和&lt;a href=&quot;#ngxsockettcp&quot;&gt;cosockets&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="16ec669f47cb0d73aa2c12fd87ac3f87572c77ac" translate="yes" xml:space="preserve">
          <source>Lua Coroutine Yielding/Resuming</source>
          <target state="translated">Lua Coroutine 屈服/恢复功能</target>
        </trans-unit>
        <trans-unit id="81be7ce438613a3e191edba2c0d0599ee9eb054c" translate="yes" xml:space="preserve">
          <source>Lua Variable Scope</source>
          <target state="translated">Lua变量范围</target>
        </trans-unit>
        <trans-unit id="e239727dc78b43ea15c5eea7446c445e7d0cdde7" translate="yes" xml:space="preserve">
          <source>Lua global variables require Lua table look-ups in the global environment which is computationally expensive, and</source>
          <target state="translated">Lua全局变量需要在全局环境中进行Lua表查询,计算成本很高,而且</target>
        </trans-unit>
        <trans-unit id="286a435a10004ebd882bdfc7a438ddce793d606e" translate="yes" xml:space="preserve">
          <source>Lua tables can be used for both requests and responses when the number of subrequests to be issued is not known in advance:</source>
          <target state="translated">当事先不知道要发出的子请求数量时,Lua表可以同时用于请求和响应。</target>
        </trans-unit>
        <trans-unit id="aecdc7f39461eecbcde3605cc25e0fe71f75fa30" translate="yes" xml:space="preserve">
          <source>Lua/LuaJIT bytecode support</source>
          <target state="translated">支持Lua/LuaJIT字节码。</target>
        </trans-unit>
        <trans-unit id="0a73d1d05563574cdd9ff18b0b15597fe3f10c4a" translate="yes" xml:space="preserve">
          <source>Mashup'ing and processing outputs of various nginx upstream outputs (proxy, drizzle, postgres, redis, memcached, and etc) in Lua,</source>
          <target state="translated">在Lua中Mashup'ing和处理各种nginx上游输出(proxy、drizzle、postgres、redis、memcached等)。</target>
        </trans-unit>
        <trans-unit id="2162b9943b7dc9b3ffa9618b2fb845143de0408f" translate="yes" xml:space="preserve">
          <source>Matches the &lt;code&gt;subject&lt;/code&gt; string using the Perl compatible regular expression &lt;code&gt;regex&lt;/code&gt; with the optional &lt;code&gt;options&lt;/code&gt;.</source>
          <target state="translated">使用与Perl兼容的正则表达式 &lt;code&gt;regex&lt;/code&gt; 与可选 &lt;code&gt;options&lt;/code&gt; 匹配 &lt;code&gt;subject&lt;/code&gt; 字符串。</target>
        </trans-unit>
        <trans-unit id="cd2c32444cd5e0e45ed666bc5343b57e8c606391" translate="yes" xml:space="preserve">
          <source>Missing data on short circuited requests</source>
          <target state="translated">短路请求的数据缺失</target>
        </trans-unit>
        <trans-unit id="314067c9b9abc3268632b142ade808b25762775d" translate="yes" xml:space="preserve">
          <source>Mixing SSI with ngx_lua in the same Nginx request is not supported at all. Just use ngx_lua exclusively. Everything you can do with SSI can be done atop ngx_lua anyway and it can be more efficient when using ngx_lua.</source>
          <target state="translated">在同一个Nginx请求中混合使用SSI和ngx_lua是完全不支持的。只需使用ngx_lua。所有你能用SSI做的事情都可以在ngx_lua上完成,而且使用ngx_lua会更有效率。</target>
        </trans-unit>
        <trans-unit id="566a0866953c9cddc989560c5d345ce6531f7d08" translate="yes" xml:space="preserve">
          <source>Mixing with SSI Not Supported</source>
          <target state="translated">不支持与SSI混合使用</target>
        </trans-unit>
        <trans-unit id="c238a082f51e69752f561d49c312243da839a0ec" translate="yes" xml:space="preserve">
          <source>More Nginx APIs for Lua may be supported in this context upon future user requests.</source>
          <target state="translated">在未来的用户请求中,可能会支持更多的Nginx APIs for Lua。</target>
        </trans-unit>
        <trans-unit id="2ddc3c92f0eba23a04309fc859c257c19673cfb8" translate="yes" xml:space="preserve">
          <source>More often we just put it into a Lua loop:</source>
          <target state="translated">更多的时候,我们只是把它放到一个Lua循环中。</target>
        </trans-unit>
        <trans-unit id="e0e944fbcb6eb23af4ead2148e02e0e2c1695714" translate="yes" xml:space="preserve">
          <source>Multi-value arguments are also supported:</source>
          <target state="translated">也支持多值参数。</target>
        </trans-unit>
        <trans-unit id="761e950673c01398f954cd38f95ae8c0a505a249" translate="yes" xml:space="preserve">
          <source>Multi-value headers can be set this way:</source>
          <target state="translated">多值头可以这样设置。</target>
        </trans-unit>
        <trans-unit id="7e6ffce17d2ad4b08e9301597531afaa98399d5c" translate="yes" xml:space="preserve">
          <source>Multi-value query args are also supported. Just use a Lua table for the argument's value, for example:</source>
          <target state="translated">也支持多值查询参数。例如,只需使用一个Lua表作为参数的值。</target>
        </trans-unit>
        <trans-unit id="8c49929b484ac09004059a5befdbfef8a976e9b4" translate="yes" xml:space="preserve">
          <source>Multiple occurrences of an argument key will result in a table value holding all of the values for that key in order.</source>
          <target state="translated">一个参数键的多次出现将导致一个表值依次持有该键的所有值。</target>
        </trans-unit>
        <trans-unit id="e0c57ca820ec571b3f6f7283896edc3a2e96c75d" translate="yes" xml:space="preserve">
          <source>Multiple occurrences of an argument key will result in a table value holding all the values for that key in order.</source>
          <target state="translated">一个参数键的多次出现将导致一个表值按顺序持有该键的所有值。</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="81492ccffc0c23f6f157946685e7833258341724" translate="yes" xml:space="preserve">
          <source>Named captures are also supported since the &lt;code&gt;v0.7.14&lt;/code&gt; release and are returned in the same Lua table as key-value pairs as the numbered captures.</source>
          <target state="translated">从 &lt;code&gt;v0.7.14&lt;/code&gt; 版本开始，还支持命名捕获，并且命名捕获与作为编号捕获的键值对在同一Lua表中返回。</target>
        </trans-unit>
        <trans-unit id="62de1a443da7c8e663e63ccebadf81592d861745" translate="yes" xml:space="preserve">
          <source>Named locations are also supported but the second &lt;code&gt;args&lt;/code&gt; argument will be ignored if present and the querystring for the new target is inherited from the referring location (if any).</source>
          <target state="translated">还支持命名位置，但是第二个 &lt;code&gt;args&lt;/code&gt; 参数（如果存在）将被忽略，并且新目标的查询字符串将从引用位置（如果有）继承。</target>
        </trans-unit>
        <trans-unit id="94c3812059e329f482def2ab66bae02b3d4467e1" translate="yes" xml:space="preserve">
          <source>Named locations like &lt;code&gt;@foo&lt;/code&gt; are not allowed due to a limitation in the nginx core. Use normal locations combined with the &lt;code&gt;internal&lt;/code&gt; directive to prepare internal-only locations.</source>
          <target state="translated">由于nginx核心的限制，不允许使用 &lt;code&gt;@foo&lt;/code&gt; 之类的命名位置。将常规位置与 &lt;code&gt;internal&lt;/code&gt; 指令结合使用以准备仅内部位置。</target>
        </trans-unit>
        <trans-unit id="670d65a340c943c43ab1ba03ab60f2b91b18fa01" translate="yes" xml:space="preserve">
          <source>Nested arrays of strings are permitted and the elements in the arrays will be sent one by one:</source>
          <target state="translated">允许字符串的嵌套数组,数组中的元素将被逐一发送。</target>
        </trans-unit>
        <trans-unit id="645ac1cdcc687fb8ac947381b144262dcb18101b" translate="yes" xml:space="preserve">
          <source>Network I/O operations in user code should only be done through the Nginx Lua API calls as the Nginx event loop may be blocked and performance drop off dramatically otherwise. Disk operations with relatively small amount of data can be done using the standard Lua &lt;code&gt;io&lt;/code&gt; library but huge file reading and writing should be avoided wherever possible as they may block the Nginx process significantly. Delegating all network and disk I/O operations to Nginx's subrequests (via the &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt; method and similar) is strongly recommended for maximum performance.</source>
          <target state="translated">用户代码中的网络I / O操作只能通过Nginx Lua API调用来完成，因为Nginx事件循环可能会被阻塞，否则性能会急剧下降。可以使用标准的Lua &lt;code&gt;io&lt;/code&gt; 库完成数据量相对较小的磁盘操作，但应尽可能避免进行大量文件读写，因为它们可能会严重阻塞Nginx进程。强烈建议将所有网络和磁盘I / O操作委托给Nginx的子请求（通过&lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt;方法和类似方法）以实现最佳性能。</target>
        </trans-unit>
        <trans-unit id="ff87d2b81b31ddc05f55235bd37ea427809edf09" translate="yes" xml:space="preserve">
          <source>Nginx API for Lua</source>
          <target state="translated">Nginx API for Lua</target>
        </trans-unit>
        <trans-unit id="18bf38898491eb7a8dc300b724c0146a117e0ecc" translate="yes" xml:space="preserve">
          <source>Nginx Compatibility</source>
          <target state="translated">Nginx兼容性</target>
        </trans-unit>
        <trans-unit id="58853061cae7a64d47f884b33352fca46eaa4ea0" translate="yes" xml:space="preserve">
          <source>Nginx Systemtap Toolkit</source>
          <target state="translated">Nginx Systemtap工具箱</target>
        </trans-unit>
        <trans-unit id="5bfddbee998421d882a511ef6ed379a3be09af5f" translate="yes" xml:space="preserve">
          <source>Nginx cores older than 1.6.0 (exclusive) are &lt;em&gt;not&lt;/em&gt; supported.</source>
          <target state="translated">&lt;em&gt;不&lt;/em&gt;支持早于1.6.0（专有）的Nginx内核。</target>
        </trans-unit>
        <trans-unit id="2c044d64faf3fdaff856b1b8d1e2a9d7b446fa15" translate="yes" xml:space="preserve">
          <source>Nginx log level constants</source>
          <target state="translated">Nginx日志级别常数</target>
        </trans-unit>
        <trans-unit id="1d7996ffe9ebf877225187ed06879c2611106f0d" translate="yes" xml:space="preserve">
          <source>Nginx may terminate a request early with (at least):</source>
          <target state="translated">Nginx可以用(至少)提前终止一个请求。</target>
        </trans-unit>
        <trans-unit id="12ff7d8d02509bfbf56621f86570af5d0807db49" translate="yes" xml:space="preserve">
          <source>Nginx modules:</source>
          <target state="translated">Nginx模块。</target>
        </trans-unit>
        <trans-unit id="7793c73465a179275ad7b572a7e5ef161e8fb423" translate="yes" xml:space="preserve">
          <source>Nginx output filters may be called multiple times for a single request because response body may be delivered in chunks. Thus, the Lua code specified by in this directive may also run multiple times in the lifetime of a single HTTP request.</source>
          <target state="translated">Nginx的输出过滤器可以在一个请求中被多次调用,因为响应体可以分块传送。因此,该指令中指定的Lua代码也可以在一个HTTP请求的生命周期内运行多次。</target>
        </trans-unit>
        <trans-unit id="ea0661826d885b9e38cd745eed85fac0d5393384" translate="yes" xml:space="preserve">
          <source>Nginx regex group capturing variables &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, &lt;code&gt;$3&lt;/code&gt;, and etc, can be read by this interface as well, by writing &lt;code&gt;ngx.var[1]&lt;/code&gt;, &lt;code&gt;ngx.var[2]&lt;/code&gt;, &lt;code&gt;ngx.var[3]&lt;/code&gt;, and etc.</source>
          <target state="translated">通过写入 &lt;code&gt;ngx.var[1]&lt;/code&gt; ， &lt;code&gt;ngx.var[2]&lt;/code&gt; ， &lt;code&gt;ngx.var[3]&lt;/code&gt; 等，也可以通过此接口读取捕获变量 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; ， &lt;code&gt;$3&lt;/code&gt; 等的Nginx正则表达式组。</target>
        </trans-unit>
        <trans-unit id="78155f49d1f7984ef7b57dfbb47e79250361d3ee" translate="yes" xml:space="preserve">
          <source>Nginx variable interpolation is supported in the &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; argument string of this directive. But special care must be taken for injection attacks.</source>
          <target state="translated">此指令的 &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; 参数字符串中支持Nginx变量插值。但是对于注射攻击必须格外小心。</target>
        </trans-unit>
        <trans-unit id="1caafcf196b99784ba3ca84ab5ee64b17de29a1a" translate="yes" xml:space="preserve">
          <source>Nginx variables are supported in the file path for dynamic dispatch just as in &lt;a href=&quot;#content_by_lua_file&quot;&gt;content_by_lua_file&lt;/a&gt;.</source>
          <target state="translated">与&lt;a href=&quot;#content_by_lua_file&quot;&gt;content_by_lua_file&lt;/a&gt;一样，在文件路径中支持Nginx变量进行动态分配。</target>
        </trans-unit>
        <trans-unit id="ede519ce7605a8c3b10b9d7f082bae2ab2007258" translate="yes" xml:space="preserve">
          <source>Nginx variables are supported in the file path for dynamic dispatch, for example:</source>
          <target state="translated">例如,在文件路径中支持Nginx变量的动态调度。</target>
        </trans-unit>
        <trans-unit id="54da8a18babb64a1603661d18049641b3125b5a3" translate="yes" xml:space="preserve">
          <source>Nginx variables can be used in the &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; string to provide flexibility. This however carries some risks and is not ordinarily recommended.</source>
          <target state="translated">Nginx变量可以在 &lt;code&gt;&amp;lt;path-to-lua-script-file&amp;gt;&lt;/code&gt; 字符串中使用，以提供灵活性。但是，这会带来一些风险，因此通常不建议这样做。</target>
        </trans-unit>
        <trans-unit id="e021461a65c61b50a18410dc40afc21d29a0fe89" translate="yes" xml:space="preserve">
          <source>Nginx version &amp;gt;= 1.4.2</source>
          <target state="translated">Nginx版本&amp;gt; = 1.4.2</target>
        </trans-unit>
        <trans-unit id="4579aaf52efd267504193696c6698c7f2b3ed5d2" translate="yes" xml:space="preserve">
          <source>Nginx's subrequests provide a powerful way to make non-blocking internal requests to other locations configured with disk file directory or &lt;em&gt;any&lt;/em&gt; other nginx C modules like &lt;code&gt;ngx_proxy&lt;/code&gt;, &lt;code&gt;ngx_fastcgi&lt;/code&gt;, &lt;code&gt;ngx_memc&lt;/code&gt;, &lt;code&gt;ngx_postgres&lt;/code&gt;, &lt;code&gt;ngx_drizzle&lt;/code&gt;, and even ngx_lua itself and etc etc etc.</source>
          <target state="translated">Nginx的子请求提供了一种强大的方法，可以向配置了磁盘文件目录或其他&lt;em&gt;任何&lt;/em&gt; &lt;code&gt;ngx_fastcgi&lt;/code&gt; C模块（例如 &lt;code&gt;ngx_proxy&lt;/code&gt; ，ngx_fastcgi， &lt;code&gt;ngx_memc&lt;/code&gt; ， &lt;code&gt;ngx_postgres&lt;/code&gt; ， &lt;code&gt;ngx_drizzle&lt;/code&gt; ，甚至ngx_lua本身等）的其他位置发出无阻塞内部请求。</target>
        </trans-unit>
        <trans-unit id="dbd4da4a070097cf2fd2d4f074d3afd98a10bde0" translate="yes" xml:space="preserve">
          <source>No special escaping is required in the Lua code block.</source>
          <target state="translated">Lua代码块中不需要特殊的转义。</target>
        </trans-unit>
        <trans-unit id="eb083169fb38c81a7e2fb297296142c5ff9f1dc8" translate="yes" xml:space="preserve">
          <source>Non-array table arguments will cause a Lua exception to be thrown.</source>
          <target state="translated">非数组表参数将导致一个Lua异常被抛出。</target>
        </trans-unit>
        <trans-unit id="e58802370b668ce81057f1ec639917482fcd7eff" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;ngx.flush&lt;/code&gt; is not functional when in the HTTP 1.0 output buffering mode. See &lt;a href=&quot;#http-10-support&quot;&gt;HTTP 1.0 support&lt;/a&gt;.</source>
          <target state="translated">请注意，在HTTP 1.0输出缓冲模式下， &lt;code&gt;ngx.flush&lt;/code&gt; 不起作用。请参阅&lt;a href=&quot;#http-10-support&quot;&gt;HTTP 1.0支持&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="534783e94de387675860b571358edbdbb109c57a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;ngx.header&lt;/code&gt; is not a normal Lua table and as such, it is not possible to iterate through it using the Lua &lt;code&gt;ipairs&lt;/code&gt; function.</source>
          <target state="translated">请注意， &lt;code&gt;ngx.header&lt;/code&gt; 不是普通的Lua表，因此，无法使用Lua &lt;code&gt;ipairs&lt;/code&gt; 函数对其进行迭代。</target>
        </trans-unit>
        <trans-unit id="2e4856374a13cb6810b0551ea7f077e8f7fd6b7c" translate="yes" xml:space="preserve">
          <source>Note that a longer from of the long bracket, &lt;code&gt;[=[...]=]&lt;/code&gt;, may be required if the regex pattern contains &lt;code&gt;[...]&lt;/code&gt; sequences. The &lt;code&gt;[=[...]=]&lt;/code&gt; form may be used as the default form if desired.</source>
          <target state="translated">需要注意的是从长支架的更长， &lt;code&gt;[=[...]=]&lt;/code&gt; ，可以被如果正则表达式模式包含所需 &lt;code&gt;[...]&lt;/code&gt; 的序列。的 &lt;code&gt;[=[...]=]&lt;/code&gt; 形式如果需要，可以用作默认形式。</target>
        </trans-unit>
        <trans-unit id="f1b3fc0ccb535b1e8cf3fa364dae16dbf32623f6" translate="yes" xml:space="preserve">
          <source>Note that a maximum of 100 request arguments are parsed by default (including those with the same name) and that additional request arguments are silently discarded to guard against potential denial of service attacks. Since &lt;code&gt;v0.10.13&lt;/code&gt;, when the limit is exceeded, it will return a second value which is the string &lt;code&gt;&quot;truncated&quot;&lt;/code&gt;.</source>
          <target state="translated">请注意，默认情况下最多解析100个请求参数（包括具有相同名称的请求参数），并且将静默丢弃其他请求参数以防止潜在的拒绝服务攻击。从 &lt;code&gt;v0.10.13&lt;/code&gt; 开始，超过限制时，它将返回第二个值，即字符串 &lt;code&gt;&quot;truncated&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1008f2001aa2b7e1c7c9ef9a907321575998aec8" translate="yes" xml:space="preserve">
          <source>Note that a maximum of 100 request headers are parsed by default (including those with the same name) and that additional request headers are silently discarded to guard against potential denial of service attacks. Since &lt;code&gt;v0.10.13&lt;/code&gt;, when the limit is exceeded, it will return a second value which is the string &lt;code&gt;&quot;truncated&quot;&lt;/code&gt;.</source>
          <target state="translated">请注意，默认情况下最多解析100个请求标头（包括具有相同名称的请求标头），并且静默丢弃其他请求标头，以防止潜在的拒绝服务攻击。从 &lt;code&gt;v0.10.13&lt;/code&gt; 开始，超过限制时，它将返回第二个值，即字符串 &lt;code&gt;&quot;truncated&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b35dc90413e383baa5920e4c6256188f294278e9" translate="yes" xml:space="preserve">
          <source>Note that a maximum of 100 response headers are parsed by default (including those with the same name) and that additional response headers are silently discarded to guard against potential denial of service attacks. Since &lt;code&gt;v0.10.13&lt;/code&gt;, when the limit is exceeded, it will return a second value which is the string &lt;code&gt;&quot;truncated&quot;&lt;/code&gt;.</source>
          <target state="translated">请注意，默认情况下最多解析100个响应标头（包括具有相同名称的响应标头），并且将静默丢弃其他响应标头以防止潜在的拒绝服务攻击。从 &lt;code&gt;v0.10.13&lt;/code&gt; 开始，超过限制时，它将返回第二个值，即字符串 &lt;code&gt;&quot;truncated&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="743168dca492c48d217f45aed738ce0c167c1930" translate="yes" xml:space="preserve">
          <source>Note that calling this function instead of using &lt;code&gt;ngx.var.request_body&lt;/code&gt; or &lt;code&gt;ngx.var.echo_request_body&lt;/code&gt; is more efficient because it can save one dynamic memory allocation and one data copy.</source>
          <target state="translated">请注意，调用此函数代替使用 &lt;code&gt;ngx.var.request_body&lt;/code&gt; 或 &lt;code&gt;ngx.var.echo_request_body&lt;/code&gt; 更为有效，因为它可以节省一个动态内存分配和一个数据副本。</target>
        </trans-unit>
        <trans-unit id="ffc114cd7564144dd44fa220318a670bed172c5f" translate="yes" xml:space="preserve">
          <source>Note that common HTTP benchmark tools such as &lt;code&gt;ab&lt;/code&gt; and &lt;code&gt;http_load&lt;/code&gt; issue HTTP 1.0 requests by default. To force &lt;code&gt;curl&lt;/code&gt; to send HTTP 1.0 requests, use the &lt;code&gt;-0&lt;/code&gt; option.</source>
          <target state="translated">请注意，默认情况下，诸如 &lt;code&gt;ab&lt;/code&gt; 和 &lt;code&gt;http_load&lt;/code&gt; 之类的常见HTTP基准测试工具会发出HTTP 1.0请求。要强制 &lt;code&gt;curl&lt;/code&gt; 发送HTTP 1.0请求，请使用 &lt;code&gt;-0&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="0f5af5cc042d914dbd336c6f815b1937ebedae81" translate="yes" xml:space="preserve">
          <source>Note that if both &lt;code&gt;share_all_vars&lt;/code&gt; and &lt;code&gt;copy_all_vars&lt;/code&gt; are set to true, then &lt;code&gt;share_all_vars&lt;/code&gt; takes precedence.</source>
          <target state="translated">请注意，如果将 &lt;code&gt;share_all_vars&lt;/code&gt; 和 &lt;code&gt;copy_all_vars&lt;/code&gt; 都设置为true，则 &lt;code&gt;share_all_vars&lt;/code&gt; 优先。</target>
        </trans-unit>
        <trans-unit id="48099a61abc289fffe618c332f51e8f6de3f885a" translate="yes" xml:space="preserve">
          <source>Note that it is not possible to use this interface to rewrite URI arguments and that &lt;a href=&quot;#ngxreqset_uri_args&quot;&gt;ngx.req.set_uri_args&lt;/a&gt; should be used for this instead. For instance, Nginx config</source>
          <target state="translated">请注意，不可能使用此接口来重写URI参数，而应为此使用&lt;a href=&quot;#ngxreqset_uri_args&quot;&gt;ngx.req.set_uri_args&lt;/a&gt;。例如，Nginx配置</target>
        </trans-unit>
        <trans-unit id="635706fb9785de0c24d1ba53fd8772141c4b840d" translate="yes" xml:space="preserve">
          <source>Note that it is recommended to use LuaJIT 2.0 or LuaJIT 2.1 instead of the standard Lua 5.1 interpreter wherever possible.</source>
          <target state="translated">注意,建议尽可能使用LuaJIT 2.0或LuaJIT 2.1代替标准的Lua 5.1解释器。</target>
        </trans-unit>
        <trans-unit id="edb15788554d45256eb17bf97302880ace5c4bfc" translate="yes" xml:space="preserve">
          <source>Note that only already defined nginx variables can be written to. For example:</source>
          <target state="translated">请注意,只有已经定义的nginx变量才能被写入。例如</target>
        </trans-unit>
        <trans-unit id="f873d4ff7e9d38bf403e125e01129f4d718d49a3" translate="yes" xml:space="preserve">
          <source>Note that only three of these constants are utilized by the &lt;a href=&quot;#nginx-api-for-lua&quot;&gt;Nginx API for Lua&lt;/a&gt; (i.e., &lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt; accepts &lt;code&gt;ngx.OK&lt;/code&gt;, &lt;code&gt;ngx.ERROR&lt;/code&gt;, and &lt;code&gt;ngx.DECLINED&lt;/code&gt; as input).</source>
          <target state="translated">请注意，&lt;a href=&quot;#nginx-api-for-lua&quot;&gt;Nginx API&lt;/a&gt;仅将其中三个常量用于Lua（即&lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt;接受 &lt;code&gt;ngx.OK&lt;/code&gt; ， &lt;code&gt;ngx.ERROR&lt;/code&gt; 和 &lt;code&gt;ngx.DECLINED&lt;/code&gt; 作为输入）。</target>
        </trans-unit>
        <trans-unit id="7ee6f9a462fef43240ba5fd87754796ab92b8973" translate="yes" xml:space="preserve">
          <source>Note that subrequests issued by &lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt; inherit all the request headers of the current request by default and that this may have unexpected side effects on the subrequest responses. For example, when using the standard &lt;code&gt;ngx_proxy&lt;/code&gt; module to serve subrequests, an &quot;Accept-Encoding: gzip&quot; header in the main request may result in gzipped responses that cannot be handled properly in Lua code. Original request headers should be ignored by setting &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass_request_headers&quot;&gt;proxy_pass_request_headers&lt;/a&gt; to &lt;code&gt;off&lt;/code&gt; in subrequest locations.</source>
          <target state="translated">请注意，默认情况下，由&lt;a href=&quot;#ngxlocationcapture&quot;&gt;ngx.location.capture&lt;/a&gt;发出的子请求继承了当前请求的所有请求标头，这可能会对子请求响应产生意外的副作用。例如，当使用标准的 &lt;code&gt;ngx_proxy&lt;/code&gt; 模块满足子请求时，主请求中的&amp;ldquo; Accept-Encoding：gzip&amp;rdquo;标头可能会导致无法在Lua代码中正确处理压缩后的响应。通过在子请求位置将&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass_request_headers&quot;&gt;proxy_pass_request_headers&lt;/a&gt;设置为 &lt;code&gt;off&lt;/code&gt; ，可以忽略原始请求标头。</target>
        </trans-unit>
        <trans-unit id="79df2901fb5d3ee02055928105ad97a59018aae1" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;#ngxvarvariable&quot;&gt;ngx.var.HEADER&lt;/a&gt; API call, which uses core &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#var_http_&quot;&gt;$http_HEADER&lt;/a&gt; variables, may be more preferable for reading individual request headers.</source>
          <target state="translated">请注意，使用核心&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#var_http_&quot;&gt;$ http_HEADER&lt;/a&gt;变量的&lt;a href=&quot;#ngxvarvariable&quot;&gt;ngx.var.HEADER&lt;/a&gt; API调用对于读取单个请求标头可能更可取。</target>
        </trans-unit>
        <trans-unit id="67a51ca95a947300c8f414535f67f2618e187c4f" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;http://mdounin.ru/hg/ngx_http_auth_request_module/&quot;&gt;ngx_auth_request&lt;/a&gt; module can be approximated by using &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua&lt;/a&gt;:</source>
          <target state="translated">请注意，可以使用&lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua&lt;/a&gt;来近似&lt;a href=&quot;http://mdounin.ru/hg/ngx_http_auth_request_module/&quot;&gt;ngx_auth_request&lt;/a&gt;模块：</target>
        </trans-unit>
        <trans-unit id="5b65537e7401c6365e05d755fe499666e9509068" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;http://www.grid.net.ru/nginx/eval.en.html&quot;&gt;ngx_eval&lt;/a&gt; module can be approximated by using &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt;. For example,</source>
          <target state="translated">请注意，可以使用&lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt;来近似&lt;a href=&quot;http://www.grid.net.ru/nginx/eval.en.html&quot;&gt;ngx_eval&lt;/a&gt;模块。例如，</target>
        </trans-unit>
        <trans-unit id="2bef02be7814d9387fe72d8350e88075e429ca7c" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;ngx.exec&lt;/code&gt; method is different from &lt;a href=&quot;#ngxredirect&quot;&gt;ngx.redirect&lt;/a&gt; in that it is purely an internal redirect and that no new external HTTP traffic is involved.</source>
          <target state="translated">请注意， &lt;code&gt;ngx.exec&lt;/code&gt; 方法是不同&lt;a href=&quot;#ngxredirect&quot;&gt;ngx.redirect&lt;/a&gt;，它纯粹是内部重定向，并且没有新的外部HTTP流量参与。</target>
        </trans-unit>
        <trans-unit id="62cffba727436c20ac21ca7a9a3735f739d1c34e" translate="yes" xml:space="preserve">
          <source>Note that the cosocket connection pool is per Nginx worker process rather than per Nginx server instance, so the size limit specified here also applies to every single Nginx worker process.</source>
          <target state="translated">请注意,cosocket连接池是每个Nginx工作进程而不是每个Nginx服务器实例,所以这里指定的大小限制也适用于每一个Nginx工作进程。</target>
        </trans-unit>
        <trans-unit id="241f427b409acf1de61d88e8f8a697694cb2704a" translate="yes" xml:space="preserve">
          <source>Note that the cosocket connection pool is per nginx worker process rather than per nginx server instance, so size limit specified here also applies to every single nginx worker process.</source>
          <target state="translated">请注意,cosocket连接池是每个nginx工作进程而不是每个nginx服务器实例,所以这里指定的大小限制也适用于每一个nginx工作进程。</target>
        </trans-unit>
        <trans-unit id="78f079835cc1b6190832ff2a709eb3b927795aaf" translate="yes" xml:space="preserve">
          <source>Note that the following API functions are currently disabled within this context due to the limitations in NGINX output filter's current implementation:</source>
          <target state="translated">请注意,由于NGINX输出过滤器当前实现的限制,以下API函数目前在此上下文中被禁用。</target>
        </trans-unit>
        <trans-unit id="c26daf5ee962e61ee82a6ed2f28e3983ef768b61" translate="yes" xml:space="preserve">
          <source>Note that the following API functions are currently disabled within this context:</source>
          <target state="translated">请注意,以下API功能目前在此上下文中被禁用。</target>
        </trans-unit>
        <trans-unit id="cd38306081c80b27c7dc753adcf3b7baf9df370b" translate="yes" xml:space="preserve">
          <source>Note that the log level specified in the standard &lt;a href=&quot;http://nginx.org/r/error_log&quot;&gt;error_log&lt;/a&gt; directive &lt;em&gt;does&lt;/em&gt; have effect on this capturing facility. It only captures log messages of a level no lower than the specified log level in the &lt;a href=&quot;http://nginx.org/r/error_log&quot;&gt;error_log&lt;/a&gt; directive. The user can still choose to set an even higher filtering log level on the fly via the Lua API function &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/errlog.md#set_filter_level&quot;&gt;errlog.set_filter_level&lt;/a&gt;. So it is more flexible than the static &lt;a href=&quot;http://nginx.org/r/error_log&quot;&gt;error_log&lt;/a&gt; directive.</source>
          <target state="translated">请注意，标准&lt;a href=&quot;http://nginx.org/r/error_log&quot;&gt;error_log&lt;/a&gt;指令&lt;em&gt;中&lt;/em&gt;指定的日志级别&lt;em&gt;确实&lt;/em&gt;对此捕获工具有效。它仅捕获不低于&lt;a href=&quot;http://nginx.org/r/error_log&quot;&gt;error_log&lt;/a&gt;指令中指定的日志级别的日志消息。用户仍然可以选择通过Lua API函数&lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/errlog.md#set_filter_level&quot;&gt;errlog.set_filter_level&lt;/a&gt;即时设置更高的过滤日志级别。因此，它比静态&lt;a href=&quot;http://nginx.org/r/error_log&quot;&gt;error_log&lt;/a&gt;指令更灵活。</target>
        </trans-unit>
        <trans-unit id="ef3ecbd1bc71a20a034bc8a316195134d0cfd59f" translate="yes" xml:space="preserve">
          <source>Note that the value of an expired key is not guaranteed to be available so one should never rely on the availability of expired items.</source>
          <target state="translated">需要注意的是,过期键的值是不能保证可用的,所以千万不要依赖过期项目的可用性。</target>
        </trans-unit>
        <trans-unit id="9c17d3ae2ae57cfed67fdbf3944b81b4b2ea38e9" translate="yes" xml:space="preserve">
          <source>Note that there is no need to call this method on socket objects that have invoked the &lt;a href=&quot;#tcpsocksetkeepalive&quot;&gt;setkeepalive&lt;/a&gt; method because the socket object is already closed (and the current connection is saved into the built-in connection pool).</source>
          <target state="translated">请注意，由于套接字对象已关闭（并且当前连接已保存到内置连接池中），因此无需在调用&lt;a href=&quot;#tcpsocksetkeepalive&quot;&gt;setkeepalive&lt;/a&gt;方法的套接字对象上调用此方法。</target>
        </trans-unit>
        <trans-unit id="c6fc8a3217ccf3d63047159121f3295c5a66de28" translate="yes" xml:space="preserve">
          <source>Note that there is normally no need to manually send out response headers as ngx_lua will automatically send headers out before content is output with &lt;a href=&quot;#ngxsay&quot;&gt;ngx.say&lt;/a&gt; or &lt;a href=&quot;#ngxprint&quot;&gt;ngx.print&lt;/a&gt; or when &lt;a href=&quot;#content_by_lua&quot;&gt;content_by_lua*&lt;/a&gt; exits normally.</source>
          <target state="translated">请注意，通常无需手动发送响应标头，因为ngx_lua会在使用&lt;a href=&quot;#ngxsay&quot;&gt;ngx.say&lt;/a&gt;或&lt;a href=&quot;#ngxprint&quot;&gt;ngx.print&lt;/a&gt;输出内容之前或当&lt;a href=&quot;#content_by_lua&quot;&gt;content_by_lua *&lt;/a&gt;正常退出时自动发送标头。</target>
        </trans-unit>
        <trans-unit id="65940a3ec594d1ac2ed9e614e82f55bdc446b125" translate="yes" xml:space="preserve">
          <source>Note that this data sharing is on a &lt;em&gt;per-worker&lt;/em&gt; basis and not on a &lt;em&gt;per-server&lt;/em&gt; basis. That is, when there are multiple nginx worker processes under an Nginx master, data sharing cannot cross the process boundary between these workers.</source>
          <target state="translated">请注意，此数据共享是基于&lt;em&gt;每个员工的，&lt;/em&gt;而不是基于&lt;em&gt;每个服务器的&lt;/em&gt;。也就是说，当一个Nginx主服务器下有多个Nginx工作进程时，数据共享不能跨越这些工作进程之间的进程边界。</target>
        </trans-unit>
        <trans-unit id="aea3e11a46abc5a4d3ded826776d9811dc5282ca" translate="yes" xml:space="preserve">
          <source>Note that this directive does &lt;em&gt;not&lt;/em&gt; affect the memory allocated by LuaJIT's own allocator based on the &lt;code&gt;mmap&lt;/code&gt; system call.</source>
          <target state="translated">请注意，这个指令并&lt;em&gt;不会&lt;/em&gt;影响通过基于LuaJIT自己的分配器分配的内存 &lt;code&gt;mmap&lt;/code&gt; 系统调用。</target>
        </trans-unit>
        <trans-unit id="5378198c8f75c3dea99f65b1c6ccf69ba63ca45e" translate="yes" xml:space="preserve">
          <source>Note that this handler always runs &lt;em&gt;after&lt;/em&gt; the standard &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_access_module.html&quot;&gt;ngx_http_access_module&lt;/a&gt;. So the following will work as expected:</source>
          <target state="translated">请注意，此处理程序始终&lt;em&gt;在&lt;/em&gt;标准&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_access_module.html&quot;&gt;ngx_http_access_module &lt;/a&gt;&lt;em&gt;之后&lt;/em&gt;运行。因此，以下将按预期工作：</target>
        </trans-unit>
        <trans-unit id="8e3d5c6d6e30193a16dcba5b440dd21fac4f6d95" translate="yes" xml:space="preserve">
          <source>Note that this handler always runs &lt;em&gt;after&lt;/em&gt; the standard &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_rewrite_module.html&quot;&gt;ngx_http_rewrite_module&lt;/a&gt;. So the following will work as expected:</source>
          <target state="translated">请注意，此处理程序始终&lt;em&gt;在&lt;/em&gt;标准&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_rewrite_module.html&quot;&gt;ngx_http_rewrite_module &lt;/a&gt;&lt;em&gt;之后&lt;/em&gt;运行。因此，以下将按预期工作：</target>
        </trans-unit>
        <trans-unit id="4c3114da95df93d38fa2f4849cd93af3ba3cc641" translate="yes" xml:space="preserve">
          <source>Note that this method call terminates the processing of the current request and that it &lt;em&gt;must&lt;/em&gt; be called before &lt;a href=&quot;#ngxsend_headers&quot;&gt;ngx.send_headers&lt;/a&gt; or explicit response body outputs by either &lt;a href=&quot;#ngxprint&quot;&gt;ngx.print&lt;/a&gt; or &lt;a href=&quot;#ngxsay&quot;&gt;ngx.say&lt;/a&gt;.</source>
          <target state="translated">请注意，此方法调用会终止当前请求的处理，并且&lt;em&gt;必须&lt;/em&gt;在&lt;a href=&quot;#ngxsend_headers&quot;&gt;ngx.send_headers&lt;/a&gt;或显式响应主体输出之前被&lt;a href=&quot;#ngxprint&quot;&gt;ngx.print&lt;/a&gt;或&lt;a href=&quot;#ngxsay&quot;&gt;ngx.say &lt;/a&gt;调用。</target>
        </trans-unit>
        <trans-unit id="efa22a6c439c29f9ac4721c5a272772493fbc244" translate="yes" xml:space="preserve">
          <source>Note that this method does &lt;em&gt;not&lt;/em&gt; affect the &lt;a href=&quot;#lua_socket_keepalive_timeout&quot;&gt;lua_socket_keepalive_timeout&lt;/a&gt; setting; the &lt;code&gt;timeout&lt;/code&gt; argument to the &lt;a href=&quot;#tcpsocksetkeepalive&quot;&gt;setkeepalive&lt;/a&gt; method should be used for this purpose instead.</source>
          <target state="translated">请注意，这种方法并&lt;em&gt;不会&lt;/em&gt;影响&lt;a href=&quot;#lua_socket_keepalive_timeout&quot;&gt;lua_socket_keepalive_timeout&lt;/a&gt;设置; &lt;a href=&quot;#tcpsocksetkeepalive&quot;&gt;为此，&lt;/a&gt;应使用setkeepalive方法的 &lt;code&gt;timeout&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="9d1a32d310451fff398026007327c7ca625d74fc" translate="yes" xml:space="preserve">
          <source>Note that when calling &lt;code&gt;ngx.exit(ngx.OK)&lt;/code&gt; within a &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua&lt;/a&gt; handler, the nginx request processing control flow will still continue to the content handler. To terminate the current request from within a &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua&lt;/a&gt; handler, calling &lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt; with status &amp;gt;= 200 (&lt;code&gt;ngx.HTTP_OK&lt;/code&gt;) and status &amp;lt; 300 (&lt;code&gt;ngx.HTTP_SPECIAL_RESPONSE&lt;/code&gt;) for successful quits and &lt;code&gt;ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)&lt;/code&gt; (or its friends) for failures.</source>
          <target state="translated">请注意，调用时 &lt;code&gt;ngx.exit(ngx.OK)&lt;/code&gt; 一内&lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua&lt;/a&gt;处理器，Nginx的请求处理的控制流仍然会继续在内容处理程序。要终止从内的当前请求&lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua&lt;/a&gt;处理程序，调用&lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt;与状态&amp;gt; = 200（ &lt;code&gt;ngx.HTTP_OK&lt;/code&gt; ）和状态&amp;lt;300（ &lt;code&gt;ngx.HTTP_SPECIAL_RESPONSE&lt;/code&gt; ）对于成功的对等和 &lt;code&gt;ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)&lt;/code&gt; （或它的朋友）的失败。</target>
        </trans-unit>
        <trans-unit id="fb9ed874675b6a917baaa4e4da878aea8074b2c7" translate="yes" xml:space="preserve">
          <source>Note that when calling &lt;code&gt;ngx.exit(ngx.OK)&lt;/code&gt; within a &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt; handler, the nginx request processing control flow will still continue to the content handler. To terminate the current request from within a &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt; handler, calling &lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt; with status &amp;gt;= 200 (&lt;code&gt;ngx.HTTP_OK&lt;/code&gt;) and status &amp;lt; 300 (&lt;code&gt;ngx.HTTP_SPECIAL_RESPONSE&lt;/code&gt;) for successful quits and &lt;code&gt;ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)&lt;/code&gt; (or its friends) for failures.</source>
          <target state="translated">请注意，调用时 &lt;code&gt;ngx.exit(ngx.OK)&lt;/code&gt; 一内&lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt;处理器，Nginx的请求处理的控制流仍然会继续在内容处理程序。从内终止当前请求&lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt;处理程序，调用&lt;a href=&quot;#ngxexit&quot;&gt;ngx.exit&lt;/a&gt;与状态&amp;gt; = 200（ &lt;code&gt;ngx.HTTP_OK&lt;/code&gt; ）和状态&amp;lt;300（ &lt;code&gt;ngx.HTTP_SPECIAL_RESPONSE&lt;/code&gt; ）对于成功的对等和 &lt;code&gt;ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)&lt;/code&gt; （或它的朋友）的失败。</target>
        </trans-unit>
        <trans-unit id="ce920d31e7164c7c248a289220762794bc51e09f" translate="yes" xml:space="preserve">
          <source>Note that while this method accepts all &lt;a href=&quot;#http-status-constants&quot;&gt;HTTP status constants&lt;/a&gt; as input, it only accepts &lt;code&gt;ngx.OK&lt;/code&gt; and &lt;code&gt;ngx.ERROR&lt;/code&gt; of the &lt;a href=&quot;#core-constants&quot;&gt;core constants&lt;/a&gt;.</source>
          <target state="translated">请注意，虽然这种方法接受所有&lt;a href=&quot;#http-status-constants&quot;&gt;的HTTP状态常量&lt;/a&gt;作为输入，它只接受 &lt;code&gt;ngx.OK&lt;/code&gt; 和 &lt;code&gt;ngx.ERROR&lt;/code&gt; 的的&lt;a href=&quot;#core-constants&quot;&gt;核心常数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0523483ad1b28cf5e24d2e5f78061cbcf3d05b1f" translate="yes" xml:space="preserve">
          <source>Note that, the &lt;code&gt;options&lt;/code&gt; argument is not optional when the &lt;code&gt;ctx&lt;/code&gt; argument is specified and that the empty Lua string (&lt;code&gt;&quot;&quot;&lt;/code&gt;) must be used as placeholder for &lt;code&gt;options&lt;/code&gt; if no meaningful regex options are required.</source>
          <target state="translated">请注意，当指定 &lt;code&gt;ctx&lt;/code&gt; 参数时， &lt;code&gt;options&lt;/code&gt; 参数不是可选的，并且如果不需要有意义的regex选项，则必须使用空的Lua字符串（ &lt;code&gt;&quot;&quot;&lt;/code&gt; ）作为 &lt;code&gt;options&lt;/code&gt; 占位符。</target>
        </trans-unit>
        <trans-unit id="dac765fca3a6b7e61e41ecfa8ef82543c0da9567" translate="yes" xml:space="preserve">
          <source>Note that, the actual data returned &lt;em&gt;might&lt;/em&gt; be a little longer than the size limit specified by the &lt;code&gt;size&lt;/code&gt; argument when the boundary pattern has ambiguity for streaming parsing. Near the boundary of the data stream, the data string actually returned could also be shorter than the size limit.</source>
          <target state="translated">请注意，当边界模式对流解析有歧义时，返回的实际数据&lt;em&gt;可能&lt;/em&gt;会比 &lt;code&gt;size&lt;/code&gt; 参数指定的大小限制稍长。在数据流边界附近，实际返回的数据字符串也可能短于大小限制。</target>
        </trans-unit>
        <trans-unit id="53caa61884a392996df870c29b8b8899252f9961" translate="yes" xml:space="preserve">
          <source>Note that: this directive is only allowed to used in &lt;strong&gt;http context&lt;/strong&gt; from the &lt;code&gt;v0.10.7&lt;/code&gt; release (because SSL session resumption happens before server name dispatch).</source>
          <target state="translated">请注意：仅在 &lt;code&gt;v0.10.7&lt;/code&gt; 发行版的&lt;strong&gt;http上下文中&lt;/strong&gt;允许使用此伪指令（因为SSL会话恢复发生在服务器名称分配之前）。</target>
        </trans-unit>
        <trans-unit id="d86f91b6b98ea753d4b1937f9cffe9e00293a081" translate="yes" xml:space="preserve">
          <source>Note, however, you still need to configure the &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate&quot;&gt;ssl_certificate&lt;/a&gt; and &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate_key&quot;&gt;ssl_certificate_key&lt;/a&gt; directives even though you will not use this static certificate and private key at all. This is because the NGINX core requires their appearance otherwise you are seeing the following error while starting NGINX:</source>
          <target state="translated">但是请注意，即使您根本不会使用此静态证书和私钥，您仍然需要配置&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate&quot;&gt;ssl_certificate&lt;/a&gt;和&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate_key&quot;&gt;ssl_certificate_key&lt;/a&gt;指令。这是因为NGINX核心需要其外观，否则在启动NGINX时会看到以下错误：</target>
        </trans-unit>
        <trans-unit id="6f8fee789de2239f32252fc0ea860eb1196d61fb" translate="yes" xml:space="preserve">
          <source>Number literals can be used directly as the argument, for instance,</source>
          <target state="translated">例如,可以直接使用数字字元作为参数。</target>
        </trans-unit>
        <trans-unit id="c03a182e232ebf3731354a8d3d8f0708ccebd13c" translate="yes" xml:space="preserve">
          <source>Obsolete Sections</source>
          <target state="translated">过时章节</target>
        </trans-unit>
        <trans-unit id="b0569934667f9535a3a8009c4f970f485c8b5046" translate="yes" xml:space="preserve">
          <source>On FreeBSD, you can only tune the system-wide configuration for TCP keepalive, for example:</source>
          <target state="translated">在FreeBSD上,您只能调整系统范围内的TCP keepalive配置,例如。</target>
        </trans-unit>
        <trans-unit id="03c0aa2318533eccb27e93afe825b16452d78401" translate="yes" xml:space="preserve">
          <source>On the other hand, if already assigned pages for a slot are full and a new key value pair is added to the slot and there is no free page, you may get &lt;code&gt;true&lt;/code&gt; for &lt;code&gt;forcible&lt;/code&gt; or non nil &lt;code&gt;err&lt;/code&gt; from the &lt;code&gt;ngx.shared.DICT.set&lt;/code&gt; method.</source>
          <target state="translated">在另一方面，如果换一个插槽已分配页已满，新的键值对被添加到插槽中，并且没有免费的页面，你可能会得到 &lt;code&gt;true&lt;/code&gt; 的 &lt;code&gt;forcible&lt;/code&gt; 或非零 &lt;code&gt;err&lt;/code&gt; 从 &lt;code&gt;ngx.shared.DICT.set&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="2abb0e064654f62263371409fbb8f72bc052ed5f" translate="yes" xml:space="preserve">
          <source>On the other hand, the following will not work as expected:</source>
          <target state="translated">另一方面,以下内容将无法达到预期效果。</target>
        </trans-unit>
        <trans-unit id="71a17540ae1f85b28c2e4909c43012dcae705555" translate="yes" xml:space="preserve">
          <source>One can also create infinite re-occurring timers, for instance, a timer getting triggered every &lt;code&gt;5&lt;/code&gt; seconds, by calling &lt;code&gt;ngx.timer.at&lt;/code&gt; recursively in the timer callback function. Here is such an example,</source>
          <target state="translated">也可以创建无限重复的计时器，例如，通过在计时器回调函数中递归调用 &lt;code&gt;ngx.timer.at&lt;/code&gt; ，每 &lt;code&gt;5&lt;/code&gt; 秒触发一次计时器。这是一个例子</target>
        </trans-unit>
        <trans-unit id="adb0046bb29bfa4db097a4bbcea9947356872d62" translate="yes" xml:space="preserve">
          <source>One can also do interesting things with the SSL handshake requests from the client side, like rejecting old SSL clients using the SSLv3 protocol or even below selectively.</source>
          <target state="translated">人们还可以对客户端的SSL握手请求做一些有趣的事情,比如有选择地拒绝使用SSLv3协议甚至以下的老SSL客户端。</target>
        </trans-unit>
        <trans-unit id="c5e0bc2f5147549b7fd6ef6fb9de7ce90fcde69c" translate="yes" xml:space="preserve">
          <source>Only Lua tables are accepted (Only the last element in the table will take effect for standard headers such as &lt;code&gt;Content-Type&lt;/code&gt; that only accept a single value).</source>
          <target state="translated">仅接受Lua表（仅表中的最后一个元素将对仅包含单个值的标准标头（如 &lt;code&gt;Content-Type&lt;/code&gt; )生效）。</target>
        </trans-unit>
        <trans-unit id="6d0aaaf98389c788f883363c37cfc85fd9be0746" translate="yes" xml:space="preserve">
          <source>Only a small set of the &lt;a href=&quot;#nginx-api-for-lua&quot;&gt;Nginx API for Lua&lt;/a&gt; is supported in this context:</source>
          <target state="translated">在这种情况下，仅支持一小部分&lt;a href=&quot;#nginx-api-for-lua&quot;&gt;用于Lua&lt;/a&gt;的Nginx API：</target>
        </trans-unit>
        <trans-unit id="5c51ffee27fcb15fca9bd29d4b659569bedb8e46" translate="yes" xml:space="preserve">
          <source>Only the direct &quot;parent coroutine&quot; can wait on its child &quot;light thread&quot;, otherwise a Lua exception will be raised.</source>
          <target state="translated">只有直接的 &quot;父线程 &quot;才能等待它的子线程 &quot;轻线程&quot;,否则会引发一个Lua异常。</target>
        </trans-unit>
        <trans-unit id="afd371453a7b8e55165edd57aa5ec9a58d8d4009" translate="yes" xml:space="preserve">
          <source>Only the first occurrence of the match is returned, or &lt;code&gt;nil&lt;/code&gt; if no match is found. In case of errors, like seeing a bad regular expression or exceeding the PCRE stack limit, &lt;code&gt;nil&lt;/code&gt; and a string describing the error will be returned.</source>
          <target state="translated">仅返回匹配的第一个匹配项；如果找不到匹配项，则返回 &lt;code&gt;nil&lt;/code&gt; 。在出现错误的情况下，例如看到错误的正则表达式或超出了PCRE堆栈限制，将返回 &lt;code&gt;nil&lt;/code&gt; 和描述错误的字符串。</target>
        </trans-unit>
        <trans-unit id="8f804668d49f20e57cd51e9ff3953ef79ca04072" translate="yes" xml:space="preserve">
          <source>Other scripting language implementations typically struggle to match this performance level.</source>
          <target state="translated">其他脚本语言的实现通常难以达到这个性能水平。</target>
        </trans-unit>
        <trans-unit id="08a88eb245e53d08d29d5aa1beb2ec1f73d677bc" translate="yes" xml:space="preserve">
          <source>Output API functions (e.g., &lt;a href=&quot;#ngxsay&quot;&gt;ngx.say&lt;/a&gt; and &lt;a href=&quot;#ngxsend_headers&quot;&gt;ngx.send_headers&lt;/a&gt;)</source>
          <target state="translated">输出API函数（例如&lt;a href=&quot;#ngxsay&quot;&gt;ngx.say&lt;/a&gt;和&lt;a href=&quot;#ngxsend_headers&quot;&gt;ngx.send_headers&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="b740866b81e1a9a29cde50a218d2c7a6c45abe3d" translate="yes" xml:space="preserve">
          <source>Overrides the current request's request method with the &lt;code&gt;method_id&lt;/code&gt; argument. Currently only numerical &lt;a href=&quot;#http-method-constants&quot;&gt;method constants&lt;/a&gt; are supported, like &lt;code&gt;ngx.HTTP_POST&lt;/code&gt; and &lt;code&gt;ngx.HTTP_GET&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;method_id&lt;/code&gt; 参数覆盖当前请求的请求方法。当前仅支持数字&lt;a href=&quot;#http-method-constants&quot;&gt;方法常量&lt;/a&gt;，例如 &lt;code&gt;ngx.HTTP_POST&lt;/code&gt; 和 &lt;code&gt;ngx.HTTP_GET&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f4b6b0ff7de5f6cefd55273d83f8121d45cc214" translate="yes" xml:space="preserve">
          <source>Overriding &lt;code&gt;ngx.ctx&lt;/code&gt; with a new Lua table is also supported, for example,</source>
          <target state="translated">还支持使用新的Lua表覆盖 &lt;code&gt;ngx.ctx&lt;/code&gt; ，例如，</target>
        </trans-unit>
        <trans-unit id="5caee26e4647c4206c97dcd1b0ffadb41e52643b" translate="yes" xml:space="preserve">
          <source>PCRE sequences such as &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt;, or &lt;code&gt;\w&lt;/code&gt;, require special attention because in string literals, the backslash character, &lt;code&gt;\&lt;/code&gt;, is stripped out by both the Lua language parser and by the nginx config file parser before processing if not within a &lt;code&gt;*_by_lua_block {}&lt;/code&gt; directive. So the following snippet will not work as expected:</source>
          <target state="translated">诸如 &lt;code&gt;\d&lt;/code&gt; ， &lt;code&gt;\s&lt;/code&gt; 或 &lt;code&gt;\w&lt;/code&gt; 类的PCRE序列需要特别注意，因为在字符串文字中，Lua语言解析器和nginx配置文件解析器会在处理之前将反斜杠字符 &lt;code&gt;\&lt;/code&gt; 去除，如果不在 &lt;code&gt;*_by_lua_block {}&lt;/code&gt; 指令。因此，以下代码段将无法按预期工作：</target>
        </trans-unit>
        <trans-unit id="145d85eb0a8f2d5fdeec50de4cacc59af1ecb86e" translate="yes" xml:space="preserve">
          <source>Parse the http time string (as returned by &lt;a href=&quot;#ngxhttp_time&quot;&gt;ngx.http_time&lt;/a&gt;) into seconds. Returns the seconds or &lt;code&gt;nil&lt;/code&gt; if the input string is in bad forms.</source>
          <target state="translated">将http时间字符串（由&lt;a href=&quot;#ngxhttp_time&quot;&gt;ngx.http_time&lt;/a&gt;返回）解析为秒。如果输入字符串格式错误，则返回秒或 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="44488a589161a071542d6dfc49ee7be4801f80ee" translate="yes" xml:space="preserve">
          <source>Pending timers are those timers that have not expired yet.</source>
          <target state="translated">待定定时器是指那些尚未到期的定时器。</target>
        </trans-unit>
        <trans-unit id="0c2bcb84eb711873a63a27d5efc0c52d05d8dc6c" translate="yes" xml:space="preserve">
          <source>Perl modules:</source>
          <target state="translated">Perl模块。</target>
        </trans-unit>
        <trans-unit id="dd4762faa58429d2699de300f151771d4835ea83" translate="yes" xml:space="preserve">
          <source>Please also refer to restrictions on capturing locations configured by &lt;a href=&quot;#locations-configured-by-subrequest-directives-of-other-modules&quot;&gt;subrequest directives of other modules&lt;/a&gt;.</source>
          <target state="translated">另请参见对捕获&lt;a href=&quot;#locations-configured-by-subrequest-directives-of-other-modules&quot;&gt;其他模块的subrequest指令&lt;/a&gt;配置的位置的限制。</target>
        </trans-unit>
        <trans-unit id="340e202e8e171b13e6084a6a12dcef1b97f23950" translate="yes" xml:space="preserve">
          <source>Please ensure that the file specified by the &lt;code&gt;file_name&lt;/code&gt; argument exists and is readable by an Nginx worker process by setting its permission properly to avoid Lua exception errors.</source>
          <target state="translated">请通过正确设置其权限以避免Lua异常错误，确保由 &lt;code&gt;file_name&lt;/code&gt; 参数指定的文件存在并且可由Nginx工作进程读取。</target>
        </trans-unit>
        <trans-unit id="e1d68c7c6739205d9ccccbd54981cc2e70b86b7c" translate="yes" xml:space="preserve">
          <source>Please note however, that Lua code written inlined within nginx.conf such as those specified by &lt;a href=&quot;#set_by_lua&quot;&gt;set_by_lua&lt;/a&gt;, &lt;a href=&quot;#content_by_lua&quot;&gt;content_by_lua&lt;/a&gt;, &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua&lt;/a&gt;, and &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt; will not be updated when you edit the inlined Lua code in your &lt;code&gt;nginx.conf&lt;/code&gt; file because only the Nginx config file parser can correctly parse the &lt;code&gt;nginx.conf&lt;/code&gt; file and the only way is to reload the config file by sending a &lt;code&gt;HUP&lt;/code&gt; signal or just to restart Nginx.</source>
          <target state="translated">但是请注意，在nginx.conf中内联编写的Lua代码（例如&lt;a href=&quot;#set_by_lua&quot;&gt;set_by_lua&lt;/a&gt;，&lt;a href=&quot;#content_by_lua&quot;&gt;content_by_lua&lt;/a&gt;，&lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua&lt;/a&gt;和&lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt;指定的代码）在您编辑 &lt;code&gt;nginx.conf&lt;/code&gt; 文件中的内联Lua代码时将不会更新，因为只有Nginx配置文件解析器可以正确解析 &lt;code&gt;nginx.conf&lt;/code&gt; 文件，唯一的方法是通过发送 &lt;code&gt;HUP&lt;/code&gt; 信号来重新加载配置文件，或者只是重新启动Nginx。</target>
        </trans-unit>
        <trans-unit id="e7f3cd3da37d895794bf195e08c98fa311f05c0b" translate="yes" xml:space="preserve">
          <source>Please note that TLS session tickets are very different and it is the clients' responsibility to cache the SSL session state when session tickets are used. SSL session resumptions based on TLS session tickets would happen automatically without going through this hook (nor the &lt;a href=&quot;#ssl_session_store_by_lua&quot;&gt;ssl_session_store_by_lua_block&lt;/a&gt; hook). This hook is mainly for older or less capable SSL clients that can only do SSL sessions by session IDs.</source>
          <target state="translated">请注意，TLS会话票证有很大不同，使用会话票证时，客户端有责任缓存SSL会话状态。基于TLS会话票证的SSL会话恢复将自动进行，而无需通过此挂钩（也不通过&lt;a href=&quot;#ssl_session_store_by_lua&quot;&gt;ssl_session_store_by_lua_block&lt;/a&gt;挂钩）。此挂钩主要用于只能使用会话ID进行SSL会话的较旧或性能较差的SSL客户端。</target>
        </trans-unit>
        <trans-unit id="c7bb48f3a05ad03ffd8763830dfbe62a10cc7d1c" translate="yes" xml:space="preserve">
          <source>Please note that both &lt;code&gt;ngx.print&lt;/code&gt; and &lt;a href=&quot;#ngxsay&quot;&gt;ngx.say&lt;/a&gt; will always invoke the whole Nginx output body filter chain, which is an expensive operation. So be careful when calling either of these two in a tight loop; buffer the data yourself in Lua and save the calls.</source>
          <target state="translated">请注意， &lt;code&gt;ngx.print&lt;/code&gt; 和&lt;a href=&quot;#ngxsay&quot;&gt;ngx.say&lt;/a&gt;都将始终调用整个Nginx输出主体过滤器链，这是一项昂贵的操作。因此，在紧密循环中调用这两个方法中的任何一个时都要小心。自己在Lua中缓冲数据并保存呼叫。</target>
        </trans-unit>
        <trans-unit id="0c8bf268191391f7647d74d2390f01df4bd0687f" translate="yes" xml:space="preserve">
          <source>Please note that the bytecode format used by LuaJIT 2.0/2.1 is not compatible with that used by the standard Lua 5.1 interpreter. So if using LuaJIT 2.0/2.1 with ngx_lua, LuaJIT compatible bytecode files must be generated as shown:</source>
          <target state="translated">请注意,LuaJIT 2.0/2.1使用的字节码格式与标准Lua 5.1解释器使用的字节码格式不兼容,所以如果使用LuaJIT 2.0/2.1和ngx_lua,必须生成如图所示的兼容LuaJIT的字节码文件。因此,如果使用LuaJIT 2.0/2.1和ngx_lua,必须生成LuaJIT兼容的字节码文件,如图所示。</target>
        </trans-unit>
        <trans-unit id="e5d0d29938a1c536ed7bb765fab62836d0f7dd78" translate="yes" xml:space="preserve">
          <source>Please note that while internally the key-value pair is set atomically, the atomicity does not go across the method call boundary.</source>
          <target state="translated">请注意,虽然内部的键值对是原子化设置的,但原子性不会跨越方法调用边界。</target>
        </trans-unit>
        <trans-unit id="bc530cb73bd8d9797bf30bbd113aac14efc1553a" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/balancer.md&quot;&gt;documentation&lt;/a&gt; for this &lt;code&gt;ngx.balancer&lt;/code&gt; Lua module in &lt;a href=&quot;https://github.com/openresty/lua-resty-core&quot;&gt;lua-resty-core&lt;/a&gt; for more details.</source>
          <target state="translated">请参阅&lt;a href=&quot;https://github.com/openresty/lua-resty-core&quot;&gt;lua-resty-core中&lt;/a&gt;此 &lt;code&gt;ngx.balancer&lt;/code&gt; Lua模块的&lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/balancer.md&quot;&gt;文档&lt;/a&gt;以获取更多详细信息。</target>
        </trans-unit>
        <trans-unit id="6abebe07286a395e1123395c2fd440d95c29156c" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/semaphore.md&quot;&gt;documentation&lt;/a&gt; for this &lt;code&gt;ngx.semaphore&lt;/code&gt; Lua module in &lt;a href=&quot;https://github.com/openresty/lua-resty-core&quot;&gt;lua-resty-core&lt;/a&gt; for more details.</source>
          <target state="translated">请参阅&lt;a href=&quot;https://github.com/openresty/lua-resty-core&quot;&gt;lua-resty-core中&lt;/a&gt;此 &lt;code&gt;ngx.semaphore&lt;/code&gt; Lua模块的&lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/semaphore.md&quot;&gt;文档&lt;/a&gt;以获取更多详细信息。</target>
        </trans-unit>
        <trans-unit id="d2425efd73bfffeadac4d63c24fae712c0079586" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md&quot;&gt;documentation&lt;/a&gt; for this &lt;code&gt;ngx.ssl&lt;/code&gt; Lua module for more details.</source>
          <target state="translated">有关更多详细信息，请参阅此 &lt;code&gt;ngx.ssl&lt;/code&gt; Lua模块的&lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md&quot;&gt;文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="61e61058a69261424e63bdadb5cbe4bdfe896676" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/ocsp-cert-by-lua-2/lib/ngx/ocsp.md&quot;&gt;documentation&lt;/a&gt; for this &lt;code&gt;ngx.ocsp&lt;/code&gt; Lua module for more details.</source>
          <target state="translated">请参阅此 &lt;code&gt;ngx.ocsp&lt;/code&gt; Lua模块的&lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/ocsp-cert-by-lua-2/lib/ngx/ocsp.md&quot;&gt;文档&lt;/a&gt;以了解更多详细信息。</target>
        </trans-unit>
        <trans-unit id="b515b4d9200087db251e87649d51d772e32c390e" translate="yes" xml:space="preserve">
          <source>Please refer to the official LuaJIT documentation on the &lt;code&gt;-b&lt;/code&gt; option for more details:</source>
          <target state="translated">请参阅 &lt;code&gt;-b&lt;/code&gt; 选项上的LuaJIT官方文档以获取更多详细信息：</target>
        </trans-unit>
        <trans-unit id="cd86759f6786ef46bfdf18395bba2e0294daf7a9" translate="yes" xml:space="preserve">
          <source>Please submit bug reports, wishlists, or patches by</source>
          <target state="translated">请通过以下方式提交错误报告、愿望清单或补丁。</target>
        </trans-unit>
        <trans-unit id="933d70a4e048fc906e493c7e911082827923d0ab" translate="yes" xml:space="preserve">
          <source>Premature timer expiration happens when the Nginx worker process is trying to shut down, as in an Nginx configuration reload triggered by the &lt;code&gt;HUP&lt;/code&gt; signal or in an Nginx server shutdown. When the Nginx worker is trying to shut down, one can no longer call &lt;code&gt;ngx.timer.at&lt;/code&gt; to create new timers with nonzero delays and in that case &lt;code&gt;ngx.timer.at&lt;/code&gt; will return a &quot;conditional false&quot; value and a string describing the error, that is, &quot;process exiting&quot;.</source>
          <target state="translated">当Nginx工作进程试图关闭时，会发生定时器过早到期，例如，由 &lt;code&gt;HUP&lt;/code&gt; 信号触发的Nginx配置重载或Nginx服务器关闭。当Nginx工作者试图关闭时，无法再调用 &lt;code&gt;ngx.timer.at&lt;/code&gt; 来创建具有非零延迟的新计时器，在这种情况下， &lt;code&gt;ngx.timer.at&lt;/code&gt; 将返回&amp;ldquo;条件错误&amp;rdquo;值和描述错误的字符串，即&amp;ldquo;进程正在退出&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="a60d227bf929aec03ac3bf943f60e0474d4fa406" translate="yes" xml:space="preserve">
          <source>Production ready.</source>
          <target state="translated">准备生产。</target>
        </trans-unit>
        <trans-unit id="4c44e5defeed2c1ae1d8dea7ea2e3909a7df78f9" translate="yes" xml:space="preserve">
          <source>Puts the current socket's connection immediately into the cosocket built-in connection pool and keep it alive until other &lt;a href=&quot;#tcpsockconnect&quot;&gt;connect&lt;/a&gt; method calls request it or the associated maximal idle timeout is expired.</source>
          <target state="translated">将当前套接字的连接立即放入cosocket内置连接池中，并保持其活动状态，直到其他&lt;a href=&quot;#tcpsockconnect&quot;&gt;connect&lt;/a&gt;方法调用请求它或相关的最大空闲超时到期为止。</target>
        </trans-unit>
        <trans-unit id="c7f31d08350bf099aff6ac7d34cbcf0c253e933f" translate="yes" xml:space="preserve">
          <source>Read and write Nginx variable values.</source>
          <target state="translated">读写Nginx变量值。</target>
        </trans-unit>
        <trans-unit id="573a83dbb5f547b8987f2cc4b9db719dacd9afde" translate="yes" xml:space="preserve">
          <source>Read and write the current request's response status. This should be called before sending out the response headers.</source>
          <target state="translated">读取和写入当前请求的响应状态。在发送响应头之前应该调用这个函数。</target>
        </trans-unit>
        <trans-unit id="5bddbfc1f846f7b52db8ade30c873a48947a0a0c" translate="yes" xml:space="preserve">
          <source>Reading &lt;code&gt;ngx.header.HEADER&lt;/code&gt; will return the value of the response header named &lt;code&gt;HEADER&lt;/code&gt;.</source>
          <target state="translated">读取 &lt;code&gt;ngx.header.HEADER&lt;/code&gt; 将返回名为 &lt;code&gt;HEADER&lt;/code&gt; 的响应标头的值。</target>
        </trans-unit>
        <trans-unit id="9a1fc527eb6c82235f90ab8a109c20257ccf6262" translate="yes" xml:space="preserve">
          <source>Reads the client request body synchronously without blocking the Nginx event loop.</source>
          <target state="translated">在不阻塞Nginx事件循环的情况下同步读取客户端请求体。</target>
        </trans-unit>
        <trans-unit id="42eafdc210a32b28f9c42192440ad539ca7a709f" translate="yes" xml:space="preserve">
          <source>Receives data from the UDP or datagram unix domain socket object with an optional receive buffer size argument, &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="translated">使用可选的接收缓冲区大小参数 &lt;code&gt;size&lt;/code&gt; 接收来自UDP或数据报unix域套接字对象的数据。</target>
        </trans-unit>
        <trans-unit id="38cb92fdf6dc1e1147eceb575ed56e430a0dda05" translate="yes" xml:space="preserve">
          <source>Receives data from the connected socket according to the reading pattern or size.</source>
          <target state="translated">根据读取模式或大小从连接的插座接收数据。</target>
        </trans-unit>
        <trans-unit id="2db05ac936e93ce2481f252c81c1066468260aab" translate="yes" xml:space="preserve">
          <source>Redirecting arbitrary external URLs is also supported, for example:</source>
          <target state="translated">也支持重定向任意外部URL,例如。</target>
        </trans-unit>
        <trans-unit id="c20bb0f7c4d78b01fa838319a2981e9b417f1f05" translate="yes" xml:space="preserve">
          <source>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</source>
          <target state="translated">允许以源码和二进制形式重新分发和使用,无论是否修改,但必须满足以下条件:</target>
        </trans-unit>
        <trans-unit id="57ec4bae787e02e75ae9439f5fbfc851c887f70f" translate="yes" xml:space="preserve">
          <source>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</source>
          <target state="translated">二进制形式的再分发必须在发行版提供的文档和/或其他材料中复制上述版权声明、本条件列表和以下免责声明。</target>
        </trans-unit>
        <trans-unit id="b7338b5245c44e48d0d288fd4ec6f22445873f8e" translate="yes" xml:space="preserve">
          <source>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</source>
          <target state="translated">源代码的再分发必须保留上述版权声明、本条件清单和以下免责声明。</target>
        </trans-unit>
        <trans-unit id="f02f280a7b4a7b9556d91b7bfffc46c04aa2ac23" translate="yes" xml:space="preserve">
          <source>Registers a user Lua function as the callback which gets called automatically when the client closes the (downstream) connection prematurely.</source>
          <target state="translated">注册一个用户Lua函数作为回调,当客户端过早关闭(下游)连接时,该函数会自动被调用。</target>
        </trans-unit>
        <trans-unit id="645abd20936993e4360af8cbafe9c4dfb101c7d4" translate="yes" xml:space="preserve">
          <source>Removes and returns the first element of the list named &lt;code&gt;key&lt;/code&gt; in the shm-based dictionary &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;.</source>
          <target state="translated">删除并返回基于shm的字典&lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;中名为 &lt;code&gt;key&lt;/code&gt; 的列表的第一个元素。</target>
        </trans-unit>
        <trans-unit id="e639e0fdda9a8bf2d699d2a3458180bd24767f06" translate="yes" xml:space="preserve">
          <source>Removes and returns the last element of the list named &lt;code&gt;key&lt;/code&gt; in the shm-based dictionary &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;.</source>
          <target state="translated">删除并返回基于shm的字典&lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;中名为 &lt;code&gt;key&lt;/code&gt; 的列表的最后一个元素。</target>
        </trans-unit>
        <trans-unit id="9322198eff9f5b29b649fbd4be1a09c203594807" translate="yes" xml:space="preserve">
          <source>Removing the &lt;code&gt;max_args&lt;/code&gt; cap is strongly discouraged.</source>
          <target state="translated">不建议移除 &lt;code&gt;max_args&lt;/code&gt; 上限。</target>
        </trans-unit>
        <trans-unit id="ec5f70f91eaba1bcb60beb759e74c4d39b008102" translate="yes" xml:space="preserve">
          <source>Removing the &lt;code&gt;max_headers&lt;/code&gt; cap is strongly discouraged.</source>
          <target state="translated">强烈建议不要卸下 &lt;code&gt;max_headers&lt;/code&gt; 帽。</target>
        </trans-unit>
        <trans-unit id="44e65159a919bfa802cca475e45694043e0148f9" translate="yes" xml:space="preserve">
          <source>Request &lt;code&gt;GET /lua&lt;/code&gt; will give the output</source>
          <target state="translated">请求 &lt;code&gt;GET /lua&lt;/code&gt; 将给出输出</target>
        </trans-unit>
        <trans-unit id="47b2ef53d67f9bc264bedfe71ce571be12f57298" translate="yes" xml:space="preserve">
          <source>Request &lt;code&gt;GET /lua&lt;/code&gt; yields the output</source>
          <target state="translated">请求 &lt;code&gt;GET /lua&lt;/code&gt; 产生输出</target>
        </trans-unit>
        <trans-unit id="07b5fa881d6cec3c2b78e46cf58f385d740af4d9" translate="yes" xml:space="preserve">
          <source>Resumes the executation of a user Lua coroutine object previously yielded or just created.</source>
          <target state="translated">恢复执行之前产生或刚刚创建的用户Lua coroutine对象。</target>
        </trans-unit>
        <trans-unit id="f2c7186cf75e46d961636abd704332b18f4b5607" translate="yes" xml:space="preserve">
          <source>Retrieves in-memory request body data. It returns a Lua string rather than a Lua table holding all the parsed query arguments. Use the &lt;a href=&quot;#ngxreqget_post_args&quot;&gt;ngx.req.get_post_args&lt;/a&gt; function instead if a Lua table is required.</source>
          <target state="translated">检索内存中的请求主体数据。它返回一个Lua字符串，而不是保存所有已解析查询参数的Lua表。如果需要Lua表，请改用&lt;a href=&quot;#ngxreqget_post_args&quot;&gt;ngx.req.get_post_args&lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="fb82e608b8ad2f96e9c17c4c7524e1a604c6d0bb" translate="yes" xml:space="preserve">
          <source>Retrieves the capacity in bytes for the shm-based dictionary &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt; declared with the &lt;a href=&quot;#lua_shared_dict&quot;&gt;lua_shared_dict&lt;/a&gt; directive.</source>
          <target state="translated">检索使用&lt;a href=&quot;#lua_shared_dict&quot;&gt;lua_shared_dict&lt;/a&gt;指令声明的基于shm的字典&lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;的容量（以字节为单位）。</target>
        </trans-unit>
        <trans-unit id="3155080229a1952b0f59cb46b6029006b7d5bb8d" translate="yes" xml:space="preserve">
          <source>Retrieves the current request's request method name. Strings like &lt;code&gt;&quot;GET&quot;&lt;/code&gt; and &lt;code&gt;&quot;POST&quot;&lt;/code&gt; are returned instead of numerical &lt;a href=&quot;#http-method-constants&quot;&gt;method constants&lt;/a&gt;.</source>
          <target state="translated">检索当前请求的请求方法名称。返回诸如 &lt;code&gt;&quot;GET&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;POST&quot;&lt;/code&gt; 类的字符串，而不是数字&lt;a href=&quot;#http-method-constants&quot;&gt;方法常量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2a3c9d4e7c427a314fdc9c33fd9b98e7bcb3e90b" translate="yes" xml:space="preserve">
          <source>Retrieves the current running phase name. Possible return values are</source>
          <target state="translated">检索当前运行的阶段名称。可能的返回值是</target>
        </trans-unit>
        <trans-unit id="730c8ea87d224a4165bf8e40b347628e7dfd6e4d" translate="yes" xml:space="preserve">
          <source>Retrieves the file name for the in-file request body data. Returns &lt;code&gt;nil&lt;/code&gt; if the request body has not been read or has been read into memory.</source>
          <target state="translated">检索文件内请求正文数据的文件名。如果尚未读取请求主体或已将其读入内存，则返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a1d046c2d10111fd3dcb420150a4c9aa1892afd" translate="yes" xml:space="preserve">
          <source>Retrieves the free page size in bytes for the shm-based dictionary &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;.</source>
          <target state="translated">检索基于shm的字典&lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;的可用页面大小（以字节为单位）。</target>
        </trans-unit>
        <trans-unit id="4748acf2b96d8fbeee842ec92b0a3bfb12c12354" translate="yes" xml:space="preserve">
          <source>Retrieves the remaining TTL (time-to-live in seconds) of a key-value pair in the shm-based dictionary &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;. Returns the TTL as a number if the operation is successfully completed or &lt;code&gt;nil&lt;/code&gt; and an error message otherwise.</source>
          <target state="translated">检索基于shm的字典&lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;中的键值对的剩余TTL（生存时间（以秒为单位））。如果操作成功完成，则将TTL作为数字返回，否则返回 &lt;code&gt;nil&lt;/code&gt; ，否则返回错误消息。</target>
        </trans-unit>
        <trans-unit id="2dad936367e92c213cc5faa3cafc18bade6e73b8" translate="yes" xml:space="preserve">
          <source>Retrieving the value in the dictionary &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt; for the key &lt;code&gt;key&lt;/code&gt;. If the key does not exist or has expired, then &lt;code&gt;nil&lt;/code&gt; will be returned.</source>
          <target state="translated">在字典&lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT中&lt;/a&gt;检索密钥 &lt;code&gt;key&lt;/code&gt; 的值。如果密钥不存在或已过期，则将返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57d33be9b599da6a4ad7e5c545b2ff2296c0fc73" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;1&lt;/code&gt; if the callback is registered successfully or returns &lt;code&gt;nil&lt;/code&gt; and a string describing the error otherwise.</source>
          <target state="translated">如果回调成功注册，则返回 &lt;code&gt;1&lt;/code&gt; ，否则返回 &lt;code&gt;nil&lt;/code&gt; ，否则返回描述错误的字符串。</target>
        </trans-unit>
        <trans-unit id="f33772d172f452f5d2dfe5af149eaa76866095e5" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the current request is an nginx subrequest, or &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">如果当前请求是nginx子请求，则返回 &lt;code&gt;true&lt;/code&gt; ,否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7861b0bd12f49ee1552b37269e5e3f175bb11c7d" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the response headers have been sent (by ngx_lua), and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">如果已发送响应头（通过ngx_lua），则返回 &lt;code&gt;true&lt;/code&gt; ;否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5e8c69cb5a487d7fd09b87f938cad9a16b7ba46f" translate="yes" xml:space="preserve">
          <source>Returns a 3rd value, &lt;code&gt;stale&lt;/code&gt;, indicating whether the key has expired or not.</source>
          <target state="translated">返回第三个值 &lt;code&gt;stale&lt;/code&gt; ，指示密钥是否已过期。</target>
        </trans-unit>
        <trans-unit id="d54c5ba67c364a744f3eb637a7aa9cd27e3e3d8e" translate="yes" xml:space="preserve">
          <source>Returns a Lua table holding all the current request POST query arguments (of the MIME type &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;). Call &lt;a href=&quot;#ngxreqread_body&quot;&gt;ngx.req.read_body&lt;/a&gt; to read the request body first or turn on the &lt;a href=&quot;#lua_need_request_body&quot;&gt;lua_need_request_body&lt;/a&gt; directive to avoid errors.</source>
          <target state="translated">返回一个Lua表，其中包含所有当前请求POST查询参数（MIME类型为 &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; ）。调用&lt;a href=&quot;#ngxreqread_body&quot;&gt;ngx.req.read_body&lt;/a&gt;首先读取请求正文，或打开&lt;a href=&quot;#lua_need_request_body&quot;&gt;lua_need_request_body&lt;/a&gt;指令以避免错误。</target>
        </trans-unit>
        <trans-unit id="cb56ac305c13907d5001e4ec467cba85986b47f1" translate="yes" xml:space="preserve">
          <source>Returns a Lua table holding all the current request URL query arguments.</source>
          <target state="translated">返回一个包含所有当前请求URL查询参数的Lua表。</target>
        </trans-unit>
        <trans-unit id="81175830e221c07eb774ae775bf453a40d3636c9" translate="yes" xml:space="preserve">
          <source>Returns a Lua table holding all the current request headers.</source>
          <target state="translated">返回一个包含所有当前请求头的 Lua 表。</target>
        </trans-unit>
        <trans-unit id="efe5e76da41f853b8b991a7f282ad30a1267bc80" translate="yes" xml:space="preserve">
          <source>Returns a Lua table holding all the current response headers for the current request.</source>
          <target state="translated">Returns a Lua table holding all current response headers for the current request.</target>
        </trans-unit>
        <trans-unit id="3c495800f8c2c1165426fab79e976b2df2ccd27c" translate="yes" xml:space="preserve">
          <source>Returns a Lua table with 4 slots: &lt;code&gt;res.status&lt;/code&gt;, &lt;code&gt;res.header&lt;/code&gt;, &lt;code&gt;res.body&lt;/code&gt;, and &lt;code&gt;res.truncated&lt;/code&gt;.</source>
          <target state="translated">返回具有4个插槽的Lua表： &lt;code&gt;res.status&lt;/code&gt; ， &lt;code&gt;res.header&lt;/code&gt; ， &lt;code&gt;res.body&lt;/code&gt; 和 &lt;code&gt;res.truncated&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6489963c7f3c12c55cc2d6c157de70ae5f0443a3" translate="yes" xml:space="preserve">
          <source>Returns a boolean indicating whether the current request is an &quot;internal request&quot;, i.e., a request initiated from inside the current nginx server instead of from the client side.</source>
          <target state="translated">返回一个布尔值,表示当前请求是否为 &quot;内部请求&quot;,即从当前nginx服务器内部而不是客户端发起的请求。</target>
        </trans-unit>
        <trans-unit id="b269c78c1b7cd6403009dda47553c12f28a2316d" translate="yes" xml:space="preserve">
          <source>Returns a floating-point number for the elapsed time in seconds (including milliseconds as the decimal part) from the epoch for the current time stamp from the nginx cached time (no syscall involved unlike Lua's date library).</source>
          <target state="translated">从nginx缓存的时间中,以秒为单位(包括小数点的毫秒)返回从当前时间戳开始的浮点数(与Lua的日期库不同,不涉及syscall)。</target>
        </trans-unit>
        <trans-unit id="970c0e3e93fcd5fa03630d541f0302420dd0c530" translate="yes" xml:space="preserve">
          <source>Returns a floating-point number representing the timestamp (including milliseconds as the decimal part) when the current request was created.</source>
          <target state="translated">返回一个浮点数,表示当前请求创建的时间戳(包括小数部分的毫秒)。</target>
        </trans-unit>
        <trans-unit id="6e939f9d1a13a6ec5c34638a095f34cae89b17fa" translate="yes" xml:space="preserve">
          <source>Returns a formated string can be used as the http header time (for example, being used in &lt;code&gt;Last-Modified&lt;/code&gt; header). The parameter &lt;code&gt;sec&lt;/code&gt; is the time stamp in seconds (like those returned from &lt;a href=&quot;#ngxtime&quot;&gt;ngx.time&lt;/a&gt;).</source>
          <target state="translated">返回一个格式化的字符串可以用作http标头时间（例如，在 &lt;code&gt;Last-Modified&lt;/code&gt; 标头中使用）。参数 &lt;code&gt;sec&lt;/code&gt; 是时间戳（以秒为单位）（如从&lt;a href=&quot;#ngxtime&quot;&gt;ngx.time&lt;/a&gt;返回的时间戳）。</target>
        </trans-unit>
        <trans-unit id="f8a21d801bbbff2c32a8c03686f7cc8440d63e9c" translate="yes" xml:space="preserve">
          <source>Returns a formatted string can be used as the cookie expiration time. The parameter &lt;code&gt;sec&lt;/code&gt; is the time stamp in seconds (like those returned from &lt;a href=&quot;#ngxtime&quot;&gt;ngx.time&lt;/a&gt;).</source>
          <target state="translated">返回一个格式化的字符串可以用作cookie的过期时间。参数 &lt;code&gt;sec&lt;/code&gt; 是时间戳（以秒为单位）（如从&lt;a href=&quot;#ngxtime&quot;&gt;ngx.time&lt;/a&gt;返回的时间戳）。</target>
        </trans-unit>
        <trans-unit id="96edce0da8d313cad3e54cd11d07d7fddcd0d634" translate="yes" xml:space="preserve">
          <source>Returns a quoted SQL string literal according to the MySQL quoting rules.</source>
          <target state="translated">根据MySQL的引号规则,返回一个引用的SQL字符串文字。</target>
        </trans-unit>
        <trans-unit id="89bd906aeb3e1de75d36961d1ad9926e97f384b6" translate="yes" xml:space="preserve">
          <source>Returns a read-only cosocket object that wraps the downstream connection. Only &lt;a href=&quot;#tcpsockreceive&quot;&gt;receive&lt;/a&gt; and &lt;a href=&quot;#tcpsockreceiveuntil&quot;&gt;receiveuntil&lt;/a&gt; methods are supported on this object.</source>
          <target state="translated">返回包装下游连接的只读cosocket对象。只有&lt;a href=&quot;#tcpsockreceive&quot;&gt;接受&lt;/a&gt;和&lt;a href=&quot;#tcpsockreceiveuntil&quot;&gt;receiveuntil&lt;/a&gt;方法都支持这一对象。</target>
        </trans-unit>
        <trans-unit id="7fcd636faf68faa820e159f2dc9f7bed74241fa4" translate="yes" xml:space="preserve">
          <source>Returns current date (in the format &lt;code&gt;yyyy-mm-dd&lt;/code&gt;) from the nginx cached time (no syscall involved unlike Lua's date library).</source>
          <target state="translated">从nginx缓存的时间返回当前日期（格式为 &lt;code&gt;yyyy-mm-dd&lt;/code&gt; ）（与Lua的日期库不同，不涉及任何系统调用）。</target>
        </trans-unit>
        <trans-unit id="42bb76558d8431074a7dbfb8670f6144e761b708" translate="yes" xml:space="preserve">
          <source>Returns the HTTP version number for the current request as a Lua number.</source>
          <target state="translated">将当前请求的HTTP版本号以Lua号的形式返回。</target>
        </trans-unit>
        <trans-unit id="403c8b2d5d9e7467eb6c86d98b0073260edc59c6" translate="yes" xml:space="preserve">
          <source>Returns the Nginx server &quot;prefix&quot; path, as determined by the &lt;code&gt;-p&lt;/code&gt; command-line option when running the nginx executable, or the path specified by the &lt;code&gt;--prefix&lt;/code&gt; command-line option when building Nginx with the &lt;code&gt;./configure&lt;/code&gt; script.</source>
          <target state="translated">返回Nginx服务器的&amp;ldquo;前缀&amp;rdquo;路径，该路径由运行nginx可执行文件时由 &lt;code&gt;-p&lt;/code&gt; 命令行选项确定，或由 &lt;code&gt;./configure&lt;/code&gt; 脚本构建Nginx时由 &lt;code&gt;--prefix&lt;/code&gt; 命令行选项指定的路径。</target>
        </trans-unit>
        <trans-unit id="6a060a226052456afaf5c596a877b6748a20534f" translate="yes" xml:space="preserve">
          <source>Returns the binary form of the MD5 digest of the &lt;code&gt;str&lt;/code&gt; argument.</source>
          <target state="translated">返回 &lt;code&gt;str&lt;/code&gt; 参数的MD5摘要的二进制形式。</target>
        </trans-unit>
        <trans-unit id="8d80be59f107b4adb4580c9748de570c34b0608d" translate="yes" xml:space="preserve">
          <source>Returns the binary form of the SHA-1 digest of the &lt;code&gt;str&lt;/code&gt; argument.</source>
          <target state="translated">返回 &lt;code&gt;str&lt;/code&gt; 参数的SHA-1摘要的二进制形式。</target>
        </trans-unit>
        <trans-unit id="476a8bd45f0b6d8e25bbe845b583596e247e7ad3" translate="yes" xml:space="preserve">
          <source>Returns the current time stamp (in the format &lt;code&gt;yyyy-mm-dd hh:mm:ss&lt;/code&gt;) of the nginx cached time (no syscall involved unlike Lua's &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-os.date&quot;&gt;os.date&lt;/a&gt; function).</source>
          <target state="translated">返回nginx缓存时间的当前时间戳（格式为 &lt;code&gt;yyyy-mm-dd hh:mm:ss&lt;/code&gt; ）（与Lua的&lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-os.date&quot;&gt;os.date&lt;/a&gt;函数不同，不涉及任何系统调用）。</target>
        </trans-unit>
        <trans-unit id="157a2eb1202ffa160d25f94918b1c4a164d3b96f" translate="yes" xml:space="preserve">
          <source>Returns the elapsed seconds from the epoch for the current time stamp from the nginx cached time (no syscall involved unlike Lua's date library).</source>
          <target state="translated">从nginx缓存的时间中返回当前时间戳的历时秒数(与Lua的日期库不同,不涉及syscall)。</target>
        </trans-unit>
        <trans-unit id="545932a89b9ef8da6bf841005f9dc7cba8034004" translate="yes" xml:space="preserve">
          <source>Returns the hexadecimal representation of the MD5 digest of the &lt;code&gt;str&lt;/code&gt; argument.</source>
          <target state="translated">返回 &lt;code&gt;str&lt;/code&gt; 参数的MD5摘要的十六进制表示形式。</target>
        </trans-unit>
        <trans-unit id="ed5caa1afd3047138513d6af2fb65ad6f0d51af7" translate="yes" xml:space="preserve">
          <source>Returns the number of elements in the list named &lt;code&gt;key&lt;/code&gt; in the shm-based dictionary &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;.</source>
          <target state="translated">返回基于shm的字典&lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;中名为 &lt;code&gt;key&lt;/code&gt; 的列表中的元素数。</target>
        </trans-unit>
        <trans-unit id="28a300dd1fdf9810700020eef8ca2c72efe0abcc" translate="yes" xml:space="preserve">
          <source>Returns the number of pending timers.</source>
          <target state="translated">Returns the number of pending timers.</target>
        </trans-unit>
        <trans-unit id="4fe28109030903092b18e45017b8f08d0c9ad10b" translate="yes" xml:space="preserve">
          <source>Returns the number of timers currently running.</source>
          <target state="translated">返回当前运行的定时器数量。</target>
        </trans-unit>
        <trans-unit id="9f9d6b656b44c4a995683bdb751d649b7b013e6d" translate="yes" xml:space="preserve">
          <source>Returns the ordinal number of the current Nginx worker processes (starting from number 0).</source>
          <target state="translated">返回当前Nginx工作进程的序数(从0开始)。</target>
        </trans-unit>
        <trans-unit id="beb66aad2eb5befae8267d63ce75ee603e07df27" translate="yes" xml:space="preserve">
          <source>Returns the original raw HTTP protocol header received by the Nginx server.</source>
          <target state="translated">返回Nginx服务器收到的原始HTTP协议头。</target>
        </trans-unit>
        <trans-unit id="7bc2bb362672c906aa0961a72569d5656909009f" translate="yes" xml:space="preserve">
          <source>Returns the total number of the Nginx worker processes (i.e., the value configured by the &lt;a href=&quot;http://nginx.org/en/docs/ngx_core_module.html#worker_processes&quot;&gt;worker_processes&lt;/a&gt; directive in &lt;code&gt;nginx.conf&lt;/code&gt;).</source>
          <target state="translated">返回Nginx工作进程的总数（即， &lt;code&gt;nginx.conf&lt;/code&gt; 中&lt;a href=&quot;http://nginx.org/en/docs/ngx_core_module.html#worker_processes&quot;&gt;worker_processes&lt;/a&gt;指令配置的值）。</target>
        </trans-unit>
        <trans-unit id="7aa1ee19879e7de344e8f22603276950ed7e49c0" translate="yes" xml:space="preserve">
          <source>Rewrite the current request's (parsed) URI by the &lt;code&gt;uri&lt;/code&gt; argument. The &lt;code&gt;uri&lt;/code&gt; argument must be a Lua string and cannot be of zero length, or a Lua exception will be thrown.</source>
          <target state="translated">通过 &lt;code&gt;uri&lt;/code&gt; 参数重写当前请求的（解析的）URI 。该 &lt;code&gt;uri&lt;/code&gt; 参数必须是一个Lua字符串，不能是零长度的，或者Lua的会抛出异常。</target>
        </trans-unit>
        <trans-unit id="39b17f0d374cfe5d72d4ff1b2ee43be76e7ca56c" translate="yes" xml:space="preserve">
          <source>Rewrite the current request's URI query arguments by the &lt;code&gt;args&lt;/code&gt; argument. The &lt;code&gt;args&lt;/code&gt; argument can be either a Lua string, as in</source>
          <target state="translated">用 &lt;code&gt;args&lt;/code&gt; 参数重写当前请求的URI查询参数。该 &lt;code&gt;args&lt;/code&gt; 参数可以是一个Lua字符串，如</target>
        </trans-unit>
        <trans-unit id="5b587e23f197991b79042b02ce0b9d60ebb29395" translate="yes" xml:space="preserve">
          <source>Routing requests to different MySQL queries based on URI arguments</source>
          <target state="translated">根据URI参数将请求路由到不同的MySQL查询。</target>
        </trans-unit>
        <trans-unit id="dd292a68064649a81389c8cea44291986d194658" translate="yes" xml:space="preserve">
          <source>Running timers are those timers whose user callback functions are still running.</source>
          <target state="translated">运行中的定时器是指那些用户回调函数仍在运行的定时器。</target>
        </trans-unit>
        <trans-unit id="8df570188e1e9e7d32495c4425153a43e5ecce7a" translate="yes" xml:space="preserve">
          <source>Runs the Lua code specified by the argument &lt;code&gt;&amp;lt;lua-script-str&amp;gt;&lt;/code&gt; on the global Lua VM level when the Nginx master process (if any) is loading the Nginx config file.</source>
          <target state="translated">Nginx主进程（如果有）正在加载Nginx配置文件时，在全局Lua VM级别上运行由参数 &lt;code&gt;&amp;lt;lua-script-str&amp;gt;&lt;/code&gt; 指定的Lua代码。</target>
        </trans-unit>
        <trans-unit id="52bfa9ac70fafbe5e95cf2f3ca0adb75d43637ce" translate="yes" xml:space="preserve">
          <source>Runs the Lua source code inlined as the &lt;code&gt;&amp;lt;lua-script-str&amp;gt;&lt;/code&gt; at the &lt;code&gt;log&lt;/code&gt; request processing phase. This does not replace the current access logs, but runs before.</source>
          <target state="translated">在 &lt;code&gt;log&lt;/code&gt; 请求处理阶段运行内联为 &lt;code&gt;&amp;lt;lua-script-str&amp;gt;&lt;/code&gt; 的Lua源代码。这不会替代当前的访问日志，但会先运行。</target>
        </trans-unit>
        <trans-unit id="515e3ea1e714875e6451c14596d62cbe57ce2a49" translate="yes" xml:space="preserve">
          <source>Runs the specified Lua code upon every Nginx worker process's startup when the master process is enabled. When the master process is disabled, this hook will just run after &lt;a href=&quot;#init_by_lua&quot;&gt;init_by_lua*&lt;/a&gt;.</source>
          <target state="translated">启用主进程后，在每次Nginx工作进程启动时运行指定的Lua代码。当禁用主进程时，此挂钩将仅在&lt;a href=&quot;#init_by_lua&quot;&gt;init_by_lua *&lt;/a&gt;之后运行。</target>
        </trans-unit>
        <trans-unit id="0af2845c0ccfd1f36ef60c96c2fad57a92866e1a" translate="yes" xml:space="preserve">
          <source>SPDY Mode Not Fully Supported</source>
          <target state="translated">不完全支持SPDY模式</target>
        </trans-unit>
        <trans-unit id="a3a47e36cf4694f35a4b7451fec0b46717814fb4" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#ngxmd5&quot;&gt;ngx.md5&lt;/a&gt; if the hexadecimal form of the MD5 digest is required.</source>
          <target state="translated">如果需要MD5摘要的十六进制形式，请参见&lt;a href=&quot;#ngxmd5&quot;&gt;ngx.md5&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eef82d82f464f5a9fe30589ff1c94456bb039186" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#ngxmd5_bin&quot;&gt;ngx.md5_bin&lt;/a&gt; if the raw binary MD5 digest is required.</source>
          <target state="translated">如果需要原始二进制MD5摘要，请参见&lt;a href=&quot;#ngxmd5_bin&quot;&gt;ngx.md5_bin&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6fae2903153d69841475f775001109f4bf560390" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt; for details.</source>
          <target state="translated">有关详细信息，请参见&lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="67373bb92cd7ecbf243edb9d60ad6f00f86a6052" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">另见</target>
        </trans-unit>
        <trans-unit id="ec3543143cf938a72d8e6052db22e41b01131ab8" translate="yes" xml:space="preserve">
          <source>See HTTP method constants methods other than POST. The &lt;code&gt;method&lt;/code&gt; option is &lt;code&gt;ngx.HTTP_GET&lt;/code&gt; by default.</source>
          <target state="translated">请参阅POST以外的HTTP方法常量方法。默认情况下， &lt;code&gt;method&lt;/code&gt; 选项为 &lt;code&gt;ngx.HTTP_GET&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e345d32569874cd7cd49f8f33fc8637285761c91" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#lua_check_client_abort&quot;&gt;lua_check_client_abort&lt;/a&gt;.</source>
          <target state="translated">另请参见&lt;a href=&quot;#lua_check_client_abort&quot;&gt;lua_check_client_abort&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0ec3dc88d3806c090d67871fab327c3a6b2c7de8" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#lua_ssl_trusted_certificate&quot;&gt;lua_ssl_trusted_certificate&lt;/a&gt;.</source>
          <target state="translated">另请参见&lt;a href=&quot;#lua_ssl_trusted_certificate&quot;&gt;lua_ssl_trusted_certificate&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d79fef6aaf4b991d3e3aa4937d102c6f07b12922" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#lua_ssl_verify_depth&quot;&gt;lua_ssl_verify_depth&lt;/a&gt;.</source>
          <target state="translated">另请参见&lt;a href=&quot;#lua_ssl_verify_depth&quot;&gt;lua_ssl_verify_depth&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d5eefa6fcf5ee5fd35ceffd7e7d975e40a2a7007" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#ngxnow&quot;&gt;ngx.now&lt;/a&gt; and &lt;a href=&quot;#ngxupdate_time&quot;&gt;ngx.update_time&lt;/a&gt;.</source>
          <target state="translated">另请参见&lt;a href=&quot;#ngxnow&quot;&gt;ngx.now&lt;/a&gt;和&lt;a href=&quot;#ngxupdate_time&quot;&gt;ngx.update_time&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a3a3fe01b6cccd2e2c86c16be4a17959b6c2f555" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#ngxon_abort&quot;&gt;ngx.on_abort&lt;/a&gt;.</source>
          <target state="translated">另请参见&lt;a href=&quot;#ngxon_abort&quot;&gt;ngx.on_abort&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="934e46ccc7dccb7e5bbb4290efa4e99ca48a2796" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#ngxreqget_body_data&quot;&gt;ngx.req.get_body_data&lt;/a&gt;.</source>
          <target state="translated">另请参见&lt;a href=&quot;#ngxreqget_body_data&quot;&gt;ngx.req.get_body_data&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8d88e616c712ce83343b401831b4b91a480cba10" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#ngxreqget_body_file&quot;&gt;ngx.req.get_body_file&lt;/a&gt;.</source>
          <target state="translated">另请参见&lt;a href=&quot;#ngxreqget_body_file&quot;&gt;ngx.req.get_body_file&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a73d3f34e603a6a8ac148ae45dcb9a278ab03c5a" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#ngxreqget_method&quot;&gt;ngx.req.get_method&lt;/a&gt;.</source>
          <target state="translated">另请参见&lt;a href=&quot;#ngxreqget_method&quot;&gt;ngx.req.get_method&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c47171e0bb3dc918ff13173ddcbefb4e7bdf59c8" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#ngxreqinit_body&quot;&gt;ngx.req.init_body&lt;/a&gt;.</source>
          <target state="translated">另请参见&lt;a href=&quot;#ngxreqinit_body&quot;&gt;ngx.req.init_body&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2ccf86f490aaf3621ecd1e207f0d36160f655ede" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#ngxreqread_body&quot;&gt;ngx.req.read_body&lt;/a&gt;.</source>
          <target state="translated">另请参见&lt;a href=&quot;#ngxreqread_body&quot;&gt;ngx.req.read_body&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="32163a097898c33d6ae51800b03dfa1cf332fcc0" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#ngxreqset_body_data&quot;&gt;ngx.req.set_body_data&lt;/a&gt;.</source>
          <target state="translated">另请参见&lt;a href=&quot;#ngxreqset_body_data&quot;&gt;ngx.req.set_body_data&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f79f2058c20da3fc9b7cc4453c786aa9e53eb3c9" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#ngxreqset_body_file&quot;&gt;ngx.req.set_body_file&lt;/a&gt;.</source>
          <target state="translated">另请参见&lt;a href=&quot;#ngxreqset_body_file&quot;&gt;ngx.req.set_body_file&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9576565dde43fb3241c120689c95894ffa624d74" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#ngxreqset_method&quot;&gt;ngx.req.set_method&lt;/a&gt;.</source>
          <target state="translated">另请参见&lt;a href=&quot;#ngxreqset_method&quot;&gt;ngx.req.set_method&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c3945d36dd3f22526c9e8aee25d8265903858c74" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#ngxreqset_uri&quot;&gt;ngx.req.set_uri&lt;/a&gt;.</source>
          <target state="translated">另请参见&lt;a href=&quot;#ngxreqset_uri&quot;&gt;ngx.req.set_uri&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a5a6b362ef9870bf7e9ec536751e38ce7fc8cec7" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;.</source>
          <target state="translated">另请参见&lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7ea34ffb7fb4f19b4bde478f22596931a0fa56e8" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#ngxshareddictflush_all&quot;&gt;ngx.shared.DICT.flush_all&lt;/a&gt; and &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;.</source>
          <target state="translated">另请参见&lt;a href=&quot;#ngxshareddictflush_all&quot;&gt;ngx.shared.DICT.flush_all&lt;/a&gt;和&lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c05c95f357635fdc590dfa33ec4b7bbe2bde5258" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#ngxshareddictflush_expired&quot;&gt;ngx.shared.DICT.flush_expired&lt;/a&gt; and &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;.</source>
          <target state="translated">另请参见&lt;a href=&quot;#ngxshareddictflush_expired&quot;&gt;ngx.shared.DICT.flush_expired&lt;/a&gt;和&lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0b271bcc6dc7b053378c7235950927663e242366" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#ngxsockettcp&quot;&gt;ngx.socket.tcp&lt;/a&gt;.</source>
          <target state="translated">另请参见&lt;a href=&quot;#ngxsockettcp&quot;&gt;ngx.socket.tcp&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a74c6b8991d5b35e6672fab1c27f924182eb4337" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#ngxsocketudp&quot;&gt;ngx.socket.udp&lt;/a&gt;.</source>
          <target state="translated">另请参见&lt;a href=&quot;#ngxsocketudp&quot;&gt;ngx.socket.udp&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f1276a6aef3ae13e5500847888cf85e3be28188e" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#ngxworkercount&quot;&gt;ngx.worker.count&lt;/a&gt;.</source>
          <target state="translated">另请参见&lt;a href=&quot;#ngxworkercount&quot;&gt;ngx.worker.count&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d0e9428321dad862d14c7e8ad23143add2401c83" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;https://github.com/openresty/lua-nginx-module/blob/master/util/build.sh&quot;&gt;developer build script&lt;/a&gt; for more details on setting up the testing environment.</source>
          <target state="translated">另请参阅&lt;a href=&quot;https://github.com/openresty/lua-nginx-module/blob/master/util/build.sh&quot;&gt;开发人员构建脚本，&lt;/a&gt;以获取有关设置测试环境的更多详细信息。</target>
        </trans-unit>
        <trans-unit id="692ad6aa11fd3b3b9e6517d7195b2a9d307acc98" translate="yes" xml:space="preserve">
          <source>See more complicated examples in the &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md&quot;&gt;ngx.ssl&lt;/a&gt; and &lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ocsp.md&quot;&gt;ngx.ocsp&lt;/a&gt; Lua modules' official documentation.</source>
          <target state="translated">请参阅&lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md&quot;&gt;ngx.ssl&lt;/a&gt;和&lt;a href=&quot;https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ocsp.md&quot;&gt;ngx.ocsp&lt;/a&gt; Lua模块的官方文档中的更复杂的示例。</target>
        </trans-unit>
        <trans-unit id="a83727ae0d0a7d9d54f2888b06e1142f19e5fb17" translate="yes" xml:space="preserve">
          <source>Sends data on the current UDP or datagram unix domain socket object.</source>
          <target state="translated">在当前UDP或数据报unix域套接字对象上发送数据。</target>
        </trans-unit>
        <trans-unit id="a85a7cc27a9d5c7ca3e22eb9352f9f6dd0c9c642" translate="yes" xml:space="preserve">
          <source>Sends data without blocking on the current TCP or Unix Domain Socket connection.</source>
          <target state="translated">在当前的TCP或Unix域套接字连接上发送数据而不被阻塞。</target>
        </trans-unit>
        <trans-unit id="1c63d1469310416c5d60b8ab014836f11900c1a5" translate="yes" xml:space="preserve">
          <source>Set the current request's request body using the in-file data specified by the &lt;code&gt;file_name&lt;/code&gt; argument.</source>
          <target state="translated">使用 &lt;code&gt;file_name&lt;/code&gt; 参数指定的文件内数据设置当前请求的请求正文。</target>
        </trans-unit>
        <trans-unit id="ba87be315635af39fe5d5147fe5286585b9f004d" translate="yes" xml:space="preserve">
          <source>Set the current request's request body using the in-memory data specified by the &lt;code&gt;data&lt;/code&gt; argument.</source>
          <target state="translated">使用 &lt;code&gt;data&lt;/code&gt; 参数指定的内存数据设置当前请求的请求主体。</target>
        </trans-unit>
        <trans-unit id="4fd302d8c5b915c6d978c73a7b7ddf254c8cd2dc" translate="yes" xml:space="preserve">
          <source>Set the current request's request header named &lt;code&gt;header_name&lt;/code&gt; to value &lt;code&gt;header_value&lt;/code&gt;, overriding any existing ones.</source>
          <target state="translated">将当前请求的名为 &lt;code&gt;header_name&lt;/code&gt; 的请求标头设置为value &lt;code&gt;header_value&lt;/code&gt; ，以覆盖任何现有的标头。</target>
        </trans-unit>
        <trans-unit id="636c214144f38969dedd2ffc5984f1e66f891c5a" translate="yes" xml:space="preserve">
          <source>Set the timeout value in milliseconds for subsequent socket operations (&lt;a href=&quot;#tcpsockconnect&quot;&gt;connect&lt;/a&gt;, &lt;a href=&quot;#tcpsockreceive&quot;&gt;receive&lt;/a&gt;, and iterators returned from &lt;a href=&quot;#tcpsockreceiveuntil&quot;&gt;receiveuntil&lt;/a&gt;).</source>
          <target state="translated">设置后续套接字操作（从&lt;a href=&quot;#tcpsockreceiveuntil&quot;&gt;receiveuntil&lt;/a&gt;返回的&lt;a href=&quot;#tcpsockconnect&quot;&gt;connect&lt;/a&gt;，&lt;a href=&quot;#tcpsockreceive&quot;&gt;receive&lt;/a&gt;和iterator ）的超时值（以毫秒为单位）。</target>
        </trans-unit>
        <trans-unit id="050807acbb87dbae3d4b4a4b61e052706ebb33f2" translate="yes" xml:space="preserve">
          <source>Set the timeout value in milliseconds for subsequent socket operations (like &lt;a href=&quot;#udpsockreceive&quot;&gt;receive&lt;/a&gt;).</source>
          <target state="translated">为后续套接字操作（如&lt;a href=&quot;#udpsockreceive&quot;&gt;receive&lt;/a&gt;）设置超时值（以毫秒为单位）。</target>
        </trans-unit>
        <trans-unit id="b47cf55d380702ebb107e003eb19235c4bb7f46e" translate="yes" xml:space="preserve">
          <source>Set, add to, or clear the current request's &lt;code&gt;HEADER&lt;/code&gt; response header that is to be sent.</source>
          <target state="translated">设置，添加或清除要发送的当前请求的 &lt;code&gt;HEADER&lt;/code&gt; 响应标头。</target>
        </trans-unit>
        <trans-unit id="2f17b4c675aba6498a00ebdd768065cc262c8dae" translate="yes" xml:space="preserve">
          <source>Sets the Lua C-module search path used by scripts specified by &lt;a href=&quot;#set_by_lua&quot;&gt;set_by_lua&lt;/a&gt;, &lt;a href=&quot;#content_by_lua&quot;&gt;content_by_lua&lt;/a&gt; and others. The cpath string is in standard Lua cpath form, and &lt;code&gt;;;&lt;/code&gt; can be used to stand for the original cpath.</source>
          <target state="translated">设置由&lt;a href=&quot;#set_by_lua&quot;&gt;set_by_lua&lt;/a&gt;，&lt;a href=&quot;#content_by_lua&quot;&gt;content_by_lua&lt;/a&gt;等指定的脚本使用的Lua C模块搜索路径。cpath字符串采用标准的Lua cpath格式，并且 &lt;code&gt;;;&lt;/code&gt; 可以用来代表原始的cpath。</target>
        </trans-unit>
        <trans-unit id="65713b479cd4156889a979ede6dd60d9817fe4da" translate="yes" xml:space="preserve">
          <source>Sets the Lua module search path used by scripts specified by &lt;a href=&quot;#set_by_lua&quot;&gt;set_by_lua&lt;/a&gt;, &lt;a href=&quot;#content_by_lua&quot;&gt;content_by_lua&lt;/a&gt; and others. The path string is in standard Lua path form, and &lt;code&gt;;;&lt;/code&gt; can be used to stand for the original search paths.</source>
          <target state="translated">设置由&lt;a href=&quot;#set_by_lua&quot;&gt;set_by_lua&lt;/a&gt;，&lt;a href=&quot;#content_by_lua&quot;&gt;content_by_lua&lt;/a&gt;等指定的脚本使用的Lua模块搜索路径。路径字符串采用标准Lua路径格式，并且 &lt;code&gt;;;&lt;/code&gt; 可用于代表原始搜索路径。</target>
        </trans-unit>
        <trans-unit id="1a16dfe9c7ec23027f4f4bd2de82f7121596ba40" translate="yes" xml:space="preserve">
          <source>Sets the connect timeout thresold, send timeout threshold, and read timeout threshold, respetively, in milliseconds, for subsequent socket operations (&lt;a href=&quot;#tcpsockconnect&quot;&gt;connect&lt;/a&gt;, &lt;a href=&quot;#tcpsocksend&quot;&gt;send&lt;/a&gt;, &lt;a href=&quot;#tcpsockreceive&quot;&gt;receive&lt;/a&gt;, and iterators returned from &lt;a href=&quot;#tcpsockreceiveuntil&quot;&gt;receiveuntil&lt;/a&gt;).</source>
          <target state="translated">设置连接超时阈值，发送超时阈值和读取超时阈值（以毫秒为单位），以重复方式（以毫秒为单位），用于后续的套接字操作（从&lt;a href=&quot;#tcpsockreceiveuntil&quot;&gt;receiveuntil&lt;/a&gt;返回的&lt;a href=&quot;#tcpsockconnect&quot;&gt;connect&lt;/a&gt;，&lt;a href=&quot;#tcpsocksend&quot;&gt;send&lt;/a&gt;，&lt;a href=&quot;#tcpsockreceive&quot;&gt;receive&lt;/a&gt;和iterators ）。</target>
        </trans-unit>
        <trans-unit id="22a4dd0a7b6a7ae8197af61e0d710e42f59a2001" translate="yes" xml:space="preserve">
          <source>Sets the verification depth in the server certificates chain.</source>
          <target state="translated">设置服务器证书链的验证深度。</target>
        </trans-unit>
        <trans-unit id="aef77a28e560cf0675044563dd256ae04ef39ade" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;ngx.header.HEADER&lt;/code&gt; after sending out response headers (either explicitly with &lt;a href=&quot;#ngxsend_headers&quot;&gt;ngx.send_headers&lt;/a&gt; or implicitly with &lt;a href=&quot;#ngxprint&quot;&gt;ngx.print&lt;/a&gt; and similar) will log an error message.</source>
          <target state="translated">发送响应标头后设置 &lt;code&gt;ngx.header.HEADER&lt;/code&gt; （显式使用&lt;a href=&quot;#ngxsend_headers&quot;&gt;ngx.send_headers&lt;/a&gt;或隐式使用&lt;a href=&quot;#ngxprint&quot;&gt;ngx.print&lt;/a&gt;等）将记录一条错误消息。</target>
        </trans-unit>
        <trans-unit id="585e1dfd9fedfbc89bd4a642247594d8bd2af8df" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;ngx.status&lt;/code&gt; after the response header is sent out has no effect but leaving an error message in your nginx's error log file:</source>
          <target state="translated">发送响应头后设置 &lt;code&gt;ngx.status&lt;/code&gt; 无效，但会在nginx的错误日志文件中留下错误消息：</target>
        </trans-unit>
        <trans-unit id="030efca69708d382204ed9b58dc59503f3c9f6da" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;ngx.var.Foo&lt;/code&gt; to a &lt;code&gt;nil&lt;/code&gt; value will unset the &lt;code&gt;$Foo&lt;/code&gt; Nginx variable.</source>
          <target state="translated">将 &lt;code&gt;ngx.var.Foo&lt;/code&gt; 设置为 &lt;code&gt;nil&lt;/code&gt; 值将取消设置 &lt;code&gt;$Foo&lt;/code&gt; Nginx变量。</target>
        </trans-unit>
        <trans-unit id="136da51c35a70d22f5c9f2da1806b476b0e0637d" translate="yes" xml:space="preserve">
          <source>Setting a slot to &lt;code&gt;nil&lt;/code&gt; effectively removes it from the response headers:</source>
          <target state="translated">将插槽设置​​为 &lt;code&gt;nil&lt;/code&gt; 可以有效地将其从响应头中删除：</target>
        </trans-unit>
        <trans-unit id="0474ce3665f81a13c0c0317c30a63299c88afa56" translate="yes" xml:space="preserve">
          <source>Settings done by this method takes priority over those config directives, i.e., &lt;a href=&quot;#lua_socket_connect_timeout&quot;&gt;lua_socket_connect_timeout&lt;/a&gt;, &lt;a href=&quot;#lua_socket_send_timeout&quot;&gt;lua_socket_send_timeout&lt;/a&gt;, and &lt;a href=&quot;#lua_socket_read_timeout&quot;&gt;lua_socket_read_timeout&lt;/a&gt;.</source>
          <target state="translated">通过此方法完成的设置优先于那些配置指令，即&lt;a href=&quot;#lua_socket_connect_timeout&quot;&gt;lua_socket_connect_timeout&lt;/a&gt;，&lt;a href=&quot;#lua_socket_send_timeout&quot;&gt;lua_socket_send_timeout&lt;/a&gt;和&lt;a href=&quot;#lua_socket_read_timeout&quot;&gt;lua_socket_read_timeout&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="af3ffc082840108afe2affe27bbfa4480aa1fbdb" translate="yes" xml:space="preserve">
          <source>Settings done by this method takes priority over those config directives, like &lt;a href=&quot;#lua_socket_read_timeout&quot;&gt;lua_socket_read_timeout&lt;/a&gt;.</source>
          <target state="translated">通过此方法完成的设置优先于那些配置指令，例如&lt;a href=&quot;#lua_socket_read_timeout&quot;&gt;lua_socket_read_timeout&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="33524ec2b1f90de10e615bf443fd29b98ed89e54" translate="yes" xml:space="preserve">
          <source>Shared Dictionary API: &lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;.</source>
          <target state="translated">共享字典API：&lt;a href=&quot;#ngxshareddict&quot;&gt;ngx.shared.DICT&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="978370756c27086eefc8b044220e251e54341fe2" translate="yes" xml:space="preserve">
          <source>Shared memory zones are always shared by all the nginx worker processes in the current nginx server instance.</source>
          <target state="translated">共享内存区总是由当前nginx服务器实例中的所有nginx工作进程共享。</target>
        </trans-unit>
        <trans-unit id="c59523c52a912196171b23d4cad823b478a16a54" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#init_worker_by_lua&quot;&gt;init_worker_by_lua&lt;/a&gt;, but accepts the file path to a Lua source file or Lua bytecode file.</source>
          <target state="translated">与&lt;a href=&quot;#init_worker_by_lua&quot;&gt;init_worker_by_lua&lt;/a&gt;相似，但是接受Lua源文件或Lua字节码文件的文件路径。</target>
        </trans-unit>
        <trans-unit id="7cb0d398e5b4c38a10c3d6949f67c9b285d8688c" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#ngxrematch&quot;&gt;ngx.re.match&lt;/a&gt; but only returns the beginning index (&lt;code&gt;from&lt;/code&gt;) and end index (&lt;code&gt;to&lt;/code&gt;) of the matched substring. The returned indexes are 1-based and can be fed directly into the &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-string.sub&quot;&gt;string.sub&lt;/a&gt; API function to obtain the matched substring.</source>
          <target state="translated">与&lt;a href=&quot;#ngxrematch&quot;&gt;ngx.re.match&lt;/a&gt;类似，但只返回匹配子字符串的开始索引（ &lt;code&gt;from&lt;/code&gt; ）和结束索引（ &lt;code&gt;to&lt;/code&gt; ）。返回的索引基于1，可以直接馈入&lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-string.sub&quot;&gt;string.sub&lt;/a&gt; API函数以获得匹配的子字符串。</target>
        </trans-unit>
        <trans-unit id="352a600c32c28300072d08110bbef4ac25e0a611" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#ngxrematch&quot;&gt;ngx.re.match&lt;/a&gt;, but returns a Lua iterator instead, so as to let the user programmer iterate all the matches over the &lt;code&gt;&amp;lt;subject&amp;gt;&lt;/code&gt; string argument with the PCRE &lt;code&gt;regex&lt;/code&gt;.</source>
          <target state="translated">与&lt;a href=&quot;#ngxrematch&quot;&gt;ngx.re.match&lt;/a&gt;相似，但是返回一个Lua迭代器，以便用户程序员使用PCRE &lt;code&gt;regex&lt;/code&gt; 迭代 &lt;code&gt;&amp;lt;subject&amp;gt;&lt;/code&gt; 字符串参数上的所有匹配项。</target>
        </trans-unit>
        <trans-unit id="f23aa11625fd22fc42eb57660368c3d212c61e77" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua&lt;/a&gt; directive except that this directive inlines the Lua source directly inside a pair of curly braces (&lt;code&gt;{}&lt;/code&gt;) instead of in an NGINX string literal (which requires special character escaping).</source>
          <target state="translated">类似于&lt;a href=&quot;#access_by_lua&quot;&gt;access_by_lua&lt;/a&gt;指令，不同之处在于该指令直接在一对大括号（ &lt;code&gt;{}&lt;/code&gt; ）内而不是在NGINX字符串文字中内联Lua源（这需要特殊的字符转义）。</target>
        </trans-unit>
        <trans-unit id="b9f9c8b7047281b88288552c8203c823d4cb95a8" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#body_filter_by_lua&quot;&gt;body_filter_by_lua&lt;/a&gt; directive except that this directive inlines the Lua source directly inside a pair of curly braces (&lt;code&gt;{}&lt;/code&gt;) instead of in an NGINX string literal (which requires special character escaping).</source>
          <target state="translated">类似于&lt;a href=&quot;#body_filter_by_lua&quot;&gt;body_filter_by_lua&lt;/a&gt;指令，不同之处在于此指令直接在一对花括号（ &lt;code&gt;{}&lt;/code&gt; ）内而不是在NGINX字符串文字中（需要特殊的字符转义）内嵌Lua源。</target>
        </trans-unit>
        <trans-unit id="da2af6a416ef6224c9dbeb9a5f048a3c91bed8d5" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#content_by_lua&quot;&gt;content_by_lua&lt;/a&gt; directive except that this directive inlines the Lua source directly inside a pair of curly braces (&lt;code&gt;{}&lt;/code&gt;) instead of in an NGINX string literal (which requires special character escaping).</source>
          <target state="translated">与&lt;a href=&quot;#content_by_lua&quot;&gt;content_by_lua&lt;/a&gt;指令相似，不同之处在于此指令直接在一对花括号（ &lt;code&gt;{}&lt;/code&gt; ）内而不是在NGINX字符串文字（需要特殊字符转义）中内嵌Lua源。</target>
        </trans-unit>
        <trans-unit id="1534b9f8e714c53e1c6552d9988831a5057ffcc0" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#header_filter_by_lua&quot;&gt;header_filter_by_lua&lt;/a&gt; directive except that this directive inlines the Lua source directly inside a pair of curly braces (&lt;code&gt;{}&lt;/code&gt;) instead of in an NGINX string literal (which requires special character escaping).</source>
          <target state="translated">类似于&lt;a href=&quot;#header_filter_by_lua&quot;&gt;header_filter_by_lua&lt;/a&gt;指令，不同之处在于此指令直接在一对花括号（ &lt;code&gt;{}&lt;/code&gt; ）内而不是在NGINX字符串文字（需要特殊字符转义）中内嵌Lua源。</target>
        </trans-unit>
        <trans-unit id="6d0b1e19fad18cc093c0598a66b0ed44c3571a23" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#init_by_lua&quot;&gt;init_by_lua&lt;/a&gt; directive except that this directive inlines the Lua source directly inside a pair of curly braces (&lt;code&gt;{}&lt;/code&gt;) instead of in an NGINX string literal (which requires special character escaping).</source>
          <target state="translated">与&lt;a href=&quot;#init_by_lua&quot;&gt;init_by_lua&lt;/a&gt;指令相似，不同之处在于此指令直接在一对花括号（ &lt;code&gt;{}&lt;/code&gt; ）内而不是在NGINX字符串文字（需要特殊字符转义）中内嵌Lua源。</target>
        </trans-unit>
        <trans-unit id="0f46807ac6663e79087fc054f4d06773e5b26953" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#init_worker_by_lua&quot;&gt;init_worker_by_lua&lt;/a&gt; directive except that this directive inlines the Lua source directly inside a pair of curly braces (&lt;code&gt;{}&lt;/code&gt;) instead of in an NGINX string literal (which requires special character escaping).</source>
          <target state="translated">与&lt;a href=&quot;#init_worker_by_lua&quot;&gt;init_worker_by_lua&lt;/a&gt;指令相似，不同之处在于此指令直接在一对花括号（ &lt;code&gt;{}&lt;/code&gt; ）内而不是在NGINX字符串文字（需要特殊的字符转义）中内嵌Lua源。</target>
        </trans-unit>
        <trans-unit id="d764510b028caf7dbb6236194ab485eb58d561d9" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#log_by_lua&quot;&gt;log_by_lua&lt;/a&gt; directive except that this directive inlines the Lua source directly inside a pair of curly braces (&lt;code&gt;{}&lt;/code&gt;) instead of in an NGINX string literal (which requires special character escaping).</source>
          <target state="translated">与&lt;a href=&quot;#log_by_lua&quot;&gt;log_by_lua&lt;/a&gt;指令相似，除了此指令直接在一对花括号（ &lt;code&gt;{}&lt;/code&gt; ）内而不是在NGINX字符串文字（需要特殊字符转义）中内嵌Lua源。</target>
        </trans-unit>
        <trans-unit id="4a11cf1071908be1221383ad564822cd5112a94e" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#ngxshareddictadd&quot;&gt;add&lt;/a&gt; method, but never overrides the (least recently used) unexpired items in the store when running out of storage in the shared memory zone. In this case, it will immediately return &lt;code&gt;nil&lt;/code&gt; and the string &quot;no memory&quot;.</source>
          <target state="translated">与&lt;a href=&quot;#ngxshareddictadd&quot;&gt;add&lt;/a&gt;方法类似，但是在共享内存区域中的存储空间用完时，永远不会覆盖存储中（最近使用最少的）未过期项目。在这种情况下，它将立即返回 &lt;code&gt;nil&lt;/code&gt; 和字符串&amp;ldquo; no memory&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="24da4f86bb8bcf68219097c2b33b59976391a4e9" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#ngxshareddictget&quot;&gt;get&lt;/a&gt; method but returns the value even if the key has already expired.</source>
          <target state="translated">与&lt;a href=&quot;#ngxshareddictget&quot;&gt;get&lt;/a&gt;方法类似，但是即使键已过期也返回值。</target>
        </trans-unit>
        <trans-unit id="a3b8ec56fa3211c0ef45499f18c8bd4233344761" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#ngxshareddictlpush&quot;&gt;lpush&lt;/a&gt; method, but inserts the specified (numerical or string) &lt;code&gt;value&lt;/code&gt; at the tail of the list named &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">与&lt;a href=&quot;#ngxshareddictlpush&quot;&gt;lpush&lt;/a&gt;方法类似，但是将指定的（数字或字符串） &lt;code&gt;value&lt;/code&gt; 插入名为 &lt;code&gt;key&lt;/code&gt; 的列表的末尾。</target>
        </trans-unit>
        <trans-unit id="0f1dbca90508a765c7da8efb048130eaba083847" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#ngxshareddictset&quot;&gt;set&lt;/a&gt; method, but never overrides the (least recently used) unexpired items in the store when running out of storage in the shared memory zone. In this case, it will immediately return &lt;code&gt;nil&lt;/code&gt; and the string &quot;no memory&quot;.</source>
          <target state="translated">与&lt;a href=&quot;#ngxshareddictset&quot;&gt;set&lt;/a&gt;方法类似，但是在共享内存区域中的存储空间用完时，永远不会覆盖存储中（最近使用最少的）未过期项目。在这种情况下，它将立即返回 &lt;code&gt;nil&lt;/code&gt; 和字符串&amp;ldquo; no memory&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="cffee42d93390d67edfdba089f1bb41c9b691ea0" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#ngxtimerat&quot;&gt;ngx.timer.at&lt;/a&gt; API function, but</source>
          <target state="translated">与&lt;a href=&quot;#ngxtimerat&quot;&gt;ngx.timer.at&lt;/a&gt; API函数类似，但</target>
        </trans-unit>
        <trans-unit id="65ef3fa553ce62ea7392a739609026bb7ca06475" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt; directive except that this directive inlines the Lua source directly inside a pair of curly braces (&lt;code&gt;{}&lt;/code&gt;) instead of in an NGINX string literal (which requires special character escaping).</source>
          <target state="translated">类似于&lt;a href=&quot;#rewrite_by_lua&quot;&gt;rewrite_by_lua&lt;/a&gt;指令，不同之处在于该指令直接在一对花括号（ &lt;code&gt;{}&lt;/code&gt; ）内而不是在NGINX字符串文字中内联Lua源（这需要特殊的字符转义）。</target>
        </trans-unit>
        <trans-unit id="0cb7d3acef2ccff8f98e4ce7fb079207bcab4918" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#set_by_lua&quot;&gt;set_by_lua&lt;/a&gt; directive except that</source>
          <target state="translated">与&lt;a href=&quot;#set_by_lua&quot;&gt;set_by_lua&lt;/a&gt;指令类似，除了</target>
        </trans-unit>
        <trans-unit id="fd19f212fee4e1f793bdebc71c579667c1d9ffed" translate="yes" xml:space="preserve">
          <source>Similar to the standard Lua &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.create&quot;&gt;coroutine.create&lt;/a&gt; API, but works in the context of the Lua coroutines created by ngx_lua.</source>
          <target state="translated">与标准Lua &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.create&quot;&gt;coroutine.create&lt;/a&gt; API 相似，但在ngx_lua创建的Lua协程的上下文中工作。</target>
        </trans-unit>
        <trans-unit id="abeec72461dbd86196a2df49e71ede29e7798178" translate="yes" xml:space="preserve">
          <source>Similar to the standard Lua &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.resume&quot;&gt;coroutine.resume&lt;/a&gt; API, but works in the context of the Lua coroutines created by ngx_lua.</source>
          <target state="translated">与标准Lua &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.resume&quot;&gt;coroutine.resume&lt;/a&gt; API 相似，但在ngx_lua创建的Lua协程的上下文中工作。</target>
        </trans-unit>
        <trans-unit id="78010ee7daa3e2bd4ab094d2de04942d6ebe347e" translate="yes" xml:space="preserve">
          <source>Similar to the standard Lua &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.wrap&quot;&gt;coroutine.wrap&lt;/a&gt; API, but works in the context of the Lua coroutines created by ngx_lua.</source>
          <target state="translated">与标准Lua &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.wrap&quot;&gt;coroutine.wrap&lt;/a&gt; API 相似，但在ngx_lua创建的Lua协程的上下文中工作。</target>
        </trans-unit>
        <trans-unit id="44cfb6fec7a73bbbf8e3dc21c4669043c1f4919f" translate="yes" xml:space="preserve">
          <source>Similar to the standard Lua &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.yield&quot;&gt;coroutine.yield&lt;/a&gt; API, but works in the context of the Lua coroutines created by ngx_lua.</source>
          <target state="translated">与标准Lua &lt;a href=&quot;http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.yield&quot;&gt;coroutine.yield&lt;/a&gt; API 相似，但在ngx_lua创建的Lua协程的上下文中工作。</target>
        </trans-unit>
        <trans-unit id="07958eaee11a6c0bba997479f92fbd7e2e3f86a2" translate="yes" xml:space="preserve">
          <source>Similarly, Nginx config</source>
          <target state="translated">同样,Nginx配置</target>
        </trans-unit>
        <trans-unit id="12e5f5cf12f71667ff3409c62673b043f11cab80" translate="yes" xml:space="preserve">
          <source>Similarly, if using the standard Lua 5.1 interpreter with ngx_lua, Lua compatible bytecode files must be generated using the &lt;code&gt;luac&lt;/code&gt; commandline utility as shown:</source>
          <target state="translated">同样，如果将标准的Lua 5.1解释器与ngx_lua一起使用，则必须使用 &lt;code&gt;luac&lt;/code&gt; 命令行实用程序生成与Lua兼容的字节码文件，如下所示：</target>
        </trans-unit>
        <trans-unit id="a856e6846e8b4073e471221248e04de15e34b684" translate="yes" xml:space="preserve">
          <source>Similarly, the following directives provided by &lt;a href=&quot;http://github.com/openresty/encrypted-session-nginx-module&quot;&gt;encrypted-session-nginx-module&lt;/a&gt; can be invoked from within Lua too:</source>
          <target state="translated">类似地，&lt;a href=&quot;http://github.com/openresty/encrypted-session-nginx-module&quot;&gt;encrypted-session-nginx-module&lt;/a&gt;提供的以下指令也可以在Lua内部调用：</target>
        </trans-unit>
        <trans-unit id="9b248a256a7a9510bdb3499e5ff809ca2d82a4d6" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;v0.8.3&lt;/code&gt; this function returns &lt;code&gt;1&lt;/code&gt; on success, or returns &lt;code&gt;nil&lt;/code&gt; and a string describing the error otherwise.</source>
          <target state="translated">从 &lt;code&gt;v0.8.3&lt;/code&gt; 开始,此函数成功返回 &lt;code&gt;1&lt;/code&gt; ，否则返回 &lt;code&gt;nil&lt;/code&gt; 和否则描述错误的字符串。</target>
        </trans-unit>
        <trans-unit id="b18a9990f544a1d0b6d5c1397202597ea48e6a16" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;0.6.9&lt;/code&gt; release, all the header names in the Lua table returned are converted to the pure lower-case form by default, unless the &lt;code&gt;raw&lt;/code&gt; argument is set to &lt;code&gt;true&lt;/code&gt; (default to &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">从 &lt;code&gt;0.6.9&lt;/code&gt; 版本开始，默认情况下，除非将 &lt;code&gt;raw&lt;/code&gt; 参数设置为 &lt;code&gt;true&lt;/code&gt; （默认为 &lt;code&gt;false&lt;/code&gt; ），否则默认情况下，返回的Lua表中的所有标头名称都将转换为纯小写形式。</target>
        </trans-unit>
        <trans-unit id="d69ce11201e400cd85895b093071d277aadae953" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;0.7.20&lt;/code&gt; release, The &lt;code&gt;0&lt;/code&gt; time argument can also be specified.</source>
          <target state="translated">从 &lt;code&gt;0.7.20&lt;/code&gt; 版本开始，还可以指定 &lt;code&gt;0&lt;/code&gt; 时间参数。</target>
        </trans-unit>
        <trans-unit id="f5502b62197033b6f4ce57f00533a3d35bb5eb77" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;0.9.16&lt;/code&gt; release, an optional boolean-typed &lt;code&gt;no_padding&lt;/code&gt; argument can be specified to control whether the base64 padding should be appended to the resulting digest (default to &lt;code&gt;false&lt;/code&gt;, i.e., with padding enabled).</source>
          <target state="translated">从 &lt;code&gt;0.9.16&lt;/code&gt; 版本开始，可以指定可选的布尔类型的 &lt;code&gt;no_padding&lt;/code&gt; 参数来控制是否应将base64填充附加到结果摘要（默认为 &lt;code&gt;false&lt;/code&gt; ，即启用填充）。</target>
        </trans-unit>
        <trans-unit id="070ee59a56a6ad95645e5072a7dcf4e41b4bb037" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;0.9.3&lt;/code&gt; release, an optional 5th argument, &lt;code&gt;nth&lt;/code&gt;, is supported to specify which (submatch) capture's indexes to return. When &lt;code&gt;nth&lt;/code&gt; is 0 (which is the default), the indexes for the whole matched substring is returned; when &lt;code&gt;nth&lt;/code&gt; is 1, then the 1st submatch capture's indexes are returned; when &lt;code&gt;nth&lt;/code&gt; is 2, then the 2nd submatch capture is returned, and so on. When the specified submatch does not have a match, then two &lt;code&gt;nil&lt;/code&gt; values will be returned. Below is an example for this:</source>
          <target state="translated">从 &lt;code&gt;0.9.3&lt;/code&gt; 版本开始，支持使用可选的第5个参数 &lt;code&gt;nth&lt;/code&gt; 来指定要返回哪个（子匹配）捕获的索引。当 &lt;code&gt;nth&lt;/code&gt; 为0（默认值）时，返回整个匹配子字符串的索引；否则，返回0。当 &lt;code&gt;nth&lt;/code&gt; 为1时，则返回第一个子匹配捕获的索引；当 &lt;code&gt;nth&lt;/code&gt; 为2时，则返回第二个子匹配捕获，依此类推。当指定的子匹配项不匹配时，将返回两个 &lt;code&gt;nil&lt;/code&gt; 值。下面是一个示例：</target>
        </trans-unit>
        <trans-unit id="61e4b5917b2fec2373b25326528f336425506795" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;v0.7.18&lt;/code&gt; release, connecting to a datagram unix domain socket file is also possible on Linux:</source>
          <target state="translated">从 &lt;code&gt;v0.7.18&lt;/code&gt; 版本开始，在Linux上也可以连接到数据报unix域套接字文件：</target>
        </trans-unit>
        <trans-unit id="210812f589792cb707bcf4b21ae05cf8653b5483" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;v0.8.8&lt;/code&gt; release, this method no longer automatically closes the current connection when the read timeout error happens. For other connection errors, this method always automatically closes the connection.</source>
          <target state="translated">从 &lt;code&gt;v0.8.8&lt;/code&gt; 版本开始，当发生读取超时错误时，此方法不再自动关闭当前连接。对于其他连接错误，此方法始终自动关闭连接。</target>
        </trans-unit>
        <trans-unit id="fa2ca56726c04febc5e980583e98a176acf7e5eb" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;v0.9.0&lt;/code&gt; release, this function accepts an optional boolean &lt;code&gt;raw&lt;/code&gt; argument. When this argument is &lt;code&gt;true&lt;/code&gt;, this function returns a full-duplex cosocket object wrapping around the raw downstream connection socket, upon which you can call the &lt;a href=&quot;#tcpsockreceive&quot;&gt;receive&lt;/a&gt;, &lt;a href=&quot;#tcpsockreceiveuntil&quot;&gt;receiveuntil&lt;/a&gt;, and &lt;a href=&quot;#tcpsocksend&quot;&gt;send&lt;/a&gt; methods.</source>
          <target state="translated">从 &lt;code&gt;v0.9.0&lt;/code&gt; 版本开始，此函数接受可选的布尔 &lt;code&gt;raw&lt;/code&gt; 参数。当此参数为 &lt;code&gt;true&lt;/code&gt; 时，此函数返回环绕原始下游连接套接字的全双工cosocket对象，您可以在其上调用&lt;a href=&quot;#tcpsockreceive&quot;&gt;receive&lt;/a&gt;，&lt;a href=&quot;#tcpsockreceiveuntil&quot;&gt;receiveuntil&lt;/a&gt;和&lt;a href=&quot;#tcpsocksend&quot;&gt;send&lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="f58b124b53b6bcd71b3599b330c2fa8d10290482" translate="yes" xml:space="preserve">
          <source>Sleeping API function &lt;a href=&quot;#ngxsleep&quot;&gt;ngx.sleep&lt;/a&gt;.</source>
          <target state="translated">睡眠API函数&lt;a href=&quot;#ngxsleep&quot;&gt;ngx.sleep&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="27359c4bc78ac00841adea22743e9d0c89171f7b" translate="yes" xml:space="preserve">
          <source>Sleeps for the specified seconds without blocking. One can specify time resolution up to 0.001 seconds (i.e., one milliseconds).</source>
          <target state="translated">在指定的秒数内无阻挡地睡眠,可以指定时间分辨率为0.001秒(即一毫秒)。可以指定最高0.001秒的时间分辨率(即一毫秒)。</target>
        </trans-unit>
        <trans-unit id="fcaea81dce16b1cf54b7811c26aa438c76e61061" translate="yes" xml:space="preserve">
          <source>So even if the return value of the &lt;code&gt;free_space&lt;/code&gt; method is zero, there may be room in already assigned pages, so you may successfully set a new key value pair to the shared dict without getting &lt;code&gt;true&lt;/code&gt; for &lt;code&gt;forcible&lt;/code&gt; or non nil &lt;code&gt;err&lt;/code&gt; from the &lt;code&gt;ngx.shared.DICT.set&lt;/code&gt;.</source>
          <target state="translated">所以，即使返回值 &lt;code&gt;free_space&lt;/code&gt; 方法是零，有可能是房间已经分配的页面，所以你可能会成功地设置新的键值对，共享的字典没有得到 &lt;code&gt;true&lt;/code&gt; 的 &lt;code&gt;forcible&lt;/code&gt; 或非零 &lt;code&gt;err&lt;/code&gt; 从 &lt;code&gt;ngx.shared.DICT.set&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e92df4b1ec1954469ddb78f2bfe169443436c7e4" translate="yes" xml:space="preserve">
          <source>So if the total number of workers is &lt;code&gt;N&lt;/code&gt;, then this method may return a number between 0 and &lt;code&gt;N - 1&lt;/code&gt; (inclusive).</source>
          <target state="translated">因此，如果工人总数为 &lt;code&gt;N&lt;/code&gt; ，则此方法可能返回0到 &lt;code&gt;N - 1&lt;/code&gt; （含N）之间的数字。</target>
        </trans-unit>
        <trans-unit id="84efbedcec6f11d239871ca18a28099a361421bc" translate="yes" xml:space="preserve">
          <source>Socket objects that have not invoked this method (and associated connections) will be closed when the socket object is released by the Lua GC (Garbage Collector) or the current client HTTP request finishes processing.</source>
          <target state="translated">当套接字对象被Lua GC(Garbage Collector)释放或当前客户端HTTP请求处理完毕时,没有调用该方法的套接字对象(以及相关连接)将被关闭。</target>
        </trans-unit>
        <trans-unit id="da9e7f8bbe4de19071db0a2c4e2d02421a8b6d82" translate="yes" xml:space="preserve">
          <source>Some special nginx variables like &lt;code&gt;$args&lt;/code&gt; and &lt;code&gt;$limit_rate&lt;/code&gt; can be assigned a value, many others are not, like &lt;code&gt;$query_string&lt;/code&gt;, &lt;code&gt;$arg_PARAMETER&lt;/code&gt;, and &lt;code&gt;$http_NAME&lt;/code&gt;.</source>
          <target state="translated">像一些特殊的Nginx变量 &lt;code&gt;$args&lt;/code&gt; 和 &lt;code&gt;$limit_rate&lt;/code&gt; 可以分配一个值，很多人都没有，像 &lt;code&gt;$query_string&lt;/code&gt; ， &lt;code&gt;$arg_PARAMETER&lt;/code&gt; ，和 &lt;code&gt;$http_NAME&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="23bafa371fcfd7ad9f80116e1d8ac3329001abeb" translate="yes" xml:space="preserve">
          <source>Spawns a new user &quot;light thread&quot; with the Lua function &lt;code&gt;func&lt;/code&gt; as well as those optional arguments &lt;code&gt;arg1&lt;/code&gt;, &lt;code&gt;arg2&lt;/code&gt;, and etc. Returns a Lua thread (or Lua coroutine) object represents this &quot;light thread&quot;.</source>
          <target state="translated">使用Lua函数 &lt;code&gt;func&lt;/code&gt; 以及那些可选参数 &lt;code&gt;arg1&lt;/code&gt; ， &lt;code&gt;arg2&lt;/code&gt; 等产生一个新的用户&amp;ldquo;轻线程&amp;rdquo; 。返回一个表示此&amp;ldquo;轻线程&amp;rdquo;的Lua线程（或Lua协程）对象。</target>
        </trans-unit>
        <trans-unit id="b26851b1e02485c8402ed45e82946b5e8b4e49f4" translate="yes" xml:space="preserve">
          <source>Special Escaping Sequences</source>
          <target state="translated">特殊逃逸序列</target>
        </trans-unit>
        <trans-unit id="5cb52b844506853e4a52ad9c6f20086d874f14dd" translate="yes" xml:space="preserve">
          <source>Special PCRE Sequences</source>
          <target state="translated">特殊PCRE序列</target>
        </trans-unit>
        <trans-unit id="87e4093eff26b9142f958fcee21b9d4f56a5d1a4" translate="yes" xml:space="preserve">
          <source>Specifies a file path with trusted CA certificates in the PEM format used to verify the certificate of the SSL/TLS server in the &lt;a href=&quot;#tcpsocksslhandshake&quot;&gt;tcpsock:sslhandshake&lt;/a&gt; method.</source>
          <target state="translated">指定文件路径，该文件路径带有PEM格式的受信任CA证书，用于通过&lt;a href=&quot;#tcpsocksslhandshake&quot;&gt;tcpsock：sslhandshake&lt;/a&gt;方法验证SSL / TLS服务器的证书。</target>
        </trans-unit>
        <trans-unit id="c347c78b21148a184b1541a95d7738ad4d4964bb" translate="yes" xml:space="preserve">
          <source>Specifies a file with revoked certificates (CRL) in the PEM format used to verify the certificate of the SSL/TLS server in the &lt;a href=&quot;#tcpsocksslhandshake&quot;&gt;tcpsock:sslhandshake&lt;/a&gt; method.</source>
          <target state="translated">使用&lt;a href=&quot;#tcpsocksslhandshake&quot;&gt;tcpsock：sslhandshake&lt;/a&gt;方法以PEM格式指定具有已吊销证书（CRL）的文件，该文件用于验证SSL / TLS服务器的证书。</target>
        </trans-unit>
        <trans-unit id="f13e6d25b00a0894c6bf2e21f820b44a958897e7" translate="yes" xml:space="preserve">
          <source>Specifies the &quot;match limit&quot; used by the PCRE library when executing the &lt;a href=&quot;#ngxrematch&quot;&gt;ngx.re API&lt;/a&gt;. To quote the PCRE manpage, &quot;the limit ... has the effect of limiting the amount of backtracking that can take place.&quot;</source>
          <target state="translated">指定执行&lt;a href=&quot;#ngxrematch&quot;&gt;ngx.re API&lt;/a&gt;时PCRE库使用的&amp;ldquo;匹配限制&amp;rdquo; 。引用PCRE手册，&amp;ldquo;限制...具有限制可以发生的回溯量的作用。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="06604fef4a9a0145840989ba5d3f572ef573fc4d" translate="yes" xml:space="preserve">
          <source>Specifies the buffer size used by cosocket reading operations.</source>
          <target state="translated">指定cosocket读取操作所使用的缓冲区大小。</target>
        </trans-unit>
        <trans-unit id="86f57a1ce0e0207ebdd37f76c124f3c3408b8d46" translate="yes" xml:space="preserve">
          <source>Specifies the enabled ciphers for requests to a SSL/TLS server in the &lt;a href=&quot;#tcpsocksslhandshake&quot;&gt;tcpsock:sslhandshake&lt;/a&gt; method. The ciphers are specified in the format understood by the OpenSSL library.</source>
          <target state="translated">在&lt;a href=&quot;#tcpsocksslhandshake&quot;&gt;tcpsock：sslhandshake&lt;/a&gt;方法中指定对SSL / TLS服务器的请求启用的密码。密码以OpenSSL库可以理解的格式指定。</target>
        </trans-unit>
        <trans-unit id="40bf5d4700cdb8bb9cbbbf1f6fe23f6536bf9f48" translate="yes" xml:space="preserve">
          <source>Specifies the maximum number of entries allowed in the worker process level compiled regex cache.</source>
          <target state="translated">指定工人进程级编译的regex缓存中允许的最大条目数。</target>
        </trans-unit>
        <trans-unit id="5d63539570ca6ce5791e9cfd872d9cd907599e94" translate="yes" xml:space="preserve">
          <source>Specifies the size limit (in terms of connection count) for every cosocket connection pool associated with every remote server (i.e., identified by either the host-port pair or the unix domain socket file path).</source>
          <target state="translated">指定与每个远程服务器相关联的每个 cosocket 连接池(即由主机端口对或 unix 域套接字文件路径识别)的大小限制(以连接数为单位)。</target>
        </trans-unit>
        <trans-unit id="0b1ce80ed42032256c9f54372fef7910c76cd177" translate="yes" xml:space="preserve">
          <source>Specifies whether to use the MIME type specified by the &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#default_type&quot;&gt;default_type&lt;/a&gt; directive for the default value of the &lt;code&gt;Content-Type&lt;/code&gt; response header. Deactivate this directive if a default &lt;code&gt;Content-Type&lt;/code&gt; response header for Lua request handlers is not desired.</source>
          <target state="translated">指定是否将&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#default_type&quot;&gt;default_type&lt;/a&gt;指令指定的MIME类型用作 &lt;code&gt;Content-Type&lt;/code&gt; 响应标头的默认值。如果不需要Lua请求处理程序的默认 &lt;code&gt;Content-Type&lt;/code&gt; 响应标头，请停用此指令。</target>
        </trans-unit>
        <trans-unit id="0959c81ee3e6fc80a3d3e5ab47968630562045fd" translate="yes" xml:space="preserve">
          <source>Specify &lt;code&gt;options&lt;/code&gt; to control how the match operation will be performed. The following option characters are supported:</source>
          <target state="translated">指定 &lt;code&gt;options&lt;/code&gt; 以控制匹配操作的执行方式。支持以下选项字符：</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
