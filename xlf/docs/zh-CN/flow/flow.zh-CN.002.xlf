<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="flow">
    <body>
      <group id="flow">
        <trans-unit id="d05d05cc53d263dbf9565cc2f8874c592fa9032b" translate="yes" xml:space="preserve">
          <source>Note: If you are using a version where types-first is enabled by default (ie. &lt;code&gt;&amp;gt;=0.134&lt;/code&gt;), make sure you set &lt;code&gt;types_first=false&lt;/code&gt; in your .flowconfig while running the codemods.</source>
          <target state="translated">注意：如果使用默认启用类型优先的版本（即 &lt;code&gt;&amp;gt;=0.134&lt;/code&gt; ），请确保在运行codemods时在.flowconfig中设置 &lt;code&gt;types_first=false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d3afeab423452d90f3f48f5a1c1720d65315cde" translate="yes" xml:space="preserve">
          <source>Note: The above flags are available in versions of Flow &lt;code&gt;&amp;gt;=0.102&lt;/code&gt; with the &lt;code&gt;experimental.&lt;/code&gt; prefix (and prior to v0.128, it used &lt;code&gt;whitelist&lt;/code&gt; in place of &lt;code&gt;includes&lt;/code&gt;):</source>
          <target state="translated">注意：以上标记在带有 &lt;code&gt;experimental.&lt;/code&gt; 的Flow &lt;code&gt;&amp;gt;=0.102&lt;/code&gt; 版本中可用。前缀（在v0.128之前，它使用 &lt;code&gt;whitelist&lt;/code&gt; 代替 &lt;code&gt;includes&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="bc76abb2875c7659b6d7f4f248528d58f58a9924" translate="yes" xml:space="preserve">
          <source>Notice the types added to the parameter of the function along with a return type at the end of the function. You might be able to tell from looking at this code that there is an error in the return type since the function can also return an &lt;code&gt;int&lt;/code&gt;. However, you do not need to visually inspect the code since the Flow background process will be able to catch this error for you when you &lt;a href=&quot;#toc-check-your-code&quot;&gt;check your code&lt;/a&gt;.</source>
          <target state="translated">请注意，添加到函数参数的类型以及函数末尾的返回类型。通过查看此代码，您也许可以看出返回类型有错误，因为该函数还可以返回 &lt;code&gt;int&lt;/code&gt; 。但是，你并不需要目视检查代码，因为流动后台进程将能够赶上这个错误时，你&lt;a href=&quot;#toc-check-your-code&quot;&gt;检查你的代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c0d7a1a5c5c6adb2044345b94128cb7b17d10e58" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;flow&lt;/code&gt; will include a directory outside the &lt;code&gt;.flowconfig&lt;/code&gt; path in its check, ignore the &lt;code&gt;build&lt;/code&gt; directory and use the declarations in &lt;code&gt;lib&lt;/code&gt;.</source>
          <target state="translated">现在， &lt;code&gt;flow&lt;/code&gt; 将在检查中包括 &lt;code&gt;.flowconfig&lt;/code&gt; 路径之外的目录，忽略 &lt;code&gt;build&lt;/code&gt; 目录并使用 &lt;code&gt;lib&lt;/code&gt; 中的声明。</target>
        </trans-unit>
        <trans-unit id="a044c31320a1c390eff0c847424350f19070f44e" translate="yes" xml:space="preserve">
          <source>Now Flow will complain when you try to write to any of these properties.</source>
          <target state="translated">现在,当你试图向这些属性写入时,Flow会抱怨。</target>
        </trans-unit>
        <trans-unit id="7b7f5bac6c35b92b712c9bf97b054fa867c2ca01" translate="yes" xml:space="preserve">
          <source>Now if you try to use &lt;code&gt;&amp;lt;MyComponent&amp;gt;&lt;/code&gt; with a string for &lt;code&gt;foo&lt;/code&gt; instead of a number you will get an error.</source>
          <target state="translated">现在，如果尝试将 &lt;code&gt;&amp;lt;MyComponent&amp;gt;&lt;/code&gt; 与 &lt;code&gt;foo&lt;/code&gt; 的字符串（而不是数字）一起使用，则会出现错误。</target>
        </trans-unit>
        <trans-unit id="5b61c8302b29c6822902031839e12485c087afa1" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s see an example of the first case documented above. Suppose we have the following code in a file &lt;code&gt;src/LookBeforeYouLeap.js&lt;/code&gt;:</source>
          <target state="translated">现在，让我们看一下上面记录的第一种情况的示例。假设我们在文件 &lt;code&gt;src/LookBeforeYouLeap.js&lt;/code&gt; 中具有以下代码：</target>
        </trans-unit>
        <trans-unit id="fb52c53f4f22a6c6d90afe94da1c5cde383f8510" translate="yes" xml:space="preserve">
          <source>Now let's see how you would take this intuition and type the children of various React components.</source>
          <target state="translated">现在让我们来看看你将如何利用这种直觉,对各种React组件的子女进行类型化。</target>
        </trans-unit>
        <trans-unit id="c47667d674268b42d8bc54bea9304a308b2c873f" translate="yes" xml:space="preserve">
          <source>Now suppose that instead of a boolean, we have a numerical value representing, say, the number of comments on a post. We want to display a count of the comments, unless there are no comments. We might naively try to do something similar to the boolean case:</source>
          <target state="translated">现在假设我们有一个数值来代替布尔值,比如说,一个帖子的评论数。我们希望显示评论的数量,除非没有评论。我们可能会天真地尝试做一些类似布尔值的情况。</target>
        </trans-unit>
        <trans-unit id="130ecc6b759fae2f2cbba2aade21537572c9ebf2" translate="yes" xml:space="preserve">
          <source>Now that all the setup and initialization is complete, you are ready to write actual Flow code. For each file that you have flagged with &lt;code&gt;// @flow&lt;/code&gt;, you now have the full power of Flow and its type-checking available to you. Here is an example Flow file:</source>
          <target state="translated">既然所有的设置和初始化都已经完成，您就可以编写实际的Flow代码了。现在，对于使用 &lt;code&gt;// @flow&lt;/code&gt; 标记的每个文件，您都可以使用Flow及其类型检查的全部功能。这是一个示例流文件：</target>
        </trans-unit>
        <trans-unit id="8a0aa492d72ba5e5ee4e490208cd56c9c6fd8b5b" translate="yes" xml:space="preserve">
          <source>Now type inference can keep working for &lt;code&gt;typeof obj&lt;/code&gt; which returns the expected shape of the object.</source>
          <target state="translated">现在，类型推断可以为 &lt;code&gt;typeof obj&lt;/code&gt; 继续工作，它返回对象的预期形状。</target>
        </trans-unit>
        <trans-unit id="18e7605734b62fc321cd934a156de7bc5fd3f54f" translate="yes" xml:space="preserve">
          <source>Now wherever we use &lt;code&gt;this.props&lt;/code&gt; in our React component Flow will treat it as the &lt;code&gt;Props&lt;/code&gt; type we defined.</source>
          <target state="translated">现在，无论我们在React组件Flow中使用 &lt;code&gt;this.props&lt;/code&gt; 的何处，都将其视为我们定义的 &lt;code&gt;Props&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="cba47b2f9c45e1dcfda8b52779b4d36ece5cf6c4" translate="yes" xml:space="preserve">
          <source>Now you&amp;rsquo;ll get a warning from Flow if you try to use numbers.</source>
          <target state="translated">现在，如果您尝试使用数字，将会收到Flow的警告。</target>
        </trans-unit>
        <trans-unit id="abd74ca854ddc164ed4dd85269784a3b28f553e8" translate="yes" xml:space="preserve">
          <source>Now your code will not leak &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">现在，您的代码将不会泄漏 &lt;code&gt;any&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d733ad521afc4421b4a66b432128c9bcdc2b5eec" translate="yes" xml:space="preserve">
          <source>Now, if you pass two values then &lt;code&gt;props.children&lt;/code&gt; will be an array. Specifically in this case &lt;code&gt;props.children&lt;/code&gt; will be &lt;code&gt;[1, 2]&lt;/code&gt;.</source>
          <target state="translated">现在，如果您传递两个值，则 &lt;code&gt;props.children&lt;/code&gt; 将是一个数组。具体来说，在这种情况下 &lt;code&gt;props.children&lt;/code&gt; 将是 &lt;code&gt;[1, 2]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="be6e2a0e2bd898f29d9210b231319127fd00f218" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s Flowify the component we just wrote:</source>
          <target state="translated">现在，让我们流化刚刚编写的组件：</target>
        </trans-unit>
        <trans-unit id="c7db6f471fb8404ecff0960ed4244da4532a2c7e" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s walk through different definitions of &lt;code&gt;method()&lt;/code&gt; in a couple different &lt;em&gt;subclasses&lt;/em&gt;.</source>
          <target state="translated">现在，让我们在几个不同的&lt;em&gt;子类中&lt;/em&gt;遍历 &lt;code&gt;method()&lt;/code&gt; 的不同定义。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3fe7f794fc68b1034d0e3f564bf32dd7ffd089d7" translate="yes" xml:space="preserve">
          <source>Nuclide</source>
          <target state="translated">Nuclide</target>
        </trans-unit>
        <trans-unit id="63c0e833d1f670a8069d40968493548f0265ef94" translate="yes" xml:space="preserve">
          <source>Nuclide also comes with many other features including support for remote projects, hack, mercurial etc.</source>
          <target state="translated">Nuclide还带有很多其他功能,包括支持远程项目、hack、mercurial等。</target>
        </trans-unit>
        <trans-unit id="9e0b7a63508302d9d09c38742d062288dc1823d2" translate="yes" xml:space="preserve">
          <source>Nuclide v0.243.0 onward has support for working with Flow to limit the reported warnings to the working fileset. This allows Nuclide and Flow to work efficiently on large codebases with tens of thousands of unsuppressed warnings.</source>
          <target state="translated">Nuclide v0.243.0以后的版本支持与Flow一起工作,将报告的警告限制在工作文件集内。这使得Nuclide和Flow能够有效地处理有数万个未抑制警告的大型代码库。</target>
        </trans-unit>
        <trans-unit id="7e53821f70ae16079c4a6a64c52a91fae645bc5f" translate="yes" xml:space="preserve">
          <source>Numbers</source>
          <target state="translated">Numbers</target>
        </trans-unit>
        <trans-unit id="335e5e44a812438f93ba78ec1988eb2972404cb9" translate="yes" xml:space="preserve">
          <source>Numbers: like &lt;code&gt;42&lt;/code&gt; or &lt;code&gt;3.14&lt;/code&gt;</source>
          <target state="translated">数字：例如 &lt;code&gt;42&lt;/code&gt; 或 &lt;code&gt;3.14&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cbf147d445453a6660add525598d56066b954b1c" translate="yes" xml:space="preserve">
          <source>Object Types</source>
          <target state="translated">对象类型</target>
        </trans-unit>
        <trans-unit id="9ed92c18b4e477381c353e8136dbc9d058b63386" translate="yes" xml:space="preserve">
          <source>Object type inference</source>
          <target state="translated">对象类型推断</target>
        </trans-unit>
        <trans-unit id="0b9a72ed85754757a03a424a4f413c85cc295a74" translate="yes" xml:space="preserve">
          <source>Object type syntax</source>
          <target state="translated">对象类型语法</target>
        </trans-unit>
        <trans-unit id="cdea7c16abb43506671d0750b87a9ae17eb2398a" translate="yes" xml:space="preserve">
          <source>Object types can have optional properties where a question mark &lt;code&gt;?&lt;/code&gt; comes after the property name.</source>
          <target state="translated">对象类型可以具有可选属性，其中问号 &lt;code&gt;?&lt;/code&gt; 在属性名称之后。</target>
        </trans-unit>
        <trans-unit id="f85c54a239ca0dd9865eaee3f09163bc064e2fde" translate="yes" xml:space="preserve">
          <source>Object types try to match the syntax for objects in JavaScript as much as possible. Using curly braces &lt;code&gt;{}&lt;/code&gt; and name-value pairs using a colon &lt;code&gt;:&lt;/code&gt; split by commas &lt;code&gt;,&lt;/code&gt;.</source>
          <target state="translated">对象类型尝试尽可能匹配JavaScript中对象的语法。使用大括号 &lt;code&gt;{}&lt;/code&gt; 和冒号的名称/值对 &lt;code&gt;:&lt;/code&gt; 用逗号分隔 &lt;code&gt;,&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1354578aed5c555826e657109cf8e1a80a7db3d0" translate="yes" xml:space="preserve">
          <source>Objects are structurally typed</source>
          <target state="translated">对象的结构类型是</target>
        </trans-unit>
        <trans-unit id="9ab5bd450c651a40acb31c6d2173d2d8a317f03b" translate="yes" xml:space="preserve">
          <source>Objects as maps</source>
          <target state="translated">物体作为地图</target>
        </trans-unit>
        <trans-unit id="01a1617fcbeab1f400211a1e0e3d5541707fdd66" translate="yes" xml:space="preserve">
          <source>Objects can be used in many different ways in JavaScript. There are a number of different ways to type them in order to support all the different use cases.</source>
          <target state="translated">在JavaScript中,对象可以以许多不同的方式使用。为了支持所有不同的用例,有许多不同的方式来类型它们。</target>
        </trans-unit>
        <trans-unit id="a4eb44d5d295882356db532a105f60a76be3916a" translate="yes" xml:space="preserve">
          <source>Obsolete. Set this to &lt;code&gt;true&lt;/code&gt; to always strip the root directory from file paths in error messages when using &lt;code&gt;--json&lt;/code&gt;, &lt;code&gt;--from emacs&lt;/code&gt;, and &lt;code&gt;--from vim&lt;/code&gt;. Do not use this option. Instead, pass the command line flag &lt;code&gt;--strip-root&lt;/code&gt;.</source>
          <target state="translated">过时的 设置为 &lt;code&gt;true&lt;/code&gt; 可以在使用 &lt;code&gt;--json&lt;/code&gt; ， &lt;code&gt;--from emacs&lt;/code&gt; from emacs和 &lt;code&gt;--from vim&lt;/code&gt; 时始终从错误消息中的文件路径中删除根目录。不要使用此选项。而是传递命令行标志 &lt;code&gt;--strip-root&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd9b17a8cc9cfeab14950ff409781477ba7078b9" translate="yes" xml:space="preserve">
          <source>Often third-party libraries have broken type definitions or have type definitions only compatible with a certain version of Flow. In those cases it may be useful to use type information from the third-party libraries without typechecking their contents.</source>
          <target state="translated">通常,第三方库的类型定义是错误的,或者其类型定义只与某个版本的Flow兼容。在这些情况下,使用第三方库的类型信息而不对其内容进行类型检查可能是有用的。</target>
        </trans-unit>
        <trans-unit id="adacc74ca82788d5eac49de1a84a330f45c46c00" translate="yes" xml:space="preserve">
          <source>Often, third-party code is organized in terms of modules rather than globals. To write a libdef that declares the presence of a module you&amp;rsquo;ll want to use the &lt;code&gt;declare module&lt;/code&gt; syntax:</source>
          <target state="translated">通常，第三方代码是根据模块而不是全局变量组织的。要编写一个声明模块存在的libdef，您将要使用 &lt;code&gt;declare module&lt;/code&gt; 语法：</target>
        </trans-unit>
        <trans-unit id="b24bbeccf5137f66b11ed50187cc6eafef3213fa" translate="yes" xml:space="preserve">
          <source>On the flip-side, &lt;strong&gt;&lt;em&gt;completeness&lt;/em&gt;&lt;/strong&gt; is the ability for a type checker to only ever catch errors that &lt;em&gt;would&lt;/em&gt; happen at runtime. This comes at the cost of sometimes missing errors that will happen at runtime.</source>
          <target state="translated">在翻盖侧，&lt;strong&gt;&lt;em&gt;完整性&lt;/em&gt;&lt;/strong&gt;是一个类型检查只能赶上错误的能力&lt;em&gt;将&lt;/em&gt;发生在运行时。这是以有时会丢失运行时发生的错误为代价的。</target>
        </trans-unit>
        <trans-unit id="d37f56efe0e6015ca80498e8ea761c659a342927" translate="yes" xml:space="preserve">
          <source>Once all the dependencies of a &lt;code&gt;@flow strict-local&lt;/code&gt; file are strict, the file can be upgraded to a &lt;code&gt;@flow strict&lt;/code&gt; file. A &lt;code&gt;@flow strict&lt;/code&gt; file cannot depend on a &lt;code&gt;@flow strict-local&lt;/code&gt; file as this would break the &lt;code&gt;nonstrict-import&lt;/code&gt; rule.</source>
          <target state="translated">一旦 &lt;code&gt;@flow strict-local&lt;/code&gt; 文件的所有依赖关系都严格，则可以将文件升级为 &lt;code&gt;@flow strict&lt;/code&gt; 文件。一个 &lt;code&gt;@flow strict&lt;/code&gt; 文件可以不依赖于一个 &lt;code&gt;@flow strict-local&lt;/code&gt; 文件，因为这将打破 &lt;code&gt;nonstrict-import&lt;/code&gt; 规则。</target>
        </trans-unit>
        <trans-unit id="2e418e3cfbf0c00ec225eae651536e321fd3bd30" translate="yes" xml:space="preserve">
          <source>Once you have &lt;a href=&quot;https://flow.org/en/install/&quot;&gt;installed&lt;/a&gt; Flow, you will want to get a feel of how to use Flow at the most basic level. For most new Flow projects, you will follow this general pattern:</source>
          <target state="translated">一旦&lt;a href=&quot;https://flow.org/en/install/&quot;&gt;安装了&lt;/a&gt; Flow，您将希望了解如何在最基本的级别上使用Flow。对于大多数新的Flow项目，您将遵循以下一般模式：</target>
        </trans-unit>
        <trans-unit id="6ccb0b14eaa9c14dee4efd8a3cd89afe87b6ccb4" translate="yes" xml:space="preserve">
          <source>Once you have Babel setup, install &lt;code&gt;@babel/preset-flow&lt;/code&gt; with either &lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt; or &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;.</source>
          <target state="translated">完成Babel设置后，使用&lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt;或&lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;安装 &lt;code&gt;@babel/preset-flow&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb59ba6cf0854aeafe84a152636ede676c99a388" translate="yes" xml:space="preserve">
          <source>Once you have eliminated signature verification errors, you can turn on the types-first mode, by adding the following line to the &lt;code&gt;[options]&lt;/code&gt; section of the &lt;code&gt;.flowconfig&lt;/code&gt; file:</source>
          <target state="translated">消除签名验证错误后，可以通过 &lt;code&gt;.flowconfig&lt;/code&gt; 添加到.flowconfig文件的 &lt;code&gt;[options]&lt;/code&gt; 部分，来打开类型优先模式：</target>
        </trans-unit>
        <trans-unit id="f5fea1da9e23ea1d202b2729a702a3f535801fdd" translate="yes" xml:space="preserve">
          <source>One of the main contributors of Flow&amp;rsquo;s precision is path-sensitivity: the way types interact with runtime tests. The essence of many JavaScript idioms is to put together ad hoc sets of runtime values and to take them apart with shallow, structural (in)equality checks. In Flow, the set of runtime values that a variable may contain is described by its type, and a runtime test on that variable refines the type to a smaller set. This ability turns out to be quite powerful and general in practice.</source>
          <target state="translated">Flow精度的主要贡献者之一是路径敏感性：类型与运行时测试交互的方式。许多JavaScript习惯用法的本质是将特定的运行时值集合放在一起，并通过浅层的，结构性的（不平等的）检查将它们分开。在Flow中，变量可能包含的运行时值集由其类型描述，并且对该变量的运行时测试会将类型优化为较小的集。事实证明，此功能非常强大且通用。</target>
        </trans-unit>
        <trans-unit id="c922fe63b25cd49cec8888b01a561a5582a84a58" translate="yes" xml:space="preserve">
          <source>Only allowing a specific element type as children.</source>
          <target state="translated">只允许特定的元素类型作为子女。</target>
        </trans-unit>
        <trans-unit id="552faaf2aafbe53d107876ccee0f0634f915c3e5" translate="yes" xml:space="preserve">
          <source>Only one background process will be running at any given time, so if you run &lt;code&gt;flow status&lt;/code&gt; multiple times, it will use the same process.</source>
          <target state="translated">在任何给定时间都将只运行一个后台进程，因此，如果您多次运行 &lt;code&gt;flow status&lt;/code&gt; ，它将使用同一进程。</target>
        </trans-unit>
        <trans-unit id="e4a45cacdd8d7e9f0ebca1ec7bc3fb1f33c78855" translate="yes" xml:space="preserve">
          <source>Opaque Type Alias Syntax</source>
          <target state="translated">不透明类型别名语法</target>
        </trans-unit>
        <trans-unit id="65ea8514201b92749598f548009f0a4afe84c188" translate="yes" xml:space="preserve">
          <source>Opaque Type Alias Type Checking</source>
          <target state="translated">不透明类型别名类型检查</target>
        </trans-unit>
        <trans-unit id="961bf1b4717073b1bc912e5a6e9062ea360301f6" translate="yes" xml:space="preserve">
          <source>Opaque Type Aliases</source>
          <target state="translated">不透明别名类型</target>
        </trans-unit>
        <trans-unit id="6077a6482ea571ceaa9f7539cf7e9cbf318e56ce" translate="yes" xml:space="preserve">
          <source>Opaque type aliases are created using the words &lt;code&gt;opaque type&lt;/code&gt; followed by its name, an equals sign &lt;code&gt;=&lt;/code&gt;, and a type definition.</source>
          <target state="translated">不透明类型别名是使用单词 &lt;code&gt;opaque type&lt;/code&gt; ，其名称，等号 &lt;code&gt;=&lt;/code&gt; 和类型定义创建的。</target>
        </trans-unit>
        <trans-unit id="ee9ac0643d45dfbbd750de612f57c1963700d825" translate="yes" xml:space="preserve">
          <source>Opaque type aliases are type aliases that do not allow access to their underlying type outside of the file in which they are defined.</source>
          <target state="translated">不透明类型别名是类型别名,不允许访问它们定义的文件之外的底层类型。</target>
        </trans-unit>
        <trans-unit id="5f911be9170f1811fca0f4efce9cc2904081c303" translate="yes" xml:space="preserve">
          <source>Opaque type aliases can also have their own &lt;a href=&quot;../generics&quot;&gt;generics&lt;/a&gt;, and they work exactly as generics do in regular &lt;a href=&quot;../aliases#toc-type-alias-generics&quot;&gt;type aliases&lt;/a&gt;</source>
          <target state="translated">不透明类型别名也可以有自己的&lt;a href=&quot;../generics&quot;&gt;泛型&lt;/a&gt;，它们的工作方式与常规&lt;a href=&quot;../aliases#toc-type-alias-generics&quot;&gt;类型别名中的&lt;/a&gt;泛型完全一样</target>
        </trans-unit>
        <trans-unit id="a9f3700878b30b619fa2c5143a86c38508c7ca4b" translate="yes" xml:space="preserve">
          <source>Opaque type aliases, like regular type aliases, may be used anywhere a type can be used.</source>
          <target state="translated">不透明类型别名,就像普通类型别名一样,可以在任何可以使用类型的地方使用。</target>
        </trans-unit>
        <trans-unit id="ddd2d4ec70a68949d8c75dd5fb57b7fa281e8e27" translate="yes" xml:space="preserve">
          <source>Optional Parameters</source>
          <target state="translated">可选参数</target>
        </trans-unit>
        <trans-unit id="6eb1e4ba2d4c68b05e65e2f8b787201061244dd0" translate="yes" xml:space="preserve">
          <source>Optional function parameters</source>
          <target state="translated">可选功能参数</target>
        </trans-unit>
        <trans-unit id="b20d0cae17674ab970acb532453aaf71edae6a61" translate="yes" xml:space="preserve">
          <source>Optional object properties</source>
          <target state="translated">可选对象属性</target>
        </trans-unit>
        <trans-unit id="2d932cfadb898020aa3d7c79ba0029b42cc035ac" translate="yes" xml:space="preserve">
          <source>Optional object type properties</source>
          <target state="translated">可选对象类型属性</target>
        </trans-unit>
        <trans-unit id="7d05768bc14089a0cc0ad2e54b12a94fab4dbaf6" translate="yes" xml:space="preserve">
          <source>Optional parameters will accept missing, &lt;code&gt;undefined&lt;/code&gt;, or matching types. But they will not accept &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">可选参数将接受缺少， &lt;code&gt;undefined&lt;/code&gt; 或匹配的类型。但是他们不会接受 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5037e7b0dd30d22a12232b46317dc9e63f9ba600" translate="yes" xml:space="preserve">
          <source>Or as constructed wrapper objects.</source>
          <target state="translated">或者作为构造的包装对象。</target>
        </trans-unit>
        <trans-unit id="f26ec27bdcca139b8bc25d769f1290e1e51a3bf0" translate="yes" xml:space="preserve">
          <source>Or you could be accessing an element that does not exist if it is a &amp;ldquo;sparse array&amp;rdquo;.</source>
          <target state="translated">或者，您可能正在访问一个不存在的元素（如果它是&amp;ldquo;稀疏数组&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="e404be6e42270a506b9fda4079e3cbb1faf93ee5" translate="yes" xml:space="preserve">
          <source>Or you could refine on the shape of objects.</source>
          <target state="translated">或者你可以对物体的形状进行细化。</target>
        </trans-unit>
        <trans-unit id="36ccd6fa5b54b074d48b3c318b7724049b209ff5" translate="yes" xml:space="preserve">
          <source>Other Editors</source>
          <target state="translated">其他编辑</target>
        </trans-unit>
        <trans-unit id="b01d9e5fc57d8be7b4d4cfaf9d867219b88b9c98" translate="yes" xml:space="preserve">
          <source>Other extensions that you may try are:</source>
          <target state="translated">你可以尝试的其他扩展有:</target>
        </trans-unit>
        <trans-unit id="55d5eb5f68ae162a0c0275477fbf7fd7aa314ea9" translate="yes" xml:space="preserve">
          <source>Other type systems will favor completeness instead, only reporting real errors in favor of possibly missing errors. Unit/Integration testing is an extreme form of this approach. Often this comes at the cost of missing the errors that are the most complicated to find, leaving that part up to the developer.</source>
          <target state="translated">其他类型的系统反而会偏重于完整性,只报告真实的错误,而偏重于可能遗漏的错误。单元/集成测试是这种方法的一种极端形式。通常这是以遗漏那些最复杂的错误为代价的,把这部分工作留给开发人员。</target>
        </trans-unit>
        <trans-unit id="8d7bf5bf136e81f9388c1f4eca050d6d94e965d7" translate="yes" xml:space="preserve">
          <source>Others</source>
          <target state="translated">Others</target>
        </trans-unit>
        <trans-unit id="d10a332d2514aa48380a681c92c805bab5fc2c39" translate="yes" xml:space="preserve">
          <source>Our &lt;a href=&quot;../types&quot;&gt;types reference&lt;/a&gt; has more information about both &lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt;&lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../types#toc-react-element&quot;&gt;&lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">我们的&lt;a href=&quot;../types&quot;&gt;类型参考中&lt;/a&gt;有关于&lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt; &lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../types#toc-react-element&quot;&gt; &lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt; &lt;/a&gt;更多信息。</target>
        </trans-unit>
        <trans-unit id="c7ec91907688dba7293db664f96aa7520dd5050d" translate="yes" xml:space="preserve">
          <source>Our first case is an element with no children:</source>
          <target state="translated">我们的第一个案例是一个没有孩子的元素。</target>
        </trans-unit>
        <trans-unit id="3e4d85a254d099e6caabb9070a8f1a5835e74184" translate="yes" xml:space="preserve">
          <source>Outside the Defining File</source>
          <target state="translated">定义文件之外</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="2bfd0b733d61ec42886bc0c31e24e1f1a0d24fdf" translate="yes" xml:space="preserve">
          <source>Parameterized generics</source>
          <target state="translated">参数化通用</target>
        </trans-unit>
        <trans-unit id="bc7025db05fe11cfb78fa0f8ede0665290fcb863" translate="yes" xml:space="preserve">
          <source>Parts of the source that are visible from a file&amp;rsquo;s exports need to be annotated unless their type can be trivially inferred (e.g. the exported expression is a numeric literal). This is a requirement for types-first mode to function properly. Failure to properly annotate exports raise &lt;code&gt;signature-verfication-failure&lt;/code&gt;s.</source>
          <target state="translated">从文件导出中可见的源部分需要注释，除非可以简单地推断出它们的类型（例如，导出的表达式是数字文字）。这是类型优先模式正常运行的要求。未能正确注释出口会引发 &lt;code&gt;signature-verfication-failure&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6aa250c187d7bae549c808c9085514424d802eea" translate="yes" xml:space="preserve">
          <source>Pathogen</source>
          <target state="translated">Pathogen</target>
        </trans-unit>
        <trans-unit id="3dd4db5ce7ea626f59e720f0c27096a22aa1ecd0" translate="yes" xml:space="preserve">
          <source>Precision</source>
          <target state="translated">Precision</target>
        </trans-unit>
        <trans-unit id="8a51f97f15da4dd4d5a94fab1a4108cee0b5e1d4" translate="yes" xml:space="preserve">
          <source>Precision also has other desirable consequences. When types are trustworthy, developers tend to rely on them to structure their code and reason about it, leading to cleaner and more efficient code with fewer dynamic checks. When type errors are trustworthy, developers can focus on what their code does rather than thinking about how to rewrite their code to satisfy (or work around) the type system.</source>
          <target state="translated">精确性还具有其他理想的后果。当类型值得信赖时,开发人员倾向于依赖类型来构建他们的代码并对其进行推理,从而使代码更干净、更高效,动态检查更少。当类型错误值得信赖时,开发人员可以专注于他们的代码做什么,而不是考虑如何重写他们的代码以满足(或绕过)类型系统。</target>
        </trans-unit>
        <trans-unit id="83590fe5defcf4d8a2747e7bff66e91f7879b09e" translate="yes" xml:space="preserve">
          <source>Precision usually comes at the cost of speed. But while a precise analysis is desirable, most of the appeal of JavaScript is lost if we slow down the edit-refresh cycle by making developers wait as we compile.</source>
          <target state="translated">精确通常是以速度为代价的。但是,虽然精确的分析是可取的,但如果我们通过让开发人员在编译时等待来减慢编辑-刷新周期,那么JavaScript的大部分吸引力就会丧失。</target>
        </trans-unit>
        <trans-unit id="257e6b97ae8767ca7162ae0be418d790074caf9b" translate="yes" xml:space="preserve">
          <source>Predicate Functions</source>
          <target state="translated">谓词函数</target>
        </trans-unit>
        <trans-unit id="8fcc548a63302b124fd2a2a6ebe6d394e16cc696" translate="yes" xml:space="preserve">
          <source>Prepare Your Code for Flow</source>
          <target state="translated">为流程准备好您的代码</target>
        </trans-unit>
        <trans-unit id="ba3433a4118eec88859d98e1423037c6cc489342" translate="yes" xml:space="preserve">
          <source>Prepare your codebase for Types-First</source>
          <target state="translated">为Types-First准备好你的代码库。</target>
        </trans-unit>
        <trans-unit id="80015c28ef31d8e37f60f4672f12166e4717f624" translate="yes" xml:space="preserve">
          <source>Preparing a project for Flow requires only one command:</source>
          <target state="translated">为Flow准备一个项目只需要一个命令。</target>
        </trans-unit>
        <trans-unit id="0334ecb0491c1c96b75c2abb7a0dde8caad5c58f" translate="yes" xml:space="preserve">
          <source>Preserving the Instance Type of a Component</source>
          <target state="translated">保留组件的实例类型</target>
        </trans-unit>
        <trans-unit id="f6675da1b1e3eb27ea3b95e0125a3fc19547c62c" translate="yes" xml:space="preserve">
          <source>Press Ctrl+Shift+P to bring up the Command Palette (or use Tools &amp;gt; Command Palette menu)</source>
          <target state="translated">按Ctrl + Shift + P调出命令面板（或使用&amp;ldquo;工具&amp;rdquo;&amp;gt;&amp;ldquo;命令面板&amp;rdquo;菜单）</target>
        </trans-unit>
        <trans-unit id="4e34606590cc14f76b8a62ab4f8ca344fd2d5ed8" translate="yes" xml:space="preserve">
          <source>Prevent this from happening by cutting &lt;code&gt;any&lt;/code&gt; off as soon as possible by casting it to another type.</source>
          <target state="translated">通过将 &lt;code&gt;any&lt;/code&gt; 强制转换为另一种类型来尽快消除任何中断，以防止发生这种情况。</target>
        </trans-unit>
        <trans-unit id="d8f0896601269b7c415369db5197a7aa8c4bfad4" translate="yes" xml:space="preserve">
          <source>Primitive Types</source>
          <target state="translated">原始类型</target>
        </trans-unit>
        <trans-unit id="4d1f996aa17807ebebdb5143b01f86f170d5bea6" translate="yes" xml:space="preserve">
          <source>React</source>
          <target state="translated">React</target>
        </trans-unit>
        <trans-unit id="8fbb63e06d63d6be6834fa16600e9a6203922475" translate="yes" xml:space="preserve">
          <source>React Runtimes</source>
          <target state="translated">React Runtimes</target>
        </trans-unit>
        <trans-unit id="498f09c9f4966796c2534e5801feef8ccd4eed84" translate="yes" xml:space="preserve">
          <source>React allows you to grab the instance of an element or component with &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt;&lt;code&gt;ref&lt;/code&gt; functions&lt;/a&gt;. To use a ref function add a &lt;a href=&quot;https://flow.org/en/types/maybe/&quot;&gt;maybe instance type&lt;/a&gt; to your class and assign your instance to that property in your ref function.</source>
          <target state="translated">React允许您使用&lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt; &lt;code&gt;ref&lt;/code&gt; 函数&lt;/a&gt;获取元素或组件的实例。要使用ref函数，请将&lt;a href=&quot;https://flow.org/en/types/maybe/&quot;&gt;可能的实例类型&lt;/a&gt;添加到您的类中，然后将您的实例分配给ref函数中的该属性。</target>
        </trans-unit>
        <trans-unit id="ce33237a4802f75e813a38036292316d4ce2343b" translate="yes" xml:space="preserve">
          <source>React allows you to pass &lt;em&gt;any&lt;/em&gt; value as the children of a React component. There are some creative uses of this capability such as using a function for children which could look like this:</source>
          <target state="translated">React允许您传递&lt;em&gt;任何&lt;/em&gt;值作为React组件的子代。此功能有一些创造性的用途，例如为孩子使用一个功能，如下所示：</target>
        </trans-unit>
        <trans-unit id="177c1e000dc1d0316d4c2c3d73adf88cdc7bde20" translate="yes" xml:space="preserve">
          <source>React also supports default props on stateless functional components. Similarly to class components, default props for stateless functional components will work without any extra type annotations.</source>
          <target state="translated">React还支持无状态功能组件的默认道具。与类组件类似,无状态功能组件的默认道具无需任何额外的类型注解即可工作。</target>
        </trans-unit>
        <trans-unit id="b4a8bc5b355decd0225ee33bd0badaf612842a37" translate="yes" xml:space="preserve">
          <source>React class components will be the class instance. So if you had &lt;code&gt;class Foo extends React.Component&amp;lt;{}&amp;gt; {}&lt;/code&gt; and used &lt;code&gt;React.ElementRef&amp;lt;typeof Foo&amp;gt;&lt;/code&gt; then the type would be the instance of &lt;code&gt;Foo&lt;/code&gt;.</source>
          <target state="translated">React类组件将是类实例。因此，如果您有 &lt;code&gt;class Foo extends React.Component&amp;lt;{}&amp;gt; {}&lt;/code&gt; 并使用了 &lt;code&gt;React.ElementRef&amp;lt;typeof Foo&amp;gt;&lt;/code&gt; 则该类型将是 &lt;code&gt;Foo&lt;/code&gt; 的实例。</target>
        </trans-unit>
        <trans-unit id="c111454a8a259a2534472c017a3802fd7ccb4ddd" translate="yes" xml:space="preserve">
          <source>React elements can have zero, one, or many children. Being able to type these children with Flow allows you to build expressive APIs with React children.</source>
          <target state="translated">React元素可以有零个、一个或多个子元素。能够使用Flow键入这些子元素,让你可以用React子元素构建表达式API。</target>
        </trans-unit>
        <trans-unit id="007c7fdccd509ac94dc704a539b8aed206e42677" translate="yes" xml:space="preserve">
          <source>React exports a handful of utility types that may be useful to you when typing advanced React patterns. In previous sections we have seen a few of them. The following is a complete reference for each of these types along with some examples for how/where to use them.</source>
          <target state="translated">React导出了一些实用类型,在输入高级React模式时,这些类型可能对你有用。在前面的章节中,我们已经看到了其中的一些类型。下面是这些类型的完整参考,以及一些关于如何/在哪里使用它们的例子。</target>
        </trans-unit>
        <trans-unit id="83f2828960b3b5c2589074d8fb5ec48d203a2618" translate="yes" xml:space="preserve">
          <source>React stateless functional components do not have a backing instance and so &lt;code&gt;React.ElementRef&amp;lt;typeof Bar&amp;gt;&lt;/code&gt; (when &lt;code&gt;Bar&lt;/code&gt; is &lt;code&gt;function Bar() {}&lt;/code&gt;) will give you the undefined type.</source>
          <target state="translated">React无状态功能组件没有后备实例，因此 &lt;code&gt;React.ElementRef&amp;lt;typeof Bar&amp;gt;&lt;/code&gt; （当 &lt;code&gt;Bar&lt;/code&gt; 是 &lt;code&gt;function Bar() {}&lt;/code&gt; ）将为您提供未定义的类型。</target>
        </trans-unit>
        <trans-unit id="29ed07e15fc66a324459b85d24416800bceafaa3" translate="yes" xml:space="preserve">
          <source>React supports the notion of &lt;code&gt;defaultProps&lt;/code&gt; which you can think of as default function arguments. When you create an element and you did not include a prop with a default then React will substitute that prop with its corresponding value from &lt;code&gt;defaultProps&lt;/code&gt;. Flow supports this notion as well. To type default props add a &lt;code&gt;static defaultProps&lt;/code&gt; property to your class.</source>
          <target state="translated">React支持 &lt;code&gt;defaultProps&lt;/code&gt; 的概念，您可以将其视为默认函数参数。当你创建一个元素，并且没有包括道具用默认随即反应过来将取代该道具与它对应的值 &lt;code&gt;defaultProps&lt;/code&gt; 。Flow也支持此概念。要键入默认道具，请向您的类添加 &lt;code&gt;static defaultProps&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="70287cb5f65a904f3e064a37b30a5a631627d2e6" translate="yes" xml:space="preserve">
          <source>Read more about &lt;a href=&quot;variance&quot;&gt;property variance&lt;/a&gt;.</source>
          <target state="translated">阅读有关&lt;a href=&quot;variance&quot;&gt;属性差异的&lt;/a&gt;更多信息。</target>
        </trans-unit>
        <trans-unit id="61910c412c7b58b226db5d6ed180b312f69dc750" translate="yes" xml:space="preserve">
          <source>Reassigning unsealed object properties</source>
          <target state="translated">重新分配未密封的对象属性</target>
        </trans-unit>
        <trans-unit id="1bf2749de445e45162652ccf38c834bf918ba1b2" translate="yes" xml:space="preserve">
          <source>Reassigning variables</source>
          <target state="translated">重新分配变量</target>
        </trans-unit>
        <trans-unit id="d6101a7583b060dcae14c84065094e42d98e9a54" translate="yes" xml:space="preserve">
          <source>Recall that the instance type of a function component is &lt;code&gt;void&lt;/code&gt;. Our example above wraps a component in a function, so the returned component has the instance type &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">回想一下，功能组件的实例类型为 &lt;code&gt;void&lt;/code&gt; 。上面的示例在函数中包装了一个组件，因此返回的组件的实例类型为 &lt;code&gt;void&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dda31a027bfa36f4ca8585837d08aaa1912d41bf" translate="yes" xml:space="preserve">
          <source>Reducers</source>
          <target state="translated">Reducers</target>
        </trans-unit>
        <trans-unit id="1a5dd83d686967dbee491e598c66e203e42c8bea" translate="yes" xml:space="preserve">
          <source>Redux</source>
          <target state="translated">Redux</target>
        </trans-unit>
        <trans-unit id="7c12d3319cfff8593c41d6d684faf2f999524cf3" translate="yes" xml:space="preserve">
          <source>Redux state &lt;a href=&quot;http://redux.js.org/docs/introduction/ThreePrinciples.html#state-is-read-only&quot;&gt;is meant to be immutable&lt;/a&gt;: creating a new state object instead of changing properties on a single object.</source>
          <target state="translated">Redux状态&lt;a href=&quot;http://redux.js.org/docs/introduction/ThreePrinciples.html#state-is-read-only&quot;&gt;是不可变的&lt;/a&gt;：创建一个新的状态对象，而不是更改单个对象的属性。</target>
        </trans-unit>
        <trans-unit id="ed05f5c415303abb0d8305ee74bd6d2e8ce7eda3" translate="yes" xml:space="preserve">
          <source>Refinement Invalidations</source>
          <target state="translated">精炼无效</target>
        </trans-unit>
        <trans-unit id="43586e5f8885df744af66a163f9bd504927049f7" translate="yes" xml:space="preserve">
          <source>Refinement invalidation can also happen with &lt;a href=&quot;types/unions#toc-disjoint-unions&quot;&gt;disjoint unions&lt;/a&gt;. Any function call will invalidate any refinement.</source>
          <target state="translated">&lt;a href=&quot;types/unions#toc-disjoint-unions&quot;&gt;脱节的联合&lt;/a&gt;也可能发生优化失效。任何函数调用都将使任何优化无效。</target>
        </trans-unit>
        <trans-unit id="a02ef029699599da7905088f0dc103f214ced944" translate="yes" xml:space="preserve">
          <source>Refinements are a frequently used aspect of many type systems. They are so ingrained in the way that we program and even the way that we think you might not even notice them.</source>
          <target state="translated">精炼是许多类型系统中经常使用的一个方面。它们是如此根深蒂固地存在于我们编程的方式中,甚至是我们认为你可能根本没有注意到它们。</target>
        </trans-unit>
        <trans-unit id="0b89cb145cee7a8457a6e4dd2a97e9f0caac7219" translate="yes" xml:space="preserve">
          <source>Refinements can also come in other forms other than testing for equality:</source>
          <target state="translated">除了平等性测试外,细化还可以有其他形式。</target>
        </trans-unit>
        <trans-unit id="698e6391f48381c22849ea4013ae0a7dff98a9af" translate="yes" xml:space="preserve">
          <source>Refining Maybe types</source>
          <target state="translated">精炼可能类型</target>
        </trans-unit>
        <trans-unit id="9452f08c2e094961ce428c428ee0585501ce1d09" translate="yes" xml:space="preserve">
          <source>Remember that &lt;code&gt;boolean&lt;/code&gt; and &lt;code&gt;Boolean&lt;/code&gt; are different types.</source>
          <target state="translated">请记住， &lt;code&gt;boolean&lt;/code&gt; 和 &lt;code&gt;Boolean&lt;/code&gt; 是不同的类型。</target>
        </trans-unit>
        <trans-unit id="11f6d4fee5ab698ed0a3047ac64f1d9637774150" translate="yes" xml:space="preserve">
          <source>Remember that &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;Number&lt;/code&gt; are different types.</source>
          <target state="translated">请记住， &lt;code&gt;number&lt;/code&gt; 和 &lt;code&gt;Number&lt;/code&gt; 是不同的类型。</target>
        </trans-unit>
        <trans-unit id="55b41046e32661a87f2a8fd34325d7734f4d4cd1" translate="yes" xml:space="preserve">
          <source>Remember that &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; are different types.</source>
          <target state="translated">请记住， &lt;code&gt;string&lt;/code&gt; 和 &lt;code&gt;String&lt;/code&gt; 是不同的类型。</target>
        </trans-unit>
        <trans-unit id="09a428f93ec07a73d726f8bd037ecacfaaf8b044" translate="yes" xml:space="preserve">
          <source>Requirements</source>
          <target state="translated">Requirements</target>
        </trans-unit>
        <trans-unit id="3d6f80999c0c50a74e8acebc121f44bdbef82ae3" translate="yes" xml:space="preserve">
          <source>Requires Flow to be installed and available on your path.</source>
          <target state="translated">需要安装Flow并在您的路径上可用。</target>
        </trans-unit>
        <trans-unit id="33b4e56519b4614c59e8b72375bac3a885fdacaa" translate="yes" xml:space="preserve">
          <source>Requires JavaScript files to be marked with /* @flow */ at the top.</source>
          <target state="translated">要求JavaScript文件在顶部用/*@flow */标记。</target>
        </trans-unit>
        <trans-unit id="0a7c549205648d46b232d0e6177754a236939fcb" translate="yes" xml:space="preserve">
          <source>Requires projects containing JavaScript files to be initialised with flow init.</source>
          <target state="translated">要求包含JavaScript文件的项目使用flow init进行初始化。</target>
        </trans-unit>
        <trans-unit id="3e884a460b4d82c0f0401e11f902d2d3991a0a50" translate="yes" xml:space="preserve">
          <source>Rest Parameters</source>
          <target state="translated">休息参数</target>
        </trans-unit>
        <trans-unit id="7af6341ba4a77c200422ad48589bc5fcb0b569c3" translate="yes" xml:space="preserve">
          <source>Return types ensure that every branch of your function returns the same type. This prevents you from accidentally not returning a value under certain conditions.</source>
          <target state="translated">返回类型确保你的函数的每个分支都返回相同的类型。这可以防止你在某些条件下意外地不返回一个值。</target>
        </trans-unit>
        <trans-unit id="686039dfdbe08da5125ed6c00f4c1399d48dfd9b" translate="yes" xml:space="preserve">
          <source>Right, the &lt;code&gt;isLeapYear&lt;/code&gt; call in &lt;code&gt;src/LookBeforeYouLeap.js&lt;/code&gt; will typecheck, since the &lt;code&gt;year&lt;/code&gt; parameter expects a &lt;code&gt;string&lt;/code&gt; in the declaration file.</source>
          <target state="translated">正确， &lt;code&gt;src/LookBeforeYouLeap.js&lt;/code&gt; 中的 &lt;code&gt;isLeapYear&lt;/code&gt; 调用将进行类型检查，因为 &lt;code&gt;year&lt;/code&gt; 参数期望声明文件中包含 &lt;code&gt;string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="67d0f5e7710e2e8d6a977594f3101bc9772e4d34" translate="yes" xml:space="preserve">
          <source>Run the Flow Background Process</source>
          <target state="translated">运行流程背景过程</target>
        </trans-unit>
        <trans-unit id="61ba9e06d750a8c11a8c53dbe4b159704d49a040" translate="yes" xml:space="preserve">
          <source>Run this command at the top level of your project to create one, empty file called &lt;a href=&quot;https://flow.org/en/config/&quot;&gt;&lt;code&gt;.flowconfig&lt;/code&gt;&lt;/a&gt;. At its most basic level, &lt;code&gt;.flowconfig&lt;/code&gt; tells the Flow background process the root of where to begin checking Flow code for errors.</source>
          <target state="translated">在项目的最高级别运行此命令以创建一个名为&lt;a href=&quot;https://flow.org/en/config/&quot;&gt; &lt;code&gt;.flowconfig&lt;/code&gt; 的&lt;/a&gt;空文件。在最基本的层次上， &lt;code&gt;.flowconfig&lt;/code&gt; 告诉Flow后台进程从何处开始检查Flow代码是否存在错误的根。</target>
        </trans-unit>
        <trans-unit id="6e373532fbaa792fe51ef4bf5789af3104a5d987" translate="yes" xml:space="preserve">
          <source>Say you have the following directory structure, with your &lt;code&gt;.flowconfig&lt;/code&gt; in &lt;code&gt;mydir&lt;/code&gt;:</source>
          <target state="translated">假设您具有以下目录结构，其中 &lt;code&gt;.flowconfig&lt;/code&gt; 位于 &lt;code&gt;mydir&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="cd4baa0dfc8d959b9fb1e5d9e4810ee66a642362" translate="yes" xml:space="preserve">
          <source>Seal your intermediate results</source>
          <target state="translated">密封您的中间结果</target>
        </trans-unit>
        <trans-unit id="3bfb431a612a3027c31b75652ccf295595fa76b2" translate="yes" xml:space="preserve">
          <source>Sealed objects</source>
          <target state="translated">密封的物体</target>
        </trans-unit>
        <trans-unit id="554e5e25f0d86fc7d48da5b753f3b192e04d6a22" translate="yes" xml:space="preserve">
          <source>Second example:</source>
          <target state="translated">第二个例子:</target>
        </trans-unit>
        <trans-unit id="863a42ae0f0b0630cfee6b7740c09c1edf767d9c" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../utilities#toc-class&quot;&gt;here&lt;/a&gt; for details on &lt;code&gt;Class&amp;lt;T&amp;gt;&lt;/code&gt;, which allows you to refer to the type of the class in an annotation.</source>
          <target state="translated">有关 &lt;code&gt;Class&amp;lt;T&amp;gt;&lt;/code&gt; 详细信息，请参见&lt;a href=&quot;../utilities#toc-class&quot;&gt;此处&lt;/a&gt;，它允许您在批注中引用类的类型。</target>
        </trans-unit>
        <trans-unit id="5437018c74686a42995bf3c86f110c73dfb010d3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/facebook/flow/issues/5725&quot;&gt;this GitHub issue for the original motivation&lt;/a&gt;</source>
          <target state="translated">请参阅&lt;a href=&quot;https://github.com/facebook/flow/issues/5725&quot;&gt;此GitHub问题以获取原始动机&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e6fc3fca1eed93ff9d9a6c2799720ebdd64e3698" translate="yes" xml:space="preserve">
          <source>See also &lt;code&gt;[untyped]&lt;/code&gt;(untyped) for not typechecking files, and instead using &lt;code&gt;any&lt;/code&gt; for all contents.</source>
          <target state="translated">另请参见 &lt;code&gt;[untyped]&lt;/code&gt; （未键入）以了解是否不对文件进行类型检查，而是对所有内容使用 &lt;code&gt;any&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d10cc1add2564282fb8d240521737d52d850d2d5" translate="yes" xml:space="preserve">
          <source>See how we added &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;SomeOtherComponent&amp;gt;&lt;/code&gt; as children to &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt;? This is not allowed and &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; will throw an error. How do we make sure Flow does not allow this pattern?</source>
          <target state="translated">看看我们如何将 &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;SomeOtherComponent&amp;gt;&lt;/code&gt; 作为子级添加到 &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; ？这是不允许的， &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; 将引发错误。我们如何确保Flow不允许这种模式？</target>
        </trans-unit>
        <trans-unit id="f741f4c166b4ccd4d41f13a13dece778f73df85a" translate="yes" xml:space="preserve">
          <source>Select &amp;lsquo;Flow for Sublime Text 2 and 3&amp;rsquo; to install</source>
          <target state="translated">选择&amp;ldquo;用于Sublime Text 2和3的流程&amp;rdquo;进行安装</target>
        </trans-unit>
        <trans-unit id="e6b4c56f97df36a6ecd6ed02f0d6868208b5ab27" translate="yes" xml:space="preserve">
          <source>Select Package Control: Install Package</source>
          <target state="translated">选择软件包控制。安装包</target>
        </trans-unit>
        <trans-unit id="8d4e3440a48420d6cf0f3379e89fee66456a0ae3" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;automatic&lt;/code&gt; if you are using React&amp;rsquo;s automatic runtime in &lt;code&gt;@babel/plugin-transform-react-jsx&lt;/code&gt;. Otherwise, use &lt;code&gt;classic&lt;/code&gt;. &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-react-jsx&quot;&gt;See the babel documentation&lt;/a&gt; for details about the transform.</source>
          <target state="translated">如果您在 &lt;code&gt;@babel/plugin-transform-react-jsx&lt;/code&gt; 中使用React的自动运行时，请将其设置为 &lt;code&gt;automatic&lt;/code&gt; 。否则，请使用 &lt;code&gt;classic&lt;/code&gt; 。&lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-react-jsx&quot;&gt;有关&lt;/a&gt;转换的详细信息，请参见babel文档。</target>
        </trans-unit>
        <trans-unit id="5a51c55e03c6fe62b671bf2a091c73c068704caf" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;enable&lt;/code&gt; to indicate that Flow should support the &lt;code&gt;export * as&lt;/code&gt; syntax from &lt;a href=&quot;https://github.com/leebyron/ecmascript-more-export-from&quot;&gt;leebyron&amp;rsquo;s proposal&lt;/a&gt;.</source>
          <target state="translated">将其设置为 &lt;code&gt;enable&lt;/code&gt; ，表明流动应该支持 &lt;code&gt;export * as&lt;/code&gt; 从语法&lt;a href=&quot;https://github.com/leebyron/ecmascript-more-export-from&quot;&gt;leebyron的建议&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d2f2f8212166435e1e26351a8d0075e389cfc197" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;enable&lt;/code&gt; to indicate that Flow should support the use of &lt;a href=&quot;https://github.com/tc39/proposal-nullish-coalescing&quot;&gt;nullish coalescing&lt;/a&gt; per the pending spec.</source>
          <target state="translated">设置此选项以 &lt;code&gt;enable&lt;/code&gt; 以指示Flow应该支持根据挂起的规范使用&lt;a href=&quot;https://github.com/tc39/proposal-nullish-coalescing&quot;&gt;无效合并&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5ffd0d476596e4beacfa43c710cc9eca05a02fef" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;enable&lt;/code&gt; to indicate that Flow should support the use of &lt;a href=&quot;https://github.com/tc39/proposal-optional-chaining&quot;&gt;optional chaining&lt;/a&gt; per the pending spec.</source>
          <target state="translated">设置此选项以 &lt;code&gt;enable&lt;/code&gt; 以指示Flow应支持根据待定规范使用&lt;a href=&quot;https://github.com/tc39/proposal-optional-chaining&quot;&gt;可选链接&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a791224e1e0c6173296867136f2701fa594c4db9" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;ignore&lt;/code&gt; to indicate that Flow should ignore decorators.</source>
          <target state="translated">将此设置为 &lt;code&gt;ignore&lt;/code&gt; 以指示Flow应该忽略装饰器。</target>
        </trans-unit>
        <trans-unit id="7252ab4a3a45b3b2cf1e24f49aebbbc8df2bea70" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; and Flow will no longer complain when you use &lt;code&gt;require()&lt;/code&gt; with something other than a string literal.</source>
          <target state="translated">将其设置为 &lt;code&gt;true&lt;/code&gt; ，当您将 &lt;code&gt;require()&lt;/code&gt; 与字符串文字以外的内容一起使用时，Flow将不再抱怨。</target>
        </trans-unit>
        <trans-unit id="17b19723fab321f07b8d03e9886bc4fd290afff7" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; if you use a transpiler that adds &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; to the top of every module.</source>
          <target state="translated">如果您使用添加了 &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; 的编译器，则将其设置为 &lt;code&gt;true&lt;/code&gt; ;否则，请将其设置为true 。到每个模块的顶部</target>
        </trans-unit>
        <trans-unit id="8f7810533f5b1afdbd99345ceeeb8bb80fe383b5" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; to add emoji to the status messages that Flow outputs when it&amp;rsquo;s busy checking your project.</source>
          <target state="translated">将此属性设置为 &lt;code&gt;true&lt;/code&gt; 可将表情符号添加到Flow在忙于检查项目时输出的状态消息中。</target>
        </trans-unit>
        <trans-unit id="0a9e20b6f9ef8f6259569858fa3254651f50988f" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; to check all files, not just those with &lt;code&gt;@flow&lt;/code&gt;.</source>
          <target state="translated">将其设置为 &lt;code&gt;true&lt;/code&gt; 可检查所有文件，而不仅仅是带有 &lt;code&gt;@flow&lt;/code&gt; 的文件。</target>
        </trans-unit>
        <trans-unit id="d2763696664697d56a9bd55ceed56c975dbfc607" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; to check that array spread syntax is only used with arrays, not arbitrary iterables (such as &lt;code&gt;Map&lt;/code&gt; or &lt;code&gt;Set&lt;/code&gt;). This is useful if you transform your code with Babel in &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-spread#loose&quot;&gt;loose mode&lt;/a&gt; which makes this non-spec-compliant assumption at runtime.</source>
          <target state="translated">将其设置为 &lt;code&gt;true&lt;/code&gt; 可以检查数组扩展语法仅用于数组，而不用于任意可迭代对象（例如 &lt;code&gt;Map&lt;/code&gt; 或 &lt;code&gt;Set&lt;/code&gt; ）。如果您在&lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-spread#loose&quot;&gt;宽松模式下&lt;/a&gt;使用Babel转换代码，这在运行时做出了不符合规范的假设，则这很有用。</target>
        </trans-unit>
        <trans-unit id="632e3852195a2720cf86c3695ec9f34205f83f66" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; to have Flow treat underscore-prefixed class properties and methods as private. This should be used in conjunction with &lt;a href=&quot;https://github.com/facebook/jstransform/blob/master/visitors/es6-class-visitors.js&quot;&gt;&lt;code&gt;jstransform&lt;/code&gt;&amp;rsquo;s ES6 class transform&lt;/a&gt;, which enforces the same privacy at runtime.</source>
          <target state="translated">将此属性设置为 &lt;code&gt;true&lt;/code&gt; 可使Flow将下划线前缀的类属性和方法视为私有。这应该与&lt;a href=&quot;https://github.com/facebook/jstransform/blob/master/visitors/es6-class-visitors.js&quot;&gt; &lt;code&gt;jstransform&lt;/code&gt; 的ES6类转换&lt;/a&gt;结合使用，该转换可在运行时实施相同的隐私保护。</target>
        </trans-unit>
        <trans-unit id="c35c47e5290b31d5376f35f006e7cd6e182798e4" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; to indicate that Flow should interpret object types as exact by default. When this flag is &lt;code&gt;false&lt;/code&gt;, Flow has the following behavior:</source>
          <target state="translated">将此属性设置为 &lt;code&gt;true&lt;/code&gt; 表示Flow默认情况下应将对象类型解释为精确的。当此标志为 &lt;code&gt;false&lt;/code&gt; 时，Flow具有以下行为：</target>
        </trans-unit>
        <trans-unit id="0b6026d788e6990fc2b88f5d97a8a7e72d548d84" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;warn&lt;/code&gt; to indicate that Flow should give a warning on use of instance &lt;a href=&quot;https://github.com/tc39/proposal-class-public-fields&quot;&gt;class fields&lt;/a&gt; per the pending spec.</source>
          <target state="translated">将其设置为 &lt;code&gt;warn&lt;/code&gt; 以指示Flow应该根据挂起的规范对使用实例&lt;a href=&quot;https://github.com/tc39/proposal-class-public-fields&quot;&gt;类字段&lt;/a&gt;给出警告。</target>
        </trans-unit>
        <trans-unit id="5a95e4b769085b845d2cd025dba547c259b83a10" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;warn&lt;/code&gt; to indicate that Flow should give a warning on use of static &lt;a href=&quot;https://github.com/tc39/proposal-class-public-fields&quot;&gt;class fields&lt;/a&gt; per the pending spec.</source>
          <target state="translated">设置为 &lt;code&gt;warn&lt;/code&gt; 以指示Flow应该根据挂起的规范警告使用静态&lt;a href=&quot;https://github.com/tc39/proposal-class-public-fields&quot;&gt;类字段&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3723576f1e23f9a6be80dfc2da353444ecba4fa5" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;lazy_mode&lt;/code&gt; in the &lt;code&gt;.flowconfig&lt;/code&gt; will cause new Flow servers for that root to use that lazy mode (or no lazy mode if set to &lt;code&gt;none&lt;/code&gt;). This option can be overridden from the CLI using the &lt;code&gt;--lazy-mode&lt;/code&gt; flag.</source>
          <target state="translated">设置 &lt;code&gt;lazy_mode&lt;/code&gt; 在 &lt;code&gt;.flowconfig&lt;/code&gt; 会造成新的流程服务器为根，以使用懒人模式（或没有偷懒模式如果设置为 &lt;code&gt;none&lt;/code&gt; ）。可以使用 &lt;code&gt;--lazy-mode&lt;/code&gt; 标志从CLI覆盖此选项。</target>
        </trans-unit>
        <trans-unit id="f8742e5ede9ca0ab99281256cb0a8da2b2abf5c7" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;sketchy-null&lt;/code&gt; sets the level for all sketchy null checks, but there are more granular rules for particular types. These are:</source>
          <target state="translated">设置 &lt;code&gt;sketchy-null&lt;/code&gt; 可以设置所有粗略null检查的级别，但是对于特定类型，存在更细化的规则。这些是：</target>
        </trans-unit>
        <trans-unit id="4dbac04babde4f94fd1324574fc30f6647291c38" translate="yes" xml:space="preserve">
          <source>Setting this option to X means the table will support up to 2^X elements, which is 16*2^X bytes.</source>
          <target state="translated">将此选项设置为X意味着该表最多支持2^X元素,即16*2^X字节。</target>
        </trans-unit>
        <trans-unit id="6f8b6166467119123c34cb8d2a8307f8f72ae96e" translate="yes" xml:space="preserve">
          <source>Setting this to 1 will cause Flow to output some stats about the data that is serialized into and deserialized out of shared memory.</source>
          <target state="translated">将此设置为1,将使Flow输出一些关于序列化进入和反序列化出共享内存的数据的统计信息。</target>
        </trans-unit>
        <trans-unit id="3907024420fe6565a297982966b2459dd6dc6639" translate="yes" xml:space="preserve">
          <source>Setting this to &lt;code&gt;true&lt;/code&gt; makes Flow commands include warnings in the error output. Warnings are hidden by default in the CLI to avoid console spew. (An IDE is a much better interface to show warnings.)</source>
          <target state="translated">将此设置为 &lt;code&gt;true&lt;/code&gt; 将使Flow命令在错误输出中包括警告。默认情况下，警告在CLI中是隐藏的，以避免控制台喷涌。（IDE是显示警告的更好的界面。）</target>
        </trans-unit>
        <trans-unit id="a78591e430fc75d428e63794ccb099ae8c20961b" translate="yes" xml:space="preserve">
          <source>Setting this to &lt;code&gt;true&lt;/code&gt; makes Flow treat all function parameters as const bindings. Reassigning a param is an error which lets Flow be less conservative with refinements.</source>
          <target state="translated">将此设置为 &lt;code&gt;true&lt;/code&gt; 可使Flow将所有函数参数视为const绑定。重新分配参数是一个错误，它使Flow在优化时不那么保守。</target>
        </trans-unit>
        <trans-unit id="c2da3d4ed1af623cc4e8b8d52d8edb981c85d346" translate="yes" xml:space="preserve">
          <source>Setting up &amp;ldquo;boundaries&amp;rdquo; with your types means you can tell Flow your intent on top of the inference it already does.</source>
          <target state="translated">使用类型设置&amp;ldquo;边界&amp;rdquo;意味着您可以在已经进行的推理之上告诉Flow您的意图。</target>
        </trans-unit>
        <trans-unit id="cdd7bb2816b7a8f88bce0e47be39943bc369516b" translate="yes" xml:space="preserve">
          <source>Setup</source>
          <target state="translated">Setup</target>
        </trans-unit>
        <trans-unit id="7133d91a35c40bcb71979c3896fc1deb038a8a20" translate="yes" xml:space="preserve">
          <source>Setup Flow with React</source>
          <target state="translated">使用React的设置流程</target>
        </trans-unit>
        <trans-unit id="7330bdb6aab9d47b6f4302ca23a0b1d1a997ea7d" translate="yes" xml:space="preserve">
          <source>Severity Levels and Meanings</source>
          <target state="translated">嚴重程度和意義</target>
        </trans-unit>
        <trans-unit id="9ef912b88879662392f8c53fad059d3c74586282" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#toc-react-componenttype&quot;&gt;&lt;code&gt;React.ComponentType&amp;lt;Props&amp;gt;&lt;/code&gt;&lt;/a&gt; except it also includes JSX intrinsics (strings).</source>
          <target state="translated">与&lt;a href=&quot;#toc-react-componenttype&quot;&gt; &lt;code&gt;React.ComponentType&amp;lt;Props&amp;gt;&lt;/code&gt; &lt;/a&gt;相似，除了它还包含JSX内部函数（字符串）。</target>
        </trans-unit>
        <trans-unit id="ad9df7675219090b45a68675090f8c88c2996d47" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;../utilities#toc-readonly&quot;&gt;&lt;code&gt;$ReadOnly&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, it is the supertype of all arrays and all tuples and represents a read-only view of an array. It does not contain any methods that will allow an object of this type to be mutated (no &lt;code&gt;push()&lt;/code&gt;, &lt;code&gt;pop()&lt;/code&gt;, etc.).</source>
          <target state="translated">与&lt;a href=&quot;../utilities#toc-readonly&quot;&gt; &lt;code&gt;$ReadOnly&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;相似，它是所有数组和所有元组的超类型，并表示数组的只读视图。它不包含任何允许对该类型的对象进行突变的方法（没有 &lt;code&gt;push()&lt;/code&gt; ， &lt;code&gt;pop()&lt;/code&gt; 等）。</target>
        </trans-unit>
        <trans-unit id="7e25832c7fbfc04c711346a40af98680a99ba4e4" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;../variables#toc-reassigning-variables&quot;&gt;&lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; variables&lt;/a&gt; if you reassign a property of an unsealed object, by default Flow will give it the type of all possible assignments.</source>
          <target state="translated">如果您重新分配未密封对象的属性，则类似于&lt;a href=&quot;../variables#toc-reassigning-variables&quot;&gt; &lt;code&gt;var&lt;/code&gt; 和 &lt;code&gt;let&lt;/code&gt; 变量&lt;/a&gt;，默认情况下，Flow将为它提供所有可能分配的类型。</target>
        </trans-unit>
        <trans-unit id="8ccc6ec56ed0f7579fe7c1219285baf1e414f25d" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;const&lt;/code&gt;, Flow can either infer the type from the value you are assigning to it or you can provide it with a type:</source>
          <target state="translated">与 &lt;code&gt;const&lt;/code&gt; 相似，Flow可以从您为其分配的值中推断类型，也可以为其提供类型：</target>
        </trans-unit>
        <trans-unit id="31cdc6274e2048217641f19c7436522e7c83902e" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;mixed&lt;/code&gt;, generics have an &amp;ldquo;unknown&amp;rdquo; type. You&amp;rsquo;re not allowed to use a generic as if it were a specific type.</source>
          <target state="translated">与 &lt;code&gt;mixed&lt;/code&gt; 相似，泛型具有&amp;ldquo;未知&amp;rdquo;类型。不允许将泛型当作特定类型使用。</target>
        </trans-unit>
        <trans-unit id="6f53a1bfd2499be63c34f7067d2986e44abdec95" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; can be re-assigned, there&amp;rsquo;s a few more rules you&amp;rsquo;ll need to know about.</source>
          <target state="translated">由于可以重新分配 &lt;code&gt;var&lt;/code&gt; 和 &lt;code&gt;let&lt;/code&gt; ，因此您需要了解一些其他规则。</target>
        </trans-unit>
        <trans-unit id="339082925233909f355d06179fa3b6b26ccf7865" translate="yes" xml:space="preserve">
          <source>Since Flow does not know the length of an array, an &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; type cannot be passed into a tuple.</source>
          <target state="translated">由于Flow不知道数组的长度，因此无法将 &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; 类型传递给元组。</target>
        </trans-unit>
        <trans-unit id="decf7e18c6fe06fc86a8a5bc89a669829d507c85" translate="yes" xml:space="preserve">
          <source>Since a &lt;code&gt;const&lt;/code&gt; variable cannot be re-assigned at a later time it is fairly simple.</source>
          <target state="translated">由于不能在以后重新分配 &lt;code&gt;const&lt;/code&gt; 变量，因此非常简单。</target>
        </trans-unit>
        <trans-unit id="8c614b00ece097ea225988eb96c38c1dc27bdcf2" translate="yes" xml:space="preserve">
          <source>Since the parameter &lt;code&gt;arr&lt;/code&gt; of the &lt;code&gt;someOperation&lt;/code&gt; function is typed as a mutable &lt;code&gt;Array&lt;/code&gt;, pushing a string into it would be possible inside that scope, which would then break the type contract of the outside &lt;code&gt;array&lt;/code&gt; variable. By annotating the parameter as &lt;code&gt;$ReadOnlyArray&lt;/code&gt; instead in this case, Flow can be sure this won&amp;rsquo;t happen and no errors will occur:</source>
          <target state="translated">由于参数 &lt;code&gt;arr&lt;/code&gt; 所述的 &lt;code&gt;someOperation&lt;/code&gt; 函数的类型为一个可变的 &lt;code&gt;Array&lt;/code&gt; ，推一个字符串转换为有可能内部的范围，然后将打破以外的类型的合同 &lt;code&gt;array&lt;/code&gt; 变量。在这种情况下，通过将参数注释为 &lt;code&gt;$ReadOnlyArray&lt;/code&gt; ，Flow可以确保不会发生这种情况并且不会发生任何错误：</target>
        </trans-unit>
        <trans-unit id="a1785a5e0b243285a1963526da42f273c5dc42f7" translate="yes" xml:space="preserve">
          <source>So a single array child is left alone, but what happens if we have multiple children that are arrays?</source>
          <target state="translated">所以单个数组的子代就不用管了,但如果我们有多个子代是数组,会怎么样呢?</target>
        </trans-unit>
        <trans-unit id="a70bd7a3ca7dbd388181ff69fc1a9d9059244ca3" translate="yes" xml:space="preserve">
          <source>So far, we support the following ways to specify supported versions</source>
          <target state="translated">到目前为止,我们支持以下方式来指定支持的版本</target>
        </trans-unit>
        <trans-unit id="64c91e3d58f11315a8f98d01485d70281a6c3678" translate="yes" xml:space="preserve">
          <source>So if Flow sees this in the &lt;code&gt;.flowconfig&lt;/code&gt;:</source>
          <target state="translated">因此，如果Flow在 &lt;code&gt;.flowconfig&lt;/code&gt; 中看到此消息：</target>
        </trans-unit>
        <trans-unit id="9eb921ba09ace5711e414821fe52adee56f0c3ff" translate="yes" xml:space="preserve">
          <source>So if I write a function that expects the numbers 1 through 5, any subtype of that set will be acceptable.</source>
          <target state="translated">因此,如果我写一个期望数字1到5的函数,该集合的任何子类型都可以接受。</target>
        </trans-unit>
        <trans-unit id="0e8b161db695089b318d824534a1f60ea4c81045" translate="yes" xml:space="preserve">
          <source>So if you have the following in your &lt;code&gt;.flowconfig&lt;/code&gt;:</source>
          <target state="translated">因此，如果您在 &lt;code&gt;.flowconfig&lt;/code&gt; 中包含以下内容：</target>
        </trans-unit>
        <trans-unit id="85f50aa3f8aa1b205c54f2530dfd25375a26cc15" translate="yes" xml:space="preserve">
          <source>So in the following example, &lt;code&gt;obj2&lt;/code&gt; is a &lt;em&gt;subtype&lt;/em&gt; of &lt;code&gt;obj1&lt;/code&gt;.</source>
          <target state="translated">因此，在下面的例子中， &lt;code&gt;obj2&lt;/code&gt; 的是一个&lt;em&gt;亚型&lt;/em&gt;的 &lt;code&gt;obj1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd21dd92e8bb38520c7aed585ce5c138a49e1e9e" translate="yes" xml:space="preserve">
          <source>So, for example, if you want to know more about how the autocomplete works, you can use this command:</source>
          <target state="translated">因此,举例来说,如果你想知道更多关于自动完成的工作原理,你可以使用这个命令。</target>
        </trans-unit>
        <trans-unit id="32f718b68766575b95119fe1d6ed7b79b6857e82" translate="yes" xml:space="preserve">
          <source>Some examples of suppression comments:</source>
          <target state="translated">一些压制评论的例子。</target>
        </trans-unit>
        <trans-unit id="6a5040bb6c58acac2d87c681ffa0099ee5ad8294" translate="yes" xml:space="preserve">
          <source>Sometimes Flow is able to figure out (with certainty) the type of a property after reassignment. In that case, Flow will give it the known type.</source>
          <target state="translated">有时,Flow能够在重新分配后找出(确定)一个属性的类型。在这种情况下,Flow会给它已知的类型。</target>
        </trans-unit>
        <trans-unit id="8cbd2e30f0fd2935872139edbe248c42b74f633b" translate="yes" xml:space="preserve">
          <source>Sometimes Flow is able to figure out (with certainty) the type of a variable after re-assignment. In that case, Flow will give it the known type.</source>
          <target state="translated">有时,Flow能够在重新赋值后找出(确定)一个变量的类型。在这种情况下,Flow会给它已知的类型。</target>
        </trans-unit>
        <trans-unit id="190aedcaebf30683452cc18021384bd29eb893ec" translate="yes" xml:space="preserve">
          <source>Sometimes Flow&amp;rsquo;s inference will create types that are more permissive than you want them to be.</source>
          <target state="translated">有时，Flow的推理会创建比您希望的类型更宽松的类型。</target>
        </trans-unit>
        <trans-unit id="bf2bc69b7d682ca6d088a661a2cccdb41226e95b" translate="yes" xml:space="preserve">
          <source>Sometimes it is useful to assert a type without using something like a function or a variable to do so. For this Flow supports an inline type cast expression syntax which can be used in a number of different ways.</source>
          <target state="translated">有时,不使用函数或变量来断言一个类型是很有用的。对于这种情况,Flow支持一种内联类型转换表达式语法,它可以以多种不同的方式使用。</target>
        </trans-unit>
        <trans-unit id="05acde073f433e3ebdb05840c280af6194f4f161" translate="yes" xml:space="preserve">
          <source>Sometimes it is useful to create a type which is &lt;strong&gt;&lt;em&gt;all of&lt;/em&gt;&lt;/strong&gt; a set of other types. For example, you might want to write a function which accepts an object which is the combination of other object types. For this, Flow supports &lt;strong&gt;intersection types&lt;/strong&gt;.</source>
          <target state="translated">有时创建一个包含&lt;strong&gt;&lt;em&gt;所有&lt;/em&gt;&lt;/strong&gt;其他类型集合的类型很有用。例如，您可能想编写一个函数，该函数接受一个对象，该对象是其他对象类型的组合。为此，Flow支持&lt;strong&gt;交集类型&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="508d0f1b6949c54ce48ed8515843765f74b1ff2c" translate="yes" xml:space="preserve">
          <source>Sometimes it is useful to disable this behavior and only allow a specific set of properties. For this, Flow supports &amp;ldquo;exact&amp;rdquo; object types.</source>
          <target state="translated">有时禁用此行为并仅允许一组特定的属性很有用。为此，Flow支持&amp;ldquo;精确&amp;rdquo;对象类型。</target>
        </trans-unit>
        <trans-unit id="7e197db0c5e7c34ea4bc888687f7a0d82f7f2217" translate="yes" xml:space="preserve">
          <source>Sometimes it is useful to make declarations inline, as part of the source of an implementation file.</source>
          <target state="translated">有时,在实现文件的源文件中内联声明是很有用的。</target>
        </trans-unit>
        <trans-unit id="4b7f2e42ec427dfe19e7546bbfa4cb1df144aec0" translate="yes" xml:space="preserve">
          <source>Sometimes it is useful to write types that accept arbitrary functions, for those you should write &lt;code&gt;() =&amp;gt; mixed&lt;/code&gt; like this:</source>
          <target state="translated">有时，编写接受任意函数的类型很有用，对于那些您应该编写 &lt;code&gt;() =&amp;gt; mixed&lt;/code&gt; 如下所示：</target>
        </trans-unit>
        <trans-unit id="0d699df94c70d270a74922c6dd7a75522ca1022c" translate="yes" xml:space="preserve">
          <source>Sometimes it is useful to write types that accept arbitrary objects, for those you should write &lt;code&gt;{}&lt;/code&gt; like this:</source>
          <target state="translated">有时，编写接受任意对象的类型很有用，对于那些您应该这样写 &lt;code&gt;{}&lt;/code&gt; 的对象：</target>
        </trans-unit>
        <trans-unit id="48c4be69fd7d7e116bfe9fff8287e72150b14b65" translate="yes" xml:space="preserve">
          <source>Sometimes it&amp;rsquo;s useful to create a type which is &lt;strong&gt;&lt;em&gt;one of&lt;/em&gt;&lt;/strong&gt; a set of other types. For example, you might want to write a function which accepts a set of primitive value types. For this Flow supports &lt;strong&gt;union types&lt;/strong&gt;.</source>
          <target state="translated">有时创建一个类型是其他类型&lt;strong&gt;&lt;em&gt;之一是&lt;/em&gt;&lt;/strong&gt;很有用的。例如，您可能想编写一个接受一组原始值类型的函数。为此，Flow支持&lt;strong&gt;联合类型&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="56e08cb76776b6d22c74c00289b74deb8fcafaba" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to ignore all files inside a directory with the exception of a few. An optional prefix &amp;ldquo;!&amp;rdquo; which negates the pattern may help. With this, any matching file excluded by a previous pattern will become included again.</source>
          <target state="translated">有时您可能想忽略目录中的所有文件，只有少数几个例外。可选的前缀&amp;ldquo;！&amp;rdquo; 否定模式可能会有所帮助。这样，先前模式排除的所有匹配文件将再次包含在内。</target>
        </trans-unit>
        <trans-unit id="079287524f7de17d8166e352d620ee09cbcee756" translate="yes" xml:space="preserve">
          <source>Sometimes you only want a specific component as the children to your React component. This often happens when you are building a table component which needs specific column children components, or a tab bar which needs specific configuration for each tab. One such tab bar component that uses this pattern is React Native&amp;rsquo;s &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; component.</source>
          <target state="translated">有时，您只希望将特定组件用作React组件的子代。当您构建需要特定列子组件的表组件或需要为每个选项卡进行特定配置的选项卡栏时，通常会发生这种情况。一种使用这种模式的选项卡栏组件是React Native的 &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; 组件。</target>
        </trans-unit>
        <trans-unit id="0ca3345128fc09227a3fc76aff4497f80cecc7db" translate="yes" xml:space="preserve">
          <source>Sometimes you want to enforce that your component will &lt;em&gt;only&lt;/em&gt; receive a single child. You could use &lt;a href=&quot;https://facebook.github.io/react/docs/react-api.html#react.children.only&quot;&gt;&lt;code&gt;React.Children.only()&lt;/code&gt; function&lt;/a&gt; to enforce this constraint, but you could also enforce this in Flow. To do this you would not wrap the type for your children in &lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt;&lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. Like so:</source>
          <target state="translated">有时您想强制您的组件将&lt;em&gt;只&lt;/em&gt;接收一个孩子。您可以使用&lt;a href=&quot;https://facebook.github.io/react/docs/react-api.html#react.children.only&quot;&gt; &lt;code&gt;React.Children.only()&lt;/code&gt; 函数&lt;/a&gt;强制执行此约束，但也可以在Flow中强制执行此约束。为此，您不会将孩子的类型包装在&lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt; &lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;。像这样：</target>
        </trans-unit>
        <trans-unit id="9c3a1440695c1cfe2882e899cdcec139639bb34e" translate="yes" xml:space="preserve">
          <source>Sometimes you want to enforce that your component will &lt;em&gt;only&lt;/em&gt; receive a single child. You could use &lt;a href=&quot;https://facebook.github.io/react/docs/react-api.html#react.children.only&quot;&gt;&lt;code&gt;React.Children.only()&lt;/code&gt; function&lt;/a&gt; to enforce this constraint, but you could also enforce this in Flow. To do this, instead of wrapping the type for your children in &lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt;&lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, specify a single element argument, like so:</source>
          <target state="translated">有时您想强制您的组件将&lt;em&gt;只&lt;/em&gt;接收一个孩子。您可以使用&lt;a href=&quot;https://facebook.github.io/react/docs/react-api.html#react.children.only&quot;&gt; &lt;code&gt;React.Children.only()&lt;/code&gt; 函数&lt;/a&gt;强制执行此约束，但也可以在Flow中强制执行此约束。为此，不要将单个孩子的类型包装在&lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt; &lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;，而是指定一个元素参数，如下所示：</target>
        </trans-unit>
        <trans-unit id="0204e6779dafad940b69a188f3ba177a640b8f57" translate="yes" xml:space="preserve">
          <source>Sometimes you will want to move the condition from an &lt;code&gt;if&lt;/code&gt; statement into a function:</source>
          <target state="translated">有时您会希望将条件从 &lt;code&gt;if&lt;/code&gt; 语句移至函数中：</target>
        </trans-unit>
        <trans-unit id="e54a11047f43ee69df389e7749159027d890696d" translate="yes" xml:space="preserve">
          <source>Soundness and Completeness</source>
          <target state="translated">健全性和完整性</target>
        </trans-unit>
        <trans-unit id="746df4e9e7a562d767f5e24a05664f4a720c7f81" translate="yes" xml:space="preserve">
          <source>Soundness is fine as long as Flow isn&amp;rsquo;t being too noisy and preventing you from being productive. Sometimes when soundness would get in your way too much, Flow will favor completeness instead. There&amp;rsquo;s only a handful of cases where Flow does this.</source>
          <target state="translated">只要Flow不会过于嘈杂并阻止您提高工作效率，声音就很好。有时，当稳健性过多地妨碍您时，Flow会偏爱完整性。在少数情况下，Flow会这样做。</target>
        </trans-unit>
        <trans-unit id="0490059ec84f1bbf6b567a4e9c26b3a680460a91" translate="yes" xml:space="preserve">
          <source>Specify a file extension to match, and a replacement module name, separated by a &lt;code&gt;-&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">指定要匹配的文件扩展名和替换模块名称，用 &lt;code&gt;-&amp;gt;&lt;/code&gt; 分隔。</target>
        </trans-unit>
        <trans-unit id="c23f789b3f6c7eff8cfdc73ee793e9e6cd434ab2" translate="yes" xml:space="preserve">
          <source>Specify a regular expression to match against module names, and a replacement pattern, separated by a &lt;code&gt;-&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">指定正则表达式以与模块名称匹配，并指定替换模式，并用 &lt;code&gt;-&amp;gt;&lt;/code&gt; 分隔。</target>
        </trans-unit>
        <trans-unit id="2d2cb022bc3d26bd1407c4aa787d5e46e1ad4c3b" translate="yes" xml:space="preserve">
          <source>Speed</source>
          <target state="translated">Speed</target>
        </trans-unit>
        <trans-unit id="3b2886d5473db8f2728b89b52d94f9b866760285" translate="yes" xml:space="preserve">
          <source>Start the &lt;a href=&quot;#toc-run-the-flow-background-process&quot;&gt;Flow background process&lt;/a&gt; with &lt;code&gt;flow&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;flow&lt;/code&gt; 启动&lt;a href=&quot;#toc-run-the-flow-background-process&quot;&gt;Flow后台进程&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="33040dda5793f74572e67f14abdfb073ecb04f28" translate="yes" xml:space="preserve">
          <source>Starting with Flow v0.23.0, you may use the &lt;code&gt;&amp;lt;PROJECT_ROOT&amp;gt;&lt;/code&gt; placeholder in your regular expressions. At runtime, Flow will treat the placeholder as if it were the absolute path to the project&amp;rsquo;s root directory. This is useful for writing regular expressions that are relative rather than absolute.</source>
          <target state="translated">从Flow v0.23.0开始，您可以在正则表达式中使用 &lt;code&gt;&amp;lt;PROJECT_ROOT&amp;gt;&lt;/code&gt; 占位符。在运行时，Flow将占位符视为它是项目根目录的绝对路径。这对于编写相对而不是绝对的正则表达式很有用。</target>
        </trans-unit>
        <trans-unit id="a72502067518684f9deeec70cf119fd26326cd33" translate="yes" xml:space="preserve">
          <source>State</source>
          <target state="translated">State</target>
        </trans-unit>
        <trans-unit id="62b1fce124c3fa807ff7f42885010e1fc39fe39d" translate="yes" xml:space="preserve">
          <source>Stateless Functional Components</source>
          <target state="translated">无状态功能组件</target>
        </trans-unit>
        <trans-unit id="2f0b1209b659172e1b117e95bf918d52ef746c97" translate="yes" xml:space="preserve">
          <source>Statements manipulating &lt;code&gt;module.exports&lt;/code&gt; and the &lt;code&gt;exports&lt;/code&gt; alias may only appear as top-level statements.</source>
          <target state="translated">声明操纵 &lt;code&gt;module.exports&lt;/code&gt; 和 &lt;code&gt;exports&lt;/code&gt; 别名可能仅显示为顶级报表。</target>
        </trans-unit>
        <trans-unit id="8ab6b0ce50387fe5c38a665805e317164318c6cd" translate="yes" xml:space="preserve">
          <source>Strict Local</source>
          <target state="translated">严格的地方</target>
        </trans-unit>
        <trans-unit id="984e1a2ea44698c9bc621d3cc2a46a2ebbfcffdb" translate="yes" xml:space="preserve">
          <source>Strictly enforced tuple length (arity)</source>
          <target state="translated">严格执行元组长度(arity)。</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="b5c84f808b85754e46cef96360cc97ceca30a211" translate="yes" xml:space="preserve">
          <source>Strings are &lt;code&gt;&quot;foo&quot;&lt;/code&gt; values in JavaScript. The &lt;code&gt;string&lt;/code&gt; type in Flow accepts these values.</source>
          <target state="translated">字符串是JavaScript 中的 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 值。Flow中的 &lt;code&gt;string&lt;/code&gt; 类型接受这些值。</target>
        </trans-unit>
        <trans-unit id="371de9693f4209b3d6baabc8cf5aa9bd9123f714" translate="yes" xml:space="preserve">
          <source>Strings: like &lt;code&gt;&quot;foo&quot;&lt;/code&gt; or &lt;code&gt;&quot;bar&quot;&lt;/code&gt;</source>
          <target state="translated">字符串：例如 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;bar&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fad0aefa729b2e3f757e7d3a4090cd9f7990d889" translate="yes" xml:space="preserve">
          <source>Structural typing</source>
          <target state="translated">结构分型</target>
        </trans-unit>
        <trans-unit id="9ce6ba148fe8d9ab4a1efa44f043d11727e7f6ee" translate="yes" xml:space="preserve">
          <source>Sublime Text</source>
          <target state="translated">崇高的文本</target>
        </trans-unit>
        <trans-unit id="d14ac23dd85e9a8386862e11638c030009ce4084" translate="yes" xml:space="preserve">
          <source>SublimeLinter-flow</source>
          <target state="translated">SublimeLinter-flow</target>
        </trans-unit>
        <trans-unit id="3f018ae5c81afd7ff03157c258e75546aee33dc2" translate="yes" xml:space="preserve">
          <source>Subsets &amp;amp; Subtypes</source>
          <target state="translated">子集和子类型</target>
        </trans-unit>
        <trans-unit id="6cdd77a39c406add3dd649d12b90f08405e31a63" translate="yes" xml:space="preserve">
          <source>Subtypes of complex types</source>
          <target state="translated">复杂类型的子类型</target>
        </trans-unit>
        <trans-unit id="9d06116efdf07868027a1561d8d0339ecc6e6c45" translate="yes" xml:space="preserve">
          <source>Subtypes of functions</source>
          <target state="translated">职能的子类型</target>
        </trans-unit>
        <trans-unit id="476bb4d588f74c233bb6c1ee03fd986be62e7cea" translate="yes" xml:space="preserve">
          <source>Subtypes of objects</source>
          <target state="translated">对象的子类型</target>
        </trans-unit>
        <trans-unit id="0be5fa8c6c74f697319a9589425f3a2612939e3d" translate="yes" xml:space="preserve">
          <source>Subtyping Constraints</source>
          <target state="translated">子类型约束</target>
        </trans-unit>
        <trans-unit id="f17dd2152e8dc1f949523edeb4f3e8b48630834f" translate="yes" xml:space="preserve">
          <source>Subtyping rules for functions are more complicated. So far, we&amp;rsquo;ve seen that &lt;code&gt;A&lt;/code&gt; is a subtype of &lt;code&gt;B&lt;/code&gt; if &lt;code&gt;B&lt;/code&gt; contains all possible values for &lt;code&gt;A&lt;/code&gt;. For functions, it&amp;rsquo;s not clear how this relationship would apply. To simplify things, you can think of a function type &lt;code&gt;A&lt;/code&gt; as being a subtype of a function type &lt;code&gt;B&lt;/code&gt; if functions of type &lt;code&gt;A&lt;/code&gt; can be used wherever a function of type &lt;code&gt;B&lt;/code&gt; is expected.</source>
          <target state="translated">函数的子类型化规则更加复杂。到目前为止，我们已经看到，如果 &lt;code&gt;B&lt;/code&gt; 包含 &lt;code&gt;A&lt;/code&gt; 的所有可能值，则 &lt;code&gt;A&lt;/code&gt; 是 &lt;code&gt;B&lt;/code&gt; 的子类型。对于函数，尚不清楚这种关系如何适用。为了简化问题，你能想到的功能类型的 &lt;code&gt;A&lt;/code&gt; 作为函数类型的子 &lt;code&gt;B&lt;/code&gt; ，如果类型的函数 &lt;code&gt;A&lt;/code&gt; 可以用于任何类型的函数 &lt;code&gt;B&lt;/code&gt; 预期。</target>
        </trans-unit>
        <trans-unit id="78102c720eccd1810b8e560681ce6685d79fff31" translate="yes" xml:space="preserve">
          <source>Suports vim 8 and neovim</source>
          <target state="translated">支持vim 8和neovim</target>
        </trans-unit>
        <trans-unit id="3ea46343abafb30794aea626700e565b309f371e" translate="yes" xml:space="preserve">
          <source>Supplying Type Arguments to Callables</source>
          <target state="translated">向可调用对象提供类型参数</target>
        </trans-unit>
        <trans-unit id="e4426aae8665ecf03f0c5957ef62701c977ed33b" translate="yes" xml:space="preserve">
          <source>Suppose for example that you want to associate a value to each suit of the previous example.</source>
          <target state="translated">例如,假设你想为前面例子中的每个花色关联一个值。</target>
        </trans-unit>
        <trans-unit id="9d5e2489ceb4c7228924f9abf264d9d064bbb4ee" translate="yes" xml:space="preserve">
          <source>Suppressible Flow errors will also have an error code associated with them (after version 0.127). This code concisely describes the type of issue the error is reporting, and is different between different kinds of errors.</source>
          <target state="translated">可抑制流错误也会有一个与之相关的错误代码(0.127版本之后)。该代码简明扼要地描述了错误所报告的问题类型,并且在不同类型的错误之间是不同的。</target>
        </trans-unit>
        <trans-unit id="4045032ea32b290b2df4209d32c0f98371142465" translate="yes" xml:space="preserve">
          <source>Suppressing one type of sketchy null check only suppresses that type, so, for example</source>
          <target state="translated">压制一种类型的简略空检查,只压制该类型,所以,例如</target>
        </trans-unit>
        <trans-unit id="ade6040e71c5d23d0d099b6e7dbe0b4d723d42dd" translate="yes" xml:space="preserve">
          <source>Suppressions must be on the line immediately before the error they suppress, otherwise they will not apply.</source>
          <target state="translated">压制必须在其压制的错误前一行,否则将不适用。</target>
        </trans-unit>
        <trans-unit id="259c4642c493b3e83c12d27ca13e5dcbed833440" translate="yes" xml:space="preserve">
          <source>Switching between classic and types-first mode may cause some new Flow errors, besides signature-verification failures that we mentioned earlier. These errors are due differences in the way types based on annotations are interpreted, compared to their respective inferred types.</source>
          <target state="translated">除了我们前面提到的签名验证失败之外,在经典模式和类型优先模式之间的切换可能会导致一些新的Flow错误。这些错误是由于基于注释的类型与它们各自的推断类型的解释方式不同造成的。</target>
        </trans-unit>
        <trans-unit id="22ad664e9eb98b75a73333b2b2395fc4b52e6fc9" translate="yes" xml:space="preserve">
          <source>Symbols</source>
          <target state="translated">Symbols</target>
        </trans-unit>
        <trans-unit id="5388b4e54e46d7ce88e2e324bb0464dd484b2048" translate="yes" xml:space="preserve">
          <source>Symbols (new in ECMAScript 2015)</source>
          <target state="translated">符号(ECMAScript 2015年新增</target>
        </trans-unit>
        <trans-unit id="b6410af0c2d3799d510fea0f3019deaa0a7626b1" translate="yes" xml:space="preserve">
          <source>Symbols are created with &lt;code&gt;Symbol()&lt;/code&gt; in JavaScript. Flow has basic support for symbols, using the &lt;code&gt;symbol&lt;/code&gt; type.</source>
          <target state="translated">使用JavaScript中的 &lt;code&gt;Symbol()&lt;/code&gt; 创建符号。Flow使用 &lt;code&gt;symbol&lt;/code&gt; 类型基本支持符号。</target>
        </trans-unit>
        <trans-unit id="a6251b774c7c6606be961a6810aa903791863a16" translate="yes" xml:space="preserve">
          <source>Syntax of functions</source>
          <target state="translated">函数的语法</target>
        </trans-unit>
        <trans-unit id="38f70f0698cfc1eb1310e93dc39ca20595f7e95e" translate="yes" xml:space="preserve">
          <source>Syntax of generics</source>
          <target state="translated">属词的语法</target>
        </trans-unit>
        <trans-unit id="bae14ee1fff7b2a05299ec56ecdba3f6a62d2c5f" translate="yes" xml:space="preserve">
          <source>Table of contents:</source>
          <target state="translated">目录:</target>
        </trans-unit>
        <trans-unit id="47b04edd80b66ddca98050f09adbdab0598b38a9" translate="yes" xml:space="preserve">
          <source>Take note of the &lt;code&gt;typeof&lt;/code&gt;, it is required! &lt;code&gt;Foo&lt;/code&gt; without &lt;code&gt;typeof&lt;/code&gt; would be the type of an instance of &lt;code&gt;Foo&lt;/code&gt;. So: &lt;code&gt;(new Foo(): Foo)&lt;/code&gt;. We want the type &lt;em&gt;of&lt;/em&gt;&lt;code&gt;Foo&lt;/code&gt; not the type of an instance of &lt;code&gt;Foo&lt;/code&gt;. So: &lt;code&gt;(Foo: typeof Foo)&lt;/code&gt;. &lt;code&gt;Class&amp;lt;Foo&amp;gt;&lt;/code&gt; would also work here, but we prefer &lt;code&gt;typeof&lt;/code&gt; for consistency with stateless functional components.</source>
          <target state="translated">注意 &lt;code&gt;typeof&lt;/code&gt; ，这是必需的！没有 &lt;code&gt;typeof&lt;/code&gt; 的 &lt;code&gt;Foo&lt;/code&gt; 将是 &lt;code&gt;Foo&lt;/code&gt; 实例的类型。因此： &lt;code&gt;(new Foo(): Foo)&lt;/code&gt; 。我们想要 &lt;code&gt;Foo&lt;/code&gt; 的类型&lt;em&gt;，&lt;/em&gt;而不是 &lt;code&gt;Foo&lt;/code&gt; 实例的类型。因此： &lt;code&gt;(Foo: typeof Foo)&lt;/code&gt; 。 &lt;code&gt;Class&amp;lt;Foo&amp;gt;&lt;/code&gt; 也可以在这里工作，但是我们更喜欢 &lt;code&gt;typeof&lt;/code&gt; 与无状态功能组件保持一致。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="143158f8e0d23bcab4c6519c800370955610ba03" translate="yes" xml:space="preserve">
          <source>Tell Flow which directory to use as a temp directory. Can be overridden with the command line flag &lt;code&gt;--temp-dir&lt;/code&gt;.</source>
          <target state="translated">告诉Flow哪个目录用作临时目录。可以用命令行标志 &lt;code&gt;--temp-dir&lt;/code&gt; 覆盖。</target>
        </trans-unit>
        <trans-unit id="2a5ea6782ec2acdb66109615aa3170a3b9e5c7b0" translate="yes" xml:space="preserve">
          <source>The 3 largest parts of the shared memory are a dependency table, a hash table, and a heap. While the heap grows and shrinks, the two tables are allocated in full. This option lets you change the size of the hash table.</source>
          <target state="translated">共享内存中最大的3个部分是依赖表、哈希表和堆。当堆增长和收缩时,这两个表是全额分配的。这个选项可以让你改变哈希表的大小。</target>
        </trans-unit>
        <trans-unit id="abe1c88748594db64c94f5f66792cd9877ba43f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;CODE&amp;gt;&lt;/code&gt; portion of a suppression is optional, but when included specifies which &lt;a href=&quot;#toc-making-suppressions-more-granular-with-error-codes&quot;&gt;error code&lt;/a&gt; the suppression affects.</source>
          <target state="translated">抑制的 &lt;code&gt;&amp;lt;CODE&amp;gt;&lt;/code&gt; 部分是可选的，但如果包含，则指定抑制影响哪个&lt;a href=&quot;#toc-making-suppressions-more-granular-with-error-codes&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0934dcae4f0cd7ddb495aeab8057d00242e3e126" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.flowconfig&lt;/code&gt; consists of 7 sections:</source>
          <target state="translated">所述 &lt;code&gt;.flowconfig&lt;/code&gt; 包括7个部分：</target>
        </trans-unit>
        <trans-unit id="b2e7419e93c6bb39d11632417b0da8c56509fd33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.flowconfig&lt;/code&gt; uses a custom format that vaguely resembles INI files. We are not proud of our custom format and plan to support a better format in the future. &lt;a href=&quot;https://github.com/facebook/flow/issues/153&quot;&gt;GitHub issue #153&lt;/a&gt; tracks this.</source>
          <target state="translated">该 &lt;code&gt;.flowconfig&lt;/code&gt; 使用隐约类似于INI文件自定义格式。我们不为我们的自定义格式感到自豪，并计划在将来支持更好的格式。&lt;a href=&quot;https://github.com/facebook/flow/issues/153&quot;&gt;GitHub第153期&lt;/a&gt;对此进行了跟踪。</target>
        </trans-unit>
        <trans-unit id="1aa5025da02d927676c9cd482376361a167bd517" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?&lt;/code&gt; in &lt;code&gt;?HTMLButtonElement&lt;/code&gt; is important. In the example above the first argument to &lt;code&gt;ref&lt;/code&gt; will be &lt;code&gt;HTMLButtonElement | null&lt;/code&gt; as React will &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html#adding-a-ref-to-a-dom-element&quot;&gt;call your &lt;code&gt;ref&lt;/code&gt; callback with null&lt;/a&gt; when the component unmounts. Also, the &lt;code&gt;button&lt;/code&gt; property on &lt;code&gt;MyComponent&lt;/code&gt; will not be set until React has finished rendering. Until then your &lt;code&gt;button&lt;/code&gt; ref will be undefined. Protect yourself against these cases and use a &lt;code&gt;?&lt;/code&gt; (like in &lt;code&gt;?HTMLButtonElement&lt;/code&gt;) to protect yourself from bugs.</source>
          <target state="translated">的 &lt;code&gt;?&lt;/code&gt; 在 &lt;code&gt;?HTMLButtonElement&lt;/code&gt; 中很重要。在上面的示例中， &lt;code&gt;ref&lt;/code&gt; 的第一个参数将是 &lt;code&gt;HTMLButtonElement | null&lt;/code&gt; 因为当组件卸载时，React将&lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html#adding-a-ref-to-a-dom-element&quot;&gt;使用null &lt;/a&gt;调用您的 &lt;code&gt;ref&lt;/code&gt; 回调。另外，在React完成渲染之前，不会在 &lt;code&gt;MyComponent&lt;/code&gt; 上设置 &lt;code&gt;button&lt;/code&gt; 属性。在此之前，您的 &lt;code&gt;button&lt;/code&gt; 引用将是不确定的。保护自己免受这些情况的侵害，并使用 &lt;code&gt;?&lt;/code&gt; （例如 &lt;code&gt;?HTMLButtonElement&lt;/code&gt; 中的代码）来保护自己免受错误的侵害。</target>
        </trans-unit>
        <trans-unit id="719a6a4c0e07c1dc9a47466bbab725e9662338ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SyntheticEvent&amp;lt;T&amp;gt;&lt;/code&gt; types that React provides and the DOM events they are related to are:</source>
          <target state="translated">React提供的 &lt;code&gt;SyntheticEvent&amp;lt;T&amp;gt;&lt;/code&gt; 类型以及与它们相关的DOM事件是：</target>
        </trans-unit>
        <trans-unit id="653be0e1cd193d42d4fa78964cd56de69b5da2cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[declarations]&lt;/code&gt; section in a &lt;code&gt;.flowconfig&lt;/code&gt; file tells Flow to parse files matching the specified regular expressions in &lt;em&gt;declaration mode&lt;/em&gt;. In declaration mode the code is not typechecked. However, the signatures of functions, classes, etc are extracted and used by the typechecker when checking other code.</source>
          <target state="translated">&lt;code&gt;.flowconfig&lt;/code&gt; 文件中的 &lt;code&gt;[declarations]&lt;/code&gt; 部分告诉Flow以&lt;em&gt;声明模式&lt;/em&gt;解析与指定的正则表达式匹配的文件。在声明模式下，不对代码进行类型检查。但是，在检查其他代码时，类型检查器会提取并使用函数，类等的签名。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="df21474ae6954ba751628a9d46d6c9512fa40f07" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[ignore]&lt;/code&gt; section in a &lt;code&gt;.flowconfig&lt;/code&gt; file tells Flow to ignore files matching the specified regular expressions when type checking your code. By default, nothing is ignored.</source>
          <target state="translated">&lt;code&gt;.flowconfig&lt;/code&gt; 文件中的 &lt;code&gt;[ignore]&lt;/code&gt; 节告诉Flow在类型检查代码时忽略与指定的正则表达式匹配的文件。默认情况下，不会忽略任何内容。</target>
        </trans-unit>
        <trans-unit id="89a1fffc651c11cf6e66838e0172e44593fd9d49" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[include]&lt;/code&gt; section in a &lt;code&gt;.flowconfig&lt;/code&gt; file tells Flow to include the specified files or directories. Including a directory recursively includes all the files under that directory. Symlinks are followed as long as they lead to a file or directory that is also included. Each line in the include section is a path to include. These paths can be relative to the root directory or absolute, and support both single and double star wildcards.</source>
          <target state="translated">&lt;code&gt;.flowconfig&lt;/code&gt; 文件中的 &lt;code&gt;[include]&lt;/code&gt; 部分告诉Flow包括指定的文件或目录。递归包含目录将包含该目录下的所有文件。只要符号链接指向也包含的文件或目录，就遵循它们。包含部分中的每一行都是要包含的路径。这些路径可以相对于根目录，也可以是绝对路径，并且支持单星号和双星号通配符。</target>
        </trans-unit>
        <trans-unit id="f33fef6875ad046a3f7a76b86437d56196d9c414" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[libs]&lt;/code&gt; section in a &lt;code&gt;.flowconfig&lt;/code&gt; file tells Flow to include the specified &lt;a href=&quot;https://flow.org/en/libdefs/&quot;&gt;library definitions&lt;/a&gt; when type checking your code. Multiple libraries can be specified. By default, the &lt;code&gt;flow-typed&lt;/code&gt; folder in your project root directory is included as a library directory. This default allows you to use &lt;a href=&quot;https://github.com/flowtype/flow-typed&quot;&gt;&lt;code&gt;flow-typed&lt;/code&gt;&lt;/a&gt; to install library definitions without additional configuration.</source>
          <target state="translated">&lt;code&gt;.flowconfig&lt;/code&gt; 文件中的 &lt;code&gt;[libs]&lt;/code&gt; 部分告诉Flow 在类型检查代码时包括指定的&lt;a href=&quot;https://flow.org/en/libdefs/&quot;&gt;库定义&lt;/a&gt;。可以指定多个库。默认情况下，项目根目录中的 &lt;code&gt;flow-typed&lt;/code&gt; 文件夹包含在库目录中。此默认设置允许您使用&lt;a href=&quot;https://github.com/flowtype/flow-typed&quot;&gt; &lt;code&gt;flow-typed&lt;/code&gt; &lt;/a&gt;安装库定义，而无需其他配置。</target>
        </trans-unit>
        <trans-unit id="93975a8a26491b29c7786a7d20f47e387cfa3514" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[lints]&lt;/code&gt; section in a &lt;code&gt;.flowconfig&lt;/code&gt; file can contain several key-value pairs of the form:</source>
          <target state="translated">&lt;code&gt;.flowconfig&lt;/code&gt; 文件中的 &lt;code&gt;[lints]&lt;/code&gt; 部分可以包含以下格式的几个键/值对：</target>
        </trans-unit>
        <trans-unit id="263df81c3f42c9c4c0096bb79a58e2dee22d2326" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[options]&lt;/code&gt; section in a &lt;code&gt;.flowconfig&lt;/code&gt; file can contain several key-value pairs of the form:</source>
          <target state="translated">&lt;code&gt;.flowconfig&lt;/code&gt; 文件中的 &lt;code&gt;[options]&lt;/code&gt; 部分可以包含以下格式的几个键/值对：</target>
        </trans-unit>
        <trans-unit id="81ba04249ba83fffa732ce0d0760f8ad3472a183" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[untyped]&lt;/code&gt; section in a &lt;code&gt;.flowconfig&lt;/code&gt; file tells Flow to not typecheck files matching the specified regular expressions and instead throw away types and treat modules as &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;.flowconfig&lt;/code&gt; 文件中的 &lt;code&gt;[untyped]&lt;/code&gt; 部分告诉Flow不要对符合指定正则表达式的文件进行类型检查，而应丢弃类型并将模块视为 &lt;code&gt;any&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="924f7192ca7f7c407e938ed0acd12668b4d33fbd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typeof&lt;/code&gt; operator returns the Flow type of a given value to be used as a type.</source>
          <target state="translated">的 &lt;code&gt;typeof&lt;/code&gt; 运算符返回流类型的给定值的被用作类型。</target>
        </trans-unit>
        <trans-unit id="1330e72fe13fbae1f885a0745df109da8382e39b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;well_formed_exports&lt;/code&gt; flag from before is implied by &lt;code&gt;types_first&lt;/code&gt;. Once this process is completed and types-first has been enabled, you can remove &lt;code&gt;well_formed_exports&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;well_formed_exports&lt;/code&gt; 从之前标志被暗示 &lt;code&gt;types_first&lt;/code&gt; 。完成此过程并启用&amp;ldquo;类型优先&amp;rdquo;后，您可以删除 &lt;code&gt;well_formed_exports&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="67966e36f904c5d8958d761e6cb9127537aff7ef" translate="yes" xml:space="preserve">
          <source>The Asynchronous Lint Engine (ALE) plugin for Vim 8+ and NeoVim, &lt;a href=&quot;https://github.com/w0rp/ale&quot;&gt;vim-ale&lt;/a&gt;, is a generalized linting engine with support for Flow and many other tools.</source>
          <target state="translated">Vim 8+和NeoVim &lt;a href=&quot;https://github.com/w0rp/ale&quot;&gt;vim-ale&lt;/a&gt;的异步Lint Engine（ALE）插件是一种通用的Linting引擎，支持Flow和许多其他工具。</target>
        </trans-unit>
        <trans-unit id="5183c3b41bf0492de80698dc738a05d76568f6ad" translate="yes" xml:space="preserve">
          <source>The CLI tool also provides several other options and commands that allow you to control the server and build tools that integrate with Flow. For example, this is how the &lt;a href=&quot;https://nuclide.io/&quot;&gt;Nuclide&lt;/a&gt; editor integrates with Flow to provide autocompletion, type errors, etc. in its UI.</source>
          <target state="translated">CLI工具还提供了其他几个选项和命令，使您可以控制服务器和构建与Flow集成的工具。例如，这就是&lt;a href=&quot;https://nuclide.io/&quot;&gt;Nuclide&lt;/a&gt;编辑器与Flow集成的方式，以在其UI中提供自动补全，类型错误等。</target>
        </trans-unit>
        <trans-unit id="0b12391516f21ae19dfcef64eb8647ae6924887e" translate="yes" xml:space="preserve">
          <source>The Flow background process monitors all Flow files. However, how does it know which files are Flow files and, thus, should be checked? Placing the following &lt;strong&gt;before any code&lt;/strong&gt; in a JavaScript file is the flag the process uses to answer that question.</source>
          <target state="translated">Flow后台进程监视所有Flow文件。但是，它如何知道哪些文件是Flow文件，因此应进行检查？在JavaScript文件中的&lt;strong&gt;任何代码之前&lt;/strong&gt;放置以下内容是该过程用来回答该问题的标志。</target>
        </trans-unit>
        <trans-unit id="3ea8fcfb745f317d30dab0afe405550d9490a0f7" translate="yes" xml:space="preserve">
          <source>The Flow root must be within a &lt;a href=&quot;https://www.mercurial-scm.org/&quot;&gt;Mercurial&lt;/a&gt; repository.</source>
          <target state="translated">Flow根目录必须在&lt;a href=&quot;https://www.mercurial-scm.org/&quot;&gt;Mercurial&lt;/a&gt;存储库中。</target>
        </trans-unit>
        <trans-unit id="eb9d9e2a123153d996537b64730290848876d71f" translate="yes" xml:space="preserve">
          <source>The IDE needs to integrate with &lt;code&gt;flow lsp&lt;/code&gt; to tell Flow which files are open.</source>
          <target state="translated">IDE需要与 &lt;code&gt;flow lsp&lt;/code&gt; 集成以告知Flow哪些文件已打开。</target>
        </trans-unit>
        <trans-unit id="e36e3ea40dbe1430b59533dc1b80fc6036bba9ee" translate="yes" xml:space="preserve">
          <source>The JavaScript language is a bunch of object-oriented ideas and functional ideas mixed together. Developer&amp;rsquo;s usage of JavaScript tends to be mixed as well. Classes (or constructor functions) being the more object-oriented side and functions (as lambdas) and objects tend to be more on the functional side, developers use both simultaneously.</source>
          <target state="translated">JavaScript语言是一堆混合在一起的面向对象的思想和功能的思想。开发人员对JavaScript的使用也趋于混杂。类（或构造函数）是面向对象的一面，而函数（如lambda）和对象在功能方面则更多，开发人员会同时使用两者。</target>
        </trans-unit>
        <trans-unit id="7bd394e3f7c77eaabbe75ef337cf434e120de82b" translate="yes" xml:space="preserve">
          <source>The Trivial HOC</source>
          <target state="translated">琐碎的HOC</target>
        </trans-unit>
        <trans-unit id="025b59ea409d457aec020e335d2f4bc894d68ede" translate="yes" xml:space="preserve">
          <source>The ability for a static type checker to be able to tell that the value inside the if statement must be &lt;code&gt;&quot;A&quot;&lt;/code&gt; is known as a refinement.</source>
          <target state="translated">静态类型检查器能够判断if语句内的值必须为 &lt;code&gt;&quot;A&quot;&lt;/code&gt; 能力被称为优化。</target>
        </trans-unit>
        <trans-unit id="fec021ecaeba3a8ee38ad356d77c56a0bb6f13a4" translate="yes" xml:space="preserve">
          <source>The above code has a type error because Flow would also allow the call expression &lt;code&gt;method({ foo: 1, bar: 2 })&lt;/code&gt;, because &lt;code&gt;{foo:number,bar:number}&lt;/code&gt; is a subtype of &lt;code&gt;{bar:number}&lt;/code&gt;, one of the members of the parameter&amp;rsquo;s union type.</source>
          <target state="translated">上面的代码有类型错误，因为Flow也允许调用表达式 &lt;code&gt;method({ foo: 1, bar: 2 })&lt;/code&gt; ，因为 &lt;code&gt;{foo:number,bar:number}&lt;/code&gt; 是 &lt;code&gt;{bar:number}&lt;/code&gt; 的子类型，其中之一参数的联合类型的成员。</target>
        </trans-unit>
        <trans-unit id="fe2ac4fdbea23fe269b2df48740a8fe5b6447c33" translate="yes" xml:space="preserve">
          <source>The advantage of the &lt;code&gt;$Exports&lt;/code&gt; syntax is that you can &lt;code&gt;export&lt;/code&gt; the type on the same line</source>
          <target state="translated">&lt;code&gt;$Exports&lt;/code&gt; 语法的优点是您可以在同一行上 &lt;code&gt;export&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="eba2348e4056127995e90c22bf6c18e156a3d1c5" translate="yes" xml:space="preserve">
          <source>The base type for Redux &lt;a href=&quot;http://redux.js.org/docs/basics/Actions.html&quot;&gt;actions&lt;/a&gt; is an object with a &lt;code&gt;type&lt;/code&gt; property.</source>
          <target state="translated">Redux &lt;a href=&quot;http://redux.js.org/docs/basics/Actions.html&quot;&gt;操作&lt;/a&gt;的基本类型是具有 &lt;code&gt;type&lt;/code&gt; 属性的对象。</target>
        </trans-unit>
        <trans-unit id="8af3b40968bb4f75f70768133b814cdf17d5d2ec" translate="yes" xml:space="preserve">
          <source>The basic &lt;code&gt;flowlint&lt;/code&gt; comment takes a comma-delimited list of &lt;code&gt;rule:severity&lt;/code&gt; pairs and applies those settings for the rest of the source file until overridden. This has three primary purposes: applying settings over a block, applying settings over a file, and applying settings over part of a line.</source>
          <target state="translated">基本的 &lt;code&gt;flowlint&lt;/code&gt; 注释采用逗号分隔的 &lt;code&gt;rule:severity&lt;/code&gt; Severity对列表，并将这些设置应用于源文件的其余部分，直到被覆盖。这具有三个主要目的：在块上应用设置，在文件上应用设置以及在行的一部分上应用设置。</target>
        </trans-unit>
        <trans-unit id="48755c9924c91563b67114a45c53a5f50b06fab7" translate="yes" xml:space="preserve">
          <source>The benefit of this new architecture is dual:</source>
          <target state="translated">这种新架构的好处是双。</target>
        </trans-unit>
        <trans-unit id="f167409d5ec197b4871f95c5db2fcf7f6bbd5cd2" translate="yes" xml:space="preserve">
          <source>The body of these predicate functions need to be expressions (i.e. local variable declarations are not supported). But it&amp;rsquo;s possible to call other predicate functions inside a predicate function. For example:</source>
          <target state="translated">这些谓词函数的主体必须是表达式（即，不支持局部变量声明）。但是可以在谓词函数中调用其他谓词函数。例如：</target>
        </trans-unit>
        <trans-unit id="3c484a1b1878460543cc195aaf9ab4cae85fb2ea" translate="yes" xml:space="preserve">
          <source>The caveat of this new version is that it requires exported parts of the code to be annotated with types, or to be expressions whose type can be trivially inferred (for example numbers and strings).</source>
          <target state="translated">这个新版本的注意事项是,它要求导出的代码部分要有类型注释,或者是类型可以简单推断的表达式(例如数字和字符串)。</target>
        </trans-unit>
        <trans-unit id="182510f68d230df9a3e633ed8ee2db47f5bc405d" translate="yes" xml:space="preserve">
          <source>The core benefit to Flow is its ability to quickly check your code for errors. Once you have enabled your project for Flow, you can start the process that allows Flow to check your code incrementally and with great speed.</source>
          <target state="translated">Flow的核心优势是它能够快速检查你的代码是否有错误。一旦你为Flow启用了你的项目,你就可以开始让Flow以极快的速度逐步检查你的代码。</target>
        </trans-unit>
        <trans-unit id="8a1aab316dcc9dd57ed72229c368c2d026bb14e1" translate="yes" xml:space="preserve">
          <source>The coverage command provides a metric of the amount of checking that Flow has performed on each part of your code. A program with high Flow coverage should increase your confidence that Flow has detected any potential runtime errors.</source>
          <target state="translated">覆盖率命令提供了一个衡量Flow对代码的每个部分进行检查的数量。一个具有高Flow覆盖率的程序应该增加您对Flow已经检测到任何潜在运行时错误的信心。</target>
        </trans-unit>
        <trans-unit id="f7197940d208092be8c8d13b858faffa50044428" translate="yes" xml:space="preserve">
          <source>The decision of which direction to apply the subtyping rule on inputs and outputs is governed by variance, which is the topic of the next section.</source>
          <target state="translated">决定在输入和输出上应用哪个方向的子类型规则是由方差决定的,这是下一节的主题。</target>
        </trans-unit>
        <trans-unit id="4ff505957015ad603cc74c9be6c56afdb90f26dc" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;node&lt;/code&gt;.</source>
          <target state="translated">默认值为 &lt;code&gt;node&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="684bf3ea595241d58aa0cbec92715b88590f0f96" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;all&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">为默认值 &lt;code&gt;all&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dcc51d57d4a016ea1192824513bdb37f918f5d3a" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;babel_loose_array_spread&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">为默认值 &lt;code&gt;babel_loose_array_spread&lt;/code&gt; 是 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3320966c1ed05d8e92be8263eb0872986cd5b9d" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;emoji&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">为默认值 &lt;code&gt;emoji&lt;/code&gt; 是 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="108bf5699171bd14f4e61bce6c21f7bec782d0a5" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;types_first&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; (as of version 0.134).</source>
          <target state="translated">为默认值 &lt;code&gt;types_first&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; （为0.134版本）。</target>
        </trans-unit>
        <trans-unit id="b4b4c401e7d77aa94ed0f3d78556a2ab12605661" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;/tmp/flow&lt;/code&gt;.</source>
          <target state="translated">默认值为 &lt;code&gt;/tmp/flow&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ab75823e9609a97fc3968cb003989422d1692ab" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;automatic&lt;/code&gt;.</source>
          <target state="translated">默认值是 &lt;code&gt;automatic&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6d1dcc6b3a394539acf783a764b41f856bcb2ec9" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17a6f3086f6053ea99056f8787ec9e3c7714223a" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">默认值为 &lt;code&gt;none&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="385f9197e267dca024cc7c5ee266ab77c07dd86b" translate="yes" xml:space="preserve">
          <source>The default value of &lt;code&gt;max_header_tokens&lt;/code&gt; is 10.</source>
          <target state="translated">&lt;code&gt;max_header_tokens&lt;/code&gt; 的默认值为10。</target>
        </trans-unit>
        <trans-unit id="4afe27211cbc9af6d345271f3bd53dcd4c074b64" translate="yes" xml:space="preserve">
          <source>The default value of this option is &lt;code&gt;enable&lt;/code&gt;, which allows use of this proposed syntax.</source>
          <target state="translated">此选项的默认值为 &lt;code&gt;enable&lt;/code&gt; ，它允许使用此建议的语法。</target>
        </trans-unit>
        <trans-unit id="07a26010ceb723197e0f6ed4ccf098b594327ee9" translate="yes" xml:space="preserve">
          <source>The default value of this option is &lt;code&gt;warn&lt;/code&gt;, which gives a warning on use since this proposal is still very early-stage.</source>
          <target state="translated">该选项的默认值为 &lt;code&gt;warn&lt;/code&gt; ，由于该建议仍处于早期阶段，因此会在使用中发出警告。</target>
        </trans-unit>
        <trans-unit id="4804a2b774fe8e16ad5ee7fbc61053dc05f70f20" translate="yes" xml:space="preserve">
          <source>The definition for &lt;code&gt;React.ComponentType&amp;lt;Props&amp;gt;&lt;/code&gt; is roughly:</source>
          <target state="translated">&lt;code&gt;React.ComponentType&amp;lt;Props&amp;gt;&lt;/code&gt; 的定义大致为：</target>
        </trans-unit>
        <trans-unit id="c3087bc731ef3517a427cf5c4e5203623cadca99" translate="yes" xml:space="preserve">
          <source>The definition for &lt;code&gt;React.ElementType&lt;/code&gt; is roughly:</source>
          <target state="translated">&lt;code&gt;React.ElementType&lt;/code&gt; 的定义大致为：</target>
        </trans-unit>
        <trans-unit id="6e617c1ee84ca2ef49a14a0c500b7bf9f6b27172" translate="yes" xml:space="preserve">
          <source>The definition for &lt;code&gt;React.Ref&amp;lt;typeof Component&amp;gt;&lt;/code&gt; is roughly:</source>
          <target state="translated">&lt;code&gt;React.Ref&amp;lt;typeof Component&amp;gt;&lt;/code&gt; 的定义大致为：</target>
        </trans-unit>
        <trans-unit id="f2c72eeedacf538eae7405dbd87fe7965700eed1" translate="yes" xml:space="preserve">
          <source>The definition for &lt;code&gt;React.StatelessFunctionalComponent&amp;lt;Props&amp;gt;&lt;/code&gt; is roughly:</source>
          <target state="translated">&lt;code&gt;React.StatelessFunctionalComponent&amp;lt;Props&amp;gt;&lt;/code&gt; 的定义大致为：</target>
        </trans-unit>
        <trans-unit id="67931b95c973afece9e67ea2abaeb942c4811eaf" translate="yes" xml:space="preserve">
          <source>The definition of &lt;code&gt;React.Node&lt;/code&gt; can be roughly approximated with a &lt;a href=&quot;#toc-react-childrenarray&quot;&gt;&lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;React.Node&lt;/code&gt; 的定义可以使用&lt;a href=&quot;#toc-react-childrenarray&quot;&gt; &lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;粗略地近似：</target>
        </trans-unit>
        <trans-unit id="65be16845f607fa6de2868121655dbf19d303167" translate="yes" xml:space="preserve">
          <source>The design decision in Flow around mixing nominal and structural typing was chosen based on how objects, functions, and classes are already used in JavaScript.</source>
          <target state="translated">Flow中围绕混合名义类型和结构类型的设计决定是基于对象、函数和类在JavaScript中的使用方式而选择的。</target>
        </trans-unit>
        <trans-unit id="615278e593ca17f18421f88e244590b32e0dc1cd" translate="yes" xml:space="preserve">
          <source>The determining factor for this is the presence of &lt;a href=&quot;../types/any&quot;&gt;&lt;code&gt;any&lt;/code&gt;&lt;/a&gt; in the inferred type of each expression. An expression whose inferred type is &lt;code&gt;any&lt;/code&gt; is considered &lt;em&gt;uncovered&lt;/em&gt;, otherwise it is considered &lt;em&gt;covered&lt;/em&gt;.</source>
          <target state="translated">决定因素是每个表达式的推断类型中是否存在&lt;a href=&quot;../types/any&quot;&gt; &lt;code&gt;any&lt;/code&gt; &lt;/a&gt;一个。推断类型为 &lt;code&gt;any&lt;/code&gt; 的表达式被认为是&lt;em&gt;未覆盖的&lt;/em&gt;，否则被认为是&lt;em&gt;covered&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="29d2d625710fa5cd0abd9e50046510b51fb847f2" translate="yes" xml:space="preserve">
          <source>The example above could not be accomplished without the &lt;code&gt;+&lt;/code&gt; variance sigil:</source>
          <target state="translated">没有 &lt;code&gt;+&lt;/code&gt; 方差标记，无法完成以上示例：</target>
        </trans-unit>
        <trans-unit id="569e13c9d22dc97266745256891834efe9cb254b" translate="yes" xml:space="preserve">
          <source>The first time this is run, the &lt;a href=&quot;#toc-run-flow-background-process&quot;&gt;Flow background process&lt;/a&gt; will be spawned and all of your Flow files will be checked. Then, as you continue to iterate on your project, the background process will continuously monitor your code such that when you run &lt;code&gt;flow&lt;/code&gt; again, the updated result will be near instantaneous.</source>
          <target state="translated">第一次运行时，将生成&lt;a href=&quot;#toc-run-flow-background-process&quot;&gt;Flow后台进程，&lt;/a&gt;并检查所有Flow文件。然后，当您继续迭代项目时，后台进程将连续监视您的代码，以便当您再次运行 &lt;code&gt;flow&lt;/code&gt; 时，更新的结果几乎是瞬时的。</target>
        </trans-unit>
        <trans-unit id="f48e199f3e1c2873fac5e329e515e0affa5734d6" translate="yes" xml:space="preserve">
          <source>The fix here is to add types to the parameters of &lt;code&gt;add&lt;/code&gt;.</source>
          <target state="translated">这里的解决方法是类型添加到的参数 &lt;code&gt;add&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="decaa6f4bcdc1dd98facfb522a07ee0290e90e6a" translate="yes" xml:space="preserve">
          <source>The flow command line tool is made to be easy-to-use for simple cases.</source>
          <target state="translated">流程命令行工具是为了简单的案例而制作的。</target>
        </trans-unit>
        <trans-unit id="568d41ac14b4b2796ccd853ff99f7c7a730490f8" translate="yes" xml:space="preserve">
          <source>The following are functionally equivalent</source>
          <target state="translated">以下是功能等同的</target>
        </trans-unit>
        <trans-unit id="10e5012640308970d1812cdfc15f495ee3f6ea82" translate="yes" xml:space="preserve">
          <source>The function argument allows &lt;code&gt;string&lt;/code&gt; values in its field, but in this case Flow prevents the original object from having a &lt;code&gt;number&lt;/code&gt; written to it. Within the body of the function you would be able to mutate the object so that the property &lt;code&gt;a&lt;/code&gt; would receive a &lt;code&gt;number&lt;/code&gt;, causing the type of the original object to no longer be accurate. You can fix this error by making the property covariant (read-only): &lt;code&gt;{+a:string|&amp;nbsp;number}&lt;/code&gt;. This prevents the function body from writing to the property, making it safe to pass more restricted types to the function.</source>
          <target state="translated">函数参数允许在其字段中使用 &lt;code&gt;string&lt;/code&gt; 值，但在这种情况下，Flow会阻止原始对象写入 &lt;code&gt;number&lt;/code&gt; 。在函数主体内，您可以对对象进行突变，以便属性 &lt;code&gt;a&lt;/code&gt; 可以接收 &lt;code&gt;number&lt;/code&gt; ，从而导致原始对象的类型不再准确。您可以通过使属性协变（只读）来解决此错误： &lt;code&gt;{+a:string|&amp;nbsp;number}&lt;/code&gt; 。这样可以防止函数主体写入属性，从而可以安全地将更多受限制的类型传递给函数。</target>
        </trans-unit>
        <trans-unit id="2155dfc51f926d913a644cc3de06c804ab01b2ad" translate="yes" xml:space="preserve">
          <source>The function&amp;rsquo;s argument allows &lt;code&gt;string&lt;/code&gt; values in its array, but in this case Flow prevents the original array from receiving a &lt;code&gt;number&lt;/code&gt;. Inside the function, you would be able to push a &lt;code&gt;number&lt;/code&gt; to the argument array, causing the type of the original array to no longer be accurate. You can fix this error by changing the type of the argument to &lt;code&gt;$ReadOnlyArray&amp;lt;string |&amp;nbsp;number&amp;gt;&lt;/code&gt;. This prevents the function body from pushing anything to the array, allowing it to accept narrower types.</source>
          <target state="translated">该函数的参数允许在其数组中使用 &lt;code&gt;string&lt;/code&gt; 值，但是在这种情况下，Flow阻止原始数组接收 &lt;code&gt;number&lt;/code&gt; 。在函数内部，您可以将一个 &lt;code&gt;number&lt;/code&gt; 压入参数数组，从而导致原始数组的类型不再准确。您可以通过将参数的类型更改为 &lt;code&gt;$ReadOnlyArray&amp;lt;string |&amp;nbsp;number&amp;gt;&lt;/code&gt; 来解决此错误。编号&amp;gt;。这样可以防止函数体将任何东西压入数组，使其接受较窄的类型。</target>
        </trans-unit>
        <trans-unit id="63f89c1777909f20b429c72e0ff7ec4f5852765d" translate="yes" xml:space="preserve">
          <source>The function&amp;rsquo;s purpose is to run all the thunks and return an object made of values. What&amp;rsquo;s the return type of this function?</source>
          <target state="translated">该函数的目的是运行所有thunk，并返回一个由值组成的对象。此函数的返回类型是什么？</target>
        </trans-unit>
        <trans-unit id="c023f83d766bac37fd8c93749ac0588a01c18d3d" translate="yes" xml:space="preserve">
          <source>The great thing about Flow is that you can get near real-time feedback on the state of your code. At any point that you want to check for errors, just run:</source>
          <target state="translated">Flow最大的好处是,你可以获得近乎实时的代码状态反馈。在任何时候,如果你想检查错误,只需运行。</target>
        </trans-unit>
        <trans-unit id="1d3a896ebf3c8fbb9102531fb367809a43a70216" translate="yes" xml:space="preserve">
          <source>The idea of using types to manage code evolution and growth in JavaScript (and related languages) is not new. In fact, several useful type systems have been built for JavaScript in recent years. However, type systems differ in their goals. On one end of the spectrum are permissive type systems that provide some degree of linting against likely errors, without regard for correctness. On the other end of the spectrum are restrictive type systems that can guarantee the correctness of static code optimizations, at the cost of interoperability. Another area that has not seen a lot of focus is the performance of type checking itself.</source>
          <target state="translated">在JavaScript(以及相关语言)中,使用类型来管理代码的演化和增长的想法并不新鲜。事实上,近年来已经为JavaScript建立了几个有用的类型系统。然而,类型系统的目标各不相同。在光谱的一端是允许型系统,它对可能出现的错误提供一定程度的过滤,而不考虑正确性。另一端是限制性类型系统,它可以保证静态代码优化的正确性,但代价是互操作性。另一个没有得到很多关注的领域是类型检查本身的性能。</target>
        </trans-unit>
        <trans-unit id="895222166e3067cff8bd88b8a774d6ab00fde9e2" translate="yes" xml:space="preserve">
          <source>The inferred type of the property becomes what you set it to.</source>
          <target state="translated">属性的推断类型就变成了你设置的类型。</target>
        </trans-unit>
        <trans-unit id="e551fea41cfe91f78e0d3bfde3174c0c4fa76ec7" translate="yes" xml:space="preserve">
          <source>The key to Flow&amp;rsquo;s speed is modularity: the ability to break the analysis into file-sized chunks that can be assembled later.</source>
          <target state="translated">Flow速度的关键是模块化：将分析分解为文件大小的块的能力，然后可以将其组装起来。</target>
        </trans-unit>
        <trans-unit id="ef6ba2b0cdf8e98a8b5dce1cdbd0afc335063144" translate="yes" xml:space="preserve">
          <source>The keys are the same, but the values have a different type, namely the return type of each function. At a value level (the implementation of the function) we&amp;rsquo;re essentially mapping over the object to produce new values for the keys. How to express this at a type level?</source>
          <target state="translated">键是相同的，但是值具有不同的类型，即每个函数的返回类型。在值级别（函数的实现）上，我们实质上是在对象上映射以产生键的新值。如何在类型层面表达这一点？</target>
        </trans-unit>
        <trans-unit id="92ccbfce1a4e920f5d1758fbdebfc31032b257d4" translate="yes" xml:space="preserve">
          <source>The length of the tuple is known as the &amp;ldquo;arity&amp;rdquo;. The length of a tuple is strictly enforced in Flow.</source>
          <target state="translated">元组的长度称为&amp;ldquo; arity&amp;rdquo;。元组的长度在Flow中严格执行。</target>
        </trans-unit>
        <trans-unit id="647cfb5d0aaa8b82192bbb83417ad5b3177c198f" translate="yes" xml:space="preserve">
          <source>The lint settings parser is fairly intelligent and will stop you if you write a redundant rule, a rule that gets completely overwritten, or an unused suppression. This should prevent most accidental misconfigurations of lint rules.</source>
          <target state="translated">lint设置解析器是相当智能的,如果你写了一个多余的规则,一个被完全覆盖的规则,或者一个未使用的抑制,它就会阻止你。这应该可以防止大多数lint规则的意外错误配置。</target>
        </trans-unit>
        <trans-unit id="f02d9fd7d48002b88a676cb504a249985d85238a" translate="yes" xml:space="preserve">
          <source>The location of the &lt;code&gt;.flowconfig&lt;/code&gt; is significant. Flow treats the directory that contains the &lt;code&gt;.flowconfig&lt;/code&gt; as the &lt;em&gt;project root&lt;/em&gt;. By default Flow includes all the source code under the project root. The paths in the &lt;a href=&quot;include&quot;&gt;[include] section&lt;/a&gt; are relative to the project root. Some other configuration also lets you reference the project root via the macro &lt;code&gt;&amp;lt;PROJECT_ROOT&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;.flowconfig&lt;/code&gt; 的位置很重要。Flow将包含 &lt;code&gt;.flowconfig&lt;/code&gt; 的目录视为&lt;em&gt;项目根目录&lt;/em&gt;。默认情况下，Flow在项目根目录下包含所有源代码。&lt;a href=&quot;include&quot;&gt;[include]部分&lt;/a&gt;中的路径是相对于项目根目录的。其他一些配置还允许您通过宏 &lt;code&gt;&amp;lt;PROJECT_ROOT&amp;gt;&lt;/code&gt; 引用项目根目录。</target>
        </trans-unit>
        <trans-unit id="88b94dfde96af7809cecaa352baf181b5eb93f8e" translate="yes" xml:space="preserve">
          <source>The main advantage to using &lt;code&gt;$ReadOnlyArray&lt;/code&gt; instead of &lt;code&gt;Array&lt;/code&gt; is that &lt;code&gt;$ReadOnlyArray&lt;/code&gt;&amp;rsquo;s type parameter is &lt;em&gt;covariant&lt;/em&gt; while &lt;code&gt;Array&lt;/code&gt;&amp;rsquo;s type parameter is &lt;em&gt;invariant&lt;/em&gt;. That means that &lt;code&gt;$ReadOnlyArray&amp;lt;number&amp;gt;&lt;/code&gt; is a subtype of &lt;code&gt;$ReadOnlyArray&amp;lt;number | string&amp;gt;&lt;/code&gt; while &lt;code&gt;Array&amp;lt;number&amp;gt;&lt;/code&gt; is NOT a subtype of &lt;code&gt;Array&amp;lt;number | string&amp;gt;&lt;/code&gt;. So it&amp;rsquo;s often useful to use &lt;code&gt;$ReadOnlyArray&lt;/code&gt; in type annotations for arrays of various types of elements. Take, for instance, the following scenario:</source>
          <target state="translated">使用 &lt;code&gt;$ReadOnlyArray&lt;/code&gt; 代替 &lt;code&gt;Array&lt;/code&gt; 的主要优点是 &lt;code&gt;$ReadOnlyArray&lt;/code&gt; 的type参数是&lt;em&gt;协变的，&lt;/em&gt;而 &lt;code&gt;Array&lt;/code&gt; 的type参数是&lt;em&gt;不变的&lt;/em&gt;。这意味着 &lt;code&gt;$ReadOnlyArray&amp;lt;number&amp;gt;&lt;/code&gt; 是 &lt;code&gt;$ReadOnlyArray&amp;lt;number | string&amp;gt;&lt;/code&gt; 的子类型。字符串&amp;gt;，而 &lt;code&gt;Array&amp;lt;number&amp;gt;&lt;/code&gt; 不是 &lt;code&gt;Array&amp;lt;number | string&amp;gt;&lt;/code&gt; 的子类型字符串&amp;gt;。因此在各种类型的元素的数组的类型注释中使用 &lt;code&gt;$ReadOnlyArray&lt;/code&gt; 通常很有用。以下面的情况为例：</target>
        </trans-unit>
        <trans-unit id="641f626a5da92cffb82099b03123b4b7495ce303" translate="yes" xml:space="preserve">
          <source>The main difference with &lt;a href=&quot;#toc-diff&quot;&gt;&lt;code&gt;$Diff&amp;lt;A, B&amp;gt;&lt;/code&gt;&lt;/a&gt;, is that &lt;code&gt;$Rest&amp;lt;A, B&amp;gt;&lt;/code&gt; aims to represent the true runtime rest operation, which implies that exact object types are treated differently in &lt;code&gt;$Rest&amp;lt;A, B&amp;gt;&lt;/code&gt;. For example, &lt;code&gt;$Rest&amp;lt;{|n: number|}, {}&amp;gt;&lt;/code&gt; will result in &lt;code&gt;{|n?:number|}&lt;/code&gt; because an in-exact empty object may have an &lt;code&gt;n&lt;/code&gt; property, while &lt;code&gt;$Diff&amp;lt;{|n: number|}, {}&amp;gt;&lt;/code&gt; will result in &lt;code&gt;{|n:number|}&lt;/code&gt;.</source>
          <target state="translated">与&lt;a href=&quot;#toc-diff&quot;&gt; &lt;code&gt;$Diff&amp;lt;A, B&amp;gt;&lt;/code&gt; &lt;/a&gt;的主要区别在于 &lt;code&gt;$Rest&amp;lt;A, B&amp;gt;&lt;/code&gt; 旨在表示真实的运行时休息操作，这意味着在 &lt;code&gt;$Rest&amp;lt;A, B&amp;gt;&lt;/code&gt; 对确切的对象类型进行不同的处理。例如， &lt;code&gt;$Rest&amp;lt;{|n: number|}, {}&amp;gt;&lt;/code&gt; 将产生 &lt;code&gt;{|n?:number|}&lt;/code&gt; 因为一个不精确的空对象可能具有 &lt;code&gt;n&lt;/code&gt; 属性，而 &lt;code&gt;$Diff&amp;lt;{|n: number|}, {}&amp;gt;&lt;/code&gt; 将产生 &lt;code&gt;{|n:number|}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7bbdc2ea29d0148a224653e3dc437fe724818563" translate="yes" xml:space="preserve">
          <source>The maximum number of workers the Flow server can start. By default, the server will use all available cores.</source>
          <target state="translated">Flow服务器可以启动的最大工作者数量。默认情况下,服务器将使用所有可用的内核。</target>
        </trans-unit>
        <trans-unit id="2288b72b1f95feec127ed704e5e991f5ea4c03bb" translate="yes" xml:space="preserve">
          <source>The module system to use to resolve &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;require&lt;/code&gt;. &lt;a href=&quot;https://github.com/facebook/node-haste&quot;&gt;Haste&lt;/a&gt; is used in React Native.</source>
          <target state="translated">该模块系统，用于解决 &lt;code&gt;import&lt;/code&gt; 和 &lt;code&gt;require&lt;/code&gt; 。&lt;a href=&quot;https://github.com/facebook/node-haste&quot;&gt;急速&lt;/a&gt;用于React Native。</target>
        </trans-unit>
        <trans-unit id="4ccdab5f7410661918848aa1e2e6bf4bba7ef93d" translate="yes" xml:space="preserve">
          <source>The most common case you&amp;rsquo;ll encounter is when exporting a function or React component. Flow requires you to annotate inputs. For instance, in this &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBTAHgB1gJwC6gMawB2AzngIYAmloAvKOXQHwOgDUoAjANxA&quot;&gt;example&lt;/a&gt;, flow will complain:</source>
          <target state="translated">您最常遇到的情况是导出函数或React组件时。流要求您注释输入。例如，在此&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBTAHgB1gJwC6gMawB2AzngIYAmloAvKOXQHwOgDUoAjANxA&quot;&gt;示例中&lt;/a&gt;，流程将抱怨：</target>
        </trans-unit>
        <trans-unit id="d1af1bf41631079e8c62d5969ca4a5ce794e7b24" translate="yes" xml:space="preserve">
          <source>The most general type of all React elements (similar to &lt;code&gt;mixed&lt;/code&gt; for all values). &lt;code&gt;React.MixedElement&lt;/code&gt; is defined as &lt;code&gt;React.Element&amp;lt;React.ElementType&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">所有React元素中最通用的类​​型（类似于所有值的 &lt;code&gt;mixed&lt;/code&gt; ）。 &lt;code&gt;React.MixedElement&lt;/code&gt; 定义为 &lt;code&gt;React.Element&amp;lt;React.ElementType&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d256527f1fd7c67fd36002480923ad5cedc2e90" translate="yes" xml:space="preserve">
          <source>The name specified in quotes after &lt;code&gt;declare module&lt;/code&gt; can be any string, but it should correspond to the same string you&amp;rsquo;d use to &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt; the third-party module into your project. For defining modules that are accessed via a relative &lt;code&gt;require&lt;/code&gt;/&lt;code&gt;import&lt;/code&gt; path, please see the docs on the &lt;a href=&quot;https://flow.org/en/declarations&quot;&gt;&lt;code&gt;.flow&lt;/code&gt; files&lt;/a&gt;</source>
          <target state="translated">在 &lt;code&gt;declare module&lt;/code&gt; 之后用引号引起来的名称可以是任何字符串，但应与您用于 &lt;code&gt;require&lt;/code&gt; 或 &lt;code&gt;import&lt;/code&gt; 第三方模块导入项目的字符串相同。有关定义通过相对 &lt;code&gt;require&lt;/code&gt; / &lt;code&gt;import&lt;/code&gt; 路径访问的模块的信息，请参阅&lt;a href=&quot;https://flow.org/en/declarations&quot;&gt; &lt;code&gt;.flow&lt;/code&gt; &lt;/a&gt;文件上的文档。</target>
        </trans-unit>
        <trans-unit id="fee97a1aa5d0e2a829b605bdbaea327f2fcfbd4f" translate="yes" xml:space="preserve">
          <source>The path to the log file (defaults to &lt;code&gt;/tmp/flow/&amp;lt;escaped root path&amp;gt;.log&lt;/code&gt;).</source>
          <target state="translated">日志文件的路径（默认为 &lt;code&gt;/tmp/flow/&amp;lt;escaped root path&amp;gt;.log&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6028aa8c33369bd6d14f531cdbe045d2ca494cce" translate="yes" xml:space="preserve">
          <source>The plus sign indicates that the &lt;code&gt;who&lt;/code&gt; property is &amp;ldquo;covariant.&amp;rdquo; Using a covariant property allows us to use objects which have subtype-compatible values for that property. By default, object properties are invariant, which allow both reads and writes, but are more restrictive in the values they accept.</source>
          <target state="translated">加号表示 &lt;code&gt;who&lt;/code&gt; 属性为&amp;ldquo;协变&amp;rdquo;。使用协变属性允许我们使用具有该属性的子类型兼容值的对象。默认情况下，对象属性是不变的，它允许读写，但在接受的值上有更多限制。</target>
        </trans-unit>
        <trans-unit id="8b6e43a14a66d8e57ad3388723dad2315e2002cc" translate="yes" xml:space="preserve">
          <source>The primitive types appear in the language as either literal values.</source>
          <target state="translated">基元类型在语言中出现的时候,要么是字面值。</target>
        </trans-unit>
        <trans-unit id="fbcdf34cda6e03181b88966618eea724fde6c716" translate="yes" xml:space="preserve">
          <source>The project root directory (where your &lt;code&gt;.flowconfig&lt;/code&gt; lives) is automatically included.</source>
          <target state="translated">项目根目录（ &lt;code&gt;.flowconfig&lt;/code&gt; 所在的目录）将自动包含在内。</target>
        </trans-unit>
        <trans-unit id="2de246126745bc16c8eecf3d43ab6f8772098522" translate="yes" xml:space="preserve">
          <source>The purpose of this option is to help prepare a codebase for Flow types-first mode. See &lt;a href=&quot;#toc-seal-your-intermediate-results&quot;&gt;this section&lt;/a&gt; for more.</source>
          <target state="translated">此选项的目的是帮助为&amp;ldquo;流类型优先&amp;rdquo;模式准备代码库。有关更多信息，请参见&lt;a href=&quot;#toc-seal-your-intermediate-results&quot;&gt;本节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="28bebee27e53966722fe139f706cf86a64136098" translate="yes" xml:space="preserve">
          <source>The reason for this is that we don&amp;rsquo;t know that &lt;code&gt;otherMethod()&lt;/code&gt; hasn&amp;rsquo;t done something to our value. Imagine the following scenario:</source>
          <target state="translated">这样做的原因是我们不知道 &lt;code&gt;otherMethod()&lt;/code&gt; 并没有对我们的价值做任何事情。想象以下情况：</target>
        </trans-unit>
        <trans-unit id="dcdaec4a5e807c4478cc1b0eb9fd497d6c728c78" translate="yes" xml:space="preserve">
          <source>The ref function will take one and only argument which will be the element instance which is retrieved using &lt;a href=&quot;#toc-react-elementref&quot;&gt;&lt;code&gt;React.ElementRef&amp;lt;typeof Component&amp;gt;&lt;/code&gt;&lt;/a&gt; or null since &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html#adding-a-ref-to-a-dom-element&quot;&gt;React will pass null into a ref function when unmounting&lt;/a&gt;.</source>
          <target state="translated">ref函数将仅接受一个参数，该参数将是使用&lt;a href=&quot;#toc-react-elementref&quot;&gt; &lt;code&gt;React.ElementRef&amp;lt;typeof Component&amp;gt;&lt;/code&gt; &lt;/a&gt;检索的元素实例，或者为null，因为&lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html#adding-a-ref-to-a-dom-element&quot;&gt;卸载时React会将null传递给ref函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d4ed83b0753888b656968d3936e2dd6c832b277c" translate="yes" xml:space="preserve">
          <source>The return type of function calls is currently not trivially inferable (due to features like polymorphism, overloading etc.). Their result needs to be annotated and so you&amp;rsquo;d see the following error:</source>
          <target state="translated">函数调用的返回类型目前无法轻松推断（由于多态性，重载等功能）。他们的结果需要注释，因此您会看到以下错误：</target>
        </trans-unit>
        <trans-unit id="5ec9470d19e8edaa8b9faed31b8b1054cafb7447" translate="yes" xml:space="preserve">
          <source>The rule to remember with React children is that if you have no children then &lt;code&gt;props.children&lt;/code&gt; will not be set, if you have one single child then &lt;code&gt;props.children&lt;/code&gt; will be set to exactly that value, and if you have two or more children then &lt;code&gt;props.children&lt;/code&gt; will be a new array of those values.</source>
          <target state="translated">React子项要记住的规则是，如果您没有子 &lt;code&gt;props.children&lt;/code&gt; 则不会设置props.children；如果您有一个孩子，那么 &lt;code&gt;props.children&lt;/code&gt; 将被精确设置为该值；如果您有两个或多个子项，则 &lt;code&gt;props.children&lt;/code&gt; 将是这些值的新数组。</target>
        </trans-unit>
        <trans-unit id="8a4824f1afb35e479739e160a81e69708d8ef1aa" translate="yes" xml:space="preserve">
          <source>The same holds for more complex assignment patterns like</source>
          <target state="translated">同样的道理也适用于更复杂的赋值模式,比如</target>
        </trans-unit>
        <trans-unit id="fb6cae9d717814c0ee942c2f77703ca8ec47aca7" translate="yes" xml:space="preserve">
          <source>The second is when the left-hand-side could be nullish, but the short-circuiting behavior of &lt;code&gt;?.&lt;/code&gt; is sufficient to handle it anyway:</source>
          <target state="translated">第二个是当左侧可能为零时，但 &lt;code&gt;?.&lt;/code&gt; 的短路行为。足以处理它：</target>
        </trans-unit>
        <trans-unit id="dd5b733400ddf864761d4b603d7eedbf4fe23de9" translate="yes" xml:space="preserve">
          <source>The solution here is to move the if check in the &lt;code&gt;forEach&lt;/code&gt;, or to assign the &lt;code&gt;age&lt;/code&gt; to an intermediate variable.</source>
          <target state="translated">解决方案是将if检查移入 &lt;code&gt;forEach&lt;/code&gt; 或将 &lt;code&gt;age&lt;/code&gt; 分配给中间变量。</target>
        </trans-unit>
        <trans-unit id="793214c4162efec809460a089d3515988a580153" translate="yes" xml:space="preserve">
          <source>The syntax of the block matches the syntax of object types and has all of the same features.</source>
          <target state="translated">块的语法与对象类型的语法相匹配,具有所有相同的功能。</target>
        </trans-unit>
        <trans-unit id="9cfb3fe3a8ca2679172f7460529c617ce30b2448" translate="yes" xml:space="preserve">
          <source>The type for &lt;code&gt;children&lt;/code&gt; is a function that takes in some object type and returns a &lt;a href=&quot;../types#toc-react-node&quot;&gt;&lt;code&gt;React.Node&lt;/code&gt;&lt;/a&gt; which is the type for any value that can be rendered by React. A &lt;code&gt;children&lt;/code&gt; function does not need to return &lt;a href=&quot;../types#toc-react-node&quot;&gt;&lt;code&gt;React.Node&lt;/code&gt;&lt;/a&gt;. It could return any type, but in this case &lt;code&gt;react-router&lt;/code&gt; wants to render the result returned by the &lt;code&gt;children&lt;/code&gt; function.</source>
          <target state="translated">类型对于 &lt;code&gt;children&lt;/code&gt; 是一个函数，它在一些对象类型，并返回一个&lt;a href=&quot;../types#toc-react-node&quot;&gt; &lt;code&gt;React.Node&lt;/code&gt; &lt;/a&gt;这对于可通过反应而呈现的任何值的类型。一个 &lt;code&gt;children&lt;/code&gt; 的功能并不需要返回&lt;a href=&quot;../types#toc-react-node&quot;&gt; &lt;code&gt;React.Node&lt;/code&gt; &lt;/a&gt;。它可以返回任何类型，但在这种情况下 &lt;code&gt;react-router&lt;/code&gt; 要呈现在返回的结果 &lt;code&gt;children&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="e26f0c3b68e62adaf93121b472c68d0c8f76d159" translate="yes" xml:space="preserve">
          <source>The type of the &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt;ref prop on React elements&lt;/a&gt;. &lt;code&gt;React.Ref&amp;lt;typeof Component&amp;gt;&lt;/code&gt; could be a string or a ref function.</source>
          <target state="translated">&lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt;React元素上ref道具&lt;/a&gt;的类型。 &lt;code&gt;React.Ref&amp;lt;typeof Component&amp;gt;&lt;/code&gt; 可以是字符串或ref函数。</target>
        </trans-unit>
        <trans-unit id="4218f62d2ad5c72e63a98ec879dc92c04a46ac00" translate="yes" xml:space="preserve">
          <source>The type of the key prop on React elements. It is a union of strings and numbers defined as:</source>
          <target state="translated">React元素上的key道具的类型。它是字符串和数字的组合,定义为:</target>
        </trans-unit>
        <trans-unit id="67e5a93b06a1471f36d4271abfe153e052448938" translate="yes" xml:space="preserve">
          <source>The type of this function will be</source>
          <target state="translated">该函数的类型将是</target>
        </trans-unit>
        <trans-unit id="9d3cd96ca03492da9df4ce4513f536c1b74f86f6" translate="yes" xml:space="preserve">
          <source>The type-specific variants are useful for specifying that some types of sketchy null checks are acceptable while others should be errors/warnings. For example, if you want to allow boolean sketchy null checks (for the pattern of treating undefined optional booleans as false) but forbid other types of sketchy null checks, you can do so with this &lt;code&gt;.flowconfig&lt;/code&gt;&lt;code&gt;[lints]&lt;/code&gt; section:</source>
          <target state="translated">特定于类型的变体可用于指定某些类型的粗略空检查是可以接受的，而其他类型应该是错误/警告。例如，如果要允许布尔值粗略的空检查（对于将未定义的可选布尔值视为false的模式），但又禁止其他类型的粗略空值检查，则可以使用此 &lt;code&gt;.flowconfig&lt;/code&gt; &lt;code&gt;[lints]&lt;/code&gt; 部分：</target>
        </trans-unit>
        <trans-unit id="62c2f90618d60a77f31571f70171c3abffcad492" translate="yes" xml:space="preserve">
          <source>The types-first signature extractor will not pick up subsequent update of an exported let-bound variables. Consider the example</source>
          <target state="translated">类型优先的签名提取器将不会接收导出的让绑定变量的后续更新。请看这个例子</target>
        </trans-unit>
        <trans-unit id="6e42194738022b79f11b671ad7ae0139eab4cfde" translate="yes" xml:space="preserve">
          <source>The value itself can also be an expression:</source>
          <target state="translated">值本身也可以是一个表达式。</target>
        </trans-unit>
        <trans-unit id="a9386266d754633b2348817655aa4135672d2a80" translate="yes" xml:space="preserve">
          <source>The workaround here might be to turn your object into an &lt;em&gt;unsealed object&lt;/em&gt;.</source>
          <target state="translated">这里的解决方法可能是将您的对象变成&lt;em&gt;未密封的对象&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="6ba1aa455c617f9487799c55083af5aee022c88f" translate="yes" xml:space="preserve">
          <source>Then Flow will instead look for the file extensions &lt;code&gt;.foo&lt;/code&gt; and &lt;code&gt;.bar&lt;/code&gt;.</source>
          <target state="translated">然后，Flow将查找文件扩展名 &lt;code&gt;.foo&lt;/code&gt; 和 &lt;code&gt;.bar&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16315533799a2def071bace787cce1d7a9a11029" translate="yes" xml:space="preserve">
          <source>Then Flow will look in directories named &lt;code&gt;node_modules&lt;/code&gt; or &lt;code&gt;custom_node_modules&lt;/code&gt;.</source>
          <target state="translated">然后Flow将在名为 &lt;code&gt;node_modules&lt;/code&gt; 或 &lt;code&gt;custom_node_modules&lt;/code&gt; 的目录中查找。</target>
        </trans-unit>
        <trans-unit id="5a695f40c07e9301bce62dd550ff93b6b48cf54b" translate="yes" xml:space="preserve">
          <source>Then add &lt;code&gt;flow&lt;/code&gt; to your Babel presets config.</source>
          <target state="translated">然后将 &lt;code&gt;flow&lt;/code&gt; 添加到您的Babel预设配置中。</target>
        </trans-unit>
        <trans-unit id="bbfbb8a4c24c2122ec36dde61b7e1b8b853e31ea" translate="yes" xml:space="preserve">
          <source>Then to type a thunk action creator, add a return type of a &lt;code&gt;ThunkAction&lt;/code&gt; to your action creator.</source>
          <target state="translated">然后，要输入一个 &lt;code&gt;ThunkAction&lt;/code&gt; 创建者，请将ThunkAction的返回类型添加到您的动作创建者中。</target>
        </trans-unit>
        <trans-unit id="2d95f939b9b75dc6ef39e9b74bf9e89365c8618f" translate="yes" xml:space="preserve">
          <source>Then to type the action creator, just add a return type of the appropriate action.</source>
          <target state="translated">然后要输入动作创建者,只需添加相应动作的返回类型即可。</target>
        </trans-unit>
        <trans-unit id="8d0d1639f463f57d4ca23faf1c9cada63360b1c0" translate="yes" xml:space="preserve">
          <source>Then when Flow checks the project in &lt;code&gt;/path/to/root&lt;/code&gt;, it will read and watch</source>
          <target state="translated">然后，当Flow检查 &lt;code&gt;/path/to/root&lt;/code&gt; 中的项目时，它将读取并观看</target>
        </trans-unit>
        <trans-unit id="5d4c41383342278b4baf1bc8936c93b77b60516b" translate="yes" xml:space="preserve">
          <source>There are a number of different places where generic types appear in syntax.</source>
          <target state="translated">通用类型在语法中出现的地方有很多。</target>
        </trans-unit>
        <trans-unit id="416eb69d14d7c0984bf388d12cfb15f4c4cb73f0" translate="yes" xml:space="preserve">
          <source>There are also more specific synthetic event types like &lt;code&gt;SyntheticKeyboardEvent&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;SyntheticMouseEvent&amp;lt;T&amp;gt;&lt;/code&gt;, or &lt;code&gt;SyntheticTouchEvent&amp;lt;T&amp;gt;&lt;/code&gt;. The &lt;code&gt;SyntheticEvent&amp;lt;T&amp;gt;&lt;/code&gt; types all take a single type argument. The type of the HTML element the event handler was placed on.</source>
          <target state="translated">还有更多特定的合成事件类型，例如 &lt;code&gt;SyntheticKeyboardEvent&amp;lt;T&amp;gt;&lt;/code&gt; ， &lt;code&gt;SyntheticMouseEvent&amp;lt;T&amp;gt;&lt;/code&gt; 或 &lt;code&gt;SyntheticTouchEvent&amp;lt;T&amp;gt;&lt;/code&gt; 。所述 &lt;code&gt;SyntheticEvent&amp;lt;T&amp;gt;&lt;/code&gt; 类型都以一个单一的类型参数。放置事件处理程序的HTML元素的类型。</target>
        </trans-unit>
        <trans-unit id="1787b085e796793d008332b01f6a6da8bb5275b0" translate="yes" xml:space="preserve">
          <source>There are many different types in Flow, some of these types behave differently than others. These differences make sense for that particular type but not for others.</source>
          <target state="translated">在Flow中有许多不同的类型,其中一些类型的行为与其他类型不同。这些差异对该特定类型来说是有意义的,但对其他类型来说就不一样了。</target>
        </trans-unit>
        <trans-unit id="bf3db35b680beed72ddb758d9747774831b6fb79" translate="yes" xml:space="preserve">
          <source>There are only a couple of scenarios where you might consider using &lt;code&gt;any&lt;/code&gt;:</source>
          <target state="translated">在仅几种情况下，您可以考虑使用 &lt;code&gt;any&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6aaa00344637c45d30679cf3abd801a1db746b96" translate="yes" xml:space="preserve">
          <source>There are other cases where this happens, and they might be harder to understand. You&amp;rsquo;ll get an error like &lt;code&gt;Missing type annotation for U&lt;/code&gt; For instance, you wrote this &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQiDGsB2BnALqAhgE4F4CeoAvKANoDkeNANKDQEY0C6iApgB4AOsArjRZcAcy7ouBAJYoAgkVIV8SkgDoAtnj4AKPBQB8+AJRA&quot;&gt;code&lt;/a&gt;:</source>
          <target state="translated">在其他情况下会发生这种情况，可能很难理解。您会收到类似 &lt;code&gt;Missing type annotation for U&lt;/code&gt; 类的错误，例如，您编写了以下&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQiDGsB2BnALqAhgE4F4CeoAvKANoDkeNANKDQEY0C6iApgB4AOsArjRZcAcy7ouBAJYoAgkVIV8SkgDoAtnj4AKPBQB8+AJRA&quot;&gt;代码&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="d4e04cbaf68e5bad49ef31cbab0ae229a010af35" translate="yes" xml:space="preserve">
          <source>There are some Babel plugins which will generate &lt;code&gt;PropTypes&lt;/code&gt; from Flow types such as &lt;a href=&quot;https://github.com/thejameskyle/babel-plugin-react-flow-props-to-prop-types&quot;&gt;&lt;code&gt;babel-plugin-react-flow-props-to-prop-types&lt;/code&gt;&lt;/a&gt; if you want both static and runtime checks.</source>
          <target state="translated">如果需要静态和运行时检查，有一些Babel插件将从Flow类型生成 &lt;code&gt;PropTypes&lt;/code&gt; ，例如&lt;a href=&quot;https://github.com/thejameskyle/babel-plugin-react-flow-props-to-prop-types&quot;&gt; &lt;code&gt;babel-plugin-react-flow-props-to-prop-types&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="05f1bf8a574169e2b0cbcee1bdb8f70d3d1115e5" translate="yes" xml:space="preserve">
          <source>There are three forms of functions that each have their own slightly different syntax.</source>
          <target state="translated">有三种形式的函数,它们各自的语法略有不同。</target>
        </trans-unit>
        <trans-unit id="ee47d349aa7bd1ef38439d36fc72e0cdd36c9114" translate="yes" xml:space="preserve">
          <source>There are three ways which Flow can use to tell which files the user cares about.</source>
          <target state="translated">Flow有三种方法可以用来判断用户关心哪些文件。</target>
        </trans-unit>
        <trans-unit id="4e2987ad3c65445a4b5f525f040f6b2d00300b6c" translate="yes" xml:space="preserve">
          <source>There are two possible use cases, depending on whether an implementation file exists or not.</source>
          <target state="translated">根据实施文件是否存在,有两种可能的使用情况。</target>
        </trans-unit>
        <trans-unit id="bc6225a3f37590ec533fb885e85a5169bfedf04f" translate="yes" xml:space="preserve">
          <source>There are two potential reasons:</source>
          <target state="translated">有两个潜在的原因。</target>
        </trans-unit>
        <trans-unit id="fc65a65476288080ee29ba1be6fd72bb6d6711c0" translate="yes" xml:space="preserve">
          <source>There are two primary pieces of the syntax: type includes and type annotations.</source>
          <target state="translated">语法中主要有两块:类型包含和类型注释。</target>
        </trans-unit>
        <trans-unit id="dcd202d61a19f5fccfdf0c23e9bd5cbafd620669" translate="yes" xml:space="preserve">
          <source>There are two ways which Flow can use to tell which files the user cares about.</source>
          <target state="translated">Flow有两种方法可以用来判断用户关心哪些文件。</target>
        </trans-unit>
        <trans-unit id="fb5471e40283f41215cba92d35f5766a72606428" translate="yes" xml:space="preserve">
          <source>There is a little bit more to the definition of &lt;code&gt;React.StatelessFunctionalComponent&amp;lt;Props&amp;gt;&lt;/code&gt; for context and props.</source>
          <target state="translated">对于上下文和props ， &lt;code&gt;React.StatelessFunctionalComponent&amp;lt;Props&amp;gt;&lt;/code&gt; 的定义还有更多。</target>
        </trans-unit>
        <trans-unit id="bb1108b33f08694a9173b9d3961f8db88797e3f6" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a special type of union in Flow known as a &amp;ldquo;disjoint union&amp;rdquo; which can be used in &lt;a href=&quot;https://flow.org/en/lang/refinements/&quot;&gt;refinements&lt;/a&gt;. These disjoint unions are made up of any number of object types which are each tagged by a single property.</source>
          <target state="translated">Flow中有一种特殊的联合类型，称为&amp;ldquo;不相交联合&amp;rdquo;，可用于&lt;a href=&quot;https://flow.org/en/lang/refinements/&quot;&gt;改进&lt;/a&gt;。这些不相交的并集由任意数量的对象类型组成，每个对象类型都由单个属性标记。</target>
        </trans-unit>
        <trans-unit id="b519d9ef0909b18ff9e1aa56c6579a08789cbdf3" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a straightforward way to get around this. Store the value before calling another method and use the stored value instead. This way you can prevent the refinement from invalidating.</source>
          <target state="translated">解决这个问题的方法很简单。在调用另一个方法之前存储该值，并改用存储的值。这样，您可以防止优化无效。</target>
        </trans-unit>
        <trans-unit id="5932b1e94eef91ff83b30936f3c0165f2887a0a9" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s also a slightly shorter form of this syntax: &lt;code&gt;Type[]&lt;/code&gt;.</source>
          <target state="translated">此语法还有一种更短的形式： &lt;code&gt;Type[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c33c60a371f4bbf35c4a6734c388e9cc2e847eac" translate="yes" xml:space="preserve">
          <source>These are &lt;a href=&quot;http://caml.inria.fr/pub/docs/manual-ocaml/libref/Str.html#TYPEregexp&quot;&gt;OCaml regular expressions&lt;/a&gt;.</source>
          <target state="translated">这些是&lt;a href=&quot;http://caml.inria.fr/pub/docs/manual-ocaml/libref/Str.html#TYPEregexp&quot;&gt;OCaml正则表达式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bf1350e4fbb26ae0f7f95072f456f487f37767ce" translate="yes" xml:space="preserve">
          <source>These are &lt;a href=&quot;http://caml.inria.fr/pub/docs/manual-ocaml/libref/Str.html#TYPEregexp&quot;&gt;OCaml regular expressions&lt;/a&gt;. Use &lt;code&gt;\(&lt;/code&gt; and &lt;code&gt;\)&lt;/code&gt; (slashes required!) to create a capturing group, which you can refer to in the replacement pattern as &lt;code&gt;\1&lt;/code&gt; (up to &lt;code&gt;\9&lt;/code&gt;).</source>
          <target state="translated">这些是&lt;a href=&quot;http://caml.inria.fr/pub/docs/manual-ocaml/libref/Str.html#TYPEregexp&quot;&gt;OCaml正则表达式&lt;/a&gt;。使用 &lt;code&gt;\(&lt;/code&gt; 和 &lt;code&gt;\)&lt;/code&gt; （需要加斜杠！）创建捕获组，您可以在替换模式中将其称为 &lt;code&gt;\1&lt;/code&gt; （最大为 &lt;code&gt;\9&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="973bfa9d37cd36bbc104342639ed6decfd34c64c" translate="yes" xml:space="preserve">
          <source>These comments allow Flow to work in plain JavaScript files without any additional work.</source>
          <target state="translated">这些注释允许Flow在纯JavaScript文件中工作,而无需任何额外的工作。</target>
        </trans-unit>
        <trans-unit id="d93265fc7d47ba2359b8e8723579e2877162a149" translate="yes" xml:space="preserve">
          <source>These regular expressions match against absolute paths. They probably should start with &lt;code&gt;.*&lt;/code&gt;</source>
          <target state="translated">这些正则表达式与绝对路径匹配。他们可能应该以 &lt;code&gt;.*&lt;/code&gt; 开头</target>
        </trans-unit>
        <trans-unit id="e82167070fabc30781330eea12f26f96e5cc3459" translate="yes" xml:space="preserve">
          <source>These special files use the same &lt;code&gt;.js&lt;/code&gt; extension as normal JS code, but they are placed in a directory called &lt;code&gt;flow-typed&lt;/code&gt; in the root directory of your project. Placement in this directory tells Flow to interpret them as libdefs rather than normal JS files.</source>
          <target state="translated">这些特殊文件使用与普通JS代码相同的 &lt;code&gt;.js&lt;/code&gt; 扩展名，但是它们放置在项目的根目录中名为 &lt;code&gt;flow-typed&lt;/code&gt; 的目录中。在此目录中的放置会告诉Flow将它们解释为libdefs而不是普通的JS文件。</target>
        </trans-unit>
        <trans-unit id="420387e05d0ef5c191c2b528df67882573697852" translate="yes" xml:space="preserve">
          <source>These three are the most common categories of types. They will make up the majority of the types you&amp;rsquo;ll be writing.</source>
          <target state="translated">这三个是最常见的类型类别。它们将构成您将要编写的大多数类型。</target>
        </trans-unit>
        <trans-unit id="521ca96243c563b5695a0817345b1aaac530fbea" translate="yes" xml:space="preserve">
          <source>These type aliases can be used anywhere a type can be used.</source>
          <target state="translated">这些类型别名可以用在任何可以使用类型的地方。</target>
        </trans-unit>
        <trans-unit id="03c735f166579e7b6a2b1df8b0b57996603576f1" translate="yes" xml:space="preserve">
          <source>These types are all exported as named type exports from the &lt;code&gt;react&lt;/code&gt; module. If you want to access them as members on the &lt;code&gt;React&lt;/code&gt; object (e.g. &lt;a href=&quot;#toc-react-node&quot;&gt;&lt;code&gt;React.Node&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#toc-react-statelessfunctionalcomponent&quot;&gt;&lt;code&gt;React.StatelessFunctionalComponent&lt;/code&gt;&lt;/a&gt;) and you are importing React as an ES module then you should import &lt;code&gt;React&lt;/code&gt; as a namespace:</source>
          <target state="translated">这些类型都从 &lt;code&gt;react&lt;/code&gt; 模块作为命名类型导出导出。如果要作为 &lt;code&gt;React&lt;/code&gt; 对象上的成员（例如&lt;a href=&quot;#toc-react-node&quot;&gt; &lt;code&gt;React.Node&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#toc-react-statelessfunctionalcomponent&quot;&gt; &lt;code&gt;React.StatelessFunctionalComponent&lt;/code&gt; &lt;/a&gt;）访问它们，并且要将 React作为ES模块导入，则应将 &lt;code&gt;React&lt;/code&gt; 作为名称空间导入：</target>
        </trans-unit>
        <trans-unit id="38dbce068fe67847b4312ef7a49844b1a3730edb" translate="yes" xml:space="preserve">
          <source>These unknown types are less common, but are still useful at times.</source>
          <target state="translated">这些不知名的类型虽然不太常见,但有时候还是很有用的。</target>
        </trans-unit>
        <trans-unit id="630fbbe3db84f8cd1f22f033444bd46fd4f788d9" translate="yes" xml:space="preserve">
          <source>These values can be used in many different ways:</source>
          <target state="translated">这些值可以以许多不同的方式使用。</target>
        </trans-unit>
        <trans-unit id="acee363f8ecdca8ebcbfe3c36617f3a858f460fa" translate="yes" xml:space="preserve">
          <source>These wrapper objects are rarely used.</source>
          <target state="translated">这些包装器对象很少使用。</target>
        </trans-unit>
        <trans-unit id="0ecb01f38d4891f3ba605fe10abbc133a33eebcb" translate="yes" xml:space="preserve">
          <source>Things to keep in mind:</source>
          <target state="translated">需要注意的事项。</target>
        </trans-unit>
        <trans-unit id="25df2f7528015bf66ff8cb5856b46ca9f89a989e" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;[declarations]&lt;/code&gt; section will parse in declaration mode:</source>
          <target state="translated">此 &lt;code&gt;[declarations]&lt;/code&gt; 部分将以声明模式进行解析：</target>
        </trans-unit>
        <trans-unit id="633b00a02de45953dce9e17ff82080b18f32ddce" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;[ignore]&lt;/code&gt; section will ignore:</source>
          <target state="translated">此 &lt;code&gt;[ignore]&lt;/code&gt; 部分将忽略：</target>
        </trans-unit>
        <trans-unit id="881b9060a283396b0ef0fc92c8d4d847c624170a" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;[untyped]&lt;/code&gt; section will parse:</source>
          <target state="translated">此 &lt;code&gt;[untyped]&lt;/code&gt; 部分将解析：</target>
        </trans-unit>
        <trans-unit id="6523434d73a5cea939dbb47f88e915c46aa3c5df" translate="yes" xml:space="preserve">
          <source>This affects Linux only.</source>
          <target state="translated">这只影响Linux。</target>
        </trans-unit>
        <trans-unit id="543aa46e91339d316364681d2b7a939cdad920b8" translate="yes" xml:space="preserve">
          <source>This allows you to pass a less specific type in place of that property.</source>
          <target state="translated">这允许你传递一个不太具体的类型来代替该属性。</target>
        </trans-unit>
        <trans-unit id="1766dd7d0a89406504a02b5ace1d77e4b69c5963" translate="yes" xml:space="preserve">
          <source>This allows you to pass a more specific type in place of that property.</source>
          <target state="translated">这允许你传递一个更具体的类型来代替该属性。</target>
        </trans-unit>
        <trans-unit id="2bd174f439abda4ebf248fb0e156219e91c6b759" translate="yes" xml:space="preserve">
          <source>This can be especially useful for referring to the type of React props, or, even the entire &lt;code&gt;props&lt;/code&gt; type itself.</source>
          <target state="translated">这对于引用React道具的类型，甚至是整个 &lt;code&gt;props&lt;/code&gt; 本身的类型尤其有用。</target>
        </trans-unit>
        <trans-unit id="7b5bf94cd27d17a08f16ee047fe0e258d2090c51" translate="yes" xml:space="preserve">
          <source>This case happens often when you use &lt;code&gt;array.map()&lt;/code&gt; such as in:</source>
          <target state="translated">这种情况通常在使用 &lt;code&gt;array.map()&lt;/code&gt; 时发生，例如：</target>
        </trans-unit>
        <trans-unit id="79978b89a7e3ee94ff65dc558994d8b9943253b3" translate="yes" xml:space="preserve">
          <source>This code leads to a runtime type error, since we are attempting to perform a call on a number. Flow, however, does not flag an error here, because we have annotated variable &lt;code&gt;one&lt;/code&gt; as &lt;code&gt;any&lt;/code&gt;. Flow&amp;rsquo;s checking is effectively turned off whenever &lt;code&gt;any&lt;/code&gt; is involved, so it will silently allow the call. The use of this &lt;em&gt;unsafe&lt;/em&gt; type has rendered the type checker ineffective, and the coverage metric is here to surface this, by reporting all instances of &lt;code&gt;one&lt;/code&gt; as uncovered.</source>
          <target state="translated">这段代码会导致运行时类型错误，因为我们正在尝试对数字进行呼叫。但是Flow在这里不会标记错误，因为我们已将变量 &lt;code&gt;one&lt;/code&gt; 注释为 &lt;code&gt;any&lt;/code&gt; 。流的检查是有效地关闭每当 &lt;code&gt;any&lt;/code&gt; 参与，所以它会悄悄地允许呼叫。使用这种&lt;em&gt;不安全&lt;/em&gt;类型会导致类型检查器失效，而在这里，覆盖率指标可以通过将 &lt;code&gt;one&lt;/code&gt; 实例的所有实例报告为未发现来体现出来。</target>
        </trans-unit>
        <trans-unit id="f0b87f03b6d241cb8b45f84bd4bf0506c5abe6b1" translate="yes" xml:space="preserve">
          <source>This command first starts a background process that will check all &lt;a href=&quot;#toc-prepare-your-code-for-flow&quot;&gt;Flow files&lt;/a&gt; for errors. The background process continues running, monitoring changes to your code and checking those changes incrementally for errors.</source>
          <target state="translated">该命令首先启动一个后台进程，该进程将检查所有&lt;a href=&quot;#toc-prepare-your-code-for-flow&quot;&gt;Flow文件&lt;/a&gt;是否存在错误。后台进程继续运行，监视代码更改并逐步检查这些更改是否有错误。</target>
        </trans-unit>
        <trans-unit id="57498d0fa536623389bfd336daad29db2ae2dc08" translate="yes" xml:space="preserve">
          <source>This command uses types that Flow infers, to fill in positions that would otherwise raise &lt;em&gt;signature-verification&lt;/em&gt; failures. It will include the necessary type import statements, as long as the respective types are exported from their defining modules.</source>
          <target state="translated">此命令使用Flow推断的类型来填充可能会导致&lt;em&gt;签名验证&lt;/em&gt;失败的位置。只要相应的类型是从其定义模块中导出的，它将包括必要的类型导入语句。</target>
        </trans-unit>
        <trans-unit id="00dd495b583130371ce040479335e5dc21959b5e" translate="yes" xml:space="preserve">
          <source>This command will transform files under &lt;code&gt;/path/to/folder&lt;/code&gt;. This does not need to be the root directory (the one containing &lt;code&gt;.flowconfig&lt;/code&gt;).</source>
          <target state="translated">此命令将转换 &lt;code&gt;/path/to/folder&lt;/code&gt; 下的文件。该目录不必是根目录（包含 &lt;code&gt;.flowconfig&lt;/code&gt; 的目录）。</target>
        </trans-unit>
        <trans-unit id="3d875274c3b689e4f7ad033af88961c28bd2f54a" translate="yes" xml:space="preserve">
          <source>This compiles to: &lt;code&gt;React.createElement(MyComponent, {}, '// some comment...', 42)&lt;/code&gt;. See how the comment is included in the element&amp;rsquo;s children? In this case &lt;code&gt;props.children&lt;/code&gt; would be &lt;code&gt;['// some comment...', 42]&lt;/code&gt; which includes the comment. To write comments in JSX use the following syntax:</source>
          <target state="translated">编译为： &lt;code&gt;React.createElement(MyComponent, {}, '// some comment...', 42)&lt;/code&gt; 。看看评论如何包含在元素的子元素中？在这种情况下， &lt;code&gt;props.children&lt;/code&gt; 将是 &lt;code&gt;['// some comment...', 42]&lt;/code&gt; ，其中包括注释。要在JSX中编写注释，请使用以下语法：</target>
        </trans-unit>
        <trans-unit id="1981415185918a76b00cd452a5e0eb6fd87253c8" translate="yes" xml:space="preserve">
          <source>This compiles to: &lt;code&gt;React.createElement(MyComponent, {}, 42, '  ')&lt;/code&gt;. (With the spaces!) See how the spaces show up as part of the children? In this case &lt;code&gt;props.children&lt;/code&gt; would be &lt;code&gt;[42, '  ']&lt;/code&gt; and &lt;em&gt;not&lt;/em&gt; the number 42. However, the following is fine:</source>
          <target state="translated">编译为： &lt;code&gt;React.createElement(MyComponent, {}, 42, ' ')&lt;/code&gt; 。（带有空格！）看看空格如何作为孩子的一部分出现？在这种情况下 &lt;code&gt;props.children&lt;/code&gt; 将是 &lt;code&gt;[42, ' ']&lt;/code&gt; 而&lt;em&gt;不是&lt;/em&gt;数字42。但是，可以使用以下命令：</target>
        </trans-unit>
        <trans-unit id="734dbfe930904c1dff5464c3868a3c58b214bbf9" translate="yes" xml:space="preserve">
          <source>This flag is in the form of a normal JavaScript comment annotated with &lt;code&gt;@flow&lt;/code&gt;. The Flow background process gathers all the files with this flag and uses the type information available from all of these files to ensure consistency and error free programming.</source>
          <target state="translated">此标志的形式为普通的JavaScript注释，并带有 &lt;code&gt;@flow&lt;/code&gt; 注释。Flow后台进程使用此标志收集所有文件，并使用所有这些文件中可用的类型信息来确保一致性和无错误编程。</target>
        </trans-unit>
        <trans-unit id="e8107dcd86e50a45fb0aff78e434d3e405ffe634" translate="yes" xml:space="preserve">
          <source>This follows the same rule that when you pass in a single child then &lt;code&gt;props.children&lt;/code&gt; will be &lt;em&gt;exactly&lt;/em&gt; that value. Even though &lt;code&gt;[1, 2]&lt;/code&gt; is an array it is a single value and so &lt;code&gt;props.children&lt;/code&gt; will be &lt;em&gt;exactly&lt;/em&gt; that value. That is to say &lt;code&gt;props.children&lt;/code&gt; will be the array &lt;code&gt;[1, 2]&lt;/code&gt; and not an array of arrays.</source>
          <target state="translated">在此之前，同样的规则，当你在一个孩子通过，则 &lt;code&gt;props.children&lt;/code&gt; 会&lt;em&gt;正是&lt;/em&gt;该值。即使 &lt;code&gt;[1, 2]&lt;/code&gt; 是一个数组它是一个单一的值，因此 &lt;code&gt;props.children&lt;/code&gt; 将&lt;em&gt;正好&lt;/em&gt;为该值。也就是说 &lt;code&gt;props.children&lt;/code&gt; 将是数组 &lt;code&gt;[1, 2]&lt;/code&gt; 而不是数组的数组。</target>
        </trans-unit>
        <trans-unit id="d7ef0baedb6b23a6e6c0bc9c81182d27e5e3dc1d" translate="yes" xml:space="preserve">
          <source>This guide will teach you the syntax and semantics of all the different types you can have in Flow.</source>
          <target state="translated">本指南将教你在Flow中可以拥有的所有不同类型的语法和语义。</target>
        </trans-unit>
        <trans-unit id="096c3c9fc415cf70866aa9adcd243f084dfc276d" translate="yes" xml:space="preserve">
          <source>This includes the code into the syntax that Flow sees.</source>
          <target state="translated">这包括代码到Flow看到的语法。</target>
        </trans-unit>
        <trans-unit id="d9fb28a17538a9106a3ad6a6bed152242ff6e4d8" translate="yes" xml:space="preserve">
          <source>This is Flow&amp;rsquo;s most abstract representation of a React component, and is most useful for writing HOCs and library definitions.</source>
          <target state="translated">这是Flow对React组件的最抽象表示，对于编写HOC和库定义最有用。</target>
        </trans-unit>
        <trans-unit id="9af90c0ecae6766788f603b8275d9514e3979ca9" translate="yes" xml:space="preserve">
          <source>This is a basic template for what your HOCs might look like. At runtime, this HOC doesn&amp;rsquo;t do anything at all. Let&amp;rsquo;s take a look at some more complex examples.</source>
          <target state="translated">这是您的HOC外观的基本模板。在运行时，此HOC根本不执行任何操作。让我们看一些更复杂的例子。</target>
        </trans-unit>
        <trans-unit id="c365f2918438c7a6e1888b46e0b930bd53745fff" translate="yes" xml:space="preserve">
          <source>This is a kind of subtyping commonly referred to as &amp;ldquo;width subtyping&amp;rdquo; because a type that is &amp;ldquo;wider&amp;rdquo; (i.e., has more properties) is a subtype of a narrower type.</source>
          <target state="translated">这是一种子类型，通常称为&amp;ldquo;宽度子类型&amp;rdquo;，因为&amp;ldquo;较宽&amp;rdquo;（即具有更多属性）的类型是较窄类型的子类型。</target>
        </trans-unit>
        <trans-unit id="75b065150ca9eda7d9b645bb02ec9b648bf937bd" translate="yes" xml:space="preserve">
          <source>This is a union of a class component or a stateless functional component. This is the type you want to use for functions that receive or return React components such as higher-order components or other utilities.</source>
          <target state="translated">这是一个类组件或无状态功能组件的联合体。这是您要用于接收或返回React组件(如高阶组件或其他实用程序)的函数的类型。</target>
        </trans-unit>
        <trans-unit id="eb111ed813f5032a53f03d0b631da3f19b265167" translate="yes" xml:space="preserve">
          <source>This is also okay because if something is using &lt;code&gt;SubClass&lt;/code&gt; as if it were a &lt;code&gt;BaseClass&lt;/code&gt; they would still have access to the same interface as before because &lt;code&gt;SanFrancisco&lt;/code&gt; is just a &lt;code&gt;City&lt;/code&gt; with a little more information.</source>
          <target state="translated">因为如果事情是用这也没关系 &lt;code&gt;SubClass&lt;/code&gt; ，好像它是一个 &lt;code&gt;BaseClass&lt;/code&gt; 的他们仍然将有机会获得与以前相同的界面，因为 &lt;code&gt;SanFrancisco&lt;/code&gt; 的只是一个 &lt;code&gt;City&lt;/code&gt; 多一点的信息。</target>
        </trans-unit>
        <trans-unit id="ed9084ae2d3a6d3909814247a0a9d2fe5955a81d" translate="yes" xml:space="preserve">
          <source>This is an error because objects are mutable. The value referenced by the &lt;code&gt;employee&lt;/code&gt; variable is the same as the value referenced by the &lt;code&gt;person&lt;/code&gt; variable.</source>
          <target state="translated">这是一个错误，因为对象是可变的。由所引用的值 &lt;code&gt;employee&lt;/code&gt; 变量是与由所引用的值 &lt;code&gt;person&lt;/code&gt; 可变。</target>
        </trans-unit>
        <trans-unit id="5b9e89f0566afa9b997d9c3c388578a1bf739bfd" translate="yes" xml:space="preserve">
          <source>This is an error in Flow because if you are expecting a &lt;code&gt;SanFrancisco&lt;/code&gt; and you get a &lt;code&gt;City&lt;/code&gt; you could be using something that only exists on &lt;code&gt;SanFrancisco&lt;/code&gt; which would cause an error at runtime.</source>
          <target state="translated">这是Flow中的错误，因为如果您期望使用 &lt;code&gt;SanFrancisco&lt;/code&gt; ,而您获得了 &lt;code&gt;City&lt;/code&gt; ，则可能使用的仅是 &lt;code&gt;SanFrancisco&lt;/code&gt; 上存在的东西，这会在运行时导致错误。</target>
        </trans-unit>
        <trans-unit id="56976d17f40e185b38c5c6efa84d2af088f0b974" translate="yes" xml:space="preserve">
          <source>This is because classes in Flow are &lt;a href=&quot;https://flow.org/en/lang/nominal-structural&quot;&gt;nominally typed&lt;/a&gt;.</source>
          <target state="translated">这是因为Flow中的类是&lt;a href=&quot;https://flow.org/en/lang/nominal-structural&quot;&gt;名义上键入的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="127badd88c854dba7d3f79ae45c90e45e0bab65a" translate="yes" xml:space="preserve">
          <source>This is because in Flow it is okay to pass an object value with more properties than the object type expects (because of width subtyping).</source>
          <target state="translated">这是因为在Flow中,可以传递一个比对象类型期望的属性更多的对象值(因为宽度子类型)。</target>
        </trans-unit>
        <trans-unit id="987cc1138d48992770da78cddf5c25e772ec1fb5" translate="yes" xml:space="preserve">
          <source>This is because the only refinements supported through &lt;code&gt;bar&lt;/code&gt; would be on &lt;code&gt;obj&lt;/code&gt; itself.</source>
          <target state="translated">这是因为通过 &lt;code&gt;bar&lt;/code&gt; 支持的唯一改进是在 &lt;code&gt;obj&lt;/code&gt; 本身上。</target>
        </trans-unit>
        <trans-unit id="a696e7fa8715b1a73c06f5c45c3a6a89c88aadac" translate="yes" xml:space="preserve">
          <source>This is different from the &lt;code&gt;[ignore]&lt;/code&gt; config section that causes matching files to be ignored by the module resolver, which inherently makes them un-typechecked, and also unresolvable by &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt;. When ignored &lt;code&gt;[libs]&lt;/code&gt; must then be specified for each &lt;code&gt;import&lt;/code&gt; using &lt;code&gt;flow-typed&lt;/code&gt;, which may not always be desired.</source>
          <target state="translated">这与 &lt;code&gt;[ignore]&lt;/code&gt; config部分不同，后者导致模块解析器忽略匹配的文件，该文件固有地使它们未经类型检查，并且也无法通过 &lt;code&gt;import&lt;/code&gt; 或 &lt;code&gt;require&lt;/code&gt; 解析。如果被忽略，则必须使用 &lt;code&gt;flow-typed&lt;/code&gt; 为每个 &lt;code&gt;import&lt;/code&gt; 指定 &lt;code&gt;[libs]&lt;/code&gt; ，但这可能并不总是需要的。</target>
        </trans-unit>
        <trans-unit id="a3e3b48d7024605ecf73a60b4a059e305833ff81" translate="yes" xml:space="preserve">
          <source>This is extremely useful for expressing the return type of functions that manipulate objects values. You could use a similar approach (for instance) to provide the return type of bluebird&amp;rsquo;s &lt;a href=&quot;http://bluebirdjs.com/docs/api/promise.props.html&quot;&gt;&lt;code&gt;Promise.props&lt;/code&gt;&lt;/a&gt; function, which is like &lt;code&gt;Promise.all&lt;/code&gt; but takes an object as input.</source>
          <target state="translated">这对于表示操作对象值的函数的返回类型非常有用。您可以使用类似的方法（例如）来提供bluebird的&lt;a href=&quot;http://bluebirdjs.com/docs/api/promise.props.html&quot;&gt; &lt;code&gt;Promise.props&lt;/code&gt; &lt;/a&gt;函数的返回类型，类似于 &lt;code&gt;Promise.all&lt;/code&gt; ,但将对象作为输入。</target>
        </trans-unit>
        <trans-unit id="60dfb0118bc43aa84388f7d66bc4c2be8af7089f" translate="yes" xml:space="preserve">
          <source>This is okay because if something else in your program is using &lt;code&gt;SubClass&lt;/code&gt; as if it were a &lt;code&gt;BaseClass&lt;/code&gt;, it would still be using a &lt;code&gt;City&lt;/code&gt; and wouldn&amp;rsquo;t cause any issues.</source>
          <target state="translated">没关系，因为如果您程序中的其他某些东西正在使用 &lt;code&gt;SubClass&lt;/code&gt; 就像是 &lt;code&gt;BaseClass&lt;/code&gt; 一样，它将仍然使用 &lt;code&gt;City&lt;/code&gt; 且不会引起任何问题。</target>
        </trans-unit>
        <trans-unit id="def5148d9c559d37a047e98dc2513022553f61be" translate="yes" xml:space="preserve">
          <source>This is perfectly fine because if we pass in a more specific type we&amp;rsquo;ll still have all the information we need to be compatible with &lt;code&gt;Noun&lt;/code&gt;.</source>
          <target state="translated">这非常好，因为如果我们传递更具体的类型，我们仍将拥有与 &lt;code&gt;Noun&lt;/code&gt; 兼容所需的所有信息。</target>
        </trans-unit>
        <trans-unit id="424b976babef7901da66b2db61ee539c2a0be62a" translate="yes" xml:space="preserve">
          <source>This is the type of a React stateless functional component.</source>
          <target state="translated">这是一个React无状态功能组件的类型。</target>
        </trans-unit>
        <trans-unit id="b2b862b3fcdd9450bc624dc8b8cf55e1f701d1ad" translate="yes" xml:space="preserve">
          <source>This is unsafe and not recommended. But it&amp;rsquo;s sometimes useful when you are doing something with a value which is very difficult or impossible to type and want to make sure that the result has the desired type.</source>
          <target state="translated">这是不安全的，不建议这样做。但是，当您使用很难或不可能键入的值来做某事并且想要确保结果具有所需的类型时，它有时会很有用。</target>
        </trans-unit>
        <trans-unit id="35aa78e533f2578f7e162a36de338a1f47f6c0b2" translate="yes" xml:space="preserve">
          <source>This is useful when you need to use a read-only version of an object type you&amp;rsquo;ve already defined, without manually having to re-define and annotate each key as read-only. For example:</source>
          <target state="translated">当您需要使用已经定义的对象类型的只读版本，而无需手动将每个键重新定义和注释为只读时，这很有用。例如：</target>
        </trans-unit>
        <trans-unit id="f4cb01bc5bdd818c1407e6cedc026d2b0b09c1ad" translate="yes" xml:space="preserve">
          <source>This is very handy, but sometimes you need to access the enum definition at runtime (i.e. at a value level).</source>
          <target state="translated">这是非常方便的,但有时你需要在运行时访问枚举定义(即在值级别)。</target>
        </trans-unit>
        <trans-unit id="54f3db6a2015884e8473b3172c31c08a869daab0" translate="yes" xml:space="preserve">
          <source>This is where &lt;a href=&quot;../types#toc-react-config&quot;&gt;&lt;code&gt;React.Config&amp;lt;Props, DefaultProps&amp;gt;&lt;/code&gt;&lt;/a&gt; comes in handy! We can use the type for Props and DefaultProps to calculate the &lt;code&gt;Config&lt;/code&gt; type for our component.</source>
          <target state="translated">这是&lt;a href=&quot;../types#toc-react-config&quot;&gt; &lt;code&gt;React.Config&amp;lt;Props, DefaultProps&amp;gt;&lt;/code&gt; &lt;/a&gt;派上用场的地方！我们可以使用Props和DefaultProps的类型来计算组件的 &lt;code&gt;Config&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="21ae5e6ce6468f7ff3f32ccfa0dd3f8fb2f7bcea" translate="yes" xml:space="preserve">
          <source>This is where &lt;code&gt;ObjMap&amp;lt;T, F&amp;gt;&lt;/code&gt; comes in handy.</source>
          <target state="translated">这是 &lt;code&gt;ObjMap&amp;lt;T, F&amp;gt;&lt;/code&gt; 派上用场的地方。</target>
        </trans-unit>
        <trans-unit id="ee856278c549261688abdbd19d4ddec7e5efdc46" translate="yes" xml:space="preserve">
          <source>This lint setting is ignored when &lt;code&gt;exact_by_default&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;exact_by_default&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 时，将忽略此皮棉设置。</target>
        </trans-unit>
        <trans-unit id="a70889c6b7d22baa7cf64ab4c9b4c3c93d6d9191" translate="yes" xml:space="preserve">
          <source>This makes Flow treat &lt;code&gt;require('image!foo.jpg')&lt;/code&gt; as if it were &lt;code&gt;require('ImageStub')&lt;/code&gt;.</source>
          <target state="translated">这使得Flow将 &lt;code&gt;require('image!foo.jpg')&lt;/code&gt; 视为 &lt;code&gt;require('ImageStub')&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e23feb9278c999088a311838ae5b7031bb5b5bf1" translate="yes" xml:space="preserve">
          <source>This makes it clear to the reader that &lt;code&gt;bar&lt;/code&gt; is not a potentially nullish property.</source>
          <target state="translated">这使读者清楚知道 &lt;code&gt;bar&lt;/code&gt; 不是潜在的无效属性。</target>
        </trans-unit>
        <trans-unit id="76437fdbf44079b1c571bd4124ab2ff68199ec3a" translate="yes" xml:space="preserve">
          <source>This means that a shorter tuple can&amp;rsquo;t be used in place of a longer one.</source>
          <target state="translated">这意味着不能使用较短的元组代替较长的元组。</target>
        </trans-unit>
        <trans-unit id="ebff5f8c600e3fd9834aa943d918c1bfbd8d2dbe" translate="yes" xml:space="preserve">
          <source>This means that reads from unsealed objects with no matching writes are never checked. This is an unsafe behavior of Flow which may be improved in the future.</source>
          <target state="translated">这意味着,从未密封的对象中读取的数据,如果没有匹配的写入数据,则永远不会被检查。这是Flow的一个不安全行为,将来可能会被改进。</target>
        </trans-unit>
        <trans-unit id="3bf9058b929ae73030823387d719318f0032a9fd" translate="yes" xml:space="preserve">
          <source>This means that the following 2 types are equivalent:</source>
          <target state="translated">这意味着,以下2种类型是等同的。</target>
        </trans-unit>
        <trans-unit id="6784af09c850d7330fc9ffa9c72f9fa8a86cc84a" translate="yes" xml:space="preserve">
          <source>This often means figuring out if the value you are passing in is a subtype of the value you are expecting.</source>
          <target state="translated">这通常意味着要弄清楚你传入的值是否是你所期望的值的子类型。</target>
        </trans-unit>
        <trans-unit id="2cd8bc2873ab259581a052bdf16376541801c36c" translate="yes" xml:space="preserve">
          <source>This option configures the maximum possible size for the shared heap. You should most likely not need to configure this, as it doesn&amp;rsquo;t really affect how much RSS Flow uses. However, if you are working on a massive codebase you might see the following error after init: &amp;ldquo;Heap init size is too close to max heap size; GC will never get triggered!&amp;rdquo; In this case, you may need to increase the size of the heap.</source>
          <target state="translated">此选项配置共享堆的最大可能大小。您很可能不需要配置它，因为它实际上并不会影响RSS Flow的使用量。但是，如果您正在使用庞大的代码库，则在init之后可能会看到以下错误：GC将永远不会被触发！&amp;rdquo; 在这种情况下，您可能需要增加堆的大小。</target>
        </trans-unit>
        <trans-unit id="b218d95c59f706fc5a5e4f4c250e3a7ed23a95c4" translate="yes" xml:space="preserve">
          <source>This option is set to &lt;code&gt;true&lt;/code&gt; by default, since it is implied by &lt;a href=&quot;#toc-types-first-boolean&quot;&gt;&lt;code&gt;types_first&lt;/code&gt;&lt;/a&gt;, but the option is useful on its own when upgrading a project from classic mode to types-first mode.</source>
          <target state="translated">默认情况下，此选项设置为 &lt;code&gt;true&lt;/code&gt; ，因为&lt;a href=&quot;#toc-types-first-boolean&quot;&gt; &lt;code&gt;types_first&lt;/code&gt; &lt;/a&gt;隐含了该选项，但是当将项目从经典模式升级到类型优先模式时，该选项本身很有用。</target>
        </trans-unit>
        <trans-unit id="9586cb7b0444ddcbaf378ece59924e71eed799e4" translate="yes" xml:space="preserve">
          <source>This option lets you alias &lt;code&gt;any&lt;/code&gt; with a given string. This is useful for explaining why you&amp;rsquo;re using &lt;code&gt;any&lt;/code&gt;. For example, let&amp;rsquo;s say you sometimes want to sometimes use &lt;code&gt;any&lt;/code&gt; to suppress an error and sometimes to mark a TODO. Your code might look like</source>
          <target state="translated">使用此选项，您可以使用给定的字符串为 &lt;code&gt;any&lt;/code&gt; 别名。这对于解释为什么使用 &lt;code&gt;any&lt;/code&gt; 很有用。例如，假设您有时要使用 &lt;code&gt;any&lt;/code&gt; 来抑制错误，有时要标记TODO。您的代码可能看起来像</target>
        </trans-unit>
        <trans-unit id="0f8104fc2a3ba71732d91aefe2ba32da9e1bba10" translate="yes" xml:space="preserve">
          <source>This output means that 5 out of the 10 nodes of this program were inferred to have type &lt;code&gt;any&lt;/code&gt;. To see exactly which parts are uncovered you can also pass one of the following flags:</source>
          <target state="translated">此输出意味着该程序的10个节点中有5个被推断为具有 &lt;code&gt;any&lt;/code&gt; 类型。要确切地发现哪些部分，您还可以传递以下标志之一：</target>
        </trans-unit>
        <trans-unit id="36407b4a8671f76cf48e67ecd38443356cf43c1d" translate="yes" xml:space="preserve">
          <source>This pattern is also not limited to function children. You could also pass in arbitrary object or class types.</source>
          <target state="translated">这种模式也不局限于函数子代,你也可以传入任意的对象或类类型。你也可以传入任意的对象或类类型。</target>
        </trans-unit>
        <trans-unit id="8daebbe8ae6fc42b982d8e4fe22459a7a10cd94c" translate="yes" xml:space="preserve">
          <source>This represents any node that can be rendered in a React application. &lt;code&gt;React.Node&lt;/code&gt; can be null, a boolean, a number, a string, a React element, or an array of any of those types recursively.</source>
          <target state="translated">这表示可以在React应用程序中呈现的任何节点。 &lt;code&gt;React.Node&lt;/code&gt; 可以为null，布尔值，数字，字符串，React元素或任何这些类型的数组。</target>
        </trans-unit>
        <trans-unit id="752249d3acac833c3c21ce430f38863e1937ed27" translate="yes" xml:space="preserve">
          <source>This syntax is also available in a &lt;code&gt;flow-include&lt;/code&gt; form.</source>
          <target state="translated">此语法也可以以包含 &lt;code&gt;flow-include&lt;/code&gt; 形式使用。</target>
        </trans-unit>
        <trans-unit id="5b31f92efc0a4da4dd28fb6304800cf7cd7fbb9c" translate="yes" xml:space="preserve">
          <source>This tells Flow that any code within the project can reference the &lt;code&gt;PI&lt;/code&gt; global variable &amp;ndash; which, in this case, is a &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">这告诉Flow，项目中的任何代码都可以引用 &lt;code&gt;PI&lt;/code&gt; 全局变量&amp;ndash;在本例中为 &lt;code&gt;number&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f16bca30984be4eadbc92268c71095b6f69d5a4" translate="yes" xml:space="preserve">
          <source>This tells Flow that any code within the project can reference the &lt;code&gt;URL&lt;/code&gt; global class. Note that this class definition does not have any implementation details &amp;ndash; it exclusively defines the interface of the class.</source>
          <target state="translated">这告诉Flow，项目中的任何代码都可以引用 &lt;code&gt;URL&lt;/code&gt; 全局类。请注意，该类定义没有任何实现细节&amp;ndash;它专门定义了该类的接口。</target>
        </trans-unit>
        <trans-unit id="fe10f9e40b8844cde008f22e6f7e27a41dd5807d" translate="yes" xml:space="preserve">
          <source>This tells Flow that any code within the project can reference the &lt;code&gt;UserID&lt;/code&gt; global type &amp;ndash; which, in this case, is just an alias for &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">这告诉Flow，项目中的任何代码都可以引用 &lt;code&gt;UserID&lt;/code&gt; 全局类型-在这种情况下，它只是 &lt;code&gt;number&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="b06e9eb45a05735715e1d1b65c57610ee02c78b2" translate="yes" xml:space="preserve">
          <source>This tells Flow that any code within the project can reference the &lt;code&gt;foo&lt;/code&gt; global function, and that the function takes one argument (a &lt;code&gt;number&lt;/code&gt;) and it returns a &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">这告诉Flow，项目中的任何代码都可以引用 &lt;code&gt;foo&lt;/code&gt; 全局函数，并且该函数采用一个参数（一个 &lt;code&gt;number&lt;/code&gt; ）并返回一个 &lt;code&gt;string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6bab6dcb6b25f93bc93c3ef139cb0898176b837" translate="yes" xml:space="preserve">
          <source>This utility has been deprecated and should be avoided. See &lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-deprecated-type&quot;&gt;here&lt;/a&gt; for details.</source>
          <target state="translated">该实用程序已被弃用，应避免使用。有关详细信息，请参见&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-deprecated-type&quot;&gt;此处&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b74c252b0eeaacbb897eb419ddf06e190d869384" translate="yes" xml:space="preserve">
          <source>This utility has been deprecated and should be avoided. See &lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-deprecated-utility&quot;&gt;here&lt;/a&gt; for details.</source>
          <target state="translated">该实用程序已被弃用，应避免使用。有关详细信息，请参见&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-deprecated-utility&quot;&gt;此处&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cabd9148684b1aa762ff2b690b8f720e71dd5acb" translate="yes" xml:space="preserve">
          <source>This way you avoid duplicating the properties that happen to have a default value.</source>
          <target state="translated">这样你就可以避免重复使用恰好有一个默认值的属性。</target>
        </trans-unit>
        <trans-unit id="22fe37b0969c2ab3810a8157bfb87e3e61565f27" translate="yes" xml:space="preserve">
          <source>This way you can keep the behavior of generics while only allowing certain types to be used.</source>
          <target state="translated">这样一来,你可以保留属的行为,同时只允许使用某些类型。</target>
        </trans-unit>
        <trans-unit id="d06c742de148aa21dfa2ce9950e849bcb9ab4c64" translate="yes" xml:space="preserve">
          <source>This will give you information about everything that flow can do. Running this command should print something like this:</source>
          <target state="translated">这将给你提供关于flow能做的所有事情的信息。运行这个命令应该会打印出这样的内容。</target>
        </trans-unit>
        <trans-unit id="25f1d22273c04f62e4a5c6ea73e398a03b77af32" translate="yes" xml:space="preserve">
          <source>This will suppress both of the two errors on this line.</source>
          <target state="translated">这将抑制这一行的两个错误。</target>
        </trans-unit>
        <trans-unit id="c5358194d5e312667901904699178d180ad0d876" translate="yes" xml:space="preserve">
          <source>This would be the same as including a type annotation inside an include comment.</source>
          <target state="translated">这和在include注释中加入类型注释是一样的。</target>
        </trans-unit>
        <trans-unit id="80babb7d0ff0eda4573ad401ec556fbf50e83b89" translate="yes" xml:space="preserve">
          <source>To add a type for state to your React class component then create a new object type, in the example below we name it &lt;code&gt;State&lt;/code&gt;, and pass it as the second type argument to &lt;code&gt;React.Component&lt;/code&gt;.</source>
          <target state="translated">要将状态类型添加到React类组件中，然后创建一个新的对象类型，在下面的示例中，我们将其命名为 &lt;code&gt;State&lt;/code&gt; ，并将其作为第二个类型参数传递给 &lt;code&gt;React.Component&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="46cc112d13261a13154b6cfac4e2d48bf5063881" translate="yes" xml:space="preserve">
          <source>To create an array type you can use &lt;code&gt;Array&amp;lt;Type&amp;gt;&lt;/code&gt; type where &lt;code&gt;Type&lt;/code&gt; is the type of elements in the array. For example, to create a type for an array of numbers you use &lt;code&gt;Array&amp;lt;number&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">要创建数组类型，可以使用 &lt;code&gt;Array&amp;lt;Type&amp;gt;&lt;/code&gt; type，其中 &lt;code&gt;Type&lt;/code&gt; 是数组中元素的类型。例如，要为数字数组创建类型，请使用 &lt;code&gt;Array&amp;lt;number&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8dd0d93865b9bfacde3e4affb1eb92fd379b6bf0" translate="yes" xml:space="preserve">
          <source>To declare a global class that should be accessible throughout your project, use the &lt;code&gt;declare class&lt;/code&gt; syntax in a libdef file:</source>
          <target state="translated">要声明在整个项目中都应可访问的全局类，请在libdef文件中使用 &lt;code&gt;declare class&lt;/code&gt; 语法：</target>
        </trans-unit>
        <trans-unit id="2c05553bc81af5c0b4f02184bd805aba0fa865c0" translate="yes" xml:space="preserve">
          <source>To declare a global function that should be accessible throughout your project, use the &lt;code&gt;declare function&lt;/code&gt; syntax in a libdef file:</source>
          <target state="translated">要声明在整个项目中都可以访问的全局函数，请在libdef文件中使用 &lt;code&gt;declare function&lt;/code&gt; 语法：</target>
        </trans-unit>
        <trans-unit id="3d8d4cb10458061c2bc75c04590a96a2ed068bd5" translate="yes" xml:space="preserve">
          <source>To declare a global type that should be accessible throughout your project, use the &lt;code&gt;declare type&lt;/code&gt; syntax in a libdef file:</source>
          <target state="translated">要声明在整个项目中都应可访问的全局类型，请在libdef文件中使用 &lt;code&gt;declare type&lt;/code&gt; 语法：</target>
        </trans-unit>
        <trans-unit id="d38d878e01cad40728f252774b0c25def7d4cb78" translate="yes" xml:space="preserve">
          <source>To declare a global variable that should be accessible throughout your project, use the &lt;code&gt;declare var&lt;/code&gt; syntax in a libdef file:</source>
          <target state="translated">要声明在整个项目中都应可访问的全局变量，请在libdef文件中使用clarify &lt;code&gt;declare var&lt;/code&gt; 语法：</target>
        </trans-unit>
        <trans-unit id="f1875d662019d803a3d158d296ddb77c1752c55d" translate="yes" xml:space="preserve">
          <source>To explicitly specify the type of a context value, pass a type parameter to &lt;code&gt;createContext&lt;/code&gt;:</source>
          <target state="translated">要显式指定上下文值的类型，请将类型参数传递给 &lt;code&gt;createContext&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="dc65e5d43387ac143a42fd49169c9f382ad9e6e7" translate="yes" xml:space="preserve">
          <source>To find out more about the CLI just type:</source>
          <target state="translated">要了解更多关于CLI的信息,只需输入。</target>
        </trans-unit>
        <trans-unit id="4d7d33015c801a7c6d2c398d267001cb7e383f0d" translate="yes" xml:space="preserve">
          <source>To find out the coverage of a file foo.js with the following contents</source>
          <target state="translated">要找出包含以下内容的文件foo.js的覆盖范围。</target>
        </trans-unit>
        <trans-unit id="d062574c0bbb40aba96339ff0dbe5323fbfe73f8" translate="yes" xml:space="preserve">
          <source>To get a sense of when and why the different kinds of variance matters, let&amp;rsquo;s talk about methods of subclasses and how they get type checked.</source>
          <target state="translated">为了了解何时以及为什么不同类型的差异很重要，让我们讨论一下子类的方法以及如何对它们进行类型检查。</target>
        </trans-unit>
        <trans-unit id="e8ca9700f4d5ea2116113c0a357e597df59a1d6a" translate="yes" xml:space="preserve">
          <source>To remove a prop from the config, we can take a component that includes the prop and return a component that does not. It&amp;rsquo;s best to construct these types using object type spread.</source>
          <target state="translated">要从配置中删除道具，我们可以使用包含道具的组件，并返回不包含道具的组件。最好使用对象类型散布构造这些类型。</target>
        </trans-unit>
        <trans-unit id="af162968659acb875948b1adecd192a495aa886b" translate="yes" xml:space="preserve">
          <source>To resolve this, you can add an annotation like the following:</source>
          <target state="translated">为了解决这个问题,你可以添加一个类似下面的注释。</target>
        </trans-unit>
        <trans-unit id="8da5a47f9a8fbbb9d2efd234b56f09b304fb7f98" translate="yes" xml:space="preserve">
          <source>To see how you can annotate exported React components, check out our docs on &lt;a href=&quot;https://flow.org/en/react/hoc/#toc-exporting-wrapped-components&quot;&gt;HOCs&lt;/a&gt;.</source>
          <target state="translated">要查看如何注释导出的React组件，请查看我们关于&lt;a href=&quot;https://flow.org/en/react/hoc/#toc-exporting-wrapped-components&quot;&gt;HOC&lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="887e026dfa02b4db43c36574cea623de3e0927d9" translate="yes" xml:space="preserve">
          <source>To see what types are missing to make your codebase types-first ready, add the following line to the &lt;code&gt;[options]&lt;/code&gt; section of the &lt;code&gt;.flowconfig&lt;/code&gt; file:</source>
          <target state="translated">若要查看缺少哪些类型可使代码库类型优先使用，请在 &lt;code&gt;.flowconfig&lt;/code&gt; 文件的 &lt;code&gt;[options]&lt;/code&gt; 部分中添加以下行：</target>
        </trans-unit>
        <trans-unit id="f5fcd1977220cbf8582e71619f881b97e9e50e3e" translate="yes" xml:space="preserve">
          <source>To see why this metric was chosen for determining Flow&amp;rsquo;s effectiveness, consider the example</source>
          <target state="translated">要了解为什么选择此指标来确定Flow的有效性，请考虑以下示例</target>
        </trans-unit>
        <trans-unit id="38d849d799ad5dab7240320680d5c36bc5f7e6a7" translate="yes" xml:space="preserve">
          <source>To start a Flow server in Filesystem lazy mode, you run</source>
          <target state="translated">要在Filesystem懒惰模式下启动Flow服务器,你可以运行以下命令</target>
        </trans-unit>
        <trans-unit id="2cf8bbf7b6d19d0001e46d5b57c96b778d96ae37" translate="yes" xml:space="preserve">
          <source>To start a Flow server in IDE lazy mode, you run</source>
          <target state="translated">要在IDE的懒人模式下启动Flow服务器,你可以运行以下命令</target>
        </trans-unit>
        <trans-unit id="6e9bdac3d6d4ba3e13640e1b5c7a6fd976aa5a44" translate="yes" xml:space="preserve">
          <source>To start a Flow server in Watchman lazy mode, you run</source>
          <target state="translated">要在Watchman懒人模式下启动Flow服务器,你可以运行以下命令</target>
        </trans-unit>
        <trans-unit id="3978fe345012186156eab3faa3a6473c8b81612a" translate="yes" xml:space="preserve">
          <source>To start, we can define a SubClass that extends our BaseClass. Here you can see that the value and the return type are both City just like in BaseClass:</source>
          <target state="translated">首先,我们可以定义一个扩展BaseClass的SubClass。这里你可以看到,值和返回类型都是City,就像BaseClass一样。</target>
        </trans-unit>
        <trans-unit id="8cfed2a3a8f7e86b967cf2cb173010c65146aff8" translate="yes" xml:space="preserve">
          <source>To stop the background process, run &lt;code&gt;flow stop&lt;/code&gt;.</source>
          <target state="translated">要停止后台进程，请运行 &lt;code&gt;flow stop&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="365cac5ca300e0e137b8e8e9c5ccad2ec1dd9628" translate="yes" xml:space="preserve">
          <source>To suppress multiple error codes on the same line, you can stack suppression comments one after another, and they will all apply to the first non-comment line like so:</source>
          <target state="translated">要在同一行上抑制多个错误代码,你可以一个接一个地堆叠抑制注释,它们将全部适用于第一个非注释行,就像这样。</target>
        </trans-unit>
        <trans-unit id="338950985d59d6b6ee99128178aad62509b70476" translate="yes" xml:space="preserve">
          <source>To type event handlers you may use the &lt;code&gt;SyntheticEvent&amp;lt;T&amp;gt;&lt;/code&gt; types like this:</source>
          <target state="translated">要键入事件处理程序，可以使用 &lt;code&gt;SyntheticEvent&amp;lt;T&amp;gt;&lt;/code&gt; 类型，如下所示：</target>
        </trans-unit>
        <trans-unit id="4fa8cc860c52b268dc6a3adcde7305e9415db5bb" translate="yes" xml:space="preserve">
          <source>Tools</source>
          <target state="translated">Tools</target>
        </trans-unit>
        <trans-unit id="624f97de4950b92b803c5cac29be65a9f2a26ac4" translate="yes" xml:space="preserve">
          <source>Triggers when a &lt;code&gt;number&lt;/code&gt; is used in a manner which may lead to unexpected results if the value is falsy. Currently, this lint triggers if a &lt;code&gt;number&lt;/code&gt; appears in:</source>
          <target state="translated">如果该值是虚假的，则在以某种方式使用 &lt;code&gt;number&lt;/code&gt; 时可能会导致意外结果时触发。当前，如果出现在以下 &lt;code&gt;number&lt;/code&gt; 则会触发此棉绒：</target>
        </trans-unit>
        <trans-unit id="8244aa53a1217dc629b3a687638e12f7a3825a89" translate="yes" xml:space="preserve">
          <source>Triggers when a dynamic type (usually &lt;code&gt;any&lt;/code&gt;) appears in a position exported from a file. Note that this is a very noisy lint, and can be triggered even when exporting types that are defined in our library definitions to include &lt;code&gt;any&lt;/code&gt; types. For this reason we recommend turning it on on a per-file or even per-line basis using &lt;a href=&quot;../flowlint-comments#toc-flowlint&quot;&gt;flowlint comments&lt;/a&gt; rather than for your whole repository in the &lt;code&gt;.flowconfig&lt;/code&gt;.</source>
          <target state="translated">当动态类型（通常触发器 &lt;code&gt;any&lt;/code&gt; ）出现在从文件中导出的位置。请注意，这是一个非常嘈杂的lint，即使在导出库定义中定义的类型以包括 &lt;code&gt;any&lt;/code&gt; 类型时也可以触发。因此，我们建议使用&lt;a href=&quot;../flowlint-comments#toc-flowlint&quot;&gt;flowlint注释，&lt;/a&gt;而不是整个 &lt;code&gt;.flowconfig&lt;/code&gt; 中的整个存储库，按文件甚至每行打开它。</target>
        </trans-unit>
        <trans-unit id="47ddc8ed6cfa00004f5b18730edf70132171135b" translate="yes" xml:space="preserve">
          <source>Triggers when you do an existence check on a value that can be either null/undefined or falsey.</source>
          <target state="translated">当你对一个可以是null/undefined或falsey的值进行存在性检查时触发。</target>
        </trans-unit>
        <trans-unit id="4ce10e302a6e69d26761a0ef32f11a1014584bb6" translate="yes" xml:space="preserve">
          <source>Triggers when you import a type from an untyped file. Importing a type from an untyped file results in an &lt;code&gt;any&lt;/code&gt; alias, which is typically not the intended behavior. Enabling this lint brings extra attention to this case and can help improve Flow coverage of typed files by limiting the spread of implicit &lt;code&gt;any&lt;/code&gt; types.</source>
          <target state="translated">从无类型文件导入类型时触发。从无类型的文件导入类型会导致 &lt;code&gt;any&lt;/code&gt; 别名，通常这不是预期的行为。启用此功能可以使这种情况引起更多关注，并且可以通过限制隐式 &lt;code&gt;any&lt;/code&gt; 类型的传播来帮助提高类型化文件的流覆盖率。</target>
        </trans-unit>
        <trans-unit id="40e312343bc5d66e00ad8f9190f3b8d256cb21f3" translate="yes" xml:space="preserve">
          <source>Triggers when you import from an untyped file. Importing from an untyped file results in those imports being typed as &lt;code&gt;any&lt;/code&gt;, which is unsafe.</source>
          <target state="translated">从无类型文件导入时触发。从无类型的文件导入会导致这些导入被键入为 &lt;code&gt;any&lt;/code&gt; ，这是不安全的。</target>
        </trans-unit>
        <trans-unit id="39095841a2d5b46ef9de672a2165376705e39be2" translate="yes" xml:space="preserve">
          <source>Triggers when you use &lt;code&gt;?.&lt;/code&gt; where it isn&amp;rsquo;t needed. This comes in two main flavors. The first is when the left-hand-side cannot be nullish:</source>
          <target state="translated">使用 &lt;code&gt;?.&lt;/code&gt; 时触发。不需要的地方。这有两种主要口味。第一种是左侧不能为零时：</target>
        </trans-unit>
        <trans-unit id="7a041463679a6c0a8cd599df21a504646bc4568e" translate="yes" xml:space="preserve">
          <source>Triggers when you use &lt;code&gt;any&lt;/code&gt;, &lt;code&gt;Object&lt;/code&gt;, or &lt;code&gt;Function&lt;/code&gt; as type annotations. These types are unsafe.</source>
          <target state="translated">在将 &lt;code&gt;any&lt;/code&gt; ， &lt;code&gt;Object&lt;/code&gt; 或 &lt;code&gt;Function&lt;/code&gt; 用作类型注释时触发。这些类型是不安全的。</target>
        </trans-unit>
        <trans-unit id="19e0b14f57c0eae8e32ecfbe46dbafa0b69613db" translate="yes" xml:space="preserve">
          <source>Triggers when you use &lt;code&gt;invariant&lt;/code&gt; to check a condition which we know must be truthy based on the available type information. This is quite conservative: for example, if all we know about the condition is that it is a &lt;code&gt;boolean&lt;/code&gt;, then the lint will not fire even if the condition must be &lt;code&gt;true&lt;/code&gt; at runtime.</source>
          <target state="translated">当您使用 &lt;code&gt;invariant&lt;/code&gt; 检查条件时触发，我们根据可用的类型信息知道该条件必须为真。这是非常保守的：例如，如果我们只知道该条件是一个 &lt;code&gt;boolean&lt;/code&gt; ，那么即使条件在运行时必须为 &lt;code&gt;true&lt;/code&gt; ，也不会触发lint 。</target>
        </trans-unit>
        <trans-unit id="88f0c0e34ae8ddb6395ee1c9617fdf1fcbad8760" translate="yes" xml:space="preserve">
          <source>Triggers when you use getters or setters. Getters and setters can have side effects and are unsafe.</source>
          <target state="translated">当你使用getters或setters时,就会触发。获取器和设置器可能有副作用,而且不安全。</target>
        </trans-unit>
        <trans-unit id="ffe944ad5706f41a9277209e96a262e3b635f27d" translate="yes" xml:space="preserve">
          <source>Triggers when you use object type syntax without explicitly specifying exactness or inexactness.</source>
          <target state="translated">当你使用对象类型语法而没有明确指定精确性或不精确性时就会触发。</target>
        </trans-unit>
        <trans-unit id="53aef4ae56fa920050fd71a2e06d45055d43a802" translate="yes" xml:space="preserve">
          <source>Triggers when you use the &lt;code&gt;$Supertype&lt;/code&gt; or &lt;code&gt;$Subtype&lt;/code&gt; utility types, as these types are unsafe and equivalent to &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">当您使用 &lt;code&gt;$Supertype&lt;/code&gt; 或 &lt;code&gt;$Subtype&lt;/code&gt; 实用程序类型时触发，因为这些类型不安全并且等效于 &lt;code&gt;any&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d53a0bb8e4d9ee63e0c2e172befa01db4dc5e57" translate="yes" xml:space="preserve">
          <source>Triggers when you use the &lt;code&gt;*&lt;/code&gt; (existential) type, as this type is unsafe and usually just equivalent to &lt;code&gt;any&lt;/code&gt;. The effect of &lt;code&gt;*&lt;/code&gt; can generally be achieved by simply not providing a type annotation.</source>
          <target state="translated">使用 &lt;code&gt;*&lt;/code&gt; （现有）类型时触发，因为该类型不安全，通常等同于 &lt;code&gt;any&lt;/code&gt; 。 &lt;code&gt;*&lt;/code&gt; 的效果通常可以通过简单地不提供类型注释来实现。</target>
        </trans-unit>
        <trans-unit id="3cddc0a96f7b4bc576c5197edc188b6a0fc13138" translate="yes" xml:space="preserve">
          <source>Trying to access an index that does not exist results in an index-out-of-bounds error.</source>
          <target state="translated">试图访问一个不存在的索引会导致index out-of-bound错误。</target>
        </trans-unit>
        <trans-unit id="cded0e3b203109683ae6b9ee54b86c57e5dee4ad" translate="yes" xml:space="preserve">
          <source>Trying to combine these two separate types into a single one will only cause us trouble.</source>
          <target state="translated">试图将这两种独立的类型合二为一,只会给我们带来麻烦。</target>
        </trans-unit>
        <trans-unit id="8f2a5e4b9220f04b1f591d617289494ede815765" translate="yes" xml:space="preserve">
          <source>Tuple Types</source>
          <target state="translated">元组类型</target>
        </trans-unit>
        <trans-unit id="61fc0a89e720d49271749ab98f1e68ad73b11567" translate="yes" xml:space="preserve">
          <source>Tuples are a sort of list but with a limited set of items. In JavaScript, tuples are created using arrays.</source>
          <target state="translated">图元组是一种列表,但有一组有限的项目。在JavaScript中,Tuple是使用数组创建的。</target>
        </trans-unit>
        <trans-unit id="73e71c95d22953ac62aab7556972e23a84de8572" translate="yes" xml:space="preserve">
          <source>Tuples don&amp;rsquo;t match array types</source>
          <target state="translated">元组与数组类型不匹配</target>
        </trans-unit>
        <trans-unit id="8228214d660934e2f3e63e0eebd31592280771e2" translate="yes" xml:space="preserve">
          <source>Tuples only match tuples with same length</source>
          <target state="translated">图元组只匹配具有相同长度的图元组</target>
        </trans-unit>
        <trans-unit id="ebd8267f01d325be2d1360510829d925406c4930" translate="yes" xml:space="preserve">
          <source>Type &amp;lsquo;Flow&amp;rsquo; to find &amp;lsquo;Flow for Sublime Text 2 and 3&amp;rsquo;</source>
          <target state="translated">键入&amp;ldquo;流&amp;rdquo;以查找&amp;ldquo;崇高文字2和3的流&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="706d45898c47974656ad0920b31f4684a46f295c" translate="yes" xml:space="preserve">
          <source>Type Alias Generics</source>
          <target state="translated">类型 别名 通用</target>
        </trans-unit>
        <trans-unit id="967c606ccee3e18535dabb6a9b4bb749abac062f" translate="yes" xml:space="preserve">
          <source>Type Alias Syntax</source>
          <target state="translated">类型 别名 语法</target>
        </trans-unit>
        <trans-unit id="353ce315d4b89d72fbf39db84d79fda4b261f3b6" translate="yes" xml:space="preserve">
          <source>Type Aliases</source>
          <target state="translated">类型别名</target>
        </trans-unit>
        <trans-unit id="22d158ab75d63715d420bc5e58daab5d8357398c" translate="yes" xml:space="preserve">
          <source>Type Annotations</source>
          <target state="translated">类型注释</target>
        </trans-unit>
        <trans-unit id="77177e460aea3473402f5aaa44a506ee91144641" translate="yes" xml:space="preserve">
          <source>Type Assertions</source>
          <target state="translated">类型断言</target>
        </trans-unit>
        <trans-unit id="679d10a7debbdc2089b71c9b81e4e219e305c114" translate="yes" xml:space="preserve">
          <source>Type Cast Expression Syntax</source>
          <target state="translated">类型 铸造表达式 语法</target>
        </trans-unit>
        <trans-unit id="7f7ae61fc4d52305e688b8380ee480f65e186212" translate="yes" xml:space="preserve">
          <source>Type Casting</source>
          <target state="translated">类型铸造</target>
        </trans-unit>
        <trans-unit id="622cca8db4f4ef9c127d2e4b8f7ee4a1c6c56924" translate="yes" xml:space="preserve">
          <source>Type Casting Expressions</source>
          <target state="translated">类型铸造表达式</target>
        </trans-unit>
        <trans-unit id="242837be86dac228098509d8b1d22d367cdf4559" translate="yes" xml:space="preserve">
          <source>Type Casting through any</source>
          <target state="translated">通过任何方式进行类型铸造</target>
        </trans-unit>
        <trans-unit id="5ad392a89ee608a47c6212c75337d50433a48220" translate="yes" xml:space="preserve">
          <source>Type Reference</source>
          <target state="translated">类型参考</target>
        </trans-unit>
        <trans-unit id="ce57a9b5c9b93e38d173ed05c80dc328e2cdfdfc" translate="yes" xml:space="preserve">
          <source>Type Refinements</source>
          <target state="translated">类型改进</target>
        </trans-unit>
        <trans-unit id="7433446286e8e2d16c8a5d667b180309a3d0c3b1" translate="yes" xml:space="preserve">
          <source>Type System</source>
          <target state="translated">类型系统</target>
        </trans-unit>
        <trans-unit id="472d5c5df27f757dd28ba1d382ee583d4a9c6081" translate="yes" xml:space="preserve">
          <source>Type Variance</source>
          <target state="translated">类型差异</target>
        </trans-unit>
        <trans-unit id="7081fc7a1f2c1115eff37592f8d91d2655e0035b" translate="yes" xml:space="preserve">
          <source>Type alias generics are &lt;a href=&quot;../generics#toc-parameterized-generics&quot;&gt;parameterized&lt;/a&gt;. When you use a type alias you need to pass parameters for each of its generics.</source>
          <target state="translated">类型别名泛型已&lt;a href=&quot;../generics#toc-parameterized-generics&quot;&gt;参数化&lt;/a&gt;。使用类型别名时，需要为其每个泛型传递参数。</target>
        </trans-unit>
        <trans-unit id="ed6584609a640d5af10378fda6649aaa9963a745" translate="yes" xml:space="preserve">
          <source>Type aliases are created using the keyword &lt;code&gt;type&lt;/code&gt; followed by its name, an equals sign &lt;code&gt;=&lt;/code&gt;, and a type definition.</source>
          <target state="translated">类型别名是使用关键字 &lt;code&gt;type&lt;/code&gt; ，其名称，等号 &lt;code&gt;=&lt;/code&gt; 和类型定义创建的。</target>
        </trans-unit>
        <trans-unit id="f5e43ef93cfc8bf99af97c7220813d7732015c36" translate="yes" xml:space="preserve">
          <source>Type aliases can also have their own &lt;a href=&quot;../generics&quot;&gt;generics&lt;/a&gt;.</source>
          <target state="translated">类型别名也可以具有自己的&lt;a href=&quot;../generics&quot;&gt;泛型&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="094f893f7105ba5dce34064ff2a962e9a5dea0a2" translate="yes" xml:space="preserve">
          <source>Type aliases with generics</source>
          <target state="translated">带有属名的类型别名</target>
        </trans-unit>
        <trans-unit id="856da198c41cb55e6e7b7e17d220f7f074929070" translate="yes" xml:space="preserve">
          <source>Type cast expressions can appear anywhere an expression can appear.</source>
          <target state="translated">类型转换表达式可以出现在表达式可以出现的任何地方。</target>
        </trans-unit>
        <trans-unit id="52a7383784e25f833d11d59af803f7d6f5fb1c80" translate="yes" xml:space="preserve">
          <source>Type checking through type assertions</source>
          <target state="translated">通过类型断言进行类型检查</target>
        </trans-unit>
        <trans-unit id="b0b25b95faf957cfa80952cbe05fe4b40c3ff732" translate="yes" xml:space="preserve">
          <source>Typeof Types</source>
          <target state="translated">类型的类型</target>
        </trans-unit>
        <trans-unit id="e96900534c313f15c2044eb007fe55d438980bfc" translate="yes" xml:space="preserve">
          <source>Types &amp;amp; Expressions</source>
          <target state="translated">类型和表达式</target>
        </trans-unit>
        <trans-unit id="c71bc629994455a4ae2c2c56b3468d4335892413" translate="yes" xml:space="preserve">
          <source>Types for literal values are lowercase.</source>
          <target state="translated">字面值的类型为小写。</target>
        </trans-unit>
        <trans-unit id="580c5ee4989e8d41e98c7cbde35a3b6779ea36bd" translate="yes" xml:space="preserve">
          <source>Types for the wrapper objects are capitalized (the same as their constructor).</source>
          <target state="translated">包装器对象的类型是大写的(和它们的构造函数一样)。</target>
        </trans-unit>
        <trans-unit id="261798fb195afa2ef742905bdf96b253f84a80b5" translate="yes" xml:space="preserve">
          <source>Types-First</source>
          <target state="translated">Types-First</target>
        </trans-unit>
        <trans-unit id="b7462bb0d3927c58dff4b373159f208396dac87e" translate="yes" xml:space="preserve">
          <source>Types-first mode is officially released with version 0.125, but has been available in &lt;em&gt;experimental&lt;/em&gt; status as of version 0.102. If you are currently on an older Flow version, you&amp;rsquo;d have to first upgrade Flow. Using the latest Flow version is the best way to benefit from the performance benefits outlined above.</source>
          <target state="translated">类型优先模式已在0.125版中正式发布，但从0.102版开始处于&lt;em&gt;实验&lt;/em&gt;状态。如果您当前使用的是较旧的Flow版本，则必须先升级Flow。使用最新的Flow版本是从上述性能优势中受益的最佳方法。</target>
        </trans-unit>
        <trans-unit id="ed2e12e68cfc75ec2c60ea3b9e8b6d3511b2f122" translate="yes" xml:space="preserve">
          <source>Types-first requires annotations at module boundaries in order to build type signature for files. If these annotations are missing, then a &lt;code&gt;signature-verification-failure&lt;/code&gt; is raised, and the exported type for the respective part of the code will be &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">&amp;ldquo;类型优先&amp;rdquo;要求在模块边界添加批注，以便为文件建立类型签名。如果缺少这些注释，则会引发 &lt;code&gt;signature-verification-failure&lt;/code&gt; ，并且代码各部分的导出类型将为 &lt;code&gt;any&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b4e1425babb83699dcc06797b8fc4bf14a2ecce" translate="yes" xml:space="preserve">
          <source>Typing Redux action creators</source>
          <target state="translated">打字Redux动作创作者</target>
        </trans-unit>
        <trans-unit id="5dfff1352be5ea6c7148bf3b4ca1615b03fabc81" translate="yes" xml:space="preserve">
          <source>Typing Redux actions</source>
          <target state="translated">打字重修行动</target>
        </trans-unit>
        <trans-unit id="6ac33fe488507408b1948fb67be46790295ab295" translate="yes" xml:space="preserve">
          <source>Typing Redux reducers</source>
          <target state="translated">输入Redux减速器</target>
        </trans-unit>
        <trans-unit id="1133cd18fcd897fc2f5bb525485b9229e6071672" translate="yes" xml:space="preserve">
          <source>Typing Redux state</source>
          <target state="translated">打字重修状态</target>
        </trans-unit>
        <trans-unit id="0640a2bc7ae817374f47547199fbe5f3a1a3b619" translate="yes" xml:space="preserve">
          <source>Typing Redux state immutability</source>
          <target state="translated">键入Redux状态不变性</target>
        </trans-unit>
        <trans-unit id="5122ba530622fd5f4a0332eb09fb6325c4305df1" translate="yes" xml:space="preserve">
          <source>Typing Redux thunk actions</source>
          <target state="translated">Typing Redux thunk actions</target>
        </trans-unit>
        <trans-unit id="8f00b09a4880f70aa5139aa250a7d8b335930e96" translate="yes" xml:space="preserve">
          <source>Typing function children or other exotic children types.</source>
          <target state="translated">打字功能儿或其他外来儿类型。</target>
        </trans-unit>
        <trans-unit id="ee1f5ee4decdbb0b21342950c2b6f1f39fa45f3a" translate="yes" xml:space="preserve">
          <source>Typing your &lt;a href=&quot;http://redux.js.org/docs/introduction/ThreePrinciples.html#single-source-of-truth&quot;&gt;state&lt;/a&gt; object, works the same as typing any other object in Flow.</source>
          <target state="translated">键入&lt;a href=&quot;http://redux.js.org/docs/introduction/ThreePrinciples.html#single-source-of-truth&quot;&gt;状态&lt;/a&gt;对象与在Flow中键入任何其他对象的作用相同。</target>
        </trans-unit>
        <trans-unit id="eaeff57d46868fd923495803e50c88004276ec83" translate="yes" xml:space="preserve">
          <source>Typings HOCs can be complicated. While you can follow the &lt;a href=&quot;react/hoc&quot;&gt;docs about it&lt;/a&gt;, sometimes it can be easier to type the returned component.</source>
          <target state="translated">键入HOC可能很复杂。尽管您可以关注&lt;a href=&quot;react/hoc&quot;&gt;有关它&lt;/a&gt;的文档，但有时键入返回的组件会更容易。</target>
        </trans-unit>
        <trans-unit id="28e0451237256965294e54fd3ed734d927e133c0" translate="yes" xml:space="preserve">
          <source>Under the hood, Flow relies on a high-throughput low-latency systems infrastructure that enables distribution of tasks among parallel workers, and communication of results in parallel via shared memory. Combined with an architecture where the analysis of a codebase is updated automatically in the background on file system changes, Flow delivers near-instantaneous feedback as the developer edits and rebases code, even in a large repository.</source>
          <target state="translated">Flow依靠高吞吐量、低延迟的系统基础架构,实现了在并行工作者之间分配任务,并通过共享内存进行并行的结果通信。结合一个架构,在文件系统发生变化时,代码库的分析结果会在后台自动更新,因此,即使是在一个大型资源库中,Flow也能在开发人员编辑和重新编写代码时提供近乎即时的反馈。</target>
        </trans-unit>
        <trans-unit id="667d6f69fc6e6557c1fd07a997502ffbb6fea4b6" translate="yes" xml:space="preserve">
          <source>Understanding the logic behind generics might be useful, but what you really need to know to make your typings valid is that you need to help Flow to understand the type of &lt;code&gt;genericArray&lt;/code&gt;.</source>
          <target state="translated">理解泛型背后的逻辑可能会很有用，但是您真正需要知道的才能使您的键入有效的是，您需要帮助Flow理解 &lt;code&gt;genericArray&lt;/code&gt; 的类型。</target>
        </trans-unit>
        <trans-unit id="19b606b9d09ef359154b3796d3b6d1ef4472ad09" translate="yes" xml:space="preserve">
          <source>Unfortunately, it is not possible to enable types-first mode for part of your repo; this switch affects all files managed by the current &lt;code&gt;.flowconfig&lt;/code&gt;.</source>
          <target state="translated">不幸的是，不可能为您的部分仓库启用类型优先模式。此开关将影响当前 &lt;code&gt;.flowconfig&lt;/code&gt; 管理的所有文件。</target>
        </trans-unit>
        <trans-unit id="468ccd5bcf72e4958742b43ae3e09374a05c2b83" translate="yes" xml:space="preserve">
          <source>Union Types</source>
          <target state="translated">联盟类型</target>
        </trans-unit>
        <trans-unit id="5997dfe0e231fc3d5039a0ce77e27fc997c50e93" translate="yes" xml:space="preserve">
          <source>Union type syntax</source>
          <target state="translated">联合型语法</target>
        </trans-unit>
        <trans-unit id="5772a5be68b2acc1748e16bd31117c9dcf779b80" translate="yes" xml:space="preserve">
          <source>Union types are any number of types which are joined by a vertical bar &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">联合类型是由竖线 &lt;code&gt;|&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4fcae8ac4735463f8391bdf76cd83a6272aa90b" translate="yes" xml:space="preserve">
          <source>Union types requires one in, but all out</source>
          <target state="translated">联盟类型要求一进一出</target>
        </trans-unit>
        <trans-unit id="40ebabc3d3f621503bd72ccc4402a11bbf25a8ef" translate="yes" xml:space="preserve">
          <source>Unions &amp;amp; Refinements</source>
          <target state="translated">联合与提炼</target>
        </trans-unit>
        <trans-unit id="38ed70ea0b1d89e63badbd5bea1ce73346a2e36d" translate="yes" xml:space="preserve">
          <source>Unknown property lookup on unsealed objects is unsafe</source>
          <target state="translated">在未密封对象上进行未知属性查询是不安全的。</target>
        </trans-unit>
        <trans-unit id="703d1ae54d78dc2791b520eb4ed986a6d9a34e11" translate="yes" xml:space="preserve">
          <source>Unless the objects somehow conflict with one another there is no way to distinguish them.</source>
          <target state="translated">除非对象之间有某种冲突,否则就无法区分它们。</target>
        </trans-unit>
        <trans-unit id="ef3248cdccf6c3a032dec37be3fbfe52ccc8052c" translate="yes" xml:space="preserve">
          <source>Unlike many other languages, JavaScript only has one type of number. These values may appear as &lt;code&gt;42&lt;/code&gt; or &lt;code&gt;3.14&lt;/code&gt;. JavaScript also considers &lt;code&gt;Infinity&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; to be numbers. The &lt;code&gt;number&lt;/code&gt; type captures everything JavaScript considers a number.</source>
          <target state="translated">与许多其他语言不同，JavaScript仅具有一种类型的数字。这些值可能显示为 &lt;code&gt;42&lt;/code&gt; 或 &lt;code&gt;3.14&lt;/code&gt; 。JavaScript还认为 &lt;code&gt;Infinity&lt;/code&gt; 和 &lt;code&gt;NaN&lt;/code&gt; 是数字。该 &lt;code&gt;number&lt;/code&gt; 型捕捉一切的JavaScript会考虑很多。</target>
        </trans-unit>
        <trans-unit id="3af13bbea775e8595b01bcfbe26e08a735507b74" translate="yes" xml:space="preserve">
          <source>Unlike regular object types, it is not valid to pass an object with &amp;ldquo;extra&amp;rdquo; properties to an exact object type.</source>
          <target state="translated">与常规对象类型不同，将具有&amp;ldquo;额外&amp;rdquo;属性的对象传递给确切的对象类型是无效的。</target>
        </trans-unit>
        <trans-unit id="07ef2b2dcd96f0dd48fe2da326d94f53363ed4ce" translate="yes" xml:space="preserve">
          <source>Unsealed objects</source>
          <target state="translated">未密封的物体</target>
        </trans-unit>
        <trans-unit id="25c6b6f53e08c0606a31166d8b9a877dcfc420f6" translate="yes" xml:space="preserve">
          <source>Unsealed objects allow new properties to be written at any time. Flow ensures that reads are compatible with writes, but does not ensure that writes happen before reads (in the order of execution).</source>
          <target state="translated">未密封的对象允许在任何时候写入新的属性。流程确保读与写兼容,但不确保写发生在读之前(执行顺序)。</target>
        </trans-unit>
        <trans-unit id="0d33c5b31a20c87d8bda6835c104266836b20ac8" translate="yes" xml:space="preserve">
          <source>Upgrade Flow version</source>
          <target state="translated">升级流程版本</target>
        </trans-unit>
        <trans-unit id="b1c17d9e11ded3c8ebada61242238b401f935c20" translate="yes" xml:space="preserve">
          <source>Upgrading to &lt;a href=&quot;https://flow.org/en/lang/types-first&quot;&gt;Types-First&lt;/a&gt; mode may require a substantial number of type annotations at module boundaries. To help with the process of upgrading large codebases, we are providing a codemod command, whose goal is to fill in these missing annotations. This command is included in the Flow binary in versions &lt;code&gt;&amp;gt;= 0.125&lt;/code&gt;.</source>
          <target state="translated">升级到&lt;a href=&quot;https://flow.org/en/lang/types-first&quot;&gt;Types-First&lt;/a&gt;模式可能需要在模块边界添加大量类型注释。为了帮助升级大型代码库，我们提供了一个codemod命令，其目的是填补这些缺失的注释。该命令包含在Flow二进制文件中，版本 &lt;code&gt;&amp;gt;= 0.125&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="a37aa700a25d2f5c26f5844b90cdc3158398c792" translate="yes" xml:space="preserve">
          <source>Used in conjuction with &lt;a href=&quot;https://flow.org/en/strict/&quot;&gt;Flow Strict&lt;/a&gt;. Triggers when importing a non &lt;code&gt;@flow strict&lt;/code&gt; module. When enabled, dependencies of a &lt;code&gt;@flow strict&lt;/code&gt; module must also be &lt;code&gt;@flow strict&lt;/code&gt;.</source>
          <target state="translated">与&lt;a href=&quot;https://flow.org/en/strict/&quot;&gt;流动严格&lt;/a&gt;结合使用。导入非 &lt;code&gt;@flow strict&lt;/code&gt; 模块时触发。启用后， &lt;code&gt;@flow strict&lt;/code&gt; 模块的依赖项也必须是 &lt;code&gt;@flow strict&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="37435b49f34aed7ea4a10106bbcc3330cbcab593" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;React.Node&lt;/code&gt; but without some primitive types like strings.</source>
          <target state="translated">使用 &lt;code&gt;React.Node&lt;/code&gt; 但没有一些原始类型，例如字符串。</target>
        </trans-unit>
        <trans-unit id="a55e66a75946c4c072cc420e4c3ed94f6780a7c2" translate="yes" xml:space="preserve">
          <source>Using Default Props</source>
          <target state="translated">使用默认道具</target>
        </trans-unit>
        <trans-unit id="08b120d1bbe1cac9b101fd75ecc8814d5b08ec58" translate="yes" xml:space="preserve">
          <source>Using Default Props for Functional Components</source>
          <target state="translated">为功能组件使用默认道具</target>
        </trans-unit>
        <trans-unit id="3c58620d569e6a2825f19e911cd8c7f8b356ab31" translate="yes" xml:space="preserve">
          <source>Using Filesystem Lazy Mode</source>
          <target state="translated">使用文件系统懒惰模式</target>
        </trans-unit>
        <trans-unit id="0eca84f8818d70549fd226298ab6a5af63ae5ddc" translate="yes" xml:space="preserve">
          <source>Using Flow you can use Maybe types for these values. Maybe types work with any other type by simply prefixing it with a question mark &lt;code&gt;?&lt;/code&gt; such as &lt;code&gt;?number&lt;/code&gt; as a sort of modifier.</source>
          <target state="translated">使用Flow可以将Maybe类型用于这些值。也许类型通过在其前面加上问号来与其他类型一起使用 &lt;code&gt;?&lt;/code&gt; 例如 &lt;code&gt;?number&lt;/code&gt; 作为修饰符。</target>
        </trans-unit>
        <trans-unit id="ba7902faac97670dd0cee466cfc7b1872b6191c6" translate="yes" xml:space="preserve">
          <source>Using IDE Lazy Mode</source>
          <target state="translated">使用IDE懒人模式</target>
        </trans-unit>
        <trans-unit id="dcb8b5c22a81a676bc4f6e0097672681d67ad964" translate="yes" xml:space="preserve">
          <source>Using Watchman Lazy Mode</source>
          <target state="translated">使用Watchman懒人模式</target>
        </trans-unit>
        <trans-unit id="4acbbdc6b766f0f60a0b004c91a169d2b83a940e" translate="yes" xml:space="preserve">
          <source>Using disjoint unions, Flow will be able to understand your reducers much better.</source>
          <target state="translated">使用不相干的联合,Flow将能够更好地理解您的减速器。</target>
        </trans-unit>
        <trans-unit id="e6ba24474eb6d1b00633e337c8dace730b98eb30" translate="yes" xml:space="preserve">
          <source>Using exact object types lets Flow know that no extra properties will exist at runtime, which allows &lt;a href=&quot;../refinements&quot;&gt;refinements&lt;/a&gt; to get more specific.</source>
          <target state="translated">使用精确的对象类型可以使Flow知道在运行时将不存在额外的属性，从而可以使&lt;a href=&quot;../refinements&quot;&gt;优化&lt;/a&gt;变得更加具体。</target>
        </trans-unit>
        <trans-unit id="10ade4f79788cce4dea297a9d609f90e95de4261" translate="yes" xml:space="preserve">
          <source>Using inference, these types are often optional:</source>
          <target state="translated">使用推理,这些类型通常是可选的。</target>
        </trans-unit>
        <trans-unit id="638d500275968b8c62e284497de3a8262dc86007" translate="yes" xml:space="preserve">
          <source>Using intersection types, it is possible to create types which are impossible to create at runtime. Intersection types will allow you to combine any set of types, even ones that conflict with one another.</source>
          <target state="translated">使用交集类型,可以创建在运行时无法创建的类型。交集类型将允许您组合任何类型集,甚至是那些相互冲突的类型。</target>
        </trans-unit>
        <trans-unit id="b8ada9fc6bb8dffff0336dfb6dc98c7dc0b143de" translate="yes" xml:space="preserve">
          <source>Using the above definition we can declare a function &lt;code&gt;fn&lt;/code&gt; that has the following behavior:</source>
          <target state="translated">使用上面的定义，我们可以声明一个具有以下行为的函数 &lt;code&gt;fn&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="86509a1d00de10c9136938cbdfb1d9850e246f6e" translate="yes" xml:space="preserve">
          <source>Using the command &lt;code&gt;flow&lt;/code&gt; will type-check your current directory if the &lt;code&gt;.flowconfig&lt;/code&gt; file is present. A flow server will automatically be started if needed.</source>
          <target state="translated">如果存在 &lt;code&gt;.flowconfig&lt;/code&gt; 文件，则使用命令 &lt;code&gt;flow&lt;/code&gt; 将对您的当前目录进行类型检查。如果需要，流服务器将自动启动。</target>
        </trans-unit>
        <trans-unit id="b4fce26a90d1ee7b21142442ea9f330e4afede8c" translate="yes" xml:space="preserve">
          <source>Using these with &lt;a href=&quot;../unions&quot;&gt;union types&lt;/a&gt; is powerful:</source>
          <target state="translated">将它们与&lt;a href=&quot;../unions&quot;&gt;联合类型&lt;/a&gt;一起使用是强大的：</target>
        </trans-unit>
        <trans-unit id="58f37430c61b5ea396ac215dd6bf35547ff8b510" translate="yes" xml:space="preserve">
          <source>Using type cast expressions</source>
          <target state="translated">使用类型转换表达式</target>
        </trans-unit>
        <trans-unit id="4e74c3c3dbc90177ee7906987795cb4e37db9635" translate="yes" xml:space="preserve">
          <source>Using type cast expressions you can assert that values are certain types.</source>
          <target state="translated">使用类型转换表达式,你可以断言值是某些类型。</target>
        </trans-unit>
        <trans-unit id="aba045b792a727f53d493f5cc2d4bbe68e26bbc6" translate="yes" xml:space="preserve">
          <source>Utility Types</source>
          <target state="translated">公用事业类型</target>
        </trans-unit>
        <trans-unit id="d981987c61afbbc64d7655e2b4cdb6bf5b85cbce" translate="yes" xml:space="preserve">
          <source>Variable Types</source>
          <target state="translated">可变类型</target>
        </trans-unit>
        <trans-unit id="3c555fe12c9dd11facd9128e236d5c42157a806e" translate="yes" xml:space="preserve">
          <source>Variance Sigils</source>
          <target state="translated">差异符号</target>
        </trans-unit>
        <trans-unit id="12e8ee8b0b460ae1489f8fa70aa448077ad5be60" translate="yes" xml:space="preserve">
          <source>Variance in Classes</source>
          <target state="translated">各级别差异</target>
        </trans-unit>
        <trans-unit id="661548cc8ae30e106f079ae71da4e22fdee3f0a3" translate="yes" xml:space="preserve">
          <source>Variance is a topic that comes up fairly often in type systems and can be a bit confusing the first time you hear it. Let&amp;rsquo;s walk through each form of variance.</source>
          <target state="translated">差异是类型系统中经常出现的一个话题，当您第一次听到它时可能会感到困惑。让我们来看一下每种形式的方差。</target>
        </trans-unit>
        <trans-unit id="4f27c48fa3564f7410e0121a7646d154ac051a32" translate="yes" xml:space="preserve">
          <source>Variance sigils allow you to be more specific about how you intend to use your generics, giving Flow the power to do more precise type checking. For example, you may want this relationship to hold:</source>
          <target state="translated">差异标志允许你更具体地说明你打算如何使用你的属相,使Flow有能力进行更精确的类型检查。例如,你可能希望这种关系能够保持。</target>
        </trans-unit>
        <trans-unit id="a78ad277616170813560c5fab7aabae8ac9cfb23" translate="yes" xml:space="preserve">
          <source>Vim</source>
          <target state="translated">Vim</target>
        </trans-unit>
        <trans-unit id="afbd00670e2a500077ed926aedfb070c71244c15" translate="yes" xml:space="preserve">
          <source>VimPlug</source>
          <target state="translated">VimPlug</target>
        </trans-unit>
        <trans-unit id="423f1f3d80c4d824ca917e13649a5c584a13ec87" translate="yes" xml:space="preserve">
          <source>Visual Studio Code</source>
          <target state="translated">Visual Studio代码</target>
        </trans-unit>
        <trans-unit id="3b8fd17bcb03bb77eb2cbfe9f38369745aa51b8d" translate="yes" xml:space="preserve">
          <source>Warning: That this is a &lt;em&gt;substring&lt;/em&gt; check, not a regular expression (for performance reasons).</source>
          <target state="translated">警告：这是&lt;em&gt;子字符串&lt;/em&gt;检查，不是正则表达式（出于性能原因）。</target>
        </trans-unit>
        <trans-unit id="b8fd2f3a8255adad646ca5327eba0b8786744dbe" translate="yes" xml:space="preserve">
          <source>Warnings aren&amp;rsquo;t shown on the CLI by default, to avoid spew. CLI warnings can be enabled by passing the &amp;ndash;include-warnings flag to the Flow server or the Flow client, or by setting &amp;ldquo;include_warnings=true&amp;rdquo; in the &lt;code&gt;.flowconfig&lt;/code&gt;. This is good for smaller projects that want to see all project warnings at once.</source>
          <target state="translated">默认情况下，不会在CLI上显示警告，以免产生警告。通过将&amp;ndash;include-warnings标志传递给Flow服务器或Flow客户端，或在 &lt;code&gt;.flowconfig&lt;/code&gt; 中设置&amp;ldquo; include_warnings = true&amp;rdquo;，可以启用CLI警告。这对于希望立即查看所有项目警告的较小项目非常有用。</target>
        </trans-unit>
        <trans-unit id="fe8d40071f5a559a669afec325304551bb16aba4" translate="yes" xml:space="preserve">
          <source>Warnings don&amp;rsquo;t affect the exit code of Flow. If Flow finds warnings but no errors, it still returns 0.</source>
          <target state="translated">警告不会影响Flow的退出代码。如果Flow发现警告但没有错误，则仍返回0。</target>
        </trans-unit>
        <trans-unit id="81f9219fd8a874b03e97d8fac13dedd6210a919b" translate="yes" xml:space="preserve">
          <source>Warnings have special &lt;a href=&quot;ide-integration&quot;&gt;IDE Integration&lt;/a&gt;.</source>
          <target state="translated">警告具有特殊的&lt;a href=&quot;ide-integration&quot;&gt;IDE集成&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bb2debe559facf651a601f9c7527b8296d8b9624" translate="yes" xml:space="preserve">
          <source>Watchman lazy mode has a few additional requirements.</source>
          <target state="translated">守望者懒人模式有一些额外的要求。</target>
        </trans-unit>
        <trans-unit id="78080fc13eb28909de716d744a8a47810b22cd61" translate="yes" xml:space="preserve">
          <source>We also need &lt;code&gt;typeof&lt;/code&gt; for &lt;code&gt;Bar&lt;/code&gt; because &lt;code&gt;Bar&lt;/code&gt; is a value. So we want to get the type &lt;em&gt;of&lt;/em&gt; the value &lt;code&gt;Bar&lt;/code&gt;. &lt;code&gt;(Bar: Bar)&lt;/code&gt; is an error because &lt;code&gt;Bar&lt;/code&gt; cannot be used as a type, so the following is correct: &lt;code&gt;(Bar: typeof Bar)&lt;/code&gt;.</source>
          <target state="translated">我们还需要 &lt;code&gt;Bar&lt;/code&gt; 的 &lt;code&gt;typeof&lt;/code&gt; ，因为 &lt;code&gt;Bar&lt;/code&gt; 是一个值。因此，我们想要得到的类型&lt;em&gt;的&lt;/em&gt;值 &lt;code&gt;Bar&lt;/code&gt; 。 &lt;code&gt;(Bar: Bar)&lt;/code&gt; 是一个错误，因为 &lt;code&gt;Bar&lt;/code&gt; 不能用作类型，因此以下是正确的： &lt;code&gt;(Bar: typeof Bar)&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="565a855b54dc5d4e5feb1c24229c3c37a0aa82ca" translate="yes" xml:space="preserve">
          <source>We can try to express both of these objects in a single object type. However, we&amp;rsquo;ll quickly run into issues where we know a property exists based on the success property but Flow does not.</source>
          <target state="translated">我们可以尝试用单个对象类型来表达这两个对象。但是，我们很快就会遇到一些问题，在这些问题中，我们知道基于成功属性存在一个属性，但Flow不存在。</target>
        </trans-unit>
        <trans-unit id="fb681ad5a4120e328dc7b7df6b9ecb5757df66ef" translate="yes" xml:space="preserve">
          <source>We can use this type alias to make sure reducers work correctly.</source>
          <target state="translated">我们可以使用这个类型别名来确保减速器正确工作。</target>
        </trans-unit>
        <trans-unit id="0eb5411b6ed2d064b0d0e833606639f58a6b2b5f" translate="yes" xml:space="preserve">
          <source>We get this error message because &lt;code&gt;React.AbstractComponent&amp;lt;Config&amp;gt;&lt;/code&gt; doesn&amp;rsquo;t set the &lt;code&gt;Instance&lt;/code&gt; type parameter, so it is automatically set to &lt;code&gt;mixed&lt;/code&gt;. If we wanted to preserve the instance type of the component, we can use &lt;a href=&quot;https://reactjs.org/docs/forwarding-refs.html&quot;&gt;&lt;code&gt;React.forwardRef&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">我们收到此错误消息是因为 &lt;code&gt;React.AbstractComponent&amp;lt;Config&amp;gt;&lt;/code&gt; 没有设置 &lt;code&gt;Instance&lt;/code&gt; type参数，因此它会自动设置为 &lt;code&gt;mixed&lt;/code&gt; 。如果我们想保留组件的实例类型，可以使用&lt;a href=&quot;https://reactjs.org/docs/forwarding-refs.html&quot;&gt; &lt;code&gt;React.forwardRef&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="14c408c67aca29a7fa863fd2f5d381f5c8273e88" translate="yes" xml:space="preserve">
          <source>We recommend you enable all your desired rules from the beginning, then adopt Flow Strict file-by-file. This works better than enabling a single rule, adding &lt;code&gt;@flow strict&lt;/code&gt; to many files, and then adding more rules to the config.</source>
          <target state="translated">我们建议您从一开始就启用所有所需的规则，然后逐个文件采用Flow Strict。这比启用单个规则，将 &lt;code&gt;@flow strict&lt;/code&gt; 添加到许多文件然后向配置中添加更多规则要好。</target>
        </trans-unit>
        <trans-unit id="34abdcf44b0093985cf9e1d46481109cab9f85f9" translate="yes" xml:space="preserve">
          <source>We removed our dependency on &lt;code&gt;prop-types&lt;/code&gt; and added a Flow object type named &lt;code&gt;Props&lt;/code&gt; with the same shape as the prop types but using Flow&amp;rsquo;s static type syntax. Then we passed our new &lt;code&gt;Props&lt;/code&gt; type into &lt;code&gt;React.Component&lt;/code&gt; as a type argument.</source>
          <target state="translated">我们删除了对 &lt;code&gt;prop-types&lt;/code&gt; 的依赖，并添加了一个名为 &lt;code&gt;Props&lt;/code&gt; 的Flow对象类型，其形状与prop类型相同，但是使用了Flow的静态类型语法。然后，我们将新的 &lt;code&gt;Props&lt;/code&gt; 类型作为类型参数传递给 &lt;code&gt;React.Component&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fdbcb95f6a23f42e50318e1968770b634c1e41d0" translate="yes" xml:space="preserve">
          <source>We set the type of props to &lt;code&gt;React.ChildrenArray&amp;lt;React.Element&amp;lt;typeof TabBarIOSItem&amp;gt;&amp;gt;&lt;/code&gt; which will guarantee that &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; must only have children that are &lt;code&gt;TabBarIOS.Item&lt;/code&gt; React elements.</source>
          <target state="translated">我们将道具的类型设置为 &lt;code&gt;React.ChildrenArray&amp;lt;React.Element&amp;lt;typeof TabBarIOSItem&amp;gt;&amp;gt;&lt;/code&gt; ，这将确保 &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; 必须仅具有属于 &lt;code&gt;TabBarIOS.Item&lt;/code&gt; React元素的子代。</target>
        </trans-unit>
        <trans-unit id="91fdfa76ed94bd3897d04cec5f4134f4e7bc035e" translate="yes" xml:space="preserve">
          <source>We will refer to all the types in the following reference as if we imported them with:</source>
          <target state="translated">我们将在下面的引用中引用所有类型,就像我们用以下方式导入它们一样。</target>
        </trans-unit>
        <trans-unit id="d0deed72cfe69559a9e7c7724e402ecb7a9ed446" translate="yes" xml:space="preserve">
          <source>We would have a lot of trouble trying to write specific types for this function since it could be anything.</source>
          <target state="translated">我们想为这个函数写具体的类型会有很多麻烦,因为它可以是任何东西。</target>
        </trans-unit>
        <trans-unit id="54c34be58b1366378d47ad4ba8a861a9a07fe8d5" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll quickly set up our &lt;code&gt;BaseClass&lt;/code&gt; which will define just one method that accepts an input value with the type &lt;code&gt;City&lt;/code&gt; and an returned output also with the type &lt;code&gt;City&lt;/code&gt;.</source>
          <target state="translated">我们将很快成立了我们 &lt;code&gt;BaseClass&lt;/code&gt; 将定义只有一个，接受与该类型的输入值法 &lt;code&gt;City&lt;/code&gt; 和返回的输出也与型 &lt;code&gt;City&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f20c7e2164e3a5acb3717c0236d43d3267a9c8ed" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll use these classes to write a method that has each kind of variance.</source>
          <target state="translated">我们将使用这些类来编写具有各种差异的方法。</target>
        </trans-unit>
        <trans-unit id="04c0bd1c623d23997ff99f3caa7042e13039a782" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve demonstrated both nominal and structure typing of classes, but there are also other complex types like objects and functions which can also be either nominal or structural. Even further, they can be different within the same type system (most of the languages listed before has features of both).</source>
          <target state="translated">我们已经演示了标称类型和结构类型的类，但是还有其他复杂类型，例如对象和函数也可以是标称类型或结构类型。更进一步，它们在同一类型系统中可能会有所不同（前面列出的大多数语言都具有两者的功能）。</target>
        </trans-unit>
        <trans-unit id="c5b6d6d89517eff4ce180cea4ab387ae48e094cb" translate="yes" xml:space="preserve">
          <source>WebStorm</source>
          <target state="translated">WebStorm</target>
        </trans-unit>
        <trans-unit id="d40a79cfe25e4cc102f0a57e8b44e1c01d37bcbb" translate="yes" xml:space="preserve">
          <source>WebStorm 2016.3</source>
          <target state="translated">WebStorm 2016.3</target>
        </trans-unit>
        <trans-unit id="6c3e64366f1d6fbef0a5c75ba4449cc79038d05d" translate="yes" xml:space="preserve">
          <source>WebStorm 2017.1</source>
          <target state="translated">WebStorm 2017.1</target>
        </trans-unit>
        <trans-unit id="8f14c5dae174ee34d208589e220dbdb169f943d4" translate="yes" xml:space="preserve">
          <source>Webstorm installation instructions can be found here:</source>
          <target state="translated">Webstorm安装说明可以在这里找到。</target>
        </trans-unit>
        <trans-unit id="44f3ba4fbbef59c08df191dcbed16fa19c8defe9" translate="yes" xml:space="preserve">
          <source>What do you think will happen?</source>
          <target state="translated">你认为会发生什么?</target>
        </trans-unit>
        <trans-unit id="4b5eba71e139ed73ff2a0e9b6ced493bb2e4087c" translate="yes" xml:space="preserve">
          <source>What happens when you have a single child?</source>
          <target state="translated">有了独生子女会怎样?</target>
        </trans-unit>
        <trans-unit id="6966f9bf72c264264a3efaf8dc5ecfa61beb1bb2" translate="yes" xml:space="preserve">
          <source>What happens when you have multiple children?</source>
          <target state="translated">如果你有多个孩子会怎么样?</target>
        </trans-unit>
        <trans-unit id="f268d50869e2db0c0130a3ca7a85cf1506065d2f" translate="yes" xml:space="preserve">
          <source>What is a Suppression?</source>
          <target state="translated">什么是压制?</target>
        </trans-unit>
        <trans-unit id="12b550ae1d285f33798a42afbb386fd6afdc67f5" translate="yes" xml:space="preserve">
          <source>What is a subtype?</source>
          <target state="translated">什么是子类型?</target>
        </trans-unit>
        <trans-unit id="ac4ecfb3127c03f684e91c1f130988581c874a06" translate="yes" xml:space="preserve">
          <source>What makes Flow fast?</source>
          <target state="translated">是什么让福禄快速发展?</target>
        </trans-unit>
        <trans-unit id="db33814c5657c00a949fba0af9d59dbafa3fcb1a" translate="yes" xml:space="preserve">
          <source>What makes Flow precise?</source>
          <target state="translated">是什么让Flow变得精准?</target>
        </trans-unit>
        <trans-unit id="b9615372050b04d6519babea83812805557c5167" translate="yes" xml:space="preserve">
          <source>What was described above is a rather coarse grained way to determine coverage. One could imagine a criterion that flags expressions as uncovered if &lt;em&gt;any&lt;/em&gt; part of their type includes &lt;code&gt;any&lt;/code&gt;, for example &lt;code&gt;Array&amp;lt;any&amp;gt;&lt;/code&gt;. While there is value in a metric like this, the &amp;ldquo;uncovered&amp;rdquo; part of the type will typically be uncovered through various operations on values of this type. For example, in the code</source>
          <target state="translated">上面描述的是一种确定覆盖率的粗粒度方法。可以想象一个条件，如果表达式的类型的&lt;em&gt;任何&lt;/em&gt;部分包括 &lt;code&gt;any&lt;/code&gt; 表达式，则将&lt;em&gt;其&lt;/em&gt;标记为未发现，例如 &lt;code&gt;Array&amp;lt;any&amp;gt;&lt;/code&gt; 。尽管在这样的度量标准中有值，但是通常会通过对该类型值进行各种操作来发现该类型的&amp;ldquo;未发现&amp;rdquo;部分。例如，在代码中</target>
        </trans-unit>
        <trans-unit id="0fd65380fb716403292b7d92faef2766c527f8ab" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s Ahead</source>
          <target state="translated">未来发展</target>
        </trans-unit>
        <trans-unit id="c5e189be8dd7a5933934ab2b958e415933a6e5ad" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s a &amp;ldquo;Library Definition&amp;rdquo;?</source>
          <target state="translated">什么是&amp;ldquo;图书馆定义&amp;rdquo;？</target>
        </trans-unit>
        <trans-unit id="40731c621de61ed4b398992215b3e1a3b5986f84" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s a Declaration File?</source>
          <target state="translated">什么是申报文件？</target>
        </trans-unit>
        <trans-unit id="b9efc85fa229daf00790235bc1d272e8bf51c10c" translate="yes" xml:space="preserve">
          <source>When an object type has an indexer property, property accesses are assumed to have the annotated type, even if the object does not have a value in that slot at runtime. It is the programmer&amp;rsquo;s responsibility to ensure the access is safe, as with arrays.</source>
          <target state="translated">当对象类型具有索引器属性时，即使对象在运行时在该插槽中没有值，也假定属性访问具有带注释的类型。与数组一样，程序员有责任确保访问的安全性。</target>
        </trans-unit>
        <trans-unit id="f8b96e1aead97a6dccb4198de5ff7a26c459a398" translate="yes" xml:space="preserve">
          <source>When are subtypes used?</source>
          <target state="translated">什么时候使用子类型?</target>
        </trans-unit>
        <trans-unit id="1f4a3bdc8dfbb9e08a8423a54448b12d02bbd84f" translate="yes" xml:space="preserve">
          <source>When calling our function that accepts a union type we must pass in &lt;strong&gt;&lt;em&gt;one of those types&lt;/em&gt;&lt;/strong&gt;. But inside of our function we are required to handle &lt;strong&gt;&lt;em&gt;all of the possible types&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">在调用接受联合类型的函数时，我们必须传入&lt;strong&gt;&lt;em&gt;这些类型之一&lt;/em&gt;&lt;/strong&gt;。但是在我们的函数内部，我们需要处理&lt;strong&gt;&lt;em&gt;所有可能的类型&lt;/em&gt;&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="302b36e230abf6c143e3b19fe2499d796c35aef9" translate="yes" xml:space="preserve">
          <source>When comparing a function type with a function it must have the same structure in order to be considered valid.</source>
          <target state="translated">当比较一个函数类型和一个函数时,它必须具有相同的结构才能被认为是有效的。</target>
        </trans-unit>
        <trans-unit id="64ef3ae0ab9bcb0e4ab1d4e8a1404fcbb0a3607c" translate="yes" xml:space="preserve">
          <source>When comparing an object type with an object it must have the same structure in order to be considered valid.</source>
          <target state="translated">当比较一个对象类型和一个对象时,它必须具有相同的结构才能被认为是有效的。</target>
        </trans-unit>
        <trans-unit id="8396399d85dff5129d383218ce52eac55a623a9e" translate="yes" xml:space="preserve">
          <source>When importing an opaque type alias, it behaves like a &lt;a href=&quot;https://flow.org/en/lang/nominal-structural/#toc-nominal-typing&quot;&gt;nominal type&lt;/a&gt;, hiding its underlying type.</source>
          <target state="translated">导入不透明类型别名时，其行为类似于&lt;a href=&quot;https://flow.org/en/lang/nominal-structural/#toc-nominal-typing&quot;&gt;名义类型&lt;/a&gt;，隐藏其基础类型。</target>
        </trans-unit>
        <trans-unit id="d2485de3e0573347cabc863911d04dfca31e158c" translate="yes" xml:space="preserve">
          <source>When in the same file the alias is defined, opaque type aliases behave exactly as regular &lt;a href=&quot;../aliases&quot;&gt;type aliases&lt;/a&gt; do.</source>
          <target state="translated">在同一文件中定义别名时，不透明类型别名的行为与常规&lt;a href=&quot;../aliases&quot;&gt;类型别名&lt;/a&gt;完全相同。</target>
        </trans-unit>
        <trans-unit id="fcb175c445847655877f1db30e472a996195f098" translate="yes" xml:space="preserve">
          <source>When setting a new value inside a tuple, the new value must match the type at that index.</source>
          <target state="translated">当在元组中设置一个新的值时,新的值必须与该索引的类型相匹配。</target>
        </trans-unit>
        <trans-unit id="7517a9e192b4a198ec7b3f51067f670add7135eb" translate="yes" xml:space="preserve">
          <source>When someone writes a class, they are declaring a &lt;em&gt;thing&lt;/em&gt;. This thing might have the same structure as something else but they still serve different purposes. Imagine two component classes that both have &lt;code&gt;render()&lt;/code&gt; methods, these components could still have totally different purposes, but in a structural type system they&amp;rsquo;d be considered exactly the same.</source>
          <target state="translated">当某人写一堂课时，他们在宣告&lt;em&gt;某件事&lt;/em&gt;。该事物可能与其他事物具有相同的结构，但它们仍具有不同的用途。想象两个都具有 &lt;code&gt;render()&lt;/code&gt; 方法的组件类，这些组件可能仍具有完全不同的用途，但是在结构类型系统中，它们将被视为完全相同。</target>
        </trans-unit>
        <trans-unit id="95d1e8cda45984711f6710361a85006d8bcb3ff6" translate="yes" xml:space="preserve">
          <source>When the request fails, we&amp;rsquo;ll get back an object with &lt;code&gt;success&lt;/code&gt; set to &lt;code&gt;false&lt;/code&gt; and an &lt;code&gt;error&lt;/code&gt; property describing the error.</source>
          <target state="translated">当请求失败时，我们将返回一个对象，该对象的 &lt;code&gt;success&lt;/code&gt; 设置为 &lt;code&gt;false&lt;/code&gt; ,并带有描述错误的 &lt;code&gt;error&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="b94abdda8ce69397406ef44dd82ee02693dedecd" translate="yes" xml:space="preserve">
          <source>When this flag is &lt;code&gt;true&lt;/code&gt;, Flow has the following behavior:</source>
          <target state="translated">当此标志为 &lt;code&gt;true&lt;/code&gt; 时，Flow具有以下行为：</target>
        </trans-unit>
        <trans-unit id="1be3aebbba7f2ab96d8a1da1d160dd3a2c2cfa21" translate="yes" xml:space="preserve">
          <source>When using a generic type for a value, Flow will track the value and make sure that you aren&amp;rsquo;t replacing it with something else.</source>
          <target state="translated">当对值使用通用类型时，Flow将跟踪该值并确保您未将其替换为其他值。</target>
        </trans-unit>
        <trans-unit id="967200160ca1f6e61c2f31daca12d9063b3bdc5b" translate="yes" xml:space="preserve">
          <source>When using this syntax, you are not required to give it a type annotation. But you still can if you need to.</source>
          <target state="translated">当使用这种语法时,你不需要给它一个类型注释。但如果你需要的话,还是可以的。</target>
        </trans-unit>
        <trans-unit id="5028ae04135e00456a2a9a3d217b11e267ea9467" translate="yes" xml:space="preserve">
          <source>When you add a subtyping constraint to an opaque type alias, we allow the opaque type to be used as the super type when outside of the defining file.</source>
          <target state="translated">当你给不透明类型别名添加一个子类型约束时,我们允许不透明类型在定义文件之外作为超级类型使用。</target>
        </trans-unit>
        <trans-unit id="7f4548b3e8ef7180dc3aa259a4fafbe13e9785c6" translate="yes" xml:space="preserve">
          <source>When you are certain your code works and for some reason Flow is unable to type check it correctly. There are a (decreasing) number of idioms in JavaScript that Flow is unable to statically type.</source>
          <target state="translated">当你确定你的代码可以工作,但由于某些原因,Flow无法正确地检查它。在JavaScript中,Flow无法静态类型化的习语数量(越来越少)。</target>
        </trans-unit>
        <trans-unit id="0640e9c67a5446e2d096da264d95ec5c0854ffcf" translate="yes" xml:space="preserve">
          <source>When you are declaring a new variable, you may optionally declare its type.</source>
          <target state="translated">当你声明一个新的变量时,你可以选择声明它的类型。</target>
        </trans-unit>
        <trans-unit id="7d4a50c3c1cd36ed94156b1a9f3ca046b8801870" translate="yes" xml:space="preserve">
          <source>When you are getting a value from a tuple at a specific index, it will return the type at that index.</source>
          <target state="translated">当你从一个特定索引的元组中获取一个值时,它将返回该索引的类型。</target>
        </trans-unit>
        <trans-unit id="01a3af0d6ce8b90608026581625e6d89d89308d5" translate="yes" xml:space="preserve">
          <source>When you are in the process of converting existing code to using Flow types and you are currently blocked on having the code type checked (maybe other code needs to be converted first).</source>
          <target state="translated">当你在将现有代码转换为使用Flow类型的过程中,而你目前被阻止了代码类型的检查(也许其他代码需要先转换)。</target>
        </trans-unit>
        <trans-unit id="e1e90957894730cc07cfd478f29c1f4e5b53f0ac" translate="yes" xml:space="preserve">
          <source>When you create an intersection of object types, you merge all of their properties together.</source>
          <target state="translated">当你创建一个对象类型的交集时,你会将它们的所有属性合并在一起。</target>
        </trans-unit>
        <trans-unit id="e5b45384d6cd9faea2b667285789acfc51eefb58" translate="yes" xml:space="preserve">
          <source>When you create an object with its properties, you create a &lt;em&gt;sealed&lt;/em&gt; object type in Flow. These sealed objects will know all of the properties you declared them with and the types of their values.</source>
          <target state="translated">创建具有其属性的对象时，将在Flow中创建&lt;em&gt;密封的&lt;/em&gt;对象类型。这些密封的对象将知道您使用它们声明的所有属性以及它们的值的类型。</target>
        </trans-unit>
        <trans-unit id="a41115243f1e2d1d0a4ea4f2efbfe55245e33a0c" translate="yes" xml:space="preserve">
          <source>When you create an object without any properties, you create an &lt;em&gt;unsealed&lt;/em&gt; object type in Flow. These unsealed objects will not know all of their properties and will allow you to add new ones.</source>
          <target state="translated">创建没有任何属性的对象时，将在Flow中创建&lt;em&gt;未密封的&lt;/em&gt;对象类型。这些未密封的对象将不了解其所有属性，并允许您添加新的属性。</target>
        </trans-unit>
        <trans-unit id="2796a6c82e1741b853aad01a67eda238fc96c9eb" translate="yes" xml:space="preserve">
          <source>When you create an opaque type alias with a subtyping constraint, the type in the type position must be a subtype of the type in the super type position.</source>
          <target state="translated">当你创建一个带有子类型约束的不透明类型别名时,类型位置的类型必须是超级类型位置的类型的子类型。</target>
        </trans-unit>
        <trans-unit id="49218e622c26dc57b5c913ea8900e0123789162a" translate="yes" xml:space="preserve">
          <source>When you do not provide a type, the inferred type will do one of two things if you re-assign it.</source>
          <target state="translated">当你不提供类型时,如果你重新分配类型,推断的类型将做两件事之一。</target>
        </trans-unit>
        <trans-unit id="dad7818449b82b15d065d9c37e04d1727c40f683" translate="yes" xml:space="preserve">
          <source>When you have a value which is a union type it&amp;rsquo;s often useful to break it apart and handle each individual type separately. With union types in Flow you can &amp;ldquo;refine&amp;rdquo; the value down to a single type.</source>
          <target state="translated">当值是联合类型时，将其分开并分别处理每个单独的类型通常很有用。使用Flow中的联合类型，您可以将值&amp;ldquo;精简&amp;rdquo;为单个类型。</target>
        </trans-unit>
        <trans-unit id="bb229dc9cf4f41267624f023e36cd675a57c24d6" translate="yes" xml:space="preserve">
          <source>When you have a value with the type &lt;code&gt;any&lt;/code&gt;, you can cause Flow to infer &lt;code&gt;any&lt;/code&gt; for the results of all of the operations you perform.</source>
          <target state="translated">当您具有类型为 &lt;code&gt;any&lt;/code&gt; 的值时，您可以使Flow根据您执行的所有操作的结果推断出 &lt;code&gt;any&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4eeac5c8af6e744b935a9344a38a377561163682" translate="yes" xml:space="preserve">
          <source>When you have complicated types that you want to reuse in multiple places, you can alias them in Flow using a &lt;strong&gt;type alias&lt;/strong&gt;.</source>
          <target state="translated">如果您要在多个地方重复使用复杂的类型，则可以使用&lt;strong&gt;类型别名&lt;/strong&gt;在Flow中为它们加上&lt;strong&gt;别名&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="d25839cb54cf8d678ab4f10e96c01f04e2a7fa3e" translate="yes" xml:space="preserve">
          <source>When you have properties that overlap by having the same name, Flow follows the same strategy as with overloaded functions: it will return the type of the first property that matches this name.</source>
          <target state="translated">当你的属性因具有相同的名称而重叠时,Flow遵循与重载函数相同的策略:它将返回与这个名称相匹配的第一个属性的类型。</target>
        </trans-unit>
        <trans-unit id="9ca6b3bbee47f3932b78bb3624b2a8e13ee5660b" translate="yes" xml:space="preserve">
          <source>When you have two classes with the same structure, they still are not considered equivalent because Flow uses nominal typing for classes.</source>
          <target state="translated">当你有两个结构相同的类时,它们仍然不被认为是等价的,因为Flow对类使用名义类型。</target>
        </trans-unit>
        <trans-unit id="10b1b571956caaa58b630e76dcdcbd496c248766" translate="yes" xml:space="preserve">
          <source>When you provide a type, you will be able to re-assign the value, but it must always be of a compatible type.</source>
          <target state="translated">当你提供一个类型时,你将能够重新赋值,但它必须始终是一个兼容的类型。</target>
        </trans-unit>
        <trans-unit id="73cb2287de1c6f15cf8167e43a3d3d87043228a3" translate="yes" xml:space="preserve">
          <source>When you retrieve an element from an array there is always a possibility that it is &lt;code&gt;undefined&lt;/code&gt;. You could have either accessed an index which is out of the bounds of the array, or the element could not exist because it is a &amp;ldquo;sparse array&amp;rdquo;.</source>
          <target state="translated">当您从数组中检索元素时，总是存在 &lt;code&gt;undefined&lt;/code&gt; 的可能性。您可能已经访问了超出数组范围的索引，或者该元素不存在，因为它是&amp;ldquo;稀疏数组&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="996a2595f6a66f040b899960922e9f1e015492aa" translate="yes" xml:space="preserve">
          <source>When you run your code, a single expression will only be run with a limited set of values. But still Flow checks &lt;em&gt;every&lt;/em&gt; possible value. In this way Flow is checking too many things or &lt;em&gt;over-approximating&lt;/em&gt; what will be valid code.</source>
          <target state="translated">当您运行代码时，将仅使用有限的一组值来运行单个表达式。但是Flow仍然会检查&lt;em&gt;所有&lt;/em&gt;可能的值。这样一来，Flow就检查了太多的东西或&lt;em&gt;过于逼近了&lt;/em&gt;什么是有效的代码。</target>
        </trans-unit>
        <trans-unit id="cfdf2c27394909eba3b1ac9709368e9e60c92c6c" translate="yes" xml:space="preserve">
          <source>When you strip the types all that is left is the value.</source>
          <target state="translated">当你把类型剥离后,剩下的只是值。</target>
        </trans-unit>
        <trans-unit id="16d02930754982f643818365c9eb65e4b4b501a2" translate="yes" xml:space="preserve">
          <source>When you try to use a value of a &lt;code&gt;mixed&lt;/code&gt; type you must first figure out what the actual type is or you&amp;rsquo;ll end up with an error.</source>
          <target state="translated">当您尝试使用 &lt;code&gt;mixed&lt;/code&gt; 类型的值时，必须首先弄清楚实际类型是什么，否则最终会出错。</target>
        </trans-unit>
        <trans-unit id="5a280997d975deface44a674ffdcce743182e95b" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;typeof&lt;/code&gt;, you&amp;rsquo;re inserting another type with all of its behaviors. This can make &lt;code&gt;typeof&lt;/code&gt; seem inconsistent where it is not.</source>
          <target state="translated">使用 &lt;code&gt;typeof&lt;/code&gt; 时，您将插入具有所有行为的另一种类型。这会使 &lt;code&gt;typeof&lt;/code&gt; 在哪里看起来不一致。</target>
        </trans-unit>
        <trans-unit id="d77557c593fb829bce95fc59df4b1a3be746ce8b" translate="yes" xml:space="preserve">
          <source>When you use the name of your class in an annotation, it means an &lt;em&gt;instance&lt;/em&gt; of your class:</source>
          <target state="translated">当您在注释中使用类的名称时，它表示您的类的&lt;em&gt;实例&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="06a3b2f1c8635c3489f18114c859485b4887b6c9" translate="yes" xml:space="preserve">
          <source>When you use this function, Flow knows exactly what is going on.</source>
          <target state="translated">当你使用这个功能时,Flow会清楚地知道发生了什么。</target>
        </trans-unit>
        <trans-unit id="b433fb4be7e2c12ca3f57f9ed0a23cad0b0d75ad" translate="yes" xml:space="preserve">
          <source>When you write a type cast expression, the result of that expression is the value with the provided type. If you hold onto the resulting value, it will have the new type.</source>
          <target state="translated">当你写一个类型转换表达式时,该表达式的结果是具有所提供类型的值。如果你抓住结果的值,它将具有新的类型。</target>
        </trans-unit>
        <trans-unit id="f5f053b01bbe2e5493eb03b59a33406b2934f8f5" translate="yes" xml:space="preserve">
          <source>Whenever you want to use a class field in Flow you must first give it an annotation.</source>
          <target state="translated">每当你想在Flow中使用一个类字段时,你必须先给它一个注释。</target>
        </trans-unit>
        <trans-unit id="007c9142c650370d910eaa325adeac0c9f34bd33" translate="yes" xml:space="preserve">
          <source>Where to put the &lt;code&gt;.flowconfig&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.flowconfig&lt;/code&gt; 放在哪里</target>
        </trans-unit>
        <trans-unit id="f9cd9b92722317ed472575adad6561c4aaa8a0c9" translate="yes" xml:space="preserve">
          <source>Which also applies to nested types within objects.</source>
          <target state="translated">这也适用于对象内的嵌套类型。</target>
        </trans-unit>
        <trans-unit id="5d77dcbc51b2f3900b8512f7fcc4c2e9f1910a53" translate="yes" xml:space="preserve">
          <source>Which then gets used as its own type.</source>
          <target state="translated">然后作为自己的类型使用。</target>
        </trans-unit>
        <trans-unit id="8a80fced10ab4b19389a445b9f4af05de4c583bb" translate="yes" xml:space="preserve">
          <source>Which would ignore any file or directory under the directory named &lt;code&gt;__tests__/&lt;/code&gt; within the project root. However, unlike the previous example&amp;rsquo;s &lt;code&gt;.*/__tests__/.*&lt;/code&gt;, it would NOT ignore files or directories under other directories named &lt;code&gt;__tests__/&lt;/code&gt;, like &lt;code&gt;src/__tests__/&lt;/code&gt;.</source>
          <target state="translated">它将忽略项目根目录下名为 &lt;code&gt;__tests__/&lt;/code&gt; 目录下的任何文件或目录。但是，与前一个示例的 &lt;code&gt;.*/__tests__/.*&lt;/code&gt; &lt;code&gt;__tests__/&lt;/code&gt; ，它不会忽略名为__tests __ /的其他目录下的文件或目录，例如 &lt;code&gt;src/__tests__/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c59a762c09f756bb3fe009f558e38099bc0a51a6" translate="yes" xml:space="preserve">
          <source>Which would parse in declaration mode any file or directory under the directory named &lt;code&gt;third_party/&lt;/code&gt; within the project root. However, unlike the previous example&amp;rsquo;s &lt;code&gt;.*/third_party/.*&lt;/code&gt;, it would NOT parse files or directories under directories named &lt;code&gt;third_party/&lt;/code&gt;, like &lt;code&gt;src/third_party/&lt;/code&gt;.</source>
          <target state="translated">它将以声明模式解析项目根目录下名为 &lt;code&gt;third_party/&lt;/code&gt; 目录下的任何文件或目录。但是，与上一个示例的 &lt;code&gt;.*/third_party/.*&lt;/code&gt; ，它不会解析名为 &lt;code&gt;third_party/&lt;/code&gt; 目录下的文件或目录，例如 &lt;code&gt;src/third_party/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6bbea4304dd73554152ad23aedd562115dbd9129" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;all&lt;/code&gt; isn&amp;rsquo;t technically a lint rule, it&amp;rsquo;s worth mentioning here. &lt;code&gt;all&lt;/code&gt; sets the default level for lint rules that don&amp;rsquo;t have a level set explicitly. &lt;code&gt;all&lt;/code&gt; can only occur as the first entry in a &lt;code&gt;.flowconfig&lt;/code&gt; or as the first rule in a &lt;code&gt;--lints&lt;/code&gt; flag. It&amp;rsquo;s not allowed in comments at all because it would have different semantics than would be expected.</source>
          <target state="translated">虽然从技术上讲并不是 &lt;code&gt;all&lt;/code&gt; 规则都可以，但在这里值得一提。 &lt;code&gt;all&lt;/code&gt; 为没有明确设置级别的皮棉规则设置默认级别。 &lt;code&gt;all&lt;/code&gt; 都只能作为 &lt;code&gt;.flowconfig&lt;/code&gt; 中的第一个条目或 &lt;code&gt;--lints&lt;/code&gt; 标志中的第一个规则出现。完全不允许在注释中使用它，因为它具有与预期不同的语义。</target>
        </trans-unit>
        <trans-unit id="52ea1ea47df53d1cf736a6d4890e67395ca8b9c4" translate="yes" xml:space="preserve">
          <source>Why can&amp;rsquo;t I pass &lt;code&gt;{a:string}&lt;/code&gt; to a function that takes &lt;code&gt;{a:string|&amp;nbsp;number}&lt;/code&gt;</source>
          <target state="translated">为什么我不能将 &lt;code&gt;{a:string}&lt;/code&gt; 传递给采用 &lt;code&gt;{a:string|&amp;nbsp;number}&lt;/code&gt; 的函数 数}</target>
        </trans-unit>
        <trans-unit id="fe6cefc353f86770ed15c2136f41c2eff2427e68" translate="yes" xml:space="preserve">
          <source>Why can&amp;rsquo;t I pass an &lt;code&gt;Array&amp;lt;string&amp;gt;&lt;/code&gt; to a function that takes an &lt;code&gt;Array&amp;lt;string |&amp;nbsp;number&amp;gt;&lt;/code&gt;</source>
          <target state="translated">为什么不能将 &lt;code&gt;Array&amp;lt;string&amp;gt;&lt;/code&gt; 传递给需要 &lt;code&gt;Array&amp;lt;string |&amp;nbsp;number&amp;gt;&lt;/code&gt; 的函数？号码&amp;gt;</target>
        </trans-unit>
        <trans-unit id="96c5c443e0f5b7e99e95365f6c4edd88369864cd" translate="yes" xml:space="preserve">
          <source>Why can&amp;rsquo;t I refine a union of objects?</source>
          <target state="translated">为什么不能优化对象的并集？</target>
        </trans-unit>
        <trans-unit id="6e3de66a2c90224644ba944e2aa7479606459060" translate="yes" xml:space="preserve">
          <source>Why can&amp;rsquo;t I use a function in my if-clause to check the type of a property?</source>
          <target state="translated">为什么不能在if子句中使用函数来检查属性的类型？</target>
        </trans-unit>
        <trans-unit id="30ff0da03e55358af58809fea89afe7aa72356c6" translate="yes" xml:space="preserve">
          <source>Width Subtyping</source>
          <target state="translated">宽度分型</target>
        </trans-unit>
        <trans-unit id="c4a257d9d182ebc37abf03c9319df6d8959cf5db" translate="yes" xml:space="preserve">
          <source>With Flow build step, using flow-bin</source>
          <target state="translated">有了Flow构建步骤,使用flow-bin</target>
        </trans-unit>
        <trans-unit id="2995c53166bcc91b45280d17fe04fd71848fc06d" translate="yes" xml:space="preserve">
          <source>With exact object types, we cannot have additional properties, so the objects conflict with one another and we are able to distinguish which is which.</source>
          <target state="translated">对于精确的对象类型,我们不能有额外的属性,所以对象之间相互冲突,我们能够区分哪个是哪个。</target>
        </trans-unit>
        <trans-unit id="c6943265cff3d8a72357d6db4963743033fc9d4b" translate="yes" xml:space="preserve">
          <source>With modularity, we can aggressively parallelize our analysis. Furthermore, when files change, we can incrementally analyze only those files that depend on the changed files. Together, these choices have helped scale the analysis to millions of lines of code.</source>
          <target state="translated">通过模块化,我们可以积极地进行并行分析。此外,当文件发生变化时,我们可以只增量分析那些依赖于变化文件的文件。这些选择共同帮助我们将分析规模扩大到数百万行代码。</target>
        </trans-unit>
        <trans-unit id="3574433dfccbc2cdc3e7d09b6a827e56cbb69b39" translate="yes" xml:space="preserve">
          <source>Within &lt;code&gt;method&lt;/code&gt;, we know that &lt;code&gt;obj&lt;/code&gt; has at least a property &lt;code&gt;foo&lt;/code&gt; and the property access expression &lt;code&gt;obj.foo&lt;/code&gt; will have type &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;method&lt;/code&gt; 中，我们知道 &lt;code&gt;obj&lt;/code&gt; 至少具有一个属性 &lt;code&gt;foo&lt;/code&gt; ,并且该属性访问表达式 &lt;code&gt;obj.foo&lt;/code&gt; 将具有 &lt;code&gt;string&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="7f4fbc91308a94a65821208a1c024c9c0775a04d" translate="yes" xml:space="preserve">
          <source>Within the -lints flag and the flowconfig, rules lower down override rules higher up, allowing you to write things like</source>
          <target state="translated">在-lints标志和flowconfig中,较低的规则覆盖了较高的规则,允许你写下类似于</target>
        </trans-unit>
        <trans-unit id="c37d919a96ee4ea89b463c060f82bc0a6e402a8f" translate="yes" xml:space="preserve">
          <source>Within the Defining File</source>
          <target state="translated">在定义文件中</target>
        </trans-unit>
        <trans-unit id="d68dc31f474400f6b50bf4dad60cd35f6668b0b3" translate="yes" xml:space="preserve">
          <source>Within the body of a &lt;code&gt;declare module&lt;/code&gt; block, you can specify the set of exports for that module. However, before we start talking about exports we have to talk about the two kinds of modules that Flow supports: CommonJS and ES modules.</source>
          <target state="translated">在 &lt;code&gt;declare module&lt;/code&gt; 块的主体内，您可以指定该模块的导出集。但是，在开始讨论导出之前，我们必须先讨论Flow支持的两种模块：CommonJS和ES模块。</target>
        </trans-unit>
        <trans-unit id="a3933bb581c579641e65e780ba1a7fc018cbb1e5" translate="yes" xml:space="preserve">
          <source>Write Flow Code</source>
          <target state="translated">编写流程代码</target>
        </trans-unit>
        <trans-unit id="0d42dc7f273412358b6af025e21835f6b2b59f3c" translate="yes" xml:space="preserve">
          <source>You are destructuring the object. When destructuring, Flow loses track of object properties.</source>
          <target state="translated">您正在对对象进行反构造。拆解时,Flow会失去对对象属性的跟踪。</target>
        </trans-unit>
        <trans-unit id="5a1fd67e5d3bc9809749035f19782f6067817cf6" translate="yes" xml:space="preserve">
          <source>You are not allowed to do the following when using &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; 时，不允许执行以下操作：</target>
        </trans-unit>
        <trans-unit id="cb97175b80248d75078c2d56240c55e682afdb8b" translate="yes" xml:space="preserve">
          <source>You are using inexact objects.</source>
          <target state="translated">你使用的是不确切的对象。</target>
        </trans-unit>
        <trans-unit id="545f113ee57613cf761d4e16a9296f0dddf18ea1" translate="yes" xml:space="preserve">
          <source>You can add methods to interfaces following the same syntax as object methods.</source>
          <target state="translated">你可以按照与对象方法相同的语法为接口添加方法。</target>
        </trans-unit>
        <trans-unit id="f13b654915322571d79f9d2209ebb3f541cb4c01" translate="yes" xml:space="preserve">
          <source>You can add properties to interfaces following the same syntax as object properties.</source>
          <target state="translated">您可以按照与对象属性相同的语法为接口添加属性。</target>
        </trans-unit>
        <trans-unit id="0ff142ce9ee3fec9b4cc52b1ba40b05d9245d3f7" translate="yes" xml:space="preserve">
          <source>You can add support for Flow in Emacs by using &lt;a href=&quot;https://github.com/flowtype/flow-for-emacs&quot;&gt;flow-for-emacs&lt;/a&gt;</source>
          <target state="translated">您可以使用&lt;a href=&quot;https://github.com/flowtype/flow-for-emacs&quot;&gt;flow-for-emacs&lt;/a&gt;添加对Emacs中Flow的支持</target>
        </trans-unit>
        <trans-unit id="f60bece6a43fa1f4f89bb550305ddcf7599cfe4f" translate="yes" xml:space="preserve">
          <source>You can add this to your &lt;code&gt;package.json&lt;/code&gt; scripts easily.</source>
          <target state="translated">您可以轻松地将其添加到 &lt;code&gt;package.json&lt;/code&gt; 脚本中。</target>
        </trans-unit>
        <trans-unit id="c722675694802907c5488d3f01827234fdbd4367" translate="yes" xml:space="preserve">
          <source>You can also add type annotations for rest parameters using the same syntax but with an &lt;code&gt;Array&lt;/code&gt;.</source>
          <target state="translated">您还可以使用相同的语法，但使用 &lt;code&gt;Array&lt;/code&gt; 为其余参数添加类型注释。</target>
        </trans-unit>
        <trans-unit id="e71d63fcbe7402ef7a02851894adf81dac971541" translate="yes" xml:space="preserve">
          <source>You can also adopt Flow incrementally and easily remove it at anytime, so you can try Flow out on any codebase and see how you like it.</source>
          <target state="translated">您还可以逐步采用Flow,并随时轻松地删除它,因此您可以在任何代码库上试用Flow,看看您的喜好。</target>
        </trans-unit>
        <trans-unit id="699187814f44354c9d5904df70d1d9ddacb546d5" translate="yes" xml:space="preserve">
          <source>You can also create arrays and add values to them later on:</source>
          <target state="translated">你也可以创建数组,并在以后向它们添加值。</target>
        </trans-unit>
        <trans-unit id="c646f56329a9cb5b56e87a03fe5b8a2719eb6c74" translate="yes" xml:space="preserve">
          <source>You can also declare opaque type aliases in &lt;a href=&quot;../libdefs&quot;&gt;libdefs&lt;/a&gt;. There, you omit the underlying type, but may still optionally include a super type.</source>
          <target state="translated">您还可以在&lt;a href=&quot;../libdefs&quot;&gt;libdefs中&lt;/a&gt;声明不透明的类型别名。在那里，您省略了基础类型，但仍可以选择包括超级类型。</target>
        </trans-unit>
        <trans-unit id="cdd17629705a4d950906c4a4641c7cec10003dd5" translate="yes" xml:space="preserve">
          <source>You can also give generic classes type arguments directly in the &lt;code&gt;new&lt;/code&gt; expression:</source>
          <target state="translated">您还可以直接在 &lt;code&gt;new&lt;/code&gt; 表达式中为泛型类提供类型参数：</target>
        </trans-unit>
        <trans-unit id="b0940d878e3d44c8bd9c7d98cbd45fecf2f71a13" translate="yes" xml:space="preserve">
          <source>You can also have optional parameters by adding a question mark &lt;code&gt;?&lt;/code&gt; after the name of the parameter and before the colon &lt;code&gt;:&lt;/code&gt;.</source>
          <target state="translated">您还可以通过添加问号来获得可选参数 &lt;code&gt;?&lt;/code&gt; 在参数名称之后和冒号之前 &lt;code&gt;:&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8cbe3e05438e8030d576dbde48b1eceb1121d9a3" translate="yes" xml:space="preserve">
          <source>You can also nest calls to &lt;code&gt;$ElementType&amp;lt;T, K&amp;gt;&lt;/code&gt;, which is useful when you need to access the types inside nested structures:</source>
          <target state="translated">您还可以嵌套对 &lt;code&gt;$ElementType&amp;lt;T, K&amp;gt;&lt;/code&gt; 调用，这在需要访问嵌套结构内的类型时非常有用：</target>
        </trans-unit>
        <trans-unit id="8c12a05528aaeb309adc27e2605804422f3d3660" translate="yes" xml:space="preserve">
          <source>You can also pass &lt;code&gt;--types-first&lt;/code&gt; to the &lt;code&gt;flow check&lt;/code&gt; or &lt;code&gt;flow start&lt;/code&gt; commands.</source>
          <target state="translated">您也可以将 &lt;code&gt;--types-first&lt;/code&gt; 传递给 &lt;code&gt;flow check&lt;/code&gt; 或 &lt;code&gt;flow start&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="815ff0c60624ac9094cf1c49f665f71a3473e58d" translate="yes" xml:space="preserve">
          <source>You can also provide defaults for parameterized generics just like parameters of a function.</source>
          <target state="translated">你也可以像函数的参数一样,为参数化的属类提供默认值。</target>
        </trans-unit>
        <trans-unit id="719a9a50e459a2a6ce7e2c56e63ed6b525dc0279" translate="yes" xml:space="preserve">
          <source>You can also specify the subtyping behavior of a generic via variance sigils. By default, generics behave invariantly, but you may add a &lt;code&gt;+&lt;/code&gt; to their declaration to make them behave covariantly, or a &lt;code&gt;-&lt;/code&gt; to their declaration to make them behave contravariantly. See &lt;a href=&quot;https://flow.org/en/lang/variance&quot;&gt;our docs on variance&lt;/a&gt; for a more information on variance in Flow.</source>
          <target state="translated">您也可以通过方差信号指定通用子类型的行为。默认情况下，泛型的行为不变，但您可以在其声明中添加 &lt;code&gt;+&lt;/code&gt; 以使其表现协变，或在其声明中添加 &lt;code&gt;-&lt;/code&gt; 以使其表现为协变。有关Flow中&lt;a href=&quot;https://flow.org/en/lang/variance&quot;&gt;方差&lt;/a&gt;的更多信息，请参见我们的方差文档。</target>
        </trans-unit>
        <trans-unit id="f9363b7818b6e43e3422f3ad1d7ee6efa7ab8e46" translate="yes" xml:space="preserve">
          <source>You can also type &lt;code&gt;flow&lt;/code&gt; to accomplish the same effect as &lt;code&gt;status&lt;/code&gt; is the default flag to the &lt;code&gt;flow&lt;/code&gt; binary.</source>
          <target state="translated">您还可以键入 &lt;code&gt;flow&lt;/code&gt; 以实现相同的效果，因为 &lt;code&gt;status&lt;/code&gt; 是 &lt;code&gt;flow&lt;/code&gt; 二进制文件的默认标志。</target>
        </trans-unit>
        <trans-unit id="b68e51da33b5e539af5dbf6e3dcc5a59c33fe6c7" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;implements&lt;/code&gt; to tell Flow that you want the class to match an interface. This prevents you from making incompatible changes when editing the class.</source>
          <target state="translated">您还可以使用 &lt;code&gt;implements&lt;/code&gt; 来告诉Flow您希望类与接口匹配。这样可以防止您在编辑类时进行不兼容的更改。</target>
        </trans-unit>
        <trans-unit id="e3a1292b81cf7cdb77a98439b57cf0147e0f8f3b" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;implements&lt;/code&gt; with multiple interfaces.</source>
          <target state="translated">您还可以将 &lt;code&gt;implements&lt;/code&gt; 与多个接口一起使用。</target>
        </trans-unit>
        <trans-unit id="48dd13ac8774ad647e286bd9947352ec269d5800" translate="yes" xml:space="preserve">
          <source>You can also use named type imports in either an ES module environment or a CommonJS environment:</source>
          <target state="translated">您也可以在ES模块环境或CommonJS环境中使用命名类型导入。</target>
        </trans-unit>
        <trans-unit id="7a88daebe91d272da9a7e038c3583dda16175e43" translate="yes" xml:space="preserve">
          <source>You can also use the form &lt;code&gt;/* @flow */&lt;/code&gt; for the flag as well.</source>
          <target state="translated">您还可以使用 &lt;code&gt;/* @flow */&lt;/code&gt; 形式的标志。</target>
        </trans-unit>
        <trans-unit id="01c4697a441a0d2aa3c1b9f07e0ceb2ffc32acec" translate="yes" xml:space="preserve">
          <source>You can also validate that you have handled every single type of action by using the &lt;code&gt;empty&lt;/code&gt; type in your &lt;code&gt;default&lt;/code&gt; case.</source>
          <target state="translated">您还可以通过在 &lt;code&gt;default&lt;/code&gt; 情况下使用 &lt;code&gt;empty&lt;/code&gt; 类型来验证是否已处理了每种类型的操作。</target>
        </trans-unit>
        <trans-unit id="8d608633d54b23080262b0d07f6cb7d3dc534564" translate="yes" xml:space="preserve">
          <source>You can benefit from having Flow run as you develop by integrating into your editor.</source>
          <target state="translated">通过将Flow集成到您的编辑器中,您可以从Flow的运行中获益。</target>
        </trans-unit>
        <trans-unit id="2dcc931397145e4c230e84b33d5d8a5720c03798" translate="yes" xml:space="preserve">
          <source>You can create &lt;a href=&quot;../objects#toc-objects-as-maps&quot;&gt;&amp;ldquo;indexer properties&amp;rdquo;&lt;/a&gt; the same way as with objects.</source>
          <target state="translated">您可以使用与对象相同的方式来创建&lt;a href=&quot;../objects#toc-objects-as-maps&quot;&gt;&amp;ldquo;索引器属性&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b7946b65fbac98e9648cd5f68e306b48534b1a74" translate="yes" xml:space="preserve">
          <source>You can do that by adding an explicit type argument:</source>
          <target state="translated">你可以通过添加一个显式类型参数来实现。</target>
        </trans-unit>
        <trans-unit id="d7fff0a703433e91168cd9bf5a21b4d5e3872e70" translate="yes" xml:space="preserve">
          <source>You can enable stronger safety guarantees in Flow (such as banning &lt;code&gt;any&lt;/code&gt;/&lt;code&gt;Object&lt;/code&gt;/&lt;code&gt;Function&lt;/code&gt; types and requiring all dependencies to be typed) by adding &lt;strong&gt;&lt;code&gt;@flow strict&lt;/code&gt;&lt;/strong&gt; to your files.</source>
          <target state="translated">通过在文件中添加&lt;strong&gt; &lt;code&gt;@flow strict&lt;/code&gt; &lt;/strong&gt;，可以在Flow中启用更强的安全性保证（例如，禁止 &lt;code&gt;any&lt;/code&gt; / &lt;code&gt;Object&lt;/code&gt; / &lt;code&gt;Function&lt;/code&gt; 类型并要求键入所有依赖项）。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eaa5fe932d239a06fd9575f03866b957b8981092" translate="yes" xml:space="preserve">
          <source>You can enforce this in Flow by making every property effectively &amp;ldquo;read-only&amp;rdquo; using &amp;ldquo;covariant&amp;rdquo; properties throughout your state object.</source>
          <target state="translated">您可以通过在整个状态对象中使用&amp;ldquo;协变量&amp;rdquo;属性使每个属性有效地为&amp;ldquo;只读&amp;rdquo;，从而在Flow中强制执行此操作。</target>
        </trans-unit>
        <trans-unit id="ba6431d84c3e47b98b215406e4d6e813fefabd22" translate="yes" xml:space="preserve">
          <source>You can even nest lookups:</source>
          <target state="translated">你甚至可以进行嵌套查询。</target>
        </trans-unit>
        <trans-unit id="4ccb58e74c71e2de2b124e20c360c5995e2ecd92" translate="yes" xml:space="preserve">
          <source>You can expand this even further and keep refining possibilities away:</source>
          <target state="translated">你可以把这一点进一步扩大,不断提炼出可能性来。</target>
        </trans-unit>
        <trans-unit id="f2afe0e2209309fcca1d0d4c82e4b42131180ea4" translate="yes" xml:space="preserve">
          <source>You can fix this by making &lt;code&gt;truthy&lt;/code&gt; a &lt;em&gt;predicate function&lt;/em&gt;, by using the &lt;code&gt;%checks&lt;/code&gt; annotation like so:</source>
          <target state="translated">您可以通过使用 &lt;code&gt;%checks&lt;/code&gt; 批注将 &lt;code&gt;truthy&lt;/code&gt; 作为&lt;em&gt;谓词函数&lt;/em&gt;来解决此问题，如下所示：</target>
        </trans-unit>
        <trans-unit id="1300bdbd711a74807a169ed243bc8221cc1ddb60" translate="yes" xml:space="preserve">
          <source>You can force Flow to treat one or more files as focused from the CLI.</source>
          <target state="translated">您可以通过CLI强制Flow将一个或多个文件作为焦点文件。</target>
        </trans-unit>
        <trans-unit id="235ba8a2cc1e9c6fd298a395322859ee23a447be" translate="yes" xml:space="preserve">
          <source>You can get around this by storing your checked values in local variables:</source>
          <target state="translated">你可以通过在本地变量中存储你的检查值来解决这个问题。</target>
        </trans-unit>
        <trans-unit id="64fd44f437add0d9e133a8562afc12f273306434" translate="yes" xml:space="preserve">
          <source>You can give callable entities type arguments for their generics directly in the call:</source>
          <target state="translated">你可以在调用中直接给可调用实体的属类提供类型参数。</target>
        </trans-unit>
        <trans-unit id="8ade9cad1bbc6b49fbea6fdd6de913340f01abe2" translate="yes" xml:space="preserve">
          <source>You can have as many of these generics as you need in the type parameter list, naming them whatever you want:</source>
          <target state="translated">在类型参数列表中,你可以根据你的需要拥有任意数量的这些属种,你想怎么命名就怎么命名。</target>
        </trans-unit>
        <trans-unit id="5cf2172f11dbbcc47d7a009c576faeb7aa356654" translate="yes" xml:space="preserve">
          <source>You can make a property contravariant by adding a minus symbol - in front of the property name.</source>
          <target state="translated">你可以通过在属性名称前添加一个减号来使属性反常。</target>
        </trans-unit>
        <trans-unit id="1bdca1788706e2fc8e4a9c9a6e2d01cd32f92dcf" translate="yes" xml:space="preserve">
          <source>You can make a property covariant by adding a plus symbol &lt;code&gt;+&lt;/code&gt; in front of the property name.</source>
          <target state="translated">您可以通过在属性名称前面添加加号 &lt;code&gt;+&lt;/code&gt; 来使属性协变。</target>
        </trans-unit>
        <trans-unit id="b010851670e4ca7a130bea951f459af8dca6a36b" translate="yes" xml:space="preserve">
          <source>You can optionally add a subtyping constraint to an opaque type alias by adding a colon &lt;code&gt;:&lt;/code&gt; and a type after the name.</source>
          <target state="translated">您可以选择在不透明类型别名中添加子类型约束，方法是在名称后添加冒号 &lt;code&gt;:&lt;/code&gt; 和类型。</target>
        </trans-unit>
        <trans-unit id="fd2496b164e62d7e0f41690b9f5e9552b1b451b8" translate="yes" xml:space="preserve">
          <source>You can pass as many arguments as you want into a rest parameter.</source>
          <target state="translated">你可以在休息参数中传递任意数量的参数。</target>
        </trans-unit>
        <trans-unit id="e6bd5c0ce38f5afd67d2acbbfbe61b90c3c48db4" translate="yes" xml:space="preserve">
          <source>You can put any type within &lt;code&gt;Array&amp;lt;Type&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">您可以在 &lt;code&gt;Array&amp;lt;Type&amp;gt;&lt;/code&gt; 放入任何类型。</target>
        </trans-unit>
        <trans-unit id="732207deaac1dc0f323e2c9b02fc147f8f812da1" translate="yes" xml:space="preserve">
          <source>You can simplify the two checks against &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; using a single &lt;code&gt;!= null&lt;/code&gt; check which will do both.</source>
          <target state="translated">您可以使用单个 &lt;code&gt;!= null&lt;/code&gt; 检查简化对 &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 的两个检查。</target>
        </trans-unit>
        <trans-unit id="9afabef0657e245fef1b9b2930123308edd5afac" translate="yes" xml:space="preserve">
          <source>You can specify in the &lt;code&gt;.flowconfig&lt;/code&gt; which version of Flow you expect to use. You do this with the &lt;code&gt;[version]&lt;/code&gt; section. If this section is omitted or left blank, then any version is allowed. If a version is specified and not matched, then Flow will immediately error and exit.</source>
          <target state="translated">您可以在 &lt;code&gt;.flowconfig&lt;/code&gt; 中指定您希望使用哪个版本的Flow。您可以通过 &lt;code&gt;[version]&lt;/code&gt; 部分执行此操作。如果省略此部分或将其留空，则允许使用任何版本。如果指定了一个版本而不匹配，则Flow将立即出错并退出。</target>
        </trans-unit>
        <trans-unit id="e03b894ceec87547a288939cd8aaf30ae007c81b" translate="yes" xml:space="preserve">
          <source>You can start to compare two objects by their keys. If one object contains all the keys of another object, then it may be a subtype.</source>
          <target state="translated">你可以从两个对象的键开始比较。如果一个对象包含另一个对象的所有键,那么它可能是一个子类型。</target>
        </trans-unit>
        <trans-unit id="d28e07b9c51e5ffadf873da6f7a3f54bbf76f2f9" translate="yes" xml:space="preserve">
          <source>You can then, further dig into particular COMMANDs by adding the &lt;code&gt;--help&lt;/code&gt; flag.</source>
          <target state="translated">然后，您可以通过添加 &lt;code&gt;--help&lt;/code&gt; 标志来进一步挖掘特定的COMMAND 。</target>
        </trans-unit>
        <trans-unit id="bd1e8c4360056b71335ea367a6b3e679639d25f3" translate="yes" xml:space="preserve">
          <source>You can think of this like passing arguments to a function, only the return value is a type that you can use.</source>
          <target state="translated">你可以认为这就像向函数传递参数一样,只是返回值是一个你可以使用的类型。</target>
        </trans-unit>
        <trans-unit id="77a6915e052949d36dbc7c36f8a0ffc2fd6eea09" translate="yes" xml:space="preserve">
          <source>You can update your code to the more readable:</source>
          <target state="translated">你可以把你的代码更新成更易读的。</target>
        </trans-unit>
        <trans-unit id="ebd1cddf8c517151cd84a6cfd9b8b49383f2e6c4" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;typeof x === &quot;symbol&quot;&lt;/code&gt; to refine to a symbol.</source>
          <target state="translated">您可以使用 &lt;code&gt;typeof x === &quot;symbol&quot;&lt;/code&gt; 细化为符号。</target>
        </trans-unit>
        <trans-unit id="b81520be069e0fa0c9db8cbcabf710cfccf37e42" translate="yes" xml:space="preserve">
          <source>You can use any value with &lt;code&gt;typeof&lt;/code&gt;:</source>
          <target state="translated">您可以将任何值与 &lt;code&gt;typeof&lt;/code&gt; 一起使用：</target>
        </trans-unit>
        <trans-unit id="5eb1e9ebfd9c95be03ab9be04d025560b3074e1c" translate="yes" xml:space="preserve">
          <source>You can use generics in the same places you&amp;rsquo;d add any other type in a class (property types and method parameter/return types).</source>
          <target state="translated">您可以在将类添加任何其他类型（属性类型和方法参数/返回类型）的相同位置使用泛型。</target>
        </trans-unit>
        <trans-unit id="f4aa0e86d6f17a2f8d19918819c102cbd6c3820e" translate="yes" xml:space="preserve">
          <source>You can use generics in the same places you&amp;rsquo;d add any other type in a function (parameter or return types).</source>
          <target state="translated">您可以在将泛型添加到函数中的任何其他类型（参数或返回类型）的相同位置使用泛型。</target>
        </trans-unit>
        <trans-unit id="8de2ccca92b2b43ac3dc44c63b7e55c6b432c76a" translate="yes" xml:space="preserve">
          <source>You can use generics in the same places you&amp;rsquo;d add any other type in a function type (parameter or return types).</source>
          <target state="translated">您可以在将泛型添加到函数类型（参数或返回类型）中的其他位置使用泛型。</target>
        </trans-unit>
        <trans-unit id="2d107b2ef0635398f316220ce167c042b23a92d8" translate="yes" xml:space="preserve">
          <source>You can use primitive values for these types:</source>
          <target state="translated">你可以为这些类型使用基元值。</target>
        </trans-unit>
        <trans-unit id="1997334cf38d8070cc18855e7eb4a51b9f7aa599" translate="yes" xml:space="preserve">
          <source>You can use this in combination with &lt;code&gt;Class&amp;lt;T&amp;gt;&lt;/code&gt; to get static props:</source>
          <target state="translated">您可以将其与 &lt;code&gt;Class&amp;lt;T&amp;gt;&lt;/code&gt; 结合使用以获得静态道具：</target>
        </trans-unit>
        <trans-unit id="b38b57891c6a590d35857959678efd3a7cbc9edf" translate="yes" xml:space="preserve">
          <source>You cannot use &lt;code&gt;Array.prototype&lt;/code&gt; methods that mutate the tuple, only ones that do not.</source>
          <target state="translated">您不能使用使元组突变的 &lt;code&gt;Array.prototype&lt;/code&gt; 方法，而不能使用那些不使元组突变的方法。</target>
        </trans-unit>
        <trans-unit id="34cdb6dbd42effcc5eee6814751e14333d7ad7b4" translate="yes" xml:space="preserve">
          <source>You could also flip it around, and check to make sure that the value has a type of &lt;code&gt;number&lt;/code&gt; before using it.</source>
          <target state="translated">您也可以将其翻转，并在使用前检查以确保该值具有 &lt;code&gt;number&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="d54fcc4baacde621798558cd944fe72a2272653e" translate="yes" xml:space="preserve">
          <source>You could continue this process until &lt;code&gt;any&lt;/code&gt; has leaked all over your code.</source>
          <target state="translated">直到你可以继续这个过程中 &lt;code&gt;any&lt;/code&gt; 已经泄漏在你的代码。</target>
        </trans-unit>
        <trans-unit id="a5ccb2330f2aef610502456380da1cc91e063a81" translate="yes" xml:space="preserve">
          <source>You could do</source>
          <target state="translated">你可以这样做</target>
        </trans-unit>
        <trans-unit id="a96c3e789576bc7f92cd0b34129750d6ad259391" translate="yes" xml:space="preserve">
          <source>You could refine the type, but the generic will still allow any type to be passed in.</source>
          <target state="translated">你可以细化类型,但generic仍然允许任何类型被传递进来。</target>
        </trans-unit>
        <trans-unit id="2ce625c160012e98036189d91961fd70764c6f12" translate="yes" xml:space="preserve">
          <source>You could then use the resulting value in another operation, such as adding it as if it were a number and the result will also be &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">然后，您可以在另一个操作中使用结果值，例如将其添加为数字，则结果也将为 &lt;code&gt;any&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6d0c0f6b4e6d2338d922e76b590f2d36d1904032" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t need to annotate the return type of either your &lt;code&gt;render()&lt;/code&gt; method or a stateless functional component. However, if you want to annotate the return type then &lt;code&gt;React.Node&lt;/code&gt; is the generic to use.</source>
          <target state="translated">您无需注释 &lt;code&gt;render()&lt;/code&gt; 方法或无状态功能组件的返回类型。但是，如果要注释返回类型，则 &lt;code&gt;React.Node&lt;/code&gt; 是要使用的泛型。</target>
        </trans-unit>
        <trans-unit id="2f9c2c80449347f7166dc305529f30c45a9e9eed" translate="yes" xml:space="preserve">
          <source>You may also add a leading ampersand which is useful when breaking intersection types onto multiple lines.</source>
          <target state="translated">您也可以添加一个前导的安括号,这在将交叉类型分解到多行上时很有用。</target>
        </trans-unit>
        <trans-unit id="2fa909f29db190474cf723005ff4008d9b7598e9" translate="yes" xml:space="preserve">
          <source>You may also add a leading vertical bar which is useful when breaking union types onto multiple lines.</source>
          <target state="translated">您也可以添加一个前导垂直条,这在将联合类型分解到多行时很有用。</target>
        </trans-unit>
        <trans-unit id="4b9fdbe0651aa0dcc77f656e366ff86ea773ba26" translate="yes" xml:space="preserve">
          <source>You may also optionally leave out the parameter names.</source>
          <target state="translated">你也可以选择不写参数名称。</target>
        </trans-unit>
        <trans-unit id="8369235f7cc951c26ca572a5f0d1089b25b9b0f4" translate="yes" xml:space="preserve">
          <source>You may also set this to &lt;code&gt;ignore&lt;/code&gt; to indicate that Flow should simply ignore the syntax (i.e. Flow will not use this syntax to indicate the presence of a property on instances of the class).</source>
          <target state="translated">您还可以将其设置为 &lt;code&gt;ignore&lt;/code&gt; 以指示Flow应该仅忽略语法（即，Flow将不使用该语法来指示类的实例上存在属性）。</target>
        </trans-unit>
        <trans-unit id="12abc47c0cac769438a2a10d53130bb5088f3b42" translate="yes" xml:space="preserve">
          <source>You may also set this to &lt;code&gt;ignore&lt;/code&gt; to indicate that Flow should simply ignore the syntax (i.e. Flow will not use this syntax to indicate the presence of a static property on the class).</source>
          <target state="translated">您也可以将其设置为 &lt;code&gt;ignore&lt;/code&gt; 以指示Flow应该仅忽略语法（即，Flow将不使用该语法指示类中是否存在静态属性）。</target>
        </trans-unit>
        <trans-unit id="bfbbefdd992a4649126e811e71f05644039bb6d5" translate="yes" xml:space="preserve">
          <source>You may also set this to &lt;code&gt;ignore&lt;/code&gt; to indicate that Flow should simply ignore the syntax.</source>
          <target state="translated">您也可以将其设置为 &lt;code&gt;ignore&lt;/code&gt; 以指示Flow应该仅忽略语法。</target>
        </trans-unit>
        <trans-unit id="43a0ac12f9014a2da637bcb44bcbb4fbf90a6924" translate="yes" xml:space="preserve">
          <source>You may also set this to &lt;code&gt;ignore&lt;/code&gt; to indicate that Flow should simply ignore the syntax. The default value of this option is &lt;code&gt;warn&lt;/code&gt;, which gives a warning on use since this proposal is still very early-stage.</source>
          <target state="translated">您也可以将其设置为 &lt;code&gt;ignore&lt;/code&gt; 以指示Flow应该仅忽略语法。该选项的默认值为 &lt;code&gt;warn&lt;/code&gt; ，由于该建议仍处于早期阶段，因此会在使用时发出警告。</target>
        </trans-unit>
        <trans-unit id="aa76b5b2c71934a0d36af87656f7165b00582a43" translate="yes" xml:space="preserve">
          <source>You may also wish to install a popular SublimeLinter plugin for Flow like &lt;a href=&quot;https://packagecontrol.io/packages/SublimeLinter-flow&quot;&gt;SublimeLinter-flow&lt;/a&gt;.</source>
          <target state="translated">您可能还希望为Flow安装流行的SublimeLinter插件，例如&lt;a href=&quot;https://packagecontrol.io/packages/SublimeLinter-flow&quot;&gt;SublimeLinter-flow&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bd52a5c29c3e64a83bb0f62e994bfb74ab453fe3" translate="yes" xml:space="preserve">
          <source>You might use these functions types for something like a callback.</source>
          <target state="translated">你可以用这些函数类型来做类似回调的事情。</target>
        </trans-unit>
        <trans-unit id="2ed4bf60715e28afa28e2fa5a72f5002c15618be" translate="yes" xml:space="preserve">
          <source>You must always include the brackets &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; when using the type (just like parentheses for a function call).</source>
          <target state="translated">使用类型时，必须始终包含方括号 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; （就像函数调用的括号一样）。</target>
        </trans-unit>
        <trans-unit id="99f73949e10ba9c21b14d2d45c52b596aa157461" translate="yes" xml:space="preserve">
          <source>You must be explicit and convert other types into strings. You can do this by using the String method or using another method for stringifying values.</source>
          <target state="translated">你必须明确并将其他类型转换成字符串。你可以通过使用String方法或使用其他方法来实现字符串化值。</target>
        </trans-unit>
        <trans-unit id="01b16b93eebbf6cd3d2d130c4da4b067de2c5876" translate="yes" xml:space="preserve">
          <source>You should represent these values with &lt;code&gt;mixed&lt;/code&gt;.</source>
          <target state="translated">您应该用 &lt;code&gt;mixed&lt;/code&gt; 代表这些值。</target>
        </trans-unit>
        <trans-unit id="e73e4c01718490bcf4d4cc882d49967190833cfe" translate="yes" xml:space="preserve">
          <source>You will have access to all of the values that React exports, but you will &lt;strong&gt;not&lt;/strong&gt; have access to the types documented below! This is because Flow will not add types to a default export since the default export could be any value (like a number). Flow will add exported named types to an ES namespace object which you can get with &lt;code&gt;import * as React from 'react'&lt;/code&gt; since Flow knows if you export a value with the same name as an exported type.</source>
          <target state="translated">你将有机会获得所有阵营出口值的，但你会&lt;strong&gt;不会&lt;/strong&gt;有机会获得以下介绍的类型！这是因为Flow不会将类型添加到默认导出中，因为默认导出可以是任何值（例如数字）。Flow会将导出的命名类型添加到ES命名空间对象中，您可以使用 &lt;code&gt;import * as React from 'react'&lt;/code&gt; 从React获得，因为Flow知道您是否导出与导出类型同名的值。</target>
        </trans-unit>
        <trans-unit id="3c23f9cce0d3c2c8df25b9ff8cf278ae227f7bad" translate="yes" xml:space="preserve">
          <source>You write classes the same way you would without Flow, but then you can use the name of the class as a type.</source>
          <target state="translated">编写类的方法和没有Flow时一样,但你可以使用类的名称作为类型。</target>
        </trans-unit>
        <trans-unit id="654c5e74e5e546451d0e1429c2931cddd203538d" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll notice that if we do not handle each possible type of our value, Flow will give us an error.</source>
          <target state="translated">您会注意到，如果我们不处理每种可能的值类型，Flow将给我们一个错误。</target>
        </trans-unit>
        <trans-unit id="75e6e89e1f9c5b889605448ec75232836809ed76" translate="yes" xml:space="preserve">
          <source>[declarations]</source>
          <target state="translated">[declarations]</target>
        </trans-unit>
        <trans-unit id="8efeedea6584d5d0f6aa150fe286ea3d383ef4a5" translate="yes" xml:space="preserve">
          <source>[ignore]</source>
          <target state="translated">[ignore]</target>
        </trans-unit>
        <trans-unit id="6c51495394c6e6372e62ee5ec85bb9eaef21cce5" translate="yes" xml:space="preserve">
          <source>[include]</source>
          <target state="translated">[include]</target>
        </trans-unit>
        <trans-unit id="7afbe53dfddbe7c93f7de3dd43aba3228ee7b934" translate="yes" xml:space="preserve">
          <source>[libs]</source>
          <target state="translated">[libs]</target>
        </trans-unit>
        <trans-unit id="0a5387e3c9cf9ab97fc0bf23e3269594e185c36d" translate="yes" xml:space="preserve">
          <source>[lints]</source>
          <target state="translated">[lints]</target>
        </trans-unit>
        <trans-unit id="83f3a6281fb9adf03bf77c91402ae0e931ccb966" translate="yes" xml:space="preserve">
          <source>[options]</source>
          <target state="translated">[options]</target>
        </trans-unit>
        <trans-unit id="5342d8199f9eb9d08f90a284e8dd1dc7804a74f9" translate="yes" xml:space="preserve">
          <source>[untyped]</source>
          <target state="translated">[untyped]</target>
        </trans-unit>
        <trans-unit id="82269fe5787de6e7ec27fcc12d83c2cbb09336c3" translate="yes" xml:space="preserve">
          <source>[version]</source>
          <target state="translated">[version]</target>
        </trans-unit>
        <trans-unit id="a1024232bfedfebb6aacd740ffd636d6f41a840a" translate="yes" xml:space="preserve">
          <source>and now</source>
          <target state="translated">而今</target>
        </trans-unit>
        <trans-unit id="48e7db6313c704fbd26e0ba32bef954b2e977a24" translate="yes" xml:space="preserve">
          <source>and spread that into the &lt;code&gt;Props&lt;/code&gt; type:</source>
          <target state="translated">并将其传播到 &lt;code&gt;Props&lt;/code&gt; 类型：</target>
        </trans-unit>
        <trans-unit id="2cc9aa7176523739af8846ebf98bde04cafdfc07" translate="yes" xml:space="preserve">
          <source>and suppose that &lt;code&gt;src/Misc.js&lt;/code&gt; has an incompatible implementation of &lt;code&gt;isLeapYear&lt;/code&gt;:</source>
          <target state="translated">并假设 &lt;code&gt;src/Misc.js&lt;/code&gt; 具有 &lt;code&gt;isLeapYear&lt;/code&gt; 的不兼容实现：</target>
        </trans-unit>
        <trans-unit id="ec2d7bdbbbacb178e39b0b7c79bfc355baf6b95f" translate="yes" xml:space="preserve">
          <source>and suppress the error. If there is no error on the next line (the suppression is unnecessary), an &amp;ldquo;Unused suppression&amp;rdquo; warning will be shown instead.</source>
          <target state="translated">并消除错误。如果下一行没有错误（不需要取消），则会显示&amp;ldquo;未使用的取消&amp;rdquo;警告。</target>
        </trans-unit>
        <trans-unit id="a9745abbdcf92eab56732a7d35f17f430c1336bf" translate="yes" xml:space="preserve">
          <source>and then it comes across a &lt;code&gt;package.json&lt;/code&gt; with</source>
          <target state="translated">然后遇到一个 &lt;code&gt;package.json&lt;/code&gt; 与</target>
        </trans-unit>
        <trans-unit id="0768098259f562a18299b5c17e4ddd6a8b9d9b5b" translate="yes" xml:space="preserve">
          <source>and you try to use Flow v0.21.0, then Flow will immediately error with the message</source>
          <target state="translated">而你试图使用Flow v0.21.0,那么Flow会立即出错,并出现以下信息。</target>
        </trans-unit>
        <trans-unit id="fca2dbc7b2ac4e20f39f9f3ef522d55252c79cbb" translate="yes" xml:space="preserve">
          <source>broken: &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBLAtgB1gJwC6gFSgCGAzqAEoCmRAxnpFrKqAORbV0uKI4Ce6lUAGUArgCMAjAAVG6MgF5QAb2IAuUADsRqMZSwAaUGPVade0AF8A3D36DRYgEwzYc0IpVF1JHFmQaAc0Mab19-AMsbRBpYDR9hcQl3UAAKdFkSdQdpDIBKdwA+UAAeABNkADdQYAKbGLi8B0dktIys8Wc8wpLyqpqo+viAYSYWpURQUBJKaEo6bH0J0AA6VfTXEkQLdRVp2fmsdV8RSkNV5eyXNwtQAB9lKZm5nGx1SCJoabPVpquyC3y8gKSz2z2woAA-CVsspzus5DcaqB1MUmrC1hlEbUgA&quot;&gt;https://flow.org/try&lt;/a&gt;</source>
          <target state="translated">损坏的：&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBLAtgB1gJwC6gFSgCGAzqAEoCmRAxnpFrKqAORbV0uKI4Ce6lUAGUArgCMAjAAVG6MgF5QAb2IAuUADsRqMZSwAaUGPVade0AF8A3D36DRYgEwzYc0IpVF1JHFmQaAc0Mab19-AMsbRBpYDR9hcQl3UAAKdFkSdQdpDIBKdwA+UAAeABNkADdQYAKbGLi8B0dktIys8Wc8wpLyqpqo+viAYSYWpURQUBJKaEo6bH0J0AA6VfTXEkQLdRVp2fmsdV8RSkNV5eyXNwtQAB9lKZm5nGx1SCJoabPVpquyC3y8gKSz2z2woAA-CVsspzus5DcaqB1MUmrC1hlEbUgA&quot;&gt;https&lt;/a&gt; : //flow.org/try</target>
        </trans-unit>
        <trans-unit id="e64557fab980626ab81ed51e1987304bd8228deb" translate="yes" xml:space="preserve">
          <source>but in types-first the exported type will be</source>
          <target state="translated">但在type-first中,导出的类型将是</target>
        </trans-unit>
        <trans-unit id="774e51ee6ebca6e8cb9d7f4d3fe9750f2b9256ae" translate="yes" xml:space="preserve">
          <source>but this doesn&amp;rsquo;t feel very DRY, as we had to explicitly define the suit names twice.</source>
          <target state="translated">但这并不太干，因为我们不得不两次定义衣服名称。</target>
        </trans-unit>
        <trans-unit id="6e45777a3dd462c6a840e9e356a7099b6982bc19" translate="yes" xml:space="preserve">
          <source>but with &lt;code&gt;$ReadOnlyArray&lt;/code&gt; you can achieve what you were looking for:</source>
          <target state="translated">但是使用 &lt;code&gt;$ReadOnlyArray&lt;/code&gt; 您可以实现所需的功能：</target>
        </trans-unit>
        <trans-unit id="46438caefd12a0fd432aedcd449aa37d123fa4c1" translate="yes" xml:space="preserve">
          <source>but with a covariant property you can achieve what you were looking for:</source>
          <target state="translated">但如果有了共变属性,就可以达到你想要的目的。</target>
        </trans-unit>
        <trans-unit id="ccd55bda6574570ee546195840fdf67842826f24" translate="yes" xml:space="preserve">
          <source>coc.nvim-neovim</source>
          <target state="translated">coc.nvim-neovim</target>
        </trans-unit>
        <trans-unit id="eca0bd3451749c34200b52876c4df81d84e1e7cd" translate="yes" xml:space="preserve">
          <source>doesn&amp;rsquo;t report a warning.</source>
          <target state="translated">不报告警告。</target>
        </trans-unit>
        <trans-unit id="ecb70bca541e08251da88aa6114a01ea186dc721" translate="yes" xml:space="preserve">
          <source>fixed: &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBLAtgB1gJwC6gFSgCGAzqAEoCmRAxnpFrKqAORbV0uKI4Ce6lUAGUArgCMAjAAVG6MgF5QAbwA+xAFygAdiNRjKWADSgxmnXoOgVAXwDcPfoNFiATDNhzQi1RtAkcWMhaAObGNJr+gSFWdtw0sFr+wuISXqAAFOiyJJrO0tkAlF4AfKAAPAAmyABuoMDF9vGJeM4uaZnZueJuhSXlVbX19ohNSQDCTO1ZHjnKaiSU0JR02JoBIpTGAHQ7ee6eNlZzfovLOKugkETQC9u73ftkNkXypUqIoKDIkBnTclsLJYrLBFd6fT5LPBKQFnbB3LbsfzWNJ-Ej2cGgdg4ERYLTlPLKHYIyhIuoND6gZGLBbKCkQyhQmHA+GInDIxSo9HgrE4vFlVqEnas5FDCnWRDWIA&quot;&gt;https://flow.org/try&lt;/a&gt;</source>
          <target state="translated">固定：&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBLAtgB1gJwC6gFSgCGAzqAEoCmRAxnpFrKqAORbV0uKI4Ce6lUAGUArgCMAjAAVG6MgF5QAbwA+xAFygAdiNRjKWADSgxmnXoOgVAXwDcPfoNFiATDNhzQi1RtAkcWMhaAObGNJr+gSFWdtw0sFr+wuISXqAAFOiyJJrO0tkAlF4AfKAAPAAmyABuoMDF9vGJeM4uaZnZueJuhSXlVbX19ohNSQDCTO1ZHjnKaiSU0JR02JoBIpTGAHQ7ee6eNlZzfovLOKugkETQC9u73ftkNkXypUqIoKDIkBnTclsLJYrLBFd6fT5LPBKQFnbB3LbsfzWNJ-Ej2cGgdg4ERYLTlPLKHYIyhIuoND6gZGLBbKCkQyhQmHA+GInDIxSo9HgrE4vFlVqEnas5FDCnWRDWIA&quot;&gt;https&lt;/a&gt; : //flow.org/try</target>
        </trans-unit>
        <trans-unit id="406a50ab8f418267ad4cb79f7ec8af3c757e5d1a" translate="yes" xml:space="preserve">
          <source>flow-for-emacs</source>
          <target state="translated">flow-for-emacs</target>
        </trans-unit>
        <trans-unit id="b31ed27db0f3f06537ccbd7e0612af0839145d27" translate="yes" xml:space="preserve">
          <source>flow-remove-types</source>
          <target state="translated">flow-remove-types</target>
        </trans-unit>
        <trans-unit id="bb6bd705fa5bbecd686c0aa80112ee7f1ec636a5" translate="yes" xml:space="preserve">
          <source>flowlint</source>
          <target state="translated">flowlint</target>
        </trans-unit>
        <trans-unit id="1ae5604c6b19edcfc16e8a0c46ddf12d0f3961dd" translate="yes" xml:space="preserve">
          <source>flowlint-line</source>
          <target state="translated">flowlint-line</target>
        </trans-unit>
        <trans-unit id="d424129af5ff1e8c17f038e5baf6afdeaa7378ab" translate="yes" xml:space="preserve">
          <source>flowlint-next-line</source>
          <target state="translated">flowlint-next-line</target>
        </trans-unit>
        <trans-unit id="9523c342f10c383dc3724202de645481a80652c5" translate="yes" xml:space="preserve">
          <source>if you want control at an even finer level than you get from the line-based comments.</source>
          <target state="translated">如果你想得到比行式注释更精细的控制。</target>
        </trans-unit>
        <trans-unit id="ec606816757167e05f48d162279dba3e8be72530" translate="yes" xml:space="preserve">
          <source>is an alias for React.AbstractComponent&amp;lt;Config, any&amp;gt;, which represents a component with config type Config and any instance type.</source>
          <target state="translated">是React.AbstractComponent &amp;lt;Config，any&amp;gt;的别名，该别名表示配置类型为Config且任何实例类型的组件。</target>
        </trans-unit>
        <trans-unit id="069f84bc5a9db81934e7d45531980b8b2dda9222" translate="yes" xml:space="preserve">
          <source>is treated as having type &lt;code&gt;Array&amp;lt;t1 | t2&amp;gt;&lt;/code&gt;, where &lt;code&gt;e1&lt;/code&gt; and &lt;code&gt;e2&lt;/code&gt; have types &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt;, instead of the tuple type &lt;code&gt;[t1, t2]&lt;/code&gt;.</source>
          <target state="translated">被视为类型为 &lt;code&gt;Array&amp;lt;t1 | t2&amp;gt;&lt;/code&gt; ，其中 &lt;code&gt;e1&lt;/code&gt; 和 &lt;code&gt;e2&lt;/code&gt; 具有类型 &lt;code&gt;t1&lt;/code&gt; 和 &lt;code&gt;t2&lt;/code&gt; ，而不是元组类型 &lt;code&gt;[t1, t2]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e56b448d5548cfe9ad70cc70da30a02c7890ea87" translate="yes" xml:space="preserve">
          <source>or by annotating the exported constant (&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBjWA7AzgF1AQwE764CeoAvKANoDku1ANKNQEbUC6iApgB4AOs+HKkw4A5pzSd8AS2QBBQiQBcoBUWIAebDLSiAfOTyLiAOgC2uXgApc5A7gCUQA&quot;&gt;https://flow.org/try&lt;/a&gt;):</source>
          <target state="translated">或通过注释导出的常量（&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBjWA7AzgF1AQwE764CeoAvKANoDku1ANKNQEbUC6iApgB4AOs+HKkw4A5pzSd8AS2QBBQiQBcoBUWIAebDLSiAfOTyLiAOgC2uXgApc5A7gCUQA&quot;&gt;https://flow.org/try&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
        <trans-unit id="7a4bfa85ec41023a2a32b1cdf3f48b7562fdb4a7" translate="yes" xml:space="preserve">
          <source>ref functions</source>
          <target state="translated">参考功能</target>
        </trans-unit>
        <trans-unit id="2193165c31d2f4f8af241c9a8931a8b36a67d5d4" translate="yes" xml:space="preserve">
          <source>returns a number, when we pass in the value &lt;code&gt;&quot;number&quot;&lt;/code&gt;, and</source>
          <target state="translated">当我们传入值 &lt;code&gt;&quot;number&quot;&lt;/code&gt; ，返回一个数字，并且</target>
        </trans-unit>
        <trans-unit id="ac03e5cf9b7ed34c910a9d7e41d6ef0b28bee9d4" translate="yes" xml:space="preserve">
          <source>returns a string, when we pass in the value &lt;code&gt;&quot;string&quot;&lt;/code&gt;,</source>
          <target state="translated">当我们传入值 &lt;code&gt;&quot;string&quot;&lt;/code&gt; ，返回一个字符串，</target>
        </trans-unit>
        <trans-unit id="34f484f97d66326080e8ca936a1ad359ef6b4abc" translate="yes" xml:space="preserve">
          <source>returns any possible type (&lt;code&gt;mixed&lt;/code&gt;), when we pass in any other string.</source>
          <target state="translated">当我们传入任何其他字符串时，返回任何可能的类型（ &lt;code&gt;mixed&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="293bf85b0e8555f44772dd43c5b8cdf5ff5c89b9" translate="yes" xml:space="preserve">
          <source>the left-hand side of an &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; expression.</source>
          <target state="translated">&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 表达式的左侧。</target>
        </trans-unit>
        <trans-unit id="aca33d45708489b41473f878247540a6c340f31f" translate="yes" xml:space="preserve">
          <source>the parameter &lt;code&gt;x&lt;/code&gt; will be flagged as uncovered. Also, in practice, a strict criterion like this would be too noisy and rather expensive to compute on the fly.</source>
          <target state="translated">参数 &lt;code&gt;x&lt;/code&gt; 将被标记为uncovered。同样，在实践中，像这样的严格标准过于嘈杂，并且无法即时计算。</target>
        </trans-unit>
        <trans-unit id="9fc1ee20cda978df2390bc72489f853397097bc8" translate="yes" xml:space="preserve">
          <source>to encode the same condition, then the following refinement would fail</source>
          <target state="translated">编码相同的条件,那么下面的改进就会失败。</target>
        </trans-unit>
        <trans-unit id="1470003cc6f898cdf238607c6ab34328b293da93" translate="yes" xml:space="preserve">
          <source>vim-flow</source>
          <target state="translated">vim-flow</target>
        </trans-unit>
        <trans-unit id="2ad74a5e0937034a00b7730362af6b184bbbc385" translate="yes" xml:space="preserve">
          <source>vscode-flow-ide</source>
          <target state="translated">vscode-flow-ide</target>
        </trans-unit>
        <trans-unit id="7e30df14febfb74a504a9f7e0ea2a1f5f14e3450" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;file.txt&lt;/code&gt; contains a specific list of files to be transformed.</source>
          <target state="translated">其中 &lt;code&gt;file.txt&lt;/code&gt; 包含要转换的文件的特定列表。</target>
        </trans-unit>
        <trans-unit id="0cbdfb85ff349a0802c41f318988e156dfbc0529" translate="yes" xml:space="preserve">
          <source>where as you would otherwise need to export an alias in the &lt;code&gt;import typeof&lt;/code&gt; case</source>
          <target state="translated">在 &lt;code&gt;import typeof&lt;/code&gt; case的情况下，否则需要导出别名</target>
        </trans-unit>
        <trans-unit id="2c7d718acdeb4c28153f3554978db15557a7145c" translate="yes" xml:space="preserve">
          <source>where you&amp;rsquo;ll need to manually annotate the export with &lt;code&gt;{():void;x:number}&lt;/code&gt;, or assignments preceding the function definition</source>
          <target state="translated">在这里您需要使用 &lt;code&gt;{():void;x:number}&lt;/code&gt; 或函数定义之前的赋值手动注释导出</target>
        </trans-unit>
        <trans-unit id="bd186b6002ab463466be199db517792bf8202dbe" translate="yes" xml:space="preserve">
          <source>will match a comment like this:</source>
          <target state="translated">会匹配这样的评论。</target>
        </trans-unit>
        <trans-unit id="f9a9d8b1f4f99fe8e77aee03fea19f8d5c42d401" translate="yes" xml:space="preserve">
          <source>will only report export related errors in files under &lt;code&gt;dirA&lt;/code&gt; and &lt;code&gt;dirB&lt;/code&gt;. This option requires &lt;code&gt;well_formed_exports&lt;/code&gt; to be set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">仅报告 &lt;code&gt;dirA&lt;/code&gt; 和 &lt;code&gt;dirB&lt;/code&gt; 下文件中与导出相关的错误。此选项要求将 &lt;code&gt;well_formed_exports&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="703e35916510aa0709f422ccc116c890cd2d9aee" translate="yes" xml:space="preserve">
          <source>will report coverage statistics for each file under &lt;code&gt;dir/&lt;/code&gt;, as well as aggregate results.</source>
          <target state="translated">将在 &lt;code&gt;dir/&lt;/code&gt; 下报告每个文件的覆盖率统计信息以及汇总结果。</target>
        </trans-unit>
        <trans-unit id="dd8179879b4cc1b0a4e2ed32e13778f6df541014" translate="yes" xml:space="preserve">
          <source>would report no errors, but</source>
          <target state="translated">将不会报告任何错误,但</target>
        </trans-unit>
        <trans-unit id="cba826f3eaa4834a5baad670fcedb5ee1f1e012b" translate="yes" xml:space="preserve">
          <source>would still have a sketchy-null-number warning on line 3.</source>
          <target state="translated">仍然会在第3行有一个简略的空数警告。</target>
        </trans-unit>
        <trans-unit id="594bfb76f84b1b4ba073112718b87595f61a0b22" translate="yes" xml:space="preserve">
          <source>would still report a type incompatibility.</source>
          <target state="translated">仍然会报告类型不兼容。</target>
        </trans-unit>
        <trans-unit id="d75e67ce648cee2a5ca84dc314da13569be0152a" translate="yes" xml:space="preserve">
          <source>you can issue the following command</source>
          <target state="translated">您可以发出以下命令</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
