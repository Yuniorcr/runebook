<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="flow">
    <body>
      <group id="flow">
        <trans-unit id="f9287b3fad8f092d74f4ec6aadb5a29cf9ba2e63" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2013&amp;ndash;present Facebook Inc.</source>
          <target state="translated">&amp;copy;2013年至今Facebook Inc.。</target>
        </trans-unit>
        <trans-unit id="503a7ef34e5694be261272081a6d34cc44e0d368" translate="yes" xml:space="preserve">
          <source>(&lt;a href=&quot;https://flow.org/try/#0PQKgBAAgZgNg9gdzCYAoVAXAngBwKZgCCAxhgJZwB2YAvGKmGAD5gDe2+AXGAOSE8AaMDgCGWeCIAm3AM4YATmUoBzAL6MGzNhzzceAIUHCxE6WEoBXALYAjPPNUBudMGBgA8gGlUxKnLBQAIy0YAAUIqQUlNwk5FQAlLQAfGyaMghkGMQAFmERcZQAdDqJrJqMxCIyBHw83PJ4GBby1PlRhaLicFKFMHgqGNnOjBVVNYb1jc2tkVQdJt2SYADUYIEADMNgqqg7Lm4AcnAYHp5gFpS+Vlb9J1Bw8mD28g8yAISorr6U-lAATCFQuxcHghJ1TKoYrNKIkaCkyq5GOlMjkwiVUoiRpVqrx+JMmi1jF0en0BkNPm4sWNeBMwA0CdRwYsVmtNhTGDtEaogA&quot;&gt;https://flow.org/try&lt;/a&gt;)</source>
          <target state="translated">(&lt;a href=&quot;https://flow.org/try/#0PQKgBAAgZgNg9gdzCYAoVAXAngBwKZgCCAxhgJZwB2YAvGKmGAD5gDe2+AXGAOSE8AaMDgCGWeCIAm3AM4YATmUoBzAL6MGzNhzzceAIUHCxE6WEoBXALYAjPPNUBudMGBgA8gGlUxKnLBQAIy0YAAUIqQUlNwk5FQAlLQAfGyaMghkGMQAFmERcZQAdDqJrJqMxCIyBHw83PJ4GBby1PlRhaLicFKFMHgqGNnOjBVVNYb1jc2tkVQdJt2SYADUYIEADMNgqqg7Lm4AcnAYHp5gFpS+Vlb9J1Bw8mD28g8yAISorr6U-lAATCFQuxcHghJ1TKoYrNKIkaCkyq5GOlMjkwiVUoiRpVqrx+JMmi1jF0en0BkNPm4sWNeBMwA0CdRwYsVmtNhTGDtEaogA&quot;&gt;https://flow.org/try&lt;/a&gt;)</target>
        </trans-unit>
        <trans-unit id="eabf0a1897fda94c2e7ebc351cec25f06658c93f" translate="yes" xml:space="preserve">
          <source>(Example adapted from the &lt;a href=&quot;https://reacttraining.com/react-router/core/api/Route/children-func&quot;&gt;&lt;code&gt;react-router&lt;/code&gt; documentation&lt;/a&gt;.)</source>
          <target state="translated">（示例摘自&lt;a href=&quot;https://reacttraining.com/react-router/core/api/Route/children-func&quot;&gt; &lt;code&gt;react-router&lt;/code&gt; 文档&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="42553dcf511140edb9c7fe5b095d179ad3d34209" translate="yes" xml:space="preserve">
          <source>.flowconfig</source>
          <target state="translated">.flowconfig</target>
        </trans-unit>
        <trans-unit id="2a0c7002997e311437a0c70c2313661b929d09ce" translate="yes" xml:space="preserve">
          <source>.flowconfig [declarations]</source>
          <target state="translated">.flowconfig [声明]</target>
        </trans-unit>
        <trans-unit id="d3dd6ba8743bbd7b4542e5b7d98c01e397699462" translate="yes" xml:space="preserve">
          <source>.flowconfig [ignore]</source>
          <target state="translated">.flowconfig [忽略]</target>
        </trans-unit>
        <trans-unit id="4cd3ed66f9dc2ea1ae8c5970c30160743de16d59" translate="yes" xml:space="preserve">
          <source>.flowconfig [include]</source>
          <target state="translated">.flowconfig [包括]</target>
        </trans-unit>
        <trans-unit id="3ea7d542265be35c8d390fac59fd3922fa10029f" translate="yes" xml:space="preserve">
          <source>.flowconfig [libs]</source>
          <target state="translated">.flowconfig [库]</target>
        </trans-unit>
        <trans-unit id="c19cd00744af8fb6b750b055353a165de408ef34" translate="yes" xml:space="preserve">
          <source>.flowconfig [lints]</source>
          <target state="translated">.flowconfig [棉绒]</target>
        </trans-unit>
        <trans-unit id="2be99164d570a360166709ab948593a53e747ee5" translate="yes" xml:space="preserve">
          <source>.flowconfig [options]</source>
          <target state="translated">.flowconfig [选项]</target>
        </trans-unit>
        <trans-unit id="84e57eb03e551cd373c767c8c1b1d4e0b233bd32" translate="yes" xml:space="preserve">
          <source>.flowconfig [untyped]</source>
          <target state="translated">.flowconfig [无类型]</target>
        </trans-unit>
        <trans-unit id="6e95572239f9d638c63d382400d10b3a21062e5b" translate="yes" xml:space="preserve">
          <source>.flowconfig [version]</source>
          <target state="translated">.flowconfig [版本]</target>
        </trans-unit>
        <trans-unit id="f75dc1d3fd7cae440d82a0aa033937f60c951c83" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#toc-check-your-code&quot;&gt;Check your code&lt;/a&gt; for type errors.</source>
          <target state="translated">&lt;a href=&quot;#toc-check-your-code&quot;&gt;检查您的代码&lt;/a&gt;是否存在类型错误。</target>
        </trans-unit>
        <trans-unit id="8bab6e4eae9423dd12abe68c046f07b864298440" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#toc-initialize-your-project&quot;&gt;Initialize your project&lt;/a&gt; with &lt;code&gt;flow init&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#toc-initialize-your-project&quot;&gt;&lt;/a&gt;使用 &lt;code&gt;flow init&lt;/code&gt; 初始化您的项目。</target>
        </trans-unit>
        <trans-unit id="3d9e05645c42f52a6d394efa517892368a0d28c4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#toc-prepare-your-code-for-flow&quot;&gt;Determine&lt;/a&gt; which files Flow will monitor with &lt;code&gt;// @flow&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#toc-prepare-your-code-for-flow&quot;&gt;确定&lt;/a&gt; Flow将使用 &lt;code&gt;// @flow&lt;/code&gt; 监视哪些文件。</target>
        </trans-unit>
        <trans-unit id="336448ab183f9e44d80f92a10e044c594b5d94a9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#toc-write-flow-code&quot;&gt;Write Flow code&lt;/a&gt; for your project.</source>
          <target state="translated">&lt;a href=&quot;#toc-write-flow-code&quot;&gt;&lt;/a&gt;为您的项目编写流程代码。</target>
        </trans-unit>
        <trans-unit id="34cd8914987eabdf3008fb9dec6130b2e2a3a08a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt;&lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is a type that models React nested array data structure for children. &lt;code&gt;ReactNodeWithoutStrings&lt;/code&gt; uses &lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt;&lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; to be an arbitrarily nested array of null, boolean, or React elements.</source>
          <target state="translated">&lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt; &lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;是一种为子代建模React嵌套数组数据结构的类型。 &lt;code&gt;ReactNodeWithoutStrings&lt;/code&gt; 使用&lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt; &lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;作为null，布尔值或React元素的任意嵌套数组。</target>
        </trans-unit>
        <trans-unit id="e273fef233f652d4764944c36bc8e7d44f3499a9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../types#toc-react-element&quot;&gt;&lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt;&lt;/a&gt; is the type of a React element like &lt;code&gt;&amp;lt;div/&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;MyComponent/&amp;gt;&lt;/code&gt;. Notably elements are not the same as components!</source>
          <target state="translated">&lt;a href=&quot;../types#toc-react-element&quot;&gt; &lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt; &lt;/a&gt;是React元素的类型，例如 &lt;code&gt;&amp;lt;div/&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;MyComponent/&amp;gt;&lt;/code&gt; 。值得注意的是元素与组件不一样！</target>
        </trans-unit>
        <trans-unit id="0f4966d59ad6be431d4d59785410831a89f983b0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../types#toc-react-node&quot;&gt;&lt;code&gt;React.Node&lt;/code&gt;&lt;/a&gt; is the general type for children, but sometimes you might want to use &lt;a href=&quot;../types#toc-react-node&quot;&gt;&lt;code&gt;React.Node&lt;/code&gt;&lt;/a&gt; while excluding some primitives like strings and numbers. &lt;a href=&quot;http://facebook.github.io/react-native/docs/view.html&quot;&gt;The React Native &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; component&lt;/a&gt; does this, for example.</source>
          <target state="translated">&lt;a href=&quot;../types#toc-react-node&quot;&gt; &lt;code&gt;React.Node&lt;/code&gt; &lt;/a&gt;是孩子的通用类型，但是有时您可能想使用&lt;a href=&quot;../types#toc-react-node&quot;&gt; &lt;code&gt;React.Node&lt;/code&gt; ,&lt;/a&gt;同时排除一些原语，例如字符串和数字。&lt;a href=&quot;http://facebook.github.io/react-native/docs/view.html&quot;&gt;例如，React Native &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; 组件&lt;/a&gt;执行此操作。</target>
        </trans-unit>
        <trans-unit id="7cf7f34d3e52f3dec53af2db9a70edf0af8a23b0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://exploringjs.com/es6/ch_modules.html&quot;&gt;ES modules&lt;/a&gt; have two kinds of exports: A &lt;strong&gt;named&lt;/strong&gt; export and a &lt;strong&gt;default&lt;/strong&gt; export. Flow supports the ability to declare either or both of these kinds of exports within a &lt;code&gt;declare module&lt;/code&gt; body as follows:</source>
          <target state="translated">&lt;a href=&quot;http://exploringjs.com/es6/ch_modules.html&quot;&gt;ES模块&lt;/a&gt;具有两种导出：&lt;strong&gt;命名&lt;/strong&gt;导出和&lt;strong&gt;默认&lt;/strong&gt;导出。Flow支持在 &lt;code&gt;declare module&lt;/code&gt; 主体中声明这两种导出中的一种或两种的能力，如下所示：</target>
        </trans-unit>
        <trans-unit id="17c120254fa9c516a881da71a463bb260e63bcd7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://facebook.github.io/react-native/docs/tabbarios.html&quot;&gt;React Native&amp;rsquo;s &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; component&lt;/a&gt; only allows React element children and those elements &lt;em&gt;must&lt;/em&gt; have a component type of &lt;code&gt;&amp;lt;TabBarIOS.Item&amp;gt;&lt;/code&gt;. You are expected to use &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; like:</source>
          <target state="translated">&lt;a href=&quot;http://facebook.github.io/react-native/docs/tabbarios.html&quot;&gt;React Native的 &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; 组件&lt;/a&gt;仅允许React元素的子元素，并且这些元素&lt;em&gt;必须&lt;/em&gt;具有 &lt;code&gt;&amp;lt;TabBarIOS.Item&amp;gt;&lt;/code&gt; 的组件类型。您应该像下面这样使用 &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="cf8957393a72df26897385761d8aa21a45d75df4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://facebook.github.io/react-native/docs/view.html&quot;&gt;The React Native &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; component&lt;/a&gt; will allow any primitive value or any React element as its children. However, &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; does not allow strings or numbers as children! You could use &lt;a href=&quot;../types#toc-react-node&quot;&gt;&lt;code&gt;React.Node&lt;/code&gt;&lt;/a&gt; as the children type for &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt;, however &lt;a href=&quot;../types#toc-react-node&quot;&gt;&lt;code&gt;React.Node&lt;/code&gt;&lt;/a&gt; includes strings which we don&amp;rsquo;t want for &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt;. So we need to create our own type.</source>
          <target state="translated">&lt;a href=&quot;http://facebook.github.io/react-native/docs/view.html&quot;&gt;React Native &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; 组件&lt;/a&gt;将允许任何原始值或任何React元素作为其子级。但是， &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; 不允许将字符串或数字作为子项！您可以使用&lt;a href=&quot;../types#toc-react-node&quot;&gt; &lt;code&gt;React.Node&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; 的子类型，但是&lt;a href=&quot;../types#toc-react-node&quot;&gt; &lt;code&gt;React.Node&lt;/code&gt; &lt;/a&gt;包含我们不希望用于 &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; 的字符串。因此，我们需要创建自己的类型。</target>
        </trans-unit>
        <trans-unit id="ad2498aaf0a179d73775581b93f384fe069a1601" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://frantic.im/using-redux-with-flow&quot;&gt;Using Redux with Flow&lt;/a&gt; - Alex Kotliarskyi</source>
          <target state="translated">&lt;a href=&quot;http://frantic.im/using-redux-with-flow&quot;&gt;将Redux与Flow结合使用&lt;/a&gt; -Alex Kotliarskyi</target>
        </trans-unit>
        <trans-unit id="8449c031ca7fc8f782a895f5de5db0cd2312f7ea" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://redux.js.org&quot;&gt;Redux&lt;/a&gt; has three major parts that should be typed:</source>
          <target state="translated">&lt;a href=&quot;http://redux.js.org&quot;&gt;Redux&lt;/a&gt;包含三个主要部分：</target>
        </trans-unit>
        <trans-unit id="d778c6db4ed26b14b4bcc87859b7232d009a05a6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://redux.js.org/docs/basics/Reducers.html&quot;&gt;Reducers&lt;/a&gt; take the state and actions that we&amp;rsquo;ve typed and pulls them together for one method.</source>
          <target state="translated">&lt;a href=&quot;http://redux.js.org/docs/basics/Reducers.html&quot;&gt;减速器&lt;/a&gt;采用我们输入的状态和动作，并将它们组合在一起作为一种方法。</target>
        </trans-unit>
        <trans-unit id="1e1a716310cc261310c0720a3defabf948f65c71" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://atom.io/packages/autocomplete-flow&quot;&gt;autocomplete-flow&lt;/a&gt; is another purpose-built tool that only does one thing. This package, as the name suggests, will give your flow enabled code autocomplete suggestions and nothing else.</source>
          <target state="translated">&lt;a href=&quot;https://atom.io/packages/autocomplete-flow&quot;&gt;自动完成流程&lt;/a&gt;是另一种专门做的工具，只能做一件事。顾名思义，此软件包将为您的启用流程的代码提供自动完成建议，而没有其他任何建议。</target>
        </trans-unit>
        <trans-unit id="70aa1aa8e107ff621d1e0476ca9e4b0d1b64169e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://atom.io/packages/flow-ide&quot;&gt;Flow-IDE&lt;/a&gt; is a smaller package that only provides you with a linter and autocomplete functionality. It, too, currently lacks support for on-the-fly linting.</source>
          <target state="translated">&lt;a href=&quot;https://atom.io/packages/flow-ide&quot;&gt;Flow-IDE&lt;/a&gt;是一个较小的程序包，仅向您提供lint和自动完成功能。目前，它也缺乏对即时棉绒的支持。</target>
        </trans-unit>
        <trans-unit id="f28025c94df4bd4e067f5342e62bb2bdd9bb61de" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://atom.io/packages/ide-flowtype&quot;&gt;Flow for Atom IDE&lt;/a&gt; is extracted from &lt;a href=&quot;https://nuclide.io&quot;&gt;Nuclide&lt;/a&gt;, and works with the &lt;a href=&quot;https://ide.atom.io/&quot;&gt;Atom IDE&lt;/a&gt; UI. It brings the core features you expect in a full-featured IDE into Atom, such as language-aware autocomplete, diagnostics, go-to-definition, type hints, and symbol outlines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ef7fc7d336d051de3c6fc08efe1aa750a6c3fd1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://atom.io/packages/ide-flowtype&quot;&gt;Flow for Atom IDE&lt;/a&gt; is extracted from Nuclide, and works with the &lt;a href=&quot;https://ide.atom.io/&quot;&gt;Atom IDE&lt;/a&gt; UI. It brings the core features you expect in a full-featured IDE into Atom, such as language-aware autocomplete, diagnostics, go-to-definition, type hints, and symbol outlines.</source>
          <target state="translated">&lt;a href=&quot;https://atom.io/packages/ide-flowtype&quot;&gt;Atom IDE的流程&lt;/a&gt;是从Nuclide中提取的，并与&lt;a href=&quot;https://ide.atom.io/&quot;&gt;Atom IDE&lt;/a&gt; UI一起使用。它将您希望在功能齐全的IDE中获得的核心功能带入Atom，例如可感知语言的自动完成功能，诊断功能，定义目标，类型提示和符号轮廓。</target>
        </trans-unit>
        <trans-unit id="f392cb41c6c533748c908f516d743440fc3fc957" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;Visual Studio Code&lt;/a&gt; has several editor integrations for using Flow.</source>
          <target state="translated">&lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;Visual Studio Code&lt;/a&gt;具有多个使用Flow的编辑器集成。</target>
        </trans-unit>
        <trans-unit id="3f30e103a4115c80055634733b0aa13e5b344c45" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://facebook.github.io/watchman/&quot;&gt;Watchman&lt;/a&gt; must be installed and the &lt;code&gt;watchman&lt;/code&gt; binary must be in the PATH.</source>
          <target state="translated">&lt;a href=&quot;https://facebook.github.io/watchman/&quot;&gt;守望者&lt;/a&gt;必须安装和 &lt;code&gt;watchman&lt;/code&gt; 二进制文件必须在PATH中。</target>
        </trans-unit>
        <trans-unit id="f963c3075e23bb3cf6001267bae91bbb9c401ba6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-nonstrict-import&quot;&gt;&lt;code&gt;nonstrict-import&lt;/code&gt;&lt;/a&gt;: Triggers an error when importing from a module which is not also &lt;code&gt;@flow strict&lt;/code&gt;. This is very important, because it means that when a file is marked as strict, all of its dependencies are strict as well.</source>
          <target state="translated">&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-nonstrict-import&quot;&gt; &lt;code&gt;nonstrict-import&lt;/code&gt; &lt;/a&gt;：从也不是 &lt;code&gt;@flow strict&lt;/code&gt; 的模块导入时触发错误。这非常重要，因为这意味着当文件标记为严格时，其所有依赖项也都严格。</target>
        </trans-unit>
        <trans-unit id="23dc038c2ecb0a3dd5d8efa5dc006412b7663f59" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-sketchy-null&quot;&gt;&lt;code&gt;sketchy-null&lt;/code&gt;&lt;/a&gt;: Triggers an error when doing an existence check on a value that could be null/undefined or falsey.</source>
          <target state="translated">&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-sketchy-null&quot;&gt; &lt;code&gt;sketchy-null&lt;/code&gt; &lt;/a&gt;：在对可能为null / undefined或falsey的值进行存在性检查时触发错误。</target>
        </trans-unit>
        <trans-unit id="56b2dc1b2d6f50b7b575c022bf5062e97e364ce7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-unclear-type&quot;&gt;&lt;code&gt;unclear-type&lt;/code&gt;&lt;/a&gt;: Triggers an error when using &lt;code&gt;Object&lt;/code&gt;, &lt;code&gt;Function&lt;/code&gt;, or &lt;code&gt;any&lt;/code&gt; in a type annotation.</source>
          <target state="translated">&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-unclear-type&quot;&gt; &lt;code&gt;unclear-type&lt;/code&gt; &lt;/a&gt;：在使用 &lt;code&gt;Object&lt;/code&gt; ， &lt;code&gt;Function&lt;/code&gt; 或类型注释中的 &lt;code&gt;any&lt;/code&gt; 类型时触发错误。</target>
        </trans-unit>
        <trans-unit id="acccc45b43c76d68c5b6f5a5cb4efb4873e9f331" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-unsafe-getters-setters&quot;&gt;&lt;code&gt;unsafe-getters-setters&lt;/code&gt;&lt;/a&gt;: Triggers an error when using getters and setters, which can be unsafe.</source>
          <target state="translated">&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-unsafe-getters-setters&quot;&gt; &lt;code&gt;unsafe-getters-setters&lt;/code&gt; &lt;/a&gt;：使用getter和setter时会触发错误，这可能是不安全的。</target>
        </trans-unit>
        <trans-unit id="50e62738926445ab80ca91b62a51deef77f07c6d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-untyped-import&quot;&gt;&lt;code&gt;untyped-import&lt;/code&gt;&lt;/a&gt;: Triggers an error when importing from an untyped module.</source>
          <target state="translated">&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-untyped-import&quot;&gt; &lt;code&gt;untyped-import&lt;/code&gt; &lt;/a&gt;：从无类型模块导入时触发错误。</target>
        </trans-unit>
        <trans-unit id="d428c85916fe38ed4c6c020088009c38838b5b26" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-untyped-type-import&quot;&gt;&lt;code&gt;untyped-type-import&lt;/code&gt;&lt;/a&gt;: Triggers an error when importing a type from an untyped module.</source>
          <target state="translated">&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-untyped-type-import&quot;&gt; &lt;code&gt;untyped-type-import&lt;/code&gt; &lt;/a&gt;：从非类型化模块导入类型时触发错误。</target>
        </trans-unit>
        <trans-unit id="8f07b8879f1946951cbf77557ef11a9915432823" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://flow.org/en/types/objects/#toc-exact-object-types&quot;&gt;Exact object types&lt;/a&gt; disable width subtyping, and do not allow additional properties to exist.</source>
          <target state="translated">&lt;a href=&quot;https://flow.org/en/types/objects/#toc-exact-object-types&quot;&gt;确切的对象类型将&lt;/a&gt;禁用宽度子类型，并且不允许存在其他属性。</target>
        </trans-unit>
        <trans-unit id="8a4bdbb0a8e0346c9734fd8517bb3446a477d3c4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/facebook/flow/tree/master/packages/flow-remove-types&quot;&gt;&lt;code&gt;flow-remove-types&lt;/code&gt;&lt;/a&gt; is a small CLI tool for stripping Flow type annotations from files. It&amp;rsquo;s a lighter-weight alternative to Babel for projects that don&amp;rsquo;t need everything Babel provides.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bb6540eba761465bf65a5ccdd99346953e691d3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt; already supports Flow by default. All you need to do is &lt;a href=&quot;https://flow.org/en/install/&quot;&gt;install Flow&lt;/a&gt; and create a &lt;code&gt;.flowconfig&lt;/code&gt; file by running &lt;code&gt;flow init&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;&lt;/a&gt;默认情况下，Create React App已经支持Flow。您所需要做的就是&lt;a href=&quot;https://flow.org/en/install/&quot;&gt;安装Flow&lt;/a&gt;并通过运行 &lt;code&gt;flow init&lt;/code&gt; 创建一个 &lt;code&gt;.flowconfig&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="5375300eb5712965cf5fc5cb3cf56433133be9cb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/flowtype/flow-remove-types&quot;&gt;&lt;code&gt;flow-remove-types&lt;/code&gt;&lt;/a&gt; is a small CLI tool for stripping Flow type annotations from files. It&amp;rsquo;s a lighter-weight alternative to Babel for projects that don&amp;rsquo;t need everything Babel provides.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/flowtype/flow-remove-types&quot;&gt; &lt;code&gt;flow-remove-types&lt;/code&gt; &lt;/a&gt;是一个小型CLI工具，用于从文件中剥离Flow类型注释。对于不需要Babel提供的所有项目的项目，它是Babel的轻巧替代品。</target>
        </trans-unit>
        <trans-unit id="518c67db26b37e0a41e20d16b7df11d4b116b8cb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/neoclide/coc.nvim&quot;&gt;Coc&lt;/a&gt; is an intellisense engine for vim8 &amp;amp; neovim.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/neoclide/coc.nvim&quot;&gt;Coc&lt;/a&gt;是vim8和neovim的智能感知引擎。</target>
        </trans-unit>
        <trans-unit id="79e9310832926dd892f262feeb40312198e89414" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=flowtype.flow-for-vscode&quot;&gt;Flow Language Support&lt;/a&gt; provides all the functionality you would expect &amp;mdash; linting, intellisense, type tooltips and click-to-definition. It&amp;rsquo;s stable and under active development.</source>
          <target state="translated">&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=flowtype.flow-for-vscode&quot;&gt;流语言支持&lt;/a&gt;提供了您期望的所有功能-整理，智能感知，键入工具提示和单击定义。它稳定且正在积极发展中。</target>
        </trans-unit>
        <trans-unit id="7c85b0e7dccf1df1c9799d9517b8f07ae7d48726" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://medium.com/@cdebotton/redux-and-flowtype-69ff1dd09036#.fsrm1amlk&quot;&gt;Redux and Flowtype&lt;/a&gt; - Christian de Botton</source>
          <target state="translated">&lt;a href=&quot;https://medium.com/@cdebotton/redux-and-flowtype-69ff1dd09036#.fsrm1amlk&quot;&gt;Redux和Flowtype&lt;/a&gt; -Christian de Botton</target>
        </trans-unit>
        <trans-unit id="cb7e5873e62fe999f5738f9368ddb0246bf2dec0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://medium.com/flow-type/on-the-roadmap-exact-objects-by-default-16b72933c5cf&quot;&gt;Flow is planning to make object types exact by default&lt;/a&gt;. This is available via an &lt;a href=&quot;https://flow.org/en/config/options/#toc-exact-by-default-boolean&quot;&gt;option in your flowconfig&lt;/a&gt;. You can also read our &lt;a href=&quot;https://medium.com/flow-type/how-to-upgrade-to-exact-by-default-object-type-syntax-7aa44b4d08ab&quot;&gt;upgrade guide&lt;/a&gt; for steps to enable this option in your own project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2bbb899b8c317c50fa7f4bf67ae90e51c42f496" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://nuclide.io&quot;&gt;Nuclide&lt;/a&gt; is a full IDE created by people at Facebook that has support for Flow built-in. It provides a linter, autocomplete and type coverage support, click-to-definition and type description on hover.</source>
          <target state="translated">&lt;a href=&quot;https://nuclide.io&quot;&gt;Nuclide&lt;/a&gt;是由Facebook员工创建的完整IDE，具有对内置Flow的支持。它提供了liner，自动完成和类型覆盖支持，悬停式单击定义和类型描述。</target>
        </trans-unit>
        <trans-unit id="9706104248435c91942f7078e78f2cbaa21d2931" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.sublimetext.com/&quot;&gt;Sublime Text&lt;/a&gt; can be integrated with Flow by using &lt;a href=&quot;https://packagecontrol.io&quot;&gt;Package Control&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.sublimetext.com/&quot;&gt;Sublime Text&lt;/a&gt;可通过使用&lt;a href=&quot;https://packagecontrol.io&quot;&gt;Package Control&lt;/a&gt;与Flow集成</target>
        </trans-unit>
        <trans-unit id="832311cb20bd2c6c6484e62e8e290372fda23e34" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;tools/babel&quot;&gt; &lt;h3&gt; Babel &lt;/h3&gt; &lt;p&gt; Learn how to use Flow with Babel &lt;/p&gt; &lt;/a&gt;&lt;a href=&quot;tools/flow-remove-types&quot;&gt; &lt;h3&gt; flow-remove-types &lt;/h3&gt; &lt;p&gt; Learn how to use Flow with flow-remove-types &lt;/p&gt; &lt;/a&gt;&lt;a href=&quot;tools/create-react-app&quot;&gt; &lt;h3&gt; Create React App &lt;/h3&gt; &lt;p&gt; Learn how to use Flow with Create React App &lt;/p&gt; &lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;tools/babel&quot;&gt; &lt;h3&gt; 巴别塔 &lt;/h3&gt; &lt;p&gt; 了解如何与Babel一起使用Flow &lt;/p&gt; &lt;/a&gt;&lt;a href=&quot;tools/flow-remove-types&quot;&gt; &lt;h3&gt; 流量去除类型 &lt;/h3&gt; &lt;p&gt; 了解如何将Flow与流量去除类型一起使用 &lt;/p&gt; &lt;/a&gt;&lt;a href=&quot;tools/create-react-app&quot;&gt; &lt;h3&gt; 创建React应用 &lt;/h3&gt; &lt;p&gt; 了解如何将Flow与Create React App一起使用 &lt;/p&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0d3edbcd8340616b98a8bb730d5f2bfb4883db8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$Call&amp;lt;F, T...&amp;gt;&lt;/code&gt; is a type that represents the result of calling the given &lt;a href=&quot;../functions&quot;&gt;function type&lt;/a&gt;&lt;code&gt;F&lt;/code&gt; with 0 or more arguments &lt;code&gt;T...&lt;/code&gt;. This is analogous to calling a function at runtime (or more specifically, it&amp;rsquo;s analogous to calling &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call&quot;&gt;&lt;code&gt;Function.prototype.call&lt;/code&gt;&lt;/a&gt;), but at the type level; this means that function type calls happens statically, i.e. not at runtime.</source>
          <target state="translated">&lt;code&gt;$Call&amp;lt;F, T...&amp;gt;&lt;/code&gt; 是表示使用0个或多个参数 &lt;code&gt;T...&lt;/code&gt; 调用给定&lt;a href=&quot;../functions&quot;&gt;函数类型&lt;/a&gt; &lt;code&gt;F&lt;/code&gt; 的结果的类型。这类似于在运行时调用函数（或更具体地说，类似于调用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call&quot;&gt; &lt;code&gt;Function.prototype.call&lt;/code&gt; &lt;/a&gt;），但在类型级别；这意味着函数类型调用是静态发生的，即不是在运行时发生的。</target>
        </trans-unit>
        <trans-unit id="f2241c9b7c945bd4d93f1e03d981bbd35f587e2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$Call&lt;/code&gt; can be very powerful because it allows you to make calls in type-land that you would otherwise have to do at runtime. The type-land calls happen statically and will be erased at runtime.</source>
          <target state="translated">&lt;code&gt;$Call&lt;/code&gt; 可能非常强大，因为它使您可以在类型域中进行调用，而在运行时则必须这样做。类型域调用是静态发生的，将在运行时删除。</target>
        </trans-unit>
        <trans-unit id="9c25dd66acf1845fd7317530f17f429c5d475619" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$ElementType&amp;lt;T, K&amp;gt;&lt;/code&gt; is the type that represents the type of every element inside an &lt;a href=&quot;../arrays&quot;&gt;array&lt;/a&gt;, &lt;a href=&quot;../tuples&quot;&gt;tuple&lt;/a&gt; or &lt;a href=&quot;../objects&quot;&gt;object&lt;/a&gt; type &lt;code&gt;T&lt;/code&gt;, that matches the given &lt;em&gt;key&lt;/em&gt; type &lt;code&gt;K&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$ElementType&amp;lt;T, K&amp;gt;&lt;/code&gt; 是表示&lt;a href=&quot;../arrays&quot;&gt;数组&lt;/a&gt;，&lt;a href=&quot;../tuples&quot;&gt;元组&lt;/a&gt;或&lt;a href=&quot;../objects&quot;&gt;对象&lt;/a&gt;类型 &lt;code&gt;T&lt;/code&gt; 中与给定&lt;em&gt;键&lt;/em&gt;类型 &lt;code&gt;K&lt;/code&gt; 匹配的每个元素的类型的类型。</target>
        </trans-unit>
        <trans-unit id="508e7e8d64ef136cbb4051692a66a33f7f03d8bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$Exact&amp;lt;{name: string}&amp;gt;&lt;/code&gt; is a synonym for &lt;code&gt;{|name:string|}&lt;/code&gt; as in the &lt;a href=&quot;../objects#toc-exact-object-types&quot;&gt;Object documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;$Exact&amp;lt;{name: string}&amp;gt;&lt;/code&gt; 是 &lt;code&gt;{|name:string|}&lt;/code&gt; 的同义词，如&lt;a href=&quot;../objects#toc-exact-object-types&quot;&gt;Object文档中所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1f560c59c278bbced6c01735997cd392ca4dcce5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$NonMaybeType&amp;lt;T&amp;gt;&lt;/code&gt; converts a type &lt;code&gt;T&lt;/code&gt; to a non-maybe type. In other words, the values of &lt;code&gt;$NonMaybeType&amp;lt;T&amp;gt;&lt;/code&gt; are the values of &lt;code&gt;T&lt;/code&gt; except for &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$NonMaybeType&amp;lt;T&amp;gt;&lt;/code&gt; 将类型 &lt;code&gt;T&lt;/code&gt; 转换为非也许类型。换句话说， &lt;code&gt;$NonMaybeType&amp;lt;T&amp;gt;&lt;/code&gt; 的值是 &lt;code&gt;T&lt;/code&gt; 的值，但 &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 除外。</target>
        </trans-unit>
        <trans-unit id="af15b84204f891abb40fd24979cfba73a49edad8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$ReadOnly&amp;lt;T&amp;gt;&lt;/code&gt; is a type that represents the read-only version of a given &lt;a href=&quot;../objects&quot;&gt;object type&lt;/a&gt;&lt;code&gt;T&lt;/code&gt;. A read-only object type is an object type whose keys are all &lt;a href=&quot;../interfaces#toc-interface-property-variance-read-only-and-write-only&quot;&gt;read-only&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;$ReadOnly&amp;lt;T&amp;gt;&lt;/code&gt; 是一种表示给定&lt;a href=&quot;../objects&quot;&gt;对象类型&lt;/a&gt; &lt;code&gt;T&lt;/code&gt; 的只读版本的类型。只读对象类型是键均为&lt;a href=&quot;../interfaces#toc-interface-property-variance-read-only-and-write-only&quot;&gt;只读&lt;/a&gt;的对象类型。</target>
        </trans-unit>
        <trans-unit id="98b234ef2ba7237b91129403279d8a12d8b8a498" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$Rest&amp;lt;A, B&amp;gt;&lt;/code&gt; is the type that represents the runtime object rest operation, e.g.: &lt;code&gt;const {foo, ...rest} = obj&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are both &lt;a href=&quot;../objects&quot;&gt;object types&lt;/a&gt;. The resulting type from this operation will be an object type containing &lt;code&gt;A&lt;/code&gt;&amp;rsquo;s &lt;em&gt;own&lt;/em&gt; properties that are not &lt;em&gt;own&lt;/em&gt; properties in &lt;code&gt;B&lt;/code&gt;. In flow, we treat all properties on &lt;a href=&quot;(../objects#toc-exact-object-types)&quot;&gt;exact object types&lt;/a&gt; as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty&quot;&gt;own&lt;/a&gt;. In in-exact objects, a property may or may not be own.</source>
          <target state="translated">&lt;code&gt;$Rest&amp;lt;A, B&amp;gt;&lt;/code&gt; 是表示运行时对象其余操作的类型，例如： &lt;code&gt;const {foo, ...rest} = obj&lt;/code&gt; ，其中 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 均为&lt;a href=&quot;../objects&quot;&gt;对象类型&lt;/a&gt;。从该操作得到的类型将是包含对象类型 &lt;code&gt;A&lt;/code&gt; 的&lt;em&gt;自己的&lt;/em&gt;属性不属于&lt;em&gt;自己的&lt;/em&gt;在性能 &lt;code&gt;B&lt;/code&gt; 。在流中，我们将&lt;a href=&quot;(../objects#toc-exact-object-types)&quot;&gt;精确对象类型&lt;/a&gt;上的所有属性都视为&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty&quot;&gt;own&lt;/a&gt;。在不精确的对象中，属性可以是或可以不是。</target>
        </trans-unit>
        <trans-unit id="11d38cd28a6d48301fea97b23cce1c785bf2fa96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$Rest&amp;lt;A, B&amp;gt;&lt;/code&gt; is the type that represents the runtime object rest operation, e.g.: &lt;code&gt;const {foo, ...rest} = obj&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are both &lt;a href=&quot;../objects&quot;&gt;object types&lt;/a&gt;. The resulting type from this operation will be an object type containing &lt;code&gt;A&lt;/code&gt;&amp;rsquo;s &lt;em&gt;own&lt;/em&gt; properties that are not &lt;em&gt;own&lt;/em&gt; properties in &lt;code&gt;B&lt;/code&gt;. In flow, we treat all properties on &lt;a href=&quot;../objects#toc-exact-object-types&quot;&gt;exact object types&lt;/a&gt; as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty&quot;&gt;own&lt;/a&gt;. In in-exact objects, a property may or may not be own.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d802f2267a06e1a2022c679c8bde31819cb03ed1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$TupleMap&amp;lt;T, F&amp;gt;&lt;/code&gt; takes an iterable type &lt;code&gt;T&lt;/code&gt; (e.g.: &lt;a href=&quot;../tuples&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../arrays&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt;), and a &lt;a href=&quot;../functions&quot;&gt;function type&lt;/a&gt;&lt;code&gt;F&lt;/code&gt;, and returns the iterable type obtained by mapping the type of each value in the iterable with the provided function type &lt;code&gt;F&lt;/code&gt;. This is analogous to the Javascript function &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$TupleMap&amp;lt;T, F&amp;gt;&lt;/code&gt; 接受一个可迭代的类型 &lt;code&gt;T&lt;/code&gt; （例如：&lt;a href=&quot;../tuples&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../arrays&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt;）和一个&lt;a href=&quot;../functions&quot;&gt;函数类型&lt;/a&gt; &lt;code&gt;F&lt;/code&gt; ，并返回通过将可迭代的每个值的类型与提供的函数类型 &lt;code&gt;F&lt;/code&gt; 映射而获得的可迭代类型。这类似于Javascript函数 &lt;code&gt;map&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1f76db9419791028b16c53d50170a640dded7f72" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$Values&amp;lt;T&amp;gt;&lt;/code&gt; represents the union type of all the value types (not the values, but their &lt;em&gt;types&lt;/em&gt;!) of the enumerable properties in an &lt;a href=&quot;../objects&quot;&gt;Object Type&lt;/a&gt;&lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$Values&amp;lt;T&amp;gt;&lt;/code&gt; 表示&lt;a href=&quot;../objects&quot;&gt;对象类型&lt;/a&gt; &lt;code&gt;T&lt;/code&gt; 中所有可枚举属性的值类型（不是值，而是它们的&lt;em&gt;类型&lt;/em&gt;！）的并集类型。</target>
        </trans-unit>
        <trans-unit id="2594799d46ec0811bd7e6e9354b8cae3d1f1d6a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.flowconfig&lt;/code&gt; format</source>
          <target state="translated">&lt;code&gt;.flowconfig&lt;/code&gt; 格式</target>
        </trans-unit>
        <trans-unit id="2f61adc534681a552a76146f3a893058257fd34c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/path/to/root/&lt;/code&gt; (automatically included)</source>
          <target state="translated">&lt;code&gt;/path/to/root/&lt;/code&gt; （自动包含）</target>
        </trans-unit>
        <trans-unit id="4eb684af2fc8a1193252507702d321d75c5eef22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@flow strict-local&lt;/code&gt; is the same as &lt;code&gt;@flow strict&lt;/code&gt;, except it does not require its dependencies to also be strict (i.e. it is &amp;ldquo;locally&amp;rdquo; strict). It does not have a separate configuration: it uses the same configuration as Flow Strict, just without the &lt;code&gt;nonstrict-import&lt;/code&gt; rule.</source>
          <target state="translated">&lt;code&gt;@flow strict-local&lt;/code&gt; 与 &lt;code&gt;@flow strict&lt;/code&gt; 相同，不同之处在于它不需要也必须严格依赖（即&amp;ldquo;本地&amp;rdquo;严格）。它没有单独的配置：它使用与Flow Strict相同的配置，只是没有 &lt;code&gt;nonstrict-import&lt;/code&gt; 规则。</target>
        </trans-unit>
        <trans-unit id="8f9cde7197917421c3115f9339175348c4255a20" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Array&lt;/code&gt; Type</source>
          <target state="translated">&lt;code&gt;Array&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="a803aafb511370111befd33436b887e6bb708e91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Array&lt;/code&gt; Type Shorthand Syntax</source>
          <target state="translated">&lt;code&gt;Array&lt;/code&gt; 类型简写语法</target>
        </trans-unit>
        <trans-unit id="3331a137b8616e6d3a4d9711f6d95d677a4a97c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Function&lt;/code&gt; Type</source>
          <target state="translated">&lt;code&gt;Function&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="2cbf7e5430db7626ac9af791d16644934975cb21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ObjMap&amp;lt;T, F&amp;gt;&lt;/code&gt; takes an &lt;a href=&quot;../objects&quot;&gt;object type&lt;/a&gt;&lt;code&gt;T&lt;/code&gt;, and a &lt;a href=&quot;../functions&quot;&gt;function type&lt;/a&gt;&lt;code&gt;F&lt;/code&gt;, and returns the object type obtained by mapping the type of each value in the object with the provided function type &lt;code&gt;F&lt;/code&gt;. In other words, &lt;code&gt;$ObjMap&lt;/code&gt; will &lt;a href=&quot;#toc-call&quot;&gt;call&lt;/a&gt; (at the type level) the given function type &lt;code&gt;F&lt;/code&gt; for every property value type in &lt;code&gt;T&lt;/code&gt;, and return the resulting object type from those calls.</source>
          <target state="translated">&lt;code&gt;ObjMap&amp;lt;T, F&amp;gt;&lt;/code&gt; 接受&lt;a href=&quot;../objects&quot;&gt;对象类型&lt;/a&gt; &lt;code&gt;T&lt;/code&gt; 和&lt;a href=&quot;../functions&quot;&gt;函数类型&lt;/a&gt; &lt;code&gt;F&lt;/code&gt; ，并返回通过将对象中每个值的类型与提供的函数类型 &lt;code&gt;F&lt;/code&gt; 映射而获得的对象类型。换句话说， &lt;code&gt;$ObjMap&lt;/code&gt; 将为 &lt;code&gt;T&lt;/code&gt; 中的每个属性值类型&lt;a href=&quot;#toc-call&quot;&gt;调用&lt;/a&gt;（在类型级别）给定的函数类型 &lt;code&gt;F&lt;/code&gt; ，并从这些调用返回结果对象类型。</target>
        </trans-unit>
        <trans-unit id="681cf2b1552373c6dcf1f86ee33a93ff337de143" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ObjMapi&amp;lt;T, F&amp;gt;&lt;/code&gt; is similar to &lt;a href=&quot;#toc-objmap&quot;&gt;&lt;code&gt;ObjMap&amp;lt;T, F&amp;gt;&lt;/code&gt;&lt;/a&gt;. The difference is that function type &lt;code&gt;F&lt;/code&gt; will be &lt;a href=&quot;#toc-call&quot;&gt;called&lt;/a&gt; with both the key and value types of the elements of the object type &lt;code&gt;T&lt;/code&gt;, instead of just the value types. For example:</source>
          <target state="translated">&lt;code&gt;ObjMapi&amp;lt;T, F&amp;gt;&lt;/code&gt; 与&lt;a href=&quot;#toc-objmap&quot;&gt; &lt;code&gt;ObjMap&amp;lt;T, F&amp;gt;&lt;/code&gt; &lt;/a&gt;相似。不同之处在于，将同时使用对象类型 &lt;code&gt;T&lt;/code&gt; 的元素的键和值类型&lt;a href=&quot;#toc-call&quot;&gt;调用&lt;/a&gt;函数类型 &lt;code&gt;F&lt;/code&gt; ，而不仅仅是值类型。例如：</target>
        </trans-unit>
        <trans-unit id="767b77f7a41bfeed131973627af17f7e6faa58cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Object&lt;/code&gt; Type</source>
          <target state="translated">&lt;code&gt;Object&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="1544818dc3132ba28560d73844cabcd76ae68cc1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.AbstractComponent&amp;lt;Config, Instance&amp;gt;&lt;/code&gt; (v0.89.0+) represents a component with a config of type Config and instance of type Instance.</source>
          <target state="translated">&lt;code&gt;React.AbstractComponent&amp;lt;Config, Instance&amp;gt;&lt;/code&gt; （v0.89.0 +）表示一个组件，其配置类型为Config，实例类型为Instance。</target>
        </trans-unit>
        <trans-unit id="7a05b510244008460c777eeffe9a1d99b0b3f433" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.Component&amp;lt;Props, State&amp;gt;&lt;/code&gt; is a &lt;a href=&quot;https://flow.org/en/types/generics/&quot;&gt;generic type&lt;/a&gt; that takes two type arguments. Props and state. The second type argument, &lt;code&gt;State&lt;/code&gt;, is optional. By default it is undefined so you can see in the example above we did not include &lt;code&gt;State&lt;/code&gt;. We will learn more about state in the next section&amp;hellip;</source>
          <target state="translated">&lt;code&gt;React.Component&amp;lt;Props, State&amp;gt;&lt;/code&gt; 是一个带有两个类型参数的&lt;a href=&quot;https://flow.org/en/types/generics/&quot;&gt;泛型类型&lt;/a&gt;。道具和状态。第二个类型参数 &lt;code&gt;State&lt;/code&gt; 是可选的。默认情况下，它是未定义的，因此您可以在上面的示例中看到我们没有包含 &lt;code&gt;State&lt;/code&gt; 。我们将在下一部分中了解有关状态的更多信息...</target>
        </trans-unit>
        <trans-unit id="9230540e79b96189b0ea859004424e54a1e6f63f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.ComponentType&amp;lt;Props&amp;gt;&lt;/code&gt; does not include intrinsic JSX element types like &lt;code&gt;div&lt;/code&gt; or &lt;code&gt;span&lt;/code&gt;. See &lt;a href=&quot;#toc-react-elementtype&quot;&gt;&lt;code&gt;React.ElementType&lt;/code&gt;&lt;/a&gt; if you also want to include JSX intrinsics.</source>
          <target state="translated">&lt;code&gt;React.ComponentType&amp;lt;Props&amp;gt;&lt;/code&gt; 不包含诸如 &lt;code&gt;div&lt;/code&gt; 或 &lt;code&gt;span&lt;/code&gt; 之类的固有JSX元素类型。如果您还想包含JSX内部函数，请参见&lt;a href=&quot;#toc-react-elementtype&quot;&gt; &lt;code&gt;React.ElementType&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="58f1f75b8bcd9618953c69318f7620eb7b4295c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt; is also the return type of &lt;code&gt;React.createElement()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt; 也是 &lt;code&gt;React.createElement()&lt;/code&gt; 的返回类型。</target>
        </trans-unit>
        <trans-unit id="adc63cd1289ababfe9d45f2979b42f2a3e435bb8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SyntheticAnimationEvent&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent&quot;&gt;AnimationEvent&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;SyntheticAnimationEvent&amp;lt;T&amp;gt;&lt;/code&gt; 为&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent&quot;&gt;AnimationEvent&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c5e5304c53ff7a14b0db24ef11da3dbb99b2b14" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SyntheticCompositionEvent&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent&quot;&gt;CompositionEvent&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;SyntheticCompositionEvent&amp;lt;T&amp;gt;&lt;/code&gt; 为&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent&quot;&gt;CompositionEvent&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c96f9ac107f248ffac9f8626b279676bd8718958" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SyntheticDragEvent&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DragEvent&quot;&gt;DragEvent&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;SyntheticDragEvent&amp;lt;T&amp;gt;&lt;/code&gt; 用于&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DragEvent&quot;&gt;DragEvent的&lt;/a&gt;SyntheticDragEvent &amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="fa52bea770e564d49631a007def85a111217c029" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SyntheticEvent&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Event&quot;&gt;Event&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;SyntheticEvent&amp;lt;T&amp;gt;&lt;/code&gt; 用于&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Event&quot;&gt;事件的&lt;/a&gt;SyntheticEvent &amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="96c79f952aac07c545dc47e57d9d9cd7d49c791f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SyntheticFocusEvent&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent&quot;&gt;FocusEvent&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;SyntheticFocusEvent&amp;lt;T&amp;gt;&lt;/code&gt; 为&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent&quot;&gt;FocusEvent&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5996e654c7c893a828a52a8b60b3799f8e789a81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SyntheticInputEvent&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/InputEvent&quot;&gt;InputEvent&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;SyntheticInputEvent&amp;lt;T&amp;gt;&lt;/code&gt; 用于&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/InputEvent&quot;&gt;InputEvent的&lt;/a&gt;SyntheticInputEvent &amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="2026e5307092d1d6c43fff4a1ac451cb1d8596f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SyntheticKeyboardEvent&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent&quot;&gt;KeyboardEvent&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;SyntheticKeyboardEvent&amp;lt;T&amp;gt;&lt;/code&gt; 对&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent&quot;&gt;的KeyboardEvent&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e4fc35b5921c09e6284b8b4d64655b2075c7403d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SyntheticMouseEvent&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent&quot;&gt;MouseEvent&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;SyntheticMouseEvent&amp;lt;T&amp;gt;&lt;/code&gt; 对&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent&quot;&gt;的MouseEvent&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d8f969c201611aa63546668fd0d4a5fb4be56f6b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SyntheticTouchEvent&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent&quot;&gt;TouchEvent&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;SyntheticTouchEvent&amp;lt;T&amp;gt;&lt;/code&gt; 用于&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent&quot;&gt;TouchEvent的&lt;/a&gt;SyntheticTouchEvent &amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5392d56e034e56ed7cf9f986f6a8e54736cf46cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SyntheticTransitionEvent&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent&quot;&gt;TransitionEvent&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;SyntheticTransitionEvent&amp;lt;T&amp;gt;&lt;/code&gt; 用于&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent&quot;&gt;TransitionEvent的&lt;/a&gt;SyntheticTransitionEvent &amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="693da3b475fb277ea5f089a6fe5960e4093a8bf9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SyntheticUIEvent&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/UIEvent&quot;&gt;UIEvent&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;SyntheticUIEvent&amp;lt;T&amp;gt;&lt;/code&gt; 对&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/UIEvent&quot;&gt;的UIEvent&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="75c836ef8f10b19801a470eac5c6ed743d951e99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SyntheticWheelEvent&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent&quot;&gt;WheelEvent&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;SyntheticWheelEvent&amp;lt;T&amp;gt;&lt;/code&gt; 为&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent&quot;&gt;WheelEvent&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bd8d3fb84c2e2653143777ce2230d40aeb161b2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[untyped]&lt;/code&gt; instead causes a file to be ignored by the typechecker as if it had &lt;code&gt;noflow&lt;/code&gt; in it, resolve modules as &lt;code&gt;any&lt;/code&gt; typ, but allow them to NOT be ignored by the module resolver. Any matching file is skipped by Flow (not even parsed, like other &lt;code&gt;noflow&lt;/code&gt; files!), but can still be &lt;code&gt;require()&lt;/code&gt;&amp;lsquo;d.</source>
          <target state="translated">&lt;code&gt;[untyped]&lt;/code&gt; ，而不是导致文件被typechecker被忽略，因为如果它有 &lt;code&gt;noflow&lt;/code&gt; 在里面，决心模块， &lt;code&gt;any&lt;/code&gt; 典型值，但是允许他们不是模块解析器被忽略。Flow会跳过任何匹配的文件（甚至不会像其他 &lt;code&gt;noflow&lt;/code&gt; 文件一样被解析！），但是仍然可以使用 &lt;code&gt;require()&lt;/code&gt; 'd。</target>
        </trans-unit>
        <trans-unit id="dd57cedd3baab0b1d89a09756ce2f7feb6611846" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[untyped]&lt;/code&gt; instead causes a file to be ignored by the typechecker as if it had &lt;code&gt;noflow&lt;/code&gt; in it, resolve modules as &lt;code&gt;any&lt;/code&gt; type, but allow them to NOT be ignored by the module resolver. Any matching file is skipped by Flow (not even parsed, like other &lt;code&gt;noflow&lt;/code&gt; files!), but can still be &lt;code&gt;require()&lt;/code&gt;&amp;lsquo;d.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4734a96ab71cb9256e40d7ef655d0b7aec2769d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;all&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;all&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9980c61e3e10b0171dab78805e509842f78d6bfd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;babel_loose_array_spread&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;babel_loose_array_spread&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9328c95d646b4ac7120c78217d7dabde5057c2d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; - declares a block-scoped variable, assigning a value that cannot be re-assigned. (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const&quot;&gt;MDN&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; -声明一个块作用域变量，分配一个无法重新分配的值。（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const&quot;&gt;MDN&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="c35bdf03258530159bd15512b8348c3d41d5a19d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; - variables that &lt;strong&gt;cannot&lt;/strong&gt; be reassigned.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; -&lt;strong&gt;无法&lt;/strong&gt;重新分配的变量。</target>
        </trans-unit>
        <trans-unit id="ec86decd5f7af51264833626096e4ddd7664c147" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;emoji&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;emoji&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="96920174b4323d8c30fdb2a3ec074673a3d14b1e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;esproposal.class_instance_fields&lt;/code&gt;&lt;em&gt;&lt;code&gt;(enable|ignore|warn)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;esproposal.class_instance_fields&lt;/code&gt;&lt;em&gt;&lt;code&gt;(enable|ignore|warn)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="171137be6be377f3d07f41d4691b38066b388d01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;esproposal.class_static_fields&lt;/code&gt;&lt;em&gt;&lt;code&gt;(enable|ignore|warn)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;esproposal.class_static_fields&lt;/code&gt;&lt;em&gt;&lt;code&gt;(enable|ignore|warn)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a9f45cd53162169474b7a6388eccd7f001dfae9f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;esproposal.decorators&lt;/code&gt;&lt;em&gt;&lt;code&gt;(ignore|warn)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;esproposal.decorators&lt;/code&gt;&lt;em&gt;&lt;code&gt;(ignore|warn)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="972a4a3dbe0f7550710ef309f72472fb16297ecb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;esproposal.export_star_as&lt;/code&gt;&lt;em&gt;&lt;code&gt;(enable|ignore|warn)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;esproposal.export_star_as&lt;/code&gt;&lt;em&gt;&lt;code&gt;(enable|ignore|warn)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="638056fd7e6c68417a3a146dfca7047b22c08d8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;esproposal.nullish_coalescing&lt;/code&gt;&lt;em&gt;&lt;code&gt;(enable|ignore|warn)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;esproposal.nullish_coalescing&lt;/code&gt;&lt;em&gt;&lt;code&gt;(enable|ignore|warn)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e869212f0b8e102de1941c727fdebe6d2a890181" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;esproposal.optional_chaining&lt;/code&gt;&lt;em&gt;&lt;code&gt;(enable|ignore|warn)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;esproposal.optional_chaining&lt;/code&gt;&lt;em&gt;&lt;code&gt;(enable|ignore|warn)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="93d7450678ff784f4a91b7939b3f1d2d0f196f78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exact_by_default&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;exact_by_default&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7f0b3658b2908fca30f69af8b284b05c29e2e0d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;experimental.const_params&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;experimental.const_params&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="42e3942bab511fa03988ce07bb75a9d0d7c74847" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f1&lt;/code&gt; can return a value that &lt;code&gt;FuncType&lt;/code&gt; never does, so code that relies on &lt;code&gt;FuncType&lt;/code&gt; might not be safe if &lt;code&gt;f1&lt;/code&gt; is used. Its type is not a subtype of &lt;code&gt;FuncType&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f1&lt;/code&gt; 可以返回 &lt;code&gt;FuncType&lt;/code&gt; 从不执行的值，因此，如果使用 &lt;code&gt;f1&lt;/code&gt; ,则依赖 &lt;code&gt;FuncType&lt;/code&gt; 的代码可能并不安全。它的类型不是 &lt;code&gt;FuncType&lt;/code&gt; 的子类型。</target>
        </trans-unit>
        <trans-unit id="726638e0c45c973078425c1f460e13663c6df9ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f2&lt;/code&gt; can&amp;rsquo;t handle all the argument values that &lt;code&gt;FuncType&lt;/code&gt; does, so code that relies on &lt;code&gt;FuncType&lt;/code&gt; can&amp;rsquo;t safely use &lt;code&gt;f2&lt;/code&gt;. Its type is also not a subtype of &lt;code&gt;FuncType&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f2&lt;/code&gt; 不能处理 &lt;code&gt;FuncType&lt;/code&gt; 可以处理的所有参数值，因此依赖 &lt;code&gt;FuncType&lt;/code&gt; 的代码不能安全地使用 &lt;code&gt;f2&lt;/code&gt; 。它的类型也不是 &lt;code&gt;FuncType&lt;/code&gt; 的子类型。</target>
        </trans-unit>
        <trans-unit id="5400ddcebeeba38d292672ea4e21ae521f4c3c92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f3&lt;/code&gt; can accept all the argument values that &lt;code&gt;FuncType&lt;/code&gt; does, and only returns values that &lt;code&gt;FuncType&lt;/code&gt; does, so its type is a subtype of &lt;code&gt;FuncType&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f3&lt;/code&gt; 可以接受 &lt;code&gt;FuncType&lt;/code&gt; 所做的所有参数值，并且仅返回 &lt;code&gt;FuncType&lt;/code&gt; 所做的值，因此其类型是 &lt;code&gt;FuncType&lt;/code&gt; 的子类型。</target>
        </trans-unit>
        <trans-unit id="0aae29a82fc10cee61f896dcf30eeebb3766c146" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flowlint-next-line&lt;/code&gt; works the same as &lt;code&gt;flowlint-line&lt;/code&gt;, except it applies its settings to the next line instead of the current line:</source>
          <target state="translated">&lt;code&gt;flowlint-next-line&lt;/code&gt; 与 &lt;code&gt;flowlint-line&lt;/code&gt; 相同，不同之处在于它将设置应用于下一行而不是当前行：</target>
        </trans-unit>
        <trans-unit id="a48e34cc7b299416a8e2b7ea16e6d555b35b2019" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;include_warnings&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;include_warnings&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6d8ddac7ae75b7a8f7db9fd921f2cf55bd4b2c66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lazy_mode&lt;/code&gt;&lt;em&gt;&lt;code&gt;(fs|ide|watchman|none)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;lazy_mode&lt;/code&gt;&lt;em&gt;&lt;code&gt;(fs|ide|watchman|none)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="336c7ba3afe701528a0e2b671be4925b95c96b3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; - declares a block-scoped variable, optionally assigning a value. (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let&quot;&gt;MDN&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; -声明一个块范围的变量，任选分配值。（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let&quot;&gt;MDN&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="447b3a2dddaad4f848e312d7d33f3c96c59892d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;var&lt;/code&gt; - variables that &lt;strong&gt;can&lt;/strong&gt; be reassigned.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;var&lt;/code&gt; -&lt;strong&gt;可以&lt;/strong&gt;重新分配的变量。</target>
        </trans-unit>
        <trans-unit id="da67888b6c142ef501bff7964e43c869c753300c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log.file&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;log.file&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="10b72cfa901df08cc8fe7be85a5ce76b92d3830e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_header_tokens&lt;/code&gt;&lt;em&gt;&lt;code&gt;(integer)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;max_header_tokens&lt;/code&gt;&lt;em&gt;&lt;code&gt;(integer)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c7127e551c98174c6634c2da74d89fefc7432f7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mixed&lt;/code&gt; will accept any type of value. Strings, numbers, objects, functions&amp;ndash; anything will work.</source>
          <target state="translated">&lt;code&gt;mixed&lt;/code&gt; 将接受任何类型的值。字符串，数字，对象，函数-任何东西都可以使用。</target>
        </trans-unit>
        <trans-unit id="51164f8b8016f0d8abcae69123c2523293287daa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module.file_ext&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;module.file_ext&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8bd5bc2f73b98906fb7419179328c69ef4d9e356" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module.ignore_non_literal_requires&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;module.ignore_non_literal_requires&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0fa5897539c2a2f8f6f118e08172c4bc433245c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module.name_mapper.extension&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string -&amp;gt; string)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;module.name_mapper.extension&lt;/code&gt; &lt;em&gt; &lt;code&gt;(string -&amp;gt; string)&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="695be517c6a87b361f0a94a84ee335146ea99233" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module.name_mapper&lt;/code&gt;&lt;em&gt;&lt;code&gt;(regex -&amp;gt; string)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;module.name_mapper&lt;/code&gt; &lt;em&gt; &lt;code&gt;(regex -&amp;gt; string)&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f6d453a4f39af3bbcc8e866a62bb026e067f3ccf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module.system.node.main_field&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;module.system.node.main_field&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a2b55b3985b54cfcb20f350998122314d8f82eca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module.system.node.resolve_dirname&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;module.system.node.resolve_dirname&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b3917f0b66e443088994451f0883b66faaf5a2a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module.system&lt;/code&gt;&lt;em&gt;&lt;code&gt;(node|haste)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;module.system&lt;/code&gt;&lt;em&gt;&lt;code&gt;(node|haste)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ac108e4226f0003b79c994c5e9872aae99cf04e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module.use_strict&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;module.use_strict&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e3c7cf33182d09b184a1acd84332f6a07f1a0cdc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;munge_underscores&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;munge_underscores&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ee2c2db77365d69cc88bb148e9b038199c9e52b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;no_flowlib&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;no_flowlib&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aec71172404443d710062cd2dbcdb5a433b974cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;null&lt;/code&gt; and &lt;code&gt;void&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;void&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a59ea58ab1aea5c130c466795049be1f9aaf0803" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;null&lt;/code&gt; and &lt;code&gt;void&lt;/code&gt; also appear in other types.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;void&lt;/code&gt; 也以其他类型出现。</target>
        </trans-unit>
        <trans-unit id="e8c9111ee40b4a3593b8970efac417f8ac70f84d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react-router&lt;/code&gt; version 4 asks for a &lt;a href=&quot;https://reacttraining.com/react-router/core/api/Route/children-func&quot;&gt;function as the children to its &lt;code&gt;&amp;lt;Route&amp;gt;&lt;/code&gt; component&lt;/a&gt;. You would provide a function as the children to &lt;code&gt;react-router&lt;/code&gt; like this:</source>
          <target state="translated">&lt;code&gt;react-router&lt;/code&gt; 版本4要求一个&lt;a href=&quot;https://reacttraining.com/react-router/core/api/Route/children-func&quot;&gt;功能作为其 &lt;code&gt;&amp;lt;Route&amp;gt;&lt;/code&gt; 组件的子代&lt;/a&gt;。您可以像下面这样提供一个功能作为 &lt;code&gt;react-router&lt;/code&gt; 的子代：</target>
        </trans-unit>
        <trans-unit id="10b2ec4f9ce546a42982c7000e3310b849ac0bf6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react.runtime&lt;/code&gt;&lt;em&gt;&lt;code&gt;(automatic|classic)&lt;/code&gt;&lt;/em&gt;&amp;ge;0.123.0</source>
          <target state="translated">&lt;code&gt;react.runtime&lt;/code&gt;&lt;em&gt;&lt;code&gt;(automatic|classic)&lt;/code&gt;&lt;/em&gt;&amp;ge;0.123.0</target>
        </trans-unit>
        <trans-unit id="0094d54f0f90d0220f6da062cdc9c6ae6eae5fe8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;server.max_workers&lt;/code&gt;&lt;em&gt;&lt;code&gt;(integer)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;server.max_workers&lt;/code&gt;&lt;em&gt;&lt;code&gt;(integer)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f189fba493378458484495c789f0c1fe55185671" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sharedmemory.dirs&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;sharedmemory.dirs&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="57b914d6e4aade39e538cecd6f22441853012d68" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sharedmemory.hash_table_pow&lt;/code&gt;&lt;em&gt;&lt;code&gt;(unsigned integer)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;sharedmemory.hash_table_pow&lt;/code&gt; &lt;em&gt; &lt;code&gt;(unsigned integer)&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e5bb5de55179a3c1994c86e08d6ba8959cf26035" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sharedmemory.heap_size&lt;/code&gt;&lt;em&gt;&lt;code&gt;(unsigned integer)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;sharedmemory.heap_size&lt;/code&gt; &lt;em&gt; &lt;code&gt;(unsigned integer)&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="feb32a4afd21311d7f593b3de1374f83ef370676" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sharedmemory.log_level&lt;/code&gt;&lt;em&gt;&lt;code&gt;(unsigned integer)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;sharedmemory.log_level&lt;/code&gt; &lt;em&gt; &lt;code&gt;(unsigned integer)&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5afdf22d252e5f159714f331f56a1183c8db4629" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sharedmemory.minimum_available&lt;/code&gt;&lt;em&gt;&lt;code&gt;(unsigned integer)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;sharedmemory.minimum_available&lt;/code&gt; &lt;em&gt; &lt;code&gt;(unsigned integer)&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6af14e5c0d4307ffde1e14ef7590be5942e679aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strip_root&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;&amp;le;0.48</source>
          <target state="translated">&lt;code&gt;strip_root&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;&amp;le;0.48</target>
        </trans-unit>
        <trans-unit id="b7056b5cc505c600e004961cb933f9821121eb2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;suppress_comment&lt;/code&gt;&lt;em&gt;&lt;code&gt;(regex)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;suppress_comment&lt;/code&gt;&lt;em&gt;&lt;code&gt;(regex)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="74a35624022ce338b663a64d371c4d915190a754" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;suppress_comment&lt;/code&gt;&lt;em&gt;&lt;code&gt;(regex)&lt;/code&gt;&lt;/em&gt;&amp;le;0.126</source>
          <target state="translated">&lt;code&gt;suppress_comment&lt;/code&gt;&lt;em&gt;&lt;code&gt;(regex)&lt;/code&gt;&lt;/em&gt;&amp;le;0.126</target>
        </trans-unit>
        <trans-unit id="72b91edcfd78ab9e6e183d55d0e45a396ff7018c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;suppress_type&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;suppress_type&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e8ad04f97245289d4e39fc158bdfbcdf56d0bf99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;temp_dir&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;temp_dir&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c0eca817f39a368fc9aa5bd8f12866ffd32eaa21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;traces&lt;/code&gt;&lt;em&gt;&lt;code&gt;(integer)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;traces&lt;/code&gt;&lt;em&gt;&lt;code&gt;(integer)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c75e6afcf9d83a43fbddc117b5707c6525bca25f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typeof Component&lt;/code&gt; can also be your React class component or stateless functional component.</source>
          <target state="translated">&lt;code&gt;typeof Component&lt;/code&gt; 也可以是您的React类组件或无状态功能组件。</target>
        </trans-unit>
        <trans-unit id="e11876a8dc567e2d922f662f5f89f99f143a6ebc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typeof&lt;/code&gt; inherits behaviors of inference</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; 继承推理行为</target>
        </trans-unit>
        <trans-unit id="eb1cf1f4297c1b2ae089f4080f05438696aa41b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typeof&lt;/code&gt; inherits behaviors of other types</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; 继承其他类型的行为</target>
        </trans-unit>
        <trans-unit id="8bc3bf8b12c02f9c49ba612a2afbc618a8714ac2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typeof&lt;/code&gt; type syntax</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; 类型语法</target>
        </trans-unit>
        <trans-unit id="b1b97f80cd34472a653238df084f1ef89d7716b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;types_first&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;&amp;ge;0.125.0</source>
          <target state="translated">&lt;code&gt;types_first&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;&amp;ge;0.125.0</target>
        </trans-unit>
        <trans-unit id="e9340dc40167bf2df1900dd5ff09de7ee451b582" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;undefined&lt;/code&gt; (&lt;code&gt;void&lt;/code&gt; in Flow types)</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; （在Flow类型中为 &lt;code&gt;void&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="e10bde5813a41a4b1af5888a4a46a6bbc121f9a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; - declares a variable, optionally assigning a value. (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var&quot;&gt;MDN&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; -声明一个变量，可以选择分配一个值。（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var&quot;&gt;MDN&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="3849f1997a58ce69bfb01dd3b43d461870cc5bea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; ， &lt;code&gt;let&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f4795a23dab3efdea98276a8557f04a9c2df93e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;well_formed_exports.includes&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;&amp;ge;0.128.0</source>
          <target state="translated">&lt;code&gt;well_formed_exports.includes&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;&amp;ge;0.128.0</target>
        </trans-unit>
        <trans-unit id="9fa5ec242b5843745a7337208914fbc4494f1be2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;well_formed_exports&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;&amp;ge;0.125.0</source>
          <target state="translated">&lt;code&gt;well_formed_exports&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;&amp;ge;0.125.0</target>
        </trans-unit>
        <trans-unit id="618a581b65ff5f5e5889511d3cd080ab05886f03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;exports.js&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;exports.js&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5b33f07a5ba2608771292c96cae619e974a5fb21" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;imports.js&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;imports.js&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2656931fc434aca0157a011d0d37c9e6f677adfb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Classes&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Classes&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f4be936250abf866d7156093839a04de7c1cd2b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Don&amp;rsquo;t forget to mention &lt;code&gt;@flow&lt;/code&gt; on top of file, otherwise flow won&amp;rsquo;t report errors&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;不要忘记在文件顶部提到 &lt;code&gt;@flow&lt;/code&gt; ，否则flow不会报告错误&lt;/em&gt;&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="4284c426f28b28ecfd869ea4f96a80f7f8690134" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Interfaces&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Interfaces&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f17253c245d87ac973fc5293b5a15ab24ab8bdc2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Type Aliases&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;类型别名&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cbe8982c76a4cc7f7e9adfc12449f681674cbb61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;You should follow &lt;a href=&quot;../any&quot;&gt;all the same rules&lt;/a&gt; as &lt;code&gt;any&lt;/code&gt; when using &lt;code&gt;Function&lt;/code&gt;.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;您应该按照&lt;a href=&quot;../any&quot;&gt;所有相同的规则&lt;/a&gt;为 &lt;code&gt;any&lt;/code&gt; 使用时 &lt;code&gt;Function&lt;/code&gt; 。&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a2811438566c8ce65b8a6941e70fbece78eceaa1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A group of different possible types:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;一组不同的可能类型：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae678a78ebebf05c595f0cdf9e9e80e85d991358" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A single type:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;单一类型：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e53a0237f152f0b316bc97b2fc063f3efa825e84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A type based on another type:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;基于另一种类型的类型：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d99a25c652d8cfb74b77ae022021f7dccc449527" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;An arbitrary type that could be anything:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;任意类型，可以是任何东西：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="17486ec505dad1463a8b0dc8465986bb70f1e04b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Dependency files&lt;/strong&gt;. These are the files which are needed in order to typecheck the focused or dependent files.</source>
          <target state="translated">&lt;strong&gt;依赖文件&lt;/strong&gt;。这些是对重点文件或从属文件进行类型检查所需的文件。</target>
        </trans-unit>
        <trans-unit id="348b0bbf82732cfba30377f2a246a2d29c935065" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Dependent files&lt;/strong&gt;. These are the files which depend on the focused files. Changes to the focused files might cause type errors in the dependent files.</source>
          <target state="translated">&lt;strong&gt;相关文件&lt;/strong&gt;。这些是依赖于重点文件的文件。对重点文件的更改可能会导致从属文件中的类型错误。</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2881ee068ac6090c9feffed65593bbb03cba2056" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Filesystem lazy mode&lt;/strong&gt;. Flow treats any file which has changed on the filesystem as focused. This mode is easier to use from the commandline, but a rebase can make every file appear focused.</source>
          <target state="translated">&lt;strong&gt;文件系统惰性模式&lt;/strong&gt;。Flow将文件系统上已更改的任何文件视为已聚焦。从命令行可以更轻松地使用此模式，但是重新设置基础可以使每个文件显得集中。</target>
        </trans-unit>
        <trans-unit id="4d1871c2ba972fbc1e0adeb69045b60c7b76dcb5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Focused files&lt;/strong&gt;. These are the files which the user cares about.</source>
          <target state="translated">&lt;strong&gt;重点文件&lt;/strong&gt;。这些是用户关心的文件。</target>
        </trans-unit>
        <trans-unit id="4c72412e2b545e519f06a9eb3fbf56d6fbd15299" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;IDE lazy mode&lt;/strong&gt;. The IDE tells Flow which files have been opened and closed via &lt;code&gt;flow lsp&lt;/code&gt;. Flow treats any file which has ever been opened since the Flow server started as focused.</source>
          <target state="translated">&lt;strong&gt;IDE惰性模式&lt;/strong&gt;。IDE通过 &lt;code&gt;flow lsp&lt;/code&gt; 告诉Flow哪些文件已打开和关闭。Flow将自Flow服务器启动以来一直打开的任何文件视为已聚焦。</target>
        </trans-unit>
        <trans-unit id="4a2bb6782e12dafbea5a42ed08ba22dd8335a4a6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Arrays are also sometimes used as tuples in JavaScript, these are annotated differently in Flow. See the Tuple docs for more information.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;数组有时在JavaScript中也用作元组，它们在Flow中的注释方式不同。有关更多信息，请参见Tuple文档。</target>
        </trans-unit>
        <trans-unit id="d0c839a0690df63ac56fe1bed5a7b464ba8c43db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Because &lt;a href=&quot;#toc-react-elementprops&quot;&gt;&lt;code&gt;React.ElementProps&lt;/code&gt;&lt;/a&gt; does not preserve the optionality of &lt;code&gt;defaultProps&lt;/code&gt;, &lt;a href=&quot;#toc-react-elementconfig&quot;&gt;&lt;code&gt;React.ElementConfig&lt;/code&gt;&lt;/a&gt; (which does) is more often the right choice, especially for simple props pass-through as with &lt;a href=&quot;../hoc#toc-supporting-defaultprops-with-react-elementconfig&quot;&gt;higher-order components&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;因为&lt;a href=&quot;#toc-react-elementprops&quot;&gt; &lt;code&gt;React.ElementProps&lt;/code&gt; &lt;/a&gt;不会保留 &lt;code&gt;defaultProps&lt;/code&gt; 的可选性，&lt;a href=&quot;#toc-react-elementconfig&quot;&gt; &lt;code&gt;React.ElementConfig&lt;/code&gt; &lt;/a&gt;（确实如此）通常是正确的选择，尤其是对于简单的道具传递（如&lt;a href=&quot;../hoc#toc-supporting-defaultprops-with-react-elementconfig&quot;&gt;高阶组件）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7fab5833ac1b21ea7a10d50df5d9bc2a182d5de9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If you don&amp;rsquo;t need to use the &lt;code&gt;Props&lt;/code&gt; type again you could also define it inline: &lt;code&gt;extends React.Component&amp;lt;{ foo: number, bar?: string }&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;如果不需要再次使用 &lt;code&gt;Props&lt;/code&gt; 类型，则也可以内联定义： &lt;code&gt;extends React.Component&amp;lt;{ foo: number, bar?: string }&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d95a1829d723b06d07fce08d5fc4c83da0c5b2f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If you don&amp;rsquo;t need to use the &lt;code&gt;State&lt;/code&gt; type again you could also define it inline: &lt;code&gt;extends React.Component&amp;lt;{}, { count: number }&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;如果您不需要再次使用 &lt;code&gt;State&lt;/code&gt; 类型，则也可以内联定义： &lt;code&gt;extends React.Component&amp;lt;{}, { count: number }&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="45fe059278697f2928479023e38c3ab10a142464" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If you want methods like &lt;code&gt;map()&lt;/code&gt; and &lt;code&gt;forEach()&lt;/code&gt; or to handle a &lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt;&lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; as a normal JavaScript array then React provides the &lt;a href=&quot;https://facebook.github.io/react/docs/react-api.html#react.children&quot;&gt;&lt;code&gt;React.Children&lt;/code&gt; API&lt;/a&gt; to do just this. It has functions like &lt;code&gt;React.Children.toArray(props.children)&lt;/code&gt; that you can use to treat your &lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt;&lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; as a flat array.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;如果要使用诸如 &lt;code&gt;map()&lt;/code&gt; 和 &lt;code&gt;forEach()&lt;/code&gt; 之类的方法,或者将&lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt; &lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;作为普通的JavaScript数组进行处理，则React会提供&lt;a href=&quot;https://facebook.github.io/react/docs/react-api.html#react.children&quot;&gt; &lt;code&gt;React.Children&lt;/code&gt; API&lt;/a&gt;来实现此目的。它具有 &lt;code&gt;React.Children.toArray(props.children)&lt;/code&gt; 之类的函数，可用于将&lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt; &lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;视为平面数组。</target>
        </trans-unit>
        <trans-unit id="981e303e077480a1b13e37cfcb658e9d478c6764" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If you want to use optional function parameters you&amp;rsquo;ll need to use the include comment form.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;如果要使用可选的函数参数，则需要使用包含注释表单。</target>
        </trans-unit>
        <trans-unit id="7d43ad66341153296b7a88ebc68288f393965e36" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; In 0.89.0+, React.ComponentType</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;在0.89.0+中，React.ComponentType</target>
        </trans-unit>
        <trans-unit id="981f48c806b7228b573613afe0482ea462d5a88a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; In version v0.127.0, the option to specify the suppression comment syntax was removed. &lt;code&gt;$FlowFixMe&lt;/code&gt;, &lt;code&gt;$FlowIssue&lt;/code&gt;, &lt;code&gt;$FlowExpectedError&lt;/code&gt;, and &lt;code&gt;$FlowIgnore&lt;/code&gt; became the only standard suppressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7417850e8b9171bcdaf44485d8c88475bdf0d461" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Previously object types used semicolons &lt;code&gt;;&lt;/code&gt; for splitting name-value pairs. While the syntax is still valid, you should use commas &lt;code&gt;,&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;以前的对象类型使用分号 &lt;code&gt;;&lt;/code&gt; 用于拆分名称/值对。在语法仍然有效的同时，您应该使用逗号 &lt;code&gt;,&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87767fc2be8bc1d1db6ace0faafec6c1caffc4b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; React uses its own event system so it is important to use the &lt;code&gt;SyntheticEvent&lt;/code&gt; types instead of the DOM types such as &lt;code&gt;Event&lt;/code&gt;, &lt;code&gt;KeyboardEvent&lt;/code&gt;, and &lt;code&gt;MouseEvent&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt; React使用自己的事件系统，因此使用 &lt;code&gt;SyntheticEvent&lt;/code&gt; 类型而不是诸如 &lt;code&gt;Event&lt;/code&gt; ， &lt;code&gt;KeyboardEvent&lt;/code&gt; 和 &lt;code&gt;MouseEvent&lt;/code&gt; 之类的DOM类型非常重要。</target>
        </trans-unit>
        <trans-unit id="8f2bf27d4821a0d74e94cf2b6f04fa28b458b80e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The &lt;code&gt;*variantOf&lt;/code&gt; types below are not a part of Flow, they are being used to explain variance.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;以下 &lt;code&gt;*variantOf&lt;/code&gt; 类型不是Flow的一部分，它们用于解释方差。</target>
        </trans-unit>
        <trans-unit id="102f82e83d1493ee86dfa63526c074eb08db5191" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The parentheses are necessary to avoid ambiguity with other syntax.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;括号是必要的，以避免与其他语法产生歧义。</target>
        </trans-unit>
        <trans-unit id="7f324099a923e249d53f34a12f3516e9e72c0142" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This is because of &lt;a href=&quot;https://flow.org/en/lang/width-subtyping/&quot;&gt;&amp;ldquo;width subtyping&amp;rdquo;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;这是因为&lt;a href=&quot;https://flow.org/en/lang/width-subtyping/&quot;&gt;&amp;ldquo;宽度子类型化&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="50be581c452b3e6bead6ab798ba2bb803100f906" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This is just shorthand for &lt;code&gt;module.name_mapper='^\(.*\)\.EXTENSION$' -&amp;gt; 'TEMPLATE'&lt;/code&gt;)</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;这只是 &lt;code&gt;module.name_mapper='^\(.*\)\.EXTENSION$' -&amp;gt; 'TEMPLATE'&lt;/code&gt; 简写）</target>
        </trans-unit>
        <trans-unit id="beb96f00dcbfc7e17127978d7b2257796cddaa5e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This is not the proper solution to the above problem, it was being used for demonstration only. The correct solution is annotating the function like this:</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;这不是解决上述问题的正确方法，仅用于演示。正确的解决方案是对这样的函数进行注释：</target>
        </trans-unit>
        <trans-unit id="eaf59b7f203d1ba63f5e98b4e246170ccb103da4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; To get the element instance, like &lt;code&gt;HTMLButtonElement&lt;/code&gt; in the example above, it is a common mistake to use &lt;code&gt;event.target&lt;/code&gt; instead of &lt;code&gt;event.currentTarget&lt;/code&gt;. The reason why you want to use &lt;code&gt;event.currentTarget&lt;/code&gt; is that &lt;code&gt;event.target&lt;/code&gt; may be the wrong element due to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Examples#Example_5:_Event_Propagation&quot;&gt;event propagation&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;要获取元素实例，例如上 &lt;code&gt;HTMLButtonElement&lt;/code&gt; 中的HTMLButtonElement，使用 &lt;code&gt;event.target&lt;/code&gt; 而不是 &lt;code&gt;event.currentTarget&lt;/code&gt; 是一个常见错误。之所以要使用 &lt;code&gt;event.currentTarget&lt;/code&gt; 是因为由于&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Examples#Example_5:_Event_Propagation&quot;&gt;事件传播&lt;/a&gt;， &lt;code&gt;event.target&lt;/code&gt; 可能是错误的元素。</target>
        </trans-unit>
        <trans-unit id="51bb4c125cd4418ed706f35e265efaf1c78dea88" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Typing context values requires Flow 0.70 or later.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;键入上下文值需要Flow 0.70或更高版本。</target>
        </trans-unit>
        <trans-unit id="0963a4d340e3fcd46ba3fd94010ce7b45a5555b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Watch out for comments! Take the following:</source>
          <target state="translated">&lt;strong&gt;注意：请注意&lt;/strong&gt;评论！采取以下措施：</target>
        </trans-unit>
        <trans-unit id="c19727e7a33fbaf5adc662298c963e80689873d3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Watch out for whitespace! Take the following:</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;注意空格！采取以下措施：</target>
        </trans-unit>
        <trans-unit id="cdf1510cc13fa0938c540a829729b695b1f7fe47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; We import &lt;code&gt;React&lt;/code&gt; as a namespace here with &lt;code&gt;import * as React from 'react'&lt;/code&gt; instead of as a default with &lt;code&gt;import React from 'react'&lt;/code&gt;. When importing React as an ES module you may use either style, but importing as a namespace gives you access to React&amp;rsquo;s &lt;a href=&quot;../types&quot;&gt;utility types&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;我们在这里将 &lt;code&gt;React&lt;/code&gt; 作为名称空间 &lt;code&gt;import * as React from 'react'&lt;/code&gt; ，而import *是'react'的React，而不是默认的 &lt;code&gt;import React from 'react'&lt;/code&gt; 。在将React作为ES模块导入时，您可以使用任何一种样式，但是作为命名空间导入可以使您访问React的&lt;a href=&quot;../types&quot;&gt;工具类型&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5ec9e52dafaf04b0fca35e642b34088ae3ccf8ca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; We&amp;rsquo;re going to go through a stripped down example for demonstrating how to make use of type cast expressions. This example is not solved well in practice.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;我们将通过一个简化的示例来演示如何使用类型强制转换表达式。这个例子在实践中不能很好地解决。</target>
        </trans-unit>
        <trans-unit id="efca69a7365214cc560454bf531e712df56be690" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; When it comes to objects, the order-specific way in which intersection types are implemented in Flow, may often seem counterintuitive from a set theoretic point of view. In sets, the operands of intersection can change order arbitrarily (commutative property). For this reason, it is a better practice to define this kind of operation over object types using the &lt;em&gt;spread&lt;/em&gt; operator, e.g. &lt;code&gt;{...One,...Two}&lt;/code&gt;, where the ordering semantics are better specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13714a09cafc3db44b0f21e686d8c767ffcc7bcb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; While importing React with a default import works:</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;在使用默认导入功能导入React时：</target>
        </trans-unit>
        <trans-unit id="66a1c90af7e35b36d5177b1f056c71e3827448ea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You can specify &lt;code&gt;module.name_mapper.extension&lt;/code&gt; multiple times for different extensions.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;您可以为不同的扩展名多次指定 &lt;code&gt;module.name_mapper.extension&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e953a25a8164a088aa27a99871bd1034fa4f7aa5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You can specify &lt;code&gt;sharedmemory.dirs&lt;/code&gt; multiple times.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;您可以多次指定 &lt;code&gt;sharedmemory.dirs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cad40a5701acf5649fe5798b08c924b1a91443a6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You can specify &lt;code&gt;suppress_comment&lt;/code&gt; multiple times. If you do define any &lt;code&gt;suppress_comment&lt;/code&gt;s, the built-in &lt;code&gt;$FlowFixMe&lt;/code&gt; suppression will be erased in favor of the regexps you specify. If you wish to use &lt;code&gt;$FlowFixMe&lt;/code&gt; with some additional custom suppression comments, you must manually specify &lt;code&gt;\\(.\\|\n\\)*\\$FlowFixMe&lt;/code&gt; in your custom list of suppressions.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;您可以多次指定 &lt;code&gt;suppress_comment&lt;/code&gt; 。如果你定义任何 &lt;code&gt;suppress_comment&lt;/code&gt; S，内置 &lt;code&gt;$FlowFixMe&lt;/code&gt; 抑制将有利于您指定的正则表达式中被删除。如果希望将 &lt;code&gt;$FlowFixMe&lt;/code&gt; 与一些其他自定义抑制注释一起使用，则必须在自定义抑制列表中手动指定 &lt;code&gt;\\(.\\|\n\\)*\\$FlowFixMe&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3ef30213691916dbfdadddd670829ca29768fca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You can specify &lt;code&gt;suppress_type&lt;/code&gt; multiple times.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;您可以多次指定 &lt;code&gt;suppress_type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="229ab2d563e326e0866c16c2ecaf54037d4f3e62" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You don&amp;rsquo;t need to make &lt;code&gt;foo&lt;/code&gt; nullable in your &lt;code&gt;Props&lt;/code&gt; type. Flow will make sure that &lt;code&gt;foo&lt;/code&gt; is optional if you have a default prop for &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;您不需要在 &lt;code&gt;Props&lt;/code&gt; 类型中使 &lt;code&gt;foo&lt;/code&gt; 可为空。如果您具有 &lt;code&gt;foo&lt;/code&gt; 的默认属性，那么Flow将确保 &lt;code&gt;foo&lt;/code&gt; 是可选的。</target>
        </trans-unit>
        <trans-unit id="a8dbdf0ca4a737e620de55f8736bb8082cbf733a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You need to use &lt;code&gt;import * as React from 'react'&lt;/code&gt; here instead of &lt;code&gt;import React from 'react'&lt;/code&gt; to get access to the &lt;a href=&quot;../types#toc-react-node&quot;&gt;&lt;code&gt;React.Node&lt;/code&gt;&lt;/a&gt; type. We explain why that is in the &lt;a href=&quot;../types&quot;&gt;React Type Reference&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：这里&lt;/strong&gt;需要使用 &lt;code&gt;import * as React from 'react'&lt;/code&gt; 的 &lt;code&gt;import React from 'react'&lt;/code&gt; 而不是从'react'导入React来访问&lt;a href=&quot;../types#toc-react-node&quot;&gt; &lt;code&gt;React.Node&lt;/code&gt; &lt;/a&gt;类型。我们在&lt;a href=&quot;../types&quot;&gt;React Type Reference中&lt;/a&gt;解释为什么会这样。</target>
        </trans-unit>
        <trans-unit id="e4e73965c0849c76958d2605758705535cf6dda6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You&amp;rsquo;ll probably want to add a &lt;code&gt;prepublish&lt;/code&gt; script that runs this transform as well, so that it runs before you publish your code to the npm registry.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;您可能需要添加一个 &lt;code&gt;prepublish&lt;/code&gt; 脚本，该脚本也要运行此转换，以便在将代码发布到npm注册表之前运行。</target>
        </trans-unit>
        <trans-unit id="d0d8dc4eae5a24d3928bd38400456f9cbe5313d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; you can specify &lt;code&gt;module.file_ext&lt;/code&gt; multiple times</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;您可以多次指定 &lt;code&gt;module.file_ext&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="277f1b76997cbec25e723aaaf5fe3c78b6b009ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; you can specify &lt;code&gt;module.name_mapper&lt;/code&gt; multiple times</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;您可以多次指定 &lt;code&gt;module.name_mapper&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0cf4d9235824eed02c46e2f1d98a8ce97a15b5b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; you can specify &lt;code&gt;module.system.node.resolve_dirname&lt;/code&gt; multiple times</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;您可以多次指定 &lt;code&gt;module.system.node.resolve_dirname&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd3867675ccb5b52461008d6e03fb348c8a53b40" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Special thanks to&lt;/strong&gt;: &lt;a href=&quot;https://github.com/jareware&quot;&gt;Jarno Rantanen&lt;/a&gt; for building &lt;a href=&quot;https://github.com/jareware/flotate&quot;&gt;flotate&lt;/a&gt; and supporting us merging his syntax upstream into Flow.</source>
          <target state="translated">&lt;strong&gt;特别感谢&lt;/strong&gt;：&lt;a href=&quot;https://github.com/jareware&quot;&gt;Jarno Rantanen&lt;/a&gt;构建了&lt;a href=&quot;https://github.com/jareware/flotate&quot;&gt;float&lt;/a&gt;并支持我们在上游将他的语法合并到Flow中。</target>
        </trans-unit>
        <trans-unit id="01a48fcac72977e1bf1c5fb03ed59c9380790e6f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Try to provide a libdef for each third-party library your project uses&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;尝试为项目使用的每个第三方库提供一个libdef&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f43a1aec0402c2b241ef1d914c61cefd59f011c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Unchecked files&lt;/strong&gt;. All other files.</source>
          <target state="translated">&lt;strong&gt;未检查的文件&lt;/strong&gt;。所有其他文件。</target>
        </trans-unit>
        <trans-unit id="a874bf28f6bc203a4ab83ee91607e029bb99dfcd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Do not mistake &lt;code&gt;any&lt;/code&gt; with &lt;code&gt;mixed&lt;/code&gt;. &lt;a href=&quot;../mixed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;不要搞错 &lt;code&gt;any&lt;/code&gt; 与 &lt;code&gt;mixed&lt;/code&gt; 。&lt;a href=&quot;../mixed&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8cc4bce83d85500a6f45865d989cce18fc4a43ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Flow does not infer generic types. If you want something to have a generic type, &lt;strong&gt;annotate it&lt;/strong&gt;. Otherwise, Flow may infer a type that is less polymorphic than you expect.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;流无法推断通用类型。如果您希望某些东西具有通用类型，请对其进行&lt;strong&gt;注释&lt;/strong&gt;。否则，Flow可能会推断出比您期望的少的多态类型。</target>
        </trans-unit>
        <trans-unit id="a280dc6a74b332873e229283e81f56eb6ccce4ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; For performance purposes, we always recommend you annotate with concrete arguments when you can. &lt;code&gt;_&lt;/code&gt; is not unsafe, but it is slower than explicitly specifying the type arguments.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;出于性能目的，我们始终建议您尽可能使用具体参数进行注释。 &lt;code&gt;_&lt;/code&gt; 不是不安全的，但是它比显式指定类型参数要慢。</target>
        </trans-unit>
        <trans-unit id="31f870561ad37a87582f2c7ee2fa8398d4fae0b2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Watchman lazy mode&lt;/strong&gt;. When starting up, Flow treats any file as focused if it has changed since the mergebase with master (the common ancestor of the current commit and the master branch). Any subsequent file that changes is also focused. After a rebase which changes the mergebase, Flow may restart the server if it estimates that a restart is faster than a recheck.</source>
          <target state="translated">&lt;strong&gt;守望者懒惰模式&lt;/strong&gt;。在启动时，如果文件与master合并（当前提交和master分支的共同祖先）以来发生更改，则Flow会将任何文件视为已聚焦。任何后续更改的文件也将被关注。在更改了合并基础的重新设置基准之后，如果Flow估计重新启动比重新检查更快，则Flow可以重新启动服务器。</target>
        </trans-unit>
        <trans-unit id="95b4924a0b182cfffbd184b94a6565475c510c1b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;error:&lt;/strong&gt; Lints with severity &lt;code&gt;error&lt;/code&gt; are treated exactly the same as any other Flow error.</source>
          <target state="translated">&lt;strong&gt;错误：&lt;/strong&gt;具有严重性 &lt;code&gt;error&lt;/code&gt; 皮棉将与任何其他&amp;ldquo;流量&amp;rdquo;错误完全一样地对待。</target>
        </trans-unit>
        <trans-unit id="1a03a729136b36f5838887b635904e593801ed41" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;flow-typed/myLibDef.js&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;flow-typed/myLibDef.js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e33c8943ab39266d98f3fccd3a3499ba35474f73" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;flow-typed/some-commonjs-module.js&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;flow-typed/some-commonjs-module.js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6bddb02bd60e0167f1a6757b72ddc9ab8cccab64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;flow-typed/some-es-module.js&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;flow-typed/some-es-module.js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3f98671d24b241f481d2118b0f7963a30771b5ea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;off:&lt;/strong&gt; The lint is ignored. Setting a lint to &lt;code&gt;off&lt;/code&gt; is similar to suppressing a type error with a suppression comment, except with much more granularity.</source>
          <target state="translated">&lt;strong&gt;off：&lt;/strong&gt;绒毛被忽略。将lint设置为 &lt;code&gt;off&lt;/code&gt; 类似于使用抑制注释来抑制类型错误，但粒度要大得多。</target>
        </trans-unit>
        <trans-unit id="d023c19a616c35ca9826c7a2ffac16870361f13d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;settings over a block of code:&lt;/strong&gt; A pair of &lt;code&gt;flowlint&lt;/code&gt; comments can be used to apply a certain setting over a block of code. For example, to disabling the untyped-type-import lint over a block of type imports would look like this:</source>
          <target state="translated">&lt;strong&gt;代码块上的设置：&lt;/strong&gt;可以使用一对 &lt;code&gt;flowlint&lt;/code&gt; 注释在代码块上应用特定设置。例如，要在类型导入块上禁用untyped-type-import棉绒，将如下所示：</target>
        </trans-unit>
        <trans-unit id="31146238339ea53d1542596a43e6ef00dc10cce7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;settings over a file:&lt;/strong&gt; A &lt;code&gt;flowlint&lt;/code&gt; comment doesn&amp;rsquo;t have to have a matching comment to form a block. An unmatched comment simply applies its settings to the rest of the file. You could use this, for example, to suppress all sketchy-null-check lints in a particular file:</source>
          <target state="translated">&lt;strong&gt;在文件设置：&lt;/strong&gt;一个 &lt;code&gt;flowlint&lt;/code&gt; 评论并不一定有一个匹配的注释，以形成一个块。无与伦比的注释只是将其设置应用于文件的其余部分。例如，您可以使用它来禁止显示特定文件中的所有sketch-null-check棉绒：</target>
        </trans-unit>
        <trans-unit id="fa2579b9e2d9cbad84fbd5f31d89ceb484a456f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;settings over part of a line:&lt;/strong&gt; The settings applied by &lt;code&gt;flowlint&lt;/code&gt; start and end right at the comment itself. This means that you can do things like</source>
          <target state="translated">&lt;strong&gt;行的一部分上&lt;/strong&gt;的设置&lt;strong&gt;：&lt;/strong&gt; &lt;code&gt;flowlint&lt;/code&gt; 应用的设置在注释本身处开始和结束。这意味着您可以做类似的事情</target>
        </trans-unit>
        <trans-unit id="feb7c9b56545cc3391e09e0d2b8bd5709fa97489" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;warn:&lt;/strong&gt; Warnings are a new severity level introduced by the linting framework. They are treated differently than errors in a couple of ways:</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;警告是Linting框架引入的新的严重性级别。在几种方面，它们与错误的区别在于：</target>
        </trans-unit>
        <trans-unit id="8f637424e74ed1ebcadcdbadc0c7f23a162bdc46" translate="yes" xml:space="preserve">
          <source>@flow - Parse this file with Flow syntax allowed and typecheck it.</source>
          <target state="translated">@flow-使用允许的Flow语法解析此文件并进行类型检查。</target>
        </trans-unit>
        <trans-unit id="dab817ff7a654e90ff5dd7173e93ea494624263b" translate="yes" xml:space="preserve">
          <source>@noflow - Parse this file with Flow syntax allowed and do not typecheck it. This is meant as an escape hatch to suppress Flow in a file without having to delete all the Flow-specific syntax.</source>
          <target state="translated">@noflow-使用允许的Flow语法解析此文件，并且不进行类型检查。这是为了避免文件中的Flow而不必删除所有特定于Flow的语法的转义填充。</target>
        </trans-unit>
        <trans-unit id="d5517ef60c8c970054ed9b5ae5d4d8803202583f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;$PropertyType&amp;lt;T, k&amp;gt;&lt;/code&gt; is the type at a given key &lt;code&gt;k&lt;/code&gt;. As of Flow v0.36.0, &lt;code&gt;k&lt;/code&gt; must be a literal string.</source>
          <target state="translated">甲 &lt;code&gt;$PropertyType&amp;lt;T, k&amp;gt;&lt;/code&gt; 是在给定的键的类型 &lt;code&gt;k&lt;/code&gt; 。从Flow v0.36.0开始， &lt;code&gt;k&lt;/code&gt; 必须是文字字符串。</target>
        </trans-unit>
        <trans-unit id="3e7f5ef7659179e8cb5f3ac39ecffed44e573698" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Boolean&lt;/code&gt; is a wrapper object created by the global &lt;code&gt;new Boolean(x)&lt;/code&gt; constructor.</source>
          <target state="translated">一个 &lt;code&gt;Boolean&lt;/code&gt; 是全球创建一个包装对象， &lt;code&gt;new Boolean(x)&lt;/code&gt; 构造函数。</target>
        </trans-unit>
        <trans-unit id="f4b4c1e23604a85feb14553cd867329fa18edcb9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Number&lt;/code&gt; is a wrapper object created by the global &lt;code&gt;new Number(x)&lt;/code&gt; constructor.</source>
          <target state="translated">一个 &lt;code&gt;Number&lt;/code&gt; 是由全球创建一个包装对象 &lt;code&gt;new Number(x)&lt;/code&gt; 构造函数。</target>
        </trans-unit>
        <trans-unit id="7ff4f95a14f0f15fb91feaff17eb578d01d42954" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt; takes a single type argument, &lt;code&gt;typeof Component&lt;/code&gt;. &lt;code&gt;typeof Component&lt;/code&gt; is the component type of the React element. For an intrinsic element, &lt;code&gt;typeof Component&lt;/code&gt; will be the string literal for the intrinsic you used. Here are a few examples with DOM intrinsics:</source>
          <target state="translated">甲 &lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt; 采用单个类型参数， &lt;code&gt;typeof Component&lt;/code&gt; 。 &lt;code&gt;typeof Component&lt;/code&gt; 是React元素的组件类型。对于内部元素， &lt;code&gt;typeof Component&lt;/code&gt; 将是您所使用的内部元素的字符串文字。以下是DOM内部函数的一些示例：</target>
        </trans-unit>
        <trans-unit id="3cc9f3a301444a49c02a8ccdf90391c3099669bb" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;String&lt;/code&gt; is a wrapper object created by the global &lt;code&gt;new String(x)&lt;/code&gt; constructor.</source>
          <target state="translated">一个 &lt;code&gt;String&lt;/code&gt; 是全球创建一个包装对象， &lt;code&gt;new String(x)&lt;/code&gt; 构造函数。</target>
        </trans-unit>
        <trans-unit id="1aa87ca478a9e8203d1f48b664ee80f4bde77cca" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;boolean&lt;/code&gt; is a literal value like &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; or the result of an expression like &lt;code&gt;a === b&lt;/code&gt;.</source>
          <target state="translated">甲 &lt;code&gt;boolean&lt;/code&gt; 就像是一个文字值 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 或类似的表达式的结果 &lt;code&gt;a === b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eae9db4713f41ce51d4836cd52cd83cf66fe6bba" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;flowlint-line&lt;/code&gt; comment works similarly to a &lt;code&gt;flowlint&lt;/code&gt; comment, except it only applies its settings to the current line instead of applying them for the rest of the file. The primary use for &lt;code&gt;flowlint-line&lt;/code&gt; comments is to suppress a lint on a particular line:</source>
          <target state="translated">一个 &lt;code&gt;flowlint-line&lt;/code&gt; 注释的工作方式类似于一个 &lt;code&gt;flowlint&lt;/code&gt; 评论，但它仅适用其设置为当前行，而不是将它们应用于该文件的其余部分。 &lt;code&gt;flowlint-line&lt;/code&gt; 注释的主要用途是抑制特定行上的皮棉：</target>
        </trans-unit>
        <trans-unit id="3dbdddd5ad4de5b2edfb46887933757af099bccf" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;number&lt;/code&gt; is a literal value like &lt;code&gt;42&lt;/code&gt; or &lt;code&gt;3.14&lt;/code&gt; or the result of an expression like &lt;code&gt;parseFloat(x)&lt;/code&gt;.</source>
          <target state="translated">甲 &lt;code&gt;number&lt;/code&gt; 就像一个文字值 &lt;code&gt;42&lt;/code&gt; 或 &lt;code&gt;3.14&lt;/code&gt; 或象表达式的结果 &lt;code&gt;parseFloat(x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="810376c88abf15447cb20ec803309eab84ccf149" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;string&lt;/code&gt; is a literal value like &lt;code&gt;&quot;foo&quot;&lt;/code&gt; or the result of an expression like &lt;code&gt;&quot;&quot; + 42&lt;/code&gt;.</source>
          <target state="translated">甲 &lt;code&gt;string&lt;/code&gt; 就像是一个文字值 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 或类似的表达式的结果 &lt;code&gt;&quot;&quot; + 42&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="86a442d2c56258fa63e09bdf1e3922431ce6755c" translate="yes" xml:space="preserve">
          <source>A React children array can be a single value or an array nested to any level. It is designed to be used with the &lt;a href=&quot;https://reactjs.org/docs/react-api.html#reactchildren&quot;&gt;&lt;code&gt;React.Children&lt;/code&gt; API&lt;/a&gt;.</source>
          <target state="translated">React子数组可以是单个值，也可以是嵌套到任何级别的数组。它旨在与&lt;a href=&quot;https://reactjs.org/docs/react-api.html#reactchildren&quot;&gt; &lt;code&gt;React.Children&lt;/code&gt; API&lt;/a&gt;一起使用。</target>
        </trans-unit>
        <trans-unit id="1ac20284b90912b5ee342718a932002c471e7063" translate="yes" xml:space="preserve">
          <source>A React element is the type for the value of a JSX element:</source>
          <target state="translated">React元素是JSX元素的值的类型。</target>
        </trans-unit>
        <trans-unit id="5d4c2e7721c9d46456be0ebe1e112134378df4c1" translate="yes" xml:space="preserve">
          <source>A class or function component with config &lt;code&gt;Config&lt;/code&gt; may be used in places that expect &lt;code&gt;React.AbstractComponent&amp;lt;Config&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">带有 &lt;code&gt;Config&lt;/code&gt; 的类或函数组件可以在需要 &lt;code&gt;React.AbstractComponent&amp;lt;Config&amp;gt;&lt;/code&gt; 地方使用。</target>
        </trans-unit>
        <trans-unit id="5c97c303f1555df5edf4bfe277f9d6c3317ef0a7" translate="yes" xml:space="preserve">
          <source>A common use case for higher-order components is to inject a prop. The HOC automatically sets a prop and returns a component which no longer requires that prop. For example, consider a navigation prop, or in the case of &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options&quot;&gt;&lt;code&gt;react-redux&lt;/code&gt; a &lt;code&gt;store&lt;/code&gt; prop&lt;/a&gt;. How would one type this?</source>
          <target state="translated">高阶组件的常见用例是注入道具。HOC自动设置道具并返回不再需要该道具的组件。例如，考虑一个导航道具，或者在&lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options&quot;&gt; &lt;code&gt;react-redux&lt;/code&gt; &lt;code&gt;store&lt;/code&gt; &lt;/a&gt;的情况下考虑一个商店道具。怎么会这样呢？</target>
        </trans-unit>
        <trans-unit id="93d366e66197a09ccf2c1277e6ddbdf41eb6a727" translate="yes" xml:space="preserve">
          <source>A common use of intersection types is to express functions that return different results based on the input we pass in. Suppose for example that we want to write the type of a function that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30dbf123853c4a0e8c3631a140f89f123c49780e" translate="yes" xml:space="preserve">
          <source>A libdef is a special file that informs Flow about the type signature of some specific third-party module or package of modules that your application uses. If you&amp;rsquo;re familiar with languages that have header files (like &lt;code&gt;C++&lt;/code&gt;), you can think of libdefs as a similar concept.</source>
          <target state="translated">libdef是一个特殊文件，用于通知Flow您的应用程序使用的某些特定第三方模块或模块包的类型签名。如果您熟悉具有头文件的语言（例如 &lt;code&gt;C++&lt;/code&gt; ），则可以将libdefs视为一个类似的概念。</target>
        </trans-unit>
        <trans-unit id="c2a62759846de776a0003ecb09307da295487e4a" translate="yes" xml:space="preserve">
          <source>A limitation in Flow is that it can&amp;rsquo;t &lt;em&gt;check&lt;/em&gt; the body of a function against an intersection type. In other words, if we provided the following implementation for &lt;code&gt;fn&lt;/code&gt; right after the above declarations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca822c818a1e02043f7fd8c1f3e2121e587ff173" translate="yes" xml:space="preserve">
          <source>A popular pattern in React is the &lt;a href=&quot;https://facebook.github.io/react/docs/higher-order-components.html&quot;&gt;higher-order component pattern&lt;/a&gt;, so it&amp;rsquo;s important that we can provide effective types for higher-order components in Flow. If you don&amp;rsquo;t already know what a higher-order component is then make sure to read the &lt;a href=&quot;https://facebook.github.io/react/docs/higher-order-components.html&quot;&gt;React documentation on higher-order components&lt;/a&gt; before continuing.</source>
          <target state="translated">React中一个流行的模式是&lt;a href=&quot;https://facebook.github.io/react/docs/higher-order-components.html&quot;&gt;高阶组件模式&lt;/a&gt;，因此重要的是我们可以为Flow中的高阶组件提供有效的类型。如果您尚不清楚什么是高阶组件，那么请确保在继续之前阅读&lt;a href=&quot;https://facebook.github.io/react/docs/higher-order-components.html&quot;&gt;有关高阶组件&lt;/a&gt;的React文档。</target>
        </trans-unit>
        <trans-unit id="2f8e9dfe25e3835aaff6cc6ecae3f02d157188cb" translate="yes" xml:space="preserve">
          <source>A static type checker uses either the names or the structure of the types in order to compare them against other types. Checking against the name is nominal typing and checking against the structure is structural typing.</source>
          <target state="translated">静态类型检查器使用类型的名称或结构来与其他类型进行比较。对名称的检查是名义类型检查,对结构的检查是结构类型检查。</target>
        </trans-unit>
        <trans-unit id="671a4ff4e804eebb070be2fc14388832f1511e9d" translate="yes" xml:space="preserve">
          <source>A type is something like a string, a boolean, an object, or a class. They have names and they have structures. Primitives like strings or booleans have a very simple structure and only go by one name.</source>
          <target state="translated">类型就是像字符串、布尔值、对象或类这样的东西。它们有名字,有结构。像字符串或布尔值这样的基元有一个非常简单的结构,而且只有一个名字。</target>
        </trans-unit>
        <trans-unit id="41848119547f63e0f0117b445db59a03ebf4ba0e" translate="yes" xml:space="preserve">
          <source>A type like &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, or &lt;code&gt;string&lt;/code&gt; describes a set of possible values. A &lt;code&gt;number&lt;/code&gt; describes every possible number, so a single number (such as &lt;code&gt;42&lt;/code&gt;) would be a &lt;em&gt;subtype&lt;/em&gt; of the &lt;code&gt;number&lt;/code&gt; type.</source>
          <target state="translated">诸如 &lt;code&gt;number&lt;/code&gt; ， &lt;code&gt;boolean&lt;/code&gt; 或 &lt;code&gt;string&lt;/code&gt; 之类的类型描述了一组可能的值。甲 &lt;code&gt;number&lt;/code&gt; 描述了每个可能的数字，所以一个单一的数（如 &lt;code&gt;42&lt;/code&gt; ）将是一个&lt;em&gt;亚型&lt;/em&gt;的的 &lt;code&gt;number&lt;/code&gt; 的类型。</target>
        </trans-unit>
        <trans-unit id="084f378a5689bc62abec28cce79f808d15cc2701" translate="yes" xml:space="preserve">
          <source>A variable of type &lt;code&gt;$Shape&amp;lt;T&amp;gt;&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is some object type, can be assigned objects &lt;code&gt;o&lt;/code&gt; that contain a subset of the properties included in &lt;code&gt;T&lt;/code&gt;. For each property &lt;code&gt;p: S&lt;/code&gt; of &lt;code&gt;T&lt;/code&gt;, the type of a potential binding of &lt;code&gt;p&lt;/code&gt; in &lt;code&gt;o&lt;/code&gt; must be compatible with &lt;code&gt;S&lt;/code&gt;.</source>
          <target state="translated">可以为类型 &lt;code&gt;$Shape&amp;lt;T&amp;gt;&lt;/code&gt; 变量（其中 &lt;code&gt;T&lt;/code&gt; 是某种对象类型）分配对象 &lt;code&gt;o&lt;/code&gt; ，这些对象包含 &lt;code&gt;T&lt;/code&gt; 中包含的属性的子集。对于 &lt;code&gt;T&lt;/code&gt; 的每个属性 &lt;code&gt;p: S&lt;/code&gt; ， &lt;code&gt;p&lt;/code&gt; 在 &lt;code&gt;o&lt;/code&gt; 中的潜在结合类型必须与 &lt;code&gt;S&lt;/code&gt; 兼容。</target>
        </trans-unit>
        <trans-unit id="2271b14edc45904cc47bb0f92baf4a74500757a6" translate="yes" xml:space="preserve">
          <source>ALE</source>
          <target state="translated">ALE</target>
        </trans-unit>
        <trans-unit id="c3cd636a585b20c40ac2df5ffb403e83cb2eef51" translate="yes" xml:space="preserve">
          <source>Actions</source>
          <target state="translated">Actions</target>
        </trans-unit>
        <trans-unit id="c2c9357e2d1358b4ed63794b3bdbb571d911a366" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;@flow strict&lt;/code&gt; to a file and fix all errors that appear. Because Flow Strict requires dependencies to also be strict (if the &lt;code&gt;nonstrict-import&lt;/code&gt; rule is enabled), start at the leaves of the dependency tree and work up from there. Do not add &lt;code&gt;$FlowFixMe&lt;/code&gt; to suppress the new errors as they appear; just add &lt;code&gt;@flow strict&lt;/code&gt; once all issues have been resolved. Since the most common reasons for using &lt;code&gt;$FlowFixMe&lt;/code&gt; stem from reliance on untyped dependencies or behavior, future issues should be greatly reduced once Flow Strict is enabled.</source>
          <target state="translated">将 &lt;code&gt;@flow strict&lt;/code&gt; 添加到文件中，并修复出现的所有错误。由于Flow Strict要求依赖项也必须严格（如果启用了 &lt;code&gt;nonstrict-import&lt;/code&gt; 规则），因此从依赖关系树的叶子开始，然后从那里开始。不要添加 &lt;code&gt;$FlowFixMe&lt;/code&gt; 来抑制出现的新错误。解决所有问题后，只需添加 &lt;code&gt;@flow strict&lt;/code&gt; 。由于使用 &lt;code&gt;$FlowFixMe&lt;/code&gt; 的最常见原因是依赖于未类型化的依赖项或行为，因此一旦启用Flow Strict，就应大大减少将来的问题。</target>
        </trans-unit>
        <trans-unit id="348f08f4c30937769280d29589632be81dce564d" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;[strict]&lt;/code&gt; section to the &lt;code&gt;.flowconfig&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;[strict]&lt;/code&gt; 部分添加到 &lt;code&gt;.flowconfig&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="debff0c0e31df0c3b54bd63967abba908318fd7b" translate="yes" xml:space="preserve">
          <source>Add this to your ~/.vimrc</source>
          <target state="translated">将此添加到你的~/.vimrc中。</target>
        </trans-unit>
        <trans-unit id="ef87c5c8a2b16d4c56ca61522bd746bf5ccd2856" translate="yes" xml:space="preserve">
          <source>Adding Flow types to your React components is incredibly powerful. After typing your component, Flow will statically ensure that you are using the component in the way it was designed to be used.</source>
          <target state="translated">将Flow类型添加到你的React组件中是非常强大的。在对您的组件进行类型化后,Flow将静态地确保您以其设计的方式使用该组件。</target>
        </trans-unit>
        <trans-unit id="ce3f0d181c2f06a4552c99e371dfc2c79d5925f9" translate="yes" xml:space="preserve">
          <source>Adding State</source>
          <target state="translated">增加国家</target>
        </trans-unit>
        <trans-unit id="3bfb8073e6bb1f0689467760321027edeffeb0e7" translate="yes" xml:space="preserve">
          <source>Adding defaults to parameterized generics</source>
          <target state="translated">为参数化的属类添加默认值。</target>
        </trans-unit>
        <trans-unit id="24102cd54654562a4cca3094ba42e1695bfc0400" translate="yes" xml:space="preserve">
          <source>Adding type annotations is an important part of your interaction with Flow.</source>
          <target state="translated">添加类型注释是与Flow交互的一个重要部分。</target>
        </trans-unit>
        <trans-unit id="dd4b16fc77256848662e64369cda76926181fdf0" translate="yes" xml:space="preserve">
          <source>Adding types to generics</source>
          <target state="translated">将类型添加到属类中</target>
        </trans-unit>
        <trans-unit id="c46c2e1f44bf89eeaca616b1006a75c2f1f9f078" translate="yes" xml:space="preserve">
          <source>Additionally, note that function parameters are considered const (i.e., treated as if they were declared with &lt;code&gt;const&lt;/code&gt; rather than &lt;code&gt;let&lt;/code&gt;). This feature is not yet configurable in Flow Strict; it is always on.</source>
          <target state="translated">另外，请注意，函数参数被视为const（即，就像使用 &lt;code&gt;const&lt;/code&gt; 而不是 &lt;code&gt;let&lt;/code&gt; 声明它们一样）。此功能尚未在Flow Strict中配置。它总是打开。</target>
        </trans-unit>
        <trans-unit id="084523950d9700bad04af812baabda38d1775c92" translate="yes" xml:space="preserve">
          <source>Additionally, one of the things that also makes &lt;code&gt;$ElementType&amp;lt;T, K&amp;gt;&lt;/code&gt; more powerful than &lt;a href=&quot;#toc-propertytype&quot;&gt;&lt;code&gt;$PropertyType&amp;lt;T, k&amp;gt;&lt;/code&gt;&lt;/a&gt; is that you can use it with generics. For example:</source>
          <target state="translated">此外，使 &lt;code&gt;$ElementType&amp;lt;T, K&amp;gt;&lt;/code&gt; 比&lt;a href=&quot;#toc-propertytype&quot;&gt; &lt;code&gt;$PropertyType&amp;lt;T, k&amp;gt;&lt;/code&gt; &lt;/a&gt;更强大的功能之一是您可以将其与泛型一起使用。例如：</target>
        </trans-unit>
        <trans-unit id="e9a588006a751b6eac3899c1c33719e0d1f574b8" translate="yes" xml:space="preserve">
          <source>Additionally, other utility types, such as &lt;a href=&quot;#toc-objmap&quot;&gt;&lt;code&gt;$ObjMap&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, may strip any read/write annotations, so &lt;code&gt;$ReadOnly&amp;lt;T&amp;gt;&lt;/code&gt; is a handy way to quickly make the object read-only again after operating on it:</source>
          <target state="translated">此外，其他实用程序类型，例如&lt;a href=&quot;#toc-objmap&quot;&gt; &lt;code&gt;$ObjMap&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;，可能会剥离任何读/写注释，因此 &lt;code&gt;$ReadOnly&amp;lt;T&amp;gt;&lt;/code&gt; 是一种方便的方法，可以在对其进行操作后快速将其再次变为只读：</target>
        </trans-unit>
        <trans-unit id="9165abaadf3796191a41d4c4e2ff7bee612bceba" translate="yes" xml:space="preserve">
          <source>Adds completions to omnifunc</source>
          <target state="translated">在omnifunc中添加补语。</target>
        </trans-unit>
        <trans-unit id="9d9855d155abfb00319d620ad3008e951f075bcb" translate="yes" xml:space="preserve">
          <source>Adoption</source>
          <target state="translated">Adoption</target>
        </trans-unit>
        <trans-unit id="7823f6ab865766bbd1127e26841e44993df0966b" translate="yes" xml:space="preserve">
          <source>Again, if you import React with: &lt;code&gt;import React from 'react'&lt;/code&gt; you will be able to access &lt;code&gt;React.Component&lt;/code&gt;, &lt;code&gt;React.createElement()&lt;/code&gt;, &lt;code&gt;React.Children&lt;/code&gt;, and other JavaScript &lt;em&gt;values&lt;/em&gt;. However, you will not be able to access &lt;a href=&quot;#toc-react-node&quot;&gt;&lt;code&gt;React.Node&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#toc-react-childrenarray&quot;&gt;&lt;code&gt;React.ChildrenArray&lt;/code&gt;&lt;/a&gt; or other Flow &lt;em&gt;types&lt;/em&gt;. You will need to use a named type import like: &lt;code&gt;import type {Node} from 'react'&lt;/code&gt; in addition to your default import.</source>
          <target state="translated">同样，如果您使用以下方式 &lt;code&gt;import React from 'react'&lt;/code&gt; 您将能够访问 &lt;code&gt;React.Component&lt;/code&gt; ， &lt;code&gt;React.createElement()&lt;/code&gt; ， &lt;code&gt;React.Children&lt;/code&gt; 和其他JavaScript &lt;em&gt;值&lt;/em&gt;。但是，您将无法访问&lt;a href=&quot;#toc-react-node&quot;&gt; &lt;code&gt;React.Node&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#toc-react-childrenarray&quot;&gt; &lt;code&gt;React.ChildrenArray&lt;/code&gt; &lt;/a&gt;或其他Flow &lt;em&gt;类型&lt;/em&gt;。除了默认导入外，您还需要使用命名类型导入，例如： &lt;code&gt;import type {Node} from 'react'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6960f0d48dae2ed291e229a0c18667430af5ad7c" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;react-dom&lt;/code&gt; JSX intrinsics have &lt;code&gt;React.Node&lt;/code&gt; as their children type. &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;, and all the rest.</source>
          <target state="translated">所有 &lt;code&gt;react-dom&lt;/code&gt; JSX内部函数都将 &lt;code&gt;React.Node&lt;/code&gt; 作为其子类型。 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; 以及所有其他内容。</target>
        </trans-unit>
        <trans-unit id="ca3d3759b20a58e23b6e490416571783c4b57d09" translate="yes" xml:space="preserve">
          <source>All of these different expressions create a new type which is a result of the types of values and the operations run on them.</source>
          <target state="translated">所有这些不同的表达式都创建了一个新的类型,它是值的类型和对它们运行的操作的结果。</target>
        </trans-unit>
        <trans-unit id="0f113e33ce14591dd70d6193beb553131d41f5f0" translate="yes" xml:space="preserve">
          <source>All of this is why Flow has contravariant inputs (accepts less specific types to be passed in), and covariant outputs (allows more specific types to be returned).</source>
          <target state="translated">所有这些就是为什么Flow有反变量输入(接受较少的特定类型传入),以及反变量输出(允许更多的特定类型被返回)。</target>
        </trans-unit>
        <trans-unit id="f47b935eb4737e5a19c994e524b19f17133d6b8b" translate="yes" xml:space="preserve">
          <source>Also a tuple type cannot be passed into to an &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; type, since then you could mutate the tuple in an unsafe way.</source>
          <target state="translated">同样，不能将元组类型传递给 &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; 类型，因为那样您可能会以不安全的方式对元组进行变异。</target>
        </trans-unit>
        <trans-unit id="1e224fe065210d7ea5bc4ecdfb975d62ba96cb27" translate="yes" xml:space="preserve">
          <source>Also recommended, but optional as it may be too noisy in some codebases: &lt;code&gt;sketchy-null&lt;/code&gt;</source>
          <target state="translated">也建议使用，但由于在某些代码库中可能太吵，所以是可选的： &lt;code&gt;sketchy-null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6650e3d7dff1ebe1979e6edf742206dcb5d30b21" translate="yes" xml:space="preserve">
          <source>Also, a longer tuple can&amp;rsquo;t be used in place of a shorter one.</source>
          <target state="translated">而且，不能使用更长的元组来代替较短的元组。</target>
        </trans-unit>
        <trans-unit id="ed76d08a5750c0ac19262fa4c88e1912b27bd2c6" translate="yes" xml:space="preserve">
          <source>Alternatively, &lt;a href=&quot;../config/options#toc-lazy-mode-fs-ide-watchman-none&quot;&gt;you can set the lazy mode from the &lt;code&gt;.flowconfig&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">另外，&lt;a href=&quot;../config/options#toc-lazy-mode-fs-ide-watchman-none&quot;&gt;您可以从 &lt;code&gt;.flowconfig&lt;/code&gt; &lt;/a&gt;设置惰性模式。</target>
        </trans-unit>
        <trans-unit id="82c66bd79d3d4ffdc185a7185952761a2c8c3f10" translate="yes" xml:space="preserve">
          <source>Alternatively, the legacy &lt;a href=&quot;#toc-vim-flow&quot;&gt;vim-flow&lt;/a&gt; extension is Flow-specific, and provides fewer features.</source>
          <target state="translated">另外，旧式&lt;a href=&quot;#toc-vim-flow&quot;&gt;vim-flow&lt;/a&gt;扩展是特定于Flow的，并且提供较少的功能。</target>
        </trans-unit>
        <trans-unit id="5d58f352f3f2d2c03f34156038b5074e5ea813c0" translate="yes" xml:space="preserve">
          <source>An equivalent way to declare the same function &lt;code&gt;fn&lt;/code&gt; would be by using consecutive &amp;ldquo;declare function&amp;rdquo; statements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05c96e450e44289cd41c687e74cce15c9214f0aa" translate="yes" xml:space="preserve">
          <source>An example &lt;code&gt;[declarations]&lt;/code&gt; section might look like:</source>
          <target state="translated">示例 &lt;code&gt;[declarations]&lt;/code&gt; 部分可能如下所示：</target>
        </trans-unit>
        <trans-unit id="90be5ce7c515603e4e6a07b492b34ad2c170d26e" translate="yes" xml:space="preserve">
          <source>An example &lt;code&gt;[ignore]&lt;/code&gt; section might look like:</source>
          <target state="translated">示例 &lt;code&gt;[ignore]&lt;/code&gt; 部分可能如下所示：</target>
        </trans-unit>
        <trans-unit id="63ef3849ebab36d15f3096be1da4ba961dfdabbb" translate="yes" xml:space="preserve">
          <source>An example &lt;code&gt;[untyped]&lt;/code&gt; section might look like:</source>
          <target state="translated">示例 &lt;code&gt;[untyped]&lt;/code&gt; 部分可能如下所示：</target>
        </trans-unit>
        <trans-unit id="c58b06aa29f634eb5b80b5c46b1dd5e2a95f3710" translate="yes" xml:space="preserve">
          <source>An important attribute of every type system is whether they are structural or nominal, they can even be mixed within a single type system. So it&amp;rsquo;s important to know the difference.</source>
          <target state="translated">每个类型系统的一个重要属性是它们是结构上的还是名义上的，甚至可以在单个类型系统内混合使用。因此了解差异非常重要。</target>
        </trans-unit>
        <trans-unit id="7534a2c6b02aff918f4734ba9f0cb833213dab75" translate="yes" xml:space="preserve">
          <source>An indexer can be optionally named, for documentation purposes:</source>
          <target state="translated">为了便于记录,可以选择命名一个索引器。</target>
        </trans-unit>
        <trans-unit id="02f5dca0f3fb11ce7b28ee592bf4f726a45875a4" translate="yes" xml:space="preserve">
          <source>And that is it. Your project is now Flow-enabled.</source>
          <target state="translated">就是这样。您的项目现在已经启用了Flow。</target>
        </trans-unit>
        <trans-unit id="bc97cb67c24efbdbd68974b88a3db4e9f3a4fc10" translate="yes" xml:space="preserve">
          <source>And use:</source>
          <target state="translated">并使用。</target>
        </trans-unit>
        <trans-unit id="8b778ae534c485f0d6739866e99f8bc63e2331d8" translate="yes" xml:space="preserve">
          <source>Another way to add support for Flow in Vim is to use &lt;a href=&quot;https://github.com/autozimu/LanguageClient-neovim&quot;&gt;LanguageClient-neovim&lt;/a&gt;.</source>
          <target state="translated">在Vim中添加对Flow的支持的另一种方法是使用&lt;a href=&quot;https://github.com/autozimu/LanguageClient-neovim&quot;&gt;LanguageClient-neovim&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c37c50bfab9118a52fdf0a7f80769cc4ab540351" translate="yes" xml:space="preserve">
          <source>Another way to add support for Flow in Vim is to use &lt;a href=&quot;https://github.com/flowtype/vim-flow&quot;&gt;vim-flow&lt;/a&gt;.</source>
          <target state="translated">在Vim中添加对Flow的支持的另一种方法是使用&lt;a href=&quot;https://github.com/flowtype/vim-flow&quot;&gt;vim-flow&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="92210bddb4211d0e6c83515a4f9b3f1b1a7a39c8" translate="yes" xml:space="preserve">
          <source>Any Types</source>
          <target state="translated">任何类型</target>
        </trans-unit>
        <trans-unit id="d75e5f7ff95f6863097f6d1ec2a9d80aba28a579" translate="yes" xml:space="preserve">
          <source>Any directory under &lt;code&gt;/path/to/otherProject&lt;/code&gt; named &lt;code&gt;coolStuff/&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;/path/to/otherProject&lt;/code&gt; &lt;code&gt;coolStuff/&lt;/code&gt; 下任何名为coolStuff /的目录</target>
        </trans-unit>
        <trans-unit id="9e3d4ca42d4885ee40721656532f3228027ab154" translate="yes" xml:space="preserve">
          <source>Any file in &lt;code&gt;/path/to/otherProject/&lt;/code&gt; that ends in &lt;code&gt;.js&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;/path/to/otherProject/&lt;/code&gt; 中以 &lt;code&gt;.js&lt;/code&gt; 结尾的任何文件</target>
        </trans-unit>
        <trans-unit id="ff45287734d6e5c2d42e27a8403e84e9cdd43925" translate="yes" xml:space="preserve">
          <source>Any file or directory under &lt;code&gt;.*/src/foo&lt;/code&gt; or under &lt;code&gt;.*/src/bar&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.*/src/foo&lt;/code&gt; 下或 &lt;code&gt;.*/src/bar&lt;/code&gt; 下的任何文件或目录</target>
        </trans-unit>
        <trans-unit id="619cdeb72fa14a27c15ad77831a5eef22d615f19" translate="yes" xml:space="preserve">
          <source>Any file or directory under a directory named &lt;code&gt;__tests__&lt;/code&gt;</source>
          <target state="translated">目录 &lt;code&gt;__tests__&lt;/code&gt; 下的任何文件或目录</target>
        </trans-unit>
        <trans-unit id="0c3253b58f788b30811429ab97032f8e98a1859d" translate="yes" xml:space="preserve">
          <source>Any file or directory under a directory named &lt;code&gt;third_party&lt;/code&gt;</source>
          <target state="translated">名为 &lt;code&gt;third_party&lt;/code&gt; 的目录下的任何文件或目录</target>
        </trans-unit>
        <trans-unit id="7cc44198b1e6e1b795a7e8aa32c3da295d676830" translate="yes" xml:space="preserve">
          <source>Any file that ends with the extension &lt;code&gt;.decl.js&lt;/code&gt;</source>
          <target state="translated">以扩展名 &lt;code&gt;.decl.js&lt;/code&gt; 结尾的任何文件</target>
        </trans-unit>
        <trans-unit id="1bffc382d25466b833b5b2837da78952a00737fd" translate="yes" xml:space="preserve">
          <source>Any file that ends with the extension &lt;code&gt;.ignore.js&lt;/code&gt;</source>
          <target state="translated">以扩展名 &lt;code&gt;.ignore.js&lt;/code&gt; 结尾的任何文件</target>
        </trans-unit>
        <trans-unit id="f72b4d45c679b8fd5b66d19514cb30c2b70941fd" translate="yes" xml:space="preserve">
          <source>Any file that ends with the extension &lt;code&gt;.untype.js&lt;/code&gt;</source>
          <target state="translated">以扩展名 &lt;code&gt;.untype.js&lt;/code&gt; 结尾的任何文件</target>
        </trans-unit>
        <trans-unit id="d8058d8ae00a7724bf520d87b91a727d4fba9de4" translate="yes" xml:space="preserve">
          <source>Any options that are omitted will use their default values. Some options can be overridden with command line flags.</source>
          <target state="translated">任何省略的选项将使用它们的默认值。有些选项可以用命令行标志来覆盖。</target>
        </trans-unit>
        <trans-unit id="158d7a05937714067b015b61e36e2e34b536b32d" translate="yes" xml:space="preserve">
          <source>Any type can appear as the super type or type of an opaque type alias.</source>
          <target state="translated">任何类型都可以作为超级类型或不透明类型别名的类型出现。</target>
        </trans-unit>
        <trans-unit id="f8b9550f4f85978cbf264304833e5597e61caa6b" translate="yes" xml:space="preserve">
          <source>Any type can appear inside a type alias.</source>
          <target state="translated">任何类型都可以出现在类型别名里面。</target>
        </trans-unit>
        <trans-unit id="b8269fc02f1c810c6ff4db59298ada4596018447" translate="yes" xml:space="preserve">
          <source>Anything goes in, Nothing comes out</source>
          <target state="translated">什么都能进去,什么都不能出来</target>
        </trans-unit>
        <trans-unit id="1847f280fe6a7cfd6c208240da7d0ab7f1c91ffb" translate="yes" xml:space="preserve">
          <source>Array Types</source>
          <target state="translated">阵列类型</target>
        </trans-unit>
        <trans-unit id="83c584ea41caf5a381449f3d3b97037f78283560" translate="yes" xml:space="preserve">
          <source>Array access is unsafe</source>
          <target state="translated">阵列访问不安全</target>
        </trans-unit>
        <trans-unit id="3170d1b3f6bc73372a7270faffd2e78add925812" translate="yes" xml:space="preserve">
          <source>Arrays are a special list-like type of object in JavaScript. You can create arrays a couple different ways.</source>
          <target state="translated">数组是JavaScript中一种特殊的类似列表的对象类型。你可以用几种不同的方式创建数组。</target>
        </trans-unit>
        <trans-unit id="2eff12655bfd37e8aba34fc4ce9e8a7b43bbf939" translate="yes" xml:space="preserve">
          <source>Arrow Functions</source>
          <target state="translated">箭头功能</target>
        </trans-unit>
        <trans-unit id="9deec36383ee4f0d0aa3b179bc68ebbe9f7b8c48" translate="yes" xml:space="preserve">
          <source>As Flow gets smarter and smarter, it will figure out the types of properties in more scenarios.</source>
          <target state="translated">随着Flow越来越聪明,它会在更多的场景中找出属性的类型。</target>
        </trans-unit>
        <trans-unit id="5ce04ebbe35f0d095625abc02e93781430c8c957" translate="yes" xml:space="preserve">
          <source>As Flow gets smarter and smarter, there should be fewer instances of these scenarios.</source>
          <target state="translated">随着Flow越来越智能,这些场景的情况应该会越来越少。</target>
        </trans-unit>
        <trans-unit id="bc029ffe889a5bffa6b1132bfb40c2eb845b9647" translate="yes" xml:space="preserve">
          <source>As Flow is made to be smarter it may be possible in the future to fix this problem, but for now you should be aware of it.</source>
          <target state="translated">由于Flow做得比较智能,将来可能会解决这个问题,但现在你应该注意这个问题。</target>
        </trans-unit>
        <trans-unit id="afba3e48afe0dd342bba029cc69e818d6ff61285" translate="yes" xml:space="preserve">
          <source>As a motivating example, consider this common idiom in React:</source>
          <target state="translated">作为一个激励性的例子,考虑一下React中的这个常见成语。</target>
        </trans-unit>
        <trans-unit id="d994c8247e9b514f90a5e611ee46421248799ee9" translate="yes" xml:space="preserve">
          <source>As a result of having weak dynamic typing, JavaScript doesn&amp;rsquo;t have any of these, you can use any type at any time.</source>
          <target state="translated">由于弱动态类型，JavaScript没有这些类型，因此您可以随时使用任何类型。</target>
        </trans-unit>
        <trans-unit id="ede9cdf7589df1689a4530c061cb9167ab6ff6e9" translate="yes" xml:space="preserve">
          <source>As a workaround, you can specify the property not present in &lt;code&gt;A&lt;/code&gt; as optional. For example:</source>
          <target state="translated">解决方法是，可以将 &lt;code&gt;A&lt;/code&gt; 中不存在的属性指定为可选属性。例如：</target>
        </trans-unit>
        <trans-unit id="668bad0a3b1e2602a10cbca6af8ca3251f27e688" translate="yes" xml:space="preserve">
          <source>As an example, this would not work:</source>
          <target state="translated">举个例子,这样做是行不通的。</target>
        </trans-unit>
        <trans-unit id="b11d09cc159c523df3005c0738393c9419eb41da" translate="yes" xml:space="preserve">
          <source>As explained in the &lt;a href=&quot;options&quot;&gt;&lt;code&gt;sharedmemory.dirs&lt;/code&gt;&lt;/a&gt; option&amp;rsquo;s description, Flow needs to create a file on a filesystem for older kernels. &lt;code&gt;sharedmemory.dirs&lt;/code&gt; specifies a list of locations where the shared memory file can be created. For each location, Flow will check to make sure the filesystem has enough space for the shared memory file. If Flow will likely run out of space, it skips that location and tries the next. This option lets you configure the minimum amount of space needed on a filesystem for shared memory.</source>
          <target state="translated">如&lt;a href=&quot;options&quot;&gt; &lt;code&gt;sharedmemory.dirs&lt;/code&gt; &lt;/a&gt;选项说明中所述，Flow需要在文件系统上为较早的内核创建文件。 &lt;code&gt;sharedmemory.dirs&lt;/code&gt; 指定可以在其中创建共享内存文件的位置列表。对于每个位置，Flow都会检查以确保文件系统有足够的空间用于共享内存文件。如果Flow可能空间不足，则跳过该位置并尝试下一个。此选项使您可以配置文件系统上共享内存所需的最小空间量。</target>
        </trans-unit>
        <trans-unit id="2073dcd9de74f00e347d42b3bc3960e160aea0a5" translate="yes" xml:space="preserve">
          <source>As the name hints, &lt;code&gt;$Diff&amp;lt;A, B&amp;gt;&lt;/code&gt; is the type representing the set difference of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, i.e. &lt;code&gt;A \ B&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are both &lt;a href=&quot;../objects&quot;&gt;object types&lt;/a&gt;. Here&amp;rsquo;s an example:</source>
          <target state="translated">顾名思义， &lt;code&gt;$Diff&amp;lt;A, B&amp;gt;&lt;/code&gt; 是表示 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 的集合差的类型，即 &lt;code&gt;A \ B&lt;/code&gt; ，其中 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 都是&lt;a href=&quot;../objects&quot;&gt;对象类型&lt;/a&gt;。这是一个例子：</target>
        </trans-unit>
        <trans-unit id="4d3ad0d71f6c8ca89c8bf0a20c87797e4687d205" translate="yes" xml:space="preserve">
          <source>As this example shows, declaration files must be written with care: it is up to the programmer to ensure they are correct, otherwise they may hide type errors.</source>
          <target state="translated">正如这个例子所显示的那样,声明文件的编写必须小心翼翼:程序员要确保它们的正确性,否则它们可能会隐藏类型错误。</target>
        </trans-unit>
        <trans-unit id="462ea53149f64cdf8d1c87506946781343ce500f" translate="yes" xml:space="preserve">
          <source>As you may have noticed, the example is not a random one. &lt;code&gt;$Diff&lt;/code&gt; is exactly what the React definition file uses to define the type of the props accepted by a React Component.</source>
          <target state="translated">您可能已经注意到，该示例不是随机的。 &lt;code&gt;$Diff&lt;/code&gt; 正是React定义文件用来定义React Component接受的props类型的东西。</target>
        </trans-unit>
        <trans-unit id="75050d15c413d5f7a029e56def34919e7565c848" translate="yes" xml:space="preserve">
          <source>Asserting types in this way works the same as types do anywhere else.</source>
          <target state="translated">以这种方式断言类型的工作方式和其他地方的类型一样。</target>
        </trans-unit>
        <trans-unit id="b7d56c19c3e1b18d86bf5280c85cef8d6ab8b6c5" translate="yes" xml:space="preserve">
          <source>Assume we have two classes, which have a subtype relationship:</source>
          <target state="translated">假设我们有两个类,它们有一个子类型关系。</target>
        </trans-unit>
        <trans-unit id="65b9fcb33e463a779d0c4da859a5125301fe7b6c" translate="yes" xml:space="preserve">
          <source>Async functions implicitly return a promise, so the return type must always be a &lt;code&gt;Promise&lt;/code&gt;.</source>
          <target state="translated">异步函数隐式返回一个 &lt;code&gt;Promise&lt;/code&gt; ，因此返回类型必须始终为Promise。</target>
        </trans-unit>
        <trans-unit id="41dded417052424bdcf3c39f6c8664147fae6806" translate="yes" xml:space="preserve">
          <source>Atom</source>
          <target state="translated">Atom</target>
        </trans-unit>
        <trans-unit id="9f01eb47108bfcd61bcd85d17fd5db43d8fe4fc5" translate="yes" xml:space="preserve">
          <source>Autocomplete-Flow</source>
          <target state="translated">Autocomplete-Flow</target>
        </trans-unit>
        <trans-unit id="7e6cbee16a2c2ad4b26fab2aa6ec8127618ef362" translate="yes" xml:space="preserve">
          <source>Available Lint Rules</source>
          <target state="translated">可用的绒毛规则</target>
        </trans-unit>
        <trans-unit id="48315d4da6f457296128d582ea2ac7a8107a6caa" translate="yes" xml:space="preserve">
          <source>Available options</source>
          <target state="translated">可用选项</target>
        </trans-unit>
        <trans-unit id="5701e01de65130c0af0004b67af666b5f9d12faa" translate="yes" xml:space="preserve">
          <source>Avoid leaking &lt;code&gt;any&lt;/code&gt;</source>
          <target state="translated">避免泄漏 &lt;code&gt;any&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f3bf8dee016caf43ae3970fbea5f976d54898ed9" translate="yes" xml:space="preserve">
          <source>Babel</source>
          <target state="translated">Babel</target>
        </trans-unit>
        <trans-unit id="cc9d9ae632880006314a40c1e1b1e575e801e3d5" translate="yes" xml:space="preserve">
          <source>Babel also &lt;a href=&quot;https://flow.org/en/tools/create-react-app/&quot;&gt;works out of the box with Create React App&lt;/a&gt;, just install Flow and create a &lt;code&gt;.flowconfig&lt;/code&gt;.</source>
          <target state="translated">Babel还&lt;a href=&quot;https://flow.org/en/tools/create-react-app/&quot;&gt;可以使用Create React App开箱即用&lt;/a&gt;，只需安装Flow并创建 &lt;code&gt;.flowconfig&lt;/code&gt; 即可。</target>
        </trans-unit>
        <trans-unit id="1d82284dd6071c5a7679a0d983aaaae31a00b7b5" translate="yes" xml:space="preserve">
          <source>Be liberal with enabling Flow Strict. Unlike adding or removing &lt;code&gt;@flow&lt;/code&gt;, adding or removing &lt;code&gt;@flow strict&lt;/code&gt; (by itself) does not change Flow coverage. It only prevents or allows certain new unsafe behavior from being added in the future. Even if in the future Flow Strict has to be disabled for the file, at least unsafe behavior was prevented from being added in the meantime.</source>
          <target state="translated">启用Flow Strict，要放宽心。与添加或删除 &lt;code&gt;@flow&lt;/code&gt; 不同， &lt;code&gt;@flow strict&lt;/code&gt; （本身）添加或删除@flow不会更改Flow覆盖范围。它仅阻止或允许将来添加某些新的不安全行为。即使将来必须为文件禁用&amp;ldquo;严格流&amp;rdquo;功能，也至少可以防止同时添加不安全行为。</target>
        </trans-unit>
        <trans-unit id="1680d3465c06ca53c16148fde39b55e52752431c" translate="yes" xml:space="preserve">
          <source>Because Flow understands JavaScript so well, it doesn&amp;rsquo;t need many of these types. You should only ever have to do a minimal amount of work to describe your code to Flow and it will &lt;em&gt;infer&lt;/em&gt; the rest. A lot of the time, Flow can understand your code without any types at all.</source>
          <target state="translated">因为Flow非常了解JavaScript，所以不需要其中许多类型。您只需要做很少的工作就可以向Flow描述您的代码，它将&lt;em&gt;推断&lt;/em&gt;其余的代码。在很多时候，Flow完全不需要任何类型就能理解您的代码。</target>
        </trans-unit>
        <trans-unit id="404fd91c9a9d241d6c9be8858eb9756bb6b4582e" translate="yes" xml:space="preserve">
          <source>Because of how contravariance works, contravariant properties also become write-only when used. Which can be useful over normal properties.</source>
          <target state="translated">由于反变量的工作原理,反变量属性在使用时也会变成只写。这比普通属性有用。</target>
        </trans-unit>
        <trans-unit id="c880f74f55ee33062612978400cf2ed6b594d1f2" translate="yes" xml:space="preserve">
          <source>Because of how covariance works, covariant properties also become read-only when used. Which can be useful over normal properties.</source>
          <target state="translated">由于协方差的工作原理,协方差属性在使用时也变成了只读属性。这比普通属性有用。</target>
        </trans-unit>
        <trans-unit id="3d81cf8083f23d6f8c59a3bff90779ac704e0cb6" translate="yes" xml:space="preserve">
          <source>Because of the &lt;code&gt;typeof value === 'string'&lt;/code&gt; check, Flow knows the &lt;code&gt;value&lt;/code&gt; can only be a &lt;code&gt;string&lt;/code&gt; inside of the &lt;code&gt;if&lt;/code&gt; statement. This is known as a &lt;a href=&quot;https://flow.org/en/lang/refinements/&quot;&gt;refinement&lt;/a&gt;.</source>
          <target state="translated">由于 &lt;code&gt;typeof value === 'string'&lt;/code&gt; 检查，因此Flow知道该 &lt;code&gt;value&lt;/code&gt; 只能是 &lt;code&gt;if&lt;/code&gt; 语句内部的 &lt;code&gt;string&lt;/code&gt; 。这被称为&lt;a href=&quot;https://flow.org/en/lang/refinements/&quot;&gt;改进&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6f57fb076b23f64a15463c71736ac7493ef61f03" translate="yes" xml:space="preserve">
          <source>Because of this behavior, it is a best practice to find or write libdefs for as many of the third-party libraries that you use as you can. We recommend checking out the &lt;code&gt;flow-typed&lt;/code&gt;&lt;a href=&quot;https://github.com/flowtype/flow-typed/blob/master/README.md&quot;&gt;tool and repository&lt;/a&gt; , which helps you quickly find and install pre-existing libdefs for your third-party dependencies.</source>
          <target state="translated">由于这种行为，最佳实践是为尽可能多的第三方库查找或编写libdefs。我们建议您检查 &lt;code&gt;flow-typed&lt;/code&gt; &lt;a href=&quot;https://github.com/flowtype/flow-typed/blob/master/README.md&quot;&gt;工具和存储库&lt;/a&gt;，它可以帮助您快速查找和安装第三方依赖项的预先存在的libdef。</target>
        </trans-unit>
        <trans-unit id="839f87b3fae494fd4e8b9480d1e5f45008a0dc7e" translate="yes" xml:space="preserve">
          <source>Because type casts work the same as all other type annotations, you can only cast values to less specific types. You cannot change the type or make it something more specific.</source>
          <target state="translated">因为类型转换与所有其他类型注解的工作原理相同,您只能将值转换为不太具体的类型。你不能改变类型,也不能把它变成更具体的东西。</target>
        </trans-unit>
        <trans-unit id="c07a19a41d787635a8e85b3b78306e9c1d7ff5d9" translate="yes" xml:space="preserve">
          <source>Before spending the time to write your own libdef, we recommend that you look to see if there is already a libdef for the third-party code that you&amp;rsquo;re addressing. &lt;code&gt;flow-typed&lt;/code&gt; is a &lt;a href=&quot;https://github.com/flowtype/flow-typed/&quot;&gt;tool and repository&lt;/a&gt; for sharing common libdefs within the Flow community &amp;ndash; so it&amp;rsquo;s a good way to knock out a good chunk of any public libdefs you might need for your project.</source>
          <target state="translated">在花时间编写自己的libdef之前，我们建议您查看是否已存在要处理的第三方代码的libdef。 &lt;code&gt;flow-typed&lt;/code&gt; 是用于在Flow社区内共享通用libdef 的&lt;a href=&quot;https://github.com/flowtype/flow-typed/&quot;&gt;工具和存储库&lt;/a&gt; &amp;ndash;因此，这是消除项目中可能需要的大量公共libdef的好方法。</target>
        </trans-unit>
        <trans-unit id="ffd8520b4ea61ae236ddd4d1f4143845bd5bc375" translate="yes" xml:space="preserve">
          <source>Before we show how to type a React class component with Flow, let us first show how you would write a React class component &lt;em&gt;without&lt;/em&gt; Flow but with React&amp;rsquo;s prop types. You would extend &lt;code&gt;React.Component&lt;/code&gt; and add a static &lt;code&gt;propTypes&lt;/code&gt; property.</source>
          <target state="translated">在展示如何使用Flow键入React类组件之前，让我们首先展示如何在&lt;em&gt;没有&lt;/em&gt; Flow的&lt;em&gt;情况下&lt;/em&gt;使用React的prop类型编写React类组件。您将扩展 &lt;code&gt;React.Component&lt;/code&gt; 并添加一个静态 &lt;code&gt;propTypes&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="2b1e005429a327929c485a9cce3808a1145b8aa0" translate="yes" xml:space="preserve">
          <source>Behavior of generics</source>
          <target state="translated">仿制药的行为</target>
        </trans-unit>
        <trans-unit id="14f05c52525df031dba9063b10d7682abd307a65" translate="yes" xml:space="preserve">
          <source>Between versions v0.125.0 and v0.127.0, this option was named &lt;code&gt;well_formed_exports.whitelist&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e82cf40f53265657d5832c1308bdb8b249dbe424" translate="yes" xml:space="preserve">
          <source>Bivariance</source>
          <target state="translated">Bivariance</target>
        </trans-unit>
        <trans-unit id="408adf1c6e528212e5ff5ec2ce7d7e888977db8a" translate="yes" xml:space="preserve">
          <source>Bivariance &lt;em&gt;does&lt;/em&gt; accept &lt;strong&gt;subtypes&lt;/strong&gt;.</source>
          <target state="translated">双方差&lt;em&gt;确实&lt;/em&gt;接受&lt;strong&gt;亚型&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="bf56a8499cffbc9b99a5c626b8e4f47f74fb6f88" translate="yes" xml:space="preserve">
          <source>Bivariance &lt;em&gt;does&lt;/em&gt; accept &lt;strong&gt;supertypes&lt;/strong&gt;.</source>
          <target state="translated">双方差&lt;em&gt;确实&lt;/em&gt;接受&lt;strong&gt;超类型&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="bcd9e69ceceba4abeefdd82a9dfed379a6547be2" translate="yes" xml:space="preserve">
          <source>Boolean types need you to be explicit by converting non-booleans. You can do that with &lt;code&gt;Boolean(x)&lt;/code&gt; or &lt;code&gt;!!x&lt;/code&gt;.</source>
          <target state="translated">布尔类型需要通过转换非布尔值来明确显示。您可以使用 &lt;code&gt;Boolean(x)&lt;/code&gt; 或 &lt;code&gt;!!x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0786cdff946e6084c50bb7df6cacd8ed965599fa" translate="yes" xml:space="preserve">
          <source>Booleans</source>
          <target state="translated">Booleans</target>
        </trans-unit>
        <trans-unit id="aeaf4741c43124d50887c3856fa57da08ef729d3" translate="yes" xml:space="preserve">
          <source>Booleans are &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; values in JavaScript. The &lt;code&gt;boolean&lt;/code&gt; type in Flow accepts these values.</source>
          <target state="translated">在JavaScript中，布尔值是 &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 值。Flow中的 &lt;code&gt;boolean&lt;/code&gt; 类型接受这些值。</target>
        </trans-unit>
        <trans-unit id="1845c94e71026f36d7237c0f0214aa3d8c3ce37d" translate="yes" xml:space="preserve">
          <source>Booleans: like &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">布尔值： &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7494e6ec8cd7b2eb5a14c1e063217659a8a1ed3a" translate="yes" xml:space="preserve">
          <source>Broken example:</source>
          <target state="translated">破例。</target>
        </trans-unit>
        <trans-unit id="f031d4d730e754281da3ddefefd685153cc7e2c0" translate="yes" xml:space="preserve">
          <source>But Flow should understand that this function cannot invalidate this refinement, right?</source>
          <target state="translated">但是Flow应该明白,这个函数不能让这个精炼无效吧?</target>
        </trans-unit>
        <trans-unit id="421430d7200437b9bff784aea6c385eb54e83ace" translate="yes" xml:space="preserve">
          <source>But JavaScript ignores these comments, so all it has is the valid syntax.</source>
          <target state="translated">但JavaScript会忽略这些注释,所以它只有有效的语法。</target>
        </trans-unit>
        <trans-unit id="9bcf9a6dad7d351fd124803ac3fa5511232e6ff7" translate="yes" xml:space="preserve">
          <source>But as soon as you change the shape it will start to cause errors.</source>
          <target state="translated">但只要你一改变形状就会开始出错。</target>
        </trans-unit>
        <trans-unit id="961b391c2d9d40cf6976473efc025458ffadca5a" translate="yes" xml:space="preserve">
          <source>But now we have a problem. Our &lt;code&gt;typeof obj&lt;/code&gt; annotation also gets this new annotation which defeats the entire purpose.</source>
          <target state="translated">但是现在我们有一个问题。我们的 &lt;code&gt;typeof obj&lt;/code&gt; 注释也获得了这个新注释，这违背了整个目的。</target>
        </trans-unit>
        <trans-unit id="0a7b7f1f4fc53f9d61a2d8e4846e79d6d5218c5c" translate="yes" xml:space="preserve">
          <source>But suppose you only want to allow strings in your function. For that you can add types.</source>
          <target state="translated">但假设你只想在你的函数中允许使用字符串。为此,你可以添加类型。</target>
        </trans-unit>
        <trans-unit id="eeada9e2d3835e3320e9297e7d171eb9198c4546" translate="yes" xml:space="preserve">
          <source>But we also need to compare the types of the values. If both objects had a key &lt;code&gt;foo&lt;/code&gt; but one was a &lt;code&gt;number&lt;/code&gt; and the other was a &lt;code&gt;string&lt;/code&gt;, then one would not be the subtype of the other.</source>
          <target state="translated">但是我们还需要比较值的类型。如果两个对象都具有键 &lt;code&gt;foo&lt;/code&gt; ,但一个对象是 &lt;code&gt;number&lt;/code&gt; ，而另一个对象是 &lt;code&gt;string&lt;/code&gt; ，则一个对象将不是另一个的子类型。</target>
        </trans-unit>
        <trans-unit id="0b1dae6be8224d27747e5314d54153e505cce8cb" translate="yes" xml:space="preserve">
          <source>But when objects are sealed, Flow will not allow you to add new properties to them.</source>
          <target state="translated">但是当对象被封印时,Flow将不允许你为其添加新的属性。</target>
        </trans-unit>
        <trans-unit id="66ff1b2d0fd5745355740b15ee2b612dc315d816" translate="yes" xml:space="preserve">
          <source>But when you have properties that overlap by having the same name, it creates an intersection of the property type as well.</source>
          <target state="translated">但当你有的属性因名称相同而重叠时,也会产生属性类型的交集。</target>
        </trans-unit>
        <trans-unit id="30753facf6dcd87d6a5e7d8483dce119cb47531c" translate="yes" xml:space="preserve">
          <source>But when you use &lt;code&gt;typeof&lt;/code&gt;, you&amp;rsquo;re taking the results of Flow&amp;rsquo;s inference and asserting it as a type. While this can be very useful, it can also lead to some unexpected results.</source>
          <target state="translated">但是，当您使用 &lt;code&gt;typeof&lt;/code&gt; 时，您将获得Flow推断的结果并将其断言为类型。尽管这可能非常有用，但也可能导致一些意外的结果。</target>
        </trans-unit>
        <trans-unit id="402c1e1505aa711e14641f9e0cbdd3c126cb8608" translate="yes" xml:space="preserve">
          <source>But you can use any to cast to whatever type you want.</source>
          <target state="translated">但你可以使用任何施放到任何你想要的类型。</target>
        </trans-unit>
        <trans-unit id="380728668d9cfaeeebed3b2bcfa77a400e52a7a2" translate="yes" xml:space="preserve">
          <source>But you can&amp;rsquo;t possibly create a value which is both a &lt;em&gt;number and a string&lt;/em&gt;, but you can create a type for it. There&amp;rsquo;s no practical use for creating types like this, but it&amp;rsquo;s a side effect of how intersection types work.</source>
          <target state="translated">但是您不可能创建一个既是&lt;em&gt;数字又是字符串的值&lt;/em&gt;，但是可以为其创建类型。创建这样的类型没有实际用途，但这是交集类型如何工作的副作用。</target>
        </trans-unit>
        <trans-unit id="a559e18c54711bce2c3c1b5537b218d29bf4a48b" translate="yes" xml:space="preserve">
          <source>But you&amp;rsquo;ll want to use more specific types for your actions using disjoint unions and each individual type of action.</source>
          <target state="translated">但是，您将需要使用不相交的并集和每种单独的操作类型来对操作使用更特定的类型。</target>
        </trans-unit>
        <trans-unit id="75d7327a8eec333652ce1fe3a29a224e1b4e6477" translate="yes" xml:space="preserve">
          <source>By casting the value to any, you can then cast to whatever you want.</source>
          <target state="translated">通过将数值投向任何,你就可以投向任何你想要的东西。</target>
        </trans-unit>
        <trans-unit id="ea11ddf576cb4458685c2b63ba3622020aced4f3" translate="yes" xml:space="preserve">
          <source>By checking every possible value, Flow might catch errors that will not actually occur when the code is run. Flow does this in order to be &lt;em&gt;&amp;ldquo;sound&amp;rdquo;&lt;/em&gt;.</source>
          <target state="translated">通过检查每个可能的值，Flow可能会捕获在运行代码时实际上不会发生的错误。Flow这样做是为了&lt;em&gt;&amp;ldquo;听起来&amp;rdquo;&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="888a90a8461cf1dcf2dfa9475b824abf2a140082" translate="yes" xml:space="preserve">
          <source>By checking the typeof our value and testing to see if it is a number, Flow knows that inside of that block it is only a number. We can then write code which treats our value as a number inside of that block.</source>
          <target state="translated">通过检查我们的值的类型并测试它是否是一个数字,Flow知道在该块中它只是一个数字。然后我们就可以编写代码,在该块中把我们的值当作一个数字。</target>
        </trans-unit>
        <trans-unit id="41e166bbfa292c608c082d1714c483c0896b791e" translate="yes" xml:space="preserve">
          <source>By default it is 536870912 (2^29 bytes, which is half a gigabyte).</source>
          <target state="translated">默认情况下是536870912(2^29字节,即半GB)。</target>
        </trans-unit>
        <trans-unit id="50633f3514931f4fa2e84559a298e46e3f897949" translate="yes" xml:space="preserve">
          <source>By default this is 0.</source>
          <target state="translated">默认情况下是0。</target>
        </trans-unit>
        <trans-unit id="15c3b3f03676e9fef47c839d9f3979c86d9e53d7" translate="yes" xml:space="preserve">
          <source>By default this is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">默认情况下为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="53bf9ecbf110fc31e84ab1d4ed08e51aaa3096ed" translate="yes" xml:space="preserve">
          <source>By default this option is set to &lt;code&gt;/dev/shm&lt;/code&gt; and &lt;code&gt;/tmp&lt;/code&gt;</source>
          <target state="translated">默认情况下，此选项设置为 &lt;code&gt;/dev/shm&lt;/code&gt; 和 &lt;code&gt;/tmp&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c9574b97e4aad17c08cdb93e1e1659dc17a8a5d" translate="yes" xml:space="preserve">
          <source>By default when you re-assign a variable, Flow will give it the type of all possible assignments.</source>
          <target state="translated">默认情况下,当你重新赋值一个变量时,Flow会给它所有可能赋值的类型。</target>
        </trans-unit>
        <trans-unit id="134864792720213ebc4bc0075f47cc4f80136ea2" translate="yes" xml:space="preserve">
          <source>By default, Flow will look for files with the extensions &lt;code&gt;.js&lt;/code&gt;, &lt;code&gt;.jsx&lt;/code&gt;, &lt;code&gt;.mjs&lt;/code&gt; and &lt;code&gt;.json&lt;/code&gt;. You can override this behavior with this option.</source>
          <target state="translated">默认情况下，流量会寻找与扩展名的文件 &lt;code&gt;.js&lt;/code&gt; ， &lt;code&gt;.jsx&lt;/code&gt; ， &lt;code&gt;.mjs&lt;/code&gt; 和 &lt;code&gt;.json&lt;/code&gt; 。您可以使用此选项覆盖此行为。</target>
        </trans-unit>
        <trans-unit id="797f4d9748a7b5ec9d7eb76937c9172242bd34b1" translate="yes" xml:space="preserve">
          <source>By default, Flow will look for files with the extensions &lt;code&gt;.js&lt;/code&gt;, &lt;code&gt;.jsx&lt;/code&gt;, &lt;code&gt;.mjs&lt;/code&gt;, &lt;code&gt;.cjs&lt;/code&gt; and &lt;code&gt;.json&lt;/code&gt;. You can override this behavior with this option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c01f8c4e09478deb33d4af8e9963cfec032edd46" translate="yes" xml:space="preserve">
          <source>By default, Flow will look in directories named &lt;code&gt;node_modules&lt;/code&gt; for node modules. You can configure this behavior with this option.</source>
          <target state="translated">默认情况下，Flow将在名为 &lt;code&gt;node_modules&lt;/code&gt; 的目录中查找节点模块。您可以使用此选项配置此行为。</target>
        </trans-unit>
        <trans-unit id="09b5075116fd3869d9cadd377bad839d72504028" translate="yes" xml:space="preserve">
          <source>By default, the Flow server will typecheck all your code. This way it can answer questions like &amp;ldquo;are there any Flow errors anywhere in my code&amp;rdquo;. This is very useful for tooling, like a continuous integration hook which prevents code changes which introduce Flow errors.</source>
          <target state="translated">默认情况下，Flow服务器将对所有代码进行类型检查。这样，它可以回答诸如&amp;ldquo;我的代码中是否存在任何Flow错误&amp;rdquo;之类的问题。这对于工具来说非常有用，例如连续集成挂钩可以防止代码更改而导致Flow错误。</target>
        </trans-unit>
        <trans-unit id="fd76a70149a54159a0fc3b1090cb3ea08262b1cc" translate="yes" xml:space="preserve">
          <source>By default, this is set to 19 (Table size is 2^19, which is 8 megabytes)</source>
          <target state="translated">默认情况下,设置为19(表的大小为2^19,也就是8兆)。</target>
        </trans-unit>
        <trans-unit id="7ff7ddf4cc91afce590edc441693a3db98fd3736" translate="yes" xml:space="preserve">
          <source>By default, this is set to 26843545600 (25 * 2^30 bytes, which is 25GiB)</source>
          <target state="translated">默认设置为26843545600(25*2^30字节,即25GiB)。</target>
        </trans-unit>
        <trans-unit id="acbb4b73f95bada54b37ed5bbd4fe52f109cb99a" translate="yes" xml:space="preserve">
          <source>CLI Commands</source>
          <target state="translated">CLI命令</target>
        </trans-unit>
        <trans-unit id="6d43703db2da8bdf8468b95d1594c5dba316eb10" translate="yes" xml:space="preserve">
          <source>Calculates a config object from props and default props. This is most useful for annotating HOCs that are abstracted over configs. See our &lt;a href=&quot;../hoc&quot;&gt;docs on writing HOCs&lt;/a&gt; for more information.</source>
          <target state="translated">根据道具和默认道具计算配置对象。这对于注释通过配置抽象的HOC最为有用。有关更多信息，请参见&lt;a href=&quot;../hoc&quot;&gt;有关编写HOC&lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="97da5c1835399f071d43358b9774ddca050daf60" translate="yes" xml:space="preserve">
          <source>Callable Objects</source>
          <target state="translated">可调用对象</target>
        </trans-unit>
        <trans-unit id="3a313789e66d78fc3c3729e779158ab414b6007d" translate="yes" xml:space="preserve">
          <source>Callable objects can be typed, for example:</source>
          <target state="translated">例如,可调用对象可以是类型化的。</target>
        </trans-unit>
        <trans-unit id="1e3dda98f28093e22a6a934530588e573abb8f00" translate="yes" xml:space="preserve">
          <source>Calling an overloaded function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c139cc9f6d79ac3a638f7ccf61f2b9637d567c2a" translate="yes" xml:space="preserve">
          <source>Cannot use mutating array methods on tuples</source>
          <target state="translated">不能在元组上使用突变数组方法。</target>
        </trans-unit>
        <trans-unit id="ee70a9dd51b9b3a375656ccfb82a0044b5db1ef2" translate="yes" xml:space="preserve">
          <source>Caret ranges, which allow changes that do not modify the left-most non-zero digit (e.g. &lt;code&gt;^0.13.0&lt;/code&gt; expands into &lt;code&gt;&amp;gt;=0.13.0 &amp;lt;0.14.0&lt;/code&gt;, and &lt;code&gt;^0.13.1&lt;/code&gt; expands into &lt;code&gt;&amp;gt;=0.13.1 &amp;lt;0.14.0&lt;/code&gt;, whereas &lt;code&gt;^1.2.3&lt;/code&gt; expands into &lt;code&gt;&amp;gt;=1.2.3 &amp;lt;2.0.0&lt;/code&gt;).</source>
          <target state="translated">插入符范围，允许更改不修改最左边的非零数字（例如 &lt;code&gt;^0.13.0&lt;/code&gt; 扩展为 &lt;code&gt;&amp;gt;=0.13.0 &amp;lt;0.14.0&lt;/code&gt; ，而 &lt;code&gt;^0.13.1&lt;/code&gt; 扩展为 &lt;code&gt;&amp;gt;=0.13.1 &amp;lt;0.14.0&lt;/code&gt; ，而 &lt;code&gt;^1.2.3&lt;/code&gt; 扩展为 &lt;code&gt;&amp;gt;=1.2.3 &amp;lt;2.0.0&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6fe0f312fa3428aa6c4fdee3743c37967749d48e" translate="yes" xml:space="preserve">
          <source>Check Your Code</source>
          <target state="translated">检查您的代码</target>
        </trans-unit>
        <trans-unit id="b73433b77514508ea8a1cefa58845c9ce4425fe1" translate="yes" xml:space="preserve">
          <source>Check out the &lt;a href=&quot;https://flow.org/en/linting&quot;&gt;linting docs&lt;/a&gt; for more information.</source>
          <target state="translated">查看&lt;a href=&quot;https://flow.org/en/linting&quot;&gt;linting文档&lt;/a&gt;以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="18c18b8a20dbe7477ce5e5b3ea1624b99b154cdc" translate="yes" xml:space="preserve">
          <source>Checks JavaScript files for type errors on save</source>
          <target state="translated">在保存时检查JavaScript文件是否有类型错误</target>
        </trans-unit>
        <trans-unit id="dcf75191c585bfb6059ad203f7ce5630a589a405" translate="yes" xml:space="preserve">
          <source>Children</source>
          <target state="translated">Children</target>
        </trans-unit>
        <trans-unit id="ea7d82eca3471176f477c2cedc92c146814951f8" translate="yes" xml:space="preserve">
          <source>Choosing Focused Files</source>
          <target state="translated">选择重点文件</target>
        </trans-unit>
        <trans-unit id="dd9e83c06b2948588c35a377c68a9e504e82cd53" translate="yes" xml:space="preserve">
          <source>Class Components</source>
          <target state="translated">类组件</target>
        </trans-unit>
        <trans-unit id="a292b9b612431489a82ca75b9a01310364d94fec" translate="yes" xml:space="preserve">
          <source>Class Fields (Properties)</source>
          <target state="translated">类字段(属性</target>
        </trans-unit>
        <trans-unit id="c29b94bc81534772a515451e3a6176277b7a484c" translate="yes" xml:space="preserve">
          <source>Class Generics</source>
          <target state="translated">通用类</target>
        </trans-unit>
        <trans-unit id="3d9f77136533c6ff7b7e86c9e68a8e0e99ad867e" translate="yes" xml:space="preserve">
          <source>Class Methods</source>
          <target state="translated">类方法</target>
        </trans-unit>
        <trans-unit id="00da90a4700b284083533dbd6e4a5418d77ae7c4" translate="yes" xml:space="preserve">
          <source>Class Syntax</source>
          <target state="translated">类语法</target>
        </trans-unit>
        <trans-unit id="970423396db9a5db3ab146030f36eab03c9bccf9" translate="yes" xml:space="preserve">
          <source>Class Types</source>
          <target state="translated">班级类型</target>
        </trans-unit>
        <trans-unit id="7ef245513b7358326754969c6ff56632c31d10bb" translate="yes" xml:space="preserve">
          <source>Class generics are &lt;a href=&quot;../generics#toc-parameterized-generics&quot;&gt;parameterized&lt;/a&gt;. When you use a class as a type you need to pass parameters for each of its generics.</source>
          <target state="translated">类泛型已&lt;a href=&quot;../generics#toc-parameterized-generics&quot;&gt;参数化&lt;/a&gt;。将类用作类型时，需要为每个类传递参数。</target>
        </trans-unit>
        <trans-unit id="1ac68839be9322d234cbe8b1175e8660eac2c1db" translate="yes" xml:space="preserve">
          <source>Classes (when being used as a type), type aliases, and interfaces all require that you pass type arguments. Functions and function types do not have parameterized generics.</source>
          <target state="translated">类(当作为类型使用时)、类型别名和接口都需要你传递类型参数。函数和函数类型没有参数化的属类。</target>
        </trans-unit>
        <trans-unit id="3164faf12698fd9d5a1ee175d4e32c8f3b28733b" translate="yes" xml:space="preserve">
          <source>Classes are nominally typed</source>
          <target state="translated">班级名义上的类型是</target>
        </trans-unit>
        <trans-unit id="09580fd8cc5532206f6976398f34d1aa760f93c6" translate="yes" xml:space="preserve">
          <source>Classes can also have their own &lt;a href=&quot;../generics&quot;&gt;generics&lt;/a&gt;.</source>
          <target state="translated">类也可以有自己的&lt;a href=&quot;../generics&quot;&gt;泛型&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5fda3adeadc4a4501aa999874c1179a4ba1c688c" translate="yes" xml:space="preserve">
          <source>Classes can create generics by placing the type parameter list before the body of the class.</source>
          <target state="translated">类可以通过将类型参数列表放在类的主体之前来创建属类。</target>
        </trans-unit>
        <trans-unit id="1b808e1e4ae68ed6db8b6f4a3b08980e0757a73a" translate="yes" xml:space="preserve">
          <source>Classes in Flow are identical to normal JavaScript classes, but with added types.</source>
          <target state="translated">Flow中的类与普通JavaScript类相同,但增加了类型。</target>
        </trans-unit>
        <trans-unit id="452b035012ae20e8fba0cecbb4575853da83a21c" translate="yes" xml:space="preserve">
          <source>Classes in Flow are nominally typed. This means that when you have two separate classes you cannot use one in place of the other even when they have the same exact properties and methods.</source>
          <target state="translated">Flow中的类名义上是类型化的,这意味着当你有两个独立的类时,你不能用一个代替另一个,即使它们有相同的属性和方法。这意味着当你有两个独立的类时,你不能用一个来代替另一个,即使它们有完全相同的属性和方法。</target>
        </trans-unit>
        <trans-unit id="cd71068bccd40b5b60ee9b0cf1c42470216943f4" translate="yes" xml:space="preserve">
          <source>Classes in annotations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c07a614cc79da75bb9b47692238ba51e242a3c47" translate="yes" xml:space="preserve">
          <source>Classes with generics</source>
          <target state="translated">有属相的类别</target>
        </trans-unit>
        <trans-unit id="a3966ac02425c85de4503912eef3010180d093f6" translate="yes" xml:space="preserve">
          <source>Classifying Files</source>
          <target state="translated">文件分类</target>
        </trans-unit>
        <trans-unit id="4060649bc0fbf1a753996c990ce6ff425ec633c7" translate="yes" xml:space="preserve">
          <source>Comment Types</source>
          <target state="translated">类型如何</target>
        </trans-unit>
        <trans-unit id="e20aa320a16fc33b19be9bd963333288cc2fbcd3" translate="yes" xml:space="preserve">
          <source>Comment support was added in v0.23.0. Lines beginning with zero or more spaces followed by an &lt;code&gt;#&lt;/code&gt; or &lt;code&gt;;&lt;/code&gt; or &lt;code&gt;💩&lt;/code&gt; are ignored. For example:</source>
          <target state="translated">v0.23.0中添加了注释支持。以零个或多个空格开头的行，后跟 &lt;code&gt;#&lt;/code&gt; 或 &lt;code&gt;;&lt;/code&gt; 或 &lt;code&gt;💩&lt;/code&gt; 被忽略。例如：</target>
        </trans-unit>
        <trans-unit id="7a3c18b9e3a38eaea2ce3317736de762da172d50" translate="yes" xml:space="preserve">
          <source>Comment type annotation</source>
          <target state="translated">注释类型</target>
        </trans-unit>
        <trans-unit id="3fdb12dbd0fc63c594f614d2015983c4d8a7cc47" translate="yes" xml:space="preserve">
          <source>Comment type include</source>
          <target state="translated">评论类型包括</target>
        </trans-unit>
        <trans-unit id="2a30d59a808479157403fbf163a7b1b950362562" translate="yes" xml:space="preserve">
          <source>Comment types syntax</source>
          <target state="translated">语法类型如何</target>
        </trans-unit>
        <trans-unit id="fce06e20e5f7f74aacccab40b59b75a56c8f7305" translate="yes" xml:space="preserve">
          <source>Comments</source>
          <target state="translated">Comments</target>
        </trans-unit>
        <trans-unit id="77cd370c5563644ed24d98dbd212c70fede32f4e" translate="yes" xml:space="preserve">
          <source>CommonJS modules have a single value that is exported (the &lt;code&gt;module.exports&lt;/code&gt; value). To describe the type of this single value within a &lt;code&gt;declare module&lt;/code&gt; body, you&amp;rsquo;ll use the &lt;code&gt;declare module.exports&lt;/code&gt; syntax:</source>
          <target state="translated">CommonJS模块具有一个导出的值（ &lt;code&gt;module.exports&lt;/code&gt; 值）。要在 &lt;code&gt;declare module&lt;/code&gt; 主体中描述此单个值的类型，您将使用 &lt;code&gt;declare module.exports&lt;/code&gt; 语法：</target>
        </trans-unit>
        <trans-unit id="9289473eeedaee09d76c8cf1b6994d8550debf46" translate="yes" xml:space="preserve">
          <source>Components</source>
          <target state="translated">Components</target>
        </trans-unit>
        <trans-unit id="defd3903dafc585dcec1a9aae0635fe10d9c6241" translate="yes" xml:space="preserve">
          <source>Conceptually one can think of declaration mode as if Flow still typechecks the files but acts as if there is a comment that matches &lt;a href=&quot;../options#toc-suppress-comment-regex&quot;&gt;&lt;code&gt;suppress_comment&lt;/code&gt;&lt;/a&gt; on every line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="357ded9bfca85d8cbd26f40a3524ddda69561b80" translate="yes" xml:space="preserve">
          <source>Conceptually one can think of declaration mode as if Flow still typechecks the files but acts as if there is a comment that matches &lt;code&gt;suppress_comment&lt;/code&gt; on every line.</source>
          <target state="translated">从概念上一个能想到的申报模式，如果仍然流动的typechecks文件，但作为是否有评论认为比赛 &lt;code&gt;suppress_comment&lt;/code&gt; 在每一行。</target>
        </trans-unit>
        <trans-unit id="754164850f38c1ecdaf6b8ed894cb192bc36c5f4" translate="yes" xml:space="preserve">
          <source>Configuration</source>
          <target state="translated">Configuration</target>
        </trans-unit>
        <trans-unit id="17e8e4decf7d96f7f04f6c0aaf456c37aae4e8a7" translate="yes" xml:space="preserve">
          <source>Configure ALE to use the &lt;code&gt;flow-language-server&lt;/code&gt; linter for JavaScript files:</source>
          <target state="translated">配置ALE以将 &lt;code&gt;flow-language-server&lt;/code&gt; linter用于JavaScript文件：</target>
        </trans-unit>
        <trans-unit id="b41a81e0d51029fe68417fdfc1818a6ce70ba9c2" translate="yes" xml:space="preserve">
          <source>Configuring Lints from the CLI</source>
          <target state="translated">从CLI配置Lints</target>
        </trans-unit>
        <trans-unit id="8e2382fbc54df1efc6f7e32e65cd9c5d7c95a4c6" translate="yes" xml:space="preserve">
          <source>Configuring Lints in the &lt;code&gt;.flowconfig&lt;/code&gt;</source>
          <target state="translated">在 &lt;code&gt;.flowconfig&lt;/code&gt; 中配置Lints</target>
        </trans-unit>
        <trans-unit id="100fcd8a929b3ce3c89e968bb90a967ea5146ece" translate="yes" xml:space="preserve">
          <source>Configuring Lints with Comments</source>
          <target state="translated">配置带有注释的林茨</target>
        </trans-unit>
        <trans-unit id="ea1be7edf59f5de51b594f9fbae2368f8449e70c" translate="yes" xml:space="preserve">
          <source>Configuring lint settings with &lt;code&gt;flowlint&lt;/code&gt; comments allows you to specify different settings within a file and different settings to different regions of different files. These comments come in three forms:</source>
          <target state="translated">使用 &lt;code&gt;flowlint&lt;/code&gt; 注释配置棉绒设置可让您在文件中指定不同的设置，并为不同文件的不同区域指定不同的设置。这些评论分为三种形式：</target>
        </trans-unit>
        <trans-unit id="5459dd4dd0d0aff9d4c5e0bb04ffd680814c6d9f" translate="yes" xml:space="preserve">
          <source>Consider a &lt;code&gt;TypeLetters&lt;/code&gt; which described the strings: &amp;ldquo;A&amp;rdquo;, &amp;ldquo;B&amp;rdquo;, &amp;ldquo;C&amp;rdquo;, and a &lt;code&gt;TypeNumbers&lt;/code&gt; which described the numbers: 1, 2, 3. Neither of them would be a subtype of the other, as they each contain a completely different set of values.</source>
          <target state="translated">考虑一个描述字符串的 &lt;code&gt;TypeLetters&lt;/code&gt; ：&amp;ldquo; A&amp;rdquo;，&amp;ldquo; B&amp;rdquo;，&amp;ldquo; C&amp;rdquo;和一个描述数字的 &lt;code&gt;TypeNumbers&lt;/code&gt; ：1、2、3。它们都不是另一个的子类型，因为它们每个都包含一个完全不同的一组值。</target>
        </trans-unit>
        <trans-unit id="cc11b3a28fa30ae6d3d3ad1438824cbd5224ba5c" translate="yes" xml:space="preserve">
          <source>Context</source>
          <target state="translated">Context</target>
        </trans-unit>
        <trans-unit id="bd6cc06a58d88fe388d82365f6c350095732e612" translate="yes" xml:space="preserve">
          <source>Contravariance</source>
          <target state="translated">Contravariance</target>
        </trans-unit>
        <trans-unit id="cb180a0b2985d8db3f02bd050b0c5682ab094c05" translate="yes" xml:space="preserve">
          <source>Contravariance &lt;em&gt;does not&lt;/em&gt; accept &lt;strong&gt;subtypes&lt;/strong&gt;.</source>
          <target state="translated">协方差&lt;em&gt;不&lt;/em&gt;接受&lt;strong&gt;子类型&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="c1af28bd0de937b51db3bbee9579b53603a2e45c" translate="yes" xml:space="preserve">
          <source>Contravariance &lt;em&gt;does&lt;/em&gt; accept &lt;strong&gt;supertypes&lt;/strong&gt;.</source>
          <target state="translated">协变性&lt;em&gt;确实&lt;/em&gt;接受&lt;strong&gt;超类型&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="f1840a661bb88bcb72aa63857962824a747fab2e" translate="yes" xml:space="preserve">
          <source>Contravariant (write-only) properties on interfaces</source>
          <target state="translated">接口上的共变(只写)属性。</target>
        </trans-unit>
        <trans-unit id="d37d133ea5c1b52753b3893f902c233ee8442bb5" translate="yes" xml:space="preserve">
          <source>Covariance</source>
          <target state="translated">Covariance</target>
        </trans-unit>
        <trans-unit id="2f10ee60c3d51dffb8e99aab19b27d99124ad7c4" translate="yes" xml:space="preserve">
          <source>Covariance &lt;em&gt;does not&lt;/em&gt; accept &lt;strong&gt;supertypes&lt;/strong&gt;.</source>
          <target state="translated">协方差&lt;em&gt;不&lt;/em&gt;接受&lt;strong&gt;超类型&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="a1fa2bb1d0052e924cece0736a3a2248a64883bc" translate="yes" xml:space="preserve">
          <source>Covariance &lt;em&gt;does&lt;/em&gt; accept &lt;strong&gt;subtypes&lt;/strong&gt;.</source>
          <target state="translated">协方差&lt;em&gt;确实&lt;/em&gt;接受&lt;strong&gt;子类型&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="6a3e204ca6009adaaa624087ce1b64b315a8aef0" translate="yes" xml:space="preserve">
          <source>Covariant (read-only) properties on interfaces</source>
          <target state="translated">接口上的共变(只读)属性</target>
        </trans-unit>
        <trans-unit id="a1d8b1686c9450f38df6ec567189c88fa8e65f62" translate="yes" xml:space="preserve">
          <source>Create React App</source>
          <target state="translated">创建React应用</target>
        </trans-unit>
        <trans-unit id="0bf0dd44b7766be1f57889796955a258d3203142" translate="yes" xml:space="preserve">
          <source>Create as many generics as you need</source>
          <target state="translated">根据您的需要,创建任意数量的仿制药</target>
        </trans-unit>
        <trans-unit id="03ce361cea65e5018df3a6c27de3a6593ce0f4ed" translate="yes" xml:space="preserve">
          <source>Creating Library Definitions</source>
          <target state="translated">创建库定义</target>
        </trans-unit>
        <trans-unit id="2f52e43b6882a3466f1d969c1cb1001473303ede" translate="yes" xml:space="preserve">
          <source>Declaration Files</source>
          <target state="translated">声明文件</target>
        </trans-unit>
        <trans-unit id="6c41a0185a4a9cfa2f6df6a748ac7876baa85cb0" translate="yes" xml:space="preserve">
          <source>Declaration mode should only be used for existing third-party code. You should never use this for code under your control.</source>
          <target state="translated">声明模式只能用于现有的第三方代码。您永远不要将此模式用于您控制下的代码。</target>
        </trans-unit>
        <trans-unit id="7377158aaae022f9ae166beb589c5befa8f2034b" translate="yes" xml:space="preserve">
          <source>Declaring A CommonJS Module</source>
          <target state="translated">声明一个CommonJS模块</target>
        </trans-unit>
        <trans-unit id="e7912896131236a8a65370bdd893e2009c32c266" translate="yes" xml:space="preserve">
          <source>Declaring A Global Class</source>
          <target state="translated">声明一个全局类</target>
        </trans-unit>
        <trans-unit id="cf300a0c751ae6bb5689acc80a14bec33cc3173d" translate="yes" xml:space="preserve">
          <source>Declaring A Global Function</source>
          <target state="translated">声明一个全局函数</target>
        </trans-unit>
        <trans-unit id="fa2144a7e4ab0959082b21d1945383339a3043f8" translate="yes" xml:space="preserve">
          <source>Declaring A Global Type</source>
          <target state="translated">声明一个全局类型</target>
        </trans-unit>
        <trans-unit id="f140a982a9c52716db37b4e9e5e30630eacfa6f6" translate="yes" xml:space="preserve">
          <source>Declaring A Global Variable</source>
          <target state="translated">声明一个全局变量</target>
        </trans-unit>
        <trans-unit id="cf71778c169e234024b86addcbe9ddb1f9d5a9b2" translate="yes" xml:space="preserve">
          <source>Declaring A Module</source>
          <target state="translated">声明一个模块</target>
        </trans-unit>
        <trans-unit id="e4ce9329aeac94bfdbc95574fafe7358b946c293" translate="yes" xml:space="preserve">
          <source>Declaring An ES Module</source>
          <target state="translated">声明一个ES模块</target>
        </trans-unit>
        <trans-unit id="e5cd6d8f44e29ee7fdbc14dbc19c634c427bceed" translate="yes" xml:space="preserve">
          <source>Declaring overloaded functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af087002f31d0ea4e967c16e89ad0e158cdeb097" translate="yes" xml:space="preserve">
          <source>Default Exports</source>
          <target state="translated">默认出口</target>
        </trans-unit>
        <trans-unit id="7f3b8d79c1988be2a2ba2d6f29be574f525f239e" translate="yes" xml:space="preserve">
          <source>Defines a magical comment that suppresses any Flow errors on the following line. For example:</source>
          <target state="translated">定义了一个神奇的注释,可以抑制下面一行的任何Flow错误。例如</target>
        </trans-unit>
        <trans-unit id="b4e96ce5110d5704ac6b16c56748c7a82fa4b290" translate="yes" xml:space="preserve">
          <source>Depth Subtyping</source>
          <target state="translated">深度分型</target>
        </trans-unit>
        <trans-unit id="bb3a537f6961c44f6476a0cf4c7c5e6d20651cc7" translate="yes" xml:space="preserve">
          <source>Detailed guides, tips, and resources on how to integrate Flow with different JavaScript tools.</source>
          <target state="translated">关于如何将Flow与不同的JavaScript工具集成的详细指南、技巧和资源。</target>
        </trans-unit>
        <trans-unit id="5397d84bf20e2c90a75c1c0e9296db893360d2d5" translate="yes" xml:space="preserve">
          <source>Detailed guides, tips, and resources on how to integrate Flow with different code editors.</source>
          <target state="translated">关于如何将Flow与不同代码编辑器集成的详细指南、技巧和资源。</target>
        </trans-unit>
        <trans-unit id="07b29e4715401afbf688a87a35ce231b8ef245ab" translate="yes" xml:space="preserve">
          <source>Developers like coding in JavaScript because it helps them move fast. The language facilitates fast prototyping of ideas via dynamic typing. The runtime provides the means for fast iteration on those ideas via dynamic compilation. This fuels a fast edit-refresh cycle, which promises an immersive coding experience that is quite appealing to creative developers.</source>
          <target state="translated">开发人员喜欢用JavaScript编码,因为它能帮助他们快速移动。该语言通过动态类型化促进了想法的快速原型化。运行时通过动态编译为这些想法提供快速迭代的手段。这促进了快速的编辑-刷新周期,保证了沉浸式的编码体验,这对有创造力的开发人员来说相当有吸引力。</target>
        </trans-unit>
        <trans-unit id="d112a1cd5683bcc108f9cd368dc51e0007d4b649" translate="yes" xml:space="preserve">
          <source>Developers will often use Flow and React together, so it is important that Flow can effectively type both common and advanced React patterns. This guide will teach you how to use Flow to create safer React applications.</source>
          <target state="translated">开发人员经常会将Flow和React一起使用,所以Flow能有效地打出常见的和高级的React模式很重要。本指南将教你如何使用Flow来创建更安全的React应用。</target>
        </trans-unit>
        <trans-unit id="1e6b556971ea4a33002387413d405d2f43ba4f6b" translate="yes" xml:space="preserve">
          <source>Different sections are available to specify different behaviours, and by combining them most use cases are expected to be met.</source>
          <target state="translated">不同的部分可用于指定不同的行为,通过将它们结合起来,大多数用例有望得到满足。</target>
        </trans-unit>
        <trans-unit id="13f50eb9f26820d014db96a7378f60b1d9165a9e" translate="yes" xml:space="preserve">
          <source>Disjoint Unions</source>
          <target state="translated">互不相干的联盟</target>
        </trans-unit>
        <trans-unit id="1a7f91bafa50063f1996b902994e106982ff9d56" translate="yes" xml:space="preserve">
          <source>Disjoint unions require you to use a single property to distinguish each object type. You cannot distinguish two different objects by different properties.</source>
          <target state="translated">不相干的联合要求您使用单一属性来区分每个对象类型。你不能用不同的属性来区分两个不同的对象。</target>
        </trans-unit>
        <trans-unit id="e9068ebe4e81ef4f2881aa16d8729d7d6e800dff" translate="yes" xml:space="preserve">
          <source>Disjoint unions with exact types</source>
          <target state="translated">具有精确类型的不相联</target>
        </trans-unit>
        <trans-unit id="aa4adede3310c0d7e145943b47a01ec740a946a3" translate="yes" xml:space="preserve">
          <source>Each line in the &lt;code&gt;[libs]&lt;/code&gt; section is a path to the library file or directory which you would like to include. These paths can be relative to the project root directory or absolute. Including a directory recursively includes all the files under that directory as library files.</source>
          <target state="translated">&lt;code&gt;[libs]&lt;/code&gt; 节中的每一行都是您要包括的库文件或目录的路径。这些路径可以相对于项目根目录，也可以是绝对路径。递归包含目录会将该目录下的所有文件作为库文件包含在内。</target>
        </trans-unit>
        <trans-unit id="9d6d093159b7ee3300d4a97efe8f2b52700a85bb" translate="yes" xml:space="preserve">
          <source>Each line in the above definition is called an &lt;em&gt;overload&lt;/em&gt;, and we say that functions of type &lt;code&gt;Fn&lt;/code&gt; are &lt;em&gt;overloaded&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="099f5c6226bea98d0b45888f6a9ff773168bded9" translate="yes" xml:space="preserve">
          <source>Each of the members of a intersection type can be any type, even another intersection type.</source>
          <target state="translated">交集类型的每个成员可以是任何类型,甚至是另一个交集类型。</target>
        </trans-unit>
        <trans-unit id="9e5ead45d63220a36e13146ef22daf86e2c2fcea" translate="yes" xml:space="preserve">
          <source>Each of the members of a union type can be any type, even another union type.</source>
          <target state="translated">联合类型的每个成员可以是任何类型,甚至是另一个联合类型。</target>
        </trans-unit>
        <trans-unit id="04062df0a5ebcde8394ccd8dfdb3632bb2dce1a6" translate="yes" xml:space="preserve">
          <source>Early in React&amp;rsquo;s history the library provided &lt;a href=&quot;https://facebook.github.io/react/docs/typechecking-with-proptypes.html&quot;&gt;&lt;code&gt;PropTypes&lt;/code&gt;&lt;/a&gt; which performed basic runtime checks. Flow is much more powerful as it can tell you when you are misusing a component without running your code.</source>
          <target state="translated">在React的早期历史中，该库提供了&lt;a href=&quot;https://facebook.github.io/react/docs/typechecking-with-proptypes.html&quot;&gt; &lt;code&gt;PropTypes&lt;/code&gt; &lt;/a&gt;来执行基本的运行时检查。Flow功能强大得多，因为它可以告诉您何时滥用组件而无需运行代码。</target>
        </trans-unit>
        <trans-unit id="d8fbeb27c5847478b31ce446787b9e3281657271" translate="yes" xml:space="preserve">
          <source>Editor plugins are provided and maintained by the community. If you have trouble configuring or using a specific plugin for your IDE, please visit the project&amp;rsquo;s repo or search for a community provided answer.</source>
          <target state="translated">编辑器插件由社区提供和维护。如果您在为IDE配置或使用特定插件时遇到问题，请访问该项目的存储库或搜索社区提供的答案。</target>
        </trans-unit>
        <trans-unit id="ed63036d8730b34c2af3aa53fe984d9883388a1c" translate="yes" xml:space="preserve">
          <source>Editors</source>
          <target state="translated">Editors</target>
        </trans-unit>
        <trans-unit id="d89a5ec1140ce5dd978c2baf15972fdf48b8b61f" translate="yes" xml:space="preserve">
          <source>Emacs</source>
          <target state="translated">Emacs</target>
        </trans-unit>
        <trans-unit id="cf46938375da84aa280715be40f3710755292d16" translate="yes" xml:space="preserve">
          <source>Enables traces on all error output (showing additional details about the flow of types through the system), to the depth specified. This can be very expensive, so is disabled by default.</source>
          <target state="translated">启用跟踪所有错误输出(显示类型在系统中流动的额外细节),深度为指定的深度。这可能是非常昂贵的,所以默认情况下是禁用的。</target>
        </trans-unit>
        <trans-unit id="f2dcc58367a1736e48cc9750d5d4e0f214c570ef" translate="yes" xml:space="preserve">
          <source>Enabling Flow Strict for a file means that several previously-allowed patterns will now trigger a Flow error. Each disallowed pattern has a corresponding &lt;a href=&quot;https://flow.org/en/linting/&quot;&gt;Flow Lint&lt;/a&gt; rule which triggers the error. The list of rules enabled for &lt;code&gt;@flow strict&lt;/code&gt; is configured in each &lt;code&gt;.flowconfig&lt;/code&gt;. Here are the recommended rules:</source>
          <target state="translated">为文件启用&amp;ldquo;严格流&amp;rdquo;意味着现在可以使用多个以前允许的模式来触发流错误。每个不允许的模式都有一个相应的&lt;a href=&quot;https://flow.org/en/linting/&quot;&gt;Flow Lint&lt;/a&gt;规则，该规则会触发错误。在每个 &lt;code&gt;.flowconfig&lt;/code&gt; 中配置为 &lt;code&gt;@flow strict&lt;/code&gt; 启用的规则列表。以下是建议的规则：</target>
        </trans-unit>
        <trans-unit id="9362e9d124ec7b068004f2f5d44579aee1193e70" translate="yes" xml:space="preserve">
          <source>Enabling Flow Strict in a .flowconfig</source>
          <target state="translated">在.flowconfig中启用Flow Strict。</target>
        </trans-unit>
        <trans-unit id="9ed9c052e4c7d570739934a2603ad815a0f3ce54" translate="yes" xml:space="preserve">
          <source>Enforce the following restrictions on file exports:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fe43e985b9f3cede92eed08e9cb385d404eea59" translate="yes" xml:space="preserve">
          <source>Enforcing that a component only gets a single child.</source>
          <target state="translated">强制一个组件只得到一个孩子。</target>
        </trans-unit>
        <trans-unit id="af6da05f12e48d3f287a21a34dc14f0f0b6d9b9d" translate="yes" xml:space="preserve">
          <source>Equally specific inputs and outputs &amp;mdash; Good</source>
          <target state="translated">同样具体的投入和产出-良好</target>
        </trans-unit>
        <trans-unit id="af15d48df82499a8c217556a8e8763e1f598d53a" translate="yes" xml:space="preserve">
          <source>Error Suppressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c01289049ee253c54bfc3dcb7ad87f71ff8dc18" translate="yes" xml:space="preserve">
          <source>Even as we treat our value as just one of the types, we do not get an error because it satisfies all of them.</source>
          <target state="translated">即使我们只把我们的值当作其中一种类型,我们也不会出错,因为它满足了所有的类型。</target>
        </trans-unit>
        <trans-unit id="fe29fc3f9fec6b884383a4b8a8698b488827777d" translate="yes" xml:space="preserve">
          <source>Even code that will cause runtime errors will not be caught by Flow:</source>
          <target state="translated">即使是会导致运行时错误的代码也不会被Flow捕获。</target>
        </trans-unit>
        <trans-unit id="47439ca5ded64f9ae2fef50d130387798195a012" translate="yes" xml:space="preserve">
          <source>Event Handling</source>
          <target state="translated">事件处理</target>
        </trans-unit>
        <trans-unit id="9c18bb5b6450b86bbb2ec82c62983e3decf5661e" translate="yes" xml:space="preserve">
          <source>Eventually, some features of Flow Strict could become the default behavior of Flow, if those features prove successful and achieve widespread adoption.</source>
          <target state="translated">最终,如果Flow Strict的一些功能被证明是成功的,并获得广泛的采用,那么这些功能可能会成为Flow的默认行为。</target>
        </trans-unit>
        <trans-unit id="79794fb5666aa8f0653b4ce2e5a3fce9b026918b" translate="yes" xml:space="preserve">
          <source>Every Flow project contains a &lt;code&gt;.flowconfig&lt;/code&gt; file. You can configure Flow by modifying &lt;code&gt;.flowconfig&lt;/code&gt;. New projects or projects that are starting to use Flow can generate a default &lt;code&gt;.flowconfig&lt;/code&gt; by running &lt;code&gt;flow init&lt;/code&gt;.</source>
          <target state="translated">每个Flow项目都包含一个 &lt;code&gt;.flowconfig&lt;/code&gt; 文件。您可以通过修改 &lt;code&gt;.flowconfig&lt;/code&gt; 来配置Flow 。新项目或开始使用Flow的项目可以通过运行 &lt;code&gt;flow init&lt;/code&gt; 生成默认的 &lt;code&gt;.flowconfig&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5fcb8d8758ed57d0a770a341b51dba1c53659f15" translate="yes" xml:space="preserve">
          <source>Every function in JavaScript can be called with a special context named &lt;code&gt;this&lt;/code&gt;. You can call a function with any context that you want.</source>
          <target state="translated">JavaScript中的每个函数都可以使用名为 &lt;code&gt;this&lt;/code&gt; 的特殊上下文来调用。您可以使用所需的任何上下文来调用函数。</target>
        </trans-unit>
        <trans-unit id="68197336316b778965bfb2950ace8adb822267f0" translate="yes" xml:space="preserve">
          <source>Exact object types</source>
          <target state="translated">确切的对象类型</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="dc536fab9433d34f6445a813d5f0c31792e7fa5f" translate="yes" xml:space="preserve">
          <source>Example (&lt;a href=&quot;https://flow.org/try/#0C4TwDgpgBACghgJzgWygXigbwFBSgI0QC4oB+AZ2AQEsA7AcwBpsBfbAMwFdaBjYagPa0oyEADFuPABTsBAkvCTIAlCUo0GWXFGrsoMuQDpCCZVrx4eQ8gIA2EQ7YH0pAIh4ALCDwDWEACYAhK7KANzaAJAIEMCcCMKyAsaIoVAA9GlQ7E4A7lAQCAgCCOSGUACSeiACnFBWyMgQtMBQwF511nYOTkw6LTnFPuTabHja0bHxUK7+EOxwnLYt6nT0ruEsQA&quot;&gt;https://flow.org/try&lt;/a&gt;):</source>
          <target state="translated">示例（&lt;a href=&quot;https://flow.org/try/#0C4TwDgpgBACghgJzgWygXigbwFBSgI0QC4oB+AZ2AQEsA7AcwBpsBfbAMwFdaBjYagPa0oyEADFuPABTsBAkvCTIAlCUo0GWXFGrsoMuQDpCCZVrx4eQ8gIA2EQ7YH0pAIh4ALCDwDWEACYAhK7KANzaAJAIEMCcCMKyAsaIoVAA9GlQ7E4A7lAQCAgCCOSGUACSeiACnFBWyMgQtMBQwF511nYOTkw6LTnFPuTabHja0bHxUK7+EOxwnLYt6nT0ruEsQA&quot;&gt;https://flow.org/try&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="e72839950b0f419947ce4f283294a67029092005" translate="yes" xml:space="preserve">
          <source>Example (&lt;a href=&quot;https://flow.org/try/#0MYewdgzgLgBAhgEwTAvDAFAMwJYCdoBcMYArgLYBGAprgDQwRWhgJGmU0CUqAfDDvlgBqBk3AIA3AChm0GADc4AGyLRc2MAHMYAH2LlquVDACM02bGwQAcgZrH0ipSSoAVEACUqOMFTZ2jPTUNTU4iAFJgAAsmAGsIXhgoAE8AByoQTAVlF3cvHypUFDQAcnZDEulsLPQrWw5cR2VObkQEJqV6ACZOCSA&quot;&gt;https://flow.org/try&lt;/a&gt;)</source>
          <target state="translated">示例（&lt;a href=&quot;https://flow.org/try/#0MYewdgzgLgBAhgEwTAvDAFAMwJYCdoBcMYArgLYBGAprgDQwRWhgJGmU0CUqAfDDvlgBqBk3AIA3AChm0GADc4AGyLRc2MAHMYAH2LlquVDACM02bGwQAcgZrH0ipSSoAVEACUqOMFTZ2jPTUNTU4iAFJgAAsmAGsIXhgoAE8AByoQTAVlF3cvHypUFDQAcnZDEulsLPQrWw5cR2VObkQEJqV6ACZOCSA&quot;&gt;https://flow.org/try&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="894360e5088d7910eaab73bfa4ad7d6cf97c6f8c" translate="yes" xml:space="preserve">
          <source>Example (&lt;a href=&quot;https://flow.org/try/#0MYewdgzgLgBAhgEwTAvDAFAMwJYCdoBcMYArgLYBGAprgDQwRWhgJGmU0CUqAfDDvlgBqBk3AIA3AChm0GADc4AGyLRc2MAHMYAH2LlquVDACM02bGwQAcgZrH0ipSSoAVEACUqOMFTZ2jPTUNTW4UPigATwAHKhBMBWUXdy8fKlQUNABydkMs6WwE9CtbDlxHZU5uRAQKpXoAJk4JIA&quot;&gt;https://flow.org/try&lt;/a&gt;)</source>
          <target state="translated">示例（&lt;a href=&quot;https://flow.org/try/#0MYewdgzgLgBAhgEwTAvDAFAMwJYCdoBcMYArgLYBGAprgDQwRWhgJGmU0CUqAfDDvlgBqBk3AIA3AChm0GADc4AGyLRc2MAHMYAH2LlquVDACM02bGwQAcgZrH0ipSSoAVEACUqOMFTZ2jPTUNTW4UPigATwAHKhBMBWUXdy8fKlQUNABydkMs6WwE9CtbDlxHZU5uRAQKpXoAJk4JIA&quot;&gt;https://flow.org/try&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="d65710bb9e0679950b0a2fa1e6f5d7c468d7acd2" translate="yes" xml:space="preserve">
          <source>Example (&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQAXAngBwKagAqYE4DOsAdqALygDeAhgOaYBcoA-CQK4C2ARgQL6IAxqULJQWWOmjZKAbVoNmARgBMfADTV6TUEoAcGrYtAqALHwC6AbiEixsaABM8RUsxfEylBToDsABj4bAEtIUAAKB2cCTwA6bQBKakRQUGESUVBtClAoj1J4hhtUiSlMWMhYfABRGkEAC3CsVy8APmTU1PTiaVi4OnCAAwAVeuxmz1BgwlAAEioJgu0+LJJHUGQx3KdckmxpuZ8+QYTi0D4ExD4gA&quot;&gt;https://flow.org/try&lt;/a&gt;):</source>
          <target state="translated">示例（&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQAXAngBwKagAqYE4DOsAdqALygDeAhgOaYBcoA-CQK4C2ARgQL6IAxqULJQWWOmjZKAbVoNmARgBMfADTV6TUEoAcGrYtAqALHwC6AbiEixsaABM8RUsxfEylBToDsABj4bAEtIUAAKB2cCTwA6bQBKakRQUGESUVBtClAoj1J4hhtUiSlMWMhYfABRGkEAC3CsVy8APmTU1PTiaVi4OnCAAwAVeuxmz1BgwlAAEioJgu0+LJJHUGQx3KdckmxpuZ8+QYTi0D4ExD4gA&quot;&gt;https://flow.org/try&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="80f15d97ffae3b57327c19c2c3876da3f190b457" translate="yes" xml:space="preserve">
          <source>Example (&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQAXAngBwKagAqYE4DOsAdqALygDeAhgOaYBcoA-CQK4C2ARgQL6IAxqULJQWWOmjZKAbVoNmARgBMfADTV6TUEoAcGrYtAqALHwC6AbiEixsaABM8RUsxfEylBToDsABj4bAEtIUAAKB2cCTwA6bQBKakRQcUxJaVjIWHwAURpBAAtwrFcvAD5k1NThEmJMuDpwgAMAFULsUs9QYMJQABIqLtJ4hj5QGhJHUGQO0Cj5kmxegaoojxHtPmaEm1S+BMQ+IA&quot;&gt;https://flow.org/try&lt;/a&gt;):</source>
          <target state="translated">示例（&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQAXAngBwKagAqYE4DOsAdqALygDeAhgOaYBcoA-CQK4C2ARgQL6IAxqULJQWWOmjZKAbVoNmARgBMfADTV6TUEoAcGrYtAqALHwC6AbiEixsaABM8RUsxfEylBToDsABj4bAEtIUAAKB2cCTwA6bQBKakRQcUxJaVjIWHwAURpBAAtwrFcvAD5k1NThEmJMuDpwgAMAFULsUs9QYMJQABIqLtJ4hj5QGhJHUGQO0Cj5kmxegaoojxHtPmaEm1S+BMQ+IA&quot;&gt;https://flow.org/try&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="322dc85522b6f01f651a645f66ddad7a2d200735" translate="yes" xml:space="preserve">
          <source>Example (&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQAXAngBwKagEqYM7qwB2+2AvKIqKAD6gDeoaWAXKAOT4CuAxrwXwcANKABuAQ2jdM7fMgBOAS2IBzUAF9qdRswyzOmBQtgKRoIyYXsAosdOaA3IkS8S80AAsJxACbRMPEJ3ClAACgUCIlIDIOiyAEpQcgA+Rm0lSHDI4JiAOhYKckouPgF8ISSGbRo3UmRxKRlk0Bz4zDzJaUwa0DJkABUlAFtMWG5kMLCk1PSaedA6-FgAvLhVMIADABIGLpkNUABGTYTejVEjgAYbhOcaLQ1HIA&quot;&gt;https://flow.org/try&lt;/a&gt;):</source>
          <target state="translated">示例（&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQAXAngBwKagEqYM7qwB2+2AvKIqKAD6gDeoaWAXKAOT4CuAxrwXwcANKABuAQ2jdM7fMgBOAS2IBzUAF9qdRswyzOmBQtgKRoIyYXsAosdOaA3IkS8S80AAsJxACbRMPEJ3ClAACgUCIlIDIOiyAEpQcgA+Rm0lSHDI4JiAOhYKckouPgF8ISSGbRo3UmRxKRlk0Bz4zDzJaUwa0DJkABUlAFtMWG5kMLCk1PSaedA6-FgAvLhVMIADABIGLpkNUABGTYTejVEjgAYbhOcaLQ1HIA&quot;&gt;https://flow.org/try&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="d33740834b3eef6ebff52fd563f9384fd43212e0" translate="yes" xml:space="preserve">
          <source>Example (&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQAXAngBwKagEqYM7qwB2+2AvKIqKAD6gDeoaWAXKAOT4CuAxrwXwcANKABuAQ2jdM7fMgBOAS2IBzUAF9qdRswyzOmBQtgKRoIyYXsAosdOaA3IkS8S80AAsJxACbRMPEJ3ClAACgUCIlIDIOiyAEpQcgA+Rm0lSHDI4JiAOhYKckouPgF8ISSGbRoyZAAVJQBbTFhuZDCwpNT0mj7QN1JYALy4VTCAAwASBhz4zDzJaUwNUABGCYSazVE1gAYDhOcaLQ1HIA&quot;&gt;https://flow.org/try&lt;/a&gt;):</source>
          <target state="translated">示例（&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQAXAngBwKagEqYM7qwB2+2AvKIqKAD6gDeoaWAXKAOT4CuAxrwXwcANKABuAQ2jdM7fMgBOAS2IBzUAF9qdRswyzOmBQtgKRoIyYXsAosdOaA3IkS8S80AAsJxACbRMPEJ3ClAACgUCIlIDIOiyAEpQcgA+Rm0lSHDI4JiAOhYKckouPgF8ISSGbRoyZAAVJQBbTFhuZDCwpNT0mj7QN1JYALy4VTCAAwASBhz4zDzJaUwNUABGCYSazVE1gAYDhOcaLQ1HIA&quot;&gt;https://flow.org/try&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="17498ea196f44dae076810df274fc7a54473ddb1" translate="yes" xml:space="preserve">
          <source>Example (&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBTAHgB1gJwC6gMawB2AzngIYAmloAvKABTkBcoRArgLYBGyWAlHQB8ocqADUoAIwBuIA&quot;&gt;https://flow.org/try&lt;/a&gt;):</source>
          <target state="translated">示例（&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBTAHgB1gJwC6gMawB2AzngIYAmloAvKABTkBcoRArgLYBGyWAlHQB8ocqADUoAIwBuIA&quot;&gt;https://flow.org/try&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="190c678983df25c000784ac0118a1c78a00727f4" translate="yes" xml:space="preserve">
          <source>Example (&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQiSgOoEsAuALWBXLUAJwFMBDAE1gDtoBPALmQGNaBnIyGgRlAF5QAClgAjAFaNQAbwA+oclM7EMNAOahZAApr4AtqNLEtsgL4BKAQD4ZiAJCox4gHTkBoHgCYAzKBAA5AHkAFQBRAEIZbUVQZVUNM1AAB3J2dlJKUFUFGkzySCwjUFwMdiyieAJoTMNQXQMijEgFaDh4DPsyLHxiGlAnAG5EU1YOIidSFiweKTktGLj1TVN3aRiAcmV10FMhlDBuHhEJSenzAb8wAB4AWjvQfBo2PT1SGiJsyFhiUCNib-Y4XCyFQdzB4IhkKh0JhILAACUKNQ6PQbgA3IzsDC0ZiINg0TigbiedzHSRRUAAagWWBUS209UMPzMln4NmkiFAoAcYCcrncXl8ARCEVAAGVVCxSKB6AQFGQHlilmw0eQVOR3lEtNSlLT4podPomcsADQyuUsDXrIh6QjkQrlTqkbq9foSIYjPFjN3iU6eWbyGl0hIrQTSBRSTa07a7ZDEsl+85AA&quot;&gt;https://flow.org/try&lt;/a&gt;)</source>
          <target state="translated">示例（&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQiSgOoEsAuALWBXLUAJwFMBDAE1gDtoBPALmQGNaBnIyGgRlAF5QAClgAjAFaNQAbwA+oclM7EMNAOahZAApr4AtqNLEtsgL4BKAQD4ZiAJCox4gHTkBoHgCYAzKBAA5AHkAFQBRAEIZbUVQZVUNM1AAB3J2dlJKUFUFGkzySCwjUFwMdiyieAJoTMNQXQMijEgFaDh4DPsyLHxiGlAnAG5EU1YOIidSFiweKTktGLj1TVN3aRiAcmV10FMhlDBuHhEJSenzAb8wAB4AWjvQfBo2PT1SGiJsyFhiUCNib-Y4XCyFQdzB4IhkKh0JhILAACUKNQ6PQbgA3IzsDC0ZiINg0TigbiedzHSRRUAAagWWBUS209UMPzMln4NmkiFAoAcYCcrncXl8ARCEVAAGVVCxSKB6AQFGQHlilmw0eQVOR3lEtNSlLT4podPomcsADQyuUsDXrIh6QjkQrlTqkbq9foSIYjPFjN3iU6eWbyGl0hIrQTSBRSTa07a7ZDEsl+85AA&quot;&gt;https://flow.org/try&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="f3309c09c3ccaba2a2970b1e441c41e351e404c8" translate="yes" xml:space="preserve">
          <source>Example (&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQiSgOoEsAuALWBXLUAJwFMBDAE1gDtoBPALmQGNaBnIyGgRlAF5QACnLFijUAEEx5egB5OxDDQDmoAD4ACmvgC2AI1LEAfAEoBx0AG9EASFSjiAOgAO+djiE8ATAGZzqAByAPIAKgCiAIRSMvKKyiqWLuTs7KSUoMqg5DQZ5JBYRqC4GOyZRPAE0HnQ7LCZNCzQ+JSkoDoGRmUYkNnQcPDpdmRY+MQ02WIA3IgAvqwcRI48EtLEsgpYSqqWggDaAOTk+iwHALozKGDcPCJiplOgqHIAtG+g+I2wurqkNFywYigIzEQHsSKRZCoN4w2Fw+EIxFIqFgABKFGodHoLwAbl0MLRmIg2DROKBuN4BMJHBIACToqjBLFrDbxVQabR6Qwmcz8Sw2UCCp5gRyudyeXzeHgBMAhCLRADKyhYbXoBEmbXcCVA9IxTIYLPkTmNljV+FALByNFgRDcHmyNHoJXZWHq2GGpFG40mxDmC1JSzE3lWsU220SVMOx1OF2QFLuxG8DyAA&quot;&gt;https://flow.org/try&lt;/a&gt;)</source>
          <target state="translated">示例（&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQiSgOoEsAuALWBXLUAJwFMBDAE1gDtoBPALmQGNaBnIyGgRlAF5QACnLFijUAEEx5egB5OxDDQDmoAD4ACmvgC2AI1LEAfAEoBx0AG9EASFSjiAOgAO+djiE8ATAGZzqAByAPIAKgCiAIRSMvKKyiqWLuTs7KSUoMqg5DQZ5JBYRqC4GOyZRPAE0HnQ7LCZNCzQ+JSkoDoGRmUYkNnQcPDpdmRY+MQ02WIA3IgAvqwcRI48EtLEsgpYSqqWggDaAOTk+iwHALozKGDcPCJiplOgqHIAtG+g+I2wurqkNFywYigIzEQHsSKRZCoN4w2Fw+EIxFIqFgABKFGodHoLwAbl0MLRmIg2DROKBuN4BMJHBIACToqjBLFrDbxVQabR6Qwmcz8Sw2UCCp5gRyudyeXzeHgBMAhCLRADKyhYbXoBEmbXcCVA9IxTIYLPkTmNljV+FALByNFgRDcHmyNHoJXZWHq2GGpFG40mxDmC1JSzE3lWsU220SVMOx1OF2QFLuxG8DyAA&quot;&gt;https://flow.org/try&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="5a53b2289397b07076fab02c5763eb1c53631c66" translate="yes" xml:space="preserve">
          <source>Example with custom project root:</source>
          <target state="translated">例子与自定义项目根。</target>
        </trans-unit>
        <trans-unit id="54a8d51fcba191895dda4ed409e712e9d6ebfc4d" translate="yes" xml:space="preserve">
          <source>Exclusions</source>
          <target state="translated">Exclusions</target>
        </trans-unit>
        <trans-unit id="8be9eff630c8880ea37c3c71e5c9f1754569ead1" translate="yes" xml:space="preserve">
          <source>Existential Type (&lt;code&gt;*&lt;/code&gt;)</source>
          <target state="translated">存在类型（ &lt;code&gt;*&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="27232a9afb263ba7bb3f411dab25557c71bf54f0" translate="yes" xml:space="preserve">
          <source>Explicit inexact object types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b6e2ec966477f28252b7545083426821a4c2c4e" translate="yes" xml:space="preserve">
          <source>Explicit versions, (e.g. &lt;code&gt;0.22.0&lt;/code&gt;, which only matches &lt;code&gt;0.22.0&lt;/code&gt;).</source>
          <target state="translated">显式版本（例如 &lt;code&gt;0.22.0&lt;/code&gt; ，仅匹配 &lt;code&gt;0.22.0&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2e0e14ad5753e9c7b526a0cc660e1f093709bbc2" translate="yes" xml:space="preserve">
          <source>Exporting Wrapped Components</source>
          <target state="translated">出口包装元件</target>
        </trans-unit>
        <trans-unit id="03688ba6aa340b87549088aa5739944cb6b1dc73" translate="yes" xml:space="preserve">
          <source>FAQ</source>
          <target state="translated">FAQ</target>
        </trans-unit>
        <trans-unit id="fc338f87a058158eb824b53705961801516a9460" translate="yes" xml:space="preserve">
          <source>Features</source>
          <target state="translated">Features</target>
        </trans-unit>
        <trans-unit id="2113c9e9296853fb527db9a13ccff3f1ceb1a1d8" translate="yes" xml:space="preserve">
          <source>Fields added outside of the class definition need to be annotated within the body of the class.</source>
          <target state="translated">在类定义之外添加的字段需要在类的主体中进行注释。</target>
        </trans-unit>
        <trans-unit id="4a066fa7f532f77d0e18961512951af8ba154e40" translate="yes" xml:space="preserve">
          <source>Fields are annotated within the body of the class with the field name followed by a colon &lt;code&gt;:&lt;/code&gt; and the type.</source>
          <target state="translated">在类的主体内用字段名注释字段，后跟冒号 &lt;code&gt;:&lt;/code&gt; 和类型。</target>
        </trans-unit>
        <trans-unit id="64f266c0fe1d54849f0f9ed285666ffc97ff5171" translate="yes" xml:space="preserve">
          <source>Figuring out types statically</source>
          <target state="translated">静态地找出类型</target>
        </trans-unit>
        <trans-unit id="4530df8ca3479183e9a0b8b7820de3c8dd0aa307" translate="yes" xml:space="preserve">
          <source>Finally, if we had a &lt;code&gt;TypeA&lt;/code&gt; which described the numbers 1 through 3, and a &lt;code&gt;TypeB&lt;/code&gt; which described the numbers 3 through 5. Neither of them would be a subtype of the other. Even though they both have 3 and describe numbers, they each have some unique items.</source>
          <target state="translated">最后，如果我们有一个描述数字1到3 的 &lt;code&gt;TypeA&lt;/code&gt; ，和一个描述数字3到5 的 &lt;code&gt;TypeB&lt;/code&gt; ，那么它们两个都不是另一个的子类型。即使它们都有3个并描述数字，它们每个都有一些独特的项目。</target>
        </trans-unit>
        <trans-unit id="0087380702d2e1d3b16fa67500a178f79cae05f8" translate="yes" xml:space="preserve">
          <source>Finally, precision enables useful developer tools to be built. In particular, the quality of results reported by Flow when the developer asks for the type of an expression, the definition reaching a reference, or the set of possible completions at a point through an IDE is correlated with the precision of Flow&amp;rsquo;s analysis.</source>
          <target state="translated">最后，精度使构建有用的开发人员工具成为可能。特别是，当开发人员要求表达式的类型，到达引用的定义或通过IDE的某个点上可能完成的操作集时，Flow报告的结果质量与Flow的分析精度相关。</target>
        </trans-unit>
        <trans-unit id="07c5cf005d2302c6d3946a6acb658df51d720297" translate="yes" xml:space="preserve">
          <source>Finally, we&amp;rsquo;ll have yet another &lt;code&gt;SubClass&lt;/code&gt; that accepts a value of a more specific type.</source>
          <target state="translated">最后，我们将有另一个 &lt;code&gt;SubClass&lt;/code&gt; ，它接受更特定类型的值。</target>
        </trans-unit>
        <trans-unit id="dac3b0962e00de97e4f2ee26698e83fa3a80f1ef" translate="yes" xml:space="preserve">
          <source>First install &lt;code&gt;flow-remove-types&lt;/code&gt; with either &lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt; or &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;.</source>
          <target state="translated">首先使用&lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt;或&lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;安装 &lt;code&gt;flow-remove-types&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd2eea5de09d8e90691b2d177dd08996669f26aa" translate="yes" xml:space="preserve">
          <source>First we&amp;rsquo;ll setup a couple of classes that extend one another.</source>
          <target state="translated">首先，我们将建立几个相互扩展的类。</target>
        </trans-unit>
        <trans-unit id="456cf8a255eb59ebf894cb52911a86af4e0bff54" translate="yes" xml:space="preserve">
          <source>Fixed example:</source>
          <target state="translated">固定的例子。</target>
        </trans-unit>
        <trans-unit id="86eff8eb789b097ddca83f2c9c4617ed23605105" translate="yes" xml:space="preserve">
          <source>Flow</source>
          <target state="translated">Flow</target>
        </trans-unit>
        <trans-unit id="5f486e379bef52ad99c92a90171eb0881d4b0d3f" translate="yes" xml:space="preserve">
          <source>Flow + Redux resources</source>
          <target state="translated">流程+Redux资源</target>
        </trans-unit>
        <trans-unit id="55ec9aab6133cd88e4cf42e5ab878820aef8afea" translate="yes" xml:space="preserve">
          <source>Flow CLI</source>
          <target state="translated">流程CLI</target>
        </trans-unit>
        <trans-unit id="8b609ab9406ce02a4ce30abc841ff2dba941e173" translate="yes" xml:space="preserve">
          <source>Flow For Sublime Text 2 and 3</source>
          <target state="translated">崇高文本2和3的流程</target>
        </trans-unit>
        <trans-unit id="aa235a6660a8f1b9aa16724f3a8222516b8f655e" translate="yes" xml:space="preserve">
          <source>Flow Strict</source>
          <target state="translated">流程严格</target>
        </trans-unit>
        <trans-unit id="f2ec6e6dfc95e327edb4e1795150f27d42969c4f" translate="yes" xml:space="preserve">
          <source>Flow Strict is configured in each &lt;code&gt;.flowconfig&lt;/code&gt;. To enable:</source>
          <target state="translated">在每个 &lt;code&gt;.flowconfig&lt;/code&gt; 中配置Flow Strict 。启用：</target>
        </trans-unit>
        <trans-unit id="6e27552186835c23a7b0bda80c42f6ffde67c69a" translate="yes" xml:space="preserve">
          <source>Flow achieves this behavior by matching the type of the argument to the &lt;em&gt;first&lt;/em&gt; overload with a compatible parameter type. Notice for example that the argument &lt;code&gt;&quot;string&quot;&lt;/code&gt; matches both the first and the last overload. Flow will just pick the first one. If no overload matches, Flow will raise an error at the call site.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8095395f626e2f4759824d2de551bb30bbe955c2" translate="yes" xml:space="preserve">
          <source>Flow also supports importing the type of values exported by other modules using &lt;a href=&quot;../typeof&quot;&gt;&lt;code&gt;typeof&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Flow还支持使用&lt;a href=&quot;../typeof&quot;&gt; &lt;code&gt;typeof&lt;/code&gt; &lt;/a&gt;导入其他模块导出的值的类型。</target>
        </trans-unit>
        <trans-unit id="b5565b1d0068dc56bcf908f48c68d08d32bae353" translate="yes" xml:space="preserve">
          <source>Flow also supports using the &lt;a href=&quot;https://tc39.github.io/proposal-class-public-fields/&quot;&gt;class properties syntax&lt;/a&gt;.</source>
          <target state="translated">Flow还支持使用&lt;a href=&quot;https://tc39.github.io/proposal-class-public-fields/&quot;&gt;类属性语法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e84982c22a83ff1714857618c803fc295ca0cb49" translate="yes" xml:space="preserve">
          <source>Flow and &lt;a href=&quot;http://babeljs.io/&quot;&gt;Babel&lt;/a&gt; are designed to work great together. It takes just a few steps to set them up together.</source>
          <target state="translated">Flow和&lt;a href=&quot;http://babeljs.io/&quot;&gt;Babel&lt;/a&gt;旨在一起工作。只需几个步骤即可将它们设置在一起。</target>
        </trans-unit>
        <trans-unit id="5ccb8cfec36d4d1243e598e54059dcef046eb1fd" translate="yes" xml:space="preserve">
          <source>Flow and Babel work well together, so it doesn&amp;rsquo;t take much to adopt Flow as a React user who already uses Babel. If you need to setup Babel with Flow, you can follow &lt;a href=&quot;https://flow.org/en/tools/babel/&quot;&gt;this guide&lt;/a&gt;.</source>
          <target state="translated">Flow和Babel可以很好地协同工作，因此将Flow用作已经使用Babel的React用户并不需要很多。如果您需要使用Flow设置Babel，可以按照&lt;a href=&quot;https://flow.org/en/tools/babel/&quot;&gt;本指南进行操作&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e7ddc3f598f9d4eaea63e1a3d210b131b6a5bf65" translate="yes" xml:space="preserve">
          <source>Flow builds intermediate artifacts to represent signatures of modules as they are checked. If this option is set to &lt;code&gt;false&lt;/code&gt;, then these artifacts are built using inferred type information. If this option is set to &lt;code&gt;true&lt;/code&gt;, then they are built using type annotations at module boundaries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12bd6e3068284e323e6e5441c7cbe62cfa2eaa15" translate="yes" xml:space="preserve">
          <source>Flow can either infer the type from the value you are assigning to it or you can provide it with a type.</source>
          <target state="translated">Flow可以从你分配给它的值中推断出类型,也可以向它提供类型。</target>
        </trans-unit>
        <trans-unit id="72ce261a07a9b54acdbe6ade8c25b4096bc1b01e" translate="yes" xml:space="preserve">
          <source>Flow can handle both CommonJS and ES modules, but there are some relevant differences between the two that need to be considered when using &lt;code&gt;declare module&lt;/code&gt;.</source>
          <target state="translated">Flow可以处理CommonJS和ES模块，但是在使用 &lt;code&gt;declare module&lt;/code&gt; 时，这两者之间需要考虑一些相关的区别。</target>
        </trans-unit>
        <trans-unit id="c4fd2a75a67392ac133c52fa3dfe6c46849561bc" translate="yes" xml:space="preserve">
          <source>Flow can infer the type of object literals in two different ways depending on how they are used.</source>
          <target state="translated">Flow可以根据对象字元的使用方式,以两种不同的方式推断对象字元的类型。</target>
        </trans-unit>
        <trans-unit id="98d85338f7ba2bc3651bb2436f50fc5aeb15f4f6" translate="yes" xml:space="preserve">
          <source>Flow can typecheck your React components that use the &lt;a href=&quot;https://reactjs.org/docs/context.html&quot;&gt;context API&lt;/a&gt; introduced in React 16.3.</source>
          <target state="translated">Flow可以对使用React 16.3中引入的&lt;a href=&quot;https://reactjs.org/docs/context.html&quot;&gt;上下文API的&lt;/a&gt; React组件进行类型检查。</target>
        </trans-unit>
        <trans-unit id="6944ed8c8b4918d2dec469bbf6c3dc20723ec0d8" translate="yes" xml:space="preserve">
          <source>Flow cannot understand the types of my higher order React component, how can I help it?</source>
          <target state="translated">Flow无法理解我的高阶React组件的类型,我该如何帮助它?</target>
        </trans-unit>
        <trans-unit id="183d1f29f5ed63eb14ac2b0f3910cf9d83903afb" translate="yes" xml:space="preserve">
          <source>Flow checks your code for errors through &lt;strong&gt;static type annotations&lt;/strong&gt;. These &lt;em&gt;types&lt;/em&gt; allow you to tell Flow how you want your code to work, and Flow will make sure it does work that way.</source>
          <target state="translated">Flow通过&lt;strong&gt;静态类型注释&lt;/strong&gt;检查代码是否存在错误。这些&lt;em&gt;类型&lt;/em&gt;使您可以告诉Flow您希望代码如何工作，并且Flow将确保它以这种方式工作。</target>
        </trans-unit>
        <trans-unit id="04032a68a1402eaf71bab9646202a4ad15b6268c" translate="yes" xml:space="preserve">
          <source>Flow chooses what is natural for JavaScript, and should behave the way you expect it to.</source>
          <target state="translated">Flow选择了JavaScript自然的东西,并且应该以你期望的方式表现出来。</target>
        </trans-unit>
        <trans-unit id="032ca5c444d8fb1a1677e49ec7f5f65de9cb839b" translate="yes" xml:space="preserve">
          <source>Flow contains a linting framework that can tell you about more than just type errors. This framework is highly configurable in order to show you the information you want and hide the information you don&amp;rsquo;t.</source>
          <target state="translated">Flow包含一个整理框架，该框架不仅可以告诉您类型错误，还可以告诉您更多信息。该框架是高度可配置的，以便向您显示所需的信息，并隐藏不需要的信息。</target>
        </trans-unit>
        <trans-unit id="8a9a662da9d9494227dfb8c32f7a3a00aa8eb74d" translate="yes" xml:space="preserve">
          <source>Flow does all sorts of type inference on your code so that you don&amp;rsquo;t have to type annotate anything. Generally, inference avoids getting in your way while still preventing you from introducing bugs.</source>
          <target state="translated">Flow对代码执行各种类型推断，因此您无需键入任何注释。通常，推理可避免妨碍您，同时仍可防止您引入错误。</target>
        </trans-unit>
        <trans-unit id="c4a7493c100b0d7186e5d7a811ec01b5c49ff79d" translate="yes" xml:space="preserve">
          <source>Flow does not do this because it would be extremely inconvenient to use. You would be forced to refine the type of every value you get when accessing an array.</source>
          <target state="translated">Flow不会这样做,因为这样做会非常不方便。当你访问一个数组时,你将被迫细化你得到的每个值的类型。</target>
        </trans-unit>
        <trans-unit id="25bf8feebd194c6ea5f28b8c0c675bd8e2749e24" translate="yes" xml:space="preserve">
          <source>Flow does not keep track of side effects, so any function call may potentially nullify your check. This is called &lt;a href=&quot;lang/refinements#toc-refinement-invalidations&quot;&gt;refinement invalidation&lt;/a&gt;.</source>
          <target state="translated">Flow不会跟踪副作用，因此任何函数调用都可能使检查无效。这称为&lt;a href=&quot;lang/refinements#toc-refinement-invalidations&quot;&gt;优化失效&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f3f46e4e936a3e8537064c3745c26d7fd98211da" translate="yes" xml:space="preserve">
          <source>Flow doesn&amp;rsquo;t track refinements made in separated function calls.</source>
          <target state="translated">Flow不会跟踪在单独的函数调用中进行的优化。</target>
        </trans-unit>
        <trans-unit id="59a4ef57b455273cbb11be7412569d3ac42e4710" translate="yes" xml:space="preserve">
          <source>Flow for Atom IDE</source>
          <target state="translated">Atom IDE的流程</target>
        </trans-unit>
        <trans-unit id="44fdaae0716bb1f8df6934754643b2d31169e8f0" translate="yes" xml:space="preserve">
          <source>Flow has &lt;a href=&quot;../primitives&quot;&gt;primitive types&lt;/a&gt; for literal values, but can also use literal values as types.</source>
          <target state="translated">Flow具有文字值的&lt;a href=&quot;../primitives&quot;&gt;原始类型&lt;/a&gt;，但也可以将文字值用作类型。</target>
        </trans-unit>
        <trans-unit id="46a176a435a62da90c46dd0328bea203b7bb04be" translate="yes" xml:space="preserve">
          <source>Flow has a powerful ability to infer the types of your programs. The majority of your code can rely on it. Still, there are places where you&amp;rsquo;ll want to add types.</source>
          <target state="translated">Flow具有强大的功能来推断您的程序类型。您的大多数代码都可以依靠它。不过，您仍然需要在某些地方添加类型。</target>
        </trans-unit>
        <trans-unit id="91780aa64a146a3b1363ded13b2a26ff2a5703d2" translate="yes" xml:space="preserve">
          <source>Flow has builtin library definitions. Setting this to &lt;code&gt;true&lt;/code&gt; will tell Flow to ignore the builtin library definitions.</source>
          <target state="translated">Flow具有内置的库定义。将其设置为 &lt;code&gt;true&lt;/code&gt; 将告诉Flow忽略内置库定义。</target>
        </trans-unit>
        <trans-unit id="825a2af8b1f4018e85d11b13cda08105f2561dfc" translate="yes" xml:space="preserve">
          <source>Flow has worked with Nuclide directly on adding support for the new warning severity level. Certain features are likely to be in other editors, but others might not yet be implemented.</source>
          <target state="translated">Flow已经直接与Nuclide合作,为新的警告严重程度增加支持。某些功能可能会出现在其他编辑器中,但其他功能可能还没有实现。</target>
        </trans-unit>
        <trans-unit id="1f749e30856c0772a3eb06d3b18fcad17982d0c5" translate="yes" xml:space="preserve">
          <source>Flow is a static type checker for JavaScript that we built at Facebook. The overall mission of Flow is to deliver an immersive coding experience for JavaScript developers&amp;mdash;a fast edit-refresh cycle&amp;mdash;even as the codebase evolves and grows. In engineering terms, we identify two concrete goals that are important to this mission: &lt;em&gt;precision&lt;/em&gt; and &lt;em&gt;speed&lt;/em&gt;. These goals pervasively drive the design and implementation.</source>
          <target state="translated">Flow是我们在Facebook上构建的JavaScript的静态类型检查器。Flow的总体任务是为JavaScript开发人员提供身临其境的编码体验-快速的编辑-刷新周期-甚至随着代码库的发展和壮大。用工程术语来说，我们确定了对该任务重要的两个具体目标：&lt;em&gt;精度&lt;/em&gt;和&lt;em&gt;速度&lt;/em&gt;。这些目标无处不在地推动设计和实施。</target>
        </trans-unit>
        <trans-unit id="e37ba63533b865ecc3dbf31c3bc219eae3775a54" translate="yes" xml:space="preserve">
          <source>Flow is a static type checker for your JavaScript code. It does a lot of work to make you more productive. Making you code faster, smarter, more confidently, and to a bigger scale.</source>
          <target state="translated">Flow是一个静态类型检查器,用于检查你的JavaScript代码。它做了很多工作,让你更有效率。让你更快、更聪明、更自信地编写代码,并达到更大的规模。</target>
        </trans-unit>
        <trans-unit id="eccc6e8d7aae412ab111e4ae2e8f9d87e9acb8a6" translate="yes" xml:space="preserve">
          <source>Flow is not &lt;a href=&quot;https://flow.org/en/lang/types-and-expressions/#soundness-and-completeness&quot;&gt;complete&lt;/a&gt;, so it cannot check all code perfectly. Instead, Flow will make conservative assumptions to try to be sound.</source>
          <target state="translated">流程不&lt;a href=&quot;https://flow.org/en/lang/types-and-expressions/#soundness-and-completeness&quot;&gt;完整&lt;/a&gt;，因此无法完美检查所有代码。取而代之的是，Flow会做出一些保守的假设，以使其听起来更加合理。</target>
        </trans-unit>
        <trans-unit id="f5a3fb20b94174faf688a6da7dfab78f503bda2d" translate="yes" xml:space="preserve">
          <source>Flow needs a way to be able to figure out the type of every expression. But it can&amp;rsquo;t just run your code to figure it out, if it did it would be affected by any issues that your code has. For example, if you created an infinite loop Flow would wait for it to finish forever.</source>
          <target state="translated">流需要一种能够弄清楚每个表达式的类型的方法。但是它不能仅仅运行您的代码来解决它，如果这样做会受到代码中任何问题的影响。例如，如果您创建了一个无限循环，Flow将等待它永远结束。</target>
        </trans-unit>
        <trans-unit id="c320f7d736c792bfa9520f9145672090f7b71c98" translate="yes" xml:space="preserve">
          <source>Flow needs to compare more than just sets of primitive values, it also needs to be able to compare objects, functions, and every other type that appears in the language.</source>
          <target state="translated">Flow需要比较的不仅仅是基元值的集合,它还需要能够比较对象、函数以及语言中出现的所有其他类型。</target>
        </trans-unit>
        <trans-unit id="197f7b0842bf7c4d39085530e1c9d6e1647ccda5" translate="yes" xml:space="preserve">
          <source>Flow needs to know which files to parse and of those how to handle any Flow types within them. For third party libraries you may wish to not parse, parse but not preserve types, or parse but not raise errors, depending on the quality and compatibility of their Flow implementation.</source>
          <target state="translated">Flow需要知道要解析哪些文件,以及如何处理其中的Flow类型,对于第三方库,你可能希望不解析,解析但不保留类型,或者解析但不产生错误,这取决于它们的质量和兼容性。对于第三方库,你可能希望不解析,解析但不保留类型,或者解析但不产生错误,这取决于他们的Flow实现的质量和兼容性。</target>
        </trans-unit>
        <trans-unit id="fa11ea1401156a6f5d8e119dec34779c7787d52c" translate="yes" xml:space="preserve">
          <source>Flow needs to know which files to read and watch for changes. This set of files is determined by taking all included files and excluding all the ignored files.</source>
          <target state="translated">Flow需要知道要读取哪些文件并观察变化。这组文件是由所有包含的文件和排除所有忽略的文件决定的。</target>
        </trans-unit>
        <trans-unit id="e74d4f194fac00619d8f08bc6cfdf7a46e8a3401" translate="yes" xml:space="preserve">
          <source>Flow provides a set of utility types to operate on other types, and can be useful for different scenarios.</source>
          <target state="translated">Flow提供了一组实用类型,可以对其他类型进行操作,并且可以在不同的场景下使用。</target>
        </trans-unit>
        <trans-unit id="1431a76ac3b525222744b6e84e9e4ddfb3690671" translate="yes" xml:space="preserve">
          <source>Flow reads &lt;code&gt;package.json&lt;/code&gt; files for the &lt;code&gt;&quot;name&quot;&lt;/code&gt; and &lt;code&gt;&quot;main&quot;&lt;/code&gt; fields to figure out the name of the module and which file should be used to provide that module.</source>
          <target state="translated">Flow会读取 &lt;code&gt;package.json&lt;/code&gt; 文件中的 &lt;code&gt;&quot;name&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;main&quot;&lt;/code&gt; 字段，以找出模块的名称以及应使用哪个文件来提供该模块。</target>
        </trans-unit>
        <trans-unit id="e11220e33346b1bf7474cc77bed10da16b3fdb63" translate="yes" xml:space="preserve">
          <source>Flow requires type annotations at module boundaries to make sure it can scale. To read more about that, check out our &lt;a href=&quot;https://medium.com/flow-type/asking-for-required-annotations-64d4f9c1edf8&quot;&gt;blog post&lt;/a&gt; about that.</source>
          <target state="translated">流需要在模块边界处进行类型注释，以确保其可扩展。要了解更多信息，请查看我们的&lt;a href=&quot;https://medium.com/flow-type/asking-for-required-annotations-64d4f9c1edf8&quot;&gt;博客文章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b4c09a80109af9a29936b09b862868ca078b9ce3" translate="yes" xml:space="preserve">
          <source>Flow silently accepts it (and uses &lt;code&gt;Fn&lt;/code&gt; as the inferred type), but does not check the implementation against this signature. This makes this kind of declaration a better suited candidate for library definitions, where implementations are omitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84d0f858caf5dd7487404da9c0e086ed565c074e" translate="yes" xml:space="preserve">
          <source>Flow supports a comment-based syntax, which makes it possible to use Flow without having to compile your files.</source>
          <target state="translated">Flow支持基于注释的语法,这使得使用Flow时无需编译文件。</target>
        </trans-unit>
        <trans-unit id="30ad932dfc5bec279c555d2817fce7c58c613eaa" translate="yes" xml:space="preserve">
          <source>Flow supports the &lt;code&gt;@babel/plugin-transform-react-jsx&lt;/code&gt; runtime options required to use JSX without explicitly importing the React namespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25dce24924ffe50d06ea3c27504223de08877a30" translate="yes" xml:space="preserve">
          <source>Flow tracks the specific type of the value you pass through a generic, letting you use it later.</source>
          <target state="translated">流动跟踪你通过一个通用的值的具体类型,让你以后使用它。</target>
        </trans-unit>
        <trans-unit id="4543e6960bdd40f7fd529d611087695f4d5149d5" translate="yes" xml:space="preserve">
          <source>Flow tries to avoid parsing non-flow files. This means Flow needs to start lexing a file to see if it has &lt;code&gt;@flow&lt;/code&gt; or &lt;code&gt;@noflow&lt;/code&gt; in it. This option lets you configure how much of the file Flow lexes before it decides there is no relevant docblock.</source>
          <target state="translated">Flow尝试避免解析非流文件。这意味着Flow需要开始对文件进行词法化处理，以查看文件中是否包含 &lt;code&gt;@flow&lt;/code&gt; 或 &lt;code&gt;@noflow&lt;/code&gt; 。通过此选项，您可以配置Flow词法文件中的多少，然后再确定没有相关的文档块。</target>
        </trans-unit>
        <trans-unit id="52553dd61330137688c84a4912b70f866c01b523" translate="yes" xml:space="preserve">
          <source>Flow tries to be as sound and complete as possible. But because JavaScript was not designed around a type system, Flow sometimes has to make a tradeoff. When this happens Flow tends to favor soundness over completeness, ensuring that code doesn&amp;rsquo;t have any bugs.</source>
          <target state="translated">Flow尝试尽可能健全和完整。但是，由于JavaScript并不是围绕类型系统设计的，因此Flow有时需要做出权衡。发生这种情况时，Flow倾向于优先考虑完整性而不是完整性，以确保代码没有任何错误。</target>
        </trans-unit>
        <trans-unit id="7d011e99cc7dbd500d87676f164a01cb49e80345" translate="yes" xml:space="preserve">
          <source>Flow tries to work out of the box as much as possible, but can be configured to work with any codebase.</source>
          <target state="translated">Flow试图尽可能地在盒子里工作,但可以配置为与任何代码库一起工作。</target>
        </trans-unit>
        <trans-unit id="eb7d367d74212ddc0e35250289a131174450c8b9" translate="yes" xml:space="preserve">
          <source>Flow understands these conversions and will allow any of them as part of an &lt;code&gt;if&lt;/code&gt; statement and other types of expressions.</source>
          <target state="translated">Flow理解这些转换并将允许其中的任何转换作为 &lt;code&gt;if&lt;/code&gt; 语句和其他类型的表达式的一部分。</target>
        </trans-unit>
        <trans-unit id="5bea5ed86f8a457903d5905c971362464ec56214" translate="yes" xml:space="preserve">
          <source>Flow was designed for easy adoption, so it allows you opt-out of type checking in certain situations, permitting unsafe behaviors. But since many codebases now have a high adoption of Flow types, this trade-off can be flipped. You can use &lt;em&gt;Flow Strict&lt;/em&gt; to disallow previously-allowed unsafe patterns. This gives you improved safety guarantees that catch more bugs and make refactoring easier. And you can implement these stronger guarantees incrementally, on a file-by-file basis.</source>
          <target state="translated">Flow是为易于采用而设计的，因此它允许您在某些情况下选择退出类型检查，从而允许不安全的行为。但是，由于许多代码库现在都高度采用了Flow类型，因此这种折衷可以忽略。您可以使用&amp;ldquo; &lt;em&gt;严格流&amp;rdquo;&lt;/em&gt;来禁止以前允许的不安全模式。这为您提供了改进的安全保证，可以捕获更多错误并简化重构。您可以逐个文件地逐步实现这些更强的保证。</target>
        </trans-unit>
        <trans-unit id="1595a2bf188fc4b7ef46616052b38b6e681bb494" translate="yes" xml:space="preserve">
          <source>Flow will be run as part of create-react-app&amp;rsquo;s scripts.</source>
          <target state="translated">Flow将作为create-react-app脚本的一部分运行。</target>
        </trans-unit>
        <trans-unit id="338d618c9a13ce96682c1d7e15f73ae7f8964da4" translate="yes" xml:space="preserve">
          <source>Flow will infer the type of your default props from &lt;code&gt;static defaultProps&lt;/code&gt; so you don&amp;rsquo;t have to add any type annotations to use default props.</source>
          <target state="translated">Flow将从 &lt;code&gt;static defaultProps&lt;/code&gt; 推断默认道具的类型，因此您无需添加任何类型注释即可使用默认道具。</target>
        </trans-unit>
        <trans-unit id="9184e4b7870b602025b0689241850daf93e22df5" translate="yes" xml:space="preserve">
          <source>Flow will infer types from the way you use a context&amp;rsquo;s &lt;code&gt;{Provider,Consumer}&lt;/code&gt; pair:</source>
          <target state="translated">流将根据您使用上下文的 &lt;code&gt;{Provider,Consumer}&lt;/code&gt; 对的方式来推断类型：</target>
        </trans-unit>
        <trans-unit id="3e54a4925e33a70ee19276a34ddf5663b9fa39c5" translate="yes" xml:space="preserve">
          <source>Flow will only accept strings and number when concatenating them to strings.</source>
          <target state="translated">Flow在将其连接成字符串时,只接受字符串和数字。</target>
        </trans-unit>
        <trans-unit id="5eab08add042bdc755cadabf5fe2a07bc373a954" translate="yes" xml:space="preserve">
          <source>Flow will unsoundly allow this last cast to succeed. If this behavior is not wanted, then this utility type should be avoided.</source>
          <target state="translated">Flow会不健全地允许这最后一次投胎成功。如果不想要这种行为,那么就应该避免使用这种实用类型。</target>
        </trans-unit>
        <trans-unit id="9fb359e7b8aa5962ece67701ffa1a8439b019086" translate="yes" xml:space="preserve">
          <source>Flow will use &lt;code&gt;bar.js&lt;/code&gt; to provide the &lt;code&gt;&quot;kittens&quot;&lt;/code&gt; module.</source>
          <target state="translated">Flow将使用 &lt;code&gt;bar.js&lt;/code&gt; 提供 &lt;code&gt;&quot;kittens&quot;&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="db39464b47c1acee0eb7fa411eeb1a89946c2d9f" translate="yes" xml:space="preserve">
          <source>Flow&amp;rsquo;s editor integration is primarily via the &lt;a href=&quot;https://microsoft.github.io/language-server-protocol/&quot;&gt;Language Server Protocol&lt;/a&gt;. There are &lt;a href=&quot;https://microsoft.github.io/language-server-protocol/implementors/tools/&quot;&gt;many vim LSP clients&lt;/a&gt; to choose from, such as &lt;a href=&quot;#toc-ale&quot;&gt;ALE&lt;/a&gt;.</source>
          <target state="translated">Flow的编辑器集成主要通过&lt;a href=&quot;https://microsoft.github.io/language-server-protocol/&quot;&gt;Language Server Protocol进行&lt;/a&gt;。有&lt;a href=&quot;https://microsoft.github.io/language-server-protocol/implementors/tools/&quot;&gt;很多vim LSP客户端&lt;/a&gt;可供选择，例如&lt;a href=&quot;#toc-ale&quot;&gt;ALE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="35e134c2f20bf81b3b896daf47c04ac35fee3088" translate="yes" xml:space="preserve">
          <source>Flow&amp;rsquo;s shared memory lives in a memory mapped file. On more modern versions of Linux (3.17+), there is a system call &lt;code&gt;memfd_create&lt;/code&gt; which allows Flow to create the file anonymously and only in memory. However, in older kernels, Flow needs to create a file on the file system. Ideally this file lives on a memory-backed tmpfs. This option lets you decide where that file is created.</source>
          <target state="translated">Flow的共享内存位于内存映射文件中。在更现代的Linux（3.17+）版本上，有一个系统调用 &lt;code&gt;memfd_create&lt;/code&gt; ，它允许Flow仅在内存中匿名创建文件。但是，在较早的内核中，Flow需要在文件系统上创建文件。理想情况下，此文件位于内存支持的tmpfs上。该选项使您可以决定在何处创建该文件。</target>
        </trans-unit>
        <trans-unit id="a151dc47e59f85e9ca3816a57d33d5371e099290" translate="yes" xml:space="preserve">
          <source>Flow-IDE</source>
          <target state="translated">Flow-IDE</target>
        </trans-unit>
        <trans-unit id="4dbea89f685901895c4ece7a62f739b66b6c8c38" translate="yes" xml:space="preserve">
          <source>Flow-Language-Support</source>
          <target state="translated">Flow-Language-Support</target>
        </trans-unit>
        <trans-unit id="52981c30a079c03c2816af01a0b63be9bf496116" translate="yes" xml:space="preserve">
          <source>Flow: Goals</source>
          <target state="translated">流程:目标</target>
        </trans-unit>
        <trans-unit id="193cbf05588eacbb65a1c0ac7089a698e31d43b1" translate="yes" xml:space="preserve">
          <source>Flowlint Comments</source>
          <target state="translated">Flowlint评论</target>
        </trans-unit>
        <trans-unit id="189ce1cc1d3d009f899bc0f0bdf7826fa8c95970" translate="yes" xml:space="preserve">
          <source>Follow the &lt;a href=&quot;https://github.com/w0rp/ale#3-installation&quot;&gt;instructions&lt;/a&gt; in the ALE README.</source>
          <target state="translated">请遵循ALE README中的&lt;a href=&quot;https://github.com/w0rp/ale#3-installation&quot;&gt;说明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a6549a69a2a1d5be1e060e92d176ddae49cb2f2" translate="yes" xml:space="preserve">
          <source>Following our example from &lt;a href=&quot;#toc-objmap&quot;&gt;&lt;code&gt;$ObjMap&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, let&amp;rsquo;s assume that &lt;code&gt;run&lt;/code&gt; takes an array of functions, instead of an object, and maps over them returning an array of the function call results. We could annotate its return type like this:</source>
          <target state="translated">在&lt;a href=&quot;#toc-objmap&quot;&gt; &lt;code&gt;$ObjMap&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;示例之后，我们假设 &lt;code&gt;run&lt;/code&gt; 接受一个函数数组而不是一个对象，并映射到它们上以返回函数调用结果数组。我们可以这样注释它的返回类型：</target>
        </trans-unit>
        <trans-unit id="8a4d289d3b1dd5ba9aa2a66d282cd434d4d6eef2" translate="yes" xml:space="preserve">
          <source>For a full list of available lint rules, see the &lt;a href=&quot;https://flow.org/en/linting/rule-reference/&quot;&gt;Lint Rule Reference&lt;/a&gt;.</source>
          <target state="translated">有关可用的皮棉规则的完整列表，请参见《皮棉规则&lt;a href=&quot;https://flow.org/en/linting/rule-reference/&quot;&gt;参考》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c8b22a41ca2285196cb7b3e9c1ec2990d2a5b7b1" translate="yes" xml:space="preserve">
          <source>For cases like this where it&amp;rsquo;s useful to assert the absence of a property, Flow provides a special syntax for &lt;a href=&quot;https://flow.org/en/types/objects/#toc-exact-object-types&quot;&gt;&amp;ldquo;exact&amp;rdquo; object types&lt;/a&gt;.</source>
          <target state="translated">对于此类断言缺少属性很有用的情况，Flow提供了一种针对&lt;a href=&quot;https://flow.org/en/types/objects/#toc-exact-object-types&quot;&gt;&amp;ldquo;精确&amp;rdquo;对象类型&lt;/a&gt;的特殊语法。</target>
        </trans-unit>
        <trans-unit id="2ea9b94790107e111f7ed5653f532123efce19c9" translate="yes" xml:space="preserve">
          <source>For classes that take type parameters, you must also provide the parameter. For example:</source>
          <target state="translated">对于取类型参数的类,也必须提供参数。例如</target>
        </trans-unit>
        <trans-unit id="dc3c09a115b4ee611eb7505826a4fa0c2a8495d8" translate="yes" xml:space="preserve">
          <source>For example</source>
          <target state="translated">比如说</target>
        </trans-unit>
        <trans-unit id="c6f67e406326ac835e3cac37e1771059c44a2f4c" translate="yes" xml:space="preserve">
          <source>For example if you want to get a normal JavaScript array from a &lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt; see the following example:</source>
          <target state="translated">例如，如果您想从 &lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt; 获取普通的JavaScript数组，请参见以下示例：</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="eb4d70e0d036fa1748a5b85d77f3bc5e2328c134" translate="yes" xml:space="preserve">
          <source>For example, Flow uses structural typing for objects and functions, but nominal typing for classes.</source>
          <target state="translated">例如,Flow对对象和函数使用结构类型,但对类使用名义类型。</target>
        </trans-unit>
        <trans-unit id="7349dc404f299437995005ad91a4e45b836943bc" translate="yes" xml:space="preserve">
          <source>For example, a type alias with a generic is parameterized. When you go to use it you will have to provide a type argument.</source>
          <target state="translated">例如,一个带有泛型的类型别名被参数化了。当你去使用它时,你必须提供一个类型参数。</target>
        </trans-unit>
        <trans-unit id="019f85d55639d616f40bcfd5b84f65f5245b2f0d" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;/path/to/root/.flowconfig&lt;/code&gt; contains the following &lt;code&gt;[include]&lt;/code&gt; section:</source>
          <target state="translated">例如，如果 &lt;code&gt;/path/to/root/.flowconfig&lt;/code&gt; 包含以下 &lt;code&gt;[include]&lt;/code&gt; 部分：</target>
        </trans-unit>
        <trans-unit id="8308d7d3a3b1e0a7a0c7ff7fe6095b8469e2ca83" translate="yes" xml:space="preserve">
          <source>For example, if we had a &lt;code&gt;TypeA&lt;/code&gt; which described the numbers 1 through 3, and a &lt;code&gt;TypeB&lt;/code&gt; which described the numbers 1 through 5: &lt;code&gt;TypeA&lt;/code&gt; would be considered a &lt;em&gt;subtype&lt;/em&gt; of &lt;code&gt;TypeB&lt;/code&gt;, because &lt;code&gt;TypeA&lt;/code&gt; is a subset of &lt;code&gt;TypeB&lt;/code&gt;.</source>
          <target state="translated">例如，如果我们有一个 &lt;code&gt;TypeA&lt;/code&gt; 描述了其中数字1至3，和一个 &lt;code&gt;TypeB&lt;/code&gt; ，描述了其中数字1至5： &lt;code&gt;TypeA&lt;/code&gt; 将被认为是一个&lt;em&gt;子类型&lt;/em&gt;的 &lt;code&gt;TypeB&lt;/code&gt; ，因为 &lt;code&gt;TypeA&lt;/code&gt; 的一个子集 &lt;code&gt;TypeB&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b1f46c1686b7fc66c7fe476a788c1c2f746e357" translate="yes" xml:space="preserve">
          <source>For example, if we had an &lt;code&gt;ObjectA&lt;/code&gt; which contained the key &lt;code&gt;foo&lt;/code&gt;, and an &lt;code&gt;ObjectB&lt;/code&gt; which contained the keys &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt;. Then it&amp;rsquo;s possible that &lt;code&gt;ObjectB&lt;/code&gt; is a subtype of &lt;code&gt;ObjectA&lt;/code&gt;.</source>
          <target state="translated">例如，如果我们有一个 &lt;code&gt;ObjectA&lt;/code&gt; ，其包含的关键 &lt;code&gt;foo&lt;/code&gt; ，和 &lt;code&gt;ObjectB&lt;/code&gt; 含有键 &lt;code&gt;foo&lt;/code&gt; 的和 &lt;code&gt;bar&lt;/code&gt; 。然后，它可能是 &lt;code&gt;ObjectB&lt;/code&gt; 是的子类型 &lt;code&gt;ObjectA&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="23d2a83693c74cdf1216f4c41606ab3b6344cfb1" translate="yes" xml:space="preserve">
          <source>For example, if we have a value with a union type that is a &lt;code&gt;number&lt;/code&gt;, a &lt;code&gt;boolean&lt;/code&gt;, or a &lt;code&gt;string&lt;/code&gt;, we can treat the number case separately by using JavaScript&amp;rsquo;s &lt;code&gt;typeof&lt;/code&gt; operator.</source>
          <target state="translated">例如，如果我们具有一个联合类型为 &lt;code&gt;number&lt;/code&gt; ， &lt;code&gt;boolean&lt;/code&gt; 或 &lt;code&gt;string&lt;/code&gt; 的值，则可以使用JavaScript的 &lt;code&gt;typeof&lt;/code&gt; 运算符单独处理数字大小写。</target>
        </trans-unit>
        <trans-unit id="6f0bba8ae13a9f5893bc26e1914082a5b9531069" translate="yes" xml:space="preserve">
          <source>For example, if you do:</source>
          <target state="translated">比如说,如果你做。</target>
        </trans-unit>
        <trans-unit id="65cad2079cddef1c7f55821c6579030cdb56abc4" translate="yes" xml:space="preserve">
          <source>For example, if you get a property on an object typed &lt;code&gt;any&lt;/code&gt;, the resulting value will also have the type &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">例如，如果获得类型为 &lt;code&gt;any&lt;/code&gt; 的对象的属性，则结果值也将具有 &lt;code&gt;any&lt;/code&gt; 的类型。</target>
        </trans-unit>
        <trans-unit id="b93fa61c86ebe13144616aecf546634749ff3161" translate="yes" xml:space="preserve">
          <source>For example, if you merge two objects with a property named &lt;code&gt;prop&lt;/code&gt;, first with a type of number and second with a type of boolean, accessing &lt;code&gt;prop&lt;/code&gt; will return &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d2c0eb517854e42dedcf683011bb1eed6441385" translate="yes" xml:space="preserve">
          <source>For example, if you merge two objects with a property named prop, one with a type of number and another with a type of boolean, the resulting object will have an intersection of number and boolean.</source>
          <target state="translated">例如,如果你合并了两个具有名为prop的属性的对象,一个对象的类型是数字,另一个对象的类型是布尔,那么产生的对象将具有数字和布尔的交集。</target>
        </trans-unit>
        <trans-unit id="0ff184d53e398a510529293cf769afe6beb5de53" translate="yes" xml:space="preserve">
          <source>For example, if you use &lt;code&gt;typeof&lt;/code&gt; with a class you need to remember that classes are &lt;em&gt;nominally&lt;/em&gt; typed instead of &lt;em&gt;structurally&lt;/em&gt; typed. So that two classes with the same exact shape are not considered equivalent.</source>
          <target state="translated">例如，如果将 &lt;code&gt;typeof&lt;/code&gt; 与类一起使用，则需要记住，类是&lt;em&gt;名义上的&lt;/em&gt;类型而不是&lt;em&gt;结构上的&lt;/em&gt;类型。因此，具有相同精确形状的两个类不视为等效。</target>
        </trans-unit>
        <trans-unit id="725f953bd64b3a92b317e1b1004670c00e1cbdb9" translate="yes" xml:space="preserve">
          <source>For example, imagine we have a function for handling a response from a server after we&amp;rsquo;ve sent it a request. When the request is successful, we&amp;rsquo;ll get back an object with a &lt;code&gt;success&lt;/code&gt; property which is &lt;code&gt;true&lt;/code&gt; and a &lt;code&gt;value&lt;/code&gt; that we&amp;rsquo;ve updated.</source>
          <target state="translated">例如，假设我们有一个函数，可以在向服务器发送请求后处理来自服务器的响应。当请求成功时，我们将返回一个对象，该对象具有为 &lt;code&gt;true&lt;/code&gt; 的 &lt;code&gt;success&lt;/code&gt; 属性和一个已更新的 &lt;code&gt;value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3102783616c1fb2ad801701f0f1fe894f5a7f3c4" translate="yes" xml:space="preserve">
          <source>For example, in order to know if you are calling a function correctly, Flow needs to compare the arguments you are passing with the parameters the function expects.</source>
          <target state="translated">例如,为了知道你是否正确调用了一个函数,Flow需要将你传递的参数与函数期望的参数进行比较。</target>
        </trans-unit>
        <trans-unit id="b4c3b99484dfdd0c8d74a80cfc7020381cb7fd5b" translate="yes" xml:space="preserve">
          <source>For example, instead of accepting &lt;code&gt;number&lt;/code&gt; type, we could accept only the literal value &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">例如，代替接受 &lt;code&gt;number&lt;/code&gt; 类型，我们可以只接受文字值 &lt;code&gt;2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0d7e7c460bdc5abc1277e2c78f9349f50b395124" translate="yes" xml:space="preserve">
          <source>For example, the following code will not report any errors:</source>
          <target state="translated">例如,以下代码将不会报告任何错误。</target>
        </trans-unit>
        <trans-unit id="be2868a9fb7a2e636970247ed66a6e565dcb7b90" translate="yes" xml:space="preserve">
          <source>For example, the following function for cloning an object.</source>
          <target state="translated">例如,以下是克隆对象的函数。</target>
        </trans-unit>
        <trans-unit id="c57d353ecaa5b9ae469153e8bd0494c2759cfd0e" translate="yes" xml:space="preserve">
          <source>For example, to figure out the result of the following expression, Flow needs to figure out what its values are first.</source>
          <target state="translated">例如,要弄清楚下面表达式的结果,Flow需要先弄清楚它的值是什么。</target>
        </trans-unit>
        <trans-unit id="c6c8a9ac1f5c16025ef387a60063c1bc2ea40cd1" translate="yes" xml:space="preserve">
          <source>For example, when you create an intersection of two objects with different sets of properties, it will result in an object with all of the properties.</source>
          <target state="translated">例如,当您创建具有不同属性集的两个对象的交集时,将产生一个具有所有属性的对象。</target>
        </trans-unit>
        <trans-unit id="be0defaf069697775abe92858214aa6eab2ca76b" translate="yes" xml:space="preserve">
          <source>For example, when you use literal values in Flow, their inferred type is the primitive that it belongs to. Thus, the number 42 has the inferred type of &lt;code&gt;number&lt;/code&gt;. You can see this when you use &lt;code&gt;typeof&lt;/code&gt;.</source>
          <target state="translated">例如，当您在Flow中使用文字值时，它们的推断类型就是它所属的原语。因此，数42具有推断出的类型的 &lt;code&gt;number&lt;/code&gt; 。当您使用 &lt;code&gt;typeof&lt;/code&gt; 时，您会看到此信息。</target>
        </trans-unit>
        <trans-unit id="7a78f29fa972df73a82d620ebcbf55256b542d21" translate="yes" xml:space="preserve">
          <source>For example, you can create an intersection of a number and a string.</source>
          <target state="translated">例如,你可以创建一个数字和一个字符串的交点。</target>
        </trans-unit>
        <trans-unit id="c6bf9aa556ae7aa47497704d8a136318cf4656ef" translate="yes" xml:space="preserve">
          <source>For example, you can write:</source>
          <target state="translated">例如,你可以写。</target>
        </trans-unit>
        <trans-unit id="41cd59ae29edba6c60d70a4800b3539e40d937dc" translate="yes" xml:space="preserve">
          <source>For example, you could be accessing an element that is out of the bounds of the array.</source>
          <target state="translated">例如,你可能会访问一个超出数组边界的元素。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="8e7b3364aed4ab54bcb5fbf0be1c986544a80686" translate="yes" xml:space="preserve">
          <source>For files in your project without this flag, the Flow background process skips and ignores the code (unless you call &lt;code&gt;flow check --all&lt;/code&gt;, which is beyond the scope of basic usage).</source>
          <target state="translated">对于项目中没有此标志的文件，Flow后台进程将跳过并忽略代码（除非您调用 &lt;code&gt;flow check --all&lt;/code&gt; ，这超出了基本用法的范围）。</target>
        </trans-unit>
        <trans-unit id="6adf72d1444fb7909aee272ad9e96f51f02d4b69" translate="yes" xml:space="preserve">
          <source>For instance, in this &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBLAtgB1gJwC6gFSgCGAzqAEoCmRAxnpFrKqAORbV0sDciiNsAOxJ4SlHABUAnukqgAvKABCpSgGEmmAZQF45APlDpG6MvtAAeZaPUZB2vAG8AdC6OwTAX1A5plOQCIAIwBXHBxBf1BgPR5+ITwAcW1KLGQaRVDwgXlQAAoHHxkAGlAaAAtkaAATdgEPAEp5A3MQsMFvXzkC3y9BVWg0gGsu3MazOJJYaEonOABzXJYaAZpByiqWeo89B3LKmu0Pc2BWrJjeCbwMtoEALgoOHCcbTXspGXNdiura+6paJ4AOVgVUo2xyogkvlySS0qXSmUE9S4QA&quot;&gt;example&lt;/a&gt;, we don&amp;rsquo;t type the HOC (setType), but the component created with it, &lt;code&gt;Button&lt;/code&gt;. To do so, we use the type &lt;code&gt;React.ComponentType&lt;/code&gt;.</source>
          <target state="translated">例如，在此&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBLAtgB1gJwC6gFSgCGAzqAEoCmRAxnpFrKqAORbV0sDciiNsAOxJ4SlHABUAnukqgAvKABCpSgGEmmAZQF45APlDpG6MvtAAeZaPUZB2vAG8AdC6OwTAX1A5plOQCIAIwBXHBxBf1BgPR5+ITwAcW1KLGQaRVDwgXlQAAoHHxkAGlAaAAtkaAATdgEPAEp5A3MQsMFvXzkC3y9BVWg0gGsu3MazOJJYaEonOABzXJYaAZpByiqWeo89B3LKmu0Pc2BWrJjeCbwMtoEALgoOHCcbTXspGXNdiura+6paJ4AOVgVUo2xyogkvlySS0qXSmUE9S4QA&quot;&gt;示例中&lt;/a&gt;，我们不键入HOC（setType），而是使用它创建的组件 &lt;code&gt;Button&lt;/code&gt; 。为此，我们使用类型 &lt;code&gt;React.ComponentType&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fdce77763d38af3a8b71abca1c0293dafa227070" translate="yes" xml:space="preserve">
          <source>For more on lazy modes, see the &lt;a href=&quot;../lang/lazy-modes&quot;&gt;lazy modes docs&lt;/a&gt;.</source>
          <target state="translated">有关延迟模式的更多信息，请参见&lt;a href=&quot;../lang/lazy-modes&quot;&gt;延迟模式docs&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5a9ff0d1ea1569c81eb6dd1194e556900bb25139" translate="yes" xml:space="preserve">
          <source>For more on types-first mode, see the &lt;a href=&quot;../lang/types-first&quot;&gt;types-first docs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c03eb76d06156d9151d583bf5017b60d060c9e8f" translate="yes" xml:space="preserve">
          <source>For objects like these, Flow provides a special kind of property, called an &amp;ldquo;indexer property.&amp;rdquo; An indexer property allows reads and writes using any key that matches the indexer key type.</source>
          <target state="translated">对于此类对象，Flow提供了一种特殊的属性，称为&amp;ldquo;索引器属性&amp;rdquo;。索引器属性允许使用与索引器键类型匹配的任何键进行读写。</target>
        </trans-unit>
        <trans-unit id="4ab0510537ce0eb4731a9b80070bc58fde2f4090" translate="yes" xml:space="preserve">
          <source>For that reason (and others), it&amp;rsquo;s useful to write types for important functions.</source>
          <target state="translated">因此（为其他原因），为重要函数编写类型很有用。</target>
        </trans-unit>
        <trans-unit id="bdccfdba2af4464ab5f05d14e93c225840b2b001" translate="yes" xml:space="preserve">
          <source>For the &lt;a href=&quot;#toc-write-flow-code&quot;&gt;code above&lt;/a&gt;, running &lt;code&gt;flow&lt;/code&gt; will yield:</source>
          <target state="translated">对于&lt;a href=&quot;#toc-write-flow-code&quot;&gt;上面&lt;/a&gt;的代码，运行 &lt;code&gt;flow&lt;/code&gt; 将产生：</target>
        </trans-unit>
        <trans-unit id="0fff3409e13cd93e88e21ac5285c632cc985eaba" translate="yes" xml:space="preserve">
          <source>Forcing Flow to Treat a File as Focused</source>
          <target state="translated">强制流将文件视为重点文件。</target>
        </trans-unit>
        <trans-unit id="cc51c13e52ce8d73c0bb48b450274afb9f82073c" translate="yes" xml:space="preserve">
          <source>Fortunately, JavaScript is already written using files as modules, so we modularize our analysis simply by asking that modules have explicitly typed signatures. (We still infer types for the vast majority of code &amp;ldquo;local&amp;rdquo; to modules.) Coincidentally, developers consider this good software engineering practice anyway.</source>
          <target state="translated">幸运的是，JavaScript已经使用文件作为模块来编写，因此我们仅通过要求模块具有显式键入的签名就可以对分析进行模块化。（我们仍然将&amp;ldquo;本地&amp;rdquo;代码的绝大多数类型推断为模块的类型。）巧合的是，开发人员仍然认为这种良好的软件工程实践。</target>
        </trans-unit>
        <trans-unit id="1c86bf0b4a5d6b8fe12a31c428cd9618f1707a5a" translate="yes" xml:space="preserve">
          <source>Function &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">功能 &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="751924331feba79685bd7ca453e7d70d1ee39798" translate="yes" xml:space="preserve">
          <source>Function Declarations</source>
          <target state="translated">功能声明</target>
        </trans-unit>
        <trans-unit id="cec90ffa8d067cfb33c2b7e5ea59f57a4ab51f07" translate="yes" xml:space="preserve">
          <source>Function Parameters</source>
          <target state="translated">功能参数</target>
        </trans-unit>
        <trans-unit id="8b80c6d0c0eb90a4193c11e2b8f639ce9765572d" translate="yes" xml:space="preserve">
          <source>Function Returns</source>
          <target state="translated">函数返回</target>
        </trans-unit>
        <trans-unit id="5b51ae5c386fcffd7ce1ff55e49610a2a8af3637" translate="yes" xml:space="preserve">
          <source>Function Types</source>
          <target state="translated">功能类型</target>
        </trans-unit>
        <trans-unit id="7cc900b0e76620e1c35c363651461063a5b2d0d3" translate="yes" xml:space="preserve">
          <source>Function parameters can also have defaults. This is a feature of ECMAScript 2015.</source>
          <target state="translated">函数参数也可以有默认值。这是ECMAScript 2015的一个特点。</target>
        </trans-unit>
        <trans-unit id="e686426824459378af5e98ab82feb0bfc1faa0e2" translate="yes" xml:space="preserve">
          <source>Function parameters can have types by adding a colon &lt;code&gt;:&lt;/code&gt; followed by the type after the name of the parameter.</source>
          <target state="translated">通过添加冒号 &lt;code&gt;:&lt;/code&gt; 可以在函数参数中具有类型：其后是参数名称之后的类型。</target>
        </trans-unit>
        <trans-unit id="e20f19430f4406d7d479bb1219578533f21581f6" translate="yes" xml:space="preserve">
          <source>Function parameters with defaults</source>
          <target state="translated">功能参数与默认值</target>
        </trans-unit>
        <trans-unit id="e628cf6d4cf7f3f60c7c92cf5e2c6d4764b18a50" translate="yes" xml:space="preserve">
          <source>Function returns can also add a type using a colon &lt;code&gt;:&lt;/code&gt; followed by the type after the list of parameters.</source>
          <target state="translated">函数返回值还可以使用冒号添加类型 &lt;code&gt;:&lt;/code&gt; 在参数列表之后紧跟该类型。</target>
        </trans-unit>
        <trans-unit id="31bf38f4775fc5c5a798a785e09ec45b75300cf9" translate="yes" xml:space="preserve">
          <source>Function types can create generics in the same way as normal functions, by adding the type parameter list &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; before the function type parameter list.</source>
          <target state="translated">通过在函数类型参数列表之前添加类型参数列表 &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; ，函数类型可以以与普通函数相同的方式创建泛型。</target>
        </trans-unit>
        <trans-unit id="1696fa363249b910e5a51ac92f7e2be6cd65b5b4" translate="yes" xml:space="preserve">
          <source>Function types with generics</source>
          <target state="translated">带属的函数类型</target>
        </trans-unit>
        <trans-unit id="3f7381fb33fff215013d059733e6eb1073506aa9" translate="yes" xml:space="preserve">
          <source>Functions are structurally typed</source>
          <target state="translated">函数的结构类型为</target>
        </trans-unit>
        <trans-unit id="7a2f0bb1d54ff79eaaada0c3765d727c899bb522" translate="yes" xml:space="preserve">
          <source>Functions can create generics by adding the type parameter list &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; before the function parameter list.</source>
          <target state="translated">函数可以通过在函数参数列表之前添加类型参数列表 &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 来创建泛型。</target>
        </trans-unit>
        <trans-unit id="d02cbcdf0a2a69aa715691fa238dfa6ccdc16a05" translate="yes" xml:space="preserve">
          <source>Functions can have optional parameters where a question mark &lt;code&gt;?&lt;/code&gt; comes after the parameter name.</source>
          <target state="translated">函数可以具有可选参数，问号在哪里 &lt;code&gt;?&lt;/code&gt; 在参数名称之后。</target>
        </trans-unit>
        <trans-unit id="cf63b2e1b9aafbb240f7e1deca5b67f9988ef437" translate="yes" xml:space="preserve">
          <source>Functions have two places where types are applied: Parameters (input) and the return value (output).</source>
          <target state="translated">函数有两个地方是应用类型的。参数(输入)和返回值(输出)。</target>
        </trans-unit>
        <trans-unit id="3c12be471a4e96534a926aacb0df7453eb2cbcca" translate="yes" xml:space="preserve">
          <source>Functions with generics</source>
          <target state="translated">带属的函数</target>
        </trans-unit>
        <trans-unit id="0c9ce2261f9d73896e79a1421f34d061659a9e49" translate="yes" xml:space="preserve">
          <source>General Best Practices</source>
          <target state="translated">一般最佳做法</target>
        </trans-unit>
        <trans-unit id="67ac7fcb0777deb807997c9f4b924988984d0fbd" translate="yes" xml:space="preserve">
          <source>Generally, the type you should first try when adding a type for the children of your React component is &lt;a href=&quot;../types#toc-react-node&quot;&gt;&lt;code&gt;React.Node&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通常，在为React组件的&lt;a href=&quot;../types#toc-react-node&quot;&gt; &lt;code&gt;React.Node&lt;/code&gt; &lt;/a&gt;添加类型时应首先尝试的类型是React.Node。</target>
        </trans-unit>
        <trans-unit id="6e69a2fc2c745899f35839a75d651978ee056569" translate="yes" xml:space="preserve">
          <source>Generic Types</source>
          <target state="translated">通用类型</target>
        </trans-unit>
        <trans-unit id="f9d7e3ac4698ff4fedd01cf6807aee7a9efac823" translate="yes" xml:space="preserve">
          <source>Generic types act as bounds</source>
          <target state="translated">通用类型作为边界</target>
        </trans-unit>
        <trans-unit id="f8c73c016669e4acd2b923bc11fc67ea9ad59c62" translate="yes" xml:space="preserve">
          <source>Generic types work a lot like variables or function parameters except that they are used for types. You can use them whenever they are in scope.</source>
          <target state="translated">通用类型的工作原理很像变量或函数参数,除了它们是用于类型的。只要它们在范围内,你就可以使用它们。</target>
        </trans-unit>
        <trans-unit id="80dadd86173d0ff3979257793d4e45beb238b6a2" translate="yes" xml:space="preserve">
          <source>Generics</source>
          <target state="translated">Generics</target>
        </trans-unit>
        <trans-unit id="1b3bd820ca45310f82d504b4fd55b7117cc37547" translate="yes" xml:space="preserve">
          <source>Generics (sometimes referred to as polymorphic types) are a way of abstracting a type away.</source>
          <target state="translated">通用类型(有时也称为多态类型)是一种将类型抽象化的方式。</target>
        </trans-unit>
        <trans-unit id="a6fd94560566e4986674c54d1df1a19a7110e683" translate="yes" xml:space="preserve">
          <source>Generics act like variables</source>
          <target state="translated">通用的作用就像变量</target>
        </trans-unit>
        <trans-unit id="ef394c1226958fc727e62243c4cb43ac0e4cd5cf" translate="yes" xml:space="preserve">
          <source>Generics allow you to hold onto the more specific type while adding a constraint. In this way types on generics act as &amp;ldquo;bounds&amp;rdquo;.</source>
          <target state="translated">泛型允许您在添加约束的同时保留更具体的类型。这样，泛型上的类型就充当了&amp;ldquo;界限&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="4aadf67c9db3328742fd5a86fc24b21a1a76c43e" translate="yes" xml:space="preserve">
          <source>Generics can be used within functions, function types, classes, type aliases, and interfaces.</source>
          <target state="translated">通用可以在函数、函数类型、类、类型别名和接口中使用。</target>
        </trans-unit>
        <trans-unit id="7faae52c2d4462ab2eaff369392d43e6c1364b8c" translate="yes" xml:space="preserve">
          <source>Generics sometimes allow you to pass types in like arguments to a function. These are known as parameterized generics (or parametric polymorphism).</source>
          <target state="translated">泛型有时允许你把类型像参数一样传递给一个函数。这就是所谓的参数化泛型(或参数多态)。</target>
        </trans-unit>
        <trans-unit id="0d8ccea6ce861b3356a8a1401bc73a5e10e8c648" translate="yes" xml:space="preserve">
          <source>Generics track values around</source>
          <target state="translated">通用型追踪值</target>
        </trans-unit>
        <trans-unit id="cfcb0c850227d5c43ba836a3ca78b5b97f74a944" translate="yes" xml:space="preserve">
          <source>Gets the instance type for a React element. The instance will be different for various component types:</source>
          <target state="translated">获取React元素的实例类型。对于不同的组件类型,实例会有所不同。</target>
        </trans-unit>
        <trans-unit id="236e116424d14004e90c27673c86a646ef19fa8e" translate="yes" xml:space="preserve">
          <source>Gets the props for a React element type, &lt;em&gt;without&lt;/em&gt; preserving the optionality of &lt;code&gt;defaultProps&lt;/code&gt;. &lt;code&gt;typeof Component&lt;/code&gt; could be the type of a React class component, a stateless functional component, or a JSX intrinsic string. This type is used for the &lt;code&gt;props&lt;/code&gt; property on &lt;a href=&quot;#toc-react-element&quot;&gt;&lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在&lt;em&gt;不&lt;/em&gt;保留 &lt;code&gt;defaultProps&lt;/code&gt; 可选性的&lt;em&gt;情况下&lt;/em&gt;获取React元素类型的props 。 &lt;code&gt;typeof Component&lt;/code&gt; 可以是React类组件的类型，无状态功能组件或JSX内部字符串。此类型用于&lt;a href=&quot;#toc-react-element&quot;&gt; &lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt; &lt;/a&gt;上的 &lt;code&gt;props&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">入门</target>
        </trans-unit>
        <trans-unit id="0ea124ff781dabd2f0647eac33da1b5dda4dac00" translate="yes" xml:space="preserve">
          <source>Given a type &lt;code&gt;T&lt;/code&gt; representing instances of a class &lt;code&gt;C&lt;/code&gt;, the type &lt;code&gt;Class&amp;lt;T&amp;gt;&lt;/code&gt; is the type of the class &lt;code&gt;C&lt;/code&gt;. For example:</source>
          <target state="translated">给定类型 &lt;code&gt;T&lt;/code&gt; 表示类 &lt;code&gt;C&lt;/code&gt; 的实例，类型 &lt;code&gt;Class&amp;lt;T&amp;gt;&lt;/code&gt; 是类 &lt;code&gt;C&lt;/code&gt; 的类型。例如：</target>
        </trans-unit>
        <trans-unit id="851df84ffecc429e99c3dd230d56812d1b5b6739" translate="yes" xml:space="preserve">
          <source>Have a question about using Flow? Check here first!</source>
          <target state="translated">对使用Flow有疑问?请先查看这里</target>
        </trans-unit>
        <trans-unit id="2ddc501d850ae3a0f6c0d81b4cee3f2a7263c9d2" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;props.children&lt;/code&gt; will be an array of arrays. Specifically &lt;code&gt;props.children&lt;/code&gt; will be &lt;code&gt;[[1, 2], [3, 4]]&lt;/code&gt;.</source>
          <target state="translated">这里 &lt;code&gt;props.children&lt;/code&gt; 将是一个数组数组。具体来说， &lt;code&gt;props.children&lt;/code&gt; 将是 &lt;code&gt;[[1, 2], [3, 4]]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3827f0f684068e8b08cda57d14ca02f9de4d36d2" translate="yes" xml:space="preserve">
          <source>Here is an example of &lt;code&gt;React.Node&lt;/code&gt; as the prop type for children:</source>
          <target state="translated">这是 &lt;code&gt;React.Node&lt;/code&gt; 作为子类的prop类型的示例：</target>
        </trans-unit>
        <trans-unit id="c801032aa18d6a477cf713f1624762e4f08d3af9" translate="yes" xml:space="preserve">
          <source>Here is an example of &lt;code&gt;React.Node&lt;/code&gt; being used as the return type to &lt;code&gt;render()&lt;/code&gt;:</source>
          <target state="translated">这是一个 &lt;code&gt;React.Node&lt;/code&gt; 用作 &lt;code&gt;render()&lt;/code&gt; 的返回类型的示例：</target>
        </trans-unit>
        <trans-unit id="bdd7a2f9607a075cf7fd0924bbed317c0eec84d4" translate="yes" xml:space="preserve">
          <source>Here is an example of how you could use the &lt;code&gt;.flowconfig&lt;/code&gt; directives.</source>
          <target state="translated">这是如何使用 &lt;code&gt;.flowconfig&lt;/code&gt; 指令的示例。</target>
        </trans-unit>
        <trans-unit id="aa528d54a7d8103f41c0bfd3b9b8fae4b3e30c90" translate="yes" xml:space="preserve">
          <source>Here is how you may use &lt;code&gt;React.ComponentType&amp;lt;Props&amp;gt;&lt;/code&gt; with &lt;a href=&quot;#toc-react-element&quot;&gt;&lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt;&lt;/a&gt; to construct a component with a specific set of props:</source>
          <target state="translated">这是如何将 &lt;code&gt;React.ComponentType&amp;lt;Props&amp;gt;&lt;/code&gt; 与&lt;a href=&quot;#toc-react-element&quot;&gt; &lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt; &lt;/a&gt;来构造具有一组特定道具的组件：</target>
        </trans-unit>
        <trans-unit id="535fabe7a4cb455852726d03b7da421c7856e385" translate="yes" xml:space="preserve">
          <source>Here is how you would type the &lt;code&gt;&amp;lt;Route&amp;gt;&lt;/code&gt; component in Flow:</source>
          <target state="translated">这是您在Flow中键入 &lt;code&gt;&amp;lt;Route&amp;gt;&lt;/code&gt; 组件的方式：</target>
        </trans-unit>
        <trans-unit id="af8389a6ecc318bb6ebf315d56db66ecc756233e" translate="yes" xml:space="preserve">
          <source>Here the input value can only be a &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">在此输入值只能是 &lt;code&gt;number&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="25234e5462d0d0721c9abf9cb778d69feaeba093" translate="yes" xml:space="preserve">
          <source>Here the input value could be either a &lt;code&gt;string&lt;/code&gt; or a &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">在这里，输入值可以是 &lt;code&gt;string&lt;/code&gt; 或 &lt;code&gt;number&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87b8649ae5d0883f7fd9dfda5cfcf802e8591bd6" translate="yes" xml:space="preserve">
          <source>Here the passed in value is an unknown type, it could be any type and the function would still work.</source>
          <target state="translated">这里传入的值是一个未知类型,它可以是任何类型,函数仍然可以工作。</target>
        </trans-unit>
        <trans-unit id="17a73674e1d8aaed9bcfe2a7bd9df88099e17a9f" translate="yes" xml:space="preserve">
          <source>Here the return type will be the same as the type of whatever value is passed into the function.</source>
          <target state="translated">这里的返回类型将与传入函数的任何值的类型相同。</target>
        </trans-unit>
        <trans-unit id="13bad31d551f7ce53902bee6f5b588e74599b66e" translate="yes" xml:space="preserve">
          <source>Here you can see a pseudo-example of a nominal type system erroring out when you&amp;rsquo;re trying to put a &lt;code&gt;Bar&lt;/code&gt; where a &lt;code&gt;Foo&lt;/code&gt; is required because they have different names.</source>
          <target state="translated">在这里，当您尝试将 &lt;code&gt;Bar&lt;/code&gt; 放置在需要 &lt;code&gt;Foo&lt;/code&gt; 的地方时，您会看到名义类型系统出错的伪示例，因为它们的名称不同。</target>
        </trans-unit>
        <trans-unit id="098e77f7a550b2cf510ca26c4aeb1fba8e8580b9" translate="yes" xml:space="preserve">
          <source>Here you can see a pseudo-example of a structural type system passing when you&amp;rsquo;re trying to put a Bar where a &lt;code&gt;Foo&lt;/code&gt; is required because their structure is exactly the same.</source>
          <target state="translated">在这里，当您尝试将Bar放置在需要 &lt;code&gt;Foo&lt;/code&gt; 的地方时，您会看到一个结构类型系统通过的伪示例，因为它们的结构完全相同。</target>
        </trans-unit>
        <trans-unit id="9d42546ad988361114be19ba4faa6ffd09713b98" translate="yes" xml:space="preserve">
          <source>Here you can see the syntax for arrow functions with and without types added.</source>
          <target state="translated">在这里,你可以看到添加和不添加类型的箭头函数的语法。</target>
        </trans-unit>
        <trans-unit id="d3699f0333712613b9e8dd3485f37fca22346ed0" translate="yes" xml:space="preserve">
          <source>Here you can see the syntax for function declarations with and without types added.</source>
          <target state="translated">在这里,你可以看到添加和不添加类型的函数声明的语法。</target>
        </trans-unit>
        <trans-unit id="56b22036dfc0a76c4f96b2794020b9590adaecf9" translate="yes" xml:space="preserve">
          <source>Here you can see the syntax for writing types that are functions.</source>
          <target state="translated">在这里你可以看到写类型是函数的语法。</target>
        </trans-unit>
        <trans-unit id="7fac12a07532dfa0ddfc895f9ad228b8e092de33" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a possible declaration of this function, which is very similar to our first example:</source>
          <target state="translated">这是此函数的可能声明，与我们的第一个示例非常相似：</target>
        </trans-unit>
        <trans-unit id="fbf28fb6962ce31b4060a59b6e700daf856a84f6" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;showFoo&lt;/code&gt; is a boolean which controls whether or not to display the &lt;code&gt;&amp;lt;Foo /&amp;gt;&lt;/code&gt; element. If &lt;code&gt;showFoo&lt;/code&gt; is true, then this evaluates to &lt;code&gt;{&amp;lt;Foo/&amp;gt;}&lt;/code&gt;. If &lt;code&gt;showFoo&lt;/code&gt; is false, then this evaluates to &lt;code&gt;{false}&lt;/code&gt;, which doesn&amp;rsquo;t display anything.</source>
          <target state="translated">在这里， &lt;code&gt;showFoo&lt;/code&gt; 是一个布尔值，它控制是否显示 &lt;code&gt;&amp;lt;Foo /&amp;gt;&lt;/code&gt; 元素。如果 &lt;code&gt;showFoo&lt;/code&gt; 为true，则结果为 &lt;code&gt;{&amp;lt;Foo/&amp;gt;}&lt;/code&gt; 。如果 &lt;code&gt;showFoo&lt;/code&gt; 为false，则结果为 &lt;code&gt;{false}&lt;/code&gt; ，不显示任何内容。</target>
        </trans-unit>
        <trans-unit id="a9f4df1640a61e73a368f05d84051cfbe689fd43" translate="yes" xml:space="preserve">
          <source>Here, Flow will complain on the &lt;code&gt;export&lt;/code&gt;, asking for a type annotation. Flow wants you to annotate exports returned by a generic function. The type of &lt;code&gt;Array.prototype.map&lt;/code&gt; is &lt;code&gt;map&amp;lt;U&amp;gt;(callbackfn: (value: T, index: number, array: Array&amp;lt;T&amp;gt;) =&amp;gt; U, thisArg?: any): Array&amp;lt;U&amp;gt;&lt;/code&gt;. The &lt;code&gt;&amp;lt;U&amp;gt;&lt;/code&gt; corresponds to what is called a &lt;a href=&quot;types/generics&quot;&gt;generic&lt;/a&gt;, to express the fact that the type of the function passed to map is linked to the type of the array.</source>
          <target state="translated">在这里，Flow将抱怨 &lt;code&gt;export&lt;/code&gt; ，要求提供类型注释。Flow希望您注释通用函数返回的导出。 &lt;code&gt;Array.prototype.map&lt;/code&gt; 的类型是 &lt;code&gt;map&amp;lt;U&amp;gt;(callbackfn: (value: T, index: number, array: Array&amp;lt;T&amp;gt;) =&amp;gt; U, thisArg?: any): Array&amp;lt;U&amp;gt;&lt;/code&gt; 。所述 &lt;code&gt;&amp;lt;U&amp;gt;&lt;/code&gt; 对应于所谓的&lt;a href=&quot;types/generics&quot;&gt;通用&lt;/a&gt;，以表达传递给地图的功能的类型链接到数组的类型的事实。</target>
        </trans-unit>
        <trans-unit id="ee8ceb048fbb5cd5fd5303e935623ce260603c2b" translate="yes" xml:space="preserve">
          <source>Here, a work around would be to extract the part of the value you&amp;rsquo;re interested in, or to move the if check inside the &lt;code&gt;setTimeout&lt;/code&gt; call:</source>
          <target state="translated">在这里，一种变通方法是提取您感兴趣的部分值，或者将if检查移入 &lt;code&gt;setTimeout&lt;/code&gt; 调用中：</target>
        </trans-unit>
        <trans-unit id="cc00b92fae87138445b8db76c9ab4f421cd563cb" translate="yes" xml:space="preserve">
          <source>Higher-order Components</source>
          <target state="translated">高阶组件</target>
        </trans-unit>
        <trans-unit id="9afcd5258af293b3e8dd22ec752eba0c2f251483" translate="yes" xml:space="preserve">
          <source>How to use Flow from the command line. Including how to manage the Flow background process.</source>
          <target state="translated">如何从命令行使用Flow。包括如何管理Flow的后台进程。</target>
        </trans-unit>
        <trans-unit id="c6b59c452c954d9defbf04ad89b295d7369263a0" translate="yes" xml:space="preserve">
          <source>However it is limited in that this string only describes so much about the type.</source>
          <target state="translated">然而它是有限的,因为这个字符串只能描述这么多关于类型的信息。</target>
        </trans-unit>
        <trans-unit id="a35ae847b7dbe7d8fd62853289ce430ad193bce8" translate="yes" xml:space="preserve">
          <source>However sometimes there isn&amp;rsquo;t a pre-existing libdef or you have third-party code that isn&amp;rsquo;t public and/or you really just need to write a libdef yourself. To do this you&amp;rsquo;ll start by creating a &lt;code&gt;.js&lt;/code&gt; file for each libdef you&amp;rsquo;re going to write and put them in the &lt;code&gt;/flow-typed&lt;/code&gt; directory at the root of your project. In these libdef file(s) you&amp;rsquo;ll use a special set of Flow syntax (explained below) to describe the interfaces of the relevant third-party code.</source>
          <target state="translated">但是，有时没有预先存在的libdef，或者您拥有不公开的第三方代码，并且/或者您只需要自己编写一个libdef。为此，首先要为要编写的每个libdef 创建一个 &lt;code&gt;.js&lt;/code&gt; 文件，并将其放在项目根目录的 &lt;code&gt;/flow-typed&lt;/code&gt; 目录中。在这些libdef文件中，您将使用特殊的Flow语法集（如下所述）来描述相关第三方代码的接口。</target>
        </trans-unit>
        <trans-unit id="1dabc8a9daa16baa576a945117465517c0ab5c57" translate="yes" xml:space="preserve">
          <source>However, Flow has &lt;a href=&quot;types/functions#toc-predicate-functions&quot;&gt;predicates functions&lt;/a&gt; that can do these checks via &lt;code&gt;%checks&lt;/code&gt;.</source>
          <target state="translated">但是，Flow具有&lt;a href=&quot;types/functions#toc-predicate-functions&quot;&gt;谓词功能&lt;/a&gt;，可以通过 &lt;code&gt;%checks&lt;/code&gt; 进行这些检查。</target>
        </trans-unit>
        <trans-unit id="27bb39d29e968deb761d41de85ea44344a3e8143" translate="yes" xml:space="preserve">
          <source>However, Flow will flag an error in the code below:</source>
          <target state="translated">但是,Flow会在下面的代码中标记一个错误。</target>
        </trans-unit>
        <trans-unit id="067267fea785830c12b74c19441557fb234dc53a" translate="yes" xml:space="preserve">
          <source>However, evolving and growing a JavaScript codebase is notoriously challenging. Developers cannot move fast when they break stuff. They hit frequent interruptions, spending a lot of time debugging silly mistakes, unraveling assumptions and guarantees made by libraries written by others, etc.</source>
          <target state="translated">然而,发展和壮大JavaScript代码库是众所周知的挑战。开发人员在破坏东西的时候不能快速移动。他们会遇到频繁的中断,花大量时间调试愚蠢的错误,解开别人写的库所做的假设和保证等等。</target>
        </trans-unit>
        <trans-unit id="0a3b394df7ec3cd961692cc5e230a54570e64cb9" translate="yes" xml:space="preserve">
          <source>However, if you need to opt-out of the type checker, and don&amp;rsquo;t want to go all the way to &lt;code&gt;any&lt;/code&gt;, you can instead use &lt;code&gt;(...args: Array&amp;lt;any&amp;gt;) =&amp;gt; any&lt;/code&gt;. (Note that &lt;a href=&quot;../any&quot;&gt;&lt;code&gt;any&lt;/code&gt;&lt;/a&gt; is unsafe and should be avoided). For historical reasons, the &lt;code&gt;Function&lt;/code&gt; keyword is still available.</source>
          <target state="translated">但是，如果您需要选择退出类型检查器，并且不想一直使用 &lt;code&gt;any&lt;/code&gt; ，则可以改用 &lt;code&gt;(...args: Array&amp;lt;any&amp;gt;) =&amp;gt; any&lt;/code&gt; 。（请注意，&lt;a href=&quot;../any&quot;&gt; &lt;code&gt;any&lt;/code&gt; &lt;/a&gt;都是不安全的，应避免使用）。由于历史原因， &lt;code&gt;Function&lt;/code&gt; 关键字仍然可用。</target>
        </trans-unit>
        <trans-unit id="6d77a143534e87e9a163d3e3ce0aca8c4103e016" translate="yes" xml:space="preserve">
          <source>However, if you need to opt-out of the type checker, and don&amp;rsquo;t want to go all the way to &lt;code&gt;any&lt;/code&gt;, you could use &lt;code&gt;{[key:string]:any}&lt;/code&gt;. (Note that &lt;a href=&quot;../any&quot;&gt;&lt;code&gt;any&lt;/code&gt;&lt;/a&gt; is unsafe and should be avoided). For historical reasons, the &lt;code&gt;Object&lt;/code&gt; keyword is still available. In previous versions of Flow, &lt;code&gt;Object&lt;/code&gt; was the same as &lt;code&gt;{[key:string]:any}&lt;/code&gt;.</source>
          <target state="translated">但是，如果你需要退出的类型检查的，并且不希望的方式去所有 &lt;code&gt;any&lt;/code&gt; ，你可以使用 &lt;code&gt;{[key:string]:any}&lt;/code&gt; 。（请注意，&lt;a href=&quot;../any&quot;&gt; &lt;code&gt;any&lt;/code&gt; &lt;/a&gt;都是不安全的，应避免使用）。由于历史原因， &lt;code&gt;Object&lt;/code&gt; 关键字仍然可用。在Flow的早期版本中， &lt;code&gt;Object&lt;/code&gt; 与 &lt;code&gt;{[key:string]:any}&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="f1e2c14006b12ab5491178ce01f3a9550f02756c" translate="yes" xml:space="preserve">
          <source>However, if you want to do anything more powerful with the React children API then you will need a strong intuition of how React handles children. Let us look at a couple of cases before continuing to help build that intuition.</source>
          <target state="translated">然而,如果你想用React children API做任何更强大的事情,那么你将需要对React如何处理子程序有很强的直觉。在继续帮助建立这种直觉之前,我们先看几个案例。</target>
        </trans-unit>
        <trans-unit id="f5931dcbe633762171ccee54a6f7889d2181ea61" translate="yes" xml:space="preserve">
          <source>However, it currently lacks support for on-the-fly type-checking (showing your type errors before you save your file).</source>
          <target state="translated">然而,它目前缺乏对即时类型检查的支持(在你保存文件之前显示你的类型错误)。</target>
        </trans-unit>
        <trans-unit id="84c821442db435688729316ed5285a4b00200528" translate="yes" xml:space="preserve">
          <source>However, it is not valid to use an object containing an &lt;code&gt;Employee&lt;/code&gt; instance where an object containing a &lt;code&gt;Person&lt;/code&gt; instance is expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aec4e47a3799d3abd4efe1fc37df16b029a38bb9" translate="yes" xml:space="preserve">
          <source>However, it is not valid to use an object containing an &lt;code&gt;Person&lt;/code&gt; instance where an object containing a &lt;code&gt;Employee&lt;/code&gt; instance is expected.</source>
          <target state="translated">但是，使用包含 &lt;code&gt;Person&lt;/code&gt; 实例的对象是无效的，而期望包含 &lt;code&gt;Employee&lt;/code&gt; 实例的对象。</target>
        </trans-unit>
        <trans-unit id="d215123d1e8037cb7806bba06a88351e172e211e" translate="yes" xml:space="preserve">
          <source>However, it&amp;rsquo;s often useful to know that a property is definitely absent.</source>
          <target state="translated">但是，知道某个属性绝对不存在通常很有用。</target>
        </trans-unit>
        <trans-unit id="9313de9dcdc57923e98881e802d0f7c94f24fa15" translate="yes" xml:space="preserve">
          <source>However, sometimes a Flow user might not care about all the code. If they are editing a file &lt;code&gt;foo.js&lt;/code&gt;, they might only want Flow to typecheck the subset of the repository needed to answer questions about &lt;code&gt;foo.js&lt;/code&gt;. Since Flow would only check a smaller number of files, this would be faster. This is the motivation behind Flow&amp;rsquo;s lazy modes.</source>
          <target state="translated">但是，有时Flow用户可能并不关心所有代码。如果他们正在编辑文件 &lt;code&gt;foo.js&lt;/code&gt; ，则他们可能只希望Flow进行类型检查以回答有关 &lt;code&gt;foo.js&lt;/code&gt; 的问题所需的存储库的子集。由于Flow仅会检查较少数量的文件，因此速度会更快。这是Flow的惰性模式背后的动机。</target>
        </trans-unit>
        <trans-unit id="0388504fdb624bb29d41874d436a861dd6df6661" translate="yes" xml:space="preserve">
          <source>However, there is also a fourth category.</source>
          <target state="translated">然而,还有第四类。</target>
        </trans-unit>
        <trans-unit id="bfac9f3c31434613c3dc25580cc54920b60f8937" translate="yes" xml:space="preserve">
          <source>However, this only happens with the inferred type. If you specify the literal type, it will be used in &lt;code&gt;typeof&lt;/code&gt;.</source>
          <target state="translated">但是，这仅在推断的类型上发生。如果指定文字类型，它将在 &lt;code&gt;typeof&lt;/code&gt; 中使用。</target>
        </trans-unit>
        <trans-unit id="60d9e12a6689ca1896d012bac4c1760061cf255c" translate="yes" xml:space="preserve">
          <source>However, to get around this you could use &lt;strong&gt;exact object types&lt;/strong&gt;.</source>
          <target state="translated">但是，要解决这个问题，您可以使用&lt;strong&gt;精确的对象类型&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="bf88ecdb532f0e02d70968558133c0d7b18ba5f0" translate="yes" xml:space="preserve">
          <source>However, type refinements can be lost. For instance, calling a function after refining the type of an object&amp;rsquo;s property will invalidate this refinement. Consult the &lt;a href=&quot;https://flow.org/en/lang/refinements/#toc-refinement-invalidations&quot;&gt;Refinement Invalidations&lt;/a&gt; docs for more details, to understand why Flow works this way, and how you can avoid this common pitfall.</source>
          <target state="translated">但是，类型优化可能会丢失。例如，在优化对象属性的类型之后调用函数会使该优化无效。有关更多详细信息，请查阅&amp;ldquo; &lt;a href=&quot;https://flow.org/en/lang/refinements/#toc-refinement-invalidations&quot;&gt;优化无效&amp;rdquo;&lt;/a&gt;文档，以了解Flow为什么以这种方式工作，以及如何避免这种常见的陷阱。</target>
        </trans-unit>
        <trans-unit id="5fd3ba2f001a6fd526870acba3decc8fde5c658e" translate="yes" xml:space="preserve">
          <source>However, you can use the &lt;code&gt;+&lt;/code&gt; operator on strings or numbers, so this would also be valid.</source>
          <target state="translated">但是，您可以对字符串或数字使用 &lt;code&gt;+&lt;/code&gt; 运算符，因此这也是有效的。</target>
        </trans-unit>
        <trans-unit id="e35f724efeda49c47595a6cc2bbf2976ebcaafa9" translate="yes" xml:space="preserve">
          <source>I checked that &lt;code&gt;foo.bar&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, but Flow still thinks it is. Why does this happen and how can I fix it?</source>
          <target state="translated">我检查了 &lt;code&gt;foo.bar&lt;/code&gt; 不是 &lt;code&gt;null&lt;/code&gt; ，但是Flow仍然认为它是null。为什么会发生这种情况，我该如何解决？</target>
        </trans-unit>
        <trans-unit id="6081ec65c275b7812a118a8d9487bec229a111d3" translate="yes" xml:space="preserve">
          <source>I checked that my object is of type A, so why does Flow still believe it&amp;rsquo;s A | B?</source>
          <target state="translated">我检查了我的对象是A类型，为什么Flow仍然认为它是A |。B？</target>
        </trans-unit>
        <trans-unit id="ab8ec6fa322ac3cb67fd8d12de1df1c19353b3b3" translate="yes" xml:space="preserve">
          <source>I got a &amp;ldquo;Missing type annotation&amp;rdquo; error. Where does it come from?</source>
          <target state="translated">我收到&amp;ldquo;缺少类型注释&amp;rdquo;错误。它从何而来？</target>
        </trans-unit>
        <trans-unit id="547872d29b34bba7a1f46637da9812595a6bd96e" translate="yes" xml:space="preserve">
          <source>I&amp;rsquo;m in a closure and Flow ignores the if check that asserts that &lt;code&gt;foo.bar&lt;/code&gt; is defined. Why?</source>
          <target state="translated">我处于关闭状态，Flow忽略了断言 &lt;code&gt;foo.bar&lt;/code&gt; 已定义foo.bar的if检查。为什么？</target>
        </trans-unit>
        <trans-unit id="1edc681e64e9bedc4b73a1b622b1bcd9c0221235" translate="yes" xml:space="preserve">
          <source>IDE Integration</source>
          <target state="translated">集成开发环境整合</target>
        </trans-unit>
        <trans-unit id="fa469552ea8a6956e0d85bd15a5b32e813e35a32" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is, say, &lt;code&gt;5&lt;/code&gt;, then this displays &amp;ldquo;[5 comments]&amp;rdquo;. However, if &lt;code&gt;count&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, then this displays &amp;ldquo;0&amp;rdquo; instead of displaying nothing. (This problem is unique to &lt;code&gt;number&lt;/code&gt; because &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; are the only falsy values which React renders with a visible result.) This could be subtly dangerous: if this immediately follows another numerical value, it might appear to the user that we have multiplied that value by 10! Instead, we should do a proper conditional check:</source>
          <target state="translated">如果 &lt;code&gt;count&lt;/code&gt; 为 &lt;code&gt;5&lt;/code&gt; ，则显示&amp;ldquo; [5条评论]&amp;rdquo;。但是，如果 &lt;code&gt;count&lt;/code&gt; 为 &lt;code&gt;0&lt;/code&gt; ，则显示为&amp;ldquo; 0&amp;rdquo;，而不显示任何内容。（这个问题是 &lt;code&gt;number&lt;/code&gt; 所特有的，因为 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;NaN&lt;/code&gt; 是React呈现的唯一带有虚假结果的虚假值。）这可能是潜在的危险：如果此值紧随另一个数字值，那么用户可能会发现我们将其乘以值减10！相反，我们应该进行适当的条件检查：</target>
        </trans-unit>
        <trans-unit id="39ad3382b221945428b6a2b474dff72bfb56707e" translate="yes" xml:space="preserve">
          <source>If Flow doesn&amp;rsquo;t know which index you are trying to access it will return all possible types.</source>
          <target state="translated">如果Flow不知道您尝试访问哪个索引，它将返回所有可能的类型。</target>
        </trans-unit>
        <trans-unit id="2c9c0dec7bafe53d2bbdf7d9959ddffbd2d70581" translate="yes" xml:space="preserve">
          <source>If Flow is unable to figure out what the exact type is for each value, Flow must figure out what every possible value is and check to make sure that the code around it will still work with all of the possible types.</source>
          <target state="translated">如果Flow无法弄清楚每个值的确切类型是什么,Flow必须弄清楚每个可能的值是什么,并检查以确保周围的代码仍然可以使用所有可能的类型。</target>
        </trans-unit>
        <trans-unit id="5acb8edfcd1e9dfddc6d2572d420f5b201ed318e" translate="yes" xml:space="preserve">
          <source>If a third-party library that has no type information is used by your project, Flow will treat it like any other untyped dependency and mark all of its exports as &lt;code&gt;any&lt;/code&gt;. Interestingly, this is the only place that Flow will implicitly inject &lt;code&gt;any&lt;/code&gt; into your program.</source>
          <target state="translated">如果您的项目使用了没有类型信息的第三方库，则Flow会将其视为任何其他无类型的依赖项，并将其所有导出标记为 &lt;code&gt;any&lt;/code&gt; 。有趣的是，这是Flow隐式将 &lt;code&gt;any&lt;/code&gt; 注入程序的唯一位置。</target>
        </trans-unit>
        <trans-unit id="3eab7b55f7ee09f03bc495ed43d0061345e8a4e3" translate="yes" xml:space="preserve">
          <source>If no suppression comments are specified in your config, Flow will apply one default: &lt;code&gt;// $FlowFixMe&lt;/code&gt;.</source>
          <target state="translated">如果您的配置中未指定任何抑制注释，则Flow将应用一个默认值： &lt;code&gt;// $FlowFixMe&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ab896379f8da8ccf06ebdb7660f6a676591eb88" translate="yes" xml:space="preserve">
          <source>If statements, functions, and other conditionally run code can all prevent Flow from being able to figure out precisely what a type will be.</source>
          <target state="translated">如果语句、函数和其他条件运行的代码都可以阻止Flow精确地找出一个类型将是什么。</target>
        </trans-unit>
        <trans-unit id="b0c36449a1266a96a5edfbb603756422dc5a110c" translate="yes" xml:space="preserve">
          <source>If the values are numbers, then the expression results in a number. If the values are strings, then the expression results in a string. There are a number of different possibilities here, so Flow must look up what the values are.</source>
          <target state="translated">如果值是数字,那么表达式的结果是一个数字。如果值是字符串,那么表达式的结果是一个字符串。这里有许多不同的可能性,所以Flow必须查找这些值是什么。</target>
        </trans-unit>
        <trans-unit id="5f9ff1c70b75813f87b337ccc40269423119c893" translate="yes" xml:space="preserve">
          <source>If these values on the object happen to be other objects, we would have to compare those against one another. We need to compare every value recursively until we can decide if we have a subtype or not.</source>
          <target state="translated">如果对象上的这些值恰好是其他对象,我们就必须将这些值相互比较。我们需要对每一个值进行递归比较,直到我们可以决定是否有子类型。</target>
        </trans-unit>
        <trans-unit id="dd58caf9f3de4a63117623155b1513d6eb2999e3" translate="yes" xml:space="preserve">
          <source>If this option is unspecified, Flow will always use the &lt;code&gt;&quot;main&quot;&lt;/code&gt; field.</source>
          <target state="translated">如果未指定此选项，则Flow将始终使用 &lt;code&gt;&quot;main&quot;&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="76fac6bacf9983c96845e23339cd8c3466f2c7a7" translate="yes" xml:space="preserve">
          <source>If we cast through any, we can return a type which is more useful.</source>
          <target state="translated">如果我们投过任何,我们可以返回一个类型,这是比较有用的。</target>
        </trans-unit>
        <trans-unit id="a6d8ac03b1e20b9356423c837abe3ce7a0f6c016" translate="yes" xml:space="preserve">
          <source>If we now create a declaration file &lt;code&gt;src/Misc.js.flow&lt;/code&gt;, the declarations in it will be used instead of the code in &lt;code&gt;src/Misc.js&lt;/code&gt;. Let&amp;rsquo;s say we have the following declarations in &lt;code&gt;src/Misc.js.flow&lt;/code&gt;.</source>
          <target state="translated">如果现在创建声明文件 &lt;code&gt;src/Misc.js.flow&lt;/code&gt; ，则将使用其中的声明代替 &lt;code&gt;src/Misc.js&lt;/code&gt; 中的代码。假设我们在 &lt;code&gt;src/Misc.js.flow&lt;/code&gt; 中具有以下声明。</target>
        </trans-unit>
        <trans-unit id="fff93b7378aeb2b38b2090807b263b7014c5548e" translate="yes" xml:space="preserve">
          <source>If we prevented any code from ever writing a new value to the object through the &lt;code&gt;person&lt;/code&gt; variable, it would be safe to use the &lt;code&gt;employee&lt;/code&gt; variable. Flow provides a syntax for this:</source>
          <target state="translated">如果我们阻止任何代码通过 &lt;code&gt;person&lt;/code&gt; 变量向对象写入新值，那么使用 &lt;code&gt;employee&lt;/code&gt; 变量将是安全的。Flow为此提供了一种语法：</target>
        </trans-unit>
        <trans-unit id="89439f8728f3f378c6012b648cca5749466a7c15" translate="yes" xml:space="preserve">
          <source>If we want to know whether one type is the subtype of another, we need to look at all the possible values for both types and figure out if the other has a &lt;em&gt;subset&lt;/em&gt; of the values.</source>
          <target state="translated">如果我们想知道一种类型是否是另一种类型的子类型，则需要查看两种类型的所有可能值，并找出另一种类型是否具有值的&lt;em&gt;子集&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="ffa5a5ea5efd7aef02382e7722a00a675b7afec3" translate="yes" xml:space="preserve">
          <source>If we want to validate what kinds of types are coming into our &lt;code&gt;cloneObject&lt;/code&gt; method from before, we could write the following annotation:</source>
          <target state="translated">如果我们想验证以前从什么类型进入 &lt;code&gt;cloneObject&lt;/code&gt; 方法，可以编写以下注释：</target>
        </trans-unit>
        <trans-unit id="d9caf10c12ea9af18781cd6eef9ed4499bd31209" translate="yes" xml:space="preserve">
          <source>If we write into the &lt;code&gt;who&lt;/code&gt; property of the &lt;code&gt;person&lt;/code&gt; object, we&amp;rsquo;ve also changed the value of &lt;code&gt;employee.who&lt;/code&gt;, which is explicitly annotated to be an &lt;code&gt;Employee&lt;/code&gt; instance.</source>
          <target state="translated">如果我们写入 &lt;code&gt;person&lt;/code&gt; 对象的 &lt;code&gt;who&lt;/code&gt; 属性，我们还将更改 &lt;code&gt;employee.who&lt;/code&gt; 的值，该值显式标注为 &lt;code&gt;Employee&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="c0385bbba6e8a638e5b435911862d68f61aa402d" translate="yes" xml:space="preserve">
          <source>If you add the following to your configuration:</source>
          <target state="translated">如果您在配置中添加以下内容。</target>
        </trans-unit>
        <trans-unit id="2f6349a666bc7969b6c4063795a6da2f8498120d" translate="yes" xml:space="preserve">
          <source>If you already have a strong intuition about how React children work then feel free to &lt;a href=&quot;#examples&quot;&gt;skip to our examples demonstrating how to type various children patterns that commonly show up in React components&lt;/a&gt;.</source>
          <target state="translated">如果您已经对React子级的工作方式有很强的直觉，那么可以随时&lt;a href=&quot;#examples&quot;&gt;跳到我们的示例来演示如何键入通常出现在React组件中的各种子级模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="de34b40fb825239268317ed36dbb1e00f0c6608b" translate="yes" xml:space="preserve">
          <source>If you are using CommonJS you can also require React:</source>
          <target state="translated">如果你使用CommonJS,你也可以要求React。</target>
        </trans-unit>
        <trans-unit id="4d70f00037273b6c8e72fde753e104d54c4cd4b8" translate="yes" xml:space="preserve">
          <source>If you are using the new automatic runtime, use this configuration in your &lt;code&gt;.flowconfig&lt;/code&gt; so that Flow knows to auto-import &lt;code&gt;jsx&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25ad5bd918b70efe676da28a844513e673fd63f9" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have Babel setup already, you can do that by following &lt;a href=&quot;http://babeljs.io/docs/setup/&quot;&gt;this guide&lt;/a&gt;.</source>
          <target state="translated">如果您尚未安装Babel，可以按照&lt;a href=&quot;http://babeljs.io/docs/setup/&quot;&gt;本指南进行操作&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a69f0a892b7706fd7d381a10e9090d3be16821d" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to add the type of your element instance you can also use &lt;code&gt;SyntheticEvent&lt;/code&gt; with &lt;em&gt;no&lt;/em&gt; type arguments like so: &lt;code&gt;SyntheticEvent&amp;lt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">如果您不想添加元素实例的类型，则也可以使用&lt;em&gt;不带&lt;/em&gt;类型参数的 &lt;code&gt;SyntheticEvent&lt;/code&gt; ，例如： &lt;code&gt;SyntheticEvent&amp;lt;&amp;gt;&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="20d32713b2839dd2173444b2f9b4d7dcc4fe36ce" translate="yes" xml:space="preserve">
          <source>If you enable the &lt;code&gt;nonstrict-import&lt;/code&gt; rule in your Flow Strict configuration (recommended), then all dependencies of a strict file must also be strict. While this the optimal goal, for large pre-existing codebases it may be beneficial to allow some of the benefits of Flow Strict to be put in use before all dependencies are strict.</source>
          <target state="translated">如果在Flow Strict配置中启用了 &lt;code&gt;nonstrict-import&lt;/code&gt; 规则（推荐），那么严格文件的所有依赖性也必须严格。虽然这是最佳目标，但对于大型的预先存在的代码库，允许在严格依赖所有依赖项之前使用Flow Strict的某些好处可能是有益的。</target>
        </trans-unit>
        <trans-unit id="7868511a9d06a4f8edf5d7a840c67f28e5c7774f" translate="yes" xml:space="preserve">
          <source>If you have an object that sometimes does not have a property you can make it an &lt;em&gt;optional property&lt;/em&gt; by adding a question mark &lt;code&gt;?&lt;/code&gt; after the property name in the object type.</source>
          <target state="translated">如果您的对象有时不具有属性，则可以通过添加问号使它成为&lt;em&gt;可选属性&lt;/em&gt; &lt;code&gt;?&lt;/code&gt; 在对象类型中的属性名称之后。</target>
        </trans-unit>
        <trans-unit id="4f24b7927c9085b7c250ed90664e78d83cbf1e68" translate="yes" xml:space="preserve">
          <source>If you need a return type for your component &lt;code&gt;render()&lt;/code&gt; methods then you should use &lt;code&gt;React.Node&lt;/code&gt;. However, if you need a generic type for a children prop, use &lt;code&gt;?React.Node&lt;/code&gt;; children can be undefined, when &lt;code&gt;render()&lt;/code&gt; can&amp;rsquo;t return &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">如果您的组件 &lt;code&gt;render()&lt;/code&gt; 方法需要返回类型，则应使用 &lt;code&gt;React.Node&lt;/code&gt; 。但是，如果您需要子道具的泛型类型，请使用 &lt;code&gt;?React.Node&lt;/code&gt; ; 当 &lt;code&gt;render()&lt;/code&gt; 无法返回 &lt;code&gt;undefined&lt;/code&gt; 时，子对象可以是未定义的。</target>
        </trans-unit>
        <trans-unit id="abe11ee943e5dc689dcff158386be0fb8f22ac39" translate="yes" xml:space="preserve">
          <source>If you only want to specify some of the type arguments, you can use &lt;code&gt;_&lt;/code&gt; to let flow infer a type for you:</source>
          <target state="translated">如果只想指定某些类型参数，则可以使用 &lt;code&gt;_&lt;/code&gt; 让flow为您推断类型：</target>
        </trans-unit>
        <trans-unit id="a9a33f8497f3a49e54f6d651972b743d6f34b7b8" translate="yes" xml:space="preserve">
          <source>If you pass in a single value then &lt;code&gt;props.children&lt;/code&gt; will be &lt;em&gt;exactly&lt;/em&gt; that single value. Here &lt;code&gt;props.children&lt;/code&gt; will be the number 42. Importantly, &lt;code&gt;props.children&lt;/code&gt; will not be an array! It will be &lt;em&gt;exactly&lt;/em&gt; the number 42.</source>
          <target state="translated">如果你在一个单一的值传递则 &lt;code&gt;props.children&lt;/code&gt; 将&lt;em&gt;正好&lt;/em&gt;是单个值。这里 &lt;code&gt;props.children&lt;/code&gt; 将是数字42。重要的是， &lt;code&gt;props.children&lt;/code&gt; 将不是数组！这将是&lt;em&gt;完全相同&lt;/em&gt;的号码42。</target>
        </trans-unit>
        <trans-unit id="0ccc08faa8b174c05c639636e1b782f03a991965" translate="yes" xml:space="preserve">
          <source>If you pass in no children when creating an element of &lt;code&gt;MyComponent&lt;/code&gt; then &lt;code&gt;props.children&lt;/code&gt; will not be set. If you try to access &lt;code&gt;props.children&lt;/code&gt;, it will be undefined.</source>
          <target state="translated">如果你没有孩子创造一个元素时，通过 &lt;code&gt;MyComponent&lt;/code&gt; 的那么 &lt;code&gt;props.children&lt;/code&gt; 将不会设置。如果尝试访问 &lt;code&gt;props.children&lt;/code&gt; ，它将是未定义的。</target>
        </trans-unit>
        <trans-unit id="34ece29e3b89f75f011bf7528980bbd49fd066fa" translate="yes" xml:space="preserve">
          <source>If you then put all your source files in a &lt;code&gt;src&lt;/code&gt; directory you can compile them to another directory by running:</source>
          <target state="translated">然后，如果将所有源文件放在 &lt;code&gt;src&lt;/code&gt; 目录中，则可以通过运行以下命令将它们编译到另一个目录中：</target>
        </trans-unit>
        <trans-unit id="062faa0de803caab920638881f00d7513c947ac6" translate="yes" xml:space="preserve">
          <source>If you try to export a wrapped component, chances are that you&amp;rsquo;ll run into a missing annotation error:</source>
          <target state="translated">如果尝试导出包装的组件，则很可能会遇到缺少的注释错误：</target>
        </trans-unit>
        <trans-unit id="309fcc8f3cc112f1e5bcf47ecdb839392b2659c4" translate="yes" xml:space="preserve">
          <source>If you want a way to opt-out of using the type checker, &lt;code&gt;any&lt;/code&gt; is the way to do it. &lt;strong&gt;Using &lt;code&gt;any&lt;/code&gt; is completely unsafe, and should be avoided whenever possible.&lt;/strong&gt;</source>
          <target state="translated">如果您想选择退出使用类型检查器，则可以使用 &lt;code&gt;any&lt;/code&gt; 方法。&lt;strong&gt;使用 &lt;code&gt;any&lt;/code&gt; 都是完全不安全的，应尽可能避免使用。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9b005b1abd0cefd6c2751db329291eac30a6cd45" translate="yes" xml:space="preserve">
          <source>If you want to allow missing properties, use &lt;a href=&quot;../objects#toc-optional-object-type-properties&quot;&gt;optional property&lt;/a&gt; syntax, where the &lt;code&gt;?&lt;/code&gt; is placed &lt;em&gt;before&lt;/em&gt; the colon. It is also possible to combine both syntaxes for an optional maybe type, for example &lt;code&gt;{value?:?number}&lt;/code&gt;.</source>
          <target state="translated">如果要允许缺少属性，请使用&lt;a href=&quot;../objects#toc-optional-object-type-properties&quot;&gt;可选属性&lt;/a&gt;语法，其中 &lt;code&gt;?&lt;/code&gt; 放在结肠&lt;em&gt;前&lt;/em&gt;。也可以将两种语法组合为一个可选的mayn类型，例如 &lt;code&gt;{value?:?number}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f07f6bae6a75d430c4180eacf06f3bed1b73ebfb" translate="yes" xml:space="preserve">
          <source>If you want to have Flow treat a comment as if it were normal syntax, you can do so by adding a double colon &lt;code&gt;::&lt;/code&gt; to the start of the comment.</source>
          <target state="translated">如果要让Flow将注释视为普通语法，可以通过在注释的开头添加双冒号 &lt;code&gt;::&lt;/code&gt; 来实现。</target>
        </trans-unit>
        <trans-unit id="1b5ea02b142df74d92e6a6f721434f19c8193978" translate="yes" xml:space="preserve">
          <source>If you want to make it &lt;code&gt;Array&amp;lt;?T&amp;gt;&lt;/code&gt; you can use parenthesis like: &lt;code&gt;(?Type)[]&lt;/code&gt;</source>
          <target state="translated">如果要使其成为 &lt;code&gt;Array&amp;lt;?T&amp;gt;&lt;/code&gt; ，则可以使用圆括号，例如：（ &lt;code&gt;(?Type)[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="483317a13682411d8f1235de07f55cf867ba1719" translate="yes" xml:space="preserve">
          <source>If you wanted to use a class structurally you could do that by mixing them with objects as interfaces:</source>
          <target state="translated">如果你想在结构上使用一个类,你可以通过将它们与对象混合为接口来实现。</target>
        </trans-unit>
        <trans-unit id="d14412dd9ea135c9d1850cdc133b518a3da76d23" translate="yes" xml:space="preserve">
          <source>If you would like to add a type annotation to &lt;code&gt;defaultProps&lt;/code&gt; you can define the type as</source>
          <target state="translated">如果要将类型注释添加到 &lt;code&gt;defaultProps&lt;/code&gt; ，则可以将类型定义为</target>
        </trans-unit>
        <trans-unit id="0bd6e77a91375cf371a7745722382dbe962d5dda" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using &lt;a href=&quot;https://atom.io&quot;&gt;Atom&lt;/a&gt; you have a bunch of options to integrate Flow into your code base.</source>
          <target state="translated">如果您使用的是&lt;a href=&quot;https://atom.io&quot;&gt;Atom&lt;/a&gt;，则可以使用很多选项将Flow集成到代码库中。</target>
        </trans-unit>
        <trans-unit id="67b20f92754a07891c76908aee9f1c454fc3a6ad" translate="yes" xml:space="preserve">
          <source>If your component does have &lt;code&gt;defaultProps&lt;/code&gt;, you don&amp;rsquo;t want to just add &lt;code&gt;Props&lt;/code&gt; as a type argument to &lt;code&gt;trivialHOC&lt;/code&gt; because that will get rid of the &lt;code&gt;defaultProps&lt;/code&gt; information that flow has about your component.</source>
          <target state="translated">如果您的组件确实具有 &lt;code&gt;defaultProps&lt;/code&gt; ，则您不希望仅将 &lt;code&gt;Props&lt;/code&gt; 作为类型参数添加到 &lt;code&gt;trivialHOC&lt;/code&gt; ,因为这将摆脱流有关您的组件的 &lt;code&gt;defaultProps&lt;/code&gt; 信息。</target>
        </trans-unit>
        <trans-unit id="780a6023120264ade0b9dac9868692f3f30232eb" translate="yes" xml:space="preserve">
          <source>If your component has no &lt;code&gt;defaultProps&lt;/code&gt;, you can use &lt;code&gt;Props&lt;/code&gt; as a type argument for &lt;code&gt;Config&lt;/code&gt;.</source>
          <target state="translated">如果您的组件没有 &lt;code&gt;defaultProps&lt;/code&gt; ，则可以将 &lt;code&gt;Props&lt;/code&gt; 用作 &lt;code&gt;Config&lt;/code&gt; 的类型参数。</target>
        </trans-unit>
        <trans-unit id="df8b42d3edaced78a9cf76e1330bae86b8d96c3b" translate="yes" xml:space="preserve">
          <source>If your context has a default value, Flow will type your consumer component accordingly:</source>
          <target state="translated">如果你的上下文有一个默认值,Flow会相应地键入你的消费者组件。</target>
        </trans-unit>
        <trans-unit id="ae552724b48e29ed087f56eabc416631aed983c9" translate="yes" xml:space="preserve">
          <source>Ignores are processed AFTER includes. If you both include and ignore a file it will be ignored.</source>
          <target state="translated">忽略是在包含之后处理的。如果你同时包含和忽略一个文件,它将被忽略。</target>
        </trans-unit>
        <trans-unit id="90a346f6dee87e3209abc8b71fd3cfad11fc7766" translate="yes" xml:space="preserve">
          <source>Imagine the following &lt;code&gt;concat&lt;/code&gt; function for concatenating two strings together.</source>
          <target state="translated">想象下面的 &lt;code&gt;concat&lt;/code&gt; 函数将两个字符串连接在一起。</target>
        </trans-unit>
        <trans-unit id="07e019c33eb53f751e20f583889e44cde2c245d3" translate="yes" xml:space="preserve">
          <source>Imagine we have the type &lt;code&gt;?number&lt;/code&gt;, if we want to use that value as a &lt;code&gt;number&lt;/code&gt; we&amp;rsquo;ll need to first check that it is not &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">试想一下，我们有型 &lt;code&gt;?number&lt;/code&gt; ，如果我们要使用该值作为一个 &lt;code&gt;number&lt;/code&gt; ，我们首先需要检查它不是 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6798e3c1aa807d4333e350015401a7abc70e80e3" translate="yes" xml:space="preserve">
          <source>Imagine writing the following &lt;code&gt;identity&lt;/code&gt; function which returns whatever value was passed.</source>
          <target state="translated">想象一下编写下面的 &lt;code&gt;identity&lt;/code&gt; 函数，该函数返回传递的任何值。</target>
        </trans-unit>
        <trans-unit id="ff623f8a9cd9b8f5349b3bb1da56c38d35cc87a1" translate="yes" xml:space="preserve">
          <source>Importing and exporting types</source>
          <target state="translated">进口和出口类型</target>
        </trans-unit>
        <trans-unit id="8b69719d369c12ce9cd0e7524c2b8530f01cb19f" translate="yes" xml:space="preserve">
          <source>Importing and exporting values</source>
          <target state="translated">导入和导出数值</target>
        </trans-unit>
        <trans-unit id="13534d9f1d5e200c3a0748880d5480a40ed54ff0" translate="yes" xml:space="preserve">
          <source>Impossible intersection types</source>
          <target state="translated">不可能的交叉口类型</target>
        </trans-unit>
        <trans-unit id="36f5825f27a921e30d7ea8251d8987b448c8e07c" translate="yes" xml:space="preserve">
          <source>In 0.89.0, we introduced &lt;a href=&quot;../types#toc-react-abstractcomponent&quot;&gt;&lt;code&gt;React.AbstractComponent&lt;/code&gt;&lt;/a&gt;, which gives you more expressive power when writing HOCs and library definitions.</source>
          <target state="translated">在0.89.0中，我们引入了&lt;a href=&quot;../types#toc-react-abstractcomponent&quot;&gt; &lt;code&gt;React.AbstractComponent&lt;/code&gt; &lt;/a&gt;，它在编写HOC和库定义时赋予您更多的表达能力。</target>
        </trans-unit>
        <trans-unit id="d23cd461e61670be17a5cbf84c124cd9f286a1b6" translate="yes" xml:space="preserve">
          <source>In Flow every value and expression has a type.</source>
          <target state="translated">在Flow中,每个值和表达式都有一个类型。</target>
        </trans-unit>
        <trans-unit id="0b86cc8dc870697405ea856ce5507108777717a2" translate="yes" xml:space="preserve">
          <source>In Flow these fall into two groups:</source>
          <target state="translated">在Flow中,这些可以分为两类。</target>
        </trans-unit>
        <trans-unit id="18a40bb39b26a81dd8b90a84e6fcc2a7aa9f4ec7" translate="yes" xml:space="preserve">
          <source>In Flow this will cause an error because if you are expecting to get a return value of a &lt;code&gt;City&lt;/code&gt;, you may be using something that doesn&amp;rsquo;t exist on &lt;code&gt;Noun&lt;/code&gt;, which could easily cause an error at runtime.</source>
          <target state="translated">在Flow中，这将导致错误，因为如果您希望获得 &lt;code&gt;City&lt;/code&gt; 的返回值，则可能使用了 &lt;code&gt;Noun&lt;/code&gt; 上不存在的东西，这很容易在运行时引起错误。</target>
        </trans-unit>
        <trans-unit id="878790a54a5224ef661b3530ee00eb752ab21af0" translate="yes" xml:space="preserve">
          <source>In Flow you can &lt;a href=&quot;../literals&quot;&gt;use union types similar to enums&lt;/a&gt;:</source>
          <target state="translated">在Flow中，您可以&lt;a href=&quot;../literals&quot;&gt;使用类似于枚举的联合类型&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="e7fb60b92b4e843cc692009677f907537c735a2b" translate="yes" xml:space="preserve">
          <source>In Flow you can create tuples using the &lt;code&gt;[type, type, type]&lt;/code&gt; syntax.</source>
          <target state="translated">在Flow中，您可以使用 &lt;code&gt;[type, type, type]&lt;/code&gt; 语法创建元组。</target>
        </trans-unit>
        <trans-unit id="1aed1690eff4b4d2b58bb1fcd12c1d5c6f001410" translate="yes" xml:space="preserve">
          <source>In Flow you don&amp;rsquo;t type annotate &lt;code&gt;this&lt;/code&gt; and Flow will check whatever context you call the function with.</source>
          <target state="translated">在流量不键入注释 &lt;code&gt;this&lt;/code&gt; 和流量会检查任何情况下与您通话的功能。</target>
        </trans-unit>
        <trans-unit id="1866b0c88cce2b9c6a8fee29c5128f64a2f80305" translate="yes" xml:space="preserve">
          <source>In Flow, it is considered safe to pass an object with extra properties where a normal object type is expected.</source>
          <target state="translated">在Flow中,传递一个具有额外属性的对象被认为是安全的,因为它是一个正常的对象类型。</target>
        </trans-unit>
        <trans-unit id="ce986f956cc22b12a2a6bfffc8a5a0edb258999c" translate="yes" xml:space="preserve">
          <source>In Flow, most of the time when you pass one type into another you lose the original type. So that when you pass a specific type into a less specific one Flow &amp;ldquo;forgets&amp;rdquo; it was once something more specific.</source>
          <target state="translated">在Flow中，大多数情况下，当您将一种类型传递给另一种类型时，就会丢失原始类型。这样，当您将一种特定类型传递给一个不太特定的流时，&amp;ldquo;忘记了&amp;rdquo;它就变得更加特定了。</target>
        </trans-unit>
        <trans-unit id="bcf0c994155157746fc1c739386893c10523fd11" translate="yes" xml:space="preserve">
          <source>In Flow, there are two different kinds of object types: exact object types and inexact object types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a9bbf724831d747e94152055fbfe4af4a218e78" translate="yes" xml:space="preserve">
          <source>In Flow, there is a similar &lt;code&gt;typeof&lt;/code&gt; operator, but it&amp;rsquo;s much more powerful.</source>
          <target state="translated">在Flow中，有一个类似的 &lt;code&gt;typeof&lt;/code&gt; 运算符，但功能更强大。</target>
        </trans-unit>
        <trans-unit id="41f1a84e9859f569ee928b713503208cbf3bc5fb" translate="yes" xml:space="preserve">
          <source>In JavaScript there are many types of values: numbers, strings, booleans, functions, objects, and more.</source>
          <target state="translated">在JavaScript中,有很多类型的值:数字、字符串、布尔值、函数、对象等。</target>
        </trans-unit>
        <trans-unit id="e94f6f8db81e235b729c1d11091229874c69e47d" translate="yes" xml:space="preserve">
          <source>In JavaScript, accessing a property that doesn&amp;rsquo;t exist evaluates to &lt;code&gt;undefined&lt;/code&gt;. This is a common source of errors in JavaScript programs, so Flow turns these into type errors.</source>
          <target state="translated">在JavaScript中，访问不存在的属性的结果为 &lt;code&gt;undefined&lt;/code&gt; 。这是JavaScript程序中常见的错误源，因此Flow将这些错误转换为类型错误。</target>
        </trans-unit>
        <trans-unit id="607c3a17b963c6542847246278eb0d806eb5228c" translate="yes" xml:space="preserve">
          <source>In Nuclide, Flow warnings are distinct from Flow errors and rendered in a different color.</source>
          <target state="translated">在Nuclide中,Flow警告与Flow错误不同,并以不同的颜色呈现。</target>
        </trans-unit>
        <trans-unit id="bc25bf1704838ddbfe93f721afeb7079da5d8274" translate="yes" xml:space="preserve">
          <source>In a project using exact-by-default syntax, the explicit inexact object type syntax is the only way to express an inexact object type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8602c23e7637c0b355d504e31ab6ce9a57961195" translate="yes" xml:space="preserve">
          <source>In addition to classes, React also supports stateless functional components. You type these components like you would type a function:</source>
          <target state="translated">除了类,React还支持无状态功能组件。你可以像键入函数一样键入这些组件。</target>
        </trans-unit>
        <trans-unit id="5c3523d972cffa078864d6aecc1b5016808eb504" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;type&lt;/code&gt; in &lt;code&gt;?type&lt;/code&gt;, maybe types can also be &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">除了 &lt;code&gt;type&lt;/code&gt; 的 &lt;code&gt;?type&lt;/code&gt; ，也许类型也可以为 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;void&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5878ffe14737888126d4158cf0ebbdd747f1742a" translate="yes" xml:space="preserve">
          <source>In addition to the default &lt;code&gt;{}&lt;/code&gt; syntax, you can explicitly indicate an inexact object by using an ellipsis at the end of your property list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2ee11de69f40000610dfec7ac07ec5df1cfe68c" translate="yes" xml:space="preserve">
          <source>In addition to their set type, default parameters can also be &lt;code&gt;void&lt;/code&gt; or omitted altogether. However, they cannot be &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">除了其设置类型外，默认参数也可以为 &lt;code&gt;void&lt;/code&gt; 或完全省略。但是，它们不能为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="76f3ea7a16fcff8d257f8c2b1bf73e609afb8ca9" translate="yes" xml:space="preserve">
          <source>In addition to their set type, these optional parameters can either be &lt;code&gt;void&lt;/code&gt; or omitted altogether. However, they cannot be &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">除了它们的设置类型外，这些可选参数可以为 &lt;code&gt;void&lt;/code&gt; 也可以完全省略。但是，它们不能为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05442271873e7bd4801123e6c257336f2ff42022" translate="yes" xml:space="preserve">
          <source>In addition to their set value type, these optional properties can either be &lt;code&gt;void&lt;/code&gt; or omitted altogether. However, they cannot be &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">除了它们的设置值类型之外，这些可选属性还可以为 &lt;code&gt;void&lt;/code&gt; 或完全省略。但是，它们不能为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eee0e3df17d7390f34a9ec9aa8fb61edb49a05a1" translate="yes" xml:space="preserve">
          <source>In all forms, whitespace and asterisks between words are ignored, allowing for flexible formatting.</source>
          <target state="translated">在所有形式中,单词之间的空白和星号被忽略,允许灵活的格式化。</target>
        </trans-unit>
        <trans-unit id="fc7fa03e8c32cc9ea9869eea330877a166bc87da" translate="yes" xml:space="preserve">
          <source>In an ideal world, every type checker would be both sound &lt;em&gt;and&lt;/em&gt; complete so that it catches &lt;em&gt;every&lt;/em&gt; error that &lt;em&gt;will&lt;/em&gt; happen at runtime.</source>
          <target state="translated">在理想的情况下，每个类型检查器都是健全&lt;em&gt;且&lt;/em&gt;完整的，因此它可以捕获运行时&lt;em&gt;将&lt;/em&gt;发生的&lt;em&gt;所有&lt;/em&gt;错误。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0e980406b01916b102c664aa8bc420ac8164cdd8" translate="yes" xml:space="preserve">
          <source>In case you&amp;rsquo;re looking for something even more minimal, &lt;a href=&quot;https://atom.io/packages/linter-flow&quot;&gt;linter-flow&lt;/a&gt; may be worth your attention. It only lints your code and provides no other features, but it does support on-the-fly linting.</source>
          <target state="translated">如果您正在寻找更小的东西，&lt;a href=&quot;https://atom.io/packages/linter-flow&quot;&gt;棉绒流&lt;/a&gt;可能值得您注意。它仅减少代码，不提供其他功能，但确实支持即时删除。</target>
        </trans-unit>
        <trans-unit id="9bffcd7b9f6bc8c106a178e285d7f231f68f3d4e" translate="yes" xml:space="preserve">
          <source>In general, programs have several different categories of types:</source>
          <target state="translated">一般来说,程序有几类不同的类型。</target>
        </trans-unit>
        <trans-unit id="fd7f4f3ed72057427360f7865505bb3424508d31" translate="yes" xml:space="preserve">
          <source>In general, the function subtyping rule is this: A function type &lt;code&gt;B&lt;/code&gt; is a subtype of a function type &lt;code&gt;A&lt;/code&gt; if and only if &lt;code&gt;B&lt;/code&gt;&amp;rsquo;s inputs are a superset of &lt;code&gt;A&lt;/code&gt;&amp;rsquo;s, and &lt;code&gt;B&lt;/code&gt;&amp;rsquo;s outputs are a subset of &lt;code&gt;A&lt;/code&gt;&amp;rsquo;s. The subtype must accept &lt;em&gt;at least&lt;/em&gt; the same inputs as its parent, and must return &lt;em&gt;at most&lt;/em&gt; the same outputs.</source>
          <target state="translated">通常，函数子类型化规则是这样的：当且仅当 &lt;code&gt;B&lt;/code&gt; 的输入是 &lt;code&gt;A&lt;/code&gt; 的超集且 &lt;code&gt;B&lt;/code&gt; 的输出是 &lt;code&gt;A&lt;/code&gt; 的子集时，函数类型 &lt;code&gt;B&lt;/code&gt; 才是函数类型 &lt;code&gt;A&lt;/code&gt; 的子类型。 。子类型必须&lt;em&gt;至少&lt;/em&gt;接受与其父代相同的输入，并且必须&lt;em&gt;最多&lt;/em&gt;返回相同的输出。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="95f08b9072eee0c507decee24cd79aa14c9843dc" translate="yes" xml:space="preserve">
          <source>In general, we recommend using &lt;a href=&quot;#toc-exact-object-types&quot;&gt;exact object types&lt;/a&gt; whenever possible. Exact object types are more precise and interact better with other type system features, like spreads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a36883ee8e26a0df06cf9d297126b7d9d0279d23" translate="yes" xml:space="preserve">
          <source>In most editors, Flow warnings are likely to be rendered the same way as other warnings are rendered by that editor.</source>
          <target state="translated">在大多数编辑器中,Flow警告的渲染方式可能与其他警告的渲染方式相同。</target>
        </trans-unit>
        <trans-unit id="3519b95ac1b03c724bc36beb2d830f52032a8ec0" translate="yes" xml:space="preserve">
          <source>In order to create a type cast expression around a &lt;code&gt;value&lt;/code&gt;, add a colon &lt;code&gt;:&lt;/code&gt; with the &lt;code&gt;Type&lt;/code&gt; and wrap the expression with parentheses &lt;code&gt;(&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;.</source>
          <target state="translated">为了创建围绕一个类型强制转换表达式 &lt;code&gt;value&lt;/code&gt; ，添加一个冒号 &lt;code&gt;:&lt;/code&gt; 与 &lt;code&gt;Type&lt;/code&gt; ，敷用括号中的表达式 &lt;code&gt;(&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a95a2762627991309d591271ba0f2cb553d8347" translate="yes" xml:space="preserve">
          <source>In order to make this safe, Flow would have to mark every single array access as &amp;ldquo;&lt;em&gt;possibly undefined&amp;rdquo;&lt;/em&gt;.</source>
          <target state="translated">为了确保安全，Flow必须将每个数组访问都标记为&amp;ldquo; &lt;em&gt;可能未定义&amp;rdquo;&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="bf1c4a34bb0b2870f57375eef532ff3033ee975a" translate="yes" xml:space="preserve">
          <source>In order to type your Redux &lt;a href=&quot;http://redux.js.org/docs/advanced/AsyncActions.html#async-action-creators&quot;&gt;thunk actions&lt;/a&gt;, you&amp;rsquo;ll add types for &lt;code&gt;ThunkAction&lt;/code&gt; as a function &lt;code&gt;Dispatch&lt;/code&gt;, and &lt;code&gt;GetState&lt;/code&gt;. &lt;code&gt;GetState&lt;/code&gt; is a function that returns an &lt;code&gt;Object&lt;/code&gt;. &lt;code&gt;Dispatch&lt;/code&gt; accepts a disjoint union of &lt;code&gt;Action&lt;/code&gt;, &lt;code&gt;ThunkAction&lt;/code&gt;, &lt;code&gt;PromiseAction&lt;/code&gt; and &lt;code&gt;Array&amp;lt;Action&amp;gt;&lt;/code&gt; and can return &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">为了键入Redux的&lt;a href=&quot;http://redux.js.org/docs/advanced/AsyncActions.html#async-action-creators&quot;&gt;thunk动作&lt;/a&gt;，您将添加 &lt;code&gt;ThunkAction&lt;/code&gt; 的类型作为函数 &lt;code&gt;Dispatch&lt;/code&gt; 和 &lt;code&gt;GetState&lt;/code&gt; 。 &lt;code&gt;GetState&lt;/code&gt; 是一个返回 &lt;code&gt;Object&lt;/code&gt; 的函数。 &lt;code&gt;Dispatch&lt;/code&gt; 接受 &lt;code&gt;Action&lt;/code&gt; ， &lt;code&gt;ThunkAction&lt;/code&gt; ， &lt;code&gt;PromiseAction&lt;/code&gt; 和 &lt;code&gt;Array&amp;lt;Action&amp;gt;&lt;/code&gt; 的不相交联合，并且可以返回 &lt;code&gt;any&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="463948e140100316fb05c0438cb2fb9b2c50f529" translate="yes" xml:space="preserve">
          <source>In order to type your Redux &lt;a href=&quot;http://redux.js.org/docs/basics/Actions.html#action-creators&quot;&gt;action creators&lt;/a&gt;, you&amp;rsquo;ll want to split up your &lt;code&gt;Action&lt;/code&gt; disjoint union into separate action types.</source>
          <target state="translated">为了输入您的Redux &lt;a href=&quot;http://redux.js.org/docs/basics/Actions.html#action-creators&quot;&gt;动作创建者&lt;/a&gt;，您需要将 &lt;code&gt;Action&lt;/code&gt; Disjoint联合拆分为单独的动作类型。</target>
        </trans-unit>
        <trans-unit id="a6ed0c1cedb4575cb7b5ef3b66fc0929b6243133" translate="yes" xml:space="preserve">
          <source>In other words, we must engineer Flow&amp;rsquo;s analysis to be extremely fast&amp;mdash;it must respond to code changes without noticeable delay, while still being precise enough in practice.</source>
          <target state="translated">换句话说，我们必须以极快的速度设计Flow的分析-它必须响应代码更改而没有明显的延迟，同时在实践中仍要足够精确。</target>
        </trans-unit>
        <trans-unit id="9ed3794afb3687160903becf6fab09177a6b9c44" translate="yes" xml:space="preserve">
          <source>In other words, we want Flow&amp;rsquo;s analysis to be precise in practice&amp;mdash;it must model essential characteristics of the language accurately enough to understand the difference between idiomatic code and unintentional mistakes.</source>
          <target state="translated">换句话说，我们希望Flow的分析在实践中是精确的-它必须足够准确地建模语言的基本特征，以理解惯用代码和意外错误之间的区别。</target>
        </trans-unit>
        <trans-unit id="9fb052ce5832a38b07cfb4b3b186920962dddf8c" translate="yes" xml:space="preserve">
          <source>In principle, this overhead can be mitigated by adding a layer of types to the codebase, and building tools that use type information to solve the above problems. For example, types can be used to identify bugs, to document interfaces of libraries, and so on.</source>
          <target state="translated">原则上,这种开销可以通过在代码库中增加一层类型来减轻,并构建使用类型信息来解决上述问题的工具。例如,类型可以用来识别bug,用来记录库的接口等等。</target>
        </trans-unit>
        <trans-unit id="46c0c160ff60aaa1954f2f13af37869b4cd1f894" translate="yes" xml:space="preserve">
          <source>In situations like this one, you can leverage the &lt;code&gt;$Keys&amp;lt;T&amp;gt;&lt;/code&gt; operator. Let&amp;rsquo;s see another example, this time using &lt;code&gt;$Keys&lt;/code&gt;:</source>
          <target state="translated">在这种情况下，您可以利用 &lt;code&gt;$Keys&amp;lt;T&amp;gt;&lt;/code&gt; 运算符。让我们来看另一个示例，这次使用 &lt;code&gt;$Keys&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="07ca63a4c55eeea9fee508bfce14ba359d037e35" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://facebook.github.io/react/docs/handling-events.html&quot;&gt;React docs &amp;ldquo;Handling Events&amp;rdquo; section&lt;/a&gt; a few different recommendations are provided on how to define event handlers. If you are using Flow we recommend that you use &lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;property initializer syntax&lt;/a&gt; as it is the easiest to statically type. Property initializer syntax looks like this:</source>
          <target state="translated">在&lt;a href=&quot;https://facebook.github.io/react/docs/handling-events.html&quot;&gt;React docs的&amp;ldquo;处理事件&amp;rdquo;部分&lt;/a&gt;中，提供了一些有关如何定义事件处理程序的不同建议。如果您使用的是Flow，我们建议您使用&lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;属性初始化器语法，&lt;/a&gt;因为它是最容易静态键入的。属性初始化程序的语法如下所示：</target>
        </trans-unit>
        <trans-unit id="045b4893ca1ae9c77490fd71764ad7b6d77ffa63" translate="yes" xml:space="preserve">
          <source>In the above case, we&amp;rsquo;re using literal values as &lt;code&gt;K&lt;/code&gt;, similarly to &lt;a href=&quot;#toc-propertytype&quot;&gt;&lt;code&gt;$PropertyType&amp;lt;T, k&amp;gt;&lt;/code&gt;&lt;/a&gt;. However, when using &lt;code&gt;$ElementType&amp;lt;T, K&amp;gt;&lt;/code&gt;, &lt;code&gt;K&lt;/code&gt; is allowed to be any type, as long as that type exists on the keys of &lt;code&gt;T&lt;/code&gt;. For example:</source>
          <target state="translated">在上述情况下，我们将文字值用作 &lt;code&gt;K&lt;/code&gt; ，类似于&lt;a href=&quot;#toc-propertytype&quot;&gt; &lt;code&gt;$PropertyType&amp;lt;T, k&amp;gt;&lt;/code&gt; &lt;/a&gt;。但是，当使用 &lt;code&gt;$ElementType&amp;lt;T, K&amp;gt;&lt;/code&gt; ，允许 &lt;code&gt;K&lt;/code&gt; 为任何类型，只要该类型存在于 &lt;code&gt;T&lt;/code&gt; 的键上即可。例如：</target>
        </trans-unit>
        <trans-unit id="3f5298183f55322a9608c40096489e4fbda648b8" translate="yes" xml:space="preserve">
          <source>In the case of objects, a &lt;strong&gt;missing&lt;/strong&gt; property is not the same thing as an explicitly &lt;code&gt;undefined&lt;/code&gt; property.</source>
          <target state="translated">对于对象，&lt;strong&gt;缺少的&lt;/strong&gt;属性与显式 &lt;code&gt;undefined&lt;/code&gt; 属性是不同的。</target>
        </trans-unit>
        <trans-unit id="4dd1fcffc78ce1a79e176af9465300a76e634c4a" translate="yes" xml:space="preserve">
          <source>In the code below, value can either be &lt;code&gt;&quot;A&quot;&lt;/code&gt; or &lt;code&gt;&quot;B&quot;&lt;/code&gt;.</source>
          <target state="translated">在下面的代码中，值可以是 &lt;code&gt;&quot;A&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;B&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de4288f8d4aaa876255c7f68bbbad7dd659c5cbb" translate="yes" xml:space="preserve">
          <source>In the example above we are using a &lt;a href=&quot;https://facebook.github.io/react/docs/state-and-lifecycle.html#state-updates-may-be-asynchronous&quot;&gt;React &lt;code&gt;setState()&lt;/code&gt; updater function&lt;/a&gt; but you could also pass a partial state object to &lt;code&gt;setState()&lt;/code&gt;.</source>
          <target state="translated">在上面的示例中，我们使用了&lt;a href=&quot;https://facebook.github.io/react/docs/state-and-lifecycle.html#state-updates-may-be-asynchronous&quot;&gt;React &lt;code&gt;setState()&lt;/code&gt; 更新器函数，&lt;/a&gt;但您也可以将部分状态对象传递给 &lt;code&gt;setState()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="78c833515da3868b1bb8e2586fa68f8aa20ca1b3" translate="yes" xml:space="preserve">
          <source>In the example above, the type of &lt;code&gt;Country&lt;/code&gt; is equivalent to &lt;code&gt;type Country = 'US' | 'IT' | 'FR'&lt;/code&gt;, but Flow was able to extract it from the keys of &lt;code&gt;countries&lt;/code&gt;.</source>
          <target state="translated">在上面的示例中，&amp;ldquo; &lt;code&gt;Country&lt;/code&gt; 的类型等效于&amp;ldquo; &lt;code&gt;type Country = 'US' | 'IT' | 'FR'&lt;/code&gt; ，但Flow能够从 &lt;code&gt;countries&lt;/code&gt; 的密钥中提取它。</target>
        </trans-unit>
        <trans-unit id="937e9cdc3d741999bdf658703ba5d2d9ee3fef52" translate="yes" xml:space="preserve">
          <source>In the first case, the exported types of a module are declared in a &lt;em&gt;declaration file&lt;/em&gt;&lt;code&gt;&amp;lt;FILENAME&amp;gt;.flow&lt;/code&gt;, that is located in the same directory as the corresponding &lt;em&gt;implementation file&lt;/em&gt;&lt;code&gt;&amp;lt;FILENAME&amp;gt;&lt;/code&gt;. The declaration file completely shadows the colocated implementation. In other words, Flow will completely ignore &lt;code&gt;&amp;lt;FILENAME&amp;gt;&lt;/code&gt; and just read &lt;code&gt;&amp;lt;FILENAME&amp;gt;.flow&lt;/code&gt; instead.</source>
          <target state="translated">在第一种情况下，模块的导出类型在&lt;em&gt;声明文件&lt;/em&gt; &lt;code&gt;&amp;lt;FILENAME&amp;gt;.flow&lt;/code&gt; 中声明，该&lt;em&gt;文件&lt;/em&gt;与相应的&lt;em&gt;实现文件&lt;/em&gt; &lt;code&gt;&amp;lt;FILENAME&amp;gt;&lt;/code&gt; 位于同一目录中。声明文件完全隐藏了共置的实现。换句话说，Flow将完全忽略 &lt;code&gt;&amp;lt;FILENAME&amp;gt;&lt;/code&gt; ,而只是读取 &lt;code&gt;&amp;lt;FILENAME&amp;gt;.flow&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f92740913668ddf1132fafd30e60ebce2409efa" translate="yes" xml:space="preserve">
          <source>In the following example, say you want to finish writing the function &lt;code&gt;fooList&lt;/code&gt; without bothering to mock up its dependencies first: a function &lt;code&gt;foo&lt;/code&gt; that takes a &lt;code&gt;number&lt;/code&gt; and returns a &lt;code&gt;string&lt;/code&gt;, and a class &lt;code&gt;List&lt;/code&gt; that has a &lt;code&gt;map&lt;/code&gt; method. You can do this by including declarations for &lt;code&gt;List&lt;/code&gt; and &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">在下面的示例中，假设您要完成编写 &lt;code&gt;fooList&lt;/code&gt; 函数，而无需首先模拟其依赖项：一个具有 &lt;code&gt;number&lt;/code&gt; 并返回 &lt;code&gt;string&lt;/code&gt; &lt;code&gt;foo&lt;/code&gt; 函数，以及一个具有 &lt;code&gt;map&lt;/code&gt; 方法的类 &lt;code&gt;List&lt;/code&gt; 。您可以通过包括 &lt;code&gt;List&lt;/code&gt; 和 &lt;code&gt;foo&lt;/code&gt; 的声明来做到这一点：</target>
        </trans-unit>
        <trans-unit id="a2326d39f5c6c0c33efe4e847e245df6cca55d45" translate="yes" xml:space="preserve">
          <source>In the following example, we forget to properly annotate &lt;code&gt;identity&lt;/code&gt; with a generic type, so we run into trouble when we try to assign it to &lt;code&gt;func&lt;/code&gt;. On the other hand, &lt;code&gt;genericIdentity&lt;/code&gt; is properly typed, and we are able to use it as expected.</source>
          <target state="translated">在下面的示例中，我们忘记了用泛型类型正确地标识 &lt;code&gt;identity&lt;/code&gt; ，因此当我们尝试将其分配给 &lt;code&gt;func&lt;/code&gt; 时遇到麻烦。另一方面， &lt;code&gt;genericIdentity&lt;/code&gt; 的类型正确，我们可以按预期使用它。</target>
        </trans-unit>
        <trans-unit id="1f9d0bf254d010bdd633b1f172693e7ad6fbe077" translate="yes" xml:space="preserve">
          <source>In the previous section we showed how refinement is lost after a function call. The exact same thing happens within closures, since Flow does not track how your value might change before the closure is called.</source>
          <target state="translated">在上一节中,我们展示了如何在函数调用后失去细化。同样的事情也会发生在闭包中,因为在闭包被调用之前,Flow并没有跟踪你的值可能发生的变化。</target>
        </trans-unit>
        <trans-unit id="26926ea42a5a5143965f679a788052c45d4b2dee" translate="yes" xml:space="preserve">
          <source>In the second case, the implementation file is missing entirely. &lt;code&gt;&amp;lt;FILENAME&amp;gt;.flow&lt;/code&gt; is treated as if it is named &lt;code&gt;&amp;lt;FILENAME&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">在第二种情况下，实现文件完全丢失。 &lt;code&gt;&amp;lt;FILENAME&amp;gt;.flow&lt;/code&gt; 视为命名为 &lt;code&gt;&amp;lt;FILENAME&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b39b2010529d0c2ccb12cf90571d17f75bb0be7e" translate="yes" xml:space="preserve">
          <source>In the second example, the first use of &lt;code&gt;?.&lt;/code&gt; is valid, since &lt;code&gt;foo&lt;/code&gt; is potentially nullish, but the second use of &lt;code&gt;?.&lt;/code&gt; is unnecessary. The left-hand-side of the second &lt;code&gt;?.&lt;/code&gt; (&lt;code&gt;foo?.bar&lt;/code&gt;) can only be nullish as a result of &lt;code&gt;foo&lt;/code&gt; being nullish, and when &lt;code&gt;foo&lt;/code&gt; is nullish, short-circuiting lets us avoid the second &lt;code&gt;?.&lt;/code&gt; altogether!</source>
          <target state="translated">在第二个示例中，第一次使用 &lt;code&gt;?.&lt;/code&gt; 是有效的，因为 &lt;code&gt;foo&lt;/code&gt; 可能为空，但是第二个使用 &lt;code&gt;?.&lt;/code&gt; 是没有必要的。第二个 &lt;code&gt;?.&lt;/code&gt; 的左侧。（ &lt;code&gt;foo?.bar&lt;/code&gt; ）只能由于 &lt;code&gt;foo&lt;/code&gt; 为空而为空，而当 &lt;code&gt;foo&lt;/code&gt; 为空时，短路可以让我们避免第二个 &lt;code&gt;?.&lt;/code&gt; 共！</target>
        </trans-unit>
        <trans-unit id="fe1405a89cd32b054392c7923e187f575819c2aa" translate="yes" xml:space="preserve">
          <source>In this guide we will assume you know &lt;a href=&quot;https://facebook.github.io/react/docs/hello-world.html&quot;&gt;the React basics&lt;/a&gt; and focus on adding types for patterns you are already familiar with. We will be using examples based on &lt;code&gt;react-dom&lt;/code&gt;, but all of these patterns work in other environments like &lt;code&gt;react-native&lt;/code&gt; as well.</source>
          <target state="translated">在本指南中，我们将假设您了解&lt;a href=&quot;https://facebook.github.io/react/docs/hello-world.html&quot;&gt;React基础知识，&lt;/a&gt;并专注于为您已经熟悉的模式添加类型。我们将使用基于 &lt;code&gt;react-dom&lt;/code&gt; 的示例，但是所有这些模式都可以在其他环境（例如 &lt;code&gt;react-native&lt;/code&gt; )中使用。</target>
        </trans-unit>
        <trans-unit id="1725f004837e7311155dfaefd968a330b6660337" translate="yes" xml:space="preserve">
          <source>In type systems, &lt;strong&gt;&lt;em&gt;soundness&lt;/em&gt;&lt;/strong&gt; is the ability for a type checker to catch every single error that &lt;em&gt;might&lt;/em&gt; happen at runtime. This comes at the cost of sometimes catching errors that will not actually happen at runtime.</source>
          <target state="translated">在类型系统中，&lt;strong&gt;&lt;em&gt;健全性&lt;/em&gt;&lt;/strong&gt;是类型检查器捕获运行时&lt;em&gt;可能&lt;/em&gt;发生的每个错误的能力。这是以有时捕获在运行时实际上不会发生的错误为代价的。</target>
        </trans-unit>
        <trans-unit id="0c22f8d1c20f6a2e728f54e6d0eb1c49eaf70b92" translate="yes" xml:space="preserve">
          <source>In which &lt;code&gt;props.children&lt;/code&gt; would be the array &lt;code&gt;['hello', ' ', &amp;lt;strong&amp;gt;world&amp;lt;/strong&amp;gt;]&lt;/code&gt;.</source>
          <target state="translated">其中 &lt;code&gt;props.children&lt;/code&gt; 是数组 &lt;code&gt;['hello', ' ', &amp;lt;strong&amp;gt;world&amp;lt;/strong&amp;gt;]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ace6df33f153a56a5ba7bd262d1c9b70a75f2081" translate="yes" xml:space="preserve">
          <source>In which &lt;code&gt;props.children&lt;/code&gt; would be the array &lt;code&gt;['hello', ' world']&lt;/code&gt;.</source>
          <target state="translated">其中 &lt;code&gt;props.children&lt;/code&gt; 是数组 &lt;code&gt;['hello', ' world']&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="379e9d202df0a82bef07b8db10eab0a058f9a77e" translate="yes" xml:space="preserve">
          <source>Indexer properties can be mixed with named properties:</source>
          <target state="translated">索引器属性可以与命名属性混合。</target>
        </trans-unit>
        <trans-unit id="2bdd61bb5045aa0f67014c84f13de75c521599ec" translate="yes" xml:space="preserve">
          <source>Initialize Your Project</source>
          <target state="translated">初始化您的项目</target>
        </trans-unit>
        <trans-unit id="8f1c0c5725c5ba0a7b766ec69cb3fb2725c240c3" translate="yes" xml:space="preserve">
          <source>Injecting Props</source>
          <target state="translated">注入道具</target>
        </trans-unit>
        <trans-unit id="830945c41eb45cbd674fe46b49ac731ee56e9c2d" translate="yes" xml:space="preserve">
          <source>Inlining declarations in regular code</source>
          <target state="translated">在常规代码中嵌入声明</target>
        </trans-unit>
        <trans-unit id="9f834cdcbee4998ebcf13d92d61227888d432240" translate="yes" xml:space="preserve">
          <source>Inside of &lt;code&gt;otherMethod()&lt;/code&gt; we sometimes remove &lt;code&gt;prop&lt;/code&gt;. Flow doesn&amp;rsquo;t know if the &lt;code&gt;if (value.prop)&lt;/code&gt; check is still true, so it invalidates the refinement.</source>
          <target state="translated">在 &lt;code&gt;otherMethod()&lt;/code&gt; 内部，有时会删除 &lt;code&gt;prop&lt;/code&gt; 。Flow不知道if &lt;code&gt;if (value.prop)&lt;/code&gt; 检查是否仍然为true，因此使精简无效。</target>
        </trans-unit>
        <trans-unit id="59233b6f1516ac12e9141c55c7ddd0c26f41e51e" translate="yes" xml:space="preserve">
          <source>Inside of the else block we know that value must be &lt;code&gt;&quot;B&quot;&lt;/code&gt; because it can only be &lt;code&gt;&quot;A&quot;&lt;/code&gt; or &lt;code&gt;&quot;B&quot;&lt;/code&gt; and we&amp;rsquo;ve removed &lt;code&gt;&quot;A&quot;&lt;/code&gt; from the possibilities.</source>
          <target state="translated">在else块内部，我们知道值必须为 &lt;code&gt;&quot;B&quot;&lt;/code&gt; 因为它只能是 &lt;code&gt;&quot;A&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;B&quot;&lt;/code&gt; 并且已从可能性中删除了 &lt;code&gt;&quot;A&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1d0007e9fb3d8a6684762ca326d9d60b18283cd" translate="yes" xml:space="preserve">
          <source>Inside of the if block we know that value must be &lt;code&gt;&quot;A&quot;&lt;/code&gt; because that&amp;rsquo;s the only time the if-statement will be truthy.</source>
          <target state="translated">在if块内部，我们知道该值必须为 &lt;code&gt;&quot;A&quot;&lt;/code&gt; 因为这是if语句为真的唯一时间。</target>
        </trans-unit>
        <trans-unit id="4d19f21faddc0369982f34fb998d7a87e3e3ab91" translate="yes" xml:space="preserve">
          <source>Install the Package Control plugin if you don&amp;rsquo;t have it</source>
          <target state="translated">如果没有安装Package Control插件</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="287044f73b2dcfe1503bb32ec13af489f09a4131" translate="yes" xml:space="preserve">
          <source>Instance is optional and is mixed by default.</source>
          <target state="translated">实例是可选的,默认为混合。</target>
        </trans-unit>
        <trans-unit id="42265abaed207a8433bf897fbee94fabb9b7efc6" translate="yes" xml:space="preserve">
          <source>Instead of typing out a full include every time, you can also use the type annotation shorthand with a single colon &lt;code&gt;:&lt;/code&gt; at the start of the comment.</source>
          <target state="translated">除了在每次输入完整的include之外，您还可以在注释的开头使用带单冒号的类型注释速记 &lt;code&gt;:&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f9d52dffb6f20d8a91f95ec202f836667e53109" translate="yes" xml:space="preserve">
          <source>Instead we can assert the type within the function using a type assertion and now we&amp;rsquo;re validating our inputs.</source>
          <target state="translated">相反，我们可以使用类型声明来声明函数中的类型，现在我们正在验证输入。</target>
        </trans-unit>
        <trans-unit id="8a0cda6edccbb3f27daf363a3f9e17bc75002fbb" translate="yes" xml:space="preserve">
          <source>Instead we can create a generic (or polymorphic type) in our function and use it in place of other types.</source>
          <target state="translated">相反,我们可以在我们的函数中创建一个泛型(或多态类型),并使用它来代替其他类型。</target>
        </trans-unit>
        <trans-unit id="18d4d0b561fd6c9ad913387087267f2acae3ec97" translate="yes" xml:space="preserve">
          <source>Instead you must ensure the value is a certain type by refining it.</source>
          <target state="translated">相反,你必须通过精炼值来确保该值是某种类型。</target>
        </trans-unit>
        <trans-unit id="bc437265bdc77498fe50689b8604c4782c5d0c38" translate="yes" xml:space="preserve">
          <source>Instead, Flow needs to be able to figure out the type of a value by analyzing it without running it (static analysis). It works its way through every known type and starts to figure out what all the expressions around them result in.</source>
          <target state="translated">相反,Flow需要能够在不运行一个值的情况下,通过分析它来找出它的类型(静态分析)。它通过每一个已知的类型,并开始计算出它们周围所有表达式的结果。</target>
        </trans-unit>
        <trans-unit id="cc0d73bb17ba9a6bc2ab84e4aeee29d97f21d5f9" translate="yes" xml:space="preserve">
          <source>Instead, if we create a union type of both object types, Flow will be able to know which object we&amp;rsquo;re using based on the success property.</source>
          <target state="translated">相反，如果我们创建两个对象类型的并集类型，则Flow将能够基于成功属性知道我们正在使用哪个对象。</target>
        </trans-unit>
        <trans-unit id="09971a8657fbf9e085d4cbb5f761ac73cf61af5d" translate="yes" xml:space="preserve">
          <source>Instead, you can use &lt;code&gt;interface&lt;/code&gt; in order to declare the structure of the class that you are expecting.</source>
          <target state="translated">相反，您可以使用 &lt;code&gt;interface&lt;/code&gt; 来声明您期望的类的结构。</target>
        </trans-unit>
        <trans-unit id="7c9832840de0bf07db6e7e769199b00197d92be2" translate="yes" xml:space="preserve">
          <source>Instead, you could add a type to your generic like you would with a function parameter.</source>
          <target state="translated">相反,你可以像添加函数参数一样,为你的泛型添加一个类型。</target>
        </trans-unit>
        <trans-unit id="4a7f5be1f3824ca58b2047493f6f9764ebebd43f" translate="yes" xml:space="preserve">
          <source>Interface Generics</source>
          <target state="translated">接口通用</target>
        </trans-unit>
        <trans-unit id="5c9516afee7b643e69c589c7e2bd6bb8f850ec3e" translate="yes" xml:space="preserve">
          <source>Interface Methods</source>
          <target state="translated">接口方法</target>
        </trans-unit>
        <trans-unit id="8e3d0bc70c93775ccb76349f5bd2dd104013f378" translate="yes" xml:space="preserve">
          <source>Interface Properties</source>
          <target state="translated">接口属性</target>
        </trans-unit>
        <trans-unit id="21a1595cfcababf257ea39c1df3d595d9106d56e" translate="yes" xml:space="preserve">
          <source>Interface Syntax</source>
          <target state="translated">接口语法</target>
        </trans-unit>
        <trans-unit id="70f73f412d22faa3833d1fbb1c9b469c337baa08" translate="yes" xml:space="preserve">
          <source>Interface Types</source>
          <target state="translated">接口类型</target>
        </trans-unit>
        <trans-unit id="74724adee3fa147f0cfea79a04b9867eafea6d0a" translate="yes" xml:space="preserve">
          <source>Interface generics are &lt;a href=&quot;../generics#toc-parameterized-generics&quot;&gt;parameterized&lt;/a&gt;. When you use an interface you need to pass parameters for each of its generics.</source>
          <target state="translated">接口泛型已&lt;a href=&quot;../generics#toc-parameterized-generics&quot;&gt;参数化&lt;/a&gt;。使用接口时，需要为其每个泛型传递参数。</target>
        </trans-unit>
        <trans-unit id="ff0e2f95a23bc1a0a798148519f6dbf839797446" translate="yes" xml:space="preserve">
          <source>Interface properties are &lt;a href=&quot;https://flow.org/en/lang/variance/&quot;&gt;invariant&lt;/a&gt; by default. But you can add modifiers to make them covariant (read-only) or contravariant (write-only).</source>
          <target state="translated">接口属性默认情况下是&lt;a href=&quot;https://flow.org/en/lang/variance/&quot;&gt;不变&lt;/a&gt;的。但是，您可以添加修饰符以使它们协变（只读）或逆变（仅写）。</target>
        </trans-unit>
        <trans-unit id="d3b1f8821225ec65ee0716fe750fde20ad499768" translate="yes" xml:space="preserve">
          <source>Interface properties can be optional as well.</source>
          <target state="translated">接口属性也可以是可选的。</target>
        </trans-unit>
        <trans-unit id="5eda7a98fcca8f4914f0766acaea5b5c31ce76c1" translate="yes" xml:space="preserve">
          <source>Interface property variance (read-only and write-only)</source>
          <target state="translated">接口属性差异(只读和只写)</target>
        </trans-unit>
        <trans-unit id="8d1aa740c66ddff084a50256d6d5d30cf43e7c72" translate="yes" xml:space="preserve">
          <source>Interfaces are created using the keyword &lt;code&gt;interface&lt;/code&gt; followed by its name and a block which contains the body of the type definition.</source>
          <target state="translated">使用关键字 &lt;code&gt;interface&lt;/code&gt; ，其名称和包含类型定义主体的块创建接口。</target>
        </trans-unit>
        <trans-unit id="402c6f12d8378d77232d585fd7b337e32915eab4" translate="yes" xml:space="preserve">
          <source>Interfaces as maps</source>
          <target state="translated">作为地图的接口</target>
        </trans-unit>
        <trans-unit id="1a13b883b189e50bf8951cacdf198f7feb8f80b6" translate="yes" xml:space="preserve">
          <source>Interfaces can also have their own &lt;a href=&quot;../generics&quot;&gt;generics&lt;/a&gt;.</source>
          <target state="translated">接口也可以具有自己的&lt;a href=&quot;../generics&quot;&gt;泛型&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5b5667cb6fa2d471880ebd263d10231bc9b5599a" translate="yes" xml:space="preserve">
          <source>Interfaces with generics</source>
          <target state="translated">与非专利产品的接口</target>
        </trans-unit>
        <trans-unit id="ef35fc41614978724e53f8c707770be7d1309ab3" translate="yes" xml:space="preserve">
          <source>Intersection Types</source>
          <target state="translated">交叉口类型</target>
        </trans-unit>
        <trans-unit id="e1ecad2c1fbdd686a36d4b38b266bcecfd3b76fc" translate="yes" xml:space="preserve">
          <source>Intersection of function types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a31764a6d7e0f5c4582676c60aee1f2a34282cc" translate="yes" xml:space="preserve">
          <source>Intersection ranges, which are ANDed together, (e.g. &lt;code&gt;&amp;gt;=0.13.0 &amp;lt;0.14.0&lt;/code&gt;, which matches &lt;code&gt;0.13.0&lt;/code&gt; and &lt;code&gt;0.13.5&lt;/code&gt; but not &lt;code&gt;0.14.0&lt;/code&gt;).</source>
          <target state="translated">相交范围将AND运算在一起（例如 &lt;code&gt;&amp;gt;=0.13.0 &amp;lt;0.14.0&lt;/code&gt; ，与 &lt;code&gt;0.13.0&lt;/code&gt; 和 &lt;code&gt;0.13.5&lt;/code&gt; 匹配，但不匹配 &lt;code&gt;0.14.0&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5f08815e0988cf77077de263c1ad9e7aa5845e9e" translate="yes" xml:space="preserve">
          <source>Intersection type syntax</source>
          <target state="translated">交集类型语法</target>
        </trans-unit>
        <trans-unit id="626a19ac04f2c67f93200f15583f19cead27a82f" translate="yes" xml:space="preserve">
          <source>Intersection types are any number of types which are joined by an ampersand &lt;code&gt;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">交叉点的类型是任意数量的其由一个与符号接合类型 &lt;code&gt;&amp;amp;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f7c84eb5f66c165a2d5dcc86fb36cae890387ee" translate="yes" xml:space="preserve">
          <source>Intersection types are the opposite of union types. When calling a function that accepts an intersection type, we must pass in &lt;strong&gt;&lt;em&gt;all of those types&lt;/em&gt;&lt;/strong&gt;. But inside of our function we only have to treat it as &lt;strong&gt;&lt;em&gt;any one of those types&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">交叉点类型与联合类型相反。调用接受交集类型的函数时，我们必须传递&lt;strong&gt;&lt;em&gt;所有这些类型&lt;/em&gt;&lt;/strong&gt;。但是在我们的函数内部，我们只需要将其视为&lt;strong&gt;&lt;em&gt;这些类型中的任何一种即可&lt;/em&gt;&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="05fd5c57befbf7fcd9f20936b84629f69018650a" translate="yes" xml:space="preserve">
          <source>Intersection types require all in, but one out</source>
          <target state="translated">交叉口类型要求全进全出。</target>
        </trans-unit>
        <trans-unit id="b7a19c5413699eccc99e2d547ef6d10a7c3d1bef" translate="yes" xml:space="preserve">
          <source>Intersections of exact object types may not work as you expect. If you need to combine exact object types, use object type spread:</source>
          <target state="translated">精确对象类型的交集可能不会像你期望的那样工作。如果您需要组合精确的对象类型,请使用对象类型展开。</target>
        </trans-unit>
        <trans-unit id="ef1118f07f2f0b37c8e805eac5ac7941bb61730b" translate="yes" xml:space="preserve">
          <source>Intersections of object types</source>
          <target state="translated">对象类型的交叉点</target>
        </trans-unit>
        <trans-unit id="2abe56a8a00ed911e647b0d623cffa17d4460d9d" translate="yes" xml:space="preserve">
          <source>Invariance</source>
          <target state="translated">Invariance</target>
        </trans-unit>
        <trans-unit id="da76716b09b6ac18a389bcf77588eef885895f86" translate="yes" xml:space="preserve">
          <source>Invariance &lt;em&gt;does not&lt;/em&gt; accept &lt;strong&gt;subtypes&lt;/strong&gt;.</source>
          <target state="translated">不变性&lt;em&gt;不&lt;/em&gt;接受&lt;strong&gt;子类型&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="6653bcb7fefb5beca9669e196871c6f423594c47" translate="yes" xml:space="preserve">
          <source>Invariance &lt;em&gt;does not&lt;/em&gt; accept &lt;strong&gt;supertypes&lt;/strong&gt;.</source>
          <target state="translated">不变性&lt;em&gt;不&lt;/em&gt;接受&lt;strong&gt;超类型&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="c6b07258a9d2edf9a12dc279bf478a7591587b4c" translate="yes" xml:space="preserve">
          <source>It can get a little bit more complicated than this.</source>
          <target state="translated">它可以得到一个比这更复杂一点。</target>
        </trans-unit>
        <trans-unit id="1057c3d1333719898e827a2ee41fb627a60e7f29" translate="yes" xml:space="preserve">
          <source>It is also different from the &lt;code&gt;[declarations]&lt;/code&gt; section. This also does not typecheck the file contents, but &lt;code&gt;[declarations]&lt;/code&gt; does extract and use the signatures of functions, classes, etc, when checking other code.</source>
          <target state="translated">它也与 &lt;code&gt;[declarations]&lt;/code&gt; 部分不同。这也不会对文件内容进行类型检查，但是 &lt;code&gt;[declarations]&lt;/code&gt; 会在检查其他代码时提取并使用函数，类等的签名。</target>
        </trans-unit>
        <trans-unit id="d3fbd12c64d612ad1b02084fd80cefee8a6288b8" translate="yes" xml:space="preserve">
          <source>It is also possible to declare both &lt;strong&gt;named&lt;/strong&gt; and &lt;strong&gt;default&lt;/strong&gt; exports in the same &lt;code&gt;declare module&lt;/code&gt; body.</source>
          <target state="translated">也可以在同一 &lt;code&gt;declare module&lt;/code&gt; 主体中声明&lt;strong&gt;命名&lt;/strong&gt;导出和&lt;strong&gt;默认&lt;/strong&gt;导出。</target>
        </trans-unit>
        <trans-unit id="f0d57b0ea07b126bc6a1382dc48f77a187c015b2" translate="yes" xml:space="preserve">
          <source>It is also possible to invalidate refinements, for example:</source>
          <target state="translated">也可以使精炼无效,例如。</target>
        </trans-unit>
        <trans-unit id="c9db640a0ff9ca2d2098c8cf12f7a5222f3c36e9" translate="yes" xml:space="preserve">
          <source>It is common to have an empty &lt;code&gt;.flowconfig&lt;/code&gt; file for your project. However, you can &lt;a href=&quot;https://flow.org/en/config/&quot;&gt;configure and customize Flow&lt;/a&gt; in many ways through options available to be added to &lt;code&gt;.flowconfig&lt;/code&gt;.</source>
          <target state="translated">通常为您的项目创建一个空的 &lt;code&gt;.flowconfig&lt;/code&gt; 文件。但是，您可以通过可用于添加到 &lt;code&gt;.flowconfig&lt;/code&gt; 的选项以多种方式&lt;a href=&quot;https://flow.org/en/config/&quot;&gt;配置和定制Flow&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d64a8b56c9d350143c6c4049c479ee66c6fad872" translate="yes" xml:space="preserve">
          <source>It is often useful to share types in between modules (files). In Flow, you can export type aliases, interfaces, and classes from one file and import them in another.</source>
          <target state="translated">在模块(文件)之间共享类型通常很有用。在Flow中,你可以从一个文件中导出类型别名、接口和类,并在另一个文件中导入它们。</target>
        </trans-unit>
        <trans-unit id="793822e10b49e7269fcbd5028ab19a2d3c9de56e" translate="yes" xml:space="preserve">
          <source>It may also be used as the return type of a stateless functional component:</source>
          <target state="translated">它也可以作为无状态功能组件的返回类型。</target>
        </trans-unit>
        <trans-unit id="75369e827759c9f54ba9a23edbe8b02d79a3c6c7" translate="yes" xml:space="preserve">
          <source>It will compile to what you would expect: &lt;code&gt;React.createElement(MyComponent, {}, 42)&lt;/code&gt;.</source>
          <target state="translated">它将编译为您期望的： &lt;code&gt;React.createElement(MyComponent, {}, 42)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="083c10e6c6edff28e6273ebb5cfbc6a9d5dd4768" translate="yes" xml:space="preserve">
          <source>It would be hard to create a type for this because we&amp;rsquo;re creating a new object based on another object.</source>
          <target state="translated">为此将很难创建类型，因为我们正在基于另一个对象创建一个新对象。</target>
        </trans-unit>
        <trans-unit id="87f8da49eb8c969a18ca82d9274232c071921f87" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s common for JavaScript code to introduce &amp;ldquo;optional&amp;rdquo; values so that you have the option of leaving out the value or passing &lt;code&gt;null&lt;/code&gt; instead.</source>
          <target state="translated">JavaScript代码通常会引入&amp;ldquo;可选&amp;rdquo;值，以便您可以选择忽略该值或传递 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09d032ed6e922fe662f519234b7d555a3d8f5ecb" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s safe to use an object with &amp;ldquo;extra&amp;rdquo; properties in a position that is annotated with a specific set of properties.</source>
          <target state="translated">在具有特定属性集的位置使用具有&amp;ldquo;额外&amp;rdquo;属性的对象是安全的。</target>
        </trans-unit>
        <trans-unit id="64245667942d0f59a4c76fbe92eaa77e04d0970f" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s valid to use an &lt;code&gt;Employee&lt;/code&gt; instance where a &lt;code&gt;Person&lt;/code&gt; instance is expected.</source>
          <target state="translated">使用需要 &lt;code&gt;Person&lt;/code&gt; 实例的 &lt;code&gt;Employee&lt;/code&gt; 实例是有效的。</target>
        </trans-unit>
        <trans-unit id="62185bdbfa583ea0a944a6564348a7230248cc32" translate="yes" xml:space="preserve">
          <source>JSX intrinsics like &lt;code&gt;div&lt;/code&gt; will give you their DOM instance. For &lt;code&gt;React.ElementRef&amp;lt;'div'&amp;gt;&lt;/code&gt; that would be &lt;code&gt;HTMLDivElement&lt;/code&gt;. For &lt;code&gt;React.ElementRef&amp;lt;'input'&amp;gt;&lt;/code&gt; that would be &lt;code&gt;HTMLInputElement&lt;/code&gt;.</source>
          <target state="translated">像 &lt;code&gt;div&lt;/code&gt; 这样的JSX内部函数将为您提供DOM实例。对于 &lt;code&gt;React.ElementRef&amp;lt;'div'&amp;gt;&lt;/code&gt; 将是 &lt;code&gt;HTMLDivElement&lt;/code&gt; 。对于 &lt;code&gt;React.ElementRef&amp;lt;'input'&amp;gt;&lt;/code&gt; 将是 &lt;code&gt;HTMLInputElement&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="314a8a9290ad5ef0b2052cf134783f7c4c08b7c9" translate="yes" xml:space="preserve">
          <source>JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes&quot;&gt;classes&lt;/a&gt; in Flow operate both as a value and a type.</source>
          <target state="translated">Flow中的JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes&quot;&gt;类&lt;/a&gt;既可以作为值也可以作为类型。</target>
        </trans-unit>
        <trans-unit id="ff96432cd6c0749abc586d23ed4761948a7d9261" translate="yes" xml:space="preserve">
          <source>JavaScript also supports having rest parameters or parameters that collect an array of arguments at the end of a list of parameters. These have an ellipsis &lt;code&gt;...&lt;/code&gt; before them.</source>
          <target state="translated">JavaScript还支持在参数列表的末尾具有rest参数或收集参数数组的参数。它们前面有一个省略号 &lt;code&gt;...&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="33492c4de9d1778195557bc2a689c8efa4fb169f" translate="yes" xml:space="preserve">
          <source>JavaScript bugs can have significant impact at Facebook. Developers want to find and fix as many bugs as they can by the time their code rolls out into production. So we must care about soundness. At the same time, we must also care about not reporting too many spurious errors, because a low signal/noise ratio implies a low fix rate.</source>
          <target state="translated">JavaScript错误在Facebook会产生重大影响。开发人员希望在他们的代码推出生产时,尽可能多地找到并修复错误。所以我们必须关心健全性。同时,我们还必须关心不要报告太多虚假的错误,因为低信噪比意味着低修复率。</target>
        </trans-unit>
        <trans-unit id="d19af2dce65e63655c2e776d25a142cbd6199eba" translate="yes" xml:space="preserve">
          <source>JavaScript can also implicitly convert other types of values into booleans.</source>
          <target state="translated">JavaScript还可以隐式地将其他类型的值转换为布尔值。</target>
        </trans-unit>
        <trans-unit id="485f1f2852599072f08415fb5cfd6b061d9a0dd4" translate="yes" xml:space="preserve">
          <source>JavaScript has a &lt;code&gt;typeof&lt;/code&gt; operator which returns a string describing a value.</source>
          <target state="translated">JavaScript具有 &lt;code&gt;typeof&lt;/code&gt; 运算符，该运算符返回描述值的字符串。</target>
        </trans-unit>
        <trans-unit id="eecc786af80843327406bcc95d93039f0b604da8" translate="yes" xml:space="preserve">
          <source>JavaScript has a number of different primitive types (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures&quot;&gt;MDN&lt;/a&gt;):</source>
          <target state="translated">JavaScript具有许多不同的原始类型（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures&quot;&gt;MDN&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="ce0fe7a86fd9b14d2fbe082506c653d7a9eeb404" translate="yes" xml:space="preserve">
          <source>JavaScript has both &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;. Flow treats these as separate types: &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;void&lt;/code&gt; (for &lt;code&gt;undefined&lt;/code&gt;).</source>
          <target state="translated">JavaScript具有 &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 。Flow将它们视为单独的类型： &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;void&lt;/code&gt; （对于 &lt;code&gt;undefined&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="40359189cd32fdb5d25cf14079d2c89de3d26e61" translate="yes" xml:space="preserve">
          <source>JavaScript has three ways of declaring local variables:</source>
          <target state="translated">JavaScript有三种方式来声明局部变量。</target>
        </trans-unit>
        <trans-unit id="377373e4c9e318e17a21d159b16d98d2f2d7a8f4" translate="yes" xml:space="preserve">
          <source>JavaScript implicitly converts other types of values into strings by concatenating them.</source>
          <target state="translated">JavaScript通过将其他类型的值连接起来,隐式地将它们转换为字符串。</target>
        </trans-unit>
        <trans-unit id="db1d2f70ca60dcb812c319504dfac9c408dad07e" translate="yes" xml:space="preserve">
          <source>JavaScript: The Good and the Bad</source>
          <target state="translated">JavaScript。好的和坏的</target>
        </trans-unit>
        <trans-unit id="1baa7d034b3c654fd892b56488a2e2906ca22f77" translate="yes" xml:space="preserve">
          <source>Just don&amp;rsquo;t forget to replace the declarations with proper implementations.</source>
          <target state="translated">只是不要忘记用适当的实现替换声明。</target>
        </trans-unit>
        <trans-unit id="03cc07a06695efabc9bb1deed8b72855cef54594" translate="yes" xml:space="preserve">
          <source>Just like in functions, class methods can have annotations for both parameters (input) and returns (output).</source>
          <target state="translated">就像在函数中一样,类方法可以对参数(输入)和返回(输出)都有注解。</target>
        </trans-unit>
        <trans-unit id="f0796f6608e21ddf9f9cee05b46aec16a2404747" translate="yes" xml:space="preserve">
          <source>Just like other type imports, this code will be stripped away by a compiler and will not add a dependency on the other module.</source>
          <target state="translated">就像其他类型导入一样,这段代码会被编译器剥离,不会增加对其他模块的依赖。</target>
        </trans-unit>
        <trans-unit id="6cfd51b40ca6ae71ea4ad94dee1f137fd72e5baa" translate="yes" xml:space="preserve">
          <source>Just note that &lt;code&gt;?Type[]&lt;/code&gt; is the equivalent of &lt;code&gt;?Array&amp;lt;T&amp;gt;&lt;/code&gt; and not &lt;code&gt;Array&amp;lt;?T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;?Type[]&lt;/code&gt; 等效于 &lt;code&gt;?Array&amp;lt;T&amp;gt;&lt;/code&gt; 而不是 &lt;code&gt;Array&amp;lt;?T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4434db270fc0025e6dbf7944b0a7129f670d0468" translate="yes" xml:space="preserve">
          <source>LanguageClient-neovim</source>
          <target state="translated">LanguageClient-neovim</target>
        </trans-unit>
        <trans-unit id="95281a82e78ce2087d1012bf40625523f8488a7d" translate="yes" xml:space="preserve">
          <source>Languages like C++, Java, and Swift have primarily nominal type systems.</source>
          <target state="translated">像C++、Java和Swift这样的语言主要有名义类型系统。</target>
        </trans-unit>
        <trans-unit id="c792712a7965712fd189272a6613d98437d6180b" translate="yes" xml:space="preserve">
          <source>Languages like OCaml, Haskell, and Elm have primarily structural type systems.</source>
          <target state="translated">OCaml、Haskell和Elm等语言主要有结构类型系统。</target>
        </trans-unit>
        <trans-unit id="a8a1053bb6874133e95b37afbe211c7a892a815e" translate="yes" xml:space="preserve">
          <source>Lazy Modes</source>
          <target state="translated">懒人模式</target>
        </trans-unit>
        <trans-unit id="dfdfa63658de426609e22c38f88280bb9b75116d" translate="yes" xml:space="preserve">
          <source>Lazy mode tries to classify your code into four categories.</source>
          <target state="translated">懒惰模式试图将你的代码分为四类。</target>
        </trans-unit>
        <trans-unit id="3dbc910e4fff9344f64869a8a5fc5c3d4355ac06" translate="yes" xml:space="preserve">
          <source>Lazy mode will still find all the JavaScript files and parse them. But it won&amp;rsquo;t typecheck the unchecked files.</source>
          <target state="translated">惰性模式仍将找到所有JavaScript文件并进行解析。但是它不会对未检查的文件进行类型检查。</target>
        </trans-unit>
        <trans-unit id="ad97b5eba3e92f8085f952420bce8e282a6f3f53" translate="yes" xml:space="preserve">
          <source>Learn how the type system in Flow works: Subtyping, Variance, Refinements, and more.</source>
          <target state="translated">了解Flow中的类型系统如何工作。子类型、差异、精炼等。</target>
        </trans-unit>
        <trans-unit id="17c6582762d51b971201160cc102c9a657f98c40" translate="yes" xml:space="preserve">
          <source>Learn how to add Flow type annotations to your code: Primitives, Objects, Functions, Classes, and more.</source>
          <target state="translated">了解如何将Flow类型注释添加到您的代码中。基元、对象、函数、类等。</target>
        </trans-unit>
        <trans-unit id="9061150cf645a8a07d4e182bd88b83043c6adeca" translate="yes" xml:space="preserve">
          <source>Learn how to configure Flow's linter to find potentially harmful code.</source>
          <target state="translated">学习如何配置Flow的linter来查找潜在的有害代码。</target>
        </trans-unit>
        <trans-unit id="ec546a6d98494e29fb29baba819e9036753ffc1c" translate="yes" xml:space="preserve">
          <source>Learn how to create and use library definitions for the third-party code your code depends on.</source>
          <target state="translated">学习如何为你的代码所依赖的第三方代码创建和使用库定义。</target>
        </trans-unit>
        <trans-unit id="81f0dff59c9c62d6cf866bb76b77e359a044ee03" translate="yes" xml:space="preserve">
          <source>Learn how to enable stricter type checking on a file-by-file basis.</source>
          <target state="translated">学习如何在逐个文件的基础上启用更严格的类型检查。</target>
        </trans-unit>
        <trans-unit id="c70b764f18ae2f3c19d5793e638472220f06722b" translate="yes" xml:space="preserve">
          <source>Learn how to suppress Flow's type errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b22d7b7814e7097977052e60714138c723c00f5" translate="yes" xml:space="preserve">
          <source>Learn how to use Flow to effectively type common and advanced React patterns.</source>
          <target state="translated">学习如何使用Flow有效地键入常见和高级React模式。</target>
        </trans-unit>
        <trans-unit id="2b9e35721f161da639af3e629c43a749a10c8d13" translate="yes" xml:space="preserve">
          <source>Learn how to write types in .flow files.</source>
          <target state="translated">学习如何在.flow文件中编写类型。</target>
        </trans-unit>
        <trans-unit id="89668dad1cc2803bc9a05873362cf34088114329" translate="yes" xml:space="preserve">
          <source>Less specific inputs &amp;mdash; Good</source>
          <target state="translated">具体输入较少-良好</target>
        </trans-unit>
        <trans-unit id="923403997632248e58e2bb70246889bdff43c52c" translate="yes" xml:space="preserve">
          <source>Less specific outputs &amp;mdash; Bad</source>
          <target state="translated">具体输出较少-较差</target>
        </trans-unit>
        <trans-unit id="56b22fadb66ce39178decbc7081dadaa222b6580" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at a couple of more advanced examples:</source>
          <target state="translated">让我们看几个更高级的示例：</target>
        </trans-unit>
        <trans-unit id="4d2a79c6b93594188cbf9b55c1481295a10f9571" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at a more general, and sometimes more convenient way to declare types for modules: &lt;code&gt;.flow&lt;/code&gt; files.</source>
          <target state="translated">让我们看一下一种更通用，有时更方便的方法来声明模块的类型： &lt;code&gt;.flow&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="e86757a83ce64508253852d9564cd9fe0caffc8b" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s rewrite our function to handle each type individually.</source>
          <target state="translated">让我们重写函数以分别处理每种类型。</target>
        </trans-unit>
        <trans-unit id="9f80216838aa529f22c630c26f5b236d726d206d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say we have a function type and a few functions. Which of the functions can be used safely in code that expects the given function type?</source>
          <target state="translated">假设我们有一个函数类型和几个函数。哪些函数可以在需要给定函数类型的代码中安全使用？</target>
        </trans-unit>
        <trans-unit id="19a72503865e9c4d4dbb4e6b8d83e9c6bb555f83" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see a couple of examples:</source>
          <target state="translated">让我们看几个例子：</target>
        </trans-unit>
        <trans-unit id="3f378a2d680120a037a23d1a877c71075aaafcf4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see an example. Suppose you have a function called &lt;code&gt;run&lt;/code&gt; that takes an object of thunks (functions in the form &lt;code&gt;() =&amp;gt; A&lt;/code&gt;) as input:</source>
          <target state="translated">让我们来看一个例子。假设您有一个名为 &lt;code&gt;run&lt;/code&gt; 的函数，该函数将一个thunk对象（形式为 &lt;code&gt;() =&amp;gt; A&lt;/code&gt; 函数）作为输入：</target>
        </trans-unit>
        <trans-unit id="32b252980a12fe72e87f2a649ca85e8a29abefd4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with the simplest HOC:</source>
          <target state="translated">让我们从最简单的HOC开始：</target>
        </trans-unit>
        <trans-unit id="ffff4663a687b3c96978f5c3f0d326215fa1908f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at how you can type some example HOCs.</source>
          <target state="translated">让我们看一下如何键入一些示例HOC。</target>
        </trans-unit>
        <trans-unit id="f9b942f0b29382ee9e16a650bf2bb4ee6a83a2ac" translate="yes" xml:space="preserve">
          <source>Library Definitions</source>
          <target state="translated">图书馆定义</target>
        </trans-unit>
        <trans-unit id="de6d8b01f166fb75ee7809437032a5304f395753" translate="yes" xml:space="preserve">
          <source>Library definitions are considered strict (as they can be included in many different projects with contradicting strict configurations).</source>
          <target state="translated">库定义被认为是严格的(因为它们可以包含在许多不同的项目中,其严格配置是矛盾的)。</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">根据麻省理工学院许可证授权。</target>
        </trans-unit>
        <trans-unit id="1f94a87973cd7d8f6f84a5de26376923c65809ef" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#toc-implicit-inexact-object&quot;&gt;&lt;code&gt;implicit-inexact-object&lt;/code&gt;&lt;/a&gt;, except triggers even when the &lt;code&gt;exact_by_default&lt;/code&gt; option is set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">类似于&lt;a href=&quot;#toc-implicit-inexact-object&quot;&gt; &lt;code&gt;implicit-inexact-object&lt;/code&gt; &lt;/a&gt; &lt;code&gt;exact_by_default&lt;/code&gt; -object，即使exact_by_default选项设置为 &lt;code&gt;true&lt;/code&gt; 也会触发。</target>
        </trans-unit>
        <trans-unit id="99631d72797c2b4f916d1968332cece8d677359f" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#toc-react-element&quot;&gt;&lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;typeof Component&lt;/code&gt; must be the type &lt;em&gt;of&lt;/em&gt; a React component so you need to use &lt;code&gt;typeof&lt;/code&gt; as in &lt;code&gt;React.ElementProps&amp;lt;typeof MyComponent&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">像&lt;a href=&quot;#toc-react-element&quot;&gt; &lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;typeof Component&lt;/code&gt; 必须是React组件的类型&lt;em&gt;，&lt;/em&gt;因此您需要像 &lt;code&gt;React.ElementProps&amp;lt;typeof MyComponent&amp;gt;&lt;/code&gt; 一样使用 &lt;code&gt;typeof&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="afdeb072663138fc0c7eb121d5d1c44b8ac851c2" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#toc-react-element&quot;&gt;&lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;typeof Component&lt;/code&gt; must be the type &lt;em&gt;of&lt;/em&gt; a React component so you need to use &lt;code&gt;typeof&lt;/code&gt; as in &lt;code&gt;React.ElementRef&amp;lt;typeof MyComponent&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">像&lt;a href=&quot;#toc-react-element&quot;&gt; &lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;typeof Component&lt;/code&gt; 必须是React组件的类型&lt;em&gt;，&lt;/em&gt;因此您需要像 &lt;code&gt;React.ElementRef&amp;lt;typeof MyComponent&amp;gt;&lt;/code&gt; 一样使用 &lt;code&gt;typeof&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3bfdd355019fb00dad0f94f122a17cd4e371ba06" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#toc-react-element&quot;&gt;&lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;typeof Component&lt;/code&gt; must be the type &lt;em&gt;of&lt;/em&gt; a React component so you need to use &lt;code&gt;typeof&lt;/code&gt; as in &lt;code&gt;React.Ref&amp;lt;typeof MyComponent&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">像&lt;a href=&quot;#toc-react-element&quot;&gt; &lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;typeof Component&lt;/code&gt; 必须是React组件的类型&lt;em&gt;，&lt;/em&gt;因此您需要像 &lt;code&gt;React.Ref&amp;lt;typeof MyComponent&amp;gt;&lt;/code&gt; 中那样使用 &lt;code&gt;typeof&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fbecb30c8c5786dd14c47738d4071ca6c0260abd" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;React.ElementProps&amp;lt;typeof Component&amp;gt;&lt;/code&gt; this utility gets the type of a component&amp;rsquo;s props but &lt;em&gt;preserves&lt;/em&gt; the optionality of &lt;code&gt;defaultProps&lt;/code&gt;!</source>
          <target state="translated">像 &lt;code&gt;React.ElementProps&amp;lt;typeof Component&amp;gt;&lt;/code&gt; 此实用程序获取组件的props的类型，但&lt;em&gt;保留&lt;/em&gt; &lt;code&gt;defaultProps&lt;/code&gt; 的可选性！</target>
        </trans-unit>
        <trans-unit id="d041aadefbd6307d2b548663eef27b76cecb7788" translate="yes" xml:space="preserve">
          <source>Like precision, speed also has other significant effects. When bugs are reported as the developer makes changes to code, they become part of the editing process&amp;mdash;the developer doesn&amp;rsquo;t need to run the code to detect bugs, and tracing bugs back to the code becomes simpler. Similarly, when the IDE can show the type of an expression, the definition reaching a reference, etc. as the developer is coding, we have observed that productivity can improve dramatically.</source>
          <target state="translated">像精度一样，速度也有其他重要影响。当在开发人员对代码进行更改时报告错误时，它们便成为编辑过程的一部分-开发人员无需运行代码来检测错误，并且将错误追溯到代码变得更加简单。同样，当IDE在开发人员进行编码时可以显示表达式的类型，到达引用的定义等时，我们发现生产率可以大大提高。</target>
        </trans-unit>
        <trans-unit id="59b86486aed4edafd59a372a9da15c32460385f0" translate="yes" xml:space="preserve">
          <source>Like this:</source>
          <target state="translated">像这样</target>
        </trans-unit>
        <trans-unit id="66fb1f635bf9b7934a337051ec9a565c68387c38" translate="yes" xml:space="preserve">
          <source>Limit the scope of the &lt;code&gt;well_formed_exports&lt;/code&gt; requirement to a specific directory of this project. For example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f316525461e2a4c6c2b89d883cfb34c624544ab" translate="yes" xml:space="preserve">
          <source>Lint Rule Reference</source>
          <target state="translated">绒毛规则参考</target>
        </trans-unit>
        <trans-unit id="d1bf3e3c86e73b07580c5c816b1b04837ea95e8f" translate="yes" xml:space="preserve">
          <source>Lint Settings Precedence</source>
          <target state="translated">绒毛设置 优先级</target>
        </trans-unit>
        <trans-unit id="4dbc74e7618b9b038882a1a26b628723a0e3e49a" translate="yes" xml:space="preserve">
          <source>Lint settings can be specified in the &lt;code&gt;.flowconfig&lt;/code&gt; [lints] section as a list of &lt;code&gt;rule=severity&lt;/code&gt; pairs. These settings apply globally to the entire project.</source>
          <target state="translated">可以在 &lt;code&gt;.flowconfig&lt;/code&gt; [lints]部分中将Lint设置指定为 &lt;code&gt;rule=severity&lt;/code&gt; Severity 对的列表。这些设置全局应用于整个项目。</target>
        </trans-unit>
        <trans-unit id="e24c1254981afd7ee28d2270b93ccfb59eae399a" translate="yes" xml:space="preserve">
          <source>Lint settings can be specified inside a file using &lt;code&gt;flowlint&lt;/code&gt; comments. These settings apply to a region of a file, or a single line, or part of a line. For more details see &lt;a href=&quot;flowlint-comments&quot;&gt;Flowlint Comments&lt;/a&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;flowlint&lt;/code&gt; 注释在文件内部指定Lint设置。这些设置适用于文件的区域，一行或一行的一部分。有关更多详细信息，请参见&lt;a href=&quot;flowlint-comments&quot;&gt;Flowlint评论&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e5d62735922d047192446d6cc3f42ad67aea4c2d" translate="yes" xml:space="preserve">
          <source>Lint settings can be specified using the &lt;code&gt;--lints&lt;/code&gt; flag of a Flow server command as a comma-delimited list of &lt;code&gt;rule=severity&lt;/code&gt; pairs. These settings apply globally to the entire project.</source>
          <target state="translated">可以使用Flow服务器命令的 &lt;code&gt;--lints&lt;/code&gt; 标志将Lint设置指定为 &lt;code&gt;rule=severity&lt;/code&gt; Severity对的逗号分隔列表。这些设置全局应用于整个项目。</target>
        </trans-unit>
        <trans-unit id="24b2695bce6ad369789c8095fc314893c4855226" translate="yes" xml:space="preserve">
          <source>Lint settings in &lt;code&gt;flowlint&lt;/code&gt; comments have the highest priority, followed by lint rules in the &lt;code&gt;--lints&lt;/code&gt; flag, followed by the &lt;code&gt;.flowconfig&lt;/code&gt;. This order allows you to use &lt;code&gt;flowlint&lt;/code&gt; comments for fine-grained linting control, the &lt;code&gt;--lints&lt;/code&gt; flag for trying out new lint settings, and the &lt;code&gt;.flowconfig&lt;/code&gt; for stable project-wide settings.</source>
          <target state="translated">&lt;code&gt;flowlint&lt;/code&gt; 注释中的Lint设置具有最高优先级，其后是 &lt;code&gt;--lints&lt;/code&gt; 标志中的lint规则，其后是 &lt;code&gt;.flowconfig&lt;/code&gt; 。此顺序允许您将 &lt;code&gt;flowlint&lt;/code&gt; 注释用于细粒度的 &lt;code&gt;--lints&lt;/code&gt; 控制，-- lints标志用于尝试新的掉毛设置，以及 &lt;code&gt;.flowconfig&lt;/code&gt; 用于稳定的项目范围设置。</target>
        </trans-unit>
        <trans-unit id="b5dc277b08ab0a076088a55936d6bb1b36b56986" translate="yes" xml:space="preserve">
          <source>Linter-Flow</source>
          <target state="translated">Linter-Flow</target>
        </trans-unit>
        <trans-unit id="8740f6b1646315b108f5a7b7630739c109bdee42" translate="yes" xml:space="preserve">
          <source>Linting</source>
          <target state="translated">Linting</target>
        </trans-unit>
        <trans-unit id="0dad7bd175f8f98714812632da5a78ae6486cb98" translate="yes" xml:space="preserve">
          <source>Linting Overview</source>
          <target state="translated">绒毛概述</target>
        </trans-unit>
        <trans-unit id="013e2bb1e1c48cce810f0e9392c090ca8d741740" translate="yes" xml:space="preserve">
          <source>List the lint rules to enable . These are strongly recommended:</source>
          <target state="translated">列出要启用的绒毛规则。强烈建议使用这些规则。</target>
        </trans-unit>
        <trans-unit id="c5f9843abf3eea470a268920f6429a30a79e8c27" translate="yes" xml:space="preserve">
          <source>Literal Types</source>
          <target state="translated">字面类型</target>
        </trans-unit>
        <trans-unit id="fd4663b897abbd9f63aa1fb029df28511b239e0f" translate="yes" xml:space="preserve">
          <source>Look up types under cursor</source>
          <target state="translated">查询光标下的类型</target>
        </trans-unit>
        <trans-unit id="e8ed77b7f356c09433025e5f0c172332bccb8b7b" translate="yes" xml:space="preserve">
          <source>Makes Flow treat &lt;code&gt;require('foo.css')&lt;/code&gt; as if it were &lt;code&gt;require(PROJECT_ROOT + '/CSSFlowStub')&lt;/code&gt;.</source>
          <target state="translated">使Flow将 &lt;code&gt;require('foo.css')&lt;/code&gt; 视为 &lt;code&gt;require(PROJECT_ROOT + '/CSSFlowStub')&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="883a53b7e28c18b0803206061049c59ce3306d06" translate="yes" xml:space="preserve">
          <source>Maybe Types</source>
          <target state="translated">可能类型</target>
        </trans-unit>
        <trans-unit id="78d444312215f80221ea8f50dcd6255ebd40e280" translate="yes" xml:space="preserve">
          <source>Maybe types</source>
          <target state="translated">可能类型</target>
        </trans-unit>
        <trans-unit id="eeab6b1b5730d5897be20e8832d631c14302d02b" translate="yes" xml:space="preserve">
          <source>Maybe types accept the provided type as well as &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. So &lt;code&gt;?number&lt;/code&gt; would mean &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">类型可能接受提供的类型以及 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; 。所以 &lt;code&gt;?number&lt;/code&gt; 表示 &lt;code&gt;number&lt;/code&gt; ， &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a099b97988d9786a09585297079102b85e29a055" translate="yes" xml:space="preserve">
          <source>Maybe types are for places where a value is optional and you can create them by adding a question mark in front of the type such as &lt;code&gt;?string&lt;/code&gt; or &lt;code&gt;?number&lt;/code&gt;.</source>
          <target state="translated">也许类型用于值是可选的地方，您可以通过在类型前面添加问号来创建它们，例如 &lt;code&gt;?string&lt;/code&gt; 或 &lt;code&gt;?number&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0dc501bb2c0dd681d66351ee6c10f4bea3fa6bb6" translate="yes" xml:space="preserve">
          <source>Mixed Types</source>
          <target state="translated">混合型</target>
        </trans-unit>
        <trans-unit id="38694f679fee1c9873abb6f0b39d8682bb35437c" translate="yes" xml:space="preserve">
          <source>Mixing nominal and structural typing</source>
          <target state="translated">混合名义类型和结构类型</target>
        </trans-unit>
        <trans-unit id="a152ec7cc4a239412b5ec07e59dc705597177c82" translate="yes" xml:space="preserve">
          <source>Module Types</source>
          <target state="translated">模块类型</target>
        </trans-unit>
        <trans-unit id="b2b4f329c4371fad34d57ca2c5ac16707d12ff70" translate="yes" xml:space="preserve">
          <source>More complex types like object or classes have more complex structures. They each get their own name even if they sometimes have the same structure overall.</source>
          <target state="translated">更复杂的类型如对象或类有更复杂的结构。它们每个都有自己的名字,即使它们有时在整体上具有相同的结构。</target>
        </trans-unit>
        <trans-unit id="778013c00f70ed72cb3d9f3f32da1db73e971c69" translate="yes" xml:space="preserve">
          <source>More specific inputs &amp;mdash; Bad</source>
          <target state="translated">更具体的输入-错误</target>
        </trans-unit>
        <trans-unit id="5ce86c0f6222882e371b81384532e8ef38f27254" translate="yes" xml:space="preserve">
          <source>More specific outputs &amp;mdash; Good</source>
          <target state="translated">更具体的输出-好</target>
        </trans-unit>
        <trans-unit id="d01518022ba66aff4ed5b2b63c6552251faa6c8d" translate="yes" xml:space="preserve">
          <source>Most editors will likely display all Flow warnings, which is fine for small- to medium-scale projects, or projects with fewer unsuppressed warnings.</source>
          <target state="translated">大多数编辑可能会显示所有的Flow警告,这对于中小规模的项目,或者未被抑制的警告较少的项目来说是没有问题的。</target>
        </trans-unit>
        <trans-unit id="7b059f68400dbd84675bceaefa0fc9dee97bfc09" translate="yes" xml:space="preserve">
          <source>Most of the work that Flow does is comparing types against one another.</source>
          <target state="translated">Flow所做的大部分工作都是对类型进行比较。</target>
        </trans-unit>
        <trans-unit id="865bd2fa28dfb2500c9d6ee7c2537c59e6ebb20a" translate="yes" xml:space="preserve">
          <source>Most people put the &lt;code&gt;.flowconfig&lt;/code&gt; in the root of their project (i.e. next to the &lt;code&gt;package.json&lt;/code&gt;). Some people put all their code in a &lt;code&gt;src/&lt;/code&gt; directory and therefore put the &lt;code&gt;.flowconfig&lt;/code&gt; at &lt;code&gt;src/.flowconfig&lt;/code&gt;.</source>
          <target state="translated">大多数人将 &lt;code&gt;.flowconfig&lt;/code&gt; 放在他们项目的根目录中（即 &lt;code&gt;package.json&lt;/code&gt; 旁边）。有些人将所有代码都放在 &lt;code&gt;src/&lt;/code&gt; 目录中，因此将 &lt;code&gt;.flowconfig&lt;/code&gt; 放在 &lt;code&gt;src/.flowconfig&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="24fb36600e4f5f9c4147c6aae34b2eb550d7c78f" translate="yes" xml:space="preserve">
          <source>Most real JavaScript programs depend on third-party code and not just code immediately under the control of the project. That means a project using Flow may need to reference outside code that either doesn&amp;rsquo;t have type information or doesn&amp;rsquo;t have accurate and/or precise type information. In order to handle this, Flow supports the concept of a &amp;ldquo;library definition&amp;rdquo; (AKA &amp;ldquo;libdef&amp;rdquo;).</source>
          <target state="translated">大多数真正的JavaScript程序都依赖于第三方代码，而不仅仅是依赖于项目控制下的代码。这意味着使用Flow的项目可能需要引用外部代码，这些代码要么没有类型信息，要么没有准确和/或精确的类型信息。为了解决这个问题，Flow支持&amp;ldquo;库定义&amp;rdquo;（AKA&amp;ldquo; libdef&amp;rdquo;）的概念。</target>
        </trans-unit>
        <trans-unit id="3e58f860a0fe4e5d6b003e3170a2f45595516a83" translate="yes" xml:space="preserve">
          <source>Moving on to the next case. What happens if we have a single child, but that child is an array?</source>
          <target state="translated">接着看下一个案例。如果我们有一个单子,但这个子是一个数组,会发生什么?</target>
        </trans-unit>
        <trans-unit id="0eaa6c704d21cdabb114c1eed0d1b20d3c99200e" translate="yes" xml:space="preserve">
          <source>Multiple children may also look like:</source>
          <target state="translated">多个孩子也可能像。</target>
        </trans-unit>
        <trans-unit id="df45cc95bf1aa33f0579b3915c74bbc29792fe71" translate="yes" xml:space="preserve">
          <source>NOTE: Because a given module cannot be both an ES module and a CommonJS module, it is an error to mix &lt;code&gt;declare export [...]&lt;/code&gt; with &lt;code&gt;declare module.exports: ...&lt;/code&gt; in the same &lt;code&gt;declare module&lt;/code&gt; body.</source>
          <target state="translated">注：由于给定的模块不能既是一个ES模块和CommonJS的模块，它是混合错误 &lt;code&gt;declare export [...]&lt;/code&gt; 与 &lt;code&gt;declare module.exports: ...&lt;/code&gt; 在同一 &lt;code&gt;declare module&lt;/code&gt; 的身体。</target>
        </trans-unit>
        <trans-unit id="8fc9d5db4bce8ff6003105d5b34b50810aab147d" translate="yes" xml:space="preserve">
          <source>NOTE: For new code prefer &lt;code&gt;any&lt;/code&gt; or &lt;code&gt;(...args: Array&amp;lt;any&amp;gt;) =&amp;gt; any&lt;/code&gt;. &lt;code&gt;Function&lt;/code&gt; has become an alias to &lt;code&gt;any&lt;/code&gt; and will be deprecated and removed in a future version of Flow.</source>
          <target state="translated">注意：对于新代码，请首选 &lt;code&gt;any&lt;/code&gt; 或 &lt;code&gt;(...args: Array&amp;lt;any&amp;gt;) =&amp;gt; any&lt;/code&gt; 。 &lt;code&gt;Function&lt;/code&gt; 已成为 &lt;code&gt;any&lt;/code&gt; 函数的别名，在Flow的未来版本中将不建议使用并删除它。</target>
        </trans-unit>
        <trans-unit id="a4fc17a7e6e5fe579f60ff1988706b047d7ddb6f" translate="yes" xml:space="preserve">
          <source>NOTE: For new code, prefer &lt;code&gt;any&lt;/code&gt; or &lt;code&gt;{[key:string]:any}&lt;/code&gt;. &lt;code&gt;Object&lt;/code&gt; is an alias to &lt;a href=&quot;../any&quot;&gt;&lt;code&gt;any&lt;/code&gt;&lt;/a&gt; and will be deprecated and removed in a future version of Flow.</source>
          <target state="translated">注意：对于新代码，请使用 &lt;code&gt;any&lt;/code&gt; 或 &lt;code&gt;{[key:string]:any}&lt;/code&gt; 。 &lt;code&gt;Object&lt;/code&gt; 是&lt;a href=&quot;../any&quot;&gt; &lt;code&gt;any&lt;/code&gt; &lt;/a&gt;对象的别名，它将在Flow的未来版本中弃用并删除。</target>
        </trans-unit>
        <trans-unit id="9bcc1eb8d16a0354aa6793057eb9ea662ddca8a2" translate="yes" xml:space="preserve">
          <source>NOTE: The syntax for declarations in a declaration file is the same as we&amp;rsquo;ve seen in &lt;a href=&quot;https://flow.org/en/libdefs/creation&quot;&gt;Creating Library Definitions section&lt;/a&gt;.</source>
          <target state="translated">注意：声明文件中声明的语法与在&amp;ldquo; &lt;a href=&quot;https://flow.org/en/libdefs/creation&quot;&gt;创建库定义&amp;rdquo;部分中&lt;/a&gt;看到的相同。</target>
        </trans-unit>
        <trans-unit id="eee4834f57293f261d87c33868be5aa7425351c9" translate="yes" xml:space="preserve">
          <source>NOTE: Using the &lt;code&gt;/flow-typed&lt;/code&gt; directory for libdefs is a convention that enables Flow to JustWork&amp;trade; out of the box and encourages consistency across projects that use Flow, but it is also possible to explicitly configure Flow to look elsewhere for libdefs using the &lt;a href=&quot;https://flow.org/en/config/libs&quot;&gt;&lt;code&gt;[libs]&lt;/code&gt; section of your &lt;code&gt;.flowconfig&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">注意：为libdefs 使用 &lt;code&gt;/flow-typed&lt;/code&gt; 目录是一种约定，可以使Flow开箱即用，并鼓励使用Flow的项目之间保持一致，但是也可以使用&lt;a href=&quot;https://flow.org/en/config/libs&quot;&gt; &lt;code&gt;[libs]&lt;/code&gt; 你的部分 &lt;code&gt;.flowconfig&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="88f2f30ba49708ae97f8d92b8a8a72e7ddff53df" translate="yes" xml:space="preserve">
          <source>Named Exports</source>
          <target state="translated">已命名的出口</target>
        </trans-unit>
        <trans-unit id="e2dffcc7cffb0debfc5f8d1550386d2bb5e3bffe" translate="yes" xml:space="preserve">
          <source>Neither &lt;code&gt;@flow&lt;/code&gt; nor &lt;code&gt;@noflow&lt;/code&gt; - Parse this file with Flow syntax disallowed and do not typecheck it.</source>
          <target state="translated">&lt;code&gt;@flow&lt;/code&gt; 和 &lt;code&gt;@noflow&lt;/code&gt; 都不-禁止使用Flow语法解析此文件，并且请勿对其进行类型检查。</target>
        </trans-unit>
        <trans-unit id="9ed4452c065a3327032cb7f9b68de94c78e6bf1c" translate="yes" xml:space="preserve">
          <source>Neither will this:</source>
          <target state="translated">也不会这样。</target>
        </trans-unit>
        <trans-unit id="17e8fc5ffc9a8aadcb69cdfea49a7be7e3e01369" translate="yes" xml:space="preserve">
          <source>NeoBundle</source>
          <target state="translated">NeoBundle</target>
        </trans-unit>
        <trans-unit id="cb0c7f1b829e145b81d56e667505ff6ca3313917" translate="yes" xml:space="preserve">
          <source>Never used a type system before or just new to Flow? Let's get you up and running in a few minutes.</source>
          <target state="translated">从未使用过类型系统或只是刚接触Flow?让我们在几分钟内让你学会并运行。</target>
        </trans-unit>
        <trans-unit id="4fa6d9c66b7b5cb1445a7a7985bc5a4c02e4f274" translate="yes" xml:space="preserve">
          <source>Newer versions of the JavaScript standard include a &lt;code&gt;Map&lt;/code&gt; class, but it is still very common to use objects as maps as well. In this use case, an object will likely have properties added to it and retrieved throughout its lifecycle. Furthermore, the property keys may not even be known statically, so writing out a type annotation would not be possible.</source>
          <target state="translated">较新版本的JavaScript标准包含 &lt;code&gt;Map&lt;/code&gt; 类，但是将对象用作地图仍然非常普遍。在这种用例中，对象可能会在其整个生命周期中添加有属性并被检索。此外，属性键甚至可能不是静态已知的，因此不可能写出类型注释。</target>
        </trans-unit>
        <trans-unit id="994a4af6c767d6bce3da94575735bc38736de599" translate="yes" xml:space="preserve">
          <source>Newlines and indentation after newlines are stripped, but watch out for whitespace when using a component with strict types around what children may be.</source>
          <target state="translated">换行和换行后的缩进都会被去除,但当使用一个具有严格类型的组件时,要注意子代周围的空白。</target>
        </trans-unit>
        <trans-unit id="c8b440e127a10dc6c8416450eb227c5047c30c36" translate="yes" xml:space="preserve">
          <source>Next we&amp;rsquo;ll add an else block to our if statement.</source>
          <target state="translated">接下来，我们将else块添加到if语句中。</target>
        </trans-unit>
        <trans-unit id="b08049f81dbbff0f0b72d5c90f11c3c94dbe857a" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll have a different &lt;code&gt;SubClass&lt;/code&gt; that returns a less specific type:</source>
          <target state="translated">接下来，我们将有一个不同的 &lt;code&gt;SubClass&lt;/code&gt; ，它返回一个不太具体的类型：</target>
        </trans-unit>
        <trans-unit id="e898df75dae72ea5a3d9d46d76532d7a85a2015f" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll have a different &lt;code&gt;SubClass&lt;/code&gt; that returns a more specific type:</source>
          <target state="translated">接下来，我们将有一个不同的 &lt;code&gt;SubClass&lt;/code&gt; ，它返回一个更特定的类型：</target>
        </trans-unit>
        <trans-unit id="ad7fad484146f11e6827ddde38d9848a5842febd" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll have another SubClass that accepts a value of a less specific type.</source>
          <target state="translated">接下来，我们将有另一个SubClass接受一个不太具体的类型的值。</target>
        </trans-unit>
        <trans-unit id="03fcc5e78375c539a4046df66cd614afc3b96f5d" translate="yes" xml:space="preserve">
          <source>Nominal &amp;amp; Structural Typing</source>
          <target state="translated">标称和结构性打字</target>
        </trans-unit>
        <trans-unit id="e8d7ae8d2ca23e63934856a596b9968693856079" translate="yes" xml:space="preserve">
          <source>Nominal typing</source>
          <target state="translated">名义打字</target>
        </trans-unit>
        <trans-unit id="7b7e96032e3f1e6663bd1bdc30dc00a06098260e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$Diff&amp;lt;A, B&amp;gt;&lt;/code&gt; will error if the object you are removing properties from does not have the property being removed, i.e. if &lt;code&gt;B&lt;/code&gt; has a key that doesn&amp;rsquo;t exist in &lt;code&gt;A&lt;/code&gt;:</source>
          <target state="translated">请注意，如果要从中删除属性的对象没有要删除的属性，即 &lt;code&gt;$Diff&amp;lt;A, B&amp;gt;&lt;/code&gt; &lt;code&gt;B&lt;/code&gt; 的键在 &lt;code&gt;A&lt;/code&gt; 中不存在，则$ Diff &amp;lt;A，B&amp;gt;将出错：</target>
        </trans-unit>
        <trans-unit id="3333e700ed17ae336d1331038ab7c3ede13160e7" translate="yes" xml:space="preserve">
          <source>Note that an array of type &lt;code&gt;$ReadOnlyArray&amp;lt;T&amp;gt;&lt;/code&gt; can still have mutable &lt;em&gt;elements&lt;/em&gt;:</source>
          <target state="translated">请注意，类型 &lt;code&gt;$ReadOnlyArray&amp;lt;T&amp;gt;&lt;/code&gt; 的数组仍可以具有可变&lt;em&gt;元素&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="8d8fdec593b4fbb6674593ce345b2fc98b244bc1" translate="yes" xml:space="preserve">
          <source>Note that if you annotate your generic with variance sigils then Flow will check to make sure those types only appear in positions that make sense for that variance sigil. For example, you cannot declare a generic type parameter to behave covariantly and use it in a contravariant position:</source>
          <target state="translated">请注意,如果你用变量符号注释你的泛型,那么Flow会检查确保这些类型只出现在对该变量符号有意义的位置。例如,你不能声明一个泛型类型参数是共变的,而在一个反变的位置使用它。</target>
        </trans-unit>
        <trans-unit id="d1ee3faa3af2380d9898eaa494128a6edeb62a34" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;.flow&lt;/code&gt; extension applies both to &lt;code&gt;.js&lt;/code&gt; files as well as &lt;code&gt;.json&lt;/code&gt; ones. The corresponding declaration files have extensions &lt;code&gt;.js.flow&lt;/code&gt; and &lt;code&gt;.json.flow&lt;/code&gt;, respectively.</source>
          <target state="translated">请注意， &lt;code&gt;.flow&lt;/code&gt; 扩展既适用于 &lt;code&gt;.js&lt;/code&gt; 文件以及 &lt;code&gt;.json&lt;/code&gt; 的。相应的声明文件分别具有扩展名 &lt;code&gt;.js.flow&lt;/code&gt; 和 &lt;code&gt;.json.flow&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="815e2ec516671c1e95e246519c4812a2e63caff8" translate="yes" xml:space="preserve">
          <source>Note that this lint does not trigger when we know a condition is always &lt;code&gt;false&lt;/code&gt;. It is a common idiom to use &lt;code&gt;invariant()&lt;/code&gt; or &lt;code&gt;invariant(false, ...)&lt;/code&gt; to throw in code that should be unreachable.</source>
          <target state="translated">请注意，当我们知道条件始终为 &lt;code&gt;false&lt;/code&gt; 时，此棉绒不会触发。使用 &lt;code&gt;invariant()&lt;/code&gt; 或 &lt;code&gt;invariant(false, ...)&lt;/code&gt; 来抛出应该无法访问的代码是一种常见的习惯。</target>
        </trans-unit>
        <trans-unit id="97abdd3aca893857a9659b8d5dc58e61b924f0e2" translate="yes" xml:space="preserve">
          <source>Note that when you have a value with a bound generic type, you can&amp;rsquo;t use it as if it were a more specific type.</source>
          <target state="translated">请注意，当您的值具有绑定的泛型类型时，就不能像使用更具体的类型一样使用它。</target>
        </trans-unit>
        <trans-unit id="3fa26fe5509b9dafc96225032b57c997a328ed0e" translate="yes" xml:space="preserve">
          <source>Note that you can also declare other things inside the body of the &lt;code&gt;declare module&lt;/code&gt;, and those things will be scoped to the body of the &lt;code&gt;declare module&lt;/code&gt; &amp;ndash; &lt;strong&gt;but they will not be exported from the module&lt;/strong&gt;:</source>
          <target state="translated">请注意，您也可以声明其他东西的体内 &lt;code&gt;declare module&lt;/code&gt; ，而这些东西将范围限定为主体 &lt;code&gt;declare module&lt;/code&gt; - &lt;strong&gt;但他们不会从模块导出&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="54bffd8f0bade33130c198fcfbb3d3928227fba5" translate="yes" xml:space="preserve">
          <source>Note that you can also declare other things inside the body of the &lt;code&gt;declare module&lt;/code&gt;, and those things will be scoped to the body of the &lt;code&gt;declare module&lt;/code&gt;, &lt;strong&gt;but they will not be exported from the module&lt;/strong&gt;:</source>
          <target state="translated">请注意，您还可以在 &lt;code&gt;declare module&lt;/code&gt; 的主体内声明其他内容，这些内容的作用域将是 &lt;code&gt;declare module&lt;/code&gt; 的主体，&lt;strong&gt;但它们不会从模块中导出&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="e2b8e8bae5815faacd0ccd12e9961c3379f24ded" translate="yes" xml:space="preserve">
          <source>Note the use of parentheses around the arrow types. These are necessary to override the precedence of the &amp;ldquo;arrow&amp;rdquo; constructor over the intersection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3611dae21abf03408abc2acf059be7215eea834" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;$ReadOnly&lt;/code&gt; is only for making read-only &lt;em&gt;object&lt;/em&gt; types. See the Array docs for how to &lt;a href=&quot;../arrays#toc-readonlyarray&quot;&gt;type read-only arrays with &lt;code&gt;$ReadOnlyArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">注意： &lt;code&gt;$ReadOnly&lt;/code&gt; 仅用于制作只读&lt;em&gt;对象&lt;/em&gt;类型。有关如何&lt;a href=&quot;../arrays#toc-readonlyarray&quot;&gt;使用 &lt;code&gt;$ReadOnlyArray&lt;/code&gt; &lt;/a&gt;键入只读数组的信息，请参见Array docs 。</target>
        </trans-unit>
        <trans-unit id="d6be40aaa6de71f620ef0689323825354900d1e8" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;$Shape&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; equivalent to &lt;code&gt;T&lt;/code&gt; with all its fields marked as optional. In particular, Flow unsoundly allows &lt;code&gt;$Shape&amp;lt;T&amp;gt;&lt;/code&gt; to be used as a &lt;code&gt;T&lt;/code&gt; in several contexts. For example in</source>
          <target state="translated">注： &lt;code&gt;$Shape&amp;lt;T&amp;gt;&lt;/code&gt; 是&lt;strong&gt;不是&lt;/strong&gt;等同于 &lt;code&gt;T&lt;/code&gt; 与所有的字段标记为可选。特别是，Flow异常允许 &lt;code&gt;$Shape&amp;lt;T&amp;gt;&lt;/code&gt; 在多个上下文中用作 &lt;code&gt;T&lt;/code&gt; 。例如在</target>
        </trans-unit>
        <trans-unit id="910cb2c37e2ad8674f98e665bc56e5aeb4d5a554" translate="yes" xml:space="preserve">
          <source>Note: If you add a type annotation to a rest parameter, it must always explicitly be an &lt;code&gt;Array&lt;/code&gt; type.</source>
          <target state="translated">注意：如果将类型注释添加到rest参数，则该注释必须始终显式为 &lt;code&gt;Array&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="bc76abb2875c7659b6d7f4f248528d58f58a9924" translate="yes" xml:space="preserve">
          <source>Notice the types added to the parameter of the function along with a return type at the end of the function. You might be able to tell from looking at this code that there is an error in the return type since the function can also return an &lt;code&gt;int&lt;/code&gt;. However, you do not need to visually inspect the code since the Flow background process will be able to catch this error for you when you &lt;a href=&quot;#toc-check-your-code&quot;&gt;check your code&lt;/a&gt;.</source>
          <target state="translated">请注意，添加到函数参数的类型以及函数末尾的返回类型。通过查看此代码，您也许可以看出返回类型有错误，因为该函数还可以返回 &lt;code&gt;int&lt;/code&gt; 。但是，你并不需要目视检查代码，因为流动后台进程将能够赶上这个错误时，你&lt;a href=&quot;#toc-check-your-code&quot;&gt;检查你的代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c0d7a1a5c5c6adb2044345b94128cb7b17d10e58" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;flow&lt;/code&gt; will include a directory outside the &lt;code&gt;.flowconfig&lt;/code&gt; path in its check, ignore the &lt;code&gt;build&lt;/code&gt; directory and use the declarations in &lt;code&gt;lib&lt;/code&gt;.</source>
          <target state="translated">现在， &lt;code&gt;flow&lt;/code&gt; 将在检查中包括 &lt;code&gt;.flowconfig&lt;/code&gt; 路径之外的目录，忽略 &lt;code&gt;build&lt;/code&gt; 目录并使用 &lt;code&gt;lib&lt;/code&gt; 中的声明。</target>
        </trans-unit>
        <trans-unit id="a044c31320a1c390eff0c847424350f19070f44e" translate="yes" xml:space="preserve">
          <source>Now Flow will complain when you try to write to any of these properties.</source>
          <target state="translated">现在,当你试图向这些属性写入时,Flow会抱怨。</target>
        </trans-unit>
        <trans-unit id="7b7f5bac6c35b92b712c9bf97b054fa867c2ca01" translate="yes" xml:space="preserve">
          <source>Now if you try to use &lt;code&gt;&amp;lt;MyComponent&amp;gt;&lt;/code&gt; with a string for &lt;code&gt;foo&lt;/code&gt; instead of a number you will get an error.</source>
          <target state="translated">现在，如果尝试将 &lt;code&gt;&amp;lt;MyComponent&amp;gt;&lt;/code&gt; 与 &lt;code&gt;foo&lt;/code&gt; 的字符串（而不是数字）一起使用，则会出现错误。</target>
        </trans-unit>
        <trans-unit id="5b61c8302b29c6822902031839e12485c087afa1" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s see an example of the first case documented above. Suppose we have the following code in a file &lt;code&gt;src/LookBeforeYouLeap.js&lt;/code&gt;:</source>
          <target state="translated">现在，让我们看一下上面记录的第一种情况的示例。假设我们在文件 &lt;code&gt;src/LookBeforeYouLeap.js&lt;/code&gt; 中具有以下代码：</target>
        </trans-unit>
        <trans-unit id="fb52c53f4f22a6c6d90afe94da1c5cde383f8510" translate="yes" xml:space="preserve">
          <source>Now let's see how you would take this intuition and type the children of various React components.</source>
          <target state="translated">现在让我们来看看你将如何利用这种直觉,对各种React组件的子女进行类型化。</target>
        </trans-unit>
        <trans-unit id="c47667d674268b42d8bc54bea9304a308b2c873f" translate="yes" xml:space="preserve">
          <source>Now suppose that instead of a boolean, we have a numerical value representing, say, the number of comments on a post. We want to display a count of the comments, unless there are no comments. We might naively try to do something similar to the boolean case:</source>
          <target state="translated">现在假设我们有一个数值来代替布尔值,比如说,一个帖子的评论数。我们希望显示评论的数量,除非没有评论。我们可能会天真地尝试做一些类似布尔值的情况。</target>
        </trans-unit>
        <trans-unit id="130ecc6b759fae2f2cbba2aade21537572c9ebf2" translate="yes" xml:space="preserve">
          <source>Now that all the setup and initialization is complete, you are ready to write actual Flow code. For each file that you have flagged with &lt;code&gt;// @flow&lt;/code&gt;, you now have the full power of Flow and its type-checking available to you. Here is an example Flow file:</source>
          <target state="translated">既然所有的设置和初始化都已经完成，您就可以编写实际的Flow代码了。现在，对于使用 &lt;code&gt;// @flow&lt;/code&gt; 标记的每个文件，您都可以使用Flow及其类型检查的全部功能。这是一个示例流文件：</target>
        </trans-unit>
        <trans-unit id="8a0aa492d72ba5e5ee4e490208cd56c9c6fd8b5b" translate="yes" xml:space="preserve">
          <source>Now type inference can keep working for &lt;code&gt;typeof obj&lt;/code&gt; which returns the expected shape of the object.</source>
          <target state="translated">现在，类型推断可以为 &lt;code&gt;typeof obj&lt;/code&gt; 继续工作，它返回对象的预期形状。</target>
        </trans-unit>
        <trans-unit id="18e7605734b62fc321cd934a156de7bc5fd3f54f" translate="yes" xml:space="preserve">
          <source>Now wherever we use &lt;code&gt;this.props&lt;/code&gt; in our React component Flow will treat it as the &lt;code&gt;Props&lt;/code&gt; type we defined.</source>
          <target state="translated">现在，无论我们在React组件Flow中使用 &lt;code&gt;this.props&lt;/code&gt; 的何处，都将其视为我们定义的 &lt;code&gt;Props&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="cba47b2f9c45e1dcfda8b52779b4d36ece5cf6c4" translate="yes" xml:space="preserve">
          <source>Now you&amp;rsquo;ll get a warning from Flow if you try to use numbers.</source>
          <target state="translated">现在，如果您尝试使用数字，将会收到Flow的警告。</target>
        </trans-unit>
        <trans-unit id="abd74ca854ddc164ed4dd85269784a3b28f553e8" translate="yes" xml:space="preserve">
          <source>Now your code will not leak &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">现在，您的代码将不会泄漏 &lt;code&gt;any&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d733ad521afc4421b4a66b432128c9bcdc2b5eec" translate="yes" xml:space="preserve">
          <source>Now, if you pass two values then &lt;code&gt;props.children&lt;/code&gt; will be an array. Specifically in this case &lt;code&gt;props.children&lt;/code&gt; will be &lt;code&gt;[1, 2]&lt;/code&gt;.</source>
          <target state="translated">现在，如果您传递两个值，则 &lt;code&gt;props.children&lt;/code&gt; 将是一个数组。具体来说，在这种情况下 &lt;code&gt;props.children&lt;/code&gt; 将是 &lt;code&gt;[1, 2]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="be6e2a0e2bd898f29d9210b231319127fd00f218" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s Flowify the component we just wrote:</source>
          <target state="translated">现在，让我们流化刚刚编写的组件：</target>
        </trans-unit>
        <trans-unit id="c7db6f471fb8404ecff0960ed4244da4532a2c7e" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s walk through different definitions of &lt;code&gt;method()&lt;/code&gt; in a couple different &lt;em&gt;subclasses&lt;/em&gt;.</source>
          <target state="translated">现在，让我们在几个不同的&lt;em&gt;子类中&lt;/em&gt;遍历 &lt;code&gt;method()&lt;/code&gt; 的不同定义。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3fe7f794fc68b1034d0e3f564bf32dd7ffd089d7" translate="yes" xml:space="preserve">
          <source>Nuclide</source>
          <target state="translated">Nuclide</target>
        </trans-unit>
        <trans-unit id="63c0e833d1f670a8069d40968493548f0265ef94" translate="yes" xml:space="preserve">
          <source>Nuclide also comes with many other features including support for remote projects, hack, mercurial etc.</source>
          <target state="translated">Nuclide还带有很多其他功能,包括支持远程项目、hack、mercurial等。</target>
        </trans-unit>
        <trans-unit id="9e0b7a63508302d9d09c38742d062288dc1823d2" translate="yes" xml:space="preserve">
          <source>Nuclide v0.243.0 onward has support for working with Flow to limit the reported warnings to the working fileset. This allows Nuclide and Flow to work efficiently on large codebases with tens of thousands of unsuppressed warnings.</source>
          <target state="translated">Nuclide v0.243.0以后的版本支持与Flow一起工作,将报告的警告限制在工作文件集内。这使得Nuclide和Flow能够有效地处理有数万个未抑制警告的大型代码库。</target>
        </trans-unit>
        <trans-unit id="7e53821f70ae16079c4a6a64c52a91fae645bc5f" translate="yes" xml:space="preserve">
          <source>Numbers</source>
          <target state="translated">Numbers</target>
        </trans-unit>
        <trans-unit id="335e5e44a812438f93ba78ec1988eb2972404cb9" translate="yes" xml:space="preserve">
          <source>Numbers: like &lt;code&gt;42&lt;/code&gt; or &lt;code&gt;3.14&lt;/code&gt;</source>
          <target state="translated">数字：例如 &lt;code&gt;42&lt;/code&gt; 或 &lt;code&gt;3.14&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cbf147d445453a6660add525598d56066b954b1c" translate="yes" xml:space="preserve">
          <source>Object Types</source>
          <target state="translated">对象类型</target>
        </trans-unit>
        <trans-unit id="9ed92c18b4e477381c353e8136dbc9d058b63386" translate="yes" xml:space="preserve">
          <source>Object type inference</source>
          <target state="translated">对象类型推断</target>
        </trans-unit>
        <trans-unit id="0b9a72ed85754757a03a424a4f413c85cc295a74" translate="yes" xml:space="preserve">
          <source>Object type syntax</source>
          <target state="translated">对象类型语法</target>
        </trans-unit>
        <trans-unit id="cdea7c16abb43506671d0750b87a9ae17eb2398a" translate="yes" xml:space="preserve">
          <source>Object types can have optional properties where a question mark &lt;code&gt;?&lt;/code&gt; comes after the property name.</source>
          <target state="translated">对象类型可以具有可选属性，其中问号 &lt;code&gt;?&lt;/code&gt; 在属性名称之后。</target>
        </trans-unit>
        <trans-unit id="f85c54a239ca0dd9865eaee3f09163bc064e2fde" translate="yes" xml:space="preserve">
          <source>Object types try to match the syntax for objects in JavaScript as much as possible. Using curly braces &lt;code&gt;{}&lt;/code&gt; and name-value pairs using a colon &lt;code&gt;:&lt;/code&gt; split by commas &lt;code&gt;,&lt;/code&gt;.</source>
          <target state="translated">对象类型尝试尽可能匹配JavaScript中对象的语法。使用大括号 &lt;code&gt;{}&lt;/code&gt; 和冒号的名称/值对 &lt;code&gt;:&lt;/code&gt; 用逗号分隔 &lt;code&gt;,&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1354578aed5c555826e657109cf8e1a80a7db3d0" translate="yes" xml:space="preserve">
          <source>Objects are structurally typed</source>
          <target state="translated">对象的结构类型是</target>
        </trans-unit>
        <trans-unit id="9ab5bd450c651a40acb31c6d2173d2d8a317f03b" translate="yes" xml:space="preserve">
          <source>Objects as maps</source>
          <target state="translated">物体作为地图</target>
        </trans-unit>
        <trans-unit id="01a1617fcbeab1f400211a1e0e3d5541707fdd66" translate="yes" xml:space="preserve">
          <source>Objects can be used in many different ways in JavaScript. There are a number of different ways to type them in order to support all the different use cases.</source>
          <target state="translated">在JavaScript中,对象可以以许多不同的方式使用。为了支持所有不同的用例,有许多不同的方式来类型它们。</target>
        </trans-unit>
        <trans-unit id="a4eb44d5d295882356db532a105f60a76be3916a" translate="yes" xml:space="preserve">
          <source>Obsolete. Set this to &lt;code&gt;true&lt;/code&gt; to always strip the root directory from file paths in error messages when using &lt;code&gt;--json&lt;/code&gt;, &lt;code&gt;--from emacs&lt;/code&gt;, and &lt;code&gt;--from vim&lt;/code&gt;. Do not use this option. Instead, pass the command line flag &lt;code&gt;--strip-root&lt;/code&gt;.</source>
          <target state="translated">过时的 设置为 &lt;code&gt;true&lt;/code&gt; 可以在使用 &lt;code&gt;--json&lt;/code&gt; ， &lt;code&gt;--from emacs&lt;/code&gt; from emacs和 &lt;code&gt;--from vim&lt;/code&gt; 时始终从错误消息中的文件路径中删除根目录。不要使用此选项。而是传递命令行标志 &lt;code&gt;--strip-root&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd9b17a8cc9cfeab14950ff409781477ba7078b9" translate="yes" xml:space="preserve">
          <source>Often third-party libraries have broken type definitions or have type definitions only compatible with a certain version of Flow. In those cases it may be useful to use type information from the third-party libraries without typechecking their contents.</source>
          <target state="translated">通常,第三方库的类型定义是错误的,或者其类型定义只与某个版本的Flow兼容。在这些情况下,使用第三方库的类型信息而不对其内容进行类型检查可能是有用的。</target>
        </trans-unit>
        <trans-unit id="adacc74ca82788d5eac49de1a84a330f45c46c00" translate="yes" xml:space="preserve">
          <source>Often, third-party code is organized in terms of modules rather than globals. To write a libdef that declares the presence of a module you&amp;rsquo;ll want to use the &lt;code&gt;declare module&lt;/code&gt; syntax:</source>
          <target state="translated">通常，第三方代码是根据模块而不是全局变量组织的。要编写一个声明模块存在的libdef，您将要使用 &lt;code&gt;declare module&lt;/code&gt; 语法：</target>
        </trans-unit>
        <trans-unit id="b24bbeccf5137f66b11ed50187cc6eafef3213fa" translate="yes" xml:space="preserve">
          <source>On the flip-side, &lt;strong&gt;&lt;em&gt;completeness&lt;/em&gt;&lt;/strong&gt; is the ability for a type checker to only ever catch errors that &lt;em&gt;would&lt;/em&gt; happen at runtime. This comes at the cost of sometimes missing errors that will happen at runtime.</source>
          <target state="translated">在翻盖侧，&lt;strong&gt;&lt;em&gt;完整性&lt;/em&gt;&lt;/strong&gt;是一个类型检查只能赶上错误的能力&lt;em&gt;将&lt;/em&gt;发生在运行时。这是以有时会丢失运行时发生的错误为代价的。</target>
        </trans-unit>
        <trans-unit id="d37f56efe0e6015ca80498e8ea761c659a342927" translate="yes" xml:space="preserve">
          <source>Once all the dependencies of a &lt;code&gt;@flow strict-local&lt;/code&gt; file are strict, the file can be upgraded to a &lt;code&gt;@flow strict&lt;/code&gt; file. A &lt;code&gt;@flow strict&lt;/code&gt; file cannot depend on a &lt;code&gt;@flow strict-local&lt;/code&gt; file as this would break the &lt;code&gt;nonstrict-import&lt;/code&gt; rule.</source>
          <target state="translated">一旦 &lt;code&gt;@flow strict-local&lt;/code&gt; 文件的所有依赖关系都严格，则可以将文件升级为 &lt;code&gt;@flow strict&lt;/code&gt; 文件。一个 &lt;code&gt;@flow strict&lt;/code&gt; 文件可以不依赖于一个 &lt;code&gt;@flow strict-local&lt;/code&gt; 文件，因为这将打破 &lt;code&gt;nonstrict-import&lt;/code&gt; 规则。</target>
        </trans-unit>
        <trans-unit id="2e418e3cfbf0c00ec225eae651536e321fd3bd30" translate="yes" xml:space="preserve">
          <source>Once you have &lt;a href=&quot;https://flow.org/en/install/&quot;&gt;installed&lt;/a&gt; Flow, you will want to get a feel of how to use Flow at the most basic level. For most new Flow projects, you will follow this general pattern:</source>
          <target state="translated">一旦&lt;a href=&quot;https://flow.org/en/install/&quot;&gt;安装了&lt;/a&gt; Flow，您将希望了解如何在最基本的级别上使用Flow。对于大多数新的Flow项目，您将遵循以下一般模式：</target>
        </trans-unit>
        <trans-unit id="6ccb0b14eaa9c14dee4efd8a3cd89afe87b6ccb4" translate="yes" xml:space="preserve">
          <source>Once you have Babel setup, install &lt;code&gt;@babel/preset-flow&lt;/code&gt; with either &lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt; or &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;.</source>
          <target state="translated">完成Babel设置后，使用&lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt;或&lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;安装 &lt;code&gt;@babel/preset-flow&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5fea1da9e23ea1d202b2729a702a3f535801fdd" translate="yes" xml:space="preserve">
          <source>One of the main contributors of Flow&amp;rsquo;s precision is path-sensitivity: the way types interact with runtime tests. The essence of many JavaScript idioms is to put together ad hoc sets of runtime values and to take them apart with shallow, structural (in)equality checks. In Flow, the set of runtime values that a variable may contain is described by its type, and a runtime test on that variable refines the type to a smaller set. This ability turns out to be quite powerful and general in practice.</source>
          <target state="translated">Flow精度的主要贡献者之一是路径敏感性：类型与运行时测试交互的方式。许多JavaScript习惯用法的本质是将特定的运行时值集合放在一起，并通过浅层的，结构性的（不平等的）检查将它们分开。在Flow中，变量可能包含的运行时值集由其类型描述，并且对该变量的运行时测试会将类型优化为较小的集。事实证明，此功能非常强大且通用。</target>
        </trans-unit>
        <trans-unit id="c922fe63b25cd49cec8888b01a561a5582a84a58" translate="yes" xml:space="preserve">
          <source>Only allowing a specific element type as children.</source>
          <target state="translated">只允许特定的元素类型作为子女。</target>
        </trans-unit>
        <trans-unit id="552faaf2aafbe53d107876ccee0f0634f915c3e5" translate="yes" xml:space="preserve">
          <source>Only one background process will be running at any given time, so if you run &lt;code&gt;flow status&lt;/code&gt; multiple times, it will use the same process.</source>
          <target state="translated">在任何给定时间都将只运行一个后台进程，因此，如果您多次运行 &lt;code&gt;flow status&lt;/code&gt; ，它将使用同一进程。</target>
        </trans-unit>
        <trans-unit id="e4a45cacdd8d7e9f0ebca1ec7bc3fb1f33c78855" translate="yes" xml:space="preserve">
          <source>Opaque Type Alias Syntax</source>
          <target state="translated">不透明类型别名语法</target>
        </trans-unit>
        <trans-unit id="65ea8514201b92749598f548009f0a4afe84c188" translate="yes" xml:space="preserve">
          <source>Opaque Type Alias Type Checking</source>
          <target state="translated">不透明类型别名类型检查</target>
        </trans-unit>
        <trans-unit id="961bf1b4717073b1bc912e5a6e9062ea360301f6" translate="yes" xml:space="preserve">
          <source>Opaque Type Aliases</source>
          <target state="translated">不透明别名类型</target>
        </trans-unit>
        <trans-unit id="6077a6482ea571ceaa9f7539cf7e9cbf318e56ce" translate="yes" xml:space="preserve">
          <source>Opaque type aliases are created using the words &lt;code&gt;opaque type&lt;/code&gt; followed by its name, an equals sign &lt;code&gt;=&lt;/code&gt;, and a type definition.</source>
          <target state="translated">不透明类型别名是使用单词 &lt;code&gt;opaque type&lt;/code&gt; ，其名称，等号 &lt;code&gt;=&lt;/code&gt; 和类型定义创建的。</target>
        </trans-unit>
        <trans-unit id="ee9ac0643d45dfbbd750de612f57c1963700d825" translate="yes" xml:space="preserve">
          <source>Opaque type aliases are type aliases that do not allow access to their underlying type outside of the file in which they are defined.</source>
          <target state="translated">不透明类型别名是类型别名,不允许访问它们定义的文件之外的底层类型。</target>
        </trans-unit>
        <trans-unit id="5f911be9170f1811fca0f4efce9cc2904081c303" translate="yes" xml:space="preserve">
          <source>Opaque type aliases can also have their own &lt;a href=&quot;../generics&quot;&gt;generics&lt;/a&gt;, and they work exactly as generics do in regular &lt;a href=&quot;../aliases#toc-type-alias-generics&quot;&gt;type aliases&lt;/a&gt;</source>
          <target state="translated">不透明类型别名也可以有自己的&lt;a href=&quot;../generics&quot;&gt;泛型&lt;/a&gt;，它们的工作方式与常规&lt;a href=&quot;../aliases#toc-type-alias-generics&quot;&gt;类型别名中的&lt;/a&gt;泛型完全一样</target>
        </trans-unit>
        <trans-unit id="a9f3700878b30b619fa2c5143a86c38508c7ca4b" translate="yes" xml:space="preserve">
          <source>Opaque type aliases, like regular type aliases, may be used anywhere a type can be used.</source>
          <target state="translated">不透明类型别名,就像普通类型别名一样,可以在任何可以使用类型的地方使用。</target>
        </trans-unit>
        <trans-unit id="ddd2d4ec70a68949d8c75dd5fb57b7fa281e8e27" translate="yes" xml:space="preserve">
          <source>Optional Parameters</source>
          <target state="translated">可选参数</target>
        </trans-unit>
        <trans-unit id="6eb1e4ba2d4c68b05e65e2f8b787201061244dd0" translate="yes" xml:space="preserve">
          <source>Optional function parameters</source>
          <target state="translated">可选功能参数</target>
        </trans-unit>
        <trans-unit id="b20d0cae17674ab970acb532453aaf71edae6a61" translate="yes" xml:space="preserve">
          <source>Optional object properties</source>
          <target state="translated">可选对象属性</target>
        </trans-unit>
        <trans-unit id="2d932cfadb898020aa3d7c79ba0029b42cc035ac" translate="yes" xml:space="preserve">
          <source>Optional object type properties</source>
          <target state="translated">可选对象类型属性</target>
        </trans-unit>
        <trans-unit id="7d05768bc14089a0cc0ad2e54b12a94fab4dbaf6" translate="yes" xml:space="preserve">
          <source>Optional parameters will accept missing, &lt;code&gt;undefined&lt;/code&gt;, or matching types. But they will not accept &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">可选参数将接受缺少， &lt;code&gt;undefined&lt;/code&gt; 或匹配的类型。但是他们不会接受 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5037e7b0dd30d22a12232b46317dc9e63f9ba600" translate="yes" xml:space="preserve">
          <source>Or as constructed wrapper objects.</source>
          <target state="translated">或者作为构造的包装对象。</target>
        </trans-unit>
        <trans-unit id="f26ec27bdcca139b8bc25d769f1290e1e51a3bf0" translate="yes" xml:space="preserve">
          <source>Or you could be accessing an element that does not exist if it is a &amp;ldquo;sparse array&amp;rdquo;.</source>
          <target state="translated">或者，您可能正在访问一个不存在的元素（如果它是&amp;ldquo;稀疏数组&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="e404be6e42270a506b9fda4079e3cbb1faf93ee5" translate="yes" xml:space="preserve">
          <source>Or you could refine on the shape of objects.</source>
          <target state="translated">或者你可以对物体的形状进行细化。</target>
        </trans-unit>
        <trans-unit id="36ccd6fa5b54b074d48b3c318b7724049b209ff5" translate="yes" xml:space="preserve">
          <source>Other Editors</source>
          <target state="translated">其他编辑</target>
        </trans-unit>
        <trans-unit id="b01d9e5fc57d8be7b4d4cfaf9d867219b88b9c98" translate="yes" xml:space="preserve">
          <source>Other extensions that you may try are:</source>
          <target state="translated">你可以尝试的其他扩展有:</target>
        </trans-unit>
        <trans-unit id="55d5eb5f68ae162a0c0275477fbf7fd7aa314ea9" translate="yes" xml:space="preserve">
          <source>Other type systems will favor completeness instead, only reporting real errors in favor of possibly missing errors. Unit/Integration testing is an extreme form of this approach. Often this comes at the cost of missing the errors that are the most complicated to find, leaving that part up to the developer.</source>
          <target state="translated">其他类型的系统反而会偏重于完整性,只报告真实的错误,而偏重于可能遗漏的错误。单元/集成测试是这种方法的一种极端形式。通常这是以遗漏那些最复杂的错误为代价的,把这部分工作留给开发人员。</target>
        </trans-unit>
        <trans-unit id="8d7bf5bf136e81f9388c1f4eca050d6d94e965d7" translate="yes" xml:space="preserve">
          <source>Others</source>
          <target state="translated">Others</target>
        </trans-unit>
        <trans-unit id="d10a332d2514aa48380a681c92c805bab5fc2c39" translate="yes" xml:space="preserve">
          <source>Our &lt;a href=&quot;../types&quot;&gt;types reference&lt;/a&gt; has more information about both &lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt;&lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../types#toc-react-element&quot;&gt;&lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">我们的&lt;a href=&quot;../types&quot;&gt;类型参考中&lt;/a&gt;有关于&lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt; &lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../types#toc-react-element&quot;&gt; &lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt; &lt;/a&gt;更多信息。</target>
        </trans-unit>
        <trans-unit id="c7ec91907688dba7293db664f96aa7520dd5050d" translate="yes" xml:space="preserve">
          <source>Our first case is an element with no children:</source>
          <target state="translated">我们的第一个案例是一个没有孩子的元素。</target>
        </trans-unit>
        <trans-unit id="3e4d85a254d099e6caabb9070a8f1a5835e74184" translate="yes" xml:space="preserve">
          <source>Outside the Defining File</source>
          <target state="translated">定义文件之外</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="2bfd0b733d61ec42886bc0c31e24e1f1a0d24fdf" translate="yes" xml:space="preserve">
          <source>Parameterized generics</source>
          <target state="translated">参数化通用</target>
        </trans-unit>
        <trans-unit id="bc7025db05fe11cfb78fa0f8ede0665290fcb863" translate="yes" xml:space="preserve">
          <source>Parts of the source that are visible from a file&amp;rsquo;s exports need to be annotated unless their type can be trivially inferred (e.g. the exported expression is a numeric literal). This is a requirement for types-first mode to function properly. Failure to properly annotate exports raise &lt;code&gt;signature-verfication-failure&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aa250c187d7bae549c808c9085514424d802eea" translate="yes" xml:space="preserve">
          <source>Pathogen</source>
          <target state="translated">Pathogen</target>
        </trans-unit>
        <trans-unit id="3dd4db5ce7ea626f59e720f0c27096a22aa1ecd0" translate="yes" xml:space="preserve">
          <source>Precision</source>
          <target state="translated">Precision</target>
        </trans-unit>
        <trans-unit id="8a51f97f15da4dd4d5a94fab1a4108cee0b5e1d4" translate="yes" xml:space="preserve">
          <source>Precision also has other desirable consequences. When types are trustworthy, developers tend to rely on them to structure their code and reason about it, leading to cleaner and more efficient code with fewer dynamic checks. When type errors are trustworthy, developers can focus on what their code does rather than thinking about how to rewrite their code to satisfy (or work around) the type system.</source>
          <target state="translated">精确性还具有其他理想的后果。当类型值得信赖时,开发人员倾向于依赖类型来构建他们的代码并对其进行推理,从而使代码更干净、更高效,动态检查更少。当类型错误值得信赖时,开发人员可以专注于他们的代码做什么,而不是考虑如何重写他们的代码以满足(或绕过)类型系统。</target>
        </trans-unit>
        <trans-unit id="83590fe5defcf4d8a2747e7bff66e91f7879b09e" translate="yes" xml:space="preserve">
          <source>Precision usually comes at the cost of speed. But while a precise analysis is desirable, most of the appeal of JavaScript is lost if we slow down the edit-refresh cycle by making developers wait as we compile.</source>
          <target state="translated">精确通常是以速度为代价的。但是,虽然精确的分析是可取的,但如果我们通过让开发人员在编译时等待来减慢编辑-刷新周期,那么JavaScript的大部分吸引力就会丧失。</target>
        </trans-unit>
        <trans-unit id="257e6b97ae8767ca7162ae0be418d790074caf9b" translate="yes" xml:space="preserve">
          <source>Predicate Functions</source>
          <target state="translated">谓词函数</target>
        </trans-unit>
        <trans-unit id="8fcc548a63302b124fd2a2a6ebe6d394e16cc696" translate="yes" xml:space="preserve">
          <source>Prepare Your Code for Flow</source>
          <target state="translated">为流程准备好您的代码</target>
        </trans-unit>
        <trans-unit id="80015c28ef31d8e37f60f4672f12166e4717f624" translate="yes" xml:space="preserve">
          <source>Preparing a project for Flow requires only one command:</source>
          <target state="translated">为Flow准备一个项目只需要一个命令。</target>
        </trans-unit>
        <trans-unit id="0334ecb0491c1c96b75c2abb7a0dde8caad5c58f" translate="yes" xml:space="preserve">
          <source>Preserving the Instance Type of a Component</source>
          <target state="translated">保留组件的实例类型</target>
        </trans-unit>
        <trans-unit id="f6675da1b1e3eb27ea3b95e0125a3fc19547c62c" translate="yes" xml:space="preserve">
          <source>Press Ctrl+Shift+P to bring up the Command Palette (or use Tools &amp;gt; Command Palette menu)</source>
          <target state="translated">按Ctrl + Shift + P调出命令面板（或使用&amp;ldquo;工具&amp;rdquo;&amp;gt;&amp;ldquo;命令面板&amp;rdquo;菜单）</target>
        </trans-unit>
        <trans-unit id="4e34606590cc14f76b8a62ab4f8ca344fd2d5ed8" translate="yes" xml:space="preserve">
          <source>Prevent this from happening by cutting &lt;code&gt;any&lt;/code&gt; off as soon as possible by casting it to another type.</source>
          <target state="translated">通过将 &lt;code&gt;any&lt;/code&gt; 强制转换为另一种类型来尽快消除任何中断，以防止发生这种情况。</target>
        </trans-unit>
        <trans-unit id="d8f0896601269b7c415369db5197a7aa8c4bfad4" translate="yes" xml:space="preserve">
          <source>Primitive Types</source>
          <target state="translated">原始类型</target>
        </trans-unit>
        <trans-unit id="4d1f996aa17807ebebdb5143b01f86f170d5bea6" translate="yes" xml:space="preserve">
          <source>React</source>
          <target state="translated">React</target>
        </trans-unit>
        <trans-unit id="8fbb63e06d63d6be6834fa16600e9a6203922475" translate="yes" xml:space="preserve">
          <source>React Runtimes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="498f09c9f4966796c2534e5801feef8ccd4eed84" translate="yes" xml:space="preserve">
          <source>React allows you to grab the instance of an element or component with &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt;&lt;code&gt;ref&lt;/code&gt; functions&lt;/a&gt;. To use a ref function add a &lt;a href=&quot;https://flow.org/en/types/maybe/&quot;&gt;maybe instance type&lt;/a&gt; to your class and assign your instance to that property in your ref function.</source>
          <target state="translated">React允许您使用&lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt; &lt;code&gt;ref&lt;/code&gt; 函数&lt;/a&gt;获取元素或组件的实例。要使用ref函数，请将&lt;a href=&quot;https://flow.org/en/types/maybe/&quot;&gt;可能的实例类型&lt;/a&gt;添加到您的类中，然后将您的实例分配给ref函数中的该属性。</target>
        </trans-unit>
        <trans-unit id="ce33237a4802f75e813a38036292316d4ce2343b" translate="yes" xml:space="preserve">
          <source>React allows you to pass &lt;em&gt;any&lt;/em&gt; value as the children of a React component. There are some creative uses of this capability such as using a function for children which could look like this:</source>
          <target state="translated">React允许您传递&lt;em&gt;任何&lt;/em&gt;值作为React组件的子代。此功能有一些创造性的用途，例如为孩子使用一个功能，如下所示：</target>
        </trans-unit>
        <trans-unit id="177c1e000dc1d0316d4c2c3d73adf88cdc7bde20" translate="yes" xml:space="preserve">
          <source>React also supports default props on stateless functional components. Similarly to class components, default props for stateless functional components will work without any extra type annotations.</source>
          <target state="translated">React还支持无状态功能组件的默认道具。与类组件类似,无状态功能组件的默认道具无需任何额外的类型注解即可工作。</target>
        </trans-unit>
        <trans-unit id="b4a8bc5b355decd0225ee33bd0badaf612842a37" translate="yes" xml:space="preserve">
          <source>React class components will be the class instance. So if you had &lt;code&gt;class Foo extends React.Component&amp;lt;{}&amp;gt; {}&lt;/code&gt; and used &lt;code&gt;React.ElementRef&amp;lt;typeof Foo&amp;gt;&lt;/code&gt; then the type would be the instance of &lt;code&gt;Foo&lt;/code&gt;.</source>
          <target state="translated">React类组件将是类实例。因此，如果您有 &lt;code&gt;class Foo extends React.Component&amp;lt;{}&amp;gt; {}&lt;/code&gt; 并使用了 &lt;code&gt;React.ElementRef&amp;lt;typeof Foo&amp;gt;&lt;/code&gt; 则该类型将是 &lt;code&gt;Foo&lt;/code&gt; 的实例。</target>
        </trans-unit>
        <trans-unit id="c111454a8a259a2534472c017a3802fd7ccb4ddd" translate="yes" xml:space="preserve">
          <source>React elements can have zero, one, or many children. Being able to type these children with Flow allows you to build expressive APIs with React children.</source>
          <target state="translated">React元素可以有零个、一个或多个子元素。能够使用Flow键入这些子元素,让你可以用React子元素构建表达式API。</target>
        </trans-unit>
        <trans-unit id="007c7fdccd509ac94dc704a539b8aed206e42677" translate="yes" xml:space="preserve">
          <source>React exports a handful of utility types that may be useful to you when typing advanced React patterns. In previous sections we have seen a few of them. The following is a complete reference for each of these types along with some examples for how/where to use them.</source>
          <target state="translated">React导出了一些实用类型,在输入高级React模式时,这些类型可能对你有用。在前面的章节中,我们已经看到了其中的一些类型。下面是这些类型的完整参考,以及一些关于如何/在哪里使用它们的例子。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
