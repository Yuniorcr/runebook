<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="d2256e3896ead62f77d423e731b976ceab4c8935" translate="yes" xml:space="preserve">
          <source>Includes the required write-ahead log files (WAL files) in the backup. This will include all write-ahead logs generated during the backup. Unless the method &lt;code&gt;none&lt;/code&gt; is specified, it is possible to start a postmaster directly in the extracted directory without the need to consult the log archive, thus making this a completely standalone backup.</source>
          <target state="translated">在备份中包括所需的预写日志文件（WAL文件）。这将包括备份期间生成的所有预写日志。除非未指定 &lt;code&gt;none&lt;/code&gt; 方法，否则可以直接在提取的目录中启动邮局主管，而无需查阅日志档案，因此使之成为完全独立的备份。</target>
        </trans-unit>
        <trans-unit id="bba52d333ab18b6249842b58dabb5827d455ee93" translate="yes" xml:space="preserve">
          <source>Including &lt;code&gt;csvlog&lt;/code&gt; in the &lt;code&gt;log_destination&lt;/code&gt; list provides a convenient way to import log files into a database table. This option emits log lines in comma-separated-values (CSV) format, with these columns: time stamp with milliseconds, user name, database name, process ID, client host:port number, session ID, per-session line number, command tag, session start time, virtual transaction ID, regular transaction ID, error severity, SQLSTATE code, error message, error message detail, hint, internal query that led to the error (if any), character count of the error position therein, error context, user query that led to the error (if any and enabled by &lt;code&gt;log_min_error_statement&lt;/code&gt;), character count of the error position therein, location of the error in the PostgreSQL source code (if &lt;code&gt;log_error_verbosity&lt;/code&gt; is set to &lt;code&gt;verbose&lt;/code&gt;), and application name. Here is a sample table definition for storing CSV-format log output:</source>
          <target state="translated">在 &lt;code&gt;log_destination&lt;/code&gt; 列表中包含 &lt;code&gt;csvlog&lt;/code&gt; 提供了一种将日志文件导入数据库表的便捷方法。此选项以逗号分隔值（CSV）格式发出日志行，并包含以下列：带毫秒的时间戳，用户名，数据库名，进程ID，客户端主机：端口号，会话ID，每个会话行号，命令标签，会话开始时间，虚拟事务ID，常规事务ID，错误严重性，SQLSTATE代码，错误消息，错误消息详细信息，提示，导致错误的内部查询（如果有），其中错误位置的字符数，错误上下文，导致错误的用户查询（如果有的话，并由 &lt;code&gt;log_min_error_statement&lt;/code&gt; 启用）），其中错误位置的字符数，PostgreSQL源代码中错误的位置（如果 &lt;code&gt;log_error_verbosity&lt;/code&gt; 设置为 &lt;code&gt;verbose&lt;/code&gt; ）以及应用程序名称。这是用于存储CSV格式日志输出的示例表定义：</target>
        </trans-unit>
        <trans-unit id="3277b28011c125843d31a46c71b92575dd21118e" translate="yes" xml:space="preserve">
          <source>Including &lt;code&gt;csvlog&lt;/code&gt; in the &lt;code&gt;log_destination&lt;/code&gt; list provides a convenient way to import log files into a database table. This option emits log lines in comma-separated-values (CSV) format, with these columns: time stamp with milliseconds, user name, database name, process ID, client host:port number, session ID, per-session line number, command tag, session start time, virtual transaction ID, regular transaction ID, error severity, SQLSTATE code, error message, error message detail, hint, internal query that led to the error (if any), character count of the error position therein, error context, user query that led to the error (if any and enabled by &lt;code&gt;log_min_error_statement&lt;/code&gt;), character count of the error position therein, location of the error in the PostgreSQL source code (if &lt;code&gt;log_error_verbosity&lt;/code&gt; is set to &lt;code&gt;verbose&lt;/code&gt;), application name, and backend type. Here is a sample table definition for storing CSV-format log output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c47c86c8d425f70d8b2151c0d809c6c1813e865" translate="yes" xml:space="preserve">
          <source>Increase &lt;a href=&quot;runtime-config-wal#GUC-MAX-WAL-SIZE&quot;&gt;max_wal_size&lt;/a&gt; and &lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-TIMEOUT&quot;&gt;checkpoint_timeout&lt;/a&gt;; this reduces the frequency of checkpoints, but increases the storage requirements of &lt;code&gt;/pg_wal&lt;/code&gt;.</source>
          <target state="translated">增加&lt;a href=&quot;runtime-config-wal#GUC-MAX-WAL-SIZE&quot;&gt;max_wal_size&lt;/a&gt;和&lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-TIMEOUT&quot;&gt;checkpoint_timeout&lt;/a&gt; ; 这减少了检查点的频率，但是增加了 &lt;code&gt;/pg_wal&lt;/code&gt; 的存储要求。</target>
        </trans-unit>
        <trans-unit id="491d088ee8f4f607e5e1e928bb9bf8875f9a361a" translate="yes" xml:space="preserve">
          <source>Increases the size of the cube by the specified radius &lt;code&gt;r&lt;/code&gt; in at least &lt;code&gt;n&lt;/code&gt; dimensions. If the radius is negative the cube is shrunk instead. All defined dimensions are changed by the radius &lt;code&gt;r&lt;/code&gt;. Lower-left coordinates are decreased by &lt;code&gt;r&lt;/code&gt; and upper-right coordinates are increased by &lt;code&gt;r&lt;/code&gt;. If a lower-left coordinate is increased to more than the corresponding upper-right coordinate (this can only happen when &lt;code&gt;r&lt;/code&gt; &amp;lt; 0) than both coordinates are set to their average. If &lt;code&gt;n&lt;/code&gt; is greater than the number of defined dimensions and the cube is being enlarged (&lt;code&gt;r&lt;/code&gt; &amp;gt; 0), then extra dimensions are added to make &lt;code&gt;n&lt;/code&gt; altogether; 0 is used as the initial value for the extra coordinates. This function is useful for creating bounding boxes around a point for searching for nearby points.</source>
          <target state="translated">在至少 &lt;code&gt;n&lt;/code&gt; 个维度上以指定的半径 &lt;code&gt;r&lt;/code&gt; 增加立方体的大小。如果半径为负，则缩小立方体。所有定义的尺寸都由半径 &lt;code&gt;r&lt;/code&gt; 更改。左下坐标减小 &lt;code&gt;r&lt;/code&gt; ，右上坐标增大 &lt;code&gt;r&lt;/code&gt; 。如果左下坐标增加到大于相应的右上坐标（这仅在 &lt;code&gt;r&lt;/code&gt; &amp;lt;0 时发生），则两个坐标均设为其平均值。如果 &lt;code&gt;n&lt;/code&gt; 大于定义的维数，并且多维数据集正在放大（ &lt;code&gt;r&lt;/code&gt; &amp;gt; 0），则添加额外的维数以使 &lt;code&gt;n&lt;/code&gt; 共; 0用作额外坐标的初始值。此功能对于在点周围创建边界框以搜索附近的点很有用。</target>
        </trans-unit>
        <trans-unit id="a6f168056ed493abc9b82ee898684e7de650c44e" translate="yes" xml:space="preserve">
          <source>Increases the size of the cube by the specified radius &lt;em&gt;&lt;code&gt;r&lt;/code&gt;&lt;/em&gt; in at least &lt;em&gt;&lt;code&gt;n&lt;/code&gt;&lt;/em&gt; dimensions. If the radius is negative the cube is shrunk instead. All defined dimensions are changed by the radius &lt;em&gt;&lt;code&gt;r&lt;/code&gt;&lt;/em&gt;. Lower-left coordinates are decreased by &lt;em&gt;&lt;code&gt;r&lt;/code&gt;&lt;/em&gt; and upper-right coordinates are increased by &lt;em&gt;&lt;code&gt;r&lt;/code&gt;&lt;/em&gt;. If a lower-left coordinate is increased to more than the corresponding upper-right coordinate (this can only happen when &lt;em&gt;&lt;code&gt;r&lt;/code&gt;&lt;/em&gt; &amp;lt; 0) than both coordinates are set to their average. If &lt;em&gt;&lt;code&gt;n&lt;/code&gt;&lt;/em&gt; is greater than the number of defined dimensions and the cube is being enlarged (&lt;em&gt;&lt;code&gt;r&lt;/code&gt;&lt;/em&gt; &amp;gt; 0), then extra dimensions are added to make &lt;em&gt;&lt;code&gt;n&lt;/code&gt;&lt;/em&gt; altogether; 0 is used as the initial value for the extra coordinates. This function is useful for creating bounding boxes around a point for searching for nearby points.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9c0442f572435bb8c34c7304c10e685fc7ac4b3" translate="yes" xml:space="preserve">
          <source>Increment an integer, making use of an argument name, in PL/pgSQL:</source>
          <target state="translated">在PL/pgSQL中,利用参数名递增一个整数。</target>
        </trans-unit>
        <trans-unit id="d5e6a1521753325e1f10aefe90f61ed951c60b45" translate="yes" xml:space="preserve">
          <source>Increment the sales count of the salesperson who manages the account for Acme Corporation, and record the whole updated row along with current time in a log table:</source>
          <target state="translated">递增管理Acme公司账户的销售人员的销售次数,并将更新后的整行与当前时间一起记录在日志表中。</target>
        </trans-unit>
        <trans-unit id="016cda80a0391be204d7aeb8cae7ec5708da297f" translate="yes" xml:space="preserve">
          <source>Increment the sales count of the salesperson who manages the account for Acme Corporation, using the &lt;code&gt;FROM&lt;/code&gt; clause syntax:</source>
          <target state="translated">使用 &lt;code&gt;FROM&lt;/code&gt; 子句语法，增加管理Acme Corporation帐户的销售人员的销售数量：</target>
        </trans-unit>
        <trans-unit id="9a4352e3ce439f57ce839ae2217c61914bab2036" translate="yes" xml:space="preserve">
          <source>Increment value of the sequence</source>
          <target state="translated">序列的增量值</target>
        </trans-unit>
        <trans-unit id="0baba858aebf401bd8fc5997be9e51de35556b66" translate="yes" xml:space="preserve">
          <source>Independently of &lt;code&gt;max_wal_size&lt;/code&gt;, &lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SEGMENTS&quot;&gt;wal_keep_segments&lt;/a&gt; + 1 most recent WAL files are kept at all times. Also, if WAL archiving is used, old segments can not be removed or recycled until they are archived. If WAL archiving cannot keep up with the pace that WAL is generated, or if &lt;code&gt;archive_command&lt;/code&gt; fails repeatedly, old WAL files will accumulate in &lt;code&gt;pg_wal&lt;/code&gt; until the situation is resolved. A slow or failed standby server that uses a replication slot will have the same effect (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Section 26.2.6&lt;/a&gt;).</source>
          <target state="translated">与 &lt;code&gt;max_wal_size&lt;/code&gt; 无关，&lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SEGMENTS&quot;&gt;始终保留wal_keep_segments&lt;/a&gt; + 1个最新的WAL文件。同样，如果使用WAL归档，则在归档之前，不能删除或回收旧段。如果WAL归档无法跟上WAL生成的速度，或者 &lt;code&gt;archive_command&lt;/code&gt; 反复失败，则旧的WAL文件将累积在 &lt;code&gt;pg_wal&lt;/code&gt; 中,直到情况解决。使用复制插槽的慢速或故障备用服务器将具有相同的效果（请参阅&lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;第26.2.6节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ac2969c439badc170cf6b29ba051a5583d528c7a" translate="yes" xml:space="preserve">
          <source>Independently of &lt;code&gt;max_wal_size&lt;/code&gt;, the most recent &lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SIZE&quot;&gt;wal_keep_size&lt;/a&gt; megabytes of WAL files plus one additional WAL file are kept at all times. Also, if WAL archiving is used, old segments can not be removed or recycled until they are archived. If WAL archiving cannot keep up with the pace that WAL is generated, or if &lt;code&gt;archive_command&lt;/code&gt; fails repeatedly, old WAL files will accumulate in &lt;code&gt;pg_wal&lt;/code&gt; until the situation is resolved. A slow or failed standby server that uses a replication slot will have the same effect (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Section 26.2.6&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbdcb0b3a79497de0963b2de12972bc29faac57b" translate="yes" xml:space="preserve">
          <source>Index (relation)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc7301cd0f493014b9a0674c1f9a1816640cb05f" translate="yes" xml:space="preserve">
          <source>Index Access Method: Basic API Structure for Indexes</source>
          <target state="translated">索引访问方法。索引的基本API结构</target>
        </trans-unit>
        <trans-unit id="f78511aae833dc82a57faebbdb5be9d2b811c5ba" translate="yes" xml:space="preserve">
          <source>Index Access Method: Index Access Method Functions</source>
          <target state="translated">索引访问法。索引访问法功能</target>
        </trans-unit>
        <trans-unit id="67844b6b086746a2175da308cd69b3a3322c8f8a" translate="yes" xml:space="preserve">
          <source>Index Access Method: Index Cost Estimation Functions</source>
          <target state="translated">指数访问法。指数成本估算函数</target>
        </trans-unit>
        <trans-unit id="ed0cf00558f5f3be604eab3a16ea9444c680fa41" translate="yes" xml:space="preserve">
          <source>Index Access Method: Index Locking Considerations</source>
          <target state="translated">索引访问方法。索引锁定注意事项</target>
        </trans-unit>
        <trans-unit id="23bdd1e7799979f5184920ab721afb82ac1bc5bc" translate="yes" xml:space="preserve">
          <source>Index Access Method: Index Scanning</source>
          <target state="translated">索引访问方法。索引扫描</target>
        </trans-unit>
        <trans-unit id="1b3aa3923e02606cc47b91d3beb9e0be0fcf698b" translate="yes" xml:space="preserve">
          <source>Index Access Method: Index Uniqueness Checks</source>
          <target state="translated">索引访问方法。索引唯一性检查</target>
        </trans-unit>
        <trans-unit id="5ec145b22f866c8350ec8fde02299443b400da81" translate="yes" xml:space="preserve">
          <source>Index Storage Parameters</source>
          <target state="translated">索引存储参数</target>
        </trans-unit>
        <trans-unit id="4e09dcdaddb1a9558501d09366dc72f53b93938b" translate="yes" xml:space="preserve">
          <source>Index Types</source>
          <target state="translated">索引类型</target>
        </trans-unit>
        <trans-unit id="f19762ba6cf5f18bb6bfea402f2aaa7605c7a6d9" translate="yes" xml:space="preserve">
          <source>Index access method operator class is for</source>
          <target state="translated">索引访问方法操作类是为</target>
        </trans-unit>
        <trans-unit id="aa270689b00c3b50db9d0d870a5d8e7c14e30f9d" translate="yes" xml:space="preserve">
          <source>Index access method operator family is for</source>
          <target state="translated">指数访问法运算符家族是为</target>
        </trans-unit>
        <trans-unit id="7f91618c60dc341c28ac1a80ab4b5e00b3b36fa4" translate="yes" xml:space="preserve">
          <source>Index access method specific data. Different methods store different data. Empty in ordinary tables.</source>
          <target state="translated">索引访问方法具体数据。不同的方法存储不同的数据。普通表格中的空。</target>
        </trans-unit>
        <trans-unit id="31a6a8a40d18f374bed6deff03fed3f43968a4d7" translate="yes" xml:space="preserve">
          <source>Index access methods must handle concurrent updates of the index by multiple processes. The core PostgreSQL system obtains &lt;code&gt;AccessShareLock&lt;/code&gt; on the index during an index scan, and &lt;code&gt;RowExclusiveLock&lt;/code&gt; when updating the index (including plain &lt;code&gt;VACUUM&lt;/code&gt;). Since these lock types do not conflict, the access method is responsible for handling any fine-grained locking it might need. An exclusive lock on the index as a whole will be taken only during index creation, destruction, or &lt;code&gt;REINDEX&lt;/code&gt;.</source>
          <target state="translated">索引访问方法必须处理多个进程对索引的并发更新。芯的PostgreSQL系统获得 &lt;code&gt;AccessShareLock&lt;/code&gt; 索引扫描期间对索引，并且 &lt;code&gt;RowExclusiveLock&lt;/code&gt; 更新索引（包括普通当 &lt;code&gt;VACUUM&lt;/code&gt; ）。由于这些锁类型没有冲突，因此访问方法负责处理可能需要的任何细粒度的锁。整个索引的排他锁只能在索引创建，销毁或 &lt;code&gt;REINDEX&lt;/code&gt; 期间进行。</target>
        </trans-unit>
        <trans-unit id="411152cefe270170bdbd707fa7bb100f59936ac0" translate="yes" xml:space="preserve">
          <source>Index definition (a reconstructed &lt;code&gt;CREATE INDEX&lt;/code&gt; command)</source>
          <target state="translated">索引定义（重构的 &lt;code&gt;CREATE INDEX&lt;/code&gt; 命令）</target>
        </trans-unit>
        <trans-unit id="fdde6507a698ff6040826cbe9781cf5e41a80789" translate="yes" xml:space="preserve">
          <source>Index expressions are relatively expensive to maintain, because the derived expression(s) must be computed for each row upon insertion and whenever it is updated. However, the index expressions are &lt;em&gt;not&lt;/em&gt; recomputed during an indexed search, since they are already stored in the index. In both examples above, the system sees the query as just &lt;code&gt;WHERE indexedcolumn = 'constant'&lt;/code&gt; and so the speed of the search is equivalent to any other simple index query. Thus, indexes on expressions are useful when retrieval speed is more important than insertion and update speed.</source>
          <target state="translated">索引表达式的维护成本相对较高，因为必须在插入时以及每当更新行时为每一行计算派生表达式。但是，索引表达式在索引搜索过程中&lt;em&gt;不会&lt;/em&gt;重新计算，因为它们已存储在索引中。在以上两个示例中，系统都将查询视为 &lt;code&gt;WHERE indexedcolumn = 'constant'&lt;/code&gt; ，因此搜索速度等同于任何其他简单索引查询。因此，当检索速度比插入和更新速度更重要时，表达式索引非常有用。</target>
        </trans-unit>
        <trans-unit id="137221474050ee597f18d1d2a9bf5cc8c57090b0" translate="yes" xml:space="preserve">
          <source>Index-Only Scans and Covering Indexes</source>
          <target state="translated">纯索引扫描和封面索引。</target>
        </trans-unit>
        <trans-unit id="fa0d50739fe1e6ebbc17d0c70d81ac62acbaf58d" translate="yes" xml:space="preserve">
          <source>Indexable Operators</source>
          <target state="translated">可索引操作符</target>
        </trans-unit>
        <trans-unit id="69a6a1b0f4ad606d0ae7c258868e72a29f0777ef" translate="yes" xml:space="preserve">
          <source>Indexed Data Type</source>
          <target state="translated">索引数据类型</target>
        </trans-unit>
        <trans-unit id="f642ee196088372ea886186c6c617515599afd3f" translate="yes" xml:space="preserve">
          <source>Indexes</source>
          <target state="translated">Indexes</target>
        </trans-unit>
        <trans-unit id="0b07dd7c1e4d64ef5d5ba2561b6e35701b2906b6" translate="yes" xml:space="preserve">
          <source>Indexes and foreign key constraints apply to single tables and not to their inheritance children, hence they have some &lt;a href=&quot;ddl-inherit#DDL-INHERIT-CAVEATS&quot;&gt;caveats&lt;/a&gt; to be aware of.</source>
          <target state="translated">索引和外键约束仅适用于单个表，而不适用于其继承子级，因此&lt;a href=&quot;ddl-inherit#DDL-INHERIT-CAVEATS&quot;&gt;需要注意&lt;/a&gt;一些注意事项。</target>
        </trans-unit>
        <trans-unit id="e15643bd769ae7fcf2c35c27f2ab1732e1a9d5c1" translate="yes" xml:space="preserve">
          <source>Indexes can also be used to enforce uniqueness of a column's value, or the uniqueness of the combined values of more than one column.</source>
          <target state="translated">索引还可以用来强制执行一列值的唯一性,或多个列的组合值的唯一性。</target>
        </trans-unit>
        <trans-unit id="94aa2c39061285d86804bbba30d7e52d694f4564" translate="yes" xml:space="preserve">
          <source>Indexes can also benefit &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; commands with search conditions. Indexes can moreover be used in join searches. Thus, an index defined on a column that is part of a join condition can also significantly speed up queries with joins.</source>
          <target state="translated">索引还可以使具有搜索条件的 &lt;code&gt;UPDATE&lt;/code&gt; 和 &lt;code&gt;DELETE&lt;/code&gt; 命令受益。此外，索引可用于联接搜索。因此，在作为联接条件一部分的列上定义的索引也可以显着加快使用联接的查询。</target>
        </trans-unit>
        <trans-unit id="68c16c2b91128e4f41955f5ff646c75a169f39bb" translate="yes" xml:space="preserve">
          <source>Indexes can be used by simple index scans, &amp;ldquo;bitmap&amp;rdquo; index scans, and the optimizer. In a bitmap scan the output of several indexes can be combined via AND or OR rules, so it is difficult to associate individual heap row fetches with specific indexes when a bitmap scan is used. Therefore, a bitmap scan increments the &lt;code&gt;pg_stat_all_indexes&lt;/code&gt;.&lt;code&gt;idx_tup_read&lt;/code&gt; count(s) for the index(es) it uses, and it increments the &lt;code&gt;pg_stat_all_tables&lt;/code&gt;.&lt;code&gt;idx_tup_fetch&lt;/code&gt; count for the table, but it does not affect &lt;code&gt;pg_stat_all_indexes&lt;/code&gt;.&lt;code&gt;idx_tup_fetch&lt;/code&gt;. The optimizer also accesses indexes to check for supplied constants whose values are outside the recorded range of the optimizer statistics because the optimizer statistics might be stale.</source>
          <target state="translated">索引可以由简单的索引扫描，&amp;ldquo;位图&amp;rdquo;索引扫描和优化程序使用。在位图扫描中，可以通过AND或OR规则组合多个索引的输出，因此，在使用位图扫描时​​，很难将单个堆行提取与特定索引相关联。因此，位图扫描会增加 &lt;code&gt;pg_stat_all_indexes&lt;/code&gt; 。 &lt;code&gt;idx_tup_read&lt;/code&gt; 它使用的索引的计数，并增加 &lt;code&gt;pg_stat_all_tables&lt;/code&gt; 。表的 &lt;code&gt;idx_tup_fetch&lt;/code&gt; 计数，但不影响 &lt;code&gt;pg_stat_all_indexes&lt;/code&gt; 。 &lt;code&gt;idx_tup_fetch&lt;/code&gt; 。优化器还访问索引以检查其值超出优化器统计信息的记录范围的提供的常量，因为优化器统计信息可能已过时。</target>
        </trans-unit>
        <trans-unit id="fe87987c8ecb565fcb320eb91d374313994665e6" translate="yes" xml:space="preserve">
          <source>Indexes can even concatenate columns:</source>
          <target state="translated">索引甚至可以连接列。</target>
        </trans-unit>
        <trans-unit id="615b513b7bf8866eb4478326c86bda00dbb8833c" translate="yes" xml:space="preserve">
          <source>Indexes can not have multiple inheritance, since they can only inherit when using declarative partitioning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fee069b42975ecfc0bf523b8f7af8b0cf11b9bb" translate="yes" xml:space="preserve">
          <source>Indexes, &lt;code&gt;PRIMARY KEY&lt;/code&gt;, &lt;code&gt;UNIQUE&lt;/code&gt;, and &lt;code&gt;EXCLUDE&lt;/code&gt; constraints on the original table will be created on the new table. Names for the new indexes and constraints are chosen according to the default rules, regardless of how the originals were named. (This behavior avoids possible duplicate-name failures for the new indexes.)</source>
          <target state="translated">原始表上的索引， &lt;code&gt;PRIMARY KEY&lt;/code&gt; ， &lt;code&gt;UNIQUE&lt;/code&gt; 和 &lt;code&gt;EXCLUDE&lt;/code&gt; 约束将在新表上创建。不论原始名称如何命名，都会根据默认规则选择新索引和约束的名称。（此行为避免了新索引可能出现的重复名称错误。）</target>
        </trans-unit>
        <trans-unit id="64accc47bb83e575341063f3658e1d1e7d2113e1" translate="yes" xml:space="preserve">
          <source>Indexing for &amp;ldquo;float ranges&amp;rdquo;</source>
          <target state="translated">索引&amp;ldquo;浮动范围&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="d165c70b9c7feb2704f3285d8d27cbb3a58c3a91" translate="yes" xml:space="preserve">
          <source>Indexing for multidimensional cubes</source>
          <target state="translated">多维立方体的索引</target>
        </trans-unit>
        <trans-unit id="b91462559e819269659f845aa92e7f5041a36896" translate="yes" xml:space="preserve">
          <source>Indexing for tree-like structures</source>
          <target state="translated">树状结构的索引</target>
        </trans-unit>
        <trans-unit id="610e7a10148c311249b3bbd57cd9833a58b8714d" translate="yes" xml:space="preserve">
          <source>Indicates how the cast is performed. &lt;code&gt;f&lt;/code&gt; means that the function specified in the &lt;code&gt;castfunc&lt;/code&gt; field is used. &lt;code&gt;i&lt;/code&gt; means that the input/output functions are used. &lt;code&gt;b&lt;/code&gt; means that the types are binary-coercible, thus no conversion is required.</source>
          <target state="translated">指示执行转换的方式。 &lt;code&gt;f&lt;/code&gt; 表示使用在 &lt;code&gt;castfunc&lt;/code&gt; 字段中指定的函数。 &lt;code&gt;i&lt;/code&gt; 表示使用输入/输出功能。 &lt;code&gt;b&lt;/code&gt; 表示类型是二进制强制的，因此不需要转换。</target>
        </trans-unit>
        <trans-unit id="c8e4b2b3e4731dd79133b34f9f993d48a44e51e7" translate="yes" xml:space="preserve">
          <source>Indicates not to recurse creating indexes on partitions, if the table is partitioned. The default is to recurse.</source>
          <target state="translated">如果表是分区的,表示不递归在分区上创建索引。默认情况下是递归。</target>
        </trans-unit>
        <trans-unit id="c934b82eb6dc908677ffc76af2256f04ecf84094" translate="yes" xml:space="preserve">
          <source>Indicates role to which this role will be added immediately as a new member. Multiple roles to which this role will be added as a member can be specified by writing multiple &lt;code&gt;-g&lt;/code&gt; switches.</source>
          <target state="translated">指示将作为新成员立即添加到的角色。可以通过编写多个 &lt;code&gt;-g&lt;/code&gt; 开关来指定将该角色作为成员添加到的多个角色。</target>
        </trans-unit>
        <trans-unit id="bba08c6b0be5e0b5de1c5dd077ea609cb92072f0" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any array data type (see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="translated">指示函数接受任何数组数据类型（请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;第37.2.5节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="eeaf761f967f3ec9a6c653153e34b899c18b98b6" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any array data type (see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2af32ec08da7863e95ebf028210e1919471adfda" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any array data type, with automatic promotion of multiple arguments to a common data type (see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a2f7fb68c39785b7c61d53497fe5cf5bd1568bd" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any data type (see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="translated">指示函数接受任何数据类型（请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;第37.2.5节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3dcc0fc3f371079dcd8cbcbfff1f3968fc460f48" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any data type (see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5be49c718755809ee9277f9ab09722e8b9a182ec" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any data type, with automatic promotion of multiple arguments to a common data type (see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f46df9b9c0db2bde38cb75f71fb9153783611d4" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any enum data type (see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt; and &lt;a href=&quot;datatype-enum&quot;&gt;Section 8.7&lt;/a&gt;).</source>
          <target state="translated">指示函数接受任何枚举数据类型（请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;第37.2.5 &lt;/a&gt;&lt;a href=&quot;datatype-enum&quot;&gt;节&lt;/a&gt;和第8.7节）。</target>
        </trans-unit>
        <trans-unit id="8fccdb3ecc85b5b077cee3a13e6c3bbb009743e7" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any enum data type (see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt; and &lt;a href=&quot;datatype-enum&quot;&gt;Section 8.7&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46bd42bb48f3fa999abde7cc36ebf5b6f5ac5c8d" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any input data type.</source>
          <target state="translated">表示函数接受任何输入数据类型。</target>
        </trans-unit>
        <trans-unit id="4e38b6c5ff227f9cc8a0278ba387f1ee54390caf" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any non-array data type (see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="translated">指示函数接受任何非数组数据类型（请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;第37.2.5节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="bd2da16b809ae60477ecb6e3765117401057fff5" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any non-array data type (see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a67aeb7edc5c822452d3c7740dc6c35d51323bcb" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any non-array data type, with automatic promotion of multiple arguments to a common data type (see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95d9465560cf78be64ef72d2e6367284edb5463f" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any range data type (see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt; and &lt;a href=&quot;rangetypes&quot;&gt;Section 8.17&lt;/a&gt;).</source>
          <target state="translated">指示函数接受任何范围数据类型（请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;第37.2.5 &lt;/a&gt;&lt;a href=&quot;rangetypes&quot;&gt;节&lt;/a&gt;和第8.17节）。</target>
        </trans-unit>
        <trans-unit id="035276077ea5e5ea9bea1d81e40e660b2873cd5b" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any range data type (see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt; and &lt;a href=&quot;rangetypes&quot;&gt;Section 8.17&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4af7c5b9171c91763d28f65430601eb54e6589ed" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any range data type, with automatic promotion of multiple arguments to a common data type (see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt; and &lt;a href=&quot;rangetypes&quot;&gt;Section 8.17&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99e158daaace8eac02a3ccf2b3b765596ccc91e4" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts or returns a null-terminated C string.</source>
          <target state="translated">表示一个函数接受或返回一个以空为结尾的C字符串。</target>
        </trans-unit>
        <trans-unit id="54761c9282026639ec5c8540cc79ebf4ba11462a" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts or returns a server-internal data type.</source>
          <target state="translated">表示一个函数接受或返回一个服务器内部的数据类型。</target>
        </trans-unit>
        <trans-unit id="89dc9ca8b4db982fb593e3e44e25350b25d82bea" translate="yes" xml:space="preserve">
          <source>Indicates that a function returns no value.</source>
          <target state="translated">表示函数不返回任何值。</target>
        </trans-unit>
        <trans-unit id="7d75608f451e28beb0733c0d6c1c5d589e592ee3" translate="yes" xml:space="preserve">
          <source>Indicates that data retrieved from the cursor should be unaffected by updates to the table(s) underlying the cursor that occur after the cursor is created. In PostgreSQL, this is the default behavior; so this key word has no effect and is only accepted for compatibility with the SQL standard.</source>
          <target state="translated">表示从游标中获取的数据不受游标创建后表的更新影响。在PostgreSQL中,这是默认的行为,所以这个关键字没有任何影响,只是为了与SQL标准兼容。</target>
        </trans-unit>
        <trans-unit id="95cdb06015680fe563a8aa9dd541903933a11ad2" translate="yes" xml:space="preserve">
          <source>Indicates that the cast can be invoked implicitly in any context.</source>
          <target state="translated">表示在任何上下文中都可以隐式地调用该浇注。</target>
        </trans-unit>
        <trans-unit id="0390d2ebad5b8b8a226d9901a34d76e7770b71be" translate="yes" xml:space="preserve">
          <source>Indicates that the cast can be invoked implicitly in assignment contexts.</source>
          <target state="translated">表示在赋值上下文中可以隐式地调用铸型。</target>
        </trans-unit>
        <trans-unit id="3840502dacc9907db02fe8896c3bfeafcfa9e633" translate="yes" xml:space="preserve">
          <source>Indicates that the cast is an I/O conversion cast, performed by invoking the output function of the source data type, and passing the resulting string to the input function of the target data type.</source>
          <target state="translated">表示该投法是I/O转换投法,通过调用源数据类型的输出函数来执行,并将产生的字符串传递给目标数据类型的输入函数。</target>
        </trans-unit>
        <trans-unit id="01e358ef1ee49de64b80b741226b8d05654b1eb9" translate="yes" xml:space="preserve">
          <source>Indicates that the source type is binary-coercible to the target type, so no function is required to perform the cast.</source>
          <target state="translated">表示源类型对目标类型是二进制可执行的,所以不需要函数来执行转换。</target>
        </trans-unit>
        <trans-unit id="4f0180a78d5a13ddfb20f673dc1c1a653a0dbf1c" translate="yes" xml:space="preserve">
          <source>Indicates this operator can support a hash join.</source>
          <target state="translated">表示该操作者可以支持哈希连接。</target>
        </trans-unit>
        <trans-unit id="7f8be265aa5381d640f66bb0fbb51979d62652fa" translate="yes" xml:space="preserve">
          <source>Indicates this operator can support a merge join.</source>
          <target state="translated">表示该操作者可以支持合并加入。</target>
        </trans-unit>
        <trans-unit id="88982366e025d973d9fdcbf523cd379f45035c49" translate="yes" xml:space="preserve">
          <source>Indicates what contexts the cast can be invoked in. &lt;code&gt;e&lt;/code&gt; means only as an explicit cast (using &lt;code&gt;CAST&lt;/code&gt; or &lt;code&gt;::&lt;/code&gt; syntax). &lt;code&gt;a&lt;/code&gt; means implicitly in assignment to a target column, as well as explicitly. &lt;code&gt;i&lt;/code&gt; means implicitly in expressions, as well as the other cases.</source>
          <target state="translated">指示可以在其中调用转换的上下文 &lt;code&gt;e&lt;/code&gt; 仅表示为显式转换（使用 &lt;code&gt;CAST&lt;/code&gt; 或 &lt;code&gt;::&lt;/code&gt; 语法）。 &lt;code&gt;a&lt;/code&gt; 隐式分配给目标列以及显式分配中的一种手段。除其他情况外， &lt;code&gt;i&lt;/code&gt; 在表达中含蓄地意思。</target>
        </trans-unit>
        <trans-unit id="e1335256027d947c4a5d7cbed371240e3fa5176d" translate="yes" xml:space="preserve">
          <source>Indirect TOAST pointers simply point at a non-indirect varlena value stored somewhere in memory. This case was originally created merely as a proof of concept, but it is currently used during logical decoding to avoid possibly having to create physical tuples exceeding 1 GB (as pulling all out-of-line field values into the tuple might do). The case is of limited use since the creator of the pointer datum is entirely responsible that the referenced data survives for as long as the pointer could exist, and there is no infrastructure to help with this.</source>
          <target state="translated">间接TOAST指针只是指向存储在内存中某处的非直接varlena值。这种情况最初只是作为概念证明而创建的,但目前在逻辑解码过程中使用,以避免可能需要创建超过1GB的物理元组(因为将所有行外字段值拉到元组中可能会这样做)。这种情况的用处有限,因为指针数据元的创建者要完全负责,只要指针能够存在,被引用的数据就能存活下来,而且没有基础设施来帮助解决这个问题。</target>
        </trans-unit>
        <trans-unit id="749d2a57690cd8938d324488d8b64d9826db075f" translate="yes" xml:space="preserve">
          <source>Individual leaf tuples and inner tuples must fit on a single index page (8kB by default). Therefore, when indexing values of variable-length data types, long values can only be supported by methods such as radix trees, in which each level of the tree includes a prefix that is short enough to fit on a page, and the final leaf level includes a suffix also short enough to fit on a page. The operator class should set &lt;code&gt;longValuesOK&lt;/code&gt; to true only if it is prepared to arrange for this to happen. Otherwise, the SP-GiST core will reject any request to index a value that is too large to fit on an index page.</source>
          <target state="translated">单个叶子元组和内部元组必须适合单个索引页（默认为8kB）。因此，当为可变长度数据类型的值建立索引时，长值只能由诸如基数树之类的方法支持，其中基数树的每个级别都包含一个足够短以适合页面的前缀，以及最终叶级别包含一个后缀，该后缀也足够短以适合页面。运营商级应该设置 &lt;code&gt;longValuesOK&lt;/code&gt; 只有当它准备安排要做到这一点为true。否则，SP-GiST内核将拒绝任何对索引值太大而无法容纳在索引页上的请求。</target>
        </trans-unit>
        <trans-unit id="60182f316e9821f12c8e613a5f4a51ed0303f8be" translate="yes" xml:space="preserve">
          <source>Individual partitions are linked to the partitioned table with inheritance behind-the-scenes; however, it is not possible to use some of the generic features of inheritance (discussed below) with declaratively partitioned tables or their partitions. For example, a partition cannot have any parents other than the partitioned table it is a partition of, nor can a regular table inherit from a partitioned table making the latter its parent. That means partitioned tables and their partitions do not participate in inheritance with regular tables. Since a partition hierarchy consisting of the partitioned table and its partitions is still an inheritance hierarchy, all the normal rules of inheritance apply as described in &lt;a href=&quot;ddl-inherit&quot;&gt;Section 5.10&lt;/a&gt; with some exceptions, most notably:</source>
          <target state="translated">各个分区通过后台继承链接到分区表。但是，无法对声明性分区的表或其分区使用继承的某些通用功能（如下所述）。例如，一个分区除了作为分区的分区表之外，不能有其他任何父级，常规表也不能从使其成为其父级的分区表继承。这意味着分区表及其分区不参与常规表的继承。由于由分区表及其分区组成的分区层次结构仍然是继承层次结构，因此所有常规继承规则都适用，如&lt;a href=&quot;ddl-inherit&quot;&gt;5.10节中&lt;/a&gt;所述，但有一些例外，最值得注意的是：</target>
        </trans-unit>
        <trans-unit id="e8da164cdd479d1b5a117c145f315adf86e0bbc9" translate="yes" xml:space="preserve">
          <source>Individual state files in &lt;code&gt;pg_twophase&lt;/code&gt; are protected by CRC-32.</source>
          <target state="translated">&lt;code&gt;pg_twophase&lt;/code&gt; 中的各个状态文件受CRC-32保护。</target>
        </trans-unit>
        <trans-unit id="10dbe9c3ced898e42dd1884b1b4e3f1dc8f408e3" translate="yes" xml:space="preserve">
          <source>Inexact means that some values cannot be converted exactly to the internal format and are stored as approximations, so that storing and retrieving a value might show slight discrepancies. Managing these errors and how they propagate through calculations is the subject of an entire branch of mathematics and computer science and will not be discussed here, except for the following points:</source>
          <target state="translated">不精确是指有些值不能精确地转换为内部格式,而是作为近似值存储,因此存储和检索一个值可能会出现轻微的差异。管理这些错误以及这些错误如何在计算中传播是整个数学和计算机科学的一个分支的主题,除了以下几点之外,这里将不作讨论。</target>
        </trans-unit>
        <trans-unit id="4d7d8b040e79c74720337a20e81bb860b0667a32" translate="yes" xml:space="preserve">
          <source>Infinite line</source>
          <target state="translated">无限线</target>
        </trans-unit>
        <trans-unit id="6f943c69647f371e6d494b5d1c35aba8e91e86d6" translate="yes" xml:space="preserve">
          <source>Information about text search configuration objects can be obtained in psql using a set of commands:</source>
          <target state="translated">在psql中可以通过一组命令获得文本搜索配置对象的信息。</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="40def20f80d8ba48037f621df42aa0343e15ee73" translate="yes" xml:space="preserve">
          <source>Inheritance does not automatically propagate data from &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;COPY&lt;/code&gt; commands to other tables in the inheritance hierarchy. In our example, the following &lt;code&gt;INSERT&lt;/code&gt; statement will fail:</source>
          <target state="translated">继承不会自动将数据从 &lt;code&gt;INSERT&lt;/code&gt; 或 &lt;code&gt;COPY&lt;/code&gt; 命令传播到继承层次结构中的其他表。在我们的示例中，以下 &lt;code&gt;INSERT&lt;/code&gt; 语句将失败：</target>
        </trans-unit>
        <trans-unit id="48cefe4735516b5da581e0949fa06f740d2b885b" translate="yes" xml:space="preserve">
          <source>Inheritance is a concept from object-oriented databases. It opens up interesting new possibilities of database design.</source>
          <target state="translated">继承是一个来自面向对象数据库的概念。它为数据库设计提供了有趣的新可能性。</target>
        </trans-unit>
        <trans-unit id="ad5cfb3ab229a84f8bd5bd34780ce3d5e37a4e03" translate="yes" xml:space="preserve">
          <source>Inherited queries perform access permission checks on the parent table only. Thus, for example, granting &lt;code&gt;UPDATE&lt;/code&gt; permission on the &lt;code&gt;cities&lt;/code&gt; table implies permission to update rows in the &lt;code&gt;capitals&lt;/code&gt; table as well, when they are accessed through &lt;code&gt;cities&lt;/code&gt;. This preserves the appearance that the data is (also) in the parent table. But the &lt;code&gt;capitals&lt;/code&gt; table could not be updated directly without an additional grant. In a similar way, the parent table's row security policies (see &lt;a href=&quot;ddl-rowsecurity&quot;&gt;Section 5.8&lt;/a&gt;) are applied to rows coming from child tables during an inherited query. A child table's policies, if any, are applied only when it is the table explicitly named in the query; and in that case, any policies attached to its parent(s) are ignored.</source>
          <target state="translated">继承的查询仅对父表执行访问权限检查。因此，例如，授予对 &lt;code&gt;cities&lt;/code&gt; 表的 &lt;code&gt;UPDATE&lt;/code&gt; 权限也意味着当通过 &lt;code&gt;cities&lt;/code&gt; 访问 &lt;code&gt;capitals&lt;/code&gt; 表中的行时也允许对它们进行更新。这样可以保留数据也位于父表中的外观。但是，如果没有其他赠款， &lt;code&gt;capitals&lt;/code&gt; 表格不能直接更新。父表的行安全策略以类似的方式（请参见&lt;a href=&quot;ddl-rowsecurity&quot;&gt;第5.8节）&lt;/a&gt;）应用于继承的查询期间来自子表的行。子表的策略（如果有）仅在查询中明确命名的表时应用；在这种情况下，将忽略附加到其父级的任何策略。</target>
        </trans-unit>
        <trans-unit id="1f25aac16509c63c647e201e6dca9b42be580c36" translate="yes" xml:space="preserve">
          <source>Initialization Options</source>
          <target state="translated">初始化选项</target>
        </trans-unit>
        <trans-unit id="02678e4e52eadddd5b615833652cf8428b2afe6a" translate="yes" xml:space="preserve">
          <source>Initialization option string for the template</source>
          <target state="translated">模板的初始化选项字符串</target>
        </trans-unit>
        <trans-unit id="6528a9644e65de4c79a52fdab1106b0b771a6d92" translate="yes" xml:space="preserve">
          <source>Initialize the new cluster using &lt;code&gt;initdb&lt;/code&gt;. Again, use compatible &lt;code&gt;initdb&lt;/code&gt; flags that match the old cluster. Many prebuilt installers do this step automatically. There is no need to start the new cluster.</source>
          <target state="translated">使用 &lt;code&gt;initdb&lt;/code&gt; 初始化新集群。同样，使用与旧群集匹配的兼容 &lt;code&gt;initdb&lt;/code&gt; 标志。许多预安装的安装程序会自动执行此步骤。无需启动新集群。</target>
        </trans-unit>
        <trans-unit id="2a5c551f4615e330d270ad5f3b0629fcdfcd3de2" translate="yes" xml:space="preserve">
          <source>Inner tuples are more complex, since they are branching points in the search tree. Each inner tuple contains a set of one or more &lt;em&gt;nodes&lt;/em&gt;, which represent groups of similar leaf values. A node contains a downlink that leads either to another, lower-level inner tuple, or to a short list of leaf tuples that all lie on the same index page. Each node normally has a &lt;em&gt;label&lt;/em&gt; that describes it; for example, in a radix tree the node label could be the next character of the string value. (Alternatively, an operator class can omit the node labels, if it works with a fixed set of nodes for all inner tuples; see &lt;a href=&quot;spgist-implementation#SPGIST-NULL-LABELS&quot;&gt;Section 65.4.2&lt;/a&gt;.) Optionally, an inner tuple can have a &lt;em&gt;prefix&lt;/em&gt; value that describes all its members. In a radix tree this could be the common prefix of the represented strings. The prefix value is not necessarily really a prefix, but can be any data needed by the operator class; for example, in a quad-tree it can store the central point that the four quadrants are measured with respect to. A quad-tree inner tuple would then also contain four nodes corresponding to the quadrants around this central point.</source>
          <target state="translated">内部元组更为复杂，因为它们是搜索树中的分支点。每个内部元组包含一组一个或多个&lt;em&gt;节点&lt;/em&gt;，这些&lt;em&gt;节点&lt;/em&gt;代表相似的叶子值的组。一个节点包含一个下行链路，该下行链路通向另一个较低级别的内部元组，或通向全部位于同一索引页上的叶元组的简短列表。每个节点通常都有一个描述它的&lt;em&gt;标签&lt;/em&gt;。例如，在基数树中，节点标签可以是字符串值的下一个字符。 （或者，如果运算符类对所有内部元组使用固定的节点集，则可以省略节点标签；请参见&lt;a href=&quot;spgist-implementation#SPGIST-NULL-LABELS&quot;&gt;第65.4.2节&lt;/a&gt;。）（可选）内部元组可以具有&lt;em&gt;前缀&lt;/em&gt;描述其所有成员的值。在基数树中，这可能是所表示字符串的通用前缀。前缀值不一定是真正的前缀，而可以是运算符类所需的任何数据；例如，在四叉树中，它可以存储相对于四个象限进行测量的中心点。然后，四叉树内部元组还将包含与该中心点周围的象限相对应的四个节点。</target>
        </trans-unit>
        <trans-unit id="0029fb34c419096901cb17ee7f69f8d100b925e7" translate="yes" xml:space="preserve">
          <source>Input Ordering</source>
          <target state="translated">输入订单</target>
        </trans-unit>
        <trans-unit id="c651bb8d20d59b648e5817a714d081c24490bd28" translate="yes" xml:space="preserve">
          <source>Input String</source>
          <target state="translated">输入字符串</target>
        </trans-unit>
        <trans-unit id="c42fb65381608e452debc58ec5ce5a7de90ede68" translate="yes" xml:space="preserve">
          <source>Input conversion function (binary format), or 0 if none</source>
          <target state="translated">输入转换功能(二进制格式),如果没有,则为0。</target>
        </trans-unit>
        <trans-unit id="6ede32a74b25d24d933316273b8d1a1c5b311742" translate="yes" xml:space="preserve">
          <source>Input conversion function (text format)</source>
          <target state="translated">输入转换功能(文本格式</target>
        </trans-unit>
        <trans-unit id="445431b172a9cb689a043786c27d77bc63ec81f4" translate="yes" xml:space="preserve">
          <source>Input data is interpreted according to &lt;code&gt;ENCODING&lt;/code&gt; option or the current client encoding, and output data is encoded in &lt;code&gt;ENCODING&lt;/code&gt; or the current client encoding, even if the data does not pass through the client but is read from or written to a file directly by the server.</source>
          <target state="translated">输入数据将根据 &lt;code&gt;ENCODING&lt;/code&gt; 选项或当前客户端编码进行解释，而输出数据将以 &lt;code&gt;ENCODING&lt;/code&gt; 或当前客户端编码进行编码，即使数据没有通过客户端，而是由服务器直接从文件中读取或写入文件中。</target>
        </trans-unit>
        <trans-unit id="95802daab3a23990338179f72248350c1434cf39" translate="yes" xml:space="preserve">
          <source>Insert</source>
          <target state="translated">Insert</target>
        </trans-unit>
        <trans-unit id="aa563adcb5d00e2fc3a73ea58d9fd1b265968174" translate="yes" xml:space="preserve">
          <source>Insert a distributor, or do nothing for rows proposed for insertion when an existing, excluded row (a row with a matching constrained column or columns after before row insert triggers fire) exists. Example assumes a unique index has been defined that constrains values appearing in the &lt;code&gt;did&lt;/code&gt; column:</source>
          <target state="translated">插入分配器，或者在存在现有排除行（具有匹配约束列的行或行插入触发触发后的列）时，对建议插入的行不执行任何操作。该示例假定已定义了一个唯一索引，该索引约束了出现在 &lt;code&gt;did&lt;/code&gt; 列中的值：</target>
        </trans-unit>
        <trans-unit id="1b0022e72f294401989398fe077aa7293c9d0864" translate="yes" xml:space="preserve">
          <source>Insert a new tuple into an existing index. The &lt;code&gt;values&lt;/code&gt; and &lt;code&gt;isnull&lt;/code&gt; arrays give the key values to be indexed, and &lt;code&gt;heap_tid&lt;/code&gt; is the TID to be indexed. If the access method supports unique indexes (its &lt;code&gt;amcanunique&lt;/code&gt; flag is true) then &lt;code&gt;checkUnique&lt;/code&gt; indicates the type of uniqueness check to perform. This varies depending on whether the unique constraint is deferrable; see &lt;a href=&quot;index-unique-checks&quot;&gt;Section 61.5&lt;/a&gt; for details. Normally the access method only needs the &lt;code&gt;heapRelation&lt;/code&gt; parameter when performing uniqueness checking (since then it will have to look into the heap to verify tuple liveness).</source>
          <target state="translated">将新的元组插入现有索引。的 &lt;code&gt;values&lt;/code&gt; 和 &lt;code&gt;isnull&lt;/code&gt; 阵列给要被索引的关键值，并且 &lt;code&gt;heap_tid&lt;/code&gt; 是要被索引的TID。如果访问方法支持唯一索引（其 &lt;code&gt;amcanunique&lt;/code&gt; 标志为true），则 &lt;code&gt;checkUnique&lt;/code&gt; 指示要执行的唯一性检查的类型。这取决于唯一约束是否可延期。有关详细信息，请参见&lt;a href=&quot;index-unique-checks&quot;&gt;第61.5节&lt;/a&gt;。通常，访问方法在执行唯一性检查时仅需要 &lt;code&gt;heapRelation&lt;/code&gt; 参数（因为那样一来，它就必须查看堆以验证元组活动性）。</target>
        </trans-unit>
        <trans-unit id="0f674319e8780ea4807c4a4acfb9e949fb5f9a9e" translate="yes" xml:space="preserve">
          <source>Insert a single row into table &lt;code&gt;distributors&lt;/code&gt;, returning the sequence number generated by the &lt;code&gt;DEFAULT&lt;/code&gt; clause:</source>
          <target state="translated">在表 &lt;code&gt;distributors&lt;/code&gt; 插入一行，返回由 &lt;code&gt;DEFAULT&lt;/code&gt; 子句生成的序列号：</target>
        </trans-unit>
        <trans-unit id="632c13df9b06de5c5de5b6f56617f6d898fc7280" translate="yes" xml:space="preserve">
          <source>Insert a single row into table &lt;code&gt;films&lt;/code&gt;:</source>
          <target state="translated">在表格 &lt;code&gt;films&lt;/code&gt; 插入一行：</target>
        </trans-unit>
        <trans-unit id="3892df53992670e16381ba584272763bbe059b7e" translate="yes" xml:space="preserve">
          <source>Insert new distributor if possible; otherwise &lt;code&gt;DO NOTHING&lt;/code&gt;. Example assumes a unique index has been defined that constrains values appearing in the &lt;code&gt;did&lt;/code&gt; column on a subset of rows where the &lt;code&gt;is_active&lt;/code&gt; Boolean column evaluates to &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">尽可能插入新的分配器；否则 &lt;code&gt;DO NOTHING&lt;/code&gt; 。该示例假定已定义了一个唯一索引，该索引限制了出现在 &lt;code&gt;did&lt;/code&gt; 列上 &lt;code&gt;is_active&lt;/code&gt; Boolean列的评估结果为 &lt;code&gt;true&lt;/code&gt; 的行子集上的值：</target>
        </trans-unit>
        <trans-unit id="db80c622e1c5ed5095a7dd936600840392c749b3" translate="yes" xml:space="preserve">
          <source>Insert or update new distributors as appropriate. Assumes a unique index has been defined that constrains values appearing in the &lt;code&gt;did&lt;/code&gt; column. Note that the special &lt;code&gt;excluded&lt;/code&gt; table is used to reference values originally proposed for insertion:</source>
          <target state="translated">插入或更新适当的新发行商。假设已经定义了一个唯一索引，以约束在 &lt;code&gt;did&lt;/code&gt; 列中出现的值。请注意，特殊 &lt;code&gt;excluded&lt;/code&gt; 表用于引用最初建议插入的值：</target>
        </trans-unit>
        <trans-unit id="449538b0ed8e6f507ea1c64d35164fae0d826023" translate="yes" xml:space="preserve">
          <source>Insert or update new distributors as appropriate. Example assumes a unique index has been defined that constrains values appearing in the &lt;code&gt;did&lt;/code&gt; column. &lt;code&gt;WHERE&lt;/code&gt; clause is used to limit the rows actually updated (any existing row not updated will still be locked, though):</source>
          <target state="translated">插入或更新适当的新发行商。该示例假定已定义一个唯一索引，该索引限制了出现在 &lt;code&gt;did&lt;/code&gt; 列中的值。 &lt;code&gt;WHERE&lt;/code&gt; 子句用于限制实际更新的行（但是，任何未更新的现有行仍将被锁定）：</target>
        </trans-unit>
        <trans-unit id="ae6eaf6a32e43f0bf6ecef28e872215845bae1e6" translate="yes" xml:space="preserve">
          <source>Inserting</source>
          <target state="translated">Inserting</target>
        </trans-unit>
        <trans-unit id="0dd2b481ad724309af4e29174757be7f9ad67dd8" translate="yes" xml:space="preserve">
          <source>Inserting Data</source>
          <target state="translated">插入数据</target>
        </trans-unit>
        <trans-unit id="a58e264f985643a8003e2d8ae2f19f1f44151747" translate="yes" xml:space="preserve">
          <source>Insertion into a GIN index can be slow due to the likelihood of many keys being inserted for each item. So, for bulk insertions into a table it is advisable to drop the GIN index and recreate it after finishing bulk insertion.</source>
          <target state="translated">由于每个项目可能会插入很多键,所以插入GIN索引的速度会很慢。所以,对于表的批量插入,建议放弃GIN索引,在完成批量插入后重新创建。</target>
        </trans-unit>
        <trans-unit id="a514639c0e9db066f2ca50c5677c9c0ad2871adb" translate="yes" xml:space="preserve">
          <source>Inside the crosstab grid, for each distinct value &lt;code&gt;x&lt;/code&gt; of &lt;code&gt;colH&lt;/code&gt; and each distinct value &lt;code&gt;y&lt;/code&gt; of &lt;code&gt;colV&lt;/code&gt;, the cell located at the intersection &lt;code&gt;(x,y)&lt;/code&gt; contains the value of the &lt;code&gt;colD&lt;/code&gt; column in the query result row for which the value of &lt;code&gt;colH&lt;/code&gt; is &lt;code&gt;x&lt;/code&gt; and the value of &lt;code&gt;colV&lt;/code&gt; is &lt;code&gt;y&lt;/code&gt;. If there is no such row, the cell is empty. If there are multiple such rows, an error is reported.</source>
          <target state="translated">交叉表格内，对于每个不同的值 &lt;code&gt;x&lt;/code&gt; 的 &lt;code&gt;colH&lt;/code&gt; 和每个不同的值 &lt;code&gt;y&lt;/code&gt; 的 &lt;code&gt;colV&lt;/code&gt; ，位于相交处的单元 &lt;code&gt;(x,y)&lt;/code&gt; 包含的值 &lt;code&gt;colD&lt;/code&gt; 塔的查询结果列于其中的值 &lt;code&gt;colH&lt;/code&gt; 是 &lt;code&gt;x&lt;/code&gt; 并且 &lt;code&gt;colV&lt;/code&gt; 的值为 &lt;code&gt;y&lt;/code&gt; 。如果没有这样的行，则该单元格为空。如果有多个这样的行，则会报告错误。</target>
        </trans-unit>
        <trans-unit id="b00cb7892b66a87132bdd26b6401b8b521c81e40" translate="yes" xml:space="preserve">
          <source>Inspect the contents of the database to ensure you have recovered to the desired state. If not, return to step 1. If all is well, allow your users to connect by restoring &lt;code&gt;pg_hba.conf&lt;/code&gt; to normal.</source>
          <target state="translated">检查数据库的内容，以确保您已恢复到所需状态。如果没有，请返回到步骤1。如果一切正常，请通过将 &lt;code&gt;pg_hba.conf&lt;/code&gt; 恢复为正常状态来允许您的用户进行连接。</target>
        </trans-unit>
        <trans-unit id="bb93c6938a2011d934988eab5986d385a4c4d0be" translate="yes" xml:space="preserve">
          <source>Inspecting the MCV list is possible using &lt;code&gt;pg_mcv_list_items&lt;/code&gt; set-returning function.</source>
          <target state="translated">使用 &lt;code&gt;pg_mcv_list_items&lt;/code&gt; 设置返回函数可以检查MCV列表。</target>
        </trans-unit>
        <trans-unit id="ff17c423681bf713fcd55cb3b3eb644d120028a0" translate="yes" xml:space="preserve">
          <source>Inspired by the original &lt;code&gt;citext&lt;/code&gt; module by Donald Fraser.</source>
          <target state="translated">受Donald Fraser 最初的 &lt;code&gt;citext&lt;/code&gt; 模块启发。</target>
        </trans-unit>
        <trans-unit id="e2f807d3934f67c59236ce54638758a511971353" translate="yes" xml:space="preserve">
          <source>Install any custom shared object files (or DLLs) used by the old cluster into the new cluster, e.g. &lt;code&gt;pgcrypto.so&lt;/code&gt;, whether they are from &lt;code&gt;contrib&lt;/code&gt; or some other source. Do not install the schema definitions, e.g. &lt;code&gt;CREATE EXTENSION pgcrypto&lt;/code&gt;, because these will be upgraded from the old cluster. Also, any custom full text search files (dictionary, synonym, thesaurus, stop words) must also be copied to the new cluster.</source>
          <target state="translated">将旧集群使用的所有自定义共享对象文件（或DLL）安装到新集群中，例如 &lt;code&gt;pgcrypto.so&lt;/code&gt; ，无论它们来自 &lt;code&gt;contrib&lt;/code&gt; 还是其他来源。不要安装模式定义，例如 &lt;code&gt;CREATE EXTENSION pgcrypto&lt;/code&gt; ，因为它们将从旧集群中升级。另外，所有自定义全文搜索文件（词典，同义词，同义词库，停用词）也必须复制到新群集中。</target>
        </trans-unit>
        <trans-unit id="ad8735c38dbf2201c7954106ea9c90d304db5a72" translate="yes" xml:space="preserve">
          <source>Install any custom shared object files (or DLLs) used by the old cluster into the new cluster, e.g., &lt;code&gt;pgcrypto.so&lt;/code&gt;, whether they are from &lt;code&gt;contrib&lt;/code&gt; or some other source. Do not install the schema definitions, e.g., &lt;code&gt;CREATE EXTENSION pgcrypto&lt;/code&gt;, because these will be upgraded from the old cluster. Also, any custom full text search files (dictionary, synonym, thesaurus, stop words) must also be copied to the new cluster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a0968ed3e41692f76e13c55e2d74df0fcf64b5b" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;hstore&quot;&gt;hstore&lt;/a&gt; extension into the current database, placing its objects in schema &lt;code&gt;addons&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34a5a70619c2c19e2c9702b13c9847e5c653791a" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;hstore&quot;&gt;hstore&lt;/a&gt; extension into the current database:</source>
          <target state="translated">将&lt;a href=&quot;hstore&quot;&gt;hstore&lt;/a&gt;扩展安装到当前数据库中：</target>
        </trans-unit>
        <trans-unit id="04f7a627a6509f6c7b363a56555a0d35366acc62" translate="yes" xml:space="preserve">
          <source>Install the &lt;code&gt;postgres_fdw&lt;/code&gt; extension using &lt;a href=&quot;sql-createextension&quot;&gt;CREATE EXTENSION&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;sql-createextension&quot;&gt;CREATE EXTENSION&lt;/a&gt;安装 &lt;code&gt;postgres_fdw&lt;/code&gt; 扩展。</target>
        </trans-unit>
        <trans-unit id="9684579d3e7c9b1f5825f61e639d95625abccadc" translate="yes" xml:space="preserve">
          <source>Install the new server's binaries and support files. pg_upgrade is included in a default installation.</source>
          <target state="translated">安装新服务器的二进制文件和支持文件。pg_upgrade包含在默认安装中。</target>
        </trans-unit>
        <trans-unit id="cb2992c5a571b6edb98a5bf527c86c020a33e35d" translate="yes" xml:space="preserve">
          <source>Install the new version of PostgreSQL as outlined in &lt;a href=&quot;https://www.postgresql.org/docs/12/install-procedure.html&quot;&gt;Section 16.4&lt;/a&gt;.</source>
          <target state="translated">如&lt;a href=&quot;https://www.postgresql.org/docs/12/install-procedure.html&quot;&gt;16.4节&lt;/a&gt;所述安装新版本的PostgreSQL 。</target>
        </trans-unit>
        <trans-unit id="d7e4ec31b8bf1a9e0464c75a90e53710f79548e0" translate="yes" xml:space="preserve">
          <source>Install the new version of PostgreSQL as outlined in &lt;a href=&quot;https://www.postgresql.org/docs/13/install-procedure.html&quot;&gt;Section 16.4&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90075fb521dd4d59c46ee65abf78d28b40851d8c" translate="yes" xml:space="preserve">
          <source>Install the same custom shared object files on the new standbys that you installed in the new primary cluster.</source>
          <target state="translated">在新的主群集中安装的新备用机上安装相同的自定义共享对象文件。</target>
        </trans-unit>
        <trans-unit id="f0738ede58ba3533e9ba6fac10de77528d0eda5f" translate="yes" xml:space="preserve">
          <source>Installing an extension as superuser requires trusting that the extension's author wrote the extension installation script in a secure fashion. It is not terribly difficult for a malicious user to create trojan-horse objects that will compromise later execution of a carelessly-written extension script, allowing that user to acquire superuser privileges. However, trojan-horse objects are only hazardous if they are in the &lt;code&gt;search_path&lt;/code&gt; during script execution, meaning that they are in the extension's installation target schema or in the schema of some extension it depends on. Therefore, a good rule of thumb when dealing with extensions whose scripts have not been carefully vetted is to install them only into schemas for which CREATE privilege has not been and will not be granted to any untrusted users. Likewise for any extensions they depend on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00a4641a5ec01b91ac5755c29e1f7d10ca370b2e" translate="yes" xml:space="preserve">
          <source>Installing the &lt;code&gt;dict_int&lt;/code&gt; extension creates a text search template &lt;code&gt;intdict_template&lt;/code&gt; and a dictionary &lt;code&gt;intdict&lt;/code&gt; based on it, with the default parameters. You can alter the parameters, for example</source>
          <target state="translated">安装 &lt;code&gt;dict_int&lt;/code&gt; 扩展名会使用默认参数创建一个文本搜索模板 &lt;code&gt;intdict_template&lt;/code&gt; 和一个基于它的字典 &lt;code&gt;intdict&lt;/code&gt; 。您可以更改参数，例如</target>
        </trans-unit>
        <trans-unit id="88a4b249e71fce074c62157e59fbc27119675b0b" translate="yes" xml:space="preserve">
          <source>Installing the &lt;code&gt;dict_xsyn&lt;/code&gt; extension creates a text search template &lt;code&gt;xsyn_template&lt;/code&gt; and a dictionary &lt;code&gt;xsyn&lt;/code&gt; based on it, with default parameters. You can alter the parameters, for example</source>
          <target state="translated">安装 &lt;code&gt;dict_xsyn&lt;/code&gt; 扩展名会使用默认参数创建文本搜索模板 &lt;code&gt;xsyn_template&lt;/code&gt; 和基于该模板的字典 &lt;code&gt;xsyn&lt;/code&gt; 。您可以更改参数，例如</target>
        </trans-unit>
        <trans-unit id="cf52efd63633f939852f89750e72d737a7ef8451" translate="yes" xml:space="preserve">
          <source>Installing the &lt;code&gt;unaccent&lt;/code&gt; extension creates a text search template &lt;code&gt;unaccent&lt;/code&gt; and a dictionary &lt;code&gt;unaccent&lt;/code&gt; based on it. The &lt;code&gt;unaccent&lt;/code&gt; dictionary has the default parameter setting &lt;code&gt;RULES='unaccent'&lt;/code&gt;, which makes it immediately usable with the standard &lt;code&gt;unaccent.rules&lt;/code&gt; file. If you wish, you can alter the parameter, for example</source>
          <target state="translated">安装 &lt;code&gt;unaccent&lt;/code&gt; 扩展会创建文本搜索模板 &lt;code&gt;unaccent&lt;/code&gt; 和基于它的字典 &lt;code&gt;unaccent&lt;/code&gt; 。该 &lt;code&gt;unaccent&lt;/code&gt; 字典具有默认参数设定 &lt;code&gt;RULES='unaccent'&lt;/code&gt; ，这使得它立即与标准可用 &lt;code&gt;unaccent.rules&lt;/code&gt; 文件。如果需要，您可以更改参数，例如</target>
        </trans-unit>
        <trans-unit id="5f97f8775628e86310829ab9e8c465258ab92a5e" translate="yes" xml:space="preserve">
          <source>Instance</source>
          <target state="translated">Instance</target>
        </trans-unit>
        <trans-unit id="5b4ebcd87748b86d7b51facd78d76e7b88a0adf7" translate="yes" xml:space="preserve">
          <source>Instead of an expression, &lt;code&gt;*&lt;/code&gt; can be written in the output list as a shorthand for all the columns of the selected rows. Also, you can write &lt;code&gt;table_name.*&lt;/code&gt; as a shorthand for the columns coming from just that table. In these cases it is not possible to specify new names with &lt;code&gt;AS&lt;/code&gt;; the output column names will be the same as the table columns' names.</source>
          <target state="translated">可以将 &lt;code&gt;*&lt;/code&gt; 而不是表达式写为输出列表，作为所选行的所有列的简写。另外，您可以编写 &lt;code&gt;table_name.*&lt;/code&gt; 作为该表的列的简写。在这些情况下，无法使用 &lt;code&gt;AS&lt;/code&gt; 指定新名称；输出列名称将与表列名称相同。</target>
        </trans-unit>
        <trans-unit id="a6521c09d55a0d983da28cb3b1223e411f459cda" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;amgettuple&lt;/code&gt;, an index scan can be done with &lt;code&gt;amgetbitmap&lt;/code&gt; to fetch all tuples in one call. This can be noticeably more efficient than &lt;code&gt;amgettuple&lt;/code&gt; because it allows avoiding lock/unlock cycles within the access method. In principle &lt;code&gt;amgetbitmap&lt;/code&gt; should have the same effects as repeated &lt;code&gt;amgettuple&lt;/code&gt; calls, but we impose several restrictions to simplify matters. First of all, &lt;code&gt;amgetbitmap&lt;/code&gt; returns all tuples at once and marking or restoring scan positions isn't supported. Secondly, the tuples are returned in a bitmap which doesn't have any specific ordering, which is why &lt;code&gt;amgetbitmap&lt;/code&gt; doesn't take a &lt;code&gt;direction&lt;/code&gt; argument. (Ordering operators will never be supplied for such a scan, either.) Also, there is no provision for index-only scans with &lt;code&gt;amgetbitmap&lt;/code&gt;, since there is no way to return the contents of index tuples. Finally, &lt;code&gt;amgetbitmap&lt;/code&gt; does not guarantee any locking of the returned tuples, with implications spelled out in &lt;a href=&quot;index-locking&quot;&gt;Section 61.4&lt;/a&gt;.</source>
          <target state="translated">而不是使用 &lt;code&gt;amgettuple&lt;/code&gt; ，索引扫描是可以做到的 &lt;code&gt;amgetbitmap&lt;/code&gt; 在一个调用获取所有元组。与 &lt;code&gt;amgettuple&lt;/code&gt; 相比，这可以显着提高效率，因为它可以避免访问方法内的锁定/解锁周期。原则上， &lt;code&gt;amgetbitmap&lt;/code&gt; 应该具有与重复 &lt;code&gt;amgettuple&lt;/code&gt; 调用相同的效果，但是我们施加了一些限制来简化事务。首先， &lt;code&gt;amgetbitmap&lt;/code&gt; 一次返回所有元组，并且不支持标记或还原扫描位置。其次，在没有任何特定顺序的位图中返回元组，这就是为什么 &lt;code&gt;amgetbitmap&lt;/code&gt; 不会 &lt;code&gt;direction&lt;/code&gt; 论据。（也永远不会为此类扫描提供订购运算符。）而且，由于无法返回索引元组的内容，因此也没有提供使用 &lt;code&gt;amgetbitmap&lt;/code&gt; 进行仅索引扫描的规定。最后， &lt;code&gt;amgetbitmap&lt;/code&gt; 不保证对返回的元组进行任何锁定，其含义在&lt;a href=&quot;index-locking&quot;&gt;第61.4节中&lt;/a&gt;阐明。</target>
        </trans-unit>
        <trans-unit id="d79849f61d583b44d9d0fdc8025d98ffb5bbfd35" translate="yes" xml:space="preserve">
          <source>Instead of writing &lt;code&gt;ONLY&lt;/code&gt; before the table name, you can write &lt;code&gt;*&lt;/code&gt; after the table name to explicitly specify that descendant tables are included. There is no real reason to use this syntax any more, because searching descendant tables is now always the default behavior. However, it is supported for compatibility with older releases.</source>
          <target state="translated">而不是写的 &lt;code&gt;ONLY&lt;/code&gt; 表名之前，你可以写 &lt;code&gt;*&lt;/code&gt; 后的表名明确指定后代表都包括在内。没有真正的理由再使用此语法，因为搜索后代表现在始终是默认行为。但是，支持它与较早版本兼容。</target>
        </trans-unit>
        <trans-unit id="4a1635249102b1ddea4769929b8a71df3f648e09" translate="yes" xml:space="preserve">
          <source>Institute of Electrical and Electronics Engineers</source>
          <target state="translated">电气和电子工程师协会</target>
        </trans-unit>
        <trans-unit id="e877a09ab092ea6de15878a42ea4226bbdc6693d" translate="yes" xml:space="preserve">
          <source>Integer bit mask indicating which arguments are not being included in the current grouping set</source>
          <target state="translated">整数位掩码,表示哪些参数不包含在当前的分组集中。</target>
        </trans-unit>
        <trans-unit id="03c1016d0a2fd0151189914ddf3d90f010d5ee41" translate="yes" xml:space="preserve">
          <source>Integer quotient of &lt;em&gt;&lt;code&gt;y&lt;/code&gt;&lt;/em&gt;/&lt;em&gt;&lt;code&gt;x&lt;/code&gt;&lt;/em&gt; (truncates towards zero)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="897c83dd3fcb5ef382c1b65917bd9be2f5323fd2" translate="yes" xml:space="preserve">
          <source>Inter-Process Communication</source>
          <target state="translated">流程间通信</target>
        </trans-unit>
        <trans-unit id="d85d227df828a06ee1ce26f9f247a35c482de85a" translate="yes" xml:space="preserve">
          <source>Interesting idea for picking passwords.</source>
          <target state="translated">挑选密码的想法很有趣。</target>
        </trans-unit>
        <trans-unit id="457737863c2801b7971002cd15c9223e0c9b404e" translate="yes" xml:space="preserve">
          <source>Interfacing with monitoring software to report errors</source>
          <target state="translated">与监控软件对接,报告错误</target>
        </trans-unit>
        <trans-unit id="bc34e531672634aab3b26d4017b45aa2bbc7b3db" translate="yes" xml:space="preserve">
          <source>Interfacing with other backup and recovery software</source>
          <target state="translated">与其他备份和恢复软件的接口</target>
        </trans-unit>
        <trans-unit id="ec9a27bfbcfba0ca31c61c9c952115c2287d92f0" translate="yes" xml:space="preserve">
          <source>Intermediate certificates that chain up to existing root certificates can also appear in the &lt;a href=&quot;runtime-config-connection#GUC-SSL-CA-FILE&quot;&gt;ssl_ca_file&lt;/a&gt; file if you wish to avoid storing them on clients (assuming the root and intermediate certificates were created with &lt;code&gt;v3_ca&lt;/code&gt; extensions). Certificate Revocation List (CRL) entries are also checked if the parameter &lt;a href=&quot;runtime-config-connection#GUC-SSL-CRL-FILE&quot;&gt;ssl_crl_file&lt;/a&gt; is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="087813fa40caa10b888af01dbc97f7437b81b67d" translate="yes" xml:space="preserve">
          <source>Intermediate certificates that chain up to existing root certificates can also appear in the &lt;a href=&quot;runtime-config-connection#GUC-SSL-CA-FILE&quot;&gt;ssl_ca_file&lt;/a&gt; file if you wish to avoid storing them on clients (assuming the root and intermediate certificates were created with &lt;code&gt;v3_ca&lt;/code&gt; extensions). Certificate Revocation List (CRL) entries are also checked if the parameter &lt;a href=&quot;runtime-config-connection#GUC-SSL-CRL-FILE&quot;&gt;ssl_crl_file&lt;/a&gt; is set. (See &lt;a href=&quot;http://h41379.www4.hpe.com/doc/83final/ba554_90007/ch04s02.html&quot;&gt;http://h41379.www4.hpe.com/doc/83final/ba554_90007/ch04s02.html&lt;/a&gt; for diagrams showing SSL certificate usage.)</source>
          <target state="translated">如果希望避免将链接到现有根证书的中间证书显示在&lt;a href=&quot;runtime-config-connection#GUC-SSL-CA-FILE&quot;&gt;ssl_ca_file&lt;/a&gt;文件中（假设根证书和中间证书是使用 &lt;code&gt;v3_ca&lt;/code&gt; 扩展名创建的）。如果设置了参数&lt;a href=&quot;runtime-config-connection#GUC-SSL-CRL-FILE&quot;&gt;ssl_crl_file，&lt;/a&gt;还将检查证书吊销列表（CRL）条目。 （有关显示SSL证书使用的图表，请参见&lt;a href=&quot;http://h41379.www4.hpe.com/doc/83final/ba554_90007/ch04s02.html&quot;&gt;http://h41379.www4.hpe.com/doc/83final/ba554_90007/ch04s02.html&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="8784a00f8fa083e2a06f38fd51cc35a39bb77fca" translate="yes" xml:space="preserve">
          <source>Internal access to the system catalogs is not done using the isolation level of the current transaction. This means that newly created database objects such as tables are visible to concurrent Repeatable Read and Serializable transactions, even though the rows they contain are not. In contrast, queries that explicitly examine the system catalogs don't see rows representing concurrently created database objects, in the higher isolation levels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6ed083a1fd80d11b5474ab6a44b299da8513f67" translate="yes" xml:space="preserve">
          <source>Internal data structures such as &lt;code&gt;pg_xact&lt;/code&gt;, &lt;code&gt;pg_subtrans&lt;/code&gt;, &lt;code&gt;pg_multixact&lt;/code&gt;, &lt;code&gt;pg_serial&lt;/code&gt;, &lt;code&gt;pg_notify&lt;/code&gt;, &lt;code&gt;pg_stat&lt;/code&gt;, &lt;code&gt;pg_snapshots&lt;/code&gt; are not directly checksummed, nor are pages protected by full page writes. However, where such data structures are persistent, WAL records are written that allow recent changes to be accurately rebuilt at crash recovery and those WAL records are protected as discussed above.</source>
          <target state="translated">内部数据结构（例如 &lt;code&gt;pg_xact&lt;/code&gt; ， &lt;code&gt;pg_subtrans&lt;/code&gt; ， &lt;code&gt;pg_multixact&lt;/code&gt; ， &lt;code&gt;pg_serial&lt;/code&gt; ， &lt;code&gt;pg_notify&lt;/code&gt; ， &lt;code&gt;pg_stat&lt;/code&gt; ， &lt;code&gt;pg_snapshots&lt;/code&gt; )不会直接进行校验和，也不会受到整页写操作的保护。但是，在此类数据结构持久的情况下，将写入WAL记录，以允许在崩溃恢复时准确地重建最近的更改，并且如上所述保护了这些WAL记录。</target>
        </trans-unit>
        <trans-unit id="210293c0eebe094c6cf4191095ebf7c83ba53d58" translate="yes" xml:space="preserve">
          <source>Internal hash code, computed from the statement's parse tree</source>
          <target state="translated">内部哈希码,由语句的解析树计算而来。</target>
        </trans-unit>
        <trans-unit id="e2daadb2e211983a80b38897bed9d140e91cd8e5" translate="yes" xml:space="preserve">
          <source>Internally &lt;code&gt;interval&lt;/code&gt; values are stored as months, days, and seconds. This is done because the number of days in a month varies, and a day can have 23 or 25 hours if a daylight savings time adjustment is involved. The months and days fields are integers while the seconds field can store fractions. Because intervals are usually created from constant strings or &lt;code&gt;timestamp&lt;/code&gt; subtraction, this storage method works well in most cases, but can cause unexpected results:</source>
          <target state="translated">内部 &lt;code&gt;interval&lt;/code&gt; 值存储为月，天和秒。这样做是因为一个月中的天数不同，并且如果涉及夏令时调整，则一天可以有23或25个小时。月和日字段是整数，而秒字段可以存储分数。由于间隔通常是由常量字符串或 &lt;code&gt;timestamp&lt;/code&gt; 减法创建的，因此此存储方法在大多数情况下效果很好，但会导致意外结果：</target>
        </trans-unit>
        <trans-unit id="95d68b94ef37a16fd1db6257f62457d5c440b435" translate="yes" xml:space="preserve">
          <source>Internally, a GIN index contains a B-tree index constructed over keys, where each key is an element of one or more indexed items (a member of an array, for example) and where each tuple in a leaf page contains either a pointer to a B-tree of heap pointers (a &amp;ldquo;posting tree&amp;rdquo;), or a simple list of heap pointers (a &amp;ldquo;posting list&amp;rdquo;) when the list is small enough to fit into a single index tuple along with the key value. &lt;a href=&quot;gin-implementation#GIN-INTERNALS-FIGURE&quot;&gt;Figure 66.1&lt;/a&gt; illustrates these components of a GIN index.</source>
          <target state="translated">在内部，GIN索引包含在键上构造的B树索引，其中每个键是一个或多个索引项的元素（例如，数组的成员），并且叶页中的每个元组都包含指向堆指针的B树（&amp;ldquo;发布树&amp;rdquo;），或堆指针的简单列表（&amp;ldquo;发布列表&amp;rdquo;），当列表小到足以容纳单个索引元组和键值的时候。&lt;a href=&quot;gin-implementation#GIN-INTERNALS-FIGURE&quot;&gt;图66.1&lt;/a&gt;说明了GIN索引的这些组件。</target>
        </trans-unit>
        <trans-unit id="7c7cae0387037fdfc011139b31adb37771e499bb" translate="yes" xml:space="preserve">
          <source>Internally, all these types use the same representation (a 64-bit integer), and all are interchangeable. Multiple types are provided to control display formatting and to permit tighter validity checking of input that is supposed to denote one particular type of number.</source>
          <target state="translated">在内部,所有这些类型都使用相同的表示方法(64位整数),而且所有类型都可以互换。提供多种类型是为了控制显示格式,并允许更严格地检查应该表示某一特定类型数字的输入的有效性。</target>
        </trans-unit>
        <trans-unit id="801996043d0146904ef0a7b7426c0b0decab6e65" translate="yes" xml:space="preserve">
          <source>Internally, an LSN is a 64-bit integer, representing a byte position in the write-ahead log stream. It is printed as two hexadecimal numbers of up to 8 digits each, separated by a slash; for example, &lt;code&gt;16/B374D848&lt;/code&gt;. The &lt;code&gt;pg_lsn&lt;/code&gt; type supports the standard comparison operators, like &lt;code&gt;=&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;. Two LSNs can be subtracted using the &lt;code&gt;-&lt;/code&gt; operator; the result is the number of bytes separating those write-ahead log locations.</source>
          <target state="translated">在内部，LSN是64位整数，表示预写日志流中的字节位置。它以两个十六进制数字（每个数字最多8位）打印，并用斜杠分隔；例如 &lt;code&gt;16/B374D848&lt;/code&gt; 。所述 &lt;code&gt;pg_lsn&lt;/code&gt; 类型支持标准的比较运算符，像 &lt;code&gt;=&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&lt;/code&gt; 。可以使用 &lt;code&gt;-&lt;/code&gt; 运算符减去两个LSN ；结果是分隔这些预写日志位置的字节数。</target>
        </trans-unit>
        <trans-unit id="653edb0bfdb6bd20dfe7affb5776bc7d271237c7" translate="yes" xml:space="preserve">
          <source>Internals</source>
          <target state="translated">Internals</target>
        </trans-unit>
        <trans-unit id="68baab823cf9c4d570311e278e9e088b97918aa9" translate="yes" xml:space="preserve">
          <source>Internals: BRIN Indexes</source>
          <target state="translated">内部。BRIN指数</target>
        </trans-unit>
        <trans-unit id="30d8bd593f993584038a1e0fe42a81f00b0963a3" translate="yes" xml:space="preserve">
          <source>Internals: Catalogs</source>
          <target state="translated">内部。目录</target>
        </trans-unit>
        <trans-unit id="3af4bd3be7009ecb5492dd21a7a43e553ce2cd0e" translate="yes" xml:space="preserve">
          <source>Internals: GIN Indexes</source>
          <target state="translated">内部。GIN指数</target>
        </trans-unit>
        <trans-unit id="dc575f859035c87eddb3703eb9f32faa91a064d5" translate="yes" xml:space="preserve">
          <source>Internals: Genetic Query Optimizer</source>
          <target state="translated">内部。遗传查询优化器</target>
        </trans-unit>
        <trans-unit id="2fdd0d171f1a82304db06140f5b0e0b132641e9d" translate="yes" xml:space="preserve">
          <source>Internals: GiST Indexes</source>
          <target state="translated">内部。GiST指数</target>
        </trans-unit>
        <trans-unit id="3353317a88b7d0fe5733c291ee0c6066760bb027" translate="yes" xml:space="preserve">
          <source>Internals: Index Access Method</source>
          <target state="translated">内部。索引访问方法</target>
        </trans-unit>
        <trans-unit id="2cfa78663fb409507ad30892f6c62ca88915c849" translate="yes" xml:space="preserve">
          <source>Internals: Physical Storage</source>
          <target state="translated">内部结构。物理存储</target>
        </trans-unit>
        <trans-unit id="72bd21b653073da0193a18c2b147b4e07c551c2d" translate="yes" xml:space="preserve">
          <source>Internals: SP-GiST Indexes</source>
          <target state="translated">内部。SP-GiST指数</target>
        </trans-unit>
        <trans-unit id="9a4222dfc9fdc77f19f92dba6e20438075629f39" translate="yes" xml:space="preserve">
          <source>International Electrotechnical Commission</source>
          <target state="translated">国际电工委员会</target>
        </trans-unit>
        <trans-unit id="efd83bf4b70a77811c228aa3f499876839b1a079" translate="yes" xml:space="preserve">
          <source>International Organization for Standardization</source>
          <target state="translated">国际标准化组织</target>
        </trans-unit>
        <trans-unit id="2bafd8d16b13f2565f9ae12e4063fa2d0cddcfb9" translate="yes" xml:space="preserve">
          <source>International Standard Book Numbers to be displayed in the new EAN13 display format</source>
          <target state="translated">将以新的EAN13显示格式显示国际标准书号</target>
        </trans-unit>
        <trans-unit id="08b688b4eb6cf112f11ba47bac6e099bfb8d453f" translate="yes" xml:space="preserve">
          <source>International Standard Book Numbers to be displayed in the old short display format</source>
          <target state="translated">国际标准书号将以旧的简短显示格式显示。</target>
        </trans-unit>
        <trans-unit id="ebb2e09bb43f37cc7a01fd763ee8d3845536f4c8" translate="yes" xml:space="preserve">
          <source>International Standard Music Numbers to be displayed in the new EAN13 display format</source>
          <target state="translated">国际标准音乐编号将以新的EAN13显示格式显示。</target>
        </trans-unit>
        <trans-unit id="ef34d5e58a9ceadea54e7a66e1ff9112f05b0da0" translate="yes" xml:space="preserve">
          <source>International Standard Music Numbers to be displayed in the old short display format</source>
          <target state="translated">国际标准音乐编号将以旧的简短显示格式显示。</target>
        </trans-unit>
        <trans-unit id="8dd6340c1b5827c9a707b92916af32dcdcd785bc" translate="yes" xml:space="preserve">
          <source>International Standard Serial Number</source>
          <target state="translated">国际标准序列号</target>
        </trans-unit>
        <trans-unit id="4e1c1c5e087cdba177b1e3d204777d49f8f64412" translate="yes" xml:space="preserve">
          <source>International Standard Serial Numbers to be displayed in the new EAN13 display format</source>
          <target state="translated">以新的EAN13显示格式显示国际标准序列号。</target>
        </trans-unit>
        <trans-unit id="105b56360755198078a6d52573dd0840458a5750" translate="yes" xml:space="preserve">
          <source>International Standard Serial Numbers to be displayed in the old short display format</source>
          <target state="translated">国际标准序列号将以旧的简短显示格式显示。</target>
        </trans-unit>
        <trans-unit id="15470fd033e12b800743519c6e594f7da0f4f0f0" translate="yes" xml:space="preserve">
          <source>Interpretation</source>
          <target state="translated">Interpretation</target>
        </trans-unit>
        <trans-unit id="8fa33d4271f21b38b9499a714668d1694939db92" translate="yes" xml:space="preserve">
          <source>Interpreting Results</source>
          <target state="translated">解释结果</target>
        </trans-unit>
        <trans-unit id="27d548cba7b30ac38c7cf5611fd348dac11ee53d" translate="yes" xml:space="preserve">
          <source>Interpreting the actual data can only be done with information obtained from other tables, mostly &lt;code&gt;pg_attribute&lt;/code&gt;. The key values needed to identify field locations are &lt;code&gt;attlen&lt;/code&gt; and &lt;code&gt;attalign&lt;/code&gt;. There is no way to directly get a particular attribute, except when there are only fixed width fields and no null values. All this trickery is wrapped up in the functions &lt;em&gt;heap_getattr&lt;/em&gt;, &lt;em&gt;fastgetattr&lt;/em&gt; and &lt;em&gt;heap_getsysattr&lt;/em&gt;.</source>
          <target state="translated">只能使用从其他表（主要是 &lt;code&gt;pg_attribute&lt;/code&gt; )获得的信息来解释实际数据。识别现场位置所需的关键值是 &lt;code&gt;attlen&lt;/code&gt; 和 &lt;code&gt;attalign&lt;/code&gt; 。除了只有固定宽度的字段且没有空值时，否则无法直接获取特定属性。所有这些&lt;em&gt;技巧&lt;/em&gt;都包装在函数&lt;em&gt;heap_getattr&lt;/em&gt;，&lt;em&gt;fastgetattr&lt;/em&gt;和&lt;em&gt;heap_getsysattr中&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="24238f9afeb08c45bbce6cbe5bfc823ad38ca9fd" translate="yes" xml:space="preserve">
          <source>Intersects?</source>
          <target state="translated">Intersects?</target>
        </trans-unit>
        <trans-unit id="4e15cd1f984843596070878cf276c50b3a281208" translate="yes" xml:space="preserve">
          <source>Interval from &lt;code&gt;x&lt;/code&gt; - &lt;code&gt;delta&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; + &lt;code&gt;delta&lt;/code&gt;</source>
          <target state="translated">间隔从 &lt;code&gt;x&lt;/code&gt; - &lt;code&gt;delta&lt;/code&gt; 到 &lt;code&gt;x&lt;/code&gt; + &lt;code&gt;delta&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="264b54df84208c3c82823ada24d9901903b36609" translate="yes" xml:space="preserve">
          <source>Interval from &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;y&lt;/code&gt;</source>
          <target state="translated">从 &lt;code&gt;x&lt;/code&gt; 到 &lt;code&gt;y&lt;/code&gt; 的间隔</target>
        </trans-unit>
        <trans-unit id="d6c942376df50e42c9c8ec0a3deb9eba3459225b" translate="yes" xml:space="preserve">
          <source>Interval values can also be written as ISO 8601 time intervals, using either the &amp;ldquo;format with designators&amp;rdquo; of the standard's section 4.4.3.2 or the &amp;ldquo;alternative format&amp;rdquo; of section 4.4.3.3. The format with designators looks like this:</source>
          <target state="translated">使用标准第4.4.3.2节的&amp;ldquo;带有指示符的格式&amp;rdquo;或第4.4.3.3节的&amp;ldquo;替代格式&amp;rdquo;，也可以将间隔值写为ISO 8601时间间隔。带有指示符的格式如下：</target>
        </trans-unit>
        <trans-unit id="e96fd04cfd40c6866ae4fadc2523f325bbca5474" translate="yes" xml:space="preserve">
          <source>Intuitively, the larger the &lt;code&gt;parameter&lt;/code&gt;, the more frequently values close to &lt;code&gt;min&lt;/code&gt; are accessed, and the less frequently values close to &lt;code&gt;max&lt;/code&gt; are accessed. The closer to 0 &lt;code&gt;parameter&lt;/code&gt; is, the flatter (more uniform) the access distribution. A crude approximation of the distribution is that the most frequent 1% values in the range, close to &lt;code&gt;min&lt;/code&gt;, are drawn &lt;code&gt;parameter&lt;/code&gt;% of the time. The &lt;code&gt;parameter&lt;/code&gt; value must be strictly positive.</source>
          <target state="translated">直观地讲， &lt;code&gt;parameter&lt;/code&gt; 越大，接近 &lt;code&gt;min&lt;/code&gt; 的值访问的频率就越高，而接近 &lt;code&gt;max&lt;/code&gt; 的值访问的频率就越少。 &lt;code&gt;parameter&lt;/code&gt; 越接近0 ，访问分布越平坦（越均匀）。分布的粗略近似的是，在该范围的最频繁的1％的值，接近 &lt;code&gt;min&lt;/code&gt; ，绘制 &lt;code&gt;parameter&lt;/code&gt; 的时间％。该 &lt;code&gt;parameter&lt;/code&gt; 值必须是严格为正。</target>
        </trans-unit>
        <trans-unit id="fa5dcf3086d32573b28d785efef236569ee934d3" translate="yes" xml:space="preserve">
          <source>Inverse cosine, result in degrees</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65156637d01418342819a73cb6f0c84ed3aadd9b" translate="yes" xml:space="preserve">
          <source>Inverse cosine, result in radians</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="044acbc59a99d5be1dcd2df39272182f119202c9" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic cosine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa52c84bd7eb12aa1c433c5d2762f1447b2f7569" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic sine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2adf2990a26a6381a709615ea39f05a1bb69453" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic tangent</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76a2b17d6de61349537c2d6805d0dd47465a55e8" translate="yes" xml:space="preserve">
          <source>Inverse sine, result in degrees</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2443561103c4f30b566171f3e2681acb12058ea" translate="yes" xml:space="preserve">
          <source>Inverse sine, result in radians</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e43d0792058a59dfb9b5584a76b17083ea3f125" translate="yes" xml:space="preserve">
          <source>Inverse tangent of &lt;em&gt;&lt;code&gt;y&lt;/code&gt;&lt;/em&gt;/&lt;em&gt;&lt;code&gt;x&lt;/code&gt;&lt;/em&gt;, result in degrees</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43cbfde7a6966208306cd1536838dca692e6b35d" translate="yes" xml:space="preserve">
          <source>Inverse tangent of &lt;em&gt;&lt;code&gt;y&lt;/code&gt;&lt;/em&gt;/&lt;em&gt;&lt;code&gt;x&lt;/code&gt;&lt;/em&gt;, result in radians</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c7267a29db6fb274a599fb9151d3055e43e152d" translate="yes" xml:space="preserve">
          <source>Inverse tangent, result in degrees</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9e9282eef441e5d3e97532b28f7543960a0fda3" translate="yes" xml:space="preserve">
          <source>Inverse tangent, result in radians</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4c4d2a44d0c1732fb4957da686a2c8c6fd4c621" translate="yes" xml:space="preserve">
          <source>Inverse transition function for moving-aggregate mode (zero if none)</source>
          <target state="translated">移动-聚集模式的逆向过渡函数(如果没有,则为零)</target>
        </trans-unit>
        <trans-unit id="28b7eaaae619dbbc89f335962aef4470def2f3e3" translate="yes" xml:space="preserve">
          <source>Invoke &lt;code&gt;VACUUM&lt;/code&gt; on the standard tables.</source>
          <target state="translated">在标准表上调用 &lt;code&gt;VACUUM&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3018fd4dab61ebc08a8223638bc64040a2d9e057" translate="yes" xml:space="preserve">
          <source>Is above (allows touching)?</source>
          <target state="translated">以上是(允许触摸)?</target>
        </trans-unit>
        <trans-unit id="da6fc6925748c3c1aaf71338cad9d5f477a2383e" translate="yes" xml:space="preserve">
          <source>Is below (allows touching)?</source>
          <target state="translated">是下面(允许触摸)?</target>
        </trans-unit>
        <trans-unit id="4cde919e343d25f19646be89eb578d4418ea8a44" translate="yes" xml:space="preserve">
          <source>Is collation visible in search path?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa29522fdb9c9289837f5d8f7d870cd6a67b34d7" translate="yes" xml:space="preserve">
          <source>Is conversion visible in search path?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94be39b60eecf97da6c05767e63714ce3bb576d4" translate="yes" xml:space="preserve">
          <source>Is first &lt;code&gt;tsquery&lt;/code&gt; contained in the second? (This considers only whether all the lexemes appearing in one query appear in the other, ignoring the combining operators.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1572ea1eb7fef37d46de7513f84f0e67fb37082" translate="yes" xml:space="preserve">
          <source>Is first object above second (allows edges to touch)?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c505339eacef9319fd285351332723a55918638e" translate="yes" xml:space="preserve">
          <source>Is first object below second (allows edges to touch)?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5bac705c5e60b2475e9b17e98087c0990a2c946" translate="yes" xml:space="preserve">
          <source>Is first object contained in or on second? Available for these pairs of types: (&lt;code id=&quot;point&quot;&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;), (&lt;code&gt;point&lt;/code&gt;, &lt;code&gt;lseg&lt;/code&gt;), (&lt;code&gt;point&lt;/code&gt;, &lt;code&gt;line&lt;/code&gt;), (&lt;code&gt;point&lt;/code&gt;, &lt;code&gt;path&lt;/code&gt;), (&lt;code&gt;point&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;), (&lt;code&gt;point&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;), (&lt;code&gt;box&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;), (&lt;code&gt;lseg&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;), (&lt;code&gt;lseg&lt;/code&gt;, &lt;code&gt;line&lt;/code&gt;), (&lt;code&gt;polygon&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;), (&lt;code&gt;circle&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e54349160763b512bf27d165196d02b1f67231a" translate="yes" xml:space="preserve">
          <source>Is first object strictly above second? (This operator is misnamed; it should be &lt;code id=&quot;1246262&quot;&gt;|&amp;gt;&amp;gt;&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ba666af39de93d6cf6a684c0aa3dde8c77aa45b" translate="yes" xml:space="preserve">
          <source>Is first object strictly above second? Available for &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a74a8665c56409f78bc9b13ad274898bb226d641" translate="yes" xml:space="preserve">
          <source>Is first object strictly below second? (This operator is misnamed; it should be &lt;code id=&quot;6060124&quot;&gt;&amp;lt;&amp;lt;|&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bb75e79e36aeff0c7858d8fb478e380c0c08061" translate="yes" xml:space="preserve">
          <source>Is first object strictly below second? Available for &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82493964e24c37744bf5de6c7abddd6d617b2dbe" translate="yes" xml:space="preserve">
          <source>Is first object strictly left of second? Available for &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceb9750549fc2256498ec80ab691b24c888f4e5c" translate="yes" xml:space="preserve">
          <source>Is first object strictly right of second? Available for &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2352c4320a598b186beeca1fa33e9ebc446c5989" translate="yes" xml:space="preserve">
          <source>Is function visible in search path? (This also works for procedures and aggregates.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea56f04ac22e5eca73342cefd404d9c1b002af61" translate="yes" xml:space="preserve">
          <source>Is horizontal?</source>
          <target state="translated">是横向的吗?</target>
        </trans-unit>
        <trans-unit id="1818cd29919e00fd168940f58522c1a837de41d9" translate="yes" xml:space="preserve">
          <source>Is left argument a descendant of right (or equal)?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6269d3f15bfebe74c5b103d510d2f6af4fbb1be" translate="yes" xml:space="preserve">
          <source>Is left argument an ancestor of right (or equal)?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bfb83cf12d958867b468135803b461105b5e313" translate="yes" xml:space="preserve">
          <source>Is left array contained in right array?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="931e59a6570abe457c179e4beff2927ed26d2296" translate="yes" xml:space="preserve">
          <source>Is left operand contained in right?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="571e67a163dd7cbf36b6a8d1f61104a0a31bbc98" translate="yes" xml:space="preserve">
          <source>Is line horizontal?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1926a606e864164a6ebd58c12b6d35ee6a87c25" translate="yes" xml:space="preserve">
          <source>Is line vertical?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae143f55d7c085448a695f852ae27520ec5aa08b" translate="yes" xml:space="preserve">
          <source>Is operator class visible in search path?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5787d3510293778cafab6156a15c641287921cd" translate="yes" xml:space="preserve">
          <source>Is operator family visible in search path?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c15be0091b6642fd23724ba17d912f27c02d8aa" translate="yes" xml:space="preserve">
          <source>Is operator visible in search path?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07ef905d97492d046c005a27265c8219bcc2fb0c" translate="yes" xml:space="preserve">
          <source>Is path closed?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="692378f0378ddf6c5206700062aa1ea0e029afe6" translate="yes" xml:space="preserve">
          <source>Is path open?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9fe9c5adbc8c22895dcd6a5a3619390deb9964a" translate="yes" xml:space="preserve">
          <source>Is perpendicular?</source>
          <target state="translated">是垂直的吗?</target>
        </trans-unit>
        <trans-unit id="aee38f7bf2589d5e14735890024a26f0647e7b2b" translate="yes" xml:space="preserve">
          <source>Is row-level security active for the specified table in the context of the current user and current environment?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3bd90c2bab054cba48ad1eb7ff2752205acec58" translate="yes" xml:space="preserve">
          <source>Is statistics object visible in search path?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fefaf9d6dfa31078880e5655df30026e38004358" translate="yes" xml:space="preserve">
          <source>Is strictly above?</source>
          <target state="translated">是严格的以上?</target>
        </trans-unit>
        <trans-unit id="a05cc4a278817fbe41225c1212990f7a42609499" translate="yes" xml:space="preserve">
          <source>Is strictly below?</source>
          <target state="translated">是严格低于?</target>
        </trans-unit>
        <trans-unit id="b70722f5747da5b37c94b2e21f108653a4a0d9d2" translate="yes" xml:space="preserve">
          <source>Is strictly left of?</source>
          <target state="translated">是严格的左的?</target>
        </trans-unit>
        <trans-unit id="c41dadb911bf56e59cfeff92444afa779a0c9714" translate="yes" xml:space="preserve">
          <source>Is strictly right of?</source>
          <target state="translated">是严格的权利的?</target>
        </trans-unit>
        <trans-unit id="fd466dacfa71c9a3651034da3efd29046bfe7fec" translate="yes" xml:space="preserve">
          <source>Is subnet contained by or equal to subnet?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="608df21f03573c35e537fec94e301c9c05a0ef8c" translate="yes" xml:space="preserve">
          <source>Is subnet strictly contained by subnet? This operator, and the next four, test for subnet inclusion. They consider only the network parts of the two addresses (ignoring any bits to the right of the netmasks) and determine whether one network is identical to or a subnet of the other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46cc6fe87dd8470a9509c9da1c694aaec675334f" translate="yes" xml:space="preserve">
          <source>Is table visible in search path? (This works for all types of relations, including views, materialized views, indexes, sequences and foreign tables.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c16dfcb2d9f33c5ed1d4f60e7e94de5cdb8bb497" translate="yes" xml:space="preserve">
          <source>Is text search configuration visible in search path?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b171387fa6a48bfddce09bcc6374af3cb74ce2b7" translate="yes" xml:space="preserve">
          <source>Is text search dictionary visible in search path?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb8ecee88af93cf9199b28e0c89bec38e335e65b" translate="yes" xml:space="preserve">
          <source>Is text search parser visible in search path?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea7a21a45c17bac5fc36d8a030345a04d716413b" translate="yes" xml:space="preserve">
          <source>Is text search template visible in search path?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0992b021bae889bee0f11abcbb95dee7929e73aa" translate="yes" xml:space="preserve">
          <source>Is the collation deterministic?</source>
          <target state="translated">整理是确定性的吗?</target>
        </trans-unit>
        <trans-unit id="8a25c1b43d537dd1a7d2ddd1e8080433f5e3eacd" translate="yes" xml:space="preserve">
          <source>Is the constraint deferrable?</source>
          <target state="translated">该约束条件是否可以推迟?</target>
        </trans-unit>
        <trans-unit id="fef490f8fe9dee88c33c6a89d30667da1bd2fb9a" translate="yes" xml:space="preserve">
          <source>Is the constraint deferred by default?</source>
          <target state="translated">该约束是否默认为延期?</target>
        </trans-unit>
        <trans-unit id="f2477e67686fc75771da395271b903b89c805e05" translate="yes" xml:space="preserve">
          <source>Is the element contained in the range?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48e41905df707985819a963b62a733ad231a70af" translate="yes" xml:space="preserve">
          <source>Is the first &lt;code&gt;seg&lt;/code&gt; contained in the second?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c56a2a69c3c21bd55c585fa99939bf4f7fc0147c" translate="yes" xml:space="preserve">
          <source>Is the first &lt;code&gt;seg&lt;/code&gt; entirely to the left of the second? [a, b] &amp;lt;&amp;lt; [c, d] is true if b &amp;lt; c.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee8b00f339a2f532b4e9c2b55069412b977dc8e8" translate="yes" xml:space="preserve">
          <source>Is the first &lt;code&gt;seg&lt;/code&gt; entirely to the right of the second? [a, b] &amp;gt;&amp;gt; [c, d] is true if a &amp;gt; d.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aea89b97de3ee5955142d5113dfb9dcdb02c115c" translate="yes" xml:space="preserve">
          <source>Is the first JSON value contained in the second?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19d335f2a70cca44d7330f0d373f5cb2960385ef" translate="yes" xml:space="preserve">
          <source>Is the first array contained by the second?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07c8facc78abfeb194236811a0926e5445b93180" translate="yes" xml:space="preserve">
          <source>Is the first cube contained in the second?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e609c817143333de1521a8cf7a158b827be99cd2" translate="yes" xml:space="preserve">
          <source>Is the first range contained by the second?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68559d84b5ac88d0e9e0f63a5f0039af51bf0f9e" translate="yes" xml:space="preserve">
          <source>Is the first range strictly left of the second?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf2611d9965b16ffb44827feb465cfe43a1b6dc3" translate="yes" xml:space="preserve">
          <source>Is the first range strictly right of the second?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3225d84455e28cf3582ea057725108c97e83f30e" translate="yes" xml:space="preserve">
          <source>Is the given transaction ID &lt;em&gt;visible&lt;/em&gt; according to this snapshot (that is, was it completed before the snapshot was taken)? Note that this function will not give the correct answer for a subtransaction ID.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db516f5dadc3d5e25dea043648eeea3321f5ccdb" translate="yes" xml:space="preserve">
          <source>Is the page dirty?</source>
          <target state="translated">页面脏吗?</target>
        </trans-unit>
        <trans-unit id="7a5b28f2abec65dff2a005cef1bab93ce79757ac" translate="yes" xml:space="preserve">
          <source>Is the policy permissive or restrictive?</source>
          <target state="translated">该政策是允许性的还是限制性的?</target>
        </trans-unit>
        <trans-unit id="1c868da3e376b67ccb29be6664b407ae22b09b84" translate="yes" xml:space="preserve">
          <source>Is the range empty?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff182ac571c70913b62ea8bad05f34c331a87f89" translate="yes" xml:space="preserve">
          <source>Is the range's lower bound inclusive?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca739e6c1b1df7d98a703e7f4cf56e0c0b73eb1f" translate="yes" xml:space="preserve">
          <source>Is the range's lower bound infinite?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3f822412dc56d423cd1651a21ff0e5c86774082" translate="yes" xml:space="preserve">
          <source>Is the range's upper bound inclusive?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6edd78c835bde36ba19726c52d54bb7fc15f1a47" translate="yes" xml:space="preserve">
          <source>Is the range's upper bound infinite?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69a6303395c0e1b94086b05146ed59054275f0b9" translate="yes" xml:space="preserve">
          <source>Is type (or domain) visible in search path?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="272dd553360faca6d08c14d4f1b40a013a88fc82" translate="yes" xml:space="preserve">
          <source>Is vertical?</source>
          <target state="translated">是垂直的吗?</target>
        </trans-unit>
        <trans-unit id="616318d9db61d03876a33f8c27e6df459bd2eff6" translate="yes" xml:space="preserve">
          <source>Isolation</source>
          <target state="translated">Isolation</target>
        </trans-unit>
        <trans-unit id="04fa9226f0713bae8b60402f090506b8771675ec" translate="yes" xml:space="preserve">
          <source>Isolation Level</source>
          <target state="translated">隔离等级</target>
        </trans-unit>
        <trans-unit id="5ef461ce76cd9304ad8686fa89152e4b6011f931" translate="yes" xml:space="preserve">
          <source>Ispell dictionaries support splitting compound words; a useful feature. Notice that the affix file should specify a special flag using the &lt;code&gt;compoundwords controlled&lt;/code&gt; statement that marks dictionary words that can participate in compound formation:</source>
          <target state="translated">Ispell词典支持拆分复合词；一个有用的功能。请注意，词缀文件应使用由 &lt;code&gt;compoundwords controlled&lt;/code&gt; 语句指定特殊标志，该语句标记可参与复合形式的字典词：</target>
        </trans-unit>
        <trans-unit id="a44764c80f1ba0b240d3f5d527b95ad90a01a872" translate="yes" xml:space="preserve">
          <source>Ispell dictionaries usually recognize a limited set of words, so they should be followed by another broader dictionary; for example, a Snowball dictionary, which recognizes everything.</source>
          <target state="translated">Ispell词典通常只识别有限的一组单词,所以应该在它们之后再使用另一本更广泛的词典;例如,雪球词典,它可以识别所有的单词。</target>
        </trans-unit>
        <trans-unit id="d78243d5b6a6182e6f2ddf831b4aabfb7caae3f0" translate="yes" xml:space="preserve">
          <source>Issues a verification prompt before doing anything destructive.</source>
          <target state="translated">在进行任何破坏性操作之前,发出验证提示。</target>
        </trans-unit>
        <trans-unit id="f4c1344e1b107a94e97cb2d1c0387b09d48b1998" translate="yes" xml:space="preserve">
          <source>Issuing &lt;code&gt;ABORT&lt;/code&gt; outside of a transaction block emits a warning and otherwise has no effect.</source>
          <target state="translated">在事务块之外发出 &lt;code&gt;ABORT&lt;/code&gt; 会发出警告，否则无效。</target>
        </trans-unit>
        <trans-unit id="51092034eb6099bfab57ce2cf44c57b972ed851c" translate="yes" xml:space="preserve">
          <source>Issuing &lt;code&gt;BEGIN&lt;/code&gt; when already inside a transaction block will provoke a warning message. The state of the transaction is not affected. To nest transactions within a transaction block, use savepoints (see &lt;a href=&quot;sql-savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;).</source>
          <target state="translated">如果已经在事务块中，则发出 &lt;code&gt;BEGIN&lt;/code&gt; 会发出警告消息。交易状态不受影响。要将事务嵌套在事务块中，请使用保存点（请参见&lt;a href=&quot;sql-savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1c66e92badb172759ea8ab0365668fbc4bfcd29b" translate="yes" xml:space="preserve">
          <source>Issuing &lt;code&gt;COMMIT&lt;/code&gt; when not inside a transaction does no harm, but it will provoke a warning message. &lt;code&gt;COMMIT AND CHAIN&lt;/code&gt; when not inside a transaction is an error.</source>
          <target state="translated">如果不在事务内部，则发出 &lt;code&gt;COMMIT&lt;/code&gt; 无害，但会引发警告消息。如果不在事务内，则 &lt;code&gt;COMMIT AND CHAIN&lt;/code&gt; 是错误的。</target>
        </trans-unit>
        <trans-unit id="d8f2914a3de77623d7fcc2d76c1402e19f0682c2" translate="yes" xml:space="preserve">
          <source>Issuing &lt;code&gt;END&lt;/code&gt; when not inside a transaction does no harm, but it will provoke a warning message.</source>
          <target state="translated">如果不在事务内部，则发出 &lt;code&gt;END&lt;/code&gt; 不会造成任何危害，但是会引发警告消息。</target>
        </trans-unit>
        <trans-unit id="9a3f1f230232d57deb86f9d1d1a7e859eaa17234" translate="yes" xml:space="preserve">
          <source>Issuing &lt;code&gt;ROLLBACK&lt;/code&gt; outside of a transaction block emits a warning and otherwise has no effect. &lt;code&gt;ROLLBACK AND CHAIN&lt;/code&gt; outside of a transaction block is an error.</source>
          <target state="translated">在事务块外部发出 &lt;code&gt;ROLLBACK&lt;/code&gt; 会发出警告，否则无效。事务块外部的 &lt;code&gt;ROLLBACK AND CHAIN&lt;/code&gt; 是错误。</target>
        </trans-unit>
        <trans-unit id="1dd72b5f30a56642ade69ef87bd0dd32591ebc8c" translate="yes" xml:space="preserve">
          <source>It can be used as a top-level command or as a space-saving syntax variant in parts of complex queries. Only the &lt;code&gt;WITH&lt;/code&gt;, &lt;code&gt;UNION&lt;/code&gt;, &lt;code&gt;INTERSECT&lt;/code&gt;, &lt;code&gt;EXCEPT&lt;/code&gt;, &lt;code&gt;ORDER BY&lt;/code&gt;, &lt;code&gt;LIMIT&lt;/code&gt;, &lt;code&gt;OFFSET&lt;/code&gt;, &lt;code&gt;FETCH&lt;/code&gt; and &lt;code&gt;FOR&lt;/code&gt; locking clauses can be used with &lt;code&gt;TABLE&lt;/code&gt;; the &lt;code&gt;WHERE&lt;/code&gt; clause and any form of aggregation cannot be used.</source>
          <target state="translated">在部分复杂查询中，它可用作顶级命令或节省空间的语法变体。 &lt;code&gt;TABLE&lt;/code&gt; 只能 &lt;code&gt;WITH&lt;/code&gt; ， &lt;code&gt;UNION&lt;/code&gt; ， &lt;code&gt;INTERSECT&lt;/code&gt; ， &lt;code&gt;EXCEPT&lt;/code&gt; ， &lt;code&gt;ORDER BY&lt;/code&gt; ， &lt;code&gt;LIMIT&lt;/code&gt; ， &lt;code&gt;OFFSET&lt;/code&gt; ， &lt;code&gt;FETCH&lt;/code&gt; 和 &lt;code&gt;FOR&lt;/code&gt; 锁定子句; 的 &lt;code&gt;WHERE&lt;/code&gt; 子句和任何形式的聚集不能使用。</target>
        </trans-unit>
        <trans-unit id="985845c593d43702ba4580f789c62a95ef3e445a" translate="yes" xml:space="preserve">
          <source>It can return 2 special key IDs:</source>
          <target state="translated">它可以返回2个特殊的密钥ID。</target>
        </trans-unit>
        <trans-unit id="e06e730d80da388853db0ab9a33a7b2a082e1e65" translate="yes" xml:space="preserve">
          <source>It creates a replication-mode connection, so it is subject to the same constraints as &lt;a href=&quot;app-pgreceivewal&quot;&gt;pg_receivewal&lt;/a&gt;, plus those for logical replication (see &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;).</source>
          <target state="translated">它创建了一个复制模式连接，因此它受到与&lt;a href=&quot;app-pgreceivewal&quot;&gt;pg_receivewal&lt;/a&gt;相同的约束以及逻辑复制的约束（请参阅&lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;第48章&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="34093efa4b222287cf39e63aac85890d7758d772" translate="yes" xml:space="preserve">
          <source>It creates a replication-mode connection, so it is subject to the same constraints as &lt;a href=&quot;app-pgreceivewal&quot;&gt;pg_receivewal&lt;/a&gt;, plus those for logical replication (see &lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee4e1383f1e9f315e70a9d76f0a1946de5a791a1" translate="yes" xml:space="preserve">
          <source>It does not matter which order the opposite corners of a cube are entered in. The &lt;code&gt;cube&lt;/code&gt; functions automatically swap values if needed to create a uniform &amp;ldquo;lower left &amp;mdash; upper right&amp;rdquo; internal representation. When the corners coincide, &lt;code&gt;cube&lt;/code&gt; stores only one corner along with an &amp;ldquo;is point&amp;rdquo; flag to avoid wasting space.</source>
          <target state="translated">输入多维数据集相对角的顺序无关紧要。如果需要， &lt;code&gt;cube&lt;/code&gt; 函数会自动交换值以创建统一的&amp;ldquo;左下-右上&amp;rdquo;内部表示形式。当拐角重合时， &lt;code&gt;cube&lt;/code&gt; 仅存储一个拐角以及&amp;ldquo; is point&amp;rdquo;标志，以避免浪费空间。</target>
        </trans-unit>
        <trans-unit id="aeb260c8d10781feddd45ff6a16008fdceb285b4" translate="yes" xml:space="preserve">
          <source>It does so by first creating all possible &lt;em&gt;paths&lt;/em&gt; leading to the same result. For example if there is an index on a relation to be scanned, there are two paths for the scan. One possibility is a simple sequential scan and the other possibility is to use the index. Next the cost for the execution of each path is estimated and the cheapest path is chosen. The cheapest path is expanded into a complete plan that the executor can use.</source>
          <target state="translated">为此，首先创建所有可能导致相同结果的&lt;em&gt;路径&lt;/em&gt;。例如，如果要扫描的关系上有索引，则有两个扫描路径。一种可能性是简单的顺序扫描，另一种可能性是使用索引。接下来，估计每个路径的执行成本，并选择最便宜的路径。最便宜的路径被扩展为执行者可以使用的完整计划。</target>
        </trans-unit>
        <trans-unit id="22062c54b59724e3ba4ff79971e8d1516ebd1cef" translate="yes" xml:space="preserve">
          <source>It does this by skipping pages that have only visible tuples according to the visibility map (if a page has the corresponding VM bit set, then it is assumed to contain no dead tuples). For such pages, it derives the free space value from the free space map, and assumes that the rest of the space on the page is taken up by live tuples.</source>
          <target state="translated">它通过跳过那些根据可见性地图只有可见元组的页面来实现这一目的(如果一个页面有相应的 VM 位设置,那么假定它不包含死元组)。对于这样的页面,它从自由空间图中得出自由空间值,并假设页面上其余的空间被活元组占用。</target>
        </trans-unit>
        <trans-unit id="289bb6de0c119ae341fea7727f0ae465a6ffb7a2" translate="yes" xml:space="preserve">
          <source>It is &lt;em&gt;not&lt;/em&gt; recommended that you override this behavior by changing the session-level settings of these parameters; that is likely to cause &lt;code&gt;postgres_fdw&lt;/code&gt; to malfunction.</source>
          <target state="translated">这是&lt;em&gt;不&lt;/em&gt;建议您通过改变这些参数的会话级设置将覆盖此行为; 这很可能导致 &lt;code&gt;postgres_fdw&lt;/code&gt; 发生故障。</target>
        </trans-unit>
        <trans-unit id="1927f65da9f3267669c003e30b5762ebad0dc5a9" translate="yes" xml:space="preserve">
          <source>It is a good idea to save the database server's log output somewhere, rather than just discarding it via &lt;code&gt;/dev/null&lt;/code&gt;. The log output is invaluable when diagnosing problems. However, the log output tends to be voluminous (especially at higher debug levels) so you won't want to save it indefinitely. You need to &lt;em&gt;rotate&lt;/em&gt; the log files so that new log files are started and old ones removed after a reasonable period of time.</source>
          <target state="translated">将数据库服务器的日志输出保存在某处是一个好主意，而不仅仅是通过 &lt;code&gt;/dev/null&lt;/code&gt; 丢弃它。诊断问题时，日志输出非常宝贵。但是，日志输出往往非常庞大（尤其是在较高的调试级别），因此您将不会无限期地保存它。您需要&lt;em&gt;旋转&lt;/em&gt;日志文件，以便在合理的时间后启动新的日志文件并删除旧的日志文件。</target>
        </trans-unit>
        <trans-unit id="45d3adbb3df378f5fff436872f95f728d888325a" translate="yes" xml:space="preserve">
          <source>It is advantageous if the log is located on a different disk from the main database files. This can be achieved by moving the &lt;code&gt;pg_wal&lt;/code&gt; directory to another location (while the server is shut down, of course) and creating a symbolic link from the original location in the main data directory to the new location.</source>
          <target state="translated">如果日志与主数据库文件位于不同的磁盘上，则是有利的。这可以通过将 &lt;code&gt;pg_wal&lt;/code&gt; 目录移动到另一个位置（当然，在关闭服务器时）并创建一个从主数据目录中的原始位置到新位置的符号链接来实现。</target>
        </trans-unit>
        <trans-unit id="25c2883a31f29210a79363008b59988d33c5a31b" translate="yes" xml:space="preserve">
          <source>It is advisable to set &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt; to a reasonably large value (but not more than the amount of RAM you can dedicate to the &lt;code&gt;CLUSTER&lt;/code&gt; operation) before clustering.</source>
          <target state="translated">建议在群集之前将&lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt;设置为一个较大的值（但不要大于您可以用于 &lt;code&gt;CLUSTER&lt;/code&gt; 操作的RAM数量）。</target>
        </trans-unit>
        <trans-unit id="f4c2ed49f12a870b96cb954dbc625ee0c439a239" translate="yes" xml:space="preserve">
          <source>It is advisable to test your proposed archive command to ensure that it indeed does not overwrite an existing file, &lt;em&gt;and that it returns nonzero status in this case&lt;/em&gt;. The example command above for Unix ensures this by including a separate &lt;code&gt;test&lt;/code&gt; step. On some Unix platforms, &lt;code&gt;cp&lt;/code&gt; has switches such as &lt;code&gt;-i&lt;/code&gt; that can be used to do the same thing less verbosely, but you should not rely on these without verifying that the right exit status is returned. (In particular, GNU &lt;code&gt;cp&lt;/code&gt; will return status zero when &lt;code&gt;-i&lt;/code&gt; is used and the target file already exists, which is &lt;em&gt;not&lt;/em&gt; the desired behavior.)</source>
          <target state="translated">建议测试建议的归档命令以确保它确实不会覆盖现有文件，&lt;em&gt;并且在这种情况下返回非零状态&lt;/em&gt;。上面针对Unix的示例命令通过包含一个单独的 &lt;code&gt;test&lt;/code&gt; 步骤来确保这一点。在某些Unix平台上， &lt;code&gt;cp&lt;/code&gt; 具有诸如 &lt;code&gt;-i&lt;/code&gt; 之类的开关，这些开关可用于更轻松地完成相同的操作，但是在不验证是否返回了正确的退出状态的情况下，请不要依赖这些开关。 （特别是，当使用 &lt;code&gt;-i&lt;/code&gt; 并且目标文件已经存在时，GNU &lt;code&gt;cp&lt;/code&gt; 将返回状态零，这&lt;em&gt;不是&lt;/em&gt;期望的行为。）&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5ccc1a490a09faccece314c281e5a4bacdabe99b" translate="yes" xml:space="preserve">
          <source>It is also important to consider the overhead of partitioning during query planning and execution. The query planner is generally able to handle partition hierarchies with up to a few thousand partitions fairly well, provided that typical queries allow the query planner to prune all but a small number of partitions. Planning times become longer and memory consumption becomes higher when more partitions remain after the planner performs partition pruning. This is particularly true for the &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; commands. Another reason to be concerned about having a large number of partitions is that the server's memory consumption may grow significantly over a period of time, especially if many sessions touch large numbers of partitions. That's because each partition requires its metadata to be loaded into the local memory of each session that touches it.</source>
          <target state="translated">在查询计划和执行过程中考虑分区的开销也很重要。查询计划程序通常能够很好地处理多达数千个分区的分区层次结构，前提是典型的查询允许查询计划程序修剪除少数分区以外的所有分区。在计划者执行分区修剪后，如果剩余更多的分区，则计划时间会更长，内存消耗也会更高。对于 &lt;code&gt;UPDATE&lt;/code&gt; 和 &lt;code&gt;DELETE&lt;/code&gt; 尤其如此命令。担心拥有大量分区的另一个原因是，服务器的内存消耗可能会在一段时间内显着增长，尤其是在许多会话接触大量分区的情况下。这是因为每个分区都需要将其元数据加载到与之接触的每个会话的本地内存中。</target>
        </trans-unit>
        <trans-unit id="08e56c7bbb1c5c1ca45ba0adfbd971830db5b40e" translate="yes" xml:space="preserve">
          <source>It is also possible to access the file as a foreign table, using the supplied &lt;a href=&quot;file-fdw&quot;&gt;file_fdw&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8a8c0ea8274eada7feb8d1cce002d08a07341cc" translate="yes" xml:space="preserve">
          <source>It is also possible to construct an array from the results of a subquery. In this form, the array constructor is written with the key word &lt;code&gt;ARRAY&lt;/code&gt; followed by a parenthesized (not bracketed) subquery. For example:</source>
          <target state="translated">也可以根据子查询的结果构造一个数组。在这种形式中，数组构造函数是用关键字 &lt;code&gt;ARRAY&lt;/code&gt; 编写的，其后是带括号的（未括在括号中）子查询。例如：</target>
        </trans-unit>
        <trans-unit id="21db650c844a5c99fb809ce100bf6bab36b3a9c1" translate="yes" xml:space="preserve">
          <source>It is also possible to create a chain of trust that includes intermediate certificates:</source>
          <target state="translated">也可以建立一个包括中间证书的信任链。</target>
        </trans-unit>
        <trans-unit id="1bbde7dfe5218957bc7115e4bb121f93797376d5" translate="yes" xml:space="preserve">
          <source>It is also possible to implement record-based log shipping using this alternative method, though this requires custom development, and changes will still only become visible to hot standby queries after a full WAL file has been shipped.</source>
          <target state="translated">也可以使用这种替代方法实现基于记录的日志运输,不过这需要定制开发,而且只有在完整的WAL文件被运输后,更改仍然会变得对热备查询可见。</target>
        </trans-unit>
        <trans-unit id="a889ddd9646ac2e435b2d44d186929390a588c8e" translate="yes" xml:space="preserve">
          <source>It is also possible to insert the result of a query (which might be no rows, one row, or many rows):</source>
          <target state="translated">也可以插入一个查询的结果(可能是无行、一行或多行)。</target>
        </trans-unit>
        <trans-unit id="23dc30a3752f1a0512f87d6b42f04212daedc525" translate="yes" xml:space="preserve">
          <source>It is also possible to make a backup while the server is stopped. In this case, you obviously cannot use &lt;code&gt;pg_start_backup&lt;/code&gt; or &lt;code&gt;pg_stop_backup&lt;/code&gt;, and you will therefore be left to your own devices to keep track of which backup is which and how far back the associated WAL files go. It is generally better to follow the continuous archiving procedure above.</source>
          <target state="translated">服务器停止时也可以进行备份。在这种情况下，您显然不能使用 &lt;code&gt;pg_start_backup&lt;/code&gt; 或 &lt;code&gt;pg_stop_backup&lt;/code&gt; ，因此将留给自己的设备来跟踪哪个备份是哪个备份以及关联的WAL文件返回多长时间。通常最好遵循上面的连续归档过程。</target>
        </trans-unit>
        <trans-unit id="6383187f9793f49474de63c9c18fca5ed6c8c44d" translate="yes" xml:space="preserve">
          <source>It is also possible to pass a page to &lt;code&gt;bt_page_items&lt;/code&gt; as a &lt;code&gt;bytea&lt;/code&gt; value. A page image obtained with &lt;code&gt;get_raw_page&lt;/code&gt; should be passed as argument. So the last example could also be rewritten like this:</source>
          <target state="translated">也可以将页面作为 &lt;code&gt;bytea&lt;/code&gt; 值传递给 &lt;code&gt;bt_page_items&lt;/code&gt; 。使用 &lt;code&gt;get_raw_page&lt;/code&gt; 获得的页面图像应作为参数传递。因此，最后一个示例也可以这样重写：</target>
        </trans-unit>
        <trans-unit id="44f6da252a14d7892790fa503a4f493737f34471" translate="yes" xml:space="preserve">
          <source>It is also possible to specify a type cast using a function-like syntax:</source>
          <target state="translated">也可以使用类似函数的语法来指定类型转换。</target>
        </trans-unit>
        <trans-unit id="da0d70336d913c862f76912f7ff4b7d2cecbbfee" translate="yes" xml:space="preserve">
          <source>It is also possible to specify a type coercion using a function-like syntax:</source>
          <target state="translated">也可以使用类似函数的语法来指定类型胁迫。</target>
        </trans-unit>
        <trans-unit id="6ce33e1d5683bd1e633283bcca0d2a1c2815c050" translate="yes" xml:space="preserve">
          <source>It is also possible to tie a session default to a specific database rather than to a role; see &lt;a href=&quot;sql-alterdatabase&quot;&gt;ALTER DATABASE&lt;/a&gt;. If there is a conflict, database-role-specific settings override role-specific ones, which in turn override database-specific ones.</source>
          <target state="translated">也可以将会话默认值绑定到特定的数据库而不是角色。请参阅&lt;a href=&quot;sql-alterdatabase&quot;&gt;ALTER DATABASE&lt;/a&gt;。如果存在冲突，则特定于数据库角色的设置将覆盖特定于角色的设置，而这些角色又将覆盖特定于数据库的角色。</target>
        </trans-unit>
        <trans-unit id="752073224562183bf86377a6f918beef1da4c653" translate="yes" xml:space="preserve">
          <source>It is also possible to tie a session default to a specific role rather than to a database; see &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt;. Role-specific settings override database-specific ones if there is a conflict.</source>
          <target state="translated">也可以将会话默认值绑定到特定角色，而不是数据库。请参阅&lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt;。如果存在冲突，特定于角色的设置将覆盖特定于数据库的设置。</target>
        </trans-unit>
        <trans-unit id="c7b08ca18ddba24ea9814754a2d56bec9634faff" translate="yes" xml:space="preserve">
          <source>It is also possible to use arbitrary expressions in the &lt;code&gt;ORDER BY&lt;/code&gt; clause, including columns that do not appear in the &lt;code&gt;SELECT&lt;/code&gt; output list. Thus the following statement is valid:</source>
          <target state="translated">还可以在 &lt;code&gt;ORDER BY&lt;/code&gt; 子句中使用任意表达式，包括未出现在 &lt;code&gt;SELECT&lt;/code&gt; 输出列表中的列。因此，以下语句是有效的：</target>
        </trans-unit>
        <trans-unit id="f4e580c8b0c33e188baa71c64a617a90c70459e7" translate="yes" xml:space="preserve">
          <source>It is also possible to use logical replication methods to create a standby server with the updated version of PostgreSQL. This is possible because logical replication supports replication between different major versions of PostgreSQL. The standby can be on the same computer or a different computer. Once it has synced up with the master server (running the older version of PostgreSQL), you can switch masters and make the standby the master and shut down the older database instance. Such a switch-over results in only several seconds of downtime for an upgrade.</source>
          <target state="translated">也可以使用逻辑复制方法来创建一个更新版本的PostgreSQL的备用服务器。之所以能够做到这一点,是因为逻辑复制支持PostgreSQL不同主要版本之间的复制。备用可以在同一台计算机上,也可以在不同的计算机上。一旦它与主服务器(运行旧版本的PostgreSQL)同步,你就可以切换主服务器,让备用服务器成为主服务器,并关闭旧数据库实例。这样的切换导致升级只需要几秒钟的停机时间。</target>
        </trans-unit>
        <trans-unit id="2f14f1cce0e64f81899ff66a139003d88acce025" translate="yes" xml:space="preserve">
          <source>It is an error to mix configuration options for simple bind with options for search+bind.</source>
          <target state="translated">将简单绑定的配置选项与搜索+绑定的选项混用是错误的。</target>
        </trans-unit>
        <trans-unit id="8a93dfee21deef6822077b576885ec96bea313d5" translate="yes" xml:space="preserve">
          <source>It is best not to use SIGKILL to shut down the server. Doing so will prevent the server from releasing shared memory and semaphores. Furthermore, SIGKILL kills the &lt;code&gt;postgres&lt;/code&gt; process without letting it relay the signal to its subprocesses, so it might be necessary to kill the individual subprocesses by hand as well.</source>
          <target state="translated">最好不要使用SIGKILL关闭服务器。这样做将防止服务器释放共享内存和信号灯。此外，SIGKILL会杀死 &lt;code&gt;postgres&lt;/code&gt; 进程而不让其将信号中继到其子进程，因此可能也有必要手动杀死各个子进程。</target>
        </trans-unit>
        <trans-unit id="03425b40ae836e9eabd64694b0fe5bdd09ab82f4" translate="yes" xml:space="preserve">
          <source>It is best not to use parallelism when restoring from an archive made with this option, because pg_restore will not know exactly which partition(s) a given archive data item will load data into. This could result in inefficiency due to lock conflicts between parallel jobs, or perhaps even reload failures due to foreign key constraints being set up before all the relevant data is loaded.</source>
          <target state="translated">当从使用该选项制作的归档中恢复时,最好不要使用并行,因为pg_restore不会准确知道给定的归档数据项会将数据加载到哪个分区。这可能会导致并行作业之间的锁冲突而导致效率低下,甚至可能在所有相关数据加载之前,由于外键约束被设置而导致重载失败。</target>
        </trans-unit>
        <trans-unit id="98e38adf41282f06a6bcba53d9fb2cad2cffe8b4" translate="yes" xml:space="preserve">
          <source>It is common for a client that executes &lt;code&gt;NOTIFY&lt;/code&gt; to be listening on the same notification channel itself. In that case it will get back a notification event, just like all the other listening sessions. Depending on the application logic, this could result in useless work, for example, reading a database table to find the same updates that that session just wrote out. It is possible to avoid such extra work by noticing whether the notifying session's server process PID (supplied in the notification event message) is the same as one's own session's PID (available from libpq). When they are the same, the notification event is one's own work bouncing back, and can be ignored.</source>
          <target state="translated">执行 &lt;code&gt;NOTIFY&lt;/code&gt; 的客户端通常在同一通知通道上进行监听。在这种情况下，它将像其他所有监听会话一样返回通知事件。根据应用程序逻辑，这可能会导致无用的工作，例如，读取数据库表以查找该会话刚刚写出的相同更新。通过通知通知会话的服务器进程PID（在通知事件消息中提供）是否与自己会话的PID（可从libpq获得）相同，可以避免此类额外的工作。当它们相同时，通知事件就是一个人自己的工作反弹，可以忽略。</target>
        </trans-unit>
        <trans-unit id="c9caa8dc8a351442eebfc90a7900dd2df9e2e966" translate="yes" xml:space="preserve">
          <source>It is common to see slow queries running bad execution plans because multiple columns used in the query clauses are correlated. The planner normally assumes that multiple conditions are independent of each other, an assumption that does not hold when column values are correlated. Regular statistics, because of their per-individual-column nature, cannot capture any knowledge about cross-column correlation. However, PostgreSQL has the ability to compute &lt;em&gt;multivariate statistics&lt;/em&gt;, which can capture such information.</source>
          <target state="translated">通常会看到慢速查询运行错误的执行计划，因为查询子句中使用的多个列是相关的。计划者通常假设多个条件是相互独立的，当列值相关时，这种假设不成立。常规统计数据由于其基于每个列的性质而无法捕获有关跨列相关性的任何知识。但是，PostgreSQL具有计算&lt;em&gt;多元统计信息&lt;/em&gt;的能力，可以捕获此类信息。</target>
        </trans-unit>
        <trans-unit id="716e43860306866d146f9c899994b23176f3323e" translate="yes" xml:space="preserve">
          <source>It is difficult to formulate a general procedure for determining which indexes to create. There are a number of typical cases that have been shown in the examples throughout the previous sections. A good deal of experimentation is often necessary. The rest of this section gives some tips for that:</source>
          <target state="translated">很难制定一个确定创建哪些索引的一般程序。前面几节的例子中已经说明了一些典型的情况。通常需要进行大量的实验。本节的其余部分将为此提供一些提示。</target>
        </trans-unit>
        <trans-unit id="8e2e75db678536414073cb564abf9bafb8f65d0c" translate="yes" xml:space="preserve">
          <source>It is easy to find your largest tables and indexes using this information:</source>
          <target state="translated">使用这些信息可以很容易地找到你最大的表和索引。</target>
        </trans-unit>
        <trans-unit id="e1f4af27f8aaeea1d69cd838327e07079c59b331" translate="yes" xml:space="preserve">
          <source>It is encrypted using the public key and put into the session key packet.</source>
          <target state="translated">它使用公钥加密并放入会话密钥包中。</target>
        </trans-unit>
        <trans-unit id="c1facaa0d2b2d45958e470a68a811dfa56fbe0cc" translate="yes" xml:space="preserve">
          <source>It is especially fatal to use very small test data sets. While selecting 1000 out of 100000 rows could be a candidate for an index, selecting 1 out of 100 rows will hardly be, because the 100 rows probably fit within a single disk page, and there is no plan that can beat sequentially fetching 1 disk page.</source>
          <target state="translated">使用很小的测试数据集尤其致命。虽然从100000行中选择1000行可以成为索引的候选者,但从100行中选择1行却很难成为索引的候选者,因为这100行可能适合在一个磁盘页内,没有任何计划可以胜过依次取1个磁盘页。</target>
        </trans-unit>
        <trans-unit id="19ad949d23432743231dc352c6a17b2b375d15f1" translate="yes" xml:space="preserve">
          <source>It is essential that the same parameters are passed in order to obtain matching XML data mappings and XML Schema documents.</source>
          <target state="translated">为了获得匹配的XML数据映射和XML Schema文档,必须传递相同的参数。</target>
        </trans-unit>
        <trans-unit id="3a50daa221b6ada829c86621c1e1031f8d10ee63" translate="yes" xml:space="preserve">
          <source>It is even possible for repeated executions of the same &lt;code&gt;LIMIT&lt;/code&gt; query to return different subsets of the rows of a table, if there is not an &lt;code&gt;ORDER BY&lt;/code&gt; to enforce selection of a deterministic subset. Again, this is not a bug; determinism of the results is simply not guaranteed in such a case.</source>
          <target state="translated">如果没有 &lt;code&gt;ORDER BY&lt;/code&gt; 来强制选择确定性子集，则甚至可以重复执行同一 &lt;code&gt;LIMIT&lt;/code&gt; 查询来返回表行的不同子集。再次，这不是错误；在这种情况下，不能保证结果的确定性。</target>
        </trans-unit>
        <trans-unit id="10042e013ab2c07aefb508d6fa86ca0af029f7db" translate="yes" xml:space="preserve">
          <source>It is frequently convenient to group users together to ease management of privileges: that way, privileges can be granted to, or revoked from, a group as a whole. In PostgreSQL this is done by creating a role that represents the group, and then granting &lt;em&gt;membership&lt;/em&gt; in the group role to individual user roles.</source>
          <target state="translated">通常，将用户分组在一起以简化特权管理非常方便：这样，可以将特权授予或撤消整个组。在PostgreSQL中，这是通过创建代表组的角色，然后将组角色的&lt;em&gt;成员资格&lt;/em&gt;授予各个用户角色来完成的。</target>
        </trans-unit>
        <trans-unit id="c7233cabce0e70bf9b6042d864213cd71aa539f4" translate="yes" xml:space="preserve">
          <source>It is generally recommended that the columns of a foreign table be declared with exactly the same data types, and collations if applicable, as the referenced columns of the remote table. Although &lt;code&gt;postgres_fdw&lt;/code&gt; is currently rather forgiving about performing data type conversions at need, surprising semantic anomalies may arise when types or collations do not match, due to the remote server interpreting &lt;code&gt;WHERE&lt;/code&gt; clauses slightly differently from the local server.</source>
          <target state="translated">通常建议使用与远程表的引用列完全相同的数据类型和排序规则来声明外部表的列。尽管 &lt;code&gt;postgres_fdw&lt;/code&gt; 目前相当宽容地根据需要执行数据类型转换，但是由于远程服务器对 &lt;code&gt;WHERE&lt;/code&gt; 子句的解释与本地服务器的解释略有不同，当类型或排序规则不匹配时，可能会出现令人惊讶的语义异常。</target>
        </trans-unit>
        <trans-unit id="e59537e8306049dacf2891d27c403a8ccf0ae6a3" translate="yes" xml:space="preserve">
          <source>It is generally recommended to use &lt;code&gt;FOR UPDATE&lt;/code&gt; if the cursor is intended to be used with &lt;code&gt;UPDATE ... WHERE CURRENT OF&lt;/code&gt; or &lt;code&gt;DELETE ... WHERE CURRENT OF&lt;/code&gt;. Using &lt;code&gt;FOR UPDATE&lt;/code&gt; prevents other sessions from changing the rows between the time they are fetched and the time they are updated. Without &lt;code&gt;FOR UPDATE&lt;/code&gt;, a subsequent &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; command will have no effect if the row was changed since the cursor was created.</source>
          <target state="translated">如果游标打算与 &lt;code&gt;UPDATE ... WHERE CURRENT OF&lt;/code&gt; 或 &lt;code&gt;DELETE ... WHERE CURRENT OF&lt;/code&gt; 一起使用，通常建议使用 &lt;code&gt;FOR UPDATE&lt;/code&gt; 。使用 &lt;code&gt;FOR UPDATE&lt;/code&gt; 可以防止其他会话在获取行和更新行之间更改行。如果没有 &lt;code&gt;FOR UPDATE&lt;/code&gt; ，则如果自创建游标以来更改了行，则后续的 &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; 命令将无效。</target>
        </trans-unit>
        <trans-unit id="a83872fa85fd0323d70dd24a91d302ff7029d1c0" translate="yes" xml:space="preserve">
          <source>It is good practice to create a role that has the &lt;code&gt;CREATEDB&lt;/code&gt; and &lt;code&gt;CREATEROLE&lt;/code&gt; privileges, but is not a superuser, and then use this role for all routine management of databases and roles. This approach avoids the dangers of operating as a superuser for tasks that do not really require it.</source>
          <target state="translated">优良作法是创建一个具有 &lt;code&gt;CREATEDB&lt;/code&gt; 和 &lt;code&gt;CREATEROLE&lt;/code&gt; 特权但不是超级用户的角色，然后将此角色用于数据库和角色的所有常规管理。这种方法避免了以超级用户身份执行不需要真正执行任务的危险。</target>
        </trans-unit>
        <trans-unit id="de68fd3161d79a0dbb9addbaa913d55e1165d0a6" translate="yes" xml:space="preserve">
          <source>It is important for the command to return a zero exit status only if it succeeds. The command &lt;em&gt;will&lt;/em&gt; be asked for file names that are not present in the archive; it must return nonzero when so asked. Examples:</source>
          <target state="translated">重要的是，命令必须成功才能返回零退出状态。系统&lt;em&gt;将&lt;/em&gt;要求该命令提供归档文件中不存在的文件名。要求时，它必须返回非零。例子：</target>
        </trans-unit>
        <trans-unit id="cf6c5b8023371ed1577875e84b0b18cba96de2de" translate="yes" xml:space="preserve">
          <source>It is important that the &lt;em&gt;&lt;code&gt;branch_delim&lt;/code&gt;&lt;/em&gt; string not appear in any key values, else &lt;code&gt;connectby&lt;/code&gt; may incorrectly report an infinite-recursion error. Note that if &lt;em&gt;&lt;code&gt;branch_delim&lt;/code&gt;&lt;/em&gt; is not provided, a default value of &lt;code&gt;~&lt;/code&gt; is used for recursion detection purposes.</source>
          <target state="translated">重要的是，&lt;em&gt; &lt;code&gt;branch_delim&lt;/code&gt; &lt;/em&gt;字符串不要出现在任何键值中，否则 &lt;code&gt;connectby&lt;/code&gt; 可能会错误地报告无限递归错误。请注意，如果未提供&lt;em&gt; &lt;code&gt;branch_delim&lt;/code&gt; &lt;/em&gt;，则将 &lt;code&gt;~&lt;/code&gt; 的默认值用于递归检测。</target>
        </trans-unit>
        <trans-unit id="b1ae60071a0616a68a075f0ef2a5eb0bf24ed27b" translate="yes" xml:space="preserve">
          <source>It is important that the administrator select appropriate settings for &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay&lt;/a&gt;. The best choices vary depending on business priorities. For example if the server is primarily tasked as a High Availability server, then you will want low delay settings, perhaps even zero, though that is a very aggressive setting. If the standby server is tasked as an additional server for decision support queries then it might be acceptable to set the maximum delay values to many hours, or even -1 which means wait forever for queries to complete.</source>
          <target state="translated">管理员必须为&lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt;和&lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay&lt;/a&gt;选择适当的设置，这一点很重要。最佳选择取决于业务优先级。例如，如果服务器主要被用作高可用性服务器，那么您将需要低延迟设置，甚至可能为零，尽管这是非常激进的设置。如果将备用服务器用作决策支持查询的其他服务器，则可以将最大延迟值设置为多个小时甚至为-1，这是可以接受的，这意味着永远等待查询完成。</target>
        </trans-unit>
        <trans-unit id="261ccf1229f9ce7bf8e5f6c3bd334b4a4c87db09" translate="yes" xml:space="preserve">
          <source>It is important that the archive command return zero exit status if and only if it succeeds. Upon getting a zero result, PostgreSQL will assume that the file has been successfully archived, and will remove or recycle it. However, a nonzero status tells PostgreSQL that the file was not archived; it will try again periodically until it succeeds.</source>
          <target state="translated">重要的是,归档命令只有在成功的情况下才会返回零的退出状态。当得到零的结果时,PostgreSQL会认为文件已经成功归档,并将其删除或回收。然而,一个非零的状态告诉PostgreSQL,文件没有被归档;它将周期性地再次尝试,直到成功。</target>
        </trans-unit>
        <trans-unit id="696e699e4bfd8bcf4f4c70ae89306a775c1076ba" translate="yes" xml:space="preserve">
          <source>It is important that the command return nonzero exit status on failure. The command &lt;em&gt;will&lt;/em&gt; be called requesting files that are not present in the archive; it must return nonzero when so asked. This is not an error condition. An exception is that if the command was terminated by a signal (other than SIGTERM, which is used as part of a database server shutdown) or an error by the shell (such as command not found), then recovery will abort and the server will not start up.</source>
          <target state="translated">重要的是，命令在失败时返回非零退出状态。该命令&lt;em&gt;将&lt;/em&gt;被称为请求归档文件中不存在的文件。要求时，它必须返回非零。这不是错误情况。例外是，如果命令被信号终止（SIGTERM除外，SIGTERM用作数据库服务器关闭的一部分），或者shell出错（例如未找到命令），则恢复将中止，服务器将终止无法启动。</target>
        </trans-unit>
        <trans-unit id="23edc6be4b94044ef5894353c32ee9e7375bcbf5" translate="yes" xml:space="preserve">
          <source>It is important to note that the ranking functions do not use any global information, so it is impossible to produce a fair normalization to 1% or 100% as sometimes desired. Normalization option 32 (&lt;code&gt;rank/(rank+1)&lt;/code&gt;) can be applied to scale all ranks into the range zero to one, but of course this is just a cosmetic change; it will not affect the ordering of the search results.</source>
          <target state="translated">重要的是要注意，排名函数不使用任何全局信息，因此有时无法将公平归一化到1％或100％。可以使用规格化选项32（ &lt;code&gt;rank/(rank+1)&lt;/code&gt; ）将所有等级缩放到零到一的范围，但这当然只是表面上的改变；它不会影响搜索结果的顺序。</target>
        </trans-unit>
        <trans-unit id="52fc312b2cbf7e2b75157d95cff3456da87ba73a" translate="yes" xml:space="preserve">
          <source>It is important to note that the validation which is performed by pg_verifybackup does not and can not include every check which will be performed by a running server when attempting to make use of the backup. Even if you use this tool, you should still perform test restores and verify that the resulting databases work as expected and that they appear to contain the correct data. However, pg_verifybackup can detect many problems that commonly occur due to storage problems or user error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a6953b33213a41a821ecf81913686f5a307e4e2" translate="yes" xml:space="preserve">
          <source>It is important to store the server's stdout and stderr output somewhere, as shown above. It will help for auditing purposes and to diagnose problems. (See &lt;a href=&quot;logfile-maintenance&quot;&gt;Section 24.3&lt;/a&gt; for a more thorough discussion of log file handling.)</source>
          <target state="translated">如上所示，将服务器的stdout和stderr输出存储在某处很重要。这将有助于审核和诊断问题。（有关日志文件处理的更详尽讨论，请参见&lt;a href=&quot;logfile-maintenance&quot;&gt;第24.3节&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="0c277ac6ce904cf376b200217f724f1a32321205" translate="yes" xml:space="preserve">
          <source>It is important to understand before studying &lt;a href=&quot;sql-keywords-appendix#KEYWORDS-TABLE&quot;&gt;Table C.1&lt;/a&gt; that the fact that a key word is not reserved in PostgreSQL does not mean that the feature related to the word is not implemented. Conversely, the presence of a key word does not indicate the existence of a feature.</source>
          <target state="translated">在研究&lt;a href=&quot;sql-keywords-appendix#KEYWORDS-TABLE&quot;&gt;表C.1&lt;/a&gt;之前，必须了解一个事实，即在PostgreSQL中未保留关键字这一事实并不意味着未实现与该单词相关的功能，这一点很重要。相反，关键字的存在并不表示特征的存在。</target>
        </trans-unit>
        <trans-unit id="2afb84d06182545308e408bb344e52041de5bb4d" translate="yes" xml:space="preserve">
          <source>It is important to understand that the &lt;code&gt;tsvector&lt;/code&gt; type itself does not perform any word normalization; it assumes the words it is given are normalized appropriately for the application. For example,</source>
          <target state="translated">重要的是要了解 &lt;code&gt;tsvector&lt;/code&gt; 类型本身不会执行任何单词标准化。它假定给出的单词已针对该应用程序进行了规范化。例如，</target>
        </trans-unit>
        <trans-unit id="2fc0b9aee575bb88d3b3c3db08a354cd3df94678" translate="yes" xml:space="preserve">
          <source>It is important to understand the interaction between aggregates and SQL's &lt;code&gt;WHERE&lt;/code&gt; and &lt;code&gt;HAVING&lt;/code&gt; clauses. The fundamental difference between &lt;code&gt;WHERE&lt;/code&gt; and &lt;code&gt;HAVING&lt;/code&gt; is this: &lt;code&gt;WHERE&lt;/code&gt; selects input rows before groups and aggregates are computed (thus, it controls which rows go into the aggregate computation), whereas &lt;code&gt;HAVING&lt;/code&gt; selects group rows after groups and aggregates are computed. Thus, the &lt;code&gt;WHERE&lt;/code&gt; clause must not contain aggregate functions; it makes no sense to try to use an aggregate to determine which rows will be inputs to the aggregates. On the other hand, the &lt;code&gt;HAVING&lt;/code&gt; clause always contains aggregate functions. (Strictly speaking, you are allowed to write a &lt;code&gt;HAVING&lt;/code&gt; clause that doesn't use aggregates, but it's seldom useful. The same condition could be used more efficiently at the &lt;code&gt;WHERE&lt;/code&gt; stage.)</source>
          <target state="translated">了解聚合与SQL的 &lt;code&gt;WHERE&lt;/code&gt; 和 &lt;code&gt;HAVING&lt;/code&gt; 子句之间的交互非常重要。 &lt;code&gt;WHERE&lt;/code&gt; 和 &lt;code&gt;HAVING&lt;/code&gt; 之间的根本区别是： &lt;code&gt;WHERE&lt;/code&gt; 在计算组和聚合之前选择输入行（因此，它控制哪些行进入聚合计算），而 &lt;code&gt;HAVING&lt;/code&gt; 在计算组和聚合之后选择输入行。因此， &lt;code&gt;WHERE&lt;/code&gt; 子句不能包含聚合函数；尝试使用聚合来确定哪些行将被输入聚合是没有意义的。在另一方面， &lt;code&gt;HAVING&lt;/code&gt; 子句始终包含聚合函数。（严格来说，允许您编写不使用聚合的 &lt;code&gt;HAVING&lt;/code&gt; 子句，但是它很少有用。在 &lt;code&gt;WHERE&lt;/code&gt; 阶段可以更有效地使用相同的条件。）</target>
        </trans-unit>
        <trans-unit id="d6f798bec767ce149f1b4884b54e8874f501f623" translate="yes" xml:space="preserve">
          <source>It is legitimate to create a &lt;code&gt;pg_cast&lt;/code&gt; entry in which the source and target types are the same, if the associated function takes more than one argument. Such entries represent &amp;ldquo;length coercion functions&amp;rdquo; that coerce values of the type to be legal for a particular type modifier value.</source>
          <target state="translated">如果关联函数接受多个参数，则在源和目标类型相同的情况下创建 &lt;code&gt;pg_cast&lt;/code&gt; 条目是合法的。这样的条目表示&amp;ldquo;长度强制函数&amp;rdquo;，其强制类型的值对特定类型修饰符值合法。</target>
        </trans-unit>
        <trans-unit id="dbc1f490f7774fb666f596c4d1e1fe3642c52d33" translate="yes" xml:space="preserve">
          <source>It is likely that &lt;code&gt;pg_pltemplate&lt;/code&gt; will be removed in some future release of PostgreSQL, in favor of keeping this knowledge about procedural languages in their respective extension installation scripts.</source>
          <target state="translated">可能会在将来的Pos​​tgreSQL发行版中删除 &lt;code&gt;pg_pltemplate&lt;/code&gt; ,以便在各自的扩展安装脚本中保留有关过程语言的知识。</target>
        </trans-unit>
        <trans-unit id="6bb4f0fbbfb491190c393dc7c8ea60757b692676" translate="yes" xml:space="preserve">
          <source>It is normally not necessary to create casts between user-defined types and the standard string types (&lt;code&gt;text&lt;/code&gt;, &lt;code&gt;varchar&lt;/code&gt;, and &lt;code&gt;char(n)&lt;/code&gt;, as well as user-defined types that are defined to be in the string category). PostgreSQL provides automatic I/O conversion casts for that. The automatic casts to string types are treated as assignment casts, while the automatic casts from string types are explicit-only. You can override this behavior by declaring your own cast to replace an automatic cast, but usually the only reason to do so is if you want the conversion to be more easily invokable than the standard assignment-only or explicit-only setting. Another possible reason is that you want the conversion to behave differently from the type's I/O function; but that is sufficiently surprising that you should think twice about whether it's a good idea. (A small number of the built-in types do indeed have different behaviors for conversions, mostly because of requirements of the SQL standard.)</source>
          <target state="translated">通常无需在用户定义的类型和标准字符串类型（ &lt;code&gt;text&lt;/code&gt; ， &lt;code&gt;varchar&lt;/code&gt; 和 &lt;code&gt;char(n)&lt;/code&gt; )之间创建强制类型转换。，以及定义在字符串类别中的用户定义类型）。 PostgreSQL为此提供了自动的I / O转换转换。字符串类型的自动强制转换被视为赋值强制转换，而字符串类型的自动强制转换仅是显式的。您可以通过声明自己的强制转换来替换自动强制转换来覆盖此行为，但是通常这样做的唯一原因是，如果您希望转换比标准仅分配或仅显式设置更容易调用。另一个可能的原因是，您希望转换的行为与类型的I / O功能不同。但这令人惊讶，您应该三思而后行。 （确实有少数内置类型的转换行为不同，主要是因为SQL标准的要求。）</target>
        </trans-unit>
        <trans-unit id="f92a52d7559ea7c6c8c28ba12e1fa17dfea96688" translate="yes" xml:space="preserve">
          <source>It is not allowed to combine &lt;code&gt;connect&lt;/code&gt; set to &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;enabled&lt;/code&gt;, &lt;code&gt;create_slot&lt;/code&gt;, or &lt;code&gt;copy_data&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">不允许将 &lt;code&gt;connect&lt;/code&gt; 设置为 &lt;code&gt;false&lt;/code&gt; 并将 &lt;code&gt;enabled&lt;/code&gt; ， &lt;code&gt;create_slot&lt;/code&gt; 或 &lt;code&gt;copy_data&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 组合在一起。</target>
        </trans-unit>
        <trans-unit id="072c5ad8d293ff2ada18ad71b639cc19ab727e57" translate="yes" xml:space="preserve">
          <source>It is not currently allowed to &lt;code&gt;PREPARE&lt;/code&gt; a transaction that has executed any operations involving temporary tables or the session's temporary namespace, created any cursors &lt;code&gt;WITH HOLD&lt;/code&gt;, or executed &lt;code&gt;LISTEN&lt;/code&gt;, &lt;code&gt;UNLISTEN&lt;/code&gt;, or &lt;code&gt;NOTIFY&lt;/code&gt;. Those features are too tightly tied to the current session to be useful in a transaction to be prepared.</source>
          <target state="translated">当前不允许 &lt;code&gt;PREPARE&lt;/code&gt; 执行已执行涉及临时表或会话的临时名称空间的任何操作，创建任何具有 &lt;code&gt;WITH HOLD&lt;/code&gt; 的游标或执行 &lt;code&gt;LISTEN&lt;/code&gt; ， &lt;code&gt;UNLISTEN&lt;/code&gt; 或 &lt;code&gt;NOTIFY&lt;/code&gt; 的事务。这些功能与当前会话紧密相关，无法在要准备的事务中使用。</target>
        </trans-unit>
        <trans-unit id="683c463d18b1311e371770a1d3375c3bacddce8d" translate="yes" xml:space="preserve">
          <source>It is not important to which database you connect here since the script file created by pg_dumpall will contain the appropriate commands to create and connect to the saved databases. An exception is that if you specified &lt;code&gt;--clean&lt;/code&gt;, you must connect to the &lt;code&gt;postgres&lt;/code&gt; database initially; the script will attempt to drop other databases immediately, and that will fail for the database you are connected to.</source>
          <target state="translated">在这里连接哪个数据库并不重要，因为pg_dumpall创建的脚本文件将包含用于创建和连接到保存的数据库的适当命令。一个例外是，如果您指定 &lt;code&gt;--clean&lt;/code&gt; ，则必须首先连接到 &lt;code&gt;postgres&lt;/code&gt; 数据库；该脚本将尝试立即删除其他数据库，并且对于您连接到的数据库将失败。</target>
        </trans-unit>
        <trans-unit id="1b796566a4506096f72ab10f4b43942e3c90636a" translate="yes" xml:space="preserve">
          <source>It is not necessary to add the root certificate to &lt;code&gt;server.crt&lt;/code&gt;. Instead, clients must have the root certificate of the server's certificate chain.</source>
          <target state="translated">无需将根证书添加到 &lt;code&gt;server.crt&lt;/code&gt; 。而是，客户端必须具有服务器证书链的根证书。</target>
        </trans-unit>
        <trans-unit id="c4d12fc72842b14e61904a6ec6e02667bd4e3ff1" translate="yes" xml:space="preserve">
          <source>It is not necessary to be concerned about the amount of time it takes to make a base backup. However, if you normally run the server with &lt;code&gt;full_page_writes&lt;/code&gt; disabled, you might notice a drop in performance while the backup runs since &lt;code&gt;full_page_writes&lt;/code&gt; is effectively forced on during backup mode.</source>
          <target state="translated">不必担心进行基本备份所花费的时间。但是，如果通常在禁用 &lt;code&gt;full_page_writes&lt;/code&gt; 的情况下运行服务器，则在备份运行时可能会注意到性能下降，因为在备份模式下会有效地强制启用 &lt;code&gt;full_page_writes&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aca7caa9402f8a163da6c6daa7fb30a56a74a363" translate="yes" xml:space="preserve">
          <source>It is not necessary to create table constraints describing partition boundary condition for partitions. Instead, partition constraints are generated implicitly from the partition bound specification whenever there is need to refer to them.</source>
          <target state="translated">没有必要为分区创建描述分区边界条件的表约束。相反,只要需要引用分区约束条件,分区约束条件就会从分区边界规范中隐式生成。</target>
        </trans-unit>
        <trans-unit id="cf0a2da0ce7b363dca7ad51ebb38c128a6e8bc4b" translate="yes" xml:space="preserve">
          <source>It is not necessary to implement this function for access methods which do not support parallel scans or for which the number of additional bytes of storage required is zero.</source>
          <target state="translated">对于不支持并行扫描的访问方法,或者所需的额外存储字节数为零的访问方法,没有必要实现这个功能。</target>
        </trans-unit>
        <trans-unit id="81e24e9944e94aaaad52d26039e5ac57f4d46637" translate="yes" xml:space="preserve">
          <source>It is not necessary to implement this function for access methods which do not support parallel scans or in cases where the shared memory space required needs no initialization.</source>
          <target state="translated">对于不支持并行扫描的访问方法,或者所需的共享内存空间不需要初始化的情况,没有必要实现这个功能。</target>
        </trans-unit>
        <trans-unit id="57e901fbd76f488aaa546e02fcd890de2339da2b" translate="yes" xml:space="preserve">
          <source>It is not necessary to provide both of these functions. If one is not specified, the language-specific default behavior will be used if necessary. (To prevent a transformation in a certain direction from happening at all, you could also write a transform function that always errors out.)</source>
          <target state="translated">没有必要同时提供这两个函数。如果没有指定其中一个,必要时将使用特定语言的默认行为。(为了防止某个方向的转换根本不发生,你也可以写一个总是出错的转换函数。)</target>
        </trans-unit>
        <trans-unit id="8c2adbe3f4bf051ef1858dcf0e81ceda3ba80d46" translate="yes" xml:space="preserve">
          <source>It is not necessary to replay the WAL entries all the way to the end. We could stop the replay at any point and have a consistent snapshot of the database as it was at that time. Thus, this technique supports &lt;em&gt;point-in-time recovery&lt;/em&gt;: it is possible to restore the database to its state at any time since your base backup was taken.</source>
          <target state="translated">不必一直重复播放WAL条目。我们可以在任何时候停止重播，并获得与当时相同的数据库快照。因此，该技术支持&lt;em&gt;时间点恢复&lt;/em&gt;：自从进行基本备份以来，可以随时将数据库恢复到其状态。</target>
        </trans-unit>
        <trans-unit id="ff889e8c8e60f8ff7137e71a9bfef2608859eeae" translate="yes" xml:space="preserve">
          <source>It is not necessary to supply correct user name, password, or database name values to obtain the server status; however, if incorrect values are provided, the server will log a failed connection attempt.</source>
          <target state="translated">不需要提供正确的用户名、密码或数据库名来获取服务器状态;但是,如果提供了不正确的值,服务器将记录一个失败的连接尝试。</target>
        </trans-unit>
        <trans-unit id="594a9711ffec0cdfe29afe713704c6029ca7c0e7" translate="yes" xml:space="preserve">
          <source>It is not necessary to use the &lt;code&gt;sync&lt;/code&gt; mount option. The behavior of the &lt;code&gt;async&lt;/code&gt; option is sufficient, since PostgreSQL issues &lt;code&gt;fsync&lt;/code&gt; calls at appropriate times to flush the write caches. (This is analogous to how it works on a local file system.) However, it is strongly recommended to use the &lt;code&gt;sync&lt;/code&gt; export option on the NFS &lt;em&gt;server&lt;/em&gt; on systems where it exists (mainly Linux). Otherwise, an &lt;code&gt;fsync&lt;/code&gt; or equivalent on the NFS client is not actually guaranteed to reach permanent storage on the server, which could cause corruption similar to running with the parameter &lt;a href=&quot;runtime-config-wal#GUC-FSYNC&quot;&gt;fsync&lt;/a&gt; off. The defaults of these mount and export options differ between vendors and versions, so it is recommended to check and perhaps specify them explicitly in any case to avoid any ambiguity.</source>
          <target state="translated">不需要使用 &lt;code&gt;sync&lt;/code&gt; 安装选项。 &lt;code&gt;async&lt;/code&gt; 选项的行为就足够了，因为PostgreSQL 在适当的时候发出 &lt;code&gt;fsync&lt;/code&gt; 调用来刷新写缓存。 （这类似于它在本地文件系统上的工作方式。）但是，强烈建议在存在该文件的系统（主要是Linux）上的NFS &lt;em&gt;服务器&lt;/em&gt;上使用 &lt;code&gt;sync&lt;/code&gt; export选项。否则，实际上不能保证NFS客户端上的 &lt;code&gt;fsync&lt;/code&gt; 或等效文件可以到达服务器上的永久存储，这可能导致损坏，类似于使用参数&lt;a href=&quot;runtime-config-wal#GUC-FSYNC&quot;&gt;fsync&lt;/a&gt;运行&lt;em&gt;&lt;/em&gt;关。这些安装和导出选项的默认设置在供应商和版本之间有所不同，因此建议在任何情况下都进行检查并明确指定它们，以避免任何歧义。</target>
        </trans-unit>
        <trans-unit id="c52dffeed651be2fa3f87bf20ee3f9a890f9417b" translate="yes" xml:space="preserve">
          <source>It is not possible to release a savepoint when the transaction is in an aborted state.</source>
          <target state="translated">当事务处于中止状态时,不可能释放保存点。</target>
        </trans-unit>
        <trans-unit id="bfd22308dc33a27874305473df207d131e6a6cc4" translate="yes" xml:space="preserve">
          <source>It is not possible to specify an operator's lexical precedence in &lt;code&gt;CREATE OPERATOR&lt;/code&gt;, because the parser's precedence behavior is hard-wired. See &lt;a href=&quot;sql-syntax-lexical#SQL-PRECEDENCE&quot;&gt;Section 4.1.6&lt;/a&gt; for precedence details.</source>
          <target state="translated">在 &lt;code&gt;CREATE OPERATOR&lt;/code&gt; 中无法指定运算符的词法优先级，因为解析器的优先级行为是硬连接的。有关优先级的详细信息，请参见&lt;a href=&quot;sql-syntax-lexical#SQL-PRECEDENCE&quot;&gt;第4.1.6节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="623a5826c4c93a0ee1b0b35f75bc29bfa6d59c5f" translate="yes" xml:space="preserve">
          <source>It is not possible to turn a regular table into a partitioned table or vice versa. However, it is possible to add a regular or partitioned table containing data as a partition of a partitioned table, or remove a partition from a partitioned table turning it into a standalone table; see &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; to learn more about the &lt;code&gt;ATTACH PARTITION&lt;/code&gt; and &lt;code&gt;DETACH PARTITION&lt;/code&gt; sub-commands.</source>
          <target state="translated">无法将常规表转换为分区表，反之亦然。但是，可以将包含数据的常规表或分区表添加为分区表的分区，也可以从分区表中删除分区，从而将其转变为独立表。请参阅&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;以了解有关 &lt;code&gt;ATTACH PARTITION&lt;/code&gt; 和 &lt;code&gt;DETACH PARTITION&lt;/code&gt; 子命令的更多信息。</target>
        </trans-unit>
        <trans-unit id="2662bc57686704e0177490490462c24f0b6b158d" translate="yes" xml:space="preserve">
          <source>It is often a good idea to also omit from the backup the files within the cluster's &lt;code&gt;pg_replslot/&lt;/code&gt; directory, so that replication slots that exist on the master do not become part of the backup. Otherwise, the subsequent use of the backup to create a standby may result in indefinite retention of WAL files on the standby, and possibly bloat on the master if hot standby feedback is enabled, because the clients that are using those replication slots will still be connecting to and updating the slots on the master, not the standby. Even if the backup is only intended for use in creating a new master, copying the replication slots isn't expected to be particularly useful, since the contents of those slots will likely be badly out of date by the time the new master comes on line.</source>
          <target state="translated">最好也从备份中省略群集的 &lt;code&gt;pg_replslot/&lt;/code&gt; 目录中的文件，这样主服务器上存在的复制插槽就不会成为备份的一部分。否则，随后使用备份创建备用数据库可能会导致WAL文件无限期保留在备用数据库上，并且如果启用了热备用反馈，可能会导致主数据库上的膨胀，因为使用这些复制插槽的客户端仍将连接并更新主服务器（而不是备用服务器）上的插槽。即使备份仅用于创建新的主服务器，复制复制插槽也不是特别有用，因为新主服务器上线时，这些插槽的内容可能已严重过时。 。</target>
        </trans-unit>
        <trans-unit id="d49711f89af35705bbf2891f981f944c8b5260d9" translate="yes" xml:space="preserve">
          <source>It is often helpful to use dollar quoting (see &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-DOLLAR-QUOTING&quot;&gt;Section 4.1.2.4&lt;/a&gt;) to write the function definition string, rather than the normal single quote syntax. Without dollar quoting, any single quotes or backslashes in the function definition must be escaped by doubling them.</source>
          <target state="translated">使用美元引号（请参阅&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-DOLLAR-QUOTING&quot;&gt;第4.1.2.4节&lt;/a&gt;）来编写函数定义字符串，而不是使用普通的单引号语法通常会很有帮助。没有美元引号，函数定义中的任何单引号或反斜杠都必须通过加倍来转义。</target>
        </trans-unit>
        <trans-unit id="070ae03385b0624216e0f28d18b1063fb9896a1e" translate="yes" xml:space="preserve">
          <source>It is often helpful to use dollar quoting (see &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-DOLLAR-QUOTING&quot;&gt;Section 4.1.2.4&lt;/a&gt;) to write the procedure definition string, rather than the normal single quote syntax. Without dollar quoting, any single quotes or backslashes in the procedure definition must be escaped by doubling them.</source>
          <target state="translated">使用美元引号（请参见&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-DOLLAR-QUOTING&quot;&gt;第4.1.2.4节&lt;/a&gt;）来编写过程定义字符串，而不是普通的单引号语法，通常会很有帮助。如果不使用美元引号，则必须通过将它们加倍来对过程定义中的任何单引号或反斜杠进行转义。</target>
        </trans-unit>
        <trans-unit id="1037cf4994d8c1ebf0e5d5f237e680d00560257d" translate="yes" xml:space="preserve">
          <source>It is often particularly handy to &lt;code&gt;LEFT JOIN&lt;/code&gt; to a &lt;code&gt;LATERAL&lt;/code&gt; subquery, so that source rows will appear in the result even if the &lt;code&gt;LATERAL&lt;/code&gt; subquery produces no rows for them. For example, if &lt;code&gt;get_product_names()&lt;/code&gt; returns the names of products made by a manufacturer, but some manufacturers in our table currently produce no products, we could find out which ones those are like this:</source>
          <target state="translated">向 &lt;code&gt;LEFT JOIN&lt;/code&gt; 到 &lt;code&gt;LATERAL&lt;/code&gt; 子查询通常特别方便，这样即使 &lt;code&gt;LATERAL&lt;/code&gt; 子查询不为它们生成任何行，结果中也会出现源行。例如，如果 &lt;code&gt;get_product_names()&lt;/code&gt; 返回制造商生产的产品名称，但是我们表中的某些制造商当前不生产任何产品，我们可以找出哪些是这样的：</target>
        </trans-unit>
        <trans-unit id="25dd81b9b45b03c00d03cc26e891361c1cfb5adf" translate="yes" xml:space="preserve">
          <source>It is often preferable to use unique index inference rather than naming a constraint directly using &lt;code&gt;ON CONFLICT ON CONSTRAINT&lt;/code&gt;&lt;code&gt;constraint_name&lt;/code&gt;. Inference will continue to work correctly when the underlying index is replaced by another more or less equivalent index in an overlapping way, for example when using &lt;code&gt;CREATE UNIQUE INDEX ... CONCURRENTLY&lt;/code&gt; before dropping the index being replaced.</source>
          <target state="translated">通常，更可取的是使用唯一索引推断，而不是直接使用 &lt;code&gt;ON CONFLICT ON CONSTRAINT&lt;/code&gt; strict_name命名 &lt;code&gt;constraint_name&lt;/code&gt; 。当基础索引被另一个或多或少等效的索引以重叠方式替换时，例如在删除要替换的索引之前使用 &lt;code&gt;CREATE UNIQUE INDEX ... CONCURRENTLY&lt;/code&gt; 时，推理将继续正常工作。</target>
        </trans-unit>
        <trans-unit id="f0921a8a84d9d3343d74c19f7c3f5f4b06b1c95a" translate="yes" xml:space="preserve">
          <source>It is possible for a &lt;code&gt;SELECT&lt;/code&gt; command running at the &lt;code&gt;READ COMMITTED&lt;/code&gt; transaction isolation level and using &lt;code&gt;ORDER BY&lt;/code&gt; and a locking clause to return rows out of order. This is because &lt;code&gt;ORDER BY&lt;/code&gt; is applied first. The command sorts the result, but might then block trying to obtain a lock on one or more of the rows. Once the &lt;code&gt;SELECT&lt;/code&gt; unblocks, some of the ordering column values might have been modified, leading to those rows appearing to be out of order (though they are in order in terms of the original column values). This can be worked around at need by placing the &lt;code&gt;FOR UPDATE/SHARE&lt;/code&gt; clause in a sub-query, for example</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; 命令可能以 &lt;code&gt;READ COMMITTED&lt;/code&gt; 事务隔离级别运行，并使用 &lt;code&gt;ORDER BY&lt;/code&gt; 和locking子句可以使行无序返回。这是因为 &lt;code&gt;ORDER BY&lt;/code&gt; 首先被应用。该命令对结果进行排序，但是可能会阻止尝试获得对一个或多个行的锁定。一旦 &lt;code&gt;SELECT&lt;/code&gt; 解除阻塞，某些排序列值可能已被修改，从而导致这些行似乎是乱序的（尽管就原始列值而言，它们是有序的）。例如，可以通过在子查询中放置 &lt;code&gt;FOR UPDATE/SHARE&lt;/code&gt; 子句来解决此问题。</target>
        </trans-unit>
        <trans-unit id="312a8769f42a09f432ff89ed107b0b0a082956d5" translate="yes" xml:space="preserve">
          <source>It is possible for both the client and server to provide SSL certificates to each other. It takes some extra configuration on each side, but this provides stronger verification of identity than the mere use of passwords. It prevents a computer from pretending to be the server just long enough to read the password sent by the client. It also helps prevent &amp;ldquo;man in the middle&amp;rdquo; attacks where a computer between the client and server pretends to be the server and reads and passes all data between the client and server.</source>
          <target state="translated">客户端和服务器都可以相互提供SSL证书。它需要在每一侧进行一些额外的配置，但这比仅使用密码提供了更强的身份验证。这样可以防止计算机假装自己只是服务器，足以读取客户端发送的密码。它还有助于防止&amp;ldquo;中间人&amp;rdquo;攻击，即客户端和服务器之间的计算机冒充服务器，并在客户端和服务器之间读取和传递所有数据。</target>
        </trans-unit>
        <trans-unit id="90f59c9a7c7c3d668eb0d91ba42953cad54439f7" translate="yes" xml:space="preserve">
          <source>It is possible for the &lt;code&gt;query&lt;/code&gt; (&lt;code&gt;SELECT&lt;/code&gt; statement) to also contain a &lt;code&gt;WITH&lt;/code&gt; clause. In such a case both sets of &lt;code&gt;with_query&lt;/code&gt; can be referenced within the &lt;code&gt;query&lt;/code&gt;, but the second one takes precedence since it is more closely nested.</source>
          <target state="translated">这是可能的 &lt;code&gt;query&lt;/code&gt; （ &lt;code&gt;SELECT&lt;/code&gt; 语句）也包含 &lt;code&gt;WITH&lt;/code&gt; 子句。在这种情况下，可以在 &lt;code&gt;query&lt;/code&gt; 引用两套 &lt;code&gt;with_query&lt;/code&gt; ，但是第二套优先，因为它的嵌套更紧密。</target>
        </trans-unit>
        <trans-unit id="db7d99e745d7786411f8e352570962f202386c2e" translate="yes" xml:space="preserve">
          <source>It is possible for the parser to produce overlapping tokens from the same piece of text. As an example, a hyphenated word will be reported both as the entire word and as each component:</source>
          <target state="translated">解析器有可能从同一段文本中产生重叠的标记。例如,一个连字符的单词将作为整个单词和每个组成部分报告。</target>
        </trans-unit>
        <trans-unit id="2357da6f1597b1c38d9b19b97f4eaf9ba4d3b605" translate="yes" xml:space="preserve">
          <source>It is possible that the replication delay between servers exceeds the value of this parameter, in which case no delay is added. Note that the delay is calculated between the WAL time stamp as written on master and the current time on the standby. Delays in transfer because of network lag or cascading replication configurations may reduce the actual wait time significantly. If the system clocks on master and standby are not synchronized, this may lead to recovery applying records earlier than expected; but that is not a major issue because useful settings of this parameter are much larger than typical time deviations between servers.</source>
          <target state="translated">有可能服务器之间的复制延迟超过了这个参数的值,在这种情况下,不增加延迟。请注意,延迟是在主站上写入的WAL时间戳和备用站上的当前时间之间计算的。由于网络滞后或级联复制配置造成的传输延迟可能会大大减少实际等待时间。如果主站和备用站上的系统时钟不同步,可能会导致恢复应用记录的时间比预期的要早;但这不是一个主要问题,因为该参数的有用设置比服务器之间的典型时间偏差要大得多。</target>
        </trans-unit>
        <trans-unit id="f9e86aaa136a99713e8aa37be86f1493657e5f36" translate="yes" xml:space="preserve">
          <source>It is possible to access the two component numbers of a &lt;code&gt;point&lt;/code&gt; as though the point were an array with indexes 0 and 1. For example, if &lt;code&gt;t.p&lt;/code&gt; is a &lt;code&gt;point&lt;/code&gt; column then &lt;code&gt;SELECT p[0] FROM t&lt;/code&gt; retrieves the X coordinate and &lt;code&gt;UPDATE t SET p[1] = ...&lt;/code&gt; changes the Y coordinate. In the same way, a value of type &lt;code&gt;box&lt;/code&gt; or &lt;code&gt;lseg&lt;/code&gt; can be treated as an array of two &lt;code&gt;point&lt;/code&gt; values.</source>
          <target state="translated">可以访问一个 &lt;code&gt;point&lt;/code&gt; 的两个组件号，就好像该点是具有索引0和1的数组一样。例如，如果 &lt;code&gt;t.p&lt;/code&gt; 是一个 &lt;code&gt;point&lt;/code&gt; 列，则 &lt;code&gt;SELECT p[0] FROM t&lt;/code&gt; 获取X坐标，而 &lt;code&gt;UPDATE t SET p[1] = ...&lt;/code&gt; 更改Y坐标。同样，可以将 &lt;code&gt;box&lt;/code&gt; 或 &lt;code&gt;lseg&lt;/code&gt; 类型的值视为两个 &lt;code&gt;point&lt;/code&gt; 值的数组。</target>
        </trans-unit>
        <trans-unit id="2d05975d6f7f169fef234fa65303a022ea6de537" translate="yes" xml:space="preserve">
          <source>It is possible to change all but &lt;code&gt;SHMMNI&lt;/code&gt; on the fly, using sysctl. But it's still best to set up your preferred values via &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;, so that the values will be kept across reboots.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fd72ecc1dea1c97715f5cc99a51c3564620c9cb" translate="yes" xml:space="preserve">
          <source>It is possible to check the accuracy of the planner's estimates by using &lt;code&gt;EXPLAIN&lt;/code&gt;'s &lt;code&gt;ANALYZE&lt;/code&gt; option. With this option, &lt;code&gt;EXPLAIN&lt;/code&gt; actually executes the query, and then displays the true row counts and true run time accumulated within each plan node, along with the same estimates that a plain &lt;code&gt;EXPLAIN&lt;/code&gt; shows. For example, we might get a result like this:</source>
          <target state="translated">使用 &lt;code&gt;EXPLAIN&lt;/code&gt; 的 &lt;code&gt;ANALYZE&lt;/code&gt; 选项可以检查计划者估算的准确性。使用此选项， &lt;code&gt;EXPLAIN&lt;/code&gt; 实际上会执行查询，然后显示每个计划节点内累积的真实行数和真实运行时间，以及与普通 &lt;code&gt;EXPLAIN&lt;/code&gt; 显示的估计相同的估计。例如，我们可能会得到如下结果：</target>
        </trans-unit>
        <trans-unit id="ed45fb50f823ca992b140dff1d81be186a3aef4d" translate="yes" xml:space="preserve">
          <source>It is possible to control the query planner to some extent by using the explicit &lt;code&gt;JOIN&lt;/code&gt; syntax. To see why this matters, we first need some background.</source>
          <target state="translated">通过使用显式 &lt;code&gt;JOIN&lt;/code&gt; 语法，可以在某种程度上控制查询计划器。为了弄清为什么如此重要，我们首先需要一些背景。</target>
        </trans-unit>
        <trans-unit id="21ffb53e2d68da0c7954b41e98f5975f4ecf8084" translate="yes" xml:space="preserve">
          <source>It is possible to create a foreign-data wrapper with no handler function, but foreign tables using such a wrapper can only be declared, not accessed.</source>
          <target state="translated">可以创建一个没有处理函数的外数据包装器,但是使用这种包装器的外表只能被声明,不能被访问。</target>
        </trans-unit>
        <trans-unit id="d5bd3763bfcd5993518d08a6fc8f19894d8b599a" translate="yes" xml:space="preserve">
          <source>It is possible to create additional template databases, and indeed one can copy any database in a cluster by specifying its name as the template for &lt;code&gt;CREATE DATABASE&lt;/code&gt;. It is important to understand, however, that this is not (yet) intended as a general-purpose &amp;ldquo;&lt;code&gt;COPY DATABASE&lt;/code&gt;&amp;rdquo; facility. The principal limitation is that no other sessions can be connected to the source database while it is being copied. &lt;code&gt;CREATE DATABASE&lt;/code&gt; will fail if any other connection exists when it starts; during the copy operation, new connections to the source database are prevented.</source>
          <target state="translated">可以创建其他模板数据库，并且实际上可以通过将集群的名称指定为 &lt;code&gt;CREATE DATABASE&lt;/code&gt; 的模板来复制集群中的任何数据库。然而，重要的是要了解，这（尚未）打算用作通用的&amp;ldquo; &lt;code&gt;COPY DATABASE&lt;/code&gt; &amp;rdquo;工具。主要限制是在复制源数据库时，无法将其他会话连接到源数据库。如果启动时存在任何其他连接，则 &lt;code&gt;CREATE DATABASE&lt;/code&gt; 将失败。在复制操作期间，将阻止与源数据库的新连接。</target>
        </trans-unit>
        <trans-unit id="e68d9c04db6c0169a67f695c187f5caec6e9c6fb" translate="yes" xml:space="preserve">
          <source>It is possible to dispense with &lt;code&gt;SET TRANSACTION&lt;/code&gt; by instead specifying the desired &lt;code&gt;transaction_modes&lt;/code&gt; in &lt;code&gt;BEGIN&lt;/code&gt; or &lt;code&gt;START TRANSACTION&lt;/code&gt;. But that option is not available for &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt;.</source>
          <target state="translated">通过在 &lt;code&gt;BEGIN&lt;/code&gt; 或 &lt;code&gt;START TRANSACTION&lt;/code&gt; 中指定所需的 &lt;code&gt;transaction_modes&lt;/code&gt; ，可以省去 &lt;code&gt;SET TRANSACTION&lt;/code&gt; TRANSACTION。但是该选项不适用于 &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c6a819090253f862f39b7dcfdb25432b06b91898" translate="yes" xml:space="preserve">
          <source>It is possible to do a full text search without an index. A simple query to print the &lt;code&gt;title&lt;/code&gt; of each row that contains the word &lt;code&gt;friend&lt;/code&gt; in its &lt;code&gt;body&lt;/code&gt; field is:</source>
          <target state="translated">无需索引即可进行全文搜索。一个简单的查询来打印在其 &lt;code&gt;body&lt;/code&gt; 字段中包含单词&amp;ldquo; &lt;code&gt;friend&lt;/code&gt; 的每一行的 &lt;code&gt;title&lt;/code&gt; 是：</target>
        </trans-unit>
        <trans-unit id="6f136c23eebfd4cd415f6012b712c4df1242fdcd" translate="yes" xml:space="preserve">
          <source>It is possible to have authentication without encryption overhead by using &lt;code&gt;NULL-SHA&lt;/code&gt; or &lt;code&gt;NULL-MD5&lt;/code&gt; ciphers. However, a man-in-the-middle could read and pass communications between client and server. Also, encryption overhead is minimal compared to the overhead of authentication. For these reasons NULL ciphers are not recommended.</source>
          <target state="translated">通过使用 &lt;code&gt;NULL-SHA&lt;/code&gt; 或 &lt;code&gt;NULL-MD5&lt;/code&gt; 密码，可以在没有加密开销的情况下进行身份验证。但是，中间人可以读取并通过客户端与服务器之间的通信。而且，与身份验证的开销相比，加密开销最小。由于这些原因，不建议使用NULL密码。</target>
        </trans-unit>
        <trans-unit id="c3a0ba5698f2b4b4f4b4ee88ac329603107cde1d" translate="yes" xml:space="preserve">
          <source>It is possible to log to stderr without using the logging collector; the log messages will just go to wherever the server's stderr is directed. However, that method is only suitable for low log volumes, since it provides no convenient way to rotate log files. Also, on some platforms not using the logging collector can result in lost or garbled log output, because multiple processes writing concurrently to the same log file can overwrite each other's output.</source>
          <target state="translated">可以在不使用日志收集器的情况下将日志记录到stderr;日志信息将直接发送到服务器的stderr所指向的地方。然而,这种方法只适用于低日志量,因为它没有提供方便的方法来旋转日志文件。另外,在某些平台上,不使用日志收集器可能会导致日志输出丢失或乱码,因为多个进程同时向同一个日志文件写入日志,可能会覆盖对方的输出。</target>
        </trans-unit>
        <trans-unit id="3d8f4459b3f7e90845c901d21d257a7423c267d0" translate="yes" xml:space="preserve">
          <source>It is possible to modify the kernel's behavior so that it will not &amp;ldquo;overcommit&amp;rdquo; memory. Although this setting will not prevent the &lt;a href=&quot;https://lwn.net/Articles/104179/&quot;&gt;OOM killer&lt;/a&gt; from being invoked altogether, it will lower the chances significantly and will therefore lead to more robust system behavior. This is done by selecting strict overcommit mode via &lt;code&gt;sysctl&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36e9a78df914fad0648da0a65b3ec648ec904013" translate="yes" xml:space="preserve">
          <source>It is possible to nest dollar-quoted string constants by choosing different tags at each nesting level. This is most commonly used in writing function definitions. For example:</source>
          <target state="translated">通过在每个嵌套级别选择不同的标签,可以嵌套美元引用的字符串常量。这在编写函数定义时最常用。例如</target>
        </trans-unit>
        <trans-unit id="a0a345a5b07bad2c1307139346533842f66f7f85" translate="yes" xml:space="preserve">
          <source>It is possible to omit the &lt;code&gt;lower-bound&lt;/code&gt; and/or &lt;code&gt;upper-bound&lt;/code&gt; of a slice specifier; the missing bound is replaced by the lower or upper limit of the array's subscripts. For example:</source>
          <target state="translated">可以省略切片说明符 &lt;code&gt;lower-bound&lt;/code&gt; 和/或 &lt;code&gt;upper-bound&lt;/code&gt; 。缺少的边界将替换为数组下标的下限或上限。例如：</target>
        </trans-unit>
        <trans-unit id="0fbcc6e88bd4f468012c5b5e8934f903489fc504" translate="yes" xml:space="preserve">
          <source>It is possible to run &lt;code&gt;ANALYZE&lt;/code&gt; on specific tables and even just specific columns of a table, so the flexibility exists to update some statistics more frequently than others if your application requires it. In practice, however, it is usually best to just analyze the entire database, because it is a fast operation. &lt;code&gt;ANALYZE&lt;/code&gt; uses a statistically random sampling of the rows of a table rather than reading every single row.</source>
          <target state="translated">可以在特定表甚至表的特定列上运行 &lt;code&gt;ANALYZE&lt;/code&gt; ，因此，如果您的应用程序需要更新某些统计信息，则可以比其他统计信息更频繁地进行更新。但是，实际上，通常最好只分析整个数据库，因为这是一个快速的操作。 &lt;code&gt;ANALYZE&lt;/code&gt; 对表的行进行统计随机抽样，而不是读取每一行。</target>
        </trans-unit>
        <trans-unit id="56b863d1457c5714b3cbf931bd78aab64ed29d7b" translate="yes" xml:space="preserve">
          <source>It is possible to set up more complex expression indexes wherein the configuration name is specified by another column, e.g.:</source>
          <target state="translated">可以设置更复杂的表达式索引,其中配置名称由另一列指定,例如:</target>
        </trans-unit>
        <trans-unit id="ab7995c28ab9203226049f19e6325626835b07f5" translate="yes" xml:space="preserve">
          <source>It is possible to use PostgreSQL's backup facilities to produce standalone hot backups. These are backups that cannot be used for point-in-time recovery, yet are typically much faster to backup and restore than pg_dump dumps. (They are also much larger than pg_dump dumps, so in some cases the speed advantage might be negated.)</source>
          <target state="translated">可以使用PostgreSQL的备份设施来生成独立的热备份。这些备份不能用于时间点恢复,但通常比pg_dump dumps的备份和恢复速度快得多。(它们也比pg_dump dumps大得多,所以在某些情况下,速度的优势可能会被否定。)</target>
        </trans-unit>
        <trans-unit id="793bdae387c6386aab767254ea0495efd0a0f102" translate="yes" xml:space="preserve">
          <source>It is possible to use SELinux's dynamic domain transition feature to switch the security label of the client process, the client domain, to a new context, if that is allowed by the security policy. The client domain needs the &lt;code&gt;setcurrent&lt;/code&gt; permission and also &lt;code&gt;dyntransition&lt;/code&gt; from the old to the new domain.</source>
          <target state="translated">如果安全策略允许，可以使用SELinux的动态域转换功能将客户端进程的安全标签（客户端域）切换到新的上下文。客户端域需要 &lt;code&gt;setcurrent&lt;/code&gt; 许可，也 &lt;code&gt;dyntransition&lt;/code&gt; 到新的领域从旧的。</target>
        </trans-unit>
        <trans-unit id="fea64923e6a1c45508b51b78c6ed3fd042a235d3" translate="yes" xml:space="preserve">
          <source>It is possible to use SSH to encrypt the network connection between clients and a PostgreSQL server. Done properly, this provides an adequately secure network connection, even for non-SSL-capable clients.</source>
          <target state="translated">可以使用SSH来加密客户端和PostgreSQL服务器之间的网络连接。如果操作得当,这可以提供一个足够安全的网络连接,即使是对不支持SSL的客户端也是如此。</target>
        </trans-unit>
        <trans-unit id="05887c55098593888d9b6548b102c0d07ee418cb" translate="yes" xml:space="preserve">
          <source>It is possible to use an NFS file system for storing the PostgreSQL data directory. PostgreSQL does nothing special for NFS file systems, meaning it assumes NFS behaves exactly like locally-connected drives. PostgreSQL does not use any functionality that is known to have nonstandard behavior on NFS, such as file locking.</source>
          <target state="translated">可以使用NFS文件系统来存储PostgreSQL数据目录。PostgreSQL对NFS文件系统没有什么特别的做法,也就是说,它假设NFS的行为与本地连接的驱动器完全一样。PostgreSQL不使用任何已知在NFS上具有非标准行为的功能,例如文件锁定。</target>
        </trans-unit>
        <trans-unit id="d07d0d357ed59e4c40820ac16ee2111a412a9fe9" translate="yes" xml:space="preserve">
          <source>It is recommended that in a &lt;code&gt;UNIQUE_CHECK_EXISTING&lt;/code&gt; call, the access method further verify that the target row actually does have an existing entry in the index, and report error if not. This is a good idea because the index tuple values passed to &lt;code&gt;aminsert&lt;/code&gt; will have been recomputed. If the index definition involves functions that are not really immutable, we might be checking the wrong area of the index. Checking that the target row is found in the recheck verifies that we are scanning for the same tuple values as were used in the original insertion.</source>
          <target state="translated">建议在 &lt;code&gt;UNIQUE_CHECK_EXISTING&lt;/code&gt; 调用中，访问方法进一步验证目标行确实在索引中确实存在现有条目，如果没有，则报告错误。这是一个好主意，因为传递给 &lt;code&gt;aminsert&lt;/code&gt; 的索引元组值将被重新计算。如果索引定义涉及的功能并不是真正不变的，那么我们可能正在检查索引的错误区域。检查是否在重新检查中找到了目标行，从而验证我们是否在扫描与原始插入中使用的相同的元组值。</target>
        </trans-unit>
        <trans-unit id="302398642319ebf3c5925fc78db8e53f6245f737" translate="yes" xml:space="preserve">
          <source>It is recommended that the file name used in &lt;code&gt;COPY&lt;/code&gt; always be specified as an absolute path. This is enforced by the server in the case of &lt;code&gt;COPY TO&lt;/code&gt;, but for &lt;code&gt;COPY FROM&lt;/code&gt; you do have the option of reading from a file specified by a relative path. The path will be interpreted relative to the working directory of the server process (normally the cluster's data directory), not the client's working directory.</source>
          <target state="translated">建议始终将 &lt;code&gt;COPY&lt;/code&gt; 中使用的文件名指定为绝对路径。对于 &lt;code&gt;COPY TO&lt;/code&gt; ，这是由服务器强制执行的，但是对于 &lt;code&gt;COPY FROM&lt;/code&gt; ,您可以选择从相对路径指定的文件中读取。该路径将相对于服务器进程的工作目录（通常是集群的数据目录）而不是客户端的工作目录进行解释。</target>
        </trans-unit>
        <trans-unit id="fc0e534ffa8e632dc4cfe7cd8ad98fc538520874" translate="yes" xml:space="preserve">
          <source>It is recommended that you use the pg_dump and pg_dumpall programs from the &lt;em&gt;newer&lt;/em&gt; version of PostgreSQL, to take advantage of enhancements that might have been made in these programs. Current releases of the dump programs can read data from any server version back to 7.0.</source>
          <target state="translated">建议您使用&lt;em&gt;更新&lt;/em&gt;版本的PostgreSQL中的pg_dump和pg_dumpall程序，以利用这些程序中可能进行的增强。当前版本的转储程序可以从任何服务器版本回7.0读取数据。</target>
        </trans-unit>
        <trans-unit id="9c852fda272f66e174a3889edb42521ecc91c452" translate="yes" xml:space="preserve">
          <source>It is redundant to use the &lt;code&gt;clientcert&lt;/code&gt; option with &lt;code&gt;cert&lt;/code&gt; authentication because &lt;code&gt;cert&lt;/code&gt; authentication is effectively &lt;code&gt;trust&lt;/code&gt; authentication with &lt;code&gt;clientcert=verify-full&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="580dc3a7b05e5fa4e5a6d4851ec4e93eeb1cdf02" translate="yes" xml:space="preserve">
          <source>It is safe to use &lt;code&gt;off&lt;/code&gt; for logical replication: If the subscriber loses transactions because of missing synchronization, the data will be resent from the publisher.</source>
          <target state="translated">使用 &lt;code&gt;off&lt;/code&gt; 进行逻辑复制是安全的：如果订阅服务器由于缺少同步而丢失了事务，则将从发布服务器重新发送数据。</target>
        </trans-unit>
        <trans-unit id="b5365d46a8cd20c8ffe5a596a1e9394f61f94500" translate="yes" xml:space="preserve">
          <source>It is safe to use &lt;code&gt;off&lt;/code&gt; for logical replication: If the subscriber loses transactions because of missing synchronization, the data will be sent again from the publisher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29f5d0a01be6a99ad6990afcd555514ae6b7efcb" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that &lt;code&gt;earthdistance&lt;/code&gt; and &lt;code&gt;cube&lt;/code&gt; be installed in the same schema, and that that schema be one for which CREATE privilege has not been and will not be granted to any untrusted users. Otherwise there are installation-time security hazards if &lt;code&gt;earthdistance&lt;/code&gt;'s schema contains objects defined by a hostile user. Furthermore, when using &lt;code&gt;earthdistance&lt;/code&gt;'s functions after installation, the entire search path should contain only trusted schemas.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70a88889b7d21af89f699959f3df667165202cd6" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that applications generating &lt;code&gt;COPY&lt;/code&gt; data convert data newlines and carriage returns to the &lt;code&gt;\n&lt;/code&gt; and &lt;code&gt;\r&lt;/code&gt; sequences respectively. At present it is possible to represent a data carriage return by a backslash and carriage return, and to represent a data newline by a backslash and newline. However, these representations might not be accepted in future releases. They are also highly vulnerable to corruption if the &lt;code&gt;COPY&lt;/code&gt; file is transferred across different machines (for example, from Unix to Windows or vice versa).</source>
          <target state="translated">强烈建议生成 &lt;code&gt;COPY&lt;/code&gt; 数据的应用程序将数据换行符和回车符分别转换为 &lt;code&gt;\n&lt;/code&gt; 和 &lt;code&gt;\r&lt;/code&gt; 序列。目前，可以通过反斜杠和回车符来表示数据回车，并且可以通过反斜杠和换行符来表示数据换行。但是，将来的发行版中可能不接受这些表示。如果 &lt;code&gt;COPY&lt;/code&gt; 文件在不同的计算机上传输（例如，从Unix到Windows，反之亦然），它们也极易受到破坏。</target>
        </trans-unit>
        <trans-unit id="d870a88dee5f04bff258cb0a3da6e5856609ce9f" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that the transform extensions be installed in the same schema as &lt;code&gt;hstore&lt;/code&gt;. Otherwise there are installation-time security hazards if a transform extension's schema contains objects defined by a hostile user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="027fad8c14749d5c9a12505629778b95ee9e9e46" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that the transform extensions be installed in the same schema as &lt;code&gt;ltree&lt;/code&gt;. Otherwise there are installation-time security hazards if a transform extension's schema contains objects defined by a hostile user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d757720e64f735dd8e83c5c66b88db49094003f" translate="yes" xml:space="preserve">
          <source>It is typically used like this:</source>
          <target state="translated">一般是这样使用的。</target>
        </trans-unit>
        <trans-unit id="cb6eae65d1260158a9aaaa3278cf273df69fbee7" translate="yes" xml:space="preserve">
          <source>It is unwise to leave transactions in the prepared state for a long time. This will interfere with the ability of &lt;code&gt;VACUUM&lt;/code&gt; to reclaim storage, and in extreme cases could cause the database to shut down to prevent transaction ID wraparound (see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;Section 24.1.5&lt;/a&gt;). Keep in mind also that the transaction continues to hold whatever locks it held. The intended usage of the feature is that a prepared transaction will normally be committed or rolled back as soon as an external transaction manager has verified that other databases are also prepared to commit.</source>
          <target state="translated">将事务长时间处于准备状态是不明智的。这将干扰 &lt;code&gt;VACUUM&lt;/code&gt; 回收存储的能力，在极端情况下，可能会导致数据库关闭以防止事务ID环绕（请参见&lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;第24.1.5节&lt;/a&gt;）。还请记住，事务将继续持有其持有的任何锁。该功能的预期用途是，通常在外部事务管理器确认其他数据库也准备提交后，就将提交或回滚准备好的事务。</target>
        </trans-unit>
        <trans-unit id="a307e2692a3d4dc03f3b0a5f0050741c926c9763" translate="yes" xml:space="preserve">
          <source>It is up to the database designer to define the channel names that will be used in a given database and what each one means. Commonly, the channel name is the same as the name of some table in the database, and the notify event essentially means, &amp;ldquo;I changed this table, take a look at it to see what's new&amp;rdquo;. But no such association is enforced by the &lt;code&gt;NOTIFY&lt;/code&gt; and &lt;code&gt;LISTEN&lt;/code&gt; commands. For example, a database designer could use several different channel names to signal different sorts of changes to a single table. Alternatively, the payload string could be used to differentiate various cases.</source>
          <target state="translated">由数据库设计人员决定要在给定数据库中使用的通道名称以及每个通道的含义。通常，通道名称与数据库中某个表的名称相同，并且notify事件本质上意味着：&amp;ldquo;我更改了该表，看看它以了解新功能&amp;rdquo;。但是， &lt;code&gt;NOTIFY&lt;/code&gt; 和 &lt;code&gt;LISTEN&lt;/code&gt; 命令不会强制这种关联。例如，数据库设计人员可以使用几个不同的通道名称向单个表发出不同种类的更改信号。替代地，有效载荷串可以用于区分各种情况。</target>
        </trans-unit>
        <trans-unit id="c8b6810a1ee6954d361d4c3ec546cf2001eccf7f" translate="yes" xml:space="preserve">
          <source>It is up to the specific dictionary how it treats stop words. For example, &lt;code&gt;ispell&lt;/code&gt; dictionaries first normalize words and then look at the list of stop words, while &lt;code&gt;Snowball&lt;/code&gt; stemmers first check the list of stop words. The reason for the different behavior is an attempt to decrease noise.</source>
          <target state="translated">具体如何处理停用词取决于具体的词典。例如， &lt;code&gt;ispell&lt;/code&gt; 词典首先对单词进行规范化，然后查看停用词列表，而 &lt;code&gt;Snowball&lt;/code&gt; 词干分析器首先检查停用词列表。行为不同的原因是试图降低噪音。</target>
        </trans-unit>
        <trans-unit id="ea9210befc0db8269a2ec074f163712e284e5a63" translate="yes" xml:space="preserve">
          <source>It is usually possible to compare values of related data types as well; for example &lt;code&gt;integer&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;bigint&lt;/code&gt; will work. Some cases of this sort are implemented directly by &amp;ldquo;cross-type&amp;rdquo; comparison operators, but if no such operator is available, the parser will coerce the less-general type to the more-general type and apply the latter's comparison operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f04c713c711198819201fd61c74a6825a1ba7c14" translate="yes" xml:space="preserve">
          <source>It is usually wise to create the primary and standby servers so that they are as similar as possible, at least from the perspective of the database server. In particular, the path names associated with tablespaces will be passed across unmodified, so both primary and standby servers must have the same mount paths for tablespaces if that feature is used. Keep in mind that if &lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt; is executed on the primary, any new mount point needed for it must be created on the primary and all standby servers before the command is executed. Hardware need not be exactly the same, but experience shows that maintaining two identical systems is easier than maintaining two dissimilar ones over the lifetime of the application and system. In any case the hardware architecture must be the same &amp;mdash; shipping from, say, a 32-bit to a 64-bit system will not work.</source>
          <target state="translated">创建主服务器和备用服务器通常是明智的，至少从数据库服务器的角度来看，它们应尽可能相似。特别是，与表空间关联的路径名将在未经修改的情况下传递，因此，如果使用了该功能，则主服务器和备用服务器必须具有相同的表空间装载路径。请记住，如果&lt;a href=&quot;sql-createtablespace&quot;&gt;创建表空间&lt;/a&gt;在主服务器上执行该命令之前，必须在主服务器和所有备用服务器上创建该命令所需的任何新安装点，然后才能执行该命令。硬件不必完全相同，但是经验表明，在应用程序和系统的整个生命周期中，维护两个相同的系统要比维护两个不同的系统容易。在任何情况下，硬件体系结构都必须相同-从32位系统移植到64位系统将无法正常工作。</target>
        </trans-unit>
        <trans-unit id="2ca150da1f7706a6be21716f546b65e3672dbc4a" translate="yes" xml:space="preserve">
          <source>It is very difficult to avoid such problems, because of SQL's general assumption that a null value is a valid value of every data type. Best practice therefore is to design a domain's constraints so that a null value is allowed, and then to apply column &lt;code&gt;NOT NULL&lt;/code&gt; constraints to columns of the domain type as needed, rather than directly to the domain type.</source>
          <target state="translated">由于SQL普遍认为null值是每种数据类型的有效值，因此很难避免此类问题。因此，最佳实践是设计域的约束，以便允许使用空值，然后根据需要将列 &lt;code&gt;NOT NULL&lt;/code&gt; 约束应用于域类型的列，而不是直接应用于域类型。</target>
        </trans-unit>
        <trans-unit id="7ca67a8bc55b2440ee4642c5a3836e4f1be7ce5b" translate="yes" xml:space="preserve">
          <source>It is very difficult to enforce business rules regarding data integrity using Read Committed transactions because the view of the data is shifting with each statement, and even a single statement may not restrict itself to the statement's snapshot if a write conflict occurs.</source>
          <target state="translated">使用Read Committed事务执行有关数据完整性的业务规则是非常困难的,因为数据的视图是随着每条语句的变化而变化的,如果发生写冲突,即使是单条语句也可能不限于语句的快照。</target>
        </trans-unit>
        <trans-unit id="c946419a4ac69d8f0e7011290f8155362fae2bbd" translate="yes" xml:space="preserve">
          <source>It is very easy to use pgbench to produce completely meaningless numbers. Here are some guidelines to help you get useful results.</source>
          <target state="translated">使用pgbench很容易产生完全没有意义的数字。这里有一些指导原则可以帮助你得到有用的结果。</target>
        </trans-unit>
        <trans-unit id="8a18d874cf4b801c23ef52010af4733b69c843e7" translate="yes" xml:space="preserve">
          <source>It is very important that the access privileges for replication be set up so that only trusted users can read the WAL stream, because it is easy to extract privileged information from it. Standby servers must authenticate to the primary as a superuser or an account that has the &lt;code&gt;REPLICATION&lt;/code&gt; privilege. It is recommended to create a dedicated user account with &lt;code&gt;REPLICATION&lt;/code&gt; and &lt;code&gt;LOGIN&lt;/code&gt; privileges for replication. While &lt;code&gt;REPLICATION&lt;/code&gt; privilege gives very high permissions, it does not allow the user to modify any data on the primary system, which the &lt;code&gt;SUPERUSER&lt;/code&gt; privilege does.</source>
          <target state="translated">设置复制访问权限非常重要，因为只有受信任的用户才能读取WAL流，因为从中提取特权信息很容易。备用服务器必须作为超级用户或具有 &lt;code&gt;REPLICATION&lt;/code&gt; 特权的帐户向主服务器进行身份验证。建议创建一个具有 &lt;code&gt;REPLICATION&lt;/code&gt; 和 &lt;code&gt;LOGIN&lt;/code&gt; 特权的专用用户帐户进行复制。尽管 &lt;code&gt;REPLICATION&lt;/code&gt; 特权提供了很高的权限，但它不允许用户修改主系统上的任何数据，而 &lt;code&gt;SUPERUSER&lt;/code&gt; 特权则可以。</target>
        </trans-unit>
        <trans-unit id="fee748fec5cbfe77ff2427ad0976951907c37cc5" translate="yes" xml:space="preserve">
          <source>It is very important that the access privileges for replication be set up so that only trusted users can read the WAL stream, because it is easy to extract privileged information from it. Standby servers must authenticate to the primary as an account that has the &lt;code&gt;REPLICATION&lt;/code&gt; privilege or a superuser. It is recommended to create a dedicated user account with &lt;code&gt;REPLICATION&lt;/code&gt; and &lt;code&gt;LOGIN&lt;/code&gt; privileges for replication. While &lt;code&gt;REPLICATION&lt;/code&gt; privilege gives very high permissions, it does not allow the user to modify any data on the primary system, which the &lt;code&gt;SUPERUSER&lt;/code&gt; privilege does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d630958bd06e172aebb494cef807db838ae776b4" translate="yes" xml:space="preserve">
          <source>It is very important to take care to avoid circular rules. For example, though each of the following two rule definitions are accepted by PostgreSQL, the &lt;code&gt;SELECT&lt;/code&gt; command would cause PostgreSQL to report an error because of recursive expansion of a rule:</source>
          <target state="translated">注意避免循环规则非常重要。例如，尽管PostgreSQL接受以下两个规则定义中的每一个，但由于规则的递归扩展， &lt;code&gt;SELECT&lt;/code&gt; 命令将导致PostgreSQL报告错误：</target>
        </trans-unit>
        <trans-unit id="5a1a313f5514df92e2599108b061f0b4f0a8e02d" translate="yes" xml:space="preserve">
          <source>It is widely considered good style to qualify all column names in a join query, so that the query won't fail if a duplicate column name is later added to one of the tables.</source>
          <target state="translated">人们普遍认为,在连接查询中限定所有列名是一种好的风格,这样,如果后来在其中一个表中添加了重复的列名,查询就不会失败。</target>
        </trans-unit>
        <trans-unit id="906e585ddeae75bc90c0d2a785d10b4e23e5052c" translate="yes" xml:space="preserve">
          <source>It is wise to be conservative about marking casts as implicit. An overabundance of implicit casting paths can cause PostgreSQL to choose surprising interpretations of commands, or to be unable to resolve commands at all because there are multiple possible interpretations. A good rule of thumb is to make a cast implicitly invokable only for information-preserving transformations between types in the same general type category. For example, the cast from &lt;code&gt;int2&lt;/code&gt; to &lt;code&gt;int4&lt;/code&gt; can reasonably be implicit, but the cast from &lt;code&gt;float8&lt;/code&gt; to &lt;code&gt;int4&lt;/code&gt; should probably be assignment-only. Cross-type-category casts, such as &lt;code&gt;text&lt;/code&gt; to &lt;code&gt;int4&lt;/code&gt;, are best made explicit-only.</source>
          <target state="translated">保守地将强制类型转换标记为隐式是明智的。过多的隐式转换路径可能导致PostgreSQL选择令人惊讶的命令解释，或者因为存在多种可能的解释而根本无法解析命令。一个好的经验法则是仅对同一常规类型类别中类型之间的信息保留转换隐式调用强制类型转换。例如，从 &lt;code&gt;int2&lt;/code&gt; 到 &lt;code&gt;int4&lt;/code&gt; 的强制转换可以合理地是隐式的，但是从 &lt;code&gt;float8&lt;/code&gt; 到 &lt;code&gt;int4&lt;/code&gt; 的强制转换应该仅是赋值的。跨类型类别的强制类型转换（例如，将 &lt;code&gt;text&lt;/code&gt; 转换为 &lt;code&gt;int4&lt;/code&gt; ）最好设为显式的。</target>
        </trans-unit>
        <trans-unit id="323e3c36d34b28b8ba0133e0d8df50cff77d9ca5" translate="yes" xml:space="preserve">
          <source>It is your responsibility that the byte sequences you create, especially when using the octal or hexadecimal escapes, compose valid characters in the server character set encoding. A useful alternative is to use Unicode escapes or the alternative Unicode escape syntax, explained in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS-UESCAPE&quot;&gt;Section 4.1.2.3&lt;/a&gt;; then the server will check that the character conversion is possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c5b3068c21100601581e786ee86ca3a3f0b7637" translate="yes" xml:space="preserve">
          <source>It is your responsibility that the byte sequences you create, especially when using the octal or hexadecimal escapes, compose valid characters in the server character set encoding. When the server encoding is UTF-8, then the Unicode escapes or the alternative Unicode escape syntax, explained in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS-UESCAPE&quot;&gt;Section 4.1.2.3&lt;/a&gt;, should be used instead. (The alternative would be doing the UTF-8 encoding by hand and writing out the bytes, which would be very cumbersome.)</source>
          <target state="translated">您要负责创建的字节序列（尤其是在使用八进制或十六进制转义符时）在服务器字符集编码中组成有效字符。如果服务器编码为UTF-8 ，则应改用Unicode转义或&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS-UESCAPE&quot;&gt;第4.1.2.3节中&lt;/a&gt;说明的替代Unicode转义语法。（另一种方法是手动进行UTF-8编码并写出字节，这将非常麻烦。）</target>
        </trans-unit>
        <trans-unit id="570a15e9c9ce6ae9a6fe65bb5309393853fdf2d9" translate="yes" xml:space="preserve">
          <source>It joins two functions into a single &lt;code&gt;FROM&lt;/code&gt; target. &lt;code&gt;json_to_recordset()&lt;/code&gt; is instructed to return two columns, the first &lt;code&gt;integer&lt;/code&gt; and the second &lt;code&gt;text&lt;/code&gt;. The result of &lt;code&gt;generate_series()&lt;/code&gt; is used directly. The &lt;code&gt;ORDER BY&lt;/code&gt; clause sorts the column values as integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e498293987ea55fea8d5b2403c8c230700d8887" translate="yes" xml:space="preserve">
          <source>It makes your SQL statements verbose, and you always have to remember to use &lt;code&gt;lower&lt;/code&gt; on both the column and the query value.</source>
          <target state="translated">它使您的SQL语句变得冗长，并且您始终必须记住在列和查询值上均使用 &lt;code&gt;lower&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef32cc79ad6cb19406da947c5847a9365640d3e1" translate="yes" xml:space="preserve">
          <source>It may also be necessary to give the database server's operating system user permission to use huge pages by setting &lt;code&gt;vm.hugetlb_shm_group&lt;/code&gt; via sysctl, and/or give permission to lock memory with &lt;code&gt;ulimit -l&lt;/code&gt;.</source>
          <target state="translated">也可能需要通过sysctl 设置 &lt;code&gt;vm.hugetlb_shm_group&lt;/code&gt; 来授予数据库服务器的操作系统用户使用大页面的权限，和/或使用 &lt;code&gt;ulimit -l&lt;/code&gt; 来授予锁定内存的权限。</target>
        </trans-unit>
        <trans-unit id="c230567f694e16c717ab914422a39d27766ee1c7" translate="yes" xml:space="preserve">
          <source>It may be advisable to avoid using type and table names that begin with underscore. While the server will change generated array type names to avoid collisions with user-given names, there is still risk of confusion, particularly with old client software that may assume that type names beginning with underscores always represent arrays.</source>
          <target state="translated">最好避免使用以下划线开头的类型和表名。虽然服务器会改变生成的数组类型名以避免与用户给定的名称发生冲突,但仍然存在混淆的风险,特别是对于老的客户端软件来说,它们可能会认为以下划线开头的类型名总是代表数组。</target>
        </trans-unit>
        <trans-unit id="914462b7eb826c460762b58dc586f5544963cc18" translate="yes" xml:space="preserve">
          <source>It may be useful to adjust this size to control the granularity of WAL log shipping or archiving. Also, in databases with a high volume of WAL, the sheer number of WAL files per directory can become a performance and management problem. Increasing the WAL file size will reduce the number of WAL files.</source>
          <target state="translated">调整这个大小来控制WAL日志运输或归档的粒度可能是有用的。此外,在WAL数量较多的数据库中,每个目录中WAL文件的数量会成为一个性能和管理问题。增加WAL文件的大小可以减少WAL文件的数量。</target>
        </trans-unit>
        <trans-unit id="7c0fb5b044b855badd9b796e550a5309d125f9a8" translate="yes" xml:space="preserve">
          <source>It might, however, be necessary to modify the global &lt;code&gt;ulimit&lt;/code&gt; information in &lt;code&gt;/etc/security/limits&lt;/code&gt;, as the default hard limits for file sizes (&lt;code&gt;fsize&lt;/code&gt;) and numbers of files (&lt;code&gt;nofiles&lt;/code&gt;) might be too low.</source>
          <target state="translated">但是，可能需要修改 &lt;code&gt;/etc/security/limits&lt;/code&gt; 中的全局 &lt;code&gt;ulimit&lt;/code&gt; 信息，因为文件大小（ &lt;code&gt;fsize&lt;/code&gt; ）和文件数（ &lt;code&gt;nofiles&lt;/code&gt; ）的默认硬性限制可能太低。</target>
        </trans-unit>
        <trans-unit id="91b31f4b37ed5e598eb7def83710e2ca48bbe707" translate="yes" xml:space="preserve">
          <source>It should also be noted that because PostgreSQL is open source and easily extended, a number of companies have taken PostgreSQL and created commercial closed-source solutions with unique failover, replication, and load balancing capabilities. These are not discussed here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fff2052adc7cc9fd5e18f86ad66dfe1b9dfc242d" translate="yes" xml:space="preserve">
          <source>It should also be noted that the default WAL format is fairly bulky since it includes many disk page snapshots. These page snapshots are designed to support crash recovery, since we might need to fix partially-written disk pages. Depending on your system hardware and software, the risk of partial writes might be small enough to ignore, in which case you can significantly reduce the total volume of archived logs by turning off page snapshots using the &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; parameter. (Read the notes and warnings in &lt;a href=&quot;https://www.postgresql.org/docs/12/wal.html&quot;&gt;Chapter 29&lt;/a&gt; before you do so.) Turning off page snapshots does not prevent use of the logs for PITR operations. An area for future development is to compress archived WAL data by removing unnecessary page copies even when &lt;code&gt;full_page_writes&lt;/code&gt; is on. In the meantime, administrators might wish to reduce the number of page snapshots included in WAL by increasing the checkpoint interval parameters as much as feasible.</source>
          <target state="translated">还应注意，默认WAL格式相当庞大，因为它包含许多磁盘页面快照。这些页面快照旨在支持崩溃恢复，因为我们可能需要修复部分写入的磁盘页面。根据系统硬件和软件的不同，部分写入的风险可能很小，可以忽略，在这种情况下，可以通过使用&lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt;参数关闭页面快照来显着减少已归档日志的总量。 （在执行此操作之前，请先阅读&lt;a href=&quot;https://www.postgresql.org/docs/12/wal.html&quot;&gt;第29章中&lt;/a&gt;的注释和警告。）关闭页面快照并不能防止将日志用于PITR操作。未来的发展领域是通过删除不必要的页面副本来压缩已归档的WAL数据，即使在 &lt;code&gt;full_page_writes&lt;/code&gt; 时也是如此开启。同时，管理员可能希望通过尽可能增加检查点间隔参数来减少WAL中包含的页面快照的数量。</target>
        </trans-unit>
        <trans-unit id="27800a360494c7320b8e3b3710d75e18bd41894b" translate="yes" xml:space="preserve">
          <source>It should also be noted that the default WAL format is fairly bulky since it includes many disk page snapshots. These page snapshots are designed to support crash recovery, since we might need to fix partially-written disk pages. Depending on your system hardware and software, the risk of partial writes might be small enough to ignore, in which case you can significantly reduce the total volume of archived logs by turning off page snapshots using the &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; parameter. (Read the notes and warnings in &lt;a href=&quot;https://www.postgresql.org/docs/13/wal.html&quot;&gt;Chapter 29&lt;/a&gt; before you do so.) Turning off page snapshots does not prevent use of the logs for PITR operations. An area for future development is to compress archived WAL data by removing unnecessary page copies even when &lt;code&gt;full_page_writes&lt;/code&gt; is on. In the meantime, administrators might wish to reduce the number of page snapshots included in WAL by increasing the checkpoint interval parameters as much as feasible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af922062ac86a130253f6b4fd50587d3a97630cd" translate="yes" xml:space="preserve">
          <source>It should be fairly clear why a btree index requires these laws to hold within a single data type: without them there is no ordering to arrange the keys with. Also, index searches using a comparison key of a different data type require comparisons to behave sanely across two data types. The extensions to three or more data types within a family are not strictly required by the btree index mechanism itself, but the planner relies on them for optimization purposes.</source>
          <target state="translated">应该相当清楚为什么btree索引要求这些法则在单一数据类型内保持:没有这些法则,就没有排列键的顺序。另外,使用不同数据类型的比较键进行索引搜索,也要求比较在两种数据类型之间表现得理智。在一个族内扩展到三个或更多的数据类型并不是btree索引机制本身严格要求的,但规划者依靠它们来进行优化。</target>
        </trans-unit>
        <trans-unit id="e49813f2476bbea73d4ff66119d7d7387c964091" translate="yes" xml:space="preserve">
          <source>It should be noted that &lt;code&gt;pg_cast&lt;/code&gt; does not represent every type conversion that the system knows how to perform; only those that cannot be deduced from some generic rule. For example, casting between a domain and its base type is not explicitly represented in &lt;code&gt;pg_cast&lt;/code&gt;. Another important exception is that &amp;ldquo;automatic I/O conversion casts&amp;rdquo;, those performed using a data type's own I/O functions to convert to or from &lt;code&gt;text&lt;/code&gt; or other string types, are not explicitly represented in &lt;code&gt;pg_cast&lt;/code&gt;.</source>
          <target state="translated">应该注意的是， &lt;code&gt;pg_cast&lt;/code&gt; 并不代表系统知道如何执行的每个类型转换。只有那些不能从某种通用规则中推论出来的。例如，在 &lt;code&gt;pg_cast&lt;/code&gt; 中没有明确表示域和其基本类型之间的转换。另一个重要的例外是，&amp;ldquo;自动I / O转换强制转换&amp;rdquo;（使用数据类型自己的I / O函数执行以在 &lt;code&gt;text&lt;/code&gt; 或其他字符串类型之间进行转换）不明确地在 &lt;code&gt;pg_cast&lt;/code&gt; 中表示。</target>
        </trans-unit>
        <trans-unit id="3f75a2b78a5f5649b3ab9e555457464dd4adddae" translate="yes" xml:space="preserve">
          <source>It should be noted that a check constraint is satisfied if the check expression evaluates to true or the null value. Since most expressions will evaluate to the null value if any operand is null, they will not prevent null values in the constrained columns. To ensure that a column does not contain null values, the not-null constraint described in the next section can be used.</source>
          <target state="translated">需要注意的是,如果检查表达式的值为真或为空值,则满足检查约束。因为如果任何操作数为空值,大多数表达式都会评价为空值,所以它们不会阻止约束列中出现空值。为了确保列中不包含空值,可以使用下一节中描述的不空约束。</target>
        </trans-unit>
        <trans-unit id="02935ea4ceb5538c0d2002f169c21bb8e60788b3" translate="yes" xml:space="preserve">
          <source>It should be noted that database superusers can access all objects regardless of object privilege settings. This is comparable to the rights of &lt;code&gt;root&lt;/code&gt; in a Unix system. As with &lt;code&gt;root&lt;/code&gt;, it's unwise to operate as a superuser except when absolutely necessary.</source>
          <target state="translated">应该注意的是，数据库超级用户可以访问所有对象，而不管对象特权设置如何。这相当于Unix系统中的 &lt;code&gt;root&lt;/code&gt; 权限。与 &lt;code&gt;root&lt;/code&gt; 一样，除非绝对必要，否则以超级用户身份操作是不明智的。</target>
        </trans-unit>
        <trans-unit id="8c98ab8e1a3d8f36aae75d2304e7a94b266eaa6f" translate="yes" xml:space="preserve">
          <source>It should be noted that except for &lt;code&gt;count&lt;/code&gt;, these functions return a null value when no rows are selected. In particular, &lt;code&gt;sum&lt;/code&gt; of no rows returns null, not zero as one might expect, and &lt;code&gt;array_agg&lt;/code&gt; returns null rather than an empty array when there are no input rows. The &lt;code&gt;coalesce&lt;/code&gt; function can be used to substitute zero or an empty array for null when necessary.</source>
          <target state="translated">应当注意，除了 &lt;code&gt;count&lt;/code&gt; 之外，当未选择任何行时，这些函数将返回空值。特别是，没有行的 &lt;code&gt;sum&lt;/code&gt; 将返回null，而不是预期的 &lt;code&gt;array_agg&lt;/code&gt; 返回零，并且在没有输入行时，array_agg返回null而不是空数组。必要时， &lt;code&gt;coalesce&lt;/code&gt; 函数可用于将零或空数组替换为null。</target>
        </trans-unit>
        <trans-unit id="fcddd727e8976d04c908eb345e29817691fb2925" translate="yes" xml:space="preserve">
          <source>It should be noted that log shipping is asynchronous, i.e., the WAL records are shipped after transaction commit. As a result, there is a window for data loss should the primary server suffer a catastrophic failure; transactions not yet shipped will be lost. The size of the data loss window in file-based log shipping can be limited by use of the &lt;code&gt;archive_timeout&lt;/code&gt; parameter, which can be set as low as a few seconds. However such a low setting will substantially increase the bandwidth required for file shipping. Streaming replication (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;) allows a much smaller window of data loss.</source>
          <target state="translated">应该注意的是，日志传送是异步的，即WAL记录是在事务提交后传送的。因此，如果主服务器遭受灾难性故障，则存在数据丢失的窗口；尚未发货的交易将丢失。通过使用 &lt;code&gt;archive_timeout&lt;/code&gt; 参数可以限制基于文件的日志传送中数据丢失窗口的大小，该参数可以设置为几秒钟。但是，如此低的设置将大大增加文件传送所需的带宽。流复制（请参阅&lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;第26.2.5节&lt;/a&gt;）允许数据丢失的窗口小得多。</target>
        </trans-unit>
        <trans-unit id="3fca8a3246e56f8200631a2d48d923a7438a3af3" translate="yes" xml:space="preserve">
          <source>It should not be necessary to do any special configuration for such parameters as &lt;code&gt;SHMMAX&lt;/code&gt;, as it appears this is configured to allow all memory to be used as shared memory. That is the sort of configuration commonly used for other databases such as DB/2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3defdb9a09006209e803808debdc569c264d27e7" translate="yes" xml:space="preserve">
          <source>It won't use an index, unless you create a functional index using &lt;code&gt;lower&lt;/code&gt;.</source>
          <target state="translated">除非您使用 &lt;code&gt;lower&lt;/code&gt; 创建函数索引，否则它将不会使用索引。</target>
        </trans-unit>
        <trans-unit id="6b722c9c9f3f75689f42f0b53f218a01c48008e8" translate="yes" xml:space="preserve">
          <source>It would be better to instead create child tables as follows:</source>
          <target state="translated">最好是按以下方式创建子表。</target>
        </trans-unit>
        <trans-unit id="b3751c875e52c61621661f1961d94164268c168e" translate="yes" xml:space="preserve">
          <source>It's a matter of taste.</source>
          <target state="translated">这是个品味问题。</target>
        </trans-unit>
        <trans-unit id="6308fac37b6f916e6aaeedec4f54478b5685b89a" translate="yes" xml:space="preserve">
          <source>It's advisable to create &lt;code&gt;ndistinct&lt;/code&gt; statistics objects only on combinations of columns that are actually used for grouping, and for which misestimation of the number of groups is resulting in bad plans. Otherwise, the &lt;code&gt;ANALYZE&lt;/code&gt; cycles are just wasted.</source>
          <target state="translated">建议仅在实际用于分组的列的组合上创建 &lt;code&gt;ndistinct&lt;/code&gt; 统计对象，对于这些组合，错误估计组数会导致不良计划。否则，将浪费 &lt;code&gt;ANALYZE&lt;/code&gt; 循环。</target>
        </trans-unit>
        <trans-unit id="695d14c6506a71cfb6f8af1b5d18b963ae0d4f6f" translate="yes" xml:space="preserve">
          <source>It's advisable to create MCV statistics objects only on combinations of columns that are actually used in conditions together, and for which misestimation of the number of groups is resulting in bad plans. Otherwise, the &lt;code&gt;ANALYZE&lt;/code&gt; and planning cycles are just wasted.</source>
          <target state="translated">建议仅在实际在条件中一起使用的列的组合上创建MCV统计对象，并且对它们的错误估计会导致不良计划。否则，只会浪费 &lt;code&gt;ANALYZE&lt;/code&gt; 和计划周期。</target>
        </trans-unit>
        <trans-unit id="26d8635c1af4731c90f7caf11c20fceefa695a0b" translate="yes" xml:space="preserve">
          <source>It's also permissible to attach &lt;code&gt;BKI_LOOKUP(encoding)&lt;/code&gt; to integer columns to reference character set encodings, which are not currently represented as catalog OIDs, but have a set of values known to &lt;code&gt;genbki.pl&lt;/code&gt;.</source>
          <target state="translated">也可以将 &lt;code&gt;BKI_LOOKUP(encoding)&lt;/code&gt; 附加到整数列以引用字符集编码，这些字符集编码当前未表示为目录OID，但是具有 &lt;code&gt;genbki.pl&lt;/code&gt; 已知的一组值。</target>
        </trans-unit>
        <trans-unit id="42cd973aeb3dbef0c62ad2e81081d6f4bf4973db" translate="yes" xml:space="preserve">
          <source>It's also possible to select no escape character by writing &lt;code&gt;ESCAPE ''&lt;/code&gt;. This effectively disables the escape mechanism, which makes it impossible to turn off the special meaning of underscore and percent signs in the pattern.</source>
          <target state="translated">通过编写 &lt;code&gt;ESCAPE ''&lt;/code&gt; 也可以选择不使用转义字符。这有效地禁用了转义机制，这使得无法关闭模式中下划线和百分号的特殊含义。</target>
        </trans-unit>
        <trans-unit id="8646be546a98ef8ea063cb9eec163a8d4548ff24" translate="yes" xml:space="preserve">
          <source>It's essential that the data types and other properties of the columns declared in &lt;code&gt;CREATE FOREIGN TABLE&lt;/code&gt; match the actual remote table. Column names must match as well, unless you attach &lt;code&gt;column_name&lt;/code&gt; options to the individual columns to show how they are named in the remote table. In many cases, use of &lt;a href=&quot;sql-importforeignschema&quot;&gt;IMPORT FOREIGN SCHEMA&lt;/a&gt; is preferable to constructing foreign table definitions manually.</source>
          <target state="translated">在 &lt;code&gt;CREATE FOREIGN TABLE&lt;/code&gt; 中声明的列的数据类型和其他属性必须与实际的远程表相匹配。列名也必须匹配，除非您将 &lt;code&gt;column_name&lt;/code&gt; 选项附加到各个列以显示它们在远程表中的命名方式。在许多情况下，使用&lt;a href=&quot;sql-importforeignschema&quot;&gt;IMPORT FOREIGN SCHEMA&lt;/a&gt;优于手动构造外部表定义。</target>
        </trans-unit>
        <trans-unit id="a75f17e623d692c2b958fa72bc491d5871febb40" translate="yes" xml:space="preserve">
          <source>It's important to understand that the cost of an upper-level node includes the cost of all its child nodes. It's also important to realize that the cost only reflects things that the planner cares about. In particular, the cost does not consider the time spent transmitting result rows to the client, which could be an important factor in the real elapsed time; but the planner ignores it because it cannot change it by altering the plan. (Every correct plan will output the same row set, we trust.)</source>
          <target state="translated">重要的是要明白,一个上层节点的成本包括其所有子节点的成本。同样重要的是要认识到,成本只反映了规划者关心的事情。特别是,成本没有考虑将结果行传输到客户端所花费的时间,这可能是实际经过时间的一个重要因素;但规划师忽略了它,因为它不能通过改变计划来改变它。每一个正确的计划都会输出相同的行集,我们相信)。</target>
        </trans-unit>
        <trans-unit id="7c3ed76ba22932f8e0061fba8fda8ba6c6509eab" translate="yes" xml:space="preserve">
          <source>It's possible to control the statements in a transaction in a more granular fashion through the use of &lt;em&gt;savepoints&lt;/em&gt;. Savepoints allow you to selectively discard parts of the transaction, while committing the rest. After defining a savepoint with &lt;code&gt;SAVEPOINT&lt;/code&gt;, you can if needed roll back to the savepoint with &lt;code&gt;ROLLBACK TO&lt;/code&gt;. All the transaction's database changes between defining the savepoint and rolling back to it are discarded, but changes earlier than the savepoint are kept.</source>
          <target state="translated">通过使用&lt;em&gt;保存点&lt;/em&gt;，可以以更精细的方式控制事务中的语句。使用保存点，您可以在提交其余事务的同时有选择地丢弃部分事务。在使用 &lt;code&gt;SAVEPOINT&lt;/code&gt; 定义保存点之后，如果需要，您可以使用 &lt;code&gt;ROLLBACK TO&lt;/code&gt; 回滚到该保存点。在定义保存点和回滚到保存点之间的所有事务数据库更改都将被放弃，但会保留早于保存点的更改。</target>
        </trans-unit>
        <trans-unit id="af6b5757cbe3f9b4c6401b87c759f120734c17d1" translate="yes" xml:space="preserve">
          <source>It's recommended to run &lt;code&gt;reformat_dat_file.pl&lt;/code&gt; before submitting catalog data patches. For convenience, you can simply change to &lt;code&gt;src/include/catalog/&lt;/code&gt; and run &lt;code&gt;make reformat-dat-files&lt;/code&gt;.</source>
          <target state="translated">建议在提交目录数据补丁之前先运行 &lt;code&gt;reformat_dat_file.pl&lt;/code&gt; 。为了方便起见，您可以简单地更改为 &lt;code&gt;src/include/catalog/&lt;/code&gt; 并运行 &lt;code&gt;make reformat-dat-files&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f13f984e4f7daa459e845c3a4715f4638313970" translate="yes" xml:space="preserve">
          <source>It's wise to be conservative about adding non-key columns to an index, especially wide columns. If an index tuple exceeds the maximum size allowed for the index type, data insertion will fail. In any case, non-key columns duplicate data from the index's table and bloat the size of the index, thus potentially slowing searches.</source>
          <target state="translated">在索引中添加非键列是明智的,尤其是宽列。如果一个索引元组超过了索引类型允许的最大大小,数据插入将失败。在任何情况下,非键列都会重复索引表中的数据,并使索引的大小膨胀,从而有可能减慢搜索速度。</target>
        </trans-unit>
        <trans-unit id="e5c646abb35ed677e4428cd5146fe3efa3d6f1d7" translate="yes" xml:space="preserve">
          <source>It's wise to be conservative about adding non-key columns to an index, especially wide columns. If an index tuple exceeds the maximum size allowed for the index type, data insertion will fail. In any case, non-key columns duplicate data from the index's table and bloat the size of the index, thus potentially slowing searches. Furthermore, B-tree deduplication is never used with indexes that have a non-key column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08237634e67b792c41b6dc72d01cf498506db594" translate="yes" xml:space="preserve">
          <source>It's wise to be conservative about adding non-key payload columns to an index, especially wide columns. If an index tuple exceeds the maximum size allowed for the index type, data insertion will fail. In any case, non-key columns duplicate data from the index's table and bloat the size of the index, thus potentially slowing searches. And remember that there is little point in including payload columns in an index unless the table changes slowly enough that an index-only scan is likely to not need to access the heap. If the heap tuple must be visited anyway, it costs nothing more to get the column's value from there. Other restrictions are that expressions are not currently supported as included columns, and that only B-tree and GiST indexes currently support included columns.</source>
          <target state="translated">在索引中添加非键有效载荷列是明智的,尤其是宽列。如果一个索引元组超过了索引类型允许的最大大小,数据插入将失败。在任何情况下,非键列都会重复索引表中的数据,并使索引的大小膨胀,从而有可能减慢搜索速度。而且请记住,在索引中包含有效载荷列是没有什么意义的,除非表的变化足够慢,以至于只对索引进行扫描很可能不需要访问堆。如果堆元组无论如何都必须被访问,那么从那里获取列的值就不需要多花钱了。其他限制是目前不支持表达式作为内含列,目前只有B-tree和GiST索引支持内含列。</target>
        </trans-unit>
        <trans-unit id="9682da0882fceeebec9d99753c1dc0306b85beab" translate="yes" xml:space="preserve">
          <source>It's worth noticing that the AND/OR/NOT operators mean something subtly different when they are within the arguments of a FOLLOWED BY operator than when they are not, because within FOLLOWED BY the exact position of the match is significant. For example, normally &lt;code&gt;!x&lt;/code&gt; matches only documents that do not contain &lt;code&gt;x&lt;/code&gt; anywhere. But &lt;code&gt;!x &amp;lt;-&amp;gt; y&lt;/code&gt; matches &lt;code&gt;y&lt;/code&gt; if it is not immediately after an &lt;code&gt;x&lt;/code&gt;; an occurrence of &lt;code&gt;x&lt;/code&gt; elsewhere in the document does not prevent a match. Another example is that &lt;code&gt;x &amp;amp; y&lt;/code&gt; normally only requires that &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; both appear somewhere in the document, but &lt;code&gt;(x &amp;amp; y) &amp;lt;-&amp;gt; z&lt;/code&gt; requires &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; to match at the same place, immediately before a &lt;code&gt;z&lt;/code&gt;. Thus this query behaves differently from &lt;code&gt;x &amp;lt;-&amp;gt; z &amp;amp; y &amp;lt;-&amp;gt; z&lt;/code&gt;, which will match a document containing two separate sequences &lt;code&gt;x z&lt;/code&gt; and &lt;code&gt;y z&lt;/code&gt;. (This specific query is useless as written, since &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; could not match at the same place; but with more complex situations such as prefix-match patterns, a query of this form could be useful.)</source>
          <target state="translated">值得注意的是，AND / OR / NOT运算符在FOLLOWED BY运算符的自变量中时的含义与在非FOLLOWED BY运算符中时的含义稍有不同，因为在FOLLOWED BY中，匹配的确切位置很重要。例如，通常 &lt;code&gt;!x&lt;/code&gt; 仅匹配不包含 &lt;code&gt;x&lt;/code&gt; 的文档。但是 &lt;code&gt;!x &amp;lt;-&amp;gt; y&lt;/code&gt; 匹配 &lt;code&gt;y&lt;/code&gt; 如果它的后不是立即 &lt;code&gt;x&lt;/code&gt; ; 在文档中其他位置出现 &lt;code&gt;x&lt;/code&gt; 不会阻止匹配。另一个例子是 &lt;code&gt;x &amp;amp; y&lt;/code&gt; 通常只要求 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 都出现在文档中的某个位置，但是 &lt;code&gt;(x &amp;amp; y) &amp;lt;-&amp;gt; z&lt;/code&gt; 要求 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 在同一位置匹配，紧接在 &lt;code&gt;z&lt;/code&gt; 之前。因此，此查询的行为不同于 &lt;code&gt;x &amp;lt;-&amp;gt; z &amp;amp; y &amp;lt;-&amp;gt; z&lt;/code&gt; ，后者将匹配包含两个独立序列 &lt;code&gt;x z&lt;/code&gt; 和 &lt;code&gt;y z&lt;/code&gt; 的文档。 （由于 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 不能在同一位置匹配，因此该特定查询在编写时是没有用的；但是对于更复杂的情况（例如前缀匹配模式），这种形式的查询可能会有用。）</target>
        </trans-unit>
        <trans-unit id="ecdda59aea5ee67d7d854c969ccf7f4f4b4a4c54" translate="yes" xml:space="preserve">
          <source>Item</source>
          <target state="translated">Item</target>
        </trans-unit>
        <trans-unit id="036b57986556b399e1579aa78767ca4cf343c8b5" translate="yes" xml:space="preserve">
          <source>ItemIdData</source>
          <target state="translated">ItemIdData</target>
        </trans-unit>
        <trans-unit id="a2965a078eaef7ee13c972baa85b167370cde26a" translate="yes" xml:space="preserve">
          <source>ItemPointerData</source>
          <target state="translated">ItemPointerData</target>
        </trans-unit>
        <trans-unit id="44d25b5d1b6d98c7d090ca3609aca11ae2815fa0" translate="yes" xml:space="preserve">
          <source>Items</source>
          <target state="translated">Items</target>
        </trans-unit>
        <trans-unit id="40f7cf3bbd8b78d82db16eda601698d7597b9ba5" translate="yes" xml:space="preserve">
          <source>J.5. Style Guide</source>
          <target state="translated">J.5.风格指南</target>
        </trans-unit>
        <trans-unit id="7685fa01b8b7b34ce179631444878fcbce78fa81" translate="yes" xml:space="preserve">
          <source>J2451187</source>
          <target state="translated">J2451187</target>
        </trans-unit>
        <trans-unit id="1f1062dcbb83b59e4f6f5cb50ef505afac199e0d" translate="yes" xml:space="preserve">
          <source>JDBC</source>
          <target state="translated">JDBC</target>
        </trans-unit>
        <trans-unit id="eb5d2f4a58038c71155ddcf3cea35dc3c6d34501" translate="yes" xml:space="preserve">
          <source>JIT</source>
          <target state="translated">JIT</target>
        </trans-unit>
        <trans-unit id="6a623f63efe8bb915b0cd81dd3786e0511e1c1a1" translate="yes" xml:space="preserve">
          <source>JIT compilation is beneficial primarily for long-running CPU-bound queries. Frequently these will be analytical queries. For short queries the added overhead of performing JIT compilation will often be higher than the time it can save.</source>
          <target state="translated">JIT编译主要对长时间运行的CPU绑定查询有利。通常这些都是分析性查询。对于简短的查询,执行JIT编译所增加的开销往往高于它所能节省的时间。</target>
        </trans-unit>
        <trans-unit id="6f7646a5ebe2aff38f294e6e525f0ea1b56f8538" translate="yes" xml:space="preserve">
          <source>JOHAB</source>
          <target state="translated">JOHAB</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="c731d9e245778a9537fc026bc57fb4f455f28593" translate="yes" xml:space="preserve">
          <source>JSON Functions and Operators</source>
          <target state="translated">JSON函数和操作符</target>
        </trans-unit>
        <trans-unit id="95cc452498b3190abb79d4cdad349208be23c944" translate="yes" xml:space="preserve">
          <source>JSON Types</source>
          <target state="translated">JSON类型</target>
        </trans-unit>
        <trans-unit id="f9bea7492dcebb5f109566d49e4bca935a7e0ff7" translate="yes" xml:space="preserve">
          <source>JSON Types: boolean</source>
          <target state="translated">JSON类型:布尔值</target>
        </trans-unit>
        <trans-unit id="22aff2decb9f95af65f4e2a85c938a9901c03229" translate="yes" xml:space="preserve">
          <source>JSON Types: null</source>
          <target state="translated">JSON类型:null</target>
        </trans-unit>
        <trans-unit id="b89570edbe3781b5bd3ad2ae7d37f0bf110fdf05" translate="yes" xml:space="preserve">
          <source>JSON Types: number</source>
          <target state="translated">JSON类型:数量</target>
        </trans-unit>
        <trans-unit id="205b72d84addc780073dacc96aedf0a7c5c2d3cc" translate="yes" xml:space="preserve">
          <source>JSON Types: string</source>
          <target state="translated">JSON类型:字符串</target>
        </trans-unit>
        <trans-unit id="6fb42476959dba43e5b647429008c3399be7120f" translate="yes" xml:space="preserve">
          <source>JSON constant &lt;code&gt;false&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="826d7973fb0fe99520474814c729759899e1f084" translate="yes" xml:space="preserve">
          <source>JSON constant &lt;code&gt;null&lt;/code&gt; (note that, unlike in SQL, comparison to &lt;code&gt;null&lt;/code&gt; works normally)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b5978544d202bc2b880af72e00c6ff1ea552f31" translate="yes" xml:space="preserve">
          <source>JSON constant &lt;code&gt;true&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49c22c401963d3661a06e8b5108d657673586e05" translate="yes" xml:space="preserve">
          <source>JSON data is subject to the same concurrency-control considerations as any other data type when stored in a table. Although storing large documents is practicable, keep in mind that any update acquires a row-level lock on the whole row. Consider limiting JSON documents to a manageable size in order to decrease lock contention among updating transactions. Ideally, JSON documents should each represent an atomic datum that business rules dictate cannot reasonably be further subdivided into smaller datums that could be modified independently.</source>
          <target state="translated">当JSON数据存储在表中时,与任何其他数据类型一样,需要考虑并发控制问题。虽然存储大型文档是可行的,但请记住,任何更新都会获得整行的行级锁。考虑将JSON文档限制在一个可管理的大小,以减少更新事务之间的锁争用。理想情况下,JSON文档应该每个代表一个原子数据,业务规则规定不能再合理地细分为可以独立修改的较小数据。</target>
        </trans-unit>
        <trans-unit id="062e2dcdb89d67da750325f5a32e496783b448b0" translate="yes" xml:space="preserve">
          <source>JSON data types are for storing JSON (JavaScript Object Notation) data, as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc7159&quot;&gt;RFC 7159&lt;/a&gt;. Such data can also be stored as &lt;code&gt;text&lt;/code&gt;, but the JSON data types have the advantage of enforcing that each stored value is valid according to the JSON rules. There are also assorted JSON-specific functions and operators available for data stored in these data types; see &lt;a href=&quot;functions-json&quot;&gt;Section 9.15&lt;/a&gt;.</source>
          <target state="translated">JSON数据类型用于存储JSON（JavaScript对象表示法）数据，如&lt;a href=&quot;https://tools.ietf.org/html/rfc7159&quot;&gt;RFC 7159中&lt;/a&gt;所指定。这样的数据也可以存储为 &lt;code&gt;text&lt;/code&gt; ，但是JSON数据类型的优点是可以根据JSON规则强制每个存储的值都是有效的。对于这些数据类型中存储的数据，还提供了各种特定于JSON的函数和运算符。参见&lt;a href=&quot;functions-json&quot;&gt;第9.15节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3439d51ccc84271989a1fe8ee4c05702a949e43b" translate="yes" xml:space="preserve">
          <source>JSON data types are for storing JSON (JavaScript Object Notation) data, as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc7159&quot;&gt;RFC 7159&lt;/a&gt;. Such data can also be stored as &lt;code&gt;text&lt;/code&gt;, but the JSON data types have the advantage of enforcing that each stored value is valid according to the JSON rules. There are also assorted JSON-specific functions and operators available for data stored in these data types; see &lt;a href=&quot;functions-json&quot;&gt;Section 9.16&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b285244e0c7fb77cf325258e945007dbcb0bd79" translate="yes" xml:space="preserve">
          <source>JSON objects are better suited than arrays for testing containment or existence when there are many keys or elements involved, because unlike arrays they are internally optimized for searching, and do not need to be searched linearly.</source>
          <target state="translated">当涉及到很多键或元素时,JSON对象比数组更适合测试包含性或存在性,因为与数组不同的是,JSON对象在内部进行了搜索优化,不需要进行线性搜索。</target>
        </trans-unit>
        <trans-unit id="ff7a8b7bee4833026249925bb4a7e075a31995d4" translate="yes" xml:space="preserve">
          <source>JSON primitive type</source>
          <target state="translated">JSON基本类型</target>
        </trans-unit>
        <trans-unit id="21d0c78d1738d7a3274678ad613fc7038b9e1cd3" translate="yes" xml:space="preserve">
          <source>JSON query functions and operators pass the provided path expression to the &lt;em&gt;path engine&lt;/em&gt; for evaluation. If the expression matches the queried JSON data, the corresponding JSON item, or set of items, is returned. Path expressions are written in the SQL/JSON path language and can include arithmetic expressions and functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="196dea5dbe3d820f7bdbd4775445b07993543c68" translate="yes" xml:space="preserve">
          <source>JSON query functions and operators pass the provided path expression to the &lt;em&gt;path engine&lt;/em&gt; for evaluation. If the expression matches the queried JSON data, the corresponding SQL/JSON item is returned. Path expressions are written in the SQL/JSON path language and can also include arithmetic expressions and functions. Query functions treat the provided expression as a text string, so it must be enclosed in single quotes.</source>
          <target state="translated">JSON查询函数和运算符将提供的路径表达式传递给&lt;em&gt;路径引擎&lt;/em&gt;以进行评估。如果表达式与查询的JSON数据匹配，则返回相应的SQL / JSON项。路径表达式是用SQL / JSON路径语言编写的，还可以包括算术表达式和函数。查询函数将提供的表达式视为文本字符串，因此必须将其括在单引号中。</target>
        </trans-unit>
        <trans-unit id="7af619b9c5342e6a889b85ca2cae08237b23f616" translate="yes" xml:space="preserve">
          <source>JSON: SQL/JSON Path Language</source>
          <target state="translated">JSON:SQL/JSON路径语言</target>
        </trans-unit>
        <trans-unit id="efed3690ea2243f5f1ac77cbb0987e5335440258" translate="yes" xml:space="preserve">
          <source>Jan</source>
          <target state="translated">Jan</target>
        </trans-unit>
        <trans-unit id="ebeb4b5ab2f3409935c06be07e3191bf0a5dc6cf" translate="yes" xml:space="preserve">
          <source>Jan-08-1999</source>
          <target state="translated">Jan-08-1999</target>
        </trans-unit>
        <trans-unit id="521a936bf91733c55274b55367cc8ed71292693f" translate="yes" xml:space="preserve">
          <source>Jan-08-99</source>
          <target state="translated">Jan-08-99</target>
        </trans-unit>
        <trans-unit id="7a22d73d336abd6281d4dd71080220a230cb79de" translate="yes" xml:space="preserve">
          <source>January</source>
          <target state="translated">January</target>
        </trans-unit>
        <trans-unit id="d6e52d181e7ba4487fe8643d957277cd1cbf82c7" translate="yes" xml:space="preserve">
          <source>January 18 in &lt;code&gt;MDY&lt;/code&gt; mode; rejected in other modes</source>
          <target state="translated">1月18日在 &lt;code&gt;MDY&lt;/code&gt; 模式下；在其他模式下被拒绝</target>
        </trans-unit>
        <trans-unit id="d1fb4cc8c23271615e96e586a4e1801c1ac84f25" translate="yes" xml:space="preserve">
          <source>January 2, 2003 in &lt;code&gt;MDY&lt;/code&gt; mode; February 1, 2003 in &lt;code&gt;DMY&lt;/code&gt; mode; February 3, 2001 in &lt;code&gt;YMD&lt;/code&gt; mode</source>
          <target state="translated">2003年1月2日处于 &lt;code&gt;MDY&lt;/code&gt; 模式；2003年2月1日，在 &lt;code&gt;DMY&lt;/code&gt; 模式下；2001年2月3日，在 &lt;code&gt;YMD&lt;/code&gt; 模式下</target>
        </trans-unit>
        <trans-unit id="397474e233d9068687b354fbdbc0b01176bcc2cc" translate="yes" xml:space="preserve">
          <source>January 8 in &lt;code&gt;MDY&lt;/code&gt; mode; August 1 in &lt;code&gt;DMY&lt;/code&gt; mode</source>
          <target state="translated">1月8日处于 &lt;code&gt;MDY&lt;/code&gt; 模式；8月1日在 &lt;code&gt;DMY&lt;/code&gt; 模式下</target>
        </trans-unit>
        <trans-unit id="2391ee88b9183f9c31234260c9722e2d62c959b0" translate="yes" xml:space="preserve">
          <source>January 8 in &lt;code&gt;YMD&lt;/code&gt; mode, else error</source>
          <target state="translated">1月8日处于 &lt;code&gt;YMD&lt;/code&gt; 模式，否则出现错误</target>
        </trans-unit>
        <trans-unit id="347ee622c39fd3015013d75c9106e7b8164231b7" translate="yes" xml:space="preserve">
          <source>January 8 in any mode</source>
          <target state="translated">1月8日,在任何模式下</target>
        </trans-unit>
        <trans-unit id="682c812bf69e66e4c213bdbcc9a0930f43e82030" translate="yes" xml:space="preserve">
          <source>January 8, 1999</source>
          <target state="translated">1999年1月8日</target>
        </trans-unit>
        <trans-unit id="4444d015dc1b7e202a7ab992a769c820f60f9019" translate="yes" xml:space="preserve">
          <source>January 8, 99 BC</source>
          <target state="translated">公元前99年1月8日</target>
        </trans-unit>
        <trans-unit id="07425bcd86481aaf19f3e5b4016da2c9f5e1cec4" translate="yes" xml:space="preserve">
          <source>January 8, except error in &lt;code&gt;YMD&lt;/code&gt; mode</source>
          <target state="translated">1月8日，除了 &lt;code&gt;YMD&lt;/code&gt; 模式下的错误</target>
        </trans-unit>
        <trans-unit id="9239c22d1d1c990ca8c206cb408b345a3ec8114c" translate="yes" xml:space="preserve">
          <source>Japanese</source>
          <target state="translated">Japanese</target>
        </trans-unit>
        <trans-unit id="21087b70eba36ef97c23b6fae1bc0502a8c7faff" translate="yes" xml:space="preserve">
          <source>Java Database Connectivity</source>
          <target state="translated">Java数据库连接</target>
        </trans-unit>
        <trans-unit id="94e850a9fa9f98700106bfba6b5849640ea65567" translate="yes" xml:space="preserve">
          <source>JavaScript Object Notation</source>
          <target state="translated">JavaScript对象符号</target>
        </trans-unit>
        <trans-unit id="66dc64282e7e424443c0ee036f6560a8429101fe" translate="yes" xml:space="preserve">
          <source>Jean-Luc Cooke Fortuna-based &lt;code&gt;/dev/random&lt;/code&gt; driver for Linux.</source>
          <target state="translated">基于Jean-Luc Cooke Fortuna的 &lt;code&gt;/dev/random&lt;/code&gt; 驱动程序，用于Linux。</target>
        </trans-unit>
        <trans-unit id="076e3b3dd165a68d5a1635c764f91d575d41e991" translate="yes" xml:space="preserve">
          <source>Joe Conway</source>
          <target state="translated">乔-康威</target>
        </trans-unit>
        <trans-unit id="36223c3c072f8f4857df7670837893beb8c9ab05" translate="yes" xml:space="preserve">
          <source>John Gray &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:jgray@azuli.co.uk&quot;&gt;jgray@azuli.co.uk&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">约翰&amp;middot;格雷 &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:jgray@azuli.co.uk&quot;&gt;jgray@azuli.co.uk&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e0d73143de80d17e82de2e017ac156ca3b9c4e01" translate="yes" xml:space="preserve">
          <source>Join</source>
          <target state="translated">Join</target>
        </trans-unit>
        <trans-unit id="5253095e71e396147a5bb85865b313a4dfaabec4" translate="yes" xml:space="preserve">
          <source>Join queries of the kind seen thus far can also be written in this alternative form:</source>
          <target state="translated">到目前为止所看到的那种连接查询也可以用这种替代形式来写。</target>
        </trans-unit>
        <trans-unit id="5d51427844afa7a67c043cae62a1e058c08bf8eb" translate="yes" xml:space="preserve">
          <source>Join selectivity estimation function for this operator</source>
          <target state="translated">该算子的加入选择性估计函数</target>
        </trans-unit>
        <trans-unit id="60bbcdff104b8ef5971151f077f9a3a69bf41608" translate="yes" xml:space="preserve">
          <source>Joins of all types can be chained together, or nested: either or both &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; can be joined tables. Parentheses can be used around &lt;code&gt;JOIN&lt;/code&gt; clauses to control the join order. In the absence of parentheses, &lt;code&gt;JOIN&lt;/code&gt; clauses nest left-to-right.</source>
          <target state="translated">可以将所有类型的联接链接在一起或嵌套： &lt;code&gt;T1&lt;/code&gt; 和 &lt;code&gt;T2&lt;/code&gt; 之一或两者都可以联接表。可以在 &lt;code&gt;JOIN&lt;/code&gt; 子句周围使用括号来控制连接顺序。在没有括号的情况下， &lt;code&gt;JOIN&lt;/code&gt; 子句从左到右嵌套。</target>
        </trans-unit>
        <trans-unit id="b737558468d75ca55b2d9185c0b55eacaea627a0" translate="yes" xml:space="preserve">
          <source>Jul</source>
          <target state="translated">Jul</target>
        </trans-unit>
        <trans-unit id="a78c0406ce3eb63581cbacb7e7085ef4cbc36ad9" translate="yes" xml:space="preserve">
          <source>Julian Day (integer days since November 24, 4714 BC at midnight UTC)</source>
          <target state="translated">朱利安日</target>
        </trans-unit>
        <trans-unit id="b597ea9fa797a2c2073652808359aeb10b763510" translate="yes" xml:space="preserve">
          <source>Julian date</source>
          <target state="translated">朱利安日期</target>
        </trans-unit>
        <trans-unit id="df97a42549e5c0e1753b985126565531cc9f3c56" translate="yes" xml:space="preserve">
          <source>July</source>
          <target state="translated">July</target>
        </trans-unit>
        <trans-unit id="6d90df3be4d0d43b08e3fb47f55e09b5b06dae3e" translate="yes" xml:space="preserve">
          <source>Jun</source>
          <target state="translated">Jun</target>
        </trans-unit>
        <trans-unit id="a9db906761699b31567727716eaa6fd19ae5f5d5" translate="yes" xml:space="preserve">
          <source>June</source>
          <target state="translated">June</target>
        </trans-unit>
        <trans-unit id="7b1ddc607d5041d94adba7779845219a639a5e00" translate="yes" xml:space="preserve">
          <source>Just as in a non-parallel plan, the driving table may be joined to one or more other tables using a nested loop, hash join, or merge join. The inner side of the join may be any kind of non-parallel plan that is otherwise supported by the planner provided that it is safe to run within a parallel worker. Depending on the join type, the inner side may also be a parallel plan.</source>
          <target state="translated">就像在非并行计划中一样,驱动表可以使用嵌套循环、哈希连接或合并连接连接到一个或多个其他表。联接的内侧可以是计划器支持的任何类型的非并行计划,只要它在并行工作者内运行是安全的。根据连接类型,内侧也可以是并行计划。</target>
        </trans-unit>
        <trans-unit id="dce656c6d5efc6ceb90feb56120166673a499a99" translate="yes" xml:space="preserve">
          <source>Just as in a table, every output column of a &lt;code&gt;SELECT&lt;/code&gt; has a name. In a simple &lt;code&gt;SELECT&lt;/code&gt; this name is just used to label the column for display, but when the &lt;code&gt;SELECT&lt;/code&gt; is a sub-query of a larger query, the name is seen by the larger query as the column name of the virtual table produced by the sub-query. To specify the name to use for an output column, write &lt;code&gt;AS&lt;/code&gt;&lt;code&gt;output_name&lt;/code&gt; after the column's expression. (You can omit &lt;code&gt;AS&lt;/code&gt;, but only if the desired output name does not match any PostgreSQL keyword (see &lt;a href=&quot;sql-keywords-appendix&quot;&gt;Appendix C&lt;/a&gt;). For protection against possible future keyword additions, it is recommended that you always either write &lt;code&gt;AS&lt;/code&gt; or double-quote the output name.) If you do not specify a column name, a name is chosen automatically by PostgreSQL. If the column's expression is a simple column reference then the chosen name is the same as that column's name. In more complex cases a function or type name may be used, or the system may fall back on a generated name such as &lt;code&gt;?column?&lt;/code&gt;.</source>
          <target state="translated">就像在表中一样， &lt;code&gt;SELECT&lt;/code&gt; 的每个输出列都有一个名称。在简单的 &lt;code&gt;SELECT&lt;/code&gt; 中,此名称仅用于标记要显示的列，但是当 &lt;code&gt;SELECT&lt;/code&gt; 是较大查询的子查询时，该名称在较大查询中被视为由该子查询生成的虚拟表的列名。 -查询。要指定用于输出列的名称，请在该列的表达式之后写入 &lt;code&gt;AS&lt;/code&gt; &lt;code&gt;output_name&lt;/code&gt; 。 （您可以省略 &lt;code&gt;AS&lt;/code&gt; ，但仅在所需的输出名称与任何PostgreSQL关键字不匹配时（请参见&lt;a href=&quot;sql-keywords-appendix&quot;&gt;附录C&lt;/a&gt;）。为了防止将来可能添加其他关键字，建议您始终编写 &lt;code&gt;AS&lt;/code&gt; 或在输出名称中使用双引号。）如果未指定列名称，则PostgreSQL将自动选择一个名称。如果列的表达式是简单的列引用，则所选名称与该列的名称相同。在更复杂的情况下，可以使用函数或类型名称，或者系统可能会依赖生成的名称（例如&amp;ldquo; &lt;code&gt;?column?&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="643851cd97b3016db737a7445d565c8fa4d8baef" translate="yes" xml:space="preserve">
          <source>Just as with indexes, a foreign key constraint can be checked &amp;ldquo;in bulk&amp;rdquo; more efficiently than row-by-row. So it might be useful to drop foreign key constraints, load data, and re-create the constraints. Again, there is a trade-off between data load speed and loss of error checking while the constraint is missing.</source>
          <target state="translated">与索引一样，外键约束可以比逐行更有效地&amp;ldquo;批量&amp;rdquo;检查。因此，删除外键约束，加载数据并重新创建约束可能很有用。同样，在缺少约束的情况下，需要在数据加载速度和错误检查丢失之间进行权衡。</target>
        </trans-unit>
        <trans-unit id="22069315e577148c2b004f5dd6381d3b0deef8a4" translate="yes" xml:space="preserve">
          <source>Just-in-Time (JIT) compilation is the process of turning some form of interpreted program evaluation into a native program, and doing so at run time. For example, instead of using general-purpose code that can evaluate arbitrary SQL expressions to evaluate a particular SQL predicate like &lt;code&gt;WHERE a.col = 3&lt;/code&gt;, it is possible to generate a function that is specific to that expression and can be natively executed by the CPU, yielding a speedup.</source>
          <target state="translated">即时（JIT）编译是将某种形式的解释程序评估转换为本机程序，然后在运行时进行的过程。例如，代替使用可以评估任意SQL表达式的通用代码来评估诸如 &lt;code&gt;WHERE a.col = 3&lt;/code&gt; 的特定SQL谓词，可以生成特定于该表达式的函数，并且可以由该函数本机执行。 CPU，加速。</target>
        </trans-unit>
        <trans-unit id="7af7e7edb636e51ba6b7f08c539611e4a0057634" translate="yes" xml:space="preserve">
          <source>Just-in-Time Compilation (JIT)</source>
          <target state="translated">即时编译(JIT)</target>
        </trans-unit>
        <trans-unit id="299af5e109b0aae56134447e7dc2dcce5de37f34" translate="yes" xml:space="preserve">
          <source>Just-in-Time compilation</source>
          <target state="translated">及时编纂</target>
        </trans-unit>
        <trans-unit id="ffa7300d92e16f73d505ed4698fdd4e962ca51c4" translate="yes" xml:space="preserve">
          <source>KAME kame/sys/crypto</source>
          <target state="translated">KAME kame/sys/crypto</target>
        </trans-unit>
        <trans-unit id="6b88dae842421fa69ad059376e38f360417c6965" translate="yes" xml:space="preserve">
          <source>KOI8-R</source>
          <target state="translated">KOI8-R</target>
        </trans-unit>
        <trans-unit id="ad190609bef1a0712934b8949ffb7c06fbaa6862" translate="yes" xml:space="preserve">
          <source>KOI8-U</source>
          <target state="translated">KOI8-U</target>
        </trans-unit>
        <trans-unit id="8f29952f92109ac24c1d37762ea2beef09083c31" translate="yes" xml:space="preserve">
          <source>KaiGai Kohei &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:kaigai@ak.jp.nec.com&quot;&gt;kaigai@ak.jp.nec.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">KaiGai Kohei &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:kaigai@ak.jp.nec.com&quot;&gt;kaigai@ak.jp.nec.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0cd084d348b2278c1d6044754c142d3183367365" translate="yes" xml:space="preserve">
          <source>Keep in mind that all aggregate functions are evaluated before evaluating any &amp;ldquo;scalar&amp;rdquo; expressions in the &lt;code&gt;HAVING&lt;/code&gt; clause or &lt;code&gt;SELECT&lt;/code&gt; list. This means that, for example, a &lt;code&gt;CASE&lt;/code&gt; expression cannot be used to skip evaluation of an aggregate function; see &lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;Section 4.2.14&lt;/a&gt;.</source>
          <target state="translated">请记住，在评估 &lt;code&gt;HAVING&lt;/code&gt; 子句或 &lt;code&gt;SELECT&lt;/code&gt; 列表中的任何&amp;ldquo;标量&amp;rdquo;表达式之前，将评估所有聚合函数。这意味着，例如， &lt;code&gt;CASE&lt;/code&gt; 表达式不能用于跳过对聚合函数的求值；参见&lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;第4.2.14节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a262b9c7138e1926e93240d562f76b55145fd596" translate="yes" xml:space="preserve">
          <source>Keep in mind that because &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; actually runs the query, any side-effects will happen as usual, even though whatever results the query might output are discarded in favor of printing the &lt;code&gt;EXPLAIN&lt;/code&gt; data. If you want to analyze a data-modifying query without changing your tables, you can roll the command back afterwards, for example:</source>
          <target state="translated">请记住，因为 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 实际上运行查询，所以任何副作用都会照常发生，即使为了打印 &lt;code&gt;EXPLAIN&lt;/code&gt; 数据而丢弃了查询可能输出的任何结果。如果要在不更改表的情况下分析数据修改查询，则可以在之后回滚该命令，例如：</target>
        </trans-unit>
        <trans-unit id="66b96c146884aa3a6a00a301b320c6680d6f4464" translate="yes" xml:space="preserve">
          <source>Keep in mind that by default, a regular expression can match just part of a string. It's usually wise to use &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt;, as shown in the above example, to force the match to be to the entire system user name.</source>
          <target state="translated">请记住，默认情况下，正则表达式只能匹配一部分字符串。如上例所示，通常明智的做法是使用 &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;$&lt;/code&gt; 来强制匹配整个系统用户名。</target>
        </trans-unit>
        <trans-unit id="c42b9dd519f94f2582e4a71f3f708e12c5a9653d" translate="yes" xml:space="preserve">
          <source>Keep in mind that it is important to specify the configuration name explicitly when creating &lt;code&gt;tsvector&lt;/code&gt; values inside triggers, so that the column's contents will not be affected by changes to &lt;code&gt;default_text_search_config&lt;/code&gt;. Failure to do this is likely to lead to problems such as search results changing after a dump and reload.</source>
          <target state="translated">请记住，在触发器内创建 &lt;code&gt;tsvector&lt;/code&gt; 值时，显式指定配置名称很重要，这样列的内容将不会受到对 &lt;code&gt;default_text_search_config&lt;/code&gt; 的更改的影响。否则，可能会导致诸如转储和重新加载后搜索结果发生更改之类的问题。</target>
        </trans-unit>
        <trans-unit id="f3ea22672b214f2b49222df5e8cffc5ea2a095eb" translate="yes" xml:space="preserve">
          <source>Keep in mind that setting up a partial index indicates that you know at least as much as the query planner knows, in particular you know when an index might be profitable. Forming this knowledge requires experience and understanding of how indexes in PostgreSQL work. In most cases, the advantage of a partial index over a regular index will be minimal.</source>
          <target state="translated">请记住,设置一个部分索引表明你至少和查询规划器知道的一样多,特别是你知道什么时候索引可能是有利可图的。形成这种知识需要经验和对PostgreSQL中索引工作方式的理解。在大多数情况下,部分索引比普通索引的优势会很小。</target>
        </trans-unit>
        <trans-unit id="3bf0ca5e99386c2632aea1fa222371e26d7ffb9e" translate="yes" xml:space="preserve">
          <source>Keep in mind that setting up a partial index indicates that you know at least as much as the query planner knows, in particular you know when an index might be profitable. Forming this knowledge requires experience and understanding of how indexes in PostgreSQL work. In most cases, the advantage of a partial index over a regular index will be minimal. There are cases where they are quite counterproductive, as in &lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX4&quot;&gt;Example 11.4&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef88fc4a4ab28c6433ccdb43fa109f84e6bdf441" translate="yes" xml:space="preserve">
          <source>Keep in mind that the &lt;code&gt;hstore&lt;/code&gt; text format, when used for input, applies &lt;em&gt;before&lt;/em&gt; any required quoting or escaping. If you are passing an &lt;code&gt;hstore&lt;/code&gt; literal via a parameter, then no additional processing is needed. But if you're passing it as a quoted literal constant, then any single-quote characters and (depending on the setting of the &lt;code&gt;standard_conforming_strings&lt;/code&gt; configuration parameter) backslash characters need to be escaped correctly. See &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;Section 4.1.2.1&lt;/a&gt; for more on the handling of string constants.</source>
          <target state="translated">请记住，将 &lt;code&gt;hstore&lt;/code&gt; 文本格式用于输入时，请&lt;em&gt;在进行&lt;/em&gt;任何必需的引号或转义&lt;em&gt;之前&lt;/em&gt;应用。如果要通过参数传递 &lt;code&gt;hstore&lt;/code&gt; 文字，则不需要其他处理。但是，如果将其作为带引号的文字常量传递，则任何单引号字符和（取决于 &lt;code&gt;standard_conforming_strings&lt;/code&gt; 配置参数的设置）反斜杠字符都必须正确转义。有关字符串常量的更多处理，请参见&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;第4.1.2.1节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3f96958d65d9c021639ce27dbbdb3f614f469552" translate="yes" xml:space="preserve">
          <source>Keep in mind that the delay parameters are compared to the elapsed time since the WAL data was received by the standby server. Thus, the grace period allowed to any one query on the standby is never more than the delay parameter, and could be considerably less if the standby has already fallen behind as a result of waiting for previous queries to complete, or as a result of being unable to keep up with a heavy update load.</source>
          <target state="translated">请记住,延迟参数是与备用服务器收到WAL数据后的时间进行比较的。因此,允许在备用服务器上进行的任何一个查询的宽限期永远不会超过延迟参数,如果备用服务器由于等待以前的查询完成而已经落后,或者由于无法跟上繁重的更新负载,那么宽限期可能会大大减少。</target>
        </trans-unit>
        <trans-unit id="281e2d1f4654cd490bed6ab58e757285785a6b63" translate="yes" xml:space="preserve">
          <source>Keep in mind that the pattern argument of &lt;code&gt;like_regex&lt;/code&gt; is a JSON path string literal, written according to the rules given in &lt;a href=&quot;datatype-json#DATATYPE-JSONPATH&quot;&gt;Section 8.14.6&lt;/a&gt;. This means in particular that any backslashes you want to use in the regular expression must be doubled. For example, to match strings that contain only digits:</source>
          <target state="translated">请记住， &lt;code&gt;like_regex&lt;/code&gt; 的pattern参数是JSON路径字符串文字，根据&lt;a href=&quot;datatype-json#DATATYPE-JSONPATH&quot;&gt;8.14.6节中&lt;/a&gt;给出的规则编写。特别是这意味着您要在正则表达式中使用的任何反斜杠都必须加倍。例如，要匹配仅包含数字的字符串：</target>
        </trans-unit>
        <trans-unit id="752b636fa6947f13347177c43e220a338c0e1d06" translate="yes" xml:space="preserve">
          <source>Keep in mind that the statement is actually executed when the &lt;code&gt;ANALYZE&lt;/code&gt; option is used. Although &lt;code&gt;EXPLAIN&lt;/code&gt; will discard any output that a &lt;code&gt;SELECT&lt;/code&gt; would return, other side effects of the statement will happen as usual. If you wish to use &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; on an &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;CREATE TABLE AS&lt;/code&gt;, or &lt;code&gt;EXECUTE&lt;/code&gt; statement without letting the command affect your data, use this approach:</source>
          <target state="translated">请记住，使用 &lt;code&gt;ANALYZE&lt;/code&gt; 选项时，该语句实际上已执行。尽管 &lt;code&gt;EXPLAIN&lt;/code&gt; 会丢弃 &lt;code&gt;SELECT&lt;/code&gt; 将返回的任何输出，但是该语句的其他副作用将照常发生。如果您希望在 &lt;code&gt;INSERT&lt;/code&gt; ， &lt;code&gt;UPDATE&lt;/code&gt; ， &lt;code&gt;DELETE&lt;/code&gt; ， &lt;code&gt;CREATE TABLE AS&lt;/code&gt; 或 &lt;code&gt;EXECUTE&lt;/code&gt; 语句上使用 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 而不让该命令影响您的数据，请使用以下方法：</target>
        </trans-unit>
        <trans-unit id="1a83b7d50233b6c01f2847bb1d523d1444438ed5" translate="yes" xml:space="preserve">
          <source>Keep the default. All users access the public schema implicitly. This simulates the situation where schemas are not available at all, giving a smooth transition from the non-schema-aware world. However, any user can issue arbitrary queries under the identity of any user not electing to protect itself individually. This pattern is acceptable only when the database has a single user or a few mutually-trusting users.</source>
          <target state="translated">保留默认值。所有用户都会隐性地访问公共模式。这模拟了模式完全不可用的情况,给非模式感知的世界一个平滑的过渡。然而,任何用户都可以在任何不选择单独保护自己的用户的身份下发出任意查询。只有当数据库只有一个用户或几个相互信任的用户时,这种模式才是可以接受的。</target>
        </trans-unit>
        <trans-unit id="7b02debd129668317e39732d6dfb75d3b401f787" translate="yes" xml:space="preserve">
          <source>Keep the default. All users access the public schema implicitly. This simulates the situation where schemas are not available at all, giving a smooth transition from the non-schema-aware world. However, this is never a secure pattern. It is acceptable only when the database has a single user or a few mutually-trusting users.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01c357ee3905e2cb6c0488939e3efd4649d18496" translate="yes" xml:space="preserve">
          <source>Keep the partitioning constraints simple, else the planner may not be able to prove that child tables might not need to be visited. Use simple equality conditions for list partitioning, or simple range tests for range partitioning, as illustrated in the preceding examples. A good rule of thumb is that partitioning constraints should contain only comparisons of the partitioning column(s) to constants using B-tree-indexable operators, because only B-tree-indexable column(s) are allowed in the partition key.</source>
          <target state="translated">保持简单的分区约束,否则规划者可能无法证明子表可能不需要访问。对列表分区使用简单的平等条件,或对范围分区使用简单的范围测试,如前面的例子所示。一个好的经验法则是,分区约束应该只包含分区列与使用B-tree-indexable运算符的常量的比较,因为分区键中只允许使用B-tree-indexable列。</target>
        </trans-unit>
        <trans-unit id="e2032a298b60ea58db844215a572d895ea523039" translate="yes" xml:space="preserve">
          <source>Kernels can also have system-wide limits on some resources.</source>
          <target state="translated">内核也可以对一些资源进行全系统的限制。</target>
        </trans-unit>
        <trans-unit id="c67dd20ee842986086a0a915ddc2a279490130ed" translate="yes" xml:space="preserve">
          <source>Key</source>
          <target state="translated">Key</target>
        </trans-unit>
        <trans-unit id="59dfe7e6cfc40d95e215dd77804938b17f6c9f40" translate="yes" xml:space="preserve">
          <source>Key Word</source>
          <target state="translated">关键字</target>
        </trans-unit>
        <trans-unit id="8e27223f630d5f11e0e66ca4d82327af33bd02f7" translate="yes" xml:space="preserve">
          <source>Key value of the row to start at</source>
          <target state="translated">行的键值开始于</target>
        </trans-unit>
        <trans-unit id="fa701570481252ff476a0ecf4e2d51ece76ebca1" translate="yes" xml:space="preserve">
          <source>Key words and unquoted identifiers are case insensitive. Therefore:</source>
          <target state="translated">关键词和未引用的标识符不区分大小写。因此:</target>
        </trans-unit>
        <trans-unit id="dec66c5bf0f7fe4cc038ac871def8eb1ac31c146" translate="yes" xml:space="preserve">
          <source>Korean</source>
          <target state="translated">Korean</target>
        </trans-unit>
        <trans-unit id="2ceaa9727ea6aa546bde8ab43842a8c79efd8f8d" translate="yes" xml:space="preserve">
          <source>Korean (Hangul)</source>
          <target state="translated">韩语</target>
        </trans-unit>
        <trans-unit id="2bfe4366aec039158c13cdff560c53552a6ab2f8" translate="yes" xml:space="preserve">
          <source>LATIN1 with Euro and accents</source>
          <target state="translated">纬度1,带欧式和口音</target>
        </trans-unit>
        <trans-unit id="a3f57123a6c2ff10f831d7d1652f96a64aa8ede6" translate="yes" xml:space="preserve">
          <source>LC_COLLATE for this database</source>
          <target state="translated">该数据库的LC_COLLATE</target>
        </trans-unit>
        <trans-unit id="ccd2341e80cefe881c6b471888b83c35d3eedb65" translate="yes" xml:space="preserve">
          <source>LC_CTYPE for this database</source>
          <target state="translated">该数据库的LC_CTYPE</target>
        </trans-unit>
        <trans-unit id="d8343c683ae1584c96390fa627005bc1bb0719cd" translate="yes" xml:space="preserve">
          <source>LDAP</source>
          <target state="translated">LDAP</target>
        </trans-unit>
        <trans-unit id="d11fef55a0f4f7f77f5a743808a9e2af4cfab644" translate="yes" xml:space="preserve">
          <source>LDAP Authentication</source>
          <target state="translated">LDAP认证</target>
        </trans-unit>
        <trans-unit id="3af0c4862ddb95641f4519deb20c9bd92b5a696b" translate="yes" xml:space="preserve">
          <source>LDAP URLs are currently only supported with OpenLDAP, not on Windows.</source>
          <target state="translated">LDAP URL目前只支持OpenLDAP,在Windows上不支持。</target>
        </trans-unit>
        <trans-unit id="a78f006babbca44fb715e5663d9cdd5f718dd110" translate="yes" xml:space="preserve">
          <source>LDAP authentication can operate in two modes. In the first mode, which we will call the simple bind mode, the server will bind to the distinguished name constructed as &lt;code&gt;prefix&lt;/code&gt;&lt;code&gt;username&lt;/code&gt;&lt;code&gt;suffix&lt;/code&gt;. Typically, the &lt;code&gt;prefix&lt;/code&gt; parameter is used to specify &lt;code&gt;cn=&lt;/code&gt;, or &lt;code&gt;DOMAIN&lt;/code&gt;&lt;code&gt;\&lt;/code&gt; in an Active Directory environment. &lt;code&gt;suffix&lt;/code&gt; is used to specify the remaining part of the DN in a non-Active Directory environment.</source>
          <target state="translated">LDAP身份验证可以两种方式运行。在第一种模式下，我们将其称为简单绑定模式，服务器将绑定到以 &lt;code&gt;prefix&lt;/code&gt; &lt;code&gt;username&lt;/code&gt; &lt;code&gt;suffix&lt;/code&gt; 构造的专有名称。通常， &lt;code&gt;prefix&lt;/code&gt; 参数用于在Active Directory环境中指定 &lt;code&gt;cn=&lt;/code&gt; 或 &lt;code&gt;DOMAIN&lt;/code&gt; &lt;code&gt;\&lt;/code&gt; 。 &lt;code&gt;suffix&lt;/code&gt; 用于在非Active Directory环境中指定DN的其余部分。</target>
        </trans-unit>
        <trans-unit id="9bd1b0f9c2859218ce1180337a2bd66b96113b2f" translate="yes" xml:space="preserve">
          <source>LIMIT and OFFSET</source>
          <target state="translated">限位和偏移</target>
        </trans-unit>
        <trans-unit id="9c6023564f6507b3ea5cad8e472da23961b9afbb" translate="yes" xml:space="preserve">
          <source>LISTEN</source>
          <target state="translated">LISTEN</target>
        </trans-unit>
        <trans-unit id="9814f182fea16d601141a37a9089918cd74f5452" translate="yes" xml:space="preserve">
          <source>LISTEN &amp;mdash; listen for a notification</source>
          <target state="translated">LISTEN &amp;mdash;收听通知</target>
        </trans-unit>
        <trans-unit id="8d0c622ff5ca1933ba98627381a4a7d1db679d31" translate="yes" xml:space="preserve">
          <source>LLVM has support for optimizing generated code. Some of the optimizations are cheap enough to be performed whenever JIT is used, while others are only beneficial for longer-running queries. See &lt;a href=&quot;https://llvm.org/docs/Passes.html#transform-passes&quot;&gt;https://llvm.org/docs/Passes.html#transform-passes&lt;/a&gt; for more details about optimizations.</source>
          <target state="translated">LLVM支持优化生成的代码。其中一些优化足够便宜，可以在使用JIT时执行，而其他优化仅对运行时间较长的查询有利。有关优化的更多详细信息，请参见&lt;a href=&quot;https://llvm.org/docs/Passes.html#transform-passes&quot;&gt;https://llvm.org/docs/Passes.html#transform-passes&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="97eb8c80f7fd9d9f6120c3bffd79e5e23e575196" translate="yes" xml:space="preserve">
          <source>LOAD</source>
          <target state="translated">LOAD</target>
        </trans-unit>
        <trans-unit id="ca2a082afa739ad45f7209a3186244665643f398" translate="yes" xml:space="preserve">
          <source>LOAD &amp;mdash; load a shared library file</source>
          <target state="translated">LOAD &amp;mdash;加载共享库文件</target>
        </trans-unit>
        <trans-unit id="c37eb4cb935a6017aaaaaab327837c7d9bbbc004" translate="yes" xml:space="preserve">
          <source>LOCK</source>
          <target state="translated">LOCK</target>
        </trans-unit>
        <trans-unit id="92d4fa824b1bf5ae650f5b90867eff13a3a5fe0a" translate="yes" xml:space="preserve">
          <source>LOCK &amp;mdash; lock a table</source>
          <target state="translated">LOCK-锁定桌子</target>
        </trans-unit>
        <trans-unit id="6b4bea52cbee20f8507b76217f199114a117089e" translate="yes" xml:space="preserve">
          <source>LSN</source>
          <target state="translated">LSN</target>
        </trans-unit>
        <trans-unit id="d1fca76fb082d22a2d8e514d1b3ce5e3ce9aa851" translate="yes" xml:space="preserve">
          <source>LSN: next byte after last byte of WAL record for last change to this page</source>
          <target state="translated">LSN:WAL记录的最后一个字节后的下一个字节,表示该页最后一次修改。</target>
        </trans-unit>
        <trans-unit id="f7d6ac021994cd293b3c94c2f6248d32ae9579b5" translate="yes" xml:space="preserve">
          <source>Lag times work automatically for physical replication. Logical decoding plugins may optionally emit tracking messages; if they do not, the tracking mechanism will simply display NULL lag.</source>
          <target state="translated">滞后时间对物理复制自动工作。逻辑解码插件可以选择性地发出跟踪消息;如果不发出,跟踪机制将简单地显示NULL滞后。</target>
        </trans-unit>
        <trans-unit id="89b86ab0e66f527166d98df92ddbcf5416ed58f6" translate="yes" xml:space="preserve">
          <source>Language</source>
          <target state="translated">Language</target>
        </trans-unit>
        <trans-unit id="5e9465d239944a0fa40232e75aff84b43ba97385" translate="yes" xml:space="preserve">
          <source>Language of messages</source>
          <target state="translated">信息的语言</target>
        </trans-unit>
        <trans-unit id="ce146ba97ccf4a9eb00c4f7b7284970bf1503949" translate="yes" xml:space="preserve">
          <source>Large objects (see &lt;a href=&quot;https://www.postgresql.org/docs/12/largeobjects.html&quot;&gt;Chapter 34&lt;/a&gt;) are not replicated. There is no workaround for that, other than storing data in normal tables.</source>
          <target state="translated">大对象（请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/largeobjects.html&quot;&gt;第34章&lt;/a&gt;）不会被复制。除了将数据存储在普通表中之外，没有其他解决方法。</target>
        </trans-unit>
        <trans-unit id="f6b0e78c3e5e8149e57bd763e4fa479405b51a85" translate="yes" xml:space="preserve">
          <source>Large objects (see &lt;a href=&quot;https://www.postgresql.org/docs/13/largeobjects.html&quot;&gt;Chapter 34&lt;/a&gt;) are not replicated. There is no workaround for that, other than storing data in normal tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a24b3c46d4ed7dfe7397ec67ef490f12c7f2d62a" translate="yes" xml:space="preserve">
          <source>Last system OID in the database; useful particularly to pg_dump</source>
          <target state="translated">数据库中的最后一个系统OID;对pg_dump特别有用。</target>
        </trans-unit>
        <trans-unit id="d8a8330f47a1d2121f7de4d246b07c539d85b887" translate="yes" xml:space="preserve">
          <source>Last time at which this table was analyzed by the autovacuum daemon</source>
          <target state="translated">自动真空守护程序最后一次分析该表的时间。</target>
        </trans-unit>
        <trans-unit id="b5daedfbaeb26dce099e49150d7deba8ed7dd63c" translate="yes" xml:space="preserve">
          <source>Last time at which this table was manually analyzed</source>
          <target state="translated">本表最后一次进行人工分析的时间。</target>
        </trans-unit>
        <trans-unit id="d21dc8edf16ccb5721e0bc05e599292ce8cd64c2" translate="yes" xml:space="preserve">
          <source>Last time at which this table was manually vacuumed (not counting &lt;code&gt;VACUUM FULL&lt;/code&gt;)</source>
          <target state="translated">上次手动清理此表的时间（不计 &lt;code&gt;VACUUM FULL&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="32d602dc6c753beae99504e742b35637bae47172" translate="yes" xml:space="preserve">
          <source>Last time at which this table was vacuumed by the autovacuum daemon</source>
          <target state="translated">自动吸尘守护程序最后一次吸尘的时间。</target>
        </trans-unit>
        <trans-unit id="a6160372ad225c352ec7ffd4f36cad1f43f752fb" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location already received and flushed to disk, the initial value of this field being the first log location used when WAL receiver is started</source>
          <target state="translated">最后一个已经收到并刷新到磁盘的写头日志位置,此字段的初始值是WAL接收器启动时使用的第一个日志位置。</target>
        </trans-unit>
        <trans-unit id="1c2624daf23aae1afae71faf67ded93dc5500054" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location already received and written to disk, but not flushed. This should not be used for data integrity checks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dd26aafa1fbdf96a846556c081c9e292557ed50" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location flushed to disk by this standby server</source>
          <target state="translated">该备用服务器最后一次刷新到磁盘的写前日志位置。</target>
        </trans-unit>
        <trans-unit id="3196ac97aabe6b93efdbd9d951f27185a4510ea9" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location received, the initial value of this field being 0</source>
          <target state="translated">最后收到的写前日志位置,该字段的初始值为0。</target>
        </trans-unit>
        <trans-unit id="7fce43ad04e1c6ea844b5017a38c520afa802611" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location replayed into the database on this standby server</source>
          <target state="translated">最后一次写入的日志位置重播到这个备用服务器的数据库中。</target>
        </trans-unit>
        <trans-unit id="0d3835b7f40d0e6e66b1e74e7de916b14d4f990d" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location reported to origin WAL sender</source>
          <target state="translated">向原WAL发送者报告的最后一次写前日志位置。</target>
        </trans-unit>
        <trans-unit id="ac1ae56d16c8b53cb449a2ee572fbfc684cbf5dd" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location sent on this connection</source>
          <target state="translated">在此连接上发送的最后一次写头日志位置</target>
        </trans-unit>
        <trans-unit id="bafcffd5bbf934c91f7d04975d6317a745ba4820" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location written to disk by this standby server</source>
          <target state="translated">该备用服务器写入磁盘的最后一个可写日志位置。</target>
        </trans-unit>
        <trans-unit id="ba538f112903a51c4fdd1a1494e1875649a225bb" translate="yes" xml:space="preserve">
          <source>Latin/Arabic</source>
          <target state="translated">Latin/Arabic</target>
        </trans-unit>
        <trans-unit id="fd84929c694afd8b1b6d7503f4f8e1b23aed9285" translate="yes" xml:space="preserve">
          <source>Latin/Cyrillic</source>
          <target state="translated">Latin/Cyrillic</target>
        </trans-unit>
        <trans-unit id="e688538b3f17f5cc30931971a729f9f8fe4c1bdd" translate="yes" xml:space="preserve">
          <source>Latin/Greek</source>
          <target state="translated">Latin/Greek</target>
        </trans-unit>
        <trans-unit id="daa3f6da7a3a4e4229771dc7d3d5e346a4582850" translate="yes" xml:space="preserve">
          <source>Latin/Hebrew</source>
          <target state="translated">Latin/Hebrew</target>
        </trans-unit>
        <trans-unit id="d494f73e6e88daa7f95e93345a91fc4c8dc4fb69" translate="yes" xml:space="preserve">
          <source>Launch the main autoprewarm worker. This will normally happen automatically, but is useful if automatic prewarm was not configured at server startup time and you wish to start up the worker at a later time.</source>
          <target state="translated">启动主自动预热工作者。这通常会自动发生,但如果在服务器启动时没有配置自动预热,而您又希望在稍后时间启动 Worker,则会很有用。</target>
        </trans-unit>
        <trans-unit id="2c4136854685f9259aab343bbd1cc7a50348e3a5" translate="yes" xml:space="preserve">
          <source>Leaf page fragmentation</source>
          <target state="translated">叶子页面碎片化</target>
        </trans-unit>
        <trans-unit id="5f877225069b04b69ebc49ed1c8ffc9db5e722b5" translate="yes" xml:space="preserve">
          <source>Leaf tuples of an SP-GiST tree contain values of the same data type as the indexed column. Leaf tuples at the root level will always contain the original indexed data value, but leaf tuples at lower levels might contain only a compressed representation, such as a suffix. In that case the operator class support functions must be able to reconstruct the original value using information accumulated from the inner tuples that are passed through to reach the leaf level.</source>
          <target state="translated">SP-GIST 树的叶元组包含与索引列相同数据类型的值。根级的叶元组将始终包含原始的索引数据值,但较低级的叶元组可能只包含压缩的表示,如后缀。在这种情况下,操作类支持函数必须能够使用从传递到叶级的内部元组中积累的信息来重建原始值。</target>
        </trans-unit>
        <trans-unit id="5daa8198764e4eb159c9ea5a3939ed7ca08e926f" translate="yes" xml:space="preserve">
          <source>Least common multiple (the smallest strictly positive number that is an integral multiple of both inputs); returns &lt;code&gt;0&lt;/code&gt; if either input is zero; available for &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;bigint&lt;/code&gt;, and &lt;code&gt;numeric&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9299c2aba089dc4590aa8606b111db26dae4554a" translate="yes" xml:space="preserve">
          <source>Left-hand input data type of associated operator</source>
          <target state="translated">相关运算符的左手输入数据类型</target>
        </trans-unit>
        <trans-unit id="ed906ae901de1e3195028f0570c5ad60b2810880" translate="yes" xml:space="preserve">
          <source>Left-hand input data type of operator</source>
          <target state="translated">左手输入数据类型的运算器</target>
        </trans-unit>
        <trans-unit id="3bade34ecbc5d996b2f301ebd4ba689e81c7c9ea" translate="yes" xml:space="preserve">
          <source>Length</source>
          <target state="translated">Length</target>
        </trans-unit>
        <trans-unit id="d8b851cee953f8d81c31ec69468e0ec20c2888c1" translate="yes" xml:space="preserve">
          <source>Length of aggregation interval (in seconds). May be used only with &lt;code&gt;-l&lt;/code&gt; option. With this option, the log contains per-interval summary data, as described below.</source>
          <target state="translated">聚合时间间隔的长度（以秒为单位）。只能与 &lt;code&gt;-l&lt;/code&gt; 选项一起使用。使用此选项，日志包含每个时间间隔的摘要数据，如下所述。</target>
        </trans-unit>
        <trans-unit id="af6b0587a83fcd51886d616d3a32f3398d01980f" translate="yes" xml:space="preserve">
          <source>Length of binary string</source>
          <target state="translated">二进制字符串的长度</target>
        </trans-unit>
        <trans-unit id="ccfe4a6f325c29c147887556a7714e5ddcdfe308" translate="yes" xml:space="preserve">
          <source>Length of each signature (index entry) in bits. It is rounded up to the nearest multiple of &lt;code&gt;16&lt;/code&gt;. The default is &lt;code&gt;80&lt;/code&gt; bits and the maximum is &lt;code&gt;4096&lt;/code&gt;.</source>
          <target state="translated">每个签名（索引条目）的长度（以位为单位）。四舍五入到最接近的 &lt;code&gt;16&lt;/code&gt; 的倍数。默认值为 &lt;code&gt;80&lt;/code&gt; 位，最大为 &lt;code&gt;4096&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12d4a8b76c20bac65c1a5a078f5f7a8e333266b4" translate="yes" xml:space="preserve">
          <source>Length or circumference</source>
          <target state="translated">长度或周长</target>
        </trans-unit>
        <trans-unit id="9d6ed670f3c04a36b7689b66ca5b25c4d52af652" translate="yes" xml:space="preserve">
          <source>Less likely to cause problems is the minimum size for shared memory segments (&lt;code&gt;SHMMIN&lt;/code&gt;), which should be at most approximately 32 bytes for PostgreSQL (it is usually just 1). The maximum number of segments system-wide (&lt;code&gt;SHMMNI&lt;/code&gt;) or per-process (&lt;code&gt;SHMSEG&lt;/code&gt;) are unlikely to cause a problem unless your system has them set to zero.</source>
          <target state="translated">引起问题的可能性较小的是共享内存段的最小大小（ &lt;code&gt;SHMMIN&lt;/code&gt; ），对于PostgreSQL ，最大大小应该大约为32字节（通常仅为1）。除非系统将其设置为零，否则系统范围（ &lt;code&gt;SHMMNI&lt;/code&gt; ）或每个进程（ &lt;code&gt;SHMSEG&lt;/code&gt; ）的最大段数不太可能引起问题。</target>
        </trans-unit>
        <trans-unit id="1d3d412a0852cc56c28ad0c2a1153229aa365b43" translate="yes" xml:space="preserve">
          <source>Less than</source>
          <target state="translated">低于</target>
        </trans-unit>
        <trans-unit id="33331a5bba7154831ad991e3d73f2368d8a52f4d" translate="yes" xml:space="preserve">
          <source>Less than or equal to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e88e84c79a2349d1ad4055f51a25c693dabaf88a" translate="yes" xml:space="preserve">
          <source>Less-than comparison</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f01a7dce204970734b2b2a327ee36987199e47f" translate="yes" xml:space="preserve">
          <source>Less-than operator</source>
          <target state="translated">小于运算符</target>
        </trans-unit>
        <trans-unit id="9f4307f8c5a910003114771823ca3aa6f1218371" translate="yes" xml:space="preserve">
          <source>Less-than-or-equal-to comparison</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4576a6bc031e504cf481eb0d13f776e9d54832eb" translate="yes" xml:space="preserve">
          <source>Less-than-or-equal-to operator</source>
          <target state="translated">小于或等于运算符</target>
        </trans-unit>
        <trans-unit id="0ab7950f1f29b3334f76dd244ef5a7ba783b1b7f" translate="yes" xml:space="preserve">
          <source>Let's also assume you have a table storing orders of those products. We want to ensure that the orders table only contains orders of products that actually exist. So we define a foreign key constraint in the orders table that references the products table:</source>
          <target state="translated">我们还假设你有一个表存储这些产品的订单。我们要确保订单表只包含实际存在的产品的订单。所以我们在订单表中定义一个引用产品表的外键约束。</target>
        </trans-unit>
        <trans-unit id="4bb0a1a761abe6883839cec3e71ca469d8a65b69" translate="yes" xml:space="preserve">
          <source>Let's assume you have filled the table with data and want to take a look at it:</source>
          <target state="translated">假设你已经用数据填满了表,并想看一看。</target>
        </trans-unit>
        <trans-unit id="6bb447a9045c7cc0d5a93bdb00100d8f10c020e2" translate="yes" xml:space="preserve">
          <source>Let's consider a real-life astronomical example. We'll expand query &lt;code&gt;supernovae&lt;/code&gt; using table-driven rewriting rules:</source>
          <target state="translated">让我们考虑一个真实的天文学例子。我们将使用表驱动的重写规则来扩展查询 &lt;code&gt;supernovae&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3450ae90635f5fd80bf01d11b0586d3e5b336518" translate="yes" xml:space="preserve">
          <source>Let's create two tables: A table &lt;code&gt;cities&lt;/code&gt; and a table &lt;code&gt;capitals&lt;/code&gt;. Naturally, capitals are also cities, so you want some way to show the capitals implicitly when you list all cities. If you're really clever you might invent some scheme like this:</source>
          <target state="translated">让我们创建两个表：一个表 &lt;code&gt;cities&lt;/code&gt; 和一个表 &lt;code&gt;capitals&lt;/code&gt; 。自然地，首都也是城市，因此当您列出所有城市时，您需要某种方式隐式显示首都。如果您真的很聪明，可以发明这样的方案：</target>
        </trans-unit>
        <trans-unit id="002106d5520b7ff0cea15ef411a279196063cbfa" translate="yes" xml:space="preserve">
          <source>Let's look at that command in detail. First is the key word &lt;code&gt;UPDATE&lt;/code&gt; followed by the table name. As usual, the table name can be schema-qualified, otherwise it is looked up in the path. Next is the key word &lt;code&gt;SET&lt;/code&gt; followed by the column name, an equal sign, and the new column value. The new column value can be any scalar expression, not just a constant. For example, if you want to raise the price of all products by 10% you could use:</source>
          <target state="translated">让我们详细查看该命令。首先是关键字 &lt;code&gt;UPDATE&lt;/code&gt; ,然后是表名。通常，表名可以是模式限定的，否则将在路径中查找表名。接下来是关键字 &lt;code&gt;SET&lt;/code&gt; ,后跟列名称，等号和新列值。新的列值可以是任何标量表达式，而不仅仅是常数。例如，如果要将所有产品的价格提高10％，可以使用：</target>
        </trans-unit>
        <trans-unit id="66b99b3611a0c2fdc7f95a1799fb3492cd67f4e6" translate="yes" xml:space="preserve">
          <source>Let's look at the query from &lt;a href=&quot;multivariate-statistics-examples#FUNCTIONAL-DEPENDENCIES&quot;&gt;Section 70.2.1&lt;/a&gt; again, but this time with a MCV list created on the same set of columns (be sure to drop the functional dependencies, to make sure the planner uses the newly created statistics).</source>
          <target state="translated">让我们再次看一下&lt;a href=&quot;multivariate-statistics-examples#FUNCTIONAL-DEPENDENCIES&quot;&gt;第70.2.1节&lt;/a&gt;中的查询，但是这次是在同一列列上创建的MCV列表（请确保删除功能依赖项，以确保计划者使用新创建的统计信息）。</target>
        </trans-unit>
        <trans-unit id="1612ac24f2069dd66f65838fc7336fa0b28c41cb" translate="yes" xml:space="preserve">
          <source>Let's move on to an example with a range condition in its &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="translated">让我们继续来看一个在其 &lt;code&gt;WHERE&lt;/code&gt; 子句中具有范围条件的示例：</target>
        </trans-unit>
        <trans-unit id="e33f516fc6df811ac7dea3c6a71c77e25ecd5519" translate="yes" xml:space="preserve">
          <source>Let's start with a very simple query:</source>
          <target state="translated">让我们从一个非常简单的查询开始。</target>
        </trans-unit>
        <trans-unit id="944a02000a7cd912b7786576975c692505293e37" translate="yes" xml:space="preserve">
          <source>Let's start with an example: suppose we are trying to build a data model for cities. Each state has many cities, but only one capital. We want to be able to quickly retrieve the capital city for any particular state. This can be done by creating two tables, one for state capitals and one for cities that are not capitals. However, what happens when we want to ask for data about a city, regardless of whether it is a capital or not? The inheritance feature can help to resolve this problem. We define the &lt;code&gt;capitals&lt;/code&gt; table so that it inherits from &lt;code&gt;cities&lt;/code&gt;:</source>
          <target state="translated">让我们从一个示例开始：假设我们正在尝试为城市构建数据模型。每个州都有许多城市，但只有一个首都。我们希望能够快速检索任何特定州的首都。这可以通过创建两个表来完成，一个表用于州首府，一个表用于非首府城市。但是，当我们要查询有关城市的数据时，无论它是否是首都，会发生什么？继承功能可以帮助解决此问题。我们定义 &lt;code&gt;capitals&lt;/code&gt; 表格，使其继承自 &lt;code&gt;cities&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8936905c2cce98cf23701c4834f7f639d90f7b6d" translate="yes" xml:space="preserve">
          <source>Let's try joining two tables, using the columns we have been discussing:</source>
          <target state="translated">让我们尝试使用我们一直在讨论的列来连接两个表。</target>
        </trans-unit>
        <trans-unit id="fc56b91f6d327225a18362ab13575f562f30c691" translate="yes" xml:space="preserve">
          <source>Lexemes that have positions can further be labeled with a &lt;em&gt;weight&lt;/em&gt;, which can be &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, or &lt;code&gt;D&lt;/code&gt;. &lt;code&gt;D&lt;/code&gt; is the default and hence is not shown on output:</source>
          <target state="translated">具有位置的词位可以进一步用标记的&lt;em&gt;重量&lt;/em&gt;，可以是 &lt;code&gt;A&lt;/code&gt; ， &lt;code&gt;B&lt;/code&gt; ， &lt;code&gt;C&lt;/code&gt; ，或 &lt;code&gt;D&lt;/code&gt; 。 &lt;code&gt;D&lt;/code&gt; 是默认值，因此不会显示在输出中：</target>
        </trans-unit>
        <trans-unit id="4de4e82a8494674ff2932d2f3ecffa7e7aa91c37" translate="yes" xml:space="preserve">
          <source>Lexical Structure</source>
          <target state="translated">词汇结构</target>
        </trans-unit>
        <trans-unit id="98b17490298c1db6b1bff4b00e76136ec7bbbbbf" translate="yes" xml:space="preserve">
          <source>Lexical Structure: Comments</source>
          <target state="translated">词汇结构。评论</target>
        </trans-unit>
        <trans-unit id="fba7d54766b9a41f8c00c3be52c20790571085f9" translate="yes" xml:space="preserve">
          <source>Lexical Structure: Constants</source>
          <target state="translated">词汇结构。常量</target>
        </trans-unit>
        <trans-unit id="0eb1a63288ed8a4eea2395df1dd364cf859d54a6" translate="yes" xml:space="preserve">
          <source>Lexical Structure: Identifiers and Key Words</source>
          <target state="translated">词汇结构。识别符和关键词</target>
        </trans-unit>
        <trans-unit id="195802f293c2f60e26c9b9d1cca1271d02591bfe" translate="yes" xml:space="preserve">
          <source>Lexical Structure: Operator Precedence</source>
          <target state="translated">词汇结构。操作者优先</target>
        </trans-unit>
        <trans-unit id="f3025dccc066fa7289f006eb8ae5b580e53548c6" translate="yes" xml:space="preserve">
          <source>Lexical Structure: Operators</source>
          <target state="translated">词汇结构。操作符</target>
        </trans-unit>
        <trans-unit id="820a42a37bd5d5e7546df4a06a9fad64993321ea" translate="yes" xml:space="preserve">
          <source>Lexical Structure: Special Characters</source>
          <target state="translated">词汇结构。特殊字符</target>
        </trans-unit>
        <trans-unit id="aa1c47b9be01b70fcc0a9ce52958782af56ce40a" translate="yes" xml:space="preserve">
          <source>Library API</source>
          <target state="translated">图书馆API</target>
        </trans-unit>
        <trans-unit id="bc61796bcb48c2cc0906e22b19a382e56ac7241c" translate="yes" xml:space="preserve">
          <source>Licensed under the PostgreSQL License.</source>
          <target state="translated">根据PostgreSQL授权许可。</target>
        </trans-unit>
        <trans-unit id="70e96422ed9935802e683689abf5ed30f10484c2" translate="yes" xml:space="preserve">
          <source>Lightweight Directory Access Protocol</source>
          <target state="translated">轻量级目录访问协议</target>
        </trans-unit>
        <trans-unit id="706c7257274a3b242ba385122feaad6c90232d40" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;%/&lt;/code&gt;, but the output is &lt;code&gt;~&lt;/code&gt; (tilde) if the database is your default database.</source>
          <target state="translated">与 &lt;code&gt;%/&lt;/code&gt; 相似，但是如果数据库是您的默认数据库，则输出为 &lt;code&gt;~&lt;/code&gt; （波浪号）。</target>
        </trans-unit>
        <trans-unit id="01c5b4c11e3825cd811354418a5a2a2256d5f14a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;--locale&lt;/code&gt;, but only sets the locale in the specified category.</source>
          <target state="translated">与 &lt;code&gt;--locale&lt;/code&gt; 类似，但仅将语言环境设置为指定的类别。</target>
        </trans-unit>
        <trans-unit id="592d71b5f1a2fc02390509f112e2932ece3b2ce3" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;.**&lt;/code&gt;, but selects only the specified levels of the JSON hierarchy. Nesting levels are specified as integers. Level zero corresponds to the current object. To access the lowest nesting level, you can use the &lt;code&gt;last&lt;/code&gt; keyword. This is a PostgreSQL extension of the SQL/JSON standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bcb9cac0fa5cedaf3e22ad3fe9503230b5e0b4b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;LIKE&lt;/code&gt;, the &lt;code&gt;SIMILAR TO&lt;/code&gt; operator succeeds only if its pattern matches the entire string; this is unlike common regular expression behavior where the pattern can match any part of the string. Also like &lt;code&gt;LIKE&lt;/code&gt;, &lt;code&gt;SIMILAR TO&lt;/code&gt; uses &lt;code&gt;_&lt;/code&gt; and &lt;code&gt;%&lt;/code&gt; as wildcard characters denoting any single character and any string, respectively (these are comparable to &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;.*&lt;/code&gt; in POSIX regular expressions).</source>
          <target state="translated">像 &lt;code&gt;LIKE&lt;/code&gt; 一样， &lt;code&gt;SIMILAR TO&lt;/code&gt; 运算符仅在其模式与整个字符串匹配时才成功；这与常见的正则表达式行为不同，在常规行为中，模式可以匹配字符串的任何部分。就像 &lt;code&gt;LIKE&lt;/code&gt; 一样， &lt;code&gt;SIMILAR TO&lt;/code&gt; 使用 &lt;code&gt;_&lt;/code&gt; 和 &lt;code&gt;%&lt;/code&gt; 作为通配符，分别表示任何单个字符和任何字符串（它们与POSIX正则表达式中的 &lt;code&gt;.&lt;/code&gt; 和 &lt;code&gt;.*&lt;/code&gt; 相类似）。</target>
        </trans-unit>
        <trans-unit id="85a2ab4c0cd63cc27de88b6c0b7fbce75e30b6bf" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;aggfinalmodify&lt;/code&gt;, but for the &lt;code&gt;aggmfinalfn&lt;/code&gt;</source>
          <target state="translated">像 &lt;code&gt;aggfinalmodify&lt;/code&gt; 一样，但是对于 &lt;code&gt;aggmfinalfn&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="059422d409e873d3ec537d586c30c482c509b6ce" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;penalty&lt;/code&gt;, the &lt;code&gt;picksplit&lt;/code&gt; function is crucial to good performance of the index. Designing suitable &lt;code&gt;penalty&lt;/code&gt; and &lt;code&gt;picksplit&lt;/code&gt; implementations is where the challenge of implementing well-performing GiST indexes lies.</source>
          <target state="translated">像 &lt;code&gt;penalty&lt;/code&gt; 一样， &lt;code&gt;picksplit&lt;/code&gt; 函数对于索引的良好性能至关重要。设计合适的 &lt;code&gt;penalty&lt;/code&gt; 和 &lt;code&gt;picksplit&lt;/code&gt; 实施是实现性能良好的GiST索引面临的挑战。</target>
        </trans-unit>
        <trans-unit id="2af7b72fbf0a8ccd43a00ff740a0fef8b75c0395" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;pg_statistic&lt;/code&gt;, &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; should not be readable by the public, since the contents might be considered sensitive. (Example: most common combinations of values in columns might be quite interesting.) &lt;a href=&quot;view-pg-stats-ext&quot;&gt;&lt;code&gt;pg_stats_ext&lt;/code&gt;&lt;/a&gt; is a publicly readable view on &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; (after joining with &lt;code&gt;pg_statistic_ext&lt;/code&gt;) that only exposes information about those tables and columns that are readable by the current user.</source>
          <target state="translated">与 &lt;code&gt;pg_statistic&lt;/code&gt; 一样， &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; 不应被公众读取，因为其内容可能被视为敏感内容。（示例：列中值的最常见组合可能会很有趣。）&lt;a href=&quot;view-pg-stats-ext&quot;&gt; &lt;code&gt;pg_stats_ext&lt;/code&gt; &lt;/a&gt;是 &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; 上的公共可读视图（与 &lt;code&gt;pg_statistic_ext&lt;/code&gt; 结合后），它仅公开有关当前用户可读的表和列的信息。</target>
        </trans-unit>
        <trans-unit id="1e283f20748a53829b82b5760d76e1b1a5f034e9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;plainto_tsquery&lt;/code&gt;, the &lt;code&gt;phraseto_tsquery&lt;/code&gt; function will not recognize &lt;code&gt;tsquery&lt;/code&gt; operators, weight labels, or prefix-match labels in its input:</source>
          <target state="translated">与 &lt;code&gt;plainto_tsquery&lt;/code&gt; 一样， &lt;code&gt;phraseto_tsquery&lt;/code&gt; 函数将无法在其输入中识别 &lt;code&gt;tsquery&lt;/code&gt; 运算符，权重标签或前缀匹配标签：</target>
        </trans-unit>
        <trans-unit id="176fba135c7656c6b09a34f8083ee1cb69b4df0d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;xpath_nodeset(document, query, toptag, itemtag)&lt;/code&gt; but result omits &lt;code&gt;toptag&lt;/code&gt;.</source>
          <target state="translated">像 &lt;code&gt;xpath_nodeset(document, query, toptag, itemtag)&lt;/code&gt; 但是结果省略了 &lt;code&gt;toptag&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="01344dcf6fdc7567e1ebfddcdc592af8624be340" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;xpath_nodeset(document, query, toptag, itemtag)&lt;/code&gt; but result omits &lt;em&gt;&lt;code&gt;toptag&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a092e16f9fe5baae3ebd61fa16eca90ce0ed31e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;xpath_nodeset(document, query, toptag, itemtag)&lt;/code&gt; but result omits both tags.</source>
          <target state="translated">像 &lt;code&gt;xpath_nodeset(document, query, toptag, itemtag)&lt;/code&gt; 但结果省略了这两个标签。</target>
        </trans-unit>
        <trans-unit id="79231c4789ce70fc6a3cc412988cea4a45cfbcbb" translate="yes" xml:space="preserve">
          <source>Like GiST and SP-GiST, GIN can support many different user-defined indexing strategies, and the particular operators with which a GIN index can be used vary depending on the indexing strategy. As an example, the standard distribution of PostgreSQL includes a GIN operator class for arrays, which supports indexed queries using these operators:</source>
          <target state="translated">与GiST和SP-GiST一样,GIN可以支持许多不同的用户定义的索引策略,GIN索引所使用的特定运算符也因索引策略的不同而不同。举个例子,PostgreSQL的标准发行版中包含了一个针对数组的GIN运算符类,它支持使用这些运算符进行索引查询。</target>
        </trans-unit>
        <trans-unit id="cd7904080c36090327450bf7ffd681d3be365b14" translate="yes" xml:space="preserve">
          <source>Like GiST, SP-GiST is meant to allow the development of custom data types with the appropriate access methods, by an expert in the domain of the data type, rather than a database expert.</source>
          <target state="translated">与GiST一样,SP-GiST的目的是允许数据类型领域的专家而不是数据库专家开发具有适当访问方法的自定义数据类型。</target>
        </trans-unit>
        <trans-unit id="48b6f9b32591a18a649f1f0d5dc992087748dd36" translate="yes" xml:space="preserve">
          <source>Like GiST, SP-GiST supports &amp;ldquo;nearest-neighbor&amp;rdquo; searches. For SP-GiST operator classes that support distance ordering, the corresponding operator is specified in the &amp;ldquo;Ordering Operators&amp;rdquo; column in &lt;a href=&quot;spgist-builtin-opclasses#SPGIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 65.1&lt;/a&gt;.</source>
          <target state="translated">与GiST一样，SP-GiST支持&amp;ldquo;最近邻居&amp;rdquo;搜索。对于支持距离排序的SP-GiST运算符类，在&lt;a href=&quot;spgist-builtin-opclasses#SPGIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;表65.1&lt;/a&gt;的&amp;ldquo;排序运算符&amp;rdquo;列中指定了相应的运算符。</target>
        </trans-unit>
        <trans-unit id="60e4d14adfb5f143c50beb7e0713788626061776" translate="yes" xml:space="preserve">
          <source>Like a &lt;code&gt;CASE&lt;/code&gt; expression, &lt;code&gt;COALESCE&lt;/code&gt; only evaluates the arguments that are needed to determine the result; that is, arguments to the right of the first non-null argument are not evaluated. This SQL-standard function provides capabilities similar to &lt;code&gt;NVL&lt;/code&gt; and &lt;code&gt;IFNULL&lt;/code&gt;, which are used in some other database systems.</source>
          <target state="translated">像 &lt;code&gt;CASE&lt;/code&gt; 表达式一样， &lt;code&gt;COALESCE&lt;/code&gt; 仅评估确定结果所需的参数。也就是说，不评估第一个非空参数右边的参数。此SQL标准函数提供的功能类似于 &lt;code&gt;NVL&lt;/code&gt; 和 &lt;code&gt;IFNULL&lt;/code&gt; ，它们在某些其他数据库系统中使用。</target>
        </trans-unit>
        <trans-unit id="1b49279f338ded2bdf03d1fe2fa28270882b8852" translate="yes" xml:space="preserve">
          <source>Like all locks in PostgreSQL, a complete list of advisory locks currently held by any session can be found in the &lt;a href=&quot;view-pg-locks&quot;&gt;&lt;code&gt;pg_locks&lt;/code&gt;&lt;/a&gt; system view.</source>
          <target state="translated">像PostgreSQL中的所有锁一样，可以在&lt;a href=&quot;view-pg-locks&quot;&gt; &lt;code&gt;pg_locks&lt;/code&gt; &lt;/a&gt;系统视图中找到任何会话当前持有的咨询锁的完整列表。</target>
        </trans-unit>
        <trans-unit id="41cf9a59f49a59843cd96e23e78a1ccf6b90562d" translate="yes" xml:space="preserve">
          <source>Like all statement-logging options, this option can add significant overhead.</source>
          <target state="translated">与所有报表记录选项一样,这个选项也会增加大量的开销。</target>
        </trans-unit>
        <trans-unit id="59c02f2aa97036dbf7f53371e80651c744767251" translate="yes" xml:space="preserve">
          <source>Like any other PostgreSQL client application, pg_dump will by default connect with the database user name that is equal to the current operating system user name. To override this, either specify the &lt;code&gt;-U&lt;/code&gt; option or set the environment variable &lt;code&gt;PGUSER&lt;/code&gt;. Remember that pg_dump connections are subject to the normal client authentication mechanisms (which are described in &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;).</source>
          <target state="translated">与其他任何PostgreSQL客户端应用程序一样，pg_dump默认情况下将使用与当前操作系统用户名相同的数据库用户名进行连接。要覆盖它，请指定 &lt;code&gt;-U&lt;/code&gt; 选项或设置环境变量 &lt;code&gt;PGUSER&lt;/code&gt; 。请记住，pg_dump连接必须遵循常规的客户端身份验证机制（在&lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;第20章&lt;/a&gt;中进行了介绍）。</target>
        </trans-unit>
        <trans-unit id="ab5911dcefb73651b71811a18cd1ea69e7e94d92" translate="yes" xml:space="preserve">
          <source>Like any other PostgreSQL client application, pg_dump will by default connect with the database user name that is equal to the current operating system user name. To override this, either specify the &lt;code&gt;-U&lt;/code&gt; option or set the environment variable &lt;code&gt;PGUSER&lt;/code&gt;. Remember that pg_dump connections are subject to the normal client authentication mechanisms (which are described in &lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9db72f7082c44e13743d7b5d39d781324396c03" translate="yes" xml:space="preserve">
          <source>Like most other relational database products, PostgreSQL supports &lt;em&gt;aggregate functions&lt;/em&gt;. An aggregate function computes a single result from multiple input rows. For example, there are aggregates to compute the &lt;code&gt;count&lt;/code&gt;, &lt;code&gt;sum&lt;/code&gt;, &lt;code&gt;avg&lt;/code&gt; (average), &lt;code&gt;max&lt;/code&gt; (maximum) and &lt;code&gt;min&lt;/code&gt; (minimum) over a set of rows.</source>
          <target state="translated">像大多数其他关系数据库产品一样，PostgreSQL支持&lt;em&gt;聚合函数&lt;/em&gt;。聚合函数从多个输入行计算单个结果。例如，存在用于计算一组行的 &lt;code&gt;count&lt;/code&gt; ， &lt;code&gt;sum&lt;/code&gt; ， &lt;code&gt;avg&lt;/code&gt; （平均值）， &lt;code&gt;max&lt;/code&gt; （最大）和 &lt;code&gt;min&lt;/code&gt; （最小）的聚合。</target>
        </trans-unit>
        <trans-unit id="e7b37131745c0548a8d7bb256942b653bac4d0f2" translate="yes" xml:space="preserve">
          <source>Like the built-in &lt;code&gt;SYSTEM&lt;/code&gt; sampling method, &lt;code&gt;SYSTEM_ROWS&lt;/code&gt; performs block-level sampling, so that the sample is not completely random but may be subject to clustering effects, especially if only a small number of rows are requested.</source>
          <target state="translated">像内置的 &lt;code&gt;SYSTEM&lt;/code&gt; 采样方法一样， &lt;code&gt;SYSTEM_ROWS&lt;/code&gt; 执行块级采样，因此采样不是完全随机的，但是可能会受到聚类的影响，尤其是在仅要求少量行的情况下。</target>
        </trans-unit>
        <trans-unit id="2764b8aec49f0a51f07f507803e713795f179f24" translate="yes" xml:space="preserve">
          <source>Like the built-in &lt;code&gt;SYSTEM&lt;/code&gt; sampling method, &lt;code&gt;SYSTEM_TIME&lt;/code&gt; performs block-level sampling, so that the sample is not completely random but may be subject to clustering effects, especially if only a small number of rows are selected.</source>
          <target state="translated">像内置的 &lt;code&gt;SYSTEM&lt;/code&gt; 采样方法一样， &lt;code&gt;SYSTEM_TIME&lt;/code&gt; 执行块级采样，因此该采样不是完全随机的，但是可能会受到聚类的影响，尤其是在仅选择少量行的情况下。</target>
        </trans-unit>
        <trans-unit id="b3332deec758b17e6fd52517b579fa1eda61782d" translate="yes" xml:space="preserve">
          <source>Likewise, any sequence state changes made by &lt;code&gt;setval&lt;/code&gt; are not undone if the transaction rolls back.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e207e275fe1f2f0794d071fcc2006657d41ca30" translate="yes" xml:space="preserve">
          <source>Likewise, if the output column is an array type and the JSON value is a JSON array, the elements of the JSON array are converted to elements of the output array by recursive application of these rules.</source>
          <target state="translated">同样,如果输出列是一个数组类型,JSON值是一个JSON数组,那么JSON数组的元素通过递归应用这些规则转换为输出数组的元素。</target>
        </trans-unit>
        <trans-unit id="c63c5f8682585854b3af24acfaa10cdf34814785" translate="yes" xml:space="preserve">
          <source>Likewise, it is the operator class's responsibility that inner tuples do not grow too large to fit on an index page; this limits the number of child nodes that can be used in one inner tuple, as well as the maximum size of a prefix value.</source>
          <target state="translated">同样,操作者类的责任是使内部元组不至于长得太大而无法容纳在索引页上;这限制了一个内部元组中可以使用的子节点的数量,以及前缀值的最大尺寸。</target>
        </trans-unit>
        <trans-unit id="55246b1bbd1c53d922bbe5662b502ad39d3e6a6a" translate="yes" xml:space="preserve">
          <source>Likewise, the current session's temporary-table schema, &lt;code&gt;pg_temp_nnn&lt;/code&gt;, is always searched if it exists. It can be explicitly listed in the path by using the alias &lt;code&gt;pg_temp&lt;/code&gt;. If it is not listed in the path then it is searched first (even before &lt;code&gt;pg_catalog&lt;/code&gt;). However, the temporary schema is only searched for relation (table, view, sequence, etc) and data type names. It is never searched for function or operator names.</source>
          <target state="translated">同样，当前会话的临时表架构 &lt;code&gt;pg_temp_nnn&lt;/code&gt; 始终会被搜索。可以使用别名 &lt;code&gt;pg_temp&lt;/code&gt; 在路径中明确列出它。如果未在路径中列出它，那么将首先搜索它（甚至在 &lt;code&gt;pg_catalog&lt;/code&gt; 之前）。但是，仅在临时模式中搜索关系（表，视图，序列等）和数据类型名称。永远不会搜索函数或运算符名称。</target>
        </trans-unit>
        <trans-unit id="23e122f77e2123c0711252ea9a852e626bde8b4c" translate="yes" xml:space="preserve">
          <source>Likewise, while an aggregate final function is normally expected not to modify its input values, sometimes it is impractical to avoid modifying the transition-state argument. Such behavior must be declared using the &lt;code&gt;FINALFUNC_MODIFY&lt;/code&gt; parameter. The &lt;code&gt;READ_WRITE&lt;/code&gt; value indicates that the final function modifies the transition state in unspecified ways. This value prevents use of the aggregate as a window function, and it also prevents merging of transition states for aggregate calls that share the same input values and transition functions. The &lt;code&gt;SHAREABLE&lt;/code&gt; value indicates that the transition function cannot be applied after the final function, but multiple final-function calls can be performed on the ending transition state value. This value prevents use of the aggregate as a window function, but it allows merging of transition states. (That is, the optimization of interest here is not applying the same final function repeatedly, but applying different final functions to the same ending transition state value. This is allowed as long as none of the final functions are marked &lt;code&gt;READ_WRITE&lt;/code&gt;.)</source>
          <target state="translated">同样，尽管通常期望汇总的最终函数不修改其输入值，但有时避免修改过渡状态参数是不切实际的。必须使用 &lt;code&gt;FINALFUNC_MODIFY&lt;/code&gt; 参数声明这种行为。该 &lt;code&gt;READ_WRITE&lt;/code&gt; 值表明最终函数修改未定的方式过渡状态。此值防止将聚合用作窗口函数，并且还防止合并共享相同输入值和转换函数的聚合调用的转换状态。可 &lt;code&gt;SHAREABLE&lt;/code&gt; value表示过渡功能不能在最终功能之后应用，但是可以在结束的过渡状态值上执行多个最终功能调用。该值防止将聚合用作窗口函数，但允许合并过渡状态。（也就是说，此处关注的优化不是重复应用相同的最终函数，而是将不同的最终函数应用于相同的结束过渡状态值。只要没有将最终函数标记为 &lt;code&gt;READ_WRITE&lt;/code&gt; ,这是允许的。）</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="b47563cbfdd571c38564d5b781eea43887f5700d" translate="yes" xml:space="preserve">
          <source>Limits and compatibility notes for the &lt;code&gt;xml&lt;/code&gt; data type can be found in &lt;a href=&quot;xml-limits-conformance&quot;&gt;Section D.3&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;xml&lt;/code&gt; 数据类型的限制和兼容性说明可在&lt;a href=&quot;xml-limits-conformance&quot;&gt;第D.3节中&lt;/a&gt;找到。</target>
        </trans-unit>
        <trans-unit id="96d43f75faf24d1ca67c70ecd2f285a22f1af174" translate="yes" xml:space="preserve">
          <source>Line number of this rule in &lt;code&gt;pg_hba.conf&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pg_hba.conf&lt;/code&gt; 中此规则的行号</target>
        </trans-unit>
        <trans-unit id="958c1e90be0b1ef7a3ea1a3a2ab4b6c7d005a8b7" translate="yes" xml:space="preserve">
          <source>Line number within the configuration file the current value was set at (null for values set from sources other than configuration files, or when examined by a user who is neither a superuser or a member of &lt;code&gt;pg_read_all_settings&lt;/code&gt;).</source>
          <target state="translated">当前值在配置文件中的行号设置为（对于从非配置文件的源设置的值，或者由既不是超级用户也不是 &lt;code&gt;pg_read_all_settings&lt;/code&gt; 成员的用户检查的值，则为null）。</target>
        </trans-unit>
        <trans-unit id="5b8f36e71eca1491bb5a406fd952255ee2d3703e" translate="yes" xml:space="preserve">
          <source>Line number within the configuration file where the entry appears</source>
          <target state="translated">配置文件中出现该条目的行号。</target>
        </trans-unit>
        <trans-unit id="883c97e9c14ffbedf2267734a54bef543950a75e" translate="yes" xml:space="preserve">
          <source>Line segments are output using the first syntax.</source>
          <target state="translated">使用第一种语法输出行段。</target>
        </trans-unit>
        <trans-unit id="752729c6452eefd378564f7929186a93baad040b" translate="yes" xml:space="preserve">
          <source>Line segments are represented by pairs of points that are the endpoints of the segment. Values of type &lt;code&gt;lseg&lt;/code&gt; are specified using any of the following syntaxes:</source>
          <target state="translated">线段由成对的点对点表示。使用以下任何语法指定类型为 &lt;code&gt;lseg&lt;/code&gt; 的值：</target>
        </trans-unit>
        <trans-unit id="16fbbc248c377444909f3461d6f0754204ffd781" translate="yes" xml:space="preserve">
          <source>Lines are represented by the linear equation &lt;code&gt;A&lt;/code&gt;x + &lt;code&gt;B&lt;/code&gt;y + &lt;code&gt;C&lt;/code&gt; = 0, where &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are not both zero. Values of type &lt;code&gt;line&lt;/code&gt; are input and output in the following form:</source>
          <target state="translated">直线由线性方程 &lt;code&gt;A&lt;/code&gt; x + &lt;code&gt;B&lt;/code&gt; y + &lt;code&gt;C&lt;/code&gt; = 0表示，其中 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 都不都是零。输入 &lt;code&gt;line&lt;/code&gt; 类型的值的格式如下：</target>
        </trans-unit>
        <trans-unit id="c8eb4d4a92219b0c43b53ed882184405007c09a3" translate="yes" xml:space="preserve">
          <source>Lines being skipped are parsed normally to identify queries and backslash commands, but queries are not sent to the server, and backslash commands other than conditionals (&lt;code&gt;\if&lt;/code&gt;, &lt;code&gt;\elif&lt;/code&gt;, &lt;code&gt;\else&lt;/code&gt;, &lt;code&gt;\endif&lt;/code&gt;) are ignored. Conditional commands are checked only for valid nesting. Variable references in skipped lines are not expanded, and backquote expansion is not performed either.</source>
          <target state="translated">通常会分析被跳过的行以标识查询和反斜杠命令，但是查询不会发送到服务器，并且除条件 &lt;code&gt;\elif&lt;/code&gt; （ &lt;code&gt;\if&lt;/code&gt; ，\ elif， &lt;code&gt;\else&lt;/code&gt; ， &lt;code&gt;\endif&lt;/code&gt; ）以外的反斜杠命令都将被忽略。仅检查条件命令的有效嵌套。跳过行中的变量引用不会扩展，也不执行反引号扩展。</target>
        </trans-unit>
        <trans-unit id="292bae73b4b4a6866d3b72fe56f7981ef97aafd8" translate="yes" xml:space="preserve">
          <source>Lines in the file can be commented out, deleted, and reordered. For example:</source>
          <target state="translated">文件中的行可以被注释、删除和重新排序。例如:</target>
        </trans-unit>
        <trans-unit id="5f388e9f9cc02768dd9a283f46d4fc51473f089e" translate="yes" xml:space="preserve">
          <source>Linguistic &amp;mdash; Ispell dictionaries try to reduce input words to a normalized form; stemmer dictionaries remove word endings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a1f33913b1ca17a294498b513bfd39ae8063421" translate="yes" xml:space="preserve">
          <source>Linguistic - Ispell dictionaries try to reduce input words to a normalized form; stemmer dictionaries remove word endings</source>
          <target state="translated">语言学--Ispell词典试图将输入的单词缩减为规范化的形式;stemmer词典则删除了词尾。</target>
        </trans-unit>
        <trans-unit id="83ad8510bbd3f22363d068e1c96f82fd0fcccd31" translate="yes" xml:space="preserve">
          <source>Linux</source>
          <target state="translated">Linux</target>
        </trans-unit>
        <trans-unit id="77cec0c3e9d8d25a57ec1badeff796c61ca86f12" translate="yes" xml:space="preserve">
          <source>List Partitioning</source>
          <target state="translated">列表分区</target>
        </trans-unit>
        <trans-unit id="0f3458dce5820aca7e890c4b2003d0e275648e05" translate="yes" xml:space="preserve">
          <source>List all available databases, then exit. Other non-connection options are ignored. This is similar to the meta-command &lt;code&gt;\list&lt;/code&gt;.</source>
          <target state="translated">列出所有可用的数据库，然后退出。其他非连接选项将被忽略。这类似于meta命令 &lt;code&gt;\list&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4286624f672002892b2ca95ea48f927cd5f85422" translate="yes" xml:space="preserve">
          <source>List information about tables or indexes in a partition tree for a given partitioned table or partitioned index, with one row for each partition. Information provided includes the name of the partition, the name of its immediate parent, a boolean value telling if the partition is a leaf, and an integer telling its level in the hierarchy. The value of level begins at &lt;code&gt;0&lt;/code&gt; for the input table or index in its role as the root of the partition tree, &lt;code&gt;1&lt;/code&gt; for its partitions, &lt;code&gt;2&lt;/code&gt; for their partitions, and so on.</source>
          <target state="translated">列出有关给定分区表或分区索引的分区树中的表或索引的信息，每个分区一行。提供的信息包括分区的名称，其直接父级的名称，指示分区是否为叶的布尔值，以及告诉其层次结构级别的整数。对于作为分区树的根的输入表或索引，级别的值从 &lt;code&gt;0&lt;/code&gt; 开始，对于分区的分区，从 &lt;code&gt;1&lt;/code&gt; 开始，作为分区的索引，从 &lt;code&gt;2&lt;/code&gt; 开始，依此类推。</target>
        </trans-unit>
        <trans-unit id="f561011cb33daf6ca735d20bdacd8bd7a77bc262" translate="yes" xml:space="preserve">
          <source>List of database name(s) to which this rule applies</source>
          <target state="translated">本规则适用的数据库名称清单</target>
        </trans-unit>
        <trans-unit id="c88853b59f7b2d53c0a2755574e42ba43712f76a" translate="yes" xml:space="preserve">
          <source>List of user and group name(s) to which this rule applies</source>
          <target state="translated">本规则适用的用户和组名列表</target>
        </trans-unit>
        <trans-unit id="d7af7e299822395c971e66ef8de74b892601d575" translate="yes" xml:space="preserve">
          <source>List text search configurations (add &lt;code&gt;+&lt;/code&gt; for more detail).</source>
          <target state="translated">列出文本搜索配置（添加 &lt;code&gt;+&lt;/code&gt; 以获得更多详细信息）。</target>
        </trans-unit>
        <trans-unit id="75bf8723aef5bc601305334105eb67bae8708809" translate="yes" xml:space="preserve">
          <source>List text search dictionaries (add &lt;code&gt;+&lt;/code&gt; for more detail).</source>
          <target state="translated">列出文本搜索词典（添加 &lt;code&gt;+&lt;/code&gt; 以获得更多详细信息）。</target>
        </trans-unit>
        <trans-unit id="f21d1140d1b1ac1f6965e01da259ebe5d03603ab" translate="yes" xml:space="preserve">
          <source>List text search parsers (add &lt;code&gt;+&lt;/code&gt; for more detail).</source>
          <target state="translated">列出文本搜索解析器（添加 &lt;code&gt;+&lt;/code&gt; 以获得更多详细信息）。</target>
        </trans-unit>
        <trans-unit id="a1e1b832b491c08ce8f5b18d1ec93b64f07d2462" translate="yes" xml:space="preserve">
          <source>List text search templates (add &lt;code&gt;+&lt;/code&gt; for more detail).</source>
          <target state="translated">列出文本搜索模板（添加 &lt;code&gt;+&lt;/code&gt; 以获取更多详细信息）。</target>
        </trans-unit>
        <trans-unit id="47ced8a7739926f8f4967c561a0debfd00799b0f" translate="yes" xml:space="preserve">
          <source>List the ancestor relations of the given partition, including the partition itself.</source>
          <target state="translated">列出给定分区的祖先关系,包括分区本身。</target>
        </trans-unit>
        <trans-unit id="1202ae63c3dc8af04c25238d78d5139577abc684" translate="yes" xml:space="preserve">
          <source>List the contents of a directory. Restricted to superusers by default, but other users can be granted EXECUTE to run the function.</source>
          <target state="translated">列出一个目录的内容,默认情况下只限于超级用户,但其他用户可以授权EXECUTE运行该函数。默认情况下只限于超级用户,但其他用户可以被授权EXECUTE来运行该函数。</target>
        </trans-unit>
        <trans-unit id="1b401449c4e0d240387a616d5ffbd4a726f02619" translate="yes" xml:space="preserve">
          <source>List the databases in the server and show their names, owners, character set encodings, and access privileges. If &lt;code&gt;pattern&lt;/code&gt; is specified, only databases whose names match the pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, database sizes, default tablespaces, and descriptions are also displayed. (Size information is only available for databases that the current user can connect to.)</source>
          <target state="translated">列出服务器中的数据库，并显示其名称，所有者，字符集编码和访问特权。如果 &lt;code&gt;pattern&lt;/code&gt; 被指定，只有数据库名匹配模式中列出。如果在命令名称后附加 &lt;code&gt;+&lt;/code&gt; ，则还会显示数据库大小，默认表空间和描述。（大小信息仅适用于当前用户可以连接到的数据库。）</target>
        </trans-unit>
        <trans-unit id="0247fd79dd91c3e0b751440d00b889937665ce82" translate="yes" xml:space="preserve">
          <source>List the log files in the &lt;code&gt;log_directory&lt;/code&gt; directory</source>
          <target state="translated">在 &lt;code&gt;log_directory&lt;/code&gt; 目录中列出日志文件</target>
        </trans-unit>
        <trans-unit id="38872979f824f8456260bf7fc7dc4180d1627b73" translate="yes" xml:space="preserve">
          <source>List the name, size, and last modification time of files in the WAL archive status directory. Access is granted to members of the &lt;code&gt;pg_monitor&lt;/code&gt; role and may be granted to other non-superuser roles.</source>
          <target state="translated">在WAL存档状态目录中列出文件的名称，大小和最后修改时间。访问权被授予 &lt;code&gt;pg_monitor&lt;/code&gt; 角色的成员，并且可以被授予其他非超级用户角色。</target>
        </trans-unit>
        <trans-unit id="216f390c14edafdef1abb92a2e408162ca22c8d7" translate="yes" xml:space="preserve">
          <source>List the name, size, and last modification time of files in the WAL directory. Access is granted to members of the &lt;code&gt;pg_monitor&lt;/code&gt; role and may be granted to other non-superuser roles.</source>
          <target state="translated">列出WAL目录中文件的名称，大小和最后修改时间。访问权被授予 &lt;code&gt;pg_monitor&lt;/code&gt; 角色的成员，并且可以被授予其他非超级用户角色。</target>
        </trans-unit>
        <trans-unit id="74056411fa2a679687b641cd39f5e9f62ea8d563" translate="yes" xml:space="preserve">
          <source>List the name, size, and last modification time of files in the log directory. Access is granted to members of the &lt;code&gt;pg_monitor&lt;/code&gt; role and may be granted to other non-superuser roles.</source>
          <target state="translated">在日志目录中列出文件的名称，大小和最后修改时间。访问权被授予 &lt;code&gt;pg_monitor&lt;/code&gt; 角色的成员，并且可以被授予其他非超级用户角色。</target>
        </trans-unit>
        <trans-unit id="26197e7b4127b303329ad5784e3d755d4742f8bd" translate="yes" xml:space="preserve">
          <source>List the name, size, and last modification time of files in the temporary directory for &lt;em&gt;&lt;code&gt;tablespace&lt;/code&gt;&lt;/em&gt;. If &lt;em&gt;&lt;code&gt;tablespace&lt;/code&gt;&lt;/em&gt; is not provided, the &lt;code&gt;pg_default&lt;/code&gt; tablespace is used. Access is granted to members of the &lt;code&gt;pg_monitor&lt;/code&gt; role and may be granted to other non-superuser roles.</source>
          <target state="translated">在&lt;em&gt; &lt;code&gt;tablespace&lt;/code&gt; &lt;/em&gt;的临时目录中列出文件的名称，大小和最后修改时间。如果&lt;em&gt; &lt;code&gt;tablespace&lt;/code&gt; &lt;/em&gt;中没有提供， &lt;code&gt;pg_default&lt;/code&gt; 使用表空间。访问权被授予 &lt;code&gt;pg_monitor&lt;/code&gt; 角色的成员，并且可以被授予其他非超级用户角色。</target>
        </trans-unit>
        <trans-unit id="6c759b89899d2c028e05b2457d4bdd0b88affd68" translate="yes" xml:space="preserve">
          <source>List the table of contents of the archive. The output of this operation can be used as input to the &lt;code&gt;-L&lt;/code&gt; option. Note that if filtering switches such as &lt;code&gt;-n&lt;/code&gt; or &lt;code&gt;-t&lt;/code&gt; are used with &lt;code&gt;-l&lt;/code&gt;, they will restrict the items listed.</source>
          <target state="translated">列出档案目录。此操作的输出可用作 &lt;code&gt;-L&lt;/code&gt; 选项的输入。请注意，如果将 &lt;code&gt;-n&lt;/code&gt; 或 &lt;code&gt;-t&lt;/code&gt; 之类的过滤开关与 &lt;code&gt;-l&lt;/code&gt; 一起使用，它们将限制列出的项目。</target>
        </trans-unit>
        <trans-unit id="c161fe12eda9cadc384d03d0ff29a932c7632490" translate="yes" xml:space="preserve">
          <source>Lists access methods. If &lt;code&gt;pattern&lt;/code&gt; is specified, only access methods whose names match the pattern are shown. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each access method is listed with its associated handler function and description.</source>
          <target state="translated">列出访问方法。如果 &lt;code&gt;pattern&lt;/code&gt; 被指定，只显示了访问方法的名字相匹配的模式。如果在命令名称后附加 &lt;code&gt;+&lt;/code&gt; ，则会列出每个访问方法及其相关的处理函数和描述。</target>
        </trans-unit>
        <trans-unit id="b5da05aa6b417885b162fa263cf878dfa1640338" translate="yes" xml:space="preserve">
          <source>Lists aggregate functions, together with their return type and the data types they operate on. If &lt;code&gt;pattern&lt;/code&gt; is specified, only aggregates whose names match the pattern are shown. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects.</source>
          <target state="translated">列出聚合函数，以及它们的返回类型和操作的数据类型。如果 &lt;code&gt;pattern&lt;/code&gt; 被指定，只显示了聚集名匹配的模式。默认情况下，仅显示用户创建的对象。提供一个模式或 &lt;code&gt;S&lt;/code&gt; 修饰符以包括系统对象。</target>
        </trans-unit>
        <trans-unit id="ba7e4d85e717101a207e6ece8fa5eae17728be95" translate="yes" xml:space="preserve">
          <source>Lists collations. If &lt;code&gt;pattern&lt;/code&gt; is specified, only collations whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each collation is listed with its associated description, if any. Note that only collations usable with the current database's encoding are shown, so the results may vary in different databases of the same installation.</source>
          <target state="translated">列出排序规则。如果 &lt;code&gt;pattern&lt;/code&gt; 被指定，唯一的排序规则，其名称匹配模式的上市。默认情况下，仅显示用户创建的对象。提供一个模式或 &lt;code&gt;S&lt;/code&gt; 修饰符以包括系统对象。如果在命令名称后附加 &lt;code&gt;+&lt;/code&gt; ，则将列出每个排序规则及其关联的描述（如果有）。请注意，仅显示可与当前数据库的编码一起使用的归类，因此在同一安装的不同数据库中，结果可能会有所不同。</target>
        </trans-unit>
        <trans-unit id="6ed6b6d351ec0314d4901220593cc831623e426a" translate="yes" xml:space="preserve">
          <source>Lists conversions between character-set encodings. If &lt;code&gt;pattern&lt;/code&gt; is specified, only conversions whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its associated description.</source>
          <target state="translated">列出字符集编码之间的转换。如果 &lt;code&gt;pattern&lt;/code&gt; 被指定，只有转换的名字匹配模式的上市。默认情况下，仅显示用户创建的对象。提供一个模式或 &lt;code&gt;S&lt;/code&gt; 修饰符以包含系统对象。如果在命令名称后附加 &lt;code&gt;+&lt;/code&gt; ，则会列出每个对象及其相关描述。</target>
        </trans-unit>
        <trans-unit id="b54152fa5b884f8f7bf428a2c5f3834496af64bd" translate="yes" xml:space="preserve">
          <source>Lists data types. If &lt;code&gt;pattern&lt;/code&gt; is specified, only types whose names match the pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each type is listed with its internal name and size, its allowed values if it is an &lt;code&gt;enum&lt;/code&gt; type, and its associated permissions. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects.</source>
          <target state="translated">列出数据类型。如果 &lt;code&gt;pattern&lt;/code&gt; 被指定，只有那些名字匹配模式的上市。如果在命令名称后附加 &lt;code&gt;+&lt;/code&gt; ，则将列出每种类型及其内部名称和大小，如果是 &lt;code&gt;enum&lt;/code&gt; 类型则允许的值及其关联的权限。默认情况下，仅显示用户创建的对象。提供一个模式或 &lt;code&gt;S&lt;/code&gt; 修饰符以包含系统对象。</target>
        </trans-unit>
        <trans-unit id="1ed12c82d91396faa77acdf69ded0ffcf5a493ea" translate="yes" xml:space="preserve">
          <source>Lists database roles. (Since the concepts of &amp;ldquo;users&amp;rdquo; and &amp;ldquo;groups&amp;rdquo; have been unified into &amp;ldquo;roles&amp;rdquo;, this command is now equivalent to &lt;code&gt;\dg&lt;/code&gt;.) By default, only user-created roles are shown; supply the &lt;code&gt;S&lt;/code&gt; modifier to include system roles. If &lt;code&gt;pattern&lt;/code&gt; is specified, only those roles whose names match the pattern are listed. If the form &lt;code&gt;\du+&lt;/code&gt; is used, additional information is shown about each role; currently this adds the comment for each role.</source>
          <target state="translated">列出数据库角色。 （由于将&amp;ldquo;用户&amp;rdquo;和&amp;ldquo;组&amp;rdquo;的概念统一为&amp;ldquo;角色&amp;rdquo;，因此此命令现在等效于 &lt;code&gt;\dg&lt;/code&gt; 。）默认情况下，仅显示用户创建的角色。提供 &lt;code&gt;S&lt;/code&gt; 修饰符以包括系统角色。如果 &lt;code&gt;pattern&lt;/code&gt; 被指定，只有那些角色的名字匹配模式的上市。如果使用 &lt;code&gt;\du+&lt;/code&gt; 形式，则将显示有关每个角色的其他信息；否则，将显示其他信息。目前，这会为每个角色添加评论。</target>
        </trans-unit>
        <trans-unit id="e29d00c4605108f4d7ba7d0a5a262d70885a0257" translate="yes" xml:space="preserve">
          <source>Lists database roles. (Since the concepts of &amp;ldquo;users&amp;rdquo; and &amp;ldquo;groups&amp;rdquo; have been unified into &amp;ldquo;roles&amp;rdquo;, this command is now equivalent to &lt;code&gt;\du&lt;/code&gt;.) By default, only user-created roles are shown; supply the &lt;code&gt;S&lt;/code&gt; modifier to include system roles. If &lt;code&gt;pattern&lt;/code&gt; is specified, only those roles whose names match the pattern are listed. If the form &lt;code&gt;\dg+&lt;/code&gt; is used, additional information is shown about each role; currently this adds the comment for each role.</source>
          <target state="translated">列出数据库角色。（由于将&amp;ldquo;用户&amp;rdquo;和&amp;ldquo;组&amp;rdquo;的概念统一为&amp;ldquo;角色&amp;rdquo;，因此该命令现在等效于 &lt;code&gt;\du&lt;/code&gt; 。）默认情况下，仅显示用户创建的角色；提供 &lt;code&gt;S&lt;/code&gt; 修饰符以包括系统角色。如果 &lt;code&gt;pattern&lt;/code&gt; 被指定，只有那些角色的名字匹配模式的上市。如果使用 &lt;code&gt;\dg+&lt;/code&gt; 形式，则将显示有关每个角色的其他信息；否则，将显示其他信息。目前，这会为每个角色添加评论。</target>
        </trans-unit>
        <trans-unit id="d0e3c51687d883f635b713be9df17a17913ec4be" translate="yes" xml:space="preserve">
          <source>Lists default access privilege settings. An entry is shown for each role (and schema, if applicable) for which the default privilege settings have been changed from the built-in defaults. If &lt;code&gt;pattern&lt;/code&gt; is specified, only entries whose role name or schema name matches the pattern are listed.</source>
          <target state="translated">列出默认的访问权限设置。将为每个角色（和模式，如果适用）显示一个条目，其默认特权设置已从内置默认值更改。如果 &lt;code&gt;pattern&lt;/code&gt; 被指定，只有其项角色名称或架构名称列出的模式相匹配。</target>
        </trans-unit>
        <trans-unit id="ee1fa4ed6c7126c1942282c2d9a97fd2fb17066c" translate="yes" xml:space="preserve">
          <source>Lists defined configuration settings. These settings can be role-specific, database-specific, or both. &lt;code&gt;role-pattern&lt;/code&gt; and &lt;code&gt;database-pattern&lt;/code&gt; are used to select specific roles and databases to list, respectively. If omitted, or if &lt;code&gt;*&lt;/code&gt; is specified, all settings are listed, including those not role-specific or database-specific, respectively.</source>
          <target state="translated">列出定义的配置设置。这些设置可以是角色特定的，数据库特定的或两者。 &lt;code&gt;role-pattern&lt;/code&gt; 和 &lt;code&gt;database-pattern&lt;/code&gt; 分别用于选择要列出的特定角色和数据库。如果省略，或者指定了 &lt;code&gt;*&lt;/code&gt; ，则列出所有设置，包括分别不是针对角色或针对数据库的设置。</target>
        </trans-unit>
        <trans-unit id="417307de73c4769c24d10a4a74f461c675665a71" translate="yes" xml:space="preserve">
          <source>Lists domains. If &lt;code&gt;pattern&lt;/code&gt; is specified, only domains whose names match the pattern are shown. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its associated permissions and description.</source>
          <target state="translated">列出域。如果 &lt;code&gt;pattern&lt;/code&gt; 被指定，只显示了域名匹配的模式。默认情况下，仅显示用户创建的对象。提供一个模式或 &lt;code&gt;S&lt;/code&gt; 修饰符以包括系统对象。如果在命令名称后附加 &lt;code&gt;+&lt;/code&gt; ，则会列出每个对象及其关联的权限和描述。</target>
        </trans-unit>
        <trans-unit id="f274b8d8f8b448f365efc740c76106814f6e8672" translate="yes" xml:space="preserve">
          <source>Lists event triggers. If &lt;code&gt;pattern&lt;/code&gt; is specified, only those event triggers whose names match the pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its associated description.</source>
          <target state="translated">列出事件触发器。如果 &lt;code&gt;pattern&lt;/code&gt; 被指定，只有那些事件触发器的名字匹配模式的上市。如果在命令名称后附加 &lt;code&gt;+&lt;/code&gt; ，则会列出每个对象及其相关描述。</target>
        </trans-unit>
        <trans-unit id="e79aeba25c72ede19da97f86bce69c0ff45f55b7" translate="yes" xml:space="preserve">
          <source>Lists foreign servers (mnemonic: &amp;ldquo;external servers&amp;rdquo;). If &lt;code&gt;pattern&lt;/code&gt; is specified, only those servers whose name matches the pattern are listed. If the form &lt;code&gt;\des+&lt;/code&gt; is used, a full description of each server is shown, including the server's access privileges, type, version, options, and description.</source>
          <target state="translated">列出外部服务器（助记符：&amp;ldquo;外部服务器&amp;rdquo;）。如果 &lt;code&gt;pattern&lt;/code&gt; 被指定，只有那些服务器的名字相匹配的模式中列出。如果使用 &lt;code&gt;\des+&lt;/code&gt; 形式，则会显示每个服务器的完整描述，包括服务器的访问权限，类型，版本，选项和描述。</target>
        </trans-unit>
        <trans-unit id="78b8f146a38943cc21434e0badfc06780b279a22" translate="yes" xml:space="preserve">
          <source>Lists foreign tables (mnemonic: &amp;ldquo;external tables&amp;rdquo;). If &lt;code&gt;pattern&lt;/code&gt; is specified, only entries whose table name or schema name matches the pattern are listed. If the form &lt;code&gt;\det+&lt;/code&gt; is used, generic options and the foreign table description are also displayed.</source>
          <target state="translated">列出外部表（助记符：&amp;ldquo;外部表&amp;rdquo;）。如果 &lt;code&gt;pattern&lt;/code&gt; 被指定，只有条目，其表名或模式名中列出的模式相匹配。如果使用 &lt;code&gt;\det+&lt;/code&gt; 形式，则还将显示通用选项和外部表描述。</target>
        </trans-unit>
        <trans-unit id="841607b805a28257bffdea756495ef2cb699e228" translate="yes" xml:space="preserve">
          <source>Lists foreign-data wrappers (mnemonic: &amp;ldquo;external wrappers&amp;rdquo;). If &lt;code&gt;pattern&lt;/code&gt; is specified, only those foreign-data wrappers whose name matches the pattern are listed. If the form &lt;code&gt;\dew+&lt;/code&gt; is used, the access privileges, options, and description of the foreign-data wrapper are also shown.</source>
          <target state="translated">列出外部数据包装器（助记符：&amp;ldquo;外部包装器&amp;rdquo;）。如果 &lt;code&gt;pattern&lt;/code&gt; 被指定，只有那些外国的数据封装的名字相匹配的模式中列出。如果使用 &lt;code&gt;\dew+&lt;/code&gt; 格式，还将显示外部数据包装程序的访问权限，选项和描述。</target>
        </trans-unit>
        <trans-unit id="c91d07a0e33c78c3a0a76bd7d8280b785bbd7664" translate="yes" xml:space="preserve">
          <source>Lists functions, together with their result data types, argument data types, and function types, which are classified as &amp;ldquo;agg&amp;rdquo; (aggregate), &amp;ldquo;normal&amp;rdquo;, &amp;ldquo;procedure&amp;rdquo;, &amp;ldquo;trigger&amp;rdquo;, or &amp;ldquo;window&amp;rdquo;. To display only functions of specific type(s), add the corresponding letters &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;p&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt;, or &lt;code&gt;w&lt;/code&gt; to the command. If &lt;code&gt;pattern&lt;/code&gt; is specified, only functions whose names match the pattern are shown. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If the form &lt;code&gt;\df+&lt;/code&gt; is used, additional information about each function is shown, including volatility, parallel safety, owner, security classification, access privileges, language, source code and description.</source>
          <target state="translated">列出函数以及它们的结果数据类型，参数数据类型和函数类型，这些函数分为&amp;ldquo;聚集&amp;rdquo;，&amp;ldquo;正常&amp;rdquo;，&amp;ldquo;过程&amp;rdquo;，&amp;ldquo;触发&amp;rdquo;或&amp;ldquo;窗口&amp;rdquo;。要仅显示特定类型的功能，请在命令中添加相应的字母 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;n&lt;/code&gt; ， &lt;code&gt;p&lt;/code&gt; ， &lt;code&gt;t&lt;/code&gt; 或 &lt;code&gt;w&lt;/code&gt; 。如果 &lt;code&gt;pattern&lt;/code&gt; 被指定，只显示了功能名称匹配的模式。默认情况下，仅显示用户创建的对象。提供一个模式或 &lt;code&gt;S&lt;/code&gt; 修饰符以包含系统对象。如果形式 &lt;code&gt;\df+&lt;/code&gt; 使用时，将显示有关每个功能的其他信息，包括易变性，并行安全性，所有者，安全性分类，访问权限，语言，源代码和描述。</target>
        </trans-unit>
        <trans-unit id="24ae150e74e52548491a1b8532993c514778868d" translate="yes" xml:space="preserve">
          <source>Lists installed extensions. If &lt;code&gt;pattern&lt;/code&gt; is specified, only those extensions whose names match the pattern are listed. If the form &lt;code&gt;\dx+&lt;/code&gt; is used, all the objects belonging to each matching extension are listed.</source>
          <target state="translated">列出已安装的扩展。如果 &lt;code&gt;pattern&lt;/code&gt; 被指定，只有这些扩展名匹配的模式中列出。如果使用 &lt;code&gt;\dx+&lt;/code&gt; 格式，则列出属于每个匹配扩展名的所有对象。</target>
        </trans-unit>
        <trans-unit id="9786e0547a160a45eeaaa13b899d2ca350fd4bf0" translate="yes" xml:space="preserve">
          <source>Lists operator classes (see &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-OPCLASS&quot;&gt;Section 37.16.1&lt;/a&gt;). If &lt;code&gt;access-method-pattern&lt;/code&gt; is specified, only operator classes associated with access methods whose names match that pattern are listed. If &lt;code&gt;input-type-pattern&lt;/code&gt; is specified, only operator classes associated with input types whose names match that pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each operator class is listed with its associated operator family and owner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dabc9d2416e57fbb1a6fc125515b7843848c40ff" translate="yes" xml:space="preserve">
          <source>Lists operator families (see &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-OPFAMILY&quot;&gt;Section 37.16.5&lt;/a&gt;). If &lt;code&gt;access-method-pattern&lt;/code&gt; is specified, only operator families associated with access methods whose names match that pattern are listed. If &lt;code&gt;input-type-pattern&lt;/code&gt; is specified, only operator families associated with input types whose names match that pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each operator family is listed with its owner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02fc530a920ec71e97da7b47a26de17857efd30a" translate="yes" xml:space="preserve">
          <source>Lists operators associated with operator families (see &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-STRATEGIES&quot;&gt;Section 37.16.2&lt;/a&gt;). If &lt;code&gt;access-method-pattern&lt;/code&gt; is specified, only members of operator families associated with access methods whose names match that pattern are listed. If &lt;code&gt;operator-family-pattern&lt;/code&gt; is specified, only members of operator families whose names match that pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each operator is listed with its sort operator family (if it is an ordering operator).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b91d850ae0056bf60018b5ebefbaf56889e4bca" translate="yes" xml:space="preserve">
          <source>Lists operators with their operand and result types. If &lt;code&gt;pattern&lt;/code&gt; is specified, only operators whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, additional information about each operator is shown, currently just the name of the underlying function.</source>
          <target state="translated">列出运算符及其操作数和结果类型。如果 &lt;code&gt;pattern&lt;/code&gt; 被指定，只有运营商的名字匹配模式的上市。默认情况下，仅显示用户创建的对象。提供一个模式或 &lt;code&gt;S&lt;/code&gt; 修饰符以包括系统对象。如果在命令名称后附加 &lt;code&gt;+&lt;/code&gt; ，则会显示有关每个运算符的其他信息，当前仅是基础函数的名称。</target>
        </trans-unit>
        <trans-unit id="b6dce10f054bc4a066d94e91eb2653d58925f8ed" translate="yes" xml:space="preserve">
          <source>Lists partitioned relations. If &lt;code&gt;pattern&lt;/code&gt; is specified, only entries whose name matches the pattern are listed. The modifiers &lt;code&gt;t&lt;/code&gt; (tables) and &lt;code&gt;i&lt;/code&gt; (indexes) can be appended to the command, filtering the kind of relations to list. By default, partitioned tables and indexes are listed.</source>
          <target state="translated">列出分区关系。如果 &lt;code&gt;pattern&lt;/code&gt; 被指定，只有项的名字列在模式相匹配。可以将修饰符 &lt;code&gt;t&lt;/code&gt; （表）和 &lt;code&gt;i&lt;/code&gt; （索引）附加到命令中，以过滤要列出的关系的种类。默认情况下，列出分区表和索引。</target>
        </trans-unit>
        <trans-unit id="6639ac93b6964b1629641d3ad0795ccf6bdb89e2" translate="yes" xml:space="preserve">
          <source>Lists procedural languages. If &lt;code&gt;pattern&lt;/code&gt; is specified, only languages whose names match the pattern are listed. By default, only user-created languages are shown; supply the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each language is listed with its call handler, validator, access privileges, and whether it is a system object.</source>
          <target state="translated">列出程序语言。如果 &lt;code&gt;pattern&lt;/code&gt; 被指定，只有语言的名字匹配模式的上市。默认情况下，仅显示用户创建的语言。提供 &lt;code&gt;S&lt;/code&gt; 修饰符以包括系统对象。如果在命令名后附加 &lt;code&gt;+&lt;/code&gt; ，则将列出每种语言及其调用处理程序，验证程序，访问权限以及是否为系统对象。</target>
        </trans-unit>
        <trans-unit id="d159d89b43261dc04712aa39d984b98a29983107" translate="yes" xml:space="preserve">
          <source>Lists replication publications. If &lt;code&gt;pattern&lt;/code&gt; is specified, only those publications whose names match the pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, the tables associated with each publication are shown as well.</source>
          <target state="translated">列出复制出版物。如果 &lt;code&gt;pattern&lt;/code&gt; 被指定，只有那些刊物的名字匹配模式的上市。如果在命令名称后附加 &lt;code&gt;+&lt;/code&gt; ,则还将显示与每个发布关联的表。</target>
        </trans-unit>
        <trans-unit id="5edfb1ad4f7a1bcdc13378e73525d95e092cfe45" translate="yes" xml:space="preserve">
          <source>Lists replication subscriptions. If &lt;code&gt;pattern&lt;/code&gt; is specified, only those subscriptions whose names match the pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, additional properties of the subscriptions are shown.</source>
          <target state="translated">列出复制订阅。如果 &lt;code&gt;pattern&lt;/code&gt; 被指定，只有那些订阅名字匹配模式的上市。如果在命令名称后附加 &lt;code&gt;+&lt;/code&gt; ，则会显示订阅的其他属性。</target>
        </trans-unit>
        <trans-unit id="4fb239c1a080740cf10a3927b46a1262b5ea56d1" translate="yes" xml:space="preserve">
          <source>Lists schemas (namespaces). If &lt;code&gt;pattern&lt;/code&gt; is specified, only schemas whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its associated permissions and description, if any.</source>
          <target state="translated">列出架构（名称空间）。如果 &lt;code&gt;pattern&lt;/code&gt; 被指定，唯一的模式，其名称匹配模式的上市。默认情况下，仅显示用户创建的对象。提供一个模式或 &lt;code&gt;S&lt;/code&gt; 修饰符以包括系统对象。如果在命令名称后附加 &lt;code&gt;+&lt;/code&gt; ，则列出每个对象及其相关的权限和描述（如果有）。</target>
        </trans-unit>
        <trans-unit id="f82cdaaaa438cda917a1234e5b948d7815debbbb" translate="yes" xml:space="preserve">
          <source>Lists support functions associated with operator families (see &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-SUPPORT&quot;&gt;Section 37.16.3&lt;/a&gt;). If &lt;code&gt;access-method-pattern&lt;/code&gt; is specified, only functions of operator families associated with access methods whose names match that pattern are listed. If &lt;code&gt;operator-family-pattern&lt;/code&gt; is specified, only functions of operator families whose names match that pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, functions are displayed verbosely, with their actual parameter lists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaa2ebfeff5215f2bad04d9af2cdf2d89c158023" translate="yes" xml:space="preserve">
          <source>Lists tables, views and sequences with their associated access privileges. If &lt;code&gt;pattern&lt;/code&gt; is specified, only tables, views and sequences whose names match the pattern are listed.</source>
          <target state="translated">列出具有相关访问权限的表，视图和序列。如果指定了 &lt;code&gt;pattern&lt;/code&gt; ，则仅列出名称与模式匹配的表，视图和序列。</target>
        </trans-unit>
        <trans-unit id="bb59616e451459bc316da05ad410acee2d59778b" translate="yes" xml:space="preserve">
          <source>Lists tables, views and sequences with their associated access privileges. If a &lt;code&gt;pattern&lt;/code&gt; is specified, only tables, views and sequences whose names match the pattern are listed.</source>
          <target state="translated">列出具有相关访问权限的表，视图和序列。如果指定了 &lt;code&gt;pattern&lt;/code&gt; ，则仅列出名称与该模式匹配的表，视图和序列。</target>
        </trans-unit>
        <trans-unit id="ef7de3f6c539d5dd5da460845cd3a63bfcafc2bd" translate="yes" xml:space="preserve">
          <source>Lists tablespaces. If &lt;code&gt;pattern&lt;/code&gt; is specified, only tablespaces whose names match the pattern are shown. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each tablespace is listed with its associated options, on-disk size, permissions and description.</source>
          <target state="translated">列出表空间。如果 &lt;code&gt;pattern&lt;/code&gt; 被指定，只显示了表空间名匹配的模式。如果在命令名后附加 &lt;code&gt;+&lt;/code&gt; ，则会列出每个表空间及其相关的选项，磁盘大小，权限和描述。</target>
        </trans-unit>
        <trans-unit id="762f36a63dc0b6ce665e3c2131b6edc15a3446da" translate="yes" xml:space="preserve">
          <source>Lists text search configurations. If &lt;code&gt;pattern&lt;/code&gt; is specified, only configurations whose names match the pattern are shown. If the form &lt;code&gt;\dF+&lt;/code&gt; is used, a full description of each configuration is shown, including the underlying text search parser and the dictionary list for each parser token type.</source>
          <target state="translated">列出文本搜索配置。如果 &lt;code&gt;pattern&lt;/code&gt; 被指定，只显示了配置名称匹配的模式。如果使用 &lt;code&gt;\dF+&lt;/code&gt; 形式，则会显示每个配置的完整说明，包括基础文本搜索解析器和每种解析器标记类型的字典列表。</target>
        </trans-unit>
        <trans-unit id="f6bb868ceb84c3b85646ce544e1a8e93f3c169f4" translate="yes" xml:space="preserve">
          <source>Lists text search dictionaries. If &lt;code&gt;pattern&lt;/code&gt; is specified, only dictionaries whose names match the pattern are shown. If the form &lt;code&gt;\dFd+&lt;/code&gt; is used, additional information is shown about each selected dictionary, including the underlying text search template and the option values.</source>
          <target state="translated">列出文本搜索词典。如果 &lt;code&gt;pattern&lt;/code&gt; 被指定，只显示了字典的名字相匹配的模式。如果使用 &lt;code&gt;\dFd+&lt;/code&gt; 形式，则会显示有关每个所选词典的其他信息，包括基础的文本搜索模板和选项值。</target>
        </trans-unit>
        <trans-unit id="ba01d174c5c6cab6bd3b44d816241b168a44d553" translate="yes" xml:space="preserve">
          <source>Lists text search parsers. If &lt;code&gt;pattern&lt;/code&gt; is specified, only parsers whose names match the pattern are shown. If the form &lt;code&gt;\dFp+&lt;/code&gt; is used, a full description of each parser is shown, including the underlying functions and the list of recognized token types.</source>
          <target state="translated">列出文本搜索解析器。如果 &lt;code&gt;pattern&lt;/code&gt; 被指定，只显示了解析器名匹配的模式。如果使用 &lt;code&gt;\dFp+&lt;/code&gt; 形式，则会显示每个解析器的完整描述，包括基础功能和已识别标记类型的列表。</target>
        </trans-unit>
        <trans-unit id="80703d2e971d1dc8cd3056fab4357086f4708060" translate="yes" xml:space="preserve">
          <source>Lists text search templates. If &lt;code&gt;pattern&lt;/code&gt; is specified, only templates whose names match the pattern are shown. If the form &lt;code&gt;\dFt+&lt;/code&gt; is used, additional information is shown about each template, including the underlying function names.</source>
          <target state="translated">列出文本搜索模板。如果 &lt;code&gt;pattern&lt;/code&gt; 被指定，只显示了模板名称匹配的模式。如果使用 &lt;code&gt;\dFt+&lt;/code&gt; 形式，则会显示有关每个模板的其他信息，包括基础函数名称。</target>
        </trans-unit>
        <trans-unit id="1d9024892b5e72795e533219deec09ad897119d7" translate="yes" xml:space="preserve">
          <source>Lists the ancestor relations of the given partition, including the relation itself. Returns no rows if the relation does not exist or is not a partition or partitioned table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f51bd1ab303ee9de03bdc15a672decf5bfa818c0" translate="yes" xml:space="preserve">
          <source>Lists the log files in the &lt;code&gt;log_directory&lt;/code&gt; directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78999412a6e9f781edbd7db90370d17b04826c4b" translate="yes" xml:space="preserve">
          <source>Lists the tables or indexes in the partition tree of the given partitioned table or partitioned index, with one row for each partition. Information provided includes the OID of the partition, the OID of its immediate parent, a boolean value telling if the partition is a leaf, and an integer telling its level in the hierarchy. The level value is 0 for the input table or index, 1 for its immediate child partitions, 2 for their partitions, and so on. Returns no rows if the relation does not exist or is not a partition or partitioned table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0a40588516c3a8604348670da0a879303a508a1" translate="yes" xml:space="preserve">
          <source>Lists type casts. If &lt;code&gt;pattern&lt;/code&gt; is specified, only casts whose source or target types match the pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its associated description.</source>
          <target state="translated">列出类型转换。如果 &lt;code&gt;pattern&lt;/code&gt; 被指定，仅投下其源或目标类型匹配的模式中列出。如果在命令名称后附加 &lt;code&gt;+&lt;/code&gt; ，则会列出每个对象及其相关描述。</target>
        </trans-unit>
        <trans-unit id="b23bce00d2c7c8d6375ab0cd2ad7f38f1f799075" translate="yes" xml:space="preserve">
          <source>Lists user mappings (mnemonic: &amp;ldquo;external users&amp;rdquo;). If &lt;code&gt;pattern&lt;/code&gt; is specified, only those mappings whose user names match the pattern are listed. If the form &lt;code&gt;\deu+&lt;/code&gt; is used, additional information about each mapping is shown.</source>
          <target state="translated">列出用户映射（助记符：&amp;ldquo;外部用户&amp;rdquo;）。如果 &lt;code&gt;pattern&lt;/code&gt; 被指定，只有那些映射其用户名匹配模式的上市。如果使用格式 &lt;code&gt;\deu+&lt;/code&gt; ，则会显示有关每个映射的其他信息。</target>
        </trans-unit>
        <trans-unit id="fee8c64f75222b953355d11e92e46cafb863f042" translate="yes" xml:space="preserve">
          <source>Lists which transforms a call to the function should apply. Transforms convert between SQL types and language-specific data types; see &lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORM&lt;/a&gt;. Procedural language implementations usually have hardcoded knowledge of the built-in types, so those don't need to be listed here. If a procedural language implementation does not know how to handle a type and no transform is supplied, it will fall back to a default behavior for converting data types, but this depends on the implementation.</source>
          <target state="translated">列出将对函数的调用转换的列表。转换可在SQL类型和特定于语言的数据类型之间进行转换；参见&lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORM&lt;/a&gt;。程序语言实现通常具有内置类型的硬编码知识，因此无需在此处列出。如果过程语言实现不知道如何处理类型并且不提供任何转换，则它将退回到用于转换数据类型的默认行为，但这取决于实现。</target>
        </trans-unit>
        <trans-unit id="c221c51fd4371df729302cc73086e8359e205a42" translate="yes" xml:space="preserve">
          <source>Lists which transforms a call to the procedure should apply. Transforms convert between SQL types and language-specific data types; see &lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORM&lt;/a&gt;. Procedural language implementations usually have hardcoded knowledge of the built-in types, so those don't need to be listed here. If a procedural language implementation does not know how to handle a type and no transform is supplied, it will fall back to a default behavior for converting data types, but this depends on the implementation.</source>
          <target state="translated">列出将对过程的调用转换的列表。转换可在SQL类型和特定于语言的数据类型之间进行转换；参见&lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORM&lt;/a&gt;。程序语言实现通常具有内置类型的硬编码知识，因此无需在此处列出。如果过程语言实现不知道如何处理类型并且不提供任何转换，则它将退回到用于转换数据类型的默认行为，但这取决于实现。</target>
        </trans-unit>
        <trans-unit id="0c4bdf42add57a2eabb9fb37aeb6c28158bad4b3" translate="yes" xml:space="preserve">
          <source>Literal &lt;code&gt;%&lt;/code&gt;</source>
          <target state="translated">文字 &lt;code&gt;%&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df214b5bbf763eb7922bad89d00442e94abbaf1f" translate="yes" xml:space="preserve">
          <source>Loading an extension essentially amounts to running the extension's script file. The script will typically create new SQL objects such as functions, data types, operators and index support methods. &lt;code&gt;CREATE EXTENSION&lt;/code&gt; additionally records the identities of all the created objects, so that they can be dropped again if &lt;code&gt;DROP EXTENSION&lt;/code&gt; is issued.</source>
          <target state="translated">加载扩展实质上等于运行扩展的脚本文件。该脚本通常将创建新的SQL对象，例如函数，数据类型，运算符和索引支持方法。 &lt;code&gt;CREATE EXTENSION&lt;/code&gt; 还会记录所有已创建对象的身份，以便在发出 &lt;code&gt;DROP EXTENSION&lt;/code&gt; 时可以再次删除它们。</target>
        </trans-unit>
        <trans-unit id="e93fcdb23625364e2abff318d75861520536fbf6" translate="yes" xml:space="preserve">
          <source>Loading an extension ordinarily requires the same privileges that would be required to create its component objects. For many extensions this means superuser privileges are needed. However, if the extension is marked &lt;em&gt;trusted&lt;/em&gt; in its control file, then it can be installed by any user who has &lt;code&gt;CREATE&lt;/code&gt; privilege on the current database. In this case the extension object itself will be owned by the calling user, but the contained objects will be owned by the bootstrap superuser (unless the extension's script explicitly assigns them to the calling user). This configuration gives the calling user the right to drop the extension, but not to modify individual objects within it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="324780c29ae9b46671035da5fbfcca3eeeaa0b74" translate="yes" xml:space="preserve">
          <source>Loading an extension requires the same privileges that would be required to create its component objects. For most extensions this means superuser or database owner privileges are needed. The user who runs &lt;code&gt;CREATE EXTENSION&lt;/code&gt; becomes the owner of the extension for purposes of later privilege checks, as well as the owner of any objects created by the extension's script.</source>
          <target state="translated">加载扩展需要与创建其组件对象相同的特权。对于大多数扩展，这意味着需要超级用户或数据库所有者特权。运行 &lt;code&gt;CREATE EXTENSION&lt;/code&gt; 的用户将成为扩展的所有者，以进行以后的权限检查，以及该扩展的脚本创建的任何对象的所有者。</target>
        </trans-unit>
        <trans-unit id="1ff55ba6c7cc873988ea156302dfd04284604724" translate="yes" xml:space="preserve">
          <source>Locale Support</source>
          <target state="translated">当地支持</target>
        </trans-unit>
        <trans-unit id="1615ae9075efc2383f73fbc3997d85cdd39b60c0" translate="yes" xml:space="preserve">
          <source>Locale support is automatically initialized when a database cluster is created using &lt;code&gt;initdb&lt;/code&gt;. &lt;code&gt;initdb&lt;/code&gt; will initialize the database cluster with the locale setting of its execution environment by default, so if your system is already set to use the locale that you want in your database cluster then there is nothing else you need to do. If you want to use a different locale (or you are not sure which locale your system is set to), you can instruct &lt;code&gt;initdb&lt;/code&gt; exactly which locale to use by specifying the &lt;code&gt;--locale&lt;/code&gt; option. For example:</source>
          <target state="translated">使用 &lt;code&gt;initdb&lt;/code&gt; 创建数据库集群时，将自动初始化语言环境支持。 &lt;code&gt;initdb&lt;/code&gt; 默认情况下将使用其执行环境的语言环境设置来初始化数据库集群，因此，如果您的系统已经设置为使用数据库集群中所需的语言环境，则无需执行其他任何操作。如果要使用其他语言环境（或者不确定系统设置为哪个语言环境），则可以通过指定 &lt;code&gt;--locale&lt;/code&gt; 选项来准确指示 &lt;code&gt;initdb&lt;/code&gt; 使用哪个语言环境。例如：</target>
        </trans-unit>
        <trans-unit id="b9fc941160f1b0396956bfd39853ec712bd8d1fb" translate="yes" xml:space="preserve">
          <source>Localization</source>
          <target state="translated">Localization</target>
        </trans-unit>
        <trans-unit id="405016b1820c348aea5cd317a6502812cdf4ad22" translate="yes" xml:space="preserve">
          <source>Location of root page (zero if none)</source>
          <target state="translated">根页面的位置(如果没有,则为零)</target>
        </trans-unit>
        <trans-unit id="24d45a6df98cb6f2c1180b96048b79a73fa5f768" translate="yes" xml:space="preserve">
          <source>Location of specified substring</source>
          <target state="translated">指定子串的位置</target>
        </trans-unit>
        <trans-unit id="dbb39d513ae60400b7ebae4d62c9e5ac6f77044b" translate="yes" xml:space="preserve">
          <source>Location of specified substring (same as &lt;code&gt;position(&lt;em&gt;substring&lt;/em&gt; in &lt;em&gt;string&lt;/em&gt;)&lt;/code&gt;, but note the reversed argument order)</source>
          <target state="translated">指定的子字符串的 &lt;code&gt;position(&lt;em&gt;substring&lt;/em&gt; in &lt;em&gt;string&lt;/em&gt;)&lt;/code&gt; （与position（&lt;em&gt;字符串&lt;/em&gt;中的&lt;em&gt;子&lt;/em&gt;&lt;em&gt;字符串&lt;/em&gt;）相同，但请注意参数顺序相反）</target>
        </trans-unit>
        <trans-unit id="9c2e448b0989a5090dc489ea6de417d94cf811c0" translate="yes" xml:space="preserve">
          <source>LocationIndex</source>
          <target state="translated">LocationIndex</target>
        </trans-unit>
        <trans-unit id="891ebccd5baa32daed16fb5a0825ca7a4464931f" translate="yes" xml:space="preserve">
          <source>Lock</source>
          <target state="translated">Lock</target>
        </trans-unit>
        <trans-unit id="c804bf0349b9527944ec4a3fe74284d562dd49b7" translate="yes" xml:space="preserve">
          <source>Lock Management</source>
          <target state="translated">锁具管理</target>
        </trans-unit>
        <trans-unit id="9f5be0c66691f0334e7d2037502bfeef360b9c5d" translate="yes" xml:space="preserve">
          <source>Lock mode of lockers (more than one if multitransaction), an array of &lt;code&gt;Key Share&lt;/code&gt;, &lt;code&gt;Share&lt;/code&gt;, &lt;code&gt;For No Key Update&lt;/code&gt;, &lt;code&gt;No Key Update&lt;/code&gt;, &lt;code&gt;For Update&lt;/code&gt;, &lt;code&gt;Update&lt;/code&gt;.</source>
          <target state="translated">储物柜的锁定模式（如果是多事务，则为多个），一组 &lt;code&gt;Key Share&lt;/code&gt; ， &lt;code&gt;Share&lt;/code&gt; ， &lt;code&gt;For No Key Update&lt;/code&gt; ， &lt;code&gt;No Key Update&lt;/code&gt; ， &lt;code&gt;For Update&lt;/code&gt; ， &lt;code&gt;Update&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9404601307758cbcb4a22750c03c625138fcfc8" translate="yes" xml:space="preserve">
          <source>Locking and Indexes</source>
          <target state="translated">锁定和索引</target>
        </trans-unit>
        <trans-unit id="8804d3dd97270b8420c7ca1e904a01e8634cbbf1" translate="yes" xml:space="preserve">
          <source>Locking the regular and/or predicate lock manager could have some impact on database performance if this view is very frequently accessed. The locks are held only for the minimum amount of time necessary to obtain data from the lock managers, but this does not completely eliminate the possibility of a performance impact.</source>
          <target state="translated">如果该视图的访问非常频繁,锁定常规和/或谓词锁管理器可能会对数据库性能产生一定影响。锁定仅在从锁管理器获取数据所需的最短时间内保持,但这并不能完全消除影响性能的可能性。</target>
        </trans-unit>
        <trans-unit id="737c6c38b2b84007c82ea914cea8efb3178d5fdf" translate="yes" xml:space="preserve">
          <source>Log File Maintenance</source>
          <target state="translated">日志文件维护</target>
        </trans-unit>
        <trans-unit id="6d6b239b122bc0b05311eb6dfbfaaf45f232b9f3" translate="yes" xml:space="preserve">
          <source>Log Sequence Number, see &lt;a href=&quot;datatype-pg-lsn&quot;&gt;&lt;code&gt;pg_lsn&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;wal-internals&quot;&gt;WAL Internals&lt;/a&gt;.</source>
          <target state="translated">日志序列号，请参阅&lt;a href=&quot;datatype-pg-lsn&quot;&gt; &lt;code&gt;pg_lsn&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;wal-internals&quot;&gt;WAL内部&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="60c1e625e1e8d8bc204338911a42295c282dd7d9" translate="yes" xml:space="preserve">
          <source>Log file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f0a509232d18cc09dfcbf97250e9485bbc40c4c" translate="yes" xml:space="preserve">
          <source>Log files contain human-readable text lines about events. Examples include login failures, long-running queries, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac059a4497d87893d31436f7f08f37f59c88514b" translate="yes" xml:space="preserve">
          <source>Log record</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d305d15801e1e955744206adafaf8f3e3d1bb78e" translate="yes" xml:space="preserve">
          <source>Log-Shipping Standby Servers</source>
          <target state="translated">对数传输备用服务器</target>
        </trans-unit>
        <trans-unit id="e22cd962d5d7b24a566d7837fcf6043185781e24" translate="yes" xml:space="preserve">
          <source>Logarithm of &lt;em&gt;&lt;code&gt;x&lt;/code&gt;&lt;/em&gt; to base &lt;em&gt;&lt;code&gt;b&lt;/code&gt;&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="567a04e87e0264325ea2d8341bf4b0ffb622ca3f" translate="yes" xml:space="preserve">
          <source>Logged</source>
          <target state="translated">Logged</target>
        </trans-unit>
        <trans-unit id="668f966ac31eb810f98d105493f1c5cdc3067858" translate="yes" xml:space="preserve">
          <source>Logger (process)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5d5c5fb2a8798e4f962780fba63386de96b07b6" translate="yes" xml:space="preserve">
          <source>Logical AND</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2445214b8389f14bf2045be1111d0264af049737" translate="yes" xml:space="preserve">
          <source>Logical Decoding</source>
          <target state="translated">逻辑解码</target>
        </trans-unit>
        <trans-unit id="e7e803ba6df9ebf5f542bc2b7ce91db2dc559f7e" translate="yes" xml:space="preserve">
          <source>Logical NOT</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9b0aefdf7ed2c67abbfc572bbc5743979450674" translate="yes" xml:space="preserve">
          <source>Logical OR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65eac6118ebdd55aa38b41f70efdf532e567ffd8" translate="yes" xml:space="preserve">
          <source>Logical Operators</source>
          <target state="translated">逻辑运算符</target>
        </trans-unit>
        <trans-unit id="e81affcc4578ce875d0e0b75ca689bf2f32a90ae" translate="yes" xml:space="preserve">
          <source>Logical Operators: AND</source>
          <target state="translated">逻辑运算符。AND</target>
        </trans-unit>
        <trans-unit id="43e083b90a70b3c47c8f0041d3ea2af4e65c51e3" translate="yes" xml:space="preserve">
          <source>Logical Operators: NOT</source>
          <target state="translated">逻辑运算符。NOT</target>
        </trans-unit>
        <trans-unit id="d639dd9302fac485c5ef253dceb1e3f97c540d72" translate="yes" xml:space="preserve">
          <source>Logical Operators: OR</source>
          <target state="translated">逻辑运算符。OR</target>
        </trans-unit>
        <trans-unit id="87801dc1bcd5e1df0b7d1f2272c64ee5b039c930" translate="yes" xml:space="preserve">
          <source>Logical Repl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3d8aa18dbe5d539b67385e1079b7cb40cef477e" translate="yes" xml:space="preserve">
          <source>Logical Replication</source>
          <target state="translated">逻辑复制</target>
        </trans-unit>
        <trans-unit id="8922d517c58eafe0151a7cf981679470b4600e69" translate="yes" xml:space="preserve">
          <source>Logical decoding can be used to build &lt;a href=&quot;warm-standby#SYNCHRONOUS-REPLICATION&quot;&gt;synchronous replication&lt;/a&gt; solutions with the same user interface as synchronous replication for &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;streaming replication&lt;/a&gt;. To do this, the streaming replication interface (see &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding-walsender.html&quot;&gt;Section 48.3&lt;/a&gt;) must be used to stream out data. Clients have to send &lt;code&gt;Standby status update (F)&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt;) messages, just like streaming replication clients do.</source>
          <target state="translated">逻辑解码可用于构建与用于&lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;流复制的&lt;/a&gt;同步复制相同的用户界面的&lt;a href=&quot;warm-standby#SYNCHRONOUS-REPLICATION&quot;&gt;同步复制&lt;/a&gt;解决方案。为此，必须使用流复制接口（请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding-walsender.html&quot;&gt;第48.3节&lt;/a&gt;）来流出数据。客户端必须发送 &lt;code&gt;Standby status update (F)&lt;/code&gt; （请参阅&lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;第52.4节&lt;/a&gt;）消息，就像流复制客户端一样。</target>
        </trans-unit>
        <trans-unit id="f503cf64b38f12bede3e30319a09deafda284c40" translate="yes" xml:space="preserve">
          <source>Logical decoding can be used to build &lt;a href=&quot;warm-standby#SYNCHRONOUS-REPLICATION&quot;&gt;synchronous replication&lt;/a&gt; solutions with the same user interface as synchronous replication for &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;streaming replication&lt;/a&gt;. To do this, the streaming replication interface (see &lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding-walsender.html&quot;&gt;Section 48.3&lt;/a&gt;) must be used to stream out data. Clients have to send &lt;code&gt;Standby status update (F)&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt;) messages, just like streaming replication clients do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b10ab294a9b68fd1f46ed7bc6062a04492e6157" translate="yes" xml:space="preserve">
          <source>Logical group of the parameter</source>
          <target state="translated">参数的逻辑组</target>
        </trans-unit>
        <trans-unit id="c580b15c66ecbba918b3e32fb395e268ced977ef" translate="yes" xml:space="preserve">
          <source>Logical replication allows a database server to send a stream of data modifications to another server. PostgreSQL logical replication constructs a stream of logical data modifications from the WAL. Logical replication allows the data changes from individual tables to be replicated. Logical replication doesn't require a particular server to be designated as a master or a replica but allows data to flow in multiple directions. For more information on logical replication, see &lt;a href=&quot;https://www.postgresql.org/docs/12/logical-replication.html&quot;&gt;Chapter 30&lt;/a&gt;. Through the logical decoding interface (&lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;), third-party extensions can also provide similar functionality.</source>
          <target state="translated">逻辑复制允许数据库服务器将数据修改流发送到另一台服务器。 PostgreSQL逻辑复制从WAL构造逻辑数据修改流。逻辑复制允许复制单个表中的数据更改。逻辑复制不需要将特定的服务器指定为主服务器或副本服务器，而是允许数据在多个方向上流动。有关逻辑复制的更多信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/logical-replication.html&quot;&gt;第30章&lt;/a&gt;。通过逻辑解码接口（&lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;第48章&lt;/a&gt;），第三方扩展也可以提供类似的功能。</target>
        </trans-unit>
        <trans-unit id="efdfc15536907810b351505bdffe988864a38656" translate="yes" xml:space="preserve">
          <source>Logical replication allows a database server to send a stream of data modifications to another server. PostgreSQL logical replication constructs a stream of logical data modifications from the WAL. Logical replication allows the data changes from individual tables to be replicated. Logical replication doesn't require a particular server to be designated as a master or a replica but allows data to flow in multiple directions. For more information on logical replication, see &lt;a href=&quot;https://www.postgresql.org/docs/13/logical-replication.html&quot;&gt;Chapter 30&lt;/a&gt;. Through the logical decoding interface (&lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;), third-party extensions can also provide similar functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed65fe8b9917e90ed44964dea1e1dc23e674a9f1" translate="yes" xml:space="preserve">
          <source>Logical replication behaves similarly to normal DML operations in that the data will be updated even if it was changed locally on the subscriber node. If incoming data violates any constraints the replication will stop. This is referred to as a &lt;em&gt;conflict&lt;/em&gt;. When replicating &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; operations, missing data will not produce a conflict and such operations will simply be skipped.</source>
          <target state="translated">逻辑复制的行为与普通DML操作类似，因为即使在订阅者节点上本地更改了数据，数据也将被更新。如果传入数据违反任何约束，则复制将停止。这被称为&lt;em&gt;冲突&lt;/em&gt;。复制 &lt;code&gt;UPDATE&lt;/code&gt; 或 &lt;code&gt;DELETE&lt;/code&gt; 操作时，丢失的数据不会产生冲突，并且将仅跳过此类操作。</target>
        </trans-unit>
        <trans-unit id="686d57c78ae4b376c0e25252dd6b05a5049c2f9c" translate="yes" xml:space="preserve">
          <source>Logical replication currently has the following restrictions or missing functionality. These might be addressed in future releases.</source>
          <target state="translated">逻辑复制目前有以下限制或功能缺失。这些问题可能会在未来的版本中得到解决。</target>
        </trans-unit>
        <trans-unit id="bc5341d79f09d707679a0da10e711069ef1d9d1a" translate="yes" xml:space="preserve">
          <source>Logical replication is built with an architecture similar to physical streaming replication (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;). It is implemented by &amp;ldquo;walsender&amp;rdquo; and &amp;ldquo;apply&amp;rdquo; processes. The walsender process starts logical decoding (described in &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;) of the WAL and loads the standard logical decoding plugin (pgoutput). The plugin transforms the changes read from WAL to the logical replication protocol (see &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-logical-replication.html&quot;&gt;Section 52.5&lt;/a&gt;) and filters the data according to the publication specification. The data is then continuously transferred using the streaming replication protocol to the apply worker, which maps the data to local tables and applies the individual changes as they are received, in correct transactional order.</source>
          <target state="translated">逻辑复制是使用类似于物理流复制的架构构建的（请参见&lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;第26.2.5节&lt;/a&gt;）。它是通过&amp;ldquo;投稿人&amp;rdquo;和&amp;ldquo;申请&amp;rdquo;程序实现的。 walsender进程开始WAL的逻辑解码（在&lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;第48章中&lt;/a&gt;进行了描述），并加载了标准逻辑解码插件（pgoutput）。该插件将从WAL读取的更改转换为逻辑复制协议（请参阅&lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-logical-replication.html&quot;&gt;第52.5节&lt;/a&gt;），并根据发布规范过滤数据。然后，使用流复制协议将数据连续传输到应用工作程序，该工作程序将数据映射到本地表，并在收到更改后按正确的事务顺序应用各个更改。</target>
        </trans-unit>
        <trans-unit id="24f246c37056cfc3d645585b0f76929bd8ff75af" translate="yes" xml:space="preserve">
          <source>Logical replication is built with an architecture similar to physical streaming replication (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;). It is implemented by &amp;ldquo;walsender&amp;rdquo; and &amp;ldquo;apply&amp;rdquo; processes. The walsender process starts logical decoding (described in &lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;) of the WAL and loads the standard logical decoding plugin (pgoutput). The plugin transforms the changes read from WAL to the logical replication protocol (see &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-logical-replication.html&quot;&gt;Section 52.5&lt;/a&gt;) and filters the data according to the publication specification. The data is then continuously transferred using the streaming replication protocol to the apply worker, which maps the data to local tables and applies the individual changes as they are received, in correct transactional order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="435079a68c735c2e34e8587daebbc03ec2b4108b" translate="yes" xml:space="preserve">
          <source>Logical replication requires several configuration options to be set.</source>
          <target state="translated">逻辑复制需要设置几个配置选项。</target>
        </trans-unit>
        <trans-unit id="e84a093ac80e997279a156ad3e78ff218f69bfc7" translate="yes" xml:space="preserve">
          <source>Logical replication starts by copying a snapshot of the data on the publisher database. Once that is done, changes on the publisher are sent to the subscriber as they occur in real time. The subscriber applies data in the order in which commits were made on the publisher so that transactional consistency is guaranteed for the publications within any single subscription.</source>
          <target state="translated">逻辑复制通过复制发布者数据库上的数据快照开始。一旦完成,发布者上的变化就会实时发送到订阅者。订阅者按照在发布者上提交的顺序应用数据,这样就保证了任何单一订阅中的出版物的事务一致性。</target>
        </trans-unit>
        <trans-unit id="27b9470b0624c147b034592fe3f3a73182a2151c" translate="yes" xml:space="preserve">
          <source>Logical replication workers are taken from the pool defined by &lt;code&gt;max_worker_processes&lt;/code&gt;.</source>
          <target state="translated">逻辑复制工作程序来自 &lt;code&gt;max_worker_processes&lt;/code&gt; 定义的池。</target>
        </trans-unit>
        <trans-unit id="a63c3a3aa22b3789bd62013d2f279dd236a57e8e" translate="yes" xml:space="preserve">
          <source>Londiste, Slony</source>
          <target state="translated">Londiste,Slony</target>
        </trans-unit>
        <trans-unit id="7ed5823bb2b8c30b7d42594563eaf3c04e339fc5" translate="yes" xml:space="preserve">
          <source>Look at &lt;code&gt;xsyn_sample.rules&lt;/code&gt;, which is installed in &lt;code&gt;$SHAREDIR/tsearch_data/&lt;/code&gt;, for an example.</source>
          <target state="translated">以 &lt;code&gt;xsyn_sample.rules&lt;/code&gt; 为例，该文件安装在 &lt;code&gt;$SHAREDIR/tsearch_data/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca517b17b581321c398ee4798749fdb48a7ae7a7" translate="yes" xml:space="preserve">
          <source>Look at the new state of the data:</source>
          <target state="translated">看看数据的新状态。</target>
        </trans-unit>
        <trans-unit id="30d58e04409362da5a524652a2e000a29c4e8c15" translate="yes" xml:space="preserve">
          <source>Look for the best match.</source>
          <target state="translated">寻找最佳搭配。</target>
        </trans-unit>
        <trans-unit id="6a2e689d9886aec21b389565fdc3ad34371dc41e" translate="yes" xml:space="preserve">
          <source>Lookahead and lookbehind constraints cannot contain &lt;em&gt;back references&lt;/em&gt; (see &lt;a href=&quot;functions-matching#POSIX-ESCAPE-SEQUENCES&quot;&gt;Section 9.7.3.3&lt;/a&gt;), and all parentheses within them are considered non-capturing.</source>
          <target state="translated">先行约束和后向约束不能包含&lt;em&gt;向后引用&lt;/em&gt;（请参阅&lt;a href=&quot;functions-matching#POSIX-ESCAPE-SEQUENCES&quot;&gt;第9.7.3.3节&lt;/a&gt;），并且其中的所有括号都被视为未捕获。</target>
        </trans-unit>
        <trans-unit id="5078c384be6b302db7193d0145acae3ffddd4617" translate="yes" xml:space="preserve">
          <source>Looks up a replication origin by name and returns the internal ID. If no such replication origin is found an error is thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56e8f3a9171c421d0883280c2cd97e28c0e45385" translate="yes" xml:space="preserve">
          <source>Lookup a replication origin by name and return the internal id. If no corresponding replication origin is found an error is thrown.</source>
          <target state="translated">通过名称查找一个复制源,并返回内部id。如果没有找到对应的复制原点,就会抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="55e4cc0e110df2ac3459453907e4bd26c086ff4d" translate="yes" xml:space="preserve">
          <source>Lossiness causes performance degradation due to unnecessary fetches of table records that turn out to be false matches. Since random access to table records is slow, this limits the usefulness of GiST indexes. The likelihood of false matches depends on several factors, in particular the number of unique words, so using dictionaries to reduce this number is recommended.</source>
          <target state="translated">丢失会导致性能下降,因为不必要地获取表记录,结果是错误匹配。由于随机访问表记录的速度很慢,这限制了GiST索引的有用性。错误匹配的可能性取决于几个因素,特别是唯一词的数量,所以建议使用字典来减少这个数量。</target>
        </trans-unit>
        <trans-unit id="1531c1daacaf1bc409855b8d1d0f55e08ee771dd" translate="yes" xml:space="preserve">
          <source>Low Value</source>
          <target state="translated">低值</target>
        </trans-unit>
        <trans-unit id="21ceb119d4d9e001890111b5576f7f16ef00c26f" translate="yes" xml:space="preserve">
          <source>Low level base backups can be made in a non-exclusive or an exclusive way. The non-exclusive method is recommended and the exclusive one is deprecated and will eventually be removed.</source>
          <target state="translated">低级基础备份可以采用非独占方式或独占方式。建议采用非排他性的方式,排他性的方式已被废弃,最终将被删除。</target>
        </trans-unit>
        <trans-unit id="bddc7c31834ef546bcfbe24e4c18d4afaf657eb8" translate="yes" xml:space="preserve">
          <source>Lowest transaction ID that was still active. All transaction IDs less than &lt;code&gt;xmin&lt;/code&gt; are either committed and visible, or rolled back and dead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="ac4243ecb01964253411eb3c09a126fc164e78e2" translate="yes" xml:space="preserve">
          <source>MAC (Media Access Control) address</source>
          <target state="translated">MAC(媒体访问控制)地址</target>
        </trans-unit>
        <trans-unit id="566c47d211683b88f50af170e2aa6203ef55b10a" translate="yes" xml:space="preserve">
          <source>MAC (Media Access Control) address (EUI-64 format)</source>
          <target state="translated">MAC(媒体访问控制)地址(EUI-64格式)。</target>
        </trans-unit>
        <trans-unit id="b3c62ec9e889671f1211f3670d9feb61fe45a931" translate="yes" xml:space="preserve">
          <source>MAC addresses</source>
          <target state="translated">MAC地址</target>
        </trans-unit>
        <trans-unit id="22afa78dd9eba1a7e4c213c3623011af13b757a5" translate="yes" xml:space="preserve">
          <source>MAC addresses (EUI-64 format)</source>
          <target state="translated">MAC地址(EUI-64格式)</target>
        </trans-unit>
        <trans-unit id="1c27d6be2a8de3b4e76dde98311054d012ea27ef" translate="yes" xml:space="preserve">
          <source>MCV (most-common values) list statistics, serialized as &lt;code&gt;pg_mcv_list&lt;/code&gt; type</source>
          <target state="translated">MCV（最常用值）列表统计信息，序列化为 &lt;code&gt;pg_mcv_list&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="b773bed04a48de200b96981bb79467413a222066" translate="yes" xml:space="preserve">
          <source>MD5</source>
          <target state="translated">MD5</target>
        </trans-unit>
        <trans-unit id="43a2b4962eca5b9cc86e8c34c251b4aaf74d69de" translate="yes" xml:space="preserve">
          <source>MD5 crypt</source>
          <target state="translated">MD5密码</target>
        </trans-unit>
        <trans-unit id="b7800f24354ba47ad5de45633c8b73e60e95cf0f" translate="yes" xml:space="preserve">
          <source>MD5 hash and SHA1</source>
          <target state="translated">MD5哈希和SHA1</target>
        </trans-unit>
        <trans-unit id="609399527c0412d282c04a9855b05c67f3f4ed44" translate="yes" xml:space="preserve">
          <source>MD5-based crypt</source>
          <target state="translated">基于MD5的密码</target>
        </trans-unit>
        <trans-unit id="3bf08a84f15b98ce4d14b707f4a093b3cc8b853e" translate="yes" xml:space="preserve">
          <source>MOVE</source>
          <target state="translated">MOVE</target>
        </trans-unit>
        <trans-unit id="ab3eeea11f18e2650760cfbc2a9ee637afed8340" translate="yes" xml:space="preserve">
          <source>MOVE &amp;mdash; position a cursor</source>
          <target state="translated">MOVE &amp;mdash;定位光标</target>
        </trans-unit>
        <trans-unit id="29f17acbc2455f9f492968fd0bda5a0de71679d9" translate="yes" xml:space="preserve">
          <source>MSVC</source>
          <target state="translated">MSVC</target>
        </trans-unit>
        <trans-unit id="a967eb92e41a009b9209426313752a674c43be15" translate="yes" xml:space="preserve">
          <source>MVCC</source>
          <target state="translated">MVCC</target>
        </trans-unit>
        <trans-unit id="f7f38fb90552f61a802690d695bfa4d9b25df00e" translate="yes" xml:space="preserve">
          <source>Maintaining catalogs of message translations requires the on-going efforts of many volunteers that want to see PostgreSQL speak their preferred language well. If messages in your language are currently not available or not fully translated, your assistance would be appreciated. If you want to help, refer to &lt;a href=&quot;https://www.postgresql.org/docs/12/nls.html&quot;&gt;Chapter 54&lt;/a&gt; or write to the developers' mailing list.</source>
          <target state="translated">维护消息翻译目录需要许多志愿者的不断努力，他们希望看到PostgreSQL能很好地讲其首选语言。如果您当前使用的语言的消息不可用或未完全翻译，将不胜感激。如果您想提供帮助，请参阅&lt;a href=&quot;https://www.postgresql.org/docs/12/nls.html&quot;&gt;第54章&lt;/a&gt;或写信给开发人员的邮件列表。</target>
        </trans-unit>
        <trans-unit id="7106741f20d440f998ee112429f77e03e33f6395" translate="yes" xml:space="preserve">
          <source>Maintaining catalogs of message translations requires the on-going efforts of many volunteers that want to see PostgreSQL speak their preferred language well. If messages in your language are currently not available or not fully translated, your assistance would be appreciated. If you want to help, refer to &lt;a href=&quot;https://www.postgresql.org/docs/13/nls.html&quot;&gt;Chapter 54&lt;/a&gt; or write to the developers' mailing list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94de303bbef8935622224c5db48199c807ab7d71" translate="yes" xml:space="preserve">
          <source>Maintenance</source>
          <target state="translated">Maintenance</target>
        </trans-unit>
        <trans-unit id="dce34191f69ff984184a7501bc8f6215cc2b1283" translate="yes" xml:space="preserve">
          <source>Maintenance commands - &lt;code&gt;ANALYZE&lt;/code&gt;, &lt;code&gt;VACUUM&lt;/code&gt;, &lt;code&gt;CLUSTER&lt;/code&gt;, &lt;code&gt;REINDEX&lt;/code&gt;</source>
          <target state="translated">维护命令 &lt;code&gt;ANALYZE&lt;/code&gt; ， &lt;code&gt;VACUUM&lt;/code&gt; ， &lt;code&gt;CLUSTER&lt;/code&gt; ， &lt;code&gt;REINDEX&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="292d556449f6baefbefbc7a2798464550e97b523" translate="yes" xml:space="preserve">
          <source>Maintenance commands: &lt;code&gt;ANALYZE&lt;/code&gt;, &lt;code&gt;VACUUM&lt;/code&gt;, &lt;code&gt;CLUSTER&lt;/code&gt;, &lt;code&gt;REINDEX&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="477597b3a5e3545e4aafdda2f2a69a40df682681" translate="yes" xml:space="preserve">
          <source>Major PostgreSQL releases regularly add new features that often change the layout of the system tables, but the internal data storage format rarely changes. pg_upgrade uses this fact to perform rapid upgrades by creating new system tables and simply reusing the old user data files. If a future major release ever changes the data storage format in a way that makes the old data format unreadable, pg_upgrade will not be usable for such upgrades. (The community will attempt to avoid such situations.)</source>
          <target state="translated">pg_upgrade利用这个事实,通过创建新的系统表和简单地重用旧的用户数据文件来进行快速升级。如果未来的主要版本改变了数据存储格式,使得旧的数据格式无法读取,pg_upgrade将无法用于这种升级。(社区将试图避免这种情况。)</target>
        </trans-unit>
        <trans-unit id="634be9b233dfc40349e54f6799f11f557bdc5c75" translate="yes" xml:space="preserve">
          <source>Make a base backup of the primary server (see &lt;a href=&quot;continuous-archiving#BACKUP-BASE-BACKUP&quot;&gt;Section 25.3.2&lt;/a&gt;), and load this data onto the standby.</source>
          <target state="translated">对主服务器进行基本备份（请参阅&lt;a href=&quot;continuous-archiving#BACKUP-BASE-BACKUP&quot;&gt;第25.3.2节&lt;/a&gt;），并将此数据加载到备用服务器上。</target>
        </trans-unit>
        <trans-unit id="63a128e9fdffb0bd6c880f9009ba685205efe3c8" translate="yes" xml:space="preserve">
          <source>Make a password valid forever:</source>
          <target state="translated">让密码永远有效。</target>
        </trans-unit>
        <trans-unit id="3d352bc98e86554b9f8e7bb50ec4f35c4891b735" translate="yes" xml:space="preserve">
          <source>Make sure both database servers are stopped using, on Unix, e.g.:</source>
          <target state="translated">确保两个数据库服务器都停止使用,在Unix上,如:</target>
        </trans-unit>
        <trans-unit id="b9eb7d5c96a8c5d308e0b19059ab781c2cbe473e" translate="yes" xml:space="preserve">
          <source>Make sure that your server keytab file is readable (and preferably only readable, not writable) by the PostgreSQL server account. (See also &lt;a href=&quot;postgres-user&quot;&gt;Section 18.1&lt;/a&gt;.) The location of the key file is specified by the &lt;a href=&quot;runtime-config-connection#GUC-KRB-SERVER-KEYFILE&quot;&gt;krb_server_keyfile&lt;/a&gt; configuration parameter. The default is &lt;code&gt;/usr/local/pgsql/etc/krb5.keytab&lt;/code&gt; (or whatever directory was specified as &lt;code&gt;sysconfdir&lt;/code&gt; at build time). For security reasons, it is recommended to use a separate keytab just for the PostgreSQL server rather than opening up permissions on the system keytab file.</source>
          <target state="translated">确保PostgreSQL服务器帐户可读取您的服务器密钥表文件（最好仅可读取，不可写入）。（另请参见&lt;a href=&quot;postgres-user&quot;&gt;第18.1节&lt;/a&gt;。）密钥文件的位置由&lt;a href=&quot;runtime-config-connection#GUC-KRB-SERVER-KEYFILE&quot;&gt;krb_server_keyfile&lt;/a&gt;配置参数指定。默认值为 &lt;code&gt;/usr/local/pgsql/etc/krb5.keytab&lt;/code&gt; （或在构建时指定为 &lt;code&gt;sysconfdir&lt;/code&gt; 的任何目录）。出于安全原因，建议仅对PostgreSQL服务器使用单独的密钥表，而不是对系统密钥表文件开放权限。</target>
        </trans-unit>
        <trans-unit id="c85ef738c1ba87c2190fc933e484d7ebb7fc1d3b" translate="yes" xml:space="preserve">
          <source>Make sure that your session does not hold more locks than necessary when calling &lt;code&gt;pg_sleep&lt;/code&gt; or its variants. Otherwise other sessions might have to wait for your sleeping process, slowing down the entire system.</source>
          <target state="translated">确保调用 &lt;code&gt;pg_sleep&lt;/code&gt; 或其变体时，会话中没有持有过多的锁。否则，其他会话可能必须等待您的睡眠过程，从而降低整个系统的速度。</target>
        </trans-unit>
        <trans-unit id="d7b3ea8ab3afc4ab9fbece610d0afa1cdefe9215" translate="yes" xml:space="preserve">
          <source>Make sure the new binaries and support files are installed on all standby servers.</source>
          <target state="translated">确保所有备用服务器上都安装了新的二进制文件和支持文件。</target>
        </trans-unit>
        <trans-unit id="4be89cba4680b61369e645efc68f83ec81c167f1" translate="yes" xml:space="preserve">
          <source>Make sure the new standby data directories do &lt;em&gt;not&lt;/em&gt; exist or are empty. If initdb was run, delete the standby servers' new data directories.</source>
          <target state="translated">确保新的备用数据目录&lt;em&gt;不&lt;/em&gt;存在或为空。如果运行了initdb，请删除备用服务器的新数据目录。</target>
        </trans-unit>
        <trans-unit id="173d02f923c11447cf74a27c2960de0e28e12c9b" translate="yes" xml:space="preserve">
          <source>Makes &lt;code&gt;initdb&lt;/code&gt; prompt for a password to give the database superuser. If you don't plan on using password authentication, this is not important. Otherwise you won't be able to use password authentication until you have a password set up.</source>
          <target state="translated">使 &lt;code&gt;initdb&lt;/code&gt; 提示输入密码以授予数据库超级用户。如果您不打算使用密码身份验证，那么这并不重要。否则，在设置密码之前，您将无法使用密码身份验证。</target>
        </trans-unit>
        <trans-unit id="792a9e540ae77e4ca51fdc9b34493d77aa427a96" translate="yes" xml:space="preserve">
          <source>Makes &lt;code&gt;initdb&lt;/code&gt; read the database superuser's password from a file. The first line of the file is taken as the password.</source>
          <target state="translated">使 &lt;code&gt;initdb&lt;/code&gt; 从文件中读取数据库超级用户的密码。文件的第一行用作密码。</target>
        </trans-unit>
        <trans-unit id="272e7aa108f37caed38de50c7bbbc12a4eeb39f5" translate="yes" xml:space="preserve">
          <source>Makes a cube with upper right and lower left coordinates as defined by the two arrays, which must be of the same length.</source>
          <target state="translated">根据两个数组定义的右上角和左下角坐标制作一个立方体,这两个数组的长度必须相同。</target>
        </trans-unit>
        <trans-unit id="7896b684cd247a71e6d914ea864835f0a201cfd2" translate="yes" xml:space="preserve">
          <source>Makes a new cube by adding a dimension on to an existing cube, with the same values for both endpoints of the new coordinate. This is useful for building cubes piece by piece from calculated values.</source>
          <target state="translated">通过在现有的立方体上添加一个维度来制作一个新的立方体,新坐标的两个端点的数值相同。这对于根据计算值逐个建立立方体很有用。</target>
        </trans-unit>
        <trans-unit id="43a84f11220bc7ec3aa6c412b1e43c3f1a62c52f" translate="yes" xml:space="preserve">
          <source>Makes a new cube by adding a dimension on to an existing cube. This is useful for building cubes piece by piece from calculated values.</source>
          <target state="translated">通过在现有的立方体上添加一个维度来制作一个新的立方体。这对于根据计算值逐个建立立方体很有用。</target>
        </trans-unit>
        <trans-unit id="cec244b05a82755211877f23eb89341a3e2a9049" translate="yes" xml:space="preserve">
          <source>Makes a new cube from an existing cube, using a list of dimension indexes from an array. Can be used to extract the endpoints of a single dimension, or to drop dimensions, or to reorder them as desired.</source>
          <target state="translated">使用数组中的维度索引列表,从一个现有的立方体中创建一个新的立方体。可以用来提取单个维度的端点,或者放弃维度,或者根据需要重新排序。</target>
        </trans-unit>
        <trans-unit id="7c70237aa382dcfcb4e30da44d32fffb86de7855" translate="yes" xml:space="preserve">
          <source>Makes a one dimensional cube with both coordinates the same.</source>
          <target state="translated">制作一个一维的立方体,两个坐标相同。</target>
        </trans-unit>
        <trans-unit id="36186a49b5b2bc93a1e3ef40c1a52eabef758439" translate="yes" xml:space="preserve">
          <source>Makes a one dimensional cube.</source>
          <target state="translated">做出一个一维的立方体。</target>
        </trans-unit>
        <trans-unit id="fa2638ba09b880989be4b7b3a19ea5c423840179" translate="yes" xml:space="preserve">
          <source>Makes a single-element array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aae8d3b9540c85c4e0f867bbcd6f86be7f07d237" translate="yes" xml:space="preserve">
          <source>Makes a single-item &lt;code&gt;hstore&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c491ded092df3548669d7b1b5d203277eaee1f2e" translate="yes" xml:space="preserve">
          <source>Makes a zero-volume cube using the coordinates defined by the array.</source>
          <target state="translated">使用数组定义的坐标制作一个零体积的立方体。</target>
        </trans-unit>
        <trans-unit id="fefd6a2a56f64d38ec0468fc161189ce50419761" translate="yes" xml:space="preserve">
          <source>Making liberal use of views is a key aspect of good SQL database design. Views allow you to encapsulate the details of the structure of your tables, which might change as your application evolves, behind consistent interfaces.</source>
          <target state="translated">充分利用视图是良好的SQL数据库设计的一个关键方面。视图允许你将表结构的细节封装在一致的接口后面,这些细节可能会随着应用程序的发展而改变。</target>
        </trans-unit>
        <trans-unit id="f26b359ba37eb8a50cdf02456f39cff00b1155a4" translate="yes" xml:space="preserve">
          <source>Managing Databases</source>
          <target state="translated">管理数据库</target>
        </trans-unit>
        <trans-unit id="efd2c6be94610f9dd5980e65687b83de3d52e077" translate="yes" xml:space="preserve">
          <source>Managing Kernel Resources</source>
          <target state="translated">管理内核资源</target>
        </trans-unit>
        <trans-unit id="9edd256f8994898f1394cd9f5902a2fe3a3418a1" translate="yes" xml:space="preserve">
          <source>Managing Kernel Resources: Linux Huge Pages</source>
          <target state="translated">管理内核资源。Linux Huge Pages</target>
        </trans-unit>
        <trans-unit id="f84c08e43ab5092b16e87ebd218788d5283b9b4a" translate="yes" xml:space="preserve">
          <source>Managing Kernel Resources: Linux Memory Overcommit</source>
          <target state="translated">管理内核资源。Linux内存超限</target>
        </trans-unit>
        <trans-unit id="412c9a22726797c7f1da88a5ca11bb92ea162415" translate="yes" xml:space="preserve">
          <source>Managing Kernel Resources: Resource Limits</source>
          <target state="translated">管理内核资源。资源限制</target>
        </trans-unit>
        <trans-unit id="fc3ccce80bea44ef80a6a994d4e4358186b901da" translate="yes" xml:space="preserve">
          <source>Managing Kernel Resources: Shared Memory and Semaphores</source>
          <target state="translated">管理内核资源。共享内存和Semaphores</target>
        </trans-unit>
        <trans-unit id="67cd2bd0c8dc97a476e8e47ebb9371727475113d" translate="yes" xml:space="preserve">
          <source>Managing Kernel Resources: systemd RemoveIPC</source>
          <target state="translated">管理内核资源:systemd RemoveIPC</target>
        </trans-unit>
        <trans-unit id="67c48d67ef7ae304937a0a8de822ed104f4b2eb2" translate="yes" xml:space="preserve">
          <source>Manually set the WAL starting location by specifying the name of the next WAL segment file.</source>
          <target state="translated">通过指定下一个WAL段文件的名称,手动设置WAL起始位置。</target>
        </trans-unit>
        <trans-unit id="6ccaa7bcfd25bcb3a947594b5b5ad3594bebb3be" translate="yes" xml:space="preserve">
          <source>Manually set the next OID.</source>
          <target state="translated">手动设置下一个OID。</target>
        </trans-unit>
        <trans-unit id="b11b4e5b2d203da27bc1c6504a10632af73bd3c8" translate="yes" xml:space="preserve">
          <source>Manually set the next and oldest multitransaction ID.</source>
          <target state="translated">手动设置下一个和最老的多交易ID。</target>
        </trans-unit>
        <trans-unit id="05fcb9c1e9b6c68d58ec688a6b55b68af75801bf" translate="yes" xml:space="preserve">
          <source>Manually set the next multitransaction offset.</source>
          <target state="translated">手动设置下一个多交易偏移量。</target>
        </trans-unit>
        <trans-unit id="14870c8a6c58f7f0c07765537e62008b75b3dc73" translate="yes" xml:space="preserve">
          <source>Manually set the next transaction ID's epoch.</source>
          <target state="translated">手动设置下一个交易ID的时间间隔。</target>
        </trans-unit>
        <trans-unit id="4f4f1e99ced530ddd1fa0f7dac805a0ddcf54b22" translate="yes" xml:space="preserve">
          <source>Manually set the next transaction ID.</source>
          <target state="translated">手动设置下一个交易ID。</target>
        </trans-unit>
        <trans-unit id="648bd7a8e83568d94a29f369df1e0064e881bb1c" translate="yes" xml:space="preserve">
          <source>Manually set the oldest and newest transaction IDs for which the commit time can be retrieved.</source>
          <target state="translated">手动设置最老和最新的事务ID,可以检索提交时间。</target>
        </trans-unit>
        <trans-unit id="ff49c52c5651b25a87adf02de107946b0c6a1108" translate="yes" xml:space="preserve">
          <source>Manufacturers not currently having any products would not appear in the result, since it is an inner join. If we wished to include the names of such manufacturers in the result, we could do:</source>
          <target state="translated">目前没有产品的厂商不会出现在结果中,因为这是一个内部连接。如果我们希望在结果中加入这些制造商的名称,我们可以这样做。</target>
        </trans-unit>
        <trans-unit id="5d400bc2fffdc5a10db82b688a6346e4cf189544" translate="yes" xml:space="preserve">
          <source>Many database systems have the notion of a one to many table. Such a table usually sits between two indexed tables, for example:</source>
          <target state="translated">很多数据库系统都有一比多表的概念。例如,这种表通常位于两个索引表之间。</target>
        </trans-unit>
        <trans-unit id="95ffbad28eb7bf7f9a21d96e280ac0310171a900" translate="yes" xml:space="preserve">
          <source>Many developers consider explicitly listing the columns better style than relying on the order implicitly.</source>
          <target state="translated">很多开发者认为显式列举比隐式依靠顺序更好的风格。</target>
        </trans-unit>
        <trans-unit id="1cb82d9eaa9bf285209fa61fc5831409cba350d7" translate="yes" xml:space="preserve">
          <source>Many failover systems use just two systems, the primary and the standby, connected by some kind of heartbeat mechanism to continually verify the connectivity between the two and the viability of the primary. It is also possible to use a third system (called a witness server) to prevent some cases of inappropriate failover, but the additional complexity might not be worthwhile unless it is set up with sufficient care and rigorous testing.</source>
          <target state="translated">许多故障切换系统只使用两个系统,即主系统和备用系统,通过某种心跳机制连接,以不断验证两者之间的连接性和主系统的可行性。也可以使用第三个系统(称为见证服务器)来防止某些不适当的故障切换情况,但除非在设置时足够谨慎和严格测试,否则额外的复杂性可能是不值得的。</target>
        </trans-unit>
        <trans-unit id="de1e6960880fdbfac06a6878d8dd73d232d78b66" translate="yes" xml:space="preserve">
          <source>Many installations create their database clusters on file systems (volumes) other than the machine's &amp;ldquo;root&amp;rdquo; volume. If you choose to do this, it is not advisable to try to use the secondary volume's topmost directory (mount point) as the data directory. Best practice is to create a directory within the mount-point directory that is owned by the PostgreSQL user, and then create the data directory within that. This avoids permissions problems, particularly for operations such as pg_upgrade, and it also ensures clean failures if the secondary volume is taken offline.</source>
          <target state="translated">除了计算机的&amp;ldquo;根&amp;rdquo;卷，许多安装都在文件系统（卷）上创建数据库集群。如果选择执行此操作，建议不要尝试使用辅助卷的最顶层目录（装入点）作为数据目录。最佳实践是在PostgreSQL用户拥有的安装点目录中创建一个目录，然后在其中创建数据目录。这样可以避免权限问题，尤其是对于诸如pg_upgrade之类的操作，还可以确保在辅助卷脱机时清除失败。</target>
        </trans-unit>
        <trans-unit id="7998a6e83c9395997d176b8166f6ac50148a21ee" translate="yes" xml:space="preserve">
          <source>Many of the ARE extensions are borrowed from Perl, but some have been changed to clean them up, and a few Perl extensions are not present. Incompatibilities of note include &lt;code&gt;\b&lt;/code&gt;, &lt;code&gt;\B&lt;/code&gt;, the lack of special treatment for a trailing newline, the addition of complemented bracket expressions to the things affected by newline-sensitive matching, the restrictions on parentheses and back references in lookahead/lookbehind constraints, and the longest/shortest-match (rather than first-match) matching semantics.</source>
          <target state="translated">许多ARE扩展都是从Perl借来的，但是有些已被更改以清理它们，并且不存在一些Perl扩展。注意的不兼容之处包括 &lt;code&gt;\b&lt;/code&gt; ， &lt;code&gt;\B&lt;/code&gt; ，对尾随换行符的特殊处理，向受换行符敏感匹配影响的事物中添加补充括号表达式，对括号的限制以及在前向/后向约束中的反向引用，以及最长/最短匹配（而不是首次匹配）匹配语义。</target>
        </trans-unit>
        <trans-unit id="c2510bd4f5c7e075d877a23b92664b0d94264d01" translate="yes" xml:space="preserve">
          <source>Many of the JSON processing functions described in &lt;a href=&quot;functions-json&quot;&gt;Section 9.15&lt;/a&gt; will convert Unicode escapes to regular characters, and will therefore throw the same types of errors just described even if their input is of type &lt;code&gt;json&lt;/code&gt; not &lt;code&gt;jsonb&lt;/code&gt;. The fact that the &lt;code&gt;json&lt;/code&gt; input function does not make these checks may be considered a historical artifact, although it does allow for simple storage (without processing) of JSON Unicode escapes in a non-UTF8 database encoding. In general, it is best to avoid mixing Unicode escapes in JSON with a non-UTF8 database encoding, if possible.</source>
          <target state="translated">&lt;a href=&quot;functions-json&quot;&gt;第9.15节中&lt;/a&gt;描述的许多JSON处理函数会将Unicode转义转换为常规字符，因此即使它们的输入类型为 &lt;code&gt;json&lt;/code&gt; not &lt;code&gt;jsonb&lt;/code&gt; ，也将引发与上述类型相同的错误。 &lt;code&gt;json&lt;/code&gt; 输入函数不进行这些检查的事实可能被认为是历史工件，尽管它确实允许以非UTF8数据库编码的形式简单存储（无需处理）JSON Unicode转义。通常，如果可能的话，最好避免将JSON中的Unicode转义与非UTF8数据库编码混合在一起。</target>
        </trans-unit>
        <trans-unit id="80b59991b11e3266fbd513366535241df81a8cf9" translate="yes" xml:space="preserve">
          <source>Many of the JSON processing functions described in &lt;a href=&quot;functions-json&quot;&gt;Section 9.16&lt;/a&gt; will convert Unicode escapes to regular characters, and will therefore throw the same types of errors just described even if their input is of type &lt;code&gt;json&lt;/code&gt; not &lt;code&gt;jsonb&lt;/code&gt;. The fact that the &lt;code&gt;json&lt;/code&gt; input function does not make these checks may be considered a historical artifact, although it does allow for simple storage (without processing) of JSON Unicode escapes in a database encoding that does not support the represented characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3ceba3684c41c44915004b6549907098b3d1192" translate="yes" xml:space="preserve">
          <source>Many of the above solutions allow multiple servers to handle multiple queries, but none allow a single query to use multiple servers to complete faster. This solution allows multiple servers to work concurrently on a single query. It is usually accomplished by splitting the data among servers and having each server execute its part of the query and return results to a central server where they are combined and returned to the user. Pgpool-II has this capability. Also, this can be implemented using the PL/Proxy tool set.</source>
          <target state="translated">以上很多解决方案都允许多台服务器处理多个查询,但都不允许一个查询使用多台服务器更快完成。这种解决方案允许多个服务器同时处理一个查询。它通常是通过在服务器之间分割数据,让每个服务器执行其部分查询,并将结果返回到中央服务器,在那里将它们合并并返回给用户。Pgpool-II具有这种功能。此外,还可以使用PL/Proxy工具集来实现这一功能。</target>
        </trans-unit>
        <trans-unit id="014eb2b75bf8a185a68dd7926fad4b4f2fb6f6a5" translate="yes" xml:space="preserve">
          <source>Many of the above solutions allow multiple servers to handle multiple queries, but none allow a single query to use multiple servers to complete faster. This solution allows multiple servers to work concurrently on a single query. It is usually accomplished by splitting the data among servers and having each server execute its part of the query and return results to a central server where they are combined and returned to the user. This can be implemented using the PL/Proxy tool set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="686c93751e24bfbb5a5a8babbdffa0304da95e5d" translate="yes" xml:space="preserve">
          <source>Many of the meta-commands act on the &lt;em&gt;current query buffer&lt;/em&gt;. This is simply a buffer holding whatever SQL command text has been typed but not yet sent to the server for execution. This will include previous input lines as well as any text appearing before the meta-command on the same line.</source>
          <target state="translated">许多元命令作用于&lt;em&gt;当前查询缓冲区&lt;/em&gt;。这只是一个缓冲区，用于保存已键入但尚未发送到服务器以执行的任何SQL命令文本。这将包括先前的输入行以及在同一行上的meta命令之前出现的所有文本。</target>
        </trans-unit>
        <trans-unit id="d0cfb05fe7e11967ff7a6d7fb5a62aee53e9651c" translate="yes" xml:space="preserve">
          <source>Many of these functions and operators will convert Unicode escapes in JSON strings to the appropriate single character. This is a non-issue if the input is type &lt;code&gt;jsonb&lt;/code&gt;, because the conversion was already done; but for &lt;code&gt;json&lt;/code&gt; input, this may result in throwing an error, as noted in &lt;a href=&quot;datatype-json&quot;&gt;Section 8.14&lt;/a&gt;.</source>
          <target state="translated">其中许多功能和运算符会将JSON字符串中的Unicode转义转换为适当的单个字符。如果输入的类型为 &lt;code&gt;jsonb&lt;/code&gt; ，则这不是问题，因为转换已经完成；但是对于 &lt;code&gt;json&lt;/code&gt; 输入，这可能会导致引发错误，如&lt;a href=&quot;datatype-json&quot;&gt;第8.14节所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7cd10805ee6287ed464e4a751e94e4711b1b75c0" translate="yes" xml:space="preserve">
          <source>Many of these functions have equivalent commands in the replication protocol; see &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt;.</source>
          <target state="translated">这些功能中的许多功能在复制协议中具有等效的命令。见&lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;52.4节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c9991bbe3c7f8082ad3aa4aa507145ca5c59d4fc" translate="yes" xml:space="preserve">
          <source>Many of these functions have equivalent commands in the replication protocol; see &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09d54c9e108446dcc126d9b9edd300bc8f018b7c" translate="yes" xml:space="preserve">
          <source>Many of these operations are only sensible for one-dimensional arrays. Although they will accept input arrays of more dimensions, the data is treated as though it were a linear array in storage order.</source>
          <target state="translated">其中许多操作只对一维数组有意义。虽然它们会接受更多维度的输入数组,但数据会被当作一个线性数组按存储顺序处理。</target>
        </trans-unit>
        <trans-unit id="747ffafd1658c72a0cfd879c2f486677fdad72db" translate="yes" xml:space="preserve">
          <source>Many people choose to use scripts to define their &lt;code&gt;archive_command&lt;/code&gt;, so that their &lt;code&gt;postgresql.conf&lt;/code&gt; entry looks very simple:</source>
          <target state="translated">许多人选择使用脚本来定义自己的 &lt;code&gt;archive_command&lt;/code&gt; ，因此他们的 &lt;code&gt;postgresql.conf&lt;/code&gt; 条目看起来非常简单：</target>
        </trans-unit>
        <trans-unit id="871adaf8d8928b9b6cb8b32ef8db751f5c6cf9e4" translate="yes" xml:space="preserve">
          <source>Many programs produce strange and occasionally perverse CSV files, so the file format is more a convention than a standard. Thus you might encounter some files that cannot be imported using this mechanism, and &lt;code&gt;COPY&lt;/code&gt; might produce files that other programs cannot process.</source>
          <target state="translated">许多程序会生成奇怪的，偶尔会变态的CSV文件，因此文件格式更像是一种约定而非标准。因此，您可能会遇到一些无法使用此机制导入的文件，并且 &lt;code&gt;COPY&lt;/code&gt; 可能会生成其他程序无法处理的文件。</target>
        </trans-unit>
        <trans-unit id="c567b905d84b0a334ddbdf37ad683a15fc2dd4c4" translate="yes" xml:space="preserve">
          <source>Many routines are already defined within PostgreSQL itself, but user-defined ones can also be added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aced3527162bd0f606c70ff2d552cd6071f17c5f" translate="yes" xml:space="preserve">
          <source>Many users consider it good practice to always list the column names.</source>
          <target state="translated">许多用户认为好的做法是总是列出列名。</target>
        </trans-unit>
        <trans-unit id="9e8ae0f81b2286e5d586c06978958263d9a26d81" translate="yes" xml:space="preserve">
          <source>Map different variations of a word to a canonical form using Snowball stemmer rules.</source>
          <target state="translated">使用雪球词干规则将一个词的不同变体映射到一个规范形式。</target>
        </trans-unit>
        <trans-unit id="8d7f24aaf39a33003cb1dd2dcc4e2ba52ecca563" translate="yes" xml:space="preserve">
          <source>Map different variations of a word to a canonical form using an Ispell dictionary.</source>
          <target state="translated">使用Ispell词典将一个词的不同变体映射到一个规范形式。</target>
        </trans-unit>
        <trans-unit id="7153d307c4a8dd126f6b081d2a4d9f2c3be33e38" translate="yes" xml:space="preserve">
          <source>Map phrases to a single word using a thesaurus.</source>
          <target state="translated">使用词库将短语映射到单字。</target>
        </trans-unit>
        <trans-unit id="9b24aee355a7838c5529c7490a65bac5367e010b" translate="yes" xml:space="preserve">
          <source>Map synonyms to a single word using Ispell.</source>
          <target state="translated">使用Ispell将同义词映射到单个单词。</target>
        </trans-unit>
        <trans-unit id="c4ba0822462e0c373aadd5360a69f205c2a7d036" translate="yes" xml:space="preserve">
          <source>Mar</source>
          <target state="translated">Mar</target>
        </trans-unit>
        <trans-unit id="433632ea5cd64cd163c3a390d5e531d33da3c5e5" translate="yes" xml:space="preserve">
          <source>March</source>
          <target state="translated">March</target>
        </trans-unit>
        <trans-unit id="531a1c0bf44a83aa6422d943626b2d77d47c5593" translate="yes" xml:space="preserve">
          <source>Mark Kirkwood &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:markir@paradise.net.nz&quot;&gt;markir@paradise.net.nz&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">马克&amp;middot;柯克伍德 &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:markir@paradise.net.nz&quot;&gt;markir@paradise.net.nz&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b50963c78fd5ba0ee384ff4f9865fdb85cbddcd7" translate="yes" xml:space="preserve">
          <source>Mark a column as allowing, or not allowing, null values.</source>
          <target state="translated">将一列标记为允许或不允许空值。</target>
        </trans-unit>
        <trans-unit id="45379fe0fd98739ca8b200f2546c07f11e0483e4" translate="yes" xml:space="preserve">
          <source>Mark current scan position. The access method need only support one remembered scan position per scan.</source>
          <target state="translated">标记当前扫描位置。该访问方式每次扫描只需支持一个记忆的扫描位置。</target>
        </trans-unit>
        <trans-unit id="d89c04496b47c6c7add6d623e145d05e0e90beea" translate="yes" xml:space="preserve">
          <source>Mark the current session as replaying from the given origin, allowing replay progress to be tracked. Use &lt;code&gt;pg_replication_origin_session_reset&lt;/code&gt; to revert. Can only be used if no previous origin is configured.</source>
          <target state="translated">将当前会话标记为从给定的源进行重播，从而可以跟踪重播进度。使用 &lt;code&gt;pg_replication_origin_session_reset&lt;/code&gt; 还原。仅当未配置先前的来源时才可以使用。</target>
        </trans-unit>
        <trans-unit id="3c353ba22d4916c50376ffc56136935d3788b393" translate="yes" xml:space="preserve">
          <source>Mark the current transaction as replaying a transaction that has committed at the given LSN and timestamp. Can only be called when a replication origin has previously been configured using &lt;code&gt;pg_replication_origin_session_setup()&lt;/code&gt;.</source>
          <target state="translated">将当前事务标记为重播已在给定LSN和时间戳下提交的事务。仅当先前使用 &lt;code&gt;pg_replication_origin_session_setup()&lt;/code&gt; 配置了复制源时才可以调用。</target>
        </trans-unit>
        <trans-unit id="8026198ec726c859996827cb2a33d945433d7db7" translate="yes" xml:space="preserve">
          <source>Marko Kreen &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:markokr@gmail.com&quot;&gt;markokr@gmail.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Marko Kreen &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:markokr@gmail.com&quot;&gt;markokr@gmail.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a8a93296bb3f7dbd2119f15415d0d529e99efc9" translate="yes" xml:space="preserve">
          <source>Marks the current session as replaying from the given origin, allowing replay progress to be tracked. Can only be used if no origin is currently selected. Use &lt;code&gt;pg_replication_origin_session_reset&lt;/code&gt; to undo.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f934292a8f9bb0e504a2267c5d57828e046b931" translate="yes" xml:space="preserve">
          <source>Marks the current transaction as replaying a transaction that has committed at the given LSN and timestamp. Can only be called when a replication origin has been selected using &lt;code&gt;pg_replication_origin_session_setup&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a85793fe091f4b79ea4b1cbe55645a43cdb25119" translate="yes" xml:space="preserve">
          <source>Marks the publication as one that replicates changes for all tables in the database, including tables created in the future.</source>
          <target state="translated">标记该发布为复制数据库中所有表的更改,包括未来创建的表。</target>
        </trans-unit>
        <trans-unit id="48783f4e8092ded2db7efb72ccd9468e6f9f40fe" translate="yes" xml:space="preserve">
          <source>Master (server)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbea724ab0ab5100a69e78a28b57720c1d6712f2" translate="yes" xml:space="preserve">
          <source>Master failure will never lose data</source>
          <target state="translated">主故障永远不会丢失数据</target>
        </trans-unit>
        <trans-unit id="b17d5df13d0871fd4cf3c5923d856a866da06d96" translate="yes" xml:space="preserve">
          <source>Match the specified columns' values against the null string, even if it has been quoted, and if a match is found set the value to &lt;code&gt;NULL&lt;/code&gt;. In the default case where the null string is empty, this converts a quoted empty string into NULL. This option is allowed only in &lt;code&gt;COPY FROM&lt;/code&gt;, and only when using &lt;code&gt;CSV&lt;/code&gt; format.</source>
          <target state="translated">将指定列的值与null字符串进行匹配，即使已将其引用，也可以将其设置为 &lt;code&gt;NULL&lt;/code&gt; 。在空字符串为空的默认情况下，这会将带引号的空字符串转换为NULL。仅在 &lt;code&gt;COPY FROM&lt;/code&gt; 中和使用 &lt;code&gt;CSV&lt;/code&gt; 格式时才允许使用此选项。</target>
        </trans-unit>
        <trans-unit id="ee2dbd5d6d82d0833069b07e7dd2848d3bf4d83a" translate="yes" xml:space="preserve">
          <source>Matches</source>
          <target state="translated">Matches</target>
        </trans-unit>
        <trans-unit id="53d751384b810e580b81b6af15ea342f4112abe1" translate="yes" xml:space="preserve">
          <source>Matches regular expression, case insensitive</source>
          <target state="translated">匹配正则表达式,不区分大小写</target>
        </trans-unit>
        <trans-unit id="50df7b2381b68eae63b34b5f24c7004fae5bf76b" translate="yes" xml:space="preserve">
          <source>Matches regular expression, case sensitive</source>
          <target state="translated">匹配正则表达式,区分大小写</target>
        </trans-unit>
        <trans-unit id="fccd01d6aebb595ebe777cc128bfd2f8fc6bb331" translate="yes" xml:space="preserve">
          <source>Materialized</source>
          <target state="translated">Materialized</target>
        </trans-unit>
        <trans-unit id="6c6539b1b3ecdc0ce5fd2e28965f4dde400d5218" translate="yes" xml:space="preserve">
          <source>Materialized view (relation)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7844bff419f63af9d9cad339e25621693c32f323" translate="yes" xml:space="preserve">
          <source>Materialized view definition (a reconstructed &lt;code&gt;SELECT&lt;/code&gt; query)</source>
          <target state="translated">物化视图定义（重建的 &lt;code&gt;SELECT&lt;/code&gt; 查询）</target>
        </trans-unit>
        <trans-unit id="1636e8b4d786c74d148e1a7dc19345ad47a2c025" translate="yes" xml:space="preserve">
          <source>Mathematical operators are provided for many PostgreSQL types. For types without standard mathematical conventions (e.g., date/time types) we describe the actual behavior in subsequent sections.</source>
          <target state="translated">许多PostgreSQL类型都提供了数学运算符。对于没有标准数学约定的类型(例如,日期/时间类型),我们将在后续章节中描述实际行为。</target>
        </trans-unit>
        <trans-unit id="1001c24f338845a2ebfc01ab0741f854faa1aca1" translate="yes" xml:space="preserve">
          <source>Mathematical:  / 2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3d70e9435a7845b6f93f885d627357ee254fe09" translate="yes" xml:space="preserve">
          <source>Mathematical: !</source>
          <target state="translated">数学:!</target>
        </trans-unit>
        <trans-unit id="fdaf7cc1ab57d2149690173f829e4f0c4dd36551" translate="yes" xml:space="preserve">
          <source>Mathematical: !!</source>
          <target state="translated">数学:!</target>
        </trans-unit>
        <trans-unit id="5e2823abc00a4631871d8a38e715d143884de402" translate="yes" xml:space="preserve">
          <source>Mathematical: !! 5</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5aaa56c60d256db29a89bc57b92703c0f7cb305" translate="yes" xml:space="preserve">
          <source>Mathematical: #</source>
          <target state="translated">数学。#</target>
        </trans-unit>
        <trans-unit id="181ffc47f204d3f9ba3ff486f0f30c0c0ef1d5b9" translate="yes" xml:space="preserve">
          <source>Mathematical: %</source>
          <target state="translated">数学:%</target>
        </trans-unit>
        <trans-unit id="ab7340ae469c4484dcc6f33a45b64f2dbe2c6ff3" translate="yes" xml:space="preserve">
          <source>Mathematical: &amp;amp;</source>
          <target state="translated">数学：＆</target>
        </trans-unit>
        <trans-unit id="c195fef9b5d30c42138e890a55d18aa8f3e74af3" translate="yes" xml:space="preserve">
          <source>Mathematical: &amp;gt;&amp;gt;</source>
          <target state="translated">数学：&amp;gt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="14a14395161c1fa4a496e90e3da92831d4e7dcdb" translate="yes" xml:space="preserve">
          <source>Mathematical: &amp;lt;&amp;lt;</source>
          <target state="translated">数学的：&amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="ddb29852cc33e3b226c0621b50ee13e25c0315f2" translate="yes" xml:space="preserve">
          <source>Mathematical: *</source>
          <target state="translated">数学方面。*</target>
        </trans-unit>
        <trans-unit id="59ea67514b35bce8cb0c2fb98d96ab75e1042145" translate="yes" xml:space="preserve">
          <source>Mathematical: +</source>
          <target state="translated">数学:+</target>
        </trans-unit>
        <trans-unit id="573654821f774c0055526f71d6224f85263be0a1" translate="yes" xml:space="preserve">
          <source>Mathematical: + 3.5</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9634adf0f4c35060714ef3c74218c7741d96738c" translate="yes" xml:space="preserve">
          <source>Mathematical: -</source>
          <target state="translated">数学:-</target>
        </trans-unit>
        <trans-unit id="bc7be2afb633a5ef91761e59ad8b5a5f36c92a00" translate="yes" xml:space="preserve">
          <source>Mathematical: /</source>
          <target state="translated">数学。/</target>
        </trans-unit>
        <trans-unit id="14509827aaea9ada84591d506dac7b95163f05fb" translate="yes" xml:space="preserve">
          <source>Mathematical: 0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dcad53763c2d6ad82f715b19ab8fec7ddeae22b" translate="yes" xml:space="preserve">
          <source>Mathematical: 1 &amp;lt;&amp;lt; 4</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca7f29cf58cb7d77da0870ecda08106919ba5797" translate="yes" xml:space="preserve">
          <source>Mathematical: 17 # 5</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aba60cec6fd188d73cb4b2c6daf41d7e269b2755" translate="yes" xml:space="preserve">
          <source>Mathematical: 2 * 3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a09b3f64871c9fa59aafabb2d8aac651ddf945f1" translate="yes" xml:space="preserve">
          <source>Mathematical: 2 + 3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46a2737a7e89745b3ae76fb70bc9a67e72cce41a" translate="yes" xml:space="preserve">
          <source>Mathematical: 2 - 3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e4ae222002ab6c8851226d9e26b9eb6997461fb" translate="yes" xml:space="preserve">
          <source>Mathematical: 2 ^ 3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1453f807f48dca3215386cb463d776ee41b48c5" translate="yes" xml:space="preserve">
          <source>Mathematical: 2 ^ 3 ^ 3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0910b16e152e2fe676e014eac4265186a97fa07e" translate="yes" xml:space="preserve">
          <source>Mathematical: 32 | 3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7585f445437546f28802c19197028b4f366b5a52" translate="yes" xml:space="preserve">
          <source>Mathematical: 5 !</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b13db5517bdad3caace02ad3155beb1c731b5ca2" translate="yes" xml:space="preserve">
          <source>Mathematical: 5 % 4</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23a81ae0fa61623f6df83d0e9447d29d062d3a97" translate="yes" xml:space="preserve">
          <source>Mathematical: 5 / 2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4f45fa3de4c530e7fd6305fbfcd48feef5d74a8" translate="yes" xml:space="preserve">
          <source>Mathematical: 5.0 / 2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11e8ff6a5010dabe71633aac622636270030f6a1" translate="yes" xml:space="preserve">
          <source>Mathematical: 8 &amp;gt;&amp;gt; 2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1211cb8df037247151be58836d25635e55e30011" translate="yes" xml:space="preserve">
          <source>Mathematical: 91 &amp;amp; 15</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3196927fede8cfa3807fe6508ad4afd6a4dd5c10" translate="yes" xml:space="preserve">
          <source>Mathematical: @</source>
          <target state="translated">数学:@</target>
        </trans-unit>
        <trans-unit id="ae31f2afe49c847bd7b50bc7534ffe77332ef912" translate="yes" xml:space="preserve">
          <source>Mathematical: @ -5.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dadfd5f33c390a7d584396b6077f56229e94a33" translate="yes" xml:space="preserve">
          <source>Mathematical: ^</source>
          <target state="translated">数学。^</target>
        </trans-unit>
        <trans-unit id="20a199d0df7c3ce2a80fb78024a1d00c66d000a9" translate="yes" xml:space="preserve">
          <source>Mathematical: abs</source>
          <target state="translated">数学:abs</target>
        </trans-unit>
        <trans-unit id="df0e19fdb206e36a2205ad9d44520f7fee9d3470" translate="yes" xml:space="preserve">
          <source>Mathematical: acos</source>
          <target state="translated">数学:acos</target>
        </trans-unit>
        <trans-unit id="f1cae65774f5f13f2e415042ed98b64f1dc67f0f" translate="yes" xml:space="preserve">
          <source>Mathematical: acosd</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f713fa364b0d2333d09caea3c059cdf323feaaae" translate="yes" xml:space="preserve">
          <source>Mathematical: acosh</source>
          <target state="translated">数学:acosh</target>
        </trans-unit>
        <trans-unit id="15392ccce532b37463508b07d4825a05d6fb2837" translate="yes" xml:space="preserve">
          <source>Mathematical: asin</source>
          <target state="translated">数学:亚信</target>
        </trans-unit>
        <trans-unit id="4629299dfc93830669825b7184510d53113981f0" translate="yes" xml:space="preserve">
          <source>Mathematical: asind</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fe074bf9a455acf4922429fcb4f7cd46c3c843a" translate="yes" xml:space="preserve">
          <source>Mathematical: asinh</source>
          <target state="translated">数学:asinh</target>
        </trans-unit>
        <trans-unit id="83a2bb5d54e23969b5a04d6c088114146c9dc45d" translate="yes" xml:space="preserve">
          <source>Mathematical: atan</source>
          <target state="translated">数学:阿坦</target>
        </trans-unit>
        <trans-unit id="c731e727bd85d0cc74cb9191f3962ed11a8f3b3b" translate="yes" xml:space="preserve">
          <source>Mathematical: atan2</source>
          <target state="translated">数学:atan2</target>
        </trans-unit>
        <trans-unit id="5b918761ab75eba1fab60d1e4fd5336ac01d2bf8" translate="yes" xml:space="preserve">
          <source>Mathematical: atan2d</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a929d56a5b59eb4bc6c164cae3d9675502095c0e" translate="yes" xml:space="preserve">
          <source>Mathematical: atand</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="583724a9264d7b0976ad47dcd14d4ac28456738f" translate="yes" xml:space="preserve">
          <source>Mathematical: atanh</source>
          <target state="translated">数学:atanh</target>
        </trans-unit>
        <trans-unit id="177cd0bc699b2203fdf2d4c75fe30163594d7b7e" translate="yes" xml:space="preserve">
          <source>Mathematical: cbrt</source>
          <target state="translated">数学:cbrt</target>
        </trans-unit>
        <trans-unit id="2693815a9d6a69c69854809a47650e0275c1e989" translate="yes" xml:space="preserve">
          <source>Mathematical: ceil</source>
          <target state="translated">数学:天花板</target>
        </trans-unit>
        <trans-unit id="d952c9a3323ba3a0a0aaeb01f24cc8dfd99821d9" translate="yes" xml:space="preserve">
          <source>Mathematical: ceiling</source>
          <target state="translated">数学:上限</target>
        </trans-unit>
        <trans-unit id="9db09acf97836fbc07512e622eb6635d3a02dc78" translate="yes" xml:space="preserve">
          <source>Mathematical: cos</source>
          <target state="translated">数学:cos</target>
        </trans-unit>
        <trans-unit id="85e771e6ddf496ad7e9555f4d093d90654ec2a2a" translate="yes" xml:space="preserve">
          <source>Mathematical: cosd</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae9e7e216cc8b38acc3988effacc0b9c9f145f6e" translate="yes" xml:space="preserve">
          <source>Mathematical: cosh</source>
          <target state="translated">数学:cosh</target>
        </trans-unit>
        <trans-unit id="6bd28a5aa54b3401f41f88e5856f7384f5d30c00" translate="yes" xml:space="preserve">
          <source>Mathematical: cot</source>
          <target state="translated">数学:cot</target>
        </trans-unit>
        <trans-unit id="e063ca4c3718afe3730ed0658e8574f03540c88a" translate="yes" xml:space="preserve">
          <source>Mathematical: cotd</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18ccdbc8bc11a04cc3a6bf245df208da8e2cae56" translate="yes" xml:space="preserve">
          <source>Mathematical: degrees</source>
          <target state="translated">数学:度</target>
        </trans-unit>
        <trans-unit id="aca19fd89939c16cdb0569b07e58a53ad9349a7b" translate="yes" xml:space="preserve">
          <source>Mathematical: div</source>
          <target state="translated">数学:div</target>
        </trans-unit>
        <trans-unit id="8af560e7bf42dc0411068f58a59ae9f72df77793" translate="yes" xml:space="preserve">
          <source>Mathematical: e</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e46d6487f521a5afb4ed4dd6a23a59fc059e6e5" translate="yes" xml:space="preserve">
          <source>Mathematical: exp</source>
          <target state="translated">数学:exp</target>
        </trans-unit>
        <trans-unit id="5d515a5291a2aa6b90f086dc95105de6456c2b72" translate="yes" xml:space="preserve">
          <source>Mathematical: factorial</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="573fe26c7738f0584a8c6cbc5489e02fe641fddb" translate="yes" xml:space="preserve">
          <source>Mathematical: floor</source>
          <target state="translated">数学:地板</target>
        </trans-unit>
        <trans-unit id="0875b243f27c954dcb0311da83af45540779329c" translate="yes" xml:space="preserve">
          <source>Mathematical: gcd</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="585a4c28147c569040ed981c6a2b550fc5404fd3" translate="yes" xml:space="preserve">
          <source>Mathematical: lcm</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="402d0cd4fdb985e3812799945b9fceb07540a0b6" translate="yes" xml:space="preserve">
          <source>Mathematical: ln</source>
          <target state="translated">数学:ln</target>
        </trans-unit>
        <trans-unit id="85d8f0757c4bc05932d8f5d5e562c9da71c34f89" translate="yes" xml:space="preserve">
          <source>Mathematical: log</source>
          <target state="translated">数学:对数</target>
        </trans-unit>
        <trans-unit id="c83ba153e80e1ad83154d81618c218abe75464e9" translate="yes" xml:space="preserve">
          <source>Mathematical: log10</source>
          <target state="translated">数学:对数10</target>
        </trans-unit>
        <trans-unit id="b72fa934be334bbd661a4dd4724fb9f4f43c1c9b" translate="yes" xml:space="preserve">
          <source>Mathematical: min_scale</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="342c1a68d26670cf3f8565a0897aa5cb7ba34b4e" translate="yes" xml:space="preserve">
          <source>Mathematical: mod</source>
          <target state="translated">数学:模数</target>
        </trans-unit>
        <trans-unit id="1c34dfef32b83a1764b863b4bbe019d5862c9c11" translate="yes" xml:space="preserve">
          <source>Mathematical: pi</source>
          <target state="translated">数学:圆周率</target>
        </trans-unit>
        <trans-unit id="886814dcb54a703998bbc0cf8f2f8499a7b62fa5" translate="yes" xml:space="preserve">
          <source>Mathematical: power</source>
          <target state="translated">数学:功率</target>
        </trans-unit>
        <trans-unit id="256f270ce3f202545798a4267069da319d55bdce" translate="yes" xml:space="preserve">
          <source>Mathematical: radians</source>
          <target state="translated">数学:弧度</target>
        </trans-unit>
        <trans-unit id="fa28188b7b4ce61e7fd1e57eb3d3850d1782d895" translate="yes" xml:space="preserve">
          <source>Mathematical: random</source>
          <target state="translated">数学:随机</target>
        </trans-unit>
        <trans-unit id="38618634f79b9464f7b75f0213cc7c4516883f3f" translate="yes" xml:space="preserve">
          <source>Mathematical: round</source>
          <target state="translated">数学:圆形</target>
        </trans-unit>
        <trans-unit id="d57a36e95bfa64f5eb46d773fdde749c2cb84fc4" translate="yes" xml:space="preserve">
          <source>Mathematical: scale</source>
          <target state="translated">数学:比例尺</target>
        </trans-unit>
        <trans-unit id="bf096078393c2c98a0b1e6c717f74e687f878163" translate="yes" xml:space="preserve">
          <source>Mathematical: setseed</source>
          <target state="translated">数学:种子</target>
        </trans-unit>
        <trans-unit id="39f4ee6bf2c1ebbb6d092ca5116d3c60ea228290" translate="yes" xml:space="preserve">
          <source>Mathematical: sign</source>
          <target state="translated">数学:符号</target>
        </trans-unit>
        <trans-unit id="21776ac559594087e48aa9a00b1065f77ca338fd" translate="yes" xml:space="preserve">
          <source>Mathematical: sin</source>
          <target state="translated">数学上的:sin</target>
        </trans-unit>
        <trans-unit id="e9237291333d54a9e72bd4303ce991cb654f9866" translate="yes" xml:space="preserve">
          <source>Mathematical: sind</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00e2992e6f676f0cd18285a72f0c1e9d55b0d240" translate="yes" xml:space="preserve">
          <source>Mathematical: sinh</source>
          <target state="translated">数学:Sinh</target>
        </trans-unit>
        <trans-unit id="aae7a6e9b70d02f4e993a9db74c8db3083ef0bfc" translate="yes" xml:space="preserve">
          <source>Mathematical: sqrt</source>
          <target state="translated">数学:平方</target>
        </trans-unit>
        <trans-unit id="02a3ee3cf42cf2113efd88c1ad458433f9a69197" translate="yes" xml:space="preserve">
          <source>Mathematical: tan</source>
          <target state="translated">数学:tan</target>
        </trans-unit>
        <trans-unit id="a12d29e8482347b79de73aeb0357bed2e637f2fc" translate="yes" xml:space="preserve">
          <source>Mathematical: tand</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43ac9c6f98336e23241f94c577f53cb99b066801" translate="yes" xml:space="preserve">
          <source>Mathematical: tanh</source>
          <target state="translated">数学:丹赫</target>
        </trans-unit>
        <trans-unit id="4cead06e1e3ecd61366e9c73534c51a69696eb50" translate="yes" xml:space="preserve">
          <source>Mathematical: trim_scale</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd05d42d41de6870056e68c4ccd289ca842197c7" translate="yes" xml:space="preserve">
          <source>Mathematical: trunc</source>
          <target state="translated">数学:截断</target>
        </trans-unit>
        <trans-unit id="b3fcfe03e83f0fd3f41685d5a0a35fa941c16d42" translate="yes" xml:space="preserve">
          <source>Mathematical: width_bucket</source>
          <target state="translated">数学:width_bucket</target>
        </trans-unit>
        <trans-unit id="102ae47fccbd9d1f7766efee6bfebf34706bb020" translate="yes" xml:space="preserve">
          <source>Mathematical: width_bucket, array::timestamptz)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfa1e770f800f341e62dbc76cea5befa40e67f50" translate="yes" xml:space="preserve">
          <source>Mathematical: |</source>
          <target state="translated">数学。|</target>
        </trans-unit>
        <trans-unit id="b18f08aa2ba95d26e5185b6a71ed15ce174e5b8f" translate="yes" xml:space="preserve">
          <source>Mathematical: |/</source>
          <target state="translated">数学。|/</target>
        </trans-unit>
        <trans-unit id="b1d8eaf643a6e6b2e7be95b78f55ac71c3eeed5c" translate="yes" xml:space="preserve">
          <source>Mathematical: |/ 25.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51e150fa17498f246e415139012baeb22d8f4d4a" translate="yes" xml:space="preserve">
          <source>Mathematical: ||/</source>
          <target state="translated">数学。||/</target>
        </trans-unit>
        <trans-unit id="6da4178d25c27664a5aeecdd5149efed87a71eaa" translate="yes" xml:space="preserve">
          <source>Mathematical: ||/ 64.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eacd2f34aae3951141d12b3b8bacb1b57ee7e7b" translate="yes" xml:space="preserve">
          <source>Mathematical: ~</source>
          <target state="translated">数学:~</target>
        </trans-unit>
        <trans-unit id="28cbee48973403ffe3820780daffa38b195ca4b1" translate="yes" xml:space="preserve">
          <source>Mathematical: ~1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a95e85aed56318093b024674e217cae0bd30241d" translate="yes" xml:space="preserve">
          <source>Max</source>
          <target state="translated">Max</target>
        </trans-unit>
        <trans-unit id="eebfdb589d2a38f34e9a5e134f62af1ef891433d" translate="yes" xml:space="preserve">
          <source>Max Password Length</source>
          <target state="translated">最大密码长度</target>
        </trans-unit>
        <trans-unit id="462156397b99eeccfdb0f5b4ea63ec4407a809bc" translate="yes" xml:space="preserve">
          <source>Maximum allowed value of the parameter (null for non-numeric values)</source>
          <target state="translated">参数的最大允许值(非数字值为空)。</target>
        </trans-unit>
        <trans-unit id="f4c49a25b4f19cb0213949aa3e28ef3557be3a93" translate="yes" xml:space="preserve">
          <source>Maximum amount of time allowed to complete client authentication. If a would-be client has not completed the authentication protocol in this much time, the server closes the connection. This prevents hung clients from occupying a connection indefinitely. If this value is specified without units, it is taken as seconds. The default is one minute (&lt;code&gt;1m&lt;/code&gt;). This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">完成客户端身份验证所允许的最长时间。如果准客户在这段时间内没有完成身份验证协议，则服务器将关闭连接。这样可以防止挂起的客户端无限期占用连接。如果指定的该值不带单位，则以秒为单位。默认值为一分钟（ &lt;code&gt;1m&lt;/code&gt; ）。该参数只能在 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件或服务器命令行中设置。</target>
        </trans-unit>
        <trans-unit id="16d4343ca4b0ff10b386fabaeb90ec48c83feb93" translate="yes" xml:space="preserve">
          <source>Maximum depth to descend to, or zero for unlimited depth</source>
          <target state="translated">下降到的最大深度,如果是无限制的深度,则为零。</target>
        </trans-unit>
        <trans-unit id="6e382e12a5004b51a9fb6db4c19fb4ad8b8e10a3" translate="yes" xml:space="preserve">
          <source>Maximum number of semaphore identifiers (i.e., sets)</source>
          <target state="translated">旗语标识符的最大数量(即集合)</target>
        </trans-unit>
        <trans-unit id="0c59e3da96b0612eb2065c185976ccb89f3be9d6" translate="yes" xml:space="preserve">
          <source>Maximum number of semaphores per set</source>
          <target state="translated">每组信号词的最大数量</target>
        </trans-unit>
        <trans-unit id="352ff6e41f28fb4dd9615ad5c6b893bc2f0820a2" translate="yes" xml:space="preserve">
          <source>Maximum number of semaphores system-wide</source>
          <target state="translated">全系统最大信号灯数量</target>
        </trans-unit>
        <trans-unit id="c815c1aa92e98505761f17e71fb912e2b0d50481" translate="yes" xml:space="preserve">
          <source>Maximum number of shared memory segments per process</source>
          <target state="translated">每个进程的最大共享内存段数</target>
        </trans-unit>
        <trans-unit id="f5eb5768d25d1069e687fbff6c4cdff705aae7ad" translate="yes" xml:space="preserve">
          <source>Maximum number of shared memory segments system-wide</source>
          <target state="translated">全系统共享内存段的最大数量</target>
        </trans-unit>
        <trans-unit id="e4a5cf08c55be90a96549a51c4d65339bafeb337" translate="yes" xml:space="preserve">
          <source>Maximum number of synchronization workers per subscription. This parameter controls the amount of parallelism of the initial data copy during the subscription initialization or when new tables are added.</source>
          <target state="translated">每个订阅的最大同步工作者数量。该参数控制订阅初始化期间或添加新表时初始数据副本的并行量。</target>
        </trans-unit>
        <trans-unit id="cf9da86e68e4a7c2a1bc302b1edbdee46483b5d4" translate="yes" xml:space="preserve">
          <source>Maximum size of shared memory segment (bytes)</source>
          <target state="translated">共享内存段的最大大小(字节)</target>
        </trans-unit>
        <trans-unit id="3bc5354a68835f6648f33d79497a82c72e86de3c" translate="yes" xml:space="preserve">
          <source>Maximum size to let the WAL grow during automatic checkpoints. This is a soft limit; WAL size can exceed &lt;code&gt;max_wal_size&lt;/code&gt; under special circumstances, such as heavy load, a failing &lt;code&gt;archive_command&lt;/code&gt;, or a high &lt;code&gt;wal_keep_size&lt;/code&gt; setting. If this value is specified without units, it is taken as megabytes. The default is 1 GB. Increasing this parameter can increase the amount of time needed for crash recovery. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d78433a672e983d650938d0f8874ea0c01c8e279" translate="yes" xml:space="preserve">
          <source>Maximum size to let the WAL grow to between automatic WAL checkpoints. This is a soft limit; WAL size can exceed &lt;code&gt;max_wal_size&lt;/code&gt; under special circumstances, such as heavy load, a failing &lt;code&gt;archive_command&lt;/code&gt;, or a high &lt;code&gt;wal_keep_segments&lt;/code&gt; setting. If this value is specified without units, it is taken as megabytes. The default is 1 GB. Increasing this parameter can increase the amount of time needed for crash recovery. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">使WAL增长到自动WAL检查点之间的最大大小。这是一个软限制；在特殊情况下，例如高负载，失败的 &lt;code&gt;archive_command&lt;/code&gt; 或较高的 &lt;code&gt;wal_keep_segments&lt;/code&gt; 设置，WAL大小可以超过 &lt;code&gt;max_wal_size&lt;/code&gt; 。如果指定的该值不带单位，则以兆字节为单位。默认值为1 GB。增大此参数可能会增加崩溃恢复所需的时间。该参数只能在 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件或服务器命令行中设置。</target>
        </trans-unit>
        <trans-unit id="a6663cd5d04ec15d3d8cb068011883bb72c21769" translate="yes" xml:space="preserve">
          <source>Maximum time between automatic WAL checkpoints. If this value is specified without units, it is taken as seconds. The valid range is between 30 seconds and one day. The default is five minutes (&lt;code&gt;5min&lt;/code&gt;). Increasing this parameter can increase the amount of time needed for crash recovery. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">自动WAL检查点之间的最长时间。如果指定的该值不带单位，则以秒为单位。有效范围是30秒至1天。默认值为五分钟（ &lt;code&gt;5min&lt;/code&gt; ）。增大此参数可能会增加崩溃恢复所需的时间。该参数只能在 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件或服务器命令行中设置。</target>
        </trans-unit>
        <trans-unit id="a6f1ed8f82cbd62e299f9090b927f2f26026550f" translate="yes" xml:space="preserve">
          <source>Maximum time spent executing the statement, in milliseconds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4455b92ac909b4c5503624f3e50369ecbf4e7112" translate="yes" xml:space="preserve">
          <source>Maximum time spent in the statement, in milliseconds</source>
          <target state="translated">在声明中花费的最长时间,以毫秒为单位。</target>
        </trans-unit>
        <trans-unit id="80cb793c865edc2335fb8eab0406dd5a5723c352" translate="yes" xml:space="preserve">
          <source>Maximum time spent planning the statement, in milliseconds (if &lt;code&gt;pg_stat_statements.track_planning&lt;/code&gt; is enabled, otherwise zero)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e356bc07e535e04e9d9c3334c083fcc3488e0bee" translate="yes" xml:space="preserve">
          <source>Maximum value of semaphore</source>
          <target state="translated">旗语的最大值</target>
        </trans-unit>
        <trans-unit id="d73ff195380431a5bbd14d7218270378e35474ca" translate="yes" xml:space="preserve">
          <source>Maximum value of the sequence</source>
          <target state="translated">序列的最大值</target>
        </trans-unit>
        <trans-unit id="c94f479833c5d401cffdfa7afe6c9c2d56448019" translate="yes" xml:space="preserve">
          <source>May</source>
          <target state="translated">May</target>
        </trans-unit>
        <trans-unit id="9a0ffa2f24694ff69c95e89a55aa229e9cda8b30" translate="yes" xml:space="preserve">
          <source>Mean time spent executing the statement, in milliseconds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="181d211e960e06792dfe28bfac1abd601a4c5a9d" translate="yes" xml:space="preserve">
          <source>Mean time spent in the statement, in milliseconds</source>
          <target state="translated">平均发言时间(毫秒)</target>
        </trans-unit>
        <trans-unit id="e1349b1d8078a8f519127952739b8b28f7e70925" translate="yes" xml:space="preserve">
          <source>Mean time spent planning the statement, in milliseconds (if &lt;code&gt;pg_stat_statements.track_planning&lt;/code&gt; is enabled, otherwise zero)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="f0f833c6521b2d19b94ba8d0789e74dc9ccb5388" translate="yes" xml:space="preserve">
          <source>Measuring Executor Timing Overhead</source>
          <target state="translated">测量执行器的时间开销</target>
        </trans-unit>
        <trans-unit id="1c83efb5aa232017e707b79cbf793fdfcf4c42d0" translate="yes" xml:space="preserve">
          <source>Member accessor that returns an object member with the specified key. If the key name is a named variable starting with &lt;code&gt;$&lt;/code&gt; or does not meet the JavaScript rules of an identifier, it must be enclosed in double quotes as a character string literal.</source>
          <target state="translated">返回具有指定键的对象成员的成员访问器。如果键名是一个以 &lt;code&gt;$&lt;/code&gt; 开头的命名变量，或者不符合标识符的JavaScript规则，则必须将双引号括起来作为字符串文字。</target>
        </trans-unit>
        <trans-unit id="016eb9bcfce0ff8bda70ffdf100d2c6f5e38a6fe" translate="yes" xml:space="preserve">
          <source>Member accessor that returns an object member with the specified key. If the key name matches some named variable starting with &lt;code&gt;$&lt;/code&gt; or does not meet the JavaScript rules for an identifier, it must be enclosed in double quotes to make it a string literal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc3e8f88c1e4c9777ada8c4e159672ef60421a6a" translate="yes" xml:space="preserve">
          <source>Merge join requires its input data to be sorted on the join keys. In this plan the &lt;code&gt;tenk1&lt;/code&gt; data is sorted by using an index scan to visit the rows in the correct order, but a sequential scan and sort is preferred for &lt;code&gt;onek&lt;/code&gt;, because there are many more rows to be visited in that table. (Sequential-scan-and-sort frequently beats an index scan for sorting many rows, because of the nonsequential disk access required by the index scan.)</source>
          <target state="translated">合并联接要求其输入数据在联接键上进行排序。在此计划中， &lt;code&gt;tenk1&lt;/code&gt; 数据通过使用索引扫描排序以按正确的顺序访问行，但是 &lt;code&gt;onek&lt;/code&gt; 最好使用顺序扫描和排序，因为该表中还有许多行要访问。 （由于索引扫描需要非顺序的磁盘访问，因此顺序扫描和排序经常胜过索引扫描以对许多行进行排序。）</target>
        </trans-unit>
        <trans-unit id="5df467aa951005c5f7e89731194b036d002c4227" translate="yes" xml:space="preserve">
          <source>Merge joins also have measurement artifacts that can confuse the unwary. A merge join will stop reading one input if it's exhausted the other input and the next key value in the one input is greater than the last key value of the other input; in such a case there can be no more matches and so no need to scan the rest of the first input. This results in not reading all of one child, with results like those mentioned for &lt;code&gt;LIMIT&lt;/code&gt;. Also, if the outer (first) child contains rows with duplicate key values, the inner (second) child is backed up and rescanned for the portion of its rows matching that key value. &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; counts these repeated emissions of the same inner rows as if they were real additional rows. When there are many outer duplicates, the reported actual row count for the inner child plan node can be significantly larger than the number of rows that are actually in the inner relation.</source>
          <target state="translated">合并联接还具有度量工件，可能会使粗心的人感到困惑。如果合并联接用尽了另一个输入，并且一个输入中的下一个键值大于另一个输入的最后一个键值，则合并联接将停止读取。在这种情况下，将不再有匹配项，因此无需扫描其余的第一个输入。这导致不读取一个孩子的全部，结果类似于 &lt;code&gt;LIMIT&lt;/code&gt; 所述。同样，如果外部（第一个）子项包含具有重复键值的行，则将备份内部（第二个）子项并对其与该键值匹配的行部分进行重新扫描。 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 计算相同内部行的这些重复发射，就好像它们是实际的其他行一样。当有很多外部重复项时，内部子计划节点的报告的实际行数可能大大大于内部关系中实际存在的行数。</target>
        </trans-unit>
        <trans-unit id="7a6317b9601e7c09c328490aa43dfe87e04fe54d" translate="yes" xml:space="preserve">
          <source>Messages like this indicate that you contacted the server, and it is willing to talk to you, but not until you pass the authorization method specified in the &lt;code&gt;pg_hba.conf&lt;/code&gt; file. Check the password you are providing, or check your Kerberos or ident software if the complaint mentions one of those authentication types.</source>
          <target state="translated">诸如此类的消息表明您已与服务器联系，并且愿意与您联系，但是直到您通过 &lt;code&gt;pg_hba.conf&lt;/code&gt; 文件中指定的授权方法后，它才愿意与您联系。检查您提供的密码，或者如果投诉中提到其中一种身份验证类型，则检查Kerberos或ident软件。</target>
        </trans-unit>
        <trans-unit id="9c2097f911138f2466e5f32e8351dcd5fd749692" translate="yes" xml:space="preserve">
          <source>Meta-Commands</source>
          <target state="translated">Meta-Commands</target>
        </trans-unit>
        <trans-unit id="f693f5960d30f7053e205f6d9a4425df858962e1" translate="yes" xml:space="preserve">
          <source>Metaphone, like Soundex, is based on the idea of constructing a representative code for an input string. Two strings are then deemed similar if they have the same codes.</source>
          <target state="translated">Metaphone和Soundex一样,是基于为一个输入字符串构建一个代表代码的想法。如果两个字符串具有相同的代码,则认为它们是相似的。</target>
        </trans-unit>
        <trans-unit id="e1c1b37b805340abcc2257db6a661352b683548e" translate="yes" xml:space="preserve">
          <source>Method used for forcing WAL updates out to disk. If &lt;code&gt;fsync&lt;/code&gt; is off then this setting is irrelevant, since WAL file updates will not be forced out at all. Possible values are:</source>
          <target state="translated">强制将WAL更新输出到磁盘的方法。如果 &lt;code&gt;fsync&lt;/code&gt; 关闭，则此设置无关紧要，因为根本不会强行退出WAL文件更新。可能的值为：</target>
        </trans-unit>
        <trans-unit id="628dc441c2bafa1afab14e359fb44c6e901b8f85" translate="yes" xml:space="preserve">
          <source>Michael J. Fromberger</source>
          <target state="translated">Michael J.Fromberger</target>
        </trans-unit>
        <trans-unit id="06fca8ee037d3a593497ab6d139577328dd86787" translate="yes" xml:space="preserve">
          <source>Microsoft Visual C</source>
          <target state="translated">Microsoft Visual C</target>
        </trans-unit>
        <trans-unit id="f0e91d657447be038c5b83745dffb09499d6baf9" translate="yes" xml:space="preserve">
          <source>Military abbreviation for UTC</source>
          <target state="translated">UTC的军事缩写</target>
        </trans-unit>
        <trans-unit id="7eb0cee888ab55b559592d38eec027e9118d7d35" translate="yes" xml:space="preserve">
          <source>Min</source>
          <target state="translated">Min</target>
        </trans-unit>
        <trans-unit id="0d47fa8c3e389b0763d87f2daa4ec6a50fb18dc1" translate="yes" xml:space="preserve">
          <source>Minimum allowed value of the parameter (null for non-numeric values)</source>
          <target state="translated">参数的最小允许值(非数字值为空)。</target>
        </trans-unit>
        <trans-unit id="c5ae78e276525910ef27ff7ddf6b5c2559e2cb00" translate="yes" xml:space="preserve">
          <source>Minimum number of concurrent open transactions to require before performing the &lt;code&gt;commit_delay&lt;/code&gt; delay. A larger value makes it more probable that at least one other transaction will become ready to commit during the delay interval. The default is five transactions.</source>
          <target state="translated">执行 &lt;code&gt;commit_delay&lt;/code&gt; 延迟之前需要的最小并发打开事务数。较大的值使至少一个其他事务在延迟间隔内更有可能准备提交。默认值为五个事务。</target>
        </trans-unit>
        <trans-unit id="0fb2ca68f01f33cc64d2c1311c2afe2326caa75d" translate="yes" xml:space="preserve">
          <source>Minimum scale (number of fractional decimal digits) needed to represent the supplied value precisely</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c373999e365b4d5993611993a45677502343dcde" translate="yes" xml:space="preserve">
          <source>Minimum size of shared memory segment (bytes)</source>
          <target state="translated">共享内存段的最小尺寸(字节)</target>
        </trans-unit>
        <trans-unit id="78afeaf9c6ff0f3ee6d2c5532d4ad21e157dee73" translate="yes" xml:space="preserve">
          <source>Minimum time spent executing the statement, in milliseconds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="613154c6477db737a4ffc935d45b4f35e3a112f3" translate="yes" xml:space="preserve">
          <source>Minimum time spent in the statement, in milliseconds</source>
          <target state="translated">在声明中花费的最少时间,以毫秒为单位。</target>
        </trans-unit>
        <trans-unit id="f3052f7c6782d78980f79d735a2525db3585b208" translate="yes" xml:space="preserve">
          <source>Minimum time spent planning the statement, in milliseconds (if &lt;code&gt;pg_stat_statements.track_planning&lt;/code&gt; is enabled, otherwise zero)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9119800734f587e7d9508436d6ce2f949b6a319c" translate="yes" xml:space="preserve">
          <source>Minimum value of the sequence</source>
          <target state="translated">序列的最小值</target>
        </trans-unit>
        <trans-unit id="f39b9975fa394daf9211460e65ad5e53c2e0737a" translate="yes" xml:space="preserve">
          <source>Minor releases never change the internal storage format and are always compatible with earlier and later minor releases of the same major version number. For example, version 10.1 is compatible with version 10.0 and version 10.6. Similarly, for example, 9.5.3 is compatible with 9.5.0, 9.5.1, and 9.5.6. To update between compatible versions, you simply replace the executables while the server is down and restart the server. The data directory remains unchanged &amp;mdash; minor upgrades are that simple.</source>
          <target state="translated">次要版本永远不会更改内部存储格式，并且始终与相同主版本号的早期和较晚次要版本兼容。例如，版本10.1与版本10.0和版本10.6兼容。类似地，例如，9.5.3与9.5.0、9.5.1和9.5.6兼容。要在兼容版本之间进行更新，只需在服务器关闭时替换可执行文件，然后重新启动服务器即可。数据目录保持不变-较小的升级就这么简单。</target>
        </trans-unit>
        <trans-unit id="c1792a6389bbff158897922be21e2febd6b41e73" translate="yes" xml:space="preserve">
          <source>Minor updates to this package were made by Bruno Wolff III &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:bruno@wolff.to&quot;&gt;bruno@wolff.to&lt;/a&gt;&amp;gt;&lt;/code&gt; in August/September of 2002. These include changing the precision from single precision to double precision and adding some new functions.</source>
          <target state="translated">Bruno Wolff III &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:bruno@wolff.to&quot;&gt;bruno@wolff.to&lt;/a&gt;&amp;gt;&lt;/code&gt; 在2002年8月/ 9月对该软件包进行了较小的更新。这些更新包括将精度从单精度更改为双精度，并添加了一些新功能。</target>
        </trans-unit>
        <trans-unit id="026961d2894207df681418954ca48774a983ec15" translate="yes" xml:space="preserve">
          <source>Minus operator that iterates over the SQL/JSON sequence</source>
          <target state="translated">对SQL/JSON序列进行迭代的减号运算符。</target>
        </trans-unit>
        <trans-unit id="dc6ddd468d33fb3431787f38241bee7260f00eb6" translate="yes" xml:space="preserve">
          <source>Minutes (in the time part)</source>
          <target state="translated">分钟(时间部分)</target>
        </trans-unit>
        <trans-unit id="dc12f1b1cf6a0bbb2272d3d7ce2040c69a7ecda0" translate="yes" xml:space="preserve">
          <source>Mixed Interval</source>
          <target state="translated">混合区间</target>
        </trans-unit>
        <trans-unit id="70c257e1738553c63bcb8eca3e2dc0f60349ef49" translate="yes" xml:space="preserve">
          <source>Mixing temporary and permanent relations in the same partition tree is not allowed. Hence, if the partitioned table is permanent, so must be its partitions and likewise if the partitioned table is temporary. When using temporary relations, all members of the partition tree have to be from the same session.</source>
          <target state="translated">在同一个分区树中不允许混合临时和永久关系。因此,如果分区表是永久的,那么它的分区也必须是永久的,同样,如果分区表是临时的,也必须是临时的。当使用临时关系时,分区树的所有成员必须来自同一个会话。</target>
        </trans-unit>
        <trans-unit id="f260e757cec75096bc3eefbfb1c4a14720832017" translate="yes" xml:space="preserve">
          <source>Modifier</source>
          <target state="translated">Modifier</target>
        </trans-unit>
        <trans-unit id="b543d8b0cd27fd8c88c5dd290fcb9193a6d18588" translate="yes" xml:space="preserve">
          <source>Modifiers can be applied to any template pattern to alter its behavior. For example, &lt;code&gt;FMMonth&lt;/code&gt; is the &lt;code&gt;Month&lt;/code&gt; pattern with the &lt;code&gt;FM&lt;/code&gt; modifier. &lt;a href=&quot;functions-formatting#FUNCTIONS-FORMATTING-DATETIMEMOD-TABLE&quot;&gt;Table 9.26&lt;/a&gt; shows the modifier patterns for date/time formatting.</source>
          <target state="translated">可以将修饰符应用于任何模板模式以更改其行为。例如， &lt;code&gt;FMMonth&lt;/code&gt; 是带有 &lt;code&gt;FM&lt;/code&gt; 修改器的&amp;ldquo; &lt;code&gt;Month&lt;/code&gt; 模式。&lt;a href=&quot;functions-formatting#FUNCTIONS-FORMATTING-DATETIMEMOD-TABLE&quot;&gt;表9.26&lt;/a&gt;显示了日期/时间格式的修饰符模式。</target>
        </trans-unit>
        <trans-unit id="aa8e787d356e5a4bed4106486ef340d55a04bda6" translate="yes" xml:space="preserve">
          <source>Modifiers can be applied to any template pattern to alter its behavior. For example, &lt;code&gt;FMMonth&lt;/code&gt; is the &lt;code&gt;Month&lt;/code&gt; pattern with the &lt;code&gt;FM&lt;/code&gt; modifier. &lt;a href=&quot;functions-formatting#FUNCTIONS-FORMATTING-DATETIMEMOD-TABLE&quot;&gt;Table 9.27&lt;/a&gt; shows the modifier patterns for date/time formatting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca58f6edfb3451890686c36bc73c14bf67559162" translate="yes" xml:space="preserve">
          <source>Modify an existing record using the values from an &lt;code&gt;hstore&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;hstore&lt;/code&gt; 中的值修改现有记录：</target>
        </trans-unit>
        <trans-unit id="4f15aa8ca874492770383bfd8d9e19998f3752e1" translate="yes" xml:space="preserve">
          <source>Modifying Tables</source>
          <target state="translated">修改表格</target>
        </trans-unit>
        <trans-unit id="a72464d357e833dd19b1829bd5b00731edf82afe" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Adding a Column</source>
          <target state="translated">修改表格。添加列</target>
        </trans-unit>
        <trans-unit id="b0a82b15be32cf23af7a5403931cbba2c3a6b302" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Adding a Constraint</source>
          <target state="translated">修改表。添加一个约束条件</target>
        </trans-unit>
        <trans-unit id="8c76fff9cefc32ac15f30b5883253ecb9faf24b5" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Changing a Column&amp;#x27;s Data Type</source>
          <target state="translated">修改表：更改列的数据类型</target>
        </trans-unit>
        <trans-unit id="bad9bdb3a7e14e2048b20553d6893b9f2daeb0f9" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Changing a Column&amp;#x27;s Default Value</source>
          <target state="translated">修改表：更改列的默认值</target>
        </trans-unit>
        <trans-unit id="8649a9592e4298a7e8e6b1abb9ef2b90d9a5be2a" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Removing a Column</source>
          <target state="translated">修改表格。删除列</target>
        </trans-unit>
        <trans-unit id="98650a2f5b97076e75384a35883a830ea83870d0" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Removing a Constraint</source>
          <target state="translated">修改表。删除约束</target>
        </trans-unit>
        <trans-unit id="6ee7fe42d54596a2449882ee5313efaaa712af34" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Renaming a Column</source>
          <target state="translated">修改表格。重命名列</target>
        </trans-unit>
        <trans-unit id="dc81484063645f8a58302e10322fd29ad17f1b92" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Renaming a Table</source>
          <target state="translated">修改表。重命名一个表</target>
        </trans-unit>
        <trans-unit id="c1e625a012d4612de9e088d7c2a093342964bb1f" translate="yes" xml:space="preserve">
          <source>Modifying a partitioned table or a table with inheritance children fires statement-level triggers attached to the explicitly named table, but not statement-level triggers for its partitions or child tables. In contrast, row-level triggers are fired on the rows in affected partitions or child tables, even if they are not explicitly named in the query. If a statement-level trigger has been defined with transition relations named by a &lt;code&gt;REFERENCING&lt;/code&gt; clause, then before and after images of rows are visible from all affected partitions or child tables. In the case of inheritance children, the row images include only columns that are present in the table that the trigger is attached to. Currently, row-level triggers with transition relations cannot be defined on partitions or inheritance child tables.</source>
          <target state="translated">修改分区表或具有继承子级的表会触发附加到显式命名表的语句级触发器，但不会触发其分区或子表的语句级触发器。相反，即使未在查询中明确命名行级触发器，也会在受影响的分区或子表中的行上触发行级触发器。如果已使用 &lt;code&gt;REFERENCING&lt;/code&gt; 子句命名的转换关系定义了语句级触发器，则在所有受影响的分区或子表中都可以看到行的图像的前后。对于继承子级，行图像仅包含触发器附加到的表中存在的列。当前，不能在分区或继承子表上定义具有转换关系的行级触发器。</target>
        </trans-unit>
        <trans-unit id="5a03c6c23d3b223671b9d8eba84851fccb59e4a7" translate="yes" xml:space="preserve">
          <source>Module for storing (key, value) pairs</source>
          <target state="translated">存储(键、值)对的模块。</target>
        </trans-unit>
        <trans-unit id="8f46472981bee7fae7b3d41646aaa681175d3eb8" translate="yes" xml:space="preserve">
          <source>Modulo (remainder)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0216fd9c439582b27771fa19ad3c81fdf577f4c0" translate="yes" xml:space="preserve">
          <source>Modulo (remainder); available for &lt;code&gt;smallint&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;bigint&lt;/code&gt;, and &lt;code&gt;numeric&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58a0f28806f53fd75308c3f2a793267cf1428ae8" translate="yes" xml:space="preserve">
          <source>Modulus</source>
          <target state="translated">Modulus</target>
        </trans-unit>
        <trans-unit id="24b2a0993d0cfa93c44282d6bba72bcf58b300d6" translate="yes" xml:space="preserve">
          <source>Mon</source>
          <target state="translated">Mon</target>
        </trans-unit>
        <trans-unit id="932eeb1076c85e522f02e15441fa371e3fd000ac" translate="yes" xml:space="preserve">
          <source>Monday</source>
          <target state="translated">Monday</target>
        </trans-unit>
        <trans-unit id="6463498da98840aa3b093c82890614171c30b5ef" translate="yes" xml:space="preserve">
          <source>Monetary Types</source>
          <target state="translated">货币类型</target>
        </trans-unit>
        <trans-unit id="881c22df54316f0107467a0277ce497e98935f6d" translate="yes" xml:space="preserve">
          <source>Monetary Types: money</source>
          <target state="translated">货币类型:货币</target>
        </trans-unit>
        <trans-unit id="a81434589757e654444719de434c44e9adc0c708" translate="yes" xml:space="preserve">
          <source>Monitoring</source>
          <target state="translated">Monitoring</target>
        </trans-unit>
        <trans-unit id="082bc378cd60e17a38d99898b21955299c5b60c8" translate="yes" xml:space="preserve">
          <source>Month</source>
          <target state="translated">Month</target>
        </trans-unit>
        <trans-unit id="ca09870a2f60b20cbbb11a8f1bfa5c112c7f2481" translate="yes" xml:space="preserve">
          <source>Months (in the date part)</source>
          <target state="translated">月份(日期部分)</target>
        </trans-unit>
        <trans-unit id="b362fae8ba4022e7ee2c51f663135e4f46fe57f1" translate="yes" xml:space="preserve">
          <source>More about &lt;code&gt;createdb&lt;/code&gt; and &lt;code&gt;dropdb&lt;/code&gt; can be found in &lt;a href=&quot;app-createdb&quot;&gt;createdb&lt;/a&gt; and &lt;a href=&quot;app-dropdb&quot;&gt;dropdb&lt;/a&gt; respectively.</source>
          <target state="translated">有关 &lt;code&gt;createdb&lt;/code&gt; 和 &lt;code&gt;dropdb&lt;/code&gt; 的更多信息，可以分别在&lt;a href=&quot;app-createdb&quot;&gt;createdb&lt;/a&gt;和&lt;a href=&quot;app-dropdb&quot;&gt;dropdb中&lt;/a&gt;找到。</target>
        </trans-unit>
        <trans-unit id="7d8a150db9b3697af1b840b6b8689717b67bec26" translate="yes" xml:space="preserve">
          <source>More complex grouping operations than those described above are possible using the concept of &lt;em&gt;grouping sets&lt;/em&gt;. The data selected by the &lt;code&gt;FROM&lt;/code&gt; and &lt;code&gt;WHERE&lt;/code&gt; clauses is grouped separately by each specified grouping set, aggregates computed for each group just as for simple &lt;code&gt;GROUP BY&lt;/code&gt; clauses, and then the results returned. For example:</source>
          <target state="translated">使用&lt;em&gt;分组集&lt;/em&gt;的概念可以实现比上述更复杂的分组操作。由 &lt;code&gt;FROM&lt;/code&gt; 和 &lt;code&gt;WHERE&lt;/code&gt; 子句选择的数据按每个指定的分组集分别分组，像简单的 &lt;code&gt;GROUP BY&lt;/code&gt; 子句一样为每个组计算聚合，然后返回结果。例如：</target>
        </trans-unit>
        <trans-unit id="32d9dc5690a3f6016671ea3b2ef25dc790df4069" translate="yes" xml:space="preserve">
          <source>More complex usage can produce undesirable results in Read Committed mode. For example, consider a &lt;code&gt;DELETE&lt;/code&gt; command operating on data that is being both added and removed from its restriction criteria by another command, e.g., assume &lt;code&gt;website&lt;/code&gt; is a two-row table with &lt;code&gt;website.hits&lt;/code&gt; equaling &lt;code&gt;9&lt;/code&gt; and &lt;code&gt;10&lt;/code&gt;:</source>
          <target state="translated">在&amp;ldquo;读取已提交&amp;rdquo;模式下，更复杂的用法可能会产生不良结果。例如，考虑一个 &lt;code&gt;DELETE&lt;/code&gt; 命令对另一个命令正在添加和从其限制条件中删除的数据进行操作，例如，假定 &lt;code&gt;website&lt;/code&gt; 是一个两行表， &lt;code&gt;website.hits&lt;/code&gt; 等于 &lt;code&gt;9&lt;/code&gt; 和 &lt;code&gt;10&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="aa123892162b2a296320ac735b855a11c0d07673" translate="yes" xml:space="preserve">
          <source>More details about window functions can be found in &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Section 4.2.8&lt;/a&gt;, &lt;a href=&quot;functions-window&quot;&gt;Section 9.21&lt;/a&gt;, &lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;Section 7.2.5&lt;/a&gt;, and the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; reference page.</source>
          <target state="translated">有关窗口功能的更多详细信息，请参见&lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;第4.2.8 &lt;/a&gt;&lt;a href=&quot;functions-window&quot;&gt;节&lt;/a&gt;，第9.21 &lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;节&lt;/a&gt;，第7.2.5节和&lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;参考页。</target>
        </trans-unit>
        <trans-unit id="61e5e0cc940bc717e85dc5f00f1f583f6b05a316" translate="yes" xml:space="preserve">
          <source>More details about window functions can be found in &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Section 4.2.8&lt;/a&gt;, &lt;a href=&quot;functions-window&quot;&gt;Section 9.22&lt;/a&gt;, &lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;Section 7.2.5&lt;/a&gt;, and the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; reference page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbf3214eaae892986b24caa3a28e76373d96aaab" translate="yes" xml:space="preserve">
          <source>More examples of using &lt;code&gt;jsonpath&lt;/code&gt; operators and methods within path expressions appear below in &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH-OPERATORS&quot;&gt;Section 9.16.2.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b706c980fab74ceb0b82c89e1d0e57333d172c3f" translate="yes" xml:space="preserve">
          <source>More examples, including suitable input and output functions, are in &lt;a href=&quot;https://www.postgresql.org/docs/12/xtypes.html&quot;&gt;Section 37.13&lt;/a&gt;.</source>
          <target state="translated">更多示例，包括合适的输入和输出功能，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/xtypes.html&quot;&gt;第37.13节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c2b364915a6606c0ca2495dd2cb97f36c000aeda" translate="yes" xml:space="preserve">
          <source>More examples, including suitable input and output functions, are in &lt;a href=&quot;https://www.postgresql.org/docs/13/xtypes.html&quot;&gt;Section 37.13&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
