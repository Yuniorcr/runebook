<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="b6017b9e9e841e1ed3391e353ec7b6f77818cd5d" translate="yes" xml:space="preserve">
          <source>The slice syntaxes with omitted &lt;code&gt;lower-bound&lt;/code&gt; and/or &lt;code&gt;upper-bound&lt;/code&gt; can be used too, but only when updating an array value that is not NULL or zero-dimensional (otherwise, there is no existing subscript limit to substitute).</source>
          <target state="translated">也可以使用省略了 &lt;code&gt;lower-bound&lt;/code&gt; 和/或 &lt;code&gt;upper-bound&lt;/code&gt; 的切片语法，但是仅当更新非NULL或零维的数组值时（否则，没有替代的现有下标限制）。</target>
        </trans-unit>
        <trans-unit id="b0a06932e4c9d25d4fab3d4aa77750dbf6cafc0f" translate="yes" xml:space="preserve">
          <source>The slot type - &lt;code&gt;physical&lt;/code&gt; or &lt;code&gt;logical&lt;/code&gt;</source>
          <target state="translated">插槽类型- &lt;code&gt;physical&lt;/code&gt; 或 &lt;code&gt;logical&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5a2a58ef414f79a96eef654d0cb5a2b339ceb599" translate="yes" xml:space="preserve">
          <source>The slot type: &lt;code&gt;physical&lt;/code&gt; or &lt;code&gt;logical&lt;/code&gt;</source>
          <target state="translated">插槽类型： &lt;code&gt;physical&lt;/code&gt; 或 &lt;code&gt;logical&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4042361f65f02965ea45d409682bd67eb2ab934d" translate="yes" xml:space="preserve">
          <source>The sole disadvantage of increasing &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; (and &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; along with it) is that the &lt;code&gt;pg_xact&lt;/code&gt; and &lt;code&gt;pg_commit_ts&lt;/code&gt; subdirectories of the database cluster will take more space, because it must store the commit status and (if &lt;code&gt;track_commit_timestamp&lt;/code&gt; is enabled) timestamp of all transactions back to the &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; horizon. The commit status uses two bits per transaction, so if &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; is set to its maximum allowed value of two billion, &lt;code&gt;pg_xact&lt;/code&gt; can be expected to grow to about half a gigabyte and &lt;code&gt;pg_commit_ts&lt;/code&gt; to about 20GB. If this is trivial compared to your total database size, setting &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; to its maximum allowed value is recommended. Otherwise, set it depending on what you are willing to allow for &lt;code&gt;pg_xact&lt;/code&gt; and &lt;code&gt;pg_commit_ts&lt;/code&gt; storage. (The default, 200 million transactions, translates to about 50MB of &lt;code&gt;pg_xact&lt;/code&gt; storage and about 2GB of &lt;code&gt;pg_commit_ts&lt;/code&gt; storage.)</source>
          <target state="translated">增加 &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; （和 &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; ）的唯一缺点是数据库集群的 &lt;code&gt;pg_xact&lt;/code&gt; 和 &lt;code&gt;pg_commit_ts&lt;/code&gt; 子目录将占用更多空间，因为它必须存储提交状态和所有事务的时间戳（如果启用了 &lt;code&gt;track_commit_timestamp&lt;/code&gt; ），所有事务的时间戳都将返回给。 &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; 范围。提交状态每个事务使用两位，因此，如果将 &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; 设置为其最大允许值20亿，则 &lt;code&gt;pg_xact&lt;/code&gt; 有望增长到大约半千兆字节，而 &lt;code&gt;pg_commit_ts&lt;/code&gt; 到约20GB。如果这与您的数据库总大小相比微不足道，则建议将 &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; 设置为其最大允许值。否则，根据您愿意为 &lt;code&gt;pg_xact&lt;/code&gt; 和 &lt;code&gt;pg_commit_ts&lt;/code&gt; 存储的内容进行设置。（默认的2亿个事务转换为约50MB的 &lt;code&gt;pg_xact&lt;/code&gt; 存储和约2GB的 &lt;code&gt;pg_commit_ts&lt;/code&gt; 存储。）</target>
        </trans-unit>
        <trans-unit id="420d354e00f2d98f43f69fb5c85b3c9d2f0a5c6c" translate="yes" xml:space="preserve">
          <source>The sort expression(s) can be any expression that would be valid in the query's select list. An example is:</source>
          <target state="translated">排序表达式可以是在查询的选择列表中有效的任何表达式。一个例子是:</target>
        </trans-unit>
        <trans-unit id="af64fa9d73d05dafcf40b04a10bc43a2c675e4b9" translate="yes" xml:space="preserve">
          <source>The sort position of this enum value within its enum type</source>
          <target state="translated">该枚举值在其枚举类型中的排序位置。</target>
        </trans-unit>
        <trans-unit id="267381ff52d7207cad90e1b1efb3d2ae56d6e149" translate="yes" xml:space="preserve">
          <source>The source directory &lt;code&gt;contrib/intarray/bench&lt;/code&gt; contains a benchmark test suite, which can be run against an installed PostgreSQL server. (It also requires &lt;code&gt;DBD::Pg&lt;/code&gt; to be installed.) To run:</source>
          <target state="translated">源目录 &lt;code&gt;contrib/intarray/bench&lt;/code&gt; 包含一个基准测试套件，可以在已安装的PostgreSQL服务器上运行。（它也需要安装 &lt;code&gt;DBD::Pg&lt;/code&gt; 。）要运行：</target>
        </trans-unit>
        <trans-unit id="f4b684dc4cf3d0e7f8017a75669ef677ed19f660" translate="yes" xml:space="preserve">
          <source>The source encoding name.</source>
          <target state="translated">源编码名称。</target>
        </trans-unit>
        <trans-unit id="5b4632e063d85e50c766912ad7e51e33ef8bf318" translate="yes" xml:space="preserve">
          <source>The special &amp;ldquo;role&amp;rdquo; name &lt;code&gt;PUBLIC&lt;/code&gt; can be used to grant a privilege to every role on the system. Also, &amp;ldquo;group&amp;rdquo; roles can be set up to help manage privileges when there are many users of a database &amp;mdash; for details see &lt;a href=&quot;https://www.postgresql.org/docs/12/user-manag.html&quot;&gt;Chapter 21&lt;/a&gt;.</source>
          <target state="translated">特殊的&amp;ldquo;角色&amp;rdquo;名称 &lt;code&gt;PUBLIC&lt;/code&gt; 可用于为系统上的每个角色授予特权。此外，当数据库的用户很多时，可以设置&amp;ldquo;组&amp;rdquo;角色来帮助管理特权-有关详细信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/user-manag.html&quot;&gt;第21章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0711f789242d7822af841eb7515278a8210c6c3f" translate="yes" xml:space="preserve">
          <source>The special &amp;ldquo;role&amp;rdquo; name &lt;code&gt;PUBLIC&lt;/code&gt; can be used to grant a privilege to every role on the system. Also, &amp;ldquo;group&amp;rdquo; roles can be set up to help manage privileges when there are many users of a database &amp;mdash; for details see &lt;a href=&quot;https://www.postgresql.org/docs/13/user-manag.html&quot;&gt;Chapter 21&lt;/a&gt;.</source>
          <target state="translated">特殊的&amp;ldquo;角色&amp;rdquo;名称 &lt;code&gt;PUBLIC&lt;/code&gt; 可用于为系统上的每个角色授予特权。另外，当数据库的用户很多时，可以设置&amp;ldquo;组&amp;rdquo;角色来帮助管理特权-有关详细信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/13/user-manag.html&quot;&gt;第21章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d534e247b3040487a992ce1f01908ab3c5c62964" translate="yes" xml:space="preserve">
          <source>The special entry &lt;code&gt;*&lt;/code&gt; matches any standby name.</source>
          <target state="translated">特殊条目 &lt;code&gt;*&lt;/code&gt; 匹配任何备用名称。</target>
        </trans-unit>
        <trans-unit id="31bc549a6a2aaa2d8b0391bf2c83e80b6eb59358" translate="yes" xml:space="preserve">
          <source>The special field name &lt;code&gt;*&lt;/code&gt; means &amp;ldquo;all fields&amp;rdquo;, as further explained in &lt;a href=&quot;rowtypes#ROWTYPES-USAGE&quot;&gt;Section 8.16.5&lt;/a&gt;.</source>
          <target state="translated">特殊字段名称 &lt;code&gt;*&lt;/code&gt; 表示&amp;ldquo;所有字段&amp;rdquo;，如&lt;a href=&quot;rowtypes#ROWTYPES-USAGE&quot;&gt;第8.16.5节所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="758ed933ac597fbff2a112b5d5781d2521256906" translate="yes" xml:space="preserve">
          <source>The special privileges of the object owner (i.e., the right to do &lt;code&gt;DROP&lt;/code&gt;, &lt;code&gt;GRANT&lt;/code&gt;, &lt;code&gt;REVOKE&lt;/code&gt;, etc.) are always implicit in being the owner, and cannot be granted or revoked. But the object owner can choose to revoke their own ordinary privileges, for example to make a table read-only for themselves as well as others.</source>
          <target state="translated">对象所有者的特殊特权（即执行 &lt;code&gt;DROP&lt;/code&gt; ， &lt;code&gt;GRANT&lt;/code&gt; ， &lt;code&gt;REVOKE&lt;/code&gt; 等的权利）始终隐含在所有者中，不能被授予或撤销。但是对象所有者可以选择撤消自己的普通特权，例如使表对自己和其他人都是只读的。</target>
        </trans-unit>
        <trans-unit id="c644ef37e4f8fad5de2f6806820052ad171113ce" translate="yes" xml:space="preserve">
          <source>The special table function &lt;code&gt;UNNEST&lt;/code&gt; may be called with any number of array parameters, and it returns a corresponding number of columns, as if &lt;code&gt;UNNEST&lt;/code&gt; (&lt;a href=&quot;functions-array&quot;&gt;Section 9.18&lt;/a&gt;) had been called on each parameter separately and combined using the &lt;code&gt;ROWS FROM&lt;/code&gt; construct.</source>
          <target state="translated">特殊表函数 &lt;code&gt;UNNEST&lt;/code&gt; 可以用任意数量的数组参数调用，并且它返回对应数量的列，就好像 &lt;code&gt;UNNEST&lt;/code&gt; 对每个参数调用了UNNEST（&lt;a href=&quot;functions-array&quot;&gt;第9.18节&lt;/a&gt;）并使用 &lt;code&gt;ROWS FROM&lt;/code&gt; 构造进行组合一样。</target>
        </trans-unit>
        <trans-unit id="394c1d359ef1d3b89124b30daad8e16a978cd018" translate="yes" xml:space="preserve">
          <source>The special table function &lt;code&gt;UNNEST&lt;/code&gt; may be called with any number of array parameters, and it returns a corresponding number of columns, as if &lt;code&gt;UNNEST&lt;/code&gt; (&lt;a href=&quot;functions-array&quot;&gt;Section 9.19&lt;/a&gt;) had been called on each parameter separately and combined using the &lt;code&gt;ROWS FROM&lt;/code&gt; construct.</source>
          <target state="translated">可以使用任意数量的数组参数来调用特殊表函数 &lt;code&gt;UNNEST&lt;/code&gt; ，并且它返回对应数量的列，就好像 &lt;code&gt;UNNEST&lt;/code&gt; 对每个参数调用了UNNEST（&lt;a href=&quot;functions-array&quot;&gt;第9.19节&lt;/a&gt;）并使用 &lt;code&gt;ROWS FROM&lt;/code&gt; 构造将其组合在一起一样。</target>
        </trans-unit>
        <trans-unit id="e3760930d6be21baabcd516fd8aaa6bbd0e31deb" translate="yes" xml:space="preserve">
          <source>The special values &lt;code&gt;MINVALUE&lt;/code&gt; and &lt;code&gt;MAXVALUE&lt;/code&gt; may be used when creating a range partition to indicate that there is no lower or upper bound on the column's value. For example, a partition defined using &lt;code&gt;FROM (MINVALUE) TO (10)&lt;/code&gt; allows any values less than 10, and a partition defined using &lt;code&gt;FROM (10) TO (MAXVALUE)&lt;/code&gt; allows any values greater than or equal to 10.</source>
          <target state="translated">创建范围分区时，可以使用特殊值 &lt;code&gt;MINVALUE&lt;/code&gt; 和 &lt;code&gt;MAXVALUE&lt;/code&gt; 来指示该列的值没有上限或下限。例如，使用 &lt;code&gt;FROM (MINVALUE) TO (10)&lt;/code&gt; 定义的分区允许任何小于10的值，而使用 &lt;code&gt;FROM (10) TO (MAXVALUE)&lt;/code&gt; 定义的分区允许任何大于或等于10的值。</target>
        </trans-unit>
        <trans-unit id="7e90fbaeae1d1655b1bb6f95cb13335bf4d3a214" translate="yes" xml:space="preserve">
          <source>The specially treated variables are:</source>
          <target state="translated">特别处理的变量是:</target>
        </trans-unit>
        <trans-unit id="1b586ed754bd73f7164a8d06b3ccf052091b7071" translate="yes" xml:space="preserve">
          <source>The specific data that a BRIN index will store, as well as the specific queries that the index will be able to satisfy, depend on the operator class selected for each column of the index. Data types having a linear sort order can have operator classes that store the minimum and maximum value within each block range, for instance; geometrical types might store the bounding box for all the objects in the block range.</source>
          <target state="translated">BRIN索引将存储的具体数据,以及索引能够满足的具体查询,取决于为索引的每一列选择的运算符类。例如,具有线性排序顺序的数据类型可以拥有存储每个块范围内最小值和最大值的运算符类;几何类型可能会存储块范围内所有对象的边界框。</target>
        </trans-unit>
        <trans-unit id="c67370c9102fee266def76d5516bcf8df8f39414" translate="yes" xml:space="preserve">
          <source>The specific function that is referenced by a function call is determined using the following procedure.</source>
          <target state="translated">使用下面的程序确定函数调用所引用的具体函数。</target>
        </trans-unit>
        <trans-unit id="d4491b1318b4f57536f43e332d74ca6d054454c5" translate="yes" xml:space="preserve">
          <source>The specific operator that is referenced by an operator expression is determined using the following procedure. Note that this procedure is indirectly affected by the precedence of the operators involved, since that will determine which sub-expressions are taken to be the inputs of which operators. See &lt;a href=&quot;sql-syntax-lexical#SQL-PRECEDENCE&quot;&gt;Section 4.1.6&lt;/a&gt; for more information.</source>
          <target state="translated">使用以下过程确定由运算符表达式引用的特定运算符。请注意，此过程受所涉及运算符的优先级间接影响，因为这将确定将哪些子表达式作为哪个运算符的输入。有关更多信息，请参见&lt;a href=&quot;sql-syntax-lexical#SQL-PRECEDENCE&quot;&gt;第4.1.6节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="56960e04e804eb4178adc815aab5ca82c4358153" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;index&lt;/code&gt; can be an integer, as well as an expression returning a single numeric value, which is automatically cast to integer. Index zero corresponds to the first array element. You can also use the &lt;code&gt;last&lt;/code&gt; keyword to denote the last array element, which is useful for handling arrays of unknown length.</source>
          <target state="translated">指定的 &lt;code&gt;index&lt;/code&gt; 可以是整数，也可以是返回单个数值的表达式，该数值将自动转换为整数。索引零对应于第一个数组元素。您还可以使用 &lt;code&gt;last&lt;/code&gt; 关键字来表示last数组元素，这对于处理未知长度的数组很有用。</target>
        </trans-unit>
        <trans-unit id="bf52c4d6cf2c8133df1aca73cde50bf658361fd0" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;index&lt;/code&gt; can be an integer, as well as an expression returning a single numeric value, which is automatically cast to integer. Zero index corresponds to the first array element. You can also use the &lt;code&gt;last&lt;/code&gt; keyword to denote the last array element, which is useful for handling arrays of unknown length.</source>
          <target state="translated">指定的 &lt;code&gt;index&lt;/code&gt; 可以是整数，也可以是返回单个数值的表达式，该数值将自动转换为整数。零索引对应于第一个数组元素。您还可以使用 &lt;code&gt;last&lt;/code&gt; 关键字来表示last数组元素，这对于处理未知长度的数组很有用。</target>
        </trans-unit>
        <trans-unit id="8859206cebb9c86d9bc85a5c793d72f97cbfcda7" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;role_name&lt;/code&gt; must be a role that the current session user is a member of. (If the session user is a superuser, any role can be selected.)</source>
          <target state="translated">指定的 &lt;code&gt;role_name&lt;/code&gt; 必须是当前会话用户所属的角色。（如果会话用户是超级用户，则可以选择任何角色。）</target>
        </trans-unit>
        <trans-unit id="afd818a1af1c31122dbe5ccb86326656bebfdabf" translate="yes" xml:space="preserve">
          <source>The specified locale and encoding settings must match, or an error will be reported.</source>
          <target state="translated">指定的locale和编码设置必须匹配,否则将报告一个错误。</target>
        </trans-unit>
        <trans-unit id="0c30502cb792c5bd66e555818ae0268a7466dc40" translate="yes" xml:space="preserve">
          <source>The specified null string is sent by &lt;code&gt;COPY TO&lt;/code&gt; without adding any backslashes; conversely, &lt;code&gt;COPY FROM&lt;/code&gt; matches the input against the null string before removing backslashes. Therefore, a null string such as &lt;code&gt;\N&lt;/code&gt; cannot be confused with the actual data value &lt;code&gt;\N&lt;/code&gt; (which would be represented as &lt;code&gt;\\N&lt;/code&gt;).</source>
          <target state="translated">指定的空字符串由 &lt;code&gt;COPY TO&lt;/code&gt; 发送，不添加任何反斜杠；相反，在删除反斜杠之前， &lt;code&gt;COPY FROM&lt;/code&gt; 将输入与空字符串进行匹配。因此，不能将诸如 &lt;code&gt;\N&lt;/code&gt; 类的空字符串与实际数据值 &lt;code&gt;\N&lt;/code&gt; （将其表示为 &lt;code&gt;\\N&lt;/code&gt; ）混淆。</target>
        </trans-unit>
        <trans-unit id="4d4785fdbe411a867de5dc30c6f6e2cd3e8ad8aa" translate="yes" xml:space="preserve">
          <source>The specified replication slot has to exist unless the option &lt;code&gt;-C&lt;/code&gt; is also used.</source>
          <target state="translated">除非还使用选项 &lt;code&gt;-C&lt;/code&gt; ,否则指定的复制插槽必须存在。</target>
        </trans-unit>
        <trans-unit id="fe37bdbcd81870812798f7398d4fa3769b9383b0" translate="yes" xml:space="preserve">
          <source>The speed of the archiving command is unimportant as long as it can keep up with the average rate at which your server generates WAL data. Normal operation continues even if the archiving process falls a little behind. If archiving falls significantly behind, this will increase the amount of data that would be lost in the event of a disaster. It will also mean that the &lt;code&gt;pg_wal/&lt;/code&gt; directory will contain large numbers of not-yet-archived segment files, which could eventually exceed available disk space. You are advised to monitor the archiving process to ensure that it is working as you intend.</source>
          <target state="translated">归档命令的速度并不重要，只要它能跟上服务器生成WAL数据的平均速率即可。即使归档过程落后一点，正常操作仍会继续。如果归档明显滞后，这将增加发生灾难时丢失的数据量。这也将意味着 &lt;code&gt;pg_wal/&lt;/code&gt; 目录将包含大量尚未归档的段文件，最终可能会超出可用磁盘空间。建议您监视归档过程，以确保它按预期工作。</target>
        </trans-unit>
        <trans-unit id="95c448049b38c97f5a095366eb9a582e60005694" translate="yes" xml:space="preserve">
          <source>The spi module provides several workable examples of using the &lt;a href=&quot;https://www.postgresql.org/docs/12/spi.html&quot;&gt;Server Programming Interface&lt;/a&gt; (SPI) and triggers. While these functions are of some value in their own right, they are even more useful as examples to modify for your own purposes. The functions are general enough to be used with any table, but you have to specify table and field names (as described below) while creating a trigger.</source>
          <target state="translated">spi模块提供了使用&lt;a href=&quot;https://www.postgresql.org/docs/12/spi.html&quot;&gt;服务器编程接口&lt;/a&gt;（SPI）和触发器的几个可行示例。虽然这些功能本身具有一定的价值，但它们作为示例进行修改以达到您自己的目的甚至更加有用。这些函数足够通用，可以与任何表一起使用，但是在创建触发器时必须指定表和字段名称（如下所述）。</target>
        </trans-unit>
        <trans-unit id="cab15a6018a42e58d3535f603f3afdd60d9e9dde" translate="yes" xml:space="preserve">
          <source>The spi module provides several workable examples of using the &lt;a href=&quot;https://www.postgresql.org/docs/13/spi.html&quot;&gt;Server Programming Interface&lt;/a&gt; (SPI) and triggers. While these functions are of some value in their own right, they are even more useful as examples to modify for your own purposes. The functions are general enough to be used with any table, but you have to specify table and field names (as described below) while creating a trigger.</source>
          <target state="translated">spi模块提供了使用&lt;a href=&quot;https://www.postgresql.org/docs/13/spi.html&quot;&gt;服务器编程接口&lt;/a&gt;（SPI）和触发器的几个可行示例。尽管这些功能本身具有一定的价值，但它们作为示例可以为您自己的目的进行修改而变得更加有用。这些函数足够通用，可以与任何表一起使用，但是在创建触发器时必须指定表和字段名称（如下所述）。</target>
        </trans-unit>
        <trans-unit id="51d51509dfcf1b638bd0142f5ba7e99e05ff8361" translate="yes" xml:space="preserve">
          <source>The standard B-tree operators are also provided, for example</source>
          <target state="translated">还提供了标准的B树运算符,例如</target>
        </trans-unit>
        <trans-unit id="540592c3e626f7c31f8adb5673f9493bff1cdcb6" translate="yes" xml:space="preserve">
          <source>The standard PostgreSQL distribution does not include any Ispell configuration files. Dictionaries for a large number of languages are available from &lt;a href=&quot;https://www.cs.hmc.edu/~geoff/ispell.html&quot;&gt;Ispell&lt;/a&gt;. Also, some more modern dictionary file formats are supported &amp;mdash; &lt;a href=&quot;https://en.wikipedia.org/wiki/MySpell&quot;&gt;MySpell&lt;/a&gt; (OO &amp;lt; 2.0.1) and &lt;a href=&quot;https://sourceforge.net/projects/hunspell/&quot;&gt;Hunspell&lt;/a&gt; (OO &amp;gt;= 2.0.2). A large list of dictionaries is available on the &lt;a href=&quot;https://wiki.openoffice.org/wiki/Dictionaries&quot;&gt;OpenOffice Wiki&lt;/a&gt;.</source>
          <target state="translated">标准PostgreSQL发行版不包含任何Ispell配置文件。&lt;a href=&quot;https://www.cs.hmc.edu/~geoff/ispell.html&quot;&gt;Ispell&lt;/a&gt;提供了多种语言的字典。此外，还支持一些更现代的词典文件格式&lt;a href=&quot;https://en.wikipedia.org/wiki/MySpell&quot;&gt;-MySpell&lt;/a&gt;（OO &amp;lt;2.0.1）和&lt;a href=&quot;https://sourceforge.net/projects/hunspell/&quot;&gt;Hunspell&lt;/a&gt;（OO&amp;gt; = 2.0.2）。&lt;a href=&quot;https://wiki.openoffice.org/wiki/Dictionaries&quot;&gt;OpenOffice Wiki&lt;/a&gt;上提供了大量词典。</target>
        </trans-unit>
        <trans-unit id="c31d1f8f49b866b6c41ce1d3be305d54cfca10f1" translate="yes" xml:space="preserve">
          <source>The standard allows transition tables to be used with column-specific &lt;code&gt;UPDATE&lt;/code&gt; triggers, but then the set of rows that should be visible in the transition tables depends on the trigger's column list. This is not currently implemented by PostgreSQL.</source>
          <target state="translated">该标准允许将过渡表与特定于列的 &lt;code&gt;UPDATE&lt;/code&gt; 触发器一起使用，但是过渡表中应可见的行集取决于触发器的列列表。PostgreSQL当前未实现此功能。</target>
        </trans-unit>
        <trans-unit id="7abbb06bd2ac89072eb3b19d752092cab8a2a05f" translate="yes" xml:space="preserve">
          <source>The standard and predefined collations are in the schema &lt;code&gt;pg_catalog&lt;/code&gt;, like all predefined objects. User-defined collations should be created in user schemas. This also ensures that they are saved by &lt;code&gt;pg_dump&lt;/code&gt;.</source>
          <target state="translated">像所有预定义对象一样，标准归类和预定义归类在 &lt;code&gt;pg_catalog&lt;/code&gt; 模式中。应在用户架构中创建用户定义的归类。这也确保它们被 &lt;code&gt;pg_dump&lt;/code&gt; 保存。</target>
        </trans-unit>
        <trans-unit id="7c4d54e7271038b160fc912ff3e59738441ec42e" translate="yes" xml:space="preserve">
          <source>The standard approach to doing case-insensitive matches in PostgreSQL has been to use the &lt;code&gt;lower&lt;/code&gt; function when comparing values, for example</source>
          <target state="translated">在PostgreSQL中进行区分大小写的匹配的标准方法是在比较值时使用 &lt;code&gt;lower&lt;/code&gt; 功能，例如</target>
        </trans-unit>
        <trans-unit id="66a45d5bab8320954db0c2f93584f58e956d983a" translate="yes" xml:space="preserve">
          <source>The standard comparison operators shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;Table 9.1&lt;/a&gt; are available for &lt;code&gt;jsonb&lt;/code&gt;, but not for &lt;code&gt;json&lt;/code&gt;. They follow the ordering rules for B-tree operations outlined at &lt;a href=&quot;datatype-json#JSON-INDEXING&quot;&gt;Section 8.14.4&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;表9.1&lt;/a&gt;中显示的标准比较运算符可用于 &lt;code&gt;jsonb&lt;/code&gt; ，但不适用于 &lt;code&gt;json&lt;/code&gt; 。它们遵循&lt;a href=&quot;datatype-json#JSON-INDEXING&quot;&gt;第8.14.4节中&lt;/a&gt;概述的B树操作的排序规则。</target>
        </trans-unit>
        <trans-unit id="aecb6846cb8fa061d2893b8cbe3329208b79f989" translate="yes" xml:space="preserve">
          <source>The standard form of &lt;code&gt;VACUUM&lt;/code&gt; removes dead row versions in tables and indexes and marks the space available for future reuse. However, it will not return the space to the operating system, except in the special case where one or more pages at the end of a table become entirely free and an exclusive table lock can be easily obtained. In contrast, &lt;code&gt;VACUUM FULL&lt;/code&gt; actively compacts tables by writing a complete new version of the table file with no dead space. This minimizes the size of the table, but can take a long time. It also requires extra disk space for the new copy of the table, until the operation completes.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; 的标准形式删除表和索引中的死行版本，并标记可供将来重用的空间。但是，它不会将空间返回给操作系统，除非在特殊情况下，表末尾的一个或多个页面变得完全空闲，并且可以轻松获得独占表锁。相反， &lt;code&gt;VACUUM FULL&lt;/code&gt; 通过写入没有死角的表文件的全新版本来主动压缩表。这样可以最大程度地减少表的大小，但是会花费很长时间。在操作完成之前，表的新副本还需要额外的磁盘空间。</target>
        </trans-unit>
        <trans-unit id="64a9df6af803f6fb88db88a2c8492bf422359cc7" translate="yes" xml:space="preserve">
          <source>The standard only allows one function to be dropped per command.</source>
          <target state="translated">标准只允许每个命令放弃一个函数。</target>
        </trans-unit>
        <trans-unit id="f5dc058e6d69517b035378cc0545a3ff6bbf59c9" translate="yes" xml:space="preserve">
          <source>The standard only allows one procedure to be dropped per command.</source>
          <target state="translated">标准只允许每个命令放弃一个过程。</target>
        </trans-unit>
        <trans-unit id="d079640bb3afa14420ec7729af4881846a5851ac" translate="yes" xml:space="preserve">
          <source>The standard only allows one routine to be dropped per command.</source>
          <target state="translated">标准只允许每个命令放弃一个例程。</target>
        </trans-unit>
        <trans-unit id="d6f30578370e30868e083b5faa5f9ddb49a2e7ea" translate="yes" xml:space="preserve">
          <source>The standard requires parentheses around the subquery clause; in PostgreSQL, these parentheses are optional.</source>
          <target state="translated">标准要求在子查询子句周围加上括号;在PostgreSQL中,这些括号是可选的。</target>
        </trans-unit>
        <trans-unit id="037c9f0273cfeaa62d235fa64430e2ec604be3e9" translate="yes" xml:space="preserve">
          <source>The standard's definition of the behavior of temporary tables is widely ignored. PostgreSQL's behavior on this point is similar to that of several other SQL databases.</source>
          <target state="translated">标准对临时表行为的定义被广泛忽视。PostgreSQL在这一点上的行为与其他几个SQL数据库类似。</target>
        </trans-unit>
        <trans-unit id="d958124d33ada3ecaa4ecf5cd2414a7d80adeee5" translate="yes" xml:space="preserve">
          <source>The statement subforms and actions available for &lt;code&gt;ALTER MATERIALIZED VIEW&lt;/code&gt; are a subset of those available for &lt;code&gt;ALTER TABLE&lt;/code&gt;, and have the same meaning when used for materialized views. See the descriptions for &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; for details.</source>
          <target state="translated">可用于 &lt;code&gt;ALTER MATERIALIZED VIEW&lt;/code&gt; 的语句子窗体和操作是可用于 &lt;code&gt;ALTER TABLE&lt;/code&gt; 的语句子窗体和操作的子集，并且在用于物化视图时具有相同的含义。有关详细信息，请参见&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;的描述。</target>
        </trans-unit>
        <trans-unit id="adf6cc4f8a6109f575b7d3519d3e9c33574716b7" translate="yes" xml:space="preserve">
          <source>The statistic-gathering target for this statistics object for subsequent &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; operations. The target can be set in the range 0 to 10000; alternatively, set it to -1 to revert to using the maximum of the statistics target of the referenced columns, if set, or the system default statistics target (&lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt;). For more information on the use of statistics by the PostgreSQL query planner, refer to &lt;a href=&quot;planner-stats&quot;&gt;Section 14.2&lt;/a&gt;.</source>
          <target state="translated">此统计对象的统计收集目标，用于后续的&lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt;操作。可以在0到10000范围内设置目标。或者，将其设置为-1以恢复为使用所引用列的统计目标的最大值（如果已设置）或系统默认统计目标（&lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt;）。有关PostgreSQL查询计划程序使用统计信息的更多信息，请参见&lt;a href=&quot;planner-stats&quot;&gt;14.2节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a85ce8c175ffd31b8c2d56822ffccc6660fc62f" translate="yes" xml:space="preserve">
          <source>The statistics collected by &lt;code&gt;ANALYZE&lt;/code&gt; usually include a list of some of the most common values in each column and a histogram showing the approximate data distribution in each column. One or both of these can be omitted if &lt;code&gt;ANALYZE&lt;/code&gt; deems them uninteresting (for example, in a unique-key column, there are no common values) or if the column data type does not support the appropriate operators. There is more information about the statistics in &lt;a href=&quot;https://www.postgresql.org/docs/12/maintenance.html&quot;&gt;Chapter 24&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ANALYZE&lt;/code&gt; 收集的统计信息通常包括每列中一些最常用值的列表以及显示每列中近似数据分布的直方图。如果 &lt;code&gt;ANALYZE&lt;/code&gt; 认为它们不重要（例如，在唯一键列中没有公共值），或者列数据类型不支持适当的运算符，则可以忽略其中一个或两个。&lt;a href=&quot;https://www.postgresql.org/docs/12/maintenance.html&quot;&gt;第24章&lt;/a&gt;提供了有关统计信息的更多信息。</target>
        </trans-unit>
        <trans-unit id="adfbbd6d85375712da67e76aabf75e7f5395de5a" translate="yes" xml:space="preserve">
          <source>The statistics collected by &lt;code&gt;ANALYZE&lt;/code&gt; usually include a list of some of the most common values in each column and a histogram showing the approximate data distribution in each column. One or both of these can be omitted if &lt;code&gt;ANALYZE&lt;/code&gt; deems them uninteresting (for example, in a unique-key column, there are no common values) or if the column data type does not support the appropriate operators. There is more information about the statistics in &lt;a href=&quot;https://www.postgresql.org/docs/13/maintenance.html&quot;&gt;Chapter 24&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ANALYZE&lt;/code&gt; 收集的统计信息通常包括每列中一些最常用值的列表以及显示每列中近似数据分布的直方图。如果 &lt;code&gt;ANALYZE&lt;/code&gt; 认为它们不重要（例如，在唯一键列中没有公共值），或者列数据类型不支持适当的运算符，则可以忽略其中一个或两个。&lt;a href=&quot;https://www.postgresql.org/docs/13/maintenance.html&quot;&gt;第24章&lt;/a&gt;提供了有关统计信息的更多信息。</target>
        </trans-unit>
        <trans-unit id="238068c46fb76fc5b6da5477e8f4ec22c3889848" translate="yes" xml:space="preserve">
          <source>The statistics collector is active during recovery. All scans, reads, blocks, index usage, etc., will be recorded normally on the standby. Replayed actions will not duplicate their effects on primary, so replaying an insert will not increment the Inserts column of pg_stat_user_tables. The stats file is deleted at the start of recovery, so stats from primary and standby will differ; this is considered a feature, not a bug.</source>
          <target state="translated">在恢复期间,统计收集器是活跃的。所有的扫描、读取、块、索引使用情况等,都会在待机状态下正常记录。重放的操作不会重复其对primary的影响,所以重放插入不会增加pg_stat_user_tables的Inserts列。在恢复开始时,统计文件会被删除,所以主设备和备用设备的统计会有所不同;这被认为是一个功能,而不是一个错误。</target>
        </trans-unit>
        <trans-unit id="965711f627243ac89dbb9d9e575eab2acab52658" translate="yes" xml:space="preserve">
          <source>The statistics collector transmits the collected information to other PostgreSQL processes through temporary files. These files are stored in the directory named by the &lt;a href=&quot;runtime-config-statistics#GUC-STATS-TEMP-DIRECTORY&quot;&gt;stats_temp_directory&lt;/a&gt; parameter, &lt;code&gt;pg_stat_tmp&lt;/code&gt; by default. For better performance, &lt;code&gt;stats_temp_directory&lt;/code&gt; can be pointed at a RAM-based file system, decreasing physical I/O requirements. When the server shuts down cleanly, a permanent copy of the statistics data is stored in the &lt;code&gt;pg_stat&lt;/code&gt; subdirectory, so that statistics can be retained across server restarts. When recovery is performed at server start (e.g. after immediate shutdown, server crash, and point-in-time recovery), all statistics counters are reset.</source>
          <target state="translated">统计信息收集器通过临时文件将收集的信息传输到其他PostgreSQL进程。这些文件存储在由指定的目录&lt;a href=&quot;runtime-config-statistics#GUC-STATS-TEMP-DIRECTORY&quot;&gt;stats_temp_directory&lt;/a&gt;参数， &lt;code&gt;pg_stat_tmp&lt;/code&gt; 默认。为了获得更好的性能，可以将 &lt;code&gt;stats_temp_directory&lt;/code&gt; 指向基于RAM的文件系统，从而降低了物理I / O需求。当服务器完全关闭时，统计数据的永久副本存储在 &lt;code&gt;pg_stat&lt;/code&gt; 子目录中，以便可以在服务器重新启动时保留统计信息。在服务器启动时（例如，在立即关闭，服务器崩溃和时间点恢复之后）执行恢复时，所有统计信息计数器都会重置。</target>
        </trans-unit>
        <trans-unit id="ed6f0b5b68c60cb649e8a7cdfda530aaa032eb80" translate="yes" xml:space="preserve">
          <source>The statistics collector transmits the collected information to other PostgreSQL processes through temporary files. These files are stored in the directory named by the &lt;a href=&quot;runtime-config-statistics#GUC-STATS-TEMP-DIRECTORY&quot;&gt;stats_temp_directory&lt;/a&gt; parameter, &lt;code&gt;pg_stat_tmp&lt;/code&gt; by default. For better performance, &lt;code&gt;stats_temp_directory&lt;/code&gt; can be pointed at a RAM-based file system, decreasing physical I/O requirements. When the server shuts down cleanly, a permanent copy of the statistics data is stored in the &lt;code&gt;pg_stat&lt;/code&gt; subdirectory, so that statistics can be retained across server restarts. When recovery is performed at server start (e.g., after immediate shutdown, server crash, and point-in-time recovery), all statistics counters are reset.</source>
          <target state="translated">统计信息收集器通过临时文件将收集的信息传输到其他PostgreSQL进程。这些文件存储在由指定的目录&lt;a href=&quot;runtime-config-statistics#GUC-STATS-TEMP-DIRECTORY&quot;&gt;stats_temp_directory&lt;/a&gt;参数， &lt;code&gt;pg_stat_tmp&lt;/code&gt; 默认。为了获得更好的性能，可以将 &lt;code&gt;stats_temp_directory&lt;/code&gt; 指向基于RAM的文件系统，从而降低了物理I / O需求。当服务器完全关闭时，统计数据的永久副本存储在 &lt;code&gt;pg_stat&lt;/code&gt; 子目录中，以便可以在服务器重新启动时保留统计信息。当在服务器启动时执行恢复时（例如，在立即关闭，服务器崩溃和时间点恢复之后），将重置所有统计信息计数器。</target>
        </trans-unit>
        <trans-unit id="3d31102b772c217f86df5c917a56d333df998b96" translate="yes" xml:space="preserve">
          <source>The statistics gathered by the module are made available via a view named &lt;code&gt;pg_stat_statements&lt;/code&gt;. This view contains one row for each distinct database ID, user ID and query ID (up to the maximum number of distinct statements that the module can track). The columns of the view are shown in &lt;a href=&quot;pgstatstatements#PGSTATSTATEMENTS-COLUMNS&quot;&gt;Table F.21&lt;/a&gt;.</source>
          <target state="translated">该模块收集的统计信息可通过名为 &lt;code&gt;pg_stat_statements&lt;/code&gt; 的视图使用。对于每个不同的数据库ID，用户ID和查询ID（该模块可以跟踪的最大不同语句数），此视图包含一行。视图的列在&lt;a href=&quot;pgstatstatements#PGSTATSTATEMENTS-COLUMNS&quot;&gt;表F.21&lt;/a&gt;中显示。</target>
        </trans-unit>
        <trans-unit id="d129f0558b07e424e594be75be7478f28f34b280" translate="yes" xml:space="preserve">
          <source>The stop point must be after the ending time of the base backup, i.e., the end time of &lt;code&gt;pg_stop_backup&lt;/code&gt;. You cannot use a base backup to recover to a time when that backup was in progress. (To recover to such a time, you must go back to your previous base backup and roll forward from there.)</source>
          <target state="translated">停止点必须在基本备份的结束时间之后，即 &lt;code&gt;pg_stop_backup&lt;/code&gt; 的结束时间之后。您不能使用基本备份恢复到正在进行该备份的时间。（要恢复到这样的时间，您必须返回到以前的基本备份并从那里前滚。）</target>
        </trans-unit>
        <trans-unit id="991a8e15374d6e812a4e43376053e637a59638d9" translate="yes" xml:space="preserve">
          <source>The stopword file format is the same as already explained.</source>
          <target state="translated">停字文件的格式与前述相同。</target>
        </trans-unit>
        <trans-unit id="6a67abf97180ecab3e7785607a17892200ca122a" translate="yes" xml:space="preserve">
          <source>The storage alignment requirement of the data type. If specified, it must be &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;int2&lt;/code&gt;, &lt;code&gt;int4&lt;/code&gt;, or &lt;code&gt;double&lt;/code&gt;; the default is &lt;code&gt;int4&lt;/code&gt;.</source>
          <target state="translated">数据类型的存储对齐要求。如果指定，则必须为 &lt;code&gt;char&lt;/code&gt; ， &lt;code&gt;int2&lt;/code&gt; ， &lt;code&gt;int4&lt;/code&gt; 或 &lt;code&gt;double&lt;/code&gt; ;默认值为 &lt;code&gt;int4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4fb27d9289cba59d0dbea8d9a256bcf54f4d8f1d" translate="yes" xml:space="preserve">
          <source>The storage requirement for a short string (up to 126 bytes) is 1 byte plus the actual string, which includes the space padding in the case of &lt;code&gt;character&lt;/code&gt;. Longer strings have 4 bytes of overhead instead of 1. Long strings are compressed by the system automatically, so the physical requirement on disk might be less. Very long values are also stored in background tables so that they do not interfere with rapid access to shorter column values. In any case, the longest possible character string that can be stored is about 1 GB. (The maximum value that will be allowed for &lt;code&gt;n&lt;/code&gt; in the data type declaration is less than that. It wouldn't be useful to change this because with multibyte character encodings the number of characters and bytes can be quite different. If you desire to store long strings with no specific upper limit, use &lt;code&gt;text&lt;/code&gt; or &lt;code&gt;character varying&lt;/code&gt; without a length specifier, rather than making up an arbitrary length limit.)</source>
          <target state="translated">短字符串（最多126个字节）的存储要求是1个字节加上实际字符串，其中包括在 &lt;code&gt;character&lt;/code&gt; 情况下的空格填充。较长的字符串的开销为4个字节，而不是1个字节。较长的字符串由系统自动压缩，因此对磁盘的物理需求可能会更少。非常长的值也存储在后台表中，这样它们就不会干扰对较短列值的快速访问。在任何情况下，可以存储的最长字符串约为1 GB。 （ &lt;code&gt;n&lt;/code&gt; 允许的最大值数据类型声明中的小于。更改此设置将无用，因为使用多字节字符编码时，字符和字节的数量可能会完全不同。如果要存储没有特定上限的长字符串，请使用不带长度说明符的 &lt;code&gt;text&lt;/code&gt; 或 &lt;code&gt;character varying&lt;/code&gt; ，而不是设置任意长度限制。）</target>
        </trans-unit>
        <trans-unit id="80d6814e5ec0e1d06f3de3ede9d15794bac11987" translate="yes" xml:space="preserve">
          <source>The storage strategy for the data type. If specified, must be &lt;code&gt;plain&lt;/code&gt;, &lt;code&gt;external&lt;/code&gt;, &lt;code&gt;extended&lt;/code&gt;, or &lt;code&gt;main&lt;/code&gt;; the default is &lt;code&gt;plain&lt;/code&gt;.</source>
          <target state="translated">数据类型的存储策略。如果指定，则必须是 &lt;code&gt;plain&lt;/code&gt; ， &lt;code&gt;external&lt;/code&gt; ， &lt;code&gt;extended&lt;/code&gt; 或 &lt;code&gt;main&lt;/code&gt; ；默认值为 &lt;code&gt;plain&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b76e63a79625e26440cca8d9a00f3887da24e61" translate="yes" xml:space="preserve">
          <source>The stream format is determined by the output plugin specified when the slot was created.</source>
          <target state="translated">流格式由创建槽时指定的输出插件决定。</target>
        </trans-unit>
        <trans-unit id="19380cfa586d87fdf911b110ff6bf4d13369bdea" translate="yes" xml:space="preserve">
          <source>The string constant can be written using either regular SQL notation or dollar-quoting.</source>
          <target state="translated">字符串常量可以使用常规SQL符号或美元引号来书写。</target>
        </trans-unit>
        <trans-unit id="84091e9e070956556635627e5454034e5e1ceadb" translate="yes" xml:space="preserve">
          <source>The string constant's text is passed to the input conversion routine for the type called &lt;code&gt;type&lt;/code&gt;. The result is a constant of the indicated type. The explicit type cast can be omitted if there is no ambiguity as to the type the constant must be (for example, when it is assigned directly to a table column), in which case it is automatically coerced.</source>
          <target state="translated">字符串常量的文本将传递给类型为 &lt;code&gt;type&lt;/code&gt; 的输入转换例程。结果是所指示类型的常数。如果在常量类型上没有任何歧义（例如，当直接将其分配给表列时），则可以省略显式类型强制转换，在这种情况下，它将被自动强制。</target>
        </trans-unit>
        <trans-unit id="c916cd87a0dd50984ecec5d10546dad9c3284d3a" translate="yes" xml:space="preserve">
          <source>The string must start with a &lt;code&gt;P&lt;/code&gt;, and may include a &lt;code&gt;T&lt;/code&gt; that introduces the time-of-day units. The available unit abbreviations are given in &lt;a href=&quot;datatype-datetime#DATATYPE-INTERVAL-ISO8601-UNITS&quot;&gt;Table 8.16&lt;/a&gt;. Units may be omitted, and may be specified in any order, but units smaller than a day must appear after &lt;code&gt;T&lt;/code&gt;. In particular, the meaning of &lt;code&gt;M&lt;/code&gt; depends on whether it is before or after &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">该字符串必须以 &lt;code&gt;P&lt;/code&gt; 开头，并且可以包含引入时间单位的 &lt;code&gt;T&lt;/code&gt; 。&lt;a href=&quot;datatype-datetime#DATATYPE-INTERVAL-ISO8601-UNITS&quot;&gt;表8.16&lt;/a&gt;中给出了可用的单位缩写。单位可以省略，可以以任何顺序指定，但是小于天的单位必须在 &lt;code&gt;T&lt;/code&gt; 之后出现。特别地， &lt;code&gt;M&lt;/code&gt; 的含义取决于它是在 &lt;code&gt;T&lt;/code&gt; 之前还是之后。</target>
        </trans-unit>
        <trans-unit id="d5ac1d279bca8c92d106e249d73c9450bd51985a" translate="yes" xml:space="preserve">
          <source>The string used as &lt;code&gt;NAS Identifier&lt;/code&gt; in the RADIUS requests. This parameter can be used as a second parameter identifying for example which database user the user is attempting to authenticate as, which can be used for policy matching on the RADIUS server. If no identifier is specified, the default &lt;code&gt;postgresql&lt;/code&gt; will be used.</source>
          <target state="translated">在RADIUS请求中用作 &lt;code&gt;NAS Identifier&lt;/code&gt; 的字符串。此参数可以用作第二个参数，例如，用于标识该用户尝试将身份验证为哪个数据库用户，该参数可以用于RADIUS服务器上的策略匹配。如果未指定标识符，将使用默认的 &lt;code&gt;postgresql&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3ee7b9f09ddbdb9488305b75db66d9c52bca23d" translate="yes" xml:space="preserve">
          <source>The string value of an XML element is the concatenation, in document order, of all text nodes contained in that element and its descendants. The string value of an element with no descendant text nodes is an empty string (not &lt;code&gt;NULL&lt;/code&gt;). Any &lt;code&gt;xsi:nil&lt;/code&gt; attributes are ignored. Note that the whitespace-only &lt;code&gt;text()&lt;/code&gt; node between two non-text elements is preserved, and that leading whitespace on a &lt;code&gt;text()&lt;/code&gt; node is not flattened. The XPath 1.0 &lt;code&gt;string&lt;/code&gt; function may be consulted for the rules defining the string value of other XML node types and non-XML values.</source>
          <target state="translated">XML元素的字符串值是按文档顺序串联包含在该元素及其后代中的所有文本节点的。没有后代文本节点的元素的字符串值是一个空字符串（不是 &lt;code&gt;NULL&lt;/code&gt; ）。任何 &lt;code&gt;xsi:nil&lt;/code&gt; 属性都将被忽略。请注意，两个非文本元素之间的 &lt;code&gt;text()&lt;/code&gt; 空白text（）节点被保留，并且 &lt;code&gt;text()&lt;/code&gt; 节点上的前导空白未被展平。可以使用XPath 1.0 &lt;code&gt;string&lt;/code&gt; 函数获取定义其他XML节点类型的字符串值和非XML值的规则。</target>
        </trans-unit>
        <trans-unit id="2fec81f56bf595f634fb57f3910c670ede118c7c" translate="yes" xml:space="preserve">
          <source>The string-literal processor removes one level of backslashes, so that what arrives at the composite-value parser looks like &lt;code&gt;(&quot;\&quot;\\&quot;)&lt;/code&gt;. In turn, the string fed to the &lt;code&gt;text&lt;/code&gt; data type's input routine becomes &lt;code&gt;&quot;\&lt;/code&gt;. (If we were working with a data type whose input routine also treated backslashes specially, &lt;code&gt;bytea&lt;/code&gt; for example, we might need as many as eight backslashes in the command to get one backslash into the stored composite field.) Dollar quoting (see &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-DOLLAR-QUOTING&quot;&gt;Section 4.1.2.4&lt;/a&gt;) can be used to avoid the need to double backslashes.</source>
          <target state="translated">字符串字面量处理器除去一级反斜杠，使得到达复合值解析器的内容类似于 &lt;code&gt;(&quot;\&quot;\\&quot;)&lt;/code&gt; ，而馈送到 &lt;code&gt;text&lt;/code&gt; 数据类型的输入例程的字符串变为 &lt;code&gt;&quot;\&lt;/code&gt; 。（如果使用的数据类型的输入例程也对反斜杠进行了特殊处理，例如 &lt;code&gt;bytea&lt;/code&gt; ，则在命令中可能需要多达8个反斜杠才能使一个反斜杠进入存储的复合字段。）美元报价（请参阅&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-DOLLAR-QUOTING&quot;&gt;第4.1节。 2.4&lt;/a&gt;）可以避免使用双反斜杠。</target>
        </trans-unit>
        <trans-unit id="6422f96b00c11494b4fcf618b39050902cb1b6e9" translate="yes" xml:space="preserve">
          <source>The strings to be used as &lt;code&gt;NAS Identifier&lt;/code&gt; in the RADIUS requests. This parameter can be used, for example, to identify which database cluster the user is attempting to connect to, which can be useful for policy matching on the RADIUS server. If no identifier is specified, the default &lt;code&gt;postgresql&lt;/code&gt; will be used.</source>
          <target state="translated">在RADIUS请求中用作 &lt;code&gt;NAS Identifier&lt;/code&gt; 的字符串。例如，可以使用此参数来标识用户尝试连接到哪个数据库集群，这对于RADIUS服务器上的策略匹配很有用。如果未指定标识符，将使用默认的 &lt;code&gt;postgresql&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b9c21921311be92ddd5f85cbd74e19f06bfbb6a" translate="yes" xml:space="preserve">
          <source>The structure &lt;code&gt;IndexAmRoutine&lt;/code&gt; is defined thus:</source>
          <target state="translated">因此定义了 &lt;code&gt;IndexAmRoutine&lt;/code&gt; 结构：</target>
        </trans-unit>
        <trans-unit id="1b7ec1adb20c9f7f9468502c9f11469bc8e03f67" translate="yes" xml:space="preserve">
          <source>The structure of a query plan is a tree of &lt;em&gt;plan nodes&lt;/em&gt;. Nodes at the bottom level of the tree are scan nodes: they return raw rows from a table. There are different types of scan nodes for different table access methods: sequential scans, index scans, and bitmap index scans. There are also non-table row sources, such as &lt;code&gt;VALUES&lt;/code&gt; clauses and set-returning functions in &lt;code&gt;FROM&lt;/code&gt;, which have their own scan node types. If the query requires joining, aggregation, sorting, or other operations on the raw rows, then there will be additional nodes above the scan nodes to perform these operations. Again, there is usually more than one possible way to do these operations, so different node types can appear here too. The output of &lt;code&gt;EXPLAIN&lt;/code&gt; has one line for each node in the plan tree, showing the basic node type plus the cost estimates that the planner made for the execution of that plan node. Additional lines might appear, indented from the node's summary line, to show additional properties of the node. The very first line (the summary line for the topmost node) has the estimated total execution cost for the plan; it is this number that the planner seeks to minimize.</source>
          <target state="translated">查询计划的结构是&lt;em&gt;计划节点&lt;/em&gt;的树。树底部的节点是扫描节点：它们从表中返回原始行。对于不同的表访问方法，有不同类型的扫描节点：顺序扫描，索引扫描和位图索引扫描。还存在非表行源，例如 &lt;code&gt;FROM&lt;/code&gt; 中的 &lt;code&gt;VALUES&lt;/code&gt; 子句和集返回函数，它们具有自己的扫描节点类型。如果查询需要对原始行进行联接，聚合，排序或其他操作，则扫描节点上方将有其他节点来执行这些操作。同样，通常有不止一种可能的方式来执行这些操作，因此不同的节点类型也会在此处出现。 &lt;code&gt;EXPLAIN&lt;/code&gt; 的输出计划树中的每个节点都有一行，显示基本节点类型以及计划者为执行该计划节点所做的成本估算。从节点的摘要行缩进可能会出现其他行，以显示节点的其他属性。第一行（最顶层节点的摘要行）具有该计划的估计总执行成本；计划者试图使该数字最小化。</target>
        </trans-unit>
        <trans-unit id="845e7bd65e68101aeef835121687192ee5165c8e" translate="yes" xml:space="preserve">
          <source>The sub-statements in &lt;code&gt;WITH&lt;/code&gt; are executed concurrently with each other and with the main query. Therefore, when using data-modifying statements in &lt;code&gt;WITH&lt;/code&gt;, the order in which the specified updates actually happen is unpredictable. All the statements are executed with the same &lt;em&gt;snapshot&lt;/em&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;), so they cannot &amp;ldquo;see&amp;rdquo; one another's effects on the target tables. This alleviates the effects of the unpredictability of the actual order of row updates, and means that &lt;code&gt;RETURNING&lt;/code&gt; data is the only way to communicate changes between different &lt;code&gt;WITH&lt;/code&gt; sub-statements and the main query. An example of this is that in</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; 中的子语句彼此并与主查询并发执行。因此，在 &lt;code&gt;WITH&lt;/code&gt; 中使用数据修改语句时，指定更新实际发生的顺序是不可预测的。所有语句都使用相同的&lt;em&gt;快照&lt;/em&gt;执行（请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;第13章&lt;/a&gt;），因此它们无法&amp;ldquo;看到&amp;rdquo;彼此对目标表的影响。这减轻了行更新实际顺序的不可预测性的影响，并且意味着 &lt;code&gt;RETURNING&lt;/code&gt; 数据是在不同 &lt;code&gt;WITH&lt;/code&gt; 子语句与主查询之间传递更改的唯一途径。一个例子是</target>
        </trans-unit>
        <trans-unit id="12dd874db96a4d69f19603b298f230a8d71acc37" translate="yes" xml:space="preserve">
          <source>The sub-statements in &lt;code&gt;WITH&lt;/code&gt; are executed concurrently with each other and with the main query. Therefore, when using data-modifying statements in &lt;code&gt;WITH&lt;/code&gt;, the order in which the specified updates actually happen is unpredictable. All the statements are executed with the same &lt;em&gt;snapshot&lt;/em&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;), so they cannot &amp;ldquo;see&amp;rdquo; one another's effects on the target tables. This alleviates the effects of the unpredictability of the actual order of row updates, and means that &lt;code&gt;RETURNING&lt;/code&gt; data is the only way to communicate changes between different &lt;code&gt;WITH&lt;/code&gt; sub-statements and the main query. An example of this is that in</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; 中的子语句彼此并与主查询并发执行。因此，在 &lt;code&gt;WITH&lt;/code&gt; 中使用数据修改语句时，指定更新实际发生的顺序是不可预测的。所有语句都使用相同的&lt;em&gt;快照&lt;/em&gt;执行（请参见&lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;第13章&lt;/a&gt;），因此它们无法&amp;ldquo;看到&amp;rdquo;彼此对目标表的影响。这减轻了行更新实际顺序的不可预测性的影响，并且意味着 &lt;code&gt;RETURNING&lt;/code&gt; 数据是在不同 &lt;code&gt;WITH&lt;/code&gt; 子语句与主查询之间传递更改的唯一途径。这方面的一个例子是</target>
        </trans-unit>
        <trans-unit id="b11dad81d612edf5fd0a4215e04a5d2694b81901" translate="yes" xml:space="preserve">
          <source>The subquery can refer to variables from the surrounding query, which will act as constants during any one evaluation of the subquery.</source>
          <target state="translated">子查询可以引用周围查询中的变量,这些变量将在子查询的任何一次计算中作为常量。</target>
        </trans-unit>
        <trans-unit id="9047f1ac499137a7641446b4435a2058e7165f8c" translate="yes" xml:space="preserve">
          <source>The subquery must return a single column. If the subquery's output column is of a non-array type, the resulting one-dimensional array will have an element for each row in the subquery result, with an element type matching that of the subquery's output column. If the subquery's output column is of an array type, the result will be an array of the same type but one higher dimension; in this case all the subquery rows must yield arrays of identical dimensionality, else the result would not be rectangular.</source>
          <target state="translated">子查询必须返回一列。如果子查询的输出列为非数组类型,那么产生的一维数组将为子查询结果中的每一行提供一个元素,元素类型与子查询输出列的元素类型匹配。如果子查询的输出列是一个数组类型,结果将是一个相同类型的数组,但维度更高;在这种情况下,所有的子查询行必须产生维度相同的数组,否则结果将不是矩形的。</target>
        </trans-unit>
        <trans-unit id="ad9a65e976a88e8f391a32410934cda1367df45d" translate="yes" xml:space="preserve">
          <source>The subquery will generally only be executed long enough to determine whether at least one row is returned, not all the way to completion. It is unwise to write a subquery that has side effects (such as calling sequence functions); whether the side effects occur might be unpredictable.</source>
          <target state="translated">子查询的执行时间一般只够确定是否至少返回一条记录,而不是一直执行到完成。编写一个有副作用的子查询是不明智的(比如调用序列函数),副作用是否发生可能是无法预料的。</target>
        </trans-unit>
        <trans-unit id="68c9d90ab99dc33425ce7d63877e33bcb6f1a254" translate="yes" xml:space="preserve">
          <source>The subscriber also requires the &lt;code&gt;max_replication_slots&lt;/code&gt; to be set. In this case it should be set to at least the number of subscriptions that will be added to the subscriber. &lt;code&gt;max_logical_replication_workers&lt;/code&gt; must be set to at least the number of subscriptions, again plus some reserve for the table synchronization. Additionally the &lt;code&gt;max_worker_processes&lt;/code&gt; may need to be adjusted to accommodate for replication workers, at least (&lt;code&gt;max_logical_replication_workers&lt;/code&gt; + &lt;code&gt;1&lt;/code&gt;). Note that some extensions and parallel queries also take worker slots from &lt;code&gt;max_worker_processes&lt;/code&gt;.</source>
          <target state="translated">订户还需要设置 &lt;code&gt;max_replication_slots&lt;/code&gt; 。在这种情况下，应至少将其设置为将添加到订户的订阅数。必须将 &lt;code&gt;max_logical_replication_workers&lt;/code&gt; 至少设置为预订数，再加上一些表同步保留空间。另外，该 &lt;code&gt;max_worker_processes&lt;/code&gt; 可能需要被调整，以适应用于复制工作者，至少（ &lt;code&gt;max_logical_replication_workers&lt;/code&gt; + &lt;code&gt;1&lt;/code&gt; ）。请注意，某些扩展和并行查询还占用 &lt;code&gt;max_worker_processes&lt;/code&gt; 中的工作器插槽。</target>
        </trans-unit>
        <trans-unit id="5061f785b5ca16b03e284f2d1ce17b7eeda1d830" translate="yes" xml:space="preserve">
          <source>The subscriber database behaves in the same way as any other PostgreSQL instance and can be used as a publisher for other databases by defining its own publications.</source>
          <target state="translated">订阅者数据库的行为方式与任何其他PostgreSQL实例相同,并且可以通过定义自己的出版物作为其他数据库的发布者。</target>
        </trans-unit>
        <trans-unit id="53e109de41793b3722661641499539600ee95867" translate="yes" xml:space="preserve">
          <source>The subscription apply process will run in the local database with the privileges of a superuser.</source>
          <target state="translated">订阅申请过程将以超级用户的权限在本地数据库中运行。</target>
        </trans-unit>
        <trans-unit id="4cb7abebeb2fd700c8b2ec617037c9667107f4c0" translate="yes" xml:space="preserve">
          <source>The subscription is added using &lt;a href=&quot;sql-createsubscription&quot;&gt;CREATE SUBSCRIPTION&lt;/a&gt; and can be stopped/resumed at any time using the &lt;a href=&quot;sql-altersubscription&quot;&gt;ALTER SUBSCRIPTION&lt;/a&gt; command and removed using &lt;a href=&quot;sql-dropsubscription&quot;&gt;DROP SUBSCRIPTION&lt;/a&gt;.</source>
          <target state="translated">可以使用&lt;a href=&quot;sql-createsubscription&quot;&gt;CREATE SUBSCRIPTION&lt;/a&gt;添加预订，并且可以随时使用&lt;a href=&quot;sql-altersubscription&quot;&gt;ALTER SUBSCRIPTION&lt;/a&gt;命令停止/恢复该预订，并使用&lt;a href=&quot;sql-dropsubscription&quot;&gt;DROP SUBSCRIPTION&lt;/a&gt;将该预订删除。</target>
        </trans-unit>
        <trans-unit id="121044a7fb76fda9e0fbc21177fe11d696a1b02d" translate="yes" xml:space="preserve">
          <source>The subscription represents a replication connection to the publisher. As such this command does not only add definitions in the local catalogs but also creates a replication slot on the publisher.</source>
          <target state="translated">订阅代表了与发布者的复制连接。因此,该命令不仅在本地目录中添加定义,而且还在发布者上创建复制槽。</target>
        </trans-unit>
        <trans-unit id="48011fd4928d8a9744bee30b18454a7d53e6f680" translate="yes" xml:space="preserve">
          <source>The subscripts of an array value built with &lt;code&gt;ARRAY&lt;/code&gt; always begin with one. For more information about arrays, see &lt;a href=&quot;arrays&quot;&gt;Section 8.15&lt;/a&gt;.</source>
          <target state="translated">用 &lt;code&gt;ARRAY&lt;/code&gt; 构建的数组值的下标始终以1开头。有关数组的更多信息，请参见&lt;a href=&quot;arrays&quot;&gt;第8.15节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2334c3c5a694ddeb266347a848900f44f0cab917" translate="yes" xml:space="preserve">
          <source>The summarizing structure is bound in size by &lt;code&gt;maintenance_work_mem&lt;/code&gt;. In order to ensure that there is no more than a 2% probability of failure to detect an inconsistency for each heap tuple that should be represented in the index, approximately 2 bytes of memory are needed per tuple. As less memory is made available per tuple, the probability of missing an inconsistency slowly increases. This approach limits the overhead of verification significantly, while only slightly reducing the probability of detecting a problem, especially for installations where verification is treated as a routine maintenance task. Any single absent or malformed tuple has a new opportunity to be detected with each new verification attempt.</source>
          <target state="translated">汇总结构的大小受 &lt;code&gt;maintenance_work_mem&lt;/code&gt; 约束。为了确保对于应该在索引中表示的每个堆元组检测到不一致的失败概率不超过2％，每个元组大约需要2个字节的内存。随着每个元组可用内存的减少，丢失不一致的可能性会逐渐增加。这种方法极大地限制了验证的开销，同时仅稍微降低了发现问题的可能性，特别是对于将验证视为日常维护任务的安装而言。任何单个不存在或格式错误的元组都有一个新的机会，可以通过每次新的验证尝试来检测。</target>
        </trans-unit>
        <trans-unit id="aa2efac8a5cca33663d7c228751b90df82bafbc8" translate="yes" xml:space="preserve">
          <source>The switch file &lt;code&gt;/var/lib/pgsql/backup_in_progress&lt;/code&gt; is created first, enabling archiving of completed WAL files to occur. After the backup the switch file is removed. Archived WAL files are then added to the backup so that both base backup and all required WAL files are part of the same tar file. Please remember to add error handling to your backup scripts.</source>
          <target state="translated">首先创建切换文件 &lt;code&gt;/var/lib/pgsql/backup_in_progress&lt;/code&gt; ，从而可以对完整的WAL文件进行存档。备份后，将删除交换文件。然后将已归档的WAL文件添加到备份中，以便基本备份和所有必需的WAL文件都属于同一tar文件。请记住要在备份脚本中添加错误处理。</target>
        </trans-unit>
        <trans-unit id="87700f6e1446d98115cf77b5305bf6c280312a5f" translate="yes" xml:space="preserve">
          <source>The symbol shown in the column &amp;ldquo;Condition Name&amp;rdquo; is the condition name to use in PL/pgSQL. Condition names can be written in either upper or lower case. (Note that PL/pgSQL does not recognize warning, as opposed to error, condition names; those are classes 00, 01, and 02.)</source>
          <target state="translated">&amp;ldquo;条件名称&amp;rdquo;列中显示的符号是要在PL / pgSQL中使用的条件名称。条件名称可以大写或小写。（请注意，PL / pgSQL无法识别警告，而不是错误的条件名称；它们是类00、01和02。）</target>
        </trans-unit>
        <trans-unit id="af2af0e19179d988e1c5bb09182f6b8329bf33d2" translate="yes" xml:space="preserve">
          <source>The synchronization workers are taken from the pool defined by &lt;code&gt;max_logical_replication_workers&lt;/code&gt;.</source>
          <target state="translated">同步工作程序来自 &lt;code&gt;max_logical_replication_workers&lt;/code&gt; 定义的池。</target>
        </trans-unit>
        <trans-unit id="9ff2f915045408cc48aad6178d8c49b4353ee6d4" translate="yes" xml:space="preserve">
          <source>The synchronous states of standby servers can be viewed using the &lt;code&gt;pg_stat_replication&lt;/code&gt; view.</source>
          <target state="translated">备用服务器的同步状态可以使用 &lt;code&gt;pg_stat_replication&lt;/code&gt; 视图查看。</target>
        </trans-unit>
        <trans-unit id="f8f8b505ce05315e1a17e36787d4eec3e6ea7c76" translate="yes" xml:space="preserve">
          <source>The syntax</source>
          <target state="translated">语法</target>
        </trans-unit>
        <trans-unit id="8f181461d9c844d09a197734c97365af11fec6c2" translate="yes" xml:space="preserve">
          <source>The syntax for &lt;code&gt;CREATE TABLE&lt;/code&gt; allows the exact size of arrays to be specified, for example:</source>
          <target state="translated">&lt;code&gt;CREATE TABLE&lt;/code&gt; 的语法允许指定数组的确切大小，例如：</target>
        </trans-unit>
        <trans-unit id="966dbee44492fe4c1ad689fb4503c9e542bc2d3e" translate="yes" xml:space="preserve">
          <source>The syntax for a function call is the name of a function (possibly qualified with a schema name), followed by its argument list enclosed in parentheses:</source>
          <target state="translated">函数调用的语法是函数的名称(可能用模式名称来限定),后面是括号中的参数列表。</target>
        </trans-unit>
        <trans-unit id="9827946ae401eb6c51ab3afdb1c21f5055ada0b5" translate="yes" xml:space="preserve">
          <source>The syntax for ordered-set aggregates allows &lt;code&gt;VARIADIC&lt;/code&gt; to be specified for both the last direct parameter and the last aggregated (&lt;code&gt;WITHIN GROUP&lt;/code&gt;) parameter. However, the current implementation restricts use of &lt;code&gt;VARIADIC&lt;/code&gt; in two ways. First, ordered-set aggregates can only use &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt;, not other variadic array types. Second, if the last direct parameter is &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt;, then there can be only one aggregated parameter and it must also be &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt;. (In the representation used in the system catalogs, these two parameters are merged into a single &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; item, since &lt;code&gt;pg_proc&lt;/code&gt; cannot represent functions with more than one &lt;code&gt;VARIADIC&lt;/code&gt; parameter.) If the aggregate is a hypothetical-set aggregate, the direct arguments that match the &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; parameter are the hypothetical ones; any preceding parameters represent additional direct arguments that are not constrained to match the aggregated arguments.</source>
          <target state="translated">有序集合聚合的语法允许为最后一个直接参数和最后一个聚合（ &lt;code&gt;WITHIN GROUP&lt;/code&gt; ）参数指定 &lt;code&gt;VARIADIC&lt;/code&gt; 。但是，当前的实现方式从两个方面限制了 &lt;code&gt;VARIADIC&lt;/code&gt; 的使用。首先，有序集合聚合只能使用 &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; ，不能使用其他可变参数数组类型。其次，如果最后一个直接参数是 &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; ，则只能有一个聚合参数，并且也必须是 &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; 。 （在系统目录中使用的表示形式中，由于 &lt;code&gt;pg_proc&lt;/code&gt; ，这两个参数合并为单个 &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; 项不能与多于一个的表示功能的 &lt;code&gt;VARIADIC&lt;/code&gt; 参数）如果聚合是假设设定的聚集体，匹配的是，直接参数。 &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; 参数是假想的人; 前面的任何参数都表示其他直接参数，这些参数不受约束以匹配聚合参数。</target>
        </trans-unit>
        <trans-unit id="d86a8075f285a9e5f082a7c58f078a97fe87d56b" translate="yes" xml:space="preserve">
          <source>The syntax is comparable to &lt;code&gt;CREATE TABLE&lt;/code&gt;, except that only field names and types can be specified; no constraints (such as &lt;code&gt;NOT NULL&lt;/code&gt;) can presently be included. Note that the &lt;code&gt;AS&lt;/code&gt; keyword is essential; without it, the system will think a different kind of &lt;code&gt;CREATE TYPE&lt;/code&gt; command is meant, and you will get odd syntax errors.</source>
          <target state="translated">该语法与 &lt;code&gt;CREATE TABLE&lt;/code&gt; 相似，但只能指定字段名称和类型。目前没有约束（例如 &lt;code&gt;NOT NULL&lt;/code&gt; ）。注意， &lt;code&gt;AS&lt;/code&gt; 关键字是必不可少的。没有它，系统会认为这意味着使用另一种 &lt;code&gt;CREATE TYPE&lt;/code&gt; 命令，并且您会得到奇怪的语法错误。</target>
        </trans-unit>
        <trans-unit id="42c058b9d6546225c3baf16e3e4b8ff07bce7ea0" translate="yes" xml:space="preserve">
          <source>The syntax of constants for the numeric types is described in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS&quot;&gt;Section 4.1.2&lt;/a&gt;. The numeric types have a full set of corresponding arithmetic operators and functions. Refer to &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;Chapter 9&lt;/a&gt; for more information. The following sections describe the types in detail.</source>
          <target state="translated">有关数字类型的常量语法，请参见&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS&quot;&gt;第4.1.2节&lt;/a&gt;。数值类型具有全套对应的算术运算符和函数。有关更多信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;第9章&lt;/a&gt;。以下各节详细介绍了这些类型。</target>
        </trans-unit>
        <trans-unit id="066ef2160f0ee25b4e61a233c1f3a6f5f1cba268" translate="yes" xml:space="preserve">
          <source>The syntax of constants for the numeric types is described in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS&quot;&gt;Section 4.1.2&lt;/a&gt;. The numeric types have a full set of corresponding arithmetic operators and functions. Refer to &lt;a href=&quot;https://www.postgresql.org/docs/13/functions.html&quot;&gt;Chapter 9&lt;/a&gt; for more information. The following sections describe the types in detail.</source>
          <target state="translated">有关数字类型的常量语法，请参见&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS&quot;&gt;第4.1.2节&lt;/a&gt;。数值类型具有一整套对应的算术运算符和函数。有关更多信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/13/functions.html&quot;&gt;第9章&lt;/a&gt;。以下各节详细介绍了这些类型。</target>
        </trans-unit>
        <trans-unit id="3602bbafe5a0054bbc62eb9c26f3d0a2eca852d1" translate="yes" xml:space="preserve">
          <source>The syntax of the &lt;a href=&quot;sql-select#SQL-WHERE&quot;&gt;&lt;code&gt;WHERE&lt;/code&gt; Clause&lt;/a&gt; is</source>
          <target state="translated">&lt;a href=&quot;sql-select#SQL-WHERE&quot;&gt; &lt;code&gt;WHERE&lt;/code&gt; 子句&lt;/a&gt;的语法是</target>
        </trans-unit>
        <trans-unit id="256ca2bba9fef3ff251261724a6f5b0ce7b90218" translate="yes" xml:space="preserve">
          <source>The syntax of the &lt;a href=&quot;sql-select#SQL-WHERE&quot;&gt;&lt;code&gt;WHERE&lt;/code&gt;&lt;/a&gt; clause is</source>
          <target state="translated">&lt;a href=&quot;sql-select#SQL-WHERE&quot;&gt; &lt;code&gt;WHERE&lt;/code&gt; &lt;/a&gt;子句的语法是</target>
        </trans-unit>
        <trans-unit id="8203a94af84f4e0e580fcba3501f0b24c27a5840" translate="yes" xml:space="preserve">
          <source>The syntax of the &lt;code&gt;CREATE INDEX&lt;/code&gt; command normally requires writing parentheses around index expressions, as shown in the second example. The parentheses can be omitted when the expression is just a function call, as in the first example.</source>
          <target state="translated">&lt;code&gt;CREATE INDEX&lt;/code&gt; 命令的语法通常需要在索引表达式周围写括号，如第二个示例所示。如第一个示例中所示，当表达式只是函数调用时，可以省略括号。</target>
        </trans-unit>
        <trans-unit id="c241abd813b7161dcc7e86ad91e10959de152091" translate="yes" xml:space="preserve">
          <source>The syntax of this command is similar to that of the SQL &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; command. All options other than the data source/destination are as specified for &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt;. Because of this, special parsing rules apply to the &lt;code&gt;\copy&lt;/code&gt; meta-command. Unlike most other meta-commands, the entire remainder of the line is always taken to be the arguments of &lt;code&gt;\copy&lt;/code&gt;, and neither variable interpolation nor backquote expansion are performed in the arguments.</source>
          <target state="translated">该命令的语法类似于SQL &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt;命令的语法。除数据源/目的地以外的所有选项均已为&lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt;指定。因此，特殊的解析规则适用于 &lt;code&gt;\copy&lt;/code&gt; 元命令。与大多数其他元命令不同，该行的其余部分始终被视为 &lt;code&gt;\copy&lt;/code&gt; 的参数，并且在参数中均未执行变量插值或反引号扩展。</target>
        </trans-unit>
        <trans-unit id="cd8d680d5b62b13099c9e19bc923e563b07e6d19" translate="yes" xml:space="preserve">
          <source>The syntax used so far requires you to remember the order of the columns. An alternative syntax allows you to list the columns explicitly:</source>
          <target state="translated">目前使用的语法要求你记住列的顺序。另一种语法允许你明确地列出各列。</target>
        </trans-unit>
        <trans-unit id="033030a62bda22a5de4a5aeea859f2505dc5e730" translate="yes" xml:space="preserve">
          <source>The syntax with &lt;code&gt;ORDER BY&lt;/code&gt; in the parameter list creates a special type of aggregate called an &lt;em&gt;ordered-set aggregate&lt;/em&gt;; or if &lt;code&gt;HYPOTHETICAL&lt;/code&gt; is specified, then a &lt;em&gt;hypothetical-set aggregate&lt;/em&gt; is created. These aggregates operate over groups of sorted values in order-dependent ways, so that specification of an input sort order is an essential part of a call. Also, they can have &lt;em&gt;direct&lt;/em&gt; arguments, which are arguments that are evaluated only once per aggregation rather than once per input row. Hypothetical-set aggregates are a subclass of ordered-set aggregates in which some of the direct arguments are required to match, in number and data types, the aggregated argument columns. This allows the values of those direct arguments to be added to the collection of aggregate-input rows as an additional &amp;ldquo;hypothetical&amp;rdquo; row.</source>
          <target state="translated">参数列表中带有 &lt;code&gt;ORDER BY&lt;/code&gt; 的语法会创建一种特殊的聚合类型，称为&lt;em&gt;有序集聚合&lt;/em&gt;；或者，如果指定了 &lt;code&gt;HYPOTHETICAL&lt;/code&gt; ，则创建一个&lt;em&gt;假设集合&lt;/em&gt;。这些聚合以顺序相关的方式对排序值的组进行操作，因此指定输入排序顺序是调用的必要部分。而且，他们可以&lt;em&gt;直接&lt;/em&gt;arguments，是每个聚合仅计算一次的参数，而不是每个输入行仅计算一次的参数。假设集聚合是有序集聚合的子类，其中一些直接参数需要在数量和数据类型上与聚合参数列匹配。这允许将这些直接参数的值添加到集合输入行的集合中，作为附加的&amp;ldquo;假设&amp;rdquo;行。</target>
        </trans-unit>
        <trans-unit id="3670cc6e37bfe2baa6c265184cfb9070b0da0ca9" translate="yes" xml:space="preserve">
          <source>The syntaxes using &lt;code&gt;*&lt;/code&gt; are used for calling parameter-less aggregate functions as window functions, for example &lt;code&gt;count(*) OVER (PARTITION BY x ORDER BY y)&lt;/code&gt;. The asterisk (&lt;code&gt;*&lt;/code&gt;) is customarily not used for window-specific functions. Window-specific functions do not allow &lt;code&gt;DISTINCT&lt;/code&gt; or &lt;code&gt;ORDER BY&lt;/code&gt; to be used within the function argument list.</source>
          <target state="translated">使用 &lt;code&gt;*&lt;/code&gt; 的语法用于将无参数聚合函数用作窗口函数，例如 &lt;code&gt;count(*) OVER (PARTITION BY x ORDER BY y)&lt;/code&gt; 。星号（ &lt;code&gt;*&lt;/code&gt; ）通常不用于特定于窗口的功能。窗口特定的函数不允许在函数参数列表中使用 &lt;code&gt;DISTINCT&lt;/code&gt; 或 &lt;code&gt;ORDER BY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5413e5588ef7474b4153013c25aed37daf2b6ac4" translate="yes" xml:space="preserve">
          <source>The system catalog &lt;code&gt;pg_language&lt;/code&gt; (see &lt;a href=&quot;catalog-pg-language&quot;&gt;Section 51.29&lt;/a&gt;) records information about the currently installed languages. Also, the psql command &lt;code&gt;\dL&lt;/code&gt; lists the installed languages.</source>
          <target state="translated">系统目录 &lt;code&gt;pg_language&lt;/code&gt; （请参阅&lt;a href=&quot;catalog-pg-language&quot;&gt;第51.29节&lt;/a&gt;）记录有关当前安装语言的信息。同样，psql命令 &lt;code&gt;\dL&lt;/code&gt; 列出了已安装的语言。</target>
        </trans-unit>
        <trans-unit id="2583bf948cb2199416aaa963439f3392af0c4543" translate="yes" xml:space="preserve">
          <source>The system catalog cache code (and most catalog-munging code in general) assumes that the fixed-length portions of all system catalog tuples are in fact present, because it maps this C struct declaration onto them. Thus, all variable-length fields and nullable fields must be placed at the end, and they cannot be accessed as struct fields. For example, if you tried to set &lt;code&gt;pg_type&lt;/code&gt;.&lt;code&gt;typrelid&lt;/code&gt; to be NULL, it would fail when some piece of code tried to reference &lt;code&gt;typetup-&amp;gt;typrelid&lt;/code&gt; (or worse, &lt;code&gt;typetup-&amp;gt;typelem&lt;/code&gt;, because that follows &lt;code&gt;typrelid&lt;/code&gt;). This would result in random errors or even segmentation violations.</source>
          <target state="translated">系统目录高速缓存代码（通常是大多数使用目录查询的代码）假定实际上所有系统目录元组的固定长度部分都存在，因为它将此C结构声明映射到它们上。因此，所有可变长度字段和可为空的字段必须放在末尾，并且不能将它们作为结构字段访问。例如，如果您尝试设置 &lt;code&gt;pg_type&lt;/code&gt; 。 &lt;code&gt;typrelid&lt;/code&gt; 为NULL，当某些代码尝试引用 &lt;code&gt;typetup-&amp;gt;typrelid&lt;/code&gt; （或更糟糕的是， &lt;code&gt;typetup-&amp;gt;typelem&lt;/code&gt; ，因为在 &lt;code&gt;typrelid&lt;/code&gt; 之后）时，它将失败。这将导致随机错误，甚至会导致细分违规。</target>
        </trans-unit>
        <trans-unit id="bb485f21372d37054b0b92886fc6889e8d0f2f48" translate="yes" xml:space="preserve">
          <source>The system catalog schema, &lt;code&gt;pg_catalog&lt;/code&gt;, is always searched, whether it is mentioned in the path or not. If it is mentioned in the path then it will be searched in the specified order. If &lt;code&gt;pg_catalog&lt;/code&gt; is not in the path then it will be searched &lt;em&gt;before&lt;/em&gt; searching any of the path items.</source>
          <target state="translated">无论是否在路径中提及，始终都会搜索系统目录架构 &lt;code&gt;pg_catalog&lt;/code&gt; 。如果在路径中提到它，则将以指定顺序对其进行搜索。如果 &lt;code&gt;pg_catalog&lt;/code&gt; 不在路径中，则将&lt;em&gt;在&lt;/em&gt;搜索任何路径项&lt;em&gt;之前&lt;/em&gt;对其进行搜索。</target>
        </trans-unit>
        <trans-unit id="dffb9af79cadde8378337d566688f00f092c9630" translate="yes" xml:space="preserve">
          <source>The system catalogs store information about which conversions, or &lt;em&gt;casts&lt;/em&gt;, exist between which data types, and how to perform those conversions. Additional casts can be added by the user with the &lt;a href=&quot;sql-createcast&quot;&gt;CREATE CAST&lt;/a&gt; command. (This is usually done in conjunction with defining new data types. The set of casts between built-in types has been carefully crafted and is best not altered.)</source>
          <target state="translated">系统目录存储有关在哪些数据类型之间存在哪些转换或&lt;em&gt;强制转换&lt;/em&gt;以及如何执行这些转换的信息。用户可以使用&lt;a href=&quot;sql-createcast&quot;&gt;CREATE CAST&lt;/a&gt;命令添加其他强制转换。（这通常与定义新的数据类型一起完成。内置类型之间的强制类型转换集已经过精心设计，最好不要更改。）</target>
        </trans-unit>
        <trans-unit id="94541a873b2d451108de2b46c0592e4902bdbb36" translate="yes" xml:space="preserve">
          <source>The system uses no more than &lt;code&gt;NAMEDATALEN&lt;/code&gt;-1 bytes of an identifier; longer names can be written in commands, but they will be truncated. By default, &lt;code&gt;NAMEDATALEN&lt;/code&gt; is 64 so the maximum identifier length is 63 bytes. If this limit is problematic, it can be raised by changing the &lt;code&gt;NAMEDATALEN&lt;/code&gt; constant in &lt;code&gt;src/include/pg_config_manual.h&lt;/code&gt;.</source>
          <target state="translated">系统使用的标识符不超过 &lt;code&gt;NAMEDATALEN&lt;/code&gt; -1个字节；较长的名称可以写在命令中，但是会被截断。默认情况下， &lt;code&gt;NAMEDATALEN&lt;/code&gt; 为64，因此最大标识符长度为63个字节。如果此限制有问题，可以通过更改 &lt;code&gt;src/include/pg_config_manual.h&lt;/code&gt; 中的 &lt;code&gt;NAMEDATALEN&lt;/code&gt; 常量来提高此限制。</target>
        </trans-unit>
        <trans-unit id="18aee9967e71bb22ca6c7ef97d956490785417e5" translate="yes" xml:space="preserve">
          <source>The system view &lt;a href=&quot;view-pg-file-settings&quot;&gt;&lt;code&gt;pg_file_settings&lt;/code&gt;&lt;/a&gt; can be helpful for pre-testing changes to the configuration files, or for diagnosing problems if a SIGHUP signal did not have the desired effects.</source>
          <target state="translated">系统视图&lt;a href=&quot;view-pg-file-settings&quot;&gt; &lt;code&gt;pg_file_settings&lt;/code&gt; &lt;/a&gt;有助于预先测试对配置文件的更改，或者在SIGHUP信号未达到预期效果时诊断问题。</target>
        </trans-unit>
        <trans-unit id="51af27f0b42d0a59cf04312463422fdaffc06293" translate="yes" xml:space="preserve">
          <source>The system view &lt;a href=&quot;view-pg-hba-file-rules&quot;&gt;&lt;code&gt;pg_hba_file_rules&lt;/code&gt;&lt;/a&gt; can be helpful for pre-testing changes to the &lt;code&gt;pg_hba.conf&lt;/code&gt; file, or for diagnosing problems if loading of the file did not have the desired effects. Rows in the view with non-null &lt;code&gt;error&lt;/code&gt; fields indicate problems in the corresponding lines of the file.</source>
          <target state="translated">系统视图&lt;a href=&quot;view-pg-hba-file-rules&quot;&gt; &lt;code&gt;pg_hba_file_rules&lt;/code&gt; &lt;/a&gt;有助于预先测试对 &lt;code&gt;pg_hba.conf&lt;/code&gt; 文件的更改，或者在文件加载未达到预期效果时诊断问题。视图中带有非空 &lt;code&gt;error&lt;/code&gt; 字段的行指示文件相应行中的问题。</target>
        </trans-unit>
        <trans-unit id="0d1a0c3c602b5e69816adbc6a5f72656d7deb220" translate="yes" xml:space="preserve">
          <source>The system-wide startup file is named &lt;code&gt;psqlrc&lt;/code&gt; and is sought in the installation's &amp;ldquo;system configuration&amp;rdquo; directory, which is most reliably identified by running &lt;code&gt;pg_config --sysconfdir&lt;/code&gt;. By default this directory will be &lt;code&gt;../etc/&lt;/code&gt; relative to the directory containing the PostgreSQL executables. The name of this directory can be set explicitly via the &lt;code&gt;PGSYSCONFDIR&lt;/code&gt; environment variable.</source>
          <target state="translated">系统范围的启动文件名为 &lt;code&gt;psqlrc&lt;/code&gt; ，可在安装的&amp;ldquo;系统配置&amp;rdquo;目录中查找，该目录可通过运行 &lt;code&gt;pg_config --sysconfdir&lt;/code&gt; 来最可靠地标识。默认情况下，该目录相对于包含PostgreSQL可执行文件的目录为 &lt;code&gt;../etc/&lt;/code&gt; 。可以通过 &lt;code&gt;PGSYSCONFDIR&lt;/code&gt; 环境变量显式设置此目录的名称。</target>
        </trans-unit>
        <trans-unit id="d9987d6e81d602450ad224137a711661462f4308" translate="yes" xml:space="preserve">
          <source>The table also shows that PostgreSQL's Repeatable Read implementation does not allow phantom reads. Stricter behavior is permitted by the SQL standard: the four isolation levels only define which phenomena must not happen, not which phenomena &lt;em&gt;must&lt;/em&gt; happen. The behavior of the available isolation levels is detailed in the following subsections.</source>
          <target state="translated">该表还显示PostgreSQL的Repeatable Read实现不允许幻像读取。 SQL标准允许更严格的行为：四个隔离级别仅定义哪些现象一定不能发生，而不是哪些现象&lt;em&gt;必须&lt;/em&gt;发生。以下各小节详细介绍了可用隔离级别的行为。</target>
        </trans-unit>
        <trans-unit id="142b69e02a67de00ba841f641f5ef3fa34a277d2" translate="yes" xml:space="preserve">
          <source>The table definition above includes a primary key specification. This is useful to protect against accidentally importing the same information twice. The &lt;code&gt;COPY&lt;/code&gt; command commits all of the data it imports at one time, so any error will cause the entire import to fail. If you import a partial log file and later import the file again when it is complete, the primary key violation will cause the import to fail. Wait until the log is complete and closed before importing. This procedure will also protect against accidentally importing a partial line that hasn't been completely written, which would also cause &lt;code&gt;COPY&lt;/code&gt; to fail.</source>
          <target state="translated">上面的表定义包括一个主键规范。这对于防止两次意外导入相同信息很有用。在 &lt;code&gt;COPY&lt;/code&gt; 命令提交所有它导入一次数据，因此任何错误都将导致整个导入失败。如果导入部分日志文件，然后在完成后再次导入该文件，则主键冲突将导致导入失败。等待直到日志完成并关闭，然后再导入。此过程还可以防止意外导入尚未完全写入的部分行，这也将导致 &lt;code&gt;COPY&lt;/code&gt; 失败。</target>
        </trans-unit>
        <trans-unit id="990156ac1571d648e7c5aa23d608c8979b58753e" translate="yes" xml:space="preserve">
          <source>The table is also vacuumed if the number of tuples inserted since the last vacuum has exceeded the defined insert threshold, which is defined as:</source>
          <target state="translated">如果自上次抽真空后插入的元组数量超过了定义的插入阈值,表也会被抽真空,这个阈值定义为:。</target>
        </trans-unit>
        <trans-unit id="8b15dacbb7afc519b6433f93ec4919614f65b399" translate="yes" xml:space="preserve">
          <source>The table is partitioned by explicitly listing which key values appear in each partition.</source>
          <target state="translated">通过明确列出每个分区中出现的键值,对表进行分区。</target>
        </trans-unit>
        <trans-unit id="b51488835cbb40ee5da1ee3d9a8f7864d4b57976" translate="yes" xml:space="preserve">
          <source>The table is partitioned by specifying a modulus and a remainder for each partition. Each partition will hold the rows for which the hash value of the partition key divided by the specified modulus will produce the specified remainder.</source>
          <target state="translated">通过为每个分区指定一个模数和一个余数来对表进行分区。每一个分区都将存放分区键的散列值除以指定的模数将产生指定余数的行。</target>
        </trans-unit>
        <trans-unit id="7c5e839b9bae27b38d6af54b60ca56e0b347f0f2" translate="yes" xml:space="preserve">
          <source>The table is partitioned into &amp;ldquo;ranges&amp;rdquo; defined by a key column or set of columns, with no overlap between the ranges of values assigned to different partitions. For example, one might partition by date ranges, or by ranges of identifiers for particular business objects.</source>
          <target state="translated">该表被划分为由一个键列或一组列定义的&amp;ldquo;范围&amp;rdquo;，分配给不同分区的值的范围之间没有重叠。例如，可以按日期范围或特定业务对象的标识符范围进行分区。</target>
        </trans-unit>
        <trans-unit id="292e8b677c187c4d68b1ebe250d22a32e9af8561" translate="yes" xml:space="preserve">
          <source>The table or index that the described column belongs to</source>
          <target state="translated">所述列所属的表或索引。</target>
        </trans-unit>
        <trans-unit id="d142b3cf8f5a90793004bbdd69de61322293bd63" translate="yes" xml:space="preserve">
          <source>The table referenced by a referential integrity constraint</source>
          <target state="translated">引用完整性约束所引用的表。</target>
        </trans-unit>
        <trans-unit id="2a8191ca3a1df3ed6d1e85b59a92238d8c6f7d14" translate="yes" xml:space="preserve">
          <source>The table this column belongs to</source>
          <target state="translated">此列所属的表</target>
        </trans-unit>
        <trans-unit id="75cfe910e753a5d9a7438e22a49cad2342942a50" translate="yes" xml:space="preserve">
          <source>The table this constraint is on; 0 if not a table constraint</source>
          <target state="translated">该约束所在的表;如果不是表约束,则为0。</target>
        </trans-unit>
        <trans-unit id="2f088db11eed75527c26721e5e66e62e0678aeb6" translate="yes" xml:space="preserve">
          <source>The table this rule is for</source>
          <target state="translated">这条规则所针对的表格</target>
        </trans-unit>
        <trans-unit id="ac24dc8d3f1364ef3223d38811cd0f1cdfc7bc70" translate="yes" xml:space="preserve">
          <source>The table this trigger is on</source>
          <target state="translated">触发器所在的表</target>
        </trans-unit>
        <trans-unit id="d2d2364aa6d119df4f431f30d6909fa91ae4a412" translate="yes" xml:space="preserve">
          <source>The table to which the policy applies</source>
          <target state="translated">该政策所适用的表格</target>
        </trans-unit>
        <trans-unit id="539b9dae513896d5721c3d82785ae25ab4799ccf" translate="yes" xml:space="preserve">
          <source>The tables added to a publication that publishes &lt;code&gt;UPDATE&lt;/code&gt; and/or &lt;code&gt;DELETE&lt;/code&gt; operations must have &lt;code&gt;REPLICA IDENTITY&lt;/code&gt; defined. Otherwise those operations will be disallowed on those tables.</source>
          <target state="translated">添加到发布中以发布 &lt;code&gt;UPDATE&lt;/code&gt; 和/或 &lt;code&gt;DELETE&lt;/code&gt; 操作的表必须定义为 &lt;code&gt;REPLICA IDENTITY&lt;/code&gt; 。否则，这些操作将在这些表上被禁止。</target>
        </trans-unit>
        <trans-unit id="367460ef7d1ca64d14464409850a0a51a7ab7dc7" translate="yes" xml:space="preserve">
          <source>The tables are matched between the publisher and the subscriber using the fully qualified table name. Replication to differently-named tables on the subscriber is not supported.</source>
          <target state="translated">表在发布者和订阅者之间使用完全限定的表名进行匹配。不支持在订阅者上向不同名称的表复制。</target>
        </trans-unit>
        <trans-unit id="f3c0314798fd15f5ed903ef71976f9e615a0bb52" translate="yes" xml:space="preserve">
          <source>The tablespace associated with a database is used to store the system catalogs of that database. Furthermore, it is the default tablespace used for tables, indexes, and temporary files created within the database, if no &lt;code&gt;TABLESPACE&lt;/code&gt; clause is given and no other selection is specified by &lt;code&gt;default_tablespace&lt;/code&gt; or &lt;code&gt;temp_tablespaces&lt;/code&gt; (as appropriate). If a database is created without specifying a tablespace for it, it uses the same tablespace as the template database it is copied from.</source>
          <target state="translated">与数据库关联的表空间用于存储该数据库的系统目录。此外，如果未提供 &lt;code&gt;TABLESPACE&lt;/code&gt; 子句，并且 &lt;code&gt;default_tablespace&lt;/code&gt; 或 &lt;code&gt;temp_tablespaces&lt;/code&gt; （视情况而定）未指定其他选择，则它是用于在数据库内创建的表，索引和临时文件的默认表空间。如果创建数据库时未为其指定表空间，则该数据库将使用与其复制的模板数据库相同的表空间。</target>
        </trans-unit>
        <trans-unit id="cd0a83e9744372d73f37f6c31fa32edd33e0f557" translate="yes" xml:space="preserve">
          <source>The tablespace in which this relation is stored. If zero, the database's default tablespace is implied. (Not meaningful if the relation has no on-disk file.)</source>
          <target state="translated">存储此关系的表空间。如果为零,则暗示数据库的默认表空间。(如果关系中没有磁盘文件,则没有意义。)</target>
        </trans-unit>
        <trans-unit id="91ace69fa784c06e03e2d35b1b8ec1909d7a7501" translate="yes" xml:space="preserve">
          <source>The tablespace in which to create the index. If not specified, &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; is consulted, or &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt; for indexes on temporary tables.</source>
          <target state="translated">在其中创建索引的表空间。如果未指定，将查询&lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt;或&lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt;以获取临时表上的索引。</target>
        </trans-unit>
        <trans-unit id="6945a89a0355036aac3b6ff63ff9fc68b1cb28a4" translate="yes" xml:space="preserve">
          <source>The tablespace to which the index will be moved.</source>
          <target state="translated">索引将被移动到的表空间。</target>
        </trans-unit>
        <trans-unit id="2fdf7a817dfba5e9f0aef01d7a04fe1bad9896f5" translate="yes" xml:space="preserve">
          <source>The tag, if any, of a dollar-quoted string follows the same rules as an unquoted identifier, except that it cannot contain a dollar sign. Tags are case sensitive, so &lt;code&gt;$tag$String content$tag$&lt;/code&gt; is correct, but &lt;code&gt;$TAG$String content$tag$&lt;/code&gt; is not.</source>
          <target state="translated">用美元引号的字符串的标签（如果有）遵循与未引用标识符相同的规则，不同之处在于它不能包含美元符号。标签区分大小写，因此 &lt;code&gt;$tag$String content$tag$&lt;/code&gt; 是正确的，但 &lt;code&gt;$TAG$String content$tag$&lt;/code&gt; 不是。</target>
        </trans-unit>
        <trans-unit id="bef8aba7a1bcf650d04e76e3a3595346989e8039" translate="yes" xml:space="preserve">
          <source>The target column names can be listed in any order. If no list of column names is given at all, the default is all the columns of the table in their declared order; or the first &lt;code&gt;N&lt;/code&gt; column names, if there are only &lt;code&gt;N&lt;/code&gt; columns supplied by the &lt;code&gt;VALUES&lt;/code&gt; clause or &lt;code&gt;query&lt;/code&gt;. The values supplied by the &lt;code&gt;VALUES&lt;/code&gt; clause or &lt;code&gt;query&lt;/code&gt; are associated with the explicit or implicit column list left-to-right.</source>
          <target state="translated">目标列名称可以按任何顺序列出。如果根本没有给出任何列名列表，则默认值为表中所有列的声明顺序；否则为默认值。或前 &lt;code&gt;N&lt;/code&gt; 个列名（如果 &lt;code&gt;VALUES&lt;/code&gt; 子句或 &lt;code&gt;query&lt;/code&gt; 仅提供 &lt;code&gt;N&lt;/code&gt; 个列）。 &lt;code&gt;VALUES&lt;/code&gt; 子句或 &lt;code&gt;query&lt;/code&gt; 提供的值与从左到右的显式或隐式列列表相关联。</target>
        </trans-unit>
        <trans-unit id="a52fa4d647d2a0e534fa04140c4a0531834e1437" translate="yes" xml:space="preserve">
          <source>The target function can be specified by name alone, or by name and arguments, for example &lt;code&gt;foo(integer, text)&lt;/code&gt;. The argument types must be given if there is more than one function of the same name.</source>
          <target state="translated">目标函数可以仅通过名称指定，也可以通过名称和参数指定，例如 &lt;code&gt;foo(integer, text)&lt;/code&gt; 。如果有多个同名函数，则必须给出参数类型。</target>
        </trans-unit>
        <trans-unit id="6a83f3ee2747bb5a0ebf49f8f4cc7233f65fe3b6" translate="yes" xml:space="preserve">
          <source>The task of the &lt;em&gt;planner/optimizer&lt;/em&gt; is to create an optimal execution plan. A given SQL query (and hence, a query tree) can be actually executed in a wide variety of different ways, each of which will produce the same set of results. If it is computationally feasible, the query optimizer will examine each of these possible execution plans, ultimately selecting the execution plan that is expected to run the fastest.</source>
          <target state="translated">&lt;em&gt;计划者/优化器&lt;/em&gt;的任务是创建最佳执行计划。一个给定的SQL查询（以及一个查询树）实际上可以以多种不同的方式执行，每种方式都会产生相同的结果集。如果在计算上可行，则查询优化器将检查这些可能的执行计划中的每一个，最终选择预期运行最快的执行计划。</target>
        </trans-unit>
        <trans-unit id="d0cfcd2522974bd11b7e720b66ddba5e0dc99d8f" translate="yes" xml:space="preserve">
          <source>The technical difference between a &lt;code&gt;jsonb_ops&lt;/code&gt; and a &lt;code&gt;jsonb_path_ops&lt;/code&gt; GIN index is that the former creates independent index items for each key and value in the data, while the latter creates index items only for each value in the data. &lt;a href=&quot;#ftn.id-1.5.7.22.18.9.3&quot;&gt;&lt;sup id=&quot;id-1.5.7.22.18.9.3&quot;&gt;[6]&lt;/sup&gt;&lt;/a&gt; Basically, each &lt;code&gt;jsonb_path_ops&lt;/code&gt; index item is a hash of the value and the key(s) leading to it; for example to index &lt;code&gt;{&quot;foo&quot;: {&quot;bar&quot;: &quot;baz&quot;}}&lt;/code&gt;, a single index item would be created incorporating all three of &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt;, and &lt;code&gt;baz&lt;/code&gt; into the hash value. Thus a containment query looking for this structure would result in an extremely specific index search; but there is no way at all to find out whether &lt;code&gt;foo&lt;/code&gt; appears as a key. On the other hand, a &lt;code&gt;jsonb_ops&lt;/code&gt; index would create three index items representing &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt;, and &lt;code&gt;baz&lt;/code&gt; separately; then to do the containment query, it would look for rows containing all three of these items. While GIN indexes can perform such an AND search fairly efficiently, it will still be less specific and slower than the equivalent &lt;code&gt;jsonb_path_ops&lt;/code&gt; search, especially if there are a very large number of rows containing any single one of the three index items.</source>
          <target state="translated">&lt;code&gt;jsonb_ops&lt;/code&gt; 和 &lt;code&gt;jsonb_path_ops&lt;/code&gt; GIN索引之间的技术区别在于，前者为数据中的每个键和值创建独立的索引项，而后者仅为数据中的每个值创建索引项。&lt;a href=&quot;#ftn.id-1.5.7.22.18.9.3&quot;&gt;&lt;sup id=&quot;id-1.5.7.22.18.9.3&quot;&gt;[6]&lt;/sup&gt;&lt;/a&gt;基本上，每个 &lt;code&gt;jsonb_path_ops&lt;/code&gt; 索引项都是值和导致它的键的哈希；例如，以索引 &lt;code&gt;{&quot;foo&quot;: {&quot;bar&quot;: &quot;baz&quot;}}&lt;/code&gt; 的索引，将创建单个索引项，将 &lt;code&gt;foo&lt;/code&gt; ， &lt;code&gt;bar&lt;/code&gt; 和 &lt;code&gt;baz&lt;/code&gt; 的所有三个都合并到哈希值中。因此，寻找这种结构的遏制查询将导致极其特定的索引搜索。但是根本无法找出是否 &lt;code&gt;foo&lt;/code&gt; 显示为键。另一方面， &lt;code&gt;jsonb_ops&lt;/code&gt; 索引将创建三个分别表示 &lt;code&gt;foo&lt;/code&gt; ， &lt;code&gt;bar&lt;/code&gt; 和 &lt;code&gt;baz&lt;/code&gt; 的索引项；然后执行包含查询，它将查找包含所有这三个项目的行。尽管GIN索引可以相当有效地执行这样的AND搜索，但它仍然比等效的 &lt;code&gt;jsonb_path_ops&lt;/code&gt; 搜索更不具体，并且运行速度也更慢，尤其是当包含三个索引项中的任何一个的行非常多时。</target>
        </trans-unit>
        <trans-unit id="1c8f7bc59665b224be12f558ca16a9e07627bb77" translate="yes" xml:space="preserve">
          <source>The temporary table will be dropped at the end of the current transaction block.</source>
          <target state="translated">临时表将在当前事务块结束时被丢弃。</target>
        </trans-unit>
        <trans-unit id="2e88ee252852e295414cf3850a24be66c227bee2" translate="yes" xml:space="preserve">
          <source>The temporary table will be dropped at the end of the current transaction block. When used on a partitioned table, this action drops its partitions and when used on tables with inheritance children, it drops the dependent children.</source>
          <target state="translated">临时表将在当前事务块结束时被放弃。当用于分区表时,该操作会放弃其分区,当用于有继承子代的表时,会放弃附属子代。</target>
        </trans-unit>
        <trans-unit id="544789fd88fe85a89dc95a84868e683fa382498a" translate="yes" xml:space="preserve">
          <source>The term attribute is equivalent to column and is used for historical reasons.</source>
          <target state="translated">属性一词相当于列,由于历史原因使用。</target>
        </trans-unit>
        <trans-unit id="a4a7c2d2771e24236d6f1bdd6761fd668754e8bc" translate="yes" xml:space="preserve">
          <source>The text representation of an &lt;code&gt;hstore&lt;/code&gt;, used for input and output, includes zero or more &lt;code&gt;key&lt;/code&gt;&lt;code&gt;=&amp;gt;&lt;/code&gt;&lt;code&gt;value&lt;/code&gt; pairs separated by commas. Some examples:</source>
          <target state="translated">用于输入和输出的 &lt;code&gt;hstore&lt;/code&gt; 的文本表示形式包括零个或多个以逗号分隔的 &lt;code&gt;key&lt;/code&gt; &lt;code&gt;=&amp;gt;&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; 对。一些例子：</target>
        </trans-unit>
        <trans-unit id="98a0a387ebcc73eb1a002f76f9873cf6168a1347" translate="yes" xml:space="preserve">
          <source>The text-search functionality in PostgreSQL can also be used to speed up full-document searches of XML data. The necessary preprocessing support is, however, not yet available in the PostgreSQL distribution.</source>
          <target state="translated">PostgreSQL中的文本搜索功能也可以用来加快XML数据的全文档搜索。然而,PostgreSQL发行版中还没有提供必要的预处理支持。</target>
        </trans-unit>
        <trans-unit id="9535cead63cebae1ff29d54da604a76ade0e73e1" translate="yes" xml:space="preserve">
          <source>The textual label for this enum value</source>
          <target state="translated">该枚举值的文字标签</target>
        </trans-unit>
        <trans-unit id="5d79225bbaf1bc36cb45016180fd38042b31a872" translate="yes" xml:space="preserve">
          <source>The thesaurus dictionary &lt;code&gt;thesaurus_astro&lt;/code&gt; does know the phrase &lt;code&gt;supernovae stars&lt;/code&gt;, but &lt;code&gt;ts_lexize&lt;/code&gt; fails since it does not parse the input text but treats it as a single token. Use &lt;code&gt;plainto_tsquery&lt;/code&gt; or &lt;code&gt;to_tsvector&lt;/code&gt; to test thesaurus dictionaries, for example:</source>
          <target state="translated">词库词典 &lt;code&gt;thesaurus_astro&lt;/code&gt; 确实知道短语 &lt;code&gt;supernovae stars&lt;/code&gt; ，但 &lt;code&gt;ts_lexize&lt;/code&gt; 失败，因为它不解析输入文本，而是将其视为单个标记。使用 &lt;code&gt;plainto_tsquery&lt;/code&gt; 或 &lt;code&gt;to_tsvector&lt;/code&gt; 测试同义词库词典，例如：</target>
        </trans-unit>
        <trans-unit id="497ebaef7c7bb30921967269b6dd4bfd06472628" translate="yes" xml:space="preserve">
          <source>The thesaurus dictionary chooses the longest match if there are multiple phrases matching the input, and ties are broken by using the last definition.</source>
          <target state="translated">如果有多个短语与输入相匹配,词库词典会选择最长的匹配,使用最后一个定义来打破平局。</target>
        </trans-unit>
        <trans-unit id="6384b1615ea61227de680b163bce3c7f613d4849" translate="yes" xml:space="preserve">
          <source>The third form changes the owner of the database. To alter the owner, you must own the database and also be a direct or indirect member of the new owning role, and you must have the &lt;code&gt;CREATEDB&lt;/code&gt; privilege. (Note that superusers have all these privileges automatically.)</source>
          <target state="translated">第三种形式更改数据库的所有者。要更改所有者，您必须拥有数据库并且还必须是新拥有角色的直接或间接成员，并且您必须具有 &lt;code&gt;CREATEDB&lt;/code&gt; 特权。（请注意，超级用户会自动拥有所有这些特权。）</target>
        </trans-unit>
        <trans-unit id="fb3a4f1cf7c17f675b6c88c65b759e2c18503d10" translate="yes" xml:space="preserve">
          <source>The third form of &lt;code&gt;CREATE TYPE&lt;/code&gt; creates a new range type, as described in &lt;a href=&quot;rangetypes&quot;&gt;Section 8.17&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;CREATE TYPE&lt;/code&gt; 的第三种形式创建了一个新的范围类型，如&lt;a href=&quot;rangetypes&quot;&gt;第8.17节&lt;/a&gt;所述。</target>
        </trans-unit>
        <trans-unit id="46e5d7ec29a414875ddb7427a1366569e134347d" translate="yes" xml:space="preserve">
          <source>The third parameter being &lt;code&gt;false&lt;/code&gt; tells &lt;code&gt;pg_start_backup&lt;/code&gt; to initiate a non-exclusive base backup.</source>
          <target state="translated">第三个参数为 &lt;code&gt;false&lt;/code&gt; 告诉 &lt;code&gt;pg_start_backup&lt;/code&gt; 启动非排他的基本备份。</target>
        </trans-unit>
        <trans-unit id="43c4f141a3275bbc30bab46035e573f420cd4242" translate="yes" xml:space="preserve">
          <source>The third syntax was used before PostgreSQL version 9.6 and is still supported. It's the same as the first syntax with &lt;code&gt;FIRST&lt;/code&gt; and &lt;code&gt;num_sync&lt;/code&gt; equal to 1. For example, &lt;code&gt;FIRST 1 (s1, s2)&lt;/code&gt; and &lt;code&gt;s1, s2&lt;/code&gt; have the same meaning: either &lt;code&gt;s1&lt;/code&gt; or &lt;code&gt;s2&lt;/code&gt; is chosen as a synchronous standby.</source>
          <target state="translated">第三种语法在PostgreSQL 9.6版之前使用，现在仍然受支持。它与 &lt;code&gt;FIRST&lt;/code&gt; 和 &lt;code&gt;num_sync&lt;/code&gt; 等于1 的第一种语法相同。例如， &lt;code&gt;FIRST 1 (s1, s2)&lt;/code&gt; 和 &lt;code&gt;s1, s2&lt;/code&gt; 具有相同的含义：选择 &lt;code&gt;s1&lt;/code&gt; 或 &lt;code&gt;s2&lt;/code&gt; 作为同步备用数据库。</target>
        </trans-unit>
        <trans-unit id="bce8828bcc021e862db732b17b8f2b754b34f3cc" translate="yes" xml:space="preserve">
          <source>The third variant changes the name of the group. This is exactly equivalent to renaming the role with &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt;.</source>
          <target state="translated">第三个变体更改组的名称。这完全等同于使用&lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt;重命名角色。</target>
        </trans-unit>
        <trans-unit id="e2d943d4346301a5cf1de51eecfb3a352a414893" translate="yes" xml:space="preserve">
          <source>The time at which the cursor was declared</source>
          <target state="translated">光标被声明的时间</target>
        </trans-unit>
        <trans-unit id="ec4185f356c4ef6086071a2e178362bf4f8c1b5e" translate="yes" xml:space="preserve">
          <source>The time at which the prepared statement was created</source>
          <target state="translated">编制报表的时间</target>
        </trans-unit>
        <trans-unit id="ffd5bbf754455019459a28dd71a5db592d1e512d" translate="yes" xml:space="preserve">
          <source>The time fields in a transition rule have the same format as the offset fields described previously, except that they cannot contain signs. They define the current local time at which the change to the other time occurs. If omitted, they default to &lt;code&gt;02:00:00&lt;/code&gt;.</source>
          <target state="translated">过渡规则中的时间字段与前面描述的偏移字段具有相同的格式，只是它们不能包含符号。它们定义了更改为其他时间的当前本地时间。如果省略，则默认为 &lt;code&gt;02:00:00&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0e8bb2f344559ea1d916061668ce3e9aa5b7836" translate="yes" xml:space="preserve">
          <source>The time zone 7 hours west from UTC (equivalent to PDT). Positive values are east from UTC.</source>
          <target state="translated">从UTC向西7小时的时区(相当于PDT)。正值为UTC以东。</target>
        </trans-unit>
        <trans-unit id="ee80f641d8eab20953a3190cfb6422152c737dea" translate="yes" xml:space="preserve">
          <source>The time zone 8 hours west from UTC (equivalent to PST).</source>
          <target state="translated">从UTC向西8小时的时区(相当于PST)。</target>
        </trans-unit>
        <trans-unit id="3d03995667dbda87e63122260f5c6f6cb9fe649a" translate="yes" xml:space="preserve">
          <source>The time zone for Berkeley, California.</source>
          <target state="translated">加州伯克利的时区。</target>
        </trans-unit>
        <trans-unit id="668f3cdec134bede84a934a9af41142895f7b007" translate="yes" xml:space="preserve">
          <source>The time zone for Italy.</source>
          <target state="translated">意大利的时区。</target>
        </trans-unit>
        <trans-unit id="c7ed4ff2c6ce4f9a9cd61b96f6374cf02812e246" translate="yes" xml:space="preserve">
          <source>The time zone offset from UTC, measured in seconds. Positive values correspond to time zones east of UTC, negative values to zones west of UTC. (Technically, PostgreSQL does not use UTC because leap seconds are not handled.)</source>
          <target state="translated">与UTC的时区偏移,以秒为单位。正值对应UTC以东的时区,负值对应UTC以西的时区。(从技术上讲,PostgreSQL不使用UTC,因为不处理闰秒。)</target>
        </trans-unit>
        <trans-unit id="0ca5243d8e51420e24c77cdd1c3e577fee34053c" translate="yes" xml:space="preserve">
          <source>The time-of-day types are &lt;code&gt;time [ (p) ] without time zone&lt;/code&gt; and &lt;code&gt;time [ (p) ] with time zone&lt;/code&gt;. &lt;code&gt;time&lt;/code&gt; alone is equivalent to &lt;code&gt;time without time zone&lt;/code&gt;.</source>
          <target state="translated">时间-日期的类型是 &lt;code&gt;time [ (p) ] without time zone&lt;/code&gt; 和 &lt;code&gt;time [ (p) ] with time zone&lt;/code&gt; 。光是 &lt;code&gt;time&lt;/code&gt; 就等于 &lt;code&gt;time without time zone&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="404ebb0f442feebec6561a16038577c2da51bc2d" translate="yes" xml:space="preserve">
          <source>The timeline for this range of WAL records, as an integer.</source>
          <target state="translated">这个范围的WAL记录的时间线,为整数。</target>
        </trans-unit>
        <trans-unit id="14e09ea608f1f50e50cadf98aabc877a7444e25e" translate="yes" xml:space="preserve">
          <source>The timeout is measured from the time a command arrives at the server until it is completed by the server. If multiple SQL statements appear in a single simple-Query message, the timeout is applied to each statement separately. (PostgreSQL versions before 13 usually treated the timeout as applying to the whole query string.) In extended query protocol, the timeout starts running when any query-related message (Parse, Bind, Execute, Describe) arrives, and it is canceled by completion of an Execute or Sync message.</source>
          <target state="translated">超时是从命令到达服务器到服务器完成为止。如果在一个简单查询消息中出现多条SQL语句,超时将分别应用于每条语句。(PostgreSQL 13之前的版本通常将超时处理为应用于整个查询字符串。)在扩展查询协议中,当任何与查询相关的消息(Parse、Bind、Execute、Describe)到达时,超时就开始运行,并通过完成Execute或Sync消息而取消。</target>
        </trans-unit>
        <trans-unit id="41de03730261b036dd783f63ba08317d9d3e641d" translate="yes" xml:space="preserve">
          <source>The timeout is measured from the time a command arrives at the server until it is completed by the server. In extended query protocol, the timeout starts running when any query-related message (Parse, Bind, Execute, Describe) arrives, and it is cancelled by completion of an Execute or Sync message.</source>
          <target state="translated">超时是从一个命令到达服务器到服务器完成为止的时间来衡量的。在扩展查询协议中,当任何与查询相关的消息(Parse、Bind、Execute、Describe)到达时,超时就开始运行,并通过完成Execute或Sync消息而被取消。</target>
        </trans-unit>
        <trans-unit id="1f30fb914124c09d41ba75a819d8afdbb3ea8c79" translate="yes" xml:space="preserve">
          <source>The toast_tuple_target specifies the minimum tuple length required before we try to compress and/or move long column values into TOAST tables, and is also the target length we try to reduce the length below once toasting begins. This affects columns marked as External (for move), Main (for compression), or Extended (for both) and applies only to new tuples. There is no effect on existing rows. By default this parameter is set to allow at least 4 tuples per block, which with the default block size will be 2040 bytes. Valid values are between 128 bytes and the (block size - header), by default 8160 bytes. Changing this value may not be useful for very short or very long rows. Note that the default setting is often close to optimal, and it is possible that setting this parameter could have negative effects in some cases. This parameter cannot be set for TOAST tables.</source>
          <target state="translated">toast_tuple_target指定了在我们尝试压缩和/或将长列值移动到TOAST表中之前所需的最小元组长度,也是我们在开始烤表后尝试将长度减少到以下的目标长度。这将影响标记为External(用于移动)、Main(用于压缩)或Extended(用于两者)的列,并且只适用于新元组。对现有行没有影响。默认情况下,该参数被设置为每个块至少允许4个元组,默认块大小为2040字节。有效值在128字节和(块大小-头)之间,默认为8160字节。改变这个值对于非常短或非常长的行可能没有用。需要注意的是,默认设置往往接近于最佳值,在某些情况下,设置这个参数有可能会产生负面影响。对于TOAST表不能设置此参数。</target>
        </trans-unit>
        <trans-unit id="d98b14f1fa1ca6a1d2cfd5fbd83b532ce899e731" translate="yes" xml:space="preserve">
          <source>The toast_tuple_target specifies the minimum tuple length required before we try to move long column values into TOAST tables, and is also the target length we try to reduce the length below once toasting begins. This only affects columns marked as either External or Extended and applies only to new tuples - there is no effect on existing rows. By default this parameter is set to allow at least 4 tuples per block, which with the default blocksize will be 2040 bytes. Valid values are between 128 bytes and the (blocksize - header), by default 8160 bytes. Changing this value may not be useful for very short or very long rows. Note that the default setting is often close to optimal, and it is possible that setting this parameter could have negative effects in some cases. This parameter cannot be set for TOAST tables.</source>
          <target state="translated">toast_tuple_target指定了在我们尝试将长列值移入TOAST表之前所需的最小元组长度,同时也是我们在开始烤表后尝试将长度减少到以下的目标长度。这只影响标记为External或Extended的列,并且只适用于新的元组--对现有行没有影响。默认情况下,该参数被设置为每个块至少允许4个元组,默认块大小为2040字节。有效值在128字节和(blocksize-header)之间,默认为8160字节。改变这个值对于非常短或非常长的行可能没有用。需要注意的是,默认设置往往接近于最佳值,在某些情况下,设置这个参数有可能会产生负面影响。对于TOAST表不能设置此参数。</target>
        </trans-unit>
        <trans-unit id="621d22a0cd204d89633ad09943ee84f1181db01e" translate="yes" xml:space="preserve">
          <source>The total number of columns in the index (duplicates &lt;code&gt;pg_class.relnatts&lt;/code&gt;); this number includes both key and included attributes</source>
          <target state="translated">索引中的总列数（重复 &lt;code&gt;pg_class.relnatts&lt;/code&gt; ）；此数字同时包含关键属性和包含的属性</target>
        </trans-unit>
        <trans-unit id="f560f36dfc9d943beeddde2257c0e1b305d7ee85" translate="yes" xml:space="preserve">
          <source>The transaction ID epoch is not actually stored anywhere in the database except in the field that is set by &lt;code&gt;pg_resetwal&lt;/code&gt;, so any value will work so far as the database itself is concerned. You might need to adjust this value to ensure that replication systems such as Slony-I and Skytools work correctly &amp;mdash; if so, an appropriate value should be obtainable from the state of the downstream replicated database.</source>
          <target state="translated">除了 &lt;code&gt;pg_resetwal&lt;/code&gt; 设置的字段之外，事务ID纪元实际上没有存储在数据库中的任何位置，因此，只要涉及数据库本身，任何值都将起作用。您可能需要调整该值，以确保诸如Slony-I和Skytools之类的复制系统正常工作-如果可以，则应从下游复制数据库的状态中获取适当的值。</target>
        </trans-unit>
        <trans-unit id="5c3634c8a4a4ce9f542309bb5a4cc86011569d07" translate="yes" xml:space="preserve">
          <source>The transaction access mode determines whether the transaction is read/write or read-only. Read/write is the default. When a transaction is read-only, the following SQL commands are disallowed: &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, and &lt;code&gt;COPY FROM&lt;/code&gt; if the table they would write to is not a temporary table; all &lt;code&gt;CREATE&lt;/code&gt;, &lt;code&gt;ALTER&lt;/code&gt;, and &lt;code&gt;DROP&lt;/code&gt; commands; &lt;code&gt;COMMENT&lt;/code&gt;, &lt;code&gt;GRANT&lt;/code&gt;, &lt;code&gt;REVOKE&lt;/code&gt;, &lt;code&gt;TRUNCATE&lt;/code&gt;; and &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; and &lt;code&gt;EXECUTE&lt;/code&gt; if the command they would execute is among those listed. This is a high-level notion of read-only that does not prevent all writes to disk.</source>
          <target state="translated">事务访问模式确定事务是读/写还是只读。读/写是默认设置。当事务为只读时，不允许使用以下SQL命令： &lt;code&gt;INSERT&lt;/code&gt; ， &lt;code&gt;UPDATE&lt;/code&gt; ， &lt;code&gt;DELETE&lt;/code&gt; 和 &lt;code&gt;COPY FROM&lt;/code&gt; ,如果它们要写入的表不是临时表；所有 &lt;code&gt;CREATE&lt;/code&gt; ， &lt;code&gt;ALTER&lt;/code&gt; 和 &lt;code&gt;DROP&lt;/code&gt; 命令； &lt;code&gt;COMMENT&lt;/code&gt; ， &lt;code&gt;GRANT&lt;/code&gt; ， &lt;code&gt;REVOKE&lt;/code&gt; ， &lt;code&gt;TRUNCATE&lt;/code&gt; ; 并解释 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 并 &lt;code&gt;EXECUTE&lt;/code&gt; 如果他们要执行的命令在列出的命令中。这是只读的高级概念，不会阻止所有对磁盘的写入。</target>
        </trans-unit>
        <trans-unit id="75f4c782782aa478238329da73889aa36680137b" translate="yes" xml:space="preserve">
          <source>The transaction identifier of the transaction that is to be committed.</source>
          <target state="translated">要提交的交易的交易标识符。</target>
        </trans-unit>
        <trans-unit id="cf987258f7d6ba8e2728a7ab480e418085360e38" translate="yes" xml:space="preserve">
          <source>The transaction identifier of the transaction that is to be rolled back.</source>
          <target state="translated">要回滚的交易的交易标识符。</target>
        </trans-unit>
        <trans-unit id="9eeef0c349968aef779233f9f813d33249bc7a83" translate="yes" xml:space="preserve">
          <source>The transaction isolation level cannot be changed after the first query or data-modification statement (&lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;FETCH&lt;/code&gt;, or &lt;code&gt;COPY&lt;/code&gt;) of a transaction has been executed. See &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt; for more information about transaction isolation and concurrency control.</source>
          <target state="translated">在执行事务的第一个查询或数据修改语句（ &lt;code&gt;SELECT&lt;/code&gt; ， &lt;code&gt;INSERT&lt;/code&gt; ， &lt;code&gt;DELETE&lt;/code&gt; ， &lt;code&gt;UPDATE&lt;/code&gt; ， &lt;code&gt;FETCH&lt;/code&gt; 或 &lt;code&gt;COPY&lt;/code&gt; ）之后，不能更改事务隔离级别。有关事务隔离和并发控制的更多信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;第13章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7fe24188c8709c03cdec891a49204bbf4cf162d4" translate="yes" xml:space="preserve">
          <source>The transaction isolation level cannot be changed after the first query or data-modification statement (&lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;FETCH&lt;/code&gt;, or &lt;code&gt;COPY&lt;/code&gt;) of a transaction has been executed. See &lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt; for more information about transaction isolation and concurrency control.</source>
          <target state="translated">在执行事务的第一个查询或数据修改语句（ &lt;code&gt;SELECT&lt;/code&gt; ， &lt;code&gt;INSERT&lt;/code&gt; ， &lt;code&gt;DELETE&lt;/code&gt; ， &lt;code&gt;UPDATE&lt;/code&gt; ， &lt;code&gt;FETCH&lt;/code&gt; 或 &lt;code&gt;COPY&lt;/code&gt; ）之后，不能更改事务隔离级别。有关事务隔离和并发控制的更多信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;第13章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ed3fff67b302c5509e4a3c68f6d878b34bcf063e" translate="yes" xml:space="preserve">
          <source>The transactional behavior of &lt;code&gt;RESET&lt;/code&gt; is the same as &lt;code&gt;SET&lt;/code&gt;: its effects will be undone by transaction rollback.</source>
          <target state="translated">&lt;code&gt;RESET&lt;/code&gt; 的事务行为与 &lt;code&gt;SET&lt;/code&gt; 相同：事务回滚将撤消其影响。</target>
        </trans-unit>
        <trans-unit id="bd74e2a12fdda047e415ded6637d08f54eb6f6c6" translate="yes" xml:space="preserve">
          <source>The translation of login credentials in the local &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; to credentials in a remote data system defined by a &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-DATA-WRAPPER&quot;&gt;foreign data wrapper&lt;/a&gt;.</source>
          <target state="translated">将本地&lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;数据库中&lt;/a&gt;的登录凭据转换为由&lt;a href=&quot;glossary#GLOSSARY-FOREIGN-DATA-WRAPPER&quot;&gt;外部数据包装程序&lt;/a&gt;定义的远程数据系统中的凭据。</target>
        </trans-unit>
        <trans-unit id="75001c08db137e17c60a1922c998f38549cfd962" translate="yes" xml:space="preserve">
          <source>The translations from internal enum values to textual labels are kept in the system catalog &lt;a href=&quot;catalog-pg-enum&quot;&gt;&lt;code&gt;pg_enum&lt;/code&gt;&lt;/a&gt;. Querying this catalog directly can be useful.</source>
          <target state="translated">从内部枚举值到文本标签的转换保存在系统目录&lt;a href=&quot;catalog-pg-enum&quot;&gt; &lt;code&gt;pg_enum&lt;/code&gt; 中&lt;/a&gt;。直接查询该目录可能很有用。</target>
        </trans-unit>
        <trans-unit id="d50a1ac1c4a79cbe553bfb51786402f941c2b3ba" translate="yes" xml:space="preserve">
          <source>The trigger can be specified to fire before the operation is attempted on a row (before constraints are checked and the &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt; is attempted); or after the operation has completed (after constraints are checked and the &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt; has completed); or instead of the operation (in the case of inserts, updates or deletes on a view). If the trigger fires before or instead of the event, the trigger can skip the operation for the current row, or change the row being inserted (for &lt;code&gt;INSERT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; operations only). If the trigger fires after the event, all changes, including the effects of other triggers, are &amp;ldquo;visible&amp;rdquo; to the trigger.</source>
          <target state="translated">可以将触发器指定为在尝试对该行进行操作之前触发（在检查约束并尝试 &lt;code&gt;INSERT&lt;/code&gt; ， &lt;code&gt;UPDATE&lt;/code&gt; 或 &lt;code&gt;DELETE&lt;/code&gt; 之前）；或在操作完成之后（在检查约束并完成 &lt;code&gt;INSERT&lt;/code&gt; ， &lt;code&gt;UPDATE&lt;/code&gt; 或 &lt;code&gt;DELETE&lt;/code&gt; 之后）；或代替操作（对于视图执行插入，更新或删除操作）。如果触发器在事件发生之前或之后触发，则触发器可以跳过当前行的操作，或更改要插入的行（对于 &lt;code&gt;INSERT&lt;/code&gt; 和 &lt;code&gt;UPDATE&lt;/code&gt; 仅操作）。如果触发器在事件发生后触发，则所有更改（包括其他触发器的效果）都对触发器&amp;ldquo;可见&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="360ddad9a8de88b17738a1bfb31175dc0ad50509" translate="yes" xml:space="preserve">
          <source>The trigger definition is the same as before. Note that each &lt;code&gt;IF&lt;/code&gt; test must exactly match the &lt;code&gt;CHECK&lt;/code&gt; constraint for its child table.</source>
          <target state="translated">触发器定义与以前相同。请注意，每个 &lt;code&gt;IF&lt;/code&gt; 测试必须与其子表的 &lt;code&gt;CHECK&lt;/code&gt; 约束完全匹配。</target>
        </trans-unit>
        <trans-unit id="a810fcfc0902003d265053e230960c8ff8fc873c" translate="yes" xml:space="preserve">
          <source>The trigger firing mechanism is also affected by the configuration variable &lt;a href=&quot;runtime-config-client#GUC-SESSION-REPLICATION-ROLE&quot;&gt;session_replication_role&lt;/a&gt;. Simply enabled triggers (the default) will fire when the replication role is &amp;ldquo;origin&amp;rdquo; (the default) or &amp;ldquo;local&amp;rdquo;. Triggers configured as &lt;code&gt;ENABLE REPLICA&lt;/code&gt; will only fire if the session is in &amp;ldquo;replica&amp;rdquo; mode, and triggers configured as &lt;code&gt;ENABLE ALWAYS&lt;/code&gt; will fire regardless of the current replication role.</source>
          <target state="translated">触发器触发机制还受配置变量&lt;a href=&quot;runtime-config-client#GUC-SESSION-REPLICATION-ROLE&quot;&gt;session_replication_role的影响&lt;/a&gt;。当复制角色为&amp;ldquo;原始&amp;rdquo;（默认）或&amp;ldquo;本地&amp;rdquo;时，将启用简单启用的触发器（默认）。仅当会话处于&amp;ldquo;副本&amp;rdquo;模式时，才会触发配置为 &lt;code&gt;ENABLE REPLICA&lt;/code&gt; 的触发器，并且无论当前的复制角色如何，都将触发配置为 &lt;code&gt;ENABLE ALWAYS&lt;/code&gt; 的触发器。</target>
        </trans-unit>
        <trans-unit id="4f53bb9473c53f31ec2630d134ac2ab3b419880a" translate="yes" xml:space="preserve">
          <source>The trigger will only fire if at least one of the listed columns is mentioned as a target of the &lt;code&gt;UPDATE&lt;/code&gt; command or if one of the listed columns is a generated column that depends on a column that is the target of the &lt;code&gt;UPDATE&lt;/code&gt;.</source>
          <target state="translated">仅当至少列出的列之一被提及为 &lt;code&gt;UPDATE&lt;/code&gt; 命令的目标，或者列出的列之一为依赖于作为 &lt;code&gt;UPDATE&lt;/code&gt; 目标的列的生成列时，才会触发触发器。</target>
        </trans-unit>
        <trans-unit id="f9812ac32136a445e04fcdb0d1e4cacff3be7be9" translate="yes" xml:space="preserve">
          <source>The two arguments must be of comparable types. To be specific, they are compared exactly as if you had written &lt;code&gt;value1 = value2&lt;/code&gt;, so there must be a suitable &lt;code&gt;=&lt;/code&gt; operator available.</source>
          <target state="translated">这两个参数必须是可比较的类型。具体来说，它们的比较就像您编写了 &lt;code&gt;value1 = value2&lt;/code&gt; ，因此必须有一个合适的 &lt;code&gt;=&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="33dc8fc66a104f662e1e1ef39564cf253e0b3d0e" translate="yes" xml:space="preserve">
          <source>The two characters must be separated by whitespace, and any leading or trailing whitespace on a line is ignored.</source>
          <target state="translated">这两个字符必须用空格隔开,行上的任何前导或尾部的空格都会被忽略。</target>
        </trans-unit>
        <trans-unit id="76e9af5cad39e06c0aff7fc7950d58905fea1d7b" translate="yes" xml:space="preserve">
          <source>The two common uses of the &lt;code&gt;COLLATE&lt;/code&gt; clause are overriding the sort order in an &lt;code&gt;ORDER BY&lt;/code&gt; clause, for example:</source>
          <target state="translated">&lt;code&gt;COLLATE&lt;/code&gt; 子句的两种常见用法是覆盖 &lt;code&gt;ORDER BY&lt;/code&gt; 子句中的排序顺序，例如：</target>
        </trans-unit>
        <trans-unit id="35a38d5de3cd4f9280a434f729b41435ab278e27" translate="yes" xml:space="preserve">
          <source>The two ranking functions currently available are:</source>
          <target state="translated">目前可用的两种排名功能是:</target>
        </trans-unit>
        <trans-unit id="ce8dc1c8a536536645752666f7fffe721ce60a13" translate="yes" xml:space="preserve">
          <source>The two-parameter form of &lt;code&gt;obj_description&lt;/code&gt; returns the comment for a database object specified by its OID and the name of the containing system catalog. For example, &lt;code&gt;obj_description(123456,'pg_class')&lt;/code&gt; would retrieve the comment for the table with OID 123456. The one-parameter form of &lt;code&gt;obj_description&lt;/code&gt; requires only the object OID. It is deprecated since there is no guarantee that OIDs are unique across different system catalogs; therefore, the wrong comment might be returned.</source>
          <target state="translated">&lt;code&gt;obj_description&lt;/code&gt; 的两参数形式返回由其OID和包含的系统目录的名称指定的数据库对象的注释。例如， &lt;code&gt;obj_description(123456,'pg_class')&lt;/code&gt; 将检索OID为123456的表的注释 &lt;code&gt;obj_description&lt;/code&gt; 的单参数形式仅需要对象OID。不建议使用此方法，因为不能保证OID在不同的系统目录中是唯一的。因此，可能会返回错误的注释。</target>
        </trans-unit>
        <trans-unit id="b4f339ae3cabb76936eb748863a60863a4f4f72e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;integer&lt;/code&gt; is the common choice, as it offers the best balance between range, storage size, and performance. The &lt;code&gt;smallint&lt;/code&gt; type is generally only used if disk space is at a premium. The &lt;code&gt;bigint&lt;/code&gt; type is designed to be used when the range of the &lt;code&gt;integer&lt;/code&gt; type is insufficient.</source>
          <target state="translated">&lt;code&gt;integer&lt;/code&gt; 类型是常见的选择，因为它在范围，存储大小和性能之间提供了最佳的平衡。所述 &lt;code&gt;smallint&lt;/code&gt; 类型如果磁盘空间是非常珍贵的，通常仅使用。的 &lt;code&gt;bigint&lt;/code&gt; 型被设计为当所述的范围内使用 &lt;code&gt;integer&lt;/code&gt; 型是不够的。</target>
        </trans-unit>
        <trans-unit id="73f1593ff9d450e1b3a9d9ecf07b14639511ab2d" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;numeric&lt;/code&gt; can store numbers with a very large number of digits. It is especially recommended for storing monetary amounts and other quantities where exactness is required. Calculations with &lt;code&gt;numeric&lt;/code&gt; values yield exact results where possible, e.g. addition, subtraction, multiplication. However, calculations on &lt;code&gt;numeric&lt;/code&gt; values are very slow compared to the integer types, or to the floating-point types described in the next section.</source>
          <target state="translated">&lt;code&gt;numeric&lt;/code&gt; 类型可以存储具有大量数字的数字。特别建议在需要精确度的情况下存储货币金额和其他数量。在可能的情况下，使用 &lt;code&gt;numeric&lt;/code&gt; 计算会得出准确的结果，例如加，减，乘。但是，与整数类型或下一节中描述的浮点类型相比，对 &lt;code&gt;numeric&lt;/code&gt; 计算非常慢。</target>
        </trans-unit>
        <trans-unit id="d8ef95808394eeedcc4e8f80e7ae1d4796c0832d" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;numeric&lt;/code&gt; can store numbers with a very large number of digits. It is especially recommended for storing monetary amounts and other quantities where exactness is required. Calculations with &lt;code&gt;numeric&lt;/code&gt; values yield exact results where possible, e.g., addition, subtraction, multiplication. However, calculations on &lt;code&gt;numeric&lt;/code&gt; values are very slow compared to the integer types, or to the floating-point types described in the next section.</source>
          <target state="translated">&lt;code&gt;numeric&lt;/code&gt; 类型可以存储具有大量数字的数字。特别建议在需要精确度的情况下存储货币金额和其他数量。在可能的情况下，使用 &lt;code&gt;numeric&lt;/code&gt; 计算会得出准确的结果，例如加法，减法，乘法。但是，与整数类型或下一节中描述的浮点类型相比，对 &lt;code&gt;numeric&lt;/code&gt; 计算非常慢。</target>
        </trans-unit>
        <trans-unit id="793233ae84eec2944804278e0981414a3f21b17d" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;time with time zone&lt;/code&gt; is defined by the SQL standard, but the definition exhibits properties which lead to questionable usefulness. In most cases, a combination of &lt;code&gt;date&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;timestamp without time zone&lt;/code&gt;, and &lt;code&gt;timestamp with time zone&lt;/code&gt; should provide a complete range of date/time functionality required by any application.</source>
          <target state="translated">&lt;code&gt;time with time zone&lt;/code&gt; 类型是由SQL标准定义的，但是该定义显示的属性会导致有用的疑问。在大多数情况下，组合 &lt;code&gt;date&lt;/code&gt; ， &lt;code&gt;time&lt;/code&gt; ， &lt;code&gt;timestamp without time zone&lt;/code&gt; ，和 &lt;code&gt;timestamp with time zone&lt;/code&gt; 应该提供的任何应用程序所需要的日期/时间功能的完整范围。</target>
        </trans-unit>
        <trans-unit id="a7b02ae1d94b05c4445fedeab1d5ea2204949c69" translate="yes" xml:space="preserve">
          <source>The type being created is an array; this specifies the type of the array elements.</source>
          <target state="translated">正在创建的类型是一个数组,这指定了数组元素的类型。</target>
        </trans-unit>
        <trans-unit id="dec7ae5dcf41bac97c38ef83c552012b75a666d1" translate="yes" xml:space="preserve">
          <source>The type names &lt;code&gt;serial&lt;/code&gt; and &lt;code&gt;serial4&lt;/code&gt; are equivalent: both create &lt;code&gt;integer&lt;/code&gt; columns. The type names &lt;code&gt;bigserial&lt;/code&gt; and &lt;code&gt;serial8&lt;/code&gt; work the same way, except that they create a &lt;code&gt;bigint&lt;/code&gt; column. &lt;code&gt;bigserial&lt;/code&gt; should be used if you anticipate the use of more than 2&lt;sup&gt;31&lt;/sup&gt; identifiers over the lifetime of the table. The type names &lt;code&gt;smallserial&lt;/code&gt; and &lt;code&gt;serial2&lt;/code&gt; also work the same way, except that they create a &lt;code&gt;smallint&lt;/code&gt; column.</source>
          <target state="translated">类型名称 &lt;code&gt;serial&lt;/code&gt; 和 &lt;code&gt;serial4&lt;/code&gt; 是等效的：都创建 &lt;code&gt;integer&lt;/code&gt; 列。类型名称 &lt;code&gt;bigserial&lt;/code&gt; 和 &lt;code&gt;serial8&lt;/code&gt; 的工作方式相同，只是它们创建了 &lt;code&gt;bigint&lt;/code&gt; 列。如果您预计在表的生命周期内使用超过2 &lt;sup&gt;31个&lt;/sup&gt;标识符，则应使用 &lt;code&gt;bigserial&lt;/code&gt; 。类型名 &lt;code&gt;smallserial&lt;/code&gt; 和 &lt;code&gt;serial2&lt;/code&gt; 也工作方式相同，不同之处在于他们创造一个 &lt;code&gt;smallint&lt;/code&gt; 列。&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="fe751081daba63125cfc111c4d7f7c5219b07dce" translate="yes" xml:space="preserve">
          <source>The type of a column is referenced by writing &lt;code&gt;table_name.column_name%TYPE&lt;/code&gt;.</source>
          <target state="translated">通过写入 &lt;code&gt;table_name.column_name%TYPE&lt;/code&gt; 来引用列的类型。</target>
        </trans-unit>
        <trans-unit id="c0ea7f76717a65c02b1bddcb00950b7e9f4876d9" translate="yes" xml:space="preserve">
          <source>The type of a column is referenced by writing &lt;code&gt;table_name.column_name%TYPE&lt;/code&gt;. Using this feature can sometimes help make a function independent of changes to the definition of a table.</source>
          <target state="translated">通过写入 &lt;code&gt;table_name.column_name%TYPE&lt;/code&gt; 来引用列的类型。使用此功能有时可以使函数独立于表定义的更改。</target>
        </trans-unit>
        <trans-unit id="b1ec982d03e7790491fadba1642490dfd8fdc55a" translate="yes" xml:space="preserve">
          <source>The type of a column is referenced by writing &lt;code&gt;table_name.column_name%TYPE&lt;/code&gt;. Using this feature can sometimes help make a procedure independent of changes to the definition of a table.</source>
          <target state="translated">通过写入 &lt;code&gt;table_name.column_name%TYPE&lt;/code&gt; 来引用列的类型。使用此功能有时可以使过程独立于表定义的更改。</target>
        </trans-unit>
        <trans-unit id="f1e103307ad05526fdabd013a4e01ed05bfdbdb7" translate="yes" xml:space="preserve">
          <source>The type of event for which the backend is waiting, if any; otherwise NULL. Possible values are:</source>
          <target state="translated">后台正在等待的事件类型,如果有的话;否则为NULL。可能的值是:</target>
        </trans-unit>
        <trans-unit id="a8d405d6c92bbb1fd074ac96c8d3effed9604172" translate="yes" xml:space="preserve">
          <source>The type of event for which the backend is waiting, if any; otherwise NULL. See &lt;a href=&quot;monitoring-stats#WAIT-EVENT-TABLE&quot;&gt;Table 27.4&lt;/a&gt;.</source>
          <target state="translated">后端正在等待的事件类型（如果有）；否则为NULL。请参阅&lt;a href=&quot;monitoring-stats#WAIT-EVENT-TABLE&quot;&gt;表27.4&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9f9f096a38b6430fd5ddb4a740ecb24f54b601d1" translate="yes" xml:space="preserve">
          <source>The type of format conversion to use to produce the format specifier's output. The following types are supported:</source>
          <target state="translated">要使用的格式转换类型,以产生格式指定器的输出。支持以下类型:</target>
        </trans-unit>
        <trans-unit id="1ddd9e551f2a05479f6513f5110e44168eae5ec3" translate="yes" xml:space="preserve">
          <source>The type of object to which this label applies, as text.</source>
          <target state="translated">该标签所适用的对象类型,为文本。</target>
        </trans-unit>
        <trans-unit id="e0efbb84b508511a8c55e93462baf31f477709c2" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;decimal&lt;/code&gt; and &lt;code&gt;numeric&lt;/code&gt; are equivalent. Both types are part of the SQL standard.</source>
          <target state="translated">&lt;code&gt;decimal&lt;/code&gt; 和 &lt;code&gt;numeric&lt;/code&gt; 类型是等效的。这两种类型都是SQL标准的一部分。</target>
        </trans-unit>
        <trans-unit id="929117e51025410290ad9a3ec11af66ca11a1c9b" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;smallint&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;, and &lt;code&gt;bigint&lt;/code&gt; store whole numbers, that is, numbers without fractional components, of various ranges. Attempts to store values outside of the allowed range will result in an error.</source>
          <target state="translated">类型 &lt;code&gt;smallint&lt;/code&gt; ， &lt;code&gt;integer&lt;/code&gt; 和 &lt;code&gt;bigint&lt;/code&gt; 存储整数，即没有小数部分的数字，其范围是不同的。尝试存储超出允许范围的值将导致错误。</target>
        </trans-unit>
        <trans-unit id="f88d1600c2fa8cf210ddde6767edf800fcc4b8ae" translate="yes" xml:space="preserve">
          <source>The unallocated space. New item identifiers are allocated from the start of this area, new items from the end.</source>
          <target state="translated">未分配的空间。新的项目标识符从这个区域开始分配,新的项目从最后分配。</target>
        </trans-unit>
        <trans-unit id="c6ac986319e3f5efca56837ce99d1572cef0217f" translate="yes" xml:space="preserve">
          <source>The underlying data type of the domain. This can include array specifiers.</source>
          <target state="translated">域的基础数据类型。这可以包括数组指定器。</target>
        </trans-unit>
        <trans-unit id="b1d964b1947580871a9afde80dd70168c2a16dc4" translate="yes" xml:space="preserve">
          <source>The union and difference operators will fail if the resulting range would need to contain two disjoint sub-ranges, as such a range cannot be represented.</source>
          <target state="translated">如果产生的范围需要包含两个不相交的子范围,那么联合和差分运算符就会失败,因为这样的范围无法表示。</target>
        </trans-unit>
        <trans-unit id="50b30c7a19cffa1de56e373435e89e8ef50ced95" translate="yes" xml:space="preserve">
          <source>The units kB, MB, GB and TB used by the functions &lt;code&gt;pg_size_pretty&lt;/code&gt; and &lt;code&gt;pg_size_bytes&lt;/code&gt; are defined using powers of 2 rather than powers of 10, so 1kB is 1024 bytes, 1MB is 1024&lt;sup&gt;2&lt;/sup&gt; = 1048576 bytes, and so on.</source>
          <target state="translated">函数 &lt;code&gt;pg_size_pretty&lt;/code&gt; 和 &lt;code&gt;pg_size_bytes&lt;/code&gt; 使用的单位kB，MB，GB和TB 是使用2的幂而不是10的幂定义的，因此1kB是1024字节，1MB是1024 &lt;sup&gt;2&lt;/sup&gt; = 1048576字节，依此类推。</target>
        </trans-unit>
        <trans-unit id="e4ae2c5b2eeaa2e69e79b5cb262b5458e41e3c91" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;=&amp;gt;&lt;/code&gt; as an operator name is deprecated. It may be disallowed altogether in a future release.</source>
          <target state="translated">不建议将 &lt;code&gt;=&amp;gt;&lt;/code&gt; 用作运算符。在将来的版本中可能完全不允许使用它。</target>
        </trans-unit>
        <trans-unit id="5abb8578ec77c7960afe6e04fbf989b69b52b5fe" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;AND&lt;/code&gt; in the &lt;code&gt;BETWEEN&lt;/code&gt; syntax creates an ambiguity with the use of &lt;code&gt;AND&lt;/code&gt; as a logical operator. To resolve this, only a limited set of expression types are allowed as the second argument of a &lt;code&gt;BETWEEN&lt;/code&gt; clause. If you need to write a more complex sub-expression in &lt;code&gt;BETWEEN&lt;/code&gt;, write parentheses around the sub-expression.</source>
          <target state="translated">在 &lt;code&gt;BETWEEN&lt;/code&gt; 语法中使用 &lt;code&gt;AND&lt;/code&gt; 会导致使用 &lt;code&gt;AND&lt;/code&gt; 作为逻辑运算符产生歧义。若要解决此问题，仅允许将一组有限的表达式类型用作 &lt;code&gt;BETWEEN&lt;/code&gt; 子句的第二个参数。如果需要在 &lt;code&gt;BETWEEN&lt;/code&gt; 中编写一个更复杂的子表达式，请在该子表达式的周围写上括号。</target>
        </trans-unit>
        <trans-unit id="93c091c993d1f380ee067cec46b15b6ee688b73b" translate="yes" xml:space="preserve">
          <source>The use of explicit locking can increase the likelihood of &lt;em&gt;deadlocks&lt;/em&gt;, wherein two (or more) transactions each hold locks that the other wants. For example, if transaction 1 acquires an exclusive lock on table A and then tries to acquire an exclusive lock on table B, while transaction 2 has already exclusive-locked table B and now wants an exclusive lock on table A, then neither one can proceed. PostgreSQL automatically detects deadlock situations and resolves them by aborting one of the transactions involved, allowing the other(s) to complete. (Exactly which transaction will be aborted is difficult to predict and should not be relied upon.)</source>
          <target state="translated">使用显式锁定可能会增加&lt;em&gt;死锁&lt;/em&gt;的可能性，其中两个（或更多）事务各自持有对方想要的锁。例如，如果事务1获取表A上的排他锁，然后尝试获取表B上的排他锁，而事务2已经对表B进行排他锁，并且现在想要对表A进行排他锁，那么任何人都无法进行。 PostgreSQL自动检测死锁情况并通过中止所涉及的事务之一来解决它们，从而允许其他事务完成。 （确切地说哪个交易将被中止很难预测，因此不应该依赖。）</target>
        </trans-unit>
        <trans-unit id="8f0b3f4b5acb7da25097931a18b8f5ac621923d3" translate="yes" xml:space="preserve">
          <source>The use of huge pages results in smaller page tables and less CPU time spent on memory management, increasing performance. For more details about using huge pages on Linux, see &lt;a href=&quot;kernel-resources#LINUX-HUGE-PAGES&quot;&gt;Section 18.4.5&lt;/a&gt;.</source>
          <target state="translated">使用大页面可导致页面表更小，并减少用于内存管理的CPU时间，从而提高性能。有关在Linux上使用大页面的更多详细信息，请参见&lt;a href=&quot;kernel-resources#LINUX-HUGE-PAGES&quot;&gt;第18.4.5节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3ce63f397bb5d8284bad24ef82b2459f7b090249" translate="yes" xml:space="preserve">
          <source>The use of this option is obsolete; all command-line options for server processes can be specified directly on the &lt;code&gt;postgres&lt;/code&gt; command line.</source>
          <target state="translated">该选项的使用已过时。服务器进程的所有命令行选项都可以在 &lt;code&gt;postgres&lt;/code&gt; 命令行上直接指定。</target>
        </trans-unit>
        <trans-unit id="09cf7166a8b226caae95159176b66ea236b91cf0" translate="yes" xml:space="preserve">
          <source>The user can select the commit mode of each transaction, so that it is possible to have both synchronous and asynchronous commit transactions running concurrently. This allows flexible trade-offs between performance and certainty of transaction durability. The commit mode is controlled by the user-settable parameter &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt;, which can be changed in any of the ways that a configuration parameter can be set. The mode used for any one transaction depends on the value of &lt;code&gt;synchronous_commit&lt;/code&gt; when transaction commit begins.</source>
          <target state="translated">用户可以选择每个事务的提交模式，以便可以同时运行同步和异步提交事务。这允许在性能和交易持久性的确定性之间进行灵活的权衡。提交模式由用户可设置的参数控制&lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt;，它可以在任何的一个配置参数可以被设置的方式改变。用于任何一个交易的模式取决于的值 &lt;code&gt;synchronous_commit&lt;/code&gt; 当事务提交开始。</target>
        </trans-unit>
        <trans-unit id="58fdb850f0b7e6f4f12d81d3a2ab809c8e564bba" translate="yes" xml:space="preserve">
          <source>The user must have &lt;code&gt;EXECUTE&lt;/code&gt; privilege on the procedure in order to be allowed to invoke it.</source>
          <target state="translated">用户必须对该过程具有 &lt;code&gt;EXECUTE&lt;/code&gt; 特权才能被允许调用它。</target>
        </trans-unit>
        <trans-unit id="c74ba756422b33951733fa9726163bde6e9f1367" translate="yes" xml:space="preserve">
          <source>The user must have &lt;code&gt;USAGE&lt;/code&gt; privilege for the procedural language, or must be a superuser if the language is untrusted. This is the same privilege requirement as for creating a function in the language.</source>
          <target state="translated">用户必须对过程语言具有 &lt;code&gt;USAGE&lt;/code&gt; 特权，或者如果该语言不受信任，则必须是超级用户。这与使用该语言创建函数的特权要求相同。</target>
        </trans-unit>
        <trans-unit id="7355b734bfbb693399b1f5be80a21fc683a4208f" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the domain.</source>
          <target state="translated">域名新主人的用户名。</target>
        </trans-unit>
        <trans-unit id="5b67af9ba18fb81e51e55c777748aa943b2fa8e5" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the event trigger.</source>
          <target state="translated">事件触发器的新主人的用户名。</target>
        </trans-unit>
        <trans-unit id="aba5a7708c66551701c5165cf7ba963ffe31406d" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the foreign server.</source>
          <target state="translated">国外服务器新所有者的用户名。</target>
        </trans-unit>
        <trans-unit id="e794753392792d29db630aab48374584b0d3cb46" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the foreign-data wrapper.</source>
          <target state="translated">国外数据包装器的新所有者的用户名。</target>
        </trans-unit>
        <trans-unit id="9764aeef0fe4bb5d4f2272e77d6962230b353685" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the materialized view.</source>
          <target state="translated">物化视图的新所有者的用户名。</target>
        </trans-unit>
        <trans-unit id="2b0e8f2639c9d0e1c0e8fa04963b62d2820b7705" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the publication.</source>
          <target state="translated">出版物新所有者的用户名。</target>
        </trans-unit>
        <trans-unit id="2288b9ac65364d46e00039d4c94aae751493c3c0" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the sequence.</source>
          <target state="translated">序列的新所有者的用户名。</target>
        </trans-unit>
        <trans-unit id="d54654fb52ccc22d099e9d7662a28009ae6c974d" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the statistics object.</source>
          <target state="translated">统计对象的新所有者的用户名。</target>
        </trans-unit>
        <trans-unit id="c69e3a3d77712ec7eadabb2257570bc879c31fe4" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the subscription.</source>
          <target state="translated">新订阅者的用户名。</target>
        </trans-unit>
        <trans-unit id="6566e54be9aa4e4a755e403ba928be2a78bd2f0e" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the table.</source>
          <target state="translated">表的新主人的用户名。</target>
        </trans-unit>
        <trans-unit id="5465925abc46b022486e34924312d36ae3fb4555" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the type.</source>
          <target state="translated">该类型新所有者的用户名。</target>
        </trans-unit>
        <trans-unit id="a6eb245257eeab851862782e2a923bbc7e47c8d6" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the view.</source>
          <target state="translated">视图的新主人的用户名。</target>
        </trans-unit>
        <trans-unit id="ead32115822b14f6c36ec30a49fc2050b45d7ff6" translate="yes" xml:space="preserve">
          <source>The user name to connect as</source>
          <target state="translated">连接的用户名为</target>
        </trans-unit>
        <trans-unit id="e907b500844d993a9893eddde6a23ad8e157309f" translate="yes" xml:space="preserve">
          <source>The user performing the lock on the view must have the corresponding privilege on the view. In addition the view's owner must have the relevant privileges on the underlying base relations, but the user performing the lock does not need any permissions on the underlying base relations.</source>
          <target state="translated">对视图执行锁定的用户必须在视图上拥有相应的权限。此外,视图的所有者必须在底层的基础关系上拥有相应的权限,但执行锁定的用户不需要在底层的基础关系上拥有任何权限。</target>
        </trans-unit>
        <trans-unit id="7bfd48e694dd153c1235989f4fbd645fdacfec80" translate="yes" xml:space="preserve">
          <source>The user that creates the function becomes the owner of the function.</source>
          <target state="translated">创建函数的用户成为函数的所有者。</target>
        </trans-unit>
        <trans-unit id="96430e1e5477d00f6c76c64e1c8233d8001617e1" translate="yes" xml:space="preserve">
          <source>The user that creates the procedure becomes the owner of the procedure.</source>
          <target state="translated">创建过程的用户成为过程的所有者。</target>
        </trans-unit>
        <trans-unit id="fa24870d0f9c850e93790c8855a7b4579bd41481" translate="yes" xml:space="preserve">
          <source>The user who defines a text search configuration becomes its owner.</source>
          <target state="translated">定义文本搜索配置的用户成为其所有者。</target>
        </trans-unit>
        <trans-unit id="f6d4088ee84ecfa3f7d22aab37f998c942ea2998" translate="yes" xml:space="preserve">
          <source>The user who defines a text search dictionary becomes its owner.</source>
          <target state="translated">定义文本搜索词典的用户成为其所有者。</target>
        </trans-unit>
        <trans-unit id="ba174285d0ec0c6de6eab2554bacc234f431f1f5" translate="yes" xml:space="preserve">
          <source>The user who defines an operator class becomes its owner. Presently, the creating user must be a superuser. (This restriction is made because an erroneous operator class definition could confuse or even crash the server.)</source>
          <target state="translated">定义操作员类的用户成为其所有者。目前,创建用户必须是超级用户。之所以有此限制,是因为错误的操作者类定义可能会使服务器混乱甚至崩溃)。</target>
        </trans-unit>
        <trans-unit id="fbdfed285f07a1cecc02c081ebab06c65c95b2f7" translate="yes" xml:space="preserve">
          <source>The user who defines an operator family becomes its owner. Presently, the creating user must be a superuser. (This restriction is made because an erroneous operator family definition could confuse or even crash the server.)</source>
          <target state="translated">定义操作员族的用户成为其所有者。目前,创建用户必须是超级用户。之所以有此限制,是因为错误的操作族定义可能会使服务器混乱甚至崩溃)。</target>
        </trans-unit>
        <trans-unit id="a72f845d3a0a4dd8ce3bae5ed1b2a783fa9c859b" translate="yes" xml:space="preserve">
          <source>The user who runs &lt;code&gt;CREATE EXTENSION&lt;/code&gt; becomes the owner of the extension for purposes of later privilege checks, and normally also becomes the owner of any objects created by the extension's script.</source>
          <target state="translated">运行 &lt;code&gt;CREATE EXTENSION&lt;/code&gt; 的用户成为扩展的所有者，以进行以后的特权检查，并且通常还成为由扩展的脚本创建的任何对象的所有者。</target>
        </trans-unit>
        <trans-unit id="a49e64af112af0fce66c24196c6a87dd37d8a41a" translate="yes" xml:space="preserve">
          <source>The user's client (frontend) application that wants to perform database operations. Client applications can be very diverse in nature: a client could be a text-oriented tool, a graphical application, a web server that accesses the database to display web pages, or a specialized database maintenance tool. Some client applications are supplied with the PostgreSQL distribution; most are developed by users.</source>
          <target state="translated">要进行数据库操作的用户客户端(前端)应用程序。客户端应用程序的性质可以非常多样化:客户端可以是一个面向文本的工具,一个图形应用程序,一个访问数据库以显示网页的网络服务器,或者一个专门的数据库维护工具。有些客户端应用程序是与PostgreSQL发行版一起提供的;大多数是由用户开发的。</target>
        </trans-unit>
        <trans-unit id="4b80e8348cd40d70e9a3578f00476d222916ac1c" translate="yes" xml:space="preserve">
          <source>The user's personal startup file is named &lt;code&gt;.psqlrc&lt;/code&gt; and is sought in the invoking user's home directory. On Windows, which lacks such a concept, the personal startup file is named &lt;code&gt;%APPDATA%\postgresql\psqlrc.conf&lt;/code&gt;. The location of the user's startup file can be set explicitly via the &lt;code&gt;PSQLRC&lt;/code&gt; environment variable.</source>
          <target state="translated">用户的个人启动文件名为 &lt;code&gt;.psqlrc&lt;/code&gt; ,并在调用用户的主目录中查找。在缺少这种概念的Windows上，个人启动文件名为 &lt;code&gt;%APPDATA%\postgresql\psqlrc.conf&lt;/code&gt; 。可以通过 &lt;code&gt;PSQLRC&lt;/code&gt; 环境变量显式设置用户启动文件的位置。</target>
        </trans-unit>
        <trans-unit id="3920cf489a63459b72dde1b92f7b717a8e6b52fd" translate="yes" xml:space="preserve">
          <source>The user, database, and (client) host items remain the same for the life of the client connection, but the activity indicator changes. The activity can be &lt;code&gt;idle&lt;/code&gt; (i.e., waiting for a client command), &lt;code&gt;idle in transaction&lt;/code&gt; (waiting for client inside a &lt;code&gt;BEGIN&lt;/code&gt; block), or a command type name such as &lt;code&gt;SELECT&lt;/code&gt;. Also, &lt;code&gt;waiting&lt;/code&gt; is appended if the server process is presently waiting on a lock held by another session. In the above example we can infer that process 15606 is waiting for process 15610 to complete its transaction and thereby release some lock. (Process 15610 must be the blocker, because there is no other active session. In more complicated cases it would be necessary to look into the &lt;a href=&quot;view-pg-locks&quot;&gt;&lt;code&gt;pg_locks&lt;/code&gt;&lt;/a&gt; system view to determine who is blocking whom.)</source>
          <target state="translated">在客户端连接的生命周期内，用户，数据库和（客户端）主机项保持不变，但活动指示器会更改。活动可以是 &lt;code&gt;idle&lt;/code&gt; （即，等待客户端命令）， &lt;code&gt;idle in transaction&lt;/code&gt; 空闲（即在 &lt;code&gt;BEGIN&lt;/code&gt; 块内等待客户端）或命令类型名称，例如 &lt;code&gt;SELECT&lt;/code&gt; 。此外， &lt;code&gt;waiting&lt;/code&gt; 如果服务器进程目前由另一个会话持有的锁等待附加。在以上示例中，我们可以推断出进程15606正在等待进程15610完成其事务并因此释放一些锁定。 （进程15610必须是阻止程序，因为没有其他活动会话。在更复杂的情况下，有必要查看&lt;a href=&quot;view-pg-locks&quot;&gt; &lt;code&gt;pg_locks&lt;/code&gt; &lt;/a&gt; 系统视图，以确定谁阻止了谁。）</target>
        </trans-unit>
        <trans-unit id="13392321669f2c3fc39fecf0f89fb41cca2076a4" translate="yes" xml:space="preserve">
          <source>The usual comparison operators are available, as shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;Table 9.1&lt;/a&gt;.</source>
          <target state="translated">常用的比较运算符可用，如&lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;表9.1&lt;/a&gt;所示。</target>
        </trans-unit>
        <trans-unit id="06a88b4eddcbb8d26f5f678e56a78a9bd14190d1" translate="yes" xml:space="preserve">
          <source>The usual goal of routine vacuuming is to do standard &lt;code&gt;VACUUM&lt;/code&gt;s often enough to avoid needing &lt;code&gt;VACUUM FULL&lt;/code&gt;. The autovacuum daemon attempts to work this way, and in fact will never issue &lt;code&gt;VACUUM FULL&lt;/code&gt;. In this approach, the idea is not to keep tables at their minimum size, but to maintain steady-state usage of disk space: each table occupies space equivalent to its minimum size plus however much space gets used up between vacuumings. Although &lt;code&gt;VACUUM FULL&lt;/code&gt; can be used to shrink a table back to its minimum size and return the disk space to the operating system, there is not much point in this if the table will just grow again in the future. Thus, moderately-frequent standard &lt;code&gt;VACUUM&lt;/code&gt; runs are a better approach than infrequent &lt;code&gt;VACUUM FULL&lt;/code&gt; runs for maintaining heavily-updated tables.</source>
          <target state="translated">常规吸尘的通常目标是经常进行标准 &lt;code&gt;VACUUM&lt;/code&gt; ，以避免需要 &lt;code&gt;VACUUM FULL&lt;/code&gt; 。 autovacuum守护程序尝试以这种方式工作，并且实际上永远不会发出 &lt;code&gt;VACUUM FULL&lt;/code&gt; 。在这种方法中，其想法不是将表保持在最小大小，而是保持磁盘空间的稳态使用：每个表占用的空间等于其最小大小，而且在两次清理之间占用了很多空间。尽管可以使用 &lt;code&gt;VACUUM FULL&lt;/code&gt; 将表缩小到最小大小并将磁盘空间返回给操作系统，但是如果表将来会再次增长，则没有什么意义。因此， &lt;code&gt;VACUUM&lt;/code&gt; 标准VACUUM与不经常使用 &lt;code&gt;VACUUM FULL&lt;/code&gt; 运行来维护大量更新的表相比，运行是一种更好的方法。</target>
        </trans-unit>
        <trans-unit id="8705eeb4c73510ec550152d0313d6eeffdb4ff7a" translate="yes" xml:space="preserve">
          <source>The usual interpretation of the &lt;code&gt;amproclefttype&lt;/code&gt; and &lt;code&gt;amprocrighttype&lt;/code&gt; fields is that they identify the left and right input types of the operator(s) that a particular support function supports. For some access methods these match the input data type(s) of the support function itself, for others not. There is a notion of &amp;ldquo;default&amp;rdquo; support functions for an index, which are those with &lt;code&gt;amproclefttype&lt;/code&gt; and &lt;code&gt;amprocrighttype&lt;/code&gt; both equal to the index operator class's &lt;code&gt;opcintype&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;amproclefttype&lt;/code&gt; 和 &lt;code&gt;amprocrighttype&lt;/code&gt; 字段的通常解释是，它们标识特定支持功能支持的运算符的左右输入类型。对于某些访问方法，它们与支持功能本身的输入数据类型匹配，对于其他访问方法则不匹配。索引存在&amp;ldquo;默认&amp;rdquo;支持功能的概念，即 &lt;code&gt;amproclefttype&lt;/code&gt; 和 &lt;code&gt;amprocrighttype&lt;/code&gt; 都等于索引运算符类的 &lt;code&gt;opcintype&lt;/code&gt; 的那些功能。</target>
        </trans-unit>
        <trans-unit id="675415fe7638319c8a05abc3d9aab113c5086abb" translate="yes" xml:space="preserve">
          <source>The usual logical operators are available:</source>
          <target state="translated">一般的逻辑运算符都可以使用。</target>
        </trans-unit>
        <trans-unit id="410b768bdab1d606d84345d16fb594b86774dec4" translate="yes" xml:space="preserve">
          <source>The utility command &lt;a href=&quot;app-pg-ctl&quot;&gt;pg_ctl&lt;/a&gt; can be used to start and shut down the &lt;code&gt;postgres&lt;/code&gt; server safely and comfortably.</source>
          <target state="translated">实用程序命令&lt;a href=&quot;app-pg-ctl&quot;&gt;pg_ctl&lt;/a&gt;可用于安全舒适地启动和关闭 &lt;code&gt;postgres&lt;/code&gt; 服务器。</target>
        </trans-unit>
        <trans-unit id="914a00521ee94634aa555f79070e426ade88941f" translate="yes" xml:space="preserve">
          <source>The value can range from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;10000000000&lt;/code&gt;. When &lt;code&gt;vacuum_cleanup_index_scale_factor&lt;/code&gt; is set to &lt;code&gt;0&lt;/code&gt;, index scans are never skipped during &lt;code&gt;VACUUM&lt;/code&gt; cleanup. The default value is &lt;code&gt;0.1&lt;/code&gt;.</source>
          <target state="translated">取值范围是 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;10000000000&lt;/code&gt; 。当 &lt;code&gt;vacuum_cleanup_index_scale_factor&lt;/code&gt; 设置为 &lt;code&gt;0&lt;/code&gt; 时，在 &lt;code&gt;VACUUM&lt;/code&gt; 清理期间永远不会跳过索引扫描。默认值为 &lt;code&gt;0.1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="82bae1585ba067ff6aabd9ec822fffc256ffef0f" translate="yes" xml:space="preserve">
          <source>The value for &lt;code&gt;dynamic_library_path&lt;/code&gt; must be a list of absolute directory paths separated by colons (or semi-colons on Windows). If a list element starts with the special string &lt;code&gt;$libdir&lt;/code&gt;, the compiled-in PostgreSQL package library directory is substituted for &lt;code&gt;$libdir&lt;/code&gt;; this is where the modules provided by the standard PostgreSQL distribution are installed. (Use &lt;code&gt;pg_config --pkglibdir&lt;/code&gt; to find out the name of this directory.) For example:</source>
          <target state="translated">&lt;code&gt;dynamic_library_path&lt;/code&gt; 的值必须是由冒号（或Windows上的分号）分隔的绝对目录路径的列表。如果列表元素以特殊字符串 &lt;code&gt;$libdir&lt;/code&gt; 开头，则将已编译的PostgreSQL软件包库目录替换为 &lt;code&gt;$libdir&lt;/code&gt; ；这是标准PostgreSQL发行版提供的模块的安装位置。（使用 &lt;code&gt;pg_config --pkglibdir&lt;/code&gt; 查找该目录的名称。）例如：</target>
        </trans-unit>
        <trans-unit id="e2ece96ce583cb594781fa18e96e90c23a241cb2" translate="yes" xml:space="preserve">
          <source>The value for &lt;code&gt;search_path&lt;/code&gt; must be a comma-separated list of schema names. Any name that is not an existing schema, or is a schema for which the user does not have &lt;code&gt;USAGE&lt;/code&gt; permission, is silently ignored.</source>
          <target state="translated">&lt;code&gt;search_path&lt;/code&gt; 的值必须是模式名称的逗号分隔列表。任何不是现有模式的名称，或者是用户没有 &lt;code&gt;USAGE&lt;/code&gt; 权限的模式的名称，都将被静默忽略。</target>
        </trans-unit>
        <trans-unit id="1885fd3acbde2dfc55224cb44032743ea0749cf2" translate="yes" xml:space="preserve">
          <source>The value is a list of names of tablespaces. When there is more than one name in the list, PostgreSQL chooses a random member of the list each time a temporary object is to be created; except that within a transaction, successively created temporary objects are placed in successive tablespaces from the list. If the selected element of the list is an empty string, PostgreSQL will automatically use the default tablespace of the current database instead.</source>
          <target state="translated">该值是一个表空间的名称列表。当列表中有多个名称时,PostgreSQL每次要创建临时对象时,都会从列表中随机选择一个成员;但在一个事务中,连续创建的临时对象会被放置在列表中的连续表空间中。如果列表中选择的元素是一个空字符串,PostgreSQL会自动使用当前数据库的默认表空间代替。</target>
        </trans-unit>
        <trans-unit id="99c82c62699420580e0ce37ee3df7912c1dd98bf" translate="yes" xml:space="preserve">
          <source>The value is either the name of a tablespace, or an empty string to specify using the default tablespace of the current database. If the value does not match the name of any existing tablespace, PostgreSQL will automatically use the default tablespace of the current database. If a nondefault tablespace is specified, the user must have &lt;code&gt;CREATE&lt;/code&gt; privilege for it, or creation attempts will fail.</source>
          <target state="translated">该值可以是表空间的名称，也可以是使用当前数据库的默认表空间指定的空字符串。如果该值与任何现有表空间的名称都不匹配，则PostgreSQL将自动使用当前数据库的默认表空间。如果指定了非默认表空间，则用户必须对其具有 &lt;code&gt;CREATE&lt;/code&gt; 特权，否则创建尝试将失败。</target>
        </trans-unit>
        <trans-unit id="35739a3ab0eff8d38722337e2254ec6c774352ae" translate="yes" xml:space="preserve">
          <source>The value might be quoted and schema-qualified. If no collation is derived for the argument expression, then a null value is returned. If the argument is not of a collatable data type, then an error is raised.</source>
          <target state="translated">该值可能是引号和模式限定的。如果没有对参数表达式进行整理,那么将返回一个空值。如果参数不属于可整理的数据类型,则会引发一个错误。</target>
        </trans-unit>
        <trans-unit id="39c36934ef87435e122aa28a1e5f5b7fbbf50ca7" translate="yes" xml:space="preserve">
          <source>The value of either of these directories that is appropriate for the installation can be found out using &lt;a href=&quot;app-pgconfig&quot;&gt;pg_config&lt;/a&gt;.</source>
          <target state="translated">可以使用&lt;a href=&quot;app-pgconfig&quot;&gt;pg_config&lt;/a&gt;查找适合安装的这两个目录的值。</target>
        </trans-unit>
        <trans-unit id="48b58f404c5ab41a010c449c8600d4f12fc88c78" translate="yes" xml:space="preserve">
          <source>The value of the last affected OID, as returned from an &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;\lo_import&lt;/code&gt; command. This variable is only guaranteed to be valid until after the result of the next SQL command has been displayed. PostgreSQL servers since version 12 do not support OID system columns anymore, thus LASTOID will always be 0 following &lt;code&gt;INSERT&lt;/code&gt; when targeting such servers.</source>
          <target state="translated">从 &lt;code&gt;INSERT&lt;/code&gt; 或 &lt;code&gt;\lo_import&lt;/code&gt; 命令返回的最后一个受影响的OID的值。仅在显示下一个SQL命令的结果之前，此变量才有效。自版本12起的PostgreSQL服务器不再支持OID系统列，因此，以此类服务器为目标时，LASTOID在 &lt;code&gt;INSERT&lt;/code&gt; 之后始终为0 。</target>
        </trans-unit>
        <trans-unit id="5b8285b6717f13b01f6793b29c8c9dedce0baef8" translate="yes" xml:space="preserve">
          <source>The value of the psql variable &lt;code&gt;name&lt;/code&gt;. See &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;Variables&lt;/a&gt;, above, for details.</source>
          <target state="translated">psql变量 &lt;code&gt;name&lt;/code&gt; 的值。有关详细信息，请参见上面的&lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c651921fd6703938e12fa970227922443e260428" translate="yes" xml:space="preserve">
          <source>The value of the psql variable &lt;code&gt;name&lt;/code&gt;. See the section &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;Variables&lt;/a&gt; for details.</source>
          <target state="translated">psql变量 &lt;code&gt;name&lt;/code&gt; 的值。有关详细信息，请参见&lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;变量&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="7cad357760c4befedd7f8fdaa593e68c359c8118" translate="yes" xml:space="preserve">
          <source>The value of the selected prompt variable is printed literally, except where a percent sign (&lt;code&gt;%&lt;/code&gt;) is encountered. Depending on the next character, certain other text is substituted instead. Defined substitutions are:</source>
          <target state="translated">所选提示变量的值按字面意义打印，除非遇到百分号（ &lt;code&gt;%&lt;/code&gt; ）。根据下一个字符，某些其他文本将代替。定义的替换是：</target>
        </trans-unit>
        <trans-unit id="039fa537d91bfcd8e0c10a9f71f9137554b1d793" translate="yes" xml:space="preserve">
          <source>The value of this parameter is a time stamp in the same format accepted by the &lt;code&gt;timestamp with time zone&lt;/code&gt; data type, except that you cannot use a time zone abbreviation (unless the &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE-ABBREVIATIONS&quot;&gt;timezone_abbreviations&lt;/a&gt; variable has been set earlier in the configuration file). Preferred style is to use a numeric offset from UTC, or you can write a full time zone name, e.g., &lt;code&gt;Europe/Helsinki&lt;/code&gt; not &lt;code&gt;EEST&lt;/code&gt;.</source>
          <target state="translated">该参数的值是 &lt;code&gt;timestamp with time zone&lt;/code&gt; 数据类型的时间戳所接受的格式相同的时间戳，除了您不能使用时区缩写（除非在配置文件中较早地设置了&lt;a href=&quot;runtime-config-client#GUC-TIMEZONE-ABBREVIATIONS&quot;&gt;timezone_abbreviations&lt;/a&gt;变量）外。首选样式是使用UTC的数字偏移量，或者您可以写一个完整的时区名称，例如 &lt;code&gt;Europe/Helsinki&lt;/code&gt; not &lt;code&gt;EEST&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68c0a0ed9f32ba0a19ec5847f3fbe4958f014ea1" translate="yes" xml:space="preserve">
          <source>The value of this parameter overrides the &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt; setting. The default value is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">此参数的值将覆盖&lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;sync_commit&lt;/a&gt;设置。默认值是 &lt;code&gt;off&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a4243c2cf710a88b014f758bc5617eddee2438a" translate="yes" xml:space="preserve">
          <source>The value to use for &lt;code&gt;old_version&lt;/code&gt; is determined by the extension's author, and might vary if there is more than one version of the old-style module that can be upgraded into an extension. For the standard additional modules supplied with pre-9.1 PostgreSQL, use &lt;code&gt;unpackaged&lt;/code&gt; for &lt;code&gt;old_version&lt;/code&gt; when updating a module to extension style.</source>
          <target state="translated">用于 &lt;code&gt;old_version&lt;/code&gt; 的值由扩展的作者确定，如果可以将多个旧版本的模块升级为扩展，则该值可能会有所不同。用于与预9.1的PostgreSQL提供的标准的附加模块，使用 &lt;code&gt;unpackaged&lt;/code&gt; 为 &lt;code&gt;old_version&lt;/code&gt; 更新模块，以扩展风格时。</target>
        </trans-unit>
        <trans-unit id="29a25a9c8e901cbf1e213381b2fe324bdafd7520" translate="yes" xml:space="preserve">
          <source>The value to use for a template-specific option. If the value is not a simple identifier or number, it must be quoted (but you can always quote it, if you wish).</source>
          <target state="translated">用于模板特定选项的值。如果该值不是简单的标识符或数字,则必须用引号来表示(但如果你愿意,也可以一直用引号)。</target>
        </trans-unit>
        <trans-unit id="97aba03e4cf10e442611ec122abb257717947453" translate="yes" xml:space="preserve">
          <source>The values in each record are separated by the &lt;code&gt;DELIMITER&lt;/code&gt; character. If the value contains the delimiter character, the &lt;code&gt;QUOTE&lt;/code&gt; character, the &lt;code&gt;NULL&lt;/code&gt; string, a carriage return, or line feed character, then the whole value is prefixed and suffixed by the &lt;code&gt;QUOTE&lt;/code&gt; character, and any occurrence within the value of a &lt;code&gt;QUOTE&lt;/code&gt; character or the &lt;code&gt;ESCAPE&lt;/code&gt; character is preceded by the escape character. You can also use &lt;code&gt;FORCE_QUOTE&lt;/code&gt; to force quotes when outputting non-&lt;code&gt;NULL&lt;/code&gt; values in specific columns.</source>
          <target state="translated">每个记录中的值由 &lt;code&gt;DELIMITER&lt;/code&gt; 字符分隔。如果值包含定界符， &lt;code&gt;QUOTE&lt;/code&gt; 字符， &lt;code&gt;NULL&lt;/code&gt; 字符串，回车符或换行符，则整个值将以 &lt;code&gt;QUOTE&lt;/code&gt; 字符作为前缀和后缀，以及在 &lt;code&gt;QUOTE&lt;/code&gt; 字符或 &lt;code&gt;ESCAPE&lt;/code&gt; 字符前面有转义字符。在特定列中输出非 &lt;code&gt;NULL&lt;/code&gt; 值时，也可以使用 &lt;code&gt;FORCE_QUOTE&lt;/code&gt; 强制使用引号。</target>
        </trans-unit>
        <trans-unit id="08d03d5b23111b07a76c7aeb9df7ffb0e8eb87a7" translate="yes" xml:space="preserve">
          <source>The values stored in the free space map are not exact. They're rounded to precision of 1/256th of &lt;code&gt;BLCKSZ&lt;/code&gt; (32 bytes with default &lt;code&gt;BLCKSZ&lt;/code&gt;), and they're not kept fully up-to-date as tuples are inserted and updated.</source>
          <target state="translated">可用空间图中存储的值不准确。将它们四舍五入到 &lt;code&gt;BLCKSZ&lt;/code&gt; 的1/256的精度（32字节，默认为 &lt;code&gt;BLCKSZ&lt;/code&gt; ），并且在插入和更新元组时，它们没有保持最新。</target>
        </trans-unit>
        <trans-unit id="b6c08b4507fc75b276335a79d4dd41a78fcf9ac5" translate="yes" xml:space="preserve">
          <source>The variants to add and drop attributes are part of the SQL standard; the other variants are PostgreSQL extensions.</source>
          <target state="translated">添加和删除属性的变体是SQL标准的一部分;其他变体是PostgreSQL的扩展。</target>
        </trans-unit>
        <trans-unit id="90629b5d606371db9e2f9a38b9c003515b5bf970" translate="yes" xml:space="preserve">
          <source>The various &lt;code&gt;\d&lt;/code&gt; commands accept a &lt;code&gt;pattern&lt;/code&gt; parameter to specify the object name(s) to be displayed. In the simplest case, a pattern is just the exact name of the object. The characters within a pattern are normally folded to lower case, just as in SQL names; for example, &lt;code&gt;\dt FOO&lt;/code&gt; will display the table named &lt;code&gt;foo&lt;/code&gt;. As in SQL names, placing double quotes around a pattern stops folding to lower case. Should you need to include an actual double quote character in a pattern, write it as a pair of double quotes within a double-quote sequence; again this is in accord with the rules for SQL quoted identifiers. For example, &lt;code&gt;\dt &quot;FOO&quot;&quot;BAR&quot;&lt;/code&gt; will display the table named &lt;code&gt;FOO&quot;BAR&lt;/code&gt; (not &lt;code&gt;foo&quot;bar&lt;/code&gt;). Unlike the normal rules for SQL names, you can put double quotes around just part of a pattern, for instance &lt;code&gt;\dt FOO&quot;FOO&quot;BAR&lt;/code&gt; will display the table named &lt;code&gt;fooFOObar&lt;/code&gt;.</source>
          <target state="translated">各种 &lt;code&gt;\d&lt;/code&gt; 命令都接受一个 &lt;code&gt;pattern&lt;/code&gt; 参数来指定要显示的对象名称。在最简单的情况下，模式只是对象的确切名称。模式中的字符通常折叠成小写，就像SQL名称一样。例如， &lt;code&gt;\dt FOO&lt;/code&gt; 将显示名为 &lt;code&gt;foo&lt;/code&gt; 的表。就像在SQL名称中一样，在模式周围放置双引号会停止折叠为小写。如果需要在模式中包含实际的双引号字符，请将其写为双引号序列中的一对双引号。再次符合SQL带引号的标识符的规则。例如， &lt;code&gt;\dt &quot;FOO&quot;&quot;BAR&quot;&lt;/code&gt; 将显示名为 &lt;code&gt;FOO&quot;BAR&lt;/code&gt; 的表（不是 &lt;code&gt;foo&quot;bar&lt;/code&gt; ）。与SQL名称的常规规则不同，您可以在模式的一部分周围加上双引号，例如 &lt;code&gt;\dt FOO&quot;FOO&quot;BAR&lt;/code&gt; 将显示名为 &lt;code&gt;fooFOObar&lt;/code&gt; 的表。</target>
        </trans-unit>
        <trans-unit id="7768758b3213c172e932c01f8e8da70daa4ada7f" translate="yes" xml:space="preserve">
          <source>The various containment and existence operators, along with all other JSON operators and functions are documented in &lt;a href=&quot;functions-json&quot;&gt;Section 9.15&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;functions-json&quot;&gt;第9.15节&lt;/a&gt;中记录了各种包含和存在运算符，以及所有其他JSON运算符和函数。</target>
        </trans-unit>
        <trans-unit id="8f313c60885e972dab9c59de4db6a32bb9909c11" translate="yes" xml:space="preserve">
          <source>The various containment and existence operators, along with all other JSON operators and functions are documented in &lt;a href=&quot;functions-json&quot;&gt;Section 9.16&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;functions-json&quot;&gt;第9.16节&lt;/a&gt;中记录了各种包含和存在运算符，以及所有其他JSON运算符和函数。</target>
        </trans-unit>
        <trans-unit id="81c7ea1665d58af0cc391c652b85b77be99d97f9" translate="yes" xml:space="preserve">
          <source>The various variants of &lt;code&gt;BETWEEN&lt;/code&gt; are implemented in terms of the ordinary comparison operators, and therefore will work for any data type(s) that can be compared.</source>
          <target state="translated">&lt;code&gt;BETWEEN&lt;/code&gt; 的各种变体是根据普通比较运算符实现的，因此适用于可以比较的任何数据类型。</target>
        </trans-unit>
        <trans-unit id="4e179b7076409c4b105a612d7c9bb99b67e607cd" translate="yes" xml:space="preserve">
          <source>The verbatim query string submitted to declare this cursor</source>
          <target state="translated">为声明该游标而提交的逐字查询字符串。</target>
        </trans-unit>
        <trans-unit id="91cb72e2fa3dca24da98249febe148f7555e66ba" translate="yes" xml:space="preserve">
          <source>The version of the extension to install. This can be written as either an identifier or a string literal. The default version is whatever is specified in the extension's control file.</source>
          <target state="translated">要安装的扩展版本。可以写成标识符或字符串文字。默认的版本是扩展的控制文件中指定的版本。</target>
        </trans-unit>
        <trans-unit id="1f466ef09b06001ef2dbe51d7e047e29feba87d5" translate="yes" xml:space="preserve">
          <source>The vertical header, displayed as the leftmost column, contains the values found in column &lt;code&gt;colV&lt;/code&gt;, in the same order as in the query results, but with duplicates removed.</source>
          <target state="translated">垂直标题显示在最左边的列中，包含在 &lt;code&gt;colV&lt;/code&gt; 列中找到的值，其顺序与查询结果中的顺序相同，但删除了重复项。</target>
        </trans-unit>
        <trans-unit id="ea52093b90b84d5b4fcb30b73c3186c808f82ec0" translate="yes" xml:space="preserve">
          <source>The very first process of an &lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;instance&lt;/a&gt;. It starts and manages the other auxiliary processes and creates &lt;a href=&quot;glossary#GLOSSARY-BACKEND&quot;&gt;backend processes&lt;/a&gt; on demand.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;实例的&lt;/a&gt;第一个过程。它启动并管理其他辅助流程，并根据需要创建&lt;a href=&quot;glossary#GLOSSARY-BACKEND&quot;&gt;后端流程&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0adcabe9624ff122085bfba5e28081fdc88cd247" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_config&lt;/code&gt; describes the compile-time configuration parameters of the currently installed version of PostgreSQL. It is intended, for example, to be used by software packages that want to interface to PostgreSQL to facilitate finding the required header files and libraries. It provides the same basic information as the &lt;a href=&quot;app-pgconfig&quot;&gt;pg_config&lt;/a&gt; PostgreSQL client application.</source>
          <target state="translated">视图 &lt;code&gt;pg_config&lt;/code&gt; 描述了当前安装的PostgreSQL版本的编译时配置参数。例如，它打算由希望与PostgreSQL接口的软件包使用，以帮助查找所需的头文件和库。它提供了与&lt;a href=&quot;app-pgconfig&quot;&gt;pg_config&lt;/a&gt; PostgreSQL客户端应用程序相同的基本信息。</target>
        </trans-unit>
        <trans-unit id="08ea6b2cfb240aa2a36ba0270a0c6bfcfe867503" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_file_settings&lt;/code&gt; provides a summary of the contents of the server's configuration file(s). A row appears in this view for each &amp;ldquo;name = value&amp;rdquo; entry appearing in the files, with annotations indicating whether the value could be applied successfully. Additional row(s) may appear for problems not linked to a &amp;ldquo;name = value&amp;rdquo; entry, such as syntax errors in the files.</source>
          <target state="translated">视图 &lt;code&gt;pg_file_settings&lt;/code&gt; 提供了服务器配置文件内容的摘要。对于每个出现在文件中的&amp;ldquo;名称=值&amp;rdquo;条目，此视图中都会出现一行，并带有注释，指示是否可以成功应用该值。对于未链接到&amp;ldquo;名称=值&amp;rdquo;条目的问题，例如文件中的语法错误，可能会出现其他行。</target>
        </trans-unit>
        <trans-unit id="63d33a4b341777d328dc2c1f214857e8874dc6d9" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_group&lt;/code&gt; exists for backwards compatibility: it emulates a catalog that existed in PostgreSQL before version 8.1. It shows the names and members of all roles that are marked as not &lt;code&gt;rolcanlogin&lt;/code&gt;, which is an approximation to the set of roles that are being used as groups.</source>
          <target state="translated">视图 &lt;code&gt;pg_group&lt;/code&gt; 的存在是为了向后兼容：它模拟版本8.1之前的PostgreSQL中存在的目录。它显示标记为not &lt;code&gt;rolcanlogin&lt;/code&gt; 的所有角色的名称和成员，这是用作组的一组角色的近似值。</target>
        </trans-unit>
        <trans-unit id="6dadc8f5b62fc6f506c2d65eb8b07e558e7c8b3f" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_hba_file_rules&lt;/code&gt; provides a summary of the contents of the client authentication configuration file, &lt;code&gt;pg_hba.conf&lt;/code&gt;. A row appears in this view for each non-empty, non-comment line in the file, with annotations indicating whether the rule could be applied successfully.</source>
          <target state="translated">视图 &lt;code&gt;pg_hba_file_rules&lt;/code&gt; 提供了客户端身份验证配置文件 &lt;code&gt;pg_hba.conf&lt;/code&gt; 的摘要。对于文件中的每个非空，非注释行，此视图中都会出现一行，并带有注释，指示规则是否可以成功应用。</target>
        </trans-unit>
        <trans-unit id="aac1873f6d2161781d725af8550ac62cddd3ae8a" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_indexes&lt;/code&gt; provides access to useful information about each index in the database.</source>
          <target state="translated">视图 &lt;code&gt;pg_indexes&lt;/code&gt; 提供对数据库中每个索引的有用信息的访问。</target>
        </trans-unit>
        <trans-unit id="c4a5f88ab67e15b0fb81ed88eb1f6933ddc8f95f" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_locks&lt;/code&gt; provides access to information about the locks held by active processes within the database server. See &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt; for more discussion of locking.</source>
          <target state="translated">视图 &lt;code&gt;pg_locks&lt;/code&gt; 提供对数据库服务器内活动进程所持有锁的信息的访问。有关锁定的更多讨论，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;第13章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f25d4dc4f833f46aa9ec8087405622ced3b66529" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_locks&lt;/code&gt; provides access to information about the locks held by active processes within the database server. See &lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt; for more discussion of locking.</source>
          <target state="translated">视图 &lt;code&gt;pg_locks&lt;/code&gt; 提供对有关数据库服务器内活动进程所持有的锁的信息的访问。有关锁定的更多讨论，请参见&lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;第13章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="042974f73615dd15fc09c5129e6b33aeeef53099" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_matviews&lt;/code&gt; provides access to useful information about each materialized view in the database.</source>
          <target state="translated">视图 &lt;code&gt;pg_matviews&lt;/code&gt; 提供对数据库中每个实例化视图的有用信息的访问。</target>
        </trans-unit>
        <trans-unit id="f35ab0d9ea2df46d55f4f8845455de38e126b0e5" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_policies&lt;/code&gt; provides access to useful information about each row-level security policy in the database.</source>
          <target state="translated">视图 &lt;code&gt;pg_policies&lt;/code&gt; 提供对数据库中每个行级安全策略的有用信息的访问。</target>
        </trans-unit>
        <trans-unit id="43d0e1b7a1af60f6a8bef0840cbf55e0cd1189ae" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_prepared_xacts&lt;/code&gt; displays information about transactions that are currently prepared for two-phase commit (see &lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt; for details).</source>
          <target state="translated">视图 &lt;code&gt;pg_prepared_xacts&lt;/code&gt; 显示有关当前为两阶段提交准备的&lt;a href=&quot;sql-prepare-transaction&quot;&gt;事务&lt;/a&gt;的信息（有关详细信息，请参见PREPARE TRANSACTION）。</target>
        </trans-unit>
        <trans-unit id="5890e8d1e9f41b0cd60cd417fec506b423153a1c" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_publication_tables&lt;/code&gt; provides information about the mapping between publications and the tables they contain. Unlike the underlying catalog &lt;code&gt;pg_publication_rel&lt;/code&gt;, this view expands publications defined as &lt;code&gt;FOR ALL TABLES&lt;/code&gt;, so for such publications there will be a row for each eligible table.</source>
          <target state="translated">视图 &lt;code&gt;pg_publication_tables&lt;/code&gt; 提供有关发布与其包含的表之间的映射的信息。与基础目录 &lt;code&gt;pg_publication_rel&lt;/code&gt; 不同，此视图扩展了定义为 &lt;code&gt;FOR ALL TABLES&lt;/code&gt; 的发布，因此对于此类发布，每个合格的表都会有一行。</target>
        </trans-unit>
        <trans-unit id="e6f8a891f9c67ef2b6de308cc7563907a8fbe06b" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_roles&lt;/code&gt; provides access to information about database roles. This is simply a publicly readable view of &lt;a href=&quot;catalog-pg-authid&quot;&gt;&lt;code&gt;pg_authid&lt;/code&gt;&lt;/a&gt; that blanks out the password field.</source>
          <target state="translated">视图 &lt;code&gt;pg_roles&lt;/code&gt; 提供对数据库角色信息的访问。这只是&lt;a href=&quot;catalog-pg-authid&quot;&gt; &lt;code&gt;pg_authid&lt;/code&gt; &lt;/a&gt;的公共可读视图，该视图空白了password字段。</target>
        </trans-unit>
        <trans-unit id="be02d2530abee0307e3d8c75ed7462d6006d37d5" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_rules&lt;/code&gt; provides access to useful information about query rewrite rules.</source>
          <target state="translated">视图 &lt;code&gt;pg_rules&lt;/code&gt; 提供对查询重写规则的有用信息的访问。</target>
        </trans-unit>
        <trans-unit id="8abbf138d7583623930f0cc0e4290da9934bc84a" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_seclabels&lt;/code&gt; provides information about security labels. It as an easier-to-query version of the &lt;a href=&quot;catalog-pg-seclabel&quot;&gt;&lt;code&gt;pg_seclabel&lt;/code&gt;&lt;/a&gt; catalog.</source>
          <target state="translated">视图 &lt;code&gt;pg_seclabels&lt;/code&gt; 提供有关安全标签的信息。它是&lt;a href=&quot;catalog-pg-seclabel&quot;&gt; &lt;code&gt;pg_seclabel&lt;/code&gt; &lt;/a&gt;目录的易于查询的版本。</target>
        </trans-unit>
        <trans-unit id="9de8f57dd43c6ec5ae63346c8a1f92176c16d0d1" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_sequences&lt;/code&gt; provides access to useful information about each sequence in the database.</source>
          <target state="translated">视图 &lt;code&gt;pg_sequences&lt;/code&gt; 提供对数据库中每个序列的有用信息的访问。</target>
        </trans-unit>
        <trans-unit id="25e4f3261aeb43d1f5668204f1fb62fa4677a0bd" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_settings&lt;/code&gt; provides access to run-time parameters of the server. It is essentially an alternative interface to the &lt;a href=&quot;sql-show&quot;&gt;SHOW&lt;/a&gt; and &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; commands. It also provides access to some facts about each parameter that are not directly available from &lt;code&gt;SHOW&lt;/code&gt;, such as minimum and maximum values.</source>
          <target state="translated">视图 &lt;code&gt;pg_settings&lt;/code&gt; 提供了对服务器运行时参数的访问。它实质上是&lt;a href=&quot;sql-show&quot;&gt;SHOW&lt;/a&gt;和&lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt;命令的替代接口。它还提供对每个参数的某些事实的访问，这些事实不能从 &lt;code&gt;SHOW&lt;/code&gt; 直接获得，例如最小值和最大值。</target>
        </trans-unit>
        <trans-unit id="7729b5ec7977be5f90c3408f6cef81a593faa4de" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_shadow&lt;/code&gt; exists for backwards compatibility: it emulates a catalog that existed in PostgreSQL before version 8.1. It shows properties of all roles that are marked as &lt;code&gt;rolcanlogin&lt;/code&gt; in &lt;a href=&quot;catalog-pg-authid&quot;&gt;&lt;code&gt;pg_authid&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">视图 &lt;code&gt;pg_shadow&lt;/code&gt; 的存在是为了向后兼容：它模拟版本8.1之前的PostgreSQL中存在的目录。它显示了在&lt;a href=&quot;catalog-pg-authid&quot;&gt; &lt;code&gt;pg_authid&lt;/code&gt; &lt;/a&gt;中标记为 &lt;code&gt;rolcanlogin&lt;/code&gt; 的所有角色的属性。</target>
        </trans-unit>
        <trans-unit id="d15bc53a297402a714a0bba8855047689e420c4a" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_stats&lt;/code&gt; provides access to the information stored in the &lt;a href=&quot;catalog-pg-statistic&quot;&gt;&lt;code&gt;pg_statistic&lt;/code&gt;&lt;/a&gt; catalog. This view allows access only to rows of &lt;code&gt;pg_statistic&lt;/code&gt; that correspond to tables the user has permission to read, and therefore it is safe to allow public read access to this view.</source>
          <target state="translated">视图 &lt;code&gt;pg_stats&lt;/code&gt; 提供对&lt;a href=&quot;catalog-pg-statistic&quot;&gt; &lt;code&gt;pg_statistic&lt;/code&gt; &lt;/a&gt;目录中存储的信息的访问。该视图仅允许访问 &lt;code&gt;pg_statistic&lt;/code&gt; 的行，这些行与用户有权读取的表相对应，因此允许对该视图的公共读取访问是安全的。</target>
        </trans-unit>
        <trans-unit id="8b10f73e0ee9172a27b8a2e39f5e546984d02189" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_stats_ext&lt;/code&gt; provides access to the information stored in the &lt;a href=&quot;catalog-pg-statistic-ext&quot;&gt;&lt;code&gt;pg_statistic_ext&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;catalog-pg-statistic-ext-data&quot;&gt;&lt;code&gt;pg_statistic_ext_data&lt;/code&gt;&lt;/a&gt; catalogs. This view allows access only to rows of &lt;code&gt;pg_statistic_ext&lt;/code&gt; and &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; that correspond to tables the user has permission to read, and therefore it is safe to allow public read access to this view.</source>
          <target state="translated">视图 &lt;code&gt;pg_stats_ext&lt;/code&gt; 提供对存储在&lt;a href=&quot;catalog-pg-statistic-ext&quot;&gt; &lt;code&gt;pg_statistic_ext&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;catalog-pg-statistic-ext-data&quot;&gt; &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; &lt;/a&gt;目录中的信息的访问。该视图仅允许访问 &lt;code&gt;pg_statistic_ext&lt;/code&gt; 和 &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; 的行，这些行与用户有权读取的表相对应，因此可以安全地允许公共读取对此视图的访问。</target>
        </trans-unit>
        <trans-unit id="f40e73d682038b4cca53135af313b3e16f3f20f0" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_tables&lt;/code&gt; provides access to useful information about each table in the database.</source>
          <target state="translated">视图 &lt;code&gt;pg_tables&lt;/code&gt; 提供对数据库中每个表的有用信息的访问。</target>
        </trans-unit>
        <trans-unit id="6619a281d707d2c59aad726e79eb743d37565afc" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_timezone_abbrevs&lt;/code&gt; provides a list of time zone abbreviations that are currently recognized by the datetime input routines. The contents of this view change when the &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE-ABBREVIATIONS&quot;&gt;timezone_abbreviations&lt;/a&gt; run-time parameter is modified.</source>
          <target state="translated">视图 &lt;code&gt;pg_timezone_abbrevs&lt;/code&gt; 提供了datetime输入例程当前识别的时区缩写列表。修改&lt;a href=&quot;runtime-config-client#GUC-TIMEZONE-ABBREVIATIONS&quot;&gt;timezone_abbreviations&lt;/a&gt;运行时参数后，此视图的内容也会更改。</target>
        </trans-unit>
        <trans-unit id="779554f59d2b5af071b41b6375ef03ef95013941" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_timezone_names&lt;/code&gt; provides a list of time zone names that are recognized by &lt;code&gt;SET TIMEZONE&lt;/code&gt;, along with their associated abbreviations, UTC offsets, and daylight-savings status. (Technically, PostgreSQL does not use UTC because leap seconds are not handled.) Unlike the abbreviations shown in &lt;a href=&quot;view-pg-timezone-abbrevs&quot;&gt;&lt;code&gt;pg_timezone_abbrevs&lt;/code&gt;&lt;/a&gt;, many of these names imply a set of daylight-savings transition date rules. Therefore, the associated information changes across local DST boundaries. The displayed information is computed based on the current value of &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt;.</source>
          <target state="translated">视图 &lt;code&gt;pg_timezone_names&lt;/code&gt; 提供了 &lt;code&gt;SET TIMEZONE&lt;/code&gt; 可以识别的时区名称列表，以及它们的相关缩写，UTC偏移量和夏时制状态。 （从技术上讲，PostgreSQL不使用UTC，因为没有处理seconds秒。）与&lt;a href=&quot;view-pg-timezone-abbrevs&quot;&gt; &lt;code&gt;pg_timezone_abbrevs&lt;/code&gt; 中&lt;/a&gt;显示的缩写不同，这些名称中的许多都暗示了一组夏令时转换日期规则。因此，关联的信息会在本地DST边界上发生变化。显示的信息是基于 &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt; 的当前值计算的。</target>
        </trans-unit>
        <trans-unit id="0accb8d532196eb116802aaa4d92096a1d624fec" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_user&lt;/code&gt; provides access to information about database users. This is simply a publicly readable view of &lt;a href=&quot;view-pg-shadow&quot;&gt;&lt;code&gt;pg_shadow&lt;/code&gt;&lt;/a&gt; that blanks out the password field.</source>
          <target state="translated">视图 &lt;code&gt;pg_user&lt;/code&gt; 提供对数据库用户信息的访问。这只是&lt;a href=&quot;view-pg-shadow&quot;&gt; &lt;code&gt;pg_shadow&lt;/code&gt; &lt;/a&gt;的公共可读视图，该视图空白了password字段。</target>
        </trans-unit>
        <trans-unit id="9af556d749b255c75a83063bd94ae2fbcc5e7542" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_user_mappings&lt;/code&gt; provides access to information about user mappings. This is essentially a publicly readable view of &lt;a href=&quot;catalog-pg-user-mapping&quot;&gt;&lt;code&gt;pg_user_mapping&lt;/code&gt;&lt;/a&gt; that leaves out the options field if the user has no rights to use it.</source>
          <target state="translated">视图 &lt;code&gt;pg_user_mappings&lt;/code&gt; 提供对用户映射信息的访问。从本质&lt;a href=&quot;catalog-pg-user-mapping&quot;&gt; &lt;code&gt;pg_user_mapping&lt;/code&gt; &lt;/a&gt;，这是pg_user_mapping的公共可读视图，如果用户无权使用它，则忽略选项字段。</target>
        </trans-unit>
        <trans-unit id="ebac217e3082208e364c831d2d7b567e319b9c3e" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_views&lt;/code&gt; provides access to useful information about each view in the database.</source>
          <target state="translated">视图 &lt;code&gt;pg_views&lt;/code&gt; 提供对数据库中每个视图的有用信息的访问。</target>
        </trans-unit>
        <trans-unit id="4817256584c648c50b28a16cee721735c1a52c24" translate="yes" xml:space="preserve">
          <source>The view definition must not contain &lt;code&gt;WITH&lt;/code&gt;, &lt;code&gt;DISTINCT&lt;/code&gt;, &lt;code&gt;GROUP BY&lt;/code&gt;, &lt;code&gt;HAVING&lt;/code&gt;, &lt;code&gt;LIMIT&lt;/code&gt;, or &lt;code&gt;OFFSET&lt;/code&gt; clauses at the top level.</source>
          <target state="translated">视图定义不得在顶层包含 &lt;code&gt;WITH&lt;/code&gt; ， &lt;code&gt;DISTINCT&lt;/code&gt; ， &lt;code&gt;GROUP BY&lt;/code&gt; ， &lt;code&gt;HAVING&lt;/code&gt; ， &lt;code&gt;LIMIT&lt;/code&gt; 或 &lt;code&gt;OFFSET&lt;/code&gt; 子句。</target>
        </trans-unit>
        <trans-unit id="ac73f4040a9b923ccad030c67910098b61fec109" translate="yes" xml:space="preserve">
          <source>The view definition must not contain set operations (&lt;code&gt;UNION&lt;/code&gt;, &lt;code&gt;INTERSECT&lt;/code&gt; or &lt;code&gt;EXCEPT&lt;/code&gt;) at the top level.</source>
          <target state="translated">视图定义不得在顶层包含设置操作（ &lt;code&gt;UNION&lt;/code&gt; ， &lt;code&gt;INTERSECT&lt;/code&gt; 或 &lt;code&gt;EXCEPT&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c5066d83f9232becf3a59274519313c89ede3a33" translate="yes" xml:space="preserve">
          <source>The view must have exactly one entry in its &lt;code&gt;FROM&lt;/code&gt; list, which must be a table or another updatable view.</source>
          <target state="translated">该视图必须在其 &lt;code&gt;FROM&lt;/code&gt; 列表中恰好有一个条目，该条目必须是一个表或另一个可更新的视图。</target>
        </trans-unit>
        <trans-unit id="baf2ef9470f50663334ce73cc7c64a2829052725" translate="yes" xml:space="preserve">
          <source>The view's select list must not contain any aggregates, window functions or set-returning functions.</source>
          <target state="translated">视图的选择列表不得包含任何聚合、窗口函数或设置返回函数。</target>
        </trans-unit>
        <trans-unit id="130532d5707af5b172a46c66162c216e956933cf" translate="yes" xml:space="preserve">
          <source>The visibility map stores two bits per heap page. The first bit, if set, indicates that the page is all-visible, or in other words that the page does not contain any tuples that need to be vacuumed. This information can also be used by &lt;a href=&quot;indexes-index-only-scans&quot;&gt;&lt;em&gt;index-only scans&lt;/em&gt;&lt;/a&gt; to answer queries using only the index tuple. The second bit, if set, means that all tuples on the page have been frozen. That means that even an anti-wraparound vacuum need not revisit the page.</source>
          <target state="translated">可见性图在每个堆页面中存储两位。如果设置了第一位，则指示该页面是全可见的，换句话说，该页面不包含任何需要清除的元组。&lt;a href=&quot;indexes-index-only-scans&quot;&gt;&lt;em&gt;仅索引扫描&lt;/em&gt;&lt;/a&gt;也可以使用此信息来&lt;em&gt;仅&lt;/em&gt;使用索引元组回答查询。如果设置了第二位，则表示页面上的所有元组都已冻结。这意味着即使是反环绕的真空也不需要重新访问页面。</target>
        </trans-unit>
        <trans-unit id="07214e8c015e87c0486ca72cfe80d8e537680c27" translate="yes" xml:space="preserve">
          <source>The web site of the Unicode Consortium.</source>
          <target state="translated">Unicode联盟的网站。</target>
        </trans-unit>
        <trans-unit id="ac0772ef278780058ef7ad6f8b7ba38fa2811ad4" translate="yes" xml:space="preserve">
          <source>The word &lt;code&gt;The&lt;/code&gt; was recognized by the &lt;code&gt;english_ispell&lt;/code&gt; dictionary as a stop word (&lt;a href=&quot;textsearch-dictionaries#TEXTSEARCH-STOPWORDS&quot;&gt;Section 12.6.1&lt;/a&gt;) and will not be indexed. The spaces are discarded too, since the configuration provides no dictionaries at all for them.</source>
          <target state="translated">这个词 &lt;code&gt;The&lt;/code&gt; 被认可 &lt;code&gt;english_ispell&lt;/code&gt; 字典为停止字（&lt;a href=&quot;textsearch-dictionaries#TEXTSEARCH-STOPWORDS&quot;&gt;第12.6.1&lt;/a&gt;），并不会被索引。空格也被丢弃，因为该配置完全不为它们提供字典。</target>
        </trans-unit>
        <trans-unit id="59b558b7e67cfe3d7e609850ba39630cdfabc234" translate="yes" xml:space="preserve">
          <source>The words &lt;code&gt;INNER&lt;/code&gt; and &lt;code&gt;OUTER&lt;/code&gt; are optional in all forms. &lt;code&gt;INNER&lt;/code&gt; is the default; &lt;code&gt;LEFT&lt;/code&gt;, &lt;code&gt;RIGHT&lt;/code&gt;, and &lt;code&gt;FULL&lt;/code&gt; imply an outer join.</source>
          <target state="translated">单词 &lt;code&gt;INNER&lt;/code&gt; 和 &lt;code&gt;OUTER&lt;/code&gt; 在所有形式中都是可选的。 &lt;code&gt;INNER&lt;/code&gt; 是默认设置； &lt;code&gt;LEFT&lt;/code&gt; ， &lt;code&gt;RIGHT&lt;/code&gt; 和 &lt;code&gt;FULL&lt;/code&gt; 表示外部联接。</target>
        </trans-unit>
        <trans-unit id="0b4d99c273391963b8b35583f768d35f9926b320" translate="yes" xml:space="preserve">
          <source>The write-ahead log files are collected at the end of the backup. Therefore, it is necessary for the &lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SEGMENTS&quot;&gt;wal_keep_segments&lt;/a&gt; parameter to be set high enough that the log is not removed before the end of the backup. If the log has been rotated when it's time to transfer it, the backup will fail and be unusable.</source>
          <target state="translated">在备份结束时收集预写日志文件。因此，必须将&lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SEGMENTS&quot;&gt;wal_keep_segments&lt;/a&gt;参数设置得足够高，以便在备份结束之前不删除日志。如果在传输日志时已将其旋转，则备份将失败并且无法使用。</target>
        </trans-unit>
        <trans-unit id="bb82d1de22fb923c487c6dd4a9b8f7c1ca501443" translate="yes" xml:space="preserve">
          <source>The write-ahead log files are collected at the end of the backup. Therefore, it is necessary for the source server's &lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SIZE&quot;&gt;wal_keep_size&lt;/a&gt; parameter to be set high enough that the required log data is not removed before the end of the backup. If the required log data has been recycled before it's time to transfer it, the backup will fail and be unusable.</source>
          <target state="translated">在备份结束时收集预写日志文件。因此，必须将源服务器的&lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SIZE&quot;&gt;wal_keep_size&lt;/a&gt;参数设置得足够高，以便在备份结束之前不删除所需的日志数据。如果所需的日志数据在传输之前已被回收，则备份将失败并且无法使用。</target>
        </trans-unit>
        <trans-unit id="ba7564fc67dee171caeeb2fce7f2a0e6bd4739d4" translate="yes" xml:space="preserve">
          <source>The write-ahead log is streamed over a regular PostgreSQL connection and uses the replication protocol. The connection must be made with a superuser or a user having &lt;code&gt;REPLICATION&lt;/code&gt; permissions (see &lt;a href=&quot;role-attributes&quot;&gt;Section 21.2&lt;/a&gt;), and &lt;code&gt;pg_hba.conf&lt;/code&gt; must permit the replication connection. The server must also be configured with &lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt; set high enough to leave at least one session available for the stream.</source>
          <target state="translated">预写日志通过常规PostgreSQL连接流式传输，并使用复制协议。连接必须由超级用户或具有 &lt;code&gt;REPLICATION&lt;/code&gt; 权限的用户建立（请参阅&lt;a href=&quot;role-attributes&quot;&gt;第21.2节&lt;/a&gt;），并且 &lt;code&gt;pg_hba.conf&lt;/code&gt; 必须允许复制连接。还必须为服务器配置&lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders，&lt;/a&gt;并将其设置得足够高，以使至少一个会话可用于该流。</target>
        </trans-unit>
        <trans-unit id="98bdbb8059522e13ab67d4f644a83a409dec157e" translate="yes" xml:space="preserve">
          <source>The write-ahead log is streamed over a regular PostgreSQL connection and uses the replication protocol. The connection must be made with a user having &lt;code&gt;REPLICATION&lt;/code&gt; permissions (see &lt;a href=&quot;role-attributes&quot;&gt;Section 21.2&lt;/a&gt;) or a superuser, and &lt;code&gt;pg_hba.conf&lt;/code&gt; must permit the replication connection. The server must also be configured with &lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt; set high enough to leave at least one session available for the stream.</source>
          <target state="translated">预写日志通过常规PostgreSQL连接流式传输，并使用复制协议。必须由具有 &lt;code&gt;REPLICATION&lt;/code&gt; 权限的用户（请参见&lt;a href=&quot;role-attributes&quot;&gt;21.2&lt;/a&gt;）或超级用户建立连接，并且 &lt;code&gt;pg_hba.conf&lt;/code&gt; 必须允许复制连接。还必须为服务器配置&lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders，&lt;/a&gt;并将其设置得足够高，以使至少一个会话可用于该流。</target>
        </trans-unit>
        <trans-unit id="432cd562d6efcb95d5dc25b8cd51ce86806b3431" translate="yes" xml:space="preserve">
          <source>The year field divided by 10</source>
          <target state="translated">年份领域除以10</target>
        </trans-unit>
        <trans-unit id="e98cba09cda3a8f0612018162bdf75b308d8a647" translate="yes" xml:space="preserve">
          <source>The year field. Keep in mind there is no &lt;code&gt;0 AD&lt;/code&gt;, so subtracting &lt;code&gt;BC&lt;/code&gt; years from &lt;code&gt;AD&lt;/code&gt; years should be done with care.</source>
          <target state="translated">年字段。请记住，没有 &lt;code&gt;0 AD&lt;/code&gt; ，因此应谨慎从 &lt;code&gt;AD&lt;/code&gt; 年中减去 &lt;code&gt;BC&lt;/code&gt; 年。</target>
        </trans-unit>
        <trans-unit id="3552e22363d1468b0aacd8c69df60173fa97d631" translate="yes" xml:space="preserve">
          <source>Then a second pass is performed to add tuples that were added while the first pass was running. This step is also done in a separate transaction for each index.</source>
          <target state="translated">然后进行第二次传递,添加在第一次传递运行时添加的tuple。这一步也是在每个索引的单独事务中完成的。</target>
        </trans-unit>
        <trans-unit id="de263736bca031472680a6589ed91b77cebda41e" translate="yes" xml:space="preserve">
          <source>Then create a foreign server using &lt;a href=&quot;sql-createserver&quot;&gt;CREATE SERVER&lt;/a&gt;. In this example we wish to connect to a PostgreSQL server on host &lt;code&gt;192.83.123.89&lt;/code&gt; listening on port &lt;code&gt;5432&lt;/code&gt;. The database to which the connection is made is named &lt;code&gt;foreign_db&lt;/code&gt; on the remote server:</source>
          <target state="translated">然后使用&lt;a href=&quot;sql-createserver&quot;&gt;CREATE SERVER&lt;/a&gt;创建一个外部服务器。在此示例中，我们希望连接到侦听端口 &lt;code&gt;5432&lt;/code&gt; 的主机 &lt;code&gt;192.83.123.89&lt;/code&gt; 上的PostgreSQL服务器。与该服务器建立连接的数据库在远程服务器上名为 &lt;code&gt;foreign_db&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3a9fba163e98528da53932bde9ceaf387982416c" translate="yes" xml:space="preserve">
          <source>Then create a foreign server:</source>
          <target state="translated">然后创建一个国外服务器。</target>
        </trans-unit>
        <trans-unit id="e43083876c3094d12a2389b25dd099144327f495" translate="yes" xml:space="preserve">
          <source>Then create the necessary functions:</source>
          <target state="translated">然后创建必要的功能。</target>
        </trans-unit>
        <trans-unit id="2dddb885a6a2b1519c7054126c37d9c20d84517e" translate="yes" xml:space="preserve">
          <source>Then do:</source>
          <target state="translated">那就做。</target>
        </trans-unit>
        <trans-unit id="4426056bca332e6c166eaec6ccb98cd595443c37" translate="yes" xml:space="preserve">
          <source>Then give the snapshot identifier in a &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; command at the beginning of the newly opened transaction:</source>
          <target state="translated">然后在新打开的事务的开始处的 &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; 命令中提供快照标识符：</target>
        </trans-unit>
        <trans-unit id="099f3b7a79e1e05797463b8b9b3322c6caaa4e61" translate="yes" xml:space="preserve">
          <source>Then in</source>
          <target state="translated">然后在</target>
        </trans-unit>
        <trans-unit id="ccb8ef6dada9fbef1512f58ed41d1e67ec739a68" translate="yes" xml:space="preserve">
          <source>Then issue the tablespace creation command inside PostgreSQL:</source>
          <target state="translated">然后在PostgreSQL里面发出表空间创建命令。</target>
        </trans-unit>
        <trans-unit id="a0f76343f97548fdfb798c00512768e705a5ee06" translate="yes" xml:space="preserve">
          <source>Then on the publisher database:</source>
          <target state="translated">然后在出版商数据库上。</target>
        </trans-unit>
        <trans-unit id="1d6e3db28b5d51e7392c9e84a5178977bac26570" translate="yes" xml:space="preserve">
          <source>Then psql's &lt;code&gt;\dp&lt;/code&gt; command would show:</source>
          <target state="translated">然后psql的 &lt;code&gt;\dp&lt;/code&gt; 命令将显示：</target>
        </trans-unit>
        <trans-unit id="e40d95af0c8bcea8599638c011ae6dba5195ebe1" translate="yes" xml:space="preserve">
          <source>Then value &lt;code&gt;i&lt;/code&gt; between &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; inclusive is drawn with probability: &lt;code&gt;f(i) - f(i + 1)&lt;/code&gt;.</source>
          <target state="translated">然后，以概率 &lt;code&gt;f(i) - f(i + 1)&lt;/code&gt; 得出介于 &lt;code&gt;min&lt;/code&gt; 和 &lt;code&gt;max&lt;/code&gt; 含）之间的值 &lt;code&gt;i&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="509703ffcaaed84d033fc9e94ce5a7937bf0da94" translate="yes" xml:space="preserve">
          <source>Then we create a GIN index to speed up the search:</source>
          <target state="translated">然后我们创建一个GIN索引来加快搜索速度。</target>
        </trans-unit>
        <trans-unit id="c623faac8eaf06e9450b38faf671811be2f6e1f9" translate="yes" xml:space="preserve">
          <source>Then we no longer have access to the public schema without explicit qualification. There is nothing special about the public schema except that it exists by default. It can be dropped, too.</source>
          <target state="translated">那么我们就不能再在没有明确限定的情况下访问公共模式。除了默认存在外,公共模式并没有什么特别之处。它也可以被删除。</target>
        </trans-unit>
        <trans-unit id="0d0e01998d1caf45906467ce09eb6d9f85a24392" translate="yes" xml:space="preserve">
          <source>Then we will get these results:</source>
          <target state="translated">那么我们就会得到这些结果。</target>
        </trans-unit>
        <trans-unit id="30348812ea695911ccd6ce73f8cff665d67bd9ad" translate="yes" xml:space="preserve">
          <source>Then you can use it in a &lt;code&gt;SELECT&lt;/code&gt; command, for instance:</source>
          <target state="translated">然后，您可以在 &lt;code&gt;SELECT&lt;/code&gt; 命令中使用它，例如：</target>
        </trans-unit>
        <trans-unit id="0c956d2a4c1c867a4aa753ae841035f68a38bb7b" translate="yes" xml:space="preserve">
          <source>Then you could name the files in the &lt;code&gt;conf.d&lt;/code&gt; directory like this:</source>
          <target state="translated">然后，您可以像下面这样命名 &lt;code&gt;conf.d&lt;/code&gt; 目录中的文件：</target>
        </trans-unit>
        <trans-unit id="f4c7647dc71f8f47d91ed549387e0af6d05b17ea" translate="yes" xml:space="preserve">
          <source>Then, create a symbolic link to it in &lt;code&gt;/etc/rc3.d&lt;/code&gt; as &lt;code&gt;S99postgresql&lt;/code&gt;.</source>
          <target state="translated">然后，在 &lt;code&gt;/etc/rc3.d&lt;/code&gt; 中以 &lt;code&gt;S99postgresql&lt;/code&gt; 的形式创建指向它的符号链接。</target>
        </trans-unit>
        <trans-unit id="e196180497775135006d17c14fe064e7b2203578" translate="yes" xml:space="preserve">
          <source>Then, sign the request with the key to create a root certificate authority (using the default OpenSSL configuration file location on Linux):</source>
          <target state="translated">然后,用密钥签署请求,创建一个根证书授权(使用Linux上默认的OpenSSL配置文件位置)。</target>
        </trans-unit>
        <trans-unit id="50d0f1107bc900bc4a9d5405919a76e23f028a3e" translate="yes" xml:space="preserve">
          <source>There also exist local objects that do not belong to schemas; some examples are &lt;a href=&quot;glossary#GLOSSARY-EXTENSION&quot;&gt;extensions&lt;/a&gt;, &lt;a href=&quot;glossary#GLOSSARY-CAST&quot;&gt;data type casts&lt;/a&gt;, and &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-DATA-WRAPPER&quot;&gt;foreign data wrappers&lt;/a&gt;. The names of such objects of the same type are enforced to be unique within the database.</source>
          <target state="translated">还存在不属于模式的局部对象；它们是局部对象。一些示例是&lt;a href=&quot;glossary#GLOSSARY-EXTENSION&quot;&gt;扩展&lt;/a&gt;，&lt;a href=&quot;glossary#GLOSSARY-CAST&quot;&gt;数据类型转换&lt;/a&gt;和&lt;a href=&quot;glossary#GLOSSARY-FOREIGN-DATA-WRAPPER&quot;&gt;外部数据包装器&lt;/a&gt;。此类相同类型的对象的名称在数据库中被强制为唯一。</target>
        </trans-unit>
        <trans-unit id="5100635bf226727d046c206be142bf5ea8b71db2" translate="yes" xml:space="preserve">
          <source>There are a few built-in trigger functions that can be used to solve common problems without having to write your own trigger code; see &lt;a href=&quot;https://www.postgresql.org/docs/13/functions-trigger.html&quot;&gt;Section 9.28&lt;/a&gt;.</source>
          <target state="translated">有一些内置的触发函数可用于解决常见问题，而无需编写您自己的触发代码。参见&lt;a href=&quot;https://www.postgresql.org/docs/13/functions-trigger.html&quot;&gt;第9.28节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6e6f711b66bbac69a2f23c2445e625c076269156" translate="yes" xml:space="preserve">
          <source>There are a few restrictions on operator names, however:</source>
          <target state="translated">但对运营商名称有一些限制。</target>
        </trans-unit>
        <trans-unit id="e06308b22446d8ff8a3bec464184e0db33a1b8e3" translate="yes" xml:space="preserve">
          <source>There are a few restrictions on your choice of name:</source>
          <target state="translated">对您选择的名字有一些限制。</target>
        </trans-unit>
        <trans-unit id="e38ec4f8f8d1c9acce491ad6d51f28d3688ffbf6" translate="yes" xml:space="preserve">
          <source>There are a few solutions that do not fit into the above categories:</source>
          <target state="translated">有一些解决方案不符合上述类别。</target>
        </trans-unit>
        <trans-unit id="f2d4b5a4acbfddfda3fa8af2f47936fbae4e67b7" translate="yes" xml:space="preserve">
          <source>There are a few things to be careful about when adding trace macros to the C code:</source>
          <target state="translated">在C代码中添加跟踪宏时,有几点需要注意。</target>
        </trans-unit>
        <trans-unit id="30225d755151e996e06d97ca5afb06ce57185f7a" translate="yes" xml:space="preserve">
          <source>There are a few things you need to do to simplify importing CSV log files:</source>
          <target state="translated">您需要做一些事情来简化CSV日志文件的导入。</target>
        </trans-unit>
        <trans-unit id="86f7d5ba0c83b5c117ed409216f966f9d7eef72d" translate="yes" xml:space="preserve">
          <source>There are also additional types of conflict that can occur with Hot Standby. These conflicts are &lt;em&gt;hard conflicts&lt;/em&gt; in the sense that queries might need to be canceled and, in some cases, sessions disconnected to resolve them. The user is provided with several ways to handle these conflicts. Conflict cases include:</source>
          <target state="translated">热备份还会发生其他类型的冲突。从某种意义上说，这些冲突是&lt;em&gt;硬冲突&lt;/em&gt;，可能需要取消查询，并且在某些情况下，会话需要断开连接才能解决它们。为用户提供了处理这些冲突的几种方法。冲突案件包括：</target>
        </trans-unit>
        <trans-unit id="080fe8c96ab19e790a2ea0bd30b8130c9a87b676" translate="yes" xml:space="preserve">
          <source>There are also some built-in operator classes besides the default ones:</source>
          <target state="translated">除了默认的操作类,还有一些内置的操作类。</target>
        </trans-unit>
        <trans-unit id="b8bbd8454471c92fa3e16174c667ec63b3cc9c3f" translate="yes" xml:space="preserve">
          <source>There are also some comparison predicates, as shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-PRED-TABLE&quot;&gt;Table 9.2&lt;/a&gt;. These behave much like operators, but have special syntax mandated by the SQL standard.</source>
          <target state="translated">还有一些比较谓词，如&lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-PRED-TABLE&quot;&gt;表9.2&lt;/a&gt;所示。它们的行为很像运算符，但是具有SQL标准规定的特殊语法。</target>
        </trans-unit>
        <trans-unit id="11f3ba822c528ebdfeb9746d393a7742a7d6e349" translate="yes" xml:space="preserve">
          <source>There are cases in which the actual and estimated values won't match up well, but nothing is really wrong. One such case occurs when plan node execution is stopped short by a &lt;code&gt;LIMIT&lt;/code&gt; or similar effect. For example, in the &lt;code&gt;LIMIT&lt;/code&gt; query we used before,</source>
          <target state="translated">在某些情况下，实际值和估计值不能很好地匹配，但是没有什么是真正错误的。当由于 &lt;code&gt;LIMIT&lt;/code&gt; 或类似作用而使计划节点执行短暂停止时，就会发生这种情况。例如，在我们之前使用的 &lt;code&gt;LIMIT&lt;/code&gt; 查询中，</target>
        </trans-unit>
        <trans-unit id="626c9a7674dab9b044bc50641f2a4b064da217a4" translate="yes" xml:space="preserve">
          <source>There are certain operations that hold critical locks and should therefore complete as quickly as possible. Cost-based vacuum delays do not occur during such operations. Therefore it is possible that the cost accumulates far higher than the specified limit. To avoid uselessly long delays in such cases, the actual delay is calculated as &lt;code&gt;vacuum_cost_delay&lt;/code&gt; * &lt;code&gt;accumulated_balance&lt;/code&gt; / &lt;code&gt;vacuum_cost_limit&lt;/code&gt; with a maximum of &lt;code&gt;vacuum_cost_delay&lt;/code&gt; * 4.</source>
          <target state="translated">有一些操作具有关键锁，因此应尽快完成。在此类操作期间不会发生基于成本的真空延迟。因此，成本累积可能远远高于指定的限制。为了避免在这种情况下无用的长时间延迟，实际延迟的计算方式是 &lt;code&gt;vacuum_cost_delay&lt;/code&gt; * &lt;code&gt;accumulated_balance&lt;/code&gt; / &lt;code&gt;vacuum_cost_limit&lt;/code&gt; ，最大值为 &lt;code&gt;vacuum_cost_delay&lt;/code&gt; * 4。</target>
        </trans-unit>
        <trans-unit id="49623fffc3b27e386ddb0902bf870bdd64aa14c1" translate="yes" xml:space="preserve">
          <source>There are different kinds of privileges: &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;TRUNCATE&lt;/code&gt;, &lt;code&gt;REFERENCES&lt;/code&gt;, &lt;code&gt;TRIGGER&lt;/code&gt;, &lt;code&gt;CREATE&lt;/code&gt;, &lt;code&gt;CONNECT&lt;/code&gt;, &lt;code&gt;TEMPORARY&lt;/code&gt;, &lt;code&gt;EXECUTE&lt;/code&gt;, and &lt;code&gt;USAGE&lt;/code&gt;. The privileges applicable to a particular object vary depending on the object's type (table, function, etc). More detail about the meanings of these privileges appears below. The following sections and chapters will also show you how these privileges are used.</source>
          <target state="translated">特权有多种： &lt;code&gt;SELECT&lt;/code&gt; ， &lt;code&gt;INSERT&lt;/code&gt; ， &lt;code&gt;UPDATE&lt;/code&gt; ， &lt;code&gt;DELETE&lt;/code&gt; ， &lt;code&gt;TRUNCATE&lt;/code&gt; ， &lt;code&gt;REFERENCES&lt;/code&gt; ， &lt;code&gt;TRIGGER&lt;/code&gt; ， &lt;code&gt;CREATE&lt;/code&gt; ， &lt;code&gt;CONNECT&lt;/code&gt; ， &lt;code&gt;TEMPORARY&lt;/code&gt; ， &lt;code&gt;EXECUTE&lt;/code&gt; 和 &lt;code&gt;USAGE&lt;/code&gt; 。适用于特定对象的特权因对象的类型（表，函数等）而异。有关这些特权的含义的更多详细信息显示在下面。以下各节和各章还将向您展示如何使用这些特权。</target>
        </trans-unit>
        <trans-unit id="2f4c8f7302f72ae7897c7273dc4e0796366f4575" translate="yes" xml:space="preserve">
          <source>There are examples in &lt;code&gt;refint.example&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;refint.example&lt;/code&gt; 中有一些示例。</target>
        </trans-unit>
        <trans-unit id="e74d4a0a2f4513529b90fbecc5989b2ddcb617e4" translate="yes" xml:space="preserve">
          <source>There are five forms of &lt;code&gt;CREATE TYPE&lt;/code&gt;, as shown in the syntax synopsis above. They respectively create a &lt;em&gt;composite type&lt;/em&gt;, an &lt;em&gt;enum type&lt;/em&gt;, a &lt;em&gt;range type&lt;/em&gt;, a &lt;em&gt;base type&lt;/em&gt;, or a &lt;em&gt;shell type&lt;/em&gt;. The first four of these are discussed in turn below. A shell type is simply a placeholder for a type to be defined later; it is created by issuing &lt;code&gt;CREATE TYPE&lt;/code&gt; with no parameters except for the type name. Shell types are needed as forward references when creating range types and base types, as discussed in those sections.</source>
          <target state="translated">如上面的语法概要所示，有五种形式的 &lt;code&gt;CREATE TYPE&lt;/code&gt; 。它们分别创建&lt;em&gt;复合类型&lt;/em&gt;，&lt;em&gt;枚举类型&lt;/em&gt;，&lt;em&gt;范围类型&lt;/em&gt;，&lt;em&gt;基类型&lt;/em&gt;或&lt;em&gt;外壳类型&lt;/em&gt;。下面依次讨论其中的前四个。壳类型只是用于稍后定义的类型的占位符；它是通过发出 &lt;code&gt;CREATE TYPE&lt;/code&gt; 来创建的，除了类型名称外，不带任何参数。如这些部分所述，在创建范围类型和基本类型时，需要使用Shell类型作为前向引用。</target>
        </trans-unit>
        <trans-unit id="6b159eaf60b6b4119e8b7cbd7a662966676f50a3" translate="yes" xml:space="preserve">
          <source>There are five methods that an index operator class for GiST must provide, and five that are optional. Correctness of the index is ensured by proper implementation of the &lt;code&gt;same&lt;/code&gt;, &lt;code&gt;consistent&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; methods, while efficiency (size and speed) of the index will depend on the &lt;code&gt;penalty&lt;/code&gt; and &lt;code&gt;picksplit&lt;/code&gt; methods. Two optional methods are &lt;code&gt;compress&lt;/code&gt; and &lt;code&gt;decompress&lt;/code&gt;, which allow an index to have internal tree data of a different type than the data it indexes. The leaves are to be of the indexed data type, while the other tree nodes can be of any C struct (but you still have to follow PostgreSQL data type rules here, see about &lt;code&gt;varlena&lt;/code&gt; for variable sized data). If the tree's internal data type exists at the SQL level, the &lt;code&gt;STORAGE&lt;/code&gt; option of the &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; command can be used. The optional eighth method is &lt;code&gt;distance&lt;/code&gt;, which is needed if the operator class wishes to support ordered scans (nearest-neighbor searches). The optional ninth method &lt;code&gt;fetch&lt;/code&gt; is needed if the operator class wishes to support index-only scans, except when the &lt;code&gt;compress&lt;/code&gt; method is omitted. The optional tenth method &lt;code&gt;options&lt;/code&gt; is needed if the operator class provides the user-specified parameters.</source>
          <target state="translated">GiST的索引运算符类必须提供五种方法，其中五种是可选的。正确执行 &lt;code&gt;same&lt;/code&gt; ， &lt;code&gt;consistent&lt;/code&gt; 和 &lt;code&gt;union&lt;/code&gt; 方法可以确保索引的正确性，而索引的效率（大小和速度）则取决于 &lt;code&gt;penalty&lt;/code&gt; 和 &lt;code&gt;picksplit&lt;/code&gt; 方法。有两种可选的方法 &lt;code&gt;compress&lt;/code&gt; 和 &lt;code&gt;decompress&lt;/code&gt; ，它们允许索引具有与其索引的数据不同类型的内部树数据。叶子将是索引数据类型，而其他树节点可以是任何C结构（但您仍然必须在此处遵循PostgreSQL数据类型规则，有关 &lt;code&gt;varlena&lt;/code&gt; 的信息)对于可变大小的数据）。如果树的内部数据类型在SQL级别存在，则可以使用 &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; 命令的 &lt;code&gt;STORAGE&lt;/code&gt; 选项。可选的第八种方法是 &lt;code&gt;distance&lt;/code&gt; ，如果操作员类别希望支持有序扫描（最近邻居搜索），则需要使用此方法。如果操作员类希望支持仅索引扫描，则需要可选的第九个方法 &lt;code&gt;fetch&lt;/code&gt; 存，除非省略了 &lt;code&gt;compress&lt;/code&gt; 方法。如果操作员类提供了用户指定的参数，则需要可选的第十个方法 &lt;code&gt;options&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1c0e123011cea9ffa5e9167dd8e734710858d21" translate="yes" xml:space="preserve">
          <source>There are five methods that an index operator class for GiST must provide, and four that are optional. Correctness of the index is ensured by proper implementation of the &lt;code&gt;same&lt;/code&gt;, &lt;code&gt;consistent&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; methods, while efficiency (size and speed) of the index will depend on the &lt;code&gt;penalty&lt;/code&gt; and &lt;code&gt;picksplit&lt;/code&gt; methods. Two optional methods are &lt;code&gt;compress&lt;/code&gt; and &lt;code&gt;decompress&lt;/code&gt;, which allow an index to have internal tree data of a different type than the data it indexes. The leaves are to be of the indexed data type, while the other tree nodes can be of any C struct (but you still have to follow PostgreSQL data type rules here, see about &lt;code&gt;varlena&lt;/code&gt; for variable sized data). If the tree's internal data type exists at the SQL level, the &lt;code&gt;STORAGE&lt;/code&gt; option of the &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; command can be used. The optional eighth method is &lt;code&gt;distance&lt;/code&gt;, which is needed if the operator class wishes to support ordered scans (nearest-neighbor searches). The optional ninth method &lt;code&gt;fetch&lt;/code&gt; is needed if the operator class wishes to support index-only scans, except when the &lt;code&gt;compress&lt;/code&gt; method is omitted.</source>
          <target state="translated">GiST的索引运算符类必须提供五种方法，其中四种是可选的。正确执行 &lt;code&gt;same&lt;/code&gt; ， &lt;code&gt;consistent&lt;/code&gt; 和 &lt;code&gt;union&lt;/code&gt; 方法可确保索引的正确性，而索引的效率（大小和速度）将取决于 &lt;code&gt;penalty&lt;/code&gt; 和 &lt;code&gt;picksplit&lt;/code&gt; 方法。有两种可选的方法 &lt;code&gt;compress&lt;/code&gt; 和 &lt;code&gt;decompress&lt;/code&gt; ，它们允许索引具有与其索引的数据不同类型的内部树数据。叶子将是索引数据类型，而其他树节点可以是任何C结构（但您仍然必须在这里遵循PostgreSQL数据类型规则，有关 &lt;code&gt;varlena&lt;/code&gt; 对于可变大小的数据）。如果树的内部数据类型在SQL级别存在，则可以使用 &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; 命令的 &lt;code&gt;STORAGE&lt;/code&gt; 选项。可选的第八种方法是 &lt;code&gt;distance&lt;/code&gt; ，如果操作员类别希望支持有序扫描（最近邻居搜索），则需要此方法。如果操作员类希望支持仅索引扫描，则需要可选的第九个方法 &lt;code&gt;fetch&lt;/code&gt; 存，除非省略了 &lt;code&gt;compress&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="29e9f9add6de4117c3f41e8f16d45114f4cd168c" translate="yes" xml:space="preserve">
          <source>There are five user-defined methods that an index operator class for SP-GiST must provide, and one is optional. All five mandatory methods follow the convention of accepting two &lt;code&gt;internal&lt;/code&gt; arguments, the first of which is a pointer to a C struct containing input values for the support method, while the second argument is a pointer to a C struct where output values must be placed. Four of the mandatory methods just return &lt;code&gt;void&lt;/code&gt;, since all their results appear in the output struct; but &lt;code&gt;leaf_consistent&lt;/code&gt; additionally returns a &lt;code&gt;boolean&lt;/code&gt; result. The methods must not modify any fields of their input structs. In all cases, the output struct is initialized to zeroes before calling the user-defined method. The optional sixth method &lt;code&gt;compress&lt;/code&gt; accepts datum to be indexed as the only argument and returns a value suitable for physical storage in a leaf tuple.</source>
          <target state="translated">SP-GiST的索引运算符类必须提供五种用户定义的方法，其中一种是可选的。所有五个强制方法都遵循接受两个 &lt;code&gt;internal&lt;/code&gt; 参数的约定，其中第一个是指向包含支持方法输入值的C结构的指针，而第二个参数是指向必须放置输出值的C结构的指针。四个强制方法仅返回 &lt;code&gt;void&lt;/code&gt; ，因为它们的所有结果都出现在输出结构中；但 &lt;code&gt;leaf_consistent&lt;/code&gt; 还会返回 &lt;code&gt;boolean&lt;/code&gt; 结果。这些方法不得修改其输入结构的任何字段。在所有情况下，在调用用户定义的方法之前，将输出结构初始化为零。可选的第六种方法 &lt;code&gt;compress&lt;/code&gt; 接受要索引的数据作为唯一参数，并返回适合物理存储在叶元组中的值。</target>
        </trans-unit>
        <trans-unit id="666f4f8fef47bb1c6205d9fa4aaa2bdc7c54c92a" translate="yes" xml:space="preserve">
          <source>There are five user-defined methods that an index operator class for SP-GiST must provide, and two are optional. All five mandatory methods follow the convention of accepting two &lt;code&gt;internal&lt;/code&gt; arguments, the first of which is a pointer to a C struct containing input values for the support method, while the second argument is a pointer to a C struct where output values must be placed. Four of the mandatory methods just return &lt;code&gt;void&lt;/code&gt;, since all their results appear in the output struct; but &lt;code&gt;leaf_consistent&lt;/code&gt; returns a &lt;code&gt;boolean&lt;/code&gt; result. The methods must not modify any fields of their input structs. In all cases, the output struct is initialized to zeroes before calling the user-defined method. The optional sixth method &lt;code&gt;compress&lt;/code&gt; accepts a &lt;code&gt;datum&lt;/code&gt; to be indexed as the only argument and returns a value suitable for physical storage in a leaf tuple. The optional seventh method &lt;code&gt;options&lt;/code&gt; accepts an &lt;code&gt;internal&lt;/code&gt; pointer to a C struct, where opclass-specific parameters should be placed, and returns &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">SP-GiST的索引运算符类必须提供五种用户定义的方法，其中两种是可选的。所有五个强制方法都遵循接受两个 &lt;code&gt;internal&lt;/code&gt; 参数的约定，第一个是指向包含支持方法输入值的C结构的指针，而第二个参数是指向必须放置输出值的C结构的指针。四个强制方法只返回 &lt;code&gt;void&lt;/code&gt; ，因为它们的所有结果都出现在输出结构中；但是 &lt;code&gt;leaf_consistent&lt;/code&gt; 返回 &lt;code&gt;boolean&lt;/code&gt; 结果。这些方法不得修改其输入结构的任何字段。在所有情况下，在调用用户定义的方法之前，将输出结构初始化为零。可选的第六种方法 &lt;code&gt;compress&lt;/code&gt; 接受要索引的 &lt;code&gt;datum&lt;/code&gt; 作为唯一参数，并返回适合物理存储在叶元组中的值。可选的第七种方法 &lt;code&gt;options&lt;/code&gt; 接受指向C结构的 &lt;code&gt;internal&lt;/code&gt; 指针，该结构应放置opclass特定的参数，并返回 &lt;code&gt;void&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa03941817da7215f34f7c4059988c3830f85876" translate="yes" xml:space="preserve">
          <source>There are four fundamental SQL constructs requiring distinct type conversion rules in the PostgreSQL parser:</source>
          <target state="translated">在PostgreSQL解析器中,有四个基本的SQL结构需要不同的类型转换规则。</target>
        </trans-unit>
        <trans-unit id="af078d5f8f920b3bd3ff699db4f54f596acf2a85" translate="yes" xml:space="preserve">
          <source>There are four methods that an operator class for BRIN must provide:</source>
          <target state="translated">BRIN的操作员类必须提供四个方法。</target>
        </trans-unit>
        <trans-unit id="dc37bd22ec5c580834570b2476e6fe4f24b8403a" translate="yes" xml:space="preserve">
          <source>There are minor differences in the interpretation of regular expression patterns used in &lt;code&gt;like_regex&lt;/code&gt; filters, as described in &lt;a href=&quot;functions-json#JSONPATH-REGULAR-EXPRESSIONS&quot;&gt;Section 9.15.2.2&lt;/a&gt;.</source>
          <target state="translated">如&lt;a href=&quot;functions-json#JSONPATH-REGULAR-EXPRESSIONS&quot;&gt;9.15.2.2节中&lt;/a&gt;所述，在 &lt;code&gt;like_regex&lt;/code&gt; 过滤器中使用的正则表达式模式的解释之间存在细微差异。</target>
        </trans-unit>
        <trans-unit id="1d77bf2fc4587de107eca9fd91e0707c3fe21d0a" translate="yes" xml:space="preserve">
          <source>There are minor differences in the interpretation of regular expression patterns used in &lt;code&gt;like_regex&lt;/code&gt; filters, as described in &lt;a href=&quot;functions-json#JSONPATH-REGULAR-EXPRESSIONS&quot;&gt;Section 9.16.2.3&lt;/a&gt;.</source>
          <target state="translated">如&lt;a href=&quot;functions-json#JSONPATH-REGULAR-EXPRESSIONS&quot;&gt;第9.16.2.3节中&lt;/a&gt;所述，在 &lt;code&gt;like_regex&lt;/code&gt; 过滤器中使用的正则表达式模式的解释之间存在细微差异。</target>
        </trans-unit>
        <trans-unit id="e2d1e6b157368edb7a34c08bf06a60ee5f8744e9" translate="yes" xml:space="preserve">
          <source>There are not currently any commands that manipulate procedural language templates; to change the built-in information, a superuser must modify the table using ordinary &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, or &lt;code&gt;UPDATE&lt;/code&gt; commands.</source>
          <target state="translated">当前没有任何可操作过程语言模板的命令。要更改内置信息，超级用户必须使用普通的 &lt;code&gt;INSERT&lt;/code&gt; ， &lt;code&gt;DELETE&lt;/code&gt; 或 &lt;code&gt;UPDATE&lt;/code&gt; 命令修改表。</target>
        </trans-unit>
        <trans-unit id="18b7b9a654dddbbbf44432092fdfff639afd65c3" translate="yes" xml:space="preserve">
          <source>There are parallel variants of these operators for both the &lt;code&gt;json&lt;/code&gt; and &lt;code&gt;jsonb&lt;/code&gt; types. The field/element/path extraction operators return the same type as their left-hand input (either &lt;code&gt;json&lt;/code&gt; or &lt;code&gt;jsonb&lt;/code&gt;), except for those specified as returning &lt;code&gt;text&lt;/code&gt;, which coerce the value to text. The field/element/path extraction operators return NULL, rather than failing, if the JSON input does not have the right structure to match the request; for example if no such element exists. The field/element/path extraction operators that accept integer JSON array subscripts all support negative subscripting from the end of arrays.</source>
          <target state="translated">对于 &lt;code&gt;json&lt;/code&gt; 和 &lt;code&gt;jsonb&lt;/code&gt; 类型，这些运算符都有并行的变体。字段/元素/路径提取运算符返回与其左侧输入相同的类型（ &lt;code&gt;json&lt;/code&gt; 或 &lt;code&gt;jsonb&lt;/code&gt; ），但指定为返回 &lt;code&gt;text&lt;/code&gt; 的类型除外，这些运算符将值强制转换为text。如果JSON输入的结构不符合请求，则字段/元素/路径提取运算符将返回NULL而不是失败。例如，如果不存在这样的元素。接受整数JSON数组下标的字段/元素/路径提取运算符都支持从数组末尾开始的负下标。</target>
        </trans-unit>
        <trans-unit id="f87d9a17505cfd4cb8b88d986ea842eb4469f8b6" translate="yes" xml:space="preserve">
          <source>There are several &lt;code&gt;substr&lt;/code&gt; functions, one of which takes types &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;integer&lt;/code&gt;. If called with a string constant of unspecified type, the system chooses the candidate function that accepts an argument of the preferred category &lt;code&gt;string&lt;/code&gt; (namely of type &lt;code&gt;text&lt;/code&gt;).</source>
          <target state="translated">有几个 &lt;code&gt;substr&lt;/code&gt; 函数，其中之一采用类型 &lt;code&gt;text&lt;/code&gt; 和 &lt;code&gt;integer&lt;/code&gt; 。如果使用未指定类型的字符串常量进行调用，则系统会选择候选函数，该函数接受首选类别 &lt;code&gt;string&lt;/code&gt; （即 &lt;code&gt;text&lt;/code&gt; 类型）的参数。</target>
        </trans-unit>
        <trans-unit id="4a86c45854efa996c6173d14634a86acbb0fae9b" translate="yes" xml:space="preserve">
          <source>There are several WAL-related configuration parameters that affect database performance. This section explains their use. Consult &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; for general information about setting server configuration parameters.</source>
          <target state="translated">有几个与WAL相关的配置参数会影响数据库性能。本节说明其用法。有关设置服务器配置参数的一般信息，请参阅&lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;第19章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b72e63e0c980adc25f0dbe77097459ea5e3e677a" translate="yes" xml:space="preserve">
          <source>There are several WAL-related configuration parameters that affect database performance. This section explains their use. Consult &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; for general information about setting server configuration parameters.</source>
          <target state="translated">有几个与WAL相关的配置参数会影响数据库性能。本节说明它们的用法。有关设置服务器配置参数的一般信息，请参阅&lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;第19章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="90a47baf0edabbb7ab4de9adfe99efaea9932730" translate="yes" xml:space="preserve">
          <source>There are several caveats to be aware of when using this option. Only one index name can be specified, and the &lt;code&gt;CASCADE&lt;/code&gt; option is not supported. (Thus, an index that supports a &lt;code&gt;UNIQUE&lt;/code&gt; or &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraint cannot be dropped this way.) Also, regular &lt;code&gt;DROP INDEX&lt;/code&gt; commands can be performed within a transaction block, but &lt;code&gt;DROP INDEX CONCURRENTLY&lt;/code&gt; cannot.</source>
          <target state="translated">使用此选项时需要注意几个注意事项。只能指定一个索引名称，并且不支持 &lt;code&gt;CASCADE&lt;/code&gt; 选项。（因此，不能以这种方式删除支持 &lt;code&gt;UNIQUE&lt;/code&gt; 或 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 约束的索引。）而且，可以在事务块内执行常规的 &lt;code&gt;DROP INDEX&lt;/code&gt; 命令，但不能以 &lt;code&gt;DROP INDEX CONCURRENTLY&lt;/code&gt; 执行。</target>
        </trans-unit>
        <trans-unit id="ce288b97182be46ed306ba70355423aaea68f94a" translate="yes" xml:space="preserve">
          <source>There are several caveats to be aware of when using this option. Only one index name can be specified, and the &lt;code&gt;CASCADE&lt;/code&gt; option is not supported. (Thus, an index that supports a &lt;code&gt;UNIQUE&lt;/code&gt; or &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraint cannot be dropped this way.) Also, regular &lt;code&gt;DROP INDEX&lt;/code&gt; commands can be performed within a transaction block, but &lt;code&gt;DROP INDEX CONCURRENTLY&lt;/code&gt; cannot. Lastly, indexes on partitioned tables cannot be dropped using this option.</source>
          <target state="translated">使用此选项时需要注意几个注意事项。只能指定一个索引名称，并且不支持 &lt;code&gt;CASCADE&lt;/code&gt; 选项。（因此，无法以这种方式删除支持 &lt;code&gt;UNIQUE&lt;/code&gt; 或 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 约束的索引。）此外，可以在事务块内执行常规的 &lt;code&gt;DROP INDEX&lt;/code&gt; 命令，但不能以 &lt;code&gt;DROP INDEX CONCURRENTLY&lt;/code&gt; 方式执行。最后，不能使用此选项删除分区表上的索引。</target>
        </trans-unit>
        <trans-unit id="91dcaac9ead3b10f651956a96badf0ae2f79aa1a" translate="yes" xml:space="preserve">
          <source>There are several common reasons the server might fail to start. Check the server's log file, or start it by hand (without redirecting standard output or standard error) and see what error messages appear. Below we explain some of the most common error messages in more detail.</source>
          <target state="translated">服务器可能无法启动的常见原因有以下几种。检查服务器的日志文件,或者手动启动它(不重定向标准输出或标准错误),看看有哪些错误信息出现。下面我们详细解释一些最常见的错误信息。</target>
        </trans-unit>
        <trans-unit id="9adbaa62a8322d6f35b205f33d65aadeb73701d5" translate="yes" xml:space="preserve">
          <source>There are several configuration parameters that control the behavior of &lt;code&gt;auto_explain&lt;/code&gt;. Note that the default behavior is to do nothing, so you must set at least &lt;code&gt;auto_explain.log_min_duration&lt;/code&gt; if you want any results.</source>
          <target state="translated">有几个配置参数可控制 &lt;code&gt;auto_explain&lt;/code&gt; 的行为。请注意，默认行为是不执行任何操作，因此，如果需要任何结果，则必须至少设置 &lt;code&gt;auto_explain.log_min_duration&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d56877000af0d37b6fb862a08aad3882b83fec73" translate="yes" xml:space="preserve">
          <source>There are several distinct types of lockable objects: whole relations (e.g., tables), individual pages of relations, individual tuples of relations, transaction IDs (both virtual and permanent IDs), and general database objects (identified by class OID and object OID, in the same way as in &lt;code&gt;pg_description&lt;/code&gt; or &lt;code&gt;pg_depend&lt;/code&gt;). Also, the right to extend a relation is represented as a separate lockable object, as is the right to update &lt;code&gt;pg_database&lt;/code&gt;.&lt;code&gt;datfrozenxid&lt;/code&gt;. Also, &amp;ldquo;advisory&amp;rdquo; locks can be taken on numbers that have user-defined meanings.</source>
          <target state="translated">有几种不同类型的可锁定对象：整个关系（例如表），单个关系页面，单个关系元组，事务ID（虚拟ID和永久ID）以及通用数据库对象（由OID类和对象OID标识，以与 &lt;code&gt;pg_description&lt;/code&gt; 或 &lt;code&gt;pg_depend&lt;/code&gt; 相同的方式）。同样，扩展关系的权限也表示为单独的可锁定对象，更新 &lt;code&gt;pg_database&lt;/code&gt; 的权限也是如此。 &lt;code&gt;datfrozenxid&lt;/code&gt; 。同样，可以对具有用户定义含义的数字进行&amp;ldquo;建议&amp;rdquo;锁定。</target>
        </trans-unit>
        <trans-unit id="8f07db15d474ec8167b00bf77d56e7101e3f26c7" translate="yes" xml:space="preserve">
          <source>There are several distinct types of lockable objects: whole relations (e.g., tables), individual pages of relations, individual tuples of relations, transaction IDs (both virtual and permanent IDs), and general database objects (identified by class OID and object OID, in the same way as in &lt;code&gt;pg_description&lt;/code&gt; or &lt;code&gt;pg_depend&lt;/code&gt;). Also, the right to extend a relation is represented as a separate lockable object. Also, &amp;ldquo;advisory&amp;rdquo; locks can be taken on numbers that have user-defined meanings.</source>
          <target state="translated">有几种不同类型的可锁定对象：整个关系（例如表），单个关系页面，单个关系元组，事务ID（虚拟ID和永久ID）以及通用数据库对象（由OID类和对象OID标识，以与 &lt;code&gt;pg_description&lt;/code&gt; 或 &lt;code&gt;pg_depend&lt;/code&gt; 相同的方式）。同样，扩展关系的权利也表示为单独的可锁定对象。同样，可以对具有用户定义含义的数字进行&amp;ldquo;建议&amp;rdquo;锁定。</target>
        </trans-unit>
        <trans-unit id="114cb14410efa6f2de15cd3a5be68d31fc1e555a" translate="yes" xml:space="preserve">
          <source>There are several limitations of Hot Standby. These can and probably will be fixed in future releases:</source>
          <target state="translated">热备份有几个限制。这些限制可以而且可能会在未来的版本中得到修正。</target>
        </trans-unit>
        <trans-unit id="faced4b79c9138d3cc4676d1e4253b24407642f4" translate="yes" xml:space="preserve">
          <source>There are several modifiers that can be put at the end of a non-star &lt;code&gt;lquery&lt;/code&gt; item to make it match more than just the exact match:</source>
          <target state="translated">可以在非星号 &lt;code&gt;lquery&lt;/code&gt; 项的末尾添加多个修饰符，以使其比完全匹配更匹配：</target>
        </trans-unit>
        <trans-unit id="9e6c3965c75b70506035e1130db0d24734cc5245" translate="yes" xml:space="preserve">
          <source>There are several modifiers that can be put at the end of a non-star label in &lt;code&gt;lquery&lt;/code&gt; to make it match more than just the exact match:</source>
          <target state="translated">可以在 &lt;code&gt;lquery&lt;/code&gt; 中的非星号标签的末尾添加几个修饰符，以使其比完全匹配更匹配：</target>
        </trans-unit>
        <trans-unit id="c65cdf0a50b535370cafd7a5d8814b1949feb7fa" translate="yes" xml:space="preserve">
          <source>There are several password-based authentication methods. These methods operate similarly but differ in how the users' passwords are stored on the server and how the password provided by a client is sent across the connection.</source>
          <target state="translated">有几种基于密码的认证方法。这些方法的操作类似,但不同的是用户的密码如何存储在服务器上,以及客户端提供的密码如何通过连接发送。</target>
        </trans-unit>
        <trans-unit id="82697895b0fc3864eed5346e0a502ff9ce90f8b6" translate="yes" xml:space="preserve">
          <source>There are several possible values of &lt;code&gt;context&lt;/code&gt;. In order of decreasing difficulty of changing the setting, they are:</source>
          <target state="translated">有几种可能的 &lt;code&gt;context&lt;/code&gt; 值。为了降低更改设置的难度，它们是：</target>
        </trans-unit>
        <trans-unit id="412101ab8ec853191b9bda2fa3098ca1192d7103" translate="yes" xml:space="preserve">
          <source>There are several reasons why one might want to use schemas:</source>
          <target state="translated">为什么要使用模式,有几个原因。</target>
        </trans-unit>
        <trans-unit id="47ec670ad87a5a65f5d73f50b758515c8d78f032" translate="yes" xml:space="preserve">
          <source>There are several settings which can cause the query planner not to generate a parallel query plan under any circumstances. In order for any parallel query plans whatsoever to be generated, the following settings must be configured as indicated.</source>
          <target state="translated">在任何情况下,有几种设置可以导致查询规划器不生成并行查询计划。为了使任何并行查询计划得以生成,必须按所示配置以下设置。</target>
        </trans-unit>
        <trans-unit id="4a490c0d4b72a8988d006fa28baad623b333c2c3" translate="yes" xml:space="preserve">
          <source>There are several ways around this problem. One simple answer is to use &lt;code&gt;SELECT ... FOR SHARE&lt;/code&gt; in sub-&lt;code&gt;SELECT&lt;/code&gt;s in row security policies. However, that requires granting &lt;code&gt;UPDATE&lt;/code&gt; privilege on the referenced table (here &lt;code&gt;users&lt;/code&gt;) to the affected users, which might be undesirable. (But another row security policy could be applied to prevent them from actually exercising that privilege; or the sub-&lt;code&gt;SELECT&lt;/code&gt; could be embedded into a security definer function.) Also, heavy concurrent use of row share locks on the referenced table could pose a performance problem, especially if updates of it are frequent. Another solution, practical if updates of the referenced table are infrequent, is to take an exclusive lock on the referenced table when updating it, so that no concurrent transactions could be examining old row values. Or one could just wait for all concurrent transactions to end after committing an update of the referenced table and before making changes that rely on the new security situation.</source>
          <target state="translated">有几种方法可以解决此问题。一个简单的答案是在行安全策略的sub &lt;code&gt;SELECT&lt;/code&gt; 中使用 &lt;code&gt;SELECT ... FOR SHARE&lt;/code&gt; 。但是，这需要向受影响的用户授予对引用表（此处为 &lt;code&gt;users&lt;/code&gt; ）的 &lt;code&gt;UPDATE&lt;/code&gt; 特权，这可能是不希望的。 （但是，可以应用另一行安全策略来防止他们实际行使该特权；或者子 &lt;code&gt;SELECT&lt;/code&gt; 此外，大量并发使用引用表上的行共享锁可能会导致性能问题，尤其是在频繁更新的情况下。如果不经常更新被引用表，则另一种可行的解决方案是在更新被引用表时对其进行排他锁，以使任何并发事务都无法检查旧行值。或者，可以在提交引用表的更新之后并在依赖新的安全状况进行更改之前等待所有并发事务结束。</target>
        </trans-unit>
        <trans-unit id="78c41a8baf3f45e2e246f13ef8df748fedf21ff4" translate="yes" xml:space="preserve">
          <source>There are several ways to shut down the database server. Under the hood, they all reduce to sending a signal to the supervisor &lt;code&gt;postgres&lt;/code&gt; process.</source>
          <target state="translated">有几种关闭数据库服务器的方法。在后台，他们全都减少了向主管 &lt;code&gt;postgres&lt;/code&gt; 过程发送信号的过程。</target>
        </trans-unit>
        <trans-unit id="0a65d46642b8ea0d625c08a9a29af3d8886f49e2" translate="yes" xml:space="preserve">
          <source>There are several ways to shut down the database server. You control the type of shutdown by sending different signals to the master &lt;code&gt;postgres&lt;/code&gt; process.</source>
          <target state="translated">有几种关闭数据库服务器的方法。您可以通过向主 &lt;code&gt;postgres&lt;/code&gt; 进程发送不同的信号来控制关闭的类型。</target>
        </trans-unit>
        <trans-unit id="f2aaff5fcb38efacb1d58514b7509e951bb1187c" translate="yes" xml:space="preserve">
          <source>There are some basic assumptions that a btree operator family must satisfy:</source>
          <target state="translated">有一些基本的假设,btree操作族必须满足。</target>
        </trans-unit>
        <trans-unit id="0b521cdf532a9a953ad42c30cbfbc097cf6b1b08" translate="yes" xml:space="preserve">
          <source>There are three available prewarming methods. &lt;code&gt;prefetch&lt;/code&gt; issues asynchronous prefetch requests to the operating system, if this is supported, or throws an error otherwise. &lt;code&gt;read&lt;/code&gt; reads the requested range of blocks; unlike &lt;code&gt;prefetch&lt;/code&gt;, this is synchronous and supported on all platforms and builds, but may be slower. &lt;code&gt;buffer&lt;/code&gt; reads the requested range of blocks into the database buffer cache.</source>
          <target state="translated">有三种可用的预热方法。 &lt;code&gt;prefetch&lt;/code&gt; 问题异步预取请求到操作系统，如果这是支持的，否则抛出一个错误。 &lt;code&gt;read&lt;/code&gt; 读取请求的块范围；与 &lt;code&gt;prefetch&lt;/code&gt; 不同，它是同步的，并且在所有平台和内部版本上均受支持，但可能更慢。 &lt;code&gt;buffer&lt;/code&gt; 将请求的块范围读入数据库缓冲区高速缓存。</target>
        </trans-unit>
        <trans-unit id="cb805126a31ff8c55ee475c5fbc01109be8dd511" translate="yes" xml:space="preserve">
          <source>There are three kinds of &lt;em&gt;implicitly-typed constants&lt;/em&gt; in PostgreSQL: strings, bit strings, and numbers. Constants can also be specified with explicit types, which can enable more accurate representation and more efficient handling by the system. These alternatives are discussed in the following subsections.</source>
          <target state="translated">PostgreSQL中有三种&lt;em&gt;隐式类型的常量&lt;/em&gt;：字符串，位字符串和数字。常量也可以用显式类型指定，这可以使系统实现更准确的表示和更有效的处理。以下各节将讨论这些替代方案。</target>
        </trans-unit>
        <trans-unit id="30766d90eb25e2981c2e600b788f88cc0665cda4" translate="yes" xml:space="preserve">
          <source>There are three possible syntaxes for an operator invocation:</source>
          <target state="translated">操作符调用有三种可能的语法。</target>
        </trans-unit>
        <trans-unit id="7ac1c9045fce554fb04868e602b7a9908c87947d" translate="yes" xml:space="preserve">
          <source>There are three separate approaches to pattern matching provided by PostgreSQL: the traditional SQL &lt;code&gt;LIKE&lt;/code&gt; operator, the more recent &lt;code&gt;SIMILAR TO&lt;/code&gt; operator (added in SQL:1999), and POSIX-style regular expressions. Aside from the basic &amp;ldquo;does this string match this pattern?&amp;rdquo; operators, functions are available to extract or replace matching substrings and to split a string at matching locations.</source>
          <target state="translated">PostgreSQL提供了三种单独的模式匹配方法：传统的SQL &lt;code&gt;LIKE&lt;/code&gt; 运算符，更新的 &lt;code&gt;SIMILAR TO&lt;/code&gt; 运算符（在SQL：1999中添加）和POSIX样式的正则表达式。除了基本的&amp;ldquo;此字符串是否匹配此模式？&amp;rdquo; 运算符，函数可用于提取或替换匹配的子字符串并在匹配的位置拆分字符串。</target>
        </trans-unit>
        <trans-unit id="c74bdd55156d3b2783c8a6fd237fe0bceb9cfeef" translate="yes" xml:space="preserve">
          <source>There are two approaches to enforce that users provide a certificate during login.</source>
          <target state="translated">有两种方法可以强制用户在登录时提供证书。</target>
        </trans-unit>
        <trans-unit id="03a8c876ced91bb81f55235d3d3af76552bcc675" translate="yes" xml:space="preserve">
          <source>There are two categories of limitation to keep in mind: the restriction from XQuery to XPath for the functions specified in the SQL standard, and the restriction of XPath to version 1.0 for both the standard and the PostgreSQL-specific functions.</source>
          <target state="translated">需要注意的限制有两类:对于SQL标准中指定的函数,从XQuery到XPath的限制;对于标准和PostgreSQL专用函数,XPath的限制是1.0版本。</target>
        </trans-unit>
        <trans-unit id="45979291689bf78b7c41886076f2033f33bb0dc2" translate="yes" xml:space="preserve">
          <source>There are two columns containing the city name. This is correct because the lists of columns from the &lt;code&gt;weather&lt;/code&gt; and &lt;code&gt;cities&lt;/code&gt; tables are concatenated. In practice this is undesirable, though, so you will probably want to list the output columns explicitly rather than using &lt;code&gt;*&lt;/code&gt;:</source>
          <target state="translated">有两列包含城市名称。这是正确的，因为 &lt;code&gt;weather&lt;/code&gt; 和 &lt;code&gt;cities&lt;/code&gt; 表中的列列表是串联的。但是，在实践中这是不希望的，因此您可能希望显式列出输出列，而不是使用 &lt;code&gt;*&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="65ab8b09fb62c8b1237a292bc36db36c5b33b77b" translate="yes" xml:space="preserve">
          <source>There are two commonly used internal WAL functions: &lt;code&gt;XLogInsertRecord&lt;/code&gt; and &lt;code&gt;XLogFlush&lt;/code&gt;. &lt;code&gt;XLogInsertRecord&lt;/code&gt; is used to place a new record into the WAL buffers in shared memory. If there is no space for the new record, &lt;code&gt;XLogInsertRecord&lt;/code&gt; will have to write (move to kernel cache) a few filled WAL buffers. This is undesirable because &lt;code&gt;XLogInsertRecord&lt;/code&gt; is used on every database low level modification (for example, row insertion) at a time when an exclusive lock is held on affected data pages, so the operation needs to be as fast as possible. What is worse, writing WAL buffers might also force the creation of a new log segment, which takes even more time. Normally, WAL buffers should be written and flushed by an &lt;code&gt;XLogFlush&lt;/code&gt; request, which is made, for the most part, at transaction commit time to ensure that transaction records are flushed to permanent storage. On systems with high log output, &lt;code&gt;XLogFlush&lt;/code&gt; requests might not occur often enough to prevent &lt;code&gt;XLogInsertRecord&lt;/code&gt; from having to do writes. On such systems one should increase the number of WAL buffers by modifying the &lt;a href=&quot;runtime-config-wal#GUC-WAL-BUFFERS&quot;&gt;wal_buffers&lt;/a&gt; parameter. When &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; is set and the system is very busy, setting &lt;code&gt;wal_buffers&lt;/code&gt; higher will help smooth response times during the period immediately following each checkpoint.</source>
          <target state="translated">有两个常用的内部WAL函数： &lt;code&gt;XLogInsertRecord&lt;/code&gt; 和 &lt;code&gt;XLogFlush&lt;/code&gt; 。 &lt;code&gt;XLogInsertRecord&lt;/code&gt; 用于将新记录放入共享内存中的WAL缓冲区中。如果新记录没有空间，则 &lt;code&gt;XLogInsertRecord&lt;/code&gt; 将不得不写入（移至内核缓存）一些已填充的WAL缓冲区。这是不希望的，因为在受影响的数据页上保持排他锁的同时，每次对数据库进行低级别修改（例如，行插入）时都使用 &lt;code&gt;XLogInsertRecord&lt;/code&gt; ，因此操作需要尽可能快。更糟糕的是，编写WAL缓冲区也可能会强制创建新的日志段，这会花费更多时间。通常，WAL缓冲区应写入并刷新 &lt;code&gt;XLogFlush&lt;/code&gt; 请求，在很大程度上是在事务提交时发出的，以确保将事务记录刷新到永久存储。在具有高日志输出的系统上， &lt;code&gt;XLogFlush&lt;/code&gt; 请求可能不会足够频繁地发生，以防止 &lt;code&gt;XLogInsertRecord&lt;/code&gt; 必须进行写操作。在这样的系统上，应该通过修改&lt;a href=&quot;runtime-config-wal#GUC-WAL-BUFFERS&quot;&gt;wal_buffers&lt;/a&gt;参数来增加WAL缓冲区的数量。当设置了&lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt;并且系统非常忙时，将 &lt;code&gt;wal_buffers&lt;/code&gt; 设置得更高将有助于在紧接每个检查点之后的时间段内缩短响应时间。</target>
        </trans-unit>
        <trans-unit id="1612227459001e258e7447e0effe46078acfe3e4" translate="yes" xml:space="preserve">
          <source>There are two differences in the behavior of &lt;code&gt;string_to_array&lt;/code&gt; from pre-9.1 versions of PostgreSQL. First, it will return an empty (zero-element) array rather than &lt;code&gt;NULL&lt;/code&gt; when the input string is of zero length. Second, if the delimiter string is &lt;code&gt;NULL&lt;/code&gt;, the function splits the input into individual characters, rather than returning &lt;code&gt;NULL&lt;/code&gt; as before.</source>
          <target state="translated">与9.1之前的PostgreSQL版本相比， &lt;code&gt;string_to_array&lt;/code&gt; 的行为有两个差异。首先，当输入字符串的长度为零时，它将返回一个空（零元素）数组，而不是 &lt;code&gt;NULL&lt;/code&gt; 。其次，如果定界符字符串为 &lt;code&gt;NULL&lt;/code&gt; ，则该函数将输入拆分为单个字符，而不是像以前一样返回 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e556036ec4c364c079311c21d04103cf4c7118b6" translate="yes" xml:space="preserve">
          <source>There are two differences in the behavior of &lt;code&gt;string_to_array&lt;/code&gt; from pre-9.1 versions of PostgreSQL. First, it will return an empty (zero-element) array rather than NULL when the input string is of zero length. Second, if the delimiter string is NULL, the function splits the input into individual characters, rather than returning NULL as before.</source>
          <target state="translated">与9.1之前的PostgreSQL版本相比， &lt;code&gt;string_to_array&lt;/code&gt; 的行为有两个区别。首先，当输入字符串的长度为零时，它将返回一个空（零元素）数组，而不是NULL。其次，如果定界符字符串为NULL，则该函数将输入拆分为单个字符，而不是像以前一样返回NULL。</target>
        </trans-unit>
        <trans-unit id="9a38ac647b826e47337bf978dbd260eda2d37e47" translate="yes" xml:space="preserve">
          <source>There are two forms of the &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; command. In the first form, the user supplies just the name of the desired language, and the PostgreSQL server consults the &lt;a href=&quot;catalog-pg-pltemplate&quot;&gt;&lt;code&gt;pg_pltemplate&lt;/code&gt;&lt;/a&gt; system catalog to determine the correct parameters. In the second form, the user supplies the language parameters along with the language name. The second form can be used to create a language that is not defined in &lt;code&gt;pg_pltemplate&lt;/code&gt;, but this approach is considered obsolescent.</source>
          <target state="translated">&lt;code&gt;CREATE LANGUAGE&lt;/code&gt; 命令有两种形式。在第一种形式中，用户仅提供所需语言的名称，而PostgreSQL服务器查询&lt;a href=&quot;catalog-pg-pltemplate&quot;&gt; &lt;code&gt;pg_pltemplate&lt;/code&gt; &lt;/a&gt;系统目录以确定正确的参数。在第二种形式中，用户提供语言参数以及语言名称。第二种形式可用于创建 &lt;code&gt;pg_pltemplate&lt;/code&gt; 中未定义的语言，但是这种方法被认为是过时的。</target>
        </trans-unit>
        <trans-unit id="f9cc8590527e484357685c3a4d915bc501e931e5" translate="yes" xml:space="preserve">
          <source>There are two kinds of indexes that can be used to speed up full text searches. Note that indexes are not mandatory for full text searching, but in cases where a column is searched on a regular basis, an index is usually desirable.</source>
          <target state="translated">有两种索引可以用来加快全文检索的速度。请注意,索引并不是全文检索的必备条件,但在经常检索某一列的情况下,通常需要索引。</target>
        </trans-unit>
        <trans-unit id="0b78b765f97cf8944029e53f4ab00dc6de355959" translate="yes" xml:space="preserve">
          <source>There are two methods that an operator class for GIN must provide:</source>
          <target state="translated">有两个方法是GIN的操作员类必须提供的。</target>
        </trans-unit>
        <trans-unit id="2ebcfbeecc8c9e28432149890e115326d408ee9d" translate="yes" xml:space="preserve">
          <source>There are two other fixed-length character types in PostgreSQL, shown in &lt;a href=&quot;datatype-character#DATATYPE-CHARACTER-SPECIAL-TABLE&quot;&gt;Table 8.5&lt;/a&gt;. The &lt;code&gt;name&lt;/code&gt; type exists &lt;em&gt;only&lt;/em&gt; for the storage of identifiers in the internal system catalogs and is not intended for use by the general user. Its length is currently defined as 64 bytes (63 usable characters plus terminator) but should be referenced using the constant &lt;code&gt;NAMEDATALEN&lt;/code&gt; in &lt;code&gt;C&lt;/code&gt; source code. The length is set at compile time (and is therefore adjustable for special uses); the default maximum length might change in a future release. The type &lt;code&gt;&quot;char&quot;&lt;/code&gt; (note the quotes) is different from &lt;code&gt;char(1)&lt;/code&gt; in that it only uses one byte of storage. It is internally used in the system catalogs as a simplistic enumeration type.</source>
          <target state="translated">PostgreSQL中还有其他两种定长字符类型，如&lt;a href=&quot;datatype-character#DATATYPE-CHARACTER-SPECIAL-TABLE&quot;&gt;表8.5&lt;/a&gt;所示。的 &lt;code&gt;name&lt;/code&gt; 类型存在&lt;em&gt;仅&lt;/em&gt;标识符的内部系统目录中存储，并且不旨在用于由一般用户使用。它的长度当前被定义为64个字节（63个可用字符加上终止子），但应使用恒定引用 &lt;code&gt;NAMEDATALEN&lt;/code&gt; 在 &lt;code&gt;C&lt;/code&gt; 源代码。该长度是在编译时设置的（因此可以针对特殊用途进行调整）；默认最大长度在将来的版本中可能会更改。类型 &lt;code&gt;&quot;char&quot;&lt;/code&gt; （请注意引号）不同于 &lt;code&gt;char(1)&lt;/code&gt; 因为它只使用一个字节的存储空间。在系统目录中内部使用它作为一种简单的枚举类型。</target>
        </trans-unit>
        <trans-unit id="1a65ab8661e9c6e6250372b71f3e4d52aadd8690" translate="yes" xml:space="preserve">
          <source>There are two restrictions, however, which make this method impractical, or at least inferior to the pg_dump method:</source>
          <target state="translated">然而,有两个限制使得这种方法不切实际,或者至少不如pg_dump方法。</target>
        </trans-unit>
        <trans-unit id="eb559c725c45849ac1890ba81d8ba70c6affbb84" translate="yes" xml:space="preserve">
          <source>There are two significant ways in which run times measured by &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; can deviate from normal execution of the same query. First, since no output rows are delivered to the client, network transmission costs and I/O conversion costs are not included. Second, the measurement overhead added by &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; can be significant, especially on machines with slow &lt;code&gt;gettimeofday()&lt;/code&gt; operating-system calls. You can use the &lt;a href=&quot;pgtesttiming&quot;&gt;pg_test_timing&lt;/a&gt; tool to measure the overhead of timing on your system.</source>
          <target state="translated">&lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 度量的运行时间有两种重要的方式可以偏离同一查询的正常执行。首先，由于没有输出行交付给客户端，因此不包括网络传输成本和I / O转换成本。其次， &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 增加的测量开销可能很大，尤其是在 &lt;code&gt;gettimeofday()&lt;/code&gt; 操作系统调用缓慢的计算机上。您可以使用&lt;a href=&quot;pgtesttiming&quot;&gt;pg_test_timing&lt;/a&gt;工具来测量系统计时的开销。</target>
        </trans-unit>
        <trans-unit id="e4b4937b46d88bd048aae10c82ed3779adc47d2b" translate="yes" xml:space="preserve">
          <source>There are two special cases of bracket expressions: the bracket expressions &lt;code&gt;[[:&amp;lt;:]]&lt;/code&gt; and &lt;code&gt;[[:&amp;gt;:]]&lt;/code&gt; are constraints, matching empty strings at the beginning and end of a word respectively. A word is defined as a sequence of word characters that is neither preceded nor followed by word characters. A word character is an &lt;code&gt;alnum&lt;/code&gt; character (as defined by the POSIX character class described above) or an underscore. This is an extension, compatible with but not specified by POSIX 1003.2, and should be used with caution in software intended to be portable to other systems. The constraint escapes described below are usually preferable; they are no more standard, but are easier to type.</source>
          <target state="translated">方括号表达式有两种特殊情况：方括号表达式 &lt;code&gt;[[:&amp;lt;:]]&lt;/code&gt; 和 &lt;code&gt;[[:&amp;gt;:]]&lt;/code&gt; 是约束，它们分别在单词的开头和结尾匹配空字符串。单词被定义为单词字符序列，该序列既不能在单词字符之前也不能在单词字符之后。单词字符是 &lt;code&gt;alnum&lt;/code&gt; 字符（由上述POSIX字符类定义）或下划线。这是一个扩展，与POSIX 1003.2兼容，但未指定该扩展，在要移植到其他系统的软件中应谨慎使用。通常最好使用下面描述的约束转义；它们不再是标准的，但更易于键入。</target>
        </trans-unit>
        <trans-unit id="33967632431b8aaf7d1ba8660310b5c4fbf05d2a" translate="yes" xml:space="preserve">
          <source>There are two variants of &lt;code&gt;VACUUM&lt;/code&gt;: standard &lt;code&gt;VACUUM&lt;/code&gt; and &lt;code&gt;VACUUM FULL&lt;/code&gt;. &lt;code&gt;VACUUM FULL&lt;/code&gt; can reclaim more disk space but runs much more slowly. Also, the standard form of &lt;code&gt;VACUUM&lt;/code&gt; can run in parallel with production database operations. (Commands such as &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt; will continue to function normally, though you will not be able to modify the definition of a table with commands such as &lt;code&gt;ALTER TABLE&lt;/code&gt; while it is being vacuumed.) &lt;code&gt;VACUUM FULL&lt;/code&gt; requires exclusive lock on the table it is working on, and therefore cannot be done in parallel with other use of the table. Generally, therefore, administrators should strive to use standard &lt;code&gt;VACUUM&lt;/code&gt; and avoid &lt;code&gt;VACUUM FULL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; 有两种变体：标准 &lt;code&gt;VACUUM&lt;/code&gt; 和 &lt;code&gt;VACUUM FULL&lt;/code&gt; 。 &lt;code&gt;VACUUM FULL&lt;/code&gt; 可以回收更多磁盘空间，但运行速度要慢得多。而且， &lt;code&gt;VACUUM&lt;/code&gt; 的标准形式可以与生产数据库操作并行运行。 （尽管在清理过程中无法使用诸如 &lt;code&gt;ALTER TABLE&lt;/code&gt; 之类的命令来修改表的定义，但是诸如 &lt;code&gt;SELECT&lt;/code&gt; ， &lt;code&gt;INSERT&lt;/code&gt; ， &lt;code&gt;UPDATE&lt;/code&gt; 和 &lt;code&gt;DELETE&lt;/code&gt; 之类的命令将继续正常运行。） &lt;code&gt;VACUUM FULL&lt;/code&gt; 需要对正在处理的表进行排他锁，因此不能与该表的其他使用并行进行。因此，通常，管理员应努力使用标准 &lt;code&gt;VACUUM&lt;/code&gt; 并避免 &lt;code&gt;VACUUM FULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="082cbad2612b1a539364141256cd8c079fbdd04c" translate="yes" xml:space="preserve">
          <source>There are two ways to acquire an advisory lock in PostgreSQL: at session level or at transaction level. Once acquired at session level, an advisory lock is held until explicitly released or the session ends. Unlike standard lock requests, session-level advisory lock requests do not honor transaction semantics: a lock acquired during a transaction that is later rolled back will still be held following the rollback, and likewise an unlock is effective even if the calling transaction fails later. A lock can be acquired multiple times by its owning process; for each completed lock request there must be a corresponding unlock request before the lock is actually released. Transaction-level lock requests, on the other hand, behave more like regular lock requests: they are automatically released at the end of the transaction, and there is no explicit unlock operation. This behavior is often more convenient than the session-level behavior for short-term usage of an advisory lock. Session-level and transaction-level lock requests for the same advisory lock identifier will block each other in the expected way. If a session already holds a given advisory lock, additional requests by it will always succeed, even if other sessions are awaiting the lock; this statement is true regardless of whether the existing lock hold and new request are at session level or transaction level.</source>
          <target state="translated">在PostgreSQL中获取咨询锁有两种方式:会话级或事务级。一旦在会话级别获取,咨询锁就会被保留,直到明确释放或会话结束。与标准的锁请求不同,会话级的咨询锁请求不尊重事务语义:在事务中获取的锁,如果后来被回滚,那么在回滚后仍然会被持有,同样,即使后来调用的事务失败,解锁也是有效的。一个锁可以被自己的进程多次获取;对于每一个完成的锁请求,必须有一个相应的解锁请求,才能真正释放锁。另一方面,事务级锁请求的行为更像常规的锁请求:它们在事务结束时自动释放,而且没有显式解锁操作。对于咨询锁的短期使用来说,这种行为通常比会话级行为更方便。对同一咨询锁标识符的会话级和事务级锁请求将以预期的方式相互阻塞。如果一个会话已经持有一个给定的咨询锁,那么它的额外请求将总是成功的,即使其他会话正在等待该锁;无论现有的锁持有和新的请求是在会话级还是事务级,这个声明都是正确的。</target>
        </trans-unit>
        <trans-unit id="d918b8ea922c6c6ee662eb9ab4cebb7da36eb443" translate="yes" xml:space="preserve">
          <source>There are two ways to define constraints: table constraints and column constraints. A column constraint is defined as part of a column definition. A table constraint definition is not tied to a particular column, and it can encompass more than one column. Every column constraint can also be written as a table constraint; a column constraint is only a notational convenience for use when the constraint only affects one column.</source>
          <target state="translated">定义约束有两种方式:表约束和列约束。列约束被定义为列定义的一部分。表约束定义不与某一列绑定,它可以包含多个列。每一个列约束也都可以写成表约束,列约束只是在约束只影响一列时使用的一种符号上的方便。</target>
        </trans-unit>
        <trans-unit id="3100ad6baa7faf64044c5fff315dddab6008581f" translate="yes" xml:space="preserve">
          <source>There are two ways to delete rows in a table using information contained in other tables in the database: using sub-selects, or specifying additional tables in the &lt;code&gt;USING&lt;/code&gt; clause. Which technique is more appropriate depends on the specific circumstances.</source>
          <target state="translated">使用数据库中其他表中包含的信息删除表中的行有两种方法：使用子选择，或在 &lt;code&gt;USING&lt;/code&gt; 子句中指定其他表。哪种技术更合适取​​决于具体情况。</target>
        </trans-unit>
        <trans-unit id="9d2cb602ac946da832fb98a751bc210a74312a33" translate="yes" xml:space="preserve">
          <source>There are two ways to modify a table using information contained in other tables in the database: using sub-selects, or specifying additional tables in the &lt;code&gt;FROM&lt;/code&gt; clause. Which technique is more appropriate depends on the specific circumstances.</source>
          <target state="translated">使用数据库中其他表中包含的信息来修改表有两种方法：使用子选择，或在 &lt;code&gt;FROM&lt;/code&gt; 子句中指定其他表。哪种技术更合适取​​决于具体情况。</target>
        </trans-unit>
        <trans-unit id="aa2e4ae09129d50722332a9a349176e58b93478a" translate="yes" xml:space="preserve">
          <source>There are various shortcut commands for &lt;code&gt;\pset&lt;/code&gt;. See &lt;code&gt;\a&lt;/code&gt;, &lt;code&gt;\C&lt;/code&gt;, &lt;code&gt;\f&lt;/code&gt;, &lt;code&gt;\H&lt;/code&gt;, &lt;code&gt;\t&lt;/code&gt;, &lt;code&gt;\T&lt;/code&gt;, and &lt;code&gt;\x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\pset&lt;/code&gt; 有多种快捷方式命令。参见 &lt;code&gt;\a&lt;/code&gt; ， &lt;code&gt;\C&lt;/code&gt; ， &lt;code&gt;\f&lt;/code&gt; ， &lt;code&gt;\H&lt;/code&gt; ， &lt;code&gt;\t&lt;/code&gt; ， &lt;code&gt;\T&lt;/code&gt; 和 &lt;code&gt;\x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36d44242f8d38cae700147e3f10ad23b2c1671f8" translate="yes" xml:space="preserve">
          <source>There are various special syntax rules and behaviors associated with composite types in queries. These rules provide useful shortcuts, but can be confusing if you don't know the logic behind them.</source>
          <target state="translated">在查询中,有各种与复合类型相关的特殊语法规则和行为。这些规则提供了有用的捷径,但如果你不知道它们背后的逻辑,就会感到困惑。</target>
        </trans-unit>
        <trans-unit id="adeaa568e81b8c22d184926d9648a6a85b174068" translate="yes" xml:space="preserve">
          <source>There can be multiple &lt;code&gt;pg_basebackup&lt;/code&gt;s running at the same time, but it is better from a performance point of view to take only one backup, and copy the result.</source>
          <target state="translated">可以同时运行多个 &lt;code&gt;pg_basebackup&lt;/code&gt; ，但是从性能的角度来看，最好只备份一个并复制结果。</target>
        </trans-unit>
        <trans-unit id="20d4685d4d3e4d67053c5be3bcdf1498541d87e6" translate="yes" xml:space="preserve">
          <source>There can be multiple &lt;code&gt;pg_basebackup&lt;/code&gt;s running at the same time, but it is usually better from a performance point of view to take only one backup, and copy the result.</source>
          <target state="translated">可以同时运行多个 &lt;code&gt;pg_basebackup&lt;/code&gt; ，但是从性能的角度来看，通常最好只备份一个并复制结果。</target>
        </trans-unit>
        <trans-unit id="241118165bea21fbe830bef68a27cbb0152bef40" translate="yes" xml:space="preserve">
          <source>There is a &amp;ldquo;simple&amp;rdquo; form of &lt;code&gt;CASE&lt;/code&gt; expression that is a variant of the general form above:</source>
          <target state="translated">&lt;code&gt;CASE&lt;/code&gt; 表达式有一种&amp;ldquo;简单&amp;rdquo;形式，是上述通用形式的一种变体：</target>
        </trans-unit>
        <trans-unit id="0a329b25f5c93a21ac5ea836673c784c6afc768a" translate="yes" xml:space="preserve">
          <source>There is a &lt;code&gt;CREATE COLLATION&lt;/code&gt; statement in the SQL standard, but it is limited to copying an existing collation. The syntax to create a new collation is a PostgreSQL extension.</source>
          <target state="translated">SQL标准中有一个 &lt;code&gt;CREATE COLLATION&lt;/code&gt; 语句，但仅限于复制现有的排序规则。创建新排序规则的语法是PostgreSQL扩展。</target>
        </trans-unit>
        <trans-unit id="74c08b98f45942b4395776e7da22b84f7266e5c2" translate="yes" xml:space="preserve">
          <source>There is a catch if you try to use conditional rules for complex view updates: there &lt;em&gt;must&lt;/em&gt; be an unconditional &lt;code&gt;INSTEAD&lt;/code&gt; rule for each action you wish to allow on the view. If the rule is conditional, or is not &lt;code&gt;INSTEAD&lt;/code&gt;, then the system will still reject attempts to perform the update action, because it thinks it might end up trying to perform the action on the dummy table of the view in some cases. If you want to handle all the useful cases in conditional rules, add an unconditional &lt;code&gt;DO INSTEAD NOTHING&lt;/code&gt; rule to ensure that the system understands it will never be called on to update the dummy table. Then make the conditional rules non-&lt;code&gt;INSTEAD&lt;/code&gt;; in the cases where they are applied, they add to the default &lt;code&gt;INSTEAD NOTHING&lt;/code&gt; action. (This method does not currently work to support &lt;code&gt;RETURNING&lt;/code&gt; queries, however.)</source>
          <target state="translated">如果您尝试使用条件规则进行复杂的视图更新，则有一个陷阱：您希望在视图上允许的每个操作都&lt;em&gt;必须&lt;/em&gt;有一个无条件的 &lt;code&gt;INSTEAD&lt;/code&gt; 规则。如果规则是有条件的，或者不是 &lt;code&gt;INSTEAD&lt;/code&gt; ，则系统仍将拒绝执行更新操作的尝试，因为它认为在某些情况下可能最终尝试对视图的虚拟表执行操作。如果要处理条件规则中的所有有用情况，请添加一个无条件的 &lt;code&gt;DO INSTEAD NOTHING&lt;/code&gt; 规则，以确保系统知道永远不会调用它来更新虚拟表。然后将条件规则 &lt;code&gt;INSTEAD&lt;/code&gt; 非INSTEAD；在应用它们的情况下，它们会添加到默认值 &lt;code&gt;INSTEAD NOTHING&lt;/code&gt; 动作。（但是，该方法当前不适用于支持 &lt;code&gt;RETURNING&lt;/code&gt; 查询。）</target>
        </trans-unit>
        <trans-unit id="c21f127ac29ffa6b6d6cad86ad16cb8ebd82f4c7" translate="yes" xml:space="preserve">
          <source>There is a limit on how many columns a table can contain. Depending on the column types, it is between 250 and 1600. However, defining a table with anywhere near this many columns is highly unusual and often a questionable design.</source>
          <target state="translated">一个表可以包含多少列是有限制的。根据列的类型,它在250到1600之间。然而,定义一个表的列数接近这么多是非常不寻常的,而且往往是一个有问题的设计。</target>
        </trans-unit>
        <trans-unit id="60f67c0e3cf6c026c3a97cec11f99b88526b93a6" translate="yes" xml:space="preserve">
          <source>There is a more general version of the FOLLOWED BY operator having the form &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is an integer standing for the difference between the positions of the matching lexemes. &lt;code&gt;&amp;lt;1&amp;gt;&lt;/code&gt; is the same as &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt;, while &lt;code&gt;&amp;lt;2&amp;gt;&lt;/code&gt; allows exactly one other lexeme to appear between the matches, and so on. The &lt;code&gt;phraseto_tsquery&lt;/code&gt; function makes use of this operator to construct a &lt;code&gt;tsquery&lt;/code&gt; that can match a multi-word phrase when some of the words are stop words. For example:</source>
          <target state="translated">FOLLOWED BY运算符有一个更通用的版本，格式为 &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; ，其中 &lt;code&gt;N&lt;/code&gt; 是代表匹配词素位置之间的差的整数。 &lt;code&gt;&amp;lt;1&amp;gt;&lt;/code&gt; 与 &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; 相同，而 &lt;code&gt;&amp;lt;2&amp;gt;&lt;/code&gt; 允许在匹配之间出现另外一个词素，依此类推。该 &lt;code&gt;phraseto_tsquery&lt;/code&gt; 功能使得使用该运营商构建一个 &lt;code&gt;tsquery&lt;/code&gt; 当一些的话是停止的话，可以搭配多词短语。例如：</target>
        </trans-unit>
        <trans-unit id="98845715e9aff2aab5a7e45eba23b610067562bc" translate="yes" xml:space="preserve">
          <source>There is a possibility that a concurrent &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; on the row being moved will get a serialization failure error. Suppose session 1 is performing an &lt;code&gt;UPDATE&lt;/code&gt; on a partition key, and meanwhile a concurrent session 2 for which this row is visible performs an &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; operation on this row. In such case, session 2's &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; will detect the row movement and raise a serialization failure error (which always returns with an SQLSTATE code '40001'). Applications may wish to retry the transaction if this occurs. In the usual case where the table is not partitioned, or where there is no row movement, session 2 would have identified the newly updated row and carried out the &lt;code&gt;UPDATE&lt;/code&gt;/&lt;code&gt;DELETE&lt;/code&gt; on this new row version.</source>
          <target state="translated">被移动的行上的并发 &lt;code&gt;UPDATE&lt;/code&gt; 或 &lt;code&gt;DELETE&lt;/code&gt; 可能会出现序列化失败错误。假设会话1正在对分区键执行 &lt;code&gt;UPDATE&lt;/code&gt; ，而与此同时可见该行的并发会话2对该行执行 &lt;code&gt;UPDATE&lt;/code&gt; 或 &lt;code&gt;DELETE&lt;/code&gt; 操作。在这种情况下，会话2的 &lt;code&gt;UPDATE&lt;/code&gt; 或 &lt;code&gt;DELETE&lt;/code&gt; 将检测行的移动并引发序列化失败错误（始终返回SQLSTATE代码&amp;ldquo; 40001&amp;rdquo;）。如果发生这种情况，应用程序可能希望重试该事务。在表未分区或没有行移动的通常情况下，会话2将识别出新近更新的行并对该新行版本执行 &lt;code&gt;UPDATE&lt;/code&gt; / &lt;code&gt;DELETE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2fb3023d52c67871f97870f963ae3e2511e1afd" translate="yes" xml:space="preserve">
          <source>There is a queue that holds notifications that have been sent but not yet processed by all listening sessions. If this queue becomes full, transactions calling &lt;code&gt;NOTIFY&lt;/code&gt; will fail at commit. The queue is quite large (8GB in a standard installation) and should be sufficiently sized for almost every use case. However, no cleanup can take place if a session executes &lt;code&gt;LISTEN&lt;/code&gt; and then enters a transaction for a very long time. Once the queue is half full you will see warnings in the log file pointing you to the session that is preventing cleanup. In this case you should make sure that this session ends its current transaction so that cleanup can proceed.</source>
          <target state="translated">有一个队列，其中包含已发送但尚未被所有侦听会话处理的通知。如果此队列已满，则调用 &lt;code&gt;NOTIFY&lt;/code&gt; 的事务将在提交时失败。队列很大（标准安装中为8GB），并且对于几乎所有用例，其大小都应足够。但是，如果会话执行 &lt;code&gt;LISTEN&lt;/code&gt; 然后输入事务很长时间，则不会进行任何清理。一旦队列半满，您将在日志文件中看到警告，指出您指向阻止清除的会话。在这种情况下，您应确保该会话结束其当前事务，以便可以进行清理。</target>
        </trans-unit>
        <trans-unit id="a6acd66eed300880ccbb1a71d22c7409bc533b1e" translate="yes" xml:space="preserve">
          <source>There is a race condition when first setting up a listening session: if concurrently-committing transactions are sending notify events, exactly which of those will the newly listening session receive? The answer is that the session will receive all events committed after an instant during the transaction's commit step. But that is slightly later than any database state that the transaction could have observed in queries. This leads to the following rule for using &lt;code&gt;LISTEN&lt;/code&gt;: first execute (and commit!) that command, then in a new transaction inspect the database state as needed by the application logic, then rely on notifications to find out about subsequent changes to the database state. The first few received notifications might refer to updates already observed in the initial database inspection, but this is usually harmless.</source>
          <target state="translated">首次建立侦听会话时，存在竞争条件：如果同时提交的事务正在发送通知事件，那么新侦听会话将确切接收哪些事件？答案是会话将在事务的提交步骤中的一瞬间之后接收所有提交的事件。但这比该事务在查询中可能观察到的任何数据库状态稍晚。这导致使用 &lt;code&gt;LISTEN&lt;/code&gt; 的以下规则：首先执行（并提交！）该命令，然后在新事务中根据应用程序逻辑的需要检查数据库状态，然后依靠通知来查找对数据库状态的后续更改。最初收到的几条通知可能涉及在初始数据库检查中已经观察到的更新，但这通常是无害的。</target>
        </trans-unit>
        <trans-unit id="7f864b552f926f474ffeb07a0a68232c7a34815b" translate="yes" xml:space="preserve">
          <source>There is a second kind of identifier: the &lt;em&gt;delimited identifier&lt;/em&gt; or &lt;em&gt;quoted identifier&lt;/em&gt;. It is formed by enclosing an arbitrary sequence of characters in double-quotes (&lt;code&gt;&quot;&lt;/code&gt;). A delimited identifier is always an identifier, never a key word. So &lt;code&gt;&quot;select&quot;&lt;/code&gt; could be used to refer to a column or table named &amp;ldquo;select&amp;rdquo;, whereas an unquoted &lt;code&gt;select&lt;/code&gt; would be taken as a key word and would therefore provoke a parse error when used where a table or column name is expected. The example can be written with quoted identifiers like this:</source>
          <target state="translated">还有第二种标识符：带&lt;em&gt;分隔符的标识符&lt;/em&gt;或带&lt;em&gt;引号的标识符&lt;/em&gt;。它是通过将任意字符序列括在双引号（ &lt;code&gt;&quot;&lt;/code&gt; ）中形成的。定界的标识符始终是标识符，而不是关键字。因此， &lt;code&gt;&quot;select&quot;&lt;/code&gt; 可用于引用名为&amp;rdquo; select&amp;ldquo;的列或表，而未加引号的 &lt;code&gt;select&lt;/code&gt; 将作为关键字，因此在期望使用表或列名称的地方使用时会引发解析错误，该示例可以用加引号的标识符编写，如下所示：</target>
        </trans-unit>
        <trans-unit id="0ad93af24a4ac7faa267b7d3536c1e6d83e1bf68" translate="yes" xml:space="preserve">
          <source>There is a second standard system database named &lt;code&gt;template0&lt;/code&gt;. This database contains the same data as the initial contents of &lt;code&gt;template1&lt;/code&gt;, that is, only the standard objects predefined by your version of PostgreSQL. &lt;code&gt;template0&lt;/code&gt; should never be changed after the database cluster has been initialized. By instructing &lt;code&gt;CREATE DATABASE&lt;/code&gt; to copy &lt;code&gt;template0&lt;/code&gt; instead of &lt;code&gt;template1&lt;/code&gt;, you can create a &amp;ldquo;pristine&amp;rdquo; user database (one where no user-defined objects exist and where the system objects have not been altered) that contains none of the site-local additions in &lt;code&gt;template1&lt;/code&gt;. This is particularly handy when restoring a &lt;code&gt;pg_dump&lt;/code&gt; dump: the dump script should be restored in a pristine database to ensure that one recreates the correct contents of the dumped database, without conflicting with objects that might have been added to &lt;code&gt;template1&lt;/code&gt; later on.</source>
          <target state="translated">还有一个第二个标准系统数据库，名为 &lt;code&gt;template0&lt;/code&gt; 。该数据库包含与 &lt;code&gt;template1&lt;/code&gt; 的初始内容相同的数据，即仅包含您的PostgreSQL版本预定义的标准对象。初始化数据库集群后，永远不要更改 &lt;code&gt;template0&lt;/code&gt; 。通过指示 &lt;code&gt;CREATE DATABASE&lt;/code&gt; 复制 &lt;code&gt;template0&lt;/code&gt; 而不是 &lt;code&gt;template1&lt;/code&gt; ，可以创建一个&amp;ldquo;原始&amp;rdquo;用户数据库（一个不存在用户定义对象并且系统对象未更改的数据库），该数据库不包含 &lt;code&gt;template1&lt;/code&gt; 中的站点本地添加内容。恢复 &lt;code&gt;pg_dump&lt;/code&gt; 时特别方便转储：转储脚本应在原始数据库中还原，以确保重新创建转储数据库的正确内容，而不会与稍后可能已添加到 &lt;code&gt;template1&lt;/code&gt; 的对象发生冲突。</target>
        </trans-unit>
        <trans-unit id="99e2749bbb2f806b8f89c17d420b1dde22c11b68" translate="yes" xml:space="preserve">
          <source>There is a second standard system database named &lt;code&gt;template0&lt;/code&gt;. This database contains the same data as the initial contents of &lt;code&gt;template1&lt;/code&gt;, that is, only the standard objects predefined by your version of PostgreSQL. &lt;code&gt;template0&lt;/code&gt; should never be changed after the database cluster has been initialized. By instructing &lt;code&gt;CREATE DATABASE&lt;/code&gt; to copy &lt;code&gt;template0&lt;/code&gt; instead of &lt;code&gt;template1&lt;/code&gt;, you can create a &amp;ldquo;virgin&amp;rdquo; user database that contains none of the site-local additions in &lt;code&gt;template1&lt;/code&gt;. This is particularly handy when restoring a &lt;code&gt;pg_dump&lt;/code&gt; dump: the dump script should be restored in a virgin database to ensure that one recreates the correct contents of the dumped database, without conflicting with objects that might have been added to &lt;code&gt;template1&lt;/code&gt; later on.</source>
          <target state="translated">还有一个第二个标准系统数据库，名为 &lt;code&gt;template0&lt;/code&gt; 。该数据库包含与 &lt;code&gt;template1&lt;/code&gt; 的初始内容相同的数据，即仅包含您的PostgreSQL版本预定义的标准对象。初始化数据库集群后，永远不要更改 &lt;code&gt;template0&lt;/code&gt; 。通过指示 &lt;code&gt;CREATE DATABASE&lt;/code&gt; 复制 &lt;code&gt;template0&lt;/code&gt; 而不是 &lt;code&gt;template1&lt;/code&gt; ，可以创建一个&amp;ldquo;原始&amp;rdquo;用户数据库，该数据库在 &lt;code&gt;template1&lt;/code&gt; 中不包含站点本地添加的内容。恢复 &lt;code&gt;pg_dump&lt;/code&gt; 时特别方便转储：转储脚本应在原始数据库中还原，以确保重新创建转储数据库的正确内容，而不会与稍后可能已添加到 &lt;code&gt;template1&lt;/code&gt; 的对象冲突。</target>
        </trans-unit>
        <trans-unit id="c4adb0689e8eca60cac4109882f9fd73f05b7582" translate="yes" xml:space="preserve">
          <source>There is a separate server process called the &lt;em&gt;background writer&lt;/em&gt;, whose function is to issue writes of &amp;ldquo;dirty&amp;rdquo; (new or modified) shared buffers. It writes shared buffers so server processes handling user queries seldom or never need to wait for a write to occur. However, the background writer does cause a net overall increase in I/O load, because while a repeatedly-dirtied page might otherwise be written only once per checkpoint interval, the background writer might write it several times as it is dirtied in the same interval. The parameters discussed in this subsection can be used to tune the behavior for local needs.</source>
          <target state="translated">有一个单独的服务器进程，称为&lt;em&gt;后台写入器&lt;/em&gt;，其功能是发出&amp;ldquo;脏的&amp;rdquo;（新的或修改的）共享缓冲区的写入。它写入共享缓冲区，因此很少或不需要等待写入发生的服务器进程处理用户查询。但是，后台写入程序确实会导致I / O负载的总体净增加，因为虽然重复写入的页面可能每个检查点间隔只能写入一次，但是后台写入器可能会多次写入它，因为在同一间隔中它被弄脏了。本小节中讨论的参数可用于调整本地需求的行为。</target>
        </trans-unit>
        <trans-unit id="90974f119b06bcf646bf0eec46102bc09a0eac90" translate="yes" xml:space="preserve">
          <source>There is a simple variable-substitution facility for script files. Variable names must consist of letters (including non-Latin letters), digits, and underscores. Variables can be set by the command-line &lt;code&gt;-D&lt;/code&gt; option, explained above, or by the meta commands explained below. In addition to any variables preset by &lt;code&gt;-D&lt;/code&gt; command-line options, there are a few variables that are preset automatically, listed in &lt;a href=&quot;pgbench#PGBENCH-AUTOMATIC-VARIABLES&quot;&gt;Table 257&lt;/a&gt;. A value specified for these variables using &lt;code&gt;-D&lt;/code&gt; takes precedence over the automatic presets. Once set, a variable's value can be inserted into a SQL command by writing &lt;code&gt;:&lt;/code&gt;&lt;code&gt;variablename&lt;/code&gt;. When running more than one client session, each session has its own set of variables. pgbench supports up to 255 variable uses in one statement.</source>
          <target state="translated">脚本文件有一个简单的变量替换工具。变量名称必须由字母（包括非拉丁字母），数字和下划线组成。可以通过上面说明的命令行 &lt;code&gt;-D&lt;/code&gt; 选项或下面说明的meta命令来设置变量。除了通过 &lt;code&gt;-D&lt;/code&gt; 命令行选项预设的任何变量外，&lt;a href=&quot;pgbench#PGBENCH-AUTOMATIC-VARIABLES&quot;&gt;表257中还&lt;/a&gt;列出了一些自动预设的变量。使用 &lt;code&gt;-D&lt;/code&gt; 为这些变量指定的值优先于自动预设。设置后，可以通过以下命令将变量的值插入SQL命令中 &lt;code&gt;:&lt;/code&gt; &lt;code&gt;variablename&lt;/code&gt; 。当运行多个客户端会话时，每个会话都有自己的一组变量。pgbench在一条语句中最多支持255个变量使用。</target>
        </trans-unit>
        <trans-unit id="f9e27e33d86d73062aeb666fac5a6e70627179d3" translate="yes" xml:space="preserve">
          <source>There is a simple variable-substitution facility for script files. Variable names must consist of letters (including non-Latin letters), digits, and underscores. Variables can be set by the command-line &lt;code&gt;-D&lt;/code&gt; option, explained above, or by the meta commands explained below. In addition to any variables preset by &lt;code&gt;-D&lt;/code&gt; command-line options, there are a few variables that are preset automatically, listed in &lt;a href=&quot;pgbench#PGBENCH-AUTOMATIC-VARIABLES&quot;&gt;Table 273&lt;/a&gt;. A value specified for these variables using &lt;code&gt;-D&lt;/code&gt; takes precedence over the automatic presets. Once set, a variable's value can be inserted into a SQL command by writing &lt;code&gt;:&lt;/code&gt;&lt;code&gt;variablename&lt;/code&gt;. When running more than one client session, each session has its own set of variables. pgbench supports up to 255 variable uses in one statement.</source>
          <target state="translated">脚本文件有一个简单的变量替换工具。变量名称必须由字母（包括非拉丁字母），数字和下划线组成。可以通过上面说明的命令行 &lt;code&gt;-D&lt;/code&gt; 选项或下面说明的meta命令来设置变量。除了通过 &lt;code&gt;-D&lt;/code&gt; 命令行选项预设的任何变量外，&lt;a href=&quot;pgbench#PGBENCH-AUTOMATIC-VARIABLES&quot;&gt;表273中还&lt;/a&gt;列出了一些自动预设的变量。使用 &lt;code&gt;-D&lt;/code&gt; 为这些变量指定的值优先于自动预设。设置后，可以通过以下命令将变量的值插入到SQL命令中 &lt;code&gt;:&lt;/code&gt; &lt;code&gt;variablename&lt;/code&gt; 。当运行多个客户端会话时，每个会话都有自己的一组变量。pgbench在一条语句中最多支持255个变量使用。</target>
        </trans-unit>
        <trans-unit id="84b40deac5f431c882b47bcec560aceab88cb2ea" translate="yes" xml:space="preserve">
          <source>There is a strong connection between the XQuery language and XPath versions 2.0 and later: any expression that is syntactically valid and executes successfully in both produces the same result (with a minor exception for expressions containing numeric character references or predefined entity references, which XQuery replaces with the corresponding character while XPath leaves them alone). But there is no such connection between these languages and XPath 1.0; it was an earlier language and differs in many respects.</source>
          <target state="translated">XQuery语言和XPath 2.0及以后的版本之间有很强的联系:任何在语法上有效的表达式,并且在两者中成功执行,都会产生相同的结果(对于包含数字字符引用或预定义实体引用的表达式有一个小的例外,XQuery用相应的字符替换了它们,而XPath则不去管它们)。但这些语言和XPath 1.0之间并没有这样的联系,它是一种更早的语言,在很多方面都有不同。</target>
        </trans-unit>
        <trans-unit id="c56c39bf47cf0690546e1095f601459a05ce75db" translate="yes" xml:space="preserve">
          <source>There is also a &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt; parameter, which determines the placement of temporary tables and indexes, as well as temporary files that are used for purposes such as sorting large data sets. This can be a list of tablespace names, rather than only one, so that the load associated with temporary objects can be spread over multiple tablespaces. A random member of the list is picked each time a temporary object is to be created.</source>
          <target state="translated">还有一个&lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt;参数，该参数确定临时表和索引以及用于诸如对大型数据集进行排序之类的目的的临时文件的位置。这可以是表空间名称的列表，而不只是一个，因此与临时对象相关的负载可以分布在多个表空间上。每次要创建临时对象时，都会选择列表的随机成员。</target>
        </trans-unit>
        <trans-unit id="58b9a64bc7c6fc9848f60613899f8c2ff0dc12dc" translate="yes" xml:space="preserve">
          <source>There is also a non-default GIN operator class &lt;code&gt;gin__int_ops&lt;/code&gt; supporting the same operators.</source>
          <target state="translated">还有一个非默认的GIN运算符类 &lt;code&gt;gin__int_ops&lt;/code&gt; 支持相同的运算符。</target>
        </trans-unit>
        <trans-unit id="3d6db9a7a400632bced3a61ed8d0f591628a4c78" translate="yes" xml:space="preserve">
          <source>There is also a single-argument &lt;code&gt;to_timestamp&lt;/code&gt; function; see &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-TABLE&quot;&gt;Table 9.31&lt;/a&gt;.</source>
          <target state="translated">还有一个单参数 &lt;code&gt;to_timestamp&lt;/code&gt; 函数；见&lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-TABLE&quot;&gt;表9.31&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="41669b255a0d94f06b45d60440ba0720ed574d46" translate="yes" xml:space="preserve">
          <source>There is also a two-parameter version of &lt;code&gt;xslt_process&lt;/code&gt; which does not pass any parameters to the transformation.</source>
          <target state="translated">还有 &lt;code&gt;xslt_process&lt;/code&gt; 的两个参数版本，该版本不将任何参数传递给转换。</target>
        </trans-unit>
        <trans-unit id="1ad78e13b5545fbac4993cd2573ccb0145f0260a" translate="yes" xml:space="preserve">
          <source>There is also an &lt;code&gt;include_if_exists&lt;/code&gt; directive, which acts the same as the &lt;code&gt;include&lt;/code&gt; directive, except when the referenced file does not exist or cannot be read. A regular &lt;code&gt;include&lt;/code&gt; will consider this an error condition, but &lt;code&gt;include_if_exists&lt;/code&gt; merely logs a message and continues processing the referencing configuration file.</source>
          <target state="translated">还有一个 &lt;code&gt;include_if_exists&lt;/code&gt; 指令，其作用与 &lt;code&gt;include&lt;/code&gt; 指令相同，但所引用的文件不存在或无法读取时除外。常规 &lt;code&gt;include&lt;/code&gt; 将认为这是错误情况，但是 &lt;code&gt;include_if_exists&lt;/code&gt; 仅记录一条消息并继续处理引用配置文件。</target>
        </trans-unit>
        <trans-unit id="87e6a166488f605dc208dade3f60cf2f1017cef3" translate="yes" xml:space="preserve">
          <source>There is also an exception to the exception: I/O conversion casts from composite types to string types cannot be invoked using functional syntax, but must be written in explicit cast syntax (either &lt;code&gt;CAST&lt;/code&gt; or &lt;code&gt;::&lt;/code&gt; notation). This exception was added because after the introduction of automatically-provided I/O conversion casts, it was found too easy to accidentally invoke such a cast when a function or column reference was intended.</source>
          <target state="translated">例外也有一个例外：不能使用函数语法调用从复合类型到字符串类型的I / O转换，而必须使用显式的转换语法（ &lt;code&gt;CAST&lt;/code&gt; 或 &lt;code&gt;::&lt;/code&gt; 表示法）编写。添加此异常的原因是，在引入自动提供的I / O转换强制转换之后，发现在打算使用函数或列引用时很容易意外调用此类强制转换。</target>
        </trans-unit>
        <trans-unit id="10e49e8f0395261cca6c9bddfde366e5b44bc0fa" translate="yes" xml:space="preserve">
          <source>There is also an option to grant privileges on all objects of the same type within one or more schemas. This functionality is currently supported only for tables, sequences, functions, and procedures. &lt;code&gt;ALL TABLES&lt;/code&gt; also affects views and foreign tables, just like the specific-object &lt;code&gt;GRANT&lt;/code&gt; command. &lt;code&gt;ALL FUNCTIONS&lt;/code&gt; also affects aggregate and window functions, but not procedures, again just like the specific-object &lt;code&gt;GRANT&lt;/code&gt; command. Use &lt;code&gt;ALL ROUTINES&lt;/code&gt; to include procedures.</source>
          <target state="translated">还有一个选项可授予一个或多个模式中所有相同类型对象的特权。当前仅表，序列，函数和过程支持此功能。就像特定对象 &lt;code&gt;GRANT&lt;/code&gt; 命令一样， &lt;code&gt;ALL TABLES&lt;/code&gt; 也影响视图和外部表。 &lt;code&gt;ALL FUNCTIONS&lt;/code&gt; 也会影响聚合函数和窗口函数，但不会影响过程，就像特定对象的 &lt;code&gt;GRANT&lt;/code&gt; 命令一样。使用&amp;ldquo; &lt;code&gt;ALL ROUTINES&lt;/code&gt; 包括过程。</target>
        </trans-unit>
        <trans-unit id="5a702bafff3c7f4c616d64a2b71bb4d856736202" translate="yes" xml:space="preserve">
          <source>There is also the prefix operator &lt;code&gt;^@&lt;/code&gt; and corresponding &lt;code&gt;starts_with&lt;/code&gt; function which covers cases when only searching by beginning of the string is needed.</source>
          <target state="translated">还有前缀运算符 &lt;code&gt;^@&lt;/code&gt; 和相应的 &lt;code&gt;starts_with&lt;/code&gt; 函数，该函数涵盖仅需要按字符串开头进行搜索的情况。</target>
        </trans-unit>
        <trans-unit id="012b88356356711e33f301f2bb1596f7e0f835cc" translate="yes" xml:space="preserve">
          <source>There is an example in &lt;code&gt;autoinc.example&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;autoinc.example&lt;/code&gt; 中有一个示例。</target>
        </trans-unit>
        <trans-unit id="93425455a73285f0e21d7315c96b601935f70ba0" translate="yes" xml:space="preserve">
          <source>There is an example in &lt;code&gt;insert_username.example&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;insert_username.example&lt;/code&gt; 中有一个示例。</target>
        </trans-unit>
        <trans-unit id="16b24fdd30442f553bc5891f105491e9f92bd108" translate="yes" xml:space="preserve">
          <source>There is an example in &lt;code&gt;moddatetime.example&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;moddatetime.example&lt;/code&gt; 中有一个示例。</target>
        </trans-unit>
        <trans-unit id="d2b9c61965fcc66e74624ddfce72996d337e8786" translate="yes" xml:space="preserve">
          <source>There is an inherent ambiguity between octal character-entry escapes and back references, which is resolved by the following heuristics, as hinted at above. A leading zero always indicates an octal escape. A single non-zero digit, not followed by another digit, is always taken as a back reference. A multi-digit sequence not starting with a zero is taken as a back reference if it comes after a suitable subexpression (i.e., the number is in the legal range for a back reference), and otherwise is taken as octal.</source>
          <target state="translated">八进制字符输入转义和回引之间存在固有的模糊性,如上文所提示的,通过以下启发式方法解决。前导零总是表示八进制转义。单个非零的数字,后面没有其他数字,总是作为后参考。一个非零开头的多位数序列,如果它在一个合适的子表达式之后(即数字在合法的回溯范围内),则被当作回溯引用,否则被当作八进制。</target>
        </trans-unit>
        <trans-unit id="2d4f42c096704e40b12586b5cb5d82cbdaf1b311" translate="yes" xml:space="preserve">
          <source>There is an optional second parameter of type &lt;code&gt;boolean&lt;/code&gt;. If &lt;code&gt;true&lt;/code&gt;, it specifies executing &lt;code&gt;pg_start_backup&lt;/code&gt; as quickly as possible. This forces an immediate checkpoint which will cause a spike in I/O operations, slowing any concurrently executing queries.</source>
          <target state="translated">有一个可选的 &lt;code&gt;boolean&lt;/code&gt; 类型的第二个参数。如果为 &lt;code&gt;true&lt;/code&gt; ，它指定尽快执行 &lt;code&gt;pg_start_backup&lt;/code&gt; 。这将强制执行立即检查点，这将导致I / O操作激增，从而减慢任何同时执行的查询。</target>
        </trans-unit>
        <trans-unit id="ea377213a3bab4fda44e6ee45837c28d5e6303c2" translate="yes" xml:space="preserve">
          <source>There is an optional second parameter of type &lt;code&gt;boolean&lt;/code&gt;. If false, the function will return immediately after the backup is completed, without waiting for WAL to be archived. This behavior is only useful with backup software that independently monitors WAL archiving. Otherwise, WAL required to make the backup consistent might be missing and make the backup useless. By default or when this parameter is true, &lt;code&gt;pg_stop_backup&lt;/code&gt; will wait for WAL to be archived when archiving is enabled. (On a standby, this means that it will wait only when &lt;code&gt;archive_mode&lt;/code&gt; = &lt;code&gt;always&lt;/code&gt;. If write activity on the primary is low, it may be useful to run &lt;code&gt;pg_switch_wal&lt;/code&gt; on the primary in order to trigger an immediate segment switch.)</source>
          <target state="translated">有一个可选的 &lt;code&gt;boolean&lt;/code&gt; 类型的第二个参数。如果为false，则该函数将在备份完成后立即返回，而无需等待WAL被存档。此行为仅对独立监视WAL归档的备份软件有用。否则，可能会丢失使备份保持一致所需的WAL，并使备份无用。默认情况下或当此参数为true时，启用归档后 &lt;code&gt;pg_stop_backup&lt;/code&gt; 将等待WAL被归档。（在备用数据库上，这意味着它将仅在 &lt;code&gt;archive_mode&lt;/code&gt; = &lt;code&gt;always&lt;/code&gt; 时等待。如果主数据库上的写入活动较少，则在主 &lt;code&gt;pg_switch_wal&lt;/code&gt; 上运行pg_switch_wal可能会很有用，以触​​发立即的段切换。）</target>
        </trans-unit>
        <trans-unit id="39681348944621b0cbdb87c4dd79d5e8a6ab1c87" translate="yes" xml:space="preserve">
          <source>There is another important concept associated with window functions: for each row, there is a set of rows within its partition called its &lt;em&gt;window frame&lt;/em&gt;. Some window functions act only on the rows of the window frame, rather than of the whole partition. By default, if &lt;code&gt;ORDER BY&lt;/code&gt; is supplied then the frame consists of all rows from the start of the partition up through the current row, plus any following rows that are equal to the current row according to the &lt;code&gt;ORDER BY&lt;/code&gt; clause. When &lt;code&gt;ORDER BY&lt;/code&gt; is omitted the default frame consists of all rows in the partition. &lt;a href=&quot;#ftn.id-1.4.5.6.9.5&quot;&gt;&lt;sup id=&quot;id-1.4.5.6.9.5&quot;&gt;[4]&lt;/sup&gt;&lt;/a&gt; Here is an example using &lt;code&gt;sum&lt;/code&gt;:</source>
          <target state="translated">与窗口函数相关的另一个重要概念是：对于每一行，在其分区中都有一组称为&lt;em&gt;窗口框架的行&lt;/em&gt;。某些窗口函数仅作用于窗口框架的行，而不作用于整个分区的行。默认情况下，如果提供了 &lt;code&gt;ORDER BY&lt;/code&gt; ，则该帧包括从分区开始到当前行的所有行，再加上根据 &lt;code&gt;ORDER BY&lt;/code&gt; 子句等于当前行的所有后续行。当省略 &lt;code&gt;ORDER BY&lt;/code&gt; 时，默认框架由分区中的所有行组成。&lt;a href=&quot;#ftn.id-1.4.5.6.9.5&quot;&gt;&lt;sup id=&quot;id-1.4.5.6.9.5&quot;&gt;[4]&lt;/sup&gt;&lt;/a&gt;以下是使用 &lt;code&gt;sum&lt;/code&gt; 的示例：</target>
        </trans-unit>
        <trans-unit id="64034dc768225bc4dcced9797dcc3830def63396" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER AGGREGATE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;ALTER AGGREGATE&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="f28370d7fe3178c0f150cc0dec3299397ce3c2af" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER COLLATION&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;ALTER COLLATION&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="7babd298f2e4c509f069c94f5602aeb995a6b57c" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER CONVERSION&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;ALTER CONVERSION&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="928fd572e35641041e67b18e6e748efce3723a8c" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="991bfb585377a575377a77fe428cfaf85a73d860" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER EVENT TRIGGER&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;ALTER EVENT TRIGGER&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="9d77ec038759f5fffa10b0b08001ebb09342372d" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER GROUP&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;ALTER GROUP&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="bb57388d9f735799eb7b9b89ff35e3d5ef151e31" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER LANGUAGE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;ALTER LANGUAGE&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="1637168216f474c65041857a21d81b0e4a440e97" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER LARGE OBJECT&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;ALTER LARGE OBJECT&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="345d872d60a75b2e0f9d89245157411db046f3d0" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER OPERATOR CLASS&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;ALTER OPERATOR CLASS&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="8fcc86f4b1945452fb4d2e3306232b8ba831ba49" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="cc28991fbce6444e2838b4c5b330fc7e8b89d499" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER OPERATOR&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;ALTER OPERATOR&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="2506d4e215504a7cdfcb1194c2679242cc54a59e" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER SCHEMA&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;ALTER SCHEMA&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="2964377f745afad2429ec74b207708196b68d312" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER STATISTICS&lt;/code&gt; command in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;ALTER STATISTICS&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="9c3931d89739bf4a90fd967b4f0a43fada449313" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER TABLESPACE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;ALTER TABLESPACE&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="e24f943c01b48797aaba76a9060c58b771452dd4" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER TEXT SEARCH CONFIGURATION&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;ALTER TEXT SEARCH CONFIGURATION&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="eee71505e9ca52479c60dc800cccb5a32c56fe24" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER TEXT SEARCH DICTIONARY&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">在SQL标准中没有 &lt;code&gt;ALTER TEXT SEARCH DICTIONARY&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="d50e75d0db9753a5bb17ed4059457e195c3fbe78" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER TEXT SEARCH PARSER&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">在SQL标准中没有 &lt;code&gt;ALTER TEXT SEARCH PARSER&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="f2e5183222d4bb5c821f92f235643d98359507e9" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER TEXT SEARCH TEMPLATE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">在SQL标准中没有 &lt;code&gt;ALTER TEXT SEARCH TEMPLATE&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="e08ef635bc500a8ffe34e71b4cb60735a3f59c83" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ANALYZE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;ANALYZE&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="2ab267186c8c406bf12491cd64160dcb07b24078" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CLUSTER&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;CLUSTER&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="b29db8edfc564e2f37aa124a9094dedfa5dc75ca" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;COMMENT&lt;/code&gt; command in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;COMMENT&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="51ffc421257a5e488b200464e2482e6c0cb494cc" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;COPY&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;COPY&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="d1ea525f2af46d628097a5d99e04b04f3dea2225" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE DATABASE&lt;/code&gt; statement in the SQL standard. Databases are equivalent to catalogs, whose creation is implementation-defined.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;CREATE DATABASE&lt;/code&gt; 语句。数据库等同于目录，目录的创建是实现定义的。</target>
        </trans-unit>
        <trans-unit id="1892a6f6e1f58d3b4418aa1f7caf04e29a8df179" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE EVENT TRIGGER&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;CREATE EVENT TRIGGER&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="5bd71c5d0a01b45b44b80fcee88ed4660e223ea1" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE GROUP&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;CREATE GROUP&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="e39953cfa3881edf0f677e0b9a6a85f9dce8605d" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE STATISTICS&lt;/code&gt; command in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;CREATE STATISTICS&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="502eb254142165b2715d9eff63db5d89a608e2d7" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE TEXT SEARCH CONFIGURATION&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;CREATE TEXT SEARCH CONFIGURATION&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="609c741f2314d56bf655daef547dcb2a0644be82" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE TEXT SEARCH DICTIONARY&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">在SQL标准中没有 &lt;code&gt;CREATE TEXT SEARCH DICTIONARY&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="41df83262dc2c3b270bf89a5b823f9c05295e631" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE TEXT SEARCH PARSER&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;CREATE TEXT SEARCH PARSER&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="ec4376bb5fb0542843f635e97909a4ca5d798c55" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE TEXT SEARCH TEMPLATE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;CREATE TEXT SEARCH TEMPLATE&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="adb922403a157a64a60a934905fa24aa07814119" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DO&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;DO&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="453ae3f4ad66d52b89a14781b63b1f82ed5a0eba" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP AGGREGATE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;DROP AGGREGATE&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="fec0e29fd940c929987502b958108c6376839288" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP CONVERSION&lt;/code&gt; statement in the SQL standard, but a &lt;code&gt;DROP TRANSLATION&lt;/code&gt; statement that goes along with the &lt;code&gt;CREATE TRANSLATION&lt;/code&gt; statement that is similar to the &lt;code&gt;CREATE CONVERSION&lt;/code&gt; statement in PostgreSQL.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;DROP CONVERSION&lt;/code&gt; 语句，但是 &lt;code&gt;DROP TRANSLATION&lt;/code&gt; 语句与 &lt;code&gt;CREATE TRANSLATION&lt;/code&gt; 语句一起使用，类似于PostgreSQL中的 &lt;code&gt;CREATE CONVERSION&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="fb09b1464adf925f06c0292814700fb9b8091f6c" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP DATABASE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;DROP DATABASE&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="a3c4c010988712d96dd1e79f98080f9432271062" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP EVENT TRIGGER&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;DROP EVENT TRIGGER&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="75623002e2b624abb982d948db215c1dd60a52cc" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP GROUP&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;DROP GROUP&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="27a5387a3bec15b9e950f163994562d5efac89f3" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP LANGUAGE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;DROP LANGUAGE&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="e3d30fcc924219aba17a45fb588c01476a1e9ff6" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP OPERATOR CLASS&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;DROP OPERATOR CLASS&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="4a4d8ad142bdd21f8d4bd8875a49f33849bf5d39" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP OPERATOR FAMILY&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;DROP OPERATOR FAMILY&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="20b4d42336169eb36dbc8e0af63669368391995e" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP OPERATOR&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;DROP OPERATOR&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="22ab45de26ec7860503bcd3c1a242a1a6a072838" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP STATISTICS&lt;/code&gt; command in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;DROP STATISTICS&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="33a3a716e771311567ab1607e35bf61106da647f" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP TEXT SEARCH CONFIGURATION&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">在SQL标准中没有 &lt;code&gt;DROP TEXT SEARCH CONFIGURATION&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="3ff33e4bc1ee2eee7f638d4f9ffce00160a3d8ec" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP TEXT SEARCH DICTIONARY&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;DROP TEXT SEARCH DICTIONARY&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="22f0a322ac87aa6f316366f64468b6a33b449141" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP TEXT SEARCH PARSER&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">在SQL标准中没有 &lt;code&gt;DROP TEXT SEARCH PARSER&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="caba21772330bd3e8d6bc5c0114bed4813577256" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP TEXT SEARCH TEMPLATE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">在SQL标准中没有 &lt;code&gt;DROP TEXT SEARCH TEMPLATE&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="4c6a0d8e969d6d60c24413dee9ec35d4707051d7" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;EXPLAIN&lt;/code&gt; statement defined in the SQL standard.</source>
          <target state="translated">在SQL标准中没有定义 &lt;code&gt;EXPLAIN&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="3188600a38497d7445251ce699c39dbe875e80ee" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;LISTEN&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">在SQL标准中没有 &lt;code&gt;LISTEN&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="89782cda07082f5c8f4d6514f108dab71bcfa4d2" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;LOCK TABLE&lt;/code&gt; in the SQL standard, which instead uses &lt;code&gt;SET TRANSACTION&lt;/code&gt; to specify concurrency levels on transactions. PostgreSQL supports that too; see &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt; for details.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;LOCK TABLE&lt;/code&gt; ，而是使用 &lt;code&gt;SET TRANSACTION&lt;/code&gt; 来指定事务的并发级别。PostgreSQL也支持。有关详细信息，请参见&lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8f784f25d51430ade6f35b2e081075babec2e0fe" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;MOVE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;MOVE&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="4a168bea72d9806503f40f80aa12982ca9fd8601" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;NOTIFY&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;NOTIFY&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="6e1257ab0b3946084dffdd621f7db244f79c25f5" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;REINDEX&lt;/code&gt; command in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;REINDEX&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="e9129bb3a754d8cf06ba21c59dfcd6069ee5971c" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;SECURITY LABEL&lt;/code&gt; command in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;SECURITY LABEL&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="c2c399b535d16a105f07135d4035417088b1dcc4" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;UNLISTEN&lt;/code&gt; command in the SQL standard.</source>
          <target state="translated">在SQL标准中没有 &lt;code&gt;UNLISTEN&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="6a373be7f6f352e566798cf5a1903b201f8406b2" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;VACUUM&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL标准中没有 &lt;code&gt;VACUUM&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="eaadde692acdf895866b856cf669a3d745361c1a" translate="yes" xml:space="preserve">
          <source>There is no alignment padding or any other extra data between fields.</source>
          <target state="translated">字段之间没有对齐填充或任何其他额外数据。</target>
        </trans-unit>
        <trans-unit id="9d9b8c9e107ad42ee0fad08dd8f24c67ee8d865a" translate="yes" xml:space="preserve">
          <source>There is no automatic way to verify that all of the &lt;code&gt;CHECK&lt;/code&gt; constraints are mutually exclusive. It is safer to create code that generates child tables and creates and/or modifies associated objects than to write each by hand.</source>
          <target state="translated">没有自动的方法来验证所有的 &lt;code&gt;CHECK&lt;/code&gt; 约束是互斥的。与手动编写每个对象相比，创建用于生成子表以及创建和/或修改关联对象的代码更安全。</target>
        </trans-unit>
        <trans-unit id="6a9b18acfad0da6c23024f7c2509d5457d17977e" translate="yes" xml:space="preserve">
          <source>There is no comparably easy way to determine a next OID that's beyond the largest one in the database, but fortunately it is not critical to get the next-OID setting right.</source>
          <target state="translated">没有比较简单的方法来确定下一个OID超越数据库中最大的OID,但幸运的是,下一个OID设置正确并不关键。</target>
        </trans-unit>
        <trans-unit id="4db36b67fac0c975746b2d641f8b3943a36d8046" translate="yes" xml:space="preserve">
          <source>There is no cross-checking of indexes against their heap relation during normal operation. Symptoms of heap corruption can be subtle.</source>
          <target state="translated">在正常的操作过程中,不会对索引与其堆关系进行交叉检查。堆损坏的症状可能很微妙。</target>
        </trans-unit>
        <trans-unit id="e96dd49b9a313a343547338d49ed17c06a38c1a6" translate="yes" xml:space="preserve">
          <source>There is no dependent object; this type of entry is a signal that the system itself depends on the referenced object, and so that object must never be deleted. Entries of this type are created only by &lt;code&gt;initdb&lt;/code&gt;. The columns for the dependent object contain zeroes.</source>
          <target state="translated">没有从属对象。这种类型的输入表明系统本身依赖于引用的对象，因此绝不能删除该对象。此类型的条目仅由 &lt;code&gt;initdb&lt;/code&gt; 创建。从属对象的列包含零。</target>
        </trans-unit>
        <trans-unit id="70fc6506fe197311ab91bc28b3e88218eb7eab49" translate="yes" xml:space="preserve">
          <source>There is no general method of repairing problems that &lt;code&gt;amcheck&lt;/code&gt; detects. An explanation for the root cause of an invariant violation should be sought. &lt;a href=&quot;pageinspect&quot;&gt;pageinspect&lt;/a&gt; may play a useful role in diagnosing corruption that &lt;code&gt;amcheck&lt;/code&gt; detects. A &lt;code&gt;REINDEX&lt;/code&gt; may not be effective in repairing corruption.</source>
          <target state="translated">没有通用的方法可以修复 &lt;code&gt;amcheck&lt;/code&gt; 检测到的问题。应寻求对永久违反的根本原因的解释。&lt;a href=&quot;pageinspect&quot;&gt;pageinspect&lt;/a&gt;在诊断 &lt;code&gt;amcheck&lt;/code&gt; 检测到的损坏中可能发挥有用的作用。一个 &lt;code&gt;REINDEX&lt;/code&gt; 可能无法有效地修复损坏。</target>
        </trans-unit>
        <trans-unit id="f84235bff819237a1da91e8e95c005f22d0298e2" translate="yes" xml:space="preserve">
          <source>There is no length limit on the input strings.</source>
          <target state="translated">输入的字符串没有长度限制。</target>
        </trans-unit>
        <trans-unit id="4dbeb068f00ac522f4db315c80e9ac31689bfd87" translate="yes" xml:space="preserve">
          <source>There is no linguistic support, even for English. Regular expressions are not sufficient because they cannot easily handle derived words, e.g., &lt;code&gt;satisfies&lt;/code&gt; and &lt;code&gt;satisfy&lt;/code&gt;. You might miss documents that contain &lt;code&gt;satisfies&lt;/code&gt;, although you probably would like to find them when searching for &lt;code&gt;satisfy&lt;/code&gt;. It is possible to use &lt;code&gt;OR&lt;/code&gt; to search for multiple derived forms, but this is tedious and error-prone (some words can have several thousand derivatives).</source>
          <target state="translated">即使是英语，也没有语言支持。正则表达式是不够的，因为它们不能轻松处理派生词，例如， &lt;code&gt;satisfies&lt;/code&gt; 和 &lt;code&gt;satisfy&lt;/code&gt; 。您可能会错过包含 &lt;code&gt;satisfies&lt;/code&gt; 文档，尽管您可能希望在搜索 &lt;code&gt;satisfy&lt;/code&gt; 时找到它们。可以使用 &lt;code&gt;OR&lt;/code&gt; 搜索多种派生形式，但这很繁琐且容易出错（某些单词可能具有数千个派生词）。</target>
        </trans-unit>
        <trans-unit id="56e118a7d0adfb0e635c9d07f655d84a8ad88c12" translate="yes" xml:space="preserve">
          <source>There is no mechanism to enforce uniqueness of standby names. In case of duplicates one of the matching standbys will be considered as higher priority, though exactly which one is indeterminate.</source>
          <target state="translated">没有强制执行备用名称唯一性的机制。在出现重复的情况下,匹配的备用名称中的一个将被视为较高的优先级,但具体是哪一个是不确定的。</target>
        </trans-unit>
        <trans-unit id="ee6e31417005e5059c60745bca02997125074c26" translate="yes" xml:space="preserve">
          <source>There is no need to grant privileges to the owner of an object (usually the user that created it), as the owner has all privileges by default. (The owner could, however, choose to revoke some of their own privileges for safety.)</source>
          <target state="translated">没有必要向对象的所有者(通常是创建对象的用户)授予权限,因为所有者默认拥有所有权限。然而,所有者可以为了安全起见,选择撤销自己的一些特权)。</target>
        </trans-unit>
        <trans-unit id="30ae1505daac493ace3132ae554c6ea20c2ba190" translate="yes" xml:space="preserve">
          <source>There is no performance difference among these three types, apart from increased storage space when using the blank-padded type, and a few extra CPU cycles to check the length when storing into a length-constrained column. While &lt;code&gt;character(n)&lt;/code&gt; has performance advantages in some other database systems, there is no such advantage in PostgreSQL; in fact &lt;code&gt;character(n)&lt;/code&gt; is usually the slowest of the three because of its additional storage costs. In most situations &lt;code&gt;text&lt;/code&gt; or &lt;code&gt;character varying&lt;/code&gt; should be used instead.</source>
          <target state="translated">这三种类型之间没有性能差异，除了使用空白填充类型时增加的存储空间，以及在存储到受长度限制的列中时需要一些额外的CPU周期来检查长度。尽管 &lt;code&gt;character(n)&lt;/code&gt; 在某些其他数据库系统中具有性能优势，但在PostgreSQL中却没有这种优势。实际上， &lt;code&gt;character(n)&lt;/code&gt; 通常是这三个中最慢的，因为它需要额外的存储成本。在大多数情况下，应改用 &lt;code&gt;text&lt;/code&gt; 或 &lt;code&gt;character varying&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8afc4737cc902a7afc20e4910e033de6ddabdb93" translate="yes" xml:space="preserve">
          <source>There is no restriction regarding how many database users a given operating system user can correspond to, nor vice versa. Thus, entries in a map should be thought of as meaning &amp;ldquo;this operating system user is allowed to connect as this database user&amp;rdquo;, rather than implying that they are equivalent. The connection will be allowed if there is any map entry that pairs the user name obtained from the external authentication system with the database user name that the user has requested to connect as.</source>
          <target state="translated">对于给定的操作系统用户可以对应多少个数据库用户，没有限制，反之亦然。因此，映射中的条目应被认为是&amp;ldquo;允许该操作系统用户以该数据库用户身份连接&amp;rdquo;，而不是暗示它们是等效的。如果有任何映射条目将从外部认证系统获得的用户名与用户请求连接的数据库用户名配对，则将允许连接。</target>
        </trans-unit>
        <trans-unit id="c6d6a72d9fa9097f88cd465d659b996359e6595c" translate="yes" xml:space="preserve">
          <source>There is no result row for the city of Hayward. This is because there is no matching entry in the &lt;code&gt;cities&lt;/code&gt; table for Hayward, so the join ignores the unmatched rows in the &lt;code&gt;weather&lt;/code&gt; table. We will see shortly how this can be fixed.</source>
          <target state="translated">海沃德（Hayward）没有结果行。这是因为在Haywards 的 &lt;code&gt;cities&lt;/code&gt; 表中没有匹配的条目，因此该联接将忽略 &lt;code&gt;weather&lt;/code&gt; 表中不匹配的行。我们很快将看到如何解决此问题。</target>
        </trans-unit>
        <trans-unit id="fb859432422d8124605fd6fa0a5ba7fbb347c338" translate="yes" xml:space="preserve">
          <source>There is no way to create an exclusion constraint spanning all partitions; it is only possible to constrain each leaf partition individually.</source>
          <target state="translated">没有办法创建一个跨越所有分区的排除约束,只能单独约束每个叶子分区。</target>
        </trans-unit>
        <trans-unit id="0394a27a4ae985b5c69a41210e1f40ba8b0d8944" translate="yes" xml:space="preserve">
          <source>There is one further implementation-level restriction that applies regardless of the operator class or collation used:</source>
          <target state="translated">还有一个实现层面的限制,无论使用的是什么运算符类还是整理,都适用。</target>
        </trans-unit>
        <trans-unit id="18b7fd66a2cb5b710dc5cc84ddcb5325f9ab68cf" translate="yes" xml:space="preserve">
          <source>There is one further implementation-level restriction that may be lifted in a future version of PostgreSQL:</source>
          <target state="translated">还有一个实现层面的限制,可能会在PostgreSQL的未来版本中被取消。</target>
        </trans-unit>
        <trans-unit id="1b5bd62ec3737bfec14cadfb61679b8166c57b55" translate="yes" xml:space="preserve">
          <source>There is one row for each buffer in the shared cache. Unused buffers are shown with all fields null except &lt;code&gt;bufferid&lt;/code&gt;. Shared system catalogs are shown as belonging to database zero.</source>
          <target state="translated">共享缓存中的每个缓冲区都有一行。显示未使用的缓冲区，除 &lt;code&gt;bufferid&lt;/code&gt; 之外的所有字段均为null 。共享的系统目录显示为属于数据库零。</target>
        </trans-unit>
        <trans-unit id="f45963e6e5833c88c83b3b4b867ec971de5358c8" translate="yes" xml:space="preserve">
          <source>There is only one &lt;code&gt;round&lt;/code&gt; function that takes two arguments; it takes a first argument of type &lt;code&gt;numeric&lt;/code&gt; and a second argument of type &lt;code&gt;integer&lt;/code&gt;. So the following query automatically converts the first argument of type &lt;code&gt;integer&lt;/code&gt; to &lt;code&gt;numeric&lt;/code&gt;:</source>
          <target state="translated">只有一个取 &lt;code&gt;round&lt;/code&gt; 函数带有两个参数。它采用 &lt;code&gt;numeric&lt;/code&gt; 类型的第一个参数和 &lt;code&gt;integer&lt;/code&gt; 类型的第二个参数。因此，以下查询自动将 &lt;code&gt;integer&lt;/code&gt; 类型的第一个参数转换为 &lt;code&gt;numeric&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b9159e4fda642d08346e94fb2d3ac2dbc99a478a" translate="yes" xml:space="preserve">
          <source>There is only one factorial operator (postfix &lt;code&gt;!&lt;/code&gt;) defined in the standard catalog, and it takes an argument of type &lt;code&gt;bigint&lt;/code&gt;. The scanner assigns an initial type of &lt;code&gt;integer&lt;/code&gt; to the argument in this query expression:</source>
          <target state="translated">在标准目录中仅定义了一个阶乘运算符（postfix &lt;code&gt;!&lt;/code&gt; ），并且它采用了 &lt;code&gt;bigint&lt;/code&gt; 类型的参数。扫描程序为该查询表达式中的参数分配 &lt;code&gt;integer&lt;/code&gt; 的初始类型：</target>
        </trans-unit>
        <trans-unit id="dd1f87be0e4d3b116fb1cbdcb6dc8732c5edc78d" translate="yes" xml:space="preserve">
          <source>There is only one square root operator (prefix &lt;code&gt;|/&lt;/code&gt;) defined in the standard catalog, and it takes an argument of type &lt;code&gt;double precision&lt;/code&gt;. The scanner assigns an initial type of &lt;code&gt;integer&lt;/code&gt; to the argument in this query expression:</source>
          <target state="translated">在标准目录中仅定义了一个平方根运算符（前缀 &lt;code&gt;|/&lt;/code&gt; ），并且它采用 &lt;code&gt;double precision&lt;/code&gt; 类型的参数。扫描程序将 &lt;code&gt;integer&lt;/code&gt; 的初始类型分配给此查询表达式中的参数：</target>
        </trans-unit>
        <trans-unit id="ca0c7153374d6f701aba32a67304ea000734d416" translate="yes" xml:space="preserve">
          <source>There is presently no security mechanism for viewing comments: any user connected to a database can see all the comments for objects in that database. For shared objects such as databases, roles, and tablespaces, comments are stored globally so any user connected to any database in the cluster can see all the comments for shared objects. Therefore, don't put security-critical information in comments.</source>
          <target state="translated">目前没有查看注释的安全机制:连接到数据库的任何用户都可以看到该数据库中对象的所有注释。对于数据库、角色和表空间等共享对象,注释是全局存储的,因此连接到集群中任何数据库的任何用户都可以看到共享对象的所有注释。因此,不要把安全关键信息放在注释中。</target>
        </trans-unit>
        <trans-unit id="e848fe2ab9f9a42478fab56269c47dd1ce42078d" translate="yes" xml:space="preserve">
          <source>There is usually not much point in making more than one tablespace per logical file system, since you cannot control the location of individual files within a logical file system. However, PostgreSQL does not enforce any such limitation, and indeed it is not directly aware of the file system boundaries on your system. It just stores files in the directories you tell it to use.</source>
          <target state="translated">通常情况下,每个逻辑文件系统制作一个以上的表空间是没有什么意义的,因为你无法控制逻辑文件系统中各个文件的位置。然而,PostgreSQL并没有强制执行任何这样的限制,事实上,它并不直接意识到你系统中的文件系统边界。它只是将文件存储在你告诉它使用的目录中。</target>
        </trans-unit>
        <trans-unit id="d953cfaaf0252b15b02b8c9a112ebe99c8fa7d20" translate="yes" xml:space="preserve">
          <source>There must also be matching child-table constraints for all &lt;code&gt;CHECK&lt;/code&gt; constraints of the parent, except those marked non-inheritable (that is, created with &lt;code&gt;ALTER TABLE ... ADD CONSTRAINT ... NO INHERIT&lt;/code&gt;) in the parent, which are ignored; all child-table constraints matched must not be marked non-inheritable. Currently &lt;code&gt;UNIQUE&lt;/code&gt;, &lt;code&gt;PRIMARY KEY&lt;/code&gt;, and &lt;code&gt;FOREIGN KEY&lt;/code&gt; constraints are not considered, but this might change in the future.</source>
          <target state="translated">对于父级的所有 &lt;code&gt;CHECK&lt;/code&gt; 约束，还必须有匹配的子表约束，但在父级中标记为不可继承（即使用 &lt;code&gt;ALTER TABLE ... ADD CONSTRAINT ... NO INHERIT&lt;/code&gt; ）的约束除外。匹配的所有子表约束均不得标记为不可继承。目前不考虑 &lt;code&gt;UNIQUE&lt;/code&gt; ， &lt;code&gt;PRIMARY KEY&lt;/code&gt; 和 &lt;code&gt;FOREIGN KEY&lt;/code&gt; 约束，但是将来可能会改变。</target>
        </trans-unit>
        <trans-unit id="9d0ef1c54ee5da6f3a9bc0faf2941d2e26078541" translate="yes" xml:space="preserve">
          <source>There should be no extra overhead in the parser or executor if a query does not need implicit type conversion. That is, if a query is well-formed and the types already match, then the query should execute without spending extra time in the parser and without introducing unnecessary implicit conversion calls in the query.</source>
          <target state="translated">如果一个查询不需要隐式类型转换,那么在解析器或执行器中不应该有额外的开销。也就是说,如果一个查询的格式很好,类型已经匹配,那么查询的执行就不应该在解析器中花费额外的时间,也不应该在查询中引入不必要的隐式转换调用。</target>
        </trans-unit>
        <trans-unit id="934618c1781f2f0a9f6bb79bbcc267c826504412" translate="yes" xml:space="preserve">
          <source>There was formerly an &lt;code&gt;ALTER INDEX OWNER&lt;/code&gt; variant, but this is now ignored (with a warning). An index cannot have an owner different from its table's owner. Changing the table's owner automatically changes the index as well.</source>
          <target state="translated">以前有 &lt;code&gt;ALTER INDEX OWNER&lt;/code&gt; 变体，但现在被忽略（带有警告）。索引的所有者不能与表的所有者不同。更改表的所有者也会自动更改索引。</target>
        </trans-unit>
        <trans-unit id="eb82410dec70b2b3321bff0d1e9388c3bd8dfd33" translate="yes" xml:space="preserve">
          <source>There's no need to manually create indexes on unique columns; doing so would just duplicate the automatically-created index.</source>
          <target state="translated">没有必要在唯一的列上手动创建索引,这样做只会重复自动创建的索引。</target>
        </trans-unit>
        <trans-unit id="dd1c3102c4930b5f2a44ebfcda5a098872c67837" translate="yes" xml:space="preserve">
          <source>Thesauruses are used during indexing so any change in the thesaurus dictionary's parameters &lt;em&gt;requires&lt;/em&gt; reindexing. For most other dictionary types, small changes such as adding or removing stopwords does not force reindexing.</source>
          <target state="translated">同义词库在索引编制过程中使用，因此同义词库字典参数的任何更改都&lt;em&gt;需要&lt;/em&gt;重新索引。对于大多数其他字典类型，小的更改（例如添加或删除停用词）不会强制重新索引。</target>
        </trans-unit>
        <trans-unit id="5f1ad8c9ce64bcda09c594082de2a500ef5cce09" translate="yes" xml:space="preserve">
          <source>These are actually just special cases of the general casting notations discussed next.</source>
          <target state="translated">这些其实只是接下来讨论的一般铸造记号的特殊情况。</target>
        </trans-unit>
        <trans-unit id="1ede3bb37d9693ab9536c9fcd48ebe3c46555fd8" translate="yes" xml:space="preserve">
          <source>These are good sources to start learning about various kinds of encoding systems.</source>
          <target state="translated">这些都是开始学习各种编码系统的良好来源。</target>
        </trans-unit>
        <trans-unit id="8a4a0666760118b211b5b7d0b41910720c832114" translate="yes" xml:space="preserve">
          <source>These are less likely to be problematic than &lt;code&gt;search_path&lt;/code&gt;, but can be handled with function &lt;code&gt;SET&lt;/code&gt; options if the need arises.</source>
          <target state="translated">与 &lt;code&gt;search_path&lt;/code&gt; 相比，它们不太可能出现问题，但是如果需要，可以使用功能 &lt;code&gt;SET&lt;/code&gt; 选项进行处理。</target>
        </trans-unit>
        <trans-unit id="e09b98f630a14c95107bbc1d571768385072e6a7" translate="yes" xml:space="preserve">
          <source>These are some examples of valid numeric constants:</source>
          <target state="translated">这些是一些有效的数字常数的例子。</target>
        </trans-unit>
        <trans-unit id="2d394fc649569a5eeeb4c5600c0f12014850ba1f" translate="yes" xml:space="preserve">
          <source>These are the steps to perform an upgrade with pg_upgrade:</source>
          <target state="translated">以下是使用pg_upgrade进行升级的步骤。</target>
        </trans-unit>
        <trans-unit id="f72a6870691351c5c2b87041a8d81f8e78b27456" translate="yes" xml:space="preserve">
          <source>These attributes inform the query optimizer about the behavior of the function. At most one choice can be specified. If none of these appear, &lt;code&gt;VOLATILE&lt;/code&gt; is the default assumption.</source>
          <target state="translated">这些属性将有关功能的行为通知查询优化器。最多可以指定一种选择。如果这些都不出现，则默认为 &lt;code&gt;VOLATILE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f85846f94f84f78007c888a90fb32598de3ea04f" translate="yes" xml:space="preserve">
          <source>These caches can typically be disabled; however, the method for doing this varies by operating system and drive type:</source>
          <target state="translated">这些缓存通常可以被禁用;然而,禁用的方法因操作系统和驱动器类型而异。</target>
        </trans-unit>
        <trans-unit id="484e4f03dd4a3ca589988330c2b61dd6c51084dd" translate="yes" xml:space="preserve">
          <source>These clauses alter attributes originally set by &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;. For more information, see the &lt;code&gt;CREATE ROLE&lt;/code&gt; reference page.</source>
          <target state="translated">这些子句更改最初由&lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;设置的属性。有关更多信息，请参见 &lt;code&gt;CREATE ROLE&lt;/code&gt; 参考页面。</target>
        </trans-unit>
        <trans-unit id="ae13d4d630a34fa139e9046de2cb8f6bc13b3a42" translate="yes" xml:space="preserve">
          <source>These clauses define a role's ability to create databases. If &lt;code&gt;CREATEDB&lt;/code&gt; is specified, the role being defined will be allowed to create new databases. Specifying &lt;code&gt;NOCREATEDB&lt;/code&gt; will deny a role the ability to create databases. If not specified, &lt;code&gt;NOCREATEDB&lt;/code&gt; is the default.</source>
          <target state="translated">这些子句定义角色创建数据库的能力。如果指定了 &lt;code&gt;CREATEDB&lt;/code&gt; ，则允许定义的角色创建新数据库。指定 &lt;code&gt;NOCREATEDB&lt;/code&gt; 将使角色无法创建数据库。如果未指定，则默认为 &lt;code&gt;NOCREATEDB&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="236a4db02b1fa5b8bc065150c9e1f92cd0c2db65" translate="yes" xml:space="preserve">
          <source>These clauses determine whether a role &amp;ldquo;inherits&amp;rdquo; the privileges of roles it is a member of. A role with the &lt;code&gt;INHERIT&lt;/code&gt; attribute can automatically use whatever database privileges have been granted to all roles it is directly or indirectly a member of. Without &lt;code&gt;INHERIT&lt;/code&gt;, membership in another role only grants the ability to &lt;code&gt;SET ROLE&lt;/code&gt; to that other role; the privileges of the other role are only available after having done so. If not specified, &lt;code&gt;INHERIT&lt;/code&gt; is the default.</source>
          <target state="translated">这些条款确定了角色是否&amp;ldquo;继承&amp;rdquo;了其成员角色的特权。具有 &lt;code&gt;INHERIT&lt;/code&gt; 属性的角色可以自动使用已授予其直接或间接成员的所有角色的任何数据库特权。如果没有 &lt;code&gt;INHERIT&lt;/code&gt; ，则另一个角色的成员资格仅授予 &lt;code&gt;SET ROLE&lt;/code&gt; 权限给该另一个角色。其他角色的特权只有在这样做之后才可用。如果未指定，则默认为 &lt;code&gt;INHERIT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a8f7e3712b4368e28fc6b45f7eab106b1e33840d" translate="yes" xml:space="preserve">
          <source>These clauses determine whether a role bypasses every row-level security (RLS) policy. &lt;code&gt;NOBYPASSRLS&lt;/code&gt; is the default. Note that pg_dump will set &lt;code&gt;row_security&lt;/code&gt; to &lt;code&gt;OFF&lt;/code&gt; by default, to ensure all contents of a table are dumped out. If the user running pg_dump does not have appropriate permissions, an error will be returned. The superuser and owner of the table being dumped always bypass RLS.</source>
          <target state="translated">这些子句确定角色是否绕过每个行级安全（RLS）策略。 &lt;code&gt;NOBYPASSRLS&lt;/code&gt; 为NOBYPASSRLS。注意，pg_dump 默认将 &lt;code&gt;row_security&lt;/code&gt; 设置为 &lt;code&gt;OFF&lt;/code&gt; ，以确保表的所有内容都被转储出去。如果运行pg_dump的用户没有适当的权限，将返回错误。转储表的超级用户和所有者始终绕过RLS。</target>
        </trans-unit>
        <trans-unit id="1c4c9abff0ed7aed3c18b9b9a05141b1d9e0e976" translate="yes" xml:space="preserve">
          <source>These clauses determine whether a role bypasses every row-level security (RLS) policy. &lt;code&gt;NOBYPASSRLS&lt;/code&gt; is the default. You must be a superuser to create a new role having the &lt;code&gt;BYPASSRLS&lt;/code&gt; attribute.</source>
          <target state="translated">这些子句确定角色是否绕过每个行级安全（RLS）策略。 &lt;code&gt;NOBYPASSRLS&lt;/code&gt; 为NOBYPASSRLS。您必须是超级用户才能创建具有 &lt;code&gt;BYPASSRLS&lt;/code&gt; 属性的新角色。</target>
        </trans-unit>
        <trans-unit id="cdfb1f660e91b5c6f6fdf7bb5b01ee2031a6647b" translate="yes" xml:space="preserve">
          <source>These clauses determine whether a role is a replication role. A role must have this attribute (or be a superuser) in order to be able to connect to the server in replication mode (physical or logical replication) and in order to be able to create or drop replication slots. A role having the &lt;code&gt;REPLICATION&lt;/code&gt; attribute is a very highly privileged role, and should only be used on roles actually used for replication. If not specified, &lt;code&gt;NOREPLICATION&lt;/code&gt; is the default.</source>
          <target state="translated">这些子句确定角色是否为复制角色。角色必须具有此属性（或成为超级用户），以便能够以复制模式（物理或逻辑复制）连接到服务器，并能够创建或删除复制插槽。具有 &lt;code&gt;REPLICATION&lt;/code&gt; 属性的角色是具有很高特权的角色，并且仅应在实际用于复制的角色上使用。如果未指定，则默认为 &lt;code&gt;NOREPLICATION&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f08ec67a75e039b1e1d579f9d114eb5649ed79b" translate="yes" xml:space="preserve">
          <source>These clauses determine whether a role is a replication role. A role must have this attribute (or be a superuser) in order to be able to connect to the server in replication mode (physical or logical replication) and in order to be able to create or drop replication slots. A role having the &lt;code&gt;REPLICATION&lt;/code&gt; attribute is a very highly privileged role, and should only be used on roles actually used for replication. If not specified, &lt;code&gt;NOREPLICATION&lt;/code&gt; is the default. You must be a superuser to create a new role having the &lt;code&gt;REPLICATION&lt;/code&gt; attribute.</source>
          <target state="translated">这些子句确定角色是否为复制角色。角色必须具有此属性（或成为超级用户），以便能够以复制模式（物理或逻辑复制）连接到服务器，并能够创建或删除复制插槽。具有 &lt;code&gt;REPLICATION&lt;/code&gt; 属性的角色是特权很高的角色，并且仅应在实际用于复制的角色上使用。如果未指定，则 &lt;code&gt;NOREPLICATION&lt;/code&gt; 是默认值。您必须是超级用户才能创建具有 &lt;code&gt;REPLICATION&lt;/code&gt; 属性的新角色。</target>
        </trans-unit>
        <trans-unit id="93cac2364d542f963f918606f10bb473c25cf54c" translate="yes" xml:space="preserve">
          <source>These clauses determine whether a role is allowed to log in; that is, whether the role can be given as the initial session authorization name during client connection. A role having the &lt;code&gt;LOGIN&lt;/code&gt; attribute can be thought of as a user. Roles without this attribute are useful for managing database privileges, but are not users in the usual sense of the word. If not specified, &lt;code&gt;NOLOGIN&lt;/code&gt; is the default, except when &lt;code&gt;CREATE ROLE&lt;/code&gt; is invoked through its alternative spelling &lt;a href=&quot;sql-createuser&quot;&gt;CREATE USER&lt;/a&gt;.</source>
          <target state="translated">这些子句确定是否允许角色登录。也就是说，是否可以在客户端连接期间将角色指定为初始会话授权名称。可以将具有 &lt;code&gt;LOGIN&lt;/code&gt; 属性的角色视为用户。没有此属性的角色对于管理数据库特权很有用，但不是通常意义上的用户。如果未指定，则默认为 &lt;code&gt;NOLOGIN&lt;/code&gt; ，除非通过其替代拼写&lt;a href=&quot;sql-createuser&quot;&gt;CREATE USER&lt;/a&gt;调用 &lt;code&gt;CREATE ROLE&lt;/code&gt; 时。</target>
        </trans-unit>
        <trans-unit id="181b83412fd4eddb3ac3029828e16b7a9b6b98ef" translate="yes" xml:space="preserve">
          <source>These clauses determine whether a role will be permitted to create new roles (that is, execute &lt;code&gt;CREATE ROLE&lt;/code&gt;). A role with &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can also alter and drop other roles. If not specified, &lt;code&gt;NOCREATEROLE&lt;/code&gt; is the default.</source>
          <target state="translated">这些子句确定是否允许一个角色创建新角色（即执行 &lt;code&gt;CREATE ROLE&lt;/code&gt; ）。具有 &lt;code&gt;CREATEROLE&lt;/code&gt; 特权的角色还可以更改和删除其他角色。如果未指定，则默认为 &lt;code&gt;NOCREATEROLE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2e0e211b5e3eb630f6887dce4107cdd808855949" translate="yes" xml:space="preserve">
          <source>These clauses determine whether the new role is a &amp;ldquo;superuser&amp;rdquo;, who can override all access restrictions within the database. Superuser status is dangerous and should be used only when really needed. You must yourself be a superuser to create a new superuser. If not specified, &lt;code&gt;NOSUPERUSER&lt;/code&gt; is the default.</source>
          <target state="translated">这些子句确定新角色是否是&amp;ldquo;超级用户&amp;rdquo;，谁可以覆盖数据库中的所有访问限制。超级用户状态很危险，应仅在真正需要时使用。您必须自己是超级用户才能创建新的超级用户。如果未指定，则默认为 &lt;code&gt;NOSUPERUSER&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b6a59cdbb5e799d0fed1a4aa2596214d1849fd5f" translate="yes" xml:space="preserve">
          <source>These clauses specify a foreign key constraint, which requires that a group of one or more columns of the new table must only contain values that match values in the referenced column(s) of some row of the referenced table. If the &lt;code&gt;refcolumn&lt;/code&gt; list is omitted, the primary key of the &lt;code&gt;reftable&lt;/code&gt; is used. The referenced columns must be the columns of a non-deferrable unique or primary key constraint in the referenced table. The user must have &lt;code&gt;REFERENCES&lt;/code&gt; permission on the referenced table (either the whole table, or the specific referenced columns). The addition of a foreign key constraint requires a &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; lock on the referenced table. Note that foreign key constraints cannot be defined between temporary tables and permanent tables.</source>
          <target state="translated">这些子句指定外键约束，这要求新表的一组一个或多个列必须仅包含与被引用表的某行的被引用列中的值匹配的值。如果省略了 &lt;code&gt;refcolumn&lt;/code&gt; 列表，则使用 &lt;code&gt;reftable&lt;/code&gt; 的主键。引用的列必须是引用表中不可延迟的唯一或主键约束的列。用户必须对被引用的表（整个表或特定的被引用的列）具有 &lt;code&gt;REFERENCES&lt;/code&gt; 权限。添加外键约束需要 &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; 锁定引用的表。注意，不能在临时表和永久表之间定义外键约束。</target>
        </trans-unit>
        <trans-unit id="857c0ae8d220b45b3955f09362ef789a9a3402e5" translate="yes" xml:space="preserve">
          <source>These commands are defined in the SQL standard, except for the &lt;code&gt;DEFERRABLE&lt;/code&gt; transaction mode and the &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; form, which are PostgreSQL extensions.</source>
          <target state="translated">这些命令是在SQL标准中定义的，除了 &lt;code&gt;DEFERRABLE&lt;/code&gt; 事务模式和 &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; 形式是PostgreSQL扩展。</target>
        </trans-unit>
        <trans-unit id="7ad3dc4d8a64e61d33f79320b9d9d378ce755f14" translate="yes" xml:space="preserve">
          <source>These commands may be used to end SQL queries, taking the place of the terminating semicolon (&lt;code&gt;;&lt;/code&gt;).</source>
          <target state="translated">这些命令可用于结束SQL查询，以代替终止分号（ &lt;code&gt;;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f08278f74b1bbe88f6fdde4ee30a3df428b62a8f" translate="yes" xml:space="preserve">
          <source>These comparison operators are available for all built-in data types that have a natural ordering, including numeric, string, and date/time types. In addition, arrays, composite types, and ranges can be compared if their component data types are comparable.</source>
          <target state="translated">这些比较运算符可用于所有具有自然排序的内置数据类型,包括数字、字符串和日期/时间类型。此外,如果数组、复合类型和范围的组成数据类型是可比较的,则可以对它们进行比较。</target>
        </trans-unit>
        <trans-unit id="c9a3af7e0da0acbd34de05752f110be6e0e62942" translate="yes" xml:space="preserve">
          <source>These configuration parameters provide a crude method of influencing the query plans chosen by the query optimizer. If the default plan chosen by the optimizer for a particular query is not optimal, a &lt;em&gt;temporary&lt;/em&gt; solution is to use one of these configuration parameters to force the optimizer to choose a different plan. Better ways to improve the quality of the plans chosen by the optimizer include adjusting the planner cost constants (see &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-CONSTANTS&quot;&gt;Section 19.7.2&lt;/a&gt;), running &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; manually, increasing the value of the &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; configuration parameter, and increasing the amount of statistics collected for specific columns using &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt;.</source>
          <target state="translated">这些配置参数提供了一种影响查询优化器选择的查询计划的粗略方法。如果优化器为特定查询选择的默认计划不是最佳选择，则&lt;em&gt;临时&lt;/em&gt;解决方案是使用这些配置参数之一来强制优化器选择其他计划。改善优化程序选择的计划质量的更好方法包括调整计划程序成本常量（请参见&lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-CONSTANTS&quot;&gt;第19.7.2节&lt;/a&gt;），手动运行&lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt;，增加&lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt;配置参数的值以及增加为特定列收集的统计信息的数量。使用 &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="97b05ff9bc8f45601af490580b1cf57f630e4008" translate="yes" xml:space="preserve">
          <source>These cost-based decisions will be made at plan time, not execution time. This means that when prepared statements are in use, and a generic plan is used (see &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt;), the values of the configuration parameters in effect at prepare time control the decisions, not the settings at execution time.</source>
          <target state="translated">这些基于成本的决策将在计划时间而不是执行时间做出。这意味着在使用准备好的语句并使用通用计划时（请参阅&lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt;），在准备时有效的配置参数的值控制决策，而不是执行时的设置。</target>
        </trans-unit>
        <trans-unit id="bd102e49cf8b96793cacdde24d32614ffb078540" translate="yes" xml:space="preserve">
          <source>These counts can be particularly valuable for filter conditions applied at join nodes. The &amp;ldquo;Rows Removed&amp;rdquo; line only appears when at least one scanned row, or potential join pair in the case of a join node, is rejected by the filter condition.</source>
          <target state="translated">这些计数对于连接节点上应用的过滤条件特别有价值。仅当过滤条件拒绝了至少一个扫描行或连接节点的情况下可能的连接对时，&amp;ldquo;已删除行&amp;rdquo;行才出现。</target>
        </trans-unit>
        <trans-unit id="9525af1114ee853e1be2e829b6746f11684a7213" translate="yes" xml:space="preserve">
          <source>These examples all specify the same address. Upper and lower case is accepted for the digits &lt;code&gt;a&lt;/code&gt; through &lt;code&gt;f&lt;/code&gt;. Output is always in the first of the forms shown.</source>
          <target state="translated">这些示例均指定相同的地址。数字 &lt;code&gt;a&lt;/code&gt; 到 &lt;code&gt;f&lt;/code&gt; 接受大小写。输出始终以所示表格的第一个形式出现。</target>
        </trans-unit>
        <trans-unit id="d2ee06a454af3afd2603bd1ff07db9463f13f34e" translate="yes" xml:space="preserve">
          <source>These examples show use of &lt;code&gt;position&lt;/code&gt; fields:</source>
          <target state="translated">这些示例说明了 &lt;code&gt;position&lt;/code&gt; 字段的用法：</target>
        </trans-unit>
        <trans-unit id="f944ac8005ce9ea42b0263baeef3f32035cd55b8" translate="yes" xml:space="preserve">
          <source>These examples show use of &lt;em&gt;&lt;code&gt;position&lt;/code&gt;&lt;/em&gt; fields:</source>
          <target state="translated">这些示例说明了&lt;em&gt; &lt;code&gt;position&lt;/code&gt; &lt;/em&gt;字段的用法：</target>
        </trans-unit>
        <trans-unit id="e22989ebfc8062e1b7b80c3eb7a3f32777c7de5c" translate="yes" xml:space="preserve">
          <source>These examples would all specify the same address. Upper and lower case is accepted for the digits &lt;code&gt;a&lt;/code&gt; through &lt;code&gt;f&lt;/code&gt;. Output is always in the first of the forms shown.</source>
          <target state="translated">这些示例都将指定相同的地址。数字 &lt;code&gt;a&lt;/code&gt; 到 &lt;code&gt;f&lt;/code&gt; 接受大小写。输出始终以所示表格的第一个形式出现。</target>
        </trans-unit>
        <trans-unit id="ef90197c0c87bcadf3fd64cda40bcfb6928639b3" translate="yes" xml:space="preserve">
          <source>These examples would all specify the same address. Upper and lower case is accepted for the digits &lt;code&gt;a&lt;/code&gt; through &lt;code&gt;f&lt;/code&gt;. Output is always in the first of the forms shown. The last six input formats that are mentioned above are not part of any standard. To convert a traditional 48 bit MAC address in EUI-48 format to modified EUI-64 format to be included as the host portion of an IPv6 address, use &lt;code&gt;macaddr8_set7bit&lt;/code&gt; as shown:</source>
          <target state="translated">这些示例都将指定相同的地址。数字 &lt;code&gt;a&lt;/code&gt; 到 &lt;code&gt;f&lt;/code&gt; 接受大小写。输出始终以所示表格的第一个形式出现。上面提到的最后六种输入格式不是任何标准的一部分。要将EUI-48格式的传统48位MAC地址转换为修改后的EUI-64格式以包含为IPv6地址的主机部分，请使用 &lt;code&gt;macaddr8_set7bit&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="31279325b3351a8e4e53dffc8199d39f6d4f7fef" translate="yes" xml:space="preserve">
          <source>These fields do not apply to &lt;code&gt;local&lt;/code&gt; records.</source>
          <target state="translated">这些字段不适用于 &lt;code&gt;local&lt;/code&gt; 记录。</target>
        </trans-unit>
        <trans-unit id="754aea8d14b67db99a02b25bbf6a65624166cf06" translate="yes" xml:space="preserve">
          <source>These fields only apply to &lt;code&gt;host&lt;/code&gt;, &lt;code&gt;hostssl&lt;/code&gt;, and &lt;code&gt;hostnossl&lt;/code&gt; records.</source>
          <target state="translated">这些字段仅适用于 &lt;code&gt;host&lt;/code&gt; ， &lt;code&gt;hostssl&lt;/code&gt; 和 &lt;code&gt;hostnossl&lt;/code&gt; 记录。</target>
        </trans-unit>
        <trans-unit id="72eddf11f12dc6025be9e6bc42deb5078bd81869" translate="yes" xml:space="preserve">
          <source>These forms alter the sequence that underlies an existing identity column. &lt;code&gt;sequence_option&lt;/code&gt; is an option supported by &lt;a href=&quot;sql-altersequence&quot;&gt;ALTER SEQUENCE&lt;/a&gt; such as &lt;code&gt;INCREMENT BY&lt;/code&gt;.</source>
          <target state="translated">这些形式更改了现有身份列基础的顺序。 &lt;code&gt;sequence_option&lt;/code&gt; 是&lt;a href=&quot;sql-altersequence&quot;&gt;ALTER SEQUENCE&lt;/a&gt;支持的选项，例如 &lt;code&gt;INCREMENT BY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="94eb82c63d8a50cb48f48fc67bdfcbfef03ff87e" translate="yes" xml:space="preserve">
          <source>These forms change whether a column is an identity column or change the generation attribute of an existing identity column. See &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for details.</source>
          <target state="translated">这些形式更改列是身份列还是更改现有身份列的生成属性。有关详细信息，请参见&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1bc8e996c262c353a8a23c5058e8d5716c2b27c6" translate="yes" xml:space="preserve">
          <source>These forms change whether a column is an identity column or change the generation attribute of an existing identity column. See &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for details. Like &lt;code&gt;SET DEFAULT&lt;/code&gt;, these forms only affect the behavior of subsequent &lt;code&gt;INSERT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; commands; they do not cause rows already in the table to change.</source>
          <target state="translated">这些形式更改列是身份列还是更改现有身份列的生成属性。有关详细信息，请参见&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;。像 &lt;code&gt;SET DEFAULT&lt;/code&gt; 一样，这些形式仅影响后续 &lt;code&gt;INSERT&lt;/code&gt; 和 &lt;code&gt;UPDATE&lt;/code&gt; 命令的行为。它们不会导致表中已有的行发生更改。</target>
        </trans-unit>
        <trans-unit id="e41d9a5a685b55548689fcb598e8403262b9b305" translate="yes" xml:space="preserve">
          <source>These forms change whether a column is marked to allow null values or to reject null values.</source>
          <target state="translated">这些表格改变了一列是否被标记为允许空值或拒绝空值。</target>
        </trans-unit>
        <trans-unit id="93ec998a277e66396552c3ff5dd5565fd0687627" translate="yes" xml:space="preserve">
          <source>These forms change whether a domain is marked to allow NULL values or to reject NULL values. You can only &lt;code&gt;SET NOT NULL&lt;/code&gt; when the columns using the domain contain no null values.</source>
          <target state="translated">这些形式会更改是将域标记为允许NULL值还是拒绝NULL值。仅当使用域的列不包含空值时，才可以将 &lt;code&gt;SET NOT NULL&lt;/code&gt; 设置为空。</target>
        </trans-unit>
        <trans-unit id="e6fb1f760d0b7848e70cd0fa414aa5c5a55c2d88" translate="yes" xml:space="preserve">
          <source>These forms configure the firing of event triggers. A disabled trigger is still known to the system, but is not executed when its triggering event occurs. See also &lt;a href=&quot;runtime-config-client#GUC-SESSION-REPLICATION-ROLE&quot;&gt;session_replication_role&lt;/a&gt;.</source>
          <target state="translated">这些表格配置事件触发器的触发。禁用的触发器仍然是系统已知的，但是在发生触发事件时不会执行。另请参见&lt;a href=&quot;runtime-config-client#GUC-SESSION-REPLICATION-ROLE&quot;&gt;session_replication_role&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ed16a2682c252a84ef2e6b9d1135068b069708b2" translate="yes" xml:space="preserve">
          <source>These forms configure the firing of rewrite rules belonging to the table. A disabled rule is still known to the system, but is not applied during query rewriting. The semantics are as for disabled/enabled triggers. This configuration is ignored for &lt;code&gt;ON SELECT&lt;/code&gt; rules, which are always applied in order to keep views working even if the current session is in a non-default replication role.</source>
          <target state="translated">这些表格配置了属于该表的重写规则的触发。禁用的规则对于系统仍然是已知的，但在查询重写期间不会应用。语义与禁用/启用触发器相同。对于 &lt;code&gt;ON SELECT&lt;/code&gt; 规则，此配置将被忽略，即使当前会话处于非默认复制角色，也将始终应用这些规则以保持视图正常工作。</target>
        </trans-unit>
        <trans-unit id="78d1881ed192b61ccc8ca5381f7ecf2d5ccbebb4" translate="yes" xml:space="preserve">
          <source>These forms configure the firing of trigger(s) belonging to the foreign table. See the similar form of &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; for more details.</source>
          <target state="translated">这些表格配置了属于外部表的触发器的触发。有关更多详细信息，请参见类似形式的&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="537c2d5f6bf4afe4d0ece015a719f2c170c94088" translate="yes" xml:space="preserve">
          <source>These forms configure the firing of trigger(s) belonging to the table. A disabled trigger is still known to the system, but is not executed when its triggering event occurs. For a deferred trigger, the enable status is checked when the event occurs, not when the trigger function is actually executed. One can disable or enable a single trigger specified by name, or all triggers on the table, or only user triggers (this option excludes internally generated constraint triggers such as those that are used to implement foreign key constraints or deferrable uniqueness and exclusion constraints). Disabling or enabling internally generated constraint triggers requires superuser privileges; it should be done with caution since of course the integrity of the constraint cannot be guaranteed if the triggers are not executed.</source>
          <target state="translated">这些表格配置了属于表的触发器的启动。被禁用的触发器仍为系统所知,但在其触发事件发生时不被执行。对于一个延迟的触发器,启用状态是在事件发生时检查,而不是在触发器功能实际执行时检查。可以禁用或启用由名称指定的单个触发器,也可以禁用或启用表上的所有触发器,或者只启用用户触发器(该选项不包括内部生成的约束触发器,如用于实现外键约束或可推迟的唯一性和排除性约束的触发器)。禁用或启用内部生成的约束触发器需要超级用户权限;应该谨慎操作,因为如果触发器不被执行,当然无法保证约束的完整性。</target>
        </trans-unit>
        <trans-unit id="e52e37f61e3318ab7cf1d7a034b06767466f19cd" translate="yes" xml:space="preserve">
          <source>These forms control the application of row security policies belonging to the table when the user is the table owner. If enabled, row level security policies will be applied when the user is the table owner. If disabled (the default) then row level security will not be applied when the user is the table owner. See also &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt;.</source>
          <target state="translated">当用户是表所有者时，这些表格控制着属于该表的行安全策略的应用。如果启用，则当用户是表所有者时，将应用行级安全策略。如果禁用（默认设置），则当用户是表所有者时，行级安全性将不适用。另请参阅&lt;a href=&quot;sql-createpolicy&quot;&gt;创建策略&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f8b1a193cdfbb05ae9fcb8caf7ab280345bebc71" translate="yes" xml:space="preserve">
          <source>These forms control the application of row security policies belonging to the table. If enabled and no policies exist for the table, then a default-deny policy is applied. Note that policies can exist for a table even if row level security is disabled - in this case, the policies will NOT be applied and the policies will be ignored. See also &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt;.</source>
          <target state="translated">这些表格控制着属于该表的行安全策略的应用。如果启用并且该表不存在任何策略，则将应用默认拒绝策略。请注意，即使禁用了行级安全性，表的策略也可以存在-在这种情况下，将不应用策略，并且将忽略该策略。另请参阅&lt;a href=&quot;sql-createpolicy&quot;&gt;创建策略&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eb00f1090b2d9838bfed692cafa4246a07d423cf" translate="yes" xml:space="preserve">
          <source>These forms control the application of row security policies belonging to the table. If enabled and no policies exist for the table, then a default-deny policy is applied. Note that policies can exist for a table even if row level security is disabled. In this case, the policies will &lt;em&gt;not&lt;/em&gt; be applied and the policies will be ignored. See also &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt;.</source>
          <target state="translated">这些表格控制着属于该表的行安全策略的应用。如果启用并且该表不存在任何策略，则将应用默认拒绝策略。请注意，即使禁用了行级安全性，表的策略也可以存在。在这种情况下，将&lt;em&gt;不&lt;/em&gt;应用策略，并且将忽略该策略。另请参阅&lt;a href=&quot;sql-createpolicy&quot;&gt;创建策略&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6de2d316d42b6299041b7b9b1fe769e5eb9fc501" translate="yes" xml:space="preserve">
          <source>These forms set or remove the default value for a column (where removal is equivalent to setting the default value to NULL). The new default value will only apply in subsequent &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; commands; it does not cause rows already in the table to change.</source>
          <target state="translated">这些表单设置或删除列的默认值（其中删除等同于将默认值设置为NULL）。新的默认值仅适用于后续的 &lt;code&gt;INSERT&lt;/code&gt; 或 &lt;code&gt;UPDATE&lt;/code&gt; 命令；它不会导致表中已有的行发生更改。</target>
        </trans-unit>
        <trans-unit id="a9ad545d11775ef6194d67bbd91b31263b043327" translate="yes" xml:space="preserve">
          <source>These forms set or remove the default value for a column. A view column's default value is substituted into any &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; command whose target is the view, before applying any rules or triggers for the view. The view's default will therefore take precedence over any default values from underlying relations.</source>
          <target state="translated">这些表格设置或删除列的默认值。在为视图应用任何规则或触发器之前，将视图列的默认值替换为目标为视图的任何 &lt;code&gt;INSERT&lt;/code&gt; 或 &lt;code&gt;UPDATE&lt;/code&gt; 命令。因此，视图的默认值将优先于基础关系中的任何默认值。</target>
        </trans-unit>
        <trans-unit id="a2f96c4d1ee03fc069f57f93ee22ce31fb12871d" translate="yes" xml:space="preserve">
          <source>These forms set or remove the default value for a column. Default values only apply in subsequent &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; commands; they do not cause rows already in the table to change.</source>
          <target state="translated">这些表格设置或删除列的默认值。默认值仅适用于后续的 &lt;code&gt;INSERT&lt;/code&gt; 或 &lt;code&gt;UPDATE&lt;/code&gt; 命令。它们不会导致表中已有的行发生更改。</target>
        </trans-unit>
        <trans-unit id="c9f74070b70e1b37c8a8a55a2765bed5bb39ae4b" translate="yes" xml:space="preserve">
          <source>These forms set or remove the default value for a domain. Note that defaults only apply to subsequent &lt;code&gt;INSERT&lt;/code&gt; commands; they do not affect rows already in a table using the domain.</source>
          <target state="translated">这些表格设置或删除域的默认值。请注意，默认设置仅适用于后续的 &lt;code&gt;INSERT&lt;/code&gt; 命令。它们不会影响使用域的表中已有的行。</target>
        </trans-unit>
        <trans-unit id="c517087178e89eb8504bd404d1b9002cc9225010" translate="yes" xml:space="preserve">
          <source>These functions act like their counterparts described above without the &lt;code&gt;_tz&lt;/code&gt; suffix, except that these functions support comparisons of date/time values that require timezone-aware conversions. The example below requires interpretation of the date-only value &lt;code&gt;2015-08-02&lt;/code&gt; as a timestamp with time zone, so the result depends on the current &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; setting. Due to this dependency, these functions are marked as stable, which means these functions cannot be used in indexes. Their counterparts are immutable, and so can be used in indexes; but they will throw errors if asked to make such comparisons.</source>
          <target state="translated">这些函数的行为类似于上述对应的函数，但不带 &lt;code&gt;_tz&lt;/code&gt; 后缀，不同之处在于，这些函数支持比较需要进行时区识别的日期/时间值的比较。下面的示例要求将仅日期值 &lt;code&gt;2015-08-02&lt;/code&gt; 解释为带时区的时间戳，因此结果取决于当前的&lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt;设置。由于这种依赖性，这些函数被标记为稳定的，这意味着这些函数不能在索引中使用。它们的对应对象是不可变的，因此可以在索引中使用；但是如果要求进行此类比较，它们将抛出错误。</target>
        </trans-unit>
        <trans-unit id="1609442aa33410461ce94595a5363c37f09493d1" translate="yes" xml:space="preserve">
          <source>These functions are provided mostly for illustration purposes. You can create your own return types and functions based on the underlying &lt;code&gt;crosstab()&lt;/code&gt; function. There are two ways to do it:</source>
          <target state="translated">提供这些功能主要是出于说明目的。您可以基于基础 &lt;code&gt;crosstab()&lt;/code&gt; 函数创建自己的返回类型和函数。有两种方法可以做到这一点：</target>
        </trans-unit>
        <trans-unit id="b71ab786c550ccb22b4bc0a42b2b14940119395f" translate="yes" xml:space="preserve">
          <source>These functions check whether a &lt;code&gt;text&lt;/code&gt; string is well-formed XML, returning a Boolean result. &lt;code&gt;xml_is_well_formed_document&lt;/code&gt; checks for a well-formed document, while &lt;code&gt;xml_is_well_formed_content&lt;/code&gt; checks for well-formed content. &lt;code&gt;xml_is_well_formed&lt;/code&gt; does the former if the &lt;a href=&quot;runtime-config-client#GUC-XMLOPTION&quot;&gt;xmloption&lt;/a&gt; configuration parameter is set to &lt;code&gt;DOCUMENT&lt;/code&gt;, or the latter if it is set to &lt;code&gt;CONTENT&lt;/code&gt;. This means that &lt;code&gt;xml_is_well_formed&lt;/code&gt; is useful for seeing whether a simple cast to type &lt;code&gt;xml&lt;/code&gt; will succeed, whereas the other two functions are useful for seeing whether the corresponding variants of &lt;code&gt;XMLPARSE&lt;/code&gt; will succeed.</source>
          <target state="translated">这些函数检查 &lt;code&gt;text&lt;/code&gt; 字符串是否为格式正确的 XML，并返回布尔结果。 &lt;code&gt;xml_is_well_formed_document&lt;/code&gt; 检查格式正确的文档，而 &lt;code&gt;xml_is_well_formed_content&lt;/code&gt; 检查格式正确的内容。如果&lt;a href=&quot;runtime-config-client#GUC-XMLOPTION&quot;&gt;xmloption&lt;/a&gt;配置参数设置为 &lt;code&gt;DOCUMENT&lt;/code&gt; ，则 &lt;code&gt;xml_is_well_formed&lt;/code&gt; 执行前一个；如果将XMLoption配置参数设置为 &lt;code&gt;CONTENT&lt;/code&gt; ,则进行后一个。 ，这意味着 &lt;code&gt;xml_is_well_formed&lt;/code&gt; 是看一个简单的强制转换为类型是否有用 &lt;code&gt;xml&lt;/code&gt; 会成功，而另外两个功能是看到相应的变体是否有用 &lt;code&gt;XMLPARSE&lt;/code&gt; 会成功。</target>
        </trans-unit>
        <trans-unit id="1992890b76b79219185f1f21ec736953dc79e0bb" translate="yes" xml:space="preserve">
          <source>These functions check whether a &lt;code&gt;text&lt;/code&gt; string represents well-formed XML, returning a Boolean result. &lt;code&gt;xml_is_well_formed_document&lt;/code&gt; checks for a well-formed document, while &lt;code&gt;xml_is_well_formed_content&lt;/code&gt; checks for well-formed content. &lt;code&gt;xml_is_well_formed&lt;/code&gt; does the former if the &lt;a href=&quot;runtime-config-client#GUC-XMLOPTION&quot;&gt;xmloption&lt;/a&gt; configuration parameter is set to &lt;code&gt;DOCUMENT&lt;/code&gt;, or the latter if it is set to &lt;code&gt;CONTENT&lt;/code&gt;. This means that &lt;code&gt;xml_is_well_formed&lt;/code&gt; is useful for seeing whether a simple cast to type &lt;code&gt;xml&lt;/code&gt; will succeed, whereas the other two functions are useful for seeing whether the corresponding variants of &lt;code&gt;XMLPARSE&lt;/code&gt; will succeed.</source>
          <target state="translated">这些函数检查 &lt;code&gt;text&lt;/code&gt; 字符串是否表示格式正确的XML，并返回布尔结果。 &lt;code&gt;xml_is_well_formed_document&lt;/code&gt; 检查格式正确的文档，而 &lt;code&gt;xml_is_well_formed_content&lt;/code&gt; 检查格式正确的内容。如果&lt;a href=&quot;runtime-config-client#GUC-XMLOPTION&quot;&gt;xmloption&lt;/a&gt;配置参数设置为 &lt;code&gt;DOCUMENT&lt;/code&gt; ，则 &lt;code&gt;xml_is_well_formed&lt;/code&gt; 执行前一个；如果将XMLoption配置参数设置为 &lt;code&gt;CONTENT&lt;/code&gt; ,则进行后一个。，这意味着 &lt;code&gt;xml_is_well_formed&lt;/code&gt; 是看一个简单的强制转换为类型是否有用 &lt;code&gt;xml&lt;/code&gt; 会成功，而另外两个功能是看到相应的变体是否有用 &lt;code&gt;XMLPARSE&lt;/code&gt; 会成功。</target>
        </trans-unit>
        <trans-unit id="c60a18e52593260f76cbca36e7fdad5953d14de4" translate="yes" xml:space="preserve">
          <source>These functions evaluate the XPath query on the supplied document, and cast the result to the specified type.</source>
          <target state="translated">这些函数对所提供的文档进行XPath查询评估,并将结果投向指定的类型。</target>
        </trans-unit>
        <trans-unit id="b4542e502e3568b9c387481842c5701029f5b7b1" translate="yes" xml:space="preserve">
          <source>These functions ignore tables that are not readable by the current user. The database-wide functions additionally ignore schemas that the current user does not have &lt;code&gt;USAGE&lt;/code&gt; (lookup) privilege for.</source>
          <target state="translated">这些函数将忽略当前用户无法读取的表。数据库范围的功能还忽略当前用户没有 &lt;code&gt;USAGE&lt;/code&gt; （查找）特权的架构。</target>
        </trans-unit>
        <trans-unit id="f4a3b49c368c625ddd8e1b267d172c4c23e85fb8" translate="yes" xml:space="preserve">
          <source>These functions only run a cipher over data; they don't have any advanced features of PGP encryption. Therefore they have some major problems:</source>
          <target state="translated">这些功能只是在数据上运行一个密码,它们不具备PGP加密的任何高级功能。因此它们有一些主要的问题:</target>
        </trans-unit>
        <trans-unit id="2e87e18038a41ce286dc1540ea6ddc6645f709cb" translate="yes" xml:space="preserve">
          <source>These functions wrap/unwrap binary data into PGP ASCII-armor format, which is basically Base64 with CRC and additional formatting.</source>
          <target state="translated">这些函数将二进制数据封装/解封装为PGP ASCII-armor格式,基本上是带有CRC和附加格式的Base64格式.</target>
        </trans-unit>
        <trans-unit id="a69e2cf20fe43ca97cfd2d3152291de2a47cffbd" translate="yes" xml:space="preserve">
          <source>These instructions assume that your existing installation is under the &lt;code&gt;/usr/local/pgsql&lt;/code&gt; directory, and that the data area is in &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt;. Substitute your paths appropriately.</source>
          <target state="translated">这些说明假定您现有的安装位于 &lt;code&gt;/usr/local/pgsql&lt;/code&gt; 目录下，并且数据区域位于 &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt; 中。适当替换您的路径。</target>
        </trans-unit>
        <trans-unit id="4c32652f01e68dc2b9e4e1795da20ec44b710efa" translate="yes" xml:space="preserve">
          <source>These key words do not have any effect, since there are no dependencies on casts.</source>
          <target state="translated">这些关键词没有任何效果,因为没有依赖性的投。</target>
        </trans-unit>
        <trans-unit id="bea3c1233d30126b2b7a88c0987f5eda6383c5d4" translate="yes" xml:space="preserve">
          <source>These key words do not have any effect, since there are no dependencies on conversions.</source>
          <target state="translated">这些关键词没有任何效果,因为对转换没有依赖性。</target>
        </trans-unit>
        <trans-unit id="0fd011ed971053a775e55c8199ea3272eca8d26f" translate="yes" xml:space="preserve">
          <source>These key words do not have any effect, since there are no dependencies on policies.</source>
          <target state="translated">这些关键词没有任何效果,因为不存在对政策的依赖性。</target>
        </trans-unit>
        <trans-unit id="a6e707f7bc3e009a0e21e941c667a8cfc394f561" translate="yes" xml:space="preserve">
          <source>These key words do not have any effect, since there are no dependencies on publications.</source>
          <target state="translated">这些关键词没有任何影响,因为对出版物没有依赖性。</target>
        </trans-unit>
        <trans-unit id="32c4da55bd25afdbc9c41ed6381881695d3bb025" translate="yes" xml:space="preserve">
          <source>These key words do not have any effect, since there are no dependencies on subscriptions.</source>
          <target state="translated">这些关键词没有任何效果,因为对订阅没有依赖性。</target>
        </trans-unit>
        <trans-unit id="2c7609a430b2441baa8c916ed20ac5c190ce5d75" translate="yes" xml:space="preserve">
          <source>These messages are harmless and should be ignored.</source>
          <target state="translated">这些信息是无害的,应该被忽略。</target>
        </trans-unit>
        <trans-unit id="0c905ac1adcf65ee4d503774195629e18e03ce45" translate="yes" xml:space="preserve">
          <source>These numbers are current as of the last &lt;code&gt;VACUUM&lt;/code&gt; or &lt;code&gt;ANALYZE&lt;/code&gt; on the table. The planner then fetches the actual current number of pages in the table (this is a cheap operation, not requiring a table scan). If that is different from &lt;code&gt;relpages&lt;/code&gt; then &lt;code&gt;reltuples&lt;/code&gt; is scaled accordingly to arrive at a current number-of-rows estimate. In the example above, the value of &lt;code&gt;relpages&lt;/code&gt; is up-to-date so the rows estimate is the same as &lt;code&gt;reltuples&lt;/code&gt;.</source>
          <target state="translated">这些数字是表格中最后一个 &lt;code&gt;VACUUM&lt;/code&gt; 或 &lt;code&gt;ANALYZE&lt;/code&gt; 的当前数字。然后，计划者获取表中当前的实际页面数（这是一种廉价操作，不需要表扫描）。如果那与 &lt;code&gt;relpages&lt;/code&gt; 不同，则对 &lt;code&gt;reltuples&lt;/code&gt; 进行相应缩放，以得出当前行数估计。在上面的示例中， &lt;code&gt;relpages&lt;/code&gt; 的值是最新的，因此行估计与 &lt;code&gt;reltuples&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="e10d3fa9498e1464949f282d6e93d894677beaed" translate="yes" xml:space="preserve">
          <source>These numbers are derived very straightforwardly. If you do:</source>
          <target state="translated">这些数字的推导非常直接。如果你这样做。</target>
        </trans-unit>
        <trans-unit id="3ceb62071b97b9d98e29565b51240d61862b6aa6" translate="yes" xml:space="preserve">
          <source>These operations are also possible using &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;. &lt;code&gt;ALTER INDEX&lt;/code&gt; is in fact just an alias for the forms of &lt;code&gt;ALTER TABLE&lt;/code&gt; that apply to indexes.</source>
          <target state="translated">这些操作也可以使用&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE进行&lt;/a&gt;。实际上， &lt;code&gt;ALTER INDEX&lt;/code&gt; 只是适用于索引的 &lt;code&gt;ALTER TABLE&lt;/code&gt; 形式的别名。</target>
        </trans-unit>
        <trans-unit id="545a0c8a716c900f9e4c80a9d1bee182bedf1b50" translate="yes" xml:space="preserve">
          <source>These operations are not as efficient as the SQL &lt;code&gt;COPY&lt;/code&gt; command with a file or program data source or destination, because all data must pass through the client/server connection. For large amounts of data the SQL command might be preferable.</source>
          <target state="translated">这些操作的效率不如使用文件或程序数据源或目标的SQL &lt;code&gt;COPY&lt;/code&gt; 命令，因为所有数据都必须通过客户端/服务器连接传递。对于大量数据，SQL命令可能更可取。</target>
        </trans-unit>
        <trans-unit id="127d5c1d5ec611dd1c5cea591e059868fdcde0f9" translate="yes" xml:space="preserve">
          <source>These operators do not make a lot of sense for any practical purpose but sorting. These operators first compare (a) to (c), and if these are equal, compare (b) to (d). That results in reasonably good sorting in most cases, which is useful if you want to use ORDER BY with this type.</source>
          <target state="translated">这些运算符除了排序之外,对任何实际目的都没有太大的意义。这些运算符首先比较(a)和(c),如果它们相等,则比较(b)和(d)。这在大多数情况下都能得到相当好的排序结果,如果你想对这种类型使用ORDER BY,这很有用。</target>
        </trans-unit>
        <trans-unit id="0263a47917171f02351f77d8e8b63fd3b27641de" translate="yes" xml:space="preserve">
          <source>These option names are recognized case-insensitively. Any unspecified options receive these defaults:</source>
          <target state="translated">这些选项名称的识别不区分大小写。任何未指定的选项都会得到这些默认值。</target>
        </trans-unit>
        <trans-unit id="97b00e5b641f2fbb1f110712d8ca4d9e2d1eb19a" translate="yes" xml:space="preserve">
          <source>These option names are recognized case-insensitively. You must double-quote string values if they contain spaces or commas.</source>
          <target state="translated">这些选项名的识别是不区分大小写的。如果字符串值包含空格或逗号,必须用双引号。</target>
        </trans-unit>
        <trans-unit id="aae23616e05cfe7a713aa38934f0f1dc39a127ad" translate="yes" xml:space="preserve">
          <source>These options can be used to control the names used in SQL statements sent to the remote PostgreSQL server. These options are needed when a foreign table is created with names different from the underlying remote table's names.</source>
          <target state="translated">这些选项可以用来控制发送到远程PostgreSQL服务器的SQL语句中使用的名称。当创建的外表的名称与远程表的名称不同时,就需要这些选项。</target>
        </trans-unit>
        <trans-unit id="d77fba085883250197e1d576feb3bfa1670ceb86" translate="yes" xml:space="preserve">
          <source>These options can only be specified for a foreign table or its columns, not in the options of the &lt;code&gt;file_fdw&lt;/code&gt; foreign-data wrapper, nor in the options of a server or user mapping using the wrapper.</source>
          <target state="translated">这些选项只能为外部表或其列指定，不能在 &lt;code&gt;file_fdw&lt;/code&gt; 外部数据包装器的选项中指定，也不能在使用包装器的服务器或用户映射的选项中指定。</target>
        </trans-unit>
        <trans-unit id="00c89bc3ee002172b7e73344d78285229be1f391" translate="yes" xml:space="preserve">
          <source>These parameters (except the XPath strings) are just substituted into a plain SQL SELECT statement, so you have some flexibility &amp;mdash; the statement is</source>
          <target state="translated">这些参数（XPath字符串除外）仅被替换为简单的SQL SELECT语句，因此您具有一定的灵活性-该语句为</target>
        </trans-unit>
        <trans-unit id="c2aabd8f5a3412d7716945926dce543c9d86d614" translate="yes" xml:space="preserve">
          <source>These parameters can be set on any server that is to send replication data to one or more standby servers. The master is always a sending server, so these parameters must always be set on the master. The role and meaning of these parameters does not change after a standby becomes the master.</source>
          <target state="translated">这些参数可以在任何要向一个或多个备用服务器发送复制数据的服务器上设置。主服务器始终是发送服务器,所以这些参数必须始终设置在主服务器上。备用服务器成为主站后,这些参数的作用和意义不会改变。</target>
        </trans-unit>
        <trans-unit id="0c34294a4db205be8e19649f7f900fbda851ca14" translate="yes" xml:space="preserve">
          <source>These parameters can be set on the master/primary server that is to send replication data to one or more standby servers. Note that in addition to these parameters, &lt;a href=&quot;runtime-config-wal#GUC-WAL-LEVEL&quot;&gt;wal_level&lt;/a&gt; must be set appropriately on the master server, and optionally WAL archiving can be enabled as well (see &lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-ARCHIVING&quot;&gt;Section 19.5.3&lt;/a&gt;). The values of these parameters on standby servers are irrelevant, although you may wish to set them there in preparation for the possibility of a standby becoming the master.</source>
          <target state="translated">可以在将复制数据发送到一个或多个备用服务器的主/主服务器上设置这些参数。请注意，除了这些参数之外，&lt;a href=&quot;runtime-config-wal#GUC-WAL-LEVEL&quot;&gt;还&lt;/a&gt;必须在主服务器上适当设置wal_level，并且还可以选择启用WAL归档（请参见&lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-ARCHIVING&quot;&gt;第19.5.3节&lt;/a&gt;）。备用服务器上的这些参数的值无关紧要，尽管您可能希望在此处设置它们，以准备备用服务器成为主服务器。</target>
        </trans-unit>
        <trans-unit id="4d75398d82f486d5c040810e5532c3a355a6c99c" translate="yes" xml:space="preserve">
          <source>These parameters control server-wide statistics collection features. When statistics collection is enabled, the data that is produced can be accessed via the &lt;code&gt;pg_stat&lt;/code&gt; and &lt;code&gt;pg_statio&lt;/code&gt; family of system views. Refer to &lt;a href=&quot;https://www.postgresql.org/docs/12/monitoring.html&quot;&gt;Chapter 27&lt;/a&gt; for more information.</source>
          <target state="translated">这些参数控制服务器范围的统计信息收集功能。启用统计信息收集后，可以通过 &lt;code&gt;pg_stat&lt;/code&gt; 和 &lt;code&gt;pg_statio&lt;/code&gt; 系列系统视图访问生成的数据。有关更多信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/monitoring.html&quot;&gt;第27章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0d575b835ad7e47410bdf9d6f66f26ab665d0047" translate="yes" xml:space="preserve">
          <source>These parameters control server-wide statistics collection features. When statistics collection is enabled, the data that is produced can be accessed via the &lt;code&gt;pg_stat&lt;/code&gt; and &lt;code&gt;pg_statio&lt;/code&gt; family of system views. Refer to &lt;a href=&quot;https://www.postgresql.org/docs/13/monitoring.html&quot;&gt;Chapter 27&lt;/a&gt; for more information.</source>
          <target state="translated">这些参数控制服务器范围的统计信息收集功能。启用统计信息收集后，可以通过 &lt;code&gt;pg_stat&lt;/code&gt; 和 &lt;code&gt;pg_statio&lt;/code&gt; 系列系统视图访问生成的数据。有关更多信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/13/monitoring.html&quot;&gt;第27章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d7058fa11283b8e308dc5c38fd60ebf25607e531" translate="yes" xml:space="preserve">
          <source>These parameters enable various debugging output to be emitted. When set, they print the resulting parse tree, the query rewriter output, or the execution plan for each executed query. These messages are emitted at &lt;code&gt;LOG&lt;/code&gt; message level, so by default they will appear in the server log but will not be sent to the client. You can change that by adjusting &lt;a href=&quot;runtime-config-client#GUC-CLIENT-MIN-MESSAGES&quot;&gt;client_min_messages&lt;/a&gt; and/or &lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-MESSAGES&quot;&gt;log_min_messages&lt;/a&gt;. These parameters are off by default.</source>
          <target state="translated">这些参数使得可以发出各种调试输出。设置后，它们将打印结果分析树，查询重写器输出或每个已执行查询的执行计划。这些消息是在 &lt;code&gt;LOG&lt;/code&gt; 消息级别发出的，因此默认情况下，它们将显示在服务器日志中，但不会发送给客户端。您可以通过调整&lt;a href=&quot;runtime-config-client#GUC-CLIENT-MIN-MESSAGES&quot;&gt;client_min_messages&lt;/a&gt;和/或&lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-MESSAGES&quot;&gt;log_min_messages&lt;/a&gt;来更改它。这些参数默认情况下处于关闭状态。</target>
        </trans-unit>
        <trans-unit id="1defee4ea46ba6aaadce70e43d5781b50b0c40a2" translate="yes" xml:space="preserve">
          <source>These parameters must be set in &lt;code&gt;postgresql.conf&lt;/code&gt;. Typical usage might be:</source>
          <target state="translated">这些参数必须在 &lt;code&gt;postgresql.conf&lt;/code&gt; 中设置。典型用法可能是：</target>
        </trans-unit>
        <trans-unit id="51c50b20efcdf41bd58d1a6d4948e28cfd164232" translate="yes" xml:space="preserve">
          <source>These popular data structures were originally developed for in-memory usage. In main memory, they are usually designed as a set of dynamically allocated nodes linked by pointers. This is not suitable for direct storing on disk, since these chains of pointers can be rather long which would require too many disk accesses. In contrast, disk-based data structures should have a high fanout to minimize I/O. The challenge addressed by SP-GiST is to map search tree nodes to disk pages in such a way that a search need access only a few disk pages, even if it traverses many nodes.</source>
          <target state="translated">这些流行的数据结构最初是为在内存中使用而开发的。在主内存中,它们通常被设计成一组由指针连接的动态分配节点。这不适合直接存储在磁盘上,因为这些指针链可能相当长,这将需要太多磁盘访问。相反,基于磁盘的数据结构应该有一个高扇出,以减少I/O。SP-GIST所面临的挑战是将搜索树节点映射到磁盘页面,这样即使搜索遍历许多节点,也只需要访问几个磁盘页面。</target>
        </trans-unit>
        <trans-unit id="929fc5ec9668da12721d514b3f6bf4c331845b00" translate="yes" xml:space="preserve">
          <source>These represent the IEEE 754 special values &amp;ldquo;infinity&amp;rdquo;, &amp;ldquo;negative infinity&amp;rdquo;, and &amp;ldquo;not-a-number&amp;rdquo;, respectively. When writing these values as constants in an SQL command, you must put quotes around them, for example &lt;code&gt;UPDATE table SET x = '-Infinity'&lt;/code&gt;. On input, these strings are recognized in a case-insensitive manner.</source>
          <target state="translated">它们分别表示IEEE 754特殊值&amp;ldquo;无穷大&amp;rdquo;，&amp;ldquo;负无穷大&amp;rdquo;和&amp;ldquo;非数字&amp;rdquo;。在SQL命令中将这些值写为常量时，必须在其 &lt;code&gt;UPDATE table SET x = '-Infinity'&lt;/code&gt; 加上引号，例如UPDATE table SET x ='-Infinity'。输入时，这些字符串以不区分大小写的方式识别。</target>
        </trans-unit>
        <trans-unit id="f1107e48978793d7f588abce7216f17e213bc711" translate="yes" xml:space="preserve">
          <source>These rules are very similar to those for writing field values in composite-type literals. See &lt;a href=&quot;rowtypes#ROWTYPES-IO-SYNTAX&quot;&gt;Section 8.16.6&lt;/a&gt; for additional commentary.</source>
          <target state="translated">这些规则与用复合类型文字编写字段值的规则非常相似。有关更多评论，请参见&lt;a href=&quot;rowtypes#ROWTYPES-IO-SYNTAX&quot;&gt;第8.16.6节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2f4ab75f18b56a1736b944ffdb026f1b2a9cc643" translate="yes" xml:space="preserve">
          <source>These semaphore-related settings are read-only as far as &lt;code&gt;sysctl&lt;/code&gt; is concerned, but can be set in &lt;code&gt;/boot/loader.conf&lt;/code&gt;:</source>
          <target state="translated">就 &lt;code&gt;sysctl&lt;/code&gt; 而言，这些与信号量相关的设置是只读的，但可以在 &lt;code&gt;/boot/loader.conf&lt;/code&gt; 中进行设置：</target>
        </trans-unit>
        <trans-unit id="f0eb1c6b354c2721dc2500c187dae9d22e4b37ec" translate="yes" xml:space="preserve">
          <source>These settings can be set from &lt;code&gt;postgresql.conf&lt;/code&gt;, or within a session via the &lt;code&gt;SET&lt;/code&gt; command. Any user is allowed to change their session-local value. Changes in &lt;code&gt;postgresql.conf&lt;/code&gt; will affect existing sessions only if no session-local value has been established with &lt;code&gt;SET&lt;/code&gt;.</source>
          <target state="translated">这些设置可以在 &lt;code&gt;postgresql.conf&lt;/code&gt; 中设置，也可以在会话中通过 &lt;code&gt;SET&lt;/code&gt; 命令设置。允许任何用户更改其本地会话值。仅当未使用 &lt;code&gt;SET&lt;/code&gt; 建立会话本地值时， &lt;code&gt;postgresql.conf&lt;/code&gt; 中的更改才会影响现有会话。</target>
        </trans-unit>
        <trans-unit id="0adef7245cebc3b52bd4dfc1694701eadaec06f1" translate="yes" xml:space="preserve">
          <source>These settings can be set from &lt;code&gt;postgresql.conf&lt;/code&gt;, or within a session via the &lt;code&gt;SET&lt;/code&gt; command; but only superusers can change them via &lt;code&gt;SET&lt;/code&gt;. Changes in &lt;code&gt;postgresql.conf&lt;/code&gt; will affect existing sessions only if no session-local value has been established with &lt;code&gt;SET&lt;/code&gt;.</source>
          <target state="translated">这些设置可以在 &lt;code&gt;postgresql.conf&lt;/code&gt; 中设置，也可以在会话中通过 &lt;code&gt;SET&lt;/code&gt; 命令设置。但是只有超级用户可以通过 &lt;code&gt;SET&lt;/code&gt; 更改它们。仅当未使用 &lt;code&gt;SET&lt;/code&gt; 建立会话本地值时， &lt;code&gt;postgresql.conf&lt;/code&gt; 中的更改才会影响现有会话。</target>
        </trans-unit>
        <trans-unit id="7a83e5497c48f3fadb734c9a42de145288252b14" translate="yes" xml:space="preserve">
          <source>These settings can only be applied when the server starts, so any change requires restarting the server. Values for these settings are typically stored in the &lt;code&gt;postgresql.conf&lt;/code&gt; file, or passed on the command line when starting the server. Of course, settings with any of the lower &lt;code&gt;context&lt;/code&gt; types can also be set at server start time.</source>
          <target state="translated">这些设置只能在服务器启动时应用，因此任何更改都需要重新启动服务器。这些设置的值通常存储在 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件中，或者在启动服务器时在命令行中传递。当然，也可以在服务器启动时设置具有任何较低 &lt;code&gt;context&lt;/code&gt; 类型的设置。</target>
        </trans-unit>
        <trans-unit id="02aa5756831dee127ec65944b5fa10a7b3de8a8e" translate="yes" xml:space="preserve">
          <source>These settings cannot be changed directly; they reflect internally determined values. Some of them may be adjustable by rebuilding the server with different configuration options, or by changing options supplied to &lt;code&gt;initdb&lt;/code&gt;.</source>
          <target state="translated">这些设置不能直接更改。它们反映了内部确定的值。通过使用不同的配置选项重建服务器，或更改提供给 &lt;code&gt;initdb&lt;/code&gt; 的选项，可以调整其中的一些。</target>
        </trans-unit>
        <trans-unit id="317e80ee1851e3545ba5ed374350ee15698895fc" translate="yes" xml:space="preserve">
          <source>These settings control how process titles of server processes are modified. Process titles are typically viewed using programs like ps or, on Windows, Process Explorer. See &lt;a href=&quot;monitoring-ps&quot;&gt;Section 27.1&lt;/a&gt; for details.</source>
          <target state="translated">这些设置控制如何修改服务器进程的进程标题。通常使用ps之类的程序或在Windows中使用Process Explorer查看进程标题。有关详细信息，请参见&lt;a href=&quot;monitoring-ps&quot;&gt;第27.1节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c21f5b22d74359b34a233de933da88c1556b1754" translate="yes" xml:space="preserve">
          <source>These settings control the behavior of a logical replication subscriber. Their values on the publisher are irrelevant.</source>
          <target state="translated">这些设置控制逻辑复制用户的行为。它们在发布者上的值是不相关的。</target>
        </trans-unit>
        <trans-unit id="51ac309dd49de1c6d6c04c1c54a256fdaeb98b75" translate="yes" xml:space="preserve">
          <source>These settings control the behavior of a standby server that is to receive replication data. Their values on the master server are irrelevant.</source>
          <target state="translated">这些设置控制要接收复制数据的备用服务器的行为。它们在主服务器上的值是不相关的。</target>
        </trans-unit>
        <trans-unit id="d40b8d037fb02f22e279e00bffd1ef98f7d8c44d" translate="yes" xml:space="preserve">
          <source>These settings control the behavior of the &lt;em&gt;autovacuum&lt;/em&gt; feature. Refer to &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information. Note that many of these settings can be overridden on a per-table basis; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt;.</source>
          <target state="translated">这些设置控制自动&lt;em&gt;真空&lt;/em&gt;功能的行为。有关更多信息，请参见&lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;第24.1.6节&lt;/a&gt;。请注意，许多设置可以按表被覆盖；请参阅&lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;存储参数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1c9c05e7e68e0c9931d3c483fab276d6098720bf" translate="yes" xml:space="preserve">
          <source>These settings control the behavior of the built-in &lt;em&gt;streaming replication&lt;/em&gt; feature (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;). Servers will be either a master or a standby server. Masters can send data, while standbys are always receivers of replicated data. When cascading replication (see &lt;a href=&quot;warm-standby#CASCADING-REPLICATION&quot;&gt;Section 26.2.7&lt;/a&gt;) is used, standby servers can also be senders, as well as receivers. Parameters are mainly for sending and standby servers, though some parameters have meaning only on the master server. Settings may vary across the cluster without problems if that is required.</source>
          <target state="translated">这些设置控制内置&lt;em&gt;流复制&lt;/em&gt;功能的行为（请参见&lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;第26.2.5节&lt;/a&gt;）。服务器将是主服务器或备用服务器。主服务器可以发送数据，而备用数据库始终是复制数据的接收者。当使用级联复制（请参阅&lt;a href=&quot;warm-standby#CASCADING-REPLICATION&quot;&gt;第26.2.7节&lt;/a&gt;）时，备用服务器也可以是发送者，也可以是接收者。参数主要用于发送和备用服务器，尽管某些参数仅在主服务器上有意义。如果需要，整个群集中的设置可能会有所不同，而不会出现问题。</target>
        </trans-unit>
        <trans-unit id="631081e51e8d0c56dfb2edd79daea765216e4764" translate="yes" xml:space="preserve">
          <source>These settings will cause postmaster child processes to run with the normal OOM score adjustment of zero, so that the OOM killer can still target them at need. You could use some other value for &lt;code&gt;PG_OOM_ADJUST_VALUE&lt;/code&gt; if you want the child processes to run with some other OOM score adjustment. (&lt;code&gt;PG_OOM_ADJUST_VALUE&lt;/code&gt; can also be omitted, in which case it defaults to zero.) If you do not set &lt;code&gt;PG_OOM_ADJUST_FILE&lt;/code&gt;, the child processes will run with the same OOM score adjustment as the postmaster, which is unwise since the whole point is to ensure that the postmaster has a preferential setting.</source>
          <target state="translated">这些设置将使Postmaster子进程在正常的OOM分数调整为零的情况下运行，因此OOM杀手仍然可以根据需要定位它们。如果希望子进程与其他一些OOM分数调整一起运行， &lt;code&gt;PG_OOM_ADJUST_VALUE&lt;/code&gt; 使用其他值。（也可以省略 &lt;code&gt;PG_OOM_ADJUST_VALUE&lt;/code&gt; ，在这种情况下它默认为零。）如果您未设置 &lt;code&gt;PG_OOM_ADJUST_FILE&lt;/code&gt; ，则子进程将以与邮政局长相同的OOM分数调整运行，这是不明智的，因为要确保整个过程邮局局长有一个优先设置。</target>
        </trans-unit>
        <trans-unit id="8ab15e9b47def86730e35b3c5c50e0dfe3f834aa" translate="yes" xml:space="preserve">
          <source>These specify what the prompts psql issues should look like. See &lt;a href=&quot;app-psql#APP-PSQL-PROMPTING&quot;&gt;Prompting&lt;/a&gt; below.</source>
          <target state="translated">这些指定了提示psql问题的外观。请参阅下面的&lt;a href=&quot;app-psql#APP-PSQL-PROMPTING&quot;&gt;提示&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6086ed3e7f06eab1a2070198d662f5b66b1e6406" translate="yes" xml:space="preserve">
          <source>These trigger functions automatically compute a &lt;code&gt;tsvector&lt;/code&gt; column from one or more textual columns, under the control of parameters specified in the &lt;code&gt;CREATE TRIGGER&lt;/code&gt; command. An example of their use is:</source>
          <target state="translated">这些触发器函数在 &lt;code&gt;CREATE TRIGGER&lt;/code&gt; 命令中指定的参数的控制下，自动从一个或多个文本列中计算出 &lt;code&gt;tsvector&lt;/code&gt; 列。其用法的一个示例是：</target>
        </trans-unit>
        <trans-unit id="26b286f322440c12ea3e3c031f3d293b77ba6582" translate="yes" xml:space="preserve">
          <source>These two fields can be used as an alternative to the &lt;code&gt;IP-address&lt;/code&gt;&lt;code&gt;/&lt;/code&gt;&lt;code&gt;mask-length&lt;/code&gt; notation. Instead of specifying the mask length, the actual mask is specified in a separate column. For example, &lt;code&gt;255.0.0.0&lt;/code&gt; represents an IPv4 CIDR mask length of 8, and &lt;code&gt;255.255.255.255&lt;/code&gt; represents a CIDR mask length of 32.</source>
          <target state="translated">这两个字段可以用作 &lt;code&gt;IP-address&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; &lt;code&gt;mask-length&lt;/code&gt; 表示法的替代。而不是指定掩码长度，而是在单独的列中指定实际掩码。例如， &lt;code&gt;255.0.0.0&lt;/code&gt; 表示IPv4 CIDR掩码长度为8，而 &lt;code&gt;255.255.255.255&lt;/code&gt; 表示CIDR掩码长度为32。</target>
        </trans-unit>
        <trans-unit id="b912ce7211a3c9dfe25f2009d32879c2b4a7718a" translate="yes" xml:space="preserve">
          <source>These variables are set at program start-up to reflect psql's version, respectively as a verbose string, a short string (e.g., &lt;code&gt;9.6.2&lt;/code&gt;, &lt;code&gt;10.1&lt;/code&gt;, or &lt;code&gt;11beta1&lt;/code&gt;), and a number (e.g., &lt;code&gt;90602&lt;/code&gt; or &lt;code&gt;100001&lt;/code&gt;). They can be changed or unset.</source>
          <target state="translated">这些变量分别设置在程序启动，以反映psql的版本，一个详细的字符串，一个简短的字符串（例如， &lt;code&gt;9.6.2&lt;/code&gt; ， &lt;code&gt;10.1&lt;/code&gt; ，或 &lt;code&gt;11beta1&lt;/code&gt; ）和数量（例如， &lt;code&gt;90602&lt;/code&gt; 或 &lt;code&gt;100001&lt;/code&gt; ）。可以更改或取消设置。</target>
        </trans-unit>
        <trans-unit id="d1888af9231d7dc7892d920d2796a7d30d3c432b" translate="yes" xml:space="preserve">
          <source>These will always return true or false, never a null value, even when the operand is null. A null input is treated as the logical value &amp;ldquo;unknown&amp;rdquo;. Notice that &lt;code&gt;IS UNKNOWN&lt;/code&gt; and &lt;code&gt;IS NOT UNKNOWN&lt;/code&gt; are effectively the same as &lt;code&gt;IS NULL&lt;/code&gt; and &lt;code&gt;IS NOT NULL&lt;/code&gt;, respectively, except that the input expression must be of Boolean type.</source>
          <target state="translated">即使操作数为null，它们也将始终返回true或false，永远不会返回null值。空输入被视为逻辑值&amp;ldquo;未知&amp;rdquo;。请注意， &lt;code&gt;IS UNKNOWN&lt;/code&gt; 和 &lt;code&gt;IS NOT UNKNOWN&lt;/code&gt; 实际上分别与 &lt;code&gt;IS NULL&lt;/code&gt; 和 &lt;code&gt;IS NOT NULL&lt;/code&gt; 相同，除了输入表达式必须为布尔类型。</target>
        </trans-unit>
        <trans-unit id="eb77a6f9b66e9a05805238727dad27ac972c149a" translate="yes" xml:space="preserve">
          <source>They are slow. As the amount of data is so small, this is the only way to make brute-forcing passwords hard.</source>
          <target state="translated">它们的速度很慢。由于数据量太小,这是唯一能让粗暴逼迫密码变得困难的方法。</target>
        </trans-unit>
        <trans-unit id="bf2c8c3d26564b271cd3b0f3cc01f4bc594ad56e" translate="yes" xml:space="preserve">
          <source>They don't handle text.</source>
          <target state="translated">他们不处理文字。</target>
        </trans-unit>
        <trans-unit id="89bd6007244204d4a23986add99e11b8144bb68e" translate="yes" xml:space="preserve">
          <source>They don't provide any integrity checking, to see if the encrypted data was modified.</source>
          <target state="translated">他们不提供任何完整性检查,以查看加密数据是否被修改。</target>
        </trans-unit>
        <trans-unit id="108af784f0fd778d605e66d5a415819131da0024" translate="yes" xml:space="preserve">
          <source>They expect that users manage all encryption parameters themselves, even IV.</source>
          <target state="translated">他们希望用户自己管理所有的加密参数,甚至四。</target>
        </trans-unit>
        <trans-unit id="0c2039617625e55d628a5303153737be520c2636" translate="yes" xml:space="preserve">
          <source>They include the algorithm type in the result, so passwords hashed with different algorithms can co-exist.</source>
          <target state="translated">它们在结果中包含算法类型,所以用不同算法哈希的密码可以共存。</target>
        </trans-unit>
        <trans-unit id="c3e7dceb3b44e3013034907236242ebd62f58f0d" translate="yes" xml:space="preserve">
          <source>They provide no ordering (ranking) of search results, which makes them ineffective when thousands of matching documents are found.</source>
          <target state="translated">它们不提供搜索结果的排序(排名),这使得它们在找到成千上万的匹配文档时无效。</target>
        </trans-unit>
        <trans-unit id="2c267279c3829425820b5af53bc51b1aea00680d" translate="yes" xml:space="preserve">
          <source>They tend to be slow because there is no index support, so they must process all documents for every search.</source>
          <target state="translated">它们往往很慢,因为没有索引支持,所以每次搜索都必须处理所有文件。</target>
        </trans-unit>
        <trans-unit id="fc6b695f1b5d50d9c60b39def6c93072e73b0c7c" translate="yes" xml:space="preserve">
          <source>They use a random value, called the &lt;em&gt;salt&lt;/em&gt;, so that users having the same password will have different encrypted passwords. This is also an additional defense against reversing the algorithm.</source>
          <target state="translated">它们使用一个称为&lt;em&gt;salt&lt;/em&gt;的随机值，以便具有相同密码的用户将具有不同的加密密码。这也是防止逆转算法的另一项防范措施。</target>
        </trans-unit>
        <trans-unit id="e85a3bee9adadb9e25e77dec1600e19104320bfe" translate="yes" xml:space="preserve">
          <source>They use user key directly as cipher key.</source>
          <target state="translated">他们直接使用用户密钥作为密码密钥。</target>
        </trans-unit>
        <trans-unit id="8dbebd5ef75455c0a62f167f8fa030487ae4ceab" translate="yes" xml:space="preserve">
          <source>Things are more difficult if you need to recover from corruption of an index on a system table. In this case it's important for the system to not have used any of the suspect indexes itself. (Indeed, in this sort of scenario you might find that server processes are crashing immediately at start-up, due to reliance on the corrupted indexes.) To recover safely, the server must be started with the &lt;code&gt;-P&lt;/code&gt; option, which prevents it from using indexes for system catalog lookups.</source>
          <target state="translated">如果您需要从系统表上的索引损坏中恢复，事情会变得更加困难。在这种情况下，重要的是系统不要使用任何可疑索引本身。（实际上，在这种情况下，您可能会发现服务器进程由于依赖于损坏的索引而在启动时立即崩溃。）为了安全地进行恢复，必须使用 &lt;code&gt;-P&lt;/code&gt; 选项启动服务器，以防止服务器启动使用索引进行系统目录查找。</target>
        </trans-unit>
        <trans-unit id="96f7dee4533ea61962d64e3ad5a7fcf16ccab0dd" translate="yes" xml:space="preserve">
          <source>Third, turn on &lt;code&gt;sepgsql_regression_test_mode&lt;/code&gt;. For security reasons, the rules in &lt;code&gt;sepgsql-regtest&lt;/code&gt; are not enabled by default; the &lt;code&gt;sepgsql_regression_test_mode&lt;/code&gt; parameter enables the rules needed to launch the regression tests. It can be turned on using the &lt;code&gt;setsebool&lt;/code&gt; command:</source>
          <target state="translated">第三，打开 &lt;code&gt;sepgsql_regression_test_mode&lt;/code&gt; 。出于安全原因，默认情况下未启用 &lt;code&gt;sepgsql-regtest&lt;/code&gt; 中的规则；在 &lt;code&gt;sepgsql_regression_test_mode&lt;/code&gt; 参数使启动回归测试所需要的规则。可以使用 &lt;code&gt;setsebool&lt;/code&gt; 命令将其打开：</target>
        </trans-unit>
        <trans-unit id="e8a4d63f55e2492f2cd42b3a9fb86caa1ca5e84c" translate="yes" xml:space="preserve">
          <source>Third-party applications can be put into separate schemas so they do not collide with the names of other objects.</source>
          <target state="translated">第三方应用可以放在单独的模式中,这样就不会与其他对象的名称发生冲突。</target>
        </trans-unit>
        <trans-unit id="04297a9823a3a2086d546b9d671ec1f8ab29f655" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;WITH&lt;/code&gt; query will be folded, producing the same execution plan as</source>
          <target state="translated">该 &lt;code&gt;WITH&lt;/code&gt; 查询将被折叠，产生与执行相同的执行计划</target>
        </trans-unit>
        <trans-unit id="14ca478547dc2e8fab1f8f6bfce576b001fe2285" translate="yes" xml:space="preserve">
          <source>This access control mechanism is independent of the one described in &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;.</source>
          <target state="translated">此访问控制机制独立于&lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;第20章中&lt;/a&gt;描述的机制。</target>
        </trans-unit>
        <trans-unit id="b5d11934ea2252677e8bf50febe72c8f70679b90" translate="yes" xml:space="preserve">
          <source>This access control mechanism is independent of the one described in &lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;.</source>
          <target state="translated">这种访问控制机制独立于&lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;第20章中&lt;/a&gt;描述的机制。</target>
        </trans-unit>
        <trans-unit id="4c7fa7bd259660d0cb8e1608dc878af198c41a3a" translate="yes" xml:space="preserve">
          <source>This acquires a row-level lock on the row with the specified account number. Then, the second transaction executes:</source>
          <target state="translated">这将在指定账号的行上获得一个行级锁。然后,第二个交易执行。</target>
        </trans-unit>
        <trans-unit id="5cf940ef6c18dd4ff1a92a3955dc9c9d23c16666" translate="yes" xml:space="preserve">
          <source>This allows further operations to be performed on the data before it is dropped. For example, this is often a useful time to back up the data using &lt;code&gt;COPY&lt;/code&gt;, pg_dump, or similar tools. It might also be a useful time to aggregate data into smaller formats, perform other data manipulations, or run reports.</source>
          <target state="translated">这允许在删除数据之前对数据执行进一步的操作。例如，这通常是使用 &lt;code&gt;COPY&lt;/code&gt; ，pg_dump或类似工具备份数据的有用时间。这也是将数据聚合为较小格式，执行其他数据操作或运行报告的有用时间。</target>
        </trans-unit>
        <trans-unit id="7fb6b13498a74131eab9c57b3090da36c9ec9b3f" translate="yes" xml:space="preserve">
          <source>This allows sequential scans of large tables to synchronize with each other, so that concurrent scans read the same block at about the same time and hence share the I/O workload. When this is enabled, a scan might start in the middle of the table and then &amp;ldquo;wrap around&amp;rdquo; the end to cover all rows, so as to synchronize with the activity of scans already in progress. This can result in unpredictable changes in the row ordering returned by queries that have no &lt;code&gt;ORDER BY&lt;/code&gt; clause. Setting this parameter to &lt;code&gt;off&lt;/code&gt; ensures the pre-8.3 behavior in which a sequential scan always starts from the beginning of the table. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">这允许对大型表进行顺序扫描以使其彼此同步，以便并发扫描大约在同一时间读取同一块，从而分担了I / O工作量。启用此功能后，扫描可能会从表的中间开始，然后&amp;ldquo;绕回&amp;rdquo;末尾以覆盖所有行，以便与正在进行的扫描活动保持同步。这会导致没有 &lt;code&gt;ORDER BY&lt;/code&gt; 子句的查询返回的行顺序发生不可预测的变化。将此参数设置为 &lt;code&gt;off&lt;/code&gt; 可确保8.3版之前的行为始终从表的开头开始进行顺序扫描。默认值为 &lt;code&gt;on&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="253b2ab3ed8967081995487ba9ee5b4826393d61" translate="yes" xml:space="preserve">
          <source>This and other array operators are further described in &lt;a href=&quot;functions-array&quot;&gt;Section 9.18&lt;/a&gt;. It can be accelerated by an appropriate index, as described in &lt;a href=&quot;indexes-types&quot;&gt;Section 11.2&lt;/a&gt;.</source>
          <target state="translated">这个和其他数组运算符将在&lt;a href=&quot;functions-array&quot;&gt;9.18节&lt;/a&gt;中进一步描述。如&lt;a href=&quot;indexes-types&quot;&gt;第11.2节&lt;/a&gt;所述，可以通过适当的索引来加速它。</target>
        </trans-unit>
        <trans-unit id="a81f0db3b04480fe75e2e180f22423d163b36314" translate="yes" xml:space="preserve">
          <source>This and other array operators are further described in &lt;a href=&quot;functions-array&quot;&gt;Section 9.19&lt;/a&gt;. It can be accelerated by an appropriate index, as described in &lt;a href=&quot;indexes-types&quot;&gt;Section 11.2&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;functions-array&quot;&gt;第9.19节&lt;/a&gt;中将进一步描述此数组运算符和其他数组运算符。如&lt;a href=&quot;indexes-types&quot;&gt;第11.2节&lt;/a&gt;所述，可以通过适当的索引来加速它。</target>
        </trans-unit>
        <trans-unit id="22f7125f90456e96d69dc4420ff05c41c76b48ac" translate="yes" xml:space="preserve">
          <source>This authentication method operates similarly to &lt;code&gt;password&lt;/code&gt; except that it uses BSD Authentication to verify the password. BSD Authentication is used only to validate user name/password pairs. Therefore the user's role must already exist in the database before BSD Authentication can be used for authentication. The BSD Authentication framework is currently only available on OpenBSD.</source>
          <target state="translated">除了使用BSD身份验证来验证 &lt;code&gt;password&lt;/code&gt; 外，此身份验证方法的操作与密码类似。BSD身份验证仅用于验证用户名/密码对。因此，在将BSD身份验证用于身份验证之前，用户角色必须已经存在于数据库中。BSD身份验证框架当前仅在OpenBSD上可用。</target>
        </trans-unit>
        <trans-unit id="b4a95a1004ec8979c4ed272cc869cffc8b380262" translate="yes" xml:space="preserve">
          <source>This authentication method operates similarly to &lt;code&gt;password&lt;/code&gt; except that it uses LDAP as the password verification method. LDAP is used only to validate the user name/password pairs. Therefore the user must already exist in the database before LDAP can be used for authentication.</source>
          <target state="translated">除了使用LDAP作为密码验证方法之外，此身份验证方法的操作与 &lt;code&gt;password&lt;/code&gt; 类似。LDAP仅用于验证用户名/密码对。因此，用户必须已经存在于数据库中，然后才能使用LDAP进行身份验证。</target>
        </trans-unit>
        <trans-unit id="14894f744e61a4d997e0bd55d2f4134698e24251" translate="yes" xml:space="preserve">
          <source>This authentication method operates similarly to &lt;code&gt;password&lt;/code&gt; except that it uses PAM (Pluggable Authentication Modules) as the authentication mechanism. The default PAM service name is &lt;code&gt;postgresql&lt;/code&gt;. PAM is used only to validate user name/password pairs and optionally the connected remote host name or IP address. Therefore the user must already exist in the database before PAM can be used for authentication. For more information about PAM, please read the &lt;a href=&quot;https://www.kernel.org/pub/linux/libs/pam/&quot;&gt;Linux-PAM Page&lt;/a&gt;.</source>
          <target state="translated">除了使用PAM（可插入身份验证模块）作为身份验证机制外，此身份验证方法的操作与 &lt;code&gt;password&lt;/code&gt; 类似。PAM服务的默认名称是 &lt;code&gt;postgresql&lt;/code&gt; 。PAM仅用于验证用户名/密码对以及可选的已连接远程主机名或IP地址。因此，用户必须已经存在于数据库中，然后才能使用PAM进行身份验证。有关PAM的更多信息，请阅读&lt;a href=&quot;https://www.kernel.org/pub/linux/libs/pam/&quot;&gt;Linux-PAM页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ebd397f0c1d27e7e6f24266e4663491230029a1f" translate="yes" xml:space="preserve">
          <source>This authentication method operates similarly to &lt;code&gt;password&lt;/code&gt; except that it uses RADIUS as the password verification method. RADIUS is used only to validate the user name/password pairs. Therefore the user must already exist in the database before RADIUS can be used for authentication.</source>
          <target state="translated">除了使用RADIUS作为密码验证方法之外，此身份验证方法的操作与 &lt;code&gt;password&lt;/code&gt; 类似。 RADIUS仅用于验证用户名/密码对。因此，用户必须已经存在于数据库中，然后才能使用RADIUS进行身份验证。</target>
        </trans-unit>
        <trans-unit id="699ba79710348057cae6bc38a6f4967f7fef3d56" translate="yes" xml:space="preserve">
          <source>This authentication method uses SSL client certificates to perform authentication. It is therefore only available for SSL connections. When using this authentication method, the server will require that the client provide a valid, trusted certificate. No password prompt will be sent to the client. The &lt;code&gt;cn&lt;/code&gt; (Common Name) attribute of the certificate will be compared to the requested database user name, and if they match the login will be allowed. User name mapping can be used to allow &lt;code&gt;cn&lt;/code&gt; to be different from the database user name.</source>
          <target state="translated">此身份验证方法使用SSL客户端证书执行身份验证。因此，它仅适用于SSL连接。使用此身份验证方法时，服务器将要求客户端提供有效的可信证书。没有密码提示将发送给客户端。证书的 &lt;code&gt;cn&lt;/code&gt; （公用名）属性将与请求的数据库用户名进行比较，如果匹配，则允许登录。用户名映射可用于允许 &lt;code&gt;cn&lt;/code&gt; 与数据库用户名不同。</target>
        </trans-unit>
        <trans-unit id="5ac6c0054ced8ebe81d0f1a02772b68633401dc6" translate="yes" xml:space="preserve">
          <source>This behavior is desirable since it allows searches to work for both the whole compound word and for components. Here is another instructive example:</source>
          <target state="translated">这种行为是可取的,因为它允许对整个复合词和组件进行搜索。下面是另一个有指导意义的例子。</target>
        </trans-unit>
        <trans-unit id="286f6e80e06ffd51f385da7d2a7694b40cc44231" translate="yes" xml:space="preserve">
          <source>This can be convenient to be able to use operating-system-independent collation names in applications.</source>
          <target state="translated">这可以方便在应用程序中使用与操作系统无关的整理名。</target>
        </trans-unit>
        <trans-unit id="2cb2c31cd20a3afc74e461bc50ba20daffd3b134" translate="yes" xml:space="preserve">
          <source>This can be implemented quite efficiently by GiST indexes, but not by GIN indexes.</source>
          <target state="translated">这可以通过GiST索引相当有效地实现,但不能通过GIN索引实现。</target>
        </trans-unit>
        <trans-unit id="30c9965536e9eb1807b9625445e1dc9ee486d49c" translate="yes" xml:space="preserve">
          <source>This can be implemented quite efficiently by GiST indexes, but not by GIN indexes. It will usually beat the first formulation when only a small number of the closest matches is wanted.</source>
          <target state="translated">这可以通过GiST索引相当有效地实现,但不能通过GIN索引实现。当只需要少量最接近的匹配时,它通常会优于第一个公式。</target>
        </trans-unit>
        <trans-unit id="b19d203036cf7d45dfab0c4ad82ce10183e0940c" translate="yes" xml:space="preserve">
          <source>This can very quickly delete millions of records because it doesn't have to individually delete every record. Note however that the above command requires taking an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock on the parent table.</source>
          <target state="translated">由于不必单独删除每条记录，因此可以很快删除数百万条记录。但是请注意，以上命令要求对父表进行 &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; 锁定。</target>
        </trans-unit>
        <trans-unit id="b3706a06d88bffe054b5b4e9ba07c3a2f69517db" translate="yes" xml:space="preserve">
          <source>This catalog only contains tables known to the subscription after running either &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; or &lt;code&gt;ALTER SUBSCRIPTION ... REFRESH PUBLICATION&lt;/code&gt;.</source>
          <target state="translated">在运行 &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; 或 &lt;code&gt;ALTER SUBSCRIPTION ... REFRESH PUBLICATION&lt;/code&gt; 之后，此目录仅包含预订已知的表。</target>
        </trans-unit>
        <trans-unit id="c00511a06e3429d3e3c63e91ce19e3a4e9397cad" translate="yes" xml:space="preserve">
          <source>This chapter explains the interface between the core PostgreSQL system and &lt;em&gt;table access methods&lt;/em&gt;, which manage the storage for tables. The core system knows little about these access methods beyond what is specified here, so it is possible to develop entirely new access method types by writing add-on code.</source>
          <target state="translated">本章介绍了核心PostgreSQL系统和&lt;em&gt;表访问方法&lt;/em&gt;之间的接口，该&lt;em&gt;方法&lt;/em&gt;管理表的存储。除了此处指定的内容外，核心系统对这些访问方法一无所知，因此可以通过编写附加代码来开发全新的访问方法类型。</target>
        </trans-unit>
        <trans-unit id="3bbb8116ccc75f5eb2a80776b0a4003df51db1c5" translate="yes" xml:space="preserve">
          <source>This chapter provides an overview of how to use SQL to perform simple operations. This tutorial is only intended to give you an introduction and is in no way a complete tutorial on SQL. Numerous books have been written on SQL, including &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#MELT93&quot;&gt;[melt93]&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#DATE97&quot;&gt;[date97]&lt;/a&gt;. You should be aware that some PostgreSQL language features are extensions to the standard.</source>
          <target state="translated">本章概述了如何使用SQL执行简单的操作。本教程仅用于向您介绍，绝不是关于SQL的完整教程。关于SQL的书籍很多，包括&lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#MELT93&quot;&gt;[melt93]&lt;/a&gt;和&lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#DATE97&quot;&gt;[date97]&lt;/a&gt;。您应该知道，某些PostgreSQL语言功能是该标准的扩展。</target>
        </trans-unit>
        <trans-unit id="8dae2bfb234e1cafffdc1445672c01cdceebec98" translate="yes" xml:space="preserve">
          <source>This chapter provides an overview of how to use SQL to perform simple operations. This tutorial is only intended to give you an introduction and is in no way a complete tutorial on SQL. Numerous books have been written on SQL, including &lt;a href=&quot;https://www.postgresql.org/docs/13/biblio.html#MELT93&quot;&gt;[melt93]&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/13/biblio.html#DATE97&quot;&gt;[date97]&lt;/a&gt;. You should be aware that some PostgreSQL language features are extensions to the standard.</source>
          <target state="translated">本章概述了如何使用SQL执行简单的操作。本教程仅用于向您介绍，绝不是关于SQL的完整教程。关于SQL的书籍很多，包括&lt;a href=&quot;https://www.postgresql.org/docs/13/biblio.html#MELT93&quot;&gt;[melt93]&lt;/a&gt;和&lt;a href=&quot;https://www.postgresql.org/docs/13/biblio.html#DATE97&quot;&gt;[date97]&lt;/a&gt;。您应该知道，某些PostgreSQL语言功能是该标准的扩展。</target>
        </trans-unit>
        <trans-unit id="d4bef49f81ca7b2b6c1d960ddeae062fa5602386" translate="yes" xml:space="preserve">
          <source>This chapter will on occasion refer to examples found in &lt;a href=&quot;https://www.postgresql.org/docs/12/tutorial-sql.html&quot;&gt;Chapter 2&lt;/a&gt; to change or improve them, so it will be useful to have read that chapter. Some examples from this chapter can also be found in &lt;code&gt;advanced.sql&lt;/code&gt; in the tutorial directory. This file also contains some sample data to load, which is not repeated here. (Refer to &lt;a href=&quot;tutorial-sql-intro&quot;&gt;Section 2.1&lt;/a&gt; for how to use the file.)</source>
          <target state="translated">本章有时会参考&lt;a href=&quot;https://www.postgresql.org/docs/12/tutorial-sql.html&quot;&gt;第2章中的&lt;/a&gt;示例以更改或改进它们，因此阅读该章将很有用。本章中的一些示例也可以在tutorial目录中的 &lt;code&gt;advanced.sql&lt;/code&gt; 中找到。该文件还包含一些要加载的样本数据，这里不再赘述。（有关如何使用该文件，请参阅&lt;a href=&quot;tutorial-sql-intro&quot;&gt;第2.1节&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="dabed7c214422d3752d4d13e0c2a45b4ba36ecbe" translate="yes" xml:space="preserve">
          <source>This chapter will on occasion refer to examples found in &lt;a href=&quot;https://www.postgresql.org/docs/13/tutorial-sql.html&quot;&gt;Chapter 2&lt;/a&gt; to change or improve them, so it will be useful to have read that chapter. Some examples from this chapter can also be found in &lt;code&gt;advanced.sql&lt;/code&gt; in the tutorial directory. This file also contains some sample data to load, which is not repeated here. (Refer to &lt;a href=&quot;tutorial-sql-intro&quot;&gt;Section 2.1&lt;/a&gt; for how to use the file.)</source>
          <target state="translated">本章有时会参考&lt;a href=&quot;https://www.postgresql.org/docs/13/tutorial-sql.html&quot;&gt;第2章中的&lt;/a&gt;示例以进行更改或改进，因此阅读该章将非常有用。本章中的一些示例也可以在tutorial目录中的 &lt;code&gt;advanced.sql&lt;/code&gt; 中找到。该文件还包含一些要加载的样本数据，这里不再赘述。（有关如何使用该文件，请参阅&lt;a href=&quot;tutorial-sql-intro&quot;&gt;第2.1节&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="b05316eb335b74f7f1d96b694767ed937c7a73d2" translate="yes" xml:space="preserve">
          <source>This clause allows selection of the tablespace in which the index associated with a &lt;code&gt;UNIQUE&lt;/code&gt;, &lt;code&gt;PRIMARY KEY&lt;/code&gt;, or &lt;code&gt;EXCLUDE&lt;/code&gt; constraint will be created. If not specified, &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; is consulted, or &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt; if the table is temporary.</source>
          <target state="translated">该子句允许选择将在其中创建与 &lt;code&gt;UNIQUE&lt;/code&gt; ， &lt;code&gt;PRIMARY KEY&lt;/code&gt; 或 &lt;code&gt;EXCLUDE&lt;/code&gt; 约束关联的索引的表空间。如果未指定，则查询&lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt;，如果表是临时表，则&lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;查询temp_tablespaces&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9a22b296ec30545018cebf2ee6b84bbc440b4d2a" translate="yes" xml:space="preserve">
          <source>This clause alters parameters originally set by &lt;a href=&quot;sql-createsubscription&quot;&gt;CREATE SUBSCRIPTION&lt;/a&gt;. See there for more information. The allowed options are &lt;code&gt;slot_name&lt;/code&gt; and &lt;code&gt;synchronous_commit&lt;/code&gt;</source>
          <target state="translated">此子句更改最初由&lt;a href=&quot;sql-createsubscription&quot;&gt;CREATE SUBSCRIPTION&lt;/a&gt;设置的参数。有关更多信息，请参见此处。允许的选项是 &lt;code&gt;slot_name&lt;/code&gt; 和 &lt;code&gt;synchronous_commit&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9dde9dc06154fb93b57360e4813d2af30753235f" translate="yes" xml:space="preserve">
          <source>This clause alters publication parameters originally set by &lt;a href=&quot;sql-createpublication&quot;&gt;CREATE PUBLICATION&lt;/a&gt;. See there for more information.</source>
          <target state="translated">此子句更改最初由&lt;a href=&quot;sql-createpublication&quot;&gt;CREATE PUBLICATION&lt;/a&gt;设置的发布参数。有关更多信息，请参见此处。</target>
        </trans-unit>
        <trans-unit id="3a47a54fa61280e2ffdfce9d2640b5d9bb858deb" translate="yes" xml:space="preserve">
          <source>This clause alters the connection property originally set by &lt;a href=&quot;sql-createsubscription&quot;&gt;CREATE SUBSCRIPTION&lt;/a&gt;. See there for more information.</source>
          <target state="translated">此子句更改最初由&lt;a href=&quot;sql-createsubscription&quot;&gt;CREATE SUBSCRIPTION&lt;/a&gt;设置的连接属性。有关更多信息，请参见此处。</target>
        </trans-unit>
        <trans-unit id="5d2fcb8e278e1a72c6a053d69e9530239790d3c7" translate="yes" xml:space="preserve">
          <source>This clause creates the column as a &lt;em&gt;generated column&lt;/em&gt;. The column cannot be written to, and when read the result of the specified expression will be returned.</source>
          <target state="translated">此子句将列创建为&lt;em&gt;生成的列&lt;/em&gt;。该列无法写入，并且在读取时将返回指定表达式的结果。</target>
        </trans-unit>
        <trans-unit id="cd8eb7a6eec884310b19db2fe89fcdaa447cc6e8" translate="yes" xml:space="preserve">
          <source>This clause creates the column as an &lt;em&gt;identity column&lt;/em&gt;. It will have an implicit sequence attached to it and the column in new rows will automatically have values from the sequence assigned to it.</source>
          <target state="translated">此子句将列创建为&lt;em&gt;标识列&lt;/em&gt;。它将附加一个隐式序列，并且新行中的列将自动具有分配给它的序列中的值。</target>
        </trans-unit>
        <trans-unit id="da05955831bd605d103f99ab7132a00a6b982439" translate="yes" xml:space="preserve">
          <source>This clause indicates whether the following relation name is for the before-image transition relation or the after-image transition relation.</source>
          <target state="translated">这个子句表示下面的关系名是用于图像前过渡关系还是图像后过渡关系。</target>
        </trans-unit>
        <trans-unit id="deddf49266216fee17210941a2dbf2f328be5ca2" translate="yes" xml:space="preserve">
          <source>This clause is only intended for compatibility with nonstandard SQL databases. Its use is discouraged in new applications.</source>
          <target state="translated">这个子句只是为了与非标准SQL数据库兼容。不鼓励在新的应用中使用该条款。</target>
        </trans-unit>
        <trans-unit id="41393a74e45a6c0a80ff1bb273dd882f889e0a0f" translate="yes" xml:space="preserve">
          <source>This clause is only provided for compatibility with non-standard SQL databases. Its use is discouraged in new applications.</source>
          <target state="translated">这个子句只是为了与非标准SQL数据库兼容而提供的。不鼓励在新的应用中使用该条款。</target>
        </trans-unit>
        <trans-unit id="22cd0887432e6ccdc3a45b9fc77bdb8214571dbc" translate="yes" xml:space="preserve">
          <source>This clause is useful for example when copying values between tables. Writing &lt;code&gt;INSERT INTO tbl2 OVERRIDING USER VALUE SELECT * FROM tbl1&lt;/code&gt; will copy from &lt;code&gt;tbl1&lt;/code&gt; all columns that are not identity columns in &lt;code&gt;tbl2&lt;/code&gt; while values for the identity columns in &lt;code&gt;tbl2&lt;/code&gt; will be generated by the sequences associated with &lt;code&gt;tbl2&lt;/code&gt;.</source>
          <target state="translated">例如，在表之间复制值时，此子句很有用。写作 &lt;code&gt;INSERT INTO tbl2 OVERRIDING USER VALUE SELECT * FROM tbl1&lt;/code&gt; 将复制 &lt;code&gt;tbl1&lt;/code&gt; 不在标识列所有列 &lt;code&gt;tbl2&lt;/code&gt; 的，而在标识列值 &lt;code&gt;tbl2&lt;/code&gt; 将通过与相关的序列产生 &lt;code&gt;tbl2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3c4ccb1be36e739cedb50d44f85c522aa002c906" translate="yes" xml:space="preserve">
          <source>This clause specifies optional parameters for a publication. The following parameters are supported:</source>
          <target state="translated">该子句指定了出版物的可选参数。支持以下参数:</target>
        </trans-unit>
        <trans-unit id="0ab7a0e0c831da17344263c723c33e3ad9e5583a" translate="yes" xml:space="preserve">
          <source>This clause specifies optional parameters for a subscription. The following parameters are supported:</source>
          <target state="translated">该子句指定了订阅的可选参数。支持以下参数:</target>
        </trans-unit>
        <trans-unit id="501055417d1a99c1021f58bb4344fd42a1fc3dfa" translate="yes" xml:space="preserve">
          <source>This clause specifies optional parameters for a view; the following parameters are supported:</source>
          <target state="translated">该子句指定了视图的可选参数,支持以下参数。</target>
        </trans-unit>
        <trans-unit id="959992a100adc135a448ff56a939c7cb03335c38" translate="yes" xml:space="preserve">
          <source>This clause specifies optional storage parameters for a table or index; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt; below for more information. For backward-compatibility the &lt;code&gt;WITH&lt;/code&gt; clause for a table can also include &lt;code&gt;OIDS=FALSE&lt;/code&gt; to specify that rows of the new table should not contain OIDs (object identifiers), &lt;code&gt;OIDS=TRUE&lt;/code&gt; is not supported anymore.</source>
          <target state="translated">此子句为表或索引指定可选的存储参数。有关更多信息，请参见下面的&lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;存储参数&lt;/a&gt;。为了向后兼容，表的 &lt;code&gt;WITH&lt;/code&gt; 子句还可以包含 &lt;code&gt;OIDS=FALSE&lt;/code&gt; ,以指定新表的行不应包含OID（对象标识符），现在不再支持 &lt;code&gt;OIDS=TRUE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="53e5726eff7272a0b43b9a8622a25a1a4b88715e" translate="yes" xml:space="preserve">
          <source>This clause specifies optional storage parameters for a table or index; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt; for more information. For backward-compatibility the &lt;code&gt;WITH&lt;/code&gt; clause for a table can also include &lt;code&gt;OIDS=FALSE&lt;/code&gt; to specify that rows of the new table should not contain OIDs (object identifiers), &lt;code&gt;OIDS=TRUE&lt;/code&gt; is not supported anymore.</source>
          <target state="translated">此子句为表或索引指定可选的存储参数。有关更多信息，请参见&lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;存储参数&lt;/a&gt;。为了实现向后兼容，表的 &lt;code&gt;WITH&lt;/code&gt; 子句还可以包含 &lt;code&gt;OIDS=FALSE&lt;/code&gt; ,以指定新表的行不应包含OID（对象标识符），现在不再支持 &lt;code&gt;OIDS=TRUE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e37f3a174a386383c959a305d30ae15361d5fa2" translate="yes" xml:space="preserve">
          <source>This clause specifies optional storage parameters for the new materialized view; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt; for more information. All parameters supported for &lt;code&gt;CREATE TABLE&lt;/code&gt; are also supported for &lt;code&gt;CREATE MATERIALIZED VIEW&lt;/code&gt;. See &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for more information.</source>
          <target state="translated">此子句为新的实例化视图指定可选的存储参数。有关更多信息，请参见&lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;存储参数&lt;/a&gt;。 &lt;code&gt;CREATE MATERIALIZED VIEW&lt;/code&gt; 也支持 &lt;code&gt;CREATE TABLE&lt;/code&gt; 支持的所有参数。有关更多信息，请参见&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="207b4757c66805d303f77232d29f374adc4dd287" translate="yes" xml:space="preserve">
          <source>This clause specifies optional storage parameters for the new materialized view; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt; in the &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; documentation for more information. All parameters supported for &lt;code&gt;CREATE TABLE&lt;/code&gt; are also supported for &lt;code&gt;CREATE MATERIALIZED VIEW&lt;/code&gt;. See &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for more information.</source>
          <target state="translated">此子句为新的实例化视图指定了可选的存储参数。有关更多信息，请参见&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;文档中的&lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt;。 &lt;code&gt;CREATE MATERIALIZED VIEW&lt;/code&gt; 也支持 &lt;code&gt;CREATE TABLE&lt;/code&gt; 支持的所有参数。有关更多信息，请参见&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="afd2349edcbad3293d90a1b82afea4e43718f802" translate="yes" xml:space="preserve">
          <source>This clause specifies optional storage parameters for the new table; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt; for more information. For backward-compatibility the &lt;code&gt;WITH&lt;/code&gt; clause for a table can also include &lt;code&gt;OIDS=FALSE&lt;/code&gt; to specify that rows of the new table should contain no OIDs (object identifiers), &lt;code&gt;OIDS=TRUE&lt;/code&gt; is not supported anymore.</source>
          <target state="translated">此子句为新表指定了可选的存储参数。有关更多信息，请参见&lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;存储参数&lt;/a&gt;。为了向后兼容，表的 &lt;code&gt;WITH&lt;/code&gt; 子句还可以包含 &lt;code&gt;OIDS=FALSE&lt;/code&gt; ,以指定新表的行不应包含OID（对象标识符），现在不再支持 &lt;code&gt;OIDS=TRUE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e578543445bd0cc923dce66a8dfdd41602ac897b" translate="yes" xml:space="preserve">
          <source>This clause specifies optional storage parameters for the new table; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt; in the &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; documentation for more information. For backward-compatibility the &lt;code&gt;WITH&lt;/code&gt; clause for a table can also include &lt;code&gt;OIDS=FALSE&lt;/code&gt; to specify that rows of the new table should contain no OIDs (object identifiers), &lt;code&gt;OIDS=TRUE&lt;/code&gt; is not supported anymore.</source>
          <target state="translated">此子句为新表指定了可选的存储参数。有关更多信息，请参见&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;文档中的&lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt;。为了向后兼容，表的 &lt;code&gt;WITH&lt;/code&gt; 子句还可以包含 &lt;code&gt;OIDS=FALSE&lt;/code&gt; ,以指定新表的行不应包含OID（对象标识符），现在不再支持 &lt;code&gt;OIDS=TRUE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b9cf336be30ceb53b3db8168b3e8c1bdee3f553" translate="yes" xml:space="preserve">
          <source>This clause specifies options for the new foreign-data wrapper. The allowed option names and values are specific to each foreign data wrapper and are validated using the foreign-data wrapper's validator function. Option names must be unique.</source>
          <target state="translated">这个子句指定了新的外来数据包装器的选项。允许的选项名称和值是每个 foreign data wrapper 所特有的,并使用 foreign data wrapper 的 validator 函数进行验证。选项名必须是唯一的。</target>
        </trans-unit>
        <trans-unit id="3f504297f50fca952ddee9289f583252aaad16be" translate="yes" xml:space="preserve">
          <source>This clause specifies the options for the server. The options typically define the connection details of the server, but the actual names and values are dependent on the server's foreign-data wrapper.</source>
          <target state="translated">这个子句指定了服务器的选项。这些选项通常定义了服务器的连接细节,但实际的名称和值取决于服务器的外来数据封装器。</target>
        </trans-unit>
        <trans-unit id="553dd348cb64862c6f6c7f8e200b08ad63014f0b" translate="yes" xml:space="preserve">
          <source>This clause specifies the options of the user mapping. The options typically define the actual user name and password of the mapping. Option names must be unique. The allowed option names and values are specific to the server's foreign-data wrapper.</source>
          <target state="translated">该子句指定了用户映射的选项。选项通常定义映射的实际用户名和密码。选项名必须是唯一的。允许的选项名和值是特定于服务器的对外数据封装器的。</target>
        </trans-unit>
        <trans-unit id="36dc1042b746c18fc663603f39f06075d4e8bad1" translate="yes" xml:space="preserve">
          <source>This clause specifies the type of access method to define. Only &lt;code&gt;TABLE&lt;/code&gt; and &lt;code&gt;INDEX&lt;/code&gt; are supported at present.</source>
          <target state="translated">此子句指定要定义的访问方法的类型。目前仅支持 &lt;code&gt;TABLE&lt;/code&gt; 和 &lt;code&gt;INDEX&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7c9f34db6e75577cfa3e83dbdc6bf919fff89f9" translate="yes" xml:space="preserve">
          <source>This clause specifies whether or not the data produced by the query should be copied into the new table. If not, only the table structure is copied. The default is to copy the data.</source>
          <target state="translated">该子句指定是否要将查询产生的数据复制到新表中。如果不复制,则只复制表结构。默认情况下是复制数据。</target>
        </trans-unit>
        <trans-unit id="3d31ed888cfee0dc08f120a78ae32fb1759c0983" translate="yes" xml:space="preserve">
          <source>This clause specifies whether or not the materialized view should be populated at creation time. If not, the materialized view will be flagged as unscannable and cannot be queried until &lt;code&gt;REFRESH MATERIALIZED VIEW&lt;/code&gt; is used.</source>
          <target state="translated">此子句指定在创建时是否应填充实例化视图。如果不是这样，则在使用&amp;ldquo; &lt;code&gt;REFRESH MATERIALIZED VIEW&lt;/code&gt; 之前，实例化视图将被标记为无法扫描，并且无法查询。</target>
        </trans-unit>
        <trans-unit id="d4795183bcf13c08ef4cb630d8902e21d5cf34ce" translate="yes" xml:space="preserve">
          <source>This color specification format is also used by other software packages such as GCC, GNU coreutils, and GNU grep.</source>
          <target state="translated">这种颜色规格格式也被其他软件包使用,如GCC、GNU coreutils和GNU grep。</target>
        </trans-unit>
        <trans-unit id="2dc6ac474993dbe5358c6881853df7fd2d4d9cd6" translate="yes" xml:space="preserve">
          <source>This column has a default expression or generation expression, in which case there will be a corresponding entry in the &lt;code&gt;pg_attrdef&lt;/code&gt; catalog that actually defines the expression. (Check &lt;code&gt;attgenerated&lt;/code&gt; to determine whether this is a default or a generation expression.)</source>
          <target state="translated">该列具有默认表达式或生成表达式，在这种情况下， &lt;code&gt;pg_attrdef&lt;/code&gt; 目录中将有一个相应的条目实际定义了该表达式。（检查 &lt;code&gt;attgenerated&lt;/code&gt; 确定这是默认表达式还是生成表达式。）</target>
        </trans-unit>
        <trans-unit id="c2b7e0b12551b63f994a3beb30fdb6c9912fa294" translate="yes" xml:space="preserve">
          <source>This column has a one element array containing the value used when the column is entirely missing from the row, as happens when the column is added with a non-volatile &lt;code&gt;DEFAULT&lt;/code&gt; value after the row is created. The value is only used when &lt;code&gt;atthasmissing&lt;/code&gt; is true. If there is no value the column is null.</source>
          <target state="translated">该列具有一个元素数组，其中包含当该行完全缺失该列时使用的值，例如在创建该行后向该列添加非易失性 &lt;code&gt;DEFAULT&lt;/code&gt; 值时会发生这种情况。仅当 &lt;code&gt;atthasmissing&lt;/code&gt; 为true 时才使用该值。如果没有值，则该列为空。</target>
        </trans-unit>
        <trans-unit id="35ff62cc51341f34bf3df6fe15f16224e9f0ba2a" translate="yes" xml:space="preserve">
          <source>This column has a value which is used where the column is entirely missing from the row, as happens when a column is added with a non-volatile &lt;code&gt;DEFAULT&lt;/code&gt; value after the row is created. The actual value used is stored in the &lt;code&gt;attmissingval&lt;/code&gt; column.</source>
          <target state="translated">该列具有一个值，用于在该行完全缺失的情况下使用的值，例如，在创建行之后添加具有非易失性 &lt;code&gt;DEFAULT&lt;/code&gt; 值的列时会发生这种情况。使用的实际值存储在 &lt;code&gt;attmissingval&lt;/code&gt; 列中。</target>
        </trans-unit>
        <trans-unit id="111e19fea7f4514da864aef92d2fd3831ac7425b" translate="yes" xml:space="preserve">
          <source>This column has been dropped and is no longer valid. A dropped column is still physically present in the table, but is ignored by the parser and so cannot be accessed via SQL.</source>
          <target state="translated">此列已被删除,不再有效。被删除的列仍然实际存在于表中,但被解析器忽略,因此不能通过SQL访问。</target>
        </trans-unit>
        <trans-unit id="b598ea81d21dfda8a3cd60afd34a658bae3f5740" translate="yes" xml:space="preserve">
          <source>This column is defined locally in the relation. Note that a column can be locally defined and inherited simultaneously.</source>
          <target state="translated">这个列是在关系中本地定义的。请注意,一个列可以是本地定义的,也可以同时继承。</target>
        </trans-unit>
        <trans-unit id="699529a66bde15ad8ad9a32706a761c81f8ea245" translate="yes" xml:space="preserve">
          <source>This command acquires a &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; lock.</source>
          <target state="translated">此命令获取 &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; 锁定。</target>
        </trans-unit>
        <trans-unit id="ace2f59fb68bc1a8e1f61640a30167ef3925c24d" translate="yes" xml:space="preserve">
          <source>This command adds the &lt;code&gt;user.postgres&lt;/code&gt; project and sets the shared memory maximum for the &lt;code&gt;postgres&lt;/code&gt; user to 8GB, and takes effect the next time that user logs in, or when you restart PostgreSQL (not reload). The above assumes that PostgreSQL is run by the &lt;code&gt;postgres&lt;/code&gt; user in the &lt;code&gt;postgres&lt;/code&gt; group. No server reboot is required.</source>
          <target state="translated">此命令将添加 &lt;code&gt;user.postgres&lt;/code&gt; 项目，并将 &lt;code&gt;postgres&lt;/code&gt; 用户的最大共享内存设置为8GB，并在用户下次登录或重新启动PostgreSQL（不重新加载）时生效。以上假设PostgreSQL由 &lt;code&gt;postgres&lt;/code&gt; 组中的 &lt;code&gt;postgres&lt;/code&gt; 用户运行。无需重启服务器。</target>
        </trans-unit>
        <trans-unit id="7d0a3c8a461143dd6e79fdea4b574da1733f08aa" translate="yes" xml:space="preserve">
          <source>This command begins a new transaction block. If the isolation level, read/write mode, or deferrable mode is specified, the new transaction has those characteristics, as if &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt; was executed. This is the same as the &lt;a href=&quot;sql-begin&quot;&gt;BEGIN&lt;/a&gt; command.</source>
          <target state="translated">该命令开始一个新的事务块。如果指定了隔离级别，读/写模式或可延迟模式，则新事务具有那些特征，就像执行&lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION一样&lt;/a&gt;。这与&lt;a href=&quot;sql-begin&quot;&gt;BEGIN&lt;/a&gt;命令相同。</target>
        </trans-unit>
        <trans-unit id="62d4740f8d77efc3fe73e95e0f13203063c98ef5" translate="yes" xml:space="preserve">
          <source>This command can't be used to set &lt;a href=&quot;runtime-config-file-locations#GUC-DATA-DIRECTORY&quot;&gt;data_directory&lt;/a&gt;, nor parameters that are not allowed in &lt;code&gt;postgresql.conf&lt;/code&gt; (e.g., &lt;a href=&quot;runtime-config-preset&quot;&gt;preset options&lt;/a&gt;).</source>
          <target state="translated">此命令不能用于设置&lt;a href=&quot;runtime-config-file-locations#GUC-DATA-DIRECTORY&quot;&gt;data_directory&lt;/a&gt;，也不能用于设置 &lt;code&gt;postgresql.conf&lt;/code&gt; 中不允许的参数（例如，&lt;a href=&quot;runtime-config-preset&quot;&gt;预设选项&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="4e40f32b710aa4b5a2f3104aef12c4365c871f09" translate="yes" xml:space="preserve">
          <source>This command cannot be executed inside a transaction block. The prepared transaction is committed immediately.</source>
          <target state="translated">此命令不能在事务块内执行。准备好的事务会立即提交。</target>
        </trans-unit>
        <trans-unit id="20b731d4b786265bb5e3ab49dc8d1a8760feab6b" translate="yes" xml:space="preserve">
          <source>This command cannot be executed inside a transaction block. The prepared transaction is rolled back immediately.</source>
          <target state="translated">此命令不能在事务块内执行。准备好的交易会立即回滚。</target>
        </trans-unit>
        <trans-unit id="3a29d09c1029fd474b45e76bcdb5bbdf65bd3023" translate="yes" xml:space="preserve">
          <source>This command cannot be executed while connected to the target database. Thus, it might be more convenient to use the program &lt;a href=&quot;app-dropdb&quot;&gt;dropdb&lt;/a&gt; instead, which is a wrapper around this command.</source>
          <target state="translated">连接到目标数据库时无法执行此命令。因此，改用程序&lt;a href=&quot;app-dropdb&quot;&gt;dropdb&lt;/a&gt;可能更方便，该程序是此命令的包装。</target>
        </trans-unit>
        <trans-unit id="2e5d7b0191945449cf1438d09ec7519757af4913" translate="yes" xml:space="preserve">
          <source>This command complies with the behavior defined in the SQL standard, except for the limitation that, in PostgreSQL, it does not apply to &lt;code&gt;NOT NULL&lt;/code&gt; and &lt;code&gt;CHECK&lt;/code&gt; constraints. Also, PostgreSQL checks non-deferrable uniqueness constraints immediately, not at end of statement as the standard would suggest.</source>
          <target state="translated">除了在PostgreSQL中不适用于 &lt;code&gt;NOT NULL&lt;/code&gt; 和 &lt;code&gt;CHECK&lt;/code&gt; 约束的限制外，此命令符合SQL标准中定义的行为。另外，PostgreSQL会立即检查不可延展的唯一性约束，而不是在标准声明的结尾处检查。</target>
        </trans-unit>
        <trans-unit id="d38352e381f4c256e7b517b01e9b0ccd61de188e" translate="yes" xml:space="preserve">
          <source>This command conforms to ISO/IEC 9075-9 (SQL/MED), except that the standard only allows one foreign table to be dropped per command, and apart from the &lt;code&gt;IF EXISTS&lt;/code&gt; option, which is a PostgreSQL extension.</source>
          <target state="translated">该命令符合ISO / IEC 9075-9（SQL / MED），不同之处在于该标准仅允许每个命令删除一个外部表，并且 &lt;code&gt;IF EXISTS&lt;/code&gt; 选项是PostgreSQL的扩展。</target>
        </trans-unit>
        <trans-unit id="5b34603e56b93d743e26d620fe567201bf5d5d62" translate="yes" xml:space="preserve">
          <source>This command conforms to the ISO/IEC 9075-9 (SQL/MED), except that the standard only allows one foreign table to be dropped per command, and apart from the &lt;code&gt;IF EXISTS&lt;/code&gt; option, which is a PostgreSQL extension.</source>
          <target state="translated">该命令符合ISO / IEC 9075-9（SQL / MED），不同之处在于该标准仅允许每个命令删除一个外部表，并且 &lt;code&gt;IF EXISTS&lt;/code&gt; 选项是PostgreSQL扩展。</target>
        </trans-unit>
        <trans-unit id="8f1f85c735f1b71966f80b17247cbce182c5909a" translate="yes" xml:space="preserve">
          <source>This command conforms to the SQL standard, except for the &lt;code&gt;IF EXISTS&lt;/code&gt; option, which is a PostgreSQL extension.</source>
          <target state="translated">除了 &lt;code&gt;IF EXISTS&lt;/code&gt; 选项（它是PostgreSQL扩展）外，此命令符合SQL标准。</target>
        </trans-unit>
        <trans-unit id="468590b4d092b563617998d73f97b2171f1d8742" translate="yes" xml:space="preserve">
          <source>This command conforms to the SQL standard, except that the &lt;code&gt;FROM&lt;/code&gt; and &lt;code&gt;RETURNING&lt;/code&gt; clauses are PostgreSQL extensions, as is the ability to use &lt;code&gt;WITH&lt;/code&gt; with &lt;code&gt;UPDATE&lt;/code&gt;.</source>
          <target state="translated">该命令符合SQL标准，除了 &lt;code&gt;FROM&lt;/code&gt; 和 &lt;code&gt;RETURNING&lt;/code&gt; 子句是PostgreSQL扩展，以及将 &lt;code&gt;WITH&lt;/code&gt; 和 &lt;code&gt;UPDATE&lt;/code&gt; 一起使用的功能。</target>
        </trans-unit>
        <trans-unit id="bf1546d77c97dbe67b0ddd8982d22b8e55974688" translate="yes" xml:space="preserve">
          <source>This command conforms to the SQL standard, except that the &lt;code&gt;USING&lt;/code&gt; and &lt;code&gt;RETURNING&lt;/code&gt; clauses are PostgreSQL extensions, as is the ability to use &lt;code&gt;WITH&lt;/code&gt; with &lt;code&gt;DELETE&lt;/code&gt;.</source>
          <target state="translated">该命令符合SQL标准，除了 &lt;code&gt;USING&lt;/code&gt; 和 &lt;code&gt;RETURNING&lt;/code&gt; 子句是PostgreSQL扩展，以及 &lt;code&gt;WITH&lt;/code&gt; 和 &lt;code&gt;DELETE&lt;/code&gt; 一起使用的功能。</target>
        </trans-unit>
        <trans-unit id="681caf8270b9ecf7b205e0a60ad45b051b0e81dd" translate="yes" xml:space="preserve">
          <source>This command conforms to the SQL standard, except that the standard only allows one table to be dropped per command, and apart from the &lt;code&gt;IF EXISTS&lt;/code&gt; option, which is a PostgreSQL extension.</source>
          <target state="translated">该命令符合SQL标准，但该标准仅允许每个命令删除一个表，并且除了 &lt;code&gt;IF EXISTS&lt;/code&gt; 选项（它是PostgreSQL扩展）外。</target>
        </trans-unit>
        <trans-unit id="93af22491b168f8df3ca39363ea91881304542c1" translate="yes" xml:space="preserve">
          <source>This command conforms to the SQL standard, except that the standard only allows one view to be dropped per command, and apart from the &lt;code&gt;IF EXISTS&lt;/code&gt; option, which is a PostgreSQL extension.</source>
          <target state="translated">该命令符合SQL标准，但该标准仅允许每个命令删除一个视图，并且除了 &lt;code&gt;IF EXISTS&lt;/code&gt; 选项（PostgreSQL扩展）以外。</target>
        </trans-unit>
        <trans-unit id="4b31cc3350023fe9b74a561a1da0159f92b17624" translate="yes" xml:space="preserve">
          <source>This command conforms to the SQL standard, with these PostgreSQL extensions:</source>
          <target state="translated">这个命令符合SQL标准,并有这些PostgreSQL扩展。</target>
        </trans-unit>
        <trans-unit id="dabcb37ca2e8b2f56629a8b0fd30a7a18fcbfc70" translate="yes" xml:space="preserve">
          <source>This command conforms to the SQL standard. The standard specifies that the key word &lt;code&gt;SAVEPOINT&lt;/code&gt; is mandatory, but PostgreSQL allows it to be omitted.</source>
          <target state="translated">该命令符合SQL标准。该标准指定关键字 &lt;code&gt;SAVEPOINT&lt;/code&gt; 是必需的，但是PostgreSQL允许省略它。</target>
        </trans-unit>
        <trans-unit id="f1c4c1beba4d7959f48fbfa14fde82110587427a" translate="yes" xml:space="preserve">
          <source>This command displays the execution plan that the PostgreSQL planner generates for the supplied statement. The execution plan shows how the table(s) referenced by the statement will be scanned &amp;mdash; by plain sequential scan, index scan, etc. &amp;mdash; and if multiple tables are referenced, what join algorithms will be used to bring together the required rows from each input table.</source>
          <target state="translated">此命令显示PostgreSQL计划程序为提供的语句生成的执行计划。执行计划显示了如何扫描语句所引用的表（通过普通顺序扫描，索引扫描等），以及如果引用了多个表，将使用哪种联接算法将每个表中所需的行汇总在一起输入表。</target>
        </trans-unit>
        <trans-unit id="4333b1355b5818f99bd58b5b127214feda5e5493" translate="yes" xml:space="preserve">
          <source>This command fetches and edits the definition of the named function or procedure, in the form of a &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; or &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; command. Editing is done in the same way as for &lt;code&gt;\edit&lt;/code&gt;. After the editor exits, the updated command is executed immediately if you added a semicolon to it. Otherwise it is redisplayed; type semicolon or &lt;code&gt;\g&lt;/code&gt; to send it, or &lt;code&gt;\r&lt;/code&gt; to cancel.</source>
          <target state="translated">该命令以 &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; 或 &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; 命令的形式获取和编辑命名函数或过程的定义。编辑的方式与 &lt;code&gt;\edit&lt;/code&gt; 相同。编辑器退出后，如果您向其中添加了分号，则会立即执行更新的命令。否则，将重新显示它；否则，将重新显示它。键入分号或 &lt;code&gt;\g&lt;/code&gt; 发送，或 &lt;code&gt;\r&lt;/code&gt; 取消。</target>
        </trans-unit>
        <trans-unit id="8488cb1889e76b5a66add5218ab2ee79544199b3" translate="yes" xml:space="preserve">
          <source>This command fetches and edits the definition of the named function or procedure, in the form of a &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; or &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; command. Editing is done in the same way as for &lt;code&gt;\edit&lt;/code&gt;. After the editor exits, the updated command waits in the query buffer; type semicolon or &lt;code&gt;\g&lt;/code&gt; to send it, or &lt;code&gt;\r&lt;/code&gt; to cancel.</source>
          <target state="translated">该命令以 &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; 或 &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; 命令的形式获取和编辑命名函数或过程的定义。编辑的方式与 &lt;code&gt;\edit&lt;/code&gt; 相同。编辑器退出后，更新的命令在查询缓冲区中等待；输入分号或 &lt;code&gt;\g&lt;/code&gt; 发送，或 &lt;code&gt;\r&lt;/code&gt; 取消。</target>
        </trans-unit>
        <trans-unit id="f922604d6411c18a78b17a2c612a5b15141b9a3b" translate="yes" xml:space="preserve">
          <source>This command fetches and edits the definition of the named view, in the form of a &lt;code&gt;CREATE OR REPLACE VIEW&lt;/code&gt; command. Editing is done in the same way as for &lt;code&gt;\edit&lt;/code&gt;. After the editor exits, the updated command is executed immediately if you added a semicolon to it. Otherwise it is redisplayed; type semicolon or &lt;code&gt;\g&lt;/code&gt; to send it, or &lt;code&gt;\r&lt;/code&gt; to cancel.</source>
          <target state="translated">该命令以 &lt;code&gt;CREATE OR REPLACE VIEW&lt;/code&gt; 命令的形式获取并编辑命名视图的定义。编辑的方式与 &lt;code&gt;\edit&lt;/code&gt; 相同。编辑器退出后，如果您向其中添加了分号，则会立即执行更新的命令。否则，将重新显示它；否则，将重新显示它。键入分号或 &lt;code&gt;\g&lt;/code&gt; 发送，或 &lt;code&gt;\r&lt;/code&gt; 取消。</target>
        </trans-unit>
        <trans-unit id="bf69a2b293c399676b07c902a79f2f6947b772dc" translate="yes" xml:space="preserve">
          <source>This command fetches and edits the definition of the named view, in the form of a &lt;code&gt;CREATE OR REPLACE VIEW&lt;/code&gt; command. Editing is done in the same way as for &lt;code&gt;\edit&lt;/code&gt;. After the editor exits, the updated command waits in the query buffer; type semicolon or &lt;code&gt;\g&lt;/code&gt; to send it, or &lt;code&gt;\r&lt;/code&gt; to cancel.</source>
          <target state="translated">该命令以 &lt;code&gt;CREATE OR REPLACE VIEW&lt;/code&gt; 命令的形式获取和编辑命名视图的定义。编辑的方式与 &lt;code&gt;\edit&lt;/code&gt; 相同。编辑器退出后，更新的命令在查询缓冲区中等待；输入分号或 &lt;code&gt;\g&lt;/code&gt; 发送，或 &lt;code&gt;\r&lt;/code&gt; 取消。</target>
        </trans-unit>
        <trans-unit id="de8b3b98128e1d7cfa1ced8632fee4a04f5b0692" translate="yes" xml:space="preserve">
          <source>This command fetches and shows the definition of the named function or procedure, in the form of a &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; or &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; command. The definition is printed to the current query output channel, as set by &lt;code&gt;\o&lt;/code&gt;.</source>
          <target state="translated">该命令以 &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; 或 &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; 命令的形式获取并显示命名函数或过程的定义。该定义将打印到当前查询输出通道，由 &lt;code&gt;\o&lt;/code&gt; 设置。</target>
        </trans-unit>
        <trans-unit id="0c81c5ecf842f5babd90a21465ed15920d3fbf2d" translate="yes" xml:space="preserve">
          <source>This command fetches and shows the definition of the named view, in the form of a &lt;code&gt;CREATE OR REPLACE VIEW&lt;/code&gt; command. The definition is printed to the current query output channel, as set by &lt;code&gt;\o&lt;/code&gt;.</source>
          <target state="translated">该命令以 &lt;code&gt;CREATE OR REPLACE VIEW&lt;/code&gt; 命令的形式获取并显示命名视图的定义。该定义将打印到当前查询输出通道，由 &lt;code&gt;\o&lt;/code&gt; 设置。</target>
        </trans-unit>
        <trans-unit id="cd85d7e6ea3b73ffb02cb31a536b30a7bacab224" translate="yes" xml:space="preserve">
          <source>This command is a PostgreSQL extension present for historical reasons. &lt;code&gt;ROLLBACK&lt;/code&gt; is the equivalent standard SQL command.</source>
          <target state="translated">由于历史原因，此命令是PostgreSQL扩展。 &lt;code&gt;ROLLBACK&lt;/code&gt; 是等效的标准SQL命令。</target>
        </trans-unit>
        <trans-unit id="2845ceac7504cffef12e499b57f5339a71e8d823" translate="yes" xml:space="preserve">
          <source>This command is functionally similar to &lt;a href=&quot;sql-selectinto&quot;&gt;SELECT INTO&lt;/a&gt;, but it is preferred since it is less likely to be confused with other uses of the &lt;code&gt;SELECT INTO&lt;/code&gt; syntax. Furthermore, &lt;code&gt;CREATE TABLE AS&lt;/code&gt; offers a superset of the functionality offered by &lt;code&gt;SELECT INTO&lt;/code&gt;.</source>
          <target state="translated">该命令在功能上类似于&lt;a href=&quot;sql-selectinto&quot;&gt;SELECT INTO&lt;/a&gt;，但是它是首选的，因为它不太可能与 &lt;code&gt;SELECT INTO&lt;/code&gt; 语法的其他用法混淆。此外， &lt;code&gt;CREATE TABLE AS&lt;/code&gt; 提供了 &lt;code&gt;SELECT INTO&lt;/code&gt; 提供的功能的超集。</target>
        </trans-unit>
        <trans-unit id="4f51d7c5a1147247ad39d7dd8578e7109e7bd269" translate="yes" xml:space="preserve">
          <source>This command is identical to &lt;code&gt;\echo&lt;/code&gt; except that the output will be written to psql's standard error channel, rather than standard output.</source>
          <target state="translated">该命令与 &lt;code&gt;\echo&lt;/code&gt; 相同，除了输出将被写入psql的标准错误通道，而不是标准输出。</target>
        </trans-unit>
        <trans-unit id="1eebc2c2dfbb338f54847defda6bbbbd05da85aa" translate="yes" xml:space="preserve">
          <source>This command is identical to &lt;code&gt;\echo&lt;/code&gt; except that the output will be written to the query output channel, as set by &lt;code&gt;\o&lt;/code&gt;.</source>
          <target state="translated">该命令与 &lt;code&gt;\echo&lt;/code&gt; 相同，除了输出将被写入 &lt;code&gt;\o&lt;/code&gt; 设置的查询输出通道。</target>
        </trans-unit>
        <trans-unit id="c6b1eb8df7cef0a6e41f20fd61cbd76e26932fed" translate="yes" xml:space="preserve">
          <source>This command is similar to the corresponding command in the SQL standard, apart from the &lt;code&gt;IF EXISTS&lt;/code&gt; option, which is a PostgreSQL extension. But note that much of the &lt;code&gt;CREATE TYPE&lt;/code&gt; command and the data type extension mechanisms in PostgreSQL differ from the SQL standard.</source>
          <target state="translated">除了 &lt;code&gt;IF EXISTS&lt;/code&gt; 选项（它是PostgreSQL扩展）外，该命令与SQL标准中的相应命令相似。但是请注意，PostgreSQL 中的许多 &lt;code&gt;CREATE TYPE&lt;/code&gt; 命令和数据类型扩展机制与SQL标准不同。</target>
        </trans-unit>
        <trans-unit id="74399205e4f06569f7b7a41f319f8abd6da5004d" translate="yes" xml:space="preserve">
          <source>This command is unrelated to the SQL command &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt;.</source>
          <target state="translated">该命令与SQL命令&lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt;无关。</target>
        </trans-unit>
        <trans-unit id="017757db6d9507e6b7436f7a9ae4e2248893c3e8" translate="yes" xml:space="preserve">
          <source>This command loads a shared library file into the PostgreSQL server's address space. If the file has been loaded already, the command does nothing. Shared library files that contain C functions are automatically loaded whenever one of their functions is called. Therefore, an explicit &lt;code&gt;LOAD&lt;/code&gt; is usually only needed to load a library that modifies the server's behavior through &amp;ldquo;hooks&amp;rdquo; rather than providing a set of functions.</source>
          <target state="translated">此命令将共享库文件加载到PostgreSQL服务器的地址空间中。如果文件已经加载，则该命令不执行任何操作。每当调用包含C函数的共享库文件之一时，它们就会自动加载。因此，通常只需要显式 &lt;code&gt;LOAD&lt;/code&gt; 来加载通过&amp;ldquo;钩子&amp;rdquo;修改服务器行为的库，而不是提供一组功能。</target>
        </trans-unit>
        <trans-unit id="58fcb6c8246e8a6d76583723b04afe1b09a7d9c3" translate="yes" xml:space="preserve">
          <source>This command may be used to end SQL queries, taking the place of the terminating semicolon (&lt;code&gt;;&lt;/code&gt;).</source>
          <target state="translated">该命令可用于结束SQL查询，以代替分号（ &lt;code&gt;;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="677d2975d49fcc1351e4405fb4dd24f72ba0639a" translate="yes" xml:space="preserve">
          <source>This command must be used inside a transaction block. Use &lt;a href=&quot;sql-begin&quot;&gt;BEGIN&lt;/a&gt; to start one.</source>
          <target state="translated">此命令必须在事务块内使用。使用&lt;a href=&quot;sql-begin&quot;&gt;BEGIN&lt;/a&gt;开始。</target>
        </trans-unit>
        <trans-unit id="6b6b0df46bdea049004d95ff3514fc627c0bf758" translate="yes" xml:space="preserve">
          <source>This command must not be used when the server is running. &lt;code&gt;pg_resetwal&lt;/code&gt; will refuse to start up if it finds a server lock file in the data directory. If the server crashed then a lock file might have been left behind; in that case you can remove the lock file to allow &lt;code&gt;pg_resetwal&lt;/code&gt; to run. But before you do so, make doubly certain that there is no server process still alive.</source>
          <target state="translated">服务器正在运行时，不得使用此命令。 &lt;code&gt;pg_resetwal&lt;/code&gt; 在数据目录中找到服务器锁定文件，它将拒绝启动。如果服务器崩溃，则可能已留下锁定文件。在这种情况下，您可以删除锁定文件以允许 &lt;code&gt;pg_resetwal&lt;/code&gt; 运行。但是在您这样做之前，请先确保没有服务器进程仍在运行。</target>
        </trans-unit>
        <trans-unit id="71df21dcefbc6a0e13c7dad07c76dab173b26ca8" translate="yes" xml:space="preserve">
          <source>This command only alters the behavior of constraints within the current transaction. Issuing this outside of a transaction block emits a warning and otherwise has no effect.</source>
          <target state="translated">这条命令只改变当前事务中约束的行为。在事务块之外发布此命令会发出警告,否则没有任何效果。</target>
        </trans-unit>
        <trans-unit id="cd16c39418a0167a8c3018978b081238b82407a5" translate="yes" xml:space="preserve">
          <source>This command removes the procedural language &lt;code&gt;plsample&lt;/code&gt;:</source>
          <target state="translated">该命令删除过程语言 &lt;code&gt;plsample&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="13a5e5db6761174aa48d67b3836a7c44b067d9bd" translate="yes" xml:space="preserve">
          <source>This command removes the square root function:</source>
          <target state="translated">该命令删除了平方根函数。</target>
        </trans-unit>
        <trans-unit id="c8da0e72c154580e68779b6eda81a32e4cdad2c2" translate="yes" xml:space="preserve">
          <source>This command sets options affecting the output of query result tables. &lt;code&gt;option&lt;/code&gt; indicates which option is to be set. The semantics of &lt;code&gt;value&lt;/code&gt; vary depending on the selected option. For some options, omitting &lt;code&gt;value&lt;/code&gt; causes the option to be toggled or unset, as described under the particular option. If no such behavior is mentioned, then omitting &lt;code&gt;value&lt;/code&gt; just results in the current setting being displayed.</source>
          <target state="translated">此命令设置影响查询结果表输出的选项。 &lt;code&gt;option&lt;/code&gt; 指示要设置的选项。 &lt;code&gt;value&lt;/code&gt; 的语义取决于所选选项。对于某些选项，省略 &lt;code&gt;value&lt;/code&gt; 会导致该选项被切换或取消设置，如特定选项所述。如果未提及此类行为，则省略 &lt;code&gt;value&lt;/code&gt; 只会导致显示当前设置。</target>
        </trans-unit>
        <trans-unit id="55b80b7eaaaf7b41602e63f2f9f3e4efa523bee3" translate="yes" xml:space="preserve">
          <source>This command sets the current user identifier of the current SQL session to be &lt;code&gt;role_name&lt;/code&gt;. The role name can be written as either an identifier or a string literal. After &lt;code&gt;SET ROLE&lt;/code&gt;, permissions checking for SQL commands is carried out as though the named role were the one that had logged in originally.</source>
          <target state="translated">此命令将当前SQL会话的当前用户标识符设置为 &lt;code&gt;role_name&lt;/code&gt; 。角色名称可以写为标识符或字符串文字。在 &lt;code&gt;SET ROLE&lt;/code&gt; 之后，将执行SQL命令的权限检查，就好像命名角色是最初登录的角色一样。</target>
        </trans-unit>
        <trans-unit id="f7712990490e001a7ee650bc9d46804ef39e8a64" translate="yes" xml:space="preserve">
          <source>This command sets the session user identifier and the current user identifier of the current SQL session to be &lt;code&gt;user_name&lt;/code&gt;. The user name can be written as either an identifier or a string literal. Using this command, it is possible, for example, to temporarily become an unprivileged user and later switch back to being a superuser.</source>
          <target state="translated">此命令将会话用户标识符和当前SQL会话的当前用户标识符设置为 &lt;code&gt;user_name&lt;/code&gt; 。用户名可以写为标识符或字符串文字。使用此命令，例如，可以暂时成为非特权用户，然后再切换回为超级用户。</target>
        </trans-unit>
        <trans-unit id="7c9ce1414108a89726b8871ae0b54d84b052aa18" translate="yes" xml:space="preserve">
          <source>This command will fail if any of &lt;code&gt;hstore&lt;/code&gt;'s objects are in use in the database, for example if any tables have columns of the &lt;code&gt;hstore&lt;/code&gt; type. Add the &lt;code&gt;CASCADE&lt;/code&gt; option to forcibly remove those dependent objects as well.</source>
          <target state="translated">如果数据库中正在使用任何 &lt;code&gt;hstore&lt;/code&gt; 对象，则该命令将失败，例如，如果任何表具有 &lt;code&gt;hstore&lt;/code&gt; 类型的列。添加 &lt;code&gt;CASCADE&lt;/code&gt; 选项也可以强制删除那些从属对象。</target>
        </trans-unit>
        <trans-unit id="6b862ff106f276a9375de8c6aab656803f7a4efb" translate="yes" xml:space="preserve">
          <source>This command will free storage associated with the materialized view &lt;code&gt;annual_statistics_basis&lt;/code&gt; and leave it in an unscannable state:</source>
          <target state="translated">此命令将释放与 &lt;code&gt;annual_statistics_basis&lt;/code&gt; 化视图Annual_statistics_basis相关联的存储，并将其置于不可扫描的状态：</target>
        </trans-unit>
        <trans-unit id="6c9c73632173fe8b7637783ced8159d79d16ea65" translate="yes" xml:space="preserve">
          <source>This command will not succeed if there are any existing indexes that reference the configuration in &lt;code&gt;to_tsvector&lt;/code&gt; calls. Add &lt;code&gt;CASCADE&lt;/code&gt; to drop such indexes along with the text search configuration.</source>
          <target state="translated">如果有任何现有索引引用 &lt;code&gt;to_tsvector&lt;/code&gt; 调用中的配置，则此命令将不会成功。添加 &lt;code&gt;CASCADE&lt;/code&gt; 以删除此类索引以及文本搜索配置。</target>
        </trans-unit>
        <trans-unit id="9b7e8e631e47d7a2498f014c562d775f4aa922d4" translate="yes" xml:space="preserve">
          <source>This command will not succeed if there are any existing indexes that use operator classes within the family. Add &lt;code&gt;CASCADE&lt;/code&gt; to drop such indexes along with the operator family.</source>
          <target state="translated">如果族中有任何使用操作符类的现有索引，则此命令将不会成功。添加 &lt;code&gt;CASCADE&lt;/code&gt; 可以删除此类索引以及运算符系列。</target>
        </trans-unit>
        <trans-unit id="e344bd47bfc7344c009cae8df60f4f2d04ad7fee" translate="yes" xml:space="preserve">
          <source>This command will not succeed if there are any existing indexes that use the operator class. Add &lt;code&gt;CASCADE&lt;/code&gt; to drop such indexes along with the operator class.</source>
          <target state="translated">如果存在使用运算符类的现有索引，则此命令将不会成功。添加 &lt;code&gt;CASCADE&lt;/code&gt; 以删除此类索引以及运算符类。</target>
        </trans-unit>
        <trans-unit id="0a073ad25e0df8057b772f9939bb92486f83b429" translate="yes" xml:space="preserve">
          <source>This command will not succeed if there are any existing text search configurations that use the dictionary. Add &lt;code&gt;CASCADE&lt;/code&gt; to drop such configurations along with the dictionary.</source>
          <target state="translated">如果存在使用该词典的任何现有文本搜索配置，则此命令将不会成功。添加 &lt;code&gt;CASCADE&lt;/code&gt; 以删除此类配置以及字典。</target>
        </trans-unit>
        <trans-unit id="98b8a535bcfac2a0dbcd407ddbfe551b50e04749" translate="yes" xml:space="preserve">
          <source>This command will not succeed if there are any existing text search configurations that use the parser. Add &lt;code&gt;CASCADE&lt;/code&gt; to drop such configurations along with the parser.</source>
          <target state="translated">如果存在使用解析器的任何现有文本搜索配置，此命令将不会成功。添加 &lt;code&gt;CASCADE&lt;/code&gt; 可以将这些配置与解析器一起删除。</target>
        </trans-unit>
        <trans-unit id="9140e2324a0907c1e9782d65b5e3ea71a6d9655e" translate="yes" xml:space="preserve">
          <source>This command will not succeed if there are any existing text search dictionaries that use the template. Add &lt;code&gt;CASCADE&lt;/code&gt; to drop such dictionaries along with the template.</source>
          <target state="translated">如果存在任何使用该模板的文本搜索词典，则此命令将不会成功。添加 &lt;code&gt;CASCADE&lt;/code&gt; 可以将此类字典与模板一起删除。</target>
        </trans-unit>
        <trans-unit id="17f6112c2268ba0c9663f367e376afa3756d596b" translate="yes" xml:space="preserve">
          <source>This command will perform archiving when &lt;code&gt;/var/lib/pgsql/backup_in_progress&lt;/code&gt; exists, and otherwise silently return zero exit status (allowing PostgreSQL to recycle the unwanted WAL file).</source>
          <target state="translated">当存在 &lt;code&gt;/var/lib/pgsql/backup_in_progress&lt;/code&gt; 时，此命令将执行归档，否则以静默方式返回零退出状态（允许PostgreSQL回收不需要的WAL文件）。</target>
        </trans-unit>
        <trans-unit id="08ffbb1ab36d371eef7c290033c779142e12ec33" translate="yes" xml:space="preserve">
          <source>This command will remove the index &lt;code&gt;title_idx&lt;/code&gt;:</source>
          <target state="translated">该命令将删除索引 &lt;code&gt;title_idx&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2078fd2a1ddd7b0f72d80b8a3d0cc32c019e717f" translate="yes" xml:space="preserve">
          <source>This command will remove the materialized view called &lt;code&gt;order_summary&lt;/code&gt;:</source>
          <target state="translated">该命令将删除名为 &lt;code&gt;order_summary&lt;/code&gt; 的实例化视图：</target>
        </trans-unit>
        <trans-unit id="a242c77a8ccd56ddace9304e1ec3ea12442c9d59" translate="yes" xml:space="preserve">
          <source>This command will remove the view called &lt;code&gt;kinds&lt;/code&gt;:</source>
          <target state="translated">该命令将删除名为 &lt;code&gt;kinds&lt;/code&gt; 的视图：</target>
        </trans-unit>
        <trans-unit id="0d7ac7005486ff5a82c81e39d2a6985dcac07fb2" translate="yes" xml:space="preserve">
          <source>This command will replace the contents of the materialized view called &lt;code&gt;order_summary&lt;/code&gt; using the query from the materialized view's definition, and leave it in a scannable state:</source>
          <target state="translated">该命令将使用 &lt;code&gt;order_summary&lt;/code&gt; 化视图定义中的查询替换名为order_summary的实例化视图的内容，并将其置于可扫描状态：</target>
        </trans-unit>
        <trans-unit id="21fb41393a4eea96218c35f555df78b95eb06e38" translate="yes" xml:space="preserve">
          <source>This command will return a sample of 100 rows from the table &lt;code&gt;my_table&lt;/code&gt; (unless the table does not have 100 visible rows, in which case all its rows are returned).</source>
          <target state="translated">该命令将从表 &lt;code&gt;my_table&lt;/code&gt; 中返回100行的样本（除非该表没有100条可见行，在这种情况下将返回其所有行）。</target>
        </trans-unit>
        <trans-unit id="01ae94e8662537ac6716b276145364c5f4fb1046" translate="yes" xml:space="preserve">
          <source>This command will return as large a sample of &lt;code&gt;my_table&lt;/code&gt; as it can read in 1 second (1000 milliseconds). Of course, if the whole table can be read in under 1 second, all its rows will be returned.</source>
          <target state="translated">此命令将返回1秒（1000毫秒）内读取的 &lt;code&gt;my_table&lt;/code&gt; 样本。当然，如果可以在1秒内读取整个表，则将返回其所有行。</target>
        </trans-unit>
        <trans-unit id="8973f1428f19cf5f51d43ae902ba0ec839e24687" translate="yes" xml:space="preserve">
          <source>This command will work independent of whether &lt;code&gt;foo&lt;/code&gt; is an aggregate, function, or procedure.</source>
          <target state="translated">该命令将独立于 &lt;code&gt;foo&lt;/code&gt; 是聚合，函数还是过程而工作。</target>
        </trans-unit>
        <trans-unit id="8ac0fa233aac6a123e11329c2972c3833b6e69d2" translate="yes" xml:space="preserve">
          <source>This confirms there are 100 distinct combinations in the two columns, and all of them are about equally likely (1% frequency for each one). The base frequency is the frequency computed from per-column statistics, as if there were no multi-column statistics. Had there been any null values in either of the columns, this would be identified in the &lt;code&gt;nulls&lt;/code&gt; column.</source>
          <target state="translated">这证实了两列中有100种不同的组合，并且所有组合的可能性大致相同（每一种频率为1％）。基本频率是根据每列统计信息计算出的频率，就好像没有多列统计信息一样。如果任一列中都存在任何空值，则将在 &lt;code&gt;nulls&lt;/code&gt; 列中进行标识。</target>
        </trans-unit>
        <trans-unit id="a75759d2d2d52e1dc2865efa8cf2fb6090b3f128" translate="yes" xml:space="preserve">
          <source>This constant is a two-dimensional, 3-by-3 array consisting of three subarrays of integers.</source>
          <target state="translated">这个常数是由三个整数子数组组成的二维3乘3数组。</target>
        </trans-unit>
        <trans-unit id="a1d39be831b881f732286b6571d19294d43d84bf" translate="yes" xml:space="preserve">
          <source>This constraint is defined locally for the relation. It is a non-inheritable constraint.</source>
          <target state="translated">这个约束条件是为关系局部定义的。它是一个不可继承的约束条件。</target>
        </trans-unit>
        <trans-unit id="ee0fafaed69e2c50c035d4176a4d38521e63e5d6" translate="yes" xml:space="preserve">
          <source>This constraint is defined locally for the relation. Note that a constraint can be locally defined and inherited simultaneously.</source>
          <target state="translated">这个约束是为关系局部定义的。请注意,一个约束可以是本地定义的,也可以同时继承。</target>
        </trans-unit>
        <trans-unit id="677137c6fdb574fcaee9a2f495faececc7604ba8" translate="yes" xml:space="preserve">
          <source>This construct is similar to a &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; row comparison, but it does not yield null for null inputs. Instead, any null value is considered unequal to (distinct from) any non-null value, and any two nulls are considered equal (not distinct). Thus the result will either be true or false, never null.</source>
          <target state="translated">此构造类似于 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 行比较，但对于空输入不会产生空值。取而代之的是，任何空值都被认为与任何非空值不相等（相异），并且任何两个空值都被视为相等（不相异）。因此结果将为true或false，从不为null。</target>
        </trans-unit>
        <trans-unit id="1020bde7bf73c7df63ce8acf0bfdb90bb93b7fcb" translate="yes" xml:space="preserve">
          <source>This construct is similar to a &lt;code&gt;=&lt;/code&gt; row comparison, but it does not yield null for null inputs. Instead, any null value is considered unequal to (distinct from) any non-null value, and any two nulls are considered equal (not distinct). Thus the result will always be either true or false, never null.</source>
          <target state="translated">此构造类似于 &lt;code&gt;=&lt;/code&gt; 行比较，但对于空输入不会产生空值。取而代之的是，任何空值都被认为与任何非空值不相等（相异），并且任何两个空值都被视为相等（不相异）。因此，结果将始终为true或false，从不为null。</target>
        </trans-unit>
        <trans-unit id="33a306bcfd5b03d8e762816f623417a83fd23a93" translate="yes" xml:space="preserve">
          <source>This controls how many pages or tuples of a single relation can be predicate-locked before the lock is promoted to covering the whole relation. Values greater than or equal to zero mean an absolute limit, while negative values mean &lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-TRANSACTION&quot;&gt;max_pred_locks_per_transaction&lt;/a&gt; divided by the absolute value of this setting. The default is -2, which keeps the behavior from previous versions of PostgreSQL. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">这控制在将锁提升为覆盖整个关系之前，可以断言锁定单个关系的页面或元组的数量。大于或等于零的值表示绝对限制，而负值表示&lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-TRANSACTION&quot;&gt;max_pred_locks_per_transaction&lt;/a&gt;除以此设置的绝对值。默认值为-2，它保持PostgreSQL早期版本的行为。该参数只能在 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件或服务器命令行中设置。</target>
        </trans-unit>
        <trans-unit id="37486631dcaede39c55161d228505d69d73e3e22" translate="yes" xml:space="preserve">
          <source>This controls how many rows on a single page can be predicate-locked before the lock is promoted to covering the whole page. The default is 2. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">这控制了在将锁提升为覆盖整个页面之前可以断言锁定单个页面上的多少行。缺省值为2。只能在 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件或服务器命令行中设置此参数。</target>
        </trans-unit>
        <trans-unit id="b8a7a6bb04de3147a65fe3e69e114d351a95bdd3" translate="yes" xml:space="preserve">
          <source>This controls whether a quote mark can be represented by &lt;code&gt;\'&lt;/code&gt; in a string literal. The preferred, SQL-standard way to represent a quote mark is by doubling it (&lt;code&gt;''&lt;/code&gt;) but PostgreSQL has historically also accepted &lt;code&gt;\'&lt;/code&gt;. However, use of &lt;code&gt;\'&lt;/code&gt; creates security risks because in some client character set encodings, there are multibyte characters in which the last byte is numerically equivalent to ASCII &lt;code&gt;\&lt;/code&gt;. If client-side code does escaping incorrectly then a SQL-injection attack is possible. This risk can be prevented by making the server reject queries in which a quote mark appears to be escaped by a backslash. The allowed values of &lt;code&gt;backslash_quote&lt;/code&gt; are &lt;code&gt;on&lt;/code&gt; (allow &lt;code&gt;\'&lt;/code&gt; always), &lt;code&gt;off&lt;/code&gt; (reject always), and &lt;code&gt;safe_encoding&lt;/code&gt; (allow only if client encoding does not allow ASCII &lt;code&gt;\&lt;/code&gt; within a multibyte character). &lt;code&gt;safe_encoding&lt;/code&gt; is the default setting.</source>
          <target state="translated">这控制引号是否可以由字符串文字中的 &lt;code&gt;\'&lt;/code&gt; 表示。优选的，SQL标准的方式来表示一个引号是通过加倍它（ &lt;code&gt;''&lt;/code&gt; ），但的PostgreSQL历来也接受 &lt;code&gt;\'&lt;/code&gt; 。但是，使用 &lt;code&gt;\'&lt;/code&gt; 会带来安全风险，因为在某些客户端字符集编码中，存在多字节字符，其中最后一个字节在数值上等效于ASCII &lt;code&gt;\&lt;/code&gt; 。如果客户端代码确实错误转义，则可能会发生SQL注入攻击。通过使服务器拒绝其中引号似乎被反斜杠转义的查询，可以避免这种风险。 &lt;code&gt;backslash_quote&lt;/code&gt; 的允许值已 &lt;code&gt;on&lt;/code&gt; （允许 &lt;code&gt;\'&lt;/code&gt; 始终）， &lt;code&gt;off&lt;/code&gt; （始终拒绝）和 &lt;code&gt;safe_encoding&lt;/code&gt; （仅当客户端编码在多字节字符内不允许ASCII &lt;code&gt;\&lt;/code&gt; 时才允许）。 &lt;code&gt;safe_encoding&lt;/code&gt; 是默认设置。</target>
        </trans-unit>
        <trans-unit id="90ccb11174fcbc5e0dcaecf5ce4057bc44c37e08" translate="yes" xml:space="preserve">
          <source>This controls whether ordinary string literals (&lt;code&gt;'...'&lt;/code&gt;) treat backslashes literally, as specified in the SQL standard. Beginning in PostgreSQL 9.1, the default is &lt;code&gt;on&lt;/code&gt; (prior releases defaulted to &lt;code&gt;off&lt;/code&gt;). Applications can check this parameter to determine how string literals will be processed. The presence of this parameter can also be taken as an indication that the escape string syntax (&lt;code&gt;E'...'&lt;/code&gt;) is supported. Escape string syntax (&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS-ESCAPE&quot;&gt;Section 4.1.2.2&lt;/a&gt;) should be used if an application desires backslashes to be treated as escape characters.</source>
          <target state="translated">这可以控制普通字符串文字（ &lt;code&gt;'...'&lt;/code&gt; ）是否按照SQL标准指定的方式按字面对待反斜杠。从PostgreSQL 9.1开始，默认设置为 &lt;code&gt;on&lt;/code&gt; （以前的版本默认为 &lt;code&gt;off&lt;/code&gt; ）。应用程序可以检查此参数以确定如何处理字符串文字。此参数的存在也可以用作表明支持转义字符串语法（ &lt;code&gt;E'...'&lt;/code&gt; ）。如果应用程序希望将反斜杠视为转义字符，则应使用转义字符串语法（&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS-ESCAPE&quot;&gt;第4.1.2.2节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="04ce8a3710d0e73d6eb9a44e5b7e7596e3b6ada8" translate="yes" xml:space="preserve">
          <source>This controls whether the array input parser recognizes unquoted &lt;code&gt;NULL&lt;/code&gt; as specifying a null array element. By default, this is &lt;code&gt;on&lt;/code&gt;, allowing array values containing null values to be entered. However, PostgreSQL versions before 8.2 did not support null values in arrays, and therefore would treat &lt;code&gt;NULL&lt;/code&gt; as specifying a normal array element with the string value &amp;ldquo;NULL&amp;rdquo;. For backward compatibility with applications that require the old behavior, this variable can be turned &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">这控制着数组输入解析器是否将未引用的 &lt;code&gt;NULL&lt;/code&gt; 识别为指定空数组元素。默认情况下为 &lt;code&gt;on&lt;/code&gt; ，允许输入包含空值的数组值。但是，PostgreSQL 8.2之前的版本不支持数组中的空值，因此会将 &lt;code&gt;NULL&lt;/code&gt; 视为使用字符串值&amp;ldquo; NULL&amp;rdquo;指定普通数组元素。为了与需要旧行为的应用程序向后兼容，可以 &lt;code&gt;off&lt;/code&gt; 此变量。</target>
        </trans-unit>
        <trans-unit id="a334bdaf5d7adfdeb7bdd6cc764b677eb1d1fc0d" translate="yes" xml:space="preserve">
          <source>This controls whether the constraint can be deferred. A constraint that is not deferrable will be checked immediately after every command. Checking of constraints that are deferrable can be postponed until the end of the transaction (using the &lt;a href=&quot;sql-set-constraints&quot;&gt;SET CONSTRAINTS&lt;/a&gt; command). &lt;code&gt;NOT DEFERRABLE&lt;/code&gt; is the default. Currently, only &lt;code&gt;UNIQUE&lt;/code&gt;, &lt;code&gt;PRIMARY KEY&lt;/code&gt;, &lt;code&gt;EXCLUDE&lt;/code&gt;, and &lt;code&gt;REFERENCES&lt;/code&gt; (foreign key) constraints accept this clause. &lt;code&gt;NOT NULL&lt;/code&gt; and &lt;code&gt;CHECK&lt;/code&gt; constraints are not deferrable. Note that deferrable constraints cannot be used as conflict arbitrators in an &lt;code&gt;INSERT&lt;/code&gt; statement that includes an &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clause.</source>
          <target state="translated">这控制是否可以推迟约束。在每个命令之后，将立即检查不可延迟的约束。可以推迟检查约束，直到事务结束为止（使用&lt;a href=&quot;sql-set-constraints&quot;&gt;SET CONSTRAINTS&lt;/a&gt;命令）。默认值是 &lt;code&gt;NOT DEFERRABLE&lt;/code&gt; 。当前，只有 &lt;code&gt;UNIQUE&lt;/code&gt; ， &lt;code&gt;PRIMARY KEY&lt;/code&gt; ， &lt;code&gt;EXCLUDE&lt;/code&gt; 和 &lt;code&gt;REFERENCES&lt;/code&gt; （外键）约束接受此子句。 &lt;code&gt;NOT NULL&lt;/code&gt; 和 &lt;code&gt;CHECK&lt;/code&gt; 约束不可延迟。请注意，可延迟约束不能在包含 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 的 &lt;code&gt;INSERT&lt;/code&gt; 语句中用作冲突仲裁程序。 条款。</target>
        </trans-unit>
        <trans-unit id="1918927d29af63f959f031de4a1383381d5530a7" translate="yes" xml:space="preserve">
          <source>This creates a security hazard when calling, via qualified name &lt;a href=&quot;#ftn.FUNC-QUALIFIED-SECURITY&quot;&gt;&lt;sup id=&quot;FUNC-QUALIFIED-SECURITY&quot;&gt;[10]&lt;/sup&gt;&lt;/a&gt;, a variadic function found in a schema that permits untrusted users to create objects. A malicious user can take control and execute arbitrary SQL functions as though you executed them. Substitute a call bearing the &lt;code&gt;VARIADIC&lt;/code&gt; keyword, which bypasses this hazard. Calls populating &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; parameters often have no equivalent formulation containing the &lt;code&gt;VARIADIC&lt;/code&gt; keyword. To issue those calls safely, the function's schema must permit only trusted users to create objects.</source>
          <target state="translated">当通过限定名称&lt;a href=&quot;#ftn.FUNC-QUALIFIED-SECURITY&quot;&gt;&lt;sup id=&quot;FUNC-QUALIFIED-SECURITY&quot;&gt;[10]&lt;/sup&gt;&lt;/a&gt;调用在架构中发现的可变参数函数时，这会造成安全隐患，该模式允许不受信任的用户创建对象。恶意用户可以控制并执行任意SQL函数，就像执行它们一样。替换带有 &lt;code&gt;VARIADIC&lt;/code&gt; 关键字的呼叫，该呼叫将绕过此危险。填充 &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; 参数的调用通常没有包含 &lt;code&gt;VARIADIC&lt;/code&gt; 关键字的等效公式。为了安全地发出这些调用，函数的架构必须仅允许受信任的用户创建对象。</target>
        </trans-unit>
        <trans-unit id="0046336b7276ca25c455594eb1a8ba81761391eb" translate="yes" xml:space="preserve">
          <source>This creates a security hazard when calling, via qualified name &lt;a href=&quot;#ftn.FUNC-QUALIFIED-SECURITY&quot;&gt;&lt;sup id=&quot;FUNC-QUALIFIED-SECURITY&quot;&gt;[9]&lt;/sup&gt;&lt;/a&gt;, a variadic function found in a schema that permits untrusted users to create objects. A malicious user can take control and execute arbitrary SQL functions as though you executed them. Substitute a call bearing the &lt;code&gt;VARIADIC&lt;/code&gt; keyword, which bypasses this hazard. Calls populating &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; parameters often have no equivalent formulation containing the &lt;code&gt;VARIADIC&lt;/code&gt; keyword. To issue those calls safely, the function's schema must permit only trusted users to create objects.</source>
          <target state="translated">当通过限定名称&lt;a href=&quot;#ftn.FUNC-QUALIFIED-SECURITY&quot;&gt;&lt;sup id=&quot;FUNC-QUALIFIED-SECURITY&quot;&gt;[9]&lt;/sup&gt;&lt;/a&gt;调用在架构中发现的可变参数函数时，这会造成安全隐患，该模式允许不受信任的用户创建对象。恶意用户可以控制并执行任意SQL函数，就像执行它们一样。替换带有 &lt;code&gt;VARIADIC&lt;/code&gt; 关键字的呼叫，该呼叫将绕过此危险。填充 &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; 参数的调用通常没有包含 &lt;code&gt;VARIADIC&lt;/code&gt; 关键字的等效公式。为了安全地发出这些调用，函数的架构必须仅允许受信任的用户创建对象。</target>
        </trans-unit>
        <trans-unit id="d12540189cdbd640895d38788f65f9fbba1d76fa" translate="yes" xml:space="preserve">
          <source>This creates a table named &lt;code&gt;my_first_table&lt;/code&gt; with two columns. The first column is named &lt;code&gt;first_column&lt;/code&gt; and has a data type of &lt;code&gt;text&lt;/code&gt;; the second column has the name &lt;code&gt;second_column&lt;/code&gt; and the type &lt;code&gt;integer&lt;/code&gt;. The table and column names follow the identifier syntax explained in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-IDENTIFIERS&quot;&gt;Section 4.1.1&lt;/a&gt;. The type names are usually also identifiers, but there are some exceptions. Note that the column list is comma-separated and surrounded by parentheses.</source>
          <target state="translated">这将创建一个名为 &lt;code&gt;my_first_table&lt;/code&gt; 的表，该表具有两列。第一列名为 &lt;code&gt;first_column&lt;/code&gt; 并具有 &lt;code&gt;text&lt;/code&gt; 数据类型;第二列的名称为 &lt;code&gt;second_column&lt;/code&gt; ，类型为 &lt;code&gt;integer&lt;/code&gt; 。表和列的名称遵循&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-IDENTIFIERS&quot;&gt;4.1.1节中&lt;/a&gt;解释的标识符语法。类型名称通常也是标识符，但是有一些例外。请注意，列列表用逗号分隔，并用括号括起来。</target>
        </trans-unit>
        <trans-unit id="2df112a8a7b40124ef90c403fdef2c5ff1577746" translate="yes" xml:space="preserve">
          <source>This creates an availability hazard when calling, via qualified name&lt;a href=&quot;typeconv-func#ftn.FUNC-QUALIFIED-SECURITY&quot;&gt;&lt;sup&gt;[10]&lt;/sup&gt;&lt;/a&gt;, any function found in a schema that permits untrusted users to create objects. A malicious user can create a function with the name of an existing function, replicating that function's parameters and appending novel parameters having default values. This precludes new calls to the original function. To forestall this hazard, place functions in schemas that permit only trusted users to create objects.</source>
          <target state="translated">通过合格名称&lt;a href=&quot;typeconv-func#ftn.FUNC-QUALIFIED-SECURITY&quot;&gt;&lt;sup&gt;[10]&lt;/sup&gt;&lt;/a&gt;调用架构中允许不信任用户创建对象的任何函数时，这会造成可用性危害。恶意用户可以使用现有功能的名称创建功能，复制该功能的参数并附加具有默认值的新颖参数。这排除了对原始函数的新调用。为了避免这种危险，请将函数放置在仅允许受信任用户创建对象的架构中。</target>
        </trans-unit>
        <trans-unit id="a732ec34a93086b562c56c901a996da67bed793b" translate="yes" xml:space="preserve">
          <source>This creates an availability hazard when calling, via qualified name&lt;a href=&quot;typeconv-func#ftn.FUNC-QUALIFIED-SECURITY&quot;&gt;&lt;sup&gt;[9]&lt;/sup&gt;&lt;/a&gt;, any function found in a schema that permits untrusted users to create objects. A malicious user can create a function with the name of an existing function, replicating that function's parameters and appending novel parameters having default values. This precludes new calls to the original function. To forestall this hazard, place functions in schemas that permit only trusted users to create objects.</source>
          <target state="translated">通过合格名称&lt;a href=&quot;typeconv-func#ftn.FUNC-QUALIFIED-SECURITY&quot;&gt;&lt;sup&gt;[9]&lt;/sup&gt;&lt;/a&gt;调用架构中允许不信任用户创建对象的任何函数时，这会造成可用性危害。恶意用户可以使用现有功能的名称创建功能，复制该功能的参数并附加具有默认值的新颖参数。这排除了对原始函数的新调用。为了防止这种危险，请将函数放置在仅允许受信任的用户创建对象的模式中。</target>
        </trans-unit>
        <trans-unit id="5fd08e31876bb0659f97fc74e6e81b5de962b395" translate="yes" xml:space="preserve">
          <source>This creates registry entries used by the event viewer, under the default event source named &lt;code&gt;PostgreSQL&lt;/code&gt;.</source>
          <target state="translated">这将在默认事件源 &lt;code&gt;PostgreSQL&lt;/code&gt; 下创建事件查看器使用的注册表项。</target>
        </trans-unit>
        <trans-unit id="a2f685ce47d5796c5b17ed2dc2e9f2a95a1be4cb" translate="yes" xml:space="preserve">
          <source>This creates the scripts and compiles the C files containing user-defined functions and types. Then, to start the tutorial, do the following:</source>
          <target state="translated">这将创建脚本并编译包含用户定义函数和类型的C文件。然后,开始教程,执行以下操作。</target>
        </trans-unit>
        <trans-unit id="d9b31e3f2055cca38cc6b689ae9fad52cab29160" translate="yes" xml:space="preserve">
          <source>This design allows for both backwards-compatible header additions (add header extension chunks, or set low-order flag bits) and non-backwards-compatible changes (set high-order flag bits to signal such changes, and add supporting data to the extension area if needed).</source>
          <target state="translated">这种设计既允许向后兼容的报头添加(添加报头扩展块,或设置低阶标志位),也允许非向后兼容的更改(设置高阶标志位来表示这种更改,如果需要,还可以向扩展区添加支持数据)。</target>
        </trans-unit>
        <trans-unit id="d1507a2d26ed6cd13d8f06661be29be45050cd21" translate="yes" xml:space="preserve">
          <source>This dictionary template is used to create dictionaries that replace a word with a synonym. Phrases are not supported (use the thesaurus template (&lt;a href=&quot;textsearch-dictionaries#TEXTSEARCH-THESAURUS&quot;&gt;Section 12.6.4&lt;/a&gt;) for that). A synonym dictionary can be used to overcome linguistic problems, for example, to prevent an English stemmer dictionary from reducing the word &amp;ldquo;Paris&amp;rdquo; to &amp;ldquo;pari&amp;rdquo;. It is enough to have a &lt;code&gt;Paris paris&lt;/code&gt; line in the synonym dictionary and put it before the &lt;code&gt;english_stem&lt;/code&gt; dictionary. For example:</source>
          <target state="translated">该词典模板用于创建词典，以同义词代替单词。不支持短语（为此使用同义词库模板（&lt;a href=&quot;textsearch-dictionaries#TEXTSEARCH-THESAURUS&quot;&gt;第12.6.4节&lt;/a&gt;））。同义词词典可用于克服语言问题，例如，防止英语词干词典将单词&amp;ldquo; Paris&amp;rdquo;简化为&amp;ldquo; pari&amp;rdquo;。在同义词词典中有一条 &lt;code&gt;Paris paris&lt;/code&gt; 行并将其放在 &lt;code&gt;english_stem&lt;/code&gt; 词典之前就足够了。例如：</target>
        </trans-unit>
        <trans-unit id="dfab7a227af58e60167bfee0ac87d5907b3ad3ee" translate="yes" xml:space="preserve">
          <source>This document answers frequently asked questions about SELinux. It focuses primarily on Fedora, but is not limited to Fedora.</source>
          <target state="translated">本文档回答了关于SELinux的常见问题。它主要侧重于Fedora,但不限于Fedora。</target>
        </trans-unit>
        <trans-unit id="64f99dd7f4a8868a1752a291c897889c1028116d" translate="yes" xml:space="preserve">
          <source>This document provides a wide spectrum of knowledge to administer SELinux on your systems. It focuses primarily on Red Hat operating systems, but is not limited to them.</source>
          <target state="translated">本文档提供了在你的系统上管理SELinux的广泛知识。它主要侧重于Red Hat操作系统,但并不限于这些系统。</target>
        </trans-unit>
        <trans-unit id="d69a24fba08d14e58aa301ec18364f049dd9f435" translate="yes" xml:space="preserve">
          <source>This does not prevent cleanup of dead rows which have reached the age specified by &lt;code&gt;old_snapshot_threshold&lt;/code&gt;.</source>
          <target state="translated">这不会阻止清除已达到 &lt;code&gt;old_snapshot_threshold&lt;/code&gt; 指定的期限的无效行。</target>
        </trans-unit>
        <trans-unit id="34a33c8e067844a10adc4d1ec87dc8f9bed7f940" translate="yes" xml:space="preserve">
          <source>This does not work because &lt;code&gt;integer&lt;/code&gt; does not have an implicit cast to &lt;code&gt;text&lt;/code&gt;. An explicit cast will work, however:</source>
          <target state="translated">这不起作用，因为 &lt;code&gt;integer&lt;/code&gt; 没有对 &lt;code&gt;text&lt;/code&gt; 的隐式转换。显式强制转换将起作用，但是：</target>
        </trans-unit>
        <trans-unit id="f8a11325d581fd69da8d48499eb1dc3e0e55ab89" translate="yes" xml:space="preserve">
          <source>This equivalence between functional notation and field notation makes it possible to use functions on composite types to implement &amp;ldquo;computed fields&amp;rdquo;.   An application using the last query above wouldn't need to be directly aware that &lt;code&gt;somefunc&lt;/code&gt; isn't a real column of the table.</source>
          <target state="translated">功能符号和字段符号之间的等效关系使得可以使用复合类型上的函数来实现&amp;ldquo;计算字段&amp;rdquo;。使用上面最后一个查询的应用程序不需要直接知道 &lt;code&gt;somefunc&lt;/code&gt; 不是表的真实列。</target>
        </trans-unit>
        <trans-unit id="cf34fbb91a15c4b2d08b406f2026ab198cd22a33" translate="yes" xml:space="preserve">
          <source>This evaluates query on document and wraps the result in XML tags. If the result is multivalued, the output will look like:</source>
          <target state="translated">它对文档的查询进行评估,并将结果包装在XML标签中。如果结果是多值的,则输出结果会像这样。</target>
        </trans-unit>
        <trans-unit id="15ced5262cfea0d7c224d2d14022b915ded0c9bb" translate="yes" xml:space="preserve">
          <source>This example creates a composite type and uses it in a function definition:</source>
          <target state="translated">这个例子创建了一个复合类型并在函数定义中使用它。</target>
        </trans-unit>
        <trans-unit id="fd20b024051cecf699f47d6601ef377cbbceb783" translate="yes" xml:space="preserve">
          <source>This example creates a large object type and uses it in a table definition:</source>
          <target state="translated">这个例子创建了一个大型对象类型,并在表定义中使用它。</target>
        </trans-unit>
        <trans-unit id="81988155ae08cfd1bb03bda3f7e767cd1d1e7982" translate="yes" xml:space="preserve">
          <source>This example creates a range type:</source>
          <target state="translated">这个例子创建了一个范围类型。</target>
        </trans-unit>
        <trans-unit id="29a86563a51e3572dd14a9d9255eda3ebb2201cc" translate="yes" xml:space="preserve">
          <source>This example creates an enumerated type and uses it in a table definition:</source>
          <target state="translated">这个例子创建了一个枚举类型,并在表定义中使用它。</target>
        </trans-unit>
        <trans-unit id="e15c416b1eb4a6e0ac422253fe9d7c571e4e1d98" translate="yes" xml:space="preserve">
          <source>This example creates the &lt;code&gt;us_postal_code&lt;/code&gt; data type and then uses the type in a table definition. A regular expression test is used to verify that the value looks like a valid US postal code:</source>
          <target state="translated">本示例创建 &lt;code&gt;us_postal_code&lt;/code&gt; 数据类型，然后在表定义中使用该类型。正则表达式测试用于验证该值看起来像是有效的美国邮政编码：</target>
        </trans-unit>
        <trans-unit id="824e6c2d218cfa4fc262bbf54ecefd33c7e0d65c" translate="yes" xml:space="preserve">
          <source>This example creates the base data type &lt;code&gt;box&lt;/code&gt; and then uses the type in a table definition:</source>
          <target state="translated">本示例创建基础数据类型 &lt;code&gt;box&lt;/code&gt; ，然后在表定义中使用该类型：</target>
        </trans-unit>
        <trans-unit id="434cf5265b6621f51d3d3b20b1a695bea28ca57d" translate="yes" xml:space="preserve">
          <source>This example for Unix systems sets the locale to Swedish (&lt;code&gt;sv&lt;/code&gt;) as spoken in Sweden (&lt;code&gt;SE&lt;/code&gt;). Other possibilities might include &lt;code&gt;en_US&lt;/code&gt; (U.S. English) and &lt;code&gt;fr_CA&lt;/code&gt; (French Canadian). If more than one character set can be used for a locale then the specifications can take the form &lt;code&gt;language_territory.codeset&lt;/code&gt;. For example, &lt;code&gt;fr_BE.UTF-8&lt;/code&gt; represents the French language (fr) as spoken in Belgium (BE), with a UTF-8 character set encoding.</source>
          <target state="translated">Unix系统的此示例将地区设置为瑞典语（ &lt;code&gt;SE&lt;/code&gt; ）中所说的瑞典语（ &lt;code&gt;sv&lt;/code&gt; ）。其他可能性可能包括 &lt;code&gt;en_US&lt;/code&gt; （美国英语）和 &lt;code&gt;fr_CA&lt;/code&gt; （加拿大法语）。如果一个语言环境可以使用多个字符集，那么规范可以采用 &lt;code&gt;language_territory.codeset&lt;/code&gt; 的形式。例如， &lt;code&gt;fr_BE.UTF-8&lt;/code&gt; 表示比利时（BE）所说的法语（fr），具有UTF-8字符集编码。</target>
        </trans-unit>
        <trans-unit id="5b2c48d8838d3c1575e17a1f1c1bf4b1c54be443" translate="yes" xml:space="preserve">
          <source>This example inserts into array columns:</source>
          <target state="translated">这个例子插入到数组列中。</target>
        </trans-unit>
        <trans-unit id="42fa4c592cce0c22be8f54fb9056c02e69ce0496" translate="yes" xml:space="preserve">
          <source>This example inserts some rows into table &lt;code&gt;films&lt;/code&gt; from a table &lt;code&gt;tmp_films&lt;/code&gt; with the same column layout as &lt;code&gt;films&lt;/code&gt;:</source>
          <target state="translated">本示例从表 &lt;code&gt;tmp_films&lt;/code&gt; 中插入一些行到表 &lt;code&gt;films&lt;/code&gt; ，这些表具有与 &lt;code&gt;films&lt;/code&gt; 相同的列布局：</target>
        </trans-unit>
        <trans-unit id="a463d9dae9db43b670ea9503d31a0e368fa4ee70" translate="yes" xml:space="preserve">
          <source>This example is equivalent to &lt;code&gt;FROM table1 AS alias_name&lt;/code&gt;. More interesting cases, which cannot be reduced to a plain join, arise when the subquery involves grouping or aggregation.</source>
          <target state="translated">此示例等效于 &lt;code&gt;FROM table1 AS alias_name&lt;/code&gt; 。当子查询涉及分组或聚合时，会出现更有趣的情况，不能简化为普通联接。</target>
        </trans-unit>
        <trans-unit id="be1a5f2f3b699d99e46d29b68340b721327b27dd" translate="yes" xml:space="preserve">
          <source>This example is, of course, oversimplified, but there's a lot of control possible in a transaction block through the use of savepoints. Moreover, &lt;code&gt;ROLLBACK TO&lt;/code&gt; is the only way to regain control of a transaction block that was put in aborted state by the system due to an error, short of rolling it back completely and starting again.</source>
          <target state="translated">当然，此示例过于简化，但是通过使用保存点，可以在事务块中进行很多控制。此外， &lt;code&gt;ROLLBACK TO&lt;/code&gt; 是重新获得对由于错误而被系统置于中止状态的事务块的控制的唯一方法，因为它无法完全回滚并重新启动。</target>
        </trans-unit>
        <trans-unit id="a7b74712a2cd7143b58e55978ebc0a1e029aad05" translate="yes" xml:space="preserve">
          <source>This example produces a set something like:</source>
          <target state="translated">这个例子产生了一个类似的集合。</target>
        </trans-unit>
        <trans-unit id="bd0849ce5d2cb6e49bc1884469c044510632ded5" translate="yes" xml:space="preserve">
          <source>This example shows a session that performs verification of the 10 largest catalog indexes in the database &amp;ldquo;test&amp;rdquo;. Verification of the presence of heap tuples as index tuples is requested for the subset that are unique indexes. Since no error is raised, all indexes tested appear to be logically consistent. Naturally, this query could easily be changed to call &lt;code&gt;bt_index_check&lt;/code&gt; for every index in the database where verification is supported.</source>
          <target state="translated">此示例显示一个会话，该会话对数据库&amp;ldquo; test&amp;rdquo;中的10个最大目录索引执行验证。对于唯一索引的子集，要求验证堆元组作为索引元组的存在。由于不会引发错误，因此所有测试的索引在逻辑上似乎都是一致的。自然，可以轻松地将此查询更改为对支持验证的数据库中的每个索引调用 &lt;code&gt;bt_index_check&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="52eaa3c393eb8836501cf0b71b2390cbd556c111" translate="yes" xml:space="preserve">
          <source>This example shows how to use a function in the &lt;code&gt;FROM&lt;/code&gt; clause, both with and without a column definition list:</source>
          <target state="translated">此示例说明如何在 &lt;code&gt;FROM&lt;/code&gt; 子句中使用函数，无论是否具有列定义列表：</target>
        </trans-unit>
        <trans-unit id="faf001583d1938e7eac65338b42d5145eeba9d29" translate="yes" xml:space="preserve">
          <source>This example shows how to use a simple &lt;code&gt;WITH&lt;/code&gt; clause:</source>
          <target state="translated">此示例说明如何使用简单的 &lt;code&gt;WITH&lt;/code&gt; 子句：</target>
        </trans-unit>
        <trans-unit id="dd1b1ae7add544b9cdd447e36bf84ceb80a1e127" translate="yes" xml:space="preserve">
          <source>This example uses &lt;code&gt;LATERAL&lt;/code&gt; to apply a set-returning function &lt;code&gt;get_product_names()&lt;/code&gt; for each row of the &lt;code&gt;manufacturers&lt;/code&gt; table:</source>
          <target state="translated">此示例使用 &lt;code&gt;LATERAL&lt;/code&gt; 为 &lt;code&gt;manufacturers&lt;/code&gt; 表的每一行应用返回设置的函数 &lt;code&gt;get_product_names()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="36985cd8d425adbc4e1df7381c866befdc14c9f1" translate="yes" xml:space="preserve">
          <source>This example uses &lt;code&gt;ROWS FROM&lt;/code&gt;:</source>
          <target state="translated">本示例使用 &lt;code&gt;ROWS FROM&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0eba8d9892663515b6cc219ad20715d37c9c5396" translate="yes" xml:space="preserve">
          <source>This example uses &lt;code&gt;WITH RECURSIVE&lt;/code&gt; to find all subordinates (direct or indirect) of the employee Mary, and their level of indirectness, from a table that shows only direct subordinates:</source>
          <target state="translated">本示例使用 &lt;code&gt;WITH RECURSIVE&lt;/code&gt; 从仅显示直接下属的表中查找员工Mary的所有下属（直接或间接）及其间接程度：</target>
        </trans-unit>
        <trans-unit id="625799a6daa4d3a32ad43aba61a387f19b4df04e" translate="yes" xml:space="preserve">
          <source>This example uses the &lt;code&gt;DEFAULT&lt;/code&gt; clause for the date columns rather than specifying a value:</source>
          <target state="translated">本示例对日期列使用 &lt;code&gt;DEFAULT&lt;/code&gt; 子句，而不是指定值：</target>
        </trans-unit>
        <trans-unit id="33b1cc724cf1f567bbb040ff9e9078c758235297" translate="yes" xml:space="preserve">
          <source>This example uses the following data (also available in file &lt;code&gt;contrib/ltree/ltreetest.sql&lt;/code&gt; in the source distribution):</source>
          <target state="translated">本示例使用以下数据（在源发行版的 &lt;code&gt;contrib/ltree/ltreetest.sql&lt;/code&gt; 文件中也可用）：</target>
        </trans-unit>
        <trans-unit id="4a2eb1d66444608a417cb7a2c5c2fded452498b8" translate="yes" xml:space="preserve">
          <source>This example would remove all rows from tables &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt;. The number of affected rows reported to the client would only include rows removed from &lt;code&gt;bar&lt;/code&gt;.</source>
          <target state="translated">本示例将从表 &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;bar&lt;/code&gt; 中删除所有行。向客户端报告的受影响的行数仅包括从 &lt;code&gt;bar&lt;/code&gt; 中删除的行。</target>
        </trans-unit>
        <trans-unit id="759fd9b05670f2874eee702f3df4de125c19d274" translate="yes" xml:space="preserve">
          <source>This example would use the standard Unicode collation in a nondeterministic way. In particular, this would allow strings in different normal forms to be compared correctly. More interesting examples make use of the ICU customization facilities explained above. For example:</source>
          <target state="translated">这个例子将以非确定性的方式使用标准的Unicode整理。特别是,这将允许正确地比较不同正常形式的字符串。更有趣的例子是利用上面解释的ICU自定义设施。例如</target>
        </trans-unit>
        <trans-unit id="a370e5d62e07be8745753fc6bbcb3e1a1d2437da" translate="yes" xml:space="preserve">
          <source>This expanded version of the previous query shows the operator family each operator class belongs to:</source>
          <target state="translated">此前查询的扩展版本显示了每个操作符类所属的操作符族。</target>
        </trans-unit>
        <trans-unit id="d891c30f21d694bab5f748d5f0b9dd9f8f629f4a" translate="yes" xml:space="preserve">
          <source>This expression returns the size of the track if it contains any segments with high heart rate values, or an empty sequence otherwise.</source>
          <target state="translated">如果轨道中包含任何具有高心率值的片段,则该表达式返回轨道的大小,否则为空序列。</target>
        </trans-unit>
        <trans-unit id="0d9bda9d80ab3b41fb483157cc1a94532dbac7fb" translate="yes" xml:space="preserve">
          <source>This expression yields true when two time periods (defined by their endpoints) overlap, false when they do not overlap. The endpoints can be specified as pairs of dates, times, or time stamps; or as a date, time, or time stamp followed by an interval. When a pair of values is provided, either the start or the end can be written first; &lt;code&gt;OVERLAPS&lt;/code&gt; automatically takes the earlier value of the pair as the start. Each time period is considered to represent the half-open interval &lt;code&gt;start&lt;/code&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;code&gt;time&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;end&lt;/code&gt;, unless &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are equal in which case it represents that single time instant. This means for instance that two time periods with only an endpoint in common do not overlap.</source>
          <target state="translated">当两个时间段（由它们的端点定义）重叠时，此表达式将产生true；当两个时间段不重叠时，该表达式将产生false。可以将端点指定为日期，时间或时间戳记对。或作为日期，时间或时间戳记，后跟一个间隔。提供一对值时，可以先写开始或结束。 &lt;code&gt;OVERLAPS&lt;/code&gt; 自动将对中的较早值作为开始。每个时间段均视为代表半开间隔 &lt;code&gt;start&lt;/code&gt; &lt;code&gt;&amp;lt;=&lt;/code&gt; &lt;code&gt;time&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;end&lt;/code&gt; ，除非 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;end&lt;/code&gt; 相等，在这种情况下，它代表那个单个时刻。例如，这意味着只有一个共同点的两个时间段不会重叠。</target>
        </trans-unit>
        <trans-unit id="c11b883111f39a35c0f589a7362884a445b2f9be" translate="yes" xml:space="preserve">
          <source>This extensibility should not be confused with the extensibility of the other standard search trees in terms of the data they can handle. For example, PostgreSQL supports extensible B-trees and hash indexes. That means that you can use PostgreSQL to build a B-tree or hash over any data type you want. But B-trees only support range predicates (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;), and hash indexes only support equality queries.</source>
          <target state="translated">就其可处理的数据而言，此可扩展性不应与其他标准搜索树的可扩展性混淆。例如，PostgreSQL支持可扩展的B树和哈希索引。这意味着您可以使用PostgreSQL在所需的任何数据类型上构建B树或哈希。但是B树仅支持范围谓词（ &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;=&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; ），而哈希索引仅支持相等查询。</target>
        </trans-unit>
        <trans-unit id="25249be2bc655571c6b319a5e05ab9bf57e7f0ce" translate="yes" xml:space="preserve">
          <source>This extension won't build at all unless the installation was configured with &lt;code&gt;--with-openssl&lt;/code&gt;.</source>
          <target state="translated">除非使用 &lt;code&gt;--with-openssl&lt;/code&gt; 配置安装，否则根本不会构建此扩展。</target>
        </trans-unit>
        <trans-unit id="985d874d57f888d6b7d33a42c3b39fe6c5d40324" translate="yes" xml:space="preserve">
          <source>This failure occurs because PostgreSQL treats multiple &lt;code&gt;UNION&lt;/code&gt;s as a nest of pairwise operations; that is, this input is the same as</source>
          <target state="translated">发生此失败的原因是PostgreSQL将多个 &lt;code&gt;UNION&lt;/code&gt; 视为成对操作的嵌套；也就是说，此输入与</target>
        </trans-unit>
        <trans-unit id="9dea5b639461b36e0d899f8204fb2b765c1a0fb6" translate="yes" xml:space="preserve">
          <source>This feature is disabled by default for manually issued &lt;code&gt;VACUUM&lt;/code&gt; commands. To enable it, set the &lt;code&gt;vacuum_cost_delay&lt;/code&gt; variable to a nonzero value.</source>
          <target state="translated">对于手动发出的 &lt;code&gt;VACUUM&lt;/code&gt; 命令，默认情况下禁用此功能。要启用它，请将 &lt;code&gt;vacuum_cost_delay&lt;/code&gt; 变量设置为非零值。</target>
        </trans-unit>
        <trans-unit id="7554d4b1db763d2db35742e4df9b2b6a631440fa" translate="yes" xml:space="preserve">
          <source>This feature is intended as a temporary measure until a complete solution is found. At that time, this option will be removed.</source>
          <target state="translated">在找到完整的解决方案之前,该功能是一项临时措施。届时,这一选项将被取消。</target>
        </trans-unit>
        <trans-unit id="37d4c1ac5e0b12c58cdf26713648d8dd1dfac571" translate="yes" xml:space="preserve">
          <source>This feature was designed to allow parameters not normally known to PostgreSQL to be added by add-on modules (such as procedural languages). This allows extension modules to be configured in the standard ways.</source>
          <target state="translated">这个功能是为了允许PostgreSQL通常不知道的参数被附加模块(如程序语言)添加。这使得扩展模块可以用标准的方式进行配置。</target>
        </trans-unit>
        <trans-unit id="c6d9b959196517fcbab35a6da62247fb2b91ad04" translate="yes" xml:space="preserve">
          <source>This feature was shamelessly plagiarized from Bash.</source>
          <target state="translated">本专题无耻地抄袭了Bash的内容。</target>
        </trans-unit>
        <trans-unit id="9dd0c7f9cb881f24c299dc7cd6acc6e93722283f" translate="yes" xml:space="preserve">
          <source>This feature was shamelessly plagiarized from tcsh.</source>
          <target state="translated">本专题无耻地抄袭了tcsh。</target>
        </trans-unit>
        <trans-unit id="195725685743f0dba93fa9e927faaeac64a5e891" translate="yes" xml:space="preserve">
          <source>This field is not available in PostgreSQL releases prior to 8.3.</source>
          <target state="translated">这个字段在8.3之前的PostgreSQL版本中是不可用的。</target>
        </trans-unit>
        <trans-unit id="6136f38c2e93a8910734e7b6cf3ef3cea4cdbf88" translate="yes" xml:space="preserve">
          <source>This field only applies to &lt;code&gt;host&lt;/code&gt;, &lt;code&gt;hostssl&lt;/code&gt;, and &lt;code&gt;hostnossl&lt;/code&gt; records.</source>
          <target state="translated">该字段仅适用于 &lt;code&gt;host&lt;/code&gt; ， &lt;code&gt;hostssl&lt;/code&gt; 和 &lt;code&gt;hostnossl&lt;/code&gt; 记录。</target>
        </trans-unit>
        <trans-unit id="1bb02774d9e01b5ecb4a1f9ea9a8d0284469c4dd" translate="yes" xml:space="preserve">
          <source>This flag does not behave identically to the &lt;code&gt;-t&lt;/code&gt; flag of pg_dump. There is not currently any provision for wild-card matching in pg_restore, nor can you include a schema name within its &lt;code&gt;-t&lt;/code&gt;. And, while pg_dump's &lt;code&gt;-t&lt;/code&gt; flag will also dump subsidiary objects (such as indexes) of the selected table(s), pg_restore's &lt;code&gt;-t&lt;/code&gt; flag does not include such subsidiary objects.</source>
          <target state="translated">该标志的行为不同于pg_dump 的 &lt;code&gt;-t&lt;/code&gt; 标志。pg_restore当前没有任何通配符匹配的规定，也不能在 &lt;code&gt;-t&lt;/code&gt; 中包含模式名称。并且，虽然pg_dump的 &lt;code&gt;-t&lt;/code&gt; 标志还将转储所选表的辅助对象（例如索引），但是pg_restore的 &lt;code&gt;-t&lt;/code&gt; 标志不包括此类辅助对象。</target>
        </trans-unit>
        <trans-unit id="238947e6bf1928a48d022f51eceab630f9f9ea68" translate="yes" xml:space="preserve">
          <source>This forces the checkpoint to be done as quickly as possible.</source>
          <target state="translated">这就迫使检查点尽快完成。</target>
        </trans-unit>
        <trans-unit id="69aa54921685a649b05a319351142e3198d02907" translate="yes" xml:space="preserve">
          <source>This form adds a new &lt;code&gt;PRIMARY KEY&lt;/code&gt; or &lt;code&gt;UNIQUE&lt;/code&gt; constraint to a table based on an existing unique index. All the columns of the index will be included in the constraint.</source>
          <target state="translated">此表单根据现有的唯一索引向表中添加新的 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 或 &lt;code&gt;UNIQUE&lt;/code&gt; 约束。索引的所有列都将包含在约束中。</target>
        </trans-unit>
        <trans-unit id="3ba31c86d5c7be29caf3e323f522bf84c40b7fcf" translate="yes" xml:space="preserve">
          <source>This form adds a new attribute to a composite type, using the same syntax as &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt;.</source>
          <target state="translated">此表单使用与&lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt;相同的语法向复合类型添加新属性。</target>
        </trans-unit>
        <trans-unit id="a0322ba886bea1157dcae5f05c22210a2d27f5b1" translate="yes" xml:space="preserve">
          <source>This form adds a new column to the foreign table, using the same syntax as &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;. Unlike the case when adding a column to a regular table, nothing happens to the underlying storage: this action simply declares that some new column is now accessible through the foreign table.</source>
          <target state="translated">此表单使用与&lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;相同的语法向外部表添加新列。与将列添加到常规表的情况不同，底层存储没有任何反应：此操作只是声明现在可以通过外部表访问某些新列。</target>
        </trans-unit>
        <trans-unit id="95c0b10fe4a25bd3c814ee981b4c421d53eaf37a" translate="yes" xml:space="preserve">
          <source>This form adds a new column to the table, using the same syntax as &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;. If &lt;code&gt;IF NOT EXISTS&lt;/code&gt; is specified and a column already exists with this name, no error is thrown.</source>
          <target state="translated">此表单使用与&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;相同的语法将新列添加到表中。如果指定了 &lt;code&gt;IF NOT EXISTS&lt;/code&gt; 并且该名称已经存在，则不会引发错误。</target>
        </trans-unit>
        <trans-unit id="b8ee63428230bf79c5e0942a3cc936820a6d5d6f" translate="yes" xml:space="preserve">
          <source>This form adds a new constraint to a domain using the same syntax as &lt;a href=&quot;sql-createdomain&quot;&gt;CREATE DOMAIN&lt;/a&gt;. When a new constraint is added to a domain, all columns using that domain will be checked against the newly added constraint. These checks can be suppressed by adding the new constraint using the &lt;code&gt;NOT VALID&lt;/code&gt; option; the constraint can later be made valid using &lt;code&gt;ALTER DOMAIN ... VALIDATE CONSTRAINT&lt;/code&gt;. Newly inserted or updated rows are always checked against all constraints, even those marked &lt;code&gt;NOT VALID&lt;/code&gt;. &lt;code&gt;NOT VALID&lt;/code&gt; is only accepted for &lt;code&gt;CHECK&lt;/code&gt; constraints.</source>
          <target state="translated">此表单使用与&lt;a href=&quot;sql-createdomain&quot;&gt;CREATE DOMAIN&lt;/a&gt;相同的语法将新约束添加到域。将新约束添加到域时，将对照新添加的约束检查使用该域的所有列。可以通过使用 &lt;code&gt;NOT VALID&lt;/code&gt; 选项添加新约束来抑制这些检查。稍后可以使用 &lt;code&gt;ALTER DOMAIN ... VALIDATE CONSTRAINT&lt;/code&gt; 使该约束有效。始终会对照所有约束（即使标记为 &lt;code&gt;NOT VALID&lt;/code&gt; 的约束）检查新插入或更新的行。 &lt;code&gt;NOT VALID&lt;/code&gt; 仅接受 &lt;code&gt;CHECK&lt;/code&gt; 约束。</target>
        </trans-unit>
        <trans-unit id="0f1ef6b759daf52986e80a140fc1e8e6996a0c1e" translate="yes" xml:space="preserve">
          <source>This form adds a new constraint to a foreign table, using the same syntax as &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;. Currently only &lt;code&gt;CHECK&lt;/code&gt; constraints are supported.</source>
          <target state="translated">此表单使用与&lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;相同的语法向外部表添加新约束。当前仅支持 &lt;code&gt;CHECK&lt;/code&gt; 约束。</target>
        </trans-unit>
        <trans-unit id="99cace79007308dc0d8e7331f85a19c72d625225" translate="yes" xml:space="preserve">
          <source>This form adds a new constraint to a table using the same constraint syntax as &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;, plus the option &lt;code&gt;NOT VALID&lt;/code&gt;, which is currently only allowed for foreign key and CHECK constraints.</source>
          <target state="translated">这种形式使用与&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;相同的约束语法，以及选项 &lt;code&gt;NOT VALID&lt;/code&gt; ，将新约束添加到表中，该选项当前仅允许用于外键和CHECK约束。</target>
        </trans-unit>
        <trans-unit id="60c743b0f8a6b250501ac85a73828ca722af7185" translate="yes" xml:space="preserve">
          <source>This form adds a new constraint to a table using the same syntax as &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;, plus the option &lt;code&gt;NOT VALID&lt;/code&gt;, which is currently only allowed for foreign key and CHECK constraints.</source>
          <target state="translated">此表单使用与&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;相同的语法向表中添加新约束，外加选项 &lt;code&gt;NOT VALID&lt;/code&gt; ，该选项当前仅适用于外键和CHECK约束。</target>
        </trans-unit>
        <trans-unit id="4ce19ef3782b6ce0c5b9df7476cc0daa1dd41c54" translate="yes" xml:space="preserve">
          <source>This form adds a new value to an enum type. The new value's place in the enum's ordering can be specified as being &lt;code&gt;BEFORE&lt;/code&gt; or &lt;code&gt;AFTER&lt;/code&gt; one of the existing values. Otherwise, the new item is added at the end of the list of values.</source>
          <target state="translated">此表单为枚举类型添加了新值。可以将新值在枚举顺序中的位置指定为现有值之一 &lt;code&gt;BEFORE&lt;/code&gt; 还是 &lt;code&gt;AFTER&lt;/code&gt; 。否则，新项目将添加到值列表的末尾。</target>
        </trans-unit>
        <trans-unit id="f6cf59f2735afa1f2d995a149ad05a9eb1b35eb7" translate="yes" xml:space="preserve">
          <source>This form adds an existing object to the extension. This is mainly useful in extension update scripts. The object will subsequently be treated as a member of the extension; notably, it can only be dropped by dropping the extension.</source>
          <target state="translated">这个表单将一个现有的对象添加到扩展中。这主要在扩展更新脚本中有用。该对象随后将被视为扩展的成员;值得注意的是,它只能通过放弃扩展来放弃。</target>
        </trans-unit>
        <trans-unit id="595f54e5f3b774c232dc30ed51e46c90273688d9" translate="yes" xml:space="preserve">
          <source>This form adds the target foreign table as a new child of the specified parent table. See the similar form of &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; for more details.</source>
          <target state="translated">此表单将目标外部表添加为指定父表的新子表。有关更多详细信息，请参见类似形式的&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="927ec7cd6b47cc568c9f6a02695b9db39fd050a7" translate="yes" xml:space="preserve">
          <source>This form adds the target table as a new child of the specified parent table. Subsequently, queries against the parent will include records of the target table. To be added as a child, the target table must already contain all the same columns as the parent (it could have additional columns, too). The columns must have matching data types, and if they have &lt;code&gt;NOT NULL&lt;/code&gt; constraints in the parent then they must also have &lt;code&gt;NOT NULL&lt;/code&gt; constraints in the child.</source>
          <target state="translated">此表单将目标表添加为指定父表的新子表。随后，针对父级的查询将包括目标表的记录。要作为子项添加，目标表必须已经包含与父项相同的所有列（它也可以具有其他列）。这些列必须具有匹配的数据类型，并且如果它们在父级中具有 &lt;code&gt;NOT NULL&lt;/code&gt; 约束，那么它们在子级中也必须具有 &lt;code&gt;NOT NULL&lt;/code&gt; 约束。</target>
        </trans-unit>
        <trans-unit id="d346519cab151e59ba4d85ab858ae6233fa9d98e" translate="yes" xml:space="preserve">
          <source>This form alters the attributes of a constraint that was previously created. Currently only foreign key constraints may be altered.</source>
          <target state="translated">这个表单可以改变之前创建的约束的属性。目前只有外键约束条件可以更改。</target>
        </trans-unit>
        <trans-unit id="7c3d28a97b5f73f4ab63b75ff86f6835976075b5" translate="yes" xml:space="preserve">
          <source>This form attaches an existing table (which might itself be partitioned) as a partition of the target table. The table can be attached as a partition for specific values using &lt;code&gt;FOR VALUES&lt;/code&gt; or as a default partition by using &lt;code&gt;DEFAULT&lt;/code&gt;. For each index in the target table, a corresponding one will be created in the attached table; or, if an equivalent index already exists, it will be attached to the target table's index, as if &lt;code&gt;ALTER INDEX ATTACH PARTITION&lt;/code&gt; had been executed. Note that if the existing table is a foreign table, it is currently not allowed to attach the table as a partition of the target table if there are &lt;code&gt;UNIQUE&lt;/code&gt; indexes on the target table. (See also &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;.)</source>
          <target state="translated">此表单将现有表（可能本身已分区）附加为目标表的分区。可以使用 &lt;code&gt;FOR VALUES&lt;/code&gt; 将表附加为特定值的分区，或者使用 &lt;code&gt;DEFAULT&lt;/code&gt; 附加为默认分区。对于目标表中的每个索引，将在所附表中创建一个对应的索引；或者，如果已经存在等效索引，它将被附加到目标表的索引，就像执行了 &lt;code&gt;ALTER INDEX ATTACH PARTITION&lt;/code&gt; 一样。请注意，如果现有表是外部表，则如果目标表上有 &lt;code&gt;UNIQUE&lt;/code&gt; 索引，则当前不允许将该表附加为目标表的分区。 （另请参阅&lt;a href=&quot;sql-createforeigntable&quot;&gt;创建外表&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="1869ca7747dbe933e84af2c5cba71787701542d6" translate="yes" xml:space="preserve">
          <source>This form attaches an existing table (which might itself be partitioned) as a partition of the target table. The table can be attached as a partition for specific values using &lt;code&gt;FOR VALUES&lt;/code&gt; or as a default partition by using &lt;code&gt;DEFAULT&lt;/code&gt;. For each index in the target table, a corresponding one will be created in the attached table; or, if an equivalent index already exists, it will be attached to the target table's index, as if &lt;code&gt;ALTER INDEX ATTACH PARTITION&lt;/code&gt; had been executed. Note that if the existing table is a foreign table, it is currently not allowed to attach the table as a partition of the target table if there are &lt;code&gt;UNIQUE&lt;/code&gt; indexes on the target table. (See also &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;.) For each user-defined row-level trigger that exists in the target table, a corresponding one is created in the attached table.</source>
          <target state="translated">此表单将现有表（可能本身已分区）附加为目标表的分区。可以使用 &lt;code&gt;FOR VALUES&lt;/code&gt; 将表附加为特定值的分区，或者使用 &lt;code&gt;DEFAULT&lt;/code&gt; 附加为默认分区。对于目标表中的每个索引，将在所附表中创建一个对应的索引；或者，如果已经存在等效索引，它将被附加到目标表的索引，就像已经执行了 &lt;code&gt;ALTER INDEX ATTACH PARTITION&lt;/code&gt; 一样。请注意，如果现有表是外部表，则如果目标表上有 &lt;code&gt;UNIQUE&lt;/code&gt; 索引，则当前不允许将该表附加为目标表的分区。（另请参阅&lt;a href=&quot;sql-createforeigntable&quot;&gt;创建外表&lt;/a&gt;。）对于目标表中存在的每个用户定义的行级触发器，都会在附加表中创建一个对应的触发器。</target>
        </trans-unit>
        <trans-unit id="bc3fb037ad7936c80f6f29d8637098894917452d" translate="yes" xml:space="preserve">
          <source>This form can be used to create the foreign table as partition of the given parent table with specified partition bound values. See the similar form of &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for more details. Note that it is currently not allowed to create the foreign table as a partition of the parent table if there are &lt;code&gt;UNIQUE&lt;/code&gt; indexes on the parent table. (See also &lt;a href=&quot;sql-altertable&quot;&gt;&lt;code&gt;ALTER TABLE ATTACH PARTITION&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">此表单可用于将外部表创建为具有指定分区绑定值的给定父表的分区。有关更多详细信息，请参见类似形式的&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;。请注意，如果父表上有 &lt;code&gt;UNIQUE&lt;/code&gt; 索引，则当前不允许将外部表创建为父表的分区。（另请参见&lt;a href=&quot;sql-altertable&quot;&gt; &lt;code&gt;ALTER TABLE ATTACH PARTITION&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="17c7c9cbd670ca1e7d92be433f5a08452d27c094" translate="yes" xml:space="preserve">
          <source>This form changes one or more index-method-specific storage parameters for the index. See &lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt; for details on the available parameters. Note that the index contents will not be modified immediately by this command; depending on the parameter you might need to rebuild the index with &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt; to get the desired effects.</source>
          <target state="translated">这种形式更改了索引的一个或多个特定于索引方法的存储参数。有关可用参数的详细信息，请参见&lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt;。请注意，此命令不会立即修改索引内容。根据参数，您可能需要使用&lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt;重建索引以获得所需的效果。</target>
        </trans-unit>
        <trans-unit id="85e33ac3b4ee94fcc601870b607686da66a411c8" translate="yes" xml:space="preserve">
          <source>This form changes one or more storage parameters for the table. See &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt; for details on the available parameters. Note that the table contents will not be modified immediately by this command; depending on the parameter you might need to rewrite the table to get the desired effects. That can be done with &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM FULL&lt;/a&gt;, &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; or one of the forms of &lt;code&gt;ALTER TABLE&lt;/code&gt; that forces a table rewrite. For planner related parameters, changes will take effect from the next time the table is locked so currently executing queries will not be affected.</source>
          <target state="translated">该表格更改了表的一个或多个存储参数。有关可用参数的详细信息，请参见&lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;存储&lt;/a&gt;参数。注意，此命令不会立即修改表的内容。根据参数，您可能需要重写表以获得所需的效果。可以使用&lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM FULL&lt;/a&gt;，&lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt;或强制表重写的 &lt;code&gt;ALTER TABLE&lt;/code&gt; 形式之一来完成。对于与计划者相关的参数，更改将在表下次锁定时生效，因此当前执行的查询将不受影响。</target>
        </trans-unit>
        <trans-unit id="a90914d894dbf343cb6837e8578f6573c8aee615" translate="yes" xml:space="preserve">
          <source>This form changes one or more storage parameters for the table. See &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt; in the &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; documentation for details on the available parameters. Note that the table contents will not be modified immediately by this command; depending on the parameter you might need to rewrite the table to get the desired effects. That can be done with &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM FULL&lt;/a&gt;, &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; or one of the forms of &lt;code&gt;ALTER TABLE&lt;/code&gt; that forces a table rewrite. For planner related parameters, changes will take effect from the next time the table is locked so currently executing queries will not be affected.</source>
          <target state="translated">该表格更改了表的一个或多个存储参数。有关可用参数的详细信息，请参见&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;文档中的&lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt;。注意，此命令不会立即修改表的内容。根据参数，您可能需要重写表以获得所需的效果。可以使用&lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM FULL&lt;/a&gt;，&lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt;或强制表重写的 &lt;code&gt;ALTER TABLE&lt;/code&gt; 形式之一来完成。对于与计划者相关的参数，更改将在表下次锁定时生效，因此当前执行的查询不会受到影响。</target>
        </trans-unit>
        <trans-unit id="e83d3c0b4c77e2425087c239b0df05fcb0116826" translate="yes" xml:space="preserve">
          <source>This form changes the index's tablespace to the specified tablespace and moves the data file(s) associated with the index to the new tablespace. To change the tablespace of an index, you must own the index and have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new tablespace. All indexes in the current database in a tablespace can be moved by using the &lt;code&gt;ALL IN TABLESPACE&lt;/code&gt; form, which will lock all indexes to be moved and then move each one. This form also supports &lt;code&gt;OWNED BY&lt;/code&gt;, which will only move indexes owned by the roles specified. If the &lt;code&gt;NOWAIT&lt;/code&gt; option is specified then the command will fail if it is unable to acquire all of the locks required immediately. Note that system catalogs will not be moved by this command, use &lt;code&gt;ALTER DATABASE&lt;/code&gt; or explicit &lt;code&gt;ALTER INDEX&lt;/code&gt; invocations instead if desired. See also &lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt;.</source>
          <target state="translated">这种形式将索引的表空间更改为指定的表空间，并将与索引关联的数据文件移动到新的表空间。要更改索引的表空间，您必须拥有索引并在新表空间上具有 &lt;code&gt;CREATE&lt;/code&gt; 特权。可以使用 &lt;code&gt;ALL IN TABLESPACE&lt;/code&gt; 表单移动表空间中当前数据库中的所有索引，该表单将锁定要移动的所有索引，然后再移动每个索引。此表单还支持 &lt;code&gt;OWNED BY&lt;/code&gt; ，它将仅移动指定角色所拥有的索引。如果指定了 &lt;code&gt;NOWAIT&lt;/code&gt; 选项，则如果该命令无法立即获取所有必需的锁，则该命令将失败。请注意，此命令不会移动系统目录，请使用 &lt;code&gt;ALTER DATABASE&lt;/code&gt; 或根据需要显式的 &lt;code&gt;ALTER INDEX&lt;/code&gt; 调用。另请参见&lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3c55be56dbc86b6d6779191aa5c394d5588fe660" translate="yes" xml:space="preserve">
          <source>This form changes the information which is written to the write-ahead log to identify rows which are updated or deleted. This option has no effect except when logical replication is in use. &lt;code&gt;DEFAULT&lt;/code&gt; (the default for non-system tables) records the old values of the columns of the primary key, if any. &lt;code&gt;USING INDEX&lt;/code&gt; records the old values of the columns covered by the named index, which must be unique, not partial, not deferrable, and include only columns marked &lt;code&gt;NOT NULL&lt;/code&gt;. &lt;code&gt;FULL&lt;/code&gt; records the old values of all columns in the row. &lt;code&gt;NOTHING&lt;/code&gt; records no information about the old row. (This is the default for system tables.) In all cases, no old values are logged unless at least one of the columns that would be logged differs between the old and new versions of the row.</source>
          <target state="translated">该表格更改了写入预写日志的信息，以标识已更新或删除的行。该选项仅在使用逻辑复制时才有效。 &lt;code&gt;DEFAULT&lt;/code&gt; （非系统表的默认值）记录主键的列的旧值（如果有）。 &lt;code&gt;USING INDEX&lt;/code&gt; 记录命名索引覆盖的列的旧值，该值必须是唯一的，不局部的，不可延迟的，并且仅包括标记为 &lt;code&gt;NOT NULL&lt;/code&gt; 的列。 &lt;code&gt;FULL&lt;/code&gt; 记录该行中所有列的旧值。 &lt;code&gt;NOTHING&lt;/code&gt; 不记录有关旧行的信息。（这是系统表的默认值。）在所有情况下，除非该行的新旧版本中至少要记录的列之一不同，否则不会记录任何旧值。</target>
        </trans-unit>
        <trans-unit id="d5fd7a415ae62d2432d673453426bcca0e434c22" translate="yes" xml:space="preserve">
          <source>This form changes the name of a constraint on a domain.</source>
          <target state="translated">此表更改域上约束的名称。</target>
        </trans-unit>
        <trans-unit id="3a34d134067f8057fdc7eb4bd8e2afb5eac929d2" translate="yes" xml:space="preserve">
          <source>This form changes the name of the domain.</source>
          <target state="translated">这种形式改变了域名的名称。</target>
        </trans-unit>
        <trans-unit id="bdaccc9f755620eea9c5a68106023cbc0c07f19d" translate="yes" xml:space="preserve">
          <source>This form changes the name of the type or the name of an individual attribute of a composite type.</source>
          <target state="translated">此表更改类型名称或复合类型的单个属性名称。</target>
        </trans-unit>
        <trans-unit id="8cfd4248390a30b80daebf0ff6ee06ccc365741e" translate="yes" xml:space="preserve">
          <source>This form changes the name of the type.</source>
          <target state="translated">此表更改类型名称。</target>
        </trans-unit>
        <trans-unit id="33709234ccf296c21440f70a857148d5d605167b" translate="yes" xml:space="preserve">
          <source>This form changes the owner of the domain to the specified user.</source>
          <target state="translated">此表单将域的所有者变更为指定的用户。</target>
        </trans-unit>
        <trans-unit id="33c8412b485a6292103c360edb753fe679de7f49" translate="yes" xml:space="preserve">
          <source>This form changes the owner of the foreign table to the specified user.</source>
          <target state="translated">此表将外表的所有者变更为指定的用户。</target>
        </trans-unit>
        <trans-unit id="bdda20046cb686daa61e8bfb091f3201cdd5da85" translate="yes" xml:space="preserve">
          <source>This form changes the owner of the table, sequence, view, materialized view, or foreign table to the specified user.</source>
          <target state="translated">此表单将表、序列、视图、物化视图或外表的所有者变更为指定用户。</target>
        </trans-unit>
        <trans-unit id="367a0875855c27e375e704da43453b6a64108026" translate="yes" xml:space="preserve">
          <source>This form changes the owner of the type.</source>
          <target state="translated">这个表格改变了类型的所有者。</target>
        </trans-unit>
        <trans-unit id="6515faf0d6c7bfb31358723522828dadb55476f0" translate="yes" xml:space="preserve">
          <source>This form changes the schema of the domain. Any constraints associated with the domain are moved into the new schema as well.</source>
          <target state="translated">这个表单改变了域的模式。任何与域相关的约束条件也会被移到新的模式中。</target>
        </trans-unit>
        <trans-unit id="9ceb0679036b94c23ce3c3c3726ad7d1600fd754" translate="yes" xml:space="preserve">
          <source>This form changes the table from unlogged to logged or vice-versa (see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-UNLOGGED&quot;&gt;&lt;code&gt;UNLOGGED&lt;/code&gt;&lt;/a&gt;). It cannot be applied to a temporary table.</source>
          <target state="translated">此表单将表从未登录更改为已登录，反之亦然（请参阅&lt;a href=&quot;sql-createtable#SQL-CREATETABLE-UNLOGGED&quot;&gt; &lt;code&gt;UNLOGGED&lt;/code&gt; &lt;/a&gt;）。它不能应用于临时表。</target>
        </trans-unit>
        <trans-unit id="b21eade6f7dd16e560cb3e285d036a4340eaa767" translate="yes" xml:space="preserve">
          <source>This form changes the table's tablespace to the specified tablespace and moves the data file(s) associated with the table to the new tablespace. Indexes on the table, if any, are not moved; but they can be moved separately with additional &lt;code&gt;SET TABLESPACE&lt;/code&gt; commands. When applied to a partitioned table, nothing is moved, but any partitions created afterwards with &lt;code&gt;CREATE TABLE PARTITION OF&lt;/code&gt; will use that tablespace, unless overridden by a &lt;code&gt;TABLESPACE&lt;/code&gt; clause.</source>
          <target state="translated">此表单将表的表空间更改为指定的表空间，并将与该表关联的数据文件移动到新表空间。表中的索引（如果有）不会移动；但是可以使用其他 &lt;code&gt;SET TABLESPACE&lt;/code&gt; 命令分别移动它们。当应用于分区表时，不会移动任何内容，但是以后使用 &lt;code&gt;CREATE TABLE PARTITION OF&lt;/code&gt; 创建的任何分区都将使用该表空间，除非被 &lt;code&gt;TABLESPACE&lt;/code&gt; 子句覆盖。</target>
        </trans-unit>
        <trans-unit id="413a825daa3f78a948f21b1ed732bd1afa98d9f3" translate="yes" xml:space="preserve">
          <source>This form changes the table's tablespace to the specified tablespace and moves the data file(s) associated with the table to the new tablespace. Indexes on the table, if any, are not moved; but they can be moved separately with additional &lt;code&gt;SET TABLESPACE&lt;/code&gt; commands. When applied to a partitioned table, nothing is moved, but any partitions created afterwards with &lt;code&gt;CREATE TABLE PARTITION OF&lt;/code&gt; will use that tablespace, unless the &lt;code&gt;TABLESPACE&lt;/code&gt; clause is used to override it.</source>
          <target state="translated">该表单将表的表空间更改为指定的表空间，并将与表关联的数据文件移动到新表空间。表中的索引（如果有）不会移动；但是可以使用其他 &lt;code&gt;SET TABLESPACE&lt;/code&gt; 命令分别移动它们。当应用于分区表时，不会移动任何内容，但是以后使用 &lt;code&gt;CREATE TABLE PARTITION OF&lt;/code&gt; 创建的任何分区都将使用该表空间，除非使用 &lt;code&gt;TABLESPACE&lt;/code&gt; 子句覆盖它。</target>
        </trans-unit>
        <trans-unit id="d606494af7f67be03bcb787fb49d4fbd5e3725e9" translate="yes" xml:space="preserve">
          <source>This form changes the type of a column of a foreign table. Again, this has no effect on any underlying storage: this action simply changes the type that PostgreSQL believes the column to have.</source>
          <target state="translated">这个表单改变了一个外表的列的类型。同样,这对任何底层存储没有影响:这个操作只是改变了PostgreSQL认为列的类型。</target>
        </trans-unit>
        <trans-unit id="ef90ca77493d55255faa9c05a6d21e673fa262d6" translate="yes" xml:space="preserve">
          <source>This form changes the type of a column of a table. Indexes and simple table constraints involving the column will be automatically converted to use the new column type by reparsing the originally supplied expression. The optional &lt;code&gt;COLLATE&lt;/code&gt; clause specifies a collation for the new column; if omitted, the collation is the default for the new column type. The optional &lt;code&gt;USING&lt;/code&gt; clause specifies how to compute the new column value from the old; if omitted, the default conversion is the same as an assignment cast from old data type to new. A &lt;code&gt;USING&lt;/code&gt; clause must be provided if there is no implicit or assignment cast from old to new type.</source>
          <target state="translated">此表单更改表的列的类型。通过重新解析最初提供的表达式，涉及该列的索引和简单表约束将自动转换为使用新的列类型。可选的 &lt;code&gt;COLLATE&lt;/code&gt; 子句为新列指定排序规则；如果省略，则排序规则是新列类型的默认排序规则。可选的 &lt;code&gt;USING&lt;/code&gt; 子句指定如何从旧的值计算新的列值；如果省略，则默认转换与从旧数据类型到新数据类型的转换相同。一个 &lt;code&gt;USING&lt;/code&gt; 如果从旧到新类型没有隐含或者赋值转换必须提供条款。</target>
        </trans-unit>
        <trans-unit id="f90f5c12001436438a106ce1bcbc9026c77d9b2f" translate="yes" xml:space="preserve">
          <source>This form changes the type of an attribute of a composite type.</source>
          <target state="translated">这种形式可以改变复合类型的属性类型。</target>
        </trans-unit>
        <trans-unit id="c4194cb65228a21c483f32a1d7544636b626b6d4" translate="yes" xml:space="preserve">
          <source>This form detaches specified partition of the target table. The detached partition continues to exist as a standalone table, but no longer has any ties to the table from which it was detached. Any indexes that were attached to the target table's indexes are detached.</source>
          <target state="translated">此表单分离目标表的指定分区。被分离的分区继续作为一个独立的表存在,但不再与被分离的表有任何联系。连接到目标表的索引的任何索引都会被分离。</target>
        </trans-unit>
        <trans-unit id="e6073cfd81439f0b29a7e52096d2c9bbc8448ad6" translate="yes" xml:space="preserve">
          <source>This form detaches the specified partition of the target table. The detached partition continues to exist as a standalone table, but no longer has any ties to the table from which it was detached. Any indexes that were attached to the target table's indexes are detached. Any triggers that were created as clones of those in the target table are removed.</source>
          <target state="translated">此表单用于分离目标表的指定分区。被分离的分区继续作为一个独立的表存在,但不再与被分离的表有任何联系。连接到目标表的索引的任何索引都会被分离。任何作为目标表中的触发器的克隆而创建的触发器都会被删除。</target>
        </trans-unit>
        <trans-unit id="6f649e2a380d4d6a7844e29c8bec08b60d14e121" translate="yes" xml:space="preserve">
          <source>This form dissociates a typed table from its type.</source>
          <target state="translated">这个表格将一个类型表从它的类型中分离出来。</target>
        </trans-unit>
        <trans-unit id="41af815da8671345e4d0830589af85c8c9d1f4f9" translate="yes" xml:space="preserve">
          <source>This form drops a column from a foreign table. You will need to say &lt;code&gt;CASCADE&lt;/code&gt; if anything outside the table depends on the column; for example, views. If &lt;code&gt;IF EXISTS&lt;/code&gt; is specified and the column does not exist, no error is thrown. In this case a notice is issued instead.</source>
          <target state="translated">此表单从外部表中删除一列。如果表外的任何内容都取决于该列，则需要说 &lt;code&gt;CASCADE&lt;/code&gt; ；例如视图。如果指定了 &lt;code&gt;IF EXISTS&lt;/code&gt; 且该列不存在，则不会引发任何错误。在这种情况下，将发出通知。</target>
        </trans-unit>
        <trans-unit id="132c35990a8f9ff6a2087c8c4db6bfe5bc0d3b7f" translate="yes" xml:space="preserve">
          <source>This form drops a column from a table. Indexes and table constraints involving the column will be automatically dropped as well. Multivariate statistics referencing the dropped column will also be removed if the removal of the column would cause the statistics to contain data for only a single column. You will need to say &lt;code&gt;CASCADE&lt;/code&gt; if anything outside the table depends on the column, for example, foreign key references or views. If &lt;code&gt;IF EXISTS&lt;/code&gt; is specified and the column does not exist, no error is thrown. In this case a notice is issued instead.</source>
          <target state="translated">此表单从表中删除一列。涉及该列的索引和表约束也将自动删除。如果删除列会导致统计信息仅包含单个列的数据，则引用该列的多元统计信息也会被删除。如果表外的任何内容取决于列，例如外键引用或视图，您将需要说 &lt;code&gt;CASCADE&lt;/code&gt; 。如果指定了 &lt;code&gt;IF EXISTS&lt;/code&gt; 且该列不存在，则不会引发任何错误。在这种情况下，将发出通知。</target>
        </trans-unit>
        <trans-unit id="630cbfc87f5704d127bcc228848ac6a6604a8fb0" translate="yes" xml:space="preserve">
          <source>This form drops an attribute from a composite type. If &lt;code&gt;IF EXISTS&lt;/code&gt; is specified and the attribute does not exist, no error is thrown. In this case a notice is issued instead.</source>
          <target state="translated">此表单从复合类型中删除属性。如果指定了 &lt;code&gt;IF EXISTS&lt;/code&gt; 且该属性不存在，则不会引发任何错误。在这种情况下，将发出通知。</target>
        </trans-unit>
        <trans-unit id="abbb33e28408b10284213af5010b6f9ed9616abd" translate="yes" xml:space="preserve">
          <source>This form drops constraints on a domain. If &lt;code&gt;IF EXISTS&lt;/code&gt; is specified and the constraint does not exist, no error is thrown. In this case a notice is issued instead.</source>
          <target state="translated">这种形式在域上放下了约束。如果指定了 &lt;code&gt;IF EXISTS&lt;/code&gt; 且该约束不存在，则不会引发任何错误。在这种情况下，将发出通知。</target>
        </trans-unit>
        <trans-unit id="0562817256cba47f3678521e40341b9bb63428df" translate="yes" xml:space="preserve">
          <source>This form drops the specified constraint on a foreign table. If &lt;code&gt;IF EXISTS&lt;/code&gt; is specified and the constraint does not exist, no error is thrown. In this case a notice is issued instead.</source>
          <target state="translated">此表单将指定的约束放在外部表上。如果指定了 &lt;code&gt;IF EXISTS&lt;/code&gt; 且该约束不存在，则不会引发任何错误。在这种情况下，将发出通知。</target>
        </trans-unit>
        <trans-unit id="ef5c32eb106661dab4fdce48beeb3716d53be331" translate="yes" xml:space="preserve">
          <source>This form drops the specified constraint on a table, along with any index underlying the constraint. If &lt;code&gt;IF EXISTS&lt;/code&gt; is specified and the constraint does not exist, no error is thrown. In this case a notice is issued instead.</source>
          <target state="translated">这种形式将指定的约束以及该约束下的任何索引都放到表上。如果指定了 &lt;code&gt;IF EXISTS&lt;/code&gt; 且该约束不存在，则不会引发任何错误。在这种情况下，将发出通知。</target>
        </trans-unit>
        <trans-unit id="d6075d1245dd08cd17ae12d300569e914c015d02" translate="yes" xml:space="preserve">
          <source>This form is not currently supported on partitioned tables.</source>
          <target state="translated">目前分区表不支持这种形式。</target>
        </trans-unit>
        <trans-unit id="d8b11f2ae6d44cb1444622b88c46b7122c4666b1" translate="yes" xml:space="preserve">
          <source>This form is only applicable to base types. It allows adjustment of a subset of the base-type properties that can be set in &lt;code&gt;CREATE TYPE&lt;/code&gt;. Specifically, these properties can be changed:</source>
          <target state="translated">该表格仅适用于基本类型。它允许调整可以在 &lt;code&gt;CREATE TYPE&lt;/code&gt; 中设置的基本类型属性的子集。具体来说，可以更改以下属性：</target>
        </trans-unit>
        <trans-unit id="f77a1a6b3b2aecc7300bf71dbd0467e9777098c6" translate="yes" xml:space="preserve">
          <source>This form is only usable with composite types. It changes the name of an individual attribute of the type.</source>
          <target state="translated">此表格仅适用于复合类型。它改变了该类型的单个属性的名称。</target>
        </trans-unit>
        <trans-unit id="62fef7209d0ef0917314ea35bb80cd3a32ecadf7" translate="yes" xml:space="preserve">
          <source>This form links the table to a composite type as though &lt;code&gt;CREATE TABLE OF&lt;/code&gt; had formed it. The table's list of column names and types must precisely match that of the composite type. The table must not inherit from any other table. These restrictions ensure that &lt;code&gt;CREATE TABLE OF&lt;/code&gt; would permit an equivalent table definition.</source>
          <target state="translated">这种形式将表链接到复合类型，就像 &lt;code&gt;CREATE TABLE OF&lt;/code&gt; 已经形成了它一样。该表的列名和类型列表必须与组合类型的列表精确匹配。该表不得从任何其他表继承。这些限制确保 &lt;code&gt;CREATE TABLE OF&lt;/code&gt; 将允许等效的表定义。</target>
        </trans-unit>
        <trans-unit id="80c03819073116dcc932622328193f2e17ef52d2" translate="yes" xml:space="preserve">
          <source>This form marks as valid a constraint that was previously marked as &lt;code&gt;NOT VALID&lt;/code&gt;. No action is taken to verify the constraint, but future queries will assume that it holds.</source>
          <target state="translated">此表单将先前标记为 &lt;code&gt;NOT VALID&lt;/code&gt; 的约束标记为有效。不会采取任何措施来验证约束，但是以后的查询将假定该约束成立。</target>
        </trans-unit>
        <trans-unit id="b14af7517538e421b68a1939c47cac2afc8ff879" translate="yes" xml:space="preserve">
          <source>This form marks the function as dependent on the extension, or no longer dependent on that extension if &lt;code&gt;NO&lt;/code&gt; is specified. A function that's marked as dependent on an extension is automatically dropped when the extension is dropped.</source>
          <target state="translated">该表格将功能标记为依赖于扩展名，或者，如果指定为 &lt;code&gt;NO&lt;/code&gt; ,则不再依赖于该扩展名。删除扩展名后，会自动删除标记为依赖于扩展名的功能。</target>
        </trans-unit>
        <trans-unit id="058bcd5831cd602d111c74db2f7028e5e56ec71d" translate="yes" xml:space="preserve">
          <source>This form marks the index as dependent on the extension, or no longer dependent on that extension if &lt;code&gt;NO&lt;/code&gt; is specified. An index that's marked as dependent on an extension is automatically dropped when the extension is dropped.</source>
          <target state="translated">此表格将索引标记为依赖于扩展名，或者，如果指定为 &lt;code&gt;NO&lt;/code&gt; ,则不再依赖于该扩展名。删除扩展名后，会自动删除标记为依赖于扩展名的索引。</target>
        </trans-unit>
        <trans-unit id="85cec438622a098483a45173b222a4d5cd019672" translate="yes" xml:space="preserve">
          <source>This form marks the index as dependent on the extension, such that if the extension is dropped, the index will automatically be dropped as well.</source>
          <target state="translated">这种形式将索引标记为依赖于扩展,这样如果扩展被删除,索引也会自动被删除。</target>
        </trans-unit>
        <trans-unit id="4faed3e54b7a44c7e7e8c551a8c0326f16df1512" translate="yes" xml:space="preserve">
          <source>This form moves the extension's objects into another schema. The extension has to be &lt;em&gt;relocatable&lt;/em&gt; for this command to succeed.</source>
          <target state="translated">这种形式将扩展的对象移动到另一个架构中。该扩展名必须可&lt;em&gt;重定位&lt;/em&gt;，此命令才能成功。</target>
        </trans-unit>
        <trans-unit id="d44749fe236086787bbeb370c7b120c56a308916" translate="yes" xml:space="preserve">
          <source>This form moves the foreign table into another schema.</source>
          <target state="translated">这个表单将外表移动到另一个模式中。</target>
        </trans-unit>
        <trans-unit id="343fe32ad6664d950886e22df1f9e56f6f16399d" translate="yes" xml:space="preserve">
          <source>This form moves the table into another schema. Associated indexes, constraints, and sequences owned by table columns are moved as well.</source>
          <target state="translated">这个表单将表移动到另一个模式中。表列所拥有的相关索引、约束和序列也会被移动。</target>
        </trans-unit>
        <trans-unit id="4a25f7c9422516454200b0986e93d0f9a7b1cd24" translate="yes" xml:space="preserve">
          <source>This form moves the type into another schema.</source>
          <target state="translated">此表单将类型移动到另一个模式中。</target>
        </trans-unit>
        <trans-unit id="af28f23e1758f00a66bd13166257650c2c6c6e02" translate="yes" xml:space="preserve">
          <source>This form of &lt;code&gt;CREATE TRANSFORM&lt;/code&gt; is a PostgreSQL extension. There is a &lt;code&gt;CREATE TRANSFORM&lt;/code&gt; command in the SQL standard, but it is for adapting data types to client languages. That usage is not supported by PostgreSQL.</source>
          <target state="translated">这种形式的 &lt;code&gt;CREATE TRANSFORM&lt;/code&gt; 是PostgreSQL的扩展。SQL标准中有一个 &lt;code&gt;CREATE TRANSFORM&lt;/code&gt; 命令，但是它用于使数据类型适应客户端语言。PostgreSQL不支持该用法。</target>
        </trans-unit>
        <trans-unit id="6ab065126927246d3956d5f89c1fdf1ac5a9c01c" translate="yes" xml:space="preserve">
          <source>This form of &lt;code&gt;DROP TRANSFORM&lt;/code&gt; is a PostgreSQL extension. See &lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORM&lt;/a&gt; for details.</source>
          <target state="translated">这种形式的 &lt;code&gt;DROP TRANSFORM&lt;/code&gt; 是PostgreSQL的扩展。有关详细信息，请参见&lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORM&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="09d38af3e512e1a4bd2fd33c7735f8320af47f2b" translate="yes" xml:space="preserve">
          <source>This form of &lt;code&gt;json_object&lt;/code&gt; takes keys and values pairwise from separate text arrays. Otherwise it is identical to the one-argument form.</source>
          <target state="translated">这种形式的 &lt;code&gt;json_object&lt;/code&gt; 从单独的文本数组中成对地获取键和值。否则，它与单参数形式相同。</target>
        </trans-unit>
        <trans-unit id="3ff5cb48fe56e9b363be562d91784fed1316defb" translate="yes" xml:space="preserve">
          <source>This form of &lt;code&gt;json_object&lt;/code&gt; takes keys and values pairwise from two separate arrays. In all other respects it is identical to the one-argument form.</source>
          <target state="translated">这种形式的 &lt;code&gt;json_object&lt;/code&gt; 从两个单独的数组中成对地获取键和值。在所有其他方面，它与单参数形式相同。</target>
        </trans-unit>
        <trans-unit id="e130ed2324ecc47cb96bb25ee04c4b0d13167363" translate="yes" xml:space="preserve">
          <source>This form of &lt;code&gt;ts_rewrite&lt;/code&gt; accepts a starting &lt;code&gt;query&lt;/code&gt; and a SQL &lt;code&gt;select&lt;/code&gt; command, which is given as a text string. The &lt;code&gt;select&lt;/code&gt; must yield two columns of &lt;code&gt;tsquery&lt;/code&gt; type. For each row of the &lt;code&gt;select&lt;/code&gt; result, occurrences of the first column value (the target) are replaced by the second column value (the substitute) within the current &lt;code&gt;query&lt;/code&gt; value. For example:</source>
          <target state="translated">&lt;code&gt;ts_rewrite&lt;/code&gt; 的这种形式接受启动 &lt;code&gt;query&lt;/code&gt; 和SQL &lt;code&gt;select&lt;/code&gt; 命令，该命令以文本字符串形式给出。该 &lt;code&gt;select&lt;/code&gt; 必须产生的两列 &lt;code&gt;tsquery&lt;/code&gt; 类型。对于 &lt;code&gt;select&lt;/code&gt; 结果的每一行，在当前 &lt;code&gt;query&lt;/code&gt; 值内，第一列值（目标）的出现被第二列值（替代）替换。例如：</target>
        </trans-unit>
        <trans-unit id="d013efd17243813d551b63d4312494e00c1c1a6c" translate="yes" xml:space="preserve">
          <source>This form of &lt;code&gt;ts_rewrite&lt;/code&gt; simply applies a single rewrite rule: &lt;code&gt;target&lt;/code&gt; is replaced by &lt;code&gt;substitute&lt;/code&gt; wherever it appears in &lt;code&gt;query&lt;/code&gt;. For example:</source>
          <target state="translated">这种形式的 &lt;code&gt;ts_rewrite&lt;/code&gt; 简单地应用于单重写规则： &lt;code&gt;target&lt;/code&gt; 被替换 &lt;code&gt;substitute&lt;/code&gt; 各处出现的 &lt;code&gt;query&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="eb31fbf716a310edf9d2b4049a82ade012c42087" translate="yes" xml:space="preserve">
          <source>This form of the &lt;code&gt;AS&lt;/code&gt; clause is used for dynamically loadable C language functions when the function name in the C language source code is not the same as the name of the SQL function. The string &lt;code&gt;obj_file&lt;/code&gt; is the name of the shared library file containing the compiled C function, and is interpreted as for the &lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt; command. The string &lt;code&gt;link_symbol&lt;/code&gt; is the function's link symbol, that is, the name of the function in the C language source code. If the link symbol is omitted, it is assumed to be the same as the name of the SQL function being defined. The C names of all functions must be different, so you must give overloaded C functions different C names (for example, use the argument types as part of the C names).</source>
          <target state="translated">当C语言源代码中的函数名称与SQL函数的名称不同时，这种形式的 &lt;code&gt;AS&lt;/code&gt; 子句用于可动态加载的C语言函数。字符串 &lt;code&gt;obj_file&lt;/code&gt; 是包含已编译的C函数的共享库文件的名称，并被解释为&lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt;命令。字符串 &lt;code&gt;link_symbol&lt;/code&gt; 是函数的链接符号，即C语言源代码中函数的名称。如果省略链接符号，则假定它与所定义的SQL函数的名称相同。所有函数的C名称必须不同，因此必须为重载的C函数赋予不同的C名称（例如，将参数类型用作C名称的一部分）。</target>
        </trans-unit>
        <trans-unit id="2a04c3c78f722989a90da205ce8987d3f751510b" translate="yes" xml:space="preserve">
          <source>This form of the &lt;code&gt;AS&lt;/code&gt; clause is used for dynamically loadable C language procedures when the procedure name in the C language source code is not the same as the name of the SQL procedure. The string &lt;code&gt;obj_file&lt;/code&gt; is the name of the shared library file containing the compiled C procedure, and is interpreted as for the &lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt; command. The string &lt;code&gt;link_symbol&lt;/code&gt; is the procedure's link symbol, that is, the name of the procedure in the C language source code. If the link symbol is omitted, it is assumed to be the same as the name of the SQL procedure being defined.</source>
          <target state="translated">当C语言源代码中的过程名称与SQL过程的名称不同时，这种形式的 &lt;code&gt;AS&lt;/code&gt; 子句用于可动态加载的C语言过程。字符串 &lt;code&gt;obj_file&lt;/code&gt; 是包含已编译的C过程的共享库文件的名称，并被解释为&lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt;命令。字符串 &lt;code&gt;link_symbol&lt;/code&gt; 是过程的链接符号，即C语言源代码中过程的名称。如果省略链接符号，则假定它与所定义的SQL过程的名称相同。</target>
        </trans-unit>
        <trans-unit id="9d61def8f9ec3856b91d045805fea7f90a02d4de" translate="yes" xml:space="preserve">
          <source>This form of the command cannot be executed inside a transaction block.</source>
          <target state="translated">这种形式的命令不能在交易块内执行。</target>
        </trans-unit>
        <trans-unit id="99f50353be2bb5b567c08b62d433e3835ac63124" translate="yes" xml:space="preserve">
          <source>This form only executes the function if column &lt;code&gt;balance&lt;/code&gt; has in fact changed value:</source>
          <target state="translated">仅当列 &lt;code&gt;balance&lt;/code&gt; 实际上已更改值时，此表单才执行该功能：</target>
        </trans-unit>
        <trans-unit id="f4473c42ad05dfd82fc106e9f90398e30bc2ce6b" translate="yes" xml:space="preserve">
          <source>This form removes a member object from the extension. This is mainly useful in extension update scripts. The object is not dropped, only disassociated from the extension.</source>
          <target state="translated">这个表单从扩展中删除一个成员对象。这主要在扩展更新脚本中有用。该对象不会被删除,只是与扩展脱离关系。</target>
        </trans-unit>
        <trans-unit id="eac856d748a6f647a905af09f04314ea23cd83c3" translate="yes" xml:space="preserve">
          <source>This form removes the most recently used &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; index specification from the table. This affects future cluster operations that don't specify an index.</source>
          <target state="translated">该表格从表中删除了最近使用的&lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt;索引规范。这会影响以后未指定索引的集群操作。</target>
        </trans-unit>
        <trans-unit id="b9adc8eb95719164761b79a5084426c7addf0749" translate="yes" xml:space="preserve">
          <source>This form removes the target foreign table from the list of children of the specified parent table.</source>
          <target state="translated">此表单将目标外表从指定父表的子表列表中删除。</target>
        </trans-unit>
        <trans-unit id="9c78c98e24aa433ee20cbdef33df9ef970bae2bf" translate="yes" xml:space="preserve">
          <source>This form removes the target table from the list of children of the specified parent table. Queries against the parent table will no longer include records drawn from the target table.</source>
          <target state="translated">此表将目标表从指定父表的子表列表中删除。对父表的查询将不再包括从目标表提取的记录。</target>
        </trans-unit>
        <trans-unit id="3c86659bd33298dbeea55e29cf320d1c3d50f459" translate="yes" xml:space="preserve">
          <source>This form renames a value of an enum type. The value's place in the enum's ordering is not affected. An error will occur if the specified value is not present or the new name is already present.</source>
          <target state="translated">此表单可以重命名一个枚举类型的值。该值在枚举类型中的排序不受影响。如果指定的值不存在或新名称已经存在,则会出现错误。</target>
        </trans-unit>
        <trans-unit id="d4bbf5050bebdaa653a528317e3e5511397a3bd9" translate="yes" xml:space="preserve">
          <source>This form resets one or more index-method-specific storage parameters to their defaults. As with &lt;code&gt;SET&lt;/code&gt;, a &lt;code&gt;REINDEX&lt;/code&gt; might be needed to update the index entirely.</source>
          <target state="translated">该表格将一个或多个特定于索引方法的存储参数重置为其默认值。与 &lt;code&gt;SET&lt;/code&gt; 一样，可能需要 &lt;code&gt;REINDEX&lt;/code&gt; 才能完全更新索引。</target>
        </trans-unit>
        <trans-unit id="5e49ca11d0f33e0a64657337a16309c7010218e7" translate="yes" xml:space="preserve">
          <source>This form resets one or more storage parameters to their defaults. As with &lt;code&gt;SET&lt;/code&gt;, a table rewrite might be needed to update the table entirely.</source>
          <target state="translated">该表格将一个或多个存储参数重置为其默认值。与 &lt;code&gt;SET&lt;/code&gt; 一样，可能需要重写表才能完全更新表。</target>
        </trans-unit>
        <trans-unit id="1d66d6fd49dacdab7eaf9fc3512115d0797c065d" translate="yes" xml:space="preserve">
          <source>This form selects the default index for future &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; operations. It does not actually re-cluster the table.</source>
          <target state="translated">此表单为将来的&lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt;操作选择默认索引。它实际上并没有重新群集表。</target>
        </trans-unit>
        <trans-unit id="518ddc9b662de15607142c00b06214f51c6fca69" translate="yes" xml:space="preserve">
          <source>This form sets or resets per-attribute options. Currently, the only defined per-attribute options are &lt;code&gt;n_distinct&lt;/code&gt; and &lt;code&gt;n_distinct_inherited&lt;/code&gt;, which override the number-of-distinct-values estimates made by subsequent &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; operations. &lt;code&gt;n_distinct&lt;/code&gt; affects the statistics for the table itself, while &lt;code&gt;n_distinct_inherited&lt;/code&gt; affects the statistics gathered for the table plus its inheritance children. When set to a positive value, &lt;code&gt;ANALYZE&lt;/code&gt; will assume that the column contains exactly the specified number of distinct nonnull values. When set to a negative value, which must be greater than or equal to -1, &lt;code&gt;ANALYZE&lt;/code&gt; will assume that the number of distinct nonnull values in the column is linear in the size of the table; the exact count is to be computed by multiplying the estimated table size by the absolute value of the given number. For example, a value of -1 implies that all values in the column are distinct, while a value of -0.5 implies that each value appears twice on the average. This can be useful when the size of the table changes over time, since the multiplication by the number of rows in the table is not performed until query planning time. Specify a value of 0 to revert to estimating the number of distinct values normally. For more information on the use of statistics by the PostgreSQL query planner, refer to &lt;a href=&quot;planner-stats&quot;&gt;Section 14.2&lt;/a&gt;.</source>
          <target state="translated">此表单设置或重置每个属性选项。当前，唯一定义的按属性的选项是 &lt;code&gt;n_distinct&lt;/code&gt; 和 &lt;code&gt;n_distinct_inherited&lt;/code&gt; ，它们覆盖了随后的&lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt;操作所做的不同值估计数。 &lt;code&gt;n_distinct&lt;/code&gt; 影响表本身的统计信息，而 &lt;code&gt;n_distinct_inherited&lt;/code&gt; 影响为表及其继承子级收集的统计信息。当设置为正值时， &lt;code&gt;ANALYZE&lt;/code&gt; 将假定该列恰好包含指定数量的不同非空值。设置为负值时，必须大于或等于-1，然后进行 &lt;code&gt;ANALYZE&lt;/code&gt; 将假定该列中不同的非空值的数量在表的大小上是线性的；确切的计数将通过将估计的表大小乘以给定数字的绝对值来计算。例如，值-1表示该列中的所有值都是不同的，而值-0.5表示每个值平均出现两次。当表的大小随时间变化时，这很有用，因为直到查询计划时间才执行表中行数的乘法。将值指定为0可恢复为通常估计不同值的数量。有关PostgreSQL查询计划程序使用统计信息的更多信息，请参见&lt;a href=&quot;planner-stats&quot;&gt;14.2节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="895b894f198c38b8b568f74baad8144867fc06d4" translate="yes" xml:space="preserve">
          <source>This form sets or resets per-attribute options. See the similar form of &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; for more details.</source>
          <target state="translated">此表单设置或重置每个属性选项。有关更多详细信息，请参见类似形式的&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="740f7c9cb8ed05218d4d039f1aa9f624d452a1af" translate="yes" xml:space="preserve">
          <source>This form sets the per-column statistics-gathering target for subsequent &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; operations, though can be used only on index columns that are defined as an expression. Since expressions lack a unique name, we refer to them using the ordinal number of the index column. The target can be set in the range 0 to 10000; alternatively, set it to -1 to revert to using the system default statistics target (&lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt;). For more information on the use of statistics by the PostgreSQL query planner, refer to &lt;a href=&quot;planner-stats&quot;&gt;Section 14.2&lt;/a&gt;.</source>
          <target state="translated">尽管只能在定义为表达式的索引列上使用，但此表格为后续&lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt;操作设置了每列统计信息收集目标。由于表达式缺少唯一名称，因此我们使用索引列的序号来引用它们。可以在0到10000范围内设置目标。或者，将其设置为-1以恢复为使用系统默认统计信息目标（&lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt;）。有关PostgreSQL查询计划程序使用统计信息的更多信息，请参见&lt;a href=&quot;planner-stats&quot;&gt;14.2节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="25d5f18188deb36d3de2faca967992d3efc2b40a" translate="yes" xml:space="preserve">
          <source>This form sets the per-column statistics-gathering target for subsequent &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; operations. See the similar form of &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; for more details.</source>
          <target state="translated">该表格为随后的&lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt;操作设置了每个列的统计信息收集目标。有关更多详细信息，请参见类似形式的&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6332f7067a3fb1b7b86c9dc56f927e587c384e78" translate="yes" xml:space="preserve">
          <source>This form sets the per-column statistics-gathering target for subsequent &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; operations. The target can be set in the range 0 to 10000; alternatively, set it to -1 to revert to using the system default statistics target (&lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt;). For more information on the use of statistics by the PostgreSQL query planner, refer to &lt;a href=&quot;planner-stats&quot;&gt;Section 14.2&lt;/a&gt;.</source>
          <target state="translated">该表格为随后的&lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt;操作设置了每个列的统计信息收集目标。可以在0到10000范围内设置目标。或者，将其设置为-1以恢复为使用系统默认统计信息目标（&lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt;）。有关PostgreSQL查询计划程序使用统计信息的更多信息，请参见&lt;a href=&quot;planner-stats&quot;&gt;14.2节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4211581d9cac601dcf30af9c236c2e568347e8dc" translate="yes" xml:space="preserve">
          <source>This form sets the storage mode for a column. See the similar form of &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; for more details. Note that the storage mode has no effect unless the table's foreign-data wrapper chooses to pay attention to it.</source>
          <target state="translated">该表格设置列的存储模式。有关更多详细信息，请参见类似形式的&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;。请注意，除非表的外部数据包装程序选择注意它，否则存储模式无效。</target>
        </trans-unit>
        <trans-unit id="647ec6a7abe325c2f43beddebcddae6af6d3e9e1" translate="yes" xml:space="preserve">
          <source>This form sets the storage mode for a column. This controls whether this column is held inline or in a secondary TOAST table, and whether the data should be compressed or not. &lt;code&gt;PLAIN&lt;/code&gt; must be used for fixed-length values such as &lt;code&gt;integer&lt;/code&gt; and is inline, uncompressed. &lt;code&gt;MAIN&lt;/code&gt; is for inline, compressible data. &lt;code&gt;EXTERNAL&lt;/code&gt; is for external, uncompressed data, and &lt;code&gt;EXTENDED&lt;/code&gt; is for external, compressed data. &lt;code&gt;EXTENDED&lt;/code&gt; is the default for most data types that support non-&lt;code&gt;PLAIN&lt;/code&gt; storage. Use of &lt;code&gt;EXTERNAL&lt;/code&gt; will make substring operations on very large &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;bytea&lt;/code&gt; values run faster, at the penalty of increased storage space. Note that &lt;code&gt;SET STORAGE&lt;/code&gt; doesn't itself change anything in the table, it just sets the strategy to be pursued during future table updates. See &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt; for more information.</source>
          <target state="translated">此表单设置列的存储模式。这控制此列是内联还是在辅助TOAST表中，以及是否应压缩数据。 &lt;code&gt;PLAIN&lt;/code&gt; 必须用于固定长度的值，例如 &lt;code&gt;integer&lt;/code&gt; 并且是内联的，未压缩的。 &lt;code&gt;MAIN&lt;/code&gt; 用于内联可压缩数据。 &lt;code&gt;EXTERNAL&lt;/code&gt; 用于外部未压缩数据，而 &lt;code&gt;EXTENDED&lt;/code&gt; 用于外部未压缩数据。 &lt;code&gt;EXTENDED&lt;/code&gt; 是大多数支持非 &lt;code&gt;PLAIN&lt;/code&gt; 存储的数据类型的默认设置。使用 &lt;code&gt;EXTERNAL&lt;/code&gt; 将对非常大的 &lt;code&gt;text&lt;/code&gt; 和 &lt;code&gt;bytea&lt;/code&gt; 进行子字符串操作值运行得更快，但会增加存储空间。请注意， &lt;code&gt;SET STORAGE&lt;/code&gt; 本身不会更改表中的任何内容，它只是设置要在将来的表更新中采用的策略。有关更多信息，请参见&lt;a href=&quot;storage-toast&quot;&gt;第68.2节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ec13ec4434f4e2b65ae05d1be4e2e6176c623511" translate="yes" xml:space="preserve">
          <source>This form specifies a transition that always happens during the same month and on the same day of the week. &lt;code&gt;m&lt;/code&gt; identifies the month, from 1 to 12. &lt;code&gt;n&lt;/code&gt; specifies the &lt;code&gt;n&lt;/code&gt;'th occurrence of the weekday identified by &lt;code&gt;d&lt;/code&gt;. &lt;code&gt;n&lt;/code&gt; is a number between 1 and 4, or 5 meaning the last occurrence of that weekday in the month (which could be the fourth or the fifth). &lt;code&gt;d&lt;/code&gt; is a number between 0 and 6, with 0 indicating Sunday. For example, &lt;code&gt;M3.2.0&lt;/code&gt; means &amp;ldquo;the second Sunday in March&amp;rdquo;.</source>
          <target state="translated">此表单指定始终在同一月份和一周的同一天发生的过渡。 &lt;code&gt;m&lt;/code&gt; 标识从1到12的月份 &lt;code&gt;n&lt;/code&gt; 指定 &lt;code&gt;d&lt;/code&gt; 标识的工作日的第 &lt;code&gt;n&lt;/code&gt; 次出现。 &lt;code&gt;n&lt;/code&gt; 是1到4之间的数字，或5，表示月份中该工作日的最后一次出现（可能是第四或第五）。 &lt;code&gt;d&lt;/code&gt; 是0到6之间的数字，0表示星期日。例如， &lt;code&gt;M3.2.0&lt;/code&gt; 的意思是&amp;ldquo;三月的第二个星期日&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="909f4c3b4cbf68b6bdfe371c2a727fe6e1f1cf31" translate="yes" xml:space="preserve">
          <source>This form turns a stored generated column into a normal base column. Existing data in the columns is retained, but future changes will no longer apply the generation expression.</source>
          <target state="translated">这个表单将存储生成的列变成了一个正常的基础列。列中的现有数据将被保留,但未来的更改将不再应用生成表达式。</target>
        </trans-unit>
        <trans-unit id="79e59ee7d655fea5f293a39645cf958df6f59eaa" translate="yes" xml:space="preserve">
          <source>This form updates the extension to a newer version. The extension must supply a suitable update script (or series of scripts) that can modify the currently-installed version into the requested version.</source>
          <target state="translated">此表将扩展程序更新到一个较新的版本。该扩展必须提供一个合适的更新脚本(或一系列脚本),可以将当前安装的版本修改为所要求的版本。</target>
        </trans-unit>
        <trans-unit id="54be61b37045a65ad5af5b24265bf2d2fe56613b" translate="yes" xml:space="preserve">
          <source>This form validates a constraint previously added as &lt;code&gt;NOT VALID&lt;/code&gt;, that is, it verifies that all values in table columns of the domain type satisfy the specified constraint.</source>
          <target state="translated">此表单验证先前添加为 &lt;code&gt;NOT VALID&lt;/code&gt; 的约束，即，它验证域类型的表列中的所有值均满足指定的约束。</target>
        </trans-unit>
        <trans-unit id="7fae39d4d329b60aa027a709db925fb7a0b45aad" translate="yes" xml:space="preserve">
          <source>This form validates a foreign key or check constraint that was previously created as &lt;code&gt;NOT VALID&lt;/code&gt;, by scanning the table to ensure there are no rows for which the constraint is not satisfied. Nothing happens if the constraint is already marked valid. (See &lt;a href=&quot;sql-altertable#SQL-ALTERTABLE-NOTES&quot;&gt;Notes&lt;/a&gt; below for an explanation of the usefulness of this command.)</source>
          <target state="translated">此表单通过扫描表以确保没有不满足约束条件的行，从而验证先前创建为 &lt;code&gt;NOT VALID&lt;/code&gt; 的外键或检查约束条件。如果约束已被标记为有效，则什么也不会发生。（见&lt;a href=&quot;sql-altertable#SQL-ALTERTABLE-NOTES&quot;&gt;注释&lt;/a&gt;下面这个命令的有效性的说明。）</target>
        </trans-unit>
        <trans-unit id="6d527b3923e336e8d7e873c75f29f0a2a678c450" translate="yes" xml:space="preserve">
          <source>This format option is used for importing and exporting the Comma Separated Value (&lt;code&gt;CSV&lt;/code&gt;) file format used by many other programs, such as spreadsheets. Instead of the escaping rules used by PostgreSQL's standard text format, it produces and recognizes the common CSV escaping mechanism.</source>
          <target state="translated">此格式选项用于导入和导出许多其他程序（例如电子表格）使用的逗号分隔值（ &lt;code&gt;CSV&lt;/code&gt; ）文件格式。它会生成并识别常见的CSV转义机制，而不是PostgreSQL的标准文本格式使用转义规则。</target>
        </trans-unit>
        <trans-unit id="792a63854d692e136337a8efffc52744faba871f" translate="yes" xml:space="preserve">
          <source>This function accepts, but does not require, the VARIADIC keyword. It tolerates both integer and numeric arguments:</source>
          <target state="translated">这个函数接受,但不要求VARIADIC关键字。它可以接受整数和数字参数。</target>
        </trans-unit>
        <trans-unit id="384addc1a1dba581b09ffbc6f99227a9381c9da3" translate="yes" xml:space="preserve">
          <source>This function applies the XSL stylesheet to the document and returns the transformed result. The &lt;code&gt;paramlist&lt;/code&gt; is a list of parameter assignments to be used in the transformation, specified in the form &lt;code&gt;a=1,b=2&lt;/code&gt;. Note that the parameter parsing is very simple-minded: parameter values cannot contain commas!</source>
          <target state="translated">此函数将XSL样式表应用于文档并返回转换后的结果。该 &lt;code&gt;paramlist&lt;/code&gt; 是在变换中使用的参数分配的列表，形式指定 &lt;code&gt;a=1,b=2&lt;/code&gt; 。请注意，参数解析非常简单：参数值不能包含逗号！</target>
        </trans-unit>
        <trans-unit id="0ee207b4a33861c6094ba8a46213a951afdbd72c" translate="yes" xml:space="preserve">
          <source>This function calculates the Levenshtein distance between two strings:</source>
          <target state="translated">该函数计算两根弦之间的列文斯丁距离。</target>
        </trans-unit>
        <trans-unit id="c2569b9ec2f2f240b538364988cd2b660c7bc809" translate="yes" xml:space="preserve">
          <source>This function calculates the metaphone code of an input string:</source>
          <target state="translated">该函数计算输入字符串的元音代码。</target>
        </trans-unit>
        <trans-unit id="b833dadc47320ce5093b7875a4e223019bb7f287" translate="yes" xml:space="preserve">
          <source>This function computes the &lt;em&gt;cover density&lt;/em&gt; ranking for the given document vector and query, as described in Clarke, Cormack, and Tudhope's &quot;Relevance Ranking for One to Three Term Queries&quot; in the journal &quot;Information Processing and Management&quot;, 1999. Cover density is similar to &lt;code&gt;ts_rank&lt;/code&gt; ranking except that the proximity of matching lexemes to each other is taken into consideration.</source>
          <target state="translated">此函数计算给定文档向量和查询的&lt;em&gt;覆盖密度&lt;/em&gt;等级，如Clarke，Cormack和Tudhope的&amp;ldquo;一到三个查询的相关性排名&amp;rdquo;在1999年《信息处理与管理》杂志中所述。覆盖密度相似到 &lt;code&gt;ts_rank&lt;/code&gt; 排名，只是考虑了匹配词素彼此之间的接近程度。</target>
        </trans-unit>
        <trans-unit id="83d7f3c8b4315f521db79931ac5b0419f7f02e44" translate="yes" xml:space="preserve">
          <source>This function generates a version 1 UUID but uses a random multicast MAC address instead of the real MAC address of the computer.</source>
          <target state="translated">该函数生成版本1的UUID,但使用随机的多播MAC地址代替计算机的真实MAC地址。</target>
        </trans-unit>
        <trans-unit id="0d47dfa9e9b8d5b7fbb04b1e480b39cea1dce637" translate="yes" xml:space="preserve">
          <source>This function generates a version 1 UUID. This involves the MAC address of the computer and a time stamp. Note that UUIDs of this kind reveal the identity of the computer that created the identifier and the time at which it did so, which might make it unsuitable for certain security-sensitive applications.</source>
          <target state="translated">这个功能会生成一个版本1的UUID。这包括计算机的MAC地址和一个时间戳。请注意,这种UUID暴露了创建标识符的计算机的身份和创建时间,这可能使它不适合某些安全敏感的应用程序。</target>
        </trans-unit>
        <trans-unit id="0487e417e0c4d9dd43a18530572f4217e42f12de" translate="yes" xml:space="preserve">
          <source>This function generates a version 3 UUID in the given namespace using the specified input name. The namespace should be one of the special constants produced by the &lt;code&gt;uuid_ns_*()&lt;/code&gt; functions shown in &lt;a href=&quot;uuid-ossp#UUID-OSSP-CONSTANTS&quot;&gt;Table F.33&lt;/a&gt;. (It could be any UUID in theory.) The name is an identifier in the selected namespace.</source>
          <target state="translated">此函数使用指定的输入名称在给定的名称空间中生成版本3 UUID。名称空间应该是由&lt;a href=&quot;uuid-ossp#UUID-OSSP-CONSTANTS&quot;&gt;表F.33中&lt;/a&gt;显示的 &lt;code&gt;uuid_ns_*()&lt;/code&gt; 函数产生的特殊常量之一。（理论上可以是任何UUID。）名称是所选名称空间中的标识符。</target>
        </trans-unit>
        <trans-unit id="815458cef4730e8a9276e3ff8e0d57eb7d786adf" translate="yes" xml:space="preserve">
          <source>This function generates a version 4 UUID, which is derived entirely from random numbers.</source>
          <target state="translated">这个函数可以生成一个版本4的UUID,这个UUID完全来自于随机数。</target>
        </trans-unit>
        <trans-unit id="70e04d40259f3b4e398eaecf4565ce5668726dbd" translate="yes" xml:space="preserve">
          <source>This function generates a version 5 UUID, which works like a version 3 UUID except that SHA-1 is used as a hashing method. Version 5 should be preferred over version 3 because SHA-1 is thought to be more secure than MD5.</source>
          <target state="translated">这个函数生成一个版本5的UUID,除了使用SHA-1作为散列方法之外,它的工作原理和版本3的UUID一样。第5版应该比第3版优先,因为SHA-1被认为比MD5更安全。</target>
        </trans-unit>
        <trans-unit id="e0a3bf72d056e543baff831854a2b9328ece5e35" translate="yes" xml:space="preserve">
          <source>This function is described in &lt;a href=&quot;functions-srf#FUNCTIONS-SRF-SUBSCRIPTS&quot;&gt;Table 9.62&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions-srf#FUNCTIONS-SRF-SUBSCRIPTS&quot;&gt;表9.62中&lt;/a&gt;描述了此功能。</target>
        </trans-unit>
        <trans-unit id="c9a6e7f01cec14b42f0b87924ed8025472ae1b3d" translate="yes" xml:space="preserve">
          <source>This function is really useful only if you have more than one trusted CA certificate in your server's certificate authority file, or if this CA has issued some intermediate certificate authority certificates.</source>
          <target state="translated">只有当你的服务器的证书授权文件中有不止一个受信任的CA证书,或者这个CA颁发了一些中间证书授权证书时,这个功能才真正有用。</target>
        </trans-unit>
        <trans-unit id="63ff3f7ccdd8e65ce06124599f3ab0770c0133c3" translate="yes" xml:space="preserve">
          <source>This function is restricted to superusers and members of the &lt;code&gt;pg_monitor&lt;/code&gt; role by default, but other users can be granted EXECUTE to run the function.</source>
          <target state="translated">默认情况下，此函数仅限于超级用户和 &lt;code&gt;pg_monitor&lt;/code&gt; 角色的成员，但可以授予其他用户EXECUTE运行该函数的权限。</target>
        </trans-unit>
        <trans-unit id="e52438a2973580a90569d73e97b9438c5b2a81d3" translate="yes" xml:space="preserve">
          <source>This function is restricted to superusers by default, but other users can be granted EXECUTE to run the function.</source>
          <target state="translated">该函数默认只限于超级用户,但其他用户可以被授予EXECUTE来运行该函数。</target>
        </trans-unit>
        <trans-unit id="09caa14af8239e8fd0fef2257c67a191f1fcb7c5" translate="yes" xml:space="preserve">
          <source>This function is used implicitly when an &lt;code&gt;hstore&lt;/code&gt; value is cast to &lt;code&gt;json&lt;/code&gt;.</source>
          <target state="translated">当将 &lt;code&gt;hstore&lt;/code&gt; 值强制转换为 &lt;code&gt;json&lt;/code&gt; 时，将隐式使用此函数。</target>
        </trans-unit>
        <trans-unit id="07a9fbad99c6b946ee2810aa1613797169567ed3" translate="yes" xml:space="preserve">
          <source>This function is used implicitly when an &lt;code&gt;hstore&lt;/code&gt; value is cast to &lt;code&gt;jsonb&lt;/code&gt;.</source>
          <target state="translated">当将 &lt;code&gt;hstore&lt;/code&gt; 值 &lt;code&gt;jsonb&lt;/code&gt; 为jsonb时，将隐式使用此函数。</target>
        </trans-unit>
        <trans-unit id="52b67ed61bf91babfe5b1fd62f929a40f3153129" translate="yes" xml:space="preserve">
          <source>This function requires &lt;code id=&quot;update&quot;&gt;UPDATE&lt;/code&gt; privilege on the sequence.</source>
          <target state="translated">此功能需要序列的 &lt;code id=&quot;update&quot;&gt;UPDATE&lt;/code&gt; 特权。</target>
        </trans-unit>
        <trans-unit id="c3bba3a33d3476c85ef64f965448f29b348576cf" translate="yes" xml:space="preserve">
          <source>This function requires &lt;code id=&quot;usage&quot;&gt;USAGE&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; privilege on the sequence.</source>
          <target state="translated">此功能需要序列具有 &lt;code id=&quot;usage&quot;&gt;USAGE&lt;/code&gt; 或 &lt;code&gt;UPDATE&lt;/code&gt; 特权。</target>
        </trans-unit>
        <trans-unit id="5b1d41d04bdf06be2e37d1f0ae8845458954a418" translate="yes" xml:space="preserve">
          <source>This function requires &lt;code&gt;UPDATE&lt;/code&gt; privilege on the sequence.</source>
          <target state="translated">此功能需要序列的 &lt;code&gt;UPDATE&lt;/code&gt; 特权。</target>
        </trans-unit>
        <trans-unit id="e39f1ca89945df262cf69293c102551266551425" translate="yes" xml:space="preserve">
          <source>This function requires &lt;code&gt;USAGE&lt;/code&gt; or &lt;code&gt;SELECT&lt;/code&gt; privilege on the last used sequence.</source>
          <target state="translated">该功能需要最后使用的序列具有 &lt;code&gt;USAGE&lt;/code&gt; 或 &lt;code&gt;SELECT&lt;/code&gt; 特权。</target>
        </trans-unit>
        <trans-unit id="9f01c920de003b371748d82ceb88ff4c45aff8e2" translate="yes" xml:space="preserve">
          <source>This function requires &lt;code&gt;USAGE&lt;/code&gt; or &lt;code&gt;SELECT&lt;/code&gt; privilege on the sequence.</source>
          <target state="translated">此功能要求序列具有 &lt;code&gt;USAGE&lt;/code&gt; 或 &lt;code&gt;SELECT&lt;/code&gt; 特权。</target>
        </trans-unit>
        <trans-unit id="67164ea85a2954ef16cf5fcf220bb12c3b615043" translate="yes" xml:space="preserve">
          <source>This function requires &lt;code&gt;USAGE&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; privilege on the sequence.</source>
          <target state="translated">此功能需要序列具有 &lt;code&gt;USAGE&lt;/code&gt; 或 &lt;code&gt;UPDATE&lt;/code&gt; 特权。</target>
        </trans-unit>
        <trans-unit id="7e54a0efd46907c22c610b8b23cccd57e0bcbc37" translate="yes" xml:space="preserve">
          <source>This function requires lexeme positional information to perform its calculation. Therefore, it ignores any &amp;ldquo;stripped&amp;rdquo; lexemes in the &lt;code&gt;tsvector&lt;/code&gt;. If there are no unstripped lexemes in the input, the result will be zero. (See &lt;a href=&quot;textsearch-features#TEXTSEARCH-MANIPULATE-TSVECTOR&quot;&gt;Section 12.4.1&lt;/a&gt; for more information about the &lt;code&gt;strip&lt;/code&gt; function and positional information in &lt;code&gt;tsvector&lt;/code&gt;s.)</source>
          <target state="translated">此功能需要词素位置信息来执行其计算。因此，它会忽略 &lt;code&gt;tsvector&lt;/code&gt; 中的任何&amp;ldquo;剥离&amp;rdquo;词素。如果输入中没有解串的词素，则结果将为零。（有关 &lt;code&gt;strip&lt;/code&gt; 函数的更多信息和 &lt;code&gt;tsvector&lt;/code&gt; 中的位置信息，请参见&lt;a href=&quot;textsearch-features#TEXTSEARCH-MANIPULATE-TSVECTOR&quot;&gt;第12.4.1节&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="c1856db892a00b2e43b297b0dbc4109fce353620" translate="yes" xml:space="preserve">
          <source>This function returns a value that can be approximately understood as the greatest similarity between the first string and any substring of the second string. However, this function does not add padding to the boundaries of the extent. Thus, the number of additional characters present in the second string is not considered, except for the mismatched word boundaries.</source>
          <target state="translated">这个函数返回一个值,这个值可以大致理解为第一个字符串和第二个字符串的任何子串之间的最大相似度。但是,这个函数不会在范围的边界上添加填充物。因此,除了不匹配的字的边界外,不考虑第二个字符串中存在的附加字符数。</target>
        </trans-unit>
        <trans-unit id="0221605a1cce6baf0cb85c01f2888179ec394f70" translate="yes" xml:space="preserve">
          <source>This function returns a version 4 (random) UUID. This is the most commonly used type of UUID and is appropriate for most applications.</source>
          <target state="translated">这个函数返回一个版本4(随机)的UUID,这是最常用的UUID类型,适用于大多数应用程序。这是最常用的UUID类型,适用于大多数应用程序。</target>
        </trans-unit>
        <trans-unit id="45aa18780b259bc2744ab8ff0666ff85306321c0" translate="yes" xml:space="preserve">
          <source>This function returns multiple values separated by the specified separator, for example &lt;code&gt;Value 1,Value 2,Value 3&lt;/code&gt; if separator is &lt;code&gt;,&lt;/code&gt;.</source>
          <target state="translated">此函数返回由指定分隔符分隔的多个值，例如 &lt;code&gt;Value 1,Value 2,Value 3&lt;/code&gt; 如果分隔符为 &lt;code&gt;,&lt;/code&gt; 则值为1、2、3。</target>
        </trans-unit>
        <trans-unit id="a92a46b380193cb9c54f2eb12d510b84b0bf579e" translate="yes" xml:space="preserve">
          <source>This function returns the value of the specified field in the certificate subject, or NULL if the field is not present. Field names are string constants that are converted into ASN1 object identifiers using the OpenSSL object database. The following values are acceptable:</source>
          <target state="translated">该函数返回证书主体中指定字段的值,如果不存在该字段,则返回NULL。字段名是字符串常量,使用OpenSSL对象数据库转换为ASN1对象标识符。下面的值是可以接受的。</target>
        </trans-unit>
        <trans-unit id="50cb6130584a2ccc2fd56083455360b1df842976" translate="yes" xml:space="preserve">
          <source>This function should be called with the same arguments as the return attributes of &lt;code&gt;heap_page_items&lt;/code&gt;.</source>
          <target state="translated">应该使用与 &lt;code&gt;heap_page_items&lt;/code&gt; 的返回属性相同的参数调用此函数。</target>
        </trans-unit>
        <trans-unit id="3bf22c93b0d832b9656f660c278a124c39df4dd9" translate="yes" xml:space="preserve">
          <source>This function terminates backup mode and performs an automatic switch to the next WAL segment. The reason for the switch is to arrange for the last WAL segment written during the backup interval to be ready to archive.</source>
          <target state="translated">此功能可终止备份模式,并自动切换到下一个 WAL 段。切换的原因是安排在备份间隔期间写入的最后一个 WAL 段准备归档。</target>
        </trans-unit>
        <trans-unit id="2aad428f96b8431576d3176be3a80d4e1c2a4447" translate="yes" xml:space="preserve">
          <source>This function will be called to initialize dynamic shared memory at the beginning of a parallel scan. &lt;em&gt;&lt;code&gt;target&lt;/code&gt;&lt;/em&gt; will point to at least the number of bytes previously returned by &lt;code&gt;amestimateparallelscan&lt;/code&gt;, and this function may use that amount of space to store whatever data it wishes.</source>
          <target state="translated">在并行扫描开始时，将调用此函数来初始化动态共享内存。&lt;em&gt; &lt;code&gt;target&lt;/code&gt; &lt;/em&gt;将至少指向 &lt;code&gt;amestimateparallelscan&lt;/code&gt; 先前返回的字节数，并且此函数可以使用该空间量来存储所需的任何数据。</target>
        </trans-unit>
        <trans-unit id="9031a619f108cfe873afc670225222a731f98ca3" translate="yes" xml:space="preserve">
          <source>This function's intention is to access a table &lt;code&gt;admin.pwds&lt;/code&gt;. But without the &lt;code&gt;SET&lt;/code&gt; clause, or with a &lt;code&gt;SET&lt;/code&gt; clause mentioning only &lt;code&gt;admin&lt;/code&gt;, the function could be subverted by creating a temporary table named &lt;code&gt;pwds&lt;/code&gt;.</source>
          <target state="translated">该函数的目的是访问表 &lt;code&gt;admin.pwds&lt;/code&gt; 。但是如果没有 &lt;code&gt;SET&lt;/code&gt; 子句，或者没有 &lt;code&gt;SET&lt;/code&gt; 子句仅提及 &lt;code&gt;admin&lt;/code&gt; ，则可以通过创建一个名为 &lt;code&gt;pwds&lt;/code&gt; 的临时表来破坏该功能。</target>
        </trans-unit>
        <trans-unit id="74eda98e312717a7e3761e1be3fed4cfe413013a" translate="yes" xml:space="preserve">
          <source>This function, if implemented, will be called when a parallel index scan must be restarted. It should reset any shared state set up by &lt;code&gt;aminitparallelscan&lt;/code&gt; such that the scan will be restarted from the beginning.</source>
          <target state="translated">如果必须执行此函数，则在必须重新启动并行索引扫描时将调用该函数。它应该重置由 &lt;code&gt;aminitparallelscan&lt;/code&gt; 设置的任何共享状态，以便从头开始重新启动扫描。</target>
        </trans-unit>
        <trans-unit id="ba0d2d4c762ce91e9a46761e7e3115cef1d26dc7" translate="yes" xml:space="preserve">
          <source>This group of commands implements nestable conditional blocks, similarly to &lt;code&gt;psql&lt;/code&gt;'s &lt;a href=&quot;app-psql#PSQL-METACOMMAND-IF&quot;&gt;&lt;code&gt;\if&lt;/code&gt; &lt;code&gt;expression&lt;/code&gt;&lt;/a&gt;. Conditional expressions are identical to those with &lt;code&gt;\set&lt;/code&gt;, with non-zero values interpreted as true.</source>
          <target state="translated">这组命令实现了可嵌套的条件块，类似于 &lt;code&gt;psql&lt;/code&gt; 的&lt;a href=&quot;app-psql#PSQL-METACOMMAND-IF&quot;&gt; &lt;code&gt;\if&lt;/code&gt; &lt;code&gt;expression&lt;/code&gt; &lt;/a&gt;。条件表达式与 &lt;code&gt;\set&lt;/code&gt; 相同，其中非零值解释为true。</target>
        </trans-unit>
        <trans-unit id="a86a1c85779a67bdb4c07c083dc8d1a736ba45ad" translate="yes" xml:space="preserve">
          <source>This group of commands implements nestable conditional blocks. A conditional block must begin with an &lt;code&gt;\if&lt;/code&gt; and end with an &lt;code&gt;\endif&lt;/code&gt;. In between there may be any number of &lt;code&gt;\elif&lt;/code&gt; clauses, which may optionally be followed by a single &lt;code&gt;\else&lt;/code&gt; clause. Ordinary queries and other types of backslash commands may (and usually do) appear between the commands forming a conditional block.</source>
          <target state="translated">这组命令实现了可嵌套的条件块。条件块必须以 &lt;code&gt;\if&lt;/code&gt; 开始，并以 &lt;code&gt;\endif&lt;/code&gt; 结尾。在两者之间可以有任意数量的 &lt;code&gt;\elif&lt;/code&gt; 子句，可以选择在其后跟一个 &lt;code&gt;\else&lt;/code&gt; 子句。普通查询和其他类型的反斜杠命令可能会（并且通常会）出现在形成条件块的命令之间。</target>
        </trans-unit>
        <trans-unit id="44140a36cc7df2f1c3a52fdc81c7272717604999" translate="yes" xml:space="preserve">
          <source>This happens because an hour was skipped due to a change in daylight saving time at &lt;code&gt;2005-04-03 02:00:00&lt;/code&gt; in time zone &lt;code&gt;America/Denver&lt;/code&gt;.</source>
          <target state="translated">发生这种情况的原因是，由于夏令时在 &lt;code&gt;2005-04-03 02:00:00&lt;/code&gt; 时区 &lt;code&gt;America/Denver&lt;/code&gt; 中的更改而跳过了一个小时。</target>
        </trans-unit>
        <trans-unit id="0b11efb2c7cb913b726605094c75fda2e8cad938" translate="yes" xml:space="preserve">
          <source>This happens because the system cannot decide which of the several possible &lt;code&gt;~&lt;/code&gt; operators should be preferred. We can help it out with an explicit cast:</source>
          <target state="translated">发生这种情况是因为系统无法确定应优先选择几个可能的 &lt;code&gt;~&lt;/code&gt; 运算符中的哪一个。我们可以通过显式转换来帮助它：</target>
        </trans-unit>
        <trans-unit id="1adefa35377cadd1c8a75aec2fb42a29f31a0dd0" translate="yes" xml:space="preserve">
          <source>This has the same effect as casting each expression to the array element type individually. For more on casting, see &lt;a href=&quot;sql-expressions#SQL-SYNTAX-TYPE-CASTS&quot;&gt;Section 4.2.9&lt;/a&gt;.</source>
          <target state="translated">这与将每个表达式分别转换为数组元素类型具有相同的效果。有关转换的更多信息，请参见&lt;a href=&quot;sql-expressions#SQL-SYNTAX-TYPE-CASTS&quot;&gt;第4.2.9节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a60511ea52748a75870fb82ff05a5c564394ceb2" translate="yes" xml:space="preserve">
          <source>This heuristic can be overridden, forcing the server to use either generic or custom plans, by setting &lt;code&gt;plan_cache_mode&lt;/code&gt; to &lt;code&gt;force_generic_plan&lt;/code&gt; or &lt;code&gt;force_custom_plan&lt;/code&gt; respectively. This setting is primarily useful if the generic plan's cost estimate is badly off for some reason, allowing it to be chosen even though its actual cost is much more than that of a custom plan.</source>
          <target state="translated">这种启发式可以否决，迫使服务器为使用通用的或定制的计划，通过设置 &lt;code&gt;plan_cache_mode&lt;/code&gt; 到 &lt;code&gt;force_generic_plan&lt;/code&gt; 或 &lt;code&gt;force_custom_plan&lt;/code&gt; 分别。如果通用计划的成本估算由于某些原因而严重欠缺，即使实际成本比自定义计划的实际成本高得多，也可以选择此设置。</target>
        </trans-unit>
        <trans-unit id="3ceb81116f5e1034358e4c68c702f99fa463a7e9" translate="yes" xml:space="preserve">
          <source>This implies that if a table is not otherwise vacuumed, autovacuum will be invoked on it approximately once every &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; minus &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt; transactions. For tables that are regularly vacuumed for space reclamation purposes, this is of little importance. However, for static tables (including tables that receive inserts, but no updates or deletes), there is no need to vacuum for space reclamation, so it can be useful to try to maximize the interval between forced autovacuums on very large static tables. Obviously one can do this either by increasing &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; or decreasing &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt;.</source>
          <target state="translated">这意味着，如果不对表进行其他 &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt; ，则每隔 &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; 减去vacuum_freeze_min_age事务，大约将在其上调用一次autovacuum。对于定期清理以回收空间的桌子，这并不重要。但是，对于静态表（包括接收插入但不进行更新或删除的表），不需要进行空间回收的清理，因此尝试在非常大的静态表上最大化强制自动清理之间的间隔会很有用。显然，可以通过增加 &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; 或减小 &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt; 来做到这一点。</target>
        </trans-unit>
        <trans-unit id="963c171b1310567729b0c667a3982a8159857c0a" translate="yes" xml:space="preserve">
          <source>This includes issues caused by the comparison rules of operating system collations changing. Comparisons of datums of a collatable type like &lt;code&gt;text&lt;/code&gt; must be immutable (just as all comparisons used for B-Tree index scans must be immutable), which implies that operating system collation rules must never change. Though rare, updates to operating system collation rules can cause these issues. More commonly, an inconsistency in the collation order between a master server and a standby server is implicated, possibly because the &lt;em&gt;major&lt;/em&gt; operating system version in use is inconsistent. Such inconsistencies will generally only arise on standby servers, and so can generally only be detected on standby servers.</source>
          <target state="translated">这包括由操作系统归类的比较规则更改引起的问题。可排序类型（如 &lt;code&gt;text&lt;/code&gt; 的基准比较必须是不可变的（就像用于B树索引扫描的所有比较都必须是不可变的），这意味着操作系统排序规则永远不能更改。尽管很少，但对操作系统整理规则的更新可能会导致这些问题。更常见的是，牵涉到主服务器和备用服务器之间的排序顺序不一致，这可能是因为使用的&lt;em&gt;主要&lt;/em&gt;操作系统版本不一致。这种不一致通常只会在备用服务器上出现，因此通常只能在备用服务器上检测到。</target>
        </trans-unit>
        <trans-unit id="a867951badfb08df8a9bb92137e4c1059d9fe31b" translate="yes" xml:space="preserve">
          <source>This indicates that the &lt;code&gt;postgres&lt;/code&gt; process has been terminated due to memory pressure. Although existing database connections will continue to function normally, no new connections will be accepted. To recover, PostgreSQL will need to be restarted.</source>
          <target state="translated">这表明由于内存压力， &lt;code&gt;postgres&lt;/code&gt; 进程已终止。尽管现有的数据库连接将继续正常运行，但不会接受任何新连接。要恢复，PostgreSQL将需要重新启动。</target>
        </trans-unit>
        <trans-unit id="0a372cfe5f8eb7d4853999840a603c1c28fd5394" translate="yes" xml:space="preserve">
          <source>This indicates that the most common combination of city and state is Washington in DC, with actual frequency (in the sample) about 0.35%. The base frequency of the combination (as computed from the simple per-column frequencies) is only 0.0027%, resulting in two orders of magnitude under-estimates.</source>
          <target state="translated">这表明,最常见的城市和州的组合是华盛顿特区的华盛顿,实际频率(在样本中)约为0.35%。该组合的基本频率(根据简单的每栏频率计算)仅为0.0027%,导致低估了两个数量级。</target>
        </trans-unit>
        <trans-unit id="e8fe534ccbaaf548c2b11e2912002e72aef917fa" translate="yes" xml:space="preserve">
          <source>This indicates that there are three combinations of columns that have 33178 distinct values: ZIP code and state; ZIP code and city; and ZIP code, city and state (the fact that they are all equal is expected given that ZIP code alone is unique in this table). On the other hand, the combination of city and state has only 27435 distinct values.</source>
          <target state="translated">这表明,有三种列的组合有33178个不同的值。邮政编码和州;邮政编码和城市;以及邮政编码、城市和州(鉴于邮政编码在本表中是唯一的,因此它们都是相等的)。另一方面,城市和州的组合只有27435个不同的值。</target>
        </trans-unit>
        <trans-unit id="fc1f09ba473095924730f620c845acdb222d24ff" translate="yes" xml:space="preserve">
          <source>This involves changes in the backend function API, which is written in the C programming language. Such changes affect code that references backend functions deep inside the server.</source>
          <target state="translated">这涉及到后台函数API的变化,该API是用C编程语言编写的。这种变化会影响到深入服务器内部引用后端函数的代码。</target>
        </trans-unit>
        <trans-unit id="d9a4686c9a5bfa4e42613a92f3eda7d13c48363f" translate="yes" xml:space="preserve">
          <source>This is OK because the subquery is an independent computation that computes its own aggregate separately from what is happening in the outer query.</source>
          <target state="translated">这是好的,因为子查询是一个独立的计算,它与外层查询中发生的事情分开计算自己的集合。</target>
        </trans-unit>
        <trans-unit id="14697b498878040181d5bdcab2a50bb95e660328" translate="yes" xml:space="preserve">
          <source>This is a &lt;code&gt;printf&lt;/code&gt;-style string that is output at the beginning of each log line. &lt;code&gt;%&lt;/code&gt; characters begin &amp;ldquo;escape sequences&amp;rdquo; that are replaced with status information as outlined below. Unrecognized escapes are ignored. Other characters are copied straight to the log line. Some escapes are only recognized by session processes, and will be treated as empty by background processes such as the main server process. Status information may be aligned either left or right by specifying a numeric literal after the % and before the option. A negative value will cause the status information to be padded on the right with spaces to give it a minimum width, whereas a positive value will pad on the left. Padding can be useful to aid human readability in log files.</source>
          <target state="translated">这是一个 &lt;code&gt;printf&lt;/code&gt; 样式的字符串，在每个日志行的开头输出。 &lt;code&gt;%&lt;/code&gt; 字符以&amp;ldquo;转义序列&amp;rdquo;开头，并由状态信息替换，如下所述。无法识别的转义将被忽略。其他字符直接复制到日志行。某些转义仅由会话进程识别，并被诸如主服务器进程之类的后台进程视为空。通过在％之后和该选项之前指定一个数字文字，可以左右对齐状态信息。负值将使状态信息在右侧填充空格以使其具有最小宽度，而正值将在左侧填充。填充有助于提高日志文件的可读性。</target>
        </trans-unit>
        <trans-unit id="1dcf869a044613b3ca0ecf7baf516a8c7193977f" translate="yes" xml:space="preserve">
          <source>This is a &lt;code&gt;printf&lt;/code&gt;-style string that is output at the beginning of each log line. &lt;code&gt;%&lt;/code&gt; characters begin &amp;ldquo;escape sequences&amp;rdquo; that are replaced with status information as outlined below. Unrecognized escapes are ignored. Other characters are copied straight to the log line. Some escapes are only recognized by session processes, and will be treated as empty by background processes such as the main server process. Status information may be aligned either left or right by specifying a numeric literal after the % and before the option. A negative value will cause the status information to be padded on the right with spaces to give it a minimum width, whereas a positive value will pad on the left. Padding can be useful to aid human readability in log files. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. The default is &lt;code&gt;'%m [%p] '&lt;/code&gt; which logs a time stamp and the process ID.</source>
          <target state="translated">这是一个 &lt;code&gt;printf&lt;/code&gt; 样式的字符串，在每个日志行的开头输出。 &lt;code&gt;%&lt;/code&gt; 字符以&amp;ldquo;转义序列&amp;rdquo;开头，并由状态信息替换，如下所述。无法识别的转义将被忽略。其他字符直接复制到日志行。某些转义仅由会话进程识别，并且将由后台进程（例如主服务器进程）视为空。通过在％之后和该选项之前指定数字文字，可以左右对齐状态信息。负值将导致状态信息在右侧填充空格以使其具有最小宽度，而正值将在左侧填充。填充有助于提高日志文件的可读性。此参数只能在 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件或在服务器命令行上。默认值为 &lt;code&gt;'%m [%p] '&lt;/code&gt; ，它记录时间戳记和进程ID。</target>
        </trans-unit>
        <trans-unit id="8b34706e04777a657dce1a4607ff942e4ebc159f" translate="yes" xml:space="preserve">
          <source>This is a B-tree leaf page. All tuples that point to the table happen to be posting list tuples (all of which store a total of 100 6 byte TIDs). There is also a &amp;ldquo;high key&amp;rdquo; tuple at &lt;code&gt;itemoffset&lt;/code&gt; number 1. &lt;code&gt;ctid&lt;/code&gt; is used to store encoded information about each tuple in this example, though leaf page tuples often store a heap TID directly in the &lt;code&gt;ctid&lt;/code&gt; field instead. &lt;code&gt;tids&lt;/code&gt; is the list of TIDs stored as a posting list.</source>
          <target state="translated">这是B树的叶子页面。指向该表的所有元组恰好是发布列表元组（所有这些元组总共存储100个6字节的TID）。在此示例中，项目 &lt;code&gt;itemoffset&lt;/code&gt; 编号为1处还有一个&amp;ldquo;高键&amp;rdquo;元组。尽管叶页元组通常将堆TID直接存储在 &lt;code&gt;ctid&lt;/code&gt; 字段中，但在此示例中， &lt;code&gt;ctid&lt;/code&gt; 用于存储有关每个元组的编码信息。 &lt;code&gt;tids&lt;/code&gt; 是存储为发布列表的TID列表。</target>
        </trans-unit>
        <trans-unit id="c9227695178f5037e0a0e506aca137b88f68d780" translate="yes" xml:space="preserve">
          <source>This is a Boolean option. If true, it specifies that values of the column should not be matched against the null string (that is, the table-level &lt;code&gt;null&lt;/code&gt; option). This has the same effect as listing the column in &lt;code&gt;COPY&lt;/code&gt;'s &lt;code&gt;FORCE_NOT_NULL&lt;/code&gt; option.</source>
          <target state="translated">这是一个布尔选项。如果为true，则指定该列的值不应与null字符串匹配（即表级 &lt;code&gt;null&lt;/code&gt; 选项）。这与在 &lt;code&gt;COPY&lt;/code&gt; 的 &lt;code&gt;FORCE_NOT_NULL&lt;/code&gt; 选项中列出该列具有相同的效果。</target>
        </trans-unit>
        <trans-unit id="bb0f72d78e70cfb965b94342147bb69a1649e537" translate="yes" xml:space="preserve">
          <source>This is a Boolean option. If true, it specifies that values of the column which match the null string are returned as &lt;code&gt;NULL&lt;/code&gt; even if the value is quoted. Without this option, only unquoted values matching the null string are returned as &lt;code&gt;NULL&lt;/code&gt;. This has the same effect as listing the column in &lt;code&gt;COPY&lt;/code&gt;'s &lt;code&gt;FORCE_NULL&lt;/code&gt; option.</source>
          <target state="translated">这是一个布尔选项。如果为true，则指定与空字符串匹配的列的值将被返回为 &lt;code&gt;NULL&lt;/code&gt; ,即使该值被引用了也是如此。如果没有此选项，则仅将与空字符串匹配的未加引号的值作为 &lt;code&gt;NULL&lt;/code&gt; 返回。这与在 &lt;code&gt;COPY&lt;/code&gt; 的 &lt;code&gt;FORCE_NULL&lt;/code&gt; 选项中列出该列具有相同的效果。</target>
        </trans-unit>
        <trans-unit id="d9d802e79acd19a5807b524b5ff1cadf1072e9c9" translate="yes" xml:space="preserve">
          <source>This is a bad idea! Almost certainly, you'll be better off with a single non-partial index, declared like</source>
          <target state="translated">这是个坏主意! 几乎可以肯定的是,你最好使用单一的非部分索引,像这样的声明</target>
        </trans-unit>
        <trans-unit id="2458d33e53e769de251317cb73941c93deac0112" translate="yes" xml:space="preserve">
          <source>This is a deprecated alias for &lt;code id=&quot;6462&quot;&gt;@&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">这是 &lt;code id=&quot;6462&quot;&gt;@&amp;gt;&lt;/code&gt; 的不推荐使用的别名。</target>
        </trans-unit>
        <trans-unit id="e89be01ecc4c51c231fa86cb87027e9f7e872252" translate="yes" xml:space="preserve">
          <source>This is a deprecated synonym for &lt;code id=&quot;6464&quot;&gt;@@&lt;/code&gt;.</source>
          <target state="translated">这是 &lt;code id=&quot;6464&quot;&gt;@@&lt;/code&gt; 的已弃用同义词。</target>
        </trans-unit>
        <trans-unit id="86fd356bbb6f1b1f6f6224d995b8d42e58695e06" translate="yes" xml:space="preserve">
          <source>This is a historical alias for &lt;code id=&quot;stddev_samp&quot;&gt;stddev_samp&lt;/code&gt;.</source>
          <target state="translated">这是 &lt;code id=&quot;stddev_samp&quot;&gt;stddev_samp&lt;/code&gt; 的历史别名。</target>
        </trans-unit>
        <trans-unit id="a9e5af4d8a94f39f1b76df48d0e7c72e55e60307" translate="yes" xml:space="preserve">
          <source>This is a historical alias for &lt;code id=&quot;var_samp&quot;&gt;var_samp&lt;/code&gt;.</source>
          <target state="translated">这是 &lt;code id=&quot;var_samp&quot;&gt;var_samp&lt;/code&gt; 的历史别名。</target>
        </trans-unit>
        <trans-unit id="952c5f2574e0ab3c7c85d004636983a1260b99d7" translate="yes" xml:space="preserve">
          <source>This is a list of acronyms commonly used in the PostgreSQL documentation and in discussions about PostgreSQL.</source>
          <target state="translated">这是PostgreSQL文档和PostgreSQL讨论中常用的缩写词列表。</target>
        </trans-unit>
        <trans-unit id="cba6116424f9b26f41ff31a3536a10c997043100" translate="yes" xml:space="preserve">
          <source>This is a list of terms and their meaning in the context of PostgreSQL and relational database systems in general.</source>
          <target state="translated">这是一个术语列表,以及它们在PostgreSQL和一般关系数据库系统中的含义。</target>
        </trans-unit>
        <trans-unit id="64e0bd441cd585968a19e4596d1d9617026fbc74" translate="yes" xml:space="preserve">
          <source>This is a noise word.</source>
          <target state="translated">这是个噪音词。</target>
        </trans-unit>
        <trans-unit id="e3f9d4c5c7e93766f0b892911d84b9660f77ff3e" translate="yes" xml:space="preserve">
          <source>This is a non-standard syntax for &lt;code&gt;trim()&lt;/code&gt;.</source>
          <target state="translated">这是 &lt;code&gt;trim()&lt;/code&gt; 的非标准语法。</target>
        </trans-unit>
        <trans-unit id="022e58efea267ae2631d535b60729a755677e2e4" translate="yes" xml:space="preserve">
          <source>This is a particularly efficient approach when there are few successful tests and many unsuccessful ones.</source>
          <target state="translated">当成功的测试很少,不成功的测试很多时,这是一种特别有效的方法。</target>
        </trans-unit>
        <trans-unit id="9e8e468a2c09a5e3ff58be6bcf971fcb3102f2b3" translate="yes" xml:space="preserve">
          <source>This is a particularly efficient approach when there are few successful tests and many unsuccessful ones. It is also possible to allow only one null in a column by creating a unique partial index with an &lt;code&gt;IS NULL&lt;/code&gt; restriction.</source>
          <target state="translated">当成功的测试很少而失败的测试很多时，这是一种特别有效的方法。通过创建具有 &lt;code&gt;IS NULL&lt;/code&gt; 限制的唯一局部索引，也可以在列中仅允许一个null 。</target>
        </trans-unit>
        <trans-unit id="b5d2e6129737b2c23b111b25ce903c45a62a32f8" translate="yes" xml:space="preserve">
          <source>This is a sequence of three commands, one per line (although this is not required; more than one command can be on a line, and commands can usefully be split across lines).</source>
          <target state="translated">这是一个由三条命令组成的序列,每行一条(尽管这不是必需的;一行可以有多条命令,而且命令可以跨行分割)。</target>
        </trans-unit>
        <trans-unit id="450f019da352d6f44183cb5a8fe197731201523e" translate="yes" xml:space="preserve">
          <source>This is a shortcut for setting &lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt; at once. If you specify this, you cannot specify either of those parameters.</source>
          <target state="translated">这是一次设置 &lt;code&gt;LC_COLLATE&lt;/code&gt; 和 &lt;code&gt;LC_CTYPE&lt;/code&gt; 的快捷方式。如果指定此选项，则不能指定这些参数中的任何一个。</target>
        </trans-unit>
        <trans-unit id="768c3e272a14bb422425810cd204ed41f4ba6629" translate="yes" xml:space="preserve">
          <source>This is a wrapper for the above function that uses &lt;code&gt;,&lt;/code&gt; as the separator.</source>
          <target state="translated">这是上述的函数，它使用一个包装 &lt;code&gt;,&lt;/code&gt; 作为分隔符。</target>
        </trans-unit>
        <trans-unit id="b3c868d4182c583f463c71ff97e781747bf3a03c" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;\dp&lt;/code&gt; (&amp;ldquo;display privileges&amp;rdquo;).</source>
          <target state="translated">这是 &lt;code&gt;\dp&lt;/code&gt; （&amp;ldquo;显示权限&amp;rdquo;）的别名。</target>
        </trans-unit>
        <trans-unit id="a3bfb72cef070dc11f447b3386a7c2706bac36a5" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;\lo_list&lt;/code&gt;, which shows a list of large objects.</source>
          <target state="translated">这是 &lt;code&gt;\lo_list&lt;/code&gt; 的别名，该别名显示大对象的列表。</target>
        </trans-unit>
        <trans-unit id="e5418e1e26d985dcf636546c65d0611e01b93f2b" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;hash_murmur2&lt;/code&gt;.</source>
          <target state="translated">这是 &lt;code&gt;hash_murmur2&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="78ba8cae4388de88507eba2b7275ccd60b950613" translate="yes" xml:space="preserve">
          <source>This is an array of &lt;code&gt;indnatts&lt;/code&gt; values that indicate which table columns this index indexes. For example a value of &lt;code&gt;1 3&lt;/code&gt; would mean that the first and the third table columns make up the index entries. Key columns come before non-key (included) columns. A zero in this array indicates that the corresponding index attribute is an expression over the table columns, rather than a simple column reference.</source>
          <target state="translated">这是 &lt;code&gt;indnatts&lt;/code&gt; 值的数组，这些值指示此索引索引的表列。例如，值 &lt;code&gt;1 3&lt;/code&gt; 表示第一和第三表列构成索引条目。关键列位于非关键（包含）列之前。此数组中的零表示相应的索引属性是表列上的表达式，而不是简单的列引用。</target>
        </trans-unit>
        <trans-unit id="f5ae302c90a19a0498f7df9c475b24d33cb673e7" translate="yes" xml:space="preserve">
          <source>This is an array of &lt;code&gt;indnkeyatts&lt;/code&gt; values that store per-column flag bits. The meaning of the bits is defined by the index's access method.</source>
          <target state="translated">这是存储每个列标志位的 &lt;code&gt;indnkeyatts&lt;/code&gt; 值的数组。这些位的含义由索引的访问方法定义。</target>
        </trans-unit>
        <trans-unit id="2fc49bd55fbc5bfa9dea1e28cd18c9a1ca88a7e4" translate="yes" xml:space="preserve">
          <source>This is an array of &lt;code&gt;partnatts&lt;/code&gt; values that indicate which table columns are part of the partition key. For example, a value of &lt;code&gt;1 3&lt;/code&gt; would mean that the first and the third table columns make up the partition key. A zero in this array indicates that the corresponding partition key column is an expression, rather than a simple column reference.</source>
          <target state="translated">这是 &lt;code&gt;partnatts&lt;/code&gt; 值的数组，用于指示哪些表列是分区键的一部分。例如，值 &lt;code&gt;1 3&lt;/code&gt; 表示第一和第三表列构成分区键。此数组中的零表示相应的分区键列是表达式，而不是简单的列引用。</target>
        </trans-unit>
        <trans-unit id="85cb6ef5ec65368f349e99d1c5b167fcd51b032f" translate="yes" xml:space="preserve">
          <source>This is an example of creating a bloom index:</source>
          <target state="translated">这是一个创建绽放指数的例子。</target>
        </trans-unit>
        <trans-unit id="28e7b5364ece8bb74449b25a2f87fdcc6112556a" translate="yes" xml:space="preserve">
          <source>This is backward-compatible syntax for declaring a table &lt;code&gt;WITHOUT OIDS&lt;/code&gt;, creating a table &lt;code&gt;WITH OIDS&lt;/code&gt; is not supported anymore.</source>
          <target state="translated">这是向后兼容的语法，用于声明 &lt;code&gt;WITHOUT OIDS&lt;/code&gt; 的表，不再支持创建带 &lt;code&gt;WITH OIDS&lt;/code&gt; 的表。</target>
        </trans-unit>
        <trans-unit id="f53c81b1fcb044c5d18d73e6543204df53f672fe" translate="yes" xml:space="preserve">
          <source>This is because a restriction placed in the &lt;code&gt;ON&lt;/code&gt; clause is processed &lt;em&gt;before&lt;/em&gt; the join, while a restriction placed in the &lt;code&gt;WHERE&lt;/code&gt; clause is processed &lt;em&gt;after&lt;/em&gt; the join. That does not matter with inner joins, but it matters a lot with outer joins.</source>
          <target state="translated">这是因为放在 &lt;code&gt;ON&lt;/code&gt; 子句中的限制是&lt;em&gt;在&lt;/em&gt;连接&lt;em&gt;之前&lt;/em&gt;处理的，而放在 &lt;code&gt;WHERE&lt;/code&gt; 子句中的限制是&lt;em&gt;在&lt;/em&gt;连接&lt;em&gt;之后&lt;/em&gt;处理的。这与内部联接无关紧要，但对于外部联接则非常重要。</target>
        </trans-unit>
        <trans-unit id="40e68e5962e0de07dffd697e9417724fccc9d63d" translate="yes" xml:space="preserve">
          <source>This is because if A had executed before B, B would have computed the sum 330, not 300, and similarly the other order would have resulted in a different sum computed by A.</source>
          <target state="translated">这是因为如果A在B之前执行,B会计算出330的总和,而不是300的总和,同样,其他顺序也会导致A计算出不同的总和。</target>
        </trans-unit>
        <trans-unit id="75b15f8961b465e16b950c107a03d87b532671ad" translate="yes" xml:space="preserve">
          <source>This is commonly used for analysis over hierarchical data; e.g. total salary by department, division, and company-wide total.</source>
          <target state="translated">这通常用于分析分层数据;例如,按部门、部门和全公司的总工资。</target>
        </trans-unit>
        <trans-unit id="acf1e54fe7c52b1e02149d6df39362598d17e105" translate="yes" xml:space="preserve">
          <source>This is commonly used for analysis over hierarchical data; e.g., total salary by department, division, and company-wide total.</source>
          <target state="translated">这通常用于分析分层数据;例如,按部门、部门和全公司的总工资。</target>
        </trans-unit>
        <trans-unit id="c19f8fd7239c9e470394caad32ebd804606ed7b1" translate="yes" xml:space="preserve">
          <source>This is effectively the same as setting the default to null. As a consequence, it is not an error to drop a default where one hadn't been defined, because the default is implicitly the null value.</source>
          <target state="translated">这实际上等同于将默认值设置为空值。因此,在没有定义缺省值的情况下放弃缺省值并不是一个错误,因为缺省值是隐式的空值。</target>
        </trans-unit>
        <trans-unit id="41f2000975a0c863d9984d3c052ffa8b2b55e07d" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code id=&quot;current_user&quot;&gt;current_user&lt;/code&gt;.</source>
          <target state="translated">这等效于 &lt;code id=&quot;current_user&quot;&gt;current_user&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="abbe5e4acccc682de9944cdbcde670be36b81565" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;current_user&lt;/code&gt;.</source>
          <target state="translated">这等效于 &lt;code&gt;current_user&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d31603eaa916aca8762159f8bda194ec5b5313c" translate="yes" xml:space="preserve">
          <source>This is equivalent to considering that the lower bound is &amp;ldquo;minus infinity&amp;rdquo;, or the upper bound is &amp;ldquo;plus infinity&amp;rdquo;, respectively. But note that these infinite values are never values of the range's element type, and can never be part of the range. (So there is no such thing as an inclusive infinite bound &amp;mdash; if you try to write one, it will automatically be converted to an exclusive bound.)</source>
          <target state="translated">这等效于分别考虑下限为&amp;ldquo;负无穷大&amp;rdquo;或上限为&amp;ldquo;正无穷大&amp;rdquo;。但是请注意，这些无穷值永远不是范围元素类型的值，也永远不能成为范围的一部分。（因此，不存在包含无穷大的边界&amp;mdash;如果您尝试编写一个无穷大边界，它将自动转换为独占大边界。）</target>
        </trans-unit>
        <trans-unit id="32b4366f2bb306ae39f6ae123b6e52ebbaf45e22" translate="yes" xml:space="preserve">
          <source>This is false for internal languages (such as SQL) and true for user-defined languages. Currently, pg_dump still uses this to determine which languages need to be dumped, but this might be replaced by a different mechanism in the future.</source>
          <target state="translated">对于内部语言(如SQL)来说,这个值为false,对于用户定义的语言来说,这个值为true。目前,pg_dump仍然使用这个功能来决定哪些语言需要被转储,但将来可能会被不同的机制所取代。</target>
        </trans-unit>
        <trans-unit id="909703c85505cd16ac2e43cb68b897cd4647ad6b" translate="yes" xml:space="preserve">
          <source>This is identical to &lt;code&gt;dow&lt;/code&gt; except for Sunday. This matches the ISO 8601 day of the week numbering.</source>
          <target state="translated">除星期天外，这与 &lt;code&gt;dow&lt;/code&gt; 相同。这与ISO 8601的星期几编号相匹配。</target>
        </trans-unit>
        <trans-unit id="774c866f144b866c3887ecc3ab9eba1546c6554f" translate="yes" xml:space="preserve">
          <source>This is more useful if the expressions in the select list return varying results. For example, you could call a function this way:</source>
          <target state="translated">如果选择列表中的表达式返回不同的结果,这一点就比较有用。例如,你可以这样调用一个函数。</target>
        </trans-unit>
        <trans-unit id="f9f2d8c3b689196c5d8ec8d4f5df566ae69faf2b" translate="yes" xml:space="preserve">
          <source>This is needed to avoid syntactic ambiguity. An example is:</source>
          <target state="translated">这是为了避免语法上的歧义。一个例子是:</target>
        </trans-unit>
        <trans-unit id="9c677b482c1d51ad6809dd70f3013fed740bc81c" translate="yes" xml:space="preserve">
          <source>This is not as efficient as a partial index on the &lt;code&gt;amount&lt;/code&gt; column would be, since the system has to scan the entire index. Yet, if there are relatively few unbilled orders, using this partial index just to find the unbilled orders could be a win.</source>
          <target state="translated">由于系统必须扫描整个索引，因此效率不如对 &lt;code&gt;amount&lt;/code&gt; 列的部分索引有效。但是，如果未开票的订单相对较少，则使用此部分索引来查找未开票的订单可能是一个成功。</target>
        </trans-unit>
        <trans-unit id="30d2d55c459297e19ddd1f07d0c1ebe65fd3794d" translate="yes" xml:space="preserve">
          <source>This is not especially useful since it has exactly the same result as the more conventional</source>
          <target state="translated">这不是特别有用,因为它的结果与更传统的</target>
        </trans-unit>
        <trans-unit id="0322eac9bb3931b0da02327d4f96591febd87604" translate="yes" xml:space="preserve">
          <source>This is only a conceptual model. The join is usually performed in a more efficient manner than actually comparing each possible pair of rows, but this is invisible to the user.</source>
          <target state="translated">这只是一个概念模型。连接通常是以比实际比较每一对可能的行更有效的方式进行的,但这对用户来说是看不见的。</target>
        </trans-unit>
        <trans-unit id="b8169801d92724560db318d90118c63ada145ffc" translate="yes" xml:space="preserve">
          <source>This is quite a different problem: how to estimate the selectivity when the value is &lt;em&gt;not&lt;/em&gt; in the MCV list. The approach is to use the fact that the value is not in the list, combined with the knowledge of the frequencies for all of the MCVs:</source>
          <target state="translated">这是一个完全不同的问题：当值&lt;em&gt;不在&lt;/em&gt; MCV列表中时，如何估算选择性。该方法是利用该值不在列表中的事实，结合所有MCV的频率知识：</target>
        </trans-unit>
        <trans-unit id="f0d520c606037b870becb6e588d6da7dff0960ba" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;digest()&lt;/code&gt; but the hash can only be recalculated knowing the key. This prevents the scenario of someone altering data and also changing the hash to match.</source>
          <target state="translated">这类似于 &lt;code&gt;digest()&lt;/code&gt; ,但是只能在知道密钥的情况下重新计算哈希值。这样可以防止有人更改数据以及更改哈希值以使其匹配的情况。</target>
        </trans-unit>
        <trans-unit id="53bd3331f309cfd6d8eeacec7a8068398ef70fcf" translate="yes" xml:space="preserve">
          <source>This is the &lt;em&gt;Fast Shutdown&lt;/em&gt; mode. The server disallows new connections and sends all existing server processes SIGTERM, which will cause them to abort their current transactions and exit promptly. It then waits for all server processes to exit and finally shuts down. If the server is in online backup mode, backup mode will be terminated, rendering the backup useless.</source>
          <target state="translated">这是&lt;em&gt;快速关机&lt;/em&gt;模式。服务器禁止新连接，并发送所有现有服务器进程SIGTERM，这将导致它们中止其当前事务并立即退出。然后，它等待所有服务器进程退出并最终关闭。如果服务器处于联机备份模式，则备份模式将终止，从而使备份无用。</target>
        </trans-unit>
        <trans-unit id="9519f8334dda9bed264446e6f4818cc6899e6c5a" translate="yes" xml:space="preserve">
          <source>This is the &lt;em&gt;Immediate Shutdown&lt;/em&gt; mode. The server will send SIGQUIT to all child processes and wait for them to terminate. If any do not terminate within 5 seconds, they will be sent SIGKILL. The master server process exits as soon as all child processes have exited, without doing normal database shutdown processing. This will lead to recovery (by replaying the WAL log) upon next start-up. This is recommended only in emergencies.</source>
          <target state="translated">这是&lt;em&gt;立即关闭&lt;/em&gt;模式。服务器将SIGQUIT发送给所有子进程，并等待它们终止。如果没有在5秒内终止，则将向他们发送SIGKILL。所有子进程都退出后，主服务器进程将立即退出，而不进行正常的数据库关闭处理。下次启动时，这将导致恢复（通过重播WAL日志）。仅在紧急情况下才建议这样做。</target>
        </trans-unit>
        <trans-unit id="64dec29096a90e2ac7b66bae5da2edc5f6e90310" translate="yes" xml:space="preserve">
          <source>This is the &lt;em&gt;Smart Shutdown&lt;/em&gt; mode. After receiving SIGTERM, the server disallows new connections, but lets existing sessions end their work normally. It shuts down only after all of the sessions terminate. If the server is in online backup mode, it additionally waits until online backup mode is no longer active. While backup mode is active, new connections will still be allowed, but only to superusers (this exception allows a superuser to connect to terminate online backup mode). If the server is in recovery when a smart shutdown is requested, recovery and streaming replication will be stopped only after all regular sessions have terminated.</source>
          <target state="translated">这是&lt;em&gt;智能关机&lt;/em&gt;模式。收到SIGTERM后，服务器将禁止新连接，但允许现有会话正常结束其工作。仅在所有会话终止后，它才会关闭。如果服务器处于联机备份模式，它将另外等待，直到联机备份模式不再处于活动状态。在备份模式处于活动状态时，仍将允许新连接，但仅允许与超级用户建立连接（此例外允许超级用户进行连接以终止在线备份模式）。如果在请求智能关闭时服务器处于恢复状态，则只有在所有常规会话都终止后，恢复和流式复制才会停止。</target>
        </trans-unit>
        <trans-unit id="18b982c4dd6953b11d003392c392545d3b122dd7" translate="yes" xml:space="preserve">
          <source>This is the SQL standard's equivalent to &lt;code&gt;bool_and&lt;/code&gt;.</source>
          <target state="translated">这是SQL标准的等效于 &lt;code&gt;bool_and&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="92dd6728f5fbf932d72131603602b0280b7afbb6" translate="yes" xml:space="preserve">
          <source>This is the amount of time to wait on a lock before checking to see if there is a deadlock condition. The check for deadlock is relatively expensive, so the server doesn't run it every time it waits for a lock. We optimistically assume that deadlocks are not common in production applications and just wait on the lock for a while before checking for a deadlock. Increasing this value reduces the amount of time wasted in needless deadlock checks, but slows down reporting of real deadlock errors. If this value is specified without units, it is taken as milliseconds. The default is one second (&lt;code&gt;1s&lt;/code&gt;), which is probably about the smallest value you would want in practice. On a heavily loaded server you might want to raise it. Ideally the setting should exceed your typical transaction time, so as to improve the odds that a lock will be released before the waiter decides to check for deadlock. Only superusers can change this setting.</source>
          <target state="translated">这是在检查是否存在死锁条件之前等待锁的时间。死锁检查相对昂贵，因此服务器不会在每次等待锁时都运行死锁。我们乐观地认为死锁在生产应用程序中并不常见，只需要等待一段时间就可以检查死锁。增大此值可减少不必要的死锁检查所浪费的时间，但会减慢实际死锁错误的报告速度。如果指定的该值不带单位，则以毫秒为单位。默认值为一秒（ &lt;code&gt;1s&lt;/code&gt; ），这大概是您在实践中想要的最小值。在负载很重的服务器上，您可能需要提高它。理想情况下，设置应超过您的典型交易时间，以提高在服务员决定检查死锁之前将释放锁的几率。只有超级用户可以更改此设置。</target>
        </trans-unit>
        <trans-unit id="66c8088759f9087b738e1b70d1cf37c8a1aae852" translate="yes" xml:space="preserve">
          <source>This is the default format.</source>
          <target state="translated">这是默认格式。</target>
        </trans-unit>
        <trans-unit id="3ce226ef1a13e0c7b419788ac5e73819bf180bcb" translate="yes" xml:space="preserve">
          <source>This is the generic &amp;ldquo;I couldn't find a server to talk to&amp;rdquo; failure. It looks like the above when TCP/IP communication is attempted. A common mistake is to forget to configure the server to allow TCP/IP connections.</source>
          <target state="translated">这是常见的&amp;ldquo;我找不到要交谈的服务器&amp;rdquo;失败。尝试进行TCP / IP通信时，看起来像上面的样子。一个常见的错误是忘记将服务器配置为允许TCP / IP连接。</target>
        </trans-unit>
        <trans-unit id="7a73a092e455b0519a284ead127b2916ee3a2346" translate="yes" xml:space="preserve">
          <source>This is the interval between updates to &lt;code&gt;autoprewarm.blocks&lt;/code&gt;. The default is 300 seconds. If set to 0, the file will not be dumped at regular intervals, but only when the server is shut down.</source>
          <target state="translated">这是对 &lt;code&gt;autoprewarm.blocks&lt;/code&gt; 进行更新的间隔。默认值为300秒。如果设置为0，则不会定期转储文件，而仅在关闭服务器时转储文件。</target>
        </trans-unit>
        <trans-unit id="7a967763949218bdd201f81e3734208d5693135c" translate="yes" xml:space="preserve">
          <source>This is the most secure of the currently provided methods, but it is not supported by older client libraries.</source>
          <target state="translated">这是目前提供的方法中最安全的方法,但旧的客户端库不支持。</target>
        </trans-unit>
        <trans-unit id="281ee2a6d6b295f0c605c272cbd3a317a0476533" translate="yes" xml:space="preserve">
          <source>This is the price one pays for extensibility.</source>
          <target state="translated">这就是人们为可扩展性所付出的代价。</target>
        </trans-unit>
        <trans-unit id="e49d24e044b41980e036610f5fc7a5e4be7955e6" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;pg_relpages(regclass)&lt;/code&gt;, except that the target relation is specified as TEXT. This function is kept because of backward-compatibility so far, and will be deprecated in some future release.</source>
          <target state="translated">与 &lt;code&gt;pg_relpages(regclass)&lt;/code&gt; 相同，除了将目标关系指定为TEXT。到目前为止，由于向后兼容而保留了此功能，在将来的某些发行版中将不推荐使用此功能。</target>
        </trans-unit>
        <trans-unit id="64132a4b93c0dbcab91f77d1ac58e1693be7385b" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;pgstatindex(regclass)&lt;/code&gt;, except that the target index is specified as TEXT. This function is kept because of backward-compatibility so far, and will be deprecated in some future release.</source>
          <target state="translated">与 &lt;code&gt;pgstatindex(regclass)&lt;/code&gt; 相同，除了目标索引指定为TEXT。到目前为止，由于向后兼容而保留了此功能，在将来的某些发行版中将不推荐使用此功能。</target>
        </trans-unit>
        <trans-unit id="54441c2148265c644b6e2c6b5762a5242346cb3d" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;pgstattuple(regclass)&lt;/code&gt;, except that the target relation is specified as TEXT. This function is kept because of backward-compatibility so far, and will be deprecated in some future release.</source>
          <target state="translated">与 &lt;code&gt;pgstattuple(regclass)&lt;/code&gt; 相同，除了将目标关系指定为TEXT。到目前为止，由于向后兼容而保留了此功能，在将来的某些发行版中将不推荐使用此功能。</target>
        </trans-unit>
        <trans-unit id="ece1f9875ce6ffc21558f8024d23103c3c5eb710" translate="yes" xml:space="preserve">
          <source>This is the same example using normalized ranking:</source>
          <target state="translated">这也是使用归一化排名的例子。</target>
        </trans-unit>
        <trans-unit id="b095631465e3260d63a74afe0d97ae2d96edf684" translate="yes" xml:space="preserve">
          <source>This is the same query as above, but we added a &lt;code&gt;LIMIT&lt;/code&gt; so that not all the rows need be retrieved, and the planner changed its mind about what to do. Notice that the total cost and row count of the Index Scan node are shown as if it were run to completion. However, the Limit node is expected to stop after retrieving only a fifth of those rows, so its total cost is only a fifth as much, and that's the actual estimated cost of the query. This plan is preferred over adding a Limit node to the previous plan because the Limit could not avoid paying the startup cost of the bitmap scan, so the total cost would be something over 25 units with that approach.</source>
          <target state="translated">这是与上面相同的查询，但是我们添加了一个 &lt;code&gt;LIMIT&lt;/code&gt; ,以便不需要检索所有行，并且计划者改变了主意。请注意，索引扫描节点的总成本和行数显示为好像已运行完毕。但是，预计Limit节点将仅在检索到这些行的五分之一后停止，因此其总开销仅为该行的五分之一，这就是查询的实际估计开销。与将Limit节点添加到之前的计划相比，此计划更为可取，因为Limit无法避免支付位图扫描的启动成本，因此采用该方法，总成本将超过25个单位。</target>
        </trans-unit>
        <trans-unit id="94cb90e2972cc12877867d7980fc980b09691ec3" translate="yes" xml:space="preserve">
          <source>This is transformed by the parser to effectively become:</source>
          <target state="translated">这被解析器转化为有效的。</target>
        </trans-unit>
        <trans-unit id="a05aa8321906cf1c74f9a81ad06926d222bf1181" translate="yes" xml:space="preserve">
          <source>This is used to specify that the foreign-data wrapper should no longer have a handler function.</source>
          <target state="translated">这用于指定外来数据包装器不应该再有处理函数。</target>
        </trans-unit>
        <trans-unit id="d0dd5b48b4b716a9453020ad47edd41a0fc5866a" translate="yes" xml:space="preserve">
          <source>This is used to specify that the foreign-data wrapper should no longer have a validator function.</source>
          <target state="translated">这用于指定外来数据包装器不应该再有验证器函数。</target>
        </trans-unit>
        <trans-unit id="d30d7211e06d7778bc4cd17adf8c8ca724a370e3" translate="yes" xml:space="preserve">
          <source>This is what you are most likely to get if you succeed in contacting the server, but it does not want to talk to you. As the message suggests, the server refused the connection request because it found no matching entry in its &lt;code&gt;pg_hba.conf&lt;/code&gt; configuration file.</source>
          <target state="translated">如果成功与服务器联系，这是您最有可能得到的，但它不想与您交谈。如消息所示，服务器拒绝了连接请求，因为它在 &lt;code&gt;pg_hba.conf&lt;/code&gt; 配置文件中找不到匹配的条目。</target>
        </trans-unit>
        <trans-unit id="fa56032fee9f040556b310dd23691f09946834cc" translate="yes" xml:space="preserve">
          <source>This is wrong since it is not clear which child table the key value 200 belongs in.</source>
          <target state="translated">这是不对的,因为不清楚键值200属于哪个子表。</target>
        </trans-unit>
        <trans-unit id="0515e31998ba6bb73d0ddae64599b98492334cc8" translate="yes" xml:space="preserve">
          <source>This is, subtract the null fraction from one for each of the relations, and divide by the maximum of the numbers of distinct values. The number of rows that the join is likely to emit is calculated as the cardinality of the Cartesian product of the two inputs, multiplied by the selectivity:</source>
          <target state="translated">这就是是,从每一个关系的空分数中减去1,然后除以不同值的数目的最大值。联接可能发出的行数是以两个输入的笛卡尔乘积的卡数,乘以选择性来计算的。</target>
        </trans-unit>
        <trans-unit id="1465b8af61e8c0e09acc4cea2d200fe28f10de58" translate="yes" xml:space="preserve">
          <source>This key is always present on the last line of the backup manifest file. The associated value is a SHA256 checksum of all the preceding lines. We use a fixed checksum method here to make it possible for clients to do incremental parsing of the manifest. While a SHA256 checksum is significantly more expensive than a CRC32C checksum, the manifest should normally be small enough that the extra computation won't matter very much.</source>
          <target state="translated">该键始终存在于备份清单文件的最后一行。相关的值是前面所有行的SHA256校验和。我们在这里使用固定的校验方法,使客户可以对清单进行增量解析。虽然SHA256校验和比CRC32C校验和贵得多,但通常清单应该足够小,额外的计算不会很重要。</target>
        </trans-unit>
        <trans-unit id="88f72ee86e21efe6631404a3bf422fe90ce0b7b5" translate="yes" xml:space="preserve">
          <source>This key word is ignored.</source>
          <target state="translated">这个关键词被忽略了。</target>
        </trans-unit>
        <trans-unit id="ccf5892ae182b1129c89233a93f9d2dff22e3a50" translate="yes" xml:space="preserve">
          <source>This keyword immediately precedes the declaration of one or two relation names that provide access to the transition relations of the triggering statement.</source>
          <target state="translated">这个关键字紧接在一个或两个关系名的声明之前,这些关系名提供了对触发语句的过渡关系的访问。</target>
        </trans-unit>
        <trans-unit id="e080950e112255fe2f612123624be96d15f65967" translate="yes" xml:space="preserve">
          <source>This latter equivalence does not hold exactly when more than two tables appear, because &lt;code&gt;JOIN&lt;/code&gt; binds more tightly than comma. For example &lt;code&gt;FROM T1 CROSS JOIN T2 INNER JOIN T3 ON condition&lt;/code&gt; is not the same as &lt;code&gt;FROM T1, T2 INNER JOIN T3 ON condition&lt;/code&gt; because the &lt;code&gt;condition&lt;/code&gt; can reference &lt;code&gt;T1&lt;/code&gt; in the first case but not the second.</source>
          <target state="translated">当出现两个以上的表时，后者的等价关系并不完全成立，因为 &lt;code&gt;JOIN&lt;/code&gt; 的绑定比逗号更紧密。例如， &lt;code&gt;FROM T1 CROSS JOIN T2 INNER JOIN T3 ON condition&lt;/code&gt; 不同于 &lt;code&gt;FROM T1, T2 INNER JOIN T3 ON condition&lt;/code&gt; 因为该 &lt;code&gt;condition&lt;/code&gt; 在第一种情况下可以引用 &lt;code&gt;T1&lt;/code&gt; ，但在第二种情况下不能引用T1。</target>
        </trans-unit>
        <trans-unit id="4445598676898e3b5c713e7c5758010ce357bcd1" translate="yes" xml:space="preserve">
          <source>This level is different from Read Committed in that a query in a repeatable read transaction sees a snapshot as of the start of the first non-transaction-control statement in the &lt;em&gt;transaction&lt;/em&gt;, not as of the start of the current statement within the transaction. Thus, successive &lt;code&gt;SELECT&lt;/code&gt; commands within a &lt;em&gt;single&lt;/em&gt; transaction see the same data, i.e., they do not see changes made by other transactions that committed after their own transaction started.</source>
          <target state="translated">此级别与&amp;ldquo;已提交读&amp;rdquo;不同，在可重复读事务中的查询看到的快照是该事务中第一个非事务控制语句开始处的快照，而不是该&lt;em&gt;事务中&lt;/em&gt;当前语句开始处的快照。因此，&lt;em&gt;单个&lt;/em&gt;事务中的连续 &lt;code&gt;SELECT&lt;/code&gt; 命令将看到相同的数据，即，它们看不到其他事务在其自己的事务开始之后提交的更改。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1b43064679af2be0d9a41eca78e98514d704b879" translate="yes" xml:space="preserve">
          <source>This level of integrity protection using Serializable transactions does not yet extend to hot standby mode (&lt;a href=&quot;hot-standby&quot;&gt;Section 26.5&lt;/a&gt;). Because of that, those using hot standby may want to use Repeatable Read and explicit locking on the master.</source>
          <target state="translated">使用可序列化事务的完整性保护级别尚未扩展到热备用模式（&lt;a href=&quot;hot-standby&quot;&gt;第26.5节&lt;/a&gt;）。因此，那些使用热备用的用户可能希望在主机上使用重复读取和显式锁定。</target>
        </trans-unit>
        <trans-unit id="81dc2dc08c39c5d2f9e3dd37d41f417f52e2a9fc" translate="yes" xml:space="preserve">
          <source>This limits the usefulness of the &lt;code&gt;passwordcheck&lt;/code&gt; module, because in that case it can only try to guess the password. For this reason, &lt;code&gt;passwordcheck&lt;/code&gt; is not recommended if your security requirements are high. It is more secure to use an external authentication method such as GSSAPI (see &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;) than to rely on passwords within the database.</source>
          <target state="translated">这限制了 &lt;code&gt;passwordcheck&lt;/code&gt; 模块的用途，因为在这种情况下，它只能尝试猜测密码。因此，如果对安全性的要求很高，则不建议使用 &lt;code&gt;passwordcheck&lt;/code&gt; 。使用外部认证方法（例如GSSAPI（请参阅&lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;第20章&lt;/a&gt;））比依赖数据库中的密码更安全。</target>
        </trans-unit>
        <trans-unit id="2789c3cbaef768ecab4d3f60f01f3d79af1c2ea9" translate="yes" xml:space="preserve">
          <source>This limits the usefulness of the &lt;code&gt;passwordcheck&lt;/code&gt; module, because in that case it can only try to guess the password. For this reason, &lt;code&gt;passwordcheck&lt;/code&gt; is not recommended if your security requirements are high. It is more secure to use an external authentication method such as GSSAPI (see &lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;) than to rely on passwords within the database.</source>
          <target state="translated">这限制了 &lt;code&gt;passwordcheck&lt;/code&gt; 模块的用途，因为在这种情况下，它只能尝试猜测密码。因此，如果对安全性的要求很高，则不建议使用 &lt;code&gt;passwordcheck&lt;/code&gt; 。使用外部认证方法（例如GSSAPI（请参阅&lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;第20章&lt;/a&gt;））比依赖数据库中的密码更安全。</target>
        </trans-unit>
        <trans-unit id="1a5e3d694aabd0836b4470958df1839ef5142811" translate="yes" xml:space="preserve">
          <source>This may be more intuitive if you are using &lt;code&gt;pg_ctl&lt;/code&gt; for starting and stopping the server (see &lt;a href=&quot;server-start&quot;&gt;Section 18.3&lt;/a&gt;), so that &lt;code&gt;pg_ctl&lt;/code&gt; would be the sole command you use for managing the database server instance.</source>
          <target state="translated">如果您正在使用 &lt;code&gt;pg_ctl&lt;/code&gt; 来启动和停止服务器（请参阅&lt;a href=&quot;server-start&quot;&gt;第18.3节&lt;/a&gt;），那么这可能会更直观，因此 &lt;code&gt;pg_ctl&lt;/code&gt; 将是您用于管理数据库服务器实例的唯一命令。</target>
        </trans-unit>
        <trans-unit id="dfa0eac4f1545a9ddc55a9ceb07c6c1edc0186f1" translate="yes" xml:space="preserve">
          <source>This means that the server was not started, or it was not started where &lt;code&gt;createdb&lt;/code&gt; expected it. Again, check the installation instructions or consult the administrator.</source>
          <target state="translated">这意味着服务器未启动，或者在 &lt;code&gt;createdb&lt;/code&gt; 预期的位置未启动。再次，检查安装说明或咨询管理员。</target>
        </trans-unit>
        <trans-unit id="ded18d2e27ab98a47b51417474a9c5eeb41e0e40" translate="yes" xml:space="preserve">
          <source>This mechanism prevents unencrypted data from being read from the drives if the drives or the entire computer is stolen. This does not protect against attacks while the file system is mounted, because when mounted, the operating system provides an unencrypted view of the data. However, to mount the file system, you need some way for the encryption key to be passed to the operating system, and sometimes the key is stored somewhere on the host that mounts the disk.</source>
          <target state="translated">如果驱动器或整个计算机被盗,这种机制可以防止从驱动器中读取未加密的数据。这并不能在文件系统被挂载时防止攻击,因为挂载时,操作系统提供了一个未加密的数据视图。然而,要挂载文件系统,你需要某种方式让加密密钥传递给操作系统,有时密钥会存储在挂载磁盘的主机的某个地方。</target>
        </trans-unit>
        <trans-unit id="4541818976374d79642c0f93c22dbb7a713f72ad" translate="yes" xml:space="preserve">
          <source>This method consolidates information in the tree. Given a set of entries, this function generates a new index entry that represents all the given entries.</source>
          <target state="translated">这种方法可以整合树中的信息。给定一组条目,该函数生成一个新的索引条目,代表所有给定条目。</target>
        </trans-unit>
        <trans-unit id="bc385497c58aec7319cf4002de1bf0ca8c1d4cff" translate="yes" xml:space="preserve">
          <source>This method of upgrading can be performed using the built-in logical replication facilities as well as using external logical replication systems such as pglogical, Slony, Londiste, and Bucardo.</source>
          <target state="translated">这种升级方法可以使用内置的逻辑复制设施,也可以使用外部逻辑复制系统,如pglogical、Slony、Londiste和Bucardo。</target>
        </trans-unit>
        <trans-unit id="82b2800cab107f6d05df0ae989ccbd67016a0ee1" translate="yes" xml:space="preserve">
          <source>This might cause zero, one, or many rows to be updated. It is not an error to attempt an update that does not match any rows.</source>
          <target state="translated">这可能导致零条、一条或多条记录被更新。试图更新不匹配的记录并不是一个错误。</target>
        </trans-unit>
        <trans-unit id="264f830b811a6d6b8c58c36cb7fd806990f75f99" translate="yes" xml:space="preserve">
          <source>This might produce log output such as:</source>
          <target state="translated">这可能会产生如下的日志输出:</target>
        </trans-unit>
        <trans-unit id="b493978753faced6c574bfe3060740f6644ad55e" translate="yes" xml:space="preserve">
          <source>This mode is provided for those who insist on it, but you are not necessarily encouraged to use it. In particular, if you mix SQL and meta-commands on a line the order of execution might not always be clear to the inexperienced user.</source>
          <target state="translated">这种模式是为那些坚持使用它的人提供的,但不一定鼓励你使用它。特别是,如果你在一行中混合使用SQL和元命令,对于没有经验的用户来说,执行的顺序可能并不总是很清楚。</target>
        </trans-unit>
        <trans-unit id="3d9301bd35d933ed8044c02b82956382914754a7" translate="yes" xml:space="preserve">
          <source>This module implements a data type &lt;code&gt;cube&lt;/code&gt; for representing multidimensional cubes.</source>
          <target state="translated">这个模块实现数据类型 &lt;code&gt;cube&lt;/code&gt; 为代表多维数据集。</target>
        </trans-unit>
        <trans-unit id="f8e33606e025a4455156d4072de6e226ed4b94f7" translate="yes" xml:space="preserve">
          <source>This module implements a data type &lt;code&gt;ltree&lt;/code&gt; for representing labels of data stored in a hierarchical tree-like structure. Extensive facilities for searching through label trees are provided.</source>
          <target state="translated">该模块实现数据类型 &lt;code&gt;ltree&lt;/code&gt; ,用于表示存储在分层树状结构中的数据的标签。提供了用于搜索标签树的广泛工具。</target>
        </trans-unit>
        <trans-unit id="e72760dc721284c431bb3ba272b6dca3b540e0f1" translate="yes" xml:space="preserve">
          <source>This module implements a data type &lt;code&gt;seg&lt;/code&gt; for representing line segments, or floating point intervals. &lt;code&gt;seg&lt;/code&gt; can represent uncertainty in the interval endpoints, making it especially useful for representing laboratory measurements.</source>
          <target state="translated">该模块实现了用于表示线段或浮点间隔的数据类型 &lt;code&gt;seg&lt;/code&gt; 。 &lt;code&gt;seg&lt;/code&gt; 可以表示间隔端点中的不确定性，这对于表示实验室测量值特别有用。</target>
        </trans-unit>
        <trans-unit id="2dd33542f64474fba94a46e6b605e9b2299f1bab" translate="yes" xml:space="preserve">
          <source>This module implements the &lt;code&gt;hstore&lt;/code&gt; data type for storing sets of key/value pairs within a single PostgreSQL value. This can be useful in various scenarios, such as rows with many attributes that are rarely examined, or semi-structured data. Keys and values are simply text strings.</source>
          <target state="translated">该模块实现了用于在单个PostgreSQL值中存储键/值对集合的 &lt;code&gt;hstore&lt;/code&gt; 数据类型。这在各种情况下很有用，例如具有许多很少检查的属性的行或半结构化数据。键和值只是文本字符串。</target>
        </trans-unit>
        <trans-unit id="de0a2c458306a9179b18df224706a81701d0af82" translate="yes" xml:space="preserve">
          <source>This module integrates with SELinux to provide an additional layer of security checking above and beyond what is normally provided by PostgreSQL. From the perspective of SELinux, this module allows PostgreSQL to function as a user-space object manager. Each table or function access initiated by a DML query will be checked against the system security policy. This check is in addition to the usual SQL permissions checking performed by PostgreSQL.</source>
          <target state="translated">这个模块与SELinux集成,在PostgreSQL通常提供的功能之外,提供了额外的安全检查层。从SELinux的角度来看,这个模块允许PostgreSQL作为一个用户空间对象管理器发挥作用。每一个由DML查询发起的表或函数访问都会根据系统安全策略进行检查。这个检查是在PostgreSQL通常的SQL权限检查之外进行的。</target>
        </trans-unit>
        <trans-unit id="f7043a9bb620afd5b48f848b5741b06bf97dc549" translate="yes" xml:space="preserve">
          <source>This module is considered &amp;ldquo;trusted&amp;rdquo;, that is, it can be installed by non-superusers who have &lt;code&gt;CREATE&lt;/code&gt; privilege on the current database.</source>
          <target state="translated">该模块被认为是&amp;ldquo;受信任的&amp;rdquo;，也就是说，可以由对当前数据库具有 &lt;code&gt;CREATE&lt;/code&gt; 特权的非超级用户安装该模块。</target>
        </trans-unit>
        <trans-unit id="269393947826c6d71fccaff13c4be9c80ca40682" translate="yes" xml:space="preserve">
          <source>This module is sponsored by Delta-Soft Ltd., Moscow, Russia.</source>
          <target state="translated">本模块由俄罗斯莫斯科Delta-Soft有限公司赞助。</target>
        </trans-unit>
        <trans-unit id="4056f705daa3e3fdd49196fac6596ba7b2aa2807" translate="yes" xml:space="preserve">
          <source>This module was inspired by Garrett A. Wollman's &lt;code&gt;isbn_issn&lt;/code&gt; code.</source>
          <target state="translated">该模块的灵感来自Garrett A. Wollman的 &lt;code&gt;isbn_issn&lt;/code&gt; 代码。</target>
        </trans-unit>
        <trans-unit id="141bf6865546870a10c076189dfdbdeb9f73407a" translate="yes" xml:space="preserve">
          <source>This naming convention establishes a clear order in which these files will be loaded. This is important because only the last setting encountered for a particular parameter while the server is reading configuration files will be used. In this example, something set in &lt;code&gt;conf.d/02server.conf&lt;/code&gt; would override a value set in &lt;code&gt;conf.d/01memory.conf&lt;/code&gt;.</source>
          <target state="translated">该命名约定确定了加载这些文件的明确顺序。这很重要，因为仅使用服务器读取配置文件时特定参数遇到的最后一个设置。在此示例中， &lt;code&gt;conf.d/02server.conf&lt;/code&gt; 中设置的内容将覆盖 &lt;code&gt;conf.d/01memory.conf&lt;/code&gt; 中设置的值。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
