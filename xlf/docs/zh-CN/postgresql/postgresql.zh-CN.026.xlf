<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="13bf3c4060b6a548c1c5420c5acc0dd3edcdfdfa" translate="yes" xml:space="preserve">
          <source>When tar format mode is used, the write-ahead log files will be written to the &lt;code&gt;base.tar&lt;/code&gt; file.</source>
          <target state="translated">使用tar格式模式时，预写日志文件将被写入 &lt;code&gt;base.tar&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="f11ae7cfc9d8e7c9709340ffb2024d1b68d62efb" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY&quot;&gt;hot_standby&lt;/a&gt; parameter is set to true on a standby server, it will begin accepting connections once the recovery has brought the system to a consistent state. All such connections are strictly read-only; not even temporary tables may be written.</source>
          <target state="translated">在备用服务器&lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY&quot;&gt;上将hot_standby&lt;/a&gt;参数设置为true时，一旦恢复使系统进入一致状态，它将开始接受连接。所有这些连接都是严格只读的。甚至不能写入临时表。</target>
        </trans-unit>
        <trans-unit id="7959e96ecaba15e9d39e3fc41cafc94b8dcfae7f" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;CONSTRAINT&lt;/code&gt; option is specified, this command creates a &lt;em&gt;constraint trigger&lt;/em&gt;. This is the same as a regular trigger except that the timing of the trigger firing can be adjusted using &lt;a href=&quot;sql-set-constraints&quot;&gt;SET CONSTRAINTS&lt;/a&gt;. Constraint triggers must be &lt;code&gt;AFTER ROW&lt;/code&gt; triggers on plain tables (not foreign tables). They can be fired either at the end of the statement causing the triggering event, or at the end of the containing transaction; in the latter case they are said to be &lt;em&gt;deferred&lt;/em&gt;. A pending deferred-trigger firing can also be forced to happen immediately by using &lt;code&gt;SET CONSTRAINTS&lt;/code&gt;. Constraint triggers are expected to raise an exception when the constraints they implement are violated.</source>
          <target state="translated">当 &lt;code&gt;CONSTRAINT&lt;/code&gt; 指定选项，该命令创建一个&lt;em&gt;约束触发&lt;/em&gt;。这与常规触发器相同，除了可以使用&lt;a href=&quot;sql-set-constraints&quot;&gt;SET CONSTRAINTS&lt;/a&gt;调整触发器触发的时间。约束触发器必须是普通表（非外部表）上的 &lt;code&gt;AFTER ROW&lt;/code&gt; 触发器。它们可以在引起触发事件的语句末尾或包含事务的末尾处触发；在后者的情况下，据说他们被&lt;em&gt;推迟了&lt;/em&gt;。还可以通过使用 &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; 强制执行待执行的延迟触发触发。当违反约束触发器实现的约束时，预计会引发异常。</target>
        </trans-unit>
        <trans-unit id="df5c7d4a7ad0b452626a13ac455de82c0906adea" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;SELECT&lt;/code&gt; is one arm of a &lt;code&gt;UNION&lt;/code&gt; (or &lt;code&gt;INTERSECT&lt;/code&gt; or &lt;code&gt;EXCEPT&lt;/code&gt;) construct, or when it appears within &lt;code&gt;INSERT ... SELECT&lt;/code&gt;, this rule is not applied since rules given in preceding sections take precedence. The type of an unspecified-type literal can be taken from the other &lt;code&gt;UNION&lt;/code&gt; arm in the first case, or from the destination column in the second case.</source>
          <target state="translated">当 &lt;code&gt;SELECT&lt;/code&gt; 是 &lt;code&gt;UNION&lt;/code&gt; （或 &lt;code&gt;INTERSECT&lt;/code&gt; 或 &lt;code&gt;EXCEPT&lt;/code&gt; ）构造的一个分支时，或者当它出现在 &lt;code&gt;INSERT ... SELECT&lt;/code&gt; ，由于前面几节中的规则优先，因此不应用此规则。未指定类型文字的类型可以在第一种情况下从另一个 &lt;code&gt;UNION&lt;/code&gt; 臂获取，或者在第二种情况下从目标列获取。</target>
        </trans-unit>
        <trans-unit id="7f2ffb48d56de0e4aaa18bb9efa3e04da4e9e279" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;WHERE&lt;/code&gt; clause is present, a &lt;em&gt;partial index&lt;/em&gt; is created. A partial index is an index that contains entries for only a portion of a table, usually a portion that is more useful for indexing than the rest of the table. For example, if you have a table that contains both billed and unbilled orders where the unbilled orders take up a small fraction of the total table and yet that is an often used section, you can improve performance by creating an index on just that portion. Another possible application is to use &lt;code&gt;WHERE&lt;/code&gt; with &lt;code&gt;UNIQUE&lt;/code&gt; to enforce uniqueness over a subset of a table. See &lt;a href=&quot;indexes-partial&quot;&gt;Section 11.8&lt;/a&gt; for more discussion.</source>
          <target state="translated">当 &lt;code&gt;WHERE&lt;/code&gt; 子句，一个&lt;em&gt;局部索引&lt;/em&gt;被创建。部分索引是仅包含表一部分的条目的索引，通常一部分索引比表的其余部分更有用。例如，如果您有一个既包含开票订单又包含未开票订单的表，其中未开票订单占总表的一小部分，但是这是经常使用的部分，则可以通过仅在该部分上创建索引来提高性能。另一个可能的应用是将 &lt;code&gt;WHERE&lt;/code&gt; 与 &lt;code&gt;UNIQUE&lt;/code&gt; 结合使用以对表的子集实施唯一性。有关更多讨论，请参见&lt;a href=&quot;indexes-partial&quot;&gt;第11.8节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4116b168926d645beb5cdf62d04cc02528b0adbd" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;\aset&lt;/code&gt; command is used, all combined SQL queries (separated by &lt;code&gt;\;&lt;/code&gt;) have their columns stored into variables named after column names, and prefixed with &lt;code&gt;prefix&lt;/code&gt; if provided. If a query returns no row, no assignment is made and the variable can be tested for existence to detect this. If a query returns more than one row, the last value is kept.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="438baff021646797a12e7710aeb9b4212d4a00b5" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;\gset&lt;/code&gt; command is used, the preceding SQL query is expected to return one row, the columns of which are stored into variables named after column names, and prefixed with &lt;code&gt;prefix&lt;/code&gt; if provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c185ac9497904ca6d14d82c8dc0a0e1690d4901" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;ampredlocks&lt;/code&gt; flag is not set, any scan using that index access method within a serializable transaction will acquire a nonblocking predicate lock on the full index. This will generate a read-write conflict with the insert of any tuple into that index by a concurrent serializable transaction. If certain patterns of read-write conflicts are detected among a set of concurrent serializable transactions, one of those transactions may be canceled to protect data integrity. When the flag is set, it indicates that the index access method implements finer-grained predicate locking, which will tend to reduce the frequency of such transaction cancellations.</source>
          <target state="translated">如果未设置 &lt;code&gt;ampredlocks&lt;/code&gt; 标志，则在可序列化事务中使用该索引访问方法进行的任何扫描都将获得对完整索引的无阻塞谓词锁定。这将与并发可序列化事务在该索引中插入任何元组产生读写冲突。如果在一组并发可序列化事务中检测到某些模式的读写冲突，则可以取消这些事务之一以保护数据完整性。设置该标志时，表明索引访问方法实现了更细粒度的谓词锁定，这将倾向于减少此类事务取消的频率。</target>
        </trans-unit>
        <trans-unit id="32c110466857121d054324f74c8a38f9bb5212e4" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;border&lt;/code&gt; setting is greater than zero, the &lt;code&gt;linestyle&lt;/code&gt; option also determines the characters with which the border lines are drawn. Plain ASCII characters work everywhere, but Unicode characters look nicer on displays that recognize them.</source>
          <target state="translated">当 &lt;code&gt;border&lt;/code&gt; 设置大于零时， &lt;code&gt;linestyle&lt;/code&gt; 选项还将确定绘制边框线所使用的字符。纯ASCII字符在任何地方都可以使用，但是Unicode字符在可以识别它们的显示器上看起来更好。</target>
        </trans-unit>
        <trans-unit id="00d6a0dfb20c2e25ada6bca76d0486b409be8ef1" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;pager&lt;/code&gt; option is &lt;code&gt;off&lt;/code&gt;, the pager program is not used. When the &lt;code&gt;pager&lt;/code&gt; option is &lt;code&gt;on&lt;/code&gt;, the pager is used when appropriate, i.e., when the output is to a terminal and will not fit on the screen. The &lt;code&gt;pager&lt;/code&gt; option can also be set to &lt;code&gt;always&lt;/code&gt;, which causes the pager to be used for all terminal output regardless of whether it fits on the screen. &lt;code&gt;\pset pager&lt;/code&gt; without a &lt;code&gt;value&lt;/code&gt; toggles pager use on and off.</source>
          <target state="translated">当 &lt;code&gt;pager&lt;/code&gt; 选项 &lt;code&gt;off&lt;/code&gt; ，不使用寻呼机程序。当 &lt;code&gt;pager&lt;/code&gt; 选项 &lt;code&gt;on&lt;/code&gt; ，将在适当的时候使用寻呼机，即，当输出到终端并且不适合屏幕时。该 &lt;code&gt;pager&lt;/code&gt; 选项也可以设定为 &lt;code&gt;always&lt;/code&gt; ，这导致用于所有终端输出不管是否它适合屏幕上的寻呼机。 &lt;code&gt;\pset pager&lt;/code&gt; 不带 &lt;code&gt;value&lt;/code&gt; 可打开和关闭传呼机的使用。</target>
        </trans-unit>
        <trans-unit id="81a140433737ca4c23a575624ce695fcc511dede" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;pg_buffercache&lt;/code&gt; view is accessed, internal buffer manager locks are taken for long enough to copy all the buffer state data that the view will display. This ensures that the view produces a consistent set of results, while not blocking normal buffer activity longer than necessary. Nonetheless there could be some impact on database performance if this view is read often.</source>
          <target state="translated">当访问 &lt;code&gt;pg_buffercache&lt;/code&gt; 视图时，将使用内部缓冲区管理器锁定足够长的时间以复制该视图将显示的所有缓冲区状态数据。这样可以确保视图产生一致的结果集，同时不会阻止正常的缓冲区活动超过所需的时间。但是，如果经常阅读该视图，可能会对数据库性能产生一些影响。</target>
        </trans-unit>
        <trans-unit id="cd60a2856753e705f8fe475e92d422e142a5a733" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;pg_prepared_xacts&lt;/code&gt; view is accessed, the internal transaction manager data structures are momentarily locked, and a copy is made for the view to display. This ensures that the view produces a consistent set of results, while not blocking normal operations longer than necessary. Nonetheless there could be some impact on database performance if this view is frequently accessed.</source>
          <target state="translated">当访问 &lt;code&gt;pg_prepared_xacts&lt;/code&gt; 视图时，内部事务管理器数据结构会暂时锁定，并创建一个副本以供视图显示。这样可以确保视图产生一致的结果集，同时不会阻止正常操作的持续时间超过必需的时间。但是，如果经常访问该视图，可能会对数据库性能产生一些影响。</target>
        </trans-unit>
        <trans-unit id="7ee8be71b9dbdb6fe9839b8abd30a5d0ca45b722" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;text&lt;/code&gt; format is used, the data read or written is a text file with one line per table row. Columns in a row are separated by the delimiter character. The column values themselves are strings generated by the output function, or acceptable to the input function, of each attribute's data type. The specified null string is used in place of columns that are null. &lt;code&gt;COPY FROM&lt;/code&gt; will raise an error if any line of the input file contains more or fewer columns than are expected.</source>
          <target state="translated">使用 &lt;code&gt;text&lt;/code&gt; 格式时，读取或写入的数据是一个文本文件，每表行一行。行中的列由定界符分隔。列值本身是由每个属性的数据类型的输出函数生成的字符串，或输入函数可接受的字符串。使用指定的空字符串代替空列。如果输入文件的任何行包含的列多于或少于预期，则 &lt;code&gt;COPY FROM&lt;/code&gt; 将引发错误。</target>
        </trans-unit>
        <trans-unit id="1c4c47cbbcff114da7b14a508ba7d65a0b19eac7" translate="yes" xml:space="preserve">
          <source>When the &lt;em&gt;&lt;code&gt;heapallindexed&lt;/code&gt;&lt;/em&gt; argument to verification functions is &lt;code&gt;true&lt;/code&gt;, an additional phase of verification is performed against the table associated with the target index relation. This consists of a &amp;ldquo;dummy&amp;rdquo;&lt;code&gt;CREATE INDEX&lt;/code&gt; operation, which checks for the presence of all hypothetical new index tuples against a temporary, in-memory summarizing structure (this is built when needed during the basic first phase of verification). The summarizing structure &amp;ldquo;fingerprints&amp;rdquo; every tuple found within the target index. The high level principle behind &lt;em&gt;&lt;code&gt;heapallindexed&lt;/code&gt;&lt;/em&gt; verification is that a new index that is equivalent to the existing, target index must only have entries that can be found in the existing structure.</source>
          <target state="translated">当验证函数的&lt;em&gt; &lt;code&gt;heapallindexed&lt;/code&gt; &lt;/em&gt;参数为 &lt;code&gt;true&lt;/code&gt; 时，将对与目标索引关系相关联的表执行附加验证阶段。这由&amp;ldquo;虚拟&amp;rdquo; &lt;code&gt;CREATE INDEX&lt;/code&gt; 操作组成，该操作根据临时的内存中汇总结构（在验证的基本第一阶段中需要时构建）来检查所有假设的新索引元组的存在。汇总结构&amp;ldquo;指纹化&amp;rdquo;目标索引中找到的每个元组。&lt;em&gt; &lt;code&gt;heapallindexed&lt;/code&gt; &lt;/em&gt;验证背后的高级原则是，与现有目标索引等效的新索引必须仅具有在现有结构中可以找到的条目。</target>
        </trans-unit>
        <trans-unit id="40b2d91686c90899997e62b0858a7f4eb03cb150" translate="yes" xml:space="preserve">
          <source>When the backup is in tar format, the target directory may be specified as &lt;code&gt;-&lt;/code&gt; (dash), causing the tar file to be written to &lt;code&gt;stdout&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4898e6eb712c6c928410a4432225d77730464bb" translate="yes" xml:space="preserve">
          <source>When the backup is in tar mode, and the directory is specified as &lt;code&gt;-&lt;/code&gt; (dash), the tar file will be written to &lt;code&gt;stdout&lt;/code&gt;.</source>
          <target state="translated">当备份处于tar模式并且目录指定为 &lt;code&gt;-&lt;/code&gt; （破折号）时，tar文件将被写入 &lt;code&gt;stdout&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2bf62b247e8d0c8ddb36cb4a11374b1155c5b650" translate="yes" xml:space="preserve">
          <source>When the client application uses the &amp;ldquo;extended query&amp;rdquo; protocol to issue a &lt;code&gt;FETCH&lt;/code&gt; command, the Bind protocol message specifies whether data is to be retrieved in text or binary format. This choice overrides the way that the cursor is defined. The concept of a binary cursor as such is thus obsolete when using extended query protocol &amp;mdash; any cursor can be treated as either text or binary.</source>
          <target state="translated">当客户端应用程序使用&amp;ldquo;扩展查询&amp;rdquo;协议发出 &lt;code&gt;FETCH&lt;/code&gt; 命令时，&amp;ldquo;绑定协议&amp;rdquo;消息指定是以文本还是二进制格式检索数据。此选择将覆盖定义光标的方式。因此，当使用扩展查询协议时，二进制游标的概念就已过时了-任何游标都可以视为文本或二进制。</target>
        </trans-unit>
        <trans-unit id="cef2bc6393c8c4a9107edf2302ecf0f071877452" translate="yes" xml:space="preserve">
          <source>When the connection to the server is lost, do not retry in a loop, just exit.</source>
          <target state="translated">当与服务器的连接丢失时,不要循环重试,只要退出即可。</target>
        </trans-unit>
        <trans-unit id="c8229aa8ad36a0b0c5e6146511e976844f24d945" translate="yes" xml:space="preserve">
          <source>When the database generates SQL, force all identifiers to be quoted, even if they are not (currently) keywords. This will affect the output of &lt;code&gt;EXPLAIN&lt;/code&gt; as well as the results of functions like &lt;code&gt;pg_get_viewdef&lt;/code&gt;. See also the &lt;code&gt;--quote-all-identifiers&lt;/code&gt; option of &lt;a href=&quot;app-pgdump&quot;&gt;pg_dump&lt;/a&gt; and &lt;a href=&quot;app-pg-dumpall&quot;&gt;pg_dumpall&lt;/a&gt;.</source>
          <target state="translated">当数据库生成SQL时，强制所有标识符加引号，即使它们不是（当前）关键字也是如此。这将影响 &lt;code&gt;EXPLAIN&lt;/code&gt; 的输出以及 &lt;code&gt;pg_get_viewdef&lt;/code&gt; 之类的函数的结果。另请参阅&lt;a href=&quot;app-pgdump&quot;&gt;pg_dump&lt;/a&gt;和&lt;a href=&quot;app-pg-dumpall&quot;&gt;pg_dumpall&lt;/a&gt;的 &lt;code&gt;--quote-all-identifiers&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="ea2bc8f44657321dd80c423b48806c42005dbc7a" translate="yes" xml:space="preserve">
          <source>When the database system has to perform an ordering or a character classification, it uses the collation of the input expression. This happens, for example, with &lt;code&gt;ORDER BY&lt;/code&gt; clauses and function or operator calls such as &lt;code&gt;&amp;lt;&lt;/code&gt;. The collation to apply for an &lt;code&gt;ORDER BY&lt;/code&gt; clause is simply the collation of the sort key. The collation to apply for a function or operator call is derived from the arguments, as described below. In addition to comparison operators, collations are taken into account by functions that convert between lower and upper case letters, such as &lt;code&gt;lower&lt;/code&gt;, &lt;code&gt;upper&lt;/code&gt;, and &lt;code&gt;initcap&lt;/code&gt;; by pattern matching operators; and by &lt;code&gt;to_char&lt;/code&gt; and related functions.</source>
          <target state="translated">当数据库系统必须执行排序或字符分类时，它将使用输入表达式的排序规则。例如，这发生在 &lt;code&gt;ORDER BY&lt;/code&gt; 子句和函数或运算符调用（例如 &lt;code&gt;&amp;lt;&lt;/code&gt; )上。申请 &lt;code&gt;ORDER BY&lt;/code&gt; 子句的排序规则只是排序键的排序规则。如下所述，从函数派生出用于申请函数或运算符的排序规则。除了比较运算符之外，在小写和大写字母之间进行转换的函数（例如 &lt;code&gt;lower&lt;/code&gt; ， &lt;code&gt;upper&lt;/code&gt; 和 &lt;code&gt;initcap&lt;/code&gt; )还考虑了归类。通过模式匹配运算符；以及 &lt;code&gt;to_char&lt;/code&gt; 和相关功能。</target>
        </trans-unit>
        <trans-unit id="cf20c03f9a438d0f6675629396820f040d752814" translate="yes" xml:space="preserve">
          <source>When the defaults aren't quite right, you can save yourself some typing by setting the environment variables &lt;code&gt;PGDATABASE&lt;/code&gt;, &lt;code&gt;PGHOST&lt;/code&gt;, &lt;code&gt;PGPORT&lt;/code&gt; and/or &lt;code&gt;PGUSER&lt;/code&gt; to appropriate values. (For additional environment variables, see &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;.) It is also convenient to have a &lt;code&gt;~/.pgpass&lt;/code&gt; file to avoid regularly having to type in passwords. See &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-pgpass.html&quot;&gt;Section 33.15&lt;/a&gt; for more information.</source>
          <target state="translated">当默认值不太正确时，可以通过将环境变量 &lt;code&gt;PGDATABASE&lt;/code&gt; ， &lt;code&gt;PGHOST&lt;/code&gt; ， &lt;code&gt;PGPORT&lt;/code&gt; 和/或 &lt;code&gt;PGUSER&lt;/code&gt; 设置为适当的值来节省键入时间。 （有关其他环境变量的信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;第33.14节&lt;/a&gt;。）拥有 &lt;code&gt;~/.pgpass&lt;/code&gt; 文件也很方便，以避免经常需要输入密码。有关更多信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-pgpass.html&quot;&gt;第33.15节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6f26c72fbc997c040dd4a76409d282497125e57c" translate="yes" xml:space="preserve">
          <source>When the defaults aren't quite right, you can save yourself some typing by setting the environment variables &lt;code&gt;PGDATABASE&lt;/code&gt;, &lt;code&gt;PGHOST&lt;/code&gt;, &lt;code&gt;PGPORT&lt;/code&gt; and/or &lt;code&gt;PGUSER&lt;/code&gt; to appropriate values. (For additional environment variables, see &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;.) It is also convenient to have a &lt;code&gt;~/.pgpass&lt;/code&gt; file to avoid regularly having to type in passwords. See &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-pgpass.html&quot;&gt;Section 33.15&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58644d348761a861122023ab84e086a5de61b1bd" translate="yes" xml:space="preserve">
          <source>When the input value is +/-Infinity, &lt;code&gt;extract&lt;/code&gt; returns +/-Infinity for monotonically-increasing fields (&lt;code&gt;epoch&lt;/code&gt;, &lt;code&gt;julian&lt;/code&gt;, &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;isoyear&lt;/code&gt;, &lt;code&gt;decade&lt;/code&gt;, &lt;code&gt;century&lt;/code&gt;, and &lt;code&gt;millennium&lt;/code&gt;). For other fields, NULL is returned. PostgreSQL versions before 9.6 returned zero for all cases of infinite input.</source>
          <target state="translated">当输入值是负无穷大， &lt;code&gt;extract&lt;/code&gt; 的回报+/-无穷远点的单调增加字段（ &lt;code&gt;epoch&lt;/code&gt; ， &lt;code&gt;julian&lt;/code&gt; ， &lt;code&gt;year&lt;/code&gt; ， &lt;code&gt;isoyear&lt;/code&gt; ， &lt;code&gt;decade&lt;/code&gt; ， &lt;code&gt;century&lt;/code&gt; ，和 &lt;code&gt;millennium&lt;/code&gt; ）。对于其他字段，返回NULL。对于无限输入的所有情况，9.6之前的PostgreSQL版本返回零。</target>
        </trans-unit>
        <trans-unit id="ca7b95a2bfd76e66a3b9a3c283932ae7ceb9d1f3" translate="yes" xml:space="preserve">
          <source>When the input value is of type &lt;code&gt;timestamp with time zone&lt;/code&gt;, the truncation is performed with respect to a particular time zone; for example, truncation to &lt;code&gt;day&lt;/code&gt; produces a value that is midnight in that zone. By default, truncation is done with respect to the current &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; setting, but the optional &lt;code&gt;time_zone&lt;/code&gt; argument can be provided to specify a different time zone. The time zone name can be specified in any of the ways described in &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;Section 8.5.3&lt;/a&gt;.</source>
          <target state="translated">当输入值是 &lt;code&gt;timestamp with time zone&lt;/code&gt; 类型时，将针对特定时区执行截断；例如，截断到 &lt;code&gt;day&lt;/code&gt; 会在该区域中产生一个午夜的值。默认情况下，会针对当前的&lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt;设置进行截断，但是可以提供可选的 &lt;code&gt;time_zone&lt;/code&gt; 参数来指定其他时区。可以使用&lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;第8.5.3节中&lt;/a&gt;描述的任何方式指定时区名称。</target>
        </trans-unit>
        <trans-unit id="b9861851aff8e3d639ce4f8c2222c534c2772377" translate="yes" xml:space="preserve">
          <source>When the last argument begins with &lt;code&gt;|&lt;/code&gt;, the entire remainder of the line is taken to be the &lt;code&gt;command&lt;/code&gt; to execute, and neither variable interpolation nor backquote expansion are performed in it. The rest of the line is simply passed literally to the shell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb992423a64d9af4e9c24a6d03361c5985029c38" translate="yes" xml:space="preserve">
          <source>When the node at the top of the parallel portion of the plan is &lt;code&gt;Gather Merge&lt;/code&gt; rather than &lt;code&gt;Gather&lt;/code&gt;, it indicates that each process executing the parallel portion of the plan is producing tuples in sorted order, and that the leader is performing an order-preserving merge. In contrast, &lt;code&gt;Gather&lt;/code&gt; reads tuples from the workers in whatever order is convenient, destroying any sort order that may have existed.</source>
          <target state="translated">当计划并行部分顶部的节点是 &lt;code&gt;Gather Merge&lt;/code&gt; 而不是 &lt;code&gt;Gather&lt;/code&gt; 时，表明执行计划并行部分的每个进程都按排序顺序生成元组，并且领导者正在执行顺序保留合并。相反， &lt;code&gt;Gather&lt;/code&gt; 会以任何方便的顺序从工人那里读取元组，从而破坏可能已经存在的任何排序顺序。</target>
        </trans-unit>
        <trans-unit id="3c8d54f7450d49b82cd5a8da77194f4c25e5cdb1" translate="yes" xml:space="preserve">
          <source>When the operating system sends a write request to the storage hardware, there is little it can do to make sure the data has arrived at a truly non-volatile storage area. Rather, it is the administrator's responsibility to make certain that all storage components ensure integrity for both data and file-system metadata. Avoid disk controllers that have non-battery-backed write caches. At the drive level, disable write-back caching if the drive cannot guarantee the data will be written before shutdown. If you use SSDs, be aware that many of these do not honor cache flush commands by default. You can test for reliable I/O subsystem behavior using &lt;a href=&quot;https://brad.livejournal.com/2116715.html&quot;&gt;&lt;code&gt;diskchecker.pl&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当操作系统将写请求发送到存储硬件时，几乎没有办法确保数据已经到达真正的非易失性存储区域。而是由管理员负责确保所有存储组件都确保数据和文件系统元数据的完整性。避免使用没有电池支持的写缓存的磁盘控制器。在驱动器级别，如果驱动器不能保证在关机之前将数据写入，请禁用回写缓存。如果使用SSD，请注意，其中许多默认情况下都不遵循高速缓存刷新命令。您可以使用&lt;a href=&quot;https://brad.livejournal.com/2116715.html&quot;&gt; &lt;code&gt;diskchecker.pl&lt;/code&gt; &lt;/a&gt;测试可靠的I / O子系统行为。</target>
        </trans-unit>
        <trans-unit id="2d33bb04f73c12f42af37757660638f7bf07dd0c" translate="yes" xml:space="preserve">
          <source>When the optimizer determines that parallel query is the fastest execution strategy for a particular query, it will create a query plan which includes a &lt;em&gt;Gather&lt;/em&gt; or &lt;em&gt;Gather Merge&lt;/em&gt; node. Here is a simple example:</source>
          <target state="translated">当优化器确定并行查询是特定查询的最快执行策略时，它将创建一个查询计划，其中包括一个&lt;em&gt;Gather&lt;/em&gt;或&lt;em&gt;Gather Merge&lt;/em&gt;节点。这是一个简单的示例：</target>
        </trans-unit>
        <trans-unit id="01b643d7a7954ad91561b8c24a008664f59d15dd" translate="yes" xml:space="preserve">
          <source>When the option list is surrounded by parentheses, the options can be written in any order. The parenthesized syntax was added in PostgreSQL 11; the unparenthesized syntax is deprecated.</source>
          <target state="translated">当选项列表被括号包围时,选项可以按任何顺序书写。在PostgreSQL 11中加入了括号语法,不加括号的语法已被废弃。</target>
        </trans-unit>
        <trans-unit id="abee5df8a890efa75529bd092cf02d64e5f74e41" translate="yes" xml:space="preserve">
          <source>When the option list is surrounded by parentheses, the options can be written in any order. Without parentheses, options must be specified in exactly the order shown above. The parenthesized syntax was added in PostgreSQL 9.0; the unparenthesized syntax is deprecated.</source>
          <target state="translated">当选项列表被括号包围时,选项可以按任何顺序书写。如果没有括号,则必须按照上面显示的顺序来指定选项。在PostgreSQL 9.0中加入了括号语法,而不加括号的语法已被废弃。</target>
        </trans-unit>
        <trans-unit id="0e9dc738f4097cde58c9e8bf1cce2f13a3e0faff" translate="yes" xml:space="preserve">
          <source>When the query executor is running a statement using &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt;, individual operations are timed as well as showing a summary. The overhead of your system can be checked by counting rows with the psql program:</source>
          <target state="translated">当查询执行程序使用 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 运行语句时，将对单个操作进行计时并显示摘要。可以通过使用psql程序对行进行计数来检查系统的开销：</target>
        </trans-unit>
        <trans-unit id="a4efc71382094156bb1e14ebb8922c4bbfee26e8" translate="yes" xml:space="preserve">
          <source>When the query involves more than two relations, the final result must be built up by a tree of join steps, each with two inputs. The planner examines different possible join sequences to find the cheapest one.</source>
          <target state="translated">当查询涉及两个以上的关系时,最终的结果必须由连接步骤的树来建立,每个步骤有两个输入。规划者会检查不同的可能的连接序列,以找到最便宜的序列。</target>
        </trans-unit>
        <trans-unit id="f91c3e21cf6bd9480dad3eeeece86758f55a90e3" translate="yes" xml:space="preserve">
          <source>When the query involves outer joins, the planner has less freedom than it does for plain (inner) joins. For example, consider:</source>
          <target state="translated">当查询涉及到外部连接时,规划师的自由度比普通(内部)连接要小。例如,考虑:</target>
        </trans-unit>
        <trans-unit id="53d57a11c26095ca3bee53a6ad82668d9cd1b948" translate="yes" xml:space="preserve">
          <source>When the replication client of pg_receivewal is configured on the server as a synchronous standby, then using a replication slot will report the flush position to the server, but only when a WAL file is closed. Therefore, that configuration will cause transactions on the primary to wait for a long time and effectively not work satisfactorily. The option &lt;code&gt;--synchronous&lt;/code&gt; (see below) must be specified in addition to make this work correctly.</source>
          <target state="translated">当在服务器上将pg_receivewal的复制客户端配置为同步备用服务器时，则使用复制插槽将向服务器报告刷新位置，但仅当WAL文件关闭时才如此。因此，该配置将导致主数据库上的事务等待很长时间，并且实际上不能令人满意地工作。为了使此功能正常工作，还必须指定选项 &lt;code&gt;--synchronous&lt;/code&gt; （请参见下文）。</target>
        </trans-unit>
        <trans-unit id="6e97e877617ee50758f9c1ed0038c82401b37ff4" translate="yes" xml:space="preserve">
          <source>When the server finds an entry in the &lt;code&gt;pg_pltemplate&lt;/code&gt; catalog for the given language name, it will use the catalog data even if the command includes language parameters. This behavior simplifies loading of old dump files, which are likely to contain out-of-date information about language support functions.</source>
          <target state="translated">当服务器在 &lt;code&gt;pg_pltemplate&lt;/code&gt; 目录中找到给定语言名称的条目时，即使命令包含语言参数，它也会使用目录数据。此行为简化了旧转储文件的加载，这些文件可能包含有关语言支持功能的过时信息。</target>
        </trans-unit>
        <trans-unit id="826ce26725107a5df987e11185041fdbac70af26" translate="yes" xml:space="preserve">
          <source>When the standby is started and &lt;code&gt;primary_conninfo&lt;/code&gt; is set correctly, the standby will connect to the primary after replaying all WAL files available in the archive. If the connection is established successfully, you will see a &lt;code&gt;walreceiver&lt;/code&gt; in the standby, and a corresponding &lt;code&gt;walsender&lt;/code&gt; process in the primary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5acf91c2009ea693cf720914c5dcc7ec25263a3f" translate="yes" xml:space="preserve">
          <source>When the standby is started and &lt;code&gt;primary_conninfo&lt;/code&gt; is set correctly, the standby will connect to the primary after replaying all WAL files available in the archive. If the connection is established successfully, you will see a walreceiver process in the standby, and a corresponding walsender process in the primary.</source>
          <target state="translated">启动备用数据库并正确设置 &lt;code&gt;primary_conninfo&lt;/code&gt; 后，备用数据库将在重播存档中所有可用的WAL文件后连接到主要数据库。如果成功建立连接，您将在备用数据库中看到一个walreceiver进程，在主数据库中看到一个相应的walsender进程。</target>
        </trans-unit>
        <trans-unit id="eedf68c3267fbf09aabeff8e3149a2fc6e02e4a5" translate="yes" xml:space="preserve">
          <source>When the system is forced to combine multiple page-level predicate locks into a single relation-level predicate lock because the predicate lock table is short of memory, an increase in the rate of serialization failures may occur. You can avoid this by increasing &lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-TRANSACTION&quot;&gt;max_pred_locks_per_transaction&lt;/a&gt;, &lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-RELATION&quot;&gt;max_pred_locks_per_relation&lt;/a&gt;, and/or &lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-PAGE&quot;&gt;max_pred_locks_per_page&lt;/a&gt;.</source>
          <target state="translated">当系统由于谓词锁表内存不足而被迫将多个页面级谓词锁组合到单个关系级谓词锁中时，可能会增加序列化失败率。您可以通过增加&lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-TRANSACTION&quot;&gt;max_pred_locks_per_transaction&lt;/a&gt;，&lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-RELATION&quot;&gt;max_pred_locks_per_relation&lt;/a&gt;和/或&lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-PAGE&quot;&gt;max_pred_locks_per_page&lt;/a&gt;来避免这种情况。</target>
        </trans-unit>
        <trans-unit id="1e5d69b735badff5a43514c3f20c29f9fa27a5a4" translate="yes" xml:space="preserve">
          <source>When the target server is started for the first time after running pg_rewind, it will go into recovery mode and replay all WAL generated in the source server after the point of divergence. If some of the WAL was no longer available in the source server when pg_rewind was run, and therefore could not be copied by the pg_rewind session, it must be made available when the target server is started. This can be done by creating a &lt;code&gt;recovery.signal&lt;/code&gt; file in the target data directory and configuring suitable &lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;restore_command&lt;/a&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="translated">在运行pg_rewind之后首次启动目标服务器时，它将进入恢复模式，并在分歧点之后重播源服务器中生成的所有WAL。如果运行pg_rewind时某些WAL在源服务器中不再可用，因此pg_rewind会话无法复制，则必须在启动目标服务器时使其可用。这可以通过在目标数据目录中创建 &lt;code&gt;recovery.signal&lt;/code&gt; 文件并在 &lt;code&gt;postgresql.conf&lt;/code&gt; 中配置适当的&lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;restore_command&lt;/a&gt;来完成。</target>
        </trans-unit>
        <trans-unit id="46d8ca3256e28b3a76b80a636c768a65a62af8f1" translate="yes" xml:space="preserve">
          <source>When the token is a number or number field:</source>
          <target state="translated">当令牌是一个数字或数字字段时。</target>
        </trans-unit>
        <trans-unit id="13de437cb552624377cc1efe8012608874203a3b" translate="yes" xml:space="preserve">
          <source>When there are &lt;code&gt;OUT&lt;/code&gt; or &lt;code&gt;INOUT&lt;/code&gt; parameters, the &lt;code&gt;RETURNS&lt;/code&gt; clause can be omitted. If present, it must agree with the result type implied by the output parameters: &lt;code&gt;RECORD&lt;/code&gt; if there are multiple output parameters, or the same type as the single output parameter.</source>
          <target state="translated">当有 &lt;code&gt;OUT&lt;/code&gt; 或 &lt;code&gt;INOUT&lt;/code&gt; 参数时，可以省略 &lt;code&gt;RETURNS&lt;/code&gt; 子句。如果存在，则必须与输出参数隐含的结果类型一致：如果有多个输出参数，或者与单个输出参数具有相同的类型，则为 &lt;code&gt;RECORD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3cbc021b4d99bd0fb8948c27e6c55ec68fedb0d0" translate="yes" xml:space="preserve">
          <source>When there are multiple queries in the &lt;code&gt;WITH&lt;/code&gt; clause, &lt;code&gt;RECURSIVE&lt;/code&gt; should be written only once, immediately after &lt;code&gt;WITH&lt;/code&gt;. It applies to all queries in the &lt;code&gt;WITH&lt;/code&gt; clause, though it has no effect on queries that do not use recursion or forward references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="086da7e4c8252cf99eea2a26d212bfca20a89638" translate="yes" xml:space="preserve">
          <source>When there are no &lt;code&gt;GIN_MAYBE&lt;/code&gt; values in the &lt;code&gt;check&lt;/code&gt; vector, a &lt;code&gt;GIN_MAYBE&lt;/code&gt; return value is the equivalent of setting the &lt;code&gt;recheck&lt;/code&gt; flag in the Boolean &lt;code&gt;consistent&lt;/code&gt; function.</source>
          <target state="translated">当没有 &lt;code&gt;GIN_MAYBE&lt;/code&gt; 中的值 &lt;code&gt;check&lt;/code&gt; 载体， &lt;code&gt;GIN_MAYBE&lt;/code&gt; 返回值是相当于设置的 &lt;code&gt;recheck&lt;/code&gt; 在布尔标志 &lt;code&gt;consistent&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="6d0ae32f2046467b15848b335dcbaffbcaf195f8" translate="yes" xml:space="preserve">
          <source>When this command is used, the preceding SQL query is expected to return one row, the columns of which are stored into variables named after column names, and prefixed with &lt;code&gt;prefix&lt;/code&gt; if provided.</source>
          <target state="translated">使用此命令时，预期前面的SQL查询将返回一行，该行的各列存储在以列名命名的变量中，并且如果提供则以 &lt;code&gt;prefix&lt;/code&gt; 为前缀。</target>
        </trans-unit>
        <trans-unit id="d01a63b618f24f934c421a450096ebe3b2d3fb7a" translate="yes" xml:space="preserve">
          <source>When this feature is enabled, freed space at the end of a relation cannot be released to the operating system, since that could remove information needed to detect the &amp;ldquo;snapshot too old&amp;rdquo; condition. All space allocated to a relation remains associated with that relation for reuse only within that relation unless explicitly freed (for example, with &lt;code&gt;VACUUM FULL&lt;/code&gt;).</source>
          <target state="translated">启用此功能后，关联末尾的释放空间无法释放给操作系统，因为这可能会删除检测&amp;ldquo;快照过旧&amp;rdquo;情况所需的信息。分配给一个关系的所有空间都保持与该关系的关联，除非明确释放（例如，使用 &lt;code&gt;VACUUM FULL&lt;/code&gt; ），否则仅在该关系内可以重用。</target>
        </trans-unit>
        <trans-unit id="edeb5910da7722ed71fd344bba96eef32a3f6641" translate="yes" xml:space="preserve">
          <source>When this happens, the range will be summarized normally during the next regular vacuum of the table.</source>
          <target state="translated">当这种情况发生时,范围将在下一次常规的表格真空期间正常汇总。</target>
        </trans-unit>
        <trans-unit id="e4570af0f67cc29537d90c659afba5db93e8b7f0" translate="yes" xml:space="preserve">
          <source>When this is enabled, the backup will start by enumerating the size of the entire database, and then go back and send the actual contents. This may make the backup take slightly longer, and in particular it will take longer before the first data is sent.</source>
          <target state="translated">启用此功能后,备份将从列举整个数据库的大小开始,然后返回并发送实际内容。这可能会使备份的时间稍长,特别是在发送第一个数据之前需要更长的时间。</target>
        </trans-unit>
        <trans-unit id="ba484c59ded97840ba63ed48a33d5adcad782f3b" translate="yes" xml:space="preserve">
          <source>When this option is used, PostgreSQL will build the index without taking any locks that prevent concurrent inserts, updates, or deletes on the table; whereas a standard index build locks out writes (but not reads) on the table until it's done. There are several caveats to be aware of when using this option &amp;mdash; see &lt;a href=&quot;sql-createindex#SQL-CREATEINDEX-CONCURRENTLY&quot;&gt;Building Indexes Concurrently&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28c1776ab93887297f059584c258d507675ecdfe" translate="yes" xml:space="preserve">
          <source>When this option is used, PostgreSQL will build the index without taking any locks that prevent concurrent inserts, updates, or deletes on the table; whereas a standard index build locks out writes (but not reads) on the table until it's done. There are several caveats to be aware of when using this option &amp;mdash; see &lt;a href=&quot;sql-createindex#SQL-CREATEINDEX-CONCURRENTLY&quot;&gt;Building Indexes Concurrently&lt;/a&gt;.</source>
          <target state="translated">当使用该选项时，PostgreSQL将建立索引而不会采取任何防止在表上进行并发插入，更新或删除的锁。而标准索引构建会锁定对表的写入（但不会读取），直到完成为止。使用此选项时需要注意一些注意事项-请参阅&lt;a href=&quot;sql-createindex#SQL-CREATEINDEX-CONCURRENTLY&quot;&gt;同时构建索引&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9cfbc756ec0e3884dc8a6bdc957bf776447f05d6" translate="yes" xml:space="preserve">
          <source>When this option is used, PostgreSQL will rebuild the index without taking any locks that prevent concurrent inserts, updates, or deletes on the table; whereas a standard index rebuild locks out writes (but not reads) on the table until it's done. There are several caveats to be aware of when using this option &amp;mdash; see &lt;a href=&quot;sql-reindex#SQL-REINDEX-CONCURRENTLY&quot;&gt;Rebuilding Indexes Concurrently&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="469c5b3c25ebc28298d0a68f767fa4e6b9232f83" translate="yes" xml:space="preserve">
          <source>When this option is used, PostgreSQL will rebuild the index without taking any locks that prevent concurrent inserts, updates, or deletes on the table; whereas a standard index rebuild locks out writes (but not reads) on the table until it's done. There are several caveats to be aware of when using this option &amp;mdash; see &lt;a href=&quot;sql-reindex#SQL-REINDEX-CONCURRENTLY&quot;&gt;Rebuilding Indexes Concurrently&lt;/a&gt;.</source>
          <target state="translated">使用此选项时，PostgreSQL将重建索引，而不会采取任何防止在表上进行并发插入，更新或删除的锁定。而标准索引重建会锁定表上的写入（但不会读取），直到完成。使用此选项时需要注意一些注意事项-请参阅&lt;a href=&quot;sql-reindex#SQL-REINDEX-CONCURRENTLY&quot;&gt;同时重建索引&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8c3757e4ca86742c07911d6404be9ee33ce2c815" translate="yes" xml:space="preserve">
          <source>When this option is used, psql will connect to the database &lt;code&gt;postgres&lt;/code&gt;, unless a different database is named on the command line (option &lt;code&gt;-d&lt;/code&gt; or non-option argument, possibly via a service entry, but not via an environment variable).</source>
          <target state="translated">使用此选项时，psql将连接到数据库 &lt;code&gt;postgres&lt;/code&gt; ，除非在命令行上指定了其他数据库（选项 &lt;code&gt;-d&lt;/code&gt; 或非选项参数，可能通过服务条目，而不是环境变量）。</target>
        </trans-unit>
        <trans-unit id="2bc222201723d0a9f83d166df5e42c7cf99836b6" translate="yes" xml:space="preserve">
          <source>When this option is used, the database named with &lt;code&gt;-d&lt;/code&gt; is used only to issue the initial &lt;code&gt;DROP DATABASE&lt;/code&gt; and &lt;code&gt;CREATE DATABASE&lt;/code&gt; commands. All data is restored into the database name that appears in the archive.</source>
          <target state="translated">使用此选项时，以 &lt;code&gt;-d&lt;/code&gt; 命名的数据库仅用于发出初始 &lt;code&gt;DROP DATABASE&lt;/code&gt; 和 &lt;code&gt;CREATE DATABASE&lt;/code&gt; 命令。所有数据都将还原到存档中显示的数据库名称中。</target>
        </trans-unit>
        <trans-unit id="3390cee1b88ac1d254da2a22a816a53421d2e870" translate="yes" xml:space="preserve">
          <source>When this parameter allows it for a particular table, the planner compares query conditions with the table's &lt;code&gt;CHECK&lt;/code&gt; constraints, and omits scanning tables for which the conditions contradict the constraints. For example:</source>
          <target state="translated">当此参数允许它用于特定表时，计划程序会将查询条件与表的 &lt;code&gt;CHECK&lt;/code&gt; 约束进行比较，并忽略条件与约束相矛盾的扫描表。例如：</target>
        </trans-unit>
        <trans-unit id="70be33b4f92d88452bcc535d531cf8223b72afbc" translate="yes" xml:space="preserve">
          <source>When this parameter is &lt;code&gt;on&lt;/code&gt;, the PostgreSQL server compresses a full page image written to WAL when &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; is on or during a base backup. A compressed page image will be decompressed during WAL replay. The default value is &lt;code&gt;off&lt;/code&gt;. Only superusers can change this setting.</source>
          <target state="translated">如果 &lt;code&gt;on&lt;/code&gt; 此参数，则在&lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;启用full_page_writes&lt;/a&gt;或在基本备份期间，PostgreSQL服务器将压缩写入WAL的整页映像。在WAL重放期间，压缩的页面图像将被解压缩。默认值是 &lt;code&gt;off&lt;/code&gt; 。只有超级用户可以更改此设置。</target>
        </trans-unit>
        <trans-unit id="095a2e6ccc43e3049250993f0343788b4a6a861a" translate="yes" xml:space="preserve">
          <source>When this parameter is &lt;code&gt;on&lt;/code&gt;, the PostgreSQL server writes the entire content of each disk page to WAL during the first modification of that page after a checkpoint, even for non-critical modifications of so-called hint bits.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; 此参数后，PostgreSQL服务器会在检查点之后对该页面的第一次修改期间将每个磁盘页面的全部内容写入WAL，即使是非关键性的所谓提示位修改也是如此。</target>
        </trans-unit>
        <trans-unit id="ff47b09b0654ad59cedec7d15e17e9fba55f3e2b" translate="yes" xml:space="preserve">
          <source>When this parameter is on, &lt;code&gt;sepgsql&lt;/code&gt; functions in permissive mode, even if SELinux in general is working in enforcing mode. This parameter is primarily useful for testing purposes.</source>
          <target state="translated">启用此参数后，即使SELinux通常在强制模式下运行， &lt;code&gt;sepgsql&lt;/code&gt; 也会在许可模式下运行。此参数主要用于测试目的。</target>
        </trans-unit>
        <trans-unit id="b664e492ac1b6b5bd7bf06b57282c7f341a60102" translate="yes" xml:space="preserve">
          <source>When this parameter is on, per-plan-node timing occurs for all statements executed, whether or not they run long enough to actually get logged. This can have an extremely negative impact on performance. Turning off &lt;code&gt;auto_explain.log_timing&lt;/code&gt; ameliorates the performance cost, at the price of obtaining less information.</source>
          <target state="translated">启用此参数后，所有计划执行的语句都会按计划节点计时，无论这些语句是否运行了足够长的时间才能实际被记录下来。这可能会对性能产生极大的负面影响。关闭 &lt;code&gt;auto_explain.log_timing&lt;/code&gt; 可以降低性能成本，但需要获取较少的信息。</target>
        </trans-unit>
        <trans-unit id="d4e134d46721d701b088fe76d2d53da371f96514" translate="yes" xml:space="preserve">
          <source>When this parameter is on, the PostgreSQL server writes the entire content of each disk page to WAL during the first modification of that page after a checkpoint. This is needed because a page write that is in process during an operating system crash might be only partially completed, leading to an on-disk page that contains a mix of old and new data. The row-level change data normally stored in WAL will not be enough to completely restore such a page during post-crash recovery. Storing the full page image guarantees that the page can be correctly restored, but at the price of increasing the amount of data that must be written to WAL. (Because WAL replay always starts from a checkpoint, it is sufficient to do this during the first change of each page after a checkpoint. Therefore, one way to reduce the cost of full-page writes is to increase the checkpoint interval parameters.)</source>
          <target state="translated">当这个参数开启时,PostgreSQL服务器会在检查点后第一次修改该页时,将每个磁盘页的全部内容写入WAL。之所以需要这样做,是因为在操作系统崩溃期间正在进行的页面写入可能只完成了一部分,导致磁盘页面中包含新旧数据的混合。通常存储在WAL中的行级变化数据不足以在崩溃后恢复期间完全恢复这样的页面。存储完整的页面映像可以保证正确地恢复该页面,但代价是必须增加写入 WAL 的数据量。(因为WAL重放总是从检查点开始,所以在检查点后的每个页面的第一次变化时就可以做到这一点。因此,降低全页写入成本的一种方法是增加检查点间隔参数)。)</target>
        </trans-unit>
        <trans-unit id="5a1902b314fccc53fa419bb9d1c5d0a54674b4cd" translate="yes" xml:space="preserve">
          <source>When this variable is set to &lt;code&gt;on&lt;/code&gt; and a backslash command queries the database, the query is first shown. This feature helps you to study PostgreSQL internals and provide similar functionality in your own programs. (To select this behavior on program start-up, use the switch &lt;code&gt;-E&lt;/code&gt;.) If you set this variable to the value &lt;code&gt;noexec&lt;/code&gt;, the queries are just shown but are not actually sent to the server and executed. The default value is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">当此变量设置为 &lt;code&gt;on&lt;/code&gt; 并且反斜杠命令查询数据库时，将首先显示该查询。此功能可帮助您研究PostgreSQL内部结构并在您自己的程序中提供类似的功能。（要在程序启动时选择此行为，请使用 &lt;code&gt;-E&lt;/code&gt; 开关。）如果将此变量设置为值 &lt;code&gt;noexec&lt;/code&gt; ，则仅显示查询，但实际上并未发送给服务器并执行查询。默认值是 &lt;code&gt;off&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0a31ece5bfbb183043ca04edf566185c4d24f24d" translate="yes" xml:space="preserve">
          <source>When throttling is active, the transaction latency reported at the end of the run is calculated from the scheduled start times, so it includes the time each transaction had to wait for the previous transaction to finish. The wait time is called the schedule lag time, and its average and maximum are also reported separately. The transaction latency with respect to the actual transaction start time, i.e. the time spent executing the transaction in the database, can be computed by subtracting the schedule lag time from the reported latency.</source>
          <target state="translated">当节流处于活动状态时,运行结束时报告的事务延迟是从计划开始时间计算出来的,因此它包括每个事务必须等待前一个事务完成的时间。等待时间被称为计划滞后时间,它的平均值和最大值也被分别报告。从报告的延迟中减去计划滞后时间,就可以计算出相对于实际事务开始时间的事务延迟,即在数据库中执行事务的时间。</target>
        </trans-unit>
        <trans-unit id="bf9d744865a36adaaaa98eb0ce0a8d0e8d495ea9" translate="yes" xml:space="preserve">
          <source>When throttling is active, the transaction latency reported at the end of the run is calculated from the scheduled start times, so it includes the time each transaction had to wait for the previous transaction to finish. The wait time is called the schedule lag time, and its average and maximum are also reported separately. The transaction latency with respect to the actual transaction start time, i.e., the time spent executing the transaction in the database, can be computed by subtracting the schedule lag time from the reported latency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62a5ce62fea33e48d7ca4dcdb6fc1d49b58833f9" translate="yes" xml:space="preserve">
          <source>When throttling is used (&lt;code&gt;--rate=...&lt;/code&gt;), transactions that lag behind schedule by more than &lt;code&gt;limit&lt;/code&gt; ms, and thus have no hope of meeting the latency limit, are not sent to the server at all. They are counted and reported separately as &lt;em&gt;skipped&lt;/em&gt;.</source>
          <target state="translated">使用节流（ &lt;code&gt;--rate=...&lt;/code&gt; ）时，比计划延迟时间超出 &lt;code&gt;limit&lt;/code&gt; ms的事务将因此根本没有发送到服务器的等待时间。&lt;em&gt;跳过时，将对&lt;/em&gt;它们进行计数和报告。</target>
        </trans-unit>
        <trans-unit id="b0431d629c5fa2195a09522dc9eddb52b7d7ef5d" translate="yes" xml:space="preserve">
          <source>When to JIT?</source>
          <target state="translated">什么时候进行JIT?</target>
        </trans-unit>
        <trans-unit id="c212a8c30b6a166bd84fdfc048fb956853e7ba65" translate="yes" xml:space="preserve">
          <source>When two arrays with an equal number of dimensions are concatenated, the result retains the lower bound subscript of the left-hand operand's outer dimension. The result is an array comprising every element of the left-hand operand followed by every element of the right-hand operand. For example:</source>
          <target state="translated">当两个维数相同的数组进行连接时,结果保留了左手操作数的外维数的下标。结果是一个由左手操作数的每个元素和右手操作数的每个元素组成的数组。举例来说,在这个数组中,左手操作数的每一个元素后面都跟着右手操作数的每一个元素。</target>
        </trans-unit>
        <trans-unit id="75c057cb6b39ec5ed6fcfc1f9fbef6e3ffe333d8" translate="yes" xml:space="preserve">
          <source>When two or more &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;databases&lt;/a&gt; are linked via &lt;a href=&quot;glossary#GLOSSARY-REPLICATION&quot;&gt;replication&lt;/a&gt;, the &lt;a href=&quot;glossary#GLOSSARY-SERVER&quot;&gt;server&lt;/a&gt; that is considered the authoritative source of information is called the &lt;em&gt;primary&lt;/em&gt;, also known as a &lt;em&gt;master&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a09c4eb9b4b598594720766db600d02893739065" translate="yes" xml:space="preserve">
          <source>When used as a standalone program all WAL files logically preceding the &lt;code&gt;oldestkeptwalfile&lt;/code&gt; will be removed from &lt;code&gt;archivelocation&lt;/code&gt;. In this mode, if you specify a &lt;code&gt;.partial&lt;/code&gt; or &lt;code&gt;.backup&lt;/code&gt; file name, then only the file prefix will be used as the &lt;code&gt;oldestkeptwalfile&lt;/code&gt;. This treatment of &lt;code&gt;.backup&lt;/code&gt; file name allows you to remove all WAL files archived prior to a specific base backup without error. For example, the following example will remove all files older than WAL file name &lt;code&gt;000000010000003700000010&lt;/code&gt;:</source>
          <target state="translated">当用作独立程序时，从逻辑上将在 &lt;code&gt;oldestkeptwalfile&lt;/code&gt; 文件之前的所有WAL文件都从 &lt;code&gt;archivelocation&lt;/code&gt; 中删除。在此模式下，如果指定 &lt;code&gt;.partial&lt;/code&gt; 或 &lt;code&gt;.backup&lt;/code&gt; 文件名，则仅文件前缀将用作 &lt;code&gt;oldestkeptwalfile&lt;/code&gt; 。对 &lt;code&gt;.backup&lt;/code&gt; 文件名的这种处理使您可以删除在特定基本备份之前存档的所有WAL文件，而不会出现错误。例如，以下示例将删除所有早于WAL文件名 &lt;code&gt;000000010000003700000010&lt;/code&gt; 的文件：</target>
        </trans-unit>
        <trans-unit id="54ce62d903f7c6555c73f41594c6b595d712ec4b" translate="yes" xml:space="preserve">
          <source>When used in exclusive mode, this function writes a backup label file (&lt;code&gt;backup_label&lt;/code&gt;) and, if there are any links in the &lt;code&gt;pg_tblspc/&lt;/code&gt; directory, a tablespace map file (&lt;code&gt;tablespace_map&lt;/code&gt;) into the database cluster's data directory, then performs a checkpoint, and then returns the backup's starting write-ahead log location. (The user can ignore this result value, but it is provided in case it is useful.) When used in non-exclusive mode, the contents of these files are instead returned by the &lt;code&gt;pg_stop_backup&lt;/code&gt; function, and should be copied to the backup area by the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4f92bbabc1b26d77780494bcd623901f19d77be" translate="yes" xml:space="preserve">
          <source>When used with one of the archive file formats and combined with pg_restore, pg_dump provides a flexible archival and transfer mechanism. pg_dump can be used to backup an entire database, then pg_restore can be used to examine the archive and/or select which parts of the database are to be restored. The most flexible output file formats are the &amp;ldquo;custom&amp;rdquo; format (&lt;code&gt;-Fc&lt;/code&gt;) and the &amp;ldquo;directory&amp;rdquo; format (&lt;code&gt;-Fd&lt;/code&gt;). They allow for selection and reordering of all archived items, support parallel restoration, and are compressed by default. The &amp;ldquo;directory&amp;rdquo; format is the only format that supports parallel dumps.</source>
          <target state="translated">当与一种存档文件格式一起使用并与pg_restore结合使用时，pg_dump提供了一种灵活的归档和传输机制。 pg_dump可用于备份整个数据库，然后pg_restore可用于检查存档和/或选择要还原数据库的哪些部分。最灵活的输出文件格式是&amp;ldquo;自定义&amp;rdquo;格式（ &lt;code&gt;-Fc&lt;/code&gt; ）和&amp;ldquo;目录&amp;rdquo;格式（ &lt;code&gt;-Fd&lt;/code&gt; ）。它们允许对所有已归档项目进行选择和重新排序，支持并行还原，并且默认情况下已压缩。 &amp;ldquo;目录&amp;rdquo;格式是唯一支持并行转储的格式。</target>
        </trans-unit>
        <trans-unit id="7fe14a6b317961785cf4d152bc27d49064bcda5a" translate="yes" xml:space="preserve">
          <source>When used within &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-CLEANUP-COMMAND&quot;&gt;archive_cleanup_command&lt;/a&gt;, all WAL files logically preceding the value of the &lt;code&gt;%r&lt;/code&gt; argument will be removed from &lt;code&gt;archivelocation&lt;/code&gt;. This minimizes the number of files that need to be retained, while preserving crash-restart capability. Use of this parameter is appropriate if the &lt;code&gt;archivelocation&lt;/code&gt; is a transient staging area for this particular standby server, but &lt;em&gt;not&lt;/em&gt; when the &lt;code&gt;archivelocation&lt;/code&gt; is intended as a long-term WAL archive area, or when multiple standby servers are recovering from the same archive location.</source>
          <target state="translated">当在&lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-CLEANUP-COMMAND&quot;&gt;archive_cleanup_command中使用时&lt;/a&gt;，逻辑上 &lt;code&gt;%r&lt;/code&gt; 参数值之前的所有WAL文件都将从 &lt;code&gt;archivelocation&lt;/code&gt; 中删除。这样可以最大程度地减少需要保留的文件数量，同时保留崩溃重新启动功能。如果使用此参数是合适的 &lt;code&gt;archivelocation&lt;/code&gt; 这种特别的备用服务器短暂停留区域，而&lt;em&gt;不是&lt;/em&gt;当 &lt;code&gt;archivelocation&lt;/code&gt; 的目的是作为一个长期的WAL归档区，或当多个备用服务器从同一存档位置恢复。</target>
        </trans-unit>
        <trans-unit id="7051b09dcb61945ea4e0d3beb1e52e65c9014732" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;COPY FROM&lt;/code&gt;, any data item that matches this string will be stored as a null value, so you should make sure that you use the same string as you used with &lt;code&gt;COPY TO&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;COPY FROM&lt;/code&gt; 时，与该字符串匹配的任何数据项都将存储为空值，因此，请确保使用与 &lt;code&gt;COPY TO&lt;/code&gt; 相同的字符串。</target>
        </trans-unit>
        <trans-unit id="f8b5d7a27b46e73dc32c1b851c7dfef0ad7fe8a0" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;LIMIT&lt;/code&gt;, it is a good idea to use an &lt;code&gt;ORDER BY&lt;/code&gt; clause that constrains the result rows into a unique order. Otherwise you will get an unpredictable subset of the query's rows &amp;mdash; you might be asking for the tenth through twentieth rows, but tenth through twentieth in what ordering? You don't know what ordering unless you specify &lt;code&gt;ORDER BY&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;LIMIT&lt;/code&gt; 时，最好使用 &lt;code&gt;ORDER BY&lt;/code&gt; 子句将结果行约束为唯一顺序。否则，您将获得查询行的不可预测的子集-您可能会要求以第十到第二十行，但是以什么顺序来请求第十到第二十行？除非您指定 &lt;code&gt;ORDER BY&lt;/code&gt; ,否则您不知道什么顺序。</target>
        </trans-unit>
        <trans-unit id="481c23a58e8db851baee87afbfd06f8aa525bda9" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;LIMIT&lt;/code&gt;, it is important to use an &lt;code&gt;ORDER BY&lt;/code&gt; clause that constrains the result rows into a unique order. Otherwise you will get an unpredictable subset of the query's rows. You might be asking for the tenth through twentieth rows, but tenth through twentieth in what ordering? The ordering is unknown, unless you specified &lt;code&gt;ORDER BY&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;LIMIT&lt;/code&gt; 时，重要的是使用 &lt;code&gt;ORDER BY&lt;/code&gt; 子句将结果行约束为唯一顺序。否则，您将获得查询行的不可预测的子集。您可能会要求输入第十到第二十行，但是以什么顺序要求输入第十到第二十行？除非您指定 &lt;code&gt;ORDER BY&lt;/code&gt; ，否则顺序是未知的。</target>
        </trans-unit>
        <trans-unit id="f85dc3be9cb7f009d076c5eedd8386addcb8b584" translate="yes" xml:space="preserve">
          <source>When using Kerberos authentication, SSPI works the same way GSSAPI does; see &lt;a href=&quot;gssapi-auth&quot;&gt;Section 20.6&lt;/a&gt; for details.</source>
          <target state="translated">使用Kerberos身份验证时，SSPI的工作方式与GSSAPI相同。有关详细信息，请参见&lt;a href=&quot;gssapi-auth&quot;&gt;第20.6节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dc80b0e9ed4294e8911057b0a0a50261a196de62" translate="yes" xml:space="preserve">
          <source>When using POSIX semaphores, the number of semaphores needed is the same as for System V, that is one semaphore per allowed connection (&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;), allowed autovacuum worker process (&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MAX-WORKERS&quot;&gt;autovacuum_max_workers&lt;/a&gt;) and allowed background process (&lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt;). On the platforms where this option is preferred, there is no specific kernel limit on the number of POSIX semaphores.</source>
          <target state="translated">使用POSIX信号量时，所需的信号量与System V相同，即每个允许的连接（&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;），允许的autovacuum worker进程（&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MAX-WORKERS&quot;&gt;autovacuum_max_workers&lt;/a&gt;）和允许的后台进程（&lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt;）一个信号量。在首选此选项的平台上，对POSIX信号量的数量没有特定的内核限制。</target>
        </trans-unit>
        <trans-unit id="8579cb5fcd4b92d72b4fadb397cff9f7dbbdad05" translate="yes" xml:space="preserve">
          <source>When using RADIUS authentication, an Access Request message will be sent to the configured RADIUS server. This request will be of type &lt;code&gt;Authenticate Only&lt;/code&gt;, and include parameters for &lt;code&gt;user name&lt;/code&gt;, &lt;code&gt;password&lt;/code&gt; (encrypted) and &lt;code&gt;NAS Identifier&lt;/code&gt;. The request will be encrypted using a secret shared with the server. The RADIUS server will respond to this request with either &lt;code&gt;Access Accept&lt;/code&gt; or &lt;code&gt;Access Reject&lt;/code&gt;. There is no support for RADIUS accounting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d87a93d2de1be22dab32dcbbc5446297da3c6d5" translate="yes" xml:space="preserve">
          <source>When using RADIUS authentication, an Access Request message will be sent to the configured RADIUS server. This request will be of type &lt;code&gt;Authenticate Only&lt;/code&gt;, and include parameters for &lt;code&gt;user name&lt;/code&gt;, &lt;code&gt;password&lt;/code&gt; (encrypted) and &lt;code&gt;NAS Identifier&lt;/code&gt;. The request will be encrypted using a secret shared with the server. The RADIUS server will respond to this server with either &lt;code&gt;Access Accept&lt;/code&gt; or &lt;code&gt;Access Reject&lt;/code&gt;. There is no support for RADIUS accounting.</source>
          <target state="translated">使用RADIUS身份验证时，访问请求消息将发送到配置的RADIUS服务器。该请求的类型将为&amp;ldquo; &lt;code&gt;Authenticate Only&lt;/code&gt; ，并包括 &lt;code&gt;user name&lt;/code&gt; ， &lt;code&gt;password&lt;/code&gt; （已加密）和 &lt;code&gt;NAS Identifier&lt;/code&gt; 。该请求将使用与服务器共享的机密进行加密。 RADIUS服务器将使用&amp;ldquo; &lt;code&gt;Access Accept&lt;/code&gt; 或&amp;ldquo; &lt;code&gt;Access Reject&lt;/code&gt; 响应此服务器。不支持RADIUS记帐。</target>
        </trans-unit>
        <trans-unit id="df1ce6f4ba5a71b98d3f24da1f9c50898361216d" translate="yes" xml:space="preserve">
          <source>When using System V semaphores, PostgreSQL uses one semaphore per allowed connection (&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;), allowed autovacuum worker process (&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MAX-WORKERS&quot;&gt;autovacuum_max_workers&lt;/a&gt;) and allowed background process (&lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt;), in sets of 16. Each such set will also contain a 17th semaphore which contains a &amp;ldquo;magic number&amp;rdquo;, to detect collision with semaphore sets used by other applications. The maximum number of semaphores in the system is set by &lt;code&gt;SEMMNS&lt;/code&gt;, which consequently must be at least as high as &lt;code&gt;max_connections&lt;/code&gt; plus &lt;code&gt;autovacuum_max_workers&lt;/code&gt; plus &lt;code&gt;max_wal_senders&lt;/code&gt;, plus &lt;code&gt;max_worker_processes&lt;/code&gt;, plus one extra for each 16 allowed connections plus workers (see the formula in &lt;a href=&quot;kernel-resources#SYSVIPC-PARAMETERS&quot;&gt;Table 18.1&lt;/a&gt;). The parameter &lt;code&gt;SEMMNI&lt;/code&gt; determines the limit on the number of semaphore sets that can exist on the system at one time. Hence this parameter must be at least &lt;code&gt;ceil((max_connections + autovacuum_max_workers + max_wal_senders + max_worker_processes + 5) / 16)&lt;/code&gt;. Lowering the number of allowed connections is a temporary workaround for failures, which are usually confusingly worded &amp;ldquo;No space left on device&amp;rdquo;, from the function &lt;code&gt;semget&lt;/code&gt;.</source>
          <target state="translated">使用System V信号量时，PostgreSQL每16个一组使用一个允许的连接数（&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;），允许的autovacuum worker进程（&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MAX-WORKERS&quot;&gt;autovacuum_max_workers&lt;/a&gt;）和允许的后台进程（&lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt;）一个信号量。每个这样的集合还将包含第17个信号量，其中包含&amp;ldquo;魔术数&amp;rdquo;，以检测与其他应用程序使用的信号量集的冲突。系统中的最大信号量由 &lt;code&gt;SEMMNS&lt;/code&gt; 设置，因此必须至少与 &lt;code&gt;max_connections&lt;/code&gt; 加上 &lt;code&gt;autovacuum_max_workers&lt;/code&gt; 加上 &lt;code&gt;max_wal_senders&lt;/code&gt; 以及 &lt;code&gt;max_worker_processes&lt;/code&gt; 一样高。，每增加16个允许的连接，再加上一个额外的工作线程，则需要额外增加一个（请参阅&lt;a href=&quot;kernel-resources#SYSVIPC-PARAMETERS&quot;&gt;表18.1中&lt;/a&gt;的公式）。参数 &lt;code&gt;SEMMNI&lt;/code&gt; 确定一次可以在系统上存在的信号量集的数量限制。因此，此参数必须至少为 &lt;code&gt;ceil((max_connections + autovacuum_max_workers + max_wal_senders + max_worker_processes + 5) / 16)&lt;/code&gt; 。减少允许的连接数是一种临时性的解决方法，用于解决故障，这些故障通常在 &lt;code&gt;semget&lt;/code&gt; 函数中用 &amp;ldquo;设备上没有空间&amp;rdquo;来混淆。</target>
        </trans-unit>
        <trans-unit id="c8382eef968bcd1841af0a45f03df20722ebed18" translate="yes" xml:space="preserve">
          <source>When using a replication setup with tools which perform direct copies of relation file blocks (for example &lt;a href=&quot;app-pgrewind&quot;&gt;pg_rewind&lt;/a&gt;), enabling or disabling checksums can lead to page corruptions in the shape of incorrect checksums if the operation is not done consistently across all nodes. When enabling or disabling checksums in a replication setup, it is thus recommended to stop all the clusters before switching them all consistently. Destroying all standbys, performing the operation on the primary and finally recreating the standbys from scratch is also safe.</source>
          <target state="translated">当将复制设置与执行关系文件块的直接副本的工具一起使用时（例如&lt;a href=&quot;app-pgrewind&quot;&gt;pg_rewind&lt;/a&gt;），如果未在所有节点上均执行一致的操作，则启用或禁用校验和会导致页面校验错误，从而导致页面损坏。在复制设置中启用或禁用校验和时，因此建议先停止所有群集，然后再将其全部切换。销毁所有备用数据库，在主数据库上执行操作，最后从头开始重新创建备用数据库也是安全的。</target>
        </trans-unit>
        <trans-unit id="eac93956f94fd1f4ae45bb87df2631e194bcbe28" translate="yes" xml:space="preserve">
          <source>When using a separate column to store the &lt;code&gt;tsvector&lt;/code&gt; representation of your documents, it is necessary to create a trigger to update the &lt;code&gt;tsvector&lt;/code&gt; column when the document content columns change. Two built-in trigger functions are available for this, or you can write your own.</source>
          <target state="translated">当使用单独的列存储文档的 &lt;code&gt;tsvector&lt;/code&gt; 表示形式时，有必要创建一个触发器以在文档内容列更改时更新 &lt;code&gt;tsvector&lt;/code&gt; 列。为此有两个内置的触发功能，或者您可以编写自己的触发功能。</target>
        </trans-unit>
        <trans-unit id="9150f1a85447666f80a11e9912230df80685449c" translate="yes" xml:space="preserve">
          <source>When using an &lt;code&gt;archive_command&lt;/code&gt; script, it's desirable to enable &lt;a href=&quot;runtime-config-logging#GUC-LOGGING-COLLECTOR&quot;&gt;logging_collector&lt;/a&gt;. Any messages written to stderr from the script will then appear in the database server log, allowing complex configurations to be diagnosed easily if they fail.</source>
          <target state="translated">使用 &lt;code&gt;archive_command&lt;/code&gt; 脚本时，最好启用&lt;a href=&quot;runtime-config-logging#GUC-LOGGING-COLLECTOR&quot;&gt;logging_collector&lt;/a&gt;。然后，从脚本写入stderr的所有消息都将出现在数据库服务器日志中，从而使复杂的配置在失败时易于诊断。</target>
        </trans-unit>
        <trans-unit id="953b500ebbfdd4983d6d154f36b232db63c79506" translate="yes" xml:space="preserve">
          <source>When using an external authentication system such as Ident or GSSAPI, the name of the operating system user that initiated the connection might not be the same as the database user (role) that is to be used. In this case, a user name map can be applied to map the operating system user name to a database user. To use user name mapping, specify &lt;code&gt;map&lt;/code&gt;=&lt;code&gt;map-name&lt;/code&gt; in the options field in &lt;code&gt;pg_hba.conf&lt;/code&gt;. This option is supported for all authentication methods that receive external user names. Since different mappings might be needed for different connections, the name of the map to be used is specified in the &lt;code&gt;map-name&lt;/code&gt; parameter in &lt;code&gt;pg_hba.conf&lt;/code&gt; to indicate which map to use for each individual connection.</source>
          <target state="translated">当使用外部身份验证系统（例如Ident或GSSAPI）时，发起连接的操作系统用户的名称可能与要使用的数据库用户（角色）不同。在这种情况下，可以应用用户名映射来将操作系统用户名映射到数据库用户。要使用用户名映射，请在 &lt;code&gt;pg_hba.conf&lt;/code&gt; 的options字段中指定 &lt;code&gt;map&lt;/code&gt; = &lt;code&gt;map-name&lt;/code&gt; 。接收外部用户名的所有身份验证方法均支持此选项。由于不同的连接可能需要不同的映射，因此要使用的 &lt;code&gt;map-name&lt;/code&gt; 在 &lt;code&gt;pg_hba.conf&lt;/code&gt; 的map-name参数中指定，以指示每个单独的连接使用哪个映射。</target>
        </trans-unit>
        <trans-unit id="492838d017254285805f7e847c1bb4763dffb265" translate="yes" xml:space="preserve">
          <source>When using binary mode to pass query parameters to the server and query results back to the client, no encoding conversion is performed, so the situation is different. In this case, an encoding declaration in the XML data will be observed, and if it is absent, the data will be assumed to be in UTF-8 (as required by the XML standard; note that PostgreSQL does not support UTF-16). On output, data will have an encoding declaration specifying the client encoding, unless the client encoding is UTF-8, in which case it will be omitted.</source>
          <target state="translated">当使用二进制模式将查询参数传给服务器并将查询结果传回客户端时,不会进行编码转换,所以情况有所不同。在这种情况下,会观察到XML数据中的编码声明,如果没有,则会假设数据是UTF-8(按照XML标准的要求,注意PostgreSQL不支持UTF-16)。在输出时,数据将有一个指定客户端编码的编码声明,除非客户端编码是UTF-8,在这种情况下,它将被省略。</target>
        </trans-unit>
        <trans-unit id="5c43830d30560b418ee227f739bdeb1afbb63531" translate="yes" xml:space="preserve">
          <source>When using collations provided by &lt;code&gt;libc&lt;/code&gt; and PostgreSQL was built with the GNU C library, the C library's version is used as a collation version. Since collation definitions typically change only with GNU C library releases, this provides some defense against corruption, but it is not completely reliable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56607247aff04e4e074b7797ef04095046172c94" translate="yes" xml:space="preserve">
          <source>When using collations provided by the ICU library, the ICU-specific version of the collator is recorded in the system catalog when the collation object is created. When the collation is used, the current version is checked against the recorded version, and a warning is issued when there is a mismatch, for example:</source>
          <target state="translated">当使用ICU库提供的校验时,当创建校验对象时,校验器的ICU专用版本会被记录在系统目录中。在使用整理器时,会根据记录的版本检查当前的版本,当出现不匹配等情况时,会发出警告。</target>
        </trans-unit>
        <trans-unit id="de5896493e8d94d607ede6725d8b75b29f2f0f82" translate="yes" xml:space="preserve">
          <source>When using cost-based vacuuming, appropriate values for &lt;code&gt;vacuum_cost_delay&lt;/code&gt; are usually quite small, perhaps less than 1 millisecond. While &lt;code&gt;vacuum_cost_delay&lt;/code&gt; can be set to fractional-millisecond values, such delays may not be measured accurately on older platforms. On such platforms, increasing &lt;code&gt;VACUUM&lt;/code&gt;'s throttled resource consumption above what you get at 1ms will require changing the other vacuum cost parameters. You should, nonetheless, keep &lt;code&gt;vacuum_cost_delay&lt;/code&gt; as small as your platform will consistently measure; large delays are not helpful.</source>
          <target state="translated">当使用基于成本的吸尘时， &lt;code&gt;vacuum_cost_delay&lt;/code&gt; 的适当值通常很小，可能小于1毫秒。尽管 &lt;code&gt;vacuum_cost_delay&lt;/code&gt; 可以设置为分数毫秒值，但在较旧的平台上可能无法准确测量此类延迟。在这样的平台上，将 &lt;code&gt;VACUUM&lt;/code&gt; 的节流资源消耗增加到1ms以上，这将需要更改其他真空成本参数。但是，您应该将 &lt;code&gt;vacuum_cost_delay&lt;/code&gt; 保持为平台将持续测量的大小；大的延误没有帮助。</target>
        </trans-unit>
        <trans-unit id="75aee5f97d42018467b21311d706aa5a647707a9" translate="yes" xml:space="preserve">
          <source>When using exclusive backup mode, it is absolutely imperative to ensure that &lt;code&gt;pg_stop_backup&lt;/code&gt; completes successfully at the end of the backup. Even if the backup itself fails, for example due to lack of disk space, failure to call &lt;code&gt;pg_stop_backup&lt;/code&gt; will leave the server in backup mode indefinitely, causing future backups to fail and increasing the risk of a restart failure during the time that &lt;code&gt;backup_label&lt;/code&gt; exists.</source>
          <target state="translated">当使用独占备份模式时，绝对必须确保 &lt;code&gt;pg_stop_backup&lt;/code&gt; 在备份结束时成功完成。即使备份本身失败（例如由于磁盘空间不足），调用 &lt;code&gt;pg_stop_backup&lt;/code&gt; 失败也会使服务器无限期处于备份模式，从而导致将来的备份失败，并在存在 &lt;code&gt;backup_label&lt;/code&gt; 的时间内增加重启失败的风险。</target>
        </trans-unit>
        <trans-unit id="ec73be80732f41a040847bc00566e73f63c25a96" translate="yes" xml:space="preserve">
          <source>When using link mode, standby servers can be quickly upgraded using rsync. To accomplish this, from a directory on the primary server that is above the old and new database cluster directories, run this on the &lt;em&gt;primary&lt;/em&gt; for each standby server:</source>
          <target state="translated">使用链接模式时，可以使用rsync快速升级备用服务器。为此，请从主服务器上位于新旧数据库集群目录上方的目录中，在每台备用服务器的&lt;em&gt;主&lt;/em&gt;服务器上运行此目录：</target>
        </trans-unit>
        <trans-unit id="7d1e98ef020032cfb9faf29c2d74acac7b1c192c" translate="yes" xml:space="preserve">
          <source>When using multiple &lt;code&gt;INSERT&lt;/code&gt;s, turn off autocommit and just do one commit at the end. (In plain SQL, this means issuing &lt;code&gt;BEGIN&lt;/code&gt; at the start and &lt;code&gt;COMMIT&lt;/code&gt; at the end. Some client libraries might do this behind your back, in which case you need to make sure the library does it when you want it done.) If you allow each insertion to be committed separately, PostgreSQL is doing a lot of work for each row that is added. An additional benefit of doing all insertions in one transaction is that if the insertion of one row were to fail then the insertion of all rows inserted up to that point would be rolled back, so you won't be stuck with partially loaded data.</source>
          <target state="translated">当使用多个 &lt;code&gt;INSERT&lt;/code&gt; 时，请关闭自动提交，最后只进行一次提交。 （在普通的SQL中，这意味着在开始时发出 &lt;code&gt;BEGIN&lt;/code&gt; ，在结束时发出 &lt;code&gt;COMMIT&lt;/code&gt; 。某些客户端库可能会在后台执行此操作，在这种情况下，您需要确保在需要时执行该库。）如果允许每个插入分别提交，PostgreSQL对添加的每一行都做了很多工作。在一个事务中进行所有插入的另一个好处是，如果一行的插入失败，那么将回滚到该点为止插入的所有行的插入，因此不会卡住部分加载的数据。</target>
        </trans-unit>
        <trans-unit id="8692847b55239c8542d72c31d947ca1f69e8f98c" translate="yes" xml:space="preserve">
          <source>When using pg_receivewal instead of &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt; as the main WAL backup method, it is strongly recommended to use replication slots. Otherwise, the server is free to recycle or remove write-ahead log files before they are backed up, because it does not have any information, either from &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt; or the replication slots, about how far the WAL stream has been archived. Note, however, that a replication slot will fill up the server's disk space if the receiver does not keep up with fetching the WAL data.</source>
          <target state="translated">当使用pg_receivewal而不是&lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt;作为主要的WAL备份方法时，强烈建议使用复制插槽。否则，服务器可以在备份前自由回收或删除预写日志文件，因为它没有来自&lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt;或复制插槽的任何有关WAL流已归档多远的信息。但是请注意，如果接收方跟不上WAL数据的获取，复制槽将填满服务器的磁盘空间。</target>
        </trans-unit>
        <trans-unit id="7805e078bb69ca14f943ca44e9ff4b57cc0c775e" translate="yes" xml:space="preserve">
          <source>When using search+bind mode, the search can be performed using a single attribute specified with &lt;code&gt;ldapsearchattribute&lt;/code&gt;, or using a custom search filter specified with &lt;code&gt;ldapsearchfilter&lt;/code&gt;. Specifying &lt;code&gt;ldapsearchattribute=foo&lt;/code&gt; is equivalent to specifying &lt;code&gt;ldapsearchfilter=&quot;(foo=$username)&quot;&lt;/code&gt;. If neither option is specified the default is &lt;code&gt;ldapsearchattribute=uid&lt;/code&gt;.</source>
          <target state="translated">当使用搜索+绑定模式，可以使用具有指定的一个属性来执行所述搜索 &lt;code&gt;ldapsearchattribute&lt;/code&gt; ，或使用带有指定的自定义搜索过滤器 &lt;code&gt;ldapsearchfilter&lt;/code&gt; 。指定 &lt;code&gt;ldapsearchattribute=foo&lt;/code&gt; 等同于指定 &lt;code&gt;ldapsearchfilter=&quot;(foo=$username)&quot;&lt;/code&gt; 。如果未指定任何选项，则默认值为 &lt;code&gt;ldapsearchattribute=uid&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="135e97cd9c471619bb69517b95ef6da4e4340a4c" translate="yes" xml:space="preserve">
          <source>When using static log file names, the server might fail to reopen the log file if the max open file limit is reached or a file table overflow occurs. In this case, log messages are sent to the old log file until a successful log rotation. If logrotate is configured to compress the log file and delete it, the server may lose the messages logged in this time frame. To avoid this issue, you can configure the logging collector to dynamically assign log file names and use a &lt;code&gt;prerotate&lt;/code&gt; script to ignore open log files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccf2c531c08aa10ba699a8b190067e047b3e70bf" translate="yes" xml:space="preserve">
          <source>When using static log file names, the server might fail to reopen the log file if the max open file limit is reached or a file table overflow occurs. In this case, log messages are sent to the old log file until a successful log rotation. If logrotate is configured to compress the log file and delete it, the server may lose the messages logged in this timeframe. To avoid this issue, you can configure the logging collector to dynamically assign log file names and use a &lt;code&gt;prerotate&lt;/code&gt; script to ignore open log files.</source>
          <target state="translated">使用静态日志文件名时，如果达到最大打开文件数限制或发生文件表溢出，则服务器可能无法重新打开日志文件。在这种情况下，日志消息将发送到旧的日志文件，直到成功进行日志轮换为止。如果将logrotate配置为压缩日志文件并将其删除，则服务器可能会丢失此时间范围内记录的消息。为避免此问题，可以将日志收集器配置为动态分配日志文件名，并使用 &lt;code&gt;prerotate&lt;/code&gt; 脚本忽略打开的日志文件。</target>
        </trans-unit>
        <trans-unit id="ddcdbf5154b4eb280778c5288af6f89414cb4462" translate="yes" xml:space="preserve">
          <source>When using systemd, you can use the following service unit file (e.g., at &lt;code&gt;/etc/systemd/system/postgresql.service&lt;/code&gt;):</source>
          <target state="translated">使用systemd时，可以使用以下服务单元文件（例如，在 &lt;code&gt;/etc/systemd/system/postgresql.service&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="aa4f4b5954d77c90199a922670870bbe00993316" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;https://www.postgresql.org/docs/12/dblink.html&quot;&gt;dblink&lt;/a&gt; module, a foreign server's name can be used as an argument of the &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib-dblink-connect.html&quot;&gt;dblink_connect&lt;/a&gt; function to indicate the connection parameters. It is necessary to have the &lt;code&gt;USAGE&lt;/code&gt; privilege on the foreign server to be able to use it in this way.</source>
          <target state="translated">使用&lt;a href=&quot;https://www.postgresql.org/docs/12/dblink.html&quot;&gt;dblink&lt;/a&gt;模块时，可以将外部服务器的名称用作&lt;a href=&quot;https://www.postgresql.org/docs/12/contrib-dblink-connect.html&quot;&gt;dblink_connect&lt;/a&gt;函数的参数，以指示连接参数。必须在外部服务器上具有 &lt;code&gt;USAGE&lt;/code&gt; 特权才能以这种方式使用它。</target>
        </trans-unit>
        <trans-unit id="2a1340434fcccdcd8d13b6480e2a087b4c7cd975" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;https://www.postgresql.org/docs/13/dblink.html&quot;&gt;dblink&lt;/a&gt; module, a foreign server's name can be used as an argument of the &lt;a href=&quot;https://www.postgresql.org/docs/13/contrib-dblink-connect.html&quot;&gt;dblink_connect&lt;/a&gt; function to indicate the connection parameters. It is necessary to have the &lt;code&gt;USAGE&lt;/code&gt; privilege on the foreign server to be able to use it in this way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd246a1d45857b9944b119a71ad8342fdd069e69" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; syntax, if one of the functions requires a column definition list, it's preferred to put the column definition list after the function call inside &lt;code&gt;ROWS FROM( ... )&lt;/code&gt;. A column definition list can be placed after the &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; construct only if there's just a single function and no &lt;code&gt;WITH ORDINALITY&lt;/code&gt; clause.</source>
          <target state="translated">使用 &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; 语法时，如果其中一个函数需要列定义列表，则最好将列定义列表放在 &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; 内部的函数调用之后。仅当只有一个函数且没有 &lt;code&gt;WITH ORDINALITY&lt;/code&gt; 子句时，才能将列定义列表放置在 &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; 构造之后。</target>
        </trans-unit>
        <trans-unit id="98b68f1005505d22ba3f1b802a0a0796977dd397" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;extensions&lt;/code&gt; option, &lt;em&gt;it is the user's responsibility&lt;/em&gt; that the listed extensions exist and behave identically on both the local and remote servers. Otherwise, remote queries may fail or behave unexpectedly.</source>
          <target state="translated">使用 &lt;code&gt;extensions&lt;/code&gt; 选项时，列出的扩展存在并且在本地和远程服务器上具有相同的行为&lt;em&gt;是用户的责任&lt;/em&gt;。否则，远程查询可能会失败或表现异常。</target>
        </trans-unit>
        <trans-unit id="e797775100fdafb459cefc34e37395f8e226c9b6" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;libc&lt;/code&gt; collation provider, the locale must be applicable to the current database encoding. See &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt; for the precise rules.</source>
          <target state="translated">使用 &lt;code&gt;libc&lt;/code&gt; 归类提供程序时，语言环境必须适用于当前数据库编码。有关确切规则，请参见&lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="33347a458dabb91eee87e22ef8743db48a2953ba" translate="yes" xml:space="preserve">
          <source>When using the statistics to monitor collected data, it is important to realize that the information does not update instantaneously. Each individual server process transmits new statistical counts to the collector just before going idle; so a query or transaction still in progress does not affect the displayed totals. Also, the collector itself emits a new report at most once per &lt;code&gt;PGSTAT_STAT_INTERVAL&lt;/code&gt; milliseconds (500 ms unless altered while building the server). So the displayed information lags behind actual activity. However, current-query information collected by &lt;code&gt;track_activities&lt;/code&gt; is always up-to-date.</source>
          <target state="translated">使用统计信息监视收集的数据时，重要的是要意识到信息不会立即更新。每个单独的服务器进程都在即将闲置之前将新的统计计数传输到收集器。因此仍在进行的查询或事务不会影响显示的总数。同样，收集器本身最多每 &lt;code&gt;PGSTAT_STAT_INTERVAL&lt;/code&gt; 毫秒（500毫秒，除非在构建服务器时进行了更改）发出一次新报告。因此，显示的信息落后于实际活动。但是， &lt;code&gt;track_activities&lt;/code&gt; 收集的当前查询信息始终是最新的。</target>
        </trans-unit>
        <trans-unit id="869040936f3cd63714aedfeb674cbbcb51ecde9f" translate="yes" xml:space="preserve">
          <source>When using this option together with &lt;a href=&quot;runtime-config-logging#GUC-LOG-STATEMENT&quot;&gt;log_statement&lt;/a&gt;, the text of statements that are logged because of &lt;code&gt;log_statement&lt;/code&gt; will not be repeated in the duration log message. If you are not using syslog, it is recommended that you log the PID or session ID using &lt;a href=&quot;runtime-config-logging#GUC-LOG-LINE-PREFIX&quot;&gt;log_line_prefix&lt;/a&gt; so that you can link the statement message to the later duration message using the process ID or session ID.</source>
          <target state="translated">当将此选项与&lt;a href=&quot;runtime-config-logging#GUC-LOG-STATEMENT&quot;&gt;log_statement&lt;/a&gt;一起使用时，由于 &lt;code&gt;log_statement&lt;/code&gt; 而记录的语句文本将不会在持续时间日志消息中重复。如果不使用syslog，建议您使用&lt;a href=&quot;runtime-config-logging#GUC-LOG-LINE-PREFIX&quot;&gt;log_line_prefix&lt;/a&gt;记录PID或会话ID，以便可以使用进程ID或会话ID将声明消息链接到以后的持续时间消息。</target>
        </trans-unit>
        <trans-unit id="f56584dae166e0f5d41c03bae8959fb67da882b7" translate="yes" xml:space="preserve">
          <source>When using this technique, it will avoid creating an unnecessary burden for application programmers if the application software goes through a framework which automatically retries transactions which are rolled back with a serialization failure. It may be a good idea to set &lt;code&gt;default_transaction_isolation&lt;/code&gt; to &lt;code&gt;serializable&lt;/code&gt;. It would also be wise to take some action to ensure that no other transaction isolation level is used, either inadvertently or to subvert integrity checks, through checks of the transaction isolation level in triggers.</source>
          <target state="translated">使用此技术时，如果应用程序软件通过自动重试因序列化失败而回滚的事务的框架，它将避免给应用程序程序员造成不必要的负担。将 &lt;code&gt;default_transaction_isolation&lt;/code&gt; 设置为 &lt;code&gt;serializable&lt;/code&gt; 可能是一个好主意。明智的是，通过对触发器中的事务隔离级别进行检查，以确保不使用其他任何事务隔离级别，或者无意或破坏完整性检查，这也是明智的。</target>
        </trans-unit>
        <trans-unit id="a2c852145ce2448ef43e1a7c8c990a843033f4d6" translate="yes" xml:space="preserve">
          <source>When verifying checksums, every file in the cluster is scanned. When enabling checksums, every file in the cluster is rewritten in-place. Disabling checksums only updates the file &lt;code&gt;pg_control&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e33ed6ffb66e09afb90b2aa31b40f235c917227" translate="yes" xml:space="preserve">
          <source>When verifying checksums, every file in the cluster is scanned. When enabling checksums, every file in the cluster is rewritten. Disabling checksums only updates the file &lt;code&gt;pg_control&lt;/code&gt;.</source>
          <target state="translated">验证校验和时，将扫描群集中的每个文件。启用校验和时，将重写集群中的每个文件。禁用校验和只会更新文件 &lt;code&gt;pg_control&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fda53778d06f68bfde32b3023f6347b2be67790d" translate="yes" xml:space="preserve">
          <source>When waiting, &lt;code&gt;pg_ctl&lt;/code&gt; repeatedly checks the server's PID file, sleeping for a short amount of time between checks. Startup is considered complete when the PID file indicates that the server is ready to accept connections. Shutdown is considered complete when the server removes the PID file. &lt;code&gt;pg_ctl&lt;/code&gt; returns an exit code based on the success of the startup or shutdown.</source>
          <target state="translated">等待时， &lt;code&gt;pg_ctl&lt;/code&gt; 反复检查服务器的PID文件，在两次检查之间睡眠一小段时间。当PID文件指示服务器已准备好接受连接时，启动被视为完成。当服务器删除PID文件时，关闭被视为完成。 &lt;code&gt;pg_ctl&lt;/code&gt; 根据启动或关闭的成功返回退出代码。</target>
        </trans-unit>
        <trans-unit id="319a6ac32ba7d37c93ad8b3aed41a7b25d9cd283" translate="yes" xml:space="preserve">
          <source>When we speak of inheriting the locale from the execution environment, this means the following on most operating systems: For a given locale category, say the collation, the following environment variables are consulted in this order until one is found to be set: &lt;code&gt;LC_ALL&lt;/code&gt;, &lt;code&gt;LC_COLLATE&lt;/code&gt; (or the variable corresponding to the respective category), &lt;code&gt;LANG&lt;/code&gt;. If none of these environment variables are set then the locale defaults to &lt;code&gt;C&lt;/code&gt;.</source>
          <target state="translated">当我们谈到从执行环境继承语言环境时，这在大多数操作系统上意味着：对于给定的语言环境类别（例如归类），将按以下顺序查询以下环境变量，直到找到一个设置： &lt;code&gt;LC_ALL&lt;/code&gt; 。 &lt;code&gt;LC_COLLATE&lt;/code&gt; （或对应于相应类别的变量） &lt;code&gt;LANG&lt;/code&gt; 。如果没有这些环境变量的设置，则该区域设置默认为 &lt;code&gt;C&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09870d0ba2815a6a474afa8adde88701322779a5" translate="yes" xml:space="preserve">
          <source>When we write</source>
          <target state="translated">当我们写</target>
        </trans-unit>
        <trans-unit id="5f55fad869d686971a61de9989dadab77ae5eb95" translate="yes" xml:space="preserve">
          <source>When working with an inner tuple having unlabeled nodes, it is an error for &lt;code&gt;choose&lt;/code&gt; to return &lt;code&gt;spgAddNode&lt;/code&gt;, since the set of nodes is supposed to be fixed in such cases.</source>
          <target state="translated">当使用具有未标记节点的内部元组时， &lt;code&gt;choose&lt;/code&gt; 返回 &lt;code&gt;spgAddNode&lt;/code&gt; 是错误的，因为在这种情况下应该固定节点集。</target>
        </trans-unit>
        <trans-unit id="513c84ce8934fc59619703510a7a572aaca0c319" translate="yes" xml:space="preserve">
          <source>When working with multiple tables, it can also be useful to ask for all the columns of a particular table:</source>
          <target state="translated">当使用多个表时,要求提供某个表的所有列也很有用。</target>
        </trans-unit>
        <trans-unit id="3f387116d6a98de65f13445ebf4c25f94df15576" translate="yes" xml:space="preserve">
          <source>When working with non-SQL-standard operator names, you will usually need to separate adjacent operators with spaces to avoid ambiguity. For example, if you have defined a left unary operator named &lt;code&gt;@&lt;/code&gt;, you cannot write &lt;code&gt;X*@Y&lt;/code&gt;; you must write &lt;code&gt;X* @Y&lt;/code&gt; to ensure that PostgreSQL reads it as two operator names not one.</source>
          <target state="translated">使用非SQL标准的运算符名称时，通常需要用空格分隔相邻的运算符，以避免产生歧义。例如，如果定义了名为 &lt;code&gt;@&lt;/code&gt; 的左一元运算符，则不能编写 &lt;code&gt;X*@Y&lt;/code&gt; ；您必须编写 &lt;code&gt;X* @Y&lt;/code&gt; 以确保PostgreSQL将其读取为两个运算符名称，而不是一个。</target>
        </trans-unit>
        <trans-unit id="ec3a2849e7e7665d1ef0586b393970fa38e06c50" translate="yes" xml:space="preserve">
          <source>When working with recursive queries it is important to be sure that the recursive part of the query will eventually return no tuples, or else the query will loop indefinitely. Sometimes, using &lt;code&gt;UNION&lt;/code&gt; instead of &lt;code&gt;UNION ALL&lt;/code&gt; can accomplish this by discarding rows that duplicate previous output rows. However, often a cycle does not involve output rows that are completely duplicate: it may be necessary to check just one or a few fields to see if the same point has been reached before. The standard method for handling such situations is to compute an array of the already-visited values. For example, consider the following query that searches a table &lt;code&gt;graph&lt;/code&gt; using a &lt;code&gt;link&lt;/code&gt; field:</source>
          <target state="translated">使用递归查询时，重要的是要确保查询的递归部分最终将不返回任何元组，否则查询将无限期地循环。有时，使用 &lt;code&gt;UNION&lt;/code&gt; 代替 &lt;code&gt;UNION ALL&lt;/code&gt; 可以通过丢弃与以前的输出行重复的行来实现。但是，一个循环通常不包含完全重复的输出行：可能需要仅检查一个或几个字段，以查看之前是否到达同一点。处理此类情况的标准方法是计算一个已访问值的数组。例如，考虑以下使用 &lt;code&gt;link&lt;/code&gt; 字段搜索表 &lt;code&gt;graph&lt;/code&gt; 查询：</target>
        </trans-unit>
        <trans-unit id="e5718cfeb2fe2d91286009aaf2e77c006f835bbe" translate="yes" xml:space="preserve">
          <source>When writing an interval constant with a &lt;code&gt;fields&lt;/code&gt; specification, or when assigning a string to an interval column that was defined with a &lt;code&gt;fields&lt;/code&gt; specification, the interpretation of unmarked quantities depends on the &lt;code&gt;fields&lt;/code&gt;. For example &lt;code&gt;INTERVAL '1' YEAR&lt;/code&gt; is read as 1 year, whereas &lt;code&gt;INTERVAL '1'&lt;/code&gt; means 1 second. Also, field values &amp;ldquo;to the right&amp;rdquo; of the least significant field allowed by the &lt;code&gt;fields&lt;/code&gt; specification are silently discarded. For example, writing &lt;code&gt;INTERVAL '1 day 2:03:04' HOUR TO MINUTE&lt;/code&gt; results in dropping the seconds field, but not the day field.</source>
          <target state="translated">在使用 &lt;code&gt;fields&lt;/code&gt; 规范编写间隔常量时，或将字符串分配给使用 &lt;code&gt;fields&lt;/code&gt; 规范定义的间隔列时，未标记量的解释取决于 &lt;code&gt;fields&lt;/code&gt; 。例如， &lt;code&gt;INTERVAL '1' YEAR&lt;/code&gt; 读为1年，而 &lt;code&gt;INTERVAL '1'&lt;/code&gt; 表示1秒。同样， &lt;code&gt;fields&lt;/code&gt; 规范允许的最低有效字段&amp;ldquo;右侧&amp;rdquo;的字段值会被静默丢弃。例如，写 &lt;code&gt;INTERVAL '1 day 2:03:04' HOUR TO MINUTE&lt;/code&gt; 导致丢弃秒字段，而不是天字段。</target>
        </trans-unit>
        <trans-unit id="988ef8be5d9c8af4c97d0fc59910f990922134e4" translate="yes" xml:space="preserve">
          <source>When you create a table and you realize that you made a mistake, or the requirements of the application change, you can drop the table and create it again. But this is not a convenient option if the table is already filled with data, or if the table is referenced by other database objects (for instance a foreign key constraint). Therefore PostgreSQL provides a family of commands to make modifications to existing tables. Note that this is conceptually distinct from altering the data contained in the table: here we are interested in altering the definition, or structure, of the table.</source>
          <target state="translated">当你创建一个表后,发现自己犯了一个错误,或者应用程序的要求发生了变化,你可以放弃这个表,重新创建。但如果表已经被数据填满,或者表被其他数据库对象引用(例如外键约束),这就不是一个方便的选择。因此PostgreSQL提供了一系列命令来对现有表进行修改。请注意,这与改变表中包含的数据在概念上是不同的:这里我们感兴趣的是改变表的定义或结构。</target>
        </trans-unit>
        <trans-unit id="63a09c13346cb20d8d1dd7186def1b2a2f01cbc1" translate="yes" xml:space="preserve">
          <source>When you create complex database structures involving many tables with foreign key constraints, views, triggers, functions, etc. you implicitly create a net of dependencies between the objects. For instance, a table with a foreign key constraint depends on the table it references.</source>
          <target state="translated">当你创建复杂的数据库结构时,涉及到许多带有外键约束、视图、触发器、函数等的表,你隐含地在对象之间建立了一个依赖关系网。例如,一个带有外键约束的表依赖于它所引用的表。</target>
        </trans-unit>
        <trans-unit id="b9a5344aa581794cb8d710e210bdb65e511f2134" translate="yes" xml:space="preserve">
          <source>When you create many interrelated tables it is wise to choose a consistent naming pattern for the tables and columns. For instance, there is a choice of using singular or plural nouns for table names, both of which are favored by some theorist or other.</source>
          <target state="translated">当你创建许多相互关联的表时,明智的做法是为表和列选择一致的命名模式。例如,可以选择使用单数名词或复数名词作为表名,这两种名词都受到一些理论家或其他理论家的青睐。</target>
        </trans-unit>
        <trans-unit id="593e96c33f6f0aab676c4ca184c4ca854f13bc97" translate="yes" xml:space="preserve">
          <source>When you insert invalid numbers in a table using the weak mode, the number will be inserted with the corrected check digit, but it will be displayed with an exclamation mark (&lt;code&gt;!&lt;/code&gt;) at the end, for example &lt;code&gt;0-11-000322-5!&lt;/code&gt;. This invalid marker can be checked with the &lt;code&gt;is_valid&lt;/code&gt; function and cleared with the &lt;code&gt;make_valid&lt;/code&gt; function.</source>
          <target state="translated">当您使用弱模式在表中插入无效数字时，该数字将与更正的校验位一起插入，但是最后将显示带有感叹号（ &lt;code&gt;!&lt;/code&gt; ），例如 &lt;code&gt;0-11-000322-5!&lt;/code&gt; 。此标记无效可以通过检查 &lt;code&gt;is_valid&lt;/code&gt; 功能，并与清除 &lt;code&gt;make_valid&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="1bf59c49779a368d436367de404fed33cad74dcd" translate="yes" xml:space="preserve">
          <source>When you query JSON data, the path expression may not match the actual JSON data structure. An attempt to access a non-existent member of an object or element of an array results in a structural error. SQL/JSON path expressions have two modes of handling structural errors:</source>
          <target state="translated">当你查询JSON数据时,路径表达式可能不符合实际的JSON数据结构。试图访问一个不存在的对象成员或数组元素会导致结构错误。SQL/JSON路径表达式有两种处理结构错误的模式。</target>
        </trans-unit>
        <trans-unit id="d3780caf73c39bd4ac2d31b375fc0dd6e1923bd0" translate="yes" xml:space="preserve">
          <source>When you write the argument of a sequence function as an unadorned literal string, it becomes a constant of type &lt;code&gt;regclass&lt;/code&gt;. Since this is really just an OID, it will track the originally identified sequence despite later renaming, schema reassignment, etc. This &amp;ldquo;early binding&amp;rdquo; behavior is usually desirable for sequence references in column defaults and views. But sometimes you might want &amp;ldquo;late binding&amp;rdquo; where the sequence reference is resolved at run time. To get late-binding behavior, force the constant to be stored as a &lt;code&gt;text&lt;/code&gt; constant instead of &lt;code&gt;regclass&lt;/code&gt;:</source>
          <target state="translated">当您将序列函数的参数编写为未经修饰的文字字符串时，它将成为 &lt;code&gt;regclass&lt;/code&gt; 类型的常量。由于这实际上只是一个OID，因此尽管稍后进行了重命名，模式重新分配等，它仍将跟踪最初标识的序列。对于列默认值和视图中的序列引用，通常需要这种&amp;ldquo;早期绑定&amp;rdquo;行为。但是有时您可能需要&amp;ldquo;后期绑定&amp;rdquo;，以便在运行时解析序列引用。要获得后期绑定行为，请强制将常量存储为 &lt;code&gt;text&lt;/code&gt; 常量而不是 &lt;code&gt;regclass&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0deb417e3efe2ecd61376860b861e35f77f81d08" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;ANALYZE&lt;/code&gt; is running, the &lt;code&gt;pg_stat_progress_analyze&lt;/code&gt; view will contain a row for each backend that is currently running that command. The tables below describe the information that will be reported and provide information about how to interpret it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2507ec70331a5deab93cd40d826b1bdba44ecbc3" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;CLUSTER&lt;/code&gt; or &lt;code&gt;VACUUM FULL&lt;/code&gt; is running, the &lt;code&gt;pg_stat_progress_cluster&lt;/code&gt; view will contain a row for each backend that is currently running either command. The tables below describe the information that will be reported and provide information about how to interpret it.</source>
          <target state="translated">每当运行 &lt;code&gt;CLUSTER&lt;/code&gt; 或 &lt;code&gt;VACUUM FULL&lt;/code&gt; 时， &lt;code&gt;pg_stat_progress_cluster&lt;/code&gt; 视图将为当前正在运行任一命令的每个后端包含一行。下表描述了将要报告的信息，并提供了有关如何解释它的信息。</target>
        </trans-unit>
        <trans-unit id="51b73a7d0ff3b39db66ff19d5f58e0f20613bb45" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;CREATE INDEX&lt;/code&gt; or &lt;code&gt;REINDEX&lt;/code&gt; is running, the &lt;code&gt;pg_stat_progress_create_index&lt;/code&gt; view will contain one row for each backend that is currently creating indexes. The tables below describe the information that will be reported and provide information about how to interpret it.</source>
          <target state="translated">每当运行 &lt;code&gt;CREATE INDEX&lt;/code&gt; 或 &lt;code&gt;REINDEX&lt;/code&gt; 时， &lt;code&gt;pg_stat_progress_create_index&lt;/code&gt; 视图将为当前正在创建索引的每个后端包含一行。下表描述了将要报告的信息，并提供了有关如何解释它的信息。</target>
        </trans-unit>
        <trans-unit id="0da2e4c266065ef5b47dc244d1142646be363723" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;VACUUM&lt;/code&gt; is running, the &lt;code&gt;pg_stat_progress_vacuum&lt;/code&gt; view will contain one row for each backend (including autovacuum worker processes) that is currently vacuuming. The tables below describe the information that will be reported and provide information about how to interpret it. Progress for &lt;code&gt;VACUUM FULL&lt;/code&gt; commands is reported via &lt;code&gt;pg_stat_progress_cluster&lt;/code&gt; because both &lt;code&gt;VACUUM FULL&lt;/code&gt; and &lt;code&gt;CLUSTER&lt;/code&gt; rewrite the table, while regular &lt;code&gt;VACUUM&lt;/code&gt; only modifies it in place. See &lt;a href=&quot;progress-reporting#CLUSTER-PROGRESS-REPORTING&quot;&gt;Section 27.4.3&lt;/a&gt;.</source>
          <target state="translated">每当 &lt;code&gt;VACUUM&lt;/code&gt; 运行时， &lt;code&gt;pg_stat_progress_vacuum&lt;/code&gt; 视图将为当前正在清理的每个后端（包括自动清理工作进程）包含一行。下表描述了将要报告的信息，并提供了有关如何解释它的信息。 &lt;code&gt;VACUUM FULL&lt;/code&gt; 命令的进度是通过 &lt;code&gt;pg_stat_progress_cluster&lt;/code&gt; 报告的，因为 &lt;code&gt;VACUUM FULL&lt;/code&gt; 和 &lt;code&gt;CLUSTER&lt;/code&gt; 都重写了表，而常规 &lt;code&gt;VACUUM&lt;/code&gt; 仅在适当的地方对其进行了修改。参见&lt;a href=&quot;progress-reporting#CLUSTER-PROGRESS-REPORTING&quot;&gt;第27.4.3节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3fb8592a09f7a3ed7d4104db7d0d68ac3ee490fb" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;VACUUM&lt;/code&gt; is running, the &lt;code&gt;pg_stat_progress_vacuum&lt;/code&gt; view will contain one row for each backend (including autovacuum worker processes) that is currently vacuuming. The tables below describe the information that will be reported and provide information about how to interpret it. Progress for &lt;code&gt;VACUUM FULL&lt;/code&gt; commands is reported via &lt;code&gt;pg_stat_progress_cluster&lt;/code&gt; because both &lt;code&gt;VACUUM FULL&lt;/code&gt; and &lt;code&gt;CLUSTER&lt;/code&gt; rewrite the table, while regular &lt;code&gt;VACUUM&lt;/code&gt; only modifies it in place. See &lt;a href=&quot;progress-reporting#CLUSTER-PROGRESS-REPORTING&quot;&gt;Section 27.4.4&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48d664025546cdeafdfe0701b9fa38130d919c75" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;VACUUM&lt;/code&gt; scans any part of a table, it will replace any multixact ID it encounters which is older than &lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-MIN-AGE&quot;&gt;vacuum_multixact_freeze_min_age&lt;/a&gt; by a different value, which can be the zero value, a single transaction ID, or a newer multixact ID. For each table, &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relminmxid&lt;/code&gt; stores the oldest possible multixact ID still appearing in any tuple of that table. If this value is older than &lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-TABLE-AGE&quot;&gt;vacuum_multixact_freeze_table_age&lt;/a&gt;, an aggressive vacuum is forced. As discussed in the previous section, an aggressive vacuum means that only those pages which are known to be all-frozen will be skipped. &lt;code&gt;mxid_age()&lt;/code&gt; can be used on &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relminmxid&lt;/code&gt; to find its age.</source>
          <target state="translated">每当 &lt;code&gt;VACUUM&lt;/code&gt; 扫描表的任何部分时，它将用一个不同的值替换它遇到的比&lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-MIN-AGE&quot;&gt;vacuum_multixact_freeze_min_age&lt;/a&gt;早的multixact ID，该值可以是零值，单个事务ID或更新的multixact ID。对于每个表， &lt;code&gt;pg_class&lt;/code&gt; 。 &lt;code&gt;relminmxid&lt;/code&gt; 存储仍然出现在该表的任何元组中的最旧的多重ID。如果此值早于&lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-TABLE-AGE&quot;&gt;vacuum_multixact_freeze_table_age&lt;/a&gt;，则将强制使用主动真空。如上一节所述，主动清除意味着仅跳过那些已知为全冻结的页面。 &lt;code&gt;mxid_age()&lt;/code&gt; 可以在 &lt;code&gt;pg_class&lt;/code&gt; 上使用。 &lt;code&gt;relminmxid&lt;/code&gt; 找到它的年龄。</target>
        </trans-unit>
        <trans-unit id="5f844cc225201cbe85cbdde3d905d07e347e61a8" translate="yes" xml:space="preserve">
          <source>Whenever PostgreSQL needs to combine rows from multiple sources into a single result set, it uses an &lt;code&gt;Append&lt;/code&gt; or &lt;code&gt;MergeAppend&lt;/code&gt; plan node. This commonly happens when implementing &lt;code&gt;UNION ALL&lt;/code&gt; or when scanning a partitioned table. Such nodes can be used in parallel plans just as they can in any other plan. However, in a parallel plan, the planner may instead use a &lt;code&gt;Parallel Append&lt;/code&gt; node.</source>
          <target state="translated">每当PostgreSQL需要将来自多个源的行合并到一个结果集中时，它都会使用一个 &lt;code&gt;Append&lt;/code&gt; 或 &lt;code&gt;MergeAppend&lt;/code&gt; 计划节点。在实现 &lt;code&gt;UNION ALL&lt;/code&gt; 或扫描分区表时，通常会发生这种情况。这样的节点可以在并行计划中使用，就像在其他任何计划中一样。但是，在并行计划中，计划者可以改用 &lt;code&gt;Parallel Append&lt;/code&gt; 节点。</target>
        </trans-unit>
        <trans-unit id="85e82d59ea38cfaea7777dbbbcc2b327247984a8" translate="yes" xml:space="preserve">
          <source>Whenever a command is executed, psql also polls for asynchronous notification events generated by &lt;a href=&quot;sql-listen&quot;&gt;LISTEN&lt;/a&gt; and &lt;a href=&quot;sql-notify&quot;&gt;NOTIFY&lt;/a&gt;.</source>
          <target state="translated">每当执行命令时，psql还将轮询&lt;a href=&quot;sql-listen&quot;&gt;LISTEN&lt;/a&gt;和&lt;a href=&quot;sql-notify&quot;&gt;NOTIFY&lt;/a&gt;生成的异步通知事件。</target>
        </trans-unit>
        <trans-unit id="fe283c15f98e1d6878cfeeadd5bbfd6c5078c552" translate="yes" xml:space="preserve">
          <source>Whenever a user-defined type is created, PostgreSQL automatically creates an associated array type, whose name consists of the element type's name prepended with an underscore, and truncated if necessary to keep it less than &lt;code&gt;NAMEDATALEN&lt;/code&gt; bytes long. (If the name so generated collides with an existing type name, the process is repeated until a non-colliding name is found.) This implicitly-created array type is variable length and uses the built-in input and output functions &lt;code&gt;array_in&lt;/code&gt; and &lt;code&gt;array_out&lt;/code&gt;. The array type tracks any changes in its element type's owner or schema, and is dropped if the element type is.</source>
          <target state="translated">每当创建用户定义的类型时，PostgreSQL都会自动创建一个关联的数组类型，其名称由元素类型的名称组成，该名称前面带有下划线，并在必要时将其截断以使其长度小于 &lt;code&gt;NAMEDATALEN&lt;/code&gt; 字节。 （如果该名称，以便与现有的类型名称产生碰撞，则重复直到一个非冲突名称被发现的处理）。这隐含创建的数组类型是可变长度，并使用内置的输入和输出功能 &lt;code&gt;array_in&lt;/code&gt; 和 &lt;code&gt;array_out&lt;/code&gt; 。数组类型跟踪其元素类型的所有者或架构中的所有更改，如果元素类型为，则将其删除。</target>
        </trans-unit>
        <trans-unit id="7c3ae7e94c74ecafe04f858b486a7a8022aa32dd" translate="yes" xml:space="preserve">
          <source>Whenever an application like pg_basebackup is taking a base backup, the &lt;code&gt;pg_stat_progress_basebackup&lt;/code&gt; view will contain a row for each WAL sender process that is currently running the &lt;code&gt;BASE_BACKUP&lt;/code&gt; replication command and streaming the backup. The tables below describe the information that will be reported and provide information about how to interpret it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c317e2f18ac74c5065186374d831c55658598512" translate="yes" xml:space="preserve">
          <source>Whenever more than this amount of data has been written by a single backend, attempt to force the OS to issue these writes to the underlying storage. Doing so will limit the amount of dirty data in the kernel's page cache, reducing the likelihood of stalls when an &lt;code&gt;fsync&lt;/code&gt; is issued at the end of a checkpoint, or when the OS writes data back in larger batches in the background. Often that will result in greatly reduced transaction latency, but there also are some cases, especially with workloads that are bigger than &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;, but smaller than the OS's page cache, where performance might degrade. This setting may have no effect on some platforms. If this value is specified without units, it is taken as blocks, that is &lt;code&gt;BLCKSZ&lt;/code&gt; bytes, typically 8kB. The valid range is between &lt;code&gt;0&lt;/code&gt;, which disables forced writeback, and &lt;code&gt;2MB&lt;/code&gt;. The default is &lt;code&gt;0&lt;/code&gt;, i.e., no forced writeback. (If &lt;code&gt;BLCKSZ&lt;/code&gt; is not 8kB, the maximum value scales proportionally to it.)</source>
          <target state="translated">每当单个后端写入的数据量超过此数量时，请尝试强制操作系统将这些写入操作发布到基础存储。这样做将限制内核页面缓存中的脏数据量，从而减少在检查点末尾发出 &lt;code&gt;fsync&lt;/code&gt; 或操作系统在后台大批量写回数据时出现停顿的可能性。通常，这将大大减少事务等待时间，但是在某些情况下，尤其是在工作负载大于&lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;但小于OS页面缓存的情况下，性能可能会下降。此设置在某些平台上可能无效。如果此值指定为无单位，则将其视为块，即 &lt;code&gt;BLCKSZ&lt;/code&gt; 字节，通常为8kB。有效范围介于 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;2MB&lt;/code&gt; 之间，该范围介于0和2MB之间，前者禁止强制写回。默认值为 &lt;code&gt;0&lt;/code&gt; ，即不强制回写。 （如果 &lt;code&gt;BLCKSZ&lt;/code&gt; 不是8kB，则最大值与之成比例。）</target>
        </trans-unit>
        <trans-unit id="de89b6016c756123d6b9441e22d55848a32a9ab3" translate="yes" xml:space="preserve">
          <source>Whenever more than this amount of data has been written by the background writer, attempt to force the OS to issue these writes to the underlying storage. Doing so will limit the amount of dirty data in the kernel's page cache, reducing the likelihood of stalls when an &lt;code&gt;fsync&lt;/code&gt; is issued at the end of a checkpoint, or when the OS writes data back in larger batches in the background. Often that will result in greatly reduced transaction latency, but there also are some cases, especially with workloads that are bigger than &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;, but smaller than the OS's page cache, where performance might degrade. This setting may have no effect on some platforms. If this value is specified without units, it is taken as blocks, that is &lt;code&gt;BLCKSZ&lt;/code&gt; bytes, typically 8kB. The valid range is between &lt;code&gt;0&lt;/code&gt;, which disables forced writeback, and &lt;code&gt;2MB&lt;/code&gt;. The default is &lt;code&gt;512kB&lt;/code&gt; on Linux, &lt;code&gt;0&lt;/code&gt; elsewhere. (If &lt;code&gt;BLCKSZ&lt;/code&gt; is not 8kB, the default and maximum values scale proportionally to it.) This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">每当后台写入器写入的数据量超过此数量时，请尝试强制操作系统将这些写入操作发布到基础存储。这样做将限制内核页面缓存中的脏数据量，从而减少在检查点末尾发出 &lt;code&gt;fsync&lt;/code&gt; 或操作系统在后台大批量写回数据时出现停顿的可能性。通常，这将大大减少事务等待时间，但是在某些情况下，尤其是在工作负载大于&lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;但小于OS页面缓存的情况下，性能可能会下降。此设置在某些平台上可能无效。如果此值指定为无单位，则将其视为块，即 &lt;code&gt;BLCKSZ&lt;/code&gt; 字节，通常为8kB。有效范围介于 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;2MB&lt;/code&gt; 之间，该范围介于0和2MB之间，前者禁止强制写回。在Linux上默认为 &lt;code&gt;512kB&lt;/code&gt; ,在其他位置为 &lt;code&gt;0&lt;/code&gt; 。 （如果 &lt;code&gt;BLCKSZ&lt;/code&gt; 不是8kB，则默认值和最大值将按比例缩放。）只能在 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件或服务器命令行中设置此参数。</target>
        </trans-unit>
        <trans-unit id="41035af23763d236bc43d7713084261d3a812120" translate="yes" xml:space="preserve">
          <source>Whenever more than this amount of data has been written while performing a checkpoint, attempt to force the OS to issue these writes to the underlying storage. Doing so will limit the amount of dirty data in the kernel's page cache, reducing the likelihood of stalls when an &lt;code&gt;fsync&lt;/code&gt; is issued at the end of the checkpoint, or when the OS writes data back in larger batches in the background. Often that will result in greatly reduced transaction latency, but there also are some cases, especially with workloads that are bigger than &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;, but smaller than the OS's page cache, where performance might degrade. This setting may have no effect on some platforms. If this value is specified without units, it is taken as blocks, that is &lt;code&gt;BLCKSZ&lt;/code&gt; bytes, typically 8kB. The valid range is between &lt;code&gt;0&lt;/code&gt;, which disables forced writeback, and &lt;code&gt;2MB&lt;/code&gt;. The default is &lt;code&gt;256kB&lt;/code&gt; on Linux, &lt;code&gt;0&lt;/code&gt; elsewhere. (If &lt;code&gt;BLCKSZ&lt;/code&gt; is not 8kB, the default and maximum values scale proportionally to it.) This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">在执行检查点时，只要写入的数据量超过此数量，请尝试强制操作系统将这些写入操作发布到基础存储。这样做将限制内核页面缓存中的脏数据量，从而减少在检查点末尾发出 &lt;code&gt;fsync&lt;/code&gt; 或操作系统在后台将数据批量写回时停顿的可能性。通常，这将大大减少事务等待时间，但是在某些情况下，尤其是在工作负载大于&lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;但小于OS页面缓存的情况下，性能可能会下降。此设置在某些平台上可能无效。如果此值指定为无单位，则将其视为块，即 &lt;code&gt;BLCKSZ&lt;/code&gt; 字节，通常为8kB。有效范围介于 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;2MB&lt;/code&gt; 之间，该范围介于0和2MB之间，前者禁止强制写回。在Linux上，默认值为 &lt;code&gt;256kB&lt;/code&gt; ,在其他位置为 &lt;code&gt;0&lt;/code&gt; 。 （如果 &lt;code&gt;BLCKSZ&lt;/code&gt; 不是8kB，则默认值和最大值将按比例缩放。）只能在 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件或服务器命令行中设置此参数。</target>
        </trans-unit>
        <trans-unit id="103203b2b9af3babb0455dacf44200f8d0e1dba1" translate="yes" xml:space="preserve">
          <source>Whenever pg_basebackup is taking a base backup, the server's &lt;code&gt;pg_stat_progress_basebackup&lt;/code&gt; view will report the progress of the backup. See &lt;a href=&quot;progress-reporting#BASEBACKUP-PROGRESS-REPORTING&quot;&gt;Section 27.4.5&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cafdfe0e40c272ef5695922c2a975f51df9e1cea" translate="yes" xml:space="preserve">
          <source>Whenever the &lt;code&gt;pattern&lt;/code&gt; parameter is omitted completely, the &lt;code&gt;\d&lt;/code&gt; commands display all objects that are visible in the current schema search path &amp;mdash; this is equivalent to using &lt;code&gt;*&lt;/code&gt; as the pattern. (An object is said to be &lt;em&gt;visible&lt;/em&gt; if its containing schema is in the search path and no object of the same kind and name appears earlier in the search path. This is equivalent to the statement that the object can be referenced by name without explicit schema qualification.) To see all objects in the database regardless of visibility, use &lt;code&gt;*.*&lt;/code&gt; as the pattern.</source>
          <target state="translated">只要完全省略 &lt;code&gt;pattern&lt;/code&gt; 参数， &lt;code&gt;\d&lt;/code&gt; 命令就会显示在当前模式搜索路径中可见的所有对象-等效于使用 &lt;code&gt;*&lt;/code&gt; 作为模式。 （如果对象的包含架构位于搜索路径中，并且在搜索路径中较早出现的对象没有相同种类和名称，则该对象被认为是&lt;em&gt;可见的&lt;/em&gt;。这等效于以下声明：可以通过名称引用该对象而无需显式架构要查看数据库中所有对象，无论可见性如何，请使用 &lt;code&gt;*.*&lt;/code&gt; 作为模式。</target>
        </trans-unit>
        <trans-unit id="2dffd7d6d50f37b1f139649fc2afe46f33411c06" translate="yes" xml:space="preserve">
          <source>Whenever the command &lt;code&gt;NOTIFY channel&lt;/code&gt; is invoked, either by this session or another one connected to the same database, all the sessions currently listening on that notification channel are notified, and each will in turn notify its connected client application.</source>
          <target state="translated">每当此会话或连接到同一数据库的另一个会话调用命令 &lt;code&gt;NOTIFY channel&lt;/code&gt; ，都会通知当前正在该通知通道上监听的所有会话，并且每个会话将依次通知其连接的客户端应用程序。</target>
        </trans-unit>
        <trans-unit id="464c9a84b9274c416e8217076cf62d6ce77919b2" translate="yes" xml:space="preserve">
          <source>Whenever the role subsequently starts a new session, the specified value becomes the session default, overriding whatever setting is present in &lt;code&gt;postgresql.conf&lt;/code&gt; or has been received from the &lt;code&gt;postgres&lt;/code&gt; command line. This only happens at login time; executing &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt; or &lt;a href=&quot;sql-set-session-authorization&quot;&gt;SET SESSION AUTHORIZATION&lt;/a&gt; does not cause new configuration values to be set. Settings set for all databases are overridden by database-specific settings attached to a role. Settings for specific databases or specific roles override settings for all roles.</source>
          <target state="translated">每当角色随后开始新的会话时，指定的值将成为会话的默认值，从而覆盖 &lt;code&gt;postgresql.conf&lt;/code&gt; 中存在的或从 &lt;code&gt;postgres&lt;/code&gt; 命令行接收到的任何设置。这仅在登录时发生；执行&lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt;或&lt;a href=&quot;sql-set-session-authorization&quot;&gt;SET SESSION AUTHORIZATION&lt;/a&gt;不会导致设置新的配置值。为所有数据库设置的设置将被附加到角色的特定于数据库的设置覆盖。特定数据库或特定角色的设置将覆盖所有角色的设置。</target>
        </trans-unit>
        <trans-unit id="1cb07a399aec26555c15e193c16effe1e79f48af" translate="yes" xml:space="preserve">
          <source>Whenever you create a table, a composite type is also automatically created, with the same name as the table, to represent the table's row type. For example, had we said:</source>
          <target state="translated">每当创建一个表时,也会自动创建一个与表同名的复合类型,来代表表的行类型。例如,如果我们说。</target>
        </trans-unit>
        <trans-unit id="72417af150626f41547b564cc2af3102889d282f" translate="yes" xml:space="preserve">
          <source>Whenever you have significantly altered the distribution of data within a table, running &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; is strongly recommended. This includes bulk loading large amounts of data into the table. Running &lt;code&gt;ANALYZE&lt;/code&gt; (or &lt;code&gt;VACUUM ANALYZE&lt;/code&gt;) ensures that the planner has up-to-date statistics about the table. With no statistics or obsolete statistics, the planner might make poor decisions during query planning, leading to poor performance on any tables with inaccurate or nonexistent statistics. Note that if the autovacuum daemon is enabled, it might run &lt;code&gt;ANALYZE&lt;/code&gt; automatically; see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Section 24.1.3&lt;/a&gt; and &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information.</source>
          <target state="translated">只要您显着更改了表中数据的分布，就强烈建议运行&lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt;。这包括将大量数据批量加载到表中。运行 &lt;code&gt;ANALYZE&lt;/code&gt; （或 &lt;code&gt;VACUUM ANALYZE&lt;/code&gt; ）可确保计划者拥有有关表的最新统计信息。没有统计信息或统计信息过时，规划器可能会在查询计划期间做出错误的决策，从而导致统计信息不正确或不存在的任何表的性能都较差。请注意，如果启用了autovacuum守护程序，则它可能会自动运行 &lt;code&gt;ANALYZE&lt;/code&gt; ；有关更多信息，请参见&lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;第24.1.3节&lt;/a&gt;和&lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;第24.1.6节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="70267c330cb08a0ff5a2a298e316262a59a144c4" translate="yes" xml:space="preserve">
          <source>Where interoperability with other systems is a concern, for some data types, it may be necessary to use data type formatting functions (such as those in &lt;a href=&quot;functions-formatting&quot;&gt;Section 9.8&lt;/a&gt;) explicitly to produce the standard mappings.</source>
          <target state="translated">如果需要考虑与其他系统的互操作性，则对于某些数据类型，可能有必要显式使用数据类型格式化功能（例如&lt;a href=&quot;functions-formatting&quot;&gt;9.8节中的&lt;/a&gt;功能）来生成标准映射。</target>
        </trans-unit>
        <trans-unit id="de87765a2f74958f3598da9f1ae5cd4df124304a" translate="yes" xml:space="preserve">
          <source>Where the command omits database name, user, host, or port, the new connection can reuse values from the previous connection. By default, values from the previous connection are reused except when processing a &lt;code&gt;conninfo&lt;/code&gt; string. Passing a first argument of &lt;code&gt;-reuse-previous=on&lt;/code&gt; or &lt;code&gt;-reuse-previous=off&lt;/code&gt; overrides that default. When the command neither specifies nor reuses a particular parameter, the libpq default is used. Specifying any of &lt;code&gt;dbname&lt;/code&gt;, &lt;code&gt;username&lt;/code&gt;, &lt;code&gt;host&lt;/code&gt; or &lt;code&gt;port&lt;/code&gt; as &lt;code&gt;-&lt;/code&gt; is equivalent to omitting that parameter. If &lt;code&gt;hostaddr&lt;/code&gt; was specified in the original connection's &lt;code&gt;conninfo&lt;/code&gt;, that address is reused for the new connection (disregarding any other host specification).</source>
          <target state="translated">如果该命令省略了数据库名称，用户，主机或端口，则新连接可以重用先前连接中的值。默认情况下，除了处理 &lt;code&gt;conninfo&lt;/code&gt; 字符串时，都将重用先前连接的值。传递 &lt;code&gt;-reuse-previous=on&lt;/code&gt; 或 &lt;code&gt;-reuse-previous=off&lt;/code&gt; 的第一个参数将覆盖该默认值。当命令既未指定也不重用特定参数时，将使用libpq缺省值。将 &lt;code&gt;dbname&lt;/code&gt; ， &lt;code&gt;username&lt;/code&gt; ， &lt;code&gt;host&lt;/code&gt; 或 &lt;code&gt;port&lt;/code&gt; 中的任何一个指定为 &lt;code&gt;-&lt;/code&gt; 等同于省略该参数。如果在原始连接的 &lt;code&gt;conninfo&lt;/code&gt; 中指定了 &lt;code&gt;hostaddr&lt;/code&gt; ，该地址将重新用于新连接（不考虑其他任何主机规范）。</target>
        </trans-unit>
        <trans-unit id="f9b1968453a400f5fd07425f7b52ed24d9c6b52b" translate="yes" xml:space="preserve">
          <source>Where the current standard provides a family of XML data types to hold &amp;ldquo;document&amp;rdquo; or &amp;ldquo;content&amp;rdquo; in untyped or XML Schema-typed variants, and a type &lt;code&gt;XML(SEQUENCE)&lt;/code&gt; to hold arbitrary pieces of XML content, PostgreSQL provides the single &lt;code&gt;xml&lt;/code&gt; type, which can hold &amp;ldquo;document&amp;rdquo; or &amp;ldquo;content&amp;rdquo;. There is no equivalent of the standard's &amp;ldquo;sequence&amp;rdquo; type.</source>
          <target state="translated">当前标准提供了一系列XML数据类型来保存无类型或XML Schema类型的变体中的&amp;ldquo;文档&amp;rdquo;或&amp;ldquo;内容&amp;rdquo;，并提供了 &lt;code&gt;XML(SEQUENCE)&lt;/code&gt; 类型来保存任意XML内容，而PostgreSQL提供了单个 &lt;code&gt;xml&lt;/code&gt; 类型。 ，可以保存&amp;ldquo;文档&amp;rdquo;或&amp;ldquo;内容&amp;rdquo;。没有等同于标准的&amp;ldquo;序列&amp;rdquo;类型。</target>
        </trans-unit>
        <trans-unit id="9be0ce89e49423198dedc7c03fd710b9a77c7468" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;pgstattuple&lt;/code&gt; always performs a full-table scan and returns an exact count of live and dead tuples (and their sizes) and free space, &lt;code&gt;pgstattuple_approx&lt;/code&gt; tries to avoid the full-table scan and returns exact dead tuple statistics along with an approximation of the number and size of live tuples and free space.</source>
          <target state="translated">而 &lt;code&gt;pgstattuple&lt;/code&gt; 等始终执行全表扫描和回报的活的和死的元组（及其大小）精确计数和自由空间， &lt;code&gt;pgstattuple_approx&lt;/code&gt; 试图避免全表扫描，并返回精确死的元组统计随着数量的近似值元组的大小和可用空间。</target>
        </trans-unit>
        <trans-unit id="9ec341d8bc6b0b4825eb80f0ff91c4f3ae8eee3b" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;aggfinalfn&lt;/code&gt; modifies the transition state value: &lt;code&gt;r&lt;/code&gt; if it is read-only, &lt;code&gt;s&lt;/code&gt; if the &lt;code&gt;aggtransfn&lt;/code&gt; cannot be applied after the &lt;code&gt;aggfinalfn&lt;/code&gt;, or &lt;code&gt;w&lt;/code&gt; if it writes on the value</source>
          <target state="translated">&lt;code&gt;aggfinalfn&lt;/code&gt; 是否修改过渡状态值：如果只读，则为 &lt;code&gt;r&lt;/code&gt; ；如果在 &lt;code&gt;aggtransfn&lt;/code&gt; 之后不能应用 &lt;code&gt;aggfinalfn&lt;/code&gt; ，则为 &lt;code&gt;s&lt;/code&gt; ;如果在该值上写入，则为 &lt;code&gt;w&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b63ddfd6a1548ba35d00a888f441158a5e09419b" translate="yes" xml:space="preserve">
          <source>Whether an RE is greedy or not is determined by the following rules:</source>
          <target state="translated">一个RE是否贪婪,是由以下规则决定的。</target>
        </trans-unit>
        <trans-unit id="a052d21cc109877e0a34f6fceb8177147b8e054e" translate="yes" xml:space="preserve">
          <source>Whether the sequence cycles</source>
          <target state="translated">顺序是否循环</target>
        </trans-unit>
        <trans-unit id="099ca603e257bb42c8d0080a36e8a200732df4c1" translate="yes" xml:space="preserve">
          <source>Whether to convert &lt;code&gt;\n&lt;/code&gt; into &lt;code&gt;\r\n&lt;/code&gt; when encrypting and &lt;code&gt;\r\n&lt;/code&gt; to &lt;code&gt;\n&lt;/code&gt; when decrypting. RFC 4880 specifies that text data should be stored using &lt;code&gt;\r\n&lt;/code&gt; line-feeds. Use this to get fully RFC-compliant behavior.</source>
          <target state="translated">是否转换 &lt;code&gt;\n&lt;/code&gt; 为 &lt;code&gt;\r\n&lt;/code&gt; 加密和当 &lt;code&gt;\r\n&lt;/code&gt; 到 &lt;code&gt;\n&lt;/code&gt; 解密时。RFC 4880指定应使用 &lt;code&gt;\r\n&lt;/code&gt; 换行符存储文本数据。使用它来获得完全符合RFC的行为。</target>
        </trans-unit>
        <trans-unit id="6a913bec72a9d1cd9190d3ca3274a90d4c381b09" translate="yes" xml:space="preserve">
          <source>Whether to convert textual data from database internal encoding to UTF-8 and back. If your database already is UTF-8, no conversion will be done, but the message will be tagged as UTF-8. Without this option it will not be.</source>
          <target state="translated">是否将数据库内部编码的文本数据转换为UTF-8并返回。如果您的数据库已经是UTF-8,则不会进行转换,但邮件会被标记为UTF-8。如果没有这个选项,则不会进行转换。</target>
        </trans-unit>
        <trans-unit id="5d0908bbd26e431175b3928caa067e2b55410af7" translate="yes" xml:space="preserve">
          <source>Which S2K algorithm to use.</source>
          <target state="translated">使用哪种S2K算法。</target>
        </trans-unit>
        <trans-unit id="1b435ac17c99f4ed78933b5d05d5b47d3dfdd820" translate="yes" xml:space="preserve">
          <source>Which cipher algorithm to use.</source>
          <target state="translated">使用哪种密码算法。</target>
        </trans-unit>
        <trans-unit id="4215d6c5a786cf08cc1b93732554ac25c2ba7716" translate="yes" xml:space="preserve">
          <source>Which cipher to use for encrypting separate session key.</source>
          <target state="translated">使用哪种密码来加密独立的会话密钥。</target>
        </trans-unit>
        <trans-unit id="8c9643312802b96a36d211d4bd8a2d4fbec5df7d" translate="yes" xml:space="preserve">
          <source>Which compression algorithm to use. Only available if PostgreSQL was built with zlib.</source>
          <target state="translated">使用哪种压缩算法。只有在PostgreSQL是用zlib构建的情况下才可用。</target>
        </trans-unit>
        <trans-unit id="36178694d36e0d8b9b4d6953d14f4cb84f698946" translate="yes" xml:space="preserve">
          <source>Which digest algorithm to use in S2K calculation.</source>
          <target state="translated">在S2K计算中使用哪种摘要算法。</target>
        </trans-unit>
        <trans-unit id="5b9d8c9d7eb5636216a755086b48fa5a8cd067ff" translate="yes" xml:space="preserve">
          <source>Which one of these you use is mainly a matter of style. The &lt;code&gt;JOIN&lt;/code&gt; syntax in the &lt;code&gt;FROM&lt;/code&gt; clause is probably not as portable to other SQL database management systems, even though it is in the SQL standard. For outer joins there is no choice: they must be done in the &lt;code&gt;FROM&lt;/code&gt; clause. The &lt;code&gt;ON&lt;/code&gt; or &lt;code&gt;USING&lt;/code&gt; clause of an outer join is &lt;em&gt;not&lt;/em&gt; equivalent to a &lt;code&gt;WHERE&lt;/code&gt; condition, because it results in the addition of rows (for unmatched input rows) as well as the removal of rows in the final result.</source>
          <target state="translated">您使用哪一个主要取决于样式。即使在 &lt;code&gt;FROM&lt;/code&gt; 标准中，FROM子句中的 &lt;code&gt;JOIN&lt;/code&gt; 语法也可能无法移植到其他SQL数据库管理系统中。对于外部联接，别无选择：它们必须在 &lt;code&gt;FROM&lt;/code&gt; 子句中完成。外部 &lt;code&gt;USING&lt;/code&gt; 的 &lt;code&gt;ON&lt;/code&gt; 或USING子句&lt;em&gt;不&lt;/em&gt;等于 &lt;code&gt;WHERE&lt;/code&gt; 条件，因为它导致添加行（对于不匹配的输入行）以及最终结果中的行删除。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f207dff92fd241726ec3f780d5ff085d75648337" translate="yes" xml:space="preserve">
          <source>Which particular operators exist and whether they are unary or binary depends on what operators have been defined by the system or the user. &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;Chapter 9&lt;/a&gt; describes the built-in operators.</source>
          <target state="translated">存在哪些特定运算符，以及它们是一元运算符还是二进制运算符，取决于系统或用户定义了哪些运算符。&lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;第9章&lt;/a&gt;介绍了内置运算符。</target>
        </trans-unit>
        <trans-unit id="6b60d8de1898a75db9c84423bdbee981b013228e" translate="yes" xml:space="preserve">
          <source>Which particular operators exist and whether they are unary or binary depends on what operators have been defined by the system or the user. &lt;a href=&quot;https://www.postgresql.org/docs/13/functions.html&quot;&gt;Chapter 9&lt;/a&gt; describes the built-in operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8189028b5d12d59cd50147d702e5a513253a68c3" translate="yes" xml:space="preserve">
          <source>Which row(s) to update</source>
          <target state="translated">要更新的行</target>
        </trans-unit>
        <trans-unit id="a8a5e55dc1620d200691892efc7a7c676cbd8264" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;CREATE INDEX&lt;/code&gt; with the &lt;code&gt;CONCURRENTLY&lt;/code&gt; option supports parallel builds without special restrictions, only the first table scan is actually performed in parallel.</source>
          <target state="translated">尽管带有 &lt;code&gt;CONCURRENTLY&lt;/code&gt; 选项的 &lt;code&gt;CREATE INDEX&lt;/code&gt; 支持并行构建而没有特殊限制，但实际上只有第一个表扫描实际上是并行执行的。</target>
        </trans-unit>
        <trans-unit id="714b73638a1ef948dee8dfe7820683df70955357" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;UNIQUE&lt;/code&gt; is a natural constraint for scalar values, it is usually unsuitable for range types. Instead, an exclusion constraint is often more appropriate (see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt;CREATE TABLE ... CONSTRAINT ... EXCLUDE&lt;/a&gt;). Exclusion constraints allow the specification of constraints such as &amp;ldquo;non-overlapping&amp;rdquo; on a range type. For example:</source>
          <target state="translated">尽管 &lt;code&gt;UNIQUE&lt;/code&gt; 是标量值的自然约束，但通常不适合范围类型。相反，排除约束通常更合适（请参见&lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt;CREATE TABLE ... CONSTRAINT ... EXCLUDE&lt;/a&gt;）。排除约束允许在范围类型上指定约束，例如&amp;ldquo;不重叠&amp;rdquo;。例如：</target>
        </trans-unit>
        <trans-unit id="4a9577e86cf0dfccc12f0ecf60188a3b6040e454" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;pg_resetwal&lt;/code&gt; will set the WAL starting address beyond the latest existing WAL segment file, some segment size changes can cause previous WAL file names to be reused. It is recommended to use &lt;code&gt;-l&lt;/code&gt; together with this option to manually set the WAL starting address if WAL file name overlap will cause problems with your archiving strategy.</source>
          <target state="translated">尽管 &lt;code&gt;pg_resetwal&lt;/code&gt; 会将WAL的起始地址设置为最新的现有WAL段文件之外，但是某些段大小的更改可能导致以前的WAL文件名被重用。如果WAL文件名重叠会导致归档策略出现问题，建议将 &lt;code&gt;-l&lt;/code&gt; 与该选项一起使用以手动设置WAL起始地址。</target>
        </trans-unit>
        <trans-unit id="01708a73847573f321d3d2da0f455cb9f949df75" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;to_date&lt;/code&gt; will reject a mixture of Gregorian and ISO week-numbering date fields, &lt;code&gt;to_char&lt;/code&gt; will not, since output format specifications like &lt;code&gt;YYYY-MM-DD (IYYY-IDDD)&lt;/code&gt; can be useful. But avoid writing something like &lt;code&gt;IYYY-MM-DD&lt;/code&gt;; that would yield surprising results near the start of the year. (See &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;Section 9.9.1&lt;/a&gt; for more information.)</source>
          <target state="translated">尽管 &lt;code&gt;to_date&lt;/code&gt; 将拒绝使用格里高利历和ISO周编号日期字段的混合，但 &lt;code&gt;to_char&lt;/code&gt; 不会，因为诸如 &lt;code&gt;YYYY-MM-DD (IYYY-IDDD)&lt;/code&gt; 类的输出格式规范可能会有用。但是避免写类似 &lt;code&gt;IYYY-MM-DD&lt;/code&gt; 的东西；在今年年初将产生令人惊讶的结果。（有关更多信息，请参见&lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;第9.9.1节&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="e362e9f328b5aa2d887a4c59191ea1b7f9721dc4" translate="yes" xml:space="preserve">
          <source>While C-style block comments are passed to the server for processing and removal, SQL-standard comments are removed by psql.</source>
          <target state="translated">C风格的块注释会传到服务器上进行处理和删除,而SQL标准的注释则由psql删除。</target>
        </trans-unit>
        <trans-unit id="5d725442e0975d9459afb2abfae7302730928d6f" translate="yes" xml:space="preserve">
          <source>While PostgreSQL's Serializable transaction isolation level only allows concurrent transactions to commit if it can prove there is a serial order of execution that would produce the same effect, it doesn't always prevent errors from being raised that would not occur in true serial execution. In particular, it is possible to see unique constraint violations caused by conflicts with overlapping Serializable transactions even after explicitly checking that the key isn't present before attempting to insert it. This can be avoided by making sure that &lt;em&gt;all&lt;/em&gt; Serializable transactions that insert potentially conflicting keys explicitly check if they can do so first. For example, imagine an application that asks the user for a new key and then checks that it doesn't exist already by trying to select it first, or generates a new key by selecting the maximum existing key and adding one. If some Serializable transactions insert new keys directly without following this protocol, unique constraints violations might be reported even in cases where they could not occur in a serial execution of the concurrent transactions.</source>
          <target state="translated">尽管PostgreSQL的Serializable事务隔离级别仅允许并发事务提交，只要它可以证明存在可以产生相同效果的串行执行顺序，但它并不能始终防止引发真正的串行执行中不会发生的错误。特别是，即使在尝试插入密钥之前明确检查了密钥是否存在之后，也有可能看到由与重叠的Serializable事务冲突引起的唯一约束冲突。可以通过确保&lt;em&gt;所有&lt;/em&gt;插入有潜在冲突的密钥的可序列化事务会先明确检查是否可以这样做。例如，假设有一个应用程序要求用户提供新密钥，然后先尝试将其选中以检查它是否不存在，或者通过选择现有的最大密钥并添加一个新密钥来生成新密钥。如果某些可序列化事务在不遵循此协议的情况下直接插入新密钥，则即使在并发事务的串行执行中无法发生唯一约束冲突，也可能会报告它们。</target>
        </trans-unit>
        <trans-unit id="594dab457c5441b59c42227020751df6f6f62a48" translate="yes" xml:space="preserve">
          <source>While XQuery/XPath provides all of the types defined in XML Schema and many operators and functions over those types, XPath 1.0 has only node-sets and the three atomic types &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">XQuery / XPath提供了XML Schema中定义的所有类型以及这些类型上的许多运算符和函数，而XPath 1.0仅具有节点集，并且具有三种原子类型 &lt;code&gt;boolean&lt;/code&gt; ， &lt;code&gt;double&lt;/code&gt; 和 &lt;code&gt;string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a627fd0ca096f765ec57a0f53e97d18839b3a4e" translate="yes" xml:space="preserve">
          <source>While a &lt;code&gt;LIKE&lt;/code&gt; clause exists in the SQL standard, many of the options that PostgreSQL accepts for it are not in the standard, and some of the standard's options are not implemented by PostgreSQL.</source>
          <target state="translated">虽然SQL标准中存在 &lt;code&gt;LIKE&lt;/code&gt; 子句，但PostgreSQL接受的许多选项都不在标准中，并且PostgreSQL并未实现某些标准的选项。</target>
        </trans-unit>
        <trans-unit id="bcdd2fd3f430f1ca01d2b3670c0f594bdee786bb" translate="yes" xml:space="preserve">
          <source>While a Repeatable Read transaction has a stable view of the data throughout its execution, there is a subtle issue with using MVCC snapshots for data consistency checks, involving something known as &lt;em&gt;read/write conflicts&lt;/em&gt;. If one transaction writes data and a concurrent transaction attempts to read the same data (whether before or after the write), it cannot see the work of the other transaction. The reader then appears to have executed first regardless of which started first or which committed first. If that is as far as it goes, there is no problem, but if the reader also writes data which is read by a concurrent transaction there is now a transaction which appears to have run before either of the previously mentioned transactions. If the transaction which appears to have executed last actually commits first, it is very easy for a cycle to appear in a graph of the order of execution of the transactions. When such a cycle appears, integrity checks will not work correctly without some help.</source>
          <target state="translated">尽管&amp;ldquo;可重复读取&amp;rdquo;事务在整个执行过程中都具有稳定的数据视图，但是使用MVCC快照进行数据一致性检查时存在一个细微的问题，涉及到一些&lt;em&gt;读/写冲突。&lt;/em&gt;。如果一个事务写入数据，而一个并发事务尝试读取同一数据（无论是在写入之前还是之后），则它看不到另一事务的工作。然后，无论先启动哪个还是先提交哪个，读者都似乎先执行了。如果可以做到这一点，那没有问题，但是如果读取器也写入并发事务读取的数据，则现在看来有一个事务在前面提到的任何一个事务之前都已运行。如果看似最后执行的事务实际上首先提交，则周期很容易出现在事务执行顺序的图表中。当出现这样的循环时，如果没有一些帮助，完整性检查将无法正确进行。</target>
        </trans-unit>
        <trans-unit id="6a87fa7f9afe44920c1e825c81201c0429df3a1c" translate="yes" xml:space="preserve">
          <source>While a self-signed certificate can be used for testing, a certificate signed by a certificate authority (CA) (usually an enterprise-wide root CA) should be used in production.</source>
          <target state="translated">虽然自签证书可以用于测试,但在生产中应使用由证书颁发机构(CA)(通常是企业范围内的根CA)签署的证书。</target>
        </trans-unit>
        <trans-unit id="cdc31b216171332e350cb9df34dfb0418ab3630e" translate="yes" xml:space="preserve">
          <source>While designing your archiving setup, consider what will happen if the archive command fails repeatedly because some aspect requires operator intervention or the archive runs out of space. For example, this could occur if you write to tape without an autochanger; when the tape fills, nothing further can be archived until the tape is swapped. You should ensure that any error condition or request to a human operator is reported appropriately so that the situation can be resolved reasonably quickly. The &lt;code&gt;pg_wal/&lt;/code&gt; directory will continue to fill with WAL segment files until the situation is resolved. (If the file system containing &lt;code&gt;pg_wal/&lt;/code&gt; fills up, PostgreSQL will do a PANIC shutdown. No committed transactions will be lost, but the database will remain offline until you free some space.)</source>
          <target state="translated">在设计归档设置时，请考虑如果由于某些方面需要操作员干预或归档空间不足而导致归档命令反复失败会发生什么情况。例如，如果您在没有自动转换器的情况下写入磁带，则可能会发生这种情况。当磁带装满时，在交换磁带之前，无法进一步存储任何内容。您应该确保适当地报告任何错误情况或对操作员的要求，以便可以迅速地解决问题。该 &lt;code&gt;pg_wal/&lt;/code&gt; 目录将继续填充WAL段文件，直到情况得到解决。 （如果包含 &lt;code&gt;pg_wal/&lt;/code&gt; 的文件系统被填满，PostgreSQL将关闭PANIC。不会丢失任何已提交的事务，但是数据库将保持脱机状态，直到您释放一些空间。）</target>
        </trans-unit>
        <trans-unit id="ed48d255fcc854a30e92ea66bfc2714ea9b2abf4" translate="yes" xml:space="preserve">
          <source>While forcing data to the disk platters periodically might seem like a simple operation, it is not. Because disk drives are dramatically slower than main memory and CPUs, several layers of caching exist between the computer's main memory and the disk platters. First, there is the operating system's buffer cache, which caches frequently requested disk blocks and combines disk writes. Fortunately, all operating systems give applications a way to force writes from the buffer cache to disk, and PostgreSQL uses those features. (See the &lt;a href=&quot;runtime-config-wal#GUC-WAL-SYNC-METHOD&quot;&gt;wal_sync_method&lt;/a&gt; parameter to adjust how this is done.)</source>
          <target state="translated">虽然周期性地将数据强制到磁盘上看起来很简单，但事实并非如此。由于磁盘驱动器比主内存和CPU慢得多，因此在计算机的主内存和磁盘片之间存在几层缓存。首先，是操作系统的缓冲区高速缓存，该缓冲区高速缓存经常请求的磁盘块并合并磁盘写入。幸运的是，所有操作系统都为应用程序提供了一种强制从缓冲区高速缓存写入磁盘的方法，而PostgreSQL使用了这些功能。 （请参阅&lt;a href=&quot;runtime-config-wal#GUC-WAL-SYNC-METHOD&quot;&gt;wal_sync_method&lt;/a&gt;参数以调整操作方式。）</target>
        </trans-unit>
        <trans-unit id="ae2f9725af5b866105aef02d826c3c21674b82a5" translate="yes" xml:space="preserve">
          <source>While it is possible to obtain information about which processes block which other processes by joining &lt;code&gt;pg_locks&lt;/code&gt; against itself, this is very difficult to get right in detail. Such a query would have to encode knowledge about which lock modes conflict with which others. Worse, the &lt;code&gt;pg_locks&lt;/code&gt; view does not expose information about which processes are ahead of which others in lock wait queues, nor information about which processes are parallel workers running on behalf of which other client sessions. It is better to use the &lt;code&gt;pg_blocking_pids()&lt;/code&gt; function (see &lt;a href=&quot;functions-info#FUNCTIONS-INFO-SESSION-TABLE&quot;&gt;Table 9.63&lt;/a&gt;) to identify which process(es) a waiting process is blocked behind.</source>
          <target state="translated">尽管有可能通过将 &lt;code&gt;pg_locks&lt;/code&gt; 自身联系起来而获得有关哪个进程阻塞了其他进程的信息，但这很难在细节上做到正确。这样的查询将必须编码有关哪些锁定模式与其他锁定模式冲突的知识。更糟糕的是， &lt;code&gt;pg_locks&lt;/code&gt; 视图不会公开有关哪些进程在锁定等待队列中领先于其他进程的信息，也不会公开有关哪些进程是代表其他客户端会话运行的并行工作程序的信息。最好使用 &lt;code&gt;pg_blocking_pids()&lt;/code&gt; 函数（请&lt;a href=&quot;functions-info#FUNCTIONS-INFO-SESSION-TABLE&quot;&gt;参见表9.63&lt;/a&gt;）来确定等待的进程被阻塞在哪个进程之后。</target>
        </trans-unit>
        <trans-unit id="17d114999ab92dc3c41f0deae7314e26f77d91d6" translate="yes" xml:space="preserve">
          <source>While most regular-expression searches can be executed very quickly, regular expressions can be contrived that take arbitrary amounts of time and memory to process. Be wary of accepting regular-expression search patterns from hostile sources. If you must do so, it is advisable to impose a statement timeout.</source>
          <target state="translated">虽然大多数正则表达式搜索可以非常快速地执行,但正则表达式可以被设计成需要任意数量的时间和内存来处理。要警惕接受来自敌对来源的正则表达式搜索模式。如果你必须这样做,最好施加一个语句超时。</target>
        </trans-unit>
        <trans-unit id="4544bbaee7531ef45a0e42c59e09a0908293364f" translate="yes" xml:space="preserve">
          <source>While most timezone abbreviations represent fixed offsets from UTC, there are some that have historically varied in value (see &lt;a href=&quot;datetime-config-files&quot;&gt;Section B.4&lt;/a&gt; for more information). In such cases this view presents their current meaning.</source>
          <target state="translated">虽然大多数时区缩写表示相对于UTC的固定偏移量，但是有些缩写的值在历史上有所不同（有关更多信息，请参见&lt;a href=&quot;datetime-config-files&quot;&gt;B.4节&lt;/a&gt;）。在这种情况下，此视图表示其当前含义。</target>
        </trans-unit>
        <trans-unit id="eb000322f7d40100b6e53cb7562cee4c2935cc07" translate="yes" xml:space="preserve">
          <source>While multiple databases can be created within a single cluster, it is advised to consider carefully whether the benefits outweigh the risks and limitations. In particular, the impact that having a shared WAL (see &lt;a href=&quot;https://www.postgresql.org/docs/13/wal.html&quot;&gt;Chapter 29&lt;/a&gt;) has on backup and recovery options. While individual databases in the cluster are isolated when considered from the user's perspective, they are closely bound from the database administrator's point-of-view.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64e20acb9a4d1b2d1994838c4133180e7c30312a" translate="yes" xml:space="preserve">
          <source>While not required, it is recommended that you continue to follow this old convention of naming cast implementation functions after the target data type. Many users are used to being able to cast data types using a function-style notation, that is &lt;code&gt;typename&lt;/code&gt;(&lt;code&gt;x&lt;/code&gt;). This notation is in fact nothing more nor less than a call of the cast implementation function; it is not specially treated as a cast. If your conversion functions are not named to support this convention then you will have surprised users. Since PostgreSQL allows overloading of the same function name with different argument types, there is no difficulty in having multiple conversion functions from different types that all use the target type's name.</source>
          <target state="translated">虽然不是必需的，但是建议您继续遵循在目标数据类型之后命名强制转换实现函数的旧约定。许多用户习惯于使用函数样式表示法（即 &lt;code&gt;typename&lt;/code&gt; （ &lt;code&gt;x&lt;/code&gt; ））来转换数据类型。实际上，这种表示法无非就是对强制转换实现函数的调用。它没有被特别视为演员。如果您的转换函数未命名为支持该约定，那么您将对用户感到惊讶。由于PostgreSQL允许使用不同的参数类型重载相同的函数名称，因此让来自不同类型的多个转换函数都都使用目标类型的名称就没有困难了。</target>
        </trans-unit>
        <trans-unit id="9e3fedf4b54ce85919b4142394d398f5b611a696" translate="yes" xml:space="preserve">
          <source>While policies will be applied for explicit queries against tables in the database, they are not applied when the system is performing internal referential integrity checks or validating constraints. This means there are indirect ways to determine that a given value exists. An example of this is attempting to insert a duplicate value into a column that is a primary key or has a unique constraint. If the insert fails then the user can infer that the value already exists. (This example assumes that the user is permitted by policy to insert records which they are not allowed to see.) Another example is where a user is allowed to insert into a table which references another, otherwise hidden table. Existence can be determined by the user inserting values into the referencing table, where success would indicate that the value exists in the referenced table. These issues can be addressed by carefully crafting policies to prevent users from being able to insert, delete, or update records at all which might possibly indicate a value they are not otherwise able to see, or by using generated values (e.g., surrogate keys) instead of keys with external meanings.</source>
          <target state="translated">虽然对数据库中的表进行显式查询时会应用策略,但当系统在执行内部参考完整性检查或验证约束时,不会应用策略。这意味着有一些间接的方法来确定一个给定的值存在。一个例子是试图在一个主键或具有唯一约束的列中插入一个重复的值。如果插入失败,那么用户可以推断该值已经存在。这个例子假设用户被策略允许插入他们不允许看到的记录)。另一个例子是允许用户插入到一个引用另一个隐藏表的表中。存在性可以通过用户将值插入到引用表中来确定,成功则表示该值存在于引用表中。这些问题可以通过仔细制定策略来解决,防止用户根本无法插入、删除或更新记录,因为这些记录可能表明他们在其他情况下无法看到的值,或者通过使用生成的值(如代用键)而不是具有外部含义的键来解决。</target>
        </trans-unit>
        <trans-unit id="5fbe4c0896d37fe14f081d1ac25be59617f075b0" translate="yes" xml:space="preserve">
          <source>While recovery is paused no further database changes are applied. If in hot standby, all new queries will see the same consistent snapshot of the database, and no further query conflicts will be generated until recovery is resumed.</source>
          <target state="translated">当恢复暂停时,不会再应用数据库更改。如果处于热备状态,所有新的查询都会看到相同的一致的数据库快照,在恢复之前不会再产生查询冲突。</target>
        </trans-unit>
        <trans-unit id="67bee53c255823e86d8c23b4190b410627254abc" translate="yes" xml:space="preserve">
          <source>While rows can be moved from local partitions to a foreign-table partition (provided the foreign data wrapper supports tuple routing), they cannot be moved from a foreign-table partition to another partition.</source>
          <target state="translated">虽然行可以从本地分区移动到外表分区(前提是外表数据封装器支持元组路由),但它们不能从外表分区移动到另一个分区。</target>
        </trans-unit>
        <trans-unit id="7158e641e335f398bdfc35c274f36a1760cfa0bc" translate="yes" xml:space="preserve">
          <source>While running pg_dump, one should examine the output for any warnings (printed on standard error), especially in light of the limitations listed below.</source>
          <target state="translated">当运行pg_dump时,应该检查输出是否有任何警告(打印在标准误差上),特别是考虑到下面列出的限制。</target>
        </trans-unit>
        <trans-unit id="891b0584891eb2794e238a1971ed31f1c215e841" translate="yes" xml:space="preserve">
          <source>While that doesn't look all that bad by itself, it's still oversimplified. A far more complicated sub-select would be needed to select the right OID if there are multiple tables named &lt;code&gt;mytable&lt;/code&gt; in different schemas. The &lt;code&gt;regclass&lt;/code&gt; input converter handles the table lookup according to the schema path setting, and so it does the &amp;ldquo;right thing&amp;rdquo; automatically. Similarly, casting a table's OID to &lt;code&gt;regclass&lt;/code&gt; is handy for symbolic display of a numeric OID.</source>
          <target state="translated">尽管这看起来并不很糟糕，但仍然过于简化了。如果在不同模式中有多个名为 &lt;code&gt;mytable&lt;/code&gt; 的表，则需要更复杂的子选择来选择正确的OID 。该 &lt;code&gt;regclass&lt;/code&gt; 的输入转换器根据模式路径设置处理查表，所以它做&amp;ldquo;正确的事&amp;rdquo;自动。同样，将表的OID强制转换为 &lt;code&gt;regclass&lt;/code&gt; 对于数字OID的符号显示很方便。</target>
        </trans-unit>
        <trans-unit id="d982cd814f64616912cda4d88166e9a69d28b85b" translate="yes" xml:space="preserve">
          <source>While that particular example might seem silly, related cases that don't obviously involve constants can occur in queries executed within functions, since the values of function arguments and local variables can be inserted into queries as constants for planning purposes. Within PL/pgSQL functions, for example, using an &lt;code&gt;IF&lt;/code&gt;-&lt;code&gt;THEN&lt;/code&gt;-&lt;code&gt;ELSE&lt;/code&gt; statement to protect a risky computation is much safer than just nesting it in a &lt;code&gt;CASE&lt;/code&gt; expression.</source>
          <target state="translated">尽管该特定示例可能看起来很愚蠢，但是在函数内执行的查询中可能会出现明显不涉及常量的相关情况，因为出于规划目的，可以将函数参数和局部变量的值作为常量插入查询中。例如，在PL / pgSQL函数中，使用 &lt;code&gt;IF&lt;/code&gt; - &lt;code&gt;THEN&lt;/code&gt; - &lt;code&gt;ELSE&lt;/code&gt; 语句来保护有风险的计算比仅将其嵌套在 &lt;code&gt;CASE&lt;/code&gt; 表达式中要安全得多。</target>
        </trans-unit>
        <trans-unit id="cfcd6cf6959e988635a363ac7fbe48c4622cc9ea" translate="yes" xml:space="preserve">
          <source>While the built-in declarative partitioning is suitable for most common use cases, there are some circumstances where a more flexible approach may be useful. Partitioning can be implemented using table inheritance, which allows for several features not supported by declarative partitioning, such as:</source>
          <target state="translated">虽然内置的声明式分区适用于大多数常见的用例,但在某些情况下,更灵活的方法可能是有用的。分区可以使用表继承来实现,它允许声明式分区不支持的一些功能,例如:</target>
        </trans-unit>
        <trans-unit id="f761cf19de1d987297c4bdb87e576a9e8ef5e265" translate="yes" xml:space="preserve">
          <source>While the default index for future &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; operations is retained, &lt;code&gt;REFRESH MATERIALIZED VIEW&lt;/code&gt; does not order the generated rows based on this property. If you want the data to be ordered upon generation, you must use an &lt;code&gt;ORDER BY&lt;/code&gt; clause in the backing query.</source>
          <target state="translated">尽管保留了将来的&lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt;操作的默认索引，但是 &lt;code&gt;REFRESH MATERIALIZED VIEW&lt;/code&gt; 不会基于此属性对生成的行进行排序。如果要在生成时对数据进行排序，则必须在后备查询中使用 &lt;code&gt;ORDER BY&lt;/code&gt; 子句。</target>
        </trans-unit>
        <trans-unit id="89bb80c5dc369e5a7b8dcef839df901e5b397bf5" translate="yes" xml:space="preserve">
          <source>While the details of the new type's internal representation are only known to the I/O functions and other functions you create to work with the type, there are several properties of the internal representation that must be declared to PostgreSQL. Foremost of these is &lt;code&gt;internallength&lt;/code&gt;. Base data types can be fixed-length, in which case &lt;code&gt;internallength&lt;/code&gt; is a positive integer, or variable-length, indicated by setting &lt;code&gt;internallength&lt;/code&gt; to &lt;code&gt;VARIABLE&lt;/code&gt;. (Internally, this is represented by setting &lt;code&gt;typlen&lt;/code&gt; to -1.) The internal representation of all variable-length types must start with a 4-byte integer giving the total length of this value of the type. (Note that the length field is often encoded, as described in &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt;; it's unwise to access it directly.)</source>
          <target state="translated">虽然新类型的内部表示的详细信息仅由I / O函数和您创建的与该类型一起使用的其他函数才知道，但是内部表示的一些属性必须声明给PostgreSQL。其中最重要的是 &lt;code&gt;internallength&lt;/code&gt; 。基本数据类型可以是固定长度，在这种情况下， &lt;code&gt;internallength&lt;/code&gt; 是正整数，也可以是可变长度，可以通过将 &lt;code&gt;internallength&lt;/code&gt; 设置为 &lt;code&gt;VARIABLE&lt;/code&gt; 来表示。 （内部，这是通过将 &lt;code&gt;typlen&lt;/code&gt; 设置为-1 来表示的。）所有可变长度类型的内部表示必须以4字节整数开头，并给出该类型值的总长度。 （请注意，长度字段通常经过编码，如&lt;a href=&quot;storage-toast&quot;&gt;68.2节&lt;/a&gt; ; 直接访问它是不明智的。）</target>
        </trans-unit>
        <trans-unit id="e2a6eda1b3f1244604b394ad1d7fc00d1fb05fef" translate="yes" xml:space="preserve">
          <source>While the example below uses a constant JSON value, typical use would be to reference a &lt;code&gt;json&lt;/code&gt; or &lt;code&gt;jsonb&lt;/code&gt; column laterally from another table in the query's &lt;code&gt;FROM&lt;/code&gt; clause. Writing &lt;code&gt;json_populate_record&lt;/code&gt; in the &lt;code&gt;FROM&lt;/code&gt; clause is good practice, since all of the extracted columns are available for use without duplicate function calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="915068b5c9a0a4207ecd95ee0a72471b7e35a59c" translate="yes" xml:space="preserve">
          <source>While the examples for these functions use constants, the typical use would be to reference a table in the &lt;code&gt;FROM&lt;/code&gt; clause and use one of its &lt;code&gt;json&lt;/code&gt; or &lt;code&gt;jsonb&lt;/code&gt; columns as an argument to the function. Extracted key values can then be referenced in other parts of the query, like &lt;code&gt;WHERE&lt;/code&gt; clauses and target lists. Extracting multiple values in this way can improve performance over extracting them separately with per-key operators.</source>
          <target state="translated">虽然这些函数的示例使用常量，但通常的用法是在 &lt;code&gt;FROM&lt;/code&gt; 子句中引用表并将其 &lt;code&gt;json&lt;/code&gt; 或 &lt;code&gt;jsonb&lt;/code&gt; 列之一用作该函数的参数。然后可以在查询的其他部分中引用提取的键值，例如 &lt;code&gt;WHERE&lt;/code&gt; 子句和目标列表。与使用每个键运算符分别提取多个值相比，以这种方式提取多个值可以提高性能。</target>
        </trans-unit>
        <trans-unit id="5c45fc673d90d93e24f91fea428d0f8a94bae39e" translate="yes" xml:space="preserve">
          <source>While the input strings &lt;code&gt;now&lt;/code&gt;, &lt;code&gt;today&lt;/code&gt;, &lt;code&gt;tomorrow&lt;/code&gt;, and &lt;code&gt;yesterday&lt;/code&gt; are fine to use in interactive SQL commands, they can have surprising behavior when the command is saved to be executed later, for example in prepared statements, views, and function definitions. The string can be converted to a specific time value that continues to be used long after it becomes stale. Use one of the SQL functions instead in such contexts. For example, &lt;code&gt;CURRENT_DATE + 1&lt;/code&gt; is safer than &lt;code&gt;'tomorrow'::date&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c09c1945f14d262f5a989a6b1b7f78a8869fb1b" translate="yes" xml:space="preserve">
          <source>While the server is running, it is not possible for a malicious user to take the place of the normal database server. However, when the server is down, it is possible for a local user to spoof the normal server by starting their own server. The spoof server could read passwords and queries sent by clients, but could not return any data because the &lt;code&gt;PGDATA&lt;/code&gt; directory would still be secure because of directory permissions. Spoofing is possible because any user can start a database server; a client cannot identify an invalid server unless it is specially configured.</source>
          <target state="translated">在服务器运行时，恶意用户无法代替普通数据库服务器。但是，当服务器关闭时，本地用户可以通过启动自己的服务器来欺骗普通服务器。欺骗服务器可以读取客户端发送的密码和查询，但不能返回任何数据，因为 &lt;code&gt;PGDATA&lt;/code&gt; 目录由于目录权限而仍然是安全的。欺骗是可能的，因为任何用户都可以启动数据库服务器。除非经过特殊配置，否则客户端无法识别无效的服务器。</target>
        </trans-unit>
        <trans-unit id="a8b90c7536148bdec5e290019a51b2379ecb8d63" translate="yes" xml:space="preserve">
          <source>While the server is running, its PID is stored in the file &lt;code&gt;postmaster.pid&lt;/code&gt; in the data directory. This is used to prevent multiple server instances from running in the same data directory and can also be used for shutting down the server.</source>
          <target state="translated">服务器运行时，其PID存储在数据目录中的文件 &lt;code&gt;postmaster.pid&lt;/code&gt; 中。这用于防止多个服务器实例在同一数据目录中运行，也可以用于关闭服务器。</target>
        </trans-unit>
        <trans-unit id="a03c807444bf3594110c4d388ec7b0a59f62a431" translate="yes" xml:space="preserve">
          <source>While the standard syntax for specifying string constants is usually convenient, it can be difficult to understand when the desired string contains many single quotes or backslashes, since each of those must be doubled. To allow more readable queries in such situations, PostgreSQL provides another way, called &amp;ldquo;dollar quoting&amp;rdquo;, to write string constants. A dollar-quoted string constant consists of a dollar sign (&lt;code&gt;$&lt;/code&gt;), an optional &amp;ldquo;tag&amp;rdquo; of zero or more characters, another dollar sign, an arbitrary sequence of characters that makes up the string content, a dollar sign, the same tag that began this dollar quote, and a dollar sign. For example, here are two different ways to specify the string &amp;ldquo;Dianne's horse&amp;rdquo; using dollar quoting:</source>
          <target state="translated">虽然指定字符串常量的标准语法通常很方便，但是当所需的字符串包含许多单引号或反斜杠时，可能很难理解，因为每个引号或反斜杠必须加倍。为了在这种情况下允许更具可读性的查询，PostgreSQL提供了另一种称为&amp;ldquo;美元引号&amp;rdquo;的方式来编写字符串常量。以美元报价的字符串常量包括一个美元符号（ &lt;code&gt;$&lt;/code&gt; ），一个零个或多个字符的可选&amp;ldquo;标记&amp;rdquo;，另一个美元符号，构成字符串内容的任意字符序列，一个美元符号以及与之相同的标记开始用这美元报价和一个美元符号。例如，以下两种使用美元引号指定字符串&amp;ldquo; Dianne's horse&amp;rdquo;的方法：</target>
        </trans-unit>
        <trans-unit id="97a03d15b6274d3b06d93b14cfe041b66ef2af72" translate="yes" xml:space="preserve">
          <source>While this function is more complex than the single-month case, it doesn't need to be updated as often, since branches can be added in advance of being needed.</source>
          <target state="translated">虽然这个功能比单月的情况更复杂,但它不需要经常更新,因为可以在需要之前添加分支。</target>
        </trans-unit>
        <trans-unit id="eb917c6d1ba7f34837342b8b023d8fdc99add536" translate="yes" xml:space="preserve">
          <source>While this is the only way to convert character strings into XML values according to the SQL standard, the PostgreSQL-specific syntaxes:</source>
          <target state="translated">虽然这是根据SQL标准将字符串转换为XML值的唯一方法,但PostgreSQL特有的语法。</target>
        </trans-unit>
        <trans-unit id="13b118c29b5eac33252cf8f05a41900068035eae" translate="yes" xml:space="preserve">
          <source>While transition table names for &lt;code&gt;AFTER&lt;/code&gt; triggers are specified using the &lt;code&gt;REFERENCING&lt;/code&gt; clause in the standard way, the row variables used in &lt;code&gt;FOR EACH ROW&lt;/code&gt; triggers may not be specified in a &lt;code&gt;REFERENCING&lt;/code&gt; clause. They are available in a manner that is dependent on the language in which the trigger function is written, but is fixed for any one language. Some languages effectively behave as though there is a &lt;code&gt;REFERENCING&lt;/code&gt; clause containing &lt;code&gt;OLD ROW AS OLD NEW ROW AS NEW&lt;/code&gt;.</source>
          <target state="translated">尽管使用 &lt;code&gt;REFERENCING&lt;/code&gt; 子句以标准方式指定了 &lt;code&gt;AFTER&lt;/code&gt; 触发器的转换表名称，但是在 &lt;code&gt;FOR EACH ROW&lt;/code&gt; 触发器中使用的行变量可能未在 &lt;code&gt;REFERENCING&lt;/code&gt; 子句中指定。它们的使用方式取决于编写触发功能的语言，但对于任何一种语言都是固定的。某些语言实际上表现得好像有一个 &lt;code&gt;REFERENCING&lt;/code&gt; 子句包含 &lt;code&gt;OLD ROW AS OLD NEW ROW AS NEW&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0775e3a82644839414e547fda3c53cda5989eee1" translate="yes" xml:space="preserve">
          <source>While turning off &lt;code&gt;fsync&lt;/code&gt; is often a performance benefit, this can result in unrecoverable data corruption in the event of a power failure or system crash. Thus it is only advisable to turn off &lt;code&gt;fsync&lt;/code&gt; if you can easily recreate your entire database from external data.</source>
          <target state="translated">虽然关闭 &lt;code&gt;fsync&lt;/code&gt; 通常可以提高性能，但是在电源故障或系统崩溃的情况下，这可能导致无法恢复的数据损坏。因此，仅当您可以轻松地从外部数据重新创建整个数据库时，才建议关闭 &lt;code&gt;fsync&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d9f7345f5e4a9cecb1d3a73e9e82a30d0080279" translate="yes" xml:space="preserve">
          <source>White space (i.e., spaces, tabs, and newlines) can be used freely in SQL commands. That means you can type the command aligned differently than above, or even all on one line. Two dashes (&amp;ldquo;&lt;code&gt;--&lt;/code&gt;&amp;rdquo;) introduce comments. Whatever follows them is ignored up to the end of the line. SQL is case insensitive about key words and identifiers, except when identifiers are double-quoted to preserve the case (not done above).</source>
          <target state="translated">空格（即空格，制表符和换行符）可以在SQL命令中自由使用。这意味着您可以键入与上面不同的对齐方式，甚至可以将所有命令都排成一行。两个破折号（&amp;ldquo; &lt;code&gt;--&lt;/code&gt; &amp;rdquo;）介绍注释。紧随其后的所有内容都将被忽略，直到行尾为止。SQL对关键字和标识符不区分大小写，除非对标识符加双引号以保留大小写（上面没有做过）。</target>
        </trans-unit>
        <trans-unit id="58bd91fff64a844973a8238af97e34efc8a5c324" translate="yes" xml:space="preserve">
          <source>White space is ignored on input, so &lt;code&gt;[(x),(y)]&lt;/code&gt; is the same as &lt;code&gt;[ ( x ), ( y ) ]&lt;/code&gt;.</source>
          <target state="translated">输入时忽略空格，因此 &lt;code&gt;[(x),(y)]&lt;/code&gt; 与 &lt;code&gt;[ ( x ), ( y ) ]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac41fe428645044123abfe95a020b4d162465d70" translate="yes" xml:space="preserve">
          <source>Whitespace is allowed before and after the range value, but any whitespace between the parentheses or brackets is taken as part of the lower or upper bound value. (Depending on the element type, it might or might not be significant.)</source>
          <target state="translated">在范围值的前后允许有空白,但括号或方括号之间的任何空白都将作为下限或上限值的一部分。根据元素类型的不同,它可能是重要的,也可能不是。</target>
        </trans-unit>
        <trans-unit id="78d976901748b052cce834685b15a7dd1749e3bc" translate="yes" xml:space="preserve">
          <source>Whitespace of the same width as the most recent output of &lt;code&gt;PROMPT1&lt;/code&gt;. This can be used as a &lt;code&gt;PROMPT2&lt;/code&gt; setting, so that multi-line statements are aligned with the first line, but there is no visible secondary prompt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cc40c3d855977fc828d35a4c20284c43f252dc0" translate="yes" xml:space="preserve">
          <source>Why would you want to use the weak mode? Well, it could be that you have a huge collection of ISBN numbers, and that there are so many of them that for weird reasons some have the wrong check digit (perhaps the numbers were scanned from a printed list and the OCR got the numbers wrong, perhaps the numbers were manually captured... who knows). Anyway, the point is you might want to clean the mess up, but you still want to be able to have all the numbers in your database and maybe use an external tool to locate the invalid numbers in the database so you can verify the information and validate it more easily; so for example you'd want to select all the invalid numbers in the table.</source>
          <target state="translated">为什么你要使用弱模式?可能是你有一个庞大的ISBN号集合,而且有这么多的ISBN号,由于一些奇怪的原因,有些号码有错误的校验码(也许号码是从打印的列表中扫描出来的,OCR把号码弄错了,也许号码是手动捕捉的......谁知道呢)。总之,问题的关键是你可能想要清理这些乱七八糟的东西,但你还是希望能够在你的数据库中拥有所有的数字,也许可以使用一个外部工具来定位数据库中的无效数字,这样你就可以更容易地验证信息和验证它;所以例如,你想选择表中所有的无效数字。</target>
        </trans-unit>
        <trans-unit id="70a7ce99eb76502ad0a6210d94039f0b40c3419d" translate="yes" xml:space="preserve">
          <source>Wildcard array element accessor that returns all array elements.</source>
          <target state="translated">返回所有数组元素的通配符数组元素访问器。</target>
        </trans-unit>
        <trans-unit id="cd2106ae04d09a5386f20710a015aa4219dc3f6c" translate="yes" xml:space="preserve">
          <source>Wildcard member accessor that returns the values of all members located at the top level of the current object.</source>
          <target state="translated">通配符成员访问器,返回位于当前对象顶层的所有成员的值。</target>
        </trans-unit>
        <trans-unit id="68fe8f958724479a101c0326f7607d389d321758" translate="yes" xml:space="preserve">
          <source>Window Functions</source>
          <target state="translated">窗口功能</target>
        </trans-unit>
        <trans-unit id="927627d12746803cbdee2462dc2d4d29bab17c5e" translate="yes" xml:space="preserve">
          <source>Window function (routine)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01267df331f99498a90196b34760cb7aa229a46d" translate="yes" xml:space="preserve">
          <source>Window function calls are permitted only in the &lt;code&gt;SELECT&lt;/code&gt; list and the &lt;code&gt;ORDER BY&lt;/code&gt; clause of the query.</source>
          <target state="translated">仅在查询的 &lt;code&gt;SELECT&lt;/code&gt; 列表和 &lt;code&gt;ORDER BY&lt;/code&gt; 子句中允许窗口函数调用。</target>
        </trans-unit>
        <trans-unit id="c367a920e4a4ea3efbe3a1a798085a3a023e6741" translate="yes" xml:space="preserve">
          <source>Window functions are described in detail in &lt;a href=&quot;tutorial-window&quot;&gt;Section 3.5&lt;/a&gt;, &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Section 4.2.8&lt;/a&gt;, and &lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;Section 7.2.5&lt;/a&gt;.</source>
          <target state="translated">窗函数中详细描述的&lt;a href=&quot;tutorial-window&quot;&gt;第3.5节&lt;/a&gt;，&lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;4.2.8节&lt;/a&gt;，和&lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;7.2.5节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5f451b621911f3a41da7c18da4aff7cdb55589c1" translate="yes" xml:space="preserve">
          <source>Window functions are permitted only in the &lt;code&gt;SELECT&lt;/code&gt; list and the &lt;code&gt;ORDER BY&lt;/code&gt; clause of the query. They are forbidden elsewhere, such as in &lt;code&gt;GROUP BY&lt;/code&gt;, &lt;code&gt;HAVING&lt;/code&gt; and &lt;code&gt;WHERE&lt;/code&gt; clauses. This is because they logically execute after the processing of those clauses. Also, window functions execute after non-window aggregate functions. This means it is valid to include an aggregate function call in the arguments of a window function, but not vice versa.</source>
          <target state="translated">窗口函数仅在查询的 &lt;code&gt;SELECT&lt;/code&gt; 列表和 &lt;code&gt;ORDER BY&lt;/code&gt; 子句中允许。在其他地方禁止使用它们，例如 &lt;code&gt;GROUP BY&lt;/code&gt; ， &lt;code&gt;HAVING&lt;/code&gt; 和 &lt;code&gt;WHERE&lt;/code&gt; 子句。这是因为它们在处理这些子句之后在逻辑上执行。同样，窗口函数在非窗口聚合函数之后执行。这意味着在窗口函数的参数中包括聚合函数调用是有效的，反之亦然。</target>
        </trans-unit>
        <trans-unit id="79e789d251d694ff69667eed3b6a1eef1b73bc73" translate="yes" xml:space="preserve">
          <source>Window: cume_dist</source>
          <target state="translated">窗口:Cume_dist</target>
        </trans-unit>
        <trans-unit id="1e7f6a60bbd5fd2e82c3412bbb88bea212c4bdb7" translate="yes" xml:space="preserve">
          <source>Window: dense_rank</source>
          <target state="translated">窗口:dense_rank</target>
        </trans-unit>
        <trans-unit id="08d36b418003a8b9c0e9b2dd2a6f2bff70e5a8ac" translate="yes" xml:space="preserve">
          <source>Window: first_value</source>
          <target state="translated">窗口:first_value</target>
        </trans-unit>
        <trans-unit id="b5f178a106cd7cba1da80bdc71ec514eea37f26d" translate="yes" xml:space="preserve">
          <source>Window: lag</source>
          <target state="translated">窗口:滞后</target>
        </trans-unit>
        <trans-unit id="fabaa17e6490da4ec5451b3b47ee388b70cf91b0" translate="yes" xml:space="preserve">
          <source>Window: last_value</source>
          <target state="translated">窗口:last_value</target>
        </trans-unit>
        <trans-unit id="994efd60b559fadbd405573c301089b7cf18f884" translate="yes" xml:space="preserve">
          <source>Window: lead</source>
          <target state="translated">窗口:铅</target>
        </trans-unit>
        <trans-unit id="757db4a854089f2de8d98fd39c8889ef5116458d" translate="yes" xml:space="preserve">
          <source>Window: nth_value</source>
          <target state="translated">窗口:nth_value</target>
        </trans-unit>
        <trans-unit id="e7f90d6e0544bf0f16ab443f5e02ee4cd6fe42bc" translate="yes" xml:space="preserve">
          <source>Window: ntile</source>
          <target state="translated">窗口:ntile</target>
        </trans-unit>
        <trans-unit id="bb901cf4a6350aa408d137094086445ef7a0cf50" translate="yes" xml:space="preserve">
          <source>Window: percent_rank</source>
          <target state="translated">窗口:%_rank</target>
        </trans-unit>
        <trans-unit id="c0ecbc78e1223c489bcdc839303f81579d301dbd" translate="yes" xml:space="preserve">
          <source>Window: rank</source>
          <target state="translated">窗口:排名</target>
        </trans-unit>
        <trans-unit id="31c13454a2137d228d57d97a95bb16f2559129e2" translate="yes" xml:space="preserve">
          <source>Window: row_number</source>
          <target state="translated">窗口:row_number</target>
        </trans-unit>
        <trans-unit id="afb3a4bfc7eab0371f71e7828e71cca0cb17b3c3" translate="yes" xml:space="preserve">
          <source>Windows CP1250</source>
          <target state="translated">Windows CP1250</target>
        </trans-unit>
        <trans-unit id="9a2c00b8e44a047e41a03f1caab3a7b4b6689695" translate="yes" xml:space="preserve">
          <source>Windows CP1251</source>
          <target state="translated">Windows CP1251</target>
        </trans-unit>
        <trans-unit id="ee9d69428625d1ff5f15b6e3dcde936a0fd1f094" translate="yes" xml:space="preserve">
          <source>Windows CP1252</source>
          <target state="translated">Windows CP1252</target>
        </trans-unit>
        <trans-unit id="cc78a0c32f91f66c55ae633ccbcefebb486eb07a" translate="yes" xml:space="preserve">
          <source>Windows CP1253</source>
          <target state="translated">Windows CP1253</target>
        </trans-unit>
        <trans-unit id="5f231ed423cb65bf660816b30028087f1a8e8ce5" translate="yes" xml:space="preserve">
          <source>Windows CP1254</source>
          <target state="translated">Windows CP1254</target>
        </trans-unit>
        <trans-unit id="a23b534f177679e438c10751dd8cd9af7ceda942" translate="yes" xml:space="preserve">
          <source>Windows CP1255</source>
          <target state="translated">Windows CP1255</target>
        </trans-unit>
        <trans-unit id="6790dc03b7d5b6e6f32fcb36c60e23323fb868ac" translate="yes" xml:space="preserve">
          <source>Windows CP1256</source>
          <target state="translated">Windows CP1256</target>
        </trans-unit>
        <trans-unit id="2de6d342a6a1f91fe73d1aed1c38e985a216e16e" translate="yes" xml:space="preserve">
          <source>Windows CP1257</source>
          <target state="translated">Windows CP1257</target>
        </trans-unit>
        <trans-unit id="640bb2a94fe66a43ea03427875c71fa7af756764" translate="yes" xml:space="preserve">
          <source>Windows CP1258</source>
          <target state="translated">Windows CP1258</target>
        </trans-unit>
        <trans-unit id="e95532249be79aa59a141ea1dc6d988132a7c104" translate="yes" xml:space="preserve">
          <source>Windows CP866</source>
          <target state="translated">Windows CP866</target>
        </trans-unit>
        <trans-unit id="69925dc2d1afa064badeb7131e0815ad04126da3" translate="yes" xml:space="preserve">
          <source>Windows CP874</source>
          <target state="translated">Windows CP874</target>
        </trans-unit>
        <trans-unit id="c6d589f8c6c9e727468855e6a54c0d6dfb5cce47" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--create&lt;/code&gt;, pg_restore also restores the database's comment if any, and any configuration variable settings that are specific to this database, that is, any &lt;code&gt;ALTER DATABASE ... SET ...&lt;/code&gt; and &lt;code&gt;ALTER ROLE ... IN DATABASE ... SET ...&lt;/code&gt; commands that mention this database. Access privileges for the database itself are also restored, unless &lt;code&gt;--no-acl&lt;/code&gt; is specified.</source>
          <target state="translated">使用 &lt;code&gt;--create&lt;/code&gt; ，pg_restore还可以恢复数据库的注释（如果有），以及该数据库特有的任何配置变量设置，即任何 &lt;code&gt;ALTER DATABASE ... SET ...&lt;/code&gt; 和 &lt;code&gt;ALTER ROLE ... IN DATABASE ... SET ...&lt;/code&gt; 提及此数据库的命令。除非指定了 &lt;code&gt;--no-acl&lt;/code&gt; ，否则还将恢复数据库本身的访问特权。</target>
        </trans-unit>
        <trans-unit id="8fdece12f1fb080c2dbfd8709cabeca4afb1d172" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--create&lt;/code&gt;, the output also includes the database's comment if any, and any configuration variable settings that are specific to this database, that is, any &lt;code&gt;ALTER DATABASE ... SET ...&lt;/code&gt; and &lt;code&gt;ALTER ROLE ... IN DATABASE ... SET ...&lt;/code&gt; commands that mention this database. Access privileges for the database itself are also dumped, unless &lt;code&gt;--no-acl&lt;/code&gt; is specified.</source>
          <target state="translated">使用 &lt;code&gt;--create&lt;/code&gt; ，输出还包括数据库的注释（如果有）以及该数据库特定的任何配置变量设置，即任何 &lt;code&gt;ALTER DATABASE ... SET ...&lt;/code&gt; 和 &lt;code&gt;ALTER ROLE ... IN DATABASE ... SET ...&lt;/code&gt; 提及此数据库的命令。除非指定了 &lt;code&gt;--no-acl&lt;/code&gt; ，否则数据库本身的访问特权也会被转储。</target>
        </trans-unit>
        <trans-unit id="f1abf8b357cf8a269c4c68a487360b4810c28399" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;G&lt;/code&gt; (server-side data generation), only small queries are sent from the &lt;code&gt;pgbench&lt;/code&gt; client and then data is actually generated in the server. No significant bandwidth is required for this variant, but the server will do more work. Using &lt;code&gt;G&lt;/code&gt; causes logging not to print any progress message while generating data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc8bd1c0f7d38dd3394b226a28acc604884d1615" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;g&lt;/code&gt; (client-side data generation), data is generated in &lt;code&gt;pgbench&lt;/code&gt; client and then sent to the server. This uses the client/server bandwidth extensively through a &lt;code&gt;COPY&lt;/code&gt;. Using &lt;code&gt;g&lt;/code&gt; causes logging to print one message every 100,000 rows while generating data for the &lt;code&gt;pgbench_accounts&lt;/code&gt; table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f453a9fafc8b310f8a3de3fda65ed4c38e9ca283" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;join_collapse_limit&lt;/code&gt; = 1, this forces the planner to join A to B before joining them to other tables, but doesn't constrain its choices otherwise. In this example, the number of possible join orders is reduced by a factor of 5.</source>
          <target state="translated">在 &lt;code&gt;join_collapse_limit&lt;/code&gt; = 1的情况下，这将迫使计划者在将A和B联接到其他表之前先将它们联接到B，但是不会限制其选择。在此示例中，可能的加入订单数减少了5倍。</target>
        </trans-unit>
        <trans-unit id="fe49ef2ae18f846d2f24144892dcb7436b22edbb" translate="yes" xml:space="preserve">
          <source>With ICU, it is not sensible to enumerate all possible locale names. ICU uses a particular naming system for locales, but there are many more ways to name a locale than there are actually distinct locales. &lt;code&gt;initdb&lt;/code&gt; uses the ICU APIs to extract a set of distinct locales to populate the initial set of collations. Collations provided by ICU are created in the SQL environment with names in BCP 47 language tag format, with a &amp;ldquo;private use&amp;rdquo; extension &lt;code&gt;-x-icu&lt;/code&gt; appended, to distinguish them from libc locales.</source>
          <target state="translated">使用ICU，枚举所有可能的语言环境名称是不明智的。 ICU对语言环境使用特定的命名系统，但是命名语言环境的方法比实际上存在不同的语言环境的方法更多。 &lt;code&gt;initdb&lt;/code&gt; 使用ICU API提取一组不同的语言环境来填充初始的排序规则集。 ICU提供的排序规则是在SQL环境中创建的，其名称使用BCP 47语言标记格式，并附加了&amp;ldquo;专用&amp;rdquo;扩展名 &lt;code&gt;-x-icu&lt;/code&gt; ，以使其与libc语言环境区分开。</target>
        </trans-unit>
        <trans-unit id="cc0ce6e945d75c0e017cd4582a6ce07fb85c72b6" translate="yes" xml:space="preserve">
          <source>With OpenSSL</source>
          <target state="translated">使用OpenSSL</target>
        </trans-unit>
        <trans-unit id="2a51bd6ec05106a3703acb2d25cff0f482de5c76" translate="yes" xml:space="preserve">
          <source>With SQL-based replication middleware, a program intercepts every SQL query and sends it to one or all servers. Each server operates independently. Read-write queries must be sent to all servers, so that every server receives any changes. But read-only queries can be sent to just one server, allowing the read workload to be distributed among them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fa1343fb87dfb28347c1e7e66e33ba69c59c2ca" translate="yes" xml:space="preserve">
          <source>With SSL support compiled in, the PostgreSQL server can be started with SSL enabled by setting the parameter &lt;a href=&quot;runtime-config-connection#GUC-SSL&quot;&gt;ssl&lt;/a&gt; to &lt;code&gt;on&lt;/code&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;. The server will listen for both normal and SSL connections on the same TCP port, and will negotiate with any connecting client on whether to use SSL. By default, this is at the client's option; see &lt;a href=&quot;auth-pg-hba-conf&quot;&gt;Section 20.1&lt;/a&gt; about how to set up the server to require use of SSL for some or all connections.</source>
          <target state="translated">编译了SSL支持后，可以通过在 &lt;code&gt;postgresql.conf&lt;/code&gt; 中将参数&lt;a href=&quot;runtime-config-connection#GUC-SSL&quot;&gt;ssl&lt;/a&gt;设置为 &lt;code&gt;on&lt;/code&gt; 来启用启用SSL的PostgreSQL服务器。服务器将侦听同一TCP端口上的常规连接和SSL连接，并将与任何连接的客户端协商是否使用SSL。默认情况下，这是由客户选择的。有关如何设置服务器以要求对某些或所有连接使用SSL的信息，请参见&lt;a href=&quot;auth-pg-hba-conf&quot;&gt;第20.1节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1d13ab27fd57668592221b667df2e40b0bb1e2e4" translate="yes" xml:space="preserve">
          <source>With a cluster distributed across multiple geographic locations, using different values per location brings more flexibility in the cluster management. A smaller value is useful for faster failure detection with a standby having a low-latency network connection, and a larger value helps in judging better the health of a standby if located on a remote location, with a high-latency network connection.</source>
          <target state="translated">对于分布在多个地理位置的集群,在每个位置使用不同的值会给集群管理带来更大的灵活性。较小的数值对于具有低延迟网络连接的备用机更快地进行故障检测非常有用,而较大的数值有助于更好地判断位于远程位置、具有高延迟网络连接的备用机的健康状况。</target>
        </trans-unit>
        <trans-unit id="2817eb5fe50b4283e89c69a97c63500ae24da2d7" translate="yes" xml:space="preserve">
          <source>With a parameter, turns displaying of how long each SQL statement takes on or off. Without a parameter, toggles the display between on and off. The display is in milliseconds; intervals longer than 1 second are also shown in minutes:seconds format, with hours and days fields added if needed.</source>
          <target state="translated">有参数时,打开或关闭每条SQL语句的显示时间。没有参数时,在打开和关闭之间切换显示。显示的单位是毫秒;超过1秒的时间间隔也以分:秒的格式显示,如果需要,还可以添加小时和天字段。</target>
        </trans-unit>
        <trans-unit id="862b8683e39578b4e7d997552333b9aad19243ce" translate="yes" xml:space="preserve">
          <source>With constraint exclusion enabled, this &lt;code&gt;SELECT&lt;/code&gt; will not scan &lt;code&gt;child1000&lt;/code&gt; at all, improving performance.</source>
          <target state="translated">启用约束排除后，此 &lt;code&gt;SELECT&lt;/code&gt; 根本不会扫描 &lt;code&gt;child1000&lt;/code&gt; ，从而提高了性能。</target>
        </trans-unit>
        <trans-unit id="281288184f75c730f93254833c37347e0fc29fe4" translate="yes" xml:space="preserve">
          <source>With data warehouse type workloads, it can make sense to use a larger number of partitions than with an OLTP type workload. Generally, in data warehouses, query planning time is less of a concern as the majority of processing time is spent during query execution. With either of these two types of workload, it is important to make the right decisions early, as re-partitioning large quantities of data can be painfully slow. Simulations of the intended workload are often beneficial for optimizing the partitioning strategy. Never assume that more partitions are better than fewer partitions and vice-versa.</source>
          <target state="translated">对于数据仓库类型的工作负载,与OLTP类型的工作负载相比,使用更多数量的分区是有意义的。一般来说,在数据仓库中,查询规划时间不太重要,因为大部分处理时间都是在查询执行过程中度过的。对于这两种类型的工作负载中的任何一种,尽早做出正确的决策都是非常重要的,因为对大量数据进行重新分区可能会非常痛苦缓慢。对预期的工作负载进行模拟,往往有利于优化分区策略。千万不要认为分区越多越好,反之亦然。</target>
        </trans-unit>
        <trans-unit id="3766650cc974cf1ed93fe99df3e842788c554914" translate="yes" xml:space="preserve">
          <source>With no advance preparation, the system would have to scan the entire &lt;code&gt;test1&lt;/code&gt; table, row by row, to find all matching entries. If there are many rows in &lt;code&gt;test1&lt;/code&gt; and only a few rows (perhaps zero or one) that would be returned by such a query, this is clearly an inefficient method. But if the system has been instructed to maintain an index on the &lt;code&gt;id&lt;/code&gt; column, it can use a more efficient method for locating matching rows. For instance, it might only have to walk a few levels deep into a search tree.</source>
          <target state="translated">如果没有提前准备，系统将不得不逐行扫描整个 &lt;code&gt;test1&lt;/code&gt; 表，以找到所有匹配的条目。如果 &lt;code&gt;test1&lt;/code&gt; 中有很多行，而这样的查询仅返回几行（也许为零或一），则显然这是一种低效的方法。但是，如果指示系统维护 &lt;code&gt;id&lt;/code&gt; 列上的索引，则可以使用更有效的方法来查找匹配的行。例如，它可能只需要深入搜索树中几级即可。</target>
        </trans-unit>
        <trans-unit id="d718f6eccff45185b0a45095de6fde081eea1bba" translate="yes" xml:space="preserve">
          <source>With no argument, escapes to a sub-shell; psql resumes when the sub-shell exits. With an argument, executes the shell command &lt;code&gt;command&lt;/code&gt;.</source>
          <target state="translated">不带任何参数，转至子外壳；子外壳程序退出时，psql恢复。带参数执行shell命令 &lt;code&gt;command&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9514950fe011b56b473f75097880ade2b163bceb" translate="yes" xml:space="preserve">
          <source>With statement-based replication middleware, a program intercepts every SQL query and sends it to one or all servers. Each server operates independently. Read-write queries must be sent to all servers, so that every server receives any changes. But read-only queries can be sent to just one server, allowing the read workload to be distributed among them.</source>
          <target state="translated">使用基于语句的复制中间件,程序拦截每个SQL查询并将其发送到一个或所有服务器。每个服务器独立运行。读写查询必须发送到所有服务器,这样每个服务器都能收到任何变化。但只读查询可以只发送给一台服务器,使读的工作量在它们之间分配。</target>
        </trans-unit>
        <trans-unit id="4094d09ba0d0f0a9849aa3ea46bb7d77a767e980" translate="yes" xml:space="preserve">
          <source>With synchronous replication options specified at the application level (on the primary) we can offer synchronous replication for the most important changes, without slowing down the bulk of the total workload. Application level options are an important and practical tool for allowing the benefits of synchronous replication for high performance applications.</source>
          <target state="translated">通过在应用层(在主设备上)指定同步复制选项,我们可以为最重要的更改提供同步复制,而不会减慢总工作负载的大部分。应用层选项是一个重要而实用的工具,可以让高性能应用享受到同步复制的好处。</target>
        </trans-unit>
        <trans-unit id="e625f82083935e0517f3c7cf1a804070d41f41f5" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--aggregate-interval&lt;/code&gt; option, a different format is used for the log files:</source>
          <target state="translated">使用 &lt;code&gt;--aggregate-interval&lt;/code&gt; 选项，日志文件将使用其他格式：</target>
        </trans-unit>
        <trans-unit id="21c13395c6ff50aca429bd803e2b410319037881" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;-l&lt;/code&gt; option (but without the &lt;code&gt;--aggregate-interval&lt;/code&gt; option), pgbench writes information about each transaction to a log file. The log file will be named &lt;code&gt;prefix.nnn&lt;/code&gt;, where &lt;code&gt;prefix&lt;/code&gt; defaults to &lt;code&gt;pgbench_log&lt;/code&gt;, and &lt;code&gt;nnn&lt;/code&gt; is the PID of the pgbench process. The prefix can be changed by using the &lt;code&gt;--log-prefix&lt;/code&gt; option. If the &lt;code&gt;-j&lt;/code&gt; option is 2 or higher, so that there are multiple worker threads, each will have its own log file. The first worker will use the same name for its log file as in the standard single worker case. The additional log files for the other workers will be named &lt;code&gt;prefix.nnn.mmm&lt;/code&gt;, where &lt;code&gt;mmm&lt;/code&gt; is a sequential number for each worker starting with 1.</source>
          <target state="translated">使用 &lt;code&gt;-l&lt;/code&gt; 选项（但不使用 &lt;code&gt;--aggregate-interval&lt;/code&gt; 选项），pgbench将有关每个事务的信息写入日志文件。日志文件将命名为 &lt;code&gt;prefix.nnn&lt;/code&gt; ，其中 &lt;code&gt;prefix&lt;/code&gt; 默认为 &lt;code&gt;pgbench_log&lt;/code&gt; ，而 &lt;code&gt;nnn&lt;/code&gt; 是pgbench进程的PID。可以使用 &lt;code&gt;--log-prefix&lt;/code&gt; 选项更改前缀。如果 &lt;code&gt;-j&lt;/code&gt; 选项为2或更高，则有多个工作线程，每个工作线程都有自己的日志文件。第一个工作程序将在其日志文件中使用与标准单工作程序情况下相同的名称。其他工作程序的其他日志文件将命名为 &lt;code&gt;prefix.nnn.mmm&lt;/code&gt; ，其中 &lt;code&gt;mmm&lt;/code&gt; 是从1开始的每个工人的序号。</target>
        </trans-unit>
        <trans-unit id="dea12aa8ce2a4f9481a6f03ad5ce52c7d1882b2a" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;-r&lt;/code&gt; option, pgbench collects the elapsed transaction time of each statement executed by every client. It then reports an average of those values, referred to as the latency for each statement, after the benchmark has finished.</source>
          <target state="translated">使用 &lt;code&gt;-r&lt;/code&gt; 选项，pgbench会收集每个客户端执行的每个语句的经过的事务时间。然后，它会在基准测试完成后报告这些值的平均值，称为每个语句的等待时间。</target>
        </trans-unit>
        <trans-unit id="b0d0adcb9fc8fc9dddac0cfadc06d179ba840172" translate="yes" xml:space="preserve">
          <source>With the default setting of &lt;code&gt;Accept&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt;, it is only useful to place a &lt;code&gt;simple&lt;/code&gt; dictionary at the end of a list of dictionaries, since it will never pass on any token to a following dictionary. Conversely, &lt;code&gt;Accept&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; is only useful when there is at least one following dictionary.</source>
          <target state="translated">使用默认设置 &lt;code&gt;Accept&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt; ，仅将 &lt;code&gt;simple&lt;/code&gt; 字典放在字典列表的末尾是有用的，因为它永远不会将任何令牌传递给后续的字典。相反，仅当至少有一个以下词典时， &lt;code&gt;Accept&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; 才有用。</target>
        </trans-unit>
        <trans-unit id="1679a02524be37201556be412a6d701fa1ad4ae3" translate="yes" xml:space="preserve">
          <source>With the tools discussed so far you can create fully functional tables. The remainder of this chapter is concerned with adding features to the table definition to ensure data integrity, security, or convenience. If you are eager to fill your tables with data now you can skip ahead to &lt;a href=&quot;https://www.postgresql.org/docs/12/dml.html&quot;&gt;Chapter 6&lt;/a&gt; and read the rest of this chapter later.</source>
          <target state="translated">使用到目前为止讨论的工具，您可以创建功能齐全的表。本章的其余部分涉及为表定义添加功能以确保数据完整性，安全性或便利性。如果您现在渴望用数据填充表格，则可以跳到&lt;a href=&quot;https://www.postgresql.org/docs/12/dml.html&quot;&gt;第6&lt;/a&gt;章，稍后再阅读本章的其余部分。</target>
        </trans-unit>
        <trans-unit id="65bded40379a6ac67a03a08a9d131c48acd1a16a" translate="yes" xml:space="preserve">
          <source>With the tools discussed so far you can create fully functional tables. The remainder of this chapter is concerned with adding features to the table definition to ensure data integrity, security, or convenience. If you are eager to fill your tables with data now you can skip ahead to &lt;a href=&quot;https://www.postgresql.org/docs/13/dml.html&quot;&gt;Chapter 6&lt;/a&gt; and read the rest of this chapter later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37674f638cca87d9f8a3c6dc8d132c3743ff6b7c" translate="yes" xml:space="preserve">
          <source>With this parameter enabled, you can still create ordinary global users. Simply append &lt;code&gt;@&lt;/code&gt; when specifying the user name in the client, e.g. &lt;code&gt;joe@&lt;/code&gt;. The &lt;code&gt;@&lt;/code&gt; will be stripped off before the user name is looked up by the server.</source>
          <target state="translated">启用此参数后，您仍然可以创建普通的全局用户。在客户端中指定用户名时，只需添加 &lt;code&gt;@&lt;/code&gt; 即可，例如 &lt;code&gt;joe@&lt;/code&gt; 。该 &lt;code&gt;@&lt;/code&gt; 将用户名是由服务器抬头之前剥离。</target>
        </trans-unit>
        <trans-unit id="5c255d5e2ff800e00e81014aac8b22d43990196d" translate="yes" xml:space="preserve">
          <source>With this parameter enabled, you can still create ordinary global users. Simply append &lt;code&gt;@&lt;/code&gt; when specifying the user name in the client, e.g., &lt;code&gt;joe@&lt;/code&gt;. The &lt;code&gt;@&lt;/code&gt; will be stripped off before the user name is looked up by the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de39e9b44ca28bac2cf5d078925f7311c5e84abb" translate="yes" xml:space="preserve">
          <source>With this preparation, a backup can be taken using a script like the following:</source>
          <target state="translated">有了这些准备,就可以用下面这样的脚本进行备份。</target>
        </trans-unit>
        <trans-unit id="d7d93925105d3192c92e0036610fccacd28a3de6" translate="yes" xml:space="preserve">
          <source>Within &lt;code&gt;condition&lt;/code&gt; and &lt;code&gt;command&lt;/code&gt;, the special table names &lt;code&gt;NEW&lt;/code&gt; and &lt;code&gt;OLD&lt;/code&gt; can be used to refer to values in the referenced table. &lt;code&gt;NEW&lt;/code&gt; is valid in &lt;code&gt;ON INSERT&lt;/code&gt; and &lt;code&gt;ON UPDATE&lt;/code&gt; rules to refer to the new row being inserted or updated. &lt;code&gt;OLD&lt;/code&gt; is valid in &lt;code&gt;ON UPDATE&lt;/code&gt; and &lt;code&gt;ON DELETE&lt;/code&gt; rules to refer to the existing row being updated or deleted.</source>
          <target state="translated">在 &lt;code&gt;condition&lt;/code&gt; 和 &lt;code&gt;command&lt;/code&gt; 中，特殊表名 &lt;code&gt;NEW&lt;/code&gt; 和 &lt;code&gt;OLD&lt;/code&gt; 可用于引用引用表中的值。 &lt;code&gt;NEW&lt;/code&gt; 在 &lt;code&gt;ON INSERT&lt;/code&gt; 和 &lt;code&gt;ON UPDATE&lt;/code&gt; 规则中有效，以引用要插入或更新的新行。 &lt;code&gt;OLD&lt;/code&gt; 在 &lt;code&gt;ON UPDATE&lt;/code&gt; 和 &lt;code&gt;ON DELETE&lt;/code&gt; 规则中有效，以引用要更新或删除的现有行。</target>
        </trans-unit>
        <trans-unit id="b7c7983937789ea59f666ccaa3b6dc10f18e4489" translate="yes" xml:space="preserve">
          <source>Within a &lt;code&gt;tsquery&lt;/code&gt;, the &lt;code&gt;&amp;amp;&lt;/code&gt; (AND) operator specifies that both its arguments must appear in the document to have a match. Similarly, the &lt;code&gt;|&lt;/code&gt; (OR) operator specifies that at least one of its arguments must appear, while the &lt;code&gt;!&lt;/code&gt; (NOT) operator specifies that its argument must &lt;em&gt;not&lt;/em&gt; appear in order to have a match. For example, the query &lt;code&gt;fat &amp;amp; ! rat&lt;/code&gt; matches documents that contain &lt;code&gt;fat&lt;/code&gt; but not &lt;code&gt;rat&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;tsquery&lt;/code&gt; 中， &lt;code&gt;&amp;amp;&lt;/code&gt; （AND）运算符指定其两个参数都必须出现在文档中才能匹配。同样， &lt;code&gt;|&lt;/code&gt; （OR）运算符指定必须出现其参数中的至少一个，而 &lt;code&gt;!&lt;/code&gt; （NOT）运算符指定其参数必须&lt;em&gt;不&lt;/em&gt;出现才能匹配。例如，查询 &lt;code&gt;fat &amp;amp; ! rat&lt;/code&gt; 匹配包含文档 &lt;code&gt;fat&lt;/code&gt; 而不是 &lt;code&gt;rat&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f2368cc4cb5a919d014b1e03cda4cf0d9819b781" translate="yes" xml:space="preserve">
          <source>Within a bracket expression, a collating element (a character, a multiple-character sequence that collates as if it were a single character, or a collating-sequence name for either) enclosed in &lt;code&gt;[.&lt;/code&gt; and &lt;code&gt;.]&lt;/code&gt; stands for the sequence of characters of that collating element. The sequence is treated as a single element of the bracket expression's list. This allows a bracket expression containing a multiple-character collating element to match more than one character, e.g., if the collating sequence includes a &lt;code&gt;ch&lt;/code&gt; collating element, then the RE &lt;code&gt;[[.ch.]]*c&lt;/code&gt; matches the first five characters of &lt;code&gt;chchcc&lt;/code&gt;.</source>
          <target state="translated">在方括号表达式中，[中包含一个归类元素（一个字符，一个好像是一个字符而进行归类的多字符序列，或任一者的归类序列名称） &lt;code&gt;[.&lt;/code&gt; 和 &lt;code&gt;.]&lt;/code&gt; 代表该整理元素的字符序列。该序列被视为方括号表达式列表的单个元素。这允许包含多字符归类元素的方括号表达式匹配多个字符，例如，如果归类序列包含 &lt;code&gt;ch&lt;/code&gt; 归类元素，则RE &lt;code&gt;[[.ch.]]*c&lt;/code&gt; 匹配 &lt;code&gt;chchcc&lt;/code&gt; 的前五个字符。</target>
        </trans-unit>
        <trans-unit id="5e1fe750b2061555e551fa7ddfd0d60d1ac81517" translate="yes" xml:space="preserve">
          <source>Within a bracket expression, a collating element enclosed in &lt;code&gt;[=&lt;/code&gt; and &lt;code&gt;=]&lt;/code&gt; is an &lt;em&gt;equivalence class&lt;/em&gt;, standing for the sequences of characters of all collating elements equivalent to that one, including itself. (If there are no other equivalent collating elements, the treatment is as if the enclosing delimiters were &lt;code&gt;[.&lt;/code&gt; and &lt;code&gt;.]&lt;/code&gt;.) For example, if &lt;code&gt;o&lt;/code&gt; and &lt;code&gt;^&lt;/code&gt; are the members of an equivalence class, then &lt;code&gt;[[=o=]]&lt;/code&gt;, &lt;code&gt;[[=^=]]&lt;/code&gt;, and &lt;code&gt;[o^]&lt;/code&gt; are all synonymous. An equivalence class cannot be an endpoint of a range.</source>
          <target state="translated">在方括号表达式中，包含在 &lt;code&gt;[=&lt;/code&gt; 和 &lt;code&gt;=]&lt;/code&gt; 中的&lt;em&gt;归类&lt;/em&gt;元素是一个&lt;em&gt;等效类&lt;/em&gt;，代表与该&lt;em&gt;归类&lt;/em&gt;元素等效的所有归类元素的字符序列，包括其自身。 （如果没有其他等效的整理元素，则将其视为 &lt;code&gt;[.&lt;/code&gt; 和 &lt;code&gt;.]&lt;/code&gt; 。）例如，如果 &lt;code&gt;o&lt;/code&gt; 和 &lt;code&gt;^&lt;/code&gt; 是等价类的成员，则 &lt;code&gt;[[=o=]]&lt;/code&gt; ， &lt;code&gt;[[=^=]]&lt;/code&gt; 和 &lt;code&gt;[o^]&lt;/code&gt; 都是同义词。等价类不能是范围的终结点。</target>
        </trans-unit>
        <trans-unit id="abb82d076f25a7be9aee0f56365d178b74a1a2ff" translate="yes" xml:space="preserve">
          <source>Within a bracket expression, the name of a character class enclosed in &lt;code&gt;[:&lt;/code&gt; and &lt;code&gt;:]&lt;/code&gt; stands for the list of all characters belonging to that class. A character class cannot be used as an endpoint of a range. The POSIX standard defines these character class names: &lt;code&gt;alnum&lt;/code&gt; (letters and numeric digits), &lt;code&gt;alpha&lt;/code&gt; (letters), &lt;code&gt;blank&lt;/code&gt; (space and tab), &lt;code&gt;cntrl&lt;/code&gt; (control characters), &lt;code&gt;digit&lt;/code&gt; (numeric digits), &lt;code&gt;graph&lt;/code&gt; (printable characters except space), &lt;code&gt;lower&lt;/code&gt; (lower-case letters), &lt;code&gt;print&lt;/code&gt; (printable characters including space), &lt;code&gt;punct&lt;/code&gt; (punctuation), &lt;code&gt;space&lt;/code&gt; (any white space), &lt;code&gt;upper&lt;/code&gt; (upper-case letters), and &lt;code&gt;xdigit&lt;/code&gt; (hexadecimal digits). The behavior of these standard character classes is generally consistent across platforms for characters in the 7-bit ASCII set. Whether a given non-ASCII character is considered to belong to one of these classes depends on the &lt;em&gt;collation&lt;/em&gt; that is used for the regular-expression function or operator (see &lt;a href=&quot;collation&quot;&gt;Section 23.2&lt;/a&gt;), or by default on the database's &lt;code&gt;LC_CTYPE&lt;/code&gt; locale setting (see &lt;a href=&quot;locale&quot;&gt;Section 23.1&lt;/a&gt;). The classification of non-ASCII characters can vary across platforms even in similarly-named locales. (But the &lt;code&gt;C&lt;/code&gt; locale never considers any non-ASCII characters to belong to any of these classes.) In addition to these standard character classes, PostgreSQL defines the &lt;code&gt;ascii&lt;/code&gt; character class, which contains exactly the 7-bit ASCII set.</source>
          <target state="translated">在方括号表达式中，用 &lt;code&gt;[:&lt;/code&gt; 和 &lt;code&gt;:]&lt;/code&gt; 括起来的字符类的名称代表该类所有字符的列表。字符类不能用作范围的端点。 POSIX标准定义了以下字符类名称： &lt;code&gt;alnum&lt;/code&gt; （字母和数字）， &lt;code&gt;alpha&lt;/code&gt; （字母）， &lt;code&gt;blank&lt;/code&gt; （空格和制表符）， &lt;code&gt;cntrl&lt;/code&gt; （控制字符）， &lt;code&gt;digit&lt;/code&gt; （数字）， &lt;code&gt;graph&lt;/code&gt; （空格以外的可打印字符）， &lt;code&gt;lower&lt;/code&gt; （小写字母）， &lt;code&gt;print&lt;/code&gt; （可打印的字符，包括空格）， &lt;code&gt;punct&lt;/code&gt; （标点符号）， &lt;code&gt;space&lt;/code&gt; （任何空格）， &lt;code&gt;upper&lt;/code&gt; （大写字母）和 &lt;code&gt;xdigit&lt;/code&gt; （十六进制数字）。这些标准字符类的行为通常在7位ASCII集字符跨平台上是一致的。给定的非ASCII字符是否被视为属于这些类之一，取决于用于正则表达式函数或运算符的&lt;em&gt;排序&lt;/em&gt;规则（请参阅&lt;a href=&quot;collation&quot;&gt;第23.2节&lt;/a&gt;），或者默认情况下取决于数据库的 &lt;code&gt;LC_CTYPE&lt;/code&gt; 语言环境设置（请参阅&lt;a href=&quot;locale&quot;&gt;第23.1节）。&lt;/a&gt;）。即使在名称相似的语言环境中，非ASCII字符的分类也会因平台而异。 （但 &lt;code&gt;C&lt;/code&gt; 语言环境从不认为任何非ASCII字符属于这些类中的任何一个。）除了这些标准字符类之外，PostgreSQL还定义了 &lt;code&gt;ascii&lt;/code&gt; 字符类，该类恰好包含7位ASCII集。</target>
        </trans-unit>
        <trans-unit id="d35bef27a0203dd6547cf96a8cb6d957c5595d5c" translate="yes" xml:space="preserve">
          <source>Within a pattern, &lt;code&gt;*&lt;/code&gt; matches any sequence of characters (including no characters) and &lt;code&gt;?&lt;/code&gt; matches any single character. (This notation is comparable to Unix shell file name patterns.) For example, &lt;code&gt;\dt int*&lt;/code&gt; displays tables whose names begin with &lt;code&gt;int&lt;/code&gt;. But within double quotes, &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt; lose these special meanings and are just matched literally.</source>
          <target state="translated">在模式中， &lt;code&gt;*&lt;/code&gt; 匹配任何字符序列（包括无字符）和 &lt;code&gt;?&lt;/code&gt; 匹配任何单个字符。（此表示法可与Unix Shell文件名模式相提并论。）例如， &lt;code&gt;\dt int*&lt;/code&gt; 显示名称以 &lt;code&gt;int&lt;/code&gt; 开头的表。但是在双引号内， &lt;code&gt;*&lt;/code&gt; 和 &lt;code&gt;?&lt;/code&gt; 失去了这些特殊含义，只是在字面上匹配。</target>
        </trans-unit>
        <trans-unit id="323b9b12ce6cec030c2782c77172b386cffa6487" translate="yes" xml:space="preserve">
          <source>Within an argument, text that is enclosed in backquotes (&lt;code&gt;`&lt;/code&gt;) is taken as a command line that is passed to the shell. The output of the command (with any trailing newline removed) replaces the backquoted text. Within the text enclosed in backquotes, no special quoting or other processing occurs, except that appearances of &lt;code&gt;:variable_name&lt;/code&gt; where &lt;code&gt;variable_name&lt;/code&gt; is a psql variable name are replaced by the variable's value. Also, appearances of &lt;code&gt;:'variable_name'&lt;/code&gt; are replaced by the variable's value suitably quoted to become a single shell command argument. (The latter form is almost always preferable, unless you are very sure of what is in the variable.) Because carriage return and line feed characters cannot be safely quoted on all platforms, the &lt;code&gt;:'variable_name'&lt;/code&gt; form prints an error message and does not substitute the variable value when such characters appear in the value.</source>
          <target state="translated">在自变量内，用引号（ &lt;code&gt;`&lt;/code&gt; ）引起来的文本将作为传递给shell的命令行使用。命令的输出（删除了所有尾随的换行符）将替换反引号引起的文本。在反引号内的文本内，不会进行特殊的引号或其他处理，除了 &lt;code&gt;:variable_name&lt;/code&gt; 的出现（其中 &lt;code&gt;variable_name&lt;/code&gt; 是psql变量名称）被变量的值替换。另外，出现的是 &lt;code&gt;:'variable_name'&lt;/code&gt; 被适当引用的变量值替换为单个shell命令参数。 （后一种形式几乎总是可取的，除非您非常确定变量中包含什么。）因为不能在所有平台上安全地引用回车符和换行符，所以 &lt;code&gt;:'variable_name'&lt;/code&gt; 形式会打印错误消息，但不会当此类字符出现在值中时，请替换该变量值。</target>
        </trans-unit>
        <trans-unit id="02446a7929ab10f300f87f18642a172ae6a7fbfe" translate="yes" xml:space="preserve">
          <source>Within any particular database, only collations that use that database's encoding are of interest. Other entries in &lt;code&gt;pg_collation&lt;/code&gt; are ignored. Thus, a stripped collation name such as &lt;code&gt;de_DE&lt;/code&gt; can be considered unique within a given database even though it would not be unique globally. Use of the stripped collation names is recommended, since it will make one less thing you need to change if you decide to change to another database encoding. Note however that the &lt;code&gt;default&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, and &lt;code&gt;POSIX&lt;/code&gt; collations can be used regardless of the database encoding.</source>
          <target state="translated">在任何特定数据库中，只有使用该数据库编码的归类才有意义。 &lt;code&gt;pg_collation&lt;/code&gt; 中的其他条目将被忽略。因此，剥离的归类名称（例如 &lt;code&gt;de_DE&lt;/code&gt; )在给定数据库中可以被认为是唯一的，即使它在全局范围内不是唯一的。建议使用剥离的排序规则名称，因为如果您决定更改为另一种数据库编码，则将减少您需要更改的内容。但是请注意，无论数据库编码如何，都可以使用 &lt;code&gt;default&lt;/code&gt; ， &lt;code&gt;C&lt;/code&gt; 和 &lt;code&gt;POSIX&lt;/code&gt; 归类。</target>
        </trans-unit>
        <trans-unit id="4a80b578691f1b5a7af0065fe86a5cb4aa2ce86a" translate="yes" xml:space="preserve">
          <source>Within bracket expressions, &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt;, and &lt;code&gt;\w&lt;/code&gt; lose their outer brackets, and &lt;code&gt;\D&lt;/code&gt;, &lt;code&gt;\S&lt;/code&gt;, and &lt;code&gt;\W&lt;/code&gt; are illegal. (So, for example, &lt;code&gt;[a-c\d]&lt;/code&gt; is equivalent to &lt;code&gt;[a-c[:digit:]]&lt;/code&gt;. Also, &lt;code&gt;[a-c\D]&lt;/code&gt;, which is equivalent to &lt;code&gt;[a-c^[:digit:]]&lt;/code&gt;, is illegal.)</source>
          <target state="translated">在括号表达式中， &lt;code&gt;\d&lt;/code&gt; ， &lt;code&gt;\s&lt;/code&gt; 和 &lt;code&gt;\w&lt;/code&gt; 失去了右括号，并且 &lt;code&gt;\D&lt;/code&gt; ， &lt;code&gt;\S&lt;/code&gt; 和 &lt;code&gt;\W&lt;/code&gt; 是非法的。 （因此，例如 &lt;code&gt;[a-c\d]&lt;/code&gt; 等效于 &lt;code&gt;[a-c[:digit:]]&lt;/code&gt; 。此外， &lt;code&gt;[a-c\D]&lt;/code&gt; 等效于 &lt;code&gt;[a-c^[:digit:]]&lt;/code&gt; 是非法的。）</target>
        </trans-unit>
        <trans-unit id="2542957abf2f09b64545fb48b800de1036c8c62f" translate="yes" xml:space="preserve">
          <source>Within each FSM page is a binary tree, stored in an array with one byte per node. Each leaf node represents a heap page, or a lower level FSM page. In each non-leaf node, the higher of its children's values is stored. The maximum value in the leaf nodes is therefore stored at the root.</source>
          <target state="translated">在每个FSM页面内是一个二进制树,存储在一个数组中,每个节点一个字节。每个叶子节点代表一个堆页,或一个较低级别的FSM页。在每个非叶子节点中,存储的是其子节点中较高的值。因此,叶子节点中的最大值存储在根节点。</target>
        </trans-unit>
        <trans-unit id="eb8d6e1ae92682e55948b9d998dc41d07bd4d9ee" translate="yes" xml:space="preserve">
          <source>Within each catalog row, write comma-separated &lt;code&gt;key&lt;/code&gt;&lt;code&gt;=&amp;gt;&lt;/code&gt;&lt;code&gt;value&lt;/code&gt; pairs. The allowed &lt;code&gt;key&lt;/code&gt;s are the names of the catalog's columns, plus the metadata keys &lt;code&gt;oid&lt;/code&gt;, &lt;code&gt;oid_symbol&lt;/code&gt;, &lt;code&gt;array_type_oid&lt;/code&gt;, and &lt;code&gt;descr&lt;/code&gt;. (The use of &lt;code&gt;oid&lt;/code&gt; and &lt;code&gt;oid_symbol&lt;/code&gt; is described in &lt;a href=&quot;system-catalog-initial-data#SYSTEM-CATALOG-OID-ASSIGNMENT&quot;&gt;Section 69.2.2&lt;/a&gt; below, while &lt;code&gt;array_type_oid&lt;/code&gt; is described in &lt;a href=&quot;system-catalog-initial-data#SYSTEM-CATALOG-AUTO-ARRAY-TYPES&quot;&gt;Section 69.2.4&lt;/a&gt;. &lt;code&gt;descr&lt;/code&gt; supplies a description string for the object, which will be inserted into &lt;code&gt;pg_description&lt;/code&gt; or &lt;code&gt;pg_shdescription&lt;/code&gt; as appropriate.) While the metadata keys are optional, the catalog's defined columns must all be provided, except when the catalog's &lt;code&gt;.h&lt;/code&gt; file specifies a default value for the column. (In the example above, the &lt;code&gt;datdba&lt;/code&gt; field has been omitted because &lt;code&gt;pg_database.h&lt;/code&gt; supplies a suitable default value for it.)</source>
          <target state="translated">在每个目录行中，编写逗号分隔的 &lt;code&gt;key&lt;/code&gt; &lt;code&gt;=&amp;gt;&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; 对。允许的 &lt;code&gt;key&lt;/code&gt; s是目录列的名称，再加 &lt;code&gt;oid_symbol&lt;/code&gt; 数据键 &lt;code&gt;oid&lt;/code&gt; ，oid_symbol， &lt;code&gt;array_type_oid&lt;/code&gt; 和 &lt;code&gt;descr&lt;/code&gt; 。 （利用的 &lt;code&gt;oid&lt;/code&gt; 和 &lt;code&gt;oid_symbol&lt;/code&gt; 被描述在&lt;a href=&quot;system-catalog-initial-data#SYSTEM-CATALOG-OID-ASSIGNMENT&quot;&gt;第69.2.2&lt;/a&gt;下面，而 &lt;code&gt;array_type_oid&lt;/code&gt; 被描述在&lt;a href=&quot;system-catalog-initial-data#SYSTEM-CATALOG-AUTO-ARRAY-TYPES&quot;&gt;章节69.2.4&lt;/a&gt;。 &lt;code&gt;descr&lt;/code&gt; 用品描述字符串对象，该对象将被插入到 &lt;code&gt;pg_description&lt;/code&gt; 或 &lt;code&gt;pg_shdescription&lt;/code&gt; 元数据键是可选的，但目录的已定义列必须全部提供，除非目录的 &lt;code&gt;.h&lt;/code&gt; 文件为该列指定默认值。（在上面的示例中，由于 &lt;code&gt;pg_database.h&lt;/code&gt; 为此提供了合适的默认值，因此省略了 &lt;code&gt;datdba&lt;/code&gt; 字段。）</target>
        </trans-unit>
        <trans-unit id="3b70f85093aa93c4bd37783889d55ab04e575f61" translate="yes" xml:space="preserve">
          <source>Within each pair of curly braces, the metadata fields &lt;code&gt;oid&lt;/code&gt;, &lt;code&gt;oid_symbol&lt;/code&gt;, &lt;code&gt;array_type_oid&lt;/code&gt;, and &lt;code&gt;descr&lt;/code&gt; (if present) come first, in that order, then the catalog's own fields appear in their defined order.</source>
          <target state="translated">在每对花括号中，元数据字段 &lt;code&gt;oid&lt;/code&gt; ， &lt;code&gt;oid_symbol&lt;/code&gt; ， &lt;code&gt;array_type_oid&lt;/code&gt; 和 &lt;code&gt;descr&lt;/code&gt; （如果存在）按此顺序排在最前面，然后目录的自身字段按其定义的顺序显示。</target>
        </trans-unit>
        <trans-unit id="7877c1484b515b178eb13d5365bc7aee43c3498f" translate="yes" xml:space="preserve">
          <source>Within larger commands, &lt;code&gt;VALUES&lt;/code&gt; is syntactically allowed anywhere that &lt;code&gt;SELECT&lt;/code&gt; is. Because it is treated like a &lt;code&gt;SELECT&lt;/code&gt; by the grammar, it is possible to use the &lt;code&gt;ORDER BY&lt;/code&gt;, &lt;code&gt;LIMIT&lt;/code&gt; (or equivalently &lt;code&gt;FETCH FIRST&lt;/code&gt;), and &lt;code&gt;OFFSET&lt;/code&gt; clauses with a &lt;code&gt;VALUES&lt;/code&gt; command.</source>
          <target state="translated">在较大的命令中，语法上允许 &lt;code&gt;SELECT&lt;/code&gt; 所在的任何位置使用 &lt;code&gt;VALUES&lt;/code&gt; 。由于语法将其视为 &lt;code&gt;SELECT&lt;/code&gt; ，因此可以将 &lt;code&gt;VALUES&lt;/code&gt; 命令与 &lt;code&gt;ORDER BY&lt;/code&gt; ， &lt;code&gt;LIMIT&lt;/code&gt; （或等效的 &lt;code&gt;FETCH FIRST&lt;/code&gt; ）和 &lt;code&gt;OFFSET&lt;/code&gt; 子句一起使用。</target>
        </trans-unit>
        <trans-unit id="85b2c20b975865db54e88c092240735063656bf9" translate="yes" xml:space="preserve">
          <source>Without a &lt;code&gt;table_and_columns&lt;/code&gt; list, &lt;code&gt;ANALYZE&lt;/code&gt; processes every table and materialized view in the current database that the current user has permission to analyze. With a list, &lt;code&gt;ANALYZE&lt;/code&gt; processes only those table(s). It is further possible to give a list of column names for a table, in which case only the statistics for those columns are collected.</source>
          <target state="translated">没有 &lt;code&gt;table_and_columns&lt;/code&gt; 列表， &lt;code&gt;ANALYZE&lt;/code&gt; 将处理当前用户有权分析的当前数据库中的每个表和实例化视图。对于列表， &lt;code&gt;ANALYZE&lt;/code&gt; 仅处理那些表。还可以给出表的列名列表，在这种情况下，仅收集这些列的统计信息。</target>
        </trans-unit>
        <trans-unit id="0bd2342b55fa6fe36f0fd7dea1e8abcfbe35286d" translate="yes" xml:space="preserve">
          <source>Without a &lt;code&gt;table_and_columns&lt;/code&gt; list, &lt;code&gt;VACUUM&lt;/code&gt; processes every table and materialized view in the current database that the current user has permission to vacuum. With a list, &lt;code&gt;VACUUM&lt;/code&gt; processes only those table(s).</source>
          <target state="translated">如果没有 &lt;code&gt;table_and_columns&lt;/code&gt; 列表， &lt;code&gt;VACUUM&lt;/code&gt; 将处理当前用户有权进行清理的当前数据库中的每个表和实例化视图。有了列表， &lt;code&gt;VACUUM&lt;/code&gt; 仅处理那些表。</target>
        </trans-unit>
        <trans-unit id="2564642da39c57e6f0da0af32cec7b221b00e6cf" translate="yes" xml:space="preserve">
          <source>Without a qualification, &lt;code&gt;DELETE&lt;/code&gt; will remove &lt;em&gt;all&lt;/em&gt; rows from the given table, leaving it empty. The system will not request confirmation before doing this!</source>
          <target state="translated">如果没有限定条件， &lt;code&gt;DELETE&lt;/code&gt; 将删除给定表中的&lt;em&gt;所有&lt;/em&gt;行，并将其保留为空。系统将不会在此之前请求确认！</target>
        </trans-unit>
        <trans-unit id="63fcdcc5d8356bd3ccce31a7a0f56d4a3af85303" translate="yes" xml:space="preserve">
          <source>Without functional-dependency statistics, the planner would assume that the two &lt;code&gt;WHERE&lt;/code&gt; conditions are independent, and would multiply their selectivities together to arrive at a much-too-small row count estimate. With such statistics, the planner recognizes that the &lt;code&gt;WHERE&lt;/code&gt; conditions are redundant and does not underestimate the row count.</source>
          <target state="translated">如果没有功能相关性统计信息，那么计划者将假定这两个 &lt;code&gt;WHERE&lt;/code&gt; 条件是独立的，并将它们的选择性相乘在一起，得出的行数估计值太小。借助此类统计信息，计划人员可以识别 &lt;code&gt;WHERE&lt;/code&gt; 条件是多余的，并且不会低估行数。</target>
        </trans-unit>
        <trans-unit id="dc783547ace7f2e9e22e7b50a67f3d97784d6474" translate="yes" xml:space="preserve">
          <source>Without partition pruning, the above query would scan each of the partitions of the &lt;code&gt;measurement&lt;/code&gt; table. With partition pruning enabled, the planner will examine the definition of each partition and prove that the partition need not be scanned because it could not contain any rows meeting the query's &lt;code&gt;WHERE&lt;/code&gt; clause. When the planner can prove this, it excludes (&lt;em&gt;prunes&lt;/em&gt;) the partition from the query plan.</source>
          <target state="translated">如果不进行分区修剪，则上面的查询将扫描 &lt;code&gt;measurement&lt;/code&gt; 表的每个分区。启用分区修剪后，计划人员将检查每个分区的定义并证明不需要扫描该分区，因为该分区不能包含满足查询的 &lt;code&gt;WHERE&lt;/code&gt; 子句的任何行。当计划者可以证明这一点时，它将从查询计划中排除（&lt;em&gt;修剪&lt;/em&gt;）分区。</target>
        </trans-unit>
        <trans-unit id="23034486b72d6e700160ee9f0facdf636985eee4" translate="yes" xml:space="preserve">
          <source>Without quotes, &lt;code&gt;to_tsquery&lt;/code&gt; will generate a syntax error for tokens that are not separated by an AND, OR, or FOLLOWED BY operator.</source>
          <target state="translated">如果不带引号，则 &lt;code&gt;to_tsquery&lt;/code&gt; 将为未由AND，OR或FOLLOWED BY运算符分隔的令牌生成语法错误。</target>
        </trans-unit>
        <trans-unit id="8d1c012acaa571247fa7393ff98695c754cfacba" translate="yes" xml:space="preserve">
          <source>Without the extra parentheses, this will generate a syntax error.</source>
          <target state="translated">如果没有额外的括号,这将产生一个语法错误。</target>
        </trans-unit>
        <trans-unit id="3003268a98f289ec381313920f30367739bc175f" translate="yes" xml:space="preserve">
          <source>Without the third rule, it is possible for an index reader to see an index entry just before it is removed by &lt;code&gt;VACUUM&lt;/code&gt;, and then to arrive at the corresponding heap entry after that was removed by &lt;code&gt;VACUUM&lt;/code&gt;. This creates no serious problems if that item number is still unused when the reader reaches it, since an empty item slot will be ignored by &lt;code&gt;heap_fetch()&lt;/code&gt;. But what if a third backend has already re-used the item slot for something else? When using an MVCC-compliant snapshot, there is no problem because the new occupant of the slot is certain to be too new to pass the snapshot test. However, with a non-MVCC-compliant snapshot (such as &lt;code&gt;SnapshotAny&lt;/code&gt;), it would be possible to accept and return a row that does not in fact match the scan keys. We could defend against this scenario by requiring the scan keys to be rechecked against the heap row in all cases, but that is too expensive. Instead, we use a pin on an index page as a proxy to indicate that the reader might still be &amp;ldquo;in flight&amp;rdquo; from the index entry to the matching heap entry. Making &lt;code&gt;ambulkdelete&lt;/code&gt; block on such a pin ensures that &lt;code&gt;VACUUM&lt;/code&gt; cannot delete the heap entry before the reader is done with it. This solution costs little in run time, and adds blocking overhead only in the rare cases where there actually is a conflict.</source>
          <target state="translated">如果没有第三条规则，它是可能的指数读者看到它被删除之前的索引条目 &lt;code&gt;VACUUM&lt;/code&gt; ，然后在相应的堆条目被删除之后抵达 &lt;code&gt;VACUUM&lt;/code&gt; 。如果在阅读器到达时仍未使用该物料号，则不会造成严重问题，因为一个空的物料槽将被 &lt;code&gt;heap_fetch()&lt;/code&gt; 忽略。但是，如果第三个后端已经将物品槽重新用于其他用途，该怎么办？使用兼容MVCC的快照时，没有问题，因为插槽的新占用者肯定太新而无法通过快照测试。但是，对于不符合MVCC的快照（例如 &lt;code&gt;SnapshotAny&lt;/code&gt; ），则有可能接受并返回实际上与扫描键不匹配的行。我们可以通过要求在所有情况下都针对堆行重新检查扫描键来防御这种情况，但这太昂贵了。相反，我们使用索引页上的图钉作为代理，以指示读取器可能仍在从索引条目到匹配堆条目的&amp;ldquo;飞行中&amp;rdquo;。在这样的引脚上制作 &lt;code&gt;ambulkdelete&lt;/code&gt; 块可确保 &lt;code&gt;VACUUM&lt;/code&gt; 在读取器完成之前无法删除堆条目。该解决方案的运行时间很少，并且仅在极少数情况下实际存在冲突时才增加阻塞开销。</target>
        </trans-unit>
        <trans-unit id="fdba0729d7141c4dc983525f28420a370b378b16" translate="yes" xml:space="preserve">
          <source>Without this clause, it is an error to specify an explicit value (other than &lt;code&gt;DEFAULT&lt;/code&gt;) for an identity column defined as &lt;code&gt;GENERATED ALWAYS&lt;/code&gt;. This clause overrides that restriction.</source>
          <target state="translated">如果没有此子句，则为定义为 &lt;code&gt;GENERATED ALWAYS&lt;/code&gt; 的标识列指定一个显式值（不是 &lt;code&gt;DEFAULT&lt;/code&gt; ）是错误的。本条款覆盖了该限制。</target>
        </trans-unit>
        <trans-unit id="77f4e928561a920783857c04bc4af1f2750cf7f5" translate="yes" xml:space="preserve">
          <source>Without this option, the backup will start by enumerating the size of the entire database, and then go back and send the actual contents. This may make the backup take slightly longer, and in particular it will take longer before the first data is sent. This option is useful to avoid such estimation time if it's too long.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5de5c631615b4050dbf3abcb11bda852949d1d49" translate="yes" xml:space="preserve">
          <source>Word, all ASCII letters</source>
          <target state="translated">字,所有ASCII字母</target>
        </trans-unit>
        <trans-unit id="cd638519c2bb50f94881c41d59edcf0f4b988187" translate="yes" xml:space="preserve">
          <source>Word, all letters</source>
          <target state="translated">单词,所有字母</target>
        </trans-unit>
        <trans-unit id="d929261f89fb5edc0a55361dccd5a42cfafc1e28" translate="yes" xml:space="preserve">
          <source>Word, letters and digits</source>
          <target state="translated">单词、字母和数字</target>
        </trans-unit>
        <trans-unit id="1c821c5f35490070199526bcafeccdc95331fb80" translate="yes" xml:space="preserve">
          <source>Work is still needed to improve the genetic algorithm parameter settings. In file &lt;code&gt;src/backend/optimizer/geqo/geqo_main.c&lt;/code&gt;, routines &lt;code&gt;gimme_pool_size&lt;/code&gt; and &lt;code&gt;gimme_number_generations&lt;/code&gt;, we have to find a compromise for the parameter settings to satisfy two competing demands:</source>
          <target state="translated">仍需要改进遗传算法参数设置的工作。在文件 &lt;code&gt;src/backend/optimizer/geqo/geqo_main.c&lt;/code&gt; 中，例程 &lt;code&gt;gimme_pool_size&lt;/code&gt; 和 &lt;code&gt;gimme_number_generations&lt;/code&gt; ，我们必须为参数设置找到一个折衷方案，以满足两个相互竞争的需求：</target>
        </trans-unit>
        <trans-unit id="3ae6871c604e1194dadbdf1baf868fa3278d7cc4" translate="yes" xml:space="preserve">
          <source>Write Ahead Log</source>
          <target state="translated">提前写日志</target>
        </trans-unit>
        <trans-unit id="3f9793b6786fb282a995505c49ca5c8dab4849b1" translate="yes" xml:space="preserve">
          <source>Write a message to the server log if checkpoints caused by the filling of WAL segment files happen closer together than this amount of time (which suggests that &lt;code&gt;max_wal_size&lt;/code&gt; ought to be raised). If this value is specified without units, it is taken as seconds. The default is 30 seconds (&lt;code&gt;30s&lt;/code&gt;). Zero disables the warning. No warnings will be generated if &lt;code&gt;checkpoint_timeout&lt;/code&gt; is less than &lt;code&gt;checkpoint_warning&lt;/code&gt;. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">如果由WAL段文件填充引起的检查点发生的时间比该时间 &lt;code&gt;max_wal_size&lt;/code&gt; 短（这表明应该提高max_wal_size），则将消息写入服务器日志。如果指定的该值不带单位，则以秒为单位。默认值为30秒（ &lt;code&gt;30s&lt;/code&gt; ）。零禁用警告。如果没有警告将产生 &lt;code&gt;checkpoint_timeout&lt;/code&gt; 小于 &lt;code&gt;checkpoint_warning&lt;/code&gt; 。此参数只能在 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件或服务器命令行中设置。</target>
        </trans-unit>
        <trans-unit id="79f29b256742ae32a7ee610c6c80dec55fe4bb44" translate="yes" xml:space="preserve">
          <source>Write all query output into file &lt;code&gt;filename&lt;/code&gt;, in addition to the normal output destination.</source>
          <target state="translated">除正常输出目标外，还将所有查询输出写入文件 &lt;code&gt;filename&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="ced9f94f9040a73c60549d122b831459c11a3fbf" translate="yes" xml:space="preserve">
          <source>Write information about each transaction to a log file. See below for details.</source>
          <target state="translated">将每次交易的信息写入日志文件。详情见下文。</target>
        </trans-unit>
        <trans-unit id="e33b6c1a70b5c50c6203011bb22d6394a5061934" translate="yes" xml:space="preserve">
          <source>Write received and decoded transaction data into this file. Use &lt;code&gt;-&lt;/code&gt; for stdout.</source>
          <target state="translated">将接收和解码的事务数据写入此文件。用途 &lt;code&gt;-&lt;/code&gt; 用于标准输出。</target>
        </trans-unit>
        <trans-unit id="660438e8219803d5c64d3c38fd0601dbee576ac1" translate="yes" xml:space="preserve">
          <source>Write the output as plain files, with the same layout as the current data directory and tablespaces. When the cluster has no additional tablespaces, the whole database will be placed in the target directory. If the cluster contains additional tablespaces, the main data directory will be placed in the target directory, but all other tablespaces will be placed in the same absolute path as they have on the server.</source>
          <target state="translated">将输出结果写成普通文件,布局与当前数据目录和表空间相同。当群集没有额外的表空间时,整个数据库将被放置在目标目录中。如果群集包含额外的表空间,主数据目录将被放置在目标目录中,但所有其他表空间将被放置在与服务器上相同的绝对路径中。</target>
        </trans-unit>
        <trans-unit id="6b1ff15d67ddd19c1531e3e1b72239d7b15119da" translate="yes" xml:space="preserve">
          <source>Write the output as plain files, with the same layout as the source server's data directory and tablespaces. When the cluster has no additional tablespaces, the whole database will be placed in the target directory. If the cluster contains additional tablespaces, the main data directory will be placed in the target directory, but all other tablespaces will be placed in the same absolute path as they have on the source server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbc92c3f4b6de8494f22f127e95dec8313f91169" translate="yes" xml:space="preserve">
          <source>Write the output as tar files in the target directory. The main data directory will be written to a file named &lt;code&gt;base.tar&lt;/code&gt;, and all other tablespaces will be named after the tablespace OID.</source>
          <target state="translated">将输出作为tar文件写入目标目录中。主数据目录将被写入名为 &lt;code&gt;base.tar&lt;/code&gt; 的文件，所有其他表空间将以表空间OID命名。</target>
        </trans-unit>
        <trans-unit id="a1016f820515616448d3af03f5c6cb584f20f3bd" translate="yes" xml:space="preserve">
          <source>Write the output as tar files in the target directory. The main data directory's contents will be written to a file named &lt;code&gt;base.tar&lt;/code&gt;, and each other tablespace will be written to a separate tar file named after that tablespace's OID.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12aba288e98df3f05ebad1cf7143b1a4df822af8" translate="yes" xml:space="preserve">
          <source>Write, or append to, a text file</source>
          <target state="translated">写入或附加到文本文件上</target>
        </trans-unit>
        <trans-unit id="73694598d4f6dd9ae50f65c44a8d5357103fbda0" translate="yes" xml:space="preserve">
          <source>Write-Ahead Log</source>
          <target state="translated">预写日志</target>
        </trans-unit>
        <trans-unit id="32219ea741aab08cd4b2cc75491ff92cd882b3c1" translate="yes" xml:space="preserve">
          <source>Write-Ahead Log Shipping</source>
          <target state="translated">预写日志运输</target>
        </trans-unit>
        <trans-unit id="bd375d03897609b092749de9e582ed65e566d377" translate="yes" xml:space="preserve">
          <source>Write-ahead log</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aab8077ca2cb9e3834b524a783525c97b082b885" translate="yes" xml:space="preserve">
          <source>Write-heavy workloads that don't benefit from deduplication due to having few or no duplicate values in indexes will incur a small, fixed performance penalty (unless deduplication is explicitly disabled). The &lt;code&gt;deduplicate_items&lt;/code&gt; storage parameter can be used to disable deduplication within individual indexes. There is never any performance penalty with read-only workloads, since reading posting list tuples is at least as efficient as reading the standard tuple representation. Disabling deduplication isn't usually helpful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="674bcf8c81a59458958b21d0660da76f6ba332b5" translate="yes" xml:space="preserve">
          <source>Writes the current query buffer to the file &lt;code&gt;filename&lt;/code&gt; or pipes it to the shell command &lt;code&gt;command&lt;/code&gt;. If the current query buffer is empty, the most recently executed query is written instead.</source>
          <target state="translated">将当前查询缓冲区写入文件 &lt;code&gt;filename&lt;/code&gt; 或通过管道传递给shell命令 &lt;code&gt;command&lt;/code&gt; 。如果当前查询缓冲区为空，则写入最近执行的查询。</target>
        </trans-unit>
        <trans-unit id="b84228914215a42dbe6fe7e926dad3ab9b4cf367" translate="yes" xml:space="preserve">
          <source>Writes the generated LLVM IR out to the file system, inside &lt;a href=&quot;runtime-config-file-locations#GUC-DATA-DIRECTORY&quot;&gt;data_directory&lt;/a&gt;. This is only useful for working on the internals of the JIT implementation. The default setting is &lt;code&gt;off&lt;/code&gt;. This parameter can only be changed by a superuser.</source>
          <target state="translated">将生成的LLVM IR写入&lt;a href=&quot;runtime-config-file-locations#GUC-DATA-DIRECTORY&quot;&gt;data_directory&lt;/a&gt;内部的文件系统。这仅对处理JIT实现的内部有用。默认设置为 &lt;code&gt;off&lt;/code&gt; 。该参数只能由超级用户更改。</target>
        </trans-unit>
        <trans-unit id="682768582621701d8f61b9c4bbc3b649ebde2e19" translate="yes" xml:space="preserve">
          <source>Writes, or appends to, a text file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5af6404c7f764d57f9d5c62315cdf9f310e1309" translate="yes" xml:space="preserve">
          <source>Writing &lt;code&gt;*&lt;/code&gt; is not necessary, since this behavior is always the default. However, this syntax is still supported for compatibility with older releases where the default could be changed.</source>
          <target state="translated">不必写 &lt;code&gt;*&lt;/code&gt; ，因为此行为始终是默认行为。但是，仍支持此语法，以便与可以更改默认值的较早版本兼容。</target>
        </trans-unit>
        <trans-unit id="6151e701c60f047c7b832b2686813d1310a12fca" translate="yes" xml:space="preserve">
          <source>Writing &lt;code&gt;ALL&lt;/code&gt; in place of a specific privilege grants all privileges that are relevant for the object type.</source>
          <target state="translated">写 &lt;code&gt;ALL&lt;/code&gt; 代替特定特权将授予与对象类型相关的所有特权。</target>
        </trans-unit>
        <trans-unit id="f43277b6f1b770dadde2ceed80f27334202f924f" translate="yes" xml:space="preserve">
          <source>Writing &lt;code&gt;SECURITY DEFINER&lt;/code&gt; Functions Safely</source>
          <target state="translated">安全地编写 &lt;code&gt;SECURITY DEFINER&lt;/code&gt; 函数</target>
        </trans-unit>
        <trans-unit id="ffbf328be37b139670f7ef37c6af175473c5c705" translate="yes" xml:space="preserve">
          <source>Writing a custom application, using one of the several available language bindings. These possibilities are discussed further in &lt;a href=&quot;https://www.postgresql.org/docs/12/client-interfaces.html&quot;&gt;Part IV&lt;/a&gt;.</source>
          <target state="translated">使用几种可用的语言绑定之一编写一个自定义应用程序。这些可能性将在&lt;a href=&quot;https://www.postgresql.org/docs/12/client-interfaces.html&quot;&gt;第四部分中&lt;/a&gt;进一步讨论。</target>
        </trans-unit>
        <trans-unit id="d2f9ec6d7e0edde20b9de31e1198d1816d564790" translate="yes" xml:space="preserve">
          <source>Writing a custom application, using one of the several available language bindings. These possibilities are discussed further in &lt;a href=&quot;https://www.postgresql.org/docs/13/client-interfaces.html&quot;&gt;Part IV&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de5165fc57d1f9a5e5c5994fec1932df3a128a9e" translate="yes" xml:space="preserve">
          <source>Writing the actual numeric value of any OID in C code is considered very bad form; always use a macro, instead. Direct references to &lt;code&gt;pg_proc&lt;/code&gt; OIDs are common enough that there's a special mechanism to create the necessary macros automatically; see &lt;code&gt;src/backend/utils/Gen_fmgrtab.pl&lt;/code&gt;. Similarly &amp;mdash; but, for historical reasons, not done the same way &amp;mdash; there's an automatic method for creating macros for &lt;code&gt;pg_type&lt;/code&gt; OIDs. &lt;code&gt;oid_symbol&lt;/code&gt; entries are therefore not necessary in those two catalogs. Likewise, macros for the &lt;code&gt;pg_class&lt;/code&gt; OIDs of system catalogs and indexes are set up automatically. For all other system catalogs, you have to manually specify any macros you need via &lt;code&gt;oid_symbol&lt;/code&gt; entries.</source>
          <target state="translated">用C代码写任何OID的实际数值被认为是非常糟糕的形式。始终使用宏代替。直接引用 &lt;code&gt;pg_proc&lt;/code&gt; OID很常见，以至于有一种特殊的机制可以自动创建必要的宏。参见 &lt;code&gt;src/backend/utils/Gen_fmgrtab.pl&lt;/code&gt; 。同样-但是，由于历史原因，操作方式 &lt;code&gt;pg_type&lt;/code&gt; 不同-有一种自动方法可以为pg_type OID 创建宏。因此，在这两个目录中不需要 &lt;code&gt;oid_symbol&lt;/code&gt; 条目。同样，系统会自动设置系统目录和索引的 &lt;code&gt;pg_class&lt;/code&gt; OID的宏。对于所有其他系统目录，您必须通过 &lt;code&gt;oid_symbol&lt;/code&gt; 条目手动指定所需的任何宏。</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="d5409f1461aa5b5298ee6d5c93002f7a27e50654" translate="yes" xml:space="preserve">
          <source>XID</source>
          <target state="translated">XID</target>
        </trans-unit>
        <trans-unit id="70fc167721857c5174dbbe545fe597100e840cd6" translate="yes" xml:space="preserve">
          <source>XID for VACUUM operation moving a row version</source>
          <target state="translated">用于VACUUM操作的XID移动行版本。</target>
        </trans-unit>
        <trans-unit id="c0aa9ef764d832b80428d756a731a94251b0e3a1" translate="yes" xml:space="preserve">
          <source>XML</source>
          <target state="translated">XML</target>
        </trans-unit>
        <trans-unit id="6dbc2e3a95bd424284a60fab71bfd99ecc6aa480" translate="yes" xml:space="preserve">
          <source>XML Functions</source>
          <target state="translated">XML函数</target>
        </trans-unit>
        <trans-unit id="677fbcd727fb96243fff280b768de17534da204d" translate="yes" xml:space="preserve">
          <source>XML Limits and Conformance to SQL/XML</source>
          <target state="translated">XML限制和与SQL/XML的一致性</target>
        </trans-unit>
        <trans-unit id="be1200e7280e074bb09cc29b489d7736fa9c3b13" translate="yes" xml:space="preserve">
          <source>XML Type</source>
          <target state="translated">XML类型</target>
        </trans-unit>
        <trans-unit id="72f6e6e18c4cf2cdf2736a3171665401b5f531b0" translate="yes" xml:space="preserve">
          <source>XML data</source>
          <target state="translated">XML数据</target>
        </trans-unit>
        <trans-unit id="9bc2b7976718250ab1463410139c7c00b0f2e7ce" translate="yes" xml:space="preserve">
          <source>XML declarations, if present, are combined as follows. If all argument values have the same XML version declaration, that version is used in the result, else no version is used. If all argument values have the standalone declaration value &amp;ldquo;yes&amp;rdquo;, then that value is used in the result. If all argument values have a standalone declaration value and at least one is &amp;ldquo;no&amp;rdquo;, then that is used in the result. Else the result will have no standalone declaration. If the result is determined to require a standalone declaration but no version declaration, a version declaration with version 1.0 will be used because XML requires an XML declaration to contain a version declaration. Encoding declarations are ignored and removed in all cases.</source>
          <target state="translated">XML声明（如果存在）按以下方式组合。如果所有参数值都具有相同的XML版本声明，则在结果中使用该版本，否则不使用任何版本。如果所有参数值都具有独立的声明值&amp;ldquo; yes&amp;rdquo;，则在结果中使用该值。如果所有参数值都有一个独立的声明值，并且至少一个为&amp;ldquo; no&amp;rdquo;，则在结果中使用该值。否则结果将没有独立的声明。如果确定结果需要独立声明但不要求版本声明，则将使用1.0版的版本声明，因为XML要求XML声明包含一个版本声明。在所有情况下，都会忽略并删除编码声明。</target>
        </trans-unit>
        <trans-unit id="93db77a518a3a65df06b8910ae3df05493323aa8" translate="yes" xml:space="preserve">
          <source>XML entity</source>
          <target state="translated">XML实体</target>
        </trans-unit>
        <trans-unit id="41d948a6e01de6c3d4845c4fb6a9cd77bb4a345f" translate="yes" xml:space="preserve">
          <source>XML format is left as an exercise for the reader.</source>
          <target state="translated">XML格式留给读者去练习。</target>
        </trans-unit>
        <trans-unit id="c648229e46576f92e57966e5bb6a169947ab07af" translate="yes" xml:space="preserve">
          <source>XML tag</source>
          <target state="translated">XML标签</target>
        </trans-unit>
        <trans-unit id="b7b6740d5d3d1f4067adb9c002cd0cc814ec4855" translate="yes" xml:space="preserve">
          <source>XML: IS DOCUMENT</source>
          <target state="translated">XML:IS DOCUMENT</target>
        </trans-unit>
        <trans-unit id="863fe78f50c66a6f7d93b18bf787a5d0aa670b5c" translate="yes" xml:space="preserve">
          <source>XML: IS NOT DOCUMENT</source>
          <target state="translated">XML:IS NOT DOCUMENT</target>
        </trans-unit>
        <trans-unit id="708b35917f64aea4aecf43902f9f6861b388f0a3" translate="yes" xml:space="preserve">
          <source>XML: XMLEXISTS</source>
          <target state="translated">XML:XMLEXISTS</target>
        </trans-unit>
        <trans-unit id="7aea648b2b4e07c316d48e040a2dfe07aea119ed" translate="yes" xml:space="preserve">
          <source>XML: xml_is_well_formed</source>
          <target state="translated">XML:xml_is_well_formed。</target>
        </trans-unit>
        <trans-unit id="3eca7373df1b8e0c5ed4c506c73dcc360d0c1000" translate="yes" xml:space="preserve">
          <source>XML: xmlagg</source>
          <target state="translated">XML:xmlagg</target>
        </trans-unit>
        <trans-unit id="31986b6f48c236780bb28b6f7a97cd2e7fe2fbbc" translate="yes" xml:space="preserve">
          <source>XML: xmlcomment</source>
          <target state="translated">XML:xmlcomment</target>
        </trans-unit>
        <trans-unit id="3336319324aa48adbaa76e0cbbf9934042dd41f7" translate="yes" xml:space="preserve">
          <source>XML: xmlconcat</source>
          <target state="translated">XML:xmlconcat</target>
        </trans-unit>
        <trans-unit id="c269b1860c6e177984dcd77f1f2f9180f500a7b1" translate="yes" xml:space="preserve">
          <source>XML: xmlelement</source>
          <target state="translated">XML:xmlelement</target>
        </trans-unit>
        <trans-unit id="f6f6cd60dad73c2efa2b22421846170fa537daf4" translate="yes" xml:space="preserve">
          <source>XML: xmlforest</source>
          <target state="translated">XML:xmlforest</target>
        </trans-unit>
        <trans-unit id="b4c3ab3b44e0a9d5e8cf4d618e5fb213a70446ae" translate="yes" xml:space="preserve">
          <source>XML: xmlpi</source>
          <target state="translated">XML:xmlpi</target>
        </trans-unit>
        <trans-unit id="2cb9abaad07f3be72c6b803b64719f6ad9373b8b" translate="yes" xml:space="preserve">
          <source>XML: xmlroot</source>
          <target state="translated">XML:xmlroot</target>
        </trans-unit>
        <trans-unit id="fe1c1afeea56eb4d61a6d5854b178d21b29bd194" translate="yes" xml:space="preserve">
          <source>XML: xmltable</source>
          <target state="translated">XML:xmltable</target>
        </trans-unit>
        <trans-unit id="943bcc21921946abacf747784b147601338c43bb" translate="yes" xml:space="preserve">
          <source>XML: xpath</source>
          <target state="translated">XML:xpath</target>
        </trans-unit>
        <trans-unit id="112eb0200c63c2f0de87632cdeab3a1c8a706831" translate="yes" xml:space="preserve">
          <source>XML: xpath_exists</source>
          <target state="translated">XML:xpath_exists</target>
        </trans-unit>
        <trans-unit id="a417f6430ccc4b644617c160b0d4f1b2c80cd5e2" translate="yes" xml:space="preserve">
          <source>XPath 1.0 blurs the distinction between &lt;em&gt;value comparisons&lt;/em&gt; and &lt;em&gt;general comparisons&lt;/em&gt; as XQuery/XPath define them. Both &lt;code&gt;sale/@hatsize = 7&lt;/code&gt; and &lt;code&gt;sale/@customer = &quot;alice&quot;&lt;/code&gt; are existentially quantified comparisons, true if there is any &lt;code&gt;sale&lt;/code&gt; with the given value for the attribute, but &lt;code&gt;sale/@taxable = false()&lt;/code&gt; is a value comparison to the &lt;em&gt;effective boolean value&lt;/em&gt; of a whole node-set. It is true only if no &lt;code&gt;sale&lt;/code&gt; has a &lt;code&gt;taxable&lt;/code&gt; attribute at all.</source>
          <target state="translated">当XQuery / XPath定义&lt;em&gt;值比较&lt;/em&gt;和&lt;em&gt;常规比较时&lt;/em&gt;，XPath 1.0模糊了它们之间的区别。这两个 &lt;code&gt;sale/@hatsize = 7&lt;/code&gt; 和 &lt;code&gt;sale/@customer = &quot;alice&quot;&lt;/code&gt; 的存在性量化的比较，真要是有任何 &lt;code&gt;sale&lt;/code&gt; 与该属性的给定值，但 &lt;code&gt;sale/@taxable = false()&lt;/code&gt; 是一个值相比，整个节点集的&lt;em&gt;有效布尔值&lt;/em&gt;。只有在没有它是真正的 &lt;code&gt;sale&lt;/code&gt; 有一个 &lt;code&gt;taxable&lt;/code&gt; 所有属性。</target>
        </trans-unit>
        <trans-unit id="f37617c0d5dc43deba6ebd523a1e7daa408818b2" translate="yes" xml:space="preserve">
          <source>XPath 1.0 does not specify an order for nodes in a node-set, so code that relies on a particular order of the results will be implementation-dependent. Details can be found in &lt;a href=&quot;xml-limits-conformance#XML-XPATH-1-SPECIFICS&quot;&gt;Section D.3.1.2&lt;/a&gt;.</source>
          <target state="translated">XPath 1.0没有为节点集中的节点指定顺序，因此依赖于结果特定顺序的代码将取决于实现。详细信息可以在&lt;a href=&quot;xml-limits-conformance#XML-XPATH-1-SPECIFICS&quot;&gt;D.3.1.2节中找到&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ccec9b819d48fea6e95ee65b1f2c2363e5212016" translate="yes" xml:space="preserve">
          <source>XPath 1.0 has no conditional operator. An XQuery/XPath expression such as &lt;code&gt;if ( hat ) then hat/@size else &quot;no hat&quot;&lt;/code&gt; has no XPath 1.0 equivalent.</source>
          <target state="translated">XPath 1.0没有条件运算符。XQuery / XPath表达式（例如 &lt;code&gt;if ( hat ) then hat/@size else &quot;no hat&quot;&lt;/code&gt; ）没有等效的XPath 1.0。</target>
        </trans-unit>
        <trans-unit id="575a5727a0aaf2dc929963572ab31f3a07d3b31b" translate="yes" xml:space="preserve">
          <source>XPath 1.0 has no ordering comparison operator for strings. Both &lt;code&gt;&quot;cat&quot; &amp;lt; &quot;dog&quot;&lt;/code&gt; and &lt;code&gt;&quot;cat&quot; &amp;gt; &quot;dog&quot;&lt;/code&gt; are false, because each is a numeric comparison of two &lt;code&gt;NaN&lt;/code&gt;s. In contrast, &lt;code&gt;=&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; do compare the strings as strings.</source>
          <target state="translated">XPath 1.0没有用于字符串的排序比较运算符。两个 &lt;code&gt;&quot;cat&quot; &amp;lt; &quot;dog&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;cat&quot; &amp;gt; &quot;dog&quot;&lt;/code&gt; 是假的，因为每一个是两个数值比较 &lt;code&gt;NaN&lt;/code&gt; 秒。相反， &lt;code&gt;=&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt; 会将字符串作为字符串进行比较。</target>
        </trans-unit>
        <trans-unit id="8c4149ee47a54aa2c037b2786d8549ef1627ad8e" translate="yes" xml:space="preserve">
          <source>XQuery allows declaration and use of local functions.</source>
          <target state="translated">XQuery允许声明和使用本地函数。</target>
        </trans-unit>
        <trans-unit id="818970bcffceb4be8cc185fddd03719babd24f42" translate="yes" xml:space="preserve">
          <source>XQuery character class elements using &lt;code&gt;\p{UnicodeProperty}&lt;/code&gt; or the inverse &lt;code&gt;\P{UnicodeProperty}&lt;/code&gt; are not supported.</source>
          <target state="translated">不支持使用 &lt;code&gt;\p{UnicodeProperty}&lt;/code&gt; 或反 &lt;code&gt;\P{UnicodeProperty}&lt;/code&gt; XQuery字符类元素。</target>
        </trans-unit>
        <trans-unit id="6f9675f91b1bee552c1436f5af897518b9d66036" translate="yes" xml:space="preserve">
          <source>XQuery character class shorthands &lt;code&gt;\c&lt;/code&gt;, &lt;code&gt;\C&lt;/code&gt;, &lt;code&gt;\i&lt;/code&gt;, and &lt;code&gt;\I&lt;/code&gt; are not supported.</source>
          <target state="translated">不支持XQuery字符类速记 &lt;code&gt;\c&lt;/code&gt; ， &lt;code&gt;\C&lt;/code&gt; ， &lt;code&gt;\i&lt;/code&gt; 和 &lt;code&gt;\I&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e05d40877e991191e09256daf83989a5f47e5557" translate="yes" xml:space="preserve">
          <source>XQuery character class subtraction is not supported. An example of this feature is using the following to match only English consonants: &lt;code&gt;[a-z-[aeiou]]&lt;/code&gt;.</source>
          <target state="translated">不支持XQuery字符类减法。此功能的一个示例是使用以下内容仅匹配英语辅音： &lt;code&gt;[a-z-[aeiou]]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7ba7fb2ffaaf928a3568f9854442e7071379dc9" translate="yes" xml:space="preserve">
          <source>XQuery does not have lookahead or lookbehind constraints, nor any of the constraint escapes described in &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-ESCAPES-TABLE&quot;&gt;Table 9.21&lt;/a&gt;.</source>
          <target state="translated">XQuery没有向前或向后约束，也没有&lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-ESCAPES-TABLE&quot;&gt;表9.21中&lt;/a&gt;描述的任何约束转义。</target>
        </trans-unit>
        <trans-unit id="fb9c8b3c7792b9cf1dc2ef58684f3e70a06da1d2" translate="yes" xml:space="preserve">
          <source>XQuery does not have lookahead or lookbehind constraints, nor any of the constraint escapes described in &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-ESCAPES-TABLE&quot;&gt;Table 9.22&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41577214ab7c5c54db475c958675a49fbb00b4a6" translate="yes" xml:space="preserve">
          <source>XQuery does not support the &lt;code&gt;[:name:]&lt;/code&gt; syntax for character classes within bracket expressions.</source>
          <target state="translated">XQuery不支持括号表达式内的字符类的 &lt;code&gt;[:name:]&lt;/code&gt; 语法。</target>
        </trans-unit>
        <trans-unit id="2e0c3c6ff5da1ba3d8311b799d1cf51c7385d7c2" translate="yes" xml:space="preserve">
          <source>XQuery expressions can construct and return new XML nodes, in addition to all possible XPath values. XPath can create and return values of the atomic types (numbers, strings, and so on) but can only return XML nodes that were already present in documents supplied as input to the expression.</source>
          <target state="translated">除了所有可能的XPath值之外,XQuery表达式还可以构造和返回新的XML节点。XPath可以创建和返回原子类型的值(数字、字符串等),但只能返回已经存在于作为表达式输入的文档中的XML节点。</target>
        </trans-unit>
        <trans-unit id="7d07dea26dd7592af4147bb1ae9d21c709ece2a7" translate="yes" xml:space="preserve">
          <source>XQuery has control constructs for iteration, sorting, and grouping.</source>
          <target state="translated">XQuery有迭代、排序和分组的控制构造。</target>
        </trans-unit>
        <trans-unit id="9add350a4eb532be8a2c9c9d393be8bd03cceb66" translate="yes" xml:space="preserve">
          <source>XQuery's &lt;code&gt;s&lt;/code&gt; (allow dot to match newline) and &lt;code&gt;m&lt;/code&gt; (allow &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; to match at newlines) flags provide access to the same behaviors as POSIX's &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;w&lt;/code&gt; flags, but they do &lt;em&gt;not&lt;/em&gt; match the behavior of POSIX's &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;m&lt;/code&gt; flags. Note in particular that dot-matches-newline is the default behavior in POSIX but not XQuery.</source>
          <target state="translated">XQuery的 &lt;code&gt;s&lt;/code&gt; （允许点匹配换行）和 &lt;code&gt;m&lt;/code&gt; （允许 &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;$&lt;/code&gt; 匹配换行）标志提供对与POSIX的 &lt;code&gt;n&lt;/code&gt; ， &lt;code&gt;p&lt;/code&gt; 和 &lt;code&gt;w&lt;/code&gt; 标志相同的行为的访问，但它们与POSIX的 &lt;code&gt;s&lt;/code&gt; 和 &lt;code&gt;m&lt;/code&gt; 标志的行为&lt;em&gt;不&lt;/em&gt;匹配。特别要注意的是，dot-matches-newline是POSIX中的默认行为，而不是XQuery。</target>
        </trans-unit>
        <trans-unit id="0fbdf61430816231b42e0b59499fabbec39b5ae3" translate="yes" xml:space="preserve">
          <source>XQuery's &lt;code&gt;x&lt;/code&gt; (ignore whitespace in pattern) flag is noticeably different from POSIX's expanded-mode flag. POSIX's &lt;code&gt;x&lt;/code&gt; flag also allows &lt;code&gt;#&lt;/code&gt; to begin a comment in the pattern, and POSIX will not ignore a whitespace character after a backslash.</source>
          <target state="translated">XQuery的 &lt;code&gt;x&lt;/code&gt; （忽略模式中的空白）标志与POSIX的扩展模式标志明显不同。POSIX的 &lt;code&gt;x&lt;/code&gt; 标志还允许 &lt;code&gt;#&lt;/code&gt; 在模式中开始注释，并且POSIX不会在反斜杠后忽略空格字符。</target>
        </trans-unit>
        <trans-unit id="23eb4d3f4155395a74e9d534f97ff4c1908f5aac" translate="yes" xml:space="preserve">
          <source>Y</source>
          <target state="translated">Y</target>
        </trans-unit>
        <trans-unit id="cb29757e458776404c0d0c4f5c75b0740d559b1c" translate="yes" xml:space="preserve">
          <source>Year and day of year: for example &lt;code&gt;to_date('2006-291', 'IYYY-IDDD')&lt;/code&gt; also returns &lt;code&gt;2006-10-19&lt;/code&gt;.</source>
          <target state="translated">每年的年份和日期：例如 &lt;code&gt;to_date('2006-291', 'IYYY-IDDD')&lt;/code&gt; 也会返回 &lt;code&gt;2006-10-19&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fc5a18c267810c3dc6c5d4fdd0b02c9e146fd0f1" translate="yes" xml:space="preserve">
          <source>Year, week number, and weekday: for example &lt;code&gt;to_date('2006-42-4', 'IYYY-IW-ID')&lt;/code&gt; returns the date &lt;code&gt;2006-10-19&lt;/code&gt;. If you omit the weekday it is assumed to be 1 (Monday).</source>
          <target state="translated">年，周号和工作日：例如 &lt;code&gt;to_date('2006-42-4', 'IYYY-IW-ID')&lt;/code&gt; 返回日期 &lt;code&gt;2006-10-19&lt;/code&gt; 。如果省略工作日，则假定为1（星期一）。</target>
        </trans-unit>
        <trans-unit id="7abdb2567a06fc713cd1d6b57e90f634441b367e" translate="yes" xml:space="preserve">
          <source>Year-Month Interval</source>
          <target state="translated">年-月间隔</target>
        </trans-unit>
        <trans-unit id="96f997bcecb36502ed4b296a795f72aff9d6bfe7" translate="yes" xml:space="preserve">
          <source>Years</source>
          <target state="translated">Years</target>
        </trans-unit>
        <trans-unit id="3cfd5c7e576642a9c9f3bbe4db929041cea0177f" translate="yes" xml:space="preserve">
          <source>Years in the 1900s are in the second millennium. The third millennium started January 1, 2001.</source>
          <target state="translated">1900年代的年份属于第二个千年。第三个千年从2001年1月1日开始。</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="6dd15150afde3fb668c9c37b5570c9f350a42483" translate="yes" xml:space="preserve">
          <source>You can (and, for most purposes, probably should) increase the number of rows by using the &lt;code&gt;-s&lt;/code&gt; (scale factor) option. The &lt;code&gt;-F&lt;/code&gt; (fillfactor) option might also be used at this point.</source>
          <target state="translated">您可以（并且，出于大多数目的，应该）通过使用 &lt;code&gt;-s&lt;/code&gt; （比例因子）选项来增加行数。此时，也可以使用 &lt;code&gt;-F&lt;/code&gt; （填充因子）选项。</target>
        </trans-unit>
        <trans-unit id="145c00d5953681c62f21c82b058caafeee2a8310" translate="yes" xml:space="preserve">
          <source>You can adapt this module to your needs by changing the source code. For example, you can use &lt;a href=&quot;https://sourceforge.net/projects/cracklib/&quot;&gt;CrackLib&lt;/a&gt; to check passwords &amp;mdash; this only requires uncommenting two lines in the &lt;code&gt;Makefile&lt;/code&gt; and rebuilding the module. (We cannot include CrackLib by default for license reasons.) Without CrackLib, the module enforces a few simple rules for password strength, which you can modify or extend as you see fit.</source>
          <target state="translated">您可以通过更改源代码使此模块适应您的需求。例如，您可以使用&lt;a href=&quot;https://sourceforge.net/projects/cracklib/&quot;&gt;CrackLib&lt;/a&gt;来检查密码-这仅需要在 &lt;code&gt;Makefile&lt;/code&gt; 中取消注释两行并重建模块。（出于许可原因，默认情况下，我们默认不包含CrackLib。）如果没有CrackLib，该模块将强制执行一些简单的密码强度规则，您可以根据需要修改或扩展它们。</target>
        </trans-unit>
        <trans-unit id="28dae3ce662983a3720ca411f5e625f764893bf1" translate="yes" xml:space="preserve">
          <source>You can add whitespace before a left brace or after a right brace. You can also add whitespace before or after any individual item string. In all of these cases the whitespace will be ignored. However, whitespace within double-quoted elements, or surrounded on both sides by non-whitespace characters of an element, is not ignored.</source>
          <target state="translated">您可以在左括号前或右括号后添加空白。您也可以在任何单个项目字符串之前或之后添加空格。在所有这些情况下,空格都会被忽略。但是,在双引号元素中的空白,或者在元素的两边被非空白字符包围的情况下,空白是不会被忽略的。</target>
        </trans-unit>
        <trans-unit id="569893ff6c39724a565a145b8a3ad3a0b9606463" translate="yes" xml:space="preserve">
          <source>You can adjust the ordering of a B-tree index by including the options &lt;code&gt;ASC&lt;/code&gt;, &lt;code&gt;DESC&lt;/code&gt;, &lt;code&gt;NULLS FIRST&lt;/code&gt;, and/or &lt;code&gt;NULLS LAST&lt;/code&gt; when creating the index; for example:</source>
          <target state="translated">您可以通过在创建索引时包括选项 &lt;code&gt;ASC&lt;/code&gt; ， &lt;code&gt;DESC&lt;/code&gt; ， &lt;code&gt;NULLS FIRST&lt;/code&gt; 和/或 &lt;code&gt;NULLS LAST&lt;/code&gt; 来调整B树索引的顺序。例如：</target>
        </trans-unit>
        <trans-unit id="4b7d9d02889a217be36bf8f71750c721f9d62b3a" translate="yes" xml:space="preserve">
          <source>You can also control the order in which rows are processed by window functions using &lt;code&gt;ORDER BY&lt;/code&gt; within &lt;code&gt;OVER&lt;/code&gt;. (The window &lt;code&gt;ORDER BY&lt;/code&gt; does not even have to match the order in which the rows are output.) Here is an example:</source>
          <target state="translated">还可以控制在这些行由利用窗口函数处理的顺序 &lt;code&gt;ORDER BY&lt;/code&gt; 内 &lt;code&gt;OVER&lt;/code&gt; 。（窗口 &lt;code&gt;ORDER BY&lt;/code&gt; 甚至不必匹配行的输出顺序。）这是一个示例：</target>
        </trans-unit>
        <trans-unit id="d8031e0a82c5477e58a31c17656bff548035b193" translate="yes" xml:space="preserve">
          <source>You can also create databases with other names. PostgreSQL allows you to create any number of databases at a given site. Database names must have an alphabetic first character and are limited to 63 bytes in length. A convenient choice is to create a database with the same name as your current user name. Many tools assume that database name as the default, so it can save you some typing. To create that database, simply type:</source>
          <target state="translated">你也可以用其他名字创建数据库。PostgreSQL允许你在一个给定的站点创建任意数量的数据库。数据库名称的第一个字符必须是英文字母,长度限制在63个字节以内。一个方便的选择是用与当前用户名相同的名称创建数据库。许多工具都假定该数据库名称为默认名称,因此可以为您节省一些输入。要创建该数据库,只需输入</target>
        </trans-unit>
        <trans-unit id="2855332ddeec7909c633615734e0f09916910215" translate="yes" xml:space="preserve">
          <source>You can also define constraints on the column at the same time, using the usual syntax:</source>
          <target state="translated">你也可以同时定义列的约束,使用通常的语法。</target>
        </trans-unit>
        <trans-unit id="ee1e40e96d3d99c788ff89c86039beb4c7ae5ad3" translate="yes" xml:space="preserve">
          <source>You can also force the insertion of invalid numbers even when not in the weak mode, by appending the &lt;code&gt;!&lt;/code&gt; character at the end of the number.</source>
          <target state="translated">您还可以通过添加 &lt;code&gt;!&lt;/code&gt; 来强制插入无效数字，即使不在弱模式下也是如此。数字末尾的字符。</target>
        </trans-unit>
        <trans-unit id="e92dd9f79aa93357545022991d035db8fa3c697a" translate="yes" xml:space="preserve">
          <source>You can also give the constraint a separate name. This clarifies error messages and allows you to refer to the constraint when you need to change it. The syntax is:</source>
          <target state="translated">您也可以给约束单独命名。这可以澄清错误信息,并允许您在需要更改约束时引用它。语法是</target>
        </trans-unit>
        <trans-unit id="5c0e733bb8f77339cb0554d27f0faf1999d777b7" translate="yes" xml:space="preserve">
          <source>You can also nest filter expressions within each other:</source>
          <target state="translated">你也可以将过滤器表达式相互嵌套。</target>
        </trans-unit>
        <trans-unit id="540c7cc55f43958519f25aa973c9e5a2c6dcb66b" translate="yes" xml:space="preserve">
          <source>You can also search an array using the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator, which checks whether the left operand overlaps with the right operand. For instance:</source>
          <target state="translated">您也可以使用 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 运算符搜索数组，该运算符检查左操作数是否与右操作数重叠。例如：</target>
        </trans-unit>
        <trans-unit id="7317ad78770ade20f7fc205d1692cc3871b32860" translate="yes" xml:space="preserve">
          <source>You can also search for specific values in an array using the &lt;code&gt;array_position&lt;/code&gt; and &lt;code&gt;array_positions&lt;/code&gt; functions. The former returns the subscript of the first occurrence of a value in an array; the latter returns an array with the subscripts of all occurrences of the value in the array. For example:</source>
          <target state="translated">您还可以使用 &lt;code&gt;array_position&lt;/code&gt; 和 &lt;code&gt;array_positions&lt;/code&gt; 函数在数组中搜索特定值。前者返回数组中第一次出现的值的下标；后者返回一个数组，其中包含该数组中所有出现的值的下标。例如：</target>
        </trans-unit>
        <trans-unit id="72011efb5669336e4615ad697b69c64d57f8e812" translate="yes" xml:space="preserve">
          <source>You can also shorten the above command to:</source>
          <target state="translated">你也可以将上述命令缩短为。</target>
        </trans-unit>
        <trans-unit id="362c18912cf35df18fb18daa4743d6a04f75f78b" translate="yes" xml:space="preserve">
          <source>You can also write &lt;code&gt;all&lt;/code&gt; to match any IP address, &lt;code&gt;samehost&lt;/code&gt; to match any of the server's own IP addresses, or &lt;code&gt;samenet&lt;/code&gt; to match any address in any subnet that the server is directly connected to.</source>
          <target state="translated">您还可以 &lt;code&gt;all&lt;/code&gt; 写入以匹配任何IP地址， &lt;code&gt;samehost&lt;/code&gt; 可以匹配服务器自己的IP地址，或者 &lt;code&gt;samenet&lt;/code&gt; 可以匹配服务器直接连接到的任何子网中的任何地址。</target>
        </trans-unit>
        <trans-unit id="81719f677a0ec0af21aab7f90315c40b111bfbd1" translate="yes" xml:space="preserve">
          <source>You can also write the table name with a trailing &lt;code&gt;*&lt;/code&gt; to explicitly specify that descendant tables are included:</source>
          <target state="translated">您还可以在表名后面加上 &lt;code&gt;*&lt;/code&gt; ,以明确指定包含后代表：</target>
        </trans-unit>
        <trans-unit id="5703517ac040c492127e1fb49e5ced3da0debc99" translate="yes" xml:space="preserve">
          <source>You can ask for all fields of a composite value by writing &lt;code&gt;.*&lt;/code&gt;:</source>
          <target state="translated">您可以通过编写 &lt;code&gt;.*&lt;/code&gt; 来请求复合值的所有字段：</target>
        </trans-unit>
        <trans-unit id="3fc07d5e0044a9e8829c097c35614fb4ad2ee919" translate="yes" xml:space="preserve">
          <source>You can assign your own name for a foreign key constraint, in the usual way.</source>
          <target state="translated">你可以用通常的方式为外键约束指定自己的名字。</target>
        </trans-unit>
        <trans-unit id="78537f8a74bec7b625797355864a6e8b33eb27d6" translate="yes" xml:space="preserve">
          <source>You can assign your own name for a unique constraint, in the usual way:</source>
          <target state="translated">你可以用通常的方式为一个唯一的约束指定自己的名字。</target>
        </trans-unit>
        <trans-unit id="2e4029bdb8227766d867d39118fde7beadbd5eab" translate="yes" xml:space="preserve">
          <source>You can avoid always having to write out a &lt;code&gt;FROM&lt;/code&gt; clause to define the output columns, by setting up a custom crosstab function that has the desired output row type wired into its definition. This is described in the next section. Another possibility is to embed the required &lt;code&gt;FROM&lt;/code&gt; clause in a view definition.</source>
          <target state="translated">您可以通过设置自定义交叉表函数来避免总是写出 &lt;code&gt;FROM&lt;/code&gt; 子句来定义输出列，该函数将所需的输出行类型连接到其定义中。下一节将对此进行描述。另一种可能性是在视图定义中嵌入所需的 &lt;code&gt;FROM&lt;/code&gt; 子句。</target>
        </trans-unit>
        <trans-unit id="91ab32b5c2f6769faecc52b84a69c2005aae2685" translate="yes" xml:space="preserve">
          <source>You can change default privileges only for objects that will be created by yourself or by roles that you are a member of. The privileges can be set globally (i.e., for all objects created in the current database), or just for objects created in specified schemas.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="564b000e3befed57b182cb04e1dbb1e1574bf5b5" translate="yes" xml:space="preserve">
          <source>You can change default privileges only for objects that will be created by yourself or by roles that you are a member of. The privileges can be set globally (i.e., for all objects created in the current database), or just for objects created in specified schemas. Default privileges that are specified per-schema are added to whatever the global default privileges are for the particular object type.</source>
          <target state="translated">您可以更改默认权限,只针对将由您自己或您是成员的角色创建的对象。权限可以全局设置(即为当前数据库中创建的所有对象),也可以只为指定模式中创建的对象设置。按模式指定的默认权限会被添加到特定对象类型的全局默认权限中。</target>
        </trans-unit>
        <trans-unit id="9ce7b82cbd1c40e5d5b3f5f38a6fd3d98a532714" translate="yes" xml:space="preserve">
          <source>You can combine these approaches by setting up logrotate to collect log files produced by PostgreSQL built-in logging collector. In this case, the logging collector defines the names and location of the log files, while logrotate periodically archives these files. When initiating log rotation, logrotate must ensure that the application sends further output to the new file. This is commonly done with a &lt;code&gt;postrotate&lt;/code&gt; script that sends a &lt;code&gt;SIGHUP&lt;/code&gt; signal to the application, which then reopens the log file. In PostgreSQL, you can run &lt;code&gt;pg_ctl&lt;/code&gt; with the &lt;code&gt;logrotate&lt;/code&gt; option instead. When the server receives this command, the server either switches to a new log file or reopens the existing file, depending on the logging configuration (see &lt;a href=&quot;runtime-config-logging#RUNTIME-CONFIG-LOGGING-WHERE&quot;&gt;Section 19.8.1&lt;/a&gt;).</source>
          <target state="translated">您可以通过设置logrotate来收集PostgreSQL内置日志收集器生成的日志文件，从而结合使用这些方法。在这种情况下，日志收集器将定义日志文件的名称和位置，而logrotate会定期存档这些文件。启动日志轮换时，logrotate必须确保应用程序将进一步的输出发送到新文件。通常使用后 &lt;code&gt;postrotate&lt;/code&gt; 脚本来完成此操作，该脚本将 &lt;code&gt;SIGHUP&lt;/code&gt; 信号发送到应用程序，然后重新打开日志文件。在PostgreSQL中，您可以使用 &lt;code&gt;logrotate&lt;/code&gt; 选项运行 &lt;code&gt;pg_ctl&lt;/code&gt; 。服务器收到此命令后，服务器将切换到新的日志文件或重新打开现有文件，具体取决于日志记录配置（请参阅&lt;a href=&quot;runtime-config-logging#RUNTIME-CONFIG-LOGGING-WHERE&quot;&gt;第19.8.1节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="5b0f94e4408c19791436a634fd6c150fbb5fd164" translate="yes" xml:space="preserve">
          <source>You can construct an empty array, but since it's impossible to have an array with no type, you must explicitly cast your empty array to the desired type. For example:</source>
          <target state="translated">你可以构造一个空数组,但是由于不可能有一个没有类型的数组,所以你必须显式地将你的空数组转换为所需的类型。比如说</target>
        </trans-unit>
        <trans-unit id="769ef112866ecb5c170f43630a2adb624d294a3a" translate="yes" xml:space="preserve">
          <source>You can convert an epoch value back to a time stamp with &lt;code&gt;to_timestamp&lt;/code&gt;:</source>
          <target state="translated">您可以使用 &lt;code&gt;to_timestamp&lt;/code&gt; 将纪元值转换回时间戳：</target>
        </trans-unit>
        <trans-unit id="6ea1e38b69360026f2565a2133b9cc41f674fbe6" translate="yes" xml:space="preserve">
          <source>You can create a new table by specifying the table name, along with all column names and their types:</source>
          <target state="translated">您可以通过指定表名以及所有列名和它们的类型来创建一个新表。</target>
        </trans-unit>
        <trans-unit id="2293b489a80bd69ba669dbf459fa76acfff7a213" translate="yes" xml:space="preserve">
          <source>You can create a replication slot like this:</source>
          <target state="translated">你可以像这样创建一个复制槽。</target>
        </trans-unit>
        <trans-unit id="e3025b62033e69c38fff841b12fa1dec6f73605a" translate="yes" xml:space="preserve">
          <source>You can create predefined functions to avoid having to write out the result column names and types in each query. See the examples in the previous section. The underlying C function for this form of &lt;code&gt;crosstab&lt;/code&gt; is named &lt;code&gt;crosstab_hash&lt;/code&gt;.</source>
          <target state="translated">您可以创建预定义函数，以避免在每个查询中写出结果列名称和类型。请参阅上一节中的示例。这种 &lt;code&gt;crosstab&lt;/code&gt; 形式的基础C函数名为 &lt;code&gt;crosstab_hash&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05fb579365a5f238d0a6df67c0b79ce59d0a29c6" translate="yes" xml:space="preserve">
          <source>You can create the illusion of an updatable view by defining &lt;code&gt;ON INSERT&lt;/code&gt;, &lt;code&gt;ON UPDATE&lt;/code&gt;, and &lt;code&gt;ON DELETE&lt;/code&gt; rules (or any subset of those that's sufficient for your purposes) to replace update actions on the view with appropriate updates on other tables. If you want to support &lt;code&gt;INSERT RETURNING&lt;/code&gt; and so on, then be sure to put a suitable &lt;code&gt;RETURNING&lt;/code&gt; clause into each of these rules.</source>
          <target state="translated">您可以通过定义 &lt;code&gt;ON INSERT&lt;/code&gt; ， &lt;code&gt;ON UPDATE&lt;/code&gt; 和 &lt;code&gt;ON DELETE&lt;/code&gt; 规则（或足以满足您目的的子集）来创建可更新视图的错觉，以用其他表上的适当更新替换视图上的更新操作。如果要支持 &lt;code&gt;INSERT RETURNING&lt;/code&gt; 等，请确保在每个规则中放入合适的 &lt;code&gt;RETURNING&lt;/code&gt; 子句。</target>
        </trans-unit>
        <trans-unit id="a0fd26f2da3bc0e528eb70dd91043a00be53f7e3" translate="yes" xml:space="preserve">
          <source>You can define a cast as an &lt;em&gt;I/O conversion cast&lt;/em&gt; by using the &lt;code&gt;WITH INOUT&lt;/code&gt; syntax. An I/O conversion cast is performed by invoking the output function of the source data type, and passing the resulting string to the input function of the target data type. In many common cases, this feature avoids the need to write a separate cast function for conversion. An I/O conversion cast acts the same as a regular function-based cast; only the implementation is different.</source>
          <target state="translated">您可以使用 &lt;code&gt;WITH INOUT&lt;/code&gt; 语法将&lt;em&gt;转换&lt;/em&gt;定义为&lt;em&gt;I / O转换转换&lt;/em&gt;。通过调用源数据类型的输出函数并将结果字符串传递给目标数据类型的输入函数来执行I / O转换转换。在许多常见情况下，此功能无需编写单独的强制转换函数即可进行转换。 I / O转换强制转换与基于函数的常规强制转换相同；只是实现不同。</target>
        </trans-unit>
        <trans-unit id="986b5339acb3c76e9d88ad629ad134c8af474edf" translate="yes" xml:space="preserve">
          <source>You can display tables in different ways by using the &lt;code&gt;\pset&lt;/code&gt; command:</source>
          <target state="translated">您可以使用 &lt;code&gt;\pset&lt;/code&gt; 命令以不同的方式显示表：</target>
        </trans-unit>
        <trans-unit id="16683852e12279f72c19abb8cc240108de7e38a2" translate="yes" xml:space="preserve">
          <source>You can do the same thing more verbosely with an explicitly named composite type:</source>
          <target state="translated">你可以用一个显式命名的复合类型来做同样的事情。</target>
        </trans-unit>
        <trans-unit id="647bf3e05906b80225fe1b4782288902652983a3" translate="yes" xml:space="preserve">
          <source>You can easily display index sizes, too:</source>
          <target state="translated">你也可以轻松地显示索引大小。</target>
        </trans-unit>
        <trans-unit id="a376faf67a062024c4f071a8c440875731b4314a" translate="yes" xml:space="preserve">
          <source>You can enter this into &lt;code&gt;psql&lt;/code&gt; with the line breaks. &lt;code&gt;psql&lt;/code&gt; will recognize that the command is not terminated until the semicolon.</source>
          <target state="translated">您可以使用换行符将其输入到 &lt;code&gt;psql&lt;/code&gt; 中。 &lt;code&gt;psql&lt;/code&gt; 将识别出直到分号才终止命令。</target>
        </trans-unit>
        <trans-unit id="b7e2b6740f842ed6fc3ff802c0860722cdf6db76" translate="yes" xml:space="preserve">
          <source>You can even omit the schema name, in which case the schema name will be the same as the user name. See &lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;Section 5.9.6&lt;/a&gt; for how this can be useful.</source>
          <target state="translated">您甚至可以省略架构名称，在这种情况下，架构名称将与用户名相同。有关如何使用的信息，请参见&lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;第5.9.6节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cc36ec902ca8c0ca398f503d160c7bcb9cae5a08" translate="yes" xml:space="preserve">
          <source>You can grant membership to other group roles, too (since there isn't really any distinction between group roles and non-group roles). The database will not let you set up circular membership loops. Also, it is not permitted to grant membership in a role to &lt;code&gt;PUBLIC&lt;/code&gt;.</source>
          <target state="translated">您也可以将成员资格授予其他组角色（因为组角色和非组角色之间实际上没有任何区别）。该数据库将不允许您设置循环成员循环。同样，不允许向 &lt;code&gt;PUBLIC&lt;/code&gt; 授予该角色的成员资格。</target>
        </trans-unit>
        <trans-unit id="1855de10627c59aa70817e07d54ec85b68d5f2a6" translate="yes" xml:space="preserve">
          <source>You can have any number of standby servers, but if you use streaming replication, make sure you set &lt;code&gt;max_wal_senders&lt;/code&gt; high enough in the primary to allow them to be connected simultaneously.</source>
          <target state="translated">您可以有任意数量的备用服务器，但是如果使用流复制，请确保在主服务器中将 &lt;code&gt;max_wal_senders&lt;/code&gt; 设置得足够高，以允许它们同时连接。</target>
        </trans-unit>
        <trans-unit id="fd1cb07de1f7e656292c8ca30e0d8e6b56ad41dd" translate="yes" xml:space="preserve">
          <source>You can insert multiple rows in a single command:</source>
          <target state="translated">您可以在一个命令中插入多行。</target>
        </trans-unit>
        <trans-unit id="42ba202e5611e6787a856f8be8ec1439c95a1b90" translate="yes" xml:space="preserve">
          <source>You can list the columns in a different order if you wish or even omit some columns, e.g., if the precipitation is unknown:</source>
          <target state="translated">如果你愿意,你可以按照不同的顺序列出列,甚至可以省略一些列,例如,如果降水量未知。</target>
        </trans-unit>
        <trans-unit id="3d6ecf73216b6b457189a453d966978eb4171c2e" translate="yes" xml:space="preserve">
          <source>You can monitor disk space in three ways: using the SQL functions listed in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBSIZE&quot;&gt;Table 9.89&lt;/a&gt;, using the &lt;a href=&quot;https://www.postgresql.org/docs/12/oid2name.html&quot;&gt;oid2name&lt;/a&gt; module, or using manual inspection of the system catalogs. The SQL functions are the easiest to use and are generally recommended. The remainder of this section shows how to do it by inspection of the system catalogs.</source>
          <target state="translated">您可以通过以下三种方式监视磁盘空间：使用&lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBSIZE&quot;&gt;表9.89中&lt;/a&gt;列出的SQL函数，使用&lt;a href=&quot;https://www.postgresql.org/docs/12/oid2name.html&quot;&gt;oid2name&lt;/a&gt;模块或对系统目录进行手动检查。SQL函数最易于使用，通常建议使用。本节的其余部分显示如何通过检查系统目录来执行此操作。</target>
        </trans-unit>
        <trans-unit id="fc43586ff2149aed2e36a6059af6a439ca36056f" translate="yes" xml:space="preserve">
          <source>You can monitor disk space in three ways: using the SQL functions listed in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBSIZE&quot;&gt;Table 9.90&lt;/a&gt;, using the &lt;a href=&quot;https://www.postgresql.org/docs/13/oid2name.html&quot;&gt;oid2name&lt;/a&gt; module, or using manual inspection of the system catalogs. The SQL functions are the easiest to use and are generally recommended. The remainder of this section shows how to do it by inspection of the system catalogs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d41216c0546ef7a2b57fe5526f609434095e7579" translate="yes" xml:space="preserve">
          <source>You can reduce the width of the output by explicitly specifying which columns you want to see:</source>
          <target state="translated">你可以通过明确指定你想看到的列来减少输出的宽度。</target>
        </trans-unit>
        <trans-unit id="8331a990fbd5bf29d20b7859a75677eec31adfb9" translate="yes" xml:space="preserve">
          <source>You can request that duplicate rows be removed from the result of a query:</source>
          <target state="translated">你可以要求从查询结果中删除重复的记录。</target>
        </trans-unit>
        <trans-unit id="3fcea913f233f38e0ca5df494ac39fe2b0977a56" translate="yes" xml:space="preserve">
          <source>You can request that the results of a query be returned in sorted order:</source>
          <target state="translated">您可以要求按排序顺序返回查询结果。</target>
        </trans-unit>
        <trans-unit id="7eb5aec5733f23b6d31556d97f7864bf4f3ef3fd" translate="yes" xml:space="preserve">
          <source>You can retrieve a list of WAL sender processes via the &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-REPLICATION-VIEW&quot;&gt;&lt;code&gt;pg_stat_replication&lt;/code&gt;&lt;/a&gt; view. Large differences between &lt;code&gt;pg_current_wal_lsn&lt;/code&gt; and the view's &lt;code&gt;sent_lsn&lt;/code&gt; field might indicate that the master server is under heavy load, while differences between &lt;code&gt;sent_lsn&lt;/code&gt; and &lt;code&gt;pg_last_wal_receive_lsn&lt;/code&gt; on the standby might indicate network delay, or that the standby is under heavy load.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa31e230282587f91ce67696a7ae247357fc3c92" translate="yes" xml:space="preserve">
          <source>You can retrieve a list of WAL sender processes via the &lt;a href=&quot;monitoring-stats#PG-STAT-REPLICATION-VIEW&quot;&gt;pg_stat_replication&lt;/a&gt; view. Large differences between &lt;code&gt;pg_current_wal_lsn&lt;/code&gt; and the view's &lt;code&gt;sent_lsn&lt;/code&gt; field might indicate that the master server is under heavy load, while differences between &lt;code&gt;sent_lsn&lt;/code&gt; and &lt;code&gt;pg_last_wal_receive_lsn&lt;/code&gt; on the standby might indicate network delay, or that the standby is under heavy load.</source>
          <target state="translated">您可以通过&lt;a href=&quot;monitoring-stats#PG-STAT-REPLICATION-VIEW&quot;&gt;pg_stat_replication&lt;/a&gt;视图检索WAL发送者进程的列表。 &lt;code&gt;pg_current_wal_lsn&lt;/code&gt; 和视图的 &lt;code&gt;sent_lsn&lt;/code&gt; 字段之间的较大差异可能表明主服务器处于高负载状态，而备用数据库上的 &lt;code&gt;sent_lsn&lt;/code&gt; 和 &lt;code&gt;pg_last_wal_receive_lsn&lt;/code&gt; 之间的差异可能表明网络延迟，或者备用数据库处于高负载状态。</target>
        </trans-unit>
        <trans-unit id="8d913910be5bfeaa10ff530630e730b9ef488370" translate="yes" xml:space="preserve">
          <source>You can see all available cursors by querying the &lt;a href=&quot;view-pg-cursors&quot;&gt;&lt;code&gt;pg_cursors&lt;/code&gt;&lt;/a&gt; system view.</source>
          <target state="translated">您可以通过查询&lt;a href=&quot;view-pg-cursors&quot;&gt; &lt;code&gt;pg_cursors&lt;/code&gt; &lt;/a&gt;系统视图来查看所有可用的游标。</target>
        </trans-unit>
        <trans-unit id="3d1e44f9701af9c1191f1ae4aa31b23f502dc3b9" translate="yes" xml:space="preserve">
          <source>You can see all prepared statements available in the session by querying the &lt;a href=&quot;view-pg-prepared-statements&quot;&gt;&lt;code&gt;pg_prepared_statements&lt;/code&gt;&lt;/a&gt; system view.</source>
          <target state="translated">您可以通过查询&lt;a href=&quot;view-pg-prepared-statements&quot;&gt; &lt;code&gt;pg_prepared_statements&lt;/code&gt; &lt;/a&gt;系统视图来查看会话中所有可用的准备好的语句。</target>
        </trans-unit>
        <trans-unit id="a1851e47d03f25069a58e8ba84744ebf9f76c67c" translate="yes" xml:space="preserve">
          <source>You can specify a non-default encoding at database creation time, provided that the encoding is compatible with the selected locale:</source>
          <target state="translated">您可以在创建数据库时指定一个非默认的编码,但编码必须与所选的语言环境兼容。</target>
        </trans-unit>
        <trans-unit id="429c21ef7f32890bc18b9fd73f1ebb90743874ca" translate="yes" xml:space="preserve">
          <source>You can unlisten something you were not listening for; no warning or error will appear.</source>
          <target state="translated">你可以解除你没有听的东西,不会出现警告或错误。</target>
        </trans-unit>
        <trans-unit id="0f0825c19fa74c86ea4fde39915a5f442a1301c8" translate="yes" xml:space="preserve">
          <source>You can update existing rows using the &lt;code&gt;UPDATE&lt;/code&gt; command. Suppose you discover the temperature readings are all off by 2 degrees after November 28. You can correct the data as follows:</source>
          <target state="translated">您可以使用 &lt;code&gt;UPDATE&lt;/code&gt; 命令更新现有行。假设您发现11月28日之后温度读数全部偏离了2度。您可以按以下方式更正数据：</target>
        </trans-unit>
        <trans-unit id="e9d9d610480d842b7b4dae95f084d8c480dea21a" translate="yes" xml:space="preserve">
          <source>You can update more than one column in an &lt;code&gt;UPDATE&lt;/code&gt; command by listing more than one assignment in the &lt;code&gt;SET&lt;/code&gt; clause. For example:</source>
          <target state="translated">您可以通过在 &lt;code&gt;SET&lt;/code&gt; 子句中列出多个分配来更新 &lt;code&gt;UPDATE&lt;/code&gt; 命令中的多个列。例如：</target>
        </trans-unit>
        <trans-unit id="afbd81cf7abf6e1ee5aed73e857469d9b19d9be7" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;pg_restore -j&lt;/code&gt; to restore a dump in parallel. This will work for any archive of either the &quot;custom&quot; or the &quot;directory&quot; archive mode, whether or not it has been created with &lt;code&gt;pg_dump -j&lt;/code&gt;.</source>
          <target state="translated">您可以使用 &lt;code&gt;pg_restore -j&lt;/code&gt; 并行恢复转储。不论是否使用 &lt;code&gt;pg_dump -j&lt;/code&gt; 创建的文件，这对于&amp;ldquo;定制&amp;rdquo;或&amp;ldquo;目录&amp;rdquo;归档模式的任何归档都适用。</target>
        </trans-unit>
        <trans-unit id="e548ce622037cda7095c1bcbf3f92886d139cb4c" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;pg_walfile_name_offset&lt;/code&gt; to extract the corresponding write-ahead log file name and byte offset from a &lt;code&gt;pg_lsn&lt;/code&gt; value. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b820c01225164f2d5b985f5de0dcbc0100e250a" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;pg_walfile_name_offset&lt;/code&gt; to extract the corresponding write-ahead log file name and byte offset from the results of any of the above functions. For example:</source>
          <target state="translated">您可以使用 &lt;code&gt;pg_walfile_name_offset&lt;/code&gt; 从上述任何函数的结果中提取相应的预写日志文件名和字节偏移量。例如：</target>
        </trans-unit>
        <trans-unit id="c69d101f435a1744fb1dd6c3be27758cb46e4777" translate="yes" xml:space="preserve">
          <source>You can use data-modifying statements (&lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt;) in &lt;code&gt;WITH&lt;/code&gt;. This allows you to perform several different operations in the same query. An example is:</source>
          <target state="translated">您可以在 &lt;code&gt;WITH&lt;/code&gt; 中使用数据修改语句（ &lt;code&gt;INSERT&lt;/code&gt; ， &lt;code&gt;UPDATE&lt;/code&gt; 或 &lt;code&gt;DELETE&lt;/code&gt; ）。这使您可以在同一查询中执行几个不同的操作。一个例子是：</target>
        </trans-unit>
        <trans-unit id="0ab93f9848617cd1c9b0e1e4c6fbe5e015dc7f2a" translate="yes" xml:space="preserve">
          <source>You can use several filter expressions in sequence, if required. For example, the following expression selects start times of all segments that contain locations with relevant coordinates and high heart rate values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aecc1927f70a57ed9583d45287b1db5300bd7af" translate="yes" xml:space="preserve">
          <source>You can use several filter expressions on the same nesting level, if required. For example, the following expression selects all segments that contain locations with relevant coordinates and high heart rate values:</source>
          <target state="translated">如果需要,您可以在同一嵌套层上使用多个过滤表达式。例如,以下表达式选择包含具有相关坐标和高心率值的位置的所有片段。</target>
        </trans-unit>
        <trans-unit id="cfeaa68d3d1e02bb6f35ba750e012709276d477e" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;btree-gist&quot;&gt;&lt;code&gt;btree_gist&lt;/code&gt;&lt;/a&gt; extension to define exclusion constraints on plain scalar data types, which can then be combined with range exclusions for maximum flexibility. For example, after &lt;code&gt;btree_gist&lt;/code&gt; is installed, the following constraint will reject overlapping ranges only if the meeting room numbers are equal:</source>
          <target state="translated">您可以使用&lt;a href=&quot;btree-gist&quot;&gt; &lt;code&gt;btree_gist&lt;/code&gt; &lt;/a&gt;扩展来定义普通标量数据类型的排除约束，然后可以将其与范围排除结合使用，以实现最大的灵活性。例如，在安装 &lt;code&gt;btree_gist&lt;/code&gt; 之后，以下约束将仅在会议室号相等时才拒绝重叠范围：</target>
        </trans-unit>
        <trans-unit id="002e817c446bf19265c623a41f235f06765b50f1" translate="yes" xml:space="preserve">
          <source>You can verify what the command will do using rsync's &lt;code&gt;--dry-run&lt;/code&gt; option. While rsync must be run on the primary for at least one standby, it is possible to run rsync on an upgraded standby to upgrade other standbys, as long as the upgraded standby has not been started.</source>
          <target state="translated">您可以使用rsync的 &lt;code&gt;--dry-run&lt;/code&gt; 选项来验证该命令将执行的操作。尽管必须至少在一个备用数据库上在主数据库上运行rsync，但只要尚未启动升级的备用数据库，就可以在升级的备用数据库上运行rsync来升级其他备用数据库。</target>
        </trans-unit>
        <trans-unit id="92d48e271b4c23101cd376b3231b8d00d43b6839" translate="yes" xml:space="preserve">
          <source>You can write expressions, not just simple column references, in the select list. For example, you can do:</source>
          <target state="translated">你可以在选择列表中写表达式,而不仅仅是简单的列引用。例如,你可以这样做。</target>
        </trans-unit>
        <trans-unit id="0b204489972744de11c0eeded07bbc813914aafd" translate="yes" xml:space="preserve">
          <source>You can:</source>
          <target state="translated">你可以。</target>
        </trans-unit>
        <trans-unit id="de82188f9fe7e2d788196205280b0985f84081cc" translate="yes" xml:space="preserve">
          <source>You cannot drop the &lt;code&gt;NOT NULL&lt;/code&gt; constraint on a partition's column if the constraint is present in the parent table.</source>
          <target state="translated">如果父表中存在约束，则 &lt;code&gt;NOT NULL&lt;/code&gt; 在分区的列上删除NOT NULL约束。</target>
        </trans-unit>
        <trans-unit id="093c2a9d5eef8843d884253372bdbca71ca3f136" translate="yes" xml:space="preserve">
          <source>You cannot execute the &lt;code&gt;DROP DATABASE&lt;/code&gt; command while connected to the victim database. You can, however, be connected to any other database, including the &lt;code&gt;template1&lt;/code&gt; database. &lt;code&gt;template1&lt;/code&gt; would be the only option for dropping the last user database of a given cluster.</source>
          <target state="translated">连接到受害者数据库后，您将无法执行 &lt;code&gt;DROP DATABASE&lt;/code&gt; 命令。但是，您可以连接到任何其他数据库，包括 &lt;code&gt;template1&lt;/code&gt; 数据库。 &lt;code&gt;template1&lt;/code&gt; 将是删除给定集群的最后一个用户数据库的唯一选项。</target>
        </trans-unit>
        <trans-unit id="7a936475d5b2fe8219655a01b86bcd035950ef3f" translate="yes" xml:space="preserve">
          <source>You could also have set up port forwarding as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8854264af301815bd4c143e497bc4039dd4ee05" translate="yes" xml:space="preserve">
          <source>You could also have set up the port forwarding as</source>
          <target state="translated">您也可以将端口转发设置为</target>
        </trans-unit>
        <trans-unit id="00192154b86c5479e232f9339dfec14280fa9591" translate="yes" xml:space="preserve">
          <source>You could also have used &lt;code&gt;COPY&lt;/code&gt; to load large amounts of data from flat-text files. This is usually faster because the &lt;code&gt;COPY&lt;/code&gt; command is optimized for this application while allowing less flexibility than &lt;code&gt;INSERT&lt;/code&gt;. An example would be:</source>
          <target state="translated">您还可能使用了 &lt;code&gt;COPY&lt;/code&gt; 从纯文本文件中加载大量数据。这通常会更快，因为 &lt;code&gt;COPY&lt;/code&gt; 命令已针对该应用程序进行了优化，但灵活性却比 &lt;code&gt;INSERT&lt;/code&gt; 小。一个例子是：</target>
        </trans-unit>
        <trans-unit id="db5bb918efb1956e14366be6e4e8492955095b0f" translate="yes" xml:space="preserve">
          <source>You do not need to constrain the join order completely in order to cut search time, because it's OK to use &lt;code&gt;JOIN&lt;/code&gt; operators within items of a plain &lt;code&gt;FROM&lt;/code&gt; list. For example, consider:</source>
          <target state="translated">您无需完全限制连接顺序即可缩短搜索时间，因为可以在普通 &lt;code&gt;FROM&lt;/code&gt; 列表的项目中使用 &lt;code&gt;JOIN&lt;/code&gt; 运算符。例如，考虑：</target>
        </trans-unit>
        <trans-unit id="cb9759ceb3a93faeeed42501a60a856539a7fb24" translate="yes" xml:space="preserve">
          <source>You do not want to use the third form when specifying a &lt;code&gt;DEFAULT&lt;/code&gt; clause while creating a table. The system will convert &lt;code&gt;now&lt;/code&gt; to a &lt;code&gt;timestamp&lt;/code&gt; as soon as the constant is parsed, so that when the default value is needed, the time of the table creation would be used! The first two forms will not be evaluated until the default value is used, because they are function calls. Thus they will give the desired behavior of defaulting to the time of row insertion.</source>
          <target state="translated">在创建表时指定 &lt;code&gt;DEFAULT&lt;/code&gt; 子句时，您不想使用第三种形式。该系统将转换成 &lt;code&gt;now&lt;/code&gt; 的 &lt;code&gt;timestamp&lt;/code&gt; 只要不断被解析，以便在需要的默认值时，创建表时将使用！在使用默认值之前，不会评估前两种形式，因为它们是函数调用。因此，它们将提供默认的行插入时间默认值。</target>
        </trans-unit>
        <trans-unit id="82ae0883f7a2deb13919a7b51525df4e84881170" translate="yes" xml:space="preserve">
          <source>You have altered a storage parameter (such as fillfactor) for an index, and wish to ensure that the change has taken full effect.</source>
          <target state="translated">你改变了一个索引的存储参数(如 fillfactor),并希望确保改变已经完全生效。</target>
        </trans-unit>
        <trans-unit id="9105126c4b98c9abf43cead14144e7c73642eea6" translate="yes" xml:space="preserve">
          <source>You have to adapt &lt;code&gt;compressed_data_type&lt;/code&gt; to the specific type you're converting to in order to compress your leaf nodes, of course.</source>
          <target state="translated">当然，为了压缩叶节点，必须将 &lt;code&gt;compressed_data_type&lt;/code&gt; 调整为要转换为的特定类型。</target>
        </trans-unit>
        <trans-unit id="c6ec9a715c152149c664d288cf7e25e03ec9494f" translate="yes" xml:space="preserve">
          <source>You may decide to use multiple columns in the partition key for range partitioning, if desired. Of course, this will often result in a larger number of partitions, each of which is individually smaller. On the other hand, using fewer columns may lead to a coarser-grained partitioning criteria with smaller number of partitions. A query accessing the partitioned table will have to scan fewer partitions if the conditions involve some or all of these columns. For example, consider a table range partitioned using columns &lt;code&gt;lastname&lt;/code&gt; and &lt;code&gt;firstname&lt;/code&gt; (in that order) as the partition key.</source>
          <target state="translated">如果需要，您可以决定在分区键中使用多列进行范围分区。当然，这通常会导致分区数量更多，每个分区分别更小。另一方面，使用较少的列可能会导致分区数量较少的分区标准更粗糙。如果条件涉及这些列中的某些或全部，则访问分区表的查询将必须扫描较少的分区。例如，考虑使用以 &lt;code&gt;lastname&lt;/code&gt; 和 &lt;code&gt;firstname&lt;/code&gt; 列（按此顺序）作为分区键进行分区的表范围。</target>
        </trans-unit>
        <trans-unit id="cf47ba3690a812065d027e7932a77588e377659a" translate="yes" xml:space="preserve">
          <source>You might also want to configure your kernel to lock System V shared memory into RAM and prevent it from being paged out to swap. This can be accomplished using the &lt;code&gt;sysctl&lt;/code&gt; setting &lt;code&gt;kern.ipc.shm_use_phys&lt;/code&gt;.</source>
          <target state="translated">您可能还需要配置内核，以将System V共享内存锁定到RAM中，并防止将其调出以进行交换。这可以使用 &lt;code&gt;sysctl&lt;/code&gt; 设置 &lt;code&gt;kern.ipc.shm_use_phys&lt;/code&gt; 来完成。</target>
        </trans-unit>
        <trans-unit id="0a62a7a5cf401923b709acdb0497028fe1fd4d2f" translate="yes" xml:space="preserve">
          <source>You might be tempted to create a large set of non-overlapping partial indexes, for example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="118dd6812b30292a1fcd4d319831dc8ec3a9335e" translate="yes" xml:space="preserve">
          <source>You might instead use this approach to naming the files descriptively:</source>
          <target state="translated">你可以改用这种方法对文件进行描述性命名。</target>
        </trans-unit>
        <trans-unit id="149e9ef120e49f8ae119951c604cd065ab893c33" translate="yes" xml:space="preserve">
          <source>You might prefer to remove the &lt;code&gt;sepgsql-regtest&lt;/code&gt; policy entirely:</source>
          <target state="translated">您可能希望完全删除 &lt;code&gt;sepgsql-regtest&lt;/code&gt; 策略：</target>
        </trans-unit>
        <trans-unit id="a34411202b4ded0e9449c6d67415d0bad4541f5b" translate="yes" xml:space="preserve">
          <source>You might reasonably ask why there is an &lt;code&gt;ELEMENT&lt;/code&gt; option, if the system makes the correct array type automatically. The only case where it's useful to use &lt;code&gt;ELEMENT&lt;/code&gt; is when you are making a fixed-length type that happens to be internally an array of a number of identical things, and you want to allow these things to be accessed directly by subscripting, in addition to whatever operations you plan to provide for the type as a whole. For example, type &lt;code&gt;point&lt;/code&gt; is represented as just two floating-point numbers, which can be accessed using &lt;code&gt;point[0]&lt;/code&gt; and &lt;code&gt;point[1]&lt;/code&gt;. Note that this facility only works for fixed-length types whose internal form is exactly a sequence of identical fixed-length fields. A subscriptable variable-length type must have the generalized internal representation used by &lt;code&gt;array_in&lt;/code&gt; and &lt;code&gt;array_out&lt;/code&gt;. For historical reasons (i.e., this is clearly wrong but it's far too late to change it), subscripting of fixed-length array types starts from zero, rather than from one as for variable-length arrays.</source>
          <target state="translated">您可能会合理地问，如果系统自动生成正确的数组类型，为什么会有 &lt;code&gt;ELEMENT&lt;/code&gt; 选项。使用 &lt;code&gt;ELEMENT&lt;/code&gt; 唯一有用的情况是，当您创建一个固定长度的类型时，该类型在内部恰好是由许多相同的东西组成的数组，并且除了允许除下标外，还希望直接通过下标来访问这些东西。您计划为整个类型提供的任何操作。例如，类型 &lt;code&gt;point&lt;/code&gt; 仅表示为两个浮点数，可以使用 &lt;code&gt;point[0]&lt;/code&gt; 和 &lt;code&gt;point[1]&lt;/code&gt; 进行访问。。请注意，此功能仅适用于内部形式完全相同的固定长度字段序列的固定长度类型。甲标化的可变长度类型必须具有由所使用的广义内部表示 &lt;code&gt;array_in&lt;/code&gt; 和 &lt;code&gt;array_out&lt;/code&gt; 。由于历史原因（即，这显然是错误的，但现在更改它为时已晚），固定长度数组类型的下标从零开始，而不是可变长度数组的下标。</target>
        </trans-unit>
        <trans-unit id="e76fa113e33e26d7d8bdc7061b1bdc78af7c35cf" translate="yes" xml:space="preserve">
          <source>You might want to reset &lt;code&gt;parallel_workers&lt;/code&gt; after setting it as part of tuning an index build. This avoids inadvertent changes to query plans, since &lt;code&gt;parallel_workers&lt;/code&gt; affects &lt;em&gt;all&lt;/em&gt; parallel table scans.</source>
          <target state="translated">您可能需要在将其设置为调整索引构建的一部分之后，重置 &lt;code&gt;parallel_workers&lt;/code&gt; 。这避免了对查询计划的无意更改，因为 &lt;code&gt;parallel_workers&lt;/code&gt; 会影响&lt;em&gt;所有&lt;/em&gt;并行表扫描。</target>
        </trans-unit>
        <trans-unit id="16c3ec0adfcebb8df4d8276a101b477163d7255e" translate="yes" xml:space="preserve">
          <source>You might wonder why bother providing all four options, when two options together with the possibility of backward scan would cover all the variants of &lt;code&gt;ORDER BY&lt;/code&gt;. In single-column indexes the options are indeed redundant, but in multicolumn indexes they can be useful. Consider a two-column index on &lt;code&gt;(x, y)&lt;/code&gt;: this can satisfy &lt;code&gt;ORDER BY x, y&lt;/code&gt; if we scan forward, or &lt;code&gt;ORDER BY x DESC, y DESC&lt;/code&gt; if we scan backward. But it might be that the application frequently needs to use &lt;code&gt;ORDER BY x ASC, y DESC&lt;/code&gt;. There is no way to get that ordering from a plain index, but it is possible if the index is defined as &lt;code&gt;(x ASC, y DESC)&lt;/code&gt; or &lt;code&gt;(x DESC, y ASC)&lt;/code&gt;.</source>
          <target state="translated">您可能想知道为什么当两个选项以及向后扫描的可能性将覆盖 &lt;code&gt;ORDER BY&lt;/code&gt; 的所有变体时，为什么还要麻烦地提供所有四个选项。在单列索引中，这些选项确实是多余的，但在多列索引中，它们可能很有用。考虑在 &lt;code&gt;(x, y)&lt;/code&gt; 上的两列索引：如果向前扫描，则可以满足 &lt;code&gt;ORDER BY x, y&lt;/code&gt; 如果向后扫描，则可以满足 &lt;code&gt;ORDER BY x DESC, y DESC&lt;/code&gt; 。但是可能是应用程序经常需要使用 &lt;code&gt;ORDER BY x ASC, y DESC&lt;/code&gt; 。无法从纯索引中获得该顺序，但是将索引定义为 &lt;code&gt;(x ASC, y DESC)&lt;/code&gt; 或 &lt;code&gt;(x DESC, y ASC)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a96b7a75456662c5aa3c61f0b2bf6c8181936405" translate="yes" xml:space="preserve">
          <source>You must be a superuser to use &lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt;. (This restriction is made because an erroneous operator family definition could confuse or even crash the server.)</source>
          <target state="translated">您必须是超级用户才能使用 &lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt; 。（之所以做出此限制，是因为错误的操作员系列定义可能会使服务器混乱甚至崩溃。）</target>
        </trans-unit>
        <trans-unit id="f2c54ba09d5b62548914418dced24b83c29f8192" translate="yes" xml:space="preserve">
          <source>You must be a superuser to use &lt;code&gt;ALTER TEXT SEARCH PARSER&lt;/code&gt;.</source>
          <target state="translated">您必须是超级用户才能使用 &lt;code&gt;ALTER TEXT SEARCH PARSER&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b1c6e4d091898d0c808adc78af3decbefdf7c390" translate="yes" xml:space="preserve">
          <source>You must be a superuser to use &lt;code&gt;ALTER TEXT SEARCH TEMPLATE&lt;/code&gt;.</source>
          <target state="translated">您必须是超级用户才能使用 &lt;code&gt;ALTER TEXT SEARCH TEMPLATE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4112b2d8f8d95b2e2b447d1ab817d0a272e11d27" translate="yes" xml:space="preserve">
          <source>You must be a superuser to use &lt;code&gt;CREATE TEXT SEARCH PARSER&lt;/code&gt;. (This restriction is made because an erroneous text search parser definition could confuse or even crash the server.)</source>
          <target state="translated">您必须是超级用户才能使用 &lt;code&gt;CREATE TEXT SEARCH PARSER&lt;/code&gt; 。（之所以做出此限制，是因为错误的文本搜索解析器定义可能会使服务器困惑甚至崩溃。）</target>
        </trans-unit>
        <trans-unit id="6ab7f85ecb54195b79adfabb967e5f95ee6fb3b3" translate="yes" xml:space="preserve">
          <source>You must be a superuser to use &lt;code&gt;CREATE TEXT SEARCH TEMPLATE&lt;/code&gt;. This restriction is made because an erroneous text search template definition could confuse or even crash the server. The reason for separating templates from dictionaries is that a template encapsulates the &amp;ldquo;unsafe&amp;rdquo; aspects of defining a dictionary. The parameters that can be set when defining a dictionary are safe for unprivileged users to set, and so creating a dictionary need not be a privileged operation.</source>
          <target state="translated">您必须是超级用户才能使用 &lt;code&gt;CREATE TEXT SEARCH TEMPLATE&lt;/code&gt; 。之所以做出此限制，是因为错误的文本搜索模板定义可能会使服务器混乱甚至崩溃。将模板与词典分开的原因是模板封装了定义词典的&amp;ldquo;不安全&amp;rdquo;方面。定义字典时可以设置的参数对于没有特权的用户是安全的，因此创建字典不必是特权操作。</target>
        </trans-unit>
        <trans-unit id="d6ba0fbc9ee76ec30e6a734cc139602ed5f74a38" translate="yes" xml:space="preserve">
          <source>You must be superuser to alter an event trigger.</source>
          <target state="translated">你必须是超级用户才能更改事件触发器。</target>
        </trans-unit>
        <trans-unit id="d2778f188a2bae6cf3e02c68a508357eae34c9bc" translate="yes" xml:space="preserve">
          <source>You must be the owner of a table to create a statistics object reading it. Once created, however, the ownership of the statistics object is independent of the underlying table(s).</source>
          <target state="translated">您必须是表的所有者才能创建读取表的统计对象。但是,一旦创建,统计对象的所有权是独立于底层表的。</target>
        </trans-unit>
        <trans-unit id="b18eb66aae7b37aaff80a2a943d09edee67a5cd6" translate="yes" xml:space="preserve">
          <source>You must be the owner of a table to create or change policies for it.</source>
          <target state="translated">您必须是表的所有者才能为其创建或更改策略。</target>
        </trans-unit>
        <trans-unit id="dd98593a661bbd8265aa519e6846bcf6a1a65a93" translate="yes" xml:space="preserve">
          <source>You must be the owner of a table to create or change rules for it.</source>
          <target state="translated">你必须是一个表的所有者才能为它创建或更改规则。</target>
        </trans-unit>
        <trans-unit id="fb2285ad531d2e07d6d7c86c0203500d7139806c" translate="yes" xml:space="preserve">
          <source>You must be the owner of the configuration to use &lt;code&gt;ALTER TEXT SEARCH CONFIGURATION&lt;/code&gt;.</source>
          <target state="translated">您必须是配置的所有者，才能使用 &lt;code&gt;ALTER TEXT SEARCH CONFIGURATION&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="90b9a22d759305d6fe1fa47e1f5ffd11756e94a9" translate="yes" xml:space="preserve">
          <source>You must be the owner of the dictionary to use &lt;code&gt;ALTER TEXT SEARCH DICTIONARY&lt;/code&gt;.</source>
          <target state="translated">您必须是字典的所有者，才能使用 &lt;code&gt;ALTER TEXT SEARCH DICTIONARY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e259c4dd1968568dc3fb80e1b6efb5689d6bdb9" translate="yes" xml:space="preserve">
          <source>You must have &lt;code&gt;INSERT&lt;/code&gt; privilege on a table in order to insert into it. If &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; is present, &lt;code&gt;UPDATE&lt;/code&gt; privilege on the table is also required.</source>
          <target state="translated">您必须对表具有 &lt;code&gt;INSERT&lt;/code&gt; 特权才能插入表中。如果存在 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; ，则还需要表的 &lt;code&gt;UPDATE&lt;/code&gt; 特权。</target>
        </trans-unit>
        <trans-unit id="bb31803ee937f757ae783b41d67981c9d86f3e9e" translate="yes" xml:space="preserve">
          <source>You must have &lt;code&gt;SELECT&lt;/code&gt; privilege on each column used in a &lt;code&gt;SELECT&lt;/code&gt; command. The use of &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt;, &lt;code&gt;FOR UPDATE&lt;/code&gt;, &lt;code&gt;FOR SHARE&lt;/code&gt; or &lt;code&gt;FOR KEY SHARE&lt;/code&gt; requires &lt;code&gt;UPDATE&lt;/code&gt; privilege as well (for at least one column of each table so selected).</source>
          <target state="translated">您必须对 &lt;code&gt;SELECT&lt;/code&gt; 命令中使用的每一列都具有 &lt;code&gt;SELECT&lt;/code&gt; 特权。使用 &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt; ， &lt;code&gt;FOR UPDATE&lt;/code&gt; ， &lt;code&gt;FOR SHARE&lt;/code&gt; 或 &lt;code&gt;FOR KEY SHARE&lt;/code&gt; 也需要 &lt;code&gt;UPDATE&lt;/code&gt; 特权（对于这样选择的每个表的至少一列）。</target>
        </trans-unit>
        <trans-unit id="d02911fbcb07608d5d71771e387bdf240b881b98" translate="yes" xml:space="preserve">
          <source>You must have select privilege on the table whose values are read by &lt;code&gt;COPY TO&lt;/code&gt;, and insert privilege on the table into which values are inserted by &lt;code&gt;COPY FROM&lt;/code&gt;. It is sufficient to have column privileges on the column(s) listed in the command.</source>
          <target state="translated">您必须对通过 &lt;code&gt;COPY TO&lt;/code&gt; 读取值的表具有选择特权，并且对于通过 &lt;code&gt;COPY FROM&lt;/code&gt; 将值插入其中的表具有插入特权。在命令中列出的列上具有列特权就足够了。</target>
        </trans-unit>
        <trans-unit id="f7e79121fed35518353fce9ebea22091560488e8" translate="yes" xml:space="preserve">
          <source>You must have the &lt;code&gt;DELETE&lt;/code&gt; privilege on the table to delete from it, as well as the &lt;code&gt;SELECT&lt;/code&gt; privilege for any table in the &lt;code&gt;USING&lt;/code&gt; clause or whose values are read in the &lt;code&gt;condition&lt;/code&gt;.</source>
          <target state="translated">您必须具有要从表中删除的表的 &lt;code&gt;DELETE&lt;/code&gt; 特权，以及 &lt;code&gt;USING&lt;/code&gt; 子句中任何表的值或在 &lt;code&gt;condition&lt;/code&gt; 中读取其值的表的 &lt;code&gt;SELECT&lt;/code&gt; 特权。</target>
        </trans-unit>
        <trans-unit id="4a1c02ef145014df727c0bbfa9c3ff89cf785dd1" translate="yes" xml:space="preserve">
          <source>You must have the &lt;code&gt;TRUNCATE&lt;/code&gt; privilege on a table to truncate it.</source>
          <target state="translated">您必须在表上具有 &lt;code&gt;TRUNCATE&lt;/code&gt; 特权才能截断它。</target>
        </trans-unit>
        <trans-unit id="77a7a29185db04a6a9d2e4452098a88fd3c7b7ea" translate="yes" xml:space="preserve">
          <source>You must have the &lt;code&gt;UPDATE&lt;/code&gt; privilege on the table, or at least on the column(s) that are listed to be updated. You must also have the &lt;code&gt;SELECT&lt;/code&gt; privilege on any column whose values are read in the &lt;code&gt;expressions&lt;/code&gt; or &lt;code&gt;condition&lt;/code&gt;.</source>
          <target state="translated">您必须在表上或至少在要更新的列上具有 &lt;code&gt;UPDATE&lt;/code&gt; 特权。您还必须对在 &lt;code&gt;expressions&lt;/code&gt; 或 &lt;code&gt;condition&lt;/code&gt; 中读取其值的任何列都具有 &lt;code&gt;SELECT&lt;/code&gt; 特权。</target>
        </trans-unit>
        <trans-unit id="d6be4ee2e09272568e1f74da88776799e39f34a3" translate="yes" xml:space="preserve">
          <source>You must own the aggregate function to use &lt;code&gt;ALTER AGGREGATE&lt;/code&gt;. To change the schema of an aggregate function, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the aggregate function's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the aggregate function. However, a superuser can alter ownership of any aggregate function anyway.)</source>
          <target state="translated">您必须拥有聚合函数才能使用 &lt;code&gt;ALTER AGGREGATE&lt;/code&gt; 。要更改聚合函数的架构，您还必须对新架构具有 &lt;code&gt;CREATE&lt;/code&gt; 特权。要更改所有者，您还必须是新拥有角色的直接或间接成员，并且该角色必须对聚合函数的架构具有 &lt;code&gt;CREATE&lt;/code&gt; 特权。 （这些限制规定，更改所有者不会通过删除并重新创建聚合函数来做您做不到的任何事情。但是，超级用户仍然可以更改任何聚合函数的所有权。）</target>
        </trans-unit>
        <trans-unit id="a5408e4e6a9f4b7999bf20809f4af3f8dff4cea5" translate="yes" xml:space="preserve">
          <source>You must own the collation to use &lt;code&gt;ALTER COLLATION&lt;/code&gt;. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the collation's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the collation. However, a superuser can alter ownership of any collation anyway.)</source>
          <target state="translated">您必须拥有排序规则才能使用 &lt;code&gt;ALTER COLLATION&lt;/code&gt; 。要更改所有者，您还必须是新拥有角色的直接或间接成员，并且该角色必须对归类的架构具有 &lt;code&gt;CREATE&lt;/code&gt; 特权。 （这些限制规定，更改所有者不会通过删除并重新创建归类来完成您做不到的任何事情。但是，超级用户仍然可以更改任何归类的所有权。）</target>
        </trans-unit>
        <trans-unit id="d3b0175f69dcf313a89dcb0b18357a030f315c24" translate="yes" xml:space="preserve">
          <source>You must own the conversion to use &lt;code&gt;ALTER CONVERSION&lt;/code&gt;. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the conversion's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the conversion. However, a superuser can alter ownership of any conversion anyway.)</source>
          <target state="translated">您必须拥有转换才能使用 &lt;code&gt;ALTER CONVERSION&lt;/code&gt; 。要更改所有者，您还必须是新拥有角色的直接或间接成员，并且该角色必须对转换模式具有 &lt;code&gt;CREATE&lt;/code&gt; 特权。 （这些限制规定，更改所有者不能通过删除并重新创建转换来执行您无法做的任何事情。但是，超级用户仍然可以更改任何转换的所有权。）</target>
        </trans-unit>
        <trans-unit id="b3c900b3d4c912ff5e4ebc53ea79d5d20107d085" translate="yes" xml:space="preserve">
          <source>You must own the domain to use &lt;code&gt;ALTER DOMAIN&lt;/code&gt;. To change the schema of a domain, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the domain's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the domain. However, a superuser can alter ownership of any domain anyway.)</source>
          <target state="translated">您必须拥有该域才能使用 &lt;code&gt;ALTER DOMAIN&lt;/code&gt; 。要更改域的架构，您还必须对新架构具有 &lt;code&gt;CREATE&lt;/code&gt; 特权。要更改所有者，您还必须是新拥有角色的直接或间接成员，并且该角色必须对域的架构具有 &lt;code&gt;CREATE&lt;/code&gt; 特权。（这些限制规定，更改所有者不能通过删除并重新创建域来完成您无法做的任何事情。但是，超级用户仍然可以更改任何域的所有权。）</target>
        </trans-unit>
        <trans-unit id="cb1bc5a4738dcb26a0f29902f3cbbe388057acc0" translate="yes" xml:space="preserve">
          <source>You must own the extension to use &lt;code&gt;ALTER EXTENSION&lt;/code&gt;. The &lt;code&gt;ADD&lt;/code&gt;/&lt;code&gt;DROP&lt;/code&gt; forms require ownership of the added/dropped object as well.</source>
          <target state="translated">您必须拥有扩展名才能使用 &lt;code&gt;ALTER EXTENSION&lt;/code&gt; 。的 &lt;code&gt;ADD&lt;/code&gt; / &lt;code&gt;DROP&lt;/code&gt; 形式需要添加/删除对象的所有权，以及。</target>
        </trans-unit>
        <trans-unit id="a6dffb3cd3b426a1dfeb4f3d4a34d04b92502381" translate="yes" xml:space="preserve">
          <source>You must own the extension to use &lt;code&gt;DROP EXTENSION&lt;/code&gt;.</source>
          <target state="translated">您必须拥有该扩展名才能使用 &lt;code&gt;DROP EXTENSION&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9424f801bf04776e94b23d25a246b419d9f806fc" translate="yes" xml:space="preserve">
          <source>You must own the function to use &lt;code&gt;ALTER FUNCTION&lt;/code&gt;. To change a function's schema, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the function's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the function. However, a superuser can alter ownership of any function anyway.)</source>
          <target state="translated">您必须拥有该函数才能使用 &lt;code&gt;ALTER FUNCTION&lt;/code&gt; 。要更改函数的架构，还必须对新架构具有 &lt;code&gt;CREATE&lt;/code&gt; 特权。要更改所有者，您还必须是新拥有角色的直接或间接成员，并且该角色必须对函数的架构具有 &lt;code&gt;CREATE&lt;/code&gt; 特权。 （这些限制规定，更改所有者不能通过删除并重新创建功能来完成您无法做的任何事情。但是，超级用户仍然可以更改任何功能的所有权。）</target>
        </trans-unit>
        <trans-unit id="2c5eaf93b84b8e16b7b4075e87568743bd5c26dc" translate="yes" xml:space="preserve">
          <source>You must own the large object to use &lt;code&gt;ALTER LARGE OBJECT&lt;/code&gt;. To alter the owner, you must also be a direct or indirect member of the new owning role. (However, a superuser can alter any large object anyway.) Currently, the only functionality is to assign a new owner, so both restrictions always apply.</source>
          <target state="translated">您必须拥有大对象才能使用 &lt;code&gt;ALTER LARGE OBJECT&lt;/code&gt; 。要更改所有者，您还必须是新拥有角色的直接或间接成员。 （但是，超级用户仍然可以更改任何大对象。）当前，唯一的功能是分配新所有者，因此这两个限制始终适用。</target>
        </trans-unit>
        <trans-unit id="c749af14eff465f32f3ae73b6015d4eb8f90f209" translate="yes" xml:space="preserve">
          <source>You must own the materialized view to use &lt;code&gt;ALTER MATERIALIZED VIEW&lt;/code&gt;. To change a materialized view's schema, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the materialized view's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the materialized view. However, a superuser can alter ownership of any view anyway.)</source>
          <target state="translated">您必须拥有 &lt;code&gt;ALTER MATERIALIZED VIEW&lt;/code&gt; 化视图才能使用ALTER MATERIALIZED VIEW。要更改实例化视图的架构，您还必须对新架构具有 &lt;code&gt;CREATE&lt;/code&gt; 特权。要更改所有者，您还必须是新拥有角色的直接或间接成员，并且该角色必须对 &lt;code&gt;CREATE&lt;/code&gt; 化视图的架构具有CREATE特权。 （这些限制规定，更改所有者不会通过删除并重新创建实例化视图来执行您无法做的任何事情。但是，超级用户仍然可以更改任何视图的所有权。）</target>
        </trans-unit>
        <trans-unit id="c551fec90f0914ad71d1aabc9e18e3244b6d6bf8" translate="yes" xml:space="preserve">
          <source>You must own the operator class to use &lt;code&gt;ALTER OPERATOR CLASS&lt;/code&gt;. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the operator class's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the operator class. However, a superuser can alter ownership of any operator class anyway.)</source>
          <target state="translated">您必须拥有操作员类才能使用 &lt;code&gt;ALTER OPERATOR CLASS&lt;/code&gt; 。要更改所有者，您还必须是新拥有角色的直接或间接成员，并且该角色必须对操作员类的架构具有 &lt;code&gt;CREATE&lt;/code&gt; 特权。 （这些限制规定，更改所有者不会通过删除并重新创建操作符类来执行您无法做的任何事情。但是，超级用户仍然可以更改任何操作符类的所有权。）</target>
        </trans-unit>
        <trans-unit id="289cb9ff5358010db129ab37edd147b9711820ba" translate="yes" xml:space="preserve">
          <source>You must own the operator to use &lt;code&gt;ALTER OPERATOR&lt;/code&gt;. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the operator's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the operator. However, a superuser can alter ownership of any operator anyway.)</source>
          <target state="translated">您必须拥有运算符才能使用 &lt;code&gt;ALTER OPERATOR&lt;/code&gt; 。要更改所有者，您还必须是新拥有角色的直接或间接成员，并且该角色必须对操作员的架构具有 &lt;code&gt;CREATE&lt;/code&gt; 特权。 （这些限制规定，更改所有者不会通过删除并重新创建运算符来执行您无法做的任何事情。但是，超级用户仍然可以更改任何运算符的所有权。）</target>
        </trans-unit>
        <trans-unit id="aa32bd3d71baaa7969581d0d0f33bf13710aaa54" translate="yes" xml:space="preserve">
          <source>You must own the procedure to use &lt;code&gt;ALTER PROCEDURE&lt;/code&gt;. To change a procedure's schema, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the procedure's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the procedure. However, a superuser can alter ownership of any procedure anyway.)</source>
          <target state="translated">您必须拥有使用 &lt;code&gt;ALTER PROCEDURE&lt;/code&gt; 的过程。要更改过程的架构，还必须对新架构具有 &lt;code&gt;CREATE&lt;/code&gt; 特权。要更改所有者，您还必须是新拥有角色的直接或间接成员，并且该角色必须对过程的模式具有 &lt;code&gt;CREATE&lt;/code&gt; 特权。 （这些限制规定，更改所有者不会通过删除并重新创建过程来做您做不到的任何事情。但是，超级用户仍然可以更改任何过程的所有权。）</target>
        </trans-unit>
        <trans-unit id="8c5dd2c9f09fa4613a78c896a4d8ff93764043b0" translate="yes" xml:space="preserve">
          <source>You must own the publication to use &lt;code&gt;ALTER PUBLICATION&lt;/code&gt;. To alter the owner, you must also be a direct or indirect member of the new owning role. The new owner must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the database. Also, the new owner of a &lt;code&gt;FOR ALL TABLES&lt;/code&gt; publication must be a superuser. However, a superuser can change the ownership of a publication while circumventing these restrictions.</source>
          <target state="translated">您必须拥有出版物才能使用 &lt;code&gt;ALTER PUBLICATION&lt;/code&gt; 。要更改所有者，您还必须是新拥有角色的直接或间接成员。新所有者必须对数据库具有 &lt;code&gt;CREATE&lt;/code&gt; 特权。另外， &lt;code&gt;FOR ALL TABLES&lt;/code&gt; 发布的新所有者必须是超级用户。但是，超级用户可以在规避这些限制的同时更改出版物的所有权。</target>
        </trans-unit>
        <trans-unit id="0ebd09d1ba00b2c43b82e29c8fd88f155f0cc3ea" translate="yes" xml:space="preserve">
          <source>You must own the schema to use &lt;code&gt;ALTER SCHEMA&lt;/code&gt;. To rename a schema you must also have the &lt;code&gt;CREATE&lt;/code&gt; privilege for the database. To alter the owner, you must also be a direct or indirect member of the new owning role, and you must have the &lt;code&gt;CREATE&lt;/code&gt; privilege for the database. (Note that superusers have all these privileges automatically.)</source>
          <target state="translated">您必须拥有该架构才能使用 &lt;code&gt;ALTER SCHEMA&lt;/code&gt; 。要重命名模式，您还必须具有数据库的 &lt;code&gt;CREATE&lt;/code&gt; 特权。要更改所有者，您还必须是新拥有角色的直接或间接成员，并且必须具有数据库的 &lt;code&gt;CREATE&lt;/code&gt; 特权。 （请注意，超级用户会自动拥有所有这些特权。）</target>
        </trans-unit>
        <trans-unit id="06321f48b26cbb2ac459fd0a6dc711be8eab0c9e" translate="yes" xml:space="preserve">
          <source>You must own the sequence to use &lt;code&gt;ALTER SEQUENCE&lt;/code&gt;. To change a sequence's schema, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the sequence's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the sequence. However, a superuser can alter ownership of any sequence anyway.)</source>
          <target state="translated">您必须拥有序列才能使用 &lt;code&gt;ALTER SEQUENCE&lt;/code&gt; 。要更改序列的架构，还必须对新架构具有 &lt;code&gt;CREATE&lt;/code&gt; 特权。要更改所有者，您还必须是新拥有角色的直接或间接成员，并且该角色必须对序列的架构具有 &lt;code&gt;CREATE&lt;/code&gt; 特权。 （这些限制规定，更改所有者不会通过删除并重新创建序列来完成您做不到的任何事情。但是，超级用户仍然可以更改任何序列的所有权。）</target>
        </trans-unit>
        <trans-unit id="43effe8f1154a0915e8a351241bc95aed6ecd629" translate="yes" xml:space="preserve">
          <source>You must own the statistics object to use &lt;code&gt;ALTER STATISTICS&lt;/code&gt;. To change a statistics object's schema, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the statistics object's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the statistics object. However, a superuser can alter ownership of any statistics object anyway.)</source>
          <target state="translated">您必须拥有统计信息对象才能使用 &lt;code&gt;ALTER STATISTICS&lt;/code&gt; 。要更改统计对象的架构，还必须对新架构具有 &lt;code&gt;CREATE&lt;/code&gt; 特权。要更改所有者，您还必须是新拥有角色的直接或间接成员，并且该角色必须对统计对象的模式具有 &lt;code&gt;CREATE&lt;/code&gt; 特权。 （这些限制规定，更改所有者不会通过删除并重新创建统计对象来做您做不到的任何事情。但是，超级用户仍然可以更改任何统计对象的所有权。）</target>
        </trans-unit>
        <trans-unit id="407b57125ead1fe2313dbe8d95fd59c9276cf527" translate="yes" xml:space="preserve">
          <source>You must own the subscription to use &lt;code&gt;ALTER SUBSCRIPTION&lt;/code&gt;. To alter the owner, you must also be a direct or indirect member of the new owning role. The new owner has to be a superuser. (Currently, all subscription owners must be superusers, so the owner checks will be bypassed in practice. But this might change in the future.)</source>
          <target state="translated">您必须拥有订阅才能使用 &lt;code&gt;ALTER SUBSCRIPTION&lt;/code&gt; 。要更改所有者，您还必须是新拥有角色的直接或间接成员。新所有者必须是超级用户。 （当前，所有订阅所有者必须是超级用户，因此实际上将绕过所有者检查。但是将来可能会改变。）</target>
        </trans-unit>
        <trans-unit id="fcf405f07e7e1cd6574b23914c55360281a218b4" translate="yes" xml:space="preserve">
          <source>You must own the table on which the trigger acts to be allowed to change its properties.</source>
          <target state="translated">你必须拥有触发器所作用的表,才能允许改变它的属性。</target>
        </trans-unit>
        <trans-unit id="b3ea6ee180cd5e6ed5b2a16c0c2bbd450f2133e6" translate="yes" xml:space="preserve">
          <source>You must own the table to use &lt;code&gt;ALTER FOREIGN TABLE&lt;/code&gt;. To change the schema of a foreign table, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the table's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the table. However, a superuser can alter ownership of any table anyway.) To add a column or alter a column type, you must also have &lt;code&gt;USAGE&lt;/code&gt; privilege on the data type.</source>
          <target state="translated">您必须拥有该表才能使用 &lt;code&gt;ALTER FOREIGN TABLE&lt;/code&gt; 。要更改外部表的架构，您还必须对新架构具有 &lt;code&gt;CREATE&lt;/code&gt; 特权。要更改所有者，您还必须是新拥有角色的直接或间接成员，并且该角色必须对表的架构具有 &lt;code&gt;CREATE&lt;/code&gt; 特权。 （这些限制规定，更改所有者不会通过删除并重新创建表来执行您无法做的任何事情。但是，超级用户仍然可以更改任何表的所有权。）要添加列或更改列类型，您必须在数据类型上也具有 &lt;code&gt;USAGE&lt;/code&gt; 特权。</target>
        </trans-unit>
        <trans-unit id="0ec11d641723946e6db98f0517abce2857c0ddb6" translate="yes" xml:space="preserve">
          <source>You must own the table to use &lt;code&gt;ALTER TABLE&lt;/code&gt;. To change the schema or tablespace of a table, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema or tablespace. To add the table as a new child of a parent table, you must own the parent table as well. Also, to attach a table as a new partition of the table, you must own the table being attached. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the table's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the table. However, a superuser can alter ownership of any table anyway.) To add a column or alter a column type or use the &lt;code&gt;OF&lt;/code&gt; clause, you must also have &lt;code&gt;USAGE&lt;/code&gt; privilege on the data type.</source>
          <target state="translated">您必须拥有该表才能使用 &lt;code&gt;ALTER TABLE&lt;/code&gt; 。要更改表的架构或表空间，您还必须对新架构或表空间具有 &lt;code&gt;CREATE&lt;/code&gt; 特权。要将表添加为父表的新子级，您还必须拥有父表。另外，要将表作为表的新分区附加，您必须拥有要附加的表。要更改所有者，您还必须是新拥有角色的直接或间接成员，并且该角色必须对表的架构具有 &lt;code&gt;CREATE&lt;/code&gt; 特权。 （这些限制规定，更改所有者不能通过删除并重新创建表来完成您无法做的任何事情。但是，超级用户仍然可以更改任何表的所有权。）要添加列或更改列类型，或使用 &lt;code&gt;OF&lt;/code&gt; 子句，您还必须对数据类型具有 &lt;code&gt;USAGE&lt;/code&gt; 特权。</target>
        </trans-unit>
        <trans-unit id="b208c35edf5cc5dc00f7bfea3242b7d2ef5016a5" translate="yes" xml:space="preserve">
          <source>You must own the tablespace to change the definition of a tablespace. To alter the owner, you must also be a direct or indirect member of the new owning role. (Note that superusers have these privileges automatically.)</source>
          <target state="translated">您必须拥有表空间,才能更改表空间的定义。要改变所有者,您还必须是新的所有者角色的直接或间接成员。注意,超级用户自动拥有这些权限)。</target>
        </trans-unit>
        <trans-unit id="bb0b957526a357fbf1b5dba72d0747095b82b01d" translate="yes" xml:space="preserve">
          <source>You must own the type to use &lt;code&gt;ALTER TYPE&lt;/code&gt;. To change the schema of a type, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the type's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the type. However, a superuser can alter ownership of any type anyway.) To add an attribute or alter an attribute type, you must also have &lt;code&gt;USAGE&lt;/code&gt; privilege on the attribute's data type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43a595550cf8e4892a3f9ade890ea91fd323c045" translate="yes" xml:space="preserve">
          <source>You must own the type to use &lt;code&gt;ALTER TYPE&lt;/code&gt;. To change the schema of a type, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the type's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the type. However, a superuser can alter ownership of any type anyway.) To add an attribute or alter an attribute type, you must also have &lt;code&gt;USAGE&lt;/code&gt; privilege on the data type.</source>
          <target state="translated">您必须拥有类型才能使用 &lt;code&gt;ALTER TYPE&lt;/code&gt; 。要更改类型的架构，还必须对新架构具有 &lt;code&gt;CREATE&lt;/code&gt; 特权。要更改所有者，您还必须是新拥有角色的直接或间接成员，并且该角色必须对类型的架构具有 &lt;code&gt;CREATE&lt;/code&gt; 特权。（这些限制规定，更改所有者不能通过删除并重新创建类型来完成您无法做的任何事情。但是，超级用户仍然可以更改任何类型的所有权。）要添加属性或更改属性类型，您必须在数据类型上也具有 &lt;code&gt;USAGE&lt;/code&gt; 特权。</target>
        </trans-unit>
        <trans-unit id="fcbfaecbde4a2455af73d870203e3398469ff416" translate="yes" xml:space="preserve">
          <source>You must own the view to use &lt;code&gt;ALTER VIEW&lt;/code&gt;. To change a view's schema, you must also have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new schema. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the view's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the view. However, a superuser can alter ownership of any view anyway.)</source>
          <target state="translated">您必须拥有视图才能使用 &lt;code&gt;ALTER VIEW&lt;/code&gt; 。要更改视图的架构，您还必须对新架构具有 &lt;code&gt;CREATE&lt;/code&gt; 特权。要更改所有者，您还必须是新拥有角色的直接或间接成员，并且该角色必须对视图的架构具有 &lt;code&gt;CREATE&lt;/code&gt; 特权。（这些限制规定，更改所有者不能通过删除并重新创建视图来完成您无法做的任何事情。但是，超级用户仍然可以更改任何视图的所有权。）</target>
        </trans-unit>
        <trans-unit id="4911aa708898e67357c9d052b13bb6ead7673cb0" translate="yes" xml:space="preserve">
          <source>You need to reboot for the changes to take effect. See also &lt;a href=&quot;http://sunsite.uakom.sk/sunworldonline/swol-09-1997/swol-09-insidesolaris.html&quot;&gt;http://sunsite.uakom.sk/sunworldonline/swol-09-1997/swol-09-insidesolaris.html&lt;/a&gt; for information on shared memory under older versions of Solaris.</source>
          <target state="translated">您需要重新启动才能使更改生效。另请参见&lt;a href=&quot;http://sunsite.uakom.sk/sunworldonline/swol-09-1997/swol-09-insidesolaris.html&quot;&gt;http://sunsite.uakom.sk/sunworldonline/swol-09-1997/swol-09-insidesolaris.html，&lt;/a&gt;以获取有关旧版本Solaris下共享内存的信息。</target>
        </trans-unit>
        <trans-unit id="fab91ed3926641d5859d776177b64f5776bb444d" translate="yes" xml:space="preserve">
          <source>You need to use &lt;code&gt;dearmor()&lt;/code&gt; on these keys before giving them to the PGP functions. Or if you can handle binary data, you can drop &lt;code&gt;-a&lt;/code&gt; from the command.</source>
          <target state="translated">在将它们提供给PGP函数之前，需要在这些键上使用 &lt;code&gt;dearmor()&lt;/code&gt; 。或者，如果可以处理二进制数据，则可以从命令中删除 &lt;code&gt;-a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="329e6d57552f34bb2c8cbc84c71a4150ac977a8a" translate="yes" xml:space="preserve">
          <source>You probably want to start up &lt;code&gt;psql&lt;/code&gt; to try the examples in this tutorial. It can be activated for the &lt;code&gt;mydb&lt;/code&gt; database by typing the command:</source>
          <target state="translated">您可能想启动 &lt;code&gt;psql&lt;/code&gt; 尝试本教程中的示例。可以通过键入以下命令为 &lt;code&gt;mydb&lt;/code&gt; 数据库激活它：</target>
        </trans-unit>
        <trans-unit id="6e22ef5923c1fd5594bbdb16bda1e16d0fcc7df3" translate="yes" xml:space="preserve">
          <source>You should also consider setting &lt;code&gt;hot_standby_feedback&lt;/code&gt; on standby server(s) as an alternative to using this parameter.</source>
          <target state="translated">您还应该考虑在备用服务器上设置 &lt;code&gt;hot_standby_feedback&lt;/code&gt; ，作为使用此参数的替代方法。</target>
        </trans-unit>
        <trans-unit id="abf0f469a9c924ec822fbdcdda37276bcd973b00" translate="yes" xml:space="preserve">
          <source>You should at this point be wondering how the input and output functions can be declared to have results or arguments of the new type, when they have to be created before the new type can be created. The answer is that the type should first be defined as a &lt;em&gt;shell type&lt;/em&gt;, which is a placeholder type that has no properties except a name and an owner. This is done by issuing the command &lt;code&gt;CREATE TYPE name&lt;/code&gt;, with no additional parameters. Then the C I/O functions can be defined referencing the shell type. Finally, &lt;code&gt;CREATE TYPE&lt;/code&gt; with a full definition replaces the shell entry with a complete, valid type definition, after which the new type can be used normally.</source>
          <target state="translated">此时，您应该想知道如何在必须创建新类型之前将输入和输出函数声明为具有新类型的结果或参数的情况。答案是该类型应首先定义为&lt;em&gt;shell type&lt;/em&gt;，这是一个占位符类型，除了名称和所有者外，没有其他属性。这是通过发出命令 &lt;code&gt;CREATE TYPE name&lt;/code&gt; 来完成的，没有附加参数。然后可以参考外壳类型定义CI / O功能。最后，具有完整定义的 &lt;code&gt;CREATE TYPE&lt;/code&gt; 将Shell条目替换为完整的有效类型定义，此后可以正常使用新类型。</target>
        </trans-unit>
        <trans-unit id="62998832a31a93f392b8c5c32a45b2a0ab95bec2" translate="yes" xml:space="preserve">
          <source>You should consider that the network bandwidth must be higher than the rate of generation of WAL data.</source>
          <target state="translated">你应该考虑到网络带宽必须高于WAL数据的生成速率。</target>
        </trans-unit>
        <trans-unit id="43179d16a3a417045be109f728f3b3a1fb7c1178" translate="yes" xml:space="preserve">
          <source>You should remember that DTrace scripts need to be carefully written and debugged, otherwise the trace information collected might be meaningless. In most cases where problems are found it is the instrumentation that is at fault, not the underlying system. When discussing information found using dynamic tracing, be sure to enclose the script used to allow that too to be checked and discussed.</source>
          <target state="translated">您应该记住,DTrace脚本需要仔细编写和调试,否则收集到的跟踪信息可能毫无意义。在大多数情况下,发现问题的是仪器设备,而不是底层系统。在讨论使用动态跟踪发现的信息时,一定要附上使用的脚本,以便也能检查和讨论。</target>
        </trans-unit>
        <trans-unit id="3bf69a6d0ffb8bac8b279e39a485a02a700714e9" translate="yes" xml:space="preserve">
          <source>You should take care that the data types specified for a probe's parameters match the data types of the variables used in the macro. Otherwise, you will get compilation errors.</source>
          <target state="translated">您应该注意为探针参数指定的数据类型与宏中使用的变量的数据类型相匹配。否则,你会得到编译错误。</target>
        </trans-unit>
        <trans-unit id="d04a892bbd8087c24b67b0ef9b1ba084ecd5f255" translate="yes" xml:space="preserve">
          <source>You should, however, omit from the backup the files within the cluster's &lt;code&gt;pg_wal/&lt;/code&gt; subdirectory. This slight adjustment is worthwhile because it reduces the risk of mistakes when restoring. This is easy to arrange if &lt;code&gt;pg_wal/&lt;/code&gt; is a symbolic link pointing to someplace outside the cluster directory, which is a common setup anyway for performance reasons. You might also want to exclude &lt;code&gt;postmaster.pid&lt;/code&gt; and &lt;code&gt;postmaster.opts&lt;/code&gt;, which record information about the running postmaster, not about the postmaster which will eventually use this backup. (These files can confuse pg_ctl.)</source>
          <target state="translated">但是，您应该从备份中忽略群集的 &lt;code&gt;pg_wal/&lt;/code&gt; 子目录中的文件。这种轻微的调整是值得的，因为它减少了还原时出错的风险。如果 &lt;code&gt;pg_wal/&lt;/code&gt; 是指向群集目录之外某个地方的符号链接，则这很容易安排，出于性能原因，这是一种常见的设置。您可能还希望排除 &lt;code&gt;postmaster.pid&lt;/code&gt; 和 &lt;code&gt;postmaster.opts&lt;/code&gt; ，它们记录有关正在运行的postmaster的信息，而不是有关最终将使用此备份的postmaster的信息。 （这些文件会混淆pg_ctl。）</target>
        </trans-unit>
        <trans-unit id="f688c2bcf87c6522b972dcd5d1a0d98122829c3b" translate="yes" xml:space="preserve">
          <source>You use the &lt;a href=&quot;sql-delete&quot;&gt;DELETE&lt;/a&gt; command to remove rows; the syntax is very similar to the &lt;code&gt;UPDATE&lt;/code&gt; command. For instance, to remove all rows from the products table that have a price of 10, use:</source>
          <target state="translated">您使用&lt;a href=&quot;sql-delete&quot;&gt;DELETE&lt;/a&gt;命令删除行；语法与 &lt;code&gt;UPDATE&lt;/code&gt; 命令非常相似。例如，要从产品表中删除价格为10的所有行，请使用：</target>
        </trans-unit>
        <trans-unit id="c8d44004f1a1375d285a996132364e5a09cd0aa9" translate="yes" xml:space="preserve">
          <source>You usually only need to set this parameter in complex re-recovery situations, where you need to return to a state that itself was reached after a point-in-time recovery. See &lt;a href=&quot;continuous-archiving#BACKUP-TIMELINES&quot;&gt;Section 25.3.5&lt;/a&gt; for discussion.</source>
          <target state="translated">通常，您仅需要在复杂的重新恢复情况下设置此参数，在这种情况下，您需要返回到在时间点恢复后已达到自身状态。有关讨论，请参见&lt;a href=&quot;continuous-archiving#BACKUP-TIMELINES&quot;&gt;第25.3.5节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1c0b4770f607d09fa317c5dc06f4c40416fa8fa6" translate="yes" xml:space="preserve">
          <source>You will encounter this style of abbreviating quite frequently.</source>
          <target state="translated">你会经常遇到这种风格的缩写。</target>
        </trans-unit>
        <trans-unit id="f2689ccc464a2d160017022cb703ee291e2f949e" translate="yes" xml:space="preserve">
          <source>You will sometimes need to add parentheses when using combinations of binary and unary operators. For instance:</source>
          <target state="translated">在使用二元和单元运算符的组合时,您有时需要添加括号。例如</target>
        </trans-unit>
        <trans-unit id="4f96b903666683fcb600721163b7537153b2acf3" translate="yes" xml:space="preserve">
          <source>You will then need to use gunzip during recovery:</source>
          <target state="translated">然后你需要在恢复过程中使用gunzip。</target>
        </trans-unit>
        <trans-unit id="76a9773cd5b34137343c2a3db898da05e9e5088f" translate="yes" xml:space="preserve">
          <source>You will usually want to increase &lt;code&gt;kern.ipc.semmni&lt;/code&gt; and &lt;code&gt;kern.ipc.semmns&lt;/code&gt;, as NetBSD's default settings for these are uncomfortably small.</source>
          <target state="translated">通常，您将需要增加 &lt;code&gt;kern.ipc.semmni&lt;/code&gt; 和 &lt;code&gt;kern.ipc.semmns&lt;/code&gt; ，因为NetBSD的默认设置太小了。</target>
        </trans-unit>
        <trans-unit id="4d7dd316d288d7dc8cab74686babd6da0f71907c" translate="yes" xml:space="preserve">
          <source>You will usually want to increase &lt;code&gt;kern.seminfo.semmni&lt;/code&gt; and &lt;code&gt;kern.seminfo.semmns&lt;/code&gt;, as OpenBSD's default settings for these are uncomfortably small.</source>
          <target state="translated">通常，您将需要增加 &lt;code&gt;kern.seminfo.semmni&lt;/code&gt; 和 &lt;code&gt;kern.seminfo.semmns&lt;/code&gt; ，因为OpenBSD的默认设置太小了。</target>
        </trans-unit>
        <trans-unit id="2609a6d5763d68ee7a0a0d2d4b45f307e6ae5ffd" translate="yes" xml:space="preserve">
          <source>Zero-Column Tables</source>
          <target state="translated">零列表</target>
        </trans-unit>
        <trans-unit id="30c11554a2b9e71795733af27503dd2000ac35f9" translate="yes" xml:space="preserve">
          <source>Zipfian-distributed random integer in &lt;code&gt;[lb, ub]&lt;/code&gt;, see below</source>
          <target state="translated">Zipfian分布的随机整数 &lt;code&gt;[lb, ub]&lt;/code&gt; ，请参见下文</target>
        </trans-unit>
        <trans-unit id="329669d49d5a7c00789e68977fd4b07da1d077c8" translate="yes" xml:space="preserve">
          <source>[ &lt;code&gt;ENCRYPTED&lt;/code&gt; ] &lt;code&gt;PASSWORD&lt;/code&gt; '&lt;code&gt;password&lt;/code&gt;'&lt;code&gt;PASSWORD NULL&lt;/code&gt;</source>
          <target state="translated">[ &lt;code&gt;ENCRYPTED&lt;/code&gt; ] &lt;code&gt;PASSWORD&lt;/code&gt; ' &lt;code&gt;password&lt;/code&gt; ' &lt;code&gt;PASSWORD NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="689b11d9bddde6c1d7ee8e5eb112418a0978460f" translate="yes" xml:space="preserve">
          <source>[(x1,y1),...]</source>
          <target state="translated">[(x1,y1),...]</target>
        </trans-unit>
        <trans-unit id="56bed60529c445af77ea7362851c52890ef3de9a" translate="yes" xml:space="preserve">
          <source>[a, b] is entirely to the left of [c, d]. That is, [a, b] &amp;lt;&amp;lt; [c, d] is true if b &amp;lt; c and false otherwise.</source>
          <target state="translated">[a，b]完全位于[c，d]的左侧。也就是说，如果b &amp;lt;c，则[a，b] &amp;lt;&amp;lt; [c，d]为true，否则为false。</target>
        </trans-unit>
        <trans-unit id="46347467de76083a1f3b3ab7c5a273c56dcfd8f4" translate="yes" xml:space="preserve">
          <source>[a, b] is entirely to the right of [c, d]. That is, [a, b] &amp;gt;&amp;gt; [c, d] is true if a &amp;gt; d and false otherwise.</source>
          <target state="translated">[a，b]完全在[c，d]的右侧。也就是说，如果a&amp;gt; d，则[a，b] &amp;gt;&amp;gt; [c，d]为true，否则为false。</target>
        </trans-unit>
        <trans-unit id="038cf8dbb178850257e9230060d8fcef7ddfb5a0" translate="yes" xml:space="preserve">
          <source>[elma04]</source>
          <target state="translated">[elma04]</target>
        </trans-unit>
        <trans-unit id="2b5f5b947ce4c4c7f099a0a2d735357e09310b58" translate="yes" xml:space="preserve">
          <source>[fong]</source>
          <target state="translated">[fong]</target>
        </trans-unit>
        <trans-unit id="5c07a6ad2db9480747f4d609fb47951588166180" translate="yes" xml:space="preserve">
          <source>a &lt;em&gt;bracket expression&lt;/em&gt;, matching any one of the &lt;code&gt;chars&lt;/code&gt; (see &lt;a href=&quot;functions-matching#POSIX-BRACKET-EXPRESSIONS&quot;&gt;Section 9.7.3.2&lt;/a&gt; for more detail)</source>
          <target state="translated">方&lt;em&gt;括号表达式&lt;/em&gt;，与任何一个 &lt;code&gt;chars&lt;/code&gt; 匹配（有关更多详细信息，请参见&lt;a href=&quot;functions-matching#POSIX-BRACKET-EXPRESSIONS&quot;&gt;9.7.3.2节&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="5c2a04f8a25082f47f2b1b62420d51d9e2586092" translate="yes" xml:space="preserve">
          <source>a closed path?</source>
          <target state="translated">一条封闭的道路?</target>
        </trans-unit>
        <trans-unit id="4f837508b52bb0f6f0c188e3d8239bb66f7f30b3" translate="yes" xml:space="preserve">
          <source>a label beginning with the case-insensitive prefix &lt;code&gt;sport&lt;/code&gt;</source>
          <target state="translated">以不区分大小写的前缀 &lt;code&gt;sport&lt;/code&gt; 开头的标签</target>
        </trans-unit>
        <trans-unit id="8b52f02d3dbf1419017e235881c6561ac7603288" translate="yes" xml:space="preserve">
          <source>a sequence of 0 or 1 matches of the atom</source>
          <target state="translated">匹配的0或1个原子序列。</target>
        </trans-unit>
        <trans-unit id="c789ac60ffb3a4856f62a0cc113a4a9eb99a3e78" translate="yes" xml:space="preserve">
          <source>a sequence of 0 or more matches of the atom</source>
          <target state="translated">0个或更多匹配的原子序列。</target>
        </trans-unit>
        <trans-unit id="37235ff249a4a2dc93bed2d89eba1468f3102441" translate="yes" xml:space="preserve">
          <source>a sequence of 1 or more matches of the atom</source>
          <target state="translated">1个或多个匹配的原子序列。</target>
        </trans-unit>
        <trans-unit id="f4d6892681b0f2c2f68672a4ea2ebea56a26fb7c" translate="yes" xml:space="preserve">
          <source>a sequence of &lt;code&gt;m&lt;/code&gt; or more matches of the atom</source>
          <target state="translated">原子的 &lt;code&gt;m&lt;/code&gt; 个或更多匹配的序列</target>
        </trans-unit>
        <trans-unit id="d6eb7a7a662e02de4e455a3d9cb22b1e5cbc9fd0" translate="yes" xml:space="preserve">
          <source>a sequence of &lt;code&gt;m&lt;/code&gt; through &lt;code&gt;n&lt;/code&gt; (inclusive) matches of the atom; &lt;code&gt;m&lt;/code&gt; cannot exceed &lt;code&gt;n&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;m&lt;/code&gt; 到 &lt;code&gt;n&lt;/code&gt; 个（包括）原子匹配的序列； &lt;code&gt;m&lt;/code&gt; 不能超过 &lt;code&gt;n&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a1befdcf13a2caa739dbb24cca880bbc955a58b" translate="yes" xml:space="preserve">
          <source>a sequence of exactly &lt;code&gt;m&lt;/code&gt; matches of the atom</source>
          <target state="translated">原子正好 &lt;code&gt;m&lt;/code&gt; 个匹配的序列</target>
        </trans-unit>
        <trans-unit id="42e244f289cb2901a2850fc0e292f5c6110aec21" translate="yes" xml:space="preserve">
          <source>a single lexeme with the &lt;code&gt;TSL_FILTER&lt;/code&gt; flag set, to replace the original token with a new token to be passed to subsequent dictionaries (a dictionary that does this is called a &lt;em&gt;filtering dictionary&lt;/em&gt;)</source>
          <target state="translated">设置了 &lt;code&gt;TSL_FILTER&lt;/code&gt; 标志的单个词位，以将新的令牌替换为要传递给后续字典的新令牌（执行此操作的&lt;em&gt;字典&lt;/em&gt;称为&lt;em&gt;过滤字典&lt;/em&gt;）</target>
        </trans-unit>
        <trans-unit id="39c985af6407cb40e9f21b877cb2f14f1ab7445e" translate="yes" xml:space="preserve">
          <source>a white-space character or &lt;code&gt;#&lt;/code&gt; preceded by &lt;code&gt;\&lt;/code&gt; is retained</source>
          <target state="translated">保留空格字符或以 &lt;code&gt;\&lt;/code&gt; 开头的 &lt;code&gt;#&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c79c0a316e1b5d5dfe7325f52987831549fe62de" translate="yes" xml:space="preserve">
          <source>abbreviated capitalized day name (3 chars in English, localized lengths vary)</source>
          <target state="translated">缩写的大写日名(3个英文字符,各地长度不一)。</target>
        </trans-unit>
        <trans-unit id="264cda486a8f189eb4b75e086f6d14582addebc5" translate="yes" xml:space="preserve">
          <source>abbreviated capitalized month name (3 chars in English, localized lengths vary)</source>
          <target state="translated">缩写的大写月份名称(3个英文字符,当地化长度不一</target>
        </trans-unit>
        <trans-unit id="ece4f8ac5a0911464c77304a7d93e8b052502ee1" translate="yes" xml:space="preserve">
          <source>abbreviated display format as text</source>
          <target state="translated">缩略显示格式</target>
        </trans-unit>
        <trans-unit id="88b965dacddbd5c3be3568170a1a398601e53a48" translate="yes" xml:space="preserve">
          <source>abbreviated lower case day name (3 chars in English, localized lengths vary)</source>
          <target state="translated">缩写的小写日名(3个英文字符,各地长度不同)</target>
        </trans-unit>
        <trans-unit id="9186b18dd65f270c46192797d4cb755071c05c1e" translate="yes" xml:space="preserve">
          <source>abbreviated lower case month name (3 chars in English, localized lengths vary)</source>
          <target state="translated">缩写的小写月名(3个英文字符,各地长度不同)</target>
        </trans-unit>
        <trans-unit id="a3f61c541f5db806cb405bf2892b6722718fec31" translate="yes" xml:space="preserve">
          <source>abbreviated upper case day name (3 chars in English, localized lengths vary)</source>
          <target state="translated">缩写的大写日名(3个英文字符,各地长度不同)</target>
        </trans-unit>
        <trans-unit id="7577f3a97383fa6c0292570407f15fbf40857e56" translate="yes" xml:space="preserve">
          <source>abbreviated upper case month name (3 chars in English, localized lengths vary)</source>
          <target state="translated">缩写的大写月名(3个英文字符,各地长度不一</target>
        </trans-unit>
        <trans-unit id="33f31413199ddb62fc17b8f2bed78e9d010e94da" translate="yes" xml:space="preserve">
          <source>absolute value</source>
          <target state="translated">绝对值</target>
        </trans-unit>
        <trans-unit id="de8436d989e265b7b258d6602654167f651db67b" translate="yes" xml:space="preserve">
          <source>access method operator classes</source>
          <target state="translated">访问方法操作类</target>
        </trans-unit>
        <trans-unit id="639212fb06d8ccc51f13d82301ca6b66a2deb947" translate="yes" xml:space="preserve">
          <source>access method operator families</source>
          <target state="translated">访问方法操作族</target>
        </trans-unit>
        <trans-unit id="a5886a24a9cd7f64cdec22dc5f1b0dad9949c443" translate="yes" xml:space="preserve">
          <source>access method operators</source>
          <target state="translated">访问方法操作者</target>
        </trans-unit>
        <trans-unit id="cce1015f8d299b67b710b93d76b497f49fa98565" translate="yes" xml:space="preserve">
          <source>access method support functions</source>
          <target state="translated">访问方法支持功能</target>
        </trans-unit>
        <trans-unit id="b9cfb8c8675bb466671371ec06207e1c430329f4" translate="yes" xml:space="preserve">
          <source>adding affix</source>
          <target state="translated">补缀</target>
        </trans-unit>
        <trans-unit id="c3805175370d19c334b59f45b87343b9f2b7f5e1" translate="yes" xml:space="preserve">
          <source>addition</source>
          <target state="translated">addition</target>
        </trans-unit>
        <trans-unit id="9118866496dfbc2e597505390a41e74349ab5152" translate="yes" xml:space="preserve">
          <source>addition, subtraction</source>
          <target state="translated">加减法</target>
        </trans-unit>
        <trans-unit id="aaf09a4b156ac6da8c98f72704c7cee1497e7d6f" translate="yes" xml:space="preserve">
          <source>additional foreign table information</source>
          <target state="translated">额外的外表信息</target>
        </trans-unit>
        <trans-unit id="1a32619c4b1c2c834145f692705708f779bed83a" translate="yes" xml:space="preserve">
          <source>additional index information</source>
          <target state="translated">补充索引信息</target>
        </trans-unit>
        <trans-unit id="de48f56b01bcd91fd19904d21fc567f7aeb73b16" translate="yes" xml:space="preserve">
          <source>address of the local connection</source>
          <target state="translated">本地连接地址</target>
        </trans-unit>
        <trans-unit id="95dd78f31f2d2267d2022e6763c1fb744bbf23ea" translate="yes" xml:space="preserve">
          <source>address of the remote connection</source>
          <target state="translated">远程连接地址</target>
        </trans-unit>
        <trans-unit id="0e18d863cc787a1080e11d6aad8c84c3d163b704" translate="yes" xml:space="preserve">
          <source>adminpack</source>
          <target state="translated">adminpack</target>
        </trans-unit>
        <trans-unit id="bccf7370fc6bc7e65ebb00bcd447b407dc6e3ec1" translate="yes" xml:space="preserve">
          <source>aggregate functions</source>
          <target state="translated">汇总函数</target>
        </trans-unit>
        <trans-unit id="5707e56794034492e28fb802f0929edc22148ae3" translate="yes" xml:space="preserve">
          <source>aggregates name/value pairs as a JSON object; values can be null, but not names</source>
          <target state="translated">将名称/值对聚合为JSON对象;值可以为空,但名称不能为空。</target>
        </trans-unit>
        <trans-unit id="100b0a2fce8f87a6bf417e59568b60def0dd95ed" translate="yes" xml:space="preserve">
          <source>aggregates values, including nulls, as a JSON array</source>
          <target state="translated">将值(包括空值)汇总为JSON数组。</target>
        </trans-unit>
        <trans-unit id="27428a051111f05b13f941652832e7ba4a594fed" translate="yes" xml:space="preserve">
          <source>alert (bell) character, as in C</source>
          <target state="translated">警示字</target>
        </trans-unit>
        <trans-unit id="8a97bf0012dbebc5bcefd88a6e6ca0df50de1524" translate="yes" xml:space="preserve">
          <source>alias for &lt;code&gt;hash_murmur2()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hash_murmur2()&lt;/code&gt; 的别名</target>
        </trans-unit>
        <trans-unit id="e3acb7916bd347d132eed28f72c60ded2aae1942" translate="yes" xml:space="preserve">
          <source>all other native and user-defined operators</source>
          <target state="translated">所有其他本地和用户定义的操作符</target>
        </trans-unit>
        <trans-unit id="15100289fd2a2926dbfc0362c8c82f216aafdb18" translate="yes" xml:space="preserve">
          <source>amcheck</source>
          <target state="translated">amcheck</target>
        </trans-unit>
        <trans-unit id="663bae22b8d6ed1b0c5424f47e75478c4fc96f3e" translate="yes" xml:space="preserve">
          <source>an array of lexemes if the input token is known to the dictionary (notice that one token can produce more than one lexeme)</source>
          <target state="translated">如果输入的标记是字典已知的,则是一个词组的数组(注意一个标记可以产生多个词组</target>
        </trans-unit>
        <trans-unit id="232a7414ddb1870267de0ac5d074d426c7090d4d" translate="yes" xml:space="preserve">
          <source>an empty array if the dictionary knows the token, but it is a stop word</source>
          <target state="translated">一个空数组,如果字典知道该标记,但它是一个停止符。</target>
        </trans-unit>
        <trans-unit id="4a50c2a4d787c9ec20847e24d511e5f7edd971bf" translate="yes" xml:space="preserve">
          <source>an integer between &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;10&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; 到 &lt;code&gt;10&lt;/code&gt; 之间的整数</target>
        </trans-unit>
        <trans-unit id="0b6686e81b37171a7ea6080018ce0ae5e675c63c" translate="yes" xml:space="preserve">
          <source>an open path?</source>
          <target state="translated">一个开放的路径?</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="195ca7bc7f18fd5ef1b0e2c3a54dd46b02d4927d" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;frame_exclusion&lt;/code&gt; can be one of</source>
          <target state="translated">并且 &lt;code&gt;frame_exclusion&lt;/code&gt; 可以是以下之一</target>
        </trans-unit>
        <trans-unit id="b061bc6b05f4e30ad67fd83ca835fa19bda9bb24" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;mode&lt;/code&gt; is one of:</source>
          <target state="translated">和 &lt;code&gt;mode&lt;/code&gt; 是以下之一：</target>
        </trans-unit>
        <trans-unit id="dfcc9edf53bd479c53a758f8cd20ae723fac9500" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;padding&lt;/code&gt; is one of:</source>
          <target state="translated">和 &lt;code&gt;padding&lt;/code&gt; 是以下之一：</target>
        </trans-unit>
        <trans-unit id="1f043826d65c29cd9d06435f4c3f4c44886caf1f" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;psql&lt;/code&gt; will quit and return you to your command shell. (For more internal commands, type &lt;code&gt;\?&lt;/code&gt; at the &lt;code&gt;psql&lt;/code&gt; prompt.) The full capabilities of &lt;code&gt;psql&lt;/code&gt; are documented in &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt;. In this tutorial we will not use these features explicitly, but you can use them yourself when it is helpful.</source>
          <target state="translated">和 &lt;code&gt;psql&lt;/code&gt; 将退出并回到你的命令行shell。（有关详细的内部命令，类型 &lt;code&gt;\?&lt;/code&gt; 在 &lt;code&gt;psql&lt;/code&gt; 提示。）的全部功能 &lt;code&gt;psql&lt;/code&gt; 记录在&lt;a href=&quot;app-psql&quot;&gt;PSQL&lt;/a&gt;。在本教程中，我们将不会显式使用这些功能，但是如果有帮助，您可以自己使用它们。</target>
        </trans-unit>
        <trans-unit id="3badfcd96666510617917bc44cf260ce650da948" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;t2&lt;/code&gt;:</source>
          <target state="translated">和 &lt;code&gt;t2&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="64f54598fc8b10700b447590aedbe9802f2cf914" translate="yes" xml:space="preserve">
          <source>and Collations</source>
          <target state="translated">和整理</target>
        </trans-unit>
        <trans-unit id="097ca12344ffcd3926b70cf91232fc017a3d35e9" translate="yes" xml:space="preserve">
          <source>and ORDER BY</source>
          <target state="translated">并按顺序排列</target>
        </trans-unit>
        <trans-unit id="a41a99f30db5c8c73bb765ef058446c9ffe876c5" translate="yes" xml:space="preserve">
          <source>and all the dependent objects will be removed, as will any objects that depend on them, recursively. In this case, it doesn't remove the orders table, it only removes the foreign key constraint. It stops there because nothing depends on the foreign key constraint. (If you want to check what &lt;code&gt;DROP ... CASCADE&lt;/code&gt; will do, run &lt;code&gt;DROP&lt;/code&gt; without &lt;code&gt;CASCADE&lt;/code&gt; and read the &lt;code&gt;DETAIL&lt;/code&gt; output.)</source>
          <target state="translated">并将所有依赖对象以及依赖于它们的任何对象递归删除。在这种情况下，它不会删除orders表，而只会删除外键约束。它在那里停止，因为没有任何东西依赖于外键约束。 （如果要检查 &lt;code&gt;DROP ... CASCADE&lt;/code&gt; 将执行的操作，请在不使用 &lt;code&gt;CASCADE&lt;/code&gt; 的情况下运行 &lt;code&gt;DROP&lt;/code&gt; 并读取 &lt;code&gt;DETAIL&lt;/code&gt; 输出。）</target>
        </trans-unit>
        <trans-unit id="91ded08e1c2fb163ac112ff991a147382d928feb" translate="yes" xml:space="preserve">
          <source>and can appear anywhere a &lt;code&gt;SELECT&lt;/code&gt; can. For example, you can use it as part of a &lt;code&gt;UNION&lt;/code&gt;, or attach a &lt;code&gt;sort_specification&lt;/code&gt; (&lt;code&gt;ORDER BY&lt;/code&gt;, &lt;code&gt;LIMIT&lt;/code&gt;, and/or &lt;code&gt;OFFSET&lt;/code&gt;) to it. &lt;code&gt;VALUES&lt;/code&gt; is most commonly used as the data source in an &lt;code&gt;INSERT&lt;/code&gt; command, and next most commonly as a subquery.</source>
          <target state="translated">并且可以出现在 &lt;code&gt;SELECT&lt;/code&gt; 可以显示的任何位置。例如，您可以将其用作 &lt;code&gt;UNION&lt;/code&gt; 的一部分，或将 &lt;code&gt;sort_specification&lt;/code&gt; （ &lt;code&gt;ORDER BY&lt;/code&gt; ， &lt;code&gt;LIMIT&lt;/code&gt; 和/或 &lt;code&gt;OFFSET&lt;/code&gt; ）附加到它。 &lt;code&gt;VALUES&lt;/code&gt; 最常在 &lt;code&gt;INSERT&lt;/code&gt; 命令中用作数据源，其次最常用作子查询。</target>
        </trans-unit>
        <trans-unit id="463a6cd589d2223d499014d12a55159d1281075e" translate="yes" xml:space="preserve">
          <source>and her transaction is in &lt;code&gt;READ COMMITTED&lt;/code&gt; mode, it is possible for her to see &amp;ldquo;secret from mallory&amp;rdquo;. That happens if her transaction reaches the &lt;code&gt;information&lt;/code&gt; row just after &lt;code&gt;alice&lt;/code&gt;'s does. It blocks waiting for &lt;code&gt;alice&lt;/code&gt;'s transaction to commit, then fetches the updated row contents thanks to the &lt;code&gt;FOR UPDATE&lt;/code&gt; clause. However, it does &lt;em&gt;not&lt;/em&gt; fetch an updated row for the implicit &lt;code&gt;SELECT&lt;/code&gt; from &lt;code&gt;users&lt;/code&gt;, because that sub-&lt;code&gt;SELECT&lt;/code&gt; did not have &lt;code&gt;FOR UPDATE&lt;/code&gt;; instead the &lt;code&gt;users&lt;/code&gt; row is read with the snapshot taken at the start of the query. Therefore, the policy expression tests the old value of &lt;code&gt;mallory&lt;/code&gt;'s privilege level and allows her to see the updated row.</source>
          <target state="translated">并且她的事务处于 &lt;code&gt;READ COMMITTED&lt;/code&gt; 模式下，她可能会看到&amp;ldquo;从马洛里秘密&amp;rdquo;。如果她的交易 &lt;code&gt;alice&lt;/code&gt; 之后到达 &lt;code&gt;information&lt;/code&gt; 行，则会发生这种情况。它阻止等待 &lt;code&gt;alice&lt;/code&gt; 的事务提交，然后借助 &lt;code&gt;FOR UPDATE&lt;/code&gt; 子句获取更新的行内容。然而，它并&lt;em&gt;不能&lt;/em&gt;获取的隐性更新行 &lt;code&gt;SELECT&lt;/code&gt; 从 &lt;code&gt;users&lt;/code&gt; ，因为子 &lt;code&gt;SELECT&lt;/code&gt; 没有 &lt;code&gt;FOR UPDATE&lt;/code&gt; ;而是 &lt;code&gt;users&lt;/code&gt; &lt;em&gt;&lt;/em&gt;在查询开始时读取快照，并获取快照。因此，策略表达式测试了 &lt;code&gt;mallory&lt;/code&gt; 特权级别的旧值，并允许她查看更新的行。</target>
        </trans-unit>
        <trans-unit id="2ddf7473848fa4907e6ee0ff26623f75dfed1f01" translate="yes" xml:space="preserve">
          <source>and next has zero to two labels before</source>
          <target state="translated">和next之前有零到两个标签</target>
        </trans-unit>
        <trans-unit id="d723326824a3836a81d727940bbbaebfea441ace" translate="yes" xml:space="preserve">
          <source>and obtains the result 300, which it inserts in a new row with &lt;code&gt;class&lt;/code&gt;&lt;code&gt;= 1&lt;/code&gt;. Then both transactions try to commit. If either transaction were running at the Repeatable Read isolation level, both would be allowed to commit; but since there is no serial order of execution consistent with the result, using Serializable transactions will allow one transaction to commit and will roll the other back with this message:</source>
          <target state="translated">并获得结果300，并将其插入到 &lt;code&gt;class&lt;/code&gt; &lt;code&gt;= 1&lt;/code&gt; 的新行中。然后，两个事务都尝试提交。如果两个事务都在&amp;ldquo;可重复读取&amp;rdquo;隔离级别上运行，则两个事务都可以提交；但是由于没有与结果一致的串行执行顺序，因此使用Serializable事务将允许提交一个事务，并使用此消息回退另一个事务：</target>
        </trans-unit>
        <trans-unit id="abd292e64f5762adf92489151f65db3a2d25c4cf" translate="yes" xml:space="preserve">
          <source>and overriding the collation of a function or operator call that has locale-sensitive results, for example:</source>
          <target state="translated">并覆盖具有局部敏感结果的函数或运算符调用的整理,例如。</target>
        </trans-unit>
        <trans-unit id="4472b3d78f22b89c61f97b762041a5148f6b86b3" translate="yes" xml:space="preserve">
          <source>and the application issues many queries of the form:</source>
          <target state="translated">和应用程序发出许多查询的形式。</target>
        </trans-unit>
        <trans-unit id="519bfeab6436137fc4443c937b4e2a57a5222950" translate="yes" xml:space="preserve">
          <source>and then ends with a label beginning with &lt;code&gt;Russ&lt;/code&gt; or exactly matching &lt;code&gt;Spain&lt;/code&gt;.</source>
          <target state="translated">然后以 &lt;code&gt;Russ&lt;/code&gt; 开头或完全匹配 &lt;code&gt;Spain&lt;/code&gt; 的标签结尾。</target>
        </trans-unit>
        <trans-unit id="da0d7e15413e88d505f96b30393006166f82a571" translate="yes" xml:space="preserve">
          <source>and then insert the &lt;code&gt;NOT&lt;/code&gt; key word where desired.</source>
          <target state="translated">然后在需要的地方插入 &lt;code&gt;NOT&lt;/code&gt; 关键字。</target>
        </trans-unit>
        <trans-unit id="f550ff82765c7c77442e312860d5c5a6aa4ec136" translate="yes" xml:space="preserve">
          <source>and then inserts the result (30) as the &lt;code&gt;value&lt;/code&gt; in a new row with &lt;code&gt;class&lt;/code&gt;&lt;code&gt;= 2&lt;/code&gt;. Concurrently, serializable transaction B computes:</source>
          <target state="translated">然后将结果（30）作为 &lt;code&gt;value&lt;/code&gt; 插入到 &lt;code&gt;class&lt;/code&gt; &lt;code&gt;= 2&lt;/code&gt; 的新行中。同时，可序列化事务B计算：</target>
        </trans-unit>
        <trans-unit id="d17266916c8a994f2881eb849993c9875639d0c1" translate="yes" xml:space="preserve">
          <source>and then run pg_upgrade with quoted directories, e.g.:</source>
          <target state="translated">然后运行pg_upgrade,并使用引号的目录,例如。</target>
        </trans-unit>
        <trans-unit id="146d654592d3bdf49836fb607a26abdff8dc565f" translate="yes" xml:space="preserve">
          <source>and these representations for the &amp;ldquo;false&amp;rdquo; state:</source>
          <target state="translated">以及这些表示&amp;ldquo; false&amp;rdquo;状态的表示：</target>
        </trans-unit>
        <trans-unit id="a5230bf3ac1fc697c044aa12dc9e2fb2c6ea3dcf" translate="yes" xml:space="preserve">
          <source>and:</source>
          <target state="translated">and:</target>
        </trans-unit>
        <trans-unit id="c5fe0200d1c7a5139bd18fd22268c4ca8bf45e90" translate="yes" xml:space="preserve">
          <source>any</source>
          <target state="translated">any</target>
        </trans-unit>
        <trans-unit id="f0d8476cddfcece7be214ceeeb87fed56a99c5be" translate="yes" xml:space="preserve">
          <source>any OID column</source>
          <target state="translated">任何OID列</target>
        </trans-unit>
        <trans-unit id="776b72d37856a0495e69540bbde0cf0ff74423cc" translate="yes" xml:space="preserve">
          <source>any array type</source>
          <target state="translated">任何数组类型</target>
        </trans-unit>
        <trans-unit id="c8fdfd5cb246da542aaeb9979987b47c98e64395" translate="yes" xml:space="preserve">
          <source>any non-array type</source>
          <target state="translated">任何非数组类型</target>
        </trans-unit>
        <trans-unit id="72433658efe8a2e649ce354eaceeb1954b3d6706" translate="yes" xml:space="preserve">
          <source>any numeric, string, date/time, network, or enum type, or arrays of these types</source>
          <target state="translated">任何数字、字符串、日期/时间、网络或枚举类型,或这些类型的数组。</target>
        </trans-unit>
        <trans-unit id="1d1ab32371b3accbfb7ecab87204e63142da53d2" translate="yes" xml:space="preserve">
          <source>any range type</source>
          <target state="translated">任意范围型</target>
        </trans-unit>
        <trans-unit id="17b1f448b91caed36d022289e6bc4c20cb8cb1bf" translate="yes" xml:space="preserve">
          <source>any sortable type</source>
          <target state="translated">任何可排序类型</target>
        </trans-unit>
        <trans-unit id="fc497c9667b2d21c95e0422a7a79489a554110d8" translate="yes" xml:space="preserve">
          <source>append an element to the beginning of an array</source>
          <target state="translated">在数组的开头添加一个元</target>
        </trans-unit>
        <trans-unit id="8510099a899e6e19ffcdc41786dd5bee38c2a170" translate="yes" xml:space="preserve">
          <source>append an element to the end of an array</source>
          <target state="translated">追加一个元素到数组末尾。</target>
        </trans-unit>
        <trans-unit id="9a48ebf2c2867a717af59a3d046f96e76db2e70a" translate="yes" xml:space="preserve">
          <source>are also of interest, an additional index could be created that supports the &lt;code&gt;&quot;y&quot;&lt;/code&gt; collation, like this:</source>
          <target state="translated">同样令人感兴趣的是，可以创建一个支持 &lt;code&gt;&quot;y&quot;&lt;/code&gt; 排序规则的附加索引，如下所示：</target>
        </trans-unit>
        <trans-unit id="aa4b0695d2fd6cd9abbff5f407b06b97863d61bd" translate="yes" xml:space="preserve">
          <source>are the addresses from the same family?</source>
          <target state="translated">是同一家族的地址吗?</target>
        </trans-unit>
        <trans-unit id="0ae7b878964a32c5aa151b7336192d99e50b6fa5" translate="yes" xml:space="preserve">
          <source>are valid values, which follow the ISO 8601 standard. In addition, the common format:</source>
          <target state="translated">为有效值,遵循ISO 8601标准。此外,通用格式:</target>
        </trans-unit>
        <trans-unit id="699e8ae92ca31d0753b1eacb9fbc3f555d78fbd6" translate="yes" xml:space="preserve">
          <source>area</source>
          <target state="translated">area</target>
        </trans-unit>
        <trans-unit id="b572d4fbffd87db31a54fcc4b02fd6c33f9b05c2" translate="yes" xml:space="preserve">
          <source>array concatenation (right array added to the end of left one)</source>
          <target state="translated">数组串联</target>
        </trans-unit>
        <trans-unit id="1f16a17f620eb69917c63399a0983d0af0fc74f5" translate="yes" xml:space="preserve">
          <source>array element selection</source>
          <target state="translated">阵列元素选择</target>
        </trans-unit>
        <trans-unit id="195b3de97f0176b7d1d976b97a073f956d949127" translate="yes" xml:space="preserve">
          <source>array of sort expression's type</source>
          <target state="translated">排序表达式类型的数组</target>
        </trans-unit>
        <trans-unit id="a9cce9638686dc89b3132c8f4d5d6e72457ed9a4" translate="yes" xml:space="preserve">
          <source>array of the argument type</source>
          <target state="translated">参数类型的数组</target>
        </trans-unit>
        <trans-unit id="c368852a549cff62f53f0d0deed89bc97c0d743b" translate="yes" xml:space="preserve">
          <source>array-to-array concatenation</source>
          <target state="translated">数组对数组连接</target>
        </trans-unit>
        <trans-unit id="f88f7ee63beb76da63ba7e7001aa8cd4317f04f4" translate="yes" xml:space="preserve">
          <source>array-to-element concatenation</source>
          <target state="translated">数组到元素的连接</target>
        </trans-unit>
        <trans-unit id="2c4cd6638cd2c3a0b7a8372b993390a30fda1d5e" translate="yes" xml:space="preserve">
          <source>as a more complicated example. Of course, you could wrap all of this in a view for convenience.</source>
          <target state="translated">作为一个更复杂的例子。当然,为了方便,你可以把所有这些都包在一个视图中。</target>
        </trans-unit>
        <trans-unit id="c3946fc8e2b3dea5bb756fef7515425b6a069b26" translate="yes" xml:space="preserve">
          <source>as above, but the match is not noted for reporting (a &amp;ldquo;non-capturing&amp;rdquo; set of parentheses) (AREs only)</source>
          <target state="translated">如上，但未在报告中注明匹配项（一组&amp;ldquo;非捕获&amp;rdquo;括号）（仅适用于ARE）</target>
        </trans-unit>
        <trans-unit id="44737fbeead1f9bddc0c69fc725d8ac03c45707a" translate="yes" xml:space="preserve">
          <source>as an index-only scan; and this is very attractive if &lt;code&gt;f()&lt;/code&gt; is an expensive-to-compute function. However, PostgreSQL's planner is currently not very smart about such cases. It considers a query to be potentially executable by index-only scan only when all &lt;em&gt;columns&lt;/em&gt; needed by the query are available from the index. In this example, &lt;code&gt;x&lt;/code&gt; is not needed except in the context &lt;code&gt;f(x)&lt;/code&gt;, but the planner does not notice that and concludes that an index-only scan is not possible. If an index-only scan seems sufficiently worthwhile, this can be worked around by adding &lt;code&gt;x&lt;/code&gt; as an included column, for example</source>
          <target state="translated">作为仅索引扫描；如果 &lt;code&gt;f()&lt;/code&gt; 是计算昂贵的函数，则这非常有吸引力。但是，PostgreSQL的计划者目​​前对这种情况不太聪明。仅当查询所需的所有&lt;em&gt;列&lt;/em&gt;都可从索引获得时，它才认为该查询可以通过仅索引扫描执行。在此实例中， &lt;code&gt;x&lt;/code&gt; 是不需要的，除非上下文 &lt;code&gt;f(x)&lt;/code&gt; ，但是被规划不通知，并得出结论，索引仅扫描是不可能的。如果仅索引扫描似乎足够值得，可以通过将 &lt;code&gt;x&lt;/code&gt; 添加为包含列来解决此问题，例如</target>
        </trans-unit>
        <trans-unit id="8fcfdc695e360dde8446f7425d95888b6550157a" translate="yes" xml:space="preserve">
          <source>as if the query were</source>
          <target state="translated">仿佛查询是</target>
        </trans-unit>
        <trans-unit id="a7261a75560cee1649f6ecc0f31279f94dba2bcf" translate="yes" xml:space="preserve">
          <source>assign &lt;code&gt;weight&lt;/code&gt; to each element of &lt;code&gt;vector&lt;/code&gt;</source>
          <target state="translated">为 &lt;code&gt;vector&lt;/code&gt; 每个元素分配 &lt;code&gt;weight&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5f3de199d97e97e8e060913f33b95d03a4f06c7e" translate="yes" xml:space="preserve">
          <source>assign &lt;code&gt;weight&lt;/code&gt; to elements of &lt;code&gt;vector&lt;/code&gt; that are listed in &lt;code&gt;lexemes&lt;/code&gt;</source>
          <target state="translated">为 &lt;code&gt;lexemes&lt;/code&gt; 中列出的 &lt;code&gt;vector&lt;/code&gt; 元素分配 &lt;code&gt;weight&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43ede3444dff3e595fe1c6f01b6c9f4950cb71df" translate="yes" xml:space="preserve">
          <source>at least 1000 (The default is often 32767; do not change unless necessary)</source>
          <target state="translated">至少1000(默认值通常为32767,除非必要,否则不要更改)。</target>
        </trans-unit>
        <trans-unit id="5439e16ae06517bfbf55405bc08c2e92863bf5ea" translate="yes" xml:space="preserve">
          <source>at least 17</source>
          <target state="translated">十七岁以上</target>
        </trans-unit>
        <trans-unit id="443e099bc3b684e0db01a5fa2add4d3ea2882a4a" translate="yes" xml:space="preserve">
          <source>at least 1kB, but the default is usually much higher</source>
          <target state="translated">至少1kB,但默认值通常要高得多。</target>
        </trans-unit>
        <trans-unit id="b54a445594f650278b14b942cc8d8778f01c797e" translate="yes" xml:space="preserve">
          <source>at least &lt;code&gt;ceil((max_connections + autovacuum_max_workers + max_wal_senders + max_worker_processes + 5) / 16)&lt;/code&gt; plus room for other applications</source>
          <target state="translated">至少 &lt;code&gt;ceil((max_connections + autovacuum_max_workers + max_wal_senders + max_worker_processes + 5) / 16)&lt;/code&gt; 加上其他应用程序的空间</target>
        </trans-unit>
        <trans-unit id="72b7c9e2eb3bd23a8fd3c8e377b81389e5a528cf" translate="yes" xml:space="preserve">
          <source>auth_delay</source>
          <target state="translated">auth_delay</target>
        </trans-unit>
        <trans-unit id="ad397fd87c3e39210986b3c99c01e01ebcf26995" translate="yes" xml:space="preserve">
          <source>authorization identifier membership relationships</source>
          <target state="translated">授权标识符</target>
        </trans-unit>
        <trans-unit id="d2896d216ff2416211d2a0e36e3d0a7b13db82ff" translate="yes" xml:space="preserve">
          <source>authorization identifiers (roles)</source>
          <target state="translated">授权标识符</target>
        </trans-unit>
        <trans-unit id="b483ffa7f9b4926c39834e971e056d9afed0e3b7" translate="yes" xml:space="preserve">
          <source>auto_explain</source>
          <target state="translated">auto_explain</target>
        </trans-unit>
        <trans-unit id="3286d9c6ac632aa037945fb31c0e37f0dd633546" translate="yes" xml:space="preserve">
          <source>autoincrementing eight-byte integer</source>
          <target state="translated">八字节自动递增整数</target>
        </trans-unit>
        <trans-unit id="1e4abd38ff5fb04fd9cc6e1989de0864a83533bd" translate="yes" xml:space="preserve">
          <source>autoincrementing four-byte integer</source>
          <target state="translated">四字节自动递增整数</target>
        </trans-unit>
        <trans-unit id="2162f05f39e1f496096d2494f2a79d5030c2b804" translate="yes" xml:space="preserve">
          <source>autoincrementing integer</source>
          <target state="translated">自动递增整数</target>
        </trans-unit>
        <trans-unit id="954cc0f6e210f639b3c9f9351202ace47d52913a" translate="yes" xml:space="preserve">
          <source>autoincrementing two-byte integer</source>
          <target state="translated">自动递增双字节整数</target>
        </trans-unit>
        <trans-unit id="8d3a645cd2a324f0617182d92fe36ab22475ce17" translate="yes" xml:space="preserve">
          <source>available extensions</source>
          <target state="translated">可用的分机</target>
        </trans-unit>
        <trans-unit id="0cc0f41b2e69a6e8bf4387c1a1ce9ef5e7d390b0" translate="yes" xml:space="preserve">
          <source>available versions of extensions</source>
          <target state="translated">可用的扩展版本</target>
        </trans-unit>
        <trans-unit id="9a6de5e0d48d7fb642bda1b378500dd99c53f1dd" translate="yes" xml:space="preserve">
          <source>average of the dependent variable (&lt;code&gt;sum(Y)/N&lt;/code&gt;)</source>
          <target state="translated">因变量的平均值（ &lt;code&gt;sum(Y)/N&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="f20b015e8a66fb8ce9b0949ef84f41895f7b022b" translate="yes" xml:space="preserve">
          <source>average of the independent variable (&lt;code&gt;sum(X)/N&lt;/code&gt;)</source>
          <target state="translated">自变量的平均值（ &lt;code&gt;sum(X)/N&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="3853072116a861ff4c871d3e96a9cac7da78b7d2" translate="yes" xml:space="preserve">
          <source>backslash</source>
          <target state="translated">backslash</target>
        </trans-unit>
        <trans-unit id="4930eb3f60df3a6a61e8d44178feb2b8f820a153" translate="yes" xml:space="preserve">
          <source>backspace</source>
          <target state="translated">backspace</target>
        </trans-unit>
        <trans-unit id="66cdf1600430f705cc4d8f5e11204829f8383256" translate="yes" xml:space="preserve">
          <source>backspace, as in C</source>
          <target state="translated">退格</target>
        </trans-unit>
        <trans-unit id="7f0d7679eb22f81f891057708c71dfb599a38184" translate="yes" xml:space="preserve">
          <source>base 10 logarithm</source>
          <target state="translated">十位数</target>
        </trans-unit>
        <trans-unit id="b749c20d2998dde8c54f69e19a74da9a0e84fc42" translate="yes" xml:space="preserve">
          <source>base frequency of this MCV item</source>
          <target state="translated">该MCV项目的基本频率</target>
        </trans-unit>
        <trans-unit id="8095e159699116466e36cbafd09e1d845f29f2b9" translate="yes" xml:space="preserve">
          <source>base64</source>
          <target state="translated">base64</target>
        </trans-unit>
        <trans-unit id="9965fcf7de748d3c770146162736f22b09a2ffad" translate="yes" xml:space="preserve">
          <source>because &lt;code&gt;postgres&lt;/code&gt; gets stemmed to &lt;code&gt;postgr&lt;/code&gt;:</source>
          <target state="translated">因为 &lt;code&gt;postgres&lt;/code&gt; 被限制在 &lt;code&gt;postgr&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="af23afc243510d2615878774b81457104ad38f78" translate="yes" xml:space="preserve">
          <source>because a repeatable read transaction cannot modify or lock rows changed by other transactions after the repeatable read transaction began.</source>
          <target state="translated">因为在可重复读取事务开始后,可重复读取事务不能修改或锁定其他事务所更改的行。</target>
        </trans-unit>
        <trans-unit id="cbcbd26ed5be476f354422d6b658763c38b229f1" translate="yes" xml:space="preserve">
          <source>because in absence of a column list the primary key of the referenced table is used as the referenced column(s).</source>
          <target state="translated">因为在没有列列表的情况下,被引用表的主键被用作被引用列。</target>
        </trans-unit>
        <trans-unit id="2d96d3c2be8f36cf4d125d8a4ee9c4468f5d1613" translate="yes" xml:space="preserve">
          <source>because it attempts to apply a collation to the result of the &lt;code&gt;&amp;gt;&lt;/code&gt; operator, which is of the non-collatable data type &lt;code&gt;boolean&lt;/code&gt;.</source>
          <target state="translated">因为它尝试将排序规则应用于 &lt;code&gt;&amp;gt;&lt;/code&gt; 运算符的结果，该运算符的类型不可为 &lt;code&gt;boolean&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d39b947f257995ccfde497491739ecd566455f0" translate="yes" xml:space="preserve">
          <source>because the parser has no idea &amp;mdash; until it is too late &amp;mdash; that &lt;code&gt;!&lt;/code&gt; is defined as a postfix operator, not an infix one. To get the desired behavior in this case, you must write:</source>
          <target state="translated">因为解析器不知道，直到为时已晚为止 &lt;code&gt;!&lt;/code&gt; 被定义为后缀运算符，而不是后缀运算符。为了在这种情况下获得所需的行为，您必须编写：</target>
        </trans-unit>
        <trans-unit id="dc3a884c6b37262fcaf12532a1f9c235ecbf4b6d" translate="yes" xml:space="preserve">
          <source>because the server will reject the file if its permissions are more liberal than this. For more details on how to create your server private key and certificate, refer to the OpenSSL documentation.</source>
          <target state="translated">因为如果文件的权限比这更宽松,服务器将拒绝该文件。关于如何创建服务器私钥和证书的更多细节,请参考OpenSSL文档。</target>
        </trans-unit>
        <trans-unit id="bd03a44af506549f106aba97d42f455d1fa7455f" translate="yes" xml:space="preserve">
          <source>begins with the label &lt;code&gt;Top&lt;/code&gt;</source>
          <target state="translated">以标签&amp;ldquo; &lt;code&gt;Top&lt;/code&gt; &amp;rdquo;开头</target>
        </trans-unit>
        <trans-unit id="709634051471385aada32356842983beeff4b065" translate="yes" xml:space="preserve">
          <source>between</source>
          <target state="translated">between</target>
        </trans-unit>
        <trans-unit id="2ec6bc31b898e16ec539ddbd405a5a171a3df210" translate="yes" xml:space="preserve">
          <source>between, after sorting the comparison values</source>
          <target state="translated">之间,对比较值进行排序后</target>
        </trans-unit>
        <trans-unit id="5f9c9d32d71f1ef8b8014c350a5f8aec50c577ec" translate="yes" xml:space="preserve">
          <source>bigint</source>
          <target state="translated">bigint</target>
        </trans-unit>
        <trans-unit id="77277e00630649e46e2738e754d21819c7bc1bf5" translate="yes" xml:space="preserve">
          <source>bigserial</source>
          <target state="translated">bigserial</target>
        </trans-unit>
        <trans-unit id="e52bf437dfb9f0dadee4cb21fac3d9c8ada93bb1" translate="yes" xml:space="preserve">
          <source>binary JSON data, decomposed</source>
          <target state="translated">二进制JSON数据,分解</target>
        </trans-unit>
        <trans-unit id="02ab455c076e6f4b354b1446757e9a4b0a79445f" translate="yes" xml:space="preserve">
          <source>binary data (&amp;ldquo;byte array&amp;rdquo;)</source>
          <target state="translated">二进制数据（&amp;ldquo;字节数组&amp;rdquo;）</target>
        </trans-unit>
        <trans-unit id="892a67172f0a564c168e95647e62558366e70470" translate="yes" xml:space="preserve">
          <source>bit varying</source>
          <target state="translated">位差</target>
        </trans-unit>
        <trans-unit id="4ba5b46e332d373dfdfa248036598eb70f831d32" translate="yes" xml:space="preserve">
          <source>bitwise AND</source>
          <target state="translated">位元和</target>
        </trans-unit>
        <trans-unit id="898900a45561d4f119a2ed52510f1ace0fda7e60" translate="yes" xml:space="preserve">
          <source>bitwise NOT</source>
          <target state="translated">位面不</target>
        </trans-unit>
        <trans-unit id="7d5bb4d1e43ddd2b7554d5d7d0b44fa8e15c9b68" translate="yes" xml:space="preserve">
          <source>bitwise OR</source>
          <target state="translated">位面OR</target>
        </trans-unit>
        <trans-unit id="8f0757e0ba4c22c9e209a79597f6b1dc188081e0" translate="yes" xml:space="preserve">
          <source>bitwise XOR</source>
          <target state="translated">位数XOR</target>
        </trans-unit>
        <trans-unit id="e8be396aab93c1fef2fc7e54326638d41fd49ba3" translate="yes" xml:space="preserve">
          <source>bitwise shift left</source>
          <target state="translated">左移位</target>
        </trans-unit>
        <trans-unit id="ee3a57994d0683b1945f1e65426a85e401e290c1" translate="yes" xml:space="preserve">
          <source>bitwise shift right</source>
          <target state="translated">右移</target>
        </trans-unit>
        <trans-unit id="5812e2b7356193b66b6555bd2fa41ed3da124f67" translate="yes" xml:space="preserve">
          <source>bloom</source>
          <target state="translated">bloom</target>
        </trans-unit>
        <trans-unit id="48647474b89fa8f56ed6bda0f8148a17b51b97bd" translate="yes" xml:space="preserve">
          <source>boolean</source>
          <target state="translated">boolean</target>
        </trans-unit>
        <trans-unit id="65fc5cc5f306627f2ee258292e0df90691c67af1" translate="yes" xml:space="preserve">
          <source>both date and time (no time zone)</source>
          <target state="translated">日时兼备</target>
        </trans-unit>
        <trans-unit id="a27279f9f262e5ba8cd291de1630ce7357a275c8" translate="yes" xml:space="preserve">
          <source>both date and time, with time zone</source>
          <target state="translated">日时并重</target>
        </trans-unit>
        <trans-unit id="33ca9adbe02fe4b2c1b14995a225396cc073c647" translate="yes" xml:space="preserve">
          <source>both of which sort by the first output column. Note that an output column name has to stand alone, that is, it cannot be used in an expression &amp;mdash; for example, this is &lt;em&gt;not&lt;/em&gt; correct:</source>
          <target state="translated">两者均按第一输出列排序。请注意，输出列名称必须独立，也就是说，不能在表达式中使用它，例如，这是&lt;em&gt;不&lt;/em&gt;正确的：</target>
        </trans-unit>
        <trans-unit id="8cde009a0af187221e6f6dd025a6cf362c599c99" translate="yes" xml:space="preserve">
          <source>box diagonal to line segment</source>
          <target state="translated">方格线</target>
        </trans-unit>
        <trans-unit id="6f5d0d15c57b74089e23ebb9522965d12a29230c" translate="yes" xml:space="preserve">
          <source>box to 4-point polygon</source>
          <target state="translated">框至4点多边形</target>
        </trans-unit>
        <trans-unit id="96b6dbd46e1f666fe3c50b034ebe2000e41de085" translate="yes" xml:space="preserve">
          <source>box to circle</source>
          <target state="translated">框框</target>
        </trans-unit>
        <trans-unit id="1ca211a26e16f8cade4a85971d5852f1c33fff52" translate="yes" xml:space="preserve">
          <source>boxes to bounding box</source>
          <target state="translated">盒到边界盒</target>
        </trans-unit>
        <trans-unit id="7e65a745a42ef9c805310b0bccb5bfa33fa4d8e9" translate="yes" xml:space="preserve">
          <source>broadcast address for network</source>
          <target state="translated">广播地址</target>
        </trans-unit>
        <trans-unit id="7e429fb710b1bd41375b836cf8242f042f2393a6" translate="yes" xml:space="preserve">
          <source>btree_gin</source>
          <target state="translated">btree_gin</target>
        </trans-unit>
        <trans-unit id="d4fc5c2b17c1dc2564aad5782a24ec87dbb33485" translate="yes" xml:space="preserve">
          <source>btree_gist</source>
          <target state="translated">btree_gist</target>
        </trans-unit>
        <trans-unit id="59d8e37e115d9900867db7d20d223db479f6ea75" translate="yes" xml:space="preserve">
          <source>build an &lt;code&gt;aclitem&lt;/code&gt; from input</source>
          <target state="translated">从输入中建立一个 &lt;code&gt;aclitem&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c70d21c53edbb94215b7aa66f5ea7d3aa0b789c" translate="yes" xml:space="preserve">
          <source>built-in logical repl., pglogical</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6310070850ba6f8f16435b6767ef6e3d84d1b51c" translate="yes" xml:space="preserve">
          <source>built-in logical replication, pglogical</source>
          <target state="translated">内置逻辑复制,pglogical</target>
        </trans-unit>
        <trans-unit id="0a4f60411d00d9bc19c78893536c661c6bb4cbb3" translate="yes" xml:space="preserve">
          <source>built-in streaming repl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b8c9efbbdae1b8096b4be992666e1f2306047c9" translate="yes" xml:space="preserve">
          <source>built-in streaming replication</source>
          <target state="translated">内置流媒体复制</target>
        </trans-unit>
        <trans-unit id="d9b843a298d5353ed2a7fe506917dc36463cf904" translate="yes" xml:space="preserve">
          <source>but not all type names can be used in this way; see &lt;a href=&quot;sql-expressions#SQL-SYNTAX-TYPE-CASTS&quot;&gt;Section 4.2.9&lt;/a&gt; for details.</source>
          <target state="translated">但并非所有类型名称都可以这种方式使用；有关详细信息，请参见&lt;a href=&quot;sql-expressions#SQL-SYNTAX-TYPE-CASTS&quot;&gt;第4.2.9节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f09f88b6f29fee99798bea8929b062956fb7df58" translate="yes" xml:space="preserve">
          <source>but real-world usage will involve including it in a text search configuration as described in &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt;. That might look like this:</source>
          <target state="translated">但实际用法将涉及将其包含在&lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;第12章&lt;/a&gt;中所述的文本搜索配置中。可能看起来像这样：</target>
        </trans-unit>
        <trans-unit id="931bb3d7295a22ba60e407c439a2751b6a2e54c6" translate="yes" xml:space="preserve">
          <source>but real-world usage will involve including it in a text search configuration as described in &lt;a href=&quot;https://www.postgresql.org/docs/13/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt;. That might look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47b8dd0ef1d9374c938682dcc12763e6b91b0511" translate="yes" xml:space="preserve">
          <source>but that approach is less flexible, and often less efficient as well.</source>
          <target state="translated">但这种方法不太灵活,而且往往效率也不高。</target>
        </trans-unit>
        <trans-unit id="777c2dee3f742dec7bfd8f0986b9928f96755335" translate="yes" xml:space="preserve">
          <source>but then the database server will see the connection as coming in on its &lt;code&gt;foo.com&lt;/code&gt; bind address, which is not opened by the default setting &lt;code&gt;listen_addresses = 'localhost'&lt;/code&gt;. This is usually not what you want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee2c835e71e434c69308497a09a58270d6b3eddb" translate="yes" xml:space="preserve">
          <source>but then the database server will see the connection as coming in on its &lt;code&gt;foo.com&lt;/code&gt; interface, which is not opened by the default setting &lt;code&gt;listen_addresses = 'localhost'&lt;/code&gt;. This is usually not what you want.</source>
          <target state="translated">但随后数据库服务器将看到该连接进入其 &lt;code&gt;foo.com&lt;/code&gt; 接口，默认设置 &lt;code&gt;listen_addresses = 'localhost'&lt;/code&gt; 不会打开该接口。这通常不是您想要的。</target>
        </trans-unit>
        <trans-unit id="254eff7ff12131042b7e5d6791570b4b68f6d612" translate="yes" xml:space="preserve">
          <source>but these queries could not:</source>
          <target state="translated">但这些疑问不能。</target>
        </trans-unit>
        <trans-unit id="f051e659481b1bdec5c2a7ae3f0ba578a9c5a900" translate="yes" xml:space="preserve">
          <source>but this does:</source>
          <target state="translated">但这确实。</target>
        </trans-unit>
        <trans-unit id="0b6affe425ac3cac0ecdcc4b798bd2ce34e6c9ad" translate="yes" xml:space="preserve">
          <source>but this will not work since the aggregate &lt;code&gt;max&lt;/code&gt; cannot be used in the &lt;code&gt;WHERE&lt;/code&gt; clause. (This restriction exists because the &lt;code&gt;WHERE&lt;/code&gt; clause determines which rows will be included in the aggregate calculation; so obviously it has to be evaluated before aggregate functions are computed.) However, as is often the case the query can be restated to accomplish the desired result, here by using a &lt;em&gt;subquery&lt;/em&gt;:</source>
          <target state="translated">但这将不起作用，因为不能在 &lt;code&gt;WHERE&lt;/code&gt; 子句中使用聚合 &lt;code&gt;max&lt;/code&gt; 。（存在此限制是因为 &lt;code&gt;WHERE&lt;/code&gt; 子句确定要在聚合计算中包括哪些行；因此很明显，必须在计算聚合函数之前对其进行评估。）但是，通常可以重新进行查询以实现所需结果的情况，这里使用&lt;em&gt;子查询&lt;/em&gt;：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b94da3599274cc93c9ee4f4d4dce4fea875b2503" translate="yes" xml:space="preserve">
          <source>but:</source>
          <target state="translated">but:</target>
        </trans-unit>
        <trans-unit id="ca4a2057bd9e261b071397023cf198c3db0688ef" translate="yes" xml:space="preserve">
          <source>calendar date (year, month, day)</source>
          <target state="translated">年月日</target>
        </trans-unit>
        <trans-unit id="3f5ae5c8becacd92f5b89cba285014d49fe90e2c" translate="yes" xml:space="preserve">
          <source>can also be used.</source>
          <target state="translated">也可以使用。</target>
        </trans-unit>
        <trans-unit id="4a9f2d676dd4658059a5f07359111b9cc42edcba" translate="yes" xml:space="preserve">
          <source>can be increased by recompiling PostgreSQL</source>
          <target state="translated">可以通过重新编译PostgreSQL来增加</target>
        </trans-unit>
        <trans-unit id="07b307ab5d0c778628385e3d5dbb950c4bbe7a5d" translate="yes" xml:space="preserve">
          <source>can be used too, but at present this is just for &lt;em&gt;pro forma&lt;/em&gt; compliance with the SQL standard. If you write a database name, it must be the same as the database you are connected to.</source>
          <target state="translated">也可以使用，但目前这只是&lt;em&gt;走形式&lt;/em&gt;与SQL标准符合性。如果编写数据库名称，则该名称必须与连接的数据库名称相同。</target>
        </trans-unit>
        <trans-unit id="45514644f4621795d582e24c02cb7cf058d26351" translate="yes" xml:space="preserve">
          <source>can equivalently be written as:</source>
          <target state="translated">可以等价地写成:</target>
        </trans-unit>
        <trans-unit id="6e9f192b79a14968d26f70ab1aa8e21b65e3df64" translate="yes" xml:space="preserve">
          <source>carriage return</source>
          <target state="translated">回车</target>
        </trans-unit>
        <trans-unit id="def334c5877ea4f63b5575fa4cc2f60305278d07" translate="yes" xml:space="preserve">
          <source>carriage return, as in C</source>
          <target state="translated">回车</target>
        </trans-unit>
        <trans-unit id="f99b34b4fa1fea2ca07ad8897d13ba6b1206cc37" translate="yes" xml:space="preserve">
          <source>case-insensitive matching (see &lt;a href=&quot;functions-matching#POSIX-MATCHING-RULES&quot;&gt;Section 9.7.3.5&lt;/a&gt;) (overrides operator type)</source>
          <target state="translated">不区分大小写的匹配（请参阅&lt;a href=&quot;functions-matching#POSIX-MATCHING-RULES&quot;&gt;第9.7.3.5节&lt;/a&gt;）（重写运算符类型）</target>
        </trans-unit>
        <trans-unit id="3e82d968dc00f833dad374e757a334e4a040c90c" translate="yes" xml:space="preserve">
          <source>case-sensitive matching (overrides operator type)</source>
          <target state="translated">大小写敏感的匹配(覆盖运算符类型)。</target>
        </trans-unit>
        <trans-unit id="5bf41021d1e013cdbe5336b032060b46fb810232" translate="yes" xml:space="preserve">
          <source>cast &lt;code&gt;ltree&lt;/code&gt; to &lt;code&gt;text&lt;/code&gt;</source>
          <target state="translated">将 &lt;code&gt;ltree&lt;/code&gt; 转换为 &lt;code&gt;text&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ed1123013c2bd604bb0d461547480f74dc473e37" translate="yes" xml:space="preserve">
          <source>cast &lt;code&gt;text&lt;/code&gt; to &lt;code&gt;ltree&lt;/code&gt;</source>
          <target state="translated">将 &lt;code&gt;text&lt;/code&gt; 为 &lt;code&gt;ltree&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a283f70188863d91855937695daa6c350cfcf558" translate="yes" xml:space="preserve">
          <source>cast to double</source>
          <target state="translated">铸成双份</target>
        </trans-unit>
        <trans-unit id="34472e7f0cad05f2b2dd139e2a7581cfa2e2f29a" translate="yes" xml:space="preserve">
          <source>cast to int</source>
          <target state="translated">投掷到int</target>
        </trans-unit>
        <trans-unit id="542ab67ef49ce56f684a8718e87598af02f5d74b" translate="yes" xml:space="preserve">
          <source>casts (data type conversions)</source>
          <target state="translated">投放(数据类型转换)</target>
        </trans-unit>
        <trans-unit id="305047e96ec089021660ee5965f893ac80268731" translate="yes" xml:space="preserve">
          <source>center</source>
          <target state="translated">center</target>
        </trans-unit>
        <trans-unit id="1c324c54487e53c22fd01ca907a0c848c8a583d9" translate="yes" xml:space="preserve">
          <source>center and radius to circle</source>
          <target state="translated">圆心和半径</target>
        </trans-unit>
        <trans-unit id="81a86dca1152d33417863c0f5f4e6cf2b16480a6" translate="yes" xml:space="preserve">
          <source>center of box</source>
          <target state="translated">盒心</target>
        </trans-unit>
        <trans-unit id="2ec0ff924735c49e81d70e8e2c7d6dfe9d7d60bc" translate="yes" xml:space="preserve">
          <source>center of circle</source>
          <target state="translated">圆心</target>
        </trans-unit>
        <trans-unit id="525b6f618cb47140c2374dbe02a53765c3c85c24" translate="yes" xml:space="preserve">
          <source>center of line segment</source>
          <target state="translated">线段中心</target>
        </trans-unit>
        <trans-unit id="33d628e71b8e6a1a2c384ae970e47570fc0b9a61" translate="yes" xml:space="preserve">
          <source>center of polygon</source>
          <target state="translated">多边形中心</target>
        </trans-unit>
        <trans-unit id="21957663c4fb58419a0c98a3724294cbfdbf1a7f" translate="yes" xml:space="preserve">
          <source>century (2 digits) (the twenty-first century starts on 2001-01-01)</source>
          <target state="translated">世纪(两位数)</target>
        </trans-unit>
        <trans-unit id="370ecf2ad70a13142bf3174e9abe256169452bd0" translate="yes" xml:space="preserve">
          <source>certificates revoked by certificate authorities</source>
          <target state="translated">被证书机构撤销的证书</target>
        </trans-unit>
        <trans-unit id="932784433f85ba8abc6f12c517aaf96068258f16" translate="yes" xml:space="preserve">
          <source>channel names that the session is currently listening on</source>
          <target state="translated">当前会话正在监听的频道名称</target>
        </trans-unit>
        <trans-unit id="f0db3fa401aea04b711d6f1f3630552eaaee8e59" translate="yes" xml:space="preserve">
          <source>character</source>
          <target state="translated">character</target>
        </trans-unit>
        <trans-unit id="d0eb7b3b4e386ffe76f12fc6f7502ffde2a5b1ca" translate="yes" xml:space="preserve">
          <source>character varying</source>
          <target state="translated">多变的性格</target>
        </trans-unit>
        <trans-unit id="eea64a15c7c41d6cf7da5318bba35b0dfa86b13f" translate="yes" xml:space="preserve">
          <source>check clusters only, don't change any data</source>
          <target state="translated">只检查集群,不改变任何数据。</target>
        </trans-unit>
        <trans-unit id="a29a96de4ab639d87155b423113f741d6b399fca" translate="yes" xml:space="preserve">
          <source>check constraints, unique constraints, primary key constraints, foreign key constraints</source>
          <target state="translated">检查约束、唯一约束、主键约束、外键约束。</target>
        </trans-unit>
        <trans-unit id="4b91f9d8b975eee622772ea62a86896ef4ef61ce" translate="yes" xml:space="preserve">
          <source>checks that client certificate is signed by a trusted certificate authority</source>
          <target state="translated">检查客户证书是否由受信任的证书颁发机构签署。</target>
        </trans-unit>
        <trans-unit id="00b7b8118efde44c546b69243ec15b21cd64c9d9" translate="yes" xml:space="preserve">
          <source>circle</source>
          <target state="translated">circle</target>
        </trans-unit>
        <trans-unit id="bfac9bc25b5fb8f2fa83ccb26e83e30c35a3a06c" translate="yes" xml:space="preserve">
          <source>circle on a plane</source>
          <target state="translated">圆环</target>
        </trans-unit>
        <trans-unit id="fe2bd0ef7b1249d0169c74005f37ca2fd5a93734" translate="yes" xml:space="preserve">
          <source>circle to 12-point polygon</source>
          <target state="translated">圆到12点的多边形</target>
        </trans-unit>
        <trans-unit id="ddf50c7158a693b8ba86924c5d88bec2f50e83aa" translate="yes" xml:space="preserve">
          <source>circle to &lt;code&gt;npts&lt;/code&gt;-point polygon</source>
          <target state="translated">圆到 &lt;code&gt;npts&lt;/code&gt; 点多边形</target>
        </trans-unit>
        <trans-unit id="ad3b153d9429c109e68ce6ced77c4260d4c34577" translate="yes" xml:space="preserve">
          <source>circle to box</source>
          <target state="translated">圆盒</target>
        </trans-unit>
        <trans-unit id="e241ce9d9ce43d18211ad61727ab59139118a131" translate="yes" xml:space="preserve">
          <source>citext</source>
          <target state="translated">citext</target>
        </trans-unit>
        <trans-unit id="751266a7fa555fd650fe60f7bd15324008f60eaf" translate="yes" xml:space="preserve">
          <source>client certificate must not be on this list</source>
          <target state="translated">客户证书必须不在此列表中</target>
        </trans-unit>
        <trans-unit id="12c22af93332ba93d2c7d1b12c8c3a6239448f8b" translate="yes" xml:space="preserve">
          <source>client character set representation</source>
          <target state="translated">客户端字符集表示法</target>
        </trans-unit>
        <trans-unit id="fe3b3f96eb8a29aa95ee6742e5391daa5a853668" translate="yes" xml:space="preserve">
          <source>closed geometric path on a plane</source>
          <target state="translated">平面上的封闭几何路径</target>
        </trans-unit>
        <trans-unit id="9d2a05384389e39e55a9fb33419864a52dc20579" translate="yes" xml:space="preserve">
          <source>cluster's install user name; environment variable &lt;code&gt;PGUSER&lt;/code&gt;</source>
          <target state="translated">集群的安装用户名；环境变量 &lt;code&gt;PGUSER&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="39f2375a466659e991122be876571fa32e1c3224" translate="yes" xml:space="preserve">
          <source>clusterdb</source>
          <target state="translated">clusterdb</target>
        </trans-unit>
        <trans-unit id="823fd4756652ecc890aa45a56776dffb0e59f612" translate="yes" xml:space="preserve">
          <source>clusterdb &amp;mdash; cluster a PostgreSQL database</source>
          <target state="translated">clusterdb &amp;mdash;集群PostgreSQL数据库</target>
        </trans-unit>
        <trans-unit id="d5bb141c39226c781b730bc7a91ab0f06285e4f0" translate="yes" xml:space="preserve">
          <source>clusterdb accepts the following command-line arguments:</source>
          <target state="translated">clusterdb接受以下命令行参数。</target>
        </trans-unit>
        <trans-unit id="cf3ac3c5cfb26bd0e1f0c4ae38487d9d7c314d08" translate="yes" xml:space="preserve">
          <source>clusterdb also accepts the following command-line arguments for connection parameters:</source>
          <target state="translated">clusterdb也接受以下命令行参数作为连接参数。</target>
        </trans-unit>
        <trans-unit id="e2fe317f2e4ea451e21fc774dc0d79619e64edfd" translate="yes" xml:space="preserve">
          <source>clusterdb is a utility for reclustering tables in a PostgreSQL database. It finds tables that have previously been clustered, and clusters them again on the same index that was last used. Tables that have never been clustered are not affected.</source>
          <target state="translated">clusterdb 是一个用于在 PostgreSQL 数据库中重新聚类表的工具。它可以找到以前被聚类过的表,并在最后使用的同一个索引上重新聚类。从未聚类过的表不受影响。</target>
        </trans-unit>
        <trans-unit id="fd2735ad5e6a19ac7e1140a224c1c24a97fc9e17" translate="yes" xml:space="preserve">
          <source>clusterdb is a wrapper around the SQL command &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt;. There is no effective difference between clustering databases via this utility and via other methods for accessing the server.</source>
          <target state="translated">clusterdb是SQL命令&lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt;的包装。通过该实用程序和通过其他访问服务器的方法对数据库集群之间没有有效的区别。</target>
        </trans-unit>
        <trans-unit id="1f1784fa738e6d5473ab5f43d736a5f44fb259b0" translate="yes" xml:space="preserve">
          <source>collation name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bea494244f54b23f44820cb069f810bb4eca7c7b" translate="yes" xml:space="preserve">
          <source>collations (locale information)</source>
          <target state="translated">小吃</target>
        </trans-unit>
        <trans-unit id="f6e81a8e1f0b533eb70f9ceeb98b3f99d57e7764" translate="yes" xml:space="preserve">
          <source>column default values</source>
          <target state="translated">列默认值</target>
        </trans-unit>
        <trans-unit id="fe7f2cdd0d102e4f8a30abbef55f21da4b2ba7d9" translate="yes" xml:space="preserve">
          <source>columns per index</source>
          <target state="translated">每索引列</target>
        </trans-unit>
        <trans-unit id="ff07f44a4127edb55f44386b09eae02d54daca39" translate="yes" xml:space="preserve">
          <source>columns per table</source>
          <target state="translated">单表</target>
        </trans-unit>
        <trans-unit id="f34c9877f2bf68c0333fc87b9e95a52bc11e5b67" translate="yes" xml:space="preserve">
          <source>comments on shared objects</source>
          <target state="translated">对共享对象的评论</target>
        </trans-unit>
        <trans-unit id="7b66eba0b67c3b9e73cc97b3d1b94a251d742d90" translate="yes" xml:space="preserve">
          <source>comparison operators</source>
          <target state="translated">比较运算符</target>
        </trans-unit>
        <trans-unit id="8154454006381d49284649c66b2403f81afb118d" translate="yes" xml:space="preserve">
          <source>compile-time configuration parameters</source>
          <target state="translated">编译时配置参数</target>
        </trans-unit>
        <trans-unit id="55a34178d77f1c51b211c756f759f8cf161a23d4" translate="yes" xml:space="preserve">
          <source>concatenate &lt;code&gt;hstore&lt;/code&gt;s</source>
          <target state="translated">串连 &lt;code&gt;hstore&lt;/code&gt; 小号</target>
        </trans-unit>
        <trans-unit id="8e1ad14ad4374d48d20d7479ab315932269fbff4" translate="yes" xml:space="preserve">
          <source>concatenate &lt;code&gt;ltree&lt;/code&gt; paths</source>
          <target state="translated">连接 &lt;code&gt;ltree&lt;/code&gt; 路径</target>
        </trans-unit>
        <trans-unit id="29b58ef42868498f9fead6297c0c68588c926edf" translate="yes" xml:space="preserve">
          <source>concatenate &lt;code&gt;tsvector&lt;/code&gt;s</source>
          <target state="translated">串连 &lt;code&gt;tsvector&lt;/code&gt; 小号</target>
        </trans-unit>
        <trans-unit id="2c4447d1d44ee3c074941b8c08ca342d23d066f6" translate="yes" xml:space="preserve">
          <source>concatenate two arrays</source>
          <target state="translated">连接两个数组</target>
        </trans-unit>
        <trans-unit id="22d0551615cf0d8546cc1c9c81d271b5e72e2fda" translate="yes" xml:space="preserve">
          <source>concatenates array elements using supplied delimiter and optional null string</source>
          <target state="translated">使用提供的定界符和可选的空字符串连接数组元素。</target>
        </trans-unit>
        <trans-unit id="5c93b563298b75fc6d2f4fcfedc5ca6dd370b747" translate="yes" xml:space="preserve">
          <source>concatenation</source>
          <target state="translated">concatenation</target>
        </trans-unit>
        <trans-unit id="5fff9a64a91f5155fd20f1f5322675919eba1779" translate="yes" xml:space="preserve">
          <source>concatenation of non-null XML values (see also &lt;a href=&quot;functions-xml#FUNCTIONS-XML-XMLAGG&quot;&gt;Section 9.14.1.7&lt;/a&gt;)</source>
          <target state="translated">非空XML值的串联（另请参见&lt;a href=&quot;functions-xml#FUNCTIONS-XML-XMLAGG&quot;&gt;第9.14.1.7节&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="cab21417f26804f2821e9cba7ec02b3d22bb0dcb" translate="yes" xml:space="preserve">
          <source>condition that has a format similar to the format of regular expressions.</source>
          <target state="translated">条件,其格式与正则表达式的格式类似。</target>
        </trans-unit>
        <trans-unit id="bdd9e092f915a4d94a6a2f20a48a3e86b741db40" translate="yes" xml:space="preserve">
          <source>configuration load time</source>
          <target state="translated">配置加载时间</target>
        </trans-unit>
        <trans-unit id="d1fa507954b44038b5d98dbdafb2b36374cc6386" translate="yes" xml:space="preserve">
          <source>constrained by maximum relations per database</source>
          <target state="translated">受制于每个数据库的最大关系数</target>
        </trans-unit>
        <trans-unit id="242491a8bd7940610b5e65d571dcdb5c72e647a2" translate="yes" xml:space="preserve">
          <source>construct an &lt;code&gt;hstore&lt;/code&gt; from a record or row</source>
          <target state="translated">从记录或行构造一个 &lt;code&gt;hstore&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c929167cb94b880f0746653e53959fc18c0bf793" translate="yes" xml:space="preserve">
          <source>construct an &lt;code&gt;hstore&lt;/code&gt; from an array, which may be either a key/value array, or a two-dimensional array</source>
          <target state="translated">从数组构造一个 &lt;code&gt;hstore&lt;/code&gt; ，该数组可以是键/值数组，也可以是二维数组</target>
        </trans-unit>
        <trans-unit id="bbd40f04098912d0ba742a8bc5af223e27c7adda" translate="yes" xml:space="preserve">
          <source>construct an &lt;code&gt;hstore&lt;/code&gt; from separate key and value arrays</source>
          <target state="translated">从单独的键和值数组构造一个 &lt;code&gt;hstore&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3cc74499a516b13f15e51d5c826818942c36a609" translate="yes" xml:space="preserve">
          <source>construct host mask for network</source>
          <target state="translated">构建网络主机掩码</target>
        </trans-unit>
        <trans-unit id="b01b9cfc44c043d7e34a6cc2f5c24aa8c879193c" translate="yes" xml:space="preserve">
          <source>construct netmask for network</source>
          <target state="translated">构建网络掩码</target>
        </trans-unit>
        <trans-unit id="14dd4fbbe8eed4db88e77a3d9dee637dfc2d10c4" translate="yes" xml:space="preserve">
          <source>construct point</source>
          <target state="translated">建点</target>
        </trans-unit>
        <trans-unit id="b75f26d172a89e83c2261d72cb9d9e1b5ef7769c" translate="yes" xml:space="preserve">
          <source>contained &amp;mdash; &lt;code&gt;true&lt;/code&gt; if left array is contained in right array</source>
          <target state="translated">contains &amp;mdash; 如果在右数组中包含左数组，则为 &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="caeb909ae4ff4ee25a0ff0d476946ed256f2aee1" translate="yes" xml:space="preserve">
          <source>contains</source>
          <target state="translated">contains</target>
        </trans-unit>
        <trans-unit id="0957a97cac9a10ebe40f435c740cc3345b2efc3f" translate="yes" xml:space="preserve">
          <source>contains &amp;mdash; &lt;code&gt;true&lt;/code&gt; if left array contains right array</source>
          <target state="translated">contains &amp;mdash; 如果left数组包含right数组，则为 &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="007f7efed9b7619cf2555d2be05833ff839d3962" translate="yes" xml:space="preserve">
          <source>contains element</source>
          <target state="translated">包含元素</target>
        </trans-unit>
        <trans-unit id="e74dd6ca81a7e2eecc18f2ec9e65ec0ea5be7ef4" translate="yes" xml:space="preserve">
          <source>contains or equals</source>
          <target state="translated">包含或等于</target>
        </trans-unit>
        <trans-unit id="ce904d2429dea4c4cd6a0c965103aaf0e346da09" translate="yes" xml:space="preserve">
          <source>contains or is contained by</source>
          <target state="translated">包含或被包含在</target>
        </trans-unit>
        <trans-unit id="e75b7119f1d5d414ff82917ba2603bf9e5b45df6" translate="yes" xml:space="preserve">
          <source>contains range</source>
          <target state="translated">包含范围</target>
        </trans-unit>
        <trans-unit id="19f826ba869b2fee68bf1f114b8e677ae0c0d856" translate="yes" xml:space="preserve">
          <source>continuous percentile: returns a value corresponding to the specified fraction in the ordering, interpolating between adjacent input items if needed</source>
          <target state="translated">连续百分位数:返回与排序中指定分数相对应的值,必要时在相邻输入项之间进行内插。</target>
        </trans-unit>
        <trans-unit id="36c18c788db3f3304d051679f1b40f05f59e4471" translate="yes" xml:space="preserve">
          <source>convert &lt;code&gt;hstore&lt;/code&gt; to array of alternating keys and values</source>
          <target state="translated">将 &lt;code&gt;hstore&lt;/code&gt; 转换为交替键和值的数组</target>
        </trans-unit>
        <trans-unit id="a10418c81af1657f4831a46624d04836bc50be5c" translate="yes" xml:space="preserve">
          <source>convert &lt;code&gt;hstore&lt;/code&gt; to two-dimensional key/value array</source>
          <target state="translated">将 &lt;code&gt;hstore&lt;/code&gt; 转换为二维键/值数组</target>
        </trans-unit>
        <trans-unit id="602cf0e08612bf183b6a1d481640a135b45b733b" translate="yes" xml:space="preserve">
          <source>convert &lt;code&gt;tsvector&lt;/code&gt; to array of lexemes</source>
          <target state="translated">将 &lt;code&gt;tsvector&lt;/code&gt; 转换为词素数组</target>
        </trans-unit>
        <trans-unit id="6d582c6dfa728d8842a0e41ff985c05950fcac9e" translate="yes" xml:space="preserve">
          <source>convert array of lexemes to &lt;code&gt;tsvector&lt;/code&gt;</source>
          <target state="translated">将词素数组转换为 &lt;code&gt;tsvector&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="042e1227ee9efe77eb7cf25e971dd091316797bb" translate="yes" xml:space="preserve">
          <source>convert integer to string</source>
          <target state="translated">整数转为字符串</target>
        </trans-unit>
        <trans-unit id="8883e03ee79e5b7ca0bcc6c68d4b71517843c875" translate="yes" xml:space="preserve">
          <source>convert interval to string</source>
          <target state="translated">将区间转换为字符串</target>
        </trans-unit>
        <trans-unit id="2c348d29e84f0505a741faf5cd29979ee0784eb6" translate="yes" xml:space="preserve">
          <source>convert numeric to string</source>
          <target state="translated">数形转换为字符串</target>
        </trans-unit>
        <trans-unit id="e58b5696e1ecb535182f8da0e55ea16d3ba9714b" translate="yes" xml:space="preserve">
          <source>convert path to closed</source>
          <target state="translated">将路径转换为封闭式</target>
        </trans-unit>
        <trans-unit id="e8c6b63ef451acece45e4a2472ed3246d96680fa" translate="yes" xml:space="preserve">
          <source>convert path to open</source>
          <target state="translated">转换路径为开放</target>
        </trans-unit>
        <trans-unit id="b4e06a2b81ef98774ce30290d2c91fbe2ee0a163" translate="yes" xml:space="preserve">
          <source>convert real/double precision to string</source>
          <target state="translated">将实数/双精度转换为字符串</target>
        </trans-unit>
        <trans-unit id="16630f62d1ae61b7816445e29898565307e22a6f" translate="yes" xml:space="preserve">
          <source>convert string to date</source>
          <target state="translated">转换字符串为日期</target>
        </trans-unit>
        <trans-unit id="77457ad94d28223c821b4d450456f45b1fe1f3c5" translate="yes" xml:space="preserve">
          <source>convert string to numeric</source>
          <target state="translated">字符串转换为数字</target>
        </trans-unit>
        <trans-unit id="d592ee6202ef0abdfa519a7ee4c6978379812ba5" translate="yes" xml:space="preserve">
          <source>convert string to time stamp</source>
          <target state="translated">时戳转换</target>
        </trans-unit>
        <trans-unit id="7554307f0c7cf7f9b6e803a9465e3e2cd2090bfa" translate="yes" xml:space="preserve">
          <source>convert text to &lt;code&gt;ltree&lt;/code&gt; and concatenate</source>
          <target state="translated">将文本转换为 &lt;code&gt;ltree&lt;/code&gt; 并连接</target>
        </trans-unit>
        <trans-unit id="176526ef5504731e3313035b22ba3c0b5c8f498b" translate="yes" xml:space="preserve">
          <source>convert time stamp to string</source>
          <target state="translated">时间戳转换为字符串</target>
        </trans-unit>
        <trans-unit id="a3d85881749badcc411aff88ce02fb6973926ade" translate="yes" xml:space="preserve">
          <source>converts the integer constant 42 to type &lt;code&gt;float8&lt;/code&gt; by invoking a previously specified function, in this case &lt;code&gt;float8(int4)&lt;/code&gt;. (If no suitable cast has been defined, the conversion fails.)</source>
          <target state="translated">通过调用先前指定的函数（在本例中为 &lt;code&gt;float8(int4)&lt;/code&gt; )将整数常量42转换为 &lt;code&gt;float8&lt;/code&gt; 类型。（如果未定义适当的转换，则转换将失败。）</target>
        </trans-unit>
        <trans-unit id="9156629cfbed20d63d58fec30d0c098f0e19d25d" translate="yes" xml:space="preserve">
          <source>copy files to the &lt;code&gt;$SHAREDIR/tsearch_data&lt;/code&gt; directory</source>
          <target state="translated">将文件复制到 &lt;code&gt;$SHAREDIR/tsearch_data&lt;/code&gt; 目录</target>
        </trans-unit>
        <trans-unit id="6f5d0356cf2bf7c83124fef63669f30215a05eee" translate="yes" xml:space="preserve">
          <source>correlation coefficient</source>
          <target state="translated">相关系数</target>
        </trans-unit>
        <trans-unit id="76b5d4c037174657db2ef3d6849098ed26c598c7" translate="yes" xml:space="preserve">
          <source>cosine</source>
          <target state="translated">cosine</target>
        </trans-unit>
        <trans-unit id="92c39d6b13445a5705c2f7b251a21f0fb971660d" translate="yes" xml:space="preserve">
          <source>cotangent</source>
          <target state="translated">cotangent</target>
        </trans-unit>
        <trans-unit id="e3b7cc2c1242a390854b610b0efc253303b2b6fd" translate="yes" xml:space="preserve">
          <source>could be used as input to pg_restore and would only restore items 10 and 6, in that order:</source>
          <target state="translated">可以作为pg_restore的输入,并且只还原第10项和第6项,依次类推。</target>
        </trans-unit>
        <trans-unit id="fa3275b435c87e20aa8f38ceb77beb1839950e18" translate="yes" xml:space="preserve">
          <source>could handle these queries as index-only scans, because &lt;code&gt;y&lt;/code&gt; can be obtained from the index without visiting the heap.</source>
          <target state="translated">可以将这些查询作为仅索引扫描来处理，因为可以从索引获取 &lt;code&gt;y&lt;/code&gt; 而无需访问堆。</target>
        </trans-unit>
        <trans-unit id="6d4415f60a15671f449844424b8af6b0eb46e52d" translate="yes" xml:space="preserve">
          <source>could use the index, because the comparison will by default use the collation of the column. However, this index cannot accelerate queries that involve some other collation. So if queries of the form, say,</source>
          <target state="translated">可以使用该索引,因为比较将默认使用列的整理。但是,这个索引不能加速涉及其他一些整理的查询。所以,如果查询的形式,比如说。</target>
        </trans-unit>
        <trans-unit id="0bac556c5d3bb14c1fede879eb302b107d254487" translate="yes" xml:space="preserve">
          <source>createdb</source>
          <target state="translated">createdb</target>
        </trans-unit>
        <trans-unit id="6b407470937a987ede5e1a0f6201cc8aa6dfebd1" translate="yes" xml:space="preserve">
          <source>createdb &amp;mdash; create a new PostgreSQL database</source>
          <target state="translated">createdb &amp;mdash;创建一个新的PostgreSQL数据库</target>
        </trans-unit>
        <trans-unit id="ddafc0b5a0df99cf7efa3a37dabf9dc9fc318b1d" translate="yes" xml:space="preserve">
          <source>createdb accepts the following command-line arguments:</source>
          <target state="translated">createdb 接受以下命令行参数。</target>
        </trans-unit>
        <trans-unit id="bbf7672a9395c4080a0583f706be79ec1c196ff7" translate="yes" xml:space="preserve">
          <source>createdb also accepts the following command-line arguments for connection parameters:</source>
          <target state="translated">createdb 还接受以下命令行参数作为连接参数。</target>
        </trans-unit>
        <trans-unit id="9470bae91f4b1b94fa4d30d94087484824b0dc48" translate="yes" xml:space="preserve">
          <source>createdb creates a new PostgreSQL database.</source>
          <target state="translated">createdb创建一个新的PostgreSQL数据库。</target>
        </trans-unit>
        <trans-unit id="048a808c9479ad0cf4813cdc85239ab9acdb44e2" translate="yes" xml:space="preserve">
          <source>createdb is a wrapper around the SQL command &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt;. There is no effective difference between creating databases via this utility and via other methods for accessing the server.</source>
          <target state="translated">createdb是SQL命令&lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt;的包装。通过此实用程序和其他访问服务器的方法创建数据库之间没有有效的区别。</target>
        </trans-unit>
        <trans-unit id="df58b9eb4912cb4f51a557c31f280002a97c1cba" translate="yes" xml:space="preserve">
          <source>createuser</source>
          <target state="translated">createuser</target>
        </trans-unit>
        <trans-unit id="b3fcd1b75b88d9bb09cc16243ed746793c22b9e2" translate="yes" xml:space="preserve">
          <source>createuser &amp;mdash; define a new PostgreSQL user account</source>
          <target state="translated">createuser &amp;mdash;定义一个新的PostgreSQL用户帐户</target>
        </trans-unit>
        <trans-unit id="d10ac2835716c1122f4b67809fce50fe94a29e90" translate="yes" xml:space="preserve">
          <source>createuser accepts the following command-line arguments:</source>
          <target state="translated">createuser接受以下命令行参数。</target>
        </trans-unit>
        <trans-unit id="6a28423b7c898a6be61a407aeecb01d59a5820bb" translate="yes" xml:space="preserve">
          <source>createuser also accepts the following command-line arguments for connection parameters:</source>
          <target state="translated">createuser 也接受以下命令行参数作为连接参数。</target>
        </trans-unit>
        <trans-unit id="d2a84b3f8857986e6dd89f160acf7f9e638227ea" translate="yes" xml:space="preserve">
          <source>createuser creates a new PostgreSQL user (or more precisely, a role). Only superusers and users with &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can create new users, so createuser must be invoked by someone who can connect as a superuser or a user with &lt;code&gt;CREATEROLE&lt;/code&gt; privilege.</source>
          <target state="translated">createuser创建一个新的PostgreSQL用户（或更确切地说，一个角色）。只有超级用户和具有 &lt;code&gt;CREATEROLE&lt;/code&gt; 特权的用户才能创建新用户，因此必须由可以作为超级用户连接的用户或具有 &lt;code&gt;CREATEROLE&lt;/code&gt; 特权的用户调用createuser 。</target>
        </trans-unit>
        <trans-unit id="3e447ff571994f9f3e3ba25c8d7ecf9fb22fbb73" translate="yes" xml:space="preserve">
          <source>createuser is a wrapper around the SQL command &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;. There is no effective difference between creating users via this utility and via other methods for accessing the server.</source>
          <target state="translated">createuser是SQL命令&lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;的包装。通过此实用程序和其他访问服务器的方法创建用户之间没有有效的区别。</target>
        </trans-unit>
        <trans-unit id="55f7d1f71091501a0205fba94258266031264150" translate="yes" xml:space="preserve">
          <source>cube</source>
          <target state="translated">cube</target>
        </trans-unit>
        <trans-unit id="a7b0a72c320ec18ab3059928fd9784a02afb8268" translate="yes" xml:space="preserve">
          <source>cube root</source>
          <target state="translated">立方体根</target>
        </trans-unit>
        <trans-unit id="12f7353964de624d3d4543c138e1761bcfdc57f8" translate="yes" xml:space="preserve">
          <source>cumulative distribution: (number of partition rows preceding or peer with current row) / total partition rows</source>
          <target state="translated">累计分布。(当前行之前或同行的分区行数)/分区行总数。</target>
        </trans-unit>
        <trans-unit id="64607b5d8e4412896465575375d94f0725abe039" translate="yes" xml:space="preserve">
          <source>currency amount</source>
          <target state="translated">币值</target>
        </trans-unit>
        <trans-unit id="b81619f92b172ce2f6fa0a84df042cb5fd37a50f" translate="yes" xml:space="preserve">
          <source>currency symbol (uses locale)</source>
          <target state="translated">货币符号</target>
        </trans-unit>
        <trans-unit id="4f4406b4ea462b2d1ce31fff99c629ac6a9ecade" translate="yes" xml:space="preserve">
          <source>current TID of this or newer row version</source>
          <target state="translated">此行或新行版本的当前TID。</target>
        </trans-unit>
        <trans-unit id="ccae96815d506bcc8eb6b9e7ef48a9c48d733f5f" translate="yes" xml:space="preserve">
          <source>current nesting level of PostgreSQL triggers (0 if not called, directly or indirectly, from inside a trigger)</source>
          <target state="translated">当前PostgreSQL触发器的嵌套级别(如果不是直接或间接从触发器内部调用,则为0)。</target>
        </trans-unit>
        <trans-unit id="779b51a546eca5f4d60da79d0ec7ada57a18e13f" translate="yes" xml:space="preserve">
          <source>current scale factor</source>
          <target state="translated">电流比例系数</target>
        </trans-unit>
        <trans-unit id="056ca10ef8889b41faa742d26656a471608732e4" translate="yes" xml:space="preserve">
          <source>current transaction's start time</source>
          <target state="translated">当前交易的开始时间</target>
        </trans-unit>
        <trans-unit id="3ccfd1fb04d76ca6fa36faf318d4bbbe6e019e62" translate="yes" xml:space="preserve">
          <source>current user is a superuser</source>
          <target state="translated">当前用户为超级用户</target>
        </trans-unit>
        <trans-unit id="e76746f9f64ea77f86d57b4affc2e26c70e97db1" translate="yes" xml:space="preserve">
          <source>current user is the server owner and mapping is for &lt;code&gt;PUBLIC&lt;/code&gt;</source>
          <target state="translated">当前用户是服务器所有者，并且映射是针对 &lt;code&gt;PUBLIC&lt;/code&gt; 的</target>
        </trans-unit>
        <trans-unit id="56acd550331e29f863c4189d4f0d3e7d6050a758" translate="yes" xml:space="preserve">
          <source>current user is the user being mapped, and owns the server or holds &lt;code&gt;USAGE&lt;/code&gt; privilege on it</source>
          <target state="translated">当前用户是被映射的用户，并且拥有服务器或对其拥有 &lt;code&gt;USAGE&lt;/code&gt; 特权</target>
        </trans-unit>
        <trans-unit id="251e17f62ca5a0bad33a4794560b84bff241ddd2" translate="yes" xml:space="preserve">
          <source>dartmouth.edu/~sting/sw/imath</source>
          <target state="translated">dartmouth.edu/~sting/sw/imath</target>
        </trans-unit>
        <trans-unit id="248361612d1d3c64585c3817d26796e95c11dece" translate="yes" xml:space="preserve">
          <source>data pages for large objects</source>
          <target state="translated">大型对象的数据页</target>
        </trans-unit>
        <trans-unit id="c429160164cb02d0618b1e822bdab4bf43fbb586" translate="yes" xml:space="preserve">
          <source>data type name</source>
          <target state="translated">数据类型名称</target>
        </trans-unit>
        <trans-unit id="1bd41877f2856c4d7b5bc551b1c51509f9f61a5b" translate="yes" xml:space="preserve">
          <source>data types</source>
          <target state="translated">数据类型</target>
        </trans-unit>
        <trans-unit id="9dbbcafe5430392decd61d26126df6cde3ef6b46" translate="yes" xml:space="preserve">
          <source>database creation</source>
          <target state="translated">数据库的建立</target>
        </trans-unit>
        <trans-unit id="564babd5efa4c177e7fbceca3d3d19ecd02f9665" translate="yes" xml:space="preserve">
          <source>database roles</source>
          <target state="translated">数据库角色</target>
        </trans-unit>
        <trans-unit id="4167ac168b132ec514ae402ff3cd6a698a1a72b2" translate="yes" xml:space="preserve">
          <source>database size</source>
          <target state="translated">数据库大小</target>
        </trans-unit>
        <trans-unit id="9ac69b495c64616d7b51aad907a1b0a02e1e82e1" translate="yes" xml:space="preserve">
          <source>database users</source>
          <target state="translated">数据库用户</target>
        </trans-unit>
        <trans-unit id="cb7adbeff69aceed0bcbedf307c65b93eee9ad75" translate="yes" xml:space="preserve">
          <source>databases within this database cluster</source>
          <target state="translated">该数据库集群内的数据库</target>
        </trans-unit>
        <trans-unit id="d202efb306923275367bde19b04202628d0810f8" translate="yes" xml:space="preserve">
          <source>date (no time of day)</source>
          <target state="translated">日子</target>
        </trans-unit>
        <trans-unit id="1b3873d4c20bb95e93889a9abb13b9714bb3aebb" translate="yes" xml:space="preserve">
          <source>date and time (no time zone)</source>
          <target state="translated">日期和时间(无时区)</target>
        </trans-unit>
        <trans-unit id="eec85f3a0d545b904948082d0843118f704b1d8d" translate="yes" xml:space="preserve">
          <source>date and time, including time zone</source>
          <target state="translated">日期和时间,包括时区</target>
        </trans-unit>
        <trans-unit id="a8317cc31a263bf0df643e148f49a9ce920f53ce" translate="yes" xml:space="preserve">
          <source>day of ISO 8601 week-numbering year (001&amp;ndash;371; day 1 of the year is Monday of the first ISO week)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2d8e3721b3534cc276e29fdaeef31b7178dcae1" translate="yes" xml:space="preserve">
          <source>day of ISO 8601 week-numbering year (001-371; day 1 of the year is Monday of the first ISO week)</source>
          <target state="translated">周日</target>
        </trans-unit>
        <trans-unit id="090f8b3f331eb935f525922409bffea8e09b7d95" translate="yes" xml:space="preserve">
          <source>day of month (01&amp;ndash;31)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ad17a3576b304f060bc744adbfaf1cfd97c0b9f" translate="yes" xml:space="preserve">
          <source>day of month (01-31)</source>
          <target state="translated">月日(01-31)</target>
        </trans-unit>
        <trans-unit id="469af68e3866ca6a9deafcaeae3928c434d4b3e1" translate="yes" xml:space="preserve">
          <source>day of the week, Sunday (&lt;code&gt;1&lt;/code&gt;) to Saturday (&lt;code&gt;7&lt;/code&gt;)</source>
          <target state="translated">星期几，星期日（ &lt;code&gt;1&lt;/code&gt; ）至星期六（ &lt;code&gt;7&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="0edf11eeeb832dd1b17b8e28879ed7531aa362ac" translate="yes" xml:space="preserve">
          <source>day of year (001&amp;ndash;366)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a71c2096de47fbc8680000b32ef705fe832913e" translate="yes" xml:space="preserve">
          <source>day of year (001-366)</source>
          <target state="translated">年月日(001-366)</target>
        </trans-unit>
        <trans-unit id="700a54df2e790245f9dcd527f33cd998af18e65f" translate="yes" xml:space="preserve">
          <source>dblink_build_sql_update</source>
          <target state="translated">dblink_build_sql_update</target>
        </trans-unit>
        <trans-unit id="a03c4c4da450b6b78f166172cdfad6685ad457cd" translate="yes" xml:space="preserve">
          <source>de-summarize the page range covering the given block, if summarized</source>
          <target state="translated">如果总结了,则去总结覆盖给定块的页面范围。</target>
        </trans-unit>
        <trans-unit id="cbb374265aa2a00ae1a935c1b66a5a8765c5a8db" translate="yes" xml:space="preserve">
          <source>decimal point</source>
          <target state="translated">小数点</target>
        </trans-unit>
        <trans-unit id="f0dcabf47a6adda5ccdca5499ec11830a3bb794d" translate="yes" xml:space="preserve">
          <source>decimal point (uses locale)</source>
          <target state="translated">小数点</target>
        </trans-unit>
        <trans-unit id="d9f9f3ca28421c771e69ddc796196abbfc38261a" translate="yes" xml:space="preserve">
          <source>decompile internal form of an expression, assuming that any Vars in it refer to the relation indicated by the second parameter</source>
          <target state="translated">对表达式的内部形式进行反编译,假设其中的任何Vars都是指第二个参数所表示的关系。</target>
        </trans-unit>
        <trans-unit id="5d0f59b9287cc99be12e3adc0a5ed8bb3aa30762" translate="yes" xml:space="preserve">
          <source>default privileges for object types</source>
          <target state="translated">对象类型的默认权限</target>
        </trans-unit>
        <trans-unit id="7ab389d535d69add8b20d71d3316df0764149116" translate="yes" xml:space="preserve">
          <source>degrees to radians</source>
          <target state="translated">度到弧度</target>
        </trans-unit>
        <trans-unit id="76a1d7b09f9d708126885250c26d9a7c5662a26e" translate="yes" xml:space="preserve">
          <source>delete XID stamp</source>
          <target state="translated">删除XID印章</target>
        </trans-unit>
        <trans-unit id="4e7d874e194c57e56c6808bda722d6e762a82d75" translate="yes" xml:space="preserve">
          <source>delete key from left operand</source>
          <target state="translated">左操作数删除键</target>
        </trans-unit>
        <trans-unit id="5994ddb3d5afc39677fe0d3e53b41199d5e46887" translate="yes" xml:space="preserve">
          <source>delete keys from left operand</source>
          <target state="translated">删除左操作数的键</target>
        </trans-unit>
        <trans-unit id="e872e58a377017a736cf1e1ab4ff236790275777" translate="yes" xml:space="preserve">
          <source>delete matching pairs from left operand</source>
          <target state="translated">删除左操作数中的匹配对</target>
        </trans-unit>
        <trans-unit id="eae96a435f5bdb0c81e63fb0c70854998629b631" translate="yes" xml:space="preserve">
          <source>delete pair with matching key</source>
          <target state="translated">删对</target>
        </trans-unit>
        <trans-unit id="b1c7a2750dfb5f36480871a2e5c6e4567af9e887" translate="yes" xml:space="preserve">
          <source>delete pairs matching those in the second argument</source>
          <target state="translated">删除与第二个参数相匹配的对</target>
        </trans-unit>
        <trans-unit id="3efddac41d9ff2c5cb13d8732824f2be0263e5fa" translate="yes" xml:space="preserve">
          <source>delete pairs with matching keys</source>
          <target state="translated">删除匹配键对</target>
        </trans-unit>
        <trans-unit id="1039b55fb5734d3d36060d3f7c0dffed078f3f5d" translate="yes" xml:space="preserve">
          <source>dependencies between database objects</source>
          <target state="translated">数据库对象之间的依赖关系</target>
        </trans-unit>
        <trans-unit id="bcf260757062336d168e0b854a6bfec054320982" translate="yes" xml:space="preserve">
          <source>dependencies on shared objects</source>
          <target state="translated">对共享对象的依赖性</target>
        </trans-unit>
        <trans-unit id="643b64fb4c981ee959710c294a989bd23751dfb6" translate="yes" xml:space="preserve">
          <source>depending on your system. If you are certain that no conflicting server is running, you can remove the lock file mentioned in the message and try again.</source>
          <target state="translated">取决于你的系统。如果你确定没有冲突的服务器在运行,你可以删除消息中提到的锁文件,然后再试。</target>
        </trans-unit>
        <trans-unit id="74b0f36995620769c56ddd2cbff3cada94967a2b" translate="yes" xml:space="preserve">
          <source>deprecated synonym for &lt;code&gt;@@&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@@&lt;/code&gt; 已弃用的同义词</target>
        </trans-unit>
        <trans-unit id="bfeb202c643a0ab0c62a61acbeda3c7ce92fcd15" translate="yes" xml:space="preserve">
          <source>descriptions or comments on database objects</source>
          <target state="translated">对数据库对象的描述或注释</target>
        </trans-unit>
        <trans-unit id="13c1d29555b21e921b0a3aedc5e4ff745b633b81" translate="yes" xml:space="preserve">
          <source>diameter of circle</source>
          <target state="translated">圆的直径</target>
        </trans-unit>
        <trans-unit id="ff9ccbf023e1d5c01856ab64c92fc6a9f9161e07" translate="yes" xml:space="preserve">
          <source>dict_int</source>
          <target state="translated">dict_int</target>
        </trans-unit>
        <trans-unit id="08bafab9b334b62e4fc9fb37bf107442495772df" translate="yes" xml:space="preserve">
          <source>dict_xsyn</source>
          <target state="translated">dict_xsyn</target>
        </trans-unit>
        <trans-unit id="48d53c6e22192bbaaff43be3456d5f6f5d82da6f" translate="yes" xml:space="preserve">
          <source>difference</source>
          <target state="translated">difference</target>
        </trans-unit>
        <trans-unit id="85ee40d69e337d51248f4aebee5d12dd412aef01" translate="yes" xml:space="preserve">
          <source>digit position (can be dropped if insignificant)</source>
          <target state="translated">位数</target>
        </trans-unit>
        <trans-unit id="a724a4d536d891e4bd851b3b127513c5cac870e7" translate="yes" xml:space="preserve">
          <source>digit position (will not be dropped, even if insignificant)</source>
          <target state="translated">码位</target>
        </trans-unit>
        <trans-unit id="58e4fb37fdcbe481209c5e401fac9ed4117d48b5" translate="yes" xml:space="preserve">
          <source>directory to use for postmaster sockets during upgrade; default is current working directory; environment variable &lt;code&gt;PGSOCKETDIR&lt;/code&gt;</source>
          <target state="translated">升级期间用于邮局主管套接字的目录；默认为当前工作目录；环境变量 &lt;code&gt;PGSOCKETDIR&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="302710649278eb0883ce3392069d7e99b6dfb8f9" translate="yes" xml:space="preserve">
          <source>dirty read</source>
          <target state="translated">脏读</target>
        </trans-unit>
        <trans-unit id="24d5fc5c766af09ab08d7bfd916da7e70bb52c5e" translate="yes" xml:space="preserve">
          <source>discrete percentile: returns the first input value whose position in the ordering equals or exceeds the specified fraction</source>
          <target state="translated">离散百分位数:返回在排序中位置等于或超过指定分数的第一个输入值。</target>
        </trans-unit>
        <trans-unit id="2090e17cbce163da2ce919466e3fd2175625ec32" translate="yes" xml:space="preserve">
          <source>disk blocks</source>
          <target state="translated">磁块</target>
        </trans-unit>
        <trans-unit id="c96264e7d87a9178b70f95d33581e0839e385c5a" translate="yes" xml:space="preserve">
          <source>display a query match</source>
          <target state="translated">显示查询匹配</target>
        </trans-unit>
        <trans-unit id="7a1ad48b2e1eb83707513d8a4c172844610b0eac" translate="yes" xml:space="preserve">
          <source>display version information, then exit</source>
          <target state="translated">显示版本信息,然后退出</target>
        </trans-unit>
        <trans-unit id="314b330f1a69b0d1e908c495db3cf5b21621f484" translate="yes" xml:space="preserve">
          <source>division (integer division truncates the result)</source>
          <target state="translated">除法</target>
        </trans-unit>
        <trans-unit id="030d8c79e8db0778a98b5c136a1d9a70816df62e" translate="yes" xml:space="preserve">
          <source>division (integer truncates the results)</source>
          <target state="translated">除法</target>
        </trans-unit>
        <trans-unit id="4cb6cafbb6abf82018a9534f90701e2e42fca638" translate="yes" xml:space="preserve">
          <source>does &lt;code&gt;hstore&lt;/code&gt; contain all specified keys?</source>
          <target state="translated">不 &lt;code&gt;hstore&lt;/code&gt; 包含所有指定的键？</target>
        </trans-unit>
        <trans-unit id="bafd763d733c6d384cfadd48039c1c94b64a5057" translate="yes" xml:space="preserve">
          <source>does &lt;code&gt;hstore&lt;/code&gt; contain any of the specified keys?</source>
          <target state="translated">不 &lt;code&gt;hstore&lt;/code&gt; 包含任何指定的键？</target>
        </trans-unit>
        <trans-unit id="16f67fbb1f9b0ce89c412fa9f9c91ed03c52ef42" translate="yes" xml:space="preserve">
          <source>does &lt;code&gt;hstore&lt;/code&gt; contain key?</source>
          <target state="translated">确实 &lt;code&gt;hstore&lt;/code&gt; 包含关键？</target>
        </trans-unit>
        <trans-unit id="6d66dc3d673440da44d129cf30dafe0627587c75" translate="yes" xml:space="preserve">
          <source>does &lt;code&gt;hstore&lt;/code&gt; contain non-&lt;code&gt;NULL&lt;/code&gt; value for key?</source>
          <target state="translated">不 &lt;code&gt;hstore&lt;/code&gt; 包含非 &lt;code&gt;NULL&lt;/code&gt; 的键值？</target>
        </trans-unit>
        <trans-unit id="c33f0d5d452e89fd44dcdef1104e34e2460df71f" translate="yes" xml:space="preserve">
          <source>does &lt;code&gt;ltree&lt;/code&gt; array contain any path matching any &lt;code&gt;lquery&lt;/code&gt;?</source>
          <target state="translated">不 &lt;code&gt;ltree&lt;/code&gt; 阵列包含匹配任何任何路径 &lt;code&gt;lquery&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="1c53b57b8ca3d240b9dc88085af96b6dbab6fa68" translate="yes" xml:space="preserve">
          <source>does &lt;code&gt;ltree&lt;/code&gt; match &lt;code&gt;lquery&lt;/code&gt;?</source>
          <target state="translated">确实 &lt;code&gt;ltree&lt;/code&gt; 匹配 &lt;code&gt;lquery&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="3648ad67b9d0438df764a00aa33a91ea0f51da62" translate="yes" xml:space="preserve">
          <source>does &lt;code&gt;ltree&lt;/code&gt; match &lt;code&gt;ltxtquery&lt;/code&gt;?</source>
          <target state="translated">确实 &lt;code&gt;ltree&lt;/code&gt; 匹配 &lt;code&gt;ltxtquery&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="bee15116149fbb94972f0f1f0a198543b5d86fe4" translate="yes" xml:space="preserve">
          <source>does &lt;code&gt;ltree&lt;/code&gt; match any &lt;code&gt;lquery&lt;/code&gt; in array?</source>
          <target state="translated">不 &lt;code&gt;ltree&lt;/code&gt; 匹配任何 &lt;code&gt;lquery&lt;/code&gt; 数组？</target>
        </trans-unit>
        <trans-unit id="6daa1a6ed3cacf7a57ce4c941eea23a2076c5480" translate="yes" xml:space="preserve">
          <source>does &lt;em&gt;not&lt;/em&gt; mean you've run out of disk space. It means your kernel's limit on the number of System V semaphores is smaller than the number PostgreSQL wants to create. As above, you might be able to work around the problem by starting the server with a reduced number of allowed connections (&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;), but you'll eventually want to increase the kernel limit.</source>
          <target state="translated">不&lt;em&gt;不&lt;/em&gt;意味着你已经用完了磁盘空间。这意味着您的内核对System V信号量的限制小于PostgreSQL要创建的数目。如上所述，您可以通过减少允许的连接数（&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;）启动服务器来解决此问题，但最终您将希望增加内核限制。</target>
        </trans-unit>
        <trans-unit id="64868bbf0f6334a11707f036779fce59caac51fe" translate="yes" xml:space="preserve">
          <source>does array contain a descendant of &lt;code&gt;ltree&lt;/code&gt;?</source>
          <target state="translated">数组是否包含 &lt;code&gt;ltree&lt;/code&gt; 的后代？</target>
        </trans-unit>
        <trans-unit id="a301dc21d55ea9fa1daaf587093b7b700878a61f" translate="yes" xml:space="preserve">
          <source>does array contain an ancestor of &lt;code&gt;ltree&lt;/code&gt;?</source>
          <target state="translated">数组是否包含 &lt;code&gt;ltree&lt;/code&gt; 的祖先？</target>
        </trans-unit>
        <trans-unit id="567bff233f20cf454c16349c2b002f100e4644d2" translate="yes" xml:space="preserve">
          <source>does array contain any path matching &lt;code&gt;lquery&lt;/code&gt;?</source>
          <target state="translated">数组是否包含任何与 &lt;code&gt;lquery&lt;/code&gt; 匹配的路径？</target>
        </trans-unit>
        <trans-unit id="7d7b1ca647e0b44d6a318e89c4b79d80dec00662" translate="yes" xml:space="preserve">
          <source>does array contain any path matching &lt;code&gt;ltxtquery&lt;/code&gt;?</source>
          <target state="translated">数组是否包含任何与 &lt;code&gt;ltxtquery&lt;/code&gt; 匹配的路径？</target>
        </trans-unit>
        <trans-unit id="d0e93f199be58627d5290fb7e295a3883e34de0e" translate="yes" xml:space="preserve">
          <source>does current user have privilege for any column of table</source>
          <target state="translated">当前用户是否对表的任何一列有权限?</target>
        </trans-unit>
        <trans-unit id="923f34e72b54c44d587b74dfe716fb9e7a0b69f3" translate="yes" xml:space="preserve">
          <source>does current user have privilege for column</source>
          <target state="translated">当前用户是否有列的权限</target>
        </trans-unit>
        <trans-unit id="8eebefcd3db5e0fd1f67f23a742c8cbdb52ca488" translate="yes" xml:space="preserve">
          <source>does current user have privilege for database</source>
          <target state="translated">当前用户是否有数据库的权限</target>
        </trans-unit>
        <trans-unit id="d5d20390d72f10839e55e755a41622b4e83aaad2" translate="yes" xml:space="preserve">
          <source>does current user have privilege for foreign server</source>
          <target state="translated">当前用户是否有国外服务器的权限</target>
        </trans-unit>
        <trans-unit id="76e06765244ec4f69ad0edf35314e91668644688" translate="yes" xml:space="preserve">
          <source>does current user have privilege for foreign-data wrapper</source>
          <target state="translated">当前用户是否有权限使用外来数据封装器?</target>
        </trans-unit>
        <trans-unit id="14cf9981a77c04be078c13991b9209c61e42b19f" translate="yes" xml:space="preserve">
          <source>does current user have privilege for function</source>
          <target state="translated">当前用户是否有权限使用函数</target>
        </trans-unit>
        <trans-unit id="e53afcf7f590b1f341c771ee932c34274218fee2" translate="yes" xml:space="preserve">
          <source>does current user have privilege for language</source>
          <target state="translated">当前用户是否有语言权限</target>
        </trans-unit>
        <trans-unit id="d392178c73923ceb61788ee59e66cfc98b85b093" translate="yes" xml:space="preserve">
          <source>does current user have privilege for role</source>
          <target state="translated">当前用户是否有角色权限</target>
        </trans-unit>
        <trans-unit id="3ce043cb41e01186d5429925060d21732a8a9b01" translate="yes" xml:space="preserve">
          <source>does current user have privilege for schema</source>
          <target state="translated">当前用户是否拥有模式的权限</target>
        </trans-unit>
        <trans-unit id="44e2c7a7969b5280a9ac5e18312a1a719915e5c8" translate="yes" xml:space="preserve">
          <source>does current user have privilege for sequence</source>
          <target state="translated">当前用户是否拥有序列的权限</target>
        </trans-unit>
        <trans-unit id="a8553aada6aa07a63b9fb14a123e6eb5d6132d87" translate="yes" xml:space="preserve">
          <source>does current user have privilege for table</source>
          <target state="translated">当前用户是否有表的权限</target>
        </trans-unit>
        <trans-unit id="aa74612a59a28280141be932e93980e9b80f16c8" translate="yes" xml:space="preserve">
          <source>does current user have privilege for tablespace</source>
          <target state="translated">当前用户是否拥有表空间的权限</target>
        </trans-unit>
        <trans-unit id="dd7e9d6b9c5d3197cefad7a4260eb463901b4b09" translate="yes" xml:space="preserve">
          <source>does current user have privilege for type</source>
          <target state="translated">当前用户是否拥有类型的权限</target>
        </trans-unit>
        <trans-unit id="65119e338c802227733d23f560577b1f92332234" translate="yes" xml:space="preserve">
          <source>does current user have row level security active for table</source>
          <target state="translated">当前用户是否对表有行级安全活动?</target>
        </trans-unit>
        <trans-unit id="b12d604405828eb6355ba772e8353d7dff5c090e" translate="yes" xml:space="preserve">
          <source>does left operand contain right?</source>
          <target state="translated">左操作数是否包含右操作数?</target>
        </trans-unit>
        <trans-unit id="756c9771ba43bfeb3fc0b27733143e509011767d" translate="yes" xml:space="preserve">
          <source>does not contradict common sense, neither does the intersection</source>
          <target state="translated">与常识并不矛盾,交集也不矛盾。</target>
        </trans-unit>
        <trans-unit id="b36715a10925245466a61b1c713e5e53614f7d3c" translate="yes" xml:space="preserve">
          <source>does not extend to the left of</source>
          <target state="translated">不向左延伸</target>
        </trans-unit>
        <trans-unit id="7d4052eb9215bde986d065d712fe5d1ea63cb4dd" translate="yes" xml:space="preserve">
          <source>does not extend to the right of</source>
          <target state="translated">不延伸到以下权利</target>
        </trans-unit>
        <trans-unit id="f7f46d46a353213d12fe0e106cd32be9a96a313c" translate="yes" xml:space="preserve">
          <source>does not result in an error, because the &lt;code&gt;||&lt;/code&gt; operator does not care about collations: its result is the same regardless of the collation.</source>
          <target state="translated">不会导致错误，因为 &lt;code&gt;||&lt;/code&gt; 运算符不关心排序规则：无论排序规则如何，其结果都是相同的。</target>
        </trans-unit>
        <trans-unit id="75e4c1b191e5aba3fca713359bb284f3bba53197" translate="yes" xml:space="preserve">
          <source>does user have privilege for any column of table</source>
          <target state="translated">用户是否对表中的任何一列有权限?</target>
        </trans-unit>
        <trans-unit id="3e3a02344dffd3279b448eb7d8ae2788f7b6be07" translate="yes" xml:space="preserve">
          <source>does user have privilege for column</source>
          <target state="translated">用户是否有列的权限</target>
        </trans-unit>
        <trans-unit id="e98b58c4f0fc14060c4884df933960d9628f8716" translate="yes" xml:space="preserve">
          <source>does user have privilege for database</source>
          <target state="translated">用户是否有数据库的权限</target>
        </trans-unit>
        <trans-unit id="765c96c7f8619408b3a2ef1d6a65be4c1cacb9c9" translate="yes" xml:space="preserve">
          <source>does user have privilege for foreign server</source>
          <target state="translated">用户是否有国外服务器的权限</target>
        </trans-unit>
        <trans-unit id="a1aad5c71dcb9de7b0ebfe1791764c821ee31f90" translate="yes" xml:space="preserve">
          <source>does user have privilege for foreign-data wrapper</source>
          <target state="translated">用户是否有权限使用外来数据封装器?</target>
        </trans-unit>
        <trans-unit id="c225f178288924737bfa6e4b6a297dd843498dd4" translate="yes" xml:space="preserve">
          <source>does user have privilege for function</source>
          <target state="translated">用户是否有功能权限</target>
        </trans-unit>
        <trans-unit id="d470907c424695bcabb45adae12569de1bad3b0d" translate="yes" xml:space="preserve">
          <source>does user have privilege for language</source>
          <target state="translated">用户是否有语言权限</target>
        </trans-unit>
        <trans-unit id="a0ba62c173d0bc0e7a46899574360820b2bc2f9f" translate="yes" xml:space="preserve">
          <source>does user have privilege for role</source>
          <target state="translated">用户是否有角色权限</target>
        </trans-unit>
        <trans-unit id="bed67dbbf088b4b1ffec5c7180d7d0ec267b5df8" translate="yes" xml:space="preserve">
          <source>does user have privilege for schema</source>
          <target state="translated">用户是否拥有模式的权限</target>
        </trans-unit>
        <trans-unit id="fda3d32d403e4d198f5f4e5703028831a30fe866" translate="yes" xml:space="preserve">
          <source>does user have privilege for sequence</source>
          <target state="translated">用户是否有序列权限</target>
        </trans-unit>
        <trans-unit id="0b3c10883f54a4a3a8e9b7a17c728cb3f9c09b6a" translate="yes" xml:space="preserve">
          <source>does user have privilege for table</source>
          <target state="translated">用户是否有表的权限</target>
        </trans-unit>
        <trans-unit id="d616ba1bcc2173d55dc3b40b681e7e2c83c7625d" translate="yes" xml:space="preserve">
          <source>does user have privilege for tablespace</source>
          <target state="translated">用户是否有表空间的权限</target>
        </trans-unit>
        <trans-unit id="f37310ea7053667a4967493d91089148515177e4" translate="yes" xml:space="preserve">
          <source>does user have privilege for type</source>
          <target state="translated">用户是否有该类型的权限</target>
        </trans-unit>
        <trans-unit id="bdb36bb22deb169275b3094ba9005a29eeddd195" translate="yes" xml:space="preserve">
          <source>double</source>
          <target state="translated">double</target>
        </trans-unit>
        <trans-unit id="f70c61055e7cd930e448a61146df9dcec538dae5" translate="yes" xml:space="preserve">
          <source>double if any &lt;code&gt;a&lt;/code&gt; is double, else integer</source>
          <target state="translated">如果任何 &lt;code&gt;a&lt;/code&gt; 为double，则为double，否则为整数</target>
        </trans-unit>
        <trans-unit id="a9d7d2a5b010ce1408927d410711b2b9b2dcf630" translate="yes" xml:space="preserve">
          <source>double precision</source>
          <target state="translated">双精度</target>
        </trans-unit>
        <trans-unit id="7bd1b3d84f60bc411ebad0e502e786bfb5dff6b4" translate="yes" xml:space="preserve">
          <source>double precision floating-point number (8 bytes)</source>
          <target state="translated">双精度浮点数(8字节)</target>
        </trans-unit>
        <trans-unit id="2b0e335cd50db4422abd071d794ce8250a0af460" translate="yes" xml:space="preserve">
          <source>download dictionary configuration files. OpenOffice extension files have the &lt;code&gt;.oxt&lt;/code&gt; extension. It is necessary to extract &lt;code&gt;.aff&lt;/code&gt; and &lt;code&gt;.dic&lt;/code&gt; files, change extensions to &lt;code&gt;.affix&lt;/code&gt; and &lt;code&gt;.dict&lt;/code&gt;. For some dictionary files it is also needed to convert characters to the UTF-8 encoding with commands (for example, for a Norwegian language dictionary):</source>
          <target state="translated">下载字典配置文件。OpenOffice扩展文件的扩展名为 &lt;code&gt;.oxt&lt;/code&gt; 。必须提取 &lt;code&gt;.aff&lt;/code&gt; 和 &lt;code&gt;.dic&lt;/code&gt; 文件，将扩展名更改为 &lt;code&gt;.affix&lt;/code&gt; 和 &lt;code&gt;.dict&lt;/code&gt; 。对于某些词典文件，还需要使用命令将字符转换为UTF-8编码（例如，对于挪威语词典）：</target>
        </trans-unit>
        <trans-unit id="6cbe8eee2be1493251c74aba3d14ce090704c314" translate="yes" xml:space="preserve">
          <source>dropdb</source>
          <target state="translated">dropdb</target>
        </trans-unit>
        <trans-unit id="da2f55f30903093b88b2abe2ff1d8c8878785d4d" translate="yes" xml:space="preserve">
          <source>dropdb &amp;mdash; remove a PostgreSQL database</source>
          <target state="translated">dropdb &amp;mdash;删除PostgreSQL数据库</target>
        </trans-unit>
        <trans-unit id="cee0a709ed144356dd15d656bc6b22fb78c87ab6" translate="yes" xml:space="preserve">
          <source>dropdb accepts the following command-line arguments:</source>
          <target state="translated">dropdb 接受以下命令行参数。</target>
        </trans-unit>
        <trans-unit id="6f5dc55cde4d56805bce8487bd823396755fbd8f" translate="yes" xml:space="preserve">
          <source>dropdb also accepts the following command-line arguments for connection parameters:</source>
          <target state="translated">dropdb 还接受以下连接参数的命令行参数。</target>
        </trans-unit>
        <trans-unit id="b2c63240befa5a55623102754bbe3f06e330117d" translate="yes" xml:space="preserve">
          <source>dropdb destroys an existing PostgreSQL database. The user who executes this command must be a database superuser or the owner of the database.</source>
          <target state="translated">dropdb 销毁一个现有的 PostgreSQL 数据库。执行此命令的用户必须是数据库超级用户或数据库的所有者。</target>
        </trans-unit>
        <trans-unit id="5fdb4e6dd14831ab684970c9656f06e02410c343" translate="yes" xml:space="preserve">
          <source>dropdb is a wrapper around the SQL command &lt;a href=&quot;sql-dropdatabase&quot;&gt;DROP DATABASE&lt;/a&gt;. There is no effective difference between dropping databases via this utility and via other methods for accessing the server.</source>
          <target state="translated">dropdb是SQL命令&lt;a href=&quot;sql-dropdatabase&quot;&gt;DROP DATABASE&lt;/a&gt;的包装。通过此实用程序和通过其他访问服务器的方法删除数据库之间没有有效的区别。</target>
        </trans-unit>
        <trans-unit id="61f8d2eb809b42145cb0c2cc59455f90ae6b39d4" translate="yes" xml:space="preserve">
          <source>dropuser</source>
          <target state="translated">dropuser</target>
        </trans-unit>
        <trans-unit id="3d4f5569f58e7a7d09eb7133d2210c8728567a77" translate="yes" xml:space="preserve">
          <source>dropuser &amp;mdash; remove a PostgreSQL user account</source>
          <target state="translated">dropuser &amp;mdash;删除PostgreSQL用户帐户</target>
        </trans-unit>
        <trans-unit id="1077aba6c2b30bf419021fbb806b212443ec339c" translate="yes" xml:space="preserve">
          <source>dropuser accepts the following command-line arguments:</source>
          <target state="translated">dropuser 接受以下命令行参数。</target>
        </trans-unit>
        <trans-unit id="2671207f049e22f4b10b3fd2b9765935cf20ee06" translate="yes" xml:space="preserve">
          <source>dropuser also accepts the following command-line arguments for connection parameters:</source>
          <target state="translated">dropuser 还接受以下连接参数的命令行参数。</target>
        </trans-unit>
        <trans-unit id="c9d1416783a863b7c532e14663d3712fc1f90804" translate="yes" xml:space="preserve">
          <source>dropuser is a wrapper around the SQL command &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt;. There is no effective difference between dropping users via this utility and via other methods for accessing the server.</source>
          <target state="translated">dropuser是SQL命令&lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt;的包装。通过此实用程序和通过其他访问服务器的方法删除用户之间没有有效的区别。</target>
        </trans-unit>
        <trans-unit id="4c08c2e0100e4eb26441eea8482accbff764a871" translate="yes" xml:space="preserve">
          <source>dropuser removes an existing PostgreSQL user. Only superusers and users with the &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can remove PostgreSQL users. (To remove a superuser, you must yourself be a superuser.)</source>
          <target state="translated">dropuser删除现有的PostgreSQL用户。只有超级用户和具有 &lt;code&gt;CREATEROLE&lt;/code&gt; 特权的用户才能删除PostgreSQL用户。（要删除超级用户，您必须自己是超级用户。）</target>
        </trans-unit>
        <trans-unit id="2d1c3f7cb60beb3d49e3f4e046f5ea896f8b0a5d" translate="yes" xml:space="preserve">
          <source>earlier than all other time stamps</source>
          <target state="translated">早于其他时间段</target>
        </trans-unit>
        <trans-unit id="d00152028f9066049bf52b54717487fea14124ea" translate="yes" xml:space="preserve">
          <source>earthdistance</source>
          <target state="translated">earthdistance</target>
        </trans-unit>
        <trans-unit id="d13f9c0d833baac358fedb3d5d5130ba389408d4" translate="yes" xml:space="preserve">
          <source>ecpg</source>
          <target state="translated">ecpg</target>
        </trans-unit>
        <trans-unit id="ee8426e3ae205f6a4fbf14400afc72dbe65a18e6" translate="yes" xml:space="preserve">
          <source>ecpg &amp;mdash; embedded SQL C preprocessor</source>
          <target state="translated">ecpg &amp;mdash;嵌入式SQL C预处理程序</target>
        </trans-unit>
        <trans-unit id="431fd257c42ba97d31ee98637d51749f58818b72" translate="yes" xml:space="preserve">
          <source>element is contained by</source>
          <target state="translated">元素包含在</target>
        </trans-unit>
        <trans-unit id="7fd8de61bf0672691fbb98aab87cd593aeaf89f4" translate="yes" xml:space="preserve">
          <source>element-to-array concatenation</source>
          <target state="translated">元素到数组的连接</target>
        </trans-unit>
        <trans-unit id="ab2afe87d80f8f35bf989060afa3c6ac12a43886" translate="yes" xml:space="preserve">
          <source>enable verbose internal logging</source>
          <target state="translated">启用详细的内部记录</target>
        </trans-unit>
        <trans-unit id="7cbe751985c35402c31394cb0929695fc5649328" translate="yes" xml:space="preserve">
          <source>encoding conversion information</source>
          <target state="translated">编码转换信息</target>
        </trans-unit>
        <trans-unit id="1671ca77906f61454bce6768a91e2e8e821e8948" translate="yes" xml:space="preserve">
          <source>enum label and value definitions</source>
          <target state="translated">枚举标签和值定义</target>
        </trans-unit>
        <trans-unit id="f57b2d312d9efe8fe993c8eb1f3e19d41ad04030" translate="yes" xml:space="preserve">
          <source>equal</source>
          <target state="translated">equal</target>
        </trans-unit>
        <trans-unit id="44040a02784585bdd6249b4edd2dd94238188e6f" translate="yes" xml:space="preserve">
          <source>equal, treating null like an ordinary value</source>
          <target state="translated">等于,把null当做一个普通的值</target>
        </trans-unit>
        <trans-unit id="80b2f559a14748525776894e12e1216b49b5b558" translate="yes" xml:space="preserve">
          <source>equals</source>
          <target state="translated">equals</target>
        </trans-unit>
        <trans-unit id="f18bd7a51999b2b1d95efa4274723b39e0ac6b39" translate="yes" xml:space="preserve">
          <source>equivalent to &lt;code&gt;bool_and&lt;/code&gt;</source>
          <target state="translated">相当于 &lt;code&gt;bool_and&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a4232efd7b52fa7af1f07ed9b444c78b5cec9a81" translate="yes" xml:space="preserve">
          <source>equivalent to &lt;code&gt;current_user&lt;/code&gt;</source>
          <target state="translated">等效于 &lt;code&gt;current_user&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="65b09de7c4f948564eb4e9f8a8c8ad7481598866" translate="yes" xml:space="preserve">
          <source>era indicator (with periods)</source>
          <target state="translated">时标</target>
        </trans-unit>
        <trans-unit id="24e96aa5ab5679037b391de37b4ce482d43684f1" translate="yes" xml:space="preserve">
          <source>era indicator (without periods)</source>
          <target state="translated">时标</target>
        </trans-unit>
        <trans-unit id="cdecabe1520a398e4e46deff9d55b19bed6d6457" translate="yes" xml:space="preserve">
          <source>escape</source>
          <target state="translated">escape</target>
        </trans-unit>
        <trans-unit id="be464074e84929b3edb1afc53993489c2a50213d" translate="yes" xml:space="preserve">
          <source>even though there will really be zero rows satisfying this query. Functional dependency statistics do not provide enough information to conclude that, however.</source>
          <target state="translated">即使真的会有零条记录满足这个查询。然而,功能依赖性统计并没有提供足够的信息来得出结论。</target>
        </trans-unit>
        <trans-unit id="b2fe05583b44066ff5424d20e6314b48bc6e0ea7" translate="yes" xml:space="preserve">
          <source>even though they had no intention of ever using &lt;code&gt;y&lt;/code&gt; as part of a &lt;code&gt;WHERE&lt;/code&gt; clause. This works fine as long as the extra columns are trailing columns; making them be leading columns is unwise for the reasons explained in &lt;a href=&quot;indexes-multicolumn&quot;&gt;Section 11.3&lt;/a&gt;. However, this method doesn't support the case where you want the index to enforce uniqueness on the key column(s).</source>
          <target state="translated">即使他们无意将 &lt;code&gt;y&lt;/code&gt; 用作 &lt;code&gt;WHERE&lt;/code&gt; 子句的一部分。只要多余的列是尾随列，这就可以正常工作；由于&lt;a href=&quot;indexes-multicolumn&quot;&gt;第11.3节中&lt;/a&gt;解释的原因，使它们成为领先者是不明智的。但是，此方法不支持您希望索引在键列上强制唯一性的情况。</target>
        </trans-unit>
        <trans-unit id="7833e7d391c504aee68e45dea9634b1c53821bff" translate="yes" xml:space="preserve">
          <source>event triggers</source>
          <target state="translated">事件触发</target>
        </trans-unit>
        <trans-unit id="f5caa8594147ec7c253638db4988e8f1141145c5" translate="yes" xml:space="preserve">
          <source>eventlog</source>
          <target state="translated">eventlog</target>
        </trans-unit>
        <trans-unit id="a1369004de61926651324b802d6bf7dde40d8308" translate="yes" xml:space="preserve">
          <source>exact numeric of selectable precision</source>
          <target state="translated">精确</target>
        </trans-unit>
        <trans-unit id="910088c467ddca75f7465dd40037d50a4b1024d5" translate="yes" xml:space="preserve">
          <source>exactly one of &lt;code&gt;A&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;B&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;B&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;A&lt;/code&gt; is true (&lt;em&gt;trichotomy law&lt;/em&gt;)</source>
          <target state="translated">正好 &lt;code&gt;A&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;B&lt;/code&gt; ， &lt;code&gt;A&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;B&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;A&lt;/code&gt; 之一为真（&lt;em&gt;三分法&lt;/em&gt;）</target>
        </trans-unit>
        <trans-unit id="98585ed8f50402fa8abbe3b11d352d8c7b352517" translate="yes" xml:space="preserve">
          <source>expand a &lt;code&gt;tsvector&lt;/code&gt; to a set of rows</source>
          <target state="translated">将 &lt;code&gt;tsvector&lt;/code&gt; 扩展到一组行</target>
        </trans-unit>
        <trans-unit id="f1b33fd39221d674e864b833837123f8c9c566a5" translate="yes" xml:space="preserve">
          <source>expand an array to a set of rows</source>
          <target state="translated">扩充数组为一组行</target>
        </trans-unit>
        <trans-unit id="b4177b3fdd9f1dcef4246133756c7d4295ee3473" translate="yes" xml:space="preserve">
          <source>expand multiple arrays (possibly of different types) to a set of rows. This is only allowed in the FROM clause; see &lt;a href=&quot;queries-table-expressions#QUERIES-TABLEFUNCTIONS&quot;&gt;Section 7.2.1.4&lt;/a&gt;</source>
          <target state="translated">将多个数组（可能是不同类型）扩展为一组行。这仅在FROM子句中允许；参见&lt;a href=&quot;queries-table-expressions#QUERIES-TABLEFUNCTIONS&quot;&gt;第7.2.1.4节&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4500e56b5a24d60ce7b2499c19162fb567e578b4" translate="yes" xml:space="preserve">
          <source>expanded syntax (see below)</source>
          <target state="translated">扩充语法</target>
        </trans-unit>
        <trans-unit id="51a433a570f5960fccaccfbfa93909e78f841178" translate="yes" xml:space="preserve">
          <source>exponent for scientific notation</source>
          <target state="translated">指数</target>
        </trans-unit>
        <trans-unit id="dc606218848a18d5c34862a175d29c1fe03c13d9" translate="yes" xml:space="preserve">
          <source>exponential</source>
          <target state="translated">exponential</target>
        </trans-unit>
        <trans-unit id="1e78ce1a1f32081b3133e35ca2ce8f4369be90ee" translate="yes" xml:space="preserve">
          <source>exponentially-distributed random integer in &lt;code&gt;[lb, ub]&lt;/code&gt;, see below</source>
          <target state="translated">&lt;code&gt;[lb, ub]&lt;/code&gt; 指数分布随机整数，请参见下文</target>
        </trans-unit>
        <trans-unit id="1d422390c5a3d1333fb7f5d97621fa0f6e7f0d6c" translate="yes" xml:space="preserve">
          <source>exponentiation</source>
          <target state="translated">exponentiation</target>
        </trans-unit>
        <trans-unit id="0db5a9a232a6935699542e335a56a8df9f43d2e9" translate="yes" xml:space="preserve">
          <source>exponentiation (associates left to right)</source>
          <target state="translated">乘法</target>
        </trans-unit>
        <trans-unit id="5d7f1bff34ea278c6c5a2fc91295c8a87607dc57" translate="yes" xml:space="preserve">
          <source>extended planner statistics</source>
          <target state="translated">扩展规划师统计</target>
        </trans-unit>
        <trans-unit id="cc65f5c101ab8b09f58273801d736b9e9677d0e8" translate="yes" xml:space="preserve">
          <source>extended planner statistics (built statistics)</source>
          <target state="translated">扩展的规划师统计(建筑统计)</target>
        </trans-unit>
        <trans-unit id="6d557d048a3b2c532f56398c201f9c70fcd3184e" translate="yes" xml:space="preserve">
          <source>extended planner statistics (definition)</source>
          <target state="translated">扩展规划师统计(定义)</target>
        </trans-unit>
        <trans-unit id="b56ba1d1de71303ba9e7ac7e6d37ccee335d2140" translate="yes" xml:space="preserve">
          <source>external node identifier</source>
          <target state="translated">外部节点标识符</target>
        </trans-unit>
        <trans-unit id="8cea632a3c2f5380e27bf9754368859382f731f4" translate="yes" xml:space="preserve">
          <source>extract IP address and netmask length as text</source>
          <target state="translated">提取IP地址和网络掩码长度为文本。</target>
        </trans-unit>
        <trans-unit id="1adf6634d9f5912d39aae24816f962b74dbd1d3d" translate="yes" xml:space="preserve">
          <source>extract IP address as text</source>
          <target state="translated">提取IP地址为文本</target>
        </trans-unit>
        <trans-unit id="52224bb43ff5437ccb717a45646600f74c89bca0" translate="yes" xml:space="preserve">
          <source>extract a subset of an &lt;code&gt;hstore&lt;/code&gt;</source>
          <target state="translated">提取一个 &lt;code&gt;hstore&lt;/code&gt; 的子集</target>
        </trans-unit>
        <trans-unit id="6a0f78ab60fe16f14c77cc85e268514510fb939e" translate="yes" xml:space="preserve">
          <source>extract family of address; &lt;code&gt;4&lt;/code&gt; for IPv4, &lt;code&gt;6&lt;/code&gt; for IPv6</source>
          <target state="translated">提取地址族；IPv4 为 &lt;code&gt;4&lt;/code&gt; ，IPv6 为 &lt;code&gt;6&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="63b60e17da1c01c315490ec61d92c6ae1b9cfac1" translate="yes" xml:space="preserve">
          <source>extract netmask length</source>
          <target state="translated">提取网罩长度</target>
        </trans-unit>
        <trans-unit id="8eb7d749717b314ca4b624308f167fb8f0536c57" translate="yes" xml:space="preserve">
          <source>extract network part of address</source>
          <target state="translated">网段提取</target>
        </trans-unit>
        <trans-unit id="cf2f15ec5a30d6402b8a8b59c0f122369583dbf1" translate="yes" xml:space="preserve">
          <source>f(x) = PHI(2.0 * parameter * (x - mu) / (max - min + 1)) / (2.0 * PHI(parameter) - 1)</source>
          <target state="translated">f(x)=PHI(2.0*参数*(x-mu)/(max-min+1))/(2.0*PHI(参数)-1)</target>
        </trans-unit>
        <trans-unit id="d8ecaf8c657a2b137edff4403d3015c673733131" translate="yes" xml:space="preserve">
          <source>f(x) = exp(-parameter * (x - min) / (max - min + 1)) / (1 - exp(-parameter))</source>
          <target state="translated">f(x)=exp(-参数*(x-min)/(max-min+1))/(1-exp(-参数))</target>
        </trans-unit>
        <trans-unit id="2bd70faaff2dc3145c4f93d20179cef8d5fd1bdd" translate="yes" xml:space="preserve">
          <source>factorial</source>
          <target state="translated">factorial</target>
        </trans-unit>
        <trans-unit id="30d4e08f4264897498d5f939d1ac8e6b0526d163" translate="yes" xml:space="preserve">
          <source>factorial (prefix operator)</source>
          <target state="translated">阶乘</target>
        </trans-unit>
        <trans-unit id="519c2566cb819aa98f00c389f875acd6c2f82fd8" translate="yes" xml:space="preserve">
          <source>field size</source>
          <target state="translated">字段大小</target>
        </trans-unit>
        <trans-unit id="3a88b38ae3a3604d3f1af4ad93ba5fe6fb9f87bc" translate="yes" xml:space="preserve">
          <source>file_fdw</source>
          <target state="translated">file_fdw</target>
        </trans-unit>
        <trans-unit id="983401d0e918dc765c97b567a565058e6af554ed" translate="yes" xml:space="preserve">
          <source>fill mode (suppress leading zeroes and padding blanks)</source>
          <target state="translated">填充模式(抑制前导零和填充空白)</target>
        </trans-unit>
        <trans-unit id="a5e4a7072f8551b572a1cee1a88417461488e2a7" translate="yes" xml:space="preserve">
          <source>fill mode (suppress trailing zeroes and padding blanks)</source>
          <target state="translated">填充模式(抑制尾部零点和填充空白)</target>
        </trans-unit>
        <trans-unit id="32003507876dacdf67e2131262acee891800afea" translate="yes" xml:space="preserve">
          <source>first array entry that is a descendant of &lt;code&gt;ltree&lt;/code&gt;; NULL if none</source>
          <target state="translated">是 &lt;code&gt;ltree&lt;/code&gt; 的后代的第一个数组项; 如果没有则为NULL</target>
        </trans-unit>
        <trans-unit id="515013b791f433a9eae1982ebea0e32381eccb14" translate="yes" xml:space="preserve">
          <source>first array entry that is an ancestor of &lt;code&gt;ltree&lt;/code&gt;; NULL if none</source>
          <target state="translated">第一个数组条目，是 &lt;code&gt;ltree&lt;/code&gt; 的祖先; 如果没有则为NULL</target>
        </trans-unit>
        <trans-unit id="5a3fdedfab8428272c62bd9bbab1aa027083b860" translate="yes" xml:space="preserve">
          <source>first array entry that matches &lt;code&gt;lquery&lt;/code&gt;; NULL if none</source>
          <target state="translated">与 &lt;code&gt;lquery&lt;/code&gt; 匹配的第一个数组项；如果没有则为NULL</target>
        </trans-unit>
        <trans-unit id="086d1f932d7df2500f28084d6285586dd205f44c" translate="yes" xml:space="preserve">
          <source>first array entry that matches &lt;code&gt;ltxtquery&lt;/code&gt;; NULL if none</source>
          <target state="translated">第一个与 &lt;code&gt;ltxtquery&lt;/code&gt; 匹配的数组项；如果没有则为NULL</target>
        </trans-unit>
        <trans-unit id="25970e09bd0194f53db323fdee569ecc5ee9d06a" translate="yes" xml:space="preserve">
          <source>fixed format global option (see usage notes)</source>
          <target state="translated">固定格式全局选项(见使用说明</target>
        </trans-unit>
        <trans-unit id="f6a11edd2a4d248a530de4d7e132bac84862a375" translate="yes" xml:space="preserve">
          <source>fixed-length bit string</source>
          <target state="translated">固定长度位串</target>
        </trans-unit>
        <trans-unit id="dcb97d9db2463758f31c0de9d3bce9df50408dfb" translate="yes" xml:space="preserve">
          <source>fixed-length character string</source>
          <target state="translated">固定长度的字符串</target>
        </trans-unit>
        <trans-unit id="223f2208f7d4b1043c7e491f40e2e2d8ed03ae8b" translate="yes" xml:space="preserve">
          <source>fixed-length, blank padded</source>
          <target state="translated">固定长度,空白填充</target>
        </trans-unit>
        <trans-unit id="42f81371a9d58223349ec7034da245db8ada9ccd" translate="yes" xml:space="preserve">
          <source>flag (name of the affix class)</source>
          <target state="translated">旗子</target>
        </trans-unit>
        <trans-unit id="b0163776e81d6187e8b5cfa662418933736608b6" translate="yes" xml:space="preserve">
          <source>flags identifying &lt;code&gt;NULL&lt;/code&gt; values</source>
          <target state="translated">标识 &lt;code&gt;NULL&lt;/code&gt; 值的标志</target>
        </trans-unit>
        <trans-unit id="93d9feb10aec6e36f31762cbd4d5259b39c8aceb" translate="yes" xml:space="preserve">
          <source>foreign server definitions</source>
          <target state="translated">国外服务器定义</target>
        </trans-unit>
        <trans-unit id="0d25df728aebb140e50bd8e011aaf8a6c6258f90" translate="yes" xml:space="preserve">
          <source>foreign-data wrapper definitions</source>
          <target state="translated">外来数据封装器定义</target>
        </trans-unit>
        <trans-unit id="cacfbd40505fff5a97d7effce15468bbc881b94d" translate="yes" xml:space="preserve">
          <source>form feed</source>
          <target state="translated">进料</target>
        </trans-unit>
        <trans-unit id="e03c80c93af95df14136862d42780c28c008d0cd" translate="yes" xml:space="preserve">
          <source>form feed, as in C</source>
          <target state="translated">饲料形式,如C</target>
        </trans-unit>
        <trans-unit id="170f5a3f34787c6aab8fa71dfbca18211e9264aa" translate="yes" xml:space="preserve">
          <source>fraction of the asynchronous notification queue currently occupied (0-1)</source>
          <target state="translated">当前占用的异步通知队列的分数(0-1)</target>
        </trans-unit>
        <trans-unit id="b5b60b504526b12a5eff5f8bd8a0e84a7249041e" translate="yes" xml:space="preserve">
          <source>frequency of this MCV item</source>
          <target state="translated">该MCV项目的频率</target>
        </trans-unit>
        <trans-unit id="0fd4434dbd8cb20c8f7359b16e3d296dc62d764e" translate="yes" xml:space="preserve">
          <source>from the SQL environment, or:</source>
          <target state="translated">从SQL环境,或。</target>
        </trans-unit>
        <trans-unit id="ba98c5a979f1d430811c4a4f29ea3a0721cf65fc" translate="yes" xml:space="preserve">
          <source>from the shell.</source>
          <target state="translated">从外壳。</target>
        </trans-unit>
        <trans-unit id="280f7dd2055e25f7e89bbec785c710da22de8e5a" translate="yes" xml:space="preserve">
          <source>from the shell. Only the superuser is allowed to create a database for someone else (that is, for a role you are not a member of).</source>
          <target state="translated">从shell中创建数据库。只有超级用户才可以为别人创建数据库(也就是说,为你不属于的角色创建)。</target>
        </trans-unit>
        <trans-unit id="15af0e8bf417a69fca0c301e28c0685d91c4b491" translate="yes" xml:space="preserve">
          <source>full capitalized day name (blank-padded to 9 chars)</source>
          <target state="translated">全大写日名(空加至9个字符)</target>
        </trans-unit>
        <trans-unit id="c4a997d97658b2cf2b8d26ebdf86435fc5ee3692" translate="yes" xml:space="preserve">
          <source>full capitalized month name (blank-padded to 9 chars)</source>
          <target state="translated">月名(全大写)(空行至9个字符)</target>
        </trans-unit>
        <trans-unit id="5a16a10dfdd5e4a2703b7455bf1f1425a37e5980" translate="yes" xml:space="preserve">
          <source>full lower case day name (blank-padded to 9 chars)</source>
          <target state="translated">全小写日名(空加到9个字符)</target>
        </trans-unit>
        <trans-unit id="f00512a393e028490b88f3aa5ebbe3549d7e487f" translate="yes" xml:space="preserve">
          <source>full lower case month name (blank-padded to 9 chars)</source>
          <target state="translated">月名(小写全称)(空加到9个字符)</target>
        </trans-unit>
        <trans-unit id="42477234123d86e358924810115cf7e4102d895a" translate="yes" xml:space="preserve">
          <source>full upper case day name (blank-padded to 9 chars)</source>
          <target state="translated">全大写日名(空加到9个字符)</target>
        </trans-unit>
        <trans-unit id="6d1edcedc94dd056218887a634de10777f3b1f06" translate="yes" xml:space="preserve">
          <source>full upper case month name (blank-padded to 9 chars)</source>
          <target state="translated">全大写月名(空加到9个字符)</target>
        </trans-unit>
        <trans-unit id="1105c0cc10eb74d7fc4c164ddb5ce386bb49d61b" translate="yes" xml:space="preserve">
          <source>function name</source>
          <target state="translated">功能名称</target>
        </trans-unit>
        <trans-unit id="79337461ae50346a3c64aedc6576d26f07d2da99" translate="yes" xml:space="preserve">
          <source>function to merge two elements</source>
          <target state="translated">合并函数</target>
        </trans-unit>
        <trans-unit id="381ba103b087ce725ad29d6fb3167623521eab03" translate="yes" xml:space="preserve">
          <source>function with argument types</source>
          <target state="translated">带参数类型的函数</target>
        </trans-unit>
        <trans-unit id="d68671ea551cf0ba52601309c38f48f032157b66" translate="yes" xml:space="preserve">
          <source>functions and operators for processing and creating JSON data</source>
          <target state="translated">用于处理和创建JSON数据的函数和运算符。</target>
        </trans-unit>
        <trans-unit id="2b9a1162c90a10eaa1c1d22357b7148a2281502d" translate="yes" xml:space="preserve">
          <source>functions and procedures</source>
          <target state="translated">职能和程序</target>
        </trans-unit>
        <trans-unit id="eb3a477dc4afde1f163053db118d49c3a03b5564" translate="yes" xml:space="preserve">
          <source>further limited by tuple size fitting on a single page; see note below</source>
          <target state="translated">进一步受制于单页元组大小的限制;见下文注解。</target>
        </trans-unit>
        <trans-unit id="a52bca9149e86a7c11c1c387784ebae5aaedd68c" translate="yes" xml:space="preserve">
          <source>fuzzystrmatch</source>
          <target state="translated">fuzzystrmatch</target>
        </trans-unit>
        <trans-unit id="8c0aaf10dcd6bcacc121f7b404cf2264a1048fdc" translate="yes" xml:space="preserve">
          <source>generation of ancestors at a time t</source>
          <target state="translated">一代祖宗</target>
        </trans-unit>
        <trans-unit id="e9092fbeebad65d675ea2563bb6ea87d206977be" translate="yes" xml:space="preserve">
          <source>generation of descendants at a time t</source>
          <target state="translated">后代</target>
        </trans-unit>
        <trans-unit id="8f26ec92a3e06fc1bd67c0ec5e3b881f007ba31d" translate="yes" xml:space="preserve">
          <source>geometric path on a plane</source>
          <target state="translated">平面上的几何路径</target>
        </trans-unit>
        <trans-unit id="5ae39128635d531b866a9705ccff8372c2803a08" translate="yes" xml:space="preserve">
          <source>geometric point on a plane</source>
          <target state="translated">平面上的几何点</target>
        </trans-unit>
        <trans-unit id="3c5902d9d1907e1e688e601d8dea2602b582cd8e" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;CREATE INDEX&lt;/code&gt; command for index</source>
          <target state="translated">获取 &lt;code&gt;CREATE INDEX&lt;/code&gt; 命令</target>
        </trans-unit>
        <trans-unit id="a3ec23c0e08fffde0bbe5f680221fb2baaef5bd5" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;CREATE INDEX&lt;/code&gt; command for index, or definition of just one index column when &lt;em&gt;&lt;code&gt;column_no&lt;/code&gt;&lt;/em&gt; is not zero</source>
          <target state="translated">获取 &lt;code&gt;CREATE INDEX&lt;/code&gt; 命令以获取索引，或者当&lt;em&gt; &lt;code&gt;column_no&lt;/code&gt; &lt;/em&gt;不为零时仅定义一个索引列</target>
        </trans-unit>
        <trans-unit id="196b69b47830d30e71241d4bd8b0fab2ca945d23" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;CREATE RULE&lt;/code&gt; command for rule</source>
          <target state="translated">获取 &lt;code&gt;CREATE RULE&lt;/code&gt; 命令</target>
        </trans-unit>
        <trans-unit id="2bd218c54320163748989ae51ee788d92b994ad7" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;CREATE STATISTICS&lt;/code&gt; command for extended statistics object</source>
          <target state="translated">获取扩展统计对象的 &lt;code&gt;CREATE STATISTICS&lt;/code&gt; 命令</target>
        </trans-unit>
        <trans-unit id="2dce21084875e338db2211be806cce40af161367" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;CREATE [ CONSTRAINT ] TRIGGER&lt;/code&gt; command for trigger</source>
          <target state="translated">获取 &lt;code&gt;CREATE [ CONSTRAINT ] TRIGGER&lt;/code&gt; 命令进行触发</target>
        </trans-unit>
        <trans-unit id="af0a1a4c510167b0be953ce464e30ebb21bbb406" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;RETURNS&lt;/code&gt; clause for function (returns null for a procedure)</source>
          <target state="translated">获取函数的 &lt;code&gt;RETURNS&lt;/code&gt; 子句（过程返回null）</target>
        </trans-unit>
        <trans-unit id="22f30c887b27700ca538951254039e1464d1cdd5" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;aclitem&lt;/code&gt; array as tuples</source>
          <target state="translated">将 &lt;code&gt;aclitem&lt;/code&gt; 数组作为元组</target>
        </trans-unit>
        <trans-unit id="937dcfc31310a1d87c64ad58c35d643c3dbb2cef" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt; as a &lt;code&gt;json&lt;/code&gt; value, but attempt to distinguish numerical and Boolean values so they are unquoted in the JSON</source>
          <target state="translated">将 &lt;code&gt;hstore&lt;/code&gt; 作为 &lt;code&gt;json&lt;/code&gt; 值获取，但尝试区分数字和布尔值，以便在JSON 中将其取消引用</target>
        </trans-unit>
        <trans-unit id="fe0b67a6cd7df0e277a3dcb3562abb8976f3d94c" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt; as a &lt;code&gt;json&lt;/code&gt; value, converting all non-null values to JSON strings</source>
          <target state="translated">将 &lt;code&gt;hstore&lt;/code&gt; 作为 &lt;code&gt;json&lt;/code&gt; 值获取，将所有非null值转换为JSON字符串</target>
        </trans-unit>
        <trans-unit id="6ae7444ae534490ab8b85dfd69c23426f2b097e0" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt; as a &lt;code&gt;jsonb&lt;/code&gt; value, but attempt to distinguish numerical and Boolean values so they are unquoted in the JSON</source>
          <target state="translated">将 &lt;code&gt;hstore&lt;/code&gt; 获取为 &lt;code&gt;jsonb&lt;/code&gt; 值，但尝试区分数字和布尔值，以便在JSON 中将其取消引用</target>
        </trans-unit>
        <trans-unit id="e18937d566312b9c933716239bd0a1b2cab0e0bf" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt; as a &lt;code&gt;jsonb&lt;/code&gt; value, converting all non-null values to JSON strings</source>
          <target state="translated">将 &lt;code&gt;hstore&lt;/code&gt; 获取为 &lt;code&gt;jsonb&lt;/code&gt; 值，将所有非null值转换为JSON字符串</target>
        </trans-unit>
        <trans-unit id="9d860c2d98eb0770214f44f458048681c29c6293" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt;'s keys and values as a set</source>
          <target state="translated">获取 &lt;code&gt;hstore&lt;/code&gt; 的键和值作为一组</target>
        </trans-unit>
        <trans-unit id="8b81abcbdffa1d36be6f3db92afd0c712b05149f" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt;'s keys and values as a two-dimensional array</source>
          <target state="translated">获取 &lt;code&gt;hstore&lt;/code&gt; 的键和值作为二维数组</target>
        </trans-unit>
        <trans-unit id="7732475b39d72d6d44dd2efd78c07a49212ac801" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt;'s keys and values as an array of alternating keys and values</source>
          <target state="translated">获取 &lt;code&gt;hstore&lt;/code&gt; 的键和值作为交替的键和值的数组</target>
        </trans-unit>
        <trans-unit id="3f21a27616331d2636099cf4cc88b18f8e29a805" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt;'s keys as a set</source>
          <target state="translated">将 &lt;code&gt;hstore&lt;/code&gt; 的密钥作为集合</target>
        </trans-unit>
        <trans-unit id="dc9a8f1f8f4ef349c79e43b0211eead30fe502f3" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt;'s keys as an array</source>
          <target state="translated">获取 &lt;code&gt;hstore&lt;/code&gt; 的键作为数组</target>
        </trans-unit>
        <trans-unit id="536f1dece096291af39df61eb1a0b2a7eaf9983d" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt;'s values as a set</source>
          <target state="translated">获取 &lt;code&gt;hstore&lt;/code&gt; 的值作为一组</target>
        </trans-unit>
        <trans-unit id="5251a2aba056bba63a67d56fc4203ed79712e3e4" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;hstore&lt;/code&gt;'s values as an array</source>
          <target state="translated">获取 &lt;code&gt;hstore&lt;/code&gt; 的值作为数组</target>
        </trans-unit>
        <trans-unit id="ad8730c72dc5b463ea8cac770153712d6576278e" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;xmax&lt;/code&gt; of snapshot</source>
          <target state="translated">获取快照的 &lt;code&gt;xmax&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ed704a6f174339573cf0c434a1db7a555f66cec" translate="yes" xml:space="preserve">
          <source>get &lt;code&gt;xmin&lt;/code&gt; of snapshot</source>
          <target state="translated">获取快照的 &lt;code&gt;xmin&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="337b585e11d46bb402f4a4cec72193fc16d86d74" translate="yes" xml:space="preserve">
          <source>get SQL name of a data type</source>
          <target state="translated">获取数据类型的SQL名称</target>
        </trans-unit>
        <trans-unit id="c2ee42154b8befeb7b402a3997c784dac4cdd3a2" translate="yes" xml:space="preserve">
          <source>get address of a database object from its external representation</source>
          <target state="translated">从外部表示中获取数据库对象的地址</target>
        </trans-unit>
        <trans-unit id="05dd67a0eb2fea988f4c7bff60b25d5bcfd72760" translate="yes" xml:space="preserve">
          <source>get argument list of function's or procedure's definition (with default values)</source>
          <target state="translated">获取函数或过程定义的参数列表(带默认值)。</target>
        </trans-unit>
        <trans-unit id="c519a3e8267da358402769c054226a03635c67ee" translate="yes" xml:space="preserve">
          <source>get argument list to identify a function or procedure (without default values)</source>
          <target state="translated">获取参数列表来识别一个函数或过程(没有默认值)。</target>
        </trans-unit>
        <trans-unit id="6b32a6038832e813790af0776307cf7b231fbb8e" translate="yes" xml:space="preserve">
          <source>get comment for a database object</source>
          <target state="translated">获取数据库对象的注释</target>
        </trans-unit>
        <trans-unit id="362276384bf1063fb473a3d69cd61ec994e9c173" translate="yes" xml:space="preserve">
          <source>get comment for a database object (&lt;em&gt;deprecated&lt;/em&gt;)</source>
          <target state="translated">获取数据库对象的注释（&lt;em&gt;不推荐使用&lt;/em&gt;）</target>
        </trans-unit>
        <trans-unit id="fb86807e0f1bd4d25c9ec5a1d13bea140bc18075" translate="yes" xml:space="preserve">
          <source>get comment for a shared database object</source>
          <target state="translated">获取共享数据库对象的注释</target>
        </trans-unit>
        <trans-unit id="ff9969c90af75d2566e6867dd12ee5fce7632f50" translate="yes" xml:space="preserve">
          <source>get comment for a table column</source>
          <target state="translated">获取表列注释</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
