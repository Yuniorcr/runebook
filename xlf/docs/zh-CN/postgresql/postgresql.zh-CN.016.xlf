<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="d835303635997cc515233b553b202dd2ca61cd9f" translate="yes" xml:space="preserve">
          <source>More generically, a relation is a set of tuples; for example, the result of a query is also a relation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5ff6c49fed97ba21bc443a8e95921cd7fef478d" translate="yes" xml:space="preserve">
          <source>More generically, the term &lt;em&gt;schema&lt;/em&gt; is used to mean all data descriptions (&lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; definitions, &lt;a href=&quot;glossary#GLOSSARY-CONSTRAINT&quot;&gt;constraints&lt;/a&gt;, comments, etc) for a given &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; or subset thereof.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c771e450e93955920d70db2f3a188ef32edea882" translate="yes" xml:space="preserve">
          <source>More information about partial indexes can be found in &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#STON89B&quot;&gt;[ston89b]&lt;/a&gt;, &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#OLSON93&quot;&gt;[olson93]&lt;/a&gt;, and &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#SESHADRI95&quot;&gt;[seshadri95]&lt;/a&gt;.</source>
          <target state="translated">有关部分索引的更多信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#STON89B&quot;&gt;[ston89b]&lt;/a&gt;，&lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#OLSON93&quot;&gt;[olson93]&lt;/a&gt;和&lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#SESHADRI95&quot;&gt;[seshadri95]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dc9aa3892ba23ddac98c416e33335aa51d42e075" translate="yes" xml:space="preserve">
          <source>More information about partial indexes can be found in &lt;a href=&quot;https://www.postgresql.org/docs/13/biblio.html#STON89B&quot;&gt;[ston89b]&lt;/a&gt;, &lt;a href=&quot;https://www.postgresql.org/docs/13/biblio.html#OLSON93&quot;&gt;[olson93]&lt;/a&gt;, and &lt;a href=&quot;https://www.postgresql.org/docs/13/biblio.html#SESHADRI95&quot;&gt;[seshadri95]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9300c1996c675687b056f93327336beacca1fbf" translate="yes" xml:space="preserve">
          <source>More information about the lock modes and locking strategies can be found in &lt;a href=&quot;explicit-locking&quot;&gt;Section 13.3&lt;/a&gt;.</source>
          <target state="translated">有关锁定模式和锁定策略的更多信息，请参见&lt;a href=&quot;explicit-locking&quot;&gt;第13.3节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ef70336c8dc9c2d758937dd2be0326ac89265cd4" translate="yes" xml:space="preserve">
          <source>More information about updating and deleting data is in &lt;a href=&quot;https://www.postgresql.org/docs/12/dml.html&quot;&gt;Chapter 6&lt;/a&gt;. Also see the description of foreign key constraint syntax in the reference documentation for &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;.</source>
          <target state="translated">有关更新和删除数据的更多信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/dml.html&quot;&gt;第6章&lt;/a&gt;。另请参见参考文档中&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;的外键约束语法说明。</target>
        </trans-unit>
        <trans-unit id="cadcf76a3de36d133ed36e25753f765d08135f4c" translate="yes" xml:space="preserve">
          <source>More information about updating and deleting data is in &lt;a href=&quot;https://www.postgresql.org/docs/13/dml.html&quot;&gt;Chapter 6&lt;/a&gt;. Also see the description of foreign key constraint syntax in the reference documentation for &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e689fb0c34bef953cc6f900b699843e5aff59cf5" translate="yes" xml:space="preserve">
          <source>More information about window functions can be found in &lt;a href=&quot;tutorial-window&quot;&gt;Section 3.5&lt;/a&gt;, &lt;a href=&quot;functions-window&quot;&gt;Section 9.21&lt;/a&gt;, and &lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;Section 7.2.5&lt;/a&gt;.</source>
          <target state="translated">有关窗口功能的更多信息，请参见&lt;a href=&quot;tutorial-window&quot;&gt;第3.5 &lt;/a&gt;&lt;a href=&quot;functions-window&quot;&gt;节&lt;/a&gt;，第9.21 &lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;节&lt;/a&gt;和第7.2.5节。</target>
        </trans-unit>
        <trans-unit id="910afb407202e4aaa34247efa3cbb1ddac8f9709" translate="yes" xml:space="preserve">
          <source>More information about window functions can be found in &lt;a href=&quot;tutorial-window&quot;&gt;Section 3.5&lt;/a&gt;, &lt;a href=&quot;functions-window&quot;&gt;Section 9.22&lt;/a&gt;, and &lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;Section 7.2.5&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b29b35804e6bc278cd58dd861059bfbd8e576bad" translate="yes" xml:space="preserve">
          <source>More specifically, setting this value to &lt;code&gt;on&lt;/code&gt; will add a &lt;code&gt;Gather&lt;/code&gt; node to the top of any query plan for which this appears to be safe, so that the query runs inside of a parallel worker. Even when a parallel worker is not available or cannot be used, operations such as starting a subtransaction that would be prohibited in a parallel query context will be prohibited unless the planner believes that this will cause the query to fail. If failures or unexpected results occur when this option is set, some functions used by the query may need to be marked &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; (or, possibly, &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt;).</source>
          <target state="translated">更具体地说，将此值设置为 &lt;code&gt;on&lt;/code&gt; 将在所有看起来安全的查询计划的顶部添加一个 &lt;code&gt;Gather&lt;/code&gt; 节点，以便查询在并行工作程序内部运行。即使并行工作者不可用或无法使用，除非计划者认为这将导致查询失败，否则将禁止诸如在并行查询上下文中禁止的子事务之类的操作。如果设置此选项时发生故障或意外结果，则查询中使用的某些功能可能需要标记为 &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; （或可能是 &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="bf1a578b87b8dcebec736c6d3df5e511c59a7712" translate="yes" xml:space="preserve">
          <source>More usually, &lt;code&gt;VALUES&lt;/code&gt; is used within a larger SQL command. The most common use is in &lt;code&gt;INSERT&lt;/code&gt;:</source>
          <target state="translated">通常，在较大的SQL命令中使用 &lt;code&gt;VALUES&lt;/code&gt; 。最常见的用法是在 &lt;code&gt;INSERT&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="f34f1661d8425a72a96b8b7cb49353a492e8fe95" translate="yes" xml:space="preserve">
          <source>Moreover, if we have a function that accepts a single argument of a composite type, we can call it with either notation. These queries are all equivalent:</source>
          <target state="translated">此外,如果我们有一个接受复合类型的单个参数的函数,我们可以用任何一种符号来调用它。这些查询都是等价的。</target>
        </trans-unit>
        <trans-unit id="b6b5cd5fdbfc629a7d3f75be5167b4b144a3f86d" translate="yes" xml:space="preserve">
          <source>Most &lt;code&gt;pg_ctl&lt;/code&gt; modes require knowing the data directory location; therefore, the &lt;code&gt;-D&lt;/code&gt; option is required unless &lt;code&gt;PGDATA&lt;/code&gt; is set.</source>
          <target state="translated">大多数 &lt;code&gt;pg_ctl&lt;/code&gt; 模式都需要知道数据目录的位置。因此，除非设置了 &lt;code&gt;PGDATA&lt;/code&gt; 否则 &lt;code&gt;-D&lt;/code&gt; 选项是必需的。</target>
        </trans-unit>
        <trans-unit id="69cf03cafc4ea41c94813d7e422965750bb31a86" translate="yes" xml:space="preserve">
          <source>Most aggregate functions ignore null inputs, so that rows in which one or more of the expression(s) yield null are discarded. This can be assumed to be true, unless otherwise specified, for all built-in aggregates.</source>
          <target state="translated">大多数聚合函数都会忽略空输入,所以一个或多个表达式产生空值的行会被丢弃。对于所有内置的聚合函数来说,除非另有规定,否则可以假定这一点是真的。</target>
        </trans-unit>
        <trans-unit id="7ba0155b71f54b39b68d7c23be1cc2e11116377b" translate="yes" xml:space="preserve">
          <source>Most atoms, and all constraints, have no greediness attribute (because they cannot match variable amounts of text anyway).</source>
          <target state="translated">大多数原子和所有约束条件,都没有贪婪属性(因为它们无论如何也无法匹配可变数量的文本)。</target>
        </trans-unit>
        <trans-unit id="7f53fad77c0918001bf87e5c2287a1e18f906e5e" translate="yes" xml:space="preserve">
          <source>Most common implementations</source>
          <target state="translated">最常见的实施方式</target>
        </trans-unit>
        <trans-unit id="750c1315d8a2e4c64b7b2cf3fe9029ccf298aef6" translate="yes" xml:space="preserve">
          <source>Most kinds of catalog objects are simply referenced by their names. Note that type names must exactly match the referenced &lt;code&gt;pg_type&lt;/code&gt; entry's &lt;code&gt;typname&lt;/code&gt;; you do not get to use any aliases such as &lt;code&gt;integer&lt;/code&gt; for &lt;code&gt;int4&lt;/code&gt;.</source>
          <target state="translated">大多数种类的目录对象仅通过其名称进行引用。需要注意的是类型名称引用必须完全匹配 &lt;code&gt;pg_type&lt;/code&gt; 里面的条目的 &lt;code&gt;typname&lt;/code&gt; ; 您不会对 &lt;code&gt;int4&lt;/code&gt; 使用任何别名，例如 &lt;code&gt;integer&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ca0f34a89e8d302478dfd8fb8ad2a79bdc73278" translate="yes" xml:space="preserve">
          <source>Most local objects belong to a specific &lt;a href=&quot;glossary#GLOSSARY-SCHEMA&quot;&gt;schema&lt;/a&gt; in their containing database, such as &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relations&lt;/a&gt; (all types), &lt;a href=&quot;glossary#GLOSSARY-FUNCTION&quot;&gt;routines&lt;/a&gt; (all types), data types, etc. The names of such objects of the same type in the same schema are enforced to be unique.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dbe371d76c6dc7cba4d9098c63670e12f1237d3" translate="yes" xml:space="preserve">
          <source>Most of the functions that reconstruct (decompile) database objects have an optional &lt;em&gt;&lt;code&gt;pretty&lt;/code&gt;&lt;/em&gt; flag, which if &lt;code&gt;true&lt;/code&gt; causes the result to be &amp;ldquo;pretty-printed&amp;rdquo;. Pretty-printing suppresses unnecessary parentheses and adds whitespace for legibility. The pretty-printed format is more readable, but the default format is more likely to be interpreted the same way by future versions of PostgreSQL; so avoid using pretty-printed output for dump purposes. Passing &lt;code&gt;false&lt;/code&gt; for the &lt;em&gt;&lt;code&gt;pretty&lt;/code&gt;&lt;/em&gt; parameter yields the same result as omitting the parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a098765cd76a02dd3c28ed1a2d6ced931f0a323" translate="yes" xml:space="preserve">
          <source>Most queries retrieve only a fraction of the rows in a table, due to &lt;code&gt;WHERE&lt;/code&gt; clauses that restrict the rows to be examined. The planner thus needs to make an estimate of the &lt;em&gt;selectivity&lt;/em&gt; of &lt;code&gt;WHERE&lt;/code&gt; clauses, that is, the fraction of rows that match each condition in the &lt;code&gt;WHERE&lt;/code&gt; clause. The information used for this task is stored in the &lt;a href=&quot;catalog-pg-statistic&quot;&gt;&lt;code&gt;pg_statistic&lt;/code&gt;&lt;/a&gt; system catalog. Entries in &lt;code&gt;pg_statistic&lt;/code&gt; are updated by the &lt;code&gt;ANALYZE&lt;/code&gt; and &lt;code&gt;VACUUM ANALYZE&lt;/code&gt; commands, and are always approximate even when freshly updated.</source>
          <target state="translated">由于 &lt;code&gt;WHERE&lt;/code&gt; 子句限制要检查的行，因此大多数查询只检索表中一部分行。因此，规划者需要使的估计&lt;em&gt;选择性&lt;/em&gt;的 &lt;code&gt;WHERE&lt;/code&gt; 子句，即，中相互匹配条件的行的分数 &lt;code&gt;WHERE&lt;/code&gt; 子句。用于此任务的信息存储在&lt;a href=&quot;catalog-pg-statistic&quot;&gt; &lt;code&gt;pg_statistic&lt;/code&gt; &lt;/a&gt;系统目录中。 &lt;code&gt;pg_statistic&lt;/code&gt; 中的条目由 &lt;code&gt;ANALYZE&lt;/code&gt; 和 &lt;code&gt;VACUUM ANALYZE&lt;/code&gt; 命令更新，即使是新近更新的也总是近似的。</target>
        </trans-unit>
        <trans-unit id="6eb034f582f8c2b79ea5f1d4aeb8e1cc749b45b2" translate="yes" xml:space="preserve">
          <source>Most scalar data types should have a corresponding array type (that is, a standard varlena array type whose element type is the scalar type, and which is referenced by the &lt;code&gt;typarray&lt;/code&gt; field of the scalar type's &lt;code&gt;pg_type&lt;/code&gt; entry). &lt;code&gt;genbki.pl&lt;/code&gt; is able to generate the &lt;code&gt;pg_type&lt;/code&gt; entry for the array type automatically in most cases.</source>
          <target state="translated">大多数标量数据类型应具有对应的数组类型（即，元素类型为标量类型的标准varlena数组类型，并由标量类型的 &lt;code&gt;pg_type&lt;/code&gt; 条目的 &lt;code&gt;typarray&lt;/code&gt; 字段引用）。 &lt;code&gt;genbki.pl&lt;/code&gt; 是能够生成 &lt;code&gt;pg_type&lt;/code&gt; 里面的在大多数情况下自动为阵列型条目。</target>
        </trans-unit>
        <trans-unit id="8934cf5770ff56a86643f007085fd816b1b58dfa" translate="yes" xml:space="preserve">
          <source>Most system catalogs are copied from the template database during database creation and are thereafter database-specific. A few catalogs are physically shared across all databases in a cluster; these are noted in the descriptions of the individual catalogs.</source>
          <target state="translated">大多数系统目录是在创建数据库时从模板数据库中复制出来的,此后是特定于数据库的。少数目录在集群中的所有数据库之间实际共享;这些目录在各个目录的描述中都有说明。</target>
        </trans-unit>
        <trans-unit id="a7bd8e4c0ba4c5fef185f840f580e4a5b9a25b96" translate="yes" xml:space="preserve">
          <source>Most types of dictionaries rely on configuration files, such as files of stop words. These files &lt;em&gt;must&lt;/em&gt; be stored in UTF-8 encoding. They will be translated to the actual database encoding, if that is different, when they are read into the server.</source>
          <target state="translated">大多数类型的词典都依赖于配置文件，例如停用词文件。这些文件&lt;em&gt;必须&lt;/em&gt;以UTF-8编码存储。当将它们读入服务器时，它们将转换为实际的数据库编码（如果不同）。</target>
        </trans-unit>
        <trans-unit id="4deea28851a7ae4ce56d6b6d82c468bb35f41bb4" translate="yes" xml:space="preserve">
          <source>Most variables that control psql's behavior cannot be unset; instead, an &lt;code&gt;\unset&lt;/code&gt; command is interpreted as setting them to their default values. See &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;Variables&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="473029ab69353e53921e8ecd7440a49c9a86be94" translate="yes" xml:space="preserve">
          <source>Most variables that control psql's behavior cannot be unset; instead, an &lt;code&gt;\unset&lt;/code&gt; command is interpreted as setting them to their default values. See &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;Variables&lt;/a&gt;, below.</source>
          <target state="translated">大多数控制psql行为的变量不能被取消设置。而是将 &lt;code&gt;\unset&lt;/code&gt; 命令解释为将它们设置为其默认值。请参阅下面的&lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7293739c8cef6860367bef80e497db37fda337b4" translate="yes" xml:space="preserve">
          <source>Moving an object to a new schema additionally requires &lt;code&gt;remove_name&lt;/code&gt; permission on the old schema and &lt;code&gt;add_name&lt;/code&gt; permission on the new one.</source>
          <target state="translated">移动对象到一个新的模式还需要 &lt;code&gt;remove_name&lt;/code&gt; 对旧模式的权限和 &lt;code&gt;add_name&lt;/code&gt; 在新的许可。</target>
        </trans-unit>
        <trans-unit id="9a676159878bdf52262c05ecb519fb1a7d01d39b" translate="yes" xml:space="preserve">
          <source>Much of the PostgreSQL type system is built around a rich set of functions. Functions can have one or more arguments. Since PostgreSQL permits function overloading, the function name alone does not uniquely identify the function to be called; the parser must select the right function based on the data types of the supplied arguments.</source>
          <target state="translated">PostgreSQL类型系统的大部分内容都是围绕着丰富的函数建立的。函数可以有一个或多个参数。由于PostgreSQL允许函数重载,因此仅凭函数名并不能唯一地识别要调用的函数;解析器必须根据提供的参数的数据类型选择正确的函数。</target>
        </trans-unit>
        <trans-unit id="2740f0c680a6e63e450d5b3c062a5229834ae2d2" translate="yes" xml:space="preserve">
          <source>Mule internal code</source>
          <target state="translated">骡子内部代码</target>
        </trans-unit>
        <trans-unit id="344fa8c431ce29a1cdabfe9e517c51ceaef15678" translate="yes" xml:space="preserve">
          <source>Multi-Version Concurrency Control</source>
          <target state="translated">多版本并发控制</target>
        </trans-unit>
        <trans-unit id="99e2646c11c9e1032892edf955d9bbabc4a055aa" translate="yes" xml:space="preserve">
          <source>Multi-version concurrency control (MVCC)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="384caf1b9fc6ff1244af37a2f4eefa0674d24a27" translate="yes" xml:space="preserve">
          <source>Multicolumn GIN indexes are implemented by building a single B-tree over composite values (column number, key value). The key values for different columns can be of different types.</source>
          <target state="translated">多列GIN索引是通过在复合值(列号、键值)上建立一个B树来实现的。不同列的键值可以是不同类型的。</target>
        </trans-unit>
        <trans-unit id="2c159674cdc49534760eb0265af934a2b89d41fe" translate="yes" xml:space="preserve">
          <source>Multicolumn Indexes</source>
          <target state="translated">多列索引</target>
        </trans-unit>
        <trans-unit id="2d93cd8bc72bc57af1ba376ce47d069b6c4a937d" translate="yes" xml:space="preserve">
          <source>Multicolumn indexes should be used sparingly. In most situations, an index on a single column is sufficient and saves space and time. Indexes with more than three columns are unlikely to be helpful unless the usage of the table is extremely stylized. See also &lt;a href=&quot;indexes-bitmap-scans&quot;&gt;Section 11.5&lt;/a&gt; and &lt;a href=&quot;indexes-index-only-scans&quot;&gt;Section 11.9&lt;/a&gt; for some discussion of the merits of different index configurations.</source>
          <target state="translated">多列索引应谨慎使用。在大多数情况下，单列索引就足够了，并且可以节省空间和时间。除非表的使用风格极高，否则具有多于三列的索引不太可能有帮助。有关不同索引配置的优点的某些讨论，另请参见&lt;a href=&quot;indexes-bitmap-scans&quot;&gt;第11.5节&lt;/a&gt;和&lt;a href=&quot;indexes-index-only-scans&quot;&gt;第11.9节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b99aa634fe16bee7bdf05b0cf7793d76fb5f12b3" translate="yes" xml:space="preserve">
          <source>Multidimensional array constructor elements can be anything yielding an array of the proper kind, not only a sub-&lt;code&gt;ARRAY&lt;/code&gt; construct. For example:</source>
          <target state="translated">多维数组构造器元素可以是产生适当类型数组的任何东西，而不仅仅是子 &lt;code&gt;ARRAY&lt;/code&gt; 构造。例如：</target>
        </trans-unit>
        <trans-unit id="5dca66d7f2aee43ef1797a393d0e215db306ea18" translate="yes" xml:space="preserve">
          <source>Multidimensional array values can be built by nesting array constructors. In the inner constructors, the key word &lt;code&gt;ARRAY&lt;/code&gt; can be omitted. For example, these produce the same result:</source>
          <target state="translated">多维数组值可以通过嵌套数组构造函数来构建。在内部构造函数中，可以省略关键字 &lt;code&gt;ARRAY&lt;/code&gt; 。例如，这些产生相同的结果：</target>
        </trans-unit>
        <trans-unit id="b8d7e3b8a7276708d01165024b6293de444e2c11" translate="yes" xml:space="preserve">
          <source>Multidimensional arrays must have matching extents for each dimension. A mismatch causes an error, for example:</source>
          <target state="translated">多维数组的每个维度必须有匹配的扩展。不匹配会导致错误,例如:</target>
        </trans-unit>
        <trans-unit id="b92978283c35094160cf22fc851c3df5bcf7effd" translate="yes" xml:space="preserve">
          <source>Multilingual Emacs</source>
          <target state="translated">多语言Emacs</target>
        </trans-unit>
        <trans-unit id="da392350dc33944a643a54bf379fde9199e79c15" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;EXCEPT&lt;/code&gt; operators in the same &lt;code&gt;SELECT&lt;/code&gt; statement are evaluated left to right, unless parentheses dictate otherwise. &lt;code&gt;EXCEPT&lt;/code&gt; binds at the same level as &lt;code&gt;UNION&lt;/code&gt;.</source>
          <target state="translated">除非括号中另有规定，否则同一 &lt;code&gt;SELECT&lt;/code&gt; 语句中的多个 &lt;code&gt;EXCEPT&lt;/code&gt; 运算符从左到右求值。 &lt;code&gt;EXCEPT&lt;/code&gt; 与 &lt;code&gt;UNION&lt;/code&gt; 绑定在同一级别。</target>
        </trans-unit>
        <trans-unit id="545da6f8ee31d7740c9c3d5dad863f020a69eb93" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;INTERSECT&lt;/code&gt; operators in the same &lt;code&gt;SELECT&lt;/code&gt; statement are evaluated left to right, unless parentheses dictate otherwise. &lt;code&gt;INTERSECT&lt;/code&gt; binds more tightly than &lt;code&gt;UNION&lt;/code&gt;. That is, &lt;code&gt;A UNION B INTERSECT C&lt;/code&gt; will be read as &lt;code&gt;A UNION (B INTERSECT C)&lt;/code&gt;.</source>
          <target state="translated">除非括号中另有规定，否则同一 &lt;code&gt;SELECT&lt;/code&gt; 语句中的多个 &lt;code&gt;INTERSECT&lt;/code&gt; 运算符从左到右求值。 &lt;code&gt;INTERSECT&lt;/code&gt; 的绑定比 &lt;code&gt;UNION&lt;/code&gt; 绑定更紧密。即， &lt;code&gt;A UNION B INTERSECT C&lt;/code&gt; 读取为 &lt;code&gt;A UNION (B INTERSECT C)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="44cc99500b8c6afffdf8915313cbba82fb39e906" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;UNION&lt;/code&gt; operators in the same &lt;code&gt;SELECT&lt;/code&gt; statement are evaluated left to right, unless otherwise indicated by parentheses.</source>
          <target state="translated">除非括号中另有说明，否则同一 &lt;code&gt;SELECT&lt;/code&gt; 语句中的多个 &lt;code&gt;UNION&lt;/code&gt; 运算符从左到右求值。</target>
        </trans-unit>
        <trans-unit id="09ad30df55e0ee1fdeb0db77709134b50e5f6d5c" translate="yes" xml:space="preserve">
          <source>Multiple Identity Columns</source>
          <target state="translated">多重身份列</target>
        </trans-unit>
        <trans-unit id="e2933c3051980c1e2e6ec097345b6b77b93e0721" translate="yes" xml:space="preserve">
          <source>Multiple RADIUS servers can be specified, in which case they will be tried sequentially. If a negative response is received from a server, the authentication will fail. If no response is received, the next server in the list will be tried. To specify multiple servers, put the names within quotes and separate the server names with a comma. If multiple servers are specified, all other RADIUS options can also be given as a comma separate list, to apply individual values to each server. They can also be specified as a single value, in which case this value will apply to all servers.</source>
          <target state="translated">可以指定多个RADIUS服务器,在这种情况下,将依次尝试。如果从一个服务器收到负面的响应,认证将失败。如果没有收到任何响应,将尝试列表中的下一个服务器。要指定多个服务器,请将名称放在引号内,并用逗号将服务器名称分开。如果指定了多个服务器,所有其他的RADIUS选项也可以以逗号分开的列表形式给出,以便对每个服务器应用单独的值。它们也可以被指定为一个单一的值,在这种情况下,这个值将适用于所有的服务器。</target>
        </trans-unit>
        <trans-unit id="52ee8ebc172afa9611da532af89c4c55f27f12a0" translate="yes" xml:space="preserve">
          <source>Multiple RADIUS servers can be specified, in which case they will be tried sequentially. If a negative response is received from a server, the authentication will fail. If no response is received, the next server in the list will be tried. To specify multiple servers, separate the server names with commas and surround the list with double quotes. If multiple servers are specified, the other RADIUS options can also be given as comma-separated lists, to provide individual values for each server. They can also be specified as a single value, in which case that value will apply to all servers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47cf9ecc42c00f97b187ac65e4ad87ed8ddddec7" translate="yes" xml:space="preserve">
          <source>Multiple function calls can be combined into a single &lt;code&gt;FROM&lt;/code&gt;-clause item by surrounding them with &lt;code&gt;ROWS FROM( ... )&lt;/code&gt;. The output of such an item is the concatenation of the first row from each function, then the second row from each function, etc. If some of the functions produce fewer rows than others, null values are substituted for the missing data, so that the total number of rows returned is always the same as for the function that produced the most rows.</source>
          <target state="translated">通过用 &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; 包围多个函数调用，可以将它们组合成单个 &lt;code&gt;FROM&lt;/code&gt; 子句。此类项目的输出是每个函数的第一行的串联，然后是每个函数的第二行的串联，依此类推。如果某些函数产生的行少于其他函数，则将空值替换为丢失的数据，以便返回的总行数始终与产生最多行的函数相同。</target>
        </trans-unit>
        <trans-unit id="cb041e89d71104ed194545d06d97265abcc8ac5c" translate="yes" xml:space="preserve">
          <source>Multiple inheritance via the &lt;code&gt;INHERITS&lt;/code&gt; clause is a PostgreSQL language extension. SQL:1999 and later define single inheritance using a different syntax and different semantics. SQL:1999-style inheritance is not yet supported by PostgreSQL.</source>
          <target state="translated">通过 &lt;code&gt;INHERITS&lt;/code&gt; 子句的多重继承是PostgreSQL语言的扩展。SQL：1999及更高版本使用不同的语法和语义定义了单个继承。PostgreSQL尚不支持SQL：1999样式的继承。</target>
        </trans-unit>
        <trans-unit id="dfc4b99f808466861398cb5089390dbcf8288968" translate="yes" xml:space="preserve">
          <source>Multiple initial administrators, and all the other options of &lt;code&gt;CREATE ROLE&lt;/code&gt;, are PostgreSQL extensions.</source>
          <target state="translated">PostgreSQL扩展是多个初始管理员以及 &lt;code&gt;CREATE ROLE&lt;/code&gt; 的所有其他选项。</target>
        </trans-unit>
        <trans-unit id="7023aa5fc8e888d453cd39667bc365999be7e91b" translate="yes" xml:space="preserve">
          <source>Multiple locking clauses can be written if it is necessary to specify different locking behavior for different tables. If the same table is mentioned (or implicitly affected) by more than one locking clause, then it is processed as if it was only specified by the strongest one. Similarly, a table is processed as &lt;code&gt;NOWAIT&lt;/code&gt; if that is specified in any of the clauses affecting it. Otherwise, it is processed as &lt;code&gt;SKIP LOCKED&lt;/code&gt; if that is specified in any of the clauses affecting it.</source>
          <target state="translated">如果有必要为不同的表指定不同的锁定行为，则可以编写多个锁定子句。如果同一表被多个锁定子句提及（或隐式影响），则将其视为仅由最强的子表指定。同样，如果在影响该表的任何子句中指定了表，则该表将作为 &lt;code&gt;NOWAIT&lt;/code&gt; 处理。否则，如果在影响它的任何子句中指定了 &lt;code&gt;SKIP LOCKED&lt;/code&gt; ，则将其作为跳过锁定处理。</target>
        </trans-unit>
        <trans-unit id="9ff93077b96a2599909c71e452a52b617dcb75f7" translate="yes" xml:space="preserve">
          <source>Multiple-Server Parallel Query Execution</source>
          <target state="translated">多服务器并行查询执行</target>
        </trans-unit>
        <trans-unit id="2b9ee6e2b5fcdbd970e8f069acf17877e49e0441" translate="yes" xml:space="preserve">
          <source>Multiplication</source>
          <target state="translated">Multiplication</target>
        </trans-unit>
        <trans-unit id="83d4c1590260d359ecbe9f085d559899657ac6eb" translate="yes" xml:space="preserve">
          <source>Multiplies each point of the first argument by the second &lt;code&gt;point&lt;/code&gt; (treating a point as being a complex number represented by real and imaginary parts, and performing standard complex multiplication). If one interprets the second &lt;code&gt;point&lt;/code&gt; as a vector, this is equivalent to scaling the object's size and distance from the origin by the length of the vector, and rotating it counterclockwise around the origin by the vector's angle from the &lt;code&gt;x&lt;/code&gt; axis. Available for &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;,&lt;a href=&quot;#ftn.FUNCTIONS-GEOMETRY-ROTATION-FN&quot;&gt;&lt;sup id=&quot;FUNCTIONS-GEOMETRY-ROTATION-FN&quot;&gt;[a]&lt;/sup&gt;&lt;/a&gt;&lt;code&gt;path&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f690d76a3a6b4f3cf2f400b6a49ebe14dc72a219" translate="yes" xml:space="preserve">
          <source>Multiply an interval by a scalar</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c0c5f6099e92ebebc75583d550cc71584a93e4c" translate="yes" xml:space="preserve">
          <source>Multiply the number of rows generated by the scale factor. For example, &lt;code&gt;-s 100&lt;/code&gt; will create 10,000,000 rows in the &lt;code&gt;pgbench_accounts&lt;/code&gt; table. Default is 1. When the scale is 20,000 or larger, the columns used to hold account identifiers (&lt;code&gt;aid&lt;/code&gt; columns) will switch to using larger integers (&lt;code&gt;bigint&lt;/code&gt;), in order to be big enough to hold the range of account identifiers.</source>
          <target state="translated">将比例因子生成的行数相乘。例如， &lt;code&gt;-s 100&lt;/code&gt; 将在 &lt;code&gt;pgbench_accounts&lt;/code&gt; 表中创建10,000,000行。默认值为1。当小数位数为20,000或更大时，用于容纳帐户标识符的列（ &lt;code&gt;aid&lt;/code&gt; 列）将切换为使用较大的整数（ &lt;code&gt;bigint&lt;/code&gt; ），以使其足够大以容纳帐户标识符的范围。</target>
        </trans-unit>
        <trans-unit id="0b63b41e9535d1638fe83e7fb152d39f9e2c71b6" translate="yes" xml:space="preserve">
          <source>Multivariate Statistics Examples</source>
          <target state="translated">多变量统计实例</target>
        </trans-unit>
        <trans-unit id="67f1e276e130e436d878dd37efbefd858f1a15f3" translate="yes" xml:space="preserve">
          <source>Multivariate correlation can be demonstrated with a very simple data set &amp;mdash; a table with two columns, both containing the same values:</source>
          <target state="translated">可以通过一个非常简单的数据集来证明多变量相关性：一个包含两列的表，这两列都包含相同的值：</target>
        </trans-unit>
        <trans-unit id="68e9ef2c165e4fa8adf23b844de4bcd199158fae" translate="yes" xml:space="preserve">
          <source>MurmurHash2 hash</source>
          <target state="translated">MurmurHash2哈希值</target>
        </trans-unit>
        <trans-unit id="1d1a603b8a91745540a0eb62aecc8635b092e498" translate="yes" xml:space="preserve">
          <source>Mutation as genetic operator is deprecated so that no repair mechanisms are needed to generate legal TSP tours.</source>
          <target state="translated">突变作为遗传操作者被废弃,这样就不需要修复机制来生成合法的TSP旅游。</target>
        </trans-unit>
        <trans-unit id="411d403f2e3b649eb2f47189fa6c058b68a3959d" translate="yes" xml:space="preserve">
          <source>My thanks are primarily to Prof. Joe Hellerstein (&lt;a href=&quot;http://db.cs.berkeley.edu/jmh/&quot;&gt;http://db.cs.berkeley.edu/jmh/&lt;/a&gt;) for elucidating the gist of the GiST (&lt;a href=&quot;http://gist.cs.berkeley.edu/&quot;&gt;http://gist.cs.berkeley.edu/&lt;/a&gt;), and to his former student Andy Dong for his example written for Illustra. I am also grateful to all Postgres developers, present and past, for enabling myself to create my own world and live undisturbed in it. And I would like to acknowledge my gratitude to Argonne Lab and to the U.S. Department of Energy for the years of faithful support of my database research.</source>
          <target state="translated">我主要感谢Joe Hellerstein教授（&lt;a href=&quot;http://db.cs.berkeley.edu/jmh/&quot;&gt;http://db.cs.berkeley.edu/jmh/&lt;/a&gt;）阐明了GiST的要旨（&lt;a href=&quot;http://gist.cs.berkeley.edu/&quot;&gt;http://gist.cs.berkeley.edu/&lt;/a&gt;）以及他的前学生安迪&amp;middot;董（Andy Dong）为他为Illustra写的例子。我也感谢所有Postgres开发人员，无论现在还是过去，使我能够创建自己的世界并在其中不受干扰地生活。我还要感谢我对Argonne实验室和美国能源部的感谢，感谢他们多年来对数据库研究的忠实支持。</target>
        </trans-unit>
        <trans-unit id="63806797acec7e92b9e9bba40d5e19f39040d989" translate="yes" xml:space="preserve">
          <source>My thanks are primarily to Prof. Joe Hellerstein (&lt;a href=&quot;http://db.cs.berkeley.edu/jmh/&quot;&gt;http://db.cs.berkeley.edu/jmh/&lt;/a&gt;) for elucidating the gist of the GiST (&lt;a href=&quot;http://gist.cs.berkeley.edu/&quot;&gt;http://gist.cs.berkeley.edu/&lt;/a&gt;). I am also grateful to all Postgres developers, present and past, for enabling myself to create my own world and live undisturbed in it. And I would like to acknowledge my gratitude to Argonne Lab and to the U.S. Department of Energy for the years of faithful support of my database research.</source>
          <target state="translated">我主要感谢Joe Hellerstein教授（&lt;a href=&quot;http://db.cs.berkeley.edu/jmh/&quot;&gt;http://db.cs.berkeley.edu/jmh/&lt;/a&gt;）阐明了GiST的要旨（&lt;a href=&quot;http://gist.cs.berkeley.edu/&quot;&gt;http://gist.cs.berkeley.edu/&lt;/a&gt;）。我也感谢所有Postgres开发人员，无论现在还是过去，使我能够创建自己的世界并在其中不受干扰地生活。我还要感谢我对Argonne实验室和美国能源部的感谢，感谢他们多年来对数据库研究的忠实支持。</target>
        </trans-unit>
        <trans-unit id="6b165eae6146362f8f4218790f243080eeac62ec" translate="yes" xml:space="preserve">
          <source>My thanks are primarily to Prof. Joe Hellerstein (&lt;a href=&quot;https://dsf.berkeley.edu/jmh/&quot;&gt;https://dsf.berkeley.edu/jmh/&lt;/a&gt;) for elucidating the gist of the GiST (&lt;a href=&quot;http://gist.cs.berkeley.edu/&quot;&gt;http://gist.cs.berkeley.edu/&lt;/a&gt;), and to his former student Andy Dong for his example written for Illustra. I am also grateful to all Postgres developers, present and past, for enabling myself to create my own world and live undisturbed in it. And I would like to acknowledge my gratitude to Argonne Lab and to the U.S. Department of Energy for the years of faithful support of my database research.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c665518a6c8a774be8b227ccf9e0e2930a0b4db" translate="yes" xml:space="preserve">
          <source>My thanks are primarily to Prof. Joe Hellerstein (&lt;a href=&quot;https://dsf.berkeley.edu/jmh/&quot;&gt;https://dsf.berkeley.edu/jmh/&lt;/a&gt;) for elucidating the gist of the GiST (&lt;a href=&quot;http://gist.cs.berkeley.edu/&quot;&gt;http://gist.cs.berkeley.edu/&lt;/a&gt;). I am also grateful to all Postgres developers, present and past, for enabling myself to create my own world and live undisturbed in it. And I would like to acknowledge my gratitude to Argonne Lab and to the U.S. Department of Energy for the years of faithful support of my database research.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="990ae3b2652542659607c20d6be633d0e3b25e79" translate="yes" xml:space="preserve">
          <source>MySpell does not support compound words. Hunspell has sophisticated support for compound words. At present, PostgreSQL implements only the basic compound word operations of Hunspell.</source>
          <target state="translated">MySpell不支持复合词。Hunspell对复合词有复杂的支持。目前,PostgreSQL只实现了Hunspell的基本复合词操作。</target>
        </trans-unit>
        <trans-unit id="5e441f15c5e733792befe0ffc73906895c439622" translate="yes" xml:space="preserve">
          <source>MySpell format is a subset of Hunspell. The &lt;code&gt;.affix&lt;/code&gt; file of Hunspell has the following structure:</source>
          <target state="translated">MySpell格式是Hunspell的子集。Hunspell 的 &lt;code&gt;.affix&lt;/code&gt; 文件具有以下结构：</target>
        </trans-unit>
        <trans-unit id="488df82bbfc103d0d771499379d0ae7070c9580f" translate="yes" xml:space="preserve">
          <source>N-distinct counts for combinations of column values. If greater than zero, the estimated number of distinct values in the combination. If less than zero, the negative of the number of distinct values divided by the number of rows. (The negated form is used when &lt;code&gt;ANALYZE&lt;/code&gt; believes that the number of distinct values is likely to increase as the table grows; the positive form is used when the column seems to have a fixed number of possible values.) For example, -1 indicates a unique combination of columns in which the number of distinct combinations is the same as the number of rows.</source>
          <target state="translated">列值组合的N分计数。如果大于零，则为组合中不同值的估计数量。如果小于零，则为不重复值数量的负数除以行数。（当 &lt;code&gt;ANALYZE&lt;/code&gt; 认为表的增长可能会增加不同值的数量时，使用否定形式；当该列似乎具有固定数量的可能值时，则使用正形式。）例如，-1表示a列的唯一组合，其中不同组合的数量与行数相同。</target>
        </trans-unit>
        <trans-unit id="b9f3788bf337d1fbd1e44a8ca35f9f8dc00922f3" translate="yes" xml:space="preserve">
          <source>N-distinct counts, serialized as &lt;code&gt;pg_ndistinct&lt;/code&gt; type</source>
          <target state="translated">N分 &lt;code&gt;pg_ndistinct&lt;/code&gt; ，序列化为pg_ndistinct类型</target>
        </trans-unit>
        <trans-unit id="df7b392c5a7d73b13e58918e0a512d5732187d0d" translate="yes" xml:space="preserve">
          <source>N.1. When Color is Used</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82b9c07010036ea2172a9c209c09188b295a72b2" translate="yes" xml:space="preserve">
          <source>N.2. Configuring the Colors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e75dedcc315971ca035b9f33d5ff4a268f0acad9" translate="yes" xml:space="preserve">
          <source>NAS</source>
          <target state="translated">NAS</target>
        </trans-unit>
        <trans-unit id="05c70c4a8ccede51b0f764a8b31b48ffad7c77b1" translate="yes" xml:space="preserve">
          <source>NLS</source>
          <target state="translated">NLS</target>
        </trans-unit>
        <trans-unit id="578dc1c57657369feb194b2bc15910a2480a2342" translate="yes" xml:space="preserve">
          <source>NOT &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">不是 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="efde75752ab811815325697b4ba90b5afbe2e2a6" translate="yes" xml:space="preserve">
          <source>NOTIFY</source>
          <target state="translated">NOTIFY</target>
        </trans-unit>
        <trans-unit id="3e7d70b52328177b60019485c8ea011b37cce023" translate="yes" xml:space="preserve">
          <source>NOTIFY &amp;mdash; generate a notification</source>
          <target state="translated">通知-生成通知</target>
        </trans-unit>
        <trans-unit id="eef19c54306daa69eda49c0272623bdb5e2b341f" translate="yes" xml:space="preserve">
          <source>NULL</source>
          <target state="translated">NULL</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="385a7cff63d2b3c51a6859910c942e284cc2cff9" translate="yes" xml:space="preserve">
          <source>Name of SSL cipher in use, or NULL if SSL is not in use on this connection</source>
          <target state="translated">正在使用的SSL密码的名称,如果在这个连接上没有使用SSL,则为NULL。</target>
        </trans-unit>
        <trans-unit id="5eaeda54ec9eb68b2072fa5d1feb6c035f44d644" translate="yes" xml:space="preserve">
          <source>Name of a language</source>
          <target state="translated">语言名称</target>
        </trans-unit>
        <trans-unit id="0178948b94c691d929c18fcd5464bd15baa26a58" translate="yes" xml:space="preserve">
          <source>Name of a new or existing column.</source>
          <target state="translated">新列或现有列的名称。</target>
        </trans-unit>
        <trans-unit id="560c42c98008ce51d03f9d6187d29c37c7009544" translate="yes" xml:space="preserve">
          <source>Name of a new or existing constraint.</source>
          <target state="translated">新的或现有约束的名称。</target>
        </trans-unit>
        <trans-unit id="35dcedcca97d439e09701340473e9f3ca046b02c" translate="yes" xml:space="preserve">
          <source>Name of a notification channel (any identifier).</source>
          <target state="translated">通知渠道的名称(任何标识符);</target>
        </trans-unit>
        <trans-unit id="ce514f0b60e997e86128266bb519efbba0a6ff6b" translate="yes" xml:space="preserve">
          <source>Name of a settable configuration parameter. Available parameters are documented in &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt;.</source>
          <target state="translated">可设置的配置参数的名称。可用参数在&lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;第19章中介绍&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f56681bfb8a12163f30d0b4fed0f1fd757c8babb" translate="yes" xml:space="preserve">
          <source>Name of a settable configuration parameter. Available parameters are documented in &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="954ee074d5be1c36459da8f7253027e56d893199" translate="yes" xml:space="preserve">
          <source>Name of a settable run-time parameter. Available parameters are documented in &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; and below.</source>
          <target state="translated">可设置的运行时参数的名称。可用参数在&lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;第19章&lt;/a&gt;及以下章节中介绍。</target>
        </trans-unit>
        <trans-unit id="9a0e3cf73c45665ec4941eb25f3329677ad2c627" translate="yes" xml:space="preserve">
          <source>Name of a settable run-time parameter. Available parameters are documented in &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; and on the &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; reference page.</source>
          <target state="translated">可设置的运行时参数的名称。可用参数都记录在&lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;第19&lt;/a&gt;和上&lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt;参考页。</target>
        </trans-unit>
        <trans-unit id="f5a2c1ef6c12c7af08e5bbbc68b4033b620233cc" translate="yes" xml:space="preserve">
          <source>Name of a settable run-time parameter. Available parameters are documented in &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; and below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aafb6ab430fc1bf75e0c604287df03b8d7d814d7" translate="yes" xml:space="preserve">
          <source>Name of a settable run-time parameter. Available parameters are documented in &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; and on the &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; reference page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c2301404426d669bb911593cec730650e2bdbfe" translate="yes" xml:space="preserve">
          <source>Name of a single trigger to disable or enable.</source>
          <target state="translated">要禁用或启用的单个触发器的名称。</target>
        </trans-unit>
        <trans-unit id="c0e033b344c49040ea83d0610c59dfd1b03a919f" translate="yes" xml:space="preserve">
          <source>Name of an existing column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="231d1ed2d468b8d6e17991509cbba8cadc17e1e5" translate="yes" xml:space="preserve">
          <source>Name of an existing constraint to drop or rename.</source>
          <target state="translated">要删除或重命名的现有约束的名称。</target>
        </trans-unit>
        <trans-unit id="22745c3446c7c4d17ba8fa32b15b8f7c06992bdd" translate="yes" xml:space="preserve">
          <source>Name of an existing constraint to drop.</source>
          <target state="translated">要删除的现有约束的名称。</target>
        </trans-unit>
        <trans-unit id="b073ede31105aa5c1b6f36a11370455d96d537b0" translate="yes" xml:space="preserve">
          <source>Name of an existing table. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, only that table is affected. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, the table and all its descendant tables (if any) are affected. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">现有表的名称。如果在表名之前 &lt;code&gt;ONLY&lt;/code&gt; 指定ONLY，则仅影响该表。如果未指定 &lt;code&gt;ONLY&lt;/code&gt; ，则该表及其所有后代表（如果有）将受到影响。（可选）可以在表名之后指定 &lt;code&gt;*&lt;/code&gt; ,以明确指示包括后代表。</target>
        </trans-unit>
        <trans-unit id="694de0e59c53dd44f4f4691acabc413768ef9d9a" translate="yes" xml:space="preserve">
          <source>Name of anonymous-block handler function, or null if none</source>
          <target state="translated">匿名块处理函数的名称,如果没有,则为空。</target>
        </trans-unit>
        <trans-unit id="5915762ae281a23f2bd1848ce737f5d865ae38a8" translate="yes" xml:space="preserve">
          <source>Name of call handler function</source>
          <target state="translated">调用处理函数的名称</target>
        </trans-unit>
        <trans-unit id="206dec00fa32e6c205384b3df437c35f69e88392" translate="yes" xml:space="preserve">
          <source>Name of default version, or &lt;code&gt;NULL&lt;/code&gt; if none is specified</source>
          <target state="translated">默认版本的名称；如果未指定，则为 &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ee034d5b0508537af88d7be3d4206b7d9a6f7ace" translate="yes" xml:space="preserve">
          <source>Name of extended statistics</source>
          <target state="translated">扩展统计名称</target>
        </trans-unit>
        <trans-unit id="987fff60ced95bb42507af7d6f424dce288531b4" translate="yes" xml:space="preserve">
          <source>Name of index</source>
          <target state="translated">索引名称</target>
        </trans-unit>
        <trans-unit id="b76e90e08249294dc6388d288e0a0ff43959a02e" translate="yes" xml:space="preserve">
          <source>Name of materialized view</source>
          <target state="translated">物化视图的名称</target>
        </trans-unit>
        <trans-unit id="6501e212c15d2fb75aeb9acf75320931a339d605" translate="yes" xml:space="preserve">
          <source>Name of materialized view's owner</source>
          <target state="translated">物化视图的所有者名称</target>
        </trans-unit>
        <trans-unit id="e6cf10a0a70ad19c5b7371da58941b6c0037ae86" translate="yes" xml:space="preserve">
          <source>Name of policy</source>
          <target state="translated">保单名称</target>
        </trans-unit>
        <trans-unit id="a146b1bd6e895582068f638a02a8412aaeadca11" translate="yes" xml:space="preserve">
          <source>Name of publication</source>
          <target state="translated">出版物名称</target>
        </trans-unit>
        <trans-unit id="611f97b7cc9cb3302c011583c51a64d361fde262" translate="yes" xml:space="preserve">
          <source>Name of rule</source>
          <target state="translated">规则名称</target>
        </trans-unit>
        <trans-unit id="916daa93b2ab22b09d0d27a6fc75daa92e090cbf" translate="yes" xml:space="preserve">
          <source>Name of schema containing extended statistic</source>
          <target state="translated">包含扩展统计的模式名称</target>
        </trans-unit>
        <trans-unit id="b8e23c7699d61150cab192ab08cb0a8c8eff18ba" translate="yes" xml:space="preserve">
          <source>Name of schema containing materialized view</source>
          <target state="translated">包含实体化视图的模式名称</target>
        </trans-unit>
        <trans-unit id="8a4b8a6f4e6c77468796e3b2343ea829020a1a97" translate="yes" xml:space="preserve">
          <source>Name of schema containing sequence</source>
          <target state="translated">包含序列的模式名称</target>
        </trans-unit>
        <trans-unit id="9330f5310d2e7af8a885aaca54f40c7a5b2e64d8" translate="yes" xml:space="preserve">
          <source>Name of schema containing table</source>
          <target state="translated">包含表的模式名称</target>
        </trans-unit>
        <trans-unit id="dd40e81316e76702c45608033ccb5e0f85f3dfea" translate="yes" xml:space="preserve">
          <source>Name of schema containing table and index</source>
          <target state="translated">包含表和索引的模式名称</target>
        </trans-unit>
        <trans-unit id="b025c1d95310dde444c37ad986883a8dee5bb9d3" translate="yes" xml:space="preserve">
          <source>Name of schema containing table policy is on</source>
          <target state="translated">包含表策略的模式名称为</target>
        </trans-unit>
        <trans-unit id="651e03eac67fc05e08a5fc3c4b0db8b8a5ca2d70" translate="yes" xml:space="preserve">
          <source>Name of schema containing view</source>
          <target state="translated">包含视图的模式名称</target>
        </trans-unit>
        <trans-unit id="fd465cc8a117f3266eab848066483930a22454ae" translate="yes" xml:space="preserve">
          <source>Name of sequence</source>
          <target state="translated">序列名称</target>
        </trans-unit>
        <trans-unit id="f8e19bb0d7e02e23ea651a2fbd412be10bd907ea" translate="yes" xml:space="preserve">
          <source>Name of sequence's owner</source>
          <target state="translated">序列的所有者名称</target>
        </trans-unit>
        <trans-unit id="2c617ffcb7fc75270eec292d65c4160eff374b06" translate="yes" xml:space="preserve">
          <source>Name of table</source>
          <target state="translated">表名</target>
        </trans-unit>
        <trans-unit id="f10df6f392a1568c4d43e34377ec16b2f3a7fa44" translate="yes" xml:space="preserve">
          <source>Name of table policy is on</source>
          <target state="translated">表政策的名称是</target>
        </trans-unit>
        <trans-unit id="c0513b8ba01d1af1c795daf01358ee55cf3296c9" translate="yes" xml:space="preserve">
          <source>Name of table the index is for</source>
          <target state="translated">索引所在表的名称</target>
        </trans-unit>
        <trans-unit id="d795c0056cb1fd8b2838b400cf90a77a5b34f1c7" translate="yes" xml:space="preserve">
          <source>Name of table the rule is for</source>
          <target state="translated">规则所针对的表的名称</target>
        </trans-unit>
        <trans-unit id="6f44460598242d440e308c5206bbdd4ee6c15df5" translate="yes" xml:space="preserve">
          <source>Name of table's owner</source>
          <target state="translated">表的所有者姓名</target>
        </trans-unit>
        <trans-unit id="cc73fa216f99d868d036ec5fa8be32ea593b2352" translate="yes" xml:space="preserve">
          <source>Name of tablespace containing index (null if default for database)</source>
          <target state="translated">包含索引的表空间的名称(如果数据库默认为空)。</target>
        </trans-unit>
        <trans-unit id="13a740701fe416ff32d444b4b9dea241f97f8406" translate="yes" xml:space="preserve">
          <source>Name of tablespace containing materialized view (null if default for database)</source>
          <target state="translated">包含实体化视图的表空间名称(如果数据库默认为空,则为空)。</target>
        </trans-unit>
        <trans-unit id="e235059f85c95c9cf0964b16c38689bf7ab5f960" translate="yes" xml:space="preserve">
          <source>Name of tablespace containing table (null if default for database)</source>
          <target state="translated">包含表的表空间的名称(如果数据库的默认值为空)。</target>
        </trans-unit>
        <trans-unit id="38df58659a85a8c6be97b9180f6ba3a3db8fd801" translate="yes" xml:space="preserve">
          <source>Name of the SLRU</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b950b20317e5d48a4d7180b3b67b23925387d954" translate="yes" xml:space="preserve">
          <source>Name of the WAL file of the last failed archival operation</source>
          <target state="translated">最后一次失败的归档操作的WAL文件的名称。</target>
        </trans-unit>
        <trans-unit id="50c7ff72173e6a33ac0f4b45d6945424b157e3f8" translate="yes" xml:space="preserve">
          <source>Name of the access method</source>
          <target state="translated">访问方法的名称</target>
        </trans-unit>
        <trans-unit id="42336fd50699db80c8e30a44b238f551cdfe5e05" translate="yes" xml:space="preserve">
          <source>Name of the application that is connected to this WAL sender</source>
          <target state="translated">连接到该WAL发送器的应用程序名称</target>
        </trans-unit>
        <trans-unit id="73eb48e900d4da8e91ccec691048b06a84e20927" translate="yes" xml:space="preserve">
          <source>Name of the application that is connected to this backend</source>
          <target state="translated">连接到这个后台的应用程序的名称。</target>
        </trans-unit>
        <trans-unit id="e5622c8d744e74d58e5852a23ea1813374720ca0" translate="yes" xml:space="preserve">
          <source>Name of the column described by this row</source>
          <target state="translated">本行描述的列名</target>
        </trans-unit>
        <trans-unit id="05582534113d6fd58f1c91cf719019de03349552" translate="yes" xml:space="preserve">
          <source>Name of the database in which the transaction was executed</source>
          <target state="translated">执行交易的数据库名称。</target>
        </trans-unit>
        <trans-unit id="3c046694c5a00d97ff6a1379659314bd6a78ef25" translate="yes" xml:space="preserve">
          <source>Name of the database this backend is connected to</source>
          <target state="translated">后台连接到的数据库名称</target>
        </trans-unit>
        <trans-unit id="21b466dc28882ad5e606c7e29b3635f8046375c5" translate="yes" xml:space="preserve">
          <source>Name of the database to which this backend is connected.</source>
          <target state="translated">该后台所连接的数据库名称。</target>
        </trans-unit>
        <trans-unit id="a4b1ce5ff884a2efdb43d43a59c57f0b4fa4d401" translate="yes" xml:space="preserve">
          <source>Name of the event source for pg_ctl to use for logging to the event log when running as a Windows service. The default is &lt;code&gt;PostgreSQL&lt;/code&gt;. Note that this only controls messages sent from pg_ctl itself; once started, the server will use the event source specified by its &lt;a href=&quot;runtime-config-logging#GUC-EVENT-SOURCE&quot;&gt;event_source&lt;/a&gt; parameter. Should the server fail very early in startup, before that parameter has been set, it might also log using the default event source name &lt;code&gt;PostgreSQL&lt;/code&gt;.</source>
          <target state="translated">pg_ctl的事件源名称，用于在作为Windows服务运行时用于记录到事件日志。默认值为 &lt;code&gt;PostgreSQL&lt;/code&gt; 。注意，这仅控制从pg_ctl本身发送的消息。一旦启动，服务器将使用其&lt;a href=&quot;runtime-config-logging#GUC-EVENT-SOURCE&quot;&gt;event_source&lt;/a&gt;参数指定的事件源。如果服务器在启动之前很早就发生故障，那么在设置该参数之前，它也可能会使用默认事件源名称 &lt;code&gt;PostgreSQL&lt;/code&gt; 进行日志记录。</target>
        </trans-unit>
        <trans-unit id="db2a8ab1c7a6e8e7352acea353746079da1e0da5" translate="yes" xml:space="preserve">
          <source>Name of the extension</source>
          <target state="translated">分机名称</target>
        </trans-unit>
        <trans-unit id="b32842559bebdaa75c2073237260c49768556ba4" translate="yes" xml:space="preserve">
          <source>Name of the field to order siblings by (optional)</source>
          <target state="translated">按兄弟姐妹排序的字段名称(可选)。</target>
        </trans-unit>
        <trans-unit id="d305530c62c0c372c9b705ff8915012e6f1258b2" translate="yes" xml:space="preserve">
          <source>Name of the foreign server</source>
          <target state="translated">国外服务器的名称</target>
        </trans-unit>
        <trans-unit id="59348747feca44834dd28cf94d333b16c8cfbbf0" translate="yes" xml:space="preserve">
          <source>Name of the foreign-data wrapper</source>
          <target state="translated">外国数据包装器的名称</target>
        </trans-unit>
        <trans-unit id="9e20c57335eda37ac38552a55cb17fe874d8fb6b" translate="yes" xml:space="preserve">
          <source>Name of the function</source>
          <target state="translated">职能名称</target>
        </trans-unit>
        <trans-unit id="eee39eba3634db32e7cb3a66942216268c13c704" translate="yes" xml:space="preserve">
          <source>Name of the group</source>
          <target state="translated">集团名称</target>
        </trans-unit>
        <trans-unit id="e6e050c906fd9fbc0c7b4d3a235e25d068290256" translate="yes" xml:space="preserve">
          <source>Name of the key field</source>
          <target state="translated">关键字段的名称</target>
        </trans-unit>
        <trans-unit id="b217fce5b600ff5e59a7bde206ff84c6743ebd06" translate="yes" xml:space="preserve">
          <source>Name of the language</source>
          <target state="translated">语文名称</target>
        </trans-unit>
        <trans-unit id="999d13acc30868afb96a2061f85f8cfbf835af9a" translate="yes" xml:space="preserve">
          <source>Name of the language this template is for</source>
          <target state="translated">本模板的语言名称</target>
        </trans-unit>
        <trans-unit id="c0904d4653e24f5cf40ca0e66167033212dff01e" translate="yes" xml:space="preserve">
          <source>Name of the last WAL file successfully archived</source>
          <target state="translated">最后一个成功归档的WAL文件的名称。</target>
        </trans-unit>
        <trans-unit id="632030382b37c4353da7f8cfd3fb10f03fb4878e" translate="yes" xml:space="preserve">
          <source>Name of the local user to be mapped</source>
          <target state="translated">要映射的本地用户名称</target>
        </trans-unit>
        <trans-unit id="3283788f7750678653d33179d0a9b570a3fb07a0" translate="yes" xml:space="preserve">
          <source>Name of the lock mode held or desired by this process (see &lt;a href=&quot;explicit-locking#LOCKING-TABLES&quot;&gt;Section 13.3.1&lt;/a&gt; and &lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;Section 13.2.3&lt;/a&gt;)</source>
          <target state="translated">此过程保持或期望的锁定模式的名称（请参见&lt;a href=&quot;explicit-locking#LOCKING-TABLES&quot;&gt;第13.3.1 &lt;/a&gt;&lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;节&lt;/a&gt;和第13.2.3节）</target>
        </trans-unit>
        <trans-unit id="bca4b201210cb86555d12a73e7fa1d0df2b4ce1d" translate="yes" xml:space="preserve">
          <source>Name of the namespace</source>
          <target state="translated">命名空间的名称</target>
        </trans-unit>
        <trans-unit id="116ede6679101b358b013bfe3778515f6a6eb59a" translate="yes" xml:space="preserve">
          <source>Name of the notification channel to be signaled (any identifier).</source>
          <target state="translated">要发出信号的通知通道的名称(任何标识符);</target>
        </trans-unit>
        <trans-unit id="b1846b8dfbb275c5d01dbe581ad89ecd8bd17f99" translate="yes" xml:space="preserve">
          <source>Name of the on-disk file of this relation; zero means this is a &amp;ldquo;mapped&amp;rdquo; relation whose disk file name is determined by low-level state</source>
          <target state="translated">此关系的磁盘文件名；零表示这是一个&amp;ldquo;映射&amp;rdquo;关系，其磁盘文件名由低级状态确定</target>
        </trans-unit>
        <trans-unit id="ffd1b3d5baf3902d7d64e922601a9c11dc846fd8" translate="yes" xml:space="preserve">
          <source>Name of the operator</source>
          <target state="translated">经营者名称</target>
        </trans-unit>
        <trans-unit id="f362cae832a0a92cf6859f4e3035227030a3fa7e" translate="yes" xml:space="preserve">
          <source>Name of the parent-key field</source>
          <target state="translated">父键字段的名称</target>
        </trans-unit>
        <trans-unit id="914386f36015301aa42cdc85d2971f37bbd3f6e1" translate="yes" xml:space="preserve">
          <source>Name of the publication</source>
          <target state="translated">出版物名称</target>
        </trans-unit>
        <trans-unit id="f8ba7366e5638b5adb85cf058a4f60fc77a1437d" translate="yes" xml:space="preserve">
          <source>Name of the replication slot in the upstream database (also used for the local replication origin name); null represents &lt;code&gt;NONE&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95141217167b4e44530e9c633ef9691ad9e4c7d5" translate="yes" xml:space="preserve">
          <source>Name of the replication slot in the upstream database. Also used for local replication origin name.</source>
          <target state="translated">上游数据库中复制槽的名称。也用于本地复制源名称。</target>
        </trans-unit>
        <trans-unit id="48b6dcd7b3f9b0cceabe3c942a0ff0d053cf3051" translate="yes" xml:space="preserve">
          <source>Name of the replication slot to use. The default behavior is to use the name of the subscription for the slot name.</source>
          <target state="translated">要使用的复制槽的名称。默认行为是使用订阅的名称作为槽名。</target>
        </trans-unit>
        <trans-unit id="0c22c3cdbc7df0d29a30ef0e5d20c6d53a22aba3" translate="yes" xml:space="preserve">
          <source>Name of the schema that the extension must be installed into, or &lt;code&gt;NULL&lt;/code&gt; if partially or fully relocatable</source>
          <target state="translated">扩展必须安装到的模式的名称，如果可部分或完全重定位，则为 &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="46b2c8652132c7dc1c02610fe232f22c32a70e49" translate="yes" xml:space="preserve">
          <source>Name of the schema that this table is in</source>
          <target state="translated">该表所在的模式名称。</target>
        </trans-unit>
        <trans-unit id="aeed8d4431144cabd5a1127005bce646d16cab11" translate="yes" xml:space="preserve">
          <source>Name of the schema this function is in</source>
          <target state="translated">该函数所在模式的名称</target>
        </trans-unit>
        <trans-unit id="b11dd1fd926881e2c689b2ce026036d1c6bf66aa" translate="yes" xml:space="preserve">
          <source>Name of the schema this index is in</source>
          <target state="translated">该索引所在模式的名称</target>
        </trans-unit>
        <trans-unit id="55e1e35ee330306af1edafba8c0ccceb0641d202" translate="yes" xml:space="preserve">
          <source>Name of the schema this sequence is in</source>
          <target state="translated">该序列所在模式的名称</target>
        </trans-unit>
        <trans-unit id="d75b4d0b583232f5341524b6ac4e00946212dc64" translate="yes" xml:space="preserve">
          <source>Name of the source relation</source>
          <target state="translated">源关系的名称</target>
        </trans-unit>
        <trans-unit id="02fe646b94a9a3942519f9c9b3db9e92f9c9c3fd" translate="yes" xml:space="preserve">
          <source>Name of the statistics object</source>
          <target state="translated">统计对象的名称</target>
        </trans-unit>
        <trans-unit id="33574f9c61c2e627eb0d3d0f3da70a170678a9ff" translate="yes" xml:space="preserve">
          <source>Name of the subscription</source>
          <target state="translated">认购名称</target>
        </trans-unit>
        <trans-unit id="90ae080c0a5fc808f5e0a7e8b8cae579504b16d5" translate="yes" xml:space="preserve">
          <source>Name of the system service to register. This name will be used as both the service name and the display name. The default is &lt;code&gt;PostgreSQL&lt;/code&gt;.</source>
          <target state="translated">要注册的系统服务的名称。该名称将同时用作服务名称和显示名称。默认值为 &lt;code&gt;PostgreSQL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5e271781547e2a1e2376a48974f2d9fab48cde2" translate="yes" xml:space="preserve">
          <source>Name of the table for this index</source>
          <target state="translated">该索引的表名</target>
        </trans-unit>
        <trans-unit id="0200e1f7b3df494bd305d84c497873916f941937" translate="yes" xml:space="preserve">
          <source>Name of the table, index, view, etc.</source>
          <target state="translated">表、索引、视图等的名称。</target>
        </trans-unit>
        <trans-unit id="a1f59b4d65687dc8fe0a85f1b74351b10bfba7a6" translate="yes" xml:space="preserve">
          <source>Name of the user logged into this WAL sender process</source>
          <target state="translated">登录该WAL发送者进程的用户名称</target>
        </trans-unit>
        <trans-unit id="3fe80a85bf2161f51d9c08098d7bfcdedce6c9ee" translate="yes" xml:space="preserve">
          <source>Name of the user logged into this backend</source>
          <target state="translated">登录到这个后台的用户名称</target>
        </trans-unit>
        <trans-unit id="04f7b7b315d382679587d80fba309d2bb70b1345" translate="yes" xml:space="preserve">
          <source>Name of the user that executed the transaction</source>
          <target state="translated">执行交易的用户名称</target>
        </trans-unit>
        <trans-unit id="c24f99aa0c8caf23a96b75cece5098629fd6a94e" translate="yes" xml:space="preserve">
          <source>Name of this database</source>
          <target state="translated">该数据库的名称</target>
        </trans-unit>
        <trans-unit id="2086d14cece3b039e0a515f48cc92518784c4d7a" translate="yes" xml:space="preserve">
          <source>Name of this database, or &lt;code&gt;NULL&lt;/code&gt; for shared objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73d6411e8bd4b74b577e7365540cb543464ed926" translate="yes" xml:space="preserve">
          <source>Name of this database, or &lt;code&gt;NULL&lt;/code&gt; for the shared objects.</source>
          <target state="translated">此数据库的名称，对于共享库为 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09edc4fe28078a94e956caa9447364b4707b6491" translate="yes" xml:space="preserve">
          <source>Name of this function</source>
          <target state="translated">该功能的名称</target>
        </trans-unit>
        <trans-unit id="a2e0e5204a994c27fb6b9e0e825c613dd1c4755e" translate="yes" xml:space="preserve">
          <source>Name of this index</source>
          <target state="translated">该索引的名称</target>
        </trans-unit>
        <trans-unit id="52256e99af10a92f8d2567b55a83d56fe82e813a" translate="yes" xml:space="preserve">
          <source>Name of this operator class</source>
          <target state="translated">该操作类的名称</target>
        </trans-unit>
        <trans-unit id="8660634803fb7c50b11c80dde370467806dff8e0" translate="yes" xml:space="preserve">
          <source>Name of this operator family</source>
          <target state="translated">该运营商家族的名称</target>
        </trans-unit>
        <trans-unit id="67e86bea4f13cfb5fdec580a24af26d2de2fdc44" translate="yes" xml:space="preserve">
          <source>Name of this sequence</source>
          <target state="translated">该序列的名称</target>
        </trans-unit>
        <trans-unit id="b490c1221b4b64551bfddc6b8b9c77d0ea3870a9" translate="yes" xml:space="preserve">
          <source>Name of this table</source>
          <target state="translated">本表的名称</target>
        </trans-unit>
        <trans-unit id="79333580b15aa0175b731014d71be95e862ff44a" translate="yes" xml:space="preserve">
          <source>Name of validator function, or null if none</source>
          <target state="translated">验证器函数的名称,如果没有,则为空。</target>
        </trans-unit>
        <trans-unit id="d340979d7f1712dd54645083825a2794537380b7" translate="yes" xml:space="preserve">
          <source>Name of view</source>
          <target state="translated">观点名称</target>
        </trans-unit>
        <trans-unit id="ca9987204d1e0d3bf0d8020ca5eccf2de116a77a" translate="yes" xml:space="preserve">
          <source>Name of view's owner</source>
          <target state="translated">视图的所有者姓名</target>
        </trans-unit>
        <trans-unit id="715cd77a48eca5f7bbf90153374438716221cbe4" translate="yes" xml:space="preserve">
          <source>Named and mixed call notations currently cannot be used when calling an aggregate function (but they do work when an aggregate function is used as a window function).</source>
          <target state="translated">目前在调用集合函数时,不能使用命名和混合调用符号(但当集合函数被用作窗口函数时,它们可以工作)。</target>
        </trans-unit>
        <trans-unit id="febb13b6b6bedee695a2cdffc8584795987df071" translate="yes" xml:space="preserve">
          <source>Named run-time parameters can be set in either of these styles:</source>
          <target state="translated">命名的运行时参数可以用其中一种方式设置。</target>
        </trans-unit>
        <trans-unit id="b335beb0e29ec02f76a030301ce30aec55d10a00" translate="yes" xml:space="preserve">
          <source>Names can be assigned to table constraints in the same way as column constraints:</source>
          <target state="translated">名称可以像列约束一样分配给表约束。</target>
        </trans-unit>
        <trans-unit id="90e76064cba28bce291e20a00492ac8908ed2815" translate="yes" xml:space="preserve">
          <source>Names of prerequisite extensions, or &lt;code&gt;NULL&lt;/code&gt; if none</source>
          <target state="translated">必备扩展名，如果没有则为 &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="879c37a97f04ee34ad69a53c4aa464879102ff50" translate="yes" xml:space="preserve">
          <source>Names of the columns the extended statistics is defined on</source>
          <target state="translated">扩展统计数据的列名定义为</target>
        </trans-unit>
        <trans-unit id="774a71278e16cec9ccf959b5bab94713611e399e" translate="yes" xml:space="preserve">
          <source>Names of the publications on the publisher to subscribe to.</source>
          <target state="translated">要订阅的出版商的出版物名称:</target>
        </trans-unit>
        <trans-unit id="ef2014703004a1217b3fec5210db4117b70e51de" translate="yes" xml:space="preserve">
          <source>Names or IP addresses of LDAP servers to connect to. Multiple servers may be specified, separated by spaces.</source>
          <target state="translated">要连接的LDAP服务器的名称或IP地址。可以指定多个服务器,用空格分隔。</target>
        </trans-unit>
        <trans-unit id="3f95be766c8568501a000e46e6894d04ef9f8877" translate="yes" xml:space="preserve">
          <source>Namespace Available to &lt;code&gt;GROUP BY&lt;/code&gt; and &lt;code&gt;ORDER BY&lt;/code&gt;</source>
          <target state="translated">命名空间可用于 &lt;code&gt;GROUP BY&lt;/code&gt; 和 &lt;code&gt;ORDER BY&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="47230dc537dc21987e746d4c719b4cc41ae69b6a" translate="yes" xml:space="preserve">
          <source>Namespace of this operator class</source>
          <target state="translated">该运算符类的命名空间</target>
        </trans-unit>
        <trans-unit id="a230663970531d46658f671326f61bad6755f192" translate="yes" xml:space="preserve">
          <source>Namespace of this operator family</source>
          <target state="translated">该运算符系列的命名空间</target>
        </trans-unit>
        <trans-unit id="a1c428db5a690b5f5a2a8bbbdfae45bd49175ad0" translate="yes" xml:space="preserve">
          <source>National Language Support</source>
          <target state="translated">国家语言支持</target>
        </trans-unit>
        <trans-unit id="725efb9e43acf1bf580c09d2cb1b0cf911451468" translate="yes" xml:space="preserve">
          <source>National Standard</source>
          <target state="translated">国家标准</target>
        </trans-unit>
        <trans-unit id="9d1f7ad08bfbe66715ad20935eced5ce9dc0eb67" translate="yes" xml:space="preserve">
          <source>Natural logarithm</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9c36a47f8e482a64ff81cd9e84619cb8413e09b" translate="yes" xml:space="preserve">
          <source>Nearest integer greater than or equal to argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68c2729e4aa8267e02a5e14878260b805c76e4f0" translate="yes" xml:space="preserve">
          <source>Nearest integer greater than or equal to argument (same as &lt;code&gt;ceil&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="333e55744c1836d8e2f747a46f8a58bd387549f7" translate="yes" xml:space="preserve">
          <source>Nearest integer greater than or equal to the SQL/JSON number</source>
          <target state="translated">大于或等于SQL/JSON数的最接近的整数。</target>
        </trans-unit>
        <trans-unit id="3089188f4ef21fadc5a7ae8a8917660ce59f776c" translate="yes" xml:space="preserve">
          <source>Nearest integer greater than or equal to the given number</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc0f09f7738d16783cda39dfae33946b8073a87" translate="yes" xml:space="preserve">
          <source>Nearest integer less than or equal to argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bee672459bc21a36f5d885e59227b9978e9d1866" translate="yes" xml:space="preserve">
          <source>Nearest integer less than or equal to the SQL/JSON number</source>
          <target state="translated">小于或等于SQL/JSON数字的最接近的整数。</target>
        </trans-unit>
        <trans-unit id="6a166687429ef42663b71e2fae4f0d6dcf7415c3" translate="yes" xml:space="preserve">
          <source>Nearest integer less than or equal to the given number</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e224c76bc25e4149e084462adee5b7564caac26" translate="yes" xml:space="preserve">
          <source>Needless to say, processing XML data with PostgreSQL will be less error-prone and more efficient if the XML data encoding, client encoding, and server encoding are the same. Since XML data is internally processed in UTF-8, computations will be most efficient if the server encoding is also UTF-8.</source>
          <target state="translated">不用说,用PostgreSQL处理XML数据,如果XML数据编码、客户端编码和服务器编码相同,那么处理XML数据的错误率会更低,效率更高。由于XML数据在内部是用UTF-8处理的,所以如果服务器编码也是UTF-8,计算效率会最高。</target>
        </trans-unit>
        <trans-unit id="dfc508fa9ddaeb33e233aa812ebad0ab8c049dd2" translate="yes" xml:space="preserve">
          <source>Negate an interval</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b33f9b7a0a4606b4bd747722b21501d99fa70ad" translate="yes" xml:space="preserve">
          <source>Negates a &lt;code&gt;tsquery&lt;/code&gt;, producing a query that matches documents that do not match the input query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24048c04eba343a323fecac37d642445c66f6c28" translate="yes" xml:space="preserve">
          <source>Negation</source>
          <target state="translated">Negation</target>
        </trans-unit>
        <trans-unit id="192f6939bf2bfe49ee33bf49687c9297f6c0972d" translate="yes" xml:space="preserve">
          <source>Negation; unlike subtraction, this can iterate over multiple values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27cadf6ca95971ac3dd5c11e621924026c16209f" translate="yes" xml:space="preserve">
          <source>Negator of this operator, if any</source>
          <target state="translated">该操作者的否定者,如果有的话</target>
        </trans-unit>
        <trans-unit id="cdedd7a3e12a28ecdae254105845f04dc8b7e221" translate="yes" xml:space="preserve">
          <source>Neither sequential scans nor nested-loop joins can be disabled completely; the &lt;code&gt;-fs&lt;/code&gt; and &lt;code&gt;-fn&lt;/code&gt; options simply discourage the optimizer from using those plan types if it has any other alternative.</source>
          <target state="translated">顺序扫描和嵌套循环联接都不能完全禁用。在 &lt;code&gt;-fs&lt;/code&gt; 和 &lt;code&gt;-fn&lt;/code&gt; 选项仅仅是阻止优化器使用这些方法，如果有任何其他的选择。</target>
        </trans-unit>
        <trans-unit id="999497fbc59b4c8badf88b3dddf684b5320af0cd" translate="yes" xml:space="preserve">
          <source>Neither the source nor the destination encoding can be &lt;code&gt;SQL_ASCII&lt;/code&gt;, as the server's behavior for cases involving the &lt;code&gt;SQL_ASCII&lt;/code&gt;&amp;ldquo;encoding&amp;rdquo; is hard-wired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc249089e46e70234a72d288cf1c8de145f74bd2" translate="yes" xml:space="preserve">
          <source>Neither timezone names nor abbreviations are hard-wired into the server; they are obtained from configuration files stored under &lt;code&gt;.../share/timezone/&lt;/code&gt; and &lt;code&gt;.../share/timezonesets/&lt;/code&gt; of the installation directory (see &lt;a href=&quot;datetime-config-files&quot;&gt;Section B.4&lt;/a&gt;).</source>
          <target state="translated">时区名称和缩写都不会硬连线到服务器中；它们是从存储在安装目录的 &lt;code&gt;.../share/timezone/&lt;/code&gt; 和 &lt;code&gt;.../share/timezonesets/&lt;/code&gt; 下的配置文件获得的（请参阅&lt;a href=&quot;datetime-config-files&quot;&gt;第B.4节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3e9e1f6f189ff8e4d505c81b54a796d5e66a2542" translate="yes" xml:space="preserve">
          <source>NetBSD</source>
          <target state="translated">NetBSD</target>
        </trans-unit>
        <trans-unit id="8d546e29b4f4fdcb009106a5c128188e2431946d" translate="yes" xml:space="preserve">
          <source>NetBSD versions before 5.0 work like old OpenBSD (see below), except that kernel parameters should be set with the keyword &lt;code&gt;options&lt;/code&gt; not &lt;code&gt;option&lt;/code&gt;.</source>
          <target state="translated">NetBSD 5.0之前的版本类似于旧的OpenBSD（请参见下文），除了内核参数应使用关键字 &lt;code&gt;options&lt;/code&gt; not &lt;code&gt;option&lt;/code&gt; 设置。</target>
        </trans-unit>
        <trans-unit id="4970c28f364d041c28f5d5ff2bc88daf1a13ad01" translate="yes" xml:space="preserve">
          <source>Network Address Types</source>
          <target state="translated">网络地址类型</target>
        </trans-unit>
        <trans-unit id="1aab162fb1d4be431f43c575684b7d8c545c8302" translate="yes" xml:space="preserve">
          <source>Network Address Types: cidr</source>
          <target state="translated">网络地址类型:cidr</target>
        </trans-unit>
        <trans-unit id="a0a4631210875f94aba2f16fc813f4614e393764" translate="yes" xml:space="preserve">
          <source>Network Address Types: inet</source>
          <target state="translated">网络地址类型:inet</target>
        </trans-unit>
        <trans-unit id="341da3e8cf1498f3f62648168d4190e67f278782" translate="yes" xml:space="preserve">
          <source>Network Address Types: macaddr</source>
          <target state="translated">网络地址类型:macaddr</target>
        </trans-unit>
        <trans-unit id="81bbd3c87492587fd7ddfed55118e840abffce9f" translate="yes" xml:space="preserve">
          <source>Network Address Types: macaddr8</source>
          <target state="translated">网络地址类型:macaddr8</target>
        </trans-unit>
        <trans-unit id="c5f17a43f889ac0d89795d00fba1671fe47f62f0" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;amp;</source>
          <target state="translated">网络地址： ＆</target>
        </trans-unit>
        <trans-unit id="3182c01748d8a83efe78a3f4ab6c4e990eacea0c" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;amp;&amp;amp;</source>
          <target state="translated">网络地址： ＆＆</target>
        </trans-unit>
        <trans-unit id="c32091a6107e7e44a68fb436fb33982336ccc452" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;gt;</source>
          <target state="translated">网络地址：&amp;gt;</target>
        </trans-unit>
        <trans-unit id="86a00c20e3381c9260f079dcb6e41c4262f1ea3a" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;gt;&amp;gt;</source>
          <target state="translated">网址：&amp;gt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f3736d0bb3a030e00d7114ef9030a0916af6881f" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;gt;&amp;gt;=</source>
          <target state="translated">网址：&amp;gt;&amp;gt; =</target>
        </trans-unit>
        <trans-unit id="b6a612c0f5ca1e234f11a6f50c9a9f41342ace58" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;gt;=</source>
          <target state="translated">网络地址：&amp;gt; =</target>
        </trans-unit>
        <trans-unit id="0cab881598e19094a73fe2cb680ef2e7600ff52c" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;lt;</source>
          <target state="translated">网络地址：&amp;lt;</target>
        </trans-unit>
        <trans-unit id="a2a64bdcd407fdda5883dcb3954eb4988b1bf440" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;lt;&amp;gt;</source>
          <target state="translated">网络地址：&amp;lt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e00740580248e58ab92c3eb2672f19b765c748b0" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;lt;&amp;lt;</source>
          <target state="translated">网址：&amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="1ff901142c2068fe8cf464afe26c9042106af748" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;lt;&amp;lt;=</source>
          <target state="translated">网络地址：&amp;lt;&amp;lt; =</target>
        </trans-unit>
        <trans-unit id="68fb0bbbf4bee491f6e6bbc78cee804b2462e684" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;lt;=</source>
          <target state="translated">网络地址：&amp;lt;=</target>
        </trans-unit>
        <trans-unit id="6b9e98c353b63977350c4597ab783ed68802ee56" translate="yes" xml:space="preserve">
          <source>Network Address: +</source>
          <target state="translated">网络地址。+</target>
        </trans-unit>
        <trans-unit id="39dd97c5cafd7589b71c3638f6bb1482a7b84d8f" translate="yes" xml:space="preserve">
          <source>Network Address: -</source>
          <target state="translated">网络地址。-</target>
        </trans-unit>
        <trans-unit id="777f2ecef47fe73d67412a0b49eb5b48a584a4d2" translate="yes" xml:space="preserve">
          <source>Network Address: 200 + inet &amp;#x27;::ffff:fff0:1&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b124004ce04609acad1c95336f7a76fcba56d8c" translate="yes" xml:space="preserve">
          <source>Network Address: 4</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b43debcb1e648bae4f59d9ad9d57421aa61da314" translate="yes" xml:space="preserve">
          <source>Network Address: =</source>
          <target state="translated">网络地址:=</target>
        </trans-unit>
        <trans-unit id="f6da4644273b4e1c84158d7bdc34944932533ec4" translate="yes" xml:space="preserve">
          <source>Network Address: abbrev</source>
          <target state="translated">网络地址:缩略语</target>
        </trans-unit>
        <trans-unit id="c0aa9d1b8f2a11dc8e2d5492bfd563df5e51a186" translate="yes" xml:space="preserve">
          <source>Network Address: broadcast</source>
          <target state="translated">网络地址:广播</target>
        </trans-unit>
        <trans-unit id="22c496032e898e93c86c9e0b2d1794774c6cc3b0" translate="yes" xml:space="preserve">
          <source>Network Address: family</source>
          <target state="translated">网络地址:家庭</target>
        </trans-unit>
        <trans-unit id="6144652f94deb193ec23e96153e939af827c258d" translate="yes" xml:space="preserve">
          <source>Network Address: host</source>
          <target state="translated">网络地址:主机</target>
        </trans-unit>
        <trans-unit id="60b63d4c005ed64503064242e41d8bfa685a802b" translate="yes" xml:space="preserve">
          <source>Network Address: hostmask</source>
          <target state="translated">网络地址:hostmask</target>
        </trans-unit>
        <trans-unit id="ed88700d6440e7a05db8038b5e1ae51130f83f6c" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.0.5&amp;#x27; &amp;lt;&amp;lt; inet &amp;#x27;192.168.1/24&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f03ec2774c64bbb3436fa6566e034e58c68aaf6" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1.43&amp;#x27; - 36</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cd543dd857eb909c7c1f144d1c68cc26ed17c84" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1.43&amp;#x27; - inet &amp;#x27;192.168.1.19&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cba4aae2f54763673ad24c08605a0dc7418f7e69" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1.5&amp;#x27; &amp;lt;&amp;lt; inet &amp;#x27;192.168.1/24&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf25351bf5e670090a9a613676ffca0130707992" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1.6&amp;#x27; &amp;amp; inet &amp;#x27;0.0.0.255&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb861d30d1aca8b8d63e37fc34ab35aac460d1f8" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1.6&amp;#x27; + 25</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47709a664ccb6f4f20ab0bedea8e5350679a1107" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1.6&amp;#x27; | inet &amp;#x27;0.0.0.255&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="538a8494f874e1b3946b7a79168cf4b1aa49a99c" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1/24&amp;#x27; &amp;amp;&amp;amp; inet &amp;#x27;192.168.1.80/28&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b08083b1369b886565f8ea80c8058e2d3af87577" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1/24&amp;#x27; &amp;amp;&amp;amp; inet &amp;#x27;192.168.2.0/28&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b9c76f3500e47f384b3cac60e30dacdb3c47029" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1/24&amp;#x27; &amp;gt;&amp;gt; inet &amp;#x27;192.168.1.5&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5a7912881770eacd62ec019a35b786530ba8e82" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1/24&amp;#x27; &amp;gt;&amp;gt;= inet &amp;#x27;192.168.1/24&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3f515856eebe2d81a6af46f2f540cf2ea72af80" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1/24&amp;#x27; &amp;lt;&amp;lt; inet &amp;#x27;192.168.1/24&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f49b063066e4c4fbd3500c30f240ef74c750c98e" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1/24&amp;#x27; &amp;lt;&amp;lt;= inet &amp;#x27;192.168.1/24&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e5e1d3f81690c06565afe5ca9d8a5a94ccf4f70" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;::1&amp;#x27; - inet &amp;#x27;::ffff:1&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7c102cda170efbd5c926c080194943072fd0080" translate="yes" xml:space="preserve">
          <source>Network Address: inet_merge</source>
          <target state="translated">网络地址:inet_merge</target>
        </trans-unit>
        <trans-unit id="026b427d2abc32061f460f5004b1e92329b176c3" translate="yes" xml:space="preserve">
          <source>Network Address: inet_same_family</source>
          <target state="translated">网络地址:inet_same_family</target>
        </trans-unit>
        <trans-unit id="78246e2d890ea6d8b5a4e72ded75baf6bfea7473" translate="yes" xml:space="preserve">
          <source>Network Address: macaddr8_set7bit</source>
          <target state="translated">网络地址:macaddr8_set7bit</target>
        </trans-unit>
        <trans-unit id="1c089819bd8607b5f9a99695372b4e5df1ae11f3" translate="yes" xml:space="preserve">
          <source>Network Address: masklen</source>
          <target state="translated">网络地址:masklen</target>
        </trans-unit>
        <trans-unit id="e38c25828a5f421b05060a2505734c3b8ed3c4ff" translate="yes" xml:space="preserve">
          <source>Network Address: netmask</source>
          <target state="translated">网络地址:netmask</target>
        </trans-unit>
        <trans-unit id="9e08bb5a4ba97edb3516d3ee46ca743eed995918" translate="yes" xml:space="preserve">
          <source>Network Address: network</source>
          <target state="translated">网络地址:网络</target>
        </trans-unit>
        <trans-unit id="e7c94e499362212c6e5807040cfed09039e1ec82" translate="yes" xml:space="preserve">
          <source>Network Address: set_masklen</source>
          <target state="translated">网络地址:set_masklen</target>
        </trans-unit>
        <trans-unit id="0ec1baf847c109f5d8cc27de72a96ec587a99682" translate="yes" xml:space="preserve">
          <source>Network Address: text</source>
          <target state="translated">网络地址:文本</target>
        </trans-unit>
        <trans-unit id="221efaf6a0e58b3e7e632e503daaffa7a1a069d7" translate="yes" xml:space="preserve">
          <source>Network Address: trunc</source>
          <target state="translated">网络地址:截断</target>
        </trans-unit>
        <trans-unit id="ab7cd2917681a96bc47067425beee2467a73704d" translate="yes" xml:space="preserve">
          <source>Network Address: |</source>
          <target state="translated">网络地址。|</target>
        </trans-unit>
        <trans-unit id="83814dd86a48a4c95e9a2274b66946fe0603b1c9" translate="yes" xml:space="preserve">
          <source>Network Address: ~</source>
          <target state="translated">网络地址:~</target>
        </trans-unit>
        <trans-unit id="103c5dac467afa451157b604c5b1cc764cc21efb" translate="yes" xml:space="preserve">
          <source>Network Address: ~ inet &amp;#x27;192.168.1.6&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a2ec6319838e0ec218c4906d73f925465627945" translate="yes" xml:space="preserve">
          <source>Network address types</source>
          <target state="translated">网络地址类型</target>
        </trans-unit>
        <trans-unit id="424a86543035666947635d11018cbc54c86cb289" translate="yes" xml:space="preserve">
          <source>Never issue a password prompt. If the server requires password authentication and a password is not available by other means such as a &lt;code&gt;.pgpass&lt;/code&gt; file, the connection attempt will fail. This option can be useful in batch jobs and scripts where no user is present to enter a password.</source>
          <target state="translated">切勿发出密码提示。如果服务器要求密码验证，而 &lt;code&gt;.pgpass&lt;/code&gt; 文件等其他方式无法使用密码，则连接尝试将失败。此选项在没有用户输入密码的批处理作业和脚本中很有用。</target>
        </trans-unit>
        <trans-unit id="9093e824038ec1b001eb89049bd2ea01904578a0" translate="yes" xml:space="preserve">
          <source>Never issue a password prompt. If the server requires password authentication and a password is not available from other sources such as a &lt;code&gt;.pgpass&lt;/code&gt; file, the connection attempt will fail. This option can be useful in batch jobs and scripts where no user is present to enter a password.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d783af92d40765554d538ccb5cb29b09817e84f6" translate="yes" xml:space="preserve">
          <source>New OIDs cannot be assigned, though some UUID generators may still work as long as they do not rely on writing new status to the database.</source>
          <target state="translated">不能分配新的OID,尽管一些UUID生成器可能仍然有效,只要它们不依靠向数据库写入新的状态。</target>
        </trans-unit>
        <trans-unit id="1599ff1bdbcb64919583d13e639c6bfaf051dfca" translate="yes" xml:space="preserve">
          <source>New aggregate functions are registered with the &lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt; command. See &lt;a href=&quot;https://www.postgresql.org/docs/12/xaggr.html&quot;&gt;Section 37.12&lt;/a&gt; for more information about writing aggregate functions and the meaning of the transition functions, etc.</source>
          <target state="translated">新的聚合函数使用&lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt;命令注册。有关编写聚合函数以及转换函数的含义等的更多信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/xaggr.html&quot;&gt;第37.12节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5691f2234d0749ef354ef0f06ef7f16ccef71ffc" translate="yes" xml:space="preserve">
          <source>New aggregate functions are registered with the &lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt; command. See &lt;a href=&quot;https://www.postgresql.org/docs/13/xaggr.html&quot;&gt;Section 37.12&lt;/a&gt; for more information about writing aggregate functions and the meaning of the transition functions, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e31c4f5893b955e11ebf06d3912e5da97f70565f" translate="yes" xml:space="preserve">
          <source>New array values can also be constructed using the concatenation operator, &lt;code&gt;||&lt;/code&gt;:</source>
          <target state="translated">还可以使用串联运算符 &lt;code&gt;||&lt;/code&gt; 构造新的数组值。：</target>
        </trans-unit>
        <trans-unit id="98e5f0d308c976c18e3e4b7efffa4995977e2612" translate="yes" xml:space="preserve">
          <source>New domain constraint for the domain.</source>
          <target state="translated">域的新域约束。</target>
        </trans-unit>
        <trans-unit id="796d9d5ad0384fcde7a5cdd2291232f588f72876" translate="yes" xml:space="preserve">
          <source>New leaf pages are added to a B-Tree index when an existing leaf page cannot fit an incoming tuple. A &lt;em&gt;page split&lt;/em&gt; operation makes room for items that originally belonged on the overflowing page by moving a portion of the items to a new page. Page splits must also insert a new &lt;em&gt;downlink&lt;/em&gt; to the new page in the parent page, which may cause the parent to split in turn. Page splits &amp;ldquo;cascade upwards&amp;rdquo; in a recursive fashion. When the root page finally cannot fit a new downlink, a &lt;em&gt;root page split&lt;/em&gt; operation takes place. This adds a new level to the tree structure by creating a new root page that is one level above the original root page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a12c3795c3d4f4819f76dadf3e557565c057892c" translate="yes" xml:space="preserve">
          <source>New libc collations can be created like this:</source>
          <target state="translated">新的libc整理可以这样创建。</target>
        </trans-unit>
        <trans-unit id="650ded8d5d402f503baa0bc831171b9d8bc4272d" translate="yes" xml:space="preserve">
          <source>New major versions also typically introduce some user-visible incompatibilities, so application programming changes might be required. All user-visible changes are listed in the release notes (&lt;a href=&quot;https://www.postgresql.org/docs/12/release.html&quot;&gt;Appendix E&lt;/a&gt;); pay particular attention to the section labeled &quot;Migration&quot;. If you are upgrading across several major versions, be sure to read the release notes for each intervening version.</source>
          <target state="translated">新的主要版本通常还会引入一些用户可见的不兼容性，因此可能需要更改应用程序编程。所有用户可见的更改均在发行说明（&lt;a href=&quot;https://www.postgresql.org/docs/12/release.html&quot;&gt;附录E&lt;/a&gt;）中列出；请特别注意标有&amp;ldquo;迁移&amp;rdquo;的部分。如果要跨多个主要版本进行升级，请确保阅读每个中间版本的发行说明。</target>
        </trans-unit>
        <trans-unit id="48e034a875ce9ccd77246027f6e0993adbe610b3" translate="yes" xml:space="preserve">
          <source>New major versions also typically introduce some user-visible incompatibilities, so application programming changes might be required. All user-visible changes are listed in the release notes (&lt;a href=&quot;https://www.postgresql.org/docs/13/release.html&quot;&gt;Appendix E&lt;/a&gt;); pay particular attention to the section labeled &quot;Migration&quot;. If you are upgrading across several major versions, be sure to read the release notes for each intervening version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a56ea799e1817e77cfb14f705f9837d87da3531d" translate="yes" xml:space="preserve">
          <source>New name for an existing column.</source>
          <target state="translated">现有列的新名称。</target>
        </trans-unit>
        <trans-unit id="b258c013a0b2baff94eb0ca18fab582791cfc317" translate="yes" xml:space="preserve">
          <source>New name for the table.</source>
          <target state="translated">该表的新名称。</target>
        </trans-unit>
        <trans-unit id="e2584f9de9d6b68e373738ded405b0367bf25369" translate="yes" xml:space="preserve">
          <source>New probes can be defined within the code wherever the developer desires, though this will require a recompilation. Below are the steps for inserting new probes:</source>
          <target state="translated">新的探针可以在代码中的任何地方被定义,尽管这将需要重新编译。以下是插入新探针的步骤。</target>
        </trans-unit>
        <trans-unit id="9bb5261862459d4fc2f236436c680944b53b22bf" translate="yes" xml:space="preserve">
          <source>New row</source>
          <target state="translated">新行</target>
        </trans-unit>
        <trans-unit id="b1955e711ad4344c38fc8ef166f89eecc1ca6dce" translate="yes" xml:space="preserve">
          <source>New row &lt;a href=&quot;#ftn.RLS-SELECT-PRIV&quot;&gt;&lt;sup id=&quot;RLS-SELECT-PRIV&quot;&gt;[a]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">新行&lt;a href=&quot;#ftn.RLS-SELECT-PRIV&quot;&gt;&lt;sup id=&quot;RLS-SELECT-PRIV&quot;&gt;[a]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="45bbeac915cddbd627fa355d4df5b9dbbc9336c8" translate="yes" xml:space="preserve">
          <source>New rows are checked against the conditions of the view and all underlying base views. If the &lt;code&gt;CHECK OPTION&lt;/code&gt; is specified, and neither &lt;code&gt;LOCAL&lt;/code&gt; nor &lt;code&gt;CASCADED&lt;/code&gt; is specified, then &lt;code&gt;CASCADED&lt;/code&gt; is assumed.</source>
          <target state="translated">将根据视图和所有基础视图的条件检查新行。如果指定了 &lt;code&gt;CHECK OPTION&lt;/code&gt; ，并且未指定 &lt;code&gt;LOCAL&lt;/code&gt; 或 &lt;code&gt;CASCADED&lt;/code&gt; ，则假定为 &lt;code&gt;CASCADED&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08a4db17fa684c55666b397d42c621a7aaca8bcb" translate="yes" xml:space="preserve">
          <source>New rows are only checked against the conditions defined directly in the view itself. Any conditions defined on underlying base views are not checked (unless they also specify the &lt;code&gt;CHECK OPTION&lt;/code&gt;).</source>
          <target state="translated">仅对照直接在视图本身中定义的条件检查新行。不会检查在基础基本视图上定义的任何条件（除非它们还指定 &lt;code&gt;CHECK OPTION&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0fffd55cc966a5c918570729a73087e9799e7b21" translate="yes" xml:space="preserve">
          <source>New server version.</source>
          <target state="translated">新的服务器版本。</target>
        </trans-unit>
        <trans-unit id="326bf78cdc5261237c497696e2f88d3bf937ac51" translate="yes" xml:space="preserve">
          <source>New table constraint for the foreign table.</source>
          <target state="translated">外表的新表约束。</target>
        </trans-unit>
        <trans-unit id="c7fc18feb54e6ecc777a74b8dce9c763304724d3" translate="yes" xml:space="preserve">
          <source>New table constraint for the table.</source>
          <target state="translated">表的新表约束。</target>
        </trans-unit>
        <trans-unit id="0ef8f5b2618f8741358d2dc6f311e26c77d17c09" translate="yes" xml:space="preserve">
          <source>New value of parameter. Values can be specified as string constants, identifiers, numbers, or comma-separated lists of these, as appropriate for the particular parameter. &lt;code&gt;DEFAULT&lt;/code&gt; can be written to specify resetting the parameter to its default value (that is, whatever value it would have had if no &lt;code&gt;SET&lt;/code&gt; had been executed in the current session).</source>
          <target state="translated">参数的新值。可以将值指定为字符串常量，标识符，数字或以逗号分隔的列表（视具体参数而定）。可以编写 &lt;code&gt;DEFAULT&lt;/code&gt; 以指定将参数重置为其默认值（即，如果在当前会话中未执行 &lt;code&gt;SET&lt;/code&gt; 的话，它将具有的值）。</target>
        </trans-unit>
        <trans-unit id="74ad18207dee0729707d6021134389a09abbbcf4" translate="yes" xml:space="preserve">
          <source>New value of the parameter. Values can be specified as string constants, identifiers, numbers, or comma-separated lists of these, as appropriate for the particular parameter. &lt;code&gt;DEFAULT&lt;/code&gt; can be written to specify removing the parameter and its value from &lt;code&gt;postgresql.auto.conf&lt;/code&gt;.</source>
          <target state="translated">参数的新值。可以将值指定为字符串常量，标识符，数字或以逗号分隔的列表（视具体参数而定）。可以编写 &lt;code&gt;DEFAULT&lt;/code&gt; 来指定从 &lt;code&gt;postgresql.auto.conf&lt;/code&gt; 中删除参数及其值。</target>
        </trans-unit>
        <trans-unit id="3f73bcda4d00edad798e144ba44c98c20a80aa1b" translate="yes" xml:space="preserve">
          <source>Newer operating systems may check for the known TSC problems and switch to a slower, more stable clock source when they are seen. If your system supports TSC time but doesn't default to that, it may be disabled for a good reason. And some operating systems may not detect all the possible problems correctly, or will allow using TSC even in situations where it's known to be inaccurate.</source>
          <target state="translated">新的操作系统可能会检查已知的TSC问题,并在看到这些问题时切换到更慢、更稳定的时钟源。如果你的系统支持TSC时间,但没有默认使用,那么它可能会因为一个很好的理由而被禁用。而有些操作系统可能不会正确检测所有可能的问题,或者即使在已知TSC不准确的情况下,也会允许使用TSC。</target>
        </trans-unit>
        <trans-unit id="91613c0496c344d2d60b757f74e45fc5cc402ce3" translate="yes" xml:space="preserve">
          <source>Newline (ASCII 10)</source>
          <target state="translated">新行(ASCII 10)</target>
        </trans-unit>
        <trans-unit id="abcfe34ad9620d6f4bc03407b5ef1c1c15fc3d23" translate="yes" xml:space="preserve">
          <source>Newlines are inserted between fields as needed to limit line length to 80 characters, if possible. A newline is also inserted between the metadata fields and the regular fields.</source>
          <target state="translated">根据需要在字段之间插入新行,尽可能将行长限制在80个字符以内。元数据字段和常规字段之间也插入一个新行。</target>
        </trans-unit>
        <trans-unit id="bc981983e7f547dc62e19a1e383acfe00782a6d5" translate="yes" xml:space="preserve">
          <source>Next</source>
          <target state="translated">Next</target>
        </trans-unit>
        <trans-unit id="668d132684646785e22fe1441b80ce3d2edabbcd" translate="yes" xml:space="preserve">
          <source>Next field is Julian Date</source>
          <target state="translated">下一栏是Julian日期</target>
        </trans-unit>
        <trans-unit id="b894f41f03f11b1ed4f8f278b45d31b30d6d7e9d" translate="yes" xml:space="preserve">
          <source>Next field is time</source>
          <target state="translated">下一个字段是时间</target>
        </trans-unit>
        <trans-unit id="8bbd06fda45074a003115cb92bcdeae70e3776f1" translate="yes" xml:space="preserve">
          <source>Next let's consider an example with an equality condition in its &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="translated">接下来，让我们考虑一个在其 &lt;code&gt;WHERE&lt;/code&gt; 子句中具有相等条件的示例：</target>
        </trans-unit>
        <trans-unit id="0accafa67ae47755f44a4c829c06920cf375701d" translate="yes" xml:space="preserve">
          <source>Next the fraction of the histogram occupied by &amp;ldquo;&amp;lt; 1000&amp;rdquo; is worked out. This is the selectivity. The histogram divides the range into equal frequency buckets, so all we have to do is locate the bucket that our value is in and count &lt;em&gt;part&lt;/em&gt; of it and &lt;em&gt;all&lt;/em&gt; of the ones before. The value 1000 is clearly in the second bucket (993&amp;ndash;1997). Assuming a linear distribution of values inside each bucket, we can calculate the selectivity as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ed06150c503b0381101da4c9e29738d8aede6e0" translate="yes" xml:space="preserve">
          <source>Next the fraction of the histogram occupied by &amp;ldquo;&amp;lt; 1000&amp;rdquo; is worked out. This is the selectivity. The histogram divides the range into equal frequency buckets, so all we have to do is locate the bucket that our value is in and count &lt;em&gt;part&lt;/em&gt; of it and &lt;em&gt;all&lt;/em&gt; of the ones before. The value 1000 is clearly in the second bucket (993-1997). Assuming a linear distribution of values inside each bucket, we can calculate the selectivity as:</source>
          <target state="translated">接下来，计算出直方图中&amp;ldquo; &amp;lt;1000&amp;rdquo;所占的比例。这就是选择性。直方图将范围划分为相等频率的存储桶，因此我们要做的就是找到我们的值所在的存储桶，并对其中的&lt;em&gt;一部分&lt;/em&gt;以及&lt;em&gt;所有&lt;/em&gt;之前的&lt;em&gt;部分&lt;/em&gt;进行计数。值1000显然在第二个存储桶（993-1997）中。假设每个值在每个存储桶中呈线性分布，我们可以将选择性计算为：</target>
        </trans-unit>
        <trans-unit id="5e15fe544e0817c8abcd5bf63590f065c8fda5e8" translate="yes" xml:space="preserve">
          <source>Next we register the Ispell dictionary &lt;code&gt;english_ispell&lt;/code&gt;, which has its own configuration files:</source>
          <target state="translated">接下来，我们注册Ispell字典 &lt;code&gt;english_ispell&lt;/code&gt; ，它具有自己的配置文件：</target>
        </trans-unit>
        <trans-unit id="5d2e580901bf6290e8151d5811cdef90838e8edb" translate="yes" xml:space="preserve">
          <source>Next, &lt;code&gt;pg_verifybackup&lt;/code&gt; will checksum all the files, compare the checksums against the values in the manifest, and emit errors for any files for which the computed checksum does not match the checksum stored in the manifest. This step is not performed for any files which produced errors in the previous step, since they are already known to have problems. Files which were ignored in the previous step are also ignored in this step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdb6f7d3081e6797875cb41a13e6c45a3f761bbf" translate="yes" xml:space="preserve">
          <source>Next, create a trigram index on the word column:</source>
          <target state="translated">接下来,在词列上创建一个卦象索引。</target>
        </trans-unit>
        <trans-unit id="d9e892095e44895492c517f24015243e155c5a35" translate="yes" xml:space="preserve">
          <source>Next, there might be a cache in the disk drive controller; this is particularly common on RAID controller cards. Some of these caches are &lt;em&gt;write-through&lt;/em&gt;, meaning writes are sent to the drive as soon as they arrive. Others are &lt;em&gt;write-back&lt;/em&gt;, meaning data is sent to the drive at some later time. Such caches can be a reliability hazard because the memory in the disk controller cache is volatile, and will lose its contents in a power failure. Better controller cards have &lt;em&gt;battery-backup units&lt;/em&gt; (BBUs), meaning the card has a battery that maintains power to the cache in case of system power loss. After power is restored the data will be written to the disk drives.</source>
          <target state="translated">接下来，磁盘驱动器控制器中可能存在高速缓存；这在RAID控制器卡上尤其常见。这些缓存中的一些是&lt;em&gt;直写式的&lt;/em&gt;，这意味着写入一旦到达就发送到驱动器。其他是&lt;em&gt;回写的&lt;/em&gt;，这意味着数据稍后会发送到驱动器。由于磁盘控制器高速缓存中的内存易失，并且在电源故障时会丢失其内容，因此此类高速缓存可能会造成可靠性危害。更好的控制器卡具有&lt;em&gt;电池备份单元&lt;/em&gt;（BBU），这意味着该卡具有一个电池，可以在系统断电时为高速缓存供电。恢复电源后，数据将被写入磁盘驱动器。</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="ab63ab43b9cd6b9423e3548d5b6495e55251533e" translate="yes" xml:space="preserve">
          <source>No background workers can be obtained because of the limitation that the total number of background workers cannot exceed &lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt;.</source>
          <target state="translated">由于后台工作者的总数不能超过&lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt;的限制，因此无法获得后台工作者。</target>
        </trans-unit>
        <trans-unit id="1db509e223519bbbe9c20165e8b19fc16220b41f" translate="yes" xml:space="preserve">
          <source>No background workers can be obtained because of the limitation that the total number of background workers launched for purposes of parallel query cannot exceed &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS&quot;&gt;max_parallel_workers&lt;/a&gt;.</source>
          <target state="translated">由于存在以下限制，因此无法获得后台工作程序：为并行查询目的而启动的后台工作程序总数不能超过&lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS&quot;&gt;max_parallel_workers&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="737fbf99fcaacc1c750aa9911a89ba763b4fb6c2" translate="yes" xml:space="preserve">
          <source>No conflict resolution necessary</source>
          <target state="translated">不需要解决冲突</target>
        </trans-unit>
        <trans-unit id="c4ae42341e7948bd6be9068db7f6b708eab0516f" translate="yes" xml:space="preserve">
          <source>No direct modifications of buffers are allowed! All modifications must be done in copies acquired from &lt;code&gt;GenericXLogRegisterBuffer()&lt;/code&gt;. In other words, code that makes generic WAL records should never call &lt;code&gt;BufferGetPage()&lt;/code&gt; for itself. However, it remains the caller's responsibility to pin/unpin and lock/unlock the buffers at appropriate times. Exclusive lock must be held on each target buffer from before &lt;code&gt;GenericXLogRegisterBuffer()&lt;/code&gt; until after &lt;code&gt;GenericXLogFinish()&lt;/code&gt;.</source>
          <target state="translated">不允许直接修改缓冲区！所有修改都必须在从 &lt;code&gt;GenericXLogRegisterBuffer()&lt;/code&gt; 获取的副本中完成。换句话说，进行通用WAL记录的代码永远不要为其本身调用 &lt;code&gt;BufferGetPage()&lt;/code&gt; 。但是，调用者仍然有责任在适当的时候锁定/解锁并锁定/解锁缓冲区。从 &lt;code&gt;GenericXLogRegisterBuffer()&lt;/code&gt; 之前到 &lt;code&gt;GenericXLogFinish()&lt;/code&gt; 之后，必须在每个目标缓冲区上保留排他锁。</target>
        </trans-unit>
        <trans-unit id="59fe225d3b68631dd2336d2bf5588427b3b21997" translate="yes" xml:space="preserve">
          <source>No error concerning corruption raised by &lt;code&gt;amcheck&lt;/code&gt; should ever be a false positive. &lt;code&gt;amcheck&lt;/code&gt; raises errors in the event of conditions that, by definition, should never happen, and so careful analysis of &lt;code&gt;amcheck&lt;/code&gt; errors is often required.</source>
          <target state="translated">关于 &lt;code&gt;amcheck&lt;/code&gt; 引起的腐败的任何错误都不应为假阳性。如果根据定义永远都不会发生条件，则 &lt;code&gt;amcheck&lt;/code&gt; 会引发错误，因此经常需要仔细分析 &lt;code&gt;amcheck&lt;/code&gt; 错误。</target>
        </trans-unit>
        <trans-unit id="3b39fb69a71692aa8fa18d1717c1f94f66adfcdf" translate="yes" xml:space="preserve">
          <source>No master server overhead</source>
          <target state="translated">无主服务器开销</target>
        </trans-unit>
        <trans-unit id="69d7c6fd29e6141d46559276ef0d0824b8ca6117" translate="yes" xml:space="preserve">
          <source>No more than 256 positions per lexeme</source>
          <target state="translated">每个词素不超过256个位置。</target>
        </trans-unit>
        <trans-unit id="d6105567c57e07dede5d4075af64116a14eb0b4d" translate="yes" xml:space="preserve">
          <source>No particular limit is imposed on the length of REs in this implementation. However, programs intended to be highly portable should not employ REs longer than 256 bytes, as a POSIX-compliant implementation can refuse to accept such REs.</source>
          <target state="translated">在这个实现中,对REs的长度没有特别的限制,但是,旨在高度可移植的程序不应该使用超过256字节的REs,因为POSIX兼容的实现可能会拒绝接受这种REs。然而,旨在高度可移植的程序不应使用超过256字节的RE,因为符合POSIX标准的实现可能拒绝接受这样的RE。</target>
        </trans-unit>
        <trans-unit id="b403c7e51ec107180064180093a27a248cb9fcae" translate="yes" xml:space="preserve">
          <source>No special action is taken at the ends of transactions. This is the default behavior.</source>
          <target state="translated">在交易结束时不采取任何特殊行动。这是默认行为。</target>
        </trans-unit>
        <trans-unit id="61fdd0ee1a0e012e017d3d0ae54de832b57200e8" translate="yes" xml:space="preserve">
          <source>No special hardware required</source>
          <target state="translated">无需特殊硬件</target>
        </trans-unit>
        <trans-unit id="ae79014d45aed5cbc3110d3674ce8fdfb2183d69" translate="yes" xml:space="preserve">
          <source>No support for encryption key as master key. As such practice is generally discouraged, this should not be a problem.</source>
          <target state="translated">不支持将加密密钥作为主密钥。由于一般不鼓励这种做法,这应该不是问题。</target>
        </trans-unit>
        <trans-unit id="8c30a7a5188f10c0ac8624ba81f5e723c5467bcf" translate="yes" xml:space="preserve">
          <source>No support for several subkeys. This may seem like a problem, as this is common practice. On the other hand, you should not use your regular GPG/PGP keys with &lt;code&gt;pgcrypto&lt;/code&gt;, but create new ones, as the usage scenario is rather different.</source>
          <target state="translated">不支持几个子项。这似乎是一个问题，因为这是常见的做法。另一方面，您不应将常规GPG / PGP密钥与 &lt;code&gt;pgcrypto&lt;/code&gt; 一起使用，而应创建新的GPG / PGP密钥，因为使用情况非常不同。</target>
        </trans-unit>
        <trans-unit id="c9435d4dd42a8ebc8de1b106f0a226340aa75454" translate="yes" xml:space="preserve">
          <source>No support for signing. That also means that it is not checked whether the encryption subkey belongs to the master key.</source>
          <target state="translated">不支持签名。也就是不检查加密子密钥是否属于主密钥。</target>
        </trans-unit>
        <trans-unit id="c0ba19704438347e67d6c41db6384452ae2aa5a4" translate="yes" xml:space="preserve">
          <source>No waiting for multiple servers</source>
          <target state="translated">无需等待多个服务器</target>
        </trans-unit>
        <trans-unit id="4b6d8042bc7e3d0b0614251a34971ce673127f09" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;C&lt;/code&gt; and non-&lt;code&gt;POSIX&lt;/code&gt; locales rely on the operating system's collation library for character set ordering. This controls the ordering of keys stored in indexes. For this reason, a cluster cannot switch to an incompatible collation library version, either through snapshot restore, binary streaming replication, a different operating system, or an operating system upgrade.</source>
          <target state="translated">非 &lt;code&gt;C&lt;/code&gt; 和非 &lt;code&gt;POSIX&lt;/code&gt; 语言环境依赖于操作系统的归类库来进行字符集排序。这控制了存储在索引中的键的顺序。因此，群集无法通过快照还原，二进制流复制，其他操作系统或操作系统升级切换到不兼容的归类库版本。</target>
        </trans-unit>
        <trans-unit id="b791053ba5b378d8e57979f3c97566be063ef0d0" translate="yes" xml:space="preserve">
          <source>Non-Deferred Uniqueness Constraints</source>
          <target state="translated">非递延的唯一性约束</target>
        </trans-unit>
        <trans-unit id="2edd532d90e9a265b3d587446d10683f0ddb82ba" translate="yes" xml:space="preserve">
          <source>Non-Durable Settings</source>
          <target state="translated">非耐久性设置</target>
        </trans-unit>
        <trans-unit id="1606d825faba4ca859c553032bca97393df353c3" translate="yes" xml:space="preserve">
          <source>Non-absolute directory names are taken as relative to the directory containing the referencing configuration file. Within the specified directory, only non-directory files whose names end with the suffix &lt;code&gt;.conf&lt;/code&gt; will be included. File names that start with the &lt;code&gt;.&lt;/code&gt; character are also ignored, to prevent mistakes since such files are hidden on some platforms. Multiple files within an include directory are processed in file name order (according to C locale rules, i.e. numbers before letters, and uppercase letters before lowercase ones).</source>
          <target state="translated">非绝对目录名被视为相对于包含引用配置文件的目录。在指定目录内，仅包含名称后缀为 &lt;code&gt;.conf&lt;/code&gt; 的非目录文件。以开头的文件名 &lt;code&gt;.&lt;/code&gt; 字符也将被忽略，以防止出错，因为此类文件在某些​​平台上是隐藏的。包含目录中的多个文件按文件名顺序处理（根据C语言环境规则，即字母前的数字和小写字母前的大写字母）。</target>
        </trans-unit>
        <trans-unit id="375e6f9829aa08a22fb91bd89b1b288cc7a6547e" translate="yes" xml:space="preserve">
          <source>Non-absolute directory names are taken as relative to the directory containing the referencing configuration file. Within the specified directory, only non-directory files whose names end with the suffix &lt;code&gt;.conf&lt;/code&gt; will be included. File names that start with the &lt;code&gt;.&lt;/code&gt; character are also ignored, to prevent mistakes since such files are hidden on some platforms. Multiple files within an include directory are processed in file name order (according to C locale rules, i.e., numbers before letters, and uppercase letters before lowercase ones).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0daa9d12e18919b30fa114566dbfc8fde09c52f" translate="yes" xml:space="preserve">
          <source>Non-equality comparison</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="005bf64a001e88d6c5954633016b2d70a8916d20" translate="yes" xml:space="preserve">
          <source>Non-equality operator</source>
          <target state="translated">非等式运算符</target>
        </trans-unit>
        <trans-unit id="5d6b03babc67eb26f4a561798892e8e1d042f8b8" translate="yes" xml:space="preserve">
          <source>Non-equality operator (same as &lt;code&gt;!=&lt;/code&gt;)</source>
          <target state="translated">非等号运算符（与 &lt;code&gt;!=&lt;/code&gt; 相同）</target>
        </trans-unit>
        <trans-unit id="20c0da4f56e91a8e794e8ad5b40aa2db7a25e473" translate="yes" xml:space="preserve">
          <source>Non-schema objects such as blobs are not dumped when &lt;code&gt;-n&lt;/code&gt; is specified. You can add blobs back to the dump with the &lt;code&gt;--blobs&lt;/code&gt; switch.</source>
          <target state="translated">指定 &lt;code&gt;-n&lt;/code&gt; 时，不转储非模式对象（例如blob）。您可以使用 &lt;code&gt;--blobs&lt;/code&gt; 开关将blob添加回转储。</target>
        </trans-unit>
        <trans-unit id="9caf6bd6e45fde8300143ee2bd8d45d380012859" translate="yes" xml:space="preserve">
          <source>Non-standard syntax for &lt;code&gt;trim()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;trim()&lt;/code&gt; 的非标准语法</target>
        </trans-unit>
        <trans-unit id="1b82aac77684b2e34b968be8bab3328cdefd6c87" translate="yes" xml:space="preserve">
          <source>Non-superusers can only apply &lt;code&gt;LOAD&lt;/code&gt; to library files located in &lt;code&gt;$libdir/plugins/&lt;/code&gt; &amp;mdash; the specified &lt;code&gt;filename&lt;/code&gt; must begin with exactly that string. (It is the database administrator's responsibility to ensure that only &amp;ldquo;safe&amp;rdquo; libraries are installed there.)</source>
          <target state="translated">非超级用户只能将 &lt;code&gt;LOAD&lt;/code&gt; 应用于 &lt;code&gt;$libdir/plugins/&lt;/code&gt; 库文件-指定的 &lt;code&gt;filename&lt;/code&gt; 必须以该字符串开头。（数据库管理员有责任确保在那里仅安装&amp;ldquo;安全&amp;rdquo;库。）</target>
        </trans-unit>
        <trans-unit id="33362508c287b322946b88bcd446c4aed0b4f943" translate="yes" xml:space="preserve">
          <source>Non-zero values of this setting add overhead, as PostgreSQL will need to store textual representations of parameter values in memory at the start of each statement, whether or not an error eventually occurs. The overhead is greater when bind parameters are sent in binary form than when they are sent as text, since the former case requires data conversion while the latter only requires copying the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdcf35d8373c6ae03dbb38620bdfe970a151c4ed" translate="yes" xml:space="preserve">
          <source>Nondeterministic collations are only supported with the ICU provider.</source>
          <target state="translated">非确定性整理只支持与ICU提供者。</target>
        </trans-unit>
        <trans-unit id="592caa46c1febc51d4ba97d3f0cb331e0f251855" translate="yes" xml:space="preserve">
          <source>Nonrepeatable Read</source>
          <target state="translated">不可重复阅读</target>
        </trans-unit>
        <trans-unit id="4cd9a0397eea6fedc043bb59b16fdf2f16c3bc14" translate="yes" xml:space="preserve">
          <source>Nonstandard Clauses</source>
          <target state="translated">非标准条款</target>
        </trans-unit>
        <trans-unit id="d10c40965cecc5427a7ccc11e532baca90682092" translate="yes" xml:space="preserve">
          <source>Nordic</source>
          <target state="translated">Nordic</target>
        </trans-unit>
        <trans-unit id="5d192ac91d079d3947c34df6ca0da6af270cb95a" translate="yes" xml:space="preserve">
          <source>Normal cursors return data in text format, the same as a &lt;code&gt;SELECT&lt;/code&gt; would produce. The &lt;code&gt;BINARY&lt;/code&gt; option specifies that the cursor should return data in binary format. This reduces conversion effort for both the server and client, at the cost of more programmer effort to deal with platform-dependent binary data formats. As an example, if a query returns a value of one from an integer column, you would get a string of &lt;code&gt;1&lt;/code&gt; with a default cursor, whereas with a binary cursor you would get a 4-byte field containing the internal representation of the value (in big-endian byte order).</source>
          <target state="translated">普通游标以文本格式返回数据，与 &lt;code&gt;SELECT&lt;/code&gt; 会产生相同的结果。该 &lt;code&gt;BINARY&lt;/code&gt; 选项指定光标应该在返回二进制格式。这减少了服务器和客户端的转换工作，但以程序员更多的精力来处理依赖于平台的二进制数据格式为代价。例如，如果查询从整数列返回值1，则将使用默认游标获得字符串 &lt;code&gt;1&lt;/code&gt; ，而使用二进制游标将获得包含该值的内部表示形式的4字节字段（以大端字节序）。</target>
        </trans-unit>
        <trans-unit id="e719f066c8f80c3d098dc0de105e52604edf52bd" translate="yes" xml:space="preserve">
          <source>Normally a copy of &lt;code&gt;pg_type.typstorage&lt;/code&gt; of this column's type. For TOAST-able data types, this can be altered after column creation to control storage policy.</source>
          <target state="translated">通常，此列类型的 &lt;code&gt;pg_type.typstorage&lt;/code&gt; 的副本。对于可TOAST的数据类型，可以在创建列之后更改此设置以控制存储策略。</target>
        </trans-unit>
        <trans-unit id="dfefa02592536f045045c313a59b93cf3ea4a182" translate="yes" xml:space="preserve">
          <source>Normally it is better to start &lt;code&gt;postgres&lt;/code&gt; in the background. For this, use the usual Unix shell syntax:</source>
          <target state="translated">通常，最好在后台启动 &lt;code&gt;postgres&lt;/code&gt; 。为此，请使用通常的Unix Shell语法：</target>
        </trans-unit>
        <trans-unit id="eb15db27354b906033434be491a2ae185754105d" translate="yes" xml:space="preserve">
          <source>Normally the set of partitions established when initially defining the table are not intended to remain static. It is common to want to remove old partitions of data and periodically add new partitions for new data. One of the most important advantages of partitioning is precisely that it allows this otherwise painful task to be executed nearly instantaneously by manipulating the partition structure, rather than physically moving large amounts of data around.</source>
          <target state="translated">通常情况下,最初定义表时建立的一组分区不打算保持静态。通常希望删除旧的数据分区,并定期为新数据添加新的分区。分区的一个最重要的优点恰恰是,它可以通过操作分区结构,而不是物理地移动大量数据,使这一原本痛苦的任务几乎可以瞬间执行。</target>
        </trans-unit>
        <trans-unit id="fe2f8f91b212090479c992426f90bbd96089fce0" translate="yes" xml:space="preserve">
          <source>Normally the set of partitions established when initially defining the table is not intended to remain static. It is common to want to remove old partitions of data and periodically add new partitions for new data. One of the most important advantages of partitioning is precisely that it allows this otherwise painful task to be executed nearly instantaneously by manipulating the partition structure, rather than physically moving large amounts of data around.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85e1a3935578c6fbceb8f9dfc1ec7edf36d93788" translate="yes" xml:space="preserve">
          <source>Normally there is one entry, with &lt;code&gt;stainherit&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt;, for each table column that has been analyzed. If the table has inheritance children, a second entry with &lt;code&gt;stainherit&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt; is also created. This row represents the column's statistics over the inheritance tree, i.e., statistics for the data you'd see with &lt;code&gt;SELECT column FROM table*&lt;/code&gt;, whereas the &lt;code&gt;stainherit&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; row represents the results of &lt;code&gt;SELECT column FROM ONLY table&lt;/code&gt;.</source>
          <target state="translated">通常，对于每个已分析的表列，只有一个条目， &lt;code&gt;stainherit&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; 。如果表具有继承子级，则还将创建第二个条目带有 &lt;code&gt;stainherit&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt; 。此行表示该列在继承树上的统计信息，即使用 &lt;code&gt;SELECT column FROM table*&lt;/code&gt; 看到的数据的统计信息，而 &lt;code&gt;stainherit&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; 行表示 &lt;code&gt;SELECT column FROM ONLY table&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="ef0a797677cd4cd7010abb5ff69a6286820deaa9" translate="yes" xml:space="preserve">
          <source>Normally these parameters are set in &lt;code&gt;postgresql.conf&lt;/code&gt; so that they apply to all server processes, but it is possible to turn them on or off in individual sessions using the &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; command. (To prevent ordinary users from hiding their activity from the administrator, only superusers are allowed to change these parameters with &lt;code&gt;SET&lt;/code&gt;.)</source>
          <target state="translated">通常，这些参数是在 &lt;code&gt;postgresql.conf&lt;/code&gt; 中设置的，以便将它们应用于所有服务器进程，但是可以使用&lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt;命令在单个会话中打开或关闭它们。 （为防止普通用户向管理员隐藏活动，仅允许超级用户使用 &lt;code&gt;SET&lt;/code&gt; 更改这些参数。）</target>
        </trans-unit>
        <trans-unit id="defa435e9220700a95afbba17bf09c1d280dc0dd" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;EXPLAIN&lt;/code&gt; will display every plan node created by the planner. However, there are cases where the executor can determine that certain nodes need not be executed because they cannot produce any rows, based on parameter values that were not available at planning time. (Currently this can only happen for child nodes of an Append or MergeAppend node that is scanning a partitioned table.) When this happens, those plan nodes are omitted from the &lt;code&gt;EXPLAIN&lt;/code&gt; output and a &lt;code&gt;Subplans Removed: N&lt;/code&gt; annotation appears instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="059b752177da2be76f272de074908dfea33c9049" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;VACUUM&lt;/code&gt; will skip pages based on the &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-VISIBILITY-MAP&quot;&gt;visibility map&lt;/a&gt;. Pages where all tuples are known to be frozen can always be skipped, and those where all tuples are known to be visible to all transactions may be skipped except when performing an aggressive vacuum. Furthermore, except when performing an aggressive vacuum, some pages may be skipped in order to avoid waiting for other sessions to finish using them. This option disables all page-skipping behavior, and is intended to be used only when the contents of the visibility map are suspect, which should happen only if there is a hardware or software issue causing database corruption.</source>
          <target state="translated">通常， &lt;code&gt;VACUUM&lt;/code&gt; 将基于&lt;a href=&quot;routine-vacuuming#VACUUM-FOR-VISIBILITY-MAP&quot;&gt;可见性图&lt;/a&gt;跳过页面。可以跳过通常已知所有元组都已冻结的页面，而可以知道所有元组对于所有事务可见的页面都可以跳过，除非执行主动清除。此外，除了进行主动清理外，某些页面可能会被跳过，以避免等待其他会话结束使用它们。该选项禁用所有页面跳过行为，仅在怀疑可见性地图的内容时才使用，仅当存在导致数据库损坏的硬件或软件问题时才应使用此选项。</target>
        </trans-unit>
        <trans-unit id="5a28b92dedca807b45d1375cda7834475db13842" translate="yes" xml:space="preserve">
          <source>Normally, a database session will read a dictionary configuration file only once, when it is first used within the session. If you modify a configuration file and want to force existing sessions to pick up the new contents, issue an &lt;code&gt;ALTER TEXT SEARCH DICTIONARY&lt;/code&gt; command on the dictionary. This can be a &amp;ldquo;dummy&amp;rdquo; update that doesn't actually change any parameter values.</source>
          <target state="translated">通常，数据库会话在会话中首次使用时，只会读取一次字典配置文件。如果您修改配置文件并希望强制现有会话使用新内容，请在字典上发出 &lt;code&gt;ALTER TEXT SEARCH DICTIONARY&lt;/code&gt; 命令。这可能是&amp;ldquo;虚拟&amp;rdquo;更新，实际上并未更改任何参数值。</target>
        </trans-unit>
        <trans-unit id="8bffa790046f833c87fae190fc13aecca45c4acb" translate="yes" xml:space="preserve">
          <source>Normally, a referencing row need not satisfy the foreign key constraint if any of its referencing columns are null. If &lt;code&gt;MATCH FULL&lt;/code&gt; is added to the foreign key declaration, a referencing row escapes satisfying the constraint only if all its referencing columns are null (so a mix of null and non-null values is guaranteed to fail a &lt;code&gt;MATCH FULL&lt;/code&gt; constraint). If you don't want referencing rows to be able to avoid satisfying the foreign key constraint, declare the referencing column(s) as &lt;code&gt;NOT NULL&lt;/code&gt;.</source>
          <target state="translated">通常，如果引用行的任何引用列为null，则不必满足外键约束。如果将 &lt;code&gt;MATCH FULL&lt;/code&gt; 添加到外键声明中，则仅当其所有引用列都为null时，引用行才能满足约束条件（因此，保证将null和non-null值混合使用将不会使 &lt;code&gt;MATCH FULL&lt;/code&gt; 约束失效）。如果您不希望引用行能够避免满足外键约束，则将引用列声明为 &lt;code&gt;NOT NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a73d6e4c0676c9748a26df54015a17cf72960f1a" translate="yes" xml:space="preserve">
          <source>Normally, psql will dispatch a SQL command to the server as soon as it reaches the command-ending semicolon, even if more input remains on the current line. Thus for example entering</source>
          <target state="translated">通常情况下,psql一旦到达命令结尾的分号处,就会向服务器发送一条SQL命令,即使当前行还有更多的输入。因此,例如输入</target>
        </trans-unit>
        <trans-unit id="c995fea5a35dfbddf38f7ea21e264f8ae6030a27" translate="yes" xml:space="preserve">
          <source>Normally, recovery will proceed through all available WAL segments, thereby restoring the database to the current point in time (or as close as possible given the available WAL segments). Therefore, a normal recovery will end with a &amp;ldquo;file not found&amp;rdquo; message, the exact text of the error message depending upon your choice of &lt;code&gt;restore_command&lt;/code&gt;. You may also see an error message at the start of recovery for a file named something like &lt;code&gt;00000001.history&lt;/code&gt;. This is also normal and does not indicate a problem in simple recovery situations; see &lt;a href=&quot;continuous-archiving#BACKUP-TIMELINES&quot;&gt;Section 25.3.5&lt;/a&gt; for discussion.</source>
          <target state="translated">通常，恢复将在所有可用的WAL段中进行，从而将数据库还原到当前时间点（或在可用的WAL段中尽可能接近）。因此，正常恢复将以&amp;ldquo;找不到文件&amp;rdquo;消息结束，错误消息的确切文本取决于您选择的 &lt;code&gt;restore_command&lt;/code&gt; 。您还可能在恢复开始时看到名为 &lt;code&gt;00000001.history&lt;/code&gt; 之类的文件的错误消息。这也是正常现象，在简单的恢复情况下并不表示有问题；有关讨论，请参见&lt;a href=&quot;continuous-archiving#BACKUP-TIMELINES&quot;&gt;第25.3.5节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="991460ee5abf98bebd31fd08e1871d36222f94b0" translate="yes" xml:space="preserve">
          <source>Normally, the database user who executes this command becomes the owner of the new database. However, a different owner can be specified via the &lt;code&gt;-O&lt;/code&gt; option, if the executing user has appropriate privileges.</source>
          <target state="translated">通常，执行此命令的数据库用户将成为新数据库的所有者。但是，如果执行用户具有适当的特权，则可以通过 &lt;code&gt;-O&lt;/code&gt; 选项指定其他所有者。</target>
        </trans-unit>
        <trans-unit id="cce3fdca736676d73614d21a0ddda63501859fa9" translate="yes" xml:space="preserve">
          <source>Normally, the single-user mode server treats newline as the command entry terminator; there is no intelligence about semicolons, as there is in psql. To continue a command across multiple lines, you must type backslash just before each newline except the last one. The backslash and adjacent newline are both dropped from the input command. Note that this will happen even when within a string literal or comment.</source>
          <target state="translated">通常情况下,单用户模式的服务器将换行作为命令输入的结束符;没有分号的智能,就像psql中一样。要想跨行继续一条命令,必须在每个换行符前输入反斜线,除了最后一个。反斜杠和相邻的换行都会从输入命令中删除。请注意,即使在字符串文字或注释中也会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="1ab9de63486b486ed7137fde8276d785f144a066" translate="yes" xml:space="preserve">
          <source>Normally, there is a single apply process running for an enabled subscription. A disabled subscription or a crashed subscription will have zero rows in this view. If the initial data synchronization of any table is in progress, there will be additional workers for the tables being synchronized.</source>
          <target state="translated">通常情况下,一个已启用的订阅会有一个应用进程在运行。禁用的订阅或崩溃的订阅在此视图中的行数为零。如果任何表的初始数据同步正在进行中,则正在同步的表将有额外的工作者。</target>
        </trans-unit>
        <trans-unit id="67e110cfa914197db96be5bd8ad2cb0e12d33a41" translate="yes" xml:space="preserve">
          <source>Normally, this form will cause a scan of the table to verify that all existing rows in the table satisfy the new constraint. But if the &lt;code&gt;NOT VALID&lt;/code&gt; option is used, this potentially-lengthy scan is skipped. The constraint will still be enforced against subsequent inserts or updates (that is, they'll fail unless there is a matching row in the referenced table, in the case of foreign keys, or they'll fail unless the new row matches the specified check condition). But the database will not assume that the constraint holds for all rows in the table, until it is validated by using the &lt;code&gt;VALIDATE CONSTRAINT&lt;/code&gt; option. See &lt;a href=&quot;sql-altertable#SQL-ALTERTABLE-NOTES&quot;&gt;Notes&lt;/a&gt; below for more information about using the &lt;code&gt;NOT VALID&lt;/code&gt; option.</source>
          <target state="translated">通常，此表单将导致对表的扫描，以验证表中所有现有的行均满足新约束。但是，如果使用 &lt;code&gt;NOT VALID&lt;/code&gt; 选项，则将跳过此可能冗长的扫描。约束将仍然针对随后的插入或更新（即，对于外键而言，除非在引用表中有匹配的行，否则它们将失败，否则，除非新行与指定的检查匹配，否则它们将失败）健康）状况）。但是，除非使用 &lt;code&gt;VALIDATE CONSTRAINT&lt;/code&gt; 选项对其进行验证，否则数据库将不假定该约束对表中的所有行均有效。有关使用 &lt;code&gt;NOT VALID&lt;/code&gt; 选项的更多信息，请参见下面的&lt;a href=&quot;sql-altertable#SQL-ALTERTABLE-NOTES&quot;&gt;注释&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="01a8f59aaf55d8442cfcf99c35955b402850a73f" translate="yes" xml:space="preserve">
          <source>Normally, you will want to start the database server when the computer boots. Autostart scripts are operating-system-specific. There are a few distributed with PostgreSQL in the &lt;code&gt;contrib/start-scripts&lt;/code&gt; directory. Installing one will require root privileges.</source>
          <target state="translated">通常，您需要在计算机启动时启动数据库服务器。自动启动脚本是特定于操作系统的。PostgreSQL的 &lt;code&gt;contrib/start-scripts&lt;/code&gt; 目录中有一些分发。安装一个将需要root特权。</target>
        </trans-unit>
        <trans-unit id="6c89afe408dffc3292c4743bcc6ff18a8191e1d0" translate="yes" xml:space="preserve">
          <source>Normally, you will want to start the database server when the computer boots. Autostart scripts are operating-system-specific. There are a few example scripts distributed with PostgreSQL in the &lt;code&gt;contrib/start-scripts&lt;/code&gt; directory. Installing one will require root privileges.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99872ab32108649405bf8805c9de4baeb85fb7ad" translate="yes" xml:space="preserve">
          <source>North European</source>
          <target state="translated">北欧</target>
        </trans-unit>
        <trans-unit id="f79ff66cfb084d1746f64ba03a393ded056f91f0" translate="yes" xml:space="preserve">
          <source>Not all client APIs support all the listed character sets. For example, the PostgreSQL JDBC driver does not support &lt;code&gt;MULE_INTERNAL&lt;/code&gt;, &lt;code&gt;LATIN6&lt;/code&gt;, &lt;code&gt;LATIN8&lt;/code&gt;, and &lt;code&gt;LATIN10&lt;/code&gt;.</source>
          <target state="translated">并非所有的客户端API都支持所有列出的字符集。例如，PostgreSQL JDBC驱动程序不支持 &lt;code&gt;MULE_INTERNAL&lt;/code&gt; ， &lt;code&gt;LATIN6&lt;/code&gt; ， &lt;code&gt;LATIN8&lt;/code&gt; 和 &lt;code&gt;LATIN10&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9bacd7c0a9a33892b688e78e77b6ecea0ecffd5d" translate="yes" xml:space="preserve">
          <source>Not all of the requested files will be WAL segment files; you should also expect requests for files with a suffix of &lt;code&gt;.history&lt;/code&gt;. Also be aware that the base name of the &lt;code&gt;%p&lt;/code&gt; path will be different from &lt;code&gt;%f&lt;/code&gt;; do not expect them to be interchangeable.</source>
          <target state="translated">并非所有请求的文件都是WAL段文件。您还应该期望后缀为 &lt;code&gt;.history&lt;/code&gt; 的文件的请求。另请注意， &lt;code&gt;%p&lt;/code&gt; 路径的基本名称将与 &lt;code&gt;%f&lt;/code&gt; 不同；不要期望它们可以互换。</target>
        </trans-unit>
        <trans-unit id="91e930192ef14cc5c350419a549c884c45961c36" translate="yes" xml:space="preserve">
          <source>Not between (the negation of &lt;code id=&quot;between&quot;&gt;BETWEEN&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5510ea0072017c65967037de500e9abf1a00ab2" translate="yes" xml:space="preserve">
          <source>Not between, after sorting the two endpoint values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eb5b8bcff17673aebb4af5a3aeb0b4ab1932316" translate="yes" xml:space="preserve">
          <source>Not equal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feb1931a7fb65e60520184c9226b83ff8b5335ec" translate="yes" xml:space="preserve">
          <source>Not equal, treating null as a comparable value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f925a3c210bc672e17b8d68ff775e287c505fff" translate="yes" xml:space="preserve">
          <source>Not every user has authorization to create new databases. If PostgreSQL refuses to create databases for you then the site administrator needs to grant you permission to create databases. Consult your site administrator if this occurs. If you installed PostgreSQL yourself then you should log in for the purposes of this tutorial under the user account that you started the server as. &lt;a href=&quot;#ftn.id-1.4.3.4.10.4&quot;&gt;&lt;sup id=&quot;id-1.4.3.4.10.4&quot;&gt;[1]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">并非每个用户都有权创建新数据库。如果PostgreSQL拒绝为您创建数据库，则站点管理员需要授予您创建数据库的权限。如果发生这种情况，请咨询您的站点管理员。如果您自己安装了PostgreSQL，则出于本教程的目的，应以启动服务器的用户帐户登录。&lt;a href=&quot;#ftn.id-1.4.3.4.10.4&quot;&gt;&lt;sup id=&quot;id-1.4.3.4.10.4&quot;&gt;[1]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7dd5e10546306e9d83ef043283f9c8c8719bbf88" translate="yes" xml:space="preserve">
          <source>Not possible</source>
          <target state="translated">不可能</target>
        </trans-unit>
        <trans-unit id="14141efdb351648cd5997a4ec11511c9b9025f02" translate="yes" xml:space="preserve">
          <source>Not the password (always reads as &lt;code&gt;********&lt;/code&gt;)</source>
          <target state="translated">不是密码（始终显示为 &lt;code&gt;********&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="5b3582a3ba934510ccb693b77b7924863143d181" translate="yes" xml:space="preserve">
          <source>Notable differences between the existing POSIX-based regular-expression feature and XQuery regular expressions include:</source>
          <target state="translated">现有的基于POSIX的正则表达式功能和XQuery正则表达式之间的显著区别包括:。</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="9b3331f6b2637140f06fa920c5a275390198583a" translate="yes" xml:space="preserve">
          <source>Note also that if one is relying on explicit locking to prevent concurrent changes, one should either use Read Committed mode, or in Repeatable Read mode be careful to obtain locks before performing queries. A lock obtained by a repeatable read transaction guarantees that no other transactions modifying the table are still running, but if the snapshot seen by the transaction predates obtaining the lock, it might predate some now-committed changes in the table. A repeatable read transaction's snapshot is actually frozen at the start of its first query or data-modification command (&lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt;), so it is possible to obtain locks explicitly before the snapshot is frozen.</source>
          <target state="translated">还要注意，如果有人依靠显式锁定来防止并发更改，则应该使用&amp;ldquo;读已提交&amp;rdquo;模式，或者在&amp;ldquo;可重复读&amp;rdquo;模式下，在执行查询之前，请小心获取锁。由可重复读取事务获得的锁保证了没有其他修改表的事务仍在运行，但是如果事务看到的快照早于获得该锁，则它可能早于表中某些当前提交的更改。可重复读取事务的快照实际上是在其第一个查询或数据修改命令（ &lt;code&gt;SELECT&lt;/code&gt; ， &lt;code&gt;INSERT&lt;/code&gt; ， &lt;code&gt;UPDATE&lt;/code&gt; 或 &lt;code&gt;DELETE&lt;/code&gt; ）开始时冻结的，因此可以在冻结快照之前显式获取锁。</target>
        </trans-unit>
        <trans-unit id="7593ffc9010adfe129fd98d3fee440d02e9a7b83" translate="yes" xml:space="preserve">
          <source>Note however that if multiple standby servers are restoring from the same archive directory, you will need to ensure that you do not delete WAL files until they are no longer needed by any of the servers. &lt;code&gt;archive_cleanup_command&lt;/code&gt; would typically be used in a warm-standby configuration (see &lt;a href=&quot;warm-standby&quot;&gt;Section 26.2&lt;/a&gt;). Write &lt;code&gt;%%&lt;/code&gt; to embed an actual &lt;code&gt;%&lt;/code&gt; character in the command.</source>
          <target state="translated">但是请注意，如果多个备用服务器正在从同一个存档目录中还原，则需要确保在所有服务器不再需要它们之前，不要删除WAL文件。 &lt;code&gt;archive_cleanup_command&lt;/code&gt; 通常将在热备份配置中使用（请参阅&lt;a href=&quot;warm-standby&quot;&gt;第26.2节&lt;/a&gt;）。写入 &lt;code&gt;%%&lt;/code&gt; 以在命令中嵌入实际的 &lt;code&gt;%&lt;/code&gt; 字符。</target>
        </trans-unit>
        <trans-unit id="a9a98603977441f8554a2833afe694dbcfe6aeee" translate="yes" xml:space="preserve">
          <source>Note however that simple names are matched to column names before table names, so this example works only because there is no column named &lt;code&gt;c&lt;/code&gt; in the query's tables.</source>
          <target state="translated">但是请注意，简单名称与表名称之前的列名称匹配，因此此示例仅适用于查询表中没有名为 &lt;code&gt;c&lt;/code&gt; 的列。</target>
        </trans-unit>
        <trans-unit id="90893364f9fe7dce948b26423ee4ecd2e88b2f16" translate="yes" xml:space="preserve">
          <source>Note however that you &lt;em&gt;cannot&lt;/em&gt; accomplish that effect with a command limited to a single schema. This command has no effect, unless it is undoing a matching &lt;code&gt;GRANT&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aef3a8d9770be0e69a039281f14778156239350" translate="yes" xml:space="preserve">
          <source>Note that &amp;ldquo;try all combinations&amp;rdquo; is not a realistic exercise. Usually password cracking is done with the help of dictionaries, which contain both regular words and various mutations of them. So, even somewhat word-like passwords could be cracked much faster than the above numbers suggest, while a 6-character non-word-like password may escape cracking. Or not.</source>
          <target state="translated">请注意，&amp;ldquo;尝试所有组合&amp;rdquo;不是现实的练习。通常，密码破解是在词典的帮助下完成的，词典既包含常规单词，又包含它们的各种变体。因此，即使是有点像单词的密码，其破解速度也可能比上述数字所提示的快得多，而6个字符的非单词的密码可能会免于破解。或不。</target>
        </trans-unit>
        <trans-unit id="00e6a4c57a18e5fbbf85ff612c2a3727ded13249" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;/etc/rc&lt;/code&gt; is usually overwritten by macOS system updates, so you should expect to have to redo these edits after each update.</source>
          <target state="translated">请注意， &lt;code&gt;/etc/rc&lt;/code&gt; 通常会被macOS系统更新覆盖，因此您应该期望在每次更新后必须重做这些编辑。</target>
        </trans-unit>
        <trans-unit id="27a1cfa3bf0ee9c52c7a87330ba166c5fa86db79" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;GREATEST&lt;/code&gt; and &lt;code&gt;LEAST&lt;/code&gt; are not in the SQL standard, but are a common extension. Some other databases make them return NULL if any argument is NULL, rather than only when all are NULL.</source>
          <target state="translated">请注意， &lt;code&gt;GREATEST&lt;/code&gt; 和 &lt;code&gt;LEAST&lt;/code&gt; 不在SQL标准中，而是常见的扩展。如果某些参数为NULL，则某些其他数据库使它们返回NULL，而不是仅当所有参数均为NULL时才返回NULL。</target>
        </trans-unit>
        <trans-unit id="d1e87e3a532a3c85a5fb7cefcf86b5bd58f7519a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;INSERT&lt;/code&gt; with &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; checks &lt;code&gt;INSERT&lt;/code&gt; policies' &lt;code&gt;WITH CHECK&lt;/code&gt; expressions only for rows appended to the relation by the &lt;code&gt;INSERT&lt;/code&gt; path.</source>
          <target state="translated">需要注意的是 &lt;code&gt;INSERT&lt;/code&gt; 与 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 检查 &lt;code&gt;INSERT&lt;/code&gt; 政策 &lt;code&gt;WITH CHECK&lt;/code&gt; 表达式仅追加到由关系行 &lt;code&gt;INSERT&lt;/code&gt; 路径。</target>
        </trans-unit>
        <trans-unit id="c319652e77f1cdd2df39e790f0f919f2b95a2486" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;amcheck&lt;/code&gt; examines a page as represented in some shared memory buffer at the time of verification if there is only a shared buffer hit when accessing the block. Consequently, &lt;code&gt;amcheck&lt;/code&gt; does not necessarily examine data read from the file system at the time of verification. Note that when checksums are enabled, &lt;code&gt;amcheck&lt;/code&gt; may raise an error due to a checksum failure when a corrupt block is read into a buffer.</source>
          <target state="translated">请注意，如果在访问块时只有共享缓冲区命中，则 &lt;code&gt;amcheck&lt;/code&gt; 会在验证时检查某个共享内存缓冲区中表示的页面。因此， &lt;code&gt;amcheck&lt;/code&gt; 不必在验证时检查从文件系统读取的数据。请注意，启用校验和后，当将损坏的块读入缓冲区时，由于校验和失败， &lt;code&gt;amcheck&lt;/code&gt; 可能会引发错误。</target>
        </trans-unit>
        <trans-unit id="ef24e95dba1150cbef958d74c2f80a5630d7740c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;extract&lt;/code&gt;'s day of the week numbering differs from that of the &lt;code&gt;to_char(..., 'D')&lt;/code&gt; function.</source>
          <target state="translated">请注意， &lt;code&gt;extract&lt;/code&gt; 的星期几编号与 &lt;code&gt;to_char(..., 'D')&lt;/code&gt; 函数的编号不同。</target>
        </trans-unit>
        <trans-unit id="993b93174865d889f669c89fbc134d310b24fd79" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;first_value&lt;/code&gt;, &lt;code&gt;last_value&lt;/code&gt;, and &lt;code&gt;nth_value&lt;/code&gt; consider only the rows within the &amp;ldquo;window frame&amp;rdquo;, which by default contains the rows from the start of the partition through the last peer of the current row. This is likely to give unhelpful results for &lt;code&gt;last_value&lt;/code&gt; and sometimes also &lt;code&gt;nth_value&lt;/code&gt;. You can redefine the frame by adding a suitable frame specification (&lt;code&gt;RANGE&lt;/code&gt;, &lt;code&gt;ROWS&lt;/code&gt; or &lt;code&gt;GROUPS&lt;/code&gt;) to the &lt;code&gt;OVER&lt;/code&gt; clause. See &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Section 4.2.8&lt;/a&gt; for more information about frame specifications.</source>
          <target state="translated">请注意， &lt;code&gt;first_value&lt;/code&gt; ， &lt;code&gt;last_value&lt;/code&gt; 和 &lt;code&gt;nth_value&lt;/code&gt; 仅考虑&amp;ldquo;窗口框架&amp;rdquo;中的行，默认情况下，这些窗口包含从分区开始到当前行的最后一个对等方的行。这可能会给 &lt;code&gt;last_value&lt;/code&gt; 甚至 &lt;code&gt;nth_value&lt;/code&gt; 带来不利的结果。您可以通过在 &lt;code&gt;OVER&lt;/code&gt; 子句中添加合适的框架规范（ &lt;code&gt;RANGE&lt;/code&gt; ， &lt;code&gt;ROWS&lt;/code&gt; 或 &lt;code&gt;GROUPS&lt;/code&gt; ）来重新定义框架。有关框架规格的更多信息，请参见&lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;第4.2.8节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e089463c04f2f8771502e8d62b431f3c71d88b7d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;m&lt;/code&gt; columns can also be moved out to secondary storage, but only as a last resort (&lt;code&gt;e&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; columns are moved first).</source>
          <target state="translated">Note that &lt;code&gt;m&lt;/code&gt; columns can also be moved out to secondary storage, but only as a last resort ( &lt;code&gt;e&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; columns are moved first).</target>
        </trans-unit>
        <trans-unit id="40331004e0ffed62ad250a770b0b797c5ac46ee7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;max_standby_archive_delay&lt;/code&gt; is not the same as the maximum length of time a query can run before cancellation; rather it is the maximum total time allowed to apply any one WAL segment's data. Thus, if one query has resulted in significant delay earlier in the WAL segment, subsequent conflicting queries will have much less grace time.</source>
          <target state="translated">Note that &lt;code&gt;max_standby_archive_delay&lt;/code&gt; is not the same as the maximum length of time a query can run before cancellation; rather it is the maximum total time allowed to apply any one WAL segment's data. Thus, if one query has resulted in significant delay earlier in the WAL segment, subsequent conflicting queries will have much less grace time.</target>
        </trans-unit>
        <trans-unit id="d4ea769871b3208ec9bdd68befff4d7903f7eff9" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; is not the same as the maximum length of time a query can run before cancellation; rather it is the maximum total time allowed to apply WAL data once it has been received from the primary server. Thus, if one query has resulted in significant delay, subsequent conflicting queries will have much less grace time until the standby server has caught up again.</source>
          <target state="translated">请注意， &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; 与取消之前查询可以运行的最大时间长度不同；而是从主服务器接收到WAL数据后允许应用的最大总时间。因此，如果一个查询导致显着的延迟，则随后的冲突查询将具有更少的宽限时间，直到备用服务器再次追上。</target>
        </trans-unit>
        <trans-unit id="d6596a8da6c53c8c974c373f17703e4e032c6d9e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;plainto_tsquery&lt;/code&gt; will not recognize &lt;code&gt;tsquery&lt;/code&gt; operators, weight labels, or prefix-match labels in its input:</source>
          <target state="translated">请注意， &lt;code&gt;plainto_tsquery&lt;/code&gt; 不会在其输入中识别 &lt;code&gt;tsquery&lt;/code&gt; 运算符，权重标签或前缀匹配标签：</target>
        </trans-unit>
        <trans-unit id="531e2b77490742cd189acb5bc5e4276f0143a9de" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;postgres_fdw&lt;/code&gt; currently lacks support for &lt;code&gt;INSERT&lt;/code&gt; statements with an &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clause. However, the &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; clause is supported, provided a unique index inference specification is omitted. Note also that &lt;code&gt;postgres_fdw&lt;/code&gt; supports row movement invoked by &lt;code&gt;UPDATE&lt;/code&gt; statements executed on partitioned tables, but it currently does not handle the case where a remote partition chosen to insert a moved row into is also an &lt;code&gt;UPDATE&lt;/code&gt; target partition that will be updated later.</source>
          <target state="translated">请注意， &lt;code&gt;postgres_fdw&lt;/code&gt; 当前不支持带有 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 子句的 &lt;code&gt;INSERT&lt;/code&gt; 语句。但是，如果省略了唯一的索引推断规范，则支持 &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; 子句。还要注意， &lt;code&gt;postgres_fdw&lt;/code&gt; 支持在分区表上执行的 &lt;code&gt;UPDATE&lt;/code&gt; 语句所调用的行移动，但是当前无法处理选择将插入行的远程分区也是 &lt;code&gt;UPDATE&lt;/code&gt; 目标分区（稍后将对其进行更新）的情况。</target>
        </trans-unit>
        <trans-unit id="9d0c357cbd644595d94bcf660fedeb383e698ab1" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;to_tsquery&lt;/code&gt; will process prefixes in the same way as other words, which means this comparison returns true:</source>
          <target state="translated">请注意， &lt;code&gt;to_tsquery&lt;/code&gt; 将以与其他词相同的方式处理前缀，这意味着此比较返回true：</target>
        </trans-unit>
        <trans-unit id="547e51942705ea4910d562213bfd3cab3c67874d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;wal_receiver_timeout&lt;/code&gt;, &lt;code&gt;wal_receiver_status_interval&lt;/code&gt; and &lt;code&gt;wal_retrieve_retry_interval&lt;/code&gt; configuration parameters affect the logical replication workers as well.</source>
          <target state="translated">请注意， &lt;code&gt;wal_receiver_timeout&lt;/code&gt; ， &lt;code&gt;wal_receiver_status_interval&lt;/code&gt; 和 &lt;code&gt;wal_retrieve_retry_interval&lt;/code&gt; 配置参数也会影响逻辑复制工作程序。</target>
        </trans-unit>
        <trans-unit id="e5c3c7860afae265b42af4a1e6e8bf5af951d1e2" translate="yes" xml:space="preserve">
          <source>Note that GIN index build time can often be improved by increasing &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt;, while GiST index build time is not sensitive to that parameter.</source>
          <target state="translated">请注意，通常可以通过增加&lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt;来改善GIN索引的建立时间，而GiST索引的建立时间对该参数并不敏感。</target>
        </trans-unit>
        <trans-unit id="4b8a5f57b365044d35823a4b451d18873918bc73" translate="yes" xml:space="preserve">
          <source>Note that XML forests are not valid XML documents if they consist of more than one element, so it might be useful to wrap &lt;code&gt;xmlforest&lt;/code&gt; expressions in &lt;code&gt;xmlelement&lt;/code&gt;.</source>
          <target state="translated">请注意，如果XML林包含多个元素，则它们不是有效的XML文档，因此将 &lt;code&gt;xmlforest&lt;/code&gt; 表达式包装在 &lt;code&gt;xmlelement&lt;/code&gt; 中可能很有用。</target>
        </trans-unit>
        <trans-unit id="41bc51ade685b6e9a9074785e60b9928bfbc83ce" translate="yes" xml:space="preserve">
          <source>Note that a file system backup will typically be larger than an SQL dump. (pg_dump does not need to dump the contents of indexes for example, just the commands to recreate them.) However, taking a file system backup might be faster.</source>
          <target state="translated">注意,文件系统的备份通常会比SQL转储大。例如,pg_dump不需要转储索引的内容,只需要转储重新创建索引的命令)。然而,采取文件系统备份可能会更快。</target>
        </trans-unit>
        <trans-unit id="4c32d659dad68b2cd17eab976deb46f2e6ed59ea" translate="yes" xml:space="preserve">
          <source>Note that a foreign table can be declared with fewer columns, or with a different column order, than its underlying remote table has. Matching of columns to the remote table is by name, not position.</source>
          <target state="translated">需要注意的是,可以声明一个外表的列数比其底层远程表的列数少,或者列序不同。列与远程表的匹配是按名称而非位置进行的。</target>
        </trans-unit>
        <trans-unit id="c47a3a43d56fab6f7325c7aa20434bcba1bc9c0b" translate="yes" xml:space="preserve">
          <source>Note that all data types use rather obvious input formats. Constants that are not simple numeric values usually must be surrounded by single quotes (&lt;code&gt;'&lt;/code&gt;), as in the example. The &lt;code&gt;date&lt;/code&gt; type is actually quite flexible in what it accepts, but for this tutorial we will stick to the unambiguous format shown here.</source>
          <target state="translated">请注意，所有数据类型都使用相当明显的输入格式。如示例中所示，不是简单数字值的常量通常必须用单引号（ &lt;code&gt;'&lt;/code&gt; ）引起来。该 &lt;code&gt;date&lt;/code&gt; 类型实际上是在什么接受相当灵活，但在本教程中，我们将继续坚持在这里显示的明确的格式。</target>
        </trans-unit>
        <trans-unit id="25d42cd6ceef922ecf25e7b24fce40695e12cb56" translate="yes" xml:space="preserve">
          <source>Note that all other sessions will immediately be able to see the data once it has been successfully loaded. This violates the normal rules of MVCC visibility and users specifying should be aware of the potential problems this might cause.</source>
          <target state="translated">请注意,一旦数据被成功加载,所有其他会话将能够立即看到该数据。这违反了MVCC的正常可见性规则,指定用户应意识到这可能导致的潜在问题。</target>
        </trans-unit>
        <trans-unit id="df99d378fb51575b390c0b84d9d7987211c8c70b" translate="yes" xml:space="preserve">
          <source>Note that all the solutions described above take care of starting new log files at configurable intervals, but they do not handle deletion of old, no-longer-useful log files. You will probably want to set up a batch job to periodically delete old log files. Another possibility is to configure the rotation program so that old log files are overwritten cyclically.</source>
          <target state="translated">请注意,上面描述的所有解决方案都会以可配置的时间间隔启动新的日志文件,但它们不会处理删除旧的、不再有用的日志文件。你可能需要设置一个批处理任务来定期删除旧的日志文件。另一种可能是配置轮换程序,使旧的日志文件周期性地被覆盖。</target>
        </trans-unit>
        <trans-unit id="2c87d02f3e8f6257698af02e373aea3121b7dc2e" translate="yes" xml:space="preserve">
          <source>Note that although WAL archiving will allow you to restore any modifications made to the data in your PostgreSQL database, it will not restore changes made to configuration files (that is, &lt;code&gt;postgresql.conf&lt;/code&gt;, &lt;code&gt;pg_hba.conf&lt;/code&gt; and &lt;code&gt;pg_ident.conf&lt;/code&gt;), since those are edited manually rather than through SQL operations. You might wish to keep the configuration files in a location that will be backed up by your regular file system backup procedures. See &lt;a href=&quot;runtime-config-file-locations&quot;&gt;Section 19.2&lt;/a&gt; for how to relocate the configuration files.</source>
          <target state="translated">请注意，尽管WAL归档将允许您恢复对PostgreSQL数据库中的数据所做的任何修改，但不会恢复对配置文件（即 &lt;code&gt;postgresql.conf&lt;/code&gt; ， &lt;code&gt;pg_hba.conf&lt;/code&gt; 和 &lt;code&gt;pg_ident.conf&lt;/code&gt; ）所做的更改。手动编辑，而不是通过SQL操作。您可能希望将配置文件保存在将由常规文件系统备份过程备份的位置。有关如何重新放置配置文件，请参见&lt;a href=&quot;runtime-config-file-locations&quot;&gt;第19.2节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d53090021f825a89df9ea9e9d71eae604c7c4a95" translate="yes" xml:space="preserve">
          <source>Note that an &lt;code&gt;AS&lt;/code&gt; clause is required when &lt;code&gt;VALUES&lt;/code&gt; is used in a &lt;code&gt;FROM&lt;/code&gt; clause, just as is true for &lt;code&gt;SELECT&lt;/code&gt;. It is not required that the &lt;code&gt;AS&lt;/code&gt; clause specify names for all the columns, but it's good practice to do so. (The default column names for &lt;code&gt;VALUES&lt;/code&gt; are &lt;code&gt;column1&lt;/code&gt;, &lt;code&gt;column2&lt;/code&gt;, etc in PostgreSQL, but these names might be different in other database systems.)</source>
          <target state="translated">请注意，在 &lt;code&gt;FROM&lt;/code&gt; 子句中使用 &lt;code&gt;VALUES&lt;/code&gt; 时，需要 &lt;code&gt;AS&lt;/code&gt; 子句，就像 &lt;code&gt;SELECT&lt;/code&gt; 一样。不需要 &lt;code&gt;AS&lt;/code&gt; 子句为所有列指定名称，但是这样做是一种好习惯。 （为默认列名 &lt;code&gt;VALUES&lt;/code&gt; 是 &lt;code&gt;column1&lt;/code&gt; ， &lt;code&gt;column2&lt;/code&gt; 等在PostgreSQL的，但这些名称可能是其他数据库系统不同。）</target>
        </trans-unit>
        <trans-unit id="2b4af4e58c7c07f18643d7fac4e1368ce1d5e583" translate="yes" xml:space="preserve">
          <source>Note that any particular role will have the sum of privileges granted directly to it, privileges granted to any role it is presently a member of, and privileges granted to &lt;code&gt;PUBLIC&lt;/code&gt;. Thus, for example, revoking &lt;code&gt;SELECT&lt;/code&gt; privilege from &lt;code&gt;PUBLIC&lt;/code&gt; does not necessarily mean that all roles have lost &lt;code&gt;SELECT&lt;/code&gt; privilege on the object: those who have it granted directly or via another role will still have it. Similarly, revoking &lt;code&gt;SELECT&lt;/code&gt; from a user might not prevent that user from using &lt;code&gt;SELECT&lt;/code&gt; if &lt;code&gt;PUBLIC&lt;/code&gt; or another membership role still has &lt;code&gt;SELECT&lt;/code&gt; rights.</source>
          <target state="translated">请注意，任何特定角色都将具有直接授予它的特权，授予当前它所属的任何角色的特权以及授予 &lt;code&gt;PUBLIC&lt;/code&gt; 的特权的总和。因此，例如，从 &lt;code&gt;PUBLIC&lt;/code&gt; 撤消 &lt;code&gt;SELECT&lt;/code&gt; 特权并不一定意味着所有角色都对该对象失去 &lt;code&gt;SELECT&lt;/code&gt; 特权：直接或通过其他角色授予它的那些人仍然拥有它。同样，如果 &lt;code&gt;PUBLIC&lt;/code&gt; 或其他成员身份角色仍然具有 &lt;code&gt;SELECT&lt;/code&gt; 权限，则从用户撤消 &lt;code&gt;SELECT&lt;/code&gt; 可能不会阻止该用户使用 &lt;code&gt;SELECT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2fd76787f2a53ba7fb758f8a964cdd22772c1d78" translate="yes" xml:space="preserve">
          <source>Note that because &lt;code&gt;recovery.signal&lt;/code&gt; will not be removed when &lt;code&gt;recovery_target_action&lt;/code&gt; is set to &lt;code&gt;shutdown&lt;/code&gt;, any subsequent start will end with immediate shutdown unless the configuration is changed or the &lt;code&gt;recovery.signal&lt;/code&gt; file is removed manually.</source>
          <target state="translated">需要注意的是，因为 &lt;code&gt;recovery.signal&lt;/code&gt; 时不会被删除 &lt;code&gt;recovery_target_action&lt;/code&gt; 设置为 &lt;code&gt;shutdown&lt;/code&gt; ，任何后续启动将立即关机，除非配置改变或结束 &lt;code&gt;recovery.signal&lt;/code&gt; 文件被手动删除。</target>
        </trans-unit>
        <trans-unit id="9c33fcc287f27c5bc2a2b32d53b1b513b1091d88" translate="yes" xml:space="preserve">
          <source>Note that casting to just &amp;ldquo;bit&amp;rdquo; means casting to &lt;code&gt;bit(1)&lt;/code&gt;, and so will deliver only the least significant bit of the integer.</source>
          <target state="translated">请注意，仅强制转换为&amp;ldquo; bit&amp;rdquo;意味着强制转换为 &lt;code&gt;bit(1)&lt;/code&gt; ，因此将仅传递整数的最低有效位。</target>
        </trans-unit>
        <trans-unit id="fd0a0fb6f9e97d5efee795fd874b77207c725a32" translate="yes" xml:space="preserve">
          <source>Note that collecting the additional timing information needed for per-statement latency computation adds some overhead. This will slow average execution speed and lower the computed TPS. The amount of slowdown varies significantly depending on platform and hardware. Comparing average TPS values with and without latency reporting enabled is a good way to measure if the timing overhead is significant.</source>
          <target state="translated">请注意,收集每条语句延迟计算所需的额外时序信息会增加一些开销。这将减慢平均执行速度,降低计算的TPS。减慢的程度因平台和硬件的不同而有很大差异。比较启用和未启用延迟报告的平均TPS值是衡量时序开销是否显著的好方法。</target>
        </trans-unit>
        <trans-unit id="46048f7966588bd79b584545411fe217e62e0e87" translate="yes" xml:space="preserve">
          <source>Note that constraints other than &lt;code&gt;NOT NULL&lt;/code&gt; will never be imported from the remote tables. Although PostgreSQL does support &lt;code&gt;CHECK&lt;/code&gt; constraints on foreign tables, there is no provision for importing them automatically, because of the risk that a constraint expression could evaluate differently on the local and remote servers. Any such inconsistency in the behavior of a &lt;code&gt;CHECK&lt;/code&gt; constraint could lead to hard-to-detect errors in query optimization. So if you wish to import &lt;code&gt;CHECK&lt;/code&gt; constraints, you must do so manually, and you should verify the semantics of each one carefully. For more detail about the treatment of &lt;code&gt;CHECK&lt;/code&gt; constraints on foreign tables, see &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;.</source>
          <target state="translated">请注意，绝不会从远程表中导入 &lt;code&gt;NOT NULL&lt;/code&gt; 以外的其他约束。尽管PostgreSQL确实支持对外部表的 &lt;code&gt;CHECK&lt;/code&gt; 约束，但是由于约束表达式在本地和远程服务器上的计算结果可能不同，因此没有自动导入约束的规定。 &lt;code&gt;CHECK&lt;/code&gt; 约束的行为中的任何此类不一致都可能导致查询优化中难以检测到的错误。因此，如果要导入 &lt;code&gt;CHECK&lt;/code&gt; 约束，则必须手动进行，并且应仔细验证每个约束的语义。有关处理外部表上的 &lt;code&gt;CHECK&lt;/code&gt; 约束的更多详细信息，请参见&lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="699164176c152ba6b84d675ad75f5ace743cae19" translate="yes" xml:space="preserve">
          <source>Note that cost estimate functions must be written in C, not in SQL or any available procedural language, because they must access internal data structures of the planner/optimizer.</source>
          <target state="translated">请注意,成本估算函数必须用C语言编写,而不是用SQL或任何可用的程序语言,因为它们必须访问规划器/优化器的内部数据结构。</target>
        </trans-unit>
        <trans-unit id="06d4a3361a37979804bf5a58a39eb486b3f91ba2" translate="yes" xml:space="preserve">
          <source>Note that deadlocks can also occur as the result of row-level locks (and thus, they can occur even if explicit locking is not used). Consider the case in which two concurrent transactions modify a table. The first transaction executes:</source>
          <target state="translated">请注意,死锁也可能是行级锁的结果(因此,即使不使用显式锁,也可能发生死锁)。考虑两个并发事务修改一个表的情况。第一个事务执行。</target>
        </trans-unit>
        <trans-unit id="6082e5afeea05f3f2e208c50995f15f349743dca" translate="yes" xml:space="preserve">
          <source>Note that deduplication is deemed unsafe and cannot be used in the following cases involving semantically significant differences among equal datums:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8001d46d3d20b93246bb06a2398e61902d0e24f2" translate="yes" xml:space="preserve">
          <source>Note that different keys may have the same ID. This is rare but a normal event. The client application should then try to decrypt with each one, to see which fits &amp;mdash; like handling &lt;code&gt;ANYKEY&lt;/code&gt;.</source>
          <target state="translated">请注意，不同的密钥可能具有相同的ID。这很少见，但这是正常现象。然后，客户端应用程序应尝试对每个应用程序进行解密，以 &lt;code&gt;ANYKEY&lt;/code&gt; 适合的对象，例如处理ANYKEY。</target>
        </trans-unit>
        <trans-unit id="8d9652ff899a1fe6db38db0e7bf8d1018609b472" translate="yes" xml:space="preserve">
          <source>Note that different units are used for the per loop time than the histogram. The loop can have resolution within a few nanoseconds (ns), while the individual timing calls can only resolve down to one microsecond (us).</source>
          <target state="translated">请注意,每个循环时间与直方图使用的单位不同。循环的分辨率可以在几纳秒(ns)内,而单个计时调用的分辨率只能达到一微秒(us)。</target>
        </trans-unit>
        <trans-unit id="8463fb9b10613a7f093421dc720a6dd930e1df32" translate="yes" xml:space="preserve">
          <source>Note that enabling or disabling group access on an existing cluster requires the cluster to be shut down and the appropriate mode to be set on all directories and files before restarting PostgreSQL. Otherwise, a mix of modes might exist in the data directory. For clusters that allow access only by the owner, the appropriate modes are &lt;code&gt;0700&lt;/code&gt; for directories and &lt;code&gt;0600&lt;/code&gt; for files. For clusters that also allow reads by the group, the appropriate modes are &lt;code&gt;0750&lt;/code&gt; for directories and &lt;code&gt;0640&lt;/code&gt; for files.</source>
          <target state="translated">请注意，要在现有集群上启用或禁用组访问，需要在重启PostgreSQL之前关闭集群并在所有目录和文件上设置适当的模式。否则，数据目录中可能存在多种模式。对于仅允许所有者访问的群集，适当的模式是目录的 &lt;code&gt;0700&lt;/code&gt; 和文件的 &lt;code&gt;0600&lt;/code&gt; 。对于也允许该组读取的群集，适当的模式是目录的 &lt;code&gt;0750&lt;/code&gt; 和文件的 &lt;code&gt;0640&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="836bf1d98935001a9e7ffe81c54955b795aef94c" translate="yes" xml:space="preserve">
          <source>Note that even when this parameter is disabled, the system will launch autovacuum processes if necessary to prevent transaction ID wraparound. See &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;Section 24.1.5&lt;/a&gt; for more information.</source>
          <target state="translated">请注意，即使禁用此参数，系统也会在必要时启动自动清理进程以防止事务ID绕回。有关更多信息，请参见&lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;第24.1.5节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7f1ea5bec1703e5249cd8348fa7e3e07222422cf" translate="yes" xml:space="preserve">
          <source>Note that exclusion constraints are not supported as arbiters with &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt;. In all cases, only &lt;code&gt;NOT DEFERRABLE&lt;/code&gt; constraints and unique indexes are supported as arbiters.</source>
          <target state="translated">请注意， &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 不支持将排除约束用作仲裁程序。在所有情况下，仅支持 &lt;code&gt;NOT DEFERRABLE&lt;/code&gt; 约束和唯一索引作为仲裁器。</target>
        </trans-unit>
        <trans-unit id="8de881cb4486af9a5996e8f814cf056ae7026e35" translate="yes" xml:space="preserve">
          <source>Note that for constraint triggers, evaluation of the &lt;code&gt;WHEN&lt;/code&gt; condition is not deferred, but occurs immediately after the row update operation is performed. If the condition does not evaluate to true then the trigger is not queued for deferred execution.</source>
          <target state="translated">请注意，对于约束触发器，不会推迟对 &lt;code&gt;WHEN&lt;/code&gt; 条件的评估，而是在执行行更新操作之后立即进行评估。如果条件未评估为真，则触发器不会排队等待延迟执行。</target>
        </trans-unit>
        <trans-unit id="0be6e3fd01fb4ed50e92212c3560099998e4c687" translate="yes" xml:space="preserve">
          <source>Note that for historic reasons, the function &lt;code&gt;md5&lt;/code&gt; returns a hex-encoded value of type &lt;code&gt;text&lt;/code&gt; whereas the SHA-2 functions return type &lt;code&gt;bytea&lt;/code&gt;. Use the functions &lt;code&gt;encode&lt;/code&gt; and &lt;code&gt;decode&lt;/code&gt; to convert between the two, for example &lt;code&gt;encode(sha256('abc'), 'hex')&lt;/code&gt; to get a hex-encoded text representation.</source>
          <target state="translated">请注意，由于历史原因，函数 &lt;code&gt;md5&lt;/code&gt; 返回十六进制编码的 &lt;code&gt;text&lt;/code&gt; 类型的值，而SHA-2函数返回type &lt;code&gt;bytea&lt;/code&gt; 。使用 &lt;code&gt;encode&lt;/code&gt; 和 &lt;code&gt;decode&lt;/code&gt; 功能在两者之间进行转换，例如， &lt;code&gt;encode(sha256('abc'), 'hex')&lt;/code&gt; 获得十六进制编码的文本表示形式。</target>
        </trans-unit>
        <trans-unit id="cfe04c8846d33d71c984b2b6f7148e6d08053137" translate="yes" xml:space="preserve">
          <source>Note that foreign tables that use a foreign-data wrapper with no handler cannot be accessed.</source>
          <target state="translated">请注意,使用没有处理程序的外数据封装器的外表不能被访问。</target>
        </trans-unit>
        <trans-unit id="02035a3862ae6605e031adf46021fcd89539c880" translate="yes" xml:space="preserve">
          <source>Note that granting users the EXECUTE privilege on &lt;code&gt;pg_read_file()&lt;/code&gt;, or related functions, allows them the ability to read any file on the server that the database server process can read; these functions bypass all in-database privilege checks. This means that, for example, a user with such access is able to read the contents of the &lt;code&gt;pg_authid&lt;/code&gt; table where authentication information is stored, as well as read any table data in the database. Therefore, granting access to these functions should be carefully considered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5453a69c6ad7e7ddfed4130bdc5747df6c5fd62b" translate="yes" xml:space="preserve">
          <source>Note that granting users the EXECUTE privilege on &lt;code&gt;pg_read_file()&lt;/code&gt;, or related functions, allows them the ability to read any file on the server which the database can read and that those reads bypass all in-database privilege checks. This means that, among other things, a user with this access is able to read the contents of the &lt;code&gt;pg_authid&lt;/code&gt; table where authentication information is contained, as well as read any file in the database. Therefore, granting access to these functions should be carefully considered.</source>
          <target state="translated">请注意，向用户授予 &lt;code&gt;pg_read_file()&lt;/code&gt; 或相关功能的EXECUTE特权，使他们能够读取服务器上数据库可以读取的任何文件，并且这些读取会绕过所有数据库内特权检查。这意味着，除其他事项外，具有此访问权限的用户能够读取 &lt;code&gt;pg_authid&lt;/code&gt; 表的内容，该表中包含身份验证信息，以及读取数据库中的任何文件。因此，应仔细考虑授予访问这些功能的权限。</target>
        </trans-unit>
        <trans-unit id="fd90b8fb5e3c2266322a8f9361a13beecb2d12fc" translate="yes" xml:space="preserve">
          <source>Note that here the &lt;code&gt;field&lt;/code&gt; parameter needs to be a string value, not a name. The valid field names for &lt;code&gt;date_part&lt;/code&gt; are the same as for &lt;code&gt;extract&lt;/code&gt;.</source>
          <target state="translated">请注意，此处的 &lt;code&gt;field&lt;/code&gt; 参数必须是字符串值，而不是名称。 &lt;code&gt;date_part&lt;/code&gt; 的有效字段名称与 &lt;code&gt;extract&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="13c19c7fbcb3e2d4787b53bfa2ce9ac2e3e6f680" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;MINVALUE&lt;/code&gt; or &lt;code&gt;MAXVALUE&lt;/code&gt; is used for one column of a partitioning bound, the same value must be used for all subsequent columns. For example, &lt;code&gt;(10, MINVALUE, 0)&lt;/code&gt; is not a valid bound; you should write &lt;code&gt;(10, MINVALUE, MINVALUE)&lt;/code&gt;.</source>
          <target state="translated">请注意，如果将 &lt;code&gt;MINVALUE&lt;/code&gt; 或 &lt;code&gt;MAXVALUE&lt;/code&gt; 用于分区绑定的一列，则所有后续列都必须使用相同的值。例如， &lt;code&gt;(10, MINVALUE, 0)&lt;/code&gt; 不是有效的界限；您应该写 &lt;code&gt;(10, MINVALUE, MINVALUE)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ba56c2e43467332103da0c13e1894f6a417084e8" translate="yes" xml:space="preserve">
          <source>Note that if a &lt;code&gt;FROM&lt;/code&gt; clause is not specified, the query cannot reference any database tables. For example, the following query is invalid:</source>
          <target state="translated">请注意，如果未指定 &lt;code&gt;FROM&lt;/code&gt; 子句，则查询无法引用任何数据库表。例如，以下查询无效：</target>
        </trans-unit>
        <trans-unit id="90a3cd6b9233790897980d2c49eb8226596f6f8e" translate="yes" xml:space="preserve">
          <source>Note that if both &lt;code&gt;fields&lt;/code&gt; and &lt;code&gt;p&lt;/code&gt; are specified, the &lt;code&gt;fields&lt;/code&gt; must include &lt;code&gt;SECOND&lt;/code&gt;, since the precision applies only to the seconds.</source>
          <target state="translated">请注意，如果同时指定了 &lt;code&gt;fields&lt;/code&gt; 和 &lt;code&gt;p&lt;/code&gt; ，则这些 &lt;code&gt;fields&lt;/code&gt; 必须包含 &lt;code&gt;SECOND&lt;/code&gt; ，因为精度仅适用于秒。</target>
        </trans-unit>
        <trans-unit id="1ee74a393ded0f5a9715105cabc63616fc14f639" translate="yes" xml:space="preserve">
          <source>Note that if extra WAL files which are not required to recover the backup are present, they will not be checked by this tool, although a separate invocation of &lt;code&gt;pg_waldump&lt;/code&gt; could be used for that purpose. Also note that WAL verification is version-specific: you must use the version of &lt;code&gt;pg_verifybackup&lt;/code&gt;, and thus of &lt;code&gt;pg_waldump&lt;/code&gt;, which pertains to the backup being checked. In contrast, the data file integrity checks should work with any version of the server that generates a &lt;code&gt;backup_manifest&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a560da48a0c3eebe2ee9e445e8f80b7a7c072449" translate="yes" xml:space="preserve">
          <source>Note that if the left-hand expression yields null, or if there are no equal right-hand values and at least one right-hand expression yields null, the result of the &lt;code&gt;IN&lt;/code&gt; construct will be null, not false. This is in accordance with SQL's normal rules for Boolean combinations of null values.</source>
          <target state="translated">请注意，如果左侧表达式产生null，或者没有相等的右侧值并且至少一个右侧表达式产生null，则 &lt;code&gt;IN&lt;/code&gt; 构造的结果将为null，而不是false。这符合SQL的空值布尔组合的常规规则。</target>
        </trans-unit>
        <trans-unit id="0c5f4c3fbdd65353e1a71d55f99ee8748d4b0fa1" translate="yes" xml:space="preserve">
          <source>Note that if the left-hand expression yields null, or if there are no equal right-hand values and at least one right-hand expression yields null, the result of the &lt;code&gt;NOT IN&lt;/code&gt; construct will be null, not true as one might naively expect. This is in accordance with SQL's normal rules for Boolean combinations of null values.</source>
          <target state="translated">请注意，如果左侧表达式的结果为null，或者如果没有相等的右侧表达式的结果并且至少一个右侧表达式的结果为null，则 &lt;code&gt;NOT IN&lt;/code&gt; 构造的结果将为null，这可能不是天真的期望。这符合SQL的空值布尔组合的常规规则。</target>
        </trans-unit>
        <trans-unit id="3770b570045d24672e81b92be3b78c98e0908b47" translate="yes" xml:space="preserve">
          <source>Note that if the left-hand expression yields null, or if there are no equal right-hand values and at least one right-hand row yields null, the result of the &lt;code&gt;IN&lt;/code&gt; construct will be null, not false. This is in accordance with SQL's normal rules for Boolean combinations of null values.</source>
          <target state="translated">请注意，如果左侧表达式的结果为null，或者右侧不相等，并且至少一个右侧行的结果为null，则 &lt;code&gt;IN&lt;/code&gt; 构造的结果将为null，而不是false。这符合SQL的空值布尔组合的常规规则。</target>
        </trans-unit>
        <trans-unit id="95d9a10f36eb36219f7c3566abef0868c3a7a8f8" translate="yes" xml:space="preserve">
          <source>Note that if the left-hand expression yields null, or if there are no equal right-hand values and at least one right-hand row yields null, the result of the &lt;code&gt;NOT IN&lt;/code&gt; construct will be null, not true. This is in accordance with SQL's normal rules for Boolean combinations of null values.</source>
          <target state="translated">请注意，如果左侧表达式产生空值，或者没有相等的右侧值并且至少一个右侧行产生空值，则 &lt;code&gt;NOT IN&lt;/code&gt; 构造的结果将为null，而不是true。这符合SQL的空值布尔组合的常规规则。</target>
        </trans-unit>
        <trans-unit id="b5695d0e24822e1a46463dd2f7c72886d58ca728" translate="yes" xml:space="preserve">
          <source>Note that if there are no successes and at least one right-hand row yields null for the operator's result, the result of the &lt;code&gt;ANY&lt;/code&gt; construct will be null, not false. This is in accordance with SQL's normal rules for Boolean combinations of null values.</source>
          <target state="translated">请注意，如果没有成功，并且至少右手一行的运算符结果为null，则 &lt;code&gt;ANY&lt;/code&gt; 构造的结果将为null，而不是false。这符合SQL的空值布尔组合的常规规则。</target>
        </trans-unit>
        <trans-unit id="f74d4f9409b75f18ec02eb7363768188eed257dd" translate="yes" xml:space="preserve">
          <source>Note that if you use this option currently, you probably also want the dump be in &lt;code&gt;INSERT&lt;/code&gt; format, as the &lt;code&gt;COPY FROM&lt;/code&gt; during restore does not support row security.</source>
          <target state="translated">请注意，如果当前使用此选项，则可能还希望转储为 &lt;code&gt;INSERT&lt;/code&gt; 格式，因为还原期间的 &lt;code&gt;COPY FROM&lt;/code&gt; 不支持行安全性。</target>
        </trans-unit>
        <trans-unit id="76b5be5ae69de8a00f81a37774ba0bddbcd592c1" translate="yes" xml:space="preserve">
          <source>Note that in a standard-conforming string literal, &lt;code&gt;\&lt;/code&gt; just means &lt;code&gt;\&lt;/code&gt; anyway. This parameter only affects the handling of non-standard-conforming literals, including escape string syntax (&lt;code&gt;E'...'&lt;/code&gt;).</source>
          <target state="translated">请注意，在符合标准的字符串文字中， &lt;code&gt;\&lt;/code&gt; 始终表示 &lt;code&gt;\&lt;/code&gt; 。此参数仅影响对不符合标准的文字的处理，包括转义字符串语法（ &lt;code&gt;E'...'&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="23bc72830133f60c02bed8bfbe946fd178dc8663" translate="yes" xml:space="preserve">
          <source>Note that in some macOS versions, &lt;em&gt;all five&lt;/em&gt; shared-memory parameters must be set in &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;, else the values will be ignored.</source>
          <target state="translated">请注意，在某些macOS版本中，必须在 &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 中设置&lt;em&gt;所有五个&lt;/em&gt;共享内存参数，否则将忽略这些值。</target>
        </trans-unit>
        <trans-unit id="7d63d2dbef5cb198e7018e15f160e61a7a98bae4" translate="yes" xml:space="preserve">
          <source>Note that in the latter case the &lt;code&gt;COLLATE&lt;/code&gt; clause is attached to an input argument of the operator we wish to affect. It doesn't matter which argument of the operator or function call the &lt;code&gt;COLLATE&lt;/code&gt; clause is attached to, because the collation that is applied by the operator or function is derived by considering all arguments, and an explicit &lt;code&gt;COLLATE&lt;/code&gt; clause will override the collations of all other arguments. (Attaching non-matching &lt;code&gt;COLLATE&lt;/code&gt; clauses to more than one argument, however, is an error. For more details see &lt;a href=&quot;collation&quot;&gt;Section 23.2&lt;/a&gt;.) Thus, this gives the same result as the previous example:</source>
          <target state="translated">注意，在后一种情况下， &lt;code&gt;COLLATE&lt;/code&gt; 子句附加到我们希望影响的运算符的输入参数上。附加到 &lt;code&gt;COLLATE&lt;/code&gt; 子句的运算符或函数的自变量无关紧要，因为运算符或函数所应用的排序规则是通过考虑所有自变量而派生的，而显式 &lt;code&gt;COLLATE&lt;/code&gt; 子句将覆盖所有其他的排序规则论点。 （但是，将不匹配的 &lt;code&gt;COLLATE&lt;/code&gt; 子句附加到多个参数上是一个错误。有关更多详细信息，请参见&lt;a href=&quot;collation&quot;&gt;23.2节&lt;/a&gt;。）因此，这给出的结果与前面的示例相同：</target>
        </trans-unit>
        <trans-unit id="a84d7bddb80d9016bd6c4bee8fb7ca51415943a4" translate="yes" xml:space="preserve">
          <source>Note that in this mode, the server will apply WAL one file at a time, so if you use the standby server for queries (see Hot Standby), there is a delay between an action in the master and when the action becomes visible in the standby, corresponding the time it takes to fill up the WAL file. &lt;code&gt;archive_timeout&lt;/code&gt; can be used to make that delay shorter. Also note that you can't combine streaming replication with this method.</source>
          <target state="translated">请注意，在这种模式下，服务器将一次应用WAL一个文件，因此，如果您使用备用服务器进行查询（请参阅热备），则主服务器中的操作与该操作在服务器中可见之间会有一定的延迟。备用，对应于填充WAL文件所需的时间。 &lt;code&gt;archive_timeout&lt;/code&gt; 可用于缩短延迟时间。另请注意，您不能将流复制与此方法结合使用。</target>
        </trans-unit>
        <trans-unit id="8a1638c843cb47802240a66e163419411cf8f8a8" translate="yes" xml:space="preserve">
          <source>Note that in this mode, the server will apply WAL one file at a time, so if you use the standby server for queries (see Hot Standby), there is a delay between an action in the master and when the action becomes visible in the standby, corresponding to the time it takes to fill up the WAL file. &lt;code&gt;archive_timeout&lt;/code&gt; can be used to make that delay shorter. Also note that you can't combine streaming replication with this method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4405d800f3ae0d5fa272786ae62fc932fc40328" translate="yes" xml:space="preserve">
          <source>Note that in this syntax, &lt;code&gt;BINARY&lt;/code&gt; and &lt;code&gt;CSV&lt;/code&gt; are treated as independent keywords, not as arguments of a &lt;code&gt;FORMAT&lt;/code&gt; option.</source>
          <target state="translated">请注意，在此语法中， &lt;code&gt;BINARY&lt;/code&gt; 和 &lt;code&gt;CSV&lt;/code&gt; 被视为独立的关键字，而不是 &lt;code&gt;FORMAT&lt;/code&gt; 选项的参数。</target>
        </trans-unit>
        <trans-unit id="a52e8eceb78cffa4749cb6c0e0ac81c842683dee" translate="yes" xml:space="preserve">
          <source>Note that it is currently not supported by &lt;code&gt;postgres_fdw&lt;/code&gt; to prepare the remote transaction for two-phase commit.</source>
          <target state="translated">请注意， &lt;code&gt;postgres_fdw&lt;/code&gt; 当前不支持为两阶段提交准备远程事务。</target>
        </trans-unit>
        <trans-unit id="5bf276b552e113c8aa30767266df52ef9cf60275" translate="yes" xml:space="preserve">
          <source>Note that it is currently not supported for the &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clause of an &lt;code&gt;INSERT&lt;/code&gt; applied to a partitioned table to update the partition key of a conflicting row such that it requires the row be moved to a new partition.</source>
          <target state="translated">请注意，当前不支持将 &lt;code&gt;INSERT&lt;/code&gt; 的 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 子句应用于已分区表以更新冲突行的分区键，从而需要将该行移至新分区。</target>
        </trans-unit>
        <trans-unit id="1def70c0867779a85dc5cf9834ec9df5745ab872" translate="yes" xml:space="preserve">
          <source>Note that it is entirely up to the access method to ensure that it correctly finds all and only the entries passing all the given scan keys. Also, the core system will simply hand off all the &lt;code&gt;WHERE&lt;/code&gt; clauses that match the index keys and operator families, without any semantic analysis to determine whether they are redundant or contradictory. As an example, given &lt;code&gt;WHERE x &amp;gt; 4 AND x &amp;gt; 14&lt;/code&gt; where &lt;code&gt;x&lt;/code&gt; is a b-tree indexed column, it is left to the b-tree &lt;code&gt;amrescan&lt;/code&gt; function to realize that the first scan key is redundant and can be discarded. The extent of preprocessing needed during &lt;code&gt;amrescan&lt;/code&gt; will depend on the extent to which the index access method needs to reduce the scan keys to a &amp;ldquo;normalized&amp;rdquo; form.</source>
          <target state="translated">请注意，完全取决于访问方法来确保它正确找到所有并且仅找到通过所有给定扫描键的条目。同样，核心系统将简单地交出所有与索引键和运算符系列匹配的 &lt;code&gt;WHERE&lt;/code&gt; 子句，而无需进行任何语义分析来确定它们是多余的还是矛盾的。例如，给定 &lt;code&gt;WHERE x &amp;gt; 4 AND x &amp;gt; 14&lt;/code&gt; 其中 &lt;code&gt;x&lt;/code&gt; 是b树索引列，将其留给b树 &lt;code&gt;amrescan&lt;/code&gt; 函数以实现第一个扫描键是多余的并且可以丢弃。 &lt;code&gt;amrescan&lt;/code&gt; 期间所需的预处理程度将取决于索引访问方法将扫描密钥减少为&amp;ldquo;规范化&amp;rdquo;形式的程度。</target>
        </trans-unit>
        <trans-unit id="873ebf4f2aa65167f1962a321c4caa0aa6923fed" translate="yes" xml:space="preserve">
          <source>Note that it is permitted for an access method to implement only &lt;code&gt;amgetbitmap&lt;/code&gt; and not &lt;code&gt;amgettuple&lt;/code&gt;, or vice versa, if its internal implementation is unsuited to one API or the other.</source>
          <target state="translated">请注意，如果访问方法的内部实现不适合某个API或其他API ，则允许该访问方法仅实现 &lt;code&gt;amgetbitmap&lt;/code&gt; 而不实现 &lt;code&gt;amgettuple&lt;/code&gt; ，反之亦然。</target>
        </trans-unit>
        <trans-unit id="0eac953a1d1c9a171b24393d7da1daab96fde8aa" translate="yes" xml:space="preserve">
          <source>Note that it is possible that pre-existing options of the foreign-data wrapper, or of dependent servers, user mappings, or foreign tables, are invalid according to the new validator. PostgreSQL does not check for this. It is up to the user to make sure that these options are correct before using the modified foreign-data wrapper. However, any options specified in this &lt;code&gt;ALTER FOREIGN DATA WRAPPER&lt;/code&gt; command will be checked using the new validator.</source>
          <target state="translated">请注意，根据新的验证器，外部数据包装程序或从属服务器，用户映射或外部表的预先存在的选项可能无效。PostgreSQL不检查这一点。在使用修改后的外部数据包装程序之前，用户需要确保这些选项正确。但是，将使用新的验证器检查此 &lt;code&gt;ALTER FOREIGN DATA WRAPPER&lt;/code&gt; 命令中指定的任何选项。</target>
        </trans-unit>
        <trans-unit id="54f1f1ea0bfe92e9a92461b1d9eddd8c8bc5388c" translate="yes" xml:space="preserve">
          <source>Note that it is possible to create array values containing null values even when this variable is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">注意，即使 &lt;code&gt;off&lt;/code&gt; 此变量，也可以创建包含空值的数组值。</target>
        </trans-unit>
        <trans-unit id="e482ec43ca141e91073df95564c36e7944046093" translate="yes" xml:space="preserve">
          <source>Note that it would not make much sense to test a non-schema-qualified type name in this way &amp;mdash; if the name can be recognized at all, it must be visible.</source>
          <target state="translated">请注意，以这种方式测试非模式限定的类型名称没有多大意义-如果可以完全识别该名称，则该名称必须可见。</target>
        </trans-unit>
        <trans-unit id="1aef4a22f764ee40b1bcb8140980923ce0f949fc" translate="yes" xml:space="preserve">
          <source>Note that it's quite possible for two objects to be linked by more than one &lt;code&gt;pg_depend&lt;/code&gt; entry. For example, a child partitioned index would have both a partition-type dependency on its associated partition table, and an auto dependency on each column of that table that it indexes. This sort of situation expresses the union of multiple dependency semantics. A dependent object can be dropped without &lt;code&gt;CASCADE&lt;/code&gt; if any of its dependencies satisfies its condition for automatic dropping. Conversely, all the dependencies' restrictions about which objects must be dropped together must be satisfied.</source>
          <target state="translated">请注意，两个对象很有可能通过一个以上的 &lt;code&gt;pg_depend&lt;/code&gt; 条目链接。例如，子分区索引将对其关联的分区表具有分区类型的依赖关系，并且对其索引的该表的每一列将具有自动依赖关系。这种情况表示多重依赖语义的并集。如果一个依赖对象的任何依赖关系都满足其自动删除的条件，则可以不使用 &lt;code&gt;CASCADE&lt;/code&gt; 删除该依赖对象。相反，必须满足所有依赖关系有关必须将哪些对象放在一起的限制。</target>
        </trans-unit>
        <trans-unit id="7a633bec827cd5945acb13add9ef3e8ab355704d" translate="yes" xml:space="preserve">
          <source>Note that late binding was the only behavior supported in PostgreSQL releases before 8.1, so you might need to do this to preserve the semantics of old applications.</source>
          <target state="translated">请注意,晚期绑定是PostgreSQL在8.1之前发布的版本中唯一支持的行为,所以你可能需要这样做来保留旧应用程序的语义。</target>
        </trans-unit>
        <trans-unit id="f498abb4a796a1a75315ef84efac83b6642a42d1" translate="yes" xml:space="preserve">
          <source>Note that libpq uses the SAM-compatible name if no explicit user name is specified. If you use libpq or a driver based on it, you should leave this option disabled or explicitly specify user name in the connection string.</source>
          <target state="translated">请注意,如果没有指定明确的用户名,libpq会使用与SAM兼容的名称。如果你使用libpq或基于libpq的驱动程序,你应该禁用这个选项,或者在连接字符串中明确指定用户名。</target>
        </trans-unit>
        <trans-unit id="743714bf2d851c6ffde333b305cc76acb3b1f4e3" translate="yes" xml:space="preserve">
          <source>Note that loading a large number of rows using &lt;code&gt;COPY&lt;/code&gt; is almost always faster than using &lt;code&gt;INSERT&lt;/code&gt;, even if &lt;code&gt;PREPARE&lt;/code&gt; is used and multiple insertions are batched into a single transaction.</source>
          <target state="translated">请注意，即使使用 &lt;code&gt;PREPARE&lt;/code&gt; 并且将多个插入批处理到单个事务中，使用 &lt;code&gt;COPY&lt;/code&gt; 装载大量行几乎总是比使用 &lt;code&gt;INSERT&lt;/code&gt; 更快。</target>
        </trans-unit>
        <trans-unit id="42e8e431b9942cab90fba21d1a0369e9ad613d53" translate="yes" xml:space="preserve">
          <source>Note that locale names are specific to the operating system, so that the above commands might not work in the same way everywhere.</source>
          <target state="translated">请注意,locale名称是特定于操作系统的,因此上述命令可能在各地的工作方式不尽相同。</target>
        </trans-unit>
        <trans-unit id="a9b85d99902345f4af7308b01a61dc7702db748b" translate="yes" xml:space="preserve">
          <source>Note that not all SQL commands are able to work on inheritance hierarchies. Commands that are used for data querying, data modification, or schema modification (e.g., &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, most variants of &lt;code&gt;ALTER TABLE&lt;/code&gt;, but not &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;ALTER TABLE ... RENAME&lt;/code&gt;) typically default to including child tables and support the &lt;code&gt;ONLY&lt;/code&gt; notation to exclude them. Commands that do database maintenance and tuning (e.g., &lt;code&gt;REINDEX&lt;/code&gt;, &lt;code&gt;VACUUM&lt;/code&gt;) typically only work on individual, physical tables and do not support recursing over inheritance hierarchies. The respective behavior of each individual command is documented in its reference page (&lt;a href=&quot;https://www.postgresql.org/docs/12/sql-commands.html&quot;&gt;SQL Commands&lt;/a&gt;).</source>
          <target state="translated">请注意，并非所有的SQL命令都可以在继承层次结构上工作。通常，用于数据查询，数据修改或模式修改的命令（例如 &lt;code&gt;SELECT&lt;/code&gt; ， &lt;code&gt;UPDATE&lt;/code&gt; ， &lt;code&gt;DELETE&lt;/code&gt; ， &lt;code&gt;ALTER TABLE&lt;/code&gt; 的大多数变体，而不是 &lt;code&gt;INSERT&lt;/code&gt; 或 &lt;code&gt;ALTER TABLE ... RENAME&lt;/code&gt; ）通常默认包含子表并 &lt;code&gt;ONLY&lt;/code&gt; 支持表示法排除它们。执行数据库维护和调整的命令（例如 &lt;code&gt;REINDEX&lt;/code&gt; ， &lt;code&gt;VACUUM&lt;/code&gt; ）通常只能在单个物理表上使用，并且不支持在继承层次结构上递归。每个单独命令的各自行为记录在其参考页（&lt;a href=&quot;https://www.postgresql.org/docs/12/sql-commands.html&quot;&gt;SQL命令&lt;/a&gt;）中。</target>
        </trans-unit>
        <trans-unit id="327ef47ac3644ee0b774c6ef4fdf9e2c60c4fad3" translate="yes" xml:space="preserve">
          <source>Note that not all SQL commands are able to work on inheritance hierarchies. Commands that are used for data querying, data modification, or schema modification (e.g., &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, most variants of &lt;code&gt;ALTER TABLE&lt;/code&gt;, but not &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;ALTER TABLE ... RENAME&lt;/code&gt;) typically default to including child tables and support the &lt;code&gt;ONLY&lt;/code&gt; notation to exclude them. Commands that do database maintenance and tuning (e.g., &lt;code&gt;REINDEX&lt;/code&gt;, &lt;code&gt;VACUUM&lt;/code&gt;) typically only work on individual, physical tables and do not support recursing over inheritance hierarchies. The respective behavior of each individual command is documented in its reference page (&lt;a href=&quot;https://www.postgresql.org/docs/13/sql-commands.html&quot;&gt;SQL Commands&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a5e9d67d623aca716181f6ec9cb80abc27268bb" translate="yes" xml:space="preserve">
          <source>Note that object keys are compared in their storage order; in particular, since shorter keys are stored before longer keys, this can lead to results that might be unintuitive, such as:</source>
          <target state="translated">请注意,对象键是按其存储顺序进行比较的;特别是,由于较短的键存储在较长的键之前,这可能会导致一些不直观的结果,例如:</target>
        </trans-unit>
        <trans-unit id="c0b32073b6d3e410922a70ee12709380a01c6753" translate="yes" xml:space="preserve">
          <source>Note that older clients might lack support for the SCRAM authentication mechanism, and hence not work with passwords encrypted with SCRAM-SHA-256. See &lt;a href=&quot;auth-password&quot;&gt;Section 20.5&lt;/a&gt; for more details.</source>
          <target state="translated">请注意，较旧的客户端可能缺乏对SCRAM身份验证机制的支持，因此不适用于使用SCRAM-SHA-256加密的密码。有关更多详细信息，请参见&lt;a href=&quot;auth-password&quot;&gt;第20.5节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a9b3d09d3d6340576d5c998f6421491652b39ecd" translate="yes" xml:space="preserve">
          <source>Note that only updating transactions might need to be retried; read-only transactions will never have serialization conflicts.</source>
          <target state="translated">请注意,只有更新事务可能需要重试,只读事务永远不会有序列化冲突。</target>
        </trans-unit>
        <trans-unit id="2954af76eca7ba35f68a0a8d801d4249462c8089" translate="yes" xml:space="preserve">
          <source>Note that ordering options apply only to the expression they follow; for example &lt;code&gt;ORDER BY x, y DESC&lt;/code&gt; does not mean the same thing as &lt;code&gt;ORDER BY x DESC, y DESC&lt;/code&gt;.</source>
          <target state="translated">注意，排序选项仅适用于它们遵循的表达式。例如 &lt;code&gt;ORDER BY x, y DESC&lt;/code&gt; 与 &lt;code&gt;ORDER BY x DESC, y DESC&lt;/code&gt; 含义不同。</target>
        </trans-unit>
        <trans-unit id="b1c2c8127025345a934a6314a2f889673aacbd3b" translate="yes" xml:space="preserve">
          <source>Note that parallel queries may consume very substantially more resources than non-parallel queries, because each worker process is a completely separate process which has roughly the same impact on the system as an additional user session. This should be taken into account when choosing a value for this setting, as well as when configuring other settings that control resource utilization, such as &lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt;work_mem&lt;/a&gt;. Resource limits such as &lt;code&gt;work_mem&lt;/code&gt; are applied individually to each worker, which means the total utilization may be much higher across all processes than it would normally be for any single process. For example, a parallel query using 4 workers may use up to 5 times as much CPU time, memory, I/O bandwidth, and so forth as a query which uses no workers at all.</source>
          <target state="translated">请注意，并行查询可能比非并行查询消耗更多的资源，因为每个工作进程都是完全独立的进程，与其他用户会话相比，对系统的影响大致相同。在选择此设置的值以及配置其他控制资源利用率的设置（例如&lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt;work_mem）&lt;/a&gt;时，应考虑到这一点。资源限制（例如 &lt;code&gt;work_mem&lt;/code&gt; )分别应用于每个工作人员，这意味着所有进程的总利用率可能比任何单个进程的正常情况都要高得多。例如，使用4个工作程序的并行查询所使用的CPU时间，内存，I / O带宽等最多可能是不使用任何工作程序的查询的5倍。</target>
        </trans-unit>
        <trans-unit id="03d17cb56c53d9a14510ff412e2277014674b9c7" translate="yes" xml:space="preserve">
          <source>Note that parallel utility commands should not consume substantially more memory than equivalent non-parallel operations. This strategy differs from that of parallel query, where resource limits generally apply per worker process. Parallel utility commands treat the resource limit &lt;code&gt;maintenance_work_mem&lt;/code&gt; as a limit to be applied to the entire utility command, regardless of the number of parallel worker processes. However, parallel utility commands may still consume substantially more CPU resources and I/O bandwidth.</source>
          <target state="translated">请注意，并行实用程序命令不应比等效的非并行操作消耗更多的内存。此策略不同于并行查询的策略，在并行查询中，资源限制通常适用于每个工作进程。并行实用程序命令将资源限制 &lt;code&gt;maintenance_work_mem&lt;/code&gt; 视为要应用于整个实用程序命令的限制，而与并行工作进程的数量无关。但是，并行实用程序命令可能仍会消耗大量CPU资源和I / O带宽。</target>
        </trans-unit>
        <trans-unit id="1c3896a4097aefd43e61d30f8ed6fc4608d53683" translate="yes" xml:space="preserve">
          <source>Note that partition pruning is driven only by the constraints defined implicitly by the partition keys, not by the presence of indexes. Therefore it isn't necessary to define indexes on the key columns. Whether an index needs to be created for a given partition depends on whether you expect that queries that scan the partition will generally scan a large part of the partition or just a small part. An index will be helpful in the latter case but not the former.</source>
          <target state="translated">请注意,分区修剪只由分区键隐式定义的约束驱动,而不是由索引的存在驱动。因此没有必要在键列上定义索引。是否需要为给定的分区创建索引,取决于你期望扫描该分区的查询一般会扫描该分区的大部分还是只扫描一小部分。索引在后一种情况下会有帮助,但在前一种情况下则没有帮助。</target>
        </trans-unit>
        <trans-unit id="c526234778414186549c3a732294e28ea6360814" translate="yes" xml:space="preserve">
          <source>Note that pg_dump will set &lt;code&gt;row_security&lt;/code&gt; to &lt;code&gt;OFF&lt;/code&gt; by default, to ensure all contents of a table are dumped out. If the user running pg_dump does not have appropriate permissions, an error will be returned. However, superusers and the owner of the table being dumped always bypass RLS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8457004be1bd2121d647641e3e2f206401f9ee82" translate="yes" xml:space="preserve">
          <source>Note that revoking this privilege will not alter the existence or location of existing objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aed232352821561d7f4d97b0cbed4bb08fe3a2ef" translate="yes" xml:space="preserve">
          <source>Note that roles are defined at the database cluster level, and so are valid in all databases in the cluster.</source>
          <target state="translated">请注意,角色是在数据库集群级别定义的,因此在集群中的所有数据库中都有效。</target>
        </trans-unit>
        <trans-unit id="746fd0d5f2f710a9b186a9ef98779e17d15fa9db" translate="yes" xml:space="preserve">
          <source>Note that tablespace directories are not cleaned up either way.</source>
          <target state="translated">请注意,无论哪种方式都不会清理表空间目录。</target>
        </trans-unit>
        <trans-unit id="d1d5538437b8defc93f56eee03304e310c0c5042" translate="yes" xml:space="preserve">
          <source>Note that the &amp;ldquo;actual time&amp;rdquo; values are in milliseconds of real time, whereas the &lt;code&gt;cost&lt;/code&gt; estimates are expressed in arbitrary units; so they are unlikely to match up. The thing that's usually most important to look for is whether the estimated row counts are reasonably close to reality. In this example the estimates were all dead-on, but that's quite unusual in practice.</source>
          <target state="translated">请注意，&amp;ldquo;实际时间&amp;rdquo;值以毫秒为单位，而 &lt;code&gt;cost&lt;/code&gt; 估算则以任意单位表示；因此他们不太可能匹配。通常最重要的事情是估计的行数是否合理地接近实际。在此示例中，估算值都是固定的，但是在实践中这是非常不寻常的。</target>
        </trans-unit>
        <trans-unit id="9e220f4fc878ea43d3bad6e0a739b4b79c17d896" translate="yes" xml:space="preserve">
          <source>Note that the &amp;ldquo;best match&amp;rdquo; rules are identical for operator and function type resolution. Some examples follow.</source>
          <target state="translated">请注意，&amp;ldquo;最佳匹配&amp;rdquo;规则对于运算符和函数类型解析是相同的。以下是一些示例。</target>
        </trans-unit>
        <trans-unit id="ef1701ee0df5df14d039148f316d2e4d2b8aa8fd" translate="yes" xml:space="preserve">
          <source>Note that the &amp;ldquo;same as&amp;rdquo; operator, &lt;code&gt;~=&lt;/code&gt;, represents the usual notion of equality for the &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, and &lt;code&gt;circle&lt;/code&gt; types. Some of the geometric types also have an &lt;code&gt;=&lt;/code&gt; operator, but &lt;code&gt;=&lt;/code&gt; compares for equal &lt;em&gt;areas&lt;/em&gt; only. The other scalar comparison operators (&lt;code&gt;&amp;lt;=&lt;/code&gt; and so on), where available for these types, likewise compare areas.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68a397047ec4388fcee29b79f7e608c05447ff76" translate="yes" xml:space="preserve">
          <source>Note that the &amp;ldquo;same as&amp;rdquo; operator, &lt;code&gt;~=&lt;/code&gt;, represents the usual notion of equality for the &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, and &lt;code&gt;circle&lt;/code&gt; types. Some of these types also have an &lt;code&gt;=&lt;/code&gt; operator, but &lt;code&gt;=&lt;/code&gt; compares for equal &lt;em&gt;areas&lt;/em&gt; only. The other scalar comparison operators (&lt;code&gt;&amp;lt;=&lt;/code&gt; and so on) likewise compare areas for these types.</source>
          <target state="translated">请注意，&amp;ldquo;等于&amp;rdquo;运算符 &lt;code&gt;~=&lt;/code&gt; 表示 &lt;code&gt;point&lt;/code&gt; ， &lt;code&gt;box&lt;/code&gt; ， &lt;code&gt;polygon&lt;/code&gt; 和 &lt;code&gt;circle&lt;/code&gt; 类型的通常相等概念。其中一些类型还具有 &lt;code&gt;=&lt;/code&gt; 运算符，但 &lt;code&gt;=&lt;/code&gt; 仅对相等的&lt;em&gt;区域&lt;/em&gt;进行比较。其他标量比较运算符（ &lt;code&gt;&amp;lt;=&lt;/code&gt; 等）也比较这些类型的面积。</target>
        </trans-unit>
        <trans-unit id="3f9568498993be48d548609f8f99b58407bdc0b5" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;CHECK OPTION&lt;/code&gt; is only supported on views that are automatically updatable, and do not have &lt;code&gt;INSTEAD OF&lt;/code&gt; triggers or &lt;code&gt;INSTEAD&lt;/code&gt; rules. If an automatically updatable view is defined on top of a base view that has &lt;code&gt;INSTEAD OF&lt;/code&gt; triggers, then the &lt;code&gt;LOCAL CHECK OPTION&lt;/code&gt; may be used to check the conditions on the automatically updatable view, but the conditions on the base view with &lt;code&gt;INSTEAD OF&lt;/code&gt; triggers will not be checked (a cascaded check option will not cascade down to a trigger-updatable view, and any check options defined directly on a trigger-updatable view will be ignored). If the view or any of its base relations has an &lt;code&gt;INSTEAD&lt;/code&gt; rule that causes the &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; command to be rewritten, then all check options will be ignored in the rewritten query, including any checks from automatically updatable views defined on top of the relation with the &lt;code&gt;INSTEAD&lt;/code&gt; rule.</source>
          <target state="translated">请注意， &lt;code&gt;CHECK OPTION&lt;/code&gt; 仅在可自动更新且不具有 &lt;code&gt;INSTEAD OF&lt;/code&gt; 触发器或 &lt;code&gt;INSTEAD&lt;/code&gt; 规则的视图上受支持。如果在具有 &lt;code&gt;INSTEAD OF&lt;/code&gt; 触发器的基本视图之上定义了自动更新视图，则可以使用 &lt;code&gt;LOCAL CHECK OPTION&lt;/code&gt; 检查自动更新视图上的条件，但是具有 &lt;code&gt;INSTEAD OF&lt;/code&gt; 触发器的基本视图上的条件将不会被检查（级联的检查选项不会级联到触发可更新的视图，并且直接在触发可更新的视图上定义的任何检查选项都将被忽略）。如果视图或其任何基本关系具有 &lt;code&gt;INSTEAD&lt;/code&gt; 规则，导致 &lt;code&gt;INSERT&lt;/code&gt; 要重写的INSERT或 &lt;code&gt;UPDATE&lt;/code&gt; 命令，那么在重写的查询中所有检查选项都将被忽略，包括来自在具有 &lt;code&gt;INSTEAD&lt;/code&gt; 规则的关系之上定义的自动可更新视图中的所有检查。</target>
        </trans-unit>
        <trans-unit id="048b814d4fde306f95eb514ec96249604d0f3baf" translate="yes" xml:space="preserve">
          <source>Note that the checksum depends on the block number, so matching block numbers should be passed (except when doing esoteric debugging).</source>
          <target state="translated">需要注意的是,校验和取决于块号,所以应该通过匹配的块号(除了做深奥的调试时)。</target>
        </trans-unit>
        <trans-unit id="8c92d729af687d63d61faa7693bb18cfc4db6007" translate="yes" xml:space="preserve">
          <source>Note that the command is invoked by the shell, so if you need to pass any arguments to shell command that come from an untrusted source, you must be careful to strip or escape any special characters that might have a special meaning for the shell. For security reasons, it is best to use a fixed command string, or at least avoid passing any user input in it.</source>
          <target state="translated">请注意,该命令是由shell调用的,所以如果你需要向shell命令传递任何来自不受信任来源的参数,你必须小心剥离或转义任何可能对shell有特殊意义的特殊字符。出于安全考虑,最好使用固定的命令字符串,或者至少避免在其中传递任何用户输入。</target>
        </trans-unit>
        <trans-unit id="95e2592cd121958603de591b16676dfd151d7385" translate="yes" xml:space="preserve">
          <source>Note that the effects of all per-row &lt;code&gt;BEFORE INSERT&lt;/code&gt; triggers are reflected in &lt;code&gt;excluded&lt;/code&gt; values, since those effects may have contributed to the row being excluded from insertion.</source>
          <target state="translated">请注意，所有每行&amp;ldquo; &lt;code&gt;BEFORE INSERT&lt;/code&gt; 触发器的影响都反映在 &lt;code&gt;excluded&lt;/code&gt; 值中，因为这些影响可能导致该行被排除在插入之外。</target>
        </trans-unit>
        <trans-unit id="5d831510235276a5c3036f14f7c31dd0c8581fc2" translate="yes" xml:space="preserve">
          <source>Note that the first item on any non-rightmost page (any page with a non-zero value in the &lt;code&gt;btpo_next&lt;/code&gt; field) is the page's &amp;ldquo;high key&amp;rdquo;, meaning its &lt;code&gt;data&lt;/code&gt; serves as an upper bound on all items appearing on the page, while its &lt;code&gt;ctid&lt;/code&gt; field does not point to another block. Also, on internal pages, the first real data item (the first item that is not a high key) reliably has every column truncated away, leaving no actual value in its &lt;code&gt;data&lt;/code&gt; field. Such an item does have a valid downlink in its &lt;code&gt;ctid&lt;/code&gt; field, however.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e212873009117f62fcd9c668559d87771494a3ea" translate="yes" xml:space="preserve">
          <source>Note that the first item on any non-rightmost page (any page with a non-zero value in the &lt;code&gt;btpo_next&lt;/code&gt; field) is the page's &amp;ldquo;high key&amp;rdquo;, meaning its &lt;code&gt;data&lt;/code&gt; serves as an upper bound on all items appearing on the page, while its &lt;code&gt;ctid&lt;/code&gt; field is meaningless. Also, on non-leaf pages, the first real data item (the first item that is not a high key) is a &amp;ldquo;minus infinity&amp;rdquo; item, with no actual value in its &lt;code&gt;data&lt;/code&gt; field. Such an item does have a valid downlink in its &lt;code&gt;ctid&lt;/code&gt; field, however.</source>
          <target state="translated">请注意，任何非最右边页面上的第一项（任何在 &lt;code&gt;btpo_next&lt;/code&gt; 字段中具有非零值的页面）都是页面的&amp;ldquo;高键&amp;rdquo;，这意味着其 &lt;code&gt;data&lt;/code&gt; 用作页面上出现的所有项目的上限，而它的 &lt;code&gt;ctid&lt;/code&gt; 字段是没有意义的。另外，在非叶子页上，第一个实际数据项（不是高键的第一个项目）是&amp;ldquo;负无穷大&amp;rdquo;项，其 &lt;code&gt;data&lt;/code&gt; 字段中没有实际值。但是，此类项目的 &lt;code&gt;ctid&lt;/code&gt; 字段中确实具有有效的下行链路。</target>
        </trans-unit>
        <trans-unit id="535954ca2908fbda93be1ed4d604a5a38ff7249d" translate="yes" xml:space="preserve">
          <source>Note that the following sections describe the behavior of the builtin &lt;code&gt;heap&lt;/code&gt;&lt;a href=&quot;tableam&quot;&gt;table access method&lt;/a&gt;, and the builtin &lt;a href=&quot;https://www.postgresql.org/docs/12/indexam.html&quot;&gt;index access methods&lt;/a&gt;. Due to the extensible nature of PostgreSQL, other access methods might work differently.</source>
          <target state="translated">请注意，以下各节描述了内置 &lt;code&gt;heap&lt;/code&gt; &lt;a href=&quot;tableam&quot;&gt;表访问方法&lt;/a&gt;和内置&lt;a href=&quot;https://www.postgresql.org/docs/12/indexam.html&quot;&gt;索引访问方法的行为&lt;/a&gt;。由于PostgreSQL的可扩展性，其他访问方法可能会有所不同。</target>
        </trans-unit>
        <trans-unit id="b97c4406cd03632c5651253443e7276d76c22605" translate="yes" xml:space="preserve">
          <source>Note that the following sections describe the behavior of the builtin &lt;code&gt;heap&lt;/code&gt;&lt;a href=&quot;tableam&quot;&gt;table access method&lt;/a&gt;, and the builtin &lt;a href=&quot;https://www.postgresql.org/docs/13/indexam.html&quot;&gt;index access methods&lt;/a&gt;. Due to the extensible nature of PostgreSQL, other access methods might work differently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ff99b02bab93b2bce6ccdae00e15d7def0f0061" translate="yes" xml:space="preserve">
          <source>Note that the locale behavior of the server is determined by the environment variables seen by the server, not by the environment of any client. Therefore, be careful to configure the correct locale settings before starting the server. A consequence of this is that if client and server are set up in different locales, messages might appear in different languages depending on where they originated.</source>
          <target state="translated">请注意,服务器的locale行为是由服务器看到的环境变量决定的,而不是由任何客户端的环境决定的。因此,在启动服务器之前,请注意配置正确的locale设置。这样做的后果是,如果客户端和服务器设置在不同的地区,消息可能会根据它们的来源以不同的语言出现。</target>
        </trans-unit>
        <trans-unit id="07d471153d0c31d19d3a687501b18f85b42ddbd4" translate="yes" xml:space="preserve">
          <source>Note that the only supported &lt;a href=&quot;auth-methods&quot;&gt;authentication methods&lt;/a&gt; for use with GSSAPI encryption are &lt;code&gt;gss&lt;/code&gt;, &lt;code&gt;reject&lt;/code&gt;, and &lt;code&gt;trust&lt;/code&gt;.</source>
          <target state="translated">请注意，与GSSAPI加密一起使用的唯一受支持的&lt;a href=&quot;auth-methods&quot;&gt;身份验证方法&lt;/a&gt;是 &lt;code&gt;gss&lt;/code&gt; ， &lt;code&gt;reject&lt;/code&gt; 和 &lt;code&gt;trust&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1ad926ce9c3e21892b3792f7b8c1dbecab3b69d" translate="yes" xml:space="preserve">
          <source>Note that the operator precedence rules also apply to user-defined operators that have the same names as the built-in operators mentioned above. For example, if you define a &amp;ldquo;+&amp;rdquo; operator for some custom data type it will have the same precedence as the built-in &amp;ldquo;+&amp;rdquo; operator, no matter what yours does.</source>
          <target state="translated">请注意，运算符优先级规则也适用于与上述内置运算符同名的用户定义的运算符。例如，如果您为某些自定义数据类型定义&amp;ldquo; +&amp;rdquo;运算符，则无论您做什么，其优先级都与内置&amp;ldquo; +&amp;rdquo;运算符相同。</target>
        </trans-unit>
        <trans-unit id="c8f86dee03c6b505a272324fb9a4a25b4a43909d" translate="yes" xml:space="preserve">
          <source>Note that the ordering options are considered independently for each sort column. For example &lt;code&gt;ORDER BY x, y DESC&lt;/code&gt; means &lt;code&gt;ORDER BY x ASC, y DESC&lt;/code&gt;, which is not the same as &lt;code&gt;ORDER BY x DESC, y DESC&lt;/code&gt;.</source>
          <target state="translated">请注意，对于每个排序列，都将单独考虑排序选项。例如， &lt;code&gt;ORDER BY x, y DESC&lt;/code&gt; 表示 &lt;code&gt;ORDER BY x ASC, y DESC&lt;/code&gt; ，这与 &lt;code&gt;ORDER BY x DESC, y DESC&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2d7f74d4ba0ae61a9bd9e94f45d68a74a955765" translate="yes" xml:space="preserve">
          <source>Note that the parser automatically understands that &lt;code&gt;TRUE&lt;/code&gt; and &lt;code&gt;FALSE&lt;/code&gt; are of type &lt;code&gt;boolean&lt;/code&gt;, but this is not so for &lt;code&gt;NULL&lt;/code&gt; because that can have any type. So in some contexts you might have to cast &lt;code&gt;NULL&lt;/code&gt; to &lt;code&gt;boolean&lt;/code&gt; explicitly, for example &lt;code&gt;NULL::boolean&lt;/code&gt;. Conversely, the cast can be omitted from a string-literal Boolean value in contexts where the parser can deduce that the literal must be of type &lt;code&gt;boolean&lt;/code&gt;.</source>
          <target state="translated">请注意，解析器会自动理解 &lt;code&gt;TRUE&lt;/code&gt; 和 &lt;code&gt;FALSE&lt;/code&gt; 是 &lt;code&gt;boolean&lt;/code&gt; 类型，但对于 &lt;code&gt;NULL&lt;/code&gt; 而言并非如此，因为它可以具有任何类型。因此，在某些情况下，你可能要投 &lt;code&gt;NULL&lt;/code&gt; 到 &lt;code&gt;boolean&lt;/code&gt; 明确，例如 &lt;code&gt;NULL::boolean&lt;/code&gt; 。相反，在解析器可以推断文字必须为 &lt;code&gt;boolean&lt;/code&gt; 类型的上下文中，可以从字符串文字布尔值中省略强制类型转换。</target>
        </trans-unit>
        <trans-unit id="6830af538ea3d4def0017ebca2cb9eb811ef481a" translate="yes" xml:space="preserve">
          <source>Note that the password prompt will occur again for each database to be dumped. Usually, it's better to set up a &lt;code&gt;~/.pgpass&lt;/code&gt; file than to rely on manual password entry.</source>
          <target state="translated">请注意，对于每个要转储的数据库，将再次出现密码提示。通常，设置 &lt;code&gt;~/.pgpass&lt;/code&gt; 文件比依靠手动密码输入更好。</target>
        </trans-unit>
        <trans-unit id="42ada1c8e6a6026750e361cb5d7ba311ef045adc" translate="yes" xml:space="preserve">
          <source>Note that the query planner does not consider deferring the evaluation of parallel-restricted functions or aggregates involved in the query in order to obtain a superior plan. So, for example, if a &lt;code&gt;WHERE&lt;/code&gt; clause applied to a particular table is parallel restricted, the query planner will not consider performing a scan of that table in the parallel portion of a plan. In some cases, it would be possible (and perhaps even efficient) to include the scan of that table in the parallel portion of the query and defer the evaluation of the &lt;code&gt;WHERE&lt;/code&gt; clause so that it happens above the &lt;code&gt;Gather&lt;/code&gt; node. However, the planner does not do this.</source>
          <target state="translated">请注意，查询计划者不会考虑为了获得上级计划而推迟对查询中涉及的并行限制函数或集合的求值。因此，例如，如果并行限制了应用于特定表的 &lt;code&gt;WHERE&lt;/code&gt; 子句，则查询计划者将不考虑在计划的并行部分中对该表进行扫描。在某些情况下，有可能（甚至可能有效）将对该表的扫描包括在查询的并行部分中，并推迟对 &lt;code&gt;WHERE&lt;/code&gt; 子句的求值，使其发生在 &lt;code&gt;Gather&lt;/code&gt; 节点之上。但是，计划者不会这样做。</target>
        </trans-unit>
        <trans-unit id="5f4f575c0dfc110a613df4c8c43c09b6bc17afc4" translate="yes" xml:space="preserve">
          <source>Note that the single-user mode server does not provide sophisticated line-editing features (no command history, for example). Single-user mode also does not do any background processing, such as automatic checkpoints or replication.</source>
          <target state="translated">请注意,单用户模式的服务器不提供复杂的行编辑功能(例如,没有命令历史记录)。单用户模式也不做任何后台处理,如自动检查点或复制。</target>
        </trans-unit>
        <trans-unit id="542b405bccbd1dfc2248044e2da7018d901a07e8" translate="yes" xml:space="preserve">
          <source>Note that the unique key on this catalog is (&lt;code&gt;collname&lt;/code&gt;, &lt;code&gt;collencoding&lt;/code&gt;, &lt;code&gt;collnamespace&lt;/code&gt;) not just (&lt;code&gt;collname&lt;/code&gt;, &lt;code&gt;collnamespace&lt;/code&gt;). PostgreSQL generally ignores all collations that do not have &lt;code&gt;collencoding&lt;/code&gt; equal to either the current database's encoding or -1, and creation of new entries with the same name as an entry with &lt;code&gt;collencoding&lt;/code&gt; = -1 is forbidden. Therefore it is sufficient to use a qualified SQL name (&lt;code&gt;schema&lt;/code&gt;.&lt;code&gt;name&lt;/code&gt;) to identify a collation, even though this is not unique according to the catalog definition. The reason for defining the catalog this way is that initdb fills it in at cluster initialization time with entries for all locales available on the system, so it must be able to hold entries for all encodings that might ever be used in the cluster.</source>
          <target state="translated">请注意，此目录上的唯一键是（ &lt;code&gt;collname&lt;/code&gt; ， &lt;code&gt;collencoding&lt;/code&gt; ， &lt;code&gt;collnamespace&lt;/code&gt; ）而不仅仅是（ &lt;code&gt;collname&lt;/code&gt; ， &lt;code&gt;collnamespace&lt;/code&gt; ）。 PostgreSQL通常会忽略所有 &lt;code&gt;collencoding&lt;/code&gt; 不等于当前数据库编码或-1的归类，并且禁止创建与 &lt;code&gt;collencoding&lt;/code&gt; = -1 相同名称的新条目。因此，这是足够使用一个合格的SQL名（ &lt;code&gt;schema&lt;/code&gt; 。 &lt;code&gt;name&lt;/code&gt; ）来识别排序规则，即使根据目录定义这不是唯一的。用这种方式定义目录的原因是initdb在集群初始化时使用系统上所有可用语言环境的条目来填充它，因此它必须能够容纳集群中可能使用过的所有编码的条目。</target>
        </trans-unit>
        <trans-unit id="57816233be3efc2c0b4b0cdc3b84a0dda807639d" translate="yes" xml:space="preserve">
          <source>Note that the user performing the insert, update or delete on the view must have the corresponding insert, update or delete privilege on the view. In addition the view's owner must have the relevant privileges on the underlying base relations, but the user performing the update does not need any permissions on the underlying base relations (see &lt;a href=&quot;https://www.postgresql.org/docs/12/rules-privileges.html&quot;&gt;Section 40.5&lt;/a&gt;).</source>
          <target state="translated">请注意，在视图上执行插入，更新或删除的用户必须在视图上具有相应的插入，更新或删除特权。另外，视图的所有者必须对基础基本关系具有相关的特权，但是执行更新的用户不需要对基础基本关系的任何许可（请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/rules-privileges.html&quot;&gt;第40.5节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="52e6a2ffb8f6a4ee70000d58285441af2239687a" translate="yes" xml:space="preserve">
          <source>Note that the user performing the insert, update or delete on the view must have the corresponding insert, update or delete privilege on the view. In addition the view's owner must have the relevant privileges on the underlying base relations, but the user performing the update does not need any permissions on the underlying base relations (see &lt;a href=&quot;https://www.postgresql.org/docs/13/rules-privileges.html&quot;&gt;Section 40.5&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f758ecc8993acb3505a10e1f0f3118a15da20e0" translate="yes" xml:space="preserve">
          <source>Note that the white space on each line is actually a tab character.</source>
          <target state="translated">请注意,每行的白色空间实际上是一个制表符。</target>
        </trans-unit>
        <trans-unit id="f2961d22f06a0ed36b2caf77fbad086d6c0a84ff" translate="yes" xml:space="preserve">
          <source>Note that there are some limitations in an online backup from the standby:</source>
          <target state="translated">需要注意的是,在从备用的在线备份中存在一些限制。</target>
        </trans-unit>
        <trans-unit id="4d288b29e3c118d6d8c73403f59b3896205eea76" translate="yes" xml:space="preserve">
          <source>Note that there are some limitations in taking a backup from a standby:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad0151522b3b77d6456a32b223d7660f4475e688" translate="yes" xml:space="preserve">
          <source>Note that there is no &lt;code&gt;CREATE ROUTINE&lt;/code&gt; command.</source>
          <target state="translated">请注意，没有 &lt;code&gt;CREATE ROUTINE&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="a1d66a79704a8f138a556c34b5e710e75580d121" translate="yes" xml:space="preserve">
          <source>Note that there needs to be at least one permissive policy to grant access to records before restrictive policies can be usefully used to reduce that access. If only restrictive policies exist, then no records will be accessible. When a mix of permissive and restrictive policies are present, a record is only accessible if at least one of the permissive policies passes, in addition to all the restrictive policies.</source>
          <target state="translated">请注意,在有效利用限制性政策减少访问之前,至少需要有一项允许访问记录的政策。如果只存在限制性政策,那么任何记录都不能被访问。当存在允许性政策和限制性政策的混合时,除了所有的限制性政策外,只有至少有一个允许性政策通过,记录才能被访问。</target>
        </trans-unit>
        <trans-unit id="95b9e36ae86d5f4054bebe05afb0d0ec344eb9ad" translate="yes" xml:space="preserve">
          <source>Note that these potentially produce a lot of data, which needs to be built up in memory. When requesting content mappings of large schemas or databases, it might be worthwhile to consider mapping the tables separately instead, possibly even through a cursor.</source>
          <target state="translated">请注意,这些可能会产生大量的数据,这些数据需要在内存中建立起来。当请求大型模式或数据库的内容映射时,可能值得考虑分别映射表,甚至可能通过游标。</target>
        </trans-unit>
        <trans-unit id="b8effb15698d614b121eab24d0dff7bc4e7c22a6" translate="yes" xml:space="preserve">
          <source>Note that this actually means &amp;ldquo;revoke all privileges that I granted&amp;rdquo;.</source>
          <target state="translated">请注意，这实际上意味着&amp;ldquo;撤销我授予的所有特权&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="a377102624b4be7d75b74040aea8858a414e0fc7" translate="yes" xml:space="preserve">
          <source>Note that this behavior is consistent with other popular implementations of host name-based access control, such as the Apache HTTP Server and TCP Wrappers.</source>
          <target state="translated">请注意,这种行为与其他流行的基于主机名的访问控制实现一致,例如Apache HTTP Server和TCP Wrappers。</target>
        </trans-unit>
        <trans-unit id="765730fc2ec6d6848cd71e4c2044c699075b50df" translate="yes" xml:space="preserve">
          <source>Note that this command is subtly different from the server-side &lt;code&gt;lo_import&lt;/code&gt; because it acts as the local user on the local file system, rather than the server's user and file system.</source>
          <target state="translated">请注意，此命令与服务器端 &lt;code&gt;lo_import&lt;/code&gt; 略有不同，因为它充当本地文件系统上的本地用户，而不是服务器的用户和文件系统。</target>
        </trans-unit>
        <trans-unit id="0f8fb90970b8968e4f7127f317566345b970df55" translate="yes" xml:space="preserve">
          <source>Note that this doesn't affect any existing rows in the table, it just changes the default for future &lt;code&gt;INSERT&lt;/code&gt; commands.</source>
          <target state="translated">请注意，这不会影响表中的任何现有行，而只是更改以后的 &lt;code&gt;INSERT&lt;/code&gt; 命令的默认值。</target>
        </trans-unit>
        <trans-unit id="56e3b32d061c366fed83bd98f4d4590767c40034" translate="yes" xml:space="preserve">
          <source>Note that this is different from</source>
          <target state="translated">请注意,这不同于</target>
        </trans-unit>
        <trans-unit id="9e5d1d4e065e9c7dc21ef91bf768d68d3c9d8a1d" translate="yes" xml:space="preserve">
          <source>Note that this is not the same as the left-to-right &amp;ldquo;short-circuiting&amp;rdquo; of Boolean operators that is found in some programming languages.</source>
          <target state="translated">请注意，这与在某些编程语言中发现的布尔运算符从左到右的&amp;ldquo;短路&amp;rdquo;不同。</target>
        </trans-unit>
        <trans-unit id="ca51a28e46507688c57df1dccd9f468de8996aae" translate="yes" xml:space="preserve">
          <source>Note that this option currently also requires the dump be in &lt;code&gt;INSERT&lt;/code&gt; format, as &lt;code&gt;COPY FROM&lt;/code&gt; does not support row security.</source>
          <target state="translated">请注意，此选项当前还要求转储为 &lt;code&gt;INSERT&lt;/code&gt; 格式，因为 &lt;code&gt;COPY FROM&lt;/code&gt; 不支持行安全性。</target>
        </trans-unit>
        <trans-unit id="9da43a46207df32c5bc41dc69140b018443cc610" translate="yes" xml:space="preserve">
          <source>Note that this option is incompatible with the &lt;code&gt;--index&lt;/code&gt; and &lt;code&gt;--system&lt;/code&gt; options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddb5224f9cf66b54a71c646c3cd12c1c98805d5f" translate="yes" xml:space="preserve">
          <source>Note that this option only affects the exact form &lt;code&gt;= NULL&lt;/code&gt;, not other comparison operators or other expressions that are computationally equivalent to some expression involving the equals operator (such as &lt;code&gt;IN&lt;/code&gt;). Thus, this option is not a general fix for bad programming.</source>
          <target state="translated">请注意，此选项仅影响精确的形式 &lt;code&gt;= NULL&lt;/code&gt; ，不影响其他比较运算符或其他在计算上等同于包含equals运算符的表达式（例如 &lt;code&gt;IN&lt;/code&gt; ）的表达式。因此，此选项不是错误编程的常规解决方案。</target>
        </trans-unit>
        <trans-unit id="e47f160f4c862fafa44c7f19b4f7d0d78fd15669" translate="yes" xml:space="preserve">
          <source>Note that this option will remain set for the entire session, and so it affects uses of the meta-command &lt;code&gt;\connect&lt;/code&gt; as well as the initial connection attempt.</source>
          <target state="translated">请注意，此选项将在整个会话中保持设置状态，因此会影响元命令 &lt;code&gt;\connect&lt;/code&gt; 使用以及初始连接尝试。</target>
        </trans-unit>
        <trans-unit id="9cb49d36842c28bbc6961c206fc6fb511f408fc8" translate="yes" xml:space="preserve">
          <source>Note that this query cannot use this index:</source>
          <target state="translated">注意,这个查询不能使用这个索引。</target>
        </trans-unit>
        <trans-unit id="eeb09f3d3f513d7242e768b40d1a3d7a48755d6c" translate="yes" xml:space="preserve">
          <source>Note that this setting only affects the main shared memory area. Operating systems such as Linux, FreeBSD, and Illumos can also use huge pages (also known as &amp;ldquo;super&amp;rdquo; pages or &amp;ldquo;large&amp;rdquo; pages) automatically for normal memory allocation, without an explicit request from PostgreSQL. On Linux, this is called &amp;ldquo;transparent huge pages&amp;rdquo; (THP). That feature has been known to cause performance degradation with PostgreSQL for some users on some Linux versions, so its use is currently discouraged (unlike explicit use of &lt;code&gt;huge_pages&lt;/code&gt;).</source>
          <target state="translated">请注意，此设置仅影响主共享存储区。诸如Linux，FreeBSD和Illumos之类的操作系统也可以自动使用大页面（也称为&amp;ldquo;超级&amp;rdquo;页面或&amp;ldquo;大&amp;rdquo;页面）进行常规内存分配，而无需PostgreSQL的明确要求。在Linux上，这称为&amp;ldquo;透明大页面&amp;rdquo;（THP）。已知该功能会导致某些Linux版本上的某些用户使用PostgreSQL降低性能，因此，目前不鼓励使用PostgreSQL（与显式使用 &lt;code&gt;huge_pages&lt;/code&gt; 不同）。</target>
        </trans-unit>
        <trans-unit id="601d111715a6b1b59291397e0542ab5aa27f6545" translate="yes" xml:space="preserve">
          <source>Note that this view does not include memory allocated using the dynamic shared memory infrastructure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="906c24642d7c9d1ccf94ab876f98cee1fa64d503" translate="yes" xml:space="preserve">
          <source>Note that this way the connection from &lt;code&gt;shell.foo.com&lt;/code&gt; to &lt;code&gt;db.foo.com&lt;/code&gt; will not be encrypted by the SSH tunnel. SSH offers quite a few configuration possibilities when the network is restricted in various ways. Please refer to the SSH documentation for details.</source>
          <target state="translated">请注意，SSH隧道不会加密从 &lt;code&gt;shell.foo.com&lt;/code&gt; 到 &lt;code&gt;db.foo.com&lt;/code&gt; 的连接。当以各种方式限制网络时，SSH提供了许多配置可能性。有关详细信息，请参阅SSH文档。</target>
        </trans-unit>
        <trans-unit id="aed9a462aeaf6aae78a53a2e55aac5e3c16613ab" translate="yes" xml:space="preserve">
          <source>Note that this will result in locking all rows of &lt;code&gt;mytable&lt;/code&gt;, whereas &lt;code&gt;FOR UPDATE&lt;/code&gt; at the top level would lock only the actually returned rows. This can make for a significant performance difference, particularly if the &lt;code&gt;ORDER BY&lt;/code&gt; is combined with &lt;code&gt;LIMIT&lt;/code&gt; or other restrictions. So this technique is recommended only if concurrent updates of the ordering columns are expected and a strictly sorted result is required.</source>
          <target state="translated">请注意，这将导致锁定 &lt;code&gt;mytable&lt;/code&gt; 的所有行，而顶级的 &lt;code&gt;FOR UPDATE&lt;/code&gt; 将仅锁定实际返回的行。这可能会导致明显的性能差异，特别是如果将 &lt;code&gt;ORDER BY&lt;/code&gt; 与 &lt;code&gt;LIMIT&lt;/code&gt; 或其他限制结合使用。因此，仅当期望并发更新排序列并且需要严格排序的结果时才建议使用此技术。</target>
        </trans-unit>
        <trans-unit id="59d9533d6b1ff70587da7945ccc9db2ea583f449" translate="yes" xml:space="preserve">
          <source>Note that two rows are displayed for the same column, one corresponding to the complete inheritance hierarchy starting at the &lt;code&gt;road&lt;/code&gt; table (&lt;code&gt;inherited&lt;/code&gt;=&lt;code&gt;t&lt;/code&gt;), and another one including only the &lt;code&gt;road&lt;/code&gt; table itself (&lt;code&gt;inherited&lt;/code&gt;=&lt;code&gt;f&lt;/code&gt;).</source>
          <target state="translated">请注意，同一列显示了两行，其中一行对应于从 &lt;code&gt;road&lt;/code&gt; 表开始的完整继承层次结构（ &lt;code&gt;inherited&lt;/code&gt; = &lt;code&gt;t&lt;/code&gt; ），另一行仅包括 &lt;code&gt;road&lt;/code&gt; 表本身（ &lt;code&gt;inherited&lt;/code&gt; = &lt;code&gt;f&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="10e9b0e25eb4f44f89bb51356ad1df0c93761c8b" translate="yes" xml:space="preserve">
          <source>Note that unlike most catalogs with a &amp;ldquo;namespace&amp;rdquo; column, &lt;code&gt;extnamespace&lt;/code&gt; is not meant to imply that the extension belongs to that schema. Extension names are never schema-qualified. Rather, &lt;code&gt;extnamespace&lt;/code&gt; indicates the schema that contains most or all of the extension's objects. If &lt;code&gt;extrelocatable&lt;/code&gt; is true, then this schema must in fact contain all schema-qualifiable objects belonging to the extension.</source>
          <target state="translated">请注意，与大多数带有&amp;ldquo;名称空间&amp;rdquo;列的目录不同， &lt;code&gt;extnamespace&lt;/code&gt; 并不意味着暗指该扩展名属于该架构。扩展名从不使用架构限定。相反， &lt;code&gt;extnamespace&lt;/code&gt; 指示包含大多数或所有扩展对象的架构。如果 &lt;code&gt;extrelocatable&lt;/code&gt; 为true，则此架构实际上必须包含属于该扩展的所有符合架构的对象。</target>
        </trans-unit>
        <trans-unit id="95d30679c93680a49476e594a17f9119213eea89" translate="yes" xml:space="preserve">
          <source>Note that unlike the &lt;code&gt;cube&lt;/code&gt;-based part of the module, units are hardwired here: changing the &lt;code&gt;earth()&lt;/code&gt; function will not affect the results of this operator.</source>
          <target state="translated">请注意，与模块的基于 &lt;code&gt;cube&lt;/code&gt; 的部分不同，此处的单元是硬接线的：更改 &lt;code&gt;earth()&lt;/code&gt; 函数不会影响此运算符的结果。</target>
        </trans-unit>
        <trans-unit id="aec424e8783da60644af6ec05ea73b5e181a5ff9" translate="yes" xml:space="preserve">
          <source>Note that using &lt;code&gt;ldapscheme&lt;/code&gt; or &lt;code&gt;ldaptls&lt;/code&gt; only encrypts the traffic between the PostgreSQL server and the LDAP server. The connection between the PostgreSQL server and the PostgreSQL client will still be unencrypted unless SSL is used there as well.</source>
          <target state="translated">请注意，使用 &lt;code&gt;ldapscheme&lt;/code&gt; 或 &lt;code&gt;ldaptls&lt;/code&gt; 仅加密PostgreSQL服务器和LDAP服务器之间的通信。除非在那里也使用SSL，否则PostgreSQL服务器与PostgreSQL客户端之间的连接仍然不会被加密。</target>
        </trans-unit>
        <trans-unit id="f4e11f3a6327ed7b6ce66ef2d86de4e055bd13dd" translate="yes" xml:space="preserve">
          <source>Note that using this mode together with the &lt;code&gt;-f&lt;/code&gt; (&lt;code&gt;FULL&lt;/code&gt;) option might cause deadlock failures if certain system catalogs are processed in parallel.</source>
          <target state="translated">请注意，如果并行处理某些系统目录，则将此模式与 &lt;code&gt;-f&lt;/code&gt; （ &lt;code&gt;FULL&lt;/code&gt; ）选项一起使用可能会导致死锁失败。</target>
        </trans-unit>
        <trans-unit id="f608b76c0c846a43652d18d27b367a743ac19721" translate="yes" xml:space="preserve">
          <source>Note that weight labels apply to &lt;em&gt;positions&lt;/em&gt;, not &lt;em&gt;lexemes&lt;/em&gt;. If the input vector has been stripped of positions then &lt;code&gt;setweight&lt;/code&gt; does nothing.</source>
          <target state="translated">请注意，权重标签适用于&lt;em&gt;位置&lt;/em&gt;，而不适用于&lt;em&gt;词位&lt;/em&gt;。如果输入向量已去除位置，则 &lt;code&gt;setweight&lt;/code&gt; 不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="a501f50ad867471d366c858d1e68c08c9bf71a3b" translate="yes" xml:space="preserve">
          <source>Note that when &lt;code&gt;ANALYZE&lt;/code&gt; is run on a partitioned table, all of its partitions are also recursively analyzed as also mentioned in &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt;. In that case, &lt;code&gt;ANALYZE&lt;/code&gt; progress is reported first for the parent table, whereby its inheritance statistics are collected, followed by that for each partition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fb0133d2b01bcc98921dcbe4b4f3b20ca215976" translate="yes" xml:space="preserve">
          <source>Note that when an ACL entry in another catalog is null, it is taken to represent the hard-wired default privileges for its object, &lt;em&gt;not&lt;/em&gt; whatever might be in &lt;code&gt;pg_default_acl&lt;/code&gt; at the moment. &lt;code&gt;pg_default_acl&lt;/code&gt; is only consulted during object creation.</source>
          <target state="translated">请注意，当另一个目录中的ACL条目为null时，它将被用来表示其对象的硬连接默认特权，&lt;em&gt;而不是&lt;/em&gt; &lt;code&gt;pg_default_acl&lt;/code&gt; 中的任何特权。 &lt;code&gt;pg_default_acl&lt;/code&gt; 仅在对象创建期间被查询。</target>
        </trans-unit>
        <trans-unit id="2e6cf1460524f06f7b596e4f9001c12f09f21277" translate="yes" xml:space="preserve">
          <source>Note that when autovacuum runs, up to &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MAX-WORKERS&quot;&gt;autovacuum_max_workers&lt;/a&gt; times this memory may be allocated, so be careful not to set the default value too high. It may be useful to control for this by separately setting &lt;a href=&quot;runtime-config-resource#GUC-AUTOVACUUM-WORK-MEM&quot;&gt;autovacuum_work_mem&lt;/a&gt;.</source>
          <target state="translated">请注意，在运行&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MAX-WORKERS&quot;&gt;autovacuum&lt;/a&gt;时，最多可以分配autovacuum_max_workers乘以该内存，因此请注意不要将默认值设置得太高。通过单独设置&lt;a href=&quot;runtime-config-resource#GUC-AUTOVACUUM-WORK-MEM&quot;&gt;autovacuum_work_mem&lt;/a&gt;对此进行控制可能很有用。</target>
        </trans-unit>
        <trans-unit id="b298d8fd9d5a27445f1547b4987f220ddf522324" translate="yes" xml:space="preserve">
          <source>Note that when multiple rewrite rules are applied in this way, the order of application can be important; so in practice you will want the source query to &lt;code&gt;ORDER BY&lt;/code&gt; some ordering key.</source>
          <target state="translated">请注意，以这种方式应用多个重写规则时，应用的顺序可能很重要。因此在实践中，您将希望源查询通过一些排序键进行 &lt;code&gt;ORDER BY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="15b117a19d6af07c7a1d926814d3fa7ed429f962" translate="yes" xml:space="preserve">
          <source>Note that when using nondefault WAL segment sizes, the numbers in the WAL file names are different from the LSNs that are reported by system functions and system views. This option takes a WAL file name, not an LSN.</source>
          <target state="translated">请注意,当使用非默认WAL段大小时,WAL文件名中的数字与系统函数和系统视图报告的LSN不同。这个选项使用WAL文件名,而不是LSN。</target>
        </trans-unit>
        <trans-unit id="5091d99db40796ae0ac6a127a75124d1c7974a77" translate="yes" xml:space="preserve">
          <source>Note that while &lt;code&gt;COPY&lt;/code&gt; allows options such as &lt;code&gt;HEADER&lt;/code&gt; to be specified without a corresponding value, the foreign table option syntax requires a value to be present in all cases. To activate &lt;code&gt;COPY&lt;/code&gt; options typically written without a value, you can pass the value TRUE, since all such options are Booleans.</source>
          <target state="translated">请注意，虽然 &lt;code&gt;COPY&lt;/code&gt; 允许指定诸如 &lt;code&gt;HEADER&lt;/code&gt; 之类的选项而没有相应的值，但外部表选项语法要求在所有情况下都必须存在一个值。要激活通常不带值的 &lt;code&gt;COPY&lt;/code&gt; 选项，可以传递值TRUE，因为所有此类选项均为布尔值。</target>
        </trans-unit>
        <trans-unit id="20e2ed64775c1454506227ebe10642431813ecd2" translate="yes" xml:space="preserve">
          <source>Note that while a table's filenode often matches its OID, this is &lt;em&gt;not&lt;/em&gt; necessarily the case; some operations, like &lt;code&gt;TRUNCATE&lt;/code&gt;, &lt;code&gt;REINDEX&lt;/code&gt;, &lt;code&gt;CLUSTER&lt;/code&gt; and some forms of &lt;code&gt;ALTER TABLE&lt;/code&gt;, can change the filenode while preserving the OID. Avoid assuming that filenode and table OID are the same. Also, for certain system catalogs including &lt;code&gt;pg_class&lt;/code&gt; itself, &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relfilenode&lt;/code&gt; contains zero. The actual filenode number of these catalogs is stored in a lower-level data structure, and can be obtained using the &lt;code&gt;pg_relation_filenode()&lt;/code&gt; function.</source>
          <target state="translated">请注意，尽管表的文件节点通常与它的OID匹配，但&lt;em&gt;并不&lt;/em&gt;一定是如此。一些操作，例如 &lt;code&gt;TRUNCATE&lt;/code&gt; ， &lt;code&gt;REINDEX&lt;/code&gt; ， &lt;code&gt;CLUSTER&lt;/code&gt; 和某些形式的 &lt;code&gt;ALTER TABLE&lt;/code&gt; ，可以在保留OID的同时更改文件节点。避免假定filenode和表OID相同。另外，对于某些系统目录，包括 &lt;code&gt;pg_class&lt;/code&gt; 本身， &lt;code&gt;pg_class&lt;/code&gt; 。 &lt;code&gt;relfilenode&lt;/code&gt; 包含零。这些目录的实际文件节点号存储在较低级别的数据结构中，可以使用 &lt;code&gt;pg_relation_filenode()&lt;/code&gt; 函数获得。</target>
        </trans-unit>
        <trans-unit id="acd42ff3a7dd119700e6cb55e96c90dc5e6fd840" translate="yes" xml:space="preserve">
          <source>Note that while rows can be moved from local partitions to a foreign-table partition (provided the foreign data wrapper supports tuple routing), they cannot be moved from a foreign-table partition to another partition.</source>
          <target state="translated">请注意,虽然行可以从本地分区移动到外表分区(前提是外表数据封装器支持元组路由),但它们不能从外表分区移动到另一个分区。</target>
        </trans-unit>
        <trans-unit id="2d8be16bebefaea4da0b18cb12ca9511981a5205" translate="yes" xml:space="preserve">
          <source>Note that while the above will indeed grant all privileges if executed by a superuser or the owner of &lt;code&gt;kinds&lt;/code&gt;, when executed by someone else it will only grant those permissions for which the someone else has grant options.</source>
          <target state="translated">请注意，尽管上述内容的确会由超级用户或 &lt;code&gt;kinds&lt;/code&gt; 所有者执行，但会授予所有特权，但在由其他人执行时，它只会授予其他人具有授予选项的权限。</target>
        </trans-unit>
        <trans-unit id="ec3a83831ac9036a3595c6ce5f5e7350a4e67363" translate="yes" xml:space="preserve">
          <source>Note that while this system allows creating collations that &amp;ldquo;ignore case&amp;rdquo; or &amp;ldquo;ignore accents&amp;rdquo; or similar (using the &lt;code&gt;ks&lt;/code&gt; key), in order for such collations to act in a truly case- or accent-insensitive manner, they also need to be declared as not &lt;em&gt;deterministic&lt;/em&gt; in &lt;code&gt;CREATE COLLATION&lt;/code&gt;; see &lt;a href=&quot;collation#COLLATION-NONDETERMINISTIC&quot;&gt;Section 23.2.2.4&lt;/a&gt;. Otherwise, any strings that compare equal according to the collation but are not byte-wise equal will be sorted according to their byte values.</source>
          <target state="translated">请注意，虽然此系统允许创建&amp;ldquo;忽略大小写&amp;rdquo;或&amp;ldquo;忽略重音符号&amp;rdquo;或类似内容（使用 &lt;code&gt;ks&lt;/code&gt; 键）的归类，但要使这些归类以真正不区分大小写或不区分重音的方式起作用，它们也必须在 &lt;code&gt;CREATE COLLATION&lt;/code&gt; 中被声明为&lt;em&gt;确定性的&lt;/em&gt; ; 参见&lt;a href=&quot;collation#COLLATION-NONDETERMINISTIC&quot;&gt;第23.2.2.4节&lt;/a&gt;。否则，根据排序规则比较相等但按字节排序不相等的任何字符串将根据其字节值进行排序。</target>
        </trans-unit>
        <trans-unit id="84595e2b092724cd7800c2af7679de35fbd01caf" translate="yes" xml:space="preserve">
          <source>Note that with any of these methods, attempting to prewarm more blocks than can be cached &amp;mdash; by the OS when using &lt;code&gt;prefetch&lt;/code&gt; or &lt;code&gt;read&lt;/code&gt;, or by PostgreSQL when using &lt;code&gt;buffer&lt;/code&gt; &amp;mdash; will likely result in lower-numbered blocks being evicted as higher numbered blocks are read in. Prewarmed data also enjoys no special protection from cache evictions, so it is possible that other system activity may evict the newly prewarmed blocks shortly after they are read; conversely, prewarming may also evict other data from cache. For these reasons, prewarming is typically most useful at startup, when caches are largely empty.</source>
          <target state="translated">请注意，使用这些方法中的任何一种，如果尝试预热比可缓存的块更多的块（由OS使用 &lt;code&gt;prefetch&lt;/code&gt; 或 &lt;code&gt;read&lt;/code&gt; ，或由PostgreSQL使用 &lt;code&gt;buffer&lt;/code&gt; ，则可能会导致编号较低的块被驱逐，因为读取编号较高的块预热的数据也不受高速缓存逐出的保护，因此其他系统活动可能会在读取新预热的块后不久将其逐出。相反，预热也可能会将其他数据从缓存中逐出。由于这些原因，通常在启动时（缓存大部分为空），预热通常是最有用的。</target>
        </trans-unit>
        <trans-unit id="e25d9c4fc7da6af49acba3a1d74aecf78d61de9d" translate="yes" xml:space="preserve">
          <source>Note that you can name the collation objects in the SQL environment anything you want. In this example, we follow the naming style that the predefined collations use, which in turn also follow BCP 47, but that is not required for user-defined collations.</source>
          <target state="translated">请注意,在SQL环境中,你可以对整理对象进行任何你想要的命名。在这个例子中,我们遵循预定义整理对象所使用的命名方式,反过来也遵循BCP 47,但对于用户定义的整理对象来说,这不是必须的。</target>
        </trans-unit>
        <trans-unit id="d9f6471c0f24b8d6760419402c171355a4484c03" translate="yes" xml:space="preserve">
          <source>Note that you must execute this command while logged into the PostgreSQL user account, which is described in the previous section.</source>
          <target state="translated">请注意,你必须在登录PostgreSQL用户账户的情况下执行这个命令,这一点在上一节有介绍。</target>
        </trans-unit>
        <trans-unit id="bb0a6a455313edbad71a60b25303151964bacc15" translate="yes" xml:space="preserve">
          <source>Note that you should also create an index with the default operator class if you want queries involving ordinary &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;gt;=&lt;/code&gt; comparisons to use an index. Such queries cannot use the &lt;code&gt;xxx_pattern_ops&lt;/code&gt; operator classes. (Ordinary equality comparisons can use these operator classes, however.) It is possible to create multiple indexes on the same column with different operator classes. If you do use the C locale, you do not need the &lt;code&gt;xxx_pattern_ops&lt;/code&gt; operator classes, because an index with the default operator class is usable for pattern-matching queries in the C locale.</source>
          <target state="translated">请注意，如果希望涉及普通 &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;=&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;gt;=&lt;/code&gt; 比较的查询使用索引，则还应使用默认的运算符类创建索引。这样的查询不能使用 &lt;code&gt;xxx_pattern_ops&lt;/code&gt; 运算符类。 （但是，普通相等性比较可以使用这些运算符类。）可以在具有不同运算符类的同一列上创建多个索引。如果您确实使用C语言环境，则不需要 &lt;code&gt;xxx_pattern_ops&lt;/code&gt; 运算符类，因为具有默认运算符类别的索引可用于C语言环境中的模式匹配查询。</target>
        </trans-unit>
        <trans-unit id="a9ac1561fc3ccdadc787e0b99a4aeb85f57a226f" translate="yes" xml:space="preserve">
          <source>Note that, for the purposes of combining multiple policies, &lt;code&gt;ALL&lt;/code&gt; policies are treated as having the same type as whichever other type of policy is being applied.</source>
          <target state="translated">请注意，出于组合多个策略的目的，将 &lt;code&gt;ALL&lt;/code&gt; 策略视为与所应用的任何其他类型的策略具有相同的类型。</target>
        </trans-unit>
        <trans-unit id="0ce85a00735b68da34a1fd226cafeaa370c6ae8f" translate="yes" xml:space="preserve">
          <source>Note the relatively large number of false positives: 2439 rows were selected to be visited in the heap, but none actually matched the query. We could reduce that by specifying a larger signature length. In this example, creating the index with &lt;code&gt;length=200&lt;/code&gt; reduced the number of false positives to 55; but it doubled the index size (to 306 MB) and ended up being slower for this query (125 ms overall).</source>
          <target state="translated">请注意，误报的数量相对较多：在堆中选择了2439行进行访问，但实际上没有与查询匹配的行。我们可以通过指定更大的签名长度来减少这种情况。在此示例中，创建 &lt;code&gt;length=200&lt;/code&gt; 的索引可将误报数量减少到55；但它使索引大小增加了一倍（至306 MB），并最终使该查询的速度变慢（总计125毫秒）。</target>
        </trans-unit>
        <trans-unit id="ad6486d9d7802af73d40de7a1e56de198a7926a1" translate="yes" xml:space="preserve">
          <source>Note the use of the double underline in the probe name. In a DTrace script using the probe, the double underline needs to be replaced with a hyphen, so &lt;code&gt;transaction-start&lt;/code&gt; is the name to document for users.</source>
          <target state="translated">请注意在探针名称中使用双下划线。在使用探针的DTrace脚本中，双下划线需要用连字符替换，因此 &lt;code&gt;transaction-start&lt;/code&gt; 是为用户记录的名称。</target>
        </trans-unit>
        <trans-unit id="6d65457512b308441a74c7c138c05193c57c7bb6" translate="yes" xml:space="preserve">
          <source>Note there can be ambiguity in the &lt;code&gt;months&lt;/code&gt; field returned by &lt;code&gt;age&lt;/code&gt; because different months have different numbers of days. PostgreSQL's approach uses the month from the earlier of the two dates when calculating partial months. For example, &lt;code&gt;age('2004-06-01', '2004-04-30')&lt;/code&gt; uses April to yield &lt;code&gt;1 mon 1 day&lt;/code&gt;, while using May would yield &lt;code&gt;1 mon 2 days&lt;/code&gt; because May has 31 days, while April has only 30.</source>
          <target state="translated">请注意，按 &lt;code&gt;age&lt;/code&gt; 返回的&amp;ldquo; &lt;code&gt;months&lt;/code&gt; 字段中可能存在歧义，因为不同的月有不同的天数。PostgreSQL的方法在计算部分月份时使用两个日期中较早的月份。例如， &lt;code&gt;age('2004-06-01', '2004-04-30')&lt;/code&gt; 使用April产生 &lt;code&gt;1 mon 1 day&lt;/code&gt; ，而使用May将产生 &lt;code&gt;1 mon 2 days&lt;/code&gt; 因为May拥有31天，而April只有30天。</target>
        </trans-unit>
        <trans-unit id="1afbaf202c9ac2c26c7604e3bc2b4bbf35293589" translate="yes" xml:space="preserve">
          <source>Note, however, that the SQL/MED functionality as a whole is not yet conforming.</source>
          <target state="translated">但请注意,SQL/MED的功能整体上还不符合要求。</target>
        </trans-unit>
        <trans-unit id="ccd71e26f3c643a05b48c9814bdace2e62bf73fd" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;ltxtquery&lt;/code&gt; allows whitespace between symbols, but &lt;code&gt;ltree&lt;/code&gt; and &lt;code&gt;lquery&lt;/code&gt; do not.</source>
          <target state="translated">注意： &lt;code&gt;ltxtquery&lt;/code&gt; 允许在符号之间使用空格，但是 &lt;code&gt;ltree&lt;/code&gt; 和 &lt;code&gt;lquery&lt;/code&gt; 不允许。</target>
        </trans-unit>
        <trans-unit id="b12db1dd6e1d08b3916e0fb99c42096b024c7157" translate="yes" xml:space="preserve">
          <source>Note: This index type is lossy.</source>
          <target state="translated">注意:这种索引类型是有损的。</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="9128e4dc19fdcbce3767684f6724986d863634bf" translate="yes" xml:space="preserve">
          <source>Notes for Windows Users</source>
          <target state="translated">Windows用户须知</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="070bd4d20a16681cab0fd80e64bbfd09232b5422" translate="yes" xml:space="preserve">
          <source>Notice here that we don't need to (and indeed cannot) put parentheses around the column name appearing just after &lt;code&gt;SET&lt;/code&gt;, but we do need parentheses when referencing the same column in the expression to the right of the equal sign.</source>
          <target state="translated">请注意，在这里我们不需要（实际上也不能）在 &lt;code&gt;SET&lt;/code&gt; 后面紧随出现的列名周围加上括号，但是当在表达式中等号右边引用同一列时，确实需要括号。</target>
        </trans-unit>
        <trans-unit id="4daabf40dd7349fdbfe5f996ee7218e2e875bd85" translate="yes" xml:space="preserve">
          <source>Notice how the &lt;code&gt;AS&lt;/code&gt; clause is used to relabel the output column. (The &lt;code&gt;AS&lt;/code&gt; clause is optional.)</source>
          <target state="translated">请注意如何使用 &lt;code&gt;AS&lt;/code&gt; 子句来重新标记输出列。（ &lt;code&gt;AS&lt;/code&gt; 子句是可选的。）</target>
        </trans-unit>
        <trans-unit id="6e1ea47811c08b80c4e6755f65407fcd8d137657" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;BETWEEN&lt;/code&gt; treats the endpoint values as included in the range. &lt;code&gt;BETWEEN SYMMETRIC&lt;/code&gt; is like &lt;code&gt;BETWEEN&lt;/code&gt; except there is no requirement that the argument to the left of &lt;code&gt;AND&lt;/code&gt; be less than or equal to the argument on the right. If it is not, those two arguments are automatically swapped, so that a nonempty range is always implied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faa7b0c69e4931a2ff5fa82ad77b7c14b3d74a7b" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;BETWEEN&lt;/code&gt; treats the endpoint values as included in the range. &lt;code&gt;NOT BETWEEN&lt;/code&gt; does the opposite comparison:</source>
          <target state="translated">请注意， &lt;code&gt;BETWEEN&lt;/code&gt; 将端点值视为包含在范围内。 &lt;code&gt;NOT BETWEEN&lt;/code&gt; 做相反的比较：</target>
        </trans-unit>
        <trans-unit id="8240947764f6659f2796d4acf4007ac22ad3a1c1" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;supernova star&lt;/code&gt; matches &lt;code&gt;supernovae stars&lt;/code&gt; in &lt;code&gt;thesaurus_astro&lt;/code&gt; because we specified the &lt;code&gt;english_stem&lt;/code&gt; stemmer in the thesaurus definition. The stemmer removed the &lt;code&gt;e&lt;/code&gt; and &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;supernova star&lt;/code&gt; 比赛 &lt;code&gt;supernovae stars&lt;/code&gt; 在 &lt;code&gt;thesaurus_astro&lt;/code&gt; 因为我们指定的 &lt;code&gt;english_stem&lt;/code&gt; 在词库定义词干。词干删除了 &lt;code&gt;e&lt;/code&gt; 和 &lt;code&gt;s&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="89eb1ae6972d1166d8e27e8ffc5a4983fca12820" translate="yes" xml:space="preserve">
          <source>Notice that although the recursive view's name is schema-qualified in this &lt;code&gt;CREATE&lt;/code&gt;, its internal self-reference is not schema-qualified. This is because the implicitly-created CTE's name cannot be schema-qualified.</source>
          <target state="translated">注意，尽管在此 &lt;code&gt;CREATE&lt;/code&gt; 中递归视图的名称是架构限定的，但其内部自引用不是架构限定的。这是因为隐式创建的CTE名称不能被模式限定。</target>
        </trans-unit>
        <trans-unit id="c36fb1e9faaa2ef2c027bbd666eb850c4abbeb31" translate="yes" xml:space="preserve">
          <source>Notice that except for the two-argument form of &lt;code&gt;enum_range&lt;/code&gt;, these functions disregard the specific value passed to them; they care only about its declared data type. Either null or a specific value of the type can be passed, with the same result. It is more common to apply these functions to a table column or function argument than to a hardwired type name as suggested by the examples.</source>
          <target state="translated">注意，除了 &lt;code&gt;enum_range&lt;/code&gt; 的两个参数形式之外，这些函数无视传递给它们的特定值。他们只关心其声明的数据类型。可以传递null或特定类型的值，结果相同。如示例所建议的那样，将这些函数应用于表列或函数参数比将其应用于硬连接类型名称更为常见。</target>
        </trans-unit>
        <trans-unit id="fb75cf9e722bdf4111edc3be58d21f8a3427f3ff" translate="yes" xml:space="preserve">
          <source>Notice that except for the two-argument form of &lt;code&gt;enum_range&lt;/code&gt;, these functions disregard the specific value passed to them; they care only about its declared data type. Either null or a specific value of the type can be passed, with the same result. It is more common to apply these functions to a table column or function argument than to a hardwired type name as used in the examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f7db9efeeec80f82f8d01c7d6c915db40d7ca58" translate="yes" xml:space="preserve">
          <source>Notice that here the planner has chosen to &amp;ldquo;materialize&amp;rdquo; the inner relation of the join, by putting a Materialize plan node atop it. This means that the &lt;code&gt;t2&lt;/code&gt; index scan will be done just once, even though the nested-loop join node needs to read that data ten times, once for each row from the outer relation. The Materialize node saves the data in memory as it's read, and then returns the data from memory on each subsequent pass.</source>
          <target state="translated">请注意，这里的计划者已选择通过将&amp;ldquo;实现&amp;rdquo;计划节点放置在连接的顶部来&amp;ldquo;实现&amp;rdquo;内部关系。这意味着即使嵌套循环连接节点需要读取该数据十次（对于外部关系中的每一行一次）， &lt;code&gt;t2&lt;/code&gt; 索引扫描也只会执行一次。 Materialize节点在读取数据时将其保存在内存中，然后在每次后续遍历时从内存中返回数据。</target>
        </trans-unit>
        <trans-unit id="4bf689adc2caa48f04b5854bba37632c664406c0" translate="yes" xml:space="preserve">
          <source>Notice that in both &lt;code&gt;ROWS&lt;/code&gt; and &lt;code&gt;GROUPS&lt;/code&gt; mode, &lt;code&gt;0 PRECEDING&lt;/code&gt; and &lt;code&gt;0 FOLLOWING&lt;/code&gt; are equivalent to &lt;code&gt;CURRENT ROW&lt;/code&gt;. This normally holds in &lt;code&gt;RANGE&lt;/code&gt; mode as well, for an appropriate data-type-specific meaning of &amp;ldquo;zero&amp;rdquo;.</source>
          <target state="translated">请注意，在 &lt;code&gt;ROWS&lt;/code&gt; 和 &lt;code&gt;GROUPS&lt;/code&gt; 模式下， &lt;code&gt;0 PRECEDING&lt;/code&gt; 和 &lt;code&gt;0 FOLLOWING&lt;/code&gt; 都等于 &lt;code&gt;CURRENT ROW&lt;/code&gt; 。对于适当的特定于数据类型的含义为&amp;ldquo;零&amp;rdquo;，这通常也适用于 &lt;code&gt;RANGE&lt;/code&gt; 模式。</target>
        </trans-unit>
        <trans-unit id="944ef29330d1f49189c08507e0ff3ef14adbfe93" translate="yes" xml:space="preserve">
          <source>Notice that inside the dollar-quoted string, single quotes can be used without needing to be escaped. Indeed, no characters inside a dollar-quoted string are ever escaped: the string content is always written literally. Backslashes are not special, and neither are dollar signs, unless they are part of a sequence matching the opening tag.</source>
          <target state="translated">请注意,在美元引号字符串内,可以使用单引号而不需要转义。事实上,美元引号字符串内的任何字符都不会被转义:字符串内容总是按字面意思书写。反斜线并不特殊,美元符号也不特殊,除非它们是与开头标签相匹配的序列的一部分。</target>
        </trans-unit>
        <trans-unit id="f68a4013d1520908a834c3452585e4c0680f0866" translate="yes" xml:space="preserve">
          <source>Notice that placing the restriction in the &lt;code&gt;WHERE&lt;/code&gt; clause produces a different result:</source>
          <target state="translated">注意，将限制放在 &lt;code&gt;WHERE&lt;/code&gt; 子句中会产生不同的结果：</target>
        </trans-unit>
        <trans-unit id="d13f7a26b5cfa0ec363a717ba07bad2b152f0f72" translate="yes" xml:space="preserve">
          <source>Notice that the 2-argument version of &lt;code&gt;to_tsvector&lt;/code&gt; is used. Only text search functions that specify a configuration name can be used in expression indexes (&lt;a href=&quot;indexes-expressional&quot;&gt;Section 11.7&lt;/a&gt;). This is because the index contents must be unaffected by &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config&lt;/a&gt;. If they were affected, the index contents might be inconsistent because different entries could contain &lt;code&gt;tsvector&lt;/code&gt;s that were created with different text search configurations, and there would be no way to guess which was which. It would be impossible to dump and restore such an index correctly.</source>
          <target state="translated">请注意，使用了2个参数的 &lt;code&gt;to_tsvector&lt;/code&gt; 版本。表达式索引中只能使用指定配置名称的文本搜索功能（&lt;a href=&quot;indexes-expressional&quot;&gt;第11.7节&lt;/a&gt;）。这是因为索引内容必须不受&lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config的&lt;/a&gt;影响。如果它们受到影响，则索引内容可能会不一致，因为不同的条目可能包含使用不同的文本搜索配置创建的 &lt;code&gt;tsvector&lt;/code&gt; ，并且无法猜测哪个是哪个。不可能正确转储和还原这样的索引。</target>
        </trans-unit>
        <trans-unit id="4b9c07bbe048665c89925c842ae22cd1fc6040f9" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;DROP&lt;/code&gt; syntax only specifies the &amp;ldquo;slot&amp;rdquo; in the operator family, by strategy or support number and input data type(s). The name of the operator or function occupying the slot is not mentioned. Also, for &lt;code&gt;DROP FUNCTION&lt;/code&gt; the type(s) to specify are the input data type(s) the function is intended to support; for GiST, SP-GiST and GIN indexes this might have nothing to do with the actual input argument types of the function.</source>
          <target state="translated">请注意， &lt;code&gt;DROP&lt;/code&gt; 语法仅按策略或支持编号以及输入数据类型在操作员系列中指定&amp;ldquo;插槽&amp;rdquo;。没有提及占用插槽的操作员或功能的名称。另外，对于 &lt;code&gt;DROP FUNCTION&lt;/code&gt; ，要指定的类型是该功能要支持的输入数据类型。对于GiST，SP-GiST和GIN索引，这可能与函数的实际输入参数类型无关。</target>
        </trans-unit>
        <trans-unit id="051e5841933239126fb981b1dfd93c63aee12913" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;EXPLAIN&lt;/code&gt; output shows the &lt;code&gt;WHERE&lt;/code&gt; clause being applied as a &amp;ldquo;filter&amp;rdquo; condition attached to the Seq Scan plan node. This means that the plan node checks the condition for each row it scans, and outputs only the ones that pass the condition. The estimate of output rows has been reduced because of the &lt;code&gt;WHERE&lt;/code&gt; clause. However, the scan will still have to visit all 10000 rows, so the cost hasn't decreased; in fact it has gone up a bit (by 10000 * &lt;a href=&quot;runtime-config-query#GUC-CPU-OPERATOR-COST&quot;&gt;cpu_operator_cost&lt;/a&gt;, to be exact) to reflect the extra CPU time spent checking the &lt;code&gt;WHERE&lt;/code&gt; condition.</source>
          <target state="translated">请注意， &lt;code&gt;EXPLAIN&lt;/code&gt; 输出显示 &lt;code&gt;WHERE&lt;/code&gt; 子句被应用为附加到Seq扫描计划节点的&amp;ldquo;过滤器&amp;rdquo;条件。这意味着计划节点检查其扫描的每一行的条件，并仅输出通过条件的行。由于使用了 &lt;code&gt;WHERE&lt;/code&gt; 子句，因此减少了对输出行的估计。但是，扫描仍将必须访问所有10000行，因此成本并未降低。实际上，它已经增加了一点（确切地说是10000 * &lt;a href=&quot;runtime-config-query#GUC-CPU-OPERATOR-COST&quot;&gt;cpu_operator_cost&lt;/a&gt;），以反映检查 &lt;code&gt;WHERE&lt;/code&gt; 条件所花费的额外CPU时间。</target>
        </trans-unit>
        <trans-unit id="d34da680054f05253f7563479166aab9f149ee00" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;WITH&lt;/code&gt; query was evaluated only once, so that we got two sets of the same three random values.</source>
          <target state="translated">注意， &lt;code&gt;WITH&lt;/code&gt; 查询仅被评估一次，因此我们得到了两个具有相同三个随机值的集合。</target>
        </trans-unit>
        <trans-unit id="51724582644bab73340aa6c622d37155c5257732" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;picksplit&lt;/code&gt; function's result is delivered by modifying the passed-in &lt;code&gt;v&lt;/code&gt; structure. The return value per se is ignored, though it's conventional to pass back the address of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">注意， &lt;code&gt;picksplit&lt;/code&gt; 函数的结果是通过修改传入的 &lt;code&gt;v&lt;/code&gt; 结构传递的。返回值本身被忽略，尽管按惯例传回 &lt;code&gt;v&lt;/code&gt; 的地址。</target>
        </trans-unit>
        <trans-unit id="bf156003e881a5db213ca4ff342d316a104a89cc" translate="yes" xml:space="preserve">
          <source>Notice that the above commands specify copying the &lt;code&gt;template0&lt;/code&gt; database. When copying any other database, the encoding and locale settings cannot be changed from those of the source database, because that might result in corrupt data. For more information see &lt;a href=&quot;manage-ag-templatedbs&quot;&gt;Section 22.3&lt;/a&gt;.</source>
          <target state="translated">请注意，以上命令指定了复制 &lt;code&gt;template0&lt;/code&gt; 数据库。复制任何其他数据库时，无法更改源数据库的编码和语言环境设置，因为这可能会导致数据损坏。有关更多信息，请参见&lt;a href=&quot;manage-ag-templatedbs&quot;&gt;第22.3节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a8cdb89e02698866354e5dd11605d6eb9295c222" translate="yes" xml:space="preserve">
          <source>Notice that the array elements are ordinary SQL constants or expressions; for instance, string literals are single quoted, instead of double quoted as they would be in an array literal. The &lt;code&gt;ARRAY&lt;/code&gt; constructor syntax is discussed in more detail in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ARRAY-CONSTRUCTORS&quot;&gt;Section 4.2.12&lt;/a&gt;.</source>
          <target state="translated">请注意，数组元素是普通的SQL常量或表达式。例如，字符串文字用单引号引起来，而不是像在数组文字中那样用双引号引起来。所述 &lt;code&gt;ARRAY&lt;/code&gt; 构造语法中更详细讨论&lt;a href=&quot;sql-expressions#SQL-SYNTAX-ARRAY-CONSTRUCTORS&quot;&gt;第4.2.12&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="66469b4e59f919ba275ed4a6fda1a4c5c23cd621" translate="yes" xml:space="preserve">
          <source>Notice that the individual subcommands do not end with semicolons.</source>
          <target state="translated">请注意,各个子命令的结尾没有分号。</target>
        </trans-unit>
        <trans-unit id="3160def781e659e6cdc752185f9870b36c8a345f" translate="yes" xml:space="preserve">
          <source>Notice that the number of rows estimated to be returned from the bitmap index scan reflects only the condition used with the index; this is important since it affects the cost estimate for the subsequent heap fetches.</source>
          <target state="translated">请注意,从位图索引扫描中估计返回的行数只反映了索引使用的条件;这一点很重要,因为它会影响后续堆获取的成本估计。</target>
        </trans-unit>
        <trans-unit id="873a445a12a2fae4f43b1f16da917ba94ef395cb" translate="yes" xml:space="preserve">
          <source>Notice that the owner's implicit grant options are not marked in the access privileges display. A &lt;code&gt;*&lt;/code&gt; will appear only when grant options have been explicitly granted to someone.</source>
          <target state="translated">请注意，所有者的隐式授予选项未在访问权限显示中标记。一 &lt;code&gt;*&lt;/code&gt; 当授出购股权已明确授予给别人才会出现。</target>
        </trans-unit>
        <trans-unit id="bf407e6deb6991a0a95054bdc8f3340e9ff64b36" translate="yes" xml:space="preserve">
          <source>Notice that the period (&lt;code&gt;.&lt;/code&gt;) is not a metacharacter for &lt;code&gt;SIMILAR TO&lt;/code&gt;.</source>
          <target state="translated">请注意，句点（ &lt;code&gt;.&lt;/code&gt; ）不是 &lt;code&gt;SIMILAR TO&lt;/code&gt; 的元字符。</target>
        </trans-unit>
        <trans-unit id="74768806db56cf6b766037079dc057b3f23de85a" translate="yes" xml:space="preserve">
          <source>Notice that the primary key overlaps with the foreign keys in the last table.</source>
          <target state="translated">注意,主键与上一张表的外键是重合的。</target>
        </trans-unit>
        <trans-unit id="8e2f5e5785b45b8d6d5aee74a3bd7e8d7b7e0944" translate="yes" xml:space="preserve">
          <source>Notice that this example defines the &lt;code&gt;page_count&lt;/code&gt; result column as an integer. The function deals internally with string representations, so when you say you want an integer in the output, it will take the string representation of the XPath result and use PostgreSQL input functions to transform it into an integer (or whatever type the &lt;code&gt;AS&lt;/code&gt; clause requests). An error will result if it can't do this &amp;mdash; for example if the result is empty &amp;mdash; so you may wish to just stick to &lt;code&gt;text&lt;/code&gt; as the column type if you think your data has any problems.</source>
          <target state="translated">注意，此示例将 &lt;code&gt;page_count&lt;/code&gt; 结果列定义为整数。该函数在内部处理字符串表示形式，因此当您说要在输出中使用整数时，它将采用XPath结果的字符串表示形式，并使用PostgreSQL输入函数将其转换为整数（或 &lt;code&gt;AS&lt;/code&gt; 子句要求的任何类型） 。如果无法执行此操作，则会导致错误（例如，如果结果为空），因此，如果您认为数据有任何问题，则可能希望仅使用 &lt;code&gt;text&lt;/code&gt; 作为列类型。</target>
        </trans-unit>
        <trans-unit id="8b9217ccd836ba1fba783902d277384da15bf50d" translate="yes" xml:space="preserve">
          <source>Notice that we showed &lt;code&gt;inner_cardinality&lt;/code&gt; as 10000, that is, the unmodified size of &lt;code&gt;tenk2&lt;/code&gt;. It might appear from inspection of the &lt;code&gt;EXPLAIN&lt;/code&gt; output that the estimate of join rows comes from 50 * 1, that is, the number of outer rows times the estimated number of rows obtained by each inner index scan on &lt;code&gt;tenk2&lt;/code&gt;. But this is not the case: the join relation size is estimated before any particular join plan has been considered. If everything is working well then the two ways of estimating the join size will produce about the same answer, but due to round-off error and other factors they sometimes diverge significantly.</source>
          <target state="translated">请注意，我们显示的 &lt;code&gt;inner_cardinality&lt;/code&gt; 为10000，即未修改的 &lt;code&gt;tenk2&lt;/code&gt; 大小。通过检查 &lt;code&gt;EXPLAIN&lt;/code&gt; 输出，可能会发现联接行的估计值来自50 * 1，即外部行数 &lt;code&gt;tenk2&lt;/code&gt; 上每个内部索引扫描获得的估计行数。但是事实并非如此：在考虑任何特定的连接计划之前，就估计了连接关系大小。如果一切运行良好，则两种估算联接大小的方法将得出大致相同的答案，但是由于舍入误差和其他因素，它们有时会大相径庭。</target>
        </trans-unit>
        <trans-unit id="159dfc60dcca0632285615def5fab2a023373a94" translate="yes" xml:space="preserve">
          <source>Notice that while the plain (unaggregated) log file shows which script was used for each transaction, the aggregated log does not. Therefore if you need per-script data, you need to aggregate the data on your own.</source>
          <target state="translated">请注意,虽然普通(未聚合)日志文件显示了每个事务使用了哪个脚本,但聚合日志却没有。因此,如果你需要每个脚本的数据,你需要自己聚合数据。</target>
        </trans-unit>
        <trans-unit id="99369cd02fa72e17001071790856a797298fed53" translate="yes" xml:space="preserve">
          <source>Notice the typical form of recursive queries: an initial condition, followed by &lt;code&gt;UNION&lt;/code&gt;, followed by the recursive part of the query. Be sure that the recursive part of the query will eventually return no tuples, or else the query will loop indefinitely. (See &lt;a href=&quot;queries-with&quot;&gt;Section 7.8&lt;/a&gt; for more examples.)</source>
          <target state="translated">请注意递归查询的典型形式：初始条件，后跟 &lt;code&gt;UNION&lt;/code&gt; ，后跟查询的递归部分。确保查询的递归部分最终不会返回任何元组，否则查询将无限期地循环。（有关更多示例，请参见&lt;a href=&quot;queries-with&quot;&gt;第7.8节&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="085506905d3dc520376505271fd3c45af0c829eb" translate="yes" xml:space="preserve">
          <source>Notice we don't use &lt;code&gt;-C&lt;/code&gt;, and instead connect directly to the database to be restored into. Also note that we clone the new database from &lt;code&gt;template0&lt;/code&gt; not &lt;code&gt;template1&lt;/code&gt;, to ensure it is initially empty.</source>
          <target state="translated">注意，我们不使用 &lt;code&gt;-C&lt;/code&gt; ，而是直接连接到要还原到的数据库。还要注意，我们从 &lt;code&gt;template0&lt;/code&gt; 而不是 &lt;code&gt;template1&lt;/code&gt; 克隆新数据库，以确保它最初是空的。</target>
        </trans-unit>
        <trans-unit id="bb9bfefd5391f52be54267e2a938a126661b0ff7" translate="yes" xml:space="preserve">
          <source>Nov</source>
          <target state="translated">Nov</target>
        </trans-unit>
        <trans-unit id="3c5bf776f5efcaa22d6e0fd4839db7d2b83e52be" translate="yes" xml:space="preserve">
          <source>November</source>
          <target state="translated">November</target>
        </trans-unit>
        <trans-unit id="0ffcf97fe0b617e1a1fb0f97e1a88d84bed8f352" translate="yes" xml:space="preserve">
          <source>Now consider the same query, but with a constant that is not in the MCV list:</source>
          <target state="translated">现在考虑同样的查询,但使用的是MCV列表中没有的常量。</target>
        </trans-unit>
        <trans-unit id="1101583b5cab5dfe73a02721963b60a84711fcd9" translate="yes" xml:space="preserve">
          <source>Now it is impossible to create orders with non-NULL &lt;code&gt;product_no&lt;/code&gt; entries that do not appear in the products table.</source>
          <target state="translated">现在，无法使用没有出现在产品表中的非NULL &lt;code&gt;product_no&lt;/code&gt; 条目创建订单。</target>
        </trans-unit>
        <trans-unit id="05189fbbab4b515fc19f955242b1b42d3dc53c9c" translate="yes" xml:space="preserve">
          <source>Now it is possible to bind the thesaurus dictionary &lt;code&gt;thesaurus_simple&lt;/code&gt; to the desired token types in a configuration, for example:</source>
          <target state="translated">现在可以将同义词库词典 &lt;code&gt;thesaurus_simple&lt;/code&gt; 绑定到配置中所需的令牌类型，例如：</target>
        </trans-unit>
        <trans-unit id="14b6efa33e8cde1d203d7549fcab8edf43d173c9" translate="yes" xml:space="preserve">
          <source>Now it is possible to create a foreign table with &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;. In this example we wish to access the table named &lt;code&gt;some_schema.some_table&lt;/code&gt; on the remote server. The local name for it will be &lt;code&gt;foreign_table&lt;/code&gt;:</source>
          <target state="translated">现在可以使用&lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;创建一个外部表。在此示例中，我们希望访问远程服务器上名为 &lt;code&gt;some_schema.some_table&lt;/code&gt; 的表。它的本地名称将为 &lt;code&gt;foreign_table&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="dd96a87b36842da43e36de2200fdfc1838f0e684" translate="yes" xml:space="preserve">
          <source>Now let's add another condition to the &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="translated">现在让我们向 &lt;code&gt;WHERE&lt;/code&gt; 子句添加另一个条件：</target>
        </trans-unit>
        <trans-unit id="95432c22f405504df2d81a0fb2d4efc9ca2560c4" translate="yes" xml:space="preserve">
          <source>Now let's consider a case with more than one condition in the &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="translated">现在让我们考虑一下 &lt;code&gt;WHERE&lt;/code&gt; 子句中具有多个条件的情况：</target>
        </trans-unit>
        <trans-unit id="f0a0a72cb219eba72676d0750f57b70ee142cf22" translate="yes" xml:space="preserve">
          <source>Now let's modify the query to add a &lt;code&gt;WHERE&lt;/code&gt; condition:</source>
          <target state="translated">现在，让我们修改查询以添加 &lt;code&gt;WHERE&lt;/code&gt; 条件：</target>
        </trans-unit>
        <trans-unit id="47c1122f650e2dbfda8bc7f189317df3657e8635" translate="yes" xml:space="preserve">
          <source>Now look at the table definition again:</source>
          <target state="translated">现在再看表的定义。</target>
        </trans-unit>
        <trans-unit id="d6a6836d17a53567c7bdd65d95a74e120c1311f5" translate="yes" xml:space="preserve">
          <source>Now suppose that &lt;code&gt;alice&lt;/code&gt; wishes to change the &amp;ldquo;slightly secret&amp;rdquo; information, but decides that &lt;code&gt;mallory&lt;/code&gt; should not be trusted with the new content of that row, so she does:</source>
          <target state="translated">现在，假设 &lt;code&gt;alice&lt;/code&gt; 希望更改&amp;ldquo;轻微机密&amp;rdquo;信息，但决定该行的新内容不应该信任 &lt;code&gt;mallory&lt;/code&gt; ，因此她这样做：</target>
        </trans-unit>
        <trans-unit id="9c4ea909bc20a14cf1d5201600f80228a4642b36" translate="yes" xml:space="preserve">
          <source>Now the parenthesized object is correctly interpreted as a reference to the &lt;code&gt;item&lt;/code&gt; column, and then the subfield can be selected from it.</source>
          <target state="translated">现在，带括号的对象已正确解释为对 &lt;code&gt;item&lt;/code&gt; 列的引用，然后可以从中选择子字段。</target>
        </trans-unit>
        <trans-unit id="deae757ce21f92bbc32823a914fbc837ca56a164" translate="yes" xml:space="preserve">
          <source>Now this is fine for PostgreSQL-specific applications, but standard code using JDBC or ODBC won't delete the objects, resulting in orphan objects &amp;mdash; objects that are not referenced by anything, and simply occupy disk space.</source>
          <target state="translated">现在，这对于PostgreSQL特定的应用程序来说很好，但是使用JDBC或ODBC的标准代码不会删除对象，从而导致孤立的对象-这些对象未被任何内容引用，只会占用磁盘空间。</target>
        </trans-unit>
        <trans-unit id="084bd00ac798eb5161b956e1962a53497a37531c" translate="yes" xml:space="preserve">
          <source>Now try inserting an invalid record:</source>
          <target state="translated">现在试着插入一条无效的记录。</target>
        </trans-unit>
        <trans-unit id="5458bef284659cf16721d439d4b767332bf554fc" translate="yes" xml:space="preserve">
          <source>Now we are ready to perform a fast full text search:</source>
          <target state="translated">现在我们准备进行快速的全文检索。</target>
        </trans-unit>
        <trans-unit id="a02f5ffaa75cbfc6c6328ab3a75ec757069f839c" translate="yes" xml:space="preserve">
          <source>Now we can see how it works. &lt;code&gt;ts_lexize&lt;/code&gt; is not very useful for testing a thesaurus, because it treats its input as a single token. Instead we can use &lt;code&gt;plainto_tsquery&lt;/code&gt; and &lt;code&gt;to_tsvector&lt;/code&gt; which will break their input strings into multiple tokens:</source>
          <target state="translated">现在我们可以看到它是如何工作的。 &lt;code&gt;ts_lexize&lt;/code&gt; 对于测试同义词库不是很有用，因为它将其输入视为单个令牌。相反，我们可以使用 &lt;code&gt;plainto_tsquery&lt;/code&gt; 和 &lt;code&gt;to_tsvector&lt;/code&gt; 将它们的输入字符串分成多个令牌：</target>
        </trans-unit>
        <trans-unit id="18b6223b0641dfa27780508785b1cab41976292c" translate="yes" xml:space="preserve">
          <source>Now we can set up the mappings for words in configuration &lt;code&gt;pg&lt;/code&gt;:</source>
          <target state="translated">现在，我们可以为配置 &lt;code&gt;pg&lt;/code&gt; 中的单词设置映射：</target>
        </trans-unit>
        <trans-unit id="b4d3c996fedace29e66a9cecc69860990e5567d4" translate="yes" xml:space="preserve">
          <source>Now we can show some &lt;code&gt;INSERT&lt;/code&gt; statements:</source>
          <target state="translated">现在我们可以显示一些 &lt;code&gt;INSERT&lt;/code&gt; 语句：</target>
        </trans-unit>
        <trans-unit id="9811d50e24107f487d484ef3d4f8590f2676cba5" translate="yes" xml:space="preserve">
          <source>Now we can test our configuration:</source>
          <target state="translated">现在我们可以测试我们的配置。</target>
        </trans-unit>
        <trans-unit id="ace10f4ace4cfabef3a16f550a37af5ffc6dcce7" translate="yes" xml:space="preserve">
          <source>Now we can test our dictionary:</source>
          <target state="translated">现在我们可以测试我们的字典。</target>
        </trans-unit>
        <trans-unit id="f27c4f52d858064037f2d98b4e6143af1fdd5e4c" translate="yes" xml:space="preserve">
          <source>Now we change the prompt to something more interesting:</source>
          <target state="translated">现在我们把提示换成更有趣的东西。</target>
        </trans-unit>
        <trans-unit id="d4a301c61d4f0a929427d7399e79093ab65b2312" translate="yes" xml:space="preserve">
          <source>Now we will figure out how we can get the Hayward records back in. What we want the query to do is to scan the &lt;code&gt;weather&lt;/code&gt; table and for each row to find the matching &lt;code&gt;cities&lt;/code&gt; row(s). If no matching row is found we want some &amp;ldquo;empty values&amp;rdquo; to be substituted for the &lt;code&gt;cities&lt;/code&gt; table's columns. This kind of query is called an &lt;em&gt;outer join&lt;/em&gt;. (The joins we have seen so far are inner joins.) The command looks like this:</source>
          <target state="translated">现在，我们将弄清楚如何获取Hayward记录。我们希望查询执行的操作是扫描 &lt;code&gt;weather&lt;/code&gt; 表，并针对每一行查找匹配的 &lt;code&gt;cities&lt;/code&gt; 行。如果找不到匹配的行，我们希望将一些&amp;ldquo;空值&amp;rdquo;替换为 &lt;code&gt;cities&lt;/code&gt; 表的列。这种查询称为&lt;em&gt;外部联接&lt;/em&gt;。（到目前为止，我们已经看到的联接是内部联接。）命令如下所示：</target>
        </trans-unit>
        <trans-unit id="7ce7fd7c4c102dd293619badd0d980d7f605bb16" translate="yes" xml:space="preserve">
          <source>Now you are ready to create the foreign data table. Using the &lt;code&gt;CREATE FOREIGN TABLE&lt;/code&gt; command, you will need to define the columns for the table, the CSV file name, and its format:</source>
          <target state="translated">现在您可以创建外部数据表了。使用 &lt;code&gt;CREATE FOREIGN TABLE&lt;/code&gt; 命令，您将需要定义表的列，CSV文件名及其格式：</target>
        </trans-unit>
        <trans-unit id="64a8dd2545b6bf024381f0d92feccb523f90f566" translate="yes" xml:space="preserve">
          <source>Now you need only &lt;code&gt;SELECT&lt;/code&gt; from a foreign table to access the data stored in its underlying remote table. You can also modify the remote table using &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt;. (Of course, the remote user you have specified in your user mapping must have privileges to do these things.)</source>
          <target state="translated">现在，您只需要从外部表中进行 &lt;code&gt;SELECT&lt;/code&gt; 即可访问存储在其基础远程表中的数据。您还可以使用 &lt;code&gt;INSERT&lt;/code&gt; ， &lt;code&gt;UPDATE&lt;/code&gt; 或 &lt;code&gt;DELETE&lt;/code&gt; 修改远程表。（当然，您在用户映射中指定的远程用户必须具有执行这些操作的权限。）</target>
        </trans-unit>
        <trans-unit id="08d3e6ece6ec2bb9a41472c3b51de60739aa48a4" translate="yes" xml:space="preserve">
          <source>Now, a &lt;code&gt;SELECT&lt;/code&gt; query similar to the previous example can be used to suggest spellings for misspelled words in user search terms. A useful extra test is to require that the selected words are also of similar length to the misspelled word.</source>
          <target state="translated">现在，与上一个示例类似的 &lt;code&gt;SELECT&lt;/code&gt; 查询可用于为用户搜索词中拼写错误的单词建议拼写。一个有用的额外测试是要求所选单词的长度也应与拼写错误的单词相似。</target>
        </trans-unit>
        <trans-unit id="eb91f362c7c32cf6e84b89572465a581c06ab515" translate="yes" xml:space="preserve">
          <source>Now, let's make the condition more restrictive:</source>
          <target state="translated">现在,让我们把条件限制得更严。</target>
        </trans-unit>
        <trans-unit id="fb9ab76d936c6c858686ae054f0811c70819eab5" translate="yes" xml:space="preserve">
          <source>Now, the &lt;code&gt;WHERE&lt;/code&gt; clause &lt;code&gt;jdoc -&amp;gt; 'tags' ? 'qui'&lt;/code&gt; will be recognized as an application of the indexable operator &lt;code&gt;?&lt;/code&gt; to the indexed expression &lt;code&gt;jdoc -&amp;gt; 'tags'&lt;/code&gt;. (More information on expression indexes can be found in &lt;a href=&quot;indexes-expressional&quot;&gt;Section 11.7&lt;/a&gt;.)</source>
          <target state="translated">现在， &lt;code&gt;WHERE&lt;/code&gt; 子句 &lt;code&gt;jdoc -&amp;gt; 'tags' ? 'qui'&lt;/code&gt; 将被识别为可索引运算符的应用程序 &lt;code&gt;?&lt;/code&gt; 到索引表达式 &lt;code&gt;jdoc -&amp;gt; 'tags'&lt;/code&gt; 。 （有关表达式索引的更多信息，请参见&lt;a href=&quot;indexes-expressional&quot;&gt;第11.7节&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="9343983b435f96d35ab006d0ce2a792fa81e36a3" translate="yes" xml:space="preserve">
          <source>Now, the catalogs also provide a cast from &lt;code&gt;numeric&lt;/code&gt; to &lt;code&gt;integer&lt;/code&gt;. If that cast were marked &lt;code&gt;AS IMPLICIT&lt;/code&gt; &amp;mdash; which it is not &amp;mdash; then the parser would be faced with choosing between the above interpretation and the alternative of casting the &lt;code&gt;numeric&lt;/code&gt; constant to &lt;code&gt;integer&lt;/code&gt; and applying the &lt;code&gt;integer&lt;/code&gt;&lt;code&gt;+&lt;/code&gt;&lt;code&gt;integer&lt;/code&gt; operator. Lacking any knowledge of which choice to prefer, it would give up and declare the query ambiguous. The fact that only one of the two casts is implicit is the way in which we teach the parser to prefer resolution of a mixed &lt;code&gt;numeric&lt;/code&gt;-and-&lt;code&gt;integer&lt;/code&gt; expression as &lt;code&gt;numeric&lt;/code&gt;; there is no built-in knowledge about that.</source>
          <target state="translated">现在，目录还提供了从 &lt;code&gt;numeric&lt;/code&gt; 到 &lt;code&gt;integer&lt;/code&gt; 。如果该强制转换被标记为&amp;ldquo; &lt;code&gt;AS IMPLICIT&lt;/code&gt; （不是），则解析器将面临在上述解释与将 &lt;code&gt;numeric&lt;/code&gt; 常量强制转换为 &lt;code&gt;integer&lt;/code&gt; 并应用 &lt;code&gt;integer&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;integer&lt;/code&gt; 运算符的选择之间进行选择的选择。缺乏对选择哪种选择的了解，它将放弃并声明查询不明确。这两个强制转换中只有一个是隐式的，这是我们教语法分析器偏向于将混合 &lt;code&gt;numeric&lt;/code&gt; 和 &lt;code&gt;integer&lt;/code&gt; 表达式解析为 &lt;code&gt;numeric&lt;/code&gt; ; 没有内置的知识。</target>
        </trans-unit>
        <trans-unit id="7e07cf090027f130a2dc1fbc4d060d70553c3b5f" translate="yes" xml:space="preserve">
          <source>Now, the main problem with the btree search is that btree is inefficient when the search conditions do not constrain the leading index column(s). A better strategy for btree is to create a separate index on each column. Then the planner will choose something like this:</source>
          <target state="translated">现在,btree搜索的主要问题是,当搜索条件不限制领先索引列时,btree的效率很低。一个更好的btree策略是在每一列上创建一个单独的索引。然后,规划师会选择类似这样的方法。</target>
        </trans-unit>
        <trans-unit id="8cf5b756d6afa6277b947e17d815b23a45e8f0cf" translate="yes" xml:space="preserve">
          <source>Now, this methodology can be cumbersome with a very large number of entries in the &lt;code&gt;one_to_many&lt;/code&gt; table. Often, a join like this would result in an index scan and a fetch for each right hand entry in the table for a particular left hand entry. If you have a very dynamic system, there is not much you can do. However, if you have some data which is fairly static, you can create a summary table with the aggregator.</source>
          <target state="translated">现在，这种方法对于 &lt;code&gt;one_to_many&lt;/code&gt; 表中的大量条目非常麻烦。通常，像这样的联接将导致索引扫描和针对表中每个右手条目的特定左手条目的访存。如果您有一个非常动态的系统，那么您将无能为力。但是，如果您有一些相当静态的数据，则可以使用聚合器创建汇总表。</target>
        </trans-unit>
        <trans-unit id="333cddf155e5f6b845810ca1b1ec9493a847d199" translate="yes" xml:space="preserve">
          <source>Now, we can run some queries on the table. First, we show how to access a single element of an array. This query retrieves the names of the employees whose pay changed in the second quarter:</source>
          <target state="translated">现在,我们可以对表运行一些查询。首先,我们展示如何访问数组的单个元素。这个查询检索了第二季度工资发生变化的员工的姓名。</target>
        </trans-unit>
        <trans-unit id="e60c418bd02619354d423e5f131c6effce59534d" translate="yes" xml:space="preserve">
          <source>Now, we have a table &lt;code&gt;test&lt;/code&gt; populated with data describing the hierarchy shown below:</source>
          <target state="translated">现在，我们有一个表 &lt;code&gt;test&lt;/code&gt; 填充了描述以下所示层次结构的数据：</target>
        </trans-unit>
        <trans-unit id="109085beaaa80ac89858b283a64f7c75d7e5bb12" translate="yes" xml:space="preserve">
          <source>Null</source>
          <target state="translated">Null</target>
        </trans-unit>
        <trans-unit id="abc801eb7aa113d4d373983685ad8e4b411d4462" translate="yes" xml:space="preserve">
          <source>Null values are represented by &lt;code&gt;_null_&lt;/code&gt;. (Note that there is no way to create a value that is just that string.)</source>
          <target state="translated">空值由 &lt;code&gt;_null_&lt;/code&gt; 表示。（请注意，无法创建只是该字符串的值。）</target>
        </trans-unit>
        <trans-unit id="71197a0f68656e301e5e80254d15a53eb1f65444" translate="yes" xml:space="preserve">
          <source>Nullness tests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf00f0e98d92759b2ab900b85062ac054ac00545" translate="yes" xml:space="preserve">
          <source>Number of &amp;ldquo;internal&amp;rdquo; (upper-level) pages</source>
          <target state="translated">&amp;ldquo;内部&amp;rdquo;（上级）页面数</target>
        </trans-unit>
        <trans-unit id="766db6ffc20af3c98e8a0c222cc91dcfc261ce82" translate="yes" xml:space="preserve">
          <source>Number of &lt;code&gt;CHECK&lt;/code&gt; constraints on the table; see &lt;a href=&quot;catalog-pg-constraint&quot;&gt;&lt;code&gt;pg_constraint&lt;/code&gt;&lt;/a&gt; catalog</source>
          <target state="translated">表上的 &lt;code&gt;CHECK&lt;/code&gt; 约束数；参见&lt;a href=&quot;catalog-pg-constraint&quot;&gt; &lt;code&gt;pg_constraint&lt;/code&gt; &lt;/a&gt;目录</target>
        </trans-unit>
        <trans-unit id="f562c8ed4194c0f5d892247c878f35e3b1adf69e" translate="yes" xml:space="preserve">
          <source>Number of WAL files that have been successfully archived</source>
          <target state="translated">已成功归档的WAL文件数量。</target>
        </trans-unit>
        <trans-unit id="c384981df593e79281c2a20754104f1934f6c9b7" translate="yes" xml:space="preserve">
          <source>Number of argument strings passed to trigger function</source>
          <target state="translated">传递给触发函数的参数字符串数量</target>
        </trans-unit>
        <trans-unit id="686b06e76d78fdcab0c83dfec56d5de3d95d6021" translate="yes" xml:space="preserve">
          <source>Number of arguments that have defaults</source>
          <target state="translated">有默认值的参数数量</target>
        </trans-unit>
        <trans-unit id="ad8f1d6b3919325e33519443b298eab45ab86017" translate="yes" xml:space="preserve">
          <source>Number of backends currently connected to this database, or &lt;code&gt;NULL&lt;/code&gt; for shared objects. This is the only column in this view that returns a value reflecting current state; all other columns return the accumulated values since the last reset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="646ba2279db42aaed6dee8b8ba74083e8ded4a4e" translate="yes" xml:space="preserve">
          <source>Number of backends currently connected to this database, or &lt;code&gt;NULL&lt;/code&gt; for the shared objects. This is the only column in this view that returns a value reflecting current state; all other columns return the accumulated values since the last reset.</source>
          <target state="translated">当前连接到该数据库的后端数，或共享对象为 &lt;code&gt;NULL&lt;/code&gt; 。这是该视图中唯一返回反映当前状态的值的列；所有其他列均返回自上次复位以来的累计值。</target>
        </trans-unit>
        <trans-unit id="055e292dc7e47521853b27a0e59b3a6f4ac3517d" translate="yes" xml:space="preserve">
          <source>Number of backends pinning this buffer</source>
          <target state="translated">锁定该缓冲区的后端数量</target>
        </trans-unit>
        <trans-unit id="7fc2a68fbd98db7f2b41bb2e743259772026c43c" translate="yes" xml:space="preserve">
          <source>Number of bitmap pages</source>
          <target state="translated">位图页数</target>
        </trans-unit>
        <trans-unit id="7826db063f5934f4aaa44397cffd4f35886a95d2" translate="yes" xml:space="preserve">
          <source>Number of bits generated for each index column. Each parameter's name refers to the number of the index column that it controls. The default is &lt;code&gt;2&lt;/code&gt; bits and maximum is &lt;code&gt;4095&lt;/code&gt;. Parameters for index columns not actually used are ignored.</source>
          <target state="translated">每个索引列生成的位数。每个参数的名称指的是它控制的索引列的编号。默认值为 &lt;code&gt;2&lt;/code&gt; 位，最大值为 &lt;code&gt;4095&lt;/code&gt; 。未实际使用的索引列的参数将被忽略。</target>
        </trans-unit>
        <trans-unit id="33909c2a9901d0948fd89312acfb6d3e292b76cf" translate="yes" xml:space="preserve">
          <source>Number of bits generated for each index column. Each parameter's name refers to the number of the index column that it controls. The default is &lt;code&gt;2&lt;/code&gt; bits and the maximum is &lt;code&gt;4095&lt;/code&gt;. Parameters for index columns not actually used are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a6ee47813de9741b16e5983ad54532485c3f7d8" translate="yes" xml:space="preserve">
          <source>Number of bits in string</source>
          <target state="translated">字符串的位数</target>
        </trans-unit>
        <trans-unit id="1efe22f20b8b3239aa455f2b88a22e48c7032a46" translate="yes" xml:space="preserve">
          <source>Number of bits in the encryption algorithm used, or NULL if SSL is not used on this connection</source>
          <target state="translated">使用的加密算法的位数,如果在此连接上没有使用SSL,则为NULL。</target>
        </trans-unit>
        <trans-unit id="0aaa9d047e0edd588ca0e7b28edd0b562bba9543" translate="yes" xml:space="preserve">
          <source>Number of blocks already processed in the current phase.</source>
          <target state="translated">当前阶段已处理的区块数。</target>
        </trans-unit>
        <trans-unit id="1c4fa9ae3322de072b98477062cf3a411db62a9c" translate="yes" xml:space="preserve">
          <source>Number of blocks checked for existence for this SLRU</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e601295de63e2a2c268076613ec412bef9974925" translate="yes" xml:space="preserve">
          <source>Number of blocks zeroed during initializations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00533abb6601d842f496de1f71453437a6ebdea3" translate="yes" xml:space="preserve">
          <source>Number of bucket pages</source>
          <target state="translated">桶页数</target>
        </trans-unit>
        <trans-unit id="5f0a807486a5a6ed87ce1d425faa9e67bccd0b96" translate="yes" xml:space="preserve">
          <source>Number of buffer hits in all indexes on this table</source>
          <target state="translated">本表所有索引中的缓冲区点击数</target>
        </trans-unit>
        <trans-unit id="e19591b7755dbe90f2648065af697ccee73ba936" translate="yes" xml:space="preserve">
          <source>Number of buffer hits in this index</source>
          <target state="translated">该指数中的缓冲区点击数</target>
        </trans-unit>
        <trans-unit id="7bc9f9ddcb6814f42c1dfcc0f6c3a5f06c83a41c" translate="yes" xml:space="preserve">
          <source>Number of buffer hits in this sequence</source>
          <target state="translated">该序列中的缓冲区点击数</target>
        </trans-unit>
        <trans-unit id="1b92c223ff9c814c48eef462cd5d9e3733ab3a60" translate="yes" xml:space="preserve">
          <source>Number of buffer hits in this table</source>
          <target state="translated">本表中的缓冲区点击数</target>
        </trans-unit>
        <trans-unit id="fb5ce149dfa5df345dadf32e3e7609e73a91ab4d" translate="yes" xml:space="preserve">
          <source>Number of buffer hits in this table's TOAST table (if any)</source>
          <target state="translated">本表的TOAST表中的缓冲区点击数(如果有的话)。</target>
        </trans-unit>
        <trans-unit id="23b7daeca394ace2c29173c2e4db7f60e4ffa150" translate="yes" xml:space="preserve">
          <source>Number of buffer hits in this table's TOAST table indexes (if any)</source>
          <target state="translated">此表的TOAST表索引中的缓冲区点击数(如果有的话</target>
        </trans-unit>
        <trans-unit id="820cb42f301c46e1dfd210dd8b99d341db358b4e" translate="yes" xml:space="preserve">
          <source>Number of buffers allocated</source>
          <target state="translated">分配的缓冲器数量</target>
        </trans-unit>
        <trans-unit id="9d5ff89dcfa3fb4035bf4d286f1b89c75201025e" translate="yes" xml:space="preserve">
          <source>Number of buffers written by the background writer</source>
          <target state="translated">后台写手所写的缓冲区数量</target>
        </trans-unit>
        <trans-unit id="0754f03bfbfe66ccdcb625fa7e3f44aa2c2a10bf" translate="yes" xml:space="preserve">
          <source>Number of buffers written directly by a backend</source>
          <target state="translated">后台直接写入的缓冲区数量</target>
        </trans-unit>
        <trans-unit id="5c0d5f7ac01275f2192348fde149f7bc358fa9b2" translate="yes" xml:space="preserve">
          <source>Number of buffers written during checkpoints</source>
          <target state="translated">检查站期间写入的缓冲区数量</target>
        </trans-unit>
        <trans-unit id="07fff57f12d731d3ce6021e11cbee81eeb3c2283" translate="yes" xml:space="preserve">
          <source>Number of bytes in binary string</source>
          <target state="translated">二进制字符串的字节数</target>
        </trans-unit>
        <trans-unit id="776e4abf0d400377907ab4118caf858bc018038c" translate="yes" xml:space="preserve">
          <source>Number of bytes in string</source>
          <target state="translated">字符串的字节数</target>
        </trans-unit>
        <trans-unit id="0c72d2a102dbeffb7f10cf64774275780bc212cb" translate="yes" xml:space="preserve">
          <source>Number of bytes used to store a particular value (possibly compressed)</source>
          <target state="translated">用于存储特定值的字节数(可能是压缩的)。</target>
        </trans-unit>
        <trans-unit id="c08b0fa84d37e1078db655b5ae7decd119da648e" translate="yes" xml:space="preserve">
          <source>Number of characters in &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt;的字符数&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fd2d8b2ef7ef37c5c432bb5b54f4a96fe58d0820" translate="yes" xml:space="preserve">
          <source>Number of characters in &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; in the given &lt;em&gt;&lt;code&gt;encoding&lt;/code&gt;&lt;/em&gt;. The &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; must be valid in this encoding.</source>
          <target state="translated">给定&lt;em&gt; &lt;code&gt;encoding&lt;/code&gt; &lt;/em&gt;中&lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt;的字符数。该&lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt;在此编码中必须有效。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="21fa6ae67d156ef97e3bcf08c970e730cf5312e3" translate="yes" xml:space="preserve">
          <source>Number of characters in string</source>
          <target state="translated">字符串的数量</target>
        </trans-unit>
        <trans-unit id="757246d7eeb8dba1a7138e1dc8e8018c67750493" translate="yes" xml:space="preserve">
          <source>Number of child tables scanned. This counter only advances when the phase is &lt;code&gt;acquiring inherited sample rows&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bd1fcff19995e8c8816753d9ab90a523509512c" translate="yes" xml:space="preserve">
          <source>Number of child tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6c03f4ded52583235611efb49840aea96640208" translate="yes" xml:space="preserve">
          <source>Number of clients simulated, that is, number of concurrent database sessions. Default is 1.</source>
          <target state="translated">模拟的客户端数量,即并发数据库会话的数量。默认为1。</target>
        </trans-unit>
        <trans-unit id="85c5091c823d8842dadc7ece08cd606b9ead02d8" translate="yes" xml:space="preserve">
          <source>Number of completed index vacuum cycles.</source>
          <target state="translated">完成的指数真空周期数。</target>
        </trans-unit>
        <trans-unit id="07c0251b99d852d386e6230c7bc68b422860b2c8" translate="yes" xml:space="preserve">
          <source>Number of data page checksum failures detected in this database (or on a shared object), or NULL if data checksums are not enabled.</source>
          <target state="translated">在本数据库(或共享对象)中检测到的数据页校验失败的次数,如果没有启用数据校验,则为NULL。</target>
        </trans-unit>
        <trans-unit id="fd10e6b6630a5e0b1a1e37d857ce93abbe92b80c" translate="yes" xml:space="preserve">
          <source>Number of dead tuples</source>
          <target state="translated">死掉的元组数量</target>
        </trans-unit>
        <trans-unit id="afdac9c7f2737a1b2507732298381e07eead13a4" translate="yes" xml:space="preserve">
          <source>Number of dead tuples (exact)</source>
          <target state="translated">死掉的元组数量(精确)</target>
        </trans-unit>
        <trans-unit id="02be773fcf618322b70d57bc8dd9f3bf3919a6ff" translate="yes" xml:space="preserve">
          <source>Number of dead tuples collected since the last index vacuum cycle.</source>
          <target state="translated">自上一个索引真空周期以来收集的死元组数量。</target>
        </trans-unit>
        <trans-unit id="dfb451e3ffa3210bb1e566dd30fd90934219a10e" translate="yes" xml:space="preserve">
          <source>Number of dead tuples that we can store before needing to perform an index vacuum cycle, based on &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;维护&lt;/a&gt; _work_mem，在需要执行索引真空循环之前可以存储的死元组数。</target>
        </trans-unit>
        <trans-unit id="c4921acfb7b89b906d587e207c982d99387b078d" translate="yes" xml:space="preserve">
          <source>Number of deadlocks detected in this database</source>
          <target state="translated">该数据库中检测到的死锁数量</target>
        </trans-unit>
        <trans-unit id="7cb4a85ff41caf8fe6b956d1175a54bab38b2930" translate="yes" xml:space="preserve">
          <source>Number of deleted pages</source>
          <target state="translated">删除的页数</target>
        </trans-unit>
        <trans-unit id="c3223e4de0ae9c43ca827d1664c98d5d300c8a06" translate="yes" xml:space="preserve">
          <source>Number of dimensions, if the column is an array type; otherwise 0. (Presently, the number of dimensions of an array is not enforced, so any nonzero value effectively means &amp;ldquo;it's an array&amp;rdquo;.)</source>
          <target state="translated">维数（如果列为数组类型）；否则为0。（当前，不强制执行数组的维数，因此任何非零值实际上表示&amp;ldquo;它是数组&amp;rdquo;。）</target>
        </trans-unit>
        <trans-unit id="2be05a9b990f09033b8618eab5d65ae1aecc4032" translate="yes" xml:space="preserve">
          <source>Number of direct (non-aggregated) arguments of an ordered-set or hypothetical-set aggregate, counting a variadic array as one argument. If equal to &lt;code&gt;pronargs&lt;/code&gt;, the aggregate must be variadic and the variadic array describes the aggregated arguments as well as the final direct arguments. Always zero for normal aggregates.</source>
          <target state="translated">有序集合或假设集合的直接（非集合）参数的数量，将可变参数数组作为一个参数。如果等于 &lt;code&gt;pronargs&lt;/code&gt; ，则聚合必须是可变参数，可变参数数组将描述聚合参数以及最终的直接参数。对于常规聚合，始终为零。</target>
        </trans-unit>
        <trans-unit id="7aaf798c193e9c02ed1872cdc3758501e3edd2e9" translate="yes" xml:space="preserve">
          <source>Number of disk blocks read for this SLRU</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32e023d3421063e999e37bd8a8607f9d3b37c25b" translate="yes" xml:space="preserve">
          <source>Number of disk blocks read from all indexes on this table</source>
          <target state="translated">从该表的所有索引中读取的磁盘块数。</target>
        </trans-unit>
        <trans-unit id="5d872dc4357e4133d7ccee125da5dd9ed6f1e23f" translate="yes" xml:space="preserve">
          <source>Number of disk blocks read from this index</source>
          <target state="translated">从该索引读取的磁盘块数</target>
        </trans-unit>
        <trans-unit id="f152a31061ce6ad3788ac1d44859392030a5e387" translate="yes" xml:space="preserve">
          <source>Number of disk blocks read from this sequence</source>
          <target state="translated">从该序列读取的磁盘块数量</target>
        </trans-unit>
        <trans-unit id="5d8a5f136039b36181bc2310abac4c580db63dc6" translate="yes" xml:space="preserve">
          <source>Number of disk blocks read from this table</source>
          <target state="translated">从本表读取的磁盘块数</target>
        </trans-unit>
        <trans-unit id="0eec262fa83f105ce7c719197839961c454478bd" translate="yes" xml:space="preserve">
          <source>Number of disk blocks read from this table's TOAST table (if any)</source>
          <target state="translated">从此表的TOAST表中读取的磁盘块数(如果有的话)。</target>
        </trans-unit>
        <trans-unit id="c3595c16a4db90858d963b19c02306856a40fc17" translate="yes" xml:space="preserve">
          <source>Number of disk blocks read from this table's TOAST table indexes (if any)</source>
          <target state="translated">从此表的TOAST表索引中读取的磁盘块数量(如果有的话)。</target>
        </trans-unit>
        <trans-unit id="afcfec9d8002c45f94146f16eeb8704ff31575b1" translate="yes" xml:space="preserve">
          <source>Number of disk blocks read in this database</source>
          <target state="translated">该数据库中读取的磁盘块数</target>
        </trans-unit>
        <trans-unit id="900fa7cb003c1be6f273043153c16b1f15b30466" translate="yes" xml:space="preserve">
          <source>Number of disk blocks written for this SLRU</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da37950fc1304c1760a3162855b0cc7eba9abaaf" translate="yes" xml:space="preserve">
          <source>Number of empty pages</source>
          <target state="translated">空页数</target>
        </trans-unit>
        <trans-unit id="1eef621006cc03444cdc3f17923c510b432b6ba9" translate="yes" xml:space="preserve">
          <source>Number of entries in semaphore map</source>
          <target state="translated">旗语地图的条目数</target>
        </trans-unit>
        <trans-unit id="477ceecd337608949a72430b5748c93213cf67af" translate="yes" xml:space="preserve">
          <source>Number of extended statistics computed. This counter only advances when the phase is &lt;code&gt;computing extended statistics&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50fbf334710b4f84f1b18744b65687758f7ff55b" translate="yes" xml:space="preserve">
          <source>Number of extended statistics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ad03f1cded443f2951e34811d9b174dcd53e9f1" translate="yes" xml:space="preserve">
          <source>Number of failed attempts for archiving WAL files</source>
          <target state="translated">归档WAL文件的失败次数</target>
        </trans-unit>
        <trans-unit id="83240d945e31782e131edbfaf89add567bc6e877" translate="yes" xml:space="preserve">
          <source>Number of flushes of dirty data for this SLRU</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="909efe526c9ef59f71379f7b5459201d6e2057fb" translate="yes" xml:space="preserve">
          <source>Number of heap blocks scanned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db7d7d8e8c6ad921ea1f650987683cdca25be133" translate="yes" xml:space="preserve">
          <source>Number of heap blocks scanned. Because the &lt;a href=&quot;storage-vm&quot;&gt;visibility map&lt;/a&gt; is used to optimize scans, some blocks will be skipped without inspection; skipped blocks are included in this total, so that this number will eventually become equal to &lt;code&gt;heap_blks_total&lt;/code&gt; when the vacuum is complete. This counter only advances when the phase is &lt;code&gt;scanning heap&lt;/code&gt;.</source>
          <target state="translated">扫描的堆块数。由于&lt;a href=&quot;storage-vm&quot;&gt;可见性图&lt;/a&gt;用于优化扫描，因此某些块将被跳过而无需检查；跳过的块包含在该总数中，以便在完成 &lt;code&gt;heap_blks_total&lt;/code&gt; 此数目最终将等于heap_blks_total。仅当阶段正在 &lt;code&gt;scanning heap&lt;/code&gt; 时，此计数器才会前进。</target>
        </trans-unit>
        <trans-unit id="8abfe62e8394a6c74c6d4a5a932d175e4675308e" translate="yes" xml:space="preserve">
          <source>Number of heap blocks scanned. This counter only advances when the phase is &lt;code&gt;seq scanning heap&lt;/code&gt;.</source>
          <target state="translated">扫描的堆块数。仅当阶段为 &lt;code&gt;seq scanning heap&lt;/code&gt; 时，此计数器才会前进。</target>
        </trans-unit>
        <trans-unit id="e3cc4495fb3d4a190394bf457f27a153df853feb" translate="yes" xml:space="preserve">
          <source>Number of heap blocks vacuumed. Unless the table has no indexes, this counter only advances when the phase is &lt;code&gt;vacuuming heap&lt;/code&gt;. Blocks that contain no dead tuples are skipped, so the counter may sometimes skip forward in large increments.</source>
          <target state="translated">已清理的堆块数。除非表没有索引，否则该计数器仅在阶段正在 &lt;code&gt;vacuuming heap&lt;/code&gt; 时才前进。不包含无效元组的块将被跳过，因此计数器有时可能会以较大的增量向前跳跃。</target>
        </trans-unit>
        <trans-unit id="f7065ea221f976c9edbd673b5b220f7e3c796ada" translate="yes" xml:space="preserve">
          <source>Number of heap tuples scanned. This counter only advances when the phase is &lt;code&gt;seq scanning heap&lt;/code&gt;, &lt;code&gt;index scanning heap&lt;/code&gt; or &lt;code&gt;writing new heap&lt;/code&gt;.</source>
          <target state="translated">扫描的堆元组数。仅当阶段为 &lt;code&gt;seq scanning heap&lt;/code&gt; ， &lt;code&gt;index scanning heap&lt;/code&gt; 或 &lt;code&gt;writing new heap&lt;/code&gt; 时，此计数器才会前进。</target>
        </trans-unit>
        <trans-unit id="1608d82e7902ccc755c873e18179b75db06e972e" translate="yes" xml:space="preserve">
          <source>Number of heap tuples written. This counter only advances when the phase is &lt;code&gt;seq scanning heap&lt;/code&gt;, &lt;code&gt;index scanning heap&lt;/code&gt; or &lt;code&gt;writing new heap&lt;/code&gt;.</source>
          <target state="translated">写入的堆元组数。仅当阶段为 &lt;code&gt;seq scanning heap&lt;/code&gt; ， &lt;code&gt;index scanning heap&lt;/code&gt; 或 &lt;code&gt;writing new heap&lt;/code&gt; 时，此计数器才会前进。</target>
        </trans-unit>
        <trans-unit id="b8a4f5e567445d068c8e050292c1c88bc19074f5" translate="yes" xml:space="preserve">
          <source>Number of index entries returned by scans on this index</source>
          <target state="translated">在此索引上扫描返回的索引条目数</target>
        </trans-unit>
        <trans-unit id="2e47feab593e8d7f11f91aca87244c1647d56eda" translate="yes" xml:space="preserve">
          <source>Number of index scans initiated on this index</source>
          <target state="translated">对该索引发起的索引扫描次数</target>
        </trans-unit>
        <trans-unit id="9740aebc5f5b78757843f388b08b6acf15d45722" translate="yes" xml:space="preserve">
          <source>Number of index scans initiated on this table</source>
          <target state="translated">对该表发起的索引扫描次数</target>
        </trans-unit>
        <trans-unit id="2512b3dbef65d5a2946445bd9f10f953be318af1" translate="yes" xml:space="preserve">
          <source>Number of indexes rebuilt. This counter only advances when the phase is &lt;code&gt;rebuilding index&lt;/code&gt;.</source>
          <target state="translated">重建的索引数。仅当阶段为 &lt;code&gt;rebuilding index&lt;/code&gt; 时，此计数器才会前进。</target>
        </trans-unit>
        <trans-unit id="c472386046a97dee2b6524340bae3b671c82f90b" translate="yes" xml:space="preserve">
          <source>Number of input arguments</source>
          <target state="translated">输入参数的数量</target>
        </trans-unit>
        <trans-unit id="2f8814269318ff6e97c5ce39779e7a57b9de7c2a" translate="yes" xml:space="preserve">
          <source>Number of leaf pages</source>
          <target state="translated">叶页数</target>
        </trans-unit>
        <trans-unit id="09d24d58ee5f9d720e6e82ed3d6f447d63a9f297" translate="yes" xml:space="preserve">
          <source>Number of live rows fetched by index scans</source>
          <target state="translated">通过索引扫描获取的有效行数。</target>
        </trans-unit>
        <trans-unit id="7f6337cf0b1025e25455e7f1eb27c447744854cc" translate="yes" xml:space="preserve">
          <source>Number of live rows fetched by sequential scans</source>
          <target state="translated">通过顺序扫描获取的有效行数。</target>
        </trans-unit>
        <trans-unit id="c7bb465c5d5812b8f1ac688b0973b4608d17fc34" translate="yes" xml:space="preserve">
          <source>Number of live rows in the table. This is only an estimate used by the planner. It is updated by &lt;code&gt;VACUUM&lt;/code&gt;, &lt;code&gt;ANALYZE&lt;/code&gt;, and a few DDL commands such as &lt;code&gt;CREATE INDEX&lt;/code&gt;.</source>
          <target state="translated">表中的活动行数。这只是计划者使用的估计值。它由 &lt;code&gt;VACUUM&lt;/code&gt; ， &lt;code&gt;ANALYZE&lt;/code&gt; 和一些DDL命令（如 &lt;code&gt;CREATE INDEX&lt;/code&gt; )更新。</target>
        </trans-unit>
        <trans-unit id="6384ca87c928ff5826fd519745a102a2e37dcfdf" translate="yes" xml:space="preserve">
          <source>Number of live table rows fetched by simple index scans using this index</source>
          <target state="translated">使用该索引进行简单的索引扫描所获取的实时表行数。</target>
        </trans-unit>
        <trans-unit id="dd029b3676675a63d87f153e3800676e7c7dd2a6" translate="yes" xml:space="preserve">
          <source>Number of live tuples</source>
          <target state="translated">活元组的数量</target>
        </trans-unit>
        <trans-unit id="d58d2b3f2cd29b1e4cc2b40b834ed9770119552a" translate="yes" xml:space="preserve">
          <source>Number of live tuples (estimated)</source>
          <target state="translated">活元组数量(估计)</target>
        </trans-unit>
        <trans-unit id="5571a3a39c2a5eeb8bba94092d426fefd43fd703" translate="yes" xml:space="preserve">
          <source>Number of lockers already waited for.</source>
          <target state="translated">已经等待的储物柜数量。</target>
        </trans-unit>
        <trans-unit id="11736240ddbd910654d9f20076ce6396954df295" translate="yes" xml:space="preserve">
          <source>Number of overflow pages</source>
          <target state="translated">溢出页数</target>
        </trans-unit>
        <trans-unit id="2ef8f42ee9f5e2c4b09ad099506a9000c698f3af" translate="yes" xml:space="preserve">
          <source>Number of pages in the pending list</source>
          <target state="translated">待处理清单中的页数</target>
        </trans-unit>
        <trans-unit id="daa5300000bb09c7a79335a89c2593536d8853e6" translate="yes" xml:space="preserve">
          <source>Number of pages that are marked all-visible in the table's visibility map. This is only an estimate used by the planner. It is updated by &lt;code&gt;VACUUM&lt;/code&gt;, &lt;code&gt;ANALYZE&lt;/code&gt;, and a few DDL commands such as &lt;code&gt;CREATE INDEX&lt;/code&gt;.</source>
          <target state="translated">在表格的可见性图中标记为全可见的页面数。这只是计划者使用的估计值。它由 &lt;code&gt;VACUUM&lt;/code&gt; ， &lt;code&gt;ANALYZE&lt;/code&gt; 和一些DDL命令（如 &lt;code&gt;CREATE INDEX&lt;/code&gt; )更新。</target>
        </trans-unit>
        <trans-unit id="e3cf04020ae64faac82b051a0ef081a4ffd60a33" translate="yes" xml:space="preserve">
          <source>Number of points in path or polygon</source>
          <target state="translated">路径或多边形中的点的数量</target>
        </trans-unit>
        <trans-unit id="544446e4ab9a886e3d43e3c0ad1665073743283d" translate="yes" xml:space="preserve">
          <source>Number of queries canceled due to conflicts with recovery in this database. (Conflicts occur only on standby servers; see &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-DATABASE-CONFLICTS-VIEW&quot;&gt;&lt;code&gt;pg_stat_database_conflicts&lt;/code&gt;&lt;/a&gt; for details.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59e27e77340db29b89a3fbca8921ff6b082deb57" translate="yes" xml:space="preserve">
          <source>Number of queries canceled due to conflicts with recovery in this database. (Conflicts occur only on standby servers; see &lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-CONFLICTS-VIEW&quot;&gt;pg_stat_database_conflicts&lt;/a&gt; for details.)</source>
          <target state="translated">由于与该数据库中的恢复冲突而取消的查询数。（冲突仅在备用服务器上发生；有关详细信息，请参见&lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-CONFLICTS-VIEW&quot;&gt;pg_stat_database_conflicts&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="14b49512f9667544c12ae0c4b4cd966d96369baa" translate="yes" xml:space="preserve">
          <source>Number of queries in this database that have been canceled due to deadlocks</source>
          <target state="translated">该数据库中因死锁而取消的查询次数。</target>
        </trans-unit>
        <trans-unit id="2965fecffa2cf1a8144374cd40187c529bd62354" translate="yes" xml:space="preserve">
          <source>Number of queries in this database that have been canceled due to dropped tablespaces</source>
          <target state="translated">该数据库中因放弃表空间而被取消的查询次数</target>
        </trans-unit>
        <trans-unit id="285091906a09f767f888d2dff167e4dafef20892" translate="yes" xml:space="preserve">
          <source>Number of queries in this database that have been canceled due to lock timeouts</source>
          <target state="translated">该数据库中因锁定超时而被取消的查询次数。</target>
        </trans-unit>
        <trans-unit id="7bd181d498f49b3250f7391fd0a21bf7f1dd7ba8" translate="yes" xml:space="preserve">
          <source>Number of queries in this database that have been canceled due to old snapshots</source>
          <target state="translated">该数据库中因旧快照而被取消的查询次数。</target>
        </trans-unit>
        <trans-unit id="a343fc19cbfe51192fb4c899e5aeef503d395f97" translate="yes" xml:space="preserve">
          <source>Number of queries in this database that have been canceled due to pinned buffers</source>
          <target state="translated">该数据库中因缓冲区钉住而被取消的查询次数</target>
        </trans-unit>
        <trans-unit id="0ac9bcd7ffe37a50ba3f5b534d815f116bf780f4" translate="yes" xml:space="preserve">
          <source>Number of requested checkpoints that have been performed</source>
          <target state="translated">已执行的请求检查站的数目。</target>
        </trans-unit>
        <trans-unit id="ac10ddd98993ae90bf693c73dcdf8ce8ff50a428" translate="yes" xml:space="preserve">
          <source>Number of rows HOT updated (i.e., with no separate index update required)</source>
          <target state="translated">HOT更新的行数(即不需要单独更新索引)。</target>
        </trans-unit>
        <trans-unit id="d2766fede1a28c68b26ca72aae563b9c0e3b81e7" translate="yes" xml:space="preserve">
          <source>Number of rows deleted</source>
          <target state="translated">删除的行数</target>
        </trans-unit>
        <trans-unit id="f34b08643d44d2358187f3d93aedd65adc903d85" translate="yes" xml:space="preserve">
          <source>Number of rows deleted by queries in this database</source>
          <target state="translated">该数据库中被查询删除的行数。</target>
        </trans-unit>
        <trans-unit id="a2b82f360651a017d5888c1a773debe321eb0eb6" translate="yes" xml:space="preserve">
          <source>Number of rows fetched by queries in this database</source>
          <target state="translated">在该数据库中通过查询获取的行数</target>
        </trans-unit>
        <trans-unit id="f45586cda10d5aa205f934dede2f25a7f45e1dde" translate="yes" xml:space="preserve">
          <source>Number of rows inserted</source>
          <target state="translated">插入的行数</target>
        </trans-unit>
        <trans-unit id="6a09e7859bb80515b532f0be7e2f1d0e3e69ef9b" translate="yes" xml:space="preserve">
          <source>Number of rows inserted by queries in this database</source>
          <target state="translated">在该数据库中通过查询插入的行数。</target>
        </trans-unit>
        <trans-unit id="df7903056ffeb2c4aeb95ecc376e010c64637c6c" translate="yes" xml:space="preserve">
          <source>Number of rows returned by queries in this database</source>
          <target state="translated">该数据库中查询返回的行数。</target>
        </trans-unit>
        <trans-unit id="323338c3c2a474e71a2da0eb4b11693b9c2f500b" translate="yes" xml:space="preserve">
          <source>Number of rows updated (includes HOT updated rows)</source>
          <target state="translated">更新的行数(包括HOT更新的行数)</target>
        </trans-unit>
        <trans-unit id="454a23c41b48acf5b2ccd14833f1fbd50495e2fe" translate="yes" xml:space="preserve">
          <source>Number of rows updated by queries in this database</source>
          <target state="translated">该数据库中经查询更新的行数。</target>
        </trans-unit>
        <trans-unit id="2ac84789e08f3d81095c6bdcfce3914d10c756d6" translate="yes" xml:space="preserve">
          <source>Number of scheduled checkpoints that have been performed</source>
          <target state="translated">已执行的预定检查站数量</target>
        </trans-unit>
        <trans-unit id="70b6c2dc7031b941f16874427081ef44f2d0e18e" translate="yes" xml:space="preserve">
          <source>Number of sequential scans initiated on this table</source>
          <target state="translated">在此表上启动的连续扫描次数。</target>
        </trans-unit>
        <trans-unit id="a406439f0d98d84ebcc73a534711b625f34ad9d2" translate="yes" xml:space="preserve">
          <source>Number of tablespaces streamed. This counter only advances when the phase is &lt;code&gt;streaming database files&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db1eaebd91f46f68739419b406f7116ca7278810" translate="yes" xml:space="preserve">
          <source>Number of temporary files created by queries in this database. All temporary files are counted, regardless of why the temporary file was created (e.g., sorting or hashing), and regardless of the &lt;a href=&quot;runtime-config-logging#GUC-LOG-TEMP-FILES&quot;&gt;log_temp_files&lt;/a&gt; setting.</source>
          <target state="translated">由该数据库中的查询创建的临时文件数。无论创建临时文件的原因（例如排序或散列），以及&lt;a href=&quot;runtime-config-logging#GUC-LOG-TEMP-FILES&quot;&gt;log_temp_files&lt;/a&gt;设置如何，都对所有临时文件进行计数。</target>
        </trans-unit>
        <trans-unit id="321ef5914a0a09d168438f2273433fc677686e24" translate="yes" xml:space="preserve">
          <source>Number of the log line for each session or process, starting at 1</source>
          <target state="translated">每个会话或进程的日志行数,从1开始。</target>
        </trans-unit>
        <trans-unit id="63fe0ed940b40404d3e8a92d939916a5dc589c9e" translate="yes" xml:space="preserve">
          <source>Number of times a backend had to execute its own &lt;code&gt;fsync&lt;/code&gt; call (normally the background writer handles those even when the backend does its own write)</source>
          <target state="translated">后端必须执行自己的 &lt;code&gt;fsync&lt;/code&gt; 调用的次数（通常，后台编写器会处理这些操作，即使后端自己执行写操作）</target>
        </trans-unit>
        <trans-unit id="68d8d91d15dbba072e77a826a2320fb4b78552e4" translate="yes" xml:space="preserve">
          <source>Number of times disk blocks were found already in the SLRU, so that a read was not necessary (this only includes hits in the SLRU, not the operating system's file system cache)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a553947fcdc098d224243a39019d65fcd42472fd" translate="yes" xml:space="preserve">
          <source>Number of times disk blocks were found already in the buffer cache, so that a read was not necessary (this only includes hits in the PostgreSQL buffer cache, not the operating system's file system cache)</source>
          <target state="translated">在缓冲区缓存中发现磁盘块的次数,因此不需要读取(这只包括在PostgreSQL缓冲区缓存中的点击,不包括操作系统的文件系统缓存)。</target>
        </trans-unit>
        <trans-unit id="d7202f6daa9d37d53dc5948cf3ce73b0f377e700" translate="yes" xml:space="preserve">
          <source>Number of times executed</source>
          <target state="translated">执行次数</target>
        </trans-unit>
        <trans-unit id="03d48edf24ffbd37a62d6a4ffcfb82831fa45c63" translate="yes" xml:space="preserve">
          <source>Number of times the background writer stopped a cleaning scan because it had written too many buffers</source>
          <target state="translated">背景写入器因为写入太多缓冲区而停止清洁扫描的次数。</target>
        </trans-unit>
        <trans-unit id="4ed26fe5383a5798683e9283907335221973e727" translate="yes" xml:space="preserve">
          <source>Number of times the statement was executed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20347e7e3ba3b446a92ff9a3bd79c5b1d653f5c0" translate="yes" xml:space="preserve">
          <source>Number of times the statement was planned (if &lt;code&gt;pg_stat_statements.track_planning&lt;/code&gt; is enabled, otherwise zero)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db4c1e8598791346cf7ab2d43ead7da4a1cb087e" translate="yes" xml:space="preserve">
          <source>Number of times this function has been called</source>
          <target state="translated">该函数被调用的次数</target>
        </trans-unit>
        <trans-unit id="981adc683189320f78f847f75dfe9f19ed8a5df7" translate="yes" xml:space="preserve">
          <source>Number of times this table has been analyzed by the autovacuum daemon</source>
          <target state="translated">该表被自动真空守护程序分析的次数。</target>
        </trans-unit>
        <trans-unit id="b87ae2050cfd76f7faad9ed39e95e377b7ba3065" translate="yes" xml:space="preserve">
          <source>Number of times this table has been manually analyzed</source>
          <target state="translated">本表被人工分析的次数</target>
        </trans-unit>
        <trans-unit id="86f3157922ed18f5e1cb8cdea053f28b23ec91b9" translate="yes" xml:space="preserve">
          <source>Number of times this table has been manually vacuumed (not counting &lt;code&gt;VACUUM FULL&lt;/code&gt;)</source>
          <target state="translated">手动清理该表的次数（不计 &lt;code&gt;VACUUM FULL&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="7d451fa30c0c321954c3a675d2c5bb4c2d50a932" translate="yes" xml:space="preserve">
          <source>Number of times this table has been vacuumed by the autovacuum daemon</source>
          <target state="translated">该表被自动吸尘守护程序吸尘的次数。</target>
        </trans-unit>
        <trans-unit id="4c54cfa40fa8364c91aff563ca87ddd6edf318b8" translate="yes" xml:space="preserve">
          <source>Number of transactions each client runs. Default is 10.</source>
          <target state="translated">每个客户端运行的交易数量。默认为10。</target>
        </trans-unit>
        <trans-unit id="3275a376403dc18fc868eeb773fd1acfe4f18aec" translate="yes" xml:space="preserve">
          <source>Number of transactions in this database that have been committed</source>
          <target state="translated">该数据库中已提交的交易数量。</target>
        </trans-unit>
        <trans-unit id="5b3dba5ee04dc9d1479c1b216978bf3f1db9f6aa" translate="yes" xml:space="preserve">
          <source>Number of transactions in this database that have been rolled back</source>
          <target state="translated">该数据库中已回滚的交易数量。</target>
        </trans-unit>
        <trans-unit id="ec735d5660ce6c32dd80bd724ca186e1322664ff" translate="yes" xml:space="preserve">
          <source>Number of truncates for this SLRU</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="249fa0ad004c753cb36af02875bc1dafebf2db43" translate="yes" xml:space="preserve">
          <source>Number of tuples already processed in the current phase.</source>
          <target state="translated">当前阶段已经处理的元组数量。</target>
        </trans-unit>
        <trans-unit id="e10a2168070471eb01214b024083f7afd7ad7f4a" translate="yes" xml:space="preserve">
          <source>Number of tuples in the pending list</source>
          <target state="translated">待定列表中的元组数量</target>
        </trans-unit>
        <trans-unit id="cf7d86c225385fe6e945a39e465f0448098943a9" translate="yes" xml:space="preserve">
          <source>Number of unused pages</source>
          <target state="translated">未使用页数</target>
        </trans-unit>
        <trans-unit id="64210a61d52a14f7a802ee5036f59bb4880be4c1" translate="yes" xml:space="preserve">
          <source>Number of user columns in the relation (system columns not counted). There must be this many corresponding entries in &lt;code&gt;pg_attribute&lt;/code&gt;. See also &lt;code&gt;pg_attribute.attnum&lt;/code&gt;.</source>
          <target state="translated">关系中的用户列数（不计算系统列）。 &lt;code&gt;pg_attribute&lt;/code&gt; 中必须有这么多对应的条目。另请参阅 &lt;code&gt;pg_attribute.attnum&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5897414fda7aed8102e3f5d6f9e16ee579dd363" translate="yes" xml:space="preserve">
          <source>Number of worker threads within pgbench. Using more than one thread can be helpful on multi-CPU machines. Clients are distributed as evenly as possible among available threads. Default is 1.</source>
          <target state="translated">pgbench内的工作线程数量。在多CPU的机器上使用一个以上的线程会很有帮助。客户端尽可能均匀地分布在可用线程中。默认为1。</target>
        </trans-unit>
        <trans-unit id="cefa5441373f254fdc1cb9fdbc4d9c0c1aa44ee4" translate="yes" xml:space="preserve">
          <source>Numbers with 7 or fewer significant digits retain their original precision. That is, if your query returns 0.00, you will be sure that the trailing zeroes are not the artifacts of formatting: they reflect the precision of the original data. The number of leading zeroes does not affect precision: the value 0.0067 is considered to have just 2 significant digits.</source>
          <target state="translated">有7位或更少有效数字的数字保留了它们的原始精度。也就是说,如果您的查询返回0.00,您将确信后面的零不是格式化的产物:它们反映了原始数据的精度。前导零的数量并不影响精度:0.0067的值被认为只有2个重要数字。</target>
        </trans-unit>
        <trans-unit id="58224773d7dc5786efbb9bfbfa152b78d5c3ced5" translate="yes" xml:space="preserve">
          <source>Numeric Types</source>
          <target state="translated">数值类型</target>
        </trans-unit>
        <trans-unit id="f1b55ea9345add00dc53f8d39e821048683ac6ac" translate="yes" xml:space="preserve">
          <source>Numeric Types: bigint</source>
          <target state="translated">数字类型:bigint</target>
        </trans-unit>
        <trans-unit id="34ca1938464846ffd7671c72fe6fcf56ce8ed626" translate="yes" xml:space="preserve">
          <source>Numeric Types: bigserial</source>
          <target state="translated">数值类型:bigserial</target>
        </trans-unit>
        <trans-unit id="4f4c21c7dbf7d3b0ce15752213f48b0ca85c6be6" translate="yes" xml:space="preserve">
          <source>Numeric Types: decimal</source>
          <target state="translated">数字类型:十进制</target>
        </trans-unit>
        <trans-unit id="5f39be2adc33677462c0440cd7f421e180a13185" translate="yes" xml:space="preserve">
          <source>Numeric Types: double precision</source>
          <target state="translated">数字类型:双精度</target>
        </trans-unit>
        <trans-unit id="7d13fe88ea7d98f3a10e5a107a6fb5f2b06420b9" translate="yes" xml:space="preserve">
          <source>Numeric Types: integer</source>
          <target state="translated">数字类型:整数</target>
        </trans-unit>
        <trans-unit id="589f0dce7263b0f4a4ffcc692a06b6cca5db39a7" translate="yes" xml:space="preserve">
          <source>Numeric Types: numeric</source>
          <target state="translated">数字类型:数字</target>
        </trans-unit>
        <trans-unit id="d049c61cbf5f08cf4a2b6ad03914911c2436a250" translate="yes" xml:space="preserve">
          <source>Numeric Types: real</source>
          <target state="translated">数字类型:实数</target>
        </trans-unit>
        <trans-unit id="017b04d1c97e36f0333abaaf314c6a6c6bbedc30" translate="yes" xml:space="preserve">
          <source>Numeric Types: serial</source>
          <target state="translated">数字类型:串行</target>
        </trans-unit>
        <trans-unit id="9e36bc851d04411f4bd3afa229897af484988fe2" translate="yes" xml:space="preserve">
          <source>Numeric Types: smallint</source>
          <target state="translated">数字类型:smallint</target>
        </trans-unit>
        <trans-unit id="3fa9584c0cd0a43cf41d81cfcfb10456d729bae0" translate="yes" xml:space="preserve">
          <source>Numeric Types: smallserial</source>
          <target state="translated">数字类型:小数点</target>
        </trans-unit>
        <trans-unit id="a172b52198f27b4b4b6b86a0f1c9b17a17d9bf18" translate="yes" xml:space="preserve">
          <source>Numeric character-entry escapes specifying values outside the ASCII range (0&amp;ndash;127) have meanings dependent on the database encoding. When the encoding is UTF-8, escape values are equivalent to Unicode code points, for example &lt;code&gt;\u1234&lt;/code&gt; means the character &lt;code&gt;U+1234&lt;/code&gt;. For other multibyte encodings, character-entry escapes usually just specify the concatenation of the byte values for the character. If the escape value does not correspond to any legal character in the database encoding, no error will be raised, but it will never match any data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6907254669bc308bcd96a76901734e20d0b431f6" translate="yes" xml:space="preserve">
          <source>Numeric character-entry escapes specifying values outside the ASCII range (0-127) have meanings dependent on the database encoding. When the encoding is UTF-8, escape values are equivalent to Unicode code points, for example &lt;code&gt;\u1234&lt;/code&gt; means the character &lt;code&gt;U+1234&lt;/code&gt;. For other multibyte encodings, character-entry escapes usually just specify the concatenation of the byte values for the character. If the escape value does not correspond to any legal character in the database encoding, no error will be raised, but it will never match any data.</source>
          <target state="translated">数字字符输入转义符指定的ASCII范围（0-127）之外的值具有取决于数据库编码的含义。当编码为UTF-8时，转义值等效于Unicode代码点，例如 &lt;code&gt;\u1234&lt;/code&gt; 表示字符 &lt;code&gt;U+1234&lt;/code&gt; 。对于其他多字节编码，字符输入转义符通常仅指定字符的字节值的串联。如果转义值与数据库编码中的任何合法字符都不对应，则不会引发任何错误，但它将永远不会与任何数据匹配。</target>
        </trans-unit>
        <trans-unit id="6e2759a88d02cd4c49727936e3e39cfce1c8fe1b" translate="yes" xml:space="preserve">
          <source>Numeric constants are accepted in these general forms:</source>
          <target state="translated">数值常量以这些一般形式被接受。</target>
        </trans-unit>
        <trans-unit id="32c0946f98f3a53c7cc5e78bd6ba14716174ad6a" translate="yes" xml:space="preserve">
          <source>Numeric ordering, sorts sequences of digits by their numeric value, for example: &lt;code&gt;A-21&lt;/code&gt; &amp;lt; &lt;code&gt;A-123&lt;/code&gt; (also known as natural sort).</source>
          <target state="translated">数值排序按数字值对数字序列进行排序，例如： &lt;code&gt;A-21&lt;/code&gt; &amp;lt; &lt;code&gt;A-123&lt;/code&gt; （也称为自然排序）。</target>
        </trans-unit>
        <trans-unit id="8d7bc2659eda5afabdbd8dae30a1b10b69aab0fa" translate="yes" xml:space="preserve">
          <source>Numeric transaction identifier of the prepared transaction</source>
          <target state="translated">准备好的交易的数字交易标识符。</target>
        </trans-unit>
        <trans-unit id="d74de684582cb87f5abe203c6987280191b1e915" translate="yes" xml:space="preserve">
          <source>Numeric types</source>
          <target state="translated">数字类型</target>
        </trans-unit>
        <trans-unit id="bbed1ad8168ad945da348f70d8f35c3aaa2d08ae" translate="yes" xml:space="preserve">
          <source>Numeric types consist of two-, four-, and eight-byte integers, four- and eight-byte floating-point numbers, and selectable-precision decimals. &lt;a href=&quot;datatype-numeric#DATATYPE-NUMERIC-TABLE&quot;&gt;Table 8.2&lt;/a&gt; lists the available types.</source>
          <target state="translated">数值类型包括2字节，4字节和8字节整数，4字节和8字节浮点数以及可选精度的小数。&lt;a href=&quot;datatype-numeric#DATATYPE-NUMERIC-TABLE&quot;&gt;表8.2&lt;/a&gt;列出了可用的类型。</target>
        </trans-unit>
        <trans-unit id="ae34df1114cf867e5a5e67721782e6b4936cf60a" translate="yes" xml:space="preserve">
          <source>Numeric values are physically stored without any extra leading or trailing zeroes. Thus, the declared precision and scale of a column are maximums, not fixed allocations. (In this sense the &lt;code&gt;numeric&lt;/code&gt; type is more akin to &lt;code&gt;varchar(n)&lt;/code&gt; than to &lt;code&gt;char(n)&lt;/code&gt;.) The actual storage requirement is two bytes for each group of four decimal digits, plus three to eight bytes overhead.</source>
          <target state="translated">数值是物理存储的，没有任何额外的前导或尾随零。因此，声明的列的精度和小数位数是最大值，而不是固定分配。（从这种意义上说， &lt;code&gt;numeric&lt;/code&gt; 类型更类似于 &lt;code&gt;varchar(n)&lt;/code&gt; 而不是 &lt;code&gt;char(n)&lt;/code&gt; 。）实际的存储要求是每组四个十进制数字的两个字节，外加三至八个字节的开销。</target>
        </trans-unit>
        <trans-unit id="1cd1073fd79a8443ea8d6973895d5ee6ffe7cdf9" translate="yes" xml:space="preserve">
          <source>Numerical statistics of the appropriate kind for the &lt;code&gt;N&lt;/code&gt;th &amp;ldquo;slot&amp;rdquo;, or null if the slot kind does not involve numerical values</source>
          <target state="translated">第 &lt;code&gt;N&lt;/code&gt; 个&amp;ldquo;插槽&amp;rdquo; 的适当种类的数值统计；如果插槽种类不包含数值，则为null</target>
        </trans-unit>
        <trans-unit id="fb91068c51189c866a8e510b38ba4dfebf5d32bc" translate="yes" xml:space="preserve">
          <source>ODBC</source>
          <target state="translated">ODBC</target>
        </trans-unit>
        <trans-unit id="4d314276ba61e4f3bc6a1b4a234e301a4e785ad9" translate="yes" xml:space="preserve">
          <source>OID</source>
          <target state="translated">OID</target>
        </trans-unit>
        <trans-unit id="725ff3ec092f4de8d511006eba9dfe844003c6f9" translate="yes" xml:space="preserve">
          <source>OID of a database</source>
          <target state="translated">数据库的OID</target>
        </trans-unit>
        <trans-unit id="f8c02df27c83758b75b440e8700bcc0f8b46a3f0" translate="yes" xml:space="preserve">
          <source>OID of a function</source>
          <target state="translated">函数的OID</target>
        </trans-unit>
        <trans-unit id="faffc6a7f80d0822867cb82f8a02546997b88ef9" translate="yes" xml:space="preserve">
          <source>OID of a handler function that is responsible for supplying information about the access method</source>
          <target state="translated">负责提供访问方法信息的处理函数的OID。</target>
        </trans-unit>
        <trans-unit id="5a4a96aa8d7efd7ac397558d10f843a235a92c88" translate="yes" xml:space="preserve">
          <source>OID of a sequence</source>
          <target state="translated">序列的OID</target>
        </trans-unit>
        <trans-unit id="996a8d685aef72e0b42d14422b03fa62a0285fd1" translate="yes" xml:space="preserve">
          <source>OID of a table</source>
          <target state="translated">表的OID</target>
        </trans-unit>
        <trans-unit id="90f9df50ed473af29d597298ed5c8caeb84243d2" translate="yes" xml:space="preserve">
          <source>OID of database in which the statement was executed</source>
          <target state="translated">执行该语句的数据库的OID。</target>
        </trans-unit>
        <trans-unit id="080d0fef7c4d986b1330554caa1d1e593f3124b0" translate="yes" xml:space="preserve">
          <source>OID of session's temporary schema, or 0 if none</source>
          <target state="translated">会话的临时模式的OID,如果没有,则为0。</target>
        </trans-unit>
        <trans-unit id="346ed8429eddd05e15627f07718d2d6a7f44eddd" translate="yes" xml:space="preserve">
          <source>OID of the &lt;code&gt;pg_class&lt;/code&gt; entry for this foreign table</source>
          <target state="translated">此外部表的 &lt;code&gt;pg_class&lt;/code&gt; 条目的OID</target>
        </trans-unit>
        <trans-unit id="3bcb74cd3805e6c2a6b21b10048ed96a348a5d71" translate="yes" xml:space="preserve">
          <source>OID of the TOAST table associated with this table, 0 if none. The TOAST table stores large attributes &amp;ldquo;out of line&amp;rdquo; in a secondary table.</source>
          <target state="translated">与此表关联的TOAST表的OID，如果没有，则为0。TOAST表将大型属性&amp;ldquo;离线&amp;rdquo;存储在辅助表中。</target>
        </trans-unit>
        <trans-unit id="0087f0d6da4c99ba53f0596b33bf633085b24106" translate="yes" xml:space="preserve">
          <source>OID of the child table currently being scanned. This field is only valid when the phase is &lt;code&gt;acquiring inherited sample rows&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cb554635bbb124706c2580bd976000c272a3041" translate="yes" xml:space="preserve">
          <source>OID of the collation used for range comparisons, or 0 if none</source>
          <target state="translated">用于范围比较的整理的OID,如果没有,则为0。</target>
        </trans-unit>
        <trans-unit id="1af1844b19464c23fc7fd9fcae9a412bfe3133ff" translate="yes" xml:space="preserve">
          <source>OID of the data type this transform is for</source>
          <target state="translated">此变换所对应的数据类型的OID。</target>
        </trans-unit>
        <trans-unit id="7be8af1517de8b566e91490637cc744e1bfc4538" translate="yes" xml:space="preserve">
          <source>OID of the database in which the lock target exists, or zero if the target is a shared object, or null if the target is a transaction ID</source>
          <target state="translated">锁定目标存在的数据库的OID,如果目标是共享对象则为0,如果目标是事务ID则为空。</target>
        </trans-unit>
        <trans-unit id="d6eff8fed00f101585817bdde7217d409d0452cb" translate="yes" xml:space="preserve">
          <source>OID of the database this backend is connected to</source>
          <target state="translated">后台连接到的数据库的OID。</target>
        </trans-unit>
        <trans-unit id="c3f83d507478524c5f0343641eaf036c1dd5f6f4" translate="yes" xml:space="preserve">
          <source>OID of the database to which this backend is connected.</source>
          <target state="translated">该后端所连接的数据库的OID。</target>
        </trans-unit>
        <trans-unit id="99d858de93dcac0523dbaa414705f17f8ce20935" translate="yes" xml:space="preserve">
          <source>OID of the database which the subscription resides in</source>
          <target state="translated">订阅所处的数据库的OID</target>
        </trans-unit>
        <trans-unit id="3c094c24ab67863a7765120475d6a2f2e2e272ea" translate="yes" xml:space="preserve">
          <source>OID of the element type (subtype) of this range type</source>
          <target state="translated">该范围类型的元素类型(子类型)的OID。</target>
        </trans-unit>
        <trans-unit id="91964bc019a248521428ce08554d6e0d30140b28" translate="yes" xml:space="preserve">
          <source>OID of the foreign server for this foreign table</source>
          <target state="translated">该外来表的外来服务器的OID。</target>
        </trans-unit>
        <trans-unit id="73727764a13452c62b9dc37a3cc28ff75c10a8fb" translate="yes" xml:space="preserve">
          <source>OID of the foreign-data wrapper of this foreign server</source>
          <target state="translated">这个外国服务器的外国数据包装器的OID。</target>
        </trans-unit>
        <trans-unit id="bef000be97274c50b609e7040996c7f3a74549e7" translate="yes" xml:space="preserve">
          <source>OID of the function</source>
          <target state="translated">函数的OID</target>
        </trans-unit>
        <trans-unit id="d936ce13d6a2191f0fb1ebd586182169926914bd" translate="yes" xml:space="preserve">
          <source>OID of the function to convert a range value into canonical form, or 0 if none</source>
          <target state="translated">将范围值转换为规范形式的函数的OID,如果没有,则为0。</target>
        </trans-unit>
        <trans-unit id="3de3255d0dade1eabbba67bef7bb7de2117ad3f9" translate="yes" xml:space="preserve">
          <source>OID of the function to return the difference between two element values as &lt;code&gt;double precision&lt;/code&gt;, or 0 if none</source>
          <target state="translated">函数的OID，以 &lt;code&gt;double precision&lt;/code&gt; 返回两个元素值之间的差；如果没有，则返回0</target>
        </trans-unit>
        <trans-unit id="04695e3476f4985e5e3d88253bca9d829918ada5" translate="yes" xml:space="preserve">
          <source>OID of the index being created or reindexed. During a non-concurrent &lt;code&gt;CREATE INDEX&lt;/code&gt;, this is 0.</source>
          <target state="translated">正在创建或重新建立索引的OID。在非并行 &lt;code&gt;CREATE INDEX&lt;/code&gt; 期间，该值为0。</target>
        </trans-unit>
        <trans-unit id="36fd3faf4abf64d7b63021e96a36b08b96b00ad5" translate="yes" xml:space="preserve">
          <source>OID of the language this transform is for</source>
          <target state="translated">该转换所使用的语言的OID</target>
        </trans-unit>
        <trans-unit id="7e460991382ec78ace08e8b50c8809bb0c2a37f4" translate="yes" xml:space="preserve">
          <source>OID of the large object to be altered</source>
          <target state="translated">要改变的大对象的OID。</target>
        </trans-unit>
        <trans-unit id="1d1d811b028d1d43309ac3a6a9795a5474876c40" translate="yes" xml:space="preserve">
          <source>OID of the local role being mapped, 0 if the user mapping is public</source>
          <target state="translated">被映射的本地角色的OID,如果用户映射是公开的,则为0。</target>
        </trans-unit>
        <trans-unit id="f6befa197b5efdceb1d6e3e97ba6a7089030d83b" translate="yes" xml:space="preserve">
          <source>OID of the lock target within its system catalog, or null if the target is not a general database object</source>
          <target state="translated">锁定目标在其系统目录中的OID,如果目标不是一般数据库对象,则为空。</target>
        </trans-unit>
        <trans-unit id="547ca9a3f91e95b8778cc1a87f9fe368954503d2" translate="yes" xml:space="preserve">
          <source>OID of the operator</source>
          <target state="translated">运营商的OID</target>
        </trans-unit>
        <trans-unit id="57147e7dec8c6552f43472e577611d734b852d01" translate="yes" xml:space="preserve">
          <source>OID of the parser's headline function</source>
          <target state="translated">解析器的标题函数的OID。</target>
        </trans-unit>
        <trans-unit id="e75052ec080efa2cb48c4eee33c12247804336c7" translate="yes" xml:space="preserve">
          <source>OID of the parser's lextype function</source>
          <target state="translated">解析器的 lextype 函数的 OID。</target>
        </trans-unit>
        <trans-unit id="070d9465021b789c1852df9d85e1dab51aa12f2b" translate="yes" xml:space="preserve">
          <source>OID of the parser's next-token function</source>
          <target state="translated">解析器的下一个标记函数的OID。</target>
        </trans-unit>
        <trans-unit id="28ddd7cda8c6ae7b671231bc8b5771d3c20a5115" translate="yes" xml:space="preserve">
          <source>OID of the parser's shutdown function</source>
          <target state="translated">解析器的关闭功能的OID。</target>
        </trans-unit>
        <trans-unit id="3441d838ae5086ffa5ad3452eab23ff3831aa095" translate="yes" xml:space="preserve">
          <source>OID of the parser's startup function</source>
          <target state="translated">解析器启动函数的OID。</target>
        </trans-unit>
        <trans-unit id="cf7d55d689e6813249b16676499a1c0b2b7376b1" translate="yes" xml:space="preserve">
          <source>OID of the range type</source>
          <target state="translated">范围类型的OID</target>
        </trans-unit>
        <trans-unit id="00bba16646f2a65970a0b9e99737c24fb8db4ee2" translate="yes" xml:space="preserve">
          <source>OID of the relation targeted by the lock, or null if the target is not a relation or part of a relation</source>
          <target state="translated">锁定所针对的关系的OID,如果目标不是一个关系或关系的一部分,则为空。</target>
        </trans-unit>
        <trans-unit id="10ccac12f9b1c1d8ff7d1e3fe492cab3d5e3c0cd" translate="yes" xml:space="preserve">
          <source>OID of the relation that the worker is synchronizing; null for the main apply worker</source>
          <target state="translated">工作者正在同步的关系的OID;主应用工作者为空。</target>
        </trans-unit>
        <trans-unit id="64dbbea0aaf12efa0d4ebae8170596e36c349efc" translate="yes" xml:space="preserve">
          <source>OID of the source data type</source>
          <target state="translated">源数据类型的OID</target>
        </trans-unit>
        <trans-unit id="4ab6e82967b76a601d959c42c032a9613f62366e" translate="yes" xml:space="preserve">
          <source>OID of the subscription</source>
          <target state="translated">订阅的OID</target>
        </trans-unit>
        <trans-unit id="529393343c510cc7f43e20828d0d63fb68383a2c" translate="yes" xml:space="preserve">
          <source>OID of the subtype's operator class used for range comparisons</source>
          <target state="translated">用于范围比较的子类型运算符类的OID。</target>
        </trans-unit>
        <trans-unit id="633257d0b0d38e2fef790525052ae12fd0314ed1" translate="yes" xml:space="preserve">
          <source>OID of the system catalog containing the lock target, or null if the target is not a general database object</source>
          <target state="translated">包含锁定目标的系统目录的OID,如果目标不是一般数据库对象,则为空。</target>
        </trans-unit>
        <trans-unit id="6ba91c2dce09309f79136d3e66a8e5ae37f1fe91" translate="yes" xml:space="preserve">
          <source>OID of the table being analyzed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6da84f1d83f2a7ebd175fcdf78bf746dff039dba" translate="yes" xml:space="preserve">
          <source>OID of the table being clustered.</source>
          <target state="translated">被聚类的表的OID。</target>
        </trans-unit>
        <trans-unit id="0e4debb724827a1126e4f0985aac0c3bd73e2728" translate="yes" xml:space="preserve">
          <source>OID of the table being vacuumed.</source>
          <target state="translated">被吸尘表的OID。</target>
        </trans-unit>
        <trans-unit id="e9109406be796a3753b7f074b353cc534267a046" translate="yes" xml:space="preserve">
          <source>OID of the table for this index</source>
          <target state="translated">该索引的表的OID</target>
        </trans-unit>
        <trans-unit id="50e7e1691ddba39a8ac80c840ffce2b6dd3a48c8" translate="yes" xml:space="preserve">
          <source>OID of the table on which the index is being created.</source>
          <target state="translated">正在创建索引的表的OID。</target>
        </trans-unit>
        <trans-unit id="090219832be11fe1619b95babe8e9c1e5e92c437" translate="yes" xml:space="preserve">
          <source>OID of the target data type</source>
          <target state="translated">目标数据类型的OID</target>
        </trans-unit>
        <trans-unit id="ac66a3e3aabe35420bf2d2c1e94ee59c9c06a065" translate="yes" xml:space="preserve">
          <source>OID of the template's initialization function</source>
          <target state="translated">模板初始化函数的OID。</target>
        </trans-unit>
        <trans-unit id="50c0da2d8b347f30166307b39f81117e5e35c3ea" translate="yes" xml:space="preserve">
          <source>OID of the template's lexize function</source>
          <target state="translated">模板的 lexize 函数的 OID。</target>
        </trans-unit>
        <trans-unit id="a8374b131925b37be69ac971d0b27d489ca95329" translate="yes" xml:space="preserve">
          <source>OID of the user logged into this WAL sender process</source>
          <target state="translated">登录到这个WAL发送者进程的用户的OID。</target>
        </trans-unit>
        <trans-unit id="5fe5cd795b2ac38b10709cbfaf75428859cfc40c" translate="yes" xml:space="preserve">
          <source>OID of the user logged into this backend</source>
          <target state="translated">登录到这个后台的用户的OID。</target>
        </trans-unit>
        <trans-unit id="ac6509d860cce791cfecdfeff54c3c371229705b" translate="yes" xml:space="preserve">
          <source>OID of the user mapping</source>
          <target state="translated">用户映射的OID</target>
        </trans-unit>
        <trans-unit id="5cb18008fb6941eebe8d741c085bfe9b7fb69a3f" translate="yes" xml:space="preserve">
          <source>OID of this database, or 0 for objects belonging to a shared relation</source>
          <target state="translated">这个数据库的OID,如果对象属于共享关系,则为0。</target>
        </trans-unit>
        <trans-unit id="a7af712c7c37a60b529576ed90f30e8cf2d7a00c" translate="yes" xml:space="preserve">
          <source>OID of this index</source>
          <target state="translated">该索引的OID</target>
        </trans-unit>
        <trans-unit id="d3dd8c985a0eabab21975bbe483a04f61be0cad9" translate="yes" xml:space="preserve">
          <source>OID of user who executed the statement</source>
          <target state="translated">执行该语句的用户的OID</target>
        </trans-unit>
        <trans-unit id="387852e7a1481866714e0a22f56d3c6e25b3ae5f" translate="yes" xml:space="preserve">
          <source>OIDs assigned during normal database operation are constrained to be 16384 or higher. This ensures that the range 10000&amp;mdash;16383 is free for OIDs assigned automatically by &lt;code&gt;genbki.pl&lt;/code&gt; or during bootstrap. These automatically-assigned OIDs are not considered stable, and may change from one installation to another.</source>
          <target state="translated">正常数据库操作期间分配的OID限制为16384或更高。这样可以确保10000-16383范围对于genbki.pl自动分配的或在引导过程中可用的OID &lt;code&gt;genbki.pl&lt;/code&gt; 。这些自动分配的OID不稳定，可能会从一种安装更改为另一种安装。</target>
        </trans-unit>
        <trans-unit id="a08513f8d6a0456d0e2e3f8053e17f798ea2afa0" translate="yes" xml:space="preserve">
          <source>OLAP</source>
          <target state="translated">OLAP</target>
        </trans-unit>
        <trans-unit id="751cc96735bf8b84aef2fec3e06efb1b1a5b1ccc" translate="yes" xml:space="preserve">
          <source>OLTP</source>
          <target state="translated">OLTP</target>
        </trans-unit>
        <trans-unit id="25e9c7c3a98b268d5dfb9854a9b3f093ee86933f" translate="yes" xml:space="preserve">
          <source>OR &lt;code&gt;tsquery&lt;/code&gt;s together</source>
          <target state="translated">或 &lt;code&gt;tsquery&lt;/code&gt; 在一起</target>
        </trans-unit>
        <trans-unit id="204bd21a2ea07120bf9aa428b287753e7d9939bc" translate="yes" xml:space="preserve">
          <source>ORDBMS</source>
          <target state="translated">ORDBMS</target>
        </trans-unit>
        <trans-unit id="2164bde64d5e67a9aad0e7c0543250365dc40e72" translate="yes" xml:space="preserve">
          <source>ORDER BY</source>
          <target state="translated">排序方式</target>
        </trans-unit>
        <trans-unit id="8cd49ef586968599e62519504427958da4d48a39" translate="yes" xml:space="preserve">
          <source>ORs two &lt;code&gt;tsquery&lt;/code&gt;s together, producing a query that matches documents that match either input query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="b77e714dbd01a80315e52e6a9d94c65e9f359c98" translate="yes" xml:space="preserve">
          <source>Object Identifier</source>
          <target state="translated">对象标识符</target>
        </trans-unit>
        <trans-unit id="2ebed2ba0d6eed2f88e2d3187c0748eee35c9c48" translate="yes" xml:space="preserve">
          <source>Object Identifier Types</source>
          <target state="translated">对象标识符类型</target>
        </trans-unit>
        <trans-unit id="690a335354f7107071acc3fa67c016dc6bc384da" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: oid</source>
          <target state="translated">对象标识符类型:oid</target>
        </trans-unit>
        <trans-unit id="0075fd06325f676dff687ca83f8e432afb05cd0a" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regclass</source>
          <target state="translated">对象标识符类型:regclass</target>
        </trans-unit>
        <trans-unit id="47d07e7ec3c2bb281acfd4b09b95c7bd692a6146" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regcollation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ff60426c655614fda7aef019d73fd45fb97d826" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regconfig</source>
          <target state="translated">对象标识符类型:regconfig</target>
        </trans-unit>
        <trans-unit id="dfaba8ba7726385dd9aaa48834af168d2f9ceedf" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regdictionary</source>
          <target state="translated">对象标识符类型:regdictionary</target>
        </trans-unit>
        <trans-unit id="cc8674af1caee1212cf1ad2d15d842446e9a98aa" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regnamespace</source>
          <target state="translated">对象标识符类型:regnamespace</target>
        </trans-unit>
        <trans-unit id="c2b56a3df38b329696180cd377e1ed88251bb409" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regoper</source>
          <target state="translated">对象标识符类型:regoper</target>
        </trans-unit>
        <trans-unit id="30c72913cd86047f07f98633a45661ed568c2533" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regoperator</source>
          <target state="translated">对象标识符类型:Regoperator</target>
        </trans-unit>
        <trans-unit id="a48a31a0bb9251c420e48d22aa7c1d09ca5723bd" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regproc</source>
          <target state="translated">对象标识符类型:regproc</target>
        </trans-unit>
        <trans-unit id="67cdc0df1aaf8b31658af7a6a45b330191b5746d" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regprocedure</source>
          <target state="translated">对象标识符类型:regprocedure</target>
        </trans-unit>
        <trans-unit id="6c6385e5aae8c21dd4c725971f7b3936a95ef63b" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regrole</source>
          <target state="translated">对象标识符类型:regrole</target>
        </trans-unit>
        <trans-unit id="f7695a1c32f9f4d88fc2778bef31cc0d65aad8a7" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regtype</source>
          <target state="translated">对象标识符类型:regtype</target>
        </trans-unit>
        <trans-unit id="cadc94239cb6d9721bc9abae7ab74549ddda3fbb" translate="yes" xml:space="preserve">
          <source>Object Type</source>
          <target state="translated">对象类型</target>
        </trans-unit>
        <trans-unit id="440eaacb05716029aec3d29f1c4c8f8f3cf112cd" translate="yes" xml:space="preserve">
          <source>Object identifiers (OIDs) are used internally by PostgreSQL as primary keys for various system tables. Type &lt;code&gt;oid&lt;/code&gt; represents an object identifier. There are also several alias types for &lt;code&gt;oid&lt;/code&gt; named &lt;code&gt;regsomething&lt;/code&gt;. &lt;a href=&quot;datatype-oid#DATATYPE-OID-TABLE&quot;&gt;Table 8.26&lt;/a&gt; shows an overview.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="486ece6dd89f3c4ea297334b48675b716e4268bd" translate="yes" xml:space="preserve">
          <source>Object identifiers (OIDs) are used internally by PostgreSQL as primary keys for various system tables. Type &lt;code&gt;oid&lt;/code&gt; represents an object identifier. There are also several alias types for &lt;code&gt;oid&lt;/code&gt;: &lt;code&gt;regproc&lt;/code&gt;, &lt;code&gt;regprocedure&lt;/code&gt;, &lt;code&gt;regoper&lt;/code&gt;, &lt;code&gt;regoperator&lt;/code&gt;, &lt;code&gt;regclass&lt;/code&gt;, &lt;code&gt;regtype&lt;/code&gt;, &lt;code&gt;regrole&lt;/code&gt;, &lt;code&gt;regnamespace&lt;/code&gt;, &lt;code&gt;regconfig&lt;/code&gt;, and &lt;code&gt;regdictionary&lt;/code&gt;. &lt;a href=&quot;datatype-oid#DATATYPE-OID-TABLE&quot;&gt;Table 8.26&lt;/a&gt; shows an overview.</source>
          <target state="translated">PostgreSQL内部使用对象标识符（OID）作为各种系统表的主键。类型 &lt;code&gt;oid&lt;/code&gt; 代表对象标识符。 &lt;code&gt;oid&lt;/code&gt; 还有几种别名类型： &lt;code&gt;regproc&lt;/code&gt; ， &lt;code&gt;regprocedure&lt;/code&gt; ， &lt;code&gt;regoper&lt;/code&gt; ， &lt;code&gt;regoperator&lt;/code&gt; ， &lt;code&gt;regclass&lt;/code&gt; ， &lt;code&gt;regtype&lt;/code&gt; ， &lt;code&gt;regrole&lt;/code&gt; ， &lt;code&gt;regnamespace&lt;/code&gt; ， &lt;code&gt;regconfig&lt;/code&gt; 和 &lt;code&gt;regdictionary&lt;/code&gt; 。&lt;a href=&quot;datatype-oid#DATATYPE-OID-TABLE&quot;&gt;表8.26&lt;/a&gt;显示了概述。</target>
        </trans-unit>
        <trans-unit id="e6ffe45f664bbe6f6262859df4e3695e1d12153a" translate="yes" xml:space="preserve">
          <source>Object-Relational Database Management System</source>
          <target state="translated">对象关系型数据库管理系统</target>
        </trans-unit>
        <trans-unit id="ec90b7e160c78de5740196cc2532f466404d90bc" translate="yes" xml:space="preserve">
          <source>Objects can have initial privileges either by having those privileges set when the system is initialized (by initdb) or when the object is created during a &lt;code&gt;CREATE EXTENSION&lt;/code&gt; and the extension script sets initial privileges using the &lt;code&gt;GRANT&lt;/code&gt; system. Note that the system will automatically handle recording of the privileges during the extension script and that extension authors need only use the &lt;code&gt;GRANT&lt;/code&gt; and &lt;code&gt;REVOKE&lt;/code&gt; statements in their script to have the privileges recorded. The &lt;code&gt;privtype&lt;/code&gt; column indicates if the initial privilege was set by initdb or during a &lt;code&gt;CREATE EXTENSION&lt;/code&gt; command.</source>
          <target state="translated">通过在初始化系统时（通过initdb）或在 &lt;code&gt;CREATE EXTENSION&lt;/code&gt; 中创建对象并且扩展脚本使用 &lt;code&gt;GRANT&lt;/code&gt; 系统设置初始特权时设置这些特权，可以对对象具有初始特权。请注意，系统将在扩展脚本期间自动处理特权的记录，并且扩展作者仅需要在其脚本中使用 &lt;code&gt;GRANT&lt;/code&gt; 和 &lt;code&gt;REVOKE&lt;/code&gt; 语句来记录特权。所述 &lt;code&gt;privtype&lt;/code&gt; 列指示如果初始特权被initdb的或期间设置 &lt;code&gt;CREATE EXTENSION&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="8d18be902bfa3d762f98290f3d1e8291c77198c6" translate="yes" xml:space="preserve">
          <source>Objects which have initial privileges set by initdb will have entries where &lt;code&gt;privtype&lt;/code&gt; is &lt;code&gt;'i'&lt;/code&gt;, while objects which have initial privileges set by &lt;code&gt;CREATE EXTENSION&lt;/code&gt; will have entries where &lt;code&gt;privtype&lt;/code&gt; is &lt;code&gt;'e'&lt;/code&gt;.</source>
          <target state="translated">具有由initdb设置的初始特权的对象将具有 &lt;code&gt;privtype&lt;/code&gt; 为 &lt;code&gt;'i'&lt;/code&gt; 的条目，而具有由 &lt;code&gt;CREATE EXTENSION&lt;/code&gt; 设置的初始特权的对象将具有 &lt;code&gt;privtype&lt;/code&gt; 为 &lt;code&gt;'e'&lt;/code&gt; 的条目。</target>
        </trans-unit>
        <trans-unit id="8f79c201923795ddf3fc3a390dc899926a81383e" translate="yes" xml:space="preserve">
          <source>Objects with equal numbers of pairs are compared in the order:</source>
          <target state="translated">对数相等的对象按顺序进行比较。</target>
        </trans-unit>
        <trans-unit id="40a4edd85bccc1fb19d69c2e2dabe7dd4292f362" translate="yes" xml:space="preserve">
          <source>Observe how in the traditional ICU locale naming system, the root locale is selected by an empty string.</source>
          <target state="translated">观察在传统的ICU locale命名系统中,根locale是如何由一个空字符串选择的。</target>
        </trans-unit>
        <trans-unit id="82dae9ce3d89138d44c64eb3de8005375bc20848" translate="yes" xml:space="preserve">
          <source>Observe that this kind of partial index requires that the common values be predetermined, so such partial indexes are best used for data distributions that do not change. Such indexes can be recreated occasionally to adjust for new data distributions, but this adds maintenance effort.</source>
          <target state="translated">请注意,这种部分索引要求预先确定共同值,所以这种部分索引最好用于不改变的数据分布。这种索引可以偶尔重新创建,以调整新的数据分布,但这增加了维护工作。</target>
        </trans-unit>
        <trans-unit id="d607df7ca6e658558b5841d4666abffe49980352" translate="yes" xml:space="preserve">
          <source>Observe that this match would not succeed if written as</source>
          <target state="translated">请注意,如果把这个匹配写为</target>
        </trans-unit>
        <trans-unit id="d177dde8092a5f060f1495243a63f697a9a17705" translate="yes" xml:space="preserve">
          <source>Observe two things about the result set:</source>
          <target state="translated">观察结果集的两点。</target>
        </trans-unit>
        <trans-unit id="4201c9715be128e9359f0f8e049514e18476b73a" translate="yes" xml:space="preserve">
          <source>Obsolete version of &lt;code&gt;crosstab(text)&lt;/code&gt;. The parameter &lt;code&gt;N&lt;/code&gt; is now ignored, since the number of value columns is always determined by the calling query</source>
          <target state="translated">&lt;code&gt;crosstab(text)&lt;/code&gt; 的过时版本。现在将忽略参数 &lt;code&gt;N&lt;/code&gt; ，因为值列的数量始终由调用查询确定</target>
        </trans-unit>
        <trans-unit id="7df429ce2fd206ab797db57eb8b6b362392f7035" translate="yes" xml:space="preserve">
          <source>Obsolete version of &lt;code&gt;crosstab(text)&lt;/code&gt;. The parameter &lt;em&gt;&lt;code&gt;N&lt;/code&gt;&lt;/em&gt; is now ignored, since the number of value columns is always determined by the calling query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11744d185f0b82d838b338e8988d902a0140f6b7" translate="yes" xml:space="preserve">
          <source>Obtain a &lt;code&gt;SHARE&lt;/code&gt; lock on a primary key table when going to perform inserts into a foreign key table:</source>
          <target state="translated">在执行向外键表的插入操作时，在主键表上获得 &lt;code&gt;SHARE&lt;/code&gt; 锁：</target>
        </trans-unit>
        <trans-unit id="05c7fc189f9bad2f9b668a2a40c5180d608c005f" translate="yes" xml:space="preserve">
          <source>Obtain exclusive session level advisory lock</source>
          <target state="translated">获得专属会话级别的咨询锁定</target>
        </trans-unit>
        <trans-unit id="019972b3655998bb11d76b53a542ff72a8b76dca" translate="yes" xml:space="preserve">
          <source>Obtain exclusive session level advisory lock if available</source>
          <target state="translated">获得专属会话级别的咨询锁定(如果有的话</target>
        </trans-unit>
        <trans-unit id="cbeca9dbec7784436d93a189577fd29e34a7fe37" translate="yes" xml:space="preserve">
          <source>Obtain exclusive transaction level advisory lock</source>
          <target state="translated">获得独家交易级咨询锁定</target>
        </trans-unit>
        <trans-unit id="b51bd7cdf3315df0e1b538d8f77d94955e4c6d83" translate="yes" xml:space="preserve">
          <source>Obtain exclusive transaction level advisory lock if available</source>
          <target state="translated">如果有的话,获得独家交易级咨询锁定</target>
        </trans-unit>
        <trans-unit id="b1ba75ca9786f988af27bd943f8ef875b87406fc" translate="yes" xml:space="preserve">
          <source>Obtain shared session level advisory lock</source>
          <target state="translated">获得共享会话级咨询锁定</target>
        </trans-unit>
        <trans-unit id="4efab6b4a18b953adcf6fcfd9c4e7e2bbeb2b169" translate="yes" xml:space="preserve">
          <source>Obtain shared session level advisory lock if available</source>
          <target state="translated">如果有的话,获得共享会话级别的咨询锁</target>
        </trans-unit>
        <trans-unit id="9524c0b6999d2af997e67edd5b67a8f0eafef7e0" translate="yes" xml:space="preserve">
          <source>Obtain shared transaction level advisory lock</source>
          <target state="translated">获得共享交易级咨询锁</target>
        </trans-unit>
        <trans-unit id="36c2761c3324c27688dc73a65bc20a430c91b936" translate="yes" xml:space="preserve">
          <source>Obtain shared transaction level advisory lock if available</source>
          <target state="translated">如果有的话,获得共享的交易级咨询锁</target>
        </trans-unit>
        <trans-unit id="443dac9c78b1145631de0395325a4f37cac34453" translate="yes" xml:space="preserve">
          <source>Obtain the client's operating system user name from the operating system and check if it matches the requested database user name. This is only available for local connections. See &lt;a href=&quot;auth-peer&quot;&gt;Section 20.9&lt;/a&gt; for details.</source>
          <target state="translated">从操作系统获取客户端的操作系统用户名，并检查其是否与请求的数据库用户名匹配。这仅适用于本地连接。有关详细信息，请参见&lt;a href=&quot;auth-peer&quot;&gt;第20.9节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0e679373412300b3d7cf749daeaf3997d4726aac" translate="yes" xml:space="preserve">
          <source>Obtain the operating system user name of the client by contacting the ident server on the client and check if it matches the requested database user name. Ident authentication can only be used on TCP/IP connections. When specified for local connections, peer authentication will be used instead. See &lt;a href=&quot;auth-ident&quot;&gt;Section 20.8&lt;/a&gt; for details.</source>
          <target state="translated">通过联系客户端上的ident服务器获取客户端的操作系统用户名，并检查其是否与请求的数据库用户名匹配。身份验证只能在TCP / IP连接上使用。当为本地连接指定时，将使用对等身份验证。有关详细信息，请参见&lt;a href=&quot;auth-ident&quot;&gt;第20.8节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3c565c625c5016da01624ee751e9ac2b988301ee" translate="yes" xml:space="preserve">
          <source>Obtaining the next value is done using the &lt;code&gt;nextval()&lt;/code&gt; function instead of the standard's &lt;code&gt;NEXT VALUE FOR&lt;/code&gt; expression.</source>
          <target state="translated">使用 &lt;code&gt;nextval()&lt;/code&gt; 函数而不是标准的 &lt;code&gt;NEXT VALUE FOR&lt;/code&gt; 表达式来获取下一个值。</target>
        </trans-unit>
        <trans-unit id="77c27c2e821d493cd41fdb16ddcdf94550584d81" translate="yes" xml:space="preserve">
          <source>Obtains a shared session-level advisory lock if available. This will either obtain the lock immediately and return &lt;code&gt;true&lt;/code&gt;, or return &lt;code&gt;false&lt;/code&gt; without waiting if the lock cannot be acquired immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63cc890455fd4316e991288e66cd3d2f6153525e" translate="yes" xml:space="preserve">
          <source>Obtains a shared session-level advisory lock, waiting if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbea7407ba6bb6ee25b3386cda5d9955692d4486" translate="yes" xml:space="preserve">
          <source>Obtains a shared transaction-level advisory lock if available. This will either obtain the lock immediately and return &lt;code&gt;true&lt;/code&gt;, or return &lt;code&gt;false&lt;/code&gt; without waiting if the lock cannot be acquired immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3514ce32dda0a7ae50b8c2a334a5396bb99040f9" translate="yes" xml:space="preserve">
          <source>Obtains a shared transaction-level advisory lock, waiting if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e623c9bebc77403e0def2b4752f5561440ee38bb" translate="yes" xml:space="preserve">
          <source>Obtains an exclusive session-level advisory lock if available. This will either obtain the lock immediately and return &lt;code&gt;true&lt;/code&gt;, or return &lt;code&gt;false&lt;/code&gt; without waiting if the lock cannot be acquired immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34d59e1d231b4e0bffcbfc5dcc9980161d2e4fdb" translate="yes" xml:space="preserve">
          <source>Obtains an exclusive session-level advisory lock, waiting if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bbbb737cb62d654d3a0339b01c5ad954c39d181" translate="yes" xml:space="preserve">
          <source>Obtains an exclusive transaction-level advisory lock if available. This will either obtain the lock immediately and return &lt;code&gt;true&lt;/code&gt;, or return &lt;code&gt;false&lt;/code&gt; without waiting if the lock cannot be acquired immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffd08a954b4fc7be94a0c48f352d297308ce7dc5" translate="yes" xml:space="preserve">
          <source>Obtains an exclusive transaction-level advisory lock, waiting if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f2c6c6809790186229da7b012c8919a980f66c8" translate="yes" xml:space="preserve">
          <source>Obviously, indexes with non-default sort orderings are a fairly specialized feature, but sometimes they can produce tremendous speedups for certain queries. Whether it's worth maintaining such an index depends on how often you use queries that require a special sort ordering.</source>
          <target state="translated">显然,具有非默认排序顺序的索引是一个相当专业的功能,但有时它们可以为某些查询产生巨大的速度。是否值得维护这样的索引,取决于你使用需要特殊排序顺序的查询的频率。</target>
        </trans-unit>
        <trans-unit id="eb1f89e656ff03a0a31a91974becb3d200ff4b46" translate="yes" xml:space="preserve">
          <source>Obviously, no one should be accessing the clusters during the upgrade. pg_upgrade defaults to running servers on port 50432 to avoid unintended client connections. You can use the same port number for both clusters when doing an upgrade because the old and new clusters will not be running at the same time. However, when checking an old running server, the old and new port numbers must be different.</source>
          <target state="translated">pg_upgrade默认在50432端口上运行服务器,以避免意外的客户端连接。在进行升级时,你可以为两个集群使用相同的端口号,因为新旧集群不会同时运行。但是,在检查正在运行的旧服务器时,新旧端口号必须不同。</target>
        </trans-unit>
        <trans-unit id="91a6106fff0646feab85327987f859dce96328f8" translate="yes" xml:space="preserve">
          <source>Obviously, pg_restore cannot restore information that is not present in the archive file. For instance, if the archive was made using the &amp;ldquo;dump data as &lt;code&gt;INSERT&lt;/code&gt; commands&amp;rdquo; option, pg_restore will not be able to load the data using &lt;code&gt;COPY&lt;/code&gt; statements.</source>
          <target state="translated">显然，pg_restore无法还原存档文件中不存在的信息。例如，如果存档是使用&amp;ldquo;将数据作为 &lt;code&gt;INSERT&lt;/code&gt; 命令转储&amp;rdquo;选项创建的，则pg_restore将无法使用 &lt;code&gt;COPY&lt;/code&gt; 语句加载数据。</target>
        </trans-unit>
        <trans-unit id="ea9f0a51f8358360ebe5d226327ee6a6dba47689" translate="yes" xml:space="preserve">
          <source>Obviously, two rows are considered distinct if they differ in at least one column value. Null values are considered equal in this comparison.</source>
          <target state="translated">很明显,如果两行至少有一列值不同,则被认为是不同的。在这种比较中,空值被认为是相等的。</target>
        </trans-unit>
        <trans-unit id="0325b2d5f9478c521e0c1edeceeab6be935d2d2e" translate="yes" xml:space="preserve">
          <source>Occasionally it is useful to mix rules from several locales, e.g., use English collation rules but Spanish messages. To support that, a set of locale subcategories exist that control only certain aspects of the localization rules:</source>
          <target state="translated">偶尔,混合使用几种语言的规则是很有用的,例如,使用英语整理规则,但使用西班牙语信息。为了支持这一点,存在一组本地化子类别,仅控制本地化规则的某些方面。</target>
        </trans-unit>
        <trans-unit id="51327aef9866e85ef5b5b2294a28494d2715ae59" translate="yes" xml:space="preserve">
          <source>Oct</source>
          <target state="translated">Oct</target>
        </trans-unit>
        <trans-unit id="87206ae2363483496c099f8c3aac5b4a8ae2a66a" translate="yes" xml:space="preserve">
          <source>October</source>
          <target state="translated">October</target>
        </trans-unit>
        <trans-unit id="c07f133434909a3b139ea6fd5087f84900fccadf" translate="yes" xml:space="preserve">
          <source>Of course, a column can have more than one constraint. Just write the constraints one after another:</source>
          <target state="translated">当然,一列可以有多个约束条件。只要把约束条件一个接一个的写出来就可以了。</target>
        </trans-unit>
        <trans-unit id="15554cdfd90fe94a0c248e4f64467a3a5d448ea0" translate="yes" xml:space="preserve">
          <source>Of course, each column must be used with operators appropriate to the index type; clauses that involve other operators will not be considered.</source>
          <target state="translated">当然,每一列必须使用适合索引类型的运算符,涉及其他运算符的子句将不被考虑。</target>
        </trans-unit>
        <trans-unit id="3cfcf640173f2cee55033307859827db1cc0f9ba" translate="yes" xml:space="preserve">
          <source>Of course, if the remote table is not in fact updatable, an error would occur anyway. Use of this option primarily allows the error to be thrown locally without querying the remote server. Note however that the &lt;code&gt;information_schema&lt;/code&gt; views will report a &lt;code&gt;postgres_fdw&lt;/code&gt; foreign table to be updatable (or not) according to the setting of this option, without any check of the remote server.</source>
          <target state="translated">当然，如果远程表实际上不可更新，则无论如何都会发生错误。使用此选项主要是允许在不查询远程服务器的情况下在本地引发错误。但是请注意，根据该选项的设置， &lt;code&gt;information_schema&lt;/code&gt; 视图将报告 &lt;code&gt;postgres_fdw&lt;/code&gt; 外部表可更新（或不可更新），而无需检查远程服务器。</target>
        </trans-unit>
        <trans-unit id="ac88e35965ca0b1056564e9dfa16bc3a086971ee" translate="yes" xml:space="preserve">
          <source>Of course, some SQL database systems might not implement schemas at all, or provide namespace support by allowing (possibly limited) cross-database access. If you need to work with those systems, then maximum portability would be achieved by not using schemas at all.</source>
          <target state="translated">当然,有些SQL数据库系统可能根本没有实现模式,或者通过允许(可能是有限的)跨数据库访问来提供命名空间支持。如果你需要与这些系统一起工作,那么完全不使用模式将实现最大的可移植性。</target>
        </trans-unit>
        <trans-unit id="b09f440f59472b164c47e7153b71ff603597271c" translate="yes" xml:space="preserve">
          <source>Of course, the &lt;code&gt;SELECT&lt;/code&gt; statement is compatible with the SQL standard. But there are some extensions and some missing features.</source>
          <target state="translated">当然， &lt;code&gt;SELECT&lt;/code&gt; 语句与SQL标准兼容。但是有一些扩展和缺少的功能。</target>
        </trans-unit>
        <trans-unit id="b998cb5ccff7c6a6d09f60a802fba18afa38d81f" translate="yes" xml:space="preserve">
          <source>Of course, the argument of a sequence function can be an expression as well as a constant. If it is a text expression then the implicit coercion will result in a run-time lookup.</source>
          <target state="translated">当然,序列函数的参数可以是一个表达式,也可以是一个常量。如果是文本表达式,那么隐式胁迫将导致运行时的查找。</target>
        </trans-unit>
        <trans-unit id="c8ec66919586aa50108f55c55fa32064846f02f9" translate="yes" xml:space="preserve">
          <source>Of course, the number and type of the constrained columns need to match the number and type of the referenced columns.</source>
          <target state="translated">当然,约束列的数量和类型需要与引用列的数量和类型相匹配。</target>
        </trans-unit>
        <trans-unit id="608089afae6cc6682d178112cb3562d38642d49b" translate="yes" xml:space="preserve">
          <source>Of course, the previous example was heavily contrived. Normally, you would give names to your tables and columns that convey what kind of data they store. So let's look at a more realistic example:</source>
          <target state="translated">当然,前面的例子有很大的人为成分。通常情况下,你会给你的表和列命名,以表达它们存储的数据种类。所以我们来看一个更现实的例子。</target>
        </trans-unit>
        <trans-unit id="cdf2e77434f0f6336db99d58530ea7e875d07b42" translate="yes" xml:space="preserve">
          <source>Of course, the specific numbers shown here depend on the actual contents of the tables involved. Also note that the numbers, and even the selected query strategy, might vary between PostgreSQL releases due to planner improvements. In addition, the &lt;code&gt;ANALYZE&lt;/code&gt; command uses random sampling to estimate data statistics; therefore, it is possible for cost estimates to change after a fresh run of &lt;code&gt;ANALYZE&lt;/code&gt;, even if the actual distribution of data in the table has not changed.</source>
          <target state="translated">当然，此处显示的具体数字取决于所涉及表的实际内容。还要注意，由于计划程序的改进，PostgreSQL版本之间的数字甚至选择的查询策略可能会有所不同。另外， &lt;code&gt;ANALYZE&lt;/code&gt; 命令使用随机采样来估计数据统计信息。因此，即使表中的实际数据分配没有更改，在重新运行 &lt;code&gt;ANALYZE&lt;/code&gt; 之后，成本估算也可能会更改。</target>
        </trans-unit>
        <trans-unit id="a685091dfb5c40427eaec8e993f66849819cf14d" translate="yes" xml:space="preserve">
          <source>Of the character-entry escapes described in &lt;a href=&quot;functions-matching#POSIX-CHARACTER-ENTRY-ESCAPES-TABLE&quot;&gt;Table 9.19&lt;/a&gt;, XQuery supports only &lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt;, and &lt;code&gt;\t&lt;/code&gt;.</source>
          <target state="translated">在&lt;a href=&quot;functions-matching#POSIX-CHARACTER-ENTRY-ESCAPES-TABLE&quot;&gt;表9.19中&lt;/a&gt;描述的字符输入转义符中，XQuery仅支持 &lt;code&gt;\n&lt;/code&gt; ， &lt;code&gt;\r&lt;/code&gt; 和 &lt;code&gt;\t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c662143ec7a1becd10a1701782d2d5b95c4d60a8" translate="yes" xml:space="preserve">
          <source>Of the character-entry escapes described in &lt;a href=&quot;functions-matching#POSIX-CHARACTER-ENTRY-ESCAPES-TABLE&quot;&gt;Table 9.20&lt;/a&gt;, XQuery supports only &lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt;, and &lt;code&gt;\t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a7f91ef8e30ab71323f7f16c956192d29cee4ea" translate="yes" xml:space="preserve">
          <source>Of the two operator classes for type &lt;code&gt;jsonb&lt;/code&gt;, &lt;code&gt;jsonb_ops&lt;/code&gt; is the default. &lt;code&gt;jsonb_path_ops&lt;/code&gt; supports fewer operators but offers better performance for those operators. See &lt;a href=&quot;datatype-json#JSON-INDEXING&quot;&gt;Section 8.14.4&lt;/a&gt; for details.</source>
          <target state="translated">在 &lt;code&gt;jsonb&lt;/code&gt; 类型的两个运算符类中， &lt;code&gt;jsonb_ops&lt;/code&gt; 是默认值。 &lt;code&gt;jsonb_path_ops&lt;/code&gt; 支持较少的运算符，但为这些运算符提供了更好的性能。有关详细信息，请参见&lt;a href=&quot;datatype-json#JSON-INDEXING&quot;&gt;第8.14.4节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="34c9deaa906dcefa70af958d1df36fd494f6477e" translate="yes" xml:space="preserve">
          <source>Of the two operator classes for type &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;quad_point_ops&lt;/code&gt; is the default. &lt;code&gt;kd_point_ops&lt;/code&gt; supports the same operators but uses a different index data structure that may offer better performance in some applications.</source>
          <target state="translated">在类型为 &lt;code&gt;point&lt;/code&gt; 的两个运算符类中，默认为 &lt;code&gt;quad_point_ops&lt;/code&gt; 。 &lt;code&gt;kd_point_ops&lt;/code&gt; 支持相同的运算符，但使用不同的索引数据结构，在某些应用程序中可能提供更好的性能。</target>
        </trans-unit>
        <trans-unit id="823b07791eec5c49089c2fa31c806093113182bb" translate="yes" xml:space="preserve">
          <source>Of these extensions, &lt;code&gt;jsonb_plperl&lt;/code&gt; is considered &amp;ldquo;trusted&amp;rdquo;, that is, it can be installed by non-superusers who have &lt;code&gt;CREATE&lt;/code&gt; privilege on the current database. The rest require superuser privilege to install.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae7fdb11d6c25f66601f3fb8a8f5b8fcc9b0822b" translate="yes" xml:space="preserve">
          <source>Offset from UTC (positive means east of Greenwich)</source>
          <target state="translated">偏离世界协调时(正值指格林威治以东)</target>
        </trans-unit>
        <trans-unit id="1981d8aed8642cc19a01ec017cd302822eb99a80" translate="yes" xml:space="preserve">
          <source>Offset to end of free space</source>
          <target state="translated">偏移到自由空间的末端</target>
        </trans-unit>
        <trans-unit id="e27e1909bffb440ac18ed4f49dfc030d3bf289b3" translate="yes" xml:space="preserve">
          <source>Offset to start of free space</source>
          <target state="translated">到自由空间开始的偏移量</target>
        </trans-unit>
        <trans-unit id="96263ee552b7638e48664d80735a522bd69e2d15" translate="yes" xml:space="preserve">
          <source>Offset to start of special space</source>
          <target state="translated">到特殊空间开始的偏移</target>
        </trans-unit>
        <trans-unit id="7f9b46694e3dc059ec6a436a3380fe755ceb8f95" translate="yes" xml:space="preserve">
          <source>Often you will want to create a schema owned by someone else (since this is one of the ways to restrict the activities of your users to well-defined namespaces). The syntax for that is:</source>
          <target state="translated">通常情况下,你会希望创建一个由别人拥有的模式(因为这是限制用户活动到定义良好的命名空间的方法之一)。其语法是</target>
        </trans-unit>
        <trans-unit id="aa524be3205ddb773bfe2be8f0cbe395871121b5" translate="yes" xml:space="preserve">
          <source>Okay, the worst has happened and you need to recover from your backup. Here is the procedure:</source>
          <target state="translated">好了,最坏的情况发生了,你需要从备份中恢复。以下是程序。</target>
        </trans-unit>
        <trans-unit id="16be0330fc822ce35047bcbe410657ce60f50c0e" translate="yes" xml:space="preserve">
          <source>Older Linux kernels do not offer &lt;code&gt;/proc/self/oom_score_adj&lt;/code&gt;, but may have a previous version of the same functionality called &lt;code&gt;/proc/self/oom_adj&lt;/code&gt;. This works the same except the disable value is &lt;code&gt;-17&lt;/code&gt; not &lt;code&gt;-1000&lt;/code&gt;.</source>
          <target state="translated">较旧的Linux内核不提供 &lt;code&gt;/proc/self/oom_score_adj&lt;/code&gt; ，但可能具有相同功能的先前版本，称为 &lt;code&gt;/proc/self/oom_adj&lt;/code&gt; 。除了禁用值为 &lt;code&gt;-17&lt;/code&gt; not &lt;code&gt;-1000&lt;/code&gt; 以外，其他方法都相同。</target>
        </trans-unit>
        <trans-unit id="ced6ddc46443201e8e3d960abac900f5903d1b39" translate="yes" xml:space="preserve">
          <source>Older PostgreSQL versions do not have this setting and always use the client's preferences. This setting is mainly for backward compatibility with those versions. Using the server's preferences is usually better because it is more likely that the server is appropriately configured.</source>
          <target state="translated">旧版本的PostgreSQL没有这个设置,总是使用客户端的偏好。这个设置主要是为了与这些版本向后兼容。使用服务器的首选项通常更好,因为服务器更有可能被适当配置。</target>
        </trans-unit>
        <trans-unit id="b76ff612400899f457b05452321eac3486e8a6ab" translate="yes" xml:space="preserve">
          <source>Oldest unpruned XMAX on page, or zero if none</source>
          <target state="translated">页面上最古老的未修剪的XMAX,如果没有,则为零。</target>
        </trans-unit>
        <trans-unit id="794b92ddcf68cabe2809fe5836f4849010daf46d" translate="yes" xml:space="preserve">
          <source>Oleg Bartunov &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:obartunov@postgrespro.ru&quot;&gt;obartunov@postgrespro.ru&lt;/a&gt;&amp;gt;&lt;/code&gt;, Postgres Professional, Moscow, Russia</source>
          <target state="translated">Oleg Bartunov &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:obartunov@postgrespro.ru&quot;&gt;obartunov@postgrespro.ru&lt;/a&gt;&amp;gt;&lt;/code&gt; ，Postgres Professional，俄罗斯莫斯科</target>
        </trans-unit>
        <trans-unit id="21c3dce2dbff52b671e09984835bd018b576e577" translate="yes" xml:space="preserve">
          <source>Oleg Bartunov &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:oleg@sai.msu.su&quot;&gt;oleg@sai.msu.su&lt;/a&gt;&amp;gt;&lt;/code&gt;, Moscow, Moscow University, Russia</source>
          <target state="translated">Oleg Bartunov &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:oleg@sai.msu.su&quot;&gt;oleg@sai.msu.su&lt;/a&gt;&amp;gt;&lt;/code&gt; ，莫斯科，俄罗斯莫斯科大学</target>
        </trans-unit>
        <trans-unit id="c57ccf7fdc0e782593eaa681140c5d9ba28fcdd1" translate="yes" xml:space="preserve">
          <source>Omit the &lt;code&gt;ROW()&lt;/code&gt; syntax in the common case where only one field needs to be checked to recognize a cycle. This allows a simple array rather than a composite-type array to be used, gaining efficiency.</source>
          <target state="translated">在通常只需要检查一个字段即可识别一个循环的常见情况下，请省略 &lt;code&gt;ROW()&lt;/code&gt; 语法。这允许使用简单阵列而不是复合型阵列，从而提高了效率。</target>
        </trans-unit>
        <trans-unit id="263c5dac706b853afb054876ee3140dcdc435cf6" translate="yes" xml:space="preserve">
          <source>Omitted &lt;code&gt;FROM&lt;/code&gt; Clauses</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 条款中省略</target>
        </trans-unit>
        <trans-unit id="46b3737570e6db5d4ea7e5047dd8b127387b63f0" translate="yes" xml:space="preserve">
          <source>Omitting the &lt;code&gt;AS&lt;/code&gt; Key Word</source>
          <target state="translated">省略 &lt;code&gt;AS&lt;/code&gt; 关键字</target>
        </trans-unit>
        <trans-unit id="22a45e27f71c292f06706c737b69fd6802e9347f" translate="yes" xml:space="preserve">
          <source>On FreeBSD, IDE drives can be queried using &lt;code&gt;atacontrol&lt;/code&gt; and write caching turned off using &lt;code&gt;hw.ata.wc=0&lt;/code&gt; in &lt;code&gt;/boot/loader.conf&lt;/code&gt;; SCSI drives can be queried using &lt;code&gt;camcontrol identify&lt;/code&gt;, and the write cache both queried and changed using &lt;code&gt;sdparm&lt;/code&gt; when available.</source>
          <target state="translated">在FreeBSD，IDE驱动器可以使用查询 &lt;code&gt;atacontrol&lt;/code&gt; 和写缓存关闭使用 &lt;code&gt;hw.ata.wc=0&lt;/code&gt; 中 &lt;code&gt;/boot/loader.conf&lt;/code&gt; ; 可以使用 &lt;code&gt;camcontrol identify&lt;/code&gt; 来查询SCSI驱动器，并在可用时使用 &lt;code&gt;sdparm&lt;/code&gt; 来查询和更改写缓存。</target>
        </trans-unit>
        <trans-unit id="d39ed9f52193cbb9703d5a56c5956b148e841314" translate="yes" xml:space="preserve">
          <source>On Linux 2.6 and later, it is possible to modify the kernel's behavior so that it will not &amp;ldquo;overcommit&amp;rdquo; memory. Although this setting will not prevent the &lt;a href=&quot;https://lwn.net/Articles/104179/&quot;&gt;OOM killer&lt;/a&gt; from being invoked altogether, it will lower the chances significantly and will therefore lead to more robust system behavior. This is done by selecting strict overcommit mode via &lt;code&gt;sysctl&lt;/code&gt;:</source>
          <target state="translated">在Linux 2.6和更高版本上，可以修改内核的行为，以便它不会&amp;ldquo;过量使用&amp;rdquo;内存。尽管此设置不会完全阻止&lt;a href=&quot;https://lwn.net/Articles/104179/&quot;&gt;OOM杀手的&lt;/a&gt;调用，但是它将大大降低机会，因此将导致更强大的系统行为。这可以通过 &lt;code&gt;sysctl&lt;/code&gt; 选择严格的过量使用模式来完成：</target>
        </trans-unit>
        <trans-unit id="501ddfe2d2530fe9fcac7688b14da5778270cdb1" translate="yes" xml:space="preserve">
          <source>On Linux &lt;code&gt;/proc/sys/fs/file-max&lt;/code&gt; determines the maximum number of open files that the kernel will support. It can be changed by writing a different number into the file or by adding an assignment in &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;. The maximum limit of files per process is fixed at the time the kernel is compiled; see &lt;code&gt;/usr/src/linux/Documentation/proc.txt&lt;/code&gt; for more information.</source>
          <target state="translated">在Linux上， &lt;code&gt;/proc/sys/fs/file-max&lt;/code&gt; 确定内核将支持的最大打开文件数。可以通过在文件中写入其他数字或在 &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 中添加赋值来更改它。在编译内核时，每个进程的文件最大限制是固定的；有关更多信息，请参见 &lt;code&gt;/usr/src/linux/Documentation/proc.txt&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f009fe3fb04da9e8adcc93565c99cbfd73e2affe" translate="yes" xml:space="preserve">
          <source>On Linux and POSIX platforms &lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-FLUSH-AFTER&quot;&gt;checkpoint_flush_after&lt;/a&gt; allows to force the OS that pages written by the checkpoint should be flushed to disk after a configurable number of bytes. Otherwise, these pages may be kept in the OS's page cache, inducing a stall when &lt;code&gt;fsync&lt;/code&gt; is issued at the end of a checkpoint. This setting will often help to reduce transaction latency, but it also can have an adverse effect on performance; particularly for workloads that are bigger than &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;, but smaller than the OS's page cache.</source>
          <target state="translated">在Linux和POSIX平台上，&lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-FLUSH-AFTER&quot;&gt;checkpoint_flush_after&lt;/a&gt;允许操作系统强制将由检查点写入的页面在可配置的字节数后刷新到磁盘。否则，这些页面可能会保留在OS的页面缓存中，从而在检查点末尾发出 &lt;code&gt;fsync&lt;/code&gt; 时导致停顿。此设置通常有助于减少事务等待时间，但也可能对性能产生不利影响。特别是对于大于&lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;但小于OS页面缓存的工作负载。</target>
        </trans-unit>
        <trans-unit id="c936f58f7f62e48372e8a8076ff322928b68bb04" translate="yes" xml:space="preserve">
          <source>On Linux or Unix systems, you might use:</source>
          <target state="translated">在Linux或Unix系统上,你可以使用。</target>
        </trans-unit>
        <trans-unit id="3f7c8c1bd4d71387a1210efd816cb3bef4ae3f74" translate="yes" xml:space="preserve">
          <source>On Linux systems either add</source>
          <target state="translated">在Linux系统中,可以添加</target>
        </trans-unit>
        <trans-unit id="dc805fd8588880f607d3f4520d6ee5e450aee68a" translate="yes" xml:space="preserve">
          <source>On Linux, IDE and SATA drives can be queried using &lt;code&gt;hdparm -I&lt;/code&gt;; write caching is enabled if there is a &lt;code&gt;*&lt;/code&gt; next to &lt;code&gt;Write cache&lt;/code&gt;. &lt;code&gt;hdparm -W 0&lt;/code&gt; can be used to turn off write caching. SCSI drives can be queried using &lt;a href=&quot;http://sg.danny.cz/sg/sdparm.html&quot;&gt;sdparm&lt;/a&gt;. Use &lt;code&gt;sdparm --get=WCE&lt;/code&gt; to check whether the write cache is enabled and &lt;code&gt;sdparm --clear=WCE&lt;/code&gt; to disable it.</source>
          <target state="translated">在Linux上，可以使用 &lt;code&gt;hdparm -I&lt;/code&gt; 查询IDE和SATA驱动器；如果写入缓存旁边有 &lt;code&gt;*&lt;/code&gt; ,则启用 &lt;code&gt;Write cache&lt;/code&gt; 。 &lt;code&gt;hdparm -W 0&lt;/code&gt; 可用于关闭写缓存。可以使用&lt;a href=&quot;http://sg.danny.cz/sg/sdparm.html&quot;&gt;sdparm&lt;/a&gt;查询SCSI驱动器。使用 &lt;code&gt;sdparm --get=WCE&lt;/code&gt; 检查是否启用了写缓存，并使用 &lt;code&gt;sdparm --clear=WCE&lt;/code&gt; 禁用它。</target>
        </trans-unit>
        <trans-unit id="55da6c1d848d4260b86ebf92495a2847786e7138" translate="yes" xml:space="preserve">
          <source>On Microsoft Windows, also:</source>
          <target state="translated">在微软Windows上,也。</target>
        </trans-unit>
        <trans-unit id="3630213a83c6eeeff64f72e78908e323507bf7bd" translate="yes" xml:space="preserve">
          <source>On NetBSD, use either the FreeBSD or Linux start scripts, depending on preference.</source>
          <target state="translated">在NetBSD上,根据喜好,使用FreeBSD或Linux的启动脚本。</target>
        </trans-unit>
        <trans-unit id="ba742d094af1abbc78f9a3859fd3be730c7188af" translate="yes" xml:space="preserve">
          <source>On OpenBSD, add the following lines to the file &lt;code&gt;/etc/rc.local&lt;/code&gt;:</source>
          <target state="translated">在OpenBSD上，将以下行添加到文件 &lt;code&gt;/etc/rc.local&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="6c2c1726b1c50e52c768b284b11ed29bfb8afb96" translate="yes" xml:space="preserve">
          <source>On Solaris, create a file called &lt;code&gt;/etc/init.d/postgresql&lt;/code&gt; that contains the following line:</source>
          <target state="translated">在Solaris上，创建一个名为 &lt;code&gt;/etc/init.d/postgresql&lt;/code&gt; 的文件，其中包含以下行：</target>
        </trans-unit>
        <trans-unit id="2bb8949d83fc7ef1475b557895bfe563a925aea9" translate="yes" xml:space="preserve">
          <source>On Solaris, the disk write cache is controlled by &lt;code&gt;format -e&lt;/code&gt;. (The Solaris ZFS file system is safe with disk write-cache enabled because it issues its own disk cache flush commands.)</source>
          <target state="translated">在Solaris上，磁盘写缓存由 &lt;code&gt;format -e&lt;/code&gt; 控制。（Solaris ZFS文件系统在启用磁盘写缓存的情况下是安全的，因为它会发出自己的磁盘缓存刷新命令。）</target>
        </trans-unit>
        <trans-unit id="d85af98780490009a295939145f84e031804f11c" translate="yes" xml:space="preserve">
          <source>On Unix systems this parameter reports the permissions of the data directory defined by (&lt;a href=&quot;runtime-config-file-locations#GUC-DATA-DIRECTORY&quot;&gt;data_directory&lt;/a&gt;) at startup. (On Microsoft Windows this parameter will always display &lt;code&gt;0700&lt;/code&gt;). See &lt;a href=&quot;app-initdb#APP-INITDB-ALLOW-GROUP-ACCESS&quot;&gt;group access&lt;/a&gt; for more information.</source>
          <target state="translated">在Unix系统上，此参数报告启动时由（&lt;a href=&quot;runtime-config-file-locations#GUC-DATA-DIRECTORY&quot;&gt;data_directory&lt;/a&gt;）定义的数据目录的权限。（在Microsoft Windows上，此参数将始终显示 &lt;code&gt;0700&lt;/code&gt; ）。有关更多信息，请参见&lt;a href=&quot;app-initdb#APP-INITDB-ALLOW-GROUP-ACCESS&quot;&gt;组访问&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5d93a70eed193dd90ef032ea7d63d19a6516eb0a" translate="yes" xml:space="preserve">
          <source>On Unix systems this parameter sets the permissions for log files when &lt;code&gt;logging_collector&lt;/code&gt; is enabled. (On Microsoft Windows this parameter is ignored.) The parameter value is expected to be a numeric mode specified in the format accepted by the &lt;code&gt;chmod&lt;/code&gt; and &lt;code&gt;umask&lt;/code&gt; system calls. (To use the customary octal format the number must start with a &lt;code&gt;0&lt;/code&gt; (zero).)</source>
          <target state="translated">在Unix系统上，启用 &lt;code&gt;logging_collector&lt;/code&gt; 时，此参数设置日志文件的权限。 （在Microsoft Windows上，将忽略此参数。）参数值应为 &lt;code&gt;chmod&lt;/code&gt; 和 &lt;code&gt;umask&lt;/code&gt; 系统调用接受的格式中指定的数字模式。 （要使用常规的八进制格式，数字必须以 &lt;code&gt;0&lt;/code&gt; （零）开头。）</target>
        </trans-unit>
        <trans-unit id="aec768083a143a16efefa19e77bcef93265299f5" translate="yes" xml:space="preserve">
          <source>On Unix systems, the permissions on &lt;code&gt;server.key&lt;/code&gt; must disallow any access to world or group; achieve this by the command &lt;code&gt;chmod 0600 server.key&lt;/code&gt;. Alternatively, the file can be owned by root and have group read access (that is, &lt;code&gt;0640&lt;/code&gt; permissions). That setup is intended for installations where certificate and key files are managed by the operating system. The user under which the PostgreSQL server runs should then be made a member of the group that has access to those certificate and key files.</source>
          <target state="translated">在Unix系统上，对 &lt;code&gt;server.key&lt;/code&gt; 的许可必须禁止对world或group的任何访问。通过命令 &lt;code&gt;chmod 0600 server.key&lt;/code&gt; 来实现。或者，该文件可以由root拥有，并具有组读取访问权限（即 &lt;code&gt;0640&lt;/code&gt; 权限）。该设置适用于证书和密钥文件由操作系统管理的安装。然后，应该使运行PostgreSQL服务器的用户成为有权访问这些证书和密钥文件的组的成员。</target>
        </trans-unit>
        <trans-unit id="e0de69e7d7ec6add644868e783650d15d55a6f2e" translate="yes" xml:space="preserve">
          <source>On Windows hosts, preloading a library at server start will not reduce the time required to start each new server process; each server process will re-load all preload libraries. However, &lt;code&gt;shared_preload_libraries&lt;/code&gt; is still useful on Windows hosts for libraries that need to perform operations at postmaster start time.</source>
          <target state="translated">在Windows主机上，在服务器启动时预加载库不会减少启动每个新服务器进程所需的时间；每个服务器进程将重新加载所有预加载库。但是， &lt;code&gt;shared_preload_libraries&lt;/code&gt; 在Windows主机上对于需要在postmaster启动时执行操作的库仍然有用。</target>
        </trans-unit>
        <trans-unit id="08c92789aa023ae69cee69a7db7a2ae77f278c4c" translate="yes" xml:space="preserve">
          <source>On Windows, if &lt;code&gt;wal_sync_method&lt;/code&gt; is &lt;code&gt;open_datasync&lt;/code&gt; (the default), write caching can be disabled by unchecking &lt;code&gt;My Computer\Open\disk drive\Properties\Hardware\Properties\Policies\Enable write caching on the disk&lt;/code&gt;. Alternatively, set &lt;code&gt;wal_sync_method&lt;/code&gt; to &lt;code&gt;fsync&lt;/code&gt; or &lt;code&gt;fsync_writethrough&lt;/code&gt;, which prevent write caching.</source>
          <target state="translated">在Windows上，如果 &lt;code&gt;wal_sync_method&lt;/code&gt; 是 &lt;code&gt;open_datasync&lt;/code&gt; （默认设置），则可以通过取消选中 &lt;code&gt;My Computer\Open\disk drive\Properties\Hardware\Properties\Policies\Enable write caching on the disk&lt;/code&gt; 。或者，将 &lt;code&gt;wal_sync_method&lt;/code&gt; 设置为 &lt;code&gt;fsync&lt;/code&gt; 或 &lt;code&gt;fsync_writethrough&lt;/code&gt; ，以防止写缓存。</target>
        </trans-unit>
        <trans-unit id="81eec3e42d4f18ead15b1e929550fb213358fb1f" translate="yes" xml:space="preserve">
          <source>On Windows, setting a value of 0 will set this parameter to 1 second, since Windows does not provide a way to read the system default value.</source>
          <target state="translated">在Windows上,设置值为0,将把这个参数设置为1秒,因为Windows没有提供读取系统默认值的方法。</target>
        </trans-unit>
        <trans-unit id="53478c470af75305cb8745b03e7cb49bde700061" translate="yes" xml:space="preserve">
          <source>On Windows, setting a value of 0 will set this parameter to 2 hours, since Windows does not provide a way to read the system default value.</source>
          <target state="translated">在Windows上,设置值为0,将把这个参数设置为2小时,因为Windows没有提供读取系统默认值的方法。</target>
        </trans-unit>
        <trans-unit id="c0312ea0b4215b07b7b0ad5539831203f3c1aa4d" translate="yes" xml:space="preserve">
          <source>On Windows, when you use the &lt;code&gt;eventlog&lt;/code&gt; option for &lt;code&gt;log_destination&lt;/code&gt;, you should register an event source and its library with the operating system so that the Windows Event Viewer can display event log messages cleanly. See &lt;a href=&quot;event-log-registration&quot;&gt;Section 18.12&lt;/a&gt; for details.</source>
          <target state="translated">在Windows上，将 &lt;code&gt;eventlog&lt;/code&gt; 选项用于 &lt;code&gt;log_destination&lt;/code&gt; 时，应在操作系统上注册事件源及其库，以便Windows Event Viewer可以干净地显示事件日志消息。有关详细信息，请参见&lt;a href=&quot;event-log-registration&quot;&gt;第18.12节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fed4544374a90927980cc01194ee5bade4dcaae9" translate="yes" xml:space="preserve">
          <source>On a hot standby, the status of the WAL receiver process can be retrieved via the &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-WAL-RECEIVER-VIEW&quot;&gt;&lt;code&gt;pg_stat_wal_receiver&lt;/code&gt;&lt;/a&gt; view. A large difference between &lt;code&gt;pg_last_wal_replay_lsn&lt;/code&gt; and the view's &lt;code&gt;flushed_lsn&lt;/code&gt; indicates that WAL is being received faster than it can be replayed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5ae51b938e943ee6107b7e5c25bdb8c42c5ee40" translate="yes" xml:space="preserve">
          <source>On a hot standby, the status of the WAL receiver process can be retrieved via the &lt;a href=&quot;monitoring-stats#PG-STAT-WAL-RECEIVER-VIEW&quot;&gt;pg_stat_wal_receiver&lt;/a&gt; view. A large difference between &lt;code&gt;pg_last_wal_replay_lsn&lt;/code&gt; and the view's &lt;code&gt;received_lsn&lt;/code&gt; indicates that WAL is being received faster than it can be replayed.</source>
          <target state="translated">在热备用数据库上，可以通过&lt;a href=&quot;monitoring-stats#PG-STAT-WAL-RECEIVER-VIEW&quot;&gt;pg_stat_wal_receiver&lt;/a&gt;视图检索WAL接收器进程的状态。之间的大的差 &lt;code&gt;pg_last_wal_replay_lsn&lt;/code&gt; 和视图的 &lt;code&gt;received_lsn&lt;/code&gt; 指示正在接收的WAL速度比它可以重放。</target>
        </trans-unit>
        <trans-unit id="a87ef11e5bf076fa4c6ca218448b2458c3ebe4c9" translate="yes" xml:space="preserve">
          <source>On all currently supported platforms, the &lt;code&gt;real&lt;/code&gt; type has a range of around 1E-37 to 1E+37 with a precision of at least 6 decimal digits. The &lt;code&gt;double precision&lt;/code&gt; type has a range of around 1E-307 to 1E+308 with a precision of at least 15 digits. Values that are too large or too small will cause an error. Rounding might take place if the precision of an input number is too high. Numbers too close to zero that are not representable as distinct from zero will cause an underflow error.</source>
          <target state="translated">在当前所有受支持的平台上， &lt;code&gt;real&lt;/code&gt; 类型的范围在1E-37到1E + 37之间，精度至少为6个十进制数字。在 &lt;code&gt;double precision&lt;/code&gt; 型具有一系列围绕1E-307到1E + 308具有至少15位精度的。太大或太小的值都会导致错误。如果输入数字的精度过高，则可能会四舍五入。太接近零且无法表示为不同于零的数字将导致下溢错误。</target>
        </trans-unit>
        <trans-unit id="fc9f60ea02e43afcbb3f8733c606556d9627a339" translate="yes" xml:space="preserve">
          <source>On all platforms, the collations named &lt;code&gt;default&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, and &lt;code&gt;POSIX&lt;/code&gt; are available. Additional collations may be available depending on operating system support. The &lt;code&gt;default&lt;/code&gt; collation selects the &lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt; values specified at database creation time. The &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;POSIX&lt;/code&gt; collations both specify &amp;ldquo;traditional C&amp;rdquo; behavior, in which only the ASCII letters &amp;ldquo;&lt;code&gt;A&lt;/code&gt;&amp;rdquo; through &amp;ldquo;&lt;code&gt;Z&lt;/code&gt;&amp;rdquo; are treated as letters, and sorting is done strictly by character code byte values.</source>
          <target state="translated">在所有平台上，都可以使用名为 &lt;code&gt;default&lt;/code&gt; ， &lt;code&gt;C&lt;/code&gt; 和 &lt;code&gt;POSIX&lt;/code&gt; 的排序规则。根据操作系统支持，可能会提供其他归类。在 &lt;code&gt;default&lt;/code&gt; 排序选择 &lt;code&gt;LC_COLLATE&lt;/code&gt; 和 &lt;code&gt;LC_CTYPE&lt;/code&gt; 在创建数据库时指定的值。该 &lt;code&gt;C&lt;/code&gt; 和 &lt;code&gt;POSIX&lt;/code&gt; 排序规则都规定了&amp;ldquo;传统C&amp;rdquo;的行为，其中仅ASCII字母&amp;ldquo; &lt;code&gt;A&lt;/code&gt; &amp;rdquo;到&amp;ldquo; &lt;code&gt;Z&lt;/code&gt; ^ &amp;rdquo;被视为字母和排序由字符代码的字节值严格完成。</target>
        </trans-unit>
        <trans-unit id="1c0634f5bf5f884787664141e116cb74ad234b48" translate="yes" xml:space="preserve">
          <source>On error, the server can abort the authentication at any stage, and send an ErrorMessage.</source>
          <target state="translated">出错时,服务器可以在任何阶段中止认证,并发送一个ErrorMessage。</target>
        </trans-unit>
        <trans-unit id="5350086780663aaf1bd7a44ba47818175298a073" translate="yes" xml:space="preserve">
          <source>On macOS, write caching can be prevented by setting &lt;code&gt;wal_sync_method&lt;/code&gt; to &lt;code&gt;fsync_writethrough&lt;/code&gt;.</source>
          <target state="translated">在macOS上，可以通过将 &lt;code&gt;wal_sync_method&lt;/code&gt; 设置为 &lt;code&gt;fsync_writethrough&lt;/code&gt; 来防止写缓存。</target>
        </trans-unit>
        <trans-unit id="befd8f0dca607b26fc6d2d970cd74ce25f6b225a" translate="yes" xml:space="preserve">
          <source>On many systems, however, syslog is not very reliable, particularly with large log messages; it might truncate or drop messages just when you need them the most. Also, on Linux, syslog will flush each message to disk, yielding poor performance. (You can use a &amp;ldquo;&lt;code&gt;-&lt;/code&gt;&amp;rdquo; at the start of the file name in the syslog configuration file to disable syncing.)</source>
          <target state="translated">但是，在许多系统上，syslog并不是非常可靠，特别是对于大型日志消息而言。它可能会在最需要时截断或删除邮件。另外，在Linux上，syslog会将每个消息刷新到磁盘，从而导致性能下降。（您可以在syslog配置文件中文件名的开头使用&amp;ldquo; &lt;code&gt;-&lt;/code&gt; &amp;rdquo;来禁用同步。）</target>
        </trans-unit>
        <trans-unit id="cb6093f7e35a1c20e326af32dcefbf608a486601" translate="yes" xml:space="preserve">
          <source>On most Unix platforms, PostgreSQL modifies its command title as reported by &lt;code&gt;ps&lt;/code&gt;, so that individual server processes can readily be identified. A sample display is</source>
          <target state="translated">在大多数Unix平台上，PostgreSQL修改 &lt;code&gt;ps&lt;/code&gt; 所报告的命令标题，以便可以轻松识别各个服务器进程。样本显示为</target>
        </trans-unit>
        <trans-unit id="d3b91e78aa6712803e0d5864f8e480013e5bf3c9" translate="yes" xml:space="preserve">
          <source>On most Unix systems, you will need to alter the configuration of your system's syslog daemon in order to make use of the syslog option for &lt;code&gt;log_destination&lt;/code&gt;. PostgreSQL can log to syslog facilities &lt;code&gt;LOCAL0&lt;/code&gt; through &lt;code&gt;LOCAL7&lt;/code&gt; (see &lt;a href=&quot;runtime-config-logging#GUC-SYSLOG-FACILITY&quot;&gt;syslog_facility&lt;/a&gt;), but the default syslog configuration on most platforms will discard all such messages. You will need to add something like:</source>
          <target state="translated">在大多数Unix系统上，为了使用 &lt;code&gt;log_destination&lt;/code&gt; 的syslog选项，您将需要更改系统syslog守护程序的配置。 PostgreSQL可以通过 &lt;code&gt;LOCAL7&lt;/code&gt; 登录到 &lt;code&gt;LOCAL0&lt;/code&gt; 到syslog设施（请参阅&lt;a href=&quot;runtime-config-logging#GUC-SYSLOG-FACILITY&quot;&gt;syslog_facility&lt;/a&gt;），但是大多数平台上的默认syslog配置将丢弃所有此类消息。您将需要添加以下内容：</target>
        </trans-unit>
        <trans-unit id="50e3c6b1dcc491688ab2b7696ca3d74d8a9db77d" translate="yes" xml:space="preserve">
          <source>On most modern operating systems, PostgreSQL can determine which character set is implied by the &lt;code&gt;LC_CTYPE&lt;/code&gt; setting, and it will enforce that only the matching database encoding is used. On older systems it is your responsibility to ensure that you use the encoding expected by the locale you have selected. A mistake in this area is likely to lead to strange behavior of locale-dependent operations such as sorting.</source>
          <target state="translated">在大多数现代操作系统上，PostgreSQL可以确定 &lt;code&gt;LC_CTYPE&lt;/code&gt; 设置所隐含的字符集，并且它将强制要求仅使用匹配的数据库编码。在较旧的系统上，您有责任确保使用所选语言环境所期望的编码。该区域中的错误很可能导致诸如排序之类的与语言环境相关的操作的奇怪行为。</target>
        </trans-unit>
        <trans-unit id="b2260de2d5df529fa47da0a7e6dd5d8bb23e03ee" translate="yes" xml:space="preserve">
          <source>On most platforms, if PostgreSQL is built with &lt;code&gt;--enable-dtrace&lt;/code&gt;, the arguments to a trace macro will be evaluated whenever control passes through the macro, &lt;em&gt;even if no tracing is being done&lt;/em&gt;. This is usually not worth worrying about if you are just reporting the values of a few local variables. But beware of putting expensive function calls into the arguments. If you need to do that, consider protecting the macro with a check to see if the trace is actually enabled:</source>
          <target state="translated">在大多数平台上，如果PostgreSQL是使用 &lt;code&gt;--enable-dtrace&lt;/code&gt; 构建的，则只要控制通过该宏，就将评估trace宏的参数，&lt;em&gt;即使未进行任何跟踪也是如此&lt;/em&gt;。如果仅报告一些局部变量的值，通常就不必担心。但是要注意不要将昂贵的函数调用放入参数中。如果需要这样做，请考虑通过检查是否实际启用跟踪来保护宏：</target>
        </trans-unit>
        <trans-unit id="d1a020e1e97e31739abdd2c2ef2354878b9e297e" translate="yes" xml:space="preserve">
          <source>On one system, an &lt;code&gt;EXPLAIN&lt;/code&gt; showed a query with a cost of 8488 was reduced to a cost of 329. The original query was a join involving the &lt;code&gt;one_to_many&lt;/code&gt; table, which was replaced by:</source>
          <target state="translated">在一个系统上， &lt;code&gt;EXPLAIN&lt;/code&gt; 显示成本为8488的查询减少为成本329。原始查询是一个涉及 &lt;code&gt;one_to_many&lt;/code&gt; 表的联接，该联接被替换为：</target>
        </trans-unit>
        <trans-unit id="46913037bc93da8c08a056c91624219985822221" translate="yes" xml:space="preserve">
          <source>On output, double quotes always surround keys and values, even when it's not strictly necessary.</source>
          <target state="translated">在输出时,即使不是严格意义上的必要,双引号也总是环绕着键和值。</target>
        </trans-unit>
        <trans-unit id="bac2b8b67734755e62d6acef24655269b5ebc6a2" translate="yes" xml:space="preserve">
          <source>On some newer Linux systems, it's possible to change the clock source used to collect timing data at any time. A second example shows the slowdown possible from switching to the slower acpi_pm time source, on the same system used for the fast results above:</source>
          <target state="translated">在一些较新的 Linux 系统上,可以随时改变用于收集定时数据的时钟源。第二个例子显示了在上述快速结果所使用的同一系统上,切换到较慢的acpi_pm时间源可能会造成的减速。</target>
        </trans-unit>
        <trans-unit id="9ce5931c68b8a455769ec944aab5c902a50f0a9b" translate="yes" xml:space="preserve">
          <source>On some operating systems, the status of data in the kernel's page cache is unknown after a write-back failure. In some cases it might have been entirely forgotten, making it unsafe to retry; the second attempt may be reported as successful, when in fact the data has been lost. In these circumstances, the only way to avoid data loss is to recover from the WAL after any failure is reported, preferably after investigating the root cause of the failure and replacing any faulty hardware.</source>
          <target state="translated">在某些操作系统上,回写失败后,内核页面缓存中的数据状态是未知的。在某些情况下,数据可能已经完全被遗忘了,因此重新尝试是不安全的;第二次尝试可能被报告为成功,但实际上数据已经丢失了。在这些情况下,避免数据丢失的唯一方法是在报告任何故障后从WAL中恢复,最好是在调查故障的根本原因并更换任何有问题的硬件之后。</target>
        </trans-unit>
        <trans-unit id="eee21b404ba214868f7afb4e8cb293a79759405b" translate="yes" xml:space="preserve">
          <source>On some systems, this locale category does not exist. Setting this variable will still work, but there will be no effect. Also, there is a chance that no translated messages for the desired language exist. In that case you will continue to see the English messages.</source>
          <target state="translated">在某些系统中,这个locale类别不存在。设置这个变量仍然有效,但没有任何效果。另外,也有可能不存在所需语言的翻译信息,在这种情况下,你将继续看到英文信息。在这种情况下,你将继续看到英文信息。</target>
        </trans-unit>
        <trans-unit id="d8426bc3d71cab36b2e69aeb3bfdd7499b750f4a" translate="yes" xml:space="preserve">
          <source>On success, &lt;code&gt;*recheck&lt;/code&gt; should be set to true if the heap tuple needs to be rechecked against the query operator, or false if the index test is exact. That is, a false return value guarantees that the heap tuple does not match the query; a true return value with &lt;code&gt;*recheck&lt;/code&gt; set to false guarantees that the heap tuple does match the query; and a true return value with &lt;code&gt;*recheck&lt;/code&gt; set to true means that the heap tuple might match the query, so it needs to be fetched and rechecked by evaluating the query operator directly against the originally indexed item.</source>
          <target state="translated">成功后，如果需要对照查询运算符重新检查堆元组，则将 &lt;code&gt;*recheck&lt;/code&gt; 设置为true；如果索引测试正确，则将false设置为false。也就是说，错误的返回值可确保堆元组与查询不匹配；否则，返回false。 &lt;code&gt;*recheck&lt;/code&gt; 设置为false的返回值为true可以确保堆元组确实与查询匹配； &lt;code&gt;*recheck&lt;/code&gt; 设置为true 的true返回值表示堆元组可能与查询匹配，因此需要通过直接针对原始索引项评估查询运算符来获取并重新检查堆元组。</target>
        </trans-unit>
        <trans-unit id="471ab7df5323b9c1beeab9b6ad11a4a3d81ba199" translate="yes" xml:space="preserve">
          <source>On successful completion, a &lt;code&gt;COPY&lt;/code&gt; command returns a command tag of the form</source>
          <target state="translated">成功完成后， &lt;code&gt;COPY&lt;/code&gt; 命令将返回以下形式的命令标签：</target>
        </trans-unit>
        <trans-unit id="a330b5f61b3e5eaefa54001cda5edd47cd225306" translate="yes" xml:space="preserve">
          <source>On successful completion, a &lt;code&gt;DELETE&lt;/code&gt; command returns a command tag of the form</source>
          <target state="translated">成功完成后， &lt;code&gt;DELETE&lt;/code&gt; 命令将返回以下形式的命令标签：</target>
        </trans-unit>
        <trans-unit id="606df5c042bda87282091ed6e870632af55a409b" translate="yes" xml:space="preserve">
          <source>On successful completion, a &lt;code&gt;FETCH&lt;/code&gt; command returns a command tag of the form</source>
          <target state="translated">成功完成后， &lt;code&gt;FETCH&lt;/code&gt; 命令将返回以下格式的命令标签：</target>
        </trans-unit>
        <trans-unit id="522cefa61331276f75d9354dde07beed068c55b2" translate="yes" xml:space="preserve">
          <source>On successful completion, a &lt;code&gt;MOVE&lt;/code&gt; command returns a command tag of the form</source>
          <target state="translated">成功完成后， &lt;code&gt;MOVE&lt;/code&gt; 命令将返回以下形式的命令标签：</target>
        </trans-unit>
        <trans-unit id="10a00a825ef1af18a74c6369608739640c2c6694" translate="yes" xml:space="preserve">
          <source>On successful completion, an &lt;code&gt;INSERT&lt;/code&gt; command returns a command tag of the form</source>
          <target state="translated">成功完成后， &lt;code&gt;INSERT&lt;/code&gt; 命令将返回以下形式的命令标签：</target>
        </trans-unit>
        <trans-unit id="adea3b7cb9bb8d678c08759a0633a3db722c1eb8" translate="yes" xml:space="preserve">
          <source>On successful completion, an &lt;code&gt;UPDATE&lt;/code&gt; command returns a command tag of the form</source>
          <target state="translated">成功完成后， &lt;code&gt;UPDATE&lt;/code&gt; 命令将返回以下形式的命令标签：</target>
        </trans-unit>
        <trans-unit id="17c3054fe4ff4e4031ec1aca452c9f2fbf414b42" translate="yes" xml:space="preserve">
          <source>On systems that have PostgreSQL started at boot time, there is probably a start-up file that will accomplish the same thing. For example, on a Red Hat Linux system one might find that this works:</source>
          <target state="translated">在启动时启动PostgreSQL的系统中,可能有一个启动文件可以完成同样的事情。例如,在Red Hat Linux系统中,人们可能会发现这个文件是有效的。</target>
        </trans-unit>
        <trans-unit id="5c79b94518a5311140dc7e0d3b2812f742d2b393" translate="yes" xml:space="preserve">
          <source>On systems that support the keepalive socket option, setting &lt;a href=&quot;runtime-config-connection#GUC-TCP-KEEPALIVES-IDLE&quot;&gt;tcp_keepalives_idle&lt;/a&gt;, &lt;a href=&quot;runtime-config-connection#GUC-TCP-KEEPALIVES-INTERVAL&quot;&gt;tcp_keepalives_interval&lt;/a&gt; and &lt;a href=&quot;runtime-config-connection#GUC-TCP-KEEPALIVES-COUNT&quot;&gt;tcp_keepalives_count&lt;/a&gt; helps the primary promptly notice a broken connection.</source>
          <target state="translated">在支持keepalive套接字选项的系统上，设置&lt;a href=&quot;runtime-config-connection#GUC-TCP-KEEPALIVES-IDLE&quot;&gt;tcp_keepalives_idle&lt;/a&gt;，&lt;a href=&quot;runtime-config-connection#GUC-TCP-KEEPALIVES-INTERVAL&quot;&gt;tcp_keepalives_interval&lt;/a&gt;和&lt;a href=&quot;runtime-config-connection#GUC-TCP-KEEPALIVES-COUNT&quot;&gt;tcp_keepalives_count&lt;/a&gt;可以帮助主数据库迅速注意到断开的连接。</target>
        </trans-unit>
        <trans-unit id="1fa1a4c2c8b8530e986a78ada66b4ce0e77848ad" translate="yes" xml:space="preserve">
          <source>On systems with less than 1GB of RAM, a smaller percentage of RAM is appropriate, so as to leave adequate space for the operating system.</source>
          <target state="translated">在内存不足1GB的系统上,内存的比例宜小一些,这样才能给操作系统留下足够的空间。</target>
        </trans-unit>
        <trans-unit id="f7c83da74a1e6d13c844e01daa0931d96bf79bb8" translate="yes" xml:space="preserve">
          <source>On that date, there were two possible interpretations of 2:30AM; there was 2:30AM EDT, and then an hour later after the reversion to standard time, there was 2:30AM EST. Again, PostgreSQL interprets the given time as if it were standard time (UTC-5). We can force the matter by specifying daylight-savings time:</source>
          <target state="translated">在那一天,2:30AM有两种可能的解释;有2:30AM EDT,然后在恢复到标准时间后的一个小时,有2:30AM EST。同样,PostgreSQL将给定的时间解释为标准时间(UTC-5)。我们可以通过指定夏令时来强制处理此事。</target>
        </trans-unit>
        <trans-unit id="108bc1acbd3eb627957c49ac13cf1805b058d6fd" translate="yes" xml:space="preserve">
          <source>On the other hand, the JSON existence operator is not nested: it will only look for the specified key or array element at top level of the JSON value.</source>
          <target state="translated">另一方面,JSON存在操作符不是嵌套的:它只会在JSON值的顶层寻找指定的键或数组元素。</target>
        </trans-unit>
        <trans-unit id="0944856f78282776625887773317f5e5a29f6901" translate="yes" xml:space="preserve">
          <source>On the other hand, the following query finds all the cities that are not state capitals and are situated at an altitude over 500 feet:</source>
          <target state="translated">另一方面,下面的查询可以找到所有非州府且海拔超过500英尺的城市。</target>
        </trans-unit>
        <trans-unit id="dc15ca0265b44e308c416ac01f3b8fd4dd23be18" translate="yes" xml:space="preserve">
          <source>On the other hand, the following query finds all the cities that are not state capitals and are situated at an elevation over 500 feet:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d66d041f4d766c1f0ee27254b9b736aa4e0885c" translate="yes" xml:space="preserve">
          <source>On the other hand, the prefix operator &lt;code&gt;~&lt;/code&gt; (bitwise negation) is defined only for integer data types, not for &lt;code&gt;float8&lt;/code&gt;. So, if we try a similar case with &lt;code&gt;~&lt;/code&gt;, we get:</source>
          <target state="translated">另一方面，前缀运算符 &lt;code&gt;~&lt;/code&gt; （按位取反）仅针对整数数据类型定义，而不针对 &lt;code&gt;float8&lt;/code&gt; 定义。因此，如果我们用 &lt;code&gt;~&lt;/code&gt; 尝试类似的情况，则会得到：</target>
        </trans-unit>
        <trans-unit id="e3fb0b420bf61dd2f01fedc471af93946522a689" translate="yes" xml:space="preserve">
          <source>On the other hand, the structurally similar case</source>
          <target state="translated">另一方面,结构上相似的情况下。</target>
        </trans-unit>
        <trans-unit id="aa512d53935676cc08f57c9480c2f5a40cb3a7f6" translate="yes" xml:space="preserve">
          <source>On the other side of the coin, some systems allow individual processes to open large numbers of files; if more than a few processes do so then the system-wide limit can easily be exceeded. If you find this happening, and you do not want to alter the system-wide limit, you can set PostgreSQL's &lt;a href=&quot;runtime-config-resource#GUC-MAX-FILES-PER-PROCESS&quot;&gt;max_files_per_process&lt;/a&gt; configuration parameter to limit the consumption of open files.</source>
          <target state="translated">另一方面，某些系统允许单个进程打开大量文件。如果这样做的过程多于几个，则很容易超过系统范围的限制。如果发现这种情况，并且不想更改系统范围的限制，则可以设置PostgreSQL的&lt;a href=&quot;runtime-config-resource#GUC-MAX-FILES-PER-PROCESS&quot;&gt;max_files_per_process&lt;/a&gt;配置参数来限制打开文件的使用。</target>
        </trans-unit>
        <trans-unit id="e90706123ac00808e07c484e32d4635f07e67a74" translate="yes" xml:space="preserve">
          <source>On the primary server, these cases simply result in waiting; and the user might choose to cancel either of the conflicting actions. However, on the standby there is no choice: the WAL-logged action already occurred on the primary so the standby must not fail to apply it. Furthermore, allowing WAL application to wait indefinitely may be very undesirable, because the standby's state will become increasingly far behind the primary's. Therefore, a mechanism is provided to forcibly cancel standby queries that conflict with to-be-applied WAL records.</source>
          <target state="translated">在主服务器上,这些情况只会导致等待;而且用户可以选择取消任何一个冲突的操作。但是,在备用服务器上,没有选择:WAL记录的动作已经在主服务器上发生,所以备用服务器一定不能不应用它。此外,允许WAL应用无限期地等待可能是非常不可取的,因为待机的状态会越来越远地落后于主机的状态。因此,提供了一种机制来强制取消与待应用的WAL记录冲突的备用查询。</target>
        </trans-unit>
        <trans-unit id="12047b5caa5d65a62660b71617de0d4a759ef067" translate="yes" xml:space="preserve">
          <source>On the primary, parameters &lt;a href=&quot;runtime-config-wal#GUC-WAL-LEVEL&quot;&gt;wal_level&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#GUC-VACUUM-DEFER-CLEANUP-AGE&quot;&gt;vacuum_defer_cleanup_age&lt;/a&gt; can be used. &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay&lt;/a&gt; have no effect if set on the primary.</source>
          <target state="translated">在主&lt;a href=&quot;runtime-config-wal#GUC-WAL-LEVEL&quot;&gt;数据库上&lt;/a&gt;，可以使用参数wal_level和&lt;a href=&quot;runtime-config-replication#GUC-VACUUM-DEFER-CLEANUP-AGE&quot;&gt;vacuum_defer_cleanup_age&lt;/a&gt;。如果在主数据库上设置了&lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt;和&lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay，则&lt;/a&gt;它们无效。</target>
        </trans-unit>
        <trans-unit id="f4d2789c0f0275ad798be7e6d4e299236ebe91e1" translate="yes" xml:space="preserve">
          <source>On the publisher side, &lt;code&gt;wal_level&lt;/code&gt; must be set to &lt;code&gt;logical&lt;/code&gt;, and &lt;code&gt;max_replication_slots&lt;/code&gt; must be set to at least the number of subscriptions expected to connect, plus some reserve for table synchronization. And &lt;code&gt;max_wal_senders&lt;/code&gt; should be set to at least the same as &lt;code&gt;max_replication_slots&lt;/code&gt; plus the number of physical replicas that are connected at the same time.</source>
          <target state="translated">在发布方，必须将 &lt;code&gt;wal_level&lt;/code&gt; 设置为 &lt;code&gt;logical&lt;/code&gt; ，并且必须将 &lt;code&gt;max_replication_slots&lt;/code&gt; 至少设置为预期要连接的预订数量，再加上一些用于表同步的预留空间。而 &lt;code&gt;max_wal_senders&lt;/code&gt; 应至少设置为相同的 &lt;code&gt;max_replication_slots&lt;/code&gt; 加上在同一时间连接的物理副本的数量。</target>
        </trans-unit>
        <trans-unit id="35745b04684e80ded8dc5507c072fa2674283617" translate="yes" xml:space="preserve">
          <source>On the standby, parameters &lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY&quot;&gt;hot_standby&lt;/a&gt;, &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay&lt;/a&gt; can be used. &lt;a href=&quot;runtime-config-replication#GUC-VACUUM-DEFER-CLEANUP-AGE&quot;&gt;vacuum_defer_cleanup_age&lt;/a&gt; has no effect as long as the server remains in standby mode, though it will become relevant if the standby becomes primary.</source>
          <target state="translated">在备用&lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY&quot;&gt;数据库上&lt;/a&gt;，可以使用参数hot_standby，&lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt;和&lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay&lt;/a&gt;。只要服务器保持待机状态，&lt;a href=&quot;runtime-config-replication#GUC-VACUUM-DEFER-CLEANUP-AGE&quot;&gt;vacuum_defer_cleanup_age&lt;/a&gt;无效，但是如果待机成为主服务器，它将变得很重要。</target>
        </trans-unit>
        <trans-unit id="70715c6fbe3e407765f6386cd308c88b6865cc56" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;UNLISTEN&lt;/code&gt; has been executed, further &lt;code&gt;NOTIFY&lt;/code&gt; messages will be ignored:</source>
          <target state="translated">一旦执行了 &lt;code&gt;UNLISTEN&lt;/code&gt; ，其他的 &lt;code&gt;NOTIFY&lt;/code&gt; 消息将被忽略：</target>
        </trans-unit>
        <trans-unit id="ec65ec416b46f0c02b02945a4d9803e7d39332ca" translate="yes" xml:space="preserve">
          <source>Once a client is connected to the database, PostgreSQL provides two additional SQL commands (and equivalent functions) to interact with session-local configuration settings:</source>
          <target state="translated">一旦客户端连接到数据库,PostgreSQL提供了两个额外的SQL命令(和等效函数)来与会话本地配置设置交互。</target>
        </trans-unit>
        <trans-unit id="356c49cf82618dc4e123a48d759d153fd0e38847" translate="yes" xml:space="preserve">
          <source>Once a connection is established the client process can send a query to the &lt;em&gt;backend&lt;/em&gt; (server). The query is transmitted using plain text, i.e., there is no parsing done in the &lt;em&gt;frontend&lt;/em&gt; (client). The server parses the query, creates an &lt;em&gt;execution plan&lt;/em&gt;, executes the plan and returns the retrieved rows to the client by transmitting them over the established connection.</source>
          <target state="translated">建立连接后，客户端进程可以将查询发送到&lt;em&gt;后端&lt;/em&gt;（服务器）。查询是使用纯文本传输的，即在&lt;em&gt;前端&lt;/em&gt;（客户端）中没有进行解析。服务器解析查询，创建&lt;em&gt;执行计划&lt;/em&gt;，执行计划，并通过在已建立的连接上传输检索到的行，将其返回给客户端。</target>
        </trans-unit>
        <trans-unit id="5ad9c4a6213a012c3300efd580e40047d30505b8" translate="yes" xml:space="preserve">
          <source>Once acquired, a lock is normally held till end of transaction. But if a lock is acquired after establishing a savepoint, the lock is released immediately if the savepoint is rolled back to. This is consistent with the principle that &lt;code&gt;ROLLBACK&lt;/code&gt; cancels all effects of the commands since the savepoint. The same holds for locks acquired within a PL/pgSQL exception block: an error escape from the block releases locks acquired within it.</source>
          <target state="translated">一旦获得，通常会持有一个锁，直到交易结束。但是，如果在建立保存点后获得了锁，则如果将保存点回滚到该锁，则会立即释放该锁。这符合以下原则： &lt;code&gt;ROLLBACK&lt;/code&gt; 取消自保存点以来的所有命令效果。 PL / pgSQL异常块中获得的锁也是如此：从该块进行错误转义会释放在其中获取的锁。</target>
        </trans-unit>
        <trans-unit id="f6e9243ef6651a8f1bff8b046ab3cebbec0d9033" translate="yes" xml:space="preserve">
          <source>Once acquired, a lock is normally held until the end of the transaction. But if a lock is acquired after establishing a savepoint, the lock is released immediately if the savepoint is rolled back to. This is consistent with the principle that &lt;code&gt;ROLLBACK&lt;/code&gt; cancels all effects of the commands since the savepoint. The same holds for locks acquired within a PL/pgSQL exception block: an error escape from the block releases locks acquired within it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41f916b016e9381b5815b3e4089f244578b1cdbc" translate="yes" xml:space="preserve">
          <source>Once an index is created, no further intervention is required: the system will update the index when the table is modified, and it will use the index in queries when it thinks doing so would be more efficient than a sequential table scan. But you might have to run the &lt;code&gt;ANALYZE&lt;/code&gt; command regularly to update statistics to allow the query planner to make educated decisions. See &lt;a href=&quot;https://www.postgresql.org/docs/12/performance-tips.html&quot;&gt;Chapter 14&lt;/a&gt; for information about how to find out whether an index is used and when and why the planner might choose &lt;em&gt;not&lt;/em&gt; to use an index.</source>
          <target state="translated">创建索引后，无需进一步干预：系统将在修改表时更新索引，并且当它认为这样做比顺序表扫描更有效时，它将在查询中使用索引。但是您可能必须定期运行 &lt;code&gt;ANALYZE&lt;/code&gt; 命令来更新统计信息，以允许查询计划者做出有根据的决策。有关如何查找是否使用索引以及计划者何时以及为什么选择&lt;em&gt;不&lt;/em&gt;使用索引的信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/performance-tips.html&quot;&gt;第14章&lt;/a&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="642332a00907b7ff64fd98bc7d16bd9934680cd4" translate="yes" xml:space="preserve">
          <source>Once an index is created, no further intervention is required: the system will update the index when the table is modified, and it will use the index in queries when it thinks doing so would be more efficient than a sequential table scan. But you might have to run the &lt;code&gt;ANALYZE&lt;/code&gt; command regularly to update statistics to allow the query planner to make educated decisions. See &lt;a href=&quot;https://www.postgresql.org/docs/13/performance-tips.html&quot;&gt;Chapter 14&lt;/a&gt; for information about how to find out whether an index is used and when and why the planner might choose &lt;em&gt;not&lt;/em&gt; to use an index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e5421d611a483b4f3357d11ff23a5acc44acb58" translate="yes" xml:space="preserve">
          <source>Once any valuable objects have been transferred to new owners, any remaining objects owned by the role-to-be-dropped can be dropped with the &lt;a href=&quot;sql-drop-owned&quot;&gt;DROP OWNED&lt;/a&gt; command. Again, this command cannot access objects in other databases, so it is necessary to run it in each database that contains objects owned by the role. Also, &lt;code&gt;DROP OWNED&lt;/code&gt; will not drop entire databases or tablespaces, so it is necessary to do that manually if the role owns any databases or tablespaces that have not been transferred to new owners.</source>
          <target state="translated">一旦将任何有价值的对象转移给新的所有者，就可以使用&lt;a href=&quot;sql-drop-owned&quot;&gt;DROP OWNED&lt;/a&gt;命令删除要删除的角色拥有的所有剩余对象。同样，此命令无法访问其他数据库中的对象，因此有必要在每个包含该角色拥有的对象的数据库中运行它。另外， &lt;code&gt;DROP OWNED&lt;/code&gt; 不会删除整个数据库或表空间，因此，如果角色拥有尚未转移给新所有者的任何数据库或表空间，则必须手动执行此操作。</target>
        </trans-unit>
        <trans-unit id="e81389b8f98e0c4fa0978b0ecbccf3ec2c7326c5" translate="yes" xml:space="preserve">
          <source>Once created, a tablespace can be used from any database, provided the requesting user has sufficient privilege. This means that a tablespace cannot be dropped until all objects in all databases using the tablespace have been removed.</source>
          <target state="translated">表空间一旦创建,就可以从任何数据库中使用,但前提是请求的用户有足够的权限。这意味着,在使用该表空间的所有数据库中的所有对象被删除之前,不能放弃该表空间。</target>
        </trans-unit>
        <trans-unit id="73da0c6102d03c025cdbc83b1b38fc971869013e" translate="yes" xml:space="preserve">
          <source>Once created, the enum type can be used in table and function definitions much like any other type:</source>
          <target state="translated">一旦创建,枚举类型就可以像其他类型一样被用于表和函数定义中。</target>
        </trans-unit>
        <trans-unit id="c9f4d5e2b4aa9fc314da7481d260ca60dd53ed46" translate="yes" xml:space="preserve">
          <source>Once failover to the standby occurs, there is only a single server in operation. This is known as a degenerate state. The former standby is now the primary, but the former primary is down and might stay down. To return to normal operation, a standby server must be recreated, either on the former primary system when it comes up, or on a third, possibly new, system. The &lt;a href=&quot;app-pgrewind&quot;&gt;pg_rewind&lt;/a&gt; utility can be used to speed up this process on large clusters. Once complete, the primary and standby can be considered to have switched roles. Some people choose to use a third server to provide backup for the new primary until the new standby server is recreated, though clearly this complicates the system configuration and operational processes.</source>
          <target state="translated">一旦故障转移到备用数据库，就只有一台服务器在运行。这称为退化状态。现在，以前的备用数据库是主要数据库，但是以前的主要数据库已关闭，并且可能会关闭。要恢复正常运行，必须在启动时在原主系统上或在第三个（可能是新的）系统上重新创建备用服务器。所述&lt;a href=&quot;app-pgrewind&quot;&gt;pg_rewind&lt;/a&gt;实用程序可用于加快对大型集群此过程。完成后，可以认为主要角色和备用角色具有切换角色。某些人选择使用第三台服务器为新的主服务器提供备份，直到重新创建新的备用服务器为止，尽管显然这会使系统配置和操作过程变得复杂。</target>
        </trans-unit>
        <trans-unit id="99eb90b007ab371c4c054db1b4a14dc72baaf9ae" translate="yes" xml:space="preserve">
          <source>Once prepared, a transaction can later be committed or rolled back with &lt;a href=&quot;sql-commit-prepared&quot;&gt;COMMIT PREPARED&lt;/a&gt; or &lt;a href=&quot;sql-rollback-prepared&quot;&gt;ROLLBACK PREPARED&lt;/a&gt;, respectively. Those commands can be issued from any session, not only the one that executed the original transaction.</source>
          <target state="translated">一旦准备好，便可以稍后分别使用&lt;a href=&quot;sql-commit-prepared&quot;&gt;COMMIT PREPARED&lt;/a&gt;或&lt;a href=&quot;sql-rollback-prepared&quot;&gt;ROLLBACK PREPARED&lt;/a&gt;来提交或回滚事务。这些命令可以从任何会话中发出，而不仅仅是执行原始事务的命令。</target>
        </trans-unit>
        <trans-unit id="a26efc323b5a3b586fc58ac6b6adb6fb3937603a" translate="yes" xml:space="preserve">
          <source>Once restored, it is wise to run &lt;code&gt;ANALYZE&lt;/code&gt; on each database so the optimizer has useful statistics. You can also run &lt;code&gt;vacuumdb -a -z&lt;/code&gt; to analyze all databases.</source>
          <target state="translated">恢复后，明智的做法是在每个数据库上运行 &lt;code&gt;ANALYZE&lt;/code&gt; ，以便优化器具有有用的统计信息。您也可以运行 &lt;code&gt;vacuumdb -a -z&lt;/code&gt; 分析所有数据库。</target>
        </trans-unit>
        <trans-unit id="e1c807b866ed2972017d5380e0a876fec0d03a30" translate="yes" xml:space="preserve">
          <source>Once restored, it is wise to run &lt;code&gt;ANALYZE&lt;/code&gt; on each restored table so the optimizer has useful statistics; see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Section 24.1.3&lt;/a&gt; and &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information.</source>
          <target state="translated">还原后，明智的做法是在每个还原的表上运行 &lt;code&gt;ANALYZE&lt;/code&gt; ，以便优化器具有有用的统计信息。有关更多信息，请参见&lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;第24.1.3节&lt;/a&gt;和&lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;第24.1.6节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4f22ae97ca76db6661c3c1f5a88b003eb151976f" translate="yes" xml:space="preserve">
          <source>Once started, &lt;code&gt;pg_upgrade&lt;/code&gt; will verify the two clusters are compatible and then do the upgrade. You can use &lt;code&gt;pg_upgrade --check&lt;/code&gt; to perform only the checks, even if the old server is still running. &lt;code&gt;pg_upgrade --check&lt;/code&gt; will also outline any manual adjustments you will need to make after the upgrade. If you are going to be using link or clone mode, you should use the option &lt;code&gt;--link&lt;/code&gt; or &lt;code&gt;--clone&lt;/code&gt; with &lt;code&gt;--check&lt;/code&gt; to enable mode-specific checks. &lt;code&gt;pg_upgrade&lt;/code&gt; requires write permission in the current directory.</source>
          <target state="translated">一旦启动， &lt;code&gt;pg_upgrade&lt;/code&gt; 将验证两个集群是否兼容，然后进行升级。即使旧服务器仍在运行，也可以使用 &lt;code&gt;pg_upgrade --check&lt;/code&gt; 仅执行检查。 &lt;code&gt;pg_upgrade --check&lt;/code&gt; 还将概述升级后您需要进行的任何手动调整。如果要使用链接或克隆模式，则应将选项 &lt;code&gt;--link&lt;/code&gt; 或 &lt;code&gt;--clone&lt;/code&gt; 与 &lt;code&gt;--check&lt;/code&gt; 一起使用，以启用特定于模式的检查。 &lt;code&gt;pg_upgrade&lt;/code&gt; 需要在当前目录中具有写权限。</target>
        </trans-unit>
        <trans-unit id="c713ae812f1782bcff8d86ab36ed9c6d151c330d" translate="yes" xml:space="preserve">
          <source>Once streaming replication has been configured, configuring synchronous replication requires only one additional configuration step: &lt;a href=&quot;runtime-config-replication#GUC-SYNCHRONOUS-STANDBY-NAMES&quot;&gt;synchronous_standby_names&lt;/a&gt; must be set to a non-empty value. &lt;code&gt;synchronous_commit&lt;/code&gt; must also be set to &lt;code&gt;on&lt;/code&gt;, but since this is the default value, typically no change is required. (See &lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-SETTINGS&quot;&gt;Section 19.5.1&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#RUNTIME-CONFIG-REPLICATION-MASTER&quot;&gt;Section 19.6.2&lt;/a&gt;.) This configuration will cause each commit to wait for confirmation that the standby has written the commit record to durable storage. &lt;code&gt;synchronous_commit&lt;/code&gt; can be set by individual users, so it can be configured in the configuration file, for particular users or databases, or dynamically by applications, in order to control the durability guarantee on a per-transaction basis.</source>
          <target state="translated">配置流复制后，配置同步复制仅需要一个额外的配置步骤：&lt;a href=&quot;runtime-config-replication#GUC-SYNCHRONOUS-STANDBY-NAMES&quot;&gt;sync_standby_names&lt;/a&gt;必须设置为非空值。 &lt;code&gt;synchronous_commit&lt;/code&gt; 也必须设置为 &lt;code&gt;on&lt;/code&gt; ，但是由于这是默认值，因此通常不需要更改。（请参阅&lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-SETTINGS&quot;&gt;第&lt;/a&gt;&lt;a href=&quot;runtime-config-replication#RUNTIME-CONFIG-REPLICATION-MASTER&quot;&gt;19.5.1 &lt;/a&gt;节和第19.6.2节。）此配置将使每个提交都等待确认备用数据库已将提交记录写入持久性存储。 &lt;code&gt;synchronous_commit&lt;/code&gt; 可以由单个用户设置，因此可以在配置文件中针对特定用户或数据库进行配置，也可以由应用程序动态配置，以基于每个事务控制持久性保证。</target>
        </trans-unit>
        <trans-unit id="9871853da7c650c2f0dd2795f59e948ae7531634" translate="yes" xml:space="preserve">
          <source>Once the WAL segment files active during the backup are archived, you are done. The file identified by &lt;code&gt;pg_stop_backup&lt;/code&gt;'s first return value is the last segment that is required to form a complete set of backup files. On a primary, if &lt;code&gt;archive_mode&lt;/code&gt; is enabled and the &lt;code&gt;wait_for_archive&lt;/code&gt; parameter is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;pg_stop_backup&lt;/code&gt; does not return until the last segment has been archived. On a standby, &lt;code&gt;archive_mode&lt;/code&gt; must be &lt;code&gt;always&lt;/code&gt; in order for &lt;code&gt;pg_stop_backup&lt;/code&gt; to wait. Archiving of these files happens automatically since you have already configured &lt;code&gt;archive_command&lt;/code&gt;. In most cases this happens quickly, but you are advised to monitor your archive system to ensure there are no delays. If the archive process has fallen behind because of failures of the archive command, it will keep retrying until the archive succeeds and the backup is complete. If you wish to place a time limit on the execution of &lt;code&gt;pg_stop_backup&lt;/code&gt;, set an appropriate &lt;code&gt;statement_timeout&lt;/code&gt; value, but make note that if &lt;code&gt;pg_stop_backup&lt;/code&gt; terminates because of this your backup may not be valid.</source>
          <target state="translated">一旦备份期间激活的WAL段文件被存档，就完成了。 &lt;code&gt;pg_stop_backup&lt;/code&gt; 的第一个返回值标识的文件是形成完整备份文件集所需的最后一个段。在主数据库上，如果启用了 &lt;code&gt;archive_mode&lt;/code&gt; 且 &lt;code&gt;wait_for_archive&lt;/code&gt; 参数为 &lt;code&gt;true&lt;/code&gt; ，则在归档最后一个段之前， &lt;code&gt;pg_stop_backup&lt;/code&gt; 不会返回。在备用数据库上， &lt;code&gt;archive_mode&lt;/code&gt; 必须 &lt;code&gt;always&lt;/code&gt; 为 &lt;code&gt;pg_stop_backup&lt;/code&gt; 等待。这些文件的存档会自动进行，因为您已经配置了 &lt;code&gt;archive_command&lt;/code&gt; 。在大多数情况下，这种情况很快发生，但是建议您监视归档系统以确保没有延迟。如果由于归档命令失败而导致归档过程落后，它将继续重试，直到归档成功并且备份完成为止。如果您希望对 &lt;code&gt;pg_stop_backup&lt;/code&gt; 的执行设置时间限制，请设置一个适当的 &lt;code&gt;statement_timeout&lt;/code&gt; 值，但请注意，如果 &lt;code&gt;pg_stop_backup&lt;/code&gt; 终止，则您的备份可能无效。</target>
        </trans-unit>
        <trans-unit id="32e5f3f159f9a76e583d7e4dd4b47490f3262b2b" translate="yes" xml:space="preserve">
          <source>Once the WAL segment files active during the backup are archived, you are done. The file identified by &lt;code&gt;pg_stop_backup&lt;/code&gt;'s result is the last segment that is required to form a complete set of backup files. If &lt;code&gt;archive_mode&lt;/code&gt; is enabled, &lt;code&gt;pg_stop_backup&lt;/code&gt; does not return until the last segment has been archived. Archiving of these files happens automatically since you have already configured &lt;code&gt;archive_command&lt;/code&gt;. In most cases this happens quickly, but you are advised to monitor your archive system to ensure there are no delays. If the archive process has fallen behind because of failures of the archive command, it will keep retrying until the archive succeeds and the backup is complete.</source>
          <target state="translated">一旦备份期间激活的WAL段文件被存档，就完成了。由 &lt;code&gt;pg_stop_backup&lt;/code&gt; 的结果标识的文件是形成完整备份文件集所需的最后一个段。如果启用了 &lt;code&gt;archive_mode&lt;/code&gt; ，则 &lt;code&gt;pg_stop_backup&lt;/code&gt; 直到最后一个段被归档后才返回。由于已经配置了 &lt;code&gt;archive_command&lt;/code&gt; ,因此将自动进行这些文件的归档。在大多数情况下，这种情况很快发生，但是建议您监视归档系统以确保没有延迟。如果由于归档命令失败而导致归档过程落后，它将继续重试，直到归档成功并且备份完成为止。</target>
        </trans-unit>
        <trans-unit id="5f47c9896865faba1d610987fd3b05badac486b3" translate="yes" xml:space="preserve">
          <source>Once the delay specified by &lt;code&gt;max_standby_archive_delay&lt;/code&gt; or &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; has been exceeded, conflicting queries will be canceled. This usually results just in a cancellation error, although in the case of replaying a &lt;code&gt;DROP DATABASE&lt;/code&gt; the entire conflicting session will be terminated. Also, if the conflict is over a lock held by an idle transaction, the conflicting session is terminated (this behavior might change in the future).</source>
          <target state="translated">一旦超过了 &lt;code&gt;max_standby_archive_delay&lt;/code&gt; 或 &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; 指定的延迟，冲突查询将被取消。通常，这仅会导致取消错误，尽管在重播 &lt;code&gt;DROP DATABASE&lt;/code&gt; 的情况下，整个冲突会话都将终止。同样，如果冲突是由于空闲事务持有的锁引起的，则冲突会话将终止（此行为将来可能会更改）。</target>
        </trans-unit>
        <trans-unit id="b8e1074216e0451321cd3f251827b2e9872eaede" translate="yes" xml:space="preserve">
          <source>Once the group role exists, you can add and remove members using the &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; and &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; commands:</source>
          <target state="translated">组角色一旦存在，就可以使用&lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt;和&lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt;命令添加和删​​除成员：</target>
        </trans-unit>
        <trans-unit id="69a71607e88d378416ed92ac7ffd6286dc445378" translate="yes" xml:space="preserve">
          <source>Once you are satisfied with the upgrade, you can delete the old cluster's data directories by running the script mentioned when &lt;code&gt;pg_upgrade&lt;/code&gt; completes. (Automatic deletion is not possible if you have user-defined tablespaces inside the old data directory.) You can also delete the old installation directories (e.g. &lt;code&gt;bin&lt;/code&gt;, &lt;code&gt;share&lt;/code&gt;).</source>
          <target state="translated">对升级感到满意后，您可以通过运行 &lt;code&gt;pg_upgrade&lt;/code&gt; 完成时提到的脚本来删除旧集群的数据目录。（如果旧数据目录中有用户定义的表空间，则无法自动删除。）您还可以删除旧的安装目录（例如 &lt;code&gt;bin&lt;/code&gt; ， &lt;code&gt;share&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ddbea494f64cf75943b4997efd25a70a79386e0d" translate="yes" xml:space="preserve">
          <source>Once you are satisfied with the upgrade, you can delete the old cluster's data directories by running the script mentioned when &lt;code&gt;pg_upgrade&lt;/code&gt; completes. (Automatic deletion is not possible if you have user-defined tablespaces inside the old data directory.) You can also delete the old installation directories (e.g., &lt;code&gt;bin&lt;/code&gt;, &lt;code&gt;share&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5a7bdde6e82e682c3584d24535e62c92a86edd3" translate="yes" xml:space="preserve">
          <source>Once you have created a database, you can access it by:</source>
          <target state="translated">一旦你创建了一个数据库,你可以通过以下方式访问它:</target>
        </trans-unit>
        <trans-unit id="a17a3f555279791537a8bafe938cf8c6379fa784" translate="yes" xml:space="preserve">
          <source>Once you have done the necessary setup, you can run your benchmark with a command that doesn't include &lt;code&gt;-i&lt;/code&gt;, that is</source>
          <target state="translated">完成必要的设置后，可以使用不包含 &lt;code&gt;-i&lt;/code&gt; 的命令运行基准测试，即</target>
        </trans-unit>
        <trans-unit id="61eda2a3b905b905ee98026b455b6eb92908a307" translate="yes" xml:space="preserve">
          <source>One &lt;code&gt;postgres&lt;/code&gt; instance always manages the data of exactly one database cluster. A database cluster is a collection of databases that is stored at a common file system location (the &amp;ldquo;data area&amp;rdquo;). More than one &lt;code&gt;postgres&lt;/code&gt; instance can run on a system at one time, so long as they use different data areas and different communication ports (see below). When &lt;code&gt;postgres&lt;/code&gt; starts it needs to know the location of the data area. The location must be specified by the &lt;code&gt;-D&lt;/code&gt; option or the &lt;code&gt;PGDATA&lt;/code&gt; environment variable; there is no default. Typically, &lt;code&gt;-D&lt;/code&gt; or &lt;code&gt;PGDATA&lt;/code&gt; points directly to the data area directory created by &lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt;. Other possible file layouts are discussed in &lt;a href=&quot;runtime-config-file-locations&quot;&gt;Section 19.2&lt;/a&gt;.</source>
          <target state="translated">一个 &lt;code&gt;postgres&lt;/code&gt; 实例始终管理一个数据库集群的数据。数据库集群是存储在公共文件系统位置（&amp;ldquo;数据区域&amp;rdquo;）的数据库的集合。一个 &lt;code&gt;postgres&lt;/code&gt; 实例可以一次在一个系统上运行，只要它们使用不同的数据区域和不同的通信端口即可（请参见下文）。当 &lt;code&gt;postgres&lt;/code&gt; 启动时，它需要知道数据区域的位置。该位置必须由 &lt;code&gt;-D&lt;/code&gt; 选项或 &lt;code&gt;PGDATA&lt;/code&gt; 环境变量指定；没有默认值。通常， &lt;code&gt;-D&lt;/code&gt; 或 &lt;code&gt;PGDATA&lt;/code&gt; 直接指向&lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt;创建的数据区域目录。其他可能的文件布局在&lt;a href=&quot;runtime-config-file-locations&quot;&gt;19.2节&lt;/a&gt;中讨论。</target>
        </trans-unit>
        <trans-unit id="8d2b8f4e1b139546c73a22f8f91fadc862c3170c" translate="yes" xml:space="preserve">
          <source>One advantage of GIN is that it allows the development of custom data types with the appropriate access methods, by an expert in the domain of the data type, rather than a database expert. This is much the same advantage as using GiST.</source>
          <target state="translated">GIN的一个优点是,它允许数据类型领域的专家而不是数据库专家开发具有适当访问方法的自定义数据类型。这与使用GiST的优势基本相同。</target>
        </trans-unit>
        <trans-unit id="e058cfc0d2adb864aa10f7c9c5f44bcfe8be50f0" translate="yes" xml:space="preserve">
          <source>One advantage of GiST is that it allows the development of custom data types with the appropriate access methods, by an expert in the domain of the data type, rather than a database expert.</source>
          <target state="translated">GiST的一个优点是,它允许由数据类型领域的专家而不是数据库专家开发具有适当访问方法的自定义数据类型。</target>
        </trans-unit>
        <trans-unit id="f48b87ea34b25adefa4f3efa4a97db47fb753d95" translate="yes" xml:space="preserve">
          <source>One advantage of the separate-column approach over an expression index is that it is not necessary to explicitly specify the text search configuration in queries in order to make use of the index. As shown in the example above, the query can depend on &lt;code&gt;default_text_search_config&lt;/code&gt;. Another advantage is that searches will be faster, since it will not be necessary to redo the &lt;code&gt;to_tsvector&lt;/code&gt; calls to verify index matches. (This is more important when using a GiST index than a GIN index; see &lt;a href=&quot;textsearch-indexes&quot;&gt;Section 12.9&lt;/a&gt;.) The expression-index approach is simpler to set up, however, and it requires less disk space since the &lt;code&gt;tsvector&lt;/code&gt; representation is not stored explicitly.</source>
          <target state="translated">分离列方法相对于表达式索引的一个优点是，不必为了使用索引而在查询中显式指定文本搜索配置。如上面的示例所示，查询可以取决于 &lt;code&gt;default_text_search_config&lt;/code&gt; 。另一个优点是搜索将更快，因为不需要重做 &lt;code&gt;to_tsvector&lt;/code&gt; 调用来验证索引匹配。（这在使用GiST索引时比在GIN索引中更为重要；请参阅&lt;a href=&quot;textsearch-indexes&quot;&gt;第12.9节&lt;/a&gt;。）expression-index方法的设置更简单，但是由于 &lt;code&gt;tsvector&lt;/code&gt; 表示没有显式存储，因此它需要更少的磁盘空间。</target>
        </trans-unit>
        <trans-unit id="c591e2a82e983192d18fdc29edda9221e37c6723" translate="yes" xml:space="preserve">
          <source>One advantage of using concatenation in the vector form, rather than concatenating text before applying &lt;code&gt;to_tsvector&lt;/code&gt;, is that you can use different configurations to parse different sections of the document. Also, because the &lt;code&gt;setweight&lt;/code&gt; function marks all lexemes of the given vector the same way, it is necessary to parse the text and do &lt;code&gt;setweight&lt;/code&gt; before concatenating if you want to label different parts of the document with different weights.</source>
          <target state="translated">在向量形式中使用串联而不是在应用 &lt;code&gt;to_tsvector&lt;/code&gt; 之前串联文本的优点之一是，您可以使用不同的配置来解析文档的不同部分。另外，由于 &lt;code&gt;setweight&lt;/code&gt; 函数以相同的方式标记给定向量的所有词素，因此如果要使用不同的权重标记文档的不同部分，则 &lt;code&gt;setweight&lt;/code&gt; 在连接之前分析文本并进行setweight设置。</target>
        </trans-unit>
        <trans-unit id="7aa492c47d8ea5d45e5da9a09ed3c6c96f7a96e5" translate="yes" xml:space="preserve">
          <source>One application of the rewrite system is in the realization of &lt;em&gt;views&lt;/em&gt;. Whenever a query against a view (i.e., a &lt;em&gt;virtual table&lt;/em&gt;) is made, the rewrite system rewrites the user's query to a query that accesses the &lt;em&gt;base tables&lt;/em&gt; given in the &lt;em&gt;view definition&lt;/em&gt; instead.</source>
          <target state="translated">重写系统的一种应用是&lt;em&gt;视图&lt;/em&gt;的实现。每当针对视图（即&lt;em&gt;虚拟表&lt;/em&gt;）进行查询时，重写系统都会将用户的查询重写为访问&lt;em&gt;视图定义中&lt;/em&gt;给定的&lt;em&gt;基本表&lt;/em&gt;的查询。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bee7fd28573b33fce2d46ef1ac5fa8251ec94562" translate="yes" xml:space="preserve">
          <source>One component of the statistics is the total number of entries in each table and index, as well as the number of disk blocks occupied by each table and index. This information is kept in the table &lt;a href=&quot;catalog-pg-class&quot;&gt;&lt;code&gt;pg_class&lt;/code&gt;&lt;/a&gt;, in the columns &lt;code&gt;reltuples&lt;/code&gt; and &lt;code&gt;relpages&lt;/code&gt;. We can look at it with queries similar to this one:</source>
          <target state="translated">统计信息的一个组成部分是每个表和索引中的条目总数，以及每个表和索引所占用的磁盘块数。该信息保存在&lt;a href=&quot;catalog-pg-class&quot;&gt; &lt;code&gt;pg_class&lt;/code&gt; &lt;/a&gt;表的 &lt;code&gt;reltuples&lt;/code&gt; 和 &lt;code&gt;relpages&lt;/code&gt; 列中。我们可以通过与此类似的查询来查看它：</target>
        </trans-unit>
        <trans-unit id="4bd99552b099beafc96cbe7829988f7a06eb967b" translate="yes" xml:space="preserve">
          <source>One convenient way to create a compatible table that will later be made a new child is to use the &lt;code&gt;LIKE&lt;/code&gt; clause in &lt;code&gt;CREATE TABLE&lt;/code&gt;. This creates a new table with the same columns as the source table. If there are any &lt;code&gt;CHECK&lt;/code&gt; constraints defined on the source table, the &lt;code&gt;INCLUDING CONSTRAINTS&lt;/code&gt; option to &lt;code&gt;LIKE&lt;/code&gt; should be specified, as the new child must have constraints matching the parent to be considered compatible.</source>
          <target state="translated">创建兼容表（以后将成为新子表）的一种便捷方法是使用 &lt;code&gt;CREATE TABLE&lt;/code&gt; 中的 &lt;code&gt;LIKE&lt;/code&gt; 子句。这将创建一个与源表具有相同列的新表。如果在源表上定义了任何 &lt;code&gt;CHECK&lt;/code&gt; 约束，则应指定 &lt;code&gt;LIKE&lt;/code&gt; 的 &lt;code&gt;INCLUDING CONSTRAINTS&lt;/code&gt; 选项，因为新子级必须具有与父级匹配的约束才能被认为是兼容的。</target>
        </trans-unit>
        <trans-unit id="313d199647b14e908c91b6831b2ac1803fbc36c9" translate="yes" xml:space="preserve">
          <source>One could accomplish the same thing with, say,</source>
          <target state="translated">我们可以用,比如说,来完成同样的事情。</target>
        </trans-unit>
        <trans-unit id="7bcb03e673340a4965d50eadd319bf1730dddebc" translate="yes" xml:space="preserve">
          <source>One disadvantage of decreasing &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt; is that it might cause &lt;code&gt;VACUUM&lt;/code&gt; to do useless work: freezing a row version is a waste of time if the row is modified soon thereafter (causing it to acquire a new XID). So the setting should be large enough that rows are not frozen until they are unlikely to change any more.</source>
          <target state="translated">减少 &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt; 的一个缺点是，它可能导致 &lt;code&gt;VACUUM&lt;/code&gt; 进行无用的工作：如果此后不久对其进行修改（冻结它以获取新的XID），则冻结行版本是浪费时间。因此，该设置应足够大，以使行不会冻结，直到行不再可能更改为止。</target>
        </trans-unit>
        <trans-unit id="d99c8486b08ccc8839ea87cdfcd9e4516a4d63fc" translate="yes" xml:space="preserve">
          <source>One disadvantage of the longitude/latitude representation is that you need to be careful about the edge conditions near the poles and near +/- 180 degrees of longitude. The &lt;code&gt;cube&lt;/code&gt;-based representation avoids these discontinuities.</source>
          <target state="translated">经度/纬度表示的一个缺点是，您需要注意极点附近和经度+/- 180度附近的边缘条件。基于 &lt;code&gt;cube&lt;/code&gt; 的表示避免了这些不连续性。</target>
        </trans-unit>
        <trans-unit id="17918ae437c6b6c4eb55d620ac26a6167c3d73b5" translate="yes" xml:space="preserve">
          <source>One example use of this mechanism is to copy the contents of a file into a table column. First load the file into a variable and then interpolate the variable's value as a quoted string:</source>
          <target state="translated">这个机制的一个使用实例是将一个文件的内容复制到一个表列中。首先将文件加载到一个变量中,然后将变量的值插值为引号字符串。</target>
        </trans-unit>
        <trans-unit id="11e396823958b9942ef20dabe2804d32c8c47de7" translate="yes" xml:space="preserve">
          <source>One fairly large constraint of the table access method API is that, currently, if the AM wants to support modifications and/or indexes, it is necessary for each tuple to have a tuple identifier (TID) consisting of a block number and an item number (see also &lt;a href=&quot;storage-page-layout&quot;&gt;Section 68.6&lt;/a&gt;). It is not strictly necessary that the sub-parts of TIDs have the same meaning they e.g. have for &lt;code&gt;heap&lt;/code&gt;, but if bitmap scan support is desired (it is optional), the block number needs to provide locality.</source>
          <target state="translated">表访问方法API的一个相当大的限制是，当前，如果AM要支持修改和/或索引，则每个元组都必须具有由块号和项目号组成的元组标识符（TID） （另请参见&lt;a href=&quot;storage-page-layout&quot;&gt;第68.6节&lt;/a&gt;）。 TID的子部分不一定具有它们例如对于 &lt;code&gt;heap&lt;/code&gt; 具有的相同含义，但是如果需要位图扫描支持（它是可选的），则块号需要提供局部性。</target>
        </trans-unit>
        <trans-unit id="b0040d1980e299cbab932d09606b61e2f45cdab4" translate="yes" xml:space="preserve">
          <source>One fairly large constraint of the table access method API is that, currently, if the AM wants to support modifications and/or indexes, it is necessary for each tuple to have a tuple identifier (TID) consisting of a block number and an item number (see also &lt;a href=&quot;storage-page-layout&quot;&gt;Section 68.6&lt;/a&gt;). It is not strictly necessary that the sub-parts of TIDs have the same meaning they e.g., have for &lt;code&gt;heap&lt;/code&gt;, but if bitmap scan support is desired (it is optional), the block number needs to provide locality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea6157e87abd7338811eb2303b2c46792b171e86" translate="yes" xml:space="preserve">
          <source>One major reason for using a partial index is to avoid indexing common values. Since a query searching for a common value (one that accounts for more than a few percent of all the table rows) will not use the index anyway, there is no point in keeping those rows in the index at all. This reduces the size of the index, which will speed up those queries that do use the index. It will also speed up many table update operations because the index does not need to be updated in all cases. &lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX1&quot;&gt;Example 11.1&lt;/a&gt; shows a possible application of this idea.</source>
          <target state="translated">使用部分索引的一个主要原因是避免索引公共值。由于搜索公共值（占所有表行的百分之几以上）的查询始终不会使用索引，因此完全没有必要将这些行保留在索引中。这样可以减小索引的大小，从而可以加快那些确实使用索引的查询的速度。因为不需要在所有情况下都更新索引，所以它也将加快许多表的更新操作。&lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX1&quot;&gt;例11.1&lt;/a&gt;展示了这种想法的可能应用。</target>
        </trans-unit>
        <trans-unit id="d407807dcbba44e4e2aa91e451040ac8b91fe898" translate="yes" xml:space="preserve">
          <source>One might need to insert a large amount of data when first populating a database. This section contains some suggestions on how to make this process as efficient as possible.</source>
          <target state="translated">在第一次填充数据库时,可能需要插入大量的数据。本节包含一些关于如何尽可能提高这一过程效率的建议。</target>
        </trans-unit>
        <trans-unit id="af46cf06b4b2b1ea8a95f9146c144e8cb5a4d7fb" translate="yes" xml:space="preserve">
          <source>One must have the PostgreSQL superuser privilege to register a new language or change an existing language's parameters. However, once the language is created it is valid to assign ownership of it to a non-superuser, who may then drop it, change its permissions, rename it, or assign it to a new owner. (Do not, however, assign ownership of the underlying C functions to a non-superuser; that would create a privilege escalation path for that user.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8bb08b9cf98dd6c73c6dc0c7e52247a78ee67c4" translate="yes" xml:space="preserve">
          <source>One of</source>
          <target state="translated">其中一个</target>
        </trans-unit>
        <trans-unit id="0e3d57db8bbc433a035cda8e815f996da30de43e" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, or &lt;code&gt;TRUNCATE&lt;/code&gt;; this specifies the event that will fire the trigger. Multiple events can be specified using &lt;code&gt;OR&lt;/code&gt;, except when transition relations are requested.</source>
          <target state="translated">一个 &lt;code&gt;INSERT&lt;/code&gt; ， &lt;code&gt;UPDATE&lt;/code&gt; ， &lt;code&gt;DELETE&lt;/code&gt; ，或 &lt;code&gt;TRUNCATE&lt;/code&gt; ;这指定了将触发触发器的事件。可以使用 &lt;code&gt;OR&lt;/code&gt; 来指定多个事件，除非请求过渡关系。</target>
        </trans-unit>
        <trans-unit id="e5e814c340c50927afd7b76075dffb81341dc8b6" translate="yes" xml:space="preserve">
          <source>One of several disjoint (not overlapping) subsets of a larger set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d58cd9872ba6b984b5aaf4db1dd4f254a5318e3" translate="yes" xml:space="preserve">
          <source>One of the most critical design decisions will be the column or columns by which you partition your data. Often the best choice will be to partition by the column or set of columns which most commonly appear in &lt;code&gt;WHERE&lt;/code&gt; clauses of queries being executed on the partitioned table. &lt;code&gt;WHERE&lt;/code&gt; clause items that match and are compatible with the partition key can be used to prune unneeded partitions. However, you may be forced into making other decisions by requirements for the &lt;code&gt;PRIMARY KEY&lt;/code&gt; or a &lt;code&gt;UNIQUE&lt;/code&gt; constraint. Removal of unwanted data is also a factor to consider when planning your partitioning strategy. An entire partition can be detached fairly quickly, so it may be beneficial to design the partition strategy in such a way that all data to be removed at once is located in a single partition.</source>
          <target state="translated">最关键的设计决策之一将是您用来划分数据的一个或多个列。通常，最好的选择是按在分区表上执行的查询的 &lt;code&gt;WHERE&lt;/code&gt; 子句中最常见的列或列集进行分区。与分区键匹配并兼容的 &lt;code&gt;WHERE&lt;/code&gt; 子句项可用于修剪不需要的分区。但是，您可能会因对 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 或 &lt;code&gt;UNIQUE&lt;/code&gt; 的要求而被迫做出其他决定。约束。在计划分区策略时，删除不需要的数据也是要考虑的因素。可以相当快地分离整个分区，因此以这样一种方式设计分区策略可能是有益的，即所有要立即删除的数据都位于单个分区中。</target>
        </trans-unit>
        <trans-unit id="511f9e4f8bd3667e3b6d755989f295209cbb7bb6" translate="yes" xml:space="preserve">
          <source>One of the obvious uses for &lt;code&gt;file_fdw&lt;/code&gt; is to make the PostgreSQL activity log available as a table for querying. To do this, first you must be &lt;a href=&quot;runtime-config-logging#RUNTIME-CONFIG-LOGGING-CSVLOG&quot;&gt;logging to a CSV file,&lt;/a&gt; which here we will call &lt;code&gt;pglog.csv&lt;/code&gt;. First, install &lt;code&gt;file_fdw&lt;/code&gt; as an extension:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd64b8780a8987f51d6cf827b3649d1c335b7dcc" translate="yes" xml:space="preserve">
          <source>One of the obvious uses for &lt;code&gt;file_fdw&lt;/code&gt; is to make the PostgreSQL activity log available as a table for querying. To do this, first you must be logging to a CSV file, which here we will call &lt;code&gt;pglog.csv&lt;/code&gt;. First, install &lt;code&gt;file_fdw&lt;/code&gt; as an extension:</source>
          <target state="translated">&lt;code&gt;file_fdw&lt;/code&gt; 的明显用途之一是使PostgreSQL活动日志可用作查询表。为此，首先必须登录到CSV文件，在这里我们将其称为 &lt;code&gt;pglog.csv&lt;/code&gt; 。首先，安装 &lt;code&gt;file_fdw&lt;/code&gt; 作为扩展：</target>
        </trans-unit>
        <trans-unit id="01a9a0754bb2d47df04d6f754f8a9d26cef931fd" translate="yes" xml:space="preserve">
          <source>One of the problems with the JDBC driver (and this affects the ODBC driver also), is that the specification assumes that references to BLOBs (Binary Large OBjects) are stored within a table, and if that entry is changed, the associated BLOB is deleted from the database.</source>
          <target state="translated">JDBC驱动的一个问题(这也影响到ODBC驱动)是,规范假设对BLOB(二进制大对象)的引用存储在一个表中,如果该条目被改变,相关的BLOB将从数据库中删除。</target>
        </trans-unit>
        <trans-unit id="5e5610f45b959ec0066fbadc6e622bf504204314" translate="yes" xml:space="preserve">
          <source>One of the values estimated by &lt;code&gt;ANALYZE&lt;/code&gt; is the number of distinct values that appear in each column. Because only a subset of the rows are examined, this estimate can sometimes be quite inaccurate, even with the largest possible statistics target. If this inaccuracy leads to bad query plans, a more accurate value can be determined manually and then installed with &lt;code&gt;ALTER TABLE ... ALTER COLUMN ... SET (n_distinct = ...)&lt;/code&gt; (see &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;ANALYZE&lt;/code&gt; 估计的值之一是出现在每列中的不同值的数量。因为仅检查了行的子集，所以即使使用最大可能的统计目标，此估计有时也可能非常不准确。如果此错误导致查询计划不正确，则可以手动确定更准确的值，然后使用 &lt;code&gt;ALTER TABLE ... ALTER COLUMN ... SET (n_distinct = ...)&lt;/code&gt; （请参见&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="493483fbe186caeb533f2587ea2f5c9911b94b74" translate="yes" xml:space="preserve">
          <source>One or more server-challenge and client-response message will follow. Each server-challenge is sent in an AuthenticationSASLContinue message, followed by a response from client in an SASLResponse message. The particulars of the messages are mechanism specific.</source>
          <target state="translated">随后会有一个或多个服务器-挑战和客户端-响应消息。每一个服务器挑战都是在一个AuthenticationSASLCContinue消息中发送的,然后是客户端在一个SASLResponse消息中的响应。这些消息的具体内容是针对机制的。</target>
        </trans-unit>
        <trans-unit id="425be19de627a14da7ab3bb185d550dfbfe3423c" translate="yes" xml:space="preserve">
          <source>One parameter is specified per line. The equal sign between name and value is optional. Whitespace is insignificant (except within a quoted parameter value) and blank lines are ignored. Hash marks (&lt;code&gt;#&lt;/code&gt;) designate the remainder of the line as a comment. Parameter values that are not simple identifiers or numbers must be single-quoted. To embed a single quote in a parameter value, write either two quotes (preferred) or backslash-quote. If the file contains multiple entries for the same parameter, all but the last one are ignored.</source>
          <target state="translated">每行指定一个参数。名称和值之间的等号是可选的。空格无关紧要（带引号的参数值中除外），并且空行将被忽略。井号（ &lt;code&gt;#&lt;/code&gt; ）将行的其余部分指定为注释。非简单标识符或数字的参数值必须用单引号引起来。要将单引号嵌入参数值中，请写两个引号（首选）或反斜杠引号。如果文件包含同一参数的多个条目，则除最后一个条目外的所有条目都将被忽略。</target>
        </trans-unit>
        <trans-unit id="71b216cd8704d27b44cb581f634267f6e26f6ef5" translate="yes" xml:space="preserve">
          <source>One past the highest completed transaction ID. All transaction IDs greater than or equal to &lt;code&gt;xmax&lt;/code&gt; had not yet completed as of the time of the snapshot, and thus are invisible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3fe47df2bc317685fd9b966bcab8a9f820096f2" translate="yes" xml:space="preserve">
          <source>One row for each WAL sender process streaming a base backup, showing current progress. See &lt;a href=&quot;progress-reporting#BASEBACKUP-PROGRESS-REPORTING&quot;&gt;Section 27.4.5&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82642c7d45248923778a2209d5f115330d366506" translate="yes" xml:space="preserve">
          <source>One row for each backend (including autovacuum worker processes) running &lt;code&gt;ANALYZE&lt;/code&gt;, showing current progress. See &lt;a href=&quot;progress-reporting#ANALYZE-PROGRESS-REPORTING&quot;&gt;Section 27.4.1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80b5eb3c3d07dabe60de983aaa0a3518afd885a7" translate="yes" xml:space="preserve">
          <source>One row for each backend (including autovacuum worker processes) running &lt;code&gt;VACUUM&lt;/code&gt;, showing current progress. See &lt;a href=&quot;progress-reporting#VACUUM-PROGRESS-REPORTING&quot;&gt;Section 27.4.2&lt;/a&gt;.</source>
          <target state="translated">每个运行 &lt;code&gt;VACUUM&lt;/code&gt; 的后端（包括自动清理工作进程）的一行，显示当前进度。参见&lt;a href=&quot;progress-reporting#VACUUM-PROGRESS-REPORTING&quot;&gt;第27.4.2节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="effeab1715906cd694d7b1852e9b8750b001e4c5" translate="yes" xml:space="preserve">
          <source>One row for each backend (including autovacuum worker processes) running &lt;code&gt;VACUUM&lt;/code&gt;, showing current progress. See &lt;a href=&quot;progress-reporting#VACUUM-PROGRESS-REPORTING&quot;&gt;Section 27.4.3&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e814a8df1ec5e7ba9113e201d150026719d20049" translate="yes" xml:space="preserve">
          <source>One row for each backend running &lt;code&gt;CLUSTER&lt;/code&gt; or &lt;code&gt;VACUUM FULL&lt;/code&gt;, showing current progress. See &lt;a href=&quot;progress-reporting#CLUSTER-PROGRESS-REPORTING&quot;&gt;Section 27.4.3&lt;/a&gt;.</source>
          <target state="translated">每个运行 &lt;code&gt;CLUSTER&lt;/code&gt; 或 &lt;code&gt;VACUUM FULL&lt;/code&gt; 的后端一行，显示当前进度。参见&lt;a href=&quot;progress-reporting#CLUSTER-PROGRESS-REPORTING&quot;&gt;第27.4.3节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3fefdce83b8168d66ba70cfd9d6be8231c7483a5" translate="yes" xml:space="preserve">
          <source>One row for each backend running &lt;code&gt;CLUSTER&lt;/code&gt; or &lt;code&gt;VACUUM FULL&lt;/code&gt;, showing current progress. See &lt;a href=&quot;progress-reporting#CLUSTER-PROGRESS-REPORTING&quot;&gt;Section 27.4.4&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="592609ed9243ae5def10fa9f090855998b555b8d" translate="yes" xml:space="preserve">
          <source>One row for each backend running &lt;code&gt;CREATE INDEX&lt;/code&gt; or &lt;code&gt;REINDEX&lt;/code&gt;, showing current progress. See &lt;a href=&quot;progress-reporting#CREATE-INDEX-PROGRESS-REPORTING&quot;&gt;Section 27.4.1&lt;/a&gt;.</source>
          <target state="translated">每个运行 &lt;code&gt;CREATE INDEX&lt;/code&gt; 或 &lt;code&gt;REINDEX&lt;/code&gt; 的后端一行，显示当前进度。参见&lt;a href=&quot;progress-reporting#CREATE-INDEX-PROGRESS-REPORTING&quot;&gt;第27.4.1节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7c1c91b429aaf8e67212422dcd282876be59a3b8" translate="yes" xml:space="preserve">
          <source>One row for each backend running &lt;code&gt;CREATE INDEX&lt;/code&gt; or &lt;code&gt;REINDEX&lt;/code&gt;, showing current progress. See &lt;a href=&quot;progress-reporting#CREATE-INDEX-PROGRESS-REPORTING&quot;&gt;Section 27.4.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e27c3edf1970037c5b38d9980359c2a682d83e63" translate="yes" xml:space="preserve">
          <source>One row for each index in the current database, showing statistics about I/O on that specific index. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STATIO-ALL-INDEXES-VIEW&quot;&gt;&lt;code&gt;pg_statio_all_indexes&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="636789b8fa3526dcb7ffa47252873c271555303c" translate="yes" xml:space="preserve">
          <source>One row for each index in the current database, showing statistics about I/O on that specific index. See &lt;a href=&quot;monitoring-stats#PG-STATIO-ALL-INDEXES-VIEW&quot;&gt;pg_statio_all_indexes&lt;/a&gt; for details.</source>
          <target state="translated">当前数据库中每个索引的一行，显示有关该特定索引的I / O的统计信息。有关详细信息，请参见&lt;a href=&quot;monitoring-stats#PG-STATIO-ALL-INDEXES-VIEW&quot;&gt;pg_statio_all_indexes&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4d77f2cdac8ddfb746a4ceaac2099e52076e9af7" translate="yes" xml:space="preserve">
          <source>One row for each index in the current database, showing statistics about accesses to that specific index. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-ALL-INDEXES-VIEW&quot;&gt;&lt;code&gt;pg_stat_all_indexes&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c843f1eedf963b1dea0a4c471c30395c4850fb0a" translate="yes" xml:space="preserve">
          <source>One row for each index in the current database, showing statistics about accesses to that specific index. See &lt;a href=&quot;monitoring-stats#PG-STAT-ALL-INDEXES-VIEW&quot;&gt;pg_stat_all_indexes&lt;/a&gt; for details.</source>
          <target state="translated">当前数据库中每个索引的一行，显示有关对该特定索引的访问的统计信息。有关详细信息，请参见&lt;a href=&quot;monitoring-stats#PG-STAT-ALL-INDEXES-VIEW&quot;&gt;pg_stat_all_indexes&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5fdb86eec2a29466a4d1044e6a5602fb45a47381" translate="yes" xml:space="preserve">
          <source>One row for each sequence in the current database, showing statistics about I/O on that specific sequence. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STATIO-ALL-SEQUENCES-VIEW&quot;&gt;&lt;code&gt;pg_statio_all_sequences&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2a19a27308f1c1e0f487d86ec09bd9389b70b95" translate="yes" xml:space="preserve">
          <source>One row for each sequence in the current database, showing statistics about I/O on that specific sequence. See &lt;a href=&quot;monitoring-stats#PG-STATIO-ALL-SEQUENCES-VIEW&quot;&gt;pg_statio_all_sequences&lt;/a&gt; for details.</source>
          <target state="translated">当前数据库中每个序列的一行，显示有关该特定序列的I / O的统计信息。有关详细信息，请参见&lt;a href=&quot;monitoring-stats#PG-STATIO-ALL-SEQUENCES-VIEW&quot;&gt;pg_statio_all_sequences&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="af3494e4cc13caccb2edb628436f0d6fc2950bc0" translate="yes" xml:space="preserve">
          <source>One row for each table in the current database, showing statistics about I/O on that specific table. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STATIO-ALL-TABLES-VIEW&quot;&gt;&lt;code&gt;pg_statio_all_tables&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="876cb7f3198f93830f07de3b355cbda033ba5c5c" translate="yes" xml:space="preserve">
          <source>One row for each table in the current database, showing statistics about I/O on that specific table. See &lt;a href=&quot;monitoring-stats#PG-STATIO-ALL-TABLES-VIEW&quot;&gt;pg_statio_all_tables&lt;/a&gt; for details.</source>
          <target state="translated">当前数据库中每个表的一行，显示有关该特定表的I / O的统计信息。有关详细信息，请参见&lt;a href=&quot;monitoring-stats#PG-STATIO-ALL-TABLES-VIEW&quot;&gt;pg_statio_all_tables&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b933ef4e80b93a79e66696a5ea76c78fbf07acf1" translate="yes" xml:space="preserve">
          <source>One row for each table in the current database, showing statistics about accesses to that specific table. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-ALL-TABLES-VIEW&quot;&gt;&lt;code&gt;pg_stat_all_tables&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
