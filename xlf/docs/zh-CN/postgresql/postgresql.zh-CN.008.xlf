<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="d06f9c00387f2a47db4df9d5fd9d29afd85a64d3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.60. General-Purpose Window Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.60。通用窗口功能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a7332511d931adb3973faa13e02e9a2f58c70fb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.61. Series Generating Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.61。系列生成功能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="09c4a37f6c6f303582adee38d96973e59b8f1d45" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.62. Subscript Generating Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.62。下标生成函数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2135932869620b53f88c3e6313d35e2e57eb9554" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.63. Session Information Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.63。会话信息功能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="39be6ee87ea95e25c83a72d132334349eca53d68" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.64. Access Privilege Inquiry Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.64。访问权限查询功能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f88ee46d75d93ee18420ab0ac7544df7b69f3ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.65. &lt;code&gt;aclitem&lt;/code&gt; Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.65。 &lt;code&gt;aclitem&lt;/code&gt; 操作员&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9bff51c4fac1999b618aa6e81c66b1e1f53e8a09" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.66. &lt;code&gt;aclitem&lt;/code&gt; Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.66。 &lt;code&gt;aclitem&lt;/code&gt; 功能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b6ba9eacd371b2f2875e8cef1278fb77ebcd99c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.67. Schema Visibility Inquiry Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.67。模式可见性查询功能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="47c6aca319addf46ce6b419f1af927dda7149772" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.68. System Catalog Information Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.68。系统目录信息功能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="59944c027b46284746c3c0d85e815a750a8891d3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.69. Index Column Properties&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.69。索引栏属性&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1714aed665ee3ec122913f297f2add6146e8617b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.7. Trigonometric Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.7。三角函数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1931873243f7b29fd60849cb0265f82b1b3daa21" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.70. Index Properties&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.70。索引属性&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="494455ae6249fdb9eaf4bc96c399bcc0b3287c53" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.71. Index Access Method Properties&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.71。索引访问方法属性&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6d4a0d7f19cdaf9dd206d8238d622ef290fa34c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.72. Object Information and Addressing Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.72。对象信息和寻址功能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a2397166ddbff9e584fb4c1463d367dec3f650e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.73. Comment Information Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.73。评论信息功能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9a9e98e7f47369de4f674860d137be126fa8ff10" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.74. Transaction ID and Snapshot Information Functions&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80e1c97f51ff6d0e29990ff06de5f0ff4842e1bf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.74. Transaction IDs and Snapshots&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.74。交易编号和快照&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9297bd2822b43f167f4851fa970b2be7bc55e646" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.75. Snapshot Components&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.75。快照组件&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b9fe3f4e24a04a45285feb4f7f3c39797576ff14" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.76. Committed Transaction Information&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.76。承诺交易信息&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ec457094df6650e5b59b2d695b38d59162000858" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.76. Deprecated Transaction ID and Snapshot Information Functions&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="037beea666806eb579eb1e15cade8169bb088d22" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.77. Committed Transaction Information Functions&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22faf23155a7f6cdba38cb993e993be8e97bdafa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.77. Control Data Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.77。控制数据功能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="10369b4d2384de89827853c38a3dbb088df94279" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.78. &lt;code&gt;pg_control_checkpoint&lt;/code&gt; Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.78。 &lt;code&gt;pg_control_checkpoint&lt;/code&gt; 栏&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f4c03e3db71b0f0e87bd2ea049915cd526ae3e4a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.78. Control Data Functions&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a853addac70ca1f81119d41bef07e20f8877b599" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.79. &lt;code&gt;pg_control_checkpoint&lt;/code&gt; Output Columns&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be67b2ae4fcc41758e4db5cec6bff447ce947830" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.79. &lt;code&gt;pg_control_system&lt;/code&gt; Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.79。 &lt;code&gt;pg_control_system&lt;/code&gt; 栏&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cc142fb66ffa0a6f7f6394c00a57cfad199c4be9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.8. Hyperbolic Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.8。双曲函数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="69d99a933c31e93d42b87a8d05638885de6cef43" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.80. &lt;code&gt;pg_control_init&lt;/code&gt; Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.80。 &lt;code&gt;pg_control_init&lt;/code&gt; 列&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f8b6c4cc1095d92081bffbb653c34b6d02d3743" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.80. &lt;code&gt;pg_control_system&lt;/code&gt; Output Columns&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a173f9966d00cc18bb434a3a4ab064b9459dfff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.81. &lt;code&gt;pg_control_init&lt;/code&gt; Output Columns&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efe7424b608f8ebbc9334ad7d348b73c225f8065" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.81. &lt;code&gt;pg_control_recovery&lt;/code&gt; Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.81。 &lt;code&gt;pg_control_recovery&lt;/code&gt; 栏&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a159d3ea3ae4f3ccfc518444dfa8484fdb024615" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.82. &lt;code&gt;pg_control_recovery&lt;/code&gt; Output Columns&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="258d4eca1eec881df06fbf6eb5c508a7eb4defe6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.82. Configuration Settings Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.82。配置设置功能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e119847bd2faa7c76a5c66565911ba36a9ec0410" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.83. Configuration Settings Functions&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af63c82b09a5fd893d3cbed8d4c9b65a84c8cc49" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.83. Server Signaling Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.83。服务器信令功能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e11c93734b157fd8c86baa8c5096f64613f03240" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.84. Backup Control Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.84。备份控制功能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2acca3a24f9bc4df489286e833e69b95dc624f3f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.84. Server Signaling Functions&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d2eccbc931adbf83e2e35ba4730cc92f21be424" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.85. Backup Control Functions&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1cf89f9807ef48af5dc5feac483e531ed89fb76" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.85. Recovery Information Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.85。恢复信息功能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eb7192e9cdc53717cb1d3a3d7a47063c367c5fd1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.86. Recovery Control Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.86。恢复控制功能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="18d1b2e85a47e7957190d7b5366cb8b95a8619e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.86. Recovery Information Functions&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c22940566328cfb562e298f923b5c5b854ba617" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.87. Recovery Control Functions&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cc57c799c7d7ee53ed8b4b0bf37c2b80ea6845e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.87. Snapshot Synchronization Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.87。快照同步功能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="56158ae74f61cf23e3e86908ca0820720f4c8518" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.88. Replication SQL Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.88。复制SQL函数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2e4a778f3f4aea3b01888a18431c4aec5450cf91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.88. Snapshot Synchronization Functions&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53a72ba96b99dede4aa68dbbb8f2f4f443280905" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.89. Database Object Size Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.89。数据库对象大小函数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c7eb24e29872bb8ce841d184195dca28e365a088" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.89. Replication Management Functions&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0821b82f66d9f4a6e0cd038e52ed04c3f7a05a58" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.9. SQL String Functions and Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.9。SQL字符串函数和运算符&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8690793f9807c3f5f8ee02a7cc52f489067f885d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.90. Database Object Location Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.90。数据库对象定位功能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="57f81cd7ef731234c1aa58e5ac57c4b20d50b59f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.90. Database Object Size Functions&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dac1ecbd39f8f56220a662263d1df23c3bd1d5f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.91. Collation Management Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.91。整理管理功能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="648f3f86b8b877c2a7cf1d1174a61e4e892421ca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.91. Database Object Location Functions&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75784f3209f818a7b4abe3d1335fa8a55370c481" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.92. Collation Management Functions&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1d40194ab60a69acde4e12b20bea43def6aedf5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.92. Partitioning Information Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.92。分区信息功能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7c370022e15dfd2d0b3991d342e19956b98c04f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.93. Index Maintenance Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.93。索引维护功能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2937ed5c90d57a915d7a2b0a154f93953f850843" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.93. Partitioning Information Functions&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8379ad039963b5ac568013d446df9562b67c6abc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.94. Generic File Access Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.94。通用文件访问功能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="42b95f05574afc667abf5b3192f21fdebd527e31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.94. Index Maintenance Functions&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5e2d3bc1f47aa4a1635eb7f3cff3425017bca1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.95. Advisory Lock Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.95。咨询锁功能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d3110ab11d26d5acb24d0ef4008dbf1062e59f19" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.95. Generic File Access Functions&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="669703497d2e61484f74a9f852b77c7dbe96af61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.96. Advisory Lock Functions&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd947ce6d00206881c9746604187286ad479d127" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table A.1. PostgreSQL Error Codes&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表A.1。PostgreSQL错误代码&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a05dac2107a5f9f2ac31f3b94de8292ede9abce7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table B.1. Month Names&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表B.1。月份名称&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6d0ce6d7b1e15e8e01aa65312fb0df9adeaf930d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table B.2. Day of the Week Names&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表B.2。星期几名称&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4035fdc79af664ad037421045dfc08f552eb1aa7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table B.3. Date/Time Field Modifiers&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表B.3。日期/时间字段修饰符&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="559edd83cb5073785f38017209bf4a3b36ac0ed6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table C.1. SQL Key Words&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表C.1。SQL关键词&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8d10534ea211538918961793e09cac043e6061f2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.1. &lt;code&gt;adminpack&lt;/code&gt; Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.1。 &lt;code&gt;adminpack&lt;/code&gt; 函数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9b519c1bf6f735544d2045d66c60755bcd006027" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.10. &lt;code&gt;intarray&lt;/code&gt; Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.10。 &lt;code&gt;intarray&lt;/code&gt; 运算符&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c07b2821b106599e7e19c067ef0623853754e74b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.11. &lt;code&gt;isn&lt;/code&gt; Data Types&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.11。 &lt;code&gt;isn&lt;/code&gt; 数据类型&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9de57df1bb6bd0b8cf1c93e4ac13f3f2cd6cec28" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.12. &lt;code&gt;isn&lt;/code&gt; Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.12。 &lt;code&gt;isn&lt;/code&gt; 功能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a5fc76943f1f53439b794c832fa0195dc25753eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.13. &lt;code&gt;ltree&lt;/code&gt; Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.13。 &lt;code&gt;ltree&lt;/code&gt; 运算符&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f47dedf5cd81c558ae828df89aeceeffbcca4ee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.14. &lt;code&gt;ltree&lt;/code&gt; Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.14。 &lt;code&gt;ltree&lt;/code&gt; 函数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="db1ea3c10d5f847276d5255278d415ebe4cfbb7d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.15. &lt;code&gt;pg_buffercache&lt;/code&gt; Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.15。 &lt;code&gt;pg_buffercache&lt;/code&gt; 列&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bb70b4765f6524df3f91e44d66f42eb9ce59f1f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.16. Supported Algorithms for &lt;code&gt;crypt()&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.16。 &lt;code&gt;crypt()&lt;/code&gt; 支持的算法&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="74efd3a20d0a5ca77d9ec0d65a88482478d0db59" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.17. Iteration Counts for &lt;code&gt;crypt()&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.17。 &lt;code&gt;crypt()&lt;/code&gt; 的迭代计数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e16082250b8218899af06afb261507b192bd2a3b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.18. Hash Algorithm Speeds&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.18。哈希算法速度&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="023c35c98f9f91629573b50cb356cd985b32d53d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.19. Summary of Functionality with and without OpenSSL&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.19。有和没有OpenSSL的功能摘要&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="97b5d7566b2274950bfb99f59140174951e32afe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.2. Cube External Representations&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.2。多维数据集外部表示&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="31519ff8934e1c9d30bb975be3e1d15050040610" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.20. &lt;code&gt;pgrowlocks&lt;/code&gt; Output Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.20。 &lt;code&gt;pgrowlocks&lt;/code&gt; 输出列&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="40ee7b256a4076cfeae51995de13c374ee02588a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.21. &lt;code&gt;pg_stat_statements&lt;/code&gt; Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.21。 &lt;code&gt;pg_stat_statements&lt;/code&gt; 列&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2bf9da321dec29d80c37b3aec85adcfd8d4e6ca7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.22. &lt;code&gt;pgstattuple&lt;/code&gt; Output Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.22。 &lt;code&gt;pgstattuple&lt;/code&gt; 输出列&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="36d397f9b671a3e1925bb2eb0936f8f0832e9789" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.23. &lt;code&gt;pgstattuple_approx&lt;/code&gt; Output Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.23。 &lt;code&gt;pgstattuple_approx&lt;/code&gt; 输出列&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c437a7af148f8e8389f5c7449218ce3b637fba68" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.24. &lt;code&gt;pg_trgm&lt;/code&gt; Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.24。 &lt;code&gt;pg_trgm&lt;/code&gt; 函数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="76d05073c0bf7063af3660fac90eb31ef8a83d22" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.25. &lt;code&gt;pg_trgm&lt;/code&gt; Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.25。 &lt;code&gt;pg_trgm&lt;/code&gt; 运算符&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b53fc25e7d7cf3149fa7d701cb97669cc4302291" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.26. &lt;code&gt;seg&lt;/code&gt; External Representations&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.26。 &lt;code&gt;seg&lt;/code&gt; 外部代表&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fce95711636b8b7c0ab0c8c90a10676ec4c5dd99" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.27. Examples of Valid &lt;code&gt;seg&lt;/code&gt; Input&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.27。有效 &lt;code&gt;seg&lt;/code&gt; 输入的示例&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c0703329077e17e37589124cf687bfbdb4ff5f02" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.28. Seg GiST Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.28。Seg GiST运算符&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7efb677aa5a54059bffe378ceabe3ff851dc97be" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.29. Sepgsql Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.29。Sepgsql函数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d3a4b5bfe663b6c86554a4fe157eb1e9883705ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.3. Cube Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.3。多维数据集运算符&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c2f068919e3f99a106ec1019bd78e8bde34335d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.30. &lt;code&gt;tablefunc&lt;/code&gt; Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.30。 &lt;code&gt;tablefunc&lt;/code&gt; 函数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c27a41af6ae7cee6f4a14c9d9a0b8aef27e683da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.31. &lt;code&gt;connectby&lt;/code&gt; Parameters&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.31。 &lt;code&gt;connectby&lt;/code&gt; 参数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eccc0fa14874dcf09c6ccf36766eb1c65d7a9d87" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.32. Functions for UUID Generation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.32。UUID生成的功能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="285949d92f8186403bfcd2046f6dcc6813339504" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.33. Functions Returning UUID Constants&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.33。返回UUID常量的函数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ce4775173e0a8d85b3a4c68976acfaac26cdbeba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.34. &lt;code&gt;xml2&lt;/code&gt; Functions&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2710d2338031518ccc53baf6792d41b5ad8f677" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.34. Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.34。功能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0e4038c34dc95dfcc18297824a175effec134055" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.35. &lt;code&gt;xpath_table&lt;/code&gt; Parameters&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.35。 &lt;code&gt;xpath_table&lt;/code&gt; 参数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="42b35f9c6abb36ad8fc92db8bdc01beb1c4250a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.4. Cube Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.4。多维数据集功能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e92b11d7884dfede47b04bfcbf5a41bf72e63d9e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.5. Cube-Based Earthdistance Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.5。基于立方体的地球距离函数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e051b81229455604f98408865a6ac1b4addebbc2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.6. Point-Based Earthdistance Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.6。基于点的地球距离算子&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="abcf169338c4abfd8292e2d9fff28e5b2b09033c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.7. &lt;code&gt;hstore&lt;/code&gt; Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.7。 &lt;code&gt;hstore&lt;/code&gt; 运算子&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="40c6e68eca0fdcd7802454203dbb36dbc3ddb825" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.8. &lt;code&gt;hstore&lt;/code&gt; Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.8。 &lt;code&gt;hstore&lt;/code&gt; 功能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1d86c143b9375e6f997fb5dadf92e3e129f96c3c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.9. &lt;code&gt;intarray&lt;/code&gt; Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.9。 &lt;code&gt;intarray&lt;/code&gt; 函数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d890fb1a42200a1b33e3307e2ccd5c9035ab6794" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table K.1. PostgreSQL Limitations&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表K.1。PostgreSQL限制&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="696c4ceafbfe949ae4e1ac9f260a8e4f375683bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table of Contents&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;目录&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1bf69c48186996b82fe7b81247ad9250cfca6c96" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table-Level Lock Modes&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表级锁定模式&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be38ff52aef87b71c69cb929026cdf03c79939a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Type Resolution for &lt;code&gt;UNION&lt;/code&gt;, &lt;code&gt;CASE&lt;/code&gt;, and Related Constructs&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;UNION&lt;/code&gt; ， &lt;code&gt;CASE&lt;/code&gt; 和相关构造的类型解析&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5460fb3b002cb82e36bdab3a44937749c957abe2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Upgrade streaming replication and log-shipping standby servers&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;升级流复制和日志传送备用服务器&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a0c5de3159b80d3a3ca8692e2ddf1964928d7107" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use &lt;code&gt;split&lt;/code&gt;. &lt;/strong&gt; The &lt;code&gt;split&lt;/code&gt; command allows you to split the output into smaller files that are acceptable in size to the underlying file system. For example, to make chunks of 1 megabyte:</source>
          <target state="translated">&lt;strong&gt;使用 &lt;code&gt;split&lt;/code&gt; 。&lt;/strong&gt;的 &lt;code&gt;split&lt;/code&gt; 命令允许输出分割成更小文件在尺寸上与底层文件系统是可接受的。例如，要制作1兆字节的块：</target>
        </trans-unit>
        <trans-unit id="1a80b9aa68fb3c8b73036c3ce7eec622afb708fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use compressed dumps. &lt;/strong&gt; You can use your favorite compression program, for example gzip:</source>
          <target state="translated">&lt;strong&gt;使用压缩转储。&lt;/strong&gt;您可以使用自己喜欢的压缩程序，例如gzip：</target>
        </trans-unit>
        <trans-unit id="1abab695321f295c720b6c84d1b5599f942c1413" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use pg_dump's custom dump format. &lt;/strong&gt; If PostgreSQL was built on a system with the zlib compression library installed, the custom dump format will compress data as it writes it to the output file. This will produce dump file sizes similar to using &lt;code&gt;gzip&lt;/code&gt;, but it has the added advantage that tables can be restored selectively. The following command dumps a database using the custom dump format:</source>
          <target state="translated">&lt;strong&gt;使用pg_dump的自定义转储格式。&lt;/strong&gt;如果PostgreSQL是在安装了zlib压缩库的系统上构建的，则自定义转储格式将在将数据写入输出文件时对其进行压缩。这将产生类似于使用 &lt;code&gt;gzip&lt;/code&gt; 的转储文件大小，但是它具有附加的优点，即可以选择性地还原表。以下命令使用自定义转储格式转储数据库：</target>
        </trans-unit>
        <trans-unit id="cbfe9fc7a7a29e0a0178f83061d2c90c3e3b191c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use pg_dump's parallel dump feature. &lt;/strong&gt; To speed up the dump of a large database, you can use pg_dump's parallel mode. This will dump multiple tables at the same time. You can control the degree of parallelism with the &lt;code&gt;-j&lt;/code&gt; parameter. Parallel dumps are only supported for the &quot;directory&quot; archive format.</source>
          <target state="translated">&lt;strong&gt;使用pg_dump的并行转储功能。&lt;/strong&gt;为了加快大型数据库的转储，可以使用pg_dump的并行模式。这将同时转储多个表。您可以使用 &lt;code&gt;-j&lt;/code&gt; 参数控制并行度。仅&amp;ldquo;目录&amp;rdquo;归档格式支持并行转储。</target>
        </trans-unit>
        <trans-unit id="edfa928646e2342a7f8cd8c011c0572d9d895659" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Value Storage Type Conversion&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;值存储类型转换&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cf7bb1fedc9115854eb42fd28c3bf8a588f25119" translate="yes" xml:space="preserve">
          <source>@ 1 year 2 mons</source>
          <target state="translated">@ 1年2星期一</target>
        </trans-unit>
        <trans-unit id="03555338c898371183a9886d4e4b1c92f3732990" translate="yes" xml:space="preserve">
          <source>@ 1 year 2 mons -3 days 4 hours 5 mins 6 secs ago</source>
          <target state="translated">@ 1年2星期一-3天4小时5分钟6秒前</target>
        </trans-unit>
        <trans-unit id="81d943392746fd8a7d1a28c6c2928f65ea407380" translate="yes" xml:space="preserve">
          <source>@ 3 days 4 hours 5 mins 6 secs</source>
          <target state="translated">@ 3天4小时5分钟6秒</target>
        </trans-unit>
        <trans-unit id="bf2057e4a34b0143c5ca30f416938d0496f64cf4" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;from SQL&amp;rdquo; function that converts the type from the SQL environment to the language. This function will be invoked on the arguments of a function written in the language.</source>
          <target state="translated">&amp;ldquo;从SQL&amp;rdquo;函数将类型从SQL环境转换为语言。该函数将在用该语言编写的函数的参数上调用。</target>
        </trans-unit>
        <trans-unit id="5d8d466be36923654e1e5048281d3752210ffa26" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;nil&amp;rdquo; UUID constant, which does not occur as a real UUID.</source>
          <target state="translated">&amp;ldquo; nil&amp;rdquo; UUID常量，不会作为真实的UUID出现。</target>
        </trans-unit>
        <trans-unit id="2762eb369c90d7266035a7f6c6fc6bc10aa918a6" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;search&amp;rdquo; operator entry indicates that an index of this operator family can be searched to find all rows satisfying &lt;code&gt;WHERE&lt;/code&gt;&lt;code&gt;indexed_column&lt;/code&gt;&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;constant&lt;/code&gt;. Obviously, such an operator must return &lt;code&gt;boolean&lt;/code&gt;, and its left-hand input type must match the index's column data type.</source>
          <target state="translated">&amp;ldquo;搜索&amp;rdquo;运算符条目指示可以搜索该运算符系列的索引，以找到满足 &lt;code&gt;WHERE&lt;/code&gt; &lt;code&gt;indexed_column&lt;/code&gt; &lt;code&gt;operator&lt;/code&gt; &lt;code&gt;constant&lt;/code&gt; 所有行。显然，此类运算符必须返回 &lt;code&gt;boolean&lt;/code&gt; ，并且其左侧输入类型必须与索引的列数据类型匹配。</target>
        </trans-unit>
        <trans-unit id="cb8c23a8cc28795360368ac535c18eb45a0b60b7" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;to SQL&amp;rdquo; function that converts the type from the language to the SQL environment. This function will be invoked on the return value of a function written in the language.</source>
          <target state="translated">一个&amp;ldquo; to SQL&amp;rdquo;函数，将类型从语言转换为SQL环境。该函数将在用该语言编写的函数的返回值上调用。</target>
        </trans-unit>
        <trans-unit id="3ae930caf5146f65e1ff7504137e6bf65415863f" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;user logging out&amp;rdquo; might happen as part of a maintenance job or manually when an administrator logs in as the &lt;code&gt;postgres&lt;/code&gt; user or something similar, so it is hard to prevent in general.</source>
          <target state="translated">当管理员以 &lt;code&gt;postgres&lt;/code&gt; 用户或类似身份登录时，&amp;ldquo;用户注销&amp;rdquo;可能是维护工作的一部分，也可能是手动发生的，因此通常很难避免。</target>
        </trans-unit>
        <trans-unit id="1ff3ebb0f8189d5c79fdc8dc5893085ae875532b" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; that is paired with a &lt;a href=&quot;glossary#GLOSSARY-PRIMARY-SERVER&quot;&gt;primary&lt;/a&gt; database and is maintaining a copy of some or all of the primary database's data. The foremost reasons for doing this are to allow for greater access to that data, and to maintain availability of the data in the event that the &lt;a href=&quot;glossary#GLOSSARY-PRIMARY-SERVER&quot;&gt;primary&lt;/a&gt; becomes unavailable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b194a0aad401cf33db00ac53a2bc3183f5f056e" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-DB-CLUSTER&quot;&gt;cluster&lt;/a&gt;'s storage space comprises the data directory plus any additional tablespaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c2f7268e91d10d9931079a4060abb1b24912d62" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-FUNCTION&quot;&gt;function&lt;/a&gt; that combines (&lt;em&gt;aggregates&lt;/em&gt;) multiple input values, for example by counting, averaging or adding, yielding a single output value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8de6f610e2bf77390b8a376c81b44793683355f" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-FUNCTION&quot;&gt;function&lt;/a&gt; which can be defined to execute whenever a certain operation (&lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;TRUNCATE&lt;/code&gt;) is applied to a &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt;. A trigger executes within the same &lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;transaction&lt;/a&gt; as the statement which invoked it, and if the function fails, then the invoking statement also fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e2fccb32e2fa61d4f930e061e62abd8488bb50a" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; that contains data derived from a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; or &lt;a href=&quot;glossary#GLOSSARY-MATERIALIZED-VIEW&quot;&gt;materialized view&lt;/a&gt;. Its internal structure supports fast retrieval of and access to the original data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="584813927fa0b70a127a5ac34c88fc5f5c387c54" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; that is defined by a &lt;code&gt;SELECT&lt;/code&gt; statement (just like a &lt;a href=&quot;glossary#GLOSSARY-VIEW&quot;&gt;view&lt;/a&gt;), but stores data in the same way that a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; does. It cannot be modified via &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt; operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="389fa46ef8422aab8a4910b862a288c61f74078c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; that is defined by a &lt;code&gt;SELECT&lt;/code&gt; statement, but has no storage of its own. Any time a query references a view, the definition of the view is substituted into the query as if the user had typed it as a subquery instead of the name of the view.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53c9b267d1a3c53d206839f21ecc0e74a5743f97" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; that is in semantic terms the same as a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt;, but whose storage is distributed across several &lt;a href=&quot;glossary#GLOSSARY-PARTITION&quot;&gt;partitions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4beb53d2dd032e24132f47b79c4ab9ee08f60da3" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; transmitted from a &lt;a href=&quot;glossary#GLOSSARY-BACKEND&quot;&gt;backend process&lt;/a&gt; to a &lt;a href=&quot;glossary#GLOSSARY-CLIENT&quot;&gt;client&lt;/a&gt; upon the completion of an SQL command, usually a &lt;code&gt;SELECT&lt;/code&gt; but it can be an &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt; command if the &lt;code&gt;RETURNING&lt;/code&gt; clause is specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15e75dd492c3448df99f37b47329397dc097e33f" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; which appears to have &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;rows&lt;/a&gt; and &lt;a href=&quot;glossary#GLOSSARY-COLUMN&quot;&gt;columns&lt;/a&gt; similar to a regular &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt;, but will forward requests for data through its &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-DATA-WRAPPER&quot;&gt;foreign data wrapper&lt;/a&gt;, which will return &lt;a href=&quot;glossary#GLOSSARY-RESULT-SET&quot;&gt;result sets&lt;/a&gt; structured according to the definition of the &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-TABLE&quot;&gt;foreign table&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2896c9fab918dbff2c145f3310c61dcc0ebaadf8" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-ROLE&quot;&gt;role&lt;/a&gt; that has the &lt;code&gt;LOGIN&lt;/code&gt; privilege.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0269b93f9965a7efd0bd4de79b884ef8ce24927" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; is considered &lt;a href=&quot;glossary#GLOSSARY-LOGGED&quot;&gt;logged&lt;/a&gt; if changes to it are sent to the &lt;a href=&quot;glossary#GLOSSARY-WAL&quot;&gt;WAL&lt;/a&gt;. By default, all regular tables are logged. A table can be specified as &lt;a href=&quot;glossary#GLOSSARY-UNLOGGED&quot;&gt;unlogged&lt;/a&gt; either at creation time or via the &lt;code&gt;ALTER TABLE&lt;/code&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87f22694b8568dac5808dc2163d1d852566c139b" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; or &lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt; command which will provide the columns and rows of the view.</source>
          <target state="translated">甲&lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;或&lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt;命令，这将提供的视图的列和行。</target>
        </trans-unit>
        <trans-unit id="f5f1049f4109dc5db352ab8d92ece996eabd228c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; or &lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt; command which will provide the rows to be returned by the cursor.</source>
          <target state="translated">甲&lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;或&lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt;命令，这将提供到由光标被返回的行。</target>
        </trans-unit>
        <trans-unit id="b8b71200935bf14bcaf475eabe324c9a915be563" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;, &lt;a href=&quot;sql-select#SQL-TABLE&quot;&gt;TABLE&lt;/a&gt;, or &lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt; command, or an &lt;a href=&quot;sql-execute&quot;&gt;EXECUTE&lt;/a&gt; command that runs a prepared &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;TABLE&lt;/code&gt;, or &lt;code&gt;VALUES&lt;/code&gt; query.</source>
          <target state="translated">甲&lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;，&lt;a href=&quot;sql-select#SQL-TABLE&quot;&gt;TABLE&lt;/a&gt;，或&lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt;命令，或&lt;a href=&quot;sql-execute&quot;&gt;EXECUTE&lt;/a&gt;运行准备的命令 &lt;code&gt;SELECT&lt;/code&gt; ， &lt;code&gt;TABLE&lt;/code&gt; ，或 &lt;code&gt;VALUES&lt;/code&gt; 查询。</target>
        </trans-unit>
        <trans-unit id="b516d250c25b6e73cb44ebe944600ea4dcdfab57" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;, &lt;a href=&quot;sql-select#SQL-TABLE&quot;&gt;TABLE&lt;/a&gt;, or &lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt; command. This query will run within a security-restricted operation; in particular, calls to functions that themselves create temporary tables will fail.</source>
          <target state="translated">甲&lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;，&lt;a href=&quot;sql-select#SQL-TABLE&quot;&gt;TABLE&lt;/a&gt;，或&lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt;命令。该查询将在安全性受限的操作中运行；特别是，对本身创建临时表的函数的调用将失败。</target>
        </trans-unit>
        <trans-unit id="4c32cd6f04f46fa40c66ced5598180206388bcb3" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;, &lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt;, &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;sql-delete&quot;&gt;DELETE&lt;/a&gt; command whose results are to be copied. Note that parentheses are required around the query.</source>
          <target state="translated">一条&lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;，&lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt;，&lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt;，&lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt;或&lt;a href=&quot;sql-delete&quot;&gt;DELETE&lt;/a&gt;命令，其结果将被复制。请注意，在查询周围需要括号。</target>
        </trans-unit>
        <trans-unit id="3aac443fc49c397d670128be5de3b30376a87d25" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;lt;&lt;/code&gt; operator must be a strong ordering relation; that is, for all non-null values &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;:</source>
          <target state="translated">甲 &lt;code&gt;&amp;lt;&lt;/code&gt; 操作员必须是一个强有力的排序关系; 也就是说，对于所有非空值 &lt;code&gt;A&lt;/code&gt; ， &lt;code&gt;B&lt;/code&gt; ， &lt;code&gt;C&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="819a83c6160f87b8fbe9b47f7e8c2fcb8b3441e2" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CASE&lt;/code&gt; construct used in this fashion will defeat optimization attempts, so it should only be done when necessary. (In this particular example, it would be better to sidestep the problem by writing &lt;code&gt;y &amp;gt; 1.5*x&lt;/code&gt; instead.)</source>
          <target state="translated">以这种方式使用的 &lt;code&gt;CASE&lt;/code&gt; 构造将挫败优化尝试，因此仅应在必要时进行。（在此特定示例中，最好改写 &lt;code&gt;y &amp;gt; 1.5*x&lt;/code&gt; 来避开该问题。）</target>
        </trans-unit>
        <trans-unit id="6247b7100ee328df210a70a605d94770307d4618" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CASE&lt;/code&gt; expression does not evaluate any subexpressions that are not needed to determine the result. For example, this is a possible way of avoiding a division-by-zero failure:</source>
          <target state="translated">甲 &lt;code&gt;CASE&lt;/code&gt; 表达式的值不未需要确定的结果的任何子表达式。例如，这是避免被零除故障的一种可能方法：</target>
        </trans-unit>
        <trans-unit id="99c1d2ec7824e3f9be873b53497fbe438c59e00f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CREATE FUNCTION&lt;/code&gt; command is defined in the SQL standard. The PostgreSQL version is similar but not fully compatible. The attributes are not portable, neither are the different available languages.</source>
          <target state="translated">甲 &lt;code&gt;CREATE FUNCTION&lt;/code&gt; 命令在SQL标准中定义。PostgreSQL版本相似，但不完全兼容。这些属性不是可移植的，不同的可用语言也不是。</target>
        </trans-unit>
        <trans-unit id="72fba28ad575d8675106f7a64f95b2cad77d64bd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CREATE PROCEDURE&lt;/code&gt; command is defined in the SQL standard. The PostgreSQL version is similar but not fully compatible. For details see also &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;.</source>
          <target state="translated">甲 &lt;code&gt;CREATE PROCEDURE&lt;/code&gt; 命令在SQL标准中定义。PostgreSQL版本相似，但不完全兼容。有关详细信息，请参见&lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4d8bad9823a1eeb3d425248ce5d647ad68ad9035" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;DELETE&lt;/code&gt; policy cannot have a &lt;code&gt;WITH CHECK&lt;/code&gt; expression, as it only applies in cases where records are being deleted from the relation, so that there is no new row to check.</source>
          <target state="translated">一个 &lt;code&gt;DELETE&lt;/code&gt; 政策不能有 &lt;code&gt;WITH CHECK&lt;/code&gt; 表达，因为它仅适用于在记录被从关系中删除的情况下，所以没有新行检查。</target>
        </trans-unit>
        <trans-unit id="ffed91b9d2e2689c8f9096a3b8e654e3487952c0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;JOIN&lt;/code&gt; clause combines two &lt;code&gt;FROM&lt;/code&gt; items, which for convenience we will refer to as &amp;ldquo;tables&amp;rdquo;, though in reality they can be any type of &lt;code&gt;FROM&lt;/code&gt; item. Use parentheses if necessary to determine the order of nesting. In the absence of parentheses, &lt;code&gt;JOIN&lt;/code&gt;s nest left-to-right. In any case &lt;code&gt;JOIN&lt;/code&gt; binds more tightly than the commas separating &lt;code&gt;FROM&lt;/code&gt;-list items.</source>
          <target state="translated">一个 &lt;code&gt;JOIN&lt;/code&gt; 子句组合两个 &lt;code&gt;FROM&lt;/code&gt; 项，为方便起见，我们将其称为&amp;ldquo;表&amp;rdquo;，但在现实中，他们可以是任何类型的 &lt;code&gt;FROM&lt;/code&gt; 项。如有必要，请使用括号确定嵌套顺序。在没有括号的情况下， &lt;code&gt;JOIN&lt;/code&gt; 从左到右嵌套。在任何情况下， &lt;code&gt;JOIN&lt;/code&gt; 结合比更紧密地分隔逗号 &lt;code&gt;FROM&lt;/code&gt; -list项目。</target>
        </trans-unit>
        <trans-unit id="22a84ad9de4a47f15eabedf603ec63031e192119" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;LATERAL&lt;/code&gt; item can appear at top level in the &lt;code&gt;FROM&lt;/code&gt; list, or within a &lt;code&gt;JOIN&lt;/code&gt; tree. In the latter case it can also refer to any items that are on the left-hand side of a &lt;code&gt;JOIN&lt;/code&gt; that it is on the right-hand side of.</source>
          <target state="translated">一个 &lt;code&gt;LATERAL&lt;/code&gt; 项目可以在顶层出现 &lt;code&gt;FROM&lt;/code&gt; 列表，或在一个 &lt;code&gt;JOIN&lt;/code&gt; 树。在后一种情况下，它还可以引用位于 &lt;code&gt;JOIN&lt;/code&gt; 左侧的任何项目。</target>
        </trans-unit>
        <trans-unit id="e8ae34e725d60cc08b18c4661033d9a5986eedac" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SECURITY DEFINER&lt;/code&gt; procedure cannot execute transaction control statements (for example, &lt;code&gt;COMMIT&lt;/code&gt; and &lt;code&gt;ROLLBACK&lt;/code&gt;, depending on the language).</source>
          <target state="translated">甲 &lt;code&gt;SECURITY DEFINER&lt;/code&gt; 过程不能执行事务控制语句（例如， &lt;code&gt;COMMIT&lt;/code&gt; 和 &lt;code&gt;ROLLBACK&lt;/code&gt; ，取决于语言）。</target>
        </trans-unit>
        <trans-unit id="24640de38cd7e79e6c26b95c139e86bc1984a68f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SELECT&lt;/code&gt; sub-query that produces as many output columns as are listed in the parenthesized column list preceding it. The sub-query must yield no more than one row when executed. If it yields one row, its column values are assigned to the target columns; if it yields no rows, NULL values are assigned to the target columns. The sub-query can refer to old values of the current row of the table being updated.</source>
          <target state="translated">一个 &lt;code&gt;SELECT&lt;/code&gt; 子查询，它产生的输出列与其前括号列中列出的输出列一样多。子查询在执行时必须产生不超过一行。如果产生一行，则将其列值分配给目标列。如果不产生任何行，则将NULL值分配给目标列。子查询可以引用要更新的表的当前行的旧值。</target>
        </trans-unit>
        <trans-unit id="9f32387ffee5e380629abaa1525601dc9d6facaf" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;ShareLock&lt;/code&gt; is required on the target index by &lt;code&gt;bt_index_parent_check&lt;/code&gt; (a &lt;code&gt;ShareLock&lt;/code&gt; is also acquired on the heap relation). These locks prevent concurrent data modification from &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt; commands. The locks also prevent the underlying relation from being concurrently processed by &lt;code&gt;VACUUM&lt;/code&gt;, as well as all other utility commands. Note that the function holds locks only while running, not for the entire transaction.</source>
          <target state="translated">甲 &lt;code&gt;ShareLock&lt;/code&gt; 需要由目标索引 &lt;code&gt;bt_index_parent_check&lt;/code&gt; （一个 &lt;code&gt;ShareLock&lt;/code&gt; 还获取在堆上关系）。这些锁可防止通过 &lt;code&gt;INSERT&lt;/code&gt; ， &lt;code&gt;UPDATE&lt;/code&gt; 和 &lt;code&gt;DELETE&lt;/code&gt; 命令进行并发数据修改。这些锁还防止 &lt;code&gt;VACUUM&lt;/code&gt; 以及所有其他实用程序命令同时处理基础关系。请注意，该函数仅在运行时才持有锁，而不是整个事务都持有。</target>
        </trans-unit>
        <trans-unit id="f5a2d75bff2c30ff411c224c9fe1259bed07345e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TABLESAMPLE&lt;/code&gt; clause after a &lt;code&gt;table_name&lt;/code&gt; indicates that the specified &lt;code&gt;sampling_method&lt;/code&gt; should be used to retrieve a subset of the rows in that table. This sampling precedes the application of any other filters such as &lt;code&gt;WHERE&lt;/code&gt; clauses. The standard PostgreSQL distribution includes two sampling methods, &lt;code&gt;BERNOULLI&lt;/code&gt; and &lt;code&gt;SYSTEM&lt;/code&gt;, and other sampling methods can be installed in the database via extensions.</source>
          <target state="translated">甲 &lt;code&gt;TABLESAMPLE&lt;/code&gt; 一个后子句 &lt;code&gt;table_name&lt;/code&gt; 表示指定 &lt;code&gt;sampling_method&lt;/code&gt; 应用于检索该表中的行的子集。此采样先于其他过滤器（例如 &lt;code&gt;WHERE&lt;/code&gt; 子句）的应用。标准的PostgreSQL发行版包括 &lt;code&gt;BERNOULLI&lt;/code&gt; 和 &lt;code&gt;SYSTEM&lt;/code&gt; 这两种采样方法，可以通过扩展将其他采样方法安装在数据库中。</target>
        </trans-unit>
        <trans-unit id="0e67a4c57a74dd900aa610f5f6c701a6078b7404" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TZH&lt;/code&gt; template pattern can match a signed number. Without the &lt;code&gt;FX&lt;/code&gt; option, minus signs may be ambiguous, and could be interpreted as a separator. This ambiguity is resolved as follows: If the number of separators before &lt;code&gt;TZH&lt;/code&gt; in the template string is less than the number of separators before the minus sign in the input string, the minus sign is interpreted as part of &lt;code&gt;TZH&lt;/code&gt;. Otherwise, the minus sign is considered to be a separator between values. For example, &lt;code&gt;to_timestamp('2000 -10', 'YYYY TZH')&lt;/code&gt; matches &lt;code&gt;-10&lt;/code&gt; to &lt;code&gt;TZH&lt;/code&gt;, but &lt;code&gt;to_timestamp('2000 -10', 'YYYY&amp;nbsp;&amp;nbsp;TZH')&lt;/code&gt; matches &lt;code&gt;10&lt;/code&gt; to &lt;code&gt;TZH&lt;/code&gt;.</source>
          <target state="translated">一个 &lt;code&gt;TZH&lt;/code&gt; 模板模式可以匹配有符号数。如果没有 &lt;code&gt;FX&lt;/code&gt; 选项，减号可能会模棱两可，并可能被解释为分隔符。解决此歧义的方法如下：如果模板字符串中 &lt;code&gt;TZH&lt;/code&gt; 之前的分隔符数目小于输入字符串中减号之前的分隔符数目，则负号将解释为 &lt;code&gt;TZH&lt;/code&gt; 的一部分。否则，减号被视为值之间的分隔符。例如， &lt;code&gt;to_timestamp('2000 -10', 'YYYY TZH')&lt;/code&gt; 匹配 &lt;code&gt;-10&lt;/code&gt; 到 &lt;code&gt;TZH&lt;/code&gt; ，但是 &lt;code&gt;to_timestamp('2000 -10', 'YYYY&amp;nbsp;&amp;nbsp;TZH')&lt;/code&gt; 匹配 &lt;code&gt;10&lt;/code&gt; 到 &lt;code&gt;TZH&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="975d4d7cc350f909c3d56a227d26009cd1f3f678" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;WITH&lt;/code&gt; query is referenced by writing its name, just as though the query's name were a table name. (In fact, the &lt;code&gt;WITH&lt;/code&gt; query hides any real table of the same name for the purposes of the primary query. If necessary, you can refer to a real table of the same name by schema-qualifying the table's name.) An alias can be provided in the same way as for a table.</source>
          <target state="translated">一个 &lt;code&gt;WITH&lt;/code&gt; 查询通过写它的名字，就好像查询的名字是一个表名引用。（实际上， &lt;code&gt;WITH&lt;/code&gt; 查询为主查询的目的隐藏了任何同名的真实表。如果有必要，可以通过模式限定表名来引用同名的实表。）别名可以是提供方式与表格相同。</target>
        </trans-unit>
        <trans-unit id="ff3f18d6b0d0d8ef8e261f092333e8ac1a83778d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;bloom&lt;/code&gt; index accepts the following parameters in its &lt;code&gt;WITH&lt;/code&gt; clause:</source>
          <target state="translated">甲 &lt;code&gt;bloom&lt;/code&gt; 索引接受在其下面的参数 &lt;code&gt;WITH&lt;/code&gt; 子句：</target>
        </trans-unit>
        <trans-unit id="4c2361c26a25ed37192ff6822eb9815e6a1bb350" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;default_expression&lt;/code&gt;, rather than being evaluated immediately when &lt;code&gt;xmltable&lt;/code&gt; is called, is evaluated each time a default is needed for the column. If the expression qualifies as stable or immutable, the repeat evaluation may be skipped. This means that you can usefully use volatile functions like &lt;code&gt;nextval&lt;/code&gt; in &lt;code&gt;default_expression&lt;/code&gt;.</source>
          <target state="translated">甲 &lt;code&gt;default_expression&lt;/code&gt; ，而不是当被立即计算 &lt;code&gt;xmltable&lt;/code&gt; 每个需要用于列的默认时间被调用时，被评估。如果表达式符合稳定或不变的条件，则可以跳过重复评估。这意味着您可以在 &lt;code&gt;default_expression&lt;/code&gt; 中有用地使用诸如 &lt;code&gt;nextval&lt;/code&gt; 之类的易失函数。</target>
        </trans-unit>
        <trans-unit id="6a8d6c448f4256c5739e1f342a948208b8ac9336" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;dict_xsyn&lt;/code&gt; dictionary accepts the following options:</source>
          <target state="translated">一个 &lt;code&gt;dict_xsyn&lt;/code&gt; 字典接受下面的选项：</target>
        </trans-unit>
        <trans-unit id="4731474e93af48b3b039ee433573b761b490ebba" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;frame_start&lt;/code&gt; of &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt; means that the frame starts with the first row of the partition, and similarly a &lt;code&gt;frame_end&lt;/code&gt; of &lt;code&gt;UNBOUNDED FOLLOWING&lt;/code&gt; means that the frame ends with the last row of the partition.</source>
          <target state="translated">甲 &lt;code&gt;frame_start&lt;/code&gt; 的 &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt; 意味着该帧与所述分区的第一行开始，类似地一 &lt;code&gt;frame_end&lt;/code&gt; 的 &lt;code&gt;UNBOUNDED FOLLOWING&lt;/code&gt; 装置，其与所述分区的最后行的帧结束。</target>
        </trans-unit>
        <trans-unit id="ba67bfc07bc1375b67a77983258edd014dff690f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;money&lt;/code&gt; value can be cast to &lt;code&gt;numeric&lt;/code&gt; without loss of precision. Conversion to other types could potentially lose precision, and must also be done in two stages:</source>
          <target state="translated">一个 &lt;code&gt;money&lt;/code&gt; 值可以转换为 &lt;code&gt;numeric&lt;/code&gt; ，且不丢失精度。转换为其他类型可能会失去精度，并且还必须分两个阶段完成：</target>
        </trans-unit>
        <trans-unit id="00e1eada317c8cafe63dee1a39dd2ab5032af82d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;pg_default_acl&lt;/code&gt; entry shows the initial privileges to be assigned to an object belonging to the indicated user. There are currently two types of entry: &amp;ldquo;global&amp;rdquo; entries with &lt;code&gt;defaclnamespace&lt;/code&gt; = 0, and &amp;ldquo;per-schema&amp;rdquo; entries that reference a particular schema. If a global entry is present then it &lt;em&gt;overrides&lt;/em&gt; the normal hard-wired default privileges for the object type. A per-schema entry, if present, represents privileges to be &lt;em&gt;added to&lt;/em&gt; the global or hard-wired default privileges.</source>
          <target state="translated">甲 &lt;code&gt;pg_default_acl&lt;/code&gt; 条目示出了初始的特权将被分配给属于所指示的用户的对象。当前有两种类型的条目：具有 &lt;code&gt;defaclnamespace&lt;/code&gt; = 0的&amp;ldquo;全局&amp;rdquo;条目和引用特定模式的&amp;ldquo;按模式&amp;rdquo;条目。如果存在全局条目，则它将&lt;em&gt;覆盖&lt;/em&gt;对象类型的常规硬连线默认特权。每个模式条目（如果存在）表示要&lt;em&gt;添加到&lt;/em&gt;全局或硬连线默认权限中的权限。</target>
        </trans-unit>
        <trans-unit id="1cb2939b4b6d4ddce66b3a2e4882d5e2fd0717d0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;pg_ident.conf&lt;/code&gt; file that could be used in conjunction with the &lt;code&gt;pg_hba.conf&lt;/code&gt; file in &lt;a href=&quot;auth-pg-hba-conf#EXAMPLE-PG-HBA.CONF&quot;&gt;Example 20.1&lt;/a&gt; is shown in &lt;a href=&quot;auth-username-maps#EXAMPLE-PG-IDENT.CONF&quot;&gt;Example 20.2&lt;/a&gt;. In this example, anyone logged in to a machine on the 192.168 network that does not have the operating system user name &lt;code&gt;bryanh&lt;/code&gt;, &lt;code&gt;ann&lt;/code&gt;, or &lt;code&gt;robert&lt;/code&gt; would not be granted access. Unix user &lt;code&gt;robert&lt;/code&gt; would only be allowed access when he tries to connect as PostgreSQL user &lt;code&gt;bob&lt;/code&gt;, not as &lt;code&gt;robert&lt;/code&gt; or anyone else. &lt;code&gt;ann&lt;/code&gt; would only be allowed to connect as &lt;code&gt;ann&lt;/code&gt;. User &lt;code&gt;bryanh&lt;/code&gt; would be allowed to connect as either &lt;code&gt;bryanh&lt;/code&gt; or as &lt;code&gt;guest1&lt;/code&gt;.</source>
          <target state="translated">甲 &lt;code&gt;pg_ident.conf&lt;/code&gt; ，可以在与该结合使用文件 &lt;code&gt;pg_hba.conf&lt;/code&gt; 在文件&lt;a href=&quot;auth-pg-hba-conf#EXAMPLE-PG-HBA.CONF&quot;&gt;实施例20.1&lt;/a&gt;中示出了&lt;a href=&quot;auth-username-maps#EXAMPLE-PG-IDENT.CONF&quot;&gt;实施例20.2&lt;/a&gt;。在此示例中，任何登录到192.168网络上没有操作系统用户名 &lt;code&gt;bryanh&lt;/code&gt; ， &lt;code&gt;ann&lt;/code&gt; 或 &lt;code&gt;robert&lt;/code&gt; 的计算机的人都不会被授予访问权限。仅当Unix用户 &lt;code&gt;robert&lt;/code&gt; 尝试以PostgreSQL用户 &lt;code&gt;bob&lt;/code&gt; 身份而不是 &lt;code&gt;robert&lt;/code&gt; 或其他任何人进行连接时，才被允许访问。 &lt;code&gt;ann&lt;/code&gt; 只允许以 &lt;code&gt;ann&lt;/code&gt; 身份连接。用户 &lt;code&gt;bryanh&lt;/code&gt; 将被允许​​以 &lt;code&gt;bryanh&lt;/code&gt; 或 &lt;code&gt;guest1&lt;/code&gt; 的身份进行连接。</target>
        </trans-unit>
        <trans-unit id="421151d14aecca0c09fe097c61a7a69cad0ef7d4" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;sort_expression&lt;/code&gt; can also be the column label or number of an output column, as in:</source>
          <target state="translated">甲 &lt;code&gt;sort_expression&lt;/code&gt; 也可以是列标签或编号输出列的，如下所示：</target>
        </trans-unit>
        <trans-unit id="2b23f0024d2472dff4bba030a8daa989f120d9ef" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;tsquery&lt;/code&gt; value stores lexemes that are to be searched for, and can combine them using the Boolean operators &lt;code&gt;&amp;amp;&lt;/code&gt; (AND), &lt;code&gt;|&lt;/code&gt; (OR), and &lt;code&gt;!&lt;/code&gt; (NOT), as well as the phrase search operator &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; (FOLLOWED BY). There is also a variant &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; of the FOLLOWED BY operator, where &lt;code&gt;N&lt;/code&gt; is an integer constant that specifies the distance between the two lexemes being searched for. &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; is equivalent to &lt;code&gt;&amp;lt;1&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">一个 &lt;code&gt;tsquery&lt;/code&gt; 要搜索价值储存语意是对，并且可以使用布尔运算符将它们组合 &lt;code&gt;&amp;amp;&lt;/code&gt; （AND）， &lt;code&gt;|&lt;/code&gt; （OR），和 &lt;code&gt;!&lt;/code&gt; （NOT），以及词组搜索运算符 &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; （FOLLOWED BY）。FOLLOWED BY运算符还有一个变体 &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; ，其中 &lt;code&gt;N&lt;/code&gt; 是一个整数常量，它指定要搜索的两个词素之间的距离。 &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; 等效于 &lt;code&gt;&amp;lt;1&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1488cfe9583a001f3966c381b957f6eda3c9c49c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;tsvector&lt;/code&gt; value is a sorted list of distinct &lt;em&gt;lexemes&lt;/em&gt;, which are words that have been &lt;em&gt;normalized&lt;/em&gt; to merge different variants of the same word (see &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt; for details). Sorting and duplicate-elimination are done automatically during input, as shown in this example:</source>
          <target state="translated">一 &lt;code&gt;tsvector&lt;/code&gt; 值是不同的排序列表&lt;em&gt;语意&lt;/em&gt;，这是已被字&lt;em&gt;归&lt;/em&gt;到合并同一个词（见的不同变体&lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;第12章&lt;/a&gt;了解详细信息）。输入期间将自动完成排序和重复消除，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="558bdfda3afcef5f29f3f2e8969b74e0c735aa26" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;tsvector&lt;/code&gt; value is a sorted list of distinct &lt;em&gt;lexemes&lt;/em&gt;, which are words that have been &lt;em&gt;normalized&lt;/em&gt; to merge different variants of the same word (see &lt;a href=&quot;https://www.postgresql.org/docs/13/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt; for details). Sorting and duplicate-elimination are done automatically during input, as shown in this example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72b056d2deaf1866d999d56f9aac903ec6223482" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;zone_abbreviation&lt;/code&gt; is just the abbreviation being defined. An &lt;code&gt;offset&lt;/code&gt; is an integer giving the equivalent offset in seconds from UTC, positive being east from Greenwich and negative being west. For example, -18000 would be five hours west of Greenwich, or North American east coast standard time. &lt;code&gt;D&lt;/code&gt; indicates that the zone name represents local daylight-savings time rather than standard time.</source>
          <target state="translated">一个 &lt;code&gt;zone_abbreviation&lt;/code&gt; 只是被定义的缩写。一个 &lt;code&gt;offset&lt;/code&gt; 是一个整数，相当于从UTC，格林威治积极福祉东部和否定时向西偏移秒。例如，-18000将位于格林威治以西五个小时，即北美东海岸标准时间。 &lt;code&gt;D&lt;/code&gt; 表示区域名称代表本地夏令时而不是标准时间。</target>
        </trans-unit>
        <trans-unit id="f4943bcbca867f42994cb13fee08c8f711efae46" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;back reference&lt;/em&gt; (&lt;code&gt;\&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;) matches the same string matched by the previous parenthesized subexpression specified by the number &lt;code&gt;n&lt;/code&gt; (see &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-BACKREF-TABLE&quot;&gt;Table 9.22&lt;/a&gt;). For example, &lt;code&gt;([bc])\1&lt;/code&gt; matches &lt;code&gt;bb&lt;/code&gt; or &lt;code&gt;cc&lt;/code&gt; but not &lt;code&gt;bc&lt;/code&gt; or &lt;code&gt;cb&lt;/code&gt;. The subexpression must entirely precede the back reference in the RE. Subexpressions are numbered in the order of their leading parentheses. Non-capturing parentheses do not define subexpressions.</source>
          <target state="translated">甲&lt;em&gt;回参考&lt;/em&gt;（ &lt;code&gt;\&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; ）由数中指定的上括号的子表达式匹配的相同的字符串相匹配 &lt;code&gt;n&lt;/code&gt; （见&lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-BACKREF-TABLE&quot;&gt;表9.22&lt;/a&gt;）。例如， &lt;code&gt;([bc])\1&lt;/code&gt; 匹配 &lt;code&gt;bb&lt;/code&gt; 或 &lt;code&gt;cc&lt;/code&gt; ,但不匹配 &lt;code&gt;bc&lt;/code&gt; 或 &lt;code&gt;cb&lt;/code&gt; 。子表达式必须完全在RE中的反向引用之前。子表达式按其前导括号的顺序编号。非捕获括号不定义子表达式。</target>
        </trans-unit>
        <trans-unit id="0a817aa5725f2f76fa3ba34527c18e8ded1f121f" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;back reference&lt;/em&gt; (&lt;code&gt;\&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;) matches the same string matched by the previous parenthesized subexpression specified by the number &lt;code&gt;n&lt;/code&gt; (see &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-BACKREF-TABLE&quot;&gt;Table 9.23&lt;/a&gt;). For example, &lt;code&gt;([bc])\1&lt;/code&gt; matches &lt;code&gt;bb&lt;/code&gt; or &lt;code&gt;cc&lt;/code&gt; but not &lt;code&gt;bc&lt;/code&gt; or &lt;code&gt;cb&lt;/code&gt;. The subexpression must entirely precede the back reference in the RE. Subexpressions are numbered in the order of their leading parentheses. Non-capturing parentheses do not define subexpressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6718ca8fb4d919393e897bdec5fb4459615fdc4d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;bracket expression&lt;/em&gt; is a list of characters enclosed in &lt;code&gt;[]&lt;/code&gt;. It normally matches any single character from the list (but see below). If the list begins with &lt;code&gt;^&lt;/code&gt;, it matches any single character &lt;em&gt;not&lt;/em&gt; from the rest of the list. If two characters in the list are separated by &lt;code&gt;-&lt;/code&gt;, this is shorthand for the full range of characters between those two (inclusive) in the collating sequence, e.g., &lt;code&gt;[0-9]&lt;/code&gt; in ASCII matches any decimal digit. It is illegal for two ranges to share an endpoint, e.g., &lt;code&gt;a-c-e&lt;/code&gt;. Ranges are very collating-sequence-dependent, so portable programs should avoid relying on them.</source>
          <target state="translated">方&lt;em&gt;括号表达式&lt;/em&gt;是 &lt;code&gt;[]&lt;/code&gt; 中包含的字符列表。它通常与列表中的任何单个字符匹配（但请参见下文）。如果列表开头 &lt;code&gt;^&lt;/code&gt; ，它匹配任何单个字符&lt;em&gt;不是&lt;/em&gt;从列表的其余部分。如果列表中的两个字符用 &lt;code&gt;-&lt;/code&gt; 分隔，则这是整理序列中这两个字符之间（包括两个字符）的全部字符的简写形式，例如ASCII中的 &lt;code&gt;[0-9]&lt;/code&gt; 匹配任何十进制数字。两个范围共享一个端点是不合法的，例如 &lt;code&gt;a-c-e&lt;/code&gt; 。范围与排序顺序非常相关，因此可移植程序应避免依赖它们。</target>
        </trans-unit>
        <trans-unit id="e492c903d1ba7fa2a18a8ea616f7ebd7783cffa9" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;composite type&lt;/em&gt; represents the structure of a row or record; it is essentially just a list of field names and their data types. PostgreSQL allows composite types to be used in many of the same ways that simple types can be used. For example, a column of a table can be declared to be of a composite type.</source>
          <target state="translated">甲&lt;em&gt;复合类型&lt;/em&gt;表示一个行或记录的结构; 它实际上只是字段名称及其数据类型的列表。PostgreSQL允许复合类型的使用方式与简单类型的使用方式相同。例如，表的一列可以声明为复合类型。</target>
        </trans-unit>
        <trans-unit id="6e860f367bba9069717fd9b941470c654d2b4f8d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;constraint escape&lt;/em&gt; is a constraint, matching the empty string if specific conditions are met, written as an escape. They are shown in &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-ESCAPES-TABLE&quot;&gt;Table 9.21&lt;/a&gt;.</source>
          <target state="translated">一个&lt;em&gt;约束逃逸&lt;/em&gt;是一个约束，如果满足特定条件时，写成逃避空字符串匹配。它们在&lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-ESCAPES-TABLE&quot;&gt;表9.21&lt;/a&gt;中显示。</target>
        </trans-unit>
        <trans-unit id="1d0f2ee8729573804e315b4c91c82a2c28f8ca2d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;constraint escape&lt;/em&gt; is a constraint, matching the empty string if specific conditions are met, written as an escape. They are shown in &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-ESCAPES-TABLE&quot;&gt;Table 9.22&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39ce7ea4252d54e37a3de7de04c14f271d76b823" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;constraint&lt;/em&gt; matches an empty string, but matches only when specific conditions are met. A constraint can be used where an atom could be used, except it cannot be followed by a quantifier. The simple constraints are shown in &lt;a href=&quot;functions-matching#POSIX-CONSTRAINTS-TABLE&quot;&gt;Table 9.18&lt;/a&gt;; some more constraints are described later.</source>
          <target state="translated">一个&lt;em&gt;约束&lt;/em&gt;一个空字符串匹配，但只有在满足特定条件相匹配。可以在可以使用原子的情况下使用约束，但不能在其后跟随量词。&lt;a href=&quot;functions-matching#POSIX-CONSTRAINTS-TABLE&quot;&gt;表9.18给出了&lt;/a&gt;简单的约束条件；稍后将描述更多约束。</target>
        </trans-unit>
        <trans-unit id="41327cfa5680423eea0edd7f46f2cf61b64b967b" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;constraint&lt;/em&gt; matches an empty string, but matches only when specific conditions are met. A constraint can be used where an atom could be used, except it cannot be followed by a quantifier. The simple constraints are shown in &lt;a href=&quot;functions-matching#POSIX-CONSTRAINTS-TABLE&quot;&gt;Table 9.19&lt;/a&gt;; some more constraints are described later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82adef88e441ec735dafa62739629a93a7d0b236" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;document&lt;/em&gt; is the unit of searching in a full text search system; for example, a magazine article or email message. The text search engine must be able to parse documents and store associations of lexemes (key words) with their parent document. Later, these associations are used to search for documents that contain query words.</source>
          <target state="translated">一个&lt;em&gt;文档&lt;/em&gt;是全文搜索系统搜索的单位; 例如，杂志文章或电子邮件。文本搜索引擎必须能够解析文档并存储词素（关键字）与其父文档的关联。以后，这些关联用于搜索包含查询词的文档。</target>
        </trans-unit>
        <trans-unit id="d539733e585980e704da973d01ffd68041e9bbe5" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;domain&lt;/em&gt; is a user-defined data type that is based on another &lt;em&gt;underlying type&lt;/em&gt;. Optionally, it can have constraints that restrict its valid values to a subset of what the underlying type would allow. Otherwise it behaves like the underlying type &amp;mdash; for example, any operator or function that can be applied to the underlying type will work on the domain type. The underlying type can be any built-in or user-defined base type, enum type, array type, composite type, range type, or another domain.</source>
          <target state="translated">甲&lt;em&gt;域&lt;/em&gt;是基于另一用户定义的数据类型&lt;em&gt;基础类型&lt;/em&gt;。可选地，它可以具有将其有效值限制为基础类型所允许的子集的约束。否则，它的行为类似于基础类型-例如，可以应用于基础类型的任何运算符或函数都将在域类型上工作。基础类型可以是任何内置或用户定义的基本类型，枚举类型，数组类型，复合类型，范围类型或其他域。</target>
        </trans-unit>
        <trans-unit id="c13def52e60f456d21c22d940b5598ad3aba92f3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;label path&lt;/em&gt; is a sequence of zero or more labels separated by dots, for example &lt;code&gt;L1.L2.L3&lt;/code&gt;, representing a path from the root of a hierarchical tree to a particular node. The length of a label path cannot exceed 65535 labels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e800c3197134211f2433e1a5e7b9939eb18274d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;label path&lt;/em&gt; is a sequence of zero or more labels separated by dots, for example &lt;code&gt;L1.L2.L3&lt;/code&gt;, representing a path from the root of a hierarchical tree to a particular node. The length of a label path must be less than 65kB, but keeping it under 2kB is preferable.</source>
          <target state="translated">甲&lt;em&gt;标签路径&lt;/em&gt;是零个或多个标签的序列由点分开，例如 &lt;code&gt;L1.L2.L3&lt;/code&gt; ，表示从分级树的根到特定节点的路径。标签路径的长度必须小于65kB，但最好将其保持在2kB以下。</target>
        </trans-unit>
        <trans-unit id="b787370839fd1f05141e9721dfa970b29907a8f6" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;label&lt;/em&gt; is a sequence of alphanumeric characters and underscores (for example, in C locale the characters &lt;code&gt;A-Za-z0-9_&lt;/code&gt; are allowed). Labels must be less than 256 bytes long.</source>
          <target state="translated">甲&lt;em&gt;标签&lt;/em&gt;是字母数字字符和下划线的序列（例如，在C语言环境中的字符 &lt;code&gt;A-Za-z0-9_&lt;/code&gt; 被允许）。标签必须小于256个字节长。</target>
        </trans-unit>
        <trans-unit id="599ffa36e210ea0adb3274124904be22bf966667" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;label&lt;/em&gt; is a sequence of alphanumeric characters and underscores (for example, in C locale the characters &lt;code&gt;A-Za-z0-9_&lt;/code&gt; are allowed). Labels must be less than 256 characters long.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53ce2d4eb014bcb723a4d1641a42edaac349db30" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;partial index&lt;/em&gt; is an index built over a subset of a table; the subset is defined by a conditional expression (called the &lt;em&gt;predicate&lt;/em&gt; of the partial index). The index contains entries only for those table rows that satisfy the predicate. Partial indexes are a specialized feature, but there are several situations in which they are useful.</source>
          <target state="translated">甲&lt;em&gt;部分索引&lt;/em&gt;是建立在一个表的子集的索引; 子集由条件表达式（称为部分索引的&lt;em&gt;谓词&lt;/em&gt;）定义。索引仅包含满足谓词的那些表行的条目。部分索引是一种特殊功能，但是在某些情况下它们很有用。</target>
        </trans-unit>
        <trans-unit id="17789413b2495753606375a6dc95de535511eb7a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;publication&lt;/em&gt; can be defined on any physical replication master. The node where a publication is defined is referred to as &lt;em&gt;publisher&lt;/em&gt;. A publication is a set of changes generated from a table or a group of tables, and might also be described as a change set or replication set. Each publication exists in only one database.</source>
          <target state="translated">甲&lt;em&gt;出版物&lt;/em&gt;可以在任何物理复制主定义。定义发布的节点称为&lt;em&gt;Publisher&lt;/em&gt;。发布是从一个表或一组表中生成的一组更改，也可以称为更改集或复制集。每个出版物仅存在于一个数据库中。</target>
        </trans-unit>
        <trans-unit id="bad628aabb95be8473994dba34d6d8a1a5004186" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;subscription&lt;/em&gt; is the downstream side of logical replication. The node where a subscription is defined is referred to as the &lt;em&gt;subscriber&lt;/em&gt;. A subscription defines the connection to another database and set of publications (one or more) to which it wants to subscribe.</source>
          <target state="translated">甲&lt;em&gt;订阅&lt;/em&gt;是逻辑复制的下游侧。定义预订的节点称为&lt;em&gt;订户&lt;/em&gt;。订阅定义到另一个数据库的连接以及它要订阅的一组出版物（一个或多个）。</target>
        </trans-unit>
        <trans-unit id="fa797af3b3f4fb2b2ac87bf17e6b99f0b17a6828" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;table expression&lt;/em&gt; computes a table. The table expression contains a &lt;code&gt;FROM&lt;/code&gt; clause that is optionally followed by &lt;code&gt;WHERE&lt;/code&gt;, &lt;code&gt;GROUP BY&lt;/code&gt;, and &lt;code&gt;HAVING&lt;/code&gt; clauses. Trivial table expressions simply refer to a table on disk, a so-called base table, but more complex expressions can be used to modify or combine base tables in various ways.</source>
          <target state="translated">甲&lt;em&gt;表表达式&lt;/em&gt;计算的表。该表表达式包含一个 &lt;code&gt;FROM&lt;/code&gt; 子句，可以选择在其后跟 &lt;code&gt;WHERE&lt;/code&gt; ， &lt;code&gt;GROUP BY&lt;/code&gt; 和 &lt;code&gt;HAVING&lt;/code&gt; 子句。琐碎的表表达式仅引用磁盘上的表，即所谓的基表，但更复杂的表达式可用于以各种方式修改或组合基表。</target>
        </trans-unit>
        <trans-unit id="2fefdb2ebab2d34cbdb1f2805b62ff07fe84dbed" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;window function call&lt;/em&gt; represents the application of an aggregate-like function over some portion of the rows selected by a query. Unlike non-window aggregate calls, this is not tied to grouping of the selected rows into a single output row &amp;mdash; each row remains separate in the query output. However the window function has access to all the rows that would be part of the current row's group according to the grouping specification (&lt;code&gt;PARTITION BY&lt;/code&gt; list) of the window function call. The syntax of a window function call is one of the following:</source>
          <target state="translated">甲&lt;em&gt;窗口函数调用&lt;/em&gt;表示的聚集体状的函数在由查询选择的行的一些部分中的应用。与非窗口聚合调用不同，这与将选定的行分组为单个输出行无关-在查询输出中，每一行都保持独立。但是，根据窗口函数调用的分组规范（ &lt;code&gt;PARTITION BY&lt;/code&gt; 列表），窗口函数可以访问将成为当前行组一部分的所有行。窗口函数调用的语法是以下之一：</target>
        </trans-unit>
        <trans-unit id="387625f992bcdbcffbfd0633e6c6c1c4ef1ce98e" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;window function&lt;/em&gt; performs a calculation across a set of table rows that are somehow related to the current row. This is comparable to the type of calculation that can be done with an aggregate function. However, window functions do not cause rows to become grouped into a single output row like non-window aggregate calls would. Instead, the rows retain their separate identities. Behind the scenes, the window function is able to access more than just the current row of the query result.</source>
          <target state="translated">甲&lt;em&gt;窗函数&lt;/em&gt;执行跨一组被以某种方式与当前行表中的行的计算。这相当于可以使用聚合函数完成的计算类型。但是，窗口函数不会像非窗口聚合调用那样将行分组为单个输出行。而是，行保留其各自的标识。在后台，窗口功能不仅可以访问查询结果的当前行，还可以访问更多内容。</target>
        </trans-unit>
        <trans-unit id="1e933097e94c165163135c375f18dec5b954f260" translate="yes" xml:space="preserve">
          <source>A Bloom filter is a space-efficient data structure that is used to test whether an element is a member of a set. In the case of an index access method, it allows fast exclusion of non-matching tuples via signatures whose size is determined at index creation.</source>
          <target state="translated">布卢姆过滤器是一种节省空间的数据结构,用于测试一个元素是否是集合的成员。在索引访问方法的情况下,它允许通过签名快速排除非匹配的元组,签名的大小在创建索引时确定。</target>
        </trans-unit>
        <trans-unit id="7133145b9a1efb20311e9b66542c47e33e3b0d76" translate="yes" xml:space="preserve">
          <source>A Boolean expression that determines whether the trigger function will actually be executed. If &lt;code&gt;WHEN&lt;/code&gt; is specified, the function will only be called if the &lt;code&gt;condition&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;. In &lt;code&gt;FOR EACH ROW&lt;/code&gt; triggers, the &lt;code&gt;WHEN&lt;/code&gt; condition can refer to columns of the old and/or new row values by writing &lt;code&gt;OLD.column_name&lt;/code&gt; or &lt;code&gt;NEW.column_name&lt;/code&gt; respectively. Of course, &lt;code&gt;INSERT&lt;/code&gt; triggers cannot refer to &lt;code&gt;OLD&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; triggers cannot refer to &lt;code&gt;NEW&lt;/code&gt;.</source>
          <target state="translated">一个布尔表达式，确定是否实际执行触发功能。如果指定了 &lt;code&gt;WHEN&lt;/code&gt; ，则仅在 &lt;code&gt;condition&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; 时才调用该函数。在 &lt;code&gt;FOR EACH ROW&lt;/code&gt; 触发器中， &lt;code&gt;WHEN&lt;/code&gt; 条件可以通过分别写入 &lt;code&gt;OLD.column_name&lt;/code&gt; 或 &lt;code&gt;NEW.column_name&lt;/code&gt; 来引用旧和/或新行值的列。当然， &lt;code&gt;INSERT&lt;/code&gt; 触发器不能引用 &lt;code&gt;OLD&lt;/code&gt; ,而 &lt;code&gt;DELETE&lt;/code&gt; 触发器不能引用 &lt;code&gt;NEW&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f47409118dd85d31d6d901173cd234a285d215a5" translate="yes" xml:space="preserve">
          <source>A GIN index stores a set of (key, posting list) pairs, where a &lt;em&gt;posting list&lt;/em&gt; is a set of row IDs in which the key occurs. The same row ID can appear in multiple posting lists, since an item can contain more than one key. Each key value is stored only once, so a GIN index is very compact for cases where the same key appears many times.</source>
          <target state="translated">GIN索引存储一组（键，发布列表）对，其中&lt;em&gt;发布列表&lt;/em&gt;是其中发生键的一组行ID。由于一个项目可以包含多个键，因此同一行ID可以出现在多个发布列表中。每个键值仅存储一次，因此对于同一键出现多次的情况，GIN索引非常紧凑。</target>
        </trans-unit>
        <trans-unit id="77d714896b96774f11d4e02f2da31afcf21ba9b4" translate="yes" xml:space="preserve">
          <source>A GiST index can be covering, i.e. use the &lt;code&gt;INCLUDE&lt;/code&gt; clause. Included columns can have data types without any GiST operator class. Included attributes will be stored uncompressed.</source>
          <target state="translated">GiST索引可以覆盖，即使用 &lt;code&gt;INCLUDE&lt;/code&gt; 子句。包含的列可以具有没有任何GiST运算符类的数据类型。包含的属性将以未压缩的形式存储。</target>
        </trans-unit>
        <trans-unit id="efe49aa51c5c238e7d22d9c414bebd48d8a0f792" translate="yes" xml:space="preserve">
          <source>A GiST index can be covering, i.e., use the &lt;code&gt;INCLUDE&lt;/code&gt; clause. Included columns can have data types without any GiST operator class. Included attributes will be stored uncompressed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="686f7293e72b8ed4fbfb23d13f584165b259d7cc" translate="yes" xml:space="preserve">
          <source>A GiST index is &lt;em&gt;lossy&lt;/em&gt;, meaning that the index might produce false matches, and it is necessary to check the actual table row to eliminate such false matches. (PostgreSQL does this automatically when needed.) GiST indexes are lossy because each document is represented in the index by a fixed-length signature. The signature is generated by hashing each word into a single bit in an n-bit string, with all these bits OR-ed together to produce an n-bit document signature. When two words hash to the same bit position there will be a false match. If all words in the query have matches (real or false) then the table row must be retrieved to see if the match is correct.</source>
          <target state="translated">GiST索引是&lt;em&gt;有损的&lt;/em&gt;，这意味着该索引可能会产生错误匹配，因此有必要检查实际的表行以消除此类错误匹配。 （PostgreSQL会在需要时自动执行此操作。）GiST索引是有损的，因为每个文档在索引中均以固定长度的签名表示。签名是通过将每个单词散列为n位字符串中的单个位而生成的，所有这些位进行&amp;ldquo;或&amp;rdquo;运算以生成n位文档签名。当两个单词散列到相同的位位置时，将出现错误匹配。如果查询中的所有单词都具有匹配项（真或假），则必须检索表行以查看匹配是否正确。</target>
        </trans-unit>
        <trans-unit id="19939a4fce59080d1c44ab5da5d78d68dd79f01b" translate="yes" xml:space="preserve">
          <source>A GiST index is &lt;em&gt;lossy&lt;/em&gt;, meaning that the index might produce false matches, and it is necessary to check the actual table row to eliminate such false matches. (PostgreSQL does this automatically when needed.) GiST indexes are lossy because each document is represented in the index by a fixed-length signature. The signature length in bytes is determined by the value of the optional integer parameter &lt;code&gt;siglen&lt;/code&gt;. The default signature length (when &lt;code&gt;siglen&lt;/code&gt; is not specified) is 124 bytes, the maximum signature length is 2024 bytes. The signature is generated by hashing each word into a single bit in an n-bit string, with all these bits OR-ed together to produce an n-bit document signature. When two words hash to the same bit position there will be a false match. If all words in the query have matches (real or false) then the table row must be retrieved to see if the match is correct. Longer signatures lead to a more precise search (scanning a smaller fraction of the index and fewer heap pages), at the cost of a larger index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4859377c56a7f4250fc7928febe82211450cf591" translate="yes" xml:space="preserve">
          <source>A GiST or SP-GiST index can accelerate queries involving these range operators: &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;&amp;lt;@&lt;/code&gt;, &lt;code&gt;@&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;-|-&lt;/code&gt;, &lt;code&gt;&amp;amp;&amp;lt;&lt;/code&gt;, and &lt;code&gt;&amp;amp;&amp;gt;&lt;/code&gt; (see &lt;a href=&quot;functions-range#RANGE-OPERATORS-TABLE&quot;&gt;Table 9.53&lt;/a&gt; for more information).</source>
          <target state="translated">GiST或SP-GiST索引可以加快涉及以下范围运算符的查询： &lt;code&gt;=&lt;/code&gt; ， &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; ， &lt;code&gt;&amp;lt;@&lt;/code&gt; ， &lt;code&gt;@&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;-|-&lt;/code&gt; ， &lt;code&gt;&amp;amp;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;amp;&amp;gt;&lt;/code&gt; （有关更多信息，请&lt;a href=&quot;functions-range#RANGE-OPERATORS-TABLE&quot;&gt;参见表9.53&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="5052f6936540d438e9a8f74a835240911affa68e" translate="yes" xml:space="preserve">
          <source>A JIT provider is loaded by dynamically loading the named shared library. The normal library search path is used to locate the library. To provide the required JIT provider callbacks and to indicate that the library is actually a JIT provider, it needs to provide a C function named &lt;code&gt;_PG_jit_provider_init&lt;/code&gt;. This function is passed a struct that needs to be filled with the callback function pointers for individual actions:</source>
          <target state="translated">通过动态加载命名的共享库来加载JIT提供程序。普通库搜索路径用于查找库。为了提供所需的JIT提供程序回调并指示该库实际上是JIT提供程序，它需要提供一个名为 &lt;code&gt;_PG_jit_provider_init&lt;/code&gt; 的C函数。此函数传递了一个结构，该结构需要用各个操作的回调函数指针填充：</target>
        </trans-unit>
        <trans-unit id="f096d1aabaef04fadfbfc0905d4cc493f3ce419f" translate="yes" xml:space="preserve">
          <source>A JSON null value is converted to a SQL null in all cases.</source>
          <target state="translated">JSON空值在所有情况下都会被转换为SQL空值。</target>
        </trans-unit>
        <trans-unit id="989ddd2bcb5960954e9e78a9c33e2efbc341a60e" translate="yes" xml:space="preserve">
          <source>A POSIX time zone specification has the form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90da68c2f0311ac40f24046e1fc30e1392f07dc8" translate="yes" xml:space="preserve">
          <source>A PostgreSQL database cluster contains one or more named databases. Roles and a few other object types are shared across the entire cluster. A client connection to the server can only access data in a single database, the one specified in the connection request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c15132a79db70b0e2b3cdb81cbd574f378944491" translate="yes" xml:space="preserve">
          <source>A PostgreSQL database cluster contains one or more named databases. Users and groups of users are shared across the entire cluster, but no other data is shared across databases. Any given client connection to the server can access only the data in a single database, the one specified in the connection request.</source>
          <target state="translated">一个PostgreSQL数据库集群包含一个或多个命名数据库。用户和用户组在整个集群中是共享的,但没有其他数据在数据库之间共享。任何给定的客户端连接到服务器,只能访问单一数据库中的数据,即连接请求中指定的数据库。</target>
        </trans-unit>
        <trans-unit id="9d33772a25bf4dd8b6ca0ae7bbd6d891d7102d71" translate="yes" xml:space="preserve">
          <source>A Snowball dictionary recognizes everything, whether or not it is able to simplify the word, so it should be placed at the end of the dictionary list. It is useless to have it before any other dictionary because a token will never pass through it to the next dictionary.</source>
          <target state="translated">雪球词典可以识别一切,不管它是否能够简化单词,所以它应该放在词典列表的最后。在其他字典之前有它是没有用的,因为一个令牌永远不会通过它进入下一个字典。</target>
        </trans-unit>
        <trans-unit id="72bd8340532262887cb9ae14aa89845f88df9078" translate="yes" xml:space="preserve">
          <source>A UUID is written as a sequence of lower-case hexadecimal digits, in several groups separated by hyphens, specifically a group of 8 digits followed by three groups of 4 digits followed by a group of 12 digits, for a total of 32 digits representing the 128 bits. An example of a UUID in this standard form is:</source>
          <target state="translated">UUID是由小写的十六进制数字组成的序列,分成几组,用连字符隔开,具体来说就是一组8位数字,然后是三组4位数字,接着是一组12位数字,总共32位数字代表128位。这种标准形式的UUID的一个例子是:。</target>
        </trans-unit>
        <trans-unit id="99a2ddaed13b4fa5189155f796c23cd0b85b2037" translate="yes" xml:space="preserve">
          <source>A bare &lt;code&gt;VALUES&lt;/code&gt; command:</source>
          <target state="translated">一条简单的 &lt;code&gt;VALUES&lt;/code&gt; 命令：</target>
        </trans-unit>
        <trans-unit id="d1c75bcd54e5d624eb16ebfaf6893165bef4c000" translate="yes" xml:space="preserve">
          <source>A better approach is to send the server's stderr output to some type of log rotation program. There is a built-in log rotation facility, which you can use by setting the configuration parameter &lt;code&gt;logging_collector&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;. The control parameters for this program are described in &lt;a href=&quot;runtime-config-logging#RUNTIME-CONFIG-LOGGING-WHERE&quot;&gt;Section 19.8.1&lt;/a&gt;. You can also use this approach to capture the log data in machine readable CSV (comma-separated values) format.</source>
          <target state="translated">更好的方法是将服务器的stderr输出发送到某种日志轮换程序。有一个内置的日志轮换工具，您可以通过在 &lt;code&gt;postgresql.conf&lt;/code&gt; 中将配置参数 &lt;code&gt;logging_collector&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 来使用。该程序的控制参数在&lt;a href=&quot;runtime-config-logging#RUNTIME-CONFIG-LOGGING-WHERE&quot;&gt;19.8.1节&lt;/a&gt;中介绍。您也可以使用这种方法以机器可读的CSV（逗号分隔值）格式捕获日志数据。</target>
        </trans-unit>
        <trans-unit id="ebc700417ea8062cbc2133cca40c230572b19efd" translate="yes" xml:space="preserve">
          <source>A better solution is this:</source>
          <target state="translated">更好的解决办法是这样的。</target>
        </trans-unit>
        <trans-unit id="6b5297ccac9bf406cd190777b88e363b006c5135" translate="yes" xml:space="preserve">
          <source>A binary string is a sequence of octets (or bytes). Binary strings are distinguished from character strings in two ways. First, binary strings specifically allow storing octets of value zero and other &amp;ldquo;non-printable&amp;rdquo; octets (usually, octets outside the decimal range 32 to 126). Character strings disallow zero octets, and also disallow any other octet values and sequences of octet values that are invalid according to the database's selected character set encoding. Second, operations on binary strings process the actual bytes, whereas the processing of character strings depends on locale settings. In short, binary strings are appropriate for storing data that the programmer thinks of as &amp;ldquo;raw bytes&amp;rdquo;, whereas character strings are appropriate for storing text.</source>
          <target state="translated">二进制字符串是八位字节（或字节）的序列。二进制字符串与字符串有两种区别。首先，二进制字符串专门允许存储值为零的八位位组和其他&amp;ldquo;不可打印的&amp;rdquo;八位位组（通常，十进制范围在32到126之间的八位位组）。字符串不允许使用零个八位位组，也不允许根据数据库的所选字符集编码而无效的任何其他八位位组值和八位位组值序列。其次，对二进制字符串的操作将处理实际的字节，而对字符串的处理则取决于语言环境设置。简而言之，二进制字符串适合于存储程序员认为是&amp;ldquo;原始字节&amp;rdquo;的数据，而字符串适合于存储文本。</target>
        </trans-unit>
        <trans-unit id="f9eaea7144ed65ec693bd5b0921667ccf802b3ac" translate="yes" xml:space="preserve">
          <source>A bit string value requires 1 byte for each group of 8 bits, plus 5 or 8 bytes overhead depending on the length of the string (but long values may be compressed or moved out-of-line, as explained in &lt;a href=&quot;datatype-character&quot;&gt;Section 8.3&lt;/a&gt; for character strings).</source>
          <target state="translated">一个位字符串值需要为每个8位组分配1个字节，再加上5或8个字节的开销，具体取决于字符串的长度（但是长的值可以压缩或移出行，如&lt;a href=&quot;datatype-character&quot;&gt;第8.3节中&lt;/a&gt;针对字符串所述） ）。</target>
        </trans-unit>
        <trans-unit id="731f4887b94e6b2c73ac23722091bfbfd646df88" translate="yes" xml:space="preserve">
          <source>A bracket expression &lt;code&gt;[...]&lt;/code&gt; specifies a character class, just as in POSIX regular expressions.</source>
          <target state="translated">方括号表达式 &lt;code&gt;[...]&lt;/code&gt; 指定的字符类，正如在POSIX正则表达式。</target>
        </trans-unit>
        <trans-unit id="accb592fdd062757612f62053a65bd65ef084e6d" translate="yes" xml:space="preserve">
          <source>A branch &amp;mdash; that is, an RE that has no top-level &lt;code&gt;|&lt;/code&gt; operator &amp;mdash; has the same greediness as the first quantified atom in it that has a greediness attribute.</source>
          <target state="translated">分支-即没有顶级 &lt;code&gt;|&lt;/code&gt; RE的RE 运算符-的贪婪与其中具有贪婪属性的第一个量化原子相同。</target>
        </trans-unit>
        <trans-unit id="1e93e1b748baa49f966038b6b801bfe31bf0d6a1" translate="yes" xml:space="preserve">
          <source>A branch is zero or more &lt;em&gt;quantified atoms&lt;/em&gt; or &lt;em&gt;constraints&lt;/em&gt;, concatenated. It matches a match for the first, followed by a match for the second, etc; an empty branch matches the empty string.</source>
          <target state="translated">分支是零个或多个串联的&lt;em&gt;量化原子&lt;/em&gt;或&lt;em&gt;约束&lt;/em&gt;。它匹配第一个匹配项，然后匹配第二个匹配项，依此类推；空分支匹配空字符串。</target>
        </trans-unit>
        <trans-unit id="2afc09a0dce3701a8ab0f81442e2374a5fdfb59a" translate="yes" xml:space="preserve">
          <source>A brief description of the parameter</source>
          <target state="translated">参数的简要说明</target>
        </trans-unit>
        <trans-unit id="531e171813e0ccf35b132f56c05f84b2c29d4251" translate="yes" xml:space="preserve">
          <source>A brief example of using the extension follows.</source>
          <target state="translated">下面是一个简单的使用扩展的例子。</target>
        </trans-unit>
        <trans-unit id="98ac6e951a01b0cf91beea39451931792f189912" translate="yes" xml:space="preserve">
          <source>A call &lt;code&gt;foo(10)&lt;/code&gt; will fail due to the ambiguity about which function should be called.</source>
          <target state="translated">由于不清楚应调用哪个函数，因此调用 &lt;code&gt;foo(10)&lt;/code&gt; 将失败。</target>
        </trans-unit>
        <trans-unit id="f4fd0d041b9fc5d4d7e64ce01b658bcce1a5ce19" translate="yes" xml:space="preserve">
          <source>A cascading standby sends not only WAL records received from the master but also those restored from the archive. So even if the replication connection in some upstream connection is terminated, streaming replication continues downstream for as long as new WAL records are available.</source>
          <target state="translated">级联待机不仅会发送从主站接收的WAL记录,还会发送从存档中恢复的记录。因此,即使某个上游连接中的复制连接被终止,只要有新的WAL记录可用,流式复制就会继续向下游发送。</target>
        </trans-unit>
        <trans-unit id="8b122451af392bc569e4090bc6ac8841aa8dd655" translate="yes" xml:space="preserve">
          <source>A case similar to filter conditions occurs with &amp;ldquo;lossy&amp;rdquo; index scans. For example, consider this search for polygons containing a specific point:</source>
          <target state="translated">&amp;ldquo;有损&amp;rdquo;索引扫描会发生类似于过滤条件的情况。例如，考虑以下搜索包含特定点的多边形：</target>
        </trans-unit>
        <trans-unit id="1483859001ccf841f9287a26876bc89e5ac64726" translate="yes" xml:space="preserve">
          <source>A cast to or from a domain type currently has no effect. Casting to or from a domain uses the casts associated with its underlying type.</source>
          <target state="translated">向域类型投掷或从域类型投掷目前没有效果。向域类型投掷或从域类型投掷使用与其基础类型相关联的投掷。</target>
        </trans-unit>
        <trans-unit id="ee03111f55078d640fb1865535e64f9dbf42c86a" translate="yes" xml:space="preserve">
          <source>A catalog row appearing in the initial data can be given a manually-assigned OID by writing an &lt;code&gt;oid =&amp;gt; nnnn&lt;/code&gt; metadata field. Furthermore, if an OID is assigned, a C macro for that OID can be created by writing an &lt;code&gt;oid_symbol =&amp;gt; name&lt;/code&gt; metadata field.</source>
          <target state="translated">通过写入 &lt;code&gt;oid =&amp;gt; nnnn&lt;/code&gt; 元数据字段，可以为出现在初始数据中的目录行提供手动分配的OID 。此外，如果分配了OID，则可以通过写入 &lt;code&gt;oid_symbol =&amp;gt; name&lt;/code&gt; 元数据字段来创建该OID的C宏。</target>
        </trans-unit>
        <trans-unit id="322518448cbeae5586806e5aaaa6dbbaaee252c8" translate="yes" xml:space="preserve">
          <source>A change in collation definitions can lead to corrupt indexes and other problems because the database system relies on stored objects having a certain sort order. Generally, this should be avoided, but it can happen in legitimate circumstances, such as when using &lt;code&gt;pg_upgrade&lt;/code&gt; to upgrade to server binaries linked with a newer version of ICU. When this happens, all objects depending on the collation should be rebuilt, for example, using &lt;code&gt;REINDEX&lt;/code&gt;. When that is done, the collation version can be refreshed using the command &lt;code&gt;ALTER COLLATION ... REFRESH VERSION&lt;/code&gt;. This will update the system catalog to record the current collator version and will make the warning go away. Note that this does not actually check whether all affected objects have been rebuilt correctly.</source>
          <target state="translated">归类定义的更改可能导致索引损坏和其他问题，因为数据库系统依赖于具有特定排序顺序的存储对象。通常，应该避免这种情况，但是在合理的情况下可能会发生，例如，使用 &lt;code&gt;pg_upgrade&lt;/code&gt; 升级到与较新版本的ICU链接的服务器二进制文件时。发生这种情况时，应根据排序规则重新构建所有对象，例如，使用 &lt;code&gt;REINDEX&lt;/code&gt; 。完成后，可以使用命令 &lt;code&gt;ALTER COLLATION ... REFRESH VERSION&lt;/code&gt; 刷新整理版本。这将更新系统目录以记录当前的整理程序版本，并使警告消失。请注意，这实际上并不检查是否所有受影响的对象都已正确重建。</target>
        </trans-unit>
        <trans-unit id="1f4a0879a18199d5f077ec0ff2e180faddd77063" translate="yes" xml:space="preserve">
          <source>A check constraint can also refer to several columns. Say you store a regular price and a discounted price, and you want to ensure that the discounted price is lower than the regular price:</source>
          <target state="translated">一个检查约束也可以指几个列。假设你存储了一个正常价格和一个折扣价格,你想确保折扣价格低于正常价格。</target>
        </trans-unit>
        <trans-unit id="5fb12afa94e8bc72660d65f619fede9431dd8e90" translate="yes" xml:space="preserve">
          <source>A check constraint is the most generic constraint type. It allows you to specify that the value in a certain column must satisfy a Boolean (truth-value) expression. For instance, to require positive product prices, you could use:</source>
          <target state="translated">检查约束是最通用的约束类型。它允许你指定某列中的值必须满足一个布尔(真值)表达式。例如,要要求产品价格为正值,您可以使用。</target>
        </trans-unit>
        <trans-unit id="d9805d0aa6ddc05f9bc01627befe8b2b8532cb45" translate="yes" xml:space="preserve">
          <source>A checkpoint is a point in the write-ahead log sequence at which all data files have been updated to reflect the information in the log. All data files will be flushed to disk. Refer to &lt;a href=&quot;wal-configuration&quot;&gt;Section 29.4&lt;/a&gt; for more details about what happens during a checkpoint.</source>
          <target state="translated">检查点是预写日志序列中的一点，所有数据文件都已更新为该点，以反映日志中的信息。所有数据文件将刷新到磁盘。有关在检查点期间发生的情况的更多详细信息，请参见&lt;a href=&quot;wal-configuration&quot;&gt;第29.4节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1a7d37eff183865f5e0589720c997a7480356b5f" translate="yes" xml:space="preserve">
          <source>A checkpoint is also the act of carrying out all the actions that are necessary to reach a checkpoint as defined above. This process is initiated when predefined conditions are met, such as a specified amount of time has passed, or a certain volume of records has been written; or it can be invoked by the user with the command &lt;code&gt;CHECKPOINT&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e10395ea67c519738bcfedd97fec8b7a98e77981" translate="yes" xml:space="preserve">
          <source>A clause of the form</source>
          <target state="translated">形式的条款</target>
        </trans-unit>
        <trans-unit id="d3d17faa1f9b24f81d090c43c22a75e3dfd2f4a5" translate="yes" xml:space="preserve">
          <source>A clause of the form &lt;code&gt;USING ( a, b, ... )&lt;/code&gt; is shorthand for &lt;code&gt;ON left_table.a = right_table.a AND left_table.b = right_table.b ...&lt;/code&gt;. Also, &lt;code&gt;USING&lt;/code&gt; implies that only one of each pair of equivalent columns will be included in the join output, not both.</source>
          <target state="translated">形式的条款 &lt;code&gt;USING ( a, b, ... )&lt;/code&gt; 是用于速记 &lt;code&gt;ON left_table.a = right_table.a AND left_table.b = right_table.b ...&lt;/code&gt; 。同样， &lt;code&gt;USING&lt;/code&gt; 表示联接输出中将仅包括每对等效列中的一对，而不是两者。</target>
        </trans-unit>
        <trans-unit id="2d0bfde758816d57c2adc33132d231587021c551" translate="yes" xml:space="preserve">
          <source>A closely related issue that affects planning time is collapsing of subqueries into their parent query. For example, consider:</source>
          <target state="translated">一个与此密切相关的影响规划时间的问题是将子查询折叠到其父查询中。例如,请考虑:</target>
        </trans-unit>
        <trans-unit id="ca452f51e79db640e56e4f9925aa0048af9d720d" translate="yes" xml:space="preserve">
          <source>A code defining the specific semantics of this dependency relationship; see text</source>
          <target state="translated">定义这种依赖关系的特定语义的代码;见文本。</target>
        </trans-unit>
        <trans-unit id="2ca8fb5b99b4bb7400bad4589e85235d85b8712a" translate="yes" xml:space="preserve">
          <source>A code defining the type of initial privilege of this object; see text</source>
          <target state="translated">定义该对象初始权限类型的代码;见文本。</target>
        </trans-unit>
        <trans-unit id="f7f2588e77da5e4feafd01ab8f374851f37bddfd" translate="yes" xml:space="preserve">
          <source>A code number indicating the kind of statistics stored in the &lt;code&gt;N&lt;/code&gt;th &amp;ldquo;slot&amp;rdquo; of the &lt;code&gt;pg_statistic&lt;/code&gt; row.</source>
          <target state="translated">一个代码号，指示存储在 &lt;code&gt;pg_statistic&lt;/code&gt; 行的第 &lt;code&gt;N&lt;/code&gt; 个&amp;ldquo;插槽&amp;rdquo;中的统计信息的类型。</target>
        </trans-unit>
        <trans-unit id="f423b7df9b88ecbf124e9ccab75b7d879dc4cca0" translate="yes" xml:space="preserve">
          <source>A collation expression</source>
          <target state="translated">一个整理的表达式</target>
        </trans-unit>
        <trans-unit id="9c0dd05ad8edff154a8e6c9ab1b14bf3a7460e7c" translate="yes" xml:space="preserve">
          <source>A collation is an SQL schema object that maps an SQL name to locales provided by libraries installed in the operating system. A collation definition has a &lt;em&gt;provider&lt;/em&gt; that specifies which library supplies the locale data. One standard provider name is &lt;code&gt;libc&lt;/code&gt;, which uses the locales provided by the operating system C library. These are the locales that most tools provided by the operating system use. Another provider is &lt;code&gt;icu&lt;/code&gt;, which uses the external ICU library. ICU locales can only be used if support for ICU was configured when PostgreSQL was built.</source>
          <target state="translated">排序规则是一个SQL模式对象，它将SQL名称映射到操作系统中安装的库提供的语言环境。归类定义具有一个&lt;em&gt;提供程序&lt;/em&gt;，该&lt;em&gt;提供程序&lt;/em&gt;指定哪个库提供区域设置数据。一个标准的提供程序名称是 &lt;code&gt;libc&lt;/code&gt; ，它使用操作系统C库提供的语言环境。这些是操作系统提供的大多数工具使用的语言环境。另一个提供程序是 &lt;code&gt;icu&lt;/code&gt; ，它使用外部ICU库。仅当在构建PostgreSQL时配置了对ICU的支持时，才能使用ICU语言环境。</target>
        </trans-unit>
        <trans-unit id="fd492bf97f6c0e26453468337ad19bf874c44502" translate="yes" xml:space="preserve">
          <source>A collation is either &lt;em&gt;deterministic&lt;/em&gt; or &lt;em&gt;nondeterministic&lt;/em&gt;. A deterministic collation uses deterministic comparisons, which means that it considers strings to be equal only if they consist of the same byte sequence. Nondeterministic comparison may determine strings to be equal even if they consist of different bytes. Typical situations include case-insensitive comparison, accent-insensitive comparison, as well as comparison of strings in different Unicode normal forms. It is up to the collation provider to actually implement such insensitive comparisons; the deterministic flag only determines whether ties are to be broken using bytewise comparison. See also &lt;a href=&quot;https://unicode.org/reports/tr10&quot;&gt;Unicode Technical Standard 10&lt;/a&gt; for more information on the terminology.</source>
          <target state="translated">排序规则是&lt;em&gt;确定性的&lt;/em&gt;或不&lt;em&gt;确定性的&lt;/em&gt;。确定性归类使用确定性比较，这意味着仅当字符串包含相同的字节序列时，它才认为字符串相等。非确定性比较可以确定字符串相等，即使它们由不同的字节组成。典型情况包括不区分大小写的比较，不区分重音的比较以及不同Unicode普通格式的字符串比较。归类提供者负责实际实现这种不敏感的比较。确定性标志仅使用字节比较确定是否要打破联系。有关该术语的更多信息，请参见&lt;a href=&quot;https://unicode.org/reports/tr10&quot;&gt;Unicode技术标准10&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="585469a73deac416236caf1e82c0a86b85aed8e2" translate="yes" xml:space="preserve">
          <source>A collation is either &lt;em&gt;deterministic&lt;/em&gt; or &lt;em&gt;nondeterministic&lt;/em&gt;. A deterministic collation uses deterministic comparisons, which means that it considers strings to be equal only if they consist of the same byte sequence. Nondeterministic comparison may determine strings to be equal even if they consist of different bytes. Typical situations include case-insensitive comparison, accent-insensitive comparison, as well as comparison of strings in different Unicode normal forms. It is up to the collation provider to actually implement such insensitive comparisons; the deterministic flag only determines whether ties are to be broken using bytewise comparison. See also &lt;a href=&quot;https://www.unicode.org/reports/tr10&quot;&gt;Unicode Technical Standard 10&lt;/a&gt; for more information on the terminology.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ebffe965dbfb2b402733d22f1b65d8768ef66b6" translate="yes" xml:space="preserve">
          <source>A collation object provided by &lt;code&gt;icu&lt;/code&gt; maps to a named collator provided by the ICU library. ICU does not support separate &amp;ldquo;collate&amp;rdquo; and &amp;ldquo;ctype&amp;rdquo; settings, so they are always the same. Also, ICU collations are independent of the encoding, so there is always only one ICU collation of a given name in a database.</source>
          <target state="translated">&lt;code&gt;icu&lt;/code&gt; 提供的排序规则对象映射到ICU库提供的命名排序规则。 ICU不支持单独的&amp;ldquo;整理&amp;rdquo;和&amp;ldquo; ctype&amp;rdquo;设置，因此它们始终相同。另外，ICU归类与编码无关，因此数据库中始终只有一个给定名称的ICU归类。</target>
        </trans-unit>
        <trans-unit id="67e66134fe986b5a1161f010ed997e5c29515718" translate="yes" xml:space="preserve">
          <source>A collation object provided by &lt;code&gt;libc&lt;/code&gt; maps to a combination of &lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt; settings, as accepted by the &lt;code&gt;setlocale()&lt;/code&gt; system library call. (As the name would suggest, the main purpose of a collation is to set &lt;code&gt;LC_COLLATE&lt;/code&gt;, which controls the sort order. But it is rarely necessary in practice to have an &lt;code&gt;LC_CTYPE&lt;/code&gt; setting that is different from &lt;code&gt;LC_COLLATE&lt;/code&gt;, so it is more convenient to collect these under one concept than to create another infrastructure for setting &lt;code&gt;LC_CTYPE&lt;/code&gt; per expression.) Also, a &lt;code&gt;libc&lt;/code&gt; collation is tied to a character set encoding (see &lt;a href=&quot;multibyte&quot;&gt;Section 23.3&lt;/a&gt;). The same collation name may exist for different encodings.</source>
          <target state="translated">&lt;code&gt;libc&lt;/code&gt; 提供的排序规则对象映射到 &lt;code&gt;setlocale()&lt;/code&gt; 系统库调用接受的 &lt;code&gt;LC_COLLATE&lt;/code&gt; 和 &lt;code&gt;LC_CTYPE&lt;/code&gt; 设置的组合。 （顾名思义，排序规则的主要目的是设置 &lt;code&gt;LC_COLLATE&lt;/code&gt; ，它控制排序顺序。但是在实践中，几乎没有必要使用不同于 &lt;code&gt;LC_COLLATE&lt;/code&gt; 的 &lt;code&gt;LC_CTYPE&lt;/code&gt; 设置，因此更方便地收集它们。而不是创建另一个用于为每个表达式设置 &lt;code&gt;LC_CTYPE&lt;/code&gt; 的基础结构。）此外， &lt;code&gt;libc&lt;/code&gt; 归类与字符集编码绑定（请参见&lt;a href=&quot;multibyte&quot;&gt;第23.3节）。&lt;/a&gt;）。对于不同的编码，可能存在相同的归类名称。</target>
        </trans-unit>
        <trans-unit id="dbd951bae781e6ca52e1aa0ea05378979fbabbd4" translate="yes" xml:space="preserve">
          <source>A collection of &lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;attributes&lt;/a&gt; in a fixed order. That order may be defined by the &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; (or other &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt;) where the tuple is contained, in which case the tuple is often called a &lt;em&gt;row&lt;/em&gt;. It may also be defined by the structure of a result set, in which case it is sometimes called a &lt;em&gt;record&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1d02a0633df2ef26eee92135725af62089ef8cb" translate="yes" xml:space="preserve">
          <source>A collection of &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;tables&lt;/a&gt; which describe the structure of all &lt;a href=&quot;glossary#GLOSSARY-SQL-OBJECT&quot;&gt;SQL objects&lt;/a&gt; of the instance. The system catalog resides in the schema &lt;code&gt;pg_catalog&lt;/code&gt;. These tables contain data in internal representation and are not typically considered useful for user examination; a number of user-friendlier &lt;a href=&quot;glossary#GLOSSARY-VIEW&quot;&gt;views&lt;/a&gt;, also in schema &lt;code&gt;pg_catalog&lt;/code&gt;, offer more convenient access to some of that information, while additional tables and views exist in schema &lt;code&gt;information_schema&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/13/information-schema.html&quot;&gt;Chapter 36&lt;/a&gt;) that expose some of the same and additional information as mandated by the &lt;a href=&quot;glossary#GLOSSARY-SQL-STANDARD&quot;&gt;SQL standard&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b63b111cc045d92308ab6bb0ff812b8d4531fcd" translate="yes" xml:space="preserve">
          <source>A collection of &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;tuples&lt;/a&gt; having a common data structure (the same number of &lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;attributes&lt;/a&gt;, in the same order, having the same name and type per position). A table is the most common form of &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; in PostgreSQL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85e16773e18c89eb8dbf7379d075c0ed8024236a" translate="yes" xml:space="preserve">
          <source>A collection of access privileges to the &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;instance&lt;/a&gt;. Roles are themselves a privilege that can be granted to other roles. This is often done for convenience or to ensure completeness when multiple &lt;a href=&quot;glossary#GLOSSARY-USER&quot;&gt;users&lt;/a&gt; need the same privileges.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81b0b809d9ea56c7639bef5d5e043207a72e42ff" translate="yes" xml:space="preserve">
          <source>A collection of databases and global SQL objects, and their common static and dynamic metadata. Sometimes referred to as a &lt;em&gt;cluster&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="243ac044c18a03ce7230410123ce180ce925ca61" translate="yes" xml:space="preserve">
          <source>A column can be assigned a default value. When a new row is created and no values are specified for some of the columns, those columns will be filled with their respective default values. A data manipulation command can also request explicitly that a column be set to its default value, without having to know what that value is. (Details about data manipulation commands are in &lt;a href=&quot;https://www.postgresql.org/docs/12/dml.html&quot;&gt;Chapter 6&lt;/a&gt;.)</source>
          <target state="translated">可以为列分配默认值。创建新行且未为某些列指定任何值时，这些列将使用其各自的默认值填充。数据操作命令还可以显式请求将列设置为其默认值，而不必知道该值是什么。（有关数据操作命令的详细信息，请参阅&lt;a href=&quot;https://www.postgresql.org/docs/12/dml.html&quot;&gt;第6章&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="728c6855211584a9477504f501bcae575c68f1dd" translate="yes" xml:space="preserve">
          <source>A column can be assigned a default value. When a new row is created and no values are specified for some of the columns, those columns will be filled with their respective default values. A data manipulation command can also request explicitly that a column be set to its default value, without having to know what that value is. (Details about data manipulation commands are in &lt;a href=&quot;https://www.postgresql.org/docs/13/dml.html&quot;&gt;Chapter 6&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a303981025d3fba2a49b2d8afa067fd02f82810b" translate="yes" xml:space="preserve">
          <source>A column can be referenced in the form:</source>
          <target state="translated">可以用以下形式引用一列。</target>
        </trans-unit>
        <trans-unit id="5e814702f2c68b1dd74624138092e2f2dac25d61" translate="yes" xml:space="preserve">
          <source>A column marked &lt;code&gt;FOR ORDINALITY&lt;/code&gt; will be populated with row numbers, starting with 1, in the order of nodes retrieved from the &lt;code&gt;row_expression&lt;/code&gt;'s result node-set. At most one column may be marked &lt;code&gt;FOR ORDINALITY&lt;/code&gt;.</source>
          <target state="translated">标记为 &lt;code&gt;FOR ORDINALITY&lt;/code&gt; 的列将按照从 &lt;code&gt;row_expression&lt;/code&gt; 的结果节点集中检索到的节点的顺序填充从1开始的行号。最多可以将一列标记为 &lt;code&gt;FOR ORDINALITY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12e0d49f86838408b879ad07c7e5231286011142" translate="yes" xml:space="preserve">
          <source>A column of a foreign table created using this wrapper can have the following options:</source>
          <target state="translated">使用这个包装器创建的外表的一列可以有以下选项。</target>
        </trans-unit>
        <trans-unit id="cc14af77e732b86dd798941f4129e5ffc051f3d7" translate="yes" xml:space="preserve">
          <source>A column reference</source>
          <target state="translated">一列参考</target>
        </trans-unit>
        <trans-unit id="43fad0f566cbecaf300364b0a3a7343007869d54" translate="yes" xml:space="preserve">
          <source>A column-specific trigger (one defined using the &lt;code&gt;UPDATE OF column_name&lt;/code&gt; syntax) will fire when any of its columns are listed as targets in the &lt;code&gt;UPDATE&lt;/code&gt; command's &lt;code&gt;SET&lt;/code&gt; list. It is possible for a column's value to change even when the trigger is not fired, because changes made to the row's contents by &lt;code&gt;BEFORE UPDATE&lt;/code&gt; triggers are not considered. Conversely, a command such as &lt;code&gt;UPDATE ... SET x = x ...&lt;/code&gt; will fire a trigger on column &lt;code&gt;x&lt;/code&gt;, even though the column's value did not change.</source>
          <target state="translated">当特定列的触发器（使用 &lt;code&gt;UPDATE OF column_name&lt;/code&gt; 语法定义的触发器）在 &lt;code&gt;UPDATE&lt;/code&gt; 命令的 &lt;code&gt;SET&lt;/code&gt; 列表中被列为目标时，将触发该触发器。即使不触发触发器，也可能会更改列的值，因为不会考虑通过 &lt;code&gt;BEFORE UPDATE&lt;/code&gt; 触发器对行的内容进行更改。相反，即使列的值未更改，诸如 &lt;code&gt;UPDATE ... SET x = x ...&lt;/code&gt; 类的命令也会在 &lt;code&gt;x&lt;/code&gt; 列上触发触发器。</target>
        </trans-unit>
        <trans-unit id="e7ce99ce6bf9fda66b89c10600a10dba3a88bd33" translate="yes" xml:space="preserve">
          <source>A combination of commands that must act as a single &lt;a href=&quot;glossary#GLOSSARY-ATOMIC&quot;&gt;atomic&lt;/a&gt; command: they all succeed or all fail as a single unit, and their effects are not visible to other &lt;a href=&quot;glossary#GLOSSARY-SESSION&quot;&gt;sessions&lt;/a&gt; until the transaction is complete, and possibly even later, depending on the isolation level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f697bbd81557d764888518e1af36278f9c8d3579" translate="yes" xml:space="preserve">
          <source>A combination of dynamic domain transition and trusted procedure enables an interesting use case that fits the typical process life-cycle of connection pooling software. Even if your connection pooling software is not allowed to run most of SQL commands, you can allow it to switch the security label of the client using the &lt;code&gt;sepgsql_setcon()&lt;/code&gt; function from within a trusted procedure; that should take some credential to authorize the request to switch the client label. After that, this session will have the privileges of the target user, rather than the connection pooler. The connection pooler can later revert the security label change by again using &lt;code&gt;sepgsql_setcon()&lt;/code&gt; with &lt;code&gt;NULL&lt;/code&gt; argument, again invoked from within a trusted procedure with appropriate permissions checks. The point here is that only the trusted procedure actually has permission to change the effective security label, and only does so when given proper credentials. Of course, for secure operation, the credential store (table, procedure definition, or whatever) must be protected from unauthorized access.</source>
          <target state="translated">动态域转换和受信任的过程的结合使一个有趣的用例适合了连接池软件的典型过程生命周期。即使不允许您的连接池软件运行大多数SQL命令，您也可以允许它使用来自可信任过程中的 &lt;code&gt;sepgsql_setcon()&lt;/code&gt; 函数来切换客户端的安全标签。应当使用一些凭据来授权请求​​切换客户端标签。此后，此会话将具有目标用户的特权，而不是连接池的特权。连接池程序以后可以再次使用 &lt;code&gt;sepgsql_setcon()&lt;/code&gt; 与 &lt;code&gt;NULL&lt;/code&gt; 来还原安全标签更改参数，再次通过具有适当权限检查的受信任过程内部调用。这里的要点是，只有可信过程实际上才有权更改有效的安全标签，并且只有在给定适当的凭据后才能这样做。当然，为了安全操作，必须保护凭据存储区（表，过程定义或其他内容）免受未经授权的访问。</target>
        </trans-unit>
        <trans-unit id="2911cc608e469494b5712a777002f2e21913d79f" translate="yes" xml:space="preserve">
          <source>A command to execute. In &lt;code&gt;COPY FROM&lt;/code&gt;, the input is read from standard output of the command, and in &lt;code&gt;COPY TO&lt;/code&gt;, the output is written to the standard input of the command.</source>
          <target state="translated">要执行的命令。在 &lt;code&gt;COPY FROM&lt;/code&gt; 中，从命令的标准输出中读取输入，而在 &lt;code&gt;COPY TO&lt;/code&gt; 中，将输出写入命令的标准输入中。</target>
        </trans-unit>
        <trans-unit id="b8b60faef517b04517cdc32cdeaec6d45d821a98" translate="yes" xml:space="preserve">
          <source>A command to prevent access to a named set of &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; objects for a named list of &lt;a href=&quot;glossary#GLOSSARY-ROLE&quot;&gt;roles&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="432b06e57f9235552442ece4a5144f1741f08cf9" translate="yes" xml:space="preserve">
          <source>A command to undo all of the operations performed since the beginning of a &lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;transaction&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfeede7bacbce2d25ad1c8afefcc0d73e7394ef6" translate="yes" xml:space="preserve">
          <source>A comment is a sequence of characters beginning with double dashes and extending to the end of the line, e.g.:</source>
          <target state="translated">注释是以双破折号开始并延伸到行尾的字符序列,例如:。</target>
        </trans-unit>
        <trans-unit id="3eb6cee486403a5e9f022d4d86b027a6b1d863bd" translate="yes" xml:space="preserve">
          <source>A comment is removed from the input stream before further syntax analysis and is effectively replaced by whitespace.</source>
          <target state="translated">在进一步的语法分析之前,输入流中的注释会被删除,并有效地被whitespace取代。</target>
        </trans-unit>
        <trans-unit id="fd4ff7f9082f219e362f6b80b3a0778be34303a7" translate="yes" xml:space="preserve">
          <source>A completely empty field value (no characters at all between the commas or parentheses) represents a NULL. To write a value that is an empty string rather than NULL, write &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">完全为空的字段值（逗号或括号之间完全没有字符）表示NULL。要写一个空字符串而不是NULL的值，请写 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc479538bc2519f6be7743a108e2d4369ba071e0" translate="yes" xml:space="preserve">
          <source>A computer on which PostgreSQL &lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;instances&lt;/a&gt; run. The term &lt;em&gt;server&lt;/em&gt; denotes real hardware, a container, or a &lt;em&gt;virtual machine&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="712b440e19e5b1db615da5ae01b27ee905115fec" translate="yes" xml:space="preserve">
          <source>A computer that communicates with other computers over a network. This is sometimes used as a synonym for &lt;a href=&quot;glossary#GLOSSARY-SERVER&quot;&gt;server&lt;/a&gt;. It is also used to refer to a computer where &lt;a href=&quot;glossary#GLOSSARY-CLIENT&quot;&gt;client processes&lt;/a&gt; run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b2c2b765e8d46a4effd9275029b3ac9ce35557f" translate="yes" xml:space="preserve">
          <source>A concept of non-existence that is a central tenet of relational database theory. It represents the absence of a definite value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db43da6a754b048f8c15b9fee6431ce49e646a6c" translate="yes" xml:space="preserve">
          <source>A conflict will produce an error and will stop the replication; it must be resolved manually by the user. Details about the conflict can be found in the subscriber's server log.</source>
          <target state="translated">冲突将产生一个错误,并将停止复制;它必须由用户手动解决。有关冲突的详细信息可以在用户的服务器日志中找到。</target>
        </trans-unit>
        <trans-unit id="6de61942e5889f7081d4c447f2d861f6661580c6" translate="yes" xml:space="preserve">
          <source>A connection from an application program to the PostgreSQL server has to be established. The application program transmits a query to the server and waits to receive the results sent back by the server.</source>
          <target state="translated">必须建立一个从应用程序到PostgreSQL服务器的连接。应用程序向服务器发送一个查询,并等待接收服务器发回的结果。</target>
        </trans-unit>
        <trans-unit id="ff27f94049d4acbe17b6492b665c173de57c0e06" translate="yes" xml:space="preserve">
          <source>A constant of an &lt;em&gt;arbitrary&lt;/em&gt; type can be entered using any one of the following notations:</source>
          <target state="translated">可以使用以下任何一种表示法输入&lt;em&gt;任意&lt;/em&gt;类型的常量：</target>
        </trans-unit>
        <trans-unit id="def2a00f2b728102b713698dbaec6bf7d1b1ba45" translate="yes" xml:space="preserve">
          <source>A constant or expression to compute and insert at the indicated place in the resulting table (set of rows). In a &lt;code&gt;VALUES&lt;/code&gt; list appearing at the top level of an &lt;code&gt;INSERT&lt;/code&gt;, an &lt;code&gt;expression&lt;/code&gt; can be replaced by &lt;code&gt;DEFAULT&lt;/code&gt; to indicate that the destination column's default value should be inserted. &lt;code&gt;DEFAULT&lt;/code&gt; cannot be used when &lt;code&gt;VALUES&lt;/code&gt; appears in other contexts.</source>
          <target state="translated">要计算并插入到结果表中指定位置（行集）的常量或表达式。在出现在 &lt;code&gt;INSERT&lt;/code&gt; 顶层的 &lt;code&gt;VALUES&lt;/code&gt; 列表中，可以将 &lt;code&gt;DEFAULT&lt;/code&gt; 替换为 &lt;code&gt;expression&lt;/code&gt; ，以指示应插入目标列的默认值。当 &lt;code&gt;VALUES&lt;/code&gt; 出现在其他上下文中时，不能使用 &lt;code&gt;DEFAULT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f51660594b80d9306c037e5807f00beb6e91d699" translate="yes" xml:space="preserve">
          <source>A constant or literal value</source>
          <target state="translated">一个常数或字面值</target>
        </trans-unit>
        <trans-unit id="cf8fda03118cc7add18d0baf25c70ed12492a1c1" translate="yes" xml:space="preserve">
          <source>A constraint marked with &lt;code&gt;NO INHERIT&lt;/code&gt; will not propagate to child tables.</source>
          <target state="translated">标有 &lt;code&gt;NO INHERIT&lt;/code&gt; 的约束将不会传播到子表。</target>
        </trans-unit>
        <trans-unit id="8913bbb8fb57baf6761a820445fb91f212ee581b" translate="yes" xml:space="preserve">
          <source>A convention often used is to write key words in upper case and names in lower case, e.g.:</source>
          <target state="translated">经常使用的惯例是将关键词写成大写,而将名称写成小写,例如:</target>
        </trans-unit>
        <trans-unit id="270045f32202a02af54823e311103963348c2e0e" translate="yes" xml:space="preserve">
          <source>A conversion of a &lt;a href=&quot;glossary#GLOSSARY-DATUM&quot;&gt;datum&lt;/a&gt; from its current data type to another data type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fee55ddb20eb8d0ea230a86a3979ff4c9211fbe9" translate="yes" xml:space="preserve">
          <source>A copy of &lt;code&gt;pg_type.typalign&lt;/code&gt; of this column's type</source>
          <target state="translated">此列类型的 &lt;code&gt;pg_type.typalign&lt;/code&gt; 的副本</target>
        </trans-unit>
        <trans-unit id="16520694e80b09447c7974353ea21a94aea9b85b" translate="yes" xml:space="preserve">
          <source>A copy of &lt;code&gt;pg_type.typbyval&lt;/code&gt; of this column's type</source>
          <target state="translated">此列类型的 &lt;code&gt;pg_type.typbyval&lt;/code&gt; 的副本</target>
        </trans-unit>
        <trans-unit id="469c374912ca15a938f750a67728c2d10a7ddd2a" translate="yes" xml:space="preserve">
          <source>A copy of &lt;code&gt;pg_type.typlen&lt;/code&gt; of this column's type</source>
          <target state="translated">此列类型的 &lt;code&gt;pg_type.typlen&lt;/code&gt; 的副本</target>
        </trans-unit>
        <trans-unit id="64372429a7f7ff378ebe32047bb948215d6fc9f3" translate="yes" xml:space="preserve">
          <source>A cursor has an associated position, which is used by &lt;code&gt;FETCH&lt;/code&gt;. The cursor position can be before the first row of the query result, on any particular row of the result, or after the last row of the result. When created, a cursor is positioned before the first row. After fetching some rows, the cursor is positioned on the row most recently retrieved. If &lt;code&gt;FETCH&lt;/code&gt; runs off the end of the available rows then the cursor is left positioned after the last row, or before the first row if fetching backward. &lt;code&gt;FETCH ALL&lt;/code&gt; or &lt;code&gt;FETCH BACKWARD ALL&lt;/code&gt; will always leave the cursor positioned after the last row or before the first row.</source>
          <target state="translated">游标具有关联的位置，该位置由 &lt;code&gt;FETCH&lt;/code&gt; 使用。光标位置可以在查询结果的第一行之前，结果的任何特定行上，或者在结果的最后一行之后。创建后，光标将位于第一行之前。在获取了一些行之后，光标将定位在最近检索到的行上。如果 &lt;code&gt;FETCH&lt;/code&gt; 从可用行的末尾开始运行，则光标将留在最后一行之后，或者如果向后取，则将光标放在第一行之前。 &lt;code&gt;FETCH ALL&lt;/code&gt; 或 &lt;code&gt;FETCH BACKWARD ALL&lt;/code&gt; 将始终使光标位于最后一行之后或第一行之前。</target>
        </trans-unit>
        <trans-unit id="ca84330d2df84d2fb3203c9d1abd5c728ed51c45" translate="yes" xml:space="preserve">
          <source>A custom-format dump is not a script for psql, but instead must be restored with pg_restore, for example:</source>
          <target state="translated">自定义格式的dump不是psql的脚本,而是必须用pg_restore来还原,例如。</target>
        </trans-unit>
        <trans-unit id="ac05a9e40c0d434aa68a1851fc9e7d6d26043953" translate="yes" xml:space="preserve">
          <source>A data type &lt;code&gt;tsvector&lt;/code&gt; is provided for storing preprocessed documents, along with a type &lt;code&gt;tsquery&lt;/code&gt; for representing processed queries (&lt;a href=&quot;datatype-textsearch&quot;&gt;Section 8.11&lt;/a&gt;). There are many functions and operators available for these data types (&lt;a href=&quot;functions-textsearch&quot;&gt;Section 9.13&lt;/a&gt;), the most important of which is the match operator &lt;code&gt;@@&lt;/code&gt;, which we introduce in &lt;a href=&quot;textsearch-intro#TEXTSEARCH-MATCHING&quot;&gt;Section 12.1.2&lt;/a&gt;. Full text searches can be accelerated using indexes (&lt;a href=&quot;textsearch-indexes&quot;&gt;Section 12.9&lt;/a&gt;).</source>
          <target state="translated">提供了用于存储预处理文档的数据类型 &lt;code&gt;tsvector&lt;/code&gt; 以及用于表示已处理查询的 &lt;code&gt;tsquery&lt;/code&gt; 类型（&lt;a href=&quot;datatype-textsearch&quot;&gt;第8.11节&lt;/a&gt;）。这些数据类型有很多功能和运算符（&lt;a href=&quot;functions-textsearch&quot;&gt;第9.13节&lt;/a&gt;），其中最重要的是匹配运算符 &lt;code&gt;@@&lt;/code&gt; ，我们将在&lt;a href=&quot;textsearch-intro#TEXTSEARCH-MATCHING&quot;&gt;第12.1.2节中&lt;/a&gt;介绍。使用索引可以加速全文搜索（&lt;a href=&quot;textsearch-indexes&quot;&gt;第12.9节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1c829ffd204fab8f2c9ec9a14aa40a4d117b945a" translate="yes" xml:space="preserve">
          <source>A data-only dump will still use &lt;code&gt;COPY&lt;/code&gt;, but it does not drop or recreate indexes, and it does not normally touch foreign keys. &lt;a href=&quot;#ftn.id-1.5.13.7.11.4.2&quot;&gt;&lt;sup id=&quot;id-1.5.13.7.11.4.2&quot;&gt;[13]&lt;/sup&gt;&lt;/a&gt; So when loading a data-only dump, it is up to you to drop and recreate indexes and foreign keys if you wish to use those techniques. It's still useful to increase &lt;code&gt;max_wal_size&lt;/code&gt; while loading the data, but don't bother increasing &lt;code&gt;maintenance_work_mem&lt;/code&gt;; rather, you'd do that while manually recreating indexes and foreign keys afterwards. And don't forget to &lt;code&gt;ANALYZE&lt;/code&gt; when you're done; see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Section 24.1.3&lt;/a&gt; and &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information.</source>
          <target state="translated">仅数据转储仍将使用 &lt;code&gt;COPY&lt;/code&gt; ，但是它不会删除或重新创建索引，并且通常不会触摸外键。&lt;a href=&quot;#ftn.id-1.5.13.7.11.4.2&quot;&gt;&lt;sup id=&quot;id-1.5.13.7.11.4.2&quot;&gt;[13]&lt;/sup&gt;&lt;/a&gt;因此，在加载仅数据转储时，如果您希望使用这些技术，则可以删除并重新创建索引和外键。在加载数据时增加 &lt;code&gt;max_wal_size&lt;/code&gt; 仍然很有用，但是不必费心增加 &lt;code&gt;maintenance_work_mem&lt;/code&gt; ；相反，您会在之后手动重新创建索引和外键的同时这样做。完成后，别忘了进行 &lt;code&gt;ANALYZE&lt;/code&gt; ；有关更多信息，请参见&lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;第24.1.3节&lt;/a&gt;和&lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;第24.1.6节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a7efff5b8bc220045364eeb6371d5a7d0adfbf4d" translate="yes" xml:space="preserve">
          <source>A database contains one or more named &lt;em&gt;schemas&lt;/em&gt;, which in turn contain tables. Schemas also contain other kinds of named objects, including data types, functions, and operators. The same object name can be used in different schemas without conflict; for example, both &lt;code&gt;schema1&lt;/code&gt; and &lt;code&gt;myschema&lt;/code&gt; can contain tables named &lt;code&gt;mytable&lt;/code&gt;. Unlike databases, schemas are not rigidly separated: a user can access objects in any of the schemas in the database they are connected to, if they have privileges to do so.</source>
          <target state="translated">数据库包含一个或多个命名&lt;em&gt;模式&lt;/em&gt;，而这些&lt;em&gt;模式&lt;/em&gt;又包含表。模式还包含其他种类的命名对象，包括数据类型，函数和运算符。相同的对象名称可以在不同的模式中使用，而不会发生冲突。例如， &lt;code&gt;schema1&lt;/code&gt; 和 &lt;code&gt;myschema&lt;/code&gt; 都可以包含名为 &lt;code&gt;mytable&lt;/code&gt; 的表。与数据库不同，架构不是严格分开的：用户可以访问与其连接的数据库中任何架构中的对象（如果有权限）。</target>
        </trans-unit>
        <trans-unit id="3ebb2f86492fa3a77fa0db26d0c30c86dff05744" translate="yes" xml:space="preserve">
          <source>A database is a named collection of SQL objects (&amp;ldquo;database objects&amp;rdquo;). Generally, every database object (tables, functions, etc.) belongs to one and only one database. (However there are a few system catalogs, for example &lt;code&gt;pg_database&lt;/code&gt;, that belong to a whole cluster and are accessible from each database within the cluster.) More accurately, a database is a collection of schemas and the schemas contain the tables, functions, etc. So the full hierarchy is: server, database, schema, table (or some other kind of object, such as a function).</source>
          <target state="translated">数据库是SQL对象（&amp;ldquo;数据库对象&amp;rdquo;）的命名集合。通常，每个数据库对象（表，函数等）都属于一个并且只有一个数据库。 （但是，有一些系统目录（例如 &lt;code&gt;pg_database&lt;/code&gt; ）属于整个集群，并且可以从集群中的每个数据库进行访问。）更准确地说，数据库是模式的集合，并且模式包含表，函数等。因此，完整的层次结构是：服务器，数据库，架构，表（或其他某种对象，例如函数）。</target>
        </trans-unit>
        <trans-unit id="c7d2c9abe130147ea353b9080d406b7f3bf3c1ff" translate="yes" xml:space="preserve">
          <source>A database role can have a number of attributes that define its privileges and interact with the client authentication system.</source>
          <target state="translated">一个数据库角色可以有很多属性,这些属性定义了它的权限,并与客户端认证系统进行交互。</target>
        </trans-unit>
        <trans-unit id="a3022f04bd927ba344f6e517eda753ede33a9966" translate="yes" xml:space="preserve">
          <source>A database superuser bypasses all permission checks, except the right to log in. This is a dangerous privilege and should not be used carelessly; it is best to do most of your work as a role that is not a superuser. To create a new database superuser, use &lt;code&gt;CREATE ROLE name SUPERUSER&lt;/code&gt;. You must do this as a role that is already a superuser.</source>
          <target state="translated">数据库超级用户会跳过所有权限检查（登录权除外）。这是一种危险的特权，不应粗心使用；否则，将被禁用。最好以不是超级用户的角色来完成大部分工作。要创建新的数据库超级用户，请使用 &lt;code&gt;CREATE ROLE name SUPERUSER&lt;/code&gt; 。您必须以已经是超级用户的角色来执行此操作。</target>
        </trans-unit>
        <trans-unit id="a652bebb73f376f1df0ca8598fee059cf76fc365" translate="yes" xml:space="preserve">
          <source>A default value can be specified, in case a user wants columns of the data type to default to something other than the null value. Specify the default with the &lt;code&gt;DEFAULT&lt;/code&gt; key word. (Such a default can be overridden by an explicit &lt;code&gt;DEFAULT&lt;/code&gt; clause attached to a particular column.)</source>
          <target state="translated">如果用户希望数据类型的列默认为空值以外的其他值，则可以指定一个默认值。使用 &lt;code&gt;DEFAULT&lt;/code&gt; 关键字指定默认值。（这种默认值可以由附加到特定列的显式 &lt;code&gt;DEFAULT&lt;/code&gt; 子句覆盖。）</target>
        </trans-unit>
        <trans-unit id="260245ca0f51394bde912da70513f69a2611aadc" translate="yes" xml:space="preserve">
          <source>A defined set of instructions stored in the database system that can be invoked for execution. A routine can be written in a variety of programming languages. Routines can be &lt;a href=&quot;glossary#GLOSSARY-FUNCTION&quot;&gt;functions&lt;/a&gt; (including set-returning functions and &lt;a href=&quot;glossary#GLOSSARY-TRIGGER&quot;&gt;trigger functions&lt;/a&gt;), &lt;a href=&quot;glossary#GLOSSARY-AGGREGATE&quot;&gt;aggregate functions&lt;/a&gt;, and &lt;a href=&quot;glossary#GLOSSARY-PROCEDURE&quot;&gt;procedures&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c1f42cac75263776f033d6ed34f1fbc16bad9be" translate="yes" xml:space="preserve">
          <source>A delay of this many seconds occurs when a new server process is started, after it conducts the authentication procedure. This is intended to give an opportunity to attach to the server process with a debugger.</source>
          <target state="translated">当一个新的服务器进程被启动时,在它进行认证程序之后,会有这么多秒的延迟。这样做的目的是为了提供一个用调试器连接服务器进程的机会。</target>
        </trans-unit>
        <trans-unit id="cd25a0e450014180419d77ce403bad9e20cb5564" translate="yes" xml:space="preserve">
          <source>A detailed description of bison or the grammar rules given in &lt;code&gt;gram.y&lt;/code&gt; would be beyond the scope of this paper. There are many books and documents dealing with flex and bison. You should be familiar with bison before you start to study the grammar given in &lt;code&gt;gram.y&lt;/code&gt; otherwise you won't understand what happens there.</source>
          <target state="translated">对野牛或 &lt;code&gt;gram.y&lt;/code&gt; 中给出的语法规则的详细描述将超出本文的范围。有许多有关flex和bison的书籍和文档。在开始学习 &lt;code&gt;gram.y&lt;/code&gt; 中给出的语法之前，您应该熟悉野牛。否则您将不了解那里发生的事情。</target>
        </trans-unit>
        <trans-unit id="bf3c5419b01f42e467232a91a0454e478bf36293" translate="yes" xml:space="preserve">
          <source>A dictionary is a program that accepts a token as input and returns:</source>
          <target state="translated">字典是一个接受一个标记作为输入并返回的程序。</target>
        </trans-unit>
        <trans-unit id="28559b5d13d6b8ce91e33b4017f8d681ab5ce5fe" translate="yes" xml:space="preserve">
          <source>A different approach to redirecting inserts into the appropriate child table is to set up rules, instead of a trigger, on the master table. For example:</source>
          <target state="translated">将插入重定向到适当的子表的另一种方法是在主表上设置规则,而不是触发器。例如:</target>
        </trans-unit>
        <trans-unit id="92dd343b65d278a179ec5a3ad694901513c02d90" translate="yes" xml:space="preserve">
          <source>A different setting might be appropriate when doing synchronous logical replication. The logical replication workers report the positions of writes and flushes to the publisher, and when using synchronous replication, the publisher will wait for the actual flush. This means that setting &lt;code&gt;synchronous_commit&lt;/code&gt; for the subscriber to &lt;code&gt;off&lt;/code&gt; when the subscription is used for synchronous replication might increase the latency for &lt;code&gt;COMMIT&lt;/code&gt; on the publisher. In this scenario, it can be advantageous to set &lt;code&gt;synchronous_commit&lt;/code&gt; to &lt;code&gt;local&lt;/code&gt; or higher.</source>
          <target state="translated">进行同步逻辑复制时，可能需要使用其他设置。逻辑复制工作程序将写入和刷新的位置报告给发布者，并且在使用同步复制时，发布者将等待实际的刷新。这意味着，设置 &lt;code&gt;synchronous_commit&lt;/code&gt; 为订户 &lt;code&gt;off&lt;/code&gt; 时，定制是用于同步复制可能会增加等待时间 &lt;code&gt;COMMIT&lt;/code&gt; 在发布。在这种情况下，它可以是有利的 &lt;code&gt;synchronous_commit&lt;/code&gt; 到 &lt;code&gt;local&lt;/code&gt; 或更高。</target>
        </trans-unit>
        <trans-unit id="77b0f5ef06846b6f2b1bf89e5b5dc745a05b482a" translate="yes" xml:space="preserve">
          <source>A disadvantage of the &lt;code&gt;jsonb_path_ops&lt;/code&gt; approach is that it produces no index entries for JSON structures not containing any values, such as &lt;code&gt;{&quot;a&quot;: {}}&lt;/code&gt;. If a search for documents containing such a structure is requested, it will require a full-index scan, which is quite slow. &lt;code&gt;jsonb_path_ops&lt;/code&gt; is therefore ill-suited for applications that often perform such searches.</source>
          <target state="translated">&lt;code&gt;jsonb_path_ops&lt;/code&gt; 方法的一个缺点是，它不为不包含任何值（例如 &lt;code&gt;{&quot;a&quot;: {}}&lt;/code&gt; JSON结构生成索引条目。如果要求搜索包含这种结构的文档，则将需要全索引扫描，这非常慢。因此， &lt;code&gt;jsonb_path_ops&lt;/code&gt; 不适合经常执行此类搜索的应用程序。</target>
        </trans-unit>
        <trans-unit id="436fb2bab58d12b2362059406a336206c3d00306" translate="yes" xml:space="preserve">
          <source>A discrete range is one whose element type has a well-defined &amp;ldquo;step&amp;rdquo;, such as &lt;code&gt;integer&lt;/code&gt; or &lt;code&gt;date&lt;/code&gt;. In these types two elements can be said to be adjacent, when there are no valid values between them. This contrasts with continuous ranges, where it's always (or almost always) possible to identify other element values between two given values. For example, a range over the &lt;code&gt;numeric&lt;/code&gt; type is continuous, as is a range over &lt;code&gt;timestamp&lt;/code&gt;. (Even though &lt;code&gt;timestamp&lt;/code&gt; has limited precision, and so could theoretically be treated as discrete, it's better to consider it continuous since the step size is normally not of interest.)</source>
          <target state="translated">离散范围是指其元素类型具有明确定义的&amp;ldquo;步骤&amp;rdquo;的范围，例如 &lt;code&gt;integer&lt;/code&gt; 或 &lt;code&gt;date&lt;/code&gt; 。在这些类型中，当两个元素之间没有有效值时，可以说它们是相邻的。这与连续范围形成对比，连续范围总是（或几乎总是）可以识别两个给定值之间的其他元素值。例如， &lt;code&gt;numeric&lt;/code&gt; 类型上的范围是连续的， &lt;code&gt;timestamp&lt;/code&gt; 上的范围也是连续的。 （尽管 &lt;code&gt;timestamp&lt;/code&gt; 精度有限，因此理论上可以将其视为离散的，但最好将其视为连续的，因为步长通常不重要。）</target>
        </trans-unit>
        <trans-unit id="a23c5cb9993deaf1311e315f3014f146e372868a" translate="yes" xml:space="preserve">
          <source>A discrete range type should have a &lt;em&gt;canonicalization&lt;/em&gt; function that is aware of the desired step size for the element type. The canonicalization function is charged with converting equivalent values of the range type to have identical representations, in particular consistently inclusive or exclusive bounds. If a canonicalization function is not specified, then ranges with different formatting will always be treated as unequal, even though they might represent the same set of values in reality.</source>
          <target state="translated">离散范围类型应具有&lt;em&gt;规范化&lt;/em&gt;功能，该功能应了解元素类型所需的步长。规范化功能负责将范围类型的等效值转换为具有相同的表示形式，尤其是始终如一的包含或排除范围。如果未指定规范化函数，那么即使格式不同的范围实际上可能表示同一组值，也始终将其视为不相等。</target>
        </trans-unit>
        <trans-unit id="52cd489229e47470dc581e1d13cab54fdd7f5f6e" translate="yes" xml:space="preserve">
          <source>A dollar sign (&lt;code&gt;$&lt;/code&gt;) followed by digits is used to represent a positional parameter in the body of a function definition or a prepared statement. In other contexts the dollar sign can be part of an identifier or a dollar-quoted string constant.</source>
          <target state="translated">美元符号（ &lt;code&gt;$&lt;/code&gt; ）后跟数字用于表示函数定义或准备好的语句主体中的位置参数。在其他情况下，美元符号可以是标识符的一部分，也可以是美元引用的字符串常量。</target>
        </trans-unit>
        <trans-unit id="85726c6c75380e885546cdf31fee2dad70737f00" translate="yes" xml:space="preserve">
          <source>A dollar-quoted string that follows a keyword or identifier must be separated from it by whitespace; otherwise the dollar quoting delimiter would be taken as part of the preceding identifier.</source>
          <target state="translated">关键词或标识符后面的美元引号字符串必须用空格隔开,否则美元引号定界符将作为前面标识符的一部分。</target>
        </trans-unit>
        <trans-unit id="483ea815eb464b44ff5ffec5d8ce0005d215accd" translate="yes" xml:space="preserve">
          <source>A duplicate is a leaf page tuple (a tuple that points to a table row) where &lt;em&gt;all&lt;/em&gt; indexed key columns have values that match corresponding column values from at least one other leaf page tuple in the same index. Duplicate tuples are quite common in practice. B-Tree indexes can use a special, space-efficient representation for duplicates when an optional technique is enabled: &lt;em&gt;deduplication&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cee3f5330478a7b8687aa435c97bcf37602fa11b" translate="yes" xml:space="preserve">
          <source>A failure message indicating inability to bind to a port might indicate that that port is already in use by some non-PostgreSQL process. You might also get this error if you terminate &lt;code&gt;postgres&lt;/code&gt; and immediately restart it using the same port; in this case, you must simply wait a few seconds until the operating system closes the port before trying again. Finally, you might get this error if you specify a port number that your operating system considers to be reserved. For example, many versions of Unix consider port numbers under 1024 to be &amp;ldquo;trusted&amp;rdquo; and only permit the Unix superuser to access them.</source>
          <target state="translated">指示无法绑定端口的失败消息可能表明该端口已被某些非PostgreSQL进程使用。如果终止 &lt;code&gt;postgres&lt;/code&gt; 并立即使用同一端口重新启动它，也可能会收到此错误；在这种情况下，您只需等待几秒钟，直到操作系统关闭端口，然后再试一次即可。最后，如果您指定操作系统认为已保留的端口号，则可能会出现此错误。例如，许多版本的Unix都认为&amp;ldquo; 1024&amp;rdquo;以下的端口号是&amp;ldquo;可信的&amp;rdquo;，并且仅允许Unix超级用户访问它们。</target>
        </trans-unit>
        <trans-unit id="6c9a12fdfac03387393cfa5d605bafff7741fcf8" translate="yes" xml:space="preserve">
          <source>A failure message mentioning &lt;code&gt;semget&lt;/code&gt; or &lt;code&gt;shmget&lt;/code&gt; probably indicates you need to configure your kernel to provide adequate shared memory and semaphores. For more discussion see &lt;a href=&quot;kernel-resources&quot;&gt;Section 18.4&lt;/a&gt;. You might be able to postpone reconfiguring your kernel by decreasing &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt; to reduce the shared memory consumption of PostgreSQL, and/or by reducing &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; to reduce the semaphore consumption.</source>
          <target state="translated">提及 &lt;code&gt;semget&lt;/code&gt; 或 &lt;code&gt;shmget&lt;/code&gt; 的失败消息可能表明您需要配置内核以提供足够的共享内存和信号灯。有关更多讨论，请参见&lt;a href=&quot;kernel-resources&quot;&gt;第18.4节&lt;/a&gt;。您可能能够通过减少&lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;来减少PostgreSQL的共享内存消耗和/或通过减少&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;来减少信号量消耗来推迟重新配置内核。</target>
        </trans-unit>
        <trans-unit id="6441f31b6574d318eb87a3d59abc87efb6583505" translate="yes" xml:space="preserve">
          <source>A failure message suggesting that another server is already running should be checked carefully, for example by using the command</source>
          <target state="translated">应该仔细检查暗示另一个服务器已经在运行的失败消息,例如,使用命令</target>
        </trans-unit>
        <trans-unit id="1d9edc129f87c5a3cfe93256806f12763480e5e4" translate="yes" xml:space="preserve">
          <source>A few of the catalogs are so fundamental that they can't even be created by the BKI &lt;code&gt;create&lt;/code&gt; command that's used for most catalogs, because that command needs to write information into these catalogs to describe the new catalog. These are called &lt;em&gt;bootstrap&lt;/em&gt; catalogs, and defining one takes a lot of extra work: you have to manually prepare appropriate entries for them in the pre-loaded contents of &lt;code&gt;pg_class&lt;/code&gt; and &lt;code&gt;pg_type&lt;/code&gt;, and those entries will need to be updated for subsequent changes to the catalog's structure. (Bootstrap catalogs also need pre-loaded entries in &lt;code&gt;pg_attribute&lt;/code&gt;, but fortunately &lt;code&gt;genbki.pl&lt;/code&gt; handles that chore nowadays.) Avoid making new catalogs be bootstrap catalogs if at all possible.</source>
          <target state="translated">一些目录是如此基础，以至于大多数目录都无法使用BKI &lt;code&gt;create&lt;/code&gt; 命令来创建它们，因为该命令需要将信息写入这些目录中以描述新目录。这些被称为&lt;em&gt;引导&lt;/em&gt;目录，定义一个目录需要花费很多额外的工作：您必须在 &lt;code&gt;pg_class&lt;/code&gt; 和 &lt;code&gt;pg_type&lt;/code&gt; 的预加载内容中为它们手动准备适当的条目，并且这些条目将需要更新以用于随后对目录的更改结构体。（引导目录还需要在 &lt;code&gt;pg_attribute&lt;/code&gt; 中预加载条目，但幸运的是 &lt;code&gt;genbki.pl&lt;/code&gt; 处理当今繁琐的工作。）尽可能避免将新目录作为引导目录。</target>
        </trans-unit>
        <trans-unit id="491372897d998156eaa18d8e18156aea1cce4b05" translate="yes" xml:space="preserve">
          <source>A field selection expression</source>
          <target state="translated">字段选择表达式</target>
        </trans-unit>
        <trans-unit id="7c39dad2086ca141110bdca18a2eda32e161292b" translate="yes" xml:space="preserve">
          <source>A file containing the major version number of PostgreSQL</source>
          <target state="translated">一个包含PostgreSQL主要版本号的文件。</target>
        </trans-unit>
        <trans-unit id="6d87ef4157174eec7539a1a8a3467ba85faf286d" translate="yes" xml:space="preserve">
          <source>A file recording the command-line options the server was last started with</source>
          <target state="translated">记录服务器最后一次使用命令行选项的文件。</target>
        </trans-unit>
        <trans-unit id="329de4f43c6fb34276fdedd0bdd8b0f19adeca12" translate="yes" xml:space="preserve">
          <source>A file used for storing configuration parameters that are set by &lt;code&gt;ALTER SYSTEM&lt;/code&gt;</source>
          <target state="translated">用于存储由 &lt;code&gt;ALTER SYSTEM&lt;/code&gt; 设置的配置参数的文件</target>
        </trans-unit>
        <trans-unit id="d60f29dfa94fb158cf5e58302f68dd9e477b3bca" translate="yes" xml:space="preserve">
          <source>A filtering dictionary can be placed anywhere in the list, except at the end where it'd be useless. Filtering dictionaries are useful to partially normalize words to simplify the task of later dictionaries. For example, a filtering dictionary could be used to remove accents from accented letters, as is done by the &lt;a href=&quot;unaccent&quot;&gt;unaccent&lt;/a&gt; module.</source>
          <target state="translated">过滤字典可以放置在列表中的任何地方，除非结尾没用。过滤字典可用于部分标准化单词，以简化后续字典的工作。例如，可以使用过滤字典从重音字母中删除重音，如&lt;a href=&quot;unaccent&quot;&gt;unaccent&lt;/a&gt;模块所做的那样。</target>
        </trans-unit>
        <trans-unit id="61b8bbc2eb9fadf3683e04ebbb9e129815f5ed02" translate="yes" xml:space="preserve">
          <source>A final identifier type used by the system is &lt;code&gt;tid&lt;/code&gt;, or tuple identifier (row identifier). This is the data type of the system column &lt;code&gt;ctid&lt;/code&gt;. A tuple ID is a pair (block number, tuple index within block) that identifies the physical location of the row within its table.</source>
          <target state="translated">系统使用的最终标识符类型是 &lt;code&gt;tid&lt;/code&gt; 或元组标识符（行标识符）。这是系统列 &lt;code&gt;ctid&lt;/code&gt; 的数据类型。元组ID是一对（块号，块内的元组索引），用于标识表中行的物理位置。</target>
        </trans-unit>
        <trans-unit id="9534174e684925e17ef91bf3e3714ca6759242b6" translate="yes" xml:space="preserve">
          <source>A fine point of the above example is that the &lt;code&gt;WITH&lt;/code&gt; clause is attached to the &lt;code&gt;INSERT&lt;/code&gt;, not the sub-&lt;code&gt;SELECT&lt;/code&gt; within the &lt;code&gt;INSERT&lt;/code&gt;. This is necessary because data-modifying statements are only allowed in &lt;code&gt;WITH&lt;/code&gt; clauses that are attached to the top-level statement. However, normal &lt;code&gt;WITH&lt;/code&gt; visibility rules apply, so it is possible to refer to the &lt;code&gt;WITH&lt;/code&gt; statement's output from the sub-&lt;code&gt;SELECT&lt;/code&gt;.</source>
          <target state="translated">上面的示例的一个优点是， &lt;code&gt;WITH&lt;/code&gt; 子句附加到 &lt;code&gt;INSERT&lt;/code&gt; ，而不是 &lt;code&gt;INSERT&lt;/code&gt; 内的子 &lt;code&gt;SELECT&lt;/code&gt; 。这是必需的，因为仅在附加到顶级语句的 &lt;code&gt;WITH&lt;/code&gt; 子句中才允许使用数据修改语句。但是，通常会 &lt;code&gt;WITH&lt;/code&gt; 可见性规则，因此可以从子 &lt;code&gt;SELECT&lt;/code&gt; 引用 &lt;code&gt;WITH&lt;/code&gt; 语句的输出。</target>
        </trans-unit>
        <trans-unit id="d04dea72f91d057a2ddbc23d00826a2d1a1c915a" translate="yes" xml:space="preserve">
          <source>A first pass to build the index is done for each new index. Once the index is built, its flag &lt;code&gt;pg_index.indisready&lt;/code&gt; is switched to &amp;ldquo;true&amp;rdquo; to make it ready for inserts, making it visible to other sessions once the transaction that performed the build is finished. This step is done in a separate transaction for each index.</source>
          <target state="translated">为每个新索引完成构建索引的第一遍。索引一旦建立，其标志 &lt;code&gt;pg_index.indisready&lt;/code&gt; 将切换为&amp;ldquo; true&amp;rdquo;以使其准备好插入，一旦完成构建的事务完成，其他会话就可以看到它。此步骤在每个索引的单独事务中完成。</target>
        </trans-unit>
        <trans-unit id="a130458680bbe29e1418dce659480b6f78389bae" translate="yes" xml:space="preserve">
          <source>A foreign key can also constrain and reference a group of columns. As usual, it then needs to be written in table constraint form. Here is a contrived syntax example:</source>
          <target state="translated">外键也可以约束和引用一组列。一样平常来说,它就必要写成表约束形式。下面是一个人为的语法例子。</target>
        </trans-unit>
        <trans-unit id="7935e3b9aa49c2d43f16cbf75e1d409bba02665a" translate="yes" xml:space="preserve">
          <source>A foreign key constraint specifies that the values in a column (or a group of columns) must match the values appearing in some row of another table. We say this maintains the &lt;em&gt;referential integrity&lt;/em&gt; between two related tables.</source>
          <target state="translated">外键约束指定一列（或一组列）中的值必须与另一个表的某一行中出现的值匹配。我们说这保持了两个相关表之间的&lt;em&gt;参照完整性&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="dec7e4504b0a144e3a3d9b45cbf1480f1f8aba04" translate="yes" xml:space="preserve">
          <source>A foreign key must reference columns that either are a primary key or form a unique constraint. This means that the referenced columns always have an index (the one underlying the primary key or unique constraint); so checks on whether a referencing row has a match will be efficient. Since a &lt;code&gt;DELETE&lt;/code&gt; of a row from the referenced table or an &lt;code&gt;UPDATE&lt;/code&gt; of a referenced column will require a scan of the referencing table for rows matching the old value, it is often a good idea to index the referencing columns too. Because this is not always needed, and there are many choices available on how to index, declaration of a foreign key constraint does not automatically create an index on the referencing columns.</source>
          <target state="translated">外键必须引用作为主键或形成唯一约束的列。这意味着被引用的列始终具有一个索引（作为主键或唯一约束的基础的索引）；因此，检查引用行是否有匹配项将非常有效。由于从被引用表中 &lt;code&gt;DELETE&lt;/code&gt; 一行或对被引用列进行 &lt;code&gt;UPDATE&lt;/code&gt; 将需要对引用表进行扫描以查找与旧值匹配的行，因此通常也建议对引用列进行索引。因为这并不总是需要的，并且有许多关于如何建立索引的选择，所以外键约束的声明不会自动在引用列上创建索引。</target>
        </trans-unit>
        <trans-unit id="8ae80fcdea6bfacfb223ea7833eb93180e9021f3" translate="yes" xml:space="preserve">
          <source>A foreign server typically encapsulates connection information that a foreign-data wrapper uses to access an external data resource. Additional user-specific connection information may be specified by means of user mappings.</source>
          <target state="translated">外来服务器通常封装了外来数据包装器用来访问外部数据资源的连接信息。可以通过用户映射来指定额外的用户特定连接信息。</target>
        </trans-unit>
        <trans-unit id="9a9b5927e002630605d5343a34d0cf4f9f180fe0" translate="yes" xml:space="preserve">
          <source>A foreign server using the &lt;code&gt;postgres_fdw&lt;/code&gt; foreign data wrapper can have the same options that libpq accepts in connection strings, as described in &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;Section 33.1.2&lt;/a&gt;, except that these options are not allowed:</source>
          <target state="translated">使用 &lt;code&gt;postgres_fdw&lt;/code&gt; 外部数据包装器的外部服务器可以具有libpq在连接字符串中接受的相同选项，如&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;第33.1.2节中所述&lt;/a&gt;，不同之处在于不允许这些选项：</target>
        </trans-unit>
        <trans-unit id="badba5a356d62e1cd053d7b73d8fe2b817602f47" translate="yes" xml:space="preserve">
          <source>A foreign server using the &lt;code&gt;postgres_fdw&lt;/code&gt; foreign data wrapper can have the same options that libpq accepts in connection strings, as described in &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;Section 33.1.2&lt;/a&gt;, except that these options are not allowed or have special handling:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1be8aee5fcb016100bb8dc793de4e631744baeb3" translate="yes" xml:space="preserve">
          <source>A foreign table created using this wrapper can have the following options:</source>
          <target state="translated">使用这个包装器创建的外表可以有以下选项。</target>
        </trans-unit>
        <trans-unit id="53f8f23c4cbab938356aea7eedc9b0a745c3d640" translate="yes" xml:space="preserve">
          <source>A foreign-data wrapper handler is declared to return &lt;code&gt;fdw_handler&lt;/code&gt;.</source>
          <target state="translated">声明了外部数据包装处理程序以返回 &lt;code&gt;fdw_handler&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d69f8188280c90b11c42fae9d5a6f62a34fa828" translate="yes" xml:space="preserve">
          <source>A full list of &lt;code&gt;tsvector&lt;/code&gt;-related functions is available in &lt;a href=&quot;functions-textsearch#TEXTSEARCH-FUNCTIONS-TABLE&quot;&gt;Table 9.42&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions-textsearch#TEXTSEARCH-FUNCTIONS-TABLE&quot;&gt;表9.42中&lt;/a&gt;提供了与 &lt;code&gt;tsvector&lt;/code&gt; 相关的功能的完整列表。</target>
        </trans-unit>
        <trans-unit id="65e83897f69ea1032a4c6125df7aec06ca7e6f69" translate="yes" xml:space="preserve">
          <source>A full time zone name, for example &lt;code&gt;America/New_York&lt;/code&gt;. The recognized time zone names are listed in the &lt;code&gt;pg_timezone_names&lt;/code&gt; view (see &lt;a href=&quot;view-pg-timezone-names&quot;&gt;Section 51.92&lt;/a&gt;). PostgreSQL uses the widely-used IANA time zone data for this purpose, so the same time zone names are also recognized by other software.</source>
          <target state="translated">全时区名称，例如 &lt;code&gt;America/New_York&lt;/code&gt; 。可识别的时区名称在 &lt;code&gt;pg_timezone_names&lt;/code&gt; 视图中列出（请参见&lt;a href=&quot;view-pg-timezone-names&quot;&gt;第51.92节&lt;/a&gt;）。PostgreSQL为此目的使用了广泛使用的IANA时区数据，因此其他软件也可以识别相同的时区名称。</target>
        </trans-unit>
        <trans-unit id="ca3257c97b3a14d468e354dcf32c96f8c18bebc4" translate="yes" xml:space="preserve">
          <source>A function call</source>
          <target state="translated">函数调用</target>
        </trans-unit>
        <trans-unit id="29b8eafb6b7c2b2b298c30410ef6e0e704d3c56b" translate="yes" xml:space="preserve">
          <source>A function can be represented by its &lt;code&gt;proname&lt;/code&gt;, if that is unique among the &lt;code&gt;pg_proc.dat&lt;/code&gt; entries (this works like regproc input). Otherwise, write it as &lt;code&gt;proname(argtypename,argtypename,...)&lt;/code&gt;, like regprocedure. The argument type names must be spelled exactly as they are in the &lt;code&gt;pg_proc.dat&lt;/code&gt; entry's &lt;code&gt;proargtypes&lt;/code&gt; field. Do not insert any spaces.</source>
          <target state="translated">如果函数在 &lt;code&gt;pg_proc.dat&lt;/code&gt; 条目中是唯一的（可以像regproc输入一样），则可以用它的 &lt;code&gt;proname&lt;/code&gt; 来表示一个函数。否则，将其写为 &lt;code&gt;proname(argtypename,argtypename,...)&lt;/code&gt; ，例如regprocedure。参数类型名称的拼写必须与 &lt;code&gt;pg_proc.dat&lt;/code&gt; 条目的 &lt;code&gt;proargtypes&lt;/code&gt; 字段中的完全相同。请勿插入任何空格。</target>
        </trans-unit>
        <trans-unit id="665c5d40faa1c27c6639ca8ba23f82787f2ca582" translate="yes" xml:space="preserve">
          <source>A function that takes a single argument of composite type can optionally be called using field-selection syntax, and conversely field selection can be written in functional style. That is, the notations &lt;code&gt;col(table)&lt;/code&gt; and &lt;code&gt;table.col&lt;/code&gt; are interchangeable. This behavior is not SQL-standard but is provided in PostgreSQL because it allows use of functions to emulate &amp;ldquo;computed fields&amp;rdquo;. For more information see &lt;a href=&quot;rowtypes#ROWTYPES-USAGE&quot;&gt;Section 8.16.5&lt;/a&gt;.</source>
          <target state="translated">可以选择使用字段选择语法来调用采用复合类型的单个参数的函数，相反，可以以函数样式编写字段选择。也就是说，符号 &lt;code&gt;col(table)&lt;/code&gt; 和 &lt;code&gt;table.col&lt;/code&gt; 是可互换的。此行为不是SQL标准的，但在PostgreSQL中提供，因为它允许使用函数来模拟&amp;ldquo;计算字段&amp;rdquo;。有关更多信息，请参见&lt;a href=&quot;rowtypes#ROWTYPES-USAGE&quot;&gt;第8.16.5节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e7f8fec4e5b8f079531cd32a009d627206c65e10" translate="yes" xml:space="preserve">
          <source>A generated column cannot be part of a partition key.</source>
          <target state="translated">生成的列不能成为分区键的一部分。</target>
        </trans-unit>
        <trans-unit id="e0ac9eba09cfa3c9dbd2d45d33c0ab9b56aec7dc" translate="yes" xml:space="preserve">
          <source>A generated column cannot be written to directly. In &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; commands, a value cannot be specified for a generated column, but the keyword &lt;code&gt;DEFAULT&lt;/code&gt; may be specified.</source>
          <target state="translated">生成的列不能直接写入。在 &lt;code&gt;INSERT&lt;/code&gt; 或 &lt;code&gt;UPDATE&lt;/code&gt; 命令中，不能为生成的列指定值，但是可以指定关键字 &lt;code&gt;DEFAULT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a974e7fa8fff8257dce1404630bd9e17704afbe0" translate="yes" xml:space="preserve">
          <source>A generated column cannot have a column default or an identity definition.</source>
          <target state="translated">生成的列不能有列默认值或身份定义。</target>
        </trans-unit>
        <trans-unit id="1dbf7e263f1354b2b93387f1bfe3cc26e77a333d" translate="yes" xml:space="preserve">
          <source>A generated column is a special column that is always computed from other columns. Thus, it is for columns what a view is for tables. There are two kinds of generated columns: stored and virtual. A stored generated column is computed when it is written (inserted or updated) and occupies storage as if it were a normal column. A virtual generated column occupies no storage and is computed when it is read. Thus, a virtual generated column is similar to a view and a stored generated column is similar to a materialized view (except that it is always updated automatically). PostgreSQL currently implements only stored generated columns.</source>
          <target state="translated">生成的列是一个特殊的列,它总是由其他列计算出来的。因此,它对于列的意义就像视图对于表的意义一样。生成列有两种:存储的和虚拟的。存储生成的列在写入(插入或更新)时就被计算出来,它就像普通的列一样占用存储空间。虚拟生成列不占用存储空间,在读取时计算。因此,虚拟生成的列类似于视图,而存储生成的列类似于实体化的视图(只是它总是自动更新)。PostgreSQL目前只实现了存储生成列。</target>
        </trans-unit>
        <trans-unit id="be4467cb35124e2c3c1d0bf937b508ea68a8aa1a" translate="yes" xml:space="preserve">
          <source>A generation expression cannot reference a system column, except &lt;code&gt;tableoid&lt;/code&gt;.</source>
          <target state="translated">代表达式不能引用系统列， &lt;code&gt;tableoid&lt;/code&gt; 除外。</target>
        </trans-unit>
        <trans-unit id="4e7a5a9dc2e173ff254950537b52dfc433ffc740" translate="yes" xml:space="preserve">
          <source>A generation expression cannot reference another generated column.</source>
          <target state="translated">一个生成表达式不能引用另一个生成列。</target>
        </trans-unit>
        <trans-unit id="cddf5b488fdbb3769abd336844e34805f857556c" translate="yes" xml:space="preserve">
          <source>A group of backend and auxiliary processes that communicate using a common shared memory area. One &lt;a href=&quot;glossary#GLOSSARY-POSTMASTER&quot;&gt;postmaster process&lt;/a&gt; manages the instance; one instance manages exactly one &lt;a href=&quot;glossary#GLOSSARY-DB-CLUSTER&quot;&gt;database cluster&lt;/a&gt; with all its databases. Many instances can run on the same &lt;a href=&quot;glossary#GLOSSARY-SERVER&quot;&gt;server&lt;/a&gt; as long as their TCP ports do not conflict.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5204280cf84852f809b22497f5b5b7223747d56b" translate="yes" xml:space="preserve">
          <source>A heap page image obtained with &lt;code&gt;get_raw_page&lt;/code&gt; should be passed as argument. For example:</source>
          <target state="translated">使用 &lt;code&gt;get_raw_page&lt;/code&gt; 获得的堆页面图像应作为参数传递。例如：</target>
        </trans-unit>
        <trans-unit id="852fc3cf5ee76f5f80b4e90d90cfd5ea3f69f788" translate="yes" xml:space="preserve">
          <source>A helpful trick for testing queries when you are not certain if they might loop is to place a &lt;code&gt;LIMIT&lt;/code&gt; in the parent query. For example, this query would loop forever without the &lt;code&gt;LIMIT&lt;/code&gt;:</source>
          <target state="translated">在不确定查询是否会循环时测试查询的一个有用技巧是在父查询中放置一个 &lt;code&gt;LIMIT&lt;/code&gt; 。例如，如果没有 &lt;code&gt;LIMIT&lt;/code&gt; ，此查询将永远循环：</target>
        </trans-unit>
        <trans-unit id="83afefe0fbb71aaede7acaeb0c43f98d93c15f12" translate="yes" xml:space="preserve">
          <source>A high schedule lag time is an indication that the system cannot process transactions at the specified rate, with the chosen number of clients and threads. When the average transaction execution time is longer than the scheduled interval between each transaction, each successive transaction will fall further behind, and the schedule lag time will keep increasing the longer the test run is. When that happens, you will have to reduce the specified transaction rate.</source>
          <target state="translated">计划滞后时间过长,说明系统在选定的客户机和线程数量下,无法以指定的速度处理事务。当平均事务执行时间比每个事务之间的计划间隔时间长时,每个连续的事务将进一步落后,并且计划滞后时间将随着测试运行时间的延长而不断增加。当这种情况发生时,你将不得不降低指定的事务速率。</target>
        </trans-unit>
        <trans-unit id="61cac6a1eeedd7da0737519022c8bf6afc564b8b" translate="yes" xml:space="preserve">
          <source>A histogram of the counts of distinct non-null element values within the values of the column, followed by the average number of distinct non-null elements. (Null for scalar types.)</source>
          <target state="translated">列的值中不同的非空元素值的计数的直方图,然后是不同的非空元素的平均数。(标量类型为空。)</target>
        </trans-unit>
        <trans-unit id="e17cd8aa619245cf1ec3d376e7b36d9afdaa66d4" translate="yes" xml:space="preserve">
          <source>A host name specification that starts with a dot (&lt;code&gt;.&lt;/code&gt;) matches a suffix of the actual host name. So &lt;code&gt;.example.com&lt;/code&gt; would match &lt;code&gt;foo.example.com&lt;/code&gt; (but not just &lt;code&gt;example.com&lt;/code&gt;).</source>
          <target state="translated">以点（ &lt;code&gt;.&lt;/code&gt; ）开头的主机名规范与实际主机名的后缀匹配。因此 &lt;code&gt;.example.com&lt;/code&gt; 将与 &lt;code&gt;foo.example.com&lt;/code&gt; 相匹配（但不只是 &lt;code&gt;example.com&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="16a83f51a8f292b8e135eff3bc4b49e6a7b0c8c1" translate="yes" xml:space="preserve">
          <source>A joined table is a table derived from two other (real or derived) tables according to the rules of the particular join type. Inner, outer, and cross-joins are available. The general syntax of a joined table is</source>
          <target state="translated">连接表是根据特定连接类型的规则从另外两个表(实表或派生表)衍生出来的表。可以使用内连接、外连接和交叉连接。连接表的一般语法是</target>
        </trans-unit>
        <trans-unit id="c38978f6d39cb114e0bbdd4555f08d4137a6d679" translate="yes" xml:space="preserve">
          <source>A key feature of psql variables is that you can substitute (&amp;ldquo;interpolate&amp;rdquo;) them into regular SQL statements, as well as the arguments of meta-commands. Furthermore, psql provides facilities for ensuring that variable values used as SQL literals and identifiers are properly quoted. The syntax for interpolating a value without any quoting is to prepend the variable name with a colon (&lt;code&gt;:&lt;/code&gt;). For example,</source>
          <target state="translated">psql变量的主要功能是您可以将它们替换（&amp;ldquo;插入&amp;rdquo;）到常规SQL语句以及meta命令的参数中。此外，psql提供了一些设施，以确保正确引用用作SQL文字和标识符的变量值。用于内插的值没有任何引用的语法是一个冒号预先设置变量名称（ &lt;code&gt;:&lt;/code&gt; ）。例如，</target>
        </trans-unit>
        <trans-unit id="82961127c30e9d99b0606fff4408183ed9cb0961" translate="yes" xml:space="preserve">
          <source>A key property of &lt;code&gt;WITH&lt;/code&gt; queries is that they are normally evaluated only once per execution of the primary query, even if the primary query refers to them more than once. In particular, data-modifying statements are guaranteed to be executed once and only once, regardless of whether the primary query reads all or any of their output.</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; 查询的一个关键属性是，即使主查询多次引用它们，通常每次执行主查询时它们只会被评估一次。特别是，无论主查询是读取全部输出还是输出任何内容，都保证数据修改语句仅执行一次。</target>
        </trans-unit>
        <trans-unit id="61ba864342105e7de2a1c4f77ad3ea649ab3dd8e" translate="yes" xml:space="preserve">
          <source>A larger setting would be appropriate if other programs on the machine also need huge pages. Don't forget to add this setting to &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; so that it will be reapplied after reboots.</source>
          <target state="translated">如果计算机上的其他程序也需要大页面，则较大的设置将是适当的。不要忘记将此设置添加到 &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 中,以便在重新启动后重新应用该设置。</target>
        </trans-unit>
        <trans-unit id="740fc98f7710c6fce519cc7ddb08e68b536ff0d4" translate="yes" xml:space="preserve">
          <source>A less-oversimplified example of a &lt;code&gt;subtype_diff&lt;/code&gt; function is:</source>
          <target state="translated">&lt;code&gt;subtype_diff&lt;/code&gt; 函数的一个不太简化的示例是：</target>
        </trans-unit>
        <trans-unit id="15b979d3d44d76b40d5152f1d019597a03929970" translate="yes" xml:space="preserve">
          <source>A limitation of pgbench is that it can itself become the bottleneck when trying to test a large number of client sessions. This can be alleviated by running pgbench on a different machine from the database server, although low network latency will be essential. It might even be useful to run several pgbench instances concurrently, on several client machines, against the same database server.</source>
          <target state="translated">pgbench的一个局限性是,当试图测试大量的客户端会话时,它本身可能会成为瓶颈。这可以通过在数据库服务器的不同机器上运行pgbench来缓解,尽管低网络延迟是必不可少的。甚至可以在几台客户机上同时运行几个pgbench实例,对同一数据库服务器进行测试。</target>
        </trans-unit>
        <trans-unit id="ab2d89a97d20a5efbc73683817ba2ff464b9a103" translate="yes" xml:space="preserve">
          <source>A limitation of these built-in triggers is that they treat all the input columns alike. To process columns differently &amp;mdash; for example, to weight title differently from body &amp;mdash; it is necessary to write a custom trigger. Here is an example using PL/pgSQL as the trigger language:</source>
          <target state="translated">这些内置触发器的局限在于它们对所有输入列的处理方式相同。要以不同方式处理列（例如，以不同的方式称呼标题），必须编写自定义触发器。这是一个使用PL / pgSQL作为触发语言的示例：</target>
        </trans-unit>
        <trans-unit id="f76857de86cd4afe434d4b21d9313477ab29ebe7" translate="yes" xml:space="preserve">
          <source>A limitation of this feature is that an &lt;code&gt;ORDER BY&lt;/code&gt; clause applying to the result of a &lt;code&gt;UNION&lt;/code&gt;, &lt;code&gt;INTERSECT&lt;/code&gt;, or &lt;code&gt;EXCEPT&lt;/code&gt; clause can only specify an output column name or number, not an expression.</source>
          <target state="translated">此功能的局限性在于，应用于 &lt;code&gt;UNION&lt;/code&gt; ， &lt;code&gt;INTERSECT&lt;/code&gt; 或 &lt;code&gt;EXCEPT&lt;/code&gt; 子句的结果的 &lt;code&gt;ORDER BY&lt;/code&gt; 子句只能指定输出列名或数字，而不能指定表达式。</target>
        </trans-unit>
        <trans-unit id="6e332e0f99b25d5ac06d1f211aa0eb2e56e7af5e" translate="yes" xml:space="preserve">
          <source>A list of NULL flags for the most common combinations of values. (Null when &lt;code&gt;most_common_vals&lt;/code&gt; is.)</source>
          <target state="translated">最常见的值组合的NULL标志列表。（当 &lt;code&gt;most_common_vals&lt;/code&gt; 为null时为null 。）</target>
        </trans-unit>
        <trans-unit id="faedcc532ba9e80276afc21b0d135826be8f1422" translate="yes" xml:space="preserve">
          <source>A list of non-null element values most often appearing within values of the column. (Null for scalar types.)</source>
          <target state="translated">列的值中最常出现的非空元素值的列表。(标量类型为空。)</target>
        </trans-unit>
        <trans-unit id="9222c144bac210ee75eb7f8e023e5b70c063c9b1" translate="yes" xml:space="preserve">
          <source>A list of table expressions, allowing columns from other tables to appear in the &lt;code&gt;WHERE&lt;/code&gt; condition and the update expressions. This is similar to the list of tables that can be specified in the &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt;&lt;code&gt;FROM&lt;/code&gt; Clause&lt;/a&gt; of a &lt;code&gt;SELECT&lt;/code&gt; statement. Note that the target table must not appear in the &lt;code&gt;from_list&lt;/code&gt;, unless you intend a self-join (in which case it must appear with an alias in the &lt;code&gt;from_list&lt;/code&gt;).</source>
          <target state="translated">表表达式的列表，允许其他表中的列出现在 &lt;code&gt;WHERE&lt;/code&gt; 条件和更新表达式中。这类似于可以在 &lt;code&gt;SELECT&lt;/code&gt; 语句的&lt;a href=&quot;sql-select#SQL-FROM&quot;&gt; &lt;code&gt;FROM&lt;/code&gt; 子句&lt;/a&gt;中指定的表的列表。请注意，除非您打算进行自 &lt;code&gt;from_list&lt;/code&gt; ，否则目标表不得出现在from_list中（在这种情况下，目标表必须以别名出现在 &lt;code&gt;from_list&lt;/code&gt; 中）。</target>
        </trans-unit>
        <trans-unit id="a5ec616bf7215f2b568c6fa91ae40cb63c46d2ff" translate="yes" xml:space="preserve">
          <source>A list of table expressions, allowing columns from other tables to appear in the &lt;code&gt;WHERE&lt;/code&gt; condition. This is similar to the list of tables that can be specified in the &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt;&lt;code&gt;FROM&lt;/code&gt; Clause&lt;/a&gt; of a &lt;code&gt;SELECT&lt;/code&gt; statement; for example, an alias for the table name can be specified. Do not repeat the target table in the &lt;code&gt;using_list&lt;/code&gt;, unless you wish to set up a self-join.</source>
          <target state="translated">表表达式列表，允许其他表中的列以 &lt;code&gt;WHERE&lt;/code&gt; 条件出现。这类似于可以在 &lt;code&gt;SELECT&lt;/code&gt; 语句的&lt;a href=&quot;sql-select#SQL-FROM&quot;&gt; &lt;code&gt;FROM&lt;/code&gt; 子句&lt;/a&gt;中指定的表的列表。例如，可以指定表名的别名。除非要设置自 &lt;code&gt;using_list&lt;/code&gt; ，否则不要在using_list中重复目标表。</target>
        </trans-unit>
        <trans-unit id="4a9f5b6a7fa98f13d9b0649d9b104ce5e824c915" translate="yes" xml:space="preserve">
          <source>A list of the base frequencies of the most common combinations, i.e., product of per-value frequencies. (Null when &lt;code&gt;most_common_vals&lt;/code&gt; is.)</source>
          <target state="translated">最常见组合的基本频率列表，即每个值频率的乘积。（当 &lt;code&gt;most_common_vals&lt;/code&gt; 为null时为null 。）</target>
        </trans-unit>
        <trans-unit id="c0a9903e8f4ef251af0eff5fa2455e175a7548a4" translate="yes" xml:space="preserve">
          <source>A list of the frequencies of the most common combinations, i.e., number of occurrences of each divided by total number of rows. (Null when &lt;code&gt;most_common_vals&lt;/code&gt; is.)</source>
          <target state="translated">最常见组合的频率列表，即每种组合的出现次数除以总行数。（当 &lt;code&gt;most_common_vals&lt;/code&gt; 为null时为null 。）</target>
        </trans-unit>
        <trans-unit id="527238c1ce219277abbb45386e199364181b4e39" translate="yes" xml:space="preserve">
          <source>A list of the frequencies of the most common element values, i.e., the fraction of rows containing at least one instance of the given value. Two or three additional values follow the per-element frequencies; these are the minimum and maximum of the preceding per-element frequencies, and optionally the frequency of null elements. (Null when &lt;code&gt;most_common_elems&lt;/code&gt; is.)</source>
          <target state="translated">最常见元素值的频率列表，即包含至少一个给定值实例的行的分数。每个元素频率跟随两个或三个附加值；这些是前面每个元素的频率的最小值和最大值，也可以是空元素的频率。（当 &lt;code&gt;most_common_elems&lt;/code&gt; 为null时为null 。）</target>
        </trans-unit>
        <trans-unit id="6973fe18397e6786beffdd562ca0c447ef38be82" translate="yes" xml:space="preserve">
          <source>A list of the frequencies of the most common values, i.e., number of occurrences of each divided by total number of rows. (Null when &lt;code&gt;most_common_vals&lt;/code&gt; is.)</source>
          <target state="translated">最常见值的频率列表，即每个值的出现次数除以总行数。（当 &lt;code&gt;most_common_vals&lt;/code&gt; 为null时为null 。）</target>
        </trans-unit>
        <trans-unit id="f63bcd58b43a4c5b783b6642ba5709e3ccbcb180" translate="yes" xml:space="preserve">
          <source>A list of the most common combinations of values in the columns. (Null if no combinations seem to be more common than any others.)</source>
          <target state="translated">各栏中最常见的数值组合列表,(如果没有任何组合比其他组合更常见,则为空)。(如果没有任何组合似乎比其他组合更常见,则为空。)</target>
        </trans-unit>
        <trans-unit id="7e7a21f80a86cbb3d663d9a6c19c5698cb32c935" translate="yes" xml:space="preserve">
          <source>A list of the most common values in the column. (Null if no values seem to be more common than any others.)</source>
          <target state="translated">列中最常见的值的列表。(如果没有任何数值似乎比其他数值更常见,则为空。)</target>
        </trans-unit>
        <trans-unit id="f5ec309be4a2c82919d5db6bbf83466f9afb0124" translate="yes" xml:space="preserve">
          <source>A list of values for the associated &lt;code&gt;filter_variable&lt;/code&gt; for which the trigger should fire. For &lt;code&gt;TAG&lt;/code&gt;, this means a list of command tags (e.g. &lt;code&gt;'DROP FUNCTION'&lt;/code&gt;).</source>
          <target state="translated">触发器应为其触发的关联 &lt;code&gt;filter_variable&lt;/code&gt; 的值的列表。对于 &lt;code&gt;TAG&lt;/code&gt; ，这意味着命令标签列表（例如 &lt;code&gt;'DROP FUNCTION'&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ff968df28749e5bcff327cac21b38ab15e60f682" translate="yes" xml:space="preserve">
          <source>A list of values for the associated &lt;code&gt;filter_variable&lt;/code&gt; for which the trigger should fire. For &lt;code&gt;TAG&lt;/code&gt;, this means a list of command tags (e.g., &lt;code&gt;'DROP FUNCTION'&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e4fe90764276ed140f41c638b69ba17b32d691f" translate="yes" xml:space="preserve">
          <source>A list of values that divide the column's values into groups of approximately equal population. The values in &lt;code&gt;most_common_vals&lt;/code&gt;, if present, are omitted from this histogram calculation. (This column is null if the column data type does not have a &lt;code&gt;&amp;lt;&lt;/code&gt; operator or if the &lt;code&gt;most_common_vals&lt;/code&gt; list accounts for the entire population.)</source>
          <target state="translated">值列表，将列的值划分为大致相等的总体。如果存在， &lt;code&gt;most_common_vals&lt;/code&gt; 中的值将从此直方图计算中省略。（如果列数据类型不具有 &lt;code&gt;&amp;lt;&lt;/code&gt; 运算符，或者 &lt;code&gt;most_common_vals&lt;/code&gt; 列表占整个填充量，则此列为null 。）</target>
        </trans-unit>
        <trans-unit id="ed9c3dd9d41fb7cb75cda90adbcd956a0d568298" translate="yes" xml:space="preserve">
          <source>A lock file recording the current postmaster process ID (PID), cluster data directory path, postmaster start timestamp, port number, Unix-domain socket directory path (could be empty), first valid listen_address (IP address or &lt;code&gt;*&lt;/code&gt;, or empty if not listening on TCP), and shared memory segment ID (this file is not present after server shutdown)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a40d49086dbccf43760fcf28e8592fb7682d6120" translate="yes" xml:space="preserve">
          <source>A lock file recording the current postmaster process ID (PID), cluster data directory path, postmaster start timestamp, port number, Unix-domain socket directory path (empty on Windows), first valid listen_address (IP address or &lt;code&gt;*&lt;/code&gt;, or empty if not listening on TCP), and shared memory segment ID (this file is not present after server shutdown)</source>
          <target state="translated">锁定文件，记录当前的postmaster进程ID（PID），群集数据目录路径，postmaster启动时间戳，端口号，Unix域套接字目录路径（在Windows上为空），第一个有效的listen_address（IP地址或 &lt;code&gt;*&lt;/code&gt; ；如果不是，则为空）侦听TCP）和共享内存段ID（服务器关闭后该文件不存在）</target>
        </trans-unit>
        <trans-unit id="66a4816dba1f7f218c3433fca4faabe3c13b10b2" translate="yes" xml:space="preserve">
          <source>A logical replication subscription can be a standby for synchronous replication (see &lt;a href=&quot;warm-standby#SYNCHRONOUS-REPLICATION&quot;&gt;Section 26.2.8&lt;/a&gt;). The standby name is by default the subscription name. An alternative name can be specified as &lt;code&gt;application_name&lt;/code&gt; in the connection information of the subscription.</source>
          <target state="translated">逻辑复制预订可以是同步复制的备用服务器（请参见&lt;a href=&quot;warm-standby#SYNCHRONOUS-REPLICATION&quot;&gt;第26.2.8节&lt;/a&gt;）。备用名称默认为订阅名称。可以在订阅的连接信息中将替代名称指定为 &lt;code&gt;application_name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fcc633543c398580321199fbfe8326677176cedc" translate="yes" xml:space="preserve">
          <source>A logical replication worker will be started to replicate data for the new subscription at the commit of the transaction where this command is run.</source>
          <target state="translated">在运行此命令的事务提交时,将启动一个逻辑复制工作者,为新订阅复制数据。</target>
        </trans-unit>
        <trans-unit id="0ff838ef761258a1112513121456f0155f8255d4" translate="yes" xml:space="preserve">
          <source>A low-level description of an individual data change. It contains sufficient information for the data change to be re-executed (&lt;em&gt;replayed&lt;/em&gt;) in case a system failure causes the change to be lost. WAL records use a non-printable binary format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60aa88a1c8ef8747220ad187c41c4e1174fc8b76" translate="yes" xml:space="preserve">
          <source>A master-standby replication setup sends all data modification queries to the master server. The master server asynchronously sends data changes to the standby server. The standby can answer read-only queries while the master server is running. The standby server is ideal for data warehouse queries.</source>
          <target state="translated">主备复制设置将所有数据修改查询发送到主服务器。主服务器异步将数据修改发送到备用服务器。备用服务器可以在主服务器运行时回答只读查询。备用服务器是数据仓库查询的理想选择。</target>
        </trans-unit>
        <trans-unit id="bb03b0cc86a8c8af01abf7c3fc42f075822f31ef" translate="yes" xml:space="preserve">
          <source>A means of identifying a &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;row&lt;/a&gt; within a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; or other &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; by values contained within one or more &lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;attributes&lt;/a&gt; in that relation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="030845a8e99966136eb3e489c254a79843ff0977" translate="yes" xml:space="preserve">
          <source>A means of representing data that is not contained in the local &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; so that it appears as if were in local &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table(s)&lt;/a&gt;. With a foreign data wrapper it is possible to define a &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-SERVER&quot;&gt;foreign server&lt;/a&gt; and &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-TABLE&quot;&gt;foreign tables&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5439dc35c023b011f3a3c74704c816d5906e3290" translate="yes" xml:space="preserve">
          <source>A means of restricting data in one &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; by a &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-KEY&quot;&gt;foreign key&lt;/a&gt; so that it must have matching data in another &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90a6939174ae7d3834abe5ab38f570dcd2acae81" translate="yes" xml:space="preserve">
          <source>A mechanism by which large attributes of table rows are split and stored in a secondary table, called the &lt;em&gt;TOAST table&lt;/em&gt;. Each relation with large attributes has its own TOAST table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0378f878c1722be034fadd027bbbb3d7983fc4d" translate="yes" xml:space="preserve">
          <source>A mechanism designed to allow several &lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;transactions&lt;/a&gt; to be reading and writing the same rows without one process causing other processes to stall. In PostgreSQL, MVCC is implemented by creating copies (&lt;em&gt;versions&lt;/em&gt;) of &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;tuples&lt;/a&gt; as they are modified; after transactions that can see the old versions terminate, those old versions need to be removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19c544cc7b4fa2f30c5d33aa71e0de0990d629df" translate="yes" xml:space="preserve">
          <source>A mechanism that allows a process to limit or prevent simultaneous access to a resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df6419859ed47f78b720bf1d7b110d267f1953f4" translate="yes" xml:space="preserve">
          <source>A message like:</source>
          <target state="translated">像这样的消息。</target>
        </trans-unit>
        <trans-unit id="917ffeb96cdfecb3f8736cd3bea86dd56c48ad27" translate="yes" xml:space="preserve">
          <source>A minimal sequence for creating a new procedural language is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0390b8c07f298b04ffb62c09de627ab67ceed13" translate="yes" xml:space="preserve">
          <source>A modified version of shared hardware functionality is file system replication, where all changes to a file system are mirrored to a file system residing on another computer. The only restriction is that the mirroring must be done in a way that ensures the standby server has a consistent copy of the file system &amp;mdash; specifically, writes to the standby must be done in the same order as those on the master. DRBD is a popular file system replication solution for Linux.</source>
          <target state="translated">共享硬件功能的修改版本是文件系统复制，其中对文件系统的所有更改都将镜像到另一台计算机上的文件系统。唯一的限制是必须以确保备用服务器具有文件系统的一致副本的方式进行镜像-特别是，写入备用数据库的顺序必须与主服务器上的顺序相同。DRBD是针对Linux的流行文件系统复制解决方案。</target>
        </trans-unit>
        <trans-unit id="eaf74e8b7bd2011db8b23c31e08c4d8c5dc7b496" translate="yes" xml:space="preserve">
          <source>A more complete example, which is directly useful for most European languages, can be found in &lt;code&gt;unaccent.rules&lt;/code&gt;, which is installed in &lt;code&gt;$SHAREDIR/tsearch_data/&lt;/code&gt; when the &lt;code&gt;unaccent&lt;/code&gt; module is installed. This rules file translates characters with accents to the same characters without accents, and it also expands ligatures into the equivalent series of simple characters (for example, &amp;AElig; to AE).</source>
          <target state="translated">一个更完整的例子，这是大多数欧洲语言直接有用，可以发现 &lt;code&gt;unaccent.rules&lt;/code&gt; ，它安装在 &lt;code&gt;$SHAREDIR/tsearch_data/&lt;/code&gt; 中时 &lt;code&gt;unaccent&lt;/code&gt; 安装模块。此规则文件将带重音符号的字符转换为不带重音符号的相同字符，并且还将连字扩展为等效的一系列简单字符（例如，&amp;AElig;到AE）。</target>
        </trans-unit>
        <trans-unit id="e62513d51117a7629a102ebbc4e62bd57c604e14" translate="yes" xml:space="preserve">
          <source>A more complex example is to select the ten most recent documents that contain &lt;code&gt;create&lt;/code&gt; and &lt;code&gt;table&lt;/code&gt; in the &lt;code&gt;title&lt;/code&gt; or &lt;code&gt;body&lt;/code&gt;:</source>
          <target state="translated">更复杂的例子是选择包含十个最近的文档 &lt;code&gt;create&lt;/code&gt; 和 &lt;code&gt;table&lt;/code&gt; 在 &lt;code&gt;title&lt;/code&gt; 或 &lt;code&gt;body&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a65faa0d2e1360aa9fc34743f49ee685ce803abe" translate="yes" xml:space="preserve">
          <source>A more complex view that does not satisfy all these conditions is read-only by default: the system will not allow an insert, update, or delete on the view. You can get the effect of an updatable view by creating &lt;code&gt;INSTEAD OF&lt;/code&gt; triggers on the view, which must convert attempted inserts, etc. on the view into appropriate actions on other tables. For more information see &lt;a href=&quot;sql-createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;. Another possibility is to create rules (see &lt;a href=&quot;sql-createrule&quot;&gt;CREATE RULE&lt;/a&gt;), but in practice triggers are easier to understand and use correctly.</source>
          <target state="translated">不满足所有这些条件的更复杂的视图默认情况下为只读：系统不允许在该视图上进行插入，更新或删除。您可以通过在视图上创建 &lt;code&gt;INSTEAD OF&lt;/code&gt; 触发器来获得可更新视图的效果，该触发器必须将视图上的尝试插入等转换为对其他表的适当操作。有关更多信息，请参见&lt;a href=&quot;sql-createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;。另一种可能性是创建规则（请参阅&lt;a href=&quot;sql-createrule&quot;&gt;CREATE RULE&lt;/a&gt;），但实际上触发器易于理解和正确使用。</target>
        </trans-unit>
        <trans-unit id="21c69ec8617bd0a23e27b4a22f876578e2ac2724" translate="yes" xml:space="preserve">
          <source>A multicharacter operator name cannot end in &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, unless the name also contains at least one of these characters:</source>
          <target state="translated">多字符运算符名称不能以 &lt;code&gt;+&lt;/code&gt; 或 &lt;code&gt;-&lt;/code&gt; 结尾，除非该名称还包含以下至少一个字符：</target>
        </trans-unit>
        <trans-unit id="763ddc64feb8cdfed8680a02b945f082cacaa6b2" translate="yes" xml:space="preserve">
          <source>A multicolumn B-tree index can be used with query conditions that involve any subset of the index's columns, but the index is most efficient when there are constraints on the leading (leftmost) columns. The exact rule is that equality constraints on leading columns, plus any inequality constraints on the first column that does not have an equality constraint, will be used to limit the portion of the index that is scanned. Constraints on columns to the right of these columns are checked in the index, so they save visits to the table proper, but they do not reduce the portion of the index that has to be scanned. For example, given an index on &lt;code&gt;(a, b, c)&lt;/code&gt; and a query condition &lt;code&gt;WHERE a = 5 AND b &amp;gt;= 42 AND c &amp;lt; 77&lt;/code&gt;, the index would have to be scanned from the first entry with &lt;code&gt;a&lt;/code&gt; = 5 and &lt;code&gt;b&lt;/code&gt; = 42 up through the last entry with &lt;code&gt;a&lt;/code&gt; = 5. Index entries with &lt;code&gt;c&lt;/code&gt; &amp;gt;= 77 would be skipped, but they'd still have to be scanned through. This index could in principle be used for queries that have constraints on &lt;code&gt;b&lt;/code&gt; and/or &lt;code&gt;c&lt;/code&gt; with no constraint on &lt;code&gt;a&lt;/code&gt; &amp;mdash; but the entire index would have to be scanned, so in most cases the planner would prefer a sequential table scan over using the index.</source>
          <target state="translated">多列B树索引可以与涉及索引列的任何子集的查询条件一起使用，但是当前导（最左边）列受到约束时，索引效率最高。确切的规则是，前导列上的相等约束，再加上第一列上没有相等约束的任何不相等约束，都将用于限制扫描的索引部分。在索引中检查了这些列右侧列的约束，因此它们可以适当地保存对表的访问，但不会减少索引中必须扫描的部分。例如，给定 &lt;code&gt;(a, b, c)&lt;/code&gt; 的索引和查询条件 &lt;code&gt;WHERE a = 5 AND b &amp;gt;= 42 AND c &amp;lt; 77&lt;/code&gt; ，则必须从第一个条目中使用 &lt;code&gt;a&lt;/code&gt; 扫描索引= 5和 &lt;code&gt;b&lt;/code&gt; = 42，直到最后 &lt;code&gt;a&lt;/code&gt; = 5的条目 &lt;code&gt;c&lt;/code&gt; &amp;gt; = 77的索引条目将被跳过，但仍必须对其进行扫描。原则上，该索引可用于对 &lt;code&gt;b&lt;/code&gt; 和/或 &lt;code&gt;c&lt;/code&gt; 有约束但对 &lt;code&gt;a&lt;/code&gt; 没有约束的查询，但是必须扫描整个索引，因此在大多数情况下，计划者宁愿使用顺序表扫描，也不愿使用索引。</target>
        </trans-unit>
        <trans-unit id="5fc5434281e629991ee555ca6201f316515a8d25" translate="yes" xml:space="preserve">
          <source>A multicolumn BRIN index can be used with query conditions that involve any subset of the index's columns. Like GIN and unlike B-tree or GiST, index search effectiveness is the same regardless of which index column(s) the query conditions use. The only reason to have multiple BRIN indexes instead of one multicolumn BRIN index on a single table is to have a different &lt;code&gt;pages_per_range&lt;/code&gt; storage parameter.</source>
          <target state="translated">多列BRIN索引可以与涉及该索引列的任何子集的查询条件一起使用。像GIN一样，与B树或GiST不同，无论查询条件使用哪个索引列，索引搜索的有效性都是相同的。在单个表上具有多个BRIN索引而不是一个多列BRIN索引的唯一原因是具有不同的 &lt;code&gt;pages_per_range&lt;/code&gt; 存储参数。</target>
        </trans-unit>
        <trans-unit id="04d3a962116670f39174cfb6d475fa11fdc7b880" translate="yes" xml:space="preserve">
          <source>A multicolumn GIN index can be used with query conditions that involve any subset of the index's columns. Unlike B-tree or GiST, index search effectiveness is the same regardless of which index column(s) the query conditions use.</source>
          <target state="translated">多列GIN索引可以与涉及索引列的任何子集的查询条件一起使用。与B-tree或GiST不同的是,无论查询条件使用哪一列索引,索引的搜索效果都是一样的。</target>
        </trans-unit>
        <trans-unit id="a40f443a6350a7a3a7b742a42955a0061cf6840b" translate="yes" xml:space="preserve">
          <source>A multicolumn GiST index can be used with query conditions that involve any subset of the index's columns. Conditions on additional columns restrict the entries returned by the index, but the condition on the first column is the most important one for determining how much of the index needs to be scanned. A GiST index will be relatively ineffective if its first column has only a few distinct values, even if there are many distinct values in additional columns.</source>
          <target state="translated">多列GiST索引可以使用涉及索引列的任何子集的查询条件。附加列上的条件会限制索引返回的条目,但第一列上的条件是决定索引需要扫描多少内容的最重要条件。如果一个GiST索引的第一列只有几个不同的值,那么它的索引将相对无效,即使附加列中有很多不同的值。</target>
        </trans-unit>
        <trans-unit id="61e3a968ac084ffcdbf2ee57ee023225a4c61ed4" translate="yes" xml:space="preserve">
          <source>A multiple-character operator name cannot end in &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, unless the name also contains at least one of these characters:</source>
          <target state="translated">多字符运算符名称不能以 &lt;code&gt;+&lt;/code&gt; 或 &lt;code&gt;-&lt;/code&gt; 结尾，除非该名称还包含以下至少一个字符：</target>
        </trans-unit>
        <trans-unit id="c34267e8f8081ad131049e90185ef07a4a593a2c" translate="yes" xml:space="preserve">
          <source>A name (without schema qualification) must be specified for each &lt;code&gt;WITH&lt;/code&gt; query. Optionally, a list of column names can be specified; if this is omitted, the column names are inferred from the subquery.</source>
          <target state="translated">必须为每个 &lt;code&gt;WITH&lt;/code&gt; 查询指定一个名称（无模式限定）。（可选）可以指定列名列表；如果省略此参数，则从子查询中推断出列名。</target>
        </trans-unit>
        <trans-unit id="6bf463ff31beb31d0372f0b1e73503dfa89eeca4" translate="yes" xml:space="preserve">
          <source>A name to use for a returned column.</source>
          <target state="translated">用于返回列的名称。</target>
        </trans-unit>
        <trans-unit id="272bf486701f1c7737a7b79a5df1a6cc7e2d076e" translate="yes" xml:space="preserve">
          <source>A named collection of &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-TABLE&quot;&gt;foreign tables&lt;/a&gt; which all use the same &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-DATA-WRAPPER&quot;&gt;foreign data wrapper&lt;/a&gt; and have other configuration values in common.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39c6fcfc35cb51a17f46343c3f38d154442e2627" translate="yes" xml:space="preserve">
          <source>A named collection of &lt;a href=&quot;glossary#GLOSSARY-SQL-OBJECT&quot;&gt;local SQL objects&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14bebfb5283ed66820e63249347863d7698ec1a3" translate="yes" xml:space="preserve">
          <source>A named location on the server file system. All &lt;a href=&quot;glossary#GLOSSARY-SQL-OBJECT&quot;&gt;SQL objects&lt;/a&gt; which require storage beyond their definition in the &lt;a href=&quot;glossary#GLOSSARY-SYSTEM-CATALOG&quot;&gt;system catalog&lt;/a&gt; must belong to a single tablespace. Initially, a database cluster contains a single usable tablespace which is used as the default for all SQL objects, called &lt;code&gt;pg_default&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c05611b43715c57dcc82e9a73dc2d7f3d8e3a806" translate="yes" xml:space="preserve">
          <source>A named variable. Its value can be set by the parameter &lt;em&gt;&lt;code&gt;vars&lt;/code&gt;&lt;/em&gt; of several JSON processing functions. See &lt;a href=&quot;functions-json#FUNCTIONS-JSON-PROCESSING-TABLE&quot;&gt;Table 9.47&lt;/a&gt; and its notes for details.</source>
          <target state="translated">命名变量。可以通过几个JSON处理函数的参数&lt;em&gt; &lt;code&gt;vars&lt;/code&gt; &lt;/em&gt;设置其值。有关详细信息，请&lt;a href=&quot;functions-json#FUNCTIONS-JSON-PROCESSING-TABLE&quot;&gt;参见表9.47&lt;/a&gt;及其注释。</target>
        </trans-unit>
        <trans-unit id="74fdd4598f86747d21b59f0ff46b91f71c06f897" translate="yes" xml:space="preserve">
          <source>A named variable. Its value can be set by the parameter &lt;em&gt;&lt;code&gt;vars&lt;/code&gt;&lt;/em&gt; of several JSON processing functions; see &lt;a href=&quot;functions-json#FUNCTIONS-JSON-PROCESSING-TABLE&quot;&gt;Table 9.47&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a91a5ad7df4feb45e2e64cef1252fbd5ff25b557" translate="yes" xml:space="preserve">
          <source>A new database object basically inherits the security label of the parent object, except when the security policy has special rules known as type-transition rules, in which case a different label may be applied. For schemas, the parent object is the current database; for tables, sequences, views, and functions, it is the containing schema; for columns, it is the containing table.</source>
          <target state="translated">新的数据库对象基本上继承了父对象的安全标签,除非安全策略有特殊的规则,称为类型转换规则,在这种情况下,可以应用不同的标签。对于模式来说,父对象是当前数据库;对于表、序列、视图和函数来说,是包含模式;对于列来说,是包含表。</target>
        </trans-unit>
        <trans-unit id="a69d7af9d66bab695fb9262e5704599a7bd6821d" translate="yes" xml:space="preserve">
          <source>A new heap entry is made before making its index entries. (Therefore a concurrent index scan is likely to fail to see the heap entry. This is okay because the index reader would be uninterested in an uncommitted row anyway. But see &lt;a href=&quot;index-unique-checks&quot;&gt;Section 61.5&lt;/a&gt;.)</source>
          <target state="translated">在创建其索引条目之前，将创建一个新的堆条目。（因此，并发索引扫描很可能无法看到堆条目。这是可以的，因为无论如何索引索引读取器对未提交的行都不感兴趣。但是请参见&lt;a href=&quot;index-unique-checks&quot;&gt;第61.5节&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="e9bfb94dcc9a12b2e365d8f54e18e6c8a60beb96" translate="yes" xml:space="preserve">
          <source>A new random session key is generated.</source>
          <target state="translated">一个新的随机会话密钥被生成。</target>
        </trans-unit>
        <trans-unit id="cd5509bd2e57840414a4b31d4dcfe1a53cd60297" translate="yes" xml:space="preserve">
          <source>A new temporary index definition is added to the catalog &lt;code&gt;pg_index&lt;/code&gt;. This definition will be used to replace the old index. A &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock at session level is taken on the indexes being reindexed as well as their associated tables to prevent any schema modification while processing.</source>
          <target state="translated">新的临时索引定义已添加到目录 &lt;code&gt;pg_index&lt;/code&gt; 中。此定义将用于替换旧索引。甲 &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; 在会话级锁采取索引被重新索引，以及它们的相关联的表，以防止在处理过程中的任何架构修改。</target>
        </trans-unit>
        <trans-unit id="e67b7984583e1c4ea079d2de00a7015a2704c63b" translate="yes" xml:space="preserve">
          <source>A new transient index definition is added to the catalog &lt;code&gt;pg_index&lt;/code&gt;. This definition will be used to replace the old index. A &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock at session level is taken on the indexes being reindexed as well as their associated tables to prevent any schema modification while processing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10ddb11c7f41b9fc173a0daee9b22a0046a88a72" translate="yes" xml:space="preserve">
          <source>A non-XML result assigned to an &lt;code&gt;xml&lt;/code&gt; output column produces content, a single text node with the string value of the result. An XML result assigned to a column of any other type may not have more than one node, or an error is raised. If there is exactly one node, the column will be set as if by assigning the node's string value (as defined for the XPath 1.0 &lt;code&gt;string&lt;/code&gt; function) to the PostgreSQL type.</source>
          <target state="translated">分配给 &lt;code&gt;xml&lt;/code&gt; 输出列的非XML结果产生内容，即带有结果字符串值的单个文本节点。分配给任何其他类型的列的XML结果最多只能有一个节点，否则会引发错误。如果仅存在一个节点，则将通过将节点的字符串值（为XPath 1.0 &lt;code&gt;string&lt;/code&gt; 函数定义）分配给PostgreSQL类型来设置该列。</target>
        </trans-unit>
        <trans-unit id="473219c281a2d874786237c92b0fcf8169682ead" translate="yes" xml:space="preserve">
          <source>A non-exclusive low level backup is one that allows other concurrent backups to be running (both those started using the same backup API and those started using &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt;).</source>
          <target state="translated">非排它的低级备份是一种允许其他并发备份运行的备份（使用相同备份API启动的备份和使用&lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt;启动的备份）。</target>
        </trans-unit>
        <trans-unit id="401550561965c2499f16ad6fd4b31c047d5f304a" translate="yes" xml:space="preserve">
          <source>A normal relationship between separately-created objects. The dependent object can be dropped without affecting the referenced object. The referenced object can only be dropped by specifying &lt;code&gt;CASCADE&lt;/code&gt;, in which case the dependent object is dropped, too. Example: a table column has a normal dependency on its data type.</source>
          <target state="translated">单独创建的对象之间的正常关系。可以删除从属对象，而不会影响引用的对象。只能通过指定 &lt;code&gt;CASCADE&lt;/code&gt; 删除引用的对象，在这种情况下，也要删除从属对象。示例：一个表列对其数据类型具有正常的依赖性。</target>
        </trans-unit>
        <trans-unit id="f4e6fa0c13024f923c36983ca255cb802f2a15dc" translate="yes" xml:space="preserve">
          <source>A not-null constraint is always written as a column constraint. A not-null constraint is functionally equivalent to creating a check constraint &lt;code&gt;CHECK (column_name IS NOT NULL)&lt;/code&gt;, but in PostgreSQL creating an explicit not-null constraint is more efficient. The drawback is that you cannot give explicit names to not-null constraints created this way.</source>
          <target state="translated">非空约束始终被写为列约束。非空约束在功能上等同于创建检查约束 &lt;code&gt;CHECK (column_name IS NOT NULL)&lt;/code&gt; ，但是在PostgreSQL中，创建显式非空约束更为有效。缺点是您不能为以此方式创建的非空约束指定显式名称。</target>
        </trans-unit>
        <trans-unit id="29e3f0f63dd403df874ec2bd2e2e99cfcbefc40b" translate="yes" xml:space="preserve">
          <source>A not-null constraint simply specifies that a column must not assume the null value. A syntax example:</source>
          <target state="translated">非空约束只是简单地指定了一个列不能使用空值。一个语法示例。</target>
        </trans-unit>
        <trans-unit id="38f215d8dff9a872adcc025cd248723a7de60a09" translate="yes" xml:space="preserve">
          <source>A number of probes or trace points are already inserted into the source code. These probes are intended to be used by database developers and administrators. By default the probes are not compiled into PostgreSQL; the user needs to explicitly tell the configure script to make the probes available.</source>
          <target state="translated">源代码中已经插入了一些探针或跟踪点。这些探针的目的是供数据库开发人员和管理员使用的,默认情况下,这些探针不会被编译到PostgreSQL中,用户需要明确地告诉configure脚本以使探针可用。默认情况下,这些探针不会被编译到PostgreSQL中;用户需要明确地告诉configure脚本使探针可用。</target>
        </trans-unit>
        <trans-unit id="62bf9b2e29dd2eab9640de99e0e28efaa651fde7" translate="yes" xml:space="preserve">
          <source>A number of standard probes are provided in the source code, as shown in &lt;a href=&quot;dynamic-trace#DTRACE-PROBE-POINT-TABLE&quot;&gt;Table 27.28&lt;/a&gt;; &lt;a href=&quot;dynamic-trace#TYPEDEFS-TABLE&quot;&gt;Table 27.29&lt;/a&gt; shows the types used in the probes. More probes can certainly be added to enhance PostgreSQL's observability.</source>
          <target state="translated">源代码中提供了许多标准探针，如&lt;a href=&quot;dynamic-trace#DTRACE-PROBE-POINT-TABLE&quot;&gt;表27.28&lt;/a&gt;所示；&lt;a href=&quot;dynamic-trace#TYPEDEFS-TABLE&quot;&gt;表27.29&lt;/a&gt;显示了探针中使用的类型。当然可以添加更多探针以增强PostgreSQL的可观察性。</target>
        </trans-unit>
        <trans-unit id="ae551e6f1a5e0e884b3ccb3cbfaaaffb2764ba8e" translate="yes" xml:space="preserve">
          <source>A number of standard probes are provided in the source code, as shown in &lt;a href=&quot;dynamic-trace#DTRACE-PROBE-POINT-TABLE&quot;&gt;Table 27.42&lt;/a&gt;; &lt;a href=&quot;dynamic-trace#TYPEDEFS-TABLE&quot;&gt;Table 27.43&lt;/a&gt; shows the types used in the probes. More probes can certainly be added to enhance PostgreSQL's observability.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83f77be94ef3c8feb2e598e753ef0750ef27c239" translate="yes" xml:space="preserve">
          <source>A number of these variables are treated specially by psql. They represent certain option settings that can be changed at run time by altering the value of the variable, or in some cases represent changeable state of psql. By convention, all specially treated variables' names consist of all upper-case ASCII letters (and possibly digits and underscores). To ensure maximum compatibility in the future, avoid using such variable names for your own purposes.</source>
          <target state="translated">其中有一些变量被psql特殊处理。它们代表某些选项设置,可以在运行时通过改变变量的值来改变,或者在某些情况下代表psql的可改变状态。按照惯例,所有经过特殊处理的变量的名称都由大写的ASCII字母组成(可能还有数字和下划线)。为了保证将来最大程度的兼容性,请避免使用这样的变量名来达到自己的目的。</target>
        </trans-unit>
        <trans-unit id="9671dc450d1031cf1ea5da7434a9e12abf1e8725" translate="yes" xml:space="preserve">
          <source>A numeric constant that contains neither a decimal point nor an exponent is initially presumed to be type &lt;code&gt;integer&lt;/code&gt; if its value fits in type &lt;code&gt;integer&lt;/code&gt; (32 bits); otherwise it is presumed to be type &lt;code&gt;bigint&lt;/code&gt; if its value fits in type &lt;code&gt;bigint&lt;/code&gt; (64 bits); otherwise it is taken to be type &lt;code&gt;numeric&lt;/code&gt;. Constants that contain decimal points and/or exponents are always initially presumed to be type &lt;code&gt;numeric&lt;/code&gt;.</source>
          <target state="translated">如果既不包含小数点也不包含指数的数字常量的值适合 &lt;code&gt;integer&lt;/code&gt; 类型（32位），则最初将其假定为 &lt;code&gt;integer&lt;/code&gt; 类型。否则，如果其值适合 &lt;code&gt;bigint&lt;/code&gt; 类型（64位），则假定它为 &lt;code&gt;bigint&lt;/code&gt; 类型；否则，假定为bigint类型。否则，将其视为 &lt;code&gt;numeric&lt;/code&gt; 类型。最初总是假定包含小数点和/或指数的常量为 &lt;code&gt;numeric&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="28053ae7864d70a55d085c051398ee367a8ba696" translate="yes" xml:space="preserve">
          <source>A numeric constant that specifies the length in bytes of the new type's internal representation. The default assumption is that it is variable-length.</source>
          <target state="translated">一个数字常数,指定新类型内部表示的字节长度。默认假设是可变长度。</target>
        </trans-unit>
        <trans-unit id="458377c420bfcead4a575e16d3cb5a525edf744e" translate="yes" xml:space="preserve">
          <source>A one-dimensional interval starting at &lt;code&gt;x&lt;/code&gt; and ending at &lt;code&gt;y&lt;/code&gt; or vice versa; the order does not matter</source>
          <target state="translated">一维间隔，从 &lt;code&gt;x&lt;/code&gt; 开始，到 &lt;code&gt;y&lt;/code&gt; ，反之亦然；顺序没关系</target>
        </trans-unit>
        <trans-unit id="258b20d113a4ac0002010f6811f02c8de89d74bf" translate="yes" xml:space="preserve">
          <source>A one-dimensional point (or, zero-length one-dimensional interval)</source>
          <target state="translated">一维点(或,零长一维区间)</target>
        </trans-unit>
        <trans-unit id="bc1071526f0987dbc584cef038787a5b04285bb1" translate="yes" xml:space="preserve">
          <source>A page image obtained with &lt;code&gt;get_raw_page&lt;/code&gt; should be passed as argument. For example:</source>
          <target state="translated">使用 &lt;code&gt;get_raw_page&lt;/code&gt; 获得的页面图像应作为参数传递。例如：</target>
        </trans-unit>
        <trans-unit id="5d8915a6b0933e1f5dc0f9cee0ae40fe953639a8" translate="yes" xml:space="preserve">
          <source>A parent table cannot be dropped while any of its children remain. Neither can columns or check constraints of child tables be dropped or altered if they are inherited from any parent tables. If you wish to remove a table and all of its descendants, one easy way is to drop the parent table with the &lt;code&gt;CASCADE&lt;/code&gt; option (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">在保留任何子表时，不能删除父表。如果子表是从任何父表继承的，则子表的列或检查约束都不能删除或更改。如果要删除表及其所有后代，一种简单的方法是使用 &lt;code&gt;CASCADE&lt;/code&gt; 选项删除父表（请参见&lt;a href=&quot;ddl-depend&quot;&gt;5.14节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b87d25eb2f25d2d484b24b9f4a15020854de03d4" translate="yes" xml:space="preserve">
          <source>A parent table to associate or de-associate with this foreign table.</source>
          <target state="translated">与这个外表关联或取消关联的父表。</target>
        </trans-unit>
        <trans-unit id="9038188b4e1e4e207e5656bab49c0b4bbe2840fb" translate="yes" xml:space="preserve">
          <source>A parent table to associate or de-associate with this table.</source>
          <target state="translated">与本表关联或取消关联的父表。</target>
        </trans-unit>
        <trans-unit id="bef9303e674e1152b39759a3ac4a051765f051a5" translate="yes" xml:space="preserve">
          <source>A partition must have the same column names and types as the partitioned table to which it belongs. Modifications to the column names or types of a partitioned table will automatically propagate to all partitions. &lt;code&gt;CHECK&lt;/code&gt; constraints will be inherited automatically by every partition, but an individual partition may specify additional &lt;code&gt;CHECK&lt;/code&gt; constraints; additional constraints with the same name and condition as in the parent will be merged with the parent constraint. Defaults may be specified separately for each partition.</source>
          <target state="translated">分区必须具有与其所属分区表相同的列名和类型。对分区表的列名或类型的修改将自动传播到所有分区。 &lt;code&gt;CHECK&lt;/code&gt; 约束将由每个分区自动继承，但是单个分区可以指定其他 &lt;code&gt;CHECK&lt;/code&gt; 约束。具有与父级中相同名称和条件的其他约束将与父级约束合并。可以为每个分区分别指定默认值。</target>
        </trans-unit>
        <trans-unit id="2b0fee0af770b0e2b7c1779ad6d02cf3f6e73981" translate="yes" xml:space="preserve">
          <source>A partition must have the same column names and types as the partitioned table to which it belongs. Modifications to the column names or types of a partitioned table will automatically propagate to all partitions. &lt;code&gt;CHECK&lt;/code&gt; constraints will be inherited automatically by every partition, but an individual partition may specify additional &lt;code&gt;CHECK&lt;/code&gt; constraints; additional constraints with the same name and condition as in the parent will be merged with the parent constraint. Defaults may be specified separately for each partition. But note that a partition's default value is not applied when inserting a tuple through a partitioned table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="753a83c5b7fc1757da85bcf15b0058b4367b5ffe" translate="yes" xml:space="preserve">
          <source>A partition using &lt;code&gt;FOR VALUES&lt;/code&gt; uses same syntax for &lt;code&gt;partition_bound_spec&lt;/code&gt; as &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;. The partition bound specification must correspond to the partitioning strategy and partition key of the target table. The table to be attached must have all the same columns as the target table and no more; moreover, the column types must also match. Also, it must have all the &lt;code&gt;NOT NULL&lt;/code&gt; and &lt;code&gt;CHECK&lt;/code&gt; constraints of the target table. Currently &lt;code&gt;FOREIGN KEY&lt;/code&gt; constraints are not considered. &lt;code&gt;UNIQUE&lt;/code&gt; and &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraints from the parent table will be created in the partition, if they don't already exist. If any of the &lt;code&gt;CHECK&lt;/code&gt; constraints of the table being attached are marked &lt;code&gt;NO INHERIT&lt;/code&gt;, the command will fail; such constraints must be recreated without the &lt;code&gt;NO INHERIT&lt;/code&gt; clause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2265efb683514f071f0b16aed28cd3bcc5853f6a" translate="yes" xml:space="preserve">
          <source>A partition using &lt;code&gt;FOR VALUES&lt;/code&gt; uses same syntax for &lt;code&gt;partition_bound_spec&lt;/code&gt; as &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;. The partition bound specification must correspond to the partitioning strategy and partition key of the target table. The table to be attached must have all the same columns as the target table and no more; moreover, the column types must also match. Also, it must have all the &lt;code&gt;NOT NULL&lt;/code&gt; and &lt;code&gt;CHECK&lt;/code&gt; constraints of the target table. Currently &lt;code&gt;FOREIGN KEY&lt;/code&gt; constraints are not considered. &lt;code&gt;UNIQUE&lt;/code&gt; and &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraints from the parent table will be created in the partition, if they don't already exist. If any of the &lt;code&gt;CHECK&lt;/code&gt; constraints of the table being attached is marked &lt;code&gt;NO INHERIT&lt;/code&gt;, the command will fail; such constraints must be recreated without the &lt;code&gt;NO INHERIT&lt;/code&gt; clause.</source>
          <target state="translated">使用一个分区 &lt;code&gt;FOR VALUES&lt;/code&gt; 使用的相同的语法 &lt;code&gt;partition_bound_spec&lt;/code&gt; 为&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;。分区绑定规范必须与目标表的分区策略和分区键相对应。要附加的表必须具有与目标表相同的所有列，并且不得更多。此外，列类型也必须匹配。而且，它必须具有目标表的所有 &lt;code&gt;NOT NULL&lt;/code&gt; 和 &lt;code&gt;CHECK&lt;/code&gt; 约束。当前不考虑 &lt;code&gt;FOREIGN KEY&lt;/code&gt; 约束。如果父表的 &lt;code&gt;UNIQUE&lt;/code&gt; 和 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 约束尚不存在，则会在分区中创建它们。如果有任何 &lt;code&gt;CHECK&lt;/code&gt; 被附加表的约束标记为 &lt;code&gt;NO INHERIT&lt;/code&gt; ，命令将失败；此类约束必须在没有 &lt;code&gt;NO INHERIT&lt;/code&gt; 子句的情况下重新创建。</target>
        </trans-unit>
        <trans-unit id="02bfa1f4284b2b7254a60122f0ece5c14ca3baa1" translate="yes" xml:space="preserve">
          <source>A partitioned table is divided into sub-tables (called partitions), which are created using separate &lt;code&gt;CREATE TABLE&lt;/code&gt; commands. The partitioned table is itself empty. A data row inserted into the table is routed to a partition based on the value of columns or expressions in the partition key. If no existing partition matches the values in the new row, an error will be reported.</source>
          <target state="translated">分区表分为多个子表（称为分区），这些子表是使用单独的 &lt;code&gt;CREATE TABLE&lt;/code&gt; 命令创建的。分区表本身为空。根据分区键中的列或表达式的值，将插入表中的数据行路由到分区。如果没有现有分区与新行中的值匹配，将报告错误。</target>
        </trans-unit>
        <trans-unit id="47bfb6365d874606167f5297b7825760e1b94998" translate="yes" xml:space="preserve">
          <source>A password is only significant if the client authentication method requires the user to supply a password when connecting to the database. The &lt;code&gt;password&lt;/code&gt; and &lt;code&gt;md5&lt;/code&gt; authentication methods make use of passwords. Database passwords are separate from operating system passwords. Specify a password upon role creation with &lt;code&gt;CREATE ROLE name PASSWORD 'string'&lt;/code&gt;.</source>
          <target state="translated">仅当客户端身份验证方法要求用户在连接数据库时提供密码时，密码才有意义。该 &lt;code&gt;password&lt;/code&gt; 和 &lt;code&gt;md5&lt;/code&gt; 认证方法使用口令。数据库密码与操作系统密码分开。创建角色时，请使用 &lt;code&gt;CREATE ROLE name PASSWORD 'string'&lt;/code&gt; 指定密码。</target>
        </trans-unit>
        <trans-unit id="35958631e7f174f767add77cc9815bb09387d918" translate="yes" xml:space="preserve">
          <source>A password that does not follow either of those formats is assumed to be unencrypted.</source>
          <target state="translated">不遵循上述任何一种格式的密码被认为是未加密的。</target>
        </trans-unit>
        <trans-unit id="ab9b8b43d3aed0e06f19d1971e9a5e5fb76320e8" translate="yes" xml:space="preserve">
          <source>A path expression can be a Boolean predicate, although the SQL/JSON standard allows predicates only in filters. This is necessary for implementation of the &lt;code&gt;@@&lt;/code&gt; operator. For example, the following &lt;code&gt;jsonpath&lt;/code&gt; expression is valid in PostgreSQL:</source>
          <target state="translated">路径表达式可以是布尔谓词，尽管SQL / JSON标准仅允许谓词出现在过滤器中。这对于实现 &lt;code&gt;@@&lt;/code&gt; 运算符是必需的。例如，以下 &lt;code&gt;jsonpath&lt;/code&gt; 表达式在PostgreSQL中有效：</target>
        </trans-unit>
        <trans-unit id="630b9b00d6c7d46f1803db83394a9ee4f3b0c93b" translate="yes" xml:space="preserve">
          <source>A path expression consists of a sequence of elements allowed by the &lt;code&gt;jsonpath&lt;/code&gt; data type. The path expression is evaluated from left to right, but you can use parentheses to change the order of operations. If the evaluation is successful, a sequence of SQL/JSON items (&lt;em&gt;SQL/JSON sequence&lt;/em&gt;) is produced, and the evaluation result is returned to the JSON query function that completes the specified computation.</source>
          <target state="translated">路径表达式由 &lt;code&gt;jsonpath&lt;/code&gt; 数据类型允许的一系列元素组成。路径表达式是从左到右计算的，但是您可以使用括号来更改操作顺序。如果评估成功，则将生成一个SQL / JSON项目&lt;em&gt;序列&lt;/em&gt;（&lt;em&gt;SQL / JSON sequence&lt;/em&gt;），并将评估结果返回到JSON查询函数，以完成指定的计算。</target>
        </trans-unit>
        <trans-unit id="87f4c54faa8f7479fd0c8926b062c01e3b7b2498" translate="yes" xml:space="preserve">
          <source>A path expression consists of a sequence of elements allowed by the &lt;code&gt;jsonpath&lt;/code&gt; data type. The path expression is normally evaluated from left to right, but you can use parentheses to change the order of operations. If the evaluation is successful, a sequence of JSON items is produced, and the evaluation result is returned to the JSON query function that completes the specified computation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="419a53a9c84f96a1644ee859a8c3c016a2c745c2" translate="yes" xml:space="preserve">
          <source>A path expression consists of a sequence of path elements, which can be any of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b906a3261066476a4e478667be529d451288613" translate="yes" xml:space="preserve">
          <source>A path expression consists of a sequence of path elements, which can be the following:</source>
          <target state="translated">路径表达式由一系列路径元素组成,可以是以下几种。</target>
        </trans-unit>
        <trans-unit id="46a75a9a8ee3f1ff5de45744e068475e9be0d81b" translate="yes" xml:space="preserve">
          <source>A pattern that contains a dot (&lt;code&gt;.&lt;/code&gt;) is interpreted as a schema name pattern followed by an object name pattern. For example, &lt;code&gt;\dt foo*.*bar*&lt;/code&gt; displays all tables whose table name includes &lt;code&gt;bar&lt;/code&gt; that are in schemas whose schema name starts with &lt;code&gt;foo&lt;/code&gt;. When no dot appears, then the pattern matches only objects that are visible in the current schema search path. Again, a dot within double quotes loses its special meaning and is matched literally.</source>
          <target state="translated">包含点（ &lt;code&gt;.&lt;/code&gt; ）的模式被解释为架构名称模式，后跟对象名称模式。例如， &lt;code&gt;\dt foo*.*bar*&lt;/code&gt; 显示所有表名包含 &lt;code&gt;bar&lt;/code&gt; 的表，这些表的模式名以 &lt;code&gt;foo&lt;/code&gt; 开头。如果没有点出现，则该模式仅匹配在当前模式搜索路径中可见的对象。同样，双引号中的点失去其特殊含义，并且在字面上匹配。</target>
        </trans-unit>
        <trans-unit id="e2fdd324df9af943d98a0446644b1732be556666" translate="yes" xml:space="preserve">
          <source>A physical file which stores data for a given &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt;. File segments are limited in size by a configuration value (typically 1 gigabyte), so if a relation exceeds that size, it is split into multiple segments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5474357c1efadc094c42e8ca5e1d158c9c8724d2" translate="yes" xml:space="preserve">
          <source>A plain integer denotes a day of the year, counting from zero to 364, or to 365 in leap years.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7897c4bbe5ec9cccaaddf1f6c43de7d3f2aaad08" translate="yes" xml:space="preserve">
          <source>A point in n-dimensional space, represented internally as a zero-volume cube</source>
          <target state="translated">n维空间中的一个点,内部表示为一个零体积的立方体。</target>
        </trans-unit>
        <trans-unit id="45445178529cbc6647ad679b1b5ca9fd7c3a49b9" translate="yes" xml:space="preserve">
          <source>A point in the &lt;a href=&quot;glossary#GLOSSARY-WAL&quot;&gt;WAL&lt;/a&gt; sequence at which it is guaranteed that the heap and index data files have been updated with all information from &lt;a href=&quot;glossary#GLOSSARY-SHARED-MEMORY&quot;&gt;shared memory&lt;/a&gt; modified before that checkpoint; a &lt;em&gt;checkpoint record&lt;/em&gt; is written and flushed to WAL to mark that point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4b7209c416eb8b0cd4ad3c6e895e2f5e59edbd1" translate="yes" xml:space="preserve">
          <source>A policy grants the permission to select, insert, update, or delete rows that match the relevant policy expression. Existing table rows are checked against the expression specified in &lt;code&gt;USING&lt;/code&gt;, while new rows that would be created via &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; are checked against the expression specified in &lt;code&gt;WITH CHECK&lt;/code&gt;. When a &lt;code&gt;USING&lt;/code&gt; expression returns true for a given row then that row is visible to the user, while if false or null is returned then the row is not visible. When a &lt;code&gt;WITH CHECK&lt;/code&gt; expression returns true for a row then that row is inserted or updated, while if false or null is returned then an error occurs.</source>
          <target state="translated">策略授予选择，插入，更新或删除与相关策略表达式匹配的行的权限。现有表行将根据 &lt;code&gt;USING&lt;/code&gt; 中指定的表达式进行检查，而将通过 &lt;code&gt;INSERT&lt;/code&gt; 或 &lt;code&gt;UPDATE&lt;/code&gt; 创建的新行将 &lt;code&gt;WITH CHECK&lt;/code&gt; 指定的表达式进行检查。当 &lt;code&gt;USING&lt;/code&gt; 表达式对于给定的行返回true时，则该行对用户可见；而如果返回false或null，则该行不可见。当 &lt;code&gt;WITH CHECK&lt;/code&gt; 表达式的一行返回true时，该行将被插入或更新，而如果返回false或null则将发生错误。</target>
        </trans-unit>
        <trans-unit id="f8e613dc0d26e68918f83658070562d9898412d1" translate="yes" xml:space="preserve">
          <source>A position normally indicates the source word's location in the document. Positional information can be used for &lt;em&gt;proximity ranking&lt;/em&gt;. Position values can range from 1 to 16383; larger numbers are silently set to 16383. Duplicate positions for the same lexeme are discarded.</source>
          <target state="translated">位置通常指示源单词在文档中的位置。位置信息可用于&lt;em&gt;邻近度排名&lt;/em&gt;。位置值的范围是1到16383；较大的数字将默默地设置为16383。相同词素的重复位置将被丢弃。</target>
        </trans-unit>
        <trans-unit id="8124e08cb675a3763a841977baebeafd4db084c2" translate="yes" xml:space="preserve">
          <source>A positional parameter reference is used to indicate a value that is supplied externally to an SQL statement. Parameters are used in SQL function definitions and in prepared queries. Some client libraries also support specifying data values separately from the SQL command string, in which case parameters are used to refer to the out-of-line data values. The form of a parameter reference is:</source>
          <target state="translated">位置参数引用用于指示从外部提供给SQL语句的值。在SQL函数定义和准备好的查询中都会用到参数。有些客户端库还支持从SQL命令串中单独指定数据值,在这种情况下,参数用于引用行外数据值。参数引用的形式是</target>
        </trans-unit>
        <trans-unit id="3833bdb7ea9a948094cad484b196a53403718838" translate="yes" xml:space="preserve">
          <source>A positional parameter reference, in the body of a function definition or prepared statement</source>
          <target state="translated">在函数定义或准备好的语句中的位置参数引用。</target>
        </trans-unit>
        <trans-unit id="0f115ce95e27f153df6502e75df85ece7a17f10c" translate="yes" xml:space="preserve">
          <source>A positive number giving the estimated execution cost for the function, in units of &lt;a href=&quot;runtime-config-query#GUC-CPU-OPERATOR-COST&quot;&gt;cpu_operator_cost&lt;/a&gt;. If the function returns a set, this is the cost per returned row. If the cost is not specified, 1 unit is assumed for C-language and internal functions, and 100 units for functions in all other languages. Larger values cause the planner to try to avoid evaluating the function more often than necessary.</source>
          <target state="translated">一个正数，给出该函数的估计执行成本，以&lt;a href=&quot;runtime-config-query#GUC-CPU-OPERATOR-COST&quot;&gt;cpu_operator_cost&lt;/a&gt;为单位。如果函数返回一个集合，则这是返回的每一行的成本。如果未指定成本，则C语言和内部功能的单位为1个单位，所有其他语言的功能的单位为100个单位。较大的值会使计划人员尝试避免不必要地评估函数。</target>
        </trans-unit>
        <trans-unit id="30c1a79cbb9484177e363d4544efe87e3e39ffa7" translate="yes" xml:space="preserve">
          <source>A positive number giving the estimated number of rows that the planner should expect the function to return. This is only allowed when the function is declared to return a set. The default assumption is 1000 rows.</source>
          <target state="translated">一个正数,表示规划者期望函数返回的行数。只有当函数被声明为返回一个集合时,才允许使用这个数字。默认假设是1000行。</target>
        </trans-unit>
        <trans-unit id="02f79e462db5425b448e96c1072a3f594c31942d" translate="yes" xml:space="preserve">
          <source>A possible query to use this index would be:</source>
          <target state="translated">使用该索引的一个可能的查询是。</target>
        </trans-unit>
        <trans-unit id="a46068a086ffe6678122c2b4a804a11dab670aaa" translate="yes" xml:space="preserve">
          <source>A prepared statement can be executed with either a &lt;em&gt;generic plan&lt;/em&gt; or a &lt;em&gt;custom plan&lt;/em&gt;. A generic plan is the same across all executions, while a custom plan is generated for a specific execution using the parameter values given in that call. Use of a generic plan avoids planning overhead, but in some situations a custom plan will be much more efficient to execute because the planner can make use of knowledge of the parameter values. (Of course, if the prepared statement has no parameters, then this is moot and a generic plan is always used.)</source>
          <target state="translated">可以使用&lt;em&gt;通用计划&lt;/em&gt;或&lt;em&gt;定制计划&lt;/em&gt;来执行准备好的语句。通用计划在所有执行中都是相同的，而使用该调用中给定的参数值为特定执行生成自定义计划。使用通用计划可以避免计划开销，但是在某些情况下，自定义计划的执行效率会更高，因为计划者可以利用参数值的知识。（当然，如果准备好的语句没有参数，那么这很无聊，并且始终使用通用计划。）</target>
        </trans-unit>
        <trans-unit id="13348ea1ec457fbeed4d2620cc50c2e7f85fa0ae" translate="yes" xml:space="preserve">
          <source>A primary key constraint indicates that a column, or group of columns, can be used as a unique identifier for rows in the table. This requires that the values be both unique and not null. So, the following two table definitions accept the same data:</source>
          <target state="translated">主键约束表示一列或一组列可以作为表中行的唯一标识符。这就要求值既要唯一,又不能为空。所以,下面两个表定义接受相同的数据。</target>
        </trans-unit>
        <trans-unit id="3f893762c520af1aa49b543485b038d4cb74971c" translate="yes" xml:space="preserve">
          <source>A procedural language call handler is declared to return &lt;code&gt;language_handler&lt;/code&gt;.</source>
          <target state="translated">声明了过程语言调用处理程序以返回 &lt;code&gt;language_handler&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="85b471a8bbdcb0184dcaf026b542b9d1c7608b3f" translate="yes" xml:space="preserve">
          <source>A process that saves copies of &lt;a href=&quot;glossary#GLOSSARY-WAL-FILE&quot;&gt;WAL files&lt;/a&gt; for the purpose of creating backups or keeping &lt;a href=&quot;glossary#GLOSSARY-REPLICA&quot;&gt;replicas&lt;/a&gt; current.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68348e6f47688291dbdf76ea9ce04384d5ed5818" translate="yes" xml:space="preserve">
          <source>A process that writes &lt;a href=&quot;glossary#GLOSSARY-WAL-RECORD&quot;&gt;WAL records&lt;/a&gt; from &lt;a href=&quot;glossary#GLOSSARY-SHARED-MEMORY&quot;&gt;shared memory&lt;/a&gt; to &lt;a href=&quot;glossary#GLOSSARY-WAL-FILE&quot;&gt;WAL files&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df87a47e5d11566e3968df708fe83a96d24cbb48" translate="yes" xml:space="preserve">
          <source>A process that writes dirty &lt;a href=&quot;glossary#GLOSSARY-DATA-PAGE&quot;&gt;data pages&lt;/a&gt; from &lt;a href=&quot;glossary#GLOSSARY-SHARED-MEMORY&quot;&gt;shared memory&lt;/a&gt; to the file system. It wakes up periodically, but works only for a short period in order to distribute its expensive I/O activity over time to avoid generating larger I/O peaks which could block other processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b598946555659e8de8862e7df2ae169d900a0d4a" translate="yes" xml:space="preserve">
          <source>A publication can only be dropped by its owner or a superuser.</source>
          <target state="translated">出版物只能由其所有者或超级用户放弃。</target>
        </trans-unit>
        <trans-unit id="ba53206c029e2edfae51f727e267685bcdf05085" translate="yes" xml:space="preserve">
          <source>A publication is created using the &lt;a href=&quot;sql-createpublication&quot;&gt;CREATE PUBLICATION&lt;/a&gt; command and may later be altered or dropped using corresponding commands.</source>
          <target state="translated">使用&lt;a href=&quot;sql-createpublication&quot;&gt;CREATE PUBLICATION&lt;/a&gt;命令创建发布，以后可以使用相应的命令更改或删除发布。</target>
        </trans-unit>
        <trans-unit id="c9ab2d1b430251390fd77666a59dc72c11f11cfe" translate="yes" xml:space="preserve">
          <source>A publication is essentially a group of tables whose data changes are intended to be replicated through logical replication. See &lt;a href=&quot;logical-replication-publication&quot;&gt;Section 30.1&lt;/a&gt; for details about how publications fit into the logical replication setup.</source>
          <target state="translated">发布实际上是一组表，其数据更改旨在通过逻辑复制进行复制。有关发布如何适合逻辑复制设置的详细信息，请参见&lt;a href=&quot;logical-replication-publication&quot;&gt;30.1节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e2338433bd110932bcc29150142a24f592f4dfbb" translate="yes" xml:space="preserve">
          <source>A published table must have a &amp;ldquo;replica identity&amp;rdquo; configured in order to be able to replicate &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; operations, so that appropriate rows to update or delete can be identified on the subscriber side. By default, this is the primary key, if there is one. Another unique index (with certain additional requirements) can also be set to be the replica identity. If the table does not have any suitable key, then it can be set to replica identity &amp;ldquo;full&amp;rdquo;, which means the entire row becomes the key. This, however, is very inefficient and should only be used as a fallback if no other solution is possible. If a replica identity other than &amp;ldquo;full&amp;rdquo; is set on the publisher side, a replica identity comprising the same or fewer columns must also be set on the subscriber side. See &lt;a href=&quot;sql-altertable#SQL-CREATETABLE-REPLICA-IDENTITY&quot;&gt;&lt;code&gt;REPLICA IDENTITY&lt;/code&gt;&lt;/a&gt; for details on how to set the replica identity. If a table without a replica identity is added to a publication that replicates &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; operations then subsequent &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; operations will cause an error on the publisher. &lt;code&gt;INSERT&lt;/code&gt; operations can proceed regardless of any replica identity.</source>
          <target state="translated">已发布的表必须具有配置的&amp;ldquo;副本身份&amp;rdquo;，以便能够复制 &lt;code&gt;UPDATE&lt;/code&gt; 和 &lt;code&gt;DELETE&lt;/code&gt; 操作，以便可以在订户侧标识要更新或删除的适当行。默认情况下，这是主键（如果有）。另一个唯一索引（具有某些其他要求）也可以设置为副本身份。如果该表没有任何合适的键，则可以将其设置为副本标识&amp;ldquo; full&amp;rdquo;，这意味着整行成为键。但是，这是非常低效的，只有在没有其他解决方案可行的情况下，才应将其用作备用。如果在发布者侧设置了除&amp;ldquo;完整&amp;rdquo;以外的副本身份，则还必须在订户侧设置包含相同或更少列的副本身份。看到&lt;a href=&quot;sql-altertable#SQL-CREATETABLE-REPLICA-IDENTITY&quot;&gt; &lt;code&gt;REPLICA IDENTITY&lt;/code&gt; ,&lt;/a&gt;以获取有关如何设置副本身份的详细信息。如果将没有副本身份的表添加到复制 &lt;code&gt;UPDATE&lt;/code&gt; 或 &lt;code&gt;DELETE&lt;/code&gt; 操作的发布中，则后续的 &lt;code&gt;UPDATE&lt;/code&gt; 或 &lt;code&gt;DELETE&lt;/code&gt; 操作将在发布者上引起错误。 &lt;code&gt;INSERT&lt;/code&gt; 操作可以继续进行，而不考虑任何副本身份。</target>
        </trans-unit>
        <trans-unit id="0fa8cd1ec75091ae1b152072de83438ac13c7ac1" translate="yes" xml:space="preserve">
          <source>A quantified atom is an &lt;em&gt;atom&lt;/em&gt; possibly followed by a single &lt;em&gt;quantifier&lt;/em&gt;. Without a quantifier, it matches a match for the atom. With a quantifier, it can match some number of matches of the atom. An &lt;em&gt;atom&lt;/em&gt; can be any of the possibilities shown in &lt;a href=&quot;functions-matching#POSIX-ATOMS-TABLE&quot;&gt;Table 9.16&lt;/a&gt;. The possible quantifiers and their meanings are shown in &lt;a href=&quot;functions-matching#POSIX-QUANTIFIERS-TABLE&quot;&gt;Table 9.17&lt;/a&gt;.</source>
          <target state="translated">量化的原子是可能跟着单个&lt;em&gt;量词&lt;/em&gt;的&lt;em&gt;原子&lt;/em&gt;。没有量词，它将匹配原子的匹配项。使用量词，它可以匹配原子的一些匹配项。一个&lt;em&gt;原子&lt;/em&gt;可以是任何的在示出的可能性&lt;a href=&quot;functions-matching#POSIX-ATOMS-TABLE&quot;&gt;表9.16&lt;/a&gt;。&lt;a href=&quot;functions-matching#POSIX-QUANTIFIERS-TABLE&quot;&gt;表9.17&lt;/a&gt;列出了可能的量词及其含义。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fc21709c3a9df27bc9570d7ce18a8b13da68c2a0" translate="yes" xml:space="preserve">
          <source>A quantified atom is an &lt;em&gt;atom&lt;/em&gt; possibly followed by a single &lt;em&gt;quantifier&lt;/em&gt;. Without a quantifier, it matches a match for the atom. With a quantifier, it can match some number of matches of the atom. An &lt;em&gt;atom&lt;/em&gt; can be any of the possibilities shown in &lt;a href=&quot;functions-matching#POSIX-ATOMS-TABLE&quot;&gt;Table 9.17&lt;/a&gt;. The possible quantifiers and their meanings are shown in &lt;a href=&quot;functions-matching#POSIX-QUANTIFIERS-TABLE&quot;&gt;Table 9.18&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14b90372a7f382e1ebe5fbc1067a98d78caf7059" translate="yes" xml:space="preserve">
          <source>A quantified atom with a fixed-repetition quantifier (&lt;code&gt;{&lt;/code&gt;&lt;code&gt;m&lt;/code&gt;&lt;code&gt;}&lt;/code&gt; or &lt;code&gt;{&lt;/code&gt;&lt;code&gt;m&lt;/code&gt;&lt;code&gt;}?&lt;/code&gt;) has the same greediness (possibly none) as the atom itself.</source>
          <target state="translated">具有固定重复量词（ &lt;code&gt;{&lt;/code&gt; &lt;code&gt;m&lt;/code&gt; &lt;code&gt;}&lt;/code&gt; 或 &lt;code&gt;{&lt;/code&gt; &lt;code&gt;m&lt;/code&gt; &lt;code&gt;}?&lt;/code&gt; ）的量化原子与原子本身具有相同的贪婪性（可能没有）。</target>
        </trans-unit>
        <trans-unit id="d2086c7d3f841e613b77902ebf9e5b97e2cde610" translate="yes" xml:space="preserve">
          <source>A quantified atom with a non-greedy quantifier (including &lt;code&gt;{&lt;/code&gt;&lt;code&gt;m&lt;/code&gt;&lt;code&gt;,&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;&lt;code&gt;}?&lt;/code&gt; with &lt;code&gt;m&lt;/code&gt; equal to &lt;code&gt;n&lt;/code&gt;) is non-greedy (prefers shortest match).</source>
          <target state="translated">具有非贪婪量词（包括 &lt;code&gt;{&lt;/code&gt; &lt;code&gt;m&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; &lt;code&gt;}?&lt;/code&gt; 且 &lt;code&gt;m&lt;/code&gt; 等于 &lt;code&gt;n&lt;/code&gt; ）的量化原子是非贪婪的（首选最短匹配）。</target>
        </trans-unit>
        <trans-unit id="044befe289d741f6adb775e3119a52c47ef4c4c1" translate="yes" xml:space="preserve">
          <source>A quantified atom with other normal quantifiers (including &lt;code&gt;{&lt;/code&gt;&lt;code&gt;m&lt;/code&gt;&lt;code&gt;,&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;&lt;code&gt;}&lt;/code&gt; with &lt;code&gt;m&lt;/code&gt; equal to &lt;code&gt;n&lt;/code&gt;) is greedy (prefers longest match).</source>
          <target state="translated">与其他正常量词（包括A量化原子 &lt;code&gt;{&lt;/code&gt; &lt;code&gt;m&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; &lt;code&gt;}&lt;/code&gt; 与 &lt;code&gt;m&lt;/code&gt; 等于 &lt;code&gt;n&lt;/code&gt; ）是贪婪（喜欢最长匹配）。</target>
        </trans-unit>
        <trans-unit id="b0376c8a695cc9a8414ca39502c5036b915645c0" translate="yes" xml:space="preserve">
          <source>A quantifier cannot immediately follow another quantifier, e.g., &lt;code&gt;**&lt;/code&gt; is invalid. A quantifier cannot begin an expression or subexpression or follow &lt;code&gt;^&lt;/code&gt; or &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">量词不能立即跟在另一个量词之后，例如 &lt;code&gt;**&lt;/code&gt; 无效。量词不能开始表达式或子表达式，也不能跟随 &lt;code&gt;^&lt;/code&gt; 或 &lt;code&gt;|&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4fb059cdfd53bb422968b17a105f57bd04f411c" translate="yes" xml:space="preserve">
          <source>A query (&lt;code&gt;SELECT&lt;/code&gt; statement) that supplies the rows to be inserted. Refer to the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; statement for a description of the syntax.</source>
          <target state="translated">提供要插入的行的查询（ &lt;code&gt;SELECT&lt;/code&gt; 语句）。有关语法的说明，请参见&lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;语句。</target>
        </trans-unit>
        <trans-unit id="f6cba9f4354114ea501407f47fa13c76eb60151c" translate="yes" xml:space="preserve">
          <source>A query can be &amp;ldquo;qualified&amp;rdquo; by adding a &lt;code&gt;WHERE&lt;/code&gt; clause that specifies which rows are wanted. The &lt;code&gt;WHERE&lt;/code&gt; clause contains a Boolean (truth value) expression, and only rows for which the Boolean expression is true are returned. The usual Boolean operators (&lt;code&gt;AND&lt;/code&gt;, &lt;code&gt;OR&lt;/code&gt;, and &lt;code&gt;NOT&lt;/code&gt;) are allowed in the qualification. For example, the following retrieves the weather of San Francisco on rainy days:</source>
          <target state="translated">通过添加指定需要哪些行的 &lt;code&gt;WHERE&lt;/code&gt; 子句，可以&amp;ldquo;限定&amp;rdquo;查询。的 &lt;code&gt;WHERE&lt;/code&gt; 子句包含一个布尔值（真值）的表达，并且仅行的量，布尔表达式为真的被返回。限定条件中允许使用常规布尔运算符（ &lt;code&gt;AND&lt;/code&gt; ， &lt;code&gt;OR&lt;/code&gt; 和 &lt;code&gt;NOT&lt;/code&gt; ）。例如，以下内容检索雨天的旧金山天气：</target>
        </trans-unit>
        <trans-unit id="a3f98fa3c0d12a208eadd01d5ce05b0ffde908aa" translate="yes" xml:space="preserve">
          <source>A read-only SQL transaction cannot alter non-temporary tables. This parameter controls the default read-only status of each new transaction. The default is &lt;code&gt;off&lt;/code&gt; (read/write).</source>
          <target state="translated">只读SQL事务不能更改非临时表。此参数控制每个新事务的默认只读状态。默认为 &lt;code&gt;off&lt;/code&gt; （读/写）。</target>
        </trans-unit>
        <trans-unit id="4a7841fe30d1103325f6249de23cba34804bfa4e" translate="yes" xml:space="preserve">
          <source>A reader should report an error if a field-count word is neither -1 nor the expected number of columns. This provides an extra check against somehow getting out of sync with the data.</source>
          <target state="translated">如果一个字段计数字既不是-1,也不是预期的列数,读者应该报告一个错误。这提供了一个额外的检查,防止以某种方式与数据不同步。</target>
        </trans-unit>
        <trans-unit id="fddf89d1b48df3d1a7d816db398c1f9bc279cad0" translate="yes" xml:space="preserve">
          <source>A record can have one of the seven formats</source>
          <target state="translated">一条记录可以有以下七种格式之一</target>
        </trans-unit>
        <trans-unit id="755da3745b4f352a5f0983d774febfd9dd4f8a2e" translate="yes" xml:space="preserve">
          <source>A record can have several formats:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b600abb4523a0f2e29ac983d05c8a91aade45f9" translate="yes" xml:space="preserve">
          <source>A recursive &lt;code&gt;DROP COLUMN&lt;/code&gt; operation will remove a descendant table's column only if the descendant does not inherit that column from any other parents and never had an independent definition of the column. A nonrecursive &lt;code&gt;DROP COLUMN&lt;/code&gt; (i.e., &lt;code&gt;ALTER TABLE ONLY ... DROP COLUMN&lt;/code&gt;) never removes any descendant columns, but instead marks them as independently defined rather than inherited. A nonrecursive &lt;code&gt;DROP COLUMN&lt;/code&gt; command will fail for a partitioned table, because all partitions of a table must have the same columns as the partitioning root.</source>
          <target state="translated">仅当后代没有从任何其他父级继承该列并且从未拥有该列的独立定义时，递归 &lt;code&gt;DROP COLUMN&lt;/code&gt; 操作才会删除该后代表的列。非递归的 &lt;code&gt;DROP COLUMN&lt;/code&gt; （即， &lt;code&gt;ALTER TABLE ONLY ... DROP COLUMN&lt;/code&gt; ）从不删除任何后代列，而是将它们标记为独立定义而不是继承。对于分区表，非递归 &lt;code&gt;DROP COLUMN&lt;/code&gt; 命令将失败，因为表的所有分区必须具有与分区根相同的列。</target>
        </trans-unit>
        <trans-unit id="c8e116c04f64e1769d84da7554d28932fe4d3963" translate="yes" xml:space="preserve">
          <source>A regular expression is a character sequence that is an abbreviated definition of a set of strings (a &lt;em&gt;regular set&lt;/em&gt;). A string is said to match a regular expression if it is a member of the regular set described by the regular expression. As with &lt;code&gt;LIKE&lt;/code&gt;, pattern characters match string characters exactly unless they are special characters in the regular expression language &amp;mdash; but regular expressions use different special characters than &lt;code&gt;LIKE&lt;/code&gt; does. Unlike &lt;code&gt;LIKE&lt;/code&gt; patterns, a regular expression is allowed to match anywhere within a string, unless the regular expression is explicitly anchored to the beginning or end of the string.</source>
          <target state="translated">正则表达式是一个字符序列，它是一组字符串（一个&lt;em&gt;正则集&lt;/em&gt;）的缩写定义。如果字符串是正则表达式描述的正则集的成员，则认为该字符串与正则表达式匹配。与 &lt;code&gt;LIKE&lt;/code&gt; 一样，模式字符完全匹配字符串字符，除非它们是正则表达式语言中的特殊字符-但是正则表达式使用的特殊字符与 &lt;code&gt;LIKE&lt;/code&gt; 不同。与 &lt;code&gt;LIKE&lt;/code&gt; 模式不同，除非将正则表达式明确地锚定到字符串的开头或结尾，否则允许在字符串中的任何位置匹配正则表达式。</target>
        </trans-unit>
        <trans-unit id="8bcf2029d3dfa5827a2882665f99b1d027b1662c" translate="yes" xml:space="preserve">
          <source>A regular expression is defined as one or more &lt;em&gt;branches&lt;/em&gt;, separated by &lt;code&gt;|&lt;/code&gt;. It matches anything that matches one of the branches.</source>
          <target state="translated">正则表达式定义为一个或多个&lt;em&gt;分支&lt;/em&gt;，以 &lt;code&gt;|&lt;/code&gt; 分隔。。它匹配任何与分支之一匹配的东西。</target>
        </trans-unit>
        <trans-unit id="3ee887f7d2952dfa9f7859c97d7cc185154f3579" translate="yes" xml:space="preserve">
          <source>A request sent by a client to a &lt;a href=&quot;glossary#GLOSSARY-BACKEND&quot;&gt;backend&lt;/a&gt;, usually to return results or to modify data on the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55280929ef651951f4ea5727fbd13d553ba423e3" translate="yes" xml:space="preserve">
          <source>A restriction on the values of data allowed within a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt;, or in attributes of a &lt;em&gt;domain&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f4f1bec4e67db6d8c109c21ce30fc24feb18e6d" translate="yes" xml:space="preserve">
          <source>A rich set of functions and operators is available to perform various geometric operations such as scaling, translation, rotation, and determining intersections. They are explained in &lt;a href=&quot;functions-geometry&quot;&gt;Section 9.11&lt;/a&gt;.</source>
          <target state="translated">一组丰富的函数和运算符可用于执行各种几何运算，例如缩放，平移，旋转和确定相交。它们在&lt;a href=&quot;functions-geometry&quot;&gt;第9.11节中&lt;/a&gt;进行了说明。</target>
        </trans-unit>
        <trans-unit id="dd3e55f45b03c0434f66fdb4c772115d77e89a86" translate="yes" xml:space="preserve">
          <source>A role can also have role-specific defaults for many of the run-time configuration settings described in &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt;. For example, if for some reason you want to disable index scans (hint: not a good idea) anytime you connect, you can use:</source>
          <target state="translated">对于&lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;第19章中&lt;/a&gt;描述的许多运行时配置设置，角色还可以具有特定于角色的默认设置。例如，如果由于某种原因您想在每次连接时禁用索引扫描（提示：不是一个好主意），则可以使用：</target>
        </trans-unit>
        <trans-unit id="5f70d4edcc88d0b7db0593c0dc96e77fa856833c" translate="yes" xml:space="preserve">
          <source>A role can also have role-specific defaults for many of the run-time configuration settings described in &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt;. For example, if for some reason you want to disable index scans (hint: not a good idea) anytime you connect, you can use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1819e27998d44ae23e1be32dd84afd40392e29ad" translate="yes" xml:space="preserve">
          <source>A role cannot be removed if it is still referenced in any database of the cluster; an error will be raised if so. Before dropping the role, you must drop all the objects it owns (or reassign their ownership) and revoke any privileges the role has been granted on other objects. The &lt;a href=&quot;sql-reassign-owned&quot;&gt;REASSIGN OWNED&lt;/a&gt; and &lt;a href=&quot;sql-drop-owned&quot;&gt;DROP OWNED&lt;/a&gt; commands can be useful for this purpose; see &lt;a href=&quot;role-removal&quot;&gt;Section 21.4&lt;/a&gt; for more discussion.</source>
          <target state="translated">如果角色仍在集群的任何数据库中被引用，则无法删除该角色；如果是这样，将引发错误。删除角色之前，必须删除其拥有的所有对象（或重新分配其所有权），并撤消已授予该角色在其他对象上的所有特权。的&lt;a href=&quot;sql-reassign-owned&quot;&gt;属主变更&lt;/a&gt;和&lt;a href=&quot;sql-drop-owned&quot;&gt;DROP OWNED&lt;/a&gt;命令可以是用于该目的的; 有关更多讨论，请参见&lt;a href=&quot;role-removal&quot;&gt;第21.4节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ca7ed328c6182a99c2ad02ba1bf771cc523959b3" translate="yes" xml:space="preserve">
          <source>A role must be explicitly given permission to create databases (except for superusers, since those bypass all permission checks). To create such a role, use &lt;code&gt;CREATE ROLE name CREATEDB&lt;/code&gt;.</source>
          <target state="translated">必须明确授予角色创建数据库的权限（超级用户除外，因为超级用户会绕过所有权限检查）。要创建这样的角色，请使用 &lt;code&gt;CREATE ROLE name CREATEDB&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d62d4d6cefafa0c4a7b229d226042d5cdbe21812" translate="yes" xml:space="preserve">
          <source>A role must be explicitly given permission to create more roles (except for superusers, since those bypass all permission checks). To create such a role, use &lt;code&gt;CREATE ROLE name CREATEROLE&lt;/code&gt;. A role with &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can alter and drop other roles, too, as well as grant or revoke membership in them. However, to create, alter, drop, or change membership of a superuser role, superuser status is required; &lt;code&gt;CREATEROLE&lt;/code&gt; is insufficient for that.</source>
          <target state="translated">必须为角色明确授予创建更多角色的权限（超级用户除外，因为超级用户会绕过所有权限检查）。要创建这样的角色，请使用 &lt;code&gt;CREATE ROLE name CREATEROLE&lt;/code&gt; 。具有 &lt;code&gt;CREATEROLE&lt;/code&gt; 特权的角色也可以更改和删除其他角色，以及授予或撤消其中的成员资格。但是，要创建，更改，删除或更改超级用户角色的成员身份，则需要超级用户状态。 &lt;code&gt;CREATEROLE&lt;/code&gt; 不足以做到这一点。</target>
        </trans-unit>
        <trans-unit id="17ba5cb05b3fc9de95da7091b339d5cf7b10fc50" translate="yes" xml:space="preserve">
          <source>A role must explicitly be given permission to initiate streaming replication (except for superusers, since those bypass all permission checks). A role used for streaming replication must have &lt;code&gt;LOGIN&lt;/code&gt; permission as well. To create such a role, use &lt;code&gt;CREATE ROLE name REPLICATION LOGIN&lt;/code&gt;.</source>
          <target state="translated">必须明确授予角色启动流复制的权限（超级用户除外，因为超级用户会绕过所有权限检查）。用于流复制的角色也必须具有 &lt;code&gt;LOGIN&lt;/code&gt; 权限。要创建这样的角色，请使用 &lt;code&gt;CREATE ROLE name REPLICATION LOGIN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="94be28bc6eb3b4ca303ced8b07cef3c876649a6d" translate="yes" xml:space="preserve">
          <source>A role's attributes can be modified after creation with &lt;code&gt;ALTER ROLE&lt;/code&gt;. See the reference pages for the &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; and &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt; commands for details.</source>
          <target state="translated">使用 &lt;code&gt;ALTER ROLE&lt;/code&gt; 创建角色后，可以修改角色的属性。有关详细信息，请参见&lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;和&lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt;命令的参考页。</target>
        </trans-unit>
        <trans-unit id="081acf24bd36c70b53212a425e34d472f83362f1" translate="yes" xml:space="preserve">
          <source>A row constructor</source>
          <target state="translated">一个行构造函数</target>
        </trans-unit>
        <trans-unit id="22f30213b82e4ac8580d06b76fb30db617ce4ae6" translate="yes" xml:space="preserve">
          <source>A row constructor can include the syntax &lt;code&gt;rowvalue&lt;/code&gt;&lt;code&gt;.*&lt;/code&gt;, which will be expanded to a list of the elements of the row value, just as occurs when the &lt;code&gt;.*&lt;/code&gt; syntax is used at the top level of a &lt;code&gt;SELECT&lt;/code&gt; list (see &lt;a href=&quot;rowtypes#ROWTYPES-USAGE&quot;&gt;Section 8.16.5&lt;/a&gt;). For example, if table &lt;code&gt;t&lt;/code&gt; has columns &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;f2&lt;/code&gt;, these are the same:</source>
          <target state="translated">行构造器可以包含 &lt;code&gt;rowvalue&lt;/code&gt; &lt;code&gt;.*&lt;/code&gt; 语法，该语法将扩展为该行值的元素列表，就像在 &lt;code&gt;SELECT&lt;/code&gt; 列表的顶层使用 &lt;code&gt;.*&lt;/code&gt; 语法时一样（请参见&lt;a href=&quot;rowtypes#ROWTYPES-USAGE&quot;&gt;第8.16.5节）&lt;/a&gt;）。例如，如果表 &lt;code&gt;t&lt;/code&gt; 具有 &lt;code&gt;f1&lt;/code&gt; 和 &lt;code&gt;f2&lt;/code&gt; 列，则它们是相同的：</target>
        </trans-unit>
        <trans-unit id="f65566297d0cf76754b5ffd2e69f3d748460cda5" translate="yes" xml:space="preserve">
          <source>A row constructor is an expression that builds a row value (also called a composite value) using values for its member fields. A row constructor consists of the key word &lt;code&gt;ROW&lt;/code&gt;, a left parenthesis, zero or more expressions (separated by commas) for the row field values, and finally a right parenthesis. For example:</source>
          <target state="translated">行构造函数是一个表达式，该表达式使用其成员字段的值构建行值（也称为复合值）。行构造函数由关键字 &lt;code&gt;ROW&lt;/code&gt; ，左括号，行字段值的零个或多个表达式（用逗号分隔）以及最后一个右括号组成。例如：</target>
        </trans-unit>
        <trans-unit id="e083a9bfabe61aa93820ae695a4040f7ab7fb65b" translate="yes" xml:space="preserve">
          <source>A rule has significantly more overhead than a trigger, but the overhead is paid once per query rather than once per row, so this method might be advantageous for bulk-insert situations. In most cases, however, the trigger method will offer better performance.</source>
          <target state="translated">规则的开销比触发器大得多,但开销是每次查询一次而不是每行一次,所以这种方法在批量插入的情况下可能有优势。但在大多数情况下,触发器方法会提供更好的性能。</target>
        </trans-unit>
        <trans-unit id="3a8ed465468f0b09e900dc84f22e1ad03222e742" translate="yes" xml:space="preserve">
          <source>A safe value can be determined by looking for the numerically largest file name in the directory &lt;code&gt;pg_multixact/members&lt;/code&gt; under the data directory, adding one, and then multiplying by 52352 (0xCC80). The file names are in hexadecimal. There is no simple recipe such as the ones for other options of appending zeroes.</source>
          <target state="translated">可以通过在数据目录下的 &lt;code&gt;pg_multixact/members&lt;/code&gt; 目录中查找数字上最大的文件名，再加一个，然后乘以52352（0xCC80）来确定安全值。文件名以十六进制表示。没有简单的配方，例如附加零的其他选项的配方。</target>
        </trans-unit>
        <trans-unit id="427cc987ada87144cf5033e51fd5ca57fac98875" translate="yes" xml:space="preserve">
          <source>A safe value can be determined by looking for the numerically largest file name in the directory &lt;code&gt;pg_xact&lt;/code&gt; under the data directory, adding one, and then multiplying by 1048576 (0x100000). Note that the file names are in hexadecimal. It is usually easiest to specify the option value in hexadecimal too. For example, if &lt;code&gt;0011&lt;/code&gt; is the largest entry in &lt;code&gt;pg_xact&lt;/code&gt;, &lt;code&gt;-x 0x1200000&lt;/code&gt; will work (five trailing zeroes provide the proper multiplier).</source>
          <target state="translated">可以通过在数据目录下的 &lt;code&gt;pg_xact&lt;/code&gt; 目录中查找数字上最大的文件名，再加一个，然后乘以1048576（0x100000），来确定安全值。请注意，文件名以十六进制表示。通常，也最容易以十六进制指定选项值。例如，如果 &lt;code&gt;0011&lt;/code&gt; 是 &lt;code&gt;pg_xact&lt;/code&gt; 中最大的条目，则 &lt;code&gt;-x 0x1200000&lt;/code&gt; 将起作用（五个尾随零表示适当的乘数）。</target>
        </trans-unit>
        <trans-unit id="cb05b109b960491956518dbc25a95b68a60bb5b7" translate="yes" xml:space="preserve">
          <source>A safe value for the next multitransaction ID (first part) can be determined by looking for the numerically largest file name in the directory &lt;code&gt;pg_multixact/offsets&lt;/code&gt; under the data directory, adding one, and then multiplying by 65536 (0x10000). Conversely, a safe value for the oldest multitransaction ID (second part of &lt;code&gt;-m&lt;/code&gt;) can be determined by looking for the numerically smallest file name in the same directory and multiplying by 65536. The file names are in hexadecimal, so the easiest way to do this is to specify the option value in hexadecimal and append four zeroes.</source>
          <target state="translated">可以通过在数据目录下的 &lt;code&gt;pg_multixact/offsets&lt;/code&gt; 目录中查找数字上最大的文件名，再加一个，然后乘以65536（0x10000），来确定下一个多重事务ID（第一部分）的安全值。相反，可以通过在同一目录中查找数字最小的文件名并乘以65536来确定最早的多重事务ID（ &lt;code&gt;-m&lt;/code&gt; 的第二部分）的安全值。文件名采用十六进制，因此最简单的方法是这将以十六进制指定选项值并附加四个零。</target>
        </trans-unit>
        <trans-unit id="210bab91fc67894e59300e346dd93bb05146f64b" translate="yes" xml:space="preserve">
          <source>A safe value for the oldest transaction ID for which the commit time can be retrieved (first part) can be determined by looking for the numerically smallest file name in the directory &lt;code&gt;pg_commit_ts&lt;/code&gt; under the data directory. Conversely, a safe value for the newest transaction ID for which the commit time can be retrieved (second part) can be determined by looking for the numerically greatest file name in the same directory. The file names are in hexadecimal.</source>
          <target state="translated">可以通过在数据目录下的 &lt;code&gt;pg_commit_ts&lt;/code&gt; 目录中查找数字上最小的文件名，来确定最早的事务ID的安全值（可以为其确定提交时间）。相反，可以通过在同一目录中查找数字上最大的文件名来确定可以为其检索提交时间的最新事务ID的安全值（第二部分）。文件名以十六进制表示。</target>
        </trans-unit>
        <trans-unit id="8c66ea914339b5b34a8487aab28576ebc5ca45da" translate="yes" xml:space="preserve">
          <source>A savepoint is a special mark inside a transaction that allows all commands that are executed after it was established to be rolled back, restoring the transaction state to what it was at the time of the savepoint.</source>
          <target state="translated">保存点是事务内部的一个特殊标记,它允许所有在建立后执行的命令被回滚,恢复到保存点时的事务状态。</target>
        </trans-unit>
        <trans-unit id="7568eb3ea7434ae7b0d16a00f453676381b783a8" translate="yes" xml:space="preserve">
          <source>A scalar subquery</source>
          <target state="translated">一个标量子查询</target>
        </trans-unit>
        <trans-unit id="81af8f2f005c91eb2539d9bedb25765441d8772a" translate="yes" xml:space="preserve">
          <source>A scalar subquery is an ordinary &lt;code&gt;SELECT&lt;/code&gt; query in parentheses that returns exactly one row with one column. (See &lt;a href=&quot;https://www.postgresql.org/docs/12/queries.html&quot;&gt;Chapter 7&lt;/a&gt; for information about writing queries.) The &lt;code&gt;SELECT&lt;/code&gt; query is executed and the single returned value is used in the surrounding value expression. It is an error to use a query that returns more than one row or more than one column as a scalar subquery. (But if, during a particular execution, the subquery returns no rows, there is no error; the scalar result is taken to be null.) The subquery can refer to variables from the surrounding query, which will act as constants during any one evaluation of the subquery. See also &lt;a href=&quot;functions-subquery&quot;&gt;Section 9.22&lt;/a&gt; for other expressions involving subqueries.</source>
          <target state="translated">标量子查询是括号中的普通 &lt;code&gt;SELECT&lt;/code&gt; 查询，该查询恰好返回一行加一列。 （有关编写查询的信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/queries.html&quot;&gt;第7章&lt;/a&gt;。）执行 &lt;code&gt;SELECT&lt;/code&gt; 查询，并在周围的值表达式中使用单个返回的值。使用返回多于一行或多于一列的查询作为标量子查询是错误的。 （但是，如果在特定的执行过程中，子查询不返回任何行，则没有错误；标量结果被视为空。）子查询可以引用周围查询中的变量，该变量将在任何一次求值期间充当常量子查询。有关涉及子查询的其他表达式，另请参见&lt;a href=&quot;functions-subquery&quot;&gt;第9.22节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e0ba5f6cf2c1fcbf75fbd9fbfb66a812b9004a7f" translate="yes" xml:space="preserve">
          <source>A scalar subquery is an ordinary &lt;code&gt;SELECT&lt;/code&gt; query in parentheses that returns exactly one row with one column. (See &lt;a href=&quot;https://www.postgresql.org/docs/13/queries.html&quot;&gt;Chapter 7&lt;/a&gt; for information about writing queries.) The &lt;code&gt;SELECT&lt;/code&gt; query is executed and the single returned value is used in the surrounding value expression. It is an error to use a query that returns more than one row or more than one column as a scalar subquery. (But if, during a particular execution, the subquery returns no rows, there is no error; the scalar result is taken to be null.) The subquery can refer to variables from the surrounding query, which will act as constants during any one evaluation of the subquery. See also &lt;a href=&quot;functions-subquery&quot;&gt;Section 9.23&lt;/a&gt; for other expressions involving subqueries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22189bcf116df43b441c919d8d32eb0f9603b0c4" translate="yes" xml:space="preserve">
          <source>A scan key is the internal representation of a &lt;code&gt;WHERE&lt;/code&gt; clause of the form &lt;code&gt;index_key&lt;/code&gt;&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;constant&lt;/code&gt;, where the index key is one of the columns of the index and the operator is one of the members of the operator family associated with that index column. An index scan has zero or more scan keys, which are implicitly ANDed &amp;mdash; the returned tuples are expected to satisfy all the indicated conditions.</source>
          <target state="translated">扫描键是 &lt;code&gt;index_key&lt;/code&gt; &lt;code&gt;operator&lt;/code&gt; &lt;code&gt;constant&lt;/code&gt; 形式的 &lt;code&gt;WHERE&lt;/code&gt; 子句的内部表示形式，其中索引键是索引的列之一，而运算符是与该索引列关联的运算符族的成员之一。索引扫描具有零个或多个扫描键，这些键隐式地进行&amp;ldquo;与&amp;rdquo;运算-返回的元组应满足所有指示的条件。</target>
        </trans-unit>
        <trans-unit id="f42378ba798baf455e1545f6ed59407d2afa77b9" translate="yes" xml:space="preserve">
          <source>A schema can only be dropped by its owner or a superuser. Note that the owner can drop the schema (and thereby all contained objects) even if they do not own some of the objects within the schema.</source>
          <target state="translated">一个模式只能由它的所有者或超级用户放弃。请注意,即使所有者不拥有模式中的某些对象,也可以放弃模式(从而放弃所有包含的对象)。</target>
        </trans-unit>
        <trans-unit id="254b4940dad1d633556557588b281f41f26bbd38" translate="yes" xml:space="preserve">
          <source>A schema is a namespace for &lt;a href=&quot;glossary#GLOSSARY-SQL-OBJECT&quot;&gt;SQL objects&lt;/a&gt;, which all reside in the same &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt;. Each SQL object must reside in exactly one schema.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6403de1aa8d8ec1e90672c217c0a1e9ee16c135" translate="yes" xml:space="preserve">
          <source>A schema is essentially a namespace: it contains named objects (tables, data types, functions, and operators) whose names can duplicate those of other objects existing in other schemas. Named objects are accessed either by &amp;ldquo;qualifying&amp;rdquo; their names with the schema name as a prefix, or by setting a search path that includes the desired schema(s). A &lt;code&gt;CREATE&lt;/code&gt; command specifying an unqualified object name creates the object in the current schema (the one at the front of the search path, which can be determined with the function &lt;code&gt;current_schema&lt;/code&gt;).</source>
          <target state="translated">模式本质上是一个名称空间：它包含命名对象（表，数据类型，函数和运算符），其名称可以与其他模式中存在的其他对象的名称重复。通过使用模式名称作为前缀&amp;ldquo;限定&amp;rdquo;其名称或设置包含所需模式的搜索路径，可以访问命名对象。使用 &lt;code&gt;CREATE&lt;/code&gt; 命令指定了不合格的对象名称，将在当前模式（搜索路径前面的对象，可以使用 &lt;code&gt;current_schema&lt;/code&gt; 函数确定）中创建该对象。</target>
        </trans-unit>
        <trans-unit id="896efd5a8d00dc02d53497ffb75c3ac39fb5a4a6" translate="yes" xml:space="preserve">
          <source>A script file contains one or more SQL commands terminated by semicolons. Empty lines and lines beginning with &lt;code&gt;--&lt;/code&gt; are ignored. Script files can also contain &amp;ldquo;meta commands&amp;rdquo;, which are interpreted by pgbench itself, as described below.</source>
          <target state="translated">脚本文件包含一个或多个以分号终止的SQL命令。空行和以 &lt;code&gt;--&lt;/code&gt; 开头的行将被忽略。脚本文件还可以包含&amp;ldquo;元命令&amp;rdquo;，这由pgbench本身解释，如下所述。</target>
        </trans-unit>
        <trans-unit id="c4717af9b4226f3b00d724aebfdacf0ab19f7c65" translate="yes" xml:space="preserve">
          <source>A second database, &lt;code&gt;template1&lt;/code&gt;, is also created during database cluster initialization. Whenever a new database is created within the cluster, &lt;code&gt;template1&lt;/code&gt; is essentially cloned. This means that any changes you make in &lt;code&gt;template1&lt;/code&gt; are propagated to all subsequently created databases. Because of this, avoid creating objects in &lt;code&gt;template1&lt;/code&gt; unless you want them propagated to every newly created database. More details appear in &lt;a href=&quot;manage-ag-templatedbs&quot;&gt;Section 22.3&lt;/a&gt;.</source>
          <target state="translated">在数据库集群初始化期间还将创建第二个数据库 &lt;code&gt;template1&lt;/code&gt; 。每当在集群中创建新数据库时，实质上都会克隆 &lt;code&gt;template1&lt;/code&gt; 。这意味着您在 &lt;code&gt;template1&lt;/code&gt; 中所做的任何更改都会传播到所有随后创建的数据库。因此，除非希望将对象传播到每个新创建的数据库，否则请避免在 &lt;code&gt;template1&lt;/code&gt; 中创建对象。更多细节请参见&lt;a href=&quot;manage-ag-templatedbs&quot;&gt;第22.3节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c0553fb63d3a8d00dba1af17146ccb321bca9edc" translate="yes" xml:space="preserve">
          <source>A separator (a space or non-letter/non-digit character) in the template string of &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt; matches any single separator in the input string or is skipped, unless the &lt;code&gt;FX&lt;/code&gt; option is used. For example, &lt;code&gt;to_timestamp('2000JUN', 'YYYY///MON')&lt;/code&gt; and &lt;code&gt;to_timestamp('2000/JUN', 'YYYY MON')&lt;/code&gt; work, but &lt;code&gt;to_timestamp('2000//JUN', 'YYYY/MON')&lt;/code&gt; returns an error because the number of separators in the input string exceeds the number of separators in the template.</source>
          <target state="translated">除非使用了 &lt;code&gt;FX&lt;/code&gt; 选项，否则 &lt;code&gt;to_timestamp&lt;/code&gt; 和 &lt;code&gt;to_date&lt;/code&gt; 的模板字符串中的分隔符（空格或非字母/非数字字符）与输入字符串中的任何单个分隔符匹配或被跳过。例如， &lt;code&gt;to_timestamp('2000JUN', 'YYYY///MON')&lt;/code&gt; 和 &lt;code&gt;to_timestamp('2000/JUN', 'YYYY MON')&lt;/code&gt; 有效，但是 &lt;code&gt;to_timestamp('2000//JUN', 'YYYY/MON')&lt;/code&gt; 返回错误，因为输入字符串中的分隔符数量超出了模板中的分隔符数量。</target>
        </trans-unit>
        <trans-unit id="11592b154f9e554cd84c7343d4d02f52f502b436" translate="yes" xml:space="preserve">
          <source>A sequential scan over this large table takes a long time:</source>
          <target state="translated">在这个大表上进行顺序扫描需要很长的时间。</target>
        </trans-unit>
        <trans-unit id="79af3c162f9318c384ae01ff487ce072e1768dfe" translate="yes" xml:space="preserve">
          <source>A sequential scan will always necessitate a relation-level predicate lock. This can result in an increased rate of serialization failures. It may be helpful to encourage the use of index scans by reducing &lt;a href=&quot;runtime-config-query#GUC-RANDOM-PAGE-COST&quot;&gt;random_page_cost&lt;/a&gt; and/or increasing &lt;a href=&quot;runtime-config-query#GUC-CPU-TUPLE-COST&quot;&gt;cpu_tuple_cost&lt;/a&gt;. Be sure to weigh any decrease in transaction rollbacks and restarts against any overall change in query execution time.</source>
          <target state="translated">顺序扫描将始终需要关系级别的谓词锁定。这会导致序列化失败率增加。通过减少&lt;a href=&quot;runtime-config-query#GUC-RANDOM-PAGE-COST&quot;&gt;random_page_cost&lt;/a&gt;和/或增加&lt;a href=&quot;runtime-config-query#GUC-CPU-TUPLE-COST&quot;&gt;cpu_tuple_cost&lt;/a&gt;来鼓励使用索引扫描可能会有所帮助。确保权衡事务回滚和重新启动的任何减少与查询执行时间的任何整体变化。</target>
        </trans-unit>
        <trans-unit id="c996ff6e0403a4fb8e72d039c933ec1c36020db2" translate="yes" xml:space="preserve">
          <source>A series of documents that define the SQL language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bfa1c21333697528077114ccbfbc09a0f9f978f" translate="yes" xml:space="preserve">
          <source>A serious limitation of the inheritance feature is that indexes (including unique constraints) and foreign key constraints only apply to single tables, not to their inheritance children. This is true on both the referencing and referenced sides of a foreign key constraint. Thus, in the terms of the above example:</source>
          <target state="translated">继承功能的一个严重限制是索引(包括唯一约束)和外键约束只适用于单个表,而不适用于其继承子表。在外键约束的引用端和被引用端都是如此。因此,在上述例子的条件下。</target>
        </trans-unit>
        <trans-unit id="b2bd01559e686b7857df249c11b785bd65be39d9" translate="yes" xml:space="preserve">
          <source>A server process, which manages the database files, accepts connections to the database from client applications, and performs database actions on behalf of the clients. The database server program is called &lt;code&gt;postgres&lt;/code&gt;.</source>
          <target state="translated">服务器进程管理数据库文件，接受来自客户端应用程序的数据库连接，并代表客户端执行数据库操作。数据库服务器程序称为 &lt;code&gt;postgres&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eda9a27048331b66fd1707531a40ce77f3ddd8c9" translate="yes" xml:space="preserve">
          <source>A session can be unregistered for a given notification channel with the &lt;code&gt;UNLISTEN&lt;/code&gt; command. A session's listen registrations are automatically cleared when the session ends.</source>
          <target state="translated">可以使用 &lt;code&gt;UNLISTEN&lt;/code&gt; 命令为给定的通知通道注销会话。会话结束时，会话的监听注册会自动清除。</target>
        </trans-unit>
        <trans-unit id="2159dca873e4422248b8b886c40fce3f04eaaa4b" translate="yes" xml:space="preserve">
          <source>A session running a &lt;code id=&quot;serializable&quot;&gt;SERIALIZABLE&lt;/code&gt; transaction blocks a &lt;code&gt;SERIALIZABLE READ ONLY DEFERRABLE&lt;/code&gt; transaction from acquiring a snapshot until the latter determines that it is safe to avoid taking any predicate locks. See &lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;Section 13.2.3&lt;/a&gt; for more information about serializable and deferrable transactions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75b584c1806aab227b279342fcda898366eb0bc1" translate="yes" xml:space="preserve">
          <source>A session will allocate temporary buffers as needed up to the limit given by &lt;code&gt;temp_buffers&lt;/code&gt;. The cost of setting a large value in sessions that do not actually need many temporary buffers is only a buffer descriptor, or about 64 bytes, per increment in &lt;code&gt;temp_buffers&lt;/code&gt;. However if a buffer is actually used an additional 8192 bytes will be consumed for it (or in general, &lt;code&gt;BLCKSZ&lt;/code&gt; bytes).</source>
          <target state="translated">会话将根据需要分配临时缓冲区，直到 &lt;code&gt;temp_buffers&lt;/code&gt; 所给定的限制。在实际上不需要很多临时缓冲区的会话中设置大值的代价只是 &lt;code&gt;temp_buffers&lt;/code&gt; 中每个增量的缓冲区描述符，或大约64个字节。但是，如果实际上使用了缓冲区， &lt;code&gt;BLCKSZ&lt;/code&gt; 消耗额外的8192字节（或者通常是BLCKSZ字节）。</target>
        </trans-unit>
        <trans-unit id="1986f4a7eb9ec7c322dfb6c9c6e1924b057be9e0" translate="yes" xml:space="preserve">
          <source>A set of background processes that routinely perform &lt;a href=&quot;glossary#GLOSSARY-VACUUM&quot;&gt;vacuum&lt;/a&gt; and &lt;a href=&quot;glossary#GLOSSARY-ANALYZE&quot;&gt;analyze&lt;/a&gt; operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78d05cbafd4652352f5f70c34a9c2c9722aea37c" translate="yes" xml:space="preserve">
          <source>A set of functions and function-like expressions are available for producing XML content from SQL data. As such, they are particularly suitable for formatting query results into XML documents for processing in client applications.</source>
          <target state="translated">一组函数和类似函数的表达式可用于从SQL数据生成XML内容。因此,它们特别适合将查询结果格式化为XML文档,以便在客户端应用程序中进行处理。</target>
        </trans-unit>
        <trans-unit id="db5cffdfcc14ae057b50bf32801b87510be72218" translate="yes" xml:space="preserve">
          <source>A set of functions and function-like expressions is available for producing XML content from SQL data. As such, they are particularly suitable for formatting query results into XML documents for processing in client applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="675287b9d3c5bb2ab0654e84d04004c09628b2e2" translate="yes" xml:space="preserve">
          <source>A shorthand notation is provided for specifying two common types of grouping set. A clause of the form</source>
          <target state="translated">提供了一个速记符号来指定两种常见的分组集类型。一个形式为</target>
        </trans-unit>
        <trans-unit id="4eb84b728058fd55ea25770f3f034fccfd80efda" translate="yes" xml:space="preserve">
          <source>A shorthand version of &lt;code&gt;get_raw_page&lt;/code&gt;, for reading from the main fork. Equivalent to &lt;code&gt;get_raw_page(relname, 'main', blkno)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;get_raw_page&lt;/code&gt; 的简写版本，用于从主fork读取。等效于 &lt;code&gt;get_raw_page(relname, 'main', blkno)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf3b68bae267e9ec8dc713868f0cc42a385b1b59" translate="yes" xml:space="preserve">
          <source>A sign formatted using &lt;code&gt;SG&lt;/code&gt;, &lt;code&gt;PL&lt;/code&gt;, or &lt;code&gt;MI&lt;/code&gt; is not anchored to the number; for example, &lt;code&gt;to_char(-12, 'MI9999')&lt;/code&gt; produces &lt;code&gt;'-&amp;nbsp;&amp;nbsp;12'&lt;/code&gt; but &lt;code&gt;to_char(-12, 'S9999')&lt;/code&gt; produces &lt;code&gt;'&amp;nbsp;&amp;nbsp;-12'&lt;/code&gt;. (The Oracle implementation does not allow the use of &lt;code&gt;MI&lt;/code&gt; before &lt;code&gt;9&lt;/code&gt;, but rather requires that &lt;code&gt;9&lt;/code&gt; precede &lt;code&gt;MI&lt;/code&gt;.)</source>
          <target state="translated">使用 &lt;code&gt;SG&lt;/code&gt; ， &lt;code&gt;PL&lt;/code&gt; 或 &lt;code&gt;MI&lt;/code&gt; 格式化的符号未固定到该数字；例如， &lt;code&gt;to_char(-12, 'MI9999')&lt;/code&gt; 产生 &lt;code&gt;'-&amp;nbsp;&amp;nbsp;12'&lt;/code&gt; &lt;code&gt;to_char(-12, 'S9999')&lt;/code&gt; '，而to_char（-12，'S9999'）产生 &lt;code&gt;'&amp;nbsp;&amp;nbsp;-12'&lt;/code&gt; 。 （Oracle里的实现不允许使用的 &lt;code&gt;MI&lt;/code&gt; 前 &lt;code&gt;9&lt;/code&gt; ，而是要求 &lt;code&gt;9&lt;/code&gt; 上一页 &lt;code&gt;MI&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="28f22335db260bb1a77d3874ff5a159c8ea0367a" translate="yes" xml:space="preserve">
          <source>A signature is a lossy representation of the indexed attribute(s), and as such is prone to reporting false positives; that is, it may be reported that an element is in the set, when it is not. So index search results must always be rechecked using the actual attribute values from the heap entry. Larger signatures reduce the odds of a false positive and thus reduce the number of useless heap visits, but of course also make the index larger and hence slower to scan.</source>
          <target state="translated">签名是索引属性的有损表示,因此很容易报告假阳性;也就是说,它可能会报告某个元素在集合中,而它却不在。所以索引搜索结果必须始终使用堆条目中的实际属性值进行重新检查。较大的签名可以降低假阳性的几率,从而减少无用的堆访问次数,当然也会使索引变大,从而使扫描速度变慢。</target>
        </trans-unit>
        <trans-unit id="32035573077f021fbb97ad61e501af43e164ab91" translate="yes" xml:space="preserve">
          <source>A similar approach is used in most non-fiction books: terms and concepts that are frequently looked up by readers are collected in an alphabetic index at the end of the book. The interested reader can scan the index relatively quickly and flip to the appropriate page(s), rather than having to read the entire book to find the material of interest. Just as it is the task of the author to anticipate the items that readers are likely to look up, it is the task of the database programmer to foresee which indexes will be useful.</source>
          <target state="translated">大多数非小说类书籍都采用了类似的方法:将读者经常查找的术语和概念收集在书末的字母索引中。有兴趣的读者可以比较快地扫描索引,并翻到相应的页面,而不是必须阅读整本书才能找到感兴趣的材料。就像作者的任务是预测读者可能查找的项目一样,数据库程序员的任务是预测哪些索引将是有用的。</target>
        </trans-unit>
        <trans-unit id="0ce67715832ac88218d019874223da06f72da1b1" translate="yes" xml:space="preserve">
          <source>A similar command will be generated for each new file to be archived.</source>
          <target state="translated">对每一个要归档的新文件都会生成类似的命令。</target>
        </trans-unit>
        <trans-unit id="3786a908833219f288eb01ce7bf3707543bec989" translate="yes" xml:space="preserve">
          <source>A similar problem occurs with estimation of the cardinality of sets of multiple columns, such as the number of groups that would be generated by a &lt;code&gt;GROUP BY&lt;/code&gt; clause. When &lt;code&gt;GROUP BY&lt;/code&gt; lists a single column, the n-distinct estimate (which is visible as the estimated number of rows returned by the HashAggregate node) is very accurate:</source>
          <target state="translated">在估计多个列的集合的基数时会发生类似的问题，例如 &lt;code&gt;GROUP BY&lt;/code&gt; 子句将生成的组数。当 &lt;code&gt;GROUP BY&lt;/code&gt; 列出单个列时，n差异估计（由HashAggregate节点返回的估计行数可见）非常准确：</target>
        </trans-unit>
        <trans-unit id="5d9a6505729509f95a09312b10bc6d90c22cf17c" translate="yes" xml:space="preserve">
          <source>A similar result could be accomplished with a join:</source>
          <target state="translated">用加入的方式也可以达到类似的效果。</target>
        </trans-unit>
        <trans-unit id="37fd7a4a35913776332656300b6e6e873ef35bb0" translate="yes" xml:space="preserve">
          <source>A simple GIN index on the &lt;code&gt;jdoc&lt;/code&gt; column can support this query. But note that such an index will store copies of every key and value in the &lt;code&gt;jdoc&lt;/code&gt; column, whereas the expression index of the previous example stores only data found under the &lt;code&gt;tags&lt;/code&gt; key. While the simple-index approach is far more flexible (since it supports queries about any key), targeted expression indexes are likely to be smaller and faster to search than a simple index.</source>
          <target state="translated">&lt;code&gt;jdoc&lt;/code&gt; 列上的简单GIN索引可以支持此查询。但是请注意，这样的索引将在 &lt;code&gt;jdoc&lt;/code&gt; 列中存储每个键和值的副本，而上一示例的表达式索引仅存储在 &lt;code&gt;tags&lt;/code&gt; 键下找到的数据。尽管简单索引方法要灵活得多（因为它支持对任何键的查询），但目标表达式索引可能比简单索引更小且搜索速度更快。</target>
        </trans-unit>
        <trans-unit id="1dca6bdccd192c38f7d0a54b1d6c641ecfc4dd07" translate="yes" xml:space="preserve">
          <source>A simple aggregate function is made from one or two ordinary functions: a state transition function &lt;code&gt;sfunc&lt;/code&gt;, and an optional final calculation function &lt;code&gt;ffunc&lt;/code&gt;. These are used as follows:</source>
          <target state="translated">一个简单的聚合函数由一个或两个普通函数组成：状态转换函数 &lt;code&gt;sfunc&lt;/code&gt; 和可选的最终计算函数 &lt;code&gt;ffunc&lt;/code&gt; 。它们的用法如下：</target>
        </trans-unit>
        <trans-unit id="92c5b995463bf0dd676bdb47c7d11c8b07e323eb" translate="yes" xml:space="preserve">
          <source>A simple example of configuration is:</source>
          <target state="translated">一个简单的配置例子是:</target>
        </trans-unit>
        <trans-unit id="0929a1c1d2dae1cb142a133fc2a8d2f50ec36161" translate="yes" xml:space="preserve">
          <source>A simple example of these rules is</source>
          <target state="translated">这些规则的一个简单例子是</target>
        </trans-unit>
        <trans-unit id="a7391df0d455f9692788470d09f0d785e12ddd80" translate="yes" xml:space="preserve">
          <source>A simple kind of query has the form:</source>
          <target state="translated">一种简单的查询形式是:</target>
        </trans-unit>
        <trans-unit id="e9cf93d0e888ede997ab50815543f2f23545f52a" translate="yes" xml:space="preserve">
          <source>A single index scan can only use query clauses that use the index's columns with operators of its operator class and are joined with &lt;code&gt;AND&lt;/code&gt;. For example, given an index on &lt;code&gt;(a, b)&lt;/code&gt; a query condition like &lt;code&gt;WHERE a = 5 AND b = 6&lt;/code&gt; could use the index, but a query like &lt;code&gt;WHERE a = 5 OR b = 6&lt;/code&gt; could not directly use the index.</source>
          <target state="translated">单个索引扫描只能使用查询子句，该查询子句将索引的列与其运算符类的运算符一起使用 &lt;code&gt;AND&lt;/code&gt; 并与AND结合在一起。例如，给定 &lt;code&gt;(a, b)&lt;/code&gt; 的索引，诸如 &lt;code&gt;WHERE a = 5 AND b = 6&lt;/code&gt; 的查询条件可以使用该索引，但是诸如 &lt;code&gt;WHERE a = 5 OR b = 6&lt;/code&gt; 的查询不能直接使用该索引。</target>
        </trans-unit>
        <trans-unit id="867794d10e104f13c9e8cf27b9206d3b607f31d5" translate="yes" xml:space="preserve">
          <source>A single operator is provided, shown in &lt;a href=&quot;earthdistance#EARTHDISTANCE-POINT-OPERATORS&quot;&gt;Table F.6&lt;/a&gt;.</source>
          <target state="translated">提供了单个运算符，如&lt;a href=&quot;earthdistance#EARTHDISTANCE-POINT-OPERATORS&quot;&gt;表F.6&lt;/a&gt;所示。</target>
        </trans-unit>
        <trans-unit id="4ecaee1e3e7fc4cc75092b8ce7abdaa9285ac3ce" translate="yes" xml:space="preserve">
          <source>A small number of objects, like role, database, and tablespace names, are defined at the cluster level and stored in the &lt;code&gt;pg_global&lt;/code&gt; tablespace. Inside the cluster are multiple databases, which are isolated from each other but can access cluster-level objects. Inside each database are multiple schemas, which contain objects like tables and functions. So the full hierarchy is: cluster, database, schema, table (or some other kind of object, such as a function).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07b58acc01d25d1802019308ca111c48a0d1dd06" translate="yes" xml:space="preserve">
          <source>A software add-on package that can be installed on an &lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;instance&lt;/a&gt; to get extra features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d707a25df7385c415429f55133f3338c29d9eb5" translate="yes" xml:space="preserve">
          <source>A sorting operator. For details see &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;&lt;code&gt;ORDER BY&lt;/code&gt; Clause&lt;/a&gt;.</source>
          <target state="translated">排序运算符。有关详细信息，请参见&lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt; &lt;code&gt;ORDER BY&lt;/code&gt; 子句&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6d3b735b7f3eb84460aea32d14769c9c3214fb68" translate="yes" xml:space="preserve">
          <source>A sorting operator. For details see &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;ORDER BY Clause&lt;/a&gt; in the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cf7b59bf27af641775e9434a262775adcfc35c9" translate="yes" xml:space="preserve">
          <source>A special case of a &lt;a href=&quot;glossary#GLOSSARY-UNIQUE-CONSTRAINT&quot;&gt;unique constraint&lt;/a&gt; defined on a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; or other &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; that also guarantees that all of the &lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;attributes&lt;/a&gt; within the &lt;a href=&quot;glossary#GLOSSARY-PRIMARY-KEY&quot;&gt;primary key&lt;/a&gt; do not have &lt;a href=&quot;glossary#GLOSSARY-NULL&quot;&gt;null&lt;/a&gt; values. As the name implies, there can be only one primary key per table, though it is possible to have multiple unique constraints that also have no null-capable attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c36087e3651816803cdd143451424471a45426ba" translate="yes" xml:space="preserve">
          <source>A special case that's sometimes useful is that &lt;code&gt;&amp;lt;0&amp;gt;&lt;/code&gt; can be used to require that two patterns match the same word.</source>
          <target state="translated">有时有用的一个特殊情况是 &lt;code&gt;&amp;lt;0&amp;gt;&lt;/code&gt; 可用于要求两个模式匹配相同的单词。</target>
        </trans-unit>
        <trans-unit id="80f2af404248705306ef790e8642f0ac8c9028d1" translate="yes" xml:space="preserve">
          <source>A special heuristic is applied to determine whether a deduplication pass in a unique index should take place. It can often skip straight to splitting a leaf page, avoiding a performance penalty from wasting cycles on unhelpful deduplication passes. If you're concerned about the overhead of deduplication, consider setting &lt;code&gt;deduplicate_items = off&lt;/code&gt; selectively. Leaving deduplication enabled in unique indexes has little downside.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bae37c740b6d35e6443717335fb07bf95869ce22" translate="yes" xml:space="preserve">
          <source>A special mark in the sequence of steps in a &lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;transaction&lt;/a&gt;. Data modifications after this point in time may be reverted to the time of the savepoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50e32359cf0b0268eacae302550072c34383af98" translate="yes" xml:space="preserve">
          <source>A specialized process responsible for executing checkpoints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a70bf6435ed23a7c676143743be435f017bc889" translate="yes" xml:space="preserve">
          <source>A standby acting as both a receiver and a sender is known as a cascading standby. Standbys that are more directly connected to the master are known as upstream servers, while those standby servers further away are downstream servers. Cascading replication does not place limits on the number or arrangement of downstream servers, though each standby connects to only one upstream server which eventually links to a single master/primary server.</source>
          <target state="translated">既是接收器又是发送器的备用服务器称为级联备用服务器。与主站连接较直接的备用服务器称为上游服务器,而距离较远的备用服务器为下游服务器。级联复制对下游服务器的数量或排列没有限制,不过每个备用服务器只连接一个上游服务器,而上游服务器最终会连接到一个主/主服务器。</target>
        </trans-unit>
        <trans-unit id="94007c63f83c2bc9effa88a81f497e0678595186" translate="yes" xml:space="preserve">
          <source>A standby server can be implemented using file-based log shipping (&lt;a href=&quot;warm-standby&quot;&gt;Section 26.2&lt;/a&gt;) or streaming replication (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;), or a combination of both. For information on hot standby, see &lt;a href=&quot;hot-standby&quot;&gt;Section 26.5&lt;/a&gt;.</source>
          <target state="translated">备用服务器可以使用基于文件的日志传送（&lt;a href=&quot;warm-standby&quot;&gt;第26.2节&lt;/a&gt;）或流复制（请参阅&lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;第26.2.5节&lt;/a&gt;）或两者结合来实现。有关热备用的信息，请参见&lt;a href=&quot;hot-standby&quot;&gt;第26.5节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="326a3efd4c9e08bc49a95748f894324f178b3b88" translate="yes" xml:space="preserve">
          <source>A state that allows a client and a backend to interact, communicating over a &lt;a href=&quot;glossary#GLOSSARY-CONNECTION&quot;&gt;connection&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eb6647573ef74b2ae4f7352625efc1c166ad8a5" translate="yes" xml:space="preserve">
          <source>A statement can only see rows committed before it began. This is the default.</source>
          <target state="translated">一条语句只能看到它开始之前提交的行。这是默认的。</target>
        </trans-unit>
        <trans-unit id="4a7d12fc82f3d9f19299237c20a3b225478fd75c" translate="yes" xml:space="preserve">
          <source>A statistics kind to be computed in this statistics object. Currently supported kinds are &lt;code&gt;ndistinct&lt;/code&gt;, which enables n-distinct statistics, &lt;code&gt;dependencies&lt;/code&gt;, which enables functional dependency statistics, and &lt;code&gt;mcv&lt;/code&gt; which enables most-common values lists. If this clause is omitted, all supported statistics kinds are included in the statistics object. For more information, see &lt;a href=&quot;planner-stats#PLANNER-STATS-EXTENDED&quot;&gt;Section 14.2.2&lt;/a&gt; and &lt;a href=&quot;multivariate-statistics-examples&quot;&gt;Section 70.2&lt;/a&gt;.</source>
          <target state="translated">要在此统计信息对象中计算的统计信息种类。当前支持的类型是 &lt;code&gt;ndistinct&lt;/code&gt; ，它启用n-distinct统计信息； &lt;code&gt;dependencies&lt;/code&gt; ，启用功能依赖关系统计信息； &lt;code&gt;mcv&lt;/code&gt; ，启用最常见的值列表。如果省略此子句，则所有受支持的统计信息类型都包括在统计信息对象中。有关更多信息，请参见&lt;a href=&quot;planner-stats#PLANNER-STATS-EXTENDED&quot;&gt;第14.2.2 &lt;/a&gt;&lt;a href=&quot;multivariate-statistics-examples&quot;&gt;节&lt;/a&gt;和第70.2节。</target>
        </trans-unit>
        <trans-unit id="7afb9dfc5301530890be994c8fdaea740d424bc6" translate="yes" xml:space="preserve">
          <source>A storage structure that keeps metadata about each data page of a table's main fork. The free space map entry for each page stores the amount of free space that's available for future tuples, and is structured to be efficiently searched for available space for a new tuple of a given size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92d5e9e679ad2ea336688f58c0cc38f17ebb2361" translate="yes" xml:space="preserve">
          <source>A storage structure that keeps metadata about each data page of a table's main fork. The visibility map entry for each page stores two bits: the first one (&lt;code&gt;all-visible&lt;/code&gt;) indicates that all tuples in the page are visible to all transactions. The second one (&lt;code&gt;all-frozen&lt;/code&gt;) indicates that all tuples in the page are marked frozen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="069a72422c3cc6a607349a4e700ca343dee3bf3a" translate="yes" xml:space="preserve">
          <source>A stored array value can be enlarged by assigning to elements not already present. Any positions between those previously present and the newly assigned elements will be filled with nulls. For example, if array &lt;code&gt;myarray&lt;/code&gt; currently has 4 elements, it will have six elements after an update that assigns to &lt;code&gt;myarray[6]&lt;/code&gt;; &lt;code&gt;myarray[5]&lt;/code&gt; will contain null. Currently, enlargement in this fashion is only allowed for one-dimensional arrays, not multidimensional arrays.</source>
          <target state="translated">可以通过分配不存在的元素来扩大存储的数组值。先前存在的元素和新分配的元素之间的任何位置都将填充为空。例如，如果数组 &lt;code&gt;myarray&lt;/code&gt; 当前具有4个元素，则在分配给 &lt;code&gt;myarray[6]&lt;/code&gt; 的更新之后它将具有六个元素； &lt;code&gt;myarray[5]&lt;/code&gt; 将包含null。当前，仅允许一维数组而不是多维数组以这种方式进行扩展。</target>
        </trans-unit>
        <trans-unit id="dffe36d8e51b4ef2ab1fe0c1b3e201415f713820" translate="yes" xml:space="preserve">
          <source>A string constant defining the function; the meaning depends on the language. It can be an internal function name, the path to an object file, an SQL command, or text in a procedural language.</source>
          <target state="translated">一个定义函数的字符串常量;其含义取决于语言。它可以是内部函数名、对象文件的路径、SQL命令或程序语言中的文本。</target>
        </trans-unit>
        <trans-unit id="dbfdac594b047310ca108ad639b27f52bf3906ca" translate="yes" xml:space="preserve">
          <source>A string constant defining the procedure; the meaning depends on the language. It can be an internal procedure name, the path to an object file, an SQL command, or text in a procedural language.</source>
          <target state="translated">一个定义过程的字符串常量;其含义取决于语言。它可以是一个内部存储过程的名称,一个对象文件的路径,一个SQL命令,或者是程序语言中的文本。</target>
        </trans-unit>
        <trans-unit id="f2a8b822478dd09960c81d58138d7e54120409b2" translate="yes" xml:space="preserve">
          <source>A string constant in SQL is an arbitrary sequence of characters bounded by single quotes (&lt;code&gt;'&lt;/code&gt;), for example &lt;code&gt;'This is a string'&lt;/code&gt;. To include a single-quote character within a string constant, write two adjacent single quotes, e.g., &lt;code&gt;'Dianne''s horse'&lt;/code&gt;. Note that this is &lt;em&gt;not&lt;/em&gt; the same as a double-quote character (&lt;code&gt;&quot;&lt;/code&gt;).</source>
          <target state="translated">SQL中的字符串常量是由单引号（ &lt;code&gt;'&lt;/code&gt; ）界定的任意字符序列，例如 &lt;code&gt;'This is a string'&lt;/code&gt; 。要在字符串常量中包含单引号字符，请写两个相邻的单引号，例如 &lt;code&gt;'Dianne''s horse'&lt;/code&gt; 。请注意，这是&lt;em&gt;不&lt;/em&gt;一样的双引号（ &lt;code&gt;&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9740675c09c16dac87aea8ba937f0db10ddc9e95" translate="yes" xml:space="preserve">
          <source>A string literal representing the textual label associated with one value of an enum type.</source>
          <target state="translated">表示与枚举类型的一个值相关联的文本标签的字符串文字。</target>
        </trans-unit>
        <trans-unit id="349698cab225818ce6aaeac8a591649416d8d5ab" translate="yes" xml:space="preserve">
          <source>A string of the form &lt;code&gt;&lt;em&gt;n&lt;/em&gt;$&lt;/code&gt; where &lt;em&gt;&lt;code&gt;n&lt;/code&gt;&lt;/em&gt; is the index of the argument to print. Index 1 means the first argument after &lt;em&gt;&lt;code&gt;formatstr&lt;/code&gt;&lt;/em&gt;. If the &lt;em&gt;&lt;code&gt;position&lt;/code&gt;&lt;/em&gt; is omitted, the default is to use the next argument in sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b5b7ed5b9f283f907a7fca459d4258127f634e3" translate="yes" xml:space="preserve">
          <source>A string of the form &lt;code&gt;n$&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; is the index of the argument to print. Index 1 means the first argument after &lt;code&gt;formatstr&lt;/code&gt;. If the &lt;code&gt;position&lt;/code&gt; is omitted, the default is to use the next argument in sequence.</source>
          <target state="translated">&lt;code&gt;n$&lt;/code&gt; 形式的字符串，其中 &lt;code&gt;n&lt;/code&gt; 是要打印的参数的索引。索引1表示 &lt;code&gt;formatstr&lt;/code&gt; 之后的第一个参数。如果省略 &lt;code&gt;position&lt;/code&gt; ，则默认为依次使用下一个参数。</target>
        </trans-unit>
        <trans-unit id="ddfb60a35b54b4a543c700ebe6924626aa1923e3" translate="yes" xml:space="preserve">
          <source>A string-like syntax is used for working with string types and for working with complex extension types. Strings with unspecified type are matched with likely operator candidates.</source>
          <target state="translated">类似字符串的语法用于处理字符串类型和处理复杂的扩展类型。未指定类型的字符串将与可能的操作符候选者匹配。</target>
        </trans-unit>
        <trans-unit id="1cc21b370e49b36cc3877fbc8b204fee390f5ba0" translate="yes" xml:space="preserve">
          <source>A sub-&lt;code&gt;SELECT&lt;/code&gt; can appear in the &lt;code&gt;FROM&lt;/code&gt; clause. This acts as though its output were created as a temporary table for the duration of this single &lt;code&gt;SELECT&lt;/code&gt; command. Note that the sub-&lt;code&gt;SELECT&lt;/code&gt; must be surrounded by parentheses, and an alias &lt;em&gt;must&lt;/em&gt; be provided for it. A &lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt; command can also be used here.</source>
          <target state="translated">子 &lt;code&gt;SELECT&lt;/code&gt; 可以出现在 &lt;code&gt;FROM&lt;/code&gt; 子句中。这就像在单个 &lt;code&gt;SELECT&lt;/code&gt; 命令期间将其输出创建为临时表一样。注意，子 &lt;code&gt;SELECT&lt;/code&gt; 必须用括号括起来，并且&lt;em&gt;必须&lt;/em&gt;为其提供别名。一个&lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt;命令也可以在这里使用。</target>
        </trans-unit>
        <trans-unit id="20d744869b3f288cd0f4b443c304ea51738904ae" translate="yes" xml:space="preserve">
          <source>A subquery can also be a &lt;code&gt;VALUES&lt;/code&gt; list:</source>
          <target state="translated">子查询也可以是 &lt;code&gt;VALUES&lt;/code&gt; 列表：</target>
        </trans-unit>
        <trans-unit id="467730923a1355f01d0ecc067917a4e744b3c1af" translate="yes" xml:space="preserve">
          <source>A subscriber node may have multiple subscriptions if desired. It is possible to define multiple subscriptions between a single publisher-subscriber pair, in which case care must be taken to ensure that the subscribed publication objects don't overlap.</source>
          <target state="translated">如果需要,一个订阅者节点可以有多个订阅。可以在一个出版商-订阅者对之间定义多个订阅,在这种情况下,必须注意确保订阅的出版物对象不重叠。</target>
        </trans-unit>
        <trans-unit id="d3b9d35fca34aebbff75a223845b5323b4b90739" translate="yes" xml:space="preserve">
          <source>A subscripted expression</source>
          <target state="translated">下标表达式</target>
        </trans-unit>
        <trans-unit id="e3de42d209ab44c2b82ef6de9aa6e4c065c039e8" translate="yes" xml:space="preserve">
          <source>A subscription can only be dropped by a superuser.</source>
          <target state="translated">只有超级用户才能放弃订阅。</target>
        </trans-unit>
        <trans-unit id="6aba51cc9b50b3a680d08e5aa1b132f7c7c53586" translate="yes" xml:space="preserve">
          <source>A substitute name for &lt;code&gt;table_name&lt;/code&gt;. When an alias is provided, it completely hides the actual name of the table. This is particularly useful when &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; targets a table named &lt;code&gt;excluded&lt;/code&gt;, since that will otherwise be taken as the name of the special table representing rows proposed for insertion.</source>
          <target state="translated">&lt;code&gt;table_name&lt;/code&gt; 的替代名称。提供别名后，它将完全隐藏表的实际名称。这是特别有用当 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 目标命名表 &lt;code&gt;excluded&lt;/code&gt; ，因为这否则将被视为代表提议插入行的特殊表的名称。</target>
        </trans-unit>
        <trans-unit id="1a3b95411aa0d3922856aa0c08c5b45d4d583913" translate="yes" xml:space="preserve">
          <source>A substitute name for the &lt;code&gt;FROM&lt;/code&gt; item containing the alias. An alias is used for brevity or to eliminate ambiguity for self-joins (where the same table is scanned multiple times). When an alias is provided, it completely hides the actual name of the table or function; for example given &lt;code&gt;FROM foo AS f&lt;/code&gt;, the remainder of the &lt;code&gt;SELECT&lt;/code&gt; must refer to this &lt;code&gt;FROM&lt;/code&gt; item as &lt;code&gt;f&lt;/code&gt; not &lt;code&gt;foo&lt;/code&gt;. If an alias is written, a column alias list can also be written to provide substitute names for one or more columns of the table.</source>
          <target state="translated">包含别名的 &lt;code&gt;FROM&lt;/code&gt; 项目的替代名称。别名是为了简洁起见或消除自联接的歧义（多次扫描同一张表）。提供别名后，它将完全隐藏表或函数的实际名称。例如，在给定 &lt;code&gt;FROM foo AS f&lt;/code&gt; 的情况下， &lt;code&gt;SELECT&lt;/code&gt; 的其余部分必须将此 &lt;code&gt;FROM&lt;/code&gt; 项目引用为 &lt;code&gt;f&lt;/code&gt; 而不是 &lt;code&gt;foo&lt;/code&gt; 。如果写入了别名，则还可以写入列别名列表以为表的一个或多个列提供替代名称。</target>
        </trans-unit>
        <trans-unit id="3b6a0087f5676053b92594d5853d2ef232106666" translate="yes" xml:space="preserve">
          <source>A substitute name for the target table. When an alias is provided, it completely hides the actual name of the table. For example, given &lt;code&gt;DELETE FROM foo AS f&lt;/code&gt;, the remainder of the &lt;code&gt;DELETE&lt;/code&gt; statement must refer to this table as &lt;code&gt;f&lt;/code&gt; not &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">目标表的替代名称。提供别名后，它将完全隐藏表的实际名称。例如，在给定 &lt;code&gt;DELETE FROM foo AS f&lt;/code&gt; 的情况下， &lt;code&gt;DELETE&lt;/code&gt; 语句的其余部分必须将此表称为 &lt;code&gt;f&lt;/code&gt; 而不是 &lt;code&gt;foo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c430b6c82238597e098d25669857d482151c353" translate="yes" xml:space="preserve">
          <source>A substitute name for the target table. When an alias is provided, it completely hides the actual name of the table. For example, given &lt;code&gt;UPDATE foo AS f&lt;/code&gt;, the remainder of the &lt;code&gt;UPDATE&lt;/code&gt; statement must refer to this table as &lt;code&gt;f&lt;/code&gt; not &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">目标表的替代名称。提供别名后，它将完全隐藏表的实际名称。例如，在给定 &lt;code&gt;UPDATE foo AS f&lt;/code&gt; 的情况下， &lt;code&gt;UPDATE&lt;/code&gt; 语句的其余部分必须将此表称为 &lt;code&gt;f&lt;/code&gt; not &lt;code&gt;foo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79a0d38239253966494c7a744510fc637f363e29" translate="yes" xml:space="preserve">
          <source>A successful run will exit with status 0. Exit status 1 indicates static problems such as invalid command-line options. Errors during the run such as database errors or problems in the script will result in exit status 2. In the latter case, pgbench will print partial results.</source>
          <target state="translated">成功的运行将以状态0退出,退出状态1表示静态问题,如无效的命令行选项。运行过程中的错误,如数据库错误或脚本中的问题将导致退出状态2。在后一种情况下,pgbench将打印部分结果。</target>
        </trans-unit>
        <trans-unit id="81738814316428e9e33dbf3e06dfac5985eb834b" translate="yes" xml:space="preserve">
          <source>A superuser may override this check on a per-user-mapping basis by setting the user mapping option &lt;code&gt;password_required 'false'&lt;/code&gt;, e.g.,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00a652a2bcf1b7844eb4e57bf495f13644006240" translate="yes" xml:space="preserve">
          <source>A synchronous replica receiving changes via logical decoding will work in the scope of a single database. Since, in contrast to that, &lt;em&gt;&lt;code&gt;synchronous_standby_names&lt;/code&gt;&lt;/em&gt; currently is server wide, this means this technique will not work properly if more than one database is actively used.</source>
          <target state="translated">通过逻辑解码接收更改的同步副本将在单个数据库的范围内工作。与此相反，由于&lt;em&gt; &lt;code&gt;synchronous_standby_names&lt;/code&gt; &lt;/em&gt;当前在服务器范围内，因此这意味着如果主动使用多个数据库，则该技术将无法正常工作。</target>
        </trans-unit>
        <trans-unit id="53732038fc5add15dbcd0175e133d7a901f6ac5b" translate="yes" xml:space="preserve">
          <source>A synchronous standby can be a physical replication standby or a logical replication subscriber. It can also be any other physical or logical WAL replication stream consumer that knows how to send the appropriate feedback messages. Besides the built-in physical and logical replication systems, this includes special programs such as &lt;code&gt;pg_receivewal&lt;/code&gt; and &lt;code&gt;pg_recvlogical&lt;/code&gt; as well as some third-party replication systems and custom programs. Check the respective documentation for details on synchronous replication support.</source>
          <target state="translated">同步备用数据库可以是物理复制备用数据库或逻辑复制订阅服务器。也可以是知道如何发送适当反馈消息的任何其他物理或逻辑WAL复制流使用者。除了内置的物理和逻辑复制系统之外，它还包括诸如 &lt;code&gt;pg_receivewal&lt;/code&gt; 和 &lt;code&gt;pg_recvlogical&lt;/code&gt; 类的特殊程序，以及一些第三方复制系统和自定义程序。查看相应的文档以获取有关同步复制支持的详细信息。</target>
        </trans-unit>
        <trans-unit id="ac835affae95f586b86b74d66f86a082fb9c7b5d" translate="yes" xml:space="preserve">
          <source>A table access method handler function must be declared to accept a single argument of type &lt;code&gt;internal&lt;/code&gt; and to return the pseudo-type &lt;code&gt;table_am_handler&lt;/code&gt;. The argument is a dummy value that simply serves to prevent handler functions from being called directly from SQL commands. The result of the function must be a pointer to a struct of type &lt;code&gt;TableAmRoutine&lt;/code&gt;, which contains everything that the core code needs to know to make use of the table access method. The return value needs to be of server lifetime, which is typically achieved by defining it as a &lt;code&gt;static const&lt;/code&gt; variable in global scope. The &lt;code&gt;TableAmRoutine&lt;/code&gt; struct, also called the access method's &lt;em&gt;API struct&lt;/em&gt;, defines the behavior of the access method using callbacks. These callbacks are pointers to plain C functions and are not visible or callable at the SQL level. All the callbacks and their behavior is defined in the &lt;code&gt;TableAmRoutine&lt;/code&gt; structure (with comments inside the struct defining the requirements for callbacks). Most callbacks have wrapper functions, which are documented from the point of view of a user (rather than an implementor) of the table access method. For details, please refer to the &lt;a href=&quot;https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=src/include/access/tableam.h;hb=HEAD&quot;&gt;&lt;code&gt;src/include/access/tableam.h&lt;/code&gt;&lt;/a&gt; file.</source>
          <target state="translated">必须声明一个表访问方法处理程序函数以接受一个 &lt;code&gt;internal&lt;/code&gt; 类型的单个参数并返回伪类型 &lt;code&gt;table_am_handler&lt;/code&gt; 。该参数是一个伪值，仅用于防止直接从SQL命令调用处理函数。该函数的结果必须是一个指向 &lt;code&gt;TableAmRoutine&lt;/code&gt; 类型的结构的指针，该结构包含核心代码使用表访问方法所需了解的所有内容。返回值必须具有服务器生存期，通常通过将其定义为全局范围内的 &lt;code&gt;static const&lt;/code&gt; 变量来实现。该 &lt;code&gt;TableAmRoutine&lt;/code&gt; 结构，也被称为访问方法的&lt;em&gt;API结构&lt;/em&gt;，使用回调定义访问方法的行为。这些回调是指向普通C函数的指针，在SQL级别不可见或不可调用。所有回调及其行为均在 &lt;code&gt;TableAmRoutine&lt;/code&gt; 结构中定义（结构中的注释定义了回调的要求）。大多数回调都具有包装函数，这些包装函数是从表访问方法的用户（而不是实现者）的角度记录的。有关详细信息，请参阅&lt;a href=&quot;https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=src/include/access/tableam.h;hb=HEAD&quot;&gt; &lt;code&gt;src/include/access/tableam.h&lt;/code&gt; &lt;/a&gt;文件。</target>
        </trans-unit>
        <trans-unit id="419d15e411a83cc5bd408b7d5b9d3b39c40e3df3" translate="yes" xml:space="preserve">
          <source>A table access method handler is declared to return &lt;code&gt;table_am_handler&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ff995032ef85b617d95b6ca1e8cb93045b2fac9" translate="yes" xml:space="preserve">
          <source>A table can have at most one primary key. (There can be any number of unique and not-null constraints, which are functionally almost the same thing, but only one can be identified as the primary key.) Relational database theory dictates that every table must have a primary key. This rule is not enforced by PostgreSQL, but it is usually best to follow it.</source>
          <target state="translated">一个表最多可以有一个主键。(可以有任意数量的唯一约束和非空约束,这些约束在功能上几乎是一样的,但只有一个可以被确定为主键)。关系型数据库理论规定,每个表都必须有一个主键。这个规则并不是PostgreSQL所强制执行的,但通常最好是遵循这个规则。</target>
        </trans-unit>
        <trans-unit id="a5dd3a29c662f0d5a9fc9f1c03648ba7178abbb4" translate="yes" xml:space="preserve">
          <source>A table can have more than one foreign key constraint. This is used to implement many-to-many relationships between tables. Say you have tables about products and orders, but now you want to allow one order to contain possibly many products (which the structure above did not allow). You could use this table structure:</source>
          <target state="translated">一个表可以有一个以上的外键约束。这用于实现表之间的多对多关系。假设你有关于产品和订单的表,但现在你想允许一个订单可能包含许多产品(上面的结构不允许)。你可以使用这种表结构。</target>
        </trans-unit>
        <trans-unit id="ea2feaef62849b073ab499dff5691a69fec6f5f4" translate="yes" xml:space="preserve">
          <source>A table can inherit from more than one parent table, in which case it has the union of the columns defined by the parent tables. Any columns declared in the child table's definition are added to these. If the same column name appears in multiple parent tables, or in both a parent table and the child's definition, then these columns are &amp;ldquo;merged&amp;rdquo; so that there is only one such column in the child table. To be merged, columns must have the same data types, else an error is raised. Inheritable check constraints and not-null constraints are merged in a similar fashion. Thus, for example, a merged column will be marked not-null if any one of the column definitions it came from is marked not-null. Check constraints are merged if they have the same name, and the merge will fail if their conditions are different.</source>
          <target state="translated">一个表可以从多个父表中继承，在这种情况下，它具有父表定义的列的并集。子表的定义中声明的所有列都将添加到这些列中。如果相同的列名称出现在多个父表中，或者出现在父表和子表的定义中，则这些列将被&amp;ldquo;合并&amp;rdquo;，因此子表中只有一个这样的列。要合并，列必须具有相同的数据类型，否则会引发错误。可继承的检查约束和非空约束以类似的方式合并。因此，例如，如果合并列来自的任何一个列定义都标记为非空，则该合并列将被标记为非空。如果检查约束具有相同的名称，则合并它们；如果它们的条件不同，则合并将失败。</target>
        </trans-unit>
        <trans-unit id="b60ab6e47e92c777a5fb70888a73042517cd9738" translate="yes" xml:space="preserve">
          <source>A table cannot have more than 1600 columns. (In practice, the effective limit is usually lower because of tuple-length constraints.)</source>
          <target state="translated">一个表的列数不能超过1600列。在实践中,由于元组长度的限制,有效的限制通常较低)。</target>
        </trans-unit>
        <trans-unit id="d9a20219501c53fe0d9df9736a36bbb3c0e01830" translate="yes" xml:space="preserve">
          <source>A table expression allowing columns from other tables to appear in the &lt;code&gt;WHERE&lt;/code&gt; condition and update expressions. This uses the same syntax as the &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt;&lt;code&gt;FROM&lt;/code&gt;&lt;/a&gt; clause of a &lt;code&gt;SELECT&lt;/code&gt; statement; for example, an alias for the table name can be specified. Do not repeat the target table as a &lt;code&gt;from_item&lt;/code&gt; unless you intend a self-join (in which case it must appear with an alias in the &lt;code&gt;from_item&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9427796f4e0c19b3da10d1c29ad2a87a93a84b6f" translate="yes" xml:space="preserve">
          <source>A table expression allowing columns from other tables to appear in the &lt;code&gt;WHERE&lt;/code&gt; condition. This uses the same syntax as the &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt;&lt;code&gt;FROM&lt;/code&gt;&lt;/a&gt; clause of a &lt;code&gt;SELECT&lt;/code&gt; statement; for example, an alias for the table name can be specified. Do not repeat the target table as a &lt;code&gt;from_item&lt;/code&gt; unless you wish to set up a self-join (in which case it must appear with an alias in the &lt;code&gt;from_item&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40d4dec2662223321ee541222a2fb74e1b35e9b6" translate="yes" xml:space="preserve">
          <source>A table in a relational database is much like a table on paper: It consists of rows and columns. The number and order of the columns is fixed, and each column has a name. The number of rows is variable &amp;mdash; it reflects how much data is stored at a given moment. SQL does not make any guarantees about the order of the rows in a table. When a table is read, the rows will appear in an unspecified order, unless sorting is explicitly requested. This is covered in &lt;a href=&quot;https://www.postgresql.org/docs/12/queries.html&quot;&gt;Chapter 7&lt;/a&gt;. Furthermore, SQL does not assign unique identifiers to rows, so it is possible to have several completely identical rows in a table. This is a consequence of the mathematical model that underlies SQL but is usually not desirable. Later in this chapter we will see how to deal with this issue.</source>
          <target state="translated">关系数据库中的表很像纸上表：它由行和列组成。列的数量和顺序是固定的，并且每列都有一个名称。行数是可变的-它反映了给定时刻存储了多少数据。 SQL对表中行的顺序不做任何保证。读取表时，除非明确要求排序，否则行将以未指定的顺序显示。这将在&lt;a href=&quot;https://www.postgresql.org/docs/12/queries.html&quot;&gt;第7章中介绍&lt;/a&gt;。此外，SQL不会为行分配唯一的标识符，因此表中可能有几个完全相同的行。这是基于SQL的数学模型的结果，但通常是不希望的。在本章的后面，我们将看到如何处理这个问题。</target>
        </trans-unit>
        <trans-unit id="d3a09d1c3ee1c32fce111e8e9a61e27e850dce55" translate="yes" xml:space="preserve">
          <source>A table in a relational database is much like a table on paper: It consists of rows and columns. The number and order of the columns is fixed, and each column has a name. The number of rows is variable &amp;mdash; it reflects how much data is stored at a given moment. SQL does not make any guarantees about the order of the rows in a table. When a table is read, the rows will appear in an unspecified order, unless sorting is explicitly requested. This is covered in &lt;a href=&quot;https://www.postgresql.org/docs/13/queries.html&quot;&gt;Chapter 7&lt;/a&gt;. Furthermore, SQL does not assign unique identifiers to rows, so it is possible to have several completely identical rows in a table. This is a consequence of the mathematical model that underlies SQL but is usually not desirable. Later in this chapter we will see how to deal with this issue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b7ed2eab9cf794fb325a1b40465300bd26db30b" translate="yes" xml:space="preserve">
          <source>A table reference can be a table name (possibly schema-qualified), or a derived table such as a subquery, a &lt;code&gt;JOIN&lt;/code&gt; construct, or complex combinations of these. If more than one table reference is listed in the &lt;code&gt;FROM&lt;/code&gt; clause, the tables are cross-joined (that is, the Cartesian product of their rows is formed; see below). The result of the &lt;code&gt;FROM&lt;/code&gt; list is an intermediate virtual table that can then be subject to transformations by the &lt;code&gt;WHERE&lt;/code&gt;, &lt;code&gt;GROUP BY&lt;/code&gt;, and &lt;code&gt;HAVING&lt;/code&gt; clauses and is finally the result of the overall table expression.</source>
          <target state="translated">表引用可以是表名称（可能是架构限定的），也可以是派生表，例如子查询， &lt;code&gt;JOIN&lt;/code&gt; 构造或这些的复杂组合。如果 &lt;code&gt;FROM&lt;/code&gt; 子句中列出了多个表引用，则表将交叉连接（即，形成其行的笛卡尔积；请参见下文）。 &lt;code&gt;FROM&lt;/code&gt; 列表的结果是一个中间虚拟表，然后可以通过 &lt;code&gt;WHERE&lt;/code&gt; ， &lt;code&gt;GROUP BY&lt;/code&gt; 和 &lt;code&gt;HAVING&lt;/code&gt; 子句进行转换，并且最终是整个表表达式的结果。</target>
        </trans-unit>
        <trans-unit id="8ea15f1133af85b529e072e262c881e0f91d10ea" translate="yes" xml:space="preserve">
          <source>A table that has columns with potentially large entries will have an associated &lt;em&gt;TOAST&lt;/em&gt; table, which is used for out-of-line storage of field values that are too large to keep in the table rows proper. &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;reltoastrelid&lt;/code&gt; links from a table to its TOAST table, if any. See &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt; for more information.</source>
          <target state="translated">包含可能包含较大条目的列的表将具有关联的&lt;em&gt;TOAST&lt;/em&gt;表，该表用于离线存储字段值太大而无法正确保存在表行中。 &lt;code&gt;pg_class&lt;/code&gt; 。从表到其TOAST表的 &lt;code&gt;reltoastrelid&lt;/code&gt; 链接（如果有）。有关更多信息，请参见&lt;a href=&quot;storage-toast&quot;&gt;第68.2节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4c16bcd4cf40264715bc5e3b5d07ef4d9afb5816" translate="yes" xml:space="preserve">
          <source>A tablesample method handler is declared to return &lt;code&gt;tsm_handler&lt;/code&gt;.</source>
          <target state="translated">声明了tablesample方法处理程序以返回 &lt;code&gt;tsm_handler&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="816a4cd8c0ed513824b7c88b1bb7cf4571478fb1" translate="yes" xml:space="preserve">
          <source>A tablespace allows superusers to define an alternative location on the file system where the data files containing database objects (such as tables and indexes) can reside.</source>
          <target state="translated">表空间允许超级用户在文件系统上定义一个替代位置,包含数据库对象(如表和索引)的数据文件可以存放在那里。</target>
        </trans-unit>
        <trans-unit id="820b586a949a1d02483ccf3a6e05f26f2fdbeced" translate="yes" xml:space="preserve">
          <source>A tablespace can only be dropped by its owner or a superuser. The tablespace must be empty of all database objects before it can be dropped. It is possible that objects in other databases might still reside in the tablespace even if no objects in the current database are using the tablespace. Also, if the tablespace is listed in the &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt; setting of any active session, the &lt;code&gt;DROP&lt;/code&gt; might fail due to temporary files residing in the tablespace.</source>
          <target state="translated">表空间只能由其所有者或超级用户删除。在删除表空间之前，表空间中的所有数据库对象必须为空。即使当前数据库中没有对象正在使用表空间，其他数据库中的对象也可能仍驻留在表空间中。另外，如果在任何活动会话的&lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt;设置中列出了表空间，则由于表空间中存在临时文件， &lt;code&gt;DROP&lt;/code&gt; 可能会失败。</target>
        </trans-unit>
        <trans-unit id="d48bc9df0b7c8031d0790b2f1fc9c85172017b3e" translate="yes" xml:space="preserve">
          <source>A tablespace cannot be used independently of the cluster in which it is defined; see &lt;a href=&quot;manage-ag-tablespaces&quot;&gt;Section 22.6&lt;/a&gt;.</source>
          <target state="translated">表空间不能独立于定义表空间的集群使用。参见&lt;a href=&quot;manage-ag-tablespaces&quot;&gt;第22.6节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d579dc88e9cdf352d2f344d0841a4b50c6608379" translate="yes" xml:space="preserve">
          <source>A tablespace parameter to be set or reset. Currently, the only available parameters are &lt;code&gt;seq_page_cost&lt;/code&gt;, &lt;code&gt;random_page_cost&lt;/code&gt; and &lt;code&gt;effective_io_concurrency&lt;/code&gt;. Setting either value for a particular tablespace will override the planner's usual estimate of the cost of reading pages from tables in that tablespace, as established by the configuration parameters of the same name (see &lt;a href=&quot;runtime-config-query#GUC-SEQ-PAGE-COST&quot;&gt;seq_page_cost&lt;/a&gt;, &lt;a href=&quot;runtime-config-query#GUC-RANDOM-PAGE-COST&quot;&gt;random_page_cost&lt;/a&gt;, &lt;a href=&quot;runtime-config-resource#GUC-EFFECTIVE-IO-CONCURRENCY&quot;&gt;effective_io_concurrency&lt;/a&gt;). This may be useful if one tablespace is located on a disk which is faster or slower than the remainder of the I/O subsystem.</source>
          <target state="translated">要设置或重置的表空间参数。目前，唯一可用的参数是 &lt;code&gt;seq_page_cost&lt;/code&gt; ， &lt;code&gt;random_page_cost&lt;/code&gt; 和 &lt;code&gt;effective_io_concurrency&lt;/code&gt; 。为特定表空间设置这两个值将覆盖计划者通常对从该表空间中读取表的页的开销的估计，这是由同名的配置参数确定的（请参见&lt;a href=&quot;runtime-config-query#GUC-SEQ-PAGE-COST&quot;&gt;seq_page_cost&lt;/a&gt;，&lt;a href=&quot;runtime-config-query#GUC-RANDOM-PAGE-COST&quot;&gt;random_page_cost&lt;/a&gt;，&lt;a href=&quot;runtime-config-resource#GUC-EFFECTIVE-IO-CONCURRENCY&quot;&gt;effective_io_concurrency&lt;/a&gt;）。如果一个表空间位于比I / O子系统的其余部分更快或更慢的磁盘上，则这可能很有用。</target>
        </trans-unit>
        <trans-unit id="4c99f85ae41b2644b7b55fc1d2d2a8d62880eaa2" translate="yes" xml:space="preserve">
          <source>A tablespace parameter to be set or reset. Currently, the only available parameters are &lt;code&gt;seq_page_cost&lt;/code&gt;, &lt;code&gt;random_page_cost&lt;/code&gt;, &lt;code&gt;effective_io_concurrency&lt;/code&gt; and &lt;code&gt;maintenance_io_concurrency&lt;/code&gt;. Setting these values for a particular tablespace will override the planner's usual estimate of the cost of reading pages from tables in that tablespace, and the executor's prefetching behavior, as established by the configuration parameters of the same name (see &lt;a href=&quot;runtime-config-query#GUC-SEQ-PAGE-COST&quot;&gt;seq_page_cost&lt;/a&gt;, &lt;a href=&quot;runtime-config-query#GUC-RANDOM-PAGE-COST&quot;&gt;random_page_cost&lt;/a&gt;, &lt;a href=&quot;runtime-config-resource#GUC-EFFECTIVE-IO-CONCURRENCY&quot;&gt;effective_io_concurrency&lt;/a&gt;, &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-IO-CONCURRENCY&quot;&gt;maintenance_io_concurrency&lt;/a&gt;). This may be useful if one tablespace is located on a disk which is faster or slower than the remainder of the I/O subsystem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ac97e0fad0b28b51a14115817e32577fe4a0b90" translate="yes" xml:space="preserve">
          <source>A temporary name can be given to tables and complex table references to be used for references to the derived table in the rest of the query. This is called a &lt;em&gt;table alias&lt;/em&gt;.</source>
          <target state="translated">可以为表和复杂表引用指定一个临时名称，以用于其余查询中对派生表的引用。这称为&lt;em&gt;表别名&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="154e0fcec698de6b2015fa25f68088725ba8e1d2" translate="yes" xml:space="preserve">
          <source>A text search configuration binds a parser together with a set of dictionaries to process the parser's output tokens. For each token type that the parser can return, a separate list of dictionaries is specified by the configuration. When a token of that type is found by the parser, each dictionary in the list is consulted in turn, until some dictionary recognizes it as a known word. If it is identified as a stop word, or if no dictionary recognizes the token, it will be discarded and not indexed or searched for. Normally, the first dictionary that returns a non-&lt;code&gt;NULL&lt;/code&gt; output determines the result, and any remaining dictionaries are not consulted; but a filtering dictionary can replace the given word with a modified word, which is then passed to subsequent dictionaries.</source>
          <target state="translated">文本搜索配置将解析器与一组字典绑定在一起，以处理解析器的输出令牌。对于解析器可以返回的每种令牌类型，配置将指定一个单独的词典列表。当解析器找到该类型的标记时，将依次查询列表中的每个字典，直到某个字典将其识别为已知单词为止。如果将其标识为停用词，或者如果没有词典能够识别该标记，则它将被丢弃并且不会被索引或搜索。通常，第一个返回非 &lt;code&gt;NULL&lt;/code&gt; 输出的字典将确定结果，并且不查询其余的字典。但是过滤字典可以将给定的单词替换为修改后的单词，然后将其传递给后续的词典。</target>
        </trans-unit>
        <trans-unit id="b660e99784a0c9ca392fa9c70b6890953f937efa" translate="yes" xml:space="preserve">
          <source>A text search configuration specifies all options necessary to transform a document into a &lt;code&gt;tsvector&lt;/code&gt;: the parser to use to break text into tokens, and the dictionaries to use to transform each token into a lexeme. Every call of &lt;code&gt;to_tsvector&lt;/code&gt; or &lt;code&gt;to_tsquery&lt;/code&gt; needs a text search configuration to perform its processing. The configuration parameter &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config&lt;/a&gt; specifies the name of the default configuration, which is the one used by text search functions if an explicit configuration parameter is omitted. It can be set in &lt;code&gt;postgresql.conf&lt;/code&gt;, or set for an individual session using the &lt;code&gt;SET&lt;/code&gt; command.</source>
          <target state="translated">文本搜索配置指定将文档转换为 &lt;code&gt;tsvector&lt;/code&gt; 所需的所有选项：用于将文本分解为标记的解析器，以及用于将每个标记转换为词素的字典。每次 &lt;code&gt;to_tsvector&lt;/code&gt; 或 &lt;code&gt;to_tsquery&lt;/code&gt; 的调用都需要一个文本搜索配置来执行其处理。配置参数&lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config&lt;/a&gt;指定默认配置的名称，如果省略了明确的配置参数，则为文本搜索功能使用的名称。可以在 &lt;code&gt;postgresql.conf&lt;/code&gt; 中设置它，也可以使用 &lt;code&gt;SET&lt;/code&gt; 命令为单个会话设置它。</target>
        </trans-unit>
        <trans-unit id="bbb87e15ef4cfdfbfbbdeb4da5c6a41f2a086081" translate="yes" xml:space="preserve">
          <source>A thesaurus dictionary (sometimes abbreviated as TZ) is a collection of words that includes information about the relationships of words and phrases, i.e., broader terms (BT), narrower terms (NT), preferred terms, non-preferred terms, related terms, etc.</source>
          <target state="translated">词库词典(有时简称TZ)是一个词的集合,它包括词和词组的关系信息,即广义词(BT)、狭义词(NT)、首选词、非首选词、相关词等。</target>
        </trans-unit>
        <trans-unit id="657570ff202cabc5e9df7f56f8f1f48bd50b5f6f" translate="yes" xml:space="preserve">
          <source>A thesaurus dictionary uses a &lt;em&gt;subdictionary&lt;/em&gt; (which is specified in the dictionary's configuration) to normalize the input text before checking for phrase matches. It is only possible to select one subdictionary. An error is reported if the subdictionary fails to recognize a word. In that case, you should remove the use of the word or teach the subdictionary about it. You can place an asterisk (&lt;code&gt;*&lt;/code&gt;) at the beginning of an indexed word to skip applying the subdictionary to it, but all sample words &lt;em&gt;must&lt;/em&gt; be known to the subdictionary.</source>
          <target state="translated">甲同义词辞典使用&lt;em&gt;子字典&lt;/em&gt;（其在字典中的配置中指定）检查短语匹配之前归一化所述输入文本。只能选择一个子词典。如果子词典无法识别单词，则会报告错误。在这种情况下，您应该删除该词的使用或教它的附属词。您可以在已索引词的开头放置一个星号（ &lt;code&gt;*&lt;/code&gt; ），以跳过对它应用该子词典的步骤，但是该子词典&lt;em&gt;必须&lt;/em&gt;知道所有示例词。</target>
        </trans-unit>
        <trans-unit id="555f5a4dff77bb6e52e02e4204a9cef467ac2510" translate="yes" xml:space="preserve">
          <source>A third identifier type used by the system is &lt;code&gt;cid&lt;/code&gt;, or command identifier. This is the data type of the system columns &lt;code&gt;cmin&lt;/code&gt; and &lt;code&gt;cmax&lt;/code&gt;. Command identifiers are also 32-bit quantities.</source>
          <target state="translated">系统使用的第三种标识符类型是 &lt;code&gt;cid&lt;/code&gt; 或命令标识符。这是系统列 &lt;code&gt;cmin&lt;/code&gt; 和 &lt;code&gt;cmax&lt;/code&gt; 的数据类型。命令标识符也是32位量。</target>
        </trans-unit>
        <trans-unit id="ea6ae6aa8002700db2a8dea433bfc36222024c69" translate="yes" xml:space="preserve">
          <source>A third possible use for partial indexes does not require the index to be used in queries at all. The idea here is to create a unique index over a subset of a table, as in &lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX3&quot;&gt;Example 11.3&lt;/a&gt;. This enforces uniqueness among the rows that satisfy the index predicate, without constraining those that do not.</source>
          <target state="translated">部分索引的第三种可能用法根本不需要在查询中使用索引。这里的想法是在表的子集上创建唯一索引，如&lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX3&quot;&gt;示例11.3所示&lt;/a&gt;。这将在满足索引谓词的行之间强制唯一性，而不会限制不满足条件的行。</target>
        </trans-unit>
        <trans-unit id="47db754740c9f2ded7d303bbef7ae69f38fb4dbf" translate="yes" xml:space="preserve">
          <source>A time zone abbreviation, for example &lt;code&gt;PST&lt;/code&gt;. Such a specification merely defines a particular offset from UTC, in contrast to full time zone names which can imply a set of daylight savings transition rules as well. The recognized abbreviations are listed in the &lt;code&gt;pg_timezone_abbrevs&lt;/code&gt; view (see &lt;a href=&quot;view-pg-timezone-abbrevs&quot;&gt;Section 51.91&lt;/a&gt;). You cannot set the configuration parameters &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; or &lt;a href=&quot;runtime-config-logging#GUC-LOG-TIMEZONE&quot;&gt;log_timezone&lt;/a&gt; to a time zone abbreviation, but you can use abbreviations in date/time input values and with the &lt;code&gt;AT TIME ZONE&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd6336e70f63a890b86a6cdbf6ec2c2a9832cb6d" translate="yes" xml:space="preserve">
          <source>A time zone abbreviation, for example &lt;code&gt;PST&lt;/code&gt;. Such a specification merely defines a particular offset from UTC, in contrast to full time zone names which can imply a set of daylight savings transition-date rules as well. The recognized abbreviations are listed in the &lt;code&gt;pg_timezone_abbrevs&lt;/code&gt; view (see &lt;a href=&quot;view-pg-timezone-abbrevs&quot;&gt;Section 51.91&lt;/a&gt;). You cannot set the configuration parameters &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; or &lt;a href=&quot;runtime-config-logging#GUC-LOG-TIMEZONE&quot;&gt;log_timezone&lt;/a&gt; to a time zone abbreviation, but you can use abbreviations in date/time input values and with the &lt;code&gt;AT TIME ZONE&lt;/code&gt; operator.</source>
          <target state="translated">时区缩写，例如 &lt;code&gt;PST&lt;/code&gt; 。与全时区名称相反，这样的规范仅定义了与UTC的特定偏移量，而全时区名称也可能暗示一组夏令时过渡日期规则。公认的缩写在 &lt;code&gt;pg_timezone_abbrevs&lt;/code&gt; 视图中列出（请参见&lt;a href=&quot;view-pg-timezone-abbrevs&quot;&gt;第51.91节&lt;/a&gt;）。您不能将配置参数&lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt;或&lt;a href=&quot;runtime-config-logging#GUC-LOG-TIMEZONE&quot;&gt;log_timezone&lt;/a&gt;设置为时区缩写，但可以在日期/时间输入值中使用缩写，并与 &lt;code&gt;AT TIME ZONE&lt;/code&gt; 运算符一起使用。</target>
        </trans-unit>
        <trans-unit id="1c1c7cede62c34481ae2c11f0263c23892006d69" translate="yes" xml:space="preserve">
          <source>A time zone cannot be specified when processing &lt;code&gt;timestamp without time zone&lt;/code&gt; or &lt;code&gt;interval&lt;/code&gt; inputs. These are always taken at face value.</source>
          <target state="translated">在 &lt;code&gt;timestamp without time zone&lt;/code&gt; 或 &lt;code&gt;interval&lt;/code&gt; 输入的情况下处理时间戳时，无法指定时区。这些总是取材于面值。</target>
        </trans-unit>
        <trans-unit id="f8aefcc9f6e4a3be95cca7cfd42df6a2625d531c" translate="yes" xml:space="preserve">
          <source>A timezone abbreviation file can contain blank lines and comments beginning with &lt;code&gt;#&lt;/code&gt;. Non-comment lines must have one of these formats:</source>
          <target state="translated">时区缩写文件可以包含空行和以 &lt;code&gt;#&lt;/code&gt; 开头的注释。非注释行必须具有以下格式之一：</target>
        </trans-unit>
        <trans-unit id="61f64c13915c0871a3186bb5a87ae1ae25b54733" translate="yes" xml:space="preserve">
          <source>A token can be a &lt;em&gt;key word&lt;/em&gt;, an &lt;em&gt;identifier&lt;/em&gt;, a &lt;em&gt;quoted identifier&lt;/em&gt;, a &lt;em&gt;literal&lt;/em&gt; (or constant), or a special character symbol. Tokens are normally separated by whitespace (space, tab, newline), but need not be if there is no ambiguity (which is generally only the case if a special character is adjacent to some other token type).</source>
          <target state="translated">令牌可以是&lt;em&gt;关键字&lt;/em&gt;，&lt;em&gt;标识符&lt;/em&gt;，带&lt;em&gt;引号的标识符&lt;/em&gt;，&lt;em&gt;文字&lt;/em&gt;（或常量）或特殊字符符号。令牌通常由空格（空格，制表符，换行符）分隔，但如果不存在歧义则不需要（通常只有特殊字符与某些其他令牌类型相邻时才是这种情况）。</target>
        </trans-unit>
        <trans-unit id="8690158fd0b251c00dae6dfc7ede983456ddc45f" translate="yes" xml:space="preserve">
          <source>A token type emitted by the configuration's parser</source>
          <target state="translated">由配置解析器发出的标记类型。</target>
        </trans-unit>
        <trans-unit id="c55f58174d7a27cababe64df945ac6699fb690f5" translate="yes" xml:space="preserve">
          <source>A transaction can also see its own statistics (as yet untransmitted to the collector) in the views &lt;code&gt;pg_stat_xact_all_tables&lt;/code&gt;, &lt;code&gt;pg_stat_xact_sys_tables&lt;/code&gt;, &lt;code&gt;pg_stat_xact_user_tables&lt;/code&gt;, and &lt;code&gt;pg_stat_xact_user_functions&lt;/code&gt;. These numbers do not act as stated above; instead they update continuously throughout the transaction.</source>
          <target state="translated">事务还可以在视图 &lt;code&gt;pg_stat_xact_all_tables&lt;/code&gt; ， &lt;code&gt;pg_stat_xact_sys_tables&lt;/code&gt; ， &lt;code&gt;pg_stat_xact_user_tables&lt;/code&gt; 和 &lt;code&gt;pg_stat_xact_user_functions&lt;/code&gt; 视图中查看其自己的统计信息（尚未发送给收集器）。这些数字与上面所述不符；相反，它们在整个交易过程中不断更新。</target>
        </trans-unit>
        <trans-unit id="014bab7370933e95d60b2fbeb6b4ddd7ac675ebb" translate="yes" xml:space="preserve">
          <source>A transaction can export more than one snapshot, if needed. Note that doing so is only useful in &lt;code&gt;READ COMMITTED&lt;/code&gt; transactions, since in &lt;code&gt;REPEATABLE READ&lt;/code&gt; and higher isolation levels, transactions use the same snapshot throughout their lifetime. Once a transaction has exported any snapshots, it cannot be prepared with &lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d7c34d636397a5326ca01bffe81c685d0466ea6" translate="yes" xml:space="preserve">
          <source>A transaction re-executes a query returning a set of rows that satisfy a search condition and finds that the set of rows satisfying the condition has changed due to another recently-committed transaction.</source>
          <target state="translated">一个事务重新执行查询,返回满足搜索条件的行集,发现满足条件的行集由于最近提交的另一个事务发生了变化。</target>
        </trans-unit>
        <trans-unit id="f8c2fd7479305ce91383c02d70969dd66b2acddb" translate="yes" xml:space="preserve">
          <source>A transaction re-reads data it has previously read and finds that data has been modified by another transaction (that committed since the initial read).</source>
          <target state="translated">一个事务重新读取之前读取的数据,发现数据已经被另一个事务(自初始读取后提交)修改。</target>
        </trans-unit>
        <trans-unit id="c3382e299466bb042feceee6752ca8ef0259c657" translate="yes" xml:space="preserve">
          <source>A transaction reads data written by a concurrent uncommitted transaction.</source>
          <target state="translated">一个事务读取一个并发的未提交的事务所写的数据。</target>
        </trans-unit>
        <trans-unit id="f339f7f826bbe705459f4d6147b96402061e9382" translate="yes" xml:space="preserve">
          <source>A transaction that has executed &lt;code&gt;LISTEN&lt;/code&gt; cannot be prepared for two-phase commit.</source>
          <target state="translated">无法执行已执行 &lt;code&gt;LISTEN&lt;/code&gt; 的事务以进行两阶段提交。</target>
        </trans-unit>
        <trans-unit id="3d0230fafa23fc125f62b605c5c7adbafb550941" translate="yes" xml:space="preserve">
          <source>A transaction that has executed &lt;code&gt;NOTIFY&lt;/code&gt; cannot be prepared for two-phase commit.</source>
          <target state="translated">已执行 &lt;code&gt;NOTIFY&lt;/code&gt; 的事务无法为两阶段提交做好准备。</target>
        </trans-unit>
        <trans-unit id="6073bbb0958767b4f02cfd2e64c1259376f80a5e" translate="yes" xml:space="preserve">
          <source>A transaction that has executed &lt;code&gt;UNLISTEN&lt;/code&gt; cannot be prepared for two-phase commit.</source>
          <target state="translated">无法执行已执行 &lt;code&gt;UNLISTEN&lt;/code&gt; 的事务以进行两阶段提交。</target>
        </trans-unit>
        <trans-unit id="fbb0eb006f978734fefdbee822c93e37ab76e793" translate="yes" xml:space="preserve">
          <source>A transform specifies how to adapt a data type to a procedural language. For example, when writing a function in PL/Python using the &lt;code&gt;hstore&lt;/code&gt; type, PL/Python has no prior knowledge how to present &lt;code&gt;hstore&lt;/code&gt; values in the Python environment. Language implementations usually default to using the text representation, but that is inconvenient when, for example, an associative array or a list would be more appropriate.</source>
          <target state="translated">转换指定如何使数据类型适应过程语言。例如，当使用 &lt;code&gt;hstore&lt;/code&gt; 类型在PL / Python中编写函数时，PL / Python不具备如何在Python环境中呈现 &lt;code&gt;hstore&lt;/code&gt; 值的先验知识。语言实现通常默认情况下使用文本表示形式，但这在例如关联数组或列表更合适的情况下不方便。</target>
        </trans-unit>
        <trans-unit id="8c2b373e9fbb9296093271c1db45ed67d33a82b6" translate="yes" xml:space="preserve">
          <source>A transform specifies two functions:</source>
          <target state="translated">一个变换指定了两个功能。</target>
        </trans-unit>
        <trans-unit id="0c9fe367d63aa8028ded2402f8662551682fdc1d" translate="yes" xml:space="preserve">
          <source>A trigger function is declared to return &lt;code&gt;trigger.&lt;/code&gt;</source>
          <target state="translated">声明一个触发器函数以返回 &lt;code&gt;trigger.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e7aece537a33eef527a0311c288ac02d9c4de009" translate="yes" xml:space="preserve">
          <source>A trigger that is marked &lt;code&gt;FOR EACH ROW&lt;/code&gt; is called once for every row that the operation modifies. For example, a &lt;code&gt;DELETE&lt;/code&gt; that affects 10 rows will cause any &lt;code&gt;ON DELETE&lt;/code&gt; triggers on the target relation to be called 10 separate times, once for each deleted row. In contrast, a trigger that is marked &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt; only executes once for any given operation, regardless of how many rows it modifies (in particular, an operation that modifies zero rows will still result in the execution of any applicable &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt; triggers).</source>
          <target state="translated">标记为 &lt;code&gt;FOR EACH ROW&lt;/code&gt; 的触发器将为该操作修改的每一行调用一次。例如，影响10行的 &lt;code&gt;DELETE&lt;/code&gt; 将导致目标关系上的任何 &lt;code&gt;ON DELETE&lt;/code&gt; 触发器被单独调用10次，每删除一条行一次。相比之下，标记为 &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt; 的触发器仅对任何给定操作执行一次，无论其修改了多少行（特别是，修改零行的操作仍将导致执行任何适用的 &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt; 触发器） 。</target>
        </trans-unit>
        <trans-unit id="7eef7b97e3bd1ce7b7ee3cef5b1119d2228d0033" translate="yes" xml:space="preserve">
          <source>A trigram is a group of three consecutive characters taken from a string. We can measure the similarity of two strings by counting the number of trigrams they share. This simple idea turns out to be very effective for measuring the similarity of words in many natural languages.</source>
          <target state="translated">卦是指从一个字符串中抽取三个连续的字符组成的一组。我们可以通过计算两个字符串共享的卦数来衡量它们的相似度。这个简单的想法被证明对测量许多自然语言中单词的相似性非常有效。</target>
        </trans-unit>
        <trans-unit id="a08b1cdf2b0b095b9d5863bddf7e5d8e3d7c32c3" translate="yes" xml:space="preserve">
          <source>A trivial example of &lt;code&gt;LATERAL&lt;/code&gt; is</source>
          <target state="translated">&lt;code&gt;LATERAL&lt;/code&gt; 的一个简单例子是</target>
        </trans-unit>
        <trans-unit id="e8e38ccfb8ee20281247054f727fc62c3822f6eb" translate="yes" xml:space="preserve">
          <source>A type cast</source>
          <target state="translated">铸型</target>
        </trans-unit>
        <trans-unit id="3a3537ff39dd61d4d97ae8731a9b41e347a01f70" translate="yes" xml:space="preserve">
          <source>A type cast specifies a conversion from one data type to another. PostgreSQL accepts two equivalent syntaxes for type casts:</source>
          <target state="translated">类型转换指定了从一种数据类型到另一种数据类型的转换。PostgreSQL接受两种等价的类型转换语法。</target>
        </trans-unit>
        <trans-unit id="191f8bc0dbd057f5d062293ad47b726e2c4bd97b" translate="yes" xml:space="preserve">
          <source>A type of &lt;a href=&quot;glossary#GLOSSARY-CONSTRAINT&quot;&gt;constraint&lt;/a&gt; defined on a &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; which restricts the values allowed in one or a combination of columns so that each value or combination of values can only appear once in the relation &amp;mdash; that is, no other row in the relation contains values that are equal to those.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47769c3fbebe762aaf5ca2f230501fed1e2e6077" translate="yes" xml:space="preserve">
          <source>A type of &lt;a href=&quot;glossary#GLOSSARY-CONSTRAINT&quot;&gt;constraint&lt;/a&gt; defined on a &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; which restricts the values allowed in one or more &lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;attributes&lt;/a&gt;. The check constraint can make reference to any attribute of the same row in the relation, but cannot reference other rows of the same relation or other relations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e0d1fa65cb5707a942beda0ba4cefcb538e80bc" translate="yes" xml:space="preserve">
          <source>A type of &lt;a href=&quot;glossary#GLOSSARY-CONSTRAINT&quot;&gt;constraint&lt;/a&gt; defined on one or more &lt;a href=&quot;glossary#GLOSSARY-COLUMN&quot;&gt;columns&lt;/a&gt; in a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; which requires the value(s) in those &lt;a href=&quot;glossary#GLOSSARY-COLUMN&quot;&gt;columns&lt;/a&gt; to identify zero or one &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;row&lt;/a&gt; in another (or, infrequently, the same) &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d90f0d3baf2cdb5f8ece9a12f549c13ec0fed9a9" translate="yes" xml:space="preserve">
          <source>A type of &lt;a href=&quot;glossary#GLOSSARY-FUNCTION&quot;&gt;function&lt;/a&gt; used in a &lt;a href=&quot;glossary#GLOSSARY-QUERY&quot;&gt;query&lt;/a&gt; that applies to a &lt;a href=&quot;glossary#GLOSSARY-PARTITION&quot;&gt;partition&lt;/a&gt; of the query's &lt;a href=&quot;glossary#GLOSSARY-RESULT-SET&quot;&gt;result set&lt;/a&gt;; the function's result is based on values found in &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;rows&lt;/a&gt; of the same partition or frame.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf5a2e79c8fc1633f97f91eb24cc9a0675c7c13b" translate="yes" xml:space="preserve">
          <source>A type of relation that is used to generate values. Typically the generated values are sequential non-repeating numbers. They are commonly used to generate surrogate &lt;a href=&quot;glossary#GLOSSARY-PRIMARY-KEY&quot;&gt;primary key&lt;/a&gt; values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6c0d0a70cc72776a389a8d07d0b7fa59473f06b" translate="yes" xml:space="preserve">
          <source>A type of routine that receives zero or more arguments, returns zero or more output values, and is constrained to run within one transaction. Functions are invoked as part of a query, for example via &lt;code&gt;SELECT&lt;/code&gt;. Certain functions can return &lt;a href=&quot;glossary#GLOSSARY-RESULT-SET&quot;&gt;sets&lt;/a&gt;; those are called &lt;em&gt;set-returning functions&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="103d10d7e532eccef03717f65e1f2bc653ed5156" translate="yes" xml:space="preserve">
          <source>A type of routine. Their distinctive qualities are that they do not return values, and that they are allowed to make transactional statements such as &lt;code&gt;COMMIT&lt;/code&gt; and &lt;code&gt;ROLLBACK&lt;/code&gt;. They are invoked via the &lt;code&gt;CALL&lt;/code&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2685b870f0e5693341cc020b2215b601f4f13b60" translate="yes" xml:space="preserve">
          <source>A typical application of table aliases is to assign short identifiers to long table names to keep the join clauses readable. For example:</source>
          <target state="translated">表别名的一个典型应用是给长表名分配短的标识符,以保持连接子句的可读性。例如:</target>
        </trans-unit>
        <trans-unit id="53e9ce7093c6b3d709e92599c2e63f01a872a533" translate="yes" xml:space="preserve">
          <source>A typical cost estimator will proceed as follows:</source>
          <target state="translated">一个典型的成本估算器将进行如下操作:</target>
        </trans-unit>
        <trans-unit id="0dc6b779feedceaca26b9995072395fe22118094" translate="yes" xml:space="preserve">
          <source>A typical observed effect when this setting is on is that shared memory objects used for parallel query execution are removed at apparently random times, leading to errors and warnings while attempting to open and remove them, like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8d74e530024da711c01ee4999c6bbacc75f1477" translate="yes" xml:space="preserve">
          <source>A typical observed effect when this setting is on is that the semaphore objects used by a PostgreSQL server are removed at apparently random times, leading to the server crashing with log messages like</source>
          <target state="translated">当这个设置开启时,一个典型的观察效果是PostgreSQL服务器使用的旗语对象会在明显的随机时间被删除,导致服务器崩溃,日志信息包括</target>
        </trans-unit>
        <trans-unit id="3fc9f5b992a80655782589dd8a0df2c7a647d35a" translate="yes" xml:space="preserve">
          <source>A typical query that can use this index would be:</source>
          <target state="translated">一个典型的可以使用这个索引的查询是:</target>
        </trans-unit>
        <trans-unit id="0521362e3f43575ffcfbc899da16b98a9800ce48" translate="yes" xml:space="preserve">
          <source>A typical use is in reading the current value of the sequence for an identity or serial column, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="169a523c2d612c2511933ebb2897995bb069e2f2" translate="yes" xml:space="preserve">
          <source>A unique, cluster-wide identifier for the replication origin. Should never leave the system.</source>
          <target state="translated">复制源的唯一的、全集群的标识符。不应离开系统。</target>
        </trans-unit>
        <trans-unit id="47f21621fe9103c27d1085b3377ce1e6907d3fec" translate="yes" xml:space="preserve">
          <source>A unique, cluster-wide identifier for the replication slot</source>
          <target state="translated">复制槽的唯一、集群范围的标识符。</target>
        </trans-unit>
        <trans-unit id="5d4bfd425f4eb16bbefa46dacd068b22bd41528d" translate="yes" xml:space="preserve">
          <source>A useful property of &lt;code&gt;WITH&lt;/code&gt; queries is that they are normally evaluated only once per execution of the parent query, even if they are referred to more than once by the parent query or sibling &lt;code&gt;WITH&lt;/code&gt; queries. Thus, expensive calculations that are needed in multiple places can be placed within a &lt;code&gt;WITH&lt;/code&gt; query to avoid redundant work. Another possible application is to prevent unwanted multiple evaluations of functions with side-effects. However, the other side of this coin is that the optimizer is not able to push restrictions from the parent query down into a multiply-referenced &lt;code&gt;WITH&lt;/code&gt; query, since that might affect all uses of the &lt;code&gt;WITH&lt;/code&gt; query's output when it should affect only one. The multiply-referenced &lt;code&gt;WITH&lt;/code&gt; query will be evaluated as written, without suppression of rows that the parent query might discard afterwards. (But, as mentioned above, evaluation might stop early if the reference(s) to the query demand only a limited number of rows.)</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; 查询的一个有用属性是，即使父查询或同级 &lt;code&gt;WITH&lt;/code&gt; 查询多次引用它们，通常每次执行父查询也只会对它们进行一次评估。因此，可以在 &lt;code&gt;WITH&lt;/code&gt; 查询中放置多个位置所需的昂贵计算，以避免多余的工作。另一个可能的应用是防止对副作用进行不必要的多重评估。但是，另一方面，优化器无法将父查询的限制向下推到多重引用的 &lt;code&gt;WITH&lt;/code&gt; 查询中，因为当它只影响一个查询时，这可能会影响 &lt;code&gt;WITH&lt;/code&gt; 查询输出的所有使用。多重引用 &lt;code&gt;WITH&lt;/code&gt; 查询将被评估为已写入，而不会抑制父查询之后可能会丢弃的行。（但是，如上所述，如果对查询的引用仅需要有限的行数，则评估可能会提前停止。）</target>
        </trans-unit>
        <trans-unit id="46f8eb17a4dc6792884149cbde1b901dd618e58c" translate="yes" xml:space="preserve">
          <source>A user able to modify the schema of subscriber-side tables can execute arbitrary code as a superuser. Limit ownership and &lt;code&gt;TRIGGER&lt;/code&gt; privilege on such tables to roles that superusers trust. Moreover, if untrusted users can create tables, use only publications that list tables explicitly. That is to say, create a subscription &lt;code&gt;FOR ALL TABLES&lt;/code&gt; only when superusers trust every user permitted to create a non-temp table on the publisher or the subscriber.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="624d70f8d00542243273d8f95b839148832783a9" translate="yes" xml:space="preserve">
          <source>A user can also be allowed to create objects in someone else's schema. To allow that, the &lt;code&gt;CREATE&lt;/code&gt; privilege on the schema needs to be granted. Note that by default, everyone has &lt;code&gt;CREATE&lt;/code&gt; and &lt;code&gt;USAGE&lt;/code&gt; privileges on the schema &lt;code&gt;public&lt;/code&gt;. This allows all users that are able to connect to a given database to create objects in its &lt;code&gt;public&lt;/code&gt; schema. Some &lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;usage patterns&lt;/a&gt; call for revoking that privilege:</source>
          <target state="translated">还可以允许用户在其他人的架构中创建对象。为此，需要授予架构的 &lt;code&gt;CREATE&lt;/code&gt; 特权。请注意，默认情况下，每个人都对模式 &lt;code&gt;public&lt;/code&gt; 具有 &lt;code&gt;CREATE&lt;/code&gt; 和 &lt;code&gt;USAGE&lt;/code&gt; 特权。这允许所有能够连接到给定数据库的用户在其 &lt;code&gt;public&lt;/code&gt; 架构中创建对象。一些&lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;使用模式&lt;/a&gt;要求撤销该特权：</target>
        </trans-unit>
        <trans-unit id="b9aa765822babac771b767a7977f197f0cfd20dc" translate="yes" xml:space="preserve">
          <source>A user can only revoke privileges that were granted directly by that user. If, for example, user A has granted a privilege with grant option to user B, and user B has in turn granted it to user C, then user A cannot revoke the privilege directly from C. Instead, user A could revoke the grant option from user B and use the &lt;code&gt;CASCADE&lt;/code&gt; option so that the privilege is in turn revoked from user C. For another example, if both A and B have granted the same privilege to C, A can revoke their own grant but not B's grant, so C will still effectively have the privilege.</source>
          <target state="translated">用户只能撤消该用户直接授予的特权。例如，如果用户A已向用户B授予了具有授予选项的特权，而用户B又将其授予了用户C，则用户A无法直接从C撤消该特权。相反，用户A可以撤消授予选项。从用户B使用 &lt;code&gt;CASCADE&lt;/code&gt; 选项，这样的特权被依次从用户C.吊销另一个例子，如果A和B都已经授予相同的权限，C，A可以撤销自己的津贴，但没有B的补助，所以C仍将有效地享有特权。</target>
        </trans-unit>
        <trans-unit id="9eef0500388438dcdd883438e62adfff2b4c59d7" translate="yes" xml:space="preserve">
          <source>A user mapping, defined with &lt;a href=&quot;sql-createusermapping&quot;&gt;CREATE USER MAPPING&lt;/a&gt;, is needed as well to identify the role that will be used on the remote server:</source>
          <target state="translated">还需要使用&lt;a href=&quot;sql-createusermapping&quot;&gt;CREATE USER MAPPING&lt;/a&gt;定义的用户映射，以标识将在远程服务器上使用的角色：</target>
        </trans-unit>
        <trans-unit id="cd811596f6c21fd6820e0962c95748afb5dd8832" translate="yes" xml:space="preserve">
          <source>A user may perform &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, etc. on a column if they hold that privilege for either the specific column or its whole table. Granting the privilege at the table level and then revoking it for one column will not do what one might wish: the table-level grant is unaffected by a column-level operation.</source>
          <target state="translated">如果用户对特定列或其整个表拥有该特权，则可以对列执行 &lt;code&gt;SELECT&lt;/code&gt; ， &lt;code&gt;INSERT&lt;/code&gt; 等。在表级别上授予特权，然后将其撤销一列将不会满足您的期望：表级别的授予不受列级别的操作的影响。</target>
        </trans-unit>
        <trans-unit id="8d16a3b790258dd6e7bcb147ac82c63396f9dabe" translate="yes" xml:space="preserve">
          <source>A user with appropriate privileges can pass &lt;code&gt;tablespace_name&lt;/code&gt; to &lt;code&gt;CREATE DATABASE&lt;/code&gt;, &lt;code&gt;CREATE TABLE&lt;/code&gt;, &lt;code&gt;CREATE INDEX&lt;/code&gt; or &lt;code&gt;ADD CONSTRAINT&lt;/code&gt; to have the data files for these objects stored within the specified tablespace.</source>
          <target state="translated">具有适当特权的用户可以将 &lt;code&gt;tablespace_name&lt;/code&gt; 传递给 &lt;code&gt;CREATE DATABASE&lt;/code&gt; ， &lt;code&gt;CREATE TABLE&lt;/code&gt; ， &lt;code&gt;CREATE INDEX&lt;/code&gt; 或 &lt;code&gt;ADD CONSTRAINT&lt;/code&gt; ,以将这些对象的数据文件存储在指定的表空间中。</target>
        </trans-unit>
        <trans-unit id="cb5146129674511426d710b87f38fac56dd128fd" translate="yes" xml:space="preserve">
          <source>A user-supplied function that is declared as taking no argument and returning type &lt;code&gt;event_trigger&lt;/code&gt;.</source>
          <target state="translated">用户提供的函数，该函数声明为不带任何参数并返回 &lt;code&gt;event_trigger&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="944b09ef2e50c44bc480f5f428bf817a45e1996f" translate="yes" xml:space="preserve">
          <source>A user-supplied function that is declared as taking no arguments and returning type &lt;code&gt;trigger&lt;/code&gt;, which is executed when the trigger fires.</source>
          <target state="translated">用户提供的函数，该函数声明为不带任何参数，并返回类型 &lt;code&gt;trigger&lt;/code&gt; ，该函数在触发器触发时执行。</target>
        </trans-unit>
        <trans-unit id="3c03a8192bb8c460f615ba363c0076eb7beddfc8" translate="yes" xml:space="preserve">
          <source>A validator function would typically inspect the function body for syntactical correctness, but it can also look at other properties of the function, for example if the language cannot handle certain argument types. To signal an error, the validator function should use the &lt;code&gt;ereport()&lt;/code&gt; function. The return value of the function is ignored.</source>
          <target state="translated">验证器函数通常会检查函数主体的语法正确性，但它也可以查看函数的其他属性，例如，如果语言无法处理某些自变量类型。要发出错误信号，验证器函数应使用 &lt;code&gt;ereport()&lt;/code&gt; 函数。该函数的返回值将被忽略。</target>
        </trans-unit>
        <trans-unit id="7bb559a62e1812965348b9dc25a132908d898b4a" translate="yes" xml:space="preserve">
          <source>A value (but not a key) can be an SQL &lt;code&gt;NULL&lt;/code&gt;. For example:</source>
          <target state="translated">值（但不是键）可以是SQL &lt;code&gt;NULL&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="f11b15a75cd7fa69b386c1868dbf1a5bd1c71215" translate="yes" xml:space="preserve">
          <source>A value expression is one of the following:</source>
          <target state="translated">价值表达式是以下几种情况之一。</target>
        </trans-unit>
        <trans-unit id="15f463c504877012fea738b4b0d0b079a3d4f123" translate="yes" xml:space="preserve">
          <source>A value inserted into the referencing column(s) is matched against the values of the referenced table and referenced columns using the given match type. There are three match types: &lt;code&gt;MATCH FULL&lt;/code&gt;, &lt;code&gt;MATCH PARTIAL&lt;/code&gt;, and &lt;code&gt;MATCH SIMPLE&lt;/code&gt; (which is the default). &lt;code&gt;MATCH FULL&lt;/code&gt; will not allow one column of a multicolumn foreign key to be null unless all foreign key columns are null; if they are all null, the row is not required to have a match in the referenced table. &lt;code&gt;MATCH SIMPLE&lt;/code&gt; allows any of the foreign key columns to be null; if any of them are null, the row is not required to have a match in the referenced table. &lt;code&gt;MATCH PARTIAL&lt;/code&gt; is not yet implemented. (Of course, &lt;code&gt;NOT NULL&lt;/code&gt; constraints can be applied to the referencing column(s) to prevent these cases from arising.)</source>
          <target state="translated">使用给定的匹配类型，将插入到引用列中的值与引用表和引用列的值进行匹配。共有三种匹配类型： &lt;code&gt;MATCH FULL&lt;/code&gt; ， &lt;code&gt;MATCH PARTIAL&lt;/code&gt; 和 &lt;code&gt;MATCH SIMPLE&lt;/code&gt; （默认设置）。除非所有外键列为空，否则 &lt;code&gt;MATCH FULL&lt;/code&gt; 将不允许多列外键的一列为空；如果它们全为空，则不需要该行在引用表中具有匹配项。 &lt;code&gt;MATCH SIMPLE&lt;/code&gt; 允许任何外键列为空；如果它们中的任何一个为null，则不需要该行在引用表中具有匹配项。 &lt;code&gt;MATCH PARTIAL&lt;/code&gt; 尚未实现。 （当然， &lt;code&gt;NOT NULL&lt;/code&gt; 约束可以应用于引用列，以防止出现这些情况。）</target>
        </trans-unit>
        <trans-unit id="d3f19f348507a8389d8d149cdf77d56e254062cd" translate="yes" xml:space="preserve">
          <source>A variable representing the JSON text to be queried (the &lt;em&gt;context item&lt;/em&gt;).</source>
          <target state="translated">代表要查询的JSON文本的变量（&lt;em&gt;上下文项&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="ad2426a5221bd13cdbc6ec097f91418bf9cf0787" translate="yes" xml:space="preserve">
          <source>A variable representing the JSON value being queried (the &lt;em&gt;context item&lt;/em&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b7ff43247d2073dd8c93ef6f893b8751eb3e7bd" translate="yes" xml:space="preserve">
          <source>A variable representing the result of path evaluation in filter expressions.</source>
          <target state="translated">在过滤器表达式中代表路径评估结果的变量。</target>
        </trans-unit>
        <trans-unit id="156f0d479c5cbda4c018211d44db7834d2c5eaed" translate="yes" xml:space="preserve">
          <source>A variant of quoted identifiers allows including escaped Unicode characters identified by their code points. This variant starts with &lt;code&gt;U&amp;amp;&lt;/code&gt; (upper or lower case U followed by ampersand) immediately before the opening double quote, without any spaces in between, for example &lt;code&gt;U&amp;amp;&quot;foo&quot;&lt;/code&gt;. (Note that this creates an ambiguity with the operator &lt;code&gt;&amp;amp;&lt;/code&gt;. Use spaces around the operator to avoid this problem.) Inside the quotes, Unicode characters can be specified in escaped form by writing a backslash followed by the four-digit hexadecimal code point number or alternatively a backslash followed by a plus sign followed by a six-digit hexadecimal code point number. For example, the identifier &lt;code&gt;&quot;data&quot;&lt;/code&gt; could be written as</source>
          <target state="translated">带引号的标识符的变体允许包含由其代码点标识的转义Unicode字符。此变体以双引号之前的 &lt;code&gt;U&amp;amp;&lt;/code&gt; （大写或小写U，后跟与号）开头，中间没有空格，例如 &lt;code&gt;U&amp;amp;&quot;foo&quot;&lt;/code&gt; 。 （请注意，这与运算符 &lt;code&gt;&amp;amp;&lt;/code&gt; 造成歧义。请在运算符周围使用空格以避免出现此问题。）在引号内，可以通过写反斜杠后跟四位数的十六进制代码点号或转义符来指定Unicode字符。或者，反斜杠后跟加号，后跟六位十六进制代码点编号。例如，标识符 &lt;code&gt;&quot;data&quot;&lt;/code&gt; 可以写为</target>
        </trans-unit>
        <trans-unit id="acdae0bdc3109dd35a6d548731ba6bb6d6a12b1e" translate="yes" xml:space="preserve">
          <source>A variant of the above query is</source>
          <target state="translated">上述查询的一个变体是</target>
        </trans-unit>
        <trans-unit id="86b56417739883cc59cc6c063327a17fce9dbe75" translate="yes" xml:space="preserve">
          <source>A view column name list must be specified for a recursive view.</source>
          <target state="translated">必须为递归视图指定一个视图列名列表。</target>
        </trans-unit>
        <trans-unit id="85b3bfd48768285b52ad306ba0d6292137e9c9f1" translate="yes" xml:space="preserve">
          <source>A view that is simple enough to be automatically updatable (see &lt;a href=&quot;sql-createview&quot;&gt;CREATE VIEW&lt;/a&gt;) does not require a user-created rule in order to be updatable. While you can create an explicit rule anyway, the automatic update transformation will generally outperform an explicit rule.</source>
          <target state="translated">足够简单的视图可以自动更新（请参见&lt;a href=&quot;sql-createview&quot;&gt;CREATE VIEW&lt;/a&gt;），不需要用户创建规则即可对其进行更新。尽管您仍然可以创建显式规则，但是自动更新转换通常会胜过显式规则。</target>
        </trans-unit>
        <trans-unit id="b5c5c1bad9d2f71be50a1fcf23b697eb7750bb21" translate="yes" xml:space="preserve">
          <source>A window function call</source>
          <target state="translated">窗口函数调用</target>
        </trans-unit>
        <trans-unit id="014e860f54b04147bfef99f64476d36d0f965833" translate="yes" xml:space="preserve">
          <source>A window function call always contains an &lt;code&gt;OVER&lt;/code&gt; clause directly following the window function's name and argument(s). This is what syntactically distinguishes it from a normal function or non-window aggregate. The &lt;code&gt;OVER&lt;/code&gt; clause determines exactly how the rows of the query are split up for processing by the window function. The &lt;code&gt;PARTITION BY&lt;/code&gt; clause within &lt;code&gt;OVER&lt;/code&gt; divides the rows into groups, or partitions, that share the same values of the &lt;code&gt;PARTITION BY&lt;/code&gt; expression(s). For each row, the window function is computed across the rows that fall into the same partition as the current row.</source>
          <target state="translated">窗口函数调用始终在窗口函数的名称和参数之后直接包含一个 &lt;code&gt;OVER&lt;/code&gt; 子句。这是从语法上将其与常规函数或非窗口聚合区分开来的。的 &lt;code&gt;OVER&lt;/code&gt; 子句确定究竟如何查询的行分裂为通过所述窗口函数处理。 &lt;code&gt;OVER&lt;/code&gt; 中的 &lt;code&gt;PARTITION BY&lt;/code&gt; 子句将行分成共享相同 &lt;code&gt;PARTITION BY&lt;/code&gt; 表达式值的组或分区。对于每一行，在属于与当前行相同的分区的行之间计算窗口函数。</target>
        </trans-unit>
        <trans-unit id="69ff975e62e5e9881d6e40cfa6394518b64c0b59" translate="yes" xml:space="preserve">
          <source>A word is defined as in the specification of &lt;code&gt;[[:&amp;lt;:]]&lt;/code&gt; and &lt;code&gt;[[:&amp;gt;:]]&lt;/code&gt; above. Constraint escapes are illegal within bracket expressions.</source>
          <target state="translated">如上面 &lt;code&gt;[[:&amp;lt;:]]&lt;/code&gt; 和 &lt;code&gt;[[:&amp;gt;:]]&lt;/code&gt; 的规范中定义的单词。在方括号表达式中，约束转义是非法的。</target>
        </trans-unit>
        <trans-unit id="e7b5c134c4da8e8da4908f5aacc24a6aa1409eb3" translate="yes" xml:space="preserve">
          <source>A working example of a waiting &lt;code&gt;restore_command&lt;/code&gt; is provided in the &lt;a href=&quot;https://www.postgresql.org/docs/12/pgstandby.html&quot;&gt;pg_standby&lt;/a&gt; module. It should be used as a reference on how to correctly implement the logic described above. It can also be extended as needed to support specific configurations and environments.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/pgstandby.html&quot;&gt;pg_standby&lt;/a&gt;模块中提供了一个等待中的 &lt;code&gt;restore_command&lt;/code&gt; 的工作示例。它应作为有关如何正确实现上述逻辑的参考。还可以根据需要扩展它以支持特定的配置和环境。</target>
        </trans-unit>
        <trans-unit id="94040fbf2d2ff3dac676f0671c8578ae0488b46e" translate="yes" xml:space="preserve">
          <source>A working example of a waiting &lt;code&gt;restore_command&lt;/code&gt; is provided in the &lt;a href=&quot;https://www.postgresql.org/docs/13/pgstandby.html&quot;&gt;pg_standby&lt;/a&gt; module. It should be used as a reference on how to correctly implement the logic described above. It can also be extended as needed to support specific configurations and environments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d87e11b3c84c752269b580bca5caeedfc37d702" translate="yes" xml:space="preserve">
          <source>A write transaction has more than 64 subtransactions</source>
          <target state="translated">一个写事务有64个以上的子事务。</target>
        </trans-unit>
        <trans-unit id="cbd57cfd9437b3c9c1c3ce7cb0fb7a7b8366940a" translate="yes" xml:space="preserve">
          <source>ABORT</source>
          <target state="translated">ABORT</target>
        </trans-unit>
        <trans-unit id="7a0ffd6011b0a819cbe07ec59ab6319e323b19e8" translate="yes" xml:space="preserve">
          <source>ABORT &amp;mdash; abort the current transaction</source>
          <target state="translated">中止&amp;mdash;中止当前交易</target>
        </trans-unit>
        <trans-unit id="e3a56e2d83c5cd3911209ecd97318531d89949dd" translate="yes" xml:space="preserve">
          <source>ACCESS EXCLUSIVE</source>
          <target state="translated">ACCESS EXCLUSIVE</target>
        </trans-unit>
        <trans-unit id="236082e0393025e2b67ccb853e349993a3e685de" translate="yes" xml:space="preserve">
          <source>ACCESS SHARE</source>
          <target state="translated">ACCESS SHARE</target>
        </trans-unit>
        <trans-unit id="d4c15b3f603d1252b36800551086669559ae86a4" translate="yes" xml:space="preserve">
          <source>ACID</source>
          <target state="translated">ACID</target>
        </trans-unit>
        <trans-unit id="41f215a6d36c7782875bfb5d6d290ebb1e7961df" translate="yes" xml:space="preserve">
          <source>AES</source>
          <target state="translated">AES</target>
        </trans-unit>
        <trans-unit id="7cd735bc88414abeac25ef102606e6871aeba944" translate="yes" xml:space="preserve">
          <source>AIX</source>
          <target state="translated">AIX</target>
        </trans-unit>
        <trans-unit id="d3f3cb97007280f4a9b1e690872959eda00344a5" translate="yes" xml:space="preserve">
          <source>ALTER AGGREGATE</source>
          <target state="translated">ALTER AGGREGATE</target>
        </trans-unit>
        <trans-unit id="ed3d1c36faecc14690efbf5d3029f3dd4930091a" translate="yes" xml:space="preserve">
          <source>ALTER AGGREGATE &amp;mdash; change the definition of an aggregate function</source>
          <target state="translated">ALTER AGGREGATE &amp;mdash;更改聚合函数的定义</target>
        </trans-unit>
        <trans-unit id="a11472b885174cf0a5b8f565bbd9df33d5c63d9f" translate="yes" xml:space="preserve">
          <source>ALTER COLLATION</source>
          <target state="translated">ALTER COLLATION</target>
        </trans-unit>
        <trans-unit id="56c3d4607ffe2e71e2c5f2646969f8ca0df737b4" translate="yes" xml:space="preserve">
          <source>ALTER COLLATION &amp;mdash; change the definition of a collation</source>
          <target state="translated">ALTER COLLATION &amp;mdash;更改排序规则的定义</target>
        </trans-unit>
        <trans-unit id="41b42a1cc1e0f91fde1b7c9e18dfe7b36339b901" translate="yes" xml:space="preserve">
          <source>ALTER CONVERSION</source>
          <target state="translated">ALTER CONVERSION</target>
        </trans-unit>
        <trans-unit id="ccebf78a2dc7b51b4b857717880c57e697294e8c" translate="yes" xml:space="preserve">
          <source>ALTER CONVERSION &amp;mdash; change the definition of a conversion</source>
          <target state="translated">ALTER CONVERSION-更改转化的定义</target>
        </trans-unit>
        <trans-unit id="00ca4087b8df03743dae97498c53fb19953638fa" translate="yes" xml:space="preserve">
          <source>ALTER DATABASE</source>
          <target state="translated">ALTER DATABASE</target>
        </trans-unit>
        <trans-unit id="bea7726d13edb6ca210b4e6c9e61ad1bc910bed8" translate="yes" xml:space="preserve">
          <source>ALTER DATABASE &amp;mdash; change a database</source>
          <target state="translated">ALTER DATABASE &amp;mdash;更改数据库</target>
        </trans-unit>
        <trans-unit id="2d6bcd612a3e7b99bb9476838637e9b5438e3634" translate="yes" xml:space="preserve">
          <source>ALTER DEFAULT PRIVILEGES</source>
          <target state="translated">ALTER DEFAULT PRIVILEGES</target>
        </trans-unit>
        <trans-unit id="d8ff7f2d5af359b01a54f95e0ec2fd521bd7747c" translate="yes" xml:space="preserve">
          <source>ALTER DEFAULT PRIVILEGES &amp;mdash; define default access privileges</source>
          <target state="translated">更改默认权限-定义默认访问权限</target>
        </trans-unit>
        <trans-unit id="3f3cf48aa306a7a17143c18f42b0b45f1ba91588" translate="yes" xml:space="preserve">
          <source>ALTER DOMAIN</source>
          <target state="translated">ALTER DOMAIN</target>
        </trans-unit>
        <trans-unit id="535f7dde2f03c36ca7629e33ff7b1217df1764aa" translate="yes" xml:space="preserve">
          <source>ALTER DOMAIN &amp;mdash; change the definition of a domain</source>
          <target state="translated">ALTER DOMAIN-更改域的定义</target>
        </trans-unit>
        <trans-unit id="20933ed39426b19f4475367266e6e6f9a626ffa6" translate="yes" xml:space="preserve">
          <source>ALTER EVENT TRIGGER</source>
          <target state="translated">ALTER EVENT TRIGGER</target>
        </trans-unit>
        <trans-unit id="10dfbf336834913b8615fd608fa879b835569269" translate="yes" xml:space="preserve">
          <source>ALTER EVENT TRIGGER &amp;mdash; change the definition of an event trigger</source>
          <target state="translated">ALTER EVENT TRIGGER &amp;mdash;更改事件触发器的定义</target>
        </trans-unit>
        <trans-unit id="0800582e9a19732ccd7ede52083d298eb7e533f7" translate="yes" xml:space="preserve">
          <source>ALTER EXTENSION</source>
          <target state="translated">ALTER EXTENSION</target>
        </trans-unit>
        <trans-unit id="fceab1548e1fa0086ad916c8c58c48d5f822b214" translate="yes" xml:space="preserve">
          <source>ALTER EXTENSION &amp;mdash; change the definition of an extension</source>
          <target state="translated">ALTER EXTENSION &amp;mdash;更改扩展名的定义</target>
        </trans-unit>
        <trans-unit id="1845d1a7f6884f411e6b6fe79fb5470d0541e6de" translate="yes" xml:space="preserve">
          <source>ALTER FOREIGN DATA WRAPPER</source>
          <target state="translated">ALTER FOREIGN DATA WRAPPER</target>
        </trans-unit>
        <trans-unit id="81f39fe099a4b1e8700a250047ab0bd19b916bbd" translate="yes" xml:space="preserve">
          <source>ALTER FOREIGN DATA WRAPPER &amp;mdash; change the definition of a foreign-data wrapper</source>
          <target state="translated">ALTER FOREIGN DATA WRAPPER &amp;mdash;更改外来数据包装器的定义</target>
        </trans-unit>
        <trans-unit id="a09c3d2b46b06da9b27051fbdd7021dbe016aef6" translate="yes" xml:space="preserve">
          <source>ALTER FOREIGN TABLE</source>
          <target state="translated">ALTER FOREIGN TABLE</target>
        </trans-unit>
        <trans-unit id="8624b9015bf6424468dfa21128e81480cb2172bb" translate="yes" xml:space="preserve">
          <source>ALTER FOREIGN TABLE &amp;mdash; change the definition of a foreign table</source>
          <target state="translated">ALTER FOREIGN TABLE &amp;mdash;更改外部表的定义</target>
        </trans-unit>
        <trans-unit id="6f1e4d41d93587f0bfc00e49946d0343d91452a6" translate="yes" xml:space="preserve">
          <source>ALTER FUNCTION</source>
          <target state="translated">ALTER FUNCTION</target>
        </trans-unit>
        <trans-unit id="0d8b2dd3aa8516a6e8465a116eb3a3088efc3943" translate="yes" xml:space="preserve">
          <source>ALTER FUNCTION &amp;mdash; change the definition of a function</source>
          <target state="translated">ALTER FUNCTION &amp;mdash;更改函数的定义</target>
        </trans-unit>
        <trans-unit id="1d015a780bf1ecbd73d8b159554c5fb6595a8014" translate="yes" xml:space="preserve">
          <source>ALTER GROUP</source>
          <target state="translated">ALTER GROUP</target>
        </trans-unit>
        <trans-unit id="8b6db204989799abd80f3151dc7f1e0c1b92ec62" translate="yes" xml:space="preserve">
          <source>ALTER GROUP &amp;mdash; change role name or membership</source>
          <target state="translated">ALTER GROUP-更改角色名称或成员</target>
        </trans-unit>
        <trans-unit id="48c2e5d4cd7c661c29fd2888d9f2286c8fc0c6bf" translate="yes" xml:space="preserve">
          <source>ALTER INDEX</source>
          <target state="translated">ALTER INDEX</target>
        </trans-unit>
        <trans-unit id="7af8592c9de99cba72394d1922b6e193f563c137" translate="yes" xml:space="preserve">
          <source>ALTER INDEX &amp;mdash; change the definition of an index</source>
          <target state="translated">ALTER INDEX &amp;mdash;更改索引的定义</target>
        </trans-unit>
        <trans-unit id="1593f1abf4a97117a0be55f5da7d21f597c8c250" translate="yes" xml:space="preserve">
          <source>ALTER LANGUAGE</source>
          <target state="translated">ALTER LANGUAGE</target>
        </trans-unit>
        <trans-unit id="2d47f4538397cbf8b0a1e802f6dfa7cb56556115" translate="yes" xml:space="preserve">
          <source>ALTER LANGUAGE &amp;mdash; change the definition of a procedural language</source>
          <target state="translated">ALTER LANGUAGE &amp;mdash;更改过程语言的定义</target>
        </trans-unit>
        <trans-unit id="b8e23037908ab469bed89826c20ecdd2b7ec5245" translate="yes" xml:space="preserve">
          <source>ALTER LARGE OBJECT</source>
          <target state="translated">ALTER LARGE OBJECT</target>
        </trans-unit>
        <trans-unit id="d01f8e01043a2f37f9bf2b4fbe638ce531bf573c" translate="yes" xml:space="preserve">
          <source>ALTER LARGE OBJECT &amp;mdash; change the definition of a large object</source>
          <target state="translated">ALTER LARGE OBJECT &amp;mdash;更改大对象的定义</target>
        </trans-unit>
        <trans-unit id="acf3facbc79c94e9820cd014a83e0c3bffc8d33e" translate="yes" xml:space="preserve">
          <source>ALTER MATERIALIZED VIEW</source>
          <target state="translated">更改材料化视图</target>
        </trans-unit>
        <trans-unit id="ff19a08e1cc705b85f737d7d03bbe11848829b1c" translate="yes" xml:space="preserve">
          <source>ALTER MATERIALIZED VIEW &amp;mdash; change the definition of a materialized view</source>
          <target state="translated">ALTER MATERIALIZED VIEW &amp;mdash;更改物化视图的定义</target>
        </trans-unit>
        <trans-unit id="dce6c5285005edbbb84e2318b05691c4b30c9b74" translate="yes" xml:space="preserve">
          <source>ALTER OPERATOR</source>
          <target state="translated">ALTER OPERATOR</target>
        </trans-unit>
        <trans-unit id="7dafb4a30aeb9191e7113acec86c091ff802f404" translate="yes" xml:space="preserve">
          <source>ALTER OPERATOR &amp;mdash; change the definition of an operator</source>
          <target state="translated">ALTER OPERATOR &amp;mdash;更改运算符的定义</target>
        </trans-unit>
        <trans-unit id="a0e738cb1034a6c7d40880b830a0d0aabd9fe44b" translate="yes" xml:space="preserve">
          <source>ALTER OPERATOR CLASS</source>
          <target state="translated">ALTER OPERATOR CLASS</target>
        </trans-unit>
        <trans-unit id="cb0f6723f3b16452ec4b0d07ef7fe014b4a43893" translate="yes" xml:space="preserve">
          <source>ALTER OPERATOR CLASS &amp;mdash; change the definition of an operator class</source>
          <target state="translated">ALTER OPERATOR CLASS &amp;mdash;更改操作员类别的定义</target>
        </trans-unit>
        <trans-unit id="0ba7fb1c4beddce29550f5cb8b66990a01471bb0" translate="yes" xml:space="preserve">
          <source>ALTER OPERATOR FAMILY</source>
          <target state="translated">ALTER OPERATOR FAMILY</target>
        </trans-unit>
        <trans-unit id="b145c0d850ce88d5e3be9bd1acd90a4f15ebe361" translate="yes" xml:space="preserve">
          <source>ALTER OPERATOR FAMILY &amp;mdash; change the definition of an operator family</source>
          <target state="translated">ALTER OPERATOR FAMILY &amp;mdash;更改操作员系列的定义</target>
        </trans-unit>
        <trans-unit id="88b3b91499f373dcdd877e9ff64364e5e7e60e0e" translate="yes" xml:space="preserve">
          <source>ALTER POLICY</source>
          <target state="translated">ALTER POLICY</target>
        </trans-unit>
        <trans-unit id="833f3039623c0b1cb3fef4e1e4f83cc843bd962e" translate="yes" xml:space="preserve">
          <source>ALTER POLICY &amp;mdash; change the definition of a row level security policy</source>
          <target state="translated">ALTER POLICY &amp;mdash;更改行级安全策略的定义</target>
        </trans-unit>
        <trans-unit id="6a0674112110b72195624944bfa13c57d5d82cb7" translate="yes" xml:space="preserve">
          <source>ALTER PROCEDURE</source>
          <target state="translated">ALTER PROCEDURE</target>
        </trans-unit>
        <trans-unit id="43575de59088420331627e718ac08acff025d18b" translate="yes" xml:space="preserve">
          <source>ALTER PROCEDURE &amp;mdash; change the definition of a procedure</source>
          <target state="translated">ALTER PROCEDURE &amp;mdash;更改过程的定义</target>
        </trans-unit>
        <trans-unit id="54107fe026e19d4f5a11e4537d44c6b6d22b8b09" translate="yes" xml:space="preserve">
          <source>ALTER PUBLICATION</source>
          <target state="translated">ALTER PUBLICATION</target>
        </trans-unit>
        <trans-unit id="9597d926bb8a9acc34d0e5930cb8d7cd0d4f568f" translate="yes" xml:space="preserve">
          <source>ALTER PUBLICATION &amp;mdash; change the definition of a publication</source>
          <target state="translated">ALTER PUBLICATION &amp;mdash;更改出版物的定义</target>
        </trans-unit>
        <trans-unit id="8d50cc704f5e61444d52d138269e970c84c316a9" translate="yes" xml:space="preserve">
          <source>ALTER ROLE</source>
          <target state="translated">ALTER ROLE</target>
        </trans-unit>
        <trans-unit id="12cc26ef42f3af7ca4348ac6467248637f685960" translate="yes" xml:space="preserve">
          <source>ALTER ROLE &amp;mdash; change a database role</source>
          <target state="translated">ALTER ROLE-更改数据库角色</target>
        </trans-unit>
        <trans-unit id="4dcea8729953c25416c614a8e9dd74665955b163" translate="yes" xml:space="preserve">
          <source>ALTER ROUTINE</source>
          <target state="translated">ALTER ROUTINE</target>
        </trans-unit>
        <trans-unit id="41b74c3c2f66a654560a7c52136c27e28aece24f" translate="yes" xml:space="preserve">
          <source>ALTER ROUTINE &amp;mdash; change the definition of a routine</source>
          <target state="translated">ALTER ROUTINE &amp;mdash;更改例程的定义</target>
        </trans-unit>
        <trans-unit id="a0e0dff76fa934f2bd1deef6694b1932d808504f" translate="yes" xml:space="preserve">
          <source>ALTER RULE</source>
          <target state="translated">ALTER RULE</target>
        </trans-unit>
        <trans-unit id="2fc7414dfcf68c3ac031a4421e6842e26618ab9c" translate="yes" xml:space="preserve">
          <source>ALTER RULE &amp;mdash; change the definition of a rule</source>
          <target state="translated">ALTER RULE &amp;mdash;更改规则的定义</target>
        </trans-unit>
        <trans-unit id="d6fc95f83521d1f149e5c2d72ccf2e6275ceff58" translate="yes" xml:space="preserve">
          <source>ALTER SCHEMA</source>
          <target state="translated">ALTER SCHEMA</target>
        </trans-unit>
        <trans-unit id="a9c6d7baa1a1fa5c1ea1e4302e14b9b0b1cbc91f" translate="yes" xml:space="preserve">
          <source>ALTER SCHEMA &amp;mdash; change the definition of a schema</source>
          <target state="translated">ALTER SCHEMA &amp;mdash;更改架构的定义</target>
        </trans-unit>
        <trans-unit id="e0ff1dd3b5bc12676f75f802c39fe58d3f568b91" translate="yes" xml:space="preserve">
          <source>ALTER SEQUENCE</source>
          <target state="translated">ALTER SEQUENCE</target>
        </trans-unit>
        <trans-unit id="75ca9fc88afe8b3a138533f529504e99e65095c7" translate="yes" xml:space="preserve">
          <source>ALTER SEQUENCE &amp;mdash; change the definition of a sequence generator</source>
          <target state="translated">ALTER SEQUENCE &amp;mdash;更改序列生成器的定义</target>
        </trans-unit>
        <trans-unit id="4e991c23674edbbd034fbea9f95fd5732fde6594" translate="yes" xml:space="preserve">
          <source>ALTER SERVER</source>
          <target state="translated">ALTER SERVER</target>
        </trans-unit>
        <trans-unit id="9097ec6c4fcb5127ed5acb37df744bf114c59cf4" translate="yes" xml:space="preserve">
          <source>ALTER SERVER &amp;mdash; change the definition of a foreign server</source>
          <target state="translated">ALTER SERVER &amp;mdash;更改外部服务器的定义</target>
        </trans-unit>
        <trans-unit id="339516769622a8fe113a08ac4316402cbf0b0186" translate="yes" xml:space="preserve">
          <source>ALTER STATISTICS</source>
          <target state="translated">ALTER STATISTICS</target>
        </trans-unit>
        <trans-unit id="08e64dea134c405908e303c3bf604acf6999c23f" translate="yes" xml:space="preserve">
          <source>ALTER STATISTICS &amp;mdash; change the definition of an extended statistics object</source>
          <target state="translated">ALTER STATISTICS &amp;mdash;更改扩展统计对象的定义</target>
        </trans-unit>
        <trans-unit id="10579de4cfd80edf9752f883f553b098d07c2351" translate="yes" xml:space="preserve">
          <source>ALTER SUBSCRIPTION</source>
          <target state="translated">ALTER SUBSCRIPTION</target>
        </trans-unit>
        <trans-unit id="3088c38bfc4248dd70925edc22aa9e03938a70b2" translate="yes" xml:space="preserve">
          <source>ALTER SUBSCRIPTION &amp;mdash; change the definition of a subscription</source>
          <target state="translated">ALTER SUBSCRIPTION-更改订阅的定义</target>
        </trans-unit>
        <trans-unit id="b751196563736994d3b141da4e3359399f7784c1" translate="yes" xml:space="preserve">
          <source>ALTER SYSTEM</source>
          <target state="translated">ALTER SYSTEM</target>
        </trans-unit>
        <trans-unit id="43121748c757e8121439597a27c3d6de3f1df5e0" translate="yes" xml:space="preserve">
          <source>ALTER SYSTEM &amp;mdash; change a server configuration parameter</source>
          <target state="translated">ALTER SYSTEM &amp;mdash;更改服务器配置参数</target>
        </trans-unit>
        <trans-unit id="fcdc3e679260efe34d4720e54eb086a76a15f687" translate="yes" xml:space="preserve">
          <source>ALTER TABLE</source>
          <target state="translated">ALTER TABLE</target>
        </trans-unit>
        <trans-unit id="afe4c7733f05b900cf17777f836ea5b6c85eae68" translate="yes" xml:space="preserve">
          <source>ALTER TABLE &amp;mdash; change the definition of a table</source>
          <target state="translated">ALTER TABLE &amp;mdash;更改表的定义</target>
        </trans-unit>
        <trans-unit id="c9732ec2c1c41131709b9ec601102740f5d08528" translate="yes" xml:space="preserve">
          <source>ALTER TABLESPACE</source>
          <target state="translated">ALTER TABLESPACE</target>
        </trans-unit>
        <trans-unit id="e3e82c20f13259759fc74c305fcf89694aa71e4c" translate="yes" xml:space="preserve">
          <source>ALTER TABLESPACE &amp;mdash; change the definition of a tablespace</source>
          <target state="translated">ALTER TABLESPACE &amp;mdash;更改表空间的定义</target>
        </trans-unit>
        <trans-unit id="ab1241fdf0558dac3416642b6e5e2afa08edd357" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH CONFIGURATION</source>
          <target state="translated">ALTER TEXT SEARCH CONFIGURATION(更改文本搜索配置)。</target>
        </trans-unit>
        <trans-unit id="2a241bc8e97bcb10c517130c630f0f5969d5e473" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH CONFIGURATION &amp;mdash; change the definition of a text search configuration</source>
          <target state="translated">ALTER TEXT SEARCH CONFIGURATION &amp;mdash;更改文本搜索配置的定义</target>
        </trans-unit>
        <trans-unit id="a62239565ecd2214c8d0dc9fde76b1033be6c2fc" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH DICTIONARY</source>
          <target state="translated">ALTER TEXT SEARCH DICTIONARY</target>
        </trans-unit>
        <trans-unit id="13998d90641b194774e8f12cf56ab5eaead8a314" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH DICTIONARY &amp;mdash; change the definition of a text search dictionary</source>
          <target state="translated">ALTER TEXT SEARCH DICTIONARY &amp;mdash;更改文本搜索词典的定义</target>
        </trans-unit>
        <trans-unit id="8179411a0a3b868da4b4880988c7d06f086d844e" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH PARSER</source>
          <target state="translated">ALTER TEXT SEARCH PARSER</target>
        </trans-unit>
        <trans-unit id="b487f243ff77599a0ebe244a83985f8acf1c14ea" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH PARSER &amp;mdash; change the definition of a text search parser</source>
          <target state="translated">ALTER TEXT SEARCH PARSER &amp;mdash;更改文本搜索解析器的定义</target>
        </trans-unit>
        <trans-unit id="03386acc96b981e6c35c90b75e2cec735105ea3c" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH TEMPLATE</source>
          <target state="translated">ALTER TEXT SEARCH TEMPLATE</target>
        </trans-unit>
        <trans-unit id="285dbc8186deb64394ffb30b6e1363ad0dbe6498" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH TEMPLATE &amp;mdash; change the definition of a text search template</source>
          <target state="translated">ALTER TEXT SEARCH TEMPLATE &amp;mdash;更改文本搜索模板的定义</target>
        </trans-unit>
        <trans-unit id="f6742edfb2c8b1a8d27beb1bba87153804373be5" translate="yes" xml:space="preserve">
          <source>ALTER TRIGGER</source>
          <target state="translated">ALTER TRIGGER</target>
        </trans-unit>
        <trans-unit id="485c6a654f45ba69729bdbf15496fe29a444d1e3" translate="yes" xml:space="preserve">
          <source>ALTER TRIGGER &amp;mdash; change the definition of a trigger</source>
          <target state="translated">ALTER TRIGGER &amp;mdash;更改触发器的定义</target>
        </trans-unit>
        <trans-unit id="b8549a9a7b44242713f7d48704380ebba425b154" translate="yes" xml:space="preserve">
          <source>ALTER TYPE</source>
          <target state="translated">ALTER TYPE</target>
        </trans-unit>
        <trans-unit id="2921b9477c2e093e0ed29e1dc88121fdd946417d" translate="yes" xml:space="preserve">
          <source>ALTER TYPE &amp;mdash; change the definition of a type</source>
          <target state="translated">ALTER TYPE-更改类型的定义</target>
        </trans-unit>
        <trans-unit id="0f0117db55477563e4484d9879a151cbea4a27fc" translate="yes" xml:space="preserve">
          <source>ALTER USER</source>
          <target state="translated">ALTER USER</target>
        </trans-unit>
        <trans-unit id="dc349b6f52ce0d7d5bb23382932a5eb2f67eac63" translate="yes" xml:space="preserve">
          <source>ALTER USER &amp;mdash; change a database role</source>
          <target state="translated">ALTER USER-更改数据库角色</target>
        </trans-unit>
        <trans-unit id="a375773515175c08cd7fc8e357c209c60d07f13e" translate="yes" xml:space="preserve">
          <source>ALTER USER MAPPING</source>
          <target state="translated">ALTER USER MAPPING</target>
        </trans-unit>
        <trans-unit id="84dbc6c571c120a8defca7e0a6c086e648f98854" translate="yes" xml:space="preserve">
          <source>ALTER USER MAPPING &amp;mdash; change the definition of a user mapping</source>
          <target state="translated">ALTER USER MAPPING &amp;mdash;更改用户映射的定义</target>
        </trans-unit>
        <trans-unit id="219d78bab64e4f5637643b61ce738d2b84487f00" translate="yes" xml:space="preserve">
          <source>ALTER VIEW</source>
          <target state="translated">ALTER VIEW</target>
        </trans-unit>
        <trans-unit id="d3ae485ff52fa79c183c7d3ce9f751addfed0468" translate="yes" xml:space="preserve">
          <source>ALTER VIEW &amp;mdash; change the definition of a view</source>
          <target state="translated">ALTER VIEW &amp;mdash;更改视图的定义</target>
        </trans-unit>
        <trans-unit id="caadd138e6e8d1596eda80c0f51c856600e89f65" translate="yes" xml:space="preserve">
          <source>ANALYZE</source>
          <target state="translated">ANALYZE</target>
        </trans-unit>
        <trans-unit id="21b8417695362cfdc412c95c44c48fa648556dd9" translate="yes" xml:space="preserve">
          <source>ANALYZE &amp;mdash; collect statistics about a database</source>
          <target state="translated">ANALYZE &amp;mdash;收集有关数据库的统计信息</target>
        </trans-unit>
        <trans-unit id="e2f2d6cea163ef0dacf4540366528f7c7edd61f2" translate="yes" xml:space="preserve">
          <source>AND &lt;code&gt;tsquery&lt;/code&gt;s together</source>
          <target state="translated">和 &lt;code&gt;tsquery&lt;/code&gt; 在一起</target>
        </trans-unit>
        <trans-unit id="8824eb37da0438275c17449687050c5930f6be40" translate="yes" xml:space="preserve">
          <source>ANDs two &lt;code&gt;tsquery&lt;/code&gt;s together, producing a query that matches documents that match both input queries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09b52ce6d8d3ca14c041a1ecfe44ca34c84c93c5" translate="yes" xml:space="preserve">
          <source>ANSI</source>
          <target state="translated">ANSI</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="94090230b1f8c256f7ac5dc5a70bd3b20ee4ff15" translate="yes" xml:space="preserve">
          <source>ASCII</source>
          <target state="translated">ASCII</target>
        </trans-unit>
        <trans-unit id="5fb9ba93128c23898a1b0a61ebd44810a0c6b606" translate="yes" xml:space="preserve">
          <source>ASCII code of the first character of the argument. For UTF8 returns the Unicode code point of the character. For other multibyte encodings, the argument must be an ASCII character.</source>
          <target state="translated">参数中第一个字符的ASCII码,对于UTF8,返回该字符的Unicode码点。对于UTF8,返回该字符的Unicode码点。对于其他多字节编码,参数必须是一个ASCII字符。</target>
        </trans-unit>
        <trans-unit id="7647bd700c1c10eb12b5de06bf40a88672e3451d" translate="yes" xml:space="preserve">
          <source>Aaron D. Gifford</source>
          <target state="translated">Aaron D.Gifford</target>
        </trans-unit>
        <trans-unit id="cd437865cbac7655f8b86519aea764f378093804" translate="yes" xml:space="preserve">
          <source>Abbreviation</source>
          <target state="translated">Abbreviation</target>
        </trans-unit>
        <trans-unit id="1bb9eda0dcf4611f958758d0ccd51e13bf341710" translate="yes" xml:space="preserve">
          <source>Abbreviation (for Pacific Standard Time)</source>
          <target state="translated">缩写(太平洋标准时间)</target>
        </trans-unit>
        <trans-unit id="a90aba13b6feb8ff1a5141d94cb1fc2fe96e9477" translate="yes" xml:space="preserve">
          <source>Abbreviations</source>
          <target state="translated">Abbreviations</target>
        </trans-unit>
        <trans-unit id="c5fd5b17ae3c41e41caede4fa07a5960ba1a5f2d" translate="yes" xml:space="preserve">
          <source>Abort any statement that takes more than the specified amount of time. If &lt;code&gt;log_min_error_statement&lt;/code&gt; is set to &lt;code&gt;ERROR&lt;/code&gt; or lower, the statement that timed out will also be logged. If this value is specified without units, it is taken as milliseconds. A value of zero (the default) disables the timeout.</source>
          <target state="translated">中止所有花费时间超过指定时间的语句。如果将 &lt;code&gt;log_min_error_statement&lt;/code&gt; 设置为 &lt;code&gt;ERROR&lt;/code&gt; 或更低，则还将记录超时的语句。如果指定的该值不带单位，则以毫秒为单位。零值（默认值）将禁用超时。</target>
        </trans-unit>
        <trans-unit id="6c33aee3e89187438edae43ea18855e5962050c2" translate="yes" xml:space="preserve">
          <source>Abort any statement that waits longer than the specified amount of time while attempting to acquire a lock on a table, index, row, or other database object. The time limit applies separately to each lock acquisition attempt. The limit applies both to explicit locking requests (such as &lt;code&gt;LOCK TABLE&lt;/code&gt;, or &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; without &lt;code&gt;NOWAIT&lt;/code&gt;) and to implicitly-acquired locks. If this value is specified without units, it is taken as milliseconds. A value of zero (the default) disables the timeout.</source>
          <target state="translated">在尝试获取表，索引，行或其他数据库对象的锁时，中止等待时间超过指定时间的任何语句。时间限制分别适用于每次锁定获取尝试。该限制适用于显式锁定请求（例如 &lt;code&gt;LOCK TABLE&lt;/code&gt; 或 &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 而没有 &lt;code&gt;NOWAIT&lt;/code&gt; ）和隐式获取的锁定。如果指定的该值不带单位，则以毫秒为单位。零值（默认值）将禁用超时。</target>
        </trans-unit>
        <trans-unit id="82c17c3ccfec7ab27999f74c3eae394cb4e66713" translate="yes" xml:space="preserve">
          <source>Above, since there is no &lt;code&gt;ORDER BY&lt;/code&gt; in the &lt;code&gt;OVER&lt;/code&gt; clause, the window frame is the same as the partition, which for lack of &lt;code&gt;PARTITION BY&lt;/code&gt; is the whole table; in other words each sum is taken over the whole table and so we get the same result for each output row. But if we add an &lt;code&gt;ORDER BY&lt;/code&gt; clause, we get very different results:</source>
          <target state="translated">如上所述，由于不存在 &lt;code&gt;ORDER BY&lt;/code&gt; 中 &lt;code&gt;OVER&lt;/code&gt; 子句，窗框是相同的分区，这对于缺乏 &lt;code&gt;PARTITION BY&lt;/code&gt; 是整个表; 换句话说，每个总和都包含在整个表中，因此对于每个输出行我们都得到相同的结果。但是，如果我们添加 &lt;code&gt;ORDER BY&lt;/code&gt; 子句，则会得到非常不同的结果：</target>
        </trans-unit>
        <trans-unit id="35e4a1a9ace5e53c1521b13130f3b1fce0bb312b" translate="yes" xml:space="preserve">
          <source>Absolute value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecc48669a5f045e0b1c73515a6a06d3751ca7ca3" translate="yes" xml:space="preserve">
          <source>Absolute value of the SQL/JSON number</source>
          <target state="translated">SQL/JSON数字的绝对值</target>
        </trans-unit>
        <trans-unit id="adaf687cef3a864875d03ee7f1764cbc49564164" translate="yes" xml:space="preserve">
          <source>Absolute value of the given number</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95ecf27dff51c67220f14d51d8af97b6912bfba7" translate="yes" xml:space="preserve">
          <source>Access Exclusive locks taken on the primary server, including both explicit &lt;code&gt;LOCK&lt;/code&gt; commands and various DDL actions, conflict with table accesses in standby queries.</source>
          <target state="translated">在主服务器上获取的访问独占锁（包括显式 &lt;code&gt;LOCK&lt;/code&gt; 命令和各种DDL操作）与备用查询中的表访问冲突。</target>
        </trans-unit>
        <trans-unit id="446d3f34dfbff4e7c337ef9e7b895902f1dba9ef" translate="yes" xml:space="preserve">
          <source>Access methods that always return entries in the natural ordering of their data (such as btree) should set &lt;code&gt;amcanorder&lt;/code&gt; to true. Currently, such access methods must use btree-compatible strategy numbers for their equality and ordering operators.</source>
          <target state="translated">始终以数据的自然顺序返回条目的访问方法（例如btree）应将 &lt;code&gt;amcanorder&lt;/code&gt; 设置为true。当前，此类访问方法必须将btree兼容策略编号用于其相等性和排序运算符。</target>
        </trans-unit>
        <trans-unit id="b0e23c5a90203bbd16a6b86de50258944a0ed57a" translate="yes" xml:space="preserve">
          <source>Access methods that support ordered scans must support &amp;ldquo;marking&amp;rdquo; a position in a scan and later returning to the marked position. The same position might be restored multiple times. However, only one position need be remembered per scan; a new &lt;code&gt;ammarkpos&lt;/code&gt; call overrides the previously marked position. An access method that does not support ordered scans need not provide &lt;code&gt;ammarkpos&lt;/code&gt; and &lt;code&gt;amrestrpos&lt;/code&gt; functions in &lt;code&gt;IndexAmRoutine&lt;/code&gt;; set those pointers to NULL instead.</source>
          <target state="translated">支持有序扫描的访问方法必须支持&amp;ldquo;标记&amp;rdquo;扫描中的位置，然后返回到标记的位置。同一位置可能会多次还原。但是，每次扫描只需要记住一个位置。一个新的 &lt;code&gt;ammarkpos&lt;/code&gt; 调用将覆盖先前标记的位置。不支持有序扫描的访问方法无需在 &lt;code&gt;IndexAmRoutine&lt;/code&gt; 中提供 &lt;code&gt;ammarkpos&lt;/code&gt; 和 &lt;code&gt;amrestrpos&lt;/code&gt; 函数；将这些指针设置为NULL。</target>
        </trans-unit>
        <trans-unit id="0fdc357a629c5f7047a03e768a0792d5cbb44b9a" translate="yes" xml:space="preserve">
          <source>Access methods that support ordering operators should implement &lt;code&gt;AMPROP_DISTANCE_ORDERABLE&lt;/code&gt; property testing, as the core code does not know how to do that and will return NULL. It may also be advantageous to implement &lt;code&gt;AMPROP_RETURNABLE&lt;/code&gt; testing, if that can be done more cheaply than by opening the index and calling &lt;code&gt;amcanreturn&lt;/code&gt;, which is the core code's default behavior. The default behavior should be satisfactory for all other standard properties.</source>
          <target state="translated">支持排序运算符的访问方法应实现 &lt;code&gt;AMPROP_DISTANCE_ORDERABLE&lt;/code&gt; 属性测试，因为核心代码不知道该如何执行，并且将返回NULL。如果实现 &lt;code&gt;AMPROP_RETURNABLE&lt;/code&gt; 测试比通过打开索引并调用 &lt;code&gt;amcanreturn&lt;/code&gt; 更为便宜，这是核心代码的默认行为，那么这样做可能会更有利。对于所有其他标准属性，默认行为应令人满意。</target>
        </trans-unit>
        <trans-unit id="ec93e5f340df1c63a8b7900c8c64d2c56b99c607" translate="yes" xml:space="preserve">
          <source>Access methods that support ordering operators should set &lt;code&gt;amcanorderbyop&lt;/code&gt; to true. This indicates that the index is capable of returning entries in an order satisfying &lt;code&gt;ORDER BY&lt;/code&gt;&lt;code&gt;index_key&lt;/code&gt;&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;constant&lt;/code&gt;. Scan modifiers of that form can be passed to &lt;code&gt;amrescan&lt;/code&gt; as described previously.</source>
          <target state="translated">支持排序运算符的访问方法应将 &lt;code&gt;amcanorderbyop&lt;/code&gt; 设置为true。这表明索引能够以满足 &lt;code&gt;ORDER BY&lt;/code&gt; &lt;code&gt;index_key&lt;/code&gt; &lt;code&gt;operator&lt;/code&gt; &lt;code&gt;constant&lt;/code&gt; 的顺序返回条目。 &lt;code&gt;amrescan&lt;/code&gt; ，可以将这种形式的扫描修饰符传递给amrescan。</target>
        </trans-unit>
        <trans-unit id="9d5da75b46e072ddd4591be60d218524fe1f309e" translate="yes" xml:space="preserve">
          <source>Access privileges for template (not actually used)</source>
          <target state="translated">模板的访问权限(未实际使用)</target>
        </trans-unit>
        <trans-unit id="85f3b04d8d02176eeb1578817040415abfa34698" translate="yes" xml:space="preserve">
          <source>Access privileges that this type of object should have on creation</source>
          <target state="translated">这种类型的对象在创建时应有的访问权限</target>
        </trans-unit>
        <trans-unit id="3d73c85183e638c3a5d257c026ae2497dddb1f32" translate="yes" xml:space="preserve">
          <source>Access privileges; see &lt;a href=&quot;ddl-priv&quot;&gt;Section 5.7&lt;/a&gt; for details</source>
          <target state="translated">访问权限；参见&lt;a href=&quot;ddl-priv&quot;&gt;5.7节&lt;/a&gt;的详细信息</target>
        </trans-unit>
        <trans-unit id="02bbd73371e69fa85fa69f734c586e2358313738" translate="yes" xml:space="preserve">
          <source>Access to tables referenced in the view is determined by permissions of the view owner. In some cases, this can be used to provide secure but restricted access to the underlying tables. However, not all views are secure against tampering; see &lt;a href=&quot;https://www.postgresql.org/docs/12/rules-privileges.html&quot;&gt;Section 40.5&lt;/a&gt; for details. Functions called in the view are treated the same as if they had been called directly from the query using the view. Therefore the user of a view must have permissions to call all functions used by the view.</source>
          <target state="translated">对视图中引用的表的访问由视图所有者的权限决定。在某些情况下，这可用于提供对基础表的安全但受限制的访问。但是，并非所有视图都可以防止篡改。有关详细信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/rules-privileges.html&quot;&gt;第40.5节&lt;/a&gt;。与在视图中直接从查询中调用它们一样，将在视图中调用的函数视为相同。因此，视图的用户必须有权调用该视图使用的所有功能。</target>
        </trans-unit>
        <trans-unit id="c4369eb157086a70b7378313eb6ff8fc4fe92c26" translate="yes" xml:space="preserve">
          <source>Access to tables referenced in the view is determined by permissions of the view owner. In some cases, this can be used to provide secure but restricted access to the underlying tables. However, not all views are secure against tampering; see &lt;a href=&quot;https://www.postgresql.org/docs/13/rules-privileges.html&quot;&gt;Section 40.5&lt;/a&gt; for details. Functions called in the view are treated the same as if they had been called directly from the query using the view. Therefore the user of a view must have permissions to call all functions used by the view.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea538985d43ba38411a22fc78790edc64739cd94" translate="yes" xml:space="preserve">
          <source>Access to the column &lt;code&gt;subconninfo&lt;/code&gt; is revoked from normal users, because it could contain plain-text passwords.</source>
          <target state="translated">普通用户撤消了对 &lt;code&gt;subconninfo&lt;/code&gt; 列的访问，因为该列可能包含纯文本密码。</target>
        </trans-unit>
        <trans-unit id="709b98ad6555808775120e3c01cba15666c7c18d" translate="yes" xml:space="preserve">
          <source>Access to the table &lt;code&gt;pg_statistic&lt;/code&gt; is restricted to superusers, so that ordinary users cannot learn about the contents of the tables of other users from it. Some selectivity estimation functions will use a user-provided operator (either the operator appearing in the query or a related operator) to analyze the stored statistics. For example, in order to determine whether a stored most common value is applicable, the selectivity estimator will have to run the appropriate &lt;code&gt;=&lt;/code&gt; operator to compare the constant in the query to the stored value. Thus the data in &lt;code&gt;pg_statistic&lt;/code&gt; is potentially passed to user-defined operators. An appropriately crafted operator can intentionally leak the passed operands (for example, by logging them or writing them to a different table), or accidentally leak them by showing their values in error messages, in either case possibly exposing data from &lt;code&gt;pg_statistic&lt;/code&gt; to a user who should not be able to see it.</source>
          <target state="translated">对表 &lt;code&gt;pg_statistic&lt;/code&gt; 的访问仅限于超级用户，因此普通用户无法从中了解其他用户的表内容。某些选择性估计功能将使用用户提供的运算符（出现在查询中的运算符或相关的运算符）来分析存储的统计信息。例如，为了确定所存储的最常用值是否适用，选择性估计器将必须运行适当的 &lt;code&gt;=&lt;/code&gt; 运算符以将查询中的常数与所存储的值进行比较。因此 &lt;code&gt;pg_statistic&lt;/code&gt; 中的数据可能会传递给用户定义的运算符。适当设计的运算符可以有意泄漏所传递的操作数（例如，通过记录它们或将它们写入不同的表中），或通过在错误消息中显示它们的值来意外泄漏它们，在两种情况下都可能会将 &lt;code&gt;pg_statistic&lt;/code&gt; 中的数据暴露给应该看不到它。</target>
        </trans-unit>
        <trans-unit id="a19557158b233d91213a81525eeee59ee4fa2d0a" translate="yes" xml:space="preserve">
          <source>Access-method-specific options, as &amp;ldquo;keyword=value&amp;rdquo; strings</source>
          <target state="translated">访问方法特定的选项，如&amp;ldquo; keyword = value&amp;rdquo;字符串</target>
        </trans-unit>
        <trans-unit id="bdebd3af85014736552b079e90a39e39b6b4b3f6" translate="yes" xml:space="preserve">
          <source>Accessing remote data may require authenticating to the external data source. This information can be provided by a &lt;em&gt;user mapping&lt;/em&gt;, which can provide additional data such as user names and passwords based on the current PostgreSQL role.</source>
          <target state="translated">访问远程数据可能需要对外部数据源进行身份验证。该信息可以由&lt;em&gt;用户映射&lt;/em&gt;提供，该&lt;em&gt;用户映射&lt;/em&gt;可以基于当前PostgreSQL角色提供其他数据，例如用户名和密码。</target>
        </trans-unit>
        <trans-unit id="52fe1ef73da9bdc5400467df47e965d263b34732" translate="yes" xml:space="preserve">
          <source>Accessor Operator</source>
          <target state="translated">访问者操作员</target>
        </trans-unit>
        <trans-unit id="af39d0c333f65451fb8a7cecb17f3d648babe73c" translate="yes" xml:space="preserve">
          <source>Accessor operators listed in &lt;a href=&quot;datatype-json#TYPE-JSONPATH-ACCESSORS&quot;&gt;Table 8.25&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;datatype-json#TYPE-JSONPATH-ACCESSORS&quot;&gt;表8.25中&lt;/a&gt;列出了访问运算符。</target>
        </trans-unit>
        <trans-unit id="a90102b6831b1be9c270ce8e277051052e425746" translate="yes" xml:space="preserve">
          <source>According to the SQL standard all fields of an interval value must have the same sign, so a leading negative sign applies to all fields; for example the negative sign in the interval literal &lt;code&gt;'-1 2:03:04'&lt;/code&gt; applies to both the days and hour/minute/second parts. PostgreSQL allows the fields to have different signs, and traditionally treats each field in the textual representation as independently signed, so that the hour/minute/second part is considered positive in this example. If &lt;code&gt;IntervalStyle&lt;/code&gt; is set to &lt;code&gt;sql_standard&lt;/code&gt; then a leading sign is considered to apply to all fields (but only if no additional signs appear). Otherwise the traditional PostgreSQL interpretation is used. To avoid ambiguity, it's recommended to attach an explicit sign to each field if any field is negative.</source>
          <target state="translated">根据SQL标准，间隔值的所有字段必须具有相同的符号，因此前导负号适用于所有字段；例如，间隔文字 &lt;code&gt;'-1 2:03:04'&lt;/code&gt; 的负号适用于日期和小时/分钟/秒部分。 PostgreSQL允许字段具有不同的符号，并且传统上将文本表示形式中的每个字段视为独立签名，因此在此示例中，小时/分钟/秒部分被视为正数。如果 &lt;code&gt;IntervalStyle&lt;/code&gt; 设置为 &lt;code&gt;sql_standard&lt;/code&gt; 则认为前导符号适用于所有字段（但前提是没有其他符号出现）。否则，将使用传统的PostgreSQL解释。为避免歧义，如果任何字段为负，建议在每个字段上附加一个显式符号。</target>
        </trans-unit>
        <trans-unit id="3aa4c2f095ab9191962811c65fa85311b6575f00" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, grant options can be granted to &lt;code&gt;PUBLIC&lt;/code&gt;; PostgreSQL only supports granting grant options to roles.</source>
          <target state="translated">根据SQL标准，可以将授予选项授予 &lt;code&gt;PUBLIC&lt;/code&gt; ；PostgreSQL仅支持将授予选项授予角色。</target>
        </trans-unit>
        <trans-unit id="1ead55767cf3a2e09a221c81670b8f16ce3da10d" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, omitting &lt;code&gt;ESCAPE&lt;/code&gt; means there is no escape character (rather than defaulting to a backslash), and a zero-length &lt;code&gt;ESCAPE&lt;/code&gt; value is disallowed. PostgreSQL's behavior in this regard is therefore slightly nonstandard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b56b4e7b5de2231618fd8815a2cda445e53356b4" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, specifying either &lt;code&gt;RESTRICT&lt;/code&gt; or &lt;code&gt;CASCADE&lt;/code&gt; is required in a &lt;code&gt;DROP&lt;/code&gt; command. No database system actually enforces that rule, but whether the default behavior is &lt;code&gt;RESTRICT&lt;/code&gt; or &lt;code&gt;CASCADE&lt;/code&gt; varies across systems.</source>
          <target state="translated">根据SQL标准，在 &lt;code&gt;DROP&lt;/code&gt; 命令中需要指定 &lt;code&gt;RESTRICT&lt;/code&gt; 或 &lt;code&gt;CASCADE&lt;/code&gt; 。实际上，没有数据库系统会强制执行该规则，但是默认行为是 &lt;code&gt;RESTRICT&lt;/code&gt; 还是 &lt;code&gt;CASCADE&lt;/code&gt; 会因系统而异。</target>
        </trans-unit>
        <trans-unit id="2656819b0489db63b95d67c6ca681b0ebbff6d9d" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, the &lt;code&gt;PRIVILEGES&lt;/code&gt; key word in &lt;code&gt;ALL PRIVILEGES&lt;/code&gt; is required. The SQL standard does not support setting the privileges on more than one object per command.</source>
          <target state="translated">根据SQL标准， &lt;code&gt;ALL PRIVILEGES&lt;/code&gt; 的 &lt;code&gt;PRIVILEGES&lt;/code&gt; 关键字都是必需的。SQL标准不支持为每个命令在多个对象上设置特权。</target>
        </trans-unit>
        <trans-unit id="63bbcd2e4bc83757343815f2d0c5cf6131ae122b" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, the command to set this option is</source>
          <target state="translated">根据SQL标准,设置这个选项的命令是</target>
        </trans-unit>
        <trans-unit id="4b8f45ef50c256265d9c97855d8b0d2a0f3dde8f" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, the expressions in the output list should be computed before applying &lt;code&gt;DISTINCT&lt;/code&gt;, &lt;code&gt;ORDER BY&lt;/code&gt;, or &lt;code&gt;LIMIT&lt;/code&gt;. This is obviously necessary when using &lt;code&gt;DISTINCT&lt;/code&gt;, since otherwise it's not clear what values are being made distinct. However, in many cases it is convenient if output expressions are computed after &lt;code&gt;ORDER BY&lt;/code&gt; and &lt;code&gt;LIMIT&lt;/code&gt;; particularly if the output list contains any volatile or expensive functions. With that behavior, the order of function evaluations is more intuitive and there will not be evaluations corresponding to rows that never appear in the output. PostgreSQL will effectively evaluate output expressions after sorting and limiting, so long as those expressions are not referenced in &lt;code&gt;DISTINCT&lt;/code&gt;, &lt;code&gt;ORDER BY&lt;/code&gt; or &lt;code&gt;GROUP BY&lt;/code&gt;. (As a counterexample, &lt;code&gt;SELECT f(x) FROM tab ORDER BY 1&lt;/code&gt; clearly must evaluate &lt;code&gt;f(x)&lt;/code&gt; before sorting.) Output expressions that contain set-returning functions are effectively evaluated after sorting and before limiting, so that &lt;code&gt;LIMIT&lt;/code&gt; will act to cut off the output from a set-returning function.</source>
          <target state="translated">根据SQL标准，应在应用 &lt;code&gt;DISTINCT&lt;/code&gt; ， &lt;code&gt;ORDER BY&lt;/code&gt; 或 &lt;code&gt;LIMIT&lt;/code&gt; 之前计算输出列表中的表达式。当使用 &lt;code&gt;DISTINCT&lt;/code&gt; 时，这显然是必要的，因为否则不清楚将哪些值区分。但是，在许多情况下，如果在 &lt;code&gt;ORDER BY&lt;/code&gt; 和 &lt;code&gt;LIMIT&lt;/code&gt; 之后计算输出表达式是很方便的; 特别是在输出列表包含任何易失性或昂贵功能的情况下。通过这种行为，函数求值的顺序更加直观，并且不会存在与输出中永远不会出现的行相对应的求值。PostgreSQL将在排序和限制后有效地评估输出表达式，只要在 &lt;code&gt;DISTINCT&lt;/code&gt; ， &lt;code&gt;ORDER BY&lt;/code&gt; 或 &lt;code&gt;GROUP BY&lt;/code&gt; 中未引用这些表达式即可。（作为一个反例，在排序之前， &lt;code&gt;SELECT f(x) FROM tab ORDER BY 1&lt;/code&gt; 显然必须对 &lt;code&gt;f(x)&lt;/code&gt; 求值。）包含set-returning函数的输出表达式在排序后和限制前都会得到有效求值，因此 &lt;code&gt;LIMIT&lt;/code&gt; 将会切断来自设定返回功能的输出。</target>
        </trans-unit>
        <trans-unit id="6db467e85d8317c698e30a66a7291c8eafa6149b" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, the owner of a schema always owns all objects within it. PostgreSQL allows schemas to contain objects owned by users other than the schema owner. This can happen only if the schema owner grants the &lt;code&gt;CREATE&lt;/code&gt; privilege on their schema to someone else, or a superuser chooses to create objects in it.</source>
          <target state="translated">根据SQL标准，模式的所有者始终拥有其中的所有对象。PostgreSQL允许模式包含模式所有者以外的用户拥有的对象。仅当模式所有者将其模式的 &lt;code&gt;CREATE&lt;/code&gt; 权限授予其他人，或者超级用户选择在其中创建对象时，才会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="3b39ba80593aea6c161c39dff62ffc2f0348762e" translate="yes" xml:space="preserve">
          <source>According to the comp.ai.genetic FAQ it cannot be stressed too strongly that a GA is not a pure random search for a solution to a problem. A GA uses stochastic processes, but the result is distinctly non-random (better than random).</source>
          <target state="translated">根据comp.ai.genetic FAQ,不能过于强调GA不是一个纯粹的随机搜索问题的解决方案。GA使用随机过程,但结果明显是非随机的(比随机好)。</target>
        </trans-unit>
        <trans-unit id="2666b06563be42700b836e6d4059dfb52c4a608d" translate="yes" xml:space="preserve">
          <source>According to the standard, the first two characters of an error code denote a class of errors, while the last three characters indicate a specific condition within that class. Thus, an application that does not recognize the specific error code might still be able to infer what to do from the error class.</source>
          <target state="translated">根据标准,错误代码的前两个字符表示一类错误,而后三个字符表示该类错误中的一个特定条件。因此,一个不认识具体错误代码的应用程序可能仍然能够从错误类别中推断出该做什么。</target>
        </trans-unit>
        <trans-unit id="61abcddacf93fafde9cc0a4bb6f9d2b6e919d03c" translate="yes" xml:space="preserve">
          <source>According to the standard, the source value for a parenthesized sub-list of target column names can be any row-valued expression yielding the correct number of columns. PostgreSQL only allows the source value to be a &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;row constructor&lt;/a&gt; or a sub-&lt;code&gt;SELECT&lt;/code&gt;. An individual column's updated value can be specified as &lt;code&gt;DEFAULT&lt;/code&gt; in the row-constructor case, but not inside a sub-&lt;code&gt;SELECT&lt;/code&gt;.</source>
          <target state="translated">根据标准，目标列名称的带括号的子列表的源值可以是产生正确列数的任何行值表达式。PostgreSQL仅允许源值是&lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;行构造器&lt;/a&gt;或子 &lt;code&gt;SELECT&lt;/code&gt; 。在行构造器的情况下，可以将单个列的更新值指定为 &lt;code&gt;DEFAULT&lt;/code&gt; ，但不能在子 &lt;code&gt;SELECT&lt;/code&gt; 内指定。</target>
        </trans-unit>
        <trans-unit id="0980056b7787afbd8fbd30571ba2c45b1dbaa749" translate="yes" xml:space="preserve">
          <source>Acquired by &lt;code&gt;CREATE INDEX&lt;/code&gt; (without &lt;code&gt;CONCURRENTLY&lt;/code&gt;).</source>
          <target state="translated">由 &lt;code&gt;CREATE INDEX&lt;/code&gt; 获取（没有 &lt;code&gt;CONCURRENTLY&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e44eba7914f83fb7f73f8f0a727d44ad52ee7677" translate="yes" xml:space="preserve">
          <source>Acquired by &lt;code&gt;CREATE TRIGGER&lt;/code&gt; and some forms of &lt;code&gt;ALTER TABLE&lt;/code&gt; (see &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;).</source>
          <target state="translated">由 &lt;code&gt;CREATE TRIGGER&lt;/code&gt; 和某些形式的 &lt;code&gt;ALTER TABLE&lt;/code&gt; （请参阅&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;）获得。</target>
        </trans-unit>
        <trans-unit id="c03704a90b839a00364666b3432c1fe877f7cfa4" translate="yes" xml:space="preserve">
          <source>Acquired by &lt;code&gt;REFRESH MATERIALIZED VIEW CONCURRENTLY&lt;/code&gt;.</source>
          <target state="translated">同时被 &lt;code&gt;REFRESH MATERIALIZED VIEW CONCURRENTLY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="35b293b84736887604a4df3e4f117c1dcc96bdfc" translate="yes" xml:space="preserve">
          <source>Acquired by &lt;code&gt;VACUUM&lt;/code&gt; (without &lt;code&gt;FULL&lt;/code&gt;), &lt;code&gt;ANALYZE&lt;/code&gt;, &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt;, &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt;, &lt;code&gt;CREATE STATISTICS&lt;/code&gt;, and certain &lt;code&gt;ALTER INDEX&lt;/code&gt; and &lt;code&gt;ALTER TABLE&lt;/code&gt; variants (for full details see &lt;a href=&quot;sql-alterindex&quot;&gt;ALTER INDEX&lt;/a&gt; and &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;).</source>
          <target state="translated">由 &lt;code&gt;VACUUM&lt;/code&gt; （无 &lt;code&gt;FULL&lt;/code&gt; ）获取，进行 &lt;code&gt;ANALYZE&lt;/code&gt; ，同时 &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt; ， &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt; 创建索引， &lt;code&gt;CREATE STATISTICS&lt;/code&gt; 和某些 &lt;code&gt;ALTER INDEX&lt;/code&gt; 和 &lt;code&gt;ALTER TABLE&lt;/code&gt; 变体（有关详细信息，请参见&lt;a href=&quot;sql-alterindex&quot;&gt;ALTER INDEX&lt;/a&gt;和&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="4a64648cce36216f47287c3873ec5299a8307659" translate="yes" xml:space="preserve">
          <source>Acquired by the &lt;code&gt;DROP TABLE&lt;/code&gt;, &lt;code&gt;TRUNCATE&lt;/code&gt;, &lt;code&gt;REINDEX&lt;/code&gt;, &lt;code&gt;CLUSTER&lt;/code&gt;, &lt;code&gt;VACUUM FULL&lt;/code&gt;, and &lt;code&gt;REFRESH MATERIALIZED VIEW&lt;/code&gt; (without &lt;code&gt;CONCURRENTLY&lt;/code&gt;) commands. Many forms of &lt;code&gt;ALTER INDEX&lt;/code&gt; and &lt;code&gt;ALTER TABLE&lt;/code&gt; also acquire a lock at this level. This is also the default lock mode for &lt;code&gt;LOCK TABLE&lt;/code&gt; statements that do not specify a mode explicitly.</source>
          <target state="translated">由 &lt;code&gt;DROP TABLE&lt;/code&gt; ， &lt;code&gt;TRUNCATE&lt;/code&gt; ， &lt;code&gt;REINDEX&lt;/code&gt; ， &lt;code&gt;CLUSTER&lt;/code&gt; ， &lt;code&gt;VACUUM FULL&lt;/code&gt; 和 &lt;code&gt;REFRESH MATERIALIZED VIEW&lt;/code&gt; （无 &lt;code&gt;CONCURRENTLY&lt;/code&gt; ）命令获取。许多形式的 &lt;code&gt;ALTER INDEX&lt;/code&gt; 和 &lt;code&gt;ALTER TABLE&lt;/code&gt; 也在此级别获得锁定。这也是未明确指定模式的 &lt;code&gt;LOCK TABLE&lt;/code&gt; 语句的默认锁定模式。</target>
        </trans-unit>
        <trans-unit id="116672ae6ceb211b89b5cc24d53045f44bb76b12" translate="yes" xml:space="preserve">
          <source>Acronyms</source>
          <target state="translated">Acronyms</target>
        </trans-unit>
        <trans-unit id="a43a7e7ff4a4d6f955aa729ae7ff758305e7b11f" translate="yes" xml:space="preserve">
          <source>Active txids at the time of the snapshot. The list includes only those active txids between &lt;code&gt;xmin&lt;/code&gt; and &lt;code&gt;xmax&lt;/code&gt;; there might be active txids higher than &lt;code&gt;xmax&lt;/code&gt;. A txid that is &lt;code&gt;xmin &amp;lt;= txid &amp;lt; xmax&lt;/code&gt; and not in this list was already completed at the time of the snapshot, and thus either visible or dead according to its commit status. The list does not include txids of subtransactions.</source>
          <target state="translated">快照时的活动txid。该列表仅包括 &lt;code&gt;xmin&lt;/code&gt; 和 &lt;code&gt;xmax&lt;/code&gt; 之间的活动txid ；可能存在高于 &lt;code&gt;xmax&lt;/code&gt; 的活动txid 。TxID添加即 &lt;code&gt;xmin &amp;lt;= txid &amp;lt; xmax&lt;/code&gt; ，而不是在该列表中已经完成了在快照的时间，并且根据由此可见或死其提交状态。该列表不包括子事务的txid。</target>
        </trans-unit>
        <trans-unit id="409557212ade1f78b39e4494cd71d7a5778b675f" translate="yes" xml:space="preserve">
          <source>Activity status of the WAL receiver process</source>
          <target state="translated">WAL接收器进程的活动状态</target>
        </trans-unit>
        <trans-unit id="5074d759e3f5dbe3c6aa005b1369aadfa7087d57" translate="yes" xml:space="preserve">
          <source>Actual data stored in the large object. This will never be more than &lt;code&gt;LOBLKSIZE&lt;/code&gt; bytes and might be less.</source>
          <target state="translated">实际数据存储在大对象中。这永远不会超过 &lt;code&gt;LOBLKSIZE&lt;/code&gt; 个字节，并且可能会更少。</target>
        </trans-unit>
        <trans-unit id="5cef4a325f0a5fb8a611f2f24f0d274a093ec734" translate="yes" xml:space="preserve">
          <source>Actually the preceding paragraph is an oversimplification: there are two cases in which a function-call construct will be treated as a cast request without having matched it to an actual function. If a function call &lt;code&gt;name&lt;/code&gt;(&lt;code&gt;x&lt;/code&gt;) does not exactly match any existing function, but &lt;code&gt;name&lt;/code&gt; is the name of a data type and &lt;code&gt;pg_cast&lt;/code&gt; provides a binary-coercible cast to this type from the type of &lt;code&gt;x&lt;/code&gt;, then the call will be construed as a binary-coercible cast. This exception is made so that binary-coercible casts can be invoked using functional syntax, even though they lack any function. Likewise, if there is no &lt;code&gt;pg_cast&lt;/code&gt; entry but the cast would be to or from a string type, the call will be construed as an I/O conversion cast. This exception allows I/O conversion casts to be invoked using functional syntax.</source>
          <target state="translated">实际上，上一段是一个过分简化的情况：在两种情况下，函数调用构造将被视为强制转换请求，而不将其与实际函数匹配。如果函数调用 &lt;code&gt;name&lt;/code&gt; （ &lt;code&gt;x&lt;/code&gt; ）与任何现有函数都不完全匹配，但是 &lt;code&gt;name&lt;/code&gt; 是数据类型的名称，并且 &lt;code&gt;pg_cast&lt;/code&gt; 提供了从 &lt;code&gt;x&lt;/code&gt; 类型转换为该类型的二进制可强制转换，则该调用将被解释为a二元可强制转换设置此异常是为了使二进制强制转换可以使用功能语法来调用，即使它们缺少任何功能。同样，如果没有 &lt;code&gt;pg_cast&lt;/code&gt; 条目，但强制类型转换为字符串类型或从字符串类型强制转换，则该调用将被解释为I / O转换强制类型。此异常允许使用功能语法调用I / O转换强制转换。</target>
        </trans-unit>
        <trans-unit id="99bd76b2471dd3de3de3ab7c1c222041031e9e64" translate="yes" xml:space="preserve">
          <source>Actually, each &amp;ldquo;character&amp;rdquo; can be any string not containing whitespace, so &lt;code&gt;unaccent&lt;/code&gt; dictionaries could be used for other sorts of substring substitutions besides diacritic removal.</source>
          <target state="translated">实际上，每个&amp;ldquo;字符&amp;rdquo;都可以是不包含空格的任何字符串，因此除变音符号删除外，不 &lt;code&gt;unaccent&lt;/code&gt; 字典还可用于其他类型的子字符串替换。</target>
        </trans-unit>
        <trans-unit id="fb4a150119fee7c38df2ebe67adb1f04cd8a1672" translate="yes" xml:space="preserve">
          <source>Actually, in these example queries, &lt;code&gt;coalesce&lt;/code&gt; should be used to prevent a single &lt;code&gt;NULL&lt;/code&gt; attribute from causing a &lt;code&gt;NULL&lt;/code&gt; result for the whole document.</source>
          <target state="translated">实际上，在这些示例查询中，应该使用 &lt;code&gt;coalesce&lt;/code&gt; 来防止单个 &lt;code&gt;NULL&lt;/code&gt; 属性对整个文档造成 &lt;code&gt;NULL&lt;/code&gt; 结果。</target>
        </trans-unit>
        <trans-unit id="8f0894c46fc9b6047265c297cf124917360edc17" translate="yes" xml:space="preserve">
          <source>Actually, the even more general syntax</source>
          <target state="translated">实际上,更通用的语法是</target>
        </trans-unit>
        <trans-unit id="9d49dccdc43481d06a4ef58b29107551c088b828" translate="yes" xml:space="preserve">
          <source>Adaptive?</source>
          <target state="translated">Adaptive?</target>
        </trans-unit>
        <trans-unit id="4415296784c0ee879898fb9df132309b61a61a7c" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; to &lt;code&gt;INSERT&lt;/code&gt; commands. This option is not valid unless &lt;code&gt;--inserts&lt;/code&gt; or &lt;code&gt;--column-inserts&lt;/code&gt; is also specified.</source>
          <target state="translated">在 &lt;code&gt;INSERT&lt;/code&gt; 命令中添加 &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; 。除非还指定了 &lt;code&gt;--inserts&lt;/code&gt; 或 &lt;code&gt;--column-inserts&lt;/code&gt; ,否则此选项无效。</target>
        </trans-unit>
        <trans-unit id="6e9832f60aad6d89585289ea2e0edf7fc9e5b79b" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; to &lt;code&gt;INSERT&lt;/code&gt; commands. This option is not valid unless &lt;code&gt;--inserts&lt;/code&gt;, &lt;code&gt;--column-inserts&lt;/code&gt; or &lt;code&gt;--rows-per-insert&lt;/code&gt; is also specified.</source>
          <target state="translated">在 &lt;code&gt;INSERT&lt;/code&gt; 命令中添加 &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; 。除非还指定了 &lt;code&gt;--inserts&lt;/code&gt; ，-- &lt;code&gt;--column-inserts&lt;/code&gt; 或 &lt;code&gt;--rows-per-insert&lt;/code&gt; ，否则此选项无效。</target>
        </trans-unit>
        <trans-unit id="df59723089709ab5e5075047c1ac7d254b3f6b22" translate="yes" xml:space="preserve">
          <source>Add a key, or update an existing key with a new value:</source>
          <target state="translated">添加一个键,或者用新的值更新一个现有的键。</target>
        </trans-unit>
        <trans-unit id="7a5572f228e469f1c2f4cd272c7b0cda74e7acf6" translate="yes" xml:space="preserve">
          <source>Add a number of days to a date</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0f3c97b278869eab76434c25a08bb2d9b563aa2" translate="yes" xml:space="preserve">
          <source>Add a time-of-day to a date</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bacadfab25c06160832a539f1c1f1901edb824fd" translate="yes" xml:space="preserve">
          <source>Add a transaction script read from &lt;code&gt;filename&lt;/code&gt; to the list of executed scripts. An optional integer weight after &lt;code&gt;@&lt;/code&gt; allows to adjust the probability of drawing the test. See below for details.</source>
          <target state="translated">将从 &lt;code&gt;filename&lt;/code&gt; 读取的事务处理脚本添加到已执行脚本的列表中。 &lt;code&gt;@&lt;/code&gt; 之后的可选整数权重允许调整绘制测试的可能性。有关详情，请参见下文。</target>
        </trans-unit>
        <trans-unit id="e386cb056d908799805563d1ba2a71ca187f495b" translate="yes" xml:space="preserve">
          <source>Add an interval to a date</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30629dc5115a69a1747c013e1cc5a69e275df7a1" translate="yes" xml:space="preserve">
          <source>Add an interval to a time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc1ce74f84bf95ea154baff4f8c09c2914ce6d50" translate="yes" xml:space="preserve">
          <source>Add an interval to a timestamp</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b612d09d7cda7883ad9f9c1e74b2026a76de08a5" translate="yes" xml:space="preserve">
          <source>Add columns</source>
          <target state="translated">增加列</target>
        </trans-unit>
        <trans-unit id="fdd20704520d17d4473df8ba637e593e3c1e9d32" translate="yes" xml:space="preserve">
          <source>Add constraints</source>
          <target state="translated">增加制约因素</target>
        </trans-unit>
        <trans-unit id="7b67cedcfe4d56f7816bcfdf431ad5afd738eb2a" translate="yes" xml:space="preserve">
          <source>Add intervals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ee44cc339a6c285bac845e10d98461ab1145004" translate="yes" xml:space="preserve">
          <source>Add non-overlapping table constraints to the child tables to define the allowed key values in each.</source>
          <target state="translated">在子表中添加不重叠的表约束,以定义每个表的允许键值。</target>
        </trans-unit>
        <trans-unit id="48999cb16b06daffee5cbba84a68d9e3c43940fe" translate="yes" xml:space="preserve">
          <source>Add or change the assignment to be made to a configuration parameter when the function is called. If &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;DEFAULT&lt;/code&gt; or, equivalently, &lt;code&gt;RESET&lt;/code&gt; is used, the function-local setting is removed, so that the function executes with the value present in its environment. Use &lt;code&gt;RESET ALL&lt;/code&gt; to clear all function-local settings. &lt;code&gt;SET FROM CURRENT&lt;/code&gt; saves the value of the parameter that is current when &lt;code&gt;ALTER FUNCTION&lt;/code&gt; is executed as the value to be applied when the function is entered.</source>
          <target state="translated">调用函数时，添加或更改要对配置参数进行的分配。如果 &lt;code&gt;value&lt;/code&gt; 为 &lt;code&gt;DEFAULT&lt;/code&gt; 或等效地使用 &lt;code&gt;RESET&lt;/code&gt; ，则将删除函数本地设置，以便函数以其环境中存在的值执行。使用 &lt;code&gt;RESET ALL&lt;/code&gt; 清除所有本地功能设置。 &lt;code&gt;SET FROM CURRENT&lt;/code&gt; 会将执行 &lt;code&gt;ALTER FUNCTION&lt;/code&gt; 时当前参数的值保存为输入该功能时要应用的值。</target>
        </trans-unit>
        <trans-unit id="741a6eebd9634b6405712ee7bced8a90249de64a" translate="yes" xml:space="preserve">
          <source>Add or change the assignment to be made to a configuration parameter when the procedure is called. If &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;DEFAULT&lt;/code&gt; or, equivalently, &lt;code&gt;RESET&lt;/code&gt; is used, the procedure-local setting is removed, so that the procedure executes with the value present in its environment. Use &lt;code&gt;RESET ALL&lt;/code&gt; to clear all procedure-local settings. &lt;code&gt;SET FROM CURRENT&lt;/code&gt; saves the value of the parameter that is current when &lt;code&gt;ALTER PROCEDURE&lt;/code&gt; is executed as the value to be applied when the procedure is entered.</source>
          <target state="translated">调用过程时，添加或更改要对配置参数进行的分配。如果 &lt;code&gt;value&lt;/code&gt; 是 &lt;code&gt;DEFAULT&lt;/code&gt; 或等效地使用 &lt;code&gt;RESET&lt;/code&gt; ，则将删除过程本地设置，以便过程以其环境中存在的值执行。使用 &lt;code&gt;RESET ALL&lt;/code&gt; 清除所有本地过程设置。 &lt;code&gt;SET FROM CURRENT&lt;/code&gt; 会将执行 &lt;code&gt;ALTER PROCEDURE&lt;/code&gt; 时当前的参数值保存为输入该过程时要应用的值。</target>
        </trans-unit>
        <trans-unit id="3e939370f13d4d6648fdf6ebce042de2b0c8b35d" translate="yes" xml:space="preserve">
          <source>Add some tables to the publication:</source>
          <target state="translated">在出版物中增加一些表格。</target>
        </trans-unit>
        <trans-unit id="0adf6644f343dab5da55bc308f3c6ee3087cbd49" translate="yes" xml:space="preserve">
          <source>Add the new column, with a default, to &lt;code&gt;pg_proc.h&lt;/code&gt;:</source>
          <target state="translated">将新列（默认情况下）添加到 &lt;code&gt;pg_proc.h&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="752268a69e3b24883f304a215dae5d50dea7c0b0" translate="yes" xml:space="preserve">
          <source>Add the probe definition to &lt;code&gt;src/backend/utils/probes.d&lt;/code&gt;:</source>
          <target state="translated">将探针定义添加到 &lt;code&gt;src/backend/utils/probes.d&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="ce0fb0fdfabd7e1bdcafb562c60398cbe55ebe0d" translate="yes" xml:space="preserve">
          <source>Add the probe definitions to &lt;code&gt;src/backend/utils/probes.d&lt;/code&gt;</source>
          <target state="translated">将探针定义添加到 &lt;code&gt;src/backend/utils/probes.d&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4acf1110e0d52a03ba3a64c356b491cd2bd51279" translate="yes" xml:space="preserve">
          <source>Add the specified built-in script to the list of executed scripts. An optional integer weight after &lt;code&gt;@&lt;/code&gt; allows to adjust the probability of drawing the script. If not specified, it is set to 1. Available built-in scripts are: &lt;code&gt;tpcb-like&lt;/code&gt;, &lt;code&gt;simple-update&lt;/code&gt; and &lt;code&gt;select-only&lt;/code&gt;. Unambiguous prefixes of built-in names are accepted. With special name &lt;code&gt;list&lt;/code&gt;, show the list of built-in scripts and exit immediately.</source>
          <target state="translated">将指定的内置脚本添加到已执行脚本的列表中。 &lt;code&gt;@&lt;/code&gt; 之后的可选整数权重允许调整绘制脚本的概率。如果未指定，则将其设置为1。可用的内置脚本为： &lt;code&gt;tpcb-like&lt;/code&gt; ， &lt;code&gt;simple-update&lt;/code&gt; 和 &lt;code&gt;select-only&lt;/code&gt; 。接受内置名称的明确前缀。使用特殊名称 &lt;code&gt;list&lt;/code&gt; ，显示内置脚本的列表并立即退出。</target>
        </trans-unit>
        <trans-unit id="c0ab5a63742ff89241c46899c37233e1df7c86b0" translate="yes" xml:space="preserve">
          <source>Add users to a group:</source>
          <target state="translated">将用户添加到一个组。</target>
        </trans-unit>
        <trans-unit id="8caea2f156f156f661ed21fc3f27f4bbd2fa80f2" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;CHECK&lt;/code&gt; or &lt;code&gt;NOT NULL&lt;/code&gt; constraint requires scanning the table to verify that existing rows meet the constraint, but does not require a table rewrite.</source>
          <target state="translated">添加 &lt;code&gt;CHECK&lt;/code&gt; 或 &lt;code&gt;NOT NULL&lt;/code&gt; 约束要求扫描表以验证现有行是否满足约束，但不需要重写表。</target>
        </trans-unit>
        <trans-unit id="cffe5a53117b776e99930ab76048f8855b384b5a" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraint will automatically create a unique btree index on the column or group of columns used in the constraint. The optional &lt;code&gt;INCLUDE&lt;/code&gt; clause allows a list of columns to be specified which will be included in the non-key portion of the index. Although uniqueness is not enforced on the included columns, the constraint still depends on them. Consequently, some operations on the included columns (e.g. &lt;code&gt;DROP COLUMN&lt;/code&gt;) can cause cascaded constraint and index deletion.</source>
          <target state="translated">添加 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 约束将自动在约束中使用的列或一组列上创建唯一的btree索引。可选的 &lt;code&gt;INCLUDE&lt;/code&gt; 子句允许指定列列表，这些列将包含在索引的非键部分中。尽管不对包含的列强制执行唯一性，但约束仍然取决于它们。因此，对包含的列的某些操作（例如 &lt;code&gt;DROP COLUMN&lt;/code&gt; ）可能会导致级联约束和索引删除。</target>
        </trans-unit>
        <trans-unit id="9e3b837b83f00305a477861a47c68fa313f35aa1" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraint will automatically create a unique btree index on the column or group of columns used in the constraint. The optional &lt;code&gt;INCLUDE&lt;/code&gt; clause allows a list of columns to be specified which will be included in the non-key portion of the index. Although uniqueness is not enforced on the included columns, the constraint still depends on them. Consequently, some operations on the included columns (e.g., &lt;code&gt;DROP COLUMN&lt;/code&gt;) can cause cascaded constraint and index deletion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c642f86413e7e0c5d8cf9f40dd1b146f4c06e416" translate="yes" xml:space="preserve">
          <source>Adding a column with a volatile &lt;code&gt;DEFAULT&lt;/code&gt; or changing the type of an existing column will require the entire table and its indexes to be rewritten. As an exception, when changing the type of an existing column, if the &lt;code&gt;USING&lt;/code&gt; clause does not change the column contents and the old type is either binary coercible to the new type or an unconstrained domain over the new type, a table rewrite is not needed; but any indexes on the affected columns must still be rebuilt. Table and/or index rebuilds may take a significant amount of time for a large table; and will temporarily require as much as double the disk space.</source>
          <target state="translated">添加具有易失性 &lt;code&gt;DEFAULT&lt;/code&gt; 的列或更改现有列的类型将需要重写整个表及其索引。作为例外，在更改现有列的类型时，如果 &lt;code&gt;USING&lt;/code&gt; 子句不更改列的内容，并且旧类型可以二进制强制转换为新类型，或者对新类型具有不受约束的域，则无需重写表;但是受影响的列上的所有索引仍必须重建。对于大型表，表和/或索引的重建可能会花费大量时间；并且暂时需要多达两倍的磁盘空间。</target>
        </trans-unit>
        <trans-unit id="c58efc1059381c4bf8b362143436cd8c4af55346" translate="yes" xml:space="preserve">
          <source>Adding a constraint using an existing index can be helpful in situations where a new constraint needs to be added without blocking table updates for a long time. To do that, create the index using &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt;, and then install it as an official constraint using this syntax. See the example below.</source>
          <target state="translated">在需要添加新约束而不长时间阻止表更新的情况下，使用现有索引添加约束可能会有所帮助。为此，请使用 &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt; 创建索引，然后使用此语法将其安装为正式约束。请参见下面的示例。</target>
        </trans-unit>
        <trans-unit id="c57d929aced463125ab8b2f66f31b21a04522c5d" translate="yes" xml:space="preserve">
          <source>Adding a primary key will automatically create a unique B-tree index on the column or group of columns listed in the primary key, and will force the column(s) to be marked &lt;code&gt;NOT NULL&lt;/code&gt;.</source>
          <target state="translated">添加主键将自动在主键中列出的列或一组列上创建唯一的B树索引，并强制将这些列标记为 &lt;code&gt;NOT NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ee5dc2437e432908c48ca918b4296acc2f6a028" translate="yes" xml:space="preserve">
          <source>Adding a unique constraint will automatically create a unique B-tree index on the column or group of columns listed in the constraint. A uniqueness restriction covering only some rows cannot be written as a unique constraint, but it is possible to enforce such a restriction by creating a unique &lt;a href=&quot;indexes-partial&quot;&gt;partial index&lt;/a&gt;.</source>
          <target state="translated">添加唯一约束将在约束中列出的列或一组列上自动创建唯一的B树索引。不能将仅覆盖某些行的唯一性限制写为唯一性约束，但是可以通过创建唯一的&lt;a href=&quot;indexes-partial&quot;&gt;部分索引&lt;/a&gt;来实施这种限制。</target>
        </trans-unit>
        <trans-unit id="1e5ef315a51bb0b0043f1a6d7277abada165d078" translate="yes" xml:space="preserve">
          <source>Adding a unique constraint will automatically create a unique btree index on the column or group of columns used in the constraint. The optional clause &lt;code&gt;INCLUDE&lt;/code&gt; adds to that index one or more columns on which the uniqueness is not enforced. Note that although the constraint is not enforced on the included columns, it still depends on them. Consequently, some operations on these columns (e.g. &lt;code&gt;DROP COLUMN&lt;/code&gt;) can cause cascaded constraint and index deletion.</source>
          <target state="translated">添加唯一约束将在约束中使用的列或一组列上自动创建唯一的btree索引。可选子句 &lt;code&gt;INCLUDE&lt;/code&gt; 向该索引添加了一个或多个不强制执行唯一性的列。请注意，尽管未对包含的列强制实施约束，但仍取决于它们。因此，对这些列的某些操作（例如 &lt;code&gt;DROP COLUMN&lt;/code&gt; ）可能会导致级联约束和索引删除。</target>
        </trans-unit>
        <trans-unit id="fa8235a384df080ad3fe537c45554b56b2b4ea42" translate="yes" xml:space="preserve">
          <source>Adding a unique constraint will automatically create a unique btree index on the column or group of columns used in the constraint. The optional clause &lt;code&gt;INCLUDE&lt;/code&gt; adds to that index one or more columns on which the uniqueness is not enforced. Note that although the constraint is not enforced on the included columns, it still depends on them. Consequently, some operations on these columns (e.g., &lt;code&gt;DROP COLUMN&lt;/code&gt;) can cause cascaded constraint and index deletion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bcad53930a4507d157767aa00d4a8d4f833266c" translate="yes" xml:space="preserve">
          <source>Adding an exclusion constraint will automatically create an index of the type specified in the constraint declaration.</source>
          <target state="translated">添加排除约束将自动创建约束声明中指定类型的索引。</target>
        </trans-unit>
        <trans-unit id="7173dacda23801ef619f4e60a2645585a6fe0048" translate="yes" xml:space="preserve">
          <source>Adding parentheses around an RE does not change its greediness.</source>
          <target state="translated">在RE周围加括号并不能改变其贪婪性。</target>
        </trans-unit>
        <trans-unit id="8e8428e85c661f03dd33db8f12b20a010ab5be5e" translate="yes" xml:space="preserve">
          <source>Addition</source>
          <target state="translated">Addition</target>
        </trans-unit>
        <trans-unit id="65d284b9baecd42d63cb154eecd228122b272bd2" translate="yes" xml:space="preserve">
          <source>Addition of a foreign key constraint requires a &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; lock on the referenced table, in addition to the lock on the table receiving the constraint.</source>
          <target state="translated">除了接收约束的表上的锁外，外键约束的添加还需要对引用表进行 &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; 锁定。</target>
        </trans-unit>
        <trans-unit id="2025ebd7978991464bc4c04e553287e1846aa3ca" translate="yes" xml:space="preserve">
          <source>Additional Features</source>
          <target state="translated">附加功能</target>
        </trans-unit>
        <trans-unit id="15680ea5248b05a075106e29ed181bc54958d717" translate="yes" xml:space="preserve">
          <source>Additional binary string manipulation functions are available and are listed in &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-OTHER&quot;&gt;Table 9.12&lt;/a&gt;. Some of them are used internally to implement the SQL-standard string functions listed in &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-SQL&quot;&gt;Table 9.11&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89c24238b1c616d3f7452d5dd9217a02ce8ecaf1" translate="yes" xml:space="preserve">
          <source>Additional binary string manipulation functions are available and are listed in &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-OTHER&quot;&gt;Table 9.13&lt;/a&gt;. Some of them are used internally to implement the SQL-standard string functions listed in &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-SQL&quot;&gt;Table 9.12&lt;/a&gt;.</source>
          <target state="translated">其他可用的二进制字符串操作函数可用，并在&lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-OTHER&quot;&gt;表9.13&lt;/a&gt;中列出。其中一些用于内部实现&lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-SQL&quot;&gt;表9.12中&lt;/a&gt;列出的SQL标准字符串函数。</target>
        </trans-unit>
        <trans-unit id="9e5fd4e93e599bcb1fb3d2db4b33749ab6dcc12b" translate="yes" xml:space="preserve">
          <source>Additional considerations apply to the use of generated columns.</source>
          <target state="translated">在使用生成的列时,还需考虑其他因素。</target>
        </trans-unit>
        <trans-unit id="aa325cbf6ead34348f2e89548944a03a6c03ebc9" translate="yes" xml:space="preserve">
          <source>Additional discussion and practical examples can be found in &lt;a href=&quot;ddl-rowsecurity&quot;&gt;Section 5.8&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;ddl-rowsecurity&quot;&gt;5.8节中提供了&lt;/a&gt;其他讨论和实际示例。</target>
        </trans-unit>
        <trans-unit id="1fbe8c837563c2f0daf28f682cb1a5ab1ec6f6fe" translate="yes" xml:space="preserve">
          <source>Additional enhancements by Andrew Gierth &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:andrew@tao11.riddles.org.uk&quot;&gt;andrew@tao11.riddles.org.uk&lt;/a&gt;&amp;gt;&lt;/code&gt;, United Kingdom</source>
          <target state="translated">英国安德鲁&amp;middot;吉斯（Andrew Gierth） &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:andrew@tao11.riddles.org.uk&quot;&gt;andrew@tao11.riddles.org.uk&lt;/a&gt;&amp;gt;&lt;/code&gt; 其他增强功能</target>
        </trans-unit>
        <trans-unit id="0ef08f4faa1371707ef2f6feef718bf54953d0e6" translate="yes" xml:space="preserve">
          <source>Additional extensions are available that implement transforms for the &lt;code&gt;hstore&lt;/code&gt; type for the languages PL/Perl and PL/Python. The extensions for PL/Perl are called &lt;code&gt;hstore_plperl&lt;/code&gt; and &lt;code&gt;hstore_plperlu&lt;/code&gt;, for trusted and untrusted PL/Perl. If you install these transforms and specify them when creating a function, &lt;code&gt;hstore&lt;/code&gt; values are mapped to Perl hashes. The extensions for PL/Python are called &lt;code&gt;hstore_plpythonu&lt;/code&gt;, &lt;code&gt;hstore_plpython2u&lt;/code&gt;, and &lt;code&gt;hstore_plpython3u&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/plpython-python23.html&quot;&gt;Section 45.1&lt;/a&gt; for the PL/Python naming convention). If you use them, &lt;code&gt;hstore&lt;/code&gt; values are mapped to Python dictionaries.</source>
          <target state="translated">可以使用其他扩展来实现对PL / Perl和PL / Python语言的 &lt;code&gt;hstore&lt;/code&gt; 类型的转换。 PL / Perl的扩展名为 &lt;code&gt;hstore_plperl&lt;/code&gt; 和 &lt;code&gt;hstore_plperlu&lt;/code&gt; ，用于受信任和不受信任的PL / Perl。如果安装这些转换并在创建函数时指定它们，则 &lt;code&gt;hstore&lt;/code&gt; 值将映射到Perl哈希。 PL / Python的扩展名为 &lt;code&gt;hstore_plpythonu&lt;/code&gt; ， &lt;code&gt;hstore_plpython2u&lt;/code&gt; 和 &lt;code&gt;hstore_plpython3u&lt;/code&gt; （有关PL / Python的命名约定，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/plpython-python23.html&quot;&gt;第45.1节&lt;/a&gt;）。如果使用它们，则 &lt;code&gt;hstore&lt;/code&gt; 值将映射到Python字典。</target>
        </trans-unit>
        <trans-unit id="17bd8a6e2056a675b0fbad2a48d38ec5e91b9a37" translate="yes" xml:space="preserve">
          <source>Additional extensions are available that implement transforms for the &lt;code&gt;hstore&lt;/code&gt; type for the languages PL/Perl and PL/Python. The extensions for PL/Perl are called &lt;code&gt;hstore_plperl&lt;/code&gt; and &lt;code&gt;hstore_plperlu&lt;/code&gt;, for trusted and untrusted PL/Perl. If you install these transforms and specify them when creating a function, &lt;code&gt;hstore&lt;/code&gt; values are mapped to Perl hashes. The extensions for PL/Python are called &lt;code&gt;hstore_plpythonu&lt;/code&gt;, &lt;code&gt;hstore_plpython2u&lt;/code&gt;, and &lt;code&gt;hstore_plpython3u&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/13/plpython-python23.html&quot;&gt;Section 45.1&lt;/a&gt; for the PL/Python naming convention). If you use them, &lt;code&gt;hstore&lt;/code&gt; values are mapped to Python dictionaries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6954bc39f2ef60e2e03ec59460cfa1e30432da9" translate="yes" xml:space="preserve">
          <source>Additional extensions are available that implement transforms for the &lt;code&gt;jsonb&lt;/code&gt; type for different procedural languages.</source>
          <target state="translated">可以使用其他扩展来实现针对不同过程语言的 &lt;code&gt;jsonb&lt;/code&gt; 类型的转换。</target>
        </trans-unit>
        <trans-unit id="041eecca386b7ca679e006e4c9dbf17a8a23f03a" translate="yes" xml:space="preserve">
          <source>Additional extensions are available that implement transforms for the &lt;code&gt;ltree&lt;/code&gt; type for PL/Python. The extensions are called &lt;code&gt;ltree_plpythonu&lt;/code&gt;, &lt;code&gt;ltree_plpython2u&lt;/code&gt;, and &lt;code&gt;ltree_plpython3u&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/plpython-python23.html&quot;&gt;Section 45.1&lt;/a&gt; for the PL/Python naming convention). If you install these transforms and specify them when creating a function, &lt;code&gt;ltree&lt;/code&gt; values are mapped to Python lists. (The reverse is currently not supported, however.)</source>
          <target state="translated">可以使用其他扩展来实现PL / Python 的 &lt;code&gt;ltree&lt;/code&gt; 类型的转换。这些扩展名为 &lt;code&gt;ltree_plpythonu&lt;/code&gt; ， &lt;code&gt;ltree_plpython2u&lt;/code&gt; 和 &lt;code&gt;ltree_plpython3u&lt;/code&gt; （有关PL / Python命名约定，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/plpython-python23.html&quot;&gt;第45.1节&lt;/a&gt;）。如果安装这些转换并在创建函数时指定它们，则 &lt;code&gt;ltree&lt;/code&gt; 值将映射到Python列表。（但是，当前不支持相反的功能。）</target>
        </trans-unit>
        <trans-unit id="5a2588f70de7908623c3d75b4d858ce4b4c9f548" translate="yes" xml:space="preserve">
          <source>Additional extensions are available that implement transforms for the &lt;code&gt;ltree&lt;/code&gt; type for PL/Python. The extensions are called &lt;code&gt;ltree_plpythonu&lt;/code&gt;, &lt;code&gt;ltree_plpython2u&lt;/code&gt;, and &lt;code&gt;ltree_plpython3u&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/13/plpython-python23.html&quot;&gt;Section 45.1&lt;/a&gt; for the PL/Python naming convention). If you install these transforms and specify them when creating a function, &lt;code&gt;ltree&lt;/code&gt; values are mapped to Python lists. (The reverse is currently not supported, however.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="848e3ef5eb869b4a42890d26de458d77b4145059" translate="yes" xml:space="preserve">
          <source>Additional functions related to statistics collection are listed in &lt;a href=&quot;monitoring-stats#MONITORING-STATS-FUNCS-TABLE&quot;&gt;Table 27.20&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;monitoring-stats#MONITORING-STATS-FUNCS-TABLE&quot;&gt;表27.20&lt;/a&gt;列出了与统计信息收集有关的其他功能。</target>
        </trans-unit>
        <trans-unit id="efb9efc34358e145f231e909fca0c910acaa66eb" translate="yes" xml:space="preserve">
          <source>Additional functions related to statistics collection are listed in &lt;a href=&quot;monitoring-stats#MONITORING-STATS-FUNCS-TABLE&quot;&gt;Table 27.30&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77a49395f2c7e958118c2da8e1de4c14e6b60602" translate="yes" xml:space="preserve">
          <source>Additional information about how to invoke the function. Again, the interpretation is language-specific.</source>
          <target state="translated">关于如何调用该函数的其他信息。同样,解释也是因语言而异的。</target>
        </trans-unit>
        <trans-unit id="284dcb5991a8da2d3edb0ed1251edf3e8b725229" translate="yes" xml:space="preserve">
          <source>Additional information about subscriptions and logical replication as a whole is available at &lt;a href=&quot;logical-replication-subscription&quot;&gt;Section 30.2&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/logical-replication.html&quot;&gt;Chapter 30&lt;/a&gt;.</source>
          <target state="translated">有关订阅和整个逻辑复制的更多信息，请参见&lt;a href=&quot;logical-replication-subscription&quot;&gt;第30.2节&lt;/a&gt;和&lt;a href=&quot;https://www.postgresql.org/docs/12/logical-replication.html&quot;&gt;第30章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="031701e67cc64e29e0f780df4ac7b24959b2258c" translate="yes" xml:space="preserve">
          <source>Additional information about subscriptions and logical replication as a whole is available at &lt;a href=&quot;logical-replication-subscription&quot;&gt;Section 30.2&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/13/logical-replication.html&quot;&gt;Chapter 30&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eacaa0140464ef9b6f84f47defe84ade132e976" translate="yes" xml:space="preserve">
          <source>Additional options controlling how the format specifier's output is formatted. Currently the only supported flag is a minus sign (&lt;code&gt;-&lt;/code&gt;) which will cause the format specifier's output to be left-justified. This has no effect unless the &lt;code&gt;width&lt;/code&gt; field is also specified.</source>
          <target state="translated">其他选项，用于控制格式说明符输出的格式。当前唯一支持的标志是减号（ &lt;code&gt;-&lt;/code&gt; ），这将导致格式说明符的输出向左对齐。除非也指定 &lt;code&gt;width&lt;/code&gt; 字段，否则这无效。</target>
        </trans-unit>
        <trans-unit id="b2569d5e654fdba9e13f3a3587c2c0d71e119a8f" translate="yes" xml:space="preserve">
          <source>Additional options controlling how the format specifier's output is formatted. Currently the only supported flag is a minus sign (&lt;code&gt;-&lt;/code&gt;) which will cause the format specifier's output to be left-justified. This has no effect unless the &lt;em&gt;&lt;code&gt;width&lt;/code&gt;&lt;/em&gt; field is also specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fdddce1ec06b246bce73843e8826c300263ddb0" translate="yes" xml:space="preserve">
          <source>Additional restrictions apply when unique indexes are applied to partitioned tables; see &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;.</source>
          <target state="translated">将唯一索引应用于分区表时，还存在其他限制；参见&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9379cab208a52cab9a14d1960740e0e9980c40a5" translate="yes" xml:space="preserve">
          <source>Additional restrictions apply when unique or primary key constraints are added to partitioned tables; see &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;. Also, foreign key constraints on partitioned tables may not be declared &lt;code&gt;NOT VALID&lt;/code&gt; at present.</source>
          <target state="translated">将唯一或主键约束添加到分区表时，还会应用其他限制；参见&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;。同样，当前可能无法将分区表上的外键约束声明为 &lt;code&gt;NOT VALID&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d8765f8e8e885763ce10457dabe0ae485bb31d5b" translate="yes" xml:space="preserve">
          <source>Additional string manipulation functions are available and are listed in &lt;a href=&quot;functions-string#FUNCTIONS-STRING-OTHER&quot;&gt;Table 9.10&lt;/a&gt;. Some of them are used internally to implement the SQL-standard string functions listed in &lt;a href=&quot;functions-string#FUNCTIONS-STRING-SQL&quot;&gt;Table 9.9&lt;/a&gt;.</source>
          <target state="translated">其他字符串操作功能可用，并在&lt;a href=&quot;functions-string#FUNCTIONS-STRING-OTHER&quot;&gt;表9.10&lt;/a&gt;中列出。其中一些用于内部实现&lt;a href=&quot;functions-string#FUNCTIONS-STRING-SQL&quot;&gt;表9.9中&lt;/a&gt;列出的SQL标准字符串函数。</target>
        </trans-unit>
        <trans-unit id="010f13497a3e5b588a77355b773385544bc33904" translate="yes" xml:space="preserve">
          <source>Additional updates were made by Joshua Reich &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:josh@root.net&quot;&gt;josh@root.net&lt;/a&gt;&amp;gt;&lt;/code&gt; in July 2006. These include &lt;code&gt;cube(float8[], float8[])&lt;/code&gt; and cleaning up the code to use the V1 call protocol instead of the deprecated V0 protocol.</source>
          <target state="translated">Joshua Reich &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:josh@root.net&quot;&gt;josh@root.net&lt;/a&gt;&amp;gt;&lt;/code&gt; 在2006年7月进行了其他更新。这些更新包括 &lt;code&gt;cube(float8[], float8[])&lt;/code&gt; 并清理代码以使用V1调用协议而不是已弃用的V0协议。</target>
        </trans-unit>
        <trans-unit id="a5f30130c7eb4575fcc776243da7a4179d9cf6f4" translate="yes" xml:space="preserve">
          <source>Additional, more detailed, description of the parameter</source>
          <target state="translated">更多、更详细的参数说明</target>
        </trans-unit>
        <trans-unit id="f10aed98f8a0fbbcdcab810e37d64419e4b89806" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;em&gt;comments&lt;/em&gt; can occur in SQL input. They are not tokens, they are effectively equivalent to whitespace.</source>
          <target state="translated">此外，SQL输入中可能会出现&lt;em&gt;注释&lt;/em&gt;。它们不是令牌，实际上等效于空格。</target>
        </trans-unit>
        <trans-unit id="3ce7d7c047715fd1454a60e6f8ab9c8a858ce3b2" translate="yes" xml:space="preserve">
          <source>Additionally, an alias is required if the table reference is a subquery (see &lt;a href=&quot;queries-table-expressions#QUERIES-SUBQUERIES&quot;&gt;Section 7.2.1.3&lt;/a&gt;).</source>
          <target state="translated">另外，如果表引用是子查询，则需要别名（请参见&lt;a href=&quot;queries-table-expressions#QUERIES-SUBQUERIES&quot;&gt;7.2.1.3节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2987436262917a5192b10eeed405ee0544038a4c" translate="yes" xml:space="preserve">
          <source>Additionally, if a query usually requires an implicit conversion for a function, and if then the user defines a new function with the correct argument types, the parser should use this new function and no longer do implicit conversion to use the old function.</source>
          <target state="translated">另外,如果一个查询通常需要对一个函数进行隐式转换,如果然后用户定义了一个新的函数,并有正确的参数类型,那么解析器应该使用这个新的函数,而不再做隐式转换来使用旧的函数。</target>
        </trans-unit>
        <trans-unit id="0a6ee1654a9731eebc2384fd193841ff3bb1bd0e" translate="yes" xml:space="preserve">
          <source>Additionally, if you are running PostgreSQL inside a zone, you may need to raise the zone resource usage limits as well. See &quot;Chapter2: Projects and Tasks&quot; in the &lt;em&gt;System Administrator's Guide&lt;/em&gt; for more information on &lt;code&gt;projects&lt;/code&gt; and &lt;code&gt;prctl&lt;/code&gt;.</source>
          <target state="translated">此外，如果在区域内运行PostgreSQL，则可能还需要提高区域资源使用限制。有关 &lt;code&gt;projects&lt;/code&gt; 和 &lt;code&gt;prctl&lt;/code&gt; 的更多信息，请参见《&lt;em&gt;系统管理员指南&lt;/em&gt;》中的&amp;ldquo;第二章：项目和任务&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="0aee321f704c4c1848fccdf5704c469a83987cc5" translate="yes" xml:space="preserve">
          <source>Additionally, refresh options as described under &lt;code&gt;REFRESH PUBLICATION&lt;/code&gt; may be specified.</source>
          <target state="translated">此外，可以指定&amp;ldquo; &lt;code&gt;REFRESH PUBLICATION&lt;/code&gt; 所述的刷新选项。</target>
        </trans-unit>
        <trans-unit id="78567ce71a3b54c604529593f06074abcf105927" translate="yes" xml:space="preserve">
          <source>Additionally, the SQL standard collation name &lt;code&gt;ucs_basic&lt;/code&gt; is available for encoding &lt;code&gt;UTF8&lt;/code&gt;. It is equivalent to &lt;code&gt;C&lt;/code&gt; and sorts by Unicode code point.</source>
          <target state="translated">此外，SQL标准排序规则名称 &lt;code&gt;ucs_basic&lt;/code&gt; 可用于编码 &lt;code&gt;UTF8&lt;/code&gt; 。它等效于 &lt;code&gt;C&lt;/code&gt; ,并按Unicode代码点排序。</target>
        </trans-unit>
        <trans-unit id="53f8119d06cd2559361245d09ce9820bdfc91e36" translate="yes" xml:space="preserve">
          <source>Adds an offset to an address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5aedd449033d6b8107ae365cb24a243a1adca0c" translate="yes" xml:space="preserve">
          <source>Adds collations to the system catalog &lt;code&gt;pg_collation&lt;/code&gt; based on all the locales it finds in the operating system. This is what &lt;code&gt;initdb&lt;/code&gt; uses; see &lt;a href=&quot;collation#COLLATION-MANAGING&quot;&gt;Section 23.2.2&lt;/a&gt; for more details. If additional locales are installed into the operating system later on, this function can be run again to add collations for the new locales. Locales that match existing entries in &lt;code&gt;pg_collation&lt;/code&gt; will be skipped. (But collation objects based on locales that are no longer present in the operating system are not removed by this function.) The &lt;em&gt;&lt;code&gt;schema&lt;/code&gt;&lt;/em&gt; parameter would typically be &lt;code&gt;pg_catalog&lt;/code&gt;, but that is not a requirement; the collations could be installed into some other schema as well. The function returns the number of new collation objects it created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e874368d9d21cc7beffa67760d80cf1b272a6209" translate="yes" xml:space="preserve">
          <source>Adds element to end of array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36522cf2f752a15facac71afeb7f67a4b36db952" translate="yes" xml:space="preserve">
          <source>Adds the coordinates of the second &lt;code&gt;point&lt;/code&gt; to those of each point of the first argument, thus performing translation. Available for &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;path&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3c767351a24f76f0563dcac6f0be4bd35c8869c" translate="yes" xml:space="preserve">
          <source>Adjust interval so 24-hour time periods are represented as days</source>
          <target state="translated">调整时间间隔,使24小时时间段以天数表示。</target>
        </trans-unit>
        <trans-unit id="7279c011b0d2f4cdb22e6caf6d21633e1e395dfa" translate="yes" xml:space="preserve">
          <source>Adjust interval so 30-day time periods are represented as months</source>
          <target state="translated">调整时间间隔,使30天的时间段以月来表示。</target>
        </trans-unit>
        <trans-unit id="0d09f290462815bf94d7d19b5220a29471c8dd87" translate="yes" xml:space="preserve">
          <source>Adjust interval using &lt;code&gt;justify_days&lt;/code&gt; and &lt;code&gt;justify_hours&lt;/code&gt;, with additional sign adjustments</source>
          <target state="translated">使用 &lt;code&gt;justify_days&lt;/code&gt; 和 &lt;code&gt;justify_hours&lt;/code&gt; 调整间隔，并进行其他符号调整</target>
        </trans-unit>
        <trans-unit id="d5274237f32eaf0cd335b0f45d9e9e406fe2937c" translate="yes" xml:space="preserve">
          <source>Adjust temperature entries and reset precipitation to its default value in one row of the table &lt;code&gt;weather&lt;/code&gt;:</source>
          <target state="translated">调整温度条目并将表 &lt;code&gt;weather&lt;/code&gt; 一行中的降水重置为默认值：</target>
        </trans-unit>
        <trans-unit id="597cf96132dd221de223e71df7ddc2feda8ca0e0" translate="yes" xml:space="preserve">
          <source>Adjustable printing options are:</source>
          <target state="translated">可调整的打印选项有:</target>
        </trans-unit>
        <trans-unit id="b8be3d1264310c3b8c848d4b90d5206179a40cc4" translate="yes" xml:space="preserve">
          <source>Administration</source>
          <target state="translated">Administration</target>
        </trans-unit>
        <trans-unit id="25a6044596d068aa8f0b03a3756a046b4662f84e" translate="yes" xml:space="preserve">
          <source>Administration Functions</source>
          <target state="translated">行政职能</target>
        </trans-unit>
        <trans-unit id="9ff417ada04d397f658792af845a2743c3df515c" translate="yes" xml:space="preserve">
          <source>Administrators can grant access to these roles to users using the &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; command, for example:</source>
          <target state="translated">管理员可以使用&lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt;命令向用户授予对这些角色的访问权限，例如：</target>
        </trans-unit>
        <trans-unit id="5748ca9fbce0c666d06fe84d7811e46cfd6b343d" translate="yes" xml:space="preserve">
          <source>Advance sequence and return new value</source>
          <target state="translated">顺序前进并返回新值</target>
        </trans-unit>
        <trans-unit id="4d638e9190ad6b08f1c75c8684e03ac19dde11c0" translate="yes" xml:space="preserve">
          <source>Advance the sequence object to its next value and return that value. This is done atomically: even if multiple sessions execute &lt;code&gt;nextval&lt;/code&gt; concurrently, each will safely receive a distinct sequence value.</source>
          <target state="translated">将序列对象前进到下一个值，然后返回该值。这是原子完成的：即使多个会话同时执行 &lt;code&gt;nextval&lt;/code&gt; ，每个会话也将安全地接收不同的序列值。</target>
        </trans-unit>
        <trans-unit id="05743e363937b509ed8a8c4f9befec86cf089852" translate="yes" xml:space="preserve">
          <source>Advanced Configuration and Power Interface (ACPI) provides a Power Management (PM) Timer, which Linux refers to as the acpi_pm. The clock derived from acpi_pm will at best provide 300 nanosecond resolution.</source>
          <target state="translated">高级配置和电源接口(ACPI)提供了一个电源管理(PM)定时器,Linux将其称为acpi_pm。由acpi_pm导出的时钟最多只能提供300纳秒的分辨率。</target>
        </trans-unit>
        <trans-unit id="96731dbaea6a5720dd33b64dc334ff765eec736a" translate="yes" xml:space="preserve">
          <source>Advanced Features</source>
          <target state="translated">高级功能</target>
        </trans-unit>
        <trans-unit id="40fdbd870880a4ac68ea44233cfb9a2306bc99de" translate="yes" xml:space="preserve">
          <source>Advanced users can use regular-expression notations such as character classes, for example &lt;code&gt;[0-9]&lt;/code&gt; to match any digit. All regular expression special characters work as specified in &lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;Section 9.7.3&lt;/a&gt;, except for &lt;code&gt;.&lt;/code&gt; which is taken as a separator as mentioned above, &lt;code&gt;*&lt;/code&gt; which is translated to the regular-expression notation &lt;code&gt;.*&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt; which is translated to &lt;code&gt;.&lt;/code&gt;, and &lt;code&gt;$&lt;/code&gt; which is matched literally. You can emulate these pattern characters at need by writing &lt;code&gt;?&lt;/code&gt; for &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;(R+|)&lt;/code&gt; for &lt;code&gt;R*&lt;/code&gt;, or &lt;code&gt;(R|)&lt;/code&gt; for &lt;code&gt;R?&lt;/code&gt;. &lt;code&gt;$&lt;/code&gt; is not needed as a regular-expression character since the pattern must match the whole name, unlike the usual interpretation of regular expressions (in other words, &lt;code&gt;$&lt;/code&gt; is automatically appended to your pattern). Write &lt;code&gt;*&lt;/code&gt; at the beginning and/or end if you don't wish the pattern to be anchored. Note that within double quotes, all regular expression special characters lose their special meanings and are matched literally. Also, the regular expression special characters are matched literally in operator name patterns (i.e., the argument of &lt;code&gt;\do&lt;/code&gt;).</source>
          <target state="translated">高级用户可以使用正则表达式表示法，例如字符类，例如 &lt;code&gt;[0-9]&lt;/code&gt; 来匹配任何数字。除之外，所有正则表达式特殊字符&lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;均按9.7.3节的&lt;/a&gt;规定工作 &lt;code&gt;.&lt;/code&gt; 将其作为如上所述的隔板， &lt;code&gt;*&lt;/code&gt; 它被转换为正则表达式表示法 &lt;code&gt;.*&lt;/code&gt; ， &lt;code&gt;?&lt;/code&gt; 转换为 &lt;code&gt;.&lt;/code&gt; 和 &lt;code&gt;$&lt;/code&gt; 字面匹配。您可以通过编写 &lt;code&gt;?&lt;/code&gt; 来模拟这些模式字符。为 &lt;code&gt;.&lt;/code&gt; ，对于 &lt;code&gt;R*&lt;/code&gt; &lt;code&gt;(R+|)&lt;/code&gt; 还是对于 &lt;code&gt;R?&lt;/code&gt; 是 &lt;code&gt;(R|)&lt;/code&gt; ？。 &lt;code&gt;$&lt;/code&gt; 不需要$作为正则表达式字符，因为该模式必须与整个名称匹配，这与对常规表达式的通常解释不同（换句话说， &lt;code&gt;$&lt;/code&gt; 自动添加到您的模式）。写 &lt;code&gt;*&lt;/code&gt; 在开始和/或结束，如果你不希望的方式被锚定。请注意，在双引号中，所有正则表达式特殊字符都会失去其特殊含义，并且会在字面上匹配。同样，正则表达式特殊字符在运算符名称模式（即 &lt;code&gt;\do&lt;/code&gt; 的参数）中按字面值进行匹配。</target>
        </trans-unit>
        <trans-unit id="ae1d5d5862d5067d5253f55fa2d10173937d4fc6" translate="yes" xml:space="preserve">
          <source>Advances the current confirmed position of a replication slot named &lt;em&gt;&lt;code&gt;slot_name&lt;/code&gt;&lt;/em&gt;. The slot will not be moved backwards, and it will not be moved beyond the current insert location. Returns name of the slot and real position to which it was advanced to.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;slot_name&lt;/code&gt; &lt;/em&gt;名为&lt;em&gt;slot_name&lt;/em&gt;的复制插槽的当前确认位置。该插槽不会向后移动，也不会移动到当前插入位置之外。返回广告位的名称以及广告位的实际位置。</target>
        </trans-unit>
        <trans-unit id="3d5aab029628974dd5c58605edc8a94526445808" translate="yes" xml:space="preserve">
          <source>Advances the current confirmed position of a replication slot named &lt;em&gt;&lt;code&gt;slot_name&lt;/code&gt;&lt;/em&gt;. The slot will not be moved backwards, and it will not be moved beyond the current insert location. Returns the name of the slot and the actual position that it was advanced to. The updated slot position information is written out at the next checkpoint if any advancing is done. So in the event of a crash, the slot may return to an earlier position.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58c81d024a1ba21f51051976ec1e66bb25143e15" translate="yes" xml:space="preserve">
          <source>Advances the sequence object to its next value and returns that value. This is done atomically: even if multiple sessions execute &lt;code&gt;nextval&lt;/code&gt; concurrently, each will safely receive a distinct sequence value. If the sequence object has been created with default parameters, successive &lt;code&gt;nextval&lt;/code&gt; calls will return successive values beginning with 1. Other behaviors can be obtained by using appropriate parameters in the &lt;a href=&quot;sql-createsequence&quot;&gt;CREATE SEQUENCE&lt;/a&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d323581d870eb70c61501cdd5933132dd855a86" translate="yes" xml:space="preserve">
          <source>Advisory locks can be acquired on keys consisting of either a single &lt;code&gt;bigint&lt;/code&gt; value or two integer values. A &lt;code&gt;bigint&lt;/code&gt; key is displayed with its high-order half in the &lt;code&gt;classid&lt;/code&gt; column, its low-order half in the &lt;code&gt;objid&lt;/code&gt; column, and &lt;code&gt;objsubid&lt;/code&gt; equal to 1. The original &lt;code&gt;bigint&lt;/code&gt; value can be reassembled with the expression &lt;code&gt;(classid::bigint &amp;lt;&amp;lt; 32) | objid::bigint&lt;/code&gt;. Integer keys are displayed with the first key in the &lt;code&gt;classid&lt;/code&gt; column, the second key in the &lt;code&gt;objid&lt;/code&gt; column, and &lt;code&gt;objsubid&lt;/code&gt; equal to 2. The actual meaning of the keys is up to the user. Advisory locks are local to each database, so the &lt;code&gt;database&lt;/code&gt; column is meaningful for an advisory lock.</source>
          <target state="translated">可以在由单个 &lt;code&gt;bigint&lt;/code&gt; 值或两个整数值组成的键上获取咨询锁。将显示一个 &lt;code&gt;bigint&lt;/code&gt; 键，其 &lt;code&gt;classid&lt;/code&gt; 列中的高位一半， &lt;code&gt;objid&lt;/code&gt; 列中的低位一半，以及 &lt;code&gt;objsubid&lt;/code&gt; 等于1。原始 &lt;code&gt;bigint&lt;/code&gt; 值可以用表达式重新组装 &lt;code&gt;(classid::bigint &amp;lt;&amp;lt; 32) | objid::bigint&lt;/code&gt; 。显示整数键，第一个键在 &lt;code&gt;classid&lt;/code&gt; 列中，第二个键在 &lt;code&gt;objid&lt;/code&gt; 列中，并且 &lt;code&gt;objsubid&lt;/code&gt; 等于2。这些键的实际含义取决于用户。咨询锁对于每个数据库都是本地的，因此 &lt;code&gt;database&lt;/code&gt; 列对于咨询锁意义重大。</target>
        </trans-unit>
        <trans-unit id="f6c29c3eec39081073449cf551f29f5ff2063ec1" translate="yes" xml:space="preserve">
          <source>Advisory locks work normally in recovery, including deadlock detection. Note that advisory locks are never WAL logged, so it is impossible for an advisory lock on either the primary or the standby to conflict with WAL replay. Nor is it possible to acquire an advisory lock on the primary and have it initiate a similar advisory lock on the standby. Advisory locks relate only to the server on which they are acquired.</source>
          <target state="translated">咨询锁在恢复中正常工作,包括死锁检测。请注意,咨询锁永远不会被WAL记录,因此主设备或备用设备上的咨询锁不可能与WAL重放发生冲突。也不可能在主设备上获得一个咨询锁,并让它在备用设备上启动一个类似的咨询锁。咨询锁只与获得咨询锁的服务器有关。</target>
        </trans-unit>
        <trans-unit id="87db6f29dc76387bbaab5ded1909ba41ea3e370f" translate="yes" xml:space="preserve">
          <source>After a checkpoint has been made and the log flushed, the checkpoint's position is saved in the file &lt;code&gt;pg_control&lt;/code&gt;. Therefore, at the start of recovery, the server first reads &lt;code&gt;pg_control&lt;/code&gt; and then the checkpoint record; then it performs the REDO operation by scanning forward from the log location indicated in the checkpoint record. Because the entire content of data pages is saved in the log on the first page modification after a checkpoint (assuming &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; is not disabled), all pages changed since the checkpoint will be restored to a consistent state.</source>
          <target state="translated">建立检查点并刷新日志后，检查点的位置将保存在文件 &lt;code&gt;pg_control&lt;/code&gt; 中。因此，在恢复开始时，服务器首先读取 &lt;code&gt;pg_control&lt;/code&gt; ，然后读取检查点记录。然后它通过从检查点记录中指示的日志位置向前扫描来执行REDO操作。因为数据页的全部内容都在检查点之后保存在第一个页面修改的日志中（假设未禁用&lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt;），所以自检查点以来所有已更改的页面都将恢复为一致状态。</target>
        </trans-unit>
        <trans-unit id="c70bb87984515ab084a4a6675924bc032765ff87" translate="yes" xml:space="preserve">
          <source>After a commit record has been written to disk on the primary, the WAL record is then sent to the standby. The standby sends reply messages each time a new batch of WAL data is written to disk, unless &lt;code&gt;wal_receiver_status_interval&lt;/code&gt; is set to zero on the standby. In the case that &lt;code&gt;synchronous_commit&lt;/code&gt; is set to &lt;code&gt;remote_apply&lt;/code&gt;, the standby sends reply messages when the commit record is replayed, making the transaction visible. If the standby is chosen as a synchronous standby, according to the setting of &lt;code&gt;synchronous_standby_names&lt;/code&gt; on the primary, the reply messages from that standby will be considered along with those from other synchronous standbys to decide when to release transactions waiting for confirmation that the commit record has been received. These parameters allow the administrator to specify which standby servers should be synchronous standbys. Note that the configuration of synchronous replication is mainly on the master. Named standbys must be directly connected to the master; the master knows nothing about downstream standby servers using cascaded replication.</source>
          <target state="translated">将提交记录写入主磁盘上的磁盘后，WAL记录将被发送到备用数据库。每当新一批WAL数据写入磁盘时，备用数据库都会发送答复消息，除非在备用 &lt;code&gt;wal_receiver_status_interval&lt;/code&gt; 设置为零。在这种情况下 &lt;code&gt;synchronous_commit&lt;/code&gt; 设置为 &lt;code&gt;remote_apply&lt;/code&gt; ，待机时会发送提交记录重放回复消息，使得交易可见。如果选择备用数据库作为同步备用数据库，则根据 &lt;code&gt;synchronous_standby_names&lt;/code&gt; 的设置在主数据库上，将考虑来自该备用数据库的答复消息以及来自其他同步备用数据库的答复消息，以决定何时释放事务以等待确认已收到提交记录。这些参数使管理员可以指定哪些备用服务器应为同步备用服务器。请注意，同步复制的配置主要在主服务器上。命名备用数据库必须直接连接到主数据库；主服务器对使用级联复制的下游备用服务器一无所知。</target>
        </trans-unit>
        <trans-unit id="94241391dfbbfde4a951b39750ed3743aeb3267e" translate="yes" xml:space="preserve">
          <source>After a query has produced an output table (after the select list has been processed) it can optionally be sorted. If sorting is not chosen, the rows will be returned in an unspecified order. The actual order in that case will depend on the scan and join plan types and the order on disk, but it must not be relied on. A particular output ordering can only be guaranteed if the sort step is explicitly chosen.</source>
          <target state="translated">在查询产生一个输出表后(在选择列表被处理后),可以选择对其进行排序。如果不选择排序,则行将以未指定的顺序返回。在这种情况下,实际的顺序将取决于扫描和连接计划类型以及磁盘上的顺序,但一定不能依赖它。只有明确选择了排序步骤,才能保证特定的输出顺序。</target>
        </trans-unit>
        <trans-unit id="3b97640c2ecb0afe6be98ec8bef630298c29b1bf" translate="yes" xml:space="preserve">
          <source>After a sequence is created, you use the functions &lt;code&gt;nextval&lt;/code&gt;, &lt;code&gt;currval&lt;/code&gt;, and &lt;code&gt;setval&lt;/code&gt; to operate on the sequence. These functions are documented in &lt;a href=&quot;functions-sequence&quot;&gt;Section 9.16&lt;/a&gt;.</source>
          <target state="translated">创建序列后，您可以使用 &lt;code&gt;nextval&lt;/code&gt; ， &lt;code&gt;currval&lt;/code&gt; 和 &lt;code&gt;setval&lt;/code&gt; 函数对序列进行操作。这些功能记录在&lt;a href=&quot;functions-sequence&quot;&gt;第9.16节中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ff749f2ca9f8a705af6bd96ce00013a3fb590b4b" translate="yes" xml:space="preserve">
          <source>After a sequence is created, you use the functions &lt;code&gt;nextval&lt;/code&gt;, &lt;code&gt;currval&lt;/code&gt;, and &lt;code&gt;setval&lt;/code&gt; to operate on the sequence. These functions are documented in &lt;a href=&quot;functions-sequence&quot;&gt;Section 9.17&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc6fe30bfc047dc5821b58053e75c58c27a7d060" translate="yes" xml:space="preserve">
          <source>After a successful rewind, the state of the target data directory is analogous to a base backup of the source data directory. Unlike taking a new base backup or using a tool like rsync, pg_rewind does not require comparing or copying unchanged relation blocks in the cluster. Only changed blocks from existing relation files are copied; all other files, including new relation files, configuration files, and WAL segments, are copied in full. As such the rewind operation is significantly faster than other approaches when the database is large and only a small fraction of blocks differ between the clusters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc113f99607193995354648154db9d5489f2fd2b" translate="yes" xml:space="preserve">
          <source>After an index is created, the system has to keep it synchronized with the table. This adds overhead to data manipulation operations. Therefore indexes that are seldom or never used in queries should be removed.</source>
          <target state="translated">索引创建后,系统必须保持它与表的同步。这就增加了数据处理操作的开销。因此在查询中很少或从不使用的索引应该被删除。</target>
        </trans-unit>
        <trans-unit id="07e3f54a730eab0090b9f9763615353b60509ba8" translate="yes" xml:space="preserve">
          <source>After completing the tests, it's recommended you disable the &lt;code&gt;sepgsql_regression_test_mode&lt;/code&gt; parameter:</source>
          <target state="translated">完成测试后，建议您禁用 &lt;code&gt;sepgsql_regression_test_mode&lt;/code&gt; 参数：</target>
        </trans-unit>
        <trans-unit id="b07e5c0448618c87913bcee1323b05d5b460e37c" translate="yes" xml:space="preserve">
          <source>After creating partitions of &lt;code&gt;measurement_y2006m02&lt;/code&gt;, any data inserted into &lt;code&gt;measurement&lt;/code&gt; that is mapped to &lt;code&gt;measurement_y2006m02&lt;/code&gt; (or data that is directly inserted into &lt;code&gt;measurement_y2006m02&lt;/code&gt;, provided it satisfies its partition constraint) will be further redirected to one of its partitions based on the &lt;code&gt;peaktemp&lt;/code&gt; column. The partition key specified may overlap with the parent's partition key, although care should be taken when specifying the bounds of a sub-partition such that the set of data it accepts constitutes a subset of what the partition's own bounds allows; the system does not try to check whether that's really the case.</source>
          <target state="translated">在创建了 &lt;code&gt;measurement_y2006m02&lt;/code&gt; 的分区之后，任何插入到 &lt;code&gt;measurement&lt;/code&gt; ，映射到 &lt;code&gt;measurement_y2006m02&lt;/code&gt; 的数据（或直接插入到 &lt;code&gt;measurement_y2006m02&lt;/code&gt; 的数据，只要满足其分区约束）将基于 &lt;code&gt;peaktemp&lt;/code&gt; 列进一步重定向到其分区之一。指定的分区键可能与父分区的分区键重叠，尽管在指定子分区的边界时应格外小心，以使其接受的数据集构成该分区自身边界所允许的子集。系统不会尝试检查是否确实如此。</target>
        </trans-unit>
        <trans-unit id="db536621da1a6c52f06af534df944428be135246" translate="yes" xml:space="preserve">
          <source>After creating the function, we create a trigger which calls the trigger function:</source>
          <target state="translated">创建函数后,我们创建一个触发器,调用触发函数。</target>
        </trans-unit>
        <trans-unit id="c393be77ecb9862e06e4a42080ca1b8d309670b1" translate="yes" xml:space="preserve">
          <source>After modifying that file, a reboot is required for the new settings to take effect.</source>
          <target state="translated">修改该文件后,需要重新启动,新设置才能生效。</target>
        </trans-unit>
        <trans-unit id="c876187243218ed419e1b156be87fd9454c80ab8" translate="yes" xml:space="preserve">
          <source>After passing the &lt;code&gt;WHERE&lt;/code&gt; filter, the derived input table might be subject to grouping, using the &lt;code&gt;GROUP BY&lt;/code&gt; clause, and elimination of group rows using the &lt;code&gt;HAVING&lt;/code&gt; clause.</source>
          <target state="translated">传递 &lt;code&gt;WHERE&lt;/code&gt; 筛选器后，派生的输入表可能使用 &lt;code&gt;GROUP BY&lt;/code&gt; 子句进行分组，并使用 &lt;code&gt;HAVING&lt;/code&gt; 子句消除组行。</target>
        </trans-unit>
        <trans-unit id="476a32ba88141aeb970e81601edc2ee511e8c4b9" translate="yes" xml:space="preserve">
          <source>After reaching the end of valid WAL, keep polling once per second for new WAL to appear.</source>
          <target state="translated">在有效的WAL结束后,继续每秒进行一次投票,等待新的WAL出现。</target>
        </trans-unit>
        <trans-unit id="fd721ac53a17faa8b9db323757ed059c923d71fc" translate="yes" xml:space="preserve">
          <source>After recompiling and running the new binary, check that your newly added probe is available by executing the following DTrace command. You should see similar output:</source>
          <target state="translated">重新编译并运行新的二进制文件后,通过执行以下 DTrace 命令检查新添加的探针是否可用。您应该会看到类似的输出。</target>
        </trans-unit>
        <trans-unit id="c206de8ceae00b19b0bbd697b5fe278bf3d62023" translate="yes" xml:space="preserve">
          <source>After restoring a backup, it is wise to run &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; on each database so the query optimizer has useful statistics; see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Section 24.1.3&lt;/a&gt; and &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information. For more advice on how to load large amounts of data into PostgreSQL efficiently, refer to &lt;a href=&quot;populate&quot;&gt;Section 14.4&lt;/a&gt;.</source>
          <target state="translated">还原备份后，明智的做法是在每个数据库上运行&lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt;，以便查询优化器具有有用的统计信息。有关更多信息，请参见&lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;第24.1.3节&lt;/a&gt;和&lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;第24.1.6节&lt;/a&gt;。有关如何有效地将大量数据有效加载到PostgreSQL的更多建议，请参见&lt;a href=&quot;populate&quot;&gt;14.4节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="417976bf060ad8e20656ba39a451c14e19b1e474" translate="yes" xml:space="preserve">
          <source>After rolling back to a savepoint, it continues to be defined, so you can roll back to it several times. Conversely, if you are sure you won't need to roll back to a particular savepoint again, it can be released, so the system can free some resources. Keep in mind that either releasing or rolling back to a savepoint will automatically release all savepoints that were defined after it.</source>
          <target state="translated">回滚到一个保存点后,它将继续被定义,所以你可以多次回滚到它。相反,如果您确定不需要再次回滚到某个保存点,可以释放它,这样系统就可以释放一些资源。请记住,无论是释放还是回滚到一个保存点,都会自动释放在它之后定义的所有保存点。</target>
        </trans-unit>
        <trans-unit id="39ee00792319dcfa46ab74c067181f9cb4e42b47" translate="yes" xml:space="preserve">
          <source>After running pg_rewind, WAL replay needs to complete for the data directory to be in a consistent state. When the target server is started again it will enter archive recovery and replay all WAL generated in the source server from the last checkpoint before the point of divergence. If some of the WAL was no longer available in the source server when pg_rewind was run, and therefore could not be copied by the pg_rewind session, it must be made available when the target server is started. This can be done by creating a &lt;code&gt;recovery.signal&lt;/code&gt; file in the target data directory and by configuring a suitable &lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;restore_command&lt;/a&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2cf5063e2afd451a505eeabbaaa31e6dea2f166" translate="yes" xml:space="preserve">
          <source>After running this command, it should be possible to start the server, but bear in mind that the database might contain inconsistent data due to partially-committed transactions. You should immediately dump your data, run &lt;code&gt;initdb&lt;/code&gt;, and reload. After reload, check for inconsistencies and repair as needed.</source>
          <target state="translated">运行此命令后，应该可以启动服务器，但是请记住，由于部分提交的事务，数据库可能包含不一致的数据。您应该立即转储数据，运行 &lt;code&gt;initdb&lt;/code&gt; ，然后重新加载。重新加载后，请检查是否存在不一致之处，并根据需要进行维修。</target>
        </trans-unit>
        <trans-unit id="f1751e378d5c61831bc66381dd026a28d4a7604f" translate="yes" xml:space="preserve">
          <source>After the &lt;code&gt;auth-method&lt;/code&gt; field, there can be field(s) of the form &lt;code&gt;name&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;value&lt;/code&gt; that specify options for the authentication method. Details about which options are available for which authentication methods appear below.</source>
          <target state="translated">在 &lt;code&gt;auth-method&lt;/code&gt; 字段之后，可以存在形式为 &lt;code&gt;name&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; 的字段，这些字段指定身份验证方法的选项。下面显示有关哪些身份验证方法可用的选项的详细信息。</target>
        </trans-unit>
        <trans-unit id="129d74f6272df45af1d745e991e7a73feebafe5a" translate="yes" xml:space="preserve">
          <source>After the processing of the &lt;code&gt;FROM&lt;/code&gt; clause is done, each row of the derived virtual table is checked against the search condition. If the result of the condition is true, the row is kept in the output table, otherwise (i.e., if the result is false or null) it is discarded. The search condition typically references at least one column of the table generated in the &lt;code&gt;FROM&lt;/code&gt; clause; this is not required, but otherwise the &lt;code&gt;WHERE&lt;/code&gt; clause will be fairly useless.</source>
          <target state="translated">在完成 &lt;code&gt;FROM&lt;/code&gt; 子句的处理后，将对照搜索条件检查派生虚拟表的每一行。如果条件的结果为true，则该行保留在输出表中，否则（即，如果结果为false或null）将其丢弃。搜索条件通常引用 &lt;code&gt;FROM&lt;/code&gt; 子句中生成的表的至少一列；这不是必需的，但是否则 &lt;code&gt;WHERE&lt;/code&gt; 子句将毫无用处。</target>
        </trans-unit>
        <trans-unit id="7afbd68cfd57086d9de66444e71b66bfaedc388a" translate="yes" xml:space="preserve">
          <source>After the select list has been processed, the result table can optionally be subject to the elimination of duplicate rows. The &lt;code&gt;DISTINCT&lt;/code&gt; key word is written directly after &lt;code&gt;SELECT&lt;/code&gt; to specify this:</source>
          <target state="translated">处理选择列表后，结果表可以选择消除重复的行。该 &lt;code&gt;DISTINCT&lt;/code&gt; 关键字被写入后直接 &lt;code&gt;SELECT&lt;/code&gt; 指定这样的：</target>
        </trans-unit>
        <trans-unit id="6f94a805413e3bb85d7fa38665d29205c38f9186" translate="yes" xml:space="preserve">
          <source>After this command is executed, the index is &amp;ldquo;owned&amp;rdquo; by the constraint, in the same way as if the index had been built by a regular &lt;code&gt;ADD PRIMARY KEY&lt;/code&gt; or &lt;code&gt;ADD UNIQUE&lt;/code&gt; command. In particular, dropping the constraint will make the index disappear too.</source>
          <target state="translated">执行此命令后，索引将由约束&amp;ldquo;拥有&amp;rdquo;，就像使用常规 &lt;code&gt;ADD PRIMARY KEY&lt;/code&gt; 或 &lt;code&gt;ADD UNIQUE&lt;/code&gt; 命令构建索引一样。特别是，删除约束将使索引也消失。</target>
        </trans-unit>
        <trans-unit id="5a54a1d7a070e112cd3e777d9befed8de7b72e73" translate="yes" xml:space="preserve">
          <source>Again connect to the database as a user with rights to run pg_stop_backup (superuser, or a user who has been granted EXECUTE on the function), and issue the command:</source>
          <target state="translated">再次以有权限运行pg_stop_backup的用户(超级用户,或被授予函数EXECUTE权限的用户)连接到数据库,并发出命令。</target>
        </trans-unit>
        <trans-unit id="89c328b5eae1533574b7b6b9cb4641c91474c438" translate="yes" xml:space="preserve">
          <source>Again the planner examines the &lt;code&gt;WHERE&lt;/code&gt; clause condition and looks up the selectivity function for &lt;code&gt;=&lt;/code&gt;, which is &lt;code&gt;eqsel&lt;/code&gt;. For equality estimation the histogram is not useful; instead the list of &lt;em&gt;most common values&lt;/em&gt; (MCVs) is used to determine the selectivity. Let's have a look at the MCVs, with some additional columns that will be useful later:</source>
          <target state="translated">再次规划器检查 &lt;code&gt;WHERE&lt;/code&gt; 子句的条件和查找该选择性功能 &lt;code&gt;=&lt;/code&gt; ，这是 &lt;code&gt;eqsel&lt;/code&gt; 。对于相等性估计，直方图没有用；而是使用&lt;em&gt;最常用值&lt;/em&gt;（MCV）列表确定选择性。让我们看一下MCV，其中还有一些其他列，这些列以后将有用：</target>
        </trans-unit>
        <trans-unit id="4c27783eb44bcd1d4c219fa9ccfc28e663471099" translate="yes" xml:space="preserve">
          <source>Again, a more realistic example:</source>
          <target state="translated">再举一个比较现实的例子。</target>
        </trans-unit>
        <trans-unit id="6c1eea13275ab96326295feeff11f71292c224b0" translate="yes" xml:space="preserve">
          <source>Again, a table alias is required. Assigning alias names to the columns of the &lt;code&gt;VALUES&lt;/code&gt; list is optional, but is good practice. For more information see &lt;a href=&quot;queries-values&quot;&gt;Section 7.7&lt;/a&gt;.</source>
          <target state="translated">同样，需要表别名。为 &lt;code&gt;VALUES&lt;/code&gt; 列表的列分配别名是可选的，但这是一种好习惯。有关更多信息，请参见&lt;a href=&quot;queries-values&quot;&gt;第7.7节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fa2e8717405811a7aefb85de6cf3250083c52ac2" translate="yes" xml:space="preserve">
          <source>Again, note that some of these commands are actually allowed during &quot;read only&quot; mode transactions on the primary.</source>
          <target state="translated">同样,请注意这些命令中的某些命令实际上是在主服务器上的 &quot;只读 &quot;模式事务中被允许的。</target>
        </trans-unit>
        <trans-unit id="d75929b4f5b2f824a7a07da4899bf1820357b131" translate="yes" xml:space="preserve">
          <source>Again, see &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt; for more detail.</source>
          <target state="translated">同样，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;第12章&lt;/a&gt;以获取更多详细信息。</target>
        </trans-unit>
        <trans-unit id="8820b9fd552bc40289d6bbf23d466ae2aeb85fb1" translate="yes" xml:space="preserve">
          <source>Again, see &lt;a href=&quot;https://www.postgresql.org/docs/13/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt; for more detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73c2d4672afb28ef558326e3d56d8e571d70b6fe" translate="yes" xml:space="preserve">
          <source>Again, the argument &lt;code&gt;uppercase&lt;/code&gt; was omitted so it is set to &lt;code&gt;false&lt;/code&gt; implicitly. One advantage of using named notation is that the arguments may be specified in any order, for example:</source>
          <target state="translated">同样，省略了参数 &lt;code&gt;uppercase&lt;/code&gt; ，因此将其隐式设置为 &lt;code&gt;false&lt;/code&gt; 。使用命名符号的一个优点是参数可以按任何顺序指定，例如：</target>
        </trans-unit>
        <trans-unit id="558d7aad6e94b62a3c3d222979b260b60b6db7d2" translate="yes" xml:space="preserve">
          <source>Aggregate Functions</source>
          <target state="translated">聚合函数</target>
        </trans-unit>
        <trans-unit id="644f8b99c4c1166b7dd3dea3ff097223a8e3390b" translate="yes" xml:space="preserve">
          <source>Aggregate function (routine)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78066b1c350419b50af4d9f199ab1be3ff9a7bd9" translate="yes" xml:space="preserve">
          <source>Aggregate functions are an extension.</source>
          <target state="translated">聚合函数是一种扩展。</target>
        </trans-unit>
        <trans-unit id="871c4bc7e83d3ebb5166fa9fb4f5c7870dcdec31" translate="yes" xml:space="preserve">
          <source>Aggregate functions that support &lt;em&gt;Partial Mode&lt;/em&gt; are eligible to participate in various optimizations, such as parallel aggregation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41c2d9b93a1fb3de5a512eb3000462da32b26df8" translate="yes" xml:space="preserve">
          <source>Aggregate functions which support &lt;em&gt;Partial Mode&lt;/em&gt; are eligible to participate in various optimizations, such as parallel aggregation.</source>
          <target state="translated">支持&lt;em&gt;部分模式的&lt;/em&gt;聚合函数有资格参与各种优化，例如并行聚合。</target>
        </trans-unit>
        <trans-unit id="90d68cd3e256fbe87b23e489f9c82e0bca666a22" translate="yes" xml:space="preserve">
          <source>Aggregate functions, if any are used, are computed across all rows making up each group, producing a separate value for each group. (If there are aggregate functions but no &lt;code&gt;GROUP BY&lt;/code&gt; clause, the query is treated as having a single group comprising all the selected rows.) The set of rows fed to each aggregate function can be further filtered by attaching a &lt;code&gt;FILTER&lt;/code&gt; clause to the aggregate function call; see &lt;a href=&quot;sql-expressions#SYNTAX-AGGREGATES&quot;&gt;Section 4.2.7&lt;/a&gt; for more information. When a &lt;code&gt;FILTER&lt;/code&gt; clause is present, only those rows matching it are included in the input to that aggregate function.</source>
          <target state="translated">汇总函数（如果有的话）在组成每个组的所有行中进行计算，从而为每个组生成单独的值。（如果有聚合函数但没有 &lt;code&gt;GROUP BY&lt;/code&gt; 子句，则该查询被视为具有包含所有选定行的单个组。）可以通过将 &lt;code&gt;FILTER&lt;/code&gt; 子句附加到聚合函数来进一步过滤馈给每个聚合函数的行集。呼叫; 有关更多信息，请参见&lt;a href=&quot;sql-expressions#SYNTAX-AGGREGATES&quot;&gt;第4.2.7节&lt;/a&gt;。如果存在 &lt;code&gt;FILTER&lt;/code&gt; 子句，则只有与之匹配的行才包含在该聚合函数的输入中。</target>
        </trans-unit>
        <trans-unit id="cbff25b6bf81504908e5320d1af957a7ec74d3b6" translate="yes" xml:space="preserve">
          <source>Aggregate kind: &lt;code&gt;n&lt;/code&gt; for &amp;ldquo;normal&amp;rdquo; aggregates, &lt;code&gt;o&lt;/code&gt; for &amp;ldquo;ordered-set&amp;rdquo; aggregates, or &lt;code&gt;h&lt;/code&gt; for &amp;ldquo;hypothetical-set&amp;rdquo; aggregates</source>
          <target state="translated">集合类型： &lt;code&gt;n&lt;/code&gt; 代表&amp;ldquo;正常&amp;rdquo;集合， &lt;code&gt;o&lt;/code&gt; 代表&amp;ldquo;有序集合&amp;rdquo;集合， &lt;code&gt;h&lt;/code&gt; 代表&amp;ldquo;假设集合&amp;rdquo;集合</target>
        </trans-unit>
        <trans-unit id="113588f464cd4fe7bfbc7d7c65d0648a3eeb21d0" translate="yes" xml:space="preserve">
          <source>Aggregate: *</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d76c0a0d13e4564f62e4ef32c8d0ac5d3a9bd1e2" translate="yes" xml:space="preserve">
          <source>Aggregate: GROUP BY</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67fa6b402dc45ed045bd73c615623304375dc24b" translate="yes" xml:space="preserve">
          <source>Aggregate: GROUPING</source>
          <target state="translated">汇总:GROUPING</target>
        </trans-unit>
        <trans-unit id="bf655ffdd9634b84bf30927558cadb22681f9bbb" translate="yes" xml:space="preserve">
          <source>Aggregate: WITHIN GROUP</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7717151bc6adba0544d963b5ecd779cf9aefbe1" translate="yes" xml:space="preserve">
          <source>Aggregate: array_agg</source>
          <target state="translated">Aggregate:array_agg</target>
        </trans-unit>
        <trans-unit id="7671fe3f4aa646a763a41cd74b0f33b4d9825d22" translate="yes" xml:space="preserve">
          <source>Aggregate: avg</source>
          <target state="translated">合计:平均数</target>
        </trans-unit>
        <trans-unit id="9464ad790968a8c3f29976c4cecb93cf8cb97818" translate="yes" xml:space="preserve">
          <source>Aggregate: bit_and</source>
          <target state="translated">汇总:bit_and</target>
        </trans-unit>
        <trans-unit id="f4ff9c9094ce1f94db13530e24012163b5e11d40" translate="yes" xml:space="preserve">
          <source>Aggregate: bit_or</source>
          <target state="translated">总量:bit_or</target>
        </trans-unit>
        <trans-unit id="b9c262247be1030665a29ac642cf245ebfafdc8c" translate="yes" xml:space="preserve">
          <source>Aggregate: bool_and</source>
          <target state="translated">Aggregate:bool_and</target>
        </trans-unit>
        <trans-unit id="a36b04811f8dfcb04687f062eee53e188ba68218" translate="yes" xml:space="preserve">
          <source>Aggregate: bool_or</source>
          <target state="translated">Aggregate:bool_or</target>
        </trans-unit>
        <trans-unit id="6b938ae10da8a5049736d651f7bdf37fa7dd2ec6" translate="yes" xml:space="preserve">
          <source>Aggregate: corr</source>
          <target state="translated">合计:运行</target>
        </trans-unit>
        <trans-unit id="f67c8e60c07fff9ff21ed59ebe5883cf64966901" translate="yes" xml:space="preserve">
          <source>Aggregate: count</source>
          <target state="translated">合计:计数</target>
        </trans-unit>
        <trans-unit id="a535e7f27744a217a4b4ebbcc5ce09395054c24d" translate="yes" xml:space="preserve">
          <source>Aggregate: covar_pop</source>
          <target state="translated">Aggregate:covar_pop.</target>
        </trans-unit>
        <trans-unit id="e42952cf656ba58f6dfa69af76b03eb6f4865935" translate="yes" xml:space="preserve">
          <source>Aggregate: covar_samp</source>
          <target state="translated">汇总:covar_samp。</target>
        </trans-unit>
        <trans-unit id="fc5ea10421b5c30ba97731125807dc2645fb9fc1" translate="yes" xml:space="preserve">
          <source>Aggregate: cume_dist</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="affa989634b7b7f9316e718975ac524915a80100" translate="yes" xml:space="preserve">
          <source>Aggregate: cume_dist WITHIN GROUP</source>
          <target state="translated">汇总:cume_dist WITHIN GROUP。</target>
        </trans-unit>
        <trans-unit id="5413552564b5ce9858645aad9d11f00224935ffb" translate="yes" xml:space="preserve">
          <source>Aggregate: dense_rank</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ff732a0c7e39824a92acd57f902391a878f3abf" translate="yes" xml:space="preserve">
          <source>Aggregate: dense_rank WITHIN GROUP</source>
          <target state="translated">Aggregate:dense_rank WITHIN GROUP.</target>
        </trans-unit>
        <trans-unit id="8dc8d8ebf59b788e17565bab2f4948b36d249316" translate="yes" xml:space="preserve">
          <source>Aggregate: every</source>
          <target state="translated">合计:每个</target>
        </trans-unit>
        <trans-unit id="cb574ceb369d625e53cf66f30a46474ab01c8d22" translate="yes" xml:space="preserve">
          <source>Aggregate: json_agg</source>
          <target state="translated">Aggregate:json_agg</target>
        </trans-unit>
        <trans-unit id="5daf429a167bfb1204d6816cc327273b7dff3d24" translate="yes" xml:space="preserve">
          <source>Aggregate: json_object_agg</source>
          <target state="translated">Aggregate:json_object_agg。</target>
        </trans-unit>
        <trans-unit id="146ad7890c6afaeaa83cf4ce928bc658120656b5" translate="yes" xml:space="preserve">
          <source>Aggregate: jsonb_agg</source>
          <target state="translated">Aggregate:jsonb_agg</target>
        </trans-unit>
        <trans-unit id="6f7d6e6ca2d445820090cd7f314ec40d5730bd62" translate="yes" xml:space="preserve">
          <source>Aggregate: jsonb_object_agg</source>
          <target state="translated">Aggregate:jsonb_object_agg。</target>
        </trans-unit>
        <trans-unit id="65e31a82796d0cddf371f7a0ba43aa2ede594f67" translate="yes" xml:space="preserve">
          <source>Aggregate: max</source>
          <target state="translated">合计:最大</target>
        </trans-unit>
        <trans-unit id="36d81566b6da93dc64aade9617077054e335a89e" translate="yes" xml:space="preserve">
          <source>Aggregate: min</source>
          <target state="translated">合计:最小值</target>
        </trans-unit>
        <trans-unit id="4eb5d44d93ed2f2a9cdcc0ef1679955c52d6f77c" translate="yes" xml:space="preserve">
          <source>Aggregate: mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c96cf40a4dc1d8d1ea12a0b1f5bcf59364dc827" translate="yes" xml:space="preserve">
          <source>Aggregate: mode WITHIN GROUP</source>
          <target state="translated">汇总:集团内部的时尚</target>
        </trans-unit>
        <trans-unit id="3827ba089152343be605c81a6829b3adfab7a03f" translate="yes" xml:space="preserve">
          <source>Aggregate: percent_rank</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34b5e1912aa5215dcec451af73485fcbfd34b50f" translate="yes" xml:space="preserve">
          <source>Aggregate: percent_rank WITHIN GROUP</source>
          <target state="translated">汇总:%_rank WITHIN GROUP(集团内的排名)</target>
        </trans-unit>
        <trans-unit id="4071198c9c5d51f5904da94e25f898d0927a065a" translate="yes" xml:space="preserve">
          <source>Aggregate: percentile_cont</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d40010d0c71e89dc5a258e985609a24fad7370a" translate="yes" xml:space="preserve">
          <source>Aggregate: percentile_cont WITHIN GROUP</source>
          <target state="translated">Aggregate:percentile_cont WITHIN GROUP.</target>
        </trans-unit>
        <trans-unit id="221d8437a4694e24ecacfafa477406400d56070a" translate="yes" xml:space="preserve">
          <source>Aggregate: percentile_disc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c269fdb441e6262d2a37b019da9d266f3b3b083" translate="yes" xml:space="preserve">
          <source>Aggregate: percentile_disc WITHIN GROUP</source>
          <target state="translated">Aggregate:percentile_disc WITHIN GROUP.</target>
        </trans-unit>
        <trans-unit id="780b4bfa2df2c728976c6499686f1e45a03cae9d" translate="yes" xml:space="preserve">
          <source>Aggregate: rank</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66604fc6a8764a0b6d82483c45c9ff5043d563ce" translate="yes" xml:space="preserve">
          <source>Aggregate: rank WITHIN GROUP</source>
          <target state="translated">合计:集团内排名</target>
        </trans-unit>
        <trans-unit id="08db334b9f771618e8d9956b3a35006958baa8aa" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_avgx</source>
          <target state="translated">Aggregate:regr_avgx</target>
        </trans-unit>
        <trans-unit id="f813e6eb9f1bd8f18122c9d3100e3e1329000930" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_avgy</source>
          <target state="translated">汇总:regr_avgy。</target>
        </trans-unit>
        <trans-unit id="db3268966df89189e65fd222205de0442daba3c2" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_count</source>
          <target state="translated">汇总:regr_count。</target>
        </trans-unit>
        <trans-unit id="4489b8487a16a39dde1e4d8b5fcd20f0950266f5" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_intercept</source>
          <target state="translated">汇总:regr_intercept。</target>
        </trans-unit>
        <trans-unit id="17dd93536539876bbf56b59964ca4c7379d9ef8f" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_r2</source>
          <target state="translated">总数:regr_r2</target>
        </trans-unit>
        <trans-unit id="bbd0902e24a6b13aeeb42be12d4c6ac689ac39d4" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_slope</source>
          <target state="translated">Aggregate:regr_slope.</target>
        </trans-unit>
        <trans-unit id="83dbb5beff01870dc33ceaa7278e2d80cc920457" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_sxx</source>
          <target state="translated">总数:regr_sxx</target>
        </trans-unit>
        <trans-unit id="ec7ca11bda1c42f1ba07c7f1bd8a0c3296064181" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_sxy</source>
          <target state="translated">汇总:regr_sxy</target>
        </trans-unit>
        <trans-unit id="f14b071a16428ce5a21dc895086399aaadc762a3" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_syy</source>
          <target state="translated">总数:regr_syy</target>
        </trans-unit>
        <trans-unit id="c004eede3fbd79af583dbd185f768dfae4d466a6" translate="yes" xml:space="preserve">
          <source>Aggregate: stddev</source>
          <target state="translated">Aggregate:stddev</target>
        </trans-unit>
        <trans-unit id="1d5e80f190137dd3cac84ce1a78d10780d5bce34" translate="yes" xml:space="preserve">
          <source>Aggregate: stddev_pop</source>
          <target state="translated">Aggregate:stddev_pop</target>
        </trans-unit>
        <trans-unit id="d3b157c6a46f69b3887530f9f9b22d6b9cb4a16e" translate="yes" xml:space="preserve">
          <source>Aggregate: stddev_samp</source>
          <target state="translated">Aggregate:stddev_samp</target>
        </trans-unit>
        <trans-unit id="2974203e91cce11e66f9221d5ec28297655cd0a8" translate="yes" xml:space="preserve">
          <source>Aggregate: string_agg</source>
          <target state="translated">Aggregate:string_agg</target>
        </trans-unit>
        <trans-unit id="ee008bd21c90b91f02271735e82b4e05772fdd98" translate="yes" xml:space="preserve">
          <source>Aggregate: sum</source>
          <target state="translated">合计:总和</target>
        </trans-unit>
        <trans-unit id="7f9f090a85b6cef6189e9f1f572af2d4232d4c63" translate="yes" xml:space="preserve">
          <source>Aggregate: sum/N</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42f2801430c2438881499cac7d09362a7b44215e" translate="yes" xml:space="preserve">
          <source>Aggregate: to_json</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56a46ffd3d158ae27b092ee54bfe3724f518b2f3" translate="yes" xml:space="preserve">
          <source>Aggregate: var_pop</source>
          <target state="translated">Aggregate:var_pop</target>
        </trans-unit>
        <trans-unit id="3c7dc337d4d493d0b8b497185b09dab2dd6b0e40" translate="yes" xml:space="preserve">
          <source>Aggregate: var_samp</source>
          <target state="translated">汇总:var_samp</target>
        </trans-unit>
        <trans-unit id="51e197a4c87920c56f05e65ce1ba4b227834b071" translate="yes" xml:space="preserve">
          <source>Aggregate: variance</source>
          <target state="translated">合计:差异</target>
        </trans-unit>
        <trans-unit id="a2fb0accd998c64e0241184b4242d48e43957e30" translate="yes" xml:space="preserve">
          <source>Aggregate: xmlagg</source>
          <target state="translated">合计:xmlagg</target>
        </trans-unit>
        <trans-unit id="576d72bc3c483daa9c7746a2659f34dd5176aed8" translate="yes" xml:space="preserve">
          <source>Aggregated Argument Type(s)</source>
          <target state="translated">彙總參數類型</target>
        </trans-unit>
        <trans-unit id="425a801b77a97dcec7fa5fa5f67892cad03a7787" translate="yes" xml:space="preserve">
          <source>Aggregated Logging</source>
          <target state="translated">汇总日志</target>
        </trans-unit>
        <trans-unit id="604697606446ca85390963f1caeb65a8c41712bd" translate="yes" xml:space="preserve">
          <source>Aggregates are also very useful in combination with &lt;code&gt;GROUP BY&lt;/code&gt; clauses. For example, we can get the maximum low temperature observed in each city with:</source>
          <target state="translated">聚集与 &lt;code&gt;GROUP BY&lt;/code&gt; 子句结合使用也非常有用。例如，我们可以通过以下方法获得每个城市观测到的最高低温：</target>
        </trans-unit>
        <trans-unit id="8a83bb8f12f58dc63f8d8450952fc03b0bc1ffde" translate="yes" xml:space="preserve">
          <source>Aggregates that behave like &lt;code&gt;MIN&lt;/code&gt; or &lt;code&gt;MAX&lt;/code&gt; can sometimes be optimized by looking into an index instead of scanning every input row. If this aggregate can be so optimized, indicate it by specifying a &lt;em&gt;sort operator&lt;/em&gt;. The basic requirement is that the aggregate must yield the first element in the sort ordering induced by the operator; in other words:</source>
          <target state="translated">有时可以通过查找索引而不是扫描每个输入行来优化行为类似于 &lt;code&gt;MIN&lt;/code&gt; 或 &lt;code&gt;MAX&lt;/code&gt; 的聚合。如果可以如此优化此聚合，请通过指定&lt;em&gt;sort运算符&lt;/em&gt;进行指示。基本要求是，集合必须在运算符引起的排序顺序中产生第一个元素；换一种说法：</target>
        </trans-unit>
        <trans-unit id="7ec048891025aea562b86e815620f42ae7adb619" translate="yes" xml:space="preserve">
          <source>Aggressive &lt;code&gt;VACUUM&lt;/code&gt; scans, regardless of what causes them, enable advancing the value for that table. Eventually, as all tables in all databases are scanned and their oldest multixact values are advanced, on-disk storage for older multixacts can be removed.</source>
          <target state="translated">不管是什么原因，积极的 &lt;code&gt;VACUUM&lt;/code&gt; 扫描都可以提高该表的值。最终，由于扫描了所有数据库中的所有表并提高了它们的最旧多重值，因此可以删除磁盘上旧版本的多重存储。</target>
        </trans-unit>
        <trans-unit id="121abf3940fab2d8dbe9b94bbd289148bc06a85b" translate="yes" xml:space="preserve">
          <source>Aggressively &amp;ldquo;freeze&amp;rdquo; tuples.</source>
          <target state="translated">积极地&amp;ldquo;冻结&amp;rdquo;元组。</target>
        </trans-unit>
        <trans-unit id="bcb017abcff2696033726df1d1faa6140cda30fa" translate="yes" xml:space="preserve">
          <source>Alexander Korotkov &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:a.korotkov@postgrespro.ru&quot;&gt;a.korotkov@postgrespro.ru&lt;/a&gt;&amp;gt;&lt;/code&gt;, Moscow, Postgres Professional, Russia</source>
          <target state="translated">亚历山大&amp;middot;科罗特科夫 &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:a.korotkov@postgrespro.ru&quot;&gt;a.korotkov@postgrespro.ru&lt;/a&gt;&amp;gt;&lt;/code&gt; ，莫斯科，俄罗斯Postgres Professional</target>
        </trans-unit>
        <trans-unit id="aa44f40c0080e2d8f22aa729bc2aa695de07bb55" translate="yes" xml:space="preserve">
          <source>Alexander Korotkov &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:a.korotkov@postgrespro.ru&quot;&gt;a.korotkov@postgrespro.ru&lt;/a&gt;&amp;gt;&lt;/code&gt;, Postgres Professional, Moscow, Russia</source>
          <target state="translated">亚历山大&amp;middot;科罗特科夫 &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:a.korotkov@postgrespro.ru&quot;&gt;a.korotkov@postgrespro.ru&lt;/a&gt;&amp;gt;&lt;/code&gt; ，Postgres Professional，俄罗斯莫斯科</target>
        </trans-unit>
        <trans-unit id="02f02485ab679a9031f461bdbd3edab48ea42a79" translate="yes" xml:space="preserve">
          <source>Algorithm</source>
          <target state="translated">Algorithm</target>
        </trans-unit>
        <trans-unit id="04259816ace1ebe56c853a8763558570c008514a" translate="yes" xml:space="preserve">
          <source>Alias</source>
          <target state="translated">Alias</target>
        </trans-unit>
        <trans-unit id="6a8b49f23c0c2e66b347773e3a4bb453ff1fb91c" translate="yes" xml:space="preserve">
          <source>Aliases</source>
          <target state="translated">Aliases</target>
        </trans-unit>
        <trans-unit id="9e3800ae71f3a62322201681fab38592cc7aac5f" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;glossary#GLOSSARY-AGGREGATE&quot;&gt;aggregate functions&lt;/a&gt; can be used as window functions, but window functions can also be used to, for example, give ranks to each of the rows in the partition. Also known as &lt;em&gt;analytic functions&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1238bd88f43030284835da146c8f594a6e3253c8" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;pgcrypto&lt;/code&gt; functions run inside the database server. That means that all the data and passwords move between &lt;code&gt;pgcrypto&lt;/code&gt; and client applications in clear text. Thus you must:</source>
          <target state="translated">所有 &lt;code&gt;pgcrypto&lt;/code&gt; 函数都在数据库服务器内部运行。这意味着所有数据和密码都以明文在 &lt;code&gt;pgcrypto&lt;/code&gt; 和客户端应用程序之间移动。因此，您必须：</target>
        </trans-unit>
        <trans-unit id="0b67ddd3a2de73817c7543968b2cc085a1a78542" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;storage&lt;/code&gt; values other than &lt;code&gt;plain&lt;/code&gt; imply that the functions of the data type can handle values that have been &lt;em&gt;toasted&lt;/em&gt;, as described in &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/xtypes.html#XTYPES-TOAST&quot;&gt;Section 37.13.1&lt;/a&gt;. The specific other value given merely determines the default TOAST storage strategy for columns of a toastable data type; users can pick other strategies for individual columns using &lt;code&gt;ALTER TABLE SET STORAGE&lt;/code&gt;.</source>
          <target state="translated">所有 &lt;code&gt;storage&lt;/code&gt; 值（非 &lt;code&gt;plain&lt;/code&gt; 存储值）都意味着数据类型的功能可以处理已&lt;em&gt;烘烤的&lt;/em&gt;值，如&lt;a href=&quot;storage-toast&quot;&gt;第68.2 &lt;/a&gt;&lt;a href=&quot;https://www.postgresql.org/docs/12/xtypes.html#XTYPES-TOAST&quot;&gt;节&lt;/a&gt;和第37.13.1节所述。给定的其他特定值仅确定可烘烤数据类型的列的默认TOAST存储策略；用户可以使用 &lt;code&gt;ALTER TABLE SET STORAGE&lt;/code&gt; 为单个列选择其他策略。</target>
        </trans-unit>
        <trans-unit id="f8dfd6e92427babe1e9a096720e962dca35e82cb" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;storage&lt;/code&gt; values other than &lt;code&gt;plain&lt;/code&gt; imply that the functions of the data type can handle values that have been &lt;em&gt;toasted&lt;/em&gt;, as described in &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/13/xtypes.html#XTYPES-TOAST&quot;&gt;Section 37.13.1&lt;/a&gt;. The specific other value given merely determines the default TOAST storage strategy for columns of a toastable data type; users can pick other strategies for individual columns using &lt;code&gt;ALTER TABLE SET STORAGE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10d6e0687d278d53588734a1b582257aaee1502f" translate="yes" xml:space="preserve">
          <source>All Privileges</source>
          <target state="translated">所有特权</target>
        </trans-unit>
        <trans-unit id="bf637fbee55bb9d868af3ee61e448c31817bc7e1" translate="yes" xml:space="preserve">
          <source>All UPC, ISBN, ISMN and ISSN numbers can be represented as EAN13 numbers.</source>
          <target state="translated">所有的UPC、ISBN、ISMN和ISSN号都可以用EAN13号来表示。</target>
        </trans-unit>
        <trans-unit id="f057cd68ee57e6fcf443add2a601584e9abb4486" translate="yes" xml:space="preserve">
          <source>All WAL records required for the backup must contain sufficient full-page writes, which requires you to enable &lt;code&gt;full_page_writes&lt;/code&gt; on the master and not to use a tool like pg_compresslog as &lt;code&gt;archive_command&lt;/code&gt; to remove full-page writes from WAL files.</source>
          <target state="translated">备份所需的所有WAL记录必须包含足够的整页写操作，这要求您在主 &lt;code&gt;full_page_writes&lt;/code&gt; 上启用full_page_writes，而不能使用pg_compresslog这样的工具作为 &lt;code&gt;archive_command&lt;/code&gt; 从WAL文件中删除整页写操作。</target>
        </trans-unit>
        <trans-unit id="32451a83c5b4d59ae6ed31b28d945b83e60fefc2" translate="yes" xml:space="preserve">
          <source>All WAL records required for the backup must contain sufficient full-page writes, which requires you to enable &lt;code&gt;full_page_writes&lt;/code&gt; on the primary and not to use a tool like pg_compresslog as &lt;code&gt;archive_command&lt;/code&gt; to remove full-page writes from WAL files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="841cc9e5c025174354644ed418b19ab2df80e067" translate="yes" xml:space="preserve">
          <source>All arguments are specified in order. The result is upper case since &lt;code&gt;uppercase&lt;/code&gt; is specified as &lt;code&gt;true&lt;/code&gt;. Another example is:</source>
          <target state="translated">所有参数均按顺序指定。由于 &lt;code&gt;uppercase&lt;/code&gt; 指定为 &lt;code&gt;true&lt;/code&gt; ，因此结果为大写字母。另一个示例是：</target>
        </trans-unit>
        <trans-unit id="64cfac4af128aada4a6d6bb5c11a90e45ce7a24e" translate="yes" xml:space="preserve">
          <source>All check constraints and not-null constraints on a parent table are automatically inherited by its children, unless explicitly specified otherwise with &lt;code&gt;NO INHERIT&lt;/code&gt; clauses. Other types of constraints (unique, primary key, and foreign key constraints) are not inherited.</source>
          <target state="translated">父表上的所有检查约束和非空约束都将由其子表自动继承，除非用 &lt;code&gt;NO INHERIT&lt;/code&gt; 子句明确指定。其他类型的约束（唯一，主键和外键约束）不会被继承。</target>
        </trans-unit>
        <trans-unit id="337d6bdce5b053fd7a1885beaee3b7d63bb8f598" translate="yes" xml:space="preserve">
          <source>All columns will be filled with their default values, as if &lt;code&gt;DEFAULT&lt;/code&gt; were explicitly specified for each column. (An &lt;code&gt;OVERRIDING&lt;/code&gt; clause is not permitted in this form.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89f96ca727311b0e1e924639300601036b23919a" translate="yes" xml:space="preserve">
          <source>All columns will be filled with their default values. (An &lt;code&gt;OVERRIDING&lt;/code&gt; clause is not permitted in this form.)</source>
          <target state="translated">所有列均将填充其默认值。（此格式不允许使用 &lt;code&gt;OVERRIDING&lt;/code&gt; 子句。）</target>
        </trans-unit>
        <trans-unit id="44d64899ac94e8442ee1baa672497f8a2ca162b4" translate="yes" xml:space="preserve">
          <source>All constraints on all children of the parent table are examined during constraint exclusion, so large numbers of children are likely to increase query planning time considerably. So the legacy inheritance based partitioning will work well with up to perhaps a hundred child tables; don't try to use many thousands of children.</source>
          <target state="translated">在约束排除过程中,会对父表所有子表的所有约束进行检查,所以大量的子表很可能会大大增加查询规划时间。所以基于继承的传统分区在最多可能有一百张子表的情况下就能很好地工作,不要试图使用很多上千张子表。</target>
        </trans-unit>
        <trans-unit id="153c80dc5116feea616ba3928be18ab8586f5a93" translate="yes" xml:space="preserve">
          <source>All current listen registrations for this session are cleared.</source>
          <target state="translated">本节课的所有当前听课注册都将被清除。</target>
        </trans-unit>
        <trans-unit id="e559ad46dfb12176f9ab6a5068fbbc335264dacf" translate="yes" xml:space="preserve">
          <source>All currently available prepared transactions are listed in the &lt;a href=&quot;view-pg-prepared-xacts&quot;&gt;&lt;code&gt;pg_prepared_xacts&lt;/code&gt;&lt;/a&gt; system view.</source>
          <target state="translated">&lt;a href=&quot;view-pg-prepared-xacts&quot;&gt; &lt;code&gt;pg_prepared_xacts&lt;/code&gt; &lt;/a&gt;系统视图中列出了所有当前可用的准备好的事务。</target>
        </trans-unit>
        <trans-unit id="2778b518fdc9b5356b12e2a79dd08d30844b8366" translate="yes" xml:space="preserve">
          <source>All elements in the &lt;code&gt;FROM&lt;/code&gt; list are computed. (Each element in the &lt;code&gt;FROM&lt;/code&gt; list is a real or virtual table.) If more than one element is specified in the &lt;code&gt;FROM&lt;/code&gt; list, they are cross-joined together. (See &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt;&lt;code&gt;FROM&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">将计算 &lt;code&gt;FROM&lt;/code&gt; 列表中的所有元素。（ &lt;code&gt;FROM&lt;/code&gt; 列表中的每个元素都是真实表或虚拟表。）如果 &lt;code&gt;FROM&lt;/code&gt; 列表中指定了多个元素，则它们将交叉连接在一起。（请参阅下面的&lt;a href=&quot;sql-select#SQL-FROM&quot;&gt; &lt;code&gt;FROM&lt;/code&gt; 子句&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="14481956ddccdbae880b961dfaa2429f752c35d7" translate="yes" xml:space="preserve">
          <source>All elements in the &lt;code&gt;FROM&lt;/code&gt; list are computed. (Each element in the &lt;code&gt;FROM&lt;/code&gt; list is a real or virtual table.) If more than one element is specified in the &lt;code&gt;FROM&lt;/code&gt; list, they are cross-joined together. (See &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt;FROM Clause&lt;/a&gt; below.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3978f2f6a0fc6fd4b0827f0ebd212e7bcc3552c2" translate="yes" xml:space="preserve">
          <source>All failure, rebuild, and reindex cases will be reported by pg_upgrade if they affect your installation; post-upgrade scripts to rebuild tables and indexes will be generated automatically. If you are trying to automate the upgrade of many clusters, you should find that clusters with identical database schemas require the same post-upgrade steps for all cluster upgrades; this is because the post-upgrade steps are based on the database schemas, and not user data.</source>
          <target state="translated">如果影响到你的安装,所有失败、重建和重新索引的情况都会被pg_upgrade报告;重建表和索引的升级后脚本会自动生成。如果你试图自动升级许多集群,你应该会发现,具有相同数据库模式的集群在所有集群升级时都需要相同的升级后步骤;这是因为升级后步骤是基于数据库模式,而不是用户数据。</target>
        </trans-unit>
        <trans-unit id="2887bc873471e44a6e402dab0ddec69892effbd0" translate="yes" xml:space="preserve">
          <source>All functions and operators used in an index definition must be &amp;ldquo;immutable&amp;rdquo;, that is, their results must depend only on their arguments and never on any outside influence (such as the contents of another table or the current time). This restriction ensures that the behavior of the index is well-defined. To use a user-defined function in an index expression or &lt;code&gt;WHERE&lt;/code&gt; clause, remember to mark the function immutable when you create it.</source>
          <target state="translated">索引定义中使用的所有函数和运算符都必须是&amp;ldquo;不可变的&amp;rdquo;，也就是说，其结果必须仅取决于其参数，而不得取决于任何外部影响（例如，另一个表的内容或当前时间）。此限制可确保索引的行为得到良好定义。要在索引表达式或 &lt;code&gt;WHERE&lt;/code&gt; 子句中使用用户定义的函数，请记住在创建函数时将其标记为不可变。</target>
        </trans-unit>
        <trans-unit id="3ef17a42f49f1b90a3d376b9b52494437e996867" translate="yes" xml:space="preserve">
          <source>All indexes in PostgreSQL are &lt;em&gt;secondary&lt;/em&gt; indexes, meaning that each index is stored separately from the table's main data area (which is called the table's &lt;em&gt;heap&lt;/em&gt; in PostgreSQL terminology). This means that in an ordinary index scan, each row retrieval requires fetching data from both the index and the heap. Furthermore, while the index entries that match a given indexable &lt;code&gt;WHERE&lt;/code&gt; condition are usually close together in the index, the table rows they reference might be anywhere in the heap. The heap-access portion of an index scan thus involves a lot of random access into the heap, which can be slow, particularly on traditional rotating media. (As described in &lt;a href=&quot;indexes-bitmap-scans&quot;&gt;Section 11.5&lt;/a&gt;, bitmap scans try to alleviate this cost by doing the heap accesses in sorted order, but that only goes so far.)</source>
          <target state="translated">PostgreSQL中的所有索引都是&lt;em&gt;辅助&lt;/em&gt;索引，这意味着每个索引都与表的主数据区（在PostgreSQL术语中称为表的&lt;em&gt;堆&lt;/em&gt;）分开存储。这意味着在普通索引扫描中，每行检索都需要从索引和堆中获取数据。此外，尽管与给定可索引 &lt;code&gt;WHERE&lt;/code&gt; 条件匹配的索引条目通常在索引中靠在一起，但它们引用的表行可能在堆中的任何位置。因此，索引扫描的堆访问部分涉及对堆的大量随机访问，这可能很慢，尤其是在传统旋转媒体上。 （如&lt;a href=&quot;indexes-bitmap-scans&quot;&gt;第11.5节&lt;/a&gt;所述，则位图扫描会尝试通过按排序顺序进行堆访问来减轻这种开销，但这只是到目前为止。）</target>
        </trans-unit>
        <trans-unit id="db79cd41caf099a5fc97eb22b9bdb081eeb2153e" translate="yes" xml:space="preserve">
          <source>All it takes to get a BRIN access method working is to implement a few user-defined methods, which define the behavior of summary values stored in the index and the way they interact with scan keys. In short, BRIN combines extensibility with generality, code reuse, and a clean interface.</source>
          <target state="translated">要让BRIN访问方法发挥作用,只需要实现一些用户定义的方法,这些方法定义了存储在索引中的摘要值的行为,以及它们与扫描键交互的方式。简而言之,BRIN将可扩展性与通用性、代码重用和简洁的界面结合起来。</target>
        </trans-unit>
        <trans-unit id="6e1a7f84a08ba9a0c97ee25a9736132689a50678" translate="yes" xml:space="preserve">
          <source>All it takes to get a GIN access method working is to implement a few user-defined methods, which define the behavior of keys in the tree and the relationships between keys, indexed items, and indexable queries. In short, GIN combines extensibility with generality, code reuse, and a clean interface.</source>
          <target state="translated">要想让GIN访问方法发挥作用,只需要实现一些用户定义的方法,这些方法定义了树中键的行为以及键、索引项和可索引查询之间的关系。简而言之,GIN将可扩展性与通用性、代码重用和简洁的界面结合起来。</target>
        </trans-unit>
        <trans-unit id="932e4d059724c2d4b8d21124cf86633cf4ac8541" translate="yes" xml:space="preserve">
          <source>All it takes to get a GiST access method up and running is to implement several user-defined methods, which define the behavior of keys in the tree. Of course these methods have to be pretty fancy to support fancy queries, but for all the standard queries (B-trees, R-trees, etc.) they're relatively straightforward. In short, GiST combines extensibility along with generality, code reuse, and a clean interface.</source>
          <target state="translated">要想让一个GiST访问方法启动并运行,只需要实现几个用户定义的方法,这些方法定义了树中键的行为。当然这些方法必须非常花哨,才能支持花哨的查询,但对于所有的标准查询(B树、R树等)来说,它们都是比较简单的。简而言之,GiST结合了可扩展性以及通用性、代码重用和简洁的界面。</target>
        </trans-unit>
        <trans-unit id="f6f094a1f0d931ca3f860e1e2d7b887c4d3d20bd" translate="yes" xml:space="preserve">
          <source>All messages emitted by the PostgreSQL server are assigned five-character error codes that follow the SQL standard's conventions for &amp;ldquo;SQLSTATE&amp;rdquo; codes. Applications that need to know which error condition has occurred should usually test the error code, rather than looking at the textual error message. The error codes are less likely to change across PostgreSQL releases, and also are not subject to change due to localization of error messages. Note that some, but not all, of the error codes produced by PostgreSQL are defined by the SQL standard; some additional error codes for conditions not defined by the standard have been invented or borrowed from other databases.</source>
          <target state="translated">PostgreSQL服务器发出的所有消息均分配有五个字符的错误代码，这些错误代码遵循SQL标准对&amp;ldquo; SQLSTATE&amp;rdquo;代码的约定。需要知道发生哪种错误情况的应用程序通常应测试错误代码，而不是查看文本错误消息。错误代码在PostgreSQL发行版中不太可能更改，并且也不会由于错误消息的本地化而更改。注意，PostgreSQL产生的一些但不是全部错误代码是由SQL标准定义的。从其他数据库中发明或借用了一些针对该标准未定义的条件的其他错误代码。</target>
        </trans-unit>
        <trans-unit id="5f17dc4d29230530f8f45813d17f855f136a3816" translate="yes" xml:space="preserve">
          <source>All multixact IDs before this one have been replaced by a transaction ID in this table. This is used to track whether the table needs to be vacuumed in order to prevent multixact ID wraparound or to allow &lt;code&gt;pg_multixact&lt;/code&gt; to be shrunk. Zero (&lt;code&gt;InvalidMultiXactId&lt;/code&gt;) if the relation is not a table.</source>
          <target state="translated">此表之前的所有多重ID已被事务ID取代。这用于跟踪是否需要清理表以防止多重ID环绕或允许 &lt;code&gt;pg_multixact&lt;/code&gt; 缩小。如果该关系不是表，则为零（ &lt;code&gt;InvalidMultiXactId&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2dede7220bdd3e91dec2b9b6615dd35bb3933921" translate="yes" xml:space="preserve">
          <source>All multixact IDs before this one have been replaced with a transaction ID in this database. This is used to track whether the database needs to be vacuumed in order to prevent multixact ID wraparound or to allow &lt;code&gt;pg_multixact&lt;/code&gt; to be shrunk. It is the minimum of the per-table &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relminmxid&lt;/code&gt; values.</source>
          <target state="translated">此数据库之前的所有多重ID已替换为事务ID。这用于跟踪是否需要清理数据库以防止多重ID环绕或允许 &lt;code&gt;pg_multixact&lt;/code&gt; 收缩。它是每个表 &lt;code&gt;pg_class&lt;/code&gt; 的最小值。 &lt;code&gt;relminmxid&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="b6a1ec7b62542588df77c091f76d37462abbe3bd" translate="yes" xml:space="preserve">
          <source>All of the OID alias types for objects grouped by namespace accept schema-qualified names, and will display schema-qualified names on output if the object would not be found in the current search path without being qualified. The &lt;code&gt;regproc&lt;/code&gt; and &lt;code&gt;regoper&lt;/code&gt; alias types will only accept input names that are unique (not overloaded), so they are of limited use; for most uses &lt;code&gt;regprocedure&lt;/code&gt; or &lt;code&gt;regoperator&lt;/code&gt; are more appropriate. For &lt;code&gt;regoperator&lt;/code&gt;, unary operators are identified by writing &lt;code&gt;NONE&lt;/code&gt; for the unused operand.</source>
          <target state="translated">按名称空间分组的对象的所有OID别名类型都接受模式限定的名称，如果在当前搜索路径中没有限定对象的情况下找不到对象，则将在输出中显示模式限定的名称。该 &lt;code&gt;regproc&lt;/code&gt; 和 &lt;code&gt;regoper&lt;/code&gt; 别名类型将只接受是唯一的（不超载），因此它们的用途有限的输入名字;在大多数 &lt;code&gt;regoperator&lt;/code&gt; ，更适合使用 &lt;code&gt;regprocedure&lt;/code&gt; 或regoperator。对于 &lt;code&gt;regoperator&lt;/code&gt; ，通过为未使用的操作数写入 &lt;code&gt;NONE&lt;/code&gt; 来标识一元运算符。</target>
        </trans-unit>
        <trans-unit id="37766175956ba6517dd475210dd4e291c6b94f05" translate="yes" xml:space="preserve">
          <source>All of the functions listed in &lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;Table 9.60&lt;/a&gt; depend on the sort ordering specified by the &lt;code&gt;ORDER BY&lt;/code&gt; clause of the associated window definition. Rows that are not distinct when considering only the &lt;code&gt;ORDER BY&lt;/code&gt; columns are said to be &lt;em&gt;peers&lt;/em&gt;. The four ranking functions (including &lt;code&gt;cume_dist&lt;/code&gt;) are defined so that they give the same answer for all peer rows.</source>
          <target state="translated">&lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;表9.60中&lt;/a&gt;列出的所有功能都取决于关联窗口定义的 &lt;code&gt;ORDER BY&lt;/code&gt; 子句指定的排序顺序。仅考虑 &lt;code&gt;ORDER BY&lt;/code&gt; 列时没有区别的行被称为对&lt;em&gt;等行&lt;/em&gt;。定义了四个排名函数（包括 &lt;code&gt;cume_dist&lt;/code&gt; ），以便它们对所有对等行给出相同的答案。</target>
        </trans-unit>
        <trans-unit id="6b3dc7a98e19d74a1c8b693082bcc2b7322b43f8" translate="yes" xml:space="preserve">
          <source>All of the functions listed in &lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;Table 9.60&lt;/a&gt; depend on the sort ordering specified by the &lt;code&gt;ORDER BY&lt;/code&gt; clause of the associated window definition. Rows that are not distinct when considering only the &lt;code&gt;ORDER BY&lt;/code&gt; columns are said to be &lt;em&gt;peers&lt;/em&gt;. The four ranking functions (including &lt;code&gt;cume_dist&lt;/code&gt;) are defined so that they give the same answer for all rows of a peer group.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02fa4b0f473762a8721b052a178d80c186d067cd" translate="yes" xml:space="preserve">
          <source>All of the options except &lt;code&gt;convert-crlf&lt;/code&gt; apply only to encrypt functions. Decrypt functions get the parameters from the PGP data.</source>
          <target state="translated">除 &lt;code&gt;convert-crlf&lt;/code&gt; 以外的所有选项仅适用于加密函数。解密功能从PGP数据获取参数。</target>
        </trans-unit>
        <trans-unit id="592ca33a4522df17e0e57a59e6344510c5d4a80c" translate="yes" xml:space="preserve">
          <source>All of the policies constructed thus far have been permissive policies, meaning that when multiple policies are applied they are combined using the &amp;ldquo;OR&amp;rdquo; Boolean operator. While permissive policies can be constructed to only allow access to rows in the intended cases, it can be simpler to combine permissive policies with restrictive policies (which the records must pass and which are combined using the &amp;ldquo;AND&amp;rdquo; Boolean operator). Building on the example above, we add a restrictive policy to require the administrator to be connected over a local Unix socket to access the records of the &lt;code&gt;passwd&lt;/code&gt; table:</source>
          <target state="translated">到目前为止构造的所有策略都是许可策略，这意味着当应用多个策略时，将使用&amp;ldquo;或&amp;rdquo;布尔运算符将它们组合在一起。虽然可以将许可策略构造为仅允许在预期的情况下访问行，但是将许可策略与限制性策略（记录必须通过且使用&amp;ldquo; AND&amp;rdquo;布尔运算符组合的限制性策略）组合起来会更简单。在上面的示例的基础上，我们添加了一个限制性策略，要求管理员通过本地Unix套接字连接以访问 &lt;code&gt;passwd&lt;/code&gt; 表的记录：</target>
        </trans-unit>
        <trans-unit id="068ae9ee084ab21fc5a8a7c0060d57cbf4e3473f" translate="yes" xml:space="preserve">
          <source>All of these &lt;code&gt;ORDER BY&lt;/code&gt; clauses specify the row's composite value, resulting in sorting the rows according to the rules described in &lt;a href=&quot;functions-comparisons#COMPOSITE-TYPE-COMPARISON&quot;&gt;Section 9.23.6&lt;/a&gt;. However, if &lt;code&gt;inventory_item&lt;/code&gt; contained a column named &lt;code&gt;c&lt;/code&gt;, the first case would be different from the others, as it would mean to sort by that column only. Given the column names previously shown, these queries are also equivalent to those above:</source>
          <target state="translated">所有这些 &lt;code&gt;ORDER BY&lt;/code&gt; 子句都指定行的复合值，从而根据&lt;a href=&quot;functions-comparisons#COMPOSITE-TYPE-COMPARISON&quot;&gt;9.23.6节中&lt;/a&gt;描述的规则对行进行排序。但是，如果 &lt;code&gt;inventory_item&lt;/code&gt; 包含名为 &lt;code&gt;c&lt;/code&gt; 的列，则第一种情况将与其他情况不同，因为这意味着仅按该列进行排序。给定先前显示的列名，这些查询也等同于上面的查询：</target>
        </trans-unit>
        <trans-unit id="c8391ba1355f7ba958065513e77b352946c8ee3d" translate="yes" xml:space="preserve">
          <source>All of these &lt;code&gt;ORDER BY&lt;/code&gt; clauses specify the row's composite value, resulting in sorting the rows according to the rules described in &lt;a href=&quot;functions-comparisons#COMPOSITE-TYPE-COMPARISON&quot;&gt;Section 9.24.6&lt;/a&gt;. However, if &lt;code&gt;inventory_item&lt;/code&gt; contained a column named &lt;code&gt;c&lt;/code&gt;, the first case would be different from the others, as it would mean to sort by that column only. Given the column names previously shown, these queries are also equivalent to those above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abf3c99355ffd14c50c6d5db9b1b5a423f1e1022" translate="yes" xml:space="preserve">
          <source>All of these fields are optional, except &lt;code&gt;commonName&lt;/code&gt;. It depends entirely on your CA's policy which of them would be included and which wouldn't. The meaning of these fields, however, is strictly defined by the X.500 and X.509 standards, so you cannot just assign arbitrary meaning to them.</source>
          <target state="translated">除了 &lt;code&gt;commonName&lt;/code&gt; 以外，所有这些字段都是可选的。这完全取决于您CA的政策，哪些将包括在内，哪些不包括在内。但是，这些字段的含义严格由X.500和X.509标准定义，因此您不能仅对它们指定任意含义。</target>
        </trans-unit>
        <trans-unit id="c6deee271f21fa5ab3c6f7bba891d40136e2c021" translate="yes" xml:space="preserve">
          <source>All of these operations will throw an error if a supplied array contains any NULL elements.</source>
          <target state="translated">如果提供的数组中包含任何NULL元素,所有这些操作都会抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="d9b92f66d52bf42e15e05f0a8c5cb26f0298b448" translate="yes" xml:space="preserve">
          <source>All other parameters are described in detail under &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;.</source>
          <target state="translated">所有其他参数在&lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;下详细说明。</target>
        </trans-unit>
        <trans-unit id="a4df9c2d50326edae48634d605dfaf0fbdb01416" translate="yes" xml:space="preserve">
          <source>All parameter names are case-insensitive. Every parameter takes a value of one of five types: boolean, string, integer, floating point, or enumerated (enum). The type determines the syntax for setting the parameter:</source>
          <target state="translated">所有参数名都不区分大小写。每个参数的值都是五种类型之一:布尔、字符串、整数、浮点或枚举(enum)。类型决定了设置参数的语法。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
