<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="99c46fa0bf1c41a332643fa4668a817dafffd6e4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;planner/optimizer&lt;/em&gt; takes the (rewritten) query tree and creates a &lt;em&gt;query plan&lt;/em&gt; that will be the input to the &lt;em&gt;executor&lt;/em&gt;.</source>
          <target state="translated">该&lt;em&gt;规划器/优化&lt;/em&gt;取（重写）查询树，并创建一个&lt;em&gt;查询计划&lt;/em&gt;，这将是输入到&lt;em&gt;执行&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="f0bfc85eac5f506c4396fe64f83cd201f163702b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;rewrite system&lt;/em&gt; takes the query tree created by the parser stage and looks for any &lt;em&gt;rules&lt;/em&gt; (stored in the &lt;em&gt;system catalogs&lt;/em&gt;) to apply to the query tree. It performs the transformations given in the &lt;em&gt;rule bodies&lt;/em&gt;.</source>
          <target state="translated">该&lt;em&gt;重写系统&lt;/em&gt;需要通过任何分析器阶段和外观创建查询树&lt;em&gt;规则&lt;/em&gt;（存储在&lt;em&gt;系统目录&lt;/em&gt;）适用于查询树。它执行&lt;em&gt;规则主体中&lt;/em&gt;给出的转换。</target>
        </trans-unit>
        <trans-unit id="daa9a547059ab18709c7d9a8b34e0eb273fde26d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;transformation process&lt;/em&gt; does modifications and augmentations to the data structures returned by the parser.</source>
          <target state="translated">在&lt;em&gt;改造过程中&lt;/em&gt;进行修改和增补由分析器返回的数据结构。</target>
        </trans-unit>
        <trans-unit id="6005c8d6a8d942aa977decf6b60a95978aaf5aab" translate="yes" xml:space="preserve">
          <source>The API for constructing generic WAL records is defined in &lt;code&gt;access/generic_xlog.h&lt;/code&gt; and implemented in &lt;code&gt;access/transam/generic_xlog.c&lt;/code&gt;.</source>
          <target state="translated">用于构造通用WAL记录的API在 &lt;code&gt;access/generic_xlog.h&lt;/code&gt; 中定义，并在 &lt;code&gt;access/transam/generic_xlog.c&lt;/code&gt; 中实现。</target>
        </trans-unit>
        <trans-unit id="aaa78d1712bc527d8b8229b7cb39f829dcef0b7a" translate="yes" xml:space="preserve">
          <source>The B-tree operator family this entry sorts according to, if an ordering operator; zero if a search operator</source>
          <target state="translated">本条目根据B树运算符族进行排序,如果是排序运算符,则为0;如果是搜索运算符,则为0。</target>
        </trans-unit>
        <trans-unit id="4717590c35f3a3113f7d473dbe7410d944c8d2f4" translate="yes" xml:space="preserve">
          <source>The BRIN interface has a high level of abstraction, requiring the access method implementer only to implement the semantics of the data type being accessed. The BRIN layer itself takes care of concurrency, logging and searching the index structure.</source>
          <target state="translated">BRIN接口具有高度的抽象性,只需要访问方法实现者实现被访问数据类型的语义。BRIN层本身负责并发、日志和搜索索引结构。</target>
        </trans-unit>
        <trans-unit id="12f1f91360cdc7254651ab3db114c105bbc973aa" translate="yes" xml:space="preserve">
          <source>The BRIN operator classes included in the standard distribution are documented in &lt;a href=&quot;brin-builtin-opclasses#BRIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 67.1&lt;/a&gt;. For more information see &lt;a href=&quot;https://www.postgresql.org/docs/12/brin.html&quot;&gt;Chapter 67&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;brin-builtin-opclasses#BRIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;表67.1&lt;/a&gt;中记录了标准分发中包含的BRIN运算符类。有关更多信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/brin.html&quot;&gt;第67章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="81c19a64f78d13b55febf5112697413cfeeb5aad" translate="yes" xml:space="preserve">
          <source>The BRIN operator classes included in the standard distribution are documented in &lt;a href=&quot;brin-builtin-opclasses#BRIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 67.1&lt;/a&gt;. For more information see &lt;a href=&quot;https://www.postgresql.org/docs/13/brin.html&quot;&gt;Chapter 67&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f61d2e62e5b85bf8f1a9692cb79be49a20ae4934" translate="yes" xml:space="preserve">
          <source>The DNS names or IP addresses of the RADIUS servers to connect to. This parameter is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05d73c5606dbc5d228281af7029fd60e51759995" translate="yes" xml:space="preserve">
          <source>The Double Metaphone system computes two &amp;ldquo;sounds like&amp;rdquo; strings for a given input string &amp;mdash; a &amp;ldquo;primary&amp;rdquo; and an &amp;ldquo;alternate&amp;rdquo;. In most cases they are the same, but for non-English names especially they can be a bit different, depending on pronunciation. These functions compute the primary and alternate codes:</source>
          <target state="translated">Double Metaphone系统为给定的输入字符串计算两个&amp;ldquo;类似声音&amp;rdquo;的字符串-&amp;ldquo;主要&amp;rdquo;和&amp;ldquo;替代&amp;rdquo;。在大多数情况下，它们是相同的，但对于非英语名称，尤其是它们，可能会有所不同，具体取决于发音。这些函数计算主代码和备用代码：</target>
        </trans-unit>
        <trans-unit id="c8af7d6c825c894dd0eb03ecb26fae46fecd94c6" translate="yes" xml:space="preserve">
          <source>The Free Space Map is organized as a tree of FSM pages. The bottom level FSM pages store the free space available on each heap (or index) page, using one byte to represent each such page. The upper levels aggregate information from the lower levels.</source>
          <target state="translated">自由空间图被组织成一棵FSM页的树,最底层的FSM页存储了每个堆(或索引)页上的可用空间,用一个字节代表每个这样的页。最底层的FSM页面存储了每个堆(或索引)页面上的可用空间,用一个字节来代表每个这样的页面。上层汇总了下层的信息。</target>
        </trans-unit>
        <trans-unit id="30fb294fef92ba7b2398333f6fd38e60940f0136" translate="yes" xml:space="preserve">
          <source>The GEQO module allows the PostgreSQL query optimizer to support large join queries effectively through non-exhaustive search.</source>
          <target state="translated">GEQO模块允许PostgreSQL查询优化器通过非穷尽性搜索有效地支持大型连接查询。</target>
        </trans-unit>
        <trans-unit id="9943a2120bd9e8c3e6721e67541600ca21fe96fa" translate="yes" xml:space="preserve">
          <source>The GEQO module approaches the query optimization problem as though it were the well-known traveling salesman problem (TSP). Possible query plans are encoded as integer strings. Each string represents the join order from one relation of the query to the next. For example, the join tree</source>
          <target state="translated">GEQO模块对查询优化问题的处理就像著名的旅行推销员问题(TSP)一样。可能的查询计划被编码为整数字符串。每个字符串代表了从一个查询关系到下一个关系的连接顺序。例如,连接树</target>
        </trans-unit>
        <trans-unit id="a13542c5aa9b5acc83ba91d19d31a9262ad99881" translate="yes" xml:space="preserve">
          <source>The GEQO planning process uses the standard planner code to generate plans for scans of individual relations. Then join plans are developed using the genetic approach. As shown above, each candidate join plan is represented by a sequence in which to join the base relations. In the initial stage, the GEQO code simply generates some possible join sequences at random. For each join sequence considered, the standard planner code is invoked to estimate the cost of performing the query using that join sequence. (For each step of the join sequence, all three possible join strategies are considered; and all the initially-determined relation scan plans are available. The estimated cost is the cheapest of these possibilities.) Join sequences with lower estimated cost are considered &amp;ldquo;more fit&amp;rdquo; than those with higher cost. The genetic algorithm discards the least fit candidates. Then new candidates are generated by combining genes of more-fit candidates &amp;mdash; that is, by using randomly-chosen portions of known low-cost join sequences to create new sequences for consideration. This process is repeated until a preset number of join sequences have been considered; then the best one found at any time during the search is used to generate the finished plan.</source>
          <target state="translated">GEQO计划过程使用标准计划者代码生成用于扫描各个关系的计划。然后使用遗传方法制定加盟计划。如上所示，每个候选加入计划由加入基本关系的顺序表示。在初始阶段，GEQO代码只是简单地随机生成一些可能的加入序列。对于所考虑的每个连接序列，调用标准计划程序代码以估计使用该连接序列执行查询的成本。 （对于连接序列的每个步骤，都考虑了所有三种可能的连接策略；并且所有初始确定的关系扫描计划都可用。估计成本是这些可能性中最便宜的。）具有较低估计成本的连接序列被认为&amp;ldquo;更多适合&amp;rdquo;的广告。遗传算法会丢弃最不适合的候选对象。然后，通过组合更适合的候选者的基因来生成新的候选者-也就是说，通过使用已知的低成本连接序列的随机选择部分来创建要考虑的新序列。重复此过程，直到考虑了预设数量的连接序列为止；然后在搜索过程中随时发现的最佳方案将用于生成最终方案。</target>
        </trans-unit>
        <trans-unit id="12d46a50018559dae87055222c8f226b8336aa38" translate="yes" xml:space="preserve">
          <source>The GIN implementation in PostgreSQL is primarily maintained by Teodor Sigaev and Oleg Bartunov. There is more information about GIN on their &lt;a href=&quot;http://www.sai.msu.su/~megera/wiki/Gin&quot;&gt;website&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL中的GIN实现主要由Teodor Sigaev和Oleg Bartunov维护。在他们的&lt;a href=&quot;http://www.sai.msu.su/~megera/wiki/Gin&quot;&gt;网站&lt;/a&gt;上有关于GIN的更多信息。</target>
        </trans-unit>
        <trans-unit id="c2e1dce9027c2870a4be78df483750ab0dd368b7" translate="yes" xml:space="preserve">
          <source>The GIN interface has a high level of abstraction, requiring the access method implementer only to implement the semantics of the data type being accessed. The GIN layer itself takes care of concurrency, logging and searching the tree structure.</source>
          <target state="translated">GIN接口具有高度的抽象性,只需要访问方法实现者实现被访问数据类型的语义。GIN层本身负责并发、日志和搜索树结构。</target>
        </trans-unit>
        <trans-unit id="47e8892c842e09af9d1e34fe3c02e2f04b0f5d8f" translate="yes" xml:space="preserve">
          <source>The GNU Privacy Handbook.</source>
          <target state="translated">GNU隐私手册。</target>
        </trans-unit>
        <trans-unit id="3d32f64c87806d58fdb89cae3ce39c10adecb6af" translate="yes" xml:space="preserve">
          <source>The High Precision Event Timer (HPET) is the preferred timer on systems where it's available and TSC is not accurate. The timer chip itself is programmable to allow up to 100 nanosecond resolution, but you may not see that much accuracy in your system clock.</source>
          <target state="translated">高精度事件定时器(HPET)是系统上的首选定时器,在有它的地方,TSC不准确。定时器芯片本身是可编程的,允许高达100纳秒的分辨率,但你可能不会在系统时钟中看到这么高的精度。</target>
        </trans-unit>
        <trans-unit id="daab10f496a1f89a75df255f2cd5f238cad28e22" translate="yes" xml:space="preserve">
          <source>The IP network address types, &lt;code&gt;cidr&lt;/code&gt; and &lt;code&gt;inet&lt;/code&gt;, support the usual comparison operators shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;Table 9.1&lt;/a&gt; as well as the specialized operators and functions shown in &lt;a href=&quot;functions-net#CIDR-INET-OPERATORS-TABLE&quot;&gt;Table 9.38&lt;/a&gt; and &lt;a href=&quot;functions-net#CIDR-INET-FUNCTIONS-TABLE&quot;&gt;Table 9.39&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db1ae3a20afea53927e5a775df1db6e7daba0537" translate="yes" xml:space="preserve">
          <source>The ISO 8601 week-numbering year that the date falls in (not applicable to intervals)</source>
          <target state="translated">日期所在的ISO 8601周号年(不适用于间隔年)。</target>
        </trans-unit>
        <trans-unit id="a2f552c0c2f33843207363b12ed183813abd32ee" translate="yes" xml:space="preserve">
          <source>The Identification Protocol is not intended as an authorization or access control protocol.</source>
          <target state="translated">识别协议不是作为授权或访问控制协议。</target>
        </trans-unit>
        <trans-unit id="34d3089a14d3fce4ff8f4421c9f8177fa0b6d74c" translate="yes" xml:space="preserve">
          <source>The Institute of Automatic Control at the University of Mining and Technology, in Freiberg, Germany, encountered some problems when it wanted to use PostgreSQL as the backend for a decision support knowledge based system for the maintenance of an electrical power grid. The DBMS needed to handle large join queries for the inference machine of the knowledge based system. The number of joins in these queries made using the normal query optimizer infeasible.</source>
          <target state="translated">位于德国弗莱贝格的矿业大学自动控制研究所在使用PostgreSQL作为决策支持知识系统的后台时遇到了一些问题,该系统用于维护电网。该DBMS需要为知识型系统的推理机处理大量的连接查询。这些查询中的连接数量使得使用普通的查询优化器不可行。</target>
        </trans-unit>
        <trans-unit id="aa9845a0dd3274b254c00b6f19f94269db7f2403" translate="yes" xml:space="preserve">
          <source>The Ispell dictionary template supports &lt;em&gt;morphological dictionaries&lt;/em&gt;, which can normalize many different linguistic forms of a word into the same lexeme. For example, an English Ispell dictionary can match all declensions and conjugations of the search term &lt;code&gt;bank&lt;/code&gt;, e.g., &lt;code&gt;banking&lt;/code&gt;, &lt;code&gt;banked&lt;/code&gt;, &lt;code&gt;banks&lt;/code&gt;, &lt;code&gt;banks'&lt;/code&gt;, and &lt;code&gt;bank's&lt;/code&gt;.</source>
          <target state="translated">Ispell词典模板支持&lt;em&gt;形态词典&lt;/em&gt;，该&lt;em&gt;词典&lt;/em&gt;可以将一个单词的许多不同语言形式规范化为同一个词素。例如，英国的ispell词典可以匹配所有的变格和搜索词的词形 &lt;code&gt;bank&lt;/code&gt; ，如 &lt;code&gt;banking&lt;/code&gt; ， &lt;code&gt;banked&lt;/code&gt; ， &lt;code&gt;banks&lt;/code&gt; ， &lt;code&gt;banks'&lt;/code&gt; 和 &lt;code&gt;bank's&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="282b226a01a92e56fbbd4540780287fee9277216" translate="yes" xml:space="preserve">
          <source>The Julian calendar was introduced by Julius Caesar in 45 BC. It was in common use in the Western world until the year 1582, when countries started changing to the Gregorian calendar. In the Julian calendar, the tropical year is approximated as 365 1/4 days = 365.25 days. This gives an error of about 1 day in 128 years.</source>
          <target state="translated">公元前45年,凯撒大帝推出朱利安历。在1582年之前,西方世界一直在普遍使用,直到1582年各国开始改用格里高利历。在朱利安历中,热带年近似为365 1/4天=365.25天。这样每128年就有1天左右的误差。</target>
        </trans-unit>
        <trans-unit id="2e4c29ef7c0e6bc4328db2d150be07eebedb7c84" translate="yes" xml:space="preserve">
          <source>The LSN at which replay must begin on the indicated timeline in order to make use of this backup. The LSN is stored in the format normally used by PostgreSQL; that is, it is a string consisting of two strings of hexadecimal characters, each with a length of between 1 and 8, separated by a slash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cde8e59b22c9d6c409e59a264cd6d5133433aa8" translate="yes" xml:space="preserve">
          <source>The Locking Clause</source>
          <target state="translated">锁定条款</target>
        </trans-unit>
        <trans-unit id="813d5e4d57613a4c405c690aaab6fce9270d1bf4" translate="yes" xml:space="preserve">
          <source>The MAC address types, &lt;code&gt;macaddr&lt;/code&gt; and &lt;code&gt;macaddr8&lt;/code&gt;, support the usual comparison operators shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;Table 9.1&lt;/a&gt; as well as the specialized functions shown in &lt;a href=&quot;functions-net#MACADDR-FUNCTIONS-TABLE&quot;&gt;Table 9.40&lt;/a&gt;. In addition, they support the bitwise logical operators &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt; (NOT, AND and OR), just as shown above for IP addresses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aaa9a5d10023ba2866dd37afda193155af0f247" translate="yes" xml:space="preserve">
          <source>The MCV list gives the planner more detailed information about the specific values that commonly appear in the table, as well as an upper bound on the selectivities of combinations of values that do not appear in the table, allowing it to generate better estimates in both cases.</source>
          <target state="translated">MCV清单为规划者提供了更详细的信息,说明表格中通常出现的具体数值,以及表格中没有出现的数值组合的选择性上限,使规划者能够在这两种情况下产生更好的估计。</target>
        </trans-unit>
        <trans-unit id="55e485d087fdc5b4b841601869e3bb93e6bf3639" translate="yes" xml:space="preserve">
          <source>The MD5 Message-Digest Algorithm.</source>
          <target state="translated">MD5消息解密算法。</target>
        </trans-unit>
        <trans-unit id="2127ad6c429aa49a235fd761eacdf2db8d6f6769" translate="yes" xml:space="preserve">
          <source>The Nagios plugin check_pgsql will work, because the simple information it checks for exists. The check_postgres monitoring script will also work, though some reported values could give different or confusing results. For example, last vacuum time will not be maintained, since no vacuum occurs on the standby. Vacuums running on the primary do still send their changes to the standby.</source>
          <target state="translated">Nagios插件check_pgsql可以工作,因为它检查的简单信息是存在的。check_postgres监控脚本也可以工作,尽管有些报告的值可能会给出不同的或混乱的结果。例如,最后的真空时间将不会被保留,因为在备用机上没有真空发生。在主设备上运行的真空仍然会将其变化发送到备用设备上。</target>
        </trans-unit>
        <trans-unit id="5e71865447d6bc9ea383afd7d76b7761f19aa1b6" translate="yes" xml:space="preserve">
          <source>The OID alias types do not completely follow transaction isolation rules. The planner also treats them as simple constants, which may result in sub-optimal planning.</source>
          <target state="translated">OID别名类型并不完全遵循事务隔离规则。规划师也将它们视为简单的常量,这可能导致次优规划。</target>
        </trans-unit>
        <trans-unit id="31161126282561c5d74d32ce529fddd65e0a76bd" translate="yes" xml:space="preserve">
          <source>The OID alias types have no operations of their own except for specialized input and output routines. These routines are able to accept and display symbolic names for system objects, rather than the raw numeric value that type &lt;code&gt;oid&lt;/code&gt; would use. The alias types allow simplified lookup of OID values for objects. For example, to examine the &lt;code&gt;pg_attribute&lt;/code&gt; rows related to a table &lt;code&gt;mytable&lt;/code&gt;, one could write:</source>
          <target state="translated">除了专门的输入和输出例程，OID别名类型没有自己的操作。这些例程能够接受和显示系统对象的符号名称，而不是 &lt;code&gt;oid&lt;/code&gt; 类型将使用的原始数值。别名类型允许简化对象的OID值查找。例如，要检查与表 &lt;code&gt;mytable&lt;/code&gt; 相关的 &lt;code&gt;pg_attribute&lt;/code&gt; 行，可以编写：</target>
        </trans-unit>
        <trans-unit id="1f728998e1513edf5bb0f58e995427e26f8967db" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_class&lt;/code&gt; entry for the default partition of this partitioned table, or zero if this partitioned table does not have a default partition.</source>
          <target state="translated">此分区表的默认分区的 &lt;code&gt;pg_class&lt;/code&gt; 条目的OID；如果此分区表没有默认分区，则为零。</target>
        </trans-unit>
        <trans-unit id="0e41c17d955ca3267fc3e0f5f9ba923e41ea0513" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_class&lt;/code&gt; entry for the table this index is for</source>
          <target state="translated">该索引用于的表的 &lt;code&gt;pg_class&lt;/code&gt; 条目的OID</target>
        </trans-unit>
        <trans-unit id="071dd0d457f9f27d9bee0d2e3ff6291a6f564862" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_class&lt;/code&gt; entry for this index</source>
          <target state="translated">该索引的 &lt;code&gt;pg_class&lt;/code&gt; 条目的OID</target>
        </trans-unit>
        <trans-unit id="f5a48c524de61d425315c3640ed2f8c5273484e3" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_class&lt;/code&gt; entry for this partitioned table</source>
          <target state="translated">此分区表的 &lt;code&gt;pg_class&lt;/code&gt; 条目的OID</target>
        </trans-unit>
        <trans-unit id="eda438d49a92e642ba61a005c3405da4f9f1c62a" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_class&lt;/code&gt; entry for this sequence</source>
          <target state="translated">此序列的 &lt;code&gt;pg_class&lt;/code&gt; 条目的OID</target>
        </trans-unit>
        <trans-unit id="303197c3c31b1c60eee9019793731af72e0dc006" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_ts_config&lt;/code&gt; entry owning this map entry</source>
          <target state="translated">拥有此映射条目的 &lt;code&gt;pg_ts_config&lt;/code&gt; 条目的OID</target>
        </trans-unit>
        <trans-unit id="f8bdb5895be29901070dfef3e22b4e60f7c2d267" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_type&lt;/code&gt; entry owning this enum value</source>
          <target state="translated">拥有该枚举值的 &lt;code&gt;pg_type&lt;/code&gt; 条目的OID</target>
        </trans-unit>
        <trans-unit id="a977c33ead1b2b309c764b95248966dbf41f0217" translate="yes" xml:space="preserve">
          <source>The OID of the child table</source>
          <target state="translated">子表的OID</target>
        </trans-unit>
        <trans-unit id="fcb128bef4bb51d558b2cbbe176487c983a3358d" translate="yes" xml:space="preserve">
          <source>The OID of the child table or index</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ebd50be09b18866cd4d57833179194c831f037b" translate="yes" xml:space="preserve">
          <source>The OID of the data type that corresponds to this table's row type, if any (zero for indexes, which have no &lt;code&gt;pg_type&lt;/code&gt; entry)</source>
          <target state="translated">与此表的行类型相对应的数据类型的OID（如果有）（对于索引，该值为零，其中没有 &lt;code&gt;pg_type&lt;/code&gt; 条目）</target>
        </trans-unit>
        <trans-unit id="b8b4662cb4e6288ca284849c4be148da66825b82" translate="yes" xml:space="preserve">
          <source>The OID of the database the dependent object is in, or zero for a shared object</source>
          <target state="translated">从属对象所在数据库的OID,如果是共享对象,则为0。</target>
        </trans-unit>
        <trans-unit id="898b60ec7f694b0fc006eda8e50f6b63d49620a6" translate="yes" xml:space="preserve">
          <source>The OID of the database the setting is applicable to, or zero if not database-specific</source>
          <target state="translated">设置所适用的数据库的OID,如果不是数据库专用,则为零。</target>
        </trans-unit>
        <trans-unit id="61af788beaa116f1b955c318390c380729eb624f" translate="yes" xml:space="preserve">
          <source>The OID of the database this slot is associated with, or null. Only logical slots have an associated database.</source>
          <target state="translated">这个槽所关联的数据库的OID,或者为空。只有逻辑槽才有关联的数据库。</target>
        </trans-unit>
        <trans-unit id="dffe34cbcb64c59bdcb3677d3a1fd7a1a7165871" translate="yes" xml:space="preserve">
          <source>The OID of the foreign server that contains this mapping</source>
          <target state="translated">包含此映射的国外服务器的OID。</target>
        </trans-unit>
        <trans-unit id="5048d68506cd122e63f767db512f5ebd84d67ed5" translate="yes" xml:space="preserve">
          <source>The OID of the function to use to perform this cast. Zero is stored if the cast method doesn't require a function.</source>
          <target state="translated">用于执行投射方法的函数的OID。如果投射方法不需要函数,则存储为零。</target>
        </trans-unit>
        <trans-unit id="59c37f70d3d21e1cf2530f6e69c1cd78c664862f" translate="yes" xml:space="preserve">
          <source>The OID of the function to use when converting output from the procedural language (e.g., return values) to the data type. Zero is stored if this operation is not supported.</source>
          <target state="translated">将程序语言的输出(例如,返回值)转换为数据类型时要使用的函数的OID。如果不支持该操作,则存储为零。</target>
        </trans-unit>
        <trans-unit id="b438ec49041a86ff7da5085d6d696fab9858a564" translate="yes" xml:space="preserve">
          <source>The OID of the function to use when converting the data type for input to the procedural language (e.g., function parameters). Zero is stored if this operation is not supported.</source>
          <target state="translated">将输入的数据类型转换为程序语言(如函数参数)时要使用的函数的OID。如果不支持该操作,则存储为零。</target>
        </trans-unit>
        <trans-unit id="8427c56037bb672e3eaf5c784fadd5373d00c50d" translate="yes" xml:space="preserve">
          <source>The OID of the large object.</source>
          <target state="translated">大对象的OID。</target>
        </trans-unit>
        <trans-unit id="aa257a5cc909f035b6b365a8de79171496abef73" translate="yes" xml:space="preserve">
          <source>The OID of the namespace associated with this entry, or 0 if none</source>
          <target state="translated">与此条目相关联的命名空间的OID,如果没有,则为0。</target>
        </trans-unit>
        <trans-unit id="3c9f55892a56c80828f11ba8da0cec8b6667ea0f" translate="yes" xml:space="preserve">
          <source>The OID of the namespace for this object, if applicable; otherwise NULL.</source>
          <target state="translated">该对象的命名空间的OID,如果适用;否则为NULL。</target>
        </trans-unit>
        <trans-unit id="6544239c27c8b98d678c4d86cd8cf2fb4a45d909" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this collation</source>
          <target state="translated">包含此整理的命名空间的OID。</target>
        </trans-unit>
        <trans-unit id="67632f7b86c5d28c986c07563f79e9f57ab7488a" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this configuration</source>
          <target state="translated">包含此配置的命名空间的OID。</target>
        </trans-unit>
        <trans-unit id="f78b68f0e0d540debab34518ee53138dd78afc9d" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this constraint</source>
          <target state="translated">包含该约束的命名空间的OID。</target>
        </trans-unit>
        <trans-unit id="26651bac2ebe9b8df63182bb4f09e8b29d4375b5" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this conversion</source>
          <target state="translated">包含此次转换的命名空间的OID。</target>
        </trans-unit>
        <trans-unit id="58fcc7c98890e8c2834e53212732cd77ac260148" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this dictionary</source>
          <target state="translated">包含此字典的命名空间的OID。</target>
        </trans-unit>
        <trans-unit id="0ffa036dc5da9392b5ff92b8de19382988ae095b" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this function</source>
          <target state="translated">包含该函数的命名空间的OID。</target>
        </trans-unit>
        <trans-unit id="4836cfb15733aecb9038935daa22b144847fa0b0" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this operator</source>
          <target state="translated">包含该操作者的命名空间的OID。</target>
        </trans-unit>
        <trans-unit id="bd2956b2c54813a0f702f1bbd1860a3130d1cd13" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this parser</source>
          <target state="translated">包含该解析器的命名空间的OID。</target>
        </trans-unit>
        <trans-unit id="4fa4ff9a62cc6b391718b0f0a2fcbd7ba489a8a1" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this relation</source>
          <target state="translated">包含此关系的命名空间的OID。</target>
        </trans-unit>
        <trans-unit id="f3b00f8f6b6908679ca83ef8448db4669f9c3f2b" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this statistics object</source>
          <target state="translated">包含该统计对象的命名空间的OID。</target>
        </trans-unit>
        <trans-unit id="0eccd6202b6e25a82e3cb731c01941486b802fde" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this template</source>
          <target state="translated">包含该模板的命名空间的OID。</target>
        </trans-unit>
        <trans-unit id="2ad5e85b9c67d0c9e6855e2f98983c857e3e9cc9" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this type</source>
          <target state="translated">包含此类型的命名空间的OID。</target>
        </trans-unit>
        <trans-unit id="4da576b45acb3f961f666fac031b8e0b7887d94a" translate="yes" xml:space="preserve">
          <source>The OID of the object this description pertains to</source>
          <target state="translated">该描述所涉及的对象的OID。</target>
        </trans-unit>
        <trans-unit id="92fb8b43568522d54e99e8435ff353f995d4d31c" translate="yes" xml:space="preserve">
          <source>The OID of the object this security label pertains to</source>
          <target state="translated">该安全标签所对应的对象的OID。</target>
        </trans-unit>
        <trans-unit id="0002c6e72af222de4cb8c506a6f1bc7c20ab1dc4" translate="yes" xml:space="preserve">
          <source>The OID of the parent table</source>
          <target state="translated">父表的OID</target>
        </trans-unit>
        <trans-unit id="2b333512ca9c37807a07a256f4818991b100a615" translate="yes" xml:space="preserve">
          <source>The OID of the parent table or index</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5ffd02286699ef3905e8a972c66ee4bb2835bfc" translate="yes" xml:space="preserve">
          <source>The OID of the role associated with this entry</source>
          <target state="translated">与此条目相关的角色的OID。</target>
        </trans-unit>
        <trans-unit id="c0915654e58b310d5210b25d19abfd7806a843de" translate="yes" xml:space="preserve">
          <source>The OID of the role the setting is applicable to, or zero if not role-specific</source>
          <target state="translated">设置所适用的角色的OID,如果不是特定角色,则为0。</target>
        </trans-unit>
        <trans-unit id="c9f3ec9e29e6e5e35e198f85cfeb26802f0a6d99" translate="yes" xml:space="preserve">
          <source>The OID of the specific dependent object</source>
          <target state="translated">特定从属对象的OID</target>
        </trans-unit>
        <trans-unit id="b9087659abb5a8df685a282e464694231a05c905" translate="yes" xml:space="preserve">
          <source>The OID of the specific object</source>
          <target state="translated">特定对象的OID</target>
        </trans-unit>
        <trans-unit id="9442b82a85ff19f9d0307346795cdb1c1390d555" translate="yes" xml:space="preserve">
          <source>The OID of the specific referenced object</source>
          <target state="translated">特定引用对象的OID</target>
        </trans-unit>
        <trans-unit id="3b6fda1c623aa2d59a074893167f643c66f63048" translate="yes" xml:space="preserve">
          <source>The OID of the system catalog the dependent object is in</source>
          <target state="translated">从属对象所在的系统目录的OID。</target>
        </trans-unit>
        <trans-unit id="45c628ea8dfbe9deffe2a6beca65b182150c549a" translate="yes" xml:space="preserve">
          <source>The OID of the system catalog the object is in</source>
          <target state="translated">对象所在的系统目录的OID。</target>
        </trans-unit>
        <trans-unit id="651df0c1a82da14b1a69c5c748c986ddebc8aa71" translate="yes" xml:space="preserve">
          <source>The OID of the system catalog the referenced object is in</source>
          <target state="translated">被引用对象所在的系统目录的OID。</target>
        </trans-unit>
        <trans-unit id="b623975e8da0f35427faa44f2916bd8169911114" translate="yes" xml:space="preserve">
          <source>The OID of the system catalog the referenced object is in (must be a shared catalog)</source>
          <target state="translated">被引用对象所在的系统目录的OID(必须是共享目录)。</target>
        </trans-unit>
        <trans-unit id="d29abf904f17279c11d42dc4f5568269360fdcb9" translate="yes" xml:space="preserve">
          <source>The OID of the system catalog this object appears in</source>
          <target state="translated">此对象出现在系统目录中的OID。</target>
        </trans-unit>
        <trans-unit id="067e884e18cd2aa571279cd559f882f0cf4ff2a1" translate="yes" xml:space="preserve">
          <source>The OID of the table containing this row. This column is particularly handy for queries that select from inheritance hierarchies (see &lt;a href=&quot;ddl-inherit&quot;&gt;Section 5.10&lt;/a&gt;), since without it, it's difficult to tell which individual table a row came from. The &lt;code&gt;tableoid&lt;/code&gt; can be joined against the &lt;code&gt;oid&lt;/code&gt; column of &lt;code&gt;pg_class&lt;/code&gt; to obtain the table name.</source>
          <target state="translated">包含该行的表的OID。对于从继承层次结构中选择的查询，此列特别方便（请参阅&lt;a href=&quot;ddl-inherit&quot;&gt;5.10节&lt;/a&gt;），因为如果没有它，则很难确定一行来自哪个表。所述 &lt;code&gt;tableoid&lt;/code&gt; 可以针对待接合 &lt;code&gt;oid&lt;/code&gt; 的柱 &lt;code&gt;pg_class&lt;/code&gt; 以获得表名。</target>
        </trans-unit>
        <trans-unit id="6a0b9e6d63b6cf8a833e5a7e3f6047bb0a93a945" translate="yes" xml:space="preserve">
          <source>The OID of the text search dictionary to consult</source>
          <target state="translated">要查询的文本搜索词典的OID。</target>
        </trans-unit>
        <trans-unit id="b6ba84785ad334e01b83ec445d3dda1ac4ac96bb" translate="yes" xml:space="preserve">
          <source>The OID of the text search parser for this configuration</source>
          <target state="translated">此配置的文本搜索解析器的OID。</target>
        </trans-unit>
        <trans-unit id="a117213bd13a98b62f97b549d2037dd5baede006" translate="yes" xml:space="preserve">
          <source>The OID of the text search template for this dictionary</source>
          <target state="translated">该字典的文本搜索模板的OID。</target>
        </trans-unit>
        <trans-unit id="58df61b40061f6a6618e8266483da7f989d95f26" translate="yes" xml:space="preserve">
          <source>The OIDs for &lt;code&gt;pg_enum&lt;/code&gt; rows follow a special rule: even-numbered OIDs are guaranteed to be ordered in the same way as the sort ordering of their enum type. That is, if two even OIDs belong to the same enum type, the smaller OID must have the smaller &lt;code&gt;enumsortorder&lt;/code&gt; value. Odd-numbered OID values need bear no relationship to the sort order. This rule allows the enum comparison routines to avoid catalog lookups in many common cases. The routines that create and alter enum types attempt to assign even OIDs to enum values whenever possible.</source>
          <target state="translated">&lt;code&gt;pg_enum&lt;/code&gt; 行的OID 遵循一条特殊的规则：偶数编号的OID保证以与其枚举类型的排序顺序相同的方式进行排序。也就是说，如果两个偶数OID属于相同的枚举类型，则较小的OID必须具有较小的 &lt;code&gt;enumsortorder&lt;/code&gt; 值。奇数编号的OID值无需与排序顺序有关。此规则使枚举比较例程可以避免在许多常见情况下进行目录查找。创建和更改枚举类型的例程在可能的情况下会尝试甚至将OID分配给枚举值。</target>
        </trans-unit>
        <trans-unit id="362f3646de7e2bebf05ad74a6325f7165ac1988c" translate="yes" xml:space="preserve">
          <source>The OpenSSL default order for &lt;code&gt;HIGH&lt;/code&gt; is problematic because it orders 3DES higher than AES128. This is wrong because 3DES offers less security than AES128, and it is also much slower. &lt;code&gt;+3DES&lt;/code&gt; reorders it after all other &lt;code&gt;HIGH&lt;/code&gt; and &lt;code&gt;MEDIUM&lt;/code&gt; ciphers.</source>
          <target state="translated">&lt;code&gt;HIGH&lt;/code&gt; 的OpenSSL默认顺序是有问题的，因为它比AES128高3DES。这是错误的，因为3DES提供的安全性低于AES128，并且速度也慢得多。 &lt;code&gt;+3DES&lt;/code&gt; 重新排序所有其他后 &lt;code&gt;HIGH&lt;/code&gt; 和 &lt;code&gt;MEDIUM&lt;/code&gt; 密码。</target>
        </trans-unit>
        <trans-unit id="b73c1bd60aad8104323371d01b1ec1a8338ede73" translate="yes" xml:space="preserve">
          <source>The Oversized-Attribute Storage Technique</source>
          <target state="translated">超大属性存储技术</target>
        </trans-unit>
        <trans-unit id="e0b1bfcde4d47951e13640eda18c565a127fb8e6" translate="yes" xml:space="preserve">
          <source>The POSIX pattern language is described in much greater detail below.</source>
          <target state="translated">下面将详细介绍POSIX模式语言。</target>
        </trans-unit>
        <trans-unit id="153ece47c4d9b24a5da118c8706404d098e93a76" translate="yes" xml:space="preserve">
          <source>The PostgreSQL &lt;code&gt;xml&lt;/code&gt; data type can only hold a value in &lt;code&gt;DOCUMENT&lt;/code&gt; or &lt;code&gt;CONTENT&lt;/code&gt; form. An XQuery/XPath expression context item must be a single XML node or atomic value, but XPath 1.0 further restricts it to be only an XML node, and has no node type allowing &lt;code&gt;CONTENT&lt;/code&gt;. The upshot is that a well-formed &lt;code&gt;DOCUMENT&lt;/code&gt; is the only form of XML value that PostgreSQL can supply as an XPath context item.</source>
          <target state="translated">PostgreSQL &lt;code&gt;xml&lt;/code&gt; 数据类型只能保存 &lt;code&gt;DOCUMENT&lt;/code&gt; 或 &lt;code&gt;CONTENT&lt;/code&gt; 形式的值。XQuery / XPath表达式上下文项必须是单个XML节点或原子值，但是XPath 1.0进一步将其限制为仅是XML节点，并且没有允许 &lt;code&gt;CONTENT&lt;/code&gt; 的节点类型。结果是格式正确的 &lt;code&gt;DOCUMENT&lt;/code&gt; 是PostgreSQL可以作为XPath上下文项提供的XML值的唯一形式。</target>
        </trans-unit>
        <trans-unit id="8019e62373b33be0ae1394da9ad186299d75d149" translate="yes" xml:space="preserve">
          <source>The PostgreSQL concept of tablespaces is not part of the standard. Hence, the clause &lt;code&gt;TABLESPACE&lt;/code&gt; is an extension.</source>
          <target state="translated">PostgreSQL表空间的概念不是标准的一部分。因此，子句 &lt;code&gt;TABLESPACE&lt;/code&gt; 是扩展。</target>
        </trans-unit>
        <trans-unit id="36ca8d540410a034c5a8f32708649004d256e17f" translate="yes" xml:space="preserve">
          <source>The PostgreSQL concept of tablespaces is not part of the standard. Hence, the clauses &lt;code&gt;TABLESPACE&lt;/code&gt; and &lt;code&gt;USING INDEX TABLESPACE&lt;/code&gt; are extensions.</source>
          <target state="translated">PostgreSQL表空间的概念不是标准的一部分。因此，子句 &lt;code&gt;TABLESPACE&lt;/code&gt; 和 &lt;code&gt;USING INDEX TABLESPACE&lt;/code&gt; 是扩展。</target>
        </trans-unit>
        <trans-unit id="74677c1410d0f3c49eba1a7361732a37abea01cf" translate="yes" xml:space="preserve">
          <source>The PostgreSQL formatting functions provide a powerful set of tools for converting various data types (date/time, integer, floating point, numeric) to formatted strings and for converting from formatted strings to specific data types. &lt;a href=&quot;functions-formatting#FUNCTIONS-FORMATTING-TABLE&quot;&gt;Table 9.24&lt;/a&gt; lists them. These functions all follow a common calling convention: the first argument is the value to be formatted and the second argument is a template that defines the output or input format.</source>
          <target state="translated">PostgreSQL格式化功能提供了一套功能强大的工具，用于将各种数据类型（日期/时间，整数，浮点数，数字）转换为格式化字符串，以及从格式化字符串转换为特定数据类型。&lt;a href=&quot;functions-formatting#FUNCTIONS-FORMATTING-TABLE&quot;&gt;表9.24&lt;/a&gt;列出了它们。这些函数都遵循一个通用的调用约定：第一个参数是要格式化的值，第二个参数是定义输出或输入格式的模板。</target>
        </trans-unit>
        <trans-unit id="d0224dd17eece7d6f08f80bf4f5c518add98b147" translate="yes" xml:space="preserve">
          <source>The PostgreSQL formatting functions provide a powerful set of tools for converting various data types (date/time, integer, floating point, numeric) to formatted strings and for converting from formatted strings to specific data types. &lt;a href=&quot;functions-formatting#FUNCTIONS-FORMATTING-TABLE&quot;&gt;Table 9.25&lt;/a&gt; lists them. These functions all follow a common calling convention: the first argument is the value to be formatted and the second argument is a template that defines the output or input format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="477d95f901512677a235f7ee46a8f81ecd4001b6" translate="yes" xml:space="preserve">
          <source>The PostgreSQL operator catalog has several entries for the infix operator &lt;code&gt;&amp;lt;@&lt;/code&gt;, but the only two that could possibly accept an integer array on the left-hand side are array inclusion (&lt;code&gt;anyarray&lt;/code&gt;&lt;code&gt;&amp;lt;@&lt;/code&gt;&lt;code&gt;anyarray&lt;/code&gt;) and range inclusion (&lt;code&gt;anyelement&lt;/code&gt;&lt;code&gt;&amp;lt;@&lt;/code&gt;&lt;code&gt;anyrange&lt;/code&gt;). Since none of these polymorphic pseudo-types (see &lt;a href=&quot;datatype-pseudo&quot;&gt;Section 8.21&lt;/a&gt;) are considered preferred, the parser cannot resolve the ambiguity on that basis. However, &lt;a href=&quot;typeconv-oper#OP-RESOL-LAST-UNKNOWN&quot;&gt;Step 3.f&lt;/a&gt; tells it to assume that the unknown-type literal is of the same type as the other input, that is, integer array. Now only one of the two operators can match, so array inclusion is selected. (Had range inclusion been selected, we would have gotten an error, because the string does not have the right format to be a range literal.)</source>
          <target state="translated">PostgreSQL运算符目录中有几个用于infix运算符 &lt;code&gt;&amp;lt;@&lt;/code&gt; 的条目，但是在左侧可能仅有的两个可以接受整数数组的条目是数组包含（ &lt;code&gt;anyarray&lt;/code&gt; &lt;code&gt;&amp;lt;@&lt;/code&gt; &lt;code&gt;anyarray&lt;/code&gt; ）和范围包含（ &lt;code&gt;anyelement&lt;/code&gt; &lt;code&gt;&amp;lt;@&lt;/code&gt; &lt;code&gt;anyrange&lt;/code&gt; ）。由于这些多态伪类型（请参见&lt;a href=&quot;datatype-pseudo&quot;&gt;第8.21节&lt;/a&gt;）均不被视为首选，因此解析器无法在此基础上解决歧义。但是，&lt;a href=&quot;typeconv-oper#OP-RESOL-LAST-UNKNOWN&quot;&gt;步骤3.f&lt;/a&gt;告诉它假定未知类型文字与其他输入（即整数数组）具有相同的类型。现在，只有两个运算符之一可以匹配，因此选择了数组包含。（如果选择了范围内包含，我们将得到一个错误，因为字符串的格式不正确，不能作为范围文字。）</target>
        </trans-unit>
        <trans-unit id="7623f7756c9bed57d74564163e6b686074d22548" translate="yes" xml:space="preserve">
          <source>The PostgreSQL operator catalog has several entries for the prefix operator &lt;code&gt;@&lt;/code&gt;, all of which implement absolute-value operations for various numeric data types. One of these entries is for type &lt;code&gt;float8&lt;/code&gt;, which is the preferred type in the numeric category. Therefore, PostgreSQL will use that entry when faced with an &lt;code&gt;unknown&lt;/code&gt; input:</source>
          <target state="translated">PostgreSQL运算符目录中有几个前缀运算符 &lt;code&gt;@&lt;/code&gt; 的条目，所有条目都对各种数字数据类型实现绝对值运算。这些条目之一是类型 &lt;code&gt;float8&lt;/code&gt; ，这是数字类别中的首选类型。因此，当面对 &lt;code&gt;unknown&lt;/code&gt; 输入时，PostgreSQL将使用该条目：</target>
        </trans-unit>
        <trans-unit id="0de6cec8150a5ca1beb884d1dae8f1be83758f61" translate="yes" xml:space="preserve">
          <source>The PostgreSQL query planner relies on statistical information about the contents of tables in order to generate good plans for queries. These statistics are gathered by the &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; command, which can be invoked by itself or as an optional step in &lt;code&gt;VACUUM&lt;/code&gt;. It is important to have reasonably accurate statistics, otherwise poor choices of plans might degrade database performance.</source>
          <target state="translated">PostgreSQL查询计划程序依靠有关表内容的统计信息来生成良好的查询计划。这些统计信息由&lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt;命令收集，该命令可以单独调用，也可以作为 &lt;code&gt;VACUUM&lt;/code&gt; 中的可选步骤调用。拥有合理准确的统计信息很重要，否则计划选择不当可能会降低数据库性能。</target>
        </trans-unit>
        <trans-unit id="091f965ebb32941711ea5df90e349daf215494b9" translate="yes" xml:space="preserve">
          <source>The PostgreSQL rule system allows one to define an alternative action to be performed on insertions, updates, or deletions in database tables. Roughly speaking, a rule causes additional commands to be executed when a given command on a given table is executed. Alternatively, an &lt;code&gt;INSTEAD&lt;/code&gt; rule can replace a given command by another, or cause a command not to be executed at all. Rules are used to implement SQL views as well. It is important to realize that a rule is really a command transformation mechanism, or command macro. The transformation happens before the execution of the command starts. If you actually want an operation that fires independently for each physical row, you probably want to use a trigger, not a rule. More information about the rules system is in &lt;a href=&quot;https://www.postgresql.org/docs/12/rules.html&quot;&gt;Chapter 40&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL规则系统允许定义对数据库表中的插入，更新或删除执行的另一种操作。粗略地说，当执行给定表上的给定命令时，规则会导致执行其他命令。或者，一个 &lt;code&gt;INSTEAD&lt;/code&gt; 规则可以用另一个命令替换给定命令，或者根本不执行命令。规则也用于实现SQL视图。重要的是要意识到规则实际上是命令转换机制或命令宏。转换发生在命令执行开始之前。如果您实际上希望为每个物理行独立触发的操作，则可能要使用触发器而不是规则。有关规则系统的更多信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/rules.html&quot;&gt;第40章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0e154a2cce3e777e6a59136969a3016037e9c1d8" translate="yes" xml:space="preserve">
          <source>The PostgreSQL rule system allows one to define an alternative action to be performed on insertions, updates, or deletions in database tables. Roughly speaking, a rule causes additional commands to be executed when a given command on a given table is executed. Alternatively, an &lt;code&gt;INSTEAD&lt;/code&gt; rule can replace a given command by another, or cause a command not to be executed at all. Rules are used to implement SQL views as well. It is important to realize that a rule is really a command transformation mechanism, or command macro. The transformation happens before the execution of the command starts. If you actually want an operation that fires independently for each physical row, you probably want to use a trigger, not a rule. More information about the rules system is in &lt;a href=&quot;https://www.postgresql.org/docs/13/rules.html&quot;&gt;Chapter 40&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10a690ef1ea7666469e6c355dbc334d6d1d70eb6" translate="yes" xml:space="preserve">
          <source>The PostgreSQL scanner/parser divides lexical elements into five fundamental categories: integers, non-integer numbers, strings, identifiers, and key words. Constants of most non-numeric types are first classified as strings. The SQL language definition allows specifying type names with strings, and this mechanism can be used in PostgreSQL to start the parser down the correct path. For example, the query:</source>
          <target state="translated">PostgreSQL扫描器/解析器将词汇元素分为五个基本类别:整数、非整数、字符串、标识符和关键词。大多数非数字类型的常量首先被划分为字符串。SQL语言定义允许用字符串来指定类型名,在PostgreSQL中可以使用这种机制来启动解析器的正确路径。例如,查询。</target>
        </trans-unit>
        <trans-unit id="b6aed6106f2d7424b2bbb821dba77f382392bc5d" translate="yes" xml:space="preserve">
          <source>The PostgreSQL server can handle multiple concurrent connections from clients. To achieve this it starts (&amp;ldquo;forks&amp;rdquo;) a new process for each connection. From that point on, the client and the new server process communicate without intervention by the original &lt;code&gt;postgres&lt;/code&gt; process. Thus, the master server process is always running, waiting for client connections, whereas client and associated server processes come and go. (All of this is of course invisible to the user. We only mention it here for completeness.)</source>
          <target state="translated">PostgreSQL服务器可以处理来自客户端的多个并发连接。为此，它为每个连接启动（&amp;ldquo;分叉&amp;rdquo;）新过程。从那时起，客户端和新服务器进程进行通信，而无需原始 &lt;code&gt;postgres&lt;/code&gt; 进程进行干预。因此，主服务器进程始终在运行，等待客户端连接，而客户端和关联的服务器进程来来往往。 （当然，所有这些对于用户都是不可见的。为了完整起见，我们在这里只提及它。）</target>
        </trans-unit>
        <trans-unit id="7af0f9ca01829c95b3c4cfa20671b04ccaa7a1b4" translate="yes" xml:space="preserve">
          <source>The PostgreSQL server uses one process per connection so you should provide for at least as many processes as allowed connections, in addition to what you need for the rest of your system. This is usually not a problem but if you run several servers on one machine things might get tight.</source>
          <target state="translated">PostgreSQL服务器在每个连接上使用一个进程,所以除了系统其他部分所需的进程外,你至少应该为允许的连接提供相同数量的进程。这通常不是一个问题,但如果你在一台机器上运行几个服务器,事情可能会变得紧张。</target>
        </trans-unit>
        <trans-unit id="929274b54effcc47ded1784455530166b7871347" translate="yes" xml:space="preserve">
          <source>The PostgreSQL server will listen for both normal and GSSAPI-encrypted connections on the same TCP port, and will negotiate with any connecting client on whether to use GSSAPI for encryption (and for authentication). By default, this decision is up to the client (which means it can be downgraded by an attacker); see &lt;a href=&quot;auth-pg-hba-conf&quot;&gt;Section 20.1&lt;/a&gt; about setting up the server to require the use of GSSAPI for some or all connections.</source>
          <target state="translated">PostgreSQL服务器将侦听同一TCP端口上的常规连接和GSSAPI加密的连接，并将与任何连接的客户端协商是否使用GSSAPI进行加密（和身份验证）。默认情况下，此决定由客户端决定（这意味着攻击者可以降级该决定）；有关设置服务器以要求对某些或所有连接使用GSSAPI的信息，请参见&lt;a href=&quot;auth-pg-hba-conf&quot;&gt;第20.1节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c912054f27c4ee7b0f1b38b55011027ea73de0d0" translate="yes" xml:space="preserve">
          <source>The PostgreSQL server will listen for both normal and GSSAPI-encrypted connections on the same TCP port, and will negotiate with any connecting client whether to use GSSAPI for encryption (and for authentication). By default, this decision is up to the client (which means it can be downgraded by an attacker); see &lt;a href=&quot;auth-pg-hba-conf&quot;&gt;Section 20.1&lt;/a&gt; about setting up the server to require the use of GSSAPI for some or all connections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4cf80f6b7604fb8b47859e4bbfb35130b5f3d5d" translate="yes" xml:space="preserve">
          <source>The PostgreSQL source distribution includes several examples of index methods implemented using GiST. The core system currently provides text search support (indexing for &lt;code&gt;tsvector&lt;/code&gt; and &lt;code&gt;tsquery&lt;/code&gt;) as well as R-Tree equivalent functionality for some of the built-in geometric data types (see &lt;code&gt;src/backend/access/gist/gistproc.c&lt;/code&gt;). The following &lt;code&gt;contrib&lt;/code&gt; modules also contain GiST operator classes:</source>
          <target state="translated">PostgreSQL源代码发行版包含使用GiST实现的索引方法的几个示例。核心系统当前为某些内置几何数据类型提供文本搜索支持（为 &lt;code&gt;tsvector&lt;/code&gt; 和 &lt;code&gt;tsquery&lt;/code&gt; 编制索引）以及R-Tree等效功能（请参阅 &lt;code&gt;src/backend/access/gist/gistproc.c&lt;/code&gt; ）。以下 &lt;code&gt;contrib&lt;/code&gt; 模块还包含GiST运算符类：</target>
        </trans-unit>
        <trans-unit id="f0456fd311416d751f4442303736e9783a5f29ea" translate="yes" xml:space="preserve">
          <source>The PostgreSQL source distribution includes several examples of index operator classes for SP-GiST, as described in &lt;a href=&quot;spgist-builtin-opclasses#SPGIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 65.1&lt;/a&gt;. Look into &lt;code&gt;src/backend/access/spgist/&lt;/code&gt; and &lt;code&gt;src/backend/utils/adt/&lt;/code&gt; to see the code.</source>
          <target state="translated">PostgreSQL源发行版包含SP-GiST的索引运算符类的几个示例，如&lt;a href=&quot;spgist-builtin-opclasses#SPGIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;表65.1中所述&lt;/a&gt;。查看 &lt;code&gt;src/backend/access/spgist/&lt;/code&gt; 和 &lt;code&gt;src/backend/utils/adt/&lt;/code&gt; 来查看代码。</target>
        </trans-unit>
        <trans-unit id="da6bb87f4fbef7ca2cd7285a5ff15baca5680b91" translate="yes" xml:space="preserve">
          <source>The PostgreSQL type system contains a number of special-purpose entries that are collectively called &lt;em&gt;pseudo-types&lt;/em&gt;. A pseudo-type cannot be used as a column data type, but it can be used to declare a function's argument or result type. Each of the available pseudo-types is useful in situations where a function's behavior does not correspond to simply taking or returning a value of a specific SQL data type. &lt;a href=&quot;datatype-pseudo#DATATYPE-PSEUDOTYPES-TABLE&quot;&gt;Table 8.27&lt;/a&gt; lists the existing pseudo-types.</source>
          <target state="translated">PostgreSQL类型系统包含许多专用条目，这些条目统称为&lt;em&gt;伪类型&lt;/em&gt;。伪类型不能用作列数据类型，但可以用来声明函数的参数或结果类型。每种可用的伪类型在函数的行为不仅仅与简单地获取或返回特定SQL数据类型的值相对应的情况下很有用。&lt;a href=&quot;datatype-pseudo#DATATYPE-PSEUDOTYPES-TABLE&quot;&gt;表8.27&lt;/a&gt;列出了现有的伪类型。</target>
        </trans-unit>
        <trans-unit id="3627ccc448cafae762325bbb25d1d00e8338b2f1" translate="yes" xml:space="preserve">
          <source>The PostgreSQL-specific functions &lt;code&gt;xpath()&lt;/code&gt; and &lt;code&gt;xpath_exists()&lt;/code&gt; query XML documents using the XPath language. PostgreSQL also provides XPath-only variants of the standard functions &lt;code&gt;XMLEXISTS&lt;/code&gt; and &lt;code&gt;XMLTABLE&lt;/code&gt;, which officially use the XQuery language. For all of these functions, PostgreSQL relies on the libxml2 library, which provides only XPath 1.0.</source>
          <target state="translated">PostgreSQL特定的函数 &lt;code&gt;xpath()&lt;/code&gt; 和 &lt;code&gt;xpath_exists()&lt;/code&gt; 使用XPath语言查询XML文档。 PostgreSQL还提供了标准函数 &lt;code&gt;XMLEXISTS&lt;/code&gt; 和 &lt;code&gt;XMLTABLE&lt;/code&gt; 的仅XPath变体，它们正式使用XQuery语言。对于所有这些功能，PostgreSQL都依靠libxml2库，该库仅提供XPath 1.0。</target>
        </trans-unit>
        <trans-unit id="efd965ec5103a44f1272738f66a9e9d5dd0aabd5" translate="yes" xml:space="preserve">
          <source>The ROW keyword is actually optional as long as you have more than one field in the expression, so these can be simplified to:</source>
          <target state="translated">ROW关键字其实是可选的,只要你在表达式中有多个字段,所以这些可以简化为。</target>
        </trans-unit>
        <trans-unit id="4adee7e95f5294837cef6adde9f546d2e1f9b70f" translate="yes" xml:space="preserve">
          <source>The Repeatable Read isolation level is implemented using a technique known in academic database literature and in some other database products as &lt;em&gt;Snapshot Isolation&lt;/em&gt;. Differences in behavior and performance may be observed when compared with systems that use a traditional locking technique that reduces concurrency. Some other systems may even offer Repeatable Read and Snapshot Isolation as distinct isolation levels with different behavior. The permitted phenomena that distinguish the two techniques were not formalized by database researchers until after the SQL standard was developed, and are outside the scope of this manual. For a full treatment, please see &lt;a href=&quot;https://www.postgresql.org/docs/13/biblio.html#BERENSON95&quot;&gt;[berenson95]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="091f62aabb99c30a476910bd3ba420fa9f860db6" translate="yes" xml:space="preserve">
          <source>The Repeatable Read mode provides a rigorous guarantee that each transaction sees a completely stable view of the database. However, this view will not necessarily always be consistent with some serial (one at a time) execution of concurrent transactions of the same level. For example, even a read only transaction at this level may see a control record updated to show that a batch has been completed but &lt;em&gt;not&lt;/em&gt; see one of the detail records which is logically part of the batch because it read an earlier revision of the control record. Attempts to enforce business rules by transactions running at this isolation level are not likely to work correctly without careful use of explicit locks to block conflicting transactions.</source>
          <target state="translated">可重复读取模式提供了严格的保证，即每个事务都能看到数据库的完全稳定的视图。但是，此视图不一定总是与同一级别的并发事务的某些串行（一次一个）执行一致。例如，即使是在这个级别只读事务可以看到更新以显示一批次已经完成，但控制记录&lt;em&gt;没有&lt;/em&gt;看到的详细信息记录在逻辑上批的一部分，因为它读取控制记录的早期版本一个。如果不谨慎使用显式锁来阻止冲突的事务，则试图以这种隔离级别运行的事务来强制执行业务规则的尝试可能无法正常工作。</target>
        </trans-unit>
        <trans-unit id="bebce75022660ba392e40784c2cdda41c615a64f" translate="yes" xml:space="preserve">
          <source>The SCRAM specification dictates that the password is also in UTF-8, and is processed with the &lt;em&gt;SASLprep&lt;/em&gt; algorithm. PostgreSQL, however, does not require UTF-8 to be used for the password. When a user's password is set, it is processed with SASLprep as if it was in UTF-8, regardless of the actual encoding used. However, if it is not a legal UTF-8 byte sequence, or it contains UTF-8 byte sequences that are prohibited by the SASLprep algorithm, the raw password will be used without SASLprep processing, instead of throwing an error. This allows the password to be normalized when it is in UTF-8, but still allows a non-UTF-8 password to be used, and doesn't require the system to know which encoding the password is in.</source>
          <target state="translated">SCRAM规范规定该密码也是UTF-8，并且使用&lt;em&gt;SASLprep&lt;/em&gt;算法进行处理。但是，PostgreSQL不需要使用UTF-8作为密码。设置用户密码后，无论使用哪种实际编码，都将使用SASLprep对其进行处理，就像使用UTF-8一样。但是，如果它不是合法的UTF-8字节序列，或者包含SASLprep算法禁止的UTF-8字节序列，则将使用原始密码而不进行SASLprep处理，而不会引发错误。这使密码在UTF-8中时可以被规范化，但是仍然允许使用非UTF-8密码，并且不需要系统知道密码的编码方式。</target>
        </trans-unit>
        <trans-unit id="0e7a1522eba0328b9be11871eb393a000b642ba7" translate="yes" xml:space="preserve">
          <source>The SP-GiST core can override the results of the operator class's &lt;code&gt;picksplit&lt;/code&gt; function when &lt;code&gt;picksplit&lt;/code&gt; fails to divide the supplied leaf values into at least two node categories. When this happens, the new inner tuple is created with multiple nodes that each have the same label (if any) that &lt;code&gt;picksplit&lt;/code&gt; gave to the one node it did use, and the leaf values are divided at random among these equivalent nodes. The &lt;code&gt;allTheSame&lt;/code&gt; flag is set on the inner tuple to warn the &lt;code&gt;choose&lt;/code&gt; and &lt;code&gt;inner_consistent&lt;/code&gt; functions that the tuple does not have the node set that they might otherwise expect.</source>
          <target state="translated">当 &lt;code&gt;picksplit&lt;/code&gt; 无法将提供的叶子值划分为至少两个节点类别时，SP-GiST核心可以覆盖操作员类的 &lt;code&gt;picksplit&lt;/code&gt; 函数的结果。发生这种情况时，将创建一个新的内部元组，其中包含多个节点，每个节点都具有相同的标签（如果有的话），该标签被 &lt;code&gt;picksplit&lt;/code&gt; 给了它确实使用的一个节点，并且叶子值在这些等效节点之间随机分配。该 &lt;code&gt;allTheSame&lt;/code&gt; 标志设置在内部的元组警告 &lt;code&gt;choose&lt;/code&gt; 和 &lt;code&gt;inner_consistent&lt;/code&gt; 功能的元组不具有节点集合，否则他们可能期望。</target>
        </trans-unit>
        <trans-unit id="d1b14a46877d8df03142e17f562b21c36e25830b" translate="yes" xml:space="preserve">
          <source>The SP-GiST core code takes care of null entries. Although SP-GiST indexes do store entries for nulls in indexed columns, this is hidden from the index operator class code: no null index entries or search conditions will ever be passed to the operator class methods. (It is assumed that SP-GiST operators are strict and so cannot succeed for null values.) Null values are therefore not discussed further here.</source>
          <target state="translated">SP-GIST核心代码负责处理空条目。虽然SP-GIST索引确实会在索引列中存储空值条目,但这是隐藏在索引操作符类代码中的:永远不会将空值索引条目或搜索条件传递给操作符类方法。假设SP-GIST运算符是严格的,所以对于空值不能成功)。因此,这里不进一步讨论空值。</target>
        </trans-unit>
        <trans-unit id="fe87973f3ef5a0d6b6662bce168960f63417cd65" translate="yes" xml:space="preserve">
          <source>The SQL &lt;code&gt;CASE&lt;/code&gt; expression is a generic conditional expression, similar to if/else statements in other programming languages:</source>
          <target state="translated">SQL &lt;code&gt;CASE&lt;/code&gt; 表达式是通用条件表达式，类似于其他编程语言中的if / else语句：</target>
        </trans-unit>
        <trans-unit id="d48ab325670cd3e1aa8741d57a661891b103e0ac" translate="yes" xml:space="preserve">
          <source>The SQL command &lt;code&gt;SET TIME ZONE&lt;/code&gt; sets the time zone for the session. This is an alternative spelling of &lt;code&gt;SET TIMEZONE TO&lt;/code&gt; with a more SQL-spec-compatible syntax.</source>
          <target state="translated">SQL命令 &lt;code&gt;SET TIME ZONE&lt;/code&gt; 设置会话的时区。这是 &lt;code&gt;SET TIMEZONE TO&lt;/code&gt; 的替代拼写，具有更多的SQL规范兼容语法。</target>
        </trans-unit>
        <trans-unit id="d138e80b8b9922df49f297ce30f8d0bcbf9cc1b2" translate="yes" xml:space="preserve">
          <source>The SQL command used to request data from a &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt;. Normally, &lt;code&gt;SELECT&lt;/code&gt; commands are not expected to modify the &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; in any way, but it is possible that &lt;a href=&quot;glossary#GLOSSARY-FUNCTION&quot;&gt;functions&lt;/a&gt; invoked within the query could have side effects that do modify data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64de07c340bdb76d49ccd2451af6603ff373cc2b" translate="yes" xml:space="preserve">
          <source>The SQL declaration of the function must look like this:</source>
          <target state="translated">函数的SQL声明必须像这样。</target>
        </trans-unit>
        <trans-unit id="d7b4645499046b1f0731ca7d87e83bccfa0f031d" translate="yes" xml:space="preserve">
          <source>The SQL script will be written to the standard output. Use the &lt;code&gt;-f&lt;/code&gt;/&lt;code&gt;--file&lt;/code&gt; option or shell operators to redirect it into a file.</source>
          <target state="translated">SQL脚本将被写入标准输出。使用 &lt;code&gt;-f&lt;/code&gt; / &lt;code&gt;--file&lt;/code&gt; 选项或shell运算符将其重定向到文件中。</target>
        </trans-unit>
        <trans-unit id="e638b08fc8b7ed4b2fdc056d0b48506d414e8ee3" translate="yes" xml:space="preserve">
          <source>The SQL specification requires row-wise comparison to return NULL if the result depends on comparing two NULL values or a NULL and a non-NULL. PostgreSQL does this only when comparing the results of two row constructors (as in &lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;Section 9.23.5&lt;/a&gt;) or comparing a row constructor to the output of a subquery (as in &lt;a href=&quot;functions-subquery&quot;&gt;Section 9.22&lt;/a&gt;). In other contexts where two composite-type values are compared, two NULL field values are considered equal, and a NULL is considered larger than a non-NULL. This is necessary in order to have consistent sorting and indexing behavior for composite types.</source>
          <target state="translated">如果结果依赖于比较两个NULL值或NULL和非NULL，则SQL规范要求按行比较以返回NULL。 PostgreSQL仅在比较两个行构造器的结果（如&lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;9.23.5节&lt;/a&gt;）或将行构造器与子查询​​的输出（如&lt;a href=&quot;functions-subquery&quot;&gt;9.22 &lt;/a&gt;节）进行比较时才这样做。在比较两个复合类型值的其他上下文中，两个NULL字段值被视为相等，并且NULL被认为大于非NULL。为了使复合类型具有一致的排序和索引行为，这是必需的。</target>
        </trans-unit>
        <trans-unit id="70d6fe59fbf6e2a74e4c6678f95fcbb041c7ebd1" translate="yes" xml:space="preserve">
          <source>The SQL specification requires row-wise comparison to return NULL if the result depends on comparing two NULL values or a NULL and a non-NULL. PostgreSQL does this only when comparing the results of two row constructors (as in &lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;Section 9.24.5&lt;/a&gt;) or comparing a row constructor to the output of a subquery (as in &lt;a href=&quot;functions-subquery&quot;&gt;Section 9.23&lt;/a&gt;). In other contexts where two composite-type values are compared, two NULL field values are considered equal, and a NULL is considered larger than a non-NULL. This is necessary in order to have consistent sorting and indexing behavior for composite types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22ab3c86af000737aa210aeaf592af19c218233b" translate="yes" xml:space="preserve">
          <source>The SQL standard (not XQuery itself) attempts to cater for more variants of &amp;ldquo;newline&amp;rdquo; than POSIX does. The newline-sensitive matching options described above consider only ASCII NL (&lt;code&gt;\n&lt;/code&gt;) to be a newline, but SQL would have us treat CR (&lt;code&gt;\r&lt;/code&gt;), CRLF (&lt;code&gt;\r\n&lt;/code&gt;) (a Windows-style newline), and some Unicode-only characters like LINE SEPARATOR (U+2028) as newlines as well. Notably, &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;\s&lt;/code&gt; should count &lt;code&gt;\r\n&lt;/code&gt; as one character not two according to SQL.</source>
          <target state="translated">SQL标准（不是XQuery本身）试图迎合比POSIX更多的&amp;ldquo;换行符&amp;rdquo;变体。上述对换行敏感的匹配选项仅将ASCII NL（ &lt;code&gt;\n&lt;/code&gt; ）视为换行符，但是SQL会让我们将CR（ &lt;code&gt;\r&lt;/code&gt; ），CRLF（ &lt;code&gt;\r\n&lt;/code&gt; ）（Windows风格的换行符）和一些仅限Unicode的字符（例如LINE SEPARATOR（U + 2028））也用作换行符。值得注意的是 &lt;code&gt;.&lt;/code&gt; 和 &lt;code&gt;\s&lt;/code&gt; 根据SQL 应将 &lt;code&gt;\r\n&lt;/code&gt; 视为一个字符而不是两个字符。</target>
        </trans-unit>
        <trans-unit id="3ca979281ade8cf94abb51fcd1544322941db9bd" translate="yes" xml:space="preserve">
          <source>The SQL standard allows a &lt;code&gt;DEFAULT CHARACTER SET&lt;/code&gt; clause in &lt;code&gt;CREATE SCHEMA&lt;/code&gt;, as well as more subcommand types than are presently accepted by PostgreSQL.</source>
          <target state="translated">SQL标准允许 &lt;code&gt;CREATE SCHEMA&lt;/code&gt; 中的 &lt;code&gt;DEFAULT CHARACTER SET&lt;/code&gt; 子句，以及比PostgreSQL目前接受的子命令类型更多的子命令类型。</target>
        </trans-unit>
        <trans-unit id="a28253dba0b95d8667501243721aade5c4069637" translate="yes" xml:space="preserve">
          <source>The SQL standard allows cursors only in embedded SQL and in modules. PostgreSQL permits cursors to be used interactively.</source>
          <target state="translated">SQL标准只允许在嵌入式SQL和模块中使用游标。PostgreSQL允许交互式使用游标。</target>
        </trans-unit>
        <trans-unit id="7005659d6b42749138703e7ef74f259a352e97f5" translate="yes" xml:space="preserve">
          <source>The SQL standard allows only &lt;code&gt;FROM&lt;/code&gt; preceding the cursor name; the option to use &lt;code&gt;IN&lt;/code&gt;, or to leave them out altogether, is an extension.</source>
          <target state="translated">SQL标准仅在游标名称之前允许 &lt;code&gt;FROM&lt;/code&gt; 。使用 &lt;code&gt;IN&lt;/code&gt; 或完全不使用它们的选项是扩展。</target>
        </trans-unit>
        <trans-unit id="69a8fc7cc008eb25ed064f0d1fdca190a5bf8644" translate="yes" xml:space="preserve">
          <source>The SQL standard allows some other expressions to appear in place of the literal &lt;code&gt;user_name&lt;/code&gt;, but these options are not important in practice. PostgreSQL allows identifier syntax (&lt;code&gt;&quot;username&quot;&lt;/code&gt;), which SQL does not. SQL does not allow this command during a transaction; PostgreSQL does not make this restriction because there is no reason to. The &lt;code&gt;SESSION&lt;/code&gt; and &lt;code&gt;LOCAL&lt;/code&gt; modifiers are a PostgreSQL extension, as is the &lt;code&gt;RESET&lt;/code&gt; syntax.</source>
          <target state="translated">SQL标准允许其他一些表达式代替文字 &lt;code&gt;user_name&lt;/code&gt; 出现，但是这些选项在实践中并不重要。PostgreSQL允许使用标识符语法（ &lt;code&gt;&quot;username&quot;&lt;/code&gt; ），而SQL则不允许。SQL在事务期间不允许使用此命令。PostgreSQL没有限制，因为没有理由。该 &lt;code&gt;SESSION&lt;/code&gt; 和 &lt;code&gt;LOCAL&lt;/code&gt; 修饰是PostgreSQL的扩展，因为是 &lt;code&gt;RESET&lt;/code&gt; 语法。</target>
        </trans-unit>
        <trans-unit id="473020e153f860561552af61b3a2ab3766cfb98d" translate="yes" xml:space="preserve">
          <source>The SQL standard allows the &lt;code&gt;GRANTED BY&lt;/code&gt; option to be used in all forms of &lt;code&gt;GRANT&lt;/code&gt;. PostgreSQL only supports it when granting role membership, and even then only superusers may use it in nontrivial ways.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b623e7f141c55510760b9b77e9eb99f9e4321e9e" translate="yes" xml:space="preserve">
          <source>The SQL standard also distinguishes between global and local temporary tables, where a local temporary table has a separate set of contents for each SQL module within each session, though its definition is still shared across sessions. Since PostgreSQL does not support SQL modules, this distinction is not relevant in PostgreSQL.</source>
          <target state="translated">SQL标准还区分了全局临时表和本地临时表,本地临时表对每个会话内的每个SQL模块都有一套独立的内容,不过它的定义仍然是跨会话共享的。由于PostgreSQL不支持SQL模块,所以这种区分在PostgreSQL中没有意义。</target>
        </trans-unit>
        <trans-unit id="6f9fa0f99df0f3d6e4d172f087bbf08f499d13c0" translate="yes" xml:space="preserve">
          <source>The SQL standard and PostgreSQL-implemented transaction isolation levels are described in &lt;a href=&quot;transaction-iso#MVCC-ISOLEVEL-TABLE&quot;&gt;Table 13.1&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;transaction-iso#MVCC-ISOLEVEL-TABLE&quot;&gt;表13.1&lt;/a&gt;中描述了SQL标准和PostgreSQL实现的事务隔离级别。</target>
        </trans-unit>
        <trans-unit id="e49f9cf60061c8b5fe47367c7175f7b9d12754fa" translate="yes" xml:space="preserve">
          <source>The SQL standard calls databases &amp;ldquo;catalogs&amp;rdquo;, but there is no difference in practice.</source>
          <target state="translated">SQL标准将数据库称为&amp;ldquo;目录&amp;rdquo;，但实际上没有区别。</target>
        </trans-unit>
        <trans-unit id="f6b9dd41b616b1103c4995e9bab7f0a1474529d1" translate="yes" xml:space="preserve">
          <source>The SQL standard defines &lt;code&gt;DROP ROLE&lt;/code&gt;, but it allows only one role to be dropped at a time, and it specifies different privilege requirements than PostgreSQL uses.</source>
          <target state="translated">SQL标准定义了 &lt;code&gt;DROP ROLE&lt;/code&gt; ，但是它一次只允许删除一个角色，并且它指定的特权要求与PostgreSQL使用的特权不同。</target>
        </trans-unit>
        <trans-unit id="89dd410d4b1dc70cede977d3716ec82a83bd84ad" translate="yes" xml:space="preserve">
          <source>The SQL standard defines &lt;code&gt;FETCH&lt;/code&gt; for use in embedded SQL only. The variant of &lt;code&gt;FETCH&lt;/code&gt; described here returns the data as if it were a &lt;code&gt;SELECT&lt;/code&gt; result rather than placing it in host variables. Other than this point, &lt;code&gt;FETCH&lt;/code&gt; is fully upward-compatible with the SQL standard.</source>
          <target state="translated">SQL标准定义了 &lt;code&gt;FETCH&lt;/code&gt; 仅用于嵌入式SQL。这里描述的 &lt;code&gt;FETCH&lt;/code&gt; 的变体将数据作为 &lt;code&gt;SELECT&lt;/code&gt; 结果返回，而不是将其放在主机变量中。除此之外， &lt;code&gt;FETCH&lt;/code&gt; 与SQL标准完全向上兼容。</target>
        </trans-unit>
        <trans-unit id="0433545c375e6f7a87b9a6951397354ec73ee790" translate="yes" xml:space="preserve">
          <source>The SQL standard defines a &lt;code&gt;RESPECT NULLS&lt;/code&gt; or &lt;code&gt;IGNORE NULLS&lt;/code&gt; option for &lt;code&gt;lead&lt;/code&gt;, &lt;code&gt;lag&lt;/code&gt;, &lt;code&gt;first_value&lt;/code&gt;, &lt;code&gt;last_value&lt;/code&gt;, and &lt;code&gt;nth_value&lt;/code&gt;. This is not implemented in PostgreSQL: the behavior is always the same as the standard's default, namely &lt;code&gt;RESPECT NULLS&lt;/code&gt;. Likewise, the standard's &lt;code&gt;FROM FIRST&lt;/code&gt; or &lt;code&gt;FROM LAST&lt;/code&gt; option for &lt;code&gt;nth_value&lt;/code&gt; is not implemented: only the default &lt;code&gt;FROM FIRST&lt;/code&gt; behavior is supported. (You can achieve the result of &lt;code&gt;FROM LAST&lt;/code&gt; by reversing the &lt;code&gt;ORDER BY&lt;/code&gt; ordering.)</source>
          <target state="translated">SQL标准为 &lt;code&gt;lead&lt;/code&gt; ， &lt;code&gt;lag&lt;/code&gt; ， &lt;code&gt;first_value&lt;/code&gt; ， &lt;code&gt;last_value&lt;/code&gt; 和 &lt;code&gt;nth_value&lt;/code&gt; 定义了 &lt;code&gt;RESPECT NULLS&lt;/code&gt; 或 &lt;code&gt;IGNORE NULLS&lt;/code&gt; 选项。这在PostgreSQL中未实现：行为始终与标准的默认行为相同，即 &lt;code&gt;RESPECT NULLS&lt;/code&gt; 。同样，没有实现标准的 &lt;code&gt;nth_value&lt;/code&gt; 的 &lt;code&gt;FROM FIRST&lt;/code&gt; 或 &lt;code&gt;FROM LAST&lt;/code&gt; 选项：仅支持默认的 &lt;code&gt;FROM FIRST&lt;/code&gt; 行为。 （您可以通过颠倒 &lt;code&gt;ORDER BY&lt;/code&gt; 顺序来获得 &lt;code&gt;FROM LAST&lt;/code&gt; 的结果。）</target>
        </trans-unit>
        <trans-unit id="fa458ed41634d193bea2fac0154b209dd0cf765a" translate="yes" xml:space="preserve">
          <source>The SQL standard defines a different binary string type, called &lt;code&gt;BLOB&lt;/code&gt; or &lt;code&gt;BINARY LARGE OBJECT&lt;/code&gt;. The input format is different from &lt;code&gt;bytea&lt;/code&gt;, but the provided functions and operators are mostly the same.</source>
          <target state="translated">SQL标准定义了另一种二进制字符串类型，称为 &lt;code&gt;BLOB&lt;/code&gt; 或 &lt;code&gt;BINARY LARGE OBJECT&lt;/code&gt; 。输入格式与 &lt;code&gt;bytea&lt;/code&gt; 不同，但是提供的功能和运算符基本相同。</target>
        </trans-unit>
        <trans-unit id="a6502238836b3c1e6ea2cb2c05c9c3eff6b47428" translate="yes" xml:space="preserve">
          <source>The SQL standard defines four levels of transaction isolation. The most strict is Serializable, which is defined by the standard in a paragraph which says that any concurrent execution of a set of Serializable transactions is guaranteed to produce the same effect as running them one at a time in some order. The other three levels are defined in terms of phenomena, resulting from interaction between concurrent transactions, which must not occur at each level. The standard notes that due to the definition of Serializable, none of these phenomena are possible at that level. (This is hardly surprising -- if the effect of the transactions must be consistent with having been run one at a time, how could you see any phenomena caused by interactions?)</source>
          <target state="translated">SQL标准定义了四个级别的事务隔离。最严格的是Serializable,标准在一个段落中定义说,任何并发执行一组Serializable事务的行为,都能保证与按一定顺序一个个运行它们产生相同的效果。其他三个层次是以现象来定义的,由并发事务之间的交互作用产生的,每个层次都不能出现这种现象。标准指出,由于Serializable的定义,这些现象都不可能在该级别出现。这一点并不奇怪 ----如果事务的效果必须与一次运行一个事务相一致,你怎么能看到任何由交互引起的现象?</target>
        </trans-unit>
        <trans-unit id="e0bda65f48165dca64ab0bb74baf32b2635a1f88" translate="yes" xml:space="preserve">
          <source>The SQL standard defines one additional level, &lt;code&gt;READ UNCOMMITTED&lt;/code&gt;. In PostgreSQL &lt;code&gt;READ UNCOMMITTED&lt;/code&gt; is treated as &lt;code&gt;READ COMMITTED&lt;/code&gt;.</source>
          <target state="translated">SQL标准定义了一个附加级别 &lt;code&gt;READ UNCOMMITTED&lt;/code&gt; 。在PostgreSQL中， &lt;code&gt;READ UNCOMMITTED&lt;/code&gt; 被视为 &lt;code&gt;READ COMMITTED&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4646156599f749581333cb75ad841c671d1c0b23" translate="yes" xml:space="preserve">
          <source>The SQL standard defines the concepts of users and roles, but it regards them as distinct concepts and leaves all commands defining users to be specified by each database implementation. In PostgreSQL we have chosen to unify users and roles into a single kind of entity. Roles therefore have many more optional attributes than they do in the standard.</source>
          <target state="translated">SQL标准定义了用户和角色的概念,但它认为它们是不同的概念,并将所有定义用户的命令留给每个数据库实现来指定。在PostgreSQL中,我们选择将用户和角色统一为一个单一的实体。因此,角色有比标准中更多的可选属性。</target>
        </trans-unit>
        <trans-unit id="0663b6424dd2f8b2135d82962a5208510f77e258" translate="yes" xml:space="preserve">
          <source>The SQL standard defines two &lt;em&gt;passing mechanisms&lt;/em&gt; that apply when passing an XML argument from SQL to an XML function or receiving a result: &lt;code&gt;BY REF&lt;/code&gt;, in which a particular XML value retains its node identity, and &lt;code&gt;BY VALUE&lt;/code&gt;, in which the content of the XML is passed but node identity is not preserved. A mechanism can be specified before a list of parameters, as the default mechanism for all of them, or after any parameter, to override the default.</source>
          <target state="translated">SQL标准定义了两种&lt;em&gt;传递机制&lt;/em&gt;，适用于将XML参数从SQL传递到XML函数或接收结果时使用的&lt;em&gt;传递机制&lt;/em&gt;： &lt;code&gt;BY REF&lt;/code&gt; 和 &lt;code&gt;BY VALUE&lt;/code&gt; ，其中特定的XML值保留其节点标识；BY VALUE，其中的XML内容传递，但未保留节点标识。可以在参数列表之前指定一种机制（作为所有参数的默认机制），也可以在任何参数之后指定该机制以覆盖默认值。</target>
        </trans-unit>
        <trans-unit id="8be5477647682fea4652e9633a7fdf7ae02cb95d" translate="yes" xml:space="preserve">
          <source>The SQL standard differentiates &lt;code&gt;timestamp without time zone&lt;/code&gt; and &lt;code&gt;timestamp with time zone&lt;/code&gt; literals by the presence of a &amp;ldquo;+&amp;rdquo; or &amp;ldquo;-&amp;rdquo; symbol and time zone offset after the time. Hence, according to the standard,</source>
          <target state="translated">SQL标准分化带来 &lt;code&gt;timestamp without time zone&lt;/code&gt; 和 &lt;code&gt;timestamp with time zone&lt;/code&gt; 文字通过的&amp;ldquo;+&amp;rdquo;或存在&amp;ldquo; - &amp;rdquo;的时间之后符号和时区偏移。因此，根据标准，</target>
        </trans-unit>
        <trans-unit id="e664f1068d4185a0e2c4e6676631526d39744df1" translate="yes" xml:space="preserve">
          <source>The SQL standard includes a &lt;code&gt;DEALLOCATE&lt;/code&gt; statement, but it is only for use in embedded SQL.</source>
          <target state="translated">SQL标准包括 &lt;code&gt;DEALLOCATE&lt;/code&gt; 语句，但仅用于嵌入式SQL。</target>
        </trans-unit>
        <trans-unit id="c90f74b3a15257d28d6e4bb3296f2c0e98aadae3" translate="yes" xml:space="preserve">
          <source>The SQL standard includes a &lt;code&gt;PREPARE&lt;/code&gt; statement, but it is only for use in embedded SQL. This version of the &lt;code&gt;PREPARE&lt;/code&gt; statement also uses a somewhat different syntax.</source>
          <target state="translated">SQL标准包括一个 &lt;code&gt;PREPARE&lt;/code&gt; 语句，但仅用于嵌入式SQL。此版本的 &lt;code&gt;PREPARE&lt;/code&gt; 语句还使用了一些不同的语法。</target>
        </trans-unit>
        <trans-unit id="fe224ee017c2bd35d24d44088347efdd2b498c3d" translate="yes" xml:space="preserve">
          <source>The SQL standard includes an &lt;code&gt;EXECUTE&lt;/code&gt; statement, but it is only for use in embedded SQL. This version of the &lt;code&gt;EXECUTE&lt;/code&gt; statement also uses a somewhat different syntax.</source>
          <target state="translated">SQL标准包含一个 &lt;code&gt;EXECUTE&lt;/code&gt; 语句，但仅用于嵌入式SQL。此版本的 &lt;code&gt;EXECUTE&lt;/code&gt; 语句还使用了一些不同的语法。</target>
        </trans-unit>
        <trans-unit id="3efa28b82e46f4409adc369dc8a870c8a673cbae" translate="yes" xml:space="preserve">
          <source>The SQL standard only makes provisions for cursors in embedded SQL. The PostgreSQL server does not implement an &lt;code&gt;OPEN&lt;/code&gt; statement for cursors; a cursor is considered to be open when it is declared. However, ECPG, the embedded SQL preprocessor for PostgreSQL, supports the standard SQL cursor conventions, including those involving &lt;code&gt;DECLARE&lt;/code&gt; and &lt;code&gt;OPEN&lt;/code&gt; statements.</source>
          <target state="translated">SQL标准仅对嵌入式SQL中的游标进行规定。PostgreSQL服务器不为游标实现 &lt;code&gt;OPEN&lt;/code&gt; 语句；当游标被声明时，它被认为是打开的。但是，ECPG是PostgreSQL的嵌入式SQL预处理程序，支持标准的SQL游标约定，包括涉及 &lt;code&gt;DECLARE&lt;/code&gt; 和 &lt;code&gt;OPEN&lt;/code&gt; 语句的约定。</target>
        </trans-unit>
        <trans-unit id="27a77950710338562f963e53983e9db24c286f83" translate="yes" xml:space="preserve">
          <source>The SQL standard provides for a &lt;code&gt;USAGE&lt;/code&gt; privilege on other kinds of objects: character sets, collations, translations.</source>
          <target state="translated">SQL标准对其他类型的对象提供 &lt;code&gt;USAGE&lt;/code&gt; 特权：字符集，排序规则，翻译。</target>
        </trans-unit>
        <trans-unit id="eee762b9a6787226a912a1d85c8be87d3dbf797a" translate="yes" xml:space="preserve">
          <source>The SQL standard requires commas between successive &lt;code&gt;transaction_modes&lt;/code&gt;, but for historical reasons PostgreSQL allows the commas to be omitted.</source>
          <target state="translated">SQL标准要求连续的 &lt;code&gt;transaction_modes&lt;/code&gt; 之间使用逗号，但是出于历史原因，PostgreSQL允许省略逗号。</target>
        </trans-unit>
        <trans-unit id="0cdcd239c4d51fe5d06e09469371cb72d1e4c5cc" translate="yes" xml:space="preserve">
          <source>The SQL standard requires parentheses around the table name when writing &lt;code&gt;ONLY&lt;/code&gt;, for example &lt;code&gt;SELECT * FROM ONLY (tab1), ONLY (tab2) WHERE ...&lt;/code&gt;. PostgreSQL considers these parentheses to be optional.</source>
          <target state="translated">SQL标准要求周围的表名的括号书写时 &lt;code&gt;ONLY&lt;/code&gt; ，例如 &lt;code&gt;SELECT * FROM ONLY (tab1), ONLY (tab2) WHERE ...&lt;/code&gt; 。PostgreSQL认为这些括号是可选的。</target>
        </trans-unit>
        <trans-unit id="9c327a647bb63bff5c4e11d3c2640afdd42ebe7e" translate="yes" xml:space="preserve">
          <source>The SQL standard requires that writing just &lt;code&gt;timestamp&lt;/code&gt; be equivalent to &lt;code&gt;timestamp without time zone&lt;/code&gt;, and PostgreSQL honors that behavior. &lt;code&gt;timestamptz&lt;/code&gt; is accepted as an abbreviation for &lt;code&gt;timestamp with time zone&lt;/code&gt;; this is a PostgreSQL extension.</source>
          <target state="translated">SQL标准要求仅写 &lt;code&gt;timestamp&lt;/code&gt; 等效于 &lt;code&gt;timestamp without time zone&lt;/code&gt; ，并且PostgreSQL尊重这种行为。 &lt;code&gt;timestamptz&lt;/code&gt; 被接受为 &lt;code&gt;timestamp with time zone&lt;/code&gt; 的缩写；这是PostgreSQL扩展。</target>
        </trans-unit>
        <trans-unit id="b32d323a75124833c9180676bb48b77e9c8490b4" translate="yes" xml:space="preserve">
          <source>The SQL standard says that &lt;code&gt;CHECK&lt;/code&gt; column constraints can only refer to the column they apply to; only &lt;code&gt;CHECK&lt;/code&gt; table constraints can refer to multiple columns. PostgreSQL does not enforce this restriction; it treats column and table check constraints alike.</source>
          <target state="translated">SQL标准说， &lt;code&gt;CHECK&lt;/code&gt; 列约束只能引用它们适用于的列。只有 &lt;code&gt;CHECK&lt;/code&gt; 表约束可以引用多个列。PostgreSQL不强制执行此限制。它对待列和表检查约束都一样。</target>
        </trans-unit>
        <trans-unit id="17cd16f5bf5a8ca370f92a98424035c167fcaa79" translate="yes" xml:space="preserve">
          <source>The SQL standard says that it is implementation-dependent whether cursors are sensitive to concurrent updates of the underlying data by default. In PostgreSQL, cursors are insensitive by default, and can be made sensitive by specifying &lt;code&gt;FOR UPDATE&lt;/code&gt;. Other products may work differently.</source>
          <target state="translated">SQL标准说，默认情况下，游标是否对基础数据的并发更新敏感，这取决于实现。在PostgreSQL中，默认情况下游标是不敏感的，并且可以通过指定 &lt;code&gt;FOR UPDATE&lt;/code&gt; 来使其变得敏感。其他产品可能会有所不同。</target>
        </trans-unit>
        <trans-unit id="6c0e6c19202fe94a3734c19398394df433a6c622" translate="yes" xml:space="preserve">
          <source>The SQL standard says that table and domain constraints must have names that are unique across the schema containing the table or domain. PostgreSQL is laxer: it only requires constraint names to be unique across the constraints attached to a particular table or domain. However, this extra freedom does not exist for index-based constraints (&lt;code&gt;UNIQUE&lt;/code&gt;, &lt;code&gt;PRIMARY KEY&lt;/code&gt;, and &lt;code&gt;EXCLUDE&lt;/code&gt; constraints), because the associated index is named the same as the constraint, and index names must be unique across all relations within the same schema.</source>
          <target state="translated">SQL标准说，表和域约束必须具有在包含表或域的架构上唯一的名称。PostgreSQL比较宽松：它只要求约束名称在附加到特定表或域的约束上是唯一的。但是，对于基于索引的约束（ &lt;code&gt;UNIQUE&lt;/code&gt; ， &lt;code&gt;PRIMARY KEY&lt;/code&gt; 和 &lt;code&gt;EXCLUDE&lt;/code&gt; 约束）不存在这种额外的自由，因为关联的索引的命名与约束相同，并且索引名称在同一架构内的所有关系中必须唯一。</target>
        </trans-unit>
        <trans-unit id="5a79884799ecc17f7b669e9ed40107182ffe5aca" translate="yes" xml:space="preserve">
          <source>The SQL standard specifies that &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt; can only be specified if an identity column that is generated always exists. PostgreSQL allows the clause in any case and ignores it if it is not applicable.</source>
          <target state="translated">SQL标准指定仅当始终生成的标识列存在时才可以指定 &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt; 。PostgreSQL在任何情况下都允许该子句，如果不适用则将其忽略。</target>
        </trans-unit>
        <trans-unit id="5b1e1c604541e0514a1f4ecda3cb5b97bda57985" translate="yes" xml:space="preserve">
          <source>The SQL standard specifies that the key word &lt;code&gt;SAVEPOINT&lt;/code&gt; is mandatory, but PostgreSQL and Oracle allow it to be omitted. SQL allows only &lt;code&gt;WORK&lt;/code&gt;, not &lt;code&gt;TRANSACTION&lt;/code&gt;, as a noise word after &lt;code&gt;ROLLBACK&lt;/code&gt;. Also, SQL has an optional clause &lt;code&gt;AND [ NO ] CHAIN&lt;/code&gt; which is not currently supported by PostgreSQL. Otherwise, this command conforms to the SQL standard.</source>
          <target state="translated">SQL标准指定关键字 &lt;code&gt;SAVEPOINT&lt;/code&gt; 是必需的，但是PostgreSQL和Oracle允许省略它。在 &lt;code&gt;ROLLBACK&lt;/code&gt; 之后，SQL只允许 &lt;code&gt;WORK&lt;/code&gt; ，而不允许 &lt;code&gt;TRANSACTION&lt;/code&gt; 作为干扰词。另外，SQL有一个可选的子句 &lt;code&gt;AND [ NO ] CHAIN&lt;/code&gt; ，PostgreSQL目前不支持该子句。否则，此命令符合SQL标准。</target>
        </trans-unit>
        <trans-unit id="4ef02d5b8713fad53d23c6b10f7669991c2a9427" translate="yes" xml:space="preserve">
          <source>The SQL standard specifies that the subcommands in &lt;code&gt;CREATE SCHEMA&lt;/code&gt; can appear in any order. The present PostgreSQL implementation does not handle all cases of forward references in subcommands; it might sometimes be necessary to reorder the subcommands in order to avoid forward references.</source>
          <target state="translated">SQL标准指定 &lt;code&gt;CREATE SCHEMA&lt;/code&gt; 中的子命令可以按任何顺序出现。当前的PostgreSQL实现不能在子命令中处理所有前向引用的情况。有时可能需要对子命令重新排序，以避免前向引用。</target>
        </trans-unit>
        <trans-unit id="7b4258f023ecf83c293dc59266efcd9181140a14" translate="yes" xml:space="preserve">
          <source>The SQL standard states that &amp;ldquo;Within the definition of a &amp;lsquo;datetime literal&amp;rsquo;, the &amp;lsquo;datetime values&amp;rsquo; are constrained by the natural rules for dates and times according to the Gregorian calendar&amp;rdquo;. PostgreSQL follows the SQL standard's lead by counting dates exclusively in the Gregorian calendar, even for years before that calendar was in use. This rule is known as the &lt;em&gt;proleptic Gregorian calendar&lt;/em&gt;.</source>
          <target state="translated">SQL标准指出：&amp;ldquo;在'datetime文字'的定义中，'datetime值'受根据公历的日期和时间的自然规则约束&amp;rdquo;。 PostgreSQL遵循SQL标准，仅在公历中对日期进行计数，即使在使用该日历之前也是如此。此规则被称为&lt;em&gt;公历&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="d19cb60e6641fce6ca2d40fc0e7200daf402177c" translate="yes" xml:space="preserve">
          <source>The SQL standard uses &lt;code&gt;SELECT INTO&lt;/code&gt; to represent selecting values into scalar variables of a host program, rather than creating a new table. This indeed is the usage found in ECPG (see &lt;a href=&quot;https://www.postgresql.org/docs/12/ecpg.html&quot;&gt;Chapter 35&lt;/a&gt;) and PL/pgSQL (see &lt;a href=&quot;https://www.postgresql.org/docs/12/plpgsql.html&quot;&gt;Chapter 42&lt;/a&gt;). The PostgreSQL usage of &lt;code&gt;SELECT INTO&lt;/code&gt; to represent table creation is historical. It is best to use &lt;code&gt;CREATE TABLE AS&lt;/code&gt; for this purpose in new code.</source>
          <target state="translated">SQL标准使用 &lt;code&gt;SELECT INTO&lt;/code&gt; 表示将值选择到主机程序的标量变量中，而不是创建新表。实际上，这就是ECPG（请参阅&lt;a href=&quot;https://www.postgresql.org/docs/12/ecpg.html&quot;&gt;第35章&lt;/a&gt;）和PL / pgSQL（请参阅&lt;a href=&quot;https://www.postgresql.org/docs/12/plpgsql.html&quot;&gt;第42 &lt;/a&gt;章）中的用法。 PostgreSQL使用 &lt;code&gt;SELECT INTO&lt;/code&gt; 表示表创建是历史性的。为此，最好在新代码中使用 &lt;code&gt;CREATE TABLE AS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="975d3d6f53b33edd080d2a6f73dab7ae808007c0" translate="yes" xml:space="preserve">
          <source>The SQL standard uses &lt;code&gt;SELECT INTO&lt;/code&gt; to represent selecting values into scalar variables of a host program, rather than creating a new table. This indeed is the usage found in ECPG (see &lt;a href=&quot;https://www.postgresql.org/docs/13/ecpg.html&quot;&gt;Chapter 35&lt;/a&gt;) and PL/pgSQL (see &lt;a href=&quot;https://www.postgresql.org/docs/13/plpgsql.html&quot;&gt;Chapter 42&lt;/a&gt;). The PostgreSQL usage of &lt;code&gt;SELECT INTO&lt;/code&gt; to represent table creation is historical. It is best to use &lt;code&gt;CREATE TABLE AS&lt;/code&gt; for this purpose in new code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe56d39f2bcc805d7f67d5dc92546476c02ed72d" translate="yes" xml:space="preserve">
          <source>The SQL standard uses this term to indicate what is called a &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; in PostgreSQL's terminology.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f96ecc2fb3538c905f725be2098ce0d65cd6679" translate="yes" xml:space="preserve">
          <source>The SQL syntax is not very consistent regarding what tokens identify commands and which are operands or parameters. The first few tokens are generally the command name, so in the above example we would usually speak of a &amp;ldquo;SELECT&amp;rdquo;, an &amp;ldquo;UPDATE&amp;rdquo;, and an &amp;ldquo;INSERT&amp;rdquo; command. But for instance the &lt;code&gt;UPDATE&lt;/code&gt; command always requires a &lt;code&gt;SET&lt;/code&gt; token to appear in a certain position, and this particular variation of &lt;code&gt;INSERT&lt;/code&gt; also requires a &lt;code&gt;VALUES&lt;/code&gt; in order to be complete. The precise syntax rules for each command are described in &lt;a href=&quot;index&quot;&gt;Part VI&lt;/a&gt;.</source>
          <target state="translated">关于哪些标记标识命令以及哪些是操作数或参数，SQL语法不一致。前几个标记通常是命令名称，因此在上面的示例中，我们通常会说&amp;ldquo; SELECT&amp;rdquo;，&amp;ldquo; UPDATE&amp;rdquo;和&amp;ldquo; INSERT&amp;rdquo;命令。但是，例如， &lt;code&gt;UPDATE&lt;/code&gt; 命令始终要求 &lt;code&gt;SET&lt;/code&gt; 令牌出现在某个位置，并且 &lt;code&gt;INSERT&lt;/code&gt; 的此特定变体也需要 &lt;code&gt;VALUES&lt;/code&gt; 才能完成。&lt;a href=&quot;index&quot;&gt;第六部分&lt;/a&gt;介绍了每个命令的精确语法规则。</target>
        </trans-unit>
        <trans-unit id="bb05fc557b9719130cdacd9aa3c915a94bbdf061" translate="yes" xml:space="preserve">
          <source>The SQL/JSON standard borrows its definition for regular expressions from the &lt;code&gt;LIKE_REGEX&lt;/code&gt; operator, which in turn uses the XQuery standard. PostgreSQL does not currently support the &lt;code&gt;LIKE_REGEX&lt;/code&gt; operator. Therefore, the &lt;code&gt;like_regex&lt;/code&gt; filter is implemented using the POSIX regular expression engine described in &lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;Section 9.7.3&lt;/a&gt;. This leads to various minor discrepancies from standard SQL/JSON behavior, which are cataloged in &lt;a href=&quot;functions-matching#POSIX-VS-XQUERY&quot;&gt;Section 9.7.3.8&lt;/a&gt;. Note, however, that the flag-letter incompatibilities described there do not apply to SQL/JSON, as it translates the XQuery flag letters to match what the POSIX engine expects.</source>
          <target state="translated">SQL / JSON标准从 &lt;code&gt;LIKE_REGEX&lt;/code&gt; 运算符借用了对正则表达式的定义，该运算符又使用XQuery标准。 PostgreSQL当前不支持 &lt;code&gt;LIKE_REGEX&lt;/code&gt; 运算符。因此， &lt;code&gt;like_regex&lt;/code&gt; 过滤器是使用&lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;第9.7.3节中&lt;/a&gt;描述的POSIX正则表达式引擎实现的。这导致与标准SQL / JSON行为的各种细微差异，这些差异在&lt;a href=&quot;functions-matching#POSIX-VS-XQUERY&quot;&gt;9.7.3.8节中进行了分类&lt;/a&gt;。但是请注意，此处描述的标志字母不兼容不适用于SQL / JSON，因为它会转换XQuery标志字母以匹配POSIX引擎的期望。</target>
        </trans-unit>
        <trans-unit id="2c1fd14d6c7b89183a3f90fd72282a55b3166126" translate="yes" xml:space="preserve">
          <source>The SQL:2008 standard includes a &lt;code&gt;TRUNCATE&lt;/code&gt; command with the syntax &lt;code&gt;TRUNCATE TABLE tablename&lt;/code&gt;. The clauses &lt;code&gt;CONTINUE IDENTITY&lt;/code&gt;/&lt;code&gt;RESTART IDENTITY&lt;/code&gt; also appear in that standard, but have slightly different though related meanings. Some of the concurrency behavior of this command is left implementation-defined by the standard, so the above notes should be considered and compared with other implementations if necessary.</source>
          <target state="translated">SQL：2008标准包括带有语法 &lt;code&gt;TRUNCATE TABLE tablename&lt;/code&gt; 的 &lt;code&gt;TRUNCATE&lt;/code&gt; 命令。条款 &lt;code&gt;CONTINUE IDENTITY&lt;/code&gt; / &lt;code&gt;RESTART IDENTITY&lt;/code&gt; 也出现在该标准中，但在相关含义上稍有不同。该命令的某些并发行为由标准实现定义，因此应考虑上述注意事项，并在必要时与其他实现进行比较。</target>
        </trans-unit>
        <trans-unit id="0be6f583c1240a1ebc14deaf65c6d5260c133db4" translate="yes" xml:space="preserve">
          <source>The Serializable isolation level is implemented using a technique known in academic database literature as Serializable Snapshot Isolation, which builds on Snapshot Isolation by adding checks for serialization anomalies. Some differences in behavior and performance may be observed when compared with other systems that use a traditional locking technique. Please see &lt;a href=&quot;https://www.postgresql.org/docs/13/biblio.html#PORTS12&quot;&gt;[ports12]&lt;/a&gt; for detailed information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="106deb17fc13475a8af50970b808cc1e2661d130" translate="yes" xml:space="preserve">
          <source>The Serializable transaction isolation level is not yet available in hot standby. (See &lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;Section 13.2.3&lt;/a&gt; and &lt;a href=&quot;applevel-consistency#SERIALIZABLE-CONSISTENCY&quot;&gt;Section 13.4.1&lt;/a&gt; for details.) An attempt to set a transaction to the serializable isolation level in hot standby mode will generate an error.</source>
          <target state="translated">可序列化事务隔离级别在热备用中尚不可用。（有关详细信息，请参见&lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;第13.2.3节&lt;/a&gt;和&lt;a href=&quot;applevel-consistency#SERIALIZABLE-CONSISTENCY&quot;&gt;第13.4.1节&lt;/a&gt;。）尝试在热备用模式下将事务设置为可序列化的隔离级别将产生错误。</target>
        </trans-unit>
        <trans-unit id="66e4ba5dbccb413a9c06a219a5d2e98558807585" translate="yes" xml:space="preserve">
          <source>The Snowball dictionary template is based on a project by Martin Porter, inventor of the popular Porter's stemming algorithm for the English language. Snowball now provides stemming algorithms for many languages (see the &lt;a href=&quot;http://snowballstem.org/&quot;&gt;Snowball site&lt;/a&gt; for more information). Each algorithm understands how to reduce common variant forms of words to a base, or stem, spelling within its language. A Snowball dictionary requires a &lt;code&gt;language&lt;/code&gt; parameter to identify which stemmer to use, and optionally can specify a &lt;code&gt;stopword&lt;/code&gt; file name that gives a list of words to eliminate. (PostgreSQL's standard stopword lists are also provided by the Snowball project.) For example, there is a built-in definition equivalent to</source>
          <target state="translated">Snowball词典模板基于Martin Porter的项目，Martin Porter是流行的Porter的英语词干提取算法的发明者。 Snowball现在提供了多种语言的词干算法（有关更多信息，请参见&lt;a href=&quot;http://snowballstem.org/&quot;&gt;Snowball网站&lt;/a&gt;）。每个算法都了解如何在其语言中将常见的变体形式的单词减少为基础或词干的拼写。 Snowball词典需要一个 &lt;code&gt;language&lt;/code&gt; 参数来标识要使用的词干，并且可以选择指定一个 &lt;code&gt;stopword&lt;/code&gt; 文件名，以提供要删除的单词列表。 （PostgreSQL的标准停用词列表也由Snowball项目提供。）例如，有一个等效于的内置定义</target>
        </trans-unit>
        <trans-unit id="00f96728bd51fe9881e179ce29f4aab84f3a0eb5" translate="yes" xml:space="preserve">
          <source>The Snowball dictionary template is based on a project by Martin Porter, inventor of the popular Porter's stemming algorithm for the English language. Snowball now provides stemming algorithms for many languages (see the &lt;a href=&quot;https://snowballstem.org/&quot;&gt;Snowball site&lt;/a&gt; for more information). Each algorithm understands how to reduce common variant forms of words to a base, or stem, spelling within its language. A Snowball dictionary requires a &lt;code&gt;language&lt;/code&gt; parameter to identify which stemmer to use, and optionally can specify a &lt;code&gt;stopword&lt;/code&gt; file name that gives a list of words to eliminate. (PostgreSQL's standard stopword lists are also provided by the Snowball project.) For example, there is a built-in definition equivalent to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13e42c2d23de5bce64e42840619341e599527d06" translate="yes" xml:space="preserve">
          <source>The Sort node shows the sort method used (in particular, whether the sort was in-memory or on-disk) and the amount of memory or disk space needed. The Hash node shows the number of hash buckets and batches as well as the peak amount of memory used for the hash table. (If the number of batches exceeds one, there will also be disk space usage involved, but that is not shown.)</source>
          <target state="translated">排序节点显示了所使用的排序方法(特别是,排序是在内存中还是在磁盘上)以及所需的内存或磁盘空间。Hash节点显示了哈希桶和批次的数量,以及哈希表使用的峰值内存量。如果批次数量超过一个,还会涉及到磁盘空间的使用,但不会显示)。</target>
        </trans-unit>
        <trans-unit id="ffcd4e9238fc5943a8a630abc801447e679c88d8" translate="yes" xml:space="preserve">
          <source>The Soundex system is a method of matching similar-sounding names by converting them to the same code. It was initially used by the United States Census in 1880, 1900, and 1910. Note that Soundex is not very useful for non-English names.</source>
          <target state="translated">Soundex系统是一种通过将相似发音的名字转换为相同代码进行匹配的方法。它最初由美国人口普查在1880年、1900年和1910年使用。需要注意的是,Soundex系统对非英文名字不是很有用。</target>
        </trans-unit>
        <trans-unit id="30ad8964ef3e16d1b565ba3b7fd4ae7ed8f17e69" translate="yes" xml:space="preserve">
          <source>The TCP port the server listens on; 5432 by default. Note that the same port number is used for all IP addresses the server listens on. This parameter can only be set at server start.</source>
          <target state="translated">服务器监听的TCP端口,默认为5432。请注意,服务器监听的所有 IP 地址都使用相同的端口号。此参数只能在服务器启动时设置。</target>
        </trans-unit>
        <trans-unit id="4a5c86c75e37eef9f48a99edd2521f09dbad0224" translate="yes" xml:space="preserve">
          <source>The TOAST management code is triggered only when a row value to be stored in a table is wider than &lt;code&gt;TOAST_TUPLE_THRESHOLD&lt;/code&gt; bytes (normally 2 kB). The TOAST code will compress and/or move field values out-of-line until the row value is shorter than &lt;code&gt;TOAST_TUPLE_TARGET&lt;/code&gt; bytes (also normally 2 kB, adjustable) or no more gains can be had. During an UPDATE operation, values of unchanged fields are normally preserved as-is; so an UPDATE of a row with out-of-line values incurs no TOAST costs if none of the out-of-line values change.</source>
          <target state="translated">仅当要存储在表中的行值大于 &lt;code&gt;TOAST_TUPLE_THRESHOLD&lt;/code&gt; 字节（通常为2 kB）时，才会触发TOAST管理代码。 TOAST代码将离线压缩和/或移动字段值，直到行值小于 &lt;code&gt;TOAST_TUPLE_TARGET&lt;/code&gt; 字节（通常也为2 kB，可调）或不再有增益为止。在UPDATE操作期间，未更改字段的值通常按原样保留；因此，如果行值没有变化，则使用行值更新的行不会产生TOAST成本。</target>
        </trans-unit>
        <trans-unit id="2962f8d4658219a67247690e9e9ec2e5d8ddb34b" translate="yes" xml:space="preserve">
          <source>The TOAST management code recognizes four different strategies for storing TOAST-able columns on disk:</source>
          <target state="translated">TOAST管理代码认识到在磁盘上存储TOAST可列的四种不同策略。</target>
        </trans-unit>
        <trans-unit id="a81c03b713c7e31311d0848c27a627beb8a79d13" translate="yes" xml:space="preserve">
          <source>The Time Stamp Counter (TSC) clock source is the most accurate one available on current generation CPUs. It's the preferred way to track the system time when it's supported by the operating system and the TSC clock is reliable. There are several ways that TSC can fail to provide an accurate timing source, making it unreliable. Older systems can have a TSC clock that varies based on the CPU temperature, making it unusable for timing. Trying to use TSC on some older multicore CPUs can give a reported time that's inconsistent among multiple cores. This can result in the time going backwards, a problem this program checks for. And even the newest systems can fail to provide accurate TSC timing with very aggressive power saving configurations.</source>
          <target state="translated">时间戳计数器(TSC)时钟源是当前一代CPU上最精确的时钟源。在操作系统支持且TSC时钟可靠的情况下,它是跟踪系统时间的首选方式。TSC有几种方式不能提供准确的时序源,使其不可靠。旧系统的TSC时钟可能会根据CPU温度而变化,使其无法用于计时。试图在一些较老的多核CPU上使用TSC,可能会给出一个在多个核心之间不一致的报告时间。这可能会导致时间倒退,这个程序会检查这个问题。即使是最新的系统,在非常激进的节能配置下,也可能无法提供准确的TSC计时。</target>
        </trans-unit>
        <trans-unit id="42e64c3210927fbc153414d6d364fd7a502138f4" translate="yes" xml:space="preserve">
          <source>The URL scheme &lt;code&gt;ldaps&lt;/code&gt; chooses the LDAPS method for making LDAP connections over SSL, equivalent to using &lt;code&gt;ldapscheme=ldaps&lt;/code&gt;. To use encrypted LDAP connections using the &lt;code&gt;StartTLS&lt;/code&gt; operation, use the normal URL scheme &lt;code&gt;ldap&lt;/code&gt; and specify the &lt;code&gt;ldaptls&lt;/code&gt; option in addition to &lt;code&gt;ldapurl&lt;/code&gt;.</source>
          <target state="translated">URL方案 &lt;code&gt;ldaps&lt;/code&gt; 选择用于通过SSL建立LDAP连接的LDAPS方法，等效于使用 &lt;code&gt;ldapscheme=ldaps&lt;/code&gt; 。要使用 &lt;code&gt;StartTLS&lt;/code&gt; 操作使用加密的LDAP连接，请使用常规URL方案 &lt;code&gt;ldap&lt;/code&gt; 并指定 &lt;code&gt;ldaptls&lt;/code&gt; 选项和 &lt;code&gt;ldapurl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7c6010c68a5af10d545c5e024dfa86cf3e81ff1d" translate="yes" xml:space="preserve">
          <source>The Unicode escape syntax works fully only when the server encoding is &lt;code&gt;UTF8&lt;/code&gt;. When other server encodings are used, only code points in the ASCII range (up to &lt;code&gt;\u007F&lt;/code&gt;) can be specified. Both the 4-digit and the 8-digit form can be used to specify UTF-16 surrogate pairs to compose characters with code points larger than U+FFFF, although the availability of the 8-digit form technically makes this unnecessary. (When surrogate pairs are used when the server encoding is &lt;code&gt;UTF8&lt;/code&gt;, they are first combined into a single code point that is then encoded in UTF-8.)</source>
          <target state="translated">仅当服务器编码为 &lt;code&gt;UTF8&lt;/code&gt; 时，Unicode转义语法才能完全起作用。使用其他服务器编码时，只能指定ASCII范围（最大为 &lt;code&gt;\u007F&lt;/code&gt; ）中的代码点。 4位和8位格式都可以用来指定UTF-16代理对来组成代码点大于U + FFFF的字符，尽管从技术上说8位格式的可用性使这不必要。 （如果在服务器编码为 &lt;code&gt;UTF8&lt;/code&gt; 时使用代理对，则首先将它们组合成一个代码点，然后再以UTF-8编码。）</target>
        </trans-unit>
        <trans-unit id="9d177c404952bede8f8a850e0e6bf27fc770e815" translate="yes" xml:space="preserve">
          <source>The Unicode escape syntax works only when the server encoding is &lt;code&gt;UTF8&lt;/code&gt;. When other server encodings are used, only code points in the ASCII range (up to &lt;code&gt;\007F&lt;/code&gt;) can be specified. Both the 4-digit and the 6-digit form can be used to specify UTF-16 surrogate pairs to compose characters with code points larger than U+FFFF, although the availability of the 6-digit form technically makes this unnecessary. (Surrogate pairs are not stored directly, but combined into a single code point that is then encoded in UTF-8.)</source>
          <target state="translated">Unicode转义语法仅在服务器编码为 &lt;code&gt;UTF8&lt;/code&gt; 时有效。使用其他服务器编码时，只能指定ASCII范围（最大 &lt;code&gt;\007F&lt;/code&gt; ）中的代码点。 4位和6位格式都可以用于指定UTF-16代理对，以组成代码点大于U + FFFF的字符，尽管从6位格式的可用性来看，这是不必要的。 （代理对不直接存储，而是组合成一个代码点，然后以UTF-8编码。）</target>
        </trans-unit>
        <trans-unit id="7a66f8e165736e1d6137c7cb68f9f8d177bec3f5" translate="yes" xml:space="preserve">
          <source>The Unicode escape syntax works only when the server encoding is &lt;code&gt;UTF8&lt;/code&gt;. When other server encodings are used, only code points in the ASCII range (up to &lt;code&gt;\007F&lt;/code&gt;) can be specified. Both the 4-digit and the 6-digit form can be used to specify UTF-16 surrogate pairs to compose characters with code points larger than U+FFFF, although the availability of the 6-digit form technically makes this unnecessary. (When surrogate pairs are used when the server encoding is &lt;code&gt;UTF8&lt;/code&gt;, they are first combined into a single code point that is then encoded in UTF-8.)</source>
          <target state="translated">Unicode转义语法仅在服务器编码为 &lt;code&gt;UTF8&lt;/code&gt; 时有效。使用其他服务器编码时，只能指定ASCII范围（最大 &lt;code&gt;\007F&lt;/code&gt; ）中的代码点。4位和6位格式均可用于指定UTF-16代理对，以组成代码点大于U + FFFF的字符，尽管从6位格式的可用性来看，这是不必要的。（如果在服务器编码为 &lt;code&gt;UTF8&lt;/code&gt; 时使用代理对，则首先将它们组合成一个代码点，然后再以UTF-8编码。）</target>
        </trans-unit>
        <trans-unit id="f25ec485689944e9d0206ff9e943ed99a4c57c18" translate="yes" xml:space="preserve">
          <source>The WAL sender process is currently estimating the total amount of database files that will be streamed as a base backup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fad15d4e7352ffeba617fa81631fe16434d0ac21" translate="yes" xml:space="preserve">
          <source>The WAL sender process is currently performing &lt;code&gt;pg_start_backup&lt;/code&gt; to prepare to take a base backup, and waiting for the start-of-backup checkpoint to finish.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7b81498551e6dcef3f85194b60965948e30f611" translate="yes" xml:space="preserve">
          <source>The WAL sender process is currently performing &lt;code&gt;pg_stop_backup&lt;/code&gt; to finish the backup, and waiting for all the WAL files required for the base backup to be successfully archived. If either &lt;code&gt;--wal-method=none&lt;/code&gt; or &lt;code&gt;--wal-method=stream&lt;/code&gt; is specified in pg_basebackup, the backup will end when this phase is completed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="742081e8987be9e068dabd67697e13799d4135be" translate="yes" xml:space="preserve">
          <source>The WAL sender process is currently streaming database files as a base backup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26f868b9098d5fef7b7fac16f33bf4c597bcd9b6" translate="yes" xml:space="preserve">
          <source>The WAL sender process is currently transferring all WAL logs generated during the backup. This phase occurs after &lt;code&gt;waiting for wal archiving to finish&lt;/code&gt; phase if &lt;code&gt;--wal-method=fetch&lt;/code&gt; is specified in pg_basebackup. The backup will end when this phase is completed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="614ca7f59107c1f62192373c03f83f3a6cdc3ee6" translate="yes" xml:space="preserve">
          <source>The WAL sender process is preparing to begin the backup. This phase is expected to be very brief.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ece699458bd7501153fdfb1c5912141f3441417" translate="yes" xml:space="preserve">
          <source>The XPath-based functions support passing one parameter to serve as the XPath expression's context item, but do not support passing additional values to be available to the expression as named parameters.</source>
          <target state="translated">基于XPath的函数支持传递一个参数作为XPath表达式的上下文项,但不支持传递额外的值作为命名参数提供给表达式。</target>
        </trans-unit>
        <trans-unit id="68d2d71e2fc0b0be97c31a2b21762a50375e3cf0" translate="yes" xml:space="preserve">
          <source>The ability of pg_dump and psql to write to or read from pipes makes it possible to dump a database directly from one server to another, for example:</source>
          <target state="translated">pg_dump和psql能够从管道中写入或读取,这使得从一个服务器到另一个服务器直接转储数据库成为可能,例如。</target>
        </trans-unit>
        <trans-unit id="fa4fd86ff72f122e1d8e3fdfa6f01d6588a00c68" translate="yes" xml:space="preserve">
          <source>The ability to create a composite type with zero attributes is a PostgreSQL-specific deviation from the standard (analogous to the same case in &lt;code&gt;CREATE TABLE&lt;/code&gt;).</source>
          <target state="translated">创建具有零属性的复合类型的能力是PostgreSQL特定于标准的偏差（类似于 &lt;code&gt;CREATE TABLE&lt;/code&gt; 中的相同情况）。</target>
        </trans-unit>
        <trans-unit id="adfc2f9948045f7d285be1359a7594bd62946d41" translate="yes" xml:space="preserve">
          <source>The ability to create like-named objects in different schemas complicates writing a query that references precisely the same objects every time. It also opens up the potential for users to change the behavior of other users' queries, maliciously or accidentally. Due to the prevalence of unqualified names in queries and their use in PostgreSQL internals, adding a schema to &lt;code&gt;search_path&lt;/code&gt; effectively trusts all users having &lt;code&gt;CREATE&lt;/code&gt; privilege on that schema. When you run an ordinary query, a malicious user able to create objects in a schema of your search path can take control and execute arbitrary SQL functions as though you executed them.</source>
          <target state="translated">在不同模式中创建名称相同的对象的能力使编写每次都引用完全相同的对象的查询变得复杂。它还为用户打开了恶意或意外更改其他用户查询行为的可能性。由于查询中普遍存在不合格名称，并且在PostgreSQL内部使用了不合格名称，因此将模式添加到 &lt;code&gt;search_path&lt;/code&gt; 可以有效地信任对该模式具有 &lt;code&gt;CREATE&lt;/code&gt; 特权的所有用户。当您运行普通查询时，能够在搜索路径的架构中创建对象的恶意用户可以控制并执行任意SQL函数，就像执行它们一样。</target>
        </trans-unit>
        <trans-unit id="b4ae0fec1e129dc1403f8e4a1f54de4512e5b908" translate="yes" xml:space="preserve">
          <source>The ability to fire triggers for &lt;code&gt;TRUNCATE&lt;/code&gt; is a PostgreSQL extension of the SQL standard, as is the ability to define statement-level triggers on views.</source>
          <target state="translated">触发 &lt;code&gt;TRUNCATE&lt;/code&gt; 触发器的功能是SQL标准的PostgreSQL扩展，以及在视图上定义语句级触发器的功能。</target>
        </trans-unit>
        <trans-unit id="a5cde4cacd03ad144a2f1d01e84ddaf95711d39b" translate="yes" xml:space="preserve">
          <source>The ability to handle parts of executing a &lt;a href=&quot;glossary#GLOSSARY-QUERY&quot;&gt;query&lt;/a&gt; to take advantage of parallel processes on servers with multiple CPUs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3edb8c451c19be6c183faaf56035a29e2c4b780" translate="yes" xml:space="preserve">
          <source>The ability to restore the database to a previous point in time creates some complexities that are akin to science-fiction stories about time travel and parallel universes. For example, in the original history of the database, suppose you dropped a critical table at 5:15PM on Tuesday evening, but didn't realize your mistake until Wednesday noon. Unfazed, you get out your backup, restore to the point-in-time 5:14PM Tuesday evening, and are up and running. In &lt;em&gt;this&lt;/em&gt; history of the database universe, you never dropped the table. But suppose you later realize this wasn't such a great idea, and would like to return to sometime Wednesday morning in the original history. You won't be able to if, while your database was up-and-running, it overwrote some of the WAL segment files that led up to the time you now wish you could get back to. Thus, to avoid this, you need to distinguish the series of WAL records generated after you've done a point-in-time recovery from those that were generated in the original database history.</source>
          <target state="translated">将数据库还原到先前时间点的能力产生了一些复杂性，类似于有关时间旅行和平行宇宙的科幻小说故事。例如，在数据库的原始历史记录中，假设您在星期二晚上5:15 PM删除了一个关键表，但是直到星期三中午才意识到自己的错误。无需担心，您可以备份并恢复到星期二晚上5:14的时间点，并开始运行。在&lt;em&gt;这个&lt;/em&gt;数据库Universe的历史记录，您从未删除过表。但是，假设您后来意识到这并不是一个好主意，并且想回到原始历史中的星期三上午。在数据库运行期间，如果您覆盖了一些WAL段文件，而这些文件导致您现在希望回到原来的时间，那么您将无法执行。因此，为避免这种情况，您需要将时间点恢复后生成的一系列WAL记录与原始数据库历史记录中生成的WAL记录区分开。</target>
        </trans-unit>
        <trans-unit id="e29767e86a52c901615b571a0d1b5b49dcfd5235" translate="yes" xml:space="preserve">
          <source>The ability to specify argument modes and names</source>
          <target state="translated">能够指定参数模式和名称</target>
        </trans-unit>
        <trans-unit id="f83cfa93265ba6bdf2c4af4154ac85132df7584f" translate="yes" xml:space="preserve">
          <source>The ability to specify both &lt;code&gt;DISTINCT&lt;/code&gt; and &lt;code&gt;ORDER BY&lt;/code&gt; in an aggregate function is a PostgreSQL extension.</source>
          <target state="translated">在聚合函数中同时指定 &lt;code&gt;DISTINCT&lt;/code&gt; 和 &lt;code&gt;ORDER BY&lt;/code&gt; 的功能是PostgreSQL扩展。</target>
        </trans-unit>
        <trans-unit id="36892c35402a71971c62f926cf33611f0095f448" translate="yes" xml:space="preserve">
          <source>The ability to specify multiple actions for a single trigger using &lt;code&gt;OR&lt;/code&gt; is a PostgreSQL extension of the SQL standard.</source>
          <target state="translated">使用 &lt;code&gt;OR&lt;/code&gt; 为单个触发器指定多个操作的功能是SQL标准的PostgreSQL扩展。</target>
        </trans-unit>
        <trans-unit id="12f8b21071990877da6aa1b7a33a6ab04258d42b" translate="yes" xml:space="preserve">
          <source>The ability to temporarily enable or disable a trigger is provided by &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;, not by &lt;code&gt;ALTER TRIGGER&lt;/code&gt;, because &lt;code&gt;ALTER TRIGGER&lt;/code&gt; has no convenient way to express the option of enabling or disabling all of a table's triggers at once.</source>
          <target state="translated">临时启用或禁用触发器的功能是由&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;提供的，而不是由 &lt;code&gt;ALTER TRIGGER&lt;/code&gt; 提供的，因为 &lt;code&gt;ALTER TRIGGER&lt;/code&gt; 没有方便的方法来表示一次启用或禁用所有表触发器的选项。</target>
        </trans-unit>
        <trans-unit id="181b9f5d513d598d56342cbdee6549b14a30572c" translate="yes" xml:space="preserve">
          <source>The ability to use indexes with &lt;code&gt;LIKE&lt;/code&gt; clauses</source>
          <target state="translated">使用带有 &lt;code&gt;LIKE&lt;/code&gt; 子句的索引的能力</target>
        </trans-unit>
        <trans-unit id="cf1bad54aa29381ffc99e0cd6534801214045eea" translate="yes" xml:space="preserve">
          <source>The above are all simple text search examples. As mentioned before, full text search functionality includes the ability to do many more things: skip indexing certain words (stop words), process synonyms, and use sophisticated parsing, e.g., parse based on more than just white space. This functionality is controlled by &lt;em&gt;text search configurations&lt;/em&gt;. PostgreSQL comes with predefined configurations for many languages, and you can easily create your own configurations. (psql's &lt;code&gt;\dF&lt;/code&gt; command shows all available configurations.)</source>
          <target state="translated">以上都是简单的文本搜索示例。如前所述，全文搜索功能包括执行更多操作的能力：跳过对某些单词（停用词）建立索引，处理同义词以及使用复杂的语法分析（例如，基于多个空格进行语法分析）的功能。此功能由&lt;em&gt;文本搜索配置&lt;/em&gt;控制。PostgreSQL带有针对多种语言的预定义配置，您可以轻松创建自己的配置。（psql的 &lt;code&gt;\dF&lt;/code&gt; 命令显示所有可用的配置。）</target>
        </trans-unit>
        <trans-unit id="2c3e1167e52b923579b2a7fc4d461580b2f1f1dc" translate="yes" xml:space="preserve">
          <source>The above operations should be performed by an administrative user.</source>
          <target state="translated">以上操作应由管理用户执行。</target>
        </trans-unit>
        <trans-unit id="d0d28ebaf3e9bc7217eabce77d41a45e775db518" translate="yes" xml:space="preserve">
          <source>The above query only shows the rows from the inner query having &lt;code&gt;rank&lt;/code&gt; less than 3.</source>
          <target state="translated">上面的查询仅显示来自内部查询的行，其 &lt;code&gt;rank&lt;/code&gt; 小于3。</target>
        </trans-unit>
        <trans-unit id="5129e9bc20e65e89b0d436aa6187d7cf918d1aeb" translate="yes" xml:space="preserve">
          <source>The above query using &lt;code&gt;int_array_enum&lt;/code&gt; produces the same results as</source>
          <target state="translated">上面使用 &lt;code&gt;int_array_enum&lt;/code&gt; 的查询产生的结果与</target>
        </trans-unit>
        <trans-unit id="8107fdc88da76184415ef69e2ecad722706ac13d" translate="yes" xml:space="preserve">
          <source>The above rules associate greediness attributes not only with individual quantified atoms, but with branches and entire REs that contain quantified atoms. What that means is that the matching is done in such a way that the branch, or whole RE, matches the longest or shortest possible substring &lt;em&gt;as a whole&lt;/em&gt;. Once the length of the entire match is determined, the part of it that matches any particular subexpression is determined on the basis of the greediness attribute of that subexpression, with subexpressions starting earlier in the RE taking priority over ones starting later.</source>
          <target state="translated">上面的规则不仅将贪婪属性与单个量化原子关联，而且与包含量化原子的分支和整个RE关联。这意味着匹配是以分支或整个RE整体上匹配最长或最短子串的&lt;em&gt;方式进行的&lt;/em&gt;。一旦确定了整个匹配的长度，便会根据该子表达式的贪婪属性来确定与任何特定子表达式匹配的部分，其中子表达式在RE中较早开始，优先于较晚开始的子表达式。</target>
        </trans-unit>
        <trans-unit id="fe4e00a739ad370965c561bc4d7c298f0756e50c" translate="yes" xml:space="preserve">
          <source>The above skeleton is suitable for the case where no decompression is needed. (But, of course, omitting the method altogether is even easier, and is recommended in such cases.)</source>
          <target state="translated">以上骨架适合于不需要减压的情况。(当然,完全省略该方法更加容易,在这种情况下建议采用该方法)。</target>
        </trans-unit>
        <trans-unit id="6987a09f0b14c398190d54898784ad9944a48328" translate="yes" xml:space="preserve">
          <source>The above syntax has the drawback that you need to know the order of the columns in the table. To avoid this you can also list the columns explicitly. For example, both of the following commands have the same effect as the one above:</source>
          <target state="translated">上面的语法有一个缺点,就是你需要知道表中列的顺序。为了避免这种情况,你也可以明确地列出列。例如,下面两个命令的效果与上面的命令相同。</target>
        </trans-unit>
        <trans-unit id="d92b695ce2e1fc99e7debc111a49b6a3b4275271" translate="yes" xml:space="preserve">
          <source>The above transaction will insert both 3 and 4.</source>
          <target state="translated">上述交易将同时插入3和4。</target>
        </trans-unit>
        <trans-unit id="d3ded6bad4b3e8cb90f32aef7f2e2ce8e740539c" translate="yes" xml:space="preserve">
          <source>The above transaction will insert the values 1 and 3, but not 2.</source>
          <target state="translated">上述交易将插入值1和3,但不插入2。</target>
        </trans-unit>
        <trans-unit id="dec9b433ac3e4e8910b0ae4310ac815b98eb482c" translate="yes" xml:space="preserve">
          <source>The above will start the replication process, which synchronizes the initial table contents of the tables &lt;code&gt;users&lt;/code&gt; and &lt;code&gt;departments&lt;/code&gt; and then starts replicating incremental changes to those tables.</source>
          <target state="translated">上面的操作将启动复制过程，该过程将同步表 &lt;code&gt;users&lt;/code&gt; 和 &lt;code&gt;departments&lt;/code&gt; 的初始表内容，然后开始将增量更改复制到这些表。</target>
        </trans-unit>
        <trans-unit id="4792ca68861299622c8a8489cae6e3ff6fc1e734" translate="yes" xml:space="preserve">
          <source>The access costs should include all disk and CPU costs associated with scanning the index itself, but &lt;em&gt;not&lt;/em&gt; the costs of retrieving or processing the parent-table rows that are identified by the index.</source>
          <target state="translated">访问成本应包括与扫描索引本身相关的所有磁盘和CPU成本，但&lt;em&gt;不&lt;/em&gt;包括检索或处理由索引标识的父表行的成本。</target>
        </trans-unit>
        <trans-unit id="07883ad5be74942310a3c715c9a683e447816066" translate="yes" xml:space="preserve">
          <source>The access method can report that the index is &lt;em&gt;lossy&lt;/em&gt;, or requires rechecks, for a particular query. This implies that the index scan will return all the entries that pass the scan key, plus possibly additional entries that do not. The core system's index-scan machinery will then apply the index conditions again to the heap tuple to verify whether or not it really should be selected. If the recheck option is not specified, the index scan must return exactly the set of matching entries.</source>
          <target state="translated">访问方法可以报告特定查询的索引&lt;em&gt;有损&lt;/em&gt;，或者需要重新检查。这意味着索引扫描将返回所有通过扫描键的条目，以及可能未通过扫描键的其他条目。然后，核心系统的索引扫描机制将再次将索引条件应用于堆元组，以验证是否确实应该选择它。如果未指定recheck选项，则索引扫描必须完全返回匹配条目集。</target>
        </trans-unit>
        <trans-unit id="7463ace40ac0727457d3fd85331890fec1e03b44" translate="yes" xml:space="preserve">
          <source>The access method must identify any rows which might violate the unique constraint, but it is not an error for it to report false positives. This allows the check to be done without waiting for other transactions to finish; conflicts reported here are not treated as errors and will be rechecked later, by which time they may no longer be conflicts.</source>
          <target state="translated">访问方法必须识别任何可能违反唯一约束的行,但它报告假阳性并不是错误。这样就可以在不等待其他事务完成的情况下进行检查;这里报告的冲突不作为错误处理,将在以后重新检查,届时它们可能不再是冲突。</target>
        </trans-unit>
        <trans-unit id="3b57f7233950ac2f66da1f759e801ef6dd2f3764" translate="yes" xml:space="preserve">
          <source>The access method must support &lt;code&gt;amgettuple&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/indexam.html&quot;&gt;Chapter 61&lt;/a&gt;); at present this means GIN cannot be used. Although it's allowed, there is little point in using B-tree or hash indexes with an exclusion constraint, because this does nothing that an ordinary unique constraint doesn't do better. So in practice the access method will always be GiST or SP-GiST.</source>
          <target state="translated">访问方法必须支持 &lt;code&gt;amgettuple&lt;/code&gt; （请参阅&lt;a href=&quot;https://www.postgresql.org/docs/12/indexam.html&quot;&gt;第61章&lt;/a&gt;）；目前，这意味着无法使用GIN。尽管允许使用，但将B树或哈希索引与排除约束一起使用几乎没有意义，因为这无异于普通的唯一约束不能做得更好。因此，实际上，访问方法将始终是GiST或SP-GiST。</target>
        </trans-unit>
        <trans-unit id="f11bb13c1be4b89a9073f3965e1e4a21ea97d02b" translate="yes" xml:space="preserve">
          <source>The access method must support &lt;code&gt;amgettuple&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/13/indexam.html&quot;&gt;Chapter 61&lt;/a&gt;); at present this means GIN cannot be used. Although it's allowed, there is little point in using B-tree or hash indexes with an exclusion constraint, because this does nothing that an ordinary unique constraint doesn't do better. So in practice the access method will always be GiST or SP-GiST.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="925d234c42527636b378041891a37fa8bc13f69a" translate="yes" xml:space="preserve">
          <source>The access method name must be unique within the database.</source>
          <target state="translated">访问方法名称在数据库中必须是唯一的。</target>
        </trans-unit>
        <trans-unit id="269e5a0688390217e0c08f2b5f501b6e542e7ab1" translate="yes" xml:space="preserve">
          <source>The accumulated cost that will cause the vacuuming process to sleep. The default value is 200.</source>
          <target state="translated">导致吸尘过程进入睡眠状态的累计成本。默认值为200。</target>
        </trans-unit>
        <trans-unit id="1dfce3d6c647c6b7a46c7536dcf8246e840a748e" translate="yes" xml:space="preserve">
          <source>The accumulating calendar error prompted Pope Gregory XIII to reform the calendar in accordance with instructions from the Council of Trent. In the Gregorian calendar, the tropical year is approximated as 365 + 97 / 400 days = 365.2425 days. Thus it takes approximately 3300 years for the tropical year to shift one day with respect to the Gregorian calendar.</source>
          <target state="translated">日积月累的历法错误促使教皇格雷戈里十三世根据特伦特会议的指示改革历法。在格里高利历中,热带年近似为365+97/400天=365.2425天。因此,相对于格里高利历而言,热带年大约需要3300年才能移动一天。</target>
        </trans-unit>
        <trans-unit id="e8af8f1a0118bcdb3de7cccd47ade7dfba7146dc" translate="yes" xml:space="preserve">
          <source>The act of finalizing a &lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;transaction&lt;/a&gt; within the &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt;, which makes it visible to other transactions and assures its &lt;a href=&quot;glossary#GLOSSARY-DURABILITY&quot;&gt;durability&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db888abdcc969733f24ba8448a46853590f7acc2" translate="yes" xml:space="preserve">
          <source>The act of reproducing data on one &lt;a href=&quot;glossary#GLOSSARY-SERVER&quot;&gt;server&lt;/a&gt; onto another server called a &lt;a href=&quot;glossary#GLOSSARY-REPLICA&quot;&gt;replica&lt;/a&gt;. This can take the form of &lt;em&gt;physical replication&lt;/em&gt;, where all file changes from one server are copied verbatim, or &lt;em&gt;logical replication&lt;/em&gt; where a defined subset of data changes are conveyed using a higher-level representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e5a51f4541a92f0a7b8eafcdaec433dbe4bd0a9" translate="yes" xml:space="preserve">
          <source>The actions for identity columns (&lt;code&gt;ADD GENERATED&lt;/code&gt;, &lt;code&gt;SET&lt;/code&gt; etc., &lt;code&gt;DROP IDENTITY&lt;/code&gt;), as well as the actions &lt;code&gt;TRIGGER&lt;/code&gt;, &lt;code&gt;CLUSTER&lt;/code&gt;, &lt;code&gt;OWNER&lt;/code&gt;, and &lt;code&gt;TABLESPACE&lt;/code&gt; never recurse to descendant tables; that is, they always act as though &lt;code&gt;ONLY&lt;/code&gt; were specified. Adding a constraint recurses only for &lt;code&gt;CHECK&lt;/code&gt; constraints that are not marked &lt;code&gt;NO INHERIT&lt;/code&gt;.</source>
          <target state="translated">标识列的操作（ &lt;code&gt;ADD GENERATED&lt;/code&gt; ， &lt;code&gt;SET&lt;/code&gt; 等， &lt;code&gt;DROP IDENTITY&lt;/code&gt; ）以及 &lt;code&gt;TRIGGER&lt;/code&gt; ， &lt;code&gt;CLUSTER&lt;/code&gt; ， &lt;code&gt;OWNER&lt;/code&gt; 和 &lt;code&gt;TABLESPACE&lt;/code&gt; 的操作从不递归到后代表；也就是说，它们始终像 &lt;code&gt;ONLY&lt;/code&gt; 被指定那样起作用。仅对未标记为 &lt;code&gt;NO INHERIT&lt;/code&gt; 的 &lt;code&gt;CHECK&lt;/code&gt; 约束重复添加约束。</target>
        </trans-unit>
        <trans-unit id="909f7edd282ab8c888fdf2ed34039a5329b6ad7a" translate="yes" xml:space="preserve">
          <source>The actual choice here is mostly a matter of taste, constrained only by possible restrictions in client applications. Both methods support all possible values, although the hex encoding will be somewhat larger than the base64 encoding.</source>
          <target state="translated">这里的实际选择主要是一个品味问题,只受客户端应用中可能的限制制约。这两种方法都支持所有可能的值,尽管十六进制编码会比base64编码大一些。</target>
        </trans-unit>
        <trans-unit id="42c8786b869e4cc819db8d6cf4749d981fd3444f" translate="yes" xml:space="preserve">
          <source>The actual colors to be used are configured using the environment variable &lt;code&gt;PG_COLORS&lt;/code&gt; (note plural). The value is a colon-separated list of &lt;code&gt;key=value&lt;/code&gt; pairs. The keys specify what the color is to be used for. The values are SGR (Select Graphic Rendition) specifications, which are interpreted by the terminal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="486a25c1f79db6232bfe3c602e8f3539de88dd46" translate="yes" xml:space="preserve">
          <source>The actual data types of the various &lt;code&gt;Datum&lt;/code&gt; values mentioned above vary depending on the operator class. The item values passed to &lt;code&gt;extractValue&lt;/code&gt; are always of the operator class's input type, and all key values must be of the class's &lt;code&gt;STORAGE&lt;/code&gt; type. The type of the &lt;code&gt;query&lt;/code&gt; argument passed to &lt;code&gt;extractQuery&lt;/code&gt;, &lt;code&gt;consistent&lt;/code&gt; and &lt;code&gt;triConsistent&lt;/code&gt; is whatever is the right-hand input type of the class member operator identified by the strategy number. This need not be the same as the indexed type, so long as key values of the correct type can be extracted from it. However, it is recommended that the SQL declarations of these three support functions use the opclass's indexed data type for the &lt;code&gt;query&lt;/code&gt; argument, even though the actual type might be something else depending on the operator.</source>
          <target state="translated">上面提到的各种 &lt;code&gt;Datum&lt;/code&gt; 值的实际数据类型取决于运算符类别。传递给 &lt;code&gt;extractValue&lt;/code&gt; 的项目值始终是操作员类的输入类型，并且所有键值都必须是该类的 &lt;code&gt;STORAGE&lt;/code&gt; 类型。传递给 &lt;code&gt;extractQuery&lt;/code&gt; 的 &lt;code&gt;query&lt;/code&gt; 自变量的类型， &lt;code&gt;consistent&lt;/code&gt; 和 &lt;code&gt;triConsistent&lt;/code&gt; 是由策略编号标识的类成员运算符的右侧输入类型。只要可以从中提取正确类型的键值，就不必与索引类型相同。但是，建议这三个支持函数的SQL声明对 &lt;code&gt;query&lt;/code&gt; 参数使用opclass的索引数据类型，即使实际类型可能取决于操作符。</target>
        </trans-unit>
        <trans-unit id="941436b14f077228160b589974e7f72ed527cb34" translate="yes" xml:space="preserve">
          <source>The actual items themselves.</source>
          <target state="translated">实际物品本身。</target>
        </trans-unit>
        <trans-unit id="fffe8ba3b231865545aa8ca6fdb204ce35d44eac" translate="yes" xml:space="preserve">
          <source>The actual number of rows this query would select is 7000, but the &lt;code&gt;rows&lt;/code&gt; estimate is only approximate. If you try to duplicate this experiment, you will probably get a slightly different estimate; moreover, it can change after each &lt;code&gt;ANALYZE&lt;/code&gt; command, because the statistics produced by &lt;code&gt;ANALYZE&lt;/code&gt; are taken from a randomized sample of the table.</source>
          <target state="translated">该查询将选择的实际行数为7000，但是 &lt;code&gt;rows&lt;/code&gt; 估计数仅为近似值。如果您尝试重复此实验，则可能会得出略有不同的估算值；此外，它可以在每个 &lt;code&gt;ANALYZE&lt;/code&gt; 命令之后更改，因为 &lt;code&gt;ANALYZE&lt;/code&gt; 生成的统计信息取自该表的随机样本。</target>
        </trans-unit>
        <trans-unit id="6d27af95eda9a00aefcefbbb3f7c08b95ed3e6d3" translate="yes" xml:space="preserve">
          <source>The actual output rows are computed using the &lt;code&gt;SELECT&lt;/code&gt; output expressions for each selected row or row group. (See &lt;a href=&quot;sql-select#SQL-SELECT-LIST&quot;&gt;&lt;code&gt;SELECT&lt;/code&gt; List&lt;/a&gt; below.)</source>
          <target state="translated">实际的输出行是使用 &lt;code&gt;SELECT&lt;/code&gt; 输出表达式为每个选定的行或行组计算的。（请参阅下面的&amp;ldquo; &lt;a href=&quot;sql-select#SQL-SELECT-LIST&quot;&gt; &lt;code&gt;SELECT&lt;/code&gt; 列表&amp;rdquo;&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="748767c5001b9a6c88bed2030a93343c4f97acfc" translate="yes" xml:space="preserve">
          <source>The actual output rows are computed using the &lt;code&gt;SELECT&lt;/code&gt; output expressions for each selected row or row group. (See &lt;a href=&quot;sql-select#SQL-SELECT-LIST&quot;&gt;SELECT List&lt;/a&gt; below.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="747c207c89333b66eb66b4cfc2d12a9cf95c6535" translate="yes" xml:space="preserve">
          <source>The actual value of a parameter to the prepared statement. This must be an expression yielding a value that is compatible with the data type of this parameter, as was determined when the prepared statement was created.</source>
          <target state="translated">准备好的语句的参数的实际值。这必须是一个表达式,产生的值必须与该参数的数据类型相符,这是在创建准备好的语句时确定的。</target>
        </trans-unit>
        <trans-unit id="ac7f1235d4be6ac9ddfc264172bcdc008188f6f4" translate="yes" xml:space="preserve">
          <source>The added condition &lt;code&gt;stringu1 = 'xxx'&lt;/code&gt; reduces the output row count estimate, but not the cost because we still have to visit the same set of rows. Notice that the &lt;code&gt;stringu1&lt;/code&gt; clause cannot be applied as an index condition, since this index is only on the &lt;code&gt;unique1&lt;/code&gt; column. Instead it is applied as a filter on the rows retrieved by the index. Thus the cost has actually gone up slightly to reflect this extra checking.</source>
          <target state="translated">添加的条件 &lt;code&gt;stringu1 = 'xxx'&lt;/code&gt; 减少了输出行数估算值，但不会降低成本，因为我们仍然必须访问相同的行集。请注意， &lt;code&gt;stringu1&lt;/code&gt; 子句不能用作索引条件，因为该索引仅在 &lt;code&gt;unique1&lt;/code&gt; 列上。而是将其作为过滤器应用于索引检索的行。因此，成本实际上略有上升，以反映此额外的检查。</target>
        </trans-unit>
        <trans-unit id="0d6d3b7f07c64185ea468d2b62ff4270f9a83a5e" translate="yes" xml:space="preserve">
          <source>The additional &lt;em&gt;&lt;code&gt;heapallindexed&lt;/code&gt;&lt;/em&gt; phase adds significant overhead: verification will typically take several times longer. However, there is no change to the relation-level locks acquired when &lt;em&gt;&lt;code&gt;heapallindexed&lt;/code&gt;&lt;/em&gt; verification is performed.</source>
          <target state="translated">额外的&lt;em&gt; &lt;code&gt;heapallindexed&lt;/code&gt; &lt;/em&gt;阶段会增加大量开销：验证通常会花费几倍的时间。但是，执行&lt;em&gt; &lt;code&gt;heapallindexed&lt;/code&gt; &lt;/em&gt;验证时获取的关系级别锁没有任何变化。</target>
        </trans-unit>
        <trans-unit id="9c1fb74bfe43620aa3ec5e950d1f4303783e6a3c" translate="yes" xml:space="preserve">
          <source>The address (&lt;code&gt;LSN&lt;/code&gt;) of oldest WAL which still might be required by the consumer of this slot and thus won't be automatically removed during checkpoints unless this LSN gets behind more than &lt;a href=&quot;runtime-config-replication#GUC-MAX-SLOT-WAL-KEEP-SIZE&quot;&gt;max_slot_wal_keep_size&lt;/a&gt; from the current LSN. &lt;code&gt;NULL&lt;/code&gt; if the &lt;code&gt;LSN&lt;/code&gt; of this slot has never been reserved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ce4777382e2000ea7e60f8a7131343e38753550" translate="yes" xml:space="preserve">
          <source>The address (&lt;code&gt;LSN&lt;/code&gt;) of oldest WAL which still might be required by the consumer of this slot and thus won't be automatically removed during checkpoints. &lt;code&gt;NULL&lt;/code&gt; if the &lt;code&gt;LSN&lt;/code&gt; of this slot has never been reserved.</source>
          <target state="translated">该插槽的使用者可能仍需要最旧的WAL 的地址（ &lt;code&gt;LSN&lt;/code&gt; ），因此不会在检查点期间自动删除。如果从未保留此插槽的 &lt;code&gt;LSN&lt;/code&gt; ，则为 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="034439fc21dbd36a2802df824278cae81f75f88d" translate="yes" xml:space="preserve">
          <source>The address (&lt;code&gt;LSN&lt;/code&gt;) up to which the logical slot's consumer has confirmed receiving data. Data older than this is not available anymore. &lt;code&gt;NULL&lt;/code&gt; for physical slots.</source>
          <target state="translated">逻辑插槽的使用者已确认接收到的地址（ &lt;code&gt;LSN&lt;/code&gt; ）。早于该时间的数据不再可用。物理插槽为 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a0ec05d31abc58e50953bffde428d1c139a9fa7" translate="yes" xml:space="preserve">
          <source>The aggregate functions &lt;code&gt;array_agg&lt;/code&gt;, &lt;code&gt;json_agg&lt;/code&gt;, &lt;code&gt;jsonb_agg&lt;/code&gt;, &lt;code&gt;json_object_agg&lt;/code&gt;, &lt;code&gt;jsonb_object_agg&lt;/code&gt;, &lt;code&gt;string_agg&lt;/code&gt;, and &lt;code&gt;xmlagg&lt;/code&gt;, as well as similar user-defined aggregate functions, produce meaningfully different result values depending on the order of the input values. This ordering is unspecified by default, but can be controlled by writing an &lt;code&gt;ORDER BY&lt;/code&gt; clause within the aggregate call, as shown in &lt;a href=&quot;sql-expressions#SYNTAX-AGGREGATES&quot;&gt;Section 4.2.7&lt;/a&gt;. Alternatively, supplying the input values from a sorted subquery will usually work. For example:</source>
          <target state="translated">聚合函数 &lt;code&gt;array_agg&lt;/code&gt; ， &lt;code&gt;json_agg&lt;/code&gt; ， &lt;code&gt;jsonb_agg&lt;/code&gt; ， &lt;code&gt;json_object_agg&lt;/code&gt; ， &lt;code&gt;jsonb_object_agg&lt;/code&gt; ， &lt;code&gt;string_agg&lt;/code&gt; 和 &lt;code&gt;xmlagg&lt;/code&gt; 以及类似的用户定义的聚合函数根据输入值的顺序产生有意义的不同结果值。默认情况下未指定此顺序，但是可以通过在聚合调用中编写 &lt;code&gt;ORDER BY&lt;/code&gt; 子句来控制，如&lt;a href=&quot;sql-expressions#SYNTAX-AGGREGATES&quot;&gt;第4.2.7节&lt;/a&gt;所示。或者，通常可以从已排序的子查询中提供输入值。例如：</target>
        </trans-unit>
        <trans-unit id="25a2a3e2d738bffa30059bdc53d46f7e3eca9a3f" translate="yes" xml:space="preserve">
          <source>The aggregator is an aggregate function &lt;code&gt;int_array_aggregate(integer)&lt;/code&gt; that produces an integer array containing exactly the integers it is fed. This is a wrapper around &lt;code&gt;array_agg&lt;/code&gt;, which does the same thing for any array type.</source>
          <target state="translated">聚合器是一个聚合函数 &lt;code&gt;int_array_aggregate(integer)&lt;/code&gt; ，它生成一个整数数组，该数组精确地包含它所馈送的整数。这是 &lt;code&gt;array_agg&lt;/code&gt; 的包装，它对任何数组类型都执行相同的操作。</target>
        </trans-unit>
        <trans-unit id="424703d8d222e3285ae8821252bab5f244b1d269" translate="yes" xml:space="preserve">
          <source>The aim of WAL is to ensure that the log is written before database records are altered, but this can be subverted by disk drives that falsely report a successful write to the kernel, when in fact they have only cached the data and not yet stored it on the disk. A power failure in such a situation might lead to irrecoverable data corruption. Administrators should try to ensure that disks holding PostgreSQL's WAL log files do not make such false reports. (See &lt;a href=&quot;wal-reliability&quot;&gt;Section 29.1&lt;/a&gt;.)</source>
          <target state="translated">WAL的目的是确保在更改数据库记录之前写入日志，但是可以通过错误地向内核报告成功写入的磁盘驱动器来破坏日志，而实际上它们只是缓存了数据而尚未存储它在磁盘上。在这种情况下断电可能会导致不可恢复的数据损坏。管理员应尝试确保保存PostgreSQL WAL日志文件的磁盘不会做出此类错误报告。（请参阅&lt;a href=&quot;wal-reliability&quot;&gt;第29.1节&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="f9e7ab5030dfc9ff217b5be87f2efd2576b52bbd" translate="yes" xml:space="preserve">
          <source>The algorithms in &lt;code&gt;crypt()&lt;/code&gt; differ from the usual MD5 or SHA1 hashing algorithms in the following respects:</source>
          <target state="translated">在算法 &lt;code&gt;crypt()&lt;/code&gt; 在以下方面与通常的MD5或SHA1哈希算法不同：</target>
        </trans-unit>
        <trans-unit id="bb6ddacff228befd7481577e88b1910758787a46" translate="yes" xml:space="preserve">
          <source>The alias becomes the new name of the table reference so far as the current query is concerned &amp;mdash; it is not allowed to refer to the table by the original name elsewhere in the query. Thus, this is not valid:</source>
          <target state="translated">就当前查询而言，别名成为表引用的新名称-不允许使用查询中其他位置的原始名称引用该表。因此，这是无效的：</target>
        </trans-unit>
        <trans-unit id="5c707c122664d3415484ea0149341fcdfab44cfa" translate="yes" xml:space="preserve">
          <source>The allowed contents of a &lt;code&gt;RETURNING&lt;/code&gt; clause are the same as a &lt;code&gt;SELECT&lt;/code&gt; command's output list (see &lt;a href=&quot;queries-select-lists&quot;&gt;Section 7.3&lt;/a&gt;). It can contain column names of the command's target table, or value expressions using those columns. A common shorthand is &lt;code&gt;RETURNING *&lt;/code&gt;, which selects all columns of the target table in order.</source>
          <target state="translated">&lt;code&gt;RETURNING&lt;/code&gt; 子句的允许内容与 &lt;code&gt;SELECT&lt;/code&gt; 命令的输出列表相同（请参见&lt;a href=&quot;queries-select-lists&quot;&gt;7.3节&lt;/a&gt;）。它可以包含命令目标表的列名，也可以包含使用这些列的值表达式。常见的缩写是 &lt;code&gt;RETURNING *&lt;/code&gt; ，它按顺序选择目标表的所有列。</target>
        </trans-unit>
        <trans-unit id="6fc27c228553cd704a3ef6963db1526d2404113f" translate="yes" xml:space="preserve">
          <source>The alternative archive file formats must be used with &lt;a href=&quot;app-pgrestore&quot;&gt;pg_restore&lt;/a&gt; to rebuild the database. They allow pg_restore to be selective about what is restored, or even to reorder the items prior to being restored. The archive file formats are designed to be portable across architectures.</source>
          <target state="translated">备用存档文件格式必须与&lt;a href=&quot;app-pgrestore&quot;&gt;pg_restore&lt;/a&gt;一起使用才能重建数据库。它们允许pg_restore对恢复什么有选择性，甚至可以在恢复之前对项目进行重新排序。存档文件格式设计为可跨体系结构移植。</target>
        </trans-unit>
        <trans-unit id="30b730b12e2a6a8e73614c8aa5e3a5771cc3031c" translate="yes" xml:space="preserve">
          <source>The amount of information stored in &lt;code&gt;pg_statistic&lt;/code&gt; by &lt;code&gt;ANALYZE&lt;/code&gt;, in particular the maximum number of entries in the &lt;code&gt;most_common_vals&lt;/code&gt; and &lt;code&gt;histogram_bounds&lt;/code&gt; arrays for each column, can be set on a column-by-column basis using the &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt; command, or globally by setting the &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; configuration variable. The default limit is presently 100 entries. Raising the limit might allow more accurate planner estimates to be made, particularly for columns with irregular data distributions, at the price of consuming more space in &lt;code&gt;pg_statistic&lt;/code&gt; and slightly more time to compute the estimates. Conversely, a lower limit might be sufficient for columns with simple data distributions.</source>
          <target state="translated">可以使用 &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt; 命令逐列设置 &lt;code&gt;ANALYZE&lt;/code&gt; 通过ANALYZE存储在 &lt;code&gt;pg_statistic&lt;/code&gt; 中的信息量，尤其是 &lt;code&gt;most_common_vals&lt;/code&gt; 和 &lt;code&gt;histogram_bounds&lt;/code&gt; 数组中的最大条目数，或者使用ALTER TABLE SET STATISTICS命令逐列设置所述&lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt;配置变量。默认限制是当前100个条目。提高该限制可能允许进行更准确的计划程序估计，尤其是对于数据分布不规则的列，其代价是要占用 &lt;code&gt;pg_statistic&lt;/code&gt; 中的更多空间和更多的时间来计算估算值。相反，对于具有简单数据分布的列，下限可能就足够了。</target>
        </trans-unit>
        <trans-unit id="0881173259f19f591f19be0dcc933c7ede671117" translate="yes" xml:space="preserve">
          <source>The amount of shared memory used for WAL data that has not yet been written to disk. The default setting of -1 selects a size equal to 1/32nd (about 3%) of &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;, but not less than &lt;code&gt;64kB&lt;/code&gt; nor more than the size of one WAL segment, typically &lt;code&gt;16MB&lt;/code&gt;. This value can be set manually if the automatic choice is too large or too small, but any positive value less than &lt;code&gt;32kB&lt;/code&gt; will be treated as &lt;code&gt;32kB&lt;/code&gt;. If this value is specified without units, it is taken as WAL blocks, that is &lt;code&gt;XLOG_BLCKSZ&lt;/code&gt; bytes, typically 8kB. This parameter can only be set at server start.</source>
          <target state="translated">用于尚未写入磁盘的WAL数据的共享内存量。默认设置为-1时，选择的大小等于&lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers的&lt;/a&gt; 1 / 32nd（大约3％），但不小于 &lt;code&gt;64kB&lt;/code&gt; ,也不大于一个WAL段的大小，通常为 &lt;code&gt;16MB&lt;/code&gt; 。如果自动选择太大或太小，可以手动设置此值，但是任何小于 &lt;code&gt;32kB&lt;/code&gt; 的正值都将被视为 &lt;code&gt;32kB&lt;/code&gt; 。如果指定的该值不带单位，则将其视为WAL块，即 &lt;code&gt;XLOG_BLCKSZ&lt;/code&gt; 字节，通常为8kB。该参数只能在服务器启动时设置。</target>
        </trans-unit>
        <trans-unit id="fb3e8e0a1884bdfed25b92caf4ca9464cbb400f7" translate="yes" xml:space="preserve">
          <source>The amount of time that the process will sleep when the cost limit has been exceeded. If this value is specified without units, it is taken as milliseconds. The default value is zero, which disables the cost-based vacuum delay feature. Positive values enable cost-based vacuuming.</source>
          <target state="translated">当超过成本限制时,流程的休眠时间。如果没有指定单位,则取为毫秒。默认值为零,这将禁用基于成本的真空延迟功能。正值可启用基于成本的真空功能。</target>
        </trans-unit>
        <trans-unit id="398a780c0d81cf69e4ef47e3ad5d58413fde5194" translate="yes" xml:space="preserve">
          <source>The amount of time to delay just after a new server process is forked, before it conducts the authentication procedure. This is intended to give developers an opportunity to attach to the server process with a debugger to trace down misbehavior in authentication. If this value is specified without units, it is taken as seconds. A value of zero (the default) disables the delay. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">分叉新服务器进程之后执行认证过程之前要延迟的时间。目的是使开发人员有机会使用调试器附加到服务器进程，以跟踪身份验证中的不良行为。如果指定的该值不带单位，则以秒为单位。零值（默认值）禁用延迟。此参数只能在 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件或服务器命令行中设置。</target>
        </trans-unit>
        <trans-unit id="eaa9e04a9a492e3d82c3eee69d98abd9fe97d974" translate="yes" xml:space="preserve">
          <source>The amount of time to delay when a new server process is started, after it conducts the authentication procedure. This is intended to give developers an opportunity to attach to the server process with a debugger. If this value is specified without units, it is taken as seconds. A value of zero (the default) disables the delay. This parameter cannot be changed after session start.</source>
          <target state="translated">在新的服务器进程启动时,在它进行认证程序后,延迟的时间。这样做的目的是让开发人员有机会用调试器连接到服务器进程。如果这个值没有指定单位,则以秒为单位。值为零(默认)则禁用延迟。这个参数在会话启动后不能改变。</target>
        </trans-unit>
        <trans-unit id="6eb708237d12cba546c559b2942241cf8b7e257d" translate="yes" xml:space="preserve">
          <source>The apply process on the subscriber database always runs with &lt;code&gt;session_replication_role&lt;/code&gt; set to &lt;code&gt;replica&lt;/code&gt;, which produces the usual effects on triggers and constraints.</source>
          <target state="translated">在订户数据库上的应用过程始终在将 &lt;code&gt;session_replication_role&lt;/code&gt; 设置为 &lt;code&gt;replica&lt;/code&gt; 运行，这会对触发器和约束产生通常的影响。</target>
        </trans-unit>
        <trans-unit id="7cc0c47ee6bb287c95c39ac65d501649b42f2391" translate="yes" xml:space="preserve">
          <source>The approach of lower-casing strings for comparison does not handle some Unicode special cases correctly, for example when one upper-case letter has two lower-case letter equivalents. Unicode distinguishes between &lt;em&gt;case mapping&lt;/em&gt; and &lt;em&gt;case folding&lt;/em&gt; for this reason. Use nondeterministic collations instead of &lt;code&gt;citext&lt;/code&gt; to handle that correctly.</source>
          <target state="translated">使用小写字符串进行比较的方法不能正确处理某些Unicode特殊情况，例如，当一个大写字母具有两个等效的小写字母时。因此，Unicode区分&lt;em&gt;大小写映射&lt;/em&gt;和&lt;em&gt;大小写折叠&lt;/em&gt;。使用非确定性排序规则而不是 &lt;code&gt;citext&lt;/code&gt; 可以正确处理该问题。</target>
        </trans-unit>
        <trans-unit id="6080666b4ca02e10aa81255d6daacddec5bda53b" translate="yes" xml:space="preserve">
          <source>The approximate average size (in bytes) of the aggregate's state value, when using moving-aggregate mode. This works the same as &lt;code&gt;state_data_size&lt;/code&gt;.</source>
          <target state="translated">使用移动聚合模式时，聚合状态值的近似平均大小（以字节为单位）。这与 &lt;code&gt;state_data_size&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="f88fc1ceaae9590f9501a23eabf20365f3ad0987" translate="yes" xml:space="preserve">
          <source>The approximate average size (in bytes) of the aggregate's state value. If this parameter is omitted or is zero, a default estimate is used based on the &lt;code&gt;state_data_type&lt;/code&gt;. The planner uses this value to estimate the memory required for a grouped aggregate query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd3a8a8bd1d1979e55b0fa66bfe45e8f15c71463" translate="yes" xml:space="preserve">
          <source>The approximate average size (in bytes) of the aggregate's state value. If this parameter is omitted or is zero, a default estimate is used based on the &lt;code&gt;state_data_type&lt;/code&gt;. The planner uses this value to estimate the memory required for a grouped aggregate query. The planner will consider using hash aggregation for such a query only if the hash table is estimated to fit in &lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt;work_mem&lt;/a&gt;; therefore, large values of this parameter discourage use of hash aggregation.</source>
          <target state="translated">聚合状态值的近似平均大小（以字节为单位）。如果省略此参数或将其设置为零，则基于 &lt;code&gt;state_data_type&lt;/code&gt; 使用默认估计。计划者使用此值来估计分组聚合查询所需的内存。仅当估计哈希表适合&lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt;work_mem时&lt;/a&gt;，计划者才会考虑对此类查询使用哈希聚合；因此，此参数的较大值不鼓励使用哈希聚合。</target>
        </trans-unit>
        <trans-unit id="5bc1a8ecb6b5b4b69664dd591c46774534fc3e77" translate="yes" xml:space="preserve">
          <source>The approximation 365+97/400 is achieved by having 97 leap years every 400 years, using the following rules:</source>
          <target state="translated">近似值365+97/400是通过每400年有97个闰年来实现的,使用的规则如下:</target>
        </trans-unit>
        <trans-unit id="31a6736bfcac19a9525dbc2f1d3d326327c448b4" translate="yes" xml:space="preserve">
          <source>The archive command is only invoked on completed WAL segments. Hence, if your server generates only little WAL traffic (or has slack periods where it does so), there could be a long delay between the completion of a transaction and its safe recording in archive storage. To put a limit on how old unarchived data can be, you can set &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-TIMEOUT&quot;&gt;archive_timeout&lt;/a&gt; to force the server to switch to a new WAL segment file at least that often. Note that archived files that are archived early due to a forced switch are still the same length as completely full files. It is therefore unwise to set a very short &lt;code&gt;archive_timeout&lt;/code&gt; &amp;mdash; it will bloat your archive storage. &lt;code&gt;archive_timeout&lt;/code&gt; settings of a minute or so are usually reasonable.</source>
          <target state="translated">仅在完成的WAL段上调用archive命令。因此，如果您的服务器仅产生很少的WAL流量（或在此期间有闲置时间），则在事务完成和将其安全记录到归档存储之间可能会有很长的延迟。要限制未归档数据的使用期限，可以设置&lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-TIMEOUT&quot;&gt;archive_timeout&lt;/a&gt;强制服务器至少经常切换至新的WAL段文件。请注意，由于强制切换而提前存档的存档文件的长度仍然与完全完整的文件相同。因此，设置一个很短的 &lt;code&gt;archive_timeout&lt;/code&gt; 是不明智的-它会使您的归档存储空间过大。一分钟左右的 &lt;code&gt;archive_timeout&lt;/code&gt; 设置通常是合理的。</target>
        </trans-unit>
        <trans-unit id="4b5c4c289983b255b0c54296b2920b77c593a40a" translate="yes" xml:space="preserve">
          <source>The archive command should generally be designed to refuse to overwrite any pre-existing archive file. This is an important safety feature to preserve the integrity of your archive in case of administrator error (such as sending the output of two different servers to the same archive directory).</source>
          <target state="translated">一般来说,归档命令应该被设计成拒绝覆盖任何已经存在的归档文件。这是一个重要的安全功能,可以在管理员出错的情况下保持存档的完整性(例如将两个不同服务器的输出发送到同一个存档目录)。</target>
        </trans-unit>
        <trans-unit id="cf0db639e47353fbf356cd38ab714bab5a462b99" translate="yes" xml:space="preserve">
          <source>The archive command will be executed under the ownership of the same user that the PostgreSQL server is running as. Since the series of WAL files being archived contains effectively everything in your database, you will want to be sure that the archived data is protected from prying eyes; for example, archive into a directory that does not have group or world read access.</source>
          <target state="translated">归档命令将在PostgreSQL服务器运行的同一用户的所有权下执行。由于被归档的WAL文件系列实际上包含了数据库中的所有内容,因此,你要确保归档的数据不被窥视,例如,归档到一个没有组或世界读取权限的目录中。</target>
        </trans-unit>
        <trans-unit id="c8f2b342beee7c3f52ad6834dd7e62ec7b49990d" translate="yes" xml:space="preserve">
          <source>The archive is a &lt;code&gt;tar&lt;/code&gt; archive.</source>
          <target state="translated">该档案是 &lt;code&gt;tar&lt;/code&gt; 档案。</target>
        </trans-unit>
        <trans-unit id="d5dd8d384e2ea3f19ced747049fc2fc3701b0b55" translate="yes" xml:space="preserve">
          <source>The archive is a directory archive.</source>
          <target state="translated">该档案是一个目录档案。</target>
        </trans-unit>
        <trans-unit id="055700e9693e4de21f0986775e962d50e33c74ee" translate="yes" xml:space="preserve">
          <source>The archive is in the custom format of pg_dump.</source>
          <target state="translated">归档是pg_dump的自定义格式。</target>
        </trans-unit>
        <trans-unit id="eadab5c3d582261bf3c9c742fde723a5f27a622f" translate="yes" xml:space="preserve">
          <source>The argument is a pointer to a &lt;code&gt;GISTENTRY&lt;/code&gt; struct. On entry, its &lt;code&gt;key&lt;/code&gt; field contains a non-NULL leaf datum in compressed form. The return value is another &lt;code&gt;GISTENTRY&lt;/code&gt; struct, whose &lt;code&gt;key&lt;/code&gt; field contains the same datum in its original, uncompressed form. If the opclass's compress function does nothing for leaf entries, the &lt;code&gt;fetch&lt;/code&gt; method can return the argument as-is. Or, if the opclass does not have a compress function, the &lt;code&gt;fetch&lt;/code&gt; method can be omitted as well, since it would necessarily be a no-op.</source>
          <target state="translated">该参数是指向 &lt;code&gt;GISTENTRY&lt;/code&gt; 结构的指针。在输入时，其 &lt;code&gt;key&lt;/code&gt; 字段包含压缩形式的非NULL叶子数据。返回值是另一个 &lt;code&gt;GISTENTRY&lt;/code&gt; 结构，其 &lt;code&gt;key&lt;/code&gt; 字段以原始的未压缩形式包含相同的数据。如果opclass的compress函数对叶条目不执行任何操作，则 &lt;code&gt;fetch&lt;/code&gt; 方法可以按原样返回参数。或者，如果opclass没有compress函数，则 &lt;code&gt;fetch&lt;/code&gt; 方法也可以省略，因为它必然是no-op。</target>
        </trans-unit>
        <trans-unit id="dac840b1ef4656a9069d124658163a0da1612eba" translate="yes" xml:space="preserve">
          <source>The argument of &lt;code&gt;EXISTS&lt;/code&gt; is an arbitrary &lt;code&gt;SELECT&lt;/code&gt; statement, or &lt;em&gt;subquery&lt;/em&gt;. The subquery is evaluated to determine whether it returns any rows. If it returns at least one row, the result of &lt;code&gt;EXISTS&lt;/code&gt; is &amp;ldquo;true&amp;rdquo;; if the subquery returns no rows, the result of &lt;code&gt;EXISTS&lt;/code&gt; is &amp;ldquo;false&amp;rdquo;.</source>
          <target state="translated">&lt;code&gt;EXISTS&lt;/code&gt; 的参数是任意的 &lt;code&gt;SELECT&lt;/code&gt; 语句或&lt;em&gt;subquery&lt;/em&gt;。评估子查询以确定它是否返回任何行。如果返回至少一行，则 &lt;code&gt;EXISTS&lt;/code&gt; 的结果为&amp;ldquo; true&amp;rdquo;；如果子查询不返回任何行，则 &lt;code&gt;EXISTS&lt;/code&gt; 的结果为&amp;ldquo; false&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="d6ba5cebe3465380bdcbb01333aff93c94b4f911" translate="yes" xml:space="preserve">
          <source>The arguments can appear in any order, not only the one shown above.</source>
          <target state="translated">参数可以以任何顺序出现,而不仅仅是上图所示的那个。</target>
        </trans-unit>
        <trans-unit id="e994da275c22b1ba01eba6c807a42b44a7a8c8c1" translate="yes" xml:space="preserve">
          <source>The arguments can optionally have names attached. See &lt;a href=&quot;sql-syntax-calling-funcs&quot;&gt;Section 4.3&lt;/a&gt; for details.</source>
          <target state="translated">参数可以选择附加名称。有关详细信息，请参见&lt;a href=&quot;sql-syntax-calling-funcs&quot;&gt;第4.3节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b00f745b2cd63e4e8f1ed5a9dd09b736b5753686" translate="yes" xml:space="preserve">
          <source>The arguments must all be convertible to a common data type, which will be the type of the result (see &lt;a href=&quot;typeconv-union-case&quot;&gt;Section 10.5&lt;/a&gt; for details).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdbe896c9bc5e0129d6c42af254aeecec20136cc" translate="yes" xml:space="preserve">
          <source>The arguments of &lt;code&gt;\set&lt;/code&gt; are subject to the same substitution rules as with other commands. Thus you can construct interesting references such as &lt;code&gt;\set :foo 'something'&lt;/code&gt; and get &amp;ldquo;soft links&amp;rdquo; or &amp;ldquo;variable variables&amp;rdquo; of Perl or PHP fame, respectively. Unfortunately (or fortunately?), there is no way to do anything useful with these constructs. On the other hand, &lt;code&gt;\set bar :foo&lt;/code&gt; is a perfectly valid way to copy a variable.</source>
          <target state="translated">&lt;code&gt;\set&lt;/code&gt; 的参数应遵循与其他命令相同的替换规则。因此，您可以构造有趣的引用，例如 &lt;code&gt;\set :foo 'something'&lt;/code&gt; 并分别获得Perl或PHP的&amp;ldquo;软链接&amp;rdquo;或&amp;ldquo;变量变量&amp;rdquo;。不幸的是（或者幸运的是？），无法对这些构造做任何有用的事情。另一方面， &lt;code&gt;\set bar :foo&lt;/code&gt; 是复制变量的完美有效方法。</target>
        </trans-unit>
        <trans-unit id="2a1116027fc276cc8421c002135dbd224494828a" translate="yes" xml:space="preserve">
          <source>The arguments to the &lt;code&gt;distance&lt;/code&gt; function are identical to the arguments of the &lt;code&gt;consistent&lt;/code&gt; function.</source>
          <target state="translated">所涉及的参数 &lt;code&gt;distance&lt;/code&gt; 函数是相同的的参数 &lt;code&gt;consistent&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="7770d5c449c9e31af54123c29733b7fdcc835b68" translate="yes" xml:space="preserve">
          <source>The arithmetic, bitwise, comparison and logical operators listed in &lt;a href=&quot;pgbench#PGBENCH-OPERATORS&quot;&gt;Table 258&lt;/a&gt; are built into pgbench and may be used in expressions appearing in &lt;a href=&quot;pgbench#PGBENCH-METACOMMAND-SET&quot;&gt;&lt;code&gt;\set&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pgbench#PGBENCH-OPERATORS&quot;&gt;表258&lt;/a&gt;中列出的算术，按位，比较和逻辑运算符内置在pgbench中，可以在&lt;a href=&quot;pgbench#PGBENCH-METACOMMAND-SET&quot;&gt; &lt;code&gt;\set&lt;/code&gt; &lt;/a&gt;出现的表达式中使用。</target>
        </trans-unit>
        <trans-unit id="c75d7c8ffc6407b194e547c6bae30091147ee957" translate="yes" xml:space="preserve">
          <source>The arithmetic, bitwise, comparison and logical operators listed in &lt;a href=&quot;pgbench#PGBENCH-OPERATORS&quot;&gt;Table 274&lt;/a&gt; are built into pgbench and may be used in expressions appearing in &lt;a href=&quot;pgbench#PGBENCH-METACOMMAND-SET&quot;&gt;&lt;code&gt;\set&lt;/code&gt;&lt;/a&gt;. The operators are listed in increasing precedence order. Except as noted, operators taking two numeric inputs will produce a double value if either input is double, otherwise they produce an integer result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f99ae22a382dffdb58abe986f81d4d8fc31ff15a" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;scankeys&lt;/code&gt;, of length &lt;code&gt;nkeys&lt;/code&gt;, describes the index search condition(s). These conditions are combined with AND &amp;mdash; only index entries that satisfy all of them are interesting. (Note that &lt;code&gt;nkeys&lt;/code&gt; = 0 implies that all index entries satisfy the query.) Usually the consistent function only cares about the &lt;code&gt;sk_strategy&lt;/code&gt; and &lt;code&gt;sk_argument&lt;/code&gt; fields of each array entry, which respectively give the indexable operator and comparison value. In particular it is not necessary to check &lt;code&gt;sk_flags&lt;/code&gt; to see if the comparison value is NULL, because the SP-GiST core code will filter out such conditions. The array &lt;code&gt;orderbys&lt;/code&gt;, of length &lt;code&gt;norderbys&lt;/code&gt;, describes ordering operators (if any) in the same manner. &lt;code&gt;reconstructedValue&lt;/code&gt; is the value reconstructed for the parent tuple; it is &lt;code&gt;(Datum) 0&lt;/code&gt; at the root level or if the &lt;code&gt;inner_consistent&lt;/code&gt; function did not provide a value at the parent level. &lt;code&gt;reconstructedValue&lt;/code&gt; is always of &lt;code&gt;spgConfigOut&lt;/code&gt;.&lt;code&gt;leafType&lt;/code&gt; type. &lt;code&gt;traversalValue&lt;/code&gt; is a pointer to any traverse data passed down from the previous call of &lt;code&gt;inner_consistent&lt;/code&gt; on the parent index tuple, or NULL at the root level. &lt;code&gt;traversalMemoryContext&lt;/code&gt; is the memory context in which to store output traverse values (see below). &lt;code&gt;level&lt;/code&gt; is the current inner tuple's level, starting at zero for the root level. &lt;code&gt;returnData&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; if reconstructed data is required for this query; this will only be so if the &lt;code&gt;config&lt;/code&gt; function asserted &lt;code&gt;canReturnData&lt;/code&gt;. &lt;code&gt;allTheSame&lt;/code&gt; is true if the current inner tuple is marked &amp;ldquo;all-the-same&amp;rdquo;; in this case all the nodes have the same label (if any) and so either all or none of them match the query (see &lt;a href=&quot;spgist-implementation#SPGIST-ALL-THE-SAME&quot;&gt;Section 65.4.3&lt;/a&gt;). &lt;code&gt;hasPrefix&lt;/code&gt; is true if the current inner tuple contains a prefix; if so, &lt;code&gt;prefixDatum&lt;/code&gt; is its value. &lt;code&gt;nNodes&lt;/code&gt; is the number of child nodes contained in the inner tuple, and &lt;code&gt;nodeLabels&lt;/code&gt; is an array of their label values, or NULL if the nodes do not have labels.</source>
          <target state="translated">长度为 &lt;code&gt;nkeys&lt;/code&gt; 的数组 &lt;code&gt;scankeys&lt;/code&gt; 描述了索引搜索条件。这些条件与AND结合使用-只有满足所有条件的索引条目才有意义。 （请注意， &lt;code&gt;nkeys&lt;/code&gt; = 0表示所有索引条目都满足查询。）通常，一致性函数只关心每个数组条目的 &lt;code&gt;sk_strategy&lt;/code&gt; 和 &lt;code&gt;sk_argument&lt;/code&gt; 字段，它们分别提供可索引的运算符和比较值。特别是，不必检查 &lt;code&gt;sk_flags&lt;/code&gt; 来查看比较值是否为NULL，因为SP-GiST核心代码将过滤掉这种情况。阵列 &lt;code&gt;orderbys&lt;/code&gt; 长度， &lt;code&gt;norderbys&lt;/code&gt; ，以相同方式描述订购运算符（如果有）。 &lt;code&gt;reconstructedValue&lt;/code&gt; 是为父元组重构的值；在根级别为 &lt;code&gt;(Datum) 0&lt;/code&gt; ，或者 &lt;code&gt;inner_consistent&lt;/code&gt; 函数在父级别未提供值。 &lt;code&gt;reconstructedValue&lt;/code&gt; 是始终 &lt;code&gt;spgConfigOut&lt;/code&gt; 。 &lt;code&gt;leafType&lt;/code&gt; 类型。 &lt;code&gt;traversalValue&lt;/code&gt; 是指向从父索引元组上的 &lt;code&gt;inner_consistent&lt;/code&gt; 的先前调用向下传递的任何遍历数据的指针，在根级别为NULL。 &lt;code&gt;traversalMemoryContext&lt;/code&gt; 是用于存储输出遍历值的内存上下文（请参见下文）。 &lt;code&gt;level&lt;/code&gt; 是当前内部元组的级别，从根级别的零开始。如果此查询需要重建数据，则 &lt;code&gt;returnData&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ;否则为false。仅当 &lt;code&gt;config&lt;/code&gt; 函数断言 &lt;code&gt;canReturnData&lt;/code&gt; 时,才会如此。如果当前内部元组标记为&amp;ldquo;全部相同&amp;rdquo;，则 &lt;code&gt;allTheSame&lt;/code&gt; 为true；在这种情况下，所有节点都具有相同的标签（如果有的话），因此它们全部或都不匹配查询（请参阅&lt;a href=&quot;spgist-implementation#SPGIST-ALL-THE-SAME&quot;&gt;第65.4.3节&lt;/a&gt;）。如果当前内部元组包含前缀，则 &lt;code&gt;hasPrefix&lt;/code&gt; 为true；否则为false。如果是这样，则 &lt;code&gt;prefixDatum&lt;/code&gt; 是其值。 &lt;code&gt;nNodes&lt;/code&gt; 是内部元组和 &lt;code&gt;nodeLabels&lt;/code&gt; 中包含的子节点数是其标签值的数组，如果节点没有标签，则为NULL。</target>
        </trans-unit>
        <trans-unit id="b4cb45da91499c64a7e30418524dae4c6bc491fc" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;scankeys&lt;/code&gt;, of length &lt;code&gt;nkeys&lt;/code&gt;, describes the index search condition(s). These conditions are combined with AND &amp;mdash; only index entries that satisfy all of them satisfy the query. (Note that &lt;code&gt;nkeys&lt;/code&gt; = 0 implies that all index entries satisfy the query.) Usually the consistent function only cares about the &lt;code&gt;sk_strategy&lt;/code&gt; and &lt;code&gt;sk_argument&lt;/code&gt; fields of each array entry, which respectively give the indexable operator and comparison value. In particular it is not necessary to check &lt;code&gt;sk_flags&lt;/code&gt; to see if the comparison value is NULL, because the SP-GiST core code will filter out such conditions. The array &lt;code&gt;orderbys&lt;/code&gt;, of length &lt;code&gt;norderbys&lt;/code&gt;, describes the ordering operators in the same manner. &lt;code&gt;reconstructedValue&lt;/code&gt; is the value reconstructed for the parent tuple; it is &lt;code&gt;(Datum) 0&lt;/code&gt; at the root level or if the &lt;code&gt;inner_consistent&lt;/code&gt; function did not provide a value at the parent level. &lt;code&gt;reconstructedValue&lt;/code&gt; is always of &lt;code&gt;spgConfigOut&lt;/code&gt;.&lt;code&gt;leafType&lt;/code&gt; type. &lt;code&gt;traversalValue&lt;/code&gt; is a pointer to any traverse data passed down from the previous call of &lt;code&gt;inner_consistent&lt;/code&gt; on the parent index tuple, or NULL at the root level. &lt;code&gt;level&lt;/code&gt; is the current leaf tuple's level, starting at zero for the root level. &lt;code&gt;returnData&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; if reconstructed data is required for this query; this will only be so if the &lt;code&gt;config&lt;/code&gt; function asserted &lt;code&gt;canReturnData&lt;/code&gt;. &lt;code&gt;leafDatum&lt;/code&gt; is the key value of &lt;code&gt;spgConfigOut&lt;/code&gt;.&lt;code&gt;leafType&lt;/code&gt; stored in the current leaf tuple.</source>
          <target state="translated">长度为 &lt;code&gt;nkeys&lt;/code&gt; 的数组 &lt;code&gt;scankeys&lt;/code&gt; 描述了索引搜索条件。这些条件与AND结合使用-只有满足所有条件的索引条目才能满足查询。 （请注意， &lt;code&gt;nkeys&lt;/code&gt; = 0表示所有索引条目都满足查询。）通常，一致性函数只关心每个数组条目的 &lt;code&gt;sk_strategy&lt;/code&gt; 和 &lt;code&gt;sk_argument&lt;/code&gt; 字段，它们分别提供可索引的运算符和比较值。特别是，不必检查 &lt;code&gt;sk_flags&lt;/code&gt; 来查看比较值是否为NULL，因为SP-GiST核心代码将过滤掉这种情况。阵列 &lt;code&gt;orderbys&lt;/code&gt; 长度， &lt;code&gt;norderbys&lt;/code&gt; ，以相同的方式描述排序运算符。 &lt;code&gt;reconstructedValue&lt;/code&gt; 是为父元组重构的值；在根级别为 &lt;code&gt;(Datum) 0&lt;/code&gt; ，或者 &lt;code&gt;inner_consistent&lt;/code&gt; 函数在父级别未提供值。 &lt;code&gt;reconstructedValue&lt;/code&gt; 是始终 &lt;code&gt;spgConfigOut&lt;/code&gt; 。 &lt;code&gt;leafType&lt;/code&gt; 类型。 &lt;code&gt;traversalValue&lt;/code&gt; 是指向从父索引元组上的 &lt;code&gt;inner_consistent&lt;/code&gt; 的先前调用向下传递的任何遍历数据的指针，在根级别为NULL。 &lt;code&gt;level&lt;/code&gt; 是当前叶元组的级别，从根级别的零开始。 &lt;code&gt;returnData&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 如果此查询需要重建的数据；只有在 &lt;code&gt;config&lt;/code&gt; 函数断言 &lt;code&gt;canReturnData&lt;/code&gt; 的情况下才会如此。 &lt;code&gt;leafDatum&lt;/code&gt; 是关键值 &lt;code&gt;spgConfigOut&lt;/code&gt; 。 &lt;code&gt;leafType&lt;/code&gt; 存储在当前叶子元组中。</target>
        </trans-unit>
        <trans-unit id="e26f508cb31ef1599228fd2a799f7ebeb7c2026b" translate="yes" xml:space="preserve">
          <source>The array containment operators (&lt;code&gt;&amp;lt;@&lt;/code&gt; and &lt;code&gt;@&amp;gt;&lt;/code&gt;) consider one array to be contained in another one if each of its elements appears in the other one. Duplicates are not treated specially, thus &lt;code&gt;ARRAY[1]&lt;/code&gt; and &lt;code&gt;ARRAY[1,1]&lt;/code&gt; are each considered to contain the other.</source>
          <target state="translated">如果数组包含运算符（ &lt;code&gt;&amp;lt;@&lt;/code&gt; 和 &lt;code&gt;@&amp;gt;&lt;/code&gt; ）的每个元素都出现在另一个数组中，则该数组包含一个数组。没有对重复项进行特殊处理，因此 &lt;code&gt;ARRAY[1]&lt;/code&gt; 和 &lt;code&gt;ARRAY[1,1]&lt;/code&gt; 都被认为包含另一个。</target>
        </trans-unit>
        <trans-unit id="a1ac56c0bce21554d688d27823930a835d434c12" translate="yes" xml:space="preserve">
          <source>The array ordering operators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, etc) compare the array contents element-by-element, using the default B-tree comparison function for the element data type, and sort based on the first difference. In multidimensional arrays the elements are visited in row-major order (last subscript varies most rapidly). If the contents of two arrays are equal but the dimensionality is different, the first difference in the dimensionality information determines the sort order. (This is a change from versions of PostgreSQL prior to 8.2: older versions would claim that two arrays with the same contents were equal, even if the number of dimensions or subscript ranges were different.)</source>
          <target state="translated">数组排序运算符（ &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;=&lt;/code&gt; 等）使用元素数据类型的默认B树比较功能逐个元素比较数组内容，并根据第一个差异进行排序。在多维数组中，元素以行优先顺序访问（最后一个下标变化最快）。如果两个数组的内容相等，但维数不同，则维数信息中的第一个差异将确定排序顺序。 （这是对8.2之前的PostgreSQL版本的更改：较旧的版本会声明两个具有相同内容的数组是相等的，即使维数或下标范围的数量不同）。</target>
        </trans-unit>
        <trans-unit id="46741e31bee949b907d3858dce5eac23fd4bcbdf" translate="yes" xml:space="preserve">
          <source>The array output routine will include explicit dimensions in its result only when there are one or more lower bounds different from one.</source>
          <target state="translated">只有当有一个或多个下界不同时,数组输出例程才会在其结果中包含显式维数。</target>
        </trans-unit>
        <trans-unit id="145d4d2c0c7cafb8b7bd9116657b494c47b146d7" translate="yes" xml:space="preserve">
          <source>The array output routine will put double quotes around element values if they are empty strings, contain curly braces, delimiter characters, double quotes, backslashes, or white space, or match the word &lt;code&gt;NULL&lt;/code&gt;. Double quotes and backslashes embedded in element values will be backslash-escaped. For numeric data types it is safe to assume that double quotes will never appear, but for textual data types one should be prepared to cope with either the presence or absence of quotes.</source>
          <target state="translated">如果数组值是空字符串，包含大括号，定界符，双引号，反斜杠或空格，或者与单词 &lt;code&gt;NULL&lt;/code&gt; 匹配，则数组输出例程将在元素值两边加上双引号。元素值中嵌入的双引号和反斜杠将被反斜杠转义。对于数字数据类型，可以安全地假定双引号将永远不会出现，但是对于文本数据类型，应准备使用双引号来应对是否存在引号。</target>
        </trans-unit>
        <trans-unit id="103411c7faff9f23f3f96fc9d71ef919bccd0156" translate="yes" xml:space="preserve">
          <source>The array subscript numbers are written within square brackets. By default PostgreSQL uses a one-based numbering convention for arrays, that is, an array of &lt;code&gt;n&lt;/code&gt; elements starts with &lt;code&gt;array[1]&lt;/code&gt; and ends with &lt;code&gt;array[n]&lt;/code&gt;.</source>
          <target state="translated">数组下标数字写在方括号内。默认情况下，PostgreSQL对数组使用基于一个编号的约定，即， &lt;code&gt;n&lt;/code&gt; 个元素的数组以 &lt;code&gt;array[1]&lt;/code&gt; 开头，以 &lt;code&gt;array[n]&lt;/code&gt; 结尾。</target>
        </trans-unit>
        <trans-unit id="d22d8bf767f7e2f65ff41f5dea0e4f13bccb5b56" translate="yes" xml:space="preserve">
          <source>The associated sort operator for a &lt;code&gt;MIN&lt;/code&gt;- or &lt;code&gt;MAX&lt;/code&gt;-like aggregate. This is just an operator name (possibly schema-qualified). The operator is assumed to have the same input data types as the aggregate (which must be a single-argument normal aggregate).</source>
          <target state="translated">The associated sort operator for a &lt;code&gt;MIN&lt;/code&gt; - or &lt;code&gt;MAX&lt;/code&gt; -like aggregate. This is just an operator name (possibly schema-qualified). The operator is assumed to have the same input data types as the aggregate (which must be a single-argument normal aggregate).</target>
        </trans-unit>
        <trans-unit id="9f45180efdf5d69d899f4c71484ab019adca9bab" translate="yes" xml:space="preserve">
          <source>The associated value is always a list of objects, each describing a range of WAL records that must be readable from a particular timeline in order to make use of the backup. The structure of these objects is further described in &lt;a href=&quot;backup-manifest-wal-ranges&quot;&gt;Section 71.3&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="658fbccdd7164ea13c1ae7470c9f741a09ac38d8" translate="yes" xml:space="preserve">
          <source>The associated value is always a list of objects, each describing one file that is present in the backup. No entries are present in this list for the WAL files that are needed in order to use the backup, or for the backup manifest itself. The structure of each object in the list is described in &lt;a href=&quot;backup-manifest-files&quot;&gt;Section 71.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8c6c90066586df369729932567a3ffed5f17a48" translate="yes" xml:space="preserve">
          <source>The associated value is always the integer 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="354efec1fb802640a13d0696d88d4e7e365ca415" translate="yes" xml:space="preserve">
          <source>The assurance that once a &lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;transaction&lt;/a&gt; has been &lt;a href=&quot;glossary#GLOSSARY-COMMIT&quot;&gt;committed&lt;/a&gt;, the changes remain even after a system failure or crash. This is one of the ACID properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daf89077b4ae20ed63b034eee053148490bd888b" translate="yes" xml:space="preserve">
          <source>The asterisk (&lt;code&gt;*&lt;/code&gt;) is used in some contexts to denote all the fields of a table row or composite value. It also has a special meaning when used as the argument of an aggregate function, namely that the aggregate does not require any explicit parameter.</source>
          <target state="translated">The asterisk ( &lt;code&gt;*&lt;/code&gt; ) is used in some contexts to denote all the fields of a table row or composite value. It also has a special meaning when used as the argument of an aggregate function, namely that the aggregate does not require any explicit parameter.</target>
        </trans-unit>
        <trans-unit id="a8f1751d17a34d74d41affe83afc62bf9926cd57" translate="yes" xml:space="preserve">
          <source>The autocommit-on mode is PostgreSQL's traditional behavior, but autocommit-off is closer to the SQL spec. If you prefer autocommit-off, you might wish to set it in the system-wide &lt;code&gt;psqlrc&lt;/code&gt; file or your &lt;code&gt;~/.psqlrc&lt;/code&gt; file.</source>
          <target state="translated">自动提交模式是PostgreSQL的传统行为，但是自动提交模式更接近SQL规范。如果您喜欢自动提交，则可能希望在系统范围的 &lt;code&gt;psqlrc&lt;/code&gt; 文件或 &lt;code&gt;~/.psqlrc&lt;/code&gt; 文件中进行设置。</target>
        </trans-unit>
        <trans-unit id="a786e81687748275f55ad70f3f5bbc00d402d949" translate="yes" xml:space="preserve">
          <source>The autovacuum daemon does not issue &lt;code&gt;ANALYZE&lt;/code&gt; commands for foreign tables, since it has no means of determining how often that might be useful. If your queries require statistics on foreign tables for proper planning, it's a good idea to run manually-managed &lt;code&gt;ANALYZE&lt;/code&gt; commands on those tables on a suitable schedule.</source>
          <target state="translated">autovacuum守护程序不会为外部表发出 &lt;code&gt;ANALYZE&lt;/code&gt; 命令，因为它无法确定有用的频率。如果您的查询需要有关外部表的统计信息以进行适当计划，则最好在适当的时间表上对那些表运行手动管理的 &lt;code&gt;ANALYZE&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="c3fb21098ee7138941d3ecbb7f53e34e6b514d65" translate="yes" xml:space="preserve">
          <source>The autovacuum daemon, if enabled, will automatically issue &lt;code&gt;ANALYZE&lt;/code&gt; commands whenever the content of a table has changed sufficiently. However, administrators might prefer to rely on manually-scheduled &lt;code&gt;ANALYZE&lt;/code&gt; operations, particularly if it is known that update activity on a table will not affect the statistics of &amp;ldquo;interesting&amp;rdquo; columns. The daemon schedules &lt;code&gt;ANALYZE&lt;/code&gt; strictly as a function of the number of rows inserted or updated; it has no knowledge of whether that will lead to meaningful statistical changes.</source>
          <target state="translated">如果启用了autovacuum守护程序，则只要表的内容已发生足够的更改，它将自动发出 &lt;code&gt;ANALYZE&lt;/code&gt; 命令。但是，管理员可能更喜欢依靠手动安排的 &lt;code&gt;ANALYZE&lt;/code&gt; 操作，尤其是在已知表上的更新活动不会影响&amp;ldquo;有趣&amp;rdquo;列的统计信息的情况下。守护程序严格根据插入或更新的行数来调度 &lt;code&gt;ANALYZE&lt;/code&gt; ；它不知道是否会导致有意义的统计变化。</target>
        </trans-unit>
        <trans-unit id="252860c5ed0258d1ec21ceb8459b34f92032e663" translate="yes" xml:space="preserve">
          <source>The availability of the different password-based authentication methods depends on how a user's password on the server is encrypted (or hashed, more accurately). This is controlled by the configuration parameter &lt;a href=&quot;runtime-config-connection#GUC-PASSWORD-ENCRYPTION&quot;&gt;password_encryption&lt;/a&gt; at the time the password is set. If a password was encrypted using the &lt;code&gt;scram-sha-256&lt;/code&gt; setting, then it can be used for the authentication methods &lt;code&gt;scram-sha-256&lt;/code&gt; and &lt;code&gt;password&lt;/code&gt; (but password transmission will be in plain text in the latter case). The authentication method specification &lt;code&gt;md5&lt;/code&gt; will automatically switch to using the &lt;code&gt;scram-sha-256&lt;/code&gt; method in this case, as explained above, so it will also work. If a password was encrypted using the &lt;code&gt;md5&lt;/code&gt; setting, then it can be used only for the &lt;code&gt;md5&lt;/code&gt; and &lt;code&gt;password&lt;/code&gt; authentication method specifications (again, with the password transmitted in plain text in the latter case). (Previous PostgreSQL releases supported storing the password on the server in plain text. This is no longer possible.) To check the currently stored password hashes, see the system catalog &lt;code&gt;pg_authid&lt;/code&gt;.</source>
          <target state="translated">不同的基于密码的身份验证方法的可用性取决于服务器上用户密码的加密方式（或更准确地说，是散列的）。这由设置&lt;a href=&quot;runtime-config-connection#GUC-PASSWORD-ENCRYPTION&quot;&gt;密码&lt;/a&gt;时的配置参数password_encryption控制。如果使用 &lt;code&gt;scram-sha-256&lt;/code&gt; 设置对密码进行了加密，则可以将其用于身份验证方法 &lt;code&gt;scram-sha-256&lt;/code&gt; 和 &lt;code&gt;password&lt;/code&gt; （但在后一种情况下，密码将以纯文本格式传输）。如上所述，在这种情况下，身份验证方法规范 &lt;code&gt;md5&lt;/code&gt; 将自动切换为使用 &lt;code&gt;scram-sha-256&lt;/code&gt; 方法，因此它也将起作用。如果密码是使用 &lt;code&gt;md5&lt;/code&gt; 加密的设置，则只能用于 &lt;code&gt;md5&lt;/code&gt; 和 &lt;code&gt;password&lt;/code&gt; 验证方法规范（同样，在后一种情况下，密码以纯文本格式传输）。（以前的PostgreSQL版本支持将密码以纯文本格式存储在服务器上。这不再可能。）要检查当前存储的密码哈希，请参见系统目录 &lt;code&gt;pg_authid&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="be4db45cb9d664398bfb8a833d78745c5f0e03cb" translate="yes" xml:space="preserve">
          <source>The available commands are:</source>
          <target state="translated">可用的命令有:</target>
        </trans-unit>
        <trans-unit id="a8b4cfaf9660d8b419b38ef501d2e57aeb699d73" translate="yes" xml:space="preserve">
          <source>The available functions are shown in &lt;a href=&quot;ltree#LTREE-FUNC-TABLE&quot;&gt;Table F.14&lt;/a&gt;.</source>
          <target state="translated">可用功能如&lt;a href=&quot;ltree#LTREE-FUNC-TABLE&quot;&gt;表F.14&lt;/a&gt;所示。</target>
        </trans-unit>
        <trans-unit id="4cf27edb4ec77236cfb1d7851c53ced1470b1ae0" translate="yes" xml:space="preserve">
          <source>The available privileges are:</source>
          <target state="translated">现有的特权是:</target>
        </trans-unit>
        <trans-unit id="b24cdea942d5e58d37185d11c8d0001459291bc6" translate="yes" xml:space="preserve">
          <source>The available sequence functions are:</source>
          <target state="translated">可用的序列功能有:</target>
        </trans-unit>
        <trans-unit id="1f54359e34884f0f14a7082c4b037dceb1040a71" translate="yes" xml:space="preserve">
          <source>The available transaction characteristics are the transaction isolation level, the transaction access mode (read/write or read-only), and the deferrable mode. In addition, a snapshot can be selected, though only for the current transaction, not as a session default.</source>
          <target state="translated">可用的事务特性是事务隔离级别、事务访问模式(读/写或只读)和可延迟模式。此外,还可以选择快照,不过只适用于当前事务,而不是作为会话默认值。</target>
        </trans-unit>
        <trans-unit id="690838e9cb021af0a2b1acec6c3a93a7e08f1bb6" translate="yes" xml:space="preserve">
          <source>The average stored width, in bytes, of nonnull entries</source>
          <target state="translated">非空条目的平均存储宽度,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="4f544e0e02bfed2fa010d1f669949bc62b79024b" translate="yes" xml:space="preserve">
          <source>The backend type corresponds to the column &lt;code&gt;backend_type&lt;/code&gt; in the view &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-ACTIVITY-VIEW&quot;&gt;&lt;code&gt;pg_stat_activity&lt;/code&gt;&lt;/a&gt;, but additional types can appear in the log that don't show in that view.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fde6e34822920c61d23e994603a609b1307667e3" translate="yes" xml:space="preserve">
          <source>The background writer is active during recovery and will perform restartpoints (similar to checkpoints on the primary) and normal block cleaning activities. This can include updates of the hint bit information stored on the standby server. The &lt;code&gt;CHECKPOINT&lt;/code&gt; command is accepted during recovery, though it performs a restartpoint rather than a new checkpoint.</source>
          <target state="translated">后台写入器在恢复期间处于活动状态，并将执行重新启动点（类似于主服务器上的检查点）和正常的块清除活动。这可以包括存储在备用服务器上的提示位信息的更新。该 &lt;code&gt;CHECKPOINT&lt;/code&gt; 命令恢复期间接受，尽管它执行restartpoint，而不是一个新的检查点。</target>
        </trans-unit>
        <trans-unit id="6a4770c7c3de3b5a6b683a55e8771f9ee1778b13" translate="yes" xml:space="preserve">
          <source>The backup history file is just a small text file. It contains the label string you gave to &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt;, as well as the starting and ending times and WAL segments of the backup. If you used the label to identify the associated dump file, then the archived history file is enough to tell you which dump file to restore.</source>
          <target state="translated">备份历史记录文件只是一个小文本文件。它包含您提供给&lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt;的标签字符串，以及备份的开始和结束时间以及WAL段。如果使用标签来标识关联的转储文件，则存档的历史文件足以告诉您要还原哪个转储文件。</target>
        </trans-unit>
        <trans-unit id="c801dce038f073674a8ac5aca2db97b365640813" translate="yes" xml:space="preserve">
          <source>The backup history file is not created in the database cluster backed up.</source>
          <target state="translated">在备份的数据库集群中没有创建备份历史文件。</target>
        </trans-unit>
        <trans-unit id="0c8b05e2a70131e9b678814d20139ef5d923c4dc" translate="yes" xml:space="preserve">
          <source>The backup is made over a regular PostgreSQL connection that uses the replication protocol. The connection must be made with a user ID that has &lt;code&gt;REPLICATION&lt;/code&gt; permissions (see &lt;a href=&quot;role-attributes&quot;&gt;Section 21.2&lt;/a&gt;) or is a superuser, and &lt;a href=&quot;auth-pg-hba-conf&quot;&gt;&lt;code&gt;pg_hba.conf&lt;/code&gt;&lt;/a&gt; must permit the replication connection. The server must also be configured with &lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt; set high enough to provide at least one walsender for the backup plus one for WAL streaming (if used).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be7e03b230f28bb65cecb0388bcfd3f69ad98241" translate="yes" xml:space="preserve">
          <source>The backup is made over a regular PostgreSQL connection, and uses the replication protocol. The connection must be made with a superuser or a user having &lt;code&gt;REPLICATION&lt;/code&gt; permissions (see &lt;a href=&quot;role-attributes&quot;&gt;Section 21.2&lt;/a&gt;), and &lt;code&gt;pg_hba.conf&lt;/code&gt; must explicitly permit the replication connection. The server must also be configured with &lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt; set high enough to leave at least one session available for the backup and one for WAL streaming (if used).</source>
          <target state="translated">备份是通过常规PostgreSQL连接进行的，并使用复制协议。连接必须由超级用户或具有 &lt;code&gt;REPLICATION&lt;/code&gt; 权限的用户建立（请参阅&lt;a href=&quot;role-attributes&quot;&gt;第21.2节&lt;/a&gt;），并且 &lt;code&gt;pg_hba.conf&lt;/code&gt; 必须明确允许复制连接。还必须为服务器配置&lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders，&lt;/a&gt;将其设置得足够高，以使至少一个会话可用于备份，而至少一个会话可用于WAL流传输（如果使用）。</target>
        </trans-unit>
        <trans-unit id="eee28f79bda7267e3e26bc973ac8a0442a749a1b" translate="yes" xml:space="preserve">
          <source>The backup label file includes the label string you gave to &lt;code&gt;pg_start_backup&lt;/code&gt;, as well as the time at which &lt;code&gt;pg_start_backup&lt;/code&gt; was run, and the name of the starting WAL file. In case of confusion it is therefore possible to look inside a backup file and determine exactly which backup session the dump file came from. The tablespace map file includes the symbolic link names as they exist in the directory &lt;code&gt;pg_tblspc/&lt;/code&gt; and the full path of each symbolic link. These files are not merely for your information; their presence and contents are critical to the proper operation of the system's recovery process.</source>
          <target state="translated">备份标签文件包括您提供给 &lt;code&gt;pg_start_backup&lt;/code&gt; 的标签字符串，运行 &lt;code&gt;pg_start_backup&lt;/code&gt; 的时间以及起始WAL文件的名称。因此，在出现混乱的情况下，可以查看备份文件内部并准确确定转储文件来自哪个备份会话。表空间映射文件包含目录 &lt;code&gt;pg_tblspc/&lt;/code&gt; 存在的符号链接名称，以及每个符号链接的完整路径。这些文件不仅供您参考。它们的存在和内容对于系统恢复过程的正常运行至关重要。</target>
        </trans-unit>
        <trans-unit id="e501c42ea79c8d19e5c5b2265b4863425cf9ba55" translate="yes" xml:space="preserve">
          <source>The backup manifest JSON document contains the following keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec28fc3545975c7f203eb96bb815ab982f3d0305" translate="yes" xml:space="preserve">
          <source>The backup will include all files in the data directory and tablespaces, including the configuration files and any additional files placed in the directory by third parties, except certain temporary files managed by PostgreSQL. But only regular files and directories are copied, except that symbolic links used for tablespaces are preserved. Symbolic links pointing to certain directories known to PostgreSQL are copied as empty directories. Other symbolic links and special device files are skipped. See &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt; for the precise details.</source>
          <target state="translated">备份将包括数据目录和表空间中的所有文件，包括配置文件以及由第三方放置在目录中的任何其他文件，但由PostgreSQL管理的某些临时文件除外。但是只复制常规文件和目录，除了保留用于表空间的符号链接。指向PostgreSQL已知的某些目录的符号链接被复制为空目录。其他符号链接和特殊设备文件将被跳过。有关详细信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;第52.4节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fcd73c92b5c4d4bc4af88fe2398a5bc2bbfd5cfa" translate="yes" xml:space="preserve">
          <source>The backup will include all files in the data directory and tablespaces, including the configuration files and any additional files placed in the directory by third parties, except certain temporary files managed by PostgreSQL. But only regular files and directories are copied, except that symbolic links used for tablespaces are preserved. Symbolic links pointing to certain directories known to PostgreSQL are copied as empty directories. Other symbolic links and special device files are skipped. See &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt; for the precise details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3172c702cad81af002509edf932aeb8ebbddf103" translate="yes" xml:space="preserve">
          <source>The bare-bones way to start the server manually is just to invoke &lt;code&gt;postgres&lt;/code&gt; directly, specifying the location of the data directory with the &lt;code&gt;-D&lt;/code&gt; option, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010379dd868ed62184a64309858104a1ef8bdfc1" translate="yes" xml:space="preserve">
          <source>The base directory on the file system of a &lt;a href=&quot;glossary#GLOSSARY-SERVER&quot;&gt;server&lt;/a&gt; that contains all data files and subdirectories associated with a &lt;a href=&quot;glossary#GLOSSARY-DB-CLUSTER&quot;&gt;database cluster&lt;/a&gt; (with the exception of &lt;a href=&quot;glossary#GLOSSARY-TABLESPACE&quot;&gt;tablespaces&lt;/a&gt;, and optionally &lt;a href=&quot;glossary#GLOSSARY-WAL&quot;&gt;WAL&lt;/a&gt;). The environment variable &lt;code&gt;PGDATA&lt;/code&gt; is commonly used to refer to the data directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5658ad1f6ce193a23633c994bf8ae4b8bb4bf57e" translate="yes" xml:space="preserve">
          <source>The base name of the shared object containing the output plugin this logical slot is using, or null for physical slots.</source>
          <target state="translated">包含该逻辑槽所使用的输出插件的共享对象的基本名称,对于物理槽,则为空。</target>
        </trans-unit>
        <trans-unit id="01f76877be594c383342f8dd0d2d641fff88c4a5" translate="yes" xml:space="preserve">
          <source>The basic idea is to copy all file system-level changes from the source cluster to the target cluster:</source>
          <target state="translated">基本思路是将所有文件系统级的变化从源集群复制到目标集群。</target>
        </trans-unit>
        <trans-unit id="37c34616336e6db6cae77db2468a45723a3fb8d6" translate="yes" xml:space="preserve">
          <source>The basic structure used to store relation data. All pages are of the same size. Data pages are typically stored on disk, each in a specific file, and can be read to &lt;a href=&quot;glossary#GLOSSARY-SHARED-MEMORY&quot;&gt;shared buffers&lt;/a&gt; where they can be modified, becoming &lt;em&gt;dirty&lt;/em&gt;. They become clean when written to disk. New pages, which initially exist in memory only, are also dirty until written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19e50f37cd3ac57ef618ac5cb372c8487c7f1bd1" translate="yes" xml:space="preserve">
          <source>The basic value of &lt;code&gt;SELECT&lt;/code&gt; in &lt;code&gt;WITH&lt;/code&gt; is to break down complicated queries into simpler parts. An example is:</source>
          <target state="translated">的基本价值 &lt;code&gt;SELECT&lt;/code&gt; 在 &lt;code&gt;WITH&lt;/code&gt; 是复杂的查询分解成简单的部分。一个例子是：</target>
        </trans-unit>
        <trans-unit id="a2b5aa5c42d40515ef87930aadc0b43fe175a670" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;%&lt;/code&gt; is a bit complicated. It tries to match words rather than the entire label. For example &lt;code&gt;foo_bar%&lt;/code&gt; matches &lt;code&gt;foo_bar_baz&lt;/code&gt; but not &lt;code&gt;foo_barbaz&lt;/code&gt;. If combined with &lt;code&gt;*&lt;/code&gt;, prefix matching applies to each word separately, for example &lt;code&gt;foo_bar%*&lt;/code&gt; matches &lt;code&gt;foo1_bar2_baz&lt;/code&gt; but not &lt;code&gt;foo1_br2_baz&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;%&lt;/code&gt; 的行为有点复杂。它尝试匹配单词而不是整个标签。例如， &lt;code&gt;foo_bar%&lt;/code&gt; 匹配 &lt;code&gt;foo_bar_baz&lt;/code&gt; ,但不匹配 &lt;code&gt;foo_barbaz&lt;/code&gt; 。如果与 &lt;code&gt;*&lt;/code&gt; 组合，则前缀匹配分别应用于每个单词，例如 &lt;code&gt;foo_bar%*&lt;/code&gt; 匹配 &lt;code&gt;foo1_bar2_baz&lt;/code&gt; 而不匹配 &lt;code&gt;foo1_br2_baz&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e8f85d7de8ab2c8253e41f10bbddbd7196e58ed" translate="yes" xml:space="preserve">
          <source>The behavior of a custom text search configuration can easily become confusing. The functions described in this section are useful for testing text search objects. You can test a complete configuration, or test parsers and dictionaries separately.</source>
          <target state="translated">自定义文本搜索配置的行为很容易变得混乱。本节中描述的功能对测试文本搜索对象很有用。您可以测试一个完整的配置,或者分别测试解析器和字典。</target>
        </trans-unit>
        <trans-unit id="7b27c83984e819ed5cc108965dd1a811c9d23e12" translate="yes" xml:space="preserve">
          <source>The behavior of foreign keys can be finely tuned to your application. We will not go beyond this simple example in this tutorial, but just refer you to &lt;a href=&quot;https://www.postgresql.org/docs/12/ddl.html&quot;&gt;Chapter 5&lt;/a&gt; for more information. Making correct use of foreign keys will definitely improve the quality of your database applications, so you are strongly encouraged to learn about them.</source>
          <target state="translated">外键的行为可以根据您的应用程序进行微调。我们将不会超出本教程中的这个简单示例，而只是请您参考&lt;a href=&quot;https://www.postgresql.org/docs/12/ddl.html&quot;&gt;第5章&lt;/a&gt;以获取更多信息。正确使用外键肯定会提高数据库应用程序的质量，因此强烈建议您学习它们。</target>
        </trans-unit>
        <trans-unit id="3eeed7c57eb15931aa5b185d4f571a20fdfcd681" translate="yes" xml:space="preserve">
          <source>The behavior of foreign keys can be finely tuned to your application. We will not go beyond this simple example in this tutorial, but just refer you to &lt;a href=&quot;https://www.postgresql.org/docs/13/ddl.html&quot;&gt;Chapter 5&lt;/a&gt; for more information. Making correct use of foreign keys will definitely improve the quality of your database applications, so you are strongly encouraged to learn about them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="296b0cebbabc7c8e4b2d8335b6fb9121ab843326" translate="yes" xml:space="preserve">
          <source>The behavior of temporary tables at the end of a transaction block can be controlled using &lt;code&gt;ON COMMIT&lt;/code&gt;. The three options are:</source>
          <target state="translated">可以使用 &lt;code&gt;ON COMMIT&lt;/code&gt; 控制事务块末尾的临时表的行为。这三个选项是：</target>
        </trans-unit>
        <trans-unit id="80731f14bda7a7a22a0a9014398f2bbf94eee233" translate="yes" xml:space="preserve">
          <source>The behavior of the &lt;code&gt;-t&lt;/code&gt; switch is not entirely upward compatible with pre-8.2 PostgreSQL versions. Formerly, writing &lt;code&gt;-t tab&lt;/code&gt; would dump all tables named &lt;code&gt;tab&lt;/code&gt;, but now it just dumps whichever one is visible in your default search path. To get the old behavior you can write &lt;code&gt;-t '*.tab'&lt;/code&gt;. Also, you must write something like &lt;code&gt;-t sch.tab&lt;/code&gt; to select a table in a particular schema, rather than the old locution of &lt;code&gt;-n sch -t tab&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-t&lt;/code&gt; 开关的行为并不完全与8.2之前的PostgreSQL版本向上兼容。以前，编写 &lt;code&gt;-t tab&lt;/code&gt; 会转储所有名为 &lt;code&gt;tab&lt;/code&gt; 的表，但是现在它只转储在默认搜索路径中可见的任何一个表。要获得旧的行为，您可以编写 &lt;code&gt;-t '*.tab'&lt;/code&gt; 。同样，您必须编写 &lt;code&gt;-t sch.tab&lt;/code&gt; 之类的内容来选择特定模式中的表，而不是 &lt;code&gt;-n sch -t tab&lt;/code&gt; 的旧版本。</target>
        </trans-unit>
        <trans-unit id="6bad8faf22e7898fa3d14beb6bbfad8894c7e5cb" translate="yes" xml:space="preserve">
          <source>The behavior specified by the SQL standard is most closely approximated by giving users the &lt;code&gt;NOINHERIT&lt;/code&gt; attribute, while roles are given the &lt;code&gt;INHERIT&lt;/code&gt; attribute.</source>
          <target state="translated">通过为用户提供 &lt;code&gt;NOINHERIT&lt;/code&gt; 属性，而为角色赋予 &lt;code&gt;INHERIT&lt;/code&gt; 属性，可以最接近地逼近SQL标准指定的行为。</target>
        </trans-unit>
        <trans-unit id="999fc3c54ee5c4c5f6f59e07c2e8f063ee92343a" translate="yes" xml:space="preserve">
          <source>The benefits will normally be worthwhile only when a table would otherwise be very large. The exact point at which a table will benefit from partitioning depends on the application, although a rule of thumb is that the size of the table should exceed the physical memory of the database server.</source>
          <target state="translated">通常只有当一个表在其他情况下会非常大的时候,才会有这样的好处。表从分区中受益的确切时间点取决于应用程序,不过经验法则是表的大小应超过数据库服务器的物理内存。</target>
        </trans-unit>
        <trans-unit id="7e72906a1cbbbaa7de5bc80e5365aa82f11074fd" translate="yes" xml:space="preserve">
          <source>The best defense against deadlocks is generally to avoid them by being certain that all applications using a database acquire locks on multiple objects in a consistent order. In the example above, if both transactions had updated the rows in the same order, no deadlock would have occurred. One should also ensure that the first lock acquired on an object in a transaction is the most restrictive mode that will be needed for that object. If it is not feasible to verify this in advance, then deadlocks can be handled on-the-fly by retrying transactions that abort due to deadlocks.</source>
          <target state="translated">一般来说,避免死锁的最好办法是确保所有使用数据库的应用程序都以一致的顺序获取多个对象的锁。在上面的例子中,如果两个事务都以相同的顺序更新行,就不会发生死锁。人们还应该确保在一个事务中,在一个对象上获取的第一个锁是该对象所需要的最限制模式。如果事先验证这一点不可行,那么可以通过重试因死锁而中止的事务来即时处理死锁。</target>
        </trans-unit>
        <trans-unit id="d85f73754546926f4e2d17ccb6f522601d212cb5" translate="yes" xml:space="preserve">
          <source>The best solution for high availability is to ensure you keep as many synchronous standbys as requested. This can be achieved by naming multiple potential synchronous standbys using &lt;code&gt;synchronous_standby_names&lt;/code&gt;.</source>
          <target state="translated">高可用性的最佳解决方案是确保按要求保留尽可能多的同步备用数据库。这可以通过使用命名多个潜在同步备用实现 &lt;code&gt;synchronous_standby_names&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9ecf6d09480763021769b90c87994739dc69c88" translate="yes" xml:space="preserve">
          <source>The bitwise operators work only on integral data types, whereas the others are available for all numeric data types. The bitwise operators are also available for the bit string types &lt;code&gt;bit&lt;/code&gt; and &lt;code&gt;bit varying&lt;/code&gt;, as shown in &lt;a href=&quot;functions-bitstring#FUNCTIONS-BIT-STRING-OP-TABLE&quot;&gt;Table 9.14&lt;/a&gt;.</source>
          <target state="translated">按位运算符仅适用于整数数据类型，而其他运算符可用于所有数字数据类型。如&lt;a href=&quot;functions-bitstring#FUNCTIONS-BIT-STRING-OP-TABLE&quot;&gt;表9.14&lt;/a&gt;所示，按位运算符还可用于位串类型的 &lt;code&gt;bit&lt;/code&gt; 和 &lt;code&gt;bit varying&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1111c2349c7453008fe438b3fef48bff0b694759" translate="yes" xml:space="preserve">
          <source>The boolean aggregates &lt;code&gt;bool_and&lt;/code&gt; and &lt;code&gt;bool_or&lt;/code&gt; correspond to the standard SQL aggregates &lt;code&gt;every&lt;/code&gt; and &lt;code&gt;any&lt;/code&gt; or &lt;code&gt;some&lt;/code&gt;. PostgreSQL supports &lt;code&gt;every&lt;/code&gt;, but not &lt;code&gt;any&lt;/code&gt; or &lt;code&gt;some&lt;/code&gt;, because there is an ambiguity built into the standard syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bb544aef82eb5e331a1c83d14ba3f14981e458a" translate="yes" xml:space="preserve">
          <source>The built-in parser is named &lt;code&gt;pg_catalog.default&lt;/code&gt;. It recognizes 23 token types, shown in &lt;a href=&quot;textsearch-parsers#TEXTSEARCH-DEFAULT-PARSER&quot;&gt;Table 12.1&lt;/a&gt;.</source>
          <target state="translated">内置的解析器名为 &lt;code&gt;pg_catalog.default&lt;/code&gt; 。它可以识别23种令牌类型，如&lt;a href=&quot;textsearch-parsers#TEXTSEARCH-DEFAULT-PARSER&quot;&gt;表12.1&lt;/a&gt;所示。</target>
        </trans-unit>
        <trans-unit id="0849997236dc34c615a4c13089f2ec08456d374b" translate="yes" xml:space="preserve">
          <source>The built-in range types &lt;code&gt;int4range&lt;/code&gt;, &lt;code&gt;int8range&lt;/code&gt;, and &lt;code&gt;daterange&lt;/code&gt; all use a canonical form that includes the lower bound and excludes the upper bound; that is, &lt;code&gt;[)&lt;/code&gt;. User-defined range types can use other conventions, however.</source>
          <target state="translated">内置范围类型 &lt;code&gt;int4range&lt;/code&gt; ， &lt;code&gt;int8range&lt;/code&gt; 和 &lt;code&gt;daterange&lt;/code&gt; 均使用规范形式，包括下限，但不包括上限；即 &lt;code&gt;[)&lt;/code&gt; 。但是，用户定义的范围类型可以使用其他约定。</target>
        </trans-unit>
        <trans-unit id="2a312305dbd3d6563e32a6d1866cf9d94a8d3583" translate="yes" xml:space="preserve">
          <source>The built-in window functions are described in &lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;Table 9.60&lt;/a&gt;. Other window functions can be added by the user. Also, any built-in or user-defined general-purpose or statistical aggregate can be used as a window function. (Ordered-set and hypothetical-set aggregates cannot presently be used as window functions.)</source>
          <target state="translated">&lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;表9.60&lt;/a&gt;中描述了内置的窗口功能。用户可以添加其他窗口功能。另外，任何内置或用户定义的通用或统计聚合都可以用作窗口函数。（有序集和假设集的集合目前不能用作窗口函数。）</target>
        </trans-unit>
        <trans-unit id="1eb1519109d2d92138e97ee3336017e3e8180e57" translate="yes" xml:space="preserve">
          <source>The built-in window functions are listed in &lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;Table 9.60&lt;/a&gt;. Note that these functions &lt;em&gt;must&lt;/em&gt; be invoked using window function syntax, i.e., an &lt;code&gt;OVER&lt;/code&gt; clause is required.</source>
          <target state="translated">内置的窗口功能在&lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;表9.60&lt;/a&gt;中列出。注意，&lt;em&gt;必须&lt;/em&gt;使用窗口函数语法来调用这些函数，即，需要 &lt;code&gt;OVER&lt;/code&gt; 子句。</target>
        </trans-unit>
        <trans-unit id="0a15741ae39e976d65eb76bd158e7ef106ba0c6d" translate="yes" xml:space="preserve">
          <source>The call handler function, the inline handler function (if any), and the validator function (if any) must already exist if the server does not have an entry for the language in &lt;code&gt;pg_pltemplate&lt;/code&gt;. But when there is an entry, the functions need not already exist; they will be automatically defined if not present in the database. (This might result in &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; failing, if the shared library that implements the language is not available in the installation.)</source>
          <target state="translated">如果服务器在 &lt;code&gt;pg_pltemplate&lt;/code&gt; 中没有该语言的条目，则调用处理程序函数，内联处理程序函数（如果有）和验证器函数（如果有）必须已经存在。但是，当有一个条目时，这些功能不必已经存在；如果数据库中不存在它们，它们将被自动定义。（如果安装中没有实现该语言的共享库，则可能导致 &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; 失败。）</target>
        </trans-unit>
        <trans-unit id="8a84995528c0ec41b02f477f2f19723fd9aad88c" translate="yes" xml:space="preserve">
          <source>The calling &lt;code&gt;SELECT&lt;/code&gt; statement doesn't necessarily have to be just &lt;code&gt;SELECT *&lt;/code&gt; &amp;mdash; it can reference the output columns by name or join them to other tables. The function produces a virtual table with which you can perform any operation you wish (e.g. aggregation, joining, sorting etc). So we could also have:</source>
          <target state="translated">调用 &lt;code&gt;SELECT&lt;/code&gt; 语句不必一定是 &lt;code&gt;SELECT *&lt;/code&gt; &amp;mdash;它可以按名称引用输出列或将它们连接到其他表。该函数会生成一个虚拟表，您可以使用该表执行任何所需的操作（例如，聚合，联接，排序等）。所以我们也可以有：</target>
        </trans-unit>
        <trans-unit id="811562b4913f9796ae3f8f1999c658370788685e" translate="yes" xml:space="preserve">
          <source>The calling &lt;code&gt;SELECT&lt;/code&gt; statement doesn't necessarily have to be just &lt;code&gt;SELECT *&lt;/code&gt; &amp;mdash; it can reference the output columns by name or join them to other tables. The function produces a virtual table with which you can perform any operation you wish (e.g., aggregation, joining, sorting etc). So we could also have:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35f5d39131b77dc8ba4b8e8bbcf6ab1ac892db18" translate="yes" xml:space="preserve">
          <source>The capabilities available for administrators to monitor and control the server often change and improve in each major release.</source>
          <target state="translated">管理员可用于监视和控制服务器的功能经常在每个主要版本中发生变化和改进。</target>
        </trans-unit>
        <trans-unit id="dcba21726e373c0ef3c1310c54912c4461e260b5" translate="yes" xml:space="preserve">
          <source>The cascading replication feature allows a standby server to accept replication connections and stream WAL records to other standbys, acting as a relay. This can be used to reduce the number of direct connections to the master and also to minimize inter-site bandwidth overheads.</source>
          <target state="translated">级联复制功能允许备用服务器接受复制连接,并将WAL记录流转到其他备用服务器,充当中继。这可以用来减少直接连接到主站的数量,也可以将站点间的带宽开销降到最低。</target>
        </trans-unit>
        <trans-unit id="2414745d3bf9d469e38eb6deaa116aeca4c295eb" translate="yes" xml:space="preserve">
          <source>The cast functions listed in &lt;code&gt;pg_cast&lt;/code&gt; must always take the cast source type as their first argument type, and return the cast destination type as their result type. A cast function can have up to three arguments. The second argument, if present, must be type &lt;code&gt;integer&lt;/code&gt;; it receives the type modifier associated with the destination type, or -1 if there is none. The third argument, if present, must be type &lt;code&gt;boolean&lt;/code&gt;; it receives &lt;code&gt;true&lt;/code&gt; if the cast is an explicit cast, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;pg_cast&lt;/code&gt; 中列出的强制转换函数必须始终将强制转换源类型作为其第一个参数类型，并返回强制转换目标类型作为其结果类型。强制转换函数最多可以包含三个参数。第二个参数（如果存在）必须为 &lt;code&gt;integer&lt;/code&gt; 类型；它接收与目标类型关联的类型修饰符；如果没有，则返回-1。第三个参数（如果存在）必须为 &lt;code&gt;boolean&lt;/code&gt; 类型；它接收 &lt;code&gt;true&lt;/code&gt; 如果转换是一种明确的转换， &lt;code&gt;false&lt;/code&gt; 否则。</target>
        </trans-unit>
        <trans-unit id="fc5f1d64f67b0574d5ae7974d9bf0296a9ac950c" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_aggregate&lt;/code&gt; stores information about aggregate functions. An aggregate function is a function that operates on a set of values (typically one column from each row that matches a query condition) and returns a single value computed from all these values. Typical aggregate functions are &lt;code&gt;sum&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt;, and &lt;code&gt;max&lt;/code&gt;. Each entry in &lt;code&gt;pg_aggregate&lt;/code&gt; is an extension of an entry in &lt;code&gt;pg_proc&lt;/code&gt;. The &lt;code&gt;pg_proc&lt;/code&gt; entry carries the aggregate's name, input and output data types, and other information that is similar to ordinary functions.</source>
          <target state="translated">目录 &lt;code&gt;pg_aggregate&lt;/code&gt; 存储有关聚合函数的信息。聚合函数是对一组值（通常是与查询条件匹配的每一行中的一列）进行运算并返回从所有这些值计算得出的单个值的函数。典型的集合函数是 &lt;code&gt;sum&lt;/code&gt; ， &lt;code&gt;count&lt;/code&gt; 和 &lt;code&gt;max&lt;/code&gt; 。 &lt;code&gt;pg_aggregate&lt;/code&gt; 中的每个条目都是 &lt;code&gt;pg_proc&lt;/code&gt; 中条目的扩展。在 &lt;code&gt;pg_proc&lt;/code&gt; 里的条目进行聚集的名字，输入和输出数据类型，以及其他信息，类似于普通的功能。</target>
        </trans-unit>
        <trans-unit id="a29845311714d7d30ac211e7ed8230388dda9146" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_am&lt;/code&gt; stores information about relation access methods. There is one row for each access method supported by the system. Currently, only tables and indexes have access methods. The requirements for table and index access methods are discussed in detail in &lt;a href=&quot;tableam&quot;&gt;Chapter 60&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/indexam.html&quot;&gt;Chapter 61&lt;/a&gt; respectively.</source>
          <target state="translated">目录 &lt;code&gt;pg_am&lt;/code&gt; 存储有关关系访问方法的信息。系统支持的每种访问方法都有一行。当前，只有表和索引具有访问方法。表和索引访问方法的要求进行了详细讨论&lt;a href=&quot;tableam&quot;&gt;第60章&lt;/a&gt;以及&lt;a href=&quot;https://www.postgresql.org/docs/12/indexam.html&quot;&gt;第61章&lt;/a&gt;分别。</target>
        </trans-unit>
        <trans-unit id="a660b5abad7b774d10c5ce0b5d5dff4f4fa539e0" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_am&lt;/code&gt; stores information about relation access methods. There is one row for each access method supported by the system. Currently, only tables and indexes have access methods. The requirements for table and index access methods are discussed in detail in &lt;a href=&quot;tableam&quot;&gt;Chapter 60&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/13/indexam.html&quot;&gt;Chapter 61&lt;/a&gt; respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bec1e44f2188ec347a755f0e3375dfd03dbafab" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_amop&lt;/code&gt; stores information about operators associated with access method operator families. There is one row for each operator that is a member of an operator family. A family member can be either a &lt;em&gt;search&lt;/em&gt; operator or an &lt;em&gt;ordering&lt;/em&gt; operator. An operator can appear in more than one family, but cannot appear in more than one search position nor more than one ordering position within a family. (It is allowed, though unlikely, for an operator to be used for both search and ordering purposes.)</source>
          <target state="translated">目录 &lt;code&gt;pg_amop&lt;/code&gt; 存储有关与访问方法运算符族相关联的运算符的信息。作为操作员系列成员的每个操作员都有一行。家庭成员可以是&lt;em&gt;搜索&lt;/em&gt;运算符或&lt;em&gt;订购&lt;/em&gt;运算符。一个操作员可以出现在多个家庭中，但不能出现在一个家庭中的一个以上搜索位置或一个订购位置。（虽然不太可能，但允许操作员同时用于搜索和订购。）</target>
        </trans-unit>
        <trans-unit id="7b26f7790ff6d1feb6dfed34e5224303ebaba082" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_amproc&lt;/code&gt; stores information about support functions associated with access method operator families. There is one row for each support function belonging to an operator family.</source>
          <target state="translated">目录 &lt;code&gt;pg_amproc&lt;/code&gt; 存储有关与访问方法操作符族相关的支持功能的信息。属于操作员系列的每个支持功能都有一行。</target>
        </trans-unit>
        <trans-unit id="e1c43da8c1bc3b1aedcc6d0b4907170e6e551dad" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_attrdef&lt;/code&gt; stores column default values. The main information about columns is stored in &lt;a href=&quot;catalog-pg-attribute&quot;&gt;&lt;code&gt;pg_attribute&lt;/code&gt;&lt;/a&gt;. Only columns for which a default value has been explicitly set will have an entry here.</source>
          <target state="translated">目录 &lt;code&gt;pg_attrdef&lt;/code&gt; 存储列的默认值。有关列的主要信息存储在&lt;a href=&quot;catalog-pg-attribute&quot;&gt; &lt;code&gt;pg_attribute&lt;/code&gt; 中&lt;/a&gt;。只有已明确设置默认值的列才会在此处具有条目。</target>
        </trans-unit>
        <trans-unit id="418f63e0244ab894621f6561175c2bc70b572229" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_attribute&lt;/code&gt; stores information about table columns. There will be exactly one &lt;code&gt;pg_attribute&lt;/code&gt; row for every column in every table in the database. (There will also be attribute entries for indexes, and indeed all objects that have &lt;code&gt;pg_class&lt;/code&gt; entries.)</source>
          <target state="translated">目录 &lt;code&gt;pg_attribute&lt;/code&gt; 存储有关表列的信息。数据库中每个表中的每一列将只有一个 &lt;code&gt;pg_attribute&lt;/code&gt; 行。（还将有索引的属性条目，甚至还有所有具有 &lt;code&gt;pg_class&lt;/code&gt; 条目的对象。）</target>
        </trans-unit>
        <trans-unit id="85bbce99b3a9fdd7e277ae10030b9970f56238bf" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_auth_members&lt;/code&gt; shows the membership relations between roles. Any non-circular set of relationships is allowed.</source>
          <target state="translated">目录 &lt;code&gt;pg_auth_members&lt;/code&gt; 显示角色之间的成员关系。允许任何非循环的关系集。</target>
        </trans-unit>
        <trans-unit id="c8154dc7e56592f09e48c6280c85b2550f6de4fa" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_authid&lt;/code&gt; contains information about database authorization identifiers (roles). A role subsumes the concepts of &amp;ldquo;users&amp;rdquo; and &amp;ldquo;groups&amp;rdquo;. A user is essentially just a role with the &lt;code&gt;rolcanlogin&lt;/code&gt; flag set. Any role (with or without &lt;code&gt;rolcanlogin&lt;/code&gt;) can have other roles as members; see &lt;a href=&quot;catalog-pg-auth-members&quot;&gt;&lt;code&gt;pg_auth_members&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">目录 &lt;code&gt;pg_authid&lt;/code&gt; 包含有关数据库授权标识符（角色）的信息。角色包含&amp;ldquo;用户&amp;rdquo;和&amp;ldquo;组&amp;rdquo;的概念。用户本质上只是设置了 &lt;code&gt;rolcanlogin&lt;/code&gt; 标志的角色。任何角色（具有或不具有 &lt;code&gt;rolcanlogin&lt;/code&gt; ）都可以具有其他角色。参见&lt;a href=&quot;catalog-pg-auth-members&quot;&gt; &lt;code&gt;pg_auth_members&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ec983a869f6c2ea34ce8826bbeff462247f967af" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_cast&lt;/code&gt; stores data type conversion paths, both built-in and user-defined.</source>
          <target state="translated">目录 &lt;code&gt;pg_cast&lt;/code&gt; 存储内置和用户定义的数据类型转换路径。</target>
        </trans-unit>
        <trans-unit id="9d04631bf68325b8525e49c943e731abe3613af7" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_class&lt;/code&gt; catalogs tables and most everything else that has columns or is otherwise similar to a table. This includes indexes (but see also &lt;code&gt;pg_index&lt;/code&gt;), sequences (but see also &lt;code&gt;pg_sequence&lt;/code&gt;), views, materialized views, composite types, and TOAST tables; see &lt;code&gt;relkind&lt;/code&gt;. Below, when we mean all of these kinds of objects we speak of &amp;ldquo;relations&amp;rdquo;. Not all columns are meaningful for all relation types.</source>
          <target state="translated">目录 &lt;code&gt;pg_class&lt;/code&gt; 对表以及具有列或与表相似的其他所有东西进行目录。这包括索引（另请参阅 &lt;code&gt;pg_index&lt;/code&gt; ），序列（另请参阅 &lt;code&gt;pg_sequence&lt;/code&gt; ），视图，实例化视图，组合类型和TOAST表；参见 &lt;code&gt;relkind&lt;/code&gt; 。下面，当我们指所有这些对象时，我们称之为&amp;ldquo;关系&amp;rdquo;。并非所有列对于所有关系类型都有意义。</target>
        </trans-unit>
        <trans-unit id="ce60dbecc80ee8b02722d2865bea98e5166433a6" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_collation&lt;/code&gt; describes the available collations, which are essentially mappings from an SQL name to operating system locale categories. See &lt;a href=&quot;collation&quot;&gt;Section 23.2&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;pg_collation&lt;/code&gt; 目录描述了可用的归类，它们实际上是从SQL名称到操作系统区域设置类别的映射。有关更多信息，请参见&lt;a href=&quot;collation&quot;&gt;第23.2节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b24facc60ba613b096ec1ffd9828eff85b641f58" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_constraint&lt;/code&gt; stores check, primary key, unique, foreign key, and exclusion constraints on tables. (Column constraints are not treated specially. Every column constraint is equivalent to some table constraint.) Not-null constraints are represented in the &lt;code&gt;pg_attribute&lt;/code&gt; catalog, not here.</source>
          <target state="translated">目录 &lt;code&gt;pg_constraint&lt;/code&gt; 在表上存储检查，主键，唯一键，外键和排除约束。（列约束没有得到特殊对待。每个列约束都等同于某些表约束。）非空约束在 &lt;code&gt;pg_attribute&lt;/code&gt; 目录中表示，此处未列出。</target>
        </trans-unit>
        <trans-unit id="b1be34b922edf24e062d7f1ae068ab828f281a75" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_conversion&lt;/code&gt; describes encoding conversion functions. See &lt;a href=&quot;sql-createconversion&quot;&gt;CREATE CONVERSION&lt;/a&gt; for more information.</source>
          <target state="translated">目录 &lt;code&gt;pg_conversion&lt;/code&gt; 描述了编码转换功能。有关更多信息，请参见&lt;a href=&quot;sql-createconversion&quot;&gt;CREATE CONVERSION&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7fa266de7304c33b5491fba7214040981ff64d51" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_database&lt;/code&gt; stores information about the available databases. Databases are created with the &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt; command. Consult &lt;a href=&quot;https://www.postgresql.org/docs/12/managing-databases.html&quot;&gt;Chapter 22&lt;/a&gt; for details about the meaning of some of the parameters.</source>
          <target state="translated">目录 &lt;code&gt;pg_database&lt;/code&gt; 存储有关可用数据库的信息。使用&lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt;命令创建数据库。有关某些参数含义的详细信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/managing-databases.html&quot;&gt;第22章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f49685a729552e79238070db8b64c8366090dda2" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_database&lt;/code&gt; stores information about the available databases. Databases are created with the &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt; command. Consult &lt;a href=&quot;https://www.postgresql.org/docs/13/managing-databases.html&quot;&gt;Chapter 22&lt;/a&gt; for details about the meaning of some of the parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eca146c013dcb962be7fbc89316ecc63d19d2b8" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_db_role_setting&lt;/code&gt; records the default values that have been set for run-time configuration variables, for each role and database combination.</source>
          <target state="translated">目录 &lt;code&gt;pg_db_role_setting&lt;/code&gt; 记录了针对每个角色和数据库组合为运行时配置变量设置的默认值。</target>
        </trans-unit>
        <trans-unit id="e6bd2b6528e4d970391e533c9ea2086c3fe18fc0" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_default_acl&lt;/code&gt; stores initial privileges to be assigned to newly created objects.</source>
          <target state="translated">目录 &lt;code&gt;pg_default_acl&lt;/code&gt; 存储要分配给新创建对象的初始特权。</target>
        </trans-unit>
        <trans-unit id="fa08d6f7153471b38ae0793d338ba6ab5b3ad0bd" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_depend&lt;/code&gt; records the dependency relationships between database objects. This information allows &lt;code&gt;DROP&lt;/code&gt; commands to find which other objects must be dropped by &lt;code&gt;DROP CASCADE&lt;/code&gt; or prevent dropping in the &lt;code&gt;DROP RESTRICT&lt;/code&gt; case.</source>
          <target state="translated">目录 &lt;code&gt;pg_depend&lt;/code&gt; 记录数据库对象之间的依赖关系。此信息允许 &lt;code&gt;DROP&lt;/code&gt; 命令查找 &lt;code&gt;DROP CASCADE&lt;/code&gt; 必须删除哪些其他对象，或者在 &lt;code&gt;DROP RESTRICT&lt;/code&gt; 情况下防止删除。</target>
        </trans-unit>
        <trans-unit id="ef59984dd4696772f2e8a7bbf2dcc9de1f2f041a" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_description&lt;/code&gt; stores optional descriptions (comments) for each database object. Descriptions can be manipulated with the &lt;a href=&quot;sql-comment&quot;&gt;COMMENT&lt;/a&gt; command and viewed with psql's &lt;code&gt;\d&lt;/code&gt; commands. Descriptions of many built-in system objects are provided in the initial contents of &lt;code&gt;pg_description&lt;/code&gt;.</source>
          <target state="translated">目录 &lt;code&gt;pg_description&lt;/code&gt; 存储每个数据库对象的可选描述（注释）。可以使用&lt;a href=&quot;sql-comment&quot;&gt;COMMENT&lt;/a&gt;命令处理描述，并可以使用psql的 &lt;code&gt;\d&lt;/code&gt; 命令查看描述。 &lt;code&gt;pg_description&lt;/code&gt; 的初始内容中提供了许多内置系统对象的描述。</target>
        </trans-unit>
        <trans-unit id="9f9198ecc665eb9bf0a1925898c8388b6df71db7" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_event_trigger&lt;/code&gt; stores event triggers. See &lt;a href=&quot;https://www.postgresql.org/docs/12/event-triggers.html&quot;&gt;Chapter 39&lt;/a&gt; for more information.</source>
          <target state="translated">目录 &lt;code&gt;pg_event_trigger&lt;/code&gt; 存储事件触发器。有关更多信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/event-triggers.html&quot;&gt;第39章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5ae659e278f2c6f623d87b5b040902fb8aebc1a0" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_event_trigger&lt;/code&gt; stores event triggers. See &lt;a href=&quot;https://www.postgresql.org/docs/13/event-triggers.html&quot;&gt;Chapter 39&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08e240a6b04efec03e383c5c2cbf6a0f5343f115" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_extension&lt;/code&gt; stores information about the installed extensions. See &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-extensions.html&quot;&gt;Section 37.17&lt;/a&gt; for details about extensions.</source>
          <target state="translated">目录 &lt;code&gt;pg_extension&lt;/code&gt; 存储有关已安装扩展的信息。有关扩展的详细信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/extend-extensions.html&quot;&gt;第37.17节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9a6bd669eb72e3c7fbbe3af8a149088d554d60d9" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_extension&lt;/code&gt; stores information about the installed extensions. See &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-extensions.html&quot;&gt;Section 37.17&lt;/a&gt; for details about extensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60ec179e1854cef6ef5b48336a3d0be1aebd94a3" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_foreign_data_wrapper&lt;/code&gt; stores foreign-data wrapper definitions. A foreign-data wrapper is the mechanism by which external data, residing on foreign servers, is accessed.</source>
          <target state="translated">目录 &lt;code&gt;pg_foreign_data_wrapper&lt;/code&gt; 存储外部数据包装器定义。外部数据包装器是一种访问位于外部服务器上的外部数据的机制。</target>
        </trans-unit>
        <trans-unit id="14e59b5f4fd68c0de1f4d9757cb9140d56e66bca" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_foreign_server&lt;/code&gt; stores foreign server definitions. A foreign server describes a source of external data, such as a remote server. Foreign servers are accessed via foreign-data wrappers.</source>
          <target state="translated">目录 &lt;code&gt;pg_foreign_server&lt;/code&gt; 存储外部服务器定义。外部服务器描述了外部数据的来源，例如远程服务器。外部服务器通过外部数据包装器访问。</target>
        </trans-unit>
        <trans-unit id="51d82ed7d4c3db5d6e6e20d733bd83d0fb2db31f" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_foreign_table&lt;/code&gt; contains auxiliary information about foreign tables. A foreign table is primarily represented by a &lt;code&gt;pg_class&lt;/code&gt; entry, just like a regular table. Its &lt;code&gt;pg_foreign_table&lt;/code&gt; entry contains the information that is pertinent only to foreign tables and not any other kind of relation.</source>
          <target state="translated">目录 &lt;code&gt;pg_foreign_table&lt;/code&gt; 包含有关外部表的辅助信息。外部表主要由 &lt;code&gt;pg_class&lt;/code&gt; 条目表示，就像常规表一样。它的 &lt;code&gt;pg_foreign_table&lt;/code&gt; 条目包含仅与外部表相关的信息，而与其他任何类型的关系均不相关。</target>
        </trans-unit>
        <trans-unit id="775fb259c9b9e32be3ed5d81afd596a58bfd39dd" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_index&lt;/code&gt; contains part of the information about indexes. The rest is mostly in &lt;code&gt;pg_class&lt;/code&gt;.</source>
          <target state="translated">目录 &lt;code&gt;pg_index&lt;/code&gt; 包含有关索引的部分信息。其余大部分在 &lt;code&gt;pg_class&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="be9fa6ee074572af10ef89fb86dd033d0a67087f" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_inherits&lt;/code&gt; records information about table and index inheritance hierarchies. There is one entry for each direct parent-child table or index relationship in the database. (Indirect inheritance can be determined by following chains of entries.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a623a0b18b2ebaf8e83d5ac1d0d6cf3474af033" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_inherits&lt;/code&gt; records information about table inheritance hierarchies. There is one entry for each direct parent-child table relationship in the database. (Indirect inheritance can be determined by following chains of entries.)</source>
          <target state="translated">目录 &lt;code&gt;pg_inherits&lt;/code&gt; 记录有关表继承层次结构的信息。数据库中的每个直接父子表关系都有一个条目。（间接继承可以通过以下条目链来确定。）</target>
        </trans-unit>
        <trans-unit id="3ef3657b35ed0b4f238ec5987d2edc24285c1ce6" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_init_privs&lt;/code&gt; records information about the initial privileges of objects in the system. There is one entry for each object in the database which has a non-default (non-NULL) initial set of privileges.</source>
          <target state="translated">目录 &lt;code&gt;pg_init_privs&lt;/code&gt; 记录有关系统中对象的初始特权的信息。数据库中每个对象都有一个条目，该条目具有一组非默认（非NULL）的初始特权。</target>
        </trans-unit>
        <trans-unit id="aed131707c511022c9597a108a69123aaaa06b71" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_language&lt;/code&gt; registers languages in which you can write functions or stored procedures. See &lt;a href=&quot;sql-createlanguage&quot;&gt;CREATE LANGUAGE&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/xplang.html&quot;&gt;Chapter 41&lt;/a&gt; for more information about language handlers.</source>
          <target state="translated">&lt;code&gt;pg_language&lt;/code&gt; 目录注册您可以编写函数或存储过程的语言。有关语言处理程序的更多信息，请参见&lt;a href=&quot;sql-createlanguage&quot;&gt;CREATE LANGUAGE&lt;/a&gt;和&lt;a href=&quot;https://www.postgresql.org/docs/12/xplang.html&quot;&gt;第41章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3dbfd44a82e6b207a606d4410b4069adc945e68c" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_language&lt;/code&gt; registers languages in which you can write functions or stored procedures. See &lt;a href=&quot;sql-createlanguage&quot;&gt;CREATE LANGUAGE&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/13/xplang.html&quot;&gt;Chapter 41&lt;/a&gt; for more information about language handlers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc853ae6dcab566bb8d51b6c3df6a48ca149be41" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_largeobject&lt;/code&gt; holds the data making up &amp;ldquo;large objects&amp;rdquo;. A large object is identified by an OID assigned when it is created. Each large object is broken into segments or &amp;ldquo;pages&amp;rdquo; small enough to be conveniently stored as rows in &lt;code&gt;pg_largeobject&lt;/code&gt;. The amount of data per page is defined to be &lt;code&gt;LOBLKSIZE&lt;/code&gt; (which is currently &lt;code&gt;BLCKSZ/4&lt;/code&gt;, or typically 2 kB).</source>
          <target state="translated">目录 &lt;code&gt;pg_largeobject&lt;/code&gt; 保存构成&amp;ldquo;大对象&amp;rdquo;的数据。大对象由创建对象时分配的OID标识。每个大对象都被分成足够小的小段或&amp;ldquo;页面&amp;rdquo;，以方便地作为行存储在 &lt;code&gt;pg_largeobject&lt;/code&gt; 中。每页的数据量定义为 &lt;code&gt;LOBLKSIZE&lt;/code&gt; （当前为 &lt;code&gt;BLCKSZ/4&lt;/code&gt; 或通常为2 kB）。</target>
        </trans-unit>
        <trans-unit id="637a0fff02f805fcd7f6572b41b759dc3d88c524" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_largeobject_metadata&lt;/code&gt; holds metadata associated with large objects. The actual large object data is stored in &lt;a href=&quot;catalog-pg-largeobject&quot;&gt;&lt;code&gt;pg_largeobject&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">目录 &lt;code&gt;pg_largeobject_metadata&lt;/code&gt; 保存与大对象相关的元数据。实际的大对象数据存储在&lt;a href=&quot;catalog-pg-largeobject&quot;&gt; &lt;code&gt;pg_largeobject&lt;/code&gt; 中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1da9fb341c1eb2b89353bf65057bd43bdb97a022" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_namespace&lt;/code&gt; stores namespaces. A namespace is the structure underlying SQL schemas: each namespace can have a separate collection of relations, types, etc. without name conflicts.</source>
          <target state="translated">目录 &lt;code&gt;pg_namespace&lt;/code&gt; 存储名称空间。命名空间是SQL模式基础的结构：每个命名空间可以具有独立的关系，类型等集合，而不会发生名称冲突。</target>
        </trans-unit>
        <trans-unit id="85e7a372d092106d4f08f9fcd3ea02828fcaa191" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_opclass&lt;/code&gt; defines index access method operator classes. Each operator class defines semantics for index columns of a particular data type and a particular index access method. An operator class essentially specifies that a particular operator family is applicable to a particular indexable column data type. The set of operators from the family that are actually usable with the indexed column are whichever ones accept the column's data type as their left-hand input.</source>
          <target state="translated">目录 &lt;code&gt;pg_opclass&lt;/code&gt; 定义索引访问方法操作符类。每个运算符类为特定数据类型的索引列和特定的索引访问方法定义语义。运算符类实质上指定了特定的运算符族适用于特定的可索引列数据类型。实际可用于索引列的族运算符集是接受该列的数据类型作为其左手输入的任何一个。</target>
        </trans-unit>
        <trans-unit id="c87fca68633fb63db57e86d79fac7ce1b22101ea" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_operator&lt;/code&gt; stores information about operators. See &lt;a href=&quot;sql-createoperator&quot;&gt;CREATE OPERATOR&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/xoper.html&quot;&gt;Section 37.14&lt;/a&gt; for more information.</source>
          <target state="translated">目录 &lt;code&gt;pg_operator&lt;/code&gt; 存储有关运算符的信息。有关更多信息，请参见&lt;a href=&quot;sql-createoperator&quot;&gt;创建运算符&lt;/a&gt;和&lt;a href=&quot;https://www.postgresql.org/docs/12/xoper.html&quot;&gt;第37.14节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="db699f37242b8105097dbca69774e5077ef97a6f" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_operator&lt;/code&gt; stores information about operators. See &lt;a href=&quot;sql-createoperator&quot;&gt;CREATE OPERATOR&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/13/xoper.html&quot;&gt;Section 37.14&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae3fdeed75aa3ce97ce3c38ef12f91f3c508c158" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_opfamily&lt;/code&gt; defines operator families. Each operator family is a collection of operators and associated support routines that implement the semantics specified for a particular index access method. Furthermore, the operators in a family are all &amp;ldquo;compatible&amp;rdquo;, in a way that is specified by the access method. The operator family concept allows cross-data-type operators to be used with indexes and to be reasoned about using knowledge of access method semantics.</source>
          <target state="translated">&lt;code&gt;pg_opfamily&lt;/code&gt; 目录定义了操作员族。每个运算符家族都是运算符和相关支持例程的集合，这些例程实现为特定索引访问方法指定的语义。此外，以访问方法指定的方式，家族中的操作员都是&amp;ldquo;兼容的&amp;rdquo;。运算符族的概念允许跨数据类型的运算符与索引一起使用，并在使用访问方法语义知识方面得到推理。</target>
        </trans-unit>
        <trans-unit id="9f9d81d5db57fdf3722685cee5c72c0b7b266b01" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_partitioned_table&lt;/code&gt; stores information about how tables are partitioned.</source>
          <target state="translated">目录 &lt;code&gt;pg_partitioned_table&lt;/code&gt; 存储有关表如何分区的信息。</target>
        </trans-unit>
        <trans-unit id="c4598dc8a02ea46018473ad3a155097abd3c7904" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_pltemplate&lt;/code&gt; stores &amp;ldquo;template&amp;rdquo; information for procedural languages. A template for a language allows the language to be created in a particular database by a simple &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; command, with no need to specify implementation details.</source>
          <target state="translated">目录 &lt;code&gt;pg_pltemplate&lt;/code&gt; 存储过程语言的&amp;ldquo;模板&amp;rdquo;信息。语言模板允许通过简单的 &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; 命令在特定数据库中创建该语言，而无需指定实现细节。</target>
        </trans-unit>
        <trans-unit id="38521eab8f4daa25e1c972502335611e746aa47f" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_policy&lt;/code&gt; stores row level security policies for tables. A policy includes the kind of command that it applies to (possibly all commands), the roles that it applies to, the expression to be added as a security-barrier qualification to queries that include the table, and the expression to be added as a &lt;code&gt;WITH CHECK&lt;/code&gt; option for queries that attempt to add new records to the table.</source>
          <target state="translated">目录 &lt;code&gt;pg_policy&lt;/code&gt; 存储表的行级安全策略。策略包括其适用的命令类型（可能是所有命令），其所应用的角色，要作为安全屏障限定条件添加到包含表的查询中的表达式以及要作为策略添加的表达式。对于尝试向表中添加新记录的查询， &lt;code&gt;WITH CHECK&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="077da08d3639d4de1fea458f7cc6d9c77756beb9" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_proc&lt;/code&gt; stores information about functions, procedures, aggregate functions, and window functions (collectively also known as routines). See &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;, &lt;a href=&quot;sql-createprocedure&quot;&gt;CREATE PROCEDURE&lt;/a&gt;, and &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc.html&quot;&gt;Section 37.3&lt;/a&gt; for more information.</source>
          <target state="translated">目录 &lt;code&gt;pg_proc&lt;/code&gt; 存储有关函数，过程，聚合函数和窗口函数（统称为例程）的信息。有关更多信息，请参见&lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;，&lt;a href=&quot;sql-createprocedure&quot;&gt;CREATE PROCEDURE&lt;/a&gt;和&lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc.html&quot;&gt;第37.3节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9e11644222b2201539ac16dfa7848782b7baf235" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_proc&lt;/code&gt; stores information about functions, procedures, aggregate functions, and window functions (collectively also known as routines). See &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;, &lt;a href=&quot;sql-createprocedure&quot;&gt;CREATE PROCEDURE&lt;/a&gt;, and &lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc.html&quot;&gt;Section 37.3&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bfdad63a7f3f3f55487cbe48d50b5126f2fe14c" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_publication&lt;/code&gt; contains all publications created in the database. For more on publications see &lt;a href=&quot;logical-replication-publication&quot;&gt;Section 30.1&lt;/a&gt;.</source>
          <target state="translated">目录 &lt;code&gt;pg_publication&lt;/code&gt; 包含在数据库中创建的所有发布。有关出版物的更多信息，请参见&lt;a href=&quot;logical-replication-publication&quot;&gt;第30.1节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b073514e28d8a7dd7d94b64ba581679b1b8073f2" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_publication_rel&lt;/code&gt; contains the mapping between relations and publications in the database. This is a many-to-many mapping. See also &lt;a href=&quot;view-pg-publication-tables&quot;&gt;Section 51.78&lt;/a&gt; for a more user-friendly view of this information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="221d9ab9d81b22114af5be8f658f635812a98821" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_publication_rel&lt;/code&gt; contains the mapping between relations and publications in the database. This is a many-to-many mapping. See also &lt;a href=&quot;view-pg-publication-tables&quot;&gt;Section 51.79&lt;/a&gt; for a more user-friendly view of this information.</source>
          <target state="translated">目录 &lt;code&gt;pg_publication_rel&lt;/code&gt; 包含数据库中关系和发布之间的映射。这是多对多映射。另请参见&lt;a href=&quot;view-pg-publication-tables&quot;&gt;第51.79节&lt;/a&gt;，以获取更友好的信息视图。</target>
        </trans-unit>
        <trans-unit id="52875f38f647bef6fb760c4d6882bec8ce49439c" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_range&lt;/code&gt; stores information about range types. This is in addition to the types' entries in &lt;a href=&quot;catalog-pg-type&quot;&gt;&lt;code&gt;pg_type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">目录 &lt;code&gt;pg_range&lt;/code&gt; 存储有关范围类型的信息。这是&lt;a href=&quot;catalog-pg-type&quot;&gt; &lt;code&gt;pg_type&lt;/code&gt; 中&lt;/a&gt;类型的条目的补充。</target>
        </trans-unit>
        <trans-unit id="cc31d507f60721e880a15f8324203d061317541c" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_rewrite&lt;/code&gt; stores rewrite rules for tables and views.</source>
          <target state="translated">目录 &lt;code&gt;pg_rewrite&lt;/code&gt; 存储表和视图的重写规则。</target>
        </trans-unit>
        <trans-unit id="2bbefd7f86634f56307ee5fef9c894c5719937d5" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_seclabel&lt;/code&gt; stores security labels on database objects. Security labels can be manipulated with the &lt;a href=&quot;sql-security-label&quot;&gt;SECURITY LABEL&lt;/a&gt; command. For an easier way to view security labels, see &lt;a href=&quot;view-pg-seclabels&quot;&gt;Section 51.83&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="743cf387d8af7cd433c0ab8fa075de457723d7d5" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_seclabel&lt;/code&gt; stores security labels on database objects. Security labels can be manipulated with the &lt;a href=&quot;sql-security-label&quot;&gt;SECURITY LABEL&lt;/a&gt; command. For an easier way to view security labels, see &lt;a href=&quot;view-pg-seclabels&quot;&gt;Section 51.84&lt;/a&gt;.</source>
          <target state="translated">目录 &lt;code&gt;pg_seclabel&lt;/code&gt; 在数据库对象上存储安全标签。可以使用&lt;a href=&quot;sql-security-label&quot;&gt;SECURITY LABEL&lt;/a&gt;命令来操作安全标签。有关查看安全标签的简便方法，请参见&lt;a href=&quot;view-pg-seclabels&quot;&gt;第51.84节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="06336f290aa5f875fbaac3ca8b83cb8674898645" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_sequence&lt;/code&gt; contains information about sequences. Some of the information about sequences, such as the name and the schema, is in &lt;code&gt;pg_class&lt;/code&gt;.</source>
          <target state="translated">目录 &lt;code&gt;pg_sequence&lt;/code&gt; 包含有关序列的信息。某些有关序列的信息，例如名称和模式，在 &lt;code&gt;pg_class&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="98aafe9d92bd83fff00a553e40adb49ebd9fb0ff" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_shdepend&lt;/code&gt; records the dependency relationships between database objects and shared objects, such as roles. This information allows PostgreSQL to ensure that those objects are unreferenced before attempting to delete them.</source>
          <target state="translated">目录 &lt;code&gt;pg_shdepend&lt;/code&gt; 记录数据库对象和共享对象（例如角色）之间的依赖关系。该信息使PostgreSQL可以确保在尝试删除这些对象之前未对其进行引用。</target>
        </trans-unit>
        <trans-unit id="707a904a0a65e47118a70277c90bf66e00682ea7" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_shdescription&lt;/code&gt; stores optional descriptions (comments) for shared database objects. Descriptions can be manipulated with the &lt;a href=&quot;sql-comment&quot;&gt;COMMENT&lt;/a&gt; command and viewed with psql's &lt;code&gt;\d&lt;/code&gt; commands.</source>
          <target state="translated">目录 &lt;code&gt;pg_shdescription&lt;/code&gt; 存储共享数据库对象的可选描述（注释）。可以使用&lt;a href=&quot;sql-comment&quot;&gt;COMMENT&lt;/a&gt;命令处理描述，并使用psql的 &lt;code&gt;\d&lt;/code&gt; 命令查看描述。</target>
        </trans-unit>
        <trans-unit id="108e726e137da0b8ec8293c84d0b89131f7f1510" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_shseclabel&lt;/code&gt; stores security labels on shared database objects. Security labels can be manipulated with the &lt;a href=&quot;sql-security-label&quot;&gt;SECURITY LABEL&lt;/a&gt; command. For an easier way to view security labels, see &lt;a href=&quot;view-pg-seclabels&quot;&gt;Section 51.83&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb1cad576af7b20a74691e7e84a0abf3918f82ca" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_shseclabel&lt;/code&gt; stores security labels on shared database objects. Security labels can be manipulated with the &lt;a href=&quot;sql-security-label&quot;&gt;SECURITY LABEL&lt;/a&gt; command. For an easier way to view security labels, see &lt;a href=&quot;view-pg-seclabels&quot;&gt;Section 51.84&lt;/a&gt;.</source>
          <target state="translated">目录 &lt;code&gt;pg_shseclabel&lt;/code&gt; 在共享数据库对象上存储安全标签。可以使用&lt;a href=&quot;sql-security-label&quot;&gt;SECURITY LABEL&lt;/a&gt;命令来操作安全标签。有关查看安全标签的简便方法，请参见&lt;a href=&quot;view-pg-seclabels&quot;&gt;第51.84节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d95048be51e3aac388b17358a36c3017066f7afd" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_statistic&lt;/code&gt; stores statistical data about the contents of the database. Entries are created by &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; and subsequently used by the query planner. Note that all the statistical data is inherently approximate, even assuming that it is up-to-date.</source>
          <target state="translated">目录 &lt;code&gt;pg_statistic&lt;/code&gt; 存储有关数据库内容的统计数据。条目是由&lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt;创建的，随后由查询计划者使用。请注意，所有统计数据本质上都是近似的，即使假设它是最新的。</target>
        </trans-unit>
        <trans-unit id="1a788b199242747f1e3ab3d464f7f212c88021b3" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_statistic_ext&lt;/code&gt; holds definitions of extended planner statistics. Each row in this catalog corresponds to a &lt;em&gt;statistics object&lt;/em&gt; created with &lt;a href=&quot;sql-createstatistics&quot;&gt;CREATE STATISTICS&lt;/a&gt;.</source>
          <target state="translated">目录 &lt;code&gt;pg_statistic_ext&lt;/code&gt; 包含扩展计划程序统计信息的定义。该目录中的每一行都对应一个使用&lt;a href=&quot;sql-createstatistics&quot;&gt;CREATE STATISTICS&lt;/a&gt;创建的&lt;em&gt;统计对象&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="efd7c967165399ed5a01a4ab9407cb379c75802f" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; holds data for extended planner statistics defined in &lt;code&gt;pg_statistic_ext&lt;/code&gt;. Each row in this catalog corresponds to a &lt;em&gt;statistics object&lt;/em&gt; created with &lt;a href=&quot;sql-createstatistics&quot;&gt;CREATE STATISTICS&lt;/a&gt;.</source>
          <target state="translated">目录 &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; 包含 &lt;code&gt;pg_statistic_ext&lt;/code&gt; 中定义的扩展计划程序统计数据。该目录中的每一行都对应一个使用&lt;a href=&quot;sql-createstatistics&quot;&gt;CREATE STATISTICS&lt;/a&gt;创建的&lt;em&gt;统计对象&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="c35fed25fc50b397d0a14fb9dcbeb17e75e6fe0f" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_subscription&lt;/code&gt; contains all existing logical replication subscriptions. For more information about logical replication see &lt;a href=&quot;https://www.postgresql.org/docs/12/logical-replication.html&quot;&gt;Chapter 30&lt;/a&gt;.</source>
          <target state="translated">目录 &lt;code&gt;pg_subscription&lt;/code&gt; 包含所有现有的逻辑复制预订。有关逻辑复制的更多信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/logical-replication.html&quot;&gt;第30章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2bfa0dd174813a02371e96eb1388d8212cb9d420" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_subscription&lt;/code&gt; contains all existing logical replication subscriptions. For more information about logical replication see &lt;a href=&quot;https://www.postgresql.org/docs/13/logical-replication.html&quot;&gt;Chapter 30&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cdf4cde86fcb864fb5af90b023119fc34f2142d" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_subscription_rel&lt;/code&gt; contains the state for each replicated relation in each subscription. This is a many-to-many mapping.</source>
          <target state="translated">目录 &lt;code&gt;pg_subscription_rel&lt;/code&gt; 包含每个预订中每个复制关系的状态。这是多对多映射。</target>
        </trans-unit>
        <trans-unit id="c447f5488ab316d33bbd3ebcf5f5d8b7c31ae85d" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_tablespace&lt;/code&gt; stores information about the available tablespaces. Tables can be placed in particular tablespaces to aid administration of disk layout.</source>
          <target state="translated">目录 &lt;code&gt;pg_tablespace&lt;/code&gt; 存储有关可用表空间的信息。可以将表放在特定的表空间中，以帮助管理磁盘布局。</target>
        </trans-unit>
        <trans-unit id="5fd8fed96cb099d0e2d39d4d04e6e7c47d74045e" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_transform&lt;/code&gt; stores information about transforms, which are a mechanism to adapt data types to procedural languages. See &lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORM&lt;/a&gt; for more information.</source>
          <target state="translated">目录 &lt;code&gt;pg_transform&lt;/code&gt; 存储有关转换的信息，这是一种使数据类型适应过程语言的机制。有关更多信息，请参见&lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORM&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="75ce3dfcf04f9d1f1bc6bfe6a8a43c82175b0a72" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_trigger&lt;/code&gt; stores triggers on tables and views. See &lt;a href=&quot;sql-createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; for more information.</source>
          <target state="translated">目录 &lt;code&gt;pg_trigger&lt;/code&gt; 在表和视图上存储触发器。有关更多信息，请参见&lt;a href=&quot;sql-createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="392fc6d5e6430c985734db6f435318b9f05a7dd3" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_type&lt;/code&gt; stores information about data types. Base types and enum types (scalar types) are created with &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt;, and domains with &lt;a href=&quot;sql-createdomain&quot;&gt;CREATE DOMAIN&lt;/a&gt;. A composite type is automatically created for each table in the database, to represent the row structure of the table. It is also possible to create composite types with &lt;code&gt;CREATE TYPE AS&lt;/code&gt;.</source>
          <target state="translated">目录 &lt;code&gt;pg_type&lt;/code&gt; 存储有关数据类型的信息。基本类型和枚举类型（标量类型）使用&lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt;创建，而域使用&lt;a href=&quot;sql-createdomain&quot;&gt;CREATE DOMAIN创建&lt;/a&gt;。将为数据库中的每个表自动创建一个复合类型，以表示该表的行结构。也可以使用 &lt;code&gt;CREATE TYPE AS&lt;/code&gt; 创建复合类型。</target>
        </trans-unit>
        <trans-unit id="6bc1e303fc4f7bb28411737b0ff9561def41771f" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_user_mapping&lt;/code&gt; stores the mappings from local user to remote. Access to this catalog is restricted from normal users, use the view &lt;a href=&quot;view-pg-user-mappings&quot;&gt;&lt;code&gt;pg_user_mappings&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">目录 &lt;code&gt;pg_user_mapping&lt;/code&gt; 存储从本地用户到远程用户的映射。普通用户不能访问此目录，请改用视图&lt;a href=&quot;view-pg-user-mappings&quot;&gt; &lt;code&gt;pg_user_mappings&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="96e368561ccfd905eaa08f49037cf99602ef83c4" translate="yes" xml:space="preserve">
          <source>The category code (a single ASCII character) for this type. The default is &lt;code&gt;'U'&lt;/code&gt; for &amp;ldquo;user-defined type&amp;rdquo;. Other standard category codes can be found in &lt;a href=&quot;catalog-pg-type#CATALOG-TYPCATEGORY-TABLE&quot;&gt;Table 51.63&lt;/a&gt;. You may also choose other ASCII characters in order to create custom categories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60a544b25f1cc2eef0830902b29eb1826d7423c5" translate="yes" xml:space="preserve">
          <source>The category code (a single ASCII character) for this type. The default is &lt;code&gt;'U'&lt;/code&gt; for &amp;ldquo;user-defined type&amp;rdquo;. Other standard category codes can be found in &lt;a href=&quot;catalog-pg-type#CATALOG-TYPCATEGORY-TABLE&quot;&gt;Table 51.64&lt;/a&gt;. You may also choose other ASCII characters in order to create custom categories.</source>
          <target state="translated">此类型的类别代码（单个ASCII字符）。对于&amp;ldquo;用户定义类型&amp;rdquo; ，默认值为 &lt;code&gt;'U'&lt;/code&gt; &amp;rdquo;。其他标准类别代码可以在&lt;a href=&quot;catalog-pg-type#CATALOG-TYPCATEGORY-TABLE&quot;&gt;表51.64中&lt;/a&gt;找到。您也可以选择其他ASCII字符以创建自定义类别。</target>
        </trans-unit>
        <trans-unit id="6e0699308172a4d35d3852cf096bcc7cdc0d6fc5" translate="yes" xml:space="preserve">
          <source>The category names translate into names of &lt;code&gt;initdb&lt;/code&gt; options to override the locale choice for a specific category. For instance, to set the locale to French Canadian, but use U.S. rules for formatting currency, use &lt;code&gt;initdb --locale=fr_CA --lc-monetary=en_US&lt;/code&gt;.</source>
          <target state="translated">类别名称转换为 &lt;code&gt;initdb&lt;/code&gt; 选项的名称，以覆盖特定类别的语言环境选择。例如，要将语言环境设置为加拿大法语，但使用美国规则来格式化货币，请使用 &lt;code&gt;initdb --locale=fr_CA --lc-monetary=en_US&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="90aadd1f991be6c6a59649f2cf2279a49d630988" translate="yes" xml:space="preserve">
          <source>The century</source>
          <target state="translated">本世纪</target>
        </trans-unit>
        <trans-unit id="64714127e62379960f8b9dabad3b7dd16b967248" translate="yes" xml:space="preserve">
          <source>The character set encoding specified for the new database must be compatible with the chosen locale settings (&lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt;). If the locale is &lt;code&gt;C&lt;/code&gt; (or equivalently &lt;code&gt;POSIX&lt;/code&gt;), then all encodings are allowed, but for other locale settings there is only one encoding that will work properly. (On Windows, however, UTF-8 encoding can be used with any locale.) &lt;code&gt;CREATE DATABASE&lt;/code&gt; will allow superusers to specify &lt;code&gt;SQL_ASCII&lt;/code&gt; encoding regardless of the locale settings, but this choice is deprecated and may result in misbehavior of character-string functions if data that is not encoding-compatible with the locale is stored in the database.</source>
          <target state="translated">为新数据库指定的字符集编码必须与所选的语言环境设置（ &lt;code&gt;LC_COLLATE&lt;/code&gt; 和 &lt;code&gt;LC_CTYPE&lt;/code&gt; ）兼容。如果语言环境为 &lt;code&gt;C&lt;/code&gt; （或等价的 &lt;code&gt;POSIX&lt;/code&gt; ），则允许所有编码，但是对于其他语言环境设置，只有一种编码可以正常工作。 （但是，在Windows上，可以在任何语言环境中使用UTF-8编码。） &lt;code&gt;CREATE DATABASE&lt;/code&gt; 将允许超级用户指定 &lt;code&gt;SQL_ASCII&lt;/code&gt; 编码，而与语言环境设置无关，但是不建议使用此选择，并且如果使用数据，则可能导致字符串函数的行为不当与语言环境不兼容的代码存储在数据库中。</target>
        </trans-unit>
        <trans-unit id="89d6fa6368565c20d96f1143f8a41b5bdded6f20" translate="yes" xml:space="preserve">
          <source>The character set support in PostgreSQL allows you to store text in a variety of character sets (also called encodings), including single-byte character sets such as the ISO 8859 series and multiple-byte character sets such as EUC (Extended Unix Code), UTF-8, and Mule internal code. All supported character sets can be used transparently by clients, but a few are not supported for use within the server (that is, as a server-side encoding). The default character set is selected while initializing your PostgreSQL database cluster using &lt;code&gt;initdb&lt;/code&gt;. It can be overridden when you create a database, so you can have multiple databases each with a different character set.</source>
          <target state="translated">PostgreSQL对字符集的支持使您可以将文本存储为多种字符集（也称为编码），包括单字节字符集（例如ISO 8859系列）和多字节字符集（例如EUC（扩展Unix代码））， UTF-8和Mule内部代码。客户端可以透明地使用所有支持的字符集，但是不支持在服务器内部使用其中的一些字符集（即，作为服务器端编码）。使用 &lt;code&gt;initdb&lt;/code&gt; 初始化PostgreSQL数据库集群时，将选择默认字符集。创建数据库时可以覆盖它，因此可以有多个数据库，每个数据库都有不同的字符集。</target>
        </trans-unit>
        <trans-unit id="97fdcbffdcc8da09aa147a46393111714ca188e7" translate="yes" xml:space="preserve">
          <source>The character with the code zero cannot be in a string constant.</source>
          <target state="translated">代码为零的字符不能出现在字符串常量中。</target>
        </trans-unit>
        <trans-unit id="1c743222d29807902173d80c9ab0c69944ad07be" translate="yes" xml:space="preserve">
          <source>The character with the indicated octal code is substituted.</source>
          <target state="translated">替换了带有指示八进制代码的字符。</target>
        </trans-unit>
        <trans-unit id="9883df04aca064376efa049e7f1ac203fe46e46b" translate="yes" xml:space="preserve">
          <source>The character-entry escapes are always taken as ordinary characters. For example, &lt;code&gt;\135&lt;/code&gt; is &lt;code&gt;]&lt;/code&gt; in ASCII, but &lt;code&gt;\135&lt;/code&gt; does not terminate a bracket expression.</source>
          <target state="translated">字符输入转义符始终被视为普通字符。例如， &lt;code&gt;\135&lt;/code&gt; 是ASCII中的 &lt;code&gt;]&lt;/code&gt; ，但是 &lt;code&gt;\135&lt;/code&gt; 不会终止方括号表达式。</target>
        </trans-unit>
        <trans-unit id="ef0e78b53fce5d8f9142725e8e0f3c5fa09a015f" translate="yes" xml:space="preserve">
          <source>The checkpoint requirement of flushing all dirty data pages to disk can cause a significant I/O load. For this reason, checkpoint activity is throttled so that I/O begins at checkpoint start and completes before the next checkpoint is due to start; this minimizes performance degradation during checkpoints.</source>
          <target state="translated">检查点要求将所有肮脏的数据页冲到磁盘上,这可能会造成大量的I/O负载。因此,检查点活动被节流,使I/O在检查点开始时开始,并在下一个检查点开始前完成;这最大限度地降低了检查点期间的性能下降。</target>
        </trans-unit>
        <trans-unit id="f4d35c97f000761ce44e09472b3a63a412d56f71" translate="yes" xml:space="preserve">
          <source>The checkpointer process and the background writer process are active during recovery. The checkpointer process will perform restartpoints (similar to checkpoints on the primary) and the background writer process will perform normal block cleaning activities. This can include updates of the hint bit information stored on the standby server. The &lt;code&gt;CHECKPOINT&lt;/code&gt; command is accepted during recovery, though it performs a restartpoint rather than a new checkpoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c35fb7c2595863d64a01efb7c2bd0d7867c26535" translate="yes" xml:space="preserve">
          <source>The checksum algorithm used to compute a checksum for this file. Currently, this will be the same for every file in the backup manifest, but this may change in future releases. At present, the supported checksum algorithms are &lt;code&gt;CRC32C&lt;/code&gt;, &lt;code&gt;SHA224&lt;/code&gt;, &lt;code&gt;SHA256&lt;/code&gt;, &lt;code&gt;SHA384&lt;/code&gt;, and &lt;code&gt;SHA512&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e144e6ae4a14c0e501dd6cac26f66ddeeba08c8" translate="yes" xml:space="preserve">
          <source>The checksum computed for this file, stored as a series of hexadecimal characters, two for each byte of the checksum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aea1ec4dfdbf684f4c49444bdb751e65ee9f5e89" translate="yes" xml:space="preserve">
          <source>The checksum computed with this function can be compared with the &lt;code&gt;checksum&lt;/code&gt; result field of the function &lt;code&gt;page_header&lt;/code&gt;. If data checksums are enabled for this instance, then the two values should be equal.</source>
          <target state="translated">可以将此函数计算出的 &lt;code&gt;checksum&lt;/code&gt; 与函数 &lt;code&gt;page_header&lt;/code&gt; 的校验和结果字段进行比较。如果为此实例启用了数据校验和，则两个值应相等。</target>
        </trans-unit>
        <trans-unit id="12cbfddc1d2244a2eb37d3e1009dc9d4f7140abc" translate="yes" xml:space="preserve">
          <source>The choice between GiST and GIN indexing depends on the relative performance characteristics of GiST and GIN, which are discussed elsewhere.</source>
          <target state="translated">GiST和GIN指数的选择取决于GiST和GIN的相对性能特点,这一点将在其他地方讨论。</target>
        </trans-unit>
        <trans-unit id="3567ccb40f1481d219e5951c92fe9f650cc7303e" translate="yes" xml:space="preserve">
          <source>The choice between these formats is up to the user. The first format is a proper XML document, which will be important in many applications. The second format tends to be more useful in the &lt;code&gt;cursor_to_xml&lt;/code&gt; function if the result values are to be reassembled into one document later on. The functions for producing XML content discussed above, in particular &lt;code&gt;xmlelement&lt;/code&gt;, can be used to alter the results to taste.</source>
          <target state="translated">这些格式之间的选择取决于用户。第一种格式是正确的XML文档，这在许多应用程序中将非常重要。如果以后将结果值重新组合到一个文档中，则第二种格式在 &lt;code&gt;cursor_to_xml&lt;/code&gt; 函数中往往更有用。上面讨论的用于生成XML内容的功能（尤其是 &lt;code&gt;xmlelement&lt;/code&gt; ）可用于更改结果以使其符合口味。</target>
        </trans-unit>
        <trans-unit id="2fcd6e12232fcafb17e4f9eed475f29ab9c942d0" translate="yes" xml:space="preserve">
          <source>The choice of how to partition a table should be made carefully as the performance of query planning and execution can be negatively affected by poor design.</source>
          <target state="translated">对表的分区方式的选择要慎重,因为设计不当会对查询规划和执行的性能产生负面影响。</target>
        </trans-unit>
        <trans-unit id="eba68582494f00f7d7461ffee77aebc9a862ba45" translate="yes" xml:space="preserve">
          <source>The clause &lt;code&gt;CACHE cache&lt;/code&gt; enables sequence numbers to be preallocated and stored in memory for faster access. The minimum value is 1 (only one value can be generated at a time, i.e., no cache). If unspecified, the old cache value will be maintained.</source>
          <target state="translated">&lt;code&gt;CACHE cache&lt;/code&gt; 子句使序列号可以预先分配并存储在内存中，以加快访问速度。最小值为1（一次只能生成一个值，即没有高速缓存）。如果未指定，则将保留旧的缓存值。</target>
        </trans-unit>
        <trans-unit id="75a69760c05706a624428c520aa62a2819be2cc8" translate="yes" xml:space="preserve">
          <source>The clause &lt;code&gt;INCREMENT BY increment&lt;/code&gt; is optional. A positive value will make an ascending sequence, a negative one a descending sequence. If unspecified, the old increment value will be maintained.</source>
          <target state="translated">&lt;code&gt;INCREMENT BY increment&lt;/code&gt; 子句是可选的。正值将形成一个升序，负值将形成一个降序。如果未指定，将保留旧的增量值。</target>
        </trans-unit>
        <trans-unit id="1e885032e33c3c5f3562475ecafb5ece897bbab7" translate="yes" xml:space="preserve">
          <source>The clauses &lt;code&gt;ALWAYS&lt;/code&gt; and &lt;code&gt;BY DEFAULT&lt;/code&gt; determine how explicitly user-specified values are handled in &lt;code&gt;INSERT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; commands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="867e5349b79e57e50c69654c14c2d9c684ca93bc" translate="yes" xml:space="preserve">
          <source>The clauses &lt;code&gt;ALWAYS&lt;/code&gt; and &lt;code&gt;BY DEFAULT&lt;/code&gt; determine how the sequence value is given precedence over a user-specified value in an &lt;code&gt;INSERT&lt;/code&gt; statement. If &lt;code&gt;ALWAYS&lt;/code&gt; is specified, a user-specified value is only accepted if the &lt;code&gt;INSERT&lt;/code&gt; statement specifies &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt;. If &lt;code&gt;BY DEFAULT&lt;/code&gt; is specified, then the user-specified value takes precedence. See &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt; for details. (In the &lt;code&gt;COPY&lt;/code&gt; command, user-specified values are always used regardless of this setting.)</source>
          <target state="translated">子句 &lt;code&gt;ALWAYS&lt;/code&gt; 和 &lt;code&gt;BY DEFAULT&lt;/code&gt; 确定如何在 &lt;code&gt;INSERT&lt;/code&gt; 语句中赋予序列值优先于用户指定的值。如果指定了 &lt;code&gt;ALWAYS&lt;/code&gt; ，则仅当 &lt;code&gt;INSERT&lt;/code&gt; 语句指定 &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt; 时,才接受用户指定的值。如果指定了 &lt;code&gt;BY DEFAULT&lt;/code&gt; ，则用户指定的值优先。有关详细信息，请参见&lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt;。 （在 &lt;code&gt;COPY&lt;/code&gt; 命令中，无论此设置如何，始终使用用户指定的值。）</target>
        </trans-unit>
        <trans-unit id="234bcc40e3c1c6669b66cf6ee7882220428cd61f" translate="yes" xml:space="preserve">
          <source>The clauses &lt;code&gt;LIMIT&lt;/code&gt; and &lt;code&gt;OFFSET&lt;/code&gt; are PostgreSQL-specific syntax, also used by MySQL. The SQL:2008 standard has introduced the clauses &lt;code&gt;OFFSET ... FETCH {FIRST|NEXT} ...&lt;/code&gt; for the same functionality, as shown above in &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;&lt;code&gt;LIMIT&lt;/code&gt; Clause&lt;/a&gt;. This syntax is also used by IBM DB2. (Applications written for Oracle frequently use a workaround involving the automatically generated &lt;code&gt;rownum&lt;/code&gt; column, which is not available in PostgreSQL, to implement the effects of these clauses.)</source>
          <target state="translated">&lt;code&gt;LIMIT&lt;/code&gt; 和 &lt;code&gt;OFFSET&lt;/code&gt; 子句是PostgreSQL特定的语法，也由MySQL使用。 SQL：2008标准引入了子句 &lt;code&gt;OFFSET ... FETCH {FIRST|NEXT} ...&lt;/code&gt; 来实现相同的功能，如上&lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt; &lt;code&gt;LIMIT&lt;/code&gt; 子句&lt;/a&gt;所示。 IBM DB2也使用此语法。 （为Oracle编写的应用程序经常使用一种变通办法来实现这些子句的效果，该变通办法涉及自动生成的 &lt;code&gt;rownum&lt;/code&gt; 列，而该列在PostgreSQL中不可用。）</target>
        </trans-unit>
        <trans-unit id="4ef779e24cd70dc78d1e7371780e8d692d8fd135" translate="yes" xml:space="preserve">
          <source>The clauses &lt;code&gt;LIMIT&lt;/code&gt; and &lt;code&gt;OFFSET&lt;/code&gt; are PostgreSQL-specific syntax, also used by MySQL. The SQL:2008 standard has introduced the clauses &lt;code&gt;OFFSET ... FETCH {FIRST|NEXT} ...&lt;/code&gt; for the same functionality, as shown above in &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;LIMIT Clause&lt;/a&gt;. This syntax is also used by IBM DB2. (Applications written for Oracle frequently use a workaround involving the automatically generated &lt;code&gt;rownum&lt;/code&gt; column, which is not available in PostgreSQL, to implement the effects of these clauses.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54380a0f1c98e1a0a687fefef82dc949bcffc323" translate="yes" xml:space="preserve">
          <source>The client must be allowed to access all referenced tables and columns, even if they originated from views which were then expanded, so that we apply consistent access control rules independent of the manner in which the table contents are referenced.</source>
          <target state="translated">客户端必须被允许访问所有被引用的表和列,即使这些表和列源于视图,而视图又被展开,这样我们就可以应用一致的访问控制规则,而不依赖于表内容的引用方式。</target>
        </trans-unit>
        <trans-unit id="05fdc0ebe765756a24f5709f3f5f878e85b6fb9a" translate="yes" xml:space="preserve">
          <source>The client process can be any program that understands the PostgreSQL protocol described in &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol.html&quot;&gt;Chapter 52&lt;/a&gt;. Many clients are based on the C-language library libpq, but several independent implementations of the protocol exist, such as the Java JDBC driver.</source>
          <target state="translated">客户进程可以是任何能够理解&lt;a href=&quot;https://www.postgresql.org/docs/12/protocol.html&quot;&gt;第52章中&lt;/a&gt;描述的PostgreSQL协议的程序。许多客户端基于C语言库libpq，但是该协议存在几种独立的实现，例如Java JDBC驱动程序。</target>
        </trans-unit>
        <trans-unit id="973ecfa139cd389fe92d63aca6613fcea6c732f4" translate="yes" xml:space="preserve">
          <source>The client process can be any program that understands the PostgreSQL protocol described in &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol.html&quot;&gt;Chapter 52&lt;/a&gt;. Many clients are based on the C-language library libpq, but several independent implementations of the protocol exist, such as the Java JDBC driver.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14c663b89bef91d752e19ecca16e81b132b43904" translate="yes" xml:space="preserve">
          <source>The client responds by sending a SASLInitialResponse message, which indicates the chosen mechanism, &lt;code&gt;SCRAM-SHA-256&lt;/code&gt; or &lt;code&gt;SCRAM-SHA-256-PLUS&lt;/code&gt;. (A client is free to choose either mechanism, but for better security it should choose the channel-binding variant if it can support it.) In the Initial Client response field, the message contains the SCRAM &lt;code&gt;client-first-message&lt;/code&gt;. The &lt;code&gt;client-first-message&lt;/code&gt; also contains the channel binding type chosen by the client.</source>
          <target state="translated">客户端通过发送SASLInitialResponse消息进行响应，该消息指示所选的机制 &lt;code&gt;SCRAM-SHA-256&lt;/code&gt; 或 &lt;code&gt;SCRAM-SHA-256-PLUS&lt;/code&gt; 。（客户端可以自由选择任何一种机制，但是为了获得更高的安全性，如果它可以支持它，则应该选择通道绑定变体。）在&amp;ldquo;初始客户端响应&amp;rdquo;字段中，消息包含SCRAM &lt;code&gt;client-first-message&lt;/code&gt; 。在 &lt;code&gt;client-first-message&lt;/code&gt; 还包含由所述客户端所选择的信道绑定类型。</target>
        </trans-unit>
        <trans-unit id="28e4175f56ce1936736eeadfb881155016ea4fed" translate="yes" xml:space="preserve">
          <source>The client selects one of the supported mechanisms from the list, and sends a SASLInitialResponse message to the server. The message includes the name of the selected mechanism, and an optional Initial Client Response, if the selected mechanism uses that.</source>
          <target state="translated">客户端从列表中选择一个支持的机制,并向服务器发送一个SASLInitialResponse消息。该消息包括所选机制的名称,以及一个可选的初始客户端响应,如果所选机制使用该机制的话。</target>
        </trans-unit>
        <trans-unit id="229cec88eb4f3eac7279336f40b13a71ae9b84dd" translate="yes" xml:space="preserve">
          <source>The client sends an Execute message with a non-zero fetch count. See the discussion of the &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY&quot;&gt;extended query protocol&lt;/a&gt;. Since &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq.html&quot;&gt;libpq&lt;/a&gt; currently provides no way to send such a message, this can only occur when using a client that does not rely on libpq. If this is a frequent occurrence, it may be a good idea to set &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-PER-GATHER&quot;&gt;max_parallel_workers_per_gather&lt;/a&gt; to zero in sessions where it is likely, so as to avoid generating query plans that may be suboptimal when run serially.</source>
          <target state="translated">客户端发送的执行消息的读取计数非零。请参阅&lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY&quot;&gt;扩展查询协议&lt;/a&gt;的讨论。由于&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq.html&quot;&gt;libpq&lt;/a&gt;当前不提供发送此类消息的方法，因此只有在使用不依赖libpq的客户端时，才会发生这种情况。如果这是经常发生的情况，则最好在可能的会话中将&lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-PER-GATHER&quot;&gt;max_parallel_workers_per_gather&lt;/a&gt;设置为零，以免生成在串行运行时可能次优的查询计划。</target>
        </trans-unit>
        <trans-unit id="b4c35b44809114c2fabb0bca78243a5e0e3a582e" translate="yes" xml:space="preserve">
          <source>The client sends an Execute message with a non-zero fetch count. See the discussion of the &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY&quot;&gt;extended query protocol&lt;/a&gt;. Since &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq.html&quot;&gt;libpq&lt;/a&gt; currently provides no way to send such a message, this can only occur when using a client that does not rely on libpq. If this is a frequent occurrence, it may be a good idea to set &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-PER-GATHER&quot;&gt;max_parallel_workers_per_gather&lt;/a&gt; to zero in sessions where it is likely, so as to avoid generating query plans that may be suboptimal when run serially.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c8bc9da59ada6925c6ca4e1408b3caa10a534cd" translate="yes" xml:space="preserve">
          <source>The code block is treated as though it were the body of a function with no parameters, returning &lt;code&gt;void&lt;/code&gt;. It is parsed and executed a single time.</source>
          <target state="translated">将代码块视为没有参数的函数的主体，并返回 &lt;code&gt;void&lt;/code&gt; 。它被解析并执行一次。</target>
        </trans-unit>
        <trans-unit id="312278044badf1f81c35c2b663c752edaa662f24" translate="yes" xml:space="preserve">
          <source>The collation assigned to a function or operator's combined input expressions is also considered to apply to the function or operator's result, if the function or operator delivers a result of a collatable data type. So, in</source>
          <target state="translated">如果函数或运算符提供了一个可整理数据类型的结果,那么分配给函数或运算符的组合输入表达式的整理也被认为适用于函数或运算符的结果。因此,在</target>
        </trans-unit>
        <trans-unit id="07ad042e8eb9598587dcbb36503b3ffb45fa7270" translate="yes" xml:space="preserve">
          <source>The collation feature allows specifying the sort order and character classification behavior of data per-column, or even per-operation. This alleviates the restriction that the &lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt; settings of a database cannot be changed after its creation.</source>
          <target state="translated">归类功能允许按列甚至按操作指定数据的排序顺序和字符分类行为。这减轻了数据库创建后不能更改 &lt;code&gt;LC_COLLATE&lt;/code&gt; 和 &lt;code&gt;LC_CTYPE&lt;/code&gt; 设置的限制。</target>
        </trans-unit>
        <trans-unit id="6968224c63a84f2b924666a708e6eefcbe1a5fe3" translate="yes" xml:space="preserve">
          <source>The collation of an expression can be the &amp;ldquo;default&amp;rdquo; collation, which means the locale settings defined for the database. It is also possible for an expression's collation to be indeterminate. In such cases, ordering operations and other operations that need to know the collation will fail.</source>
          <target state="translated">表达式的排序规则可以是&amp;ldquo;默认&amp;rdquo;排序规则，这表示为数据库定义的语言环境设置。表达式的排序规则也可能不确定。在这种情况下，需要知道排序规则的订购操作和其他操作将失败。</target>
        </trans-unit>
        <trans-unit id="8cbb0497a2d0489a87ba349c1f09ee8dec4f3fd5" translate="yes" xml:space="preserve">
          <source>The collation used to derive the statistics stored in the &lt;code&gt;N&lt;/code&gt;th &amp;ldquo;slot&amp;rdquo;. For example, a histogram slot for a collatable column would show the collation that defines the sort order of the data. Zero for noncollatable data.</source>
          <target state="translated">排序规则用于导出存储在第 &lt;code&gt;N&lt;/code&gt; 个&amp;ldquo;插槽&amp;rdquo;中的统计信息。例如，可排序列的直方图槽将显示定义数据排序顺序的排序规则。对于非可整理数据，为零。</target>
        </trans-unit>
        <trans-unit id="b4385bb7e15544b6f2f8d39c7296d888e4a8a5d9" translate="yes" xml:space="preserve">
          <source>The colon (&lt;code&gt;:&lt;/code&gt;) is used to select &amp;ldquo;slices&amp;rdquo; from arrays. (See &lt;a href=&quot;arrays&quot;&gt;Section 8.15&lt;/a&gt;.) In certain SQL dialects (such as Embedded SQL), the colon is used to prefix variable names.</source>
          <target state="translated">冒号（ &lt;code&gt;:&lt;/code&gt; ）用于选择来自阵列&amp;ldquo;片&amp;rdquo;。（请参见&lt;a href=&quot;arrays&quot;&gt;第8.15节&lt;/a&gt;。）在某些SQL方言（例如Embedded SQL）中，冒号用于为变量名添加前缀。</target>
        </trans-unit>
        <trans-unit id="b41c26c54c1ac62b21f77b8fd62d5d3012b96e24" translate="yes" xml:space="preserve">
          <source>The colon syntax for variables is standard SQL for embedded query languages, such as ECPG. The colon syntaxes for array slices and type casts are PostgreSQL extensions, which can sometimes conflict with the standard usage. The colon-quote syntax for escaping a variable's value as an SQL literal or identifier is a psql extension.</source>
          <target state="translated">变量的冒号语法是嵌入式查询语言的标准SQL,如ECPG。数组切片和类型转换的冒号语法是PostgreSQL的扩展,有时会与标准用法相冲突。用于将变量的值转义为SQL文字或标识符的冒号引号语法是psql扩展。</target>
        </trans-unit>
        <trans-unit id="d094304df5c5c2f3f002a3a5f2b5b0282e855c32" translate="yes" xml:space="preserve">
          <source>The column data type that this operator class is for.</source>
          <target state="translated">该操作类的列数据类型。</target>
        </trans-unit>
        <trans-unit id="5a6fb4ccabc2a7663f993c4ebb4c744ff2affbac" translate="yes" xml:space="preserve">
          <source>The column default value, in &lt;code&gt;nodeToString()&lt;/code&gt; representation. Use &lt;code&gt;pg_get_expr(adbin, adrelid)&lt;/code&gt; to convert it to an SQL expression.</source>
          <target state="translated">列的默认值，以 &lt;code&gt;nodeToString()&lt;/code&gt; 表示形式。使用 &lt;code&gt;pg_get_expr(adbin, adrelid)&lt;/code&gt; 将其转换为SQL表达式。</target>
        </trans-unit>
        <trans-unit id="08368fd428556014aaea42a5338ea6c2743ad445" translate="yes" xml:space="preserve">
          <source>The column is allowed to contain null values. This is the default.</source>
          <target state="translated">该列允许包含空值。这是默认值。</target>
        </trans-unit>
        <trans-unit id="5bb55967abb94c1ccc24a2441d33dbf806399e61" translate="yes" xml:space="preserve">
          <source>The column is not allowed to contain null values.</source>
          <target state="translated">该列不允许包含空值。</target>
        </trans-unit>
        <trans-unit id="8420d2c88df44919ff7832e5423eccf9e0e7b65d" translate="yes" xml:space="preserve">
          <source>The column name</source>
          <target state="translated">栏目名称</target>
        </trans-unit>
        <trans-unit id="d9ec3849dbdc73ff83e6e2b53f90a20a6fb0948f" translate="yes" xml:space="preserve">
          <source>The column source table(s) must be &lt;code&gt;INNER&lt;/code&gt; or &lt;code&gt;LEFT&lt;/code&gt; joined to the &lt;code&gt;LATERAL&lt;/code&gt; item, else there would not be a well-defined set of rows from which to compute each set of rows for the &lt;code&gt;LATERAL&lt;/code&gt; item. Thus, although a construct such as &lt;code&gt;X RIGHT JOIN LATERAL Y&lt;/code&gt; is syntactically valid, it is not actually allowed for &lt;code&gt;Y&lt;/code&gt; to reference &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">列源表必须是 &lt;code&gt;INNER&lt;/code&gt; 或 &lt;code&gt;LEFT&lt;/code&gt; 联接到 &lt;code&gt;LATERAL&lt;/code&gt; 项，否则将没有定义明确的行集，可从中计算出 &lt;code&gt;LATERAL&lt;/code&gt; 项的每组行。因此，虽然一个构建体如 &lt;code&gt;X RIGHT JOIN LATERAL Y&lt;/code&gt; 是语法上有效，但并不实际允许对 &lt;code&gt;Y&lt;/code&gt; 到参考 &lt;code&gt;X&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e991f9b83115d7ba9de797ba7c6fd7f9b86d5e91" translate="yes" xml:space="preserve">
          <source>The columns names &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt; are either the actual names of the columns of tables referenced in the &lt;code&gt;FROM&lt;/code&gt; clause, or the aliases given to them as explained in &lt;a href=&quot;queries-table-expressions#QUERIES-TABLE-ALIASES&quot;&gt;Section 7.2.1.2&lt;/a&gt;. The name space available in the select list is the same as in the &lt;code&gt;WHERE&lt;/code&gt; clause, unless grouping is used, in which case it is the same as in the &lt;code&gt;HAVING&lt;/code&gt; clause.</source>
          <target state="translated">列名 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 要么是 &lt;code&gt;FROM&lt;/code&gt; 子句中引用的表的列的实际名称，要么是&lt;a href=&quot;queries-table-expressions#QUERIES-TABLE-ALIASES&quot;&gt;第7.2.1.2节中&lt;/a&gt;说明的为其赋予的别名。选择列表中可用的名称空间与 &lt;code&gt;WHERE&lt;/code&gt; 子句中的名称空间相同，除非使用了分组，在这种情况下，它与 &lt;code&gt;HAVING&lt;/code&gt; 子句中的名称空间相同。</target>
        </trans-unit>
        <trans-unit id="4599d6eec1312706887ef09d2464d5545c627474" translate="yes" xml:space="preserve">
          <source>The combination of the return value of this function with the certificate serial number uniquely identifies the certificate.</source>
          <target state="translated">此函数的返回值与证书序列号的组合可以唯一地识别证书。</target>
        </trans-unit>
        <trans-unit id="062e4ea98a9662fe6dca5fb34a40a037aa606eb5" translate="yes" xml:space="preserve">
          <source>The command</source>
          <target state="translated">命令</target>
        </trans-unit>
        <trans-unit id="fd4ecf316bcb95382c9ca99fb6834b4e0a4db40c" translate="yes" xml:space="preserve">
          <source>The command &lt;a href=&quot;sql-createcollation&quot;&gt;CREATE COLLATION&lt;/a&gt; can also be used to create a new collation from an existing collation, which can be useful to be able to use operating-system-independent collation names in applications, create compatibility names, or use an ICU-provided collation under a more readable name. For example:</source>
          <target state="translated">命令&lt;a href=&quot;sql-createcollation&quot;&gt;CREATE COLLATION&lt;/a&gt;也可用于从现有排序规则创建新的排序规则，这对于在应用程序中使用独立于操作系统的排序规则名称，创建兼容性名称或在ICU下使用ICU提供的排序规则很有用。更易读的名称。例如：</target>
        </trans-unit>
        <trans-unit id="d977c35dcae77bd0de806a55a77621ba14612b62" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;ALTER PUBLICATION&lt;/code&gt; can change the attributes of a publication.</source>
          <target state="translated">命令 &lt;code&gt;ALTER PUBLICATION&lt;/code&gt; 可以更改发布的属性。</target>
        </trans-unit>
        <trans-unit id="969778663757608a9ceb272b57ae37cfa06e3dd9" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;COMMIT&lt;/code&gt; conforms to the SQL standard. The form &lt;code&gt;COMMIT TRANSACTION&lt;/code&gt; is a PostgreSQL extension.</source>
          <target state="translated">命令 &lt;code&gt;COMMIT&lt;/code&gt; 符合SQL标准。形式 &lt;code&gt;COMMIT TRANSACTION&lt;/code&gt; 是PostgreSQL扩展。</target>
        </trans-unit>
        <trans-unit id="dbf0fa331f942a39e4739f4ed15c74b619e12d1b" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;CREATE DOMAIN&lt;/code&gt; conforms to the SQL standard.</source>
          <target state="translated">命令 &lt;code&gt;CREATE DOMAIN&lt;/code&gt; 符合SQL标准。</target>
        </trans-unit>
        <trans-unit id="c0e7572b18c65a9a6261e55f6991fd2f67f9ff3c" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;LOCK TABLE a, b;&lt;/code&gt; is equivalent to &lt;code&gt;LOCK TABLE a; LOCK TABLE b;&lt;/code&gt;. The tables are locked one-by-one in the order specified in the &lt;code&gt;LOCK TABLE&lt;/code&gt; command.</source>
          <target state="translated">命令 &lt;code&gt;LOCK TABLE a, b;&lt;/code&gt; 等效于 &lt;code&gt;LOCK TABLE a; LOCK TABLE b;&lt;/code&gt; 。这些表按照 &lt;code&gt;LOCK TABLE&lt;/code&gt; 命令中指定的顺序被一一锁定。</target>
        </trans-unit>
        <trans-unit id="bd29caedfd38b09e6ed21c78963ca39d6d0fdf15" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;ROLLBACK&lt;/code&gt; conforms to the SQL standard. The form &lt;code&gt;ROLLBACK TRANSACTION&lt;/code&gt; is a PostgreSQL extension.</source>
          <target state="translated">命令 &lt;code&gt;ROLLBACK&lt;/code&gt; 符合SQL标准。 &lt;code&gt;ROLLBACK TRANSACTION&lt;/code&gt; 的形式是PostgreSQL扩展。</target>
        </trans-unit>
        <trans-unit id="14f45c2838c91f3d088f1dbeb531759099cc9619" translate="yes" xml:space="preserve">
          <source>The command does not actually have to prompt the user for a passphrase. It can read it from a file, obtain it from a keychain facility, or similar. It is up to the user to make sure the chosen mechanism is adequately secure.</source>
          <target state="translated">该命令实际上不需要提示用户输入密码,它可以从文件中读取密码,也可以从钥匙链设施或类似设施中获取密码。它可以从文件中读取密码,也可以从钥匙链设施中获取密码,或者类似的方法。用户要确保所选择的机制是足够安全的。</target>
        </trans-unit>
        <trans-unit id="125f23e3bb7186ab7a646a52cf5bf9eca19bcc45" translate="yes" xml:space="preserve">
          <source>The command form &lt;code&gt;\d+&lt;/code&gt; is identical, except that more information is displayed: any comments associated with the columns of the table are shown, as is the presence of OIDs in the table, the view definition if the relation is a view, a non-default &lt;a href=&quot;sql-altertable#SQL-CREATETABLE-REPLICA-IDENTITY&quot;&gt;replica identity&lt;/a&gt; setting.</source>
          <target state="translated">命令格式 &lt;code&gt;\d+&lt;/code&gt; 相同，除了显示更多信息：显示与表的列关联的所有注释，表中是否存在OID，如果关系是视图，则为视图定义，否则为-默认&lt;a href=&quot;sql-altertable#SQL-CREATETABLE-REPLICA-IDENTITY&quot;&gt;副本身份&lt;/a&gt;设置。</target>
        </trans-unit>
        <trans-unit id="0916bd8daa5b51f8834876be91b7f972c2fe0c9c" translate="yes" xml:space="preserve">
          <source>The command identifier (starting at zero) within the inserting transaction.</source>
          <target state="translated">插入交易中的命令标识符(从零开始)。</target>
        </trans-unit>
        <trans-unit id="d1364d07c5f1725771640b150e94c42c6a8b2515" translate="yes" xml:space="preserve">
          <source>The command identifier within the deleting transaction, or zero.</source>
          <target state="translated">删除交易中的命令标识符,或为零。</target>
        </trans-unit>
        <trans-unit id="1437750e20fa527029f8f074bcd579b652d1fc5a" translate="yes" xml:space="preserve">
          <source>The command is computing extended statistics from the sample rows obtained during the table scan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="733186417b69bd6a5c32f04973634c419eb62936" translate="yes" xml:space="preserve">
          <source>The command is computing statistics from the sample rows obtained during the table scan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d0382226380f9ead190eb302a73c778dbdd6e8d" translate="yes" xml:space="preserve">
          <source>The command is currently rebuilding an index.</source>
          <target state="translated">该命令目前正在重建一个索引。</target>
        </trans-unit>
        <trans-unit id="08589d87d0f9a78f65af3716f713118502dde96d" translate="yes" xml:space="preserve">
          <source>The command is currently scanning child tables to obtain sample rows. Columns &lt;code&gt;child_tables_total&lt;/code&gt;, &lt;code&gt;child_tables_done&lt;/code&gt;, and &lt;code&gt;current_child_table_relid&lt;/code&gt; contain the progress information for this phase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="818a6c346e272bdd257338212ea062e5d982098f" translate="yes" xml:space="preserve">
          <source>The command is currently scanning the table given by &lt;code&gt;relid&lt;/code&gt; to obtain sample rows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf18e6a22964c8d441f27d38a4a845cd36e9d7a8" translate="yes" xml:space="preserve">
          <source>The command is currently scanning the table using a sequential scan.</source>
          <target state="translated">该命令目前采用顺序扫描的方式对表进行扫描。</target>
        </trans-unit>
        <trans-unit id="2d997222e2d809bc7ed01be5d82f30faa7501100" translate="yes" xml:space="preserve">
          <source>The command is currently swapping newly-built files into place.</source>
          <target state="translated">目前,该命令正在将新建的文件交换到位。</target>
        </trans-unit>
        <trans-unit id="d36048945358a61f078040109a39866ba3017fd5" translate="yes" xml:space="preserve">
          <source>The command is performing final cleanup. When this phase is completed, &lt;code&gt;CLUSTER&lt;/code&gt; or &lt;code&gt;VACUUM FULL&lt;/code&gt; will end.</source>
          <target state="translated">该命令正在执行最终清理。完成此阶段后， &lt;code&gt;CLUSTER&lt;/code&gt; 或 &lt;code&gt;VACUUM FULL&lt;/code&gt; 将结束。</target>
        </trans-unit>
        <trans-unit id="b779f0c2e033575cc8fc0dc14c755c01561f9ff6" translate="yes" xml:space="preserve">
          <source>The command is preparing to begin scanning the heap. This phase is expected to be very brief.</source>
          <target state="translated">指挥部正准备开始扫描堆。预计这一阶段将非常短暂。</target>
        </trans-unit>
        <trans-unit id="68b75bc58da613bc57b4a395ff1c9dc327e8f607" translate="yes" xml:space="preserve">
          <source>The command is updating &lt;code&gt;pg_class&lt;/code&gt;. When this phase is completed, &lt;code&gt;ANALYZE&lt;/code&gt; will end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00faacb1d010fe63608a96c43ef3a7084a48b136" translate="yes" xml:space="preserve">
          <source>The command must print the passphrase to the standard output and exit with code 0. In the parameter value, &lt;code&gt;%p&lt;/code&gt; is replaced by a prompt string. (Write &lt;code&gt;%%&lt;/code&gt; for a literal &lt;code&gt;%&lt;/code&gt;.) Note that the prompt string will probably contain whitespace, so be sure to quote adequately. A single newline is stripped from the end of the output if present.</source>
          <target state="translated">该命令必须将密码短语打印到标准输出，并以代码0退出。在参数值中， &lt;code&gt;%p&lt;/code&gt; 将替换为提示字符串。（将 &lt;code&gt;%%&lt;/code&gt; 写入文字 &lt;code&gt;%&lt;/code&gt; 。）请注意，提示字符串可能包含空格，因此请务必使用足够的引号。如果存在，将从输出的末尾除去一条换行符。</target>
        </trans-unit>
        <trans-unit id="c98b53eebf8fcd4fa5340e65c4d477e99fd91e81" translate="yes" xml:space="preserve">
          <source>The command or commands that make up the rule action. Valid commands are &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, or &lt;code&gt;NOTIFY&lt;/code&gt;.</source>
          <target state="translated">组成规则操作的一个或多个命令。有效命令为 &lt;code&gt;SELECT&lt;/code&gt; ， &lt;code&gt;INSERT&lt;/code&gt; ， &lt;code&gt;UPDATE&lt;/code&gt; ， &lt;code&gt;DELETE&lt;/code&gt; 或 &lt;code&gt;NOTIFY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f5e5a53841d0cfd1aacf0accff8cefa2f5212ac" translate="yes" xml:space="preserve">
          <source>The command tag returned by &lt;code&gt;EXECUTE&lt;/code&gt; is that of the prepared statement, and not &lt;code&gt;EXECUTE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;EXECUTE&lt;/code&gt; 返回的命令标记是预处理语句的命令标记，而不是 &lt;code&gt;EXECUTE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74ac6ad09ab58057a9fed1f64a26a788f3d3e326" translate="yes" xml:space="preserve">
          <source>The command that is running. Either &lt;code&gt;CLUSTER&lt;/code&gt; or &lt;code&gt;VACUUM FULL&lt;/code&gt;.</source>
          <target state="translated">正在运行的命令。无论是 &lt;code&gt;CLUSTER&lt;/code&gt; 或 &lt;code&gt;VACUUM FULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9850fa889a0eec791cad23100b9e331cd2aa4fc" translate="yes" xml:space="preserve">
          <source>The command that is running: &lt;code&gt;CREATE INDEX&lt;/code&gt;, &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt;, &lt;code&gt;REINDEX&lt;/code&gt;, or &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt;.</source>
          <target state="translated">正在运行的命令： &lt;code&gt;CREATE INDEX&lt;/code&gt; ， &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt; ， &lt;code&gt;REINDEX&lt;/code&gt; 或 &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="559d421f3432d35c3d9a8fb5131571d6eb8752e8" translate="yes" xml:space="preserve">
          <source>The command to which the policy applies. Valid options are &lt;code&gt;ALL&lt;/code&gt;, &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt;. &lt;code&gt;ALL&lt;/code&gt; is the default. See below for specifics regarding how these are applied.</source>
          <target state="translated">策略适用的命令。有效选项为 &lt;code&gt;ALL&lt;/code&gt; ， &lt;code&gt;SELECT&lt;/code&gt; ， &lt;code&gt;INSERT&lt;/code&gt; ， &lt;code&gt;UPDATE&lt;/code&gt; 和 &lt;code&gt;DELETE&lt;/code&gt; 。 &lt;code&gt;ALL&lt;/code&gt; 是默认值。有关如何应用这些内容的详细信息，请参见下文。</target>
        </trans-unit>
        <trans-unit id="7852202b8a6003f108d83f18dfb4650d44b65813" translate="yes" xml:space="preserve">
          <source>The command type to which the policy is applied</source>
          <target state="translated">应用策略的命令类型</target>
        </trans-unit>
        <trans-unit id="6c49af8969ccfcd1693376760717e08595698aa9" translate="yes" xml:space="preserve">
          <source>The command type to which the policy is applied: &lt;code&gt;r&lt;/code&gt; for &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; for &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt; for &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;d&lt;/code&gt; for &lt;code&gt;DELETE&lt;/code&gt;, or &lt;code&gt;*&lt;/code&gt; for all</source>
          <target state="translated">应用该策略的命令类型： &lt;code&gt;r&lt;/code&gt; 表示 &lt;code&gt;SELECT&lt;/code&gt; ， &lt;code&gt;a&lt;/code&gt; 表示 &lt;code&gt;INSERT&lt;/code&gt; ， &lt;code&gt;w&lt;/code&gt; 表示 &lt;code&gt;UPDATE&lt;/code&gt; ， &lt;code&gt;d&lt;/code&gt; 表示 &lt;code&gt;DELETE&lt;/code&gt; ，或 &lt;code&gt;*&lt;/code&gt; 表示全部</target>
        </trans-unit>
        <trans-unit id="31a55b9a99200f37a1fc91d5f4fc188806cc57ad" translate="yes" xml:space="preserve">
          <source>The command's result is a textual description of the plan selected for the &lt;code&gt;statement&lt;/code&gt;, optionally annotated with execution statistics. &lt;a href=&quot;using-explain&quot;&gt;Section 14.1&lt;/a&gt; describes the information provided.</source>
          <target state="translated">该命令的结果是为该 &lt;code&gt;statement&lt;/code&gt; 选择的计划的文字描述，可以选择在其上加上执行统计信息。&lt;a href=&quot;using-explain&quot;&gt;第14.1节&lt;/a&gt;介绍了所提供的信息。</target>
        </trans-unit>
        <trans-unit id="40e0a2632f98d43624e2ba898ef7cc5bdd1cf8c1" translate="yes" xml:space="preserve">
          <source>The command-line history is stored in the file &lt;code&gt;~/.psql_history&lt;/code&gt;, or &lt;code&gt;%APPDATA%\postgresql\psql_history&lt;/code&gt; on Windows.</source>
          <target state="translated">命令行历史记录存储在文件 &lt;code&gt;~/.psql_history&lt;/code&gt; 或Windows上的 &lt;code&gt;%APPDATA%\postgresql\psql_history&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="f9e42c3efb15d8e677dc2308149404249d782207" translate="yes" xml:space="preserve">
          <source>The command-line-style arguments specified in &lt;code&gt;extra-options&lt;/code&gt; are passed to all server processes started by this &lt;code&gt;postgres&lt;/code&gt; process.</source>
          <target state="translated">在 &lt;code&gt;extra-options&lt;/code&gt; 中指定的命令行样式参数将传递给此 &lt;code&gt;postgres&lt;/code&gt; 进程启动的所有服务器进程。</target>
        </trans-unit>
        <trans-unit id="360d0f8394d720d22156d27a3f3ab0d50f8729e3" translate="yes" xml:space="preserve">
          <source>The commands &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, and &lt;code&gt;INSERT&lt;/code&gt; acquire this lock mode on the target table (in addition to &lt;code&gt;ACCESS SHARE&lt;/code&gt; locks on any other referenced tables). In general, this lock mode will be acquired by any command that &lt;em&gt;modifies data&lt;/em&gt; in a table.</source>
          <target state="translated">命令 &lt;code&gt;UPDATE&lt;/code&gt; ， &lt;code&gt;DELETE&lt;/code&gt; 和 &lt;code&gt;INSERT&lt;/code&gt; 在目标表上获取此锁定方式（除了对任何其他引用表的 &lt;code&gt;ACCESS SHARE&lt;/code&gt; 锁定外）。通常，此锁定模式将由任何&lt;em&gt;修改&lt;/em&gt;表中&lt;em&gt;数据的&lt;/em&gt;命令获取。</target>
        </trans-unit>
        <trans-unit id="b120614b8a1edecdcf4c676c85b59acab98338cc" translate="yes" xml:space="preserve">
          <source>The commutator of this operator.</source>
          <target state="translated">这个算子的换算器。</target>
        </trans-unit>
        <trans-unit id="f6803da73417ed20d6aa993c5529f00237b3f6a3" translate="yes" xml:space="preserve">
          <source>The compatibility notes of the &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; command apply analogously to &lt;code&gt;REVOKE&lt;/code&gt;. The keyword &lt;code&gt;RESTRICT&lt;/code&gt; or &lt;code&gt;CASCADE&lt;/code&gt; is required according to the standard, but PostgreSQL assumes &lt;code&gt;RESTRICT&lt;/code&gt; by default.</source>
          <target state="translated">&lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt;命令的兼容性说明类似地适用于 &lt;code&gt;REVOKE&lt;/code&gt; 。根据标准，关键字 &lt;code&gt;RESTRICT&lt;/code&gt; 或 &lt;code&gt;CASCADE&lt;/code&gt; 是必需的，但是PostgreSQL 默认采用 &lt;code&gt;RESTRICT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="40702de9ee6c2366268d72254909613dec0511c4" translate="yes" xml:space="preserve">
          <source>The complete lack of these facilities is usually manifested by an &amp;ldquo;Illegal system call&amp;rdquo; error upon server start. In that case there is no alternative but to reconfigure your kernel. PostgreSQL won't work without them. This situation is rare, however, among modern operating systems.</source>
          <target state="translated">这些功能的完全缺乏通常通过服务器启动时出现&amp;ldquo;非法系统调用&amp;rdquo;错误来表明。在这种情况下，别无选择，只能重新配置内核。没有它们，PostgreSQL将无法工作。但是，这种情况在现代操作系统中很少见。</target>
        </trans-unit>
        <trans-unit id="8728921721ecf34d843d2d7d08bdc9c0ecc2f84b" translate="yes" xml:space="preserve">
          <source>The composite output routine will put double quotes around field values if they are empty strings or contain parentheses, commas, double quotes, backslashes, or white space. (Doing so for white space is not essential, but aids legibility.) Double quotes and backslashes embedded in field values will be doubled.</source>
          <target state="translated">如果字段值是空字符串或包含括号、逗号、双引号、反斜杠或空白,复合输出例程将在字段值周围加上双引号。(对于空白,这样做不是必要的,但有助于阅读)。(这样做对空白处不是必要的,但有助于提高可读性。)嵌入在字段值中的双引号和反斜杠将被加倍。</target>
        </trans-unit>
        <trans-unit id="7b5e42f8ee02c00c89066a781bb2783e80203625" translate="yes" xml:space="preserve">
          <source>The compression technique used for either in-line or out-of-line compressed data is a fairly simple and very fast member of the LZ family of compression techniques. See &lt;code&gt;src/common/pg_lzcompress.c&lt;/code&gt; for the details.</source>
          <target state="translated">用于行内或行外压缩数据的压缩技术是LZ系列压缩技术中相当简单且非常快速的成员。有关详细信息，请参见 &lt;code&gt;src/common/pg_lzcompress.c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74936e59660e5e1e74d04f83302b0b914fcee784" translate="yes" xml:space="preserve">
          <source>The concatenation operator allows a single element to be pushed onto the beginning or end of a one-dimensional array. It also accepts two &lt;code&gt;N&lt;/code&gt;-dimensional arrays, or an &lt;code&gt;N&lt;/code&gt;-dimensional and an &lt;code&gt;N+1&lt;/code&gt;-dimensional array.</source>
          <target state="translated">串联运算符允许将单个元素推到一维数组的开头或结尾。它还接受两个 &lt;code&gt;N&lt;/code&gt; 维阵列，或 &lt;code&gt;N&lt;/code&gt; 维和 &lt;code&gt;N+1&lt;/code&gt; 维阵列。</target>
        </trans-unit>
        <trans-unit id="4e300a4f5e6f2c02a48d5242548de8a6b349eea4" translate="yes" xml:space="preserve">
          <source>The concept that multiple independent operations happen within the &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; at the same time. In PostgreSQL, concurrency is controlled by the &lt;a href=&quot;glossary#GLOSSARY-MVCC&quot;&gt;multiversion concurrency control&lt;/a&gt; mechanism.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5239ff4b58c91e7e13723e3163e22ecae35f6c6f" translate="yes" xml:space="preserve">
          <source>The condition &lt;code&gt;t1.hundred &amp;lt; t2.hundred&lt;/code&gt; can't be tested in the &lt;code&gt;tenk2_unique2&lt;/code&gt; index, so it's applied at the join node. This reduces the estimated output row count of the join node, but does not change either input scan.</source>
          <target state="translated">无法在 &lt;code&gt;tenk2_unique2&lt;/code&gt; 索引中测试条件 &lt;code&gt;t1.hundred &amp;lt; t2.hundred&lt;/code&gt; ，因此将其应用于连接节点。这样可以减少连接节点的估计输出行数，但不会更改任何输入扫描。</target>
        </trans-unit>
        <trans-unit id="c068c3abe0f845f75d348f1e71b7501c9e85d719" translate="yes" xml:space="preserve">
          <source>The configuration file is reread whenever the main server process receives a SIGHUP signal; this signal is most easily sent by running &lt;code&gt;pg_ctl reload&lt;/code&gt; from the command line or by calling the SQL function &lt;code&gt;pg_reload_conf()&lt;/code&gt;. The main server process also propagates this signal to all currently running server processes, so that existing sessions also adopt the new values (this will happen after they complete any currently-executing client command). Alternatively, you can send the signal to a single server process directly. Some parameters can only be set at server start; any changes to their entries in the configuration file will be ignored until the server is restarted. Invalid parameter settings in the configuration file are likewise ignored (but logged) during SIGHUP processing.</source>
          <target state="translated">每当主服务器进程接收到SIGHUP信号时，都会重新读取配置文件。通过从命令行运行 &lt;code&gt;pg_ctl reload&lt;/code&gt; 或调用SQL函数 &lt;code&gt;pg_reload_conf()&lt;/code&gt; ,最容易发送此信号。主服务器进程还将此信号传播到所有当前正在运行的服务器进程，以便现有会话也采用新值（这将在它们完成任何当前正在执行的客户端命令之后发生）。或者，您可以将信号直接发送到单个服务器进程。某些参数只能在服务器启动时设置。在重新启动服务器之前，将忽略对配置文件中条目的任何更改。在SIGHUP处理期间，同样会忽略（但会记录）配置文件中无效的参数设置。</target>
        </trans-unit>
        <trans-unit id="b9dccd142849bf4c5f5639f61a51dab8e56e5d09" translate="yes" xml:space="preserve">
          <source>The configuration variable &lt;a href=&quot;runtime-config-query#GUC-JIT&quot;&gt;jit&lt;/a&gt; determines whether JIT compilation is enabled or disabled. If it is enabled, the configuration variables &lt;a href=&quot;runtime-config-query#GUC-JIT-ABOVE-COST&quot;&gt;jit_above_cost&lt;/a&gt;, &lt;a href=&quot;runtime-config-query#GUC-JIT-INLINE-ABOVE-COST&quot;&gt;jit_inline_above_cost&lt;/a&gt;, and &lt;a href=&quot;runtime-config-query#GUC-JIT-OPTIMIZE-ABOVE-COST&quot;&gt;jit_optimize_above_cost&lt;/a&gt; determine whether JIT compilation is performed for a query, and how much effort is spent doing so.</source>
          <target state="translated">配置变量&lt;a href=&quot;runtime-config-query#GUC-JIT&quot;&gt;jit&lt;/a&gt;确定是启用还是禁用JIT编译。如果已启用，则配置变量&lt;a href=&quot;runtime-config-query#GUC-JIT-ABOVE-COST&quot;&gt;jit_above_cost&lt;/a&gt;，&lt;a href=&quot;runtime-config-query#GUC-JIT-INLINE-ABOVE-COST&quot;&gt;jit_inline_above_cost&lt;/a&gt;和&lt;a href=&quot;runtime-config-query#GUC-JIT-OPTIMIZE-ABOVE-COST&quot;&gt;jit_optimize_above_cost&lt;/a&gt;决定是否对查询执行JIT编译，以及花费了多少精力。</target>
        </trans-unit>
        <trans-unit id="19797f9713f4025f6738d996f66f2f16f1bb3ee3" translate="yes" xml:space="preserve">
          <source>The connection must be to the same database used to create the slot.</source>
          <target state="translated">该连接必须与用于创建插槽的数据库相同。</target>
        </trans-unit>
        <trans-unit id="cbc80489eb4bf174c233f6bbbaa42452b7d3d86f" translate="yes" xml:space="preserve">
          <source>The connection string should specify the host name (or address) of the sending server, as well as the port number if it is not the same as the standby server's default. Also specify a user name corresponding to a suitably-privileged role on the sending server (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-AUTHENTICATION&quot;&gt;Section 26.2.5.1&lt;/a&gt;). A password needs to be provided too, if the sender demands password authentication. It can be provided in the &lt;code&gt;primary_conninfo&lt;/code&gt; string, or in a separate &lt;code&gt;~/.pgpass&lt;/code&gt; file on the standby server (use &lt;code&gt;replication&lt;/code&gt; as the database name). Do not specify a database name in the &lt;code&gt;primary_conninfo&lt;/code&gt; string.</source>
          <target state="translated">连接字符串应指定发送服务器的主机名（或地址），以及端口号（如果它与备用服务器的默认名称不同）。还指定与发送服务器上适当特权角色相对应的用户名（请参见&lt;a href=&quot;warm-standby#STREAMING-REPLICATION-AUTHENTICATION&quot;&gt;26.2.5.1节&lt;/a&gt;）。如果发件人要求密码验证，则还需要提供密码。它可以在 &lt;code&gt;primary_conninfo&lt;/code&gt; 字符串中提供，也可以在备用服务器上的单独 &lt;code&gt;~/.pgpass&lt;/code&gt; 文件中提供（使用 &lt;code&gt;replication&lt;/code&gt; 作为数据库名称）。不要在 &lt;code&gt;primary_conninfo&lt;/code&gt; 字符串中指定数据库名称。</target>
        </trans-unit>
        <trans-unit id="31fcb6829f600da0b565f01362ffaf255feb5d94" translate="yes" xml:space="preserve">
          <source>The connection string to the publisher. For details see &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;Section 33.1.1&lt;/a&gt;.</source>
          <target state="translated">与发布者的连接字符串。有关详细信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;第33.1.1节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3910ec7c4e89817bfb9d10225155392dd277cac9" translate="yes" xml:space="preserve">
          <source>The connection string to the publisher. For details see &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;Section 33.1.1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="164c7293cd6f4e265338f6fb352f7b98d06266a8" translate="yes" xml:space="preserve">
          <source>The constraint expression for a partial index.</source>
          <target state="translated">部分索引的约束表达式。</target>
        </trans-unit>
        <trans-unit id="0a023003d324d129028d83c645a2d4429045b67a" translate="yes" xml:space="preserve">
          <source>The constraint will be checked immediately, so the table data must satisfy the constraint before it can be added.</source>
          <target state="translated">该约束将被立即检查,所以表数据必须满足该约束才能添加。</target>
        </trans-unit>
        <trans-unit id="f753df8000fdee9203aa2be3a2862eb377d770ad" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;(a, b)&lt;/code&gt; is normally recognized in expressions as a &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;row constructor&lt;/a&gt;. Within the &lt;code&gt;GROUP BY&lt;/code&gt; clause, this does not apply at the top levels of expressions, and &lt;code&gt;(a, b)&lt;/code&gt; is parsed as a list of expressions as described above. If for some reason you &lt;em&gt;need&lt;/em&gt; a row constructor in a grouping expression, use &lt;code&gt;ROW(a, b)&lt;/code&gt;.</source>
          <target state="translated">构造 &lt;code&gt;(a, b)&lt;/code&gt; 通常在表达式中识别为&lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;行构造器&lt;/a&gt;。在 &lt;code&gt;GROUP BY&lt;/code&gt; 子句中，这不适用于表达式的最高级别，并且如上所述，将 &lt;code&gt;(a, b)&lt;/code&gt; 解析为表达式列表。如果出于某种原因在分组表达式中&lt;em&gt;需要&lt;/em&gt;行构造函数，请使用 &lt;code&gt;ROW(a, b)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bdace32fdb5c0027816e247b4bd1b7fb7ff95259" translate="yes" xml:space="preserve">
          <source>The contents of tables and indexes are discussed further in &lt;a href=&quot;storage-page-layout&quot;&gt;Section 68.6&lt;/a&gt;.</source>
          <target state="translated">表和索引的内容将在&lt;a href=&quot;storage-page-layout&quot;&gt;68.6节中&lt;/a&gt;进一步讨论。</target>
        </trans-unit>
        <trans-unit id="38f47269fb5aeb6c838c026cdcf1f0ae2ecfc4fc" translate="yes" xml:space="preserve">
          <source>The contents of the WAL buffers are written out to disk at every transaction commit, so extremely large values are unlikely to provide a significant benefit. However, setting this value to at least a few megabytes can improve write performance on a busy server where many clients are committing at once. The auto-tuning selected by the default setting of -1 should give reasonable results in most cases.</source>
          <target state="translated">WAL缓冲区的内容在每次事务提交时都会被写入磁盘,所以极大的数值不太可能带来显著的好处。然而,将这个值设置为至少几兆字节,可以提高在繁忙的服务器上的写入性能,因为很多客户机都在同时提交。在大多数情况下,默认设置-1所选择的自动调优应该可以得到合理的结果。</target>
        </trans-unit>
        <trans-unit id="b1c6502d2f4ffe992973e02c33536a28b4746870" translate="yes" xml:space="preserve">
          <source>The contents of the directories &lt;code&gt;pg_dynshmem/&lt;/code&gt;, &lt;code&gt;pg_notify/&lt;/code&gt;, &lt;code&gt;pg_serial/&lt;/code&gt;, &lt;code&gt;pg_snapshots/&lt;/code&gt;, &lt;code&gt;pg_stat_tmp/&lt;/code&gt;, and &lt;code&gt;pg_subtrans/&lt;/code&gt; (but not the directories themselves) can be omitted from the backup as they will be initialized on postmaster startup. If &lt;a href=&quot;runtime-config-statistics#GUC-STATS-TEMP-DIRECTORY&quot;&gt;stats_temp_directory&lt;/a&gt; is set and is under the data directory then the contents of that directory can also be omitted.</source>
          <target state="translated">可以从备份中省略目录 &lt;code&gt;pg_dynshmem/&lt;/code&gt; ， &lt;code&gt;pg_notify/&lt;/code&gt; ， &lt;code&gt;pg_serial/&lt;/code&gt; ， &lt;code&gt;pg_snapshots/&lt;/code&gt; ， &lt;code&gt;pg_stat_tmp/&lt;/code&gt; 和 &lt;code&gt;pg_subtrans/&lt;/code&gt; （但不是目录本身），因为它们将在邮局主管启动时进行初始化。如果设置了&lt;a href=&quot;runtime-config-statistics#GUC-STATS-TEMP-DIRECTORY&quot;&gt;stats_temp_directory&lt;/a&gt;并且位于数据目录下，则该目录的内容也可以省略。</target>
        </trans-unit>
        <trans-unit id="3de8d3c890918676d736b678933d22a18ab061b7" translate="yes" xml:space="preserve">
          <source>The convention followed by the operator classes included with the core PostgreSQL distribution is to register a stock, generic &lt;code&gt;equalimage&lt;/code&gt; function. Most operator classes register &lt;code&gt;btequalimage()&lt;/code&gt;, which indicates that deduplication is safe unconditionally. Operator classes for collatable data types such as &lt;code&gt;text&lt;/code&gt; register &lt;code&gt;btvarstrequalimage()&lt;/code&gt;, which indicates that deduplication is safe with deterministic collations. Best practice for third-party extensions is to register their own custom function to retain control.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46e0411ab62d3d86cfefc61b32fd0a5818262ee5" translate="yes" xml:space="preserve">
          <source>The conversion rules presented here are not exactly those of the SQL standard, as discussed in &lt;a href=&quot;xml-limits-conformance#FUNCTIONS-XML-LIMITS-CASTS&quot;&gt;Section D.3.1.3&lt;/a&gt;.</source>
          <target state="translated">如&lt;a href=&quot;xml-limits-conformance#FUNCTIONS-XML-LIMITS-CASTS&quot;&gt;D.3.1.3节中所述&lt;/a&gt;，此处介绍的转换规则与SQL标准不完全相同。</target>
        </trans-unit>
        <trans-unit id="93003637d33db2eb4895822b5caba9508ac9a024" translate="yes" xml:space="preserve">
          <source>The coordinates of an individual in the search space are represented by &lt;em&gt;chromosomes&lt;/em&gt;, in essence a set of character strings. A &lt;em&gt;gene&lt;/em&gt; is a subsection of a chromosome which encodes the value of a single parameter being optimized. Typical encodings for a gene could be &lt;em&gt;binary&lt;/em&gt; or &lt;em&gt;integer&lt;/em&gt;.</source>
          <target state="translated">搜索空间中个体的坐标由&lt;em&gt;染色体&lt;/em&gt;表示，本质上是一组字符串。甲&lt;em&gt;基因&lt;/em&gt;是编码单个参数的值被优化染色体的子部分。基因的典型编码可以是&lt;em&gt;二进制&lt;/em&gt;或&lt;em&gt;整数&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="862293286080d0a9f0113978ebf74556e90249fd" translate="yes" xml:space="preserve">
          <source>The core PostgreSQL distribution includes the BRIN operator classes shown in &lt;a href=&quot;brin-builtin-opclasses#BRIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 67.1&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL的核心发行版包括&lt;a href=&quot;brin-builtin-opclasses#BRIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;表67.1中&lt;/a&gt;所示的BRIN运算符类。</target>
        </trans-unit>
        <trans-unit id="7243c976dc744d56b010e5d36a8288b88892f5dc" translate="yes" xml:space="preserve">
          <source>The core PostgreSQL distribution includes the GIN operator classes previously shown in &lt;a href=&quot;gin-builtin-opclasses#GIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 66.1&lt;/a&gt;. The following &lt;code&gt;contrib&lt;/code&gt; modules also contain GIN operator classes:</source>
          <target state="translated">核心PostgreSQL发行版包括以前在&lt;a href=&quot;gin-builtin-opclasses#GIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;表66.1中&lt;/a&gt;显示的GIN运算符类。以下 &lt;code&gt;contrib&lt;/code&gt; 模块还包含GIN运算符类：</target>
        </trans-unit>
        <trans-unit id="c2fbf40f11cf35a0a12e58dfa2d5f0d5377fea85" translate="yes" xml:space="preserve">
          <source>The core PostgreSQL distribution includes the GIN operator classes shown in &lt;a href=&quot;gin-builtin-opclasses#GIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 66.1&lt;/a&gt;. (Some of the optional modules described in &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;Appendix F&lt;/a&gt; provide additional GIN operator classes.)</source>
          <target state="translated">PostgreSQL的核心发行版包括&lt;a href=&quot;gin-builtin-opclasses#GIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;表66.1中&lt;/a&gt;所示的GIN运算符类。（&lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;附录F中&lt;/a&gt;描述的一些可选模块提供了其他GIN运算符类。）</target>
        </trans-unit>
        <trans-unit id="806d720c4b8fe7fcc17e70e9b466b37e2e2f856b" translate="yes" xml:space="preserve">
          <source>The core PostgreSQL distribution includes the GIN operator classes shown in &lt;a href=&quot;gin-builtin-opclasses#GIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 66.1&lt;/a&gt;. (Some of the optional modules described in &lt;a href=&quot;https://www.postgresql.org/docs/13/contrib.html&quot;&gt;Appendix F&lt;/a&gt; provide additional GIN operator classes.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d8a9d6f1f395ae01d0f93e48fe3bca4cc653cd4" translate="yes" xml:space="preserve">
          <source>The core PostgreSQL distribution includes the GiST operator classes shown in &lt;a href=&quot;gist-builtin-opclasses#GIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 64.1&lt;/a&gt;. (Some of the optional modules described in &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;Appendix F&lt;/a&gt; provide additional GiST operator classes.)</source>
          <target state="translated">PostgreSQL的核心发行版包括&lt;a href=&quot;gist-builtin-opclasses#GIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;表64.1中&lt;/a&gt;所示的GiST运算符类。（&lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;附录F中&lt;/a&gt;描述的一些可选模块提供了其他GiST运算符类。）</target>
        </trans-unit>
        <trans-unit id="0cf2930ff562138360e1ed4d1a72443d736ec8f6" translate="yes" xml:space="preserve">
          <source>The core PostgreSQL distribution includes the GiST operator classes shown in &lt;a href=&quot;gist-builtin-opclasses#GIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 64.1&lt;/a&gt;. (Some of the optional modules described in &lt;a href=&quot;https://www.postgresql.org/docs/13/contrib.html&quot;&gt;Appendix F&lt;/a&gt; provide additional GiST operator classes.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d4f128e5e4ead669ae57136a3aca466199dcb9f" translate="yes" xml:space="preserve">
          <source>The core PostgreSQL distribution includes the SP-GiST operator classes shown in &lt;a href=&quot;spgist-builtin-opclasses#SPGIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 65.1&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL的核心发行版包括&lt;a href=&quot;spgist-builtin-opclasses#SPGIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;表65.1中&lt;/a&gt;所示的SP-GiST运算符类。</target>
        </trans-unit>
        <trans-unit id="05fafa81f43ebb1970323c27149ee647ab30ffe3" translate="yes" xml:space="preserve">
          <source>The core code is fundamentally unable to deduce anything about the &amp;ldquo;equality implies image equality&amp;rdquo; status of an operator class within a multiple-data-type family based on details from other operator classes in the same family. Also, it is not sensible for an operator family to register a cross-type &lt;code&gt;equalimage&lt;/code&gt; function, and attempting to do so will result in an error. This is because &amp;ldquo;equality implies image equality&amp;rdquo; status does not just depend on sorting/equality semantics, which are more or less defined at the operator family level. In general, the semantics that one particular data type implements must be considered separately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89a856912c9ac553c9e328fb462dc4a3dc3f226a" translate="yes" xml:space="preserve">
          <source>The core distribution includes support for two types of operator classes: minmax and inclusion. Operator class definitions using them are shipped for in-core data types as appropriate. Additional operator classes can be defined by the user for other data types using equivalent definitions, without having to write any source code; appropriate catalog entries being declared is enough. Note that assumptions about the semantics of operator strategies are embedded in the support functions' source code.</source>
          <target state="translated">核心发行版包括对两种类型的运算符类的支持:minmax和inclusion。使用它们的运算符类定义会适当地提供给核心数据类型。用户可以使用等价的定义为其他数据类型定义额外的运算符类,而无需编写任何源代码;声明适当的目录项就足够了。请注意,关于运算符策略语义的假设被嵌入到支持函数的源代码中。</target>
        </trans-unit>
        <trans-unit id="c6af74783e2e512b02fff35f8b9b1611ba92c8bc" translate="yes" xml:space="preserve">
          <source>The corresponding column will be filled with its default value.</source>
          <target state="translated">对应的列将用其默认值填充。</target>
        </trans-unit>
        <trans-unit id="33e9a48b1e5df95c7200af8afb9a8f1b54ef12f2" translate="yes" xml:space="preserve">
          <source>The corresponding column will be filled with its default value. An identity column will be filled with a new value generated by the associated sequence. For a generated column, specifying this is permitted but merely specifies the normal behavior of computing the column from its generation expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39b1b5853e1b21f147904a21bac6120e0399eff4" translate="yes" xml:space="preserve">
          <source>The corresponding constraint in the parent partitioned table, if this is a constraint in a partition; else 0</source>
          <target state="translated">父分区表中对应的约束,如果这是一个分区中的约束;否则为0。</target>
        </trans-unit>
        <trans-unit id="e50bc6dd81573c8b84e401b93b09d0320c5165e6" translate="yes" xml:space="preserve">
          <source>The costs are measured in arbitrary units determined by the planner's cost parameters (see &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-CONSTANTS&quot;&gt;Section 19.7.2&lt;/a&gt;). Traditional practice is to measure the costs in units of disk page fetches; that is, &lt;a href=&quot;runtime-config-query#GUC-SEQ-PAGE-COST&quot;&gt;seq_page_cost&lt;/a&gt; is conventionally set to &lt;code&gt;1.0&lt;/code&gt; and the other cost parameters are set relative to that. The examples in this section are run with the default cost parameters.</source>
          <target state="translated">成本以由计划者的成本参数确定的任意单位计量（请参阅&lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-CONSTANTS&quot;&gt;第19.7.2节&lt;/a&gt;）。传统做法是以磁盘页面提取为单位来衡量成本。也就是说，&lt;a href=&quot;runtime-config-query#GUC-SEQ-PAGE-COST&quot;&gt;seq_page_cost&lt;/a&gt;通常设置为 &lt;code&gt;1.0&lt;/code&gt; ，而其他cost参数则相对于此设置。本节中的示例使用默认的cost参数运行。</target>
        </trans-unit>
        <trans-unit id="40a2e5c659fc82ea65929c45fcbdccd61dafc250" translate="yes" xml:space="preserve">
          <source>The creation of a publication does not start replication. It only defines a grouping and filtering logic for future subscribers.</source>
          <target state="translated">创建一个出版物并不开始复制。它只是为未来的订阅者定义了一个分组和过滤逻辑。</target>
        </trans-unit>
        <trans-unit id="3e98adbd0156fb7d426b89504f191dda4a555319" translate="yes" xml:space="preserve">
          <source>The creation of databases is a restricted operation. See &lt;a href=&quot;role-attributes&quot;&gt;Section 21.2&lt;/a&gt; for how to grant permission.</source>
          <target state="translated">数据库的创建是受限制的操作。有关如何授予权限的信息，请参见&lt;a href=&quot;role-attributes&quot;&gt;第21.2节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1880291804157d355a896d197b0a52d8a09b04b7" translate="yes" xml:space="preserve">
          <source>The cube a contains the cube b.</source>
          <target state="translated">立方体a包含立方体b。</target>
        </trans-unit>
        <trans-unit id="375266423676b7d7beda6d0e513197403bfef8c1" translate="yes" xml:space="preserve">
          <source>The cube a is contained in the cube b.</source>
          <target state="translated">立方体a包含在立方体b中。</target>
        </trans-unit>
        <trans-unit id="b588f40bf468c3153645f14f27d51be8b21426c9" translate="yes" xml:space="preserve">
          <source>The cube a is greater than or equal to the cube b.</source>
          <target state="translated">立方a大于或等于立方b。</target>
        </trans-unit>
        <trans-unit id="2f01cfa360b4f7c3692487eca6dd5b417fc389b3" translate="yes" xml:space="preserve">
          <source>The cube a is greater than the cube b.</source>
          <target state="translated">立方a比立方体b大。</target>
        </trans-unit>
        <trans-unit id="0e6cf54be6b186407704fdff88fc957131d4ed9b" translate="yes" xml:space="preserve">
          <source>The cube a is less than or equal to the cube b.</source>
          <target state="translated">立方a小于或等于立方b。</target>
        </trans-unit>
        <trans-unit id="f2d342ff49043cacce0129a759922d79461a11fa" translate="yes" xml:space="preserve">
          <source>The cube a is less than the cube b.</source>
          <target state="translated">正方体a比正方体b小。</target>
        </trans-unit>
        <trans-unit id="4634367f6224780d287c24528a5fced1237e5fa1" translate="yes" xml:space="preserve">
          <source>The cube a is not equal to the cube b.</source>
          <target state="translated">立方a不等于立方体b。</target>
        </trans-unit>
        <trans-unit id="45987f656860bb4eb975fa1cd72ba43bc699f956" translate="yes" xml:space="preserve">
          <source>The cubes a and b are identical.</source>
          <target state="translated">立方体a和b是相同的。</target>
        </trans-unit>
        <trans-unit id="9213cf52b8d8a10f6b7daa93550fc8c65e89e83d" translate="yes" xml:space="preserve">
          <source>The cubes a and b overlap.</source>
          <target state="translated">立方体a和b重合。</target>
        </trans-unit>
        <trans-unit id="1a1e2040f8ce058f3c38c6e6d3751c0a69992146" translate="yes" xml:space="preserve">
          <source>The current backend's &lt;code&gt;xmin&lt;/code&gt; horizon.</source>
          <target state="translated">当前后端的 &lt;code&gt;xmin&lt;/code&gt; 范围。</target>
        </trans-unit>
        <trans-unit id="71bea49a2448467c39ae3d46b44b8328244be40c" translate="yes" xml:space="preserve">
          <source>The current client character set encoding. This is set every time you connect to a database (including program start-up), and when you change the encoding with &lt;code&gt;\encoding&lt;/code&gt;, but it can be changed or unset.</source>
          <target state="translated">当前客户端字符集编码。每次您连接到数据库（包括程序启动）时，以及使用 &lt;code&gt;\encoding&lt;/code&gt; 更改编码时，都会进行设置，但是可以更改或取消设置。</target>
        </trans-unit>
        <trans-unit id="0deea51724bf6c34acfe1425e13fc10373b6c41e" translate="yes" xml:space="preserve">
          <source>The current dimensions of any array value can be retrieved with the &lt;code&gt;array_dims&lt;/code&gt; function:</source>
          <target state="translated">可以使用 &lt;code&gt;array_dims&lt;/code&gt; 函数检索任何数组值的当前维：</target>
        </trans-unit>
        <trans-unit id="8c3a8302b74a0c1c2418c7953403859316142fae" translate="yes" xml:space="preserve">
          <source>The current effective value of the search path can be examined via the SQL function &lt;code&gt;current_schemas&lt;/code&gt; (see &lt;a href=&quot;functions-info&quot;&gt;Section 9.25&lt;/a&gt;). This is not quite the same as examining the value of &lt;code&gt;search_path&lt;/code&gt;, since &lt;code&gt;current_schemas&lt;/code&gt; shows how the items appearing in &lt;code&gt;search_path&lt;/code&gt; were resolved.</source>
          <target state="translated">可以通过SQL函数 &lt;code&gt;current_schemas&lt;/code&gt; 检查搜索路径的当前有效值（请参见&lt;a href=&quot;functions-info&quot;&gt;9.25节&lt;/a&gt;）。这与检查 &lt;code&gt;search_path&lt;/code&gt; 的值并不完全相同，因为 &lt;code&gt;current_schemas&lt;/code&gt; 显示了如何解析出现在 &lt;code&gt;search_path&lt;/code&gt; 中的项目。</target>
        </trans-unit>
        <trans-unit id="197001cc9f21d760f60e1fb495baacfbe4512e51" translate="yes" xml:space="preserve">
          <source>The current effective value of the search path can be examined via the SQL function &lt;code&gt;current_schemas&lt;/code&gt; (see &lt;a href=&quot;functions-info&quot;&gt;Section 9.26&lt;/a&gt;). This is not quite the same as examining the value of &lt;code&gt;search_path&lt;/code&gt;, since &lt;code&gt;current_schemas&lt;/code&gt; shows how the items appearing in &lt;code&gt;search_path&lt;/code&gt; were resolved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="588306ac744664bcce2285f16a927597e5d43ed4" translate="yes" xml:space="preserve">
          <source>The current implementation does not enforce the declared number of dimensions either. Arrays of a particular element type are all considered to be of the same type, regardless of size or number of dimensions. So, declaring the array size or number of dimensions in &lt;code&gt;CREATE TABLE&lt;/code&gt; is simply documentation; it does not affect run-time behavior.</source>
          <target state="translated">当前实现也不执行声明的维数。无论大小或维数如何，特定元素类型的数组都被认为是同一类型。因此，在 &lt;code&gt;CREATE TABLE&lt;/code&gt; 中声明数组大小或维数只是文档。它不会影响运行时行为。</target>
        </trans-unit>
        <trans-unit id="03a220364aef06c1bbc7f574a82ccaeced5bea27" translate="yes" xml:space="preserve">
          <source>The current implementation has significant limitations, and does not enforce mandatory access control for all actions. See &lt;a href=&quot;sepgsql#SEPGSQL-LIMITATIONS&quot;&gt;Section F.35.7&lt;/a&gt;.</source>
          <target state="translated">当前的实现有很多限制，并且不对所有操作强制执行强制访问控制。参见&lt;a href=&quot;sepgsql#SEPGSQL-LIMITATIONS&quot;&gt;第F.35.7节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="25210d55190c9236b389899a74a7b5704fff78d4" translate="yes" xml:space="preserve">
          <source>The current implementation of &lt;code&gt;unaccent&lt;/code&gt; cannot be used as a normalizing dictionary for the &lt;code&gt;thesaurus&lt;/code&gt; dictionary.</source>
          <target state="translated">&lt;code&gt;unaccent&lt;/code&gt; 的当前实现不能用作 &lt;code&gt;thesaurus&lt;/code&gt; 字典的规范化字典。</target>
        </trans-unit>
        <trans-unit id="ed96c59248b01f330729c6c44b2035a2f3097a16" translate="yes" xml:space="preserve">
          <source>The current limitations of PostgreSQL's text search features are:</source>
          <target state="translated">目前PostgreSQL的文本搜索功能的局限性在于。</target>
        </trans-unit>
        <trans-unit id="11ad6de9ae99189b133ed48695fe71e760901959" translate="yes" xml:space="preserve">
          <source>The cursor should be declared with the &lt;code&gt;SCROLL&lt;/code&gt; option if one intends to use any variants of &lt;code&gt;FETCH&lt;/code&gt; other than &lt;code&gt;FETCH NEXT&lt;/code&gt; or &lt;code&gt;FETCH FORWARD&lt;/code&gt; with a positive count. For simple queries PostgreSQL will allow backwards fetch from cursors not declared with &lt;code&gt;SCROLL&lt;/code&gt;, but this behavior is best not relied on. If the cursor is declared with &lt;code&gt;NO SCROLL&lt;/code&gt;, no backward fetches are allowed.</source>
          <target state="translated">光标应与声明 &lt;code&gt;SCROLL&lt;/code&gt; 选项，如果一个打算使用的任何变种 &lt;code&gt;FETCH&lt;/code&gt; 除 &lt;code&gt;FETCH NEXT&lt;/code&gt; 和 &lt;code&gt;FETCH FORWARD&lt;/code&gt; 具有正数。对于简单查询，PostgreSQL将允许从未使用 &lt;code&gt;SCROLL&lt;/code&gt; 声明的游标进行向后取回，但是最好不要依赖这种行为。如果使用 &lt;code&gt;NO SCROLL&lt;/code&gt; 声明了游标，则不允许向后提取。</target>
        </trans-unit>
        <trans-unit id="4f29dd59131cbd500833c5a80fec96f77393e7a4" translate="yes" xml:space="preserve">
          <source>The data distribution is very simple; there are only 100 distinct values in each column, uniformly distributed.</source>
          <target state="translated">数据分布非常简单,每列只有100个不同的值,均匀分布。</target>
        </trans-unit>
        <trans-unit id="bf388f98f91dd65f88f15e7c3f1b408fc205654b" translate="yes" xml:space="preserve">
          <source>The data is prefixed with a block of random bytes. This is equivalent to using a random IV.</source>
          <target state="translated">数据的前缀是一个随机字节块。这相当于使用随机IV。</target>
        </trans-unit>
        <trans-unit id="d53ba1352e33254f15d2784088350652d0fec89f" translate="yes" xml:space="preserve">
          <source>The data on the standby takes some time to arrive from the primary server so there will be a measurable delay between primary and standby. Running the same query nearly simultaneously on both primary and standby might therefore return differing results. We say that data on the standby is &lt;em&gt;eventually consistent&lt;/em&gt; with the primary. Once the commit record for a transaction is replayed on the standby, the changes made by that transaction will be visible to any new snapshots taken on the standby. Snapshots may be taken at the start of each query or at the start of each transaction, depending on the current transaction isolation level. For more details, see &lt;a href=&quot;transaction-iso&quot;&gt;Section 13.2&lt;/a&gt;.</source>
          <target state="translated">备用服务器上的数据需要花费一些时间才能从主服务器到达，因此主服务器和备用服务器之间会有可测量的延迟。因此，在主数据库和备用数据库上几乎同时运行同一查询可能会返回不同的结果。我们说备用数据库上的数据&lt;em&gt;最终&lt;/em&gt;与主数据库&lt;em&gt;一致&lt;/em&gt;。一旦在备用数据库上重放事务的提交记录，该事务所做的更改将对在备用数据库上拍摄的所有新快照可见。根据当前事务隔离级别，可以在每个查询的开始或每个事务的开始拍摄快照。有关更多详细信息，请参见&lt;a href=&quot;transaction-iso&quot;&gt;第13.2节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0b4139483f5abc1e06390b32222b164b98282561" translate="yes" xml:space="preserve">
          <source>The data section contains actual table data as well as large-object definitions. Post-data items consist of definitions of indexes, triggers, rules and constraints other than validated check constraints. Pre-data items consist of all other data definition items.</source>
          <target state="translated">数据部分包含实际的表数据以及大对象定义。后数据项包括索引、触发器、规则和除验证检查约束外的约束的定义。前数据项包括所有其他数据定义项。</target>
        </trans-unit>
        <trans-unit id="e6ca4b823a5f4163ec85e2bd3fdf29af04d8b385" translate="yes" xml:space="preserve">
          <source>The data section contains actual table data, large-object contents, and sequence values. Post-data items include definitions of indexes, triggers, rules, and constraints other than validated check constraints. Pre-data items include all other data definition items.</source>
          <target state="translated">数据部分包含实际表数据、大对象内容和序列值。后数据项包括索引、触发器、规则和除验证检查约束外的约束的定义。前数据项包括所有其他数据定义项。</target>
        </trans-unit>
        <trans-unit id="b17b79d26641dd87ba0c23b6c9bc174faa3a8b61" translate="yes" xml:space="preserve">
          <source>The data type &lt;code&gt;uuid&lt;/code&gt; stores Universally Unique Identifiers (UUID) as defined by RFC 4122, ISO/IEC 9834-8:2005, and related standards. (Some systems refer to this data type as a globally unique identifier, or GUID, instead.) This identifier is a 128-bit quantity that is generated by an algorithm chosen to make it very unlikely that the same identifier will be generated by anyone else in the known universe using the same algorithm. Therefore, for distributed systems, these identifiers provide a better uniqueness guarantee than sequence generators, which are only unique within a single database.</source>
          <target state="translated">&lt;code&gt;uuid&lt;/code&gt; 数据类型存储RFC 4122，ISO / IEC 9834-8：2005和相关标准定义的通用唯一标识符（UUID）。 （某些系统将这种数据类型称为全局唯一标识符，即GUID。）此标识符是128位的数量，该数量是由一种算法生成的，该算法的选择是使其他人不太可能生成同一标识符在已知的宇宙中使用相同的算法。因此，对于分布式系统，这些标识符提供了比仅在单个数据库中唯一的序列生成器更好的唯一性保证。</target>
        </trans-unit>
        <trans-unit id="9a349537e0ccabe90f0be4224865fb39a87fb38c" translate="yes" xml:space="preserve">
          <source>The data type actually stored in the index. Normally this is the same as the column data type, but some index methods (currently GiST, GIN and BRIN) allow it to be different. The &lt;code&gt;STORAGE&lt;/code&gt; clause must be omitted unless the index method allows a different type to be used. If the column &lt;code&gt;data_type&lt;/code&gt; is specified as &lt;code&gt;anyarray&lt;/code&gt;, the &lt;code&gt;storage_type&lt;/code&gt; can be declared as &lt;code&gt;anyelement&lt;/code&gt; to indicate that the index entries are members of the element type belonging to the actual array type that each particular index is created for.</source>
          <target state="translated">实际存储在索引中的数据类型。通常，这与列数据类型相同，但是某些索引方法（当前为GiST，GIN和BRIN）允许其不同。的 &lt;code&gt;STORAGE&lt;/code&gt; 子句必须省略除非索引方法允许使用不同的类型。如果将列 &lt;code&gt;data_type&lt;/code&gt; 指定为 &lt;code&gt;anyarray&lt;/code&gt; ，则可以将 &lt;code&gt;storage_type&lt;/code&gt; 声明为 &lt;code&gt;anyelement&lt;/code&gt; ,以指示索引条目是属于为每个特定索引创建的实际数组类型的元素类型的成员。</target>
        </trans-unit>
        <trans-unit id="b3cf16533d2c33c2548b22d8bef5b9f8bd26fb43" translate="yes" xml:space="preserve">
          <source>The data type for the aggregate's state value, when using moving-aggregate mode.</source>
          <target state="translated">当使用移动聚合模式时,聚合的状态值的数据类型。</target>
        </trans-unit>
        <trans-unit id="450e47ffde369f976b7ab98b3a6e066768317211" translate="yes" xml:space="preserve">
          <source>The data type for the aggregate's state value.</source>
          <target state="translated">聚合体的状态值的数据类型。</target>
        </trans-unit>
        <trans-unit id="a84accdb873accb8d045ec8f5d98450a1c8038e0" translate="yes" xml:space="preserve">
          <source>The data type of a function, procedure, or aggregate argument.</source>
          <target state="translated">函数、过程或集合参数的数据类型。</target>
        </trans-unit>
        <trans-unit id="7678a7f2db2f20f82bdcd718575a886bbedb555c" translate="yes" xml:space="preserve">
          <source>The data type of a parameter to the prepared statement. If the data type of a particular parameter is unspecified or is specified as &lt;code&gt;unknown&lt;/code&gt;, it will be inferred from the context in which the parameter is first referenced. To refer to the parameters in the prepared statement itself, use &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, etc.</source>
          <target state="translated">准备好的语句的参数的数据类型。如果未指定特定参数的数据类型或将其指定为 &lt;code&gt;unknown&lt;/code&gt; ，则将从首次引用该参数的上下文中推断出该数据类型。要在prepared语句本身中引用参数，请使用 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="97e7b1042480837c18e5146ff95fc1e9e9d4ce38" translate="yes" xml:space="preserve">
          <source>The data type of an output column in the &lt;code&gt;RETURNS TABLE&lt;/code&gt; syntax.</source>
          <target state="translated">&lt;code&gt;RETURNS TABLE&lt;/code&gt; 语法中的输出列的数据类型。</target>
        </trans-unit>
        <trans-unit id="1f4da46a2e46ee99f93db576da8c6c70a740dbca" translate="yes" xml:space="preserve">
          <source>The data type of the attribute to add, or the new type of the attribute to alter.</source>
          <target state="translated">要添加的属性的数据类型,或者要改变的属性的新类型。</target>
        </trans-unit>
        <trans-unit id="643babd5ccd3dbc1eadd607ad51f52e3099e9220" translate="yes" xml:space="preserve">
          <source>The data type of the column. This can include array specifiers. For more information on the data types supported by PostgreSQL, refer to &lt;a href=&quot;datatype&quot;&gt;Chapter 8&lt;/a&gt;.</source>
          <target state="translated">列的数据类型。这可以包括数组说明符。有关PostgreSQL支持的数据类型的更多信息，请参见&lt;a href=&quot;datatype&quot;&gt;第8章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="00e2be0bf08b0f249705f534c771af62f659c534" translate="yes" xml:space="preserve">
          <source>The data type of the operator's left operand, if any. This option would be omitted for a left-unary operator.</source>
          <target state="translated">运算符左操作数的数据类型(如果有的话)。对于左单数运算符,这个选项可以省略。</target>
        </trans-unit>
        <trans-unit id="3851b291352047da5cb8dab5436b1049af2b810b" translate="yes" xml:space="preserve">
          <source>The data type of the operator's left operand; write &lt;code&gt;NONE&lt;/code&gt; if the operator has no left operand.</source>
          <target state="translated">运算符的左操作数的数据类型；如果运算符没有左操作数，则写 &lt;code&gt;NONE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ccbd8cc94b9c8b592bbe8864eb6cc7e34df08235" translate="yes" xml:space="preserve">
          <source>The data type of the operator's right operand, if any. This option would be omitted for a right-unary operator.</source>
          <target state="translated">运算符右操作数的数据类型(如果有的话)。对于右单数运算符,这个选项可以省略。</target>
        </trans-unit>
        <trans-unit id="977b80839dcec0a264635f6fae2341cd4abe466d" translate="yes" xml:space="preserve">
          <source>The data type of the operator's right operand; write &lt;code&gt;NONE&lt;/code&gt; if the operator has no right operand.</source>
          <target state="translated">运算符的右操作数的数据类型；如果运算符没有正确的操作数，则写 &lt;code&gt;NONE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d1e6d9a6627f0f8541d4b2888407afff0ea3591c" translate="yes" xml:space="preserve">
          <source>The data type of this column</source>
          <target state="translated">此列的数据类型</target>
        </trans-unit>
        <trans-unit id="536b65adfc0c23a20e0043a6c217a813568358a2" translate="yes" xml:space="preserve">
          <source>The data type(s) of the function's arguments (optionally schema-qualified), if any.</source>
          <target state="translated">函数参数的数据类型(可选择模式限定),如果有的话。</target>
        </trans-unit>
        <trans-unit id="c1899d531f40a6d2bc934ee7a1bdb436b5b33cc2" translate="yes" xml:space="preserve">
          <source>The data type(s) of the function's arguments (optionally schema-qualified), if any. The argument types can be base, composite, or domain types, or can reference the type of a table column.</source>
          <target state="translated">函数参数的数据类型(可选择模式限定),如果有的话。参数类型可以是基本类型、复合类型或域类型,也可以引用一个表列的类型。</target>
        </trans-unit>
        <trans-unit id="0fa26cbbebcfa5ffa72e0fb66013b91729e1dbea" translate="yes" xml:space="preserve">
          <source>The data type(s) of the operator's arguments (optionally schema-qualified). Write &lt;code&gt;NONE&lt;/code&gt; for the missing argument of a prefix or postfix operator.</source>
          <target state="translated">运算符参数的数据类型（可选，模式限定）。为前缀或后缀运算符的缺少参数写 &lt;code&gt;NONE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f78d5722d424ec9c1eb5a72c627a144311353db1" translate="yes" xml:space="preserve">
          <source>The data type(s) of the procedure's arguments (optionally schema-qualified), if any.</source>
          <target state="translated">存储过程参数的数据类型(可选择模式限定),如果有的话。</target>
        </trans-unit>
        <trans-unit id="cc4ed7c8f0edb91ee3802c9f1cbfdfe5d88cd95f" translate="yes" xml:space="preserve">
          <source>The data type(s) of the procedure's arguments (optionally schema-qualified), if any. The argument types can be base, composite, or domain types, or can reference the type of a table column.</source>
          <target state="translated">存储过程的参数的数据类型(可选择模式限定),如果有的话。参数类型可以是基本类型、复合类型或域类型,也可以引用一个表列的类型。</target>
        </trans-unit>
        <trans-unit id="b13b1cfa55ac5025cb1667821c336a02f9958dc9" translate="yes" xml:space="preserve">
          <source>The data types &lt;code&gt;real&lt;/code&gt; and &lt;code&gt;double precision&lt;/code&gt; are inexact, variable-precision numeric types. On all currently supported platforms, these types are implementations of IEEE Standard 754 for Binary Floating-Point Arithmetic (single and double precision, respectively), to the extent that the underlying processor, operating system, and compiler support it.</source>
          <target state="translated">&lt;code&gt;real&lt;/code&gt; 和 &lt;code&gt;double precision&lt;/code&gt; 数据类型是不精确的可变精度数字类型。在当前支持的所有平台上，这些类型都是IEEE标准754的二进制浮点算术（分别为单精度和双精度）的实现，只要底层处理器，操作系统和编译器都支持它即可。</target>
        </trans-unit>
        <trans-unit id="95cc47952f3a5e2e5bea18ece63744adf6f3d52b" translate="yes" xml:space="preserve">
          <source>The data types &lt;code&gt;smallserial&lt;/code&gt;, &lt;code&gt;serial&lt;/code&gt; and &lt;code&gt;bigserial&lt;/code&gt; are not true types, but merely a notational convenience for creating unique identifier columns (similar to the &lt;code&gt;AUTO_INCREMENT&lt;/code&gt; property supported by some other databases). In the current implementation, specifying:</source>
          <target state="translated">数据类型 &lt;code&gt;smallserial&lt;/code&gt; ， &lt;code&gt;serial&lt;/code&gt; 和 &lt;code&gt;bigserial&lt;/code&gt; 不是真正的类型，而只是创建唯一标识符列的符号方便（类似于某些其他数据库支持的 &lt;code&gt;AUTO_INCREMENT&lt;/code&gt; 属性）。在当前的实现中，指定：</target>
        </trans-unit>
        <trans-unit id="c1d4cee11581ccf46822d30574cc04ac170d447c" translate="yes" xml:space="preserve">
          <source>The data types of all the &lt;code&gt;result&lt;/code&gt; expressions must be convertible to a single output type. See &lt;a href=&quot;typeconv-union-case&quot;&gt;Section 10.5&lt;/a&gt; for more details.</source>
          <target state="translated">所有 &lt;code&gt;result&lt;/code&gt; 表达式的数据类型必须可转换为单个输出类型。有关更多详细信息，请参见&lt;a href=&quot;typeconv-union-case&quot;&gt;第10.5节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="833950eaad4f091a792f16ed765cff996e89f49e" translate="yes" xml:space="preserve">
          <source>The data values are listed in the order in which the columns appear in the table, separated by commas. Usually, the data values will be literals (constants), but scalar expressions are also allowed.</source>
          <target state="translated">数据值按照表格中各列出现的顺序排列,用逗号分隔。通常情况下,数据值将是字数(常数),但也允许使用标量表达式。</target>
        </trans-unit>
        <trans-unit id="511f74682fefbedf40676929009d5d52bb81a56d" translate="yes" xml:space="preserve">
          <source>The data values are mapped in the same way as described for the function &lt;code&gt;xmlelement&lt;/code&gt; above.</source>
          <target state="translated">数据值的映射方式与上述函数 &lt;code&gt;xmlelement&lt;/code&gt; 所述的方式相同。</target>
        </trans-unit>
        <trans-unit id="b3854c2d1d8f8304933b603d0d2fef62ed88a35f" translate="yes" xml:space="preserve">
          <source>The database activity of pg_dump is normally collected by the statistics collector. If this is undesirable, you can set parameter &lt;code&gt;track_counts&lt;/code&gt; to false via &lt;code&gt;PGOPTIONS&lt;/code&gt; or the &lt;code&gt;ALTER USER&lt;/code&gt; command.</source>
          <target state="translated">pg_dump的数据库活动通常由统计信息收集器收集。如果不希望这样做，则可以通过 &lt;code&gt;PGOPTIONS&lt;/code&gt; 或 &lt;code&gt;ALTER USER&lt;/code&gt; 命令将参数 &lt;code&gt;track_counts&lt;/code&gt; 设置为false 。</target>
        </trans-unit>
        <trans-unit id="e78726feeb2c4690a432f23c59d13fb4ceea2509" translate="yes" xml:space="preserve">
          <source>The database named in the &lt;code&gt;-d&lt;/code&gt; switch can be any database existing in the cluster; pg_restore only uses it to issue the &lt;code&gt;CREATE DATABASE&lt;/code&gt; command for &lt;code&gt;mydb&lt;/code&gt;. With &lt;code&gt;-C&lt;/code&gt;, data is always restored into the database name that appears in the dump file.</source>
          <target state="translated">&lt;code&gt;-d&lt;/code&gt; 开关中命名的数据库可以是集群中现有的任何数据库；pg_restore仅使用它为 &lt;code&gt;mydb&lt;/code&gt; 发出 &lt;code&gt;CREATE DATABASE&lt;/code&gt; 命令。使用 &lt;code&gt;-C&lt;/code&gt; ，数据总是还原到转储文件中显示的数据库名称中。</target>
        </trans-unit>
        <trans-unit id="a7217998725cfcd7339a40affa714dc41a9f7779" translate="yes" xml:space="preserve">
          <source>The database schema and DDL commands are not replicated. The initial schema can be copied by hand using &lt;code&gt;pg_dump --schema-only&lt;/code&gt;. Subsequent schema changes would need to be kept in sync manually. (Note, however, that there is no need for the schemas to be absolutely the same on both sides.) Logical replication is robust when schema definitions change in a live database: When the schema is changed on the publisher and replicated data starts arriving at the subscriber but does not fit into the table schema, replication will error until the schema is updated. In many cases, intermittent errors can be avoided by applying additive schema changes to the subscriber first.</source>
          <target state="translated">数据库模式和DDL命令不会被复制。可以使用 &lt;code&gt;pg_dump --schema-only&lt;/code&gt; 手动复制初始模式。随后的模式更改将需要手动保持同步。 （但是，请注意，架构的两端不必完全相同。）当实时数据库中的架构定义发生更改时，逻辑复制将很可靠：当发布服务器上的架构发生更改并且复制的数据开始到达时订阅服务器，但不适合表架构，在架构更新之前复制将出错。在许多情况下，可以通过首先将附加模式更改应用于订户来避免间歇性错误。</target>
        </trans-unit>
        <trans-unit id="7126248724d0590ca70b478abc60308b632b1141" translate="yes" xml:space="preserve">
          <source>The database server &lt;em&gt;must&lt;/em&gt; be shut down in order to get a usable backup. Half-way measures such as disallowing all connections will &lt;em&gt;not&lt;/em&gt; work (in part because &lt;code&gt;tar&lt;/code&gt; and similar tools do not take an atomic snapshot of the state of the file system, but also because of internal buffering within the server). Information about stopping the server can be found in &lt;a href=&quot;server-shutdown&quot;&gt;Section 18.5&lt;/a&gt;. Needless to say, you also need to shut down the server before restoring the data.</source>
          <target state="translated">&lt;em&gt;必须&lt;/em&gt;关闭数据库服务器才能获得可用的备份。中途的措施，如禁止所有连接将&lt;em&gt;不会&lt;/em&gt;（部分原因是因为工作 &lt;code&gt;tar&lt;/code&gt; 和类似的工具并不会考虑文件系统的状态的原子快照，而且还因为在服务器中的内部缓冲）。有关停止服务器的信息，请参见&lt;a href=&quot;server-shutdown&quot;&gt;第18.5节&lt;/a&gt;。不用说，您还需要在还原数据之前关闭服务器。</target>
        </trans-unit>
        <trans-unit id="c8210278fffa651db73498b44685083caea4837b" translate="yes" xml:space="preserve">
          <source>The database server host you are currently connected to. This is set every time you connect to a database (including program start-up), but can be changed or unset.</source>
          <target state="translated">你当前连接的数据库服务器主机。每次连接到数据库(包括程序启动)时都会设置,但可以更改或取消设置。</target>
        </trans-unit>
        <trans-unit id="4225ad89a733947e3891f6391650e080a1af4ac1" translate="yes" xml:space="preserve">
          <source>The database server port to which you are currently connected. This is set every time you connect to a database (including program start-up), but can be changed or unset.</source>
          <target state="translated">当前连接到的数据库服务器端口。每次连接到数据库时(包括程序启动)都会设置这个端口,但可以更改或取消设置。</target>
        </trans-unit>
        <trans-unit id="cc0f8108abc644f84f0071b412b2512b78ad2132" translate="yes" xml:space="preserve">
          <source>The database server's host name</source>
          <target state="translated">数据库服务器的主机名</target>
        </trans-unit>
        <trans-unit id="a4b3d744975ee6b60121119bc335e231f7de4513" translate="yes" xml:space="preserve">
          <source>The database server's port number</source>
          <target state="translated">数据库服务器的端口号</target>
        </trans-unit>
        <trans-unit id="cfe5c0809041f0c5dee1fdfbdf2f909905d7bde5" translate="yes" xml:space="preserve">
          <source>The database session user name. (The expansion of this value might change during a database session as the result of the command &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt;.)</source>
          <target state="translated">数据库会话用户名。（此值的扩展可能在数据库会话期间由于命令 &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; 而改变。）</target>
        </trans-unit>
        <trans-unit id="7c6fc494e971daf47c30896ebfcc78ba315d5aed" translate="yes" xml:space="preserve">
          <source>The database to connect to. See the description of the actions for what this means in detail. The &lt;code&gt;dbname&lt;/code&gt; can be a &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;connection string&lt;/a&gt;. If so, connection string parameters will override any conflicting command line options. Defaults to the user name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8854074f0a9f2884a73fba5bef5522aadc8c6fe8" translate="yes" xml:space="preserve">
          <source>The database to connect to. See the description of the actions for what this means in detail. This can be a libpq connection string; see &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;Section 33.1.1&lt;/a&gt; for more information. Defaults to user name.</source>
          <target state="translated">要连接的数据库。有关详细含义，请参见操作说明。这可以是一个libpq连接字符串。有关更多信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;第33.1.1节&lt;/a&gt;。默认为用户名。</target>
        </trans-unit>
        <trans-unit id="8142c603a5c381a14fdd730098342401f6c26eea" translate="yes" xml:space="preserve">
          <source>The database user you are currently connected as. This is set every time you connect to a database (including program start-up), but can be changed or unset.</source>
          <target state="translated">你当前连接的数据库用户。每次连接数据库(包括程序启动)时都会设置,但可以更改或取消设置。</target>
        </trans-unit>
        <trans-unit id="b630a685a9f1e8cf73c559db8e767d96cc4b9662" translate="yes" xml:space="preserve">
          <source>The database you are trying to connect to does not exist. Note that if you do not specify a database name, it defaults to the database user name, which might or might not be the right thing.</source>
          <target state="translated">你试图连接的数据库不存在。请注意,如果你没有指定数据库名称,它默认为数据库用户名,这可能是或不是正确的事情。</target>
        </trans-unit>
        <trans-unit id="fee1a6c055e42f40e71b91d8726649529647f66d" translate="yes" xml:space="preserve">
          <source>The datatype input function for type &lt;code&gt;boolean&lt;/code&gt; accepts these string representations for the &amp;ldquo;true&amp;rdquo; state:</source>
          <target state="translated">&lt;code&gt;boolean&lt;/code&gt; 类型的数据类型输入函数接受这些字符串表示为&amp;ldquo; true&amp;rdquo;状态：</target>
        </trans-unit>
        <trans-unit id="ae4a7ff4b226f1bae5a99aaa421f3e1ec4a71979" translate="yes" xml:space="preserve">
          <source>The datatype output function for type &lt;code&gt;boolean&lt;/code&gt; always emits either &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;f&lt;/code&gt;, as shown in &lt;a href=&quot;datatype-boolean#DATATYPE-BOOLEAN-EXAMPLE&quot;&gt;Example 8.2&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;boolean&lt;/code&gt; 类型的数据类型输出函数始终发出 &lt;code&gt;t&lt;/code&gt; 或 &lt;code&gt;f&lt;/code&gt; ，如&lt;a href=&quot;datatype-boolean#DATATYPE-BOOLEAN-EXAMPLE&quot;&gt;示例8.2&lt;/a&gt;所示。</target>
        </trans-unit>
        <trans-unit id="7cfcef52fd742ca2a7d47081e6367dac502e36ab" translate="yes" xml:space="preserve">
          <source>The date/time style can be selected by the user using the &lt;code&gt;SET datestyle&lt;/code&gt; command, the &lt;a href=&quot;runtime-config-client#GUC-DATESTYLE&quot;&gt;DateStyle&lt;/a&gt; parameter in the &lt;code&gt;postgresql.conf&lt;/code&gt; configuration file, or the &lt;code&gt;PGDATESTYLE&lt;/code&gt; environment variable on the server or client.</source>
          <target state="translated">用户可以使用 &lt;code&gt;SET datestyle&lt;/code&gt; 命令， &lt;code&gt;postgresql.conf&lt;/code&gt; 配置文件中的&lt;a href=&quot;runtime-config-client#GUC-DATESTYLE&quot;&gt;DateStyle&lt;/a&gt;参数或服务器或客户端上的 &lt;code&gt;PGDATESTYLE&lt;/code&gt; 环境变量来选择日期/时间样式。</target>
        </trans-unit>
        <trans-unit id="5d764ba10f260d8d4e8bfcd3a741fca678bd1d96" translate="yes" xml:space="preserve">
          <source>The day of the week as Monday (&lt;code&gt;1&lt;/code&gt;) to Sunday (&lt;code&gt;7&lt;/code&gt;)</source>
          <target state="translated">星期几是星期一（ &lt;code&gt;1&lt;/code&gt; ）到星期日（ &lt;code&gt;7&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="a891efc073ada13a5907f18625fe5fde82907c09" translate="yes" xml:space="preserve">
          <source>The day of the week as Sunday (&lt;code&gt;0&lt;/code&gt;) to Saturday (&lt;code&gt;6&lt;/code&gt;)</source>
          <target state="translated">星期几是星期日（ &lt;code&gt;0&lt;/code&gt; ）到星期六（ &lt;code&gt;6&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="9ca4eefed78bdde53eebbe05d44c2b02c01e2924" translate="yes" xml:space="preserve">
          <source>The day of the year (1 - 365/366)</source>
          <target state="translated">一年中的某一天(1-365/366)</target>
        </trans-unit>
        <trans-unit id="9a1fd8cf416c0db89c29a7999ef88f31189e883a" translate="yes" xml:space="preserve">
          <source>The day of the year (1&amp;ndash;365/366)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb0c5380f15a2fcb247a4681d0ebeea27f30d33e" translate="yes" xml:space="preserve">
          <source>The daylight-savings transition &lt;code&gt;rule&lt;/code&gt; has the format</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4a9223278a724eaae749c9ac28592e80acca20f" translate="yes" xml:space="preserve">
          <source>The decrypted data and the decryption key are present on the server for a brief time while it is being decrypted and communicated between the client and server. This presents a brief moment where the data and keys can be intercepted by someone with complete access to the database server, such as the system administrator.</source>
          <target state="translated">在客户端和服务器之间进行解密和通信时,解密数据和解密密钥在服务器上存在的时间很短。这就出现了一个短暂的时刻,数据和密钥可以被完全可以进入数据库服务器的人,如系统管理员拦截。</target>
        </trans-unit>
        <trans-unit id="0c0cddca1cd2a66e6ef93ce9c61b41178a127f6f" translate="yes" xml:space="preserve">
          <source>The deduplication process occurs lazily, when a new item is inserted that cannot fit on an existing leaf page. This prevents (or at least delays) leaf page splits. Unlike GIN posting list tuples, B-Tree posting list tuples do not need to expand every time a new duplicate is inserted; they are merely an alternative physical representation of the original logical contents of the leaf page. This design prioritizes consistent performance with mixed read-write workloads. Most client applications will at least see a moderate performance benefit from using deduplication. Deduplication is enabled by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="164046e431b6ca84db93b57b79867c4791c090cf" translate="yes" xml:space="preserve">
          <source>The default (and recommended) setting of &lt;a href=&quot;runtime-config-query#GUC-CONSTRAINT-EXCLUSION&quot;&gt;constraint_exclusion&lt;/a&gt; is neither &lt;code&gt;on&lt;/code&gt; nor &lt;code&gt;off&lt;/code&gt;, but an intermediate setting called &lt;code&gt;partition&lt;/code&gt;, which causes the technique to be applied only to queries that are likely to be working on inheritance partitioned tables. The &lt;code&gt;on&lt;/code&gt; setting causes the planner to examine &lt;code&gt;CHECK&lt;/code&gt; constraints in all queries, even simple ones that are unlikely to benefit.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-query#GUC-CONSTRAINT-EXCLUSION&quot;&gt;Constraint_exclusion&lt;/a&gt;的默认（建议设置）既不 &lt;code&gt;on&lt;/code&gt; 也不 &lt;code&gt;off&lt;/code&gt; ，而是一个名为 &lt;code&gt;partition&lt;/code&gt; 的中间设置，这导致该技术仅应用于可能在继承分区表上运行的查询。在 &lt;code&gt;on&lt;/code&gt; 设置使规划师来检查 &lt;code&gt;CHECK&lt;/code&gt; 在所有查询的限制，即使是简单的认为是不太可能的利益。</target>
        </trans-unit>
        <trans-unit id="1787e7e5cf03a442dbbaaa1d6af68edf6096b6e2" translate="yes" xml:space="preserve">
          <source>The default GIN operator class for &lt;code&gt;jsonb&lt;/code&gt; supports queries with top-level key-exists operators &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;?&amp;amp;&lt;/code&gt; and &lt;code&gt;?|&lt;/code&gt; operators and path/value-exists operator &lt;code&gt;@&amp;gt;&lt;/code&gt;. (For details of the semantics that these operators implement, see &lt;a href=&quot;functions-json#FUNCTIONS-JSONB-OP-TABLE&quot;&gt;Table 9.45&lt;/a&gt;.) An example of creating an index with this operator class is:</source>
          <target state="translated">&lt;code&gt;jsonb&lt;/code&gt; 的默认GIN运算符类支持使用顶级键存在运算符进行查询 &lt;code&gt;?&lt;/code&gt; ， &lt;code&gt;?&amp;amp;&lt;/code&gt; 和 &lt;code&gt;?|&lt;/code&gt; 运算符和路径/值存在运算符 &lt;code&gt;@&amp;gt;&lt;/code&gt; 。（有关这些运算符实现的语义的详细信息，请&lt;a href=&quot;functions-json#FUNCTIONS-JSONB-OP-TABLE&quot;&gt;参见表9.45&lt;/a&gt;。）使用此运算符类创建索引的示例是：</target>
        </trans-unit>
        <trans-unit id="2eb60f012e323a27dd228ff40f13cdf0f9d72cff" translate="yes" xml:space="preserve">
          <source>The default IPC settings can be changed using the &lt;code&gt;sysctl&lt;/code&gt; or &lt;code&gt;loader&lt;/code&gt; interfaces. The following parameters can be set using &lt;code&gt;sysctl&lt;/code&gt;:</source>
          <target state="translated">可以使用 &lt;code&gt;sysctl&lt;/code&gt; 或 &lt;code&gt;loader&lt;/code&gt; 接口更改默认IPC设置。可以使用 &lt;code&gt;sysctl&lt;/code&gt; 设置以下参数：</target>
        </trans-unit>
        <trans-unit id="0939858e47c24e25aea8221bd11aa7efd06e7d2d" translate="yes" xml:space="preserve">
          <source>The default TPC-B-like transaction test requires specific tables to be set up beforehand. pgbench should be invoked with the &lt;code&gt;-i&lt;/code&gt; (initialize) option to create and populate these tables. (When you are testing a custom script, you don't need this step, but will instead need to do whatever setup your test needs.) Initialization looks like:</source>
          <target state="translated">默认的类似TPC-B的事务测试需要预先设置特定的表。应当使用 &lt;code&gt;-i&lt;/code&gt; （初始化）选项调用pgbench 来创建和填充这些表。（在测试自定义脚本时，不需要此步骤，但是需要执行测试所需的任何设置。）初始化看起来像：</target>
        </trans-unit>
        <trans-unit id="1cd3fc8c960efc439298488cea62fca507ea8c64" translate="yes" xml:space="preserve">
          <source>The default behavior for huge pages in PostgreSQL is to use them when possible and to fall back to normal pages when failing. To enforce the use of huge pages, you can set &lt;a href=&quot;runtime-config-resource#GUC-HUGE-PAGES&quot;&gt;huge_pages&lt;/a&gt; to &lt;code&gt;on&lt;/code&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;. Note that with this setting PostgreSQL will fail to start if not enough huge pages are available.</source>
          <target state="translated">PostgreSQL中大页面的默认行为是在可能的情况下使用它们，而在失败时退回到普通页面。要强制使用大页面，可以在 &lt;code&gt;postgresql.conf&lt;/code&gt; 中将&lt;a href=&quot;runtime-config-resource#GUC-HUGE-PAGES&quot;&gt;huge_pages&lt;/a&gt;设置为 &lt;code&gt;on&lt;/code&gt; 。请注意，如果没有足够大的页面，使用此设置，PostgreSQL将无法启动。</target>
        </trans-unit>
        <trans-unit id="aaa5ded69b6418f38f6ec7a4670e3b4d29f7971b" translate="yes" xml:space="preserve">
          <source>The default behavior of recovery is to recover along the same timeline that was current when the base backup was taken. If you wish to recover into some child timeline (that is, you want to return to some state that was itself generated after a recovery attempt), you need to specify the target timeline ID in &lt;a href=&quot;runtime-config-wal#GUC-RECOVERY-TARGET-TIMELINE&quot;&gt;recovery_target_timeline&lt;/a&gt;. You cannot recover into timelines that branched off earlier than the base backup.</source>
          <target state="translated">恢复的默认行为是按照进行基本备份时的当前时间线进行恢复。如果希望恢复到某个子时间轴（即，要返回到尝试恢复后本身生成的某种状态），则需要在&lt;a href=&quot;runtime-config-wal#GUC-RECOVERY-TARGET-TIMELINE&quot;&gt;recovery_target_timeline中&lt;/a&gt;指定目标时间轴ID 。您无法恢复到比基本备份更早分支的时间表。</target>
        </trans-unit>
        <trans-unit id="3a7ad1055953cf587ab781a3bc1fc4c9129cc265" translate="yes" xml:space="preserve">
          <source>The default built-in transaction script (also invoked with &lt;code&gt;-b tpcb-like&lt;/code&gt;) issues seven commands per transaction over randomly chosen &lt;code&gt;aid&lt;/code&gt;, &lt;code&gt;tid&lt;/code&gt;, &lt;code&gt;bid&lt;/code&gt; and &lt;code&gt;delta&lt;/code&gt;. The scenario is inspired by the TPC-B benchmark, but is not actually TPC-B, hence the name.</source>
          <target state="translated">默认的内置事务脚本（也与 &lt;code&gt;-b tpcb-like&lt;/code&gt; 一起调用）针对每个事务在随机选择的 &lt;code&gt;aid&lt;/code&gt; ， &lt;code&gt;tid&lt;/code&gt; ， &lt;code&gt;bid&lt;/code&gt; 和 &lt;code&gt;delta&lt;/code&gt; 上发出七个命令。该方案的灵感来自TPC-B基准，但实际上不是TPC-B，因此得名。</target>
        </trans-unit>
        <trans-unit id="23125fde28fb9f59764dcf1b23a280a89053eb88" translate="yes" xml:space="preserve">
          <source>The default database privilege system allows database superusers to modify system catalogs using DML commands, and reference or modify toast tables. These operations are prohibited when &lt;code&gt;sepgsql&lt;/code&gt; is enabled.</source>
          <target state="translated">默认的数据库特权系统允许数据库超级用户使用DML命令修改系统目录，并引用或修改Toast表。启用 &lt;code&gt;sepgsql&lt;/code&gt; 时，将禁止这些操作。</target>
        </trans-unit>
        <trans-unit id="bc78e0117d012c08a955c11c85e0b86286d746a5" translate="yes" xml:space="preserve">
          <source>The default expression will be used in any insert operation that does not specify a value for the column. If a default value is defined for a particular column, it overrides any default associated with the domain. In turn, the domain default overrides any default value associated with the underlying data type.</source>
          <target state="translated">默认表达式将用于任何没有为列指定值的插入操作。如果为某一列定义了一个默认值,它将覆盖与域相关联的任何默认值。反过来,域默认值也会覆盖与底层数据类型相关联的任何默认值。</target>
        </trans-unit>
        <trans-unit id="e924dec24aeaf46efa87502acfc94f6cc77685ce" translate="yes" xml:space="preserve">
          <source>The default expression will be used in any insert operation that does not specify a value for the column. If there is no default for a column, then the default is null.</source>
          <target state="translated">在任何没有为列指定值的插入操作中,将使用默认表达式。如果没有指定列的默认值,那么默认值为空。</target>
        </trans-unit>
        <trans-unit id="5c475e2d48f46531de3913f26ad3045b4e6daa74" translate="yes" xml:space="preserve">
          <source>The default framing option is &lt;code&gt;RANGE UNBOUNDED PRECEDING&lt;/code&gt;, which is the same as &lt;code&gt;RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW&lt;/code&gt;. With &lt;code&gt;ORDER BY&lt;/code&gt;, this sets the frame to be all rows from the partition start up through the current row's last &lt;code&gt;ORDER BY&lt;/code&gt; peer. Without &lt;code&gt;ORDER BY&lt;/code&gt;, this means all rows of the partition are included in the window frame, since all rows become peers of the current row.</source>
          <target state="translated">默认的成帧选项是&amp;ldquo; &lt;code&gt;RANGE UNBOUNDED PRECEDING&lt;/code&gt; &amp;rdquo;，与&amp;ldquo; &lt;code&gt;RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW&lt;/code&gt; 相同。使用 &lt;code&gt;ORDER BY&lt;/code&gt; ，这会将帧设置为从分区开始到当前行的最后一个 &lt;code&gt;ORDER BY&lt;/code&gt; 对等点的所有行。如果没有 &lt;code&gt;ORDER BY&lt;/code&gt; ，则意味着该分区的所有行都包含在窗口框架中，因为所有行都成为当前行的对等方。</target>
        </trans-unit>
        <trans-unit id="ab9ba2008544bbedbbd493b6d70ae946d72bc7ec" translate="yes" xml:space="preserve">
          <source>The default framing option is &lt;code&gt;RANGE UNBOUNDED PRECEDING&lt;/code&gt;, which is the same as &lt;code&gt;RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW&lt;/code&gt;; it sets the frame to be all rows from the partition start up through the current row's last &lt;em&gt;peer&lt;/em&gt; (a row that the window's &lt;code&gt;ORDER BY&lt;/code&gt; clause considers equivalent to the current row; all rows are peers if there is no &lt;code&gt;ORDER BY&lt;/code&gt;). In general, &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt; means that the frame starts with the first row of the partition, and similarly &lt;code&gt;UNBOUNDED FOLLOWING&lt;/code&gt; means that the frame ends with the last row of the partition, regardless of &lt;code&gt;RANGE&lt;/code&gt;, &lt;code&gt;ROWS&lt;/code&gt; or &lt;code&gt;GROUPS&lt;/code&gt; mode. In &lt;code&gt;ROWS&lt;/code&gt; mode, &lt;code&gt;CURRENT ROW&lt;/code&gt; means that the frame starts or ends with the current row; but in &lt;code&gt;RANGE&lt;/code&gt; or &lt;code&gt;GROUPS&lt;/code&gt; mode it means that the frame starts or ends with the current row's first or last peer in the &lt;code&gt;ORDER BY&lt;/code&gt; ordering. The &lt;code&gt;offset&lt;/code&gt;&lt;code&gt;PRECEDING&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt;&lt;code&gt;FOLLOWING&lt;/code&gt; options vary in meaning depending on the frame mode. In &lt;code&gt;ROWS&lt;/code&gt; mode, the &lt;code&gt;offset&lt;/code&gt; is an integer indicating that the frame starts or ends that many rows before or after the current row. In &lt;code&gt;GROUPS&lt;/code&gt; mode, the &lt;code&gt;offset&lt;/code&gt; is an integer indicating that the frame starts or ends that many peer groups before or after the current row's peer group, where a &lt;em&gt;peer group&lt;/em&gt; is a group of rows that are equivalent according to the window's &lt;code&gt;ORDER BY&lt;/code&gt; clause. In &lt;code&gt;RANGE&lt;/code&gt; mode, use of an &lt;code&gt;offset&lt;/code&gt; option requires that there be exactly one &lt;code&gt;ORDER BY&lt;/code&gt; column in the window definition. Then the frame contains those rows whose ordering column value is no more than &lt;code&gt;offset&lt;/code&gt; less than (for &lt;code&gt;PRECEDING&lt;/code&gt;) or more than (for &lt;code&gt;FOLLOWING&lt;/code&gt;) the current row's ordering column value. In these cases the data type of the &lt;code&gt;offset&lt;/code&gt; expression depends on the data type of the ordering column. For numeric ordering columns it is typically of the same type as the ordering column, but for datetime ordering columns it is an &lt;code&gt;interval&lt;/code&gt;. In all these cases, the value of the &lt;code&gt;offset&lt;/code&gt; must be non-null and non-negative. Also, while the &lt;code&gt;offset&lt;/code&gt; does not have to be a simple constant, it cannot contain variables, aggregate functions, or window functions.</source>
          <target state="translated">默认的成帧选项是 &lt;code&gt;RANGE UNBOUNDED PRECEDING&lt;/code&gt; ，与 &lt;code&gt;RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW&lt;/code&gt; 相同;它将帧设置为从分区开始到当前行的最后一个&lt;em&gt;对等点的&lt;/em&gt;所有行（窗口的 &lt;code&gt;ORDER BY&lt;/code&gt; 子句认为与当前行等效的行；如果没有 &lt;code&gt;ORDER BY&lt;/code&gt; ，则所有行都是对等的）。通常， &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt; 表示帧以分区的第一行开始，类似地 &lt;code&gt;UNBOUNDED FOLLOWING&lt;/code&gt; 表示帧以分区的最后一行结束，而不考虑 &lt;code&gt;RANGE&lt;/code&gt; ， &lt;code&gt;ROWS&lt;/code&gt; 或 &lt;code&gt;GROUPS&lt;/code&gt; 模式。在 &lt;code&gt;ROWS&lt;/code&gt; 模式下， &lt;code&gt;CURRENT ROW&lt;/code&gt; 表示帧以当前行开始或结束；但在 &lt;code&gt;RANGE&lt;/code&gt; 或 &lt;code&gt;GROUPS&lt;/code&gt; 模式下，则表示帧以 &lt;code&gt;ORDER BY&lt;/code&gt; 顺序中当前行的第一个或最后一个对等点开始或结束。的 &lt;code&gt;offset&lt;/code&gt; &lt;code&gt;PRECEDING&lt;/code&gt; 和 &lt;code&gt;offset&lt;/code&gt; &lt;code&gt;FOLLOWING&lt;/code&gt; 选项根据帧模式意义而变化。在 &lt;code&gt;ROWS&lt;/code&gt; 模式下， &lt;code&gt;offset&lt;/code&gt; 是一个整数，指示帧在当前行之前或之后的许多行开始或结束。在 &lt;code&gt;GROUPS&lt;/code&gt; 模式下， &lt;code&gt;offset&lt;/code&gt; 是一个整数，指示该帧在当前行的对等组之前或之后开始或结束许多对等组，其中，&lt;em&gt;对等组&lt;/em&gt;是根据窗口的 &lt;code&gt;ORDER BY&lt;/code&gt; 子句等效的一组行。在 &lt;code&gt;RANGE&lt;/code&gt; 模式下，使用 &lt;code&gt;offset&lt;/code&gt; 选项要求窗口定义中仅包含一个 &lt;code&gt;ORDER BY&lt;/code&gt; 列。然后，框架包含那些其排序列值不大于 &lt;code&gt;offset&lt;/code&gt; 小于 &lt;code&gt;PRECEDING&lt;/code&gt; ）或大于（对于 &lt;code&gt;FOLLOWING&lt;/code&gt; ）当前行的排序列值的行。在这些情况下， &lt;code&gt;offset&lt;/code&gt; 的数据类型表达式取决于排序列的数据类型。对于数字排序列，它通常与排序列的类型相同，但是对于日期时间排序列，它是一个 &lt;code&gt;interval&lt;/code&gt; 。在所有这些情况下， &lt;code&gt;offset&lt;/code&gt; 的值必须为非空且非负。同样，虽然 &lt;code&gt;offset&lt;/code&gt; 不必是简单的常量，但它不能包含变量，聚合函数或窗口函数。</target>
        </trans-unit>
        <trans-unit id="02427aea9e6cc1534ffa5badcc166ebd495d7d99" translate="yes" xml:space="preserve">
          <source>The default initialization behavior uses client-side data generation (equivalent to &lt;code&gt;g&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="585bb809ddf49c27ccd679a2aefbbe26ae6b7fc7" translate="yes" xml:space="preserve">
          <source>The default is 1 on supported systems, otherwise 0. This value can be overridden for tables in a particular tablespace by setting the tablespace parameter of the same name (see &lt;a href=&quot;sql-altertablespace&quot;&gt;ALTER TABLESPACE&lt;/a&gt;).</source>
          <target state="translated">在受支持的系统上，默认值为1，否则为0。可以通过设置相同名称的表空间参数来覆盖特定表空间中的表的该值（请参阅&lt;a href=&quot;sql-altertablespace&quot;&gt;ALTER TABLESPACE&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b428941637c56ecacd6f3388f30af9a9f66c9397" translate="yes" xml:space="preserve">
          <source>The default is 10 on supported systems, otherwise 0. This value can be overridden for tables in a particular tablespace by setting the tablespace parameter of the same name (see &lt;a href=&quot;sql-altertablespace&quot;&gt;ALTER TABLESPACE&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e91abeb434a6ce9f069e1f28ad61aa04fc26c2bb" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;+&lt;/code&gt; on Unix systems (corresponding to the default editor &lt;code&gt;vi&lt;/code&gt;, and useful for many other common editors); but there is no default on Windows systems.</source>
          <target state="translated">在Unix系统上，默认值为 &lt;code&gt;+&lt;/code&gt; （对应于默认编辑器 &lt;code&gt;vi&lt;/code&gt; ，对许多其他常用编辑器很有用）；但Windows系统上没有默认设置。</target>
        </trans-unit>
        <trans-unit id="20bd35f00ae043441f0cf7d67ea091592c87a851" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;CONTENT&lt;/code&gt;, so all forms of XML data are allowed.</source>
          <target state="translated">默认值为 &lt;code&gt;CONTENT&lt;/code&gt; ，因此允许所有形式的XML数据。</target>
        </trans-unit>
        <trans-unit id="a9030ed63211ad93fd21a5052bbbc9ec44c66fe7" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;TLSv1.2&lt;/code&gt;, which satisfies industry best practices as of this writing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="520d36bf5a7163373f8a236d77b263a2c0a04d44" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;TLSv1&lt;/code&gt;, mainly to support older versions of the OpenSSL library. You might want to set this to a higher value if all software components can support the newer protocol versions.</source>
          <target state="translated">默认值为 &lt;code&gt;TLSv1&lt;/code&gt; ，主要是为了支持较旧版本的OpenSSL库。如果所有软件组件都可以支持较新的协议版本，则可能需要将此值设置为更高的值。</target>
        </trans-unit>
        <trans-unit id="231c42f70ffe5e8ab4244e5bdc8f6dbabaa3b107" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;none&lt;/code&gt;. Only superusers can change this setting.</source>
          <target state="translated">默认值为 &lt;code&gt;none&lt;/code&gt; 。只有超级用户可以更改此设置。</target>
        </trans-unit>
        <trans-unit id="bd107bd07370addfaeb12f86e3bf6c56137f5dc1" translate="yes" xml:space="preserve">
          <source>The default is simple query protocol. (See &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol.html&quot;&gt;Chapter 52&lt;/a&gt; for more information.)</source>
          <target state="translated">默认为简单查询协议。（有关更多信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/protocol.html&quot;&gt;第52章&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="4a4b29d9014d7b5f69a6f2afb601d3ce7d3550d2" translate="yes" xml:space="preserve">
          <source>The default is simple query protocol. (See &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol.html&quot;&gt;Chapter 52&lt;/a&gt; for more information.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6f72dd6acfbb83ab51b40e408e5dc009e36a5da" translate="yes" xml:space="preserve">
          <source>The default maximum segment size is 32 MB, and the default maximum total size is 2097152 pages. A page is almost always 4096 bytes except in unusual kernel configurations with &amp;ldquo;huge pages&amp;rdquo; (use &lt;code&gt;getconf PAGE_SIZE&lt;/code&gt; to verify).</source>
          <target state="translated">默认的最大段大小为32 MB，默认的最大总大小为2097152页。一个页面几乎总是4096字节，除非在具有&amp;ldquo;巨大页面&amp;rdquo;的异常内核配置中使用（使用 &lt;code&gt;getconf PAGE_SIZE&lt;/code&gt; 进行验证）。</target>
        </trans-unit>
        <trans-unit id="d525664dcf3bd05b109fdf34118093a16b891bcb" translate="yes" xml:space="preserve">
          <source>The default permissions are &lt;code&gt;0600&lt;/code&gt;, meaning only the server owner can read or write the log files. The other commonly useful setting is &lt;code&gt;0640&lt;/code&gt;, allowing members of the owner's group to read the files. Note however that to make use of such a setting, you'll need to alter &lt;a href=&quot;runtime-config-logging#GUC-LOG-DIRECTORY&quot;&gt;log_directory&lt;/a&gt; to store the files somewhere outside the cluster data directory. In any case, it's unwise to make the log files world-readable, since they might contain sensitive data.</source>
          <target state="translated">默认权限是 &lt;code&gt;0600&lt;/code&gt; ，这意味着只有服务器所有者才能读取或写入日志文件。另一个常用的设置是 &lt;code&gt;0640&lt;/code&gt; ，允许所有者组的成员读取文件。但是请注意，要使用这样的设置，您需要更改&lt;a href=&quot;runtime-config-logging#GUC-LOG-DIRECTORY&quot;&gt;log_directory&lt;/a&gt;以将文件存储在集群数据目录之外的某个位置。无论如何，使日志文件具有全球可读性是不明智的，因为它们可能包含敏感数据。</target>
        </trans-unit>
        <trans-unit id="d2132a47fb8ed97625d8e6972b86c9c464704580" translate="yes" xml:space="preserve">
          <source>The default permissions are &lt;code&gt;0777&lt;/code&gt;, meaning anyone can connect. Reasonable alternatives are &lt;code&gt;0770&lt;/code&gt; (only user and group, see also &lt;code&gt;unix_socket_group&lt;/code&gt;) and &lt;code&gt;0700&lt;/code&gt; (only user). (Note that for a Unix-domain socket, only write permission matters, so there is no point in setting or revoking read or execute permissions.)</source>
          <target state="translated">默认权限是 &lt;code&gt;0777&lt;/code&gt; ，这意味着任何人都可以连接。合理的选择是 &lt;code&gt;0770&lt;/code&gt; （仅用户和组，另请参见 &lt;code&gt;unix_socket_group&lt;/code&gt; ）和 &lt;code&gt;0700&lt;/code&gt; （仅用户）。（请注意，对于Unix域套接字，仅写权限很重要，因此设置或撤消读或执行权限毫无意义。）</target>
        </trans-unit>
        <trans-unit id="68b85b4979bd5c75a82926a217579dec94acad6f" translate="yes" xml:space="preserve">
          <source>The default roles are described in &lt;a href=&quot;default-roles#DEFAULT-ROLES-TABLE&quot;&gt;Table 21.1&lt;/a&gt;. Note that the specific permissions for each of the default roles may change in the future as additional capabilities are added. Administrators should monitor the release notes for changes.</source>
          <target state="translated">&lt;a href=&quot;default-roles#DEFAULT-ROLES-TABLE&quot;&gt;表21.1&lt;/a&gt;中描述了默认角色。请注意，随着其他功能的添加，将来每个默认角色的特定权限可能会更改。管理员应监视发行说明中的​​更改。</target>
        </trans-unit>
        <trans-unit id="252df4a98d09d9259c2e1911dffde240009cf803" translate="yes" xml:space="preserve">
          <source>The default set of collations provided by &lt;code&gt;libc&lt;/code&gt; map directly to the locales installed in the operating system, which can be listed using the command &lt;code&gt;locale -a&lt;/code&gt;. In case a &lt;code&gt;libc&lt;/code&gt; collation is needed that has different values for &lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt;, or if new locales are installed in the operating system after the database system was initialized, then a new collation may be created using the &lt;a href=&quot;sql-createcollation&quot;&gt;CREATE COLLATION&lt;/a&gt; command. New operating system locales can also be imported en masse using the &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-COLLATION&quot;&gt;&lt;code&gt;pg_import_system_collations()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;code&gt;libc&lt;/code&gt; 提供的默认排序规则集直接映射到操作系统中安装的语言环境，可以使用命令 &lt;code&gt;locale -a&lt;/code&gt; 列出这些语言环境。如果需要一个 &lt;code&gt;libc&lt;/code&gt; 排序规则，其 &lt;code&gt;LC_COLLATE&lt;/code&gt; 和 &lt;code&gt;LC_CTYPE&lt;/code&gt; 的值不同，或者如果初始化数据库系统后在操作系统中安装了新的语言环境，则可以使用&lt;a href=&quot;sql-createcollation&quot;&gt;CREATE COLLATION&lt;/a&gt;命令创建一个新的排序规则。也可以使用&lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-COLLATION&quot;&gt; &lt;code&gt;pg_import_system_collations()&lt;/code&gt; &lt;/a&gt;函数整体导入新的操作系统语言环境。</target>
        </trans-unit>
        <trans-unit id="bd6c5d1d773597e919f54fc6c40b0813dfeb2846" translate="yes" xml:space="preserve">
          <source>The default settings tend to suffice for normal installations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fa3c32f18b7a363e1e30df22bf5f90a31fa97a8" translate="yes" xml:space="preserve">
          <source>The default settings tend to suffice for normal installations. On HP-UX 10, the factory default for &lt;code&gt;SEMMNS&lt;/code&gt; is 128, which might be too low for larger database sites.</source>
          <target state="translated">默认设置通常足以满足常规安装的需要。在HP-UX 10上， &lt;code&gt;SEMMNS&lt;/code&gt; 的出厂默认值为128，对于较大的数据库站点来说可能太低了。</target>
        </trans-unit>
        <trans-unit id="387f794e89c6e468e480bdf4684dee520f1e3ee6" translate="yes" xml:space="preserve">
          <source>The default shared memory and semaphore settings are usually good enough for most PostgreSQL applications. Solaris defaults to a &lt;code&gt;SHMMAX&lt;/code&gt; of one-quarter of system RAM. To further adjust this setting, use a project setting associated with the &lt;code&gt;postgres&lt;/code&gt; user. For example, run the following as &lt;code&gt;root&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f84f4a393cffab388bec3988211dd06baa8b6f3" translate="yes" xml:space="preserve">
          <source>The default shared memory and semaphore settings are usually good enough, unless you have set &lt;code&gt;shared_memory_type&lt;/code&gt; to &lt;code&gt;sysv&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8182b5b7aff519b85fd1a2180f16c9dae4671198" translate="yes" xml:space="preserve">
          <source>The default shared memory settings are usually good enough, unless you have set &lt;code&gt;shared_memory_type&lt;/code&gt; to &lt;code&gt;sysv&lt;/code&gt;, and even then only on older kernel versions that shipped with low defaults. System V semaphores are not used on this platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb304375b17e288f6f388651b3f58cf692da39fb" translate="yes" xml:space="preserve">
          <source>The default shared memory settings are usually good enough, unless you have set &lt;code&gt;shared_memory_type&lt;/code&gt; to &lt;code&gt;sysv&lt;/code&gt;. System V semaphores are not used on this platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4af5ef9d1d5b1be0577de1bcf13eca580f5485e" translate="yes" xml:space="preserve">
          <source>The default shared memory settings are usually good enough, unless you have set &lt;code&gt;shared_memory_type&lt;/code&gt; to &lt;code&gt;sysv&lt;/code&gt;. You will usually want to increase &lt;code&gt;kern.ipc.semmni&lt;/code&gt; and &lt;code&gt;kern.ipc.semmns&lt;/code&gt;, as NetBSD's default settings for these are uncomfortably small.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5adefc1dbffba745f0ea181ce26972df7feee97e" translate="yes" xml:space="preserve">
          <source>The default shared memory settings are usually good enough, unless you have set &lt;code&gt;shared_memory_type&lt;/code&gt; to &lt;code&gt;sysv&lt;/code&gt;. You will usually want to increase &lt;code&gt;kern.seminfo.semmni&lt;/code&gt; and &lt;code&gt;kern.seminfo.semmns&lt;/code&gt;, as OpenBSD's default settings for these are uncomfortably small.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44e22ca1caa169ea01c4c21799c6c36ccb13234f" translate="yes" xml:space="preserve">
          <source>The default tablespace for the database. Within this database, all tables for which &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;reltablespace&lt;/code&gt; is zero will be stored in this tablespace; in particular, all the non-shared system catalogs will be there.</source>
          <target state="translated">数据库的默认表空间。在此数据库中，包含 &lt;code&gt;pg_class&lt;/code&gt; 的所有表。 &lt;code&gt;reltablespace&lt;/code&gt; 为零将存储在此表空间中；特别是，所有非共享系统目录都将存在。</target>
        </trans-unit>
        <trans-unit id="80289ade38539d0a5fbe52bfa6a8f6f1dac442e4" translate="yes" xml:space="preserve">
          <source>The default test scenario is also quite sensitive to how long it's been since the tables were initialized: accumulation of dead rows and dead space in the tables changes the results. To understand the results you must keep track of the total number of updates and when vacuuming happens. If autovacuum is enabled it can result in unpredictable changes in measured performance.</source>
          <target state="translated">默认的测试方案对表被初始化后的时间也相当敏感:表中死行和死空间的积累会改变结果。为了了解结果,你必须跟踪更新的总次数和吸尘发生的时间。如果启用了自动吸尘,可能会导致测量的性能发生不可预知的变化。</target>
        </trans-unit>
        <trans-unit id="9132263848d1108e0d8602af59d87e147d73248d" translate="yes" xml:space="preserve">
          <source>The default thresholds and scale factors are taken from &lt;code&gt;postgresql.conf&lt;/code&gt;, but it is possible to override them (and many other autovacuum control parameters) on a per-table basis; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt; for more information. If a setting has been changed via a table's storage parameters, that value is used when processing that table; otherwise the global settings are used. See &lt;a href=&quot;runtime-config-autovacuum&quot;&gt;Section 19.10&lt;/a&gt; for more details on the global settings.</source>
          <target state="translated">默认阈值和比例因子取自 &lt;code&gt;postgresql.conf&lt;/code&gt; ，但是可以按表覆盖它们（以及许多其他自动真空控制参数）；有关更多信息，请参见&lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;存储参数&lt;/a&gt;。如果通过表的存储参数更改了设置，则在处理该表时将使用该值；否则，将使用该值。否则，将使用全局设置。有关全局设置的更多详细信息，请参见&lt;a href=&quot;runtime-config-autovacuum&quot;&gt;第19.10节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0424e3dc5096d9c8dbd34cb8d06e5315c54e045d" translate="yes" xml:space="preserve">
          <source>The default time zone is specified as a constant numeric offset from UTC. It is therefore impossible to adapt to daylight-saving time when doing date/time arithmetic across DST boundaries.</source>
          <target state="translated">默认时区被指定为UTC的常数偏移。因此,在跨DST边界进行日期/时间运算时,无法适应夏令时。</target>
        </trans-unit>
        <trans-unit id="cfbfb39fe00c30f34ca2449d77325fd4667682f6" translate="yes" xml:space="preserve">
          <source>The default timing of the trigger. See the &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; documentation for details of these constraint options. This can only be specified for constraint triggers.</source>
          <target state="translated">触发器的默认计时。有关这些约束选项的详细信息，请参见&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;文档。这只能为约束触发器指定。</target>
        </trans-unit>
        <trans-unit id="d7cc14aa1c7871e1d91e9c6189dd189cdc4b1317" translate="yes" xml:space="preserve">
          <source>The default value can be an expression, which will be evaluated whenever the default value is inserted (&lt;em&gt;not&lt;/em&gt; when the table is created). A common example is for a &lt;code&gt;timestamp&lt;/code&gt; column to have a default of &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt;, so that it gets set to the time of row insertion. Another common example is generating a &amp;ldquo;serial number&amp;rdquo; for each row. In PostgreSQL this is typically done by something like:</source>
          <target state="translated">默认值可以是一个表达式，只要插入默认值（&lt;em&gt;不在&lt;/em&gt;创建表时），便会对其求值。一个常见的示例是， &lt;code&gt;timestamp&lt;/code&gt; 列的默认值为 &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt; ，以便将其设置为行插入的时间。另一个常见的示例是为每一行生成一个&amp;ldquo;序列号&amp;rdquo;。在PostgreSQL中，这通常通过以下方式完成：</target>
        </trans-unit>
        <trans-unit id="0b0db30e831b0c9d520dd21139ba84ee034c9c6b" translate="yes" xml:space="preserve">
          <source>The default value for the data type. If this is omitted, the default is null.</source>
          <target state="translated">数据类型的默认值。如果省略,则默认为空。</target>
        </trans-unit>
        <trans-unit id="ee14fce3a3ca851f605a2ff7d5b6a51a01fb240b" translate="yes" xml:space="preserve">
          <source>The default value for this parameter is &lt;code&gt;&quot;$user&quot;, public&lt;/code&gt;. This setting supports shared use of a database (where no users have private schemas, and all share use of &lt;code&gt;public&lt;/code&gt;), private per-user schemas, and combinations of these. Other effects can be obtained by altering the default search path setting, either globally or per-user.</source>
          <target state="translated">此参数的默认值为 &lt;code&gt;&quot;$user&quot;, public&lt;/code&gt; 。此设置支持共享使用数据库（没有用户拥有私有模式，并且所有用户都共享使用 &lt;code&gt;public&lt;/code&gt; ），私有每用户模式以及这些的组合。通过更改全局或每个用户的默认搜索路径设置，可以获得其他效果。</target>
        </trans-unit>
        <trans-unit id="85d16eca710f45efd17caf29c22cdac95ac6757a" translate="yes" xml:space="preserve">
          <source>The default value for this parameter is &lt;code&gt;'$libdir'&lt;/code&gt;. If the value is set to an empty string, the automatic path search is turned off.</source>
          <target state="translated">此参数的默认值为 &lt;code&gt;'$libdir'&lt;/code&gt; 。如果该值设置为空字符串，则自动路径搜索将关闭。</target>
        </trans-unit>
        <trans-unit id="71d008eed3fec13080aed7c6d124a51c1f2df8b8" translate="yes" xml:space="preserve">
          <source>The default value is 2.</source>
          <target state="translated">默认值为2。</target>
        </trans-unit>
        <trans-unit id="d8e9c33db68a29a970a8558f211b5f4b07ef1edd" translate="yes" xml:space="preserve">
          <source>The default value is 4.</source>
          <target state="translated">默认值为4。</target>
        </trans-unit>
        <trans-unit id="65c175fa9341b5e979c73accbe6240cd619cd0dc" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;error=01;31:warning=01;35:locus=01&lt;/code&gt; (&lt;code&gt;01;31&lt;/code&gt; = bold red, &lt;code&gt;01;35&lt;/code&gt; = bold magenta, &lt;code&gt;01&lt;/code&gt; = bold default color).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca161bfe7f68575f9b78d9b22cc20c4f61990ca6" translate="yes" xml:space="preserve">
          <source>The default value is an empty string, which results in all temporary objects being created in the default tablespace of the current database.</source>
          <target state="translated">默认值是一个空字符串,其结果是在当前数据库的默认表空间中创建所有临时对象。</target>
        </trans-unit>
        <trans-unit id="2dbc96deb9627171cbe40ca7523d55ca78505616" translate="yes" xml:space="preserve">
          <source>The default value is defined as the value that the parameter would have had, if no &lt;code&gt;SET&lt;/code&gt; had ever been issued for it in the current session. The actual source of this value might be a compiled-in default, the configuration file, command-line options, or per-database or per-user default settings. This is subtly different from defining it as &amp;ldquo;the value that the parameter had at session start&amp;rdquo;, because if the value came from the configuration file, it will be reset to whatever is specified by the configuration file now. See &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; for details.</source>
          <target state="translated">如果在当前会话中没有为其发出 &lt;code&gt;SET&lt;/code&gt; ，则默认值定义为该参数应具有的值。该值的实际来源可能是内置的默认值，配置文件，命令行选项，或者是每个数据库或每个用户的默认设置。这与将其定义为&amp;ldquo;参数在会话启动时具有的值&amp;rdquo;有细微的区别，因为如果该值来自配置文件，则它将被重置为配置文件现在指定的值。有关详细信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;第19章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="04f2d094b00a5be29b7b3b7af554f26ca4e00d68" translate="yes" xml:space="preserve">
          <source>The default value is defined as the value that the parameter would have had, if no &lt;code&gt;SET&lt;/code&gt; had ever been issued for it in the current session. The actual source of this value might be a compiled-in default, the configuration file, command-line options, or per-database or per-user default settings. This is subtly different from defining it as &amp;ldquo;the value that the parameter had at session start&amp;rdquo;, because if the value came from the configuration file, it will be reset to whatever is specified by the configuration file now. See &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7169dc9a643791bfe51c929b266f11a33c289429" translate="yes" xml:space="preserve">
          <source>The default value is three connections. The value must be less than &lt;code&gt;max_connections&lt;/code&gt;. This parameter can only be set at server start.</source>
          <target state="translated">默认值为三个连接。该值必须小于 &lt;code&gt;max_connections&lt;/code&gt; 。该参数只能在服务器启动时设置。</target>
        </trans-unit>
        <trans-unit id="72f22d9e98b0402b3ffa342734437db31335a193" translate="yes" xml:space="preserve">
          <source>The default value of this setting is the empty string, which disables the feature. It can be set to &lt;code&gt;all&lt;/code&gt; to check all records, or to a comma-separated list of resource managers to check only records originating from those resource managers. Currently, the supported resource managers are &lt;code&gt;heap&lt;/code&gt;, &lt;code&gt;heap2&lt;/code&gt;, &lt;code&gt;btree&lt;/code&gt;, &lt;code&gt;hash&lt;/code&gt;, &lt;code&gt;gin&lt;/code&gt;, &lt;code&gt;gist&lt;/code&gt;, &lt;code&gt;sequence&lt;/code&gt;, &lt;code&gt;spgist&lt;/code&gt;, &lt;code&gt;brin&lt;/code&gt;, and &lt;code&gt;generic&lt;/code&gt;. Only superusers can change this setting.</source>
          <target state="translated">此设置的默认值为空字符串，该字符串将禁用该功能。可以将其设置为 &lt;code&gt;all&lt;/code&gt; 以检查所有记录，也可以将其设置为以逗号分隔的资源管理器列表以仅检查源自那些资源管理器的记录。当前，受支持的资源管理器是 &lt;code&gt;heap&lt;/code&gt; ， &lt;code&gt;heap2&lt;/code&gt; ， &lt;code&gt;btree&lt;/code&gt; ， &lt;code&gt;hash&lt;/code&gt; ， &lt;code&gt;gin&lt;/code&gt; ， &lt;code&gt;gist&lt;/code&gt; ， &lt;code&gt;sequence&lt;/code&gt; ， &lt;code&gt;spgist&lt;/code&gt; ， &lt;code&gt;brin&lt;/code&gt; 和 &lt;code&gt;generic&lt;/code&gt; 。只有超级用户可以更改此设置。</target>
        </trans-unit>
        <trans-unit id="20ab73f20d81504384efda8f5568618702ec519f" translate="yes" xml:space="preserve">
          <source>The default virtual memory behavior on Linux is not optimal for PostgreSQL. Because of the way that the kernel implements memory overcommit, the kernel might terminate the PostgreSQL postmaster (the master server process) if the memory demands of either PostgreSQL or another process cause the system to run out of virtual memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd9068090248fdb711a8f2a412ca5077ebbda170" translate="yes" xml:space="preserve">
          <source>The defined collation of the column, or zero if the column is not of a collatable data type.</source>
          <target state="translated">列的定义整理,如果列不是可整理的数据类型,则为零。</target>
        </trans-unit>
        <trans-unit id="b0e121be440089b477e6ea25c5d7cb8d2a246664" translate="yes" xml:space="preserve">
          <source>The definitions of the columns exposed by the view are shown in &lt;a href=&quot;pgbuffercache#PGBUFFERCACHE-COLUMNS&quot;&gt;Table F.15&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pgbuffercache#PGBUFFERCACHE-COLUMNS&quot;&gt;表F.15&lt;/a&gt;中显示了该视图公开的列的定义。</target>
        </trans-unit>
        <trans-unit id="a8c0177656a1475222b9e9f01f048f945368cb6d" translate="yes" xml:space="preserve">
          <source>The delay occurs once the database in recovery has reached a consistent state, until the standby is promoted or triggered. After that the standby will end recovery without further waiting.</source>
          <target state="translated">一旦恢复中的数据库达到一致状态,就会发生延迟,直到待机被推广或触发。之后,待机将结束恢复,无需再等待。</target>
        </trans-unit>
        <trans-unit id="37c54600b84522926deb2fb64ab7c8c51ddae0fc" translate="yes" xml:space="preserve">
          <source>The delay occurs only on WAL records for transaction commits. Other records are replayed as quickly as possible, which is not a problem because MVCC visibility rules ensure their effects are not visible until the corresponding commit record is applied.</source>
          <target state="translated">延迟只发生在事务提交的WAL记录上。其他记录会尽快重放,这不是问题,因为MVCC的可见性规则确保在应用相应的提交记录之前,它们的影响不可见。</target>
        </trans-unit>
        <trans-unit id="790720978a39aefa71d264470fa610449c099e01" translate="yes" xml:space="preserve">
          <source>The delimiter character to be used between values in arrays made of this type.</source>
          <target state="translated">在这种类型的数组中的值之间使用的定界符。</target>
        </trans-unit>
        <trans-unit id="e3f72476c5f4c3f27d14849d70a712b70cac2da9" translate="yes" xml:space="preserve">
          <source>The dependent object can be dropped separately from the referenced object, and should be automatically dropped (regardless of &lt;code&gt;RESTRICT&lt;/code&gt; or &lt;code&gt;CASCADE&lt;/code&gt; mode) if the referenced object is dropped. Example: a named constraint on a table is made auto-dependent on the table, so that it will go away if the table is dropped.</source>
          <target state="translated">可以从参考对象中单独删除依赖对象，如果删除了参考对象，则应将其自动删除（无论 &lt;code&gt;RESTRICT&lt;/code&gt; 或 &lt;code&gt;CASCADE&lt;/code&gt; 模式）。示例：使表上的命名约束自动依赖于表，因此如果删除表，它将消失。</target>
        </trans-unit>
        <trans-unit id="42b52b99ac2341cf62bd00d9b5e1bc3f8c4f0ef2" translate="yes" xml:space="preserve">
          <source>The dependent object is a member of the &lt;em&gt;extension&lt;/em&gt; that is the referenced object (see &lt;a href=&quot;catalog-pg-extension&quot;&gt;&lt;code&gt;pg_extension&lt;/code&gt;&lt;/a&gt;). The dependent object can be dropped only via &lt;code&gt;DROP EXTENSION&lt;/code&gt; on the referenced object. Functionally this dependency type acts the same as an &lt;code&gt;INTERNAL&lt;/code&gt; dependency, but it's kept separate for clarity and to simplify pg_dump.</source>
          <target state="translated">从属对象是作为引用对象的&lt;em&gt;扩展&lt;/em&gt;的成员（请参见&lt;a href=&quot;catalog-pg-extension&quot;&gt; &lt;code&gt;pg_extension&lt;/code&gt; &lt;/a&gt;）。仅可以通过对引用对象的 &lt;code&gt;DROP EXTENSION&lt;/code&gt; 删除从属对象。从功能上讲，此依赖类型与 &lt;code&gt;INTERNAL&lt;/code&gt; 依赖相同，但为了清楚起见并简化pg_dump，将其分开。</target>
        </trans-unit>
        <trans-unit id="bf57c8a0f5e570bb9686592bde8b3b28f101a435" translate="yes" xml:space="preserve">
          <source>The dependent object is not a member of the extension that is the referenced object (and so it should not be ignored by pg_dump), but it cannot function without the extension and should be auto-dropped if the extension is. The dependent object may be dropped on its own as well. Functionally this dependency type acts the same as an &lt;code&gt;AUTO&lt;/code&gt; dependency, but it's kept separate for clarity and to simplify pg_dump.</source>
          <target state="translated">从属对象不是作为引用对象的扩展的成员（因此，它不应被pg_dump忽略），但是如果没有扩展，它就无法起作用，如果扩展是扩展名，则应将其自动删除。依赖对象也可以自行删除。从功能上说，此依赖类型与 &lt;code&gt;AUTO&lt;/code&gt; 依赖相同，但为了清楚起见和简化pg_dump，将其分开。</target>
        </trans-unit>
        <trans-unit id="39aa74188fe1f062ac474926c65191d5babb5508" translate="yes" xml:space="preserve">
          <source>The dependent object was created as part of creation of the referenced object, and is really just a part of its internal implementation. A direct &lt;code&gt;DROP&lt;/code&gt; of the dependent object will be disallowed outright (we'll tell the user to issue a &lt;code&gt;DROP&lt;/code&gt; against the referenced object, instead). A &lt;code&gt;DROP&lt;/code&gt; of the referenced object will result in automatically dropping the dependent object whether &lt;code&gt;CASCADE&lt;/code&gt; is specified or not. If the dependent object has to be dropped due to a dependency on some other object being removed, its drop is converted to a drop of the referenced object, so that &lt;code&gt;NORMAL&lt;/code&gt; and &lt;code&gt;AUTO&lt;/code&gt; dependencies of the dependent object behave much like they were dependencies of the referenced object. Example: a view's &lt;code&gt;ON SELECT&lt;/code&gt; rule is made internally dependent on the view, preventing it from being dropped while the view remains. Dependencies of the rule (such as tables it refers to) act as if they were dependencies of the view.</source>
          <target state="translated">创建依赖对象是引用对象创建的一部分，并且实际上只是其内部实现的一部分。直接 &lt;code&gt;DROP&lt;/code&gt; 有依赖对象是不能直接允许（我们将告诉用户发出 &lt;code&gt;DROP&lt;/code&gt; 被引用对象，而不是）。甲 &lt;code&gt;DROP&lt;/code&gt; 被引用的对象都将导致自动滴是否依赖对象 &lt;code&gt;CASCADE&lt;/code&gt; 指定与否。如果由于要删除对某些其他对象的依赖性而不得不删除依赖对象，则将其删除转换为引用对象的删除，这样 &lt;code&gt;NORMAL&lt;/code&gt; 和 &lt;code&gt;AUTO&lt;/code&gt; 依赖对象的依赖行为的行为就像是引用对象的依赖一样。示例：使视图的 &lt;code&gt;ON SELECT&lt;/code&gt; 规则在内部依赖于视图，以防止在视图保留时将其删除。规则的依存关系（例如它引用的表）的行为就好像它们是视图的依存关系一样。</target>
        </trans-unit>
        <trans-unit id="6f08ad4e0433fd5acac3297aba03b2acf8ab1183" translate="yes" xml:space="preserve">
          <source>The dependent object was created as part of creation of the referenced object, and is really just a part of its internal implementation; however, unlike &lt;code&gt;INTERNAL&lt;/code&gt;, there is more than one such referenced object. The dependent object must not be dropped unless at least one of these referenced objects is dropped; if any one is, the dependent object should be dropped whether or not &lt;code&gt;CASCADE&lt;/code&gt; is specified. Also unlike &lt;code&gt;INTERNAL&lt;/code&gt;, a drop of some other object that the dependent object depends on does not result in automatic deletion of any partition-referenced object. Hence, if the drop does not cascade to at least one of these objects via some other path, it will be refused. (In most cases, the dependent object shares all its non-partition dependencies with at least one partition-referenced object, so that this restriction does not result in blocking any cascaded delete.) Primary and secondary partition dependencies behave identically except that the primary dependency is preferred for use in error messages; hence, a partition-dependent object should have one primary partition dependency and one or more secondary partition dependencies. Note that partition dependencies are made in addition to, not instead of, any dependencies the object would normally have. This simplifies &lt;code&gt;ATTACH/DETACH PARTITION&lt;/code&gt; operations: the partition dependencies need only be added or removed. Example: a child partitioned index is made partition-dependent on both the partition table it is on and the parent partitioned index, so that it goes away if either of those is dropped, but not otherwise. The dependency on the parent index is primary, so that if the user tries to drop the child partitioned index, the error message will suggest dropping the parent index instead (not the table).</source>
          <target state="translated">从属对象是作为引用对象创建的一部分而创建的，实际上只是其内部实现的一部分。但是，与 &lt;code&gt;INTERNAL&lt;/code&gt; 不同，有多个这样的引用对象。除非删除了这些引用对象中的至少一个，否则不得删除依赖对象。如果存在，则无论是否指定 &lt;code&gt;CASCADE&lt;/code&gt; ,都应删除依赖对象。也不同于 &lt;code&gt;INTERNAL&lt;/code&gt; ，从属对象所依赖的其他一些对象的删除不会导致任何分区引用的对象的自动删除。因此，如果丢弃没有通过其他路径级联到这些对象中的至少一个，它将被拒绝。 （在大多数情况下，从属对象与至少一个分区引用的对象共享所有非分区依赖项，因此此限制不会导致阻止任何级联删除。）主分区和从属分区依赖项的行为相同，除了主依赖项首选用于错误消息；因此，与分区相关的对象应具有一个主分区相关性和一个或多个辅助分区相关性。请注意，分区依赖性是对对象通常具有的任何依赖性的补充，而不是代替。这简化了 &lt;code&gt;ATTACH/DETACH PARTITION&lt;/code&gt; 操作：仅需要添加或删除分区依赖项。示例：使子分区索引既取决于其所在的分区表又取决于其父分区索引，因此，如果删除了其中一个分区索引，则该子分区索引将消失，否则不会消失。对父索引的依赖关系是主要的，因此，如果用户尝试删除子分区索引，则错误消息将建议删除父索引（而不是表）。</target>
        </trans-unit>
        <trans-unit id="7ba979debfd87ef975dc568dd7e8792b4269670b" translate="yes" xml:space="preserve">
          <source>The desired new version of the extension. This can be written as either an identifier or a string literal. If not specified, &lt;code&gt;ALTER EXTENSION UPDATE&lt;/code&gt; attempts to update to whatever is shown as the default version in the extension's control file.</source>
          <target state="translated">所需的扩展新版本。可以将其写为标识符或字符串文字。如果未指定，则 &lt;code&gt;ALTER EXTENSION UPDATE&lt;/code&gt; 尝试更新为扩展程序控制文件中显示为默认版本的内容。</target>
        </trans-unit>
        <trans-unit id="fbd0e34ca3a19b97d0aeb9f0e2c89bbf73246c51" translate="yes" xml:space="preserve">
          <source>The destination encoding name.</source>
          <target state="translated">目的地编码名称。</target>
        </trans-unit>
        <trans-unit id="acbe64874af1481c3f0cac1a6029d7f03fb77273" translate="yes" xml:space="preserve">
          <source>The details of these commands are not important here; the important point is that there are several separate updates involved to accomplish this rather simple operation. Our bank's officers will want to be assured that either all these updates happen, or none of them happen. It would certainly not do for a system failure to result in Bob receiving $100.00 that was not debited from Alice. Nor would Alice long remain a happy customer if she was debited without Bob being credited. We need a guarantee that if something goes wrong partway through the operation, none of the steps executed so far will take effect. Grouping the updates into a &lt;em&gt;transaction&lt;/em&gt; gives us this guarantee. A transaction is said to be &lt;em&gt;atomic&lt;/em&gt;: from the point of view of other transactions, it either happens completely or not at all.</source>
          <target state="translated">这些命令的细节在这里并不重要；重要的一点是，要完成此相当简单的操作，需要涉及几个单独的更新。我们银行的管理人员将希望确保所有这些更新都发生了，或者没有发生。系统故障当然不会导致Bob收到未从Alice借记的$ 100.00。如果在没有Bob信用的情况下将她借入借方，Alice也永远不会成为一个满意的客户。我们需要保证，如果在操作过程中出现问题，到目前为止执行的任何步骤都不会生效。将更新分组到一个&lt;em&gt;事务中&lt;/em&gt;为我们提供了这一保证。据说交易是&lt;em&gt;原子的&lt;/em&gt;：从其他交易的角度来看，它要么完全发生，要么根本没有发生。</target>
        </trans-unit>
        <trans-unit id="81c51a0e7b9a40e273e8f7fe3f2164c947629b88" translate="yes" xml:space="preserve">
          <source>The dictionary accepts three options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e98ae374f333e238cb54e40ccd57bf293c2950f" translate="yes" xml:space="preserve">
          <source>The dictionary accepts two options:</source>
          <target state="translated">该字典接受两个选项。</target>
        </trans-unit>
        <trans-unit id="a19f3de80263e9a6413003bf67d42fb29a4dfff8" translate="yes" xml:space="preserve">
          <source>The difference between enabling &lt;code&gt;log_duration&lt;/code&gt; and setting &lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-DURATION-STATEMENT&quot;&gt;log_min_duration_statement&lt;/a&gt; to zero is that exceeding &lt;code&gt;log_min_duration_statement&lt;/code&gt; forces the text of the query to be logged, but this option doesn't. Thus, if &lt;code&gt;log_duration&lt;/code&gt; is &lt;code&gt;on&lt;/code&gt; and &lt;code&gt;log_min_duration_statement&lt;/code&gt; has a positive value, all durations are logged but the query text is included only for statements exceeding the threshold. This behavior can be useful for gathering statistics in high-load installations.</source>
          <target state="translated">启用 &lt;code&gt;log_duration&lt;/code&gt; 和将&lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-DURATION-STATEMENT&quot;&gt;log_min_duration_statement&lt;/a&gt;设置为零之间的区别在于，超过 &lt;code&gt;log_min_duration_statement&lt;/code&gt; 会强制记录查询的文本，但此选项不会。因此，如果 &lt;code&gt;log_duration&lt;/code&gt; 是 &lt;code&gt;on&lt;/code&gt; 和 &lt;code&gt;log_min_duration_statement&lt;/code&gt; 为正值，所有的持续时间被记录，但包括查询文本仅报表超过阈值。此行为对于在高负载安装中收集统计信息很有用。</target>
        </trans-unit>
        <trans-unit id="86d6a3829cada6f81d9cef342af0288f96d331f4" translate="yes" xml:space="preserve">
          <source>The difference is that the query against the summary table has to get only one row from the table, whereas the direct query against &lt;code&gt;one_to_many&lt;/code&gt; must index scan and fetch a row for each entry.</source>
          <target state="translated">区别在于，针对汇总表的查询仅需从表中获取一行，而针对 &lt;code&gt;one_to_many&lt;/code&gt; 的直接查询则必须索引扫描并为每个条目获取一行。</target>
        </trans-unit>
        <trans-unit id="638327d505052c3c14e5ba331469e70ba93f8131" translate="yes" xml:space="preserve">
          <source>The differences highlighted here are not all of them. In XQuery and the 2.0 and later versions of XPath, there is an XPath 1.0 compatibility mode, and the W3C lists of &lt;a href=&quot;https://www.w3.org/TR/2010/REC-xpath-functions-20101214/#xpath1-compatibility&quot;&gt;function library changes&lt;/a&gt; and &lt;a href=&quot;https://www.w3.org/TR/xpath20/#id-backwards-compatibility&quot;&gt;language changes&lt;/a&gt; applied in that mode offer a more complete (but still not exhaustive) account of the differences. The compatibility mode cannot make the later languages exactly equivalent to XPath 1.0.</source>
          <target state="translated">这里突出显示的差异并不是全部。在XQuery和XPath 2.0及更高版本中，存在XPath 1.0兼容模式，并且在该模式下应用的&lt;a href=&quot;https://www.w3.org/TR/2010/REC-xpath-functions-20101214/#xpath1-compatibility&quot;&gt;函数库更改&lt;/a&gt;和&lt;a href=&quot;https://www.w3.org/TR/xpath20/#id-backwards-compatibility&quot;&gt;语言更改&lt;/a&gt;的W3C列表提供了更完整（但仍不是穷尽）的区别说明。兼容模式不能使更高版本的语言完全等同于XPath 1.0。</target>
        </trans-unit>
        <trans-unit id="3e588858632409434bd776e63f92b5761c3db20c" translate="yes" xml:space="preserve">
          <source>The directory &lt;code&gt;$PGDATA/pg_tblspc&lt;/code&gt; contains symbolic links that point to each of the non-built-in tablespaces defined in the cluster. Although not recommended, it is possible to adjust the tablespace layout by hand by redefining these links. Under no circumstances perform this operation while the server is running. Note that in PostgreSQL 9.1 and earlier you will also need to update the &lt;code&gt;pg_tablespace&lt;/code&gt; catalog with the new locations. (If you do not, &lt;code&gt;pg_dump&lt;/code&gt; will continue to output the old tablespace locations.)</source>
          <target state="translated">&lt;code&gt;$PGDATA/pg_tblspc&lt;/code&gt; 目录包含指向群集中定义的每个非内置表空间的符号链接。尽管不建议这样做，但可以通过重新定义这些链接来手动调整表空间布局。在服务器运行期间，任何情况下都不要执行此操作。请注意，在PostgreSQL 9.1和更早版本中，您还需要使用新位置更新 &lt;code&gt;pg_tablespace&lt;/code&gt; 目录。（如果不这样做， &lt;code&gt;pg_dump&lt;/code&gt; 将继续输出旧表空间位置。）</target>
        </trans-unit>
        <trans-unit id="48e3d4bb3b396fb8ccb3377c9877d054f3fd3eaa" translate="yes" xml:space="preserve">
          <source>The directory &lt;code&gt;src/test/locale&lt;/code&gt; in the source distribution contains a test suite for PostgreSQL's locale support.</source>
          <target state="translated">源代码发行版中的目录 &lt;code&gt;src/test/locale&lt;/code&gt; 包含一个用于PostgreSQL的语言环境支持的测试套件。</target>
        </trans-unit>
        <trans-unit id="8f609b85a02a4ded47fa5c57a791418dd0d72112" translate="yes" xml:space="preserve">
          <source>The directory that will be used for the tablespace. The directory must exist (&lt;code&gt;CREATE TABLESPACE&lt;/code&gt; will not create it), should be empty, and must be owned by the PostgreSQL system user. The directory must be specified by an absolute path name.</source>
          <target state="translated">将用于表空间的目录。该目录必须存在（ &lt;code&gt;CREATE TABLESPACE&lt;/code&gt; 将不会创建该目录），该目录必须为空，并且必须由PostgreSQL系统用户拥有。该目录必须由绝对路径名指定。</target>
        </trans-unit>
        <trans-unit id="0c9ae3d8cb40fd37366fec2ea07a50700e4c2316" translate="yes" xml:space="preserve">
          <source>The domain this constraint is on; 0 if not a domain constraint</source>
          <target state="translated">该约束所在的域;如果不是域约束,则为0。</target>
        </trans-unit>
        <trans-unit id="66141cd3e18bcdc88d4a038dfc634ffad3fa560d" translate="yes" xml:space="preserve">
          <source>The drawback of this procedure is that it depends on the integrity of the client: if the client machine is untrusted or compromised, an attacker could run just about any program on port 113 and return any user name they choose. This authentication method is therefore only appropriate for closed networks where each client machine is under tight control and where the database and system administrators operate in close contact. In other words, you must trust the machine running the ident server. Heed the warning:</source>
          <target state="translated">这个过程的缺点是,它取决于客户机的完整性:如果客户机不受信任或被入侵,攻击者可以在113端口上运行几乎任何程序,并返回他们选择的任何用户名。因此,这种身份验证方法只适用于封闭的网络,在这种网络中,每台客户机都受到严格的控制,而且数据库和系统管理员的操作是紧密联系的。换句话说,你必须信任运行身份服务器的机器。听从警告。</target>
        </trans-unit>
        <trans-unit id="13aa020c26befcd9c06640c85756679a7699e20c" translate="yes" xml:space="preserve">
          <source>The drawback of using locales other than &lt;code&gt;C&lt;/code&gt; or &lt;code&gt;POSIX&lt;/code&gt; in PostgreSQL is its performance impact. It slows character handling and prevents ordinary indexes from being used by &lt;code&gt;LIKE&lt;/code&gt;. For this reason use locales only if you actually need them.</source>
          <target state="translated">在PostgreSQL 中使用 &lt;code&gt;C&lt;/code&gt; 或 &lt;code&gt;POSIX&lt;/code&gt; 以外的语言环境的缺点是其性能影响。它减慢了字符处理的速度，并阻止了 &lt;code&gt;LIKE&lt;/code&gt; 使用普通索引。因此，仅在实际需要时才使用语言环境。</target>
        </trans-unit>
        <trans-unit id="ff3e6b54f5a69b71d88bd211c608fb1a58dc225c" translate="yes" xml:space="preserve">
          <source>The dump file produced by pg_dump does not contain the statistics used by the optimizer to make query planning decisions. Therefore, it is wise to run &lt;code&gt;ANALYZE&lt;/code&gt; after restoring from a dump file to ensure optimal performance; see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Section 24.1.3&lt;/a&gt; and &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information.</source>
          <target state="translated">pg_dump生成的转储文件不包含优化程序用于制定查询计划决策的统计信息。因此，从转储文件还原后运行 &lt;code&gt;ANALYZE&lt;/code&gt; 是明智的，以确保最佳性能。有关更多信息，请参见&lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;第24.1.3节&lt;/a&gt;和&lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;第24.1.6节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7b92c28f4a6038b16d370463cb2b0c497c1536e4" translate="yes" xml:space="preserve">
          <source>The dump script should not be expected to run completely without errors. In particular, because the script will issue &lt;code&gt;CREATE ROLE&lt;/code&gt; for every role existing in the source cluster, it is certain to get a &amp;ldquo;role already exists&amp;rdquo; error for the bootstrap superuser, unless the destination cluster was initialized with a different bootstrap superuser name. This error is harmless and should be ignored. Use of the &lt;code&gt;--clean&lt;/code&gt; option is likely to produce additional harmless error messages about non-existent objects, although you can minimize those by adding &lt;code&gt;--if-exists&lt;/code&gt;.</source>
          <target state="translated">转储脚本不应期望完全运行而不会出现错误。特别是，由于脚本将为源集群中存在的每个角色发出 &lt;code&gt;CREATE ROLE&lt;/code&gt; ，因此可以肯定引导超级用户会遇到&amp;ldquo;角色已存在&amp;rdquo;错误，除非目标集群是使用不同的引导超级用户名初始化的。该错误是无害的，应该忽略。使用 &lt;code&gt;--clean&lt;/code&gt; 选项可能会产生有关不存在的对象的其他无害错误消息，尽管您可以通过添加 &lt;code&gt;--if-exists&lt;/code&gt; 来最小化这些消息。</target>
        </trans-unit>
        <trans-unit id="7f3181a66ca9fbe6427fab730ca21eb224bb5bb9" translate="yes" xml:space="preserve">
          <source>The dumps produced by pg_dump are relative to &lt;code&gt;template0&lt;/code&gt;. This means that any languages, procedures, etc. added via &lt;code&gt;template1&lt;/code&gt; will also be dumped by pg_dump. As a result, when restoring, if you are using a customized &lt;code&gt;template1&lt;/code&gt;, you must create the empty database from &lt;code&gt;template0&lt;/code&gt;, as in the example above.</source>
          <target state="translated">pg_dump产生的转储相对于 &lt;code&gt;template0&lt;/code&gt; 。这意味着通过 &lt;code&gt;template1&lt;/code&gt; 添加的任何语言，过程等也将被pg_dump转储。结果，在还原时，如果使用的是自定义 &lt;code&gt;template1&lt;/code&gt; ，则必须从 &lt;code&gt;template0&lt;/code&gt; 创建空数据库，如上例所示。</target>
        </trans-unit>
        <trans-unit id="95dc72eaaf7198b33e4096fb87aae7d094164670" translate="yes" xml:space="preserve">
          <source>The earliest LSN at which replay on the indicated timeline may end when making use of this backup. This is stored in the same format as &lt;code&gt;Start-LSN&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7817fb8368f1c7b07f344d07c4746bc348201b26" translate="yes" xml:space="preserve">
          <source>The easiest way to perform a base backup is to use the &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt; tool. It can create a base backup either as regular files or as a tar archive. If more flexibility than &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt; can provide is required, you can also make a base backup using the low level API (see &lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP&quot;&gt;Section 25.3.3&lt;/a&gt;).</source>
          <target state="translated">执行基本备份的最简单方法是使用&lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt;工具。它可以将基本备份创建为常规文件或tar存档。如果需要比&lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt;所提供的更多的灵活性，您还可以使用低级API进行基本备份（请参见&lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP&quot;&gt;第25.3.3节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="29f1de90d9c685081e50b22b770744253403d7c5" translate="yes" xml:space="preserve">
          <source>The effect of this mechanism is that in the default configuration, triggers do not fire on replicas. This is useful because if a trigger is used on the origin to propagate data between tables, then the replication system will also replicate the propagated data, and the trigger should not fire a second time on the replica, because that would lead to duplication. However, if a trigger is used for another purpose such as creating external alerts, then it might be appropriate to set it to &lt;code&gt;ENABLE ALWAYS&lt;/code&gt; so that it is also fired on replicas.</source>
          <target state="translated">此机制的作用是，在默认配置中，触发器不会在副本上触发。这很有用，因为如果在源上使用触发器在表之间传播数据，则复制系统还将复制传播的数据，并且触发器不应在副本上再次触发，因为这会导致重复。但是，如果将触发器用于其他目的（例如，创建外部警报），则将其设置为&amp;ldquo; &lt;code&gt;ENABLE ALWAYS&lt;/code&gt; 可能是适当的，这样它也会在副本上触发。</target>
        </trans-unit>
        <trans-unit id="11f70bcfbdc794c385378840673cf0a249c54a0a" translate="yes" xml:space="preserve">
          <source>The effective maximum for &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; is 0.95 * &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt;; a setting higher than that will be capped to the maximum. A value higher than &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; wouldn't make sense because an anti-wraparound autovacuum would be triggered at that point anyway, and the 0.95 multiplier leaves some breathing room to run a manual &lt;code&gt;VACUUM&lt;/code&gt; before that happens. As a rule of thumb, &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; should be set to a value somewhat below &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt;, leaving enough gap so that a regularly scheduled &lt;code&gt;VACUUM&lt;/code&gt; or an autovacuum triggered by normal delete and update activity is run in that window. Setting it too close could lead to anti-wraparound autovacuums, even though the table was recently vacuumed to reclaim space, whereas lower values lead to more frequent aggressive vacuuming.</source>
          <target state="translated">&lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; 的有效最大值为0.95 * &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; ;高于该设置的最高限额。高于 &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; 的值是没有意义的，因为无论如何都会在该点触发反环绕式自动 &lt;code&gt;VACUUM&lt;/code&gt; ，并且0.95乘数留有喘息的空间来运行手动VACUUM。根据经验， &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; 的值应设置为略低于 &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; 的值，并留有足够的空隙，以便定期安排 &lt;code&gt;VACUUM&lt;/code&gt; 或在该窗口中运行由正常删除和更新活动触发的自动清理。设置得太近可能会导致自动抽真空，即使桌子最近被吸尘以回收空间，而较低的值则会导致更频繁的主动吸尘。</target>
        </trans-unit>
        <trans-unit id="6acae8d5fe7431e883721a35bb83f27f6d33e399" translate="yes" xml:space="preserve">
          <source>The effective resolution of the sleep interval is platform-specific; 0.01 seconds is a common value. The sleep delay will be at least as long as specified. It might be longer depending on factors such as server load. In particular, &lt;code&gt;pg_sleep_until&lt;/code&gt; is not guaranteed to wake up exactly at the specified time, but it will not wake up any earlier.</source>
          <target state="translated">睡眠间隔的有效分辨率是特定于平台的；0.01秒是一个常用值。睡眠延迟将至少与指定的时间一样长。可能会更长，具体取决于服务器负载等因素。特别是，不能保证 &lt;code&gt;pg_sleep_until&lt;/code&gt; 在指定的时间准确地唤醒，但是不会更早地唤醒。</target>
        </trans-unit>
        <trans-unit id="ca3e0b7947e98767e7bc3c70b05110c06d007fc6" translate="yes" xml:space="preserve">
          <source>The effects of &lt;code&gt;SET LOCAL&lt;/code&gt; last only till the end of the current transaction, whether committed or not. A special case is &lt;code&gt;SET&lt;/code&gt; followed by &lt;code&gt;SET LOCAL&lt;/code&gt; within a single transaction: the &lt;code&gt;SET LOCAL&lt;/code&gt; value will be seen until the end of the transaction, but afterwards (if the transaction is committed) the &lt;code&gt;SET&lt;/code&gt; value will take effect.</source>
          <target state="translated">无论是否提交， &lt;code&gt;SET LOCAL&lt;/code&gt; 的影响仅持续到当前事务结束。一个特殊情况是在单个事务中紧随其后的是 &lt;code&gt;SET&lt;/code&gt; ,然后是 &lt;code&gt;SET LOCAL&lt;/code&gt; ： &lt;code&gt;SET LOCAL&lt;/code&gt; 值将一直显示到事务结束为止，但是此后（如果提交了事务） &lt;code&gt;SET&lt;/code&gt; 值将生效。</target>
        </trans-unit>
        <trans-unit id="1963e14d77518dfe80e47bfcd05e2429f11a8bde" translate="yes" xml:space="preserve">
          <source>The effects of &lt;code&gt;SET&lt;/code&gt; or &lt;code&gt;SET LOCAL&lt;/code&gt; are also canceled by rolling back to a savepoint that is earlier than the command.</source>
          <target state="translated">通过回滚到早于命令的保存点，也可以取消 &lt;code&gt;SET&lt;/code&gt; 或 &lt;code&gt;SET LOCAL&lt;/code&gt; 的影响。</target>
        </trans-unit>
        <trans-unit id="005a74c57d93879fd436d69f089f03e96ff53b14" translate="yes" xml:space="preserve">
          <source>The elements of the &lt;code&gt;PARTITION BY&lt;/code&gt; list are interpreted in much the same fashion as elements of a &lt;a href=&quot;sql-select#SQL-GROUPBY&quot;&gt;&lt;code&gt;GROUP BY&lt;/code&gt; Clause&lt;/a&gt;, except that they are always simple expressions and never the name or number of an output column. Another difference is that these expressions can contain aggregate function calls, which are not allowed in a regular &lt;code&gt;GROUP BY&lt;/code&gt; clause. They are allowed here because windowing occurs after grouping and aggregation.</source>
          <target state="translated">&lt;code&gt;PARTITION BY&lt;/code&gt; 列表中的元素的解释方式与&lt;a href=&quot;sql-select#SQL-GROUPBY&quot;&gt; &lt;code&gt;GROUP BY&lt;/code&gt; 子句中的&lt;/a&gt;元素几乎相同，不同之处在于它们始终是简单表达式，而不是输出列的名称或编号。另一个区别是这些表达式可以包含聚合函数调用，这在常规 &lt;code&gt;GROUP BY&lt;/code&gt; 子句中是不允许的。在此处允许使用它们，因为窗口在分组和聚合之后发生。</target>
        </trans-unit>
        <trans-unit id="ee005edb8cd95f17a956edeff522c590d6992936" translate="yes" xml:space="preserve">
          <source>The elements of the &lt;code&gt;PARTITION BY&lt;/code&gt; list are interpreted in much the same fashion as elements of a &lt;a href=&quot;sql-select#SQL-GROUPBY&quot;&gt;&lt;code&gt;GROUP BY&lt;/code&gt;&lt;/a&gt; clause, except that they are always simple expressions and never the name or number of an output column. Another difference is that these expressions can contain aggregate function calls, which are not allowed in a regular &lt;code&gt;GROUP BY&lt;/code&gt; clause. They are allowed here because windowing occurs after grouping and aggregation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd51d8414173fa812e307883cf9daca455add1a4" translate="yes" xml:space="preserve">
          <source>The empty scalar sub-SELECT will produce a null value that is considered to be of the domain type, so no further constraint checking is applied to it, and the insertion will succeed.</source>
          <target state="translated">空标量子-SELECT将产生一个空值,该值被认为是域类型的,因此不再对其进行约束检查,插入成功。</target>
        </trans-unit>
        <trans-unit id="750129d09bd31bb5985c26e665018fb53719c8d3" translate="yes" xml:space="preserve">
          <source>The encoding and locale settings must match those of the template database, except when &lt;code&gt;template0&lt;/code&gt; is used as template. This is because other databases might contain data that does not match the specified encoding, or might contain indexes whose sort ordering is affected by &lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt;. Copying such data would result in a database that is corrupt according to the new settings. &lt;code&gt;template0&lt;/code&gt;, however, is known to not contain any data or indexes that would be affected.</source>
          <target state="translated">编码和语言环境设置必须与模板数据库的设置匹配，除非将 &lt;code&gt;template0&lt;/code&gt; 用作模板。这是因为其他数据库可能包含与指定编码不匹配的数据，或者可能包含其排序顺序受 &lt;code&gt;LC_COLLATE&lt;/code&gt; 和 &lt;code&gt;LC_CTYPE&lt;/code&gt; 影响的索引。复制此类数据将导致数据库根据新设置损坏。但是，已知 &lt;code&gt;template0&lt;/code&gt; 不包含任何会受到影响的数据或索引。</target>
        </trans-unit>
        <trans-unit id="06ebfe8f29152790c8c19069e09027b276e20d6f" translate="yes" xml:space="preserve">
          <source>The encoding for a database is stored in the system catalog &lt;code&gt;pg_database&lt;/code&gt;. You can see it by using the &lt;code&gt;psql&lt;/code&gt;&lt;code&gt;-l&lt;/code&gt; option or the &lt;code&gt;\l&lt;/code&gt; command.</source>
          <target state="translated">数据库的编码存储在系统目录 &lt;code&gt;pg_database&lt;/code&gt; 中。您可以使用 &lt;code&gt;psql&lt;/code&gt; &lt;code&gt;-l&lt;/code&gt; 选项或 &lt;code&gt;\l&lt;/code&gt; 命令来查看它。</target>
        </trans-unit>
        <trans-unit id="7b548a79db3b694cdb5c78e7ae46892fe80152d6" translate="yes" xml:space="preserve">
          <source>The encryption vector used will only be cryptographically strong if PostgreSQL is built with support for OpenSSL. In other cases, the transmission to the RADIUS server should only be considered obfuscated, not secured, and external security measures should be applied if necessary.</source>
          <target state="translated">只有在PostgreSQL构建时支持OpenSSL的情况下,使用的加密向量才会具有加密强度。在其他情况下,传输到RADIUS服务器的过程中,只能认为是混淆的,而不是安全的,必要时应采用外部安全措施。</target>
        </trans-unit>
        <trans-unit id="807f48853a85df34d9a80e7027652fd76ea8d1d2" translate="yes" xml:space="preserve">
          <source>The entries in the select list can be assigned names for subsequent processing, such as for use in an &lt;code&gt;ORDER BY&lt;/code&gt; clause or for display by the client application. For example:</source>
          <target state="translated">可以为选择列表中的条目分配名称，以进行后续处理，例如在 &lt;code&gt;ORDER BY&lt;/code&gt; 子句中使用或由客户端应用程序显示。例如：</target>
        </trans-unit>
        <trans-unit id="5ed44cca4375f0386d06f29a5cb471a7a637f589" translate="yes" xml:space="preserve">
          <source>The enumerator is a function &lt;code&gt;int_array_enum(integer[])&lt;/code&gt; that returns &lt;code&gt;setof integer&lt;/code&gt;. It is essentially the reverse operation of the aggregator: given an array of integers, expand it into a set of rows. This is a wrapper around &lt;code&gt;unnest&lt;/code&gt;, which does the same thing for any array type.</source>
          <target state="translated">枚举器是一个函数 &lt;code&gt;int_array_enum(integer[])&lt;/code&gt; ，该函数返回 &lt;code&gt;setof integer&lt;/code&gt; 。本质上，这是聚合器的反向操作：给定整数数组，将其扩展为一组行。这是 &lt;code&gt;unnest&lt;/code&gt; 的包装，对任何数组类型都执行相同的操作。</target>
        </trans-unit>
        <trans-unit id="adf2db7b61ef30b8a94189e9e7cbc4a2342e7f7a" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;PG_COLOR&lt;/code&gt; specifies whether to use color in diagnostic messages. Possible values are &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;auto&lt;/code&gt; and &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d14b9d4e54d6bcfb1eb32844ae2033e082cd8255" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;PG_COLOR&lt;/code&gt; specifies whether to use color in diagnostics messages. Possible values are &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;auto&lt;/code&gt;, &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">环境变量 &lt;code&gt;PG_COLOR&lt;/code&gt; 指定是否在诊断消息中使用颜色。可能的值 &lt;code&gt;always&lt;/code&gt; ， &lt;code&gt;auto&lt;/code&gt; ， &lt;code&gt;never&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0960a83450dbd1eaf41a4a82cb1e20f4eb07da46" translate="yes" xml:space="preserve">
          <source>The error code (see &lt;a href=&quot;errcodes-appendix&quot;&gt;Appendix A&lt;/a&gt;) associated with the last SQL query's failure, or &lt;code&gt;00000&lt;/code&gt; if it succeeded.</source>
          <target state="translated">与上一个SQL查询的失败相关联的错误代码（请参阅&lt;a href=&quot;errcodes-appendix&quot;&gt;附录A&lt;/a&gt;）；如果成功，则返回 &lt;code&gt;00000&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18033404335da13276f24e2efbba0cea44bc2fa8" translate="yes" xml:space="preserve">
          <source>The error message contains a useful hint: if you do not want to bother deleting all the dependent objects individually, you can run:</source>
          <target state="translated">错误信息包含一个有用的提示:如果你不想麻烦地单独删除所有依赖对象,你可以运行。</target>
        </trans-unit>
        <trans-unit id="57829bc22f9a034fee876abab6cb834a1c2e8f4d" translate="yes" xml:space="preserve">
          <source>The escape character can be any single character other than a hexadecimal digit, the plus sign, a single quote, a double quote, or a whitespace character.</source>
          <target state="translated">转义字符可以是除十六进制数字、加号、单引号、双引号或空白字符以外的任何单个字符。</target>
        </trans-unit>
        <trans-unit id="67bd70b6b09776588b82cea1e08b3ca407b7095e" translate="yes" xml:space="preserve">
          <source>The escape character can be any single character other than a hexadecimal digit, the plus sign, a single quote, a double quote, or a whitespace character. Note that the escape character is written in single quotes, not double quotes, after &lt;code&gt;UESCAPE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="558d22a4e0d0e48723c35f2a0cfc8e75bf258ba8" translate="yes" xml:space="preserve">
          <source>The escape character can be any single character other than a hexadecimal digit, the plus sign, a single quote, a double quote, or a whitespace character. Note that the escape character is written in single quotes, not double quotes.</source>
          <target state="translated">转义字符可以是除十六进制数字、加号、单引号、双引号或空白字符以外的任何单个字符。注意,转义字符是用单引号写的,而不是双引号。</target>
        </trans-unit>
        <trans-unit id="c319bbe8d3e052f0e1ded51a38eee81a844539cf" translate="yes" xml:space="preserve">
          <source>The escape-double-quote separators actually divide &lt;code&gt;substring&lt;/code&gt;'s pattern into three independent regular expressions; for example, a vertical bar (&lt;code&gt;|&lt;/code&gt;) in any of the three sections affects only that section. Also, the first and third of these regular expressions are defined to match the smallest possible amount of text, not the largest, when there is any ambiguity about how much of the data string matches which pattern. (In POSIX parlance, the first and third regular expressions are forced to be non-greedy.)</source>
          <target state="translated">转义双引号分隔符实际上将 &lt;code&gt;substring&lt;/code&gt; 的模式分为三个独立的正则表达式。例如，三个部分中任何一个的竖线（ &lt;code&gt;|&lt;/code&gt; ）仅影响该部分。同样，当对多少数据字符串与哪种模式匹配有任何歧义时，这些正则表达式的第一个和第三个被定义为匹配最小可能的文本量，而不是最大的文本。（按照POSIX的说法，第一个和第三个正则表达式被强制为非贪婪的。）</target>
        </trans-unit>
        <trans-unit id="3b9ec713fc7d733ff3cae68659b4d4e80a25bebd" translate="yes" xml:space="preserve">
          <source>The essential difference between &lt;code&gt;inet&lt;/code&gt; and &lt;code&gt;cidr&lt;/code&gt; data types is that &lt;code&gt;inet&lt;/code&gt; accepts values with nonzero bits to the right of the netmask, whereas &lt;code&gt;cidr&lt;/code&gt; does not. For example, &lt;code&gt;192.168.0.1/24&lt;/code&gt; is valid for &lt;code&gt;inet&lt;/code&gt; but not for &lt;code&gt;cidr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;inet&lt;/code&gt; 和 &lt;code&gt;cidr&lt;/code&gt; 数据类型之间的本质区别是 &lt;code&gt;inet&lt;/code&gt; 接受子网掩码右侧具有非零位的值，而 &lt;code&gt;cidr&lt;/code&gt; 则不接受。例如， &lt;code&gt;192.168.0.1/24&lt;/code&gt; 对 &lt;code&gt;inet&lt;/code&gt; 有效，但对 &lt;code&gt;cidr&lt;/code&gt; 无效。</target>
        </trans-unit>
        <trans-unit id="df18f95e8b31c041dbe1102915fb4ff49c1585b3" translate="yes" xml:space="preserve">
          <source>The essential semantics of an &lt;code&gt;in_range&lt;/code&gt; function depend on the two Boolean flag parameters. It should add or subtract &lt;code&gt;base&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt;, then compare &lt;code&gt;val&lt;/code&gt; to the result, as follows:</source>
          <target state="translated">&lt;code&gt;in_range&lt;/code&gt; 函数的基本语义取决于两个布尔标志参数。它应该添加或减去 &lt;code&gt;base&lt;/code&gt; 和 &lt;code&gt;offset&lt;/code&gt; ，然后将 &lt;code&gt;val&lt;/code&gt; 与结果进行比较，如下所示：</target>
        </trans-unit>
        <trans-unit id="e84d23798c1117bda45a63153c240c91e5736421" translate="yes" xml:space="preserve">
          <source>The estimate is as accurate as with the functional dependencies, mostly thanks to the table being fairly small and having a simple distribution with a low number of distinct values. Before looking at the second query, which was not handled by functional dependencies particularly well, let's inspect the MCV list a bit.</source>
          <target state="translated">这个估计和功能依赖一样准确,主要是由于表相当小,而且分布简单,不同值的数量少。在看第二个查询之前,我们先检查一下MCV列表,因为功能依赖性处理得不是特别好。</target>
        </trans-unit>
        <trans-unit id="e69083f44a757893f1ada1ae6b8cb9bd97b58e99" translate="yes" xml:space="preserve">
          <source>The estimated cost charged when vacuum modifies a block that was previously clean. It represents the extra I/O required to flush the dirty block out to disk again. The default value is 20.</source>
          <target state="translated">当真空修改一个先前干净的块时,所收取的估计费用。它代表了再次将脏块冲出磁盘所需的额外I/O。默认值是20。</target>
        </trans-unit>
        <trans-unit id="ee2db52b19d2bfa03dc1ab623c01a2a1907e2459" translate="yes" xml:space="preserve">
          <source>The estimated cost for vacuuming a buffer found in the shared buffer cache. It represents the cost to lock the buffer pool, lookup the shared hash table and scan the content of the page. The default value is one.</source>
          <target state="translated">对共享缓冲区缓存中发现的缓冲区进行吸尘的估计成本。它代表了锁定缓冲区池、查找共享哈希表和扫描页面内容的成本。默认值为1。</target>
        </trans-unit>
        <trans-unit id="83ce27e1c08fee6790695cac6b8c3ef5bff725b5" translate="yes" xml:space="preserve">
          <source>The estimated cost for vacuuming a buffer that has to be read from disk. This represents the effort to lock the buffer pool, lookup the shared hash table, read the desired block in from the disk and scan its content. The default value is 10.</source>
          <target state="translated">从磁盘读取缓冲区的估计成本。这代表了锁定缓冲区池、查找共享哈希表、从磁盘读取所需的块并扫描其内容的工作量。默认值是10。</target>
        </trans-unit>
        <trans-unit id="a717571e9b46bfa71ced49ce7ab5ad2053e90b7b" translate="yes" xml:space="preserve">
          <source>The event is one of &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt;. Note that an &lt;code&gt;INSERT&lt;/code&gt; containing an &lt;code&gt;ON CONFLICT&lt;/code&gt; clause cannot be used on tables that have either &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; rules. Consider using an updatable view instead.</source>
          <target state="translated">该事件是 &lt;code&gt;SELECT&lt;/code&gt; ， &lt;code&gt;INSERT&lt;/code&gt; ， &lt;code&gt;UPDATE&lt;/code&gt; 或 &lt;code&gt;DELETE&lt;/code&gt; 之一。请注意，包含 &lt;code&gt;ON CONFLICT&lt;/code&gt; 子句的 &lt;code&gt;INSERT&lt;/code&gt; 不能用于具有 &lt;code&gt;INSERT&lt;/code&gt; 或 &lt;code&gt;UPDATE&lt;/code&gt; 规则的表。考虑改用可更新的视图。</target>
        </trans-unit>
        <trans-unit id="227dafe90d62bc0d6660bf9b763aa381e9cc9dfe" translate="yes" xml:space="preserve">
          <source>The exact values that are acceptable for the &lt;code&gt;locale&lt;/code&gt; clause in this command depend on the operating system. On Unix-like systems, the command &lt;code&gt;locale -a&lt;/code&gt; will show a list.</source>
          <target state="translated">此命令中的 &lt;code&gt;locale&lt;/code&gt; 子句可接受的确切值取决于操作系统。在类似Unix的系统上，命令 &lt;code&gt;locale -a&lt;/code&gt; 将显示一个列表。</target>
        </trans-unit>
        <trans-unit id="1583bbd20b51e7ac63ce0bb194332cc2a7d7d470" translate="yes" xml:space="preserve">
          <source>The example above can be written using the simple &lt;code&gt;CASE&lt;/code&gt; syntax:</source>
          <target state="translated">可以使用简单的 &lt;code&gt;CASE&lt;/code&gt; 语法编写以上示例：</target>
        </trans-unit>
        <trans-unit id="af8e2a351cf21a24426f9811e0f9ff471eeba69b" translate="yes" xml:space="preserve">
          <source>The example below shows a DTrace script for analyzing transaction counts in the system, as an alternative to snapshotting &lt;code&gt;pg_stat_database&lt;/code&gt; before and after a performance test:</source>
          <target state="translated">下面的示例显示了一个DTrace脚本，用于分析系统中的事务计数，作为在性能测试前后对 &lt;code&gt;pg_stat_database&lt;/code&gt; 进行快照的替代方法：</target>
        </trans-unit>
        <trans-unit id="f0d6977a3eaffb08d482eddd947f053b0bf9bd5c" translate="yes" xml:space="preserve">
          <source>The examples above only show &lt;code&gt;WITH&lt;/code&gt; being used with &lt;code&gt;SELECT&lt;/code&gt;, but it can be attached in the same way to &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt;. In each case it effectively provides temporary table(s) that can be referred to in the main command.</source>
          <target state="translated">上面的示例仅显示 &lt;code&gt;WITH&lt;/code&gt; 与 &lt;code&gt;SELECT&lt;/code&gt; 一起使用，但是可以以相同的方式将其附加到 &lt;code&gt;INSERT&lt;/code&gt; ， &lt;code&gt;UPDATE&lt;/code&gt; 或 &lt;code&gt;DELETE&lt;/code&gt; 。在每种情况下，它都有效地提供了可以在main命令中引用的临时表。</target>
        </trans-unit>
        <trans-unit id="380cc7f137a8c15a1ad87e0fd8242117724c9f5a" translate="yes" xml:space="preserve">
          <source>The examples in the previous section illustrated full text matching using simple constant strings. This section shows how to search table data, optionally using indexes.</source>
          <target state="translated">上一节的例子说明了使用简单的常量字符串进行全文匹配。本节介绍了如何搜索表数据,可选择使用索引。</target>
        </trans-unit>
        <trans-unit id="b9b0afad9f26eddf93a4253af463b944d4205ce4" translate="yes" xml:space="preserve">
          <source>The examples shown below use tables in the PostgreSQL regression test database. The outputs shown are taken from version 8.3. The behavior of earlier (or later) versions might vary. Note also that since &lt;code&gt;ANALYZE&lt;/code&gt; uses random sampling while producing statistics, the results will change slightly after any new &lt;code&gt;ANALYZE&lt;/code&gt;.</source>
          <target state="translated">下面显示的示例使用PostgreSQL回归测试数据库中的表。显示的输出取自8.3版本。早期（或更高版本）的行为可能有所不同。还要注意，由于 &lt;code&gt;ANALYZE&lt;/code&gt; 在生成统计信息时使用随机抽样，因此在进行任何新的 &lt;code&gt;ANALYZE&lt;/code&gt; 之后结果将略有变化。</target>
        </trans-unit>
        <trans-unit id="c2367138a166c600af3d676a2ed6d45de33c069c" translate="yes" xml:space="preserve">
          <source>The examples use &lt;code&gt;EXPLAIN&lt;/code&gt;'s default &amp;ldquo;text&amp;rdquo; output format, which is compact and convenient for humans to read. If you want to feed &lt;code&gt;EXPLAIN&lt;/code&gt;'s output to a program for further analysis, you should use one of its machine-readable output formats (XML, JSON, or YAML) instead.</source>
          <target state="translated">这些示例使用 &lt;code&gt;EXPLAIN&lt;/code&gt; 的默认&amp;ldquo;文本&amp;rdquo;输出格式，该格式紧凑且便于人类阅读。如果要将 &lt;code&gt;EXPLAIN&lt;/code&gt; 的输出提供给程序以进行进一步的分析，则应改用其机器可读的输出格式之一（XML，JSON或YAML）。</target>
        </trans-unit>
        <trans-unit id="d75f123f158a40ce2bca3268003c1deb66947f66" translate="yes" xml:space="preserve">
          <source>The exclusive backup method is deprecated and should be avoided. Prior to PostgreSQL 9.6, this was the only low-level method available, but it is now recommended that all users upgrade their scripts to use non-exclusive backups.</source>
          <target state="translated">独占的备份方法已经被废弃,应该避免使用。在PostgreSQL 9.6之前,这是唯一可用的低级方法,但现在建议所有用户升级他们的脚本,使用非专属备份。</target>
        </trans-unit>
        <trans-unit id="bb6f1793100519508110d4857d8c27514367d631" translate="yes" xml:space="preserve">
          <source>The executor mechanism is used to evaluate all four basic SQL query types: &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt;. For &lt;code&gt;SELECT&lt;/code&gt;, the top-level executor code only needs to send each row returned by the query plan tree off to the client. For &lt;code&gt;INSERT&lt;/code&gt;, each returned row is inserted into the target table specified for the &lt;code&gt;INSERT&lt;/code&gt;. This is done in a special top-level plan node called &lt;code&gt;ModifyTable&lt;/code&gt;. (A simple &lt;code&gt;INSERT ... VALUES&lt;/code&gt; command creates a trivial plan tree consisting of a single &lt;code&gt;Result&lt;/code&gt; node, which computes just one result row, and &lt;code&gt;ModifyTable&lt;/code&gt; above it to perform the insertion. But &lt;code&gt;INSERT ... SELECT&lt;/code&gt; can demand the full power of the executor mechanism.) For &lt;code&gt;UPDATE&lt;/code&gt;, the planner arranges that each computed row includes all the updated column values, plus the &lt;em&gt;TID&lt;/em&gt; (tuple ID, or row ID) of the original target row; this data is fed into a &lt;code&gt;ModifyTable&lt;/code&gt; node, which uses the information to create a new updated row and mark the old row deleted. For &lt;code&gt;DELETE&lt;/code&gt;, the only column that is actually returned by the plan is the TID, and the &lt;code&gt;ModifyTable&lt;/code&gt; node simply uses the TID to visit each target row and mark it deleted.</source>
          <target state="translated">执行程序机制用于评估所有四种基本SQL查询类型： &lt;code&gt;SELECT&lt;/code&gt; ， &lt;code&gt;INSERT&lt;/code&gt; ， &lt;code&gt;UPDATE&lt;/code&gt; 和 &lt;code&gt;DELETE&lt;/code&gt; 。对于 &lt;code&gt;SELECT&lt;/code&gt; ，顶级执行程序代码仅需要将查询计划树返回的每一行发送给客户端。对于 &lt;code&gt;INSERT&lt;/code&gt; ，每个返回的行都插入到为 &lt;code&gt;INSERT&lt;/code&gt; 指定的目标表中。这是在名为 &lt;code&gt;ModifyTable&lt;/code&gt; 的特殊顶层计划节点中完成的。 （一个简单的 &lt;code&gt;INSERT ... VALUES&lt;/code&gt; 命令创建了一个简单的计划树，该计划树由单个 &lt;code&gt;Result&lt;/code&gt; 节点（仅计算一个结果行）和 &lt;code&gt;ModifyTable&lt;/code&gt; 组成在其上方执行插入。但是 &lt;code&gt;INSERT ... SELECT&lt;/code&gt; 可能需要执行程序机制的全部功能。）对于 &lt;code&gt;UPDATE&lt;/code&gt; ，计划者将安排每个计算行包括所有更新的列值，以及原始目标行的&lt;em&gt;TID&lt;/em&gt;（元组ID或行ID）。 ;此数据被馈送到 &lt;code&gt;ModifyTable&lt;/code&gt; 节点，该节点使用该信息来创建新的更新行并标记旧行已删除。对于 &lt;code&gt;DELETE&lt;/code&gt; ，计划实际返回的唯一列是TID，而 &lt;code&gt;ModifyTable&lt;/code&gt; 节点仅使用TID访问每个目标行并将其标记为已删除。</target>
        </trans-unit>
        <trans-unit id="4ce520996e20d2c06a7766155c3058caa75b4272" translate="yes" xml:space="preserve">
          <source>The executor recursively steps through the &lt;em&gt;plan tree&lt;/em&gt; and retrieves rows in the way represented by the plan. The executor makes use of the &lt;em&gt;storage system&lt;/em&gt; while scanning relations, performs &lt;em&gt;sorts&lt;/em&gt; and &lt;em&gt;joins&lt;/em&gt;, evaluates &lt;em&gt;qualifications&lt;/em&gt; and finally hands back the rows derived.</source>
          <target state="translated">执行程序以递归方式遍历&lt;em&gt;计划树&lt;/em&gt;并以计划表示的方式检索行。执行&lt;em&gt;程序&lt;/em&gt;在扫描关系，执行&lt;em&gt;排序&lt;/em&gt;和&lt;em&gt;联接&lt;/em&gt;，评估&lt;em&gt;资格&lt;/em&gt;并最终交回派生的行时利用&lt;em&gt;存储系统&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="cf8658aa7a1382f233186544e10108cceaf18988" translate="yes" xml:space="preserve">
          <source>The existence of functional dependencies directly affects the accuracy of estimates in certain queries. If a query contains conditions on both the independent and the dependent column(s), the conditions on the dependent columns do not further reduce the result size; but without knowledge of the functional dependency, the query planner will assume that the conditions are independent, resulting in underestimating the result size.</source>
          <target state="translated">功能依赖性的存在直接影响某些查询中估计的准确性。如果一个查询中既包含独立列又包含从属列的条件,那么从属列的条件就不会进一步减小结果大小;但如果不知道功能依赖性,查询规划者就会认为条件是独立的,导致低估结果大小。</target>
        </trans-unit>
        <trans-unit id="278c43dc066d35135921d352f59558e56072aaf4" translate="yes" xml:space="preserve">
          <source>The existing enum value that should be renamed. Like all enum literals, it needs to be quoted.</source>
          <target state="translated">应该重新命名的现有枚举值。和所有的枚举值一样,它需要被引用。</target>
        </trans-unit>
        <trans-unit id="ec72bab01087d3968b75adfc77dfce97e7c1c187" translate="yes" xml:space="preserve">
          <source>The existing enum value that the new value should be added immediately before or after in the enum type's sort ordering. Like all enum literals, it needs to be quoted.</source>
          <target state="translated">现有的枚举值,在枚举类型的排序中,新的值应该紧接着添加在前面或后面。像所有的枚举值一样,它需要被引用。</target>
        </trans-unit>
        <trans-unit id="288730aef18ef4aa044e0dc2a74d3a67ae251dbc" translate="yes" xml:space="preserve">
          <source>The expected parameter types for the prepared statement in the form of an array of &lt;code&gt;regtype&lt;/code&gt;. The OID corresponding to an element of this array can be obtained by casting the &lt;code&gt;regtype&lt;/code&gt; value to &lt;code&gt;oid&lt;/code&gt;.</source>
          <target state="translated">准备好的语句的期望参数类型为 &lt;code&gt;regtype&lt;/code&gt; 数组的形式。可以通过将 &lt;code&gt;regtype&lt;/code&gt; 值转换为 &lt;code&gt;oid&lt;/code&gt; 来获得与该数组的元素对应的OID 。</target>
        </trans-unit>
        <trans-unit id="2f35445a6307ee1d7e051209ff3712898a533184" translate="yes" xml:space="preserve">
          <source>The expected size of this file, as an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d73c415087d49efbf447ec5f41bf9143b5e43b5" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;IS DOCUMENT&lt;/code&gt; returns true if the argument XML value is a proper XML document, false if it is not (that is, it is a content fragment), or null if the argument is null. See &lt;a href=&quot;datatype-xml&quot;&gt;Section 8.13&lt;/a&gt; about the difference between documents and content fragments.</source>
          <target state="translated">如果参数XML值是正确的XML文档，则表达式 &lt;code&gt;IS DOCUMENT&lt;/code&gt; 返回true；否则，返回false（即，它是内容片段）；如果参数为null，则返回null。有关文档和内容片段之间的区别，请参见&lt;a href=&quot;datatype-xml&quot;&gt;第8.13节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d3f0f5215911482c31ec80c4c63789e99b22d5c9" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;IS NOT DOCUMENT&lt;/code&gt; returns false if the argument XML value is a proper XML document, true if it is not (that is, it is a content fragment), or null if the argument is null.</source>
          <target state="translated">如果参数XML值是正确的XML文档，则表达式 &lt;code&gt;IS NOT DOCUMENT&lt;/code&gt; 返回false；否则，返回true（如果它是内容片段）；如果参数为null，则返回null。</target>
        </trans-unit>
        <trans-unit id="2fefc72765ee0edb8389edc8b54df23ebd5b6c13" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;collation for&lt;/code&gt; returns the collation of the value that is passed to it. Example:</source>
          <target state="translated">表达式 &lt;code&gt;collation for&lt;/code&gt; 返回传递给它的值的排序规则。例：</target>
        </trans-unit>
        <trans-unit id="9cec711d90ae7214afb1e767819f2c01ba82f2bc" translate="yes" xml:space="preserve">
          <source>The expression added to the WITH CHECK qualifications for queries that attempt to add rows to this table</source>
          <target state="translated">添加到WITH CHECK限定条件中的表达式,该限定条件用于试图向此表添加行的查询。</target>
        </trans-unit>
        <trans-unit id="fa02a0029d6349d8e6423a393d9fb0288905f902" translate="yes" xml:space="preserve">
          <source>The expression added to the security barrier qualifications for queries that this policy applies to</source>
          <target state="translated">在本政策适用的查询安全屏障资格中增加了以下表述。</target>
        </trans-unit>
        <trans-unit id="239121cdfc5b45b387f1658717f60a67584813d6" translate="yes" xml:space="preserve">
          <source>The expression tree to be added to the WITH CHECK qualifications for queries that attempt to add rows to the table</source>
          <target state="translated">要添加到WITH CHECK限定中的表达式树,用于试图向表添加行的查询。</target>
        </trans-unit>
        <trans-unit id="710b7212dd7cdac519a9932cd2101a57cc49631a" translate="yes" xml:space="preserve">
          <source>The expression tree to be added to the security barrier qualifications for queries that use the table</source>
          <target state="translated">对于使用表的查询,安全屏障资格中要添加的表达树。</target>
        </trans-unit>
        <trans-unit id="d2c435961e2d1a2d5fc091620a3b53aedf1bc369" translate="yes" xml:space="preserve">
          <source>The expression used in the &lt;code&gt;WHERE&lt;/code&gt; clause can refer only to columns of the underlying table, but it can use all columns, not just the ones being indexed. Presently, subqueries and aggregate expressions are also forbidden in &lt;code&gt;WHERE&lt;/code&gt;. The same restrictions apply to index fields that are expressions.</source>
          <target state="translated">&lt;code&gt;WHERE&lt;/code&gt; 子句中使用的表达式只能引用基础表的列，但是它可以使用所有列，而不仅仅是被索引的列。当前，在 &lt;code&gt;WHERE&lt;/code&gt; 中也禁止子查询和聚合表达式。相同的限制适用于作为表达式的索引字段。</target>
        </trans-unit>
        <trans-unit id="e44d27b215403bd620571252d0254bbcc4cec3b6" translate="yes" xml:space="preserve">
          <source>The expressions described in this section check properties of &lt;code&gt;xml&lt;/code&gt; values.</source>
          <target state="translated">本节中描述的表达式检查 &lt;code&gt;xml&lt;/code&gt; 值的属性。</target>
        </trans-unit>
        <trans-unit id="56934ce6588045922ec59583c810f1cb0acd84a1" translate="yes" xml:space="preserve">
          <source>The extensions currently available for loading can be identified from the &lt;a href=&quot;view-pg-available-extensions&quot;&gt;&lt;code&gt;pg_available_extensions&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;view-pg-available-extension-versions&quot;&gt;&lt;code&gt;pg_available_extension_versions&lt;/code&gt;&lt;/a&gt; system views.</source>
          <target state="translated">当前可用于加载的扩展名可以从&lt;a href=&quot;view-pg-available-extensions&quot;&gt; &lt;code&gt;pg_available_extensions&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;view-pg-available-extension-versions&quot;&gt; &lt;code&gt;pg_available_extension_versions&lt;/code&gt; &lt;/a&gt;系统视图中识别。</target>
        </trans-unit>
        <trans-unit id="8afec2ee5b2d1b2e4a42a77922b5f5aca2fe0a53" translate="yes" xml:space="preserve">
          <source>The extensions for PL/Perl are called &lt;code&gt;jsonb_plperl&lt;/code&gt; and &lt;code&gt;jsonb_plperlu&lt;/code&gt;. If you use them, &lt;code&gt;jsonb&lt;/code&gt; values are mapped to Perl arrays, hashes, and scalars, as appropriate.</source>
          <target state="translated">PL / Perl的扩展名为 &lt;code&gt;jsonb_plperl&lt;/code&gt; 和 &lt;code&gt;jsonb_plperlu&lt;/code&gt; 。如果使用它们，则 &lt;code&gt;jsonb&lt;/code&gt; 值将视情况映射到Perl数组，哈希和标量。</target>
        </trans-unit>
        <trans-unit id="19e8b6e34d048aaf0ad16665bbe37cdf1acb53f4" translate="yes" xml:space="preserve">
          <source>The extensions for PL/Python are called &lt;code&gt;jsonb_plpythonu&lt;/code&gt;, &lt;code&gt;jsonb_plpython2u&lt;/code&gt;, and &lt;code&gt;jsonb_plpython3u&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/plpython-python23.html&quot;&gt;Section 45.1&lt;/a&gt; for the PL/Python naming convention). If you use them, &lt;code&gt;jsonb&lt;/code&gt; values are mapped to Python dictionaries, lists, and scalars, as appropriate.</source>
          <target state="translated">PL / Python的扩展名为 &lt;code&gt;jsonb_plpythonu&lt;/code&gt; ， &lt;code&gt;jsonb_plpython2u&lt;/code&gt; 和 &lt;code&gt;jsonb_plpython3u&lt;/code&gt; （有关PL / Python的命名约定，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/plpython-python23.html&quot;&gt;第45.1节&lt;/a&gt;）。如果使用它们， &lt;code&gt;jsonb&lt;/code&gt; 值视情况映射到Python字典，列表和标量。</target>
        </trans-unit>
        <trans-unit id="b34c58961fecd5bbfea5deffa1c8dc758272c022" translate="yes" xml:space="preserve">
          <source>The extensions for PL/Python are called &lt;code&gt;jsonb_plpythonu&lt;/code&gt;, &lt;code&gt;jsonb_plpython2u&lt;/code&gt;, and &lt;code&gt;jsonb_plpython3u&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/13/plpython-python23.html&quot;&gt;Section 45.1&lt;/a&gt; for the PL/Python naming convention). If you use them, &lt;code&gt;jsonb&lt;/code&gt; values are mapped to Python dictionaries, lists, and scalars, as appropriate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05f3501f99bc04897b07450c60fab261a8909a70" translate="yes" xml:space="preserve">
          <source>The extensions supplied with PostgreSQL are believed to be secure against installation-time attacks of this sort, except for a few that depend on other extensions. As stated in the documentation for those extensions, they should be installed into secure schemas, or installed into the same schemas as the extensions they depend on, or both.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75cf68d4493c1ff227589e69d7f36aa6187d6f32" translate="yes" xml:space="preserve">
          <source>The extent of analysis can be controlled by adjusting the &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; configuration variable, or on a column-by-column basis by setting the per-column statistics target with &lt;code&gt;ALTER TABLE ... ALTER COLUMN ... SET STATISTICS&lt;/code&gt; (see &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;). The target value sets the maximum number of entries in the most-common-value list and the maximum number of bins in the histogram. The default target value is 100, but this can be adjusted up or down to trade off accuracy of planner estimates against the time taken for &lt;code&gt;ANALYZE&lt;/code&gt; and the amount of space occupied in &lt;code&gt;pg_statistic&lt;/code&gt;. In particular, setting the statistics target to zero disables collection of statistics for that column. It might be useful to do that for columns that are never used as part of the &lt;code&gt;WHERE&lt;/code&gt;, &lt;code&gt;GROUP BY&lt;/code&gt;, or &lt;code&gt;ORDER BY&lt;/code&gt; clauses of queries, since the planner will have no use for statistics on such columns.</source>
          <target state="translated">可以通过调整&lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt;配置变量来控制分析范围，也可以通过使用 &lt;code&gt;ALTER TABLE ... ALTER COLUMN ... SET STATISTICS&lt;/code&gt; 设置每个列的统计目标来逐列地控制（请参阅&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;）。目标值设置最常用值列表中的最大条目数和直方图中的最大bin数。默认目标值是100，但是可以向上或向下调整此值，以权衡计划者估算的准确性与 &lt;code&gt;ANALYZE&lt;/code&gt; 花费的时间以及 &lt;code&gt;pg_statistic&lt;/code&gt; 中占用的空间量。特别是，将统计目标设置为零会禁用该列的统计收集。对于从未用作 &lt;code&gt;WHERE&lt;/code&gt; ， &lt;code&gt;GROUP BY&lt;/code&gt; 或 &lt;code&gt;ORDER BY&lt;/code&gt; 子句一部分的列，执行此操作可能很有用，因为计划器将不会使用此类列的统计信息。</target>
        </trans-unit>
        <trans-unit id="4a1085020ce268691ef6285fd13220f59746e5a1" translate="yes" xml:space="preserve">
          <source>The external representation of an interval is formed using one or two floating-point numbers joined by the range operator (&lt;code&gt;..&lt;/code&gt; or &lt;code&gt;...&lt;/code&gt;). Alternatively, it can be specified as a center point plus or minus a deviation. Optional certainty indicators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;~&lt;/code&gt;) can be stored as well. (Certainty indicators are ignored by all the built-in operators, however.) &lt;a href=&quot;seg#SEG-REPR-TABLE&quot;&gt;Table F.26&lt;/a&gt; gives an overview of allowed representations; &lt;a href=&quot;seg#SEG-INPUT-EXAMPLES&quot;&gt;Table F.27&lt;/a&gt; shows some examples.</source>
          <target state="translated">区间的外部表示是使用一个或两个浮点数形成的，这些浮点数由范围运算符（ &lt;code&gt;..&lt;/code&gt; 或 &lt;code&gt;...&lt;/code&gt; ）连接。或者，可以将其指定为中心点加上或减去偏差。也可以存储可选的确定性指示符（ &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; 或 &lt;code&gt;~&lt;/code&gt; ）。 （但是，所有内置运算符都忽略了确定性指标。）&lt;a href=&quot;seg#SEG-REPR-TABLE&quot;&gt;表F.26&lt;/a&gt;概述了允许的表示形式。&lt;a href=&quot;seg#SEG-INPUT-EXAMPLES&quot;&gt;表F.27&lt;/a&gt;显示了一些示例。</target>
        </trans-unit>
        <trans-unit id="ae94f4d8ec241ec4efa4661c23c0573db1da2b96" translate="yes" xml:space="preserve">
          <source>The external text representation of a composite value consists of items that are interpreted according to the I/O conversion rules for the individual field types, plus decoration that indicates the composite structure. The decoration consists of parentheses (&lt;code&gt;(&lt;/code&gt; and &lt;code&gt;)&lt;/code&gt;) around the whole value, plus commas (&lt;code&gt;,&lt;/code&gt;) between adjacent items. Whitespace outside the parentheses is ignored, but within the parentheses it is considered part of the field value, and might or might not be significant depending on the input conversion rules for the field data type. For example, in:</source>
          <target state="translated">复合值的外部文本表示由根据各个字段类型的I / O转换规则解释的项目以及表示复合结构的修饰组成。装饰包括围绕整个值的括号（ &lt;code&gt;(&lt;/code&gt; 和 &lt;code&gt;)&lt;/code&gt; ），以及相邻项目之间的逗号（ &lt;code&gt;,&lt;/code&gt; ）。括号外的空格将被忽略，但是括号内的空格将被视为字段值的一部分，并且取决于字段数据类型的输入转换规则，该空格可能会或可能不会很重要。例如，在：</target>
        </trans-unit>
        <trans-unit id="165e79d513851869bfa7df4f3e60a06eff8eadcf" translate="yes" xml:space="preserve">
          <source>The external text representation of an array value consists of items that are interpreted according to the I/O conversion rules for the array's element type, plus decoration that indicates the array structure. The decoration consists of curly braces (&lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt;) around the array value plus delimiter characters between adjacent items. The delimiter character is usually a comma (&lt;code&gt;,&lt;/code&gt;) but can be something else: it is determined by the &lt;code&gt;typdelim&lt;/code&gt; setting for the array's element type. Among the standard data types provided in the PostgreSQL distribution, all use a comma, except for type &lt;code&gt;box&lt;/code&gt;, which uses a semicolon (&lt;code&gt;;&lt;/code&gt;). In a multidimensional array, each dimension (row, plane, cube, etc.) gets its own level of curly braces, and delimiters must be written between adjacent curly-braced entities of the same level.</source>
          <target state="translated">数组值的外部文本表示包括根据数组元素类型的I / O转换规则解释的项目，以及表示数组结构的修饰。装饰由数组值周围的花括号（ &lt;code&gt;{&lt;/code&gt; 和 &lt;code&gt;}&lt;/code&gt; ）以及相邻项目之间的定界符组成。分隔符通常是逗号（ &lt;code&gt;,&lt;/code&gt; ），但可以是其他字符：它由数组元素类型的 &lt;code&gt;typdelim&lt;/code&gt; 设置确定。在PostgreSQL发行版中提供的标准数据类型中，除了类型 &lt;code&gt;box&lt;/code&gt; 使用分号（ &lt;code&gt;;&lt;/code&gt; 以外，所有均使用逗号。）。在多维数组中，每个维度（行，平面，立方体等）都有其自己的花括号级别，并且必须在同一级别的相邻花括号实体之间编写分隔符。</target>
        </trans-unit>
        <trans-unit id="6b72823d964b50e21e643394f5a86559900b575c" translate="yes" xml:space="preserve">
          <source>The external, user defined, name of a replication origin.</source>
          <target state="translated">外部的、用户定义的复制源名称。</target>
        </trans-unit>
        <trans-unit id="b158be94edfd836340b3eb6a9fee5fccbd77513b" translate="yes" xml:space="preserve">
          <source>The fact that a result set is a relation means that a query can be used in the definition of another query, becoming a &lt;em&gt;subquery&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23e10c575081917649336c89f16d01777906e835" translate="yes" xml:space="preserve">
          <source>The fact that constraint exclusion uses &lt;code&gt;CHECK&lt;/code&gt; constraints, which makes it slow compared to partition pruning, can sometimes be used as an advantage: because constraints can be defined even on declaratively-partitioned tables, in addition to their internal partition bounds, constraint exclusion may be able to elide additional partitions from the query plan.</source>
          <target state="translated">约束排除使用 &lt;code&gt;CHECK&lt;/code&gt; 约束的事实，这使其比分区修剪慢，有时可以用作优点：因为即使在声明性分区的表上也可以定义约束，所以除了其内部分区边界外，约束排除也可以是能够从查询计划中删除其他分区。</target>
        </trans-unit>
        <trans-unit id="19233032264a45feb14fbaa7d90f7412bf00d3b4" translate="yes" xml:space="preserve">
          <source>The factory default limit on open files is often set to &amp;ldquo;socially friendly&amp;rdquo; values that allow many users to coexist on a machine without using an inappropriate fraction of the system resources. If you run many servers on a machine this is perhaps what you want, but on dedicated servers you might want to raise this limit.</source>
          <target state="translated">打开文件的出厂默认限制通常设置为&amp;ldquo;社交友好&amp;rdquo;值，该值允许许多用户在计算机上共存，而不会使用不适当的系统资源。如果您在一台计算机上运行许多服务器，这也许就是您想要的，但是在专用服务器上，您可能希望提高此限制。</target>
        </trans-unit>
        <trans-unit id="656ca22572866570d9b541e49d642f6e1926acfb" translate="yes" xml:space="preserve">
          <source>The field/element/path extraction operators return NULL, rather than failing, if the JSON input does not have the right structure to match the request; for example if no such key or array element exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eb210aea67c31ef1dbed7fd3eae3f43ab6220c6" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; is only honored in macOS 10.3.9 and later. If you are running a previous 10.3.x release, you must edit the file &lt;code&gt;/etc/rc&lt;/code&gt; and change the values in the following commands:</source>
          <target state="translated">仅在macOS 10.3.9及更高版本中支持 &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 文件。如果运行的是10.3.x以前的版本，则必须编辑文件 &lt;code&gt;/etc/rc&lt;/code&gt; 并在以下命令中更改值：</target>
        </trans-unit>
        <trans-unit id="84e9c854c59c60e0df39d55604e40742c14a3b04" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;scan.l&lt;/code&gt; is transformed to the C source file &lt;code&gt;scan.c&lt;/code&gt; using the program flex and &lt;code&gt;gram.y&lt;/code&gt; is transformed to &lt;code&gt;gram.c&lt;/code&gt; using bison. After these transformations have taken place a normal C compiler can be used to create the parser. Never make any changes to the generated C files as they will be overwritten the next time flex or bison is called.</source>
          <target state="translated">使用程序flex将文件 &lt;code&gt;scan.c&lt;/code&gt; 转换为C源文件 &lt;code&gt;scan.l&lt;/code&gt; 并使用bison 将 &lt;code&gt;gram.y&lt;/code&gt; 转换为 &lt;code&gt;gram.c&lt;/code&gt; 。完成这些转换后，可以使用普通的C编译器来创建解析器。切勿对生成的C文件进行任何更改，因为它们将在下次调用flex或bison时被覆盖。</target>
        </trans-unit>
        <trans-unit id="45d0800a2dc4458be5cbd179d0ad2c43301c7d89" translate="yes" xml:space="preserve">
          <source>The file header consists of 15 bytes of fixed fields, followed by a variable-length header extension area. The fixed fields are:</source>
          <target state="translated">文件头由15个字节的固定字段组成,后面是一个长度可变的头扩展区。固定字段为:</target>
        </trans-unit>
        <trans-unit id="08e8ce7451fee51ac789a7527b77201e50285954" translate="yes" xml:space="preserve">
          <source>The file name that will be used to store the history list. If unset, the file name is taken from the &lt;code&gt;PSQL_HISTORY&lt;/code&gt; environment variable. If that is not set either, the default is &lt;code&gt;~/.psql_history&lt;/code&gt;, or &lt;code&gt;%APPDATA%\postgresql\psql_history&lt;/code&gt; on Windows. For example, putting:</source>
          <target state="translated">将用于存储历史记录列表的文件名。如果未设置，则从 &lt;code&gt;PSQL_HISTORY&lt;/code&gt; 环境变量获取文件名。如果两者均未设置，则默认值为 &lt;code&gt;~/.psql_history&lt;/code&gt; 或Windows上的 &lt;code&gt;%APPDATA%\postgresql\psql_history&lt;/code&gt; 。例如，将：</target>
        </trans-unit>
        <trans-unit id="349919ea5386038c9255234a7dc46c1f159466f8" translate="yes" xml:space="preserve">
          <source>The file trailer consists of a 16-bit integer word containing -1. This is easily distinguished from a tuple's field-count word.</source>
          <target state="translated">文件预告片由一个包含-1的16位整数字组成。这很容易与元组的字段计数字区分开来。</target>
        </trans-unit>
        <trans-unit id="80e18aa528aa991bd67d4fb018eb762c1dfd60ad" translate="yes" xml:space="preserve">
          <source>The fillfactor for a table is a percentage between 10 and 100. 100 (complete packing) is the default. When a smaller fillfactor is specified, &lt;code&gt;INSERT&lt;/code&gt; operations pack table pages only to the indicated percentage; the remaining space on each page is reserved for updating rows on that page. This gives &lt;code&gt;UPDATE&lt;/code&gt; a chance to place the updated copy of a row on the same page as the original, which is more efficient than placing it on a different page. For a table whose entries are never updated, complete packing is the best choice, but in heavily updated tables smaller fillfactors are appropriate. This parameter cannot be set for TOAST tables.</source>
          <target state="translated">表格的填充因子是10到100之间的百分比。默认值为100（完全打包）。当指定较小的填充因子时， &lt;code&gt;INSERT&lt;/code&gt; 操作仅将表页面打包到指定的百分比；每个页面上的剩余空间都保留用于更新该页面上的行。这样， &lt;code&gt;UPDATE&lt;/code&gt; 就有机会将行的更新副本与原始副本放置在同一页面上，这比将其放置在另一页面上更为有效。对于永远不会更新其条目的表，最好进行完全打包，但在更新频繁的表中，较小的填充因子是合适的。不能为TOAST表设置此参数。</target>
        </trans-unit>
        <trans-unit id="4a018942b6effccffd16cfc6cd2d9f3b5906ea0a" translate="yes" xml:space="preserve">
          <source>The fillfactor for an index is a percentage that determines how full the index method will try to pack index pages. For B-trees, leaf pages are filled to this percentage during initial index build, and also when extending the index at the right (adding new largest key values). If pages subsequently become completely full, they will be split, leading to gradual degradation in the index's efficiency. B-trees use a default fillfactor of 90, but any integer value from 10 to 100 can be selected. If the table is static then fillfactor 100 is best to minimize the index's physical size, but for heavily updated tables a smaller fillfactor is better to minimize the need for page splits. The other index methods use fillfactor in different but roughly analogous ways; the default fillfactor varies between methods.</source>
          <target state="translated">索引的fillfactor是一个百分比,它决定了索引方法将尝试打包索引页的满度。对于B树来说,叶子页在初始建立索引时,以及在右侧扩展索引时(添加新的最大键值),都会被填充到这个百分比。如果随后页面完全填满,就会被拆分,导致索引的效率逐渐降低。B树使用的默认fillfactor为90,但可以选择10到100的任何整数值。如果表是静态的,那么fillfactor 100是最好的,以最小化索引的物理大小,但对于大量更新的表,较小的fillfactor更好,以最小化页面分割的需要。其他索引方法使用fillfactor的方式不同,但大致类似;不同方法的默认fillfactor也不同。</target>
        </trans-unit>
        <trans-unit id="5c29e42edd123c00869988ea11e4589bccf58ecb" translate="yes" xml:space="preserve">
          <source>The final section is the &amp;ldquo;special section&amp;rdquo; which can contain anything the access method wishes to store. For example, b-tree indexes store links to the page's left and right siblings, as well as some other data relevant to the index structure. Ordinary tables do not use a special section at all (indicated by setting &lt;code&gt;pd_special&lt;/code&gt; to equal the page size).</source>
          <target state="translated">最后一部分是&amp;ldquo;特殊部分&amp;rdquo;，其中可以包含访问方法希望存储的任何内容。例如，b树索引存储到页面的左右同级的链接，以及与索引结构相关的其他一些数据。普通表根本不使用特殊节（通过将 &lt;code&gt;pd_special&lt;/code&gt; 设置为等于页面大小来表示）。</target>
        </trans-unit>
        <trans-unit id="02efe302dcd79b9e88f3a8473b49b8f9d4ac5123" translate="yes" xml:space="preserve">
          <source>The finished plan tree consists of sequential or index scans of the base relations, plus nested-loop, merge, or hash join nodes as needed, plus any auxiliary steps needed, such as sort nodes or aggregate-function calculation nodes. Most of these plan node types have the additional ability to do &lt;em&gt;selection&lt;/em&gt; (discarding rows that do not meet a specified Boolean condition) and &lt;em&gt;projection&lt;/em&gt; (computation of a derived column set based on given column values, that is, evaluation of scalar expressions where needed). One of the responsibilities of the planner is to attach selection conditions from the &lt;code&gt;WHERE&lt;/code&gt; clause and computation of required output expressions to the most appropriate nodes of the plan tree.</source>
          <target state="translated">完成的计划树包括对基本关系的顺序或索引扫描，以及根据需要的嵌套循环，合并或哈希联接节点，以及所需的任何辅助步骤，例如排序节点或聚合函数计算节点。这些计划节点类型中的大多数具有执行&lt;em&gt;选择&lt;/em&gt;（丢弃不满足指定布尔条件的行）和&lt;em&gt;投影&lt;/em&gt;（基于给定列值的派生列集的计算，即在需要时评估标量表达式）的附加功能。。计划者的职责之一是将 &lt;code&gt;WHERE&lt;/code&gt; 子句中的选择条件附加起来，并将所需的输出表达式计算到计划树的最适当节点上。</target>
        </trans-unit>
        <trans-unit id="2f91a1368250aec82fa6c3ae45da03e945de99bb" translate="yes" xml:space="preserve">
          <source>The firing of triggers that are declared as &amp;ldquo;constraint triggers&amp;rdquo; is also controlled by this setting &amp;mdash; they fire at the same time that the associated constraint should be checked.</source>
          <target state="translated">声明为&amp;ldquo;约束触发器&amp;rdquo;的触发器的触发也由此设置控制-它们在应检查相关约束的同时触发。</target>
        </trans-unit>
        <trans-unit id="88e7caa4743ed2b44e88bb8540b5ed22e8f063f5" translate="yes" xml:space="preserve">
          <source>The first 24 bytes of each page consists of a page header (&lt;code&gt;PageHeaderData&lt;/code&gt;). Its format is detailed in &lt;a href=&quot;storage-page-layout#PAGEHEADERDATA-TABLE&quot;&gt;Table 68.3&lt;/a&gt;. The first field tracks the most recent WAL entry related to this page. The second field contains the page checksum if &lt;a href=&quot;app-initdb#APP-INITDB-DATA-CHECKSUMS&quot;&gt;data checksums&lt;/a&gt; are enabled. Next is a 2-byte field containing flag bits. This is followed by three 2-byte integer fields (&lt;code&gt;pd_lower&lt;/code&gt;, &lt;code&gt;pd_upper&lt;/code&gt;, and &lt;code&gt;pd_special&lt;/code&gt;). These contain byte offsets from the page start to the start of unallocated space, to the end of unallocated space, and to the start of the special space. The next 2 bytes of the page header, &lt;code&gt;pd_pagesize_version&lt;/code&gt;, store both the page size and a version indicator. Beginning with PostgreSQL 8.3 the version number is 4; PostgreSQL 8.1 and 8.2 used version number 3; PostgreSQL 8.0 used version number 2; PostgreSQL 7.3 and 7.4 used version number 1; prior releases used version number 0. (The basic page layout and header format has not changed in most of these versions, but the layout of heap row headers has.) The page size is basically only present as a cross-check; there is no support for having more than one page size in an installation. The last field is a hint that shows whether pruning the page is likely to be profitable: it tracks the oldest un-pruned XMAX on the page.</source>
          <target state="translated">每页的前24个字节由页眉（ &lt;code&gt;PageHeaderData&lt;/code&gt; ）组成。&lt;a href=&quot;storage-page-layout#PAGEHEADERDATA-TABLE&quot;&gt;表68.3中&lt;/a&gt;详细介绍了其格式。第一个字段跟踪与此页面相关的最新WAL条目。如果启用了&lt;a href=&quot;app-initdb#APP-INITDB-DATA-CHECKSUMS&quot;&gt;数据校验&lt;/a&gt;和，则第二个字段包含页面校验和。接下来是一个包含标志位的2字节字段。随后是三个2字节整数字段（ &lt;code&gt;pd_lower&lt;/code&gt; ， &lt;code&gt;pd_upper&lt;/code&gt; 和 &lt;code&gt;pd_special&lt;/code&gt; ）。它们包含从页面开始到未分配空间的开头，到未分配空间的结尾以及特殊空间的开头的字节偏移。页面标题的后2个字节 &lt;code&gt;pd_pagesize_version&lt;/code&gt; ，同时存储页面大小和版本指示器。从PostgreSQL 8.3开始，版本号是4。 PostgreSQL 8.1和8.2使用版本号3； PostgreSQL 8.0使用版本号2； PostgreSQL 7.3和7.4使用版本号1；早期版本使用的版本号为0。（在大多数这些版本中，基本页面布局和标头格式没有更改，但堆行标头的布局已更改。）页面大小基本上仅作为交叉检查出现；不支持安装中的页面大小超过一个。最后一个字段是提示，显示修剪页面是否可能有利可图：它跟踪页面上最早的未修剪XMAX。</target>
        </trans-unit>
        <trans-unit id="146b5ed003ceae9188015f907676c66e37810a01" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;UPDATE&lt;/code&gt; statement successfully acquires a row-level lock on the specified row, so it succeeds in updating that row. However, the second &lt;code&gt;UPDATE&lt;/code&gt; statement finds that the row it is attempting to update has already been locked, so it waits for the transaction that acquired the lock to complete. Transaction two is now waiting on transaction one to complete before it continues execution. Now, transaction one executes:</source>
          <target state="translated">第一条 &lt;code&gt;UPDATE&lt;/code&gt; 语句成功获取指定行上的行级锁，因此它成功更新了该行。但是，第二条 &lt;code&gt;UPDATE&lt;/code&gt; 语句发现它试图更新的行已被锁定，因此它等待获取该锁的事务完成。现在，事务二正在等待事务一完成，然后再继续执行。现在，事务一执行：</target>
        </trans-unit>
        <trans-unit id="5efcfda2d8c77b88473ca9337c42439a024d54ff" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;expression&lt;/code&gt; is computed, then compared to each of the &lt;code&gt;value&lt;/code&gt; expressions in the &lt;code&gt;WHEN&lt;/code&gt; clauses until one is found that is equal to it. If no match is found, the &lt;code&gt;result&lt;/code&gt; of the &lt;code&gt;ELSE&lt;/code&gt; clause (or a null value) is returned. This is similar to the &lt;code&gt;switch&lt;/code&gt; statement in C.</source>
          <target state="translated">计算第一个 &lt;code&gt;expression&lt;/code&gt; ，然后将其与 &lt;code&gt;WHEN&lt;/code&gt; 子句中的每个 &lt;code&gt;value&lt;/code&gt; 表达式进行比较，直到找到一个等于它的值。如果没有找到匹配，则 &lt;code&gt;result&lt;/code&gt; 的的 &lt;code&gt;ELSE&lt;/code&gt; 返回条款（或空值）。这类似于C中的 &lt;code&gt;switch&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="db81095a43bec432038707d12a55f4ea232797fc" translate="yes" xml:space="preserve">
          <source>The first approach makes use of the &lt;code&gt;cert&lt;/code&gt; authentication method for &lt;code&gt;hostssl&lt;/code&gt; entries in &lt;code&gt;pg_hba.conf&lt;/code&gt;, such that the certificate itself is used for authentication while also providing ssl connection security. See &lt;a href=&quot;auth-cert&quot;&gt;Section 20.12&lt;/a&gt; for details. (It is not necessary to specify any &lt;code&gt;clientcert&lt;/code&gt; options explicitly when using the &lt;code&gt;cert&lt;/code&gt; authentication method.) In this case, the &lt;code&gt;cn&lt;/code&gt; (Common Name) provided in the certificate is checked against the user name or an applicable mapping.</source>
          <target state="translated">第一种方法是对 &lt;code&gt;pg_hba.conf&lt;/code&gt; 中的 &lt;code&gt;hostssl&lt;/code&gt; 条目使用 &lt;code&gt;cert&lt;/code&gt; 身份验证方法，以便证书本身用于身份验证，同时还提供ssl连接安全性。有关详细信息，请参见&lt;a href=&quot;auth-cert&quot;&gt;第20.12节&lt;/a&gt;。 （使用 &lt;code&gt;cert&lt;/code&gt; 身份验证方法时， &lt;code&gt;clientcert&lt;/code&gt; 显式指定任何clientcert选项。）在这种情况下，将根据用户名或适用的映射检查证书中提供的 &lt;code&gt;cn&lt;/code&gt; （通用名称）。</target>
        </trans-unit>
        <trans-unit id="44f0ace0e5a351af8867382fc6a4698f25099edc" translate="yes" xml:space="preserve">
          <source>The first argument is a pointer to a &lt;code&gt;spgChooseIn&lt;/code&gt; C struct, containing input data for the function. The second argument is a pointer to a &lt;code&gt;spgChooseOut&lt;/code&gt; C struct, which the function must fill with result data.</source>
          <target state="translated">第一个参数是指向 &lt;code&gt;spgChooseIn&lt;/code&gt; C结构的指针，该结构包含函数的输入数据。第二个参数是指向 &lt;code&gt;spgChooseOut&lt;/code&gt; C结构的指针，该函数必须在其中填充结果数据。</target>
        </trans-unit>
        <trans-unit id="73a46dbd547b3476953fd0d40d226d75ab67a447" translate="yes" xml:space="preserve">
          <source>The first argument is a pointer to a &lt;code&gt;spgConfigIn&lt;/code&gt; C struct, containing input data for the function. The second argument is a pointer to a &lt;code&gt;spgConfigOut&lt;/code&gt; C struct, which the function must fill with result data.</source>
          <target state="translated">第一个参数是指向 &lt;code&gt;spgConfigIn&lt;/code&gt; C结构的指针，其中包含该函数的输入数据。第二个参数是指向 &lt;code&gt;spgConfigOut&lt;/code&gt; C结构的指针，该函数必须用结果数据填充该结构。</target>
        </trans-unit>
        <trans-unit id="b3d25ba584bb4c4acb9f3461e219135398ddc741" translate="yes" xml:space="preserve">
          <source>The first argument is a pointer to a &lt;code&gt;spgInnerConsistentIn&lt;/code&gt; C struct, containing input data for the function. The second argument is a pointer to a &lt;code&gt;spgInnerConsistentOut&lt;/code&gt; C struct, which the function must fill with result data.</source>
          <target state="translated">第一个参数是指向 &lt;code&gt;spgInnerConsistentIn&lt;/code&gt; C结构的指针，其中包含该函数的输入数据。第二个参数是指向 &lt;code&gt;spgInnerConsistentOut&lt;/code&gt; C结构的指针，该函数必须用结果数据填充该结构。</target>
        </trans-unit>
        <trans-unit id="4b95190547cc0ff307d0a7948518c66223c69217" translate="yes" xml:space="preserve">
          <source>The first argument is a pointer to a &lt;code&gt;spgLeafConsistentIn&lt;/code&gt; C struct, containing input data for the function. The second argument is a pointer to a &lt;code&gt;spgLeafConsistentOut&lt;/code&gt; C struct, which the function must fill with result data.</source>
          <target state="translated">第一个参数是指向 &lt;code&gt;spgLeafConsistentIn&lt;/code&gt; C结构的指针，其中包含该函数的输入数据。第二个参数是指向 &lt;code&gt;spgLeafConsistentOut&lt;/code&gt; C结构的指针，该函数必须用结果数据填充该结构。</target>
        </trans-unit>
        <trans-unit id="ca5853d09340bad3adb00c3e57ccca9e872f72bb" translate="yes" xml:space="preserve">
          <source>The first argument is a pointer to a &lt;code&gt;spgPickSplitIn&lt;/code&gt; C struct, containing input data for the function. The second argument is a pointer to a &lt;code&gt;spgPickSplitOut&lt;/code&gt; C struct, which the function must fill with result data.</source>
          <target state="translated">第一个参数是指向 &lt;code&gt;spgPickSplitIn&lt;/code&gt; C结构的指针，其中包含该函数的输入数据。第二个参数是指向 &lt;code&gt;spgPickSplitOut&lt;/code&gt; C结构的指针，该函数必须用结果数据填充该结构。</target>
        </trans-unit>
        <trans-unit id="1f369dd1771752484284223f6c8b61724d963075" translate="yes" xml:space="preserve">
          <source>The first argument is the relation to be prewarmed. The second argument is the prewarming method to be used, as further discussed below; the third is the relation fork to be prewarmed, usually &lt;code&gt;main&lt;/code&gt;. The fourth argument is the first block number to prewarm (&lt;code&gt;NULL&lt;/code&gt; is accepted as a synonym for zero). The fifth argument is the last block number to prewarm (&lt;code&gt;NULL&lt;/code&gt; means prewarm through the last block in the relation). The return value is the number of blocks prewarmed.</source>
          <target state="translated">第一个论点是要预热的关系。第二个参数是要使用的预热方法，如下所述。第三是要预热的关系叉，通常是 &lt;code&gt;main&lt;/code&gt; 。第四个参数是要预热的第一个块号（ &lt;code&gt;NULL&lt;/code&gt; 被接受为零的同义词）。第五个参数是要预热的最后一个块号（ &lt;code&gt;NULL&lt;/code&gt; 表示预热关系中的最后一个块）。返回值是预热的块数。</target>
        </trans-unit>
        <trans-unit id="cd29c1ca625357cd146a327c957cb4b92e5a317e" translate="yes" xml:space="preserve">
          <source>The first century starts at 0001-01-01 00:00:00 AD, although they did not know it at the time. This definition applies to all Gregorian calendar countries. There is no century number 0, you go from -1 century to 1 century. If you disagree with this, please write your complaint to: Pope, Cathedral Saint-Peter of Roma, Vatican.</source>
          <target state="translated">第一个世纪从公元0001-01-01 00:00:00开始,虽然他们当时并不知道。这个定义适用于所有格里高利历国家。没有世纪号0,你从-1世纪到1世纪。如果你不同意这个说法,请写信投诉到。教皇,罗马圣彼得大教堂,梵蒂冈。</target>
        </trans-unit>
        <trans-unit id="31c0daddd0e62eb1e65c5d8c244c78848b7fb826" translate="yes" xml:space="preserve">
          <source>The first certificate in &lt;code&gt;server.crt&lt;/code&gt; must be the server's certificate because it must match the server's private key. The certificates of &amp;ldquo;intermediate&amp;rdquo; certificate authorities can also be appended to the file. Doing this avoids the necessity of storing intermediate certificates on clients, assuming the root and intermediate certificates were created with &lt;code&gt;v3_ca&lt;/code&gt; extensions. (This sets the certificate's basic constraint of &lt;code&gt;CA&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;.) This allows easier expiration of intermediate certificates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="256263538ce2e1f28734e2b2ed2dbaa9ee5222c8" translate="yes" xml:space="preserve">
          <source>The first certificate in &lt;code&gt;server.crt&lt;/code&gt; must be the server's certificate because it must match the server's private key. The certificates of &amp;ldquo;intermediate&amp;rdquo; certificate authorities can also be appended to the file. Doing this avoids the necessity of storing intermediate certificates on clients, assuming the root and intermediate certificates were created with &lt;code&gt;v3_ca&lt;/code&gt; extensions. This allows easier expiration of intermediate certificates.</source>
          <target state="translated">&lt;code&gt;server.crt&lt;/code&gt; 中的第一个证书必须是服务器的证书，因为它必须与服务器的私钥匹配。 &amp;ldquo;中间&amp;rdquo;证书颁发机构的证书也可以附加到文件中。假设根证书和中间证书是使用 &lt;code&gt;v3_ca&lt;/code&gt; 扩展名创建的，那么这样做避免了在客户端上存储中间证书的必要。这使得中间证书更容易到期。</target>
        </trans-unit>
        <trans-unit id="79f3996eda734e252b355fcb3237a8e729927963" translate="yes" xml:space="preserve">
          <source>The first element specifies that a schema with the same name as the current user is to be searched. If no such schema exists, the entry is ignored. The second element refers to the public schema that we have seen already.</source>
          <target state="translated">第一个元素指定要搜索与当前用户同名的模式。如果没有这样的模式存在,则该条目将被忽略。第二个元素是指我们已经看到的公共模式。</target>
        </trans-unit>
        <trans-unit id="f0dca4048f0fcfac6cd746615ce4e8a0baea6f2f" translate="yes" xml:space="preserve">
          <source>The first example adds a time zone to a value that lacks it, and displays the value using the current &lt;code&gt;TimeZone&lt;/code&gt; setting. The second example shifts the time stamp with time zone value to the specified time zone, and returns the value without a time zone. This allows storage and display of values different from the current &lt;code&gt;TimeZone&lt;/code&gt; setting. The third example converts Tokyo time to Chicago time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dd1c81747f7da19e4955a86256d7b17a34ec6f9" translate="yes" xml:space="preserve">
          <source>The first example adds a time zone to a value that lacks it, and displays the value using the current &lt;code&gt;TimeZone&lt;/code&gt; setting. The second example shifts the time stamp with time zone value to the specified time zone, and returns the value without a time zone. This allows storage and display of values different from the current &lt;code&gt;TimeZone&lt;/code&gt; setting. The third example converts Tokyo time to Chicago time. Converting &lt;em&gt;time&lt;/em&gt; values to other time zones uses the currently active time zone rules since no date is supplied.</source>
          <target state="translated">第一个示例向缺少时区的值添加时区，并使用当前的 &lt;code&gt;TimeZone&lt;/code&gt; 设置显示该值。第二个示例将带有时区值的时间戳移到指定的时区，并返回不带时区的值。这样可以存储和显示与当前 &lt;code&gt;TimeZone&lt;/code&gt; 设置不同的值。第三个示例将东京时间转换为芝加哥时间。由于没有提供日期，因此将&lt;em&gt;时间&lt;/em&gt;值转换为其他时区会使用当前活动的时区规则。</target>
        </trans-unit>
        <trans-unit id="dd4f388d81712247b36f96199e31fe01ab0dcd8a" translate="yes" xml:space="preserve">
          <source>The first example omits &lt;code&gt;ROW&lt;/code&gt;, the second uses it; we could have done it either way.</source>
          <target state="translated">第一个示例省略了 &lt;code&gt;ROW&lt;/code&gt; ，第二个示例使用了它。我们可以以任何一种方式做到。</target>
        </trans-unit>
        <trans-unit id="612c7d9435df3c5121ea73e09ab866021bad4c1b" translate="yes" xml:space="preserve">
          <source>The first example selects the ICU locale using a &amp;ldquo;language tag&amp;rdquo; per BCP 47. The second example uses the traditional ICU-specific locale syntax. The first style is preferred going forward, but it is not supported by older ICU versions.</source>
          <target state="translated">第一个示例根据BCP 47使用&amp;ldquo;语言标记&amp;rdquo;选择ICU语言环境。第二个示例使用传统的ICU特定语言环境语法。首选使用第一种样式，但是较旧的ICU版本不支持该样式。</target>
        </trans-unit>
        <trans-unit id="f1d60b8c5a21ae5115bceb8211e299ddf895cf0f" translate="yes" xml:space="preserve">
          <source>The first example shows how to spread a command over several lines of input. Notice the changing prompt:</source>
          <target state="translated">第一个例子展示了如何将一条命令分布在几行输入中。请注意不断变化的提示。</target>
        </trans-unit>
        <trans-unit id="e43256b97dc53da480190315bac59bb3f0cada5f" translate="yes" xml:space="preserve">
          <source>The first form changes certain per-database settings. (See below for details.) Only the database owner or a superuser can change these settings.</source>
          <target state="translated">第一种形式可以更改每个数据库的某些设置。详情请参见下文。)只有数据库所有者或超级用户可以更改这些设置。</target>
        </trans-unit>
        <trans-unit id="da17ae59b4b9d415d049588fbe4c802a8a77a808" translate="yes" xml:space="preserve">
          <source>The first form of &lt;code&gt;CREATE TYPE&lt;/code&gt; creates a composite type. The composite type is specified by a list of attribute names and data types. An attribute's collation can be specified too, if its data type is collatable. A composite type is essentially the same as the row type of a table, but using &lt;code&gt;CREATE TYPE&lt;/code&gt; avoids the need to create an actual table when all that is wanted is to define a type. A stand-alone composite type is useful, for example, as the argument or return type of a function.</source>
          <target state="translated">&lt;code&gt;CREATE TYPE&lt;/code&gt; 的第一种形式创建复合类型。组合类型由属性名称和数据类型的列表指定。如果属性的数据类型是可排序的，则也可以指定该属性的排序规则。复合类型与表的行类型本质上相同，但是使用 &lt;code&gt;CREATE TYPE&lt;/code&gt; 可以避免在只需要定义类型时创建实际表。独立的复合类型很有用，例如，用作函数的参数或返回类型。</target>
        </trans-unit>
        <trans-unit id="a9da06ff6dbdef653da94da0ffaf44a0aef0024f" translate="yes" xml:space="preserve">
          <source>The first form of aggregate expression invokes the aggregate once for each input row. The second form is the same as the first, since &lt;code&gt;ALL&lt;/code&gt; is the default. The third form invokes the aggregate once for each distinct value of the expression (or distinct set of values, for multiple expressions) found in the input rows. The fourth form invokes the aggregate once for each input row; since no particular input value is specified, it is generally only useful for the &lt;code&gt;count(*)&lt;/code&gt; aggregate function. The last form is used with &lt;em&gt;ordered-set&lt;/em&gt; aggregate functions, which are described below.</source>
          <target state="translated">聚合表达式的第一种形式为每个输入行调用一次聚合。第二种形式与第一种形式相同，因为 &lt;code&gt;ALL&lt;/code&gt; 是默认形式。第三种形式为在输入行中找到的表达式的每个不同值（或多个表达式的不同值集）调用一次聚合。第四种形式为每个输入行调用一次聚合；由于未指定特定的输入值，因此通常仅对 &lt;code&gt;count(*)&lt;/code&gt; 聚合函数有用。最后一种形式与&lt;em&gt;有序集合&lt;/em&gt;聚合函数一起使用，如下所述。</target>
        </trans-unit>
        <trans-unit id="c6c37d2c4cb9171a6fcf0c1214edbc6145fc4b4d" translate="yes" xml:space="preserve">
          <source>The first form of the &lt;code&gt;CREATE TYPE&lt;/code&gt; command, which creates a composite type, conforms to the SQL standard. The other forms are PostgreSQL extensions. The &lt;code&gt;CREATE TYPE&lt;/code&gt; statement in the SQL standard also defines other forms that are not implemented in PostgreSQL.</source>
          <target state="translated">创建复合类型的 &lt;code&gt;CREATE TYPE&lt;/code&gt; 命令的第一种形式符合SQL标准。其他形式是PostgreSQL扩展。SQL标准中的 &lt;code&gt;CREATE TYPE&lt;/code&gt; 语句还定义了PostgreSQL中未实现的其他形式。</target>
        </trans-unit>
        <trans-unit id="c38ff028812a13bb491adf5222d97dc3de42b820" translate="yes" xml:space="preserve">
          <source>The first line of an affix class is the header. Fields of an affix rules are listed after the header:</source>
          <target state="translated">一个词缀类的第一行是头。一个词缀规则的字段列在页眉之后。</target>
        </trans-unit>
        <trans-unit id="c36e2c0d0e2475af262a16c7939f4fd6fcb834b7" translate="yes" xml:space="preserve">
          <source>The first number in the &lt;code&gt;-L&lt;/code&gt; argument, 63333, is the local port number of the tunnel; it can be any unused port. (IANA reserves ports 49152 through 65535 for private use.) The name or IP address after this is the remote bind address you are connecting to, i.e., &lt;code&gt;localhost&lt;/code&gt;, which is the default. The second number, 5432, is the remote end of the tunnel, e.g., the port number your database server is using. In order to connect to the database server using this tunnel, you connect to port 63333 on the local machine:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e805cf56cf5d6631bb0160a0e06bad5df15b037" translate="yes" xml:space="preserve">
          <source>The first number in the &lt;code&gt;-L&lt;/code&gt; argument, 63333, is the port number of your end of the tunnel; it can be any unused port. (IANA reserves ports 49152 through 65535 for private use.) The second number, 5432, is the remote end of the tunnel: the port number your server is using. The name or IP address between the port numbers is the host with the database server you are going to connect to, as seen from the host you are logging in to, which is &lt;code&gt;foo.com&lt;/code&gt; in this example. In order to connect to the database server using this tunnel, you connect to port 63333 on the local machine:</source>
          <target state="translated">&lt;code&gt;-L&lt;/code&gt; 参数中的第一个数字63333是隧道末端的端口号。它可以是任何未使用的端口。 （IANA保留端口49152至65535供私人使用。）第二个数字5432是隧道的远程端：服务器使用的端口号。端口号之间的名称或IP地址是您要连接到的数据库服务器的主机，从登录的主机可以看到，在此示例中为 &lt;code&gt;foo.com&lt;/code&gt; 。为了使用此隧道连接到数据库服务器，请连接到本地计算机上的端口63333：</target>
        </trans-unit>
        <trans-unit id="3f99873fa941c47208f84d01e9069ef478e98de2" translate="yes" xml:space="preserve">
          <source>The first one worked using &lt;em&gt;row level&lt;/em&gt; processing and was implemented deep in the &lt;em&gt;executor&lt;/em&gt;. The rule system was called whenever an individual row had been accessed. This implementation was removed in 1995 when the last official release of the Berkeley Postgres project was transformed into Postgres95.</source>
          <target state="translated">第一个使用工作&lt;em&gt;行级&lt;/em&gt;处理，并在深实施&lt;em&gt;执行&lt;/em&gt;。每当访问单个行时，就会调用规则系统。1995年，当伯克利Postgres项目的最后一个正式版本转换为Postgres95时，此实现被删除。</target>
        </trans-unit>
        <trans-unit id="0fa18c39fe287e28bd5e7314fe8af5727d16d727" translate="yes" xml:space="preserve">
          <source>The first schema in the search path that exists is the default location for creating new objects. That is the reason that by default objects are created in the public schema. When objects are referenced in any other context without schema qualification (table modification, data modification, or query commands) the search path is traversed until a matching object is found. Therefore, in the default configuration, any unqualified access again can only refer to the public schema.</source>
          <target state="translated">搜索路径中存在的第一个模式是创建新对象的默认位置。这就是默认情况下对象是在公共模式中创建的原因。当在没有模式限定的任何其他上下文中引用对象时(表修改、数据修改或查询命令),搜索路径会被遍历,直到找到匹配的对象。因此,在默认配置中,任何不限定的访问又只能引用公共模式。</target>
        </trans-unit>
        <trans-unit id="9f3413da7a0291a52f1a7dcc2b820079440b3c54" translate="yes" xml:space="preserve">
          <source>The first schema named in the search path is called the current schema. Aside from being the first schema searched, it is also the schema in which new tables will be created if the &lt;code&gt;CREATE TABLE&lt;/code&gt; command does not specify a schema name.</source>
          <target state="translated">在搜索路径中命名的第一个模式称为当前模式。除了作为第一个搜索的架构之外，如果 &lt;code&gt;CREATE TABLE&lt;/code&gt; 命令未指定架构名称，它也是将在其中创建新表的架构。</target>
        </trans-unit>
        <trans-unit id="9d12bc7a9f0942909d34ace4bd41d7e184667d01" translate="yes" xml:space="preserve">
          <source>The first six lines report some of the most important parameter settings. The next line reports the number of transactions completed and intended (the latter being just the product of number of clients and number of transactions per client); these will be equal unless the run failed before completion. (In &lt;code&gt;-T&lt;/code&gt; mode, only the actual number of transactions is printed.) The last two lines report the number of transactions per second, figured with and without counting the time to start database sessions.</source>
          <target state="translated">前六行报告一些最重要的参数设置。下一行报告已完成和预期的交易数量（后者仅是客户数量和每个客户交易数量的乘积）；除非运行在完成前失败，否则它们将相等。 （在 &lt;code&gt;-T&lt;/code&gt; 模式下，仅打印实际的事务数。）最后两行报告每秒的事务数，计算有无开始数据库会话的时间。</target>
        </trans-unit>
        <trans-unit id="46861698534eb993d5363434e9d5cb2bd00b93d2" translate="yes" xml:space="preserve">
          <source>The first step is to generate an auxiliary table containing all the unique words in the documents:</source>
          <target state="translated">第一步是生成一个包含文档中所有唯一词的辅助表。</target>
        </trans-unit>
        <trans-unit id="d440c66135f418ef7372813549a4be5ffe416b8b" translate="yes" xml:space="preserve">
          <source>The first test to see whether you can access the database server is to try to create a database. A running PostgreSQL server can manage many databases. Typically, a separate database is used for each project or for each user.</source>
          <target state="translated">第一个测试是否可以访问数据库服务器的方法是尝试创建一个数据库。一个正在运行的PostgreSQL服务器可以管理许多数据库。通常情况下,每个项目或每个用户都会使用一个单独的数据库。</target>
        </trans-unit>
        <trans-unit id="c00d09908f3f4ddbf657d8ad0f17eabf84136b00" translate="yes" xml:space="preserve">
          <source>The first three output columns come directly from the table &lt;code&gt;empsalary&lt;/code&gt;, and there is one output row for each row in the table. The fourth column represents an average taken across all the table rows that have the same &lt;code&gt;depname&lt;/code&gt; value as the current row. (This actually is the same function as the non-window &lt;code&gt;avg&lt;/code&gt; aggregate, but the &lt;code&gt;OVER&lt;/code&gt; clause causes it to be treated as a window function and computed across the window frame.)</source>
          <target state="translated">前三个输出列直接来自表 &lt;code&gt;empsalary&lt;/code&gt; ，表中的每一行都有一个输出行。第四列代表与当前行具有相同 &lt;code&gt;depname&lt;/code&gt; 值的所有表行的平均值。 （这实际上与非窗口 &lt;code&gt;avg&lt;/code&gt; 聚合具有相同的功能，但是 &lt;code&gt;OVER&lt;/code&gt; 子句将其视为窗口函数并在整个窗口框架内进行计算。）</target>
        </trans-unit>
        <trans-unit id="c0413166d43e378dc8855747d05360346ec4b249" translate="yes" xml:space="preserve">
          <source>The first three parameters are inputs:</source>
          <target state="translated">前三个参数是输入。</target>
        </trans-unit>
        <trans-unit id="54956845c90a8b39103dc2ab8d6e4402b710d114" translate="yes" xml:space="preserve">
          <source>The first three variants change which tables are part of the publication. The &lt;code&gt;SET TABLE&lt;/code&gt; clause will replace the list of tables in the publication with the specified one. The &lt;code&gt;ADD TABLE&lt;/code&gt; and &lt;code&gt;DROP TABLE&lt;/code&gt; clauses will add and remove one or more tables from the publication. Note that adding tables to a publication that is already subscribed to will require a &lt;code&gt;ALTER SUBSCRIPTION ... REFRESH PUBLICATION&lt;/code&gt; action on the subscribing side in order to become effective.</source>
          <target state="translated">前三个变体更改哪些表是出版物的一部分。在 &lt;code&gt;SET TABLE&lt;/code&gt; 子句将替换用指定的出版物表的列表。的 &lt;code&gt;ADD TABLE&lt;/code&gt; 和 &lt;code&gt;DROP TABLE&lt;/code&gt; 子句将添加和删除发布一个或多个表。请注意，向已订阅的发布中添加表将需要在订阅侧进行 &lt;code&gt;ALTER SUBSCRIPTION ... REFRESH PUBLICATION&lt;/code&gt; 操作，以使其生效。</target>
        </trans-unit>
        <trans-unit id="70d5b4450dbfd9e788e4338d7701eefa6a67f05f" translate="yes" xml:space="preserve">
          <source>The first trigger argument must be the name of the &lt;code&gt;tsvector&lt;/code&gt; column to be updated. The second argument specifies the text search configuration to be used to perform the conversion. For &lt;code&gt;tsvector_update_trigger&lt;/code&gt;, the configuration name is simply given as the second trigger argument. It must be schema-qualified as shown above, so that the trigger behavior will not change with changes in &lt;code&gt;search_path&lt;/code&gt;. For &lt;code&gt;tsvector_update_trigger_column&lt;/code&gt;, the second trigger argument is the name of another table column, which must be of type &lt;code&gt;regconfig&lt;/code&gt;. This allows a per-row selection of configuration to be made. The remaining argument(s) are the names of textual columns (of type &lt;code&gt;text&lt;/code&gt;, &lt;code&gt;varchar&lt;/code&gt;, or &lt;code&gt;char&lt;/code&gt;). These will be included in the document in the order given. NULL values will be skipped (but the other columns will still be indexed).</source>
          <target state="translated">第一个触发器参数必须是要更新的 &lt;code&gt;tsvector&lt;/code&gt; 列的名称。第二个参数指定用于执行转换的文本搜索配置。对于 &lt;code&gt;tsvector_update_trigger&lt;/code&gt; ，配置名称仅作为第二个触发器参数给出。如上所示，它必须是模式限定的，这样触发行为就不会随着 &lt;code&gt;search_path&lt;/code&gt; 的改变而改变。对于 &lt;code&gt;tsvector_update_trigger_column&lt;/code&gt; ，第二个触发器参数是另一个表列的名称，该列的类型必须为 &lt;code&gt;regconfig&lt;/code&gt; 。这允许按行选择配置。其余参数是文本列的名称（类型为 &lt;code&gt;text&lt;/code&gt; ， &lt;code&gt;varchar&lt;/code&gt; ，或 &lt;code&gt;char&lt;/code&gt; ）。这些将按照给定的顺序包含在文档中。NULL值将被跳过（但其他列仍将被索引）。</target>
        </trans-unit>
        <trans-unit id="01ce9912b77202e1b48ed397f2bfc3b3783947c2" translate="yes" xml:space="preserve">
          <source>The first two constraints should look familiar. The third one uses a new syntax. It is not attached to a particular column, instead it appears as a separate item in the comma-separated column list. Column definitions and these constraint definitions can be listed in mixed order.</source>
          <target state="translated">前两个约束条件看起来应该很熟悉。第三个约束条件使用了一种新的语法。它不与特定的列相连,而是作为一个单独的项目出现在以逗号分隔的列列表中。列定义和这些约束定义可以以混合顺序列出。</target>
        </trans-unit>
        <trans-unit id="2927557f90bef3d374c5198102a6e3ea28461171" translate="yes" xml:space="preserve">
          <source>The first two of these we saw already. The form &lt;code&gt;text&lt;/code&gt;&lt;code&gt;@@&lt;/code&gt;&lt;code&gt;tsquery&lt;/code&gt; is equivalent to &lt;code&gt;to_tsvector(x) @@ y&lt;/code&gt;. The form &lt;code&gt;text&lt;/code&gt;&lt;code&gt;@@&lt;/code&gt;&lt;code&gt;text&lt;/code&gt; is equivalent to &lt;code&gt;to_tsvector(x) @@ plainto_tsquery(y)&lt;/code&gt;.</source>
          <target state="translated">我们已经看到了其中的前两个。形式 &lt;code&gt;text&lt;/code&gt; &lt;code&gt;@@&lt;/code&gt; &lt;code&gt;tsquery&lt;/code&gt; 等效于 &lt;code&gt;to_tsvector(x) @@ y&lt;/code&gt; 。形式 &lt;code&gt;text&lt;/code&gt; &lt;code&gt;@@&lt;/code&gt; &lt;code&gt;text&lt;/code&gt; 等效于 &lt;code&gt;to_tsvector(x) @@ plainto_tsquery(y)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cdaab7b9b529bcc8f6406321204002fe17ed4b88" translate="yes" xml:space="preserve">
          <source>The first two output columns are used for the current row's key and its parent row's key; they must match the type of the table's key field. The third output column is the depth in the tree and must be of type &lt;code&gt;integer&lt;/code&gt;. If a &lt;em&gt;&lt;code&gt;branch_delim&lt;/code&gt;&lt;/em&gt; parameter was given, the next output column is the branch display and must be of type &lt;code&gt;text&lt;/code&gt;. Finally, if an &lt;em&gt;&lt;code&gt;orderby_fld&lt;/code&gt;&lt;/em&gt; parameter was given, the last output column is a serial number, and must be of type &lt;code&gt;integer&lt;/code&gt;.</source>
          <target state="translated">前两个输出列用于当前行的键及其父行的键；它们必须匹配表的键字段的类型。第三输出列是树中的深度，并且必须是 &lt;code&gt;integer&lt;/code&gt; 类型。如果给出了&lt;em&gt; &lt;code&gt;branch_delim&lt;/code&gt; &lt;/em&gt;参数，则下一个输出列是分支显示，并且必须为 &lt;code&gt;text&lt;/code&gt; 类型。最后，如果给出了&lt;em&gt; &lt;code&gt;orderby_fld&lt;/code&gt; &lt;/em&gt;参数，则最后一个输出列是序列号，并且必须是 &lt;code&gt;integer&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="bf7215eea980a2a0bf86f75a412a5f3cd60fbcd5" translate="yes" xml:space="preserve">
          <source>The first two variants add users to a group or remove them from a group. (Any role can play the part of either a &amp;ldquo;user&amp;rdquo; or a &amp;ldquo;group&amp;rdquo; for this purpose.) These variants are effectively equivalent to granting or revoking membership in the role named as the &amp;ldquo;group&amp;rdquo;; so the preferred way to do this is to use &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; or &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt;.</source>
          <target state="translated">前两个变体将用户添加到组中或将其从组中删除。 （为此，任何角色都可以扮演&amp;ldquo;用户&amp;rdquo;或&amp;ldquo;组&amp;rdquo;的角色。）这些变体实际上等效于授予或撤消名为&amp;ldquo;组&amp;rdquo;的角色的成员资格；因此，执行此操作的首选方法是使用&lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt;或&lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="586ee19112a7a3ecf50504f1b0e758b680347d53" translate="yes" xml:space="preserve">
          <source>The first variant of this command listed in the synopsis can change many of the role attributes that can be specified in &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;. (All the possible attributes are covered, except that there are no options for adding or removing memberships; use &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; and &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; for that.) Attributes not mentioned in the command retain their previous settings. Database superusers can change any of these settings for any role. Roles having &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can change any of these settings except &lt;code&gt;SUPERUSER&lt;/code&gt;, &lt;code&gt;REPLICATION&lt;/code&gt;, and &lt;code&gt;BYPASSRLS&lt;/code&gt;; but only for non-superuser and non-replication roles. Ordinary roles can only change their own password.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b5e370e58213823b4126e17f4b6e7ad4cef2b17" translate="yes" xml:space="preserve">
          <source>The first variant of this command listed in the synopsis can change many of the role attributes that can be specified in &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;. (All the possible attributes are covered, except that there are no options for adding or removing memberships; use &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; and &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; for that.) Attributes not mentioned in the command retain their previous settings. Database superusers can change any of these settings for any role. Roles having &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can change any of these settings, but only for non-superuser and non-replication roles. Ordinary roles can only change their own password.</source>
          <target state="translated">概要中列出的该命令的第一个变体可以更改可以在&lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE中&lt;/a&gt;指定的许多角色属性。 （涵盖了所有可能的属性，除了没有用于添加或删除成员资格的选项；为此使用&lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt;和&lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt;。）命令中未提及的属性保留其先前的设置。数据库超级用户可以为任何角色更改任何这些设置。具有 &lt;code&gt;CREATEROLE&lt;/code&gt; 特权的角色可以更改任何这些设置，但仅适用于非超级用户和非复制角色。普通角色只能更改自己的密码。</target>
        </trans-unit>
        <trans-unit id="25ae6ee44a0f0d836e1704c794f00aceb8d356c4" translate="yes" xml:space="preserve">
          <source>The five mandatory user-defined methods are:</source>
          <target state="translated">五种强制性的用户定义方法是:</target>
        </trans-unit>
        <trans-unit id="72ce333d0c25ef1597b4fa8ad61ed91fb435220e" translate="yes" xml:space="preserve">
          <source>The following &amp;ldquo;parameters&amp;rdquo; are read-only, and are determined when PostgreSQL is compiled or when it is installed. As such, they have been excluded from the sample &lt;code&gt;postgresql.conf&lt;/code&gt; file. These options report various aspects of PostgreSQL behavior that might be of interest to certain applications, particularly administrative front-ends.</source>
          <target state="translated">以下&amp;ldquo;参数&amp;rdquo;是只读的，由PostgreSQL编译或安装时确定。因此，它们已从示例 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件中排除。这些选项报告了某些应用程序（尤其是管理前端）可能感兴趣的PostgreSQL行为的各个方面。</target>
        </trans-unit>
        <trans-unit id="a28614c3e8ef3dfbb002911a23857ed9cadcc2f2" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;method&lt;/code&gt;s for collecting the write-ahead logs are supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="771558088b2464a0c70d76532be21bcb4ca8194b" translate="yes" xml:space="preserve">
          <source>The following SQL-compatible functions can also be used to obtain the current time value for the corresponding data type: &lt;code&gt;CURRENT_DATE&lt;/code&gt;, &lt;code&gt;CURRENT_TIME&lt;/code&gt;, &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt;, &lt;code&gt;LOCALTIME&lt;/code&gt;, &lt;code&gt;LOCALTIMESTAMP&lt;/code&gt;. (See &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-CURRENT&quot;&gt;Section 9.9.4&lt;/a&gt;.) Note that these are SQL functions and are &lt;em&gt;not&lt;/em&gt; recognized in data input strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f94e73cd2b87aba8e9913a22c540c941db79c62c" translate="yes" xml:space="preserve">
          <source>The following SQL-compatible functions can also be used to obtain the current time value for the corresponding data type: &lt;code&gt;CURRENT_DATE&lt;/code&gt;, &lt;code&gt;CURRENT_TIME&lt;/code&gt;, &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt;, &lt;code&gt;LOCALTIME&lt;/code&gt;, &lt;code&gt;LOCALTIMESTAMP&lt;/code&gt;. The latter four accept an optional subsecond precision specification. (See &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-CURRENT&quot;&gt;Section 9.9.4&lt;/a&gt;.) Note that these are SQL functions and are &lt;em&gt;not&lt;/em&gt; recognized in data input strings.</source>
          <target state="translated">以下与SQL兼容的函数也可以用于获取对应数据类型的当前时间值： &lt;code&gt;CURRENT_DATE&lt;/code&gt; ， &lt;code&gt;CURRENT_TIME&lt;/code&gt; ， &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt; ， &lt;code&gt;LOCALTIME&lt;/code&gt; ， &lt;code&gt;LOCALTIMESTAMP&lt;/code&gt; 。后四个接受可选的亚秒精度规格。（请参阅&lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-CURRENT&quot;&gt;第9.9.4节&lt;/a&gt;。）请注意，这些是SQL函数，&lt;em&gt;不能&lt;/em&gt;在数据输入字符串中识别。</target>
        </trans-unit>
        <trans-unit id="7345097a3373ddd38c8dbf7f484bcb7a83adcfc5" translate="yes" xml:space="preserve">
          <source>The following SQL-standard functions work on bit strings as well as character strings: &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;bit_length&lt;/code&gt;, &lt;code&gt;octet_length&lt;/code&gt;, &lt;code&gt;position&lt;/code&gt;, &lt;code&gt;substring&lt;/code&gt;, &lt;code&gt;overlay&lt;/code&gt;.</source>
          <target state="translated">以下SQL标准函数对位字符串和字符串均适用： &lt;code&gt;length&lt;/code&gt; ， &lt;code&gt;bit_length&lt;/code&gt; ， &lt;code&gt;octet_length&lt;/code&gt; ， &lt;code&gt;position&lt;/code&gt; ， &lt;code&gt;substring&lt;/code&gt; ， &lt;code&gt;overlay&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9bd2c2e8eaa4afd48046645ba794fcbca53b28f4" translate="yes" xml:space="preserve">
          <source>The following additional options are available:</source>
          <target state="translated">可提供以下附加选项:</target>
        </trans-unit>
        <trans-unit id="0f218f3efdde351da4f071874c06c4afe80e209d" translate="yes" xml:space="preserve">
          <source>The following are all valid &lt;code&gt;json&lt;/code&gt; (or &lt;code&gt;jsonb&lt;/code&gt;) expressions:</source>
          <target state="translated">以下是所有有效的 &lt;code&gt;json&lt;/code&gt; （或 &lt;code&gt;jsonb&lt;/code&gt; ）表达式：</target>
        </trans-unit>
        <trans-unit id="c039bfa9f08ddfc0a59acd61d84cddcf4b0d6ac9" translate="yes" xml:space="preserve">
          <source>The following caveats apply to constraint exclusion:</source>
          <target state="translated">以下注意事项适用于约束排除。</target>
        </trans-unit>
        <trans-unit id="ed89af6d7b571e68348aa46975289d8d36b6f9e9" translate="yes" xml:space="preserve">
          <source>The following caveats apply to partitioning implemented using inheritance:</source>
          <target state="translated">以下注意事项适用于使用继承实现的分区。</target>
        </trans-unit>
        <trans-unit id="29e533c6b217bf172992ac716839050a2d3fd0b7" translate="yes" xml:space="preserve">
          <source>The following command can be used to create an index on the &lt;code&gt;id&lt;/code&gt; column, as discussed:</source>
          <target state="translated">如下所述，可以使用以下命令在 &lt;code&gt;id&lt;/code&gt; 列上创建索引：</target>
        </trans-unit>
        <trans-unit id="4545d07872378e0f1220b619c3281f607f171dfb" translate="yes" xml:space="preserve">
          <source>The following command defines a new operator, area-equality, for the data type &lt;code&gt;box&lt;/code&gt;:</source>
          <target state="translated">以下命令为数据类型 &lt;code&gt;box&lt;/code&gt; 定义一个新的运算符area-equality ：</target>
        </trans-unit>
        <trans-unit id="55cc91b2b085f350c73a66cbdf6d3a5a0c4fb379" translate="yes" xml:space="preserve">
          <source>The following command-line options are available:</source>
          <target state="translated">以下是可用的命令行选项。</target>
        </trans-unit>
        <trans-unit id="7065caab547161a186d449fdb20fb545416a7f46" translate="yes" xml:space="preserve">
          <source>The following command-line options control the connection to the source server:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b5ca5337b558c5af015478dbbd74c89d07107d2" translate="yes" xml:space="preserve">
          <source>The following command-line options control the content and format of the output.</source>
          <target state="translated">以下命令行选项控制输出的内容和格式。</target>
        </trans-unit>
        <trans-unit id="05475cf2eec87e97d8772a07ec18d9fdca7b5435" translate="yes" xml:space="preserve">
          <source>The following command-line options control the database connection parameters.</source>
          <target state="translated">以下是控制数据库连接参数的命令行选项。</target>
        </trans-unit>
        <trans-unit id="3d113b81b40bdffb0cde200d7b3c4f6a86ddbb52" translate="yes" xml:space="preserve">
          <source>The following command-line options control the generation of the backup and the invocation of the program:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="220365fea8f99014f431d00f0ea052b58e2c1fcb" translate="yes" xml:space="preserve">
          <source>The following command-line options control the generation of the backup and the running of the program.</source>
          <target state="translated">以下命令行选项控制备份的生成和程序的运行。</target>
        </trans-unit>
        <trans-unit id="a56b05f8e623fa43fb5bc9f1eeba6d4c3440d581" translate="yes" xml:space="preserve">
          <source>The following command-line options control the location and format of the output and other replication behavior:</source>
          <target state="translated">以下命令行选项控制输出的位置和格式以及其他复制行为。</target>
        </trans-unit>
        <trans-unit id="f449555e10b2046b1ccc209c3ef5b6dce0f90612" translate="yes" xml:space="preserve">
          <source>The following command-line options control the location and format of the output.</source>
          <target state="translated">以下命令行选项控制输出的位置和格式。</target>
        </trans-unit>
        <trans-unit id="00a034b5b9d901cf6c0ba2052c558173c4b654b2" translate="yes" xml:space="preserve">
          <source>The following command-line options control the location and format of the output:</source>
          <target state="translated">以下命令行选项控制输出的位置和格式。</target>
        </trans-unit>
        <trans-unit id="b90c14e70ab12e4fce9bec3bf939f8e3cd367938" translate="yes" xml:space="preserve">
          <source>The following configuration options are supported for GSSAPI:</source>
          <target state="translated">GSSAPI支持以下配置选项。</target>
        </trans-unit>
        <trans-unit id="46edfe1841a44936730cc915774b2516fbe1a78a" translate="yes" xml:space="preserve">
          <source>The following configuration options are supported for PAM:</source>
          <target state="translated">PAM支持以下配置选项。</target>
        </trans-unit>
        <trans-unit id="514923f06896538a2f8d0943aa9139974686a363" translate="yes" xml:space="preserve">
          <source>The following configuration options are supported for RADIUS:</source>
          <target state="translated">RADIUS支持以下配置选项。</target>
        </trans-unit>
        <trans-unit id="acf0b28821a566799fd52288a31f3e25a128c408" translate="yes" xml:space="preserve">
          <source>The following configuration options are supported for SSL certificate authentication:</source>
          <target state="translated">SSL证书认证支持以下配置选项。</target>
        </trans-unit>
        <trans-unit id="bad3bae7c6cb5e9156e0aafc4f4c4d5aa18bfd10" translate="yes" xml:space="preserve">
          <source>The following configuration options are supported for SSPI:</source>
          <target state="translated">SSPI支持以下配置选项。</target>
        </trans-unit>
        <trans-unit id="be704faf73a86cf08decb39d5cfdd09dedabb81b" translate="yes" xml:space="preserve">
          <source>The following configuration options are supported for ident:</source>
          <target state="translated">ident.支持以下配置选项。</target>
        </trans-unit>
        <trans-unit id="7fd3b16b14e5df4be73c034d0d0a8f2f793213cc" translate="yes" xml:space="preserve">
          <source>The following configuration options are supported for peer:</source>
          <target state="translated">对等体支持以下配置选项。</target>
        </trans-unit>
        <trans-unit id="b2cc6138e97e8a814646a47d2cd6ecdb0c1d8d16" translate="yes" xml:space="preserve">
          <source>The following configuration options are used in both modes:</source>
          <target state="translated">以下配置选项在两种模式下均可使用。</target>
        </trans-unit>
        <trans-unit id="82ae133d649ffad972068d98ba1e0a950ea94086" translate="yes" xml:space="preserve">
          <source>The following containment predicate uses the point syntax, while in fact the second argument is internally represented by a box. This syntax makes it unnecessary to define a separate point type and functions for (box,point) predicates.</source>
          <target state="translated">下面的包含谓词使用了点语法,而实际上第二个参数在内部是由一个盒子来表示的。这种语法使得没有必要为(box,point)谓词单独定义一个点类型和函数。</target>
        </trans-unit>
        <trans-unit id="ab1f58c5086fb9d7dbb2dff29ebf934fc1fd38a7" translate="yes" xml:space="preserve">
          <source>The following example command &amp;ldquo;updates&amp;rdquo; the dictionary's definition without actually changing anything.</source>
          <target state="translated">以下示例命令&amp;ldquo;更新&amp;rdquo;字典的定义，而无需实际更改任何内容。</target>
        </trans-unit>
        <trans-unit id="5f20cbbdfc0e4abc07d317b7cde01bad2e3188ac" translate="yes" xml:space="preserve">
          <source>The following example command adds cross-data-type operators and support functions to an operator family that already contains B-tree operator classes for data types &lt;code&gt;int4&lt;/code&gt; and &lt;code&gt;int2&lt;/code&gt;.</source>
          <target state="translated">以下示例命令将跨数据类型的运算符和支持功能添加到一个运算符系列中，该运算符系列已经包含数据类型 &lt;code&gt;int4&lt;/code&gt; 和 &lt;code&gt;int2&lt;/code&gt; 的 B树运算符类。</target>
        </trans-unit>
        <trans-unit id="98ce952daa9dd539b9ae5ea67f8fc03311bc7883" translate="yes" xml:space="preserve">
          <source>The following example command changes the language option to &lt;code&gt;dutch&lt;/code&gt;, and removes the stopword option entirely.</source>
          <target state="translated">以下示例命令将language选项更改为 &lt;code&gt;dutch&lt;/code&gt; ，并完全删除了停用词选项。</target>
        </trans-unit>
        <trans-unit id="0690fd36226cece879c24f85e0b2a34e7740cb2a" translate="yes" xml:space="preserve">
          <source>The following example command changes the stopword list for a Snowball-based dictionary. Other parameters remain unchanged.</source>
          <target state="translated">下面的示例命令改变了基于雪球的字典的停止词列表。其他参数保持不变。</target>
        </trans-unit>
        <trans-unit id="c6c6101649b45994a81cc07611f7c341ccfd2d4d" translate="yes" xml:space="preserve">
          <source>The following example command creates a Snowball-based dictionary with a nonstandard list of stop words.</source>
          <target state="translated">下面的示例命令创建了一个基于雪球的字典,其中包含一个非标准的停止词列表。</target>
        </trans-unit>
        <trans-unit id="0540cfecb071eb102ec89874893aeae6b2dac906" translate="yes" xml:space="preserve">
          <source>The following example command defines a GiST index operator class for the data type &lt;code&gt;_int4&lt;/code&gt; (array of &lt;code&gt;int4&lt;/code&gt;). See the &lt;a href=&quot;intarray&quot;&gt;intarray&lt;/a&gt; module for the complete example.</source>
          <target state="translated">以下示例命令为数据类型 &lt;code&gt;_int4&lt;/code&gt; （ &lt;code&gt;int4&lt;/code&gt; 的数组）定义了GiST索引运算符类。有关完整的示例，请参见&lt;a href=&quot;intarray&quot;&gt;intarray&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="ef3a1ce4208d975ebd37d2a046e1777755826724" translate="yes" xml:space="preserve">
          <source>The following example copies a table to the client using the vertical bar (&lt;code&gt;|&lt;/code&gt;) as the field delimiter:</source>
          <target state="translated">下面的示例使用竖线（ &lt;code&gt;|&lt;/code&gt; ）作为字段定界符将表复制到客户端：</target>
        </trans-unit>
        <trans-unit id="0d013459769f3027ad75584e21efea2204848877" translate="yes" xml:space="preserve">
          <source>The following example illustrates how the &lt;code&gt;XMLNAMESPACES&lt;/code&gt; clause can be used to specify a list of namespaces used in the XML document as well as in the XPath expressions:</source>
          <target state="translated">下面的示例说明如何使用 &lt;code&gt;XMLNAMESPACES&lt;/code&gt; 子句来指定XML文档以及XPath表达式中使用的名称空间列表：</target>
        </trans-unit>
        <trans-unit id="8120020f967b896e9eb5f42600de6773abdc4c59" translate="yes" xml:space="preserve">
          <source>The following example puts the final account balance from the first query into variable &lt;code&gt;abalance&lt;/code&gt;, and fills variables &lt;code&gt;p_two&lt;/code&gt; and &lt;code&gt;p_three&lt;/code&gt; with integers from the third query. The result of the second query is discarded.</source>
          <target state="translated">下面的示例把最终的帐户余额从第一查询到可变 &lt;code&gt;abalance&lt;/code&gt; ，并填充变量 &lt;code&gt;p_two&lt;/code&gt; 和 &lt;code&gt;p_three&lt;/code&gt; 从第三个查询整数。第二个查询的结果将被丢弃。</target>
        </trans-unit>
        <trans-unit id="550fb6dd31ce5c45513c6afc9762a8e612652741" translate="yes" xml:space="preserve">
          <source>The following example puts the final account balance from the first query into variable &lt;code&gt;abalance&lt;/code&gt;, and fills variables &lt;code&gt;p_two&lt;/code&gt; and &lt;code&gt;p_three&lt;/code&gt; with integers from the third query. The result of the second query is discarded. The result of the two last combined queries are stored in variables &lt;code&gt;four&lt;/code&gt; and &lt;code&gt;five&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e0272043332c15e45fca8627b9940585ab0ce4a" translate="yes" xml:space="preserve">
          <source>The following example replaces the &lt;code&gt;english&lt;/code&gt; dictionary with the &lt;code&gt;swedish&lt;/code&gt; dictionary anywhere that &lt;code&gt;english&lt;/code&gt; is used within &lt;code&gt;my_config&lt;/code&gt;.</source>
          <target state="translated">以下示例在 &lt;code&gt;my_config&lt;/code&gt; 中使用 &lt;code&gt;english&lt;/code&gt; 任何地方，用 &lt;code&gt;swedish&lt;/code&gt; 词典替换 &lt;code&gt;english&lt;/code&gt; 词典。</target>
        </trans-unit>
        <trans-unit id="a86c39babfe81954fe9ebb108b217aea8248e655" translate="yes" xml:space="preserve">
          <source>The following example shows concatenation of multiple text() nodes, usage of the column name as XPath filter, and the treatment of whitespace, XML comments and processing instructions:</source>
          <target state="translated">下面的例子显示了多个text()节点的连接,列名作为XPath过滤器的使用,以及空格、XML注释和处理指令的处理。</target>
        </trans-unit>
        <trans-unit id="54642b031a2227e507d5a953bc0c97aa2f10ca2d" translate="yes" xml:space="preserve">
          <source>The following example shows how the security label of a table might be changed.</source>
          <target state="translated">下面的示例显示了如何更改表的安全标签。</target>
        </trans-unit>
        <trans-unit id="b9d0858a7dd21e2c17fd7d8938ac8b2bda33b78f" translate="yes" xml:space="preserve">
          <source>The following example shows the result of estimating a &lt;code&gt;WHERE&lt;/code&gt; condition on the &lt;code&gt;a&lt;/code&gt; column:</source>
          <target state="translated">以下示例显示了对 &lt;code&gt;a&lt;/code&gt; 列的 &lt;code&gt;WHERE&lt;/code&gt; 条件进行估算的结果：</target>
        </trans-unit>
        <trans-unit id="04036b5b20e932a63bf10913615aab08c6e7f9bb" translate="yes" xml:space="preserve">
          <source>The following example traverses a table using a cursor:</source>
          <target state="translated">下面的例子是使用游标遍历一个表。</target>
        </trans-unit>
        <trans-unit id="b0c8644502b27c5f09c1b2cd46083c907b3859da" translate="yes" xml:space="preserve">
          <source>The following examples will illustrate the usage of all three notations, using the following function definition:</source>
          <target state="translated">下面的例子将使用以下函数定义来说明这三种符号的用法。</target>
        </trans-unit>
        <trans-unit id="ddc2a5eced86eee0d88b99c3c79c239f1015ae7c" translate="yes" xml:space="preserve">
          <source>The following functions allow direct testing of a text search parser.</source>
          <target state="translated">以下函数可以直接测试文本搜索解析器。</target>
        </trans-unit>
        <trans-unit id="5e0070eaa8f2988c475085144814bd098c68e7d6" translate="yes" xml:space="preserve">
          <source>The following functions are available if libxslt is installed:</source>
          <target state="translated">如果安装了libxslt,则可以使用以下功能。</target>
        </trans-unit>
        <trans-unit id="6868f6a5c512b545d6b54882e8a5b465e4040e96" translate="yes" xml:space="preserve">
          <source>The following functions are available to delay execution of the server process:</source>
          <target state="translated">以下功能可用于延迟服务器进程的执行。</target>
        </trans-unit>
        <trans-unit id="7eaa7ab3c8107e57a840871a19a9fd7639ac2e60" translate="yes" xml:space="preserve">
          <source>The following functions map the contents of relational tables to XML values. They can be thought of as XML export functionality:</source>
          <target state="translated">以下函数将关系表的内容映射到XML值。它们可以被认为是XML导出功能。</target>
        </trans-unit>
        <trans-unit id="d99534b0054b1dbaf525bfa83dffbf3dceb4ed5a" translate="yes" xml:space="preserve">
          <source>The following functions produce XML data mappings and the corresponding XML Schema in one document (or forest), linked together. They can be useful where self-contained and self-describing results are wanted:</source>
          <target state="translated">以下函数在一个文档(或森林)中产生XML数据映射和相应的XML Schema,并连接在一起。在需要自足的和自描述的结果时,它们可能很有用。</target>
        </trans-unit>
        <trans-unit id="0717a340e1889a17503b962f24442ac075bb61f2" translate="yes" xml:space="preserve">
          <source>The following functions return XML Schema documents describing the mappings performed by the corresponding functions above:</source>
          <target state="translated">以下函数返回描述上述相应函数执行的映射的XML Schema文档。</target>
        </trans-unit>
        <trans-unit id="87e9cfe2ae99c540eae639b3c0d4e7139991c05c" translate="yes" xml:space="preserve">
          <source>The following functions work on bit strings as well as binary strings: &lt;code&gt;get_bit&lt;/code&gt;, &lt;code&gt;set_bit&lt;/code&gt;. When working with a bit string, these functions number the first (leftmost) bit of the string as bit 0.</source>
          <target state="translated">以下函数可用于位字符串和二进制字符串： &lt;code&gt;get_bit&lt;/code&gt; ， &lt;code&gt;set_bit&lt;/code&gt; 。使用位字符串时，这些函数将字符串的第一个（最左边）的位编号为0。</target>
        </trans-unit>
        <trans-unit id="f8888d531981405af8909029406e91231d32e3fc" translate="yes" xml:space="preserve">
          <source>The following is an equivalent way of accomplishing the same result:</source>
          <target state="translated">以下是实现同样结果的同等方法。</target>
        </trans-unit>
        <trans-unit id="f5156ec918109db1c50b00eba83d4a25d3045435" translate="yes" xml:space="preserve">
          <source>The following is divided into three subsections. Different options are used during database initialization and while running benchmarks, but some options are useful in both cases.</source>
          <target state="translated">下面分为三个小节。在数据库初始化期间和运行基准时使用不同的选项,但有些选项在两种情况下都有用。</target>
        </trans-unit>
        <trans-unit id="647af377018af1687ed8efb04b9618837aa7790d" translate="yes" xml:space="preserve">
          <source>The following is the same data, output in binary format. The data is shown after filtering through the Unix utility &lt;code&gt;od -c&lt;/code&gt;. The table has three columns; the first has type &lt;code&gt;char(2)&lt;/code&gt;, the second has type &lt;code&gt;text&lt;/code&gt;, and the third has type &lt;code&gt;integer&lt;/code&gt;. All the rows have a null value in the third column.</source>
          <target state="translated">以下是相同的数据，以二进制格式输出。通过Unix实用程序 &lt;code&gt;od -c&lt;/code&gt; 过滤后显示数据。该表有三列；第一个具有 &lt;code&gt;char(2)&lt;/code&gt; 类型，第二个具有 &lt;code&gt;text&lt;/code&gt; 类型，第三个具有 &lt;code&gt;integer&lt;/code&gt; 类型。所有行在第三列中都为空值。</target>
        </trans-unit>
        <trans-unit id="c1be0628b6cf705e05d346385bba0020aac7aea8" translate="yes" xml:space="preserve">
          <source>The following keys are currently in use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eda35f89f366a92b9c1f3ee20bc9ca7f81e63cc1" translate="yes" xml:space="preserve">
          <source>The following less trivial example writes the Russian word &amp;ldquo;slon&amp;rdquo; (elephant) in Cyrillic letters:</source>
          <target state="translated">以下不那么简单的示例用西里尔字母写俄语单词&amp;ldquo; slon&amp;rdquo;（大象）：</target>
        </trans-unit>
        <trans-unit id="189e345b5ef4ff87c793abeb8737dfccbc0f04c1" translate="yes" xml:space="preserve">
          <source>The following limitations apply to partitioned tables:</source>
          <target state="translated">以下限制适用于分区表。</target>
        </trans-unit>
        <trans-unit id="44e788f5edc12a91d7e7f317a229ad70f5f2729c" translate="yes" xml:space="preserve">
          <source>The following meta-commands are defined:</source>
          <target state="translated">定义了以下元命令。</target>
        </trans-unit>
        <trans-unit id="cd608061d746b035415cdac00c81458451b62316" translate="yes" xml:space="preserve">
          <source>The following methods for collecting the write-ahead logs are supported:</source>
          <target state="translated">支持以下方法收集写前日志。</target>
        </trans-unit>
        <trans-unit id="a56049877daf2d04bdadddbc86e9035f590ef7d4" translate="yes" xml:space="preserve">
          <source>The following non-standard approach used to be recommended in previous versions, and may still be useful in specific cases:</source>
          <target state="translated">在以前的版本中曾经推荐过以下非标准方法,在特定情况下可能仍然有用。</target>
        </trans-unit>
        <trans-unit id="8a441d0a9d0ce26e47c5d9596d3d57e320cb00a5" translate="yes" xml:space="preserve">
          <source>The following operations are always parallel restricted.</source>
          <target state="translated">以下操作总是受到并行限制。</target>
        </trans-unit>
        <trans-unit id="0e406b45cfda5d02b89a1154761a86fa7316f577" translate="yes" xml:space="preserve">
          <source>The following operations are always parallel restricted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51e78db2119a951e7a8c9fc8a972d223a3355886" translate="yes" xml:space="preserve">
          <source>The following options are only needed when &lt;code&gt;pg_resetwal&lt;/code&gt; is unable to determine appropriate values by reading &lt;code&gt;pg_control&lt;/code&gt;. Safe values can be determined as described below. For values that take numeric arguments, hexadecimal values can be specified by using the prefix &lt;code&gt;0x&lt;/code&gt;.</source>
          <target state="translated">仅当 &lt;code&gt;pg_resetwal&lt;/code&gt; 无法通过读取 &lt;code&gt;pg_control&lt;/code&gt; 确定适当的值时，才需要以下选项。可以如下所述确定安全值。对于采用数字参数的值，可以使用前缀 &lt;code&gt;0x&lt;/code&gt; 指定十六进制值。</target>
        </trans-unit>
        <trans-unit id="69bed63b9b9fa472f1bfef341fe738b22ca2d102" translate="yes" xml:space="preserve">
          <source>The following options are used in search+bind mode only:</source>
          <target state="translated">以下选项仅在搜索+绑定模式下使用。</target>
        </trans-unit>
        <trans-unit id="a727fc2f66779d9648449bd2ed769b9bf5969532" translate="yes" xml:space="preserve">
          <source>The following options are used in simple bind mode only:</source>
          <target state="translated">以下选项仅在简单绑定模式下使用。</target>
        </trans-unit>
        <trans-unit id="537f6640d02bb24a88ec9d9b40defc6c0eca02e5" translate="yes" xml:space="preserve">
          <source>The following options further specify the recovery target, and affect what happens when the target is reached:</source>
          <target state="translated">以下选项进一步指定了恢复目标,并影响到达到目标后的情况。</target>
        </trans-unit>
        <trans-unit id="b33280ef9e0c134ead04314d2e16bd6297d099cc" translate="yes" xml:space="preserve">
          <source>The following options only apply to the single-user mode (see &lt;a href=&quot;app-postgres#APP-POSTGRES-SINGLE-USER&quot;&gt;Single-User Mode&lt;/a&gt; below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7135a7643cb1d0d74cb2e4a970ae91d9faed5be8" translate="yes" xml:space="preserve">
          <source>The following options only apply to the single-user mode (see &lt;a href=&quot;app-postgres#APP-POSTGRES-SINGLE-USER&quot;&gt;Single-User Mode&lt;/a&gt;).</source>
          <target state="translated">以下选项仅适用于单用户模式（请参阅&lt;a href=&quot;app-postgres#APP-POSTGRES-SINGLE-USER&quot;&gt;单用户模式&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="4e806d19c35f4be356192bcaf56df7bac7d67cbd" translate="yes" xml:space="preserve">
          <source>The following parameters are intended for work on the PostgreSQL source code, and in some cases to assist with recovery of severely damaged databases. There should be no reason to use them on a production database. As such, they have been excluded from the sample &lt;code&gt;postgresql.conf&lt;/code&gt; file. Note that many of these parameters require special source compilation flags to work at all.</source>
          <target state="translated">以下参数旨在用于PostgreSQL源代码，并且在某些情况下有助于恢复严重受损的数据库。应该没有理由在生产数据库上使用它们。因此，它们已从示例 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件中排除。请注意，这些参数中的许多参数都需要特殊的源代码编译标志才能完全起作用。</target>
        </trans-unit>
        <trans-unit id="4026e02031547a37479fb9b05f84b97775d5fe92" translate="yes" xml:space="preserve">
          <source>The following query can be used to identify all collations in the current database that need to be refreshed and the objects that depend on them:</source>
          <target state="translated">下面的查询可以用来识别当前数据库中所有需要刷新的整理和依赖于它们的对象。</target>
        </trans-unit>
        <trans-unit id="c0122a37523d76103f38f449cd343e0b060ab0d9" translate="yes" xml:space="preserve">
          <source>The following query shows all defined operator classes:</source>
          <target state="translated">下面的查询显示了所有已定义的操作类。</target>
        </trans-unit>
        <trans-unit id="8cfe858c80303e50296d8f2a37810c84b510900d" translate="yes" xml:space="preserve">
          <source>The following resources contain additional information about genetic algorithms:</source>
          <target state="translated">以下资源包含有关遗传算法的其他信息。</target>
        </trans-unit>
        <trans-unit id="66737f1e0a66b3e5bd4174eda08630ddc7c2985c" translate="yes" xml:space="preserve">
          <source>The following sections describe each of these authentication methods in more detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="327c23aaa47c9cad7b97d5d2a03e766b6d51df50" translate="yes" xml:space="preserve">
          <source>The following sections describe the authentication methods in more detail.</source>
          <target state="translated">下面的章节将更详细地介绍认证方法。</target>
        </trans-unit>
        <trans-unit id="aeb4c79f6ac510d43001882e836e62ac542ea4a4" translate="yes" xml:space="preserve">
          <source>The following sections describe the details of the select list, the table expression, and the sort specification. &lt;code&gt;WITH&lt;/code&gt; queries are treated last since they are an advanced feature.</source>
          <target state="translated">以下各节描述了选择列表，表表达式和排序规范的详细信息。 &lt;code&gt;WITH&lt;/code&gt; 查询是高级功能，因此它们将被最后处理。</target>
        </trans-unit>
        <trans-unit id="9d4ca436eba9354db1bd47061237b54b62f2b67c" translate="yes" xml:space="preserve">
          <source>The following special backslash sequences are recognized by &lt;code&gt;COPY FROM&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;COPY FROM&lt;/code&gt; 可以识别以下特殊的反斜杠序列：</target>
        </trans-unit>
        <trans-unit id="8f427c4f9638a34d3033435ec6c0132981a12871" translate="yes" xml:space="preserve">
          <source>The following steps occur in a concurrent reindex. Each step is run in a separate transaction. If there are multiple indexes to be rebuilt, then each step loops through all the indexes before moving to the next step.</source>
          <target state="translated">以下步骤在一个并发的重新索引中进行。每一步都在一个单独的事务中运行。如果有多个索引要重建,那么每一步都会在进入下一步之前循环浏览所有的索引。</target>
        </trans-unit>
        <trans-unit id="e32c87e22cead595c4cbd93a657097e6823f09e3" translate="yes" xml:space="preserve">
          <source>The following subsections describe the kinds of extended statistics that are currently supported.</source>
          <target state="translated">以下各小节介绍了目前支持的扩展统计的种类。</target>
        </trans-unit>
        <trans-unit id="542557b3d5f6134bfa542b4b0f72c63ee404d9ac" translate="yes" xml:space="preserve">
          <source>The following syntax was used before PostgreSQL version 7.3 and is still supported:</source>
          <target state="translated">以下语法在PostgreSQL 7.3版本之前使用,现在仍然支持。</target>
        </trans-unit>
        <trans-unit id="cb4264d6fcf534ad0d711543bbbad940acfd384f" translate="yes" xml:space="preserve">
          <source>The following syntax was used before PostgreSQL version 9.0 and is still supported:</source>
          <target state="translated">以下语法在PostgreSQL 9.0版本之前使用,现在仍然支持。</target>
        </trans-unit>
        <trans-unit id="7ffe77d533e655164667efaec733a8644752fd0c" translate="yes" xml:space="preserve">
          <source>The following table summarizes which types of triggers may be used on tables, views, and foreign tables:</source>
          <target state="translated">下表总结了哪些类型的触发器可以用于表、视图和外表。</target>
        </trans-unit>
        <trans-unit id="b9dedb03b6c7c1e94159053f8cafdd1b64ee1259" translate="yes" xml:space="preserve">
          <source>The following two examples are identical ways of sorting the individual results according to the contents of the second column (&lt;code&gt;name&lt;/code&gt;):</source>
          <target state="translated">以下两个示例是根据第二列（ &lt;code&gt;name&lt;/code&gt; ）的内容对单个结果进行排序的相同方法：</target>
        </trans-unit>
        <trans-unit id="a55bcd1aa5b5db14890555290a8f28e4c18316d2" translate="yes" xml:space="preserve">
          <source>The following two keys are always present:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f82d287994dca1133e1c905ec21b4420d1348aaa" translate="yes" xml:space="preserve">
          <source>The following types (or spellings thereof) are specified by SQL: &lt;code&gt;bigint&lt;/code&gt;, &lt;code&gt;bit&lt;/code&gt;, &lt;code&gt;bit varying&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;character varying&lt;/code&gt;, &lt;code&gt;character&lt;/code&gt;, &lt;code&gt;varchar&lt;/code&gt;, &lt;code&gt;date&lt;/code&gt;, &lt;code&gt;double precision&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;interval&lt;/code&gt;, &lt;code&gt;numeric&lt;/code&gt;, &lt;code&gt;decimal&lt;/code&gt;, &lt;code&gt;real&lt;/code&gt;, &lt;code&gt;smallint&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt; (with or without time zone), &lt;code&gt;timestamp&lt;/code&gt; (with or without time zone), &lt;code&gt;xml&lt;/code&gt;.</source>
          <target state="translated">SQL指定以下类型（或其拼写）： &lt;code&gt;bigint&lt;/code&gt; ， &lt;code&gt;bit&lt;/code&gt; ， &lt;code&gt;bit varying&lt;/code&gt; ， &lt;code&gt;boolean&lt;/code&gt; ， &lt;code&gt;char&lt;/code&gt; ， &lt;code&gt;character varying&lt;/code&gt; ， &lt;code&gt;character&lt;/code&gt; ， &lt;code&gt;varchar&lt;/code&gt; ， &lt;code&gt;date&lt;/code&gt; ， &lt;code&gt;double precision&lt;/code&gt; ， &lt;code&gt;integer&lt;/code&gt; ， &lt;code&gt;interval&lt;/code&gt; ， &lt;code&gt;numeric&lt;/code&gt; ， &lt;code&gt;decimal&lt;/code&gt; ， &lt;code&gt;real&lt;/code&gt; ， &lt;code&gt;smallint&lt;/code&gt; ， &lt;code&gt;time&lt;/code&gt; （带有或不带有时区）， &lt;code&gt;timestamp&lt;/code&gt; （带有或不带有时区）， &lt;code&gt;xml&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="008f4840c9bbbc114acf97e5143a54c88f68912b" translate="yes" xml:space="preserve">
          <source>The following types of administration commands are not accepted during recovery mode:</source>
          <target state="translated">在恢复模式下,不接受以下类型的管理命令。</target>
        </trans-unit>
        <trans-unit id="d4a4cbf72726623686906a4dfcab95be0271a53f" translate="yes" xml:space="preserve">
          <source>The following types of parallel-aware table scans are currently supported.</source>
          <target state="translated">目前支持以下类型的并行感知表扫描。</target>
        </trans-unit>
        <trans-unit id="45ec767602366e0da0c6d60741f363eda41896e3" translate="yes" xml:space="preserve">
          <source>The foreign server to import from.</source>
          <target state="translated">要导入的国外服务器。</target>
        </trans-unit>
        <trans-unit id="fbe288bd62bdf2a35ec4994319ad86594322f65f" translate="yes" xml:space="preserve">
          <source>The foreign-data wrapper name must be unique within the database.</source>
          <target state="translated">外来数据包装器的名称在数据库中必须是唯一的。</target>
        </trans-unit>
        <trans-unit id="721abb232cb1907cbf75dfbc734244683645423e" translate="yes" xml:space="preserve">
          <source>The form of &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; that does not supply any handler function is obsolete. For backwards compatibility with old dump files, it is interpreted as &lt;code&gt;CREATE EXTENSION&lt;/code&gt;. That will work if the language has been packaged into an extension of the same name, which is the conventional way to set up procedural languages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="128070d44af946b3f1ecf65ccd252fb06b8cf14f" translate="yes" xml:space="preserve">
          <source>The format of a psql command is the backslash, followed immediately by a command verb, then any arguments. The arguments are separated from the command verb and each other by any number of whitespace characters.</source>
          <target state="translated">psql命令的格式是反斜杠,紧接着是一个命令动词,然后是任何参数。参数与命令动词之间用任意数量的空白字符分开。</target>
        </trans-unit>
        <trans-unit id="7f3c7541e2c4fcc461ec02ccb2547741ee4be834" translate="yes" xml:space="preserve">
          <source>The format of the log is:</source>
          <target state="translated">日志的格式是:</target>
        </trans-unit>
        <trans-unit id="c1adf1c1ec6d1279c3ae3b2793de10b99dbd36d4" translate="yes" xml:space="preserve">
          <source>The formatting function &lt;code&gt;to_char&lt;/code&gt; (see &lt;a href=&quot;functions-formatting&quot;&gt;Section 9.8&lt;/a&gt;) is also available as a more flexible way to format date/time output.</source>
          <target state="translated">格式化函数 &lt;code&gt;to_char&lt;/code&gt; （请参见&lt;a href=&quot;functions-formatting&quot;&gt;第9.8节&lt;/a&gt;）也可以作为一种更灵活的方式来格式化日期/时间输出。</target>
        </trans-unit>
        <trans-unit id="9ba5e32cb8a2291627c08e67bf1bfb6249955cd8" translate="yes" xml:space="preserve">
          <source>The forms &lt;code&gt;ADD&lt;/code&gt; (without &lt;code&gt;USING INDEX&lt;/code&gt;), &lt;code&gt;DROP [COLUMN]&lt;/code&gt;, &lt;code&gt;DROP IDENTITY&lt;/code&gt;, &lt;code&gt;RESTART&lt;/code&gt;, &lt;code&gt;SET DEFAULT&lt;/code&gt;, &lt;code&gt;SET DATA TYPE&lt;/code&gt; (without &lt;code&gt;USING&lt;/code&gt;), &lt;code&gt;SET GENERATED&lt;/code&gt;, and &lt;code&gt;SET sequence_option&lt;/code&gt; conform with the SQL standard. The other forms are PostgreSQL extensions of the SQL standard. Also, the ability to specify more than one manipulation in a single &lt;code&gt;ALTER TABLE&lt;/code&gt; command is an extension.</source>
          <target state="translated">形式 &lt;code&gt;ADD&lt;/code&gt; （无 &lt;code&gt;USING INDEX&lt;/code&gt; ）， &lt;code&gt;DROP [COLUMN]&lt;/code&gt; ， &lt;code&gt;DROP IDENTITY&lt;/code&gt; ， &lt;code&gt;RESTART&lt;/code&gt; ， &lt;code&gt;SET DEFAULT&lt;/code&gt; ， &lt;code&gt;SET DATA TYPE&lt;/code&gt; （不 &lt;code&gt;USING&lt;/code&gt; ）， &lt;code&gt;SET GENERATED&lt;/code&gt; ，和 &lt;code&gt;SET sequence_option&lt;/code&gt; 符合SQL标准。其他形式是SQL标准的PostgreSQL扩展。同样，在单个 &lt;code&gt;ALTER TABLE&lt;/code&gt; 命令中指定多个操纵的功能也是一种扩展。</target>
        </trans-unit>
        <trans-unit id="60e0a26739b6392b783c8e0781017e51a86f2c82" translate="yes" xml:space="preserve">
          <source>The forms &lt;code&gt;ADD&lt;/code&gt;, &lt;code&gt;DROP&lt;/code&gt;, and &lt;code&gt;SET DATA TYPE&lt;/code&gt; conform with the SQL standard. The other forms are PostgreSQL extensions of the SQL standard. Also, the ability to specify more than one manipulation in a single &lt;code&gt;ALTER FOREIGN TABLE&lt;/code&gt; command is an extension.</source>
          <target state="translated">形式 &lt;code&gt;ADD&lt;/code&gt; ， &lt;code&gt;DROP&lt;/code&gt; 和 &lt;code&gt;SET DATA TYPE&lt;/code&gt; 符合SQL标准。其他形式是SQL标准的PostgreSQL扩展。同样，在单个 &lt;code&gt;ALTER FOREIGN TABLE&lt;/code&gt; 命令中指定多个操纵的功能也是一种扩展。</target>
        </trans-unit>
        <trans-unit id="ceb183e300587222b81cf3fc6aa4245c9a8136ea" translate="yes" xml:space="preserve">
          <source>The forms &lt;code&gt;NEXT&lt;/code&gt;, &lt;code&gt;PRIOR&lt;/code&gt;, &lt;code&gt;FIRST&lt;/code&gt;, &lt;code&gt;LAST&lt;/code&gt;, &lt;code&gt;ABSOLUTE&lt;/code&gt;, &lt;code&gt;RELATIVE&lt;/code&gt; fetch a single row after moving the cursor appropriately. If there is no such row, an empty result is returned, and the cursor is left positioned before the first row or after the last row as appropriate.</source>
          <target state="translated">形式 &lt;code&gt;NEXT&lt;/code&gt; ， &lt;code&gt;PRIOR&lt;/code&gt; ， &lt;code&gt;FIRST&lt;/code&gt; ， &lt;code&gt;LAST&lt;/code&gt; ， &lt;code&gt;ABSOLUTE&lt;/code&gt; ， &lt;code&gt;RELATIVE&lt;/code&gt; 适当地移动光标后取的单个行。如果没有这样的行，则返回空结果，并且光标将视情况放在第一行之前或最后一行之后。</target>
        </trans-unit>
        <trans-unit id="2588add0e86c17b12a1c6aa4f12342731ddacd9b" translate="yes" xml:space="preserve">
          <source>The forms using &lt;code&gt;FORWARD&lt;/code&gt; and &lt;code&gt;BACKWARD&lt;/code&gt; retrieve the indicated number of rows moving in the forward or backward direction, leaving the cursor positioned on the last-returned row (or after/before all rows, if the &lt;code&gt;count&lt;/code&gt; exceeds the number of rows available).</source>
          <target state="translated">使用 &lt;code&gt;FORWARD&lt;/code&gt; 和 &lt;code&gt;BACKWARD&lt;/code&gt; 的表单将检索指示的向前或向后移动的行数，将光标置于最后返回的行上（如果 &lt;code&gt;count&lt;/code&gt; 超过了可用行数，则位于所有行之后/之前）。</target>
        </trans-unit>
        <trans-unit id="38a28d1e90b500392094fc0f5e04fc9e1934bc5b" translate="yes" xml:space="preserve">
          <source>The forms using &lt;code&gt;{&lt;/code&gt;&lt;code&gt;...&lt;/code&gt;&lt;code&gt;}&lt;/code&gt; are known as &lt;em&gt;bounds&lt;/em&gt;. The numbers &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; within a bound are unsigned decimal integers with permissible values from 0 to 255 inclusive.</source>
          <target state="translated">使用 &lt;code&gt;{&lt;/code&gt; &lt;code&gt;...&lt;/code&gt; &lt;code&gt;}&lt;/code&gt; 的形式称为&lt;em&gt;界限&lt;/em&gt;。范围内的数字 &lt;code&gt;m&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; 是无符号十进制整数，允许的值介于0到255之间（含0和255）。</target>
        </trans-unit>
        <trans-unit id="35372a44df7778273e762917011aca61a01afe9f" translate="yes" xml:space="preserve">
          <source>The forward transition function for moving-aggregate mode is not allowed to return NULL as the new state value. If the inverse transition function returns NULL, this is taken as an indication that the inverse function cannot reverse the state calculation for this particular input, and so the aggregate calculation will be redone from scratch for the current frame starting position. This convention allows moving-aggregate mode to be used in situations where there are some infrequent cases that are impractical to reverse out of the running state value.</source>
          <target state="translated">移动聚合模式的正向过渡函数不允许返回NULL作为新的状态值。如果反转函数返回NULL,则被认为是表示反转函数不能反转这个特定输入的状态计算,因此将对当前帧起始位置从头开始重新进行聚合计算。这种约定使得移动-聚合模式可以在一些不经常发生的情况下使用,因为这些情况下,反向出运行状态值是不切实际的。</target>
        </trans-unit>
        <trans-unit id="5ac2696bdfdb7d076133fbfd9fa64682db1b8328" translate="yes" xml:space="preserve">
          <source>The four timezone names &lt;code&gt;EST5EDT&lt;/code&gt;, &lt;code&gt;CST6CDT&lt;/code&gt;, &lt;code&gt;MST7MDT&lt;/code&gt;, and &lt;code&gt;PST8PDT&lt;/code&gt; look like they are POSIX zone specifications. However, they actually are treated as named time zones because (for historical reasons) there are files by those names in the IANA time zone database. The practical implication of this is that these zone names will produce valid historical USA daylight-savings transitions, even when a plain POSIX specification would not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab5226a0f4072d37673ee94afa6e18b7e80854c8" translate="yes" xml:space="preserve">
          <source>The fourth form changes the default tablespace of the database. Only the database owner or a superuser can do this; you must also have create privilege for the new tablespace. This command physically moves any tables or indexes in the database's old default tablespace to the new tablespace. The new default tablespace must be empty for this database, and no one can be connected to the database. Tables and indexes in non-default tablespaces are unaffected.</source>
          <target state="translated">第四种形式改变数据库的默认表空间。只有数据库所有者或超级用户可以这样做;你还必须拥有新表空间的创建权限。该命令将数据库旧的默认表空间中的任何表或索引物理地移动到新的表空间。新的默认表空间对这个数据库来说必须是空的,任何人都不能连接到数据库。非默认表空间中的表和索引不受影响。</target>
        </trans-unit>
        <trans-unit id="36812cc6bb8478aaca401b63d7fbabaea11a3122" translate="yes" xml:space="preserve">
          <source>The fourth form of &lt;code&gt;CREATE TYPE&lt;/code&gt; creates a new base type (scalar type). To create a new base type, you must be a superuser. (This restriction is made because an erroneous type definition could confuse or even crash the server.)</source>
          <target state="translated">&lt;code&gt;CREATE TYPE&lt;/code&gt; 的第四种形式创建新的基本类型（标量类型）。要创建新的基本类型，您必须是超级用户。（之所以做出此限制，是因为错误的类型定义可能会使服务器混乱甚至崩溃。）</target>
        </trans-unit>
        <trans-unit id="9a5bc0cc22101b5b7b3dd6dc1462291809c736e9" translate="yes" xml:space="preserve">
          <source>The fourth variant of this command listed in the synopsis can change all of the publication properties specified in &lt;a href=&quot;sql-createpublication&quot;&gt;CREATE PUBLICATION&lt;/a&gt;. Properties not mentioned in the command retain their previous settings.</source>
          <target state="translated">概要中列出的该命令的第四个变体可以更改&lt;a href=&quot;sql-createpublication&quot;&gt;CREATE PUBLICATION中&lt;/a&gt;指定的所有发布属性。命令中未提及的属性保留其先前的设置。</target>
        </trans-unit>
        <trans-unit id="dea2017c78cbd95284b251ddbea3a7b1e10a923d" translate="yes" xml:space="preserve">
          <source>The fraction of the column's entries that are null</source>
          <target state="translated">列的条目中为空的部分。</target>
        </trans-unit>
        <trans-unit id="44d7567a007c45862dffe28ca10785cde8529aa6" translate="yes" xml:space="preserve">
          <source>The full SQL type syntax is allowed for declaring a function's arguments and return value. However, parenthesized type modifiers (e.g., the precision field for type &lt;code&gt;numeric&lt;/code&gt;) are discarded by &lt;code&gt;CREATE FUNCTION&lt;/code&gt;. Thus for example &lt;code&gt;CREATE FUNCTION foo (varchar(10)) ...&lt;/code&gt; is exactly the same as &lt;code&gt;CREATE FUNCTION foo (varchar) ...&lt;/code&gt;.</source>
          <target state="translated">允许使用完整的SQL类型语法来声明函数的参数和返回值。然而，带括号的类型调节剂（例如，用于类型的精度域 &lt;code&gt;numeric&lt;/code&gt; ）通过丢弃 &lt;code&gt;CREATE FUNCTION&lt;/code&gt; 。因此，例如 &lt;code&gt;CREATE FUNCTION foo (varchar(10)) ...&lt;/code&gt; 与 &lt;code&gt;CREATE FUNCTION foo (varchar) ...&lt;/code&gt; 完全相同。</target>
        </trans-unit>
        <trans-unit id="b36f659c83072f67d547396d3e51c25042456bdd" translate="yes" xml:space="preserve">
          <source>The full host name (with domain name) of the database server, or &lt;code&gt;[local]&lt;/code&gt; if the connection is over a Unix domain socket, or &lt;code&gt;[local:/dir/name]&lt;/code&gt;, if the Unix domain socket is not at the compiled in default location.</source>
          <target state="translated">完整的主机名（带有域名）数据库服务器，或 &lt;code&gt;[local]&lt;/code&gt; 如果连接是通过Unix域套接字，或 &lt;code&gt;[local:/dir/name]&lt;/code&gt; ，如果Unix域套接字不是在默认的编译位置。</target>
        </trans-unit>
        <trans-unit id="51d56119fb00f5592b9aaa01b9f5e760e9ad4329" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;current_setting&lt;/code&gt; produces equivalent output; see &lt;a href=&quot;functions-admin&quot;&gt;Section 9.26&lt;/a&gt;. Also, the &lt;a href=&quot;view-pg-settings&quot;&gt;&lt;code&gt;pg_settings&lt;/code&gt;&lt;/a&gt; system view produces the same information.</source>
          <target state="translated">函数 &lt;code&gt;current_setting&lt;/code&gt; 产生等效的输出；参见&lt;a href=&quot;functions-admin&quot;&gt;第9.26节&lt;/a&gt;。同样，&lt;a href=&quot;view-pg-settings&quot;&gt; &lt;code&gt;pg_settings&lt;/code&gt; &lt;/a&gt;系统视图产生相同的信息。</target>
        </trans-unit>
        <trans-unit id="5afbca91f6730238f363a7b1792e0e6d19d8f348" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;current_setting&lt;/code&gt; produces equivalent output; see &lt;a href=&quot;functions-admin&quot;&gt;Section 9.27&lt;/a&gt;. Also, the &lt;a href=&quot;view-pg-settings&quot;&gt;&lt;code&gt;pg_settings&lt;/code&gt;&lt;/a&gt; system view produces the same information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afa8c22afca8c86aa84834df3d7365a4c4ad70ab" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;current_setting&lt;/code&gt; yields the current value of the setting &lt;em&gt;&lt;code&gt;setting_name&lt;/code&gt;&lt;/em&gt;. It corresponds to the SQL command &lt;code&gt;SHOW&lt;/code&gt;. An example:</source>
          <target state="translated">函数 &lt;code&gt;current_setting&lt;/code&gt; 产生设置&lt;em&gt; &lt;code&gt;setting_name&lt;/code&gt; &lt;/em&gt;的当前值。它对应于SQL命令 &lt;code&gt;SHOW&lt;/code&gt; 。一个例子：</target>
        </trans-unit>
        <trans-unit id="f6649ace670e65e10a1490b2ecf7a4829ee526f2" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;date_trunc&lt;/code&gt; is conceptually similar to the &lt;code&gt;trunc&lt;/code&gt; function for numbers.</source>
          <target state="translated">&lt;code&gt;date_trunc&lt;/code&gt; 函数在概念上类似于数字的 &lt;code&gt;trunc&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="246b10543803d9782a161a47909e8e612b910177" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;format&lt;/code&gt; produces output formatted according to a format string, in a style similar to the C function &lt;code&gt;sprintf&lt;/code&gt;.</source>
          <target state="translated">函数 &lt;code&gt;format&lt;/code&gt; 产生的输出根据格式字符串格式化，格式类似于C函数 &lt;code&gt;sprintf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f972d6e5c3f5f9e5c41c594a5f0d51dc8e13164" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;hstore_to_json&lt;/code&gt; is used when an &lt;code&gt;hstore&lt;/code&gt; value is cast to &lt;code&gt;json&lt;/code&gt;. Likewise, &lt;code&gt;hstore_to_jsonb&lt;/code&gt; is used when an &lt;code&gt;hstore&lt;/code&gt; value is cast to &lt;code&gt;jsonb&lt;/code&gt;.</source>
          <target state="translated">当将 &lt;code&gt;hstore&lt;/code&gt; 值强制转换为 &lt;code&gt;json&lt;/code&gt; 时，将使用函数 &lt;code&gt;hstore_to_json&lt;/code&gt; 。同样，当将 &lt;code&gt;hstore&lt;/code&gt; 值 &lt;code&gt;hstore_to_jsonb&lt;/code&gt; 为jsonb时，将使用 &lt;code&gt;jsonb&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e40c0481379cfb3fb5e6423f9267d79ee88e237" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;pg_export_snapshot&lt;/code&gt; saves the current snapshot and returns a &lt;code&gt;text&lt;/code&gt; string identifying the snapshot. This string must be passed (outside the database) to clients that want to import the snapshot. The snapshot is available for import only until the end of the transaction that exported it. A transaction can export more than one snapshot, if needed. Note that doing so is only useful in &lt;code&gt;READ COMMITTED&lt;/code&gt; transactions, since in &lt;code&gt;REPEATABLE READ&lt;/code&gt; and higher isolation levels, transactions use the same snapshot throughout their lifetime. Once a transaction has exported any snapshots, it cannot be prepared with &lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt;.</source>
          <target state="translated">函数 &lt;code&gt;pg_export_snapshot&lt;/code&gt; 保存当前快照，并返回标识快照的 &lt;code&gt;text&lt;/code&gt; 字符串。此字符串必须（在数据库外部）传递给要导入快照的客户端。快照仅可用于导入，直到导出快照的事务结束为止。如果需要，一个事务可以导出多个快照。请注意，这样做仅在 &lt;code&gt;READ COMMITTED&lt;/code&gt; 事务中有用，因为在 &lt;code&gt;REPEATABLE READ&lt;/code&gt; 和更高的隔离级别中，事务在整个生命周期中都使用相同的快照。事务导出任何快照后，就无法使用&lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt;进行准备。</target>
        </trans-unit>
        <trans-unit id="9f7c2a78ba8dec8a097ba6554379141ee778a83d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;pg_notification_queue_usage&lt;/code&gt; returns the fraction of the queue that is currently occupied by pending notifications. See &lt;a href=&quot;functions-info&quot;&gt;Section 9.25&lt;/a&gt; for more information.</source>
          <target state="translated">函数 &lt;code&gt;pg_notification_queue_usage&lt;/code&gt; 返回队列中当前被挂起的通知占用的部分。有关更多信息，请参见&lt;a href=&quot;functions-info&quot;&gt;第9.25节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="47fe71d7219fa50bb753b32d84319041e350cf1a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;pg_notification_queue_usage&lt;/code&gt; returns the fraction of the queue that is currently occupied by pending notifications. See &lt;a href=&quot;functions-info&quot;&gt;Section 9.26&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="082064f30064e38cacd08cc4cf5d96bae8c8c23d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;populate_record&lt;/code&gt; is actually declared with &lt;code&gt;anyelement&lt;/code&gt;, not &lt;code&gt;record&lt;/code&gt;, as its first argument, but it will reject non-record types with a run-time error.</source>
          <target state="translated">函数 &lt;code&gt;populate_record&lt;/code&gt; 实际上是使用 &lt;code&gt;anyelement&lt;/code&gt; 而不是 &lt;code&gt;record&lt;/code&gt; 声明的，它是它的第一个参数，但是它将拒绝带有运行时错误的非记录类型。</target>
        </trans-unit>
        <trans-unit id="472db68032e87a9f5dc2308d607eed94d8936c47" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;set_config&lt;/code&gt; provides equivalent functionality; see &lt;a href=&quot;functions-admin&quot;&gt;Section 9.26&lt;/a&gt;. Also, it is possible to UPDATE the &lt;a href=&quot;view-pg-settings&quot;&gt;&lt;code&gt;pg_settings&lt;/code&gt;&lt;/a&gt; system view to perform the equivalent of &lt;code&gt;SET&lt;/code&gt;.</source>
          <target state="translated">函数 &lt;code&gt;set_config&lt;/code&gt; 提供等效的功能。参见&lt;a href=&quot;functions-admin&quot;&gt;第9.26节&lt;/a&gt;。另外，可以更新&lt;a href=&quot;view-pg-settings&quot;&gt; &lt;code&gt;pg_settings&lt;/code&gt; &lt;/a&gt;系统视图以执行与 &lt;code&gt;SET&lt;/code&gt; 等效的操作。</target>
        </trans-unit>
        <trans-unit id="1a81b9de17dd1c89cda6e145c6b31e9ece522492" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;set_config&lt;/code&gt; provides equivalent functionality; see &lt;a href=&quot;functions-admin&quot;&gt;Section 9.27&lt;/a&gt;. Also, it is possible to UPDATE the &lt;a href=&quot;view-pg-settings&quot;&gt;&lt;code&gt;pg_settings&lt;/code&gt;&lt;/a&gt; system view to perform the equivalent of &lt;code&gt;SET&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a0af8636b241010eb58f1e64ca4ece0dacf61bc" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;setweight&lt;/code&gt; can be used to label the entries of a &lt;code&gt;tsvector&lt;/code&gt; with a given &lt;em&gt;weight&lt;/em&gt;, where a weight is one of the letters &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, or &lt;code&gt;D&lt;/code&gt;. This is typically used to mark entries coming from different parts of a document, such as title versus body. Later, this information can be used for ranking of search results.</source>
          <target state="translated">&lt;code&gt;setweight&lt;/code&gt; 函数可用于标记具有给定&lt;em&gt;权重&lt;/em&gt;的 &lt;code&gt;tsvector&lt;/code&gt; 的条目，其中权重是字母 &lt;code&gt;A&lt;/code&gt; ， &lt;code&gt;B&lt;/code&gt; ， &lt;code&gt;C&lt;/code&gt; 或 &lt;code&gt;D&lt;/code&gt; 之一。这通常用于标记来自文档不同部分的条目，例如标题与正文。以后，此信息可用于搜索结果的排名。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="13cca378c8ae0fc168761a1769d0060a92e5808a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;timezone(zone, timestamp)&lt;/code&gt; is equivalent to the SQL-conforming construct &lt;code&gt;timestamp AT TIME ZONE zone&lt;/code&gt;.</source>
          <target state="translated">函数 &lt;code&gt;timezone(zone, timestamp)&lt;/code&gt; 等效于符合SQL的构造 &lt;code&gt;timestamp AT TIME ZONE zone&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c2461207b12b5b4e196270e7b51786ac6ccae21" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;ts_debug&lt;/code&gt; allows easy testing of a text search configuration.</source>
          <target state="translated">&lt;code&gt;ts_debug&lt;/code&gt; 函数可轻松测试文本搜索配置。</target>
        </trans-unit>
        <trans-unit id="99af9ae29d7989fa85e4ac3a29989c54729ceea6" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;ts_stat&lt;/code&gt; is useful for checking your configuration and for finding stop-word candidates.</source>
          <target state="translated">&lt;code&gt;ts_stat&lt;/code&gt; 函数对于检查配置和查找停用词候选很有用。</target>
        </trans-unit>
        <trans-unit id="2e394c193235d538ba957624ee9cbb6815d37e36" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;xmlagg&lt;/code&gt; is, unlike the other functions described here, an aggregate function. It concatenates the input values to the aggregate function call, much like &lt;code&gt;xmlconcat&lt;/code&gt; does, except that concatenation occurs across rows rather than across expressions in a single row. See &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.20&lt;/a&gt; for additional information about aggregate functions.</source>
          <target state="translated">与此处描述的其他函数不同，函数 &lt;code&gt;xmlagg&lt;/code&gt; 是聚合函数。它像 &lt;code&gt;xmlconcat&lt;/code&gt; 一样将输入值连接到聚合函数调用，不同之处在于，连接是在行之间而不是在单个行中的表达式之间进行的。有关聚合函数的更多信息，请参见&lt;a href=&quot;functions-aggregate&quot;&gt;第9.20节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0c233db134ccdaf6d9f67f9f0ee69ad09d27e178" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;xmlagg&lt;/code&gt; is, unlike the other functions described here, an aggregate function. It concatenates the input values to the aggregate function call, much like &lt;code&gt;xmlconcat&lt;/code&gt; does, except that concatenation occurs across rows rather than across expressions in a single row. See &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.21&lt;/a&gt; for additional information about aggregate functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f1fc89a699325691e39d0dd59e92400a699e36a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;xmlcomment&lt;/code&gt; creates an XML value containing an XML comment with the specified text as content. The text cannot contain &amp;ldquo;&lt;code&gt;--&lt;/code&gt;&amp;rdquo; or end with a &amp;ldquo;&lt;code&gt;-&lt;/code&gt;&amp;rdquo; so that the resulting construct is a valid XML comment. If the argument is null, the result is null.</source>
          <target state="translated">函数 &lt;code&gt;xmlcomment&lt;/code&gt; 创建一个XML值，其中包含带有以指定文本为内容的XML注释。文本不能包含&amp;ldquo; &lt;code&gt;--&lt;/code&gt; &amp;rdquo;或结尾有&amp;ldquo; &lt;code&gt;-&lt;/code&gt; &amp;rdquo;，这样得到的构建是一个有效的XML注释。如果参数为null，则结果为null。</target>
        </trans-unit>
        <trans-unit id="3e13677298d4e7c49ab95cddcc30183542277248" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;xmlcomment&lt;/code&gt; creates an XML value containing an XML comment with the specified text as content. The text cannot contain &amp;ldquo;&lt;code&gt;--&lt;/code&gt;&amp;rdquo; or end with a &amp;ldquo;&lt;code&gt;-&lt;/code&gt;&amp;rdquo;, otherwise the resulting construct would not be a valid XML comment. If the argument is null, the result is null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebaef272546a7798627e85265fe680ca3031d61e" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;xmlconcat&lt;/code&gt; concatenates a list of individual XML values to create a single value containing an XML content fragment. Null values are omitted; the result is only null if there are no nonnull arguments.</source>
          <target state="translated">函数 &lt;code&gt;xmlconcat&lt;/code&gt; 连接一个单独的XML值列表，以创建一个包含XML内容片段的单个值。空值被省略；仅当没有非空参数时，结果才为空。</target>
        </trans-unit>
        <trans-unit id="ef22fdb70040aafe9245779771954e498b2f3f6a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;xmlexists&lt;/code&gt; evaluates an XPath 1.0 expression (the first argument), with the passed XML value as its context item. The function returns false if the result of that evaluation yields an empty node-set, true if it yields any other value. The function returns null if any argument is null. A nonnull value passed as the context item must be an XML document, not a content fragment or any non-XML value.</source>
          <target state="translated">&lt;code&gt;xmlexists&lt;/code&gt; 函数使用传递的XML值作为其上下文项来评估XPath 1.0表达式（第一个参数）。如果该评估的结果产生一个空节点集，则该函数返回false；如果产生任何其他值，则返回true。如果任何参数为null，则该函数返回null。作为上下文项传递的非空值必须是XML文档，而不是内容片段或任何非XML值。</target>
        </trans-unit>
        <trans-unit id="837a957d18da91847b5357c6c3108da0982c435c" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;xpath&lt;/code&gt; evaluates the XPath 1.0 expression &lt;code&gt;xpath&lt;/code&gt; (a &lt;code&gt;text&lt;/code&gt; value) against the XML value &lt;code&gt;xml&lt;/code&gt;. It returns an array of XML values corresponding to the node-set produced by the XPath expression. If the XPath expression returns a scalar value rather than a node-set, a single-element array is returned.</source>
          <target state="translated">函数 &lt;code&gt;xpath&lt;/code&gt; 根据XML值 &lt;code&gt;xml&lt;/code&gt; 评估XPath 1.0表达式 &lt;code&gt;xpath&lt;/code&gt; （ &lt;code&gt;text&lt;/code&gt; 值）。它返回与XPath表达式生成的节点集相对应的XML值数组。如果XPath表达式返回标量值而不是节点集，则返回单元素数组。</target>
        </trans-unit>
        <trans-unit id="8aa320cc15b2fe4c99adf1be98b695e1536ba201" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;xpath&lt;/code&gt; evaluates the XPath 1.0 expression &lt;em&gt;&lt;code&gt;xpath&lt;/code&gt;&lt;/em&gt; (given as text) against the XML value &lt;em&gt;&lt;code&gt;xml&lt;/code&gt;&lt;/em&gt;. It returns an array of XML values corresponding to the node-set produced by the XPath expression. If the XPath expression returns a scalar value rather than a node-set, a single-element array is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49641632c456630ce0fe9561c2cd9fece93afa1f" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;xpath_exists&lt;/code&gt; is a specialized form of the &lt;code&gt;xpath&lt;/code&gt; function. Instead of returning the individual XML values that satisfy the XPath 1.0 expression, this function returns a Boolean indicating whether the query was satisfied or not (specifically, whether it produced any value other than an empty node-set). This function is equivalent to the &lt;code&gt;XMLEXISTS&lt;/code&gt; predicate, except that it also offers support for a namespace mapping argument.</source>
          <target state="translated">函数 &lt;code&gt;xpath_exists&lt;/code&gt; 是 &lt;code&gt;xpath&lt;/code&gt; 函数的一种特殊形式。该函数返回一个布尔值，该布尔值指示查询是否得到满足（具体来说，查询是否产生除空节点集以外的任何值），而不是返回满足XPath 1.0表达式的单个XML值。该函数等效于 &lt;code&gt;XMLEXISTS&lt;/code&gt; 谓词，除了它还提供了对名称空间映射参数的支持。</target>
        </trans-unit>
        <trans-unit id="5c574a36f3d0b3b9d8fd4793fb7a1aefa7712dc3" translate="yes" xml:space="preserve">
          <source>The function has no side effects. No information about the arguments is conveyed except via the return value. Any function that might throw an error depending on the values of its arguments is not leak-proof.</source>
          <target state="translated">该函数没有副作用。除了返回值之外,没有任何关于参数的信息被传递。任何可能根据参数值而产生错误的函数都不是防泄漏的。</target>
        </trans-unit>
        <trans-unit id="b27ab2a24cc42745c4233c190a0fd395e1a3a156" translate="yes" xml:space="preserve">
          <source>The function has to be used in a &lt;code&gt;FROM&lt;/code&gt; expression, with an &lt;code&gt;AS&lt;/code&gt; clause to specify the output columns; for example</source>
          <target state="translated">该函数必须在 &lt;code&gt;FROM&lt;/code&gt; 表达式中使用，并带有 &lt;code&gt;AS&lt;/code&gt; 子句以指定输出列。例如</target>
        </trans-unit>
        <trans-unit id="c9d8fff21244f2a2d5eabd0812b19e459568cfb8" translate="yes" xml:space="preserve">
          <source>The function is passed a pointer to a &lt;code&gt;local_relopts&lt;/code&gt; struct, which needs to be filled with a set of operator class specific options. The options can be accessed from other support functions using the &lt;code&gt;PG_HAS_OPCLASS_OPTIONS()&lt;/code&gt; and &lt;code&gt;PG_GET_OPCLASS_OPTIONS()&lt;/code&gt; macros.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6bc1caecad2cc53ec1c4c77402a0b8f9335155f" translate="yes" xml:space="preserve">
          <source>The function must have the following signature:</source>
          <target state="translated">该函数必须具有以下签名:</target>
        </trans-unit>
        <trans-unit id="c9d3b3a8b1ce80dcb6ec1f9fb5fa0bcff0d4df0d" translate="yes" xml:space="preserve">
          <source>The function must return &lt;code&gt;true&lt;/code&gt; if the leaf tuple matches the query, or &lt;code&gt;false&lt;/code&gt; if not. In the &lt;code&gt;true&lt;/code&gt; case, if &lt;code&gt;returnData&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; then &lt;code&gt;leafValue&lt;/code&gt; must be set to the value of &lt;code&gt;spgConfigIn&lt;/code&gt;.&lt;code&gt;attType&lt;/code&gt; type originally supplied to be indexed for this leaf tuple. Also, &lt;code&gt;recheck&lt;/code&gt; may be set to &lt;code&gt;true&lt;/code&gt; if the match is uncertain and so the operator(s) must be re-applied to the actual heap tuple to verify the match. If ordered search is performed, set &lt;code&gt;distances&lt;/code&gt; to an array of distance values according to &lt;code&gt;orderbys&lt;/code&gt; array. Leave it NULL otherwise. If at least one of returned distances is not exact, set &lt;code&gt;recheckDistances&lt;/code&gt; to true. In this case, the executor will calculate the exact distances after fetching the tuple from the heap, and will reorder the tuples if needed.</source>
          <target state="translated">如果叶子元组与查询匹配，则该函数必须返回 &lt;code&gt;true&lt;/code&gt; ,否则返回 &lt;code&gt;false&lt;/code&gt; 。在 &lt;code&gt;true&lt;/code&gt; 情况下，如果 &lt;code&gt;returnData&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; 那么 &lt;code&gt;leafValue&lt;/code&gt; 必须设置的值 &lt;code&gt;spgConfigIn&lt;/code&gt; 。最初提供给此叶子元组建立索引的 &lt;code&gt;attType&lt;/code&gt; 类型。此外，如果匹配不确定，则可以将 &lt;code&gt;recheck&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; ，因此必须将运算符重新应用于实际堆元组以验证匹配。如果执行有序搜索，请根据 &lt;code&gt;orderbys&lt;/code&gt; 将 &lt;code&gt;distances&lt;/code&gt; 设置为距离值数组数组。否则将其保留为NULL。如果返回的距离中至少有一个不正确，请将 &lt;code&gt;recheckDistances&lt;/code&gt; 设置为true。在这种情况下，执行程序将在从堆中获取元组后计算出精确的距离，并在需要时对元组进行重新排序。</target>
        </trans-unit>
        <trans-unit id="dbb965af01f35df576ea93f5375cbc5d7cb5a800" translate="yes" xml:space="preserve">
          <source>The function names can be schema-qualified if necessary. Argument types are not given, since the argument list for each type of function is predetermined. All except the headline function are required.</source>
          <target state="translated">如果需要,函数名可以用模式限定。没有给出参数类型,因为每种类型函数的参数列表是预先确定的。除了标题函数外,其他函数都是必须的。</target>
        </trans-unit>
        <trans-unit id="85e3b58b43bc6834c37e08716eb6be535f35e900" translate="yes" xml:space="preserve">
          <source>The function names can be schema-qualified if necessary. Argument types are not given, since the argument list for each type of function is predetermined. The lexize function is required, but the init function is optional.</source>
          <target state="translated">如果需要,函数名可以用模式限定。没有给出参数类型,因为每种类型函数的参数列表是预先确定的。lexize函数是必须的,但init函数是可选的。</target>
        </trans-unit>
        <trans-unit id="3e644e558fc444f59115fd62f759afc494438aeb" translate="yes" xml:space="preserve">
          <source>The function to be called</source>
          <target state="translated">要调用的函数</target>
        </trans-unit>
        <trans-unit id="10c50baf8431e61e9cb02cb427556dde06fcb6c7" translate="yes" xml:space="preserve">
          <source>The function used to implement this operator.</source>
          <target state="translated">用于实现该运算符的函数。</target>
        </trans-unit>
        <trans-unit id="0c214640ce9489d4916101b16e01715654ee3006" translate="yes" xml:space="preserve">
          <source>The function used to perform the cast. The function name can be schema-qualified. If it is not, the function will be looked up in the schema search path. The function's result data type must match the target type of the cast. Its arguments are discussed below. If no argument list is specified, the function name must be unique in its schema.</source>
          <target state="translated">用于执行投射的函数。函数名可以是schema限定的,如果不是,函数将在schema搜索路径中查找。如果不是,函数将在模式搜索路径中被查找。函数的结果数据类型必须与投递的目标类型相匹配。它的参数将在下面讨论。如果没有指定参数列表,函数名必须在其模式中是唯一的。</target>
        </trans-unit>
        <trans-unit id="4070b563f17e2132c89c11f1dad26e620d3d0a33" translate="yes" xml:space="preserve">
          <source>The function used to perform the conversion. The function name can be schema-qualified. If it is not, the function will be looked up in the path.</source>
          <target state="translated">用于执行转换的函数。函数名可以是schema限定的。如果不是,则将在路径中查找该函数。</target>
        </trans-unit>
        <trans-unit id="32829bac3c1c7822fdaafe64cfff6a892c8b38d6" translate="yes" xml:space="preserve">
          <source>The function will now execute with whatever search path is used by its caller.</source>
          <target state="translated">现在,该函数将以其调用者使用的任何搜索路径执行。</target>
        </trans-unit>
        <trans-unit id="3887f28b4d8dd432ded2ac6b6e06e93d7b6fd604" translate="yes" xml:space="preserve">
          <source>The function's Boolean result value is significant only when &lt;code&gt;checkUnique&lt;/code&gt; is &lt;code&gt;UNIQUE_CHECK_PARTIAL&lt;/code&gt;. In this case a true result means the new entry is known unique, whereas false means it might be non-unique (and a deferred uniqueness check must be scheduled). For other cases a constant false result is recommended.</source>
          <target state="translated">仅当 &lt;code&gt;checkUnique&lt;/code&gt; 为 &lt;code&gt;UNIQUE_CHECK_PARTIAL&lt;/code&gt; 时，函数的布尔结果值才有意义。在这种情况下，结果为true表示新条目是唯一的，而false则为新条目（必须安排延迟的唯一性检查）。对于其他情况，建议始终提供错误的结果。</target>
        </trans-unit>
        <trans-unit id="e1dfbee76245b05e9845e2733e79d53c030e40bb" translate="yes" xml:space="preserve">
          <source>The function-like syntax is in fact just a function call. When one of the two standard cast syntaxes is used to do a run-time conversion, it will internally invoke a registered function to perform the conversion. By convention, these conversion functions have the same name as their output type, and thus the &amp;ldquo;function-like syntax&amp;rdquo; is nothing more than a direct invocation of the underlying conversion function. Obviously, this is not something that a portable application should rely on. For further details see &lt;a href=&quot;sql-createcast&quot;&gt;CREATE CAST&lt;/a&gt;.</source>
          <target state="translated">类似函数的语法实际上只是一个函数调用。当使用两种标准强制转换语法之一进行运行时转换时，它将在内部调用注册的函数来执行转换。按照约定，这些转换函数与其输出类型具有相同的名称，因此&amp;ldquo;类似于函数的语法&amp;rdquo;无非就是直接调用基础转换函数。显然，这不是便携式应用程序应依赖的东西。有关更多详细信息，请参见&lt;a href=&quot;sql-createcast&quot;&gt;CREATE CAST&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1ff17dc219c0bcfbebd29717a230a4a214e2cbc8" translate="yes" xml:space="preserve">
          <source>The functionality provided by this module overlaps substantially with the functionality of the older &lt;a href=&quot;https://www.postgresql.org/docs/12/dblink.html&quot;&gt;dblink&lt;/a&gt; module. But &lt;code&gt;postgres_fdw&lt;/code&gt; provides more transparent and standards-compliant syntax for accessing remote tables, and can give better performance in many cases.</source>
          <target state="translated">该模块提供的功能与旧版&lt;a href=&quot;https://www.postgresql.org/docs/12/dblink.html&quot;&gt;dblink&lt;/a&gt;模块的功能基本重叠。但是 &lt;code&gt;postgres_fdw&lt;/code&gt; 提供了更透明和符合标准的语法来访问远程表，并且在许多情况下可以提供更好的性能。</target>
        </trans-unit>
        <trans-unit id="a4c5ee9bf20fe8736a119caaca754b1fea56c984" translate="yes" xml:space="preserve">
          <source>The functionality provided by this module overlaps substantially with the functionality of the older &lt;a href=&quot;https://www.postgresql.org/docs/13/dblink.html&quot;&gt;dblink&lt;/a&gt; module. But &lt;code&gt;postgres_fdw&lt;/code&gt; provides more transparent and standards-compliant syntax for accessing remote tables, and can give better performance in many cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31e36b0f324aa4e2e4f308d3f86f3d1cbe3d7e22" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;crypt()&lt;/code&gt; and &lt;code&gt;gen_salt()&lt;/code&gt; are specifically designed for hashing passwords. &lt;code&gt;crypt()&lt;/code&gt; does the hashing and &lt;code&gt;gen_salt()&lt;/code&gt; prepares algorithm parameters for it.</source>
          <target state="translated">函数 &lt;code&gt;crypt()&lt;/code&gt; 和 &lt;code&gt;gen_salt()&lt;/code&gt; 专为哈希密码而设计。 &lt;code&gt;crypt()&lt;/code&gt; 进行哈希处理， &lt;code&gt;gen_salt()&lt;/code&gt; 为它准备算法参数。</target>
        </trans-unit>
        <trans-unit id="459538ee1cd160dead602c42a37b3db46574d899" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;json[b]_populate_record&lt;/code&gt;, &lt;code&gt;json[b]_populate_recordset&lt;/code&gt;, &lt;code&gt;json[b]_to_record&lt;/code&gt; and &lt;code&gt;json[b]_to_recordset&lt;/code&gt; operate on a JSON object, or array of objects, and extract the values associated with keys whose names match column names of the output row type. Object fields that do not correspond to any output column name are ignored, and output columns that do not match any object field will be filled with nulls. To convert a JSON value to the SQL type of an output column, the following rules are applied in sequence:</source>
          <target state="translated">函数 &lt;code&gt;json[b]_populate_record&lt;/code&gt; ， &lt;code&gt;json[b]_populate_recordset&lt;/code&gt; ， &lt;code&gt;json[b]_to_record&lt;/code&gt; 和 &lt;code&gt;json[b]_to_recordset&lt;/code&gt; 对JSON对象或对象数组进行操作，并提取与其名称与对象的列名称匹配的键相关联的值。输出行类型。不对应于任何输出列名称的对象字段将被忽略，不匹配任何对象字段的输出列将被填充为空。要将JSON值转换为输出列的SQL类型，请依次应用以下规则：</target>
        </trans-unit>
        <trans-unit id="377b36f768957552b23e80bcd91c885aadb25355" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;lower_inc&lt;/code&gt; and &lt;code&gt;upper_inc&lt;/code&gt; test the inclusivity of the lower and upper bounds of a range value, respectively.</source>
          <target state="translated">函数 &lt;code&gt;lower_inc&lt;/code&gt; 和 &lt;code&gt;upper_inc&lt;/code&gt; 分别测试范围值的上下边界的包容性。</target>
        </trans-unit>
        <trans-unit id="f9b6f07f168f9bab47cb0d63914798ab55512000" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;lower_inf&lt;/code&gt; and &lt;code&gt;upper_inf&lt;/code&gt; test for infinite lower and upper bounds of a range, respectively.</source>
          <target state="translated">函数 &lt;code&gt;lower_inf&lt;/code&gt; 和 &lt;code&gt;upper_inf&lt;/code&gt; 分别测试范围的无限下限和上限。</target>
        </trans-unit>
        <trans-unit id="f703d74ff7244a4147930578a835fc919fa68d3e" translate="yes" xml:space="preserve">
          <source>The functions above that operate on tables or indexes accept a &lt;code&gt;regclass&lt;/code&gt; argument, which is simply the OID of the table or index in the &lt;code&gt;pg_class&lt;/code&gt; system catalog. You do not have to look up the OID by hand, however, since the &lt;code&gt;regclass&lt;/code&gt; data type's input converter will do the work for you. Just write the table name enclosed in single quotes so that it looks like a literal constant. For compatibility with the handling of ordinary SQL names, the string will be converted to lower case unless it contains double quotes around the table name.</source>
          <target state="translated">上面对表或索引进行操作的函数接受 &lt;code&gt;regclass&lt;/code&gt; 参数，该参数只是 &lt;code&gt;pg_class&lt;/code&gt; 系统目录中表或索引的OID 。但是，您不必手动查找OID，因为 &lt;code&gt;regclass&lt;/code&gt; 数据类型的输入转换器将为您完成工作。只需将表名写在单引号中，使它看起来像文字常量。为了与普通SQL名称的处理兼容，除非字符串在表名周围包含双引号，否则它将转换为小写。</target>
        </trans-unit>
        <trans-unit id="c0e923506f65e63b3dddbd22a7fb5e1606f3b604" translate="yes" xml:space="preserve">
          <source>The functions and function-like expressions described in this section operate on values of type &lt;code&gt;xml&lt;/code&gt;. See &lt;a href=&quot;datatype-xml&quot;&gt;Section 8.13&lt;/a&gt; for information about the &lt;code&gt;xml&lt;/code&gt; type. The function-like expressions &lt;code&gt;xmlparse&lt;/code&gt; and &lt;code&gt;xmlserialize&lt;/code&gt; for converting to and from type &lt;code&gt;xml&lt;/code&gt; are documented there, not in this section.</source>
          <target state="translated">本节中描述的函数和类似函数的表达式对 &lt;code&gt;xml&lt;/code&gt; 类型的值进行操作。有关 &lt;code&gt;xml&lt;/code&gt; 类型的信息，请参见&lt;a href=&quot;datatype-xml&quot;&gt;第8.13节&lt;/a&gt;。用于在 &lt;code&gt;xml&lt;/code&gt; 类型之间 &lt;code&gt;xmlserialize&lt;/code&gt; 转换的类似函数的表达式 &lt;code&gt;xmlparse&lt;/code&gt; 和xmlserialize不在此处记录。</target>
        </trans-unit>
        <trans-unit id="446413d467bd2bbb60b9839ce5313e8b03a2051d" translate="yes" xml:space="preserve">
          <source>The functions and operators that can be used in filter expressions are listed in &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-FILTER-EX-TABLE&quot;&gt;Table 9.49&lt;/a&gt;. Within a filter expression, the &lt;code&gt;@&lt;/code&gt; variable denotes the value being filtered (i.e., one result of the preceding path step). You can write accessor operators after &lt;code&gt;@&lt;/code&gt; to retrieve component items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ccb73aae614647b2269d26a350b909a44513b27" translate="yes" xml:space="preserve">
          <source>The functions described in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP&quot;&gt;Section 9.26.3&lt;/a&gt;, &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL&quot;&gt;Section 9.26.4&lt;/a&gt;, and &lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION&quot;&gt;Section 9.26.5&lt;/a&gt; are also relevant for replication.</source>
          <target state="translated">在所描述的功能&lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP&quot;&gt;部分9.26.3&lt;/a&gt;，&lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL&quot;&gt;第9.26.4&lt;/a&gt;和&lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION&quot;&gt;第9.26.5&lt;/a&gt;也是相关进行复制。</target>
        </trans-unit>
        <trans-unit id="b81751fa3955355b5d3a556c7a3d013468731610" translate="yes" xml:space="preserve">
          <source>The functions described in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP&quot;&gt;Section 9.27.3&lt;/a&gt;, &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL&quot;&gt;Section 9.27.4&lt;/a&gt;, and &lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION&quot;&gt;Section 9.27.5&lt;/a&gt; are also relevant for replication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e464a1af28710d4a1fd7e811bd3d0475c5576752" translate="yes" xml:space="preserve">
          <source>The functions described in this section are used to control and monitor a PostgreSQL installation.</source>
          <target state="translated">本节中描述的功能用于控制和监控PostgreSQL的安装。</target>
        </trans-unit>
        <trans-unit id="01945498ca90e6ae3cd1d1b921c28c9c72aead1f" translate="yes" xml:space="preserve">
          <source>The functions here implement the encryption part of the OpenPGP (RFC 4880) standard. Supported are both symmetric-key and public-key encryption.</source>
          <target state="translated">这里的函数实现了OpenPGP(RFC 4880)标准的加密部分。支持对称密钥和公钥加密。</target>
        </trans-unit>
        <trans-unit id="122b22a585b5cb5a2901cc7acf3393bb3b507311" translate="yes" xml:space="preserve">
          <source>The functions in &lt;a href=&quot;functions-textsearch#TEXTSEARCH-FUNCTIONS-DEBUG-TABLE&quot;&gt;Table 9.43&lt;/a&gt; are listed separately because they are not usually used in everyday text searching operations. They are helpful for development and debugging of new text search configurations.</source>
          <target state="translated">&lt;a href=&quot;functions-textsearch#TEXTSEARCH-FUNCTIONS-DEBUG-TABLE&quot;&gt;表9.43&lt;/a&gt;中的功能被单独列出，因为它们在日常文本搜索操作中通常不使用。它们有助于开发和调试新的文本搜索配置。</target>
        </trans-unit>
        <trans-unit id="c6ad12baa54d39c8fc88a5e6e9a85448981c7055" translate="yes" xml:space="preserve">
          <source>The functions in &lt;a href=&quot;functions-textsearch#TEXTSEARCH-FUNCTIONS-DEBUG-TABLE&quot;&gt;Table 9.43&lt;/a&gt; are listed separately because they are not usually used in everyday text searching operations. They are primarily helpful for development and debugging of new text search configurations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60ec00f1a0d952540e42b411ff256f01a844ba9a" translate="yes" xml:space="preserve">
          <source>The functions listed in &lt;a href=&quot;pgbench#PGBENCH-FUNCTIONS&quot;&gt;Table 259&lt;/a&gt; are built into pgbench and may be used in expressions appearing in &lt;a href=&quot;pgbench#PGBENCH-METACOMMAND-SET&quot;&gt;&lt;code&gt;\set&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pgbench#PGBENCH-FUNCTIONS&quot;&gt;表259&lt;/a&gt;中列出的函数内置在pgbench中，可以在&lt;a href=&quot;pgbench#PGBENCH-METACOMMAND-SET&quot;&gt; &lt;code&gt;\set&lt;/code&gt; &lt;/a&gt;出现的表达式中使用。</target>
        </trans-unit>
        <trans-unit id="eb877f9037b63b7fb5ec45e9dfbcbce68a00d900" translate="yes" xml:space="preserve">
          <source>The functions listed in &lt;a href=&quot;pgbench#PGBENCH-FUNCTIONS&quot;&gt;Table 275&lt;/a&gt; are built into pgbench and may be used in expressions appearing in &lt;a href=&quot;pgbench#PGBENCH-METACOMMAND-SET&quot;&gt;&lt;code&gt;\set&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d976c2e21ce82fc5ee166341bd65f2f942d7585" translate="yes" xml:space="preserve">
          <source>The functions provided by the &lt;code&gt;intarray&lt;/code&gt; module are shown in &lt;a href=&quot;intarray#INTARRAY-FUNC-TABLE&quot;&gt;Table F.9&lt;/a&gt;, the operators in &lt;a href=&quot;intarray#INTARRAY-OP-TABLE&quot;&gt;Table F.10&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;intarray&lt;/code&gt; 模块提供的功能如&lt;a href=&quot;intarray#INTARRAY-FUNC-TABLE&quot;&gt;表F.9&lt;/a&gt;所示，运算符如&lt;a href=&quot;intarray#INTARRAY-OP-TABLE&quot;&gt;表F.10所示&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="589cd253a59ec741e7593831b0243a0b8a47c194" translate="yes" xml:space="preserve">
          <source>The functions provided by the &lt;code&gt;pg_trgm&lt;/code&gt; module are shown in &lt;a href=&quot;pgtrgm#PGTRGM-FUNC-TABLE&quot;&gt;Table F.24&lt;/a&gt;, the operators in &lt;a href=&quot;pgtrgm#PGTRGM-OP-TABLE&quot;&gt;Table F.25&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_trgm&lt;/code&gt; 模块提供的功能如&lt;a href=&quot;pgtrgm#PGTRGM-FUNC-TABLE&quot;&gt;表F.24&lt;/a&gt;所示，运算符如&lt;a href=&quot;pgtrgm#PGTRGM-OP-TABLE&quot;&gt;表F.25所示&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5afb7a5be90f1ea0d87d155bbd2bc796569625a1" translate="yes" xml:space="preserve">
          <source>The functions provided to manipulate advisory locks are described in &lt;a href=&quot;functions-admin#FUNCTIONS-ADVISORY-LOCKS&quot;&gt;Section 9.26.10&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;functions-admin#FUNCTIONS-ADVISORY-LOCKS&quot;&gt;第9.26.10节&lt;/a&gt;中介绍了用于操纵咨询锁的功能。</target>
        </trans-unit>
        <trans-unit id="7cd30982d3557c91a4d774832819968f49725f2e" translate="yes" xml:space="preserve">
          <source>The functions provided to manipulate advisory locks are described in &lt;a href=&quot;functions-admin#FUNCTIONS-ADVISORY-LOCKS&quot;&gt;Section 9.27.10&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ef1c3ef042af3960555b6b81e0fa70ed4d457f" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;adminpack#FUNCTIONS-ADMINPACK-TABLE&quot;&gt;Table F.1&lt;/a&gt; provide write access to files on the machine hosting the server. (See also the functions in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-GENFILE-TABLE&quot;&gt;Table 9.94&lt;/a&gt;, which provide read-only access.) Only files within the database cluster directory can be accessed, unless the user is a superuser or given one of the pg_read_server_files, or pg_write_server_files roles, as appropriate for the function, but either a relative or absolute path is allowable.</source>
          <target state="translated">&lt;a href=&quot;adminpack#FUNCTIONS-ADMINPACK-TABLE&quot;&gt;表F.1中&lt;/a&gt;显示的功能提供对托管服务器的计算机上文件的写访问权限。 （另请&lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-GENFILE-TABLE&quot;&gt;参见表9.94&lt;/a&gt;中提供只读访问的函数。）只能访问数据库集群目录中的文件，除非用户是超级用户或具有pg_read_server_files或pg_write_server_files个角色（视情况而定） ，但相对路径或绝对路径都是允许的。</target>
        </trans-unit>
        <trans-unit id="70cd1eb89b2a38aa3978efc4d80de7d291b55bb8" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;adminpack#FUNCTIONS-ADMINPACK-TABLE&quot;&gt;Table F.1&lt;/a&gt; provide write access to files on the machine hosting the server. (See also the functions in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-GENFILE-TABLE&quot;&gt;Table 9.95&lt;/a&gt;, which provide read-only access.) Only files within the database cluster directory can be accessed, unless the user is a superuser or given one of the pg_read_server_files, or pg_write_server_files roles, as appropriate for the function, but either a relative or absolute path is allowable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af557d79922e415d01771dc33cbf93a73edbe83c" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;Table 9.84&lt;/a&gt; assist in making on-line backups. These functions cannot be executed during recovery (except non-exclusive &lt;code&gt;pg_start_backup&lt;/code&gt;, non-exclusive &lt;code&gt;pg_stop_backup&lt;/code&gt;, &lt;code&gt;pg_is_in_backup&lt;/code&gt;, &lt;code&gt;pg_backup_start_time&lt;/code&gt; and &lt;code&gt;pg_wal_lsn_diff&lt;/code&gt;).</source>
          <target state="translated">&lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;表9.84中&lt;/a&gt;显示的功能有助于进行在线备份。这些函数不能在恢复期间执行（非专有 &lt;code&gt;pg_start_backup&lt;/code&gt; ，非专有 &lt;code&gt;pg_stop_backup&lt;/code&gt; ， &lt;code&gt;pg_is_in_backup&lt;/code&gt; ， &lt;code&gt;pg_backup_start_time&lt;/code&gt; 和 &lt;code&gt;pg_wal_lsn_diff&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="fbbf6edb07e082e01233d3732d43204b4655cc4b" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;Table 9.85&lt;/a&gt; assist in making on-line backups. These functions cannot be executed during recovery (except non-exclusive &lt;code&gt;pg_start_backup&lt;/code&gt;, non-exclusive &lt;code&gt;pg_stop_backup&lt;/code&gt;, &lt;code&gt;pg_is_in_backup&lt;/code&gt;, &lt;code&gt;pg_backup_start_time&lt;/code&gt; and &lt;code&gt;pg_wal_lsn_diff&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f2948c9238f28bd4ff2bb40ce8791d0b13005bd" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBLOCATION&quot;&gt;Table 9.90&lt;/a&gt; assist in identifying the specific disk files associated with database objects.</source>
          <target state="translated">&lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBLOCATION&quot;&gt;表9.90中&lt;/a&gt;显示的功能有助于识别与数据库对象关联的特定磁盘文件。</target>
        </trans-unit>
        <trans-unit id="862902fc740913f3db230495f16a3481a70b3805" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBLOCATION&quot;&gt;Table 9.91&lt;/a&gt; assist in identifying the specific disk files associated with database objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d92b50819e3d60d5191300256c8390d3bc20d24" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBSIZE&quot;&gt;Table 9.89&lt;/a&gt; calculate the disk space usage of database objects.</source>
          <target state="translated">&lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBSIZE&quot;&gt;表9.89中&lt;/a&gt;显示的功能计算数据库对象的磁盘空间使用量。</target>
        </trans-unit>
        <trans-unit id="4a83057be3a29505df68ff81363e61d91a887e44" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-DBSIZE&quot;&gt;Table 9.90&lt;/a&gt; calculate the disk space usage of database objects, or assist in presentation of usage results. All these functions return sizes measured in bytes. If an OID that does not represent an existing object is passed to one of these functions, &lt;code&gt;NULL&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="596d61caa752f0c6f6982e0c8634c7eacfed18b6" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-GENFILE-TABLE&quot;&gt;Table 9.94&lt;/a&gt; provide native access to files on the machine hosting the server. Only files within the database cluster directory and the &lt;code&gt;log_directory&lt;/code&gt; can be accessed unless the user is granted the role &lt;code&gt;pg_read_server_files&lt;/code&gt;. Use a relative path for files in the cluster directory, and a path matching the &lt;code&gt;log_directory&lt;/code&gt; configuration setting for log files.</source>
          <target state="translated">&lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-GENFILE-TABLE&quot;&gt;表9.94中&lt;/a&gt;显示的功能提供对托管服务器的计算机上文件的本地访问。除非授予用户角色 &lt;code&gt;pg_read_server_files&lt;/code&gt; ,否则只能访问数据库集群目录和 &lt;code&gt;log_directory&lt;/code&gt; 中的文件。为群集目录中的文件使用相对路径，为日志文件使用与 &lt;code&gt;log_directory&lt;/code&gt; 配置设置匹配的路径。</target>
        </trans-unit>
        <trans-unit id="e2846b4d9144cb92c1cdd58938547d8a0b822c70" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-GENFILE-TABLE&quot;&gt;Table 9.95&lt;/a&gt; provide native access to files on the machine hosting the server. Only files within the database cluster directory and the &lt;code&gt;log_directory&lt;/code&gt; can be accessed, unless the user is a superuser or is granted the role &lt;code&gt;pg_read_server_files&lt;/code&gt;. Use a relative path for files in the cluster directory, and a path matching the &lt;code&gt;log_directory&lt;/code&gt; configuration setting for log files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c73f231d92075fb0c71fc7740bf5175d685468" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-SIGNAL-TABLE&quot;&gt;Table 9.83&lt;/a&gt; send control signals to other server processes. Use of these functions is restricted to superusers by default but access may be granted to others using &lt;code&gt;GRANT&lt;/code&gt;, with noted exceptions.</source>
          <target state="translated">&lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-SIGNAL-TABLE&quot;&gt;表9.83中&lt;/a&gt;显示的功能将控制信号发送到其他服务器进程。默认情况下，仅限超级用户使用这些功能，但可以使用 &lt;code&gt;GRANT&lt;/code&gt; 授予其他人访问权限，但有例外。</target>
        </trans-unit>
        <trans-unit id="3a4405481fecb5e6303cc2c9e6917c8fc5078234" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-SIGNAL-TABLE&quot;&gt;Table 9.84&lt;/a&gt; send control signals to other server processes. Use of these functions is restricted to superusers by default but access may be granted to others using &lt;code&gt;GRANT&lt;/code&gt;, with noted exceptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11868a349a93977f4f568672a07b5dec83a888d7" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADVISORY-LOCKS-TABLE&quot;&gt;Table 9.95&lt;/a&gt; manage advisory locks. For details about proper use of these functions, see &lt;a href=&quot;explicit-locking#ADVISORY-LOCKS&quot;&gt;Section 13.3.5&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions-admin#FUNCTIONS-ADVISORY-LOCKS-TABLE&quot;&gt;表9.95中&lt;/a&gt;显示的功能管理咨询锁。有关正确使用这些功能的详细信息，请参见&lt;a href=&quot;explicit-locking#ADVISORY-LOCKS&quot;&gt;第13.3.5节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0b59303348c39a352bb589d8b03735abeb1beeb3" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADVISORY-LOCKS-TABLE&quot;&gt;Table 9.96&lt;/a&gt; manage advisory locks. For details about proper use of these functions, see &lt;a href=&quot;explicit-locking#ADVISORY-LOCKS&quot;&gt;Section 13.3.5&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba997e6585ffd2ebf0df203e2718f49b87e3ad76" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL-TABLE&quot;&gt;Table 9.86&lt;/a&gt; control the progress of recovery. These functions may be executed only during recovery.</source>
          <target state="translated">&lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL-TABLE&quot;&gt;表9.86中&lt;/a&gt;显示的功能控制恢复进度。这些功能只能在恢复期间执行。</target>
        </trans-unit>
        <trans-unit id="127dcdaf3c316cf3d90889d6aee1511f65db73de" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL-TABLE&quot;&gt;Table 9.87&lt;/a&gt; control the progress of recovery. These functions may be executed only during recovery.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cf9851935069d5da8579d648493492e0773919e" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;Table 9.85&lt;/a&gt; provide information about the current status of the standby. These functions may be executed both during recovery and in normal running.</source>
          <target state="translated">&lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;表9.85中&lt;/a&gt;显示的功能提供有关备用服务器当前状态的信息。这些功能可以在恢复期间和正常运行中执行。</target>
        </trans-unit>
        <trans-unit id="341a6188170e97e18176dfb27299fdbe78c52ae6" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;Table 9.86&lt;/a&gt; provide information about the current status of a standby server. These functions may be executed both during recovery and in normal running.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64ba5a0a32a32de29b727183748ebc1db30a8063" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-REPLICATION-TABLE&quot;&gt;Table 9.88&lt;/a&gt; are for controlling and interacting with replication features. See &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;, &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Section 26.2.6&lt;/a&gt;, and &lt;a href=&quot;https://www.postgresql.org/docs/12/replication-origins.html&quot;&gt;Chapter 49&lt;/a&gt; for information about the underlying features. Use of functions for replication origin is restricted to superusers. Use of functions for replication slot is restricted to superusers and users having &lt;code&gt;REPLICATION&lt;/code&gt; privilege.</source>
          <target state="translated">&lt;a href=&quot;functions-admin#FUNCTIONS-REPLICATION-TABLE&quot;&gt;表9.88&lt;/a&gt;中显示的功能用于控制复制功能并与之交互。参见&lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;第26.2.5&lt;/a&gt;，&lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;第26.2.6&lt;/a&gt;和&lt;a href=&quot;https://www.postgresql.org/docs/12/replication-origins.html&quot;&gt;第49章&lt;/a&gt;的有关基本功能的信息。复制源功能的使用仅限于超级用户。复制插槽功能的使用仅限于超级用户和具有 &lt;code&gt;REPLICATION&lt;/code&gt; 特权的用户。</target>
        </trans-unit>
        <trans-unit id="0dad85ba1196a94eeff1c17a7e2716734fef21a9" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-REPLICATION-TABLE&quot;&gt;Table 9.89&lt;/a&gt; are for controlling and interacting with replication features. See &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;, &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Section 26.2.6&lt;/a&gt;, and &lt;a href=&quot;https://www.postgresql.org/docs/13/replication-origins.html&quot;&gt;Chapter 49&lt;/a&gt; for information about the underlying features. Use of functions for replication origin is restricted to superusers. Use of functions for replication slots is restricted to superusers and users having &lt;code&gt;REPLICATION&lt;/code&gt; privilege.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="423b085ba2dc236f90217ee4b570443351039e1a" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-info#FUNCTIONS-COMMIT-TIMESTAMP&quot;&gt;Table 9.76&lt;/a&gt; provide information about transactions that have been already committed. These functions mainly provide information about when the transactions were committed. They only provide useful data when &lt;a href=&quot;runtime-config-replication#GUC-TRACK-COMMIT-TIMESTAMP&quot;&gt;track_commit_timestamp&lt;/a&gt; configuration option is enabled and only for transactions that were committed after it was enabled.</source>
          <target state="translated">&lt;a href=&quot;functions-info#FUNCTIONS-COMMIT-TIMESTAMP&quot;&gt;表9.76中&lt;/a&gt;显示的功能提供了有关已提交事务的信息。这些功能主要提供有关何时提交事务的信息。仅在启用&lt;a href=&quot;runtime-config-replication#GUC-TRACK-COMMIT-TIMESTAMP&quot;&gt;track_commit_timestamp&lt;/a&gt;配置选项时，它们才提供有用的数据，并且仅针对在启用它之后提交的事务。</target>
        </trans-unit>
        <trans-unit id="d456c632c2c97e3b05a72328c838d9913de5f8d0" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-info#FUNCTIONS-COMMIT-TIMESTAMP&quot;&gt;Table 9.77&lt;/a&gt; provide information about when past transactions were committed. They only provide useful data when the &lt;a href=&quot;runtime-config-replication#GUC-TRACK-COMMIT-TIMESTAMP&quot;&gt;track_commit_timestamp&lt;/a&gt; configuration option is enabled, and only for transactions that were committed after it was enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bfe1a4de569556a1d516d3985556b63d6f6146f" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-info#FUNCTIONS-CONTROLDATA&quot;&gt;Table 9.77&lt;/a&gt; print information initialized during &lt;code&gt;initdb&lt;/code&gt;, such as the catalog version. They also show information about write-ahead logging and checkpoint processing. This information is cluster-wide, and not specific to any one database. They provide most of the same information, from the same source, as &lt;a href=&quot;app-pgcontroldata&quot;&gt;pg_controldata&lt;/a&gt;, although in a form better suited to SQL functions.</source>
          <target state="translated">&lt;a href=&quot;functions-info#FUNCTIONS-CONTROLDATA&quot;&gt;表9.77中&lt;/a&gt;显示的函数显示在 &lt;code&gt;initdb&lt;/code&gt; 期间初始化的信息，例如目录版本。它们还显示有关预写日志记录和检查点处理的信息。此信息是群集范围的，而不特定于任何一个数据库。它们以与&lt;a href=&quot;app-pgcontroldata&quot;&gt;pg_controldata&lt;/a&gt;相同的来源提供了大多数相同的信息，尽管它们的形式更适合SQL函数。</target>
        </trans-unit>
        <trans-unit id="f4644a53e9bb9e3b709daab47cfd9c549aaf8f50" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-info#FUNCTIONS-CONTROLDATA&quot;&gt;Table 9.78&lt;/a&gt; print information initialized during &lt;code&gt;initdb&lt;/code&gt;, such as the catalog version. They also show information about write-ahead logging and checkpoint processing. This information is cluster-wide, not specific to any one database. These functions provide most of the same information, from the same source, as the &lt;a href=&quot;app-pgcontroldata&quot;&gt;pg_controldata&lt;/a&gt; application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46311f3452a56adeb669710af158b1d331e3ba4e" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-info#FUNCTIONS-INFO-COMMENT-TABLE&quot;&gt;Table 9.73&lt;/a&gt; extract comments previously stored with the &lt;a href=&quot;sql-comment&quot;&gt;COMMENT&lt;/a&gt; command. A null value is returned if no comment could be found for the specified parameters.</source>
          <target state="translated">&lt;a href=&quot;functions-info#FUNCTIONS-INFO-COMMENT-TABLE&quot;&gt;表9.73中&lt;/a&gt;显示的功能提取先前使用&lt;a href=&quot;sql-comment&quot;&gt;COMMENT&lt;/a&gt;命令存储的注释。如果找不到指定参数的注释，则返回空值。</target>
        </trans-unit>
        <trans-unit id="d1b030aa28d10d3a864b72b4ee87a9054320e5c9" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-info#FUNCTIONS-PG-SNAPSHOT&quot;&gt;Table 9.74&lt;/a&gt; provide server transaction information in an exportable form. The main use of these functions is to determine which transactions were committed between two snapshots.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f306d4b7a9229188bb697a19658366a35ce8588" translate="yes" xml:space="preserve">
          <source>The functions shown in &lt;a href=&quot;functions-info#FUNCTIONS-TXID-SNAPSHOT&quot;&gt;Table 9.74&lt;/a&gt; provide server transaction information in an exportable form. The main use of these functions is to determine which transactions were committed between two snapshots.</source>
          <target state="translated">&lt;a href=&quot;functions-info#FUNCTIONS-TXID-SNAPSHOT&quot;&gt;表9.74中&lt;/a&gt;显示的功能以可导出的形式提供服务器事务信息。这些功能的主要用途是确定在两个快照之间提交了哪些事务。</target>
        </trans-unit>
        <trans-unit id="9398f596a0390810b3e41d607c70ae410202516a" translate="yes" xml:space="preserve">
          <source>The functions verify various &lt;em&gt;invariants&lt;/em&gt; in the structure of the representation of particular relations. The correctness of the access method functions behind index scans and other important operations relies on these invariants always holding. For example, certain functions verify, among other things, that all B-Tree pages have items in &amp;ldquo;logical&amp;rdquo; order (e.g., for B-Tree indexes on &lt;code&gt;text&lt;/code&gt;, index tuples should be in collated lexical order). If that particular invariant somehow fails to hold, we can expect binary searches on the affected page to incorrectly guide index scans, resulting in wrong answers to SQL queries.</source>
          <target state="translated">这些函数验证特定关系表示的结构中的各种&lt;em&gt;不变量&lt;/em&gt;。索引扫描和其他重要操作背后的访问方法功能的正确性始终取决于这些不变式。例如，某些功能除其他外，验证所有B-Tree页面具有&amp;ldquo;逻辑&amp;rdquo;顺序的项目（例如，对于 &lt;code&gt;text&lt;/code&gt; 上的B-Tree索引，索引元组应按整理的词法顺序）。如果该特定不变式无法保持某种状态，则可以预期在受影响的页面上进行二进制搜索会错误地引导索引扫描，从而导致对SQL查询的错误答案。</target>
        </trans-unit>
        <trans-unit id="0d68a3d97b1b4428fbfcb9d0333819c6fcb3c2b0" translate="yes" xml:space="preserve">
          <source>The fundamental type of an XQuery/XPath expression, the &lt;code&gt;sequence&lt;/code&gt;, which can contain XML nodes, atomic values, or both, does not exist in XPath 1.0. A 1.0 expression can only produce a node-set (containing zero or more XML nodes), or a single atomic value.</source>
          <target state="translated">XQuery / XPath表达式的基本类型， &lt;code&gt;sequence&lt;/code&gt; （可以包含XML节点和/或原子值）在XPath 1.0中不存在。1.0表达式只能产生一个节点集（包含零个或多个XML节点）或单个原子值。</target>
        </trans-unit>
        <trans-unit id="01481c12012dd36b33a9e59e6d02e28615f69f45" translate="yes" xml:space="preserve">
          <source>The general form of a recursive &lt;code&gt;WITH&lt;/code&gt; query is always a &lt;em&gt;non-recursive term&lt;/em&gt;, then &lt;code&gt;UNION&lt;/code&gt; (or &lt;code&gt;UNION ALL&lt;/code&gt;), then a &lt;em&gt;recursive term&lt;/em&gt;, where only the recursive term can contain a reference to the query's own output. Such a query is executed as follows:</source>
          <target state="translated">递归 &lt;code&gt;WITH&lt;/code&gt; 查询的一般形式始终&lt;em&gt;是非递归项&lt;/em&gt;，然后是 &lt;code&gt;UNION&lt;/code&gt; （或 &lt;code&gt;UNION ALL&lt;/code&gt; ），然后是&lt;em&gt;递归项&lt;/em&gt;，其中只有递归项可以包含对查询自身输出的引用。这样的查询执行如下：</target>
        </trans-unit>
        <trans-unit id="8eee7d4e38c500df724907fbea7403f66500c981" translate="yes" xml:space="preserve">
          <source>The general format of the &lt;code&gt;pg_hba.conf&lt;/code&gt; file is a set of records, one per line. Blank lines are ignored, as is any text after the &lt;code&gt;#&lt;/code&gt; comment character. Records cannot be continued across lines. A record is made up of a number of fields which are separated by spaces and/or tabs. Fields can contain white space if the field value is double-quoted. Quoting one of the keywords in a database, user, or address field (e.g., &lt;code&gt;all&lt;/code&gt; or &lt;code&gt;replication&lt;/code&gt;) makes the word lose its special meaning, and just match a database, user, or host with that name.</source>
          <target state="translated">&lt;code&gt;pg_hba.conf&lt;/code&gt; 文件的一般格式是一组记录，每行一条。空行以及 &lt;code&gt;#&lt;/code&gt; 注释字符后的任何文本都将被忽略。记录不能跨行继续。记录由许多由空格和/或制表符分隔的字段组成。如果字段值用双引号引起来，则字段可以包含空格。引用数据库，用户或地址字段中的关键字之一（例如 &lt;code&gt;all&lt;/code&gt; 或 &lt;code&gt;replication&lt;/code&gt; ）会使单词失去其特殊含义，并且仅将数据库，用户或主机与该名称匹配。</target>
        </trans-unit>
        <trans-unit id="2ed177efb04faf95279eeefdbca2d0ce9a32d2a9" translate="yes" xml:space="preserve">
          <source>The general principle is that the contained object must match the containing object as to structure and data contents, possibly after discarding some non-matching array elements or object key/value pairs from the containing object. But remember that the order of array elements is not significant when doing a containment match, and duplicate array elements are effectively considered only once.</source>
          <target state="translated">一般的原则是,包含对象必须在结构和数据内容上与包含对象相匹配,可能会从包含对象中抛弃一些不匹配的数组元素或对象键/值对。但请记住,在进行包含匹配时,数组元素的顺序并不重要,重复的数组元素实际上只考虑一次。</target>
        </trans-unit>
        <trans-unit id="ab5e9d694a644360b18b209b2a60b5fe2f2901b9" translate="yes" xml:space="preserve">
          <source>The general rule for configuring a list of dictionaries is to place first the most narrow, most specific dictionary, then the more general dictionaries, finishing with a very general dictionary, like a Snowball stemmer or &lt;code&gt;simple&lt;/code&gt;, which recognizes everything. For example, for an astronomy-specific search (&lt;code&gt;astro_en&lt;/code&gt; configuration) one could bind token type &lt;code&gt;asciiword&lt;/code&gt; (ASCII word) to a synonym dictionary of astronomical terms, a general English dictionary and a Snowball English stemmer:</source>
          <target state="translated">配置字典列表的一般规则是，首先放置最狭窄，最具体的字典，然后放置更一般的字典，最后放置一个非常普通的字典，例如Snowball stemmer或 &lt;code&gt;simple&lt;/code&gt; ，它可以识别所有内容。例如，对于天文学特定的搜索（ &lt;code&gt;astro_en&lt;/code&gt; 配置），可以将令牌类型的 &lt;code&gt;asciiword&lt;/code&gt; （ASCII词）绑定到天文学术语的同义词词典，通用英语词典和Snowball English stemmer：</target>
        </trans-unit>
        <trans-unit id="5f82a175fcf092449c33c188da71a078b0c24826" translate="yes" xml:space="preserve">
          <source>The generated array type's name is the scalar type's name with an underscore prepended. The array entry's other fields are filled from &lt;code&gt;BKI_ARRAY_DEFAULT(value)&lt;/code&gt; annotations in &lt;code&gt;pg_type.h&lt;/code&gt;, or if there isn't one, copied from the scalar type. (There's also a special case for &lt;code&gt;typalign&lt;/code&gt;.) Then the &lt;code&gt;typelem&lt;/code&gt; and &lt;code&gt;typarray&lt;/code&gt; fields of the two entries are set to cross-reference each other.</source>
          <target state="translated">生成的数组类型的名称是标量类型的名称，并带有下划线。数组条目的其他字段由 &lt;code&gt;BKI_ARRAY_DEFAULT(value)&lt;/code&gt; 批注 &lt;code&gt;pg_type.h&lt;/code&gt; ，或者如果没有，则从标量类型复制。 （对于 &lt;code&gt;typalign&lt;/code&gt; 也有一种特殊情况。）然后，将两个条目的 &lt;code&gt;typelem&lt;/code&gt; 和 &lt;code&gt;typarray&lt;/code&gt; 字段设置为相互交叉引用。</target>
        </trans-unit>
        <trans-unit id="3eb30312d4c2f46733a2c8327c7814b6e7e52a77" translate="yes" xml:space="preserve">
          <source>The generated queries are executed in the order in which the rows are returned, and left-to-right within each row if there is more than one column. NULL fields are ignored. The generated queries are sent literally to the server for processing, so they cannot be psql meta-commands nor contain psql variable references. If any individual query fails, execution of the remaining queries continues unless &lt;code&gt;ON_ERROR_STOP&lt;/code&gt; is set. Execution of each query is subject to &lt;code&gt;ECHO&lt;/code&gt; processing. (Setting &lt;code&gt;ECHO&lt;/code&gt; to &lt;code&gt;all&lt;/code&gt; or &lt;code&gt;queries&lt;/code&gt; is often advisable when using &lt;code&gt;\gexec&lt;/code&gt;.) Query logging, single-step mode, timing, and other query execution features apply to each generated query as well.</source>
          <target state="translated">生成的查询将按返回行的顺序执行，如果有多个列，则在每一行中从左到右执行。空字段将被忽略。生成的查询从字面上发送到服务器进行处理，因此它们既不能是psql元命令，也不能包含psql变量引用。如果任何单个查询失败，除非设置了 &lt;code&gt;ON_ERROR_STOP&lt;/code&gt; ,否则其余查询将继续执行。每个查询的执行均受 &lt;code&gt;ECHO&lt;/code&gt; 处理。 （使用 &lt;code&gt;\gexec&lt;/code&gt; 时，通常建议将 &lt;code&gt;ECHO&lt;/code&gt; 设置为 &lt;code&gt;all&lt;/code&gt; 或 &lt;code&gt;queries&lt;/code&gt; 。）查询日志记录，单步模式，计时和其他查询执行功能也适用于每个生成的查询。</target>
        </trans-unit>
        <trans-unit id="b9932b57cc46c7c3eb3f68c8f986add5fa46c3a0" translate="yes" xml:space="preserve">
          <source>The generation expression can only use immutable functions and cannot use subqueries or reference anything other than the current row in any way.</source>
          <target state="translated">生成表达式只能使用不可变的函数,不能使用子查询,也不能以任何方式引用当前行以外的其他内容。</target>
        </trans-unit>
        <trans-unit id="491279f444aecfec04612928c73be9653a1967ca" translate="yes" xml:space="preserve">
          <source>The generation expression can refer to other columns in the table, but not other generated columns. Any functions and operators used must be immutable. References to other tables are not allowed.</source>
          <target state="translated">生成表达式可以引用表中的其他列,但不能引用其他生成的列。使用的任何函数和运算符必须是不可变的。不允许引用其他表。</target>
        </trans-unit>
        <trans-unit id="107e72819959dbe843c78d42ff3ca5cede1b2e0f" translate="yes" xml:space="preserve">
          <source>The generic WAL redo function will acquire exclusive locks to buffers in the same order as they were registered. After redoing all changes, the locks will be released in the same order.</source>
          <target state="translated">通用的WAL重做功能将以与注册时相同的顺序获得缓冲区的独占锁。在重做所有更改后,锁将以相同的顺序释放。</target>
        </trans-unit>
        <trans-unit id="0ec880a1f4bc52e38225ff4766fdd3a9f49cf436" translate="yes" xml:space="preserve">
          <source>The generic term for all objects in a &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; that have a name and a list of &lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;attributes&lt;/a&gt; defined in a specific order. &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;Tables&lt;/a&gt;, &lt;a href=&quot;glossary#GLOSSARY-SEQUENCE&quot;&gt;sequences&lt;/a&gt;, &lt;a href=&quot;glossary#GLOSSARY-VIEW&quot;&gt;views&lt;/a&gt;, &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-TABLE&quot;&gt;foreign tables&lt;/a&gt;, &lt;a href=&quot;glossary#GLOSSARY-MATERIALIZED-VIEW&quot;&gt;materialized views&lt;/a&gt;, composite types, and &lt;a href=&quot;glossary#GLOSSARY-INDEX&quot;&gt;indexes&lt;/a&gt; are all relations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82aaa212b0dcfe65dc390eb2bddcbdc50aeac8ad" translate="yes" xml:space="preserve">
          <source>The genetic algorithm (GA) is a heuristic optimization method which operates through randomized search. The set of possible solutions for the optimization problem is considered as a &lt;em&gt;population&lt;/em&gt; of &lt;em&gt;individuals&lt;/em&gt;. The degree of adaptation of an individual to its environment is specified by its &lt;em&gt;fitness&lt;/em&gt;.</source>
          <target state="translated">遗传算法（GA）是一种启发式优化方法，通过随机搜索进行操作。该组的优化问题可能的解决方案被认为是一个&lt;em&gt;群体&lt;/em&gt;的&lt;em&gt;个体&lt;/em&gt;。一个人适应环境的程度由其&lt;em&gt;适应度决定&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="7ee74388f5d56affe1f244671fe03aad5cc5e12c" translate="yes" xml:space="preserve">
          <source>The genetic query optimizer (GEQO) is an algorithm that does query planning using heuristic searching. This reduces planning time for complex queries (those joining many relations), at the cost of producing plans that are sometimes inferior to those found by the normal exhaustive-search algorithm. For more information see &lt;a href=&quot;https://www.postgresql.org/docs/12/geqo.html&quot;&gt;Chapter 59&lt;/a&gt;.</source>
          <target state="translated">遗传查询优化器（GEQO）是一种使用启发式搜索进行查询计划的算法。这样可以减少复杂查询（那些包含许多关系的查询）的计划时间，但所产生的计划有时会比通常的穷举搜索算法所发现的计划差。有关更多信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/geqo.html&quot;&gt;第59章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="76e81ac1072d86242c4bc156a134a00ceecb9182" translate="yes" xml:space="preserve">
          <source>The genetic query optimizer (GEQO) is an algorithm that does query planning using heuristic searching. This reduces planning time for complex queries (those joining many relations), at the cost of producing plans that are sometimes inferior to those found by the normal exhaustive-search algorithm. For more information see &lt;a href=&quot;https://www.postgresql.org/docs/13/geqo.html&quot;&gt;Chapter 59&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be4cf5614687e283544003825f41ef8216ea5370" translate="yes" xml:space="preserve">
          <source>The geometric types &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;lseg&lt;/code&gt;, &lt;code&gt;line&lt;/code&gt;, &lt;code&gt;path&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, and &lt;code&gt;circle&lt;/code&gt; have a large set of native support functions and operators, shown in &lt;a href=&quot;functions-geometry#FUNCTIONS-GEOMETRY-OP-TABLE&quot;&gt;Table 9.34&lt;/a&gt;, &lt;a href=&quot;functions-geometry#FUNCTIONS-GEOMETRY-FUNC-TABLE&quot;&gt;Table 9.35&lt;/a&gt;, and &lt;a href=&quot;functions-geometry#FUNCTIONS-GEOMETRY-CONV-TABLE&quot;&gt;Table 9.36&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;point&lt;/code&gt; ， &lt;code&gt;box&lt;/code&gt; ， &lt;code&gt;lseg&lt;/code&gt; ， &lt;code&gt;line&lt;/code&gt; ， &lt;code&gt;path&lt;/code&gt; ， &lt;code&gt;polygon&lt;/code&gt; 和 &lt;code&gt;circle&lt;/code&gt; 的几何类型具有大量的本机支持函数和运算符，如&lt;a href=&quot;functions-geometry#FUNCTIONS-GEOMETRY-OP-TABLE&quot;&gt;表9.34&lt;/a&gt;，&lt;a href=&quot;functions-geometry#FUNCTIONS-GEOMETRY-FUNC-TABLE&quot;&gt;表9.35&lt;/a&gt;和&lt;a href=&quot;functions-geometry#FUNCTIONS-GEOMETRY-CONV-TABLE&quot;&gt;表9.36所示&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="347bd2183f41ac71a7c964a957ff88f0b7d2f9db" translate="yes" xml:space="preserve">
          <source>The geometric types &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;lseg&lt;/code&gt;, &lt;code&gt;line&lt;/code&gt;, &lt;code&gt;path&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, and &lt;code&gt;circle&lt;/code&gt; have a large set of native support functions and operators, shown in &lt;a href=&quot;functions-geometry#FUNCTIONS-GEOMETRY-OP-TABLE&quot;&gt;Table 9.35&lt;/a&gt;, &lt;a href=&quot;functions-geometry#FUNCTIONS-GEOMETRY-FUNC-TABLE&quot;&gt;Table 9.36&lt;/a&gt;, and &lt;a href=&quot;functions-geometry#FUNCTIONS-GEOMETRY-CONV-TABLE&quot;&gt;Table 9.37&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66e8935cc591dee18b7ed24a47a78f49e5afb1a3" translate="yes" xml:space="preserve">
          <source>The geometry of measurements is usually more complex than that of a point in a numeric continuum. A measurement is usually a segment of that continuum with somewhat fuzzy limits. The measurements come out as intervals because of uncertainty and randomness, as well as because the value being measured may naturally be an interval indicating some condition, such as the temperature range of stability of a protein.</source>
          <target state="translated">测量的几何形状通常比数值连续体中的一个点复杂。测量通常是该连续体的一段,其界限有些模糊。由于不确定性和随机性,以及由于被测量的值可能自然是一个表示某种条件的区间,如蛋白质稳定性的温度范围,测量结果以区间的形式出现。</target>
        </trans-unit>
        <trans-unit id="443b3b682ab171a2c355d696fdc2acc186cfef4d" translate="yes" xml:space="preserve">
          <source>The given password is hashed using a String2Key (S2K) algorithm. This is rather similar to &lt;code&gt;crypt()&lt;/code&gt; algorithms &amp;mdash; purposefully slow and with random salt &amp;mdash; but it produces a full-length binary key.</source>
          <target state="translated">使用String2Key（S2K）算法对给定的密码进行哈希处理。这与 &lt;code&gt;crypt()&lt;/code&gt; 算法非常相似-故意降低速度并随机添加盐分-但它会生成全长的二进制密钥。</target>
        </trans-unit>
        <trans-unit id="0e4e030b166d032a885deba1d77181dbb66b8bc9" translate="yes" xml:space="preserve">
          <source>The grouping operations shown in &lt;a href=&quot;functions-aggregate#FUNCTIONS-GROUPING-TABLE&quot;&gt;Table 9.59&lt;/a&gt; are used in conjunction with grouping sets (see &lt;a href=&quot;queries-table-expressions#QUERIES-GROUPING-SETS&quot;&gt;Section 7.2.4&lt;/a&gt;) to distinguish result rows. The arguments to the &lt;code&gt;GROUPING&lt;/code&gt; function are not actually evaluated, but they must exactly match expressions given in the &lt;code&gt;GROUP BY&lt;/code&gt; clause of the associated query level. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0b9a6b33b61484344b41d8768ea944df1857641" translate="yes" xml:space="preserve">
          <source>The header extension area is envisioned to contain a sequence of self-identifying chunks. The flags field is not intended to tell readers what is in the extension area. Specific design of header extension contents is left for a later release.</source>
          <target state="translated">页眉扩展区被设想为包含一连串自我识别的块。标志字段不是为了告诉读者扩展区的内容。头扩展内容的具体设计留待以后发布。</target>
        </trans-unit>
        <trans-unit id="6e01e0ce077bd1d9c99c3825e5edad48a491fa26" translate="yes" xml:space="preserve">
          <source>The horizontal header, displayed as the first row, contains the values found in column &lt;code&gt;colH&lt;/code&gt;, with duplicates removed. By default, these appear in the same order as in the query results. But if the optional &lt;code&gt;sortcolH&lt;/code&gt; argument is given, it identifies a column whose values must be integer numbers, and the values from &lt;code&gt;colH&lt;/code&gt; will appear in the horizontal header sorted according to the corresponding &lt;code&gt;sortcolH&lt;/code&gt; values.</source>
          <target state="translated">显示为第一行的水平标题包含在 &lt;code&gt;colH&lt;/code&gt; 列中找到的值，并删除了重复项。默认情况下，它们的显示顺序与查询结果中的顺序相同。但是，如果给出了可选的 &lt;code&gt;sortcolH&lt;/code&gt; 参数，它将标识一列，其值必须是整数，并且来自 &lt;code&gt;colH&lt;/code&gt; 的值将出现在根据相应的 &lt;code&gt;sortcolH&lt;/code&gt; 值排序的水平标题中。</target>
        </trans-unit>
        <trans-unit id="323272ce1c2fce6128855defbc54368c470d5d34" translate="yes" xml:space="preserve">
          <source>The host name and port number of the primary, connection user name, and password are specified in the &lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-CONNINFO&quot;&gt;primary_conninfo&lt;/a&gt;. The password can also be set in the &lt;code&gt;~/.pgpass&lt;/code&gt; file on the standby (specify &lt;code&gt;replication&lt;/code&gt; in the &lt;code&gt;database&lt;/code&gt; field). For example, if the primary is running on host IP &lt;code&gt;192.168.1.50&lt;/code&gt;, port &lt;code&gt;5432&lt;/code&gt;, the account name for replication is &lt;code&gt;foo&lt;/code&gt;, and the password is &lt;code&gt;foopass&lt;/code&gt;, the administrator can add the following line to the &lt;code&gt;postgresql.conf&lt;/code&gt; file on the standby:</source>
          <target state="translated">主服务器的主机名和端口号，连接用户名和密码在&lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-CONNINFO&quot;&gt;primary_conninfo&lt;/a&gt;中指定。也可以在备用 &lt;code&gt;database&lt;/code&gt; 的 &lt;code&gt;~/.pgpass&lt;/code&gt; 文件中设置密码（在数据库字段中指定 &lt;code&gt;replication&lt;/code&gt; ）。例如，如果主服务器在主机IP &lt;code&gt;192.168.1.50&lt;/code&gt; 的端口 &lt;code&gt;5432&lt;/code&gt; 上运行，复制的帐户名是 &lt;code&gt;foo&lt;/code&gt; ，密码是 &lt;code&gt;foopass&lt;/code&gt; ，则管理员可以将以下行添加到备用服务器上的 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件中：</target>
        </trans-unit>
        <trans-unit id="41cfca1d0872f04d37ad8cb9cbf3834cb90f01db" translate="yes" xml:space="preserve">
          <source>The host name of the database server, truncated at the first dot, or &lt;code&gt;[local]&lt;/code&gt; if the connection is over a Unix domain socket.</source>
          <target state="translated">数据库服务器的主机名，在第一个点处被截断，如果连接是通过Unix域套接字的，则为 &lt;code&gt;[local]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0b7649f0038242a26a0c621f7315d0b3f51c7304" translate="yes" xml:space="preserve">
          <source>The hour component of the time zone offset</source>
          <target state="translated">时区偏移的小时分量</target>
        </trans-unit>
        <trans-unit id="6ced8e552c81e4a5ec5eb0ba5039b71c87a5c484" translate="yes" xml:space="preserve">
          <source>The hour field (0 - 23)</source>
          <target state="translated">小时领域(0-23)</target>
        </trans-unit>
        <trans-unit id="c96645608711f945ba53324fe90b2674f60c24de" translate="yes" xml:space="preserve">
          <source>The hour field (0&amp;ndash;23)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="842cd42d6043fc7261db6ee13e01b6e92f6c88ea" translate="yes" xml:space="preserve">
          <source>The i7-860 system measured runs the count query in 9.8 ms while the &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; version takes 16.6 ms, each processing just over 100,000 rows. That 6.8 ms difference means the timing overhead per row is 68 ns, about twice what pg_test_timing estimated it would be. Even that relatively small amount of overhead is making the fully timed count statement take almost 70% longer. On more substantial queries, the timing overhead would be less problematic.</source>
          <target state="translated">测得的i7-860系统在9.8毫秒内运行计数查询，而 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 版本需要16.6毫秒，每个处理刚好超过100,000行。6.8 ms的差异意味着每行的定时开销为68 ns，大约是pg_test_timing估计的两倍。即使是相对较少的开销，全定时计数语句也将花费将近70％的时间。在更多实质性查询中，计时开销将不会有太大问题。</target>
        </trans-unit>
        <trans-unit id="fbf85920bba7cb75c10687cf6cd36aab7a7c9b2a" translate="yes" xml:space="preserve">
          <source>The idea behind this dump method is to generate a file with SQL commands that, when fed back to the server, will recreate the database in the same state as it was at the time of the dump. PostgreSQL provides the utility program &lt;a href=&quot;app-pgdump&quot;&gt;pg_dump&lt;/a&gt; for this purpose. The basic usage of this command is:</source>
          <target state="translated">这种转储方法的思想是使用SQL命令生成一个文件，当该文件被反馈到服务器时，它将以与转储时相同的状态重新创建数据库。PostgreSQL 为此提供了实用程序&lt;a href=&quot;app-pgdump&quot;&gt;pg_dump&lt;/a&gt;。该命令的基本用法是：</target>
        </trans-unit>
        <trans-unit id="6cf4bd1d2fa41d408b71387e9f46d7734f70e2c4" translate="yes" xml:space="preserve">
          <source>The ident authentication method works by obtaining the client's operating system user name from an ident server and using it as the allowed database user name (with an optional user name mapping). This is only supported on TCP/IP connections.</source>
          <target state="translated">ident认证方法的工作原理是从ident服务器上获取客户端的操作系统用户名,并将其作为允许的数据库用户名(可选择用户名映射)。这只在TCP/IP连接上支持。</target>
        </trans-unit>
        <trans-unit id="75cef3c7a191b437000bac7046319a3652002a6f" translate="yes" xml:space="preserve">
          <source>The identifier of the prepared statement</source>
          <target state="translated">编制的报表的标识符</target>
        </trans-unit>
        <trans-unit id="5814fec88046aa889ddca71e977eccd80834a133" translate="yes" xml:space="preserve">
          <source>The identity (transaction ID) of the deleting transaction, or zero for an undeleted row version. It is possible for this column to be nonzero in a visible row version. That usually indicates that the deleting transaction hasn't committed yet, or that an attempted deletion was rolled back.</source>
          <target state="translated">删除事务的标识(事务ID),对于未删除的行版本,标识为零。在可见的行版本中,此列有可能是非零。这通常表示删除的事务还没有提交,或者尝试的删除被回滚。</target>
        </trans-unit>
        <trans-unit id="7c52aeea0184eb0092fc19e054b01bbe20a261fc" translate="yes" xml:space="preserve">
          <source>The identity (transaction ID) of the inserting transaction for this row version. (A row version is an individual state of a row; each update of a row creates a new row version for the same logical row.)</source>
          <target state="translated">该行版本的插入事务的标识(事务ID)。一个行版本是一个行的单独状态,每更新一个行都会为同一逻辑行创建一个新的行版本)。</target>
        </trans-unit>
        <trans-unit id="61965181bc017854598b0845bd8393cd487f7cfb" translate="yes" xml:space="preserve">
          <source>The implementation does not resist &lt;a href=&quot;https://en.wikipedia.org/wiki/Side-channel_attack&quot;&gt;side-channel attacks&lt;/a&gt;. For example, the time required for a &lt;code&gt;pgcrypto&lt;/code&gt; decryption function to complete varies among ciphertexts of a given size.</source>
          <target state="translated">该实现不能抵抗&lt;a href=&quot;https://en.wikipedia.org/wiki/Side-channel_attack&quot;&gt;边信道攻击&lt;/a&gt;。例如， &lt;code&gt;pgcrypto&lt;/code&gt; 解密功能完成所需的时间在给定大小的密文中会有所不同。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
