<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="e1a2d424d05fad0ce8a503aad44ed8e2890ec86d" translate="yes" xml:space="preserve">
          <source>One row for each table in the current database, showing statistics about accesses to that specific table. See &lt;a href=&quot;monitoring-stats#PG-STAT-ALL-TABLES-VIEW&quot;&gt;pg_stat_all_tables&lt;/a&gt; for details.</source>
          <target state="translated">当前数据库中每个表的一行，显示有关对该特定表的访问的统计信息。有关详细信息，请参见&lt;a href=&quot;monitoring-stats#PG-STAT-ALL-TABLES-VIEW&quot;&gt;pg_stat_all_tables&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="abc0444614ec30e98f25afeab84f356db8f57c5c" translate="yes" xml:space="preserve">
          <source>One row for each tracked function, showing statistics about executions of that function. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-USER-FUNCTIONS-VIEW&quot;&gt;&lt;code&gt;pg_stat_user_functions&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">每个跟踪功能的一行，显示有关该功能执行的统计信息。有关详细信息，请参见&lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-USER-FUNCTIONS-VIEW&quot;&gt; &lt;code&gt;pg_stat_user_functions&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5e4f1c454b46b07db5b5caff74a33b9a88d14f14" translate="yes" xml:space="preserve">
          <source>One row for each tracked function, showing statistics about executions of that function. See &lt;a href=&quot;monitoring-stats#PG-STAT-USER-FUNCTIONS-VIEW&quot;&gt;pg_stat_user_functions&lt;/a&gt; for details.</source>
          <target state="translated">每个跟踪功能的一行，显示有关该功能执行的统计信息。有关详细信息，请参见&lt;a href=&quot;monitoring-stats#PG-STAT-USER-FUNCTIONS-VIEW&quot;&gt;pg_stat_user_functions&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b9f68f712788d8659f6dc744778895e8637cccb9" translate="yes" xml:space="preserve">
          <source>One row only, showing statistics about the WAL archiver process's activity. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-ARCHIVER-VIEW&quot;&gt;&lt;code&gt;pg_stat_archiver&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">仅一行，显示有关WAL归档程序过程活动的统计信息。有关详细信息，请参见&lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-ARCHIVER-VIEW&quot;&gt; &lt;code&gt;pg_stat_archiver&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2a27e9764cf42abc447770a40b26ae4110256df1" translate="yes" xml:space="preserve">
          <source>One row only, showing statistics about the WAL archiver process's activity. See &lt;a href=&quot;monitoring-stats#PG-STAT-ARCHIVER-VIEW&quot;&gt;pg_stat_archiver&lt;/a&gt; for details.</source>
          <target state="translated">仅一行，显示有关WAL归档程序过程活动的统计信息。有关详细信息，请参见&lt;a href=&quot;monitoring-stats#PG-STAT-ARCHIVER-VIEW&quot;&gt;pg_stat_archiver&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7159edec345b30dd16d1cfb1cd64291c8e94cf0f" translate="yes" xml:space="preserve">
          <source>One row only, showing statistics about the background writer process's activity. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-BGWRITER-VIEW&quot;&gt;&lt;code&gt;pg_stat_bgwriter&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">仅一行，显示有关后台编写器进程活动的统计信息。有关详细信息，请参见&lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-BGWRITER-VIEW&quot;&gt; &lt;code&gt;pg_stat_bgwriter&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="08ff69da529511355514d8fad09917a768f3dfee" translate="yes" xml:space="preserve">
          <source>One row only, showing statistics about the background writer process's activity. See &lt;a href=&quot;monitoring-stats#PG-STAT-BGWRITER-VIEW&quot;&gt;pg_stat_bgwriter&lt;/a&gt; for details.</source>
          <target state="translated">仅一行，显示有关后台编写器进程活动的统计信息。有关详细信息，请参见&lt;a href=&quot;monitoring-stats#PG-STAT-BGWRITER-VIEW&quot;&gt;pg_stat_bgwriter&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="60bbed9973e1e54e8a987346455e2156c0d06574" translate="yes" xml:space="preserve">
          <source>One row per SLRU, showing statistics of operations. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-SLRU-VIEW&quot;&gt;&lt;code&gt;pg_stat_slru&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">每个SLRU一行，显示操作统计信息。有关详细信息，请参见&lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-SLRU-VIEW&quot;&gt; &lt;code&gt;pg_stat_slru&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="246692679d62f964e577891f2766cf44cbec4578" translate="yes" xml:space="preserve">
          <source>One row per WAL sender process, showing statistics about replication to that sender's connected standby server. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-REPLICATION-VIEW&quot;&gt;&lt;code&gt;pg_stat_replication&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">每个WAL发送方进程一行，显示有关复制到该发送方连接的备用服务器的统计信息。有关详细信息，请参见&lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-REPLICATION-VIEW&quot;&gt; &lt;code&gt;pg_stat_replication&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="41761c4e3d769b5a97047d2af3c904ca9b99e019" translate="yes" xml:space="preserve">
          <source>One row per WAL sender process, showing statistics about replication to that sender's connected standby server. See &lt;a href=&quot;monitoring-stats#PG-STAT-REPLICATION-VIEW&quot;&gt;pg_stat_replication&lt;/a&gt; for details.</source>
          <target state="translated">每个WAL发送方进程一行，显示有关复制到该发送方连接的备用服务器的统计信息。有关详细信息，请参见&lt;a href=&quot;monitoring-stats#PG-STAT-REPLICATION-VIEW&quot;&gt;pg_stat_replication&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1e405939a7164c82deba654b8915f184314fd703" translate="yes" xml:space="preserve">
          <source>One row per connection (regular and replication), showing information about GSSAPI authentication and encryption used on this connection. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-GSSAPI-VIEW&quot;&gt;&lt;code&gt;pg_stat_gssapi&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">每个连接（常规和复制）一行，显示有关此连接上使用的GSSAPI身份验证和加密的信息。有关详细信息，请参见&lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-GSSAPI-VIEW&quot;&gt; &lt;code&gt;pg_stat_gssapi&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="04eefccf9acdca920d874c55aed10830947f2ad0" translate="yes" xml:space="preserve">
          <source>One row per connection (regular and replication), showing information about GSSAPI authentication and encryption used on this connection. See &lt;a href=&quot;monitoring-stats#PG-STAT-GSSAPI-VIEW&quot;&gt;pg_stat_gssapi&lt;/a&gt; for details.</source>
          <target state="translated">每个连接（常规和复制）一行，显示有关此连接上使用的GSSAPI身份验证和加密的信息。有关详细信息，请参见&lt;a href=&quot;monitoring-stats#PG-STAT-GSSAPI-VIEW&quot;&gt;pg_stat_gssapi&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c0c6ee7f9f33f1b8de0af5ed4f012017f5739968" translate="yes" xml:space="preserve">
          <source>One row per connection (regular and replication), showing information about SSL used on this connection. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-SSL-VIEW&quot;&gt;&lt;code&gt;pg_stat_ssl&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">每个连接（常规和复制）一行，显示有关此连接上使用的SSL的信息。有关详细信息，请参见&lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-SSL-VIEW&quot;&gt; &lt;code&gt;pg_stat_ssl&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ff2500623059c396127b50986a7192b6dece4045" translate="yes" xml:space="preserve">
          <source>One row per connection (regular and replication), showing information about SSL used on this connection. See &lt;a href=&quot;monitoring-stats#PG-STAT-SSL-VIEW&quot;&gt;pg_stat_ssl&lt;/a&gt; for details.</source>
          <target state="translated">每个连接（常规和复制）一行，显示有关此连接上使用的SSL的信息。有关详细信息，请参见&lt;a href=&quot;monitoring-stats#PG-STAT-SSL-VIEW&quot;&gt;pg_stat_ssl&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="01cc5c68a8fa3b32b1a1b5f70dba90054b794d9e" translate="yes" xml:space="preserve">
          <source>One row per database, showing database-wide statistics about query cancels due to conflict with recovery on standby servers. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-DATABASE-CONFLICTS-VIEW&quot;&gt;&lt;code&gt;pg_stat_database_conflicts&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">每个数据库一行，显示有关由于备用服务器上的恢复冲突而导致的查询取消的全数据库范围的统计信息。有关详细信息，请参见&lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-DATABASE-CONFLICTS-VIEW&quot;&gt; &lt;code&gt;pg_stat_database_conflicts&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1e2bdd85f6f61ca9f60bf24ae4eb4fe127af69af" translate="yes" xml:space="preserve">
          <source>One row per database, showing database-wide statistics about query cancels due to conflict with recovery on standby servers. See &lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-CONFLICTS-VIEW&quot;&gt;pg_stat_database_conflicts&lt;/a&gt; for details.</source>
          <target state="translated">每个数据库一行，显示有关由于备用服务器上的恢复冲突而导致的查询取消的全数据库范围统计信息。有关详细信息，请参见&lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-CONFLICTS-VIEW&quot;&gt;pg_stat_database_conflicts&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="28e4559145d57da7a6239ef820ede5cd25bacf3c" translate="yes" xml:space="preserve">
          <source>One row per database, showing database-wide statistics. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-DATABASE-VIEW&quot;&gt;&lt;code&gt;pg_stat_database&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">每个数据库一行，显示数据库范围的统计信息。有关详细信息，请参见&lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-DATABASE-VIEW&quot;&gt; &lt;code&gt;pg_stat_database&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="28ca9a3ad9c0527d7bf8067a93b52b4e199755b8" translate="yes" xml:space="preserve">
          <source>One row per database, showing database-wide statistics. See &lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-VIEW&quot;&gt;pg_stat_database&lt;/a&gt; for details.</source>
          <target state="translated">每个数据库一行，显示数据库范围的统计信息。有关详细信息，请参见&lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-VIEW&quot;&gt;pg_stat_database&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e295d72faf33e0deeaaee1f07b6d5d6544081e45" translate="yes" xml:space="preserve">
          <source>One row per server process, showing information related to the current activity of that process, such as state and current query. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-ACTIVITY-VIEW&quot;&gt;&lt;code&gt;pg_stat_activity&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">每个服务器进程一行，显示与该进程的当前活动有关的信息，例如状态和当前查询。有关详细信息，请参见&lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-ACTIVITY-VIEW&quot;&gt; &lt;code&gt;pg_stat_activity&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="02ad092a9644445754a24d9ccf37920da6663d5c" translate="yes" xml:space="preserve">
          <source>One row per server process, showing information related to the current activity of that process, such as state and current query. See &lt;a href=&quot;monitoring-stats#PG-STAT-ACTIVITY-VIEW&quot;&gt;pg_stat_activity&lt;/a&gt; for details.</source>
          <target state="translated">每个服务器进程一行，显示与该进程的当前活动有关的信息，例如状态和当前查询。有关详细信息，请参见&lt;a href=&quot;monitoring-stats#PG-STAT-ACTIVITY-VIEW&quot;&gt;pg_stat_activity&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cd0d7184c558c048e1447f27b2e4a45d43e212a8" translate="yes" xml:space="preserve">
          <source>One semantically-insignificant detail worth noting is that in &lt;code&gt;jsonb&lt;/code&gt;, numbers will be printed according to the behavior of the underlying &lt;code&gt;numeric&lt;/code&gt; type. In practice this means that numbers entered with &lt;code&gt;E&lt;/code&gt; notation will be printed without it, for example:</source>
          <target state="translated">值得注意的一个语义无关紧要的细节是，在 &lt;code&gt;jsonb&lt;/code&gt; 中，将根据基础 &lt;code&gt;numeric&lt;/code&gt; 类型的行为来打印数字。实际上，这意味着使用 &lt;code&gt;E&lt;/code&gt; 记号输入的数字将不打印，例如：</target>
        </trans-unit>
        <trans-unit id="7a6e275ed16c86e3b4c5fd635846a9ed4c51adbd" translate="yes" xml:space="preserve">
          <source>One server process blocks another if it either holds a lock that conflicts with the blocked process's lock request (hard block), or is waiting for a lock that would conflict with the blocked process's lock request and is ahead of it in the wait queue (soft block). When using parallel queries the result always lists client-visible process IDs (that is, &lt;code&gt;pg_backend_pid&lt;/code&gt; results) even if the actual lock is held or awaited by a child worker process. As a result of that, there may be duplicated PIDs in the result. Also note that when a prepared transaction holds a conflicting lock, it will be represented by a zero process ID.</source>
          <target state="translated">如果一个服务器进程持有与被阻止进程的锁定请求（硬块）相冲突的锁，或者正在等待一个与被阻止进程的锁定请求相冲突的锁，并且位于等待队列中，则另一个服务器进程将阻塞另一个（软堵塞）。使用并行查询时，即使子工作进程持有或等待了实际的锁定，结果也始终列出客户端可见的进程ID（即 &lt;code&gt;pg_backend_pid&lt;/code&gt; 结果）。结果，结果中可能存在重复的PID。还要注意，当准备好的事务持有冲突的锁时，它将由零进程ID表示。</target>
        </trans-unit>
        <trans-unit id="eee0b1a9ad748e96945cdf21735c3cba379b36e1" translate="yes" xml:space="preserve">
          <source>One should be wary of statements of the form</source>
          <target state="translated">我们应该警惕以下形式的声明</target>
        </trans-unit>
        <trans-unit id="46a23970289c263b3e0e6e71fbc6ba26b97f5282" translate="yes" xml:space="preserve">
          <source>One should be wary that it is easy to misspell a POSIX-style time zone specification, since there is no check on the reasonableness of the zone abbreviation(s). For example, &lt;code&gt;SET TIMEZONE TO FOOBAR0&lt;/code&gt; will work, leaving the system effectively using a rather peculiar abbreviation for UTC.</source>
          <target state="translated">应当警惕，很容易拼写POSIX风格的时区规范，因为没有检查时区缩写的合理性。例如， &lt;code&gt;SET TIMEZONE TO FOOBAR0&lt;/code&gt; 将起作用，而使用UTC的一个特有的缩写有效地离开了系统。</target>
        </trans-unit>
        <trans-unit id="0503270d022d51df4a5d1385ddb363763c100a21" translate="yes" xml:space="preserve">
          <source>One should be wary that the POSIX-style time zone feature can lead to silently accepting bogus input, since there is no check on the reasonableness of the zone abbreviations. For example, &lt;code&gt;SET TIMEZONE TO FOOBAR0&lt;/code&gt; will work, leaving the system effectively using a rather peculiar abbreviation for UTC. Another issue to keep in mind is that in POSIX time zone names, positive offsets are used for locations &lt;em&gt;west&lt;/em&gt; of Greenwich. Everywhere else, PostgreSQL follows the ISO-8601 convention that positive timezone offsets are &lt;em&gt;east&lt;/em&gt; of Greenwich.</source>
          <target state="translated">应当警惕的是，POSIX风格的时区功能可能导致静默接受虚假输入，因为没有检查时区缩写的合理性。例如， &lt;code&gt;SET TIMEZONE TO FOOBAR0&lt;/code&gt; 将起作用，而使用UTC的一个特有的缩写有效地离开了系统。要记住的另一个问题是，在POSIX时区名称中，格林威治&lt;em&gt;以西&lt;/em&gt;的位置使用正偏移量。 PostgreSQL在其他任何地方都遵循ISO-8601约定，正时区偏移量&lt;em&gt;位于&lt;/em&gt;格林威治&lt;em&gt;以东&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="07761093680f0435d07de4dfbf3133e5f6e33451" translate="yes" xml:space="preserve">
          <source>One upgrade method is to dump data from one major version of PostgreSQL and reload it in another &amp;mdash; to do this, you must use a &lt;em&gt;logical&lt;/em&gt; backup tool like pg_dumpall; file system level backup methods will not work. (There are checks in place that prevent you from using a data directory with an incompatible version of PostgreSQL, so no great harm can be done by trying to start the wrong server version on a data directory.)</source>
          <target state="translated">一种升级方法是从一个主要PostgreSQL版本中转储数据，然后将其重新加载到另一个主要版本中-为此，您必须使用pg_dumpall之类的&lt;em&gt;逻辑&lt;/em&gt;备份工具。文件系统级备份方法将不起作用。 （有适当的检查可以防止您使用数据目录与PostgreSQL的不兼容版本，因此，尝试在数据目录上启动错误的服务器版本不会造成很大的伤害。）</target>
        </trans-unit>
        <trans-unit id="3c2ef0cb6e16fe638517e00044d9fddafd2f1f0e" translate="yes" xml:space="preserve">
          <source>One way to avoid this problem is to run PostgreSQL on a machine where you can be sure that other processes will not run the machine out of memory. If memory is tight, increasing the swap space of the operating system can help avoid the problem, because the out-of-memory (OOM) killer is invoked only when physical memory and swap space are exhausted.</source>
          <target state="translated">避免这个问题的一个方法是在一台机器上运行PostgreSQL,在这台机器上你可以确定其他进程不会将机器运行到内存不足。如果内存紧张,增加操作系统的交换空间可以帮助避免这个问题,因为只有当物理内存和交换空间耗尽时,才会调用内存外(OOM)杀手。</target>
        </trans-unit>
        <trans-unit id="cb720ead71b0312fba38d640c63f7a5801cc13dc" translate="yes" xml:space="preserve">
          <source>One way to do this is to shut down the server and start a single-user PostgreSQL server with the &lt;code&gt;-P&lt;/code&gt; option included on its command line. Then, &lt;code&gt;REINDEX DATABASE&lt;/code&gt;, &lt;code&gt;REINDEX SYSTEM&lt;/code&gt;, &lt;code&gt;REINDEX TABLE&lt;/code&gt;, or &lt;code&gt;REINDEX INDEX&lt;/code&gt; can be issued, depending on how much you want to reconstruct. If in doubt, use &lt;code&gt;REINDEX SYSTEM&lt;/code&gt; to select reconstruction of all system indexes in the database. Then quit the single-user server session and restart the regular server. See the &lt;a href=&quot;app-postgres&quot;&gt;postgres&lt;/a&gt; reference page for more information about how to interact with the single-user server interface.</source>
          <target state="translated">一种方法是关闭服务器，并使用命令行中包含的 &lt;code&gt;-P&lt;/code&gt; 选项启动单用户PostgreSQL服务器。然后，根据要重建的数量，可以发出 &lt;code&gt;REINDEX DATABASE&lt;/code&gt; ， &lt;code&gt;REINDEX SYSTEM&lt;/code&gt; ， &lt;code&gt;REINDEX TABLE&lt;/code&gt; 或 &lt;code&gt;REINDEX INDEX&lt;/code&gt; 。如有疑问，请使用 &lt;code&gt;REINDEX SYSTEM&lt;/code&gt; 选择重建数据库中所有系统索引的方式。然后退出单用户服务器会话并重新启动常规服务器。有关如何与单用户服务器界面进行交互的更多信息，请参见&lt;a href=&quot;app-postgres&quot;&gt;postgres&lt;/a&gt;参考页面。</target>
        </trans-unit>
        <trans-unit id="76a318a5204a34131edd8add7164960e6a6851df" translate="yes" xml:space="preserve">
          <source>One way to look at variant plans is to force the planner to disregard whatever strategy it thought was the cheapest, using the enable/disable flags described in &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-ENABLE&quot;&gt;Section 19.7.1&lt;/a&gt;. (This is a crude tool, but useful. See also &lt;a href=&quot;explicit-joins&quot;&gt;Section 14.3&lt;/a&gt;.) For example, if we're unconvinced that sequential-scan-and-sort is the best way to deal with table &lt;code&gt;onek&lt;/code&gt; in the previous example, we could try</source>
          <target state="translated">查看变体计划的一种方法是，使用&lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-ENABLE&quot;&gt;19.7.1节中&lt;/a&gt;描述的启用/禁用标志，迫使计划者忽略其认为最便宜的任何策略。 （这是一个粗略的工具，但很有用。另请参见&lt;a href=&quot;explicit-joins&quot;&gt;第14.3节&lt;/a&gt;。）例如，如果我们不相信顺序扫描和排序是处理上一个示例中的表 &lt;code&gt;onek&lt;/code&gt; 的最佳方法，则可以尝试</target>
        </trans-unit>
        <trans-unit id="0391e7fdb45313d9e4e2f5f1634bb9ecb7a05ff9" translate="yes" xml:space="preserve">
          <source>One way to prevent spoofing of &lt;code&gt;local&lt;/code&gt; connections is to use a Unix domain socket directory (&lt;a href=&quot;runtime-config-connection#GUC-UNIX-SOCKET-DIRECTORIES&quot;&gt;unix_socket_directories&lt;/a&gt;) that has write permission only for a trusted local user. This prevents a malicious user from creating their own socket file in that directory. If you are concerned that some applications might still reference &lt;code&gt;/tmp&lt;/code&gt; for the socket file and hence be vulnerable to spoofing, during operating system startup create a symbolic link &lt;code&gt;/tmp/.s.PGSQL.5432&lt;/code&gt; that points to the relocated socket file. You also might need to modify your &lt;code&gt;/tmp&lt;/code&gt; cleanup script to prevent removal of the symbolic link.</source>
          <target state="translated">防止欺骗 &lt;code&gt;local&lt;/code&gt; 连接的一种方法是使用Unix域套接字目录（&lt;a href=&quot;runtime-config-connection#GUC-UNIX-SOCKET-DIRECTORIES&quot;&gt;unix_socket_directories&lt;/a&gt;），该目录仅对受信任的本地用户具有写权限。这样可以防止恶意用户在该目录中创建自己的套接字文件。如果您担心某些应用程序可能仍然为套接字文件引用 &lt;code&gt;/tmp&lt;/code&gt; 并因此容易受到欺骗，请在操作系统启动期间创建一个符号链接 &lt;code&gt;/tmp/.s.PGSQL.5432&lt;/code&gt; ，该链接指向已重定位的套接字文件。您可能还需要修改 &lt;code&gt;/tmp&lt;/code&gt; 清理脚本，以防止删除符号链接。</target>
        </trans-unit>
        <trans-unit id="839eb373f7e57c0c527b6ab4498f37574f9b1b5d" translate="yes" xml:space="preserve">
          <source>Online Analytical Processing</source>
          <target state="translated">在线分析处理</target>
        </trans-unit>
        <trans-unit id="9bc8e24fa431e83abb8ee45cbd92647ad8e714f7" translate="yes" xml:space="preserve">
          <source>Online Transaction Processing</source>
          <target state="translated">在线交易处理</target>
        </trans-unit>
        <trans-unit id="0b59497ee41bee58e3cf2969b674c4903d4bc6b0" translate="yes" xml:space="preserve">
          <source>Online statistics:</source>
          <target state="translated">在线统计。</target>
        </trans-unit>
        <trans-unit id="95683a3aebf06f5e3b349d234f74e1173b887f29" translate="yes" xml:space="preserve">
          <source>Only an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock blocks a &lt;code&gt;SELECT&lt;/code&gt; (without &lt;code&gt;FOR UPDATE/SHARE&lt;/code&gt;) statement.</source>
          <target state="translated">仅 &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; 锁会阻止 &lt;code&gt;SELECT&lt;/code&gt; （不带 &lt;code&gt;FOR UPDATE/SHARE&lt;/code&gt; ）语句。</target>
        </trans-unit>
        <trans-unit id="6428d0603b66d67294f1af1eb460cffe5ea43327" translate="yes" xml:space="preserve">
          <source>Only calculate statistics for use by the optimizer (no vacuum), like &lt;code&gt;--analyze-only&lt;/code&gt;. Run several (currently three) stages of analyze with different configuration settings, to produce usable statistics faster.</source>
          <target state="translated">仅计算供优化程序使用的统计信息（无真空），例如 &lt;code&gt;--analyze-only&lt;/code&gt; 。使用不同的配置设置运行几个（当前三个）分析阶段，以更快地生成可用的统计信息。</target>
        </trans-unit>
        <trans-unit id="e4af2b2a347593a2587cd89d5c7edc042fe1b2ae" translate="yes" xml:space="preserve">
          <source>Only calculate statistics for use by the optimizer (no vacuum).</source>
          <target state="translated">只计算供优化器使用的统计数据(没有真空)。</target>
        </trans-unit>
        <trans-unit id="1ff76f6d5463fac41b779622c32a96a9ae59972a" translate="yes" xml:space="preserve">
          <source>Only certain data types support TOAST &amp;mdash; there is no need to impose the overhead on data types that cannot produce large field values. To support TOAST, a data type must have a variable-length (&lt;em&gt;varlena&lt;/em&gt;) representation, in which, ordinarily, the first four-byte word of any stored value contains the total length of the value in bytes (including itself). TOAST does not constrain the rest of the data type's representation. The special representations collectively called &lt;em&gt;TOASTed values&lt;/em&gt; work by modifying or reinterpreting this initial length word. Therefore, the C-level functions supporting a TOAST-able data type must be careful about how they handle potentially TOASTed input values: an input might not actually consist of a four-byte length word and contents until after it's been &lt;em&gt;detoasted&lt;/em&gt;. (This is normally done by invoking &lt;code&gt;PG_DETOAST_DATUM&lt;/code&gt; before doing anything with an input value, but in some cases more efficient approaches are possible. See &lt;a href=&quot;https://www.postgresql.org/docs/12/xtypes.html#XTYPES-TOAST&quot;&gt;Section 37.13.1&lt;/a&gt; for more detail.)</source>
          <target state="translated">仅某些数据类型支持TOAST-无需将开销强加于不能产生较大字段值的数据类型。为了支持TOAST，数据类型必须具有可变长度（&lt;em&gt;varlena&lt;/em&gt;）表示形式，在该表示形式中，通常任何存储值的前四个字节字都包含该值的总长度（以字节为单位）（包括其自身）。 TOAST不会约束其余数据类型的表示。统称为&lt;em&gt;TOASTed值&lt;/em&gt;的特殊表示通过修改或重新解释此初始长度字词来工作。因此，支持TOAST-able数据类型的C级函数必须谨慎对待它们如何处理可能的TOASTed输入值：输入可能直到由输入后才真正由四字节长的字和内容组成&lt;em&gt;敬酒的&lt;/em&gt;。（这通常是通过在对输入值进行任何 &lt;code&gt;PG_DETOAST_DATUM&lt;/code&gt; 之前调用PG_DETOAST_DATUM来完成的，但是在某些情况下，更有效的方法是可行的。有关更多详细信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/xtypes.html#XTYPES-TOAST&quot;&gt;37.13.1节&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="6ed75bf01a8cac9ceb181bdbf71cfb0dfa8f9324" translate="yes" xml:space="preserve">
          <source>Only certain data types support TOAST &amp;mdash; there is no need to impose the overhead on data types that cannot produce large field values. To support TOAST, a data type must have a variable-length (&lt;em&gt;varlena&lt;/em&gt;) representation, in which, ordinarily, the first four-byte word of any stored value contains the total length of the value in bytes (including itself). TOAST does not constrain the rest of the data type's representation. The special representations collectively called &lt;em&gt;TOASTed values&lt;/em&gt; work by modifying or reinterpreting this initial length word. Therefore, the C-level functions supporting a TOAST-able data type must be careful about how they handle potentially TOASTed input values: an input might not actually consist of a four-byte length word and contents until after it's been &lt;em&gt;detoasted&lt;/em&gt;. (This is normally done by invoking &lt;code&gt;PG_DETOAST_DATUM&lt;/code&gt; before doing anything with an input value, but in some cases more efficient approaches are possible. See &lt;a href=&quot;https://www.postgresql.org/docs/13/xtypes.html#XTYPES-TOAST&quot;&gt;Section 37.13.1&lt;/a&gt; for more detail.)</source>
          <target state="translated">仅某些数据类型支持TOAST-无需将开销强加于不能产生较大字段值的数据类型。为了支持TOAST，数据类型必须具有可变长度（&lt;em&gt;varlena&lt;/em&gt;）表示形式，在该表示形式中，通常任何存储值的前四个字节字都包含该值的总长度（以字节为单位）（包括其自身）。TOAST不会约束其余数据类型的表示。统称为&lt;em&gt;TOASTed值&lt;/em&gt;的特殊表示通过修改或重新解释此初始长度字词来工作。因此，支持可支持TOAST的数据类型的C级函数必须谨慎对待它们如何处理潜在的TOASTed输入值：输入可能直到由输入后才真正由四字节长的字和内容组成&lt;em&gt;敬酒的&lt;/em&gt;。（这通常是通过在对输入值进行任何 &lt;code&gt;PG_DETOAST_DATUM&lt;/code&gt; 之前调用PG_DETOAST_DATUM来完成的，但是在某些情况下，更有效的方法是可行的。有关更多详细信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/13/xtypes.html#XTYPES-TOAST&quot;&gt;37.13.1节&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="27a5875a715917165876854e17c248ccf4f95f13" translate="yes" xml:space="preserve">
          <source>Only display records generated by the specified resource manager. If &lt;code&gt;list&lt;/code&gt; is passed as name, print a list of valid resource manager names, and exit.</source>
          <target state="translated">仅显示由指定资源管理器生成的记录。如果将 &lt;code&gt;list&lt;/code&gt; 作为名称传递，则打印有效资源管理器名称的列表，然后退出。</target>
        </trans-unit>
        <trans-unit id="1eec6acc7fed503402488b3ba82909c46aae0483" translate="yes" xml:space="preserve">
          <source>Only display records marked with the given transaction ID.</source>
          <target state="translated">只显示标有给定交易ID的记录。</target>
        </trans-unit>
        <trans-unit id="df686aa57f8a0399728798091a1185e8914758e9" translate="yes" xml:space="preserve">
          <source>Only dump the named section. The section name can be &lt;code&gt;pre-data&lt;/code&gt;, &lt;code&gt;data&lt;/code&gt;, or &lt;code&gt;post-data&lt;/code&gt;. This option can be specified more than once to select multiple sections. The default is to dump all sections.</source>
          <target state="translated">仅转储命名部分。节名称可以是 &lt;code&gt;pre-data&lt;/code&gt; ， &lt;code&gt;data&lt;/code&gt; 或 &lt;code&gt;post-data&lt;/code&gt; 。可以多次指定此选项以选择多个部分。默认为转储所有部分。</target>
        </trans-unit>
        <trans-unit id="8c62a53b547108de76ccc1531107eb8cfedb9cfb" translate="yes" xml:space="preserve">
          <source>Only execute the vacuum or analyze commands on tables with a multixact ID age of at least &lt;code&gt;mxid_age&lt;/code&gt;. This setting is useful for prioritizing tables to process to prevent multixact ID wraparound (see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-MULTIXACT-WRAPAROUND&quot;&gt;Section 24.1.5.1&lt;/a&gt;).</source>
          <target state="translated">仅对多重ID年龄至少为 &lt;code&gt;mxid_age&lt;/code&gt; 的表执行真空或分析命令。此设置对于优先处理表以防止多重ID换行很有用（请参阅&lt;a href=&quot;routine-vacuuming#VACUUM-FOR-MULTIXACT-WRAPAROUND&quot;&gt;第24.1.5.1节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="22cc7a345e3b6c6eac0bd069839bf36f1185ab25" translate="yes" xml:space="preserve">
          <source>Only execute the vacuum or analyze commands on tables with a transaction ID age of at least &lt;code&gt;xid_age&lt;/code&gt;. This setting is useful for prioritizing tables to process to prevent transaction ID wraparound (see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;Section 24.1.5&lt;/a&gt;).</source>
          <target state="translated">仅对事务ID年龄至少为 &lt;code&gt;xid_age&lt;/code&gt; 的表执行真空或分析命令。此设置对于优先处理表以防止事务ID绕包很有用（请参见&lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;第24.1.5节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="30caad55acba8eaee72cd0eb2b22ca9a6e1cfcaa" translate="yes" xml:space="preserve">
          <source>Only has effect if &lt;a href=&quot;app-initdb#APP-INITDB-DATA-CHECKSUMS&quot;&gt;data checksums&lt;/a&gt; are enabled.</source>
          <target state="translated">仅当启用&lt;a href=&quot;app-initdb#APP-INITDB-DATA-CHECKSUMS&quot;&gt;数据校验和&lt;/a&gt;时才有效。</target>
        </trans-unit>
        <trans-unit id="4930a6bbf0f1c4de7f538ff4072a1668f8d281a2" translate="yes" xml:space="preserve">
          <source>Only lowercase &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; spellings are accepted</source>
          <target state="translated">只有小写 &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 拼写被接受</target>
        </trans-unit>
        <trans-unit id="5d755b459eeaa6b733e81509898e0f04066e3489" translate="yes" xml:space="preserve">
          <source>Only one comment string is stored for each object, so to modify a comment, issue a new &lt;code&gt;COMMENT&lt;/code&gt; command for the same object. To remove a comment, write &lt;code&gt;NULL&lt;/code&gt; in place of the text string. Comments are automatically dropped when their object is dropped.</source>
          <target state="translated">每个对象仅存储一个注释字符串，因此要修改注释，对同一对象发出新的 &lt;code&gt;COMMENT&lt;/code&gt; 命令。要删除注释，请在文本字符串的位置写入 &lt;code&gt;NULL&lt;/code&gt; 。删除对象时，注释会自动删除。</target>
        </trans-unit>
        <trans-unit id="6b3d566bcef3dc1ca42fe3bd8ea05bbe930d19d6" translate="yes" xml:space="preserve">
          <source>Only one parameter may be supplied to the function in a &lt;code&gt;CREATE TRIGGER&lt;/code&gt; statement, and that is optional. If supplied it will be used for the channel name for the notifications. If omitted &lt;code&gt;tcn&lt;/code&gt; will be used for the channel name.</source>
          <target state="translated">在 &lt;code&gt;CREATE TRIGGER&lt;/code&gt; 语句中只能向函数提供一个参数，并且这是可选的。如果提供，它将用作通知的频道名称。如果省略，则将 &lt;code&gt;tcn&lt;/code&gt; 用作通道名称。</target>
        </trans-unit>
        <trans-unit id="e6026da30f943934674a5eb09f1e0f0526ceb2de" translate="yes" xml:space="preserve">
          <source>Only one row, showing statistics about the WAL receiver from that receiver's connected server. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-WAL-RECEIVER-VIEW&quot;&gt;&lt;code&gt;pg_stat_wal_receiver&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">仅一行，显示有关来自该接收器的连接服务器的WAL接收器的统计信息。有关详细信息，请参见&lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-WAL-RECEIVER-VIEW&quot;&gt; &lt;code&gt;pg_stat_wal_receiver&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="52d2c18b8c742c722526abc3884826a2891d9cd5" translate="yes" xml:space="preserve">
          <source>Only one row, showing statistics about the WAL receiver from that receiver's connected server. See &lt;a href=&quot;monitoring-stats#PG-STAT-WAL-RECEIVER-VIEW&quot;&gt;pg_stat_wal_receiver&lt;/a&gt; for details.</source>
          <target state="translated">仅一行，显示有关来自该接收器的连接服务器的WAL接收器的统计信息。有关详细信息，请参见&lt;a href=&quot;monitoring-stats#PG-STAT-WAL-RECEIVER-VIEW&quot;&gt;pg_stat_wal_receiver&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6e141ed896712b895fe333210a9bdff25138d7ab" translate="yes" xml:space="preserve">
          <source>Only operator classes for &lt;code&gt;int4&lt;/code&gt; and &lt;code&gt;text&lt;/code&gt; are included with the module.</source>
          <target state="translated">该模块仅包含 &lt;code&gt;int4&lt;/code&gt; 和 &lt;code&gt;text&lt;/code&gt; 的运算符类。</target>
        </trans-unit>
        <trans-unit id="109540637ae1151a05d5ef17fc0235346d4ed7ef" translate="yes" xml:space="preserve">
          <source>Only persistent base tables and partitioned tables can be part of a publication. Temporary tables, unlogged tables, foreign tables, materialized views, and regular views cannot be part of a publication.</source>
          <target state="translated">只有持久化的基表和分区表才能成为出版物的一部分。临时表、未记录的表、外来表、实体化视图和常规视图不能成为出版物的一部分。</target>
        </trans-unit>
        <trans-unit id="36554985b3656b4dddfbe30677cd178826516027" translate="yes" xml:space="preserve">
          <source>Only persistent base tables can be part of a publication. Temporary tables, unlogged tables, foreign tables, materialized views, regular views, and partitioned tables cannot be part of a publication. To replicate a partitioned table, add the individual partitions to the publication.</source>
          <target state="translated">只有持久化的基础表才能成为出版物的一部分。临时表、未记录表、外表、物化视图、常规视图和分区表不能成为出版物的一部分。要复制分区表,请将各个分区添加到出版物中。</target>
        </trans-unit>
        <trans-unit id="b0f9131e0157ccbc9f71702565357129b8273efc" translate="yes" xml:space="preserve">
          <source>Only restore the named section. The section name can be &lt;code&gt;pre-data&lt;/code&gt;, &lt;code&gt;data&lt;/code&gt;, or &lt;code&gt;post-data&lt;/code&gt;. This option can be specified more than once to select multiple sections. The default is to restore all sections.</source>
          <target state="translated">仅还原命名部分。节名称可以是 &lt;code&gt;pre-data&lt;/code&gt; ， &lt;code&gt;data&lt;/code&gt; 或 &lt;code&gt;post-data&lt;/code&gt; 。可以多次指定此选项以选择多个部分。默认为还原所有部分。</target>
        </trans-unit>
        <trans-unit id="9d94341e83b6e3cc09be7f96d9ae2bbdbd997a3f" translate="yes" xml:space="preserve">
          <source>Only roles that have the &lt;code&gt;LOGIN&lt;/code&gt; attribute can be used as the initial role name for a database connection. A role with the &lt;code&gt;LOGIN&lt;/code&gt; attribute can be considered the same as a &amp;ldquo;database user&amp;rdquo;. To create a role with login privilege, use either:</source>
          <target state="translated">只有具有 &lt;code&gt;LOGIN&lt;/code&gt; 属性的角色才能用作数据库连接的初始角色名称。具有 &lt;code&gt;LOGIN&lt;/code&gt; 属性的角色可被视为与&amp;ldquo;数据库用户&amp;rdquo;相同。要创建具有登录特权的角色，请使用以下任一方法：</target>
        </trans-unit>
        <trans-unit id="d85fc142dd33473e697f51542b02c504f67a9b35" translate="yes" xml:space="preserve">
          <source>Only shared libraries specifically intended to be used with PostgreSQL can be loaded this way. Every PostgreSQL-supported library has a &amp;ldquo;magic block&amp;rdquo; that is checked to guarantee compatibility. For this reason, non-PostgreSQL libraries cannot be loaded in this way. You might be able to use operating-system facilities such as &lt;code&gt;LD_PRELOAD&lt;/code&gt; for that.</source>
          <target state="translated">这样只能加载专门用于PostgreSQL的共享库。每个PostgreSQL支持的库都有一个&amp;ldquo;魔术块&amp;rdquo;，选中该魔术块可以保证兼容性。因此，无法以这种方式加载非PostgreSQL库。您可能可以使用操作系统功能，例如 &lt;code&gt;LD_PRELOAD&lt;/code&gt; 之。</target>
        </trans-unit>
        <trans-unit id="7bf905053544478968750f95521ca3e30e70375f" translate="yes" xml:space="preserve">
          <source>Only superusers can alter foreign-data wrappers. Additionally, only superusers can own foreign-data wrappers.</source>
          <target state="translated">只有超级用户才可以修改外来数据的包装物,另外,只有超级用户才可以拥有外来数据的包装物。此外,只有超级用户才能拥有外来数据包装器。</target>
        </trans-unit>
        <trans-unit id="b9d1a65de15d43acfd7df441e250838c198f3037" translate="yes" xml:space="preserve">
          <source>Only superusers can call &lt;code&gt;CHECKPOINT&lt;/code&gt;.</source>
          <target state="translated">只有超级用户可以拨打电话 &lt;code&gt;CHECKPOINT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b3d5ff53d3f29afdf3319b912d99cf3260a4f77" translate="yes" xml:space="preserve">
          <source>Only superusers can change this setting, because it affects the messages sent to the server log as well as to the client, and an improper value might obscure the readability of the server logs.</source>
          <target state="translated">只有超级用户才能改变这个设置,因为它既会影响发送到服务器日志的消息,也会影响发送到客户端的消息,一个不恰当的值可能会掩盖服务器日志的可读性。</target>
        </trans-unit>
        <trans-unit id="b2be6ed45f348313973635f2ddfd082cf6f9717d" translate="yes" xml:space="preserve">
          <source>Only superusers can create event triggers.</source>
          <target state="translated">只有超级用户可以创建事件触发器。</target>
        </trans-unit>
        <trans-unit id="2ae5bc67902361297a54dbc3f2c9fc4cdf0facde" translate="yes" xml:space="preserve">
          <source>Only superusers can create foreign-data wrappers.</source>
          <target state="translated">只有超级用户才能创建外来数据包装器。</target>
        </trans-unit>
        <trans-unit id="a0a550e0a836899716e0fe5ebdbfaa0d54059384" translate="yes" xml:space="preserve">
          <source>Only superusers can define new access methods.</source>
          <target state="translated">只有超级用户才能定义新的访问方法。</target>
        </trans-unit>
        <trans-unit id="d11423b98472dc3dca65de17ed52b8e73990fa3d" translate="yes" xml:space="preserve">
          <source>Only superusers can use &lt;code&gt;ALTER SYSTEM&lt;/code&gt;. Also, since this command acts directly on the file system and cannot be rolled back, it is not allowed inside a transaction block or function.</source>
          <target state="translated">只有超级用户可以使用 &lt;code&gt;ALTER SYSTEM&lt;/code&gt; 。另外，由于此命令直接作用于文件系统且无法回滚，因此不允许在事务块或函数内部使用该命令。</target>
        </trans-unit>
        <trans-unit id="d0b0ed2869d7ce3fc0379f4c0080abfebb839775" translate="yes" xml:space="preserve">
          <source>Only superusers may connect to foreign servers without password authentication, so always specify the &lt;code&gt;password&lt;/code&gt; option for user mappings belonging to non-superusers.</source>
          <target state="translated">只有超级用户可以在没有密码身份验证的情况下连接到外部服务器，因此请务必指定 &lt;code&gt;password&lt;/code&gt; 为属于非超级用户的用户映射 password选项。</target>
        </trans-unit>
        <trans-unit id="9674d9c7cf6a8e522bf949d4719f88f50cf734f7" translate="yes" xml:space="preserve">
          <source>Only superusers may create or modify user mappings with the &lt;code&gt;sslcert&lt;/code&gt; or &lt;code&gt;sslkey&lt;/code&gt; settings.</source>
          <target state="translated">只有超级用户才能使用 &lt;code&gt;sslcert&lt;/code&gt; 或 &lt;code&gt;sslkey&lt;/code&gt; 设置创建或修改用户映射。</target>
        </trans-unit>
        <trans-unit id="add5aed352ded84ef9a29f07c8afce866831ef29" translate="yes" xml:space="preserve">
          <source>Only the &lt;code&gt;=&lt;/code&gt; operator is supported for search. But it is possible to add support for arrays with union and intersection operations in the future.</source>
          <target state="translated">只有 &lt;code&gt;=&lt;/code&gt; 支持=运算符进行搜索。但是将来可能会增加对具有联合和相交运算的数组的支持。</target>
        </trans-unit>
        <trans-unit id="a2c2cf173b45b1ac1a32e3ec0d5fe77ba32623c7" translate="yes" xml:space="preserve">
          <source>Only the &lt;code&gt;ANALYZE&lt;/code&gt; and &lt;code&gt;VERBOSE&lt;/code&gt; options can be specified, and only in that order, without surrounding the option list in parentheses. Prior to PostgreSQL 9.0, the unparenthesized syntax was the only one supported. It is expected that all new options will be supported only in the parenthesized syntax.</source>
          <target state="translated">只有 &lt;code&gt;ANALYZE&lt;/code&gt; 和 &lt;code&gt;VERBOSE&lt;/code&gt; 可以指定选项，并且只能按该顺序指定，而不要在括号中包含选项列表。在PostgreSQL 9.0之前，唯一支持无括号语法。期望所有新选项仅在括号语法中受支持。</target>
        </trans-unit>
        <trans-unit id="60a1039af88ab14d5161dbfac50ade9fe96eaa30" translate="yes" xml:space="preserve">
          <source>Only the custom and directory archive formats are supported with this option. The input must be a regular file or directory (not, for example, a pipe or standard input). Also, multiple jobs cannot be used together with the option &lt;code&gt;--single-transaction&lt;/code&gt;.</source>
          <target state="translated">此选项仅支持自定义和目录归档格式。输入必须是常规文件或目录（而不是管道或标准输入）。另外，不能将多个作业与 &lt;code&gt;--single-transaction&lt;/code&gt; 选项一起使用。</target>
        </trans-unit>
        <trans-unit id="5022f8e7bdd77bf8c02d9d1490318561a8027b6a" translate="yes" xml:space="preserve">
          <source>Only the custom and directory archive formats are supported with this option. The input must be a regular file or directory (not, for example, a pipe). This option is ignored when emitting a script rather than connecting directly to a database server. Also, multiple jobs cannot be used together with the option &lt;code&gt;--single-transaction&lt;/code&gt;.</source>
          <target state="translated">此选项仅支持自定义和目录归档格式。输入必须是常规文件或目录（而不是管道）。发出脚本而不是直接连接到数据库服务器时，将忽略此选项。另外，不能将多个作业与 &lt;code&gt;--single-transaction&lt;/code&gt; 选项一起使用。</target>
        </trans-unit>
        <trans-unit id="5e47b4720ff6f0582001899cb68bf4bdb2a0ac11" translate="yes" xml:space="preserve">
          <source>Only the owner of the database, or a superuser, can drop a database. Dropping a database removes all objects that were contained within the database. The destruction of a database cannot be undone.</source>
          <target state="translated">只有数据库的所有者或超级用户才能放弃数据库。删除数据库会删除数据库中包含的所有对象。数据库的销毁是无法挽回的。</target>
        </trans-unit>
        <trans-unit id="992702029b9e3a50c611dc6825669adb061c4f3f" translate="yes" xml:space="preserve">
          <source>Only the specified timeline is displayed (or the default, if none is specified). Records in other timelines are ignored.</source>
          <target state="translated">只显示指定的时间线(如果没有指定,则显示默认值)。其他时间线中的记录将被忽略。</target>
        </trans-unit>
        <trans-unit id="0e8a66b6f0be3b6d7c6a27438485bc034b86bede" translate="yes" xml:space="preserve">
          <source>Only validate checksums in the relation with filenode &lt;code&gt;filenode&lt;/code&gt;.</source>
          <target state="translated">仅在与FileNode &lt;code&gt;filenode&lt;/code&gt; 的关系中验证校验和。</target>
        </trans-unit>
        <trans-unit id="e0b885bbfd4f3bfc263123d67cbabd608309adfe" translate="yes" xml:space="preserve">
          <source>Open Database Connectivity</source>
          <target state="translated">开放式数据库连接</target>
        </trans-unit>
        <trans-unit id="904b1a9c4f30cf27ea883ca5fa7d3ff036c36eb9" translate="yes" xml:space="preserve">
          <source>Open interval with lower bound &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">下限 &lt;code&gt;x&lt;/code&gt; 的开区间</target>
        </trans-unit>
        <trans-unit id="5a8b4a983dd22778ee9f002679eacd86bf69191d" translate="yes" xml:space="preserve">
          <source>Open interval with upper bound &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">开区间 &lt;code&gt;x&lt;/code&gt; 的上限</target>
        </trans-unit>
        <trans-unit id="45de3417dc1987111074bc170202fbf751c567d8" translate="yes" xml:space="preserve">
          <source>Open path</source>
          <target state="translated">开放路径</target>
        </trans-unit>
        <trans-unit id="db3951317261fd51cb4c1a3e01c4748b4896c421" translate="yes" xml:space="preserve">
          <source>OpenBSD</source>
          <target state="translated">OpenBSD</target>
        </trans-unit>
        <trans-unit id="50ef244d7dd70cb29f22ada32d04825a64fc9036" translate="yes" xml:space="preserve">
          <source>OpenBSD sys/crypto</source>
          <target state="translated">OpenBSD sys/crypto</target>
        </trans-unit>
        <trans-unit id="e301ca795081a87c0033bddb2e90503f9f7929d2" translate="yes" xml:space="preserve">
          <source>OpenPGP message format.</source>
          <target state="translated">OpenPGP消息格式。</target>
        </trans-unit>
        <trans-unit id="2188261ca504497d39a1689d5dff920fe8b50f79" translate="yes" xml:space="preserve">
          <source>OpenSSL names for the most common curves are: &lt;code&gt;prime256v1&lt;/code&gt; (NIST P-256), &lt;code&gt;secp384r1&lt;/code&gt; (NIST P-384), &lt;code&gt;secp521r1&lt;/code&gt; (NIST P-521). The full list of available curves can be shown with the command &lt;code&gt;openssl ecparam -list_curves&lt;/code&gt;. Not all of them are usable in TLS though.</source>
          <target state="translated">最常见曲线的OpenSSL名称是： &lt;code&gt;prime256v1&lt;/code&gt; （NIST P-256）， &lt;code&gt;secp384r1&lt;/code&gt; （NIST P-384）， &lt;code&gt;secp521r1&lt;/code&gt; （NIST P-521）。可用曲线的完整列表可以使用以下命令显示： &lt;code&gt;openssl ecparam -list_curves&lt;/code&gt; 。但是，并非所有这些功能都可以在TLS中使用。</target>
        </trans-unit>
        <trans-unit id="5c972fdff495c397d3150e0515793a7f4559382c" translate="yes" xml:space="preserve">
          <source>OpenSSL supports a wide range of ciphers and authentication algorithms, of varying strength. While a list of ciphers can be specified in the OpenSSL configuration file, you can specify ciphers specifically for use by the database server by modifying &lt;a href=&quot;runtime-config-connection#GUC-SSL-CIPHERS&quot;&gt;ssl_ciphers&lt;/a&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="translated">OpenSSL支持各种强度不同的密码和身份验证算法。虽然可以在OpenSSL设置文件中指定的密码列表，你可以通过修改指定专门针对数据库服务器使用密码&lt;a href=&quot;runtime-config-connection#GUC-SSL-CIPHERS&quot;&gt;的ssl_ciphers&lt;/a&gt;在 &lt;code&gt;postgresql.conf&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="c3b0974ebaa95408edcf74b52711fc4f50a804a3" translate="yes" xml:space="preserve">
          <source>Operations such as TRUNCATE which normally affect a table and all of its inheritance children will cascade to all partitions, but may also be performed on an individual partition. Note that dropping a partition with &lt;code&gt;DROP TABLE&lt;/code&gt; requires taking an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock on the parent table.</source>
          <target state="translated">通常会影响表及其所有继承子级的操作（例如TRUNCATE）将级联到所有分区，但也可以在单个分区上执行。请注意，使用 &lt;code&gt;DROP TABLE&lt;/code&gt; 删除分区需要使用 &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; 对父表锁定。</target>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="b07cfafa5cefef04cd848e7642b8acf9013a81e6" translate="yes" xml:space="preserve">
          <source>Operator Classes and Operator Families</source>
          <target state="translated">操作员类别和操作员家族</target>
        </trans-unit>
        <trans-unit id="b398f34e06d00a1a82db7c5bd5884749c340c3d5" translate="yes" xml:space="preserve">
          <source>Operator Strategy 1</source>
          <target state="translated">运营商战略1</target>
        </trans-unit>
        <trans-unit id="244ef231d648a8011796f75d8ba0c200ff67c490" translate="yes" xml:space="preserve">
          <source>Operator Strategy 10</source>
          <target state="translated">经营者战略 10</target>
        </trans-unit>
        <trans-unit id="aa5d9755365c2952ee3e6f612eacdbdd1a1d7624" translate="yes" xml:space="preserve">
          <source>Operator Strategy 11</source>
          <target state="translated">经营者战略 11</target>
        </trans-unit>
        <trans-unit id="d4a97822fa5fff84d7420e13e887c2193e9890f0" translate="yes" xml:space="preserve">
          <source>Operator Strategy 12</source>
          <target state="translated">经营者战略.12</target>
        </trans-unit>
        <trans-unit id="84afbc51b4cffb9fe60bc11408d20fc3c75207ff" translate="yes" xml:space="preserve">
          <source>Operator Strategy 2</source>
          <target state="translated">运营商战略2</target>
        </trans-unit>
        <trans-unit id="32970bd5b0dc670174fa5e603b715a1879812041" translate="yes" xml:space="preserve">
          <source>Operator Strategy 20</source>
          <target state="translated">经营者战略.20</target>
        </trans-unit>
        <trans-unit id="151eb78f3e104abebf3876024563a961e2605d2c" translate="yes" xml:space="preserve">
          <source>Operator Strategy 21</source>
          <target state="translated">经营者战略 21</target>
        </trans-unit>
        <trans-unit id="8684f3d138a78992a0b771dfbb423682326c65f8" translate="yes" xml:space="preserve">
          <source>Operator Strategy 22</source>
          <target state="translated">经营者战略.22</target>
        </trans-unit>
        <trans-unit id="71205740f8d9e86efeb0bd151835d85c0a6b3446" translate="yes" xml:space="preserve">
          <source>Operator Strategy 23</source>
          <target state="translated">经营者战略 23</target>
        </trans-unit>
        <trans-unit id="e0c4fa7b818964dd91a014987dc2cbf9d0f35f95" translate="yes" xml:space="preserve">
          <source>Operator Strategy 3</source>
          <target state="translated">运营商战略3</target>
        </trans-unit>
        <trans-unit id="c0698fd0a94af9d76a35b8038b94b51dc5055fa5" translate="yes" xml:space="preserve">
          <source>Operator Strategy 4</source>
          <target state="translated">经营者战略4</target>
        </trans-unit>
        <trans-unit id="7f6f8898348de22423f28b86e1d340d71a2b39e6" translate="yes" xml:space="preserve">
          <source>Operator Strategy 5</source>
          <target state="translated">经营者战略5</target>
        </trans-unit>
        <trans-unit id="3b8f252bde4d01adf4e5020737ab0f39249112c8" translate="yes" xml:space="preserve">
          <source>Operator Strategy 6, 18</source>
          <target state="translated">运营商战略 6、18</target>
        </trans-unit>
        <trans-unit id="63882822a5b9fac73c626ceb2fedd6c07953d3d2" translate="yes" xml:space="preserve">
          <source>Operator Strategy 7</source>
          <target state="translated">经营者战略 7</target>
        </trans-unit>
        <trans-unit id="614f640543a97c56dc41fc006e5e6df302593992" translate="yes" xml:space="preserve">
          <source>Operator Strategy 7, 13, 16, 24, 25</source>
          <target state="translated">经营者战略 7、13、16、24、25</target>
        </trans-unit>
        <trans-unit id="f5666e86d614f20d9c6c6d654b73870444a0a7b8" translate="yes" xml:space="preserve">
          <source>Operator Strategy 8, 14, 26, 27</source>
          <target state="translated">经营者战略 8、14、26、27</target>
        </trans-unit>
        <trans-unit id="6bd466b077248c905be85a30157069ea7d392f05" translate="yes" xml:space="preserve">
          <source>Operator Strategy 9</source>
          <target state="translated">经营者战略 9</target>
        </trans-unit>
        <trans-unit id="23a5e32675db7a6dae8947caf6f8b77d2fb419f2" translate="yes" xml:space="preserve">
          <source>Operator class member</source>
          <target state="translated">操作员类成员</target>
        </trans-unit>
        <trans-unit id="a154991f482d1ef020b50f829693f6a3e7645883" translate="yes" xml:space="preserve">
          <source>Operator classes are described at length in &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html&quot;&gt;Section 37.16&lt;/a&gt;.</source>
          <target state="translated">运算符类别在&lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html&quot;&gt;37.16节中&lt;/a&gt;进行了详细描述。</target>
        </trans-unit>
        <trans-unit id="c63c649d8246e4687f509dd0b4cd3e53d324b319" translate="yes" xml:space="preserve">
          <source>Operator classes are described at length in &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html&quot;&gt;Section 37.16&lt;/a&gt;.</source>
          <target state="translated">运算符类别在&lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html&quot;&gt;第37.16节中&lt;/a&gt;进行了详细描述。</target>
        </trans-unit>
        <trans-unit id="58080c4fb9795121bf1294991f50a6dd258005c4" translate="yes" xml:space="preserve">
          <source>Operator classes that implement completely different semantics are also possible, provided implementations of the four main support functions described above are written. Note that backwards compatibility across major releases is not guaranteed: for example, additional support functions might be required in later releases.</source>
          <target state="translated">实现完全不同语义的操作者类也是可能的,但前提是要编写上述四个主要支持函数的实现。请注意,不能保证各主要版本之间的向后兼容性:例如,在以后的版本中可能需要额外的支持函数。</target>
        </trans-unit>
        <trans-unit id="eb753b5f274e2276c93849eb8d4d017ef67b8b0d" translate="yes" xml:space="preserve">
          <source>Operator families are described at length in &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html&quot;&gt;Section 37.16&lt;/a&gt;.</source>
          <target state="translated">运营商系列在&lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html&quot;&gt;第37.16节中&lt;/a&gt;进行了详细描述。</target>
        </trans-unit>
        <trans-unit id="85e043feb1fde1f2ad0490d4b9f478c590c6ae0a" translate="yes" xml:space="preserve">
          <source>Operator families are described at length in &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html&quot;&gt;Section 37.16&lt;/a&gt;.</source>
          <target state="translated">运营商系列在&lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html&quot;&gt;第37.16节中&lt;/a&gt;进行了详细描述。</target>
        </trans-unit>
        <trans-unit id="089453e64460e24c4860d90b978d73331899e626" translate="yes" xml:space="preserve">
          <source>Operator family containing the operator class</source>
          <target state="translated">含有操作类的操作族</target>
        </trans-unit>
        <trans-unit id="d001f433bb040727266e2e45232ebf1b96c87507" translate="yes" xml:space="preserve">
          <source>Operator purpose, either &lt;code&gt;s&lt;/code&gt; for search or &lt;code&gt;o&lt;/code&gt; for ordering</source>
          <target state="translated">运营商的目的，无论是 &lt;code&gt;s&lt;/code&gt; 搜索或 &lt;code&gt;o&lt;/code&gt; 订货</target>
        </trans-unit>
        <trans-unit id="912efd8e18516ea9637e59e441f7f7a9add7dc7b" translate="yes" xml:space="preserve">
          <source>Operator strategy number</source>
          <target state="translated">运营商战略号</target>
        </trans-unit>
        <trans-unit id="2e8cb1b3b6dd7d5c36991fdde1327aa3fa525b70" translate="yes" xml:space="preserve">
          <source>Operator/Element</source>
          <target state="translated">Operator/Element</target>
        </trans-unit>
        <trans-unit id="2d08499adb61cbc2e5aa0edb02bd1f8b9de48e7f" translate="yes" xml:space="preserve">
          <source>Operator/Method</source>
          <target state="translated">Operator/Method</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="245cf7f12c2bf5a2fc5aaf31f347829fe389252a" translate="yes" xml:space="preserve">
          <source>Operators are represented by &lt;code&gt;oprname(lefttype,righttype)&lt;/code&gt;, writing the type names exactly as they appear in the &lt;code&gt;pg_operator.dat&lt;/code&gt; entry's &lt;code&gt;oprleft&lt;/code&gt; and &lt;code&gt;oprright&lt;/code&gt; fields. (Write &lt;code&gt;0&lt;/code&gt; for the omitted operand of a unary operator.)</source>
          <target state="translated">运算符由 &lt;code&gt;oprname(lefttype,righttype)&lt;/code&gt; 表示，其类型名称应与 &lt;code&gt;pg_operator.dat&lt;/code&gt; 条目的 &lt;code&gt;oprleft&lt;/code&gt; 和 &lt;code&gt;oprright&lt;/code&gt; 字段中出现的名称完全相同。（写 &lt;code&gt;0&lt;/code&gt; 为一元运算符的省略操作数）</target>
        </trans-unit>
        <trans-unit id="1f5c0ba13f00010cbbfefca8a52453ff0cb4b539" translate="yes" xml:space="preserve">
          <source>Optimality of the query plan</source>
          <target state="translated">查询计划的优化</target>
        </trans-unit>
        <trans-unit id="5b15e9cc0d575ead9ee77f9021833cc95443ec95" translate="yes" xml:space="preserve">
          <source>Optimizer</source>
          <target state="translated">Optimizer</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="30ea09691f79f4f3b53ede4678ab841460419294" translate="yes" xml:space="preserve">
          <source>Optional data-manipulation: compression, conversion to UTF-8, and/or conversion of line-endings.</source>
          <target state="translated">可选的数据处理:压缩,转换为UTF-8,和/或转换行尾。</target>
        </trans-unit>
        <trans-unit id="dda0500e72a6b8d9415eee2d2bd9c2b4bddc1e78" translate="yes" xml:space="preserve">
          <source>Optional key words. They have no effect.</source>
          <target state="translated">可选关键词。它们没有效果。</target>
        </trans-unit>
        <trans-unit id="be700c602b6a0f91e2d0a7efd9323b26ffbdc0e3" translate="yes" xml:space="preserve">
          <source>Optional parameters can be written in any order, not only the order illustrated above.</source>
          <target state="translated">可选参数可以按任何顺序写,而不仅仅是上面说明的顺序。</target>
        </trans-unit>
        <trans-unit id="a1ddbf1be07fc433b776138e1087ccfcfc7bb295" translate="yes" xml:space="preserve">
          <source>Optional planner support function for this function (see &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-optimization.html&quot;&gt;Section 37.11&lt;/a&gt;)</source>
          <target state="translated">此功能的可选计划程序支持功能（请参阅&lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-optimization.html&quot;&gt;第37.11节&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="a2e97703c74b74734bc3d703b229e2fffbfe125d" translate="yes" xml:space="preserve">
          <source>Optional planner support function for this function (see &lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc-optimization.html&quot;&gt;Section 37.11&lt;/a&gt;)</source>
          <target state="translated">此功能的可选计划程序支持功能（请参阅&lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc-optimization.html&quot;&gt;第37.11节&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="2fd16c799a777633af7110bcb3365acd2d2f9b6f" translate="yes" xml:space="preserve">
          <source>Optional server type, potentially useful to foreign-data wrappers.</source>
          <target state="translated">可选的服务器类型,可能对外国数据包装器有用。</target>
        </trans-unit>
        <trans-unit id="23e65fc5f0e4b9be1c8551d9648425aede4fa734" translate="yes" xml:space="preserve">
          <source>Optional server version, potentially useful to foreign-data wrappers.</source>
          <target state="translated">可选的服务器版本,可能对外国数据包装器有用。</target>
        </trans-unit>
        <trans-unit id="8080182e2b9ea49c9096dd85079cd9c704e16363" translate="yes" xml:space="preserve">
          <source>Optionally one can add the key word &lt;code&gt;ASC&lt;/code&gt; (ascending) or &lt;code&gt;DESC&lt;/code&gt; (descending) after any expression in the &lt;code&gt;ORDER BY&lt;/code&gt; clause. If not specified, &lt;code&gt;ASC&lt;/code&gt; is assumed by default. Alternatively, a specific ordering operator name can be specified in the &lt;code&gt;USING&lt;/code&gt; clause. An ordering operator must be a less-than or greater-than member of some B-tree operator family. &lt;code&gt;ASC&lt;/code&gt; is usually equivalent to &lt;code&gt;USING &amp;lt;&lt;/code&gt; and &lt;code&gt;DESC&lt;/code&gt; is usually equivalent to &lt;code&gt;USING &amp;gt;&lt;/code&gt;. (But the creator of a user-defined data type can define exactly what the default sort ordering is, and it might correspond to operators with other names.)</source>
          <target state="translated">可以选择在 &lt;code&gt;ORDER BY&lt;/code&gt; 子句中的任何表达式之后添加关键字 &lt;code&gt;ASC&lt;/code&gt; （升序）或 &lt;code&gt;DESC&lt;/code&gt; （降序）。如果未指定，则默认为 &lt;code&gt;ASC&lt;/code&gt; 。或者，可以在 &lt;code&gt;USING&lt;/code&gt; 子句中指定特定的排序运算符名称。订购运算符必须是小于或大于某些B树运算符系列的成员。 &lt;code&gt;ASC&lt;/code&gt; 通常等效于 &lt;code&gt;USING &amp;lt;&lt;/code&gt; ,而 &lt;code&gt;DESC&lt;/code&gt; 通常等效于 &lt;code&gt;USING &amp;gt;&lt;/code&gt; 。 （但是，用户定义的数据类型的创建者可以准确定义默认的排序顺序，并且它可能与其他名称的运算符相对应。）</target>
        </trans-unit>
        <trans-unit id="25a8ce77c093de9028c29694dad75d1d0b46f922" translate="yes" xml:space="preserve">
          <source>Optionally specifies an existing replication slot to be used when connecting to the sending server via streaming replication to control resource removal on the upstream node (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Section 26.2.6&lt;/a&gt;). This parameter can only be set at server start. This setting has no effect if &lt;code&gt;primary_conninfo&lt;/code&gt; is not set.</source>
          <target state="translated">（可选）指定在通过流复制连接到发送服务器以控制上游节点上的资源删除时要使用的现有复制插槽（请参阅&lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;第26.2.6节&lt;/a&gt;）。该参数只能在服务器启动时设置。如果未设置 &lt;code&gt;primary_conninfo&lt;/code&gt; ,则此设置无效。</target>
        </trans-unit>
        <trans-unit id="96c92ada09a34799bdf814b9347c979dbca22b37" translate="yes" xml:space="preserve">
          <source>Optionally specifies an existing replication slot to be used when connecting to the sending server via streaming replication to control resource removal on the upstream node (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Section 26.2.6&lt;/a&gt;). This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. If this parameter is changed while the WAL receiver process is running, that process is signaled to shut down and expected to restart with the new setting. This setting has no effect if &lt;code&gt;primary_conninfo&lt;/code&gt; is not set or the server is not in standby mode.</source>
          <target state="translated">（可选）指定在通过流复制连接到发送服务器以控制上游节点上的资源删除时要使用的现有复制插槽（请参阅&lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;第26.2.6节&lt;/a&gt;）。此参数只能在 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件或服务器命令行中设置。如果在运行WAL接收器进程时更改了此参数，则该进程将发出关闭信号，并有望使用新设置重新启动。如果未设置 &lt;code&gt;primary_conninfo&lt;/code&gt; 或服务器未处于待机模式，则此设置无效。</target>
        </trans-unit>
        <trans-unit id="a9e1a54cb19d7f45ef6c62130cbc0ebd54aaaeaa" translate="yes" xml:space="preserve">
          <source>Optionally, &lt;code&gt;CREATE SCHEMA&lt;/code&gt; can include subcommands to create objects within the new schema. The subcommands are treated essentially the same as separate commands issued after creating the schema, except that if the &lt;code&gt;AUTHORIZATION&lt;/code&gt; clause is used, all the created objects will be owned by that user.</source>
          <target state="translated">（可选） &lt;code&gt;CREATE SCHEMA&lt;/code&gt; 可以包含子命令以在新模式中创建对象。子命令与创建模式后发出的单独命令基本相同，不同之处在于，如果使用 &lt;code&gt;AUTHORIZATION&lt;/code&gt; 子句，则所有创建的对象将归该用户所有。</target>
        </trans-unit>
        <trans-unit id="f83f2be43194c5b280c1fd15656c0623344c2afd" translate="yes" xml:space="preserve">
          <source>Optionally, &lt;code&gt;GLOBAL&lt;/code&gt; or &lt;code&gt;LOCAL&lt;/code&gt; can be written before &lt;code&gt;TEMPORARY&lt;/code&gt; or &lt;code&gt;TEMP&lt;/code&gt;. This presently makes no difference in PostgreSQL and is deprecated; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-COMPATIBILITY&quot;&gt;Compatibility&lt;/a&gt; below.</source>
          <target state="translated">可以选择将 &lt;code&gt;GLOBAL&lt;/code&gt; 或 &lt;code&gt;LOCAL&lt;/code&gt; 写入 &lt;code&gt;TEMPORARY&lt;/code&gt; 或 &lt;code&gt;TEMP&lt;/code&gt; 之前。目前，这在PostgreSQL中没有区别，不建议使用；请参阅下面的&lt;a href=&quot;sql-createtable#SQL-CREATETABLE-COMPATIBILITY&quot;&gt;兼容性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fb213cf60cad5118b118598f7c3788d5e4cf965c" translate="yes" xml:space="preserve">
          <source>Optionally, &lt;code&gt;GLOBAL&lt;/code&gt; or &lt;code&gt;LOCAL&lt;/code&gt; can be written before &lt;code&gt;TEMPORARY&lt;/code&gt; or &lt;code&gt;TEMP&lt;/code&gt;. This presently makes no difference in PostgreSQL and is deprecated; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-COMPATIBILITY&quot;&gt;Compatibility&lt;/a&gt;.</source>
          <target state="translated">可以选择将 &lt;code&gt;GLOBAL&lt;/code&gt; 或 &lt;code&gt;LOCAL&lt;/code&gt; 写入 &lt;code&gt;TEMPORARY&lt;/code&gt; 或 &lt;code&gt;TEMP&lt;/code&gt; 之前。目前，这在PostgreSQL中没有区别，不建议使用；请参阅&lt;a href=&quot;sql-createtable#SQL-CREATETABLE-COMPATIBILITY&quot;&gt;兼容性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a86b4b1bbae5190193648607744f965bba9ad7dc" translate="yes" xml:space="preserve">
          <source>Optionally, a B-tree operator family may provide &lt;code&gt;options&lt;/code&gt; (&amp;ldquo;operator class specific options&amp;rdquo;) support functions, registered under support function number 5. These functions define a set of user-visible parameters that control operator class behavior.</source>
          <target state="translated">可选地，B树操作员家族可以提供在支持功能编号5下注册的 &lt;code&gt;options&lt;/code&gt; （&amp;ldquo;特定于操作员类别的选项&amp;rdquo;）支持功能。这些功能定义了一组控制操作员类别行为的用户可见参数。</target>
        </trans-unit>
        <trans-unit id="8bbcd7d9ec5c4025e28ab09de1e1dc49ba23c52a" translate="yes" xml:space="preserve">
          <source>Optionally, a btree operator family may provide &lt;code&gt;equalimage&lt;/code&gt; (&amp;ldquo;equality implies image equality&amp;rdquo;) support functions, registered under support function number 4. These functions allow the core code to determine when it is safe to apply the btree deduplication optimization. Currently, &lt;code&gt;equalimage&lt;/code&gt; functions are only called when building or rebuilding an index.</source>
          <target state="translated">可选地，btree运算符家族可以提供在支持功能编号4下注册的 &lt;code&gt;equalimage&lt;/code&gt; （&amp;ldquo;相等意味着图像相等&amp;rdquo;）支持功能。这些功能允许核心代码确定何时安全地应用btree重复数据删除优化。当前，仅在建立或重建索引时才调用 &lt;code&gt;equalimage&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="38ce22db7991e92cf37c1757c548b3362a7ca1aa" translate="yes" xml:space="preserve">
          <source>Optionally, a btree operator family may provide &lt;em&gt;in_range&lt;/em&gt; support function(s), registered under support function number 3. These are not used during btree index operations; rather, they extend the semantics of the operator family so that it can support window clauses containing the &lt;code&gt;RANGE&lt;/code&gt;&lt;code&gt;offset&lt;/code&gt;&lt;code&gt;PRECEDING&lt;/code&gt; and &lt;code&gt;RANGE&lt;/code&gt;&lt;code&gt;offset&lt;/code&gt;&lt;code&gt;FOLLOWING&lt;/code&gt; frame bound types (see &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Section 4.2.8&lt;/a&gt;). Fundamentally, the extra information provided is how to add or subtract an &lt;code&gt;offset&lt;/code&gt; value in a way that is compatible with the family's data ordering.</source>
          <target state="translated">可选地，btree运算符家族可以提供在支持功能编号3下注册的&lt;em&gt;in_range&lt;/em&gt;支持功能。在btree索引操作过程中不使用这些功能。相反，它们扩展了运算符系列的语义，以便它可以支持包含 &lt;code&gt;RANGE&lt;/code&gt; &lt;code&gt;offset&lt;/code&gt; &lt;code&gt;PRECEDING&lt;/code&gt; 和 &lt;code&gt;RANGE&lt;/code&gt; &lt;code&gt;offset&lt;/code&gt; &lt;code&gt;FOLLOWING&lt;/code&gt; 框架绑定类型的窗口子句（请参见&lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;4.2.8节&lt;/a&gt;）。从根本上讲，提供的额外信息是如何以与系列的数据排序兼容的方式添加或减去 &lt;code&gt;offset&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="478c790850d122e707e8f7883dedaa4fc2abbd82" translate="yes" xml:space="preserve">
          <source>Optionally, a btree operator family may provide &lt;em&gt;sort support&lt;/em&gt; function(s), registered under support function number 2. These functions allow implementing comparisons for sorting purposes in a more efficient way than naively calling the comparison support function. The APIs involved in this are defined in &lt;code&gt;src/include/utils/sortsupport.h&lt;/code&gt;.</source>
          <target state="translated">可选地，操作者B树家族可提供&lt;em&gt;排序支持&lt;/em&gt;（多个）功能，下支持功能编号2.这些功能允许执行比较用于以更有效的方式比天真地调用比较支持功能排序目的注册。涉及的API在 &lt;code&gt;src/include/utils/sortsupport.h&lt;/code&gt; 中定义。</target>
        </trans-unit>
        <trans-unit id="8d0b1d8f44651eff9c08018d57dc26658e0d79ec" translate="yes" xml:space="preserve">
          <source>Optionally, an operator class for GIN can supply the following method:</source>
          <target state="translated">可选地,GIN的操作类可以提供以下方法。</target>
        </trans-unit>
        <trans-unit id="555fcafecaac1b7a79da77571a044c4fcd960ef4" translate="yes" xml:space="preserve">
          <source>Optionally, integer &lt;em&gt;positions&lt;/em&gt; can be attached to lexemes:</source>
          <target state="translated">可以选择将整数&lt;em&gt;位置&lt;/em&gt;附加到词素上：</target>
        </trans-unit>
        <trans-unit id="ba2c90dde0ab03dd101be9fe39552cd35bcc19fc" translate="yes" xml:space="preserve">
          <source>Optionally, lexemes in a &lt;code&gt;tsquery&lt;/code&gt; can be labeled with one or more weight letters, which restricts them to match only &lt;code&gt;tsvector&lt;/code&gt; lexemes with one of those weights:</source>
          <target state="translated">可选地，可以使用一个或多个权重字母来标记 &lt;code&gt;tsquery&lt;/code&gt; 中的词素，这限制了它们仅匹配具有这些权重之一的 &lt;code&gt;tsvector&lt;/code&gt; 词素：</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="bfb2e74b331377cdefa56e8103510af4757e8e75" translate="yes" xml:space="preserve">
          <source>Options are named to be similar to GnuPG. An option's value should be given after an equal sign; separate options from each other with commas. For example:</source>
          <target state="translated">选项的命名与 GnuPG 相似。一个选项的值应该在等号之后给出;选项之间用逗号分开。例如,选项之间用逗号隔开。</target>
        </trans-unit>
        <trans-unit id="01c5d645df020042965df6656c79fbcb52302c6d" translate="yes" xml:space="preserve">
          <source>Options for Single-User Mode</source>
          <target state="translated">单用户模式的选项</target>
        </trans-unit>
        <trans-unit id="2cc6e913a91a4d81d0ee2eacb713152c147c5122" translate="yes" xml:space="preserve">
          <source>Options for Windows</source>
          <target state="translated">Windows的选项</target>
        </trans-unit>
        <trans-unit id="0807432116c5005f30d6e9cc2d8f5760b3400db2" translate="yes" xml:space="preserve">
          <source>Options specified for authentication method, if any</source>
          <target state="translated">为认证方法指定的选项(如有)</target>
        </trans-unit>
        <trans-unit id="2ba952bec3ffacb85d251e04c62c8891e8cc4022" translate="yes" xml:space="preserve">
          <source>Options to be associated with the new foreign table or one of its columns. The allowed option names and values are specific to each foreign data wrapper and are validated using the foreign-data wrapper's validator function. Duplicate option names are not allowed (although it's OK for a table option and a column option to have the same name).</source>
          <target state="translated">要与新的外表或其某一列关联的选项。允许的选项名称和值是每个外数据包装器所特有的,并使用外数据包装器的验证器函数进行验证。不允许有重复的选项名(虽然一个表选项和一个列选项有相同的名称是可以的)。</target>
        </trans-unit>
        <trans-unit id="ea0cc8f54bce88ccfd10bba527220a016a032c30" translate="yes" xml:space="preserve">
          <source>Options to be used during the import. The allowed option names and values are specific to each foreign data wrapper.</source>
          <target state="translated">在导入过程中要使用的选项。允许的选项名称和值是针对每个外国数据封装器的。</target>
        </trans-unit>
        <trans-unit id="9a0c5ecf28319808109742741597da1a162506e4" translate="yes" xml:space="preserve">
          <source>Or, if no array size is to be specified:</source>
          <target state="translated">或者,如果没有指定数组大小。</target>
        </trans-unit>
        <trans-unit id="57f20b026b33a5f996b1722a8963058f7f139ed9" translate="yes" xml:space="preserve">
          <source>Order in which the entries are processed (1..&lt;code&gt;n&lt;/code&gt;)</source>
          <target state="translated">条目处理的顺序（1 .. &lt;code&gt;n&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="6b71865e60556421edb3dc5a27a33115f8d23b2c" translate="yes" xml:space="preserve">
          <source>Order in which to consult this entry (lower &lt;code&gt;mapseqno&lt;/code&gt;s first)</source>
          <target state="translated">查阅该条目的顺序（先 &lt;code&gt;mapseqno&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="9032c5927654c6b139387affcba7ab64e16f3699" translate="yes" xml:space="preserve">
          <source>Ordering Operators</source>
          <target state="translated">订货员</target>
        </trans-unit>
        <trans-unit id="bb496dd08aebe7c50e13b0f636e3490f9e72e352" translate="yes" xml:space="preserve">
          <source>Ordinarily a cast must have different source and target data types. However, it is allowed to declare a cast with identical source and target types if it has a cast implementation function with more than one argument. This is used to represent type-specific length coercion functions in the system catalogs. The named function is used to coerce a value of the type to the type modifier value given by its second argument.</source>
          <target state="translated">通常情况下,一个cast必须有不同的源和目标数据类型。但是,如果一个投种有一个以上的参数的投种实现函数,则允许声明它具有相同的源和目标类型。这在系统目录中用来表示特定类型的长度胁迫函数。被命名的函数用于将类型的一个值胁迫到其第二个参数给出的类型修饰值。</target>
        </trans-unit>
        <trans-unit id="23ae1f89c4cafddef64330187ff525b64ad51110" translate="yes" xml:space="preserve">
          <source>Ordinarily, PostgreSQL functions are expected to be true functions that do not modify their input values. However, an aggregate transition function, &lt;em&gt;when used in the context of an aggregate&lt;/em&gt;, is allowed to cheat and modify its transition-state argument in place. This can provide substantial performance benefits compared to making a fresh copy of the transition state each time.</source>
          <target state="translated">通常，PostgreSQL函数应该是不修改其输入值的真实函数。但是，&lt;em&gt;当在聚合上下文中使用&lt;/em&gt;聚合转换函数&lt;em&gt;时&lt;/em&gt;，允许&lt;em&gt;该&lt;/em&gt;函数作弊并在适当位置修改其转换状态参数。与每次重新制作过渡状态副本相比，这可以提供显着的性能优势。</target>
        </trans-unit>
        <trans-unit id="7c0095250f58080cd4f7b0263a9f790d13029e21" translate="yes" xml:space="preserve">
          <source>Ordinarily, if a date/time string is syntactically valid but contains out-of-range field values, an error will be thrown. For example, input specifying the 31st of February will be rejected.</source>
          <target state="translated">通常情况下,如果一个日期/时间字符串在语法上是有效的,但包含超出范围的字段值,就会抛出一个错误。例如,指定2月31日的输入将被拒绝。</target>
        </trans-unit>
        <trans-unit id="d469c00e9517d285e5591f4a6f0cfdb929fc4475" translate="yes" xml:space="preserve">
          <source>Ordinarily, only the object's owner (or a superuser) can grant or revoke privileges on an object. However, it is possible to grant a privilege &amp;ldquo;with grant option&amp;rdquo;, which gives the recipient the right to grant it in turn to others. If the grant option is subsequently revoked then all who received the privilege from that recipient (directly or through a chain of grants) will lose the privilege. For details see the &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; and &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; reference pages.</source>
          <target state="translated">通常，只有对象的所有者（或超级用户）才能授予或撤销对象的特权。但是，可以通过&amp;ldquo;具有授予选项&amp;rdquo;来授予特权，这使接收者有权依次将其授予其他人。如果随后取消了授予选项，则所有从该接收者那里（直接或通过一系列授予）获得特权的人都将失去该特权。有关详细信息，请参见&lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt;和&lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt;参考页。</target>
        </trans-unit>
        <trans-unit id="1198b431d5751f4a8f2d46d9894c80568e5c546c" translate="yes" xml:space="preserve">
          <source>Ordinarily, the input rows are fed to the aggregate function in an unspecified order. In many cases this does not matter; for example, &lt;code&gt;min&lt;/code&gt; produces the same result no matter what order it receives the inputs in. However, some aggregate functions (such as &lt;code&gt;array_agg&lt;/code&gt; and &lt;code&gt;string_agg&lt;/code&gt;) produce results that depend on the ordering of the input rows. When using such an aggregate, the optional &lt;code&gt;order_by_clause&lt;/code&gt; can be used to specify the desired ordering. The &lt;code&gt;order_by_clause&lt;/code&gt; has the same syntax as for a query-level &lt;code&gt;ORDER BY&lt;/code&gt; clause, as described in &lt;a href=&quot;queries-order&quot;&gt;Section 7.5&lt;/a&gt;, except that its expressions are always just expressions and cannot be output-column names or numbers. For example:</source>
          <target state="translated">通常，输入行以未指定的顺序被馈送到聚合函数。在许多情况下，这无关紧要；例如，无论 &lt;code&gt;min&lt;/code&gt; 接收输入的顺序如何，min都会产生相同的结果。但是，某些聚合函数（例如 &lt;code&gt;array_agg&lt;/code&gt; 和 &lt;code&gt;string_agg&lt;/code&gt; ）产生的结果取决于输入行的顺序。使用这种聚合时，可以使用可选的 &lt;code&gt;order_by_clause&lt;/code&gt; 指定所需的排序。如&lt;a href=&quot;queries-order&quot;&gt;7.5节&lt;/a&gt;所述， &lt;code&gt;order_by_clause&lt;/code&gt; 的语法与查询级 &lt;code&gt;ORDER BY&lt;/code&gt; 子句的语法相同。，除了它的表达式始终只是表达式而不能是输出列名称或数字。例如：</target>
        </trans-unit>
        <trans-unit id="2a1751155e24c2b7f81369ad2aa106588546c4f5" translate="yes" xml:space="preserve">
          <source>Ordinarily, the user must have the PostgreSQL superuser privilege to register a new language. However, the owner of a database can register a new language within that database if the language is listed in the &lt;code&gt;pg_pltemplate&lt;/code&gt; catalog and is marked as allowed to be created by database owners (&lt;code&gt;tmpldbacreate&lt;/code&gt; is true). The default is that trusted languages can be created by database owners, but this can be adjusted by superusers by modifying the contents of &lt;code&gt;pg_pltemplate&lt;/code&gt;. The creator of a language becomes its owner and can later drop it, rename it, or assign it to a new owner.</source>
          <target state="translated">通常，用户必须具有PostgreSQL超级用户特权才能注册新语言。但是，如果 &lt;code&gt;pg_pltemplate&lt;/code&gt; 目录中列出了该语言并将其标记为允许数据库所有者创建，则该数据库的所有者可以在该数据库中注册新语言（ &lt;code&gt;tmpldbacreate&lt;/code&gt; 为true）。缺省值是数据库所有者可以创建受信任的语言，但是超级用户可以通过修改 &lt;code&gt;pg_pltemplate&lt;/code&gt; 的内容来调整信任的语言。语言的创建者成为其所有者，以后可以将其删除，重命名或将其分配给新的所有者。</target>
        </trans-unit>
        <trans-unit id="d31ebd6359b908a6b08b46621a9edc9ed8848a84" translate="yes" xml:space="preserve">
          <source>Ordinarily, there will be only a single WAL range. However, if a backup is taken from a standby which switches timelines during the backup due to an upstream promotion, it is possible for multiple ranges to be present, each with a different timeline. There will never be multiple WAL ranges present for the same timeline.</source>
          <target state="translated">通常情况下,只有一个WAL范围。但是,如果备份来自备用,而备用在备份期间由于上游升级而切换时间线,则可能存在多个范围,每个范围有不同的时间线。同一时间线永远不会有多个WAL范围存在。</target>
        </trans-unit>
        <trans-unit id="49558321bc55879a8f79a252d13bd83f15cac2ec" translate="yes" xml:space="preserve">
          <source>Ordinary comparison operators yield null (signifying &amp;ldquo;unknown&amp;rdquo;), not true or false, when either input is null. For example, &lt;code&gt;7 = NULL&lt;/code&gt; yields null, as does &lt;code&gt;7 &amp;lt;&amp;gt; NULL&lt;/code&gt;. When this behavior is not suitable, use the &lt;code&gt;IS [ NOT ] DISTINCT FROM&lt;/code&gt; predicates:</source>
          <target state="translated">当任一输入为null时，普通比较运算符将生成null（表示&amp;ldquo;未知&amp;rdquo;），而不是true或false。例如， &lt;code&gt;7 = NULL&lt;/code&gt; 和 &lt;code&gt;7 &amp;lt;&amp;gt; NULL&lt;/code&gt; 产生null 。如果此行为不合适，请使用 &lt;code&gt;IS [ NOT ] DISTINCT FROM&lt;/code&gt; 谓词：</target>
        </trans-unit>
        <trans-unit id="1f51e9682012527e72ed015353424811e9ad8a4d" translate="yes" xml:space="preserve">
          <source>Ordinary text is allowed in &lt;code&gt;to_char&lt;/code&gt; templates and will be output literally. You can put a substring in double quotes to force it to be interpreted as literal text even if it contains template patterns. For example, in &lt;code&gt;'&quot;Hello Year &quot;YYYY'&lt;/code&gt;, the &lt;code&gt;YYYY&lt;/code&gt; will be replaced by the year data, but the single &lt;code&gt;Y&lt;/code&gt; in &lt;code&gt;Year&lt;/code&gt; will not be. In &lt;code&gt;to_date&lt;/code&gt;, &lt;code&gt;to_number&lt;/code&gt;, and &lt;code&gt;to_timestamp&lt;/code&gt;, literal text and double-quoted strings result in skipping the number of characters contained in the string; for example &lt;code&gt;&quot;XX&quot;&lt;/code&gt; skips two input characters (whether or not they are &lt;code&gt;XX&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;to_char&lt;/code&gt; 模板中允许使用普通文本，并将按字面输出。您可以将子字符串放在双引号中，以强制将其解释为原义文本，即使它包含模板模式也是如此。例如，在 &lt;code&gt;'&quot;Hello Year &quot;YYYY'&lt;/code&gt; ，则 &lt;code&gt;YYYY&lt;/code&gt; 将被年份数据代替，但是单 &lt;code&gt;Y&lt;/code&gt; 在 &lt;code&gt;Year&lt;/code&gt; 不会。在 &lt;code&gt;to_date&lt;/code&gt; ， &lt;code&gt;to_number&lt;/code&gt; 和 &lt;code&gt;to_timestamp&lt;/code&gt; 中，文字文本和双引号字符串导致跳过字符串中包含的字符数；例如 &lt;code&gt;&quot;XX&quot;&lt;/code&gt; 跳过两个输入字符（无论它们是否为 &lt;code&gt;XX&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="47deb2333130b0b71a558b913d84907ec715a39c" translate="yes" xml:space="preserve">
          <source>Original UNIX crypt</source>
          <target state="translated">原始UNIX密码</target>
        </trans-unit>
        <trans-unit id="728421f1a8e764e582012583a50320fee679ab3e" translate="yes" xml:space="preserve">
          <source>Original author: Gene Selkov, Jr. &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:selkovjr@mcs.anl.gov&quot;&gt;selkovjr@mcs.anl.gov&lt;/a&gt;&amp;gt;&lt;/code&gt;, Mathematics and Computer Science Division, Argonne National Laboratory.</source>
          <target state="translated">原始作者：Gene Selkov，Jr. &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:selkovjr@mcs.anl.gov&quot;&gt;selkovjr@mcs.anl.gov&lt;/a&gt;&amp;gt;&lt;/code&gt; ，阿贡国家实验室数学和计算机科学系。</target>
        </trans-unit>
        <trans-unit id="15c3cbc7d90ec04ca02171128016ae7aa1d06c07" translate="yes" xml:space="preserve">
          <source>Original version by Mark Kirkwood &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:markir@paradise.net.nz&quot;&gt;markir@paradise.net.nz&lt;/a&gt;&amp;gt;&lt;/code&gt;. Rewritten in version 8.4 to suit new FSM implementation by Heikki Linnakangas &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:heikki@enterprisedb.com&quot;&gt;heikki@enterprisedb.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Mark Kirkwood的原始版本 &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:markir@paradise.net.nz&quot;&gt;markir@paradise.net.nz&lt;/a&gt;&amp;gt;&lt;/code&gt; 。Heikki Linnakangas在版本8.4中进行了重写，以适应新的FSM实施 &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:heikki@enterprisedb.com&quot;&gt;heikki@enterprisedb.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c3f5ca5b9a803aee38134c4fbdc2dd67fcb8f9e" translate="yes" xml:space="preserve">
          <source>Other clients and libraries might provide their own mechanisms, via the shell or otherwise, that allow the user to alter session settings without direct use of SQL commands.</source>
          <target state="translated">其他客户端和库可能会提供自己的机制,通过shell或其他方式,允许用户在不直接使用SQL命令的情况下改变会话设置。</target>
        </trans-unit>
        <trans-unit id="1b025a6555e41ac8947f0005aa2f96a2fbcedc20" translate="yes" xml:space="preserve">
          <source>Other database systems might advance these values more frequently.</source>
          <target state="translated">其他数据库系统可能会更频繁地推进这些值。</target>
        </trans-unit>
        <trans-unit id="16dab4fb6d3b76123e52d90af3ba7c8bf6cdec38" translate="yes" xml:space="preserve">
          <source>Other dependency flavors might be needed in future.</source>
          <target state="translated">未来可能还需要其他的依赖性口味。</target>
        </trans-unit>
        <trans-unit id="d54e9e4d1cedbb61d73910e1c0331a6b34276e3c" translate="yes" xml:space="preserve">
          <source>Other dependency flavors might be needed in future. Note in particular that the current definition only supports roles as referenced objects.</source>
          <target state="translated">未来可能还需要其他的依赖性样式。请特别注意,当前的定义只支持作为引用对象的角色。</target>
        </trans-unit>
        <trans-unit id="b090b2cc862f6eb58c39020ceea8daeedfe6f7b3" translate="yes" xml:space="preserve">
          <source>Other digest algorithms</source>
          <target state="translated">其他摘要算法</target>
        </trans-unit>
        <trans-unit id="dd97a9c89af824879fb23956d987ca3355ff4cc8" translate="yes" xml:space="preserve">
          <source>Other libraries can also be preloaded. By preloading a shared library, the library startup time is avoided when the library is first used. However, the time to start each new server process might increase slightly, even if that process never uses the library. So this parameter is recommended only for libraries that will be used in most sessions. Also, changing this parameter requires a server restart, so this is not the right setting to use for short-term debugging tasks, say. Use &lt;a href=&quot;runtime-config-client#GUC-SESSION-PRELOAD-LIBRARIES&quot;&gt;session_preload_libraries&lt;/a&gt; for that instead.</source>
          <target state="translated">也可以预加载其他库。通过预加载共享库，可以避免首次使用该库时的库启动时间。但是，启动每个新服务器进程的时间可能会略有增加，即使该进程从不使用该库也是如此。因此，仅对于将在大多数会话中使用的库，建议使用此参数。另外，更改此参数需要重新启动服务器，因此，这不是用于短期调试任务的正确设置。请改用&lt;a href=&quot;runtime-config-client#GUC-SESSION-PRELOAD-LIBRARIES&quot;&gt;session_preload_libraries&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4c67ab500e2007fcfd325e1fcf258d410b75fddd" translate="yes" xml:space="preserve">
          <source>Other notes for &lt;code&gt;log_min_duration_statement&lt;/code&gt; apply also to this setting.</source>
          <target state="translated">&lt;code&gt;log_min_duration_statement&lt;/code&gt; 的其他说明也适用于此设置。</target>
        </trans-unit>
        <trans-unit id="f8b92deff69f1b0201e91466736d1490cd0ff7c6" translate="yes" xml:space="preserve">
          <source>Other object types, such as &lt;a href=&quot;glossary#GLOSSARY-ROLE&quot;&gt;roles&lt;/a&gt;, &lt;a href=&quot;glossary#GLOSSARY-TABLESPACE&quot;&gt;tablespaces&lt;/a&gt;, replication origins, subscriptions for logical replication, and databases themselves are not local SQL objects since they exist entirely outside of any specific database; they are called &lt;em&gt;global objects&lt;/em&gt;. The names of such objects are enforced to be unique within the whole database cluster.</source>
          <target state="translated">其他对象类型（例如&lt;a href=&quot;glossary#GLOSSARY-ROLE&quot;&gt;角色&lt;/a&gt;，&lt;a href=&quot;glossary#GLOSSARY-TABLESPACE&quot;&gt;表空间&lt;/a&gt;，复制源，逻辑复制的预订）和数据库本身不是本地SQL对象，因为它们完全存在于任何特定数据库的外部；它们被称为&lt;em&gt;全局对象&lt;/em&gt;。此类对象的名称在整个数据库群集中被强制为唯一。</target>
        </trans-unit>
        <trans-unit id="8b6d149d1176a026cafb96a0f82667c8ba54a10c" translate="yes" xml:space="preserve">
          <source>Other options are also available:</source>
          <target state="translated">也有其他的选择。</target>
        </trans-unit>
        <trans-unit id="599ffbd6e95e9102a19874cfc765e0666e6a5f25" translate="yes" xml:space="preserve">
          <source>Other options:</source>
          <target state="translated">其他选择:</target>
        </trans-unit>
        <trans-unit id="c97d8649180973af39b8407abdf8e46bf80d94a0" translate="yes" xml:space="preserve">
          <source>Other punctuation is ignored. So like &lt;code&gt;plainto_tsquery&lt;/code&gt; and &lt;code&gt;phraseto_tsquery&lt;/code&gt;, the &lt;code&gt;websearch_to_tsquery&lt;/code&gt; function will not recognize &lt;code&gt;tsquery&lt;/code&gt; operators, weight labels, or prefix-match labels in its input.</source>
          <target state="translated">其他标点符号将被忽略。因此，像 &lt;code&gt;plainto_tsquery&lt;/code&gt; 和 &lt;code&gt;phraseto_tsquery&lt;/code&gt; 一样， &lt;code&gt;websearch_to_tsquery&lt;/code&gt; 函数将无法在其输入中识别 &lt;code&gt;tsquery&lt;/code&gt; 运算符，权重标签或前缀匹配标签。</target>
        </trans-unit>
        <trans-unit id="da25b0d9d5dc45c67ed8cb3f27503780b4aa4443" translate="yes" xml:space="preserve">
          <source>Other recommended kernel setting changes for database servers which will have a large number of connections are:</source>
          <target state="translated">对于将有大量连接的数据库服务器,其他推荐的内核设置更改有:。</target>
        </trans-unit>
        <trans-unit id="3903dba9afe98748981ae8bb62ee1e14b5b5b0bf" translate="yes" xml:space="preserve">
          <source>Other scan types, such as scans of non-btree indexes, may support parallel scans in the future.</source>
          <target state="translated">其他扫描类型,如非树索引的扫描,将来可能会支持并行扫描。</target>
        </trans-unit>
        <trans-unit id="c88c65d71407192da2177c969f1b4c3e1b24c5ec" translate="yes" xml:space="preserve">
          <source>Other systems may only allow setting the time source on boot. On older Linux systems the &quot;clock&quot; kernel setting is the only way to make this sort of change. And even on some more recent ones, the only option you'll see for a clock source is &quot;jiffies&quot;. Jiffies are the older Linux software clock implementation, which can have good resolution when it's backed by fast enough timing hardware, as in this example:</source>
          <target state="translated">其他系统可能只允许在启动时设置时间源。在旧的Linux系统中,&quot;clock &quot;内核设置是进行这种改变的唯一方法。甚至在一些最新的系统中,你会看到时钟源的唯一选项是 &quot;jiffies&quot;。Jiffies是较老的Linux软件时钟实现,当它有足够快的时序硬件支持时,可以有很好的分辨率,就像这个例子一样。</target>
        </trans-unit>
        <trans-unit id="4a2d21cbb1de6f88a1dcf3d541f364a9e95c1127" translate="yes" xml:space="preserve">
          <source>Other than configuration of the negotiation behavior, GSSAPI encryption requires no setup beyond that which is necessary for GSSAPI authentication. (For more information on configuring that, see &lt;a href=&quot;gssapi-auth&quot;&gt;Section 20.6&lt;/a&gt;.)</source>
          <target state="translated">除了协商行为的配置外，GSSAPI加密不需要进行任何其他设置，而无需进行GSSAPI身份验证。（有关配置的更多信息，请参见&lt;a href=&quot;gssapi-auth&quot;&gt;第20.6节&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="d21779594b1e9934ec89f12215df7e04fc45898b" translate="yes" xml:space="preserve">
          <source>Other ways of looking at the statistics can be set up by writing queries that use the same underlying statistics access functions used by the standard views shown above. For details such as the functions' names, consult the definitions of the standard views. (For example, in psql you could issue &lt;code&gt;\d+ pg_stat_activity&lt;/code&gt;.) The access functions for per-database statistics take a database OID as an argument to identify which database to report on. The per-table and per-index functions take a table or index OID. The functions for per-function statistics take a function OID. Note that only tables, indexes, and functions in the current database can be seen with these functions.</source>
          <target state="translated">可以通过编写查询来建立查看统计信息的其他方式，这些查询使用与上面显示的标准视图所使用的相同的基础统计信息访问功能。有关功能名称等详细信息，请查阅标准视图的定义。 （例如，在psql中，您可以发出 &lt;code&gt;\d+ pg_stat_activity&lt;/code&gt; 。）针对每个数据库的统计信息的访问函数将数据库OID作为参数来标识要报告的数据库。每表和每索引函数采用表或索引OID。用于每个功能的统计信息的功能带有功能OID。请注意，使用这些功能只能看到当前数据库中的表，索引和功能。</target>
        </trans-unit>
        <trans-unit id="5209293ce5b675774d27db322f4e25b9f78fde50" translate="yes" xml:space="preserve">
          <source>Other, less commonly used, options are also available:</source>
          <target state="translated">其他不常用的选项也可以使用。</target>
        </trans-unit>
        <trans-unit id="86f791018da698782167efe67330f3a311425f18" translate="yes" xml:space="preserve">
          <source>Otherwise the date field ordering is assumed to follow the &lt;code&gt;DateStyle&lt;/code&gt; setting: mm-dd-yy, dd-mm-yy, or yy-mm-dd. Throw an error if a month or day field is found to be out of range.</source>
          <target state="translated">否则，假定日期字段的排序遵循 &lt;code&gt;DateStyle&lt;/code&gt; 设置：mm-dd-yy，dd-mm-yy或yy-mm-dd。如果发现月或日字段超出范围，则引发错误。</target>
        </trans-unit>
        <trans-unit id="456174149b4fb59cccb0b858ebfab00191262c8b" translate="yes" xml:space="preserve">
          <source>Otherwise, all input expressions must have the same implicit collation derivation or the default collation. If any non-default collation is present, that is the result of the collation combination. Otherwise, the result is the default collation.</source>
          <target state="translated">否则,所有的输入表达式必须具有相同的隐式整理派生或默认整理。如果有任何非缺省整理,那就是整理组合的结果。否则,结果就是默认的整理。</target>
        </trans-unit>
        <trans-unit id="d7ebacc516a1689e9342c3f059955ce6038791c1" translate="yes" xml:space="preserve">
          <source>Otherwise, choose the last non-unknown input type that allows all the preceding non-unknown inputs to be implicitly converted to it. (There always is such a type, since at least the first type in the list must satisfy this condition.)</source>
          <target state="translated">否则,选择最后一个非未知输入类型,允许所有前面的非未知输入隐式转换为它。(总是有这样一个类型,因为至少列表中的第一个类型必须满足这个条件。)</target>
        </trans-unit>
        <trans-unit id="c834d57b171be985e3943329b0a6b22664e27dab" translate="yes" xml:space="preserve">
          <source>Otherwise, color is not used.</source>
          <target state="translated">否则,不使用颜色。</target>
        </trans-unit>
        <trans-unit id="b9c2a604b8999f698fdb4a51e3a4309645319d17" translate="yes" xml:space="preserve">
          <source>Otherwise, if the JSON value is a string literal, the contents of the string are fed to the input conversion function for the column's data type.</source>
          <target state="translated">否则,如果JSON值是一个字符串文字,字符串的内容将被输入到列的数据类型的输入转换函数中。</target>
        </trans-unit>
        <trans-unit id="8a7f14af2eabfd7eaf13755e5438dd8fa6b532ed" translate="yes" xml:space="preserve">
          <source>Otherwise, if the JSON value is a string, the contents of the string are fed to the input conversion function for the column's data type.</source>
          <target state="translated">否则,如果JSON值是一个字符串,字符串的内容将被送入列的数据类型的输入转换函数。</target>
        </trans-unit>
        <trans-unit id="7bead17837ca29580c9cb15e38f0a813be5d9242" translate="yes" xml:space="preserve">
          <source>Otherwise, the ordinary text representation of the JSON value is fed to the input conversion function for the column's data type.</source>
          <target state="translated">否则,JSON值的普通文本表示将被输入到该列数据类型的输入转换函数中。</target>
        </trans-unit>
        <trans-unit id="c91502e459c401481e3ca0162bbcb613cfb57d2b" translate="yes" xml:space="preserve">
          <source>Otherwise, try to convert the expression to the target type. This is possible if an &lt;em&gt;assignment cast&lt;/em&gt; between the two types is registered in the &lt;code&gt;pg_cast&lt;/code&gt; catalog (see &lt;a href=&quot;sql-createcast&quot;&gt;CREATE CAST&lt;/a&gt;). Alternatively, if the expression is an unknown-type literal, the contents of the literal string will be fed to the input conversion routine for the target type.</source>
          <target state="translated">否则，请尝试将表达式转换为目标类型。如果这是可能的&lt;em&gt;赋值转换&lt;/em&gt;的两种类型之间的注册 &lt;code&gt;pg_cast&lt;/code&gt; 里目录（见&lt;a href=&quot;sql-createcast&quot;&gt;CREATE CAST&lt;/a&gt;）。或者，如果表达式是未知类型的文字，则文字字符串的内容将被馈送到目标类型的输入转换例程。</target>
        </trans-unit>
        <trans-unit id="43c3af901aa493d7824a6ced3329413231661c11" translate="yes" xml:space="preserve">
          <source>Out-of-line values are divided (after compression if used) into chunks of at most &lt;code&gt;TOAST_MAX_CHUNK_SIZE&lt;/code&gt; bytes (by default this value is chosen so that four chunk rows will fit on a page, making it about 2000 bytes). Each chunk is stored as a separate row in the TOAST table belonging to the owning table. Every TOAST table has the columns &lt;code&gt;chunk_id&lt;/code&gt; (an OID identifying the particular TOASTed value), &lt;code&gt;chunk_seq&lt;/code&gt; (a sequence number for the chunk within its value), and &lt;code&gt;chunk_data&lt;/code&gt; (the actual data of the chunk). A unique index on &lt;code&gt;chunk_id&lt;/code&gt; and &lt;code&gt;chunk_seq&lt;/code&gt; provides fast retrieval of the values. A pointer datum representing an out-of-line on-disk TOASTed value therefore needs to store the OID of the TOAST table in which to look and the OID of the specific value (its &lt;code&gt;chunk_id&lt;/code&gt;). For convenience, pointer datums also store the logical datum size (original uncompressed data length) and physical stored size (different if compression was applied). Allowing for the varlena header bytes, the total size of an on-disk TOAST pointer datum is therefore 18 bytes regardless of the actual size of the represented value.</source>
          <target state="translated">&lt;code&gt;TOAST_MAX_CHUNK_SIZE&lt;/code&gt; 值被划分（最多使用TOAST_MAX_CHUNK_SIZE个字节）（在压缩后使用）（默认情况下，选择此值以便在页面上容纳四个大块行，使其大约为2000个字节）。每个块都作为单独的行存储在属于拥有表的TOAST表中。每个TOAST表均具有以 &lt;code&gt;chunk_id&lt;/code&gt; （标识特定TOASTed值的OID）， &lt;code&gt;chunk_seq&lt;/code&gt; （其值内的块的序列号）和 &lt;code&gt;chunk_data&lt;/code&gt; （块的实际数据）。基于 &lt;code&gt;chunk_id&lt;/code&gt; 和 &lt;code&gt;chunk_seq&lt;/code&gt; 的唯一索引提供对值的快速检索。因此，表示离线磁盘上TOASTed值的指针数据需要存储要在其中查找的TOAST表的OID和特定值的OID（其 &lt;code&gt;chunk_id&lt;/code&gt; ）。为了方便起见，指针数据还存储逻辑数据大小（原始未压缩的数据长度）和物理存储的大小（如果应用压缩则不同）。因此，考虑到varlena标头字节，磁盘TOAST指针数据的总大小为18个字节，而与所表示值的实际大小无关。</target>
        </trans-unit>
        <trans-unit id="97c53cd2b521753c0d717a86dd39f58035793149" translate="yes" xml:space="preserve">
          <source>Output Length</source>
          <target state="translated">输出长度</target>
        </trans-unit>
        <trans-unit id="afe32b815eb6ac2d448375f1b337e892bc780a8c" translate="yes" xml:space="preserve">
          <source>Output Result</source>
          <target state="translated">輸出結果</target>
        </trans-unit>
        <trans-unit id="a19289a8a65e3eaa1c70019f70d69f0ccdc7e3cc" translate="yes" xml:space="preserve">
          <source>Output SQL-standard &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; commands instead of &lt;code&gt;ALTER OWNER&lt;/code&gt; commands to determine object ownership. This makes the dump more standards compatible, but depending on the history of the objects in the dump, might not restore properly.</source>
          <target state="translated">输出SQL标准的 &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; 命令而不是 &lt;code&gt;ALTER OWNER&lt;/code&gt; 命令来确定对象所有权。这使转储与更多标准兼容，但是根据转储中对象的历史记录，可能无法正确还原。</target>
        </trans-unit>
        <trans-unit id="8d49ccd8d61f0c2e0d773215d12c820e621fe051" translate="yes" xml:space="preserve">
          <source>Output SQL-standard &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; commands instead of &lt;code&gt;ALTER OWNER&lt;/code&gt; commands to determine object ownership. This makes the dump more standards-compatible, but depending on the history of the objects in the dump, might not restore properly.</source>
          <target state="translated">输出SQL标准的 &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; 命令而不是 &lt;code&gt;ALTER OWNER&lt;/code&gt; 命令来确定对象所有权。这使转储更加符合标准，但是根据转储中对象的历史记录，可能无法正确还原。</target>
        </trans-unit>
        <trans-unit id="4625db4629522bcdf0c7c483ff44db087396b6a5" translate="yes" xml:space="preserve">
          <source>Output SQL-standard &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; commands instead of &lt;code&gt;ALTER OWNER&lt;/code&gt; commands to determine object ownership. This makes the dump more standards-compatible, but depending on the history of the objects in the dump, might not restore properly. Also, a dump using &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; will certainly require superuser privileges to restore correctly, whereas &lt;code&gt;ALTER OWNER&lt;/code&gt; requires lesser privileges.</source>
          <target state="translated">输出SQL标准的 &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; 命令而不是 &lt;code&gt;ALTER OWNER&lt;/code&gt; 命令来确定对象所有权。这使转储更加符合标准，但是根据转储中对象的历史记录，可能无法正确还原。同样，使用 &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; 进行的转储当然需要超级用户特权才能正确还原，而 &lt;code&gt;ALTER OWNER&lt;/code&gt; 则需要较少的特权。</target>
        </trans-unit>
        <trans-unit id="2005b7d907d65c19aff7a047dfc1b1dcc52ef1ca" translate="yes" xml:space="preserve">
          <source>Output a &lt;code&gt;tar&lt;/code&gt;-format archive suitable for input into pg_restore. The tar format is compatible with the directory format: extracting a tar-format archive produces a valid directory-format archive. However, the tar format does not support compression. Also, when using tar format the relative order of table data items cannot be changed during restore.</source>
          <target state="translated">输出适合于输入pg_restore 的 &lt;code&gt;tar&lt;/code&gt; 格式的存档。tar格式与目录格式兼容：提取tar格式的存档会生成有效的目录格式的存档。但是，tar格式不支持压缩。同样，当使用tar格式时，在还原过程中不能更改表数据项的相对顺序。</target>
        </trans-unit>
        <trans-unit id="2eb830dc0187c951bb3c38e2fc9ae11b3f83d2a4" translate="yes" xml:space="preserve">
          <source>Output a custom-format archive suitable for input into pg_restore. Together with the directory output format, this is the most flexible output format in that it allows manual selection and reordering of archived items during restore. This format is also compressed by default.</source>
          <target state="translated">输出一个适合输入pg_restore的自定义格式的存档。与目录输出格式一样,这是最灵活的输出格式,因为它允许在还原过程中手动选择和重新排列存档项目。默认情况下,这种格式也是经过压缩的。</target>
        </trans-unit>
        <trans-unit id="314bcb0a58dea88f5b77ecfb141e26b87d6cd0bf" translate="yes" xml:space="preserve">
          <source>Output a directory-format archive suitable for input into pg_restore. This will create a directory with one file for each table and blob being dumped, plus a so-called Table of Contents file describing the dumped objects in a machine-readable format that pg_restore can read. A directory format archive can be manipulated with standard Unix tools; for example, files in an uncompressed archive can be compressed with the gzip tool. This format is compressed by default and also supports parallel dumps.</source>
          <target state="translated">输出一个适合输入pg_restore的目录格式的存档。这将为每个被转储的表和blob创建一个包含一个文件的目录,加上一个所谓的Table of Contents文件,以pg_restore可以读取的机器可读格式描述转储对象。一个目录格式的存档可以用标准的Unix工具来操作,例如,未压缩的存档中的文件可以用gzip工具来压缩。这种格式默认是压缩的,也支持并行转储。</target>
        </trans-unit>
        <trans-unit id="9af173b4747fa54411d828576f57ede6b623e6c6" translate="yes" xml:space="preserve">
          <source>Output a plain-text SQL script file (the default).</source>
          <target state="translated">输出纯文本SQL脚本文件(默认)。</target>
        </trans-unit>
        <trans-unit id="8bdf0890d1e63cc1cfc92f91594ac95c633ba722" translate="yes" xml:space="preserve">
          <source>Output commands to clean (drop) database objects prior to outputting the commands for creating them. (Unless &lt;code&gt;--if-exists&lt;/code&gt; is also specified, restore might generate some harmless error messages, if any objects were not present in the destination database.)</source>
          <target state="translated">在输出用于创建数据库对象的命令之前，先输出命令以清理（删除）数据库对象。（除非也指定了 &lt;code&gt;--if-exists&lt;/code&gt; ，如果目标数据库中不存在任何对象，则还原可能会生成一些无害的错误消息。）</target>
        </trans-unit>
        <trans-unit id="48cd5d324665dcd708893b4a104e4fb4fecb1e8f" translate="yes" xml:space="preserve">
          <source>Output conversion function (binary format), or 0 if none</source>
          <target state="translated">输出转换功能(二进制格式),如果没有则为0。</target>
        </trans-unit>
        <trans-unit id="3bc8730df1e12ab656e0ea8398920726728cdbcd" translate="yes" xml:space="preserve">
          <source>Output conversion function (text format)</source>
          <target state="translated">输出转换功能(文本格式</target>
        </trans-unit>
        <trans-unit id="2d850ce6c63d0f20826daa05520cced6f2083334" translate="yes" xml:space="preserve">
          <source>Output detailed information about backup blocks.</source>
          <target state="translated">输出备份块的详细信息。</target>
        </trans-unit>
        <trans-unit id="babad7640e9f136cd19423d495f4b1ee0fee89a9" translate="yes" xml:space="preserve">
          <source>Output is always in the standard form.</source>
          <target state="translated">输出始终是标准形式。</target>
        </trans-unit>
        <trans-unit id="7835db447bc76230b5b0d736b2d78c671d7100a1" translate="yes" xml:space="preserve">
          <source>Outputs</source>
          <target state="translated">Outputs</target>
        </trans-unit>
        <trans-unit id="cdfe59de620bc8ec7ec39dbaf869451006fe122e" translate="yes" xml:space="preserve">
          <source>Outputs information about the current database connection.</source>
          <target state="translated">输出当前数据库连接的信息。</target>
        </trans-unit>
        <trans-unit id="a3ae7cd3ba4b5d3440099a3b3e44c0885cc411f2" translate="yes" xml:space="preserve">
          <source>Overlaps or is left of &amp;mdash; This might be better read as &amp;ldquo;does not extend to right of&amp;rdquo;. It is true when b &amp;lt;= d.</source>
          <target state="translated">重叠或在其左侧-最好将其理解为&amp;ldquo;不延伸至其右侧&amp;rdquo;。当b &amp;lt;= d时为真。</target>
        </trans-unit>
        <trans-unit id="e3d201e01172e474738c7662f57e70ca764bc088" translate="yes" xml:space="preserve">
          <source>Overlaps or is right of &amp;mdash; This might be better read as &amp;ldquo;does not extend to left of&amp;rdquo;. It is true when a &amp;gt;= c.</source>
          <target state="translated">重叠或在其右侧-最好将其理解为&amp;ldquo;不延伸至其左侧&amp;rdquo;。当a&amp;gt; = c时是正确的。</target>
        </trans-unit>
        <trans-unit id="7af34d74e482413c9143a47da7e672969aed843a" translate="yes" xml:space="preserve">
          <source>Overlaps? (One point in common makes this true.)</source>
          <target state="translated">重叠?(有一点共同点使之成为事实)。</target>
        </trans-unit>
        <trans-unit id="cb2f163ccc20cb7388203cf1edbc6860b44ea0f0" translate="yes" xml:space="preserve">
          <source>Overloading</source>
          <target state="translated">Overloading</target>
        </trans-unit>
        <trans-unit id="a2fd113f354ec9ec1edb291682b81f94fe430ddc" translate="yes" xml:space="preserve">
          <source>Owner of the collation</source>
          <target state="translated">整理者</target>
        </trans-unit>
        <trans-unit id="b7eb54933c030e119dce1086dc82e09c41077f94" translate="yes" xml:space="preserve">
          <source>Owner of the configuration</source>
          <target state="translated">配置的所有者</target>
        </trans-unit>
        <trans-unit id="a47511340c90f2c223a36694793ee22b0651e345" translate="yes" xml:space="preserve">
          <source>Owner of the conversion</source>
          <target state="translated">改造业主</target>
        </trans-unit>
        <trans-unit id="9adb637b26bc7a0111112afdc905c0fa9b433b1f" translate="yes" xml:space="preserve">
          <source>Owner of the database, usually the user who created it</source>
          <target state="translated">数据库的所有者,通常是创建数据库的用户。</target>
        </trans-unit>
        <trans-unit id="1e1395f6076a153ad4fcc55b23348741788d9a0e" translate="yes" xml:space="preserve">
          <source>Owner of the dictionary</source>
          <target state="translated">字典所有者</target>
        </trans-unit>
        <trans-unit id="873852f61944660a0d123bafc40c1182f58cd2a5" translate="yes" xml:space="preserve">
          <source>Owner of the event trigger</source>
          <target state="translated">事件触发器的所有者</target>
        </trans-unit>
        <trans-unit id="e618675166fd8eccc064277b88953a8fdc0951cf" translate="yes" xml:space="preserve">
          <source>Owner of the extended statistics</source>
          <target state="translated">扩展统计数字的所有者</target>
        </trans-unit>
        <trans-unit id="0e0062122acfc3428eb36e8494aa91cdda1bb823" translate="yes" xml:space="preserve">
          <source>Owner of the extension</source>
          <target state="translated">分机的所有者</target>
        </trans-unit>
        <trans-unit id="1b3fd58bbcd1cbede99d727eb332a616ef746459" translate="yes" xml:space="preserve">
          <source>Owner of the foreign server</source>
          <target state="translated">外国服务器的所有者</target>
        </trans-unit>
        <trans-unit id="4abeec384f4e4e4fd2630496e361931c03792e90" translate="yes" xml:space="preserve">
          <source>Owner of the foreign-data wrapper</source>
          <target state="translated">外国数据包装器的所有者</target>
        </trans-unit>
        <trans-unit id="045ebe36026cc33372375251adb04267dd08a6f9" translate="yes" xml:space="preserve">
          <source>Owner of the function</source>
          <target state="translated">职能所有者</target>
        </trans-unit>
        <trans-unit id="3de3b296802701c83666e4a9e6c77ad8e092b09c" translate="yes" xml:space="preserve">
          <source>Owner of the language</source>
          <target state="translated">语文所有者</target>
        </trans-unit>
        <trans-unit id="5f358242f17294414495cbc231ac35ed8a7ef36f" translate="yes" xml:space="preserve">
          <source>Owner of the large object</source>
          <target state="translated">大型物体的所有者</target>
        </trans-unit>
        <trans-unit id="08c133834660a3f3265245c9248f60f1979449d5" translate="yes" xml:space="preserve">
          <source>Owner of the namespace</source>
          <target state="translated">命名空间的所有者</target>
        </trans-unit>
        <trans-unit id="f3d409145414a207ad5ab1a06298cf4de3e3d79d" translate="yes" xml:space="preserve">
          <source>Owner of the operator</source>
          <target state="translated">经营者的业主</target>
        </trans-unit>
        <trans-unit id="4fe1d02890b80f29d14de9cf7c7d720b98ec4436" translate="yes" xml:space="preserve">
          <source>Owner of the operator class</source>
          <target state="translated">经营者类的所有者</target>
        </trans-unit>
        <trans-unit id="34a092b8bf19aa76f83af3f5f7f00fd4abe9f1da" translate="yes" xml:space="preserve">
          <source>Owner of the operator family</source>
          <target state="translated">经营者家庭的所有者</target>
        </trans-unit>
        <trans-unit id="530840c2bedf8afbc58ec145a817bd5855b5da2c" translate="yes" xml:space="preserve">
          <source>Owner of the publication</source>
          <target state="translated">出版物的所有者</target>
        </trans-unit>
        <trans-unit id="f104f465825a18941861fe36eee16972af35d0fd" translate="yes" xml:space="preserve">
          <source>Owner of the relation</source>
          <target state="translated">关系人</target>
        </trans-unit>
        <trans-unit id="d2d338d2c9f46fc9058acd6bf8b505d62cfd7125" translate="yes" xml:space="preserve">
          <source>Owner of the statistics object</source>
          <target state="translated">统计对象的所有者</target>
        </trans-unit>
        <trans-unit id="27aa59e6a53863d7fc75c728e631589d9ef875ce" translate="yes" xml:space="preserve">
          <source>Owner of the subscription</source>
          <target state="translated">订阅者</target>
        </trans-unit>
        <trans-unit id="3ca261d2ecfb68a9f64ba043ec469131179f4f2d" translate="yes" xml:space="preserve">
          <source>Owner of the tablespace, usually the user who created it</source>
          <target state="translated">表空间的所有者,通常是创建表空间的用户。</target>
        </trans-unit>
        <trans-unit id="451938c2f2732dd84e3e87dd05cdd4be024d9498" translate="yes" xml:space="preserve">
          <source>Owner of the type</source>
          <target state="translated">类型的所有者</target>
        </trans-unit>
        <trans-unit id="7a88ac00bf4b0ee2c311712a067ae74712fb2321" translate="yes" xml:space="preserve">
          <source>Ownership of objects can be transferred one at a time using &lt;code&gt;ALTER&lt;/code&gt; commands, for example:</source>
          <target state="translated">可以使用 &lt;code&gt;ALTER&lt;/code&gt; 命令一次转移一个对象的所有权，例如：</target>
        </trans-unit>
        <trans-unit id="880684f9ec2b7a622ac555da2f5f06938c962c51" translate="yes" xml:space="preserve">
          <source>P''(t)</source>
          <target state="translated">P''(t)</target>
        </trans-unit>
        <trans-unit id="6c4b4caa40b248d284230f88cbcd7f13476b2cac" translate="yes" xml:space="preserve">
          <source>P(t)</source>
          <target state="translated">P(t)</target>
        </trans-unit>
        <trans-unit id="f8475eae73fea7de999190d28ead30c11cd46b3b" translate="yes" xml:space="preserve">
          <source>P-1Y-2M3DT-4H-5M-6S</source>
          <target state="translated">P-1Y-2M3DT-4H-5M-6S</target>
        </trans-unit>
        <trans-unit id="637e5ac0a44e83d198f6482aad52a4ee2c33076a" translate="yes" xml:space="preserve">
          <source>P-1Y-2M3D​T-4H-5M-6S</source>
          <target state="translated">P-1Y-2M3D​T-4H-5M-6S</target>
        </trans-unit>
        <trans-unit id="c066b74bc2c03f3472bba6e63d39e90c2e2d20c7" translate="yes" xml:space="preserve">
          <source>P0001-02-03T04:05:06</source>
          <target state="translated">P0001-02-03T04:05:06</target>
        </trans-unit>
        <trans-unit id="579e8ed8bf53a5860299c4787471ee73ec431b5e" translate="yes" xml:space="preserve">
          <source>P1Y2M</source>
          <target state="translated">P1Y2M</target>
        </trans-unit>
        <trans-unit id="bd1aaf321a587301c665f6a19e72881af023a930" translate="yes" xml:space="preserve">
          <source>P1Y2M3DT4H5M6S</source>
          <target state="translated">P1Y2M3DT4H5M6S</target>
        </trans-unit>
        <trans-unit id="9ba0b6685e5baca573f3acd95f81a092797985f3" translate="yes" xml:space="preserve">
          <source>P3DT4H5M6S</source>
          <target state="translated">P3DT4H5M6S</target>
        </trans-unit>
        <trans-unit id="1dc752ba52c4ea05107706b7e03df6ab354e39ff" translate="yes" xml:space="preserve">
          <source>PAM</source>
          <target state="translated">PAM</target>
        </trans-unit>
        <trans-unit id="388c2af7f59c6eee722356ebc329cec67a8389d7" translate="yes" xml:space="preserve">
          <source>PAM Authentication</source>
          <target state="translated">PAM认证</target>
        </trans-unit>
        <trans-unit id="9e8eaf2f87853067037437397fcd30a4aa337b20" translate="yes" xml:space="preserve">
          <source>PAM service name.</source>
          <target state="translated">PAM服务名称:</target>
        </trans-unit>
        <trans-unit id="0bfd8f66160aa4b77dcdec5d43e4805495e07e18" translate="yes" xml:space="preserve">
          <source>PGP Public-Key encryption</source>
          <target state="translated">PGP公钥加密</target>
        </trans-unit>
        <trans-unit id="76646f05da6bf5eb4fecf712e1a4c9bffc428604" translate="yes" xml:space="preserve">
          <source>PGP Symmetric encryption</source>
          <target state="translated">PGP 对称加密</target>
        </trans-unit>
        <trans-unit id="4e09cf6b34360609cb4cdd2c5b437e8b7854a05d" translate="yes" xml:space="preserve">
          <source>PGSQL</source>
          <target state="translated">PGSQL</target>
        </trans-unit>
        <trans-unit id="3ba27c9c3666ed10b53aa3320fe270149336d75a" translate="yes" xml:space="preserve">
          <source>PGXS</source>
          <target state="translated">PGXS</target>
        </trans-unit>
        <trans-unit id="dde57e820d65c87a0777da46aba7cd35a0c8436a" translate="yes" xml:space="preserve">
          <source>PID</source>
          <target state="translated">PID</target>
        </trans-unit>
        <trans-unit id="feee1d9b13144a255359aea6e303897e613b068c" translate="yes" xml:space="preserve">
          <source>PITR</source>
          <target state="translated">PITR</target>
        </trans-unit>
        <trans-unit id="3238a2c23ec52b54d1a9d62034bcdec3628b7db6" translate="yes" xml:space="preserve">
          <source>PL</source>
          <target state="translated">PL</target>
        </trans-unit>
        <trans-unit id="beec5d503ed58c40992ce7fab4af575b48a55538" translate="yes" xml:space="preserve">
          <source>PL/pgSQL handles output parameters in &lt;code&gt;CALL&lt;/code&gt; commands differently; see &lt;a href=&quot;https://www.postgresql.org/docs/12/plpgsql-control-structures.html#PLPGSQL-STATEMENTS-CALLING-PROCEDURE&quot;&gt;Section 42.6.3&lt;/a&gt;.</source>
          <target state="translated">PL / pgSQL处理 &lt;code&gt;CALL&lt;/code&gt; 命令中的输出参数的方式有所不同。参见&lt;a href=&quot;https://www.postgresql.org/docs/12/plpgsql-control-structures.html#PLPGSQL-STATEMENTS-CALLING-PROCEDURE&quot;&gt;第42.6.3节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="17b76a5d14c8b2c49a6ac06895875148d89695c0" translate="yes" xml:space="preserve">
          <source>PL/pgSQL handles output parameters in &lt;code&gt;CALL&lt;/code&gt; commands differently; see &lt;a href=&quot;https://www.postgresql.org/docs/13/plpgsql-control-structures.html#PLPGSQL-STATEMENTS-CALLING-PROCEDURE&quot;&gt;Section 42.6.3&lt;/a&gt;.</source>
          <target state="translated">PL / pgSQL处理 &lt;code&gt;CALL&lt;/code&gt; 命令中的输出参数的方式有所不同。参见&lt;a href=&quot;https://www.postgresql.org/docs/13/plpgsql-control-structures.html#PLPGSQL-STATEMENTS-CALLING-PROCEDURE&quot;&gt;第42.6.3节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="23507e798d66fee0b05313c2a15e15ff93e82f20" translate="yes" xml:space="preserve">
          <source>POSIX</source>
          <target state="translated">POSIX</target>
        </trans-unit>
        <trans-unit id="4e03c943de4a471ff8d7eb0aea61351231577229" translate="yes" xml:space="preserve">
          <source>POSIX Time Zone Specifications</source>
          <target state="translated">POSIX时区规格</target>
        </trans-unit>
        <trans-unit id="f586c4a0642bd8530bd206b6d1e6d9b7d935f68f" translate="yes" xml:space="preserve">
          <source>POSIX interprets character classes such as &lt;code&gt;\w&lt;/code&gt; (see &lt;a href=&quot;functions-matching#POSIX-CLASS-SHORTHAND-ESCAPES-TABLE&quot;&gt;Table 9.20&lt;/a&gt;) according to the prevailing locale (which you can control by attaching a &lt;code&gt;COLLATE&lt;/code&gt; clause to the operator or function). XQuery specifies these classes by reference to Unicode character properties, so equivalent behavior is obtained only with a locale that follows the Unicode rules.</source>
          <target state="translated">POSIX 根据主要语言环境（您可以通过将 &lt;code&gt;COLLATE&lt;/code&gt; 子句附加到运算符或函数来控制）来解释字符类，例如 &lt;code&gt;\w&lt;/code&gt; （请&lt;a href=&quot;functions-matching#POSIX-CLASS-SHORTHAND-ESCAPES-TABLE&quot;&gt;参见表9.20&lt;/a&gt;）。XQuery通过引用Unicode字符属性来指定这些类，因此仅使用遵循Unicode规则的语言环境才能获得等效的行为。</target>
        </trans-unit>
        <trans-unit id="63465644013ae752eee8a21083fea8ac69dc57b1" translate="yes" xml:space="preserve">
          <source>POSIX interprets character classes such as &lt;code&gt;\w&lt;/code&gt; (see &lt;a href=&quot;functions-matching#POSIX-CLASS-SHORTHAND-ESCAPES-TABLE&quot;&gt;Table 9.21&lt;/a&gt;) according to the prevailing locale (which you can control by attaching a &lt;code&gt;COLLATE&lt;/code&gt; clause to the operator or function). XQuery specifies these classes by reference to Unicode character properties, so equivalent behavior is obtained only with a locale that follows the Unicode rules.</source>
          <target state="translated">POSIX根据普遍的语言环境（您可以通过将 &lt;code&gt;COLLATE&lt;/code&gt; 子句附加到运算符或函数来控制）来解释字符类，例如 &lt;code&gt;\w&lt;/code&gt; （请&lt;a href=&quot;functions-matching#POSIX-CLASS-SHORTHAND-ESCAPES-TABLE&quot;&gt;参见表9.21&lt;/a&gt;）。XQuery通过引用Unicode字符属性来指定这些类，因此仅使用遵循Unicode规则的语言环境才能获得等效的行为。</target>
        </trans-unit>
        <trans-unit id="e102feaa5742be5a0f3d3fc50f40fceae7d340a6" translate="yes" xml:space="preserve">
          <source>POSIX regular expressions provide a more powerful means for pattern matching than the &lt;code&gt;LIKE&lt;/code&gt; and &lt;code&gt;SIMILAR TO&lt;/code&gt; operators. Many Unix tools such as &lt;code&gt;egrep&lt;/code&gt;, &lt;code&gt;sed&lt;/code&gt;, or &lt;code&gt;awk&lt;/code&gt; use a pattern matching language that is similar to the one described here.</source>
          <target state="translated">POSIX正则表达式提供了比 &lt;code&gt;LIKE&lt;/code&gt; 和 &lt;code&gt;SIMILAR TO&lt;/code&gt; 运算符更强大的模式匹配方式。许多Unix工具（例如 &lt;code&gt;egrep&lt;/code&gt; ， &lt;code&gt;sed&lt;/code&gt; 或 &lt;code&gt;awk&lt;/code&gt; )使用一种模式匹配语言，该语言与此处描述的语言相似。</target>
        </trans-unit>
        <trans-unit id="46e0e2f3d2a15c3b14b95e0c1c7504bef70da246" translate="yes" xml:space="preserve">
          <source>POSIX-style time zone specification</source>
          <target state="translated">POSIX风格的时区规范</target>
        </trans-unit>
        <trans-unit id="66e2f96d2e144c19219f34885e8aed66af8ec26f" translate="yes" xml:space="preserve">
          <source>PREPARE</source>
          <target state="translated">PREPARE</target>
        </trans-unit>
        <trans-unit id="497f657a7bd6c59491c1afe2f14778a0325e0aeb" translate="yes" xml:space="preserve">
          <source>PREPARE &amp;mdash; prepare a statement for execution</source>
          <target state="translated">PREPARE-准备要执行的语句</target>
        </trans-unit>
        <trans-unit id="37fb488fc1130c92529c23ebb00239237637a743" translate="yes" xml:space="preserve">
          <source>PREPARE TRANSACTION</source>
          <target state="translated">准备交易</target>
        </trans-unit>
        <trans-unit id="a6c4ba5ff6212b5c43bdc5722e0f091244559eda" translate="yes" xml:space="preserve">
          <source>PREPARE TRANSACTION &amp;mdash; prepare the current transaction for two-phase commit</source>
          <target state="translated">准备事务-为两阶段提交准备当前事务</target>
        </trans-unit>
        <trans-unit id="5ddcb3afaebc491f73714dc172d37266e6be3bda" translate="yes" xml:space="preserve">
          <source>Packaging and deployment scripts should be careful to create the &lt;code&gt;postgres&lt;/code&gt; user as a system user by using &lt;code&gt;useradd -r&lt;/code&gt;, &lt;code&gt;adduser --system&lt;/code&gt;, or equivalent.</source>
          <target state="translated">打包和部署脚本应谨慎使用 &lt;code&gt;useradd -r&lt;/code&gt; ， &lt;code&gt;adduser --system&lt;/code&gt; 或等效名称将 &lt;code&gt;postgres&lt;/code&gt; 用户创建为系统用户。</target>
        </trans-unit>
        <trans-unit id="a10c2d221e8eba42e9b331576d9daca086bdfe95" translate="yes" xml:space="preserve">
          <source>Packet containing a session key &amp;mdash; either symmetric-key or public-key encrypted.</source>
          <target state="translated">包含会话密钥的数据包-对称密钥或公共密钥已加密。</target>
        </trans-unit>
        <trans-unit id="fe9ad910809dee7861d17df7e5f096ed938e0ab2" translate="yes" xml:space="preserve">
          <source>Packet containing data encrypted with the session key.</source>
          <target state="translated">包含用会话密钥加密的数据包。</target>
        </trans-unit>
        <trans-unit id="5dd9f751429eb18847bb4ae66caf8a2fda2b0c20" translate="yes" xml:space="preserve">
          <source>Page checksum</source>
          <target state="translated">页面校验和</target>
        </trans-unit>
        <trans-unit id="10d741089ed07914a82a77ba0b90a6a76cd492d4" translate="yes" xml:space="preserve">
          <source>Page number of this page within its large object (counting from zero)</source>
          <target state="translated">本页在其大对象内的页数(从零开始计数</target>
        </trans-unit>
        <trans-unit id="fc5666da83404ee33adbe94f98f1c6ba4503d3c8" translate="yes" xml:space="preserve">
          <source>Page number targeted by the lock within the relation, or null if the target is not a relation page or tuple</source>
          <target state="translated">在关系中被锁定的页数,如果目标不是关系页或元组,则为空。</target>
        </trans-unit>
        <trans-unit id="05fe9679957eb1665689044c2d47f231b7b99aa3" translate="yes" xml:space="preserve">
          <source>Page number within the relation</source>
          <target state="translated">关系内的页数</target>
        </trans-unit>
        <trans-unit id="2b355a7b15353314735e75b8e122c5ae1fcd5a22" translate="yes" xml:space="preserve">
          <source>Page size and layout version number information</source>
          <target state="translated">页面大小和布局版本号信息</target>
        </trans-unit>
        <trans-unit id="a03c41b78d25bf18f06cd333e2c95e267c66a660" translate="yes" xml:space="preserve">
          <source>PageHeaderData</source>
          <target state="translated">PageHeaderData</target>
        </trans-unit>
        <trans-unit id="2750093ba2a279af4331fd53d0a8cee7be245d4f" translate="yes" xml:space="preserve">
          <source>PageXLogRecPtr</source>
          <target state="translated">PageXLogRecPtr</target>
        </trans-unit>
        <trans-unit id="d90de0896be6c5efa3c782fa286f1c3cdb9a7b50" translate="yes" xml:space="preserve">
          <source>Parallel Plans</source>
          <target state="translated">平行计划</target>
        </trans-unit>
        <trans-unit id="686414fccc150dceb0e9f56ace196fdc729a14bb" translate="yes" xml:space="preserve">
          <source>Parallel Plans: Parallel Aggregation</source>
          <target state="translated">并行计划。平行聚合</target>
        </trans-unit>
        <trans-unit id="b75e7cdb23627ee4086ddf3246e9c894f0ce11d0" translate="yes" xml:space="preserve">
          <source>Parallel Plans: Parallel Append</source>
          <target state="translated">平行计划。平行附件</target>
        </trans-unit>
        <trans-unit id="976b16b543b8304722b64b1a24c59b4c0b79488f" translate="yes" xml:space="preserve">
          <source>Parallel Plans: Parallel Joins</source>
          <target state="translated">平行计划。平行连接</target>
        </trans-unit>
        <trans-unit id="9010e7d56024ae4a3d31f2d2290191dd0b36e537" translate="yes" xml:space="preserve">
          <source>Parallel Plans: Parallel Plan Tips</source>
          <target state="translated">平行计划。平行计划技巧</target>
        </trans-unit>
        <trans-unit id="039109d587d0e62745986a2cf6f26a04992e1351" translate="yes" xml:space="preserve">
          <source>Parallel Plans: Parallel Scans</source>
          <target state="translated">平行计划。平行扫描</target>
        </trans-unit>
        <trans-unit id="cfafb44924e6a5f388ef259a64814a132f966833" translate="yes" xml:space="preserve">
          <source>Parallel Query</source>
          <target state="translated">并行查询</target>
        </trans-unit>
        <trans-unit id="82124baa3b5560bbd5720a4765dc2466961bc53a" translate="yes" xml:space="preserve">
          <source>Parallel Safety</source>
          <target state="translated">平行安全</target>
        </trans-unit>
        <trans-unit id="0fe56d7979154496310d56ea233bf1c11643ddc4" translate="yes" xml:space="preserve">
          <source>Parallel Safety: Parallel Labeling for Functions and Aggregates</source>
          <target state="translated">并行安全。函数和集合的并行标签设计</target>
        </trans-unit>
        <trans-unit id="5ab3e8fa2d7856e75083b2a36c41793361958622" translate="yes" xml:space="preserve">
          <source>Parallel aggregation is not supported in all situations. Each aggregate must be &lt;a href=&quot;parallel-safety&quot;&gt;safe&lt;/a&gt; for parallelism and must have a combine function. If the aggregate has a transition state of type &lt;code&gt;internal&lt;/code&gt;, it must have serialization and deserialization functions. See &lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt; for more details. Parallel aggregation is not supported if any aggregate function call contains &lt;code&gt;DISTINCT&lt;/code&gt; or &lt;code&gt;ORDER BY&lt;/code&gt; clause and is also not supported for ordered set aggregates or when the query involves &lt;code&gt;GROUPING SETS&lt;/code&gt;. It can only be used when all joins involved in the query are also part of the parallel portion of the plan.</source>
          <target state="translated">并非在所有情况下都支持并行聚合。每个聚合对于并行性必须是&lt;a href=&quot;parallel-safety&quot;&gt;安全的&lt;/a&gt;，并且必须具有合并功能。如果聚合的过渡状态为 &lt;code&gt;internal&lt;/code&gt; ，则必须具有序列化和反序列化功能。有关更多详细信息，请参见&lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt;。如果任何聚合函数调用包含 &lt;code&gt;DISTINCT&lt;/code&gt; 或 &lt;code&gt;ORDER BY&lt;/code&gt; 子句，则不支持并行聚合；对于有序集聚合，或者当查询涉及 &lt;code&gt;GROUPING SETS&lt;/code&gt; 时，也不支持并行聚合。仅当查询中涉及的所有联接也是计划的并行部分的一部分时，才可以使用它。</target>
        </trans-unit>
        <trans-unit id="04d6d9331b5a5aaad9590228fe97b2a4cfe26295" translate="yes" xml:space="preserve">
          <source>Parallel index builds may benefit from increasing &lt;code&gt;maintenance_work_mem&lt;/code&gt; where an equivalent serial index build will see little or no benefit. Note that &lt;code&gt;maintenance_work_mem&lt;/code&gt; may influence the number of worker processes requested, since parallel workers must have at least a &lt;code&gt;32MB&lt;/code&gt; share of the total &lt;code&gt;maintenance_work_mem&lt;/code&gt; budget. There must also be a remaining &lt;code&gt;32MB&lt;/code&gt; share for the leader process. Increasing &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-MAINTENANCE&quot;&gt;max_parallel_maintenance_workers&lt;/a&gt; may allow more workers to be used, which will reduce the time needed for index creation, so long as the index build is not already I/O bound. Of course, there should also be sufficient CPU capacity that would otherwise lie idle.</source>
          <target state="translated">并行索引构建可能会受益于 &lt;code&gt;maintenance_work_mem&lt;/code&gt; 的增加，而等效的串行索引构建将几乎没有收益。请注意， &lt;code&gt;maintenance_work_mem&lt;/code&gt; 可能会影响请求的工作进程数，因为并行工作程序必须至少占 &lt;code&gt;maintenance_work_mem&lt;/code&gt; 总预算的 &lt;code&gt;32MB&lt;/code&gt; 。领导者进程还必须有剩余的 &lt;code&gt;32MB&lt;/code&gt; 共享空间。增加&lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-MAINTENANCE&quot;&gt;max_parallel_maintenance_workers&lt;/a&gt;可能允许使用更多的worker，只要索引构建尚未受I / O约束，这将减少索引创建所需的时间。当然，还应该有足够的CPU容量，否则它们将处于空闲状态。</target>
        </trans-unit>
        <trans-unit id="8d1ebc235cfc864b875140b5812bbbb72ec9bf92" translate="yes" xml:space="preserve">
          <source>Parallel query</source>
          <target state="translated">并行查询</target>
        </trans-unit>
        <trans-unit id="f699f295e5ae4ac633cfa18437fed38d028b3fdb" translate="yes" xml:space="preserve">
          <source>Parameter</source>
          <target state="translated">Parameter</target>
        </trans-unit>
        <trans-unit id="09be2449f5c7874ea156950916c870b9f0c9269d" translate="yes" xml:space="preserve">
          <source>Parameter type (&lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;enum&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;real&lt;/code&gt;, or &lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">参数类型（ &lt;code&gt;bool&lt;/code&gt; ， &lt;code&gt;enum&lt;/code&gt; ， &lt;code&gt;integer&lt;/code&gt; ， &lt;code&gt;real&lt;/code&gt; 或 &lt;code&gt;string&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="044b6f8bb6500f64950a5a00b3fc891db56006e8" translate="yes" xml:space="preserve">
          <source>Parameter value assumed at server startup if the parameter is not otherwise set</source>
          <target state="translated">在服务器启动时假设的参数值,如果该参数没有其他设置。</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="2f389ed6f97b68ab045fe7feae01a113660deba4" translate="yes" xml:space="preserve">
          <source>Parameters - &lt;code&gt;SHOW&lt;/code&gt;, &lt;code&gt;SET&lt;/code&gt;, &lt;code&gt;RESET&lt;/code&gt;</source>
          <target state="translated">参数 &lt;code&gt;SHOW&lt;/code&gt; ， &lt;code&gt;SET&lt;/code&gt; ， &lt;code&gt;RESET&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6d605d3acb20f72158d3fdf0384d4816df27da77" translate="yes" xml:space="preserve">
          <source>Parameters set in this way provide default values for the cluster. The settings seen by active sessions will be these values unless they are overridden. The following sections describe ways in which the administrator or user can override these defaults.</source>
          <target state="translated">以这种方式设置的参数为群集提供了默认值。活动会话看到的设置将是这些值,除非它们被覆盖。下面的章节描述了管理员或用户可以覆盖这些默认值的方法。</target>
        </trans-unit>
        <trans-unit id="b9f24c90be4904850b86a1b21d3ff1448827c68d" translate="yes" xml:space="preserve">
          <source>Parent trigger that this trigger is cloned from, zero if not a clone; this happens when partitions are created or attached to a partitioned table.</source>
          <target state="translated">这个触发器是从父触发器克隆出来的,如果不是克隆,则为零;当创建分区或附加到分区表时,就会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="f9c46bf34fcbc732066fd8d85a736b2f71975d85" translate="yes" xml:space="preserve">
          <source>Parentheses (&lt;code&gt;()&lt;/code&gt;) have their usual meaning to group expressions and enforce precedence. In some cases parentheses are required as part of the fixed syntax of a particular SQL command.</source>
          <target state="translated">括号（ &lt;code&gt;()&lt;/code&gt; ）具有将表达式分组和强制执行优先级的通常含义。在某些情况下，括号是特定SQL命令的固定语法的一部分。</target>
        </trans-unit>
        <trans-unit id="98e95b8350c1e439f335fb041362e108a0725712" translate="yes" xml:space="preserve">
          <source>Parentheses &lt;code&gt;()&lt;/code&gt; can be used to group items into a single logical item.</source>
          <target state="translated">括号 &lt;code&gt;()&lt;/code&gt; 可用于将项目分组为单个逻辑项目。</target>
        </trans-unit>
        <trans-unit id="6bd6d9306fafc7f371b0f3c8451bd6a999eda172" translate="yes" xml:space="preserve">
          <source>Parentheses are used to resolve ambiguities. In the following example, the first statement assigns the alias &lt;code&gt;b&lt;/code&gt; to the second instance of &lt;code&gt;my_table&lt;/code&gt;, but the second statement assigns the alias to the result of the join:</source>
          <target state="translated">括号用于解决歧义。在下面的示例中，第一条语句将别名 &lt;code&gt;b&lt;/code&gt; 分配给 &lt;code&gt;my_table&lt;/code&gt; 的第二个实例，但是第二条语句将别名分配给联接的结果：</target>
        </trans-unit>
        <trans-unit id="8a18942798320d682a81a99742ced66e1f7dcd4f" translate="yes" xml:space="preserve">
          <source>Parentheses can be used to control nesting of the &lt;code&gt;tsquery&lt;/code&gt; operators. Without parentheses, &lt;code&gt;|&lt;/code&gt; binds least tightly, then &lt;code&gt;&amp;amp;&lt;/code&gt;, then &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt;, and &lt;code&gt;!&lt;/code&gt; most tightly.</source>
          <target state="translated">括号可用于控制 &lt;code&gt;tsquery&lt;/code&gt; 运算符的嵌套。没有括号， &lt;code&gt;|&lt;/code&gt; 。绑定最少，然后 &lt;code&gt;&amp;amp;&lt;/code&gt; ，然后 &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; ，和 &lt;code&gt;!&lt;/code&gt; 最紧密地。</target>
        </trans-unit>
        <trans-unit id="0de9a8d461cec2b96e138a5742063451fce829dd" translate="yes" xml:space="preserve">
          <source>Parentheses can be used to enforce grouping of these operators. In the absence of parentheses, &lt;code&gt;!&lt;/code&gt; (NOT) binds most tightly, &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; (FOLLOWED BY) next most tightly, then &lt;code&gt;&amp;amp;&lt;/code&gt; (AND), with &lt;code&gt;|&lt;/code&gt; (OR) binding the least tightly.</source>
          <target state="translated">括号可用于强制对这些运算符进行分组。在没有括号的情况下， &lt;code&gt;!&lt;/code&gt; （NOT）绑定最紧密， &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; （FOLLOWED BY）紧随其后，然后 &lt;code&gt;&amp;amp;&lt;/code&gt; （AND），用 &lt;code&gt;|&lt;/code&gt; （OR）绑定最少。</target>
        </trans-unit>
        <trans-unit id="1050a7f51685a531fe35b29d9845b1171bb5126c" translate="yes" xml:space="preserve">
          <source>Parentheses, which can be used to provide filter expressions or define the order of path evaluation.</source>
          <target state="translated">括号,可以用来提供过滤表达式或定义路径评估的顺序。</target>
        </trans-unit>
        <trans-unit id="dde89c96be949ecdb36498952ab75fb083c95513" translate="yes" xml:space="preserve">
          <source>Parse and validate the reloptions array for an index. This is called only when a non-null reloptions array exists for the index. &lt;em&gt;&lt;code&gt;reloptions&lt;/code&gt;&lt;/em&gt; is a &lt;code&gt;text&lt;/code&gt; array containing entries of the form &lt;code&gt;name&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;value&lt;/code&gt;. The function should construct a &lt;code&gt;bytea&lt;/code&gt; value, which will be copied into the &lt;code&gt;rd_options&lt;/code&gt; field of the index's relcache entry. The data contents of the &lt;code&gt;bytea&lt;/code&gt; value are open for the access method to define; most of the standard access methods use struct &lt;code&gt;StdRdOptions&lt;/code&gt;. When &lt;em&gt;&lt;code&gt;validate&lt;/code&gt;&lt;/em&gt; is true, the function should report a suitable error message if any of the options are unrecognized or have invalid values; when &lt;em&gt;&lt;code&gt;validate&lt;/code&gt;&lt;/em&gt; is false, invalid entries should be silently ignored. (&lt;em&gt;&lt;code&gt;validate&lt;/code&gt;&lt;/em&gt; is false when loading options already stored in &lt;code&gt;pg_catalog&lt;/code&gt;; an invalid entry could only be found if the access method has changed its rules for options, and in that case ignoring obsolete entries is appropriate.) It is OK to return NULL if default behavior is wanted.</source>
          <target state="translated">解析并验证索引的reloptions数组。仅当索引存在非空reloptions数组时才调用此方法。&lt;em&gt; &lt;code&gt;reloptions&lt;/code&gt; &lt;/em&gt;是一个 &lt;code&gt;text&lt;/code&gt; 数组，其中包含形式为 &lt;code&gt;name&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; 的条目。该函数应构造一个 &lt;code&gt;bytea&lt;/code&gt; 值，该值将被复制到索引的relcache条目的 &lt;code&gt;rd_options&lt;/code&gt; 字段中。将打开 &lt;code&gt;bytea&lt;/code&gt; 值的数据内容以供访问方法定义；大多数标准访问方法都使用struct &lt;code&gt;StdRdOptions&lt;/code&gt; 。当&lt;em&gt; &lt;code&gt;validate&lt;/code&gt; &lt;/em&gt;为true时，如果任何选项无法识别或具有无效值，则该函数应报告适当的错误消息；什么时候&lt;em&gt; &lt;code&gt;validate&lt;/code&gt; &lt;/em&gt;为false，无效条目应静默忽略。 （当加载已经存储在 &lt;code&gt;pg_catalog&lt;/code&gt; 中的选项时，&lt;em&gt; &lt;code&gt;validate&lt;/code&gt; &lt;/em&gt;为false；仅当访问方法更改了选项规则时才找到无效的条目，在这种情况下，忽略过时的条目是适当的。）如果默认行为，则返回NULL是可以的。被通缉。</target>
        </trans-unit>
        <trans-unit id="e963287c4fec77476e5d1bf8476b1e7cc102ae88" translate="yes" xml:space="preserve">
          <source>Parse system include files as well.</source>
          <target state="translated">也可以解析系统包含文件。</target>
        </trans-unit>
        <trans-unit id="0c8772d05d1a8b9d8d78cf0c1c4a6eb499eca0c8" translate="yes" xml:space="preserve">
          <source>Parser Stage</source>
          <target state="translated">解析器阶段</target>
        </trans-unit>
        <trans-unit id="efdb99a054fb37fae9696b10ed15efeeb9f36b28" translate="yes" xml:space="preserve">
          <source>Parsers</source>
          <target state="translated">Parsers</target>
        </trans-unit>
        <trans-unit id="284615f8b9e452b1f47ea07fb3256c3c1e7eaa1e" translate="yes" xml:space="preserve">
          <source>Parses the given document and returns true if the document is well-formed XML. (Note: this is an alias for the standard PostgreSQL function &lt;code&gt;xml_is_well_formed()&lt;/code&gt;. The name &lt;code&gt;xml_valid()&lt;/code&gt; is technically incorrect since validity and well-formedness have different meanings in XML.)</source>
          <target state="translated">解析给定的文档，如果文档是格式正确的XML，则返回true。（注意：这是标准PostgreSQL函数 &lt;code&gt;xml_is_well_formed()&lt;/code&gt; 的别名。由于有效性和格式正确在XML中的含义不同，因此名称 &lt;code&gt;xml_valid()&lt;/code&gt; 在技​​术上是不正确的。）</target>
        </trans-unit>
        <trans-unit id="b58d58ace5fa0761b582d29360f9eac7d42ba9f0" translate="yes" xml:space="preserve">
          <source>Parsing for arguments stops at the end of the line, or when another unquoted backslash is found. An unquoted backslash is taken as the beginning of a new meta-command. The special sequence &lt;code&gt;\\&lt;/code&gt; (two backslashes) marks the end of arguments and continues parsing SQL commands, if any. That way SQL and psql commands can be freely mixed on a line. But in any case, the arguments of a meta-command cannot continue beyond the end of the line.</source>
          <target state="translated">对参数的解析在该行的结尾处停止，或者在找到另一个未引用的反斜杠时停止。无引号的反斜杠被视为新元命令的开始。特殊序列 &lt;code&gt;\\&lt;/code&gt; （两个反斜杠）标记参数的结尾，并继续解析SQL命令（如果有）。这样，SQL和psql命令可以自由地混合在一行上。但是无论如何，元命令的参数不能继续超出行尾。</target>
        </trans-unit>
        <trans-unit id="07c159051320590e27d53f2ca68bc5552c059bb0" translate="yes" xml:space="preserve">
          <source>Part II. The SQL Language</source>
          <target state="translated">第二部分。SQL语言</target>
        </trans-unit>
        <trans-unit id="ed99b73ba1d17331570cbb8c11cb9612833219a4" translate="yes" xml:space="preserve">
          <source>Part III. Server Administration</source>
          <target state="translated">第三部分.服务器管理</target>
        </trans-unit>
        <trans-unit id="233b8f2c1ff53528b0a2395bfd96a5533e5bf211" translate="yes" xml:space="preserve">
          <source>Part VII. Internals</source>
          <target state="translated">第七部分.内部结构</target>
        </trans-unit>
        <trans-unit id="1c0b1424932f39a83140c4ab14b4b9ddde6b4f52" translate="yes" xml:space="preserve">
          <source>Part VIII. Appendixes</source>
          <target state="translated">第八部分.附录</target>
        </trans-unit>
        <trans-unit id="53657ace24d508d9d61d6689474a05a11f116ca4" translate="yes" xml:space="preserve">
          <source>Partial (including parallel) aggregation is currently not supported for ordered-set aggregates. Also, it will never be used for aggregate calls that include &lt;code&gt;DISTINCT&lt;/code&gt; or &lt;code&gt;ORDER BY&lt;/code&gt; clauses, since those semantics cannot be supported during partial aggregation.</source>
          <target state="translated">有序集聚合当前不支持部分（包括并行）聚合。而且，它将永远不会用于包含 &lt;code&gt;DISTINCT&lt;/code&gt; 或 &lt;code&gt;ORDER BY&lt;/code&gt; 子句的聚集调用，因为在部分聚集期间不支持这些语义。</target>
        </trans-unit>
        <trans-unit id="6893b79566df0f4ab433d9b0d800d95d1637ec25" translate="yes" xml:space="preserve">
          <source>Partial Indexes</source>
          <target state="translated">部分索引</target>
        </trans-unit>
        <trans-unit id="21eb60b5918acacccb4909c31bcd93a4758e3020" translate="yes" xml:space="preserve">
          <source>Partial Mode</source>
          <target state="translated">部分模式</target>
        </trans-unit>
        <trans-unit id="f7fabd14af4eb6ccfa3f503f4e268b2ad2693497" translate="yes" xml:space="preserve">
          <source>Partial indexes also have interesting interactions with index-only scans. Consider the partial index shown in &lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX3&quot;&gt;Example 11.3&lt;/a&gt;:</source>
          <target state="translated">部分索引还与仅索引扫描有有趣的交互。考虑&lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX3&quot;&gt;示例11.3中&lt;/a&gt;显示的部分索引：</target>
        </trans-unit>
        <trans-unit id="943df06a52fbfe34ca375a62898de53e7d01f42f" translate="yes" xml:space="preserve">
          <source>Partition</source>
          <target state="translated">Partition</target>
        </trans-unit>
        <trans-unit id="7a5ba09370f100d4b05c522688c9cba42e037f6a" translate="yes" xml:space="preserve">
          <source>Partition pruning can be disabled using the &lt;a href=&quot;runtime-config-query#GUC-ENABLE-PARTITION-PRUNING&quot;&gt;enable_partition_pruning&lt;/a&gt; setting.</source>
          <target state="translated">可以使用&lt;a href=&quot;runtime-config-query#GUC-ENABLE-PARTITION-PRUNING&quot;&gt;enable_partition_pruning&lt;/a&gt;设置禁用分区修剪。</target>
        </trans-unit>
        <trans-unit id="2325b1acc0d3782c122e1bc1c9eed9984fc2f19a" translate="yes" xml:space="preserve">
          <source>Partition pruning can be performed not only during the planning of a given query, but also during its execution. This is useful as it can allow more partitions to be pruned when clauses contain expressions whose values are not known at query planning time, for example, parameters defined in a &lt;code&gt;PREPARE&lt;/code&gt; statement, using a value obtained from a subquery, or using a parameterized value on the inner side of a nested loop join. Partition pruning during execution can be performed at any of the following times:</source>
          <target state="translated">分区修剪不仅可以在规划给定查询的过程中执行，还可以在其执行过程中执行。这很有用，因为当子句包含其值在查询计划时未知的表达式时（例如，在 &lt;code&gt;PREPARE&lt;/code&gt; 语句中定义的参数，使用从子查询获得的值或在以下位置使用参数化的值），它可以允许修剪更多分区：嵌套循环联接的内侧。可以在以下任意时间执行执行期间的分区修剪：</target>
        </trans-unit>
        <trans-unit id="a5a934d5fd56ebc9886a2336d4cf199c8f485ebd" translate="yes" xml:space="preserve">
          <source>Partitioned table (relation)</source>
          <target state="translated">分区表</target>
        </trans-unit>
        <trans-unit id="25be32546f15fa3443a67e839c875e6c98ffb53d" translate="yes" xml:space="preserve">
          <source>Partitioned tables do not support &lt;code&gt;EXCLUDE&lt;/code&gt; constraints; however, you can define these constraints on individual partitions.</source>
          <target state="translated">分区表不支持 &lt;code&gt;EXCLUDE&lt;/code&gt; 约束。但是，您可以在单个分区上定义这些约束。</target>
        </trans-unit>
        <trans-unit id="cdd1ab913d96a23c99606f41fe3792bb2b1fe894" translate="yes" xml:space="preserve">
          <source>Partitioning of big collections and the proper use of GIN and GiST indexes allows the implementation of very fast searches with online update. Partitioning can be done at the database level using table inheritance, or by distributing documents over servers and collecting external search results, e.g. via &lt;a href=&quot;ddl-foreign-data&quot;&gt;Foreign Data&lt;/a&gt; access. The latter is possible because ranking functions use only local information.</source>
          <target state="translated">大集合的分区以及GIN和GiST索引的正确使用允许通过在线更新实现非常快速的搜索。可以使用表继承在数据库级别进行分区，也可以通过在服务器上分发文档并收集外部搜索结果（例如，通过&lt;a href=&quot;ddl-foreign-data&quot;&gt;外部数据&lt;/a&gt;访问）来进行分区。后者是可能的，因为排名功能仅使用本地信息。</target>
        </trans-unit>
        <trans-unit id="a24ec4cff1b6c6f9a0a6c355299a351c0f004fce" translate="yes" xml:space="preserve">
          <source>Partitioning of big collections and the proper use of GIN and GiST indexes allows the implementation of very fast searches with online update. Partitioning can be done at the database level using table inheritance, or by distributing documents over servers and collecting external search results, e.g., via &lt;a href=&quot;ddl-foreign-data&quot;&gt;Foreign Data&lt;/a&gt; access. The latter is possible because ranking functions use only local information.</source>
          <target state="translated">大集合的分区以及GIN和GiST索引的正确使用允许通过在线更新实现非常快速的搜索。可以使用表继承在数据库级别进行分区，也可以通过在服务器上分发文档并收集外部搜索结果（例如，通过&lt;a href=&quot;ddl-foreign-data&quot;&gt;外部数据&lt;/a&gt;访问）来进行分区。后者是可能的，因为排名功能仅使用本地信息。</target>
        </trans-unit>
        <trans-unit id="de0bffd921d00f01c704a415da77618af1ad1157" translate="yes" xml:space="preserve">
          <source>Partitioning refers to splitting what is logically one large table into smaller physical pieces. Partitioning can provide several benefits:</source>
          <target state="translated">分区指的是将逻辑上的一张大表分割成较小的物理块。分区可以提供若干好处。</target>
        </trans-unit>
        <trans-unit id="7c73b5aa4d6c05a53fb97d25c9d92f2517cfd521" translate="yes" xml:space="preserve">
          <source>Partitioning strategy; &lt;code&gt;h&lt;/code&gt; = hash partitioned table, &lt;code&gt;l&lt;/code&gt; = list partitioned table, &lt;code&gt;r&lt;/code&gt; = range partitioned table</source>
          <target state="translated">分区策略； &lt;code&gt;h&lt;/code&gt; =哈希分区表， &lt;code&gt;l&lt;/code&gt; =列表分区表， &lt;code&gt;r&lt;/code&gt; =范围分区表</target>
        </trans-unit>
        <trans-unit id="ac39e0014a08ee6c92f0e5cdb5959d966b4de171" translate="yes" xml:space="preserve">
          <source>Partitions can also be foreign tables, although they have some limitations that normal tables do not; see &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt; for more information.</source>
          <target state="translated">分区也可以是外部表，尽管它们具有普通表所没有的一些限制。有关更多信息，请参见&lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="742a14b2e0099a02fc2828373fdc246b43a7d658" translate="yes" xml:space="preserve">
          <source>Partitions cannot have columns that are not present in the parent. It is not possible to specify columns when creating partitions with &lt;code&gt;CREATE TABLE&lt;/code&gt;, nor is it possible to add columns to partitions after-the-fact using &lt;code&gt;ALTER TABLE&lt;/code&gt;. Tables may be added as a partition with &lt;code&gt;ALTER TABLE ... ATTACH PARTITION&lt;/code&gt; only if their columns exactly match the parent.</source>
          <target state="translated">分区不能具有父级中不存在的列。使用 &lt;code&gt;CREATE TABLE&lt;/code&gt; 创建分区时，不能指定列，也不能在事后使用 &lt;code&gt;ALTER TABLE&lt;/code&gt; 向分区中添加列。仅当表的列与父表完全匹配时，才可以使用 &lt;code&gt;ALTER TABLE ... ATTACH PARTITION&lt;/code&gt; 添加为分区。</target>
        </trans-unit>
        <trans-unit id="90542a9f44eb209be50c576524ab51cf75180838" translate="yes" xml:space="preserve">
          <source>Partitions may themselves be defined as partitioned tables, using what is called &lt;em&gt;sub-partitioning&lt;/em&gt;. Partitions may have their own indexes, constraints and default values, distinct from those of other partitions. See &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for more details on creating partitioned tables and partitions.</source>
          <target state="translated">分区本身可以使用所谓的&lt;em&gt;sub-partitioning&lt;/em&gt;定义为分区表。分区可能具有自己的索引，约束和默认值，与其他分区的索引，约束和默认值不同。有关创建分区表和分区的更多详细信息，请参见&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0fe4b4dd2ad3e0c4391acf69fe76d976b85276f5" translate="yes" xml:space="preserve">
          <source>Partitions thus created are in every way normal PostgreSQL tables (or, possibly, foreign tables). It is possible to specify a tablespace and storage parameters for each partition separately.</source>
          <target state="translated">这样创建的分区在各方面都是正常的PostgreSQL表(也可能是外表)。可以为每个分区分别指定表空间和存储参数。</target>
        </trans-unit>
        <trans-unit id="88b62432a05ee62c1b6215e5aa74e2720815cc44" translate="yes" xml:space="preserve">
          <source>Parts of the GEQO module are adapted from D. Whitley's Genitor algorithm.</source>
          <target state="translated">GEQO模块的部分内容改编自D.Whitley的Genitor算法。</target>
        </trans-unit>
        <trans-unit id="f1c5d9114d4f8eeeec0857bd19317d948e267875" translate="yes" xml:space="preserve">
          <source>Pass the option &lt;code&gt;name&lt;/code&gt; to the output plugin with, if specified, the option value &lt;code&gt;value&lt;/code&gt;. Which options exist and their effects depends on the used output plugin.</source>
          <target state="translated">将选项 &lt;code&gt;name&lt;/code&gt; （如果指定）与选项值 &lt;code&gt;value&lt;/code&gt; 一起传递到输出插件。存在哪些选项及其效果取决于所使用的输出插件。</target>
        </trans-unit>
        <trans-unit id="adee4d3938c90062826aa15c6cd38c8f321a8960" translate="yes" xml:space="preserve">
          <source>Password (possibly encrypted); null if none. See &lt;a href=&quot;catalog-pg-authid&quot;&gt;&lt;code&gt;pg_authid&lt;/code&gt;&lt;/a&gt; for details of how encrypted passwords are stored.</source>
          <target state="translated">密码（可能已加密）；如果没有，则为null。有关如何存储加密密码的详细信息，请参见&lt;a href=&quot;catalog-pg-authid&quot;&gt; &lt;code&gt;pg_authid&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="99366622edd98624e0f268beb5dfad9b43284c50" translate="yes" xml:space="preserve">
          <source>Password (possibly encrypted); null if none. The format depends on the form of encryption used.</source>
          <target state="translated">密码(可能是加密的);如果没有,则为空。格式取决于使用的加密形式。</target>
        </trans-unit>
        <trans-unit id="e6148812de885ba8e1911ccd743a2dc2463667a7" translate="yes" xml:space="preserve">
          <source>Password Authentication</source>
          <target state="translated">密码认证</target>
        </trans-unit>
        <trans-unit id="e8e30ae74424dc989ae9149964d67afb93a52bdb" translate="yes" xml:space="preserve">
          <source>Password Encryption</source>
          <target state="translated">密码加密</target>
        </trans-unit>
        <trans-unit id="36eca0e0aafbe2102ac86aee3d25cb85966cbaa6" translate="yes" xml:space="preserve">
          <source>Password expiry time (only used for password authentication)</source>
          <target state="translated">密码到期时间(仅用于密码认证)。</target>
        </trans-unit>
        <trans-unit id="de5ff361027e5b08609865471d6dc5846a389286" translate="yes" xml:space="preserve">
          <source>Password expiry time (only used for password authentication); null if no expiration</source>
          <target state="translated">密码过期时间(仅用于密码认证);如果没有过期时间,则为空。</target>
        </trans-unit>
        <trans-unit id="238db8fa438548c1928f9502d7d8e1e30eb6d531" translate="yes" xml:space="preserve">
          <source>Password for the user to run the service as.</source>
          <target state="translated">用户运行服务的密码。</target>
        </trans-unit>
        <trans-unit id="3fa38ad80d289fe4c73a95809bdea71d6cbf450b" translate="yes" xml:space="preserve">
          <source>Password for user to bind to the directory with to perform the search when doing search+bind authentication.</source>
          <target state="translated">当进行搜索+绑定认证时,用户要与目录绑定的密码,以执行搜索。</target>
        </trans-unit>
        <trans-unit id="d33984b00815ba0da90a3eeaeb545efb634cbde4" translate="yes" xml:space="preserve">
          <source>Path construction using functions:</source>
          <target state="translated">使用函数构建路径。</target>
        </trans-unit>
        <trans-unit id="463f854670c23f477bbd78e96423f8e31931e339" translate="yes" xml:space="preserve">
          <source>Path literals of JSON primitive types: Unicode text, numeric, true, false, or null.</source>
          <target state="translated">JSON基元类型的路径字元。Unicode文本、数字、真、假或空。</target>
        </trans-unit>
        <trans-unit id="7b6339b7ad3d2b4abc5be8c19dc30583042c4165" translate="yes" xml:space="preserve">
          <source>Path of a Query</source>
          <target state="translated">查询路径</target>
        </trans-unit>
        <trans-unit id="266a8e23c8475feda63519f1c3d2f320f2aaac65" translate="yes" xml:space="preserve">
          <source>Path of shared library that implements language</source>
          <target state="translated">实现语言的共享库的路径</target>
        </trans-unit>
        <trans-unit id="6a3675336ca9e8caece923ce6c69021ab35c9b34" translate="yes" xml:space="preserve">
          <source>Path variables listed in &lt;a href=&quot;datatype-json#TYPE-JSONPATH-VARIABLES&quot;&gt;Table 8.24&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;datatype-json#TYPE-JSONPATH-VARIABLES&quot;&gt;表8.24中&lt;/a&gt;列出了路径变量。</target>
        </trans-unit>
        <trans-unit id="55707d92267c5187de428b55c28d908802787d98" translate="yes" xml:space="preserve">
          <source>Paths are output using the first or second syntax, as appropriate.</source>
          <target state="translated">路径根据情况使用第一或第二语法输出。</target>
        </trans-unit>
        <trans-unit id="d21eb60eb90443c1e0fde7a365afe587f415ae66" translate="yes" xml:space="preserve">
          <source>Paths are represented by lists of connected points. Paths can be &lt;em&gt;open&lt;/em&gt;, where the first and last points in the list are considered not connected, or &lt;em&gt;closed&lt;/em&gt;, where the first and last points are considered connected.</source>
          <target state="translated">路径由连接点列表表示。路径可以是&lt;em&gt;开放的&lt;/em&gt;，其中列表中的第一个和最后一个点被认为是未连接，或者&lt;em&gt;关闭&lt;/em&gt;，其中第一个和最后一个点被认为连接。</target>
        </trans-unit>
        <trans-unit id="1fff6a31661b491fc40cc9c1ad7fe5e479cb7500" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Pattern</target>
        </trans-unit>
        <trans-unit id="535ab3a1c5459ace2d0b0bcb8fc022e58a4100d9" translate="yes" xml:space="preserve">
          <source>Pattern Matching</source>
          <target state="translated">模式匹配</target>
        </trans-unit>
        <trans-unit id="1a43195d59d6b988e5bc825ea91ee5fa2ee54455" translate="yes" xml:space="preserve">
          <source>Pattern Matching: LIKE</source>
          <target state="translated">模式匹配:LIKE</target>
        </trans-unit>
        <trans-unit id="577a01dd1c0e8f649068e70f9cf054970915cb36" translate="yes" xml:space="preserve">
          <source>Pattern Matching: POSIX Regular Expressions</source>
          <target state="translated">模式匹配:POSIX正则表达式。</target>
        </trans-unit>
        <trans-unit id="1aca0dbf2888e4f1bc7d10adb1a49bb94a808a60" translate="yes" xml:space="preserve">
          <source>Pattern Matching: SIMILAR TO Regular Expressions</source>
          <target state="translated">模式匹配:类似于正则表达式。</target>
        </trans-unit>
        <trans-unit id="2cca6a6a36d34faa5c5f178fbe489846badc8fb5" translate="yes" xml:space="preserve">
          <source>Pattern matching operators (&lt;code&gt;LIKE&lt;/code&gt;, &lt;code&gt;SIMILAR TO&lt;/code&gt;, and POSIX-style regular expressions); locales affect both case insensitive matching and the classification of characters by character-class regular expressions</source>
          <target state="translated">模式匹配运算符（ &lt;code&gt;LIKE&lt;/code&gt; ， &lt;code&gt;SIMILAR TO&lt;/code&gt; 和POSIX样式的正则表达式）；语言环境会影响不区分大小写的匹配和字符类正则表达式对字符的分类</target>
        </trans-unit>
        <trans-unit id="4d34f7a2b0b3b6df62a051917d7e7ac2de8a38df" translate="yes" xml:space="preserve">
          <source>Patterns</source>
          <target state="translated">Patterns</target>
        </trans-unit>
        <trans-unit id="ca382c16294c214dbe3191677fc4669d70c86654" translate="yes" xml:space="preserve">
          <source>Pauses recovery immediately (restricted to superusers by default, but other users can be granted EXECUTE to run the function).</source>
          <target state="translated">立即暂停恢复(默认情况下仅限于超级用户,但其他用户可以被授予EXECUTE运行该功能)。</target>
        </trans-unit>
        <trans-unit id="9d18ff4f9325c1d261553975b88e0f79d832a0bc" translate="yes" xml:space="preserve">
          <source>Pauses recovery. While recovery is paused, no further database changes are applied. If hot standby is active, all new queries will see the same consistent snapshot of the database, and no further query conflicts will be generated until recovery is resumed.</source>
          <target state="translated">暂停恢复。暂停恢复时,不会再应用数据库更改。如果热备用处于活动状态,所有新的查询都将看到相同的一致的数据库快照,在恢复之前不会再产生查询冲突。</target>
        </trans-unit>
        <trans-unit id="12a0f150ca4476ed5b576c007ac1865d1fb8bb74" translate="yes" xml:space="preserve">
          <source>Peer Authentication</source>
          <target state="translated">同行认证</target>
        </trans-unit>
        <trans-unit id="7140c44c7da9185cfa0b73cd8cc49f9de3bc1489" translate="yes" xml:space="preserve">
          <source>Peer authentication is only available on operating systems providing the &lt;code&gt;getpeereid()&lt;/code&gt; function, the &lt;code&gt;SO_PEERCRED&lt;/code&gt; socket parameter, or similar mechanisms. Currently that includes Linux, most flavors of BSD including macOS, and Solaris.</source>
          <target state="translated">对等身份验证仅在提供 &lt;code&gt;getpeereid()&lt;/code&gt; 函数， &lt;code&gt;SO_PEERCRED&lt;/code&gt; 套接字参数或类似机制的操作系统上可用。当前包括Linux，大多数版本的BSD（包括macOS）和Solaris。</target>
        </trans-unit>
        <trans-unit id="a4e88cdf6f01c061fef4d5d033c1f84e81c460db" translate="yes" xml:space="preserve">
          <source>Peer authentication is usually recommendable for local connections, though trust authentication might be sufficient in some circumstances. Password authentication is the easiest choice for remote connections. All the other options require some kind of external security infrastructure (usually an authentication server or a certificate authority for issuing SSL certificates), or are platform-specific.</source>
          <target state="translated">对于本地连接,通常建议采用对等认证,但在某些情况下,信任认证可能就足够了。对于远程连接,密码认证是最简单的选择。所有其他选项都需要某种外部安全基础设施(通常是认证服务器或用于签发SSL证书的证书机构),或者是特定平台。</target>
        </trans-unit>
        <trans-unit id="9cdd79a05b9da966c26a1f6a5e99a7a9fb8d64a3" translate="yes" xml:space="preserve">
          <source>Per-Command Policies</source>
          <target state="translated">每项命令政策</target>
        </trans-unit>
        <trans-unit id="ed1d3a75054b9592b198ba465dda151b09c333ea" translate="yes" xml:space="preserve">
          <source>Per-Statement Latencies</source>
          <target state="translated">每报表延迟</target>
        </trans-unit>
        <trans-unit id="db0ae07882c18b5649ee33de907e97a3481ed614" translate="yes" xml:space="preserve">
          <source>Per-Transaction Logging</source>
          <target state="translated">每笔交易记录</target>
        </trans-unit>
        <trans-unit id="f973c235a702ba0b4882340692bc401f9c1e7c7c" translate="yes" xml:space="preserve">
          <source>Per-index value for &lt;a href=&quot;runtime-config-client#GUC-VACUUM-CLEANUP-INDEX-SCALE-FACTOR&quot;&gt;vacuum_cleanup_index_scale_factor&lt;/a&gt;.</source>
          <target state="translated">每个索引值&lt;a href=&quot;runtime-config-client#GUC-VACUUM-CLEANUP-INDEX-SCALE-FACTOR&quot;&gt;vacuum_cleanup_index_scale_factor&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6aee541129a013df791c695dddfe4b66f3b0804a" translate="yes" xml:space="preserve">
          <source>Per-table granularity</source>
          <target state="translated">每张表的颗粒度</target>
        </trans-unit>
        <trans-unit id="df6300430e05243fb8623c3dacf21a834f4ec9db" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-ANALYZE-SCALE-FACTOR&quot;&gt;autovacuum_analyze_scale_factor&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-ANALYZE-SCALE-FACTOR&quot;&gt;autovacuum_analyze_scale_factor&lt;/a&gt;参数的每表值。</target>
        </trans-unit>
        <trans-unit id="13bcc410c7f9ecd5027e7aabb4054809e94a5637" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-ANALYZE-THRESHOLD&quot;&gt;autovacuum_analyze_threshold&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-ANALYZE-THRESHOLD&quot;&gt;autovacuum_analyze_threshold&lt;/a&gt;参数的每表值。</target>
        </trans-unit>
        <trans-unit id="b4cc49570c37ddaf0ad982835227bdfeb5fb34fc" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-FREEZE-MAX-AGE&quot;&gt;autovacuum_freeze_max_age&lt;/a&gt; parameter. Note that autovacuum will ignore per-table &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; parameters that are larger than the system-wide setting (it can only be set smaller).</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-FREEZE-MAX-AGE&quot;&gt;autovacuum_freeze_max_age&lt;/a&gt;参数的每表值。请注意，autovacuum将忽略每个表的 &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; 参数，这些参数大于系统范围的设置（只能设置为较小）。</target>
        </trans-unit>
        <trans-unit id="adc3bbc6bde46e7a977a3d025522a0b130c2221c" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE&quot;&gt;autovacuum_multixact_freeze_max_age&lt;/a&gt; parameter. Note that autovacuum will ignore per-table &lt;code&gt;autovacuum_multixact_freeze_max_age&lt;/code&gt; parameters that are larger than the system-wide setting (it can only be set smaller).</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE&quot;&gt;autovacuum_multixact_freeze_max_age&lt;/a&gt;参数的每表值。请注意，autovacuum将忽略每个表的 &lt;code&gt;autovacuum_multixact_freeze_max_age&lt;/code&gt; 参数，这些参数大于系统范围的设置（只能设置为较小）。</target>
        </trans-unit>
        <trans-unit id="52ee90bf83a221126d345af63a697f023bf7aaf2" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-COST-DELAY&quot;&gt;autovacuum_vacuum_cost_delay&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-COST-DELAY&quot;&gt;autovacuum_vacuum_cost_delay&lt;/a&gt;参数的每表值。</target>
        </trans-unit>
        <trans-unit id="b8f18627239c76784b53c354db6754ba7815a1a8" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-COST-LIMIT&quot;&gt;autovacuum_vacuum_cost_limit&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-COST-LIMIT&quot;&gt;autovacuum_vacuum_cost_limit&lt;/a&gt;参数的每表值。</target>
        </trans-unit>
        <trans-unit id="4d12e56fad0fc8cfde31ec88733d4a8a4914d22d" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-INSERT-SCALE-FACTOR&quot;&gt;autovacuum_vacuum_insert_scale_factor&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-INSERT-SCALE-FACTOR&quot;&gt;autovacuum_vacuum_insert_scale_factor&lt;/a&gt;参数的每个表的值。</target>
        </trans-unit>
        <trans-unit id="d66effb5fc4a6d26e983439f8ea5df04cb08e89f" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-INSERT-THRESHOLD&quot;&gt;autovacuum_vacuum_insert_threshold&lt;/a&gt; parameter. The special value of -1 may be used to disable insert vacuums on the table.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-INSERT-THRESHOLD&quot;&gt;autovacuum_vacuum_insert_threshold&lt;/a&gt;参数的每个表的值。特殊值-1可用于禁用工作台上的插入式吸尘器。</target>
        </trans-unit>
        <trans-unit id="3dd4eed61fa80fd43095c3741dd5dd959fac77e2" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-SCALE-FACTOR&quot;&gt;autovacuum_vacuum_scale_factor&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-SCALE-FACTOR&quot;&gt;autovacuum_vacuum_scale_factor&lt;/a&gt;参数的每表值。</target>
        </trans-unit>
        <trans-unit id="4413713442ca0dbea5e7f8130793f8e4a24e0cef" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-THRESHOLD&quot;&gt;autovacuum_vacuum_threshold&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-THRESHOLD&quot;&gt;autovacuum_vacuum_threshold&lt;/a&gt;参数的每表值。</target>
        </trans-unit>
        <trans-unit id="3d2800f8c07e42c6c33e28d11f8d0822c4287722" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-LOG-AUTOVACUUM-MIN-DURATION&quot;&gt;log_autovacuum_min_duration&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-LOG-AUTOVACUUM-MIN-DURATION&quot;&gt;log_autovacuum_min_duration&lt;/a&gt;参数的每表值。</target>
        </trans-unit>
        <trans-unit id="223ad5e2d00a73119ddde400e71e2b1ba9280ccb" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-client#GUC-VACUUM-FREEZE-MIN-AGE&quot;&gt;vacuum_freeze_min_age&lt;/a&gt; parameter. Note that autovacuum will ignore per-table &lt;code&gt;autovacuum_freeze_min_age&lt;/code&gt; parameters that are larger than half the system-wide &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-FREEZE-MAX-AGE&quot;&gt;autovacuum_freeze_max_age&lt;/a&gt; setting.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-client#GUC-VACUUM-FREEZE-MIN-AGE&quot;&gt;vacuum_freeze_min_age&lt;/a&gt;参数的每表值。请注意，autovacuum将忽略每个表的 &lt;code&gt;autovacuum_freeze_min_age&lt;/code&gt; 参数，该参数大于系统范围的&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-FREEZE-MAX-AGE&quot;&gt;autovacuum_freeze_max_age&lt;/a&gt;设置的一半。</target>
        </trans-unit>
        <trans-unit id="68a4d3118ea45821db0cebd7519f0ea146995887" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-client#GUC-VACUUM-FREEZE-TABLE-AGE&quot;&gt;vacuum_freeze_table_age&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-client#GUC-VACUUM-FREEZE-TABLE-AGE&quot;&gt;vacuum_freeze_table_age&lt;/a&gt;参数的每表值。</target>
        </trans-unit>
        <trans-unit id="aed713d91e51cd08cd23d16d2810e44fceb208ef" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-MIN-AGE&quot;&gt;vacuum_multixact_freeze_min_age&lt;/a&gt; parameter. Note that autovacuum will ignore per-table &lt;code&gt;autovacuum_multixact_freeze_min_age&lt;/code&gt; parameters that are larger than half the system-wide &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE&quot;&gt;autovacuum_multixact_freeze_max_age&lt;/a&gt; setting.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-MIN-AGE&quot;&gt;vacuum_multixact_freeze_min_age&lt;/a&gt;参数的每表值。请注意，autovacuum将忽略每个表的 &lt;code&gt;autovacuum_multixact_freeze_min_age&lt;/code&gt; 参数，该参数大于系统范围&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE&quot;&gt;autovacuum_multixact_freeze_max_age&lt;/a&gt;设置的一半。</target>
        </trans-unit>
        <trans-unit id="3d6a639607b9fecb0af2c41612e5b2768fa56a2e" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-TABLE-AGE&quot;&gt;vacuum_multixact_freeze_table_age&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-TABLE-AGE&quot;&gt;vacuum_multixact_freeze_table_age&lt;/a&gt;参数的每表值。</target>
        </trans-unit>
        <trans-unit id="e975b3d41bbeabc6eb00c97d7e30fbafd1d2457e" translate="yes" xml:space="preserve">
          <source>Percentage of dead tuples</source>
          <target state="translated">死掉的元组的百分比</target>
        </trans-unit>
        <trans-unit id="b0cd75c0030dceadd02cefb1f4f8cdfe1c43c19b" translate="yes" xml:space="preserve">
          <source>Percentage of free space</source>
          <target state="translated">自由空间的百分比</target>
        </trans-unit>
        <trans-unit id="026e26a6ed3d13c32e91d16667b4fce6169c8f91" translate="yes" xml:space="preserve">
          <source>Percentage of live tuples</source>
          <target state="translated">活元组的百分比</target>
        </trans-unit>
        <trans-unit id="20574a809cad3d22e4de78bb07a64ea3c84d8769" translate="yes" xml:space="preserve">
          <source>Percentage of table scanned</source>
          <target state="translated">扫描的表格百分比</target>
        </trans-unit>
        <trans-unit id="cecafd6247612c74017c4324067017c519c963f3" translate="yes" xml:space="preserve">
          <source>Perform &amp;ldquo;full&amp;rdquo; vacuuming.</source>
          <target state="translated">执行&amp;ldquo;完全&amp;rdquo;吸尘。</target>
        </trans-unit>
        <trans-unit id="feca8a5ed5223a5437966dd095f2b42b084450e7" translate="yes" xml:space="preserve">
          <source>Perform SCRAM-SHA-256 authentication to verify the user's password. See &lt;a href=&quot;auth-password&quot;&gt;Section 20.5&lt;/a&gt; for details.</source>
          <target state="translated">执行SCRAM-SHA-256身份验证以验证用户密码。有关详细信息，请参见&lt;a href=&quot;auth-password&quot;&gt;第20.5节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cee9d96cd6bf238088136c000e640e78e06aa374" translate="yes" xml:space="preserve">
          <source>Perform SCRAM-SHA-256 or MD5 authentication to verify the user's password. See &lt;a href=&quot;auth-password&quot;&gt;Section 20.5&lt;/a&gt; for details.</source>
          <target state="translated">执行SCRAM-SHA-256或MD5身份验证以验证用户密码。有关详细信息，请参见&lt;a href=&quot;auth-password&quot;&gt;第20.5节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7e17faacf8a7556f475f5c4f9f96ab42fd904d29" translate="yes" xml:space="preserve">
          <source>Perform a variable assignment, like the &lt;code&gt;\set&lt;/code&gt; meta-command. Note that you must separate name and value, if any, by an equal sign on the command line. To unset a variable, leave off the equal sign. To set a variable with an empty value, use the equal sign but leave off the value. These assignments are done during command line processing, so variables that reflect connection state will get overwritten later.</source>
          <target state="translated">执行变量分配，例如 &lt;code&gt;\set&lt;/code&gt; meta-command。请注意，必须在命令行上用等号分隔名称和值（如果有）。要取消设置变量，请取消等号。要将变量设置为空值，请使用等号，但不要使用该值。这些分配是在命令行处理期间完成的，因此反映连接状态的变量将在以后被覆盖。</target>
        </trans-unit>
        <trans-unit id="fb9e20f68ce84ca1bc08bc43d32bfdf37750e58d" translate="yes" xml:space="preserve">
          <source>Perform index vacuum and index cleanup phases of &lt;code&gt;VACUUM&lt;/code&gt; in parallel using &lt;code&gt;integer&lt;/code&gt; background workers (for the details of each vacuum phase, please refer to &lt;a href=&quot;progress-reporting#VACUUM-PHASES&quot;&gt;Table 27.37&lt;/a&gt;). The number of workers used to perform the operation is equal to the number of indexes on the relation that support parallel vacuum which is limited by the number of workers specified with &lt;code&gt;PARALLEL&lt;/code&gt; option if any which is further limited by &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-MAINTENANCE&quot;&gt;max_parallel_maintenance_workers&lt;/a&gt;. An index can participate in parallel vacuum if and only if the size of the index is more than &lt;a href=&quot;runtime-config-query#GUC-MIN-PARALLEL-INDEX-SCAN-SIZE&quot;&gt;min_parallel_index_scan_size&lt;/a&gt;. Please note that it is not guaranteed that the number of parallel workers specified in &lt;code&gt;integer&lt;/code&gt; will be used during execution. It is possible for a vacuum to run with fewer workers than specified, or even with no workers at all. Only one worker can be used per index. So parallel workers are launched only when there are at least &lt;code&gt;2&lt;/code&gt; indexes in the table. Workers for vacuum are launched before the start of each phase and exit at the end of the phase. These behaviors might change in a future release. This option can't be used with the &lt;code&gt;FULL&lt;/code&gt; option.</source>
          <target state="translated">使用 &lt;code&gt;integer&lt;/code&gt; 后台工作程序并行执行 &lt;code&gt;VACUUM&lt;/code&gt; 的索引真空和索引清理阶段（有关每个真空阶段的详细信息，请参阅&lt;a href=&quot;progress-reporting#VACUUM-PHASES&quot;&gt;表27.37&lt;/a&gt;）。用于执行操作的工作程序数量等于支持并行真空的关系上的索引数量，该索引数量受 &lt;code&gt;PARALLEL&lt;/code&gt; 选项指定的工作程序数量限制（如果有的话，&lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-MAINTENANCE&quot;&gt;max_parallel_maintenance_workers&lt;/a&gt;进一步限制了该数量）。且仅当索引的大小大于&lt;a href=&quot;runtime-config-query#GUC-MIN-PARALLEL-INDEX-SCAN-SIZE&quot;&gt;min_parallel_index_scan_size时，&lt;/a&gt;索引才能参与并行真空。请注意，不能保证以 &lt;code&gt;integer&lt;/code&gt; 指定的并行工作程序数将在执行期间使用。真空吸尘器运行的工人可能少于指定数量，甚至根本没有工人。每个索引只能使用一个工人。因此，仅当表中至少有 &lt;code&gt;2&lt;/code&gt; 索引时才启动并行工作器。抽真空的工作人员在每个阶段开始之前启动，并在阶段结束时退出。这些行为可能会在将来的版本中更改。此选项不能与 &lt;code&gt;FULL&lt;/code&gt; 选项一起使用。</target>
        </trans-unit>
        <trans-unit id="b34d3d05facf882ae3a691abd30e8b6cd4a6e677" translate="yes" xml:space="preserve">
          <source>Perform just a selected set of the normal initialization steps. &lt;code&gt;init_steps&lt;/code&gt; specifies the initialization steps to be performed, using one character per step. Each step is invoked in the specified order. The default is &lt;code&gt;dtgvp&lt;/code&gt;. The available steps are:</source>
          <target state="translated">仅执行一组选定的常规初始化步骤。 &lt;code&gt;init_steps&lt;/code&gt; 指定要执行的初始化步骤，每步使用一个字符。每个步骤均以指定的顺序调用。默认值为 &lt;code&gt;dtgvp&lt;/code&gt; 。可用步骤为：</target>
        </trans-unit>
        <trans-unit id="5f6bc160364e3493898bf7d6bb17edbe09454bda" translate="yes" xml:space="preserve">
          <source>Perform no vacuuming before running the test. This option is &lt;em&gt;necessary&lt;/em&gt; if you are running a custom test scenario that does not include the standard tables &lt;code&gt;pgbench_accounts&lt;/code&gt;, &lt;code&gt;pgbench_branches&lt;/code&gt;, &lt;code&gt;pgbench_history&lt;/code&gt;, and &lt;code&gt;pgbench_tellers&lt;/code&gt;.</source>
          <target state="translated">运行测试之前，请勿抽真空。如果您正在运行的自定义测试方案不包含标准表 &lt;code&gt;pgbench_accounts&lt;/code&gt; ， &lt;code&gt;pgbench_branches&lt;/code&gt; ， &lt;code&gt;pgbench_history&lt;/code&gt; 和 &lt;code&gt;pgbench_tellers&lt;/code&gt; ，则此选项是&lt;em&gt;必需的&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="8a366494657843694e57b5bad59c50324f01a651" translate="yes" xml:space="preserve">
          <source>Perform no vacuuming during initialization. (This option suppresses the &lt;code&gt;v&lt;/code&gt; initialization step, even if it was specified in &lt;code&gt;-I&lt;/code&gt;.)</source>
          <target state="translated">初始化期间不执行清理操作。（即使在 &lt;code&gt;-I&lt;/code&gt; 中指定了该选项，它也会禁止 &lt;code&gt;v&lt;/code&gt; 初始化步骤。）</target>
        </trans-unit>
        <trans-unit id="ae7a93c9cfd5aa5e2e72b1ed16236cb5de67de61" translate="yes" xml:space="preserve">
          <source>Perform the backup, using any convenient file-system-backup tool such as tar or cpio (not pg_dump or pg_dumpall). It is neither necessary nor desirable to stop normal operation of the database while you do this. See &lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP-DATA&quot;&gt;Section 25.3.3.3&lt;/a&gt; for things to consider during this backup.</source>
          <target state="translated">使用任何方便的文件系统备份工具（例如tar或cpio（而不是pg_dump或pg_dumpall））执行备份。在执行此操作时，既没有必要也不希望停止数据库的正常运行。有关此备份期间要考虑的事项，请参见&lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP-DATA&quot;&gt;第25.3.3.3节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d0828d0154023185a4f3f08252e7050a26fc998a" translate="yes" xml:space="preserve">
          <source>Perform the same operation and return the updated entries:</source>
          <target state="translated">执行同样的操作并返回更新后的条目。</target>
        </trans-unit>
        <trans-unit id="ca80079033f0036f2ec138c62dcdab998ede3b1d" translate="yes" xml:space="preserve">
          <source>Perform the same operation, using a sub-select in the &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="translated">使用 &lt;code&gt;WHERE&lt;/code&gt; 子句中的子选择来执行相同的操作：</target>
        </trans-unit>
        <trans-unit id="6d4af32e4acc11996347bfaec82c71604728dd29" translate="yes" xml:space="preserve">
          <source>Performance Tips</source>
          <target state="translated">性能提示</target>
        </trans-unit>
        <trans-unit id="fc8d14b954dfe439eb5ef6988b32004ef49622c0" translate="yes" xml:space="preserve">
          <source>Performs a frontend (client) copy. This is an operation that runs an SQL &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; command, but instead of the server reading or writing the specified file, psql reads or writes the file and routes the data between the server and the local file system. This means that file accessibility and privileges are those of the local user, not the server, and no SQL superuser privileges are required.</source>
          <target state="translated">执行前端（客户端）副本。此操作运行SQL &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt;命令，但是psql读取或写入文件并在服务器和本地文件系统之间路由数据，而不是由服务器读取或写入指定的文件。这意味着文件可访问性和特权是本地用户（而不是服务器）的文件可访问性和特权，并且不需要SQL超级用户特权。</target>
        </trans-unit>
        <trans-unit id="6c344e1248da1978bc3644d43b9d891fff2e39be" translate="yes" xml:space="preserve">
          <source>Peter Eisentraut &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:peter_e@gmx.net&quot;&gt;peter_e@gmx.net&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">彼得&amp;middot;艾森特拉特（Peter Eisentraut） &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:peter_e@gmx.net&quot;&gt;peter_e@gmx.net&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="da078a3d051b083b829b48a189bf09b75dac6cd7" translate="yes" xml:space="preserve">
          <source>Peter Mount &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:peter@retep.org.uk&quot;&gt;peter@retep.org.uk&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">彼得&amp;middot;芒特 &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:peter@retep.org.uk&quot;&gt;peter@retep.org.uk&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac972e7b24283f21a917e63d12ab81c028b6b619" translate="yes" xml:space="preserve">
          <source>Phantom Read</source>
          <target state="translated">幻影阅读</target>
        </trans-unit>
        <trans-unit id="f6371a4980dacd0f821ddeb75bac77ae4886ba72" translate="yes" xml:space="preserve">
          <source>Phase</source>
          <target state="translated">Phase</target>
        </trans-unit>
        <trans-unit id="042205072874b99f497a9509acb6db1b05f17fb3" translate="yes" xml:space="preserve">
          <source>Physical Storage: Database File Layout</source>
          <target state="translated">物理存储。数据库文件布局</target>
        </trans-unit>
        <trans-unit id="3fc82c3858fa9eb0fe848a4e73244b155ecf922b" translate="yes" xml:space="preserve">
          <source>Physical Storage: Database Page Layout</source>
          <target state="translated">物理存储。数据库页面布局</target>
        </trans-unit>
        <trans-unit id="bb5882e77d3988624189c0ed4e594bfe45615e1a" translate="yes" xml:space="preserve">
          <source>Physical Storage: Free Space Map</source>
          <target state="translated">物理存储。自由空间地图</target>
        </trans-unit>
        <trans-unit id="1aa3f80bb2e1afaf99e1bd935f3605582854ea4b" translate="yes" xml:space="preserve">
          <source>Physical Storage: Initialization Fork</source>
          <target state="translated">物理存储。Initialization Fork</target>
        </trans-unit>
        <trans-unit id="365026e65b63752c65e5cd29c199d84c6b17ab3e" translate="yes" xml:space="preserve">
          <source>Physical Storage: TOAST</source>
          <target state="translated">物理存储。TOAST</target>
        </trans-unit>
        <trans-unit id="2b725586447f2023155afd853eb7071d04362c03" translate="yes" xml:space="preserve">
          <source>Physical Storage: Visibility Map</source>
          <target state="translated">物理存储。可见度地图</target>
        </trans-unit>
        <trans-unit id="27e67533896359d51a605428384ec08a0b4ccbfe" translate="yes" xml:space="preserve">
          <source>Physical relation length in bytes</source>
          <target state="translated">物理关系长度(单位:字节</target>
        </trans-unit>
        <trans-unit id="53d91fab1719e32b08f04ca110073dde614b240a" translate="yes" xml:space="preserve">
          <source>Physical relation length in bytes (exact)</source>
          <target state="translated">物理关系长度,以字节为单位(精确)</target>
        </trans-unit>
        <trans-unit id="2d0ec6f0ef721a8a8cb1c82f207caf7adfca229f" translate="yes" xml:space="preserve">
          <source>Place the database cluster's data directory in a memory-backed file system (i.e. RAM disk). This eliminates all database disk I/O, but limits data storage to the amount of available memory (and perhaps swap).</source>
          <target state="translated">将数据库群集的数据目录放在内存支持的文件系统中(即RAM磁盘)。这样可以消除所有的数据库磁盘I/O,但将数据存储限制在可用的内存量上(也许还有交换)。</target>
        </trans-unit>
        <trans-unit id="763b9aa0654971e3e19fdea85c60c9a6639631aa" translate="yes" xml:space="preserve">
          <source>Place the database cluster's data directory in a memory-backed file system (i.e., RAM disk). This eliminates all database disk I/O, but limits data storage to the amount of available memory (and perhaps swap).</source>
          <target state="translated">将数据库群集的数据目录放在内存支持的文件系统中(即RAM磁盘)。这样可以消除所有的数据库磁盘I/O,但将数据存储限制在可用的内存量上(也许还有交换)。</target>
        </trans-unit>
        <trans-unit id="eeb237570f0f7f892d4ed491876f26dd479a782a" translate="yes" xml:space="preserve">
          <source>Placing &lt;code&gt;ORDER BY&lt;/code&gt; within the aggregate's regular argument list, as described so far, is used when ordering the input rows for general-purpose and statistical aggregates, for which ordering is optional. There is a subclass of aggregate functions called &lt;em&gt;ordered-set aggregates&lt;/em&gt; for which an &lt;code&gt;order_by_clause&lt;/code&gt; is &lt;em&gt;required&lt;/em&gt;, usually because the aggregate's computation is only sensible in terms of a specific ordering of its input rows. Typical examples of ordered-set aggregates include rank and percentile calculations. For an ordered-set aggregate, the &lt;code&gt;order_by_clause&lt;/code&gt; is written inside &lt;code&gt;WITHIN GROUP (...)&lt;/code&gt;, as shown in the final syntax alternative above. The expressions in the &lt;code&gt;order_by_clause&lt;/code&gt; are evaluated once per input row just like regular aggregate arguments, sorted as per the &lt;code&gt;order_by_clause&lt;/code&gt;'s requirements, and fed to the aggregate function as input arguments. (This is unlike the case for a non-&lt;code&gt;WITHIN GROUP&lt;/code&gt;&lt;code&gt;order_by_clause&lt;/code&gt;, which is not treated as argument(s) to the aggregate function.) The argument expressions preceding &lt;code&gt;WITHIN GROUP&lt;/code&gt;, if any, are called &lt;em&gt;direct arguments&lt;/em&gt; to distinguish them from the &lt;em&gt;aggregated arguments&lt;/em&gt; listed in the &lt;code&gt;order_by_clause&lt;/code&gt;. Unlike regular aggregate arguments, direct arguments are evaluated only once per aggregate call, not once per input row. This means that they can contain variables only if those variables are grouped by &lt;code&gt;GROUP BY&lt;/code&gt;; this restriction is the same as if the direct arguments were not inside an aggregate expression at all. Direct arguments are typically used for things like percentile fractions, which only make sense as a single value per aggregation calculation. The direct argument list can be empty; in this case, write just &lt;code&gt;()&lt;/code&gt; not &lt;code&gt;(*)&lt;/code&gt;. (PostgreSQL will actually accept either spelling, but only the first way conforms to the SQL standard.)</source>
          <target state="translated">到目前为止，将 &lt;code&gt;ORDER BY&lt;/code&gt; 放在聚合的常规参数列表中时，是在对通用和统计聚合的输入行进行排序时使用，排序是可选的。还有的叫聚合函数一类子&lt;em&gt;有序集聚集&lt;/em&gt;为其中 &lt;code&gt;order_by_clause&lt;/code&gt; 生成是&lt;em&gt;必需的&lt;/em&gt;，通常是因为总的计算仅在其输入行的特定顺序而言明智的。有序集合聚合的典型示例包括等级和百分位计算。对于有序集合，将 &lt;code&gt;order_by_clause&lt;/code&gt; 写入 &lt;code&gt;WITHIN GROUP (...)&lt;/code&gt; ，如上述最终语法中所示。中的表达式 &lt;code&gt;order_by_clause&lt;/code&gt; 像常规聚合参数一样，对每个输入行对order_by_clause进行一次评估，并按照 &lt;code&gt;order_by_clause&lt;/code&gt; 的要求进行排序，然后将其作为输入参数馈入聚合函数。 （这与非 &lt;code&gt;WITHIN GROUP&lt;/code&gt; &lt;code&gt;order_by_clause&lt;/code&gt; 的情况不同，后者不视为聚合函数的参数。） &lt;code&gt;WITHIN GROUP&lt;/code&gt; 之前的参数表达式（如果有的话）称为&lt;em&gt;直接参数，&lt;/em&gt;以区别于&lt;em&gt;聚合参数&lt;/em&gt;在 &lt;code&gt;order_by_clause&lt;/code&gt; 中列出。与常规聚合参数不同，直接参数每个聚合调用仅被评估一次，而不是每个输入行一次。这意味着仅当这些变量按 &lt;code&gt;GROUP BY&lt;/code&gt; 分组时，它们才能包含变量。此限制与直接参数根本不在聚合表达式中一样。直接自变量通常用于百分比分数之类的东西，百分数仅在每次聚合计算中作为单个值才有意义。直接参数列表可以为空；在这种情况下，只写 &lt;code&gt;()&lt;/code&gt; 而不是 &lt;code&gt;(*)&lt;/code&gt; 。 （PostgreSQL实际上会接受任何一种拼写，但只有第一种方式符合SQL标准。）</target>
        </trans-unit>
        <trans-unit id="050a736fd59911f8226167a2c6f31c24c2830d29" translate="yes" xml:space="preserve">
          <source>Placing the function in a &lt;code&gt;LATERAL&lt;/code&gt;&lt;code&gt;FROM&lt;/code&gt; item keeps it from being invoked more than once per row. &lt;code&gt;m.*&lt;/code&gt; is still expanded into &lt;code&gt;m.a, m.b, m.c&lt;/code&gt;, but now those variables are just references to the output of the &lt;code&gt;FROM&lt;/code&gt; item. (The &lt;code&gt;LATERAL&lt;/code&gt; keyword is optional here, but we show it to clarify that the function is getting &lt;code&gt;x&lt;/code&gt; from &lt;code&gt;some_table&lt;/code&gt;.)</source>
          <target state="translated">将函数放在 &lt;code&gt;LATERAL&lt;/code&gt; &lt;code&gt;FROM&lt;/code&gt; 项中，可以防止每行多次调用该函数。 &lt;code&gt;m.*&lt;/code&gt; 仍扩展为 &lt;code&gt;m.a, m.b, m.c&lt;/code&gt; ，但是现在这些变量只是对 &lt;code&gt;FROM&lt;/code&gt; 项输出的引用。 （ &lt;code&gt;LATERAL&lt;/code&gt; 关键字在这里是可选的，但是我们展示它来说明该功能是从 &lt;code&gt;some_table&lt;/code&gt; 获取 &lt;code&gt;x&lt;/code&gt; 的。）</target>
        </trans-unit>
        <trans-unit id="b4a1219ff91be25a0770f7df590b928d12b8a2c5" translate="yes" xml:space="preserve">
          <source>Plain &lt;code&gt;VACUUM&lt;/code&gt; (without &lt;code&gt;FULL&lt;/code&gt;) simply reclaims space and makes it available for re-use. This form of the command can operate in parallel with normal reading and writing of the table, as an exclusive lock is not obtained. However, extra space is not returned to the operating system (in most cases); it's just kept available for re-use within the same table. &lt;code&gt;VACUUM FULL&lt;/code&gt; rewrites the entire contents of the table into a new disk file with no extra space, allowing unused space to be returned to the operating system. This form is much slower and requires an exclusive lock on each table while it is being processed.</source>
          <target state="translated">普通 &lt;code&gt;VACUUM&lt;/code&gt; （无 &lt;code&gt;FULL&lt;/code&gt; ）只是回收空间并使其可重复使用。该命令的形式可以与表的正常读取和写入并行进行，因为没有获得排他锁。但是，在大多数情况下，多余的空间不会返回给操作系统。它只是可以在同一张表中重复使用。 &lt;code&gt;VACUUM FULL&lt;/code&gt; 将表的全部内容重写为一个没有额外空间的新磁盘文件，从而允许将未使用的空间返回给操作系统。这种形式要慢得多，并且在处理过程中需要在每个表上具有排他锁。</target>
        </trans-unit>
        <trans-unit id="cdc70d31ed5da3eee47809b4dd230782b8f8497b" translate="yes" xml:space="preserve">
          <source>Plain &lt;code&gt;VACUUM&lt;/code&gt; (without &lt;code&gt;FULL&lt;/code&gt;) simply reclaims space and makes it available for re-use. This form of the command can operate in parallel with normal reading and writing of the table, as an exclusive lock is not obtained. However, extra space is not returned to the operating system (in most cases); it's just kept available for re-use within the same table. It also allows us to leverage multiple CPUs in order to process indexes. This feature is known as &lt;em&gt;parallel vacuum&lt;/em&gt;. To disable this feature, one can use &lt;code&gt;PARALLEL&lt;/code&gt; option and specify parallel workers as zero. &lt;code&gt;VACUUM FULL&lt;/code&gt; rewrites the entire contents of the table into a new disk file with no extra space, allowing unused space to be returned to the operating system. This form is much slower and requires an exclusive lock on each table while it is being processed.</source>
          <target state="translated">普通 &lt;code&gt;VACUUM&lt;/code&gt; （无 &lt;code&gt;FULL&lt;/code&gt; ）只是回收空间并使其可重复使用。该命令的形式可以与表的正常读取和写入并行进行，因为没有获得排他锁。但是，在大多数情况下，多余的空间不会返回给操作系统。它只是可以在同一张表中重复使用。它还允许我们利用多个CPU来处理索引。此功能称为&lt;em&gt;平行真空&lt;/em&gt;。要禁用此功能，可以使用 &lt;code&gt;PARALLEL&lt;/code&gt; 选项并将并行工作程序指定为零。 &lt;code&gt;VACUUM FULL&lt;/code&gt; 将表的全部内容重写为一个没有额外空间的新磁盘文件，从而允许将未使用的空间返回给操作系统。这种形式要慢得多，并且在处理过程中需要在每个表上具有排他锁。</target>
        </trans-unit>
        <trans-unit id="8499132893d83a3f2ae11d9668e227a0e6596484" translate="yes" xml:space="preserve">
          <source>Plain &lt;code&gt;VACUUM&lt;/code&gt; may not be satisfactory when a table contains large numbers of dead row versions as a result of massive update or delete activity. If you have such a table and you need to reclaim the excess disk space it occupies, you will need to use &lt;code&gt;VACUUM FULL&lt;/code&gt;, or alternatively &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; or one of the table-rewriting variants of &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;. These commands rewrite an entire new copy of the table and build new indexes for it. All these options require exclusive lock. Note that they also temporarily use extra disk space approximately equal to the size of the table, since the old copies of the table and indexes can't be released until the new ones are complete.</source>
          <target state="translated">普通 &lt;code&gt;VACUUM&lt;/code&gt; ，当表中包含大量的死行版本的大规模更新或删除操作的结果可能不尽如人意。如果您有这样一个表，并且需要回收它占用的多余磁盘空间，则需要使用 &lt;code&gt;VACUUM FULL&lt;/code&gt; ，或者使用&lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt;或&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;的表重写变体之一。这些命令重写表的整个新副本并为其建立新索引。所有这些选项都需要排他锁。请注意，它们还临时使用大约等于表大小的额外磁盘空间，因为在新表和索引完成之前，无法释放表和索引的旧副本。</target>
        </trans-unit>
        <trans-unit id="a9dba597737e71648392c996cea122250f0bead7" translate="yes" xml:space="preserve">
          <source>Plan nodes to which an &lt;code&gt;InitPlan&lt;/code&gt; is attached.</source>
          <target state="translated">计划附加了 &lt;code&gt;InitPlan&lt;/code&gt; 的节点。</target>
        </trans-unit>
        <trans-unit id="2bae7f24c9eebd1039795f1be6ffdf3da89d373b" translate="yes" xml:space="preserve">
          <source>Plan nodes which reference a correlated &lt;code&gt;SubPlan&lt;/code&gt;.</source>
          <target state="translated">参考相关 &lt;code&gt;SubPlan&lt;/code&gt; 计划的计划节点。</target>
        </trans-unit>
        <trans-unit id="fd8eca8ef866c5503502580ce3a00558f59a9928" translate="yes" xml:space="preserve">
          <source>Plannable queries (that is, &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt;) are combined into a single &lt;code&gt;pg_stat_statements&lt;/code&gt; entry whenever they have identical query structures according to an internal hash calculation. Typically, two queries will be considered the same for this purpose if they are semantically equivalent except for the values of literal constants appearing in the query. Utility commands (that is, all other commands) are compared strictly on the basis of their textual query strings, however.</source>
          <target state="translated">只要有计划的查询（即 &lt;code&gt;SELECT&lt;/code&gt; ， &lt;code&gt;INSERT&lt;/code&gt; ， &lt;code&gt;UPDATE&lt;/code&gt; 和 &lt;code&gt;DELETE&lt;/code&gt; ）根据内部哈希计算具有相同的查询结构，它们就会组合到单个 &lt;code&gt;pg_stat_statements&lt;/code&gt; 条目中。通常，如果两个查询在语义上等效，则两个查询在此意义上是相同的，只是出现在查询中的文字常量的值除外。但是，将严格根据实用程序命令（即所有其他命令）的文本查询字符串进行比较。</target>
        </trans-unit>
        <trans-unit id="1c065dbb4470e9d21b7a921d317fd42a4a204fc8" translate="yes" xml:space="preserve">
          <source>Planner Statistics and Security</source>
          <target state="translated">规划师统计和安全</target>
        </trans-unit>
        <trans-unit id="20ef8925a22326d996284c55f97493dce8cb35b8" translate="yes" xml:space="preserve">
          <source>Planner/Optimizer</source>
          <target state="translated">Planner/Optimizer</target>
        </trans-unit>
        <trans-unit id="88b7699abe5df4b9c91f2b6e5ea1aabcde7ea7fc" translate="yes" xml:space="preserve">
          <source>Plans and resources - &lt;code&gt;PREPARE&lt;/code&gt;, &lt;code&gt;EXECUTE&lt;/code&gt;, &lt;code&gt;DEALLOCATE&lt;/code&gt;, &lt;code&gt;DISCARD&lt;/code&gt;</source>
          <target state="translated">计划和资源- &lt;code&gt;PREPARE&lt;/code&gt; ， &lt;code&gt;EXECUTE&lt;/code&gt; ， &lt;code&gt;DEALLOCATE&lt;/code&gt; ， &lt;code&gt;DISCARD&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2e7c7717c711ec0c456d95556daba5b3b636c0d1" translate="yes" xml:space="preserve">
          <source>Plans and resources: &lt;code&gt;PREPARE&lt;/code&gt;, &lt;code&gt;EXECUTE&lt;/code&gt;, &lt;code&gt;DEALLOCATE&lt;/code&gt;, &lt;code&gt;DISCARD&lt;/code&gt;</source>
          <target state="translated">计划和资源： &lt;code&gt;PREPARE&lt;/code&gt; ， &lt;code&gt;EXECUTE&lt;/code&gt; ， &lt;code&gt;DEALLOCATE&lt;/code&gt; ， &lt;code&gt;DISCARD&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="60e74c5b37f496e9f5820d20828439504e47ddb6" translate="yes" xml:space="preserve">
          <source>Please enter all the commands shown above so you have some data to work with in the following sections.</source>
          <target state="translated">请输入上面显示的所有命令,这样你就有了一些数据,可以在下面的章节中使用。</target>
        </trans-unit>
        <trans-unit id="a932052bd8c1c2c9d99c8557aa55ac6cb1e71319" translate="yes" xml:space="preserve">
          <source>Please note that you may see some or all of the following notifications depending on the particular versions you have of libselinux and selinux-policy:</source>
          <target state="translated">请注意,您可能会看到以下一些或所有的通知,这取决于您所拥有的libselinux和selinux-policy的特定版本。</target>
        </trans-unit>
        <trans-unit id="0db2f66cabcb72c7d5c5552d7794e37b6384e5d6" translate="yes" xml:space="preserve">
          <source>Please note the following points when using the generic WAL record facility:</source>
          <target state="translated">在使用通用WAL记录功能时,请注意以下几点。</target>
        </trans-unit>
        <trans-unit id="86f9d988d7b8b2829ff9e18a117a22f3c6c12cda" translate="yes" xml:space="preserve">
          <source>Pluggable Authentication Modules</source>
          <target state="translated">可插拔式认证模块</target>
        </trans-unit>
        <trans-unit id="3dfb3c336b3693041700e2e10c00427b27b0180f" translate="yes" xml:space="preserve">
          <source>Plugins and extensions - &lt;code&gt;LOAD&lt;/code&gt;</source>
          <target state="translated">插件和扩展 &lt;code&gt;LOAD&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cfc627985ddf6332a8ae76b6d6e7fac5e923c727" translate="yes" xml:space="preserve">
          <source>Plugins and extensions: &lt;code&gt;LOAD&lt;/code&gt;</source>
          <target state="translated">插件和扩展： &lt;code&gt;LOAD&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="efefb1be830f67be53a399ad23055160dfbce160" translate="yes" xml:space="preserve">
          <source>Plus operator that iterates over the SQL/JSON sequence</source>
          <target state="translated">加运算符,对SQL/JSON序列进行迭代。</target>
        </trans-unit>
        <trans-unit id="65afde293357ae741287178244c36bbcce3cc736" translate="yes" xml:space="preserve">
          <source>Point on a plane</source>
          <target state="translated">平面上的点</target>
        </trans-unit>
        <trans-unit id="609adbe0655f07f14c79208d551f8d9718fabd23" translate="yes" xml:space="preserve">
          <source>Point or box of intersection</source>
          <target state="translated">交点或交框</target>
        </trans-unit>
        <trans-unit id="09812b4d0aeaa487df4bde731b3996675a249aaa" translate="yes" xml:space="preserve">
          <source>Points are output using the first syntax.</source>
          <target state="translated">使用第一种语法输出点数。</target>
        </trans-unit>
        <trans-unit id="44c9844a5c8235f295a2612b30b79553235db5c0" translate="yes" xml:space="preserve">
          <source>Points are the fundamental two-dimensional building block for geometric types. Values of type &lt;code&gt;point&lt;/code&gt; are specified using either of the following syntaxes:</source>
          <target state="translated">点是几何类型的基本二维构建基块。使用以下两种语法之一指定 &lt;code&gt;point&lt;/code&gt; 类型的值：</target>
        </trans-unit>
        <trans-unit id="7f6158e808f6832883a61fff6f7473e7ffa8d937" translate="yes" xml:space="preserve">
          <source>Points to note:</source>
          <target state="translated">需要注意的是:</target>
        </trans-unit>
        <trans-unit id="da968837807c4a4627a6c38281eebcac2e2aa0b7" translate="yes" xml:space="preserve">
          <source>Policies are created using the &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt; command, altered using the &lt;a href=&quot;sql-alterpolicy&quot;&gt;ALTER POLICY&lt;/a&gt; command, and dropped using the &lt;a href=&quot;sql-droppolicy&quot;&gt;DROP POLICY&lt;/a&gt; command. To enable and disable row security for a given table, use the &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; command.</source>
          <target state="translated">使用&lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt;命令创建策略，使用&lt;a href=&quot;sql-alterpolicy&quot;&gt;ALTER POLICY&lt;/a&gt;命令更改策略，然后使用&lt;a href=&quot;sql-droppolicy&quot;&gt;DROP POLICY&lt;/a&gt;命令删除策略。要启用和禁用给定表的行安全性，请使用&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="1624c281a60434d712e179fdb6ff898796130b43" translate="yes" xml:space="preserve">
          <source>Policies can be applied for specific commands or for specific roles. The default for newly created policies is that they apply for all commands and roles, unless otherwise specified. Multiple policies may apply to a single command; see below for more details. &lt;a href=&quot;sql-createpolicy#SQL-CREATEPOLICY-SUMMARY&quot;&gt;Table 256&lt;/a&gt; summarizes how the different types of policy apply to specific commands.</source>
          <target state="translated">策略可以应用于特定命令或特定角色。除非另有说明，否则新创建的策略的默认设置是它们适用于所有命令和角色。多个策略可能适用于单个命令。请参阅下面的更多细节。&lt;a href=&quot;sql-createpolicy#SQL-CREATEPOLICY-SUMMARY&quot;&gt;表256&lt;/a&gt;总结了不同类型的策略如何应用于特定命令。</target>
        </trans-unit>
        <trans-unit id="ea4ac1b26dd811200c863a2d28d42117a994a64e" translate="yes" xml:space="preserve">
          <source>Policies can be applied for specific commands or for specific roles. The default for newly created policies is that they apply for all commands and roles, unless otherwise specified. Multiple policies may apply to a single command; see below for more details. &lt;a href=&quot;sql-createpolicy#SQL-CREATEPOLICY-SUMMARY&quot;&gt;Table 272&lt;/a&gt; summarizes how the different types of policy apply to specific commands.</source>
          <target state="translated">策略可以应用于特定命令或特定角色。除非另有说明，否则新创建的策略的默认设置是它们适用于所有命令和角色。多个策略可能适用于单个命令。请参阅下面的更多细节。&lt;a href=&quot;sql-createpolicy#SQL-CREATEPOLICY-SUMMARY&quot;&gt;表272&lt;/a&gt;总结了不同类型的策略如何应用于特定命令。</target>
        </trans-unit>
        <trans-unit id="9218496f73981d3e04361890ce5e81c103eeff2b" translate="yes" xml:space="preserve">
          <source>Policies stored in &lt;code&gt;pg_policy&lt;/code&gt; are applied only when &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relrowsecurity&lt;/code&gt; is set for their table.</source>
          <target state="translated">&lt;code&gt;pg_policy&lt;/code&gt; 中存储的策略仅在 &lt;code&gt;pg_class&lt;/code&gt; 时适用。为他们的表设置了 &lt;code&gt;relrowsecurity&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="64fe90225d9ffc87de024a67667003d6e6192eb8" translate="yes" xml:space="preserve">
          <source>Policy names are per-table. Therefore, one policy name can be used for many different tables and have a definition for each table which is appropriate to that table.</source>
          <target state="translated">策略名称是按表命名的。因此,一个策略名可以用于许多不同的表,并为每个表都有一个适合该表的定义。</target>
        </trans-unit>
        <trans-unit id="a028a9272b54da3da6db504ed096a2910de4d948" translate="yes" xml:space="preserve">
          <source>Polygon (similar to closed path)</source>
          <target state="translated">多边形(类似于封闭路径</target>
        </trans-unit>
        <trans-unit id="358c4e4d5755c21f01067425fdfdaf1bfdcb7099" translate="yes" xml:space="preserve">
          <source>Polygons are output using the first syntax.</source>
          <target state="translated">使用第一种语法输出多边形。</target>
        </trans-unit>
        <trans-unit id="7fb66bc5a7ec5dcfcc725c19a5a1e5c03cd32e7e" translate="yes" xml:space="preserve">
          <source>Polygons are represented by lists of points (the vertexes of the polygon). Polygons are very similar to closed paths, but are stored differently and have their own set of support routines.</source>
          <target state="translated">多边形由点的列表(多边形的顶点)表示。多边形与封闭路径非常相似,但存储方式不同,有自己的一套支持例程。</target>
        </trans-unit>
        <trans-unit id="931d8d1ab098337b34a524e4f5275bb68856723d" translate="yes" xml:space="preserve">
          <source>Popular examples</source>
          <target state="translated">最受欢迎的例子</target>
        </trans-unit>
        <trans-unit id="274e42ad6449f3252ec5038abe402083876dea88" translate="yes" xml:space="preserve">
          <source>Populating a Database</source>
          <target state="translated">填充数据库</target>
        </trans-unit>
        <trans-unit id="367461ddb82787c5535ecce370eaabdc51b55d46" translate="yes" xml:space="preserve">
          <source>Population standard deviation of time spent executing the statement, in milliseconds</source>
          <target state="translated">执行语句所花时间的总体标准差,以毫秒为单位。</target>
        </trans-unit>
        <trans-unit id="7fbc9b4eb9f4bb4e95de4acb2d6d7f0b43e20913" translate="yes" xml:space="preserve">
          <source>Population standard deviation of time spent in the statement, in milliseconds</source>
          <target state="translated">报表所用时间的总体标准差,以毫秒计</target>
        </trans-unit>
        <trans-unit id="75494ee8f234525fd82a1234cd1d741493f67113" translate="yes" xml:space="preserve">
          <source>Population standard deviation of time spent planning the statement, in milliseconds (if &lt;code&gt;pg_stat_statements.track_planning&lt;/code&gt; is enabled, otherwise zero)</source>
          <target state="translated">计划语句的总体时间标准偏差（以毫秒为单位）（如果启用了 &lt;code&gt;pg_stat_statements.track_planning&lt;/code&gt; ，否则为零）</target>
        </trans-unit>
        <trans-unit id="384cecb2d7b1b2012eaea272977d2cf0c551884e" translate="yes" xml:space="preserve">
          <source>Port number of the PostgreSQL instance this WAL receiver is connected to.</source>
          <target state="translated">这个WAL接收器连接的PostgreSQL实例的端口号。</target>
        </trans-unit>
        <trans-unit id="008e62801aaa400319958b2b2b06cc2182c60162" translate="yes" xml:space="preserve">
          <source>Port number on LDAP server to connect to. If no port is specified, the LDAP library's default port setting will be used.</source>
          <target state="translated">要连接到的LDAP服务器的端口号。如果没有指定端口,将使用LDAP库的默认端口设置。</target>
        </trans-unit>
        <trans-unit id="c75704d05c6e22d0fdf67c00eb401f9b1c6b139b" translate="yes" xml:space="preserve">
          <source>Portable Operating System Interface</source>
          <target state="translated">便携式操作系统接口</target>
        </trans-unit>
        <trans-unit id="e7c56d55f410fd275aaccf8ba063a18761b3e5c0" translate="yes" xml:space="preserve">
          <source>Position values in &lt;code&gt;tsvector&lt;/code&gt; must be greater than 0 and no more than 16,383</source>
          <target state="translated">&lt;code&gt;tsvector&lt;/code&gt; 中的位置值必须大于0且不大于16,383</target>
        </trans-unit>
        <trans-unit id="bbb340fe5bf8594afaa03b969bb8e8f82eef71df" translate="yes" xml:space="preserve">
          <source>Positional notation is the traditional mechanism for passing arguments to functions in PostgreSQL. An example is:</source>
          <target state="translated">位置符号是PostgreSQL中传递参数给函数的传统机制。一个例子是:</target>
        </trans-unit>
        <trans-unit id="dd8bd0b5027f70c1cefa9f905da80fd30083ef2a" translate="yes" xml:space="preserve">
          <source>Possible</source>
          <target state="translated">Possible</target>
        </trans-unit>
        <trans-unit id="6db8a7e83593975ece623b8f9b3fe94d53e8a1b1" translate="yes" xml:space="preserve">
          <source>Possible limitations of the &lt;code&gt;query&lt;/code&gt; clause are documented under &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;记录了 &lt;code&gt;query&lt;/code&gt; 子句的可能限制。</target>
        </trans-unit>
        <trans-unit id="7280aa9b126e519bb5acdcab7417841a30bb930a" translate="yes" xml:space="preserve">
          <source>Possible values are:</source>
          <target state="translated">可能的数值是:</target>
        </trans-unit>
        <trans-unit id="e46bf54baa1011e163ced28f70574e61876f70d3" translate="yes" xml:space="preserve">
          <source>Possible variants of the above queries are:</source>
          <target state="translated">上述查询的可能变体是:</target>
        </trans-unit>
        <trans-unit id="92818ef9b703eafdfca9b984fb83c6ed173e8358" translate="yes" xml:space="preserve">
          <source>Possibly, your site administrator has already created a database for your use. In that case you can omit this step and skip ahead to the next section.</source>
          <target state="translated">有可能,您的网站管理员已经创建了一个数据库供您使用。在这种情况下,你可以省略这一步,跳到下一节。</target>
        </trans-unit>
        <trans-unit id="24fd6c2d1150de6a47543209150ff4c2a2d3104f" translate="yes" xml:space="preserve">
          <source>PostgreSQL</source>
          <target state="translated">PostgreSQL</target>
        </trans-unit>
        <trans-unit id="d31a3cecdd68dfe451de7f17fd71f41b5ec2d2b2" translate="yes" xml:space="preserve">
          <source>PostgreSQL B-Tree indexes are multi-level tree structures, where each level of the tree can be used as a doubly-linked list of pages. A single metapage is stored in a fixed position at the start of the first segment file of the index. All other pages are either leaf pages or internal pages. Leaf pages are the pages on the lowest level of the tree. All other levels consist of internal pages. Each leaf page contains tuples that point to table rows. Each internal page contains tuples that point to the next level down in the tree. Typically, over 99% of all pages are leaf pages. Both internal pages and leaf pages use the standard page format described in &lt;a href=&quot;storage-page-layout&quot;&gt;Section 68.6&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL B树索引是多层树结构，其中树的每一层都可以用作页面的双向链接列表。单个元页存储在索引的第一个段文件的开始处的固定位置。所有其他页面都是叶页面或内部页面。叶子页面是树的最低层上的页面。所有其他级别都由内部页面组成。每个叶子页包含指向表行的元组。每个内部页面都包含指向树中下一层的元组。通常，所有页面中超过99％是叶子页面。内部页面和叶子页面都使用&lt;a href=&quot;storage-page-layout&quot;&gt;第68.6节中&lt;/a&gt;描述的标准页面格式。</target>
        </trans-unit>
        <trans-unit id="0c5bb15ce4cd87c929efa330565ff6d28cd04381" translate="yes" xml:space="preserve">
          <source>PostgreSQL Client Applications</source>
          <target state="translated">PostgreSQL客户端应用</target>
        </trans-unit>
        <trans-unit id="c24f12993bca195ad8365e3a9f46bba7d548c46e" translate="yes" xml:space="preserve">
          <source>PostgreSQL Error Codes</source>
          <target state="translated">PostgreSQL错误代码</target>
        </trans-unit>
        <trans-unit id="179caa7e2f2ae5bcccafd6de1029390b28df93ea" translate="yes" xml:space="preserve">
          <source>PostgreSQL Extension System</source>
          <target state="translated">PostgreSQL扩展系统</target>
        </trans-unit>
        <trans-unit id="bde4caa4f627d1ed1cd6258230a52653ae368364" translate="yes" xml:space="preserve">
          <source>PostgreSQL Limits</source>
          <target state="translated">PostgreSQL的限制</target>
        </trans-unit>
        <trans-unit id="831c73ba52cb3a865742b364e490e3d33fd67271" translate="yes" xml:space="preserve">
          <source>PostgreSQL Log Sequence Number</source>
          <target state="translated">PostgreSQL日志序列号</target>
        </trans-unit>
        <trans-unit id="d6e7156cbc0b3b93da375064bee0966e60cdb8ac" translate="yes" xml:space="preserve">
          <source>PostgreSQL Rule System</source>
          <target state="translated">PostgreSQL规则系统</target>
        </trans-unit>
        <trans-unit id="452e61af45168fd75ac971dbf646f72b427da732" translate="yes" xml:space="preserve">
          <source>PostgreSQL Server Applications</source>
          <target state="translated">PostgreSQL服务器应用</target>
        </trans-unit>
        <trans-unit id="67fae22a18c43950aa1922954f1d91e59073538b" translate="yes" xml:space="preserve">
          <source>PostgreSQL User Account</source>
          <target state="translated">PostgreSQL用户账户</target>
        </trans-unit>
        <trans-unit id="2764cd9d3bf007f792e3e2fc4a68faeb55344442" translate="yes" xml:space="preserve">
          <source>PostgreSQL accesses certain on-disk information via &lt;em&gt;SLRU&lt;/em&gt; (simple least-recently-used) caches. The &lt;code&gt;pg_stat_slru&lt;/code&gt; view will contain one row for each tracked SLRU cache, showing statistics about access to cached pages.</source>
          <target state="translated">PostgreSQL通过&lt;em&gt;SLRU&lt;/em&gt;（最近最少使用）缓存访问某些磁盘信息。该 &lt;code&gt;pg_stat_slru&lt;/code&gt; 视图将包含一行每个跟踪SLRU缓存，显示有关访问缓存页面的统计数据。</target>
        </trans-unit>
        <trans-unit id="c5ec2d5a5859a9a3bd680edc1c2f24695d8620d3" translate="yes" xml:space="preserve">
          <source>PostgreSQL actually treats every SQL statement as being executed within a transaction. If you do not issue a &lt;code&gt;BEGIN&lt;/code&gt; command, then each individual statement has an implicit &lt;code&gt;BEGIN&lt;/code&gt; and (if successful) &lt;code&gt;COMMIT&lt;/code&gt; wrapped around it. A group of statements surrounded by &lt;code&gt;BEGIN&lt;/code&gt; and &lt;code&gt;COMMIT&lt;/code&gt; is sometimes called a &lt;em&gt;transaction block&lt;/em&gt;.</source>
          <target state="translated">PostgreSQL实际上将每个SQL语句都视为在事务内执行。如果您不发出 &lt;code&gt;BEGIN&lt;/code&gt; 命令，则每个单独的语句都有一个隐式的 &lt;code&gt;BEGIN&lt;/code&gt; 和（如果成功的话）用 &lt;code&gt;COMMIT&lt;/code&gt; 包装。由 &lt;code&gt;BEGIN&lt;/code&gt; 和 &lt;code&gt;COMMIT&lt;/code&gt; 包围的一组语句有时称为&lt;em&gt;事务块&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="a08fed9d9b5168502be31cd2bf857824ed3fb1b6" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt; to be used as &lt;code&gt;WITH&lt;/code&gt; queries. This is not found in the SQL standard.</source>
          <target state="translated">PostgreSQL允许 &lt;code&gt;INSERT&lt;/code&gt; ， &lt;code&gt;UPDATE&lt;/code&gt; 和 &lt;code&gt;DELETE&lt;/code&gt; 用作 &lt;code&gt;WITH&lt;/code&gt; 查询。在SQL标准中找不到。</target>
        </trans-unit>
        <trans-unit id="4ae0ed23837a44ee80fff5d2d48a225d0adbd095" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows a function call to be written directly as a member of the &lt;code&gt;FROM&lt;/code&gt; list. In the SQL standard it would be necessary to wrap such a function call in a sub-&lt;code&gt;SELECT&lt;/code&gt;; that is, the syntax &lt;code&gt;FROM func(...) alias&lt;/code&gt; is approximately equivalent to &lt;code&gt;FROM LATERAL (SELECT func(...)) alias&lt;/code&gt;. Note that &lt;code&gt;LATERAL&lt;/code&gt; is considered to be implicit; this is because the standard requires &lt;code&gt;LATERAL&lt;/code&gt; semantics for an &lt;code&gt;UNNEST()&lt;/code&gt; item in &lt;code&gt;FROM&lt;/code&gt;. PostgreSQL treats &lt;code&gt;UNNEST()&lt;/code&gt; the same as other set-returning functions.</source>
          <target state="translated">PostgreSQL允许将函数调用直接编写为 &lt;code&gt;FROM&lt;/code&gt; 列表的成员。在SQL标准中，有必要将这样的函数调用包装在子 &lt;code&gt;SELECT&lt;/code&gt; 中。也就是说，语法 &lt;code&gt;FROM func(...) alias&lt;/code&gt; 近似等效于 &lt;code&gt;FROM LATERAL (SELECT func(...)) alias&lt;/code&gt; 。注意 &lt;code&gt;LATERAL&lt;/code&gt; 被认为是隐式的；这是因为该标准要求 &lt;code&gt;FROM&lt;/code&gt; 中的 &lt;code&gt;UNNEST()&lt;/code&gt; 项具有 &lt;code&gt;LATERAL&lt;/code&gt; 语义。 PostgreSQL将 &lt;code&gt;UNNEST()&lt;/code&gt; 与其他返回集合的函数相同。</target>
        </trans-unit>
        <trans-unit id="1fec2c228fe0347b7815e3014f29d97d5a87acca" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows a table of no columns to be created (for example, &lt;code&gt;CREATE TABLE foo();&lt;/code&gt;). This is an extension from the SQL standard, which does not allow zero-column tables. Zero-column tables are not in themselves very useful, but disallowing them creates odd special cases for &lt;code&gt;ALTER TABLE DROP COLUMN&lt;/code&gt;, so it seems cleaner to ignore this spec restriction.</source>
          <target state="translated">PostgreSQL允许创建没有列的表（例如 &lt;code&gt;CREATE TABLE foo();&lt;/code&gt; ）。这是SQL标准的扩展，不允许使用零列表。零列表本身并不是很有用，但是不允许使用零列表会产生 &lt;code&gt;ALTER TABLE DROP COLUMN&lt;/code&gt; 奇怪的特殊情况，因此似乎可以忽略此规范限制。</target>
        </trans-unit>
        <trans-unit id="5a502e4f8d9c2660f0a8eba2540286883c5cd8c9" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows a table to have more than one identity column. The standard specifies that a table can have at most one identity column. This is relaxed mainly to give more flexibility for doing schema changes or migrations. Note that the &lt;code&gt;INSERT&lt;/code&gt; command supports only one override clause that applies to the entire statement, so having multiple identity columns with different behaviors is not well supported.</source>
          <target state="translated">PostgreSQL允许一个表具有多个标识列。该标准指定一个表最多可以包含一个标识列。放宽这主要是为了给模式更改或迁移提供更大的灵活性。请注意， &lt;code&gt;INSERT&lt;/code&gt; 命令仅支持一个应用于整个语句的重写子句，因此，不完全支持具有不同行为的多个标识列。</target>
        </trans-unit>
        <trans-unit id="b3ae4855b2a3e72640693b7d20d3ad5d9fb47042" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows a trailing &lt;code&gt;*&lt;/code&gt; to be written to explicitly specify the non-&lt;code&gt;ONLY&lt;/code&gt; behavior of including child tables. The standard does not allow this.</source>
          <target state="translated">PostgreSQL允许写一个结尾 &lt;code&gt;*&lt;/code&gt; 来明确指定包括子表的非 &lt;code&gt;ONLY&lt;/code&gt; 行为。该标准不允许这样做。</target>
        </trans-unit>
        <trans-unit id="0222c8fe2334be83692d30a209d5aa08ec24134f" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows an object owner to revoke their own ordinary privileges: for example, a table owner can make the table read-only to themselves by revoking their own &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, and &lt;code&gt;TRUNCATE&lt;/code&gt; privileges. This is not possible according to the SQL standard. The reason is that PostgreSQL treats the owner's privileges as having been granted by the owner to themselves; therefore they can revoke them too. In the SQL standard, the owner's privileges are granted by an assumed entity &amp;ldquo;_SYSTEM&amp;rdquo;. Not being &amp;ldquo;_SYSTEM&amp;rdquo;, the owner cannot revoke these rights.</source>
          <target state="translated">PostgreSQL允许对象所有者撤销其自己的普通特权：例如，表所有者可以通过撤销其自己的 &lt;code&gt;INSERT&lt;/code&gt; ， &lt;code&gt;UPDATE&lt;/code&gt; ， &lt;code&gt;DELETE&lt;/code&gt; 和 &lt;code&gt;TRUNCATE&lt;/code&gt; 特权使该表对自己只读。根据SQL标准，这是不可能的。原因是PostgreSQL将所有者的特权视为所有者授予自己的特权。因此他们也可以撤销它们。在SQL标准中，所有者的特权由假定的实体&amp;ldquo; _SYSTEM&amp;rdquo;授予。所有者不是&amp;ldquo; _SYSTEM&amp;rdquo;，不能撤消这些权利。</target>
        </trans-unit>
        <trans-unit id="d75f3d8cbebcea3de67f82faaf69d14b5b967380" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows columns of a table to be defined as variable-length multidimensional arrays. Arrays of any built-in or user-defined base type, enum type, composite type, range type, or domain can be created.</source>
          <target state="translated">PostgreSQL允许将表的列定义为可变长度的多维数组,可以创建任何内置的或用户定义的基本类型、枚举类型、复合类型、范围类型或域的数组。可以创建任何内置的或用户定义的基本类型、枚举类型、复合类型、范围类型或域的数组。</target>
        </trans-unit>
        <trans-unit id="06987dbdd7bcd6dca55a6bfbcab96569673d7620" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows conversion between any two character sets for which a conversion function is listed in the &lt;a href=&quot;catalog-pg-conversion&quot;&gt;&lt;code&gt;pg_conversion&lt;/code&gt;&lt;/a&gt; system catalog. PostgreSQL comes with some predefined conversions, as summarized in &lt;a href=&quot;multibyte#MULTIBYTE-TRANSLATION-TABLE&quot;&gt;Table 23.2&lt;/a&gt; and shown in more detail in &lt;a href=&quot;multibyte#BUILTIN-CONVERSIONS-TABLE&quot;&gt;Table 23.3&lt;/a&gt;. You can create a new conversion using the SQL command &lt;a href=&quot;sql-createconversion&quot;&gt;CREATE CONVERSION&lt;/a&gt;. (To be used for automatic client/server conversions, a conversion must be marked as &amp;ldquo;default&amp;rdquo; for its character set pair.)</source>
          <target state="translated">PostgreSQL允许在&lt;a href=&quot;catalog-pg-conversion&quot;&gt; &lt;code&gt;pg_conversion&lt;/code&gt; &lt;/a&gt;系统目录中列出了转换功能的任何两个字符集之间进行转换。PostgreSQL附带了一些预定义的转换，如&lt;a href=&quot;multibyte#MULTIBYTE-TRANSLATION-TABLE&quot;&gt;表23.2&lt;/a&gt;所概述，并在&lt;a href=&quot;multibyte#BUILTIN-CONVERSIONS-TABLE&quot;&gt;表23.3&lt;/a&gt;中更详细地显示。您可以使用SQL命令&lt;a href=&quot;sql-createconversion&quot;&gt;CREATE CONVERSION&lt;/a&gt;创建新的转换。（要用于自动客户端/服务器转换，必须将其字符集对标记为&amp;ldquo;默认&amp;rdquo;。）</target>
        </trans-unit>
        <trans-unit id="bbbdf4cafaaa4dcf65d19eea36b6d2663f13d7b7" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows database sessions to synchronize their snapshots. A &lt;em&gt;snapshot&lt;/em&gt; determines which data is visible to the transaction that is using the snapshot. Synchronized snapshots are necessary when two or more sessions need to see identical content in the database. If two sessions just start their transactions independently, there is always a possibility that some third transaction commits between the executions of the two &lt;code&gt;START TRANSACTION&lt;/code&gt; commands, so that one session sees the effects of that transaction and the other does not.</source>
          <target state="translated">PostgreSQL允许数据库会话同步其快照。甲&lt;em&gt;快照&lt;/em&gt;确定哪些数据是可见于利用快照被交易。当两个或多个会话需要查看数据库中的相同内容时，需要同步快照。如果两个会话只是独立地开始其事务，则始终有可能在两个 &lt;code&gt;START TRANSACTION&lt;/code&gt; 命令的执行之间提交某些第三事务，这样一个会话就可以看到该事务的效果，而另一个会话则看不到该事务的效果。</target>
        </trans-unit>
        <trans-unit id="2f376988cf3adab23de6270e27f2d8af7b43d3dc" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows expressions with prefix and postfix unary (one-argument) operators, as well as binary (two-argument) operators. Like functions, operators can be overloaded, so the same problem of selecting the right operator exists.</source>
          <target state="translated">PostgreSQL允许表达式使用前缀和后缀的一元(一个参数)运算符,以及二元(两个参数)运算符。和函数一样,运算符也可以被重载,所以同样存在选择正确运算符的问题。</target>
        </trans-unit>
        <trans-unit id="38e06aff61270fa25d3a83fecc14dbc49c17fa73" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows function &lt;em&gt;overloading&lt;/em&gt;; that is, the same name can be used for several different functions so long as they have distinct input argument types. Whether or not you use it, this capability entails security precautions when calling functions in databases where some users mistrust other users; see &lt;a href=&quot;typeconv-func&quot;&gt;Section 10.3&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL允许函数&lt;em&gt;重载&lt;/em&gt; ;也就是说，相同的名称可以用于多个不同的函数，只要它们具有不同的输入参数类型即可。无论您是否使用它，在某些用户不信任其他用户的数据库中调用函数时，此功能都需要采取安全预防措施。参见&lt;a href=&quot;typeconv-func&quot;&gt;10.3节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="885786b4f5cdfbf8b703cb2cdbcec19a632c472d" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows functions that have named parameters to be called using either &lt;em&gt;positional&lt;/em&gt; or &lt;em&gt;named&lt;/em&gt; notation. Named notation is especially useful for functions that have a large number of parameters, since it makes the associations between parameters and actual arguments more explicit and reliable. In positional notation, a function call is written with its argument values in the same order as they are defined in the function declaration. In named notation, the arguments are matched to the function parameters by name and can be written in any order. For each notation, also consider the effect of function argument types, documented in &lt;a href=&quot;typeconv-func&quot;&gt;Section 10.3&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL允许使用&lt;em&gt;位置&lt;/em&gt;或&lt;em&gt;命名&lt;/em&gt;符号来调用具有命名参数的函数。命名符号对于具有大量参数的函数特别有用，因为它使参数与实际参数之间的关联更加明确和可靠。在位置表示法中，函数调用的参数值的顺序与函数声明中定义的顺序相同。在命名符号中，参数按名称与功能参数匹配，并且可以按任何顺序编写。对于每种表示法，还应考虑在&lt;a href=&quot;typeconv-func&quot;&gt;10.3节中&lt;/a&gt;记录的函数参数类型的影响。</target>
        </trans-unit>
        <trans-unit id="ccedf68ac95013795d6781ac353bb002bbdac9bd" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows identifier syntax (&lt;code&gt;&quot;rolename&quot;&lt;/code&gt;), while the SQL standard requires the role name to be written as a string literal. SQL does not allow this command during a transaction; PostgreSQL does not make this restriction because there is no reason to. The &lt;code&gt;SESSION&lt;/code&gt; and &lt;code&gt;LOCAL&lt;/code&gt; modifiers are a PostgreSQL extension, as is the &lt;code&gt;RESET&lt;/code&gt; syntax.</source>
          <target state="translated">PostgreSQL允许标识符语法（ &lt;code&gt;&quot;rolename&quot;&lt;/code&gt; ），而SQL标准要求角色名称必须以字符串文字形式编写。SQL在事务期间不允许使用此命令。PostgreSQL没有限制，因为没有理由。该 &lt;code&gt;SESSION&lt;/code&gt; 和 &lt;code&gt;LOCAL&lt;/code&gt; 修饰是PostgreSQL的扩展，因为是 &lt;code&gt;RESET&lt;/code&gt; 语法。</target>
        </trans-unit>
        <trans-unit id="aee304bddb0add35cce98f16acc2e91d76460499" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows one to omit the &lt;code&gt;FROM&lt;/code&gt; clause. It has a straightforward use to compute the results of simple expressions:</source>
          <target state="translated">PostgreSQL允许省略 &lt;code&gt;FROM&lt;/code&gt; 子句。它可以直接用于计算简单表达式的结果：</target>
        </trans-unit>
        <trans-unit id="d0eb6de17c126effc5a1502158efa04db9cdf59d" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows only one character set encoding per database. It is therefore not possible for the JSON types to conform rigidly to the JSON specification unless the database encoding is UTF8. Attempts to directly include characters that cannot be represented in the database encoding will fail; conversely, characters that can be represented in the database encoding but not in UTF8 will be allowed.</source>
          <target state="translated">PostgreSQL只允许每个数据库使用一种字符集编码。因此,除非数据库编码是UTF8,否则JSON类型不可能严格遵守JSON规范。试图直接包含数据库编码中无法表示的字符将失败;反之,数据库编码中可以表示但不是UTF8的字符将被允许。</target>
        </trans-unit>
        <trans-unit id="6f4d7c19f392d3d32e2ae22627f8334829c75a1e" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows the application developer to specify the durability level required via replication. This can be specified for the system overall, though it can also be specified for specific users or connections, or even individual transactions.</source>
          <target state="translated">PostgreSQL允许应用开发者通过复制来指定所需的耐用性级别,这可以为系统整体指定,但也可以为特定的用户或连接,甚至是单个事务指定。这可以为系统整体指定,但也可以为特定的用户或连接,甚至单个事务指定。</target>
        </trans-unit>
        <trans-unit id="67e964073140451a310c8055af1d484d7e584b05" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows you to specify time zones in three different forms:</source>
          <target state="translated">PostgreSQL允许你以三种不同的形式指定时区。</target>
        </trans-unit>
        <trans-unit id="2091ac924b203b9490fe163a62e56fac7f983c3f" translate="yes" xml:space="preserve">
          <source>PostgreSQL also accepts &amp;ldquo;escape&amp;rdquo; string constants, which are an extension to the SQL standard. An escape string constant is specified by writing the letter &lt;code&gt;E&lt;/code&gt; (upper or lower case) just before the opening single quote, e.g., &lt;code&gt;E'foo'&lt;/code&gt;. (When continuing an escape string constant across lines, write &lt;code&gt;E&lt;/code&gt; only before the first opening quote.) Within an escape string, a backslash character (&lt;code&gt;\&lt;/code&gt;) begins a C-like &lt;em&gt;backslash escape&lt;/em&gt; sequence, in which the combination of backslash and following character(s) represent a special byte value, as shown in &lt;a href=&quot;sql-syntax-lexical#SQL-BACKSLASH-TABLE&quot;&gt;Table 4.1&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL还接受&amp;ldquo;转义&amp;rdquo;字符串常量，这是SQL标准的扩展。通过在开头的单引号之前写字母 &lt;code&gt;E&lt;/code&gt; （大写或小写）来指定转义字符串常量，例如 &lt;code&gt;E'foo'&lt;/code&gt; 。 （当跨行继续使用转义字符串常量时，请仅在第一个开始的引号之前写 &lt;code&gt;E&lt;/code&gt; 。）在转义字符串中，反斜杠字符（ &lt;code&gt;\&lt;/code&gt; ）开始一个类似于C的&lt;em&gt;反斜杠转义&lt;/em&gt;序列，其中反斜杠和后跟字符（ s）代表一个特殊的字节值，如&lt;a href=&quot;sql-syntax-lexical#SQL-BACKSLASH-TABLE&quot;&gt;表4.1&lt;/a&gt;所示。</target>
        </trans-unit>
        <trans-unit id="b8e26c666446bf180bc1b3bdb6835476bef38f80" translate="yes" xml:space="preserve">
          <source>PostgreSQL also accepts the following alternative forms for input: use of upper-case digits, the standard format surrounded by braces, omitting some or all hyphens, adding a hyphen after any group of four digits. Examples are:</source>
          <target state="translated">PostgreSQL也接受以下替代形式的输入:使用大写数字、用大括号包围的标准格式、省略部分或全部连字符、在任何一组四位数字后添加一个连字符。例子如下:</target>
        </trans-unit>
        <trans-unit id="d551afc59236ea284f4ca849fa7d2277a7469049" translate="yes" xml:space="preserve">
          <source>PostgreSQL also has native support for using GSSAPI to encrypt client/server communications for increased security. Support requires that a GSSAPI implementation (such as MIT krb5) is installed on both client and server systems, and that support in PostgreSQL is enabled at build time (see &lt;a href=&quot;https://www.postgresql.org/docs/12/installation.html&quot;&gt;Chapter 16&lt;/a&gt;).</source>
          <target state="translated">PostgreSQL还具有使用GSSAPI加密客户端/服务器通信以增强安全性的本机支持。支持要求在客户端和服务器系统上都安装GSSAPI实现（例如MIT krb5），并且在构建时启用PostgreSQL中的支持（请参阅&lt;a href=&quot;https://www.postgresql.org/docs/12/installation.html&quot;&gt;第16章&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="dd43f6c5eff3afed0ef2482d92caa74dc0ae8b00" translate="yes" xml:space="preserve">
          <source>PostgreSQL also has native support for using GSSAPI to encrypt client/server communications for increased security. Support requires that a GSSAPI implementation (such as MIT krb5) is installed on both client and server systems, and that support in PostgreSQL is enabled at build time (see &lt;a href=&quot;https://www.postgresql.org/docs/13/installation.html&quot;&gt;Chapter 16&lt;/a&gt;).</source>
          <target state="translated">PostgreSQL还具有使用GSSAPI加密客户端/服务器通信以增强安全性的本机支持。支持要求在客户端和服务器系统上都安装GSSAPI实现（例如MIT krb5），并且在构建时启用PostgreSQL中的支持（请参阅&lt;a href=&quot;https://www.postgresql.org/docs/13/installation.html&quot;&gt;第16章&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="7d7d486aaa9f91eb610db7317aa89991dcace483" translate="yes" xml:space="preserve">
          <source>PostgreSQL also protects against some kinds of data corruption on storage devices that may occur because of hardware errors or media failure over time, such as reading/writing garbage data.</source>
          <target state="translated">PostgreSQL还可以保护存储设备上的一些数据损坏,这些损坏可能会因为硬件错误或介质故障而随着时间的推移而发生,例如读取/写入垃圾数据。</target>
        </trans-unit>
        <trans-unit id="bc4957185fda95801e3489431ec80f6cc95ed9d3" translate="yes" xml:space="preserve">
          <source>PostgreSQL also provides functions that return the start time of the current statement, as well as the actual current time at the instant the function is called. The complete list of non-SQL-standard time functions is:</source>
          <target state="translated">PostgreSQL还提供了返回当前语句的开始时间,以及函数被调用瞬间的实际当前时间的函数。非SQL标准时间函数的完整列表是:。</target>
        </trans-unit>
        <trans-unit id="dd1b1c906496b16c3b9719d59a4575ea64702a53" translate="yes" xml:space="preserve">
          <source>PostgreSQL also provides the usual comparison operators shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;Table 9.1&lt;/a&gt; for UUIDs.</source>
          <target state="translated">PostgreSQL还提供了&lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;表9.1中显示的&lt;/a&gt;用于UUID的常规比较运算符。</target>
        </trans-unit>
        <trans-unit id="73c105cc11eec562c7842e40a45124c8ca33cfca" translate="yes" xml:space="preserve">
          <source>PostgreSQL also supports &lt;em&gt;mixed&lt;/em&gt; notation, which combines positional and named notation. In this case, positional parameters are written first and named parameters appear after them.</source>
          <target state="translated">PostgreSQL还支持&lt;em&gt;混合&lt;/em&gt;符号，它结合了位置和命名符号。在这种情况下，首先写入位置参数，然后在它们之后显示命名参数。</target>
        </trans-unit>
        <trans-unit id="ca59eb947715e169590d0f69e1f5c9da2f5d3e56" translate="yes" xml:space="preserve">
          <source>PostgreSQL also supports a parameter to strip the realm from the principal. This method is supported for backwards compatibility and is strongly discouraged as it is then impossible to distinguish different users with the same user name but coming from different realms. To enable this, set &lt;code&gt;include_realm&lt;/code&gt; to 0. For simple single-realm installations, doing that combined with setting the &lt;code&gt;krb_realm&lt;/code&gt; parameter (which checks that the principal's realm matches exactly what is in the &lt;code&gt;krb_realm&lt;/code&gt; parameter) is still secure; but this is a less capable approach compared to specifying an explicit mapping in &lt;code&gt;pg_ident.conf&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL还支持从主体剥离领域的参数。支持此方法以实现向后兼容，因此强烈建议不要使用此方法，因为这样就不可能区分具有相同用户名但来自不同领域的不同用户。要启用此功能，请将 &lt;code&gt;include_realm&lt;/code&gt; 设置为0。对于简单的单领域安装，将其与设置 &lt;code&gt;krb_realm&lt;/code&gt; 参数（检查主体的领域是否与 &lt;code&gt;krb_realm&lt;/code&gt; 参数中的内容完全匹配）结合起来仍然是安全的。但是，与在 &lt;code&gt;pg_ident.conf&lt;/code&gt; 中指定显式映射相比，这是一种功能较弱的方法。</target>
        </trans-unit>
        <trans-unit id="0b477944494e7d8e126d3d69b3ea2e26c69eb1df" translate="yes" xml:space="preserve">
          <source>PostgreSQL also supports another type of escape syntax for strings that allows specifying arbitrary Unicode characters by code point. A Unicode escape string constant starts with &lt;code&gt;U&amp;amp;&lt;/code&gt; (upper or lower case letter U followed by ampersand) immediately before the opening quote, without any spaces in between, for example &lt;code&gt;U&amp;amp;'foo'&lt;/code&gt;. (Note that this creates an ambiguity with the operator &lt;code&gt;&amp;amp;&lt;/code&gt;. Use spaces around the operator to avoid this problem.) Inside the quotes, Unicode characters can be specified in escaped form by writing a backslash followed by the four-digit hexadecimal code point number or alternatively a backslash followed by a plus sign followed by a six-digit hexadecimal code point number. For example, the string &lt;code&gt;'data'&lt;/code&gt; could be written as</source>
          <target state="translated">PostgreSQL还支持字符串的另一种转义语法，允许按代码点指定任意Unicode字符。 Unicode转义字符串常量以 &lt;code&gt;U&amp;amp;&lt;/code&gt; （大写或小写字母U，后跟与号）开头，紧接在开头的引号之前，中间没有空格，例如 &lt;code&gt;U&amp;amp;'foo'&lt;/code&gt; 。 （请注意，这与运算符 &lt;code&gt;&amp;amp;&lt;/code&gt; 产生了歧义。请在运算符周围使用空格以避免出现此问题。）在引号内，可以通过写反斜杠后跟四位数的十六进制代码点号或转义符来指定Unicode字符。或者，反斜杠后跟加号，后跟六位十六进制代码点编号。例如，字符串 &lt;code&gt;'data'&lt;/code&gt; 可以写成</target>
        </trans-unit>
        <trans-unit id="8b4d1cfe50623e59a66d0a1accf91a989fc0e27f" translate="yes" xml:space="preserve">
          <source>PostgreSQL also supports reporting dynamic information about exactly what is going on in the system right now, such as the exact command currently being executed by other server processes, and which other connections exist in the system. This facility is independent of the collector process.</source>
          <target state="translated">PostgreSQL还支持报告系统中现在到底发生了什么动态信息,比如其他服务器进程当前正在执行的确切命令,以及系统中还存在哪些连接。这个设施是独立于采集器进程的。</target>
        </trans-unit>
        <trans-unit id="478c7623d400e727e3280b1e79d887e002061f8f" translate="yes" xml:space="preserve">
          <source>PostgreSQL also supports the SQL-standard notations &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;float(p)&lt;/code&gt; for specifying inexact numeric types. Here, &lt;code&gt;p&lt;/code&gt; specifies the minimum acceptable precision in &lt;em&gt;binary&lt;/em&gt; digits. PostgreSQL accepts &lt;code&gt;float(1)&lt;/code&gt; to &lt;code&gt;float(24)&lt;/code&gt; as selecting the &lt;code&gt;real&lt;/code&gt; type, while &lt;code&gt;float(25)&lt;/code&gt; to &lt;code&gt;float(53)&lt;/code&gt; select &lt;code&gt;double precision&lt;/code&gt;. Values of &lt;code&gt;p&lt;/code&gt; outside the allowed range draw an error. &lt;code&gt;float&lt;/code&gt; with no precision specified is taken to mean &lt;code&gt;double precision&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL还支持SQL标准符号 &lt;code&gt;float&lt;/code&gt; 和 &lt;code&gt;float(p)&lt;/code&gt; 来指定不精确的数字类型。在此， &lt;code&gt;p&lt;/code&gt; 指定&lt;em&gt;二进制&lt;/em&gt;数字的最小可接受精度。PostgreSQL接受 &lt;code&gt;float(1)&lt;/code&gt; 到 &lt;code&gt;float(24)&lt;/code&gt; 作为 &lt;code&gt;real&lt;/code&gt; 型选择，而 &lt;code&gt;float(25)&lt;/code&gt; 到 &lt;code&gt;float(53)&lt;/code&gt; 选择 &lt;code&gt;double precision&lt;/code&gt; 。 &lt;code&gt;p&lt;/code&gt; 的值超出允许范围会产生错误。没有指定精度的 &lt;code&gt;float&lt;/code&gt; 表示 &lt;code&gt;double precision&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de648c643b7990a2f17212f7c4a34e709bba19e4" translate="yes" xml:space="preserve">
          <source>PostgreSQL always initially presumes that a regular expression follows the ARE rules. However, the more limited ERE or BRE rules can be chosen by prepending an &lt;em&gt;embedded option&lt;/em&gt; to the RE pattern, as described in &lt;a href=&quot;functions-matching#POSIX-METASYNTAX&quot;&gt;Section 9.7.3.4&lt;/a&gt;. This can be useful for compatibility with applications that expect exactly the POSIX 1003.2 rules.</source>
          <target state="translated">PostgreSQL最初总是假定正则表达式遵循ARE规则。但是，可以通过在RE模式之前添加&lt;em&gt;嵌入式选项&lt;/em&gt;来选择更有限的ERE或BRE规则，如&lt;a href=&quot;functions-matching#POSIX-METASYNTAX&quot;&gt;9.7.3.4节所述&lt;/a&gt;。这对于与完全期望POSIX 1003.2规则的应用程序兼容可能很有用。</target>
        </trans-unit>
        <trans-unit id="54903aca24fd73df3d0ecfd618b2abc92e61f984" translate="yes" xml:space="preserve">
          <source>PostgreSQL assumes that &lt;code&gt;CHECK&lt;/code&gt; constraints' conditions are immutable, that is, they will always give the same result for the same input row. This assumption is what justifies examining &lt;code&gt;CHECK&lt;/code&gt; constraints only when rows are inserted or updated, and not at other times. (The warning above about not referencing other table data is really a special case of this restriction.)</source>
          <target state="translated">PostgreSQL假设 &lt;code&gt;CHECK&lt;/code&gt; 约束的条件是不可变的，也就是说，对于相同的输入行，它们将始终给出相同的结果。这种假设证明只有在插入或更新行时才检查 &lt;code&gt;CHECK&lt;/code&gt; 约束，而在其他时候则不行。（上面关于未引用其他表数据的警告确实是此限制的一种特殊情况。）</target>
        </trans-unit>
        <trans-unit id="ff088d9be54485de195a863d4cf5285816323947" translate="yes" xml:space="preserve">
          <source>PostgreSQL assumes that &lt;code&gt;CHECK&lt;/code&gt; constraints' conditions are immutable, that is, they will always give the same result for the same input value. This assumption is what justifies examining &lt;code&gt;CHECK&lt;/code&gt; constraints only when a value is first converted to be of a domain type, and not at other times. (This is essentially the same as the treatment of table &lt;code&gt;CHECK&lt;/code&gt; constraints, as described in &lt;a href=&quot;ddl-constraints#DDL-CONSTRAINTS-CHECK-CONSTRAINTS&quot;&gt;Section 5.4.1&lt;/a&gt;.)</source>
          <target state="translated">PostgreSQL假设 &lt;code&gt;CHECK&lt;/code&gt; 约束的条件是不可变的，也就是说，对于相同的输入值，它们将始终给出相同的结果。这种假设证明只有在将值首先转换为域类型时才检查 &lt;code&gt;CHECK&lt;/code&gt; 约束，而在其他时候则不行。（这基本上与表 &lt;code&gt;CHECK&lt;/code&gt; 约束的处理相同，如&lt;a href=&quot;ddl-constraints#DDL-CONSTRAINTS-CHECK-CONSTRAINTS&quot;&gt;第5.4.1节中&lt;/a&gt;所述。）</target>
        </trans-unit>
        <trans-unit id="a2bff8b5a2ca5d91db2860fea9c0dad6138d0027" translate="yes" xml:space="preserve">
          <source>PostgreSQL automatically creates a unique index when a unique constraint or primary key is defined for a table. The index covers the columns that make up the primary key or unique constraint (a multicolumn index, if appropriate), and is the mechanism that enforces the constraint.</source>
          <target state="translated">当为表定义唯一约束或主键时,PostgreSQL会自动创建一个唯一索引。索引涵盖了构成主键或唯一约束的列(如果合适的话,是多列索引),是强制执行约束的机制。</target>
        </trans-unit>
        <trans-unit id="f26b59affbadfc237829843f54d3c4584d266882" translate="yes" xml:space="preserve">
          <source>PostgreSQL automatically creates an index for each unique constraint and primary key constraint to enforce uniqueness. Thus, it is not necessary to create an index explicitly for primary key columns. (See &lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt; for more information.)</source>
          <target state="translated">PostgreSQL自动为每个唯一性约束和主键约束创建索引以强制唯一性。因此，没有必要为主键列显式创建索引。（有关更多信息，请参见&lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="0b81b71597df376d9c14681a44f3238d9b5f3ccb" translate="yes" xml:space="preserve">
          <source>PostgreSQL can accept time zone specifications that are written according to the POSIX standard's rules for the &lt;code&gt;TZ&lt;/code&gt; environment variable. POSIX time zone specifications are inadequate to deal with the complexity of real-world time zone history, but there are sometimes reasons to use them.</source>
          <target state="translated">PostgreSQL可以接受时区规范，该时区规范是根据 &lt;code&gt;TZ&lt;/code&gt; 环境变量的POSIX标准的规则编写的。POSIX时区规范不足以解决现实世界中时区历史的复杂性，但是有时有使用它们的理由。</target>
        </trans-unit>
        <trans-unit id="71faf5408aef54cef3ab5e08ed45e5e43ecd20a6" translate="yes" xml:space="preserve">
          <source>PostgreSQL can build indexes while leveraging multiple CPUs in order to process the table rows faster. This feature is known as &lt;em&gt;parallel index build&lt;/em&gt;. For index methods that support building indexes in parallel (currently, only B-tree), &lt;code&gt;maintenance_work_mem&lt;/code&gt; specifies the maximum amount of memory that can be used by each index build operation as a whole, regardless of how many worker processes were started. Generally, a cost model automatically determines how many worker processes should be requested, if any.</source>
          <target state="translated">PostgreSQL可以在利用多个CPU的同时建立索引，以便更快地处理表行。此功能称为&lt;em&gt;并行索引构建&lt;/em&gt;。对于支持并行构建索引的索引方法（当前仅B树）， &lt;code&gt;maintenance_work_mem&lt;/code&gt; 指定整个索引构建操作可以整体使用的最大内存量，而不管启动了多少个工作进程。通常，成本模型会自动确定应请求多少个工人流程（如果有）。</target>
        </trans-unit>
        <trans-unit id="b61a24efb840bbdfd7121333fc936cd259d1497d" translate="yes" xml:space="preserve">
          <source>PostgreSQL can sometimes exhaust various operating system resource limits, especially when multiple copies of the server are running on the same system, or in very large installations. This section explains the kernel resources used by PostgreSQL and the steps you can take to resolve problems related to kernel resource consumption.</source>
          <target state="translated">PostgreSQL有时会耗尽各种操作系统的资源限制,特别是当服务器的多个副本在同一系统上运行,或者在非常大的安装中。本节解释了PostgreSQL使用的内核资源,以及你可以采取的步骤来解决与内核资源消耗有关的问题。</target>
        </trans-unit>
        <trans-unit id="b2e725f00d6a809e37502a0cf8c2fc8a68d3f58c" translate="yes" xml:space="preserve">
          <source>PostgreSQL comes with the following built-in range types:</source>
          <target state="translated">PostgreSQL内置了以下范围类型。</target>
        </trans-unit>
        <trans-unit id="cb387a6689d06faa79aaca21b4c8e065a066ab23" translate="yes" xml:space="preserve">
          <source>PostgreSQL considers distinct collation objects to be incompatible even when they have identical properties. Thus for example,</source>
          <target state="translated">PostgreSQL认为不同的整理对象即使有相同的属性也是不兼容的。因此,例如</target>
        </trans-unit>
        <trans-unit id="390d5417e842d1a1814896813c380671ee3b4fd0" translate="yes" xml:space="preserve">
          <source>PostgreSQL creates a temporary variable of data type &lt;code&gt;stype&lt;/code&gt; to hold the current internal state of the aggregate. At each input row, the aggregate argument value(s) are calculated and the state transition function is invoked with the current state value and the new argument value(s) to calculate a new internal state value. After all the rows have been processed, the final function is invoked once to calculate the aggregate's return value. If there is no final function then the ending state value is returned as-is.</source>
          <target state="translated">PostgreSQL创建一个数据类型为 &lt;code&gt;stype&lt;/code&gt; 的临时变量来保存聚合的当前内部状态。在每个输入行，将计算一个或多个汇总参数值，并使用当前状态值和新的参数值调用状态转换函数，以计算新的内部状态值。在处理完所有行之后，将一次调用final函数以计算聚合的返回值。如果没有最终功能，则按原样返回最终状态值。</target>
        </trans-unit>
        <trans-unit id="14a71a515034c71c679dfb591fbd291cd9591d60" translate="yes" xml:space="preserve">
          <source>PostgreSQL currently does not support multi-character collating elements. This information describes possible future behavior.</source>
          <target state="translated">PostgreSQL目前不支持多字符整理元素。此信息描述了未来可能的行为。</target>
        </trans-unit>
        <trans-unit id="7e2fde7f5f9c9a2ecbda1c45fded6817737c8d70" translate="yes" xml:space="preserve">
          <source>PostgreSQL database passwords are separate from operating system user passwords. The password for each database user is stored in the &lt;code&gt;pg_authid&lt;/code&gt; system catalog. Passwords can be managed with the SQL commands &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; and &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt;, e.g., &lt;strong&gt;&lt;code&gt;CREATE ROLE foo WITH LOGIN PASSWORD 'secret'&lt;/code&gt;&lt;/strong&gt;, or the psql command &lt;code&gt;\password&lt;/code&gt;. If no password has been set up for a user, the stored password is null and password authentication will always fail for that user.</source>
          <target state="translated">PostgreSQL数据库密码与操作系统用户密码分开。每个数据库用户的密码存储在 &lt;code&gt;pg_authid&lt;/code&gt; 系统目录中。可以使用SQL命令&lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;和&lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt;来管理密码，例如，&lt;strong&gt; &lt;code&gt;CREATE ROLE foo WITH LOGIN PASSWORD 'secret'&lt;/code&gt; &lt;/strong&gt;或使用psql命令 &lt;code&gt;\password&lt;/code&gt; 。如果未为用户设置密码，则存储的密码为null，并且该用户的密码身份验证将始终失败。</target>
        </trans-unit>
        <trans-unit id="ae07be10ad05f8eb77e791ce859f3046663e8d9e" translate="yes" xml:space="preserve">
          <source>PostgreSQL databases require periodic maintenance known as &lt;em&gt;vacuuming&lt;/em&gt;. For many installations, it is sufficient to let vacuuming be performed by the &lt;em&gt;autovacuum daemon&lt;/em&gt;, which is described in &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt;. You might need to adjust the autovacuuming parameters described there to obtain best results for your situation. Some database administrators will want to supplement or replace the daemon's activities with manually-managed &lt;code&gt;VACUUM&lt;/code&gt; commands, which typically are executed according to a schedule by cron or Task Scheduler scripts. To set up manually-managed vacuuming properly, it is essential to understand the issues discussed in the next few subsections. Administrators who rely on autovacuuming may still wish to skim this material to help them understand and adjust autovacuuming.</source>
          <target state="translated">PostgreSQL数据库需要定期维护，即&lt;em&gt;清理&lt;/em&gt;。对于许多安装而言，让&lt;em&gt;autovacuum守护程序&lt;/em&gt;执行吸尘就足够了，如&lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;第24.1.6节中所述&lt;/a&gt;。您可能需要调整此处描述的自动抽真空参数，以获得适合您情况的最佳结果。一些数据库管理员会希望通过手动管理的 &lt;code&gt;VACUUM&lt;/code&gt; 来补充或替换守护程序的活动。命令，通常由cron或Task Scheduler脚本根据时间表执行。为了正确设置手动管理的清理，必须理解接下来几个小节中讨论的问题。依靠自动抽真空的管理员可能仍希望略读此材料，以帮助他们了解和调整自动抽真空。</target>
        </trans-unit>
        <trans-unit id="0b15ec468b17952447cfdd51a679958ed70d2e48" translate="yes" xml:space="preserve">
          <source>PostgreSQL devises a &lt;em&gt;query plan&lt;/em&gt; for each query it receives. Choosing the right plan to match the query structure and the properties of the data is absolutely critical for good performance, so the system includes a complex &lt;em&gt;planner&lt;/em&gt; that tries to choose good plans. You can use the &lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt; command to see what query plan the planner creates for any query. Plan-reading is an art that requires some experience to master, but this section attempts to cover the basics.</source>
          <target state="translated">PostgreSQL 为收到的每个查询设计一个&lt;em&gt;查询计划&lt;/em&gt;。选择正确的计划以匹配查询结构和数据的属性对于获得良好的性能绝对至关重要，因此该系统包括一个复杂的&lt;em&gt;计划器&lt;/em&gt;，该计划器试图选择良好的计划。您可以使用&lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt;命令查看计划者为任何查询创建的查询计划。计划阅读是一门艺术，需要一定的经验来掌握，但是本节尝试介绍基础知识。</target>
        </trans-unit>
        <trans-unit id="c6bdc7ca1f027f4e423efc6001869a2aac8718c0" translate="yes" xml:space="preserve">
          <source>PostgreSQL does not have an explicit &lt;code&gt;OPEN&lt;/code&gt; cursor statement; a cursor is considered open when it is declared. Use the &lt;a href=&quot;sql-declare&quot;&gt;DECLARE&lt;/a&gt; statement to declare a cursor.</source>
          <target state="translated">PostgreSQL没有显式的 &lt;code&gt;OPEN&lt;/code&gt; 游标语句；当游标被声明时，它被认为是打开的。使用&lt;a href=&quot;sql-declare&quot;&gt;DECLARE&lt;/a&gt;语句声明游标。</target>
        </trans-unit>
        <trans-unit id="0dfef93504eab39387d43751a55a477c2955176f" translate="yes" xml:space="preserve">
          <source>PostgreSQL does not offer this type of replication, though PostgreSQL two-phase commit (&lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt; and &lt;a href=&quot;sql-commit-prepared&quot;&gt;COMMIT PREPARED&lt;/a&gt;) can be used to implement this in application code or middleware.</source>
          <target state="translated">PostgreSQL不提供这种复制，尽管可以使用PostgreSQL两阶段提交（&lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt;和&lt;a href=&quot;sql-commit-prepared&quot;&gt;COMMIT PREPARED&lt;/a&gt;）在应用程序代码或中间件中实现这种复制。</target>
        </trans-unit>
        <trans-unit id="bcb2a401b7b0ac69a360f9b7c695ed89ed9ebff0" translate="yes" xml:space="preserve">
          <source>PostgreSQL does not protect against correctable memory errors and it is assumed you will operate using RAM that uses industry standard Error Correcting Codes (ECC) or better protection.</source>
          <target state="translated">PostgreSQL不保护可纠正的内存错误,假定你将使用使用行业标准的纠错代码(ECC)或更好的保护的RAM来操作。</target>
        </trans-unit>
        <trans-unit id="13d3dc2372c98003c5a49c2b15eff6ff46f18e90" translate="yes" xml:space="preserve">
          <source>PostgreSQL does not protect against correctable memory errors and it is assumed you will operate using RAM that uses industry standard Error Correcting Codes (ECC) or better protection. However, ECC memory is typically only immune to single-bit errors, and should not be assumed to provide &lt;em&gt;absolute&lt;/em&gt; protection against failures that result in memory corruption.</source>
          <target state="translated">PostgreSQL不能防止可纠正的内存错误，并且假定您将使用使用行业标准错误纠正代码（ECC）或更好保护的RAM进行操作。但是，ECC内存通常仅能抵抗单位错误，并且不应假定ECC内存提供&lt;em&gt;绝对&lt;/em&gt;保护，以防止导致内存损坏的故障。</target>
        </trans-unit>
        <trans-unit id="1217e1656a3a27412f47a2f27ca6ddad0011cb8d" translate="yes" xml:space="preserve">
          <source>PostgreSQL does not provide the system software required to identify a failure on the primary and notify the standby database server. Many such tools exist and are well integrated with the operating system facilities required for successful failover, such as IP address migration.</source>
          <target state="translated">PostgreSQL不提供识别主数据库服务器故障并通知备用数据库服务器所需的系统软件。许多这样的工具已经存在,并与成功的故障转移所需的操作系统设施(如IP地址迁移)很好地集成在一起。</target>
        </trans-unit>
        <trans-unit id="1d796e67fd8db9494e77a87bae072c969985dce1" translate="yes" xml:space="preserve">
          <source>PostgreSQL does not support &lt;code&gt;CHECK&lt;/code&gt; constraints that reference table data other than the new or updated row being checked. While a &lt;code&gt;CHECK&lt;/code&gt; constraint that violates this rule may appear to work in simple tests, it cannot guarantee that the database will not reach a state in which the constraint condition is false (due to subsequent changes of the other row(s) involved). This would cause a database dump and reload to fail. The reload could fail even when the complete database state is consistent with the constraint, due to rows not being loaded in an order that will satisfy the constraint. If possible, use &lt;code&gt;UNIQUE&lt;/code&gt;, &lt;code&gt;EXCLUDE&lt;/code&gt;, or &lt;code&gt;FOREIGN KEY&lt;/code&gt; constraints to express cross-row and cross-table restrictions.</source>
          <target state="translated">PostgreSQL不支持 &lt;code&gt;CHECK&lt;/code&gt; 约束，该约束引用除检查的新行或更新行以外的表数据。尽管违反此规则的 &lt;code&gt;CHECK&lt;/code&gt; 约束似乎可以在简单测试中起作用，但它不能保证数据库不会达到约束条件为假（由于所涉及的其他行的后续更改）而不会导致的状态。这将导致数据库转储和重新加载失败。即使整个数据库状态与约束一致，重装也可能失败，这是因为未按满足约束的顺序加载行。如果可能，请使用 &lt;code&gt;UNIQUE&lt;/code&gt; ， &lt;code&gt;EXCLUDE&lt;/code&gt; 或 &lt;code&gt;FOREIGN KEY&lt;/code&gt; 约束来表示跨行和跨表的约束。</target>
        </trans-unit>
        <trans-unit id="cef8ed11bde695868953cc0c745e366d96215f8a" translate="yes" xml:space="preserve">
          <source>PostgreSQL doesn't remember any information about modified rows in memory, so there is no limit on the number of rows locked at one time. However, locking a row might cause a disk write, e.g., &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; modifies selected rows to mark them locked, and so will result in disk writes.</source>
          <target state="translated">PostgreSQL不会记住有关内存中已修改行的任何信息，因此一次锁定的行数没有限制。但是，锁定行可能会导致磁盘写入，例如， &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 修改所选行以将其标记为已锁定，因此将导致磁盘写入。</target>
        </trans-unit>
        <trans-unit id="63ab1d6406e057a762f3f310fecdc3a3bbd6104e" translate="yes" xml:space="preserve">
          <source>PostgreSQL endeavors to be compatible with the SQL standard definitions for typical usage. However, the SQL standard has an odd mix of date and time types and capabilities. Two obvious problems are:</source>
          <target state="translated">PostgreSQL努力兼容SQL标准定义的典型用法。然而,SQL标准在日期和时间类型和功能上有一个奇怪的混合。两个明显的问题是:</target>
        </trans-unit>
        <trans-unit id="66d120b7abdf73ead6dc3fd9f48bfc40f4f89b99" translate="yes" xml:space="preserve">
          <source>PostgreSQL enforces SQL uniqueness constraints using &lt;em&gt;unique indexes&lt;/em&gt;, which are indexes that disallow multiple entries with identical keys. An access method that supports this feature sets &lt;code&gt;amcanunique&lt;/code&gt; true. (At present, only b-tree supports it.) Columns listed in the &lt;code&gt;INCLUDE&lt;/code&gt; clause are not considered when enforcing uniqueness.</source>
          <target state="translated">PostgreSQL使用&lt;em&gt;唯一索引&lt;/em&gt;来强制执行SQL唯一性约束，&lt;em&gt;唯一&lt;/em&gt;索引是不允许具有相同键的多个条目的索引。支持此功能的访问方法将 &lt;code&gt;amcanunique&lt;/code&gt; 设置为 true。（当前，只有b树支持它。）强制唯一性时，不考虑 &lt;code&gt;INCLUDE&lt;/code&gt; 子句中列出的列。</target>
        </trans-unit>
        <trans-unit id="46cf5e94b98f5acb847fc69a661150beb395793b" translate="yes" xml:space="preserve">
          <source>PostgreSQL grants privileges on some types of objects to &lt;code&gt;PUBLIC&lt;/code&gt; by default when the objects are created. No privileges are granted to &lt;code&gt;PUBLIC&lt;/code&gt; by default on tables, table columns, sequences, foreign data wrappers, foreign servers, large objects, schemas, or tablespaces. For other types of objects, the default privileges granted to &lt;code&gt;PUBLIC&lt;/code&gt; are as follows: &lt;code&gt;CONNECT&lt;/code&gt; and &lt;code&gt;TEMPORARY&lt;/code&gt; (create temporary tables) privileges for databases; &lt;code&gt;EXECUTE&lt;/code&gt; privilege for functions and procedures; and &lt;code&gt;USAGE&lt;/code&gt; privilege for languages and data types (including domains). The object owner can, of course, &lt;code&gt;REVOKE&lt;/code&gt; both default and expressly granted privileges. (For maximum security, issue the &lt;code&gt;REVOKE&lt;/code&gt; in the same transaction that creates the object; then there is no window in which another user can use the object.) Also, these default privilege settings can be overridden using the &lt;a href=&quot;sql-alterdefaultprivileges&quot;&gt;ALTER DEFAULT PRIVILEGES&lt;/a&gt; command.</source>
          <target state="translated">创建对象时，PostgreSQL 默认将某些类型的对象的特权授予 &lt;code&gt;PUBLIC&lt;/code&gt; 。默认情况下，在表，表列，序列，外部数据包装器，外部服务器，大型对象，模式或表空间上，不授予 &lt;code&gt;PUBLIC&lt;/code&gt; 特权。对于其他类型的对象，授予 &lt;code&gt;PUBLIC&lt;/code&gt; 的默认特权如下：数据库的 &lt;code&gt;CONNECT&lt;/code&gt; 和 &lt;code&gt;TEMPORARY&lt;/code&gt; （创建临时表）特权；功能和程序的 &lt;code&gt;EXECUTE&lt;/code&gt; 特权；以及对语言和数据类型（包括域）的 &lt;code&gt;USAGE&lt;/code&gt; 特权。对象所有者当然可以 &lt;code&gt;REVOKE&lt;/code&gt; 默认特权和明确授予的特权。（为了获得最大的安全性，请在创建对象的同一事务中发出 &lt;code&gt;REVOKE&lt;/code&gt; ；然后，没有其他用户可以在其中使用该对象的窗口。）此外，可以使用&lt;a href=&quot;sql-alterdefaultprivileges&quot;&gt;ALTER DEFAULT PRIVILEGES&lt;/a&gt;命令来覆盖这些默认特权设置。</target>
        </trans-unit>
        <trans-unit id="7a3b4b281714f98b0b025baa01ab2e4079267b58" translate="yes" xml:space="preserve">
          <source>PostgreSQL handles column expansion by actually transforming the first form into the second. So, in this example, &lt;code&gt;myfunc()&lt;/code&gt; would get invoked three times per row with either syntax. If it's an expensive function you may wish to avoid that, which you can do with a query like:</source>
          <target state="translated">PostgreSQL通过实际将第一种形式转换为第二种形式来处理列扩展。因此，在此示例中，使用任何一种语法， &lt;code&gt;myfunc()&lt;/code&gt; 每行将被调用三次。如果这是一个昂贵的函数，您可能希望避免这种情况，您可以使用以下查询来做到这一点：</target>
        </trans-unit>
        <trans-unit id="df3dd7b1a171b6d6a80edc47008e7fbb158239c5" translate="yes" xml:space="preserve">
          <source>PostgreSQL handles temporary tables in a way rather different from the standard; see &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for details.</source>
          <target state="translated">PostgreSQL处理临时表的方式与标准完全不同。有关详细信息，请参见&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6d2f14dc9f7becae572a0674a0a8f299b6b7b7aa" translate="yes" xml:space="preserve">
          <source>PostgreSQL has a rich set of native data types available to users. Users can add new types to PostgreSQL using the &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt; command.</source>
          <target state="translated">PostgreSQL具有丰富的本机数据类型供用户使用。用户可以使用&lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt;命令将新类型添加到PostgreSQL 。</target>
        </trans-unit>
        <trans-unit id="78dda5739ec01795bd873fabe7ba9d163840acc7" translate="yes" xml:space="preserve">
          <source>PostgreSQL has an optional but highly recommended feature called &lt;em&gt;autovacuum&lt;/em&gt;, whose purpose is to automate the execution of &lt;code&gt;VACUUM&lt;/code&gt; and &lt;code&gt;ANALYZE&lt;/code&gt; commands. When enabled, autovacuum checks for tables that have had a large number of inserted, updated or deleted tuples. These checks use the statistics collection facility; therefore, autovacuum cannot be used unless &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-COUNTS&quot;&gt;track_counts&lt;/a&gt; is set to &lt;code&gt;true&lt;/code&gt;. In the default configuration, autovacuuming is enabled and the related configuration parameters are appropriately set.</source>
          <target state="translated">PostgreSQL有一个可选的但强烈推荐的功能，称为&lt;em&gt;autovacuum&lt;/em&gt;，其目的是自动执行 &lt;code&gt;VACUUM&lt;/code&gt; 和 &lt;code&gt;ANALYZE&lt;/code&gt; 命令。启用后，自动清理将检查具有大量插入，更新或删除的元组的表。这些检查使用统计信息收集工具；因此，除非&lt;a href=&quot;runtime-config-statistics#GUC-TRACK-COUNTS&quot;&gt;track_counts&lt;/a&gt;设置为 &lt;code&gt;true&lt;/code&gt; ,否则不能使用autovacuum 。在默认配置中，启用了自动抽真空，并已正确设置了相关的配置参数。</target>
        </trans-unit>
        <trans-unit id="745a9a5fff0d46d735897a2bfe230fa0dcd833f5" translate="yes" xml:space="preserve">
          <source>PostgreSQL has builtin support to perform JIT compilation using &lt;a href=&quot;https://llvm.org/&quot;&gt;LLVM&lt;/a&gt; when PostgreSQL is built with &lt;a href=&quot;https://www.postgresql.org/docs/12/install-procedure.html#CONFIGURE-WITH-LLVM&quot;&gt;&lt;code&gt;--with-llvm&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当使用&lt;a href=&quot;https://www.postgresql.org/docs/12/install-procedure.html#CONFIGURE-WITH-LLVM&quot;&gt; &lt;code&gt;--with-llvm&lt;/code&gt; &lt;/a&gt;构建PostgreSQL时，PostgreSQL 内置支持使用&lt;a href=&quot;https://llvm.org/&quot;&gt;LLVM&lt;/a&gt;执行JIT编译。</target>
        </trans-unit>
        <trans-unit id="f7ea341e1bda684ee6450441ed6006b9a4d3fe3f" translate="yes" xml:space="preserve">
          <source>PostgreSQL has builtin support to perform JIT compilation using &lt;a href=&quot;https://llvm.org/&quot;&gt;LLVM&lt;/a&gt; when PostgreSQL is built with &lt;a href=&quot;https://www.postgresql.org/docs/13/install-procedure.html#CONFIGURE-WITH-LLVM&quot;&gt;&lt;code&gt;--with-llvm&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当使用&lt;a href=&quot;https://www.postgresql.org/docs/13/install-procedure.html#CONFIGURE-WITH-LLVM&quot;&gt; &lt;code&gt;--with-llvm&lt;/code&gt; &lt;/a&gt;构建PostgreSQL时，PostgreSQL内置了使用&lt;a href=&quot;https://llvm.org/&quot;&gt;LLVM&lt;/a&gt;执行JIT编译的支持。</target>
        </trans-unit>
        <trans-unit id="1f59e9103489b1a27d73e875b095c1816ff90ee6" translate="yes" xml:space="preserve">
          <source>PostgreSQL has many features not touched upon in this tutorial introduction, which has been oriented toward newer users of SQL. These features are discussed in more detail in the remainder of this book.</source>
          <target state="translated">PostgreSQL有许多特性在本教程介绍中没有触及,它已经面向SQL的新用户。这些特性将在本书的其余部分详细讨论。</target>
        </trans-unit>
        <trans-unit id="34f532154e5db2109f00a916c27e879723393e79" translate="yes" xml:space="preserve">
          <source>PostgreSQL has native support for using SSL connections to encrypt client/server communications for increased security. This requires that OpenSSL is installed on both client and server systems and that support in PostgreSQL is enabled at build time (see &lt;a href=&quot;https://www.postgresql.org/docs/12/installation.html&quot;&gt;Chapter 16&lt;/a&gt;).</source>
          <target state="translated">PostgreSQL对使用SSL连接加密客户端/服务器通信以提高安全性提供了本机支持。这要求在客户端和服务器系统上都安装OpenSSL，并在构建时启用PostgreSQL支持（请参阅&lt;a href=&quot;https://www.postgresql.org/docs/12/installation.html&quot;&gt;第16章&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="640330cf66c03ad2dde6227a20793bf15623446d" translate="yes" xml:space="preserve">
          <source>PostgreSQL has native support for using SSL connections to encrypt client/server communications for increased security. This requires that OpenSSL is installed on both client and server systems and that support in PostgreSQL is enabled at build time (see &lt;a href=&quot;https://www.postgresql.org/docs/13/installation.html&quot;&gt;Chapter 16&lt;/a&gt;).</source>
          <target state="translated">PostgreSQL对使用SSL连接来加密客户端/服务器通信以提高安全性提供了本机支持。这要求在客户端和服务器系统上都安装OpenSSL，并在构建时启用PostgreSQL中的支持（请参阅&lt;a href=&quot;https://www.postgresql.org/docs/13/installation.html&quot;&gt;第16章&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ac22150741f7b1e7ae0c9084c74a767cc69f4028" translate="yes" xml:space="preserve">
          <source>PostgreSQL has the ability to report the progress of certain commands during command execution. Currently, the only commands which support progress reporting are &lt;code&gt;ANALYZE&lt;/code&gt;, &lt;code&gt;CLUSTER&lt;/code&gt;, &lt;code&gt;CREATE INDEX&lt;/code&gt;, &lt;code&gt;VACUUM&lt;/code&gt;, and &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-replication.html#PROTOCOL-REPLICATION-BASE-BACKUP&quot;&gt;BASE_BACKUP&lt;/a&gt; (i.e., replication command that &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt; issues to take a base backup). This may be expanded in the future.</source>
          <target state="translated">PostgreSQL能够在命令执行过程中报告某些命令的进度。当前，唯一支持进度报告的命令是 &lt;code&gt;ANALYZE&lt;/code&gt; ， &lt;code&gt;CLUSTER&lt;/code&gt; ， &lt;code&gt;CREATE INDEX&lt;/code&gt; ， &lt;code&gt;VACUUM&lt;/code&gt; 和&lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-replication.html#PROTOCOL-REPLICATION-BASE-BACKUP&quot;&gt;BASE_BACKUP&lt;/a&gt;（即&lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt;发布以进行基本备份的复制命令）。将来可能会扩大。</target>
        </trans-unit>
        <trans-unit id="2cee738042d576fe56c5cf2614b5d2a89ef2ed35" translate="yes" xml:space="preserve">
          <source>PostgreSQL has the ability to report the progress of certain commands during command execution. Currently, the only commands which support progress reporting are &lt;code&gt;CREATE INDEX&lt;/code&gt;, &lt;code&gt;VACUUM&lt;/code&gt; and &lt;code&gt;CLUSTER&lt;/code&gt;. This may be expanded in the future.</source>
          <target state="translated">PostgreSQL可以在命令执行期间报告某些命令的进度。当前，唯一支持进度报告的命令是 &lt;code&gt;CREATE INDEX&lt;/code&gt; ， &lt;code&gt;VACUUM&lt;/code&gt; 和 &lt;code&gt;CLUSTER&lt;/code&gt; 。将来可能会扩大。</target>
        </trans-unit>
        <trans-unit id="a153bd140b6eee429afa97ad0154361013ce149c" translate="yes" xml:space="preserve">
          <source>PostgreSQL implements portions of the SQL/MED specification, allowing you to access data that resides outside PostgreSQL using regular SQL queries. Such data is referred to as &lt;em&gt;foreign data&lt;/em&gt;. (Note that this usage is not to be confused with foreign keys, which are a type of constraint within the database.)</source>
          <target state="translated">PostgreSQL实现了SQL / MED规范的某些部分，允许您使用常规SQL查询访问PostgreSQL外部的数据。此类数据称为&lt;em&gt;外来数据&lt;/em&gt;。（请注意，不要将此用法与外键混淆，后者是数据库中的一种约束。）</target>
        </trans-unit>
        <trans-unit id="45ba54515ef38ae8443e32276665e58fc7c44f3d" translate="yes" xml:space="preserve">
          <source>PostgreSQL implements table inheritance, which can be a useful tool for database designers. (SQL:1999 and later define a type inheritance feature, which differs in many respects from the features described here.)</source>
          <target state="translated">PostgreSQL实现了表继承,这对数据库设计者来说是一个有用的工具。(SQL:1999及以后的版本定义了一个类型继承功能,它在许多方面与这里描述的功能不同)。</target>
        </trans-unit>
        <trans-unit id="9a4293b24f0d18f72db2fd6c1c67a47c9fab41ed" translate="yes" xml:space="preserve">
          <source>PostgreSQL includes a program &lt;a href=&quot;app-createuser&quot;&gt;createuser&lt;/a&gt; that has the same functionality as &lt;code&gt;CREATE ROLE&lt;/code&gt; (in fact, it calls this command) but can be run from the command shell.</source>
          <target state="translated">PostgreSQL包含一个程序&lt;a href=&quot;app-createuser&quot;&gt;createuser&lt;/a&gt;，它具有与 &lt;code&gt;CREATE ROLE&lt;/code&gt; 相同的功能（实际上，它调用此命令），但是可以从命令外壳运行。</target>
        </trans-unit>
        <trans-unit id="84114ad3110b572f55729ff61c07b1a5d40daec3" translate="yes" xml:space="preserve">
          <source>PostgreSQL includes a program &lt;a href=&quot;app-dropuser&quot;&gt;dropuser&lt;/a&gt; that has the same functionality as this command (in fact, it calls this command) but can be run from the command shell.</source>
          <target state="translated">PostgreSQL包含一个程序&lt;a href=&quot;app-dropuser&quot;&gt;dropuser&lt;/a&gt;，该程序具有与此命令相同的功能（实际上，它调用此命令），但是可以从命令外壳运行。</target>
        </trans-unit>
        <trans-unit id="682b0969ef85f21e73efd9cc0f1d64eca421eb6a" translate="yes" xml:space="preserve">
          <source>PostgreSQL includes a sizable set of built-in data types that fit many applications. Users can also define their own data types. Most built-in data types have obvious names and semantics, so we defer a detailed explanation to &lt;a href=&quot;datatype&quot;&gt;Chapter 8&lt;/a&gt;. Some of the frequently used data types are &lt;code&gt;integer&lt;/code&gt; for whole numbers, &lt;code&gt;numeric&lt;/code&gt; for possibly fractional numbers, &lt;code&gt;text&lt;/code&gt; for character strings, &lt;code&gt;date&lt;/code&gt; for dates, &lt;code&gt;time&lt;/code&gt; for time-of-day values, and &lt;code&gt;timestamp&lt;/code&gt; for values containing both date and time.</source>
          <target state="translated">PostgreSQL包括一组适合许多应用程序的内置数据类型。用户还可以定义自己的数据类型。大多数内置数据类型具有明显的名称和语义，因此我们将详细说明交给&lt;a href=&quot;datatype&quot;&gt;第8章&lt;/a&gt;。一些常用的数据类型是： &lt;code&gt;integer&lt;/code&gt; ， &lt;code&gt;numeric&lt;/code&gt; （可能的分数）， &lt;code&gt;text&lt;/code&gt; 的字符串， &lt;code&gt;date&lt;/code&gt; 的日期， &lt;code&gt;time&lt;/code&gt; 的值以及包含日期和时间的值的 &lt;code&gt;timestamp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="735559b54f06b3f3f206e8111b18e4ea8d9566e4" translate="yes" xml:space="preserve">
          <source>PostgreSQL includes an &amp;ldquo;autovacuum&amp;rdquo; facility which can automate routine vacuum maintenance. For more information about automatic and manual vacuuming, see &lt;a href=&quot;routine-vacuuming&quot;&gt;Section 24.1&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL包括一个&amp;ldquo; autovacuum&amp;rdquo;工具，可以自动执行日常真空维护。有关自动和手动吸尘的更多信息，请参见&lt;a href=&quot;routine-vacuuming&quot;&gt;第24.1节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ffa60848047cd6b07df3ba1987237f159ca48b0a" translate="yes" xml:space="preserve">
          <source>PostgreSQL includes an implementation of the standard btree (multi-way balanced tree) index data structure. Any data type that can be sorted into a well-defined linear order can be indexed by a btree index. The only limitation is that an index entry cannot exceed approximately one-third of a page (after TOAST compression, if applicable).</source>
          <target state="translated">PostgreSQL包含了标准btree(多向平衡树)索引数据结构的实现。任何可以排序为定义良好的线性顺序的数据类型都可以通过btree索引进行索引。唯一的限制是一个索引条目不能超过页面的大约三分之一(如果适用,经过TOAST压缩后)。</target>
        </trans-unit>
        <trans-unit id="d6a78d8c03890ed632c11d38bfbd22f9d27d3999" translate="yes" xml:space="preserve">
          <source>PostgreSQL includes one function to generate a UUID:</source>
          <target state="translated">PostgreSQL包含一个生成UUID的函数。</target>
        </trans-unit>
        <trans-unit id="821fe06f71c1808348a7b91e09179799740b9a95" translate="yes" xml:space="preserve">
          <source>PostgreSQL is a &lt;em&gt;relational database management system&lt;/em&gt; (RDBMS). That means it is a system for managing data stored in &lt;em&gt;relations&lt;/em&gt;. Relation is essentially a mathematical term for &lt;em&gt;table&lt;/em&gt;. The notion of storing data in tables is so commonplace today that it might seem inherently obvious, but there are a number of other ways of organizing databases. Files and directories on Unix-like operating systems form an example of a hierarchical database. A more modern development is the object-oriented database.</source>
          <target state="translated">PostgreSQL是一个&lt;em&gt;关系数据库管理系统&lt;/em&gt;（RDBMS）。这意味着它是用于管理&lt;em&gt;关系中&lt;/em&gt;存储的数据的系统。关系本质上是&lt;em&gt;表&lt;/em&gt;的数学术语。在表中存储数据的概念如今已变得司空见惯，以至于在本质上似乎显而易见，但是还有许多其他组织数据库的方式。类似于Unix的操作系统上的文件和目录构成了分层数据库的示例。面向对象的数据库是一个更现代的发展。</target>
        </trans-unit>
        <trans-unit id="9cfd426182152d61be1e2778a072f15bc552fcab" translate="yes" xml:space="preserve">
          <source>PostgreSQL is implemented using a simple &amp;ldquo;process per user&amp;rdquo; client/server model. In this model there is one &lt;em&gt;client process&lt;/em&gt; connected to exactly one &lt;em&gt;server process&lt;/em&gt;. As we do not know ahead of time how many connections will be made, we have to use a &lt;em&gt;master process&lt;/em&gt; that spawns a new server process every time a connection is requested. This master process is called &lt;code&gt;postgres&lt;/code&gt; and listens at a specified TCP/IP port for incoming connections. Whenever a request for a connection is detected the &lt;code&gt;postgres&lt;/code&gt; process spawns a new server process. The server tasks communicate with each other using &lt;em&gt;semaphores&lt;/em&gt; and &lt;em&gt;shared memory&lt;/em&gt; to ensure data integrity throughout concurrent data access.</source>
          <target state="translated">PostgreSQL是使用简单的&amp;ldquo;每用户进程&amp;rdquo;客户端/服务器模型实现的。在此模型中，有一个&lt;em&gt;客户端进程&lt;/em&gt;恰好连接到一个&lt;em&gt;服务器进程&lt;/em&gt;。由于我们无法提前知道将建立多少个连接，因此必须使用&lt;em&gt;主进程&lt;/em&gt;，该&lt;em&gt;主进程&lt;/em&gt;在每次请求连接时都会生成一个新的服务器进程。这个主进程称为 &lt;code&gt;postgres&lt;/code&gt; ，它在指定的TCP / IP端口上侦听传入的连接。只要检测到连接请求， &lt;code&gt;postgres&lt;/code&gt; 进程就会生成一个新的服务器进程。服务器任务使用&lt;em&gt;信号量&lt;/em&gt;和&lt;em&gt;共享内存&lt;/em&gt;相互通信&lt;em&gt;&lt;/em&gt; 以确保在并发数据访问期间的数据完整性。</target>
        </trans-unit>
        <trans-unit id="e5b0c6c6215c78ea032d3a013c7f4ae434fd6519" translate="yes" xml:space="preserve">
          <source>PostgreSQL is more flexible in handling date/time input than the SQL standard requires. See &lt;a href=&quot;https://www.postgresql.org/docs/12/datetime-appendix.html&quot;&gt;Appendix B&lt;/a&gt; for the exact parsing rules of date/time input and for the recognized text fields including months, days of the week, and time zones.</source>
          <target state="translated">PostgreSQL比SQL标准更灵活地处理日期/时间输入。有关日期/时间输入的确切解析规则以及公认的文本字段（包括月份，星期几和时区），请参阅&lt;a href=&quot;https://www.postgresql.org/docs/12/datetime-appendix.html&quot;&gt;附录B。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e736d3c1e26ee5e1fae5c95f8dd1c63e5c415e11" translate="yes" xml:space="preserve">
          <source>PostgreSQL is more flexible in handling date/time input than the SQL standard requires. See &lt;a href=&quot;https://www.postgresql.org/docs/13/datetime-appendix.html&quot;&gt;Appendix B&lt;/a&gt; for the exact parsing rules of date/time input and for the recognized text fields including months, days of the week, and time zones.</source>
          <target state="translated">PostgreSQL比SQL标准更灵活地处理日期/时间输入。有关日期/时间输入的确切解析规则以及公认的文本字段（包括月份，星期几和时区），请参阅&lt;a href=&quot;https://www.postgresql.org/docs/13/datetime-appendix.html&quot;&gt;附录B。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c828eb4cf5a62919aaf9e56822812dfeb42eacd5" translate="yes" xml:space="preserve">
          <source>PostgreSQL is very extensible and allows new data types, functions, operators and other database objects to be defined; see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend.html&quot;&gt;Chapter 37&lt;/a&gt;. In fact the built-in objects are implemented using nearly the same mechanisms. This extensibility implies some overhead, for example due to function calls (see &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc.html&quot;&gt;Section 37.3&lt;/a&gt;). To reduce that overhead, JIT compilation can inline the bodies of small functions into the expressions using them. That allows a significant percentage of the overhead to be optimized away.</source>
          <target state="translated">PostgreSQL是非常可扩展的，并允许定义新的数据类型，函数，运算符和其他数据库对象。参见&lt;a href=&quot;https://www.postgresql.org/docs/12/extend.html&quot;&gt;第37章&lt;/a&gt;。实际上，内置对象是使用几乎相同的机制实现的。这种可扩展性意味着一些开销，例如由于函数调用（请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc.html&quot;&gt;第37.3节&lt;/a&gt;）。为了减少这些开销，JIT编译可以使用小函数的内联函数将其内联到表达式中。这样就可以将很大一部分开销进行优化。</target>
        </trans-unit>
        <trans-unit id="b06ee715ba9fc1a2cac6f18f375e3b7a31953a1c" translate="yes" xml:space="preserve">
          <source>PostgreSQL is very extensible and allows new data types, functions, operators and other database objects to be defined; see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend.html&quot;&gt;Chapter 37&lt;/a&gt;. In fact the built-in objects are implemented using nearly the same mechanisms. This extensibility implies some overhead, for example due to function calls (see &lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc.html&quot;&gt;Section 37.3&lt;/a&gt;). To reduce that overhead, JIT compilation can inline the bodies of small functions into the expressions using them. That allows a significant percentage of the overhead to be optimized away.</source>
          <target state="translated">PostgreSQL是非常可扩展的，并允许定义新的数据类型，函数，运算符和其他数据库对象。参见&lt;a href=&quot;https://www.postgresql.org/docs/13/extend.html&quot;&gt;第37章&lt;/a&gt;。实际上，内置对象是使用几乎相同的机制实现的。这种可扩展性意味着一些开销，例如由于函数调用（请参见&lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc.html&quot;&gt;第37.3节&lt;/a&gt;）。为了减少开销，JIT编译可以使用小函数的内联函数将其内联到表达式中。这样就可以将很大一部分开销进行优化。</target>
        </trans-unit>
        <trans-unit id="66bf58dffda176b2af709bb0e9bb018d0b319b34" translate="yes" xml:space="preserve">
          <source>PostgreSQL lets you reference columns of other tables in the &lt;code&gt;WHERE&lt;/code&gt; condition by specifying the other tables in the &lt;code&gt;USING&lt;/code&gt; clause. For example, to delete all films produced by a given producer, one can do:</source>
          <target state="translated">PostgreSQL 通过在 &lt;code&gt;USING&lt;/code&gt; 子句中指定其他表，允许您在 &lt;code&gt;WHERE&lt;/code&gt; 条件下引用其他表的列。例如，要删除给定制片人制作的所有电影，可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="575317fbf767c3750ee89eec8e188302800f4189" translate="yes" xml:space="preserve">
          <source>PostgreSQL makes use of symbolic links to simplify the implementation of tablespaces. This means that tablespaces can be used &lt;em&gt;only&lt;/em&gt; on systems that support symbolic links.</source>
          <target state="translated">PostgreSQL利用符号链接来简化表空间的实现。这意味着表空间&lt;em&gt;只能&lt;/em&gt;在支持符号链接的系统上使用。</target>
        </trans-unit>
        <trans-unit id="c0ca6dd2831d7be94912fd0050870a1cb327936d" translate="yes" xml:space="preserve">
          <source>PostgreSQL offers a way to specify how to divide a table into pieces called partitions. The table that is divided is referred to as a &lt;em&gt;partitioned table&lt;/em&gt;. The specification consists of the &lt;em&gt;partitioning method&lt;/em&gt; and a list of columns or expressions to be used as the &lt;em&gt;partition key&lt;/em&gt;.</source>
          <target state="translated">PostgreSQL提供了一种指定如何将表划分为多个部分的方法。被划分的表称为&lt;em&gt;分区表&lt;/em&gt;。该规范包括&lt;em&gt;分区方法&lt;/em&gt;和用作&lt;em&gt;分区键&lt;/em&gt;的列或表达式列表。</target>
        </trans-unit>
        <trans-unit id="891f5d2a022ddd1dd671a070027ea1cff8f75e34" translate="yes" xml:space="preserve">
          <source>PostgreSQL offers built-in support for the following forms of partitioning:</source>
          <target state="translated">PostgreSQL提供了对以下分区形式的内置支持。</target>
        </trans-unit>
        <trans-unit id="5662adc70468d34652ede9f811304c570cee30e3" translate="yes" xml:space="preserve">
          <source>PostgreSQL offers data types to store IPv4, IPv6, and MAC addresses, as shown in &lt;a href=&quot;datatype-net-types#DATATYPE-NET-TYPES-TABLE&quot;&gt;Table 8.21&lt;/a&gt;. It is better to use these types instead of plain text types to store network addresses, because these types offer input error checking and specialized operators and functions (see &lt;a href=&quot;functions-net&quot;&gt;Section 9.12&lt;/a&gt;).</source>
          <target state="translated">PostgreSQL提供了用于存储IPv4，IPv6和MAC地址的数据类型，如&lt;a href=&quot;datatype-net-types#DATATYPE-NET-TYPES-TABLE&quot;&gt;表8.21&lt;/a&gt;所示。最好使用这些类型而不是纯文本类型来存储网络地址，因为这些类型提供输入错误检查以及专门的运算符和功能（请参见&lt;a href=&quot;functions-net&quot;&gt;第9.12节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="84c215e752220c438a12a8423b6fe5998d9faf4a" translate="yes" xml:space="preserve">
          <source>PostgreSQL offers encryption at several levels, and provides flexibility in protecting data from disclosure due to database server theft, unscrupulous administrators, and insecure networks. Encryption might also be required to secure sensitive data such as medical records or financial transactions.</source>
          <target state="translated">PostgreSQL提供了多个级别的加密功能,可以灵活地保护数据不因数据库服务器被盗、不法管理员和不安全的网络而泄露。也可能需要加密来保护敏感数据,如医疗记录或金融交易。</target>
        </trans-unit>
        <trans-unit id="69f5fb450ee35fca9053db0e9cf0fee2e325d788" translate="yes" xml:space="preserve">
          <source>PostgreSQL offers two types for storing JSON data: &lt;code&gt;json&lt;/code&gt; and &lt;code&gt;jsonb&lt;/code&gt;. To implement efficient query mechanisms for these data types, PostgreSQL also provides the &lt;code&gt;jsonpath&lt;/code&gt; data type described in &lt;a href=&quot;datatype-json#DATATYPE-JSONPATH&quot;&gt;Section 8.14.6&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL提供了两种存储JSON数据的类型： &lt;code&gt;json&lt;/code&gt; 和 &lt;code&gt;jsonb&lt;/code&gt; 。为了对这些数据类型实现有效的查询机制，PostgreSQL还提供了&lt;a href=&quot;datatype-json#DATATYPE-JSONPATH&quot;&gt;第8.14.6节中&lt;/a&gt;描述的 &lt;code&gt;jsonpath&lt;/code&gt; 数据类型。</target>
        </trans-unit>
        <trans-unit id="926dbd334c49f127c9efe79cdb0a9983f9b87b3a" translate="yes" xml:space="preserve">
          <source>PostgreSQL only allows the execution of a user-defined function for the triggered action. The standard allows the execution of a number of other SQL commands, such as &lt;code&gt;CREATE TABLE&lt;/code&gt;, as the triggered action. This limitation is not hard to work around by creating a user-defined function that executes the desired commands.</source>
          <target state="translated">PostgreSQL仅允许执行触发操作的用户定义函数。该标准允许执行许多其他SQL命令，例如 &lt;code&gt;CREATE TABLE&lt;/code&gt; ，作为触发操作。通过创建执行所需命令的用户定义函数，不难解决此限制。</target>
        </trans-unit>
        <trans-unit id="43083b6336b02575039a2d9d8f76b5988935b20e" translate="yes" xml:space="preserve">
          <source>PostgreSQL procedural language libraries can be preloaded in this way, typically by using the syntax &lt;code&gt;'$libdir/plXXX'&lt;/code&gt; where &lt;code&gt;XXX&lt;/code&gt; is &lt;code&gt;pgsql&lt;/code&gt;, &lt;code&gt;perl&lt;/code&gt;, &lt;code&gt;tcl&lt;/code&gt;, or &lt;code&gt;python&lt;/code&gt;.</source>
          <target state="translated">可以以这种方式预加载PostgreSQL过程语言库，通常使用语法 &lt;code&gt;'$libdir/plXXX'&lt;/code&gt; ，其中 &lt;code&gt;XXX&lt;/code&gt; 是 &lt;code&gt;pgsql&lt;/code&gt; ， &lt;code&gt;perl&lt;/code&gt; ， &lt;code&gt;tcl&lt;/code&gt; 或 &lt;code&gt;python&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f59dd80e652539f7d5e5bc6cc2d156491128c008" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides a JIT implementation based on LLVM. The interface to the JIT provider is pluggable and the provider can be changed without recompiling (although currently, the build process only provides inlining support data for LLVM). The active provider is chosen via the setting &lt;a href=&quot;runtime-config-client#GUC-JIT-PROVIDER&quot;&gt;jit_provider&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL提供了基于LLVM的JIT实现。JIT提供程序的接口是可插入的，并且可以在不重新编译的情况下更改提供程序（尽管当前，构建过程仅提供LLVM的内联支持数据）。通过设置&lt;a href=&quot;runtime-config-client#GUC-JIT-PROVIDER&quot;&gt;jit_provider&lt;/a&gt;选择活动的提供程序。</target>
        </trans-unit>
        <trans-unit id="fe91789313046ec6475705a372e78ba71b0024c0" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides a function to inspect complex statistics defined using the &lt;code&gt;CREATE STATISTICS&lt;/code&gt; command.</source>
          <target state="translated">PostgreSQL提供了一种检查使用 &lt;code&gt;CREATE STATISTICS&lt;/code&gt; 命令定义的复杂统计信息的功能。</target>
        </trans-unit>
        <trans-unit id="46fdddf06cc7902f32855be5f7713801b1905af6" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides a means for creating locks that have application-defined meanings. These are called &lt;em&gt;advisory locks&lt;/em&gt;, because the system does not enforce their use &amp;mdash; it is up to the application to use them correctly. Advisory locks can be useful for locking strategies that are an awkward fit for the MVCC model. For example, a common use of advisory locks is to emulate pessimistic locking strategies typical of so-called &amp;ldquo;flat file&amp;rdquo; data management systems. While a flag stored in a table could be used for the same purpose, advisory locks are faster, avoid table bloat, and are automatically cleaned up by the server at the end of the session.</source>
          <target state="translated">PostgreSQL提供了一种创建具有应用程序定义含义的锁的方法。这些被称为&lt;em&gt;咨询锁&lt;/em&gt;，因为系统不会强制使用它们-取决于应用程序是否正确使用它们。咨询性锁定对于不适用于MVCC模型的锁定策略很有用。例如，咨询锁的常见用法是模拟所谓的&amp;ldquo;平面文件&amp;rdquo;数据管理系统特有的悲观锁策略。虽然存储在表中的标志可以用于相同的目的，但咨询锁更快，可以避免表膨胀，并在会话结束时由服务器自动清除。</target>
        </trans-unit>
        <trans-unit id="0cfb1fbdc7aff0cefa972216042683bcba69e5d6" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides a number of functions that return values related to the current date and time. These SQL-standard functions all return values based on the start time of the current transaction:</source>
          <target state="translated">PostgreSQL提供了一些函数,这些函数返回与当前日期和时间相关的值。这些SQL标准函数都是根据当前事务的开始时间来返回值。</target>
        </trans-unit>
        <trans-unit id="b4d4d96a6016bf1a3419a8adde28df6d7f17d284" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides a rich set of tools for developers to manage concurrent access to data. Internally, data consistency is maintained by using a multiversion model (Multiversion Concurrency Control, MVCC). This means that each SQL statement sees a snapshot of data (a &lt;em&gt;database version&lt;/em&gt;) as it was some time ago, regardless of the current state of the underlying data. This prevents statements from viewing inconsistent data produced by concurrent transactions performing updates on the same data rows, providing &lt;em&gt;transaction isolation&lt;/em&gt; for each database session. MVCC, by eschewing the locking methodologies of traditional database systems, minimizes lock contention in order to allow for reasonable performance in multiuser environments.</source>
          <target state="translated">PostgreSQL为开发人员提供了一套丰富的工具来管理对数据的并发访问。在内部，通过使用多版本模型（Multiversion Concurrency Control，MVCC）来维护数据一致性。这意味着无论基础数据的当前状态如何，每个SQL语句都可以像以前一样看到数据快照（&lt;em&gt;数据库版本&lt;/em&gt;）。这样可以防止语句查看由并发事务对同一数据行执行更新而产生的不一致数据，从而为每个数据库会话提供&lt;em&gt;事务隔离&lt;/em&gt;。 MVCC通过避免传统数据库系统的锁定方法，最大程度地减少了锁定争用，以便在多用户环境中实现合理的性能。</target>
        </trans-unit>
        <trans-unit id="1ecdd68232ab41018a2aebf2b36bf6bfee6f90a3" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides a set of default roles which provide access to certain, commonly needed, privileged capabilities and information. Administrators can GRANT these roles to users and/or other roles in their environment, providing those users with access to the specified capabilities and information.</source>
          <target state="translated">PostgreSQL提供了一组默认角色,这些角色提供了对某些通常需要的特权功能和信息的访问权限,管理员可以将这些角色授予用户和/或环境中的其他角色,为这些用户提供对指定功能和信息的访问权限。管理员可以将这些角色授予用户和/或环境中的其他角色,使这些用户能够访问指定的功能和信息。</target>
        </trans-unit>
        <trans-unit id="12a7e7c8c66bad39574adedb86e60a5508ed2a12" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides facilities to support dynamic tracing of the database server. This allows an external utility to be called at specific points in the code and thereby trace execution.</source>
          <target state="translated">PostgreSQL提供了支持动态跟踪数据库服务器的设施。这允许在代码中的特定点调用外部工具,从而跟踪执行情况。</target>
        </trans-unit>
        <trans-unit id="93788cdb40903d97aaf58bdd1f296a2d0af57e6d" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides predefined dictionaries for many languages. There are also several predefined templates that can be used to create new dictionaries with custom parameters. Each predefined dictionary template is described below. If no existing template is suitable, it is possible to create new ones; see the &lt;code&gt;contrib/&lt;/code&gt; area of the PostgreSQL distribution for examples.</source>
          <target state="translated">PostgreSQL提供了许多语言的预定义词典。还有一些预定义的模板可用于创建带有自定义参数的新字典。每个预定义的词典模板描述如下。如果没有合适的现有模板，则可以创建新模板。有关示例，请参见PostgreSQL发行版的 &lt;code&gt;contrib/&lt;/code&gt; 区域。</target>
        </trans-unit>
        <trans-unit id="abe4b5b2c2d17d1440228c909b7105d20d3d03a0" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides several features for breaking down complex &lt;code&gt;postgresql.conf&lt;/code&gt; files into sub-files. These features are especially useful when managing multiple servers with related, but not identical, configurations.</source>
          <target state="translated">PostgreSQL提供了几种功能，可以将复杂的 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件分解为子文件。当使用相关但不相同的配置管理多台服务器时，这些功能特别有用。</target>
        </trans-unit>
        <trans-unit id="12ddc3899973df221c8322e34a526586b23ebfaa" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides several index types: B-tree, Hash, GiST, SP-GiST, GIN and BRIN. Each index type uses a different algorithm that is best suited to different types of queries. By default, the &lt;code&gt;CREATE INDEX&lt;/code&gt; command creates B-tree indexes, which fit the most common situations.</source>
          <target state="translated">PostgreSQL提供了几种索引类型：B树，哈希，GiST，SP-GiST，GIN和BRIN。每种索引类型使用最适合不同类型查询的不同算法。默认情况下， &lt;code&gt;CREATE INDEX&lt;/code&gt; 命令创建B树索引，该索引适合最常见的情况。</target>
        </trans-unit>
        <trans-unit id="4d643a989351582bdcc707ed3905be058a733c4a" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides storage and comparison functions for UUIDs, but the core database does not include any function for generating UUIDs, because no single algorithm is well suited for every application. The &lt;a href=&quot;uuid-ossp&quot;&gt;uuid-ossp&lt;/a&gt; module provides functions that implement several standard algorithms. The &lt;a href=&quot;pgcrypto&quot;&gt;pgcrypto&lt;/a&gt; module also provides a generation function for random UUIDs. Alternatively, UUIDs could be generated by client applications or other libraries invoked through a server-side function.</source>
          <target state="translated">PostgreSQL提供了用于UUID的存储和比较功能，但是核心数据库不包含任何用于生成UUID的功能，因为没有一种算法适合于每个应用程序。的&lt;a href=&quot;uuid-ossp&quot;&gt;UUID-OSSP&lt;/a&gt;模块提供了数个实施标准算法功能。所述&lt;a href=&quot;pgcrypto&quot;&gt;pgcrypto&lt;/a&gt;模块还提供了一种随机的UUID生成函数。或者，UUID可以由客户端应用程序或通过服务器端功能调用的其他库生成。</target>
        </trans-unit>
        <trans-unit id="a8055d8a3fe512bf9a836cadb5eae9c2e8b86c5c" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides the function &lt;code&gt;to_tsvector&lt;/code&gt; for converting a document to the &lt;code&gt;tsvector&lt;/code&gt; data type.</source>
          <target state="translated">PostgreSQL提供了 &lt;code&gt;to_tsvector&lt;/code&gt; 函数,用于将文档转换为 &lt;code&gt;tsvector&lt;/code&gt; 数据类型。</target>
        </trans-unit>
        <trans-unit id="987c367c1a1efc0cb03cfb3dd34409cf91adaf69" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides the functions &lt;code&gt;to_tsquery&lt;/code&gt;, &lt;code&gt;plainto_tsquery&lt;/code&gt;, &lt;code&gt;phraseto_tsquery&lt;/code&gt; and &lt;code&gt;websearch_to_tsquery&lt;/code&gt; for converting a query to the &lt;code&gt;tsquery&lt;/code&gt; data type. &lt;code&gt;to_tsquery&lt;/code&gt; offers access to more features than either &lt;code&gt;plainto_tsquery&lt;/code&gt; or &lt;code&gt;phraseto_tsquery&lt;/code&gt;, but it is less forgiving about its input. &lt;code&gt;websearch_to_tsquery&lt;/code&gt; is a simplified version of &lt;code&gt;to_tsquery&lt;/code&gt; with an alternative syntax, similar to the one used by web search engines.</source>
          <target state="translated">PostgreSQL提供了 &lt;code&gt;to_tsquery&lt;/code&gt; ， &lt;code&gt;plainto_tsquery&lt;/code&gt; ， &lt;code&gt;phraseto_tsquery&lt;/code&gt; 和 &lt;code&gt;websearch_to_tsquery&lt;/code&gt; 函数，用于将查询转换为 &lt;code&gt;tsquery&lt;/code&gt; 数据类型。与 &lt;code&gt;plainto_tsquery&lt;/code&gt; 或 &lt;code&gt;phraseto_tsquery&lt;/code&gt; 相比， &lt;code&gt;to_tsquery&lt;/code&gt; 提供了更多的功能，但是对它的输入的宽容度较小。 &lt;code&gt;websearch_to_tsquery&lt;/code&gt; 是 &lt;code&gt;to_tsquery&lt;/code&gt; 的简化版本，具有替代语法，类似于网络搜索引擎使用的语法。</target>
        </trans-unit>
        <trans-unit id="d433b9e1cb0cc5f1366352a11ce9410f17e6d0fd" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides the index methods B-tree, hash, GiST, SP-GiST, GIN, and BRIN. Users can also define their own index methods, but that is fairly complicated.</source>
          <target state="translated">PostgreSQL提供了B-tree、hash、GiST、SP-GiST、GIN和BRIN等索引方法。用户也可以定义自己的索引方法,但这相当复杂。</target>
        </trans-unit>
        <trans-unit id="bed8f31d13fc879249d79e50cd113d8dd0d3c306" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides the standard SQL type &lt;code&gt;boolean&lt;/code&gt;; see &lt;a href=&quot;datatype-boolean#DATATYPE-BOOLEAN-TABLE&quot;&gt;Table 8.19&lt;/a&gt;. The &lt;code&gt;boolean&lt;/code&gt; type can have several states: &amp;ldquo;true&amp;rdquo;, &amp;ldquo;false&amp;rdquo;, and a third state, &amp;ldquo;unknown&amp;rdquo;, which is represented by the SQL null value.</source>
          <target state="translated">PostgreSQL提供了标准的SQL类型 &lt;code&gt;boolean&lt;/code&gt; ; 见&lt;a href=&quot;datatype-boolean#DATATYPE-BOOLEAN-TABLE&quot;&gt;表8.19&lt;/a&gt;。在 &lt;code&gt;boolean&lt;/code&gt; 类型可以有几种状态：&amp;ldquo;真&amp;rdquo;，&amp;ldquo;假&amp;rdquo;，与第三国，&amp;ldquo;未知&amp;rdquo;，这是由SQL空值表示。</target>
        </trans-unit>
        <trans-unit id="112d712cbd3f4abfdabfc159cdc6a3584db95c15" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides three SQL commands to establish configuration defaults. The already-mentioned &lt;a href=&quot;sql-altersystem&quot;&gt;ALTER SYSTEM&lt;/a&gt; command provides a SQL-accessible means of changing global defaults; it is functionally equivalent to editing &lt;code&gt;postgresql.conf&lt;/code&gt;. In addition, there are two commands that allow setting of defaults on a per-database or per-role basis:</source>
          <target state="translated">PostgreSQL提供了三个SQL命令来建立默认配置。已经提到的&lt;a href=&quot;sql-altersystem&quot;&gt;ALTER SYSTEM&lt;/a&gt;命令提供了一种可通过SQL访问的方式来更改全局默认值。它在功能上等效于编辑 &lt;code&gt;postgresql.conf&lt;/code&gt; 。另外，有两个命令允许按数据库或角色设置默认值：</target>
        </trans-unit>
        <trans-unit id="d071c1667c54c5d765a697ea20deb60db45601b3" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides two data types that are designed to support full text search, which is the activity of searching through a collection of natural-language &lt;em&gt;documents&lt;/em&gt; to locate those that best match a &lt;em&gt;query&lt;/em&gt;. The &lt;code&gt;tsvector&lt;/code&gt; type represents a document in a form optimized for text search; the &lt;code&gt;tsquery&lt;/code&gt; type similarly represents a text query. &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt; provides a detailed explanation of this facility, and &lt;a href=&quot;functions-textsearch&quot;&gt;Section 9.13&lt;/a&gt; summarizes the related functions and operators.</source>
          <target state="translated">PostgreSQL提供了两种旨在支持全文本搜索的数据类型，即通过自然语言&lt;em&gt;文档&lt;/em&gt;集合进行搜索以找到与&lt;em&gt;查询&lt;/em&gt;最匹配的&lt;em&gt;文档&lt;/em&gt;的活动。所述 &lt;code&gt;tsvector&lt;/code&gt; 类型表示为文本搜索优化的形式的文件;在 &lt;code&gt;tsquery&lt;/code&gt; 类型同样表示文本查询。&lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;第12章&lt;/a&gt;详细介绍了此功能，&lt;a href=&quot;functions-textsearch&quot;&gt;第9.13节&lt;/a&gt;总结了相关功能和运算符。</target>
        </trans-unit>
        <trans-unit id="fc076effaac188434f505c3be6fa39f626918c7e" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides two data types that are designed to support full text search, which is the activity of searching through a collection of natural-language &lt;em&gt;documents&lt;/em&gt; to locate those that best match a &lt;em&gt;query&lt;/em&gt;. The &lt;code&gt;tsvector&lt;/code&gt; type represents a document in a form optimized for text search; the &lt;code&gt;tsquery&lt;/code&gt; type similarly represents a text query. &lt;a href=&quot;https://www.postgresql.org/docs/13/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt; provides a detailed explanation of this facility, and &lt;a href=&quot;functions-textsearch&quot;&gt;Section 9.13&lt;/a&gt; summarizes the related functions and operators.</source>
          <target state="translated">PostgreSQL提供了两种旨在支持全文本搜索的数据类型，即通过自然语言&lt;em&gt;文档&lt;/em&gt;集合进行搜索以找到与&lt;em&gt;查询&lt;/em&gt;最匹配的&lt;em&gt;文档&lt;/em&gt;的活动。所述 &lt;code&gt;tsvector&lt;/code&gt; 类型表示为文本搜索优化的形式的文件; 在 &lt;code&gt;tsquery&lt;/code&gt; 类型同样表示文本查询。&lt;a href=&quot;https://www.postgresql.org/docs/13/textsearch.html&quot;&gt;第12章&lt;/a&gt;详细介绍了此功能，&lt;a href=&quot;functions-textsearch&quot;&gt;第9.13节&lt;/a&gt;总结了相关的功能和运算符。</target>
        </trans-unit>
        <trans-unit id="8d5de0e98d735e8c10c90f072b5e772ac6f8ca44" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides two functions introduced in SQL:2006, but in variants that use the XPath 1.0 language, rather than XML Query as specified for them in the standard.</source>
          <target state="translated">PostgreSQL提供了两个在SQL:2006中引入的函数,但在变体中使用XPath 1.0语言,而不是标准中指定的XML Query。</target>
        </trans-unit>
        <trans-unit id="6e29f8f292e01eb034e6335e7938f34ec555db8f" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides various lock modes to control concurrent access to data in tables. These modes can be used for application-controlled locking in situations where MVCC does not give the desired behavior. Also, most PostgreSQL commands automatically acquire locks of appropriate modes to ensure that referenced tables are not dropped or modified in incompatible ways while the command executes. (For example, &lt;code&gt;TRUNCATE&lt;/code&gt; cannot safely be executed concurrently with other operations on the same table, so it obtains an exclusive lock on the table to enforce that.)</source>
          <target state="translated">PostgreSQL提供了各种锁定模式来控制对表中数据的并发访问。在MVCC无法提供所需行为的情况下，这些模式可用于应用程序控制的锁定。另外，大多数PostgreSQL命令会自动获取适当模式的锁，以确保在执行命令时不会以不兼容的方式删除或修改引用的表。 （例如， &lt;code&gt;TRUNCATE&lt;/code&gt; 无法安全地与同一表上的其他操作并发执行，因此它获得了表上的排他锁来强制执行该操作。）</target>
        </trans-unit>
        <trans-unit id="a2a834b0e992b83325c457a9496be0432049ea8a" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides various methods for authenticating users:</source>
          <target state="translated">PostgreSQL提供了多种验证用户的方法。</target>
        </trans-unit>
        <trans-unit id="aca67cd10f6b55fba07fefeab32464592e84bd50" translate="yes" xml:space="preserve">
          <source>PostgreSQL reads the system-wide OpenSSL configuration file. By default, this file is named &lt;code&gt;openssl.cnf&lt;/code&gt; and is located in the directory reported by &lt;code&gt;openssl version -d&lt;/code&gt;. This default can be overridden by setting environment variable &lt;code&gt;OPENSSL_CONF&lt;/code&gt; to the name of the desired configuration file.</source>
          <target state="translated">PostgreSQL读取系统范围的OpenSSL配置文件。默认情况下，此文件名为 &lt;code&gt;openssl.cnf&lt;/code&gt; ，位于 &lt;code&gt;openssl version -d&lt;/code&gt; 报告的目录中。通过将环境变量 &lt;code&gt;OPENSSL_CONF&lt;/code&gt; 设置为所需配置文件的名称，可以覆盖此默认值。</target>
        </trans-unit>
        <trans-unit id="0e141c534293f75601bff1fea667fc64a4f6c7d7" translate="yes" xml:space="preserve">
          <source>PostgreSQL recognizes functional dependency (allowing columns to be omitted from &lt;code&gt;GROUP BY&lt;/code&gt;) only when a table's primary key is included in the &lt;code&gt;GROUP BY&lt;/code&gt; list. The SQL standard specifies additional conditions that should be recognized.</source>
          <target state="translated">只有当表的主键包含在 &lt;code&gt;GROUP BY&lt;/code&gt; 列表中时，PostgreSQL才认识到功能依赖性（允许 &lt;code&gt;GROUP BY&lt;/code&gt; 省略列）。SQL标准指定了应识别的其他条件。</target>
        </trans-unit>
        <trans-unit id="d151da8167491478df86aef81ab6d8ffea35f9fb" translate="yes" xml:space="preserve">
          <source>PostgreSQL releases before 7.4 used a different binary file format.</source>
          <target state="translated">PostgreSQL在7.4之前的版本使用了不同的二进制文件格式。</target>
        </trans-unit>
        <trans-unit id="b128f368f0a60d65746b559a252c4dc977c1b44f" translate="yes" xml:space="preserve">
          <source>PostgreSQL releases prior to 8.1 would accept queries of this form, and add an implicit entry to the query's &lt;code&gt;FROM&lt;/code&gt; clause for each table referenced by the query. This is no longer allowed.</source>
          <target state="translated">PostgreSQL的8.1之前的版本将接受这种形式的查询，并为查询所引用的每个表在查询的 &lt;code&gt;FROM&lt;/code&gt; 子句中添加一个隐式条目。不再允许这样做。</target>
        </trans-unit>
        <trans-unit id="63fb6169ba8a1a0f974f4aea96b8b4aa6c3f1759" translate="yes" xml:space="preserve">
          <source>PostgreSQL requires a few bytes of System V shared memory (typically 48 bytes, on 64-bit platforms) for each copy of the server. On most modern operating systems, this amount can easily be allocated. However, if you are running many copies of the server or you explicitly configure the server to use large amounts of System V shared memory (see &lt;a href=&quot;runtime-config-resource#GUC-SHARED-MEMORY-TYPE&quot;&gt;shared_memory_type&lt;/a&gt; and &lt;a href=&quot;runtime-config-resource#GUC-DYNAMIC-SHARED-MEMORY-TYPE&quot;&gt;dynamic_shared_memory_type&lt;/a&gt;), it may be necessary to increase &lt;code&gt;SHMALL&lt;/code&gt;, which is the total amount of System V shared memory system-wide. Note that &lt;code&gt;SHMALL&lt;/code&gt; is measured in pages rather than bytes on many systems.</source>
          <target state="translated">PostgreSQL需要为服务器的每个副本提供几个字节的System V共享内存（在64位平台上通常为48个字节）。在大多数现代操作系统上，可以轻松分配此数量。但是，如果您正在运行服务器的许多副本，或者将服务器显式配置为使用大量的System V共享内存（请参阅&lt;a href=&quot;runtime-config-resource#GUC-SHARED-MEMORY-TYPE&quot;&gt;shared_memory_type&lt;/a&gt;和&lt;a href=&quot;runtime-config-resource#GUC-DYNAMIC-SHARED-MEMORY-TYPE&quot;&gt;dynamic_shared_memory_type&lt;/a&gt;），则可能有必要增加 &lt;code&gt;SHMALL&lt;/code&gt; ，它是System V共享的总量系统内存。请注意，在许多系统上， &lt;code&gt;SHMALL&lt;/code&gt; 是按页而不是字节进行度量的。</target>
        </trans-unit>
        <trans-unit id="c2c20c79653dcae8f8fc047710211c040521d5bc" translate="yes" xml:space="preserve">
          <source>PostgreSQL requires the operating system to provide inter-process communication (IPC) features, specifically shared memory and semaphores. Unix-derived systems typically provide &amp;ldquo;System V&amp;rdquo; IPC, &amp;ldquo;POSIX&amp;rdquo; IPC, or both. Windows has its own implementation of these features and is not discussed here.</source>
          <target state="translated">PostgreSQL要求操作系统提供进程间通信（IPC）功能，特别是共享内存和信号量。Unix派生的系统通常提供&amp;ldquo;系统V&amp;rdquo; IPC，&amp;ldquo; POSIX&amp;rdquo; IPC或两者。Windows具有自己的这些功能的实现，因此不在此讨论。</target>
        </trans-unit>
        <trans-unit id="36d337a94d7ba7a46b07377e19460ac78dd155d2" translate="yes" xml:space="preserve">
          <source>PostgreSQL streaming replication is asynchronous by default. If the primary server crashes then some transactions that were committed may not have been replicated to the standby server, causing data loss. The amount of data loss is proportional to the replication delay at the time of failover.</source>
          <target state="translated">PostgreSQL流式复制默认是异步的。如果主服务器崩溃,那么一些已经提交的事务可能没有复制到备用服务器上,造成数据丢失。数据丢失的数量与故障转移时的复制延迟成正比。</target>
        </trans-unit>
        <trans-unit id="7c42d1cce1b2b6028e2490c0570386d5f856bca2" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports a powerful &lt;em&gt;rule system&lt;/em&gt; for the specification of &lt;em&gt;views&lt;/em&gt; and ambiguous &lt;em&gt;view updates&lt;/em&gt;. Originally the PostgreSQL rule system consisted of two implementations:</source>
          <target state="translated">PostgreSQL支持强大的&lt;em&gt;规则系统&lt;/em&gt;来规范&lt;em&gt;视图&lt;/em&gt;和模糊的&lt;em&gt;视图更新&lt;/em&gt;。最初，PostgreSQL规则系统由两个实现组成：</target>
        </trans-unit>
        <trans-unit id="2241743d9fa8eb9bf19ded10e2bc6c68ceaf9df2" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports automatic character set conversion between server and client for certain character set combinations. The conversion information is stored in the &lt;code&gt;pg_conversion&lt;/code&gt; system catalog. PostgreSQL comes with some predefined conversions, as shown in &lt;a href=&quot;multibyte#MULTIBYTE-TRANSLATION-TABLE&quot;&gt;Table 23.2&lt;/a&gt;. You can create a new conversion using the SQL command &lt;code&gt;CREATE CONVERSION&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL支持服务器和客户端之间针对某些字符集组合的自动字符集转换。转换信息存储在 &lt;code&gt;pg_conversion&lt;/code&gt; 系统目录中。 PostgreSQL带有一些预定义的转换，如&lt;a href=&quot;multibyte#MULTIBYTE-TRANSLATION-TABLE&quot;&gt;表23.2&lt;/a&gt;所示。您可以使用SQL命令 &lt;code&gt;CREATE CONVERSION&lt;/code&gt; 创建新的转换。</target>
        </trans-unit>
        <trans-unit id="debb294ce8d55fb3d9baa6257891a19adad25190" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports automatic character set conversion between server and client for many combinations of character sets (&lt;a href=&quot;multibyte#MULTIBYTE-CONVERSIONS-SUPPORTED&quot;&gt;Section 23.3.4&lt;/a&gt; shows which ones).</source>
          <target state="translated">PostgreSQL支持在服务器和客户端之间进行字符集的许多组合的自动字符集转换（&lt;a href=&quot;multibyte#MULTIBYTE-CONVERSIONS-SUPPORTED&quot;&gt;第23.3.4节&lt;/a&gt;显示了哪些字符集）。</target>
        </trans-unit>
        <trans-unit id="a7c3b9018391e76aa16042a998f014061b76d5bb" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports basic table partitioning. This section describes why and how to implement partitioning as part of your database design.</source>
          <target state="translated">PostgreSQL支持基本的表分区。本节介绍了为什么以及如何在数据库设计中实现分区。</target>
        </trans-unit>
        <trans-unit id="1e97f638eb1274873aa3e4e622cb72d93b7b7f24" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports building indexes without locking out writes. This method is invoked by specifying the &lt;code&gt;CONCURRENTLY&lt;/code&gt; option of &lt;code&gt;CREATE INDEX&lt;/code&gt;. When this option is used, PostgreSQL must perform two scans of the table, and in addition it must wait for all existing transactions that could potentially modify or use the index to terminate. Thus this method requires more total work than a standard index build and takes significantly longer to complete. However, since it allows normal operations to continue while the index is built, this method is useful for adding new indexes in a production environment. Of course, the extra CPU and I/O load imposed by the index creation might slow other operations.</source>
          <target state="translated">PostgreSQL支持在不锁定写入的情况下建立索引。通过指定 &lt;code&gt;CREATE INDEX&lt;/code&gt; 的 &lt;code&gt;CONCURRENTLY&lt;/code&gt; 选项来调用此方法。使用此选项时，PostgreSQL必须对表进行两次扫描，此外，它必须等待所有可能修改或使用索引终止的现有事务。因此，与标准索引构建相比，此方法需要更多的总工作量，并且需要花费更长的时间才能完成。但是，由于它允许在建立索引时继续进行正常操作，因此该方法对于在生产环境中添加新索引很有用。当然，索引创建所带来的额外CPU和I / O负载可能会减慢其他操作的速度。</target>
        </trans-unit>
        <trans-unit id="bf603007c3689d71b489ed77c1b75a8fa44bed1c" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports parallel aggregation by aggregating in two stages. First, each process participating in the parallel portion of the query performs an aggregation step, producing a partial result for each group of which that process is aware. This is reflected in the plan as a &lt;code&gt;Partial Aggregate&lt;/code&gt; node. Second, the partial results are transferred to the leader via &lt;code&gt;Gather&lt;/code&gt; or &lt;code&gt;Gather Merge&lt;/code&gt;. Finally, the leader re-aggregates the results across all workers in order to produce the final result. This is reflected in the plan as a &lt;code&gt;Finalize Aggregate&lt;/code&gt; node.</source>
          <target state="translated">PostgreSQL通过两个阶段的聚合来支持并行聚合。首先，参与查询并行部分的每个进程执行一个聚合步骤，为该进程知道的每个组生成部分结果。这在计划中反映为&amp;ldquo; &lt;code&gt;Partial Aggregate&lt;/code&gt; 节点。其次，部分结果通过 &lt;code&gt;Gather&lt;/code&gt; 或 &lt;code&gt;Gather Merge&lt;/code&gt; 转移到领导者。最后，领导者重新汇总所有工作人员的结果，以产生最终结果。这在计划中反映为 &lt;code&gt;Finalize Aggregate&lt;/code&gt; 节点。</target>
        </trans-unit>
        <trans-unit id="98c96f2dead7b89b38c3c2461ff7cd5a4376ae6d" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports rebuilding indexes with minimum locking of writes. This method is invoked by specifying the &lt;code&gt;CONCURRENTLY&lt;/code&gt; option of &lt;code&gt;REINDEX&lt;/code&gt;. When this option is used, PostgreSQL must perform two scans of the table for each index that needs to be rebuilt and wait for termination of all existing transactions that could potentially use the index. This method requires more total work than a standard index rebuild and takes significantly longer to complete as it needs to wait for unfinished transactions that might modify the index. However, since it allows normal operations to continue while the index is being rebuilt, this method is useful for rebuilding indexes in a production environment. Of course, the extra CPU, memory and I/O load imposed by the index rebuild may slow down other operations.</source>
          <target state="translated">PostgreSQL支持以最小的写锁定来重建索引。通过指定 &lt;code&gt;REINDEX&lt;/code&gt; 的 &lt;code&gt;CONCURRENTLY&lt;/code&gt; 选项来调用此方法。使用此选项时，PostgreSQL必须对需要重建的每个索引执行两次表扫描，并等待终止所有可能使用该索引的现有事务。与标准索引重建相比，此方法需要更多的总工作量，并且由于需要等待可能会修改索引的未完成事务而需要更长的时间才能完成。但是，由于它允许重建索引时正常操作继续进行，因此该方法对于在生产环境中重建索引很有用。当然，索引重建带来的额外CPU，内存和I / O负载可能会减慢其他操作的速度。</target>
        </trans-unit>
        <trans-unit id="b659630282ce6fbd7aba80155fab2795874d42d4" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports row-level access, but &lt;code&gt;sepgsql&lt;/code&gt; does not.</source>
          <target state="translated">PostgreSQL支持行级访问，但 &lt;code&gt;sepgsql&lt;/code&gt; 不支持。</target>
        </trans-unit>
        <trans-unit id="ef19df889c26aff47b13a779090fcd37550d60bb" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports several methods for logging server messages, including stderr, csvlog and syslog. On Windows, eventlog is also supported. Set this parameter to a list of desired log destinations separated by commas. The default is to log to stderr only. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">PostgreSQL支持几种记录服务器消息的方法，包括stderr，csvlog和syslog。在Windows上，也支持eventlog。将此参数设置为所需的日志目标列表，以逗号分隔。默认为仅登录到stderr。该参数只能在 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件或服务器命令行中设置。</target>
        </trans-unit>
        <trans-unit id="51899fa8eebb3b3aa74bb4a137479eee2fd66147" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports several special date/time input values for convenience, as shown in &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-SPECIAL-TABLE&quot;&gt;Table 8.13&lt;/a&gt;. The values &lt;code&gt;infinity&lt;/code&gt; and &lt;code&gt;-infinity&lt;/code&gt; are specially represented inside the system and will be displayed unchanged; but the others are simply notational shorthands that will be converted to ordinary date/time values when read. (In particular, &lt;code&gt;now&lt;/code&gt; and related strings are converted to a specific time value as soon as they are read.) All of these values need to be enclosed in single quotes when used as constants in SQL commands.</source>
          <target state="translated">为了方便起见，PostgreSQL支持几个特殊的日期/时间输入值，如&lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-SPECIAL-TABLE&quot;&gt;表8.13&lt;/a&gt;所示。值 &lt;code&gt;infinity&lt;/code&gt; 和 &lt;code&gt;-infinity&lt;/code&gt; 在系统内部专门表示，将保持不变。但其他仅仅是符号速记，将在读取时转换为普通的日期/时间值。 （尤其是， &lt;code&gt;now&lt;/code&gt; 和相关的字符串在读取后立即转换为特定的时间值。）当在SQL命令中用作常量时，所有这些值都必须用单引号引起来。</target>
        </trans-unit>
        <trans-unit id="f6c41dd3d36631eef9a60ad49bfd703137d3f4d8" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports the full set of SQL date and time types, shown in &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-TABLE&quot;&gt;Table 8.9&lt;/a&gt;. The operations available on these data types are described in &lt;a href=&quot;functions-datetime&quot;&gt;Section 9.9&lt;/a&gt;. Dates are counted according to the Gregorian calendar, even in years before that calendar was introduced (see &lt;a href=&quot;datetime-units-history&quot;&gt;Section B.5&lt;/a&gt; for more information).</source>
          <target state="translated">PostgreSQL支持完整的SQL日期和时间类型，如&lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-TABLE&quot;&gt;表8.9&lt;/a&gt;所示。这些数据类型上可用的操作在&lt;a href=&quot;functions-datetime&quot;&gt;9.9节&lt;/a&gt;中描述。日期是根据公历计算的，即使在采用该日历的年份也是如此（有关更多信息，请参见&lt;a href=&quot;datetime-units-history&quot;&gt;B.5节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="20349ba6e468e9df9a098ab6e794e103ce905a08" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports the full set of SQL date and time types, shown in &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-TABLE&quot;&gt;Table 8.9&lt;/a&gt;. The operations available on these data types are described in &lt;a href=&quot;functions-datetime&quot;&gt;Section 9.9&lt;/a&gt;. Dates are counted according to the Gregorian calendar, even in years before that calendar was introduced (see &lt;a href=&quot;datetime-units-history&quot;&gt;Section B.6&lt;/a&gt; for more information).</source>
          <target state="translated">PostgreSQL支持完整的SQL日期和时间类型，如&lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-TABLE&quot;&gt;表8.9&lt;/a&gt;所示。这些数据类型上可用的操作在&lt;a href=&quot;functions-datetime&quot;&gt;9.9节&lt;/a&gt;中描述。日期是根据公历计算的，即使是在采用该日历之前的年份也是如此（有关更多信息，请参见&lt;a href=&quot;datetime-units-history&quot;&gt;B.6节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="f14a3d6cb75702f32d5dc071e65c1dc41ad01772" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports the standard SQL types &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;smallint&lt;/code&gt;, &lt;code&gt;real&lt;/code&gt;, &lt;code&gt;double precision&lt;/code&gt;, &lt;code&gt;char(N)&lt;/code&gt;, &lt;code&gt;varchar(N)&lt;/code&gt;, &lt;code&gt;date&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;timestamp&lt;/code&gt;, and &lt;code&gt;interval&lt;/code&gt;, as well as other types of general utility and a rich set of geometric types. PostgreSQL can be customized with an arbitrary number of user-defined data types. Consequently, type names are not key words in the syntax, except where required to support special cases in the SQL standard.</source>
          <target state="translated">PostgreSQL支持标准SQL类型 &lt;code&gt;int&lt;/code&gt; ， &lt;code&gt;smallint&lt;/code&gt; ， &lt;code&gt;real&lt;/code&gt; ， &lt;code&gt;double precision&lt;/code&gt; ， &lt;code&gt;char(N)&lt;/code&gt; ， &lt;code&gt;varchar(N)&lt;/code&gt; ， &lt;code&gt;date&lt;/code&gt; ， &lt;code&gt;time&lt;/code&gt; ， &lt;code&gt;timestamp&lt;/code&gt; 和 &lt;code&gt;interval&lt;/code&gt; ，以及其他类型的常规实用程序和一组丰富的几何类型。可以使用任意数量的用户定义数据类型来自定义PostgreSQL。因此，类型名称不是语法中的关键字，除非需要在SQL标准中支持特殊情况。</target>
        </trans-unit>
        <trans-unit id="0d51b565fec4c2b0e44f5a1d45ac9c129a9f5580" translate="yes" xml:space="preserve">
          <source>PostgreSQL treats the settings &lt;code&gt;origin&lt;/code&gt; and &lt;code&gt;local&lt;/code&gt; the same internally. Third-party replication systems may use these two values for their internal purposes, for example using &lt;code&gt;local&lt;/code&gt; to designate a session whose changes should not be replicated.</source>
          <target state="translated">PostgreSQL在内部将设置 &lt;code&gt;origin&lt;/code&gt; 和 &lt;code&gt;local&lt;/code&gt; 设置相同。第三方复制系统可能会将这两个值用于内部目的，例如使用 &lt;code&gt;local&lt;/code&gt; 来指定不应复制其更改的会话。</target>
        </trans-unit>
        <trans-unit id="749a4f6a11ea83f98676b6594e8c9efc963bc390" translate="yes" xml:space="preserve">
          <source>PostgreSQL type</source>
          <target state="translated">PostgreSQL类型</target>
        </trans-unit>
        <trans-unit id="47a27d79e52ae2c7462f626790ad2829a449a676" translate="yes" xml:space="preserve">
          <source>PostgreSQL uses a fixed page size (commonly 8 kB), and does not allow tuples to span multiple pages. Therefore, it is not possible to store very large field values directly. To overcome this limitation, large field values are compressed and/or broken up into multiple physical rows. This happens transparently to the user, with only small impact on most of the backend code. The technique is affectionately known as TOAST (or &amp;ldquo;the best thing since sliced bread&amp;rdquo;). The TOAST infrastructure is also used to improve handling of large data values in-memory.</source>
          <target state="translated">PostgreSQL使用固定的页面大小（通常为8 kB），并且不允许元组跨越多个页面。因此，不可能直接存储非常大的字段值。为了克服此限制，将大字段值压缩和/或分解为多个物理行。这对用户是透明的，对大多数后端代码影响很小。该技术被亲切地称为TOAST（或&amp;ldquo;自切片面包以来最好的东西&amp;rdquo;）。TOAST基础结构还用于改善内存中大数据值的处理。</target>
        </trans-unit>
        <trans-unit id="e1529abe3421ea489100f9759672bf8f68aa03a3" translate="yes" xml:space="preserve">
          <source>PostgreSQL version information. See also &lt;a href=&quot;runtime-config-preset#GUC-SERVER-VERSION-NUM&quot;&gt;server_version_num&lt;/a&gt; for a machine-readable version.</source>
          <target state="translated">PostgreSQL版本信息。另请参阅&lt;a href=&quot;runtime-config-preset#GUC-SERVER-VERSION-NUM&quot;&gt;server_version_num&lt;/a&gt;以获取机器可读的版本。</target>
        </trans-unit>
        <trans-unit id="79b79e94e250861d3a37b2b81991c08edde567f2" translate="yes" xml:space="preserve">
          <source>PostgreSQL versions before 9.5 used slightly different operator precedence rules. In particular, &lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt; and &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; used to be treated as generic operators; &lt;code&gt;IS&lt;/code&gt; tests used to have higher priority; and &lt;code&gt;NOT BETWEEN&lt;/code&gt; and related constructs acted inconsistently, being taken in some cases as having the precedence of &lt;code&gt;NOT&lt;/code&gt; rather than &lt;code&gt;BETWEEN&lt;/code&gt;. These rules were changed for better compliance with the SQL standard and to reduce confusion from inconsistent treatment of logically equivalent constructs. In most cases, these changes will result in no behavioral change, or perhaps in &amp;ldquo;no such operator&amp;rdquo; failures which can be resolved by adding parentheses. However there are corner cases in which a query might change behavior without any parsing error being reported. If you are concerned about whether these changes have silently broken something, you can test your application with the configuration parameter &lt;a href=&quot;runtime-config-compatible#GUC-OPERATOR-PRECEDENCE-WARNING&quot;&gt;operator_precedence_warning&lt;/a&gt; turned on to see if any warnings are logged.</source>
          <target state="translated">9.5之前的PostgreSQL版本使用略有不同的运算符优先级规则。特别是， &lt;code&gt;&amp;lt;=&lt;/code&gt; &lt;code&gt;&amp;gt;=&lt;/code&gt; 和 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 过去被视为通用运算符；过去， &lt;code&gt;IS&lt;/code&gt; 测试具有更高的优先级；和 &lt;code&gt;NOT BETWEEN&lt;/code&gt; 及其相关构造的行为不一致，在某些情况下被认为具有 &lt;code&gt;NOT&lt;/code&gt; 而不是 &lt;code&gt;BETWEEN&lt;/code&gt; 的优先权。更改这些规则是为了更好地符合SQL标准，并减少对逻辑等效结构的不一致处理所造成的混淆。在大多数情况下，这些更改不会导致任何行为更改，或者可能导致&amp;ldquo;没有此类操作员&amp;rdquo;失败，可以通过添加括号来解决。但是，在某些极端情况下，查询可能会更改行为而没有报告任何解析错误。如果您担心这些更改是否在默默地破坏了某些内容，则可以在打开配置参数&lt;a href=&quot;runtime-config-compatible#GUC-OPERATOR-PRECEDENCE-WARNING&quot;&gt;operator_precedence_warning的情况下&lt;/a&gt;测试您的应用程序，以查看是否记录了任何警告。</target>
        </trans-unit>
        <trans-unit id="b12aba1a6149cc1a1cc6de75b2d9db3d7327f976" translate="yes" xml:space="preserve">
          <source>PostgreSQL versions before 9.6 did not provide any guarantees about the timing of evaluation of output expressions versus sorting and limiting; it depended on the form of the chosen query plan.</source>
          <target state="translated">PostgreSQL在9.6之前的版本没有提供任何关于输出表达式的评估时间与排序和限制的保证,它取决于所选查询计划的形式。</target>
        </trans-unit>
        <trans-unit id="a330d6e333f0e705b7dbdae815c080baf029fd11" translate="yes" xml:space="preserve">
          <source>PostgreSQL will accept &lt;code&gt;BY VALUE&lt;/code&gt; or &lt;code&gt;BY REF&lt;/code&gt; in an &lt;code&gt;XMLEXISTS&lt;/code&gt; or &lt;code&gt;XMLTABLE&lt;/code&gt; construct, but it ignores them. The &lt;code&gt;xml&lt;/code&gt; data type holds a character-string serialized representation, so there is no node identity to preserve, and passing is always effectively &lt;code&gt;BY VALUE&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL将在 &lt;code&gt;XMLEXISTS&lt;/code&gt; 或 &lt;code&gt;XMLTABLE&lt;/code&gt; 构造中接受 &lt;code&gt;BY VALUE&lt;/code&gt; 或 &lt;code&gt;BY REF&lt;/code&gt; ，但它将忽略它们。该 &lt;code&gt;xml&lt;/code&gt; 数据类型保存字符串序列化表示形式，所以没有节点身份保留，和传球总是有效地 &lt;code&gt;BY VALUE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="46668d602303093fd5436b07b8510921686fe19b" translate="yes" xml:space="preserve">
          <source>PostgreSQL will allow superusers to create databases with &lt;code&gt;SQL_ASCII&lt;/code&gt; encoding even when &lt;code&gt;LC_CTYPE&lt;/code&gt; is not &lt;code&gt;C&lt;/code&gt; or &lt;code&gt;POSIX&lt;/code&gt;. As noted above, &lt;code&gt;SQL_ASCII&lt;/code&gt; does not enforce that the data stored in the database has any particular encoding, and so this choice poses risks of locale-dependent misbehavior. Using this combination of settings is deprecated and may someday be forbidden altogether.</source>
          <target state="translated">PostgreSQL将允许超级用户使用 &lt;code&gt;SQL_ASCII&lt;/code&gt; 编码创建数据库，即使 &lt;code&gt;LC_CTYPE&lt;/code&gt; 不是 &lt;code&gt;C&lt;/code&gt; 或 &lt;code&gt;POSIX&lt;/code&gt; 也不例外。如上所述， &lt;code&gt;SQL_ASCII&lt;/code&gt; 并不强制数据库中存储的数据具有任何特定的编码，因此此选择带来了依赖于语言环境的行为异常的风险。不建议使用这种设置组合，有一天可能会完全禁止使用。</target>
        </trans-unit>
        <trans-unit id="b4c3b94e027418ea1293e7cfc1afc35261ba39ee" translate="yes" xml:space="preserve">
          <source>PostgreSQL will apply this expansion behavior to any composite-valued expression, although as shown &lt;a href=&quot;rowtypes#ROWTYPES-ACCESSING&quot;&gt;above&lt;/a&gt;, you need to write parentheses around the value that &lt;code&gt;.*&lt;/code&gt; is applied to whenever it's not a simple table name. For example, if &lt;code&gt;myfunc()&lt;/code&gt; is a function returning a composite type with columns &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;, then these two queries have the same result:</source>
          <target state="translated">PostgreSQL将应用这种扩张行为，任何复合值表达式，虽然如图所示&lt;a href=&quot;rowtypes#ROWTYPES-ACCESSING&quot;&gt;上面&lt;/a&gt;，你需要写周围的值括号 &lt;code&gt;.*&lt;/code&gt; 适用于每当它不是一个简单的表名。例如，如果 &lt;code&gt;myfunc()&lt;/code&gt; 是一个返回具有 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 列的复合类型的函数，则这两个查询的结果相同：</target>
        </trans-unit>
        <trans-unit id="c89f6a3f1560a7bd4653723f3e72dbf1311168a6" translate="yes" xml:space="preserve">
          <source>PostgreSQL will attempt to convert the column's default value (if any) to the new type, as well as any constraints that involve the column. But these conversions might fail, or might produce surprising results. It's often best to drop any constraints on the column before altering its type, and then add back suitably modified constraints afterwards.</source>
          <target state="translated">PostgreSQL会尝试将列的默认值(如果有的话)转换为新的类型,以及涉及该列的任何约束。但是这些转换可能会失败,或者可能产生令人惊讶的结果。通常最好的办法是在改变列的类型之前,先放弃列上的任何约束,然后再将适当修改后的约束添加回来。</target>
        </trans-unit>
        <trans-unit id="23adfa969a97323ee3ec177a7dcb8f6884bb3a0c" translate="yes" xml:space="preserve">
          <source>PostgreSQL's &lt;a href=&quot;mvcc-intro&quot;&gt;MVCC&lt;/a&gt; transaction semantics depend on being able to compare transaction ID (XID) numbers: a row version with an insertion XID greater than the current transaction's XID is &amp;ldquo;in the future&amp;rdquo; and should not be visible to the current transaction. But since transaction IDs have limited size (32 bits) a cluster that runs for a long time (more than 4 billion transactions) would suffer &lt;em&gt;transaction ID wraparound&lt;/em&gt;: the XID counter wraps around to zero, and all of a sudden transactions that were in the past appear to be in the future &amp;mdash; which means their output become invisible. In short, catastrophic data loss. (Actually the data is still there, but that's cold comfort if you cannot get at it.) To avoid this, it is necessary to vacuum every table in every database at least once every two billion transactions.</source>
          <target state="translated">PostgreSQL的&lt;a href=&quot;mvcc-intro&quot;&gt;MVCC&lt;/a&gt;事务语义取决于能否比较事务ID（XID）号：插入XID大于当前事务XID的行版本是&amp;ldquo;将来的&amp;rdquo;，并且对当前事务不可见。但是，由于事务ID的大小有限（32位），因此长时间运行（超过40亿个事务）的集群将遭受&lt;em&gt;事务ID环绕&lt;/em&gt;：XID计数器回零，并且过去突然出现的所有事务似乎都在将来-这意味着它们的输出变得不可见。简而言之，灾难性的数据丢失。（实际上，数据仍然存在，但是如果您不能获得它，那真是令人感到安慰。）为避免这种情况，有必要对每个数据库中的每个表进行至少20亿次事务清理。</target>
        </trans-unit>
        <trans-unit id="d01ad7a96af1c4c37b0765a65b29de55d59ec177" translate="yes" xml:space="preserve">
          <source>PostgreSQL's &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt; command has to process each table on a regular basis for several reasons:</source>
          <target state="translated">PostgreSQL的&lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt;命令必须定期处理每个表，这有几个原因：</target>
        </trans-unit>
        <trans-unit id="1d397eedb2e425cb61e6640819576e2ece268547" translate="yes" xml:space="preserve">
          <source>PostgreSQL's &lt;em&gt;statistics collector&lt;/em&gt; is a subsystem that supports collection and reporting of information about server activity. Presently, the collector can count accesses to tables and indexes in both disk-block and individual-row terms. It also tracks the total number of rows in each table, and information about vacuum and analyze actions for each table. It can also count calls to user-defined functions and the total time spent in each one.</source>
          <target state="translated">PostgreSQL的&lt;em&gt;统计信息收集器&lt;/em&gt;是一个子系统，支持收集和报告有关服务器活动的信息。当前，收集器可以以磁盘块和单个行的方式计算对表和索引的访问。它还跟踪每个表中的总行数，以及有关每个表的清理和分析操作的信息。它还可以计算对用户定义函数的调用以及每个函数所花费的总时间。</target>
        </trans-unit>
        <trans-unit id="fa34938a4c0bdb7ddaed6ea9437aad3e7e7c20a7" translate="yes" xml:space="preserve">
          <source>PostgreSQL's JIT implementation can inline the bodies of functions of types &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;internal&lt;/code&gt;, as well as operators based on such functions. To do so for functions in extensions, the definitions of those functions need to be made available. When using &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-pgxs.html&quot;&gt;PGXS&lt;/a&gt; to build an extension against a server that has been compiled with LLVM JIT support, the relevant files will be built and installed automatically.</source>
          <target state="translated">PostgreSQL的JIT实现可以内联 &lt;code&gt;C&lt;/code&gt; 型和 &lt;code&gt;internal&lt;/code&gt; 类型的函数体，以及基于此类函数的运算符。为此，对于扩展中的功能，需要使这些功能的定义可用。当使用&lt;a href=&quot;https://www.postgresql.org/docs/12/extend-pgxs.html&quot;&gt;PGXS&lt;/a&gt;针对已使用LLVM JIT支持编译的服务器构建扩展时，将自动构建并安装相关文件。</target>
        </trans-unit>
        <trans-unit id="cbfface12059fe15d4ea1c0663b32afd132d460b" translate="yes" xml:space="preserve">
          <source>PostgreSQL's JIT implementation can inline the bodies of functions of types &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;internal&lt;/code&gt;, as well as operators based on such functions. To do so for functions in extensions, the definitions of those functions need to be made available. When using &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-pgxs.html&quot;&gt;PGXS&lt;/a&gt; to build an extension against a server that has been compiled with LLVM JIT support, the relevant files will be built and installed automatically.</source>
          <target state="translated">PostgreSQL的JIT实现可以内联 &lt;code&gt;C&lt;/code&gt; 类型和 &lt;code&gt;internal&lt;/code&gt; 类型的函数体，以及基于此类函数的运算符。为此，对于扩展中的功能，需要使这些功能的定义可用。当使用&lt;a href=&quot;https://www.postgresql.org/docs/13/extend-pgxs.html&quot;&gt;PGXS&lt;/a&gt;针对已使用LLVM JIT支持编译的服务器构建扩展时，将自动构建并安装相关文件。</target>
        </trans-unit>
        <trans-unit id="b2ce9be22eb538937b290524f1a893fff9a3a342" translate="yes" xml:space="preserve">
          <source>PostgreSQL's foreign-data functionality is still under active development. Optimization of queries is primitive (and mostly left to the wrapper, too). Thus, there is considerable room for future performance improvements.</source>
          <target state="translated">PostgreSQL的外数据功能仍在积极开发中。对查询的优化还很原始(而且大部分也是由包装器来完成)。因此,未来的性能还有很大的改进空间。</target>
        </trans-unit>
        <trans-unit id="045ba636eac8c350bd9d92d07f5b544b6d689ef6" translate="yes" xml:space="preserve">
          <source>PostgreSQL's implementation of SQL/JSON path language has the following deviations from the SQL/JSON standard:</source>
          <target state="translated">PostgreSQL实现的SQL/JSON路径语言与SQL/JSON标准有以下偏差。</target>
        </trans-unit>
        <trans-unit id="49d790f2e543677fa7af238d2ad2b0bee3041d87" translate="yes" xml:space="preserve">
          <source>PostgreSQL's implementation of the SQL/JSON path language has the following deviations from the SQL/JSON standard:</source>
          <target state="translated">PostgreSQL实现的SQL/JSON路径语言与SQL/JSON标准有以下偏差。</target>
        </trans-unit>
        <trans-unit id="b6512655ce0206ad2e55af59128437c19a85eef8" translate="yes" xml:space="preserve">
          <source>PostgreSQL's regular expressions are implemented using a software package written by Henry Spencer. Much of the description of regular expressions below is copied verbatim from his manual.</source>
          <target state="translated">PostgreSQL的正则表达式是用Henry Spencer编写的软件包实现的。下面对正则表达式的描述大部分是从他的手册中逐字逐句复制的。</target>
        </trans-unit>
        <trans-unit id="8b89dce84ea21263b16697e60b4c1b4c85d27493" translate="yes" xml:space="preserve">
          <source>PostgreSQL's text search features are described at length in &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;第12章&lt;/a&gt;将详细介绍PostgreSQL的文本搜索功能。</target>
        </trans-unit>
        <trans-unit id="e1d7207a8f75323c89ab9632a9dcc5793d725c97" translate="yes" xml:space="preserve">
          <source>PostgreSQL's text search features are described at length in &lt;a href=&quot;https://www.postgresql.org/docs/13/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/13/textsearch.html&quot;&gt;第12章&lt;/a&gt;详细介绍了PostgreSQL的文本搜索功能。</target>
        </trans-unit>
        <trans-unit id="39f6a42a4fb0039de8b2fce0531aa5cf8bf17009" translate="yes" xml:space="preserve">
          <source>PostgreSQL-style typecast</source>
          <target state="translated">PostgreSQL风格的类型转换</target>
        </trans-unit>
        <trans-unit id="ee3a796a1951d3ab475d28807f6598608b0104af" translate="yes" xml:space="preserve">
          <source>Postmaster (process)</source>
          <target state="translated">邮局局长(流程)</target>
        </trans-unit>
        <trans-unit id="19b427c5cf5eb995bfcd7725e3fbf7217d1adcbd" translate="yes" xml:space="preserve">
          <source>Poul-Henning Kamp</source>
          <target state="translated">Poul-Henning营地</target>
        </trans-unit>
        <trans-unit id="17ae45bd355f880cc7401f24ea563dca0df2e7d4" translate="yes" xml:space="preserve">
          <source>Pre-loaded catalog rows must have preassigned OIDs if there are OID references to them in other pre-loaded rows. A preassigned OID is also needed if the row's OID must be referenced from C code. If neither case applies, the &lt;code&gt;oid&lt;/code&gt; metadata field can be omitted, in which case the bootstrap code assigns an OID automatically. In practice we usually preassign OIDs for all or none of the pre-loaded rows in a given catalog, even if only some of them are actually cross-referenced.</source>
          <target state="translated">如果在其他预加载的行中有对它们的OID引用，则预加载的目录行必须具有预分配的OID。如果必须从C代码中引用行的OID，则还需要预分配的OID。如果两种情况都不适用，则可以省略 &lt;code&gt;oid&lt;/code&gt; 元数据字段，在这种情况下，引导程序代码会自动分配OID。实际上，我们通常为给定目录中的所有预加载行或不为所有预加载行预分配OID，即使实际上只有部分交叉引用也是如此。</target>
        </trans-unit>
        <trans-unit id="3509ce167d8714af0e6b496635d49ac549f353e8" translate="yes" xml:space="preserve">
          <source>Pre-packaged versions of PostgreSQL will typically create a suitable user account automatically during package installation.</source>
          <target state="translated">预先打包的PostgreSQL版本通常会在软件包安装过程中自动创建一个合适的用户账户。</target>
        </trans-unit>
        <trans-unit id="9eee28bfd739e1debf4d3b892d013537ae16da9f" translate="yes" xml:space="preserve">
          <source>Predicate</source>
          <target state="translated">Predicate</target>
        </trans-unit>
        <trans-unit id="24fe09a1cf90d17df4307cd57797792c845342fc" translate="yes" xml:space="preserve">
          <source>Predicate locks in PostgreSQL, like in most other database systems, are based on data actually accessed by a transaction. These will show up in the &lt;a href=&quot;view-pg-locks&quot;&gt;&lt;code&gt;pg_locks&lt;/code&gt;&lt;/a&gt; system view with a &lt;code&gt;mode&lt;/code&gt; of &lt;code&gt;SIReadLock&lt;/code&gt;. The particular locks acquired during execution of a query will depend on the plan used by the query, and multiple finer-grained locks (e.g., tuple locks) may be combined into fewer coarser-grained locks (e.g., page locks) during the course of the transaction to prevent exhaustion of the memory used to track the locks. A &lt;code&gt;READ ONLY&lt;/code&gt; transaction may be able to release its SIRead locks before completion, if it detects that no conflicts can still occur which could lead to a serialization anomaly. In fact, &lt;code&gt;READ ONLY&lt;/code&gt; transactions will often be able to establish that fact at startup and avoid taking any predicate locks. If you explicitly request a &lt;code&gt;SERIALIZABLE READ ONLY DEFERRABLE&lt;/code&gt; transaction, it will block until it can establish this fact. (This is the &lt;em&gt;only&lt;/em&gt; case where Serializable transactions block but Repeatable Read transactions don't.) On the other hand, SIRead locks often need to be kept past transaction commit, until overlapping read write transactions complete.</source>
          <target state="translated">像大多数其他数据库系统一样，PostgreSQL中的谓词锁基于事务实际访问的数据。这些将在显示&lt;a href=&quot;view-pg-locks&quot;&gt; &lt;code&gt;pg_locks&lt;/code&gt; 对&lt;/a&gt;具有系统视图 &lt;code&gt;mode&lt;/code&gt; 的 &lt;code&gt;SIReadLock&lt;/code&gt; 。在查询执行期间获取的特定锁将取决于查询所使用的计划，并且在执行过程中，多个更细粒度的锁（例如，tuple锁）可以组合为更少的较粗粒度的锁（例如，页面锁）。该事务可防止用于跟踪锁的内存耗尽。如果 &lt;code&gt;READ ONLY&lt;/code&gt; 事务检测到仍然没有发生可能导致序列化异常的冲突，则它可以在完成之前释放其SIRead锁。实际上， &lt;code&gt;READ ONLY&lt;/code&gt; 事务通常将能够在启动时建立该事实，并避免采取任何谓词锁定。如果您显式请求 &lt;code&gt;SERIALIZABLE READ ONLY DEFERRABLE&lt;/code&gt; 事务，它将阻塞直到可以建立此事实。 （这是&lt;em&gt;唯一的可&lt;/em&gt;序列化事务阻塞但不重复可重复事务阻塞的情况。）另一方面，SIRead锁通常需要保留到事务提交之后，直到完成重叠的读写事务为止。</target>
        </trans-unit>
        <trans-unit id="8515d3fdb655d3e82744bca30feb482862c14535" translate="yes" xml:space="preserve">
          <source>Predicate/Value</source>
          <target state="translated">Predicate/Value</target>
        </trans-unit>
        <trans-unit id="7a2a4f6fed53f092f075c647902092f49dff565c" translate="yes" xml:space="preserve">
          <source>Prepare all statements before using them. Libecpg will keep a cache of prepared statements and reuse a statement if it gets executed again. If the cache runs full, libecpg will free the least used statement.</source>
          <target state="translated">在使用所有语句之前,先准备好它们。Libecpg 会保留一个已准备好的语句的缓存,并在语句再次被执行时重新使用它。如果缓存满了,libecpg会释放使用最少的语句。</target>
        </trans-unit>
        <trans-unit id="805b0426cd8c493c6395add1e59cb6d57cc782f6" translate="yes" xml:space="preserve">
          <source>Prepare for an index scan. The &lt;code&gt;nkeys&lt;/code&gt; and &lt;code&gt;norderbys&lt;/code&gt; parameters indicate the number of quals and ordering operators that will be used in the scan; these may be useful for space allocation purposes. Note that the actual values of the scan keys aren't provided yet. The result must be a palloc'd struct. For implementation reasons the index access method &lt;em&gt;must&lt;/em&gt; create this struct by calling &lt;code&gt;RelationGetIndexScan()&lt;/code&gt;. In most cases &lt;code&gt;ambeginscan&lt;/code&gt; does little beyond making that call and perhaps acquiring locks; the interesting parts of index-scan startup are in &lt;code&gt;amrescan&lt;/code&gt;.</source>
          <target state="translated">准备索引扫描。的 &lt;code&gt;nkeys&lt;/code&gt; 和 &lt;code&gt;norderbys&lt;/code&gt; 参数指示quals和将在扫描中使用排序操作符的数量; 这些对于空间分配可能有用。请注意，尚未提供扫描键的实际值。结果必须是一个palloc结构。出于实现原因，索引访问方法&lt;em&gt;必须&lt;/em&gt;通过调用 &lt;code&gt;RelationGetIndexScan()&lt;/code&gt; 创建此结构。在大多数情况下， &lt;code&gt;ambeginscan&lt;/code&gt; 所做的仅是拨打该电话和获得锁。索引扫描启动的有趣部分在 &lt;code&gt;amrescan&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="1badb6123149d2dd80187b1001e17317e0376a45" translate="yes" xml:space="preserve">
          <source>Prepare for performing on-line backup (restricted to superusers by default, but other users can be granted EXECUTE to run the function)</source>
          <target state="translated">为执行在线备份做准备(默认情况下仅限于超级用户,但其他用户可以被授予EXECUTE来运行该功能</target>
        </trans-unit>
        <trans-unit id="ea6420d9e6ea0b317eaaff702554d4ab07b95961" translate="yes" xml:space="preserve">
          <source>Prepare the current transaction for two-phase commit, using &lt;code&gt;foobar&lt;/code&gt; as the transaction identifier:</source>
          <target state="translated">使用 &lt;code&gt;foobar&lt;/code&gt; 作为事务标识符，为两阶段提交准备当前事务：</target>
        </trans-unit>
        <trans-unit id="5eccdbb667192934bc79ff3dadac066bfd3213f5" translate="yes" xml:space="preserve">
          <source>Prepared statements (either explicitly prepared or implicitly generated, for example by PL/pgSQL) can be executed using custom or generic plans. Custom plans are made afresh for each execution using its specific set of parameter values, while generic plans do not rely on the parameter values and can be re-used across executions. Thus, use of a generic plan saves planning time, but if the ideal plan depends strongly on the parameter values then a generic plan may be inefficient. The choice between these options is normally made automatically, but it can be overridden with &lt;code&gt;plan_cache_mode&lt;/code&gt;. The allowed values are &lt;code&gt;auto&lt;/code&gt; (the default), &lt;code&gt;force_custom_plan&lt;/code&gt; and &lt;code&gt;force_generic_plan&lt;/code&gt;. This setting is considered when a cached plan is to be executed, not when it is prepared. For more information see &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt;.</source>
          <target state="translated">可以使用自定义计划或通用计划来执行准备好的语句（例如通过PL / pgSQL显式准备或隐式生成）。使用特定的参数值集合为每个执行重新创建自定义计划，而通用计划不依赖于参数值，并且可以在各个执行之间重复使用。因此，使用通用计划可以节省计划时间，但是如果理想计划在很大程度上取决于参数值，那么通用计划可能会效率低下。这些选项之间的选择通常是自动进行的，但是可以用 &lt;code&gt;plan_cache_mode&lt;/code&gt; 覆盖。允许的值为 &lt;code&gt;auto&lt;/code&gt; （默认值）， &lt;code&gt;force_custom_plan&lt;/code&gt; 和 &lt;code&gt;force_generic_plan&lt;/code&gt; 。在执行缓存计划时（而不是在准备计划时）会考虑此设置。有关更多信息，请参见&lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5d2d9ca4ec55b877233447dcb48943c2ef02e7aa" translate="yes" xml:space="preserve">
          <source>Prepared statements can take parameters: values that are substituted into the statement when it is executed. When creating the prepared statement, refer to parameters by position, using &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, etc. A corresponding list of parameter data types can optionally be specified. When a parameter's data type is not specified or is declared as &lt;code&gt;unknown&lt;/code&gt;, the type is inferred from the context in which the parameter is first referenced (if possible). When executing the statement, specify the actual values for these parameters in the &lt;code&gt;EXECUTE&lt;/code&gt; statement. Refer to &lt;a href=&quot;sql-execute&quot;&gt;EXECUTE&lt;/a&gt; for more information about that.</source>
          <target state="translated">准备好的语句可以带有参数：执行语句时将替换为语句的值。创建准备好的语句时，请使用 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; 等按位置引用参数。可以选择指定相应的参数数据类型列表。如果未指定参数的数据类型或将其声明为 &lt;code&gt;unknown&lt;/code&gt; ，则从首次引用该参数的上下文（如果可能）中推断出该类型。执行该语句时，请在 &lt;code&gt;EXECUTE&lt;/code&gt; 语句中指定这些参数的实际值。有关更多信息，请参考&lt;a href=&quot;sql-execute&quot;&gt;EXECUTE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="23037ec79dcb923a75cebd6186549d643c581e91" translate="yes" xml:space="preserve">
          <source>Prepared statements only last for the duration of the current database session. When the session ends, the prepared statement is forgotten, so it must be recreated before being used again. This also means that a single prepared statement cannot be used by multiple simultaneous database clients; however, each client can create their own prepared statement to use. Prepared statements can be manually cleaned up using the &lt;a href=&quot;sql-deallocate&quot;&gt;DEALLOCATE&lt;/a&gt; command.</source>
          <target state="translated">准备的语句仅在当前数据库会话期间持续。会话结束时，准备好的语句将被遗忘，因此必须在重新使用之前重新创建它。这也意味着单个准备好的语句不能同时被多个数据库客户端使用。但是，每个客户端可以创建自己准备好的语句来使用。可以使用&lt;a href=&quot;sql-deallocate&quot;&gt;DEALLOCATE&lt;/a&gt;命令手动清除准备好的语句。</target>
        </trans-unit>
        <trans-unit id="a483a03c91ae871a21f8ef97015a97d796c2feb5" translate="yes" xml:space="preserve">
          <source>Prepared statements potentially have the largest performance advantage when a single session is being used to execute a large number of similar statements. The performance difference will be particularly significant if the statements are complex to plan or rewrite, e.g. if the query involves a join of many tables or requires the application of several rules. If the statement is relatively simple to plan and rewrite but relatively expensive to execute, the performance advantage of prepared statements will be less noticeable.</source>
          <target state="translated">当一个会话被用来执行大量类似的语句时,准备好的语句可能具有最大的性能优势。如果语句的计划或重写很复杂,例如,如果查询涉及许多表的连接或需要应用若干规则,那么性能差异将特别显著。如果语句的规划和重写相对简单,但执行成本相对较高,那么准备好的语句的性能优势就不那么明显了。</target>
        </trans-unit>
        <trans-unit id="7a94a7cd86cc26d07584643894920d2ea393b742" translate="yes" xml:space="preserve">
          <source>Prepared statements potentially have the largest performance advantage when a single session is being used to execute a large number of similar statements. The performance difference will be particularly significant if the statements are complex to plan or rewrite, e.g., if the query involves a join of many tables or requires the application of several rules. If the statement is relatively simple to plan and rewrite but relatively expensive to execute, the performance advantage of prepared statements will be less noticeable.</source>
          <target state="translated">当一个会话被用来执行大量类似的语句时,准备好的语句可能具有最大的性能优势。如果语句的计划或重写很复杂,例如,如果查询涉及许多表的连接或需要应用若干规则,那么性能差异将特别显著。如果语句的规划和重写相对简单,但执行成本相对较高,那么准备好的语句的性能优势就不那么明显了。</target>
        </trans-unit>
        <trans-unit id="753ab9dddcfb8d57e3e410ee3c11bd1e55a46a27" translate="yes" xml:space="preserve">
          <source>Prepares the server to begin an on-line backup. The only required parameter is an arbitrary user-defined label for the backup. (Typically this would be the name under which the backup dump file will be stored.) If the optional second parameter is given as &lt;code&gt;true&lt;/code&gt;, it specifies executing &lt;code&gt;pg_start_backup&lt;/code&gt; as quickly as possible. This forces an immediate checkpoint which will cause a spike in I/O operations, slowing any concurrently executing queries. The optional third parameter specifies whether to perform an exclusive or non-exclusive backup (default is exclusive).</source>
          <target state="translated">准备服务器以开始联机备份。唯一需要的参数是备份的任意用户定义标签。（通常这将是备份转储文件的存储名称。）如果将可选的第二个参数指定为 &lt;code&gt;true&lt;/code&gt; ，则它指定尽快执行 &lt;code&gt;pg_start_backup&lt;/code&gt; 。这将强制执行立即检查点，这将导致I / O操作激增，从而降低任何同时执行的查询的速度。可选的第三个参数指定执行独占备份还是非独占备份（默认为独占）。</target>
        </trans-unit>
        <trans-unit id="09d9df46eddb7f24ca7fe8fbfe8e2dbda8bfc576" translate="yes" xml:space="preserve">
          <source>Prepends an element to the beginning of an array (same as the &lt;code&gt;anyelement&lt;/code&gt;&lt;code&gt;||&lt;/code&gt;&lt;code&gt;anyarray&lt;/code&gt; operator).</source>
          <target state="translated">将元素添加到数组的开头（与 &lt;code&gt;anyelement&lt;/code&gt; &lt;code&gt;||&lt;/code&gt; &lt;code&gt;anyarray&lt;/code&gt; 运算符相同）。</target>
        </trans-unit>
        <trans-unit id="16e489d5458780c56ecec5255859ffa473005ad5" translate="yes" xml:space="preserve">
          <source>Presently, &lt;code&gt;COPY TO&lt;/code&gt; will never emit an octal or hex-digits backslash sequence, but it does use the other sequences listed above for those control characters.</source>
          <target state="translated">目前， &lt;code&gt;COPY TO&lt;/code&gt; 将永远不会发出八进制或十六进制的反斜杠序列，但是它确实将上面列出的其他序列用于那些控制字符。</target>
        </trans-unit>
        <trans-unit id="aa75b2cb1f42b5b78ef47e3bac6d7cbc20568a8c" translate="yes" xml:space="preserve">
          <source>Presently, &lt;code&gt;ON SELECT&lt;/code&gt; rules must be unconditional &lt;code&gt;INSTEAD&lt;/code&gt; rules and must have actions that consist of a single &lt;code&gt;SELECT&lt;/code&gt; command. Thus, an &lt;code&gt;ON SELECT&lt;/code&gt; rule effectively turns the table into a view, whose visible contents are the rows returned by the rule's &lt;code&gt;SELECT&lt;/code&gt; command rather than whatever had been stored in the table (if anything). It is considered better style to write a &lt;code&gt;CREATE VIEW&lt;/code&gt; command than to create a real table and define an &lt;code&gt;ON SELECT&lt;/code&gt; rule for it.</source>
          <target state="translated">当前， &lt;code&gt;ON SELECT&lt;/code&gt; 规则必须是无条件的 &lt;code&gt;INSTEAD&lt;/code&gt; 规则，并且必须具有由单个 &lt;code&gt;SELECT&lt;/code&gt; 命令组成的动作。因此， &lt;code&gt;ON SELECT&lt;/code&gt; 规则有效地将表转换为视图，其可见内容是规则的 &lt;code&gt;SELECT&lt;/code&gt; 命令返回的行，而不是表中存储的内容（如果有的话）。与创建真实表并为其定义 &lt;code&gt;ON SELECT&lt;/code&gt; 规则相比，写 &lt;code&gt;CREATE VIEW&lt;/code&gt; 命令被认为是更好的样式。</target>
        </trans-unit>
        <trans-unit id="52172a45fa35ea47ee37481a7598605f94332941" translate="yes" xml:space="preserve">
          <source>Presently, all data values in a binary-format file are assumed to be in binary format (format code one). It is anticipated that a future extension might add a header field that allows per-column format codes to be specified.</source>
          <target state="translated">目前,二进制格式文件中的所有数据值都被假定为二进制格式(格式代码一)。预计未来的扩展可能会增加一个标题字段,允许指定每栏的格式码。</target>
        </trans-unit>
        <trans-unit id="07a55fa2dfc20be04c1afe40194156f4b790bc71" translate="yes" xml:space="preserve">
          <source>Presently, if a rule action contains a &lt;code&gt;NOTIFY&lt;/code&gt; command, the &lt;code&gt;NOTIFY&lt;/code&gt; command will be executed unconditionally, that is, the &lt;code&gt;NOTIFY&lt;/code&gt; will be issued even if there are not any rows that the rule should apply to. For example, in:</source>
          <target state="translated">当前，如果规则操作包含 &lt;code&gt;NOTIFY&lt;/code&gt; 命令，则将无条件执行 &lt;code&gt;NOTIFY&lt;/code&gt; 命令，即，即使没有规则应适用的任何行，也将发出 &lt;code&gt;NOTIFY&lt;/code&gt; 。例如，在：</target>
        </trans-unit>
        <trans-unit id="70f8a5644dc2d0fd28dd5618b027e4363107a89a" translate="yes" xml:space="preserve">
          <source>Presently, the commands emitted for &lt;code&gt;--disable-triggers&lt;/code&gt; must be done as superuser. So you should also specify a superuser name with &lt;code&gt;-S&lt;/code&gt; or, preferably, run pg_restore as a PostgreSQL superuser.</source>
          <target state="translated">当前，为 &lt;code&gt;--disable-triggers&lt;/code&gt; 发出的命令必须以超级用户身份执行。因此，您还应该使用 &lt;code&gt;-S&lt;/code&gt; 指定超级用户名，或者最好以PostgreSQL超级用户身份运行pg_restore。</target>
        </trans-unit>
        <trans-unit id="48866779c6574ae0eb32e070be6be5c56e3ca440" translate="yes" xml:space="preserve">
          <source>Presently, the commands emitted for &lt;code&gt;--disable-triggers&lt;/code&gt; must be done as superuser. So, you should also specify a superuser name with &lt;code&gt;-S&lt;/code&gt;, or preferably be careful to start the resulting script as a superuser.</source>
          <target state="translated">当前，为 &lt;code&gt;--disable-triggers&lt;/code&gt; 发出的命令必须以超级用户身份执行。因此，您还应该使用 &lt;code&gt;-S&lt;/code&gt; 指定超级用户名，或者最好小心地以超级用户身份启动生成的脚本。</target>
        </trans-unit>
        <trans-unit id="334d01d9c8e3bbf43f71d7eda4f0774b3bc44f64" translate="yes" xml:space="preserve">
          <source>Preset Options</source>
          <target state="translated">预设选项</target>
        </trans-unit>
        <trans-unit id="e96fea52df5eb0d7ea088eb0523f5fd6be20645f" translate="yes" xml:space="preserve">
          <source>Prev</source>
          <target state="translated">Prev</target>
        </trans-unit>
        <trans-unit id="ee7bdb0dff39839c1fd827f5826a7bfd60c2d7e2" translate="yes" xml:space="preserve">
          <source>Prevent dumping of access privileges (grant/revoke commands).</source>
          <target state="translated">防止倾倒访问权限(授予/撤销命令)。</target>
        </trans-unit>
        <trans-unit id="a0771736ef9369c38d7919dcb8f69f80ef4855cc" translate="yes" xml:space="preserve">
          <source>Prevent restoration of access privileges (grant/revoke commands).</source>
          <target state="translated">防止恢复访问权限(授予/撤销命令)。</target>
        </trans-unit>
        <trans-unit id="233b752a1d979d1b03bfc00189d385eb81deac5c" translate="yes" xml:space="preserve">
          <source>Preventing Server Spoofing</source>
          <target state="translated">防止服务器欺骗</target>
        </trans-unit>
        <trans-unit id="1a94269e22003d091ed6391f5e761e1543872045" translate="yes" xml:space="preserve">
          <source>Prevents issuing a password prompt. If the server requires password authentication and a password is not available by other means such as a &lt;code&gt;.pgpass&lt;/code&gt; file, the connection attempt will fail. This option can be useful in batch jobs and scripts where no user is present to enter a password.</source>
          <target state="translated">防止发出密码提示。如果服务器要求密码验证，而 &lt;code&gt;.pgpass&lt;/code&gt; 文件等其他方式无法使用密码，则连接尝试将失败。在没有用户输入密码的批处理作业和脚本中，此选项很有用。</target>
        </trans-unit>
        <trans-unit id="e8bdc61ee10f118e8dbdacdf82251ed8db7cccd4" translate="yes" xml:space="preserve">
          <source>Prevents the creation of a temporary replication slot for the backup.</source>
          <target state="translated">防止为备份创建临时复制槽。</target>
        </trans-unit>
        <trans-unit id="2b615ec81ab4e47bd0f90f57d3f7154275428abd" translate="yes" xml:space="preserve">
          <source>Prevents the server from estimating the total amount of backup data that will be streamed, resulting in the &lt;code&gt;backup_total&lt;/code&gt; column in the &lt;code&gt;pg_stat_progress_basebackup&lt;/code&gt; view always being &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">阻止服务器估计将要流式传输的备份数据的总量，从而导致 &lt;code&gt;pg_stat_progress_basebackup&lt;/code&gt; 视图中的 &lt;code&gt;backup_total&lt;/code&gt; 列始终为 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b97befde20e55eaecab9bab9cc63c02e247c4a9f" translate="yes" xml:space="preserve">
          <source>Previous releases failed to preserve a lock which is upgraded by a later savepoint. For example, this code:</source>
          <target state="translated">以前的版本无法保存被后来的保存点升级的锁。例如,这段代码。</target>
        </trans-unit>
        <trans-unit id="7ed4a0fe2451468df117ba30c37470ca22149ca7" translate="yes" xml:space="preserve">
          <source>Primary (server)</source>
          <target state="translated">主要(服务器)</target>
        </trans-unit>
        <trans-unit id="f4bbf8103efddb82c7e4b9fff8c530d57422a504" translate="yes" xml:space="preserve">
          <source>Primary key</source>
          <target state="translated">主键</target>
        </trans-unit>
        <trans-unit id="5e203068f90ee842092a40f00034de5e2bf0c940" translate="yes" xml:space="preserve">
          <source>Primary keys are useful both for documentation purposes and for client applications. For example, a GUI application that allows modifying row values probably needs to know the primary key of a table to be able to identify rows uniquely. There are also various ways in which the database system makes use of a primary key if one has been declared; for example, the primary key defines the default target column(s) for foreign keys referencing its table.</source>
          <target state="translated">主键对于文档目的和客户端应用都很有用。例如,一个允许修改行值的GUI应用程序可能需要知道一个表的主键,以便能够唯一地识别行。如果已经声明了主键,数据库系统也有各种方式使用主键;例如,主键定义了引用其表的外键的默认目标列。</target>
        </trans-unit>
        <trans-unit id="302096a883e851361a7c65e770ac4a2f93b77640" translate="yes" xml:space="preserve">
          <source>Primary keys can span more than one column; the syntax is similar to unique constraints:</source>
          <target state="translated">主键可以跨越多列;语法与唯一约束相似。</target>
        </trans-unit>
        <trans-unit id="54c622f5b5e8c75c7d4757c68339aa2e8b25f7fc" translate="yes" xml:space="preserve">
          <source>Primary log file name, or log in the requested format, currently in use by the logging collector</source>
          <target state="translated">主要日志文件名,或日志收集器当前使用的所需格式的日志。</target>
        </trans-unit>
        <trans-unit id="4a03aad5c247b986acad6d97b6927c2a6ffb1095" translate="yes" xml:space="preserve">
          <source>Primitive JSON values are compared using the same comparison rules as for the underlying PostgreSQL data type. Strings are compared using the default database collation.</source>
          <target state="translated">原始JSON值使用与底层PostgreSQL数据类型相同的比较规则进行比较。字符串则使用默认的数据库整理方式进行比较。</target>
        </trans-unit>
        <trans-unit id="9f9dd23572b66164559cf3545fb93e79c89e5d8a" translate="yes" xml:space="preserve">
          <source>Principal used to authenticate this connection, or NULL if GSSAPI was not used to authenticate this connection. This field is truncated if the principal is longer than &lt;code&gt;NAMEDATALEN&lt;/code&gt; (64 characters in a standard build).</source>
          <target state="translated">用于验证此连接的主体，如果不使用GSSAPI验证此连接，则为NULL。如果主体长度大于 &lt;code&gt;NAMEDATALEN&lt;/code&gt; （标准版本中为64个字符），则此字段将被截断。</target>
        </trans-unit>
        <trans-unit id="a7e7318f55e0c844d9e1050c000b470ae6a8596e" translate="yes" xml:space="preserve">
          <source>Print additional information including the version and the &quot;include&quot; path.</source>
          <target state="translated">打印附加信息,包括版本和 &quot;包含 &quot;路径。</target>
        </trans-unit>
        <trans-unit id="e8de0f5082ac6065288eac684400de412407c144" translate="yes" xml:space="preserve">
          <source>Print all nonempty input lines to standard output as they are read. (This does not apply to lines read interactively.) This is equivalent to setting the variable &lt;code&gt;ECHO&lt;/code&gt; to &lt;code&gt;all&lt;/code&gt;.</source>
          <target state="translated">读取时将所有非空输入行打印到标准输出。（这不适用于以交互方式读取的行。）这等效于将变量 &lt;code&gt;ECHO&lt;/code&gt; 设置为 &lt;code&gt;all&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ebb9a1e5bbdb1243d5e4a31dff31eebe9fc06f03" translate="yes" xml:space="preserve">
          <source>Print debugging output from the bootstrap backend and a few other messages of lesser interest for the general public. The bootstrap backend is the program &lt;code&gt;initdb&lt;/code&gt; uses to create the catalog tables. This option generates a tremendous amount of extremely boring output.</source>
          <target state="translated">打印来自引导后端的调试输出和其他一些公众不太感兴趣的消息。引导程序后端是 &lt;code&gt;initdb&lt;/code&gt; 用于创建目录表的程序。此选项会产生大量非常无聊的输出。</target>
        </trans-unit>
        <trans-unit id="a7c370355f00f0bd758a9808623b790c218141fd" translate="yes" xml:space="preserve">
          <source>Print debugging output.</source>
          <target state="translated">打印调试输出。</target>
        </trans-unit>
        <trans-unit id="f0d63d35347e807b3cd5630fcccfcb97aefdff03" translate="yes" xml:space="preserve">
          <source>Print detailed information during processing.</source>
          <target state="translated">在处理过程中打印详细信息。</target>
        </trans-unit>
        <trans-unit id="c073dbd6b543c579fb650eb5ea8d11e57c402573" translate="yes" xml:space="preserve">
          <source>Print failed SQL commands to standard error output. This is equivalent to setting the variable &lt;code&gt;ECHO&lt;/code&gt; to &lt;code&gt;errors&lt;/code&gt;.</source>
          <target state="translated">将失败的SQL命令打印到标准错误输出。这等效于将变量 &lt;code&gt;ECHO&lt;/code&gt; 设置为 &lt;code&gt;errors&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="597bb464eafa276a5ad0cc91e76eaf6190c85748" translate="yes" xml:space="preserve">
          <source>Print lots of debug logging output on &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;stderr&lt;/code&gt; 上打印大量调试日志记录输出。</target>
        </trans-unit>
        <trans-unit id="a75f64b677ea04810bae39f5467bba0bd440ec28" translate="yes" xml:space="preserve">
          <source>Print only errors, no informational messages.</source>
          <target state="translated">只打印错误,不打印信息性信息。</target>
        </trans-unit>
        <trans-unit id="4f01f9df20b27d4321c4eb47d64e1ce581df8c21" translate="yes" xml:space="preserve">
          <source>Print psql's command line history to &lt;code&gt;filename&lt;/code&gt;. If &lt;code&gt;filename&lt;/code&gt; is omitted, the history is written to the standard output (using the pager if appropriate). This command is not available if psql was built without Readline support.</source>
          <target state="translated">将psql的命令行历史记录打印到 &lt;code&gt;filename&lt;/code&gt; 。如果省略 &lt;code&gt;filename&lt;/code&gt; ，则将历史记录写入标准输出（如果合适，使用寻呼机）。如果psql是在没有Readline支持的情况下构建的，则此命令不可用。</target>
        </trans-unit>
        <trans-unit id="827ff74717cfd2b965ff32b6c6548085dff68335" translate="yes" xml:space="preserve">
          <source>Print the clusterdb version and exit.</source>
          <target state="translated">打印 clusterdb 版本并退出。</target>
        </trans-unit>
        <trans-unit id="f6d64dc0309d9d3b50923addc35c2349b3a13866" translate="yes" xml:space="preserve">
          <source>Print the createdb version and exit.</source>
          <target state="translated">打印创建的版本b并退出。</target>
        </trans-unit>
        <trans-unit id="f9c1069309fb6fad15e176f641cc5f92410a215f" translate="yes" xml:space="preserve">
          <source>Print the createuser version and exit.</source>
          <target state="translated">打印createuser版本并退出。</target>
        </trans-unit>
        <trans-unit id="6ca986b09253f90ac05485c4d1b53fd88df68efc" translate="yes" xml:space="preserve">
          <source>Print the current query buffer to the standard output. If the current query buffer is empty, the most recently executed query is printed instead.</source>
          <target state="translated">将当前的查询缓冲区打印到标准输出。如果当前查询缓冲区为空,则打印最近执行的查询。</target>
        </trans-unit>
        <trans-unit id="1947bab167f53773caffcdb3abd24d61e23f4340" translate="yes" xml:space="preserve">
          <source>Print the dropdb version and exit.</source>
          <target state="translated">打印dropdb版本并退出。</target>
        </trans-unit>
        <trans-unit id="c27b83ad0e23795e57b1563b077c538c9ab60bb3" translate="yes" xml:space="preserve">
          <source>Print the dropuser version and exit.</source>
          <target state="translated">打印dropuser版本并退出。</target>
        </trans-unit>
        <trans-unit id="e9eeca2b3e3f27d8960033787d850e4053105026" translate="yes" xml:space="preserve">
          <source>Print the ecpg version and exit.</source>
          <target state="translated">打印ecpg版本并退出。</target>
        </trans-unit>
        <trans-unit id="657af6d675a70187bdfd892abd1e767e65979526" translate="yes" xml:space="preserve">
          <source>Print the initdb version and exit.</source>
          <target state="translated">打印initdb版本并退出。</target>
        </trans-unit>
        <trans-unit id="a31c7045982c28354a2311d649532f2714d0cd52" translate="yes" xml:space="preserve">
          <source>Print the location of C header files for server programming.</source>
          <target state="translated">打印服务器编程的C头文件的位置。</target>
        </trans-unit>
        <trans-unit id="c7399f9aea54b81806345b5fe9d88c09f2b217c4" translate="yes" xml:space="preserve">
          <source>Print the location of C header files of the client interfaces.</source>
          <target state="translated">打印客户端接口的C头文件的位置。</target>
        </trans-unit>
        <trans-unit id="595d5d7d00e3b9031bcf9b394461136007040d8b" translate="yes" xml:space="preserve">
          <source>Print the location of HTML documentation files.</source>
          <target state="translated">打印HTML文档文件的位置。</target>
        </trans-unit>
        <trans-unit id="2c45a54aeef843a3b47abadef8be23a9c8c5faa3" translate="yes" xml:space="preserve">
          <source>Print the location of architecture-independent support files.</source>
          <target state="translated">打印与架构无关的支持文件的位置。</target>
        </trans-unit>
        <trans-unit id="6938b263f35a6474ff201cc4e757d0f937313671" translate="yes" xml:space="preserve">
          <source>Print the location of documentation files.</source>
          <target state="translated">打印文档文件的位置。</target>
        </trans-unit>
        <trans-unit id="38bf4c616b7c56d3f58464d10d1a64af7f6e8779" translate="yes" xml:space="preserve">
          <source>Print the location of dynamically loadable modules, or where the server would search for them. (Other architecture-dependent data files might also be installed in this directory.)</source>
          <target state="translated">打印动态可加载模块的位置,或者服务器搜索它们的位置。(其他与架构相关的数据文件也可能安装在这个目录中。)</target>
        </trans-unit>
        <trans-unit id="53148cc85f0f5372b92b4adab97d78f0cf599385" translate="yes" xml:space="preserve">
          <source>Print the location of extension makefiles.</source>
          <target state="translated">打印extension makefiles的位置。</target>
        </trans-unit>
        <trans-unit id="4dee3cc7ede35752aad16661b510c6ddc2cb5087" translate="yes" xml:space="preserve">
          <source>Print the location of locale support files. (This will be an empty string if locale support was not configured when PostgreSQL was built.)</source>
          <target state="translated">打印locale支持文件的位置。(如果在建立PostgreSQL时没有配置locale支持,那么这将是一个空字符串。)</target>
        </trans-unit>
        <trans-unit id="8935ed932264eb12d05dc3d54390bc5894e6a109" translate="yes" xml:space="preserve">
          <source>Print the location of manual pages.</source>
          <target state="translated">打印手册页的位置。</target>
        </trans-unit>
        <trans-unit id="5c6b2cdac40039c6a4b46eed898e35031563c475" translate="yes" xml:space="preserve">
          <source>Print the location of object code libraries.</source>
          <target state="translated">打印对象代码库的位置。</target>
        </trans-unit>
        <trans-unit id="cc4be32137a130cb7e8939f72a35980a1297a7e0" translate="yes" xml:space="preserve">
          <source>Print the location of other C header files.</source>
          <target state="translated">打印其他C头文件的位置。</target>
        </trans-unit>
        <trans-unit id="348ec650580d85aaddcb30661d2eb9345e76019a" translate="yes" xml:space="preserve">
          <source>Print the location of system-wide configuration files.</source>
          <target state="translated">打印全系统配置文件的位置。</target>
        </trans-unit>
        <trans-unit id="4773e766d5cc8cfc3ce755cd29aeb486a0dd05ae" translate="yes" xml:space="preserve">
          <source>Print the location of user executables. Use this, for example, to find the &lt;code&gt;psql&lt;/code&gt; program. This is normally also the location where the &lt;code&gt;pg_config&lt;/code&gt; program resides.</source>
          <target state="translated">打印用户可执行文件的位置。例如，使用它来查找 &lt;code&gt;psql&lt;/code&gt; 程序。通常这也是 &lt;code&gt;pg_config&lt;/code&gt; 程序所在的位置。</target>
        </trans-unit>
        <trans-unit id="53049ab5ef89f22bb5a6370fb0f7681de3a90603" translate="yes" xml:space="preserve">
          <source>Print the names of the files that would have been removed on &lt;code&gt;stdout&lt;/code&gt; (performs a dry run).</source>
          <target state="translated">打印将在 &lt;code&gt;stdout&lt;/code&gt; 上删除的文件名（执行空运行）。</target>
        </trans-unit>
        <trans-unit id="9c56e3a83e3c5d8c7d0ed82cb15ca361eb64f1dd" translate="yes" xml:space="preserve">
          <source>Print the options that were given to the &lt;code&gt;configure&lt;/code&gt; script when PostgreSQL was configured for building. This can be used to reproduce the identical configuration, or to find out with what options a binary package was built. (Note however that binary packages often contain vendor-specific custom patches.) See also the examples below.</source>
          <target state="translated">打印为PostgreSQL配置进行构建时为 &lt;code&gt;configure&lt;/code&gt; 脚本提供的选项。这可用于重现相同的配置，或找出构建二进制包的选项。（但是请注意，二进制软件包通常包含特定于供应商的自定义补丁。）另请参见以下示例。</target>
        </trans-unit>
        <trans-unit id="b85724f77cfb0e7f274dc964acb424d6648ba3f5" translate="yes" xml:space="preserve">
          <source>Print the pg_archivecleanup version and exit.</source>
          <target state="translated">打印pg_archivecleanup版本并退出。</target>
        </trans-unit>
        <trans-unit id="74b744744ac1bd9386b12893ce62c91739371ca7" translate="yes" xml:space="preserve">
          <source>Print the pg_basebackup version and exit.</source>
          <target state="translated">打印pg_basebackup版本并退出。</target>
        </trans-unit>
        <trans-unit id="1fca2718d1cfc02986e8abfd6906319ca68c5805" translate="yes" xml:space="preserve">
          <source>Print the pg_checksums version and exit.</source>
          <target state="translated">打印pg_checksums版本并退出。</target>
        </trans-unit>
        <trans-unit id="bff35bc331305f42d0adc605e5c4b58b8bea0e9f" translate="yes" xml:space="preserve">
          <source>Print the pg_ctl version and exit.</source>
          <target state="translated">打印pg_ctl版本并退出。</target>
        </trans-unit>
        <trans-unit id="2f2c8e42d192d577eaeaaebcc2a4ef29dbe17a60" translate="yes" xml:space="preserve">
          <source>Print the pg_dump version and exit.</source>
          <target state="translated">打印pg_dump版本并退出。</target>
        </trans-unit>
        <trans-unit id="711f70c380c99649a9e35f12c5de7cf7f0629905" translate="yes" xml:space="preserve">
          <source>Print the pg_dumpall version and exit.</source>
          <target state="translated">打印pg_dumpall版本并退出。</target>
        </trans-unit>
        <trans-unit id="8234e166090222ac3be3d5f09ddf8625331bebb7" translate="yes" xml:space="preserve">
          <source>Print the pg_isready version and exit.</source>
          <target state="translated">打印pg_isready版本并退出。</target>
        </trans-unit>
        <trans-unit id="521a97d4453901044173e646cb65a707141a7eb2" translate="yes" xml:space="preserve">
          <source>Print the pg_receivewal version and exit.</source>
          <target state="translated">打印pg_receivewal版本并退出。</target>
        </trans-unit>
        <trans-unit id="8fea9240f920d019a51b3b8ffd1d91229e6f0d5d" translate="yes" xml:space="preserve">
          <source>Print the pg_recvlogical version and exit.</source>
          <target state="translated">打印pg_recvlogical版本并退出。</target>
        </trans-unit>
        <trans-unit id="70b6553fafd53c48b770a9da4d3ec37d70a8b1bd" translate="yes" xml:space="preserve">
          <source>Print the pg_restore version and exit.</source>
          <target state="translated">打印pg_restore版本并退出。</target>
        </trans-unit>
        <trans-unit id="6c61b85690c18a6b2ca1bca9177c45ff31b5bf02" translate="yes" xml:space="preserve">
          <source>Print the pg_test_fsync version and exit.</source>
          <target state="translated">打印pg_test_fsync版本并退出。</target>
        </trans-unit>
        <trans-unit id="b30cd37e82aef2f652a2277ade9f7c97f25f875b" translate="yes" xml:space="preserve">
          <source>Print the pg_test_timing version and exit.</source>
          <target state="translated">打印pg_test_timing版本并退出。</target>
        </trans-unit>
        <trans-unit id="e08a7072f490e6a4e9bfb50e943fdf0655a61477" translate="yes" xml:space="preserve">
          <source>Print the pg_verifybackup version and exit.</source>
          <target state="translated">打印pg_verifybackup版本并退出。</target>
        </trans-unit>
        <trans-unit id="a75796fa54df85333380d1e7052d5f64abec4dce" translate="yes" xml:space="preserve">
          <source>Print the pg_waldump version and exit.</source>
          <target state="translated">打印pg_waldump版本并退出。</target>
        </trans-unit>
        <trans-unit id="835f88fb67301afbc19bedf23ff78555f1978387" translate="yes" xml:space="preserve">
          <source>Print the pgbench version and exit.</source>
          <target state="translated">打印pgbench版本并退出。</target>
        </trans-unit>
        <trans-unit id="f24e000355bdd04337ccc4fe4d288fbdae421623" translate="yes" xml:space="preserve">
          <source>Print the postgres version and exit.</source>
          <target state="translated">打印postgres版本并退出。</target>
        </trans-unit>
        <trans-unit id="a240d07648994ecf31009ecc7c34fcbc6cd8c620" translate="yes" xml:space="preserve">
          <source>Print the psql version and exit.</source>
          <target state="translated">打印psql版本并退出。</target>
        </trans-unit>
        <trans-unit id="9739b8f99cc181f488382f72fe14dfc0f6cbc479" translate="yes" xml:space="preserve">
          <source>Print the reindexdb version and exit.</source>
          <target state="translated">打印reindexdb版本并退出。</target>
        </trans-unit>
        <trans-unit id="ecaad77a21e5cec5eaf16f12e5d3692f68b6cf4f" translate="yes" xml:space="preserve">
          <source>Print the vacuumdb version and exit.</source>
          <target state="translated">打印vacuumdb版本并退出。</target>
        </trans-unit>
        <trans-unit id="860a0a17430dffac960ad73d395384c352d45cdd" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;CC&lt;/code&gt; variable that was used for building PostgreSQL. This shows the C compiler used.</source>
          <target state="translated">打印用于构建PostgreSQL 的 &lt;code&gt;CC&lt;/code&gt; 变量的值。这显示了使用的C编译器。</target>
        </trans-unit>
        <trans-unit id="7872c242661cddddfe9f42b05b47dc0212422396" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;CFLAGS&lt;/code&gt; variable that was used for building PostgreSQL. This shows C compiler switches.</source>
          <target state="translated">打印用于构建PostgreSQL 的 &lt;code&gt;CFLAGS&lt;/code&gt; 变量的值。这显示了C编译器开关。</target>
        </trans-unit>
        <trans-unit id="04b3c2f0676508a38269ff7567031f4ef2b568d8" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;CFLAGS_SL&lt;/code&gt; variable that was used for building PostgreSQL. This shows extra C compiler switches used for building shared libraries.</source>
          <target state="translated">打印用于构建PostgreSQL 的 &lt;code&gt;CFLAGS_SL&lt;/code&gt; 变量的值。这显示了用于构建共享库的其他C编译器开关。</target>
        </trans-unit>
        <trans-unit id="7c0bdef9295fb7af405415912b5de766b9d4853d" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;CPPFLAGS&lt;/code&gt; variable that was used for building PostgreSQL. This shows C compiler switches needed at preprocessing time (typically, &lt;code&gt;-I&lt;/code&gt; switches).</source>
          <target state="translated">打印用于构建PostgreSQL 的 &lt;code&gt;CPPFLAGS&lt;/code&gt; 变量的值。这显示了在预处理时需要的C编译器开关（通常是 &lt;code&gt;-I&lt;/code&gt; 开关）。</target>
        </trans-unit>
        <trans-unit id="0696181ec9c948b2b028ffaf665cb6bea3b893d7" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;LDFLAGS&lt;/code&gt; variable that was used for building PostgreSQL. This shows linker switches.</source>
          <target state="translated">打印用于构建PostgreSQL 的 &lt;code&gt;LDFLAGS&lt;/code&gt; 变量的值。这显示了链接器开关。</target>
        </trans-unit>
        <trans-unit id="6bb0fe5ffeea6cad2f014a2a3a3b8da60923296c" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;LDFLAGS_EX&lt;/code&gt; variable that was used for building PostgreSQL. This shows linker switches used for building executables only.</source>
          <target state="translated">打印用于构建PostgreSQL 的 &lt;code&gt;LDFLAGS_EX&lt;/code&gt; 变量的值。这显示了仅用于构建可执行文件的链接器开关。</target>
        </trans-unit>
        <trans-unit id="afbd4079f245521defb38cf6819d6a459fcf80ee" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;LDFLAGS_SL&lt;/code&gt; variable that was used for building PostgreSQL. This shows linker switches used for building shared libraries only.</source>
          <target state="translated">打印用于构建PostgreSQL 的 &lt;code&gt;LDFLAGS_SL&lt;/code&gt; 变量的值。这显示了仅用于构建共享库的链接器开关。</target>
        </trans-unit>
        <trans-unit id="6ca57dae88c29583c5d57897894867bc83f03e6b" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;LIBS&lt;/code&gt; variable that was used for building PostgreSQL. This normally contains &lt;code&gt;-l&lt;/code&gt; switches for external libraries linked into PostgreSQL.</source>
          <target state="translated">打印用于构建PostgreSQL 的 &lt;code&gt;LIBS&lt;/code&gt; 变量的值。它通常包含 &lt;code&gt;-l&lt;/code&gt; 开关，用于链接到PostgreSQL的外部库。</target>
        </trans-unit>
        <trans-unit id="8570b6b8795434406c72b8b33b0f9520fcd7b330" translate="yes" xml:space="preserve">
          <source>Print the version of PostgreSQL.</source>
          <target state="translated">打印PostgreSQL的版本。</target>
        </trans-unit>
        <trans-unit id="c7df780f62e4b06755a28e7503d78d06b7b6aac8" translate="yes" xml:space="preserve">
          <source>Print time information and other statistics at the end of each command. This is useful for benchmarking or for use in tuning the number of buffers.</source>
          <target state="translated">在每个命令结束时打印时间信息和其他统计数据。这对基准测试或调整缓冲区数量很有用。</target>
        </trans-unit>
        <trans-unit id="7df4a5fb243017c5e16941bc4e0dfea430b29b29" translate="yes" xml:space="preserve">
          <source>Print timing statistics for each query relating to each of the major system modules. This option cannot be used together with the &lt;code&gt;-s&lt;/code&gt; option.</source>
          <target state="translated">打印与每个主要系统模块有关的每个查询的计时统计信息。此选项不能与 &lt;code&gt;-s&lt;/code&gt; 选项一起使用。</target>
        </trans-unit>
        <trans-unit id="85a0746f8a9b8ded581582b11332c0023bccc928" translate="yes" xml:space="preserve">
          <source>Print verbose debugging output that is mostly useful for developers debugging pg_rewind.</source>
          <target state="translated">打印详细的调试输出,这对于调试pg_rewind的开发人员来说,主要是有用的。</target>
        </trans-unit>
        <trans-unit id="97b0c0a03f737e5ff32021d5ed70701853641a62" translate="yes" xml:space="preserve">
          <source>Prints a detailed vacuum activity report for each table.</source>
          <target state="translated">打印每个表的详细真空活动报告。</target>
        </trans-unit>
        <trans-unit id="fdb87a5e1b1bdc10bff754f8e203de6fe5cda103" translate="yes" xml:space="preserve">
          <source>Prints a progress report as each index is reindexed.</source>
          <target state="translated">在每个索引重新索引时打印进度报告。</target>
        </trans-unit>
        <trans-unit id="aa656d5b9337debc039cad558013cd97db922af4" translate="yes" xml:space="preserve">
          <source>Prints a progress report as each table is clustered.</source>
          <target state="translated">在每张表聚类时打印进度报告。</target>
        </trans-unit>
        <trans-unit id="dd907f7d58905d750186d058c3a6deb80e3a4b4f" translate="yes" xml:space="preserve">
          <source>Prints the argument to stderr, and returns the argument.</source>
          <target state="translated">将参数打印到stderr,并返回参数。</target>
        </trans-unit>
        <trans-unit id="b8b2b40104cd92cd0c519f2553360402afa05710" translate="yes" xml:space="preserve">
          <source>Prints the arguments to the standard output, separated by one space and followed by a newline. This can be useful to intersperse information in the output of scripts. For example:</source>
          <target state="translated">将参数打印到标准输出中,用一个空格隔开,后面加一个换行。这对于在脚本输出中穿插信息很有用。例如</target>
        </trans-unit>
        <trans-unit id="54169614c32fc13e7741fdc14ac2684c64e4dad5" translate="yes" xml:space="preserve">
          <source>Prints the evaluated arguments to standard output, separated by spaces and followed by a newline. This can be useful to intersperse information in the output of scripts. For example:</source>
          <target state="translated">将经过评估的参数打印到标准输出,用空格隔开,后面加一个换行。这对于在脚本输出中穿插信息很有用。例如</target>
        </trans-unit>
        <trans-unit id="0f1bb5606479758154dc8298304bb8f734e9529b" translate="yes" xml:space="preserve">
          <source>Prints the pg_basebackup version and exits.</source>
          <target state="translated">打印pg_basebackup版本并退出。</target>
        </trans-unit>
        <trans-unit id="f89aa4d95dc992bd35115af766260f55953c5bc3" translate="yes" xml:space="preserve">
          <source>Prints the value of the named run-time parameter, and exits. (See the &lt;code&gt;-c&lt;/code&gt; option above for details.) This can be used on a running server, and returns values from &lt;code&gt;postgresql.conf&lt;/code&gt;, modified by any parameters supplied in this invocation. It does not reflect parameters supplied when the cluster was started.</source>
          <target state="translated">打印命名的运行时参数的值，然后退出。（有关详细信息，请参见上面的 &lt;code&gt;-c&lt;/code&gt; 选项。）这可以在运行的服务器上使用，并从 &lt;code&gt;postgresql.conf&lt;/code&gt; 返回值，该值由此调用中提供的任何参数修改。它不反映集群启动时提供的参数。</target>
        </trans-unit>
        <trans-unit id="4dcba485023d207a9206ea5fc3e3c00fb561414e" translate="yes" xml:space="preserve">
          <source>Prior releases of PostgreSQL also had an R-tree index method. This method has been removed because it had no significant advantages over the GiST method. If &lt;code&gt;USING rtree&lt;/code&gt; is specified, &lt;code&gt;CREATE INDEX&lt;/code&gt; will interpret it as &lt;code&gt;USING gist&lt;/code&gt;, to simplify conversion of old databases to GiST.</source>
          <target state="translated">先前的PostgreSQL版本也有R树索引方法。该方法已被删除，因为它与GiST方法相比没有明显的优势。如果指定了 &lt;code&gt;USING rtree&lt;/code&gt; ，则 &lt;code&gt;CREATE INDEX&lt;/code&gt; 会将其解释为 &lt;code&gt;USING gist&lt;/code&gt; ，以简化从旧数据库到GiST的转换。</target>
        </trans-unit>
        <trans-unit id="3bafe92248149caf71bc79d94b8990987f12cfb7" translate="yes" xml:space="preserve">
          <source>Prior to PostgreSQL 10, this rule did not exist, and unspecified-type literals in a &lt;code&gt;SELECT&lt;/code&gt; output list were left as type &lt;code&gt;unknown&lt;/code&gt;. That had assorted bad consequences, so it's been changed.</source>
          <target state="translated">在PostgreSQL 10之前，该规则不存在，并且 &lt;code&gt;SELECT&lt;/code&gt; 输出列表中未指定类型的文字保留为 &lt;code&gt;unknown&lt;/code&gt; 类型。那已经带来了各种各样的不良后果，所以已经改变了。</target>
        </trans-unit>
        <trans-unit id="35b1eb24223c97f90cf161ff4a23f9a4840e576e" translate="yes" xml:space="preserve">
          <source>Prior to PostgreSQL 12, it was possible to skip arbitrary text in the input string using non-letter or non-digit characters. For example, &lt;code&gt;to_timestamp('2000y6m1d', 'yyyy-MM-DD')&lt;/code&gt; used to work. Now you can only use letter characters for this purpose. For example, &lt;code&gt;to_timestamp('2000y6m1d', 'yyyytMMtDDt')&lt;/code&gt; and &lt;code&gt;to_timestamp('2000y6m1d', 'yyyy&quot;y&quot;MM&quot;m&quot;DD&quot;d&quot;')&lt;/code&gt; skip &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, and &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">在PostgreSQL 12之前，可以使用非字母或非数字字符跳过输入字符串中的任意文本。例如， &lt;code&gt;to_timestamp('2000y6m1d', 'yyyy-MM-DD')&lt;/code&gt; 曾经工作过。现在，您只能为此使用字母字符。例如， &lt;code&gt;to_timestamp('2000y6m1d', 'yyyytMMtDDt')&lt;/code&gt; 和 &lt;code&gt;to_timestamp('2000y6m1d', 'yyyy&quot;y&quot;MM&quot;m&quot;DD&quot;d&quot;')&lt;/code&gt; 跳过 &lt;code&gt;y&lt;/code&gt; ， &lt;code&gt;m&lt;/code&gt; 和 &lt;code&gt;d&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="857acef4a685e40620b468c416dd0a4e24020172" translate="yes" xml:space="preserve">
          <source>Prior to PostgreSQL 8.2, the &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;gt;=&lt;/code&gt; cases were not handled per SQL specification. A comparison like &lt;code&gt;ROW(a,b) &amp;lt; ROW(c,d)&lt;/code&gt; was implemented as &lt;code&gt;a &amp;lt; c AND b &amp;lt; d&lt;/code&gt; whereas the correct behavior is equivalent to &lt;code&gt;a &amp;lt; c OR (a = c AND b &amp;lt; d)&lt;/code&gt;.</source>
          <target state="translated">在PostgreSQL 8.2之前，没有按照SQL规范处理 &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;=&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;gt;=&lt;/code&gt; 情况。像 &lt;code&gt;ROW(a,b) &amp;lt; ROW(c,d)&lt;/code&gt; 被实现为 &lt;code&gt;a &amp;lt; c AND b &amp;lt; d&lt;/code&gt; 而正确的行为等效于 &lt;code&gt;a &amp;lt; c OR (a = c AND b &amp;lt; d)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ebe12687d87000c523fc24a0eeeef23def50ea6" translate="yes" xml:space="preserve">
          <source>Prior to PostgreSQL 8.2, the containment operators &lt;code&gt;@&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;@&lt;/code&gt; were called &lt;code&gt;@&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt;, respectively. These names are still available, but are deprecated and will eventually be removed. Notice that the old names are reversed from the convention formerly followed by the core geometric data types!</source>
          <target state="translated">在PostgreSQL 8.2之前，包含运算符 &lt;code&gt;@&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;@&lt;/code&gt; 分别称为 &lt;code&gt;@&lt;/code&gt; 和 &lt;code&gt;~&lt;/code&gt; 。这些名称仍然可用，但已过时，最终将被删除。注意，旧名称与以前的约定相反，后跟核心几何数据类型！</target>
        </trans-unit>
        <trans-unit id="5348a6ba1728be7d24665ecab38998e34ce72cc3" translate="yes" xml:space="preserve">
          <source>Prior to PostgreSQL 9.0, there was no permission structure associated with large objects. As a result, &lt;code&gt;pg_largeobject&lt;/code&gt; was publicly readable and could be used to obtain the OIDs (and contents) of all large objects in the system. This is no longer the case; use &lt;a href=&quot;catalog-pg-largeobject-metadata&quot;&gt;&lt;code&gt;pg_largeobject_metadata&lt;/code&gt;&lt;/a&gt; to obtain a list of large object OIDs.</source>
          <target state="translated">在PostgreSQL 9.0之前，没有与大对象相关的权限结构。结果， &lt;code&gt;pg_largeobject&lt;/code&gt; 是公共可读的，可以用来获取系统中所有大型对象的OID（和内容）。这已不再是这种情况;使用&lt;a href=&quot;catalog-pg-largeobject-metadata&quot;&gt; &lt;code&gt;pg_largeobject_metadata&lt;/code&gt; &lt;/a&gt;获取大对象OID的列表。</target>
        </trans-unit>
        <trans-unit id="b601cf233ea62fc96a74bc628fe24fcc3e36d22e" translate="yes" xml:space="preserve">
          <source>Prior to PostgreSQL 9.3, only System V shared memory was used, so the amount of System V shared memory required to start the server was much larger. If you are running an older version of the server, please consult the documentation for your server version.</source>
          <target state="translated">在PostgreSQL 9.3之前,只使用System V共享内存,因此启动服务器所需的System V共享内存量要大得多。如果你运行的是旧版本的服务器,请查阅服务器版本的文档。</target>
        </trans-unit>
        <trans-unit id="aa951ebcd4fe7e0105a5593fae4e308d45c56780" translate="yes" xml:space="preserve">
          <source>Prior to PostgreSQL version 9.1, a request for the Serializable transaction isolation level provided exactly the same behavior described here. To retain the legacy Serializable behavior, Repeatable Read should now be requested.</source>
          <target state="translated">在PostgreSQL 9.1版本之前,请求Serializable事务隔离级别提供的行为与这里描述的完全相同。为了保留传统的Serializable行为,现在应该请求Repeatable Read。</target>
        </trans-unit>
        <trans-unit id="284364f281ed56be49bcacf7f01665e2a0a6fd04" translate="yes" xml:space="preserve">
          <source>Priority of this standby server for being chosen as the synchronous standby in a priority-based synchronous replication. This has no effect in a quorum-based synchronous replication.</source>
          <target state="translated">在基于优先级的同步复制中,该备用服务器被选为同步备用的优先级。在基于定额的同步复制中,这一点没有影响。</target>
        </trans-unit>
        <trans-unit id="515ede092cef3c82a110d9534d9f8d3d6afc3135" translate="yes" xml:space="preserve">
          <source>Privilege</source>
          <target state="translated">Privilege</target>
        </trans-unit>
        <trans-unit id="f10ec7ea8e1d8b3a37e319a1b22811778ff9078d" translate="yes" xml:space="preserve">
          <source>Privilege and Ownership - &lt;code&gt;GRANT&lt;/code&gt;, &lt;code&gt;REVOKE&lt;/code&gt;, &lt;code&gt;REASSIGN&lt;/code&gt;</source>
          <target state="translated">特权和所有权 &lt;code&gt;GRANT&lt;/code&gt; ， &lt;code&gt;REVOKE&lt;/code&gt; ， &lt;code&gt;REASSIGN&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9010c080ebbc337d2462d6350ec168e7027ffdcc" translate="yes" xml:space="preserve">
          <source>Privilege and Ownership: &lt;code&gt;GRANT&lt;/code&gt;, &lt;code&gt;REVOKE&lt;/code&gt;, &lt;code&gt;REASSIGN&lt;/code&gt;</source>
          <target state="translated">特权和所有权： &lt;code&gt;GRANT&lt;/code&gt; ， &lt;code&gt;REVOKE&lt;/code&gt; ， &lt;code&gt;REASSIGN&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="de3a5e762db24187db518d22a3b23c1896a649d9" translate="yes" xml:space="preserve">
          <source>Privileges</source>
          <target state="translated">Privileges</target>
        </trans-unit>
        <trans-unit id="2a58093a093ab7a9a99a1645efb525934d0d372c" translate="yes" xml:space="preserve">
          <source>Privileges are only checked once at the start of a replication connection. They are not re-checked as each change record is read from the publisher, nor are they re-checked for each change when applied.</source>
          <target state="translated">权限只在复制连接开始时检查一次。当从发布者读取每条变更记录时,它们不会被重新检查,应用时也不会为每条变更重新检查。</target>
        </trans-unit>
        <trans-unit id="1787c604579783f25be8d303f900f7717e89e48f" translate="yes" xml:space="preserve">
          <source>Privileges on databases, tablespaces, schemas, and languages are PostgreSQL extensions.</source>
          <target state="translated">数据库、表空间、模式和语言的权限是PostgreSQL的扩展。</target>
        </trans-unit>
        <trans-unit id="46289836967711686edf2dff70a298178c49970e" translate="yes" xml:space="preserve">
          <source>Probe that fires after dirty buffers have been written to the kernel, and before starting to issue fsync requests.</source>
          <target state="translated">在脏缓冲区被写入内核后,在开始发出fsync请求前触发的探针。</target>
        </trans-unit>
        <trans-unit id="53ee2024c54dc2129f5d4dce9249284ce7d962e4" translate="yes" xml:space="preserve">
          <source>Probe that fires after each buffer is written during checkpoint. arg0 is the ID number of the buffer.</source>
          <target state="translated">arg0是缓冲区的ID号。</target>
        </trans-unit>
        <trans-unit id="3c4f6900a8f3d94a47b827dad74ca58a7f090a3e" translate="yes" xml:space="preserve">
          <source>Probe that fires anytime the server process updates its &lt;code&gt;pg_stat_activity&lt;/code&gt;.&lt;code&gt;status&lt;/code&gt;. arg0 is the new status string.</source>
          <target state="translated">每当服务器进程更新其 &lt;code&gt;pg_stat_activity&lt;/code&gt; 时将触发的探针。 &lt;code&gt;status&lt;/code&gt; 。arg0是新的状态字符串。</target>
        </trans-unit>
        <trans-unit id="453f8db7eb85902c8d7efba2100824b715baeb8d" translate="yes" xml:space="preserve">
          <source>Probe that fires at the start of a new transaction. arg0 is the transaction ID.</source>
          <target state="translated">arg0是交易ID。</target>
        </trans-unit>
        <trans-unit id="3a3aefacb2b30c73490e38f66077f014ccc50ebf" translate="yes" xml:space="preserve">
          <source>Probe that fires before issuing any write request for a shared buffer. arg0 and arg1 contain the fork and block numbers of the page. arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation.</source>
          <target state="translated">arg0和arg1包含页面的fork和块号,arg2、arg3和arg4包含表空间、数据库和关系的OID,标识关系。</target>
        </trans-unit>
        <trans-unit id="33d263a06d1f645788a7d9cc687ecf761651c94e" translate="yes" xml:space="preserve">
          <source>Probe that fires when a WAL record is inserted. arg0 is the resource manager (rmid) for the record. arg1 contains the info flags.</source>
          <target state="translated">arg0是记录的资源管理器(rmid)。 arg1包含信息标志。</target>
        </trans-unit>
        <trans-unit id="9f1168c24751c9cc0c2a8a2c6b3927e1a19c2275" translate="yes" xml:space="preserve">
          <source>Probe that fires when a WAL segment switch is requested.</source>
          <target state="translated">当请求进行WAL段切换时触发的探针。</target>
        </trans-unit>
        <trans-unit id="8e4d476400e68096572772c60276c43e69c8a62b" translate="yes" xml:space="preserve">
          <source>Probe that fires when a block read is complete. arg0 and arg1 contain the fork and block numbers of the page. arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation. arg5 is the ID of the backend which created the temporary relation for a local buffer, or &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1) for a shared buffer. arg6 is the number of bytes actually read, while arg7 is the number requested (if these are different it indicates trouble).</source>
          <target state="translated">块读取完成时将触发的探针。arg0和arg1包含页面的派生号和块号。arg2，arg3和arg4包含表空间，数据库和标识关系的关系OID。arg5是为本地缓冲区创建临时关系的后端的ID，或为共享缓冲区创建的 &lt;code&gt;InvalidBackendId&lt;/code&gt; （-1）。arg6是实际读取的字节数，而arg7是请求的数目（如果它们不同，则表示有问题）。</target>
        </trans-unit>
        <trans-unit id="bec87f01b3c4ae7574229debd84c5fd432c77b1a" translate="yes" xml:space="preserve">
          <source>Probe that fires when a block write is complete. arg0 and arg1 contain the fork and block numbers of the page. arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation. arg5 is the ID of the backend which created the temporary relation for a local buffer, or &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1) for a shared buffer. arg6 is the number of bytes actually written, while arg7 is the number requested (if these are different it indicates trouble).</source>
          <target state="translated">块写入完成时将触发的探针。 arg0和arg1包含页面的派生号和块号。 arg2，arg3和arg4包含表空间，数据库和标识关系的关系OID。 arg5是为本地缓冲区创建临时关系的后端的ID，或为共享缓冲区创建的 &lt;code&gt;InvalidBackendId&lt;/code&gt; （-1）。 arg6是实际写入的字节数，而arg7是请求的数目（如果它们不同，则表示有问题）。</target>
        </trans-unit>
        <trans-unit id="46f91b3dd629f638c1e5b0918321dc6a1503deb9" translate="yes" xml:space="preserve">
          <source>Probe that fires when a buffer read is complete. arg0 and arg1 contain the fork and block numbers of the page (if this is a relation extension request, arg1 now contains the block number of the newly added block). arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation. arg5 is the ID of the backend which created the temporary relation for a local buffer, or &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1) for a shared buffer. arg6 is true for a relation extension request, false for normal read. arg7 is true if the buffer was found in the pool, false if not.</source>
          <target state="translated">缓冲区读取完成时将触发的探针。 arg0和arg1包含页面的派生号和块号（如果这是一个关系扩展请求，则arg1现在包含新添加的块的块号）。 arg2，arg3和arg4包含表空间，数据库和标识关系的关系OID。 arg5是为本地缓冲区创建临时关系的后端的ID，或为共享缓冲区创建的 &lt;code&gt;InvalidBackendId&lt;/code&gt; （-1）。 arg6对于关系扩展请求为true，对于正常读取为false。如果在池中找到了缓冲区，则arg7为true，否则为false。</target>
        </trans-unit>
        <trans-unit id="58ba85ae8dc3ff12abd986e1bbe24ce88cd6ffee" translate="yes" xml:space="preserve">
          <source>Probe that fires when a buffer read is started. arg0 and arg1 contain the fork and block numbers of the page (but arg1 will be -1 if this is a relation extension request). arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation. arg5 is the ID of the backend which created the temporary relation for a local buffer, or &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1) for a shared buffer. arg6 is true for a relation extension request, false for normal read.</source>
          <target state="translated">开始读取缓冲区时触发的探测器。arg0和arg1包含页面的派生号和块号（但如果这是一个关系扩展请求，则arg1将为-1）。arg2，arg3和arg4包含表空间，数据库和标识关系的关系OID。arg5是为本地缓冲区创建临时关系的后端的ID，或为共享缓冲区创建的 &lt;code&gt;InvalidBackendId&lt;/code&gt; （-1）。arg6对于关系扩展请求为true，对于正常读取为false。</target>
        </trans-unit>
        <trans-unit id="0fbe84f59555154d75e50194b6717675ebf83d0f" translate="yes" xml:space="preserve">
          <source>Probe that fires when a checkpoint is complete. (The probes listed next fire in sequence during checkpoint processing.) arg0 is the number of buffers written. arg1 is the total number of buffers. arg2, arg3 and arg4 contain the number of WAL files added, removed and recycled respectively.</source>
          <target state="translated">当一个检查点完成时触发的探针,(接下来列出的探针在检查点处理过程中依次触发。)arg0是写入的缓冲区数量,arg1是缓冲区总数,arg2、 arg3和 arg4包含WAL文件的数量。arg0是写入的缓冲区数量,arg1是缓冲区总数,arg2、arg3和arg4分别包含添加、删除和回收的WAL文件数量。</target>
        </trans-unit>
        <trans-unit id="23fe54bf3cce9571085cc7cf6504d3feaa949415" translate="yes" xml:space="preserve">
          <source>Probe that fires when a checkpoint is started. arg0 holds the bitwise flags used to distinguish different checkpoint types, such as shutdown, immediate or force.</source>
          <target state="translated">arg0持有用于区分不同检查点类型的位标志,如关闭、立即或强制。</target>
        </trans-unit>
        <trans-unit id="93bbd1ca880ff804d869958124aceb46cced58c3" translate="yes" xml:space="preserve">
          <source>Probe that fires when a deadlock is found by the deadlock detector.</source>
          <target state="translated">当死锁检测器发现死锁时发射的探头。</target>
        </trans-unit>
        <trans-unit id="cd2095b8769349eb00b3e4c4c59eb7c9f09aa65d" translate="yes" xml:space="preserve">
          <source>Probe that fires when a dirty WAL buffer write is complete.</source>
          <target state="translated">当肮脏的WAL缓冲区写入完成时触发的探针。</target>
        </trans-unit>
        <trans-unit id="e06e64448ac61e5f30e9d0aae09a59b087a40467" translate="yes" xml:space="preserve">
          <source>Probe that fires when a dirty-buffer write is complete. The arguments are the same as for &lt;code&gt;buffer-write-dirty-start&lt;/code&gt;.</source>
          <target state="translated">脏缓冲区写入完成后将触发的探针。参数与 &lt;code&gt;buffer-write-dirty-start&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="bc7ff5d60d95edecd39d25ce953e04898f2adf03" translate="yes" xml:space="preserve">
          <source>Probe that fires when a request for a heavyweight lock (lmgr lock) has begun to wait because the lock is not available. arg0 through arg3 are the tag fields identifying the object being locked. arg4 indicates the type of object being locked. arg5 indicates the lock type being requested.</source>
          <target state="translated">arg0到arg3是标识被锁定对象的标签字段,arg4表示被锁定的对象类型,arg5表示请求的锁类型。</target>
        </trans-unit>
        <trans-unit id="4162528ebd10f947261c421936db3a10071c6bda" translate="yes" xml:space="preserve">
          <source>Probe that fires when a request for a heavyweight lock (lmgr lock) has finished waiting (i.e., has acquired the lock). The arguments are the same as for &lt;code&gt;lock-wait-start&lt;/code&gt;.</source>
          <target state="translated">对重量级锁（lmgr锁）的请求完成等待（即已获得锁）时将触发的探测器。参数与 &lt;code&gt;lock-wait-start&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="c611257e152cea80f6cfc845709b8d0de904351c" translate="yes" xml:space="preserve">
          <source>Probe that fires when a server process begins to write a dirty WAL buffer because no more WAL buffer space is available. (If this happens often, it implies that &lt;a href=&quot;runtime-config-wal#GUC-WAL-BUFFERS&quot;&gt;wal_buffers&lt;/a&gt; is too small.)</source>
          <target state="translated">由于没有更多的WAL缓冲区可用，服务器进程开始写入脏的WAL缓冲区时将触发的探测器。（如果这种情况经常发生，则表明&lt;a href=&quot;runtime-config-wal#GUC-WAL-BUFFERS&quot;&gt;wal_buffers&lt;/a&gt;太小。）</target>
        </trans-unit>
        <trans-unit id="f78264e8172fbf9d18964b5de63c4b5c50a37b93" translate="yes" xml:space="preserve">
          <source>Probe that fires when a server process begins to write a dirty buffer. (If this happens often, it implies that &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt; is too small or the background writer control parameters need adjustment.) arg0 and arg1 contain the fork and block numbers of the page. arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation.</source>
          <target state="translated">服务器进程开始写入脏缓冲区时将触发的探针。（如果这种情况经常发生，则意味着&lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;太小或需要后台编写器控制参数进行调整。）arg0和arg1包含页面的派生号和块号。arg2，arg3和arg4包含表空间，数据库和标识关系的关系OID。</target>
        </trans-unit>
        <trans-unit id="ab6028b90f757cbb259294d12f57f8c712860524" translate="yes" xml:space="preserve">
          <source>Probe that fires when a server process has been released from its wait for an LWLock (it does not actually have the lock yet). arg0 is the LWLock's tranche. arg1 is the requested lock mode, either exclusive or shared.</source>
          <target state="translated">arg0是LWLock的分档。 arg1是请求的锁模式,可以是独占的,也可以是共享的。</target>
        </trans-unit>
        <trans-unit id="327d56ed2b9d3f4cc36bd9b948fbb4da61129ae8" translate="yes" xml:space="preserve">
          <source>Probe that fires when a sort is complete. arg0 is true for external sort, false for internal sort. arg1 is the number of disk blocks used for an external sort, or kilobytes of memory used for an internal sort.</source>
          <target state="translated">arg0是外部排序的真值,内部排序的假值。 arg1是外部排序使用的磁盘块数,或者内部排序使用的内存千字节数。</target>
        </trans-unit>
        <trans-unit id="4a9847b929f87d2af0af81f9222c2554ede52eda" translate="yes" xml:space="preserve">
          <source>Probe that fires when a sort operation is started. arg0 indicates heap, index or datum sort. arg1 is true for unique-value enforcement. arg2 is the number of key columns. arg3 is the number of kilobytes of work memory allowed. arg4 is true if random access to the sort result is required. arg5 indicates serial when &lt;code&gt;0&lt;/code&gt;, parallel worker when &lt;code&gt;1&lt;/code&gt;, or parallel leader when &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">开始排序操作时将触发的探针。arg0指示堆，索引或基准排序。arg1对于唯一值强制实施为true。arg2是键列的数量。arg3是允许的工作内存的千字节数。如果需要随机访问排序结果，则arg4为true。arg5在 &lt;code&gt;0&lt;/code&gt; 时指示串行，在 &lt;code&gt;1&lt;/code&gt; 时指示并行工作程序，或在 &lt;code&gt;2&lt;/code&gt; 时指示并行引导程序。</target>
        </trans-unit>
        <trans-unit id="9a6c578cf9ebf6dafcb797b30e10c8c0ea10449f" translate="yes" xml:space="preserve">
          <source>Probe that fires when a transaction completes successfully. arg0 is the transaction ID.</source>
          <target state="translated">arg0是交易ID,当交易成功完成时触发的探针。</target>
        </trans-unit>
        <trans-unit id="4a8dcaad5632a5c029ca8a4cd70eeafe1ca847b1" translate="yes" xml:space="preserve">
          <source>Probe that fires when a transaction completes unsuccessfully. arg0 is the transaction ID.</source>
          <target state="translated">arg0是交易ID,当交易完成不成功时触发的探针。</target>
        </trans-unit>
        <trans-unit id="17050254a1180d83c2f09021018121a20c9a108c" translate="yes" xml:space="preserve">
          <source>Probe that fires when a write request is complete. (Note that this just reflects the time to pass the data to the kernel; it's typically not actually been written to disk yet.) The arguments are the same as for &lt;code&gt;buffer-flush-start&lt;/code&gt;.</source>
          <target state="translated">写请求完成后将触发的探针。（请注意，这仅反映了将数据传递到内核的时间；通常实际上还没有将其写入磁盘。）参数与 &lt;code&gt;buffer-flush-start&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="8e023e6af3bb6f75b33af22efff6aa6afa3fd941" translate="yes" xml:space="preserve">
          <source>Probe that fires when all dirty buffers have been written. arg0 is the total number of buffers. arg1 is the number of buffers actually written by the checkpoint process. arg2 is the number that were expected to be written (arg1 of &lt;code&gt;buffer-sync-start&lt;/code&gt;); any difference reflects other processes flushing buffers during the checkpoint.</source>
          <target state="translated">写入所有脏缓冲区后将触发的探测器。arg0是缓冲区的总数。arg1是检查点进程实际写入的缓冲区数。arg2是预期要写入的数字（ &lt;code&gt;buffer-sync-start&lt;/code&gt; 的 arg1 ）；任何差异都反映了检查点期间其他进程刷新缓冲区。</target>
        </trans-unit>
        <trans-unit id="466cfd0176351b56d635f32f0410727040245d40" translate="yes" xml:space="preserve">
          <source>Probe that fires when an LWLock has been acquired. arg0 is the LWLock's tranche. arg1 is the requested lock mode, either exclusive or shared.</source>
          <target state="translated">arg0是LWLock的档次。 arg1是要求的锁模式,可以是独占的,也可以是共享的。</target>
        </trans-unit>
        <trans-unit id="6121be81d01b11fd11854f3cc9d63c7a9a5f1cbf" translate="yes" xml:space="preserve">
          <source>Probe that fires when an LWLock has been released (but note that any released waiters have not yet been awakened). arg0 is the LWLock's tranche.</source>
          <target state="translated">当一个LWLock被释放时发射的探针(但注意任何被释放的等待者还没有被唤醒)。 arg0是LWLock的档次。</target>
        </trans-unit>
        <trans-unit id="eee4a231a6a278d84a4bf21d96cfbf0b033695e4" translate="yes" xml:space="preserve">
          <source>Probe that fires when an LWLock was not immediately available and a server process has begun to wait for the lock to become available. arg0 is the LWLock's tranche. arg1 is the requested lock mode, either exclusive or shared.</source>
          <target state="translated">arg0是LWLock的档位。 arg1是请求的锁模式,可以是独占的,也可以是共享的。</target>
        </trans-unit>
        <trans-unit id="32b5dee951d8d8bbcc4c527b18fd9921e80f05ea" translate="yes" xml:space="preserve">
          <source>Probe that fires when an LWLock was not successfully acquired when the caller specified no waiting. arg0 is the LWLock's tranche. arg1 is the requested lock mode, either exclusive or shared.</source>
          <target state="translated">arg0是LWLock的批次。 arg1是请求的锁模式,可以是独占的,也可以是共享的。</target>
        </trans-unit>
        <trans-unit id="29ccd443bca3bd38a197795375408911c2de33c3" translate="yes" xml:space="preserve">
          <source>Probe that fires when an LWLock was successfully acquired when the caller specified no waiting. arg0 is the LWLock's tranche. arg1 is the requested lock mode, either exclusive or shared.</source>
          <target state="translated">arg0是LWLock的批次。 arg1是请求的锁模式,可以是独占的,也可以是共享的,当呼叫者指定不等待时,LWLock被成功获取时触发的探针。</target>
        </trans-unit>
        <trans-unit id="9fe33e9001aca2852cd9dca52b36bdbecb7c1f32" translate="yes" xml:space="preserve">
          <source>Probe that fires when beginning to read a block from a relation. arg0 and arg1 contain the fork and block numbers of the page. arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation. arg5 is the ID of the backend which created the temporary relation for a local buffer, or &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1) for a shared buffer.</source>
          <target state="translated">开始从关系读取块时将触发的探针。arg0和arg1包含页面的派生号和块号。arg2，arg3和arg4包含表空间，数据库和标识关系的关系OID。arg5是为本地缓冲区创建临时关系的后端的ID，或为共享缓冲区创建的 &lt;code&gt;InvalidBackendId&lt;/code&gt; （-1）。</target>
        </trans-unit>
        <trans-unit id="d3f7e8aeab722a5eb71c03e5e72e466f6f7d683f" translate="yes" xml:space="preserve">
          <source>Probe that fires when beginning to write a block to a relation. arg0 and arg1 contain the fork and block numbers of the page. arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation. arg5 is the ID of the backend which created the temporary relation for a local buffer, or &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1) for a shared buffer.</source>
          <target state="translated">开始将块写入关系时将触发的探针。arg0和arg1包含页面的派生号和块号。arg2，arg3和arg4包含表空间，数据库和标识关系的关系OID。arg5是为本地缓冲区创建临时关系的后端的ID，或为共享缓冲区创建的 &lt;code&gt;InvalidBackendId&lt;/code&gt; （-1）。</target>
        </trans-unit>
        <trans-unit id="9cef86798a06a87b1e53005af8b7cffd9544c2ff" translate="yes" xml:space="preserve">
          <source>Probe that fires when syncing of buffers to disk is complete.</source>
          <target state="translated">当缓冲区与磁盘的同步完成时触发的探针。</target>
        </trans-unit>
        <trans-unit id="7e4496f8bfaa3cf215e7723d1b3f6a6a44062ac3" translate="yes" xml:space="preserve">
          <source>Probe that fires when the CLOG portion of a checkpoint is complete. arg0 has the same meaning as for &lt;code&gt;clog-checkpoint-start&lt;/code&gt;.</source>
          <target state="translated">检查点的CLOG部分完成时将触发的探针。arg0具有与 &lt;code&gt;clog-checkpoint-start&lt;/code&gt; 相同的含义。</target>
        </trans-unit>
        <trans-unit id="1ce40580bfe3cc60932d40bba9c3a62201a4d419" translate="yes" xml:space="preserve">
          <source>Probe that fires when the CLOG portion of a checkpoint is started. arg0 is true for normal checkpoint, false for shutdown checkpoint.</source>
          <target state="translated">arg0对正常检查点为真,对关闭检查点为假。</target>
        </trans-unit>
        <trans-unit id="f127e8e58e69f04b50616b0e221c7c59b7f1f3d1" translate="yes" xml:space="preserve">
          <source>Probe that fires when the MultiXact portion of a checkpoint is complete. arg0 has the same meaning as for &lt;code&gt;multixact-checkpoint-start&lt;/code&gt;.</source>
          <target state="translated">检查点的MultiXact部分完​​成后将触发的探针。arg0具有与 &lt;code&gt;multixact-checkpoint-start&lt;/code&gt; 相同的含义。</target>
        </trans-unit>
        <trans-unit id="7db7d3684151dd5b3ccf2213972ecca8de60eb5e" translate="yes" xml:space="preserve">
          <source>Probe that fires when the MultiXact portion of a checkpoint is started. arg0 is true for normal checkpoint, false for shutdown checkpoint.</source>
          <target state="translated">arg0对正常检查点为真,对关闭检查点为假。</target>
        </trans-unit>
        <trans-unit id="19d184e6d4448ad19f4409d088d396f7df8c32d3" translate="yes" xml:space="preserve">
          <source>Probe that fires when the SUBTRANS portion of a checkpoint is complete. arg0 has the same meaning as for &lt;code&gt;subtrans-checkpoint-start&lt;/code&gt;.</source>
          <target state="translated">当检查点的SUBTRANS部分完成时将触发的探针。arg0与 &lt;code&gt;subtrans-checkpoint-start&lt;/code&gt; 具有相同的含义。</target>
        </trans-unit>
        <trans-unit id="406309c24a9ce7d667e2ff79d8bf7268a9ff9831" translate="yes" xml:space="preserve">
          <source>Probe that fires when the SUBTRANS portion of a checkpoint is started. arg0 is true for normal checkpoint, false for shutdown checkpoint.</source>
          <target state="translated">arg0为正常检查点为真,关闭检查点为假。</target>
        </trans-unit>
        <trans-unit id="2d124d93cd049bd0371700c2959bdf0770b013e0" translate="yes" xml:space="preserve">
          <source>Probe that fires when the buffer-writing portion of a checkpoint is started. arg0 holds the bitwise flags used to distinguish different checkpoint types, such as shutdown, immediate or force.</source>
          <target state="translated">arg0持有用于区分不同检查点类型的位标志,如关闭、立即或强制。</target>
        </trans-unit>
        <trans-unit id="931b1ed777e93c094dcd52151780b666556374f1" translate="yes" xml:space="preserve">
          <source>Probe that fires when the execution of a query is complete.</source>
          <target state="translated">当一个查询执行完毕时,触发的探针。</target>
        </trans-unit>
        <trans-unit id="6643c1646d73651ecf6358eff359f77c5055c16d" translate="yes" xml:space="preserve">
          <source>Probe that fires when the execution of a query is started.</source>
          <target state="translated">当开始执行查询时触发的探针。</target>
        </trans-unit>
        <trans-unit id="0944a082320c7bc732281e77e7ca49f36f32c834" translate="yes" xml:space="preserve">
          <source>Probe that fires when the parsing of a query is complete. arg0 is the query string.</source>
          <target state="translated">arg0是查询字符串,当查询解析完成后触发的探针。</target>
        </trans-unit>
        <trans-unit id="d96fa9e5daed0c63d0c0481d8ca8ebbe0a261583" translate="yes" xml:space="preserve">
          <source>Probe that fires when the parsing of a query is started. arg0 is the query string.</source>
          <target state="translated">arg0是查询字符串,当开始解析查询时触发的探针。</target>
        </trans-unit>
        <trans-unit id="9452ef2f9dd8e46c1c62afe77724fc190b423661" translate="yes" xml:space="preserve">
          <source>Probe that fires when the planning of a query is complete.</source>
          <target state="translated">当一个查询的规划完成时,会触发的探针。</target>
        </trans-unit>
        <trans-unit id="a1d4370c7121e9a518ec9800f508633ae2640459" translate="yes" xml:space="preserve">
          <source>Probe that fires when the planning of a query is started.</source>
          <target state="translated">当一个查询的计划开始时触发的探针。</target>
        </trans-unit>
        <trans-unit id="96a4a695589b1af8e96af229876a85b1ac6a6721" translate="yes" xml:space="preserve">
          <source>Probe that fires when the processing of a query is complete. arg0 is the query string.</source>
          <target state="translated">arg0是查询字符串,当查询处理完成后触发的探针。</target>
        </trans-unit>
        <trans-unit id="17d08bdfb5f9889597cd8fad97751d8760642495" translate="yes" xml:space="preserve">
          <source>Probe that fires when the processing of a query is started. arg0 is the query string.</source>
          <target state="translated">arg0是查询字符串,当开始处理查询时触发的探针。</target>
        </trans-unit>
        <trans-unit id="eab217356aa735f20b49ab127f241495b6ade066" translate="yes" xml:space="preserve">
          <source>Probe that fires when the rewriting of a query is complete. arg0 is the query string.</source>
          <target state="translated">arg0是查询字符串,当重写查询完成后触发的探针。</target>
        </trans-unit>
        <trans-unit id="a428364242cf9691158e2fd27eee09f0cdf33ee9" translate="yes" xml:space="preserve">
          <source>Probe that fires when the rewriting of a query is started. arg0 is the query string.</source>
          <target state="translated">当开始重写查询时触发的探针。 arg0是查询字符串。</target>
        </trans-unit>
        <trans-unit id="21185778a7abdae335897b758940d7f751d2a6f0" translate="yes" xml:space="preserve">
          <source>Probe that fires when the two-phase portion of a checkpoint is complete.</source>
          <target state="translated">当检查点的两阶段部分完成时,发射的探针。</target>
        </trans-unit>
        <trans-unit id="0b37c215587e2b196fc6e3605c0952c5abaaeaa4" translate="yes" xml:space="preserve">
          <source>Probe that fires when the two-phase portion of a checkpoint is started.</source>
          <target state="translated">当一个检查点的两阶段部分开始时,触发的探针。</target>
        </trans-unit>
        <trans-unit id="64dbe1e4375ac3d8c100dcc3b4624e32ba635dcb" translate="yes" xml:space="preserve">
          <source>Probe that fires when we begin to write dirty buffers during checkpoint (after identifying which buffers must be written). arg0 is the total number of buffers. arg1 is the number that are currently dirty and need to be written.</source>
          <target state="translated">arg0是缓冲区的总数,arg1是当前需要写入的脏缓冲区的数量。</target>
        </trans-unit>
        <trans-unit id="0e17699a3879dd39ab092b19091e781ba0c3179a" translate="yes" xml:space="preserve">
          <source>Procedural Languages (server-side)</source>
          <target state="translated">程序语言(服务器端)</target>
        </trans-unit>
        <trans-unit id="d23b357b75ad2622370788956db89d9cceb43ba0" translate="yes" xml:space="preserve">
          <source>Procedural languages are local to individual databases. However, a language can be installed into the &lt;code&gt;template1&lt;/code&gt; database, which will cause it to be available automatically in all subsequently-created databases.</source>
          <target state="translated">过程语言是单个数据库的本地语言。但是，可以将一种语言安装到 &lt;code&gt;template1&lt;/code&gt; 数据库中，这将导致该语言在所有随后创建的数据库中自动可用。</target>
        </trans-unit>
        <trans-unit id="dc9339747734b918985c0542808ea173cf36ca7c" translate="yes" xml:space="preserve">
          <source>Procedure (routine)</source>
          <target state="translated">程序(常规)</target>
        </trans-unit>
        <trans-unit id="c80cc4229f5a9d3da6a7c3b6c8547ced65049640" translate="yes" xml:space="preserve">
          <source>Process ID</source>
          <target state="translated">流程ID</target>
        </trans-unit>
        <trans-unit id="be2c2eb824ea5b51d9b5bce07c9b40cd34577acf" translate="yes" xml:space="preserve">
          <source>Process ID of a WAL sender process</source>
          <target state="translated">WAL发送者进程的进程ID</target>
        </trans-unit>
        <trans-unit id="41767044d1edbdb5cf9f2dae1fdd49d59e940ebf" translate="yes" xml:space="preserve">
          <source>Process ID of a WAL sender process.</source>
          <target state="translated">WAL发送者进程的进程ID。</target>
        </trans-unit>
        <trans-unit id="af10df8d6082fa39f1e4f58ff138720439c3d068" translate="yes" xml:space="preserve">
          <source>Process ID of a backend</source>
          <target state="translated">后台的流程ID</target>
        </trans-unit>
        <trans-unit id="373864156198cbd9c04a34d7ab3e6735c02719d2" translate="yes" xml:space="preserve">
          <source>Process ID of a backend or WAL sender process</source>
          <target state="translated">后端或WAL发送方进程的进程ID。</target>
        </trans-unit>
        <trans-unit id="c5da887d9f68351aff22198bf3916a2bd05dd9d7" translate="yes" xml:space="preserve">
          <source>Process ID of backend.</source>
          <target state="translated">后台的流程ID。</target>
        </trans-unit>
        <trans-unit id="1aca36c0622a2538e27d8bf063d83ca00390c145" translate="yes" xml:space="preserve">
          <source>Process ID of the WAL receiver process</source>
          <target state="translated">WAL接收器进程的进程ID</target>
        </trans-unit>
        <trans-unit id="5d7d2e19d28ca6186fcc59c93b80889377f993f2" translate="yes" xml:space="preserve">
          <source>Process ID of the locker currently being waited for.</source>
          <target state="translated">当前正在等待的储物柜的进程ID。</target>
        </trans-unit>
        <trans-unit id="f0648fb422c9ce57f595e096435bf789668b2752" translate="yes" xml:space="preserve">
          <source>Process ID of the parallel group leader, if this process is a parallel query worker. &lt;code&gt;NULL&lt;/code&gt; if this process is a parallel group leader or does not participate in parallel query.</source>
          <target state="translated">并行组长的进程ID（如果此进程是并行查询工作程序）。如果此过程是并行组领导者或不参与并行查询，则为 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="01681ffc812bd9e058f3a6c5baf1409c4f0ba3bc" translate="yes" xml:space="preserve">
          <source>Process ID of the server process attached to the current session</source>
          <target state="translated">连接到当前会话的服务器进程的进程ID。</target>
        </trans-unit>
        <trans-unit id="af8e0118b6d9e8d86d67cf0400739aba8210dd2b" translate="yes" xml:space="preserve">
          <source>Process ID of the server process handling the current session</source>
          <target state="translated">处理当前会话的服务器进程的进程ID。</target>
        </trans-unit>
        <trans-unit id="03fbcc6f1367738e610a0cace02a8fd6438fb048" translate="yes" xml:space="preserve">
          <source>Process ID of the server process holding or awaiting this lock, or null if the lock is held by a prepared transaction</source>
          <target state="translated">持有或等待此锁的服务器进程的进程ID,如果锁是由准备好的事务持有,则为空。</target>
        </trans-unit>
        <trans-unit id="999d9e41cb5cf7f111cc6e19904f6e291da38b6e" translate="yes" xml:space="preserve">
          <source>Process ID of the subscription worker process</source>
          <target state="translated">订阅工作者进程的进程ID</target>
        </trans-unit>
        <trans-unit id="e1f52d5447d8eaecbf7bddfce74b35d1ffb039b9" translate="yes" xml:space="preserve">
          <source>Process ID of this backend</source>
          <target state="translated">该后台的流程ID</target>
        </trans-unit>
        <trans-unit id="d15b210cc1e134700f907b8b25d7b1043aa0ca7b" translate="yes" xml:space="preserve">
          <source>Process ID(s) that are blocking specified server process ID from acquiring a lock</source>
          <target state="translated">阻止指定服务器进程ID获取锁的进程ID。</target>
        </trans-unit>
        <trans-unit id="6f132a3ada7bb531c167b75bc5eeea4c4aebfc18" translate="yes" xml:space="preserve">
          <source>Process ID(s) that are blocking specified server process ID from acquiring a safe snapshot</source>
          <target state="translated">阻止指定服务器进程ID获取安全快照的进程ID。</target>
        </trans-unit>
        <trans-unit id="f9b1d2668cc983dbc740512036c3c2a0339f13e5" translate="yes" xml:space="preserve">
          <source>Process IDs of locking backends (more than one if multitransaction)</source>
          <target state="translated">锁定后台的进程ID(如果是多事务,则超过一个)。</target>
        </trans-unit>
        <trans-unit id="f966bc3f73e4a99fa5d7b7c8751d4573456fa586" translate="yes" xml:space="preserve">
          <source>Process Identifier</source>
          <target state="translated">流程标识符</target>
        </trans-unit>
        <trans-unit id="23fe74f2755c9dfea4c7fb3bc31b2e29d2cbcd59" translate="yes" xml:space="preserve">
          <source>Process header files. When this option is specified, the output file extension becomes &lt;code&gt;.h&lt;/code&gt; not &lt;code&gt;.c&lt;/code&gt;, and the default input file extension is &lt;code&gt;.pgh&lt;/code&gt; not &lt;code&gt;.pgc&lt;/code&gt;. Also, the &lt;code&gt;-c&lt;/code&gt; option is forced on.</source>
          <target state="translated">处理头文件。指定此选项时，输出文件扩展名为 &lt;code&gt;.h&lt;/code&gt; 而不是 &lt;code&gt;.c&lt;/code&gt; ，默认输入文件扩展名为 &lt;code&gt;.pgh&lt;/code&gt; 而不是 &lt;code&gt;.pgc&lt;/code&gt; 。另外， &lt;code&gt;-c&lt;/code&gt; 选项是强制打开的。</target>
        </trans-unit>
        <trans-unit id="d4a6aac2feb7c0acbdd36ece9c6b8ffa6edac4ab" translate="yes" xml:space="preserve">
          <source>Process of an &lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;instance&lt;/a&gt; which acts on behalf of a &lt;a href=&quot;glossary#GLOSSARY-SESSION&quot;&gt;client session&lt;/a&gt; and handles its requests.</source>
          <target state="translated">代表&lt;a href=&quot;glossary#GLOSSARY-SESSION&quot;&gt;客户端会话&lt;/a&gt;并处理其请求的&lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;实例的&lt;/a&gt;过程。</target>
        </trans-unit>
        <trans-unit id="9404f1b149e0fa2944f7fe7f5a9758a8f27d7f2a" translate="yes" xml:space="preserve">
          <source>Process start time stamp</source>
          <target state="translated">进程开始时间戳</target>
        </trans-unit>
        <trans-unit id="2fc3c183e1dc7c192411203ba9cdff758c852d48" translate="yes" xml:space="preserve">
          <source>Process within an &lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;instance&lt;/a&gt;, which runs system- or user-supplied code. Serves as infrastructure for several features in PostgreSQL, such as &lt;a href=&quot;glossary#GLOSSARY-REPLICATION&quot;&gt;logical replication&lt;/a&gt; and &lt;a href=&quot;glossary#GLOSSARY-PARALLEL-QUERY&quot;&gt;parallel queries&lt;/a&gt;. In addition, &lt;a href=&quot;glossary#GLOSSARY-EXTENSION&quot;&gt;Extensions&lt;/a&gt; can add custom background worker processes.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;实例中的&lt;/a&gt;进程，该实例运行系统或用户提供的代码。用作PostgreSQL中若干功能的基础结构，例如&lt;a href=&quot;glossary#GLOSSARY-REPLICATION&quot;&gt;逻辑复制&lt;/a&gt;和&lt;a href=&quot;glossary#GLOSSARY-PARALLEL-QUERY&quot;&gt;并行查询&lt;/a&gt;。此外，&lt;a href=&quot;glossary#GLOSSARY-EXTENSION&quot;&gt;扩展&lt;/a&gt;可以添加自定义后台工作进程。</target>
        </trans-unit>
        <trans-unit id="9b87f820c5635b5c920ad2cf5059d2207d8f59e5" translate="yes" xml:space="preserve">
          <source>Produce an error indicating that the deletion or update would create a foreign key constraint violation. If the constraint is deferred, this error will be produced at constraint check time if there still exist any referencing rows. This is the default action.</source>
          <target state="translated">产生一个错误,表明删除或更新会造成外键约束的违反。如果约束被推迟,那么如果仍然存在任何引用记录,那么在约束检查时将产生这个错误。这是默认的操作。</target>
        </trans-unit>
        <trans-unit id="19db911f45836f08f67324db7d1d1b7713f59b5d" translate="yes" xml:space="preserve">
          <source>Produce an error indicating that the deletion or update would create a foreign key constraint violation. This is the same as &lt;code&gt;NO ACTION&lt;/code&gt; except that the check is not deferrable.</source>
          <target state="translated">产生一个错误，指示删除或更新将导致违反外键约束。这与 &lt;code&gt;NO ACTION&lt;/code&gt; 相同，除了支票不可延期。</target>
        </trans-unit>
        <trans-unit id="595741604d266c8ba7ee063d34ab349a2aac4f77" translate="yes" xml:space="preserve">
          <source>Produces a &amp;ldquo;pivot table&amp;rdquo; containing row names plus &lt;code&gt;N&lt;/code&gt; value columns, where &lt;code&gt;N&lt;/code&gt; is determined by the row type specified in the calling query</source>
          <target state="translated">产生一个&amp;ldquo;数据透视表&amp;rdquo;，其中包含行名和 &lt;code&gt;N&lt;/code&gt; 个值列，其中 &lt;code&gt;N&lt;/code&gt; 由调用查询中指定的行类型确定</target>
        </trans-unit>
        <trans-unit id="d19d956161f313325e8c8fa1383c1d5dc4285689" translate="yes" xml:space="preserve">
          <source>Produces a &amp;ldquo;pivot table&amp;rdquo; containing row names plus &lt;code&gt;N&lt;/code&gt; value columns, where &lt;code&gt;N&lt;/code&gt; is determined by the row type specified in the calling query.</source>
          <target state="translated">生成一个包含数据行名称和 &lt;code&gt;N&lt;/code&gt; 个值列的&amp;ldquo;数据透视表&amp;rdquo; ，其中 &lt;code&gt;N&lt;/code&gt; 由调用查询中指定的行类型确定。</target>
        </trans-unit>
        <trans-unit id="3b7d934bad462d22e3d780a0512ef5f70c8fefe7" translate="yes" xml:space="preserve">
          <source>Produces a &amp;ldquo;pivot table&amp;rdquo; containing row names plus &lt;code&gt;N&lt;/code&gt; value columns. &lt;code&gt;crosstab2&lt;/code&gt;, &lt;code&gt;crosstab3&lt;/code&gt;, and &lt;code&gt;crosstab4&lt;/code&gt; are predefined, but you can create additional &lt;code&gt;crosstabN&lt;/code&gt; functions as described below</source>
          <target state="translated">产生一个&amp;ldquo;数据透视表&amp;rdquo;，其中包含行名和 &lt;code&gt;N&lt;/code&gt; 个值列。 &lt;code&gt;crosstab2&lt;/code&gt; ， &lt;code&gt;crosstab3&lt;/code&gt; 和 &lt;code&gt;crosstab4&lt;/code&gt; 是预定义的，但是您可以按如下所述创建其他 &lt;code&gt;crosstabN&lt;/code&gt; 函数</target>
        </trans-unit>
        <trans-unit id="6827b61996dcfecd3a6bdd8ecd7849189131e707" translate="yes" xml:space="preserve">
          <source>Produces a &amp;ldquo;pivot table&amp;rdquo; containing row names plus &lt;code&gt;N&lt;/code&gt; value columns. &lt;code&gt;crosstab2&lt;/code&gt;, &lt;code&gt;crosstab3&lt;/code&gt;, and &lt;code&gt;crosstab4&lt;/code&gt; are predefined, but you can create additional &lt;code&gt;crosstabN&lt;/code&gt; functions as described below.</source>
          <target state="translated">产生一个包含数据行名称和 &lt;code&gt;N&lt;/code&gt; 个值列的&amp;ldquo;数据透视表&amp;rdquo; 。 &lt;code&gt;crosstab2&lt;/code&gt; ， &lt;code&gt;crosstab3&lt;/code&gt; 和 &lt;code&gt;crosstab4&lt;/code&gt; 是预定义的，但是您可以如下所述创建其他 &lt;code&gt;crosstabN&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="953361f0fb07cbbdc30a8c3d39ada8d75e41aa1b" translate="yes" xml:space="preserve">
          <source>Produces a &amp;ldquo;pivot table&amp;rdquo; with the value columns specified by a second query</source>
          <target state="translated">产生具有第二个查询指定的值列的&amp;ldquo;数据透视表&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="2796ff43fdf0371172e3aca0613ef5e330539f10" translate="yes" xml:space="preserve">
          <source>Produces a &amp;ldquo;pivot table&amp;rdquo; with the value columns specified by a second query.</source>
          <target state="translated">生成具有第二个查询指定的值列的&amp;ldquo;数据透视表&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="eeb96fffad25790b78f8b2fd976762cd22e0262e" translate="yes" xml:space="preserve">
          <source>Produces a representation of a hierarchical tree structure</source>
          <target state="translated">生成分层树结构的表示方法。</target>
        </trans-unit>
        <trans-unit id="6073947dcba4d43cc98e457a1a526968941edbfc" translate="yes" xml:space="preserve">
          <source>Produces a representation of a hierarchical tree structure.</source>
          <target state="translated">生成一个层次树结构的表示。</target>
        </trans-unit>
        <trans-unit id="f1f50ebfc9183ee48a90532a8dbfb3653ac19c72" translate="yes" xml:space="preserve">
          <source>Produces a representation of the indexable portion of a &lt;code&gt;tsquery&lt;/code&gt;. A result that is empty or just &lt;code id=&quot;t&quot;&gt;T&lt;/code&gt; indicates a non-indexable query.</source>
          <target state="translated">产生 &lt;code&gt;tsquery&lt;/code&gt; 的可索引部分的表示。为空或仅 &lt;code id=&quot;t&quot;&gt;T&lt;/code&gt; 的结果表示不可索引的查询。</target>
        </trans-unit>
        <trans-unit id="d2cf09a7cb7a5d996def491486e555116c8e56fe" translate="yes" xml:space="preserve">
          <source>Produces a set of normally distributed random values</source>
          <target state="translated">产生一组正态分布的随机值</target>
        </trans-unit>
        <trans-unit id="315b9480dccd3ac225db648897293892f773f54e" translate="yes" xml:space="preserve">
          <source>Produces a set of normally distributed random values.</source>
          <target state="translated">产生一组正态分布的随机值。</target>
        </trans-unit>
        <trans-unit id="9b3d37859bb87e00841bf5b68801363110571121" translate="yes" xml:space="preserve">
          <source>Produces no output, but tells non-session processes to stop at this point in the string; ignored by session processes</source>
          <target state="translated">不产生任何输出,但告诉非会话进程在字符串的这一点上停止;被会话进程忽略。</target>
        </trans-unit>
        <trans-unit id="c4cc122a953a1ad9e9d147019c31d589653986fa" translate="yes" xml:space="preserve">
          <source>Produces the intersection of two cubes.</source>
          <target state="translated">产生两个立方体的交点。</target>
        </trans-unit>
        <trans-unit id="bc2b03c140585a107e123dbad9c7907236c487ae" translate="yes" xml:space="preserve">
          <source>Produces the union of two cubes.</source>
          <target state="translated">产生两个立方体的结合。</target>
        </trans-unit>
        <trans-unit id="3a873ea551f5b656a037c9a2775158084055a3fb" translate="yes" xml:space="preserve">
          <source>Programs using C code with embedded SQL have to be linked against the &lt;code&gt;libecpg&lt;/code&gt; library, for example using the linker options &lt;code&gt;-L/usr/local/pgsql/lib -lecpg&lt;/code&gt;.</source>
          <target state="translated">使用带有嵌入式SQL的C代码的程序必须针对 &lt;code&gt;libecpg&lt;/code&gt; 库进行链接，例如，使用链接器选项 &lt;code&gt;-L/usr/local/pgsql/lib -lecpg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="62babe4510e8d8a8ee8afda900ec73acd0a5dab6" translate="yes" xml:space="preserve">
          <source>Progress Reporting</source>
          <target state="translated">进展报告</target>
        </trans-unit>
        <trans-unit id="3d02226c16e2d7d25eeaba8bd347cdb833f33050" translate="yes" xml:space="preserve">
          <source>Promotes a physical standby server. With &lt;em&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/em&gt; set to &lt;code&gt;true&lt;/code&gt; (the default), the function waits until promotion is completed or &lt;em&gt;&lt;code&gt;wait_seconds&lt;/code&gt;&lt;/em&gt; seconds have passed, and returns &lt;code&gt;true&lt;/code&gt; if promotion is successful and &lt;code&gt;false&lt;/code&gt; otherwise. If &lt;em&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/em&gt; is set to &lt;code&gt;false&lt;/code&gt;, the function returns &lt;code&gt;true&lt;/code&gt; immediately after sending &lt;code&gt;SIGUSR1&lt;/code&gt; to the postmaster to trigger the promotion. This function is restricted to superusers by default, but other users can be granted EXECUTE to run the function.</source>
          <target state="translated">升级物理备用服务器。将&lt;em&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/em&gt;设置为 &lt;code&gt;true&lt;/code&gt; （默认值）后，该函数将等待直到升级完成或&lt;em&gt; &lt;code&gt;wait_seconds&lt;/code&gt; &lt;/em&gt;秒已过去，如果升级成功，则返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。如果&lt;em&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/em&gt;设置为 &lt;code&gt;false&lt;/code&gt; ，则该函数在将 &lt;code&gt;SIGUSR1&lt;/code&gt; 发送给邮政局长以触发升级后立即返回 &lt;code&gt;true&lt;/code&gt; 。默认情况下，此功能仅限于超级用户使用，但可以授予其他用户执行该功能的权限。</target>
        </trans-unit>
        <trans-unit id="377afe4fc3a70d640cc41e476917292a950a7519" translate="yes" xml:space="preserve">
          <source>Promotes a standby server to primary status. With &lt;em&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/em&gt; set to &lt;code&gt;true&lt;/code&gt; (the default), the function waits until promotion is completed or &lt;em&gt;&lt;code&gt;wait_seconds&lt;/code&gt;&lt;/em&gt; seconds have passed, and returns &lt;code&gt;true&lt;/code&gt; if promotion is successful and &lt;code&gt;false&lt;/code&gt; otherwise. If &lt;em&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/em&gt; is set to &lt;code&gt;false&lt;/code&gt;, the function returns &lt;code&gt;true&lt;/code&gt; immediately after sending a &lt;code&gt;SIGUSR1&lt;/code&gt; signal to the postmaster to trigger promotion.</source>
          <target state="translated">将备用服务器提升为主要状态。将&lt;em&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/em&gt;设置为 &lt;code&gt;true&lt;/code&gt; （默认值）时，该函数将等待，直到升级完成或&lt;em&gt; &lt;code&gt;wait_seconds&lt;/code&gt; &lt;/em&gt;秒已过去，如果升级成功，则返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。如果&lt;em&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/em&gt;设置为 &lt;code&gt;false&lt;/code&gt; ，则该函数在将 &lt;code&gt;SIGUSR1&lt;/code&gt; 信号发送到邮政局长以触发升级后立即返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="310745705e4b51911f7ad05e685132e85803b43c" translate="yes" xml:space="preserve">
          <source>Prompt for confirmation before actually removing the user, and prompt for the user name if none is specified on the command line.</source>
          <target state="translated">在实际删除用户之前提示确认,如果在命令行中没有指定用户名,则提示用户名称。</target>
        </trans-unit>
        <trans-unit id="a4139dbdd33b4ca75eb092bf7d5f911f9e520f3e" translate="yes" xml:space="preserve">
          <source>Prompt for the user name if none is specified on the command line, and also prompt for whichever of the options &lt;code&gt;-d&lt;/code&gt;/&lt;code&gt;-D&lt;/code&gt;, &lt;code&gt;-r&lt;/code&gt;/&lt;code&gt;-R&lt;/code&gt;, &lt;code&gt;-s&lt;/code&gt;/&lt;code&gt;-S&lt;/code&gt; is not specified on the command line. (This was the default behavior up to PostgreSQL 9.1.)</source>
          <target state="translated">如果在命令行上未指定用户名，则提示输入用户名，并且还提示未在命令行上指定选项 &lt;code&gt;-d&lt;/code&gt; / &lt;code&gt;-D&lt;/code&gt; ， &lt;code&gt;-r&lt;/code&gt; / &lt;code&gt;-R&lt;/code&gt; ， &lt;code&gt;-s&lt;/code&gt; / &lt;code&gt;-S&lt;/code&gt; 中的任何一个。（这是PostgreSQL 9.1之前的默认行为。）</target>
        </trans-unit>
        <trans-unit id="4d970e24b22fc0f6e277e6e1b9c10241b2293ff1" translate="yes" xml:space="preserve">
          <source>Prompting</source>
          <target state="translated">Prompting</target>
        </trans-unit>
        <trans-unit id="7b9401a5b590107a8b6c6f9423644051eff19629" translate="yes" xml:space="preserve">
          <source>Prompts can contain terminal control characters which, for example, change the color, background, or style of the prompt text, or change the title of the terminal window. In order for the line editing features of Readline to work properly, these non-printing control characters must be designated as invisible by surrounding them with &lt;code&gt;%[&lt;/code&gt; and &lt;code&gt;%]&lt;/code&gt;. Multiple pairs of these can occur within the prompt. For example:</source>
          <target state="translated">提示可以包含终端控制字符，例如，它们会更改提示文本的颜色，背景或样式，或更改终端窗口的标题。为了使Readline的行编辑功能正常工作，必须将这些非打印控制字符用 &lt;code&gt;%[&lt;/code&gt; 和 &lt;code&gt;%]&lt;/code&gt; 括起来以指定为不可见。提示中可以出现多对。例如：</target>
        </trans-unit>
        <trans-unit id="068e4f6fa6576b1f7eb180c4d966c9c332e88e9a" translate="yes" xml:space="preserve">
          <source>Prompts the user to supply text, which is assigned to the variable &lt;code&gt;name&lt;/code&gt;. An optional prompt string, &lt;code&gt;text&lt;/code&gt;, can be specified. (For multiword prompts, surround the text with single quotes.)</source>
          <target state="translated">提示用户提供文本，该文本已分配给变量 &lt;code&gt;name&lt;/code&gt; 。可以指定一个可选的提示字符串 &lt;code&gt;text&lt;/code&gt; 。（对于多字提示，请用单引号将文本引起来。）</target>
        </trans-unit>
        <trans-unit id="25a719c409be1921beafe5e788d439d93b07f5ff" translate="yes" xml:space="preserve">
          <source>Protocol head</source>
          <target state="translated">礼宾头</target>
        </trans-unit>
        <trans-unit id="1a9320a6ee345a64538cc41c73838b336f61862b" translate="yes" xml:space="preserve">
          <source>Protocol to use for submitting queries to the server:</source>
          <target state="translated">用于向服务器提交查询的协议。</target>
        </trans-unit>
        <trans-unit id="c1ac8c14d0bafdecefeefa05418d3e4bf8d46ea4" translate="yes" xml:space="preserve">
          <source>Provide an extension that will be stripped from all file names before deciding if they should be deleted. This is typically useful for cleaning up archives that have been compressed during storage, and therefore have had an extension added by the compression program. For example: &lt;code&gt;-x .gz&lt;/code&gt;.</source>
          <target state="translated">提供一个扩展名，该扩展名将从所有文件名中剥离，然后再决定是否应删除它们。这通常对于清理在存储过程中已压缩的存档很有用，因此压缩程序添加了扩展名。例如： &lt;code&gt;-x .gz&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5c7f8ac0c8dc8b2a3526acf0eb6df53ded419c3" translate="yes" xml:space="preserve">
          <source>Provide information about extensions of client certificate: extension name, extension value, and if it is a critical extension.</source>
          <target state="translated">提供客户证书的扩展信息:扩展名、扩展值、是否为关键扩展。</target>
        </trans-unit>
        <trans-unit id="7bc2350bc3b2039d9e0afed6b3606b6e8d63eb56" translate="yes" xml:space="preserve">
          <source>Provide the correct path to the database directory with &lt;code&gt;-D&lt;/code&gt;, or make sure that the environment variable &lt;code&gt;PGDATA&lt;/code&gt; is set. Also specify the name of the particular database you want to work in.</source>
          <target state="translated">使用 &lt;code&gt;-D&lt;/code&gt; 提供到数据库目录的正确路径，或者确保设置了环境变量 &lt;code&gt;PGDATA&lt;/code&gt; 。还指定您要使用的特定数据库的名称。</target>
        </trans-unit>
        <trans-unit id="7fba2085619c6e697d55f8299ef0ca805ea435a8" translate="yes" xml:space="preserve">
          <source>Provider of the collation: &lt;code&gt;d&lt;/code&gt; = database default, &lt;code&gt;c&lt;/code&gt; = libc, &lt;code&gt;i&lt;/code&gt; = icu</source>
          <target state="translated">整理程序的提供者： &lt;code&gt;d&lt;/code&gt; =数据库默认值， &lt;code&gt;c&lt;/code&gt; = libc， &lt;code&gt;i&lt;/code&gt; = icu</target>
        </trans-unit>
        <trans-unit id="b0a624c98e3417bfbf37f095267adcc37f1bdf46" translate="yes" xml:space="preserve">
          <source>Provider-specific version of the collation. This is recorded when the collation is created and then checked when it is used, to detect changes in the collation definition that could lead to data corruption.</source>
          <target state="translated">提供者特定的整理版本。这在创建整理时被记录下来,然后在使用时进行检查,以检测整理定义中可能导致数据损坏的变化。</target>
        </trans-unit>
        <trans-unit id="813380993db87b7b78063d3b522dabe042e0e038" translate="yes" xml:space="preserve">
          <source>Provides information implicitly requested by the user, e.g., output from &lt;code&gt;VACUUM VERBOSE&lt;/code&gt;.</source>
          <target state="translated">提供用户隐式请求的信息，例如 &lt;code&gt;VACUUM VERBOSE&lt;/code&gt; 的输出。</target>
        </trans-unit>
        <trans-unit id="de28296ee358cb5c7a7c1493346ff358cf83bc56" translate="yes" xml:space="preserve">
          <source>Provides information that might be helpful to users, e.g., notice of truncation of long identifiers.</source>
          <target state="translated">提供可能对用户有帮助的信息,如长标识符的截断通知。</target>
        </trans-unit>
        <trans-unit id="b544ef7e317c450388c8e22bbca337ffb169c783" translate="yes" xml:space="preserve">
          <source>Provides successively-more-detailed information for use by developers.</source>
          <target state="translated">提供更详细的信息,供开发人员使用。</target>
        </trans-unit>
        <trans-unit id="4085a3488b9b927970106c990aa79f6421cbdb9c" translate="yes" xml:space="preserve">
          <source>Provides warnings of likely problems, e.g., &lt;code&gt;COMMIT&lt;/code&gt; outside a transaction block.</source>
          <target state="translated">提供可能出现问题的警告，例如，在事务块外部的 &lt;code&gt;COMMIT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff659eeee4de0858f88b33fd3f4e7746d59a5ad2" translate="yes" xml:space="preserve">
          <source>Pseudo-Types</source>
          <target state="translated">Pseudo-Types</target>
        </trans-unit>
        <trans-unit id="4ece916bc1c6f84ddff998832df4ef0ea2024f0a" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: any</source>
          <target state="translated">伪类型:任何</target>
        </trans-unit>
        <trans-unit id="b47d9ee644ffb538aa98ee437eec99c988a8d15d" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: anyarray</source>
          <target state="translated">伪类型:anyarray</target>
        </trans-unit>
        <trans-unit id="54a7e454a263cbffc9189e0007bfd9b7424c0230" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: anycompatible</source>
          <target state="translated">伪类型:anycompatible。</target>
        </trans-unit>
        <trans-unit id="e1fcd8d0a37fb97a6ae1915b033c556308cf2f68" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: anycompatiblearray</source>
          <target state="translated">伪类型:anycompatiblearray。</target>
        </trans-unit>
        <trans-unit id="8e05bbac8a7e912d1c04921f6f4547ac37465d26" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: anycompatiblenonarray</source>
          <target state="translated">伪类型:anycompatiblenonarray。</target>
        </trans-unit>
        <trans-unit id="934be7c6aaed34ba9e8da8c91bad2e35901f6935" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: anycompatiblerange</source>
          <target state="translated">伪类型:anycompatiblerange。</target>
        </trans-unit>
        <trans-unit id="22e5a6f841dae2418964bcaa84aa6a0a7f245549" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: anyelement</source>
          <target state="translated">伪类型:Anyelement。</target>
        </trans-unit>
        <trans-unit id="7a3f6d920428a6c8e5967a26fb4e46758728f6a5" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: anyenum</source>
          <target state="translated">伪类型:Anyenum。</target>
        </trans-unit>
        <trans-unit id="84a873dc734548a1fe95e38fb333bb6d8bee10ef" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: anynonarray</source>
          <target state="translated">伪类型:Anynonarray。</target>
        </trans-unit>
        <trans-unit id="3f53e360e11fbb973d5b222308c28fd5706c50dd" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: anyrange</source>
          <target state="translated">伪类型:anyrange</target>
        </trans-unit>
        <trans-unit id="df7657db40732623a8894c06b0028cc7640273e5" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: cstring</source>
          <target state="translated">伪类型:cstring</target>
        </trans-unit>
        <trans-unit id="facd216b2d58500521e9c80e073f3f02e67f467b" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: event_trigger</source>
          <target state="translated">伪类型:event_trigger。</target>
        </trans-unit>
        <trans-unit id="0c5c3ab69652fb55ae765ca8240e7c3bf40db9ce" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: fdw_handler</source>
          <target state="translated">伪类型:fdw_handler。</target>
        </trans-unit>
        <trans-unit id="8d96c1feed021f0bd14872d446a70c55ec2a02e1" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: index_am_handler</source>
          <target state="translated">伪类型:index_am_handler。</target>
        </trans-unit>
        <trans-unit id="8be67788a823313be97039f4a4b82ee6108f4b0f" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: internal</source>
          <target state="translated">伪类型:内部</target>
        </trans-unit>
        <trans-unit id="c054109c5cb702aee10dbb32b0def25f56488525" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: language_handler</source>
          <target state="translated">伪类型:语言处理程序。</target>
        </trans-unit>
        <trans-unit id="20a35bc47475d7650010ce766369afc8aabfb683" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: opaque</source>
          <target state="translated">伪类型:不透明。</target>
        </trans-unit>
        <trans-unit id="3674c8f90a9e09b98f639dae572ceb4253fed389" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: pg_ddl_command</source>
          <target state="translated">伪类型:pg_ddl_command。</target>
        </trans-unit>
        <trans-unit id="c0325a47d21e05370cdf2a42ac118a73e10a48da" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: record</source>
          <target state="translated">伪类型:记录</target>
        </trans-unit>
        <trans-unit id="5724b565e2f347bb8125e3c1275c349af6b7742b" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: table_am_handler</source>
          <target state="translated">伪类型:table_am_handler。</target>
        </trans-unit>
        <trans-unit id="d51593e94e15db79bb52c20320be4240d42cc899" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: trigger</source>
          <target state="translated">伪类型:触发器</target>
        </trans-unit>
        <trans-unit id="4e60d0c02309d5445a01602a98db4ff91365738e" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: tsm_handler</source>
          <target state="translated">伪类型:tsm_handler</target>
        </trans-unit>
        <trans-unit id="17a7daa819e8dc7b6c6317f25efa7b50fffc1bab" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: unknown</source>
          <target state="translated">伪类型:未知</target>
        </trans-unit>
        <trans-unit id="ad3dfebd9fb48eb5727ce6fe6f50844a86efc6a5" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: void</source>
          <target state="translated">伪类型:void</target>
        </trans-unit>
        <trans-unit id="6c4dc2e4c074e37178229f858d4eb2dfaf30038f" translate="yes" xml:space="preserve">
          <source>Pseudo-types</source>
          <target state="translated">Pseudo-types</target>
        </trans-unit>
        <trans-unit id="cfb71764f58cd5ce25681b038025973a34e3322a" translate="yes" xml:space="preserve">
          <source>Pseudocode for a suitable &lt;code&gt;restore_command&lt;/code&gt; is:</source>
          <target state="translated">合适的 &lt;code&gt;restore_command&lt;/code&gt; 的伪代码为：</target>
        </trans-unit>
        <trans-unit id="88d402501992d3fecf47cb438f8e35c65835d25d" translate="yes" xml:space="preserve">
          <source>PuTTY</source>
          <target state="translated">PuTTY</target>
        </trans-unit>
        <trans-unit id="e00441c49bf6cb62a4a537860a47c6b85de694f6" translate="yes" xml:space="preserve">
          <source>Publication</source>
          <target state="translated">Publication</target>
        </trans-unit>
        <trans-unit id="1c3179d96f0fdc556230a1396cdf463d5208ef82" translate="yes" xml:space="preserve">
          <source>Publications are different from schemas and do not affect how the table is accessed. Each table can be added to multiple publications if needed. Publications may currently only contain tables. Objects must be added explicitly, except when a publication is created for &lt;code&gt;ALL TABLES&lt;/code&gt;.</source>
          <target state="translated">发布与架构不同，并且不影响表的访问方式。如果需要，可以将每个表添加到多个出版物中。出版物当前可能仅包含表。必须明确添加对象，除非为 &lt;code&gt;ALL TABLES&lt;/code&gt; 创建发布。</target>
        </trans-unit>
        <trans-unit id="58589c3756a9812c4f0f3e4873d1e342581ef4c0" translate="yes" xml:space="preserve">
          <source>Publications can choose to limit the changes they produce to any combination of &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, and &lt;code&gt;TRUNCATE&lt;/code&gt;, similar to how triggers are fired by particular event types. By default, all operation types are replicated.</source>
          <target state="translated">发布可以选择将它们产生的更改限制为 &lt;code&gt;INSERT&lt;/code&gt; ， &lt;code&gt;UPDATE&lt;/code&gt; ， &lt;code&gt;DELETE&lt;/code&gt; 和 &lt;code&gt;TRUNCATE&lt;/code&gt; 的任意组合，类似于特定事件类型如何触发触发器。默认情况下，将复制所有操作类型。</target>
        </trans-unit>
        <trans-unit id="a0fb821bdaf93ed9a1f1e920acfb2840eff5b153" translate="yes" xml:space="preserve">
          <source>Purpose</source>
          <target state="translated">Purpose</target>
        </trans-unit>
        <trans-unit id="18900d3584ded79ec60330adb7d33689eb4bab06" translate="yes" xml:space="preserve">
          <source>Put all query output into file &lt;code&gt;filename&lt;/code&gt;. This is equivalent to the command &lt;code&gt;\o&lt;/code&gt;.</source>
          <target state="translated">将所有查询输出放入文件 &lt;code&gt;filename&lt;/code&gt; 中。这等效于命令 &lt;code&gt;\o&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="877e59f50b56dd32ce7ae2762957d53396b6d9d9" translate="yes" xml:space="preserve">
          <source>Qualified joins</source>
          <target state="translated">合格的加盟</target>
        </trans-unit>
        <trans-unit id="3eb467853e78723a75783ad177cb3b81ed614c2e" translate="yes" xml:space="preserve">
          <source>Qualified names are tedious to write, and it's often best not to wire a particular schema name into applications anyway. Therefore tables are often referred to by &lt;em&gt;unqualified names&lt;/em&gt;, which consist of just the table name. The system determines which table is meant by following a &lt;em&gt;search path&lt;/em&gt;, which is a list of schemas to look in. The first matching table in the search path is taken to be the one wanted. If there is no match in the search path, an error is reported, even if matching table names exist in other schemas in the database.</source>
          <target state="translated">合格名称的编写很繁琐，而且通常最好不要将任何特定的架构名称连接到应用程序中。因此，表通常由&lt;em&gt;不合格的名称&lt;/em&gt;引用，该&lt;em&gt;名称&lt;/em&gt;仅由表名称组成。系统通过遵循&lt;em&gt;搜索路径&lt;/em&gt;（查找的模式列表）来确定要使用哪个表。将&lt;em&gt;搜索路径&lt;/em&gt;中的第一个匹配表视为所需的表。如果搜索路径中没有匹配项，即使数据库中其他模式中存在匹配的表名，也会报告错误。</target>
        </trans-unit>
        <trans-unit id="29bac22a5e177f5c85c1a4ee3241bc0678be6667" translate="yes" xml:space="preserve">
          <source>Quantifier</source>
          <target state="translated">Quantifier</target>
        </trans-unit>
        <trans-unit id="5370954c958801abba850882cd6534802d171dbc" translate="yes" xml:space="preserve">
          <source>Quantities of days, hours, minutes, and seconds can be specified without explicit unit markings. For example, &lt;code&gt;'1 12:59:10'&lt;/code&gt; is read the same as &lt;code&gt;'1 day 12 hours 59 min 10 sec'&lt;/code&gt;. Also, a combination of years and months can be specified with a dash; for example &lt;code&gt;'200-10'&lt;/code&gt; is read the same as &lt;code&gt;'200 years 10 months'&lt;/code&gt;. (These shorter forms are in fact the only ones allowed by the SQL standard, and are used for output when &lt;code&gt;IntervalStyle&lt;/code&gt; is set to &lt;code&gt;sql_standard&lt;/code&gt;.)</source>
          <target state="translated">可以指定天数，小时数，分钟数和秒数，而无需显式的单位标记。例如， &lt;code&gt;'1 12:59:10'&lt;/code&gt; 的读法与 &lt;code&gt;'1 day 12 hours 59 min 10 sec'&lt;/code&gt; 。同样，可以用破折号指定年份和月份的组合。例如， &lt;code&gt;'200-10'&lt;/code&gt; 的读法与 &lt;code&gt;'200 years 10 months'&lt;/code&gt; 读法相同。（这些较短的形式实际上是SQL标准所允许的唯一形式，并且在 &lt;code&gt;IntervalStyle&lt;/code&gt; 设置为 &lt;code&gt;sql_standard&lt;/code&gt; 时用于输出。）</target>
        </trans-unit>
        <trans-unit id="2644b7d942f174a4bbf0bc8675c1badf9352393e" translate="yes" xml:space="preserve">
          <source>Queries</source>
          <target state="translated">Queries</target>
        </trans-unit>
        <trans-unit id="a618b4be8d3ac72545f3085fe616d342b7139fba" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="translated">Query</target>
        </trans-unit>
        <trans-unit id="efa9d81fc99ae6041fbe49339a919ef99bac7ade" translate="yes" xml:space="preserve">
          <source>Query Planning</source>
          <target state="translated">查询规划</target>
        </trans-unit>
        <trans-unit id="b65f94596db8e112e4f92d4f1acdc4bb922a6268" translate="yes" xml:space="preserve">
          <source>Query access - &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;COPY TO&lt;/code&gt;</source>
          <target state="translated">查询访问- &lt;code&gt;SELECT&lt;/code&gt; ， &lt;code&gt;COPY TO&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b64c3246eb985e6edb480b51e216c4c9b501e9cb" translate="yes" xml:space="preserve">
          <source>Query access: &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;COPY TO&lt;/code&gt;</source>
          <target state="translated">查询访问： &lt;code&gt;SELECT&lt;/code&gt; ， &lt;code&gt;COPY TO&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cb0b645346d8b6276dfe9ec30dfc16f0625329b2" translate="yes" xml:space="preserve">
          <source>Query performance can be improved dramatically in certain situations, particularly when most of the heavily accessed rows of the table are in a single partition or a small number of partitions. The partitioning substitutes for leading columns of indexes, reducing index size and making it more likely that the heavily-used parts of the indexes fit in memory.</source>
          <target state="translated">在某些情况下,特别是当表的大部分访问量大的行都在一个分区或少量分区中时,查询性能可以得到极大的提高。分区代替了索引的前导列,减少了索引的大小,使索引中使用量大的部分更有可能在内存中容纳。</target>
        </trans-unit>
        <trans-unit id="1478c128e274ba1bf11d8cef131aa61f63dfccc5" translate="yes" xml:space="preserve">
          <source>Query planner</source>
          <target state="translated">查询计划器</target>
        </trans-unit>
        <trans-unit id="198d3f9fde17e740d63372e1985f338979a36a67" translate="yes" xml:space="preserve">
          <source>Query tree (in the form of a &lt;code&gt;nodeToString()&lt;/code&gt; representation) for the rule's action</source>
          <target state="translated">规则操作的查询树（以 &lt;code&gt;nodeToString()&lt;/code&gt; 表示形式）</target>
        </trans-unit>
        <trans-unit id="a6002c5c363574bc4fe16e6079b6e23f671de172" translate="yes" xml:space="preserve">
          <source>Querying this view is similar to using &lt;code&gt;SHOW ALL&lt;/code&gt; but provides more detail. It is also more flexible, since it's possible to specify filter conditions or join against other relations.</source>
          <target state="translated">查询此视图类似于使用 &lt;code&gt;SHOW ALL&lt;/code&gt; ,但提供更多详细信息。它也更加灵活，因为可以指定过滤条件或加入其他关系。</target>
        </trans-unit>
        <trans-unit id="33208d59d48811565117bf5ce172585c48018ea8" translate="yes" xml:space="preserve">
          <source>Quick Setup</source>
          <target state="translated">快速设置</target>
        </trans-unit>
        <trans-unit id="d17b23cd28367fcd27d5f878512b5e25587ec17b" translate="yes" xml:space="preserve">
          <source>Quits the psql program. In a script file, only execution of that script is terminated.</source>
          <target state="translated">退出psql程序。在脚本文件中,只有该脚本的执行才会终止。</target>
        </trans-unit>
        <trans-unit id="472cc72a1798e7f5b5bbceeb0bca7885d9d12809" translate="yes" xml:space="preserve">
          <source>Quoted identifiers can contain any character, except the character with code zero. (To include a double quote, write two double quotes.) This allows constructing table or column names that would otherwise not be possible, such as ones containing spaces or ampersands. The length limitation still applies.</source>
          <target state="translated">引号标识符可以包含任何字符,但代码为零的字符除外。(要包含双引号,请写两个双引号。)这就允许构造表名或列名,否则就不可能,例如包含空格或安培的表名或列名。长度限制仍然适用。</target>
        </trans-unit>
        <trans-unit id="9a777f2b79b97851a7b855a9429a5ebde18f036d" translate="yes" xml:space="preserve">
          <source>Quoting an identifier also makes it case-sensitive, whereas unquoted names are always folded to lower case. For example, the identifiers &lt;code&gt;FOO&lt;/code&gt;, &lt;code&gt;foo&lt;/code&gt;, and &lt;code&gt;&quot;foo&quot;&lt;/code&gt; are considered the same by PostgreSQL, but &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; and &lt;code&gt;&quot;FOO&quot;&lt;/code&gt; are different from these three and each other. (The folding of unquoted names to lower case in PostgreSQL is incompatible with the SQL standard, which says that unquoted names should be folded to upper case. Thus, &lt;code&gt;foo&lt;/code&gt; should be equivalent to &lt;code&gt;&quot;FOO&quot;&lt;/code&gt; not &lt;code&gt;&quot;foo&quot;&lt;/code&gt; according to the standard. If you want to write portable applications you are advised to always quote a particular name or never quote it.)</source>
          <target state="translated">引用标识符也使其区分大小写，而未引用的名称总是折叠为小写。例如，PostgreSQL认为标识符 &lt;code&gt;FOO&lt;/code&gt; ， &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 相同，但是 &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;FOO&quot;&lt;/code&gt; 彼此不同。 （在PostgreSQL中将未加引号的名称折叠成小写是与SQL标准不兼容的，SQL标准说，未加引号的名称应该被折叠成大写。因此，根据标准， &lt;code&gt;foo&lt;/code&gt; 应该等于 &lt;code&gt;&quot;FOO&quot;&lt;/code&gt; 而不是 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 。如果您想编写可移植的应用程序，建议您始终使用特定名称，也不要使用任何特定名称。）</target>
        </trans-unit>
        <trans-unit id="115088ecccb3000708edba51535672720b3a9ec6" translate="yes" xml:space="preserve">
          <source>Quoting rules for lexemes are the same as described previously for lexemes in &lt;code&gt;tsvector&lt;/code&gt;; and, as with &lt;code&gt;tsvector&lt;/code&gt;, any required normalization of words must be done before converting to the &lt;code&gt;tsquery&lt;/code&gt; type. The &lt;code&gt;to_tsquery&lt;/code&gt; function is convenient for performing such normalization:</source>
          <target state="translated">词素的报价规则与先前在 &lt;code&gt;tsvector&lt;/code&gt; 中对词素的描述相同; 并且，与 &lt;code&gt;tsvector&lt;/code&gt; 一样，在转换为 &lt;code&gt;tsquery&lt;/code&gt; 类型之前，必须先完成所有必要的单词标准化操作。该 &lt;code&gt;to_tsquery&lt;/code&gt; 功能是方便用于执行这种归一化：</target>
        </trans-unit>
        <trans-unit id="b79583615e1227273c81a5db2662b19ad81511a9" translate="yes" xml:space="preserve">
          <source>RADIUS Authentication</source>
          <target state="translated">RADIUS认证</target>
        </trans-unit>
        <trans-unit id="a954f117477515ead533688d7e4ca8e606782c1a" translate="yes" xml:space="preserve">
          <source>RAM which is used by the processes common to an &lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;instance&lt;/a&gt;. It mirrors parts of &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; files, provides a transient area for &lt;a href=&quot;glossary#GLOSSARY-WAL-RECORD&quot;&gt;WAL records&lt;/a&gt;, and stores additional common information. Note that shared memory belongs to the complete instance, not to a single database.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;实例&lt;/a&gt;共有的进程使用的RAM 。它镜像&lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;数据库&lt;/a&gt;文件的一部分，为&lt;a href=&quot;glossary#GLOSSARY-WAL-RECORD&quot;&gt;WAL记录&lt;/a&gt;提供一个临时区域，并存储其他公共信息。请注意，共享内存属于完整实例，而不是单个数据库。</target>
        </trans-unit>
        <trans-unit id="7edcf4d8bc4d16588d07b8848c85c166b827fdc9" translate="yes" xml:space="preserve">
          <source>RD-Tree for one-dimensional array of int4 values</source>
          <target state="translated">一维int4值数组的RD树。</target>
        </trans-unit>
        <trans-unit id="ff426c74c79867f7bf13e61c4f68d776339590f2" translate="yes" xml:space="preserve">
          <source>RDBMS</source>
          <target state="translated">RDBMS</target>
        </trans-unit>
        <trans-unit id="633fabe87d723214b65f1db2d624431f04c32334" translate="yes" xml:space="preserve">
          <source>REASSIGN OWNED</source>
          <target state="translated">重新分配拥有的</target>
        </trans-unit>
        <trans-unit id="7b6e0d55ca8c5d1c174cbdd39c8e88014cc1d924" translate="yes" xml:space="preserve">
          <source>REASSIGN OWNED &amp;mdash; change the ownership of database objects owned by a database role</source>
          <target state="translated">REASSIGN OWNED-更改数据库角色拥有的数据库对象的所有权</target>
        </trans-unit>
        <trans-unit id="d9cbb3a44e5994b48186107b069ebdee3f1ded8c" translate="yes" xml:space="preserve">
          <source>REFRESH MATERIALIZED VIEW</source>
          <target state="translated">重温材料化视图</target>
        </trans-unit>
        <trans-unit id="044770dd01baff51d49560ba1c3262f9b7a5e296" translate="yes" xml:space="preserve">
          <source>REFRESH MATERIALIZED VIEW &amp;mdash; replace the contents of a materialized view</source>
          <target state="translated">刷新材料视图&amp;mdash;替换实例化视图的内容</target>
        </trans-unit>
        <trans-unit id="5345e769e7d2d5a04080b106526b4188c28b2947" translate="yes" xml:space="preserve">
          <source>REINDEX</source>
          <target state="translated">REINDEX</target>
        </trans-unit>
        <trans-unit id="d68887fcf8498472cf8183721de3d160d3d8a3bb" translate="yes" xml:space="preserve">
          <source>REINDEX &amp;mdash; rebuild indexes</source>
          <target state="translated">REINDEX &amp;mdash;重建索引</target>
        </trans-unit>
        <trans-unit id="bec39b2581dc86d96ef7eb4b59715b2db9fb5b98" translate="yes" xml:space="preserve">
          <source>RELEASE SAVEPOINT</source>
          <target state="translated">释放保存点(RELEASE SAVEPOINT)</target>
        </trans-unit>
        <trans-unit id="d33a2b2590d58d2a81b75053789ac9fe4aed380a" translate="yes" xml:space="preserve">
          <source>RELEASE SAVEPOINT &amp;mdash; destroy a previously defined savepoint</source>
          <target state="translated">释放保存点&amp;mdash;销毁先前定义的保存点</target>
        </trans-unit>
        <trans-unit id="995f2d9ddfbe7ab63a2a7ddd59856b61ae272710" translate="yes" xml:space="preserve">
          <source>RESET</source>
          <target state="translated">RESET</target>
        </trans-unit>
        <trans-unit id="c157890fb1f2fab533caebe2d7bbafd037ee3504" translate="yes" xml:space="preserve">
          <source>RESET &amp;mdash; restore the value of a run-time parameter to the default value</source>
          <target state="translated">RESET &amp;mdash;将运行时参数的值恢复为默认值</target>
        </trans-unit>
        <trans-unit id="d173eb30e8b9fe61478a02d722cdc111a632ca90" translate="yes" xml:space="preserve">
          <source>REVOKE</source>
          <target state="translated">REVOKE</target>
        </trans-unit>
        <trans-unit id="6d5e97f2b0b3bc9eba1622d19f4c033f547d2f10" translate="yes" xml:space="preserve">
          <source>REVOKE &amp;mdash; remove access privileges</source>
          <target state="translated">撤消&amp;mdash;删除访问权限</target>
        </trans-unit>
        <trans-unit id="285e88316b0d14455ae0c18a656f7e4c2153f4a5" translate="yes" xml:space="preserve">
          <source>RFC</source>
          <target state="translated">RFC</target>
        </trans-unit>
        <trans-unit id="709f9208ad6c95b7efb1b7aea432fe35dfaffef8" translate="yes" xml:space="preserve">
          <source>RFC 3629</source>
          <target state="translated">RFC 3629</target>
        </trans-unit>
        <trans-unit id="bf1bf54df970aa71d56934027fc34edd568d7730" translate="yes" xml:space="preserve">
          <source>RFC 7159 permits JSON strings to contain Unicode escape sequences denoted by &lt;code&gt;\uXXXX&lt;/code&gt;. In the input function for the &lt;code&gt;json&lt;/code&gt; type, Unicode escapes are allowed regardless of the database encoding, and are checked only for syntactic correctness (that is, that four hex digits follow &lt;code&gt;\u&lt;/code&gt;). However, the input function for &lt;code&gt;jsonb&lt;/code&gt; is stricter: it disallows Unicode escapes for characters that cannot be represented in the database encoding. The &lt;code&gt;jsonb&lt;/code&gt; type also rejects &lt;code&gt;\u0000&lt;/code&gt; (because that cannot be represented in PostgreSQL's &lt;code&gt;text&lt;/code&gt; type), and it insists that any use of Unicode surrogate pairs to designate characters outside the Unicode Basic Multilingual Plane be correct. Valid Unicode escapes are converted to the equivalent single character for storage; this includes folding surrogate pairs into a single character.</source>
          <target state="translated">RFC 7159允许JSON字符串包含 &lt;code&gt;\uXXXX&lt;/code&gt; 表示的Unicode转义序列。在 &lt;code&gt;json&lt;/code&gt; 类型的输入函数中，无论数据库编码如何，均允许Unicode转义，并且仅对语法正确性进行检查（即，四个十六进制数字紧跟 &lt;code&gt;\u&lt;/code&gt; ）。但是， &lt;code&gt;jsonb&lt;/code&gt; 的输入函数更为严格：对于数据库编码中无法表示的字符，它不允许Unicode转义。该 &lt;code&gt;jsonb&lt;/code&gt; 类型也拒绝 &lt;code&gt;\u0000&lt;/code&gt; （因为不能在PostgreSQL的表示 &lt;code&gt;text&lt;/code&gt; 类型），并坚持使用Unicode代理对来指定Unicode Basic Multilingual Plane之外的字符都是正确的。有效的Unicode转义会转换为等效的单个字符进行存储；这包括将代理对折叠为单个字符。</target>
        </trans-unit>
        <trans-unit id="2e9a9191aa9d2f384e00599efbf540e0c6906e72" translate="yes" xml:space="preserve">
          <source>RFC 7159 permits JSON strings to contain Unicode escape sequences denoted by &lt;code&gt;\uXXXX&lt;/code&gt;. In the input function for the &lt;code&gt;json&lt;/code&gt; type, Unicode escapes are allowed regardless of the database encoding, and are checked only for syntactic correctness (that is, that four hex digits follow &lt;code&gt;\u&lt;/code&gt;). However, the input function for &lt;code&gt;jsonb&lt;/code&gt; is stricter: it disallows Unicode escapes for non-ASCII characters (those above &lt;code&gt;U+007F&lt;/code&gt;) unless the database encoding is UTF8. The &lt;code&gt;jsonb&lt;/code&gt; type also rejects &lt;code&gt;\u0000&lt;/code&gt; (because that cannot be represented in PostgreSQL's &lt;code&gt;text&lt;/code&gt; type), and it insists that any use of Unicode surrogate pairs to designate characters outside the Unicode Basic Multilingual Plane be correct. Valid Unicode escapes are converted to the equivalent ASCII or UTF8 character for storage; this includes folding surrogate pairs into a single character.</source>
          <target state="translated">RFC 7159允许JSON字符串包含 &lt;code&gt;\uXXXX&lt;/code&gt; 表示的Unicode转义序列。在 &lt;code&gt;json&lt;/code&gt; 类型的输入函数中，无论数据库编码如何，均允许Unicode转义，并且仅对语法正确性进行检查（即，四个十六进制数字紧跟 &lt;code&gt;\u&lt;/code&gt; ）。但是， &lt;code&gt;jsonb&lt;/code&gt; 的输入函数更为严格：除非数据库编码为UTF8，否则它不允许非ASCII字符（ &lt;code&gt;U+007F&lt;/code&gt; 以上的字符）使用Unicode转义。该 &lt;code&gt;jsonb&lt;/code&gt; 类型也拒绝 &lt;code&gt;\u0000&lt;/code&gt; （因为不能在PostgreSQL的表示 &lt;code&gt;text&lt;/code&gt; 类型），并坚持使用Unicode代理对来指定Unicode Basic Multilingual Plane之外的字符都是正确的。有效的Unicode转义会转换为等效的ASCII或UTF8字符进行存储；这包括将代理对折叠为单个字符。</target>
        </trans-unit>
        <trans-unit id="f7efe490a5991ad892dcbf815cf18cb496f3a528" translate="yes" xml:space="preserve">
          <source>RFC 7159 specifies that JSON strings should be encoded in UTF8. It is therefore not possible for the JSON types to conform rigidly to the JSON specification unless the database encoding is UTF8. Attempts to directly include characters that cannot be represented in the database encoding will fail; conversely, characters that can be represented in the database encoding but not in UTF8 will be allowed.</source>
          <target state="translated">RFC 7159规定JSON字符串应以UTF8编码。因此,除非数据库编码是UTF8,否则JSON类型不可能严格遵守JSON规范。试图直接包含数据库编码无法表示的字符将失败;反之,数据库编码可以表示但不是UTF8的字符将被允许。</target>
        </trans-unit>
        <trans-unit id="2ce42e824f2163751d62c49d3226c338efa1179d" translate="yes" xml:space="preserve">
          <source>ROLLBACK</source>
          <target state="translated">ROLLBACK</target>
        </trans-unit>
        <trans-unit id="59a24d752da80d40b19238fcc5ec55b82fdc443e" translate="yes" xml:space="preserve">
          <source>ROLLBACK &amp;mdash; abort the current transaction</source>
          <target state="translated">ROLLBACK-中止当前事务</target>
        </trans-unit>
        <trans-unit id="e90e1449c7ef5b8820b08718a11f2da71c8d13be" translate="yes" xml:space="preserve">
          <source>ROLLBACK PREPARED</source>
          <target state="translated">滾軸準備</target>
        </trans-unit>
        <trans-unit id="48a2a83386a59b9b2fdad5e2cd3606242846748b" translate="yes" xml:space="preserve">
          <source>ROLLBACK PREPARED &amp;mdash; cancel a transaction that was earlier prepared for two-phase commit</source>
          <target state="translated">ROLLBACK PREPARED &amp;mdash;取消先前为两阶段提交准备的事务</target>
        </trans-unit>
        <trans-unit id="61b9b7603e40508bc503ee4691737e409606fd90" translate="yes" xml:space="preserve">
          <source>ROLLBACK TO SAVEPOINT</source>
          <target state="translated">返回到保存点。</target>
        </trans-unit>
        <trans-unit id="d35ebfad8fd6f928fec74d3875a90f0020c24317" translate="yes" xml:space="preserve">
          <source>ROLLBACK TO SAVEPOINT &amp;mdash; roll back to a savepoint</source>
          <target state="translated">回滚到保存点&amp;mdash;回滚到保存点</target>
        </trans-unit>
        <trans-unit id="5a8f649047eb74a2e378d2089854762723ab49ef" translate="yes" xml:space="preserve">
          <source>ROW EXCLUSIVE</source>
          <target state="translated">ROW EXCLUSIVE</target>
        </trans-unit>
        <trans-unit id="14cb7a6b49bc39b1cc0a49d9f930265fc065d308" translate="yes" xml:space="preserve">
          <source>ROW SHARE</source>
          <target state="translated">行数分享</target>
        </trans-unit>
        <trans-unit id="498fa9be2d32c469ac4cde84af98396f043472d9" translate="yes" xml:space="preserve">
          <source>Random access to mechanical disk storage is normally much more expensive than four times sequential access. However, a lower default is used (4.0) because the majority of random accesses to disk, such as indexed reads, are assumed to be in cache. The default value can be thought of as modeling random access as 40 times slower than sequential, while expecting 90% of random reads to be cached.</source>
          <target state="translated">机械磁盘存储的随机访问通常比顺序访问的四倍要贵得多。但是,使用了一个较低的默认值(4.0),因为大多数对磁盘的随机访问,如索引读取,被假定为在缓存中。默认值可以被认为是将随机访问建模为比顺序访问慢40倍,同时期望90%的随机读取被缓存。</target>
        </trans-unit>
        <trans-unit id="a16c5bbe4bf996740f257aa1e81bd57e4c52c8dd" translate="yes" xml:space="preserve">
          <source>Range</source>
          <target state="translated">Range</target>
        </trans-unit>
        <trans-unit id="a12932077f1a02e9d49ac217bf48adda8287e429" translate="yes" xml:space="preserve">
          <source>Range Partitioning</source>
          <target state="translated">范围分区</target>
        </trans-unit>
        <trans-unit id="150371fe63779db9b501fedeeefe579700f1d7d0" translate="yes" xml:space="preserve">
          <source>Range Types</source>
          <target state="translated">范围类型</target>
        </trans-unit>
        <trans-unit id="53d929e1fb8ce766a0948419773ae86cbb9a3971" translate="yes" xml:space="preserve">
          <source>Range Types: daterange</source>
          <target state="translated">范围类型:数据范围</target>
        </trans-unit>
        <trans-unit id="a3693b9f49e1d1bce857f56deb98c373c7aef619" translate="yes" xml:space="preserve">
          <source>Range Types: int4range</source>
          <target state="translated">范围类型:int4range</target>
        </trans-unit>
        <trans-unit id="8a82ac3da25ee609b2aeb0f2103e7ae7eeded8ea" translate="yes" xml:space="preserve">
          <source>Range Types: int8range</source>
          <target state="translated">范围类型:int8range</target>
        </trans-unit>
        <trans-unit id="744cc477872918910432194727cf36fb5632f253" translate="yes" xml:space="preserve">
          <source>Range Types: numrange</source>
          <target state="translated">范围类型:numrange</target>
        </trans-unit>
        <trans-unit id="f03184b38e676b9e59d518680c29ef81d475b159" translate="yes" xml:space="preserve">
          <source>Range Types: tsrange</source>
          <target state="translated">范围类型:tsrange</target>
        </trans-unit>
        <trans-unit id="010e27d6ddc0ef1f60c30945a5ab60be84e20b61" translate="yes" xml:space="preserve">
          <source>Range Types: tstzrange</source>
          <target state="translated">范围类型:tstzrange</target>
        </trans-unit>
        <trans-unit id="19eccf536154da069167603ea475b5f422e59b33" translate="yes" xml:space="preserve">
          <source>Range and list partitioning require a btree operator class, while hash partitioning requires a hash operator class. If no operator class is specified explicitly, the default operator class of the appropriate type will be used; if no default operator class exists, an error will be raised. When hash partitioning is used, the operator class used must implement support function 2 (see &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-SUPPORT&quot;&gt;Section 37.16.3&lt;/a&gt; for details).</source>
          <target state="translated">范围和列表分区需要btree运算符类，而哈希分区需要哈希运算符类。如果未明确指定运算符类别，则将使用适当类型的默认运算符类别；否则，将使用默认运算符类别。如果不存在默认的运算符类，将引发错误。当使用散列分区时，使用的运算符类必须实现支持功能2（有关详细信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-SUPPORT&quot;&gt;37.16.3节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8895dad393fa948899c08b946bd0ebf4934f19ea" translate="yes" xml:space="preserve">
          <source>Range and list partitioning require a btree operator class, while hash partitioning requires a hash operator class. If no operator class is specified explicitly, the default operator class of the appropriate type will be used; if no default operator class exists, an error will be raised. When hash partitioning is used, the operator class used must implement support function 2 (see &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-SUPPORT&quot;&gt;Section 37.16.3&lt;/a&gt; for details).</source>
          <target state="translated">范围和列表分区需要btree运算符类，而哈希分区需要哈希运算符类。如果未明确指定运算符类别，则将使用适当类型的默认运算符类别；否则，将使用默认运算符类别。如果不存在默认的运算符类，将引发错误。当使用散列分区时，使用的运算符类必须实现支持功能2（有关详细信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-SUPPORT&quot;&gt;37.16.3节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="48652fff66c0aa4370d5c8fba0d573037de8ea3f" translate="yes" xml:space="preserve">
          <source>Range types</source>
          <target state="translated">范围类型</target>
        </trans-unit>
        <trans-unit id="152d9f920b5a18dd2e34c468823a545e1a1c8d0c" translate="yes" xml:space="preserve">
          <source>Range types are data types representing a range of values of some element type (called the range's &lt;em&gt;subtype&lt;/em&gt;). For instance, ranges of &lt;code&gt;timestamp&lt;/code&gt; might be used to represent the ranges of time that a meeting room is reserved. In this case the data type is &lt;code&gt;tsrange&lt;/code&gt; (short for &amp;ldquo;timestamp range&amp;rdquo;), and &lt;code&gt;timestamp&lt;/code&gt; is the subtype. The subtype must have a total order so that it is well-defined whether element values are within, before, or after a range of values.</source>
          <target state="translated">范围类型是表示某种元素类型（称为范围的&lt;em&gt;子类型&lt;/em&gt;）的值范围的数据&lt;em&gt;类型&lt;/em&gt;。例如， &lt;code&gt;timestamp&lt;/code&gt; 范围可用于表示保留会议室的时间范围。在这种情况下，数据类型为 &lt;code&gt;tsrange&lt;/code&gt; （&amp;ldquo;时间戳范围&amp;rdquo;的缩写）， &lt;code&gt;timestamp&lt;/code&gt; 是子类型。子类型必须具有总顺序，以便可以很好地定义元素值是在值范围之内，之前还是之后。</target>
        </trans-unit>
        <trans-unit id="10501cb18e09508ff10076b64f0cc428df172882" translate="yes" xml:space="preserve">
          <source>Range types are useful because they represent many element values in a single range value, and because concepts such as overlapping ranges can be expressed clearly. The use of time and date ranges for scheduling purposes is the clearest example; but price ranges, measurement ranges from an instrument, and so forth can also be useful.</source>
          <target state="translated">范围类型是有用的,因为它们在一个单一的范围值中代表了许多元素值,而且可以清楚地表达重叠范围等概念。时间和日期范围的使用是最明显的例子;但价格范围、仪器的测量范围等也是有用的。</target>
        </trans-unit>
        <trans-unit id="e16fe42dfe025a7c0b1d71163b5e1f4ac592f248" translate="yes" xml:space="preserve">
          <source>Range: &amp;#x27;[2011-01-01,2011-03-01)&amp;#x27;::tsrange @&amp;gt; &amp;#x27;2011-01-10&amp;#x27;::timestamp</source>
          <target state="translated">范围：'[2011-01-01,2011-03-01）':: tsrange @&amp;gt;'2011-01-10':: timestamp</target>
        </trans-unit>
        <trans-unit id="a9a5ac13ea7278862eadf429fec1a6d53e07ac45" translate="yes" xml:space="preserve">
          <source>Range: &amp;amp;&amp;amp;</source>
          <target state="translated">范围： ＆＆</target>
        </trans-unit>
        <trans-unit id="5138aeeb99cbf6ebff075b87fadb3ac93d6e5193" translate="yes" xml:space="preserve">
          <source>Range: &amp;amp;&amp;gt;</source>
          <target state="translated">范围：＆&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d72ae278ac597396584e8c02a1741c100edfca80" translate="yes" xml:space="preserve">
          <source>Range: &amp;amp;&amp;lt;</source>
          <target state="translated">范围：＆&amp;lt;</target>
        </trans-unit>
        <trans-unit id="e3887b799dded8092c6301d5be1aefa3d0dd6d3a" translate="yes" xml:space="preserve">
          <source>Range: &amp;gt;</source>
          <target state="translated">范围：&amp;gt;</target>
        </trans-unit>
        <trans-unit id="798e0e9e88e4e32e73dc02d11defb73693566666" translate="yes" xml:space="preserve">
          <source>Range: &amp;gt;&amp;gt;</source>
          <target state="translated">范围：&amp;gt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="8e6946ee5453b7aafe3852ad6a413e04bbe70b3f" translate="yes" xml:space="preserve">
          <source>Range: &amp;gt;=</source>
          <target state="translated">范围：&amp;gt; =</target>
        </trans-unit>
        <trans-unit id="50827e59e82c8b9b94902deba9c0cd7d740e2584" translate="yes" xml:space="preserve">
          <source>Range: &amp;lt;</source>
          <target state="translated">范围：&amp;lt;</target>
        </trans-unit>
        <trans-unit id="f6f037363a29496f0699d11afa7d6227f3803584" translate="yes" xml:space="preserve">
          <source>Range: &amp;lt;&amp;gt;</source>
          <target state="translated">范围：&amp;lt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6f6f0031a9d4355c819448b50757c3487642b742" translate="yes" xml:space="preserve">
          <source>Range: &amp;lt;&amp;lt;</source>
          <target state="translated">范围：&amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="278020aa13725565b03e23b783ab30ead6a5d971" translate="yes" xml:space="preserve">
          <source>Range: &amp;lt;=</source>
          <target state="translated">范围：&amp;lt;=</target>
        </trans-unit>
        <trans-unit id="8fd029989c2ed32bcffaf5576523df4934fcb6aa" translate="yes" xml:space="preserve">
          <source>Range: &amp;lt;@</source>
          <target state="translated">范围：&amp;lt;@</target>
        </trans-unit>
        <trans-unit id="519ae404f51d7cdda5157d728a679f6ac34e633b" translate="yes" xml:space="preserve">
          <source>Range: *</source>
          <target state="translated">范围:*</target>
        </trans-unit>
        <trans-unit id="2eb640bcc9834e28157d86493366688f7c5d38a2" translate="yes" xml:space="preserve">
          <source>Range: +</source>
          <target state="translated">范围:+</target>
        </trans-unit>
        <trans-unit id="c8e5cef097bd3910fe5e0190257f34cad206f4c2" translate="yes" xml:space="preserve">
          <source>Range: -</source>
          <target state="translated">范围:-</target>
        </trans-unit>
        <trans-unit id="b30626f6a47ecd0abac84acd28b5ffc7444c5618" translate="yes" xml:space="preserve">
          <source>Range: -|-</source>
          <target state="translated">范围:-|-</target>
        </trans-unit>
        <trans-unit id="1c3066fd7e6819e63ddca17dcd69c108489cf890" translate="yes" xml:space="preserve">
          <source>Range: 42 &amp;lt;@ int4range</source>
          <target state="translated">范围：42 &amp;lt;@ int4range</target>
        </trans-unit>
        <trans-unit id="d7943ac61251b0e439e59453d3c9bd4d92cbe7db" translate="yes" xml:space="preserve">
          <source>Range: =</source>
          <target state="translated">范围:=</target>
        </trans-unit>
        <trans-unit id="5c9fd1a7ffb6cd6aed893574001127ea193ec53e" translate="yes" xml:space="preserve">
          <source>Range: @&amp;gt;</source>
          <target state="translated">范围：@&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5345a847755c33035bc2591758bc060d8da94779" translate="yes" xml:space="preserve">
          <source>Range: NULL</source>
          <target state="translated">范围。NULL</target>
        </trans-unit>
        <trans-unit id="83729c8bd9a31e069f9cad56b7e2bfe6d4220671" translate="yes" xml:space="preserve">
          <source>Range: int4range &amp;lt;@ int4range</source>
          <target state="translated">范围：int4range &amp;lt;@ int4range</target>
        </trans-unit>
        <trans-unit id="b6abcc684ac42f015a5d77cb6bf7ae1803faa802" translate="yes" xml:space="preserve">
          <source>Range: int4range @&amp;gt; int4range</source>
          <target state="translated">范围：int4range @&amp;gt; int4range</target>
        </trans-unit>
        <trans-unit id="7cbb9c6dd7fa8194a072796ecd9b741b996bd7a3" translate="yes" xml:space="preserve">
          <source>Range: int8range &amp;amp;&amp;amp; int8range</source>
          <target state="translated">范围：int8range &amp;amp;&amp;amp; int8range</target>
        </trans-unit>
        <trans-unit id="4b0bb91169217b4e29cfb76dc5581d25ed6b251b" translate="yes" xml:space="preserve">
          <source>Range: int8range &amp;amp;&amp;gt; int8range</source>
          <target state="translated">范围：int8range＆&amp;gt; int8range</target>
        </trans-unit>
        <trans-unit id="ff9df88e5abad3c50f6d014794683bf550b4afb2" translate="yes" xml:space="preserve">
          <source>Range: int8range &amp;amp;&amp;lt; int8range</source>
          <target state="translated">范围：int8range＆&amp;lt;int8range</target>
        </trans-unit>
        <trans-unit id="e00a7aa8e9c2301c9240fdd0b4875fa5651174d5" translate="yes" xml:space="preserve">
          <source>Range: int8range &amp;gt;&amp;gt; int8range</source>
          <target state="translated">范围：int8range &amp;gt;&amp;gt; int8range</target>
        </trans-unit>
        <trans-unit id="3040a7f95f19ee36e36e4e5ae3a596d709298aa3" translate="yes" xml:space="preserve">
          <source>Range: int8range &amp;lt;&amp;lt; int8range</source>
          <target state="translated">范围：int8range &amp;lt;&amp;lt; int8range</target>
        </trans-unit>
        <trans-unit id="6d06790af02020de10dd09609a797d037f242e11" translate="yes" xml:space="preserve">
          <source>Range: int8range * int8range</source>
          <target state="translated">范围:int8range*int8range</target>
        </trans-unit>
        <trans-unit id="79c4e2dbf1d6156da3d7eac97068e72a3e022465" translate="yes" xml:space="preserve">
          <source>Range: int8range - int8range</source>
          <target state="translated">范围:int8range-int8range</target>
        </trans-unit>
        <trans-unit id="5df42bdba4fe9375d8ecde65d144985e2fa123da" translate="yes" xml:space="preserve">
          <source>Range: isempty</source>
          <target state="translated">范围:isempty</target>
        </trans-unit>
        <trans-unit id="9447a77bf49896166cdfa5ac004b88e4656caa30" translate="yes" xml:space="preserve">
          <source>Range: isempty)</source>
          <target state="translated">Range:isempty)</target>
        </trans-unit>
        <trans-unit id="7cf1b8f7817c42e33a217bf084388d7956ddb800" translate="yes" xml:space="preserve">
          <source>Range: lower</source>
          <target state="translated">范围:较低</target>
        </trans-unit>
        <trans-unit id="3534ccb32cb9b587caf3133de3f56d8a17947373" translate="yes" xml:space="preserve">
          <source>Range: lower)</source>
          <target state="translated">幅度:较低))</target>
        </trans-unit>
        <trans-unit id="41561998090e13cce0a01b7784c0b3af97242f0c" translate="yes" xml:space="preserve">
          <source>Range: lower_inc</source>
          <target state="translated">范围:lower_inc</target>
        </trans-unit>
        <trans-unit id="49ede64eaa7a5da6409899cef575840c6dedca3b" translate="yes" xml:space="preserve">
          <source>Range: lower_inc)</source>
          <target state="translated">范围:lower_inc)</target>
        </trans-unit>
        <trans-unit id="2cc53727481a0808617729c756b990601f85da64" translate="yes" xml:space="preserve">
          <source>Range: lower_inf</source>
          <target state="translated">范围:lower_inf</target>
        </trans-unit>
        <trans-unit id="2a99c9126b3c8019058e523ae759bf66bab6b3d8" translate="yes" xml:space="preserve">
          <source>Range: lower_inf&amp;#x27;::daterange)</source>
          <target state="translated">范围：lower_inf':: daterange）</target>
        </trans-unit>
        <trans-unit id="34730d102b3ffad4351ea1715389e7a70c0cc7ec" translate="yes" xml:space="preserve">
          <source>Range: numrange + numrange</source>
          <target state="translated">范围:numrange+numrange</target>
        </trans-unit>
        <trans-unit id="2a1e61e3344f0ee0e36aee5f2d966cf254ba621b" translate="yes" xml:space="preserve">
          <source>Range: numrange -|- numrange</source>
          <target state="translated">范围:numrange -|-numrange。</target>
        </trans-unit>
        <trans-unit id="4ace460c813343c7a659f92c463b48f8e9497c10" translate="yes" xml:space="preserve">
          <source>Range: range_merge</source>
          <target state="translated">范围:range_merge</target>
        </trans-unit>
        <trans-unit id="25aa728cd66f80690db18e571734403309e220fa" translate="yes" xml:space="preserve">
          <source>Range: range_merge&amp;#x27;::int4range, &amp;#x27;[3,4)&amp;#x27;::int4range)</source>
          <target state="translated">范围：range_merge':: int4range，'[3,4）':: int4range）</target>
        </trans-unit>
        <trans-unit id="1f28a3c6d0b4768f8b324bd884ab8839d0315ae6" translate="yes" xml:space="preserve">
          <source>Range: upper</source>
          <target state="translated">范围:上级</target>
        </trans-unit>
        <trans-unit id="04161af92454051c0f045081c7825aa3a8e93a1f" translate="yes" xml:space="preserve">
          <source>Range: upper)</source>
          <target state="translated">范围:上))</target>
        </trans-unit>
        <trans-unit id="254cd3d46f3b050314f0a32b8ccaf21bfef8428c" translate="yes" xml:space="preserve">
          <source>Range: upper_inc</source>
          <target state="translated">范围:upper_inc</target>
        </trans-unit>
        <trans-unit id="96dc0693990a3ee24e3cb9591cf140f45bea8755" translate="yes" xml:space="preserve">
          <source>Range: upper_inc)</source>
          <target state="translated">范围:upper_inc)</target>
        </trans-unit>
        <trans-unit id="15a1bf88678aec9c8e638569577cf68508681fb4" translate="yes" xml:space="preserve">
          <source>Range: upper_inf</source>
          <target state="translated">范围:upper_inf</target>
        </trans-unit>
        <trans-unit id="97b0a2bf6f728a07761880c6d6ff4cec56f9089c" translate="yes" xml:space="preserve">
          <source>Range: upper_inf&amp;#x27;::daterange)</source>
          <target state="translated">范围：upper_inf':: daterange）</target>
        </trans-unit>
        <trans-unit id="16773cb5b6a39b09024cc881604849b2ada6e7b5" translate="yes" xml:space="preserve">
          <source>Ranking attempts to measure how relevant documents are to a particular query, so that when there are many matches the most relevant ones can be shown first. PostgreSQL provides two predefined ranking functions, which take into account lexical, proximity, and structural information; that is, they consider how often the query terms appear in the document, how close together the terms are in the document, and how important is the part of the document where they occur. However, the concept of relevancy is vague and very application-specific. Different applications might require additional information for ranking, e.g., document modification time. The built-in ranking functions are only examples. You can write your own ranking functions and/or combine their results with additional factors to fit your specific needs.</source>
          <target state="translated">排名试图衡量文档与特定查询的相关程度,因此当有许多匹配时,可以首先显示最相关的文档。PostgreSQL提供了两个预定义的排名函数,它们考虑了词性、接近性和结构信息;也就是说,它们考虑了查询术语在文档中出现的频率,术语在文档中的接近程度,以及它们出现的部分在文档中的重要性。然而,相关性的概念是模糊的,而且非常针对应用。不同的应用可能需要额外的信息来进行排名,例如,文档修改时间。内置的排序函数只是一个例子。您可以编写自己的排名函数和/或将其结果与其他因素相结合,以满足您的特定需求。</target>
        </trans-unit>
        <trans-unit id="6d643b0d7aa4393d4d9da3687d8322d0a81e0cab" translate="yes" xml:space="preserve">
          <source>Ranking can be expensive since it requires consulting the &lt;code&gt;tsvector&lt;/code&gt; of each matching document, which can be I/O bound and therefore slow. Unfortunately, it is almost impossible to avoid since practical queries often result in large numbers of matches.</source>
          <target state="translated">排名可能很昂贵，因为排名需要咨询每个匹配文档的 &lt;code&gt;tsvector&lt;/code&gt; ，而tsvector可能受I / O限制，因此很慢。不幸的是，几乎无法避免，因为实际查询通常会导致大量匹配。</target>
        </trans-unit>
        <trans-unit id="19afdfa41a0ed827f969267ae295f3b913f28c70" translate="yes" xml:space="preserve">
          <source>Ranks vectors based on the frequency of their matching lexemes.</source>
          <target state="translated">根据匹配词组的频率对向量进行排序。</target>
        </trans-unit>
        <trans-unit id="236c736d2b53bb667d136c499a0d1ba402fdd25d" translate="yes" xml:space="preserve">
          <source>Rather than look at &lt;code&gt;pg_statistic&lt;/code&gt; directly, it's better to look at its view &lt;a href=&quot;view-pg-stats&quot;&gt;&lt;code&gt;pg_stats&lt;/code&gt;&lt;/a&gt; when examining the statistics manually. &lt;code&gt;pg_stats&lt;/code&gt; is designed to be more easily readable. Furthermore, &lt;code&gt;pg_stats&lt;/code&gt; is readable by all, whereas &lt;code&gt;pg_statistic&lt;/code&gt; is only readable by a superuser. (This prevents unprivileged users from learning something about the contents of other people's tables from the statistics. The &lt;code&gt;pg_stats&lt;/code&gt; view is restricted to show only rows about tables that the current user can read.) For example, we might do:</source>
          <target state="translated">与其直接查看 &lt;code&gt;pg_statistic&lt;/code&gt; ，不如直接查看统计信息时，最好查看其视图&lt;a href=&quot;view-pg-stats&quot;&gt; &lt;code&gt;pg_stats&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;pg_stats&lt;/code&gt; 的设计使其更易于阅读。此外， &lt;code&gt;pg_stats&lt;/code&gt; 所有人都可读，而 &lt;code&gt;pg_statistic&lt;/code&gt; 仅超级用户可读。 （这阻止了非特权用户从统计信息中了解其他人的表的内容 &lt;code&gt;pg_stats&lt;/code&gt; 视图被限制为仅显示当前用户可以读取的表的行。）例如，我们可以这样做：</target>
        </trans-unit>
        <trans-unit id="e2bec5c61f15a407e756ab05a685ad23bb7e5511" translate="yes" xml:space="preserve">
          <source>Raw encryption</source>
          <target state="translated">原始加密</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
