<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="95f8a0055f70864568262af7adc2dc1b06f590cc" translate="yes" xml:space="preserve">
          <source>For additional details see &lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc-volatility.html&quot;&gt;Section 37.7&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb8ec9455b3b3ecef5cd6da5c8b1451f7a76196b" translate="yes" xml:space="preserve">
          <source>For additional details see &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt; and &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，请参见&lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt;和&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7bc2c859a66cc47f7ab253d738eacf7f06902a6f" translate="yes" xml:space="preserve">
          <source>For additional information on tuning these settings, see &lt;a href=&quot;wal-configuration&quot;&gt;Section 29.4&lt;/a&gt;.</source>
          <target state="translated">有关调整这些设置的更多信息，请参见&lt;a href=&quot;wal-configuration&quot;&gt;第29.4节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3269f32ce55507d4303558fb95944d5f97b55201" translate="yes" xml:space="preserve">
          <source>For additional information see &lt;a href=&quot;sql-createdomain&quot;&gt;CREATE DOMAIN&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;sql-createdomain&quot;&gt;CREATE DOMAIN&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6de3939693bb1f9d3d1fe45488c69d0a8681aad2" translate="yes" xml:space="preserve">
          <source>For additional information, see &lt;a href=&quot;sql-createforeigndatawrapper&quot;&gt;CREATE FOREIGN DATA WRAPPER&lt;/a&gt;, &lt;a href=&quot;sql-createserver&quot;&gt;CREATE SERVER&lt;/a&gt;, &lt;a href=&quot;sql-createusermapping&quot;&gt;CREATE USER MAPPING&lt;/a&gt;, &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;, and &lt;a href=&quot;sql-importforeignschema&quot;&gt;IMPORT FOREIGN SCHEMA&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;sql-createforeigndatawrapper&quot;&gt;CREATE FOREIGN DATA WRAPPER&lt;/a&gt;，&lt;a href=&quot;sql-createserver&quot;&gt;CREATE SERVER&lt;/a&gt;，&lt;a href=&quot;sql-createusermapping&quot;&gt;CREATE USER MAPPING&lt;/a&gt;，&lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;和&lt;a href=&quot;sql-importforeignschema&quot;&gt;IMPORT FOREIGN SCHEMA&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4e8aca49f3e5f06e066139112539b79576ab0035" translate="yes" xml:space="preserve">
          <source>For additional variables that affect the server, see &lt;a href=&quot;app-postgres&quot;&gt;postgres&lt;/a&gt;.</source>
          <target state="translated">有关影响服务器的其他变量，请参见&lt;a href=&quot;app-postgres&quot;&gt;postgres&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cdf9570df93b845cb267b78130d56401af562fa2" translate="yes" xml:space="preserve">
          <source>For aggregate functions whose &lt;code&gt;state_data_type&lt;/code&gt; is &lt;code&gt;internal&lt;/code&gt;, the &lt;code&gt;combinefunc&lt;/code&gt; must not be strict. In this case the &lt;code&gt;combinefunc&lt;/code&gt; must ensure that null states are handled correctly and that the state being returned is properly stored in the aggregate memory context.</source>
          <target state="translated">对于 &lt;code&gt;state_data_type&lt;/code&gt; 为 &lt;code&gt;internal&lt;/code&gt; 的聚合函数， &lt;code&gt;combinefunc&lt;/code&gt; 不能严格。在这种情况下， &lt;code&gt;combinefunc&lt;/code&gt; 必须确保正确处理空状态，并将返回的状态正确存储在聚合内存上下文中。</target>
        </trans-unit>
        <trans-unit id="96ebaaa890b3287a6cc4cc73ddb31fd495f4b938" translate="yes" xml:space="preserve">
          <source>For all types of in-memory TOAST pointer, the TOAST management code ensures that no such pointer datum can accidentally get stored on disk. In-memory TOAST pointers are automatically expanded to normal in-line varlena values before storage &amp;mdash; and then possibly converted to on-disk TOAST pointers, if the containing tuple would otherwise be too big.</source>
          <target state="translated">对于所有类型的内存TOAST指针，TOAST管理代码可确保不会意外将此类指针数据存储在磁盘上。内存中的TOAST指针在存储之前会自动扩展为正常的行内varlena值，然后可能会转换为磁盘上的TOAST指针，如果包含的元组太大的话。</target>
        </trans-unit>
        <trans-unit id="00c5f8e7c27807a2274e36cb656c8abd549f0c2f" translate="yes" xml:space="preserve">
          <source>For an &lt;code&gt;INSERT ... ON CONFLICT&lt;/code&gt; command, the publication will publish the operation that actually results from the command. So depending of the outcome, it may be published as either &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt;, or it may not be published at all.</source>
          <target state="translated">对于 &lt;code&gt;INSERT ... ON CONFLICT&lt;/code&gt; 命令，发布将发布该命令实际产生的操作。因此，根据结果，它可能以 &lt;code&gt;INSERT&lt;/code&gt; 或 &lt;code&gt;UPDATE&lt;/code&gt; 的形式发布，也可能根本不发布。</target>
        </trans-unit>
        <trans-unit id="e4c28bd7503d02aa54b1f5bc7ca2e5f40da183d1" translate="yes" xml:space="preserve">
          <source>For an MD5 encrypted password, &lt;code&gt;rolpassword&lt;/code&gt; column will begin with the string &lt;code&gt;md5&lt;/code&gt; followed by a 32-character hexadecimal MD5 hash. The MD5 hash will be of the user's password concatenated to their user name. For example, if user &lt;code&gt;joe&lt;/code&gt; has password &lt;code&gt;xyzzy&lt;/code&gt;, PostgreSQL will store the md5 hash of &lt;code&gt;xyzzyjoe&lt;/code&gt;.</source>
          <target state="translated">对于MD5加密密码， &lt;code&gt;rolpassword&lt;/code&gt; 列将以字符串 &lt;code&gt;md5&lt;/code&gt; 开头，后跟32个字符的十六进制MD5哈希。MD5哈希将是与用户名关联的用户密码。例如，如果用户 &lt;code&gt;joe&lt;/code&gt; 的密码为 &lt;code&gt;xyzzy&lt;/code&gt; ，则PostgreSQL将存储 &lt;code&gt;xyzzyjoe&lt;/code&gt; 的md5哈希值。</target>
        </trans-unit>
        <trans-unit id="a8f9fac8435c636eaa9948982c5c6b1419a33356" translate="yes" xml:space="preserve">
          <source>For an exponential distribution, &lt;code&gt;parameter&lt;/code&gt; controls the distribution by truncating a quickly-decreasing exponential distribution at &lt;code&gt;parameter&lt;/code&gt;, and then projecting onto integers between the bounds. To be precise, with</source>
          <target state="translated">对于指数分布， &lt;code&gt;parameter&lt;/code&gt; 通过在 &lt;code&gt;parameter&lt;/code&gt; 处截断快速递减的指数分布，然后投影到边界之间的整数上来控制分布。确切地说，</target>
        </trans-unit>
        <trans-unit id="9dddaa17ae34450f80cb35e71888640772ac6f9b" translate="yes" xml:space="preserve">
          <source>For an identity column defined as &lt;code&gt;GENERATED ALWAYS&lt;/code&gt;, it is an error to insert an explicit value (other than &lt;code&gt;DEFAULT&lt;/code&gt;) without specifying either &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt; or &lt;code&gt;OVERRIDING USER VALUE&lt;/code&gt;. (For an identity column defined as &lt;code&gt;GENERATED BY DEFAULT&lt;/code&gt;, &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt; is the normal behavior and specifying it does nothing, but PostgreSQL allows it as an extension.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65c3010f7ad4d8ce5cd9ffc778600e650d4f3866" translate="yes" xml:space="preserve">
          <source>For an operator family supporting multiple data types, the above laws must hold when &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt; are taken from any data types in the family. The transitive laws are the trickiest to ensure, as in cross-type situations they represent statements that the behaviors of two or three different operators are consistent. As an example, it would not work to put &lt;code&gt;float8&lt;/code&gt; and &lt;code&gt;numeric&lt;/code&gt; into the same operator family, at least not with the current semantics that &lt;code&gt;numeric&lt;/code&gt; values are converted to &lt;code&gt;float8&lt;/code&gt; for comparison to a &lt;code&gt;float8&lt;/code&gt;. Because of the limited accuracy of &lt;code&gt;float8&lt;/code&gt;, this means there are distinct &lt;code&gt;numeric&lt;/code&gt; values that will compare equal to the same &lt;code&gt;float8&lt;/code&gt; value, and thus the transitive law would fail.</source>
          <target state="translated">对于支持多种数据类型的运营商系列，当从系列中的任何数据类型中提取 &lt;code&gt;A&lt;/code&gt; ， &lt;code&gt;B&lt;/code&gt; ， &lt;code&gt;C&lt;/code&gt; 时，必须遵守上述法律。传递律是最难以确保的，因为在交叉类型的情况下，传递律表示两个或三个不同运算符的行为是一致的。作为一个例子，它不会工作，以放 &lt;code&gt;float8&lt;/code&gt; 和 &lt;code&gt;numeric&lt;/code&gt; 到同一个运营商的家庭，至少与当前语义 &lt;code&gt;numeric&lt;/code&gt; 值转换成 &lt;code&gt;float8&lt;/code&gt; 进行比较的 &lt;code&gt;float8&lt;/code&gt; 。由于 &lt;code&gt;float8&lt;/code&gt; 的精度有限，这意味着存在不同的 &lt;code&gt;numeric&lt;/code&gt; 值将等于相同的 &lt;code&gt;float8&lt;/code&gt; 值，因此传递定律将失败。</target>
        </trans-unit>
        <trans-unit id="fb67d8e335116f8d04cb145c346f347c48295886" translate="yes" xml:space="preserve">
          <source>For analyze, a similar condition is used: the threshold, defined as:</source>
          <target state="translated">分析时,采用类似的条件:阈值,定义为:。</target>
        </trans-unit>
        <trans-unit id="d9ad010e024a4439cd621de2da500fdb418cf81a" translate="yes" xml:space="preserve">
          <source>For any pattern, to install shared applications (tables to be used by everyone, additional functions provided by third parties, etc.), put them into separate schemas. Remember to grant appropriate privileges to allow the other users to access them. Users can then refer to these additional objects by qualifying the names with a schema name, or they can put the additional schemas into their search path, as they choose.</source>
          <target state="translated">对于任何模式,要安装共享应用(大家都要用的表、第三方提供的附加功能等),把它们放到单独的模式中。记住要授予适当的权限,允许其他用户访问它们。然后,用户可以通过用模式名称来限定名称来引用这些额外的对象,也可以根据自己的选择,将额外的模式放入搜索路径中。</target>
        </trans-unit>
        <trans-unit id="16a497bd5483558f99655038b89f96368461a1c5" translate="yes" xml:space="preserve">
          <source>For backward compatibility, the name can be enclosed by single quotes.</source>
          <target state="translated">为了向后兼容,名称可以用单引号括起来。</target>
        </trans-unit>
        <trans-unit id="ca86393d893511ed217c26aec47e69fc362ff707" translate="yes" xml:space="preserve">
          <source>For both &lt;code&gt;LIKE&lt;/code&gt; and regular-expression searches, keep in mind that a pattern with no extractable trigrams will degenerate to a full-index scan.</source>
          <target state="translated">对于 &lt;code&gt;LIKE&lt;/code&gt; 搜索和正则表达式搜索，请记住，没有可提取三字母组的模式将退化为全索引扫描。</target>
        </trans-unit>
        <trans-unit id="7c873bea9ea29f067ffabebef48d2954f71baefe" translate="yes" xml:space="preserve">
          <source>For both these functions, the optional &lt;code&gt;weights&lt;/code&gt; argument offers the ability to weigh word instances more or less heavily depending on how they are labeled. The weight arrays specify how heavily to weigh each category of word, in the order:</source>
          <target state="translated">对于这两个功能，可选的 &lt;code&gt;weights&lt;/code&gt; 参数提供了根据单词的标记方式或多或少地对单词实例进行加权的功能。权重数组按以下顺序指定对每个单词类别加权的权重：</target>
        </trans-unit>
        <trans-unit id="0b0722cabc6ab2e548afa613aa4953b992a05e07" translate="yes" xml:space="preserve">
          <source>For clarity we omitted the &lt;code&gt;coalesce&lt;/code&gt; function calls which would be needed to find rows that contain &lt;code&gt;NULL&lt;/code&gt; in one of the two fields.</source>
          <target state="translated">为了清楚起见，我们省略了 &lt;code&gt;coalesce&lt;/code&gt; 函数调用，这将需要在两个字段之一中查找包含 &lt;code&gt;NULL&lt;/code&gt; 的行。</target>
        </trans-unit>
        <trans-unit id="5a4475c3ea46bdd2013d00d5535373f530d5c349" translate="yes" xml:space="preserve">
          <source>For clarity, you can also request default values explicitly, for individual columns or for the entire row:</source>
          <target state="translated">为了清楚起见,你也可以明确地要求个别列或整行的默认值。</target>
        </trans-unit>
        <trans-unit id="93860c51a978bc4e5066beb2f011be832a913dba" translate="yes" xml:space="preserve">
          <source>For clients using extended query protocol, durations of the Parse, Bind, and Execute steps are logged independently.</source>
          <target state="translated">对于使用扩展查询协议的客户端,解析、绑定和执行步骤的持续时间将被独立记录。</target>
        </trans-unit>
        <trans-unit id="642c28fcef80f55a7fa8a09654289e47fe6125b8" translate="yes" xml:space="preserve">
          <source>For comparison, the PostgreSQL 8.1 documentation contained 10,441 unique words, a total of 335,420 words, and the most frequent word &amp;ldquo;postgresql&amp;rdquo; was mentioned 6,127 times in 655 documents.</source>
          <target state="translated">为了进行比较，PostgreSQL 8.1文档包含10,441个唯一单词，总共335,420个单词，在655个文档中，最常见的单词&amp;ldquo; postgresql&amp;rdquo;被提及6,127次。</target>
        </trans-unit>
        <trans-unit id="3e2967140afc307af479be8f80698d1858dbc62a" translate="yes" xml:space="preserve">
          <source>For compatibility with output generated by older versions of PostgreSQL, and to allow the output precision to be reduced, the &lt;a href=&quot;runtime-config-client#GUC-EXTRA-FLOAT-DIGITS&quot;&gt;extra_float_digits&lt;/a&gt; parameter can be used to select rounded decimal output instead. Setting a value of 0 restores the previous default of rounding the value to 6 (for &lt;code&gt;float4&lt;/code&gt;) or 15 (for &lt;code&gt;float8&lt;/code&gt;) significant decimal digits. Setting a negative value reduces the number of digits further; for example -2 would round output to 4 or 13 digits respectively.</source>
          <target state="translated">为了与旧版PostgreSQL生成的输出兼容，并允许降低输出精度，可以使用&lt;a href=&quot;runtime-config-client#GUC-EXTRA-FLOAT-DIGITS&quot;&gt;extra_float_digits&lt;/a&gt;参数选择舍入的十进制输出。将值设置为0将恢复先前的默认值，即将值四舍五入为6（对于 &lt;code&gt;float4&lt;/code&gt; ）或15（对于 &lt;code&gt;float8&lt;/code&gt; ）有效的十进制数字。设置负值会进一步减少位数。例如-2会将输出分别舍入到4或13位数字。</target>
        </trans-unit>
        <trans-unit id="82e33c9e09cc041982adc16695f27c2ebea4aeea" translate="yes" xml:space="preserve">
          <source>For compatibility with some other database systems, &lt;code&gt;argmode&lt;/code&gt; can be written either before or after &lt;code&gt;argname&lt;/code&gt;. But only the first way is standard-compliant.</source>
          <target state="translated">与一些其它数据库系统的兼容性， &lt;code&gt;argmode&lt;/code&gt; 可以之前或之后被写入 &lt;code&gt;argname&lt;/code&gt; 。但是只有第一种方法是符合标准的。</target>
        </trans-unit>
        <trans-unit id="28fead7bc1a5393ae5055409c79f82dc0d627975" translate="yes" xml:space="preserve">
          <source>For compatibility's sake, PostgreSQL will accept the &lt;code&gt;GLOBAL&lt;/code&gt; and &lt;code&gt;LOCAL&lt;/code&gt; keywords in a temporary table declaration, but they currently have no effect. Use of these keywords is discouraged, since future versions of PostgreSQL might adopt a more standard-compliant interpretation of their meaning.</source>
          <target state="translated">出于兼容性考虑，PostgreSQL将在临时表声明中接受 &lt;code&gt;GLOBAL&lt;/code&gt; 和 &lt;code&gt;LOCAL&lt;/code&gt; 关键字，但是它们目前无效。不鼓励使用这些关键字，因为PostgreSQL的未来版本可能会对其含义进行更符合标准的解释。</target>
        </trans-unit>
        <trans-unit id="cb0d695c453e288497b0e820fe56bdd716e52946" translate="yes" xml:space="preserve">
          <source>For compiled functions, both built-in and dynamically loaded, &lt;code&gt;prosrc&lt;/code&gt; contains the function's C-language name (link symbol). For all other currently-known language types, &lt;code&gt;prosrc&lt;/code&gt; contains the function's source text. &lt;code&gt;probin&lt;/code&gt; is unused except for dynamically-loaded C functions, for which it gives the name of the shared library file containing the function.</source>
          <target state="translated">对于内置和动态加载的编译函数， &lt;code&gt;prosrc&lt;/code&gt; 包含函数的C语言名称（链接符号）。对于所有其他当前已知的语言类型， &lt;code&gt;prosrc&lt;/code&gt; 包含函数的源文本。除了动态加载的C函数外， &lt;code&gt;probin&lt;/code&gt; 均未使用，它会为其提供包含该函数的共享库文件的名称。</target>
        </trans-unit>
        <trans-unit id="1593a37c3e4bef998076b51ab60cf493f14debc2" translate="yes" xml:space="preserve">
          <source>For conditional purposes, non zero numerical values are &lt;code&gt;TRUE&lt;/code&gt;, zero numerical values and &lt;code&gt;NULL&lt;/code&gt; are &lt;code&gt;FALSE&lt;/code&gt;.</source>
          <target state="translated">出于条件目的，非零数值为 &lt;code&gt;TRUE&lt;/code&gt; ，零数值和 &lt;code&gt;NULL&lt;/code&gt; 为 &lt;code&gt;FALSE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1ca450dc70846b4e702e0834dc4a1ac754f8335c" translate="yes" xml:space="preserve">
          <source>For convenience there are also single letter command-line option switches available for some parameters. They are described in &lt;a href=&quot;runtime-config-short#RUNTIME-CONFIG-SHORT-TABLE&quot;&gt;Table 19.2&lt;/a&gt;. Some of these options exist for historical reasons, and their presence as a single-letter option does not necessarily indicate an endorsement to use the option heavily.</source>
          <target state="translated">为了方便起见，某些参数还提供了单字母命令行选项开关。它们在&lt;a href=&quot;runtime-config-short#RUNTIME-CONFIG-SHORT-TABLE&quot;&gt;表19.2&lt;/a&gt;中描述。这些选项中的某些选项是出于历史原因而存在的，它们作为单个字母选项的存在并不一定表示赞同使用该选项。</target>
        </trans-unit>
        <trans-unit id="7bc2076f57d611864b1939f513772007f82c5791" translate="yes" xml:space="preserve">
          <source>For convenience there are also single letter command-line option switches available for some parameters. They are described in &lt;a href=&quot;runtime-config-short#RUNTIME-CONFIG-SHORT-TABLE&quot;&gt;Table 19.3&lt;/a&gt;. Some of these options exist for historical reasons, and their presence as a single-letter option does not necessarily indicate an endorsement to use the option heavily.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f4b1609541244f90c1469cfda93f87205751028" translate="yes" xml:space="preserve">
          <source>For convenience, the programs &lt;a href=&quot;app-createuser&quot;&gt;createuser&lt;/a&gt; and &lt;a href=&quot;app-dropuser&quot;&gt;dropuser&lt;/a&gt; are provided as wrappers around these SQL commands that can be called from the shell command line:</source>
          <target state="translated">为了方便起见，程序&lt;a href=&quot;app-createuser&quot;&gt;createuser&lt;/a&gt;和&lt;a href=&quot;app-dropuser&quot;&gt;dropuser&lt;/a&gt;作为这些SQL命令的包装提供，可以从shell命令行调用这些SQL命令：</target>
        </trans-unit>
        <trans-unit id="3832912e6c9f91aa4902ff08b60d0cbcee1c2ac8" translate="yes" xml:space="preserve">
          <source>For convenience, there is also a shell program to drop databases, &lt;a href=&quot;app-dropdb&quot;&gt;dropdb&lt;/a&gt;:</source>
          <target state="translated">为了方便起见，还有一个用于删除数据库的shell程序&lt;a href=&quot;app-dropdb&quot;&gt;dropdb&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="2086e8168bb5d57d0ea6881d92ef9c3d377f6179" translate="yes" xml:space="preserve">
          <source>For crash safety, an AM can use postgres' &lt;a href=&quot;https://www.postgresql.org/docs/12/wal.html&quot;&gt;WAL&lt;/a&gt;, or a custom implementation. If WAL is chosen, either &lt;a href=&quot;generic-wal&quot;&gt;Generic WAL Records&lt;/a&gt; can be used, or a new type of WAL records can be implemented. Generic WAL Records are easy, but imply higher WAL volume. Implementation of a new type of WAL record currently requires modifications to core code (specifically, &lt;code&gt;src/include/access/rmgrlist.h&lt;/code&gt;).</source>
          <target state="translated">为了防撞安全，AM可以使用postgres的&lt;a href=&quot;https://www.postgresql.org/docs/12/wal.html&quot;&gt;WAL&lt;/a&gt;或自定义实现。如果选择了&lt;a href=&quot;generic-wal&quot;&gt;WAL，&lt;/a&gt;则可以使用通用WAL记录，也可以实现新型的WAL记录。通用的WAL记录很容易，但是意味着更高的WAL量。当前，要实现一种新型的WAL记录，需要修改核心代码（特别是 &lt;code&gt;src/include/access/rmgrlist.h&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="bbdc473894ba97ea91078047c916d6159b963419" translate="yes" xml:space="preserve">
          <source>For crash safety, an AM can use postgres' &lt;a href=&quot;https://www.postgresql.org/docs/13/wal.html&quot;&gt;WAL&lt;/a&gt;, or a custom implementation. If WAL is chosen, either &lt;a href=&quot;generic-wal&quot;&gt;Generic WAL Records&lt;/a&gt; can be used, or a new type of WAL records can be implemented. Generic WAL Records are easy, but imply higher WAL volume. Implementation of a new type of WAL record currently requires modifications to core code (specifically, &lt;code&gt;src/include/access/rmgrlist.h&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45171c5ce1cebf261c0bfc4a29a7bbae2406dddb" translate="yes" xml:space="preserve">
          <source>For databases, allows new schemas and publications to be created within the database, and allows trusted extensions to be installed within the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c062e145de387371ec37dc656ac5b92503663ca" translate="yes" xml:space="preserve">
          <source>For databases, allows new schemas and publications to be created within the database.</source>
          <target state="translated">对于数据库,允许在数据库内创建新的模式和出版物。</target>
        </trans-unit>
        <trans-unit id="f4984c57688cb1cee66323a19c7444a0a9bb0477" translate="yes" xml:space="preserve">
          <source>For declarative partitioning, partitions must have exactly the same set of columns as the partitioned table, whereas with table inheritance, child tables may have extra columns not present in the parent.</source>
          <target state="translated">对于声明式分区,分区必须拥有与分区表完全相同的列集,而对于表继承,子表可能拥有父表不存在的额外列。</target>
        </trans-unit>
        <trans-unit id="fd8cd79e49912cef7e36a49a72250f6cd15cb54e" translate="yes" xml:space="preserve">
          <source>For deployment testing, create a schema-only copy of the old cluster, insert dummy data, and upgrade that.</source>
          <target state="translated">对于部署测试来说,创建一个旧集群的仅有模式的副本,插入虚数据,并升级该副本。</target>
        </trans-unit>
        <trans-unit id="23fcbc4c69f038c631978df5d852e7c988638319" translate="yes" xml:space="preserve">
          <source>For details about proper usage of these functions, see &lt;a href=&quot;continuous-archiving&quot;&gt;Section 25.3&lt;/a&gt;.</source>
          <target state="translated">有关正确使用这些功能的详细信息，请参见&lt;a href=&quot;continuous-archiving&quot;&gt;第25.3节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7a67dca85d30cbed66dc7cc81857442fa00d590c" translate="yes" xml:space="preserve">
          <source>For details on using &lt;code&gt;jsonpath&lt;/code&gt; expressions with SQL/JSON query functions, see &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH&quot;&gt;Section 9.15.2&lt;/a&gt;.</source>
          <target state="translated">有关将 &lt;code&gt;jsonpath&lt;/code&gt; 表达式与SQL / JSON查询函数一起使用的详细信息，请参见&lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH&quot;&gt;9.15.2节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0a2ee1a4a4b6ea5b1e5dc69f843d5bf40d2adf1f" translate="yes" xml:space="preserve">
          <source>For details on using &lt;code&gt;jsonpath&lt;/code&gt; expressions with SQL/JSON query functions, see &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH&quot;&gt;Section 9.16.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aba8e3841c67fc994b221c5d39e6ca9666653d88" translate="yes" xml:space="preserve">
          <source>For developers familiar with XQuery and XPath 2.0 or later, XPath 1.0 presents a number of differences to contend with:</source>
          <target state="translated">对于熟悉XQuery和XPath 2.0或更高版本的开发人员来说,XPath 1.0提供了许多需要解决的差异。</target>
        </trans-unit>
        <trans-unit id="444e073c791a9db99f3d6ee4275247eb7942a2d4" translate="yes" xml:space="preserve">
          <source>For development and debugging purposes a few additional configuration parameters exist, as described in &lt;a href=&quot;runtime-config-developer&quot;&gt;Section 19.17&lt;/a&gt;.</source>
          <target state="translated">为了进行开发和调试，存在一些其他配置参数，如&lt;a href=&quot;runtime-config-developer&quot;&gt;第19.17节&lt;/a&gt;所述。</target>
        </trans-unit>
        <trans-unit id="2f6d0f2ed640d213e669a2d88363956decb0dc50" translate="yes" xml:space="preserve">
          <source>For each child table, create an index on the key column(s), as well as any other indexes you might want.</source>
          <target state="translated">对于每个子表,在关键列上创建一个索引,以及任何其他你可能需要的索引。</target>
        </trans-unit>
        <trans-unit id="25abda91cdb6a3bbf8ff5bdcb98364248d703bc8" translate="yes" xml:space="preserve">
          <source>For each column in the index key (&lt;code&gt;indnkeyatts&lt;/code&gt; values), this contains the OID of the collation to use for the index, or zero if the column is not of a collatable data type.</source>
          <target state="translated">对于索引键中的每一列（ &lt;code&gt;indnkeyatts&lt;/code&gt; 值），它包含要用于索引的排序规则的OID；如果该列不是可排序的数据类型，则为零。</target>
        </trans-unit>
        <trans-unit id="6fc7ad5122e2bfa01daa15f6eed504af7d2b8967" translate="yes" xml:space="preserve">
          <source>For each column in the index key (&lt;code&gt;indnkeyatts&lt;/code&gt; values), this contains the OID of the operator class to use. See &lt;a href=&quot;catalog-pg-opclass&quot;&gt;&lt;code&gt;pg_opclass&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">对于索引键中的每一列（ &lt;code&gt;indnkeyatts&lt;/code&gt; 值），它包含要使用的运算符类的OID。有关详细信息，请参见&lt;a href=&quot;catalog-pg-opclass&quot;&gt; &lt;code&gt;pg_opclass&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="51f668b2a5a8c54bfcef88243c43a45aa5a55a09" translate="yes" xml:space="preserve">
          <source>For each column in the partition key, this contains the OID of the collation to use for partitioning, or zero if the column is not of a collatable data type.</source>
          <target state="translated">对于分区键中的每一列,这包含用于分区的整理的OID,如果该列不是可整理的数据类型,则为零。</target>
        </trans-unit>
        <trans-unit id="3edc803302a59c643149e81e1e75d11544ede04f" translate="yes" xml:space="preserve">
          <source>For each column in the partition key, this contains the OID of the operator class to use. See &lt;a href=&quot;catalog-pg-opclass&quot;&gt;&lt;code&gt;pg_opclass&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">对于分区键中的每一列，它包含要使用的运算符类的OID。有关详细信息，请参见&lt;a href=&quot;catalog-pg-opclass&quot;&gt; &lt;code&gt;pg_opclass&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7ccb1aca150cd3fd2a76eea5ce2e2c6866c56ef1" translate="yes" xml:space="preserve">
          <source>For each column that will contain unique references to large objects, create a &lt;code&gt;BEFORE UPDATE OR DELETE&lt;/code&gt; trigger, and give the column name as the sole trigger argument. You can also restrict the trigger to only execute on updates to the column by using &lt;code&gt;BEFORE UPDATE OF&lt;/code&gt;&lt;code&gt;column_name&lt;/code&gt;. If you need multiple &lt;code&gt;lo&lt;/code&gt; columns in the same table, create a separate trigger for each one, remembering to give a different name to each trigger on the same table.</source>
          <target state="translated">对于将包含对大型对象的唯一引用的每个列，创建一个 &lt;code&gt;BEFORE UPDATE OR DELETE&lt;/code&gt; 触发器，并将该列名作为唯一的触发器参数。您还可以使用 &lt;code&gt;BEFORE UPDATE OF&lt;/code&gt; &lt;code&gt;column_name&lt;/code&gt; 将触发器限制为仅对列的更新执行。如果您在同一表中需要多个 &lt;code&gt;lo&lt;/code&gt; 列，请为每个表创建一个单独的触发器，并记住为同一表上的每个触发器指定不同的名称。</target>
        </trans-unit>
        <trans-unit id="dc93abd020281b000ae47dfd8ef843f236c6a3a8" translate="yes" xml:space="preserve">
          <source>For each combination of data types that a btree operator family provides comparison operators for, it must provide a comparison support function, registered in &lt;code&gt;pg_amproc&lt;/code&gt; with support function number 1 and &lt;code&gt;amproclefttype&lt;/code&gt;/&lt;code&gt;amprocrighttype&lt;/code&gt; equal to the left and right data types for the comparison (i.e., the same data types that the matching operators are registered with in &lt;code&gt;pg_amop&lt;/code&gt;). The comparison function must take two non-null values &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; and return an &lt;code&gt;int32&lt;/code&gt; value that is &lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;0&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;, or &lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;0&lt;/code&gt; when &lt;code&gt;A&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;B&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;B&lt;/code&gt;, or &lt;code&gt;A&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;B&lt;/code&gt;, respectively. A null result is disallowed: all values of the data type must be comparable. See &lt;code&gt;src/backend/access/nbtree/nbtcompare.c&lt;/code&gt; for examples.</source>
          <target state="translated">对于btree运算符族提供比较运算符的每种数据类型组合，它必须提供一个比较支持功能，该函数在 &lt;code&gt;pg_amproc&lt;/code&gt; 中注册，其支持函数编号为1，并且 &lt;code&gt;amproclefttype&lt;/code&gt; / &lt;code&gt;amprocrighttype&lt;/code&gt; 等于用于比较的左右数据类型（即，与匹配运算符在 &lt;code&gt;pg_amop&lt;/code&gt; 中注册的数据类型相同）。比较函数必须采取两个非空值 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 并返回一个 &lt;code&gt;int32&lt;/code&gt; 类型值，该值是 &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;0&lt;/code&gt; ， &lt;code&gt;0&lt;/code&gt; ，或 &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;0&lt;/code&gt; 时 &lt;code&gt;A&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;B&lt;/code&gt; ， &lt;code&gt;A&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;B&lt;/code&gt; ，或 &lt;code&gt;A&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;B&lt;/code&gt; 分别。不允许为空结果：数据类型的所有值都必须是可比较的。有关示例，请参见 &lt;code&gt;src/backend/access/nbtree/nbtcompare.c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="816bbd53914791af08e63dd703c10a6ffd0c4825" translate="yes" xml:space="preserve">
          <source>For each database in the cluster there is a subdirectory within &lt;code&gt;PGDATA&lt;/code&gt;&lt;code&gt;/base&lt;/code&gt;, named after the database's OID in &lt;code&gt;pg_database&lt;/code&gt;. This subdirectory is the default location for the database's files; in particular, its system catalogs are stored there.</source>
          <target state="translated">对于集群中的每个数据库， &lt;code&gt;PGDATA&lt;/code&gt; &lt;code&gt;/base&lt;/code&gt; 中都有一个子目录，以 &lt;code&gt;pg_database&lt;/code&gt; 中数据库的OID命名。该子目录是数据库文件的默认位置。特别是其系统目录存储在此。</target>
        </trans-unit>
        <trans-unit id="5a93df004449e3d17d4da507b5cc8728f0ee8920" translate="yes" xml:space="preserve">
          <source>For each of these hypothetical-set aggregates, the list of direct arguments given in &lt;code&gt;args&lt;/code&gt; must match the number and types of the aggregated arguments given in &lt;code&gt;sorted_args&lt;/code&gt;. Unlike most built-in aggregates, these aggregates are not strict, that is they do not drop input rows containing nulls. Null values sort according to the rule specified in the &lt;code&gt;ORDER BY&lt;/code&gt; clause.</source>
          <target state="translated">对于这些假设集合的每个集合， &lt;code&gt;args&lt;/code&gt; 中给出的直接参数列表必须与 &lt;code&gt;sorted_args&lt;/code&gt; 中给出的聚合参数的数量和类型相匹配。与大多数内置聚合不同，这些聚合不是严格的，即它们不会删除包含空值的输入行。空值根据 &lt;code&gt;ORDER BY&lt;/code&gt; 子句中指定的规则排序。</target>
        </trans-unit>
        <trans-unit id="9cc9c8be16b2cd2bfdfefa12d9931dcf7459faa0" translate="yes" xml:space="preserve">
          <source>For each query, output performance statistics of the respective module to the server log. This is a crude profiling instrument, similar to the Unix &lt;code&gt;getrusage()&lt;/code&gt; operating system facility. &lt;code&gt;log_statement_stats&lt;/code&gt; reports total statement statistics, while the others report per-module statistics. &lt;code&gt;log_statement_stats&lt;/code&gt; cannot be enabled together with any of the per-module options. All of these options are disabled by default. Only superusers can change these settings.</source>
          <target state="translated">对于每个查询，将相应模块的性能统计信息输出到服务器日志。这是一种粗略的分析工具，类似于Unix &lt;code&gt;getrusage()&lt;/code&gt; 操作系统工具。 &lt;code&gt;log_statement_stats&lt;/code&gt; 报告总计语句统计信息，而其他报告按模块统计信息。 &lt;code&gt;log_statement_stats&lt;/code&gt; 不能与任何每个模块选项一起启用。默认情况下，所有这些选项都是禁用的。只有超级用户可以更改这些设置。</target>
        </trans-unit>
        <trans-unit id="0ba598fc8c9be134161735a51a95dc2f9f525608" translate="yes" xml:space="preserve">
          <source>For each relation (table, view, materialized view, index, sequence, or foreign table) or composite type matching the &lt;code&gt;pattern&lt;/code&gt;, show all columns, their types, the tablespace (if not the default) and any special attributes such as &lt;code&gt;NOT NULL&lt;/code&gt; or defaults. Associated indexes, constraints, rules, and triggers are also shown. For foreign tables, the associated foreign server is shown as well. (&amp;ldquo;Matching the pattern&amp;rdquo; is defined in &lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;Patterns&lt;/a&gt; below.)</source>
          <target state="translated">对于与 &lt;code&gt;pattern&lt;/code&gt; 匹配的每个关系（表，视图，实例化视图，索引，序列或外部表）或组合类型，请显示所有列，其类型，表空间（如果不是默认值）以及任何特殊属性，例如 &lt;code&gt;NOT NULL&lt;/code&gt; 或默认值。还显示了相关的索引，约束，规则和触发器。对于外部表，还将显示关联的外部服务器。 （&amp;ldquo;匹配模式&amp;rdquo;中被定义&lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;模式&lt;/a&gt;下文）。</target>
        </trans-unit>
        <trans-unit id="77b4eaff32602e55630fc25f0d7615181a46a544" translate="yes" xml:space="preserve">
          <source>For each row R1 of T1, the joined table has a row for each row in T2 that satisfies the join condition with R1.</source>
          <target state="translated">对于T1的每条记录R1,加入表的每条记录在T2中都有一条与R1满足加入条件的记录。</target>
        </trans-unit>
        <trans-unit id="8594ae1b752513c4090775efefd1243bce43044f" translate="yes" xml:space="preserve">
          <source>For efficiency reasons, &lt;code&gt;reltuples&lt;/code&gt; and &lt;code&gt;relpages&lt;/code&gt; are not updated on-the-fly, and so they usually contain somewhat out-of-date values. They are updated by &lt;code&gt;VACUUM&lt;/code&gt;, &lt;code&gt;ANALYZE&lt;/code&gt;, and a few DDL commands such as &lt;code&gt;CREATE INDEX&lt;/code&gt;. A &lt;code&gt;VACUUM&lt;/code&gt; or &lt;code&gt;ANALYZE&lt;/code&gt; operation that does not scan the entire table (which is commonly the case) will incrementally update the &lt;code&gt;reltuples&lt;/code&gt; count on the basis of the part of the table it did scan, resulting in an approximate value. In any case, the planner will scale the values it finds in &lt;code&gt;pg_class&lt;/code&gt; to match the current physical table size, thus obtaining a closer approximation.</source>
          <target state="translated">由于效率的原因， &lt;code&gt;reltuples&lt;/code&gt; 和 &lt;code&gt;relpages&lt;/code&gt; 不会即时更新，因此它们通常包含一些过时的值。它们由 &lt;code&gt;VACUUM&lt;/code&gt; ， &lt;code&gt;ANALYZE&lt;/code&gt; 和一些DDL命令（如 &lt;code&gt;CREATE INDEX&lt;/code&gt; )更新。不扫描整个表的 &lt;code&gt;VACUUM&lt;/code&gt; 或 &lt;code&gt;ANALYZE&lt;/code&gt; 操作（通常是这种情况）将根据它扫描的表的一部分来增量更新 &lt;code&gt;reltuples&lt;/code&gt; 计数，从而得到一个近似值。无论如何，计划者都会缩放在 &lt;code&gt;pg_class&lt;/code&gt; 中找到的值以匹配当前的物理表大小，从而获得更接近的近似值。</target>
        </trans-unit>
        <trans-unit id="2498c1aea650efa3ff6e721df8f862e425ed274a" translate="yes" xml:space="preserve">
          <source>For enum types (described in &lt;a href=&quot;datatype-enum&quot;&gt;Section 8.7&lt;/a&gt;), there are several functions that allow cleaner programming without hard-coding particular values of an enum type. These are listed in &lt;a href=&quot;functions-enum#FUNCTIONS-ENUM-TABLE&quot;&gt;Table 9.33&lt;/a&gt;. The examples assume an enum type created as:</source>
          <target state="translated">对于枚举类型（在&lt;a href=&quot;datatype-enum&quot;&gt;8.7节中进行了&lt;/a&gt;介绍），有几个函数可以使编程更加简洁，而无需对枚举类型的特定值进行硬编码。这些列在&lt;a href=&quot;functions-enum#FUNCTIONS-ENUM-TABLE&quot;&gt;表9.33中&lt;/a&gt;。这些示例假定创建的枚举类型为：</target>
        </trans-unit>
        <trans-unit id="7318a3eeb2a0e3f509084e3ec69e3b05be39dc31" translate="yes" xml:space="preserve">
          <source>For enum types (described in &lt;a href=&quot;datatype-enum&quot;&gt;Section 8.7&lt;/a&gt;), there are several functions that allow cleaner programming without hard-coding particular values of an enum type. These are listed in &lt;a href=&quot;functions-enum#FUNCTIONS-ENUM-TABLE&quot;&gt;Table 9.34&lt;/a&gt;. The examples assume an enum type created as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a25a74babc64151f8b4ea2da440ad370951a8d59" translate="yes" xml:space="preserve">
          <source>For every possible combination of rows from &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; (i.e., a Cartesian product), the joined table will contain a row consisting of all columns in &lt;code&gt;T1&lt;/code&gt; followed by all columns in &lt;code&gt;T2&lt;/code&gt;. If the tables have N and M rows respectively, the joined table will have N * M rows.</source>
          <target state="translated">对于来自 &lt;code&gt;T1&lt;/code&gt; 和 &lt;code&gt;T2&lt;/code&gt; 的行的每种可能组合（即笛卡尔乘积），联接表将包含一行，该行包含 &lt;code&gt;T1&lt;/code&gt; 中的所有列，然后是 &lt;code&gt;T2&lt;/code&gt; 中的所有列。如果表分别具有N行和M行，则联接表将具有N * M行。</target>
        </trans-unit>
        <trans-unit id="0c6d96910fe12ae8175afb9cb9ebf00927346590" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;@-&lt;/code&gt; is an allowed operator name, but &lt;code&gt;*-&lt;/code&gt; is not. This restriction allows PostgreSQL to parse SQL-compliant commands without requiring spaces between tokens.</source>
          <target state="translated">例如， &lt;code&gt;@-&lt;/code&gt; 是允许的运算符名称，但 &lt;code&gt;*-&lt;/code&gt; 不是。此限制使PostgreSQL可以解析与SQL兼容的命令，而无需在标记之间使用空格。</target>
        </trans-unit>
        <trans-unit id="7420785e3365d78ac1f9c68594d975825431286b" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;@-&lt;/code&gt; is an allowed operator name, but &lt;code&gt;*-&lt;/code&gt; is not. This restriction allows PostgreSQL to parse SQL-compliant queries without requiring spaces between tokens.</source>
          <target state="translated">例如， &lt;code&gt;@-&lt;/code&gt; 是允许的运算符名称，但 &lt;code&gt;*-&lt;/code&gt; 不是。此限制使PostgreSQL可以解析SQL兼容查询，而无需在标记之间使用空格。</target>
        </trans-unit>
        <trans-unit id="1270acc7d371bd67bf727e789543eb2fb05a795a" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;count(*)&lt;/code&gt; yields the total number of input rows; &lt;code&gt;count(f1)&lt;/code&gt; yields the number of input rows in which &lt;code&gt;f1&lt;/code&gt; is non-null, since &lt;code&gt;count&lt;/code&gt; ignores nulls; and &lt;code&gt;count(distinct f1)&lt;/code&gt; yields the number of distinct non-null values of &lt;code&gt;f1&lt;/code&gt;.</source>
          <target state="translated">例如， &lt;code&gt;count(*)&lt;/code&gt; 产生输入行的总数； &lt;code&gt;count(f1)&lt;/code&gt; 产生 &lt;code&gt;f1&lt;/code&gt; 非空的输入行 &lt;code&gt;count&lt;/code&gt; ，因为count忽略空值；和 &lt;code&gt;count(distinct f1)&lt;/code&gt; 产生的不同的非空值的数量 &lt;code&gt;f1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="241e368bd5f84d8bd9b37213abb0c1ce606628ca" translate="yes" xml:space="preserve">
          <source>For example, &lt;em&gt;&lt;code&gt;source_sql&lt;/code&gt;&lt;/em&gt; might produce a set something like:</source>
          <target state="translated">例如，&lt;em&gt; &lt;code&gt;source_sql&lt;/code&gt; &lt;/em&gt;可能会产生类似以下内容的集合：</target>
        </trans-unit>
        <trans-unit id="155faecb9306b9147a2e7777bee4e12a795c5623" translate="yes" xml:space="preserve">
          <source>For example, a common way to do case-insensitive comparisons is to use the &lt;code&gt;lower&lt;/code&gt; function:</source>
          <target state="translated">例如，进行不区分大小写的比较的常用方法是使用 &lt;code&gt;lower&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="d5c31174366767191298875589e027e626f3481e" translate="yes" xml:space="preserve">
          <source>For example, an application workload might consist of: 10% of changes are important customer details, while 90% of changes are less important data that the business can more easily survive if it is lost, such as chat messages between users.</source>
          <target state="translated">例如,一个应用程序的工作负载可能包括。10%的变化是重要的客户细节,而90%的变化是不太重要的数据,如果数据丢失,业务可以更容易地存活,比如用户之间的聊天信息。</target>
        </trans-unit>
        <trans-unit id="130ff877846a9ba145c6084d6c6d927c9f6f130d" translate="yes" xml:space="preserve">
          <source>For example, consider a bank database that contains balances for various customer accounts, as well as total deposit balances for branches. Suppose that we want to record a payment of $100.00 from Alice's account to Bob's account. Simplifying outrageously, the SQL commands for this might look like:</source>
          <target state="translated">例如,考虑一个银行数据库,其中包含各种客户账户的余额,以及各分行的总存款余额。假设我们想记录一笔100.00美元的付款,从Alice的账户到Bob的账户。简化得很离谱的是,这方面的SQL命令可能是这样的。</target>
        </trans-unit>
        <trans-unit id="2f3682a6f9ea0b208434ae010d3a1a17fff514e9" translate="yes" xml:space="preserve">
          <source>For example, consider the definition of a function, &lt;code&gt;dept&lt;/code&gt;, as:</source>
          <target state="translated">例如，将函数 &lt;code&gt;dept&lt;/code&gt; 的定义考虑为：</target>
        </trans-unit>
        <trans-unit id="0e0f997381e2092937165cc0bbee1c5517c59395" translate="yes" xml:space="preserve">
          <source>For example, consider this table definition:</source>
          <target state="translated">例如,考虑这个表的定义。</target>
        </trans-unit>
        <trans-unit id="8190f04d38d06a461e096583cfda36d375198e8e" translate="yes" xml:space="preserve">
          <source>For example, consider:</source>
          <target state="translated">例如,考虑:</target>
        </trans-unit>
        <trans-unit id="c33bc524f5320aea55d00b964061ae906c69106d" translate="yes" xml:space="preserve">
          <source>For example, if for some reason you want to disable the GEQO optimizer for a given database, you'd ordinarily have to either disable it for all databases or make sure that every connecting client is careful to issue &lt;code&gt;SET geqo TO off&lt;/code&gt;. To make this setting the default within a particular database, you can execute the command:</source>
          <target state="translated">例如，如果出于某种原因要为给定数据库禁用GEQO优化器，则通常必须为所有数据库禁用它，或者确保每个连接的客户端都小心地将 &lt;code&gt;SET geqo TO off&lt;/code&gt; 。要使此设置成为特定数据库中的默认设置，可以执行以下命令：</target>
        </trans-unit>
        <trans-unit id="3496b62777d29ce14330d5cf671f27e158b5c5b3" translate="yes" xml:space="preserve">
          <source>For example, in an &lt;code&gt;UPDATE&lt;/code&gt; command requiring both &lt;code&gt;SELECT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; permissions, if there are multiple applicable policies of each type, they will be combined as follows:</source>
          <target state="translated">For example, in an &lt;code&gt;UPDATE&lt;/code&gt; command requiring both &lt;code&gt;SELECT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; permissions, if there are multiple applicable policies of each type, they will be combined as follows:</target>
        </trans-unit>
        <trans-unit id="ab8f2f938fa83461064d386cea51bbcdc598d202" translate="yes" xml:space="preserve">
          <source>For example, suppose you have some JSON data from a GPS tracker that you would like to parse, such as:</source>
          <target state="translated">例如,假设你有一些来自GPS跟踪器的JSON数据,你想对这些数据进行解析,比如:。</target>
        </trans-unit>
        <trans-unit id="09ccf286e7b8e433098859f728308c846bcff18f" translate="yes" xml:space="preserve">
          <source>For example, suppose you would like to retrieve all heart rate values higher than 130. You can achieve this using the following expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06aef20d242f4af58541238d6758845220aef49a" translate="yes" xml:space="preserve">
          <source>For example, the following computes the square root of 2:</source>
          <target state="translated">例如,下面计算2的平方根。</target>
        </trans-unit>
        <trans-unit id="d06f05887749d75fd3c1c2ace4acae1fa3061b96" translate="yes" xml:space="preserve">
          <source>For example, the following finds the largest city population in each state:</source>
          <target state="translated">例如,下面找出各州最大的城市人口。</target>
        </trans-unit>
        <trans-unit id="da6cc196eb1d7b4036c8cbb26afabb02667647d5" translate="yes" xml:space="preserve">
          <source>For example, the following is (syntactically) valid SQL input:</source>
          <target state="translated">例如,以下是(语法上)有效的SQL输入。</target>
        </trans-unit>
        <trans-unit id="471cd6e5da58fc5eff7b7a62ed009e72a5a73a36" translate="yes" xml:space="preserve">
          <source>For example, the following query finds the names of all cities, including state capitals, that are located at an altitude over 500 feet:</source>
          <target state="translated">例如,下面的查询可以找到海拔超过500英尺的所有城市(包括州府)的名称。</target>
        </trans-unit>
        <trans-unit id="427b943c4463b780091a4e2b86abe42fce5db1c0" translate="yes" xml:space="preserve">
          <source>For example, the following query finds the names of all cities, including state capitals, that are located at an elevation over 500 feet:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8766b8f0ef1ada9c82b69e07f58a59c6fe1e88b5" translate="yes" xml:space="preserve">
          <source>For example, the operating system might provide a locale named &lt;code&gt;de_DE.utf8&lt;/code&gt;. &lt;code&gt;initdb&lt;/code&gt; would then create a collation named &lt;code&gt;de_DE.utf8&lt;/code&gt; for encoding &lt;code&gt;UTF8&lt;/code&gt; that has both &lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt; set to &lt;code&gt;de_DE.utf8&lt;/code&gt;. It will also create a collation with the &lt;code&gt;.utf8&lt;/code&gt; tag stripped off the name. So you could also use the collation under the name &lt;code&gt;de_DE&lt;/code&gt;, which is less cumbersome to write and makes the name less encoding-dependent. Note that, nevertheless, the initial set of collation names is platform-dependent.</source>
          <target state="translated">例如，操作系统可能提供一个名为 &lt;code&gt;de_DE.utf8&lt;/code&gt; 的语言环境。 &lt;code&gt;initdb&lt;/code&gt; 然后将创建一个名为整理 &lt;code&gt;de_DE.utf8&lt;/code&gt; 编码 &lt;code&gt;UTF8&lt;/code&gt; 同时具有 &lt;code&gt;LC_COLLATE&lt;/code&gt; 和 &lt;code&gt;LC_CTYPE&lt;/code&gt; 设置为 &lt;code&gt;de_DE.utf8&lt;/code&gt; 。它还将使用 &lt;code&gt;.utf8&lt;/code&gt; 标记删除名称后创建归类。因此，您也可以使用名称为 &lt;code&gt;de_DE&lt;/code&gt; 的排序规则，它简化了编写工作，并使名称不依赖于编码。但是请注意，归类名称的初始集合是平台相关的。</target>
        </trans-unit>
        <trans-unit id="3d1092481b703760dda3e1ee7578a2b981f6cc15" translate="yes" xml:space="preserve">
          <source>For example, the provided query might produce a set something like:</source>
          <target state="translated">例如,所提供的查询可能产生一个类似于以下的集合:</target>
        </trans-unit>
        <trans-unit id="52791448958e771d66ed4c02517edcf92f08b5b5" translate="yes" xml:space="preserve">
          <source>For example, this call requests 1000 values with a mean of 5 and a standard deviation of 3:</source>
          <target state="translated">例如,这个电话请求1000个平均值为5,标准差为3的值。</target>
        </trans-unit>
        <trans-unit id="2183a836f537bf498dab36fed767383696d0c956" translate="yes" xml:space="preserve">
          <source>For example, this command updates all products that have a price of 5 to have a price of 10:</source>
          <target state="translated">例如,该命令将所有价格为5的产品更新为价格为10的产品。</target>
        </trans-unit>
        <trans-unit id="324c8ee952ed40593d1680efa074498a02761679" translate="yes" xml:space="preserve">
          <source>For example, to check the total size of the data contained in a partitioned table &lt;code&gt;measurement&lt;/code&gt;, one could use the following query:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9b7cfd87b1d0ccc58641762031f79d95fb10548" translate="yes" xml:space="preserve">
          <source>For example, to find the ten most frequent words in a document collection:</source>
          <target state="translated">例如,要在一个文档集合中找到最常出现的十个词。</target>
        </trans-unit>
        <trans-unit id="e1319ad17250aad6d336666b42f8c3fc3dd702af" translate="yes" xml:space="preserve">
          <source>For example, we could create a domain over integers that accepts only positive integers:</source>
          <target state="translated">例如,我们可以在整数上创建一个只接受正整数的域。</target>
        </trans-unit>
        <trans-unit id="85f07a23cd87e159d728d36de17c8370d8afa3c6" translate="yes" xml:space="preserve">
          <source>For example, when querying the GPS data listed above, you can abstract from the fact that it stores an array of segments when using the lax mode:</source>
          <target state="translated">例如,在查询上面列出的GPS数据时,你可以抽象出使用涣散模式时,它存储的是一个数组段。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="c2d772c743b871fd1a2436437c4b730a2cfa282c" translate="yes" xml:space="preserve">
          <source>For examples of usage, see the regression test &lt;code&gt;sql/cube.sql&lt;/code&gt;.</source>
          <target state="translated">有关用法的示例，请参见回归测试 &lt;code&gt;sql/cube.sql&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2fc3e3d4179a2417bcd2f2e1fa817b3ae7d39bff" translate="yes" xml:space="preserve">
          <source>For examples of usage, see the regression test &lt;code&gt;sql/seg.sql&lt;/code&gt;.</source>
          <target state="translated">有关用法的示例，请参见回归测试 &lt;code&gt;sql/seg.sql&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3df123af765f2fc11785cbb335e07b630c980edc" translate="yes" xml:space="preserve">
          <source>For fixed-width types used in system tables, it is critical that the size and alignment defined in &lt;code&gt;pg_type&lt;/code&gt; agree with the way that the compiler will lay out the column in a structure representing a table row.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20343bba651c5588f7a79e82c05205aaef985eca" translate="yes" xml:space="preserve">
          <source>For foreign servers, allows creation of foreign tables using the server. Grantees may also create, alter, or drop their own user mappings associated with that server.</source>
          <target state="translated">对于国外服务器,允许使用该服务器创建国外表。受赠人也可以创建、更改或删除自己与该服务器相关的用户映射。</target>
        </trans-unit>
        <trans-unit id="f6b32aab859f58749932d6c6be03c33f6bd3e7d6" translate="yes" xml:space="preserve">
          <source>For foreign-data wrappers, allows creation of new servers using the foreign-data wrapper.</source>
          <target state="translated">对于国外数据包装器,允许使用国外数据包装器创建新的服务器。</target>
        </trans-unit>
        <trans-unit id="781dea1ed3385a0b699638076216344a55a6bbec" translate="yes" xml:space="preserve">
          <source>For functions and operators, an object in the search path is said to be visible if there is no object of the same name &lt;em&gt;and argument data type(s)&lt;/em&gt; earlier in the path. For operator classes and families, both the name and the associated index access method are considered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db80d63b0cfce8e9c534eefc3bfa1133ade5f443" translate="yes" xml:space="preserve">
          <source>For functions built into PostgreSQL itself, the bitcode is installed into &lt;code&gt;$pkglibdir/bitcode/postgres&lt;/code&gt;.</source>
          <target state="translated">对于PostgreSQL本身内置的函数，位代码安装在 &lt;code&gt;$pkglibdir/bitcode/postgres&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="76b109732d62dd01020a7a1cd75adf97d78489a2" translate="yes" xml:space="preserve">
          <source>For functions, &lt;code&gt;db_procedure:{execute}&lt;/code&gt; will be checked when user tries to execute a function as a part of query, or using fast-path invocation. If this function is a trusted procedure, it also checks &lt;code&gt;db_procedure:{entrypoint}&lt;/code&gt; permission to check whether it can perform as entry point of trusted procedure.</source>
          <target state="translated">对于函数，当用户尝试执行函数作为查询的一部分或使用快速路径调用时，将检查 &lt;code&gt;db_procedure:{execute}&lt;/code&gt; 。如果此函数是受信任的过程，它还将检查 &lt;code&gt;db_procedure:{entrypoint}&lt;/code&gt; 权限，以检查它是否可以作为受信任过程的入口点执行。</target>
        </trans-unit>
        <trans-unit id="50f73f941e99db6aff704bfc76eaf9cb53fc581b" translate="yes" xml:space="preserve">
          <source>For further examples of scripts used for bulk editing, see &lt;code&gt;convert_oid2name.pl&lt;/code&gt; and &lt;code&gt;remove_pg_type_oid_symbols.pl&lt;/code&gt; attached to this message: &lt;a href=&quot;https://www.postgresql.org/message-id/CAJVSVGVX8gXnPm+Xa=DxR7kFYprcQ1tNcCT5D0O3ShfnM6jehA@mail.gmail.com&quot;&gt;https://www.postgresql.org/message-id/CAJVSVGVX8gXnPm+Xa=DxR7kFYprcQ1tNcCT5D0O3ShfnM6jehA@mail.gmail.com&lt;/a&gt;</source>
          <target state="translated">对于脚本的用于批量编辑看到进一步的实例中， &lt;code&gt;convert_oid2name.pl&lt;/code&gt; 和 &lt;code&gt;remove_pg_type_oid_symbols.pl&lt;/code&gt; 附加到此消息：&lt;a href=&quot;https://www.postgresql.org/message-id/CAJVSVGVX8gXnPm+Xa=DxR7kFYprcQ1tNcCT5D0O3ShfnM6jehA@mail.gmail.com&quot;&gt;https://www.postgresql.org/message-id/CAJVSVGVX8gXnPm+Xa=DxR7kFYprcQ1tNcCT5D0O3ShfnM6jehA@mail.gmail.com&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="95d0a9533934206493197f921cdd921bcea9067d" translate="yes" xml:space="preserve">
          <source>For historical reasons, &lt;code&gt;ALTER TABLE&lt;/code&gt; can be used with sequences too; but the only variants of &lt;code&gt;ALTER TABLE&lt;/code&gt; that are allowed with sequences are equivalent to the forms shown above.</source>
          <target state="translated">由于历史原因， &lt;code&gt;ALTER TABLE&lt;/code&gt; 也可以与序列一起使用。但是序列允许的 &lt;code&gt;ALTER TABLE&lt;/code&gt; 的唯一变体与上述形式等效。</target>
        </trans-unit>
        <trans-unit id="821eb91f933952c5c235fc4f1d7ebbeff4650e0a" translate="yes" xml:space="preserve">
          <source>For historical reasons, &lt;code&gt;ALTER TABLE&lt;/code&gt; can be used with views too; but the only variants of &lt;code&gt;ALTER TABLE&lt;/code&gt; that are allowed with views are equivalent to the ones shown above.</source>
          <target state="translated">由于历史原因， &lt;code&gt;ALTER TABLE&lt;/code&gt; 也可以与视图一起使用。但是视图允许的 &lt;code&gt;ALTER TABLE&lt;/code&gt; 的唯一变体与上面显示的等同。</target>
        </trans-unit>
        <trans-unit id="fd9d930dc3517bba2d1837bdddba003f94a1e402" translate="yes" xml:space="preserve">
          <source>For historical reasons, the &lt;code&gt;inet_ops&lt;/code&gt; operator class is not the default class for types &lt;code&gt;inet&lt;/code&gt; and &lt;code&gt;cidr&lt;/code&gt;. To use it, mention the class name in &lt;code&gt;CREATE INDEX&lt;/code&gt;, for example</source>
          <target state="translated">由于历史原因， &lt;code&gt;inet_ops&lt;/code&gt; 运算符类不是 &lt;code&gt;inet&lt;/code&gt; 和 &lt;code&gt;cidr&lt;/code&gt; 类型的默认类。要使用它，请在 &lt;code&gt;CREATE INDEX&lt;/code&gt; 中提及类名，例如</target>
        </trans-unit>
        <trans-unit id="c4d4c412fef208bbedad98fd29f400c744b1038b" translate="yes" xml:space="preserve">
          <source>For historical reasons, the &lt;code&gt;penalty&lt;/code&gt; function doesn't just return a &lt;code&gt;float&lt;/code&gt; result; instead it has to store the value at the location indicated by the third argument. The return value per se is ignored, though it's conventional to pass back the address of that argument.</source>
          <target state="translated">由于历史原因， &lt;code&gt;penalty&lt;/code&gt; 函数不仅会返回 &lt;code&gt;float&lt;/code&gt; 可能会返回结果。相反，它必须将值存储在第三个参数指示的位置。返回值本身被忽略，尽管按惯例传回该参数的地址。</target>
        </trans-unit>
        <trans-unit id="602a56377f9c453998804c9239a3f0e16670f12d" translate="yes" xml:space="preserve">
          <source>For historical reasons, the &lt;code&gt;same&lt;/code&gt; function doesn't just return a Boolean result; instead it has to store the flag at the location indicated by the third argument. The return value per se is ignored, though it's conventional to pass back the address of that argument.</source>
          <target state="translated">由于历史原因， &lt;code&gt;same&lt;/code&gt; 函数不仅会返回布尔结果；它还会返回布尔值。相反，它必须将标志存储在第三个参数指示的位置。返回值本身被忽略，尽管按惯例传回该参数的地址。</target>
        </trans-unit>
        <trans-unit id="21712eeec3b375c143c6b302dd00ef3b3fdb1287" translate="yes" xml:space="preserve">
          <source>For historical reasons, the function &lt;code&gt;md5&lt;/code&gt; returns a hex-encoded value of type &lt;code&gt;text&lt;/code&gt; whereas the SHA-2 functions return type &lt;code&gt;bytea&lt;/code&gt;. Use the functions &lt;a href=&quot;functions-binarystring#FUNCTION-ENCODE&quot;&gt;&lt;code&gt;encode&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;functions-binarystring#FUNCTION-DECODE&quot;&gt;&lt;code&gt;decode&lt;/code&gt;&lt;/a&gt; to convert between the two. For example write &lt;code&gt;encode(sha256('abc'), 'hex')&lt;/code&gt; to get a hex-encoded text representation, or &lt;code&gt;decode(md5('abc'), 'hex')&lt;/code&gt; to get a &lt;code&gt;bytea&lt;/code&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edf5a6774e8ddac6655d000c335cd8365c752c22" translate="yes" xml:space="preserve">
          <source>For identity columns, the &lt;code&gt;COPY FROM&lt;/code&gt; command will always write the column values provided in the input data, like the &lt;code&gt;INSERT&lt;/code&gt; option &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt;.</source>
          <target state="translated">对于标识列， &lt;code&gt;COPY FROM&lt;/code&gt; 命令将始终写入输入数据中提供的列值，例如 &lt;code&gt;INSERT&lt;/code&gt; 选项 &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="330e059840df0474749e60d131c132790cef269d" translate="yes" xml:space="preserve">
          <source>For index methods that support ordered scans (currently, only B-tree), the optional clauses &lt;code&gt;ASC&lt;/code&gt;, &lt;code&gt;DESC&lt;/code&gt;, &lt;code&gt;NULLS FIRST&lt;/code&gt;, and/or &lt;code&gt;NULLS LAST&lt;/code&gt; can be specified to modify the sort ordering of the index. Since an ordered index can be scanned either forward or backward, it is not normally useful to create a single-column &lt;code&gt;DESC&lt;/code&gt; index &amp;mdash; that sort ordering is already available with a regular index. The value of these options is that multicolumn indexes can be created that match the sort ordering requested by a mixed-ordering query, such as &lt;code&gt;SELECT ... ORDER BY x ASC, y DESC&lt;/code&gt;. The &lt;code&gt;NULLS&lt;/code&gt; options are useful if you need to support &amp;ldquo;nulls sort low&amp;rdquo; behavior, rather than the default &amp;ldquo;nulls sort high&amp;rdquo;, in queries that depend on indexes to avoid sorting steps.</source>
          <target state="translated">对于支持有序扫描的索引方法（当前仅支持B树），可以指定可选子句 &lt;code&gt;ASC&lt;/code&gt; ， &lt;code&gt;DESC&lt;/code&gt; ， &lt;code&gt;NULLS FIRST&lt;/code&gt; 和/或 &lt;code&gt;NULLS LAST&lt;/code&gt; 来修改索引的排序顺序。由于可以向前或向后扫描有序索引，因此创建单列 &lt;code&gt;DESC&lt;/code&gt; 索引通常没有用-常规索引已经可以使用排序顺序。这些选项的价值在于可以创建与混合排序查询所请求的排序顺序匹配的多列索引，例如 &lt;code&gt;SELECT ... ORDER BY x ASC, y DESC&lt;/code&gt; 。该 &lt;code&gt;NULLS&lt;/code&gt; 如果您需要在依赖索引的查询中避免排序步骤，则在需要支持&amp;ldquo; null排序低&amp;rdquo;的行为而不是默认的&amp;ldquo; null排序高&amp;rdquo;的行为时，此选项很有用。</target>
        </trans-unit>
        <trans-unit id="6b918ccfc93956e12afed439ea7d7ee85b4aa64b" translate="yes" xml:space="preserve">
          <source>For indexes, what is tracked is entirely-unused pages, rather than free space within pages. Therefore, the values are not meaningful, just whether a page is full or empty.</source>
          <target state="translated">对于索引来说,跟踪的是完全未使用的页面,而不是页面内的自由空间。因此,这些值是没有意义的,只是一个页面是满还是空。</target>
        </trans-unit>
        <trans-unit id="4513c5edb4e83b5f0af5e4602920aeca55f3099c" translate="yes" xml:space="preserve">
          <source>For information about writing new extensions, see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-extensions.html&quot;&gt;Section 37.17&lt;/a&gt;.</source>
          <target state="translated">有关编写新扩展的信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/extend-extensions.html&quot;&gt;第37.17节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6332e24d7bf340ffc8bee2de4ec1b88cdff7c6ee" translate="yes" xml:space="preserve">
          <source>For information about writing new extensions, see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-extensions.html&quot;&gt;Section 37.17&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f9e4e41c768a47414e220546e9436ef01464205" translate="yes" xml:space="preserve">
          <source>For inheritance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac175c388fdbc502fc95fbb47ec000df9ac1c1ac" translate="yes" xml:space="preserve">
          <source>For instance, the example given in the previous section would also work as</source>
          <target state="translated">例如,上一节中给出的例子也可以作为</target>
        </trans-unit>
        <trans-unit id="aa594066fb4185dd4bf2bb314c6dc858ea1dc91b" translate="yes" xml:space="preserve">
          <source>For large tables, &lt;code&gt;ANALYZE&lt;/code&gt; takes a random sample of the table contents, rather than examining every row. This allows even very large tables to be analyzed in a small amount of time. Note, however, that the statistics are only approximate, and will change slightly each time &lt;code&gt;ANALYZE&lt;/code&gt; is run, even if the actual table contents did not change. This might result in small changes in the planner's estimated costs shown by &lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt;. In rare situations, this non-determinism will cause the planner's choices of query plans to change after &lt;code&gt;ANALYZE&lt;/code&gt; is run. To avoid this, raise the amount of statistics collected by &lt;code&gt;ANALYZE&lt;/code&gt;, as described below.</source>
          <target state="translated">对于大型表， &lt;code&gt;ANALYZE&lt;/code&gt; 会从表内容中随机抽取一个样本，而不是检查每一行。这样就可以在很短的时间内分析非常大的表。但是请注意，统计信息只是近似的，并且每次运行 &lt;code&gt;ANALYZE&lt;/code&gt; 时统计信息都会略有变化，即使实际的表内容没有变化。这可能会导致&lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN所&lt;/a&gt;显示的计划者估算成本发生微小变化。在极少数情况下，这种不确定性会导致计划者在运行 &lt;code&gt;ANALYZE&lt;/code&gt; 后更改查询计划的选择。为避免这种情况，请增加 &lt;code&gt;ANALYZE&lt;/code&gt; 收集的统计信息的数量，如下所述。</target>
        </trans-unit>
        <trans-unit id="d9def7e76f8e004e7c6ff9a43935027a0e8494d2" translate="yes" xml:space="preserve">
          <source>For magnetic drives, a good starting point for this setting is the number of separate drives comprising a RAID 0 stripe or RAID 1 mirror being used for the database. (For RAID 5 the parity drive should not be counted.) However, if the database is often busy with multiple queries issued in concurrent sessions, lower values may be sufficient to keep the disk array busy. A value higher than needed to keep the disks busy will only result in extra CPU overhead. SSDs and other memory-based storage can often process many concurrent requests, so the best value might be in the hundreds.</source>
          <target state="translated">对于磁驱动器,此设置的一个良好起点是由数据库使用的 RAID 0 条带或 RAID 1 镜像组成的独立驱动器的数量。(对于 RAID 5,不应计算奇偶校验驱动器)。(对于RAID 5,奇偶校验驱动器不应计算在内。)然而,如果数据库经常忙于在并发会话中发出多个查询,较低的值可能足以保持磁盘阵列繁忙。高于保持磁盘繁忙所需的值只会导致额外的CPU开销。SSD和其他基于内存的存储通常可以处理许多并发请求,因此最佳值可能是数百个。</target>
        </trans-unit>
        <trans-unit id="db0641cab9eeea26c49a646ff42537d081fed018" translate="yes" xml:space="preserve">
          <source>For more detail see &lt;a href=&quot;functions-comparisons&quot;&gt;Section 9.23&lt;/a&gt;. Row constructors can also be used in connection with subqueries, as discussed in &lt;a href=&quot;functions-subquery&quot;&gt;Section 9.22&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，请参见&lt;a href=&quot;functions-comparisons&quot;&gt;第9.23节&lt;/a&gt;。行构造器也可以与子查询结合使用，如&lt;a href=&quot;functions-subquery&quot;&gt;第9.22节所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="18338d5f8684a02701c33055a650f503dc79428a" translate="yes" xml:space="preserve">
          <source>For more detail see &lt;a href=&quot;functions-comparisons&quot;&gt;Section 9.24&lt;/a&gt;. Row constructors can also be used in connection with subqueries, as discussed in &lt;a href=&quot;functions-subquery&quot;&gt;Section 9.23&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cb95316ba3180c7abceba8b606b2390f6f76c76" translate="yes" xml:space="preserve">
          <source>For more details about the structure of B-tree indexes, see &lt;a href=&quot;btree-implementation#BTREE-STRUCTURE&quot;&gt;Section 63.4.1&lt;/a&gt;. For more details about deduplication and posting lists, see &lt;a href=&quot;btree-implementation#BTREE-DEDUPLICATION&quot;&gt;Section 63.4.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fb8d2224d716120397e37c095ccc4fc811af648" translate="yes" xml:space="preserve">
          <source>For more details see &lt;code&gt;man gpg&lt;/code&gt;, &lt;a href=&quot;https://www.gnupg.org/gph/en/manual.html&quot;&gt;The GNU Privacy Handbook&lt;/a&gt; and other documentation on &lt;a href=&quot;https://www.gnupg.org/&quot;&gt;https://www.gnupg.org/&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，请参见 &lt;code&gt;man gpg&lt;/code&gt; ，&lt;a href=&quot;https://www.gnupg.org/gph/en/manual.html&quot;&gt;《 GNU隐私手册》&lt;/a&gt;和其他文档，&lt;a href=&quot;https://www.gnupg.org/&quot;&gt;网址为https://www.gnupg.org/&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2c6217eaee5aceb86ffc3acacd99e4351f7c6bdf" translate="yes" xml:space="preserve">
          <source>For more examples of using &lt;code&gt;jsonpath&lt;/code&gt; operators and methods within path expressions, see &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH-OPERATORS&quot;&gt;Section 9.15.2.3&lt;/a&gt;.</source>
          <target state="translated">有关在路径表达式中使用 &lt;code&gt;jsonpath&lt;/code&gt; 运算符和方法的更多示例，请参见&lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH-OPERATORS&quot;&gt;第9.15.2.3节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="79cf6e3cf917058a0ed742c04d1ca6289aff5a38" translate="yes" xml:space="preserve">
          <source>For more information on each row-level lock mode, refer to &lt;a href=&quot;explicit-locking#LOCKING-ROWS&quot;&gt;Section 13.3.2&lt;/a&gt;.</source>
          <target state="translated">有关每种行级锁定模式的更多信息，请参见&lt;a href=&quot;explicit-locking#LOCKING-ROWS&quot;&gt;第13.3.2节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e2f8f8e747ece8758e1b6ba702e3c8c61e76fde3" translate="yes" xml:space="preserve">
          <source>For more information on parallel query, see &lt;a href=&quot;https://www.postgresql.org/docs/12/parallel-query.html&quot;&gt;Chapter 15&lt;/a&gt;.</source>
          <target state="translated">有关并行查询的更多信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/parallel-query.html&quot;&gt;第15章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c49142dd945917208a161ed15ae4eabdc1feb316" translate="yes" xml:space="preserve">
          <source>For more information on parallel query, see &lt;a href=&quot;https://www.postgresql.org/docs/13/parallel-query.html&quot;&gt;Chapter 15&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e9f192fbf0623739197082afd424ce16d42f59b" translate="yes" xml:space="preserve">
          <source>For more information on prepared statements, see &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt;.</source>
          <target state="translated">有关&lt;a href=&quot;sql-prepare&quot;&gt;预&lt;/a&gt;准备语句的更多信息，请参见PREPARE。</target>
        </trans-unit>
        <trans-unit id="d65fb0f770cbb9d7773305feb7d0f9aff8503a9d" translate="yes" xml:space="preserve">
          <source>For more information on query planning and the statistics collected by PostgreSQL for that purpose, see the &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; documentation.</source>
          <target state="translated">有关查询计划和PostgreSQL为此目的收集的统计信息的更多信息，请参见&lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="7b483319bfce6914eeb2d77590a6f05860cc2822" translate="yes" xml:space="preserve">
          <source>For more information on row security policies, see &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt;.</source>
          <target state="translated">有关行安全策略的更多信息，请参见&lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6cd57e75dd7c6d9a0bba32ec8cf0aedac82282ff" translate="yes" xml:space="preserve">
          <source>For more information on schema handling, see &lt;a href=&quot;ddl-schemas&quot;&gt;Section 5.9&lt;/a&gt;. In particular, the default configuration is suitable only when the database has a single user or a few mutually-trusting users.</source>
          <target state="translated">有关模式处理的更多信息，请参见&lt;a href=&quot;ddl-schemas&quot;&gt;第5.9节&lt;/a&gt;。特别是，仅当数据库具有单个用户或几个相互信任的用户时，默认配置才适用。</target>
        </trans-unit>
        <trans-unit id="7a7cfc539431d71689ab3e6fc5a89a4a3ad68497" translate="yes" xml:space="preserve">
          <source>For more information on tablespaces, see &lt;a href=&quot;manage-ag-tablespaces&quot;&gt;Section 22.6&lt;/a&gt;.</source>
          <target state="translated">有关表空间的更多信息，请参见&lt;a href=&quot;manage-ag-tablespaces&quot;&gt;第22.6节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="156d896fc36c27213e33f6486192aeb35b072ae4" translate="yes" xml:space="preserve">
          <source>For more information on the creation and usage of prepared statements, see &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt;.</source>
          <target state="translated">有关准备语句的创建和使用的更多信息，请参见&lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5233548445314b3aa1fa8672502b639b8263c6c7" translate="yes" xml:space="preserve">
          <source>For more information see &lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4dd314c2b9f8c0a5f4a4e41c5efbe9fea6718856" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;continuous-archiving&quot;&gt;Section 25.3&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c8ecf019aee64acad91826dcc7e9b171f0be1a3" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;datatype-oid&quot;&gt;Section 8.19&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20226217ec3afb436b4729b0abf0339c4c1dd2ec" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;ddl-constraints&quot;&gt;Section 5.4&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1adc5bd35432adf2eb7a774b8a34ae4fb1d4e1a" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;ddl-schemas&quot;&gt;Section 5.9&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d79b9c727fe67702d70b6fd9999ab32eca117acb" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.21&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="980ff7abe737ed29a2eef6afee49381fad9641d4" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;https://www.postgresql.org/docs/13/bgworker.html&quot;&gt;Chapter 47&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="780f7f92af5944157940b8ad375fbf026ad4460e" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-extensions.html&quot;&gt;Section 37.17&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dc856ae16ea4020ceefa8b323354b5bb864a7ae" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;logfile-maintenance&quot;&gt;Section 24.3&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1290c10776f1a21730c9d3d4d887ff27a87c6292" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;manage-ag-overview&quot;&gt;Section 22.1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5e210e5231f27abc7ef42e8fb21b52c35cb3c9d" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;manage-ag-tablespaces&quot;&gt;Section 22.6&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="214a61df4ffb5c9aacd0276fef415f0fd717971e" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;monitoring-stats&quot;&gt;Section 27.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69f071548ff8e2bf11f53bb59f5a867ac246fb29" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;routine-vacuuming&quot;&gt;Section 24.1&lt;/a&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14fb86a709f50b66214aa6322a762395267a59e5" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="998da92e58bf1cb4909e97dd5246a04a2cb1c611" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;runtime-config-connection&quot;&gt;Section 19.3&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e9cee8d5c892db192aebeb281deff09ba3186a0" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;runtime-config-logging&quot;&gt;Section 19.8&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57e27342dd33a63d74ae836f45de53d4f70ca811" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;runtime-config-resource#RUNTIME-CONFIG-RESOURCE-BACKGROUND-WRITER&quot;&gt;Section 19.4.5&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2e214c810c78d30da88471e9743b6fb079f8dc4" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;runtime-config-resource#RUNTIME-CONFIG-RESOURCE-MEMORY&quot;&gt;Section 19.4.1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57a39e47097148bf2b804e705bbfd7be10e3d22f" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;runtime-config-wal&quot;&gt;Section 19.5&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe101332ab82e0d86e6d3cf0a47fcad58b5e3cfd" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;server-start&quot;&gt;Section 18.3&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f6e986dbd3152279b0853a52133ca23ef852275" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6b52e4cf0af72d79422d38425c0eeb1d0943c31" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-commit&quot;&gt;COMMIT&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7989d717cddceab28ddd2a4acba5581bf4509f56" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-createcast&quot;&gt;CREATE CAST&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feb082d47f0b69434fc625c629e1b305bb95391f" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-createforeigndatawrapper&quot;&gt;CREATE FOREIGN DATA WRAPPER&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51d486d6d4cc03e053d0925cca9ae38c095cdd43" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72aa113f96629050f4ef19a2cf379f2dc52cd5f0" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3943a2288ce11b53333fada41110757ed47b902a" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cae845df4a402ad075e8e3db9aa71b1455d17920" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-creatematerializedview&quot;&gt;CREATE MATERIALIZED VIEW&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ed6c934a5ed774b78b51edbb7e5027d4516dcb3" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-createprocedure&quot;&gt;CREATE PROCEDURE&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee0c9366d5740e64d2536225af931f9da1914bac" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49d706ea8beef4d7260b021441cd0098fccedf8c" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-createserver&quot;&gt;CREATE SERVER&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b19a5a64f6dac1c732b3ebb9d66397bfe70bd79" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1615c2ef2a9a56a9cc0e423d2083415987ccd74" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b63a860f4649a0112c2786fe1bdba3d786899d1" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-createusermapping&quot;&gt;CREATE USER MAPPING&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1020a498be2604ab4d7cd1896dffc51885aca810" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-createview&quot;&gt;CREATE VIEW&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a24d18f5506b6ee9a84a8cd84f78661ee9adf77f" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-delete&quot;&gt;DELETE&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db99c706cdb285235578b6aba63b47fdabf2194c" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71b270bd4563c9f2060a6d80c982b5fe2fcbf480" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e77ed2d4e2d96aeecd1142f94b637f23ca5612a5" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e64300e8df12c926d53c45eb642cc98e387af7f" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-rollback&quot;&gt;ROLLBACK&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fb228d5dbcc85882f9f4b3d191b9ca72d6f348f" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91dbc01352523da4727aedf894f80ad7b6f798c5" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2032925ebdd4aacf138805e17a31b7d2c9007880" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d94d1228165f626fcdafbcea9f9f512b2bcebb2" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;storage-file-layout&quot;&gt;Section 68.1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42a31e142177fa23ae77a8cce8af185fdd1360b0" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;storage-fsm&quot;&gt;Section 68.3&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24d65fe6857f379faaff0de74d64cfde9e65cff9" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7ba20758a038db38b1afb4465c53d889c714355" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;transaction-iso&quot;&gt;Section 13.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dae07da77c31ebbc8bba210c0470d446f27cdfe2" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;tutorial-window&quot;&gt;Section 3.5&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aca210e015407bccd6e5fff2f3af7fc7dc6dfad" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;wal-configuration&quot;&gt;Section 29.4&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccf0df41e7a0c42924a513c55a49a3c1fe56d531" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;wal-internals&quot;&gt;Section 29.5&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c85bc4c828173ae286d66f5092152fb72a510a4c" translate="yes" xml:space="preserve">
          <source>For more on replication slots, see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Section 26.2.6&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;.</source>
          <target state="translated">有关复制插槽的更多信息，请参见&lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;第26.2.6节&lt;/a&gt;和&lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;第48章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="36e5b0eb43b67d12107b8b4cd8c78c78e3b8f7db" translate="yes" xml:space="preserve">
          <source>For more on replication slots, see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Section 26.2.6&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f67c610531547fa3cca67f0d1f83f00712e9e930" translate="yes" xml:space="preserve">
          <source>For most English-text-searching applications the above words would be considered non-normalized, but &lt;code&gt;tsvector&lt;/code&gt; doesn't care. Raw document text should usually be passed through &lt;code&gt;to_tsvector&lt;/code&gt; to normalize the words appropriately for searching:</source>
          <target state="translated">对于大多数英语文本搜索应用程序，以上单词将被视为未规范化，但 &lt;code&gt;tsvector&lt;/code&gt; 无关紧要。原始文档文本通常应通过 &lt;code&gt;to_tsvector&lt;/code&gt; 传递，以适当地标准化单词以进行搜索：</target>
        </trans-unit>
        <trans-unit id="d11cb8ba24b12fd4341f66b81cfe8da1a67ba46b" translate="yes" xml:space="preserve">
          <source>For most index methods, the speed of creating an index is dependent on the setting of &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt;. Larger values will reduce the time needed for index creation, so long as you don't make it larger than the amount of memory really available, which would drive the machine into swapping.</source>
          <target state="translated">对于大多数索引方法，创建索引的速度取决于&lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt;的设置。较大的值将减少创建索引所需的时间，只要您不使其大于实际可用的内存量即可，这会促使计算机进行交换。</target>
        </trans-unit>
        <trans-unit id="0c13a44404e4e32e101f6de95dbe745d7a8d8623" translate="yes" xml:space="preserve">
          <source>For most kinds of object, only the object's owner can set the comment. Roles don't have owners, so the rule for &lt;code&gt;COMMENT ON ROLE&lt;/code&gt; is that you must be superuser to comment on a superuser role, or have the &lt;code&gt;CREATEROLE&lt;/code&gt; privilege to comment on non-superuser roles. Likewise, access methods don't have owners either; you must be superuser to comment on an access method. Of course, a superuser can comment on anything.</source>
          <target state="translated">对于大多数对象，只有对象的所有者才能设置注释。角色没有所有者，因此 &lt;code&gt;COMMENT ON ROLE&lt;/code&gt; 的规则是您必须是超级用户才能对超级用户角色进行评论，或者具有 &lt;code&gt;CREATEROLE&lt;/code&gt; 特权才能对非超级用户角色进行评论。同样，访问方法也没有所有者。您必须是超级用户才能评论访问方法。当然，超级用户可以对任何内容发表评论。</target>
        </trans-unit>
        <trans-unit id="9837f0c6ad7a5aa6e60539d85268c2d3ed2d116e" translate="yes" xml:space="preserve">
          <source>For new relations being written during a DDL operation that requires a table rewrite, this contains the OID of the original relation; otherwise 0. That state is only visible internally; this field should never contain anything other than 0 for a user-visible relation.</source>
          <target state="translated">对于在需要重写表的DDL操作过程中写入的新关系,这个字段包含了原始关系的OID,否则为0,这个状态只在内部可见;对于用户可见的关系,这个字段不应该包含任何0以外的内容。</target>
        </trans-unit>
        <trans-unit id="db2d4f573696790d499c4fdcbed43171e9eb9774" translate="yes" xml:space="preserve">
          <source>For non-anonymous binds, &lt;code&gt;ldapbinddn&lt;/code&gt; and &lt;code&gt;ldapbindpasswd&lt;/code&gt; must be specified as separate options.</source>
          <target state="translated">对于非匿名绑定，必须将 &lt;code&gt;ldapbinddn&lt;/code&gt; 和 &lt;code&gt;ldapbindpasswd&lt;/code&gt; 指定为单独的选项。</target>
        </trans-unit>
        <trans-unit id="8e8b858bd4de863389670e9fe6770c7877741b6a" translate="yes" xml:space="preserve">
          <source>For non-null inputs, &lt;code&gt;IS DISTINCT FROM&lt;/code&gt; is the same as the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator. However, if both inputs are null it returns false, and if only one input is null it returns true. Similarly, &lt;code&gt;IS NOT DISTINCT FROM&lt;/code&gt; is identical to &lt;code&gt;=&lt;/code&gt; for non-null inputs, but it returns true when both inputs are null, and false when only one input is null. Thus, these predicates effectively act as though null were a normal data value, rather than &amp;ldquo;unknown&amp;rdquo;.</source>
          <target state="translated">对于非空输入， &lt;code&gt;IS DISTINCT FROM&lt;/code&gt; 与 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 运算符相同。但是，如果两个输入均为null，则返回false，如果只有一个输入为null，则返回true。类似地，对于非空输入， &lt;code&gt;IS NOT DISTINCT FROM&lt;/code&gt; 与 &lt;code&gt;=&lt;/code&gt; 相同，但是当两个输入均为空时，它返回true；而当只有一个输入为空时，它返回false。因此，这些谓词有效地充当空值是正常数据值，而不是&amp;ldquo;未知&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="452c316e78163cb01fa71da21305864e3d992733" translate="yes" xml:space="preserve">
          <source>For noninternal languages this references the language handler, which is a special function that is responsible for executing all functions that are written in the particular language</source>
          <target state="translated">对于非内部语言,它引用了语言处理程序,它是一个特殊的函数,负责执行所有用特定语言编写的函数</target>
        </trans-unit>
        <trans-unit id="08f7ad6afcfac3234695bfac00c247d3c8fb6960" translate="yes" xml:space="preserve">
          <source>For operator classes that do not use prefixes, &lt;code&gt;prefixType&lt;/code&gt; can be set to &lt;code&gt;VOIDOID&lt;/code&gt;. Likewise, for operator classes that do not use node labels, &lt;code&gt;labelType&lt;/code&gt; can be set to &lt;code&gt;VOIDOID&lt;/code&gt;. &lt;code&gt;canReturnData&lt;/code&gt; should be set true if the operator class is capable of reconstructing the originally-supplied index value. &lt;code&gt;longValuesOK&lt;/code&gt; should be set true only when the &lt;code&gt;attType&lt;/code&gt; is of variable length and the operator class is capable of segmenting long values by repeated suffixing (see &lt;a href=&quot;spgist-implementation#SPGIST-LIMITS&quot;&gt;Section 65.4.1&lt;/a&gt;).</source>
          <target state="translated">对于不使用前缀操作符类， &lt;code&gt;prefixType&lt;/code&gt; 可以设置为 &lt;code&gt;VOIDOID&lt;/code&gt; 。同样，对于不使用节点标签操作类， &lt;code&gt;labelType&lt;/code&gt; 可以设置为 &lt;code&gt;VOIDOID&lt;/code&gt; 。如果操作员类能够重建原始提供的索引值，则应将 &lt;code&gt;canReturnData&lt;/code&gt; 设置为true。 &lt;code&gt;longValuesOK&lt;/code&gt; 仅当应设置真 &lt;code&gt;attType&lt;/code&gt; 是可变长度的并且操作者类能够通过重复后面添加分割长值（见&lt;a href=&quot;spgist-implementation#SPGIST-LIMITS&quot;&gt;章节65.4.1&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8734e694c951a6833bd37344ff08949a24e29e7a" translate="yes" xml:space="preserve">
          <source>For optimal performance when relying on Serializable transactions for concurrency control, these issues should be considered:</source>
          <target state="translated">为了在依赖Serializable事务进行并发控制时获得最佳性能,应该考虑这些问题。</target>
        </trans-unit>
        <trans-unit id="6009f4ee46750a96d20ce23527cf9e0e8cb726de" translate="yes" xml:space="preserve">
          <source>For ordered-set (including hypothetical-set) aggregates, the final function receives not only the final state value, but also the values of all the direct arguments.</source>
          <target state="translated">对于有序集(包括假设集)聚合,最终函数不仅接收最终状态值,还接收所有直接参数的值。</target>
        </trans-unit>
        <trans-unit id="be6a9c4c63ed11fa1c2795f316b3b8e9e65b1b58" translate="yes" xml:space="preserve">
          <source>For ordered-set (including hypothetical-set) aggregates, the state transition function receives only the current state value and the aggregated arguments, not the direct arguments. Otherwise it is the same.</source>
          <target state="translated">对于有序集(包括假设集)集合,状态转换函数只接收当前状态值和集合参数,不接收直接参数。否则是一样的。</target>
        </trans-unit>
        <trans-unit id="6c0d59e1cc0d04f93b79c02798466c5f3e582923" translate="yes" xml:space="preserve">
          <source>For ordered-set aggregates only, this flag specifies that the aggregate arguments are to be processed according to the requirements for hypothetical-set aggregates: that is, the last few direct arguments must match the data types of the aggregated (&lt;code&gt;WITHIN GROUP&lt;/code&gt;) arguments. The &lt;code&gt;HYPOTHETICAL&lt;/code&gt; flag has no effect on run-time behavior, only on parse-time resolution of the data types and collations of the aggregate's arguments.</source>
          <target state="translated">仅对于有序集合聚合，此标志指定将根据假设集合聚合的要求处理聚合参数：也就是说，最后几个直接参数必须与聚合（ &lt;code&gt;WITHIN GROUP&lt;/code&gt; ）参数的数据类型匹配。该 &lt;code&gt;HYPOTHETICAL&lt;/code&gt; 标志只对数据类型和聚集的论点归类分析时分辨率上运行时的行为没有任何影响。</target>
        </trans-unit>
        <trans-unit id="13b1b26b35f07e3a875d44019b004753915b48df" translate="yes" xml:space="preserve">
          <source>For pages that cannot be skipped, it scans each tuple, recording its presence and size in the appropriate counters, and adding up the free space on the page. At the end, it estimates the total number of live tuples based on the number of pages and tuples scanned (in the same way that VACUUM estimates pg_class.reltuples).</source>
          <target state="translated">对于不能跳过的页面,它扫描每个元组,在相应的计数器中记录它的存在和大小,并将页面上的可用空间加起来。最后,它根据扫描到的页面和元组数量来估计实时元组的总数(与 VACUUM 估计 pg_class.reltuples 的方式相同)。</target>
        </trans-unit>
        <trans-unit id="868352f139d86028da2fe3079d740960bf5a0c0a" translate="yes" xml:space="preserve">
          <source>For parameter defaults, the SQL standard specifies only the syntax with the &lt;code&gt;DEFAULT&lt;/code&gt; key word. The syntax with &lt;code&gt;=&lt;/code&gt; is used in T-SQL and Firebird.</source>
          <target state="translated">对于参数默认值，SQL标准仅使用 &lt;code&gt;DEFAULT&lt;/code&gt; 关键字指定语法。在T-SQL和Firebird中使用 &lt;code&gt;=&lt;/code&gt; 语法。</target>
        </trans-unit>
        <trans-unit id="d24bbed3cf952c936ab011c509488bf0467fa622" translate="yes" xml:space="preserve">
          <source>For policies that can have both &lt;code&gt;USING&lt;/code&gt; and &lt;code&gt;WITH CHECK&lt;/code&gt; expressions (&lt;code&gt;ALL&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt;), if no &lt;code&gt;WITH CHECK&lt;/code&gt; expression is defined, then the &lt;code&gt;USING&lt;/code&gt; expression will be used both to determine which rows are visible (normal &lt;code&gt;USING&lt;/code&gt; case) and which new rows will be allowed to be added (&lt;code&gt;WITH CHECK&lt;/code&gt; case).</source>
          <target state="translated">对于同时具有 &lt;code&gt;USING&lt;/code&gt; 和 &lt;code&gt;WITH CHECK&lt;/code&gt; 表达式（ &lt;code&gt;ALL&lt;/code&gt; 和 &lt;code&gt;UPDATE&lt;/code&gt; ）的策略，如果未定义 &lt;code&gt;WITH CHECK&lt;/code&gt; 表达式，则 &lt;code&gt;USING&lt;/code&gt; 表达式将用于确定哪些行可见（正常的 &lt;code&gt;USING&lt;/code&gt; 情况）以及哪些新行将是可见的。允许添加（ &lt;code&gt;WITH CHECK&lt;/code&gt; 情况）。</target>
        </trans-unit>
        <trans-unit id="82d5e1c9db6a18c117c8031e2597235ae83ea517" translate="yes" xml:space="preserve">
          <source>For procedural languages, allows use of the language for the creation of functions in that language. This is the only type of privilege that is applicable to procedural languages.</source>
          <target state="translated">对于程序性语言,允许使用该语言创建该语言的函数。这是唯一一种适用于程序性语言的特权。</target>
        </trans-unit>
        <trans-unit id="72ae8edf284efd5793c4ac2e8558efa80968a775" translate="yes" xml:space="preserve">
          <source>For protection against possible future keyword additions, it is recommended that you always either write &lt;code&gt;AS&lt;/code&gt; or double-quote the output column name.</source>
          <target state="translated">为了防止将来可能会增加关键字，建议始终写 &lt;code&gt;AS&lt;/code&gt; 或在输出列名称中用双引号引起来。</target>
        </trans-unit>
        <trans-unit id="90dfd308078c52df87fcfcab656bb11ad21b3919" translate="yes" xml:space="preserve">
          <source>For reasons of backwards compatibility, the commas between successive &lt;code&gt;transaction_modes&lt;/code&gt; can be omitted.</source>
          <target state="translated">出于向后兼容性的原因，可以省略连续 &lt;code&gt;transaction_modes&lt;/code&gt; 之间的逗号。</target>
        </trans-unit>
        <trans-unit id="ee31746206f7099bf155b9a7de2ea519f45916ff" translate="yes" xml:space="preserve">
          <source>For reference purposes, a standard installation also contains files &lt;code&gt;Africa.txt&lt;/code&gt;, &lt;code&gt;America.txt&lt;/code&gt;, etc, containing information about every time zone abbreviation known to be in use according to the IANA timezone database. The zone name definitions found in these files can be copied and pasted into a custom configuration file as needed. Note that these files cannot be directly referenced as &lt;code&gt;timezone_abbreviations&lt;/code&gt; settings, because of the dot embedded in their names.</source>
          <target state="translated">作为参考，标准安装还包含文件 &lt;code&gt;Africa.txt&lt;/code&gt; ， &lt;code&gt;America.txt&lt;/code&gt; 等，其中包含有关根据IANA时区数据库已知正在使用的每个时区缩写的信息。这些文件中找到的区域名称定义可以根据需要复制并粘贴到自定义配置文件中。请注意，由于这些文件的名称中嵌入了点，因此它们不能直接引用为 &lt;code&gt;timezone_abbreviations&lt;/code&gt; 设置。</target>
        </trans-unit>
        <trans-unit id="124811ada3de0016b7583028ff8e0587746fbc22" translate="yes" xml:space="preserve">
          <source>For reliable recovery when changing &lt;code&gt;fsync&lt;/code&gt; off to on, it is necessary to force all modified buffers in the kernel to durable storage. This can be done while the cluster is shutdown or while &lt;code&gt;fsync&lt;/code&gt; is on by running &lt;code&gt;initdb --sync-only&lt;/code&gt;, running &lt;code&gt;sync&lt;/code&gt;, unmounting the file system, or rebooting the server.</source>
          <target state="translated">为了在将 &lt;code&gt;fsync&lt;/code&gt; 更改为on 时进行可靠的恢复，必须将内核中所有已修改的缓冲区强制为持久存储。这可以在集群关闭或 &lt;code&gt;fsync&lt;/code&gt; 打开时通过运行 &lt;code&gt;initdb --sync-only&lt;/code&gt; ，运行 &lt;code&gt;sync&lt;/code&gt; ，卸载文件系统或重新引导服务器来完成。</target>
        </trans-unit>
        <trans-unit id="319e6f276af3394d5ebbac353d76e4013f542a01" translate="yes" xml:space="preserve">
          <source>For roles that can log in, this sets maximum number of concurrent connections this role can make. -1 means no limit.</source>
          <target state="translated">对于可以登录的角色,该值设置该角色可以进行的最大并发连接数。-1表示没有限制。</target>
        </trans-unit>
        <trans-unit id="0a4172c7b4024e73e796b850c139c38ecd17203c" translate="yes" xml:space="preserve">
          <source>For schemas, allows access to objects contained in the schema (assuming that the objects' own privilege requirements are also met). Essentially this allows the grantee to &amp;ldquo;look up&amp;rdquo; objects within the schema. Without this permission, it is still possible to see the object names, e.g. by querying system catalogs. Also, after revoking this permission, existing sessions might have statements that have previously performed this lookup, so this is not a completely secure way to prevent object access.</source>
          <target state="translated">对于模式，允许访问模式中包含的对象（假设还满足对象自身的特权要求）。从本质上讲，这允许被授予者在模式中&amp;ldquo;查找&amp;rdquo;对象。没有此许可，仍然可以查看对象名称，例如通过查询系统目录。同样，在撤消该权限之后，现有会话可能具有以前执行过此查找的语句，因此这不是防止对象访问的完全安全的方法。</target>
        </trans-unit>
        <trans-unit id="104e353c308a9f15b922dc481c8e27852ead1095" translate="yes" xml:space="preserve">
          <source>For schemas, allows access to objects contained in the schema (assuming that the objects' own privilege requirements are also met). Essentially this allows the grantee to &amp;ldquo;look up&amp;rdquo; objects within the schema. Without this permission, it is still possible to see the object names, e.g., by querying system catalogs. Also, after revoking this permission, existing sessions might have statements that have previously performed this lookup, so this is not a completely secure way to prevent object access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca22692db97a2637a8e751de3cc8e36b4187aab7" translate="yes" xml:space="preserve">
          <source>For schemas, allows new objects to be created within the schema. To rename an existing object, you must own the object &lt;em&gt;and&lt;/em&gt; have this privilege for the containing schema.</source>
          <target state="translated">对于模式，允许在模式内创建新对象。要重命名现有对象，您必须拥有该对象&lt;em&gt;，&lt;/em&gt;并对包含的架构具有此特权。</target>
        </trans-unit>
        <trans-unit id="77c0cf444f37221ad1fe5a6fc24e9c33e4046529" translate="yes" xml:space="preserve">
          <source>For searches within PostgreSQL, a document is normally a textual field within a row of a database table, or possibly a combination (concatenation) of such fields, perhaps stored in several tables or obtained dynamically. In other words, a document can be constructed from different parts for indexing and it might not be stored anywhere as a whole. For example:</source>
          <target state="translated">对于PostgreSQL中的搜索来说,文档通常是数据库表中某一行中的一个文本字段,或者可能是这些字段的组合(连接),可能存储在几个表中或动态获得。换句话说,一个文档可以由不同的部分构成索引,它可能不会作为一个整体存储在任何地方。例如:</target>
        </trans-unit>
        <trans-unit id="a142a9753e3ece701e9f2b90c2d239cb6b9b44cd" translate="yes" xml:space="preserve">
          <source>For security reasons the new cluster created by &lt;code&gt;initdb&lt;/code&gt; will only be accessible by the cluster owner by default. The &lt;code&gt;--allow-group-access&lt;/code&gt; option allows any user in the same group as the cluster owner to read files in the cluster. This is useful for performing backups as a non-privileged user.</source>
          <target state="translated">出于安全原因，默认情况下，只有群集所有者才能访问由 &lt;code&gt;initdb&lt;/code&gt; 创建的新群集。该 &lt;code&gt;--allow-group-access&lt;/code&gt; 选项允许在同一组群所有者任何用户集群中读取文件。这对于以非特权用户身份执行备份很有用。</target>
        </trans-unit>
        <trans-unit id="1f1663e5a58c2af0c67ac06b0e2e7c597b770b66" translate="yes" xml:space="preserve">
          <source>For security reasons, only superusers and members of the &lt;code&gt;pg_read_all_stats&lt;/code&gt; role are allowed to see the SQL text and &lt;code&gt;queryid&lt;/code&gt; of queries executed by other users. Other users can see the statistics, however, if the view has been installed in their database.</source>
          <target state="translated">出于安全原因，仅超级用户和 &lt;code&gt;pg_read_all_stats&lt;/code&gt; 角色成员被允许查看其他用户执行的SQL文本和 &lt;code&gt;queryid&lt;/code&gt; 。但是，如果视图已安装在他们的数据库中，则其他用户可以查看统计信息。</target>
        </trans-unit>
        <trans-unit id="a2387fb268a4aad1cb27f4814253a95ea4053932" translate="yes" xml:space="preserve">
          <source>For sequences, &lt;code&gt;db_sequence:get_value&lt;/code&gt; is checked when we reference a sequence object using &lt;code&gt;SELECT&lt;/code&gt;; however, note that we do not currently check permissions on execution of corresponding functions such as &lt;code&gt;lastval()&lt;/code&gt;.</source>
          <target state="translated">对于序列，当我们使用 &lt;code&gt;SELECT&lt;/code&gt; 引用序列对象时，将检查 &lt;code&gt;db_sequence:get_value&lt;/code&gt; ；但是，请注意，我们目前不检查执行相应功能（例如 &lt;code&gt;lastval()&lt;/code&gt; )的权限。</target>
        </trans-unit>
        <trans-unit id="a6107c5c35722f41cd50e68f08c51a50459956c5" translate="yes" xml:space="preserve">
          <source>For sequences, allows use of the &lt;code&gt;currval&lt;/code&gt; and &lt;code&gt;nextval&lt;/code&gt; functions.</source>
          <target state="translated">对于序列，允许使用 &lt;code&gt;currval&lt;/code&gt; 和 &lt;code&gt;nextval&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="41c9e0790209171bd641f0e2a59f5f0172d7ebb1" translate="yes" xml:space="preserve">
          <source>For servers that are not regularly connected or have slow communication links, like laptops or remote servers, keeping data consistent among servers is a challenge. Using asynchronous multimaster replication, each server works independently, and periodically communicates with the other servers to identify conflicting transactions. The conflicts can be resolved by users or conflict resolution rules. Bucardo is an example of this type of replication.</source>
          <target state="translated">对于不定期连接或通信链路较慢的服务器,如笔记本电脑或远程服务器,保持服务器之间的数据一致是一个挑战。使用异步多主站复制,每个服务器独立工作,并定期与其他服务器进行通信,以识别冲突的事务。这些冲突可以由用户或冲突解决规则来解决。Bucardo是这种类型的复制的一个例子。</target>
        </trans-unit>
        <trans-unit id="62b0a1b5925a4635226ab51bcd1ee55bb85746c9" translate="yes" xml:space="preserve">
          <source>For simple &lt;code&gt;IN&lt;/code&gt; tests, it's better to rely on the &lt;a href=&quot;functions-comparisons#FUNCTIONS-COMPARISONS-IN-SCALAR&quot;&gt;list-of-scalars&lt;/a&gt; form of &lt;code&gt;IN&lt;/code&gt; than to write a &lt;code&gt;VALUES&lt;/code&gt; query as shown above. The list of scalars method requires less writing and is often more efficient.</source>
          <target state="translated">对于简单的 &lt;code&gt;IN&lt;/code&gt; 测试，最好依赖于 &lt;code&gt;IN&lt;/code&gt; &lt;a href=&quot;functions-comparisons#FUNCTIONS-COMPARISONS-IN-SCALAR&quot;&gt;的标量列表&lt;/a&gt;形式，而不要编写如上所示的 &lt;code&gt;VALUES&lt;/code&gt; 查询。标量方法列表需要较少的编写，并且通常效率更高。</target>
        </trans-unit>
        <trans-unit id="1c8ca5d9d323066d6d659aa5ff3196102b40293c" translate="yes" xml:space="preserve">
          <source>For some types of errors, the server reports the name of a database object (a table, table column, data type, or constraint) associated with the error; for example, the name of the unique constraint that caused a &lt;code&gt;unique_violation&lt;/code&gt; error. Such names are supplied in separate fields of the error report message so that applications need not try to extract them from the possibly-localized human-readable text of the message. As of PostgreSQL 9.3, complete coverage for this feature exists only for errors in SQLSTATE class 23 (integrity constraint violation), but this is likely to be expanded in future.</source>
          <target state="translated">对于某些类型的错误，服务器报告与该错误关联的数据库对象的名称（表，表列，数据类型或约束）。例如，导致 &lt;code&gt;unique_violation&lt;/code&gt; 错误的唯一约束的名称。这些名称在错误报告消息的单独字段中提供，因此应用程序无需尝试从消息的可能本地化的人类可读文本中提取它们。从PostgreSQL 9.3开始，仅针对SQLSTATE class 23（完整性约束违规）中的错误才存在此功能的完整覆盖范围，但是将来可能会扩大。</target>
        </trans-unit>
        <trans-unit id="b6625213e6e6fa2bc1eaac3fdaba176e51b962e6" translate="yes" xml:space="preserve">
          <source>For some types of relation, &lt;code&gt;\d&lt;/code&gt; shows additional information for each column: column values for sequences, indexed expressions for indexes, and foreign data wrapper options for foreign tables.</source>
          <target state="translated">对于某些类型的关系， &lt;code&gt;\d&lt;/code&gt; 显示每列的其他信息：序列的列值，索引的索引表达式以及外部表的外部数据包装器选项。</target>
        </trans-unit>
        <trans-unit id="96c3119cad566b7b88d64ca07bab7df7991bc93e" translate="yes" xml:space="preserve">
          <source>For source installs, if you wish to install the new server in a custom location, use the &lt;code&gt;prefix&lt;/code&gt; variable:</source>
          <target state="translated">对于源代码安装，如果希望将新服务器安装在自定义位置，请使用 &lt;code&gt;prefix&lt;/code&gt; 变量：</target>
        </trans-unit>
        <trans-unit id="02535fa4807bcb15e6b90f67411bc5308adeb97f" translate="yes" xml:space="preserve">
          <source>For tables with GIN indexes, &lt;code&gt;VACUUM&lt;/code&gt; (in any form) also completes any pending index insertions, by moving pending index entries to the appropriate places in the main GIN index structure. See &lt;a href=&quot;gin-implementation#GIN-FAST-UPDATE&quot;&gt;Section 66.4.1&lt;/a&gt; for details.</source>
          <target state="translated">对于具有GIN索引的表， &lt;code&gt;VACUUM&lt;/code&gt; （以任何形式）还可以通过将未决索引条目移动到主GIN索引结构中的适当位置来完成所有未决索引插入。有关详细信息，请参见&lt;a href=&quot;gin-implementation#GIN-FAST-UPDATE&quot;&gt;第66.4.1节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c91c055bfb7a26b615975cdc96ae00a408c07dd3" translate="yes" xml:space="preserve">
          <source>For tables, &lt;code&gt;db_table:select&lt;/code&gt;, &lt;code&gt;db_table:insert&lt;/code&gt;, &lt;code&gt;db_table:update&lt;/code&gt; or &lt;code&gt;db_table:delete&lt;/code&gt; are checked for all the referenced target tables depending on the kind of statement; in addition, &lt;code&gt;db_table:select&lt;/code&gt; is also checked for all the tables that contain columns referenced in the &lt;code&gt;WHERE&lt;/code&gt; or &lt;code&gt;RETURNING&lt;/code&gt; clause, as a data source for &lt;code&gt;UPDATE&lt;/code&gt;, and so on.</source>
          <target state="translated">对于表， &lt;code&gt;db_table:insert&lt;/code&gt; 根据语句的类型为所有引用的目标表检查 &lt;code&gt;db_table:select&lt;/code&gt; ，db_table：insert， &lt;code&gt;db_table:update&lt;/code&gt; 或 &lt;code&gt;db_table:delete&lt;/code&gt; ；另外，还将检查 &lt;code&gt;db_table:select&lt;/code&gt; 是否包含所有在 &lt;code&gt;WHERE&lt;/code&gt; 或 &lt;code&gt;RETURNING&lt;/code&gt; 子句中引用的列的表，作为 &lt;code&gt;UPDATE&lt;/code&gt; 的数据源，依此类推。</target>
        </trans-unit>
        <trans-unit id="c5801368320c105ca425cc142e3ec8942b58fbca" translate="yes" xml:space="preserve">
          <source>For tablespaces, allows tables, indexes, and temporary files to be created within the tablespace, and allows databases to be created that have the tablespace as their default tablespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c7df8e7cc19f2604588ffd58fd2bd20e5c27f91" translate="yes" xml:space="preserve">
          <source>For tablespaces, allows tables, indexes, and temporary files to be created within the tablespace, and allows databases to be created that have the tablespace as their default tablespace. (Note that revoking this privilege will not alter the placement of existing objects.)</source>
          <target state="translated">对于表空间,允许在表空间内创建表、索引和临时文件,并允许创建以表空间为默认表空间的数据库。(注意,撤销该权限不会改变现有对象的位置)。</target>
        </trans-unit>
        <trans-unit id="60dffce454150377149f2bc1c7ec0c5dc5d0791c" translate="yes" xml:space="preserve">
          <source>For temporary tables, &lt;code&gt;CREATE INDEX&lt;/code&gt; is always non-concurrent, as no other session can access them, and non-concurrent index creation is cheaper.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93534c68b9e76f0b0f7395d9f112e5d49d630585" translate="yes" xml:space="preserve">
          <source>For temporary tables, &lt;code&gt;DROP INDEX&lt;/code&gt; is always non-concurrent, as no other session can access them, and non-concurrent index drop is cheaper.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82929702d8109347128382c7167aff5836ee34d7" translate="yes" xml:space="preserve">
          <source>For temporary tables, &lt;code&gt;REINDEX&lt;/code&gt; is always non-concurrent, as no other session can access them, and non-concurrent reindex is cheaper.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ed1cb94cb2f097d1a4265a2618f61e0b1b1ddd6" translate="yes" xml:space="preserve">
          <source>For testing purposes, it is possible to run both primary and standby servers on the same system. This does not provide any worthwhile improvement in server robustness, nor would it be described as HA.</source>
          <target state="translated">为了测试的目的,可以在同一系统上同时运行主服务器和备用服务器。这并不能为服务器的健壮性提供任何值得改进的地方,也不会被称为HA。</target>
        </trans-unit>
        <trans-unit id="14326aec7784d590e8d770eaca8e03f0b4af843b" translate="yes" xml:space="preserve">
          <source>For text search purposes, each document must be reduced to the preprocessed &lt;code&gt;tsvector&lt;/code&gt; format. Searching and ranking are performed entirely on the &lt;code&gt;tsvector&lt;/code&gt; representation of a document &amp;mdash; the original text need only be retrieved when the document has been selected for display to a user. We therefore often speak of the &lt;code&gt;tsvector&lt;/code&gt; as being the document, but of course it is only a compact representation of the full document.</source>
          <target state="translated">为了进行文本搜索，必须将每个文档缩小为预处理的 &lt;code&gt;tsvector&lt;/code&gt; 格式。搜索和排序完全在文档的 &lt;code&gt;tsvector&lt;/code&gt; 表示上执行-仅当选择了文档显示给用户时才需要检索原始文本。因此，我们经常将 &lt;code&gt;tsvector&lt;/code&gt; 称为文档，但是当然，它只是完整文档的紧凑表示。</target>
        </trans-unit>
        <trans-unit id="a7a000de4f9a94a7302faa3da1d5fa7c3f403c9e" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;gt;=&lt;/code&gt; cases, the row elements are compared left-to-right, stopping as soon as an unequal or null pair of elements is found. If either of this pair of elements is null, the result of the row comparison is unknown (null); otherwise comparison of this pair of elements determines the result. For example, &lt;code&gt;ROW(1,2,NULL) &amp;lt; ROW(1,3,0)&lt;/code&gt; yields true, not null, because the third pair of elements are not considered.</source>
          <target state="translated">对于 &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;=&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;gt;=&lt;/code&gt; 情况，将行元素从左到右进行比较，一旦发现不相等或为空的元素对，就会停止。如果这对元素中的任何一个为null，则行比较的结果未知（null）；否则，结果为null。否则，通过这对元素的比较确定结果。例如，由于未考虑第三对元素，因此 &lt;code&gt;ROW(1,2,NULL) &amp;lt; ROW(1,3,0)&lt;/code&gt; 得出true，而不是null。</target>
        </trans-unit>
        <trans-unit id="dfc3c21d9ddee1f916ca1387da5b3a8a58887534" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;INNER&lt;/code&gt; and &lt;code&gt;OUTER&lt;/code&gt; join types, a join condition must be specified, namely exactly one of &lt;code&gt;NATURAL&lt;/code&gt;, &lt;code&gt;ON join_condition&lt;/code&gt;, or &lt;code&gt;USING (join_column [, ...])&lt;/code&gt;. See below for the meaning. For &lt;code&gt;CROSS JOIN&lt;/code&gt;, none of these clauses can appear.</source>
          <target state="translated">对于 &lt;code&gt;INNER&lt;/code&gt; 和 &lt;code&gt;OUTER&lt;/code&gt; 连接类型，必须指定一个连接条件，即恰好是 &lt;code&gt;NATURAL&lt;/code&gt; ， &lt;code&gt;ON join_condition&lt;/code&gt; 或 &lt;code&gt;USING (join_column [, ...])&lt;/code&gt; 。含义见下文。对于 &lt;code&gt;CROSS JOIN&lt;/code&gt; ，这些子句都不会出现。</target>
        </trans-unit>
        <trans-unit id="dad37c11367f0fd32c32e9bf08cc2fd30c405130" translate="yes" xml:space="preserve">
          <source>For the default TPC-B-like test scenario, the initialization scale factor (&lt;code&gt;-s&lt;/code&gt;) should be at least as large as the largest number of clients you intend to test (&lt;code&gt;-c&lt;/code&gt;); else you'll mostly be measuring update contention. There are only &lt;code&gt;-s&lt;/code&gt; rows in the &lt;code&gt;pgbench_branches&lt;/code&gt; table, and every transaction wants to update one of them, so &lt;code&gt;-c&lt;/code&gt; values in excess of &lt;code&gt;-s&lt;/code&gt; will undoubtedly result in lots of transactions blocked waiting for other transactions.</source>
          <target state="translated">对于默认的类似TPC-B的测试方案，初始化比例因子（ &lt;code&gt;-s&lt;/code&gt; ）至少应与要测试的最大客户端数量（ &lt;code&gt;-c&lt;/code&gt; ）一样大。否则，您将主要衡量更新争用。 &lt;code&gt;pgbench_branches&lt;/code&gt; 表中只有 &lt;code&gt;-s&lt;/code&gt; 行，每个事务都希望更新其中的一个，因此，超过 &lt;code&gt;-s&lt;/code&gt; 的 &lt;code&gt;-c&lt;/code&gt; 值无疑会导致许多事务被阻塞，以等待其他事务。</target>
        </trans-unit>
        <trans-unit id="a5751609fa3abe5700d0557e4f26ffe5f05018e3" translate="yes" xml:space="preserve">
          <source>For the default script, the output will look similar to this:</source>
          <target state="translated">对于默认的脚本,输出将类似于这样。</target>
        </trans-unit>
        <trans-unit id="9007ccafafbe06f38e92e2d086ee0438ce1eec15" translate="yes" xml:space="preserve">
          <source>For the list of built-in functions and operators available for constructing and processing JSON values, see &lt;a href=&quot;functions-json&quot;&gt;Section 9.15&lt;/a&gt;.</source>
          <target state="translated">有关可用于构造和处理JSON值的内置函数和运算符的列表，请参见&lt;a href=&quot;functions-json&quot;&gt;第9.15节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b3e8f597d5cc47851d8a9d164150d2f7a92e4220" translate="yes" xml:space="preserve">
          <source>For the list of built-in functions and operators available for constructing and processing JSON values, see &lt;a href=&quot;functions-json&quot;&gt;Section 9.16&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6a1288823da614ad6ddd8076b29a2c859b00b3d" translate="yes" xml:space="preserve">
          <source>For the purpose of a unique constraint, null values are not considered equal.</source>
          <target state="translated">为了唯一约束的目的,空值不被视为相等。</target>
        </trans-unit>
        <trans-unit id="c5aa91a6ae5978dfba449fc8f21af598ecb84b63" translate="yes" xml:space="preserve">
          <source>For the purposes of this option, the multixact ID age of a relation is the greatest of the ages of the main relation and its associated TOAST table, if one exists. Since the commands issued by vacuumdb will also process the TOAST table for the relation if necessary, it does not need to be considered separately.</source>
          <target state="translated">在这个选项中,一个关系的多重精确ID年龄是主关系和它相关的TOAST表(如果存在的话)的年龄中最大的一个。因为如果有必要的话,由Vacuumdb发出的命令也会处理关系的TOAST表,所以不需要单独考虑。</target>
        </trans-unit>
        <trans-unit id="7a930282601dc6d73b8f0cbaf1770a134e812692" translate="yes" xml:space="preserve">
          <source>For the purposes of this option, the transaction ID age of a relation is the greatest of the ages of the main relation and its associated TOAST table, if one exists. Since the commands issued by vacuumdb will also process the TOAST table for the relation if necessary, it does not need to be considered separately.</source>
          <target state="translated">在这个选项中,一个关系的事务ID年龄是主关系和它的相关TOAST表(如果存在的话)的年龄中最大的一个。因为如果需要的话,vacuumdb发出的命令也会处理关系的TOAST表,所以不需要单独考虑。</target>
        </trans-unit>
        <trans-unit id="e7dd494ba670198b28ebfc500d18e95c5d26c155" translate="yes" xml:space="preserve">
          <source>For the regexp functions, if you want to match case-sensitively, you can specify the &amp;ldquo;c&amp;rdquo; flag to force a case-sensitive match. Otherwise, you must cast to &lt;code&gt;text&lt;/code&gt; before using one of these functions if you want case-sensitive behavior.</source>
          <target state="translated">对于正则表达式函数，如果要区分大小写，可以指定&amp;ldquo; c&amp;rdquo;标志来强制区分大小写。否则，如果要区分大小写，则必须在使用这些功能之一之前强制转换为 &lt;code&gt;text&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d78645291bcc7701c1b16378879f0e6ec0613a1b" translate="yes" xml:space="preserve">
          <source>For this purpose, white-space characters are blank, tab, newline, and any character that belongs to the &lt;code&gt;space&lt;/code&gt; character class.</source>
          <target state="translated">为此，空格字符为空白，制表符，换行符以及任何属于 &lt;code&gt;space&lt;/code&gt; 字符类的字符。</target>
        </trans-unit>
        <trans-unit id="74af73ce47f8b4a950cf1dc74d44af070dbfb80a" translate="yes" xml:space="preserve">
          <source>For those interested in further details, estimation of the size of a table (before any &lt;code&gt;WHERE&lt;/code&gt; clauses) is done in &lt;code&gt;src/backend/optimizer/util/plancat.c&lt;/code&gt;. The generic logic for clause selectivities is in &lt;code&gt;src/backend/optimizer/path/clausesel.c&lt;/code&gt;. The operator-specific selectivity functions are mostly found in &lt;code&gt;src/backend/utils/adt/selfuncs.c&lt;/code&gt;.</source>
          <target state="translated">对于那些对更多细节感兴趣的人，可以在 &lt;code&gt;src/backend/optimizer/util/plancat.c&lt;/code&gt; 中估算表的大小（在任何 &lt;code&gt;WHERE&lt;/code&gt; 子句之前）。子句选择性的通用逻辑在 &lt;code&gt;src/backend/optimizer/path/clausesel.c&lt;/code&gt; 中。特定于运营商的选择性功能主要在 &lt;code&gt;src/backend/utils/adt/selfuncs.c&lt;/code&gt; 中找到。</target>
        </trans-unit>
        <trans-unit id="f63222727e6629be4e7161b8b3cc8abbda85cb89" translate="yes" xml:space="preserve">
          <source>For those not using autovacuum, a typical approach is to schedule a database-wide &lt;code&gt;VACUUM&lt;/code&gt; once a day during a low-usage period, supplemented by more frequent vacuuming of heavily-updated tables as necessary. (Some installations with extremely high update rates vacuum their busiest tables as often as once every few minutes.) If you have multiple databases in a cluster, don't forget to &lt;code&gt;VACUUM&lt;/code&gt; each one; the program &lt;a href=&quot;app-vacuumdb&quot;&gt;vacuumdb&lt;/a&gt; might be helpful.</source>
          <target state="translated">对于那些不使用自动抽空的用户，一种典型的方法是在低使用率期间每天安排一次数据库范围的 &lt;code&gt;VACUUM&lt;/code&gt; ，并根据需要更频繁地清理大量更新的表。 （某些更新速度极高的安装程序每隔几分钟就会频繁清理最繁忙的表一次。）如果群集中有多个数据库，请不要忘记对每个数据库进行 &lt;code&gt;VACUUM&lt;/code&gt; 。该程序&lt;a href=&quot;app-vacuumdb&quot;&gt;vacuumdb&lt;/a&gt;可能会有所帮助。</target>
        </trans-unit>
        <trans-unit id="c7b55b171eb70ee6df74b6fa93a4927e18a0f903" translate="yes" xml:space="preserve">
          <source>For tranches registered by extensions, the name is specified by extension and this will be displayed as &lt;code&gt;wait_event&lt;/code&gt;. It is quite possible that user has registered the tranche in one of the backends (by having allocation in dynamic shared memory) in which case other backends won't have that information, so we display &lt;code&gt;extension&lt;/code&gt; for such cases.</source>
          <target state="translated">对于由扩展名注册的付款，名称由扩展名指定，并且将显示为 &lt;code&gt;wait_event&lt;/code&gt; 。用户很有可能已经在后端之一中注册了付款（通过在动态共享内存中进行分配），在这种情况下其他后端将没有该信息，因此我们在这种情况下显示 &lt;code&gt;extension&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ededecf7230bd098333895398724d8cf30ca646" translate="yes" xml:space="preserve">
          <source>For typed tables, the OID of the underlying composite type, zero for all other relations</source>
          <target state="translated">对于类型化的表,是底层复合类型的OID,对于所有其他关系,为零。</target>
        </trans-unit>
        <trans-unit id="27c45ad1aa00e6a5905b5f896364ccf8b4773847" translate="yes" xml:space="preserve">
          <source>For types and domains, allows use of the type or domain in the creation of tables, functions, and other schema objects. (Note that this privilege does not control all &amp;ldquo;usage&amp;rdquo; of the type, such as values of the type appearing in queries. It only prevents objects from being created that depend on the type. The main purpose of this privilege is controlling which users can create dependencies on a type, which could prevent the owner from changing the type later.)</source>
          <target state="translated">对于类型和域，允许在创建表，函数和其他架构对象时使用类型或域。（请注意，此特权不能控制类型的所有&amp;ldquo;使用&amp;rdquo;，例如查询中出现的类型的值。它只能防止创建依赖于类型的对象。此特权的主要目的是控制哪些用户可以在类型上创建依赖项，这可能会阻止所有者稍后更改类型。）</target>
        </trans-unit>
        <trans-unit id="bff214879bf946c9914852230e9d3373cec1aabc" translate="yes" xml:space="preserve">
          <source>For types used in system tables, it is critical that the size and alignment defined in &lt;code&gt;pg_type&lt;/code&gt; agree with the way that the compiler will lay out the column in a structure representing a table row.</source>
          <target state="translated">对于系统表中使用的类型，至关重要的是 &lt;code&gt;pg_type&lt;/code&gt; 中定义的大小和对齐方式与编译器将列布局在表示表行的结构中的方式一致。</target>
        </trans-unit>
        <trans-unit id="0e1106a91cc01fcaaeb464887fd19957f0820912" translate="yes" xml:space="preserve">
          <source>For unlogged relations, everything works the same except that no actual WAL record is emitted. Thus, you typically do not need to do any explicit checks for unlogged relations.</source>
          <target state="translated">对于未记录的关系,除了没有实际的 WAL 记录被发出之外,一切工作都是一样的。因此,你通常不需要为未记录的关系做任何显式检查。</target>
        </trans-unit>
        <trans-unit id="85b738e0688a60aa0821e2d9571d4dd56271215e" translate="yes" xml:space="preserve">
          <source>For user-defined functions, PostgreSQL tracks dependencies associated with a function's externally-visible properties, such as its argument and result types, but &lt;em&gt;not&lt;/em&gt; dependencies that could only be known by examining the function body. As an example, consider this situation:</source>
          <target state="translated">对于用户定义的函数，PostgreSQL跟踪与函数的外部可见属性（例如，其参数和结果类型）相关联的依赖关系，但&lt;em&gt;不&lt;/em&gt;跟踪只能通过检查函数体才能知道的依赖关系。例如，考虑这种情况：</target>
        </trans-unit>
        <trans-unit id="cd43cb783f81232deb1bffc73b358dcab3c75399" translate="yes" xml:space="preserve">
          <source>For very large databases, you might need to combine &lt;code&gt;split&lt;/code&gt; with one of the other two approaches.</source>
          <target state="translated">对于非常大的数据库，您可能需要将 &lt;code&gt;split&lt;/code&gt; 与其他两种方法之一结合使用。</target>
        </trans-unit>
        <trans-unit id="33f690385f50f3c83dc2195d926f5a45ebb2cb63" translate="yes" xml:space="preserve">
          <source>For views, &lt;code&gt;db_view:expand&lt;/code&gt; will be checked, then any other required permissions will be checked on the objects being expanded from the view, individually.</source>
          <target state="translated">对于视图，将检查 &lt;code&gt;db_view:expand&lt;/code&gt; ，然后将分别检查从视图扩展的对象的所有其他必需权限。</target>
        </trans-unit>
        <trans-unit id="9bf29d0c0afb407846366a836c4874ef5e6ab74c" translate="yes" xml:space="preserve">
          <source>Forbid the execution of any &lt;a href=&quot;https://www.postgresql.org/docs/12/ddl.html&quot;&gt;DDL&lt;/a&gt; command:</source>
          <target state="translated">禁止执行任何&lt;a href=&quot;https://www.postgresql.org/docs/12/ddl.html&quot;&gt;DDL&lt;/a&gt;命令：</target>
        </trans-unit>
        <trans-unit id="12f8a377f5b991eee465fcb5a9cc92f6309394f2" translate="yes" xml:space="preserve">
          <source>Forbid the execution of any &lt;a href=&quot;https://www.postgresql.org/docs/13/ddl.html&quot;&gt;DDL&lt;/a&gt; command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e74aa9c02843996563e83950d619d1a48cca853" translate="yes" xml:space="preserve">
          <source>Forbids the use of particular scan and join methods: &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;i&lt;/code&gt; disable sequential and index scans respectively, &lt;code&gt;o&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt; disable index-only scans, bitmap index scans, and TID scans respectively, while &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, and &lt;code&gt;h&lt;/code&gt; disable nested-loop, merge and hash joins respectively.</source>
          <target state="translated">禁止使用特定的扫描和连接方法： &lt;code&gt;s&lt;/code&gt; 和 &lt;code&gt;i&lt;/code&gt; 分别禁用顺序扫描和索引扫描， &lt;code&gt;o&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;t&lt;/code&gt; 分别禁用仅索引扫描，位图索引扫描和TID扫描，而 &lt;code&gt;n&lt;/code&gt; ， &lt;code&gt;m&lt;/code&gt; 和 &lt;code&gt;h&lt;/code&gt; 禁用嵌套-分别循环，合并和哈希联接。</target>
        </trans-unit>
        <trans-unit id="6b54925430ba39c29285400ee9438bd06b14498b" translate="yes" xml:space="preserve">
          <source>Force &lt;code&gt;pg_resetwal&lt;/code&gt; to proceed even if it cannot determine valid data for &lt;code&gt;pg_control&lt;/code&gt;, as explained above.</source>
          <target state="translated">&lt;code&gt;pg_resetwal&lt;/code&gt; ，即使无法确定 &lt;code&gt;pg_control&lt;/code&gt; 的有效数据，也要强制pg_resetwal继续进行。</target>
        </trans-unit>
        <trans-unit id="1eac8549c0aec6316f92f1df6ba514101db909c7" translate="yes" xml:space="preserve">
          <source>Force clusterdb to prompt for a password before connecting to a database.</source>
          <target state="translated">强制 clusterdb 在连接数据库前提示密码。</target>
        </trans-unit>
        <trans-unit id="b0925c99f8012867ed4e28694186256d8b497b07" translate="yes" xml:space="preserve">
          <source>Force createdb to prompt for a password before connecting to a database.</source>
          <target state="translated">强制createdb在连接到数据库之前提示密码。</target>
        </trans-unit>
        <trans-unit id="919f499ede6938621bb948df3ec55861e7b6e806" translate="yes" xml:space="preserve">
          <source>Force createuser to prompt for a password (for connecting to the server, not for the password of the new user).</source>
          <target state="translated">强制createuser提示输入密码(用于连接服务器,而不是新用户的密码)。</target>
        </trans-unit>
        <trans-unit id="0f5754485fd77647fa947500ba7d7eb3887d6390" translate="yes" xml:space="preserve">
          <source>Force dropdb to prompt for a password before connecting to a database.</source>
          <target state="translated">强制dropdb在连接到数据库之前提示密码。</target>
        </trans-unit>
        <trans-unit id="873b3fb51bdfb58a81fcee07b36cfd295d4a25ba" translate="yes" xml:space="preserve">
          <source>Force dropuser to prompt for a password before connecting to a database.</source>
          <target state="translated">强制dropuser在连接到数据库之前提示密码。</target>
        </trans-unit>
        <trans-unit id="68791460318431f1565f0db6649c38933e1c99f9" translate="yes" xml:space="preserve">
          <source>Force pg_basebackup to prompt for a password before connecting to a database.</source>
          <target state="translated">强制pg_basebackup在连接到数据库之前提示输入密码。</target>
        </trans-unit>
        <trans-unit id="e1db6640e8674298e7ff463f7c01bcb7d3c09291" translate="yes" xml:space="preserve">
          <source>Force pg_dump to prompt for a password before connecting to a database.</source>
          <target state="translated">强制pg_dump在连接数据库前提示密码。</target>
        </trans-unit>
        <trans-unit id="0bf671184854c4cafab424f289da944581383f7f" translate="yes" xml:space="preserve">
          <source>Force pg_dumpall to prompt for a password before connecting to a database.</source>
          <target state="translated">强制pg_dumpall在连接到数据库之前提示输入密码。</target>
        </trans-unit>
        <trans-unit id="cd46ad236b5565bc59849836637665c81e945654" translate="yes" xml:space="preserve">
          <source>Force pg_receivewal to prompt for a password before connecting to a database.</source>
          <target state="translated">强制pg_receivewal在连接到数据库之前提示输入密码。</target>
        </trans-unit>
        <trans-unit id="cb0cb6641f18ac0a5ebc128cc7585e9485375d09" translate="yes" xml:space="preserve">
          <source>Force pg_recvlogical to prompt for a password before connecting to a database.</source>
          <target state="translated">强制pg_recvlogical在连接到数据库之前提示输入密码。</target>
        </trans-unit>
        <trans-unit id="4333d7ad34894773d7724c896ba1ace5baa2e67d" translate="yes" xml:space="preserve">
          <source>Force pg_restore to prompt for a password before connecting to a database.</source>
          <target state="translated">强制pg_restore在连接数据库前提示密码。</target>
        </trans-unit>
        <trans-unit id="5d4bbbd7b1b0e3c3b7ba8c83092d65226c1b31be" translate="yes" xml:space="preserve">
          <source>Force psql to prompt for a password before connecting to a database, even if the password will not be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="060988688e7df93b56005121dd07764d70ac7fe5" translate="yes" xml:space="preserve">
          <source>Force psql to prompt for a password before connecting to a database.</source>
          <target state="translated">强制psql在连接数据库前提示输入密码。</target>
        </trans-unit>
        <trans-unit id="b0cd7fd585ccc7a582ee1111bc67d7d89a04cf8e" translate="yes" xml:space="preserve">
          <source>Force quoting of all identifiers. This option is recommended when dumping a database from a server whose PostgreSQL major version is different from pg_dump's, or when the output is intended to be loaded into a server of a different major version. By default, pg_dump quotes only identifiers that are reserved words in its own major version. This sometimes results in compatibility issues when dealing with servers of other versions that may have slightly different sets of reserved words. Using &lt;code&gt;--quote-all-identifiers&lt;/code&gt; prevents such issues, at the price of a harder-to-read dump script.</source>
          <target state="translated">强制引用所有标识符。当从PostgreSQL主版本不同于pg_dump的服务器中转储数据库时，或者打算将输出加载到其他主版本的服务器中时，建议使用此选项。默认情况下，pg_dump仅引用在其主版本中为保留字的标识符。在处理其他版本的保留字可能略有不同的服务器时，有时会导致兼容性问题。使用 &lt;code&gt;--quote-all-identifiers&lt;/code&gt; 可以防止此类问题，但代价是难以阅读的转储脚本。</target>
        </trans-unit>
        <trans-unit id="b22bd3cb5e64bd74dfce653c7bff0f559c9c1f26" translate="yes" xml:space="preserve">
          <source>Force quoting of all identifiers. This option is recommended when dumping a database from a server whose PostgreSQL major version is different from pg_dumpall's, or when the output is intended to be loaded into a server of a different major version. By default, pg_dumpall quotes only identifiers that are reserved words in its own major version. This sometimes results in compatibility issues when dealing with servers of other versions that may have slightly different sets of reserved words. Using &lt;code&gt;--quote-all-identifiers&lt;/code&gt; prevents such issues, at the price of a harder-to-read dump script.</source>
          <target state="translated">强制引用所有标识符。当从PostgreSQL主版本不同于pg_dumpall的服务器中转储数据库时，或者打算将输出加载到其他主版本的服务器中时，建议使用此选项。默认情况下，pg_dumpall仅引用在其主版本中为保留字的标识符。在处理其他版本的保留字可能略有不同的服务器时，有时会导致兼容性问题。使用 &lt;code&gt;--quote-all-identifiers&lt;/code&gt; 可以防止此类问题，但代价是难以阅读的转储脚本。</target>
        </trans-unit>
        <trans-unit id="5a4d553a940905a5b45f8f4a9271805f05936143" translate="yes" xml:space="preserve">
          <source>Force reindexdb to prompt for a password before connecting to a database.</source>
          <target state="translated">强制reindexdb在连接数据库前提示密码。</target>
        </trans-unit>
        <trans-unit id="d704d18558a65a962929acf79610b9c10e0ea21f" translate="yes" xml:space="preserve">
          <source>Force switch to a new write-ahead log file (restricted to superusers by default, but other users can be granted EXECUTE to run the function)</source>
          <target state="translated">强制切换到新的可写日志文件(默认情况下只限于超级用户,但其他用户可以被授予EXECUTE来运行该功能</target>
        </trans-unit>
        <trans-unit id="ad34c2643c5ad08a3b8ba0b861d443b8a1146fd4" translate="yes" xml:space="preserve">
          <source>Force vacuumdb to prompt for a password before connecting to a database.</source>
          <target state="translated">在连接到数据库之前,强制要求vacuumdb输入密码。</target>
        </trans-unit>
        <trans-unit id="8ba33bb09d0b9eedd0a5116108d4c330db881549" translate="yes" xml:space="preserve">
          <source>Forces all filenames in the backup manifest to be hex-encoded. If this option is not specified, only non-UTF8 filenames are hex-encoded. This option is mostly intended to test that tools which read a backup manifest file properly handle this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26d93bada9089cb03adfebd957430eeb5dee1930" translate="yes" xml:space="preserve">
          <source>Forces pg_basebackup to prompt for a password before connecting to the source server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab1894a9915a1c5bdd4fa99a3c35aa7aef1f3043" translate="yes" xml:space="preserve">
          <source>Forces quoting to be used for all non-&lt;code&gt;NULL&lt;/code&gt; values in each specified column. &lt;code&gt;NULL&lt;/code&gt; output is never quoted. If &lt;code&gt;*&lt;/code&gt; is specified, non-&lt;code&gt;NULL&lt;/code&gt; values will be quoted in all columns. This option is allowed only in &lt;code&gt;COPY TO&lt;/code&gt;, and only when using &lt;code&gt;CSV&lt;/code&gt; format.</source>
          <target state="translated">强制将引号用于每个指定列中的所有非 &lt;code&gt;NULL&lt;/code&gt; 值。 &lt;code&gt;NULL&lt;/code&gt; 输出从不引用。如果指定 &lt;code&gt;*&lt;/code&gt; ,则在所有列中都引用非 &lt;code&gt;NULL&lt;/code&gt; 值。仅在 &lt;code&gt;COPY TO&lt;/code&gt; 中和使用 &lt;code&gt;CSV&lt;/code&gt; 格式时才允许使用此选项。</target>
        </trans-unit>
        <trans-unit id="538b02792cabcf9f2865608e41802e229f615f71" translate="yes" xml:space="preserve">
          <source>Forces the server to switch to a new write-ahead log file, which allows the current file to be archived (assuming you are using continuous archiving). The result is the ending write-ahead log location plus 1 within the just-completed write-ahead log file. If there has been no write-ahead log activity since the last write-ahead log switch, &lt;code&gt;pg_switch_wal&lt;/code&gt; does nothing and returns the start location of the write-ahead log file currently in use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e53ee207fccbc10bf771537429c8ceb105018b4c" translate="yes" xml:space="preserve">
          <source>Foreign Data</source>
          <target state="translated">国外数据</target>
        </trans-unit>
        <trans-unit id="60b698071b99433356500a6664686a79ff0c576f" translate="yes" xml:space="preserve">
          <source>Foreign data is accessed with help from a &lt;em&gt;foreign data wrapper&lt;/em&gt;. A foreign data wrapper is a library that can communicate with an external data source, hiding the details of connecting to the data source and obtaining data from it. There are some foreign data wrappers available as &lt;code&gt;contrib&lt;/code&gt; modules; see &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;Appendix F&lt;/a&gt;. Other kinds of foreign data wrappers might be found as third party products. If none of the existing foreign data wrappers suit your needs, you can write your own; see &lt;a href=&quot;https://www.postgresql.org/docs/12/fdwhandler.html&quot;&gt;Chapter 56&lt;/a&gt;.</source>
          <target state="translated">外部数据在&lt;em&gt;外部数据包装器的&lt;/em&gt;帮助下进行访问。外部数据包装器是一个可以与外部数据源进行通信的库，它隐藏了连接到数据源并从中获取数据的详细信息。有一些外部数据包装器可以用作 &lt;code&gt;contrib&lt;/code&gt; 模块。见&lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;附录F&lt;/a&gt;。其他类型的外部数据包装器也可能是第三方产品。如果现有的外部数据包装器都不满足您的需求，则可以编写自己的数据包装器；参见&lt;a href=&quot;https://www.postgresql.org/docs/12/fdwhandler.html&quot;&gt;第56章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e081c17d534c83bc3c89dd5e5ae11f9988469a0c" translate="yes" xml:space="preserve">
          <source>Foreign data is accessed with help from a &lt;em&gt;foreign data wrapper&lt;/em&gt;. A foreign data wrapper is a library that can communicate with an external data source, hiding the details of connecting to the data source and obtaining data from it. There are some foreign data wrappers available as &lt;code&gt;contrib&lt;/code&gt; modules; see &lt;a href=&quot;https://www.postgresql.org/docs/13/contrib.html&quot;&gt;Appendix F&lt;/a&gt;. Other kinds of foreign data wrappers might be found as third party products. If none of the existing foreign data wrappers suit your needs, you can write your own; see &lt;a href=&quot;https://www.postgresql.org/docs/13/fdwhandler.html&quot;&gt;Chapter 56&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d0b62aaedf4c17c32eaa3ba64c33e854069e4d0" translate="yes" xml:space="preserve">
          <source>Foreign data wrapper</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec49828d4aeea86333a990a4bd9c0abe72c2db0a" translate="yes" xml:space="preserve">
          <source>Foreign key</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94c0cd02df3f1a32213c26c15ceb6bc33046efb5" translate="yes" xml:space="preserve">
          <source>Foreign key deletion action code: &lt;code&gt;a&lt;/code&gt; = no action, &lt;code&gt;r&lt;/code&gt; = restrict, &lt;code&gt;c&lt;/code&gt; = cascade, &lt;code&gt;n&lt;/code&gt; = set null, &lt;code&gt;d&lt;/code&gt; = set default</source>
          <target state="translated">外键删除操作代码： &lt;code&gt;a&lt;/code&gt; =不执行操作， &lt;code&gt;r&lt;/code&gt; =限制， &lt;code&gt;c&lt;/code&gt; =级联， &lt;code&gt;n&lt;/code&gt; =设置为空， &lt;code&gt;d&lt;/code&gt; =设置为默认</target>
        </trans-unit>
        <trans-unit id="67ed786663de0061ba336e549d3d7d184b09ab90" translate="yes" xml:space="preserve">
          <source>Foreign key match type: &lt;code&gt;f&lt;/code&gt; = full, &lt;code&gt;p&lt;/code&gt; = partial, &lt;code&gt;s&lt;/code&gt; = simple</source>
          <target state="translated">外键匹配类型： &lt;code&gt;f&lt;/code&gt; =完整， &lt;code&gt;p&lt;/code&gt; =部分， &lt;code&gt;s&lt;/code&gt; =简单</target>
        </trans-unit>
        <trans-unit id="f7223fe60c8520d1d8c5dd54e60a3a21d67aff2e" translate="yes" xml:space="preserve">
          <source>Foreign key update action code: &lt;code&gt;a&lt;/code&gt; = no action, &lt;code&gt;r&lt;/code&gt; = restrict, &lt;code&gt;c&lt;/code&gt; = cascade, &lt;code&gt;n&lt;/code&gt; = set null, &lt;code&gt;d&lt;/code&gt; = set default</source>
          <target state="translated">外键更新操作代码： &lt;code&gt;a&lt;/code&gt; =无操作， &lt;code&gt;r&lt;/code&gt; =限制， &lt;code&gt;c&lt;/code&gt; =级联， &lt;code&gt;n&lt;/code&gt; =设置为空， &lt;code&gt;d&lt;/code&gt; =设置为默认</target>
        </trans-unit>
        <trans-unit id="24479ccb6a12c499e80b0da414bfcc11fa42a42f" translate="yes" xml:space="preserve">
          <source>Foreign server</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65a5d0add327edf5ad461c0cb7f6054d85e3b0e7" translate="yes" xml:space="preserve">
          <source>Foreign server specific options, as &amp;ldquo;keyword=value&amp;rdquo; strings</source>
          <target state="translated">特定于外部服务器的选项，例如&amp;ldquo; keyword = value&amp;rdquo;字符串</target>
        </trans-unit>
        <trans-unit id="2328a33941c65762849f0c57e1700f0618ac2c11" translate="yes" xml:space="preserve">
          <source>Foreign table (relation)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1b45f3e264a3f3e8e58872fe892f43e82136b90" translate="yes" xml:space="preserve">
          <source>Foreign table options, as &amp;ldquo;keyword=value&amp;rdquo; strings</source>
          <target state="translated">外部表选项，如&amp;ldquo; keyword = value&amp;rdquo;字符串</target>
        </trans-unit>
        <trans-unit id="a914bd9dafd1ce6150ce31452c647084bd0851ab" translate="yes" xml:space="preserve">
          <source>Foreign tables (see &lt;a href=&quot;ddl-foreign-data&quot;&gt;Section 5.12&lt;/a&gt;) can also be part of inheritance hierarchies, either as parent or child tables, just as regular tables can be. If a foreign table is part of an inheritance hierarchy then any operations not supported by the foreign table are not supported on the whole hierarchy either.</source>
          <target state="translated">就像常规表一样，外部表（请参阅&lt;a href=&quot;ddl-foreign-data&quot;&gt;第5.12节&lt;/a&gt;）也可以作为父表或子表作为继承层次结构的一部分。如果外部表是继承层次结构的一部分，则整个层次结构也不支持外部表不支持的任何操作。</target>
        </trans-unit>
        <trans-unit id="f355c9e7f0aaa375694a97f071442929b8bef72d" translate="yes" xml:space="preserve">
          <source>Foreign tables are analyzed only when explicitly selected. Not all foreign data wrappers support &lt;code&gt;ANALYZE&lt;/code&gt;. If the table's wrapper does not support &lt;code&gt;ANALYZE&lt;/code&gt;, the command prints a warning and does nothing.</source>
          <target state="translated">仅在明确选择外部表时才对其进行分析。并非所有外部数据包装器都支持 &lt;code&gt;ANALYZE&lt;/code&gt; 。如果表的包装器不支持 &lt;code&gt;ANALYZE&lt;/code&gt; ，则该命令将显示警告并且不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="114810936e2e203f850dfc30c1a7c22dda77dc02" translate="yes" xml:space="preserve">
          <source>Foreign tables can have generated columns. See &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt; for details.</source>
          <target state="translated">外部表可以具有生成的列。有关详细信息，请参见&lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="85799ef6669eba496b7c90dd087afbef34699725" translate="yes" xml:space="preserve">
          <source>Foreign-data wrapper specific options, as &amp;ldquo;keyword=value&amp;rdquo; strings</source>
          <target state="translated">外部数据包装程序特定的选项，如&amp;ldquo; keyword = value&amp;rdquo;字符串</target>
        </trans-unit>
        <trans-unit id="471121e27a3e0f2a208ec3e9a0b109102268a22f" translate="yes" xml:space="preserve">
          <source>Fork</source>
          <target state="translated">Fork</target>
        </trans-unit>
        <trans-unit id="8340dbc9e3b7c8b79fc57d1ea821c4dd6ab2e45a" translate="yes" xml:space="preserve">
          <source>Fork number within the relation; see &lt;code&gt;include/common/relpath.h&lt;/code&gt;</source>
          <target state="translated">关系内的货叉号；参见 &lt;code&gt;include/common/relpath.h&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bfff5fab0567decaa660bb51d870a4a558ade9bd" translate="yes" xml:space="preserve">
          <source>Form feed (ASCII 12)</source>
          <target state="translated">表格输入(ASCII 12)</target>
        </trans-unit>
        <trans-unit id="2186cd568d6445c67ce20f9b2564241918cf9481" translate="yes" xml:space="preserve">
          <source>Format arguments according to a format string. This function is similar to the C function &lt;code&gt;sprintf&lt;/code&gt;. See &lt;a href=&quot;functions-string#FUNCTIONS-STRING-FORMAT&quot;&gt;Section 9.4.1&lt;/a&gt;.</source>
          <target state="translated">根据格式字符串设置参数格式。此函数类似于C函数 &lt;code&gt;sprintf&lt;/code&gt; 。参见&lt;a href=&quot;functions-string#FUNCTIONS-STRING-FORMAT&quot;&gt;第9.4.1节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2f10703a114eeb65e11771dfbfc8cbc068e4d983" translate="yes" xml:space="preserve">
          <source>Format of the &lt;code&gt;.dict&lt;/code&gt; file is:</source>
          <target state="translated">&lt;code&gt;.dict&lt;/code&gt; 文件的格式为：</target>
        </trans-unit>
        <trans-unit id="d32d1fc793b4203a324b693b7b245d9ad6dbbf1f" translate="yes" xml:space="preserve">
          <source>Format specifiers are introduced by a &lt;code&gt;%&lt;/code&gt; character and have the form</source>
          <target state="translated">格式说明符由 &lt;code&gt;%&lt;/code&gt; 字符引入，格式为</target>
        </trans-unit>
        <trans-unit id="c46b5c69a535eddb26b0b25a59b562dfdb1ab01b" translate="yes" xml:space="preserve">
          <source>Formats arguments according to a format string; see &lt;a href=&quot;functions-string#FUNCTIONS-STRING-FORMAT&quot;&gt;Section 9.4.1&lt;/a&gt;. This function is similar to the C function &lt;code&gt;sprintf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac4e3c929fdec4f6080024051a0ba50e01f4af70" translate="yes" xml:space="preserve">
          <source>Formatting Functions</source>
          <target state="translated">格式化功能</target>
        </trans-unit>
        <trans-unit id="27f02bbdc243505380802862dfc269e6f51a4b71" translate="yes" xml:space="preserve">
          <source>Formatting of currency amounts</source>
          <target state="translated">货币金额的格式化</target>
        </trans-unit>
        <trans-unit id="3117b3b2c7e85f24cb15daec9ea8d347a5a664b1" translate="yes" xml:space="preserve">
          <source>Formatting of dates and times</source>
          <target state="translated">日期和时间的格式化</target>
        </trans-unit>
        <trans-unit id="860fd1b538482a0032ad8bac4633d0f2e1fcba7b" translate="yes" xml:space="preserve">
          <source>Formatting of numbers</source>
          <target state="translated">数字的格式化</target>
        </trans-unit>
        <trans-unit id="6a1f6ab661d4c193244f17d409e7e72bd4d570ee" translate="yes" xml:space="preserve">
          <source>Fortunately, PostgreSQL has the ability to combine multiple indexes (including multiple uses of the same index) to handle cases that cannot be implemented by single index scans. The system can form &lt;code&gt;AND&lt;/code&gt; and &lt;code&gt;OR&lt;/code&gt; conditions across several index scans. For example, a query like &lt;code&gt;WHERE x = 42 OR x = 47 OR x = 53 OR x = 99&lt;/code&gt; could be broken down into four separate scans of an index on &lt;code&gt;x&lt;/code&gt;, each scan using one of the query clauses. The results of these scans are then ORed together to produce the result. Another example is that if we have separate indexes on &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, one possible implementation of a query like &lt;code&gt;WHERE x = 5 AND y = 6&lt;/code&gt; is to use each index with the appropriate query clause and then AND together the index results to identify the result rows.</source>
          <target state="translated">幸运的是，PostgreSQL能够合并多个索引（包括对同一索引的多次使用）来处理无法通过单个索引扫描实现的情况。系统可以在多个索引扫描中形成 &lt;code&gt;AND&lt;/code&gt; 和 &lt;code&gt;OR&lt;/code&gt; 条件。例如，诸如 &lt;code&gt;WHERE x = 42 OR x = 47 OR x = 53 OR x = 99&lt;/code&gt; 可以分解为 &lt;code&gt;x&lt;/code&gt; 上索引的四次单独扫描，每次扫描都使用查询子句之一。然后将这些扫描的结果进行&amp;ldquo;或&amp;rdquo;运算以产生结果。另一个例子是，如果我们在 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 上有单独的索引，则查询的一种可能实现如 &lt;code&gt;WHERE x = 5 AND y = 6&lt;/code&gt; 是将每个索引与适当的查询子句一起使用，然后对索引结果进行&amp;ldquo;与&amp;rdquo;运算以标识结果行。</target>
        </trans-unit>
        <trans-unit id="7a4530052e4c5506e1ca3c7fe0019b4ab8ad7aeb" translate="yes" xml:space="preserve">
          <source>Forward transition function for moving-aggregate mode (zero if none)</source>
          <target state="translated">移动-聚集模式的正向过渡功能(如果没有,则为零)。</target>
        </trans-unit>
        <trans-unit id="f6bf4e66e6e60c9947bd8c75fee01c881afbe844" translate="yes" xml:space="preserve">
          <source>Fourth, verify your shell is operating in the &lt;code&gt;unconfined_t&lt;/code&gt; domain:</source>
          <target state="translated">第四，验证您的外壳程序是否在 &lt;code&gt;unconfined_t&lt;/code&gt; 域中运行：</target>
        </trans-unit>
        <trans-unit id="3b72b0d434a6da3b7a140f72c4533ea003e1049d" translate="yes" xml:space="preserve">
          <source>Fraction of column entries that are null</source>
          <target state="translated">列项为空的部分</target>
        </trans-unit>
        <trans-unit id="05336909662a05ee4c216375dd2926cd06ca7ff1" translate="yes" xml:space="preserve">
          <source>Free Space Map</source>
          <target state="translated">自由空间地图</target>
        </trans-unit>
        <trans-unit id="8d1442f2468898b3b97983d4c108633f0dd9704b" translate="yes" xml:space="preserve">
          <source>Free space</source>
          <target state="translated">自由空间</target>
        </trans-unit>
        <trans-unit id="15b3a8f5ed1b0f0d55b8d26fe0145527a2ec6761" translate="yes" xml:space="preserve">
          <source>Free space map (fork)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b845fdaff1bf49c014dff506cfa6bdc63dadd835" translate="yes" xml:space="preserve">
          <source>FreeBSD</source>
          <target state="translated">FreeBSD</target>
        </trans-unit>
        <trans-unit id="eba92e8cbbcf79124e18b38dc9296cb1e7b3c90c" translate="yes" xml:space="preserve">
          <source>FreeBSD also allows changing the time source on the fly, and it logs information about the timer selected during boot:</source>
          <target state="translated">FreeBSD 还允许在飞行中改变时间源,并在启动时记录所选定时器的信息。</target>
        </trans-unit>
        <trans-unit id="163ea5dad4eb636b98f8ad7f2021b2c2146c890b" translate="yes" xml:space="preserve">
          <source>FreeBSD libcrypt</source>
          <target state="translated">FreeBSD libcrypt</target>
        </trans-unit>
        <trans-unit id="28073e04cfc0b55e307bd7ab2f2fab043889d334" translate="yes" xml:space="preserve">
          <source>FreeBSD versions before 4.0 work like old OpenBSD (see below).</source>
          <target state="translated">4.0之前的FreeBSD版本就像旧版的OpenBSD一样工作(见下文)。</target>
        </trans-unit>
        <trans-unit id="343be4952511cb2fc2b6ddde12f9c10d6cce223e" translate="yes" xml:space="preserve">
          <source>Frequent calls to this function could have some impact on database performance, because it needs access to the predicate lock manager's shared state for a short time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62bfe0b7eae857a638e0542deb3faf6e7cb6ef3b" translate="yes" xml:space="preserve">
          <source>Frequent calls to this function could have some impact on database performance, because it needs exclusive access to the lock manager's shared state for a short time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d790b402d79ac1a723c790313bcd679999474630" translate="yes" xml:space="preserve">
          <source>Frequently Asked Questions</source>
          <target state="translated">常问问题</target>
        </trans-unit>
        <trans-unit id="bbd6e32ee1326237814b697269b4368033d50d2f" translate="yes" xml:space="preserve">
          <source>Fri</source>
          <target state="translated">Fri</target>
        </trans-unit>
        <trans-unit id="d166e844a3f3f87149cc4f866eb998e9a751c72a" translate="yes" xml:space="preserve">
          <source>Friday</source>
          <target state="translated">Friday</target>
        </trans-unit>
        <trans-unit id="0092eefda9395145cd29888b2348888692bc90be" translate="yes" xml:space="preserve">
          <source>From PostgreSQL 11, adding a column with a constant default value no longer means that each row of the table needs to be updated when the &lt;code&gt;ALTER TABLE&lt;/code&gt; statement is executed. Instead, the default value will be returned the next time the row is accessed, and applied when the table is rewritten, making the &lt;code&gt;ALTER TABLE&lt;/code&gt; very fast even on large tables.</source>
          <target state="translated">从PostgreSQL 11开始，添加具有恒定默认值的列不再意味着在执行 &lt;code&gt;ALTER TABLE&lt;/code&gt; 语句时需要更新表的每一行。取而代之的是，默认值将在下次访问该行时返回，并在重写表时应用，从而使 &lt;code&gt;ALTER TABLE&lt;/code&gt; 即使在大型表上也非常快。</target>
        </trans-unit>
        <trans-unit id="74866cf8a85ad43b25b0fa833b5c4a9e7721fc2f" translate="yes" xml:space="preserve">
          <source>From PostgreSQL 8.3 on, there is XML-related functionality based on the SQL/XML standard in the core server. That functionality covers XML syntax checking and XPath queries, which is what this module does, and more, but the API is not at all compatible. It is planned that this module will be removed in a future version of PostgreSQL in favor of the newer standard API, so you are encouraged to try converting your applications. If you find that some of the functionality of this module is not available in an adequate form with the newer API, please explain your issue to &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:pgsql-hackers@lists.postgresql.org&quot;&gt;pgsql-hackers@lists.postgresql.org&lt;/a&gt;&amp;gt;&lt;/code&gt; so that the deficiency can be addressed.</source>
          <target state="translated">从PostgreSQL 8.3开始，核心服务器中具有基于SQL / XML标准的XML相关功能。该功能涵盖了XML语法检查和XPath查询（这是该模块的工作），以及更多，但API根本不兼容。我们计划在PostgreSQL的未来版本中删除该模块，以支持较新的标准API，因此建议您尝试转换应用程序。如果发现更新的API无法以适当的形式提供此模块的某些功能，请向 &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:pgsql-hackers@lists.postgresql.org&quot;&gt;pgsql-hackers@lists.postgresql.org&lt;/a&gt;&amp;gt;&lt;/code&gt; 解释您的问题，以便可以解决缺陷。</target>
        </trans-unit>
        <trans-unit id="278d8abdb35f5b8d4b7f92c6d932b66d8fe44745" translate="yes" xml:space="preserve">
          <source>From experience, values in the thousands (e.g., 5000 &amp;mdash; 20000) work well.</source>
          <target state="translated">根据经验，成千上万的值（例如5000 &amp;mdash; 20000）效果很好。</target>
        </trans-unit>
        <trans-unit id="a9f490fca8caa246230fe49e0dcc7c45a0810a07" translate="yes" xml:space="preserve">
          <source>From the point of view of the issuing session, &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; is not unlike a &lt;code&gt;ROLLBACK&lt;/code&gt; command: after executing it, there is no active current transaction, and the effects of the prepared transaction are no longer visible. (The effects will become visible again if the transaction is committed.)</source>
          <target state="translated">从发布会话的角度来看， &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; 与 &lt;code&gt;ROLLBACK&lt;/code&gt; 命令没有什么不同：执行它之后，没有活动的当前事务，并且不再可见准备好的事务的效果。 （如果提交事务，则效果将再次可见。）</target>
        </trans-unit>
        <trans-unit id="2047a74f4a2930f4b44969e9f4cae7215400249e" translate="yes" xml:space="preserve">
          <source>Frontend code should not include any &lt;code&gt;pg_xxx.h&lt;/code&gt; catalog header file, as these files may contain C code that won't compile outside the backend. (Typically, that happens because these files also contain declarations for functions in &lt;code&gt;src/backend/catalog/&lt;/code&gt; files.) Instead, frontend code may include the corresponding generated &lt;code&gt;pg_xxx_d.h&lt;/code&gt; header, which will contain OID &lt;code&gt;#define&lt;/code&gt;s and any other data that might be of use on the client side. If you want macros or other code in a catalog header to be visible to frontend code, write &lt;code&gt;#ifdef EXPOSE_TO_CLIENT_CODE&lt;/code&gt; ... &lt;code&gt;#endif&lt;/code&gt; around that section to instruct &lt;code&gt;genbki.pl&lt;/code&gt; to copy that section to the &lt;code&gt;pg_xxx_d.h&lt;/code&gt; header.</source>
          <target state="translated">前端代码不应包含任何 &lt;code&gt;pg_xxx.h&lt;/code&gt; 目录头文件，因为这些文件可能包含不会在后端外部编译的C代码。（通常会发生这种情况，因为这些文件还包含 &lt;code&gt;src/backend/catalog/&lt;/code&gt; 文件中的函数声明。）相反，前端代码可能包括相应的生成的 &lt;code&gt;pg_xxx_d.h&lt;/code&gt; 标头，该标头将包含OID &lt;code&gt;#define&lt;/code&gt; 以及任何其他可能在客户端有用。如果希望目录头中的宏或其他代码对前端代码可见，请在该部分周围编写 &lt;code&gt;#ifdef EXPOSE_TO_CLIENT_CODE&lt;/code&gt; ... &lt;code&gt;#endif&lt;/code&gt; ，以指示 &lt;code&gt;genbki.pl&lt;/code&gt; 将其复制到 &lt;code&gt;pg_xxx_d.h&lt;/code&gt; 标头。</target>
        </trans-unit>
        <trans-unit id="5342caa1027afd1b462e71637b0394a8eb14ac7b" translate="yes" xml:space="preserve">
          <source>Frontend/Backend Protocol</source>
          <target state="translated">前端/后端协议</target>
        </trans-unit>
        <trans-unit id="6b2e86b36efeac1ca193b435611b528921adc671" translate="yes" xml:space="preserve">
          <source>Full Text Search</source>
          <target state="translated">全文检索</target>
        </trans-unit>
        <trans-unit id="58bab05efd3bb13a137c704cfe50139caf2da01d" translate="yes" xml:space="preserve">
          <source>Full Text Searching (or just &lt;em&gt;text search&lt;/em&gt;) provides the capability to identify natural-language &lt;em&gt;documents&lt;/em&gt; that satisfy a &lt;em&gt;query&lt;/em&gt;, and optionally to sort them by relevance to the query. The most common type of search is to find all documents containing given &lt;em&gt;query terms&lt;/em&gt; and return them in order of their &lt;em&gt;similarity&lt;/em&gt; to the query. Notions of &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;similarity&lt;/code&gt; are very flexible and depend on the specific application. The simplest search considers &lt;code&gt;query&lt;/code&gt; as a set of words and &lt;code&gt;similarity&lt;/code&gt; as the frequency of query words in the document.</source>
          <target state="translated">全文搜索（或仅&lt;em&gt;文本搜索&lt;/em&gt;）提供了识别满足&lt;em&gt;查询条件的&lt;/em&gt;自然语言&lt;em&gt;文档&lt;/em&gt;的功能，并可以选择根据查询的相关性对它们进行排序。最常见的搜索类型是查找包含给定&lt;em&gt;查询词的&lt;/em&gt;所有文档，然后按与查询&lt;em&gt;相似的&lt;/em&gt;顺序返回它们。 &lt;code&gt;query&lt;/code&gt; 和 &lt;code&gt;similarity&lt;/code&gt; 概念非常灵活，并且取决于特定的应用程序。最简单的搜索将 &lt;code&gt;query&lt;/code&gt; 视为一组单词，并将 &lt;code&gt;similarity&lt;/code&gt; 视为文档中查询单词的频率。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="db82b334faa95ac9dd9f6513348aba4908da1917" translate="yes" xml:space="preserve">
          <source>Full knowledge of running transactions is required before snapshots can be taken. Transactions that use large numbers of subtransactions (currently greater than 64) will delay the start of read only connections until the completion of the longest running write transaction. If this situation occurs, explanatory messages will be sent to the server log.</source>
          <target state="translated">在拍摄快照之前,需要充分了解正在运行的事务。使用大量子事务(目前大于64个)的事务会延迟开始只读连接,直到完成最长运行的写事务。如果出现这种情况,将向服务器日志发送解释信息。</target>
        </trans-unit>
        <trans-unit id="0c4e89b5598c4c2f96620f236425e65a764b4e0c" translate="yes" xml:space="preserve">
          <source>Full path name of the configuration file</source>
          <target state="translated">配置文件的完整路径名</target>
        </trans-unit>
        <trans-unit id="f75d588686a67b50b8825a6ec9a2cd0fa788d6f1" translate="yes" xml:space="preserve">
          <source>Full text indexing allows documents to be &lt;em&gt;preprocessed&lt;/em&gt; and an index saved for later rapid searching. Preprocessing includes:</source>
          <target state="translated">全文索引允许对文档进行&lt;em&gt;预处理，&lt;/em&gt;并保存索引以供以后快速搜索。预处理包括：</target>
        </trans-unit>
        <trans-unit id="1e173192dc3f0eff1cb3f86ab840c4e44f26a1a2" translate="yes" xml:space="preserve">
          <source>Full text searching in PostgreSQL is based on the match operator &lt;code&gt;@@&lt;/code&gt;, which returns &lt;code&gt;true&lt;/code&gt; if a &lt;code&gt;tsvector&lt;/code&gt; (document) matches a &lt;code&gt;tsquery&lt;/code&gt; (query). It doesn't matter which data type is written first:</source>
          <target state="translated">PostgreSQL中的全文本搜索基于匹配运算符 &lt;code&gt;@@&lt;/code&gt; ，如果 &lt;code&gt;tsvector&lt;/code&gt; （文档）与 &lt;code&gt;tsquery&lt;/code&gt; （查询）匹配，则返回 &lt;code&gt;true&lt;/code&gt; 。首先写入哪种数据类型无关紧要：</target>
        </trans-unit>
        <trans-unit id="31ad0600481ef9dcfec15d2c9583987bbeea5538" translate="yes" xml:space="preserve">
          <source>Full time zone name</source>
          <target state="translated">全时区名称</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="199b395518a17474f39a98683e459c8710d22bf0" translate="yes" xml:space="preserve">
          <source>Function (degrees)</source>
          <target state="translated">功能(度)</target>
        </trans-unit>
        <trans-unit id="c4cdc4b98800828d365361d7093d5e13c470e528" translate="yes" xml:space="preserve">
          <source>Function (radians)</source>
          <target state="translated">功能(弧度)</target>
        </trans-unit>
        <trans-unit id="f20152848a0a27fa254ba49727fe94ca837e87e8" translate="yes" xml:space="preserve">
          <source>Function (routine)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3ebe4e72fe78109751ae6020102e21b46343c0b" translate="yes" xml:space="preserve">
          <source>Function &lt;code&gt;concat_lower_or_upper&lt;/code&gt; has two mandatory parameters, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. Additionally there is one optional parameter &lt;code&gt;uppercase&lt;/code&gt; which defaults to &lt;code&gt;false&lt;/code&gt;. The &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; inputs will be concatenated, and forced to either upper or lower case depending on the &lt;code&gt;uppercase&lt;/code&gt; parameter. The remaining details of this function definition are not important here (see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend.html&quot;&gt;Chapter 37&lt;/a&gt; for more information).</source>
          <target state="translated">函数 &lt;code&gt;concat_lower_or_upper&lt;/code&gt; 具有两个必需参数 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 。此外，还有一个可选参数 &lt;code&gt;uppercase&lt;/code&gt; ，默认为 &lt;code&gt;false&lt;/code&gt; 。的 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 输入将被连接在一起，并被迫大写或小写取决于 &lt;code&gt;uppercase&lt;/code&gt; 参数。此函数定义的其余细节在这里并不重要（有关更多信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/extend.html&quot;&gt;第37章&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2af2dc6af90c7c987875d7c9624eadd9b65f4d37" translate="yes" xml:space="preserve">
          <source>Function &lt;code&gt;concat_lower_or_upper&lt;/code&gt; has two mandatory parameters, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. Additionally there is one optional parameter &lt;code&gt;uppercase&lt;/code&gt; which defaults to &lt;code&gt;false&lt;/code&gt;. The &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; inputs will be concatenated, and forced to either upper or lower case depending on the &lt;code&gt;uppercase&lt;/code&gt; parameter. The remaining details of this function definition are not important here (see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend.html&quot;&gt;Chapter 37&lt;/a&gt; for more information).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9485768ec808a8458b8061522775420e2a0d736" translate="yes" xml:space="preserve">
          <source>Function Calls in &lt;code&gt;FROM&lt;/code&gt;</source>
          <target state="translated">在 &lt;code&gt;FROM&lt;/code&gt; 中的函数调用</target>
        </trans-unit>
        <trans-unit id="5cd7aa6580361c1c90294750468e2a6e5d51165d" translate="yes" xml:space="preserve">
          <source>Function Security</source>
          <target state="translated">功能安全</target>
        </trans-unit>
        <trans-unit id="307d58da1cb5c708acf50f78b41a528827c81cf8" translate="yes" xml:space="preserve">
          <source>Function calls</source>
          <target state="translated">功能调用</target>
        </trans-unit>
        <trans-unit id="8b07e5d5a0f30facf481faff6183bfd24366f034" translate="yes" xml:space="preserve">
          <source>Function calls can appear in the &lt;code&gt;FROM&lt;/code&gt; clause. (This is especially useful for functions that return result sets, but any function can be used.) This acts as though the function's output were created as a temporary table for the duration of this single &lt;code&gt;SELECT&lt;/code&gt; command. When the optional &lt;code&gt;WITH ORDINALITY&lt;/code&gt; clause is added to the function call, a new column is appended after all the function's output columns with numbering for each row.</source>
          <target state="translated">函数调用可以出现在 &lt;code&gt;FROM&lt;/code&gt; 子句中。 （这对于返回结果集的函数特别有用，但是可以使用任何函数。）这就像在单个 &lt;code&gt;SELECT&lt;/code&gt; 命令期间将函数的输出创建为临时表一样。当将可选的 &lt;code&gt;WITH ORDINALITY&lt;/code&gt; 子句添加到函数调用中时，新列将追加到所有函数的输出列之后，并为每行编号。</target>
        </trans-unit>
        <trans-unit id="b4946fa700c9eda6e438f9d998236ae26798c94a" translate="yes" xml:space="preserve">
          <source>Function is a security definer (i.e., a &amp;ldquo;setuid&amp;rdquo; function)</source>
          <target state="translated">函数是安全定义器（即&amp;ldquo; setuid&amp;rdquo;函数）</target>
        </trans-unit>
        <trans-unit id="716c6238c1da557cf03815f10e855bae3322359c" translate="yes" xml:space="preserve">
          <source>Function returns a set (i.e., multiple values of the specified data type)</source>
          <target state="translated">函数返回一组(即指定数据类型的多个值)。</target>
        </trans-unit>
        <trans-unit id="23fbe0cb5a01469d890d631e094cc17384405a30" translate="yes" xml:space="preserve">
          <source>Function returns null if any call argument is null. In that case the function won't actually be called at all. Functions that are not &amp;ldquo;strict&amp;rdquo; must be prepared to handle null inputs.</source>
          <target state="translated">如果任何调用参数为null，则函数返回null。在这种情况下，实际上根本不会调用该函数。非&amp;ldquo;严格&amp;rdquo;功能必须准备好处理空输入。</target>
        </trans-unit>
        <trans-unit id="8fd90f4b1717187c9f3e3d19223db85d2f734625" translate="yes" xml:space="preserve">
          <source>Function that implements this operator</source>
          <target state="translated">实现该运算符的函数</target>
        </trans-unit>
        <trans-unit id="3d160cc011b485e39a85d5d485371501ec7cfb5f" translate="yes" xml:space="preserve">
          <source>Function's local settings for run-time configuration variables</source>
          <target state="translated">功能的运行时配置变量的本地设置。</target>
        </trans-unit>
        <trans-unit id="ec496000534b307fd515f93c3bf982f8043b1486" translate="yes" xml:space="preserve">
          <source>Function/Operator</source>
          <target state="translated">Function/Operator</target>
        </trans-unit>
        <trans-unit id="72f655d0260fed163ce26bf8c073ff029ead93e0" translate="yes" xml:space="preserve">
          <source>Functional Dependencies</source>
          <target state="translated">功能依赖性</target>
        </trans-unit>
        <trans-unit id="6538b8b49394fd4058eb032b1ed6c7549c5fd8b9" translate="yes" xml:space="preserve">
          <source>Functional dependencies are currently only applied when considering simple equality conditions that compare columns to constant values, and &lt;code&gt;IN&lt;/code&gt; clauses with constant values. They are not used to improve estimates for equality conditions comparing two columns or comparing a column to an expression, nor for range clauses, &lt;code&gt;LIKE&lt;/code&gt; or any other type of condition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ff8dd38721f013a6f2f4a7b0736888d581a5d95" translate="yes" xml:space="preserve">
          <source>Functional dependencies are currently only applied when considering simple equality conditions that compare columns to constant values. They are not used to improve estimates for equality conditions comparing two columns or comparing a column to an expression, nor for range clauses, &lt;code&gt;LIKE&lt;/code&gt; or any other type of condition.</source>
          <target state="translated">当前仅在考虑将列与常量值进行比较的简单相等条件时才应用功能依赖项。它们不用于改进比较两列或将一列与表达式进行比较的相等条件的估计，也不用于范围子句， &lt;code&gt;LIKE&lt;/code&gt; 或任何其他类型的条件。</target>
        </trans-unit>
        <trans-unit id="c1d8fc0143ef31c2eddcaedc63b8975839dcb0a6" translate="yes" xml:space="preserve">
          <source>Functional dependency statistics</source>
          <target state="translated">功能依赖性统计</target>
        </trans-unit>
        <trans-unit id="66e4b5d56651ee62066b47e8179cf0572f0a44de" translate="yes" xml:space="preserve">
          <source>Functional dependency statistics, serialized as &lt;code&gt;pg_dependencies&lt;/code&gt; type</source>
          <target state="translated">功能依赖性统计信息，序列化为 &lt;code&gt;pg_dependencies&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="79fde2ac8490ff2b99ac9c9890e046fdff6e3659" translate="yes" xml:space="preserve">
          <source>Functionality</source>
          <target state="translated">Functionality</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="2ef4610dd144f45355b17173e115381a509a4ae6" translate="yes" xml:space="preserve">
          <source>Functions &lt;code&gt;get_byte&lt;/code&gt; and &lt;code&gt;set_byte&lt;/code&gt; number the first byte of a binary string as byte 0. Functions &lt;code&gt;get_bit&lt;/code&gt; and &lt;code&gt;set_bit&lt;/code&gt; number bits from the right within each byte; for example bit 0 is the least significant bit of the first byte, and bit 15 is the most significant bit of the second byte.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bc6ed2a77aad7bfa2b82a40e38f2ba52fbf90bc" translate="yes" xml:space="preserve">
          <source>Functions &lt;code&gt;justify_days&lt;/code&gt; and &lt;code&gt;justify_hours&lt;/code&gt; are available for adjusting days and hours that overflow their normal ranges.</source>
          <target state="translated">函数 &lt;code&gt;justify_days&lt;/code&gt; 和 &lt;code&gt;justify_hours&lt;/code&gt; 可用于调整超出正常范围的天数和小时数。</target>
        </trans-unit>
        <trans-unit id="be003abde8f2ab71ad33e1cc06ea3dd303feedda" translate="yes" xml:space="preserve">
          <source>Functions and Operators</source>
          <target state="translated">函数和运算符</target>
        </trans-unit>
        <trans-unit id="c65bb1eea1a55d451d6926238ca1817228c00025" translate="yes" xml:space="preserve">
          <source>Functions and aggregates must be marked &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; if they write to the database, access sequences, change the transaction state even temporarily (e.g. a PL/pgSQL function which establishes an &lt;code&gt;EXCEPTION&lt;/code&gt; block to catch errors), or make persistent changes to settings. Similarly, functions must be marked &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; if they access temporary tables, client connection state, cursors, prepared statements, or miscellaneous backend-local state which the system cannot synchronize across workers. For example, &lt;code&gt;setseed&lt;/code&gt; and &lt;code&gt;random&lt;/code&gt; are parallel restricted for this last reason.</source>
          <target state="translated">如果函数和聚合写入数据库，访问序列，甚至临时更改事务状态（例如，建立 &lt;code&gt;EXCEPTION&lt;/code&gt; 块以捕获错误的PL / pgSQL函数）或对设置进行永久更改，则它们必须标记为 &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; 。同样，如果函数访问临时表，客户端连接状态，游标，准备好的语句或系统无法在工作进程之间同步的其他后端本地状态，则必须将它们标记为 &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; 。例如， &lt;code&gt;setseed&lt;/code&gt; 最后一个原因，并行限制了setseed和 &lt;code&gt;random&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d1d2a2fe42ec99a70594ecc07d4bafedfeedcc6" translate="yes" xml:space="preserve">
          <source>Functions and aggregates must be marked &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; if they write to the database, access sequences, change the transaction state even temporarily (e.g., a PL/pgSQL function which establishes an &lt;code&gt;EXCEPTION&lt;/code&gt; block to catch errors), or make persistent changes to settings. Similarly, functions must be marked &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; if they access temporary tables, client connection state, cursors, prepared statements, or miscellaneous backend-local state which the system cannot synchronize across workers. For example, &lt;code&gt;setseed&lt;/code&gt; and &lt;code&gt;random&lt;/code&gt; are parallel restricted for this last reason.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fe9555fcfd38cd02c2b84229962727f96f4f2eb" translate="yes" xml:space="preserve">
          <source>Functions and most operators return &lt;code&gt;NULL&lt;/code&gt; on &lt;code&gt;NULL&lt;/code&gt; input.</source>
          <target state="translated">函数和大多数运算符在 &lt;code&gt;NULL&lt;/code&gt; 输入上返回 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f265f85b070748c539b48bb2df1919c8d0132ab" translate="yes" xml:space="preserve">
          <source>Functions and operators that can be used in filter expressions are listed in &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-FILTER-EX-TABLE&quot;&gt;Table 9.49&lt;/a&gt;. The path evaluation result to be filtered is denoted by the &lt;code&gt;@&lt;/code&gt; variable. To refer to a JSON element stored at a lower nesting level, add one or more accessor operators after &lt;code&gt;@&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-FILTER-EX-TABLE&quot;&gt;表9.49&lt;/a&gt;列出了可在过滤器表达式中使用的函数和运算符。用 &lt;code&gt;@&lt;/code&gt; 变量表示要过滤的路径评估结果。要引用存储在较低嵌套级别的JSON元素，请在 &lt;code&gt;@&lt;/code&gt; 之后添加一个或多个访问运算符。</target>
        </trans-unit>
        <trans-unit id="898ae4ce80d1416da1e82be5528ff4ee3420d0cc" translate="yes" xml:space="preserve">
          <source>Functions are provided to support input in latitude and longitude (in degrees), to support output of latitude and longitude, to calculate the great circle distance between two points and to easily specify a bounding box usable for index searches.</source>
          <target state="translated">提供的函数支持输入经纬度(度数),支持输出经纬度,计算两点之间的大圆距离,以及轻松指定可用于索引搜索的边界框。</target>
        </trans-unit>
        <trans-unit id="bab4610ff64d803d4f4e2ad2f2b59a748f8c7899" translate="yes" xml:space="preserve">
          <source>Functions can also be used for &lt;a href=&quot;glossary#GLOSSARY-TRIGGER&quot;&gt;triggers&lt;/a&gt; to invoke.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="363d6f73b8773f17e3ee7b55c329af36a576dd3e" translate="yes" xml:space="preserve">
          <source>Functions coded in C (whether built-in or dynamically loaded) can be declared to accept or return any of these pseudo data types. It is up to the function author to ensure that the function will behave safely when a pseudo-type is used as an argument type.</source>
          <target state="translated">用C语言编码的函数(无论是内置的还是动态加载的)都可以被声明为接受或返回任何这些伪数据类型。确保函数在使用伪类型作为参数类型时能够安全地运行是函数作者的责任。</target>
        </trans-unit>
        <trans-unit id="e75c7dde792e62f93784e745daa34244d2b25079" translate="yes" xml:space="preserve">
          <source>Functions coded in C (whether built-in or dynamically loaded) can be declared to accept or return any of these pseudo-types. It is up to the function author to ensure that the function will behave safely when a pseudo-type is used as an argument type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04ca6b1f3b45b7dfbecfbb5e57babd0db8514f38" translate="yes" xml:space="preserve">
          <source>Functions coded in procedural languages can use pseudo-types only as allowed by their implementation languages. At present most procedural languages forbid use of a pseudo-type as an argument type, and allow only &lt;code&gt;void&lt;/code&gt; and &lt;code&gt;record&lt;/code&gt; as a result type (plus &lt;code&gt;trigger&lt;/code&gt; or &lt;code&gt;event_trigger&lt;/code&gt; when the function is used as a trigger or event trigger). Some also support polymorphic functions using the polymorphic pseudo-types, which are shown above and discussed in detail in &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="357d435e84354e072901789e999d5e8184ddfdf6" translate="yes" xml:space="preserve">
          <source>Functions coded in procedural languages can use pseudo-types only as allowed by their implementation languages. At present most procedural languages forbid use of a pseudo-type as an argument type, and allow only &lt;code&gt;void&lt;/code&gt; and &lt;code&gt;record&lt;/code&gt; as a result type (plus &lt;code&gt;trigger&lt;/code&gt; or &lt;code&gt;event_trigger&lt;/code&gt; when the function is used as a trigger or event trigger). Some also support polymorphic functions using the types &lt;code&gt;anyelement&lt;/code&gt;, &lt;code&gt;anyarray&lt;/code&gt;, &lt;code&gt;anynonarray&lt;/code&gt;, &lt;code&gt;anyenum&lt;/code&gt;, and &lt;code&gt;anyrange&lt;/code&gt;.</source>
          <target state="translated">以过程语言编码的函数只能在其实现语言允许的情况下使用伪类型。当前，大多数程序语言都禁止将伪类型用作参数类型，并且仅允许将 &lt;code&gt;void&lt;/code&gt; 和 &lt;code&gt;record&lt;/code&gt; 作为结果类型（当将函数用作触发器或事件触发器时，则添加 &lt;code&gt;trigger&lt;/code&gt; 或 &lt;code&gt;event_trigger&lt;/code&gt; ）。有些还使用类型 &lt;code&gt;anyelement&lt;/code&gt; ， &lt;code&gt;anyarray&lt;/code&gt; ， &lt;code&gt;anynonarray&lt;/code&gt; ， &lt;code&gt;anyenum&lt;/code&gt; 和 &lt;code&gt;anyrange&lt;/code&gt; 支持多态函数。</target>
        </trans-unit>
        <trans-unit id="99ae93c6cb1d152d9259b18ff6ab4fe6a95f0f1e" translate="yes" xml:space="preserve">
          <source>Functions for converting strings between different character sets (encodings), and for representing arbitrary binary data in textual form, are shown in &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-CONVERSIONS&quot;&gt;Table 9.13&lt;/a&gt;. For these functions, an argument or result of type &lt;code&gt;text&lt;/code&gt; is expressed in the database's default encoding, while arguments or results of type &lt;code&gt;bytea&lt;/code&gt; are in an encoding named by another argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a3e904c1371583b52ebdd3a3d3f52a9437f4a8d" translate="yes" xml:space="preserve">
          <source>Functions run inside the backend server process with the operating system permissions of the database server daemon. If the programming language used for the function allows unchecked memory accesses, it is possible to change the server's internal data structures. Hence, among many other things, such functions can circumvent any system access controls. Function languages that allow such access are considered &amp;ldquo;untrusted&amp;rdquo;, and PostgreSQL allows only superusers to create functions written in those languages.</source>
          <target state="translated">在数据库服务器守护程序的操作系统许可下，功能在后端服务器进程内部运行。如果用于该功能的编程语言允许未经检查的内存访问，则可以更改服务器的内部数据结构。因此，除其他外，此类功能可以规避任何系统访问控制。允许这种访问的函数语言被认为是&amp;ldquo;不受信任的&amp;rdquo;，而PostgreSQL仅允许超级用户创建以那些语言编写的函数。</target>
        </trans-unit>
        <trans-unit id="425b58ada88d6e2c4cd54b7ad94f94b6cfbbbdae" translate="yes" xml:space="preserve">
          <source>Functions should be labeled parallel unsafe if they modify any database state, or if they make changes to the transaction such as using sub-transactions, or if they access sequences or attempt to make persistent changes to settings (e.g. &lt;code&gt;setval&lt;/code&gt;). They should be labeled as parallel restricted if they access temporary tables, client connection state, cursors, prepared statements, or miscellaneous backend-local state which the system cannot synchronize in parallel mode (e.g. &lt;code&gt;setseed&lt;/code&gt; cannot be executed other than by the group leader because a change made by another process would not be reflected in the leader). In general, if a function is labeled as being safe when it is restricted or unsafe, or if it is labeled as being restricted when it is in fact unsafe, it may throw errors or produce wrong answers when used in a parallel query. C-language functions could in theory exhibit totally undefined behavior if mislabeled, since there is no way for the system to protect itself against arbitrary C code, but in most likely cases the result will be no worse than for any other function. If in doubt, functions should be labeled as &lt;code&gt;UNSAFE&lt;/code&gt;, which is the default.</source>
          <target state="translated">如果函数修改了任何数据库状态，或者对事务进行了更改（例如使用子事务），或者访问了序列或试图对设置进行永久更改（例如 &lt;code&gt;setval&lt;/code&gt; ），则应将它们标记为并行不安全。它们应该被标记为平行如果他们访问的临时表的限制，客户端的连接状态，光标，准备语句，或杂于后端的本地状态，其系统不能在并行模式同步（例如 &lt;code&gt;setseed&lt;/code&gt; 不能由组长执行，因为其他过程所做的更改不会反映在组长中。通常，如果某个函数在受限或不安全时被标记为安全，或者在实际上不安全时被标记为受限，则在并行查询中使用该函数可能会引发错误或产生错误的答案。如果没有正确标注，C语言函数在理论上可能表现出完全未定义的行为，因为系统无法保护自己免受任意C代码的侵害，但是在大多数情况下，其结果不会比其他函数差。如有疑问，应将功能标记为 &lt;code&gt;UNSAFE&lt;/code&gt; ，这是默认值。</target>
        </trans-unit>
        <trans-unit id="ca99020631ecbd508e87c7482047eede97742a02" translate="yes" xml:space="preserve">
          <source>Functions should be labeled parallel unsafe if they modify any database state, or if they make changes to the transaction such as using sub-transactions, or if they access sequences or attempt to make persistent changes to settings (e.g., &lt;code&gt;setval&lt;/code&gt;). They should be labeled as parallel restricted if they access temporary tables, client connection state, cursors, prepared statements, or miscellaneous backend-local state which the system cannot synchronize in parallel mode (e.g., &lt;code&gt;setseed&lt;/code&gt; cannot be executed other than by the group leader because a change made by another process would not be reflected in the leader). In general, if a function is labeled as being safe when it is restricted or unsafe, or if it is labeled as being restricted when it is in fact unsafe, it may throw errors or produce wrong answers when used in a parallel query. C-language functions could in theory exhibit totally undefined behavior if mislabeled, since there is no way for the system to protect itself against arbitrary C code, but in most likely cases the result will be no worse than for any other function. If in doubt, functions should be labeled as &lt;code&gt;UNSAFE&lt;/code&gt;, which is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b84230860ab5761ae6c39a0cf038afa0e0d25690" translate="yes" xml:space="preserve">
          <source>Functions that display information about &lt;code&gt;PD_ALL_VISIBLE&lt;/code&gt; bits are much more costly than those that only consult the visibility map, because they must read the relation's data blocks rather than only the (much smaller) visibility map. Functions that check the relation's data blocks are similarly expensive.</source>
          <target state="translated">显示有关 &lt;code&gt;PD_ALL_VISIBLE&lt;/code&gt; 位的信息的功能比仅查询可见性图的功能要昂贵得多，因为它们必须读取关系的数据块，而不仅是（更小）可见性图。检查关系数据块的功能同样昂贵。</target>
        </trans-unit>
        <trans-unit id="bdbee713b789a01d106896990329fe65f45aec42" translate="yes" xml:space="preserve">
          <source>Functions that have default values for parameters are considered to match any call that omits zero or more of the defaultable parameter positions. If more than one such function matches a call, the one appearing earliest in the search path is used. If there are two or more such functions in the same schema with identical parameter types in the non-defaulted positions (which is possible if they have different sets of defaultable parameters), the system will not be able to determine which to prefer, and so an &amp;ldquo;ambiguous function call&amp;rdquo; error will result if no better match to the call can be found.</source>
          <target state="translated">具有参数默认值的函数被认为与忽略零个或多个默认参数位置的任何调用匹配。如果一个以上的函数与一个呼叫相匹配，则使用最早出现在搜索路径中的一个。如果在同一模式中有两个或多个这样的函数，并且它们的参数类型在非默认位置（如果它们具有不同的默认参数集，则可能是相同的），那么系统将无法确定首选哪个，等等。如果找不到与该调用的更好匹配，则会导致&amp;ldquo;歧义函数调用&amp;rdquo;错误。</target>
        </trans-unit>
        <trans-unit id="968a1bb51fb8e88d31fbc6fa43c7108e8557e4b7" translate="yes" xml:space="preserve">
          <source>Functions that have different argument type lists will not be considered to conflict at creation time, but if defaults are provided they might conflict in use. For example, consider</source>
          <target state="translated">具有不同参数类型列表的函数在创建时不会被认为是冲突的,但如果提供了默认值,它们在使用时可能会冲突。例如,考虑</target>
        </trans-unit>
        <trans-unit id="135becd421fd7ec3a1d11031f3897f120bbd244e" translate="yes" xml:space="preserve">
          <source>Functions, triggers and row-level security policies allow users to insert code into the backend server that other users might execute unintentionally. Hence, these mechanisms permit users to &amp;ldquo;Trojan horse&amp;rdquo; others with relative ease. The strongest protection is tight control over who can define objects. Where that is infeasible, write queries referring only to objects having trusted owners. Remove from &lt;code&gt;search_path&lt;/code&gt; the public schema and any other schemas that permit untrusted users to create objects.</source>
          <target state="translated">功能，触发器和行级安全策略允许用户将代码插入其他用户可能无意执行的后端服务器。因此，这些机制允许用户相对轻松地&amp;ldquo;盗用木马&amp;rdquo;。最强的保护是严格控制谁可以定义对象。在不可行的地方，编写查询仅引用具有受信任所有者的对象。从 &lt;code&gt;search_path&lt;/code&gt; 中删除公共模式以及允许不受信任的用户创建对象的任何其他模式。</target>
        </trans-unit>
        <trans-unit id="5108d609f3fb07622f5f3d1be40ac26ef2e0a0a8" translate="yes" xml:space="preserve">
          <source>Functions: Aggregate</source>
          <target state="translated">功能。汇总</target>
        </trans-unit>
        <trans-unit id="64682352d164f9b71b9cd241b5b867b131e9918f" translate="yes" xml:space="preserve">
          <source>Functions: Array</source>
          <target state="translated">功能。阵列</target>
        </trans-unit>
        <trans-unit id="a17a5cd5398272b5c3db6c42f415d4231dc9dd50" translate="yes" xml:space="preserve">
          <source>Functions: Binary String</source>
          <target state="translated">函数。二进制字符串</target>
        </trans-unit>
        <trans-unit id="46e7b932a583771eba0b904ed9f4220de160a130" translate="yes" xml:space="preserve">
          <source>Functions: Bit String</source>
          <target state="translated">功能。字符串</target>
        </trans-unit>
        <trans-unit id="106e142aa5e330cde3a84b7b845817b28d2e9175" translate="yes" xml:space="preserve">
          <source>Functions: Data Type Formatting</source>
          <target state="translated">功能。数据类型格式化</target>
        </trans-unit>
        <trans-unit id="bfefb2129f2304220f19e00946bdffaabf6dc0e1" translate="yes" xml:space="preserve">
          <source>Functions: Date/Time</source>
          <target state="translated">功能。日期/时间</target>
        </trans-unit>
        <trans-unit id="9b63eb1b87b1e024896cd43589c27f090399d066" translate="yes" xml:space="preserve">
          <source>Functions: Geometric</source>
          <target state="translated">功能。几何</target>
        </trans-unit>
        <trans-unit id="4d3dafd3b51e63a124d63c626067bce30229ab1f" translate="yes" xml:space="preserve">
          <source>Functions: JSON</source>
          <target state="translated">功能。JSON</target>
        </trans-unit>
        <trans-unit id="9b518a3dc41009e3acee3808ac0e704f6b08a5f3" translate="yes" xml:space="preserve">
          <source>Functions: Mathematical</source>
          <target state="translated">函数。数学</target>
        </trans-unit>
        <trans-unit id="a9c0c6a0475c27e5bdfe98492ed642ea26c29174" translate="yes" xml:space="preserve">
          <source>Functions: Network Address</source>
          <target state="translated">功能。网络地址</target>
        </trans-unit>
        <trans-unit id="a4976494155f4e6dade31fdc069e51f1a7d1ce69" translate="yes" xml:space="preserve">
          <source>Functions: Range</source>
          <target state="translated">功能。范围</target>
        </trans-unit>
        <trans-unit id="b8fcb9bba13dc3a8cc6d595a39daf47631d430a4" translate="yes" xml:space="preserve">
          <source>Functions: Statistics Information</source>
          <target state="translated">功能。统计信息</target>
        </trans-unit>
        <trans-unit id="d1ee22b179879e9f873763bb172d33f3017f840e" translate="yes" xml:space="preserve">
          <source>Functions: String</source>
          <target state="translated">功能。字符串</target>
        </trans-unit>
        <trans-unit id="6843fcead53a6cf24daa8566fecd89162ab37e7f" translate="yes" xml:space="preserve">
          <source>Functions: System Administration</source>
          <target state="translated">职能。系统管理</target>
        </trans-unit>
        <trans-unit id="a388797fbe7fca428c186d9bd0e36003dc121806" translate="yes" xml:space="preserve">
          <source>Functions: System Information</source>
          <target state="translated">功能。系统信息</target>
        </trans-unit>
        <trans-unit id="6774bc067b00b4a898fa2d81854d9f8ccd1bb6e9" translate="yes" xml:space="preserve">
          <source>Functions: Text Search</source>
          <target state="translated">功能。文本搜索</target>
        </trans-unit>
        <trans-unit id="ce981f4dc8ac16f802c8f14bef565b7c26ef8014" translate="yes" xml:space="preserve">
          <source>Functions: UUID</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1acb35ad39f3bcd2faf73955c2408efc740b8965" translate="yes" xml:space="preserve">
          <source>Functions: Window</source>
          <target state="translated">功能。窗口</target>
        </trans-unit>
        <trans-unit id="4ea9b0534343b6662064e8e66df29f936486dcbe" translate="yes" xml:space="preserve">
          <source>Functions: XML</source>
          <target state="translated">功能。XML</target>
        </trans-unit>
        <trans-unit id="be1881053687afed29c0ae862b5bb84c66f949f7" translate="yes" xml:space="preserve">
          <source>Further along the line of common sense, the fuzziness of the limits suggests that the use of traditional numeric data types leads to a certain loss of information. Consider this: your instrument reads 6.50, and you input this reading into the database. What do you get when you fetch it? Watch:</source>
          <target state="translated">沿着常识的方向进一步,极限的模糊性表明,使用传统的数字数据类型会导致一定的信息损失。考虑一下:你的仪器读数是6.50,你把这个读数输入到数据库中。当你取到它时,你会得到什么?请看。</target>
        </trans-unit>
        <trans-unit id="e2310579f06e5c7b30a8aa96bc1d602f5e9203e6" translate="yes" xml:space="preserve">
          <source>Further assumptions are that the aggregate ignores null inputs, and that it delivers a null result if and only if there were no non-null inputs. Ordinarily, a data type's &lt;code&gt;&amp;lt;&lt;/code&gt; operator is the proper sort operator for &lt;code&gt;MIN&lt;/code&gt;, and &lt;code&gt;&amp;gt;&lt;/code&gt; is the proper sort operator for &lt;code&gt;MAX&lt;/code&gt;. Note that the optimization will never actually take effect unless the specified operator is the &amp;ldquo;less than&amp;rdquo; or &amp;ldquo;greater than&amp;rdquo; strategy member of a B-tree index operator class.</source>
          <target state="translated">进一步的假设是，聚合将忽略空输入，并且当且仅当不存在非空输入时，它才会提供空结果。通常，数据类型的 &lt;code&gt;&amp;lt;&lt;/code&gt; 运算符是 &lt;code&gt;MIN&lt;/code&gt; 的适当排序运算符， &lt;code&gt;&amp;gt;&lt;/code&gt; 是 &lt;code&gt;MAX&lt;/code&gt; 的适当的排序运算符。请注意，除非指定的运算符是B树索引运算符类的&amp;ldquo;小于&amp;rdquo;或&amp;ldquo;大于&amp;rdquo;策略成员，否则优化实际上不会生效。</target>
        </trans-unit>
        <trans-unit id="8e3fde8eb12ee9830b9efa317f6db1a2760019c3" translate="yes" xml:space="preserve">
          <source>Further details about the planner's use of statistics can be found in &lt;a href=&quot;https://www.postgresql.org/docs/12/planner-stats-details.html&quot;&gt;Chapter 70&lt;/a&gt;.</source>
          <target state="translated">有关计划者使用统计信息的更多详细信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/planner-stats-details.html&quot;&gt;第70章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="65f251a5bf245d188901a7cc3757ef7e35aa3e2d" translate="yes" xml:space="preserve">
          <source>Further details about the planner's use of statistics can be found in &lt;a href=&quot;https://www.postgresql.org/docs/13/planner-stats-details.html&quot;&gt;Chapter 70&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80923ff08a3698b44c0358905326ad4315d1f3f8" translate="yes" xml:space="preserve">
          <source>Furthermore, although multiple sessions are guaranteed to allocate distinct sequence values, the values might be generated out of sequence when all the sessions are considered. For example, with a &lt;code&gt;cache&lt;/code&gt; setting of 10, session A might reserve values 1..10 and return &lt;code&gt;nextval&lt;/code&gt;=1, then session B might reserve values 11..20 and return &lt;code&gt;nextval&lt;/code&gt;=11 before session A has generated &lt;code&gt;nextval&lt;/code&gt;=2. Thus, with a &lt;code&gt;cache&lt;/code&gt; setting of one it is safe to assume that &lt;code&gt;nextval&lt;/code&gt; values are generated sequentially; with a &lt;code&gt;cache&lt;/code&gt; setting greater than one you should only assume that the &lt;code&gt;nextval&lt;/code&gt; values are all distinct, not that they are generated purely sequentially. Also, &lt;code&gt;last_value&lt;/code&gt; will reflect the latest value reserved by any session, whether or not it has yet been returned by &lt;code&gt;nextval&lt;/code&gt;.</source>
          <target state="translated">此外，尽管保证多个会话分配不同的序列值，但是当考虑所有会话时，这些值可能会不按顺序生成。例如，在 &lt;code&gt;cache&lt;/code&gt; 设置为10的情况下，会话A可能会保留值1..10并返回 &lt;code&gt;nextval&lt;/code&gt; = 1，然后会话B可能会保留值11..20并在会话A生成 &lt;code&gt;nextval&lt;/code&gt; = 2 之前返回 &lt;code&gt;nextval&lt;/code&gt; = 11 。因此，在 &lt;code&gt;cache&lt;/code&gt; 设置为1的情况下，可以安全地假设 &lt;code&gt;nextval&lt;/code&gt; 值是顺序生成的；与 &lt;code&gt;cache&lt;/code&gt; 设置大于一，你应该只假设 &lt;code&gt;nextval&lt;/code&gt; 值都是不同的，而不是纯粹按顺序生成。同样， &lt;code&gt;last_value&lt;/code&gt; 将反映任何会话保留的最新值，无论 &lt;code&gt;nextval&lt;/code&gt; 是否返回了该值。</target>
        </trans-unit>
        <trans-unit id="224c260c1b97921918028686f800ec2a753d6d99" translate="yes" xml:space="preserve">
          <source>Furthermore, if the result of an expression can be determined by evaluating only some parts of it, then other subexpressions might not be evaluated at all. For instance, if one wrote:</source>
          <target state="translated">此外,如果一个表达式的结果只能通过评估它的某些部分来确定,那么其他的子表达式可能根本不会被评估。例如,如果写道:</target>
        </trans-unit>
        <trans-unit id="c76baa18e3a105ad25a2e47745a365c732d219e6" translate="yes" xml:space="preserve">
          <source>Furthermore, immediately before reporting a uniqueness violation according to the above rules, the access method must recheck the liveness of the row being inserted. If it is committed dead then no violation should be reported. (This case cannot occur during the ordinary scenario of inserting a row that's just been created by the current transaction. It can happen during &lt;code&gt;CREATE UNIQUE INDEX CONCURRENTLY&lt;/code&gt;, however.)</source>
          <target state="translated">此外，在根据上述规则报告唯一性违规之前，访问方法必须重新检查要插入的行的活动性。如果它被判死刑，则不应报告任何违规行为。（这种情况在插入由当前事务刚创建的行的普通情况下不会发生。但是，在 &lt;code&gt;CREATE UNIQUE INDEX CONCURRENTLY&lt;/code&gt; 期间可能会发生。）</target>
        </trans-unit>
        <trans-unit id="b247028066a34eb255cbd5a7c12a62f7ec515ba5" translate="yes" xml:space="preserve">
          <source>Furthermore, indexes for exclusion constraints cannot be reindexed concurrently. If such an index is named directly in this command, an error is raised. If a table or database with exclusion constraint indexes is reindexed concurrently, those indexes will be skipped. (It is possible to reindex such indexes without the &lt;code&gt;CONCURRENTLY&lt;/code&gt; option.)</source>
          <target state="translated">此外，排除约束的索引不能同时重新索引。如果在此命令中直接命名了这样的索引，则会引发错误。如果同时对具有排除约束索引的表或数据库重新建立索引，则将跳过这些索引。（可以在没有 &lt;code&gt;CONCURRENTLY&lt;/code&gt; 选项的情况下重新索引此类索引。）</target>
        </trans-unit>
        <trans-unit id="ca37f367ca14421a51e0f4caacbc290fabee5387" translate="yes" xml:space="preserve">
          <source>Furthermore, the ordering is total; that is, for all non-null values &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;:</source>
          <target state="translated">此外，订购是总计；也就是说，对于所有非空值 &lt;code&gt;A&lt;/code&gt; ， &lt;code&gt;B&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="403e23f7e975f56f502368918f62f79a68fb24a2" translate="yes" xml:space="preserve">
          <source>Furthermore, the output of &lt;code&gt;JOIN USING&lt;/code&gt; suppresses redundant columns: there is no need to print both of the matched columns, since they must have equal values. While &lt;code&gt;JOIN ON&lt;/code&gt; produces all columns from &lt;code&gt;T1&lt;/code&gt; followed by all columns from &lt;code&gt;T2&lt;/code&gt;, &lt;code&gt;JOIN USING&lt;/code&gt; produces one output column for each of the listed column pairs (in the listed order), followed by any remaining columns from &lt;code&gt;T1&lt;/code&gt;, followed by any remaining columns from &lt;code&gt;T2&lt;/code&gt;.</source>
          <target state="translated">此外， &lt;code&gt;JOIN USING&lt;/code&gt; 的输出抑制了多余的列：无需打印两个匹配的列，因为它们必须具有相等的值。虽然 &lt;code&gt;JOIN ON&lt;/code&gt; 产生从所有列 &lt;code&gt;T1&lt;/code&gt; ，接着从所有列 &lt;code&gt;T2&lt;/code&gt; ， &lt;code&gt;JOIN USING&lt;/code&gt; 每个列出列对产生一个输出列（在列出的顺序），然后通过从任何剩余的列 &lt;code&gt;T1&lt;/code&gt; ，接着从任何剩余的列 &lt;code&gt;T2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2e40a8533f467834ab1d55c9055f3d84061da31d" translate="yes" xml:space="preserve">
          <source>GEQO</source>
          <target state="translated">GEQO</target>
        </trans-unit>
        <trans-unit id="7c02cecaa08dd20b2878a0e9246d9afddbd1bfa9" translate="yes" xml:space="preserve">
          <source>GIN</source>
          <target state="translated">GIN</target>
        </trans-unit>
        <trans-unit id="ecc6a1db2685ccbd525e456602d8a531d64c012d" translate="yes" xml:space="preserve">
          <source>GIN Indexes: Built-in Operator Classes</source>
          <target state="translated">GIN索引。内置操作类</target>
        </trans-unit>
        <trans-unit id="df2283621762cf6fbe34492dd970bdc1a2fb8f2e" translate="yes" xml:space="preserve">
          <source>GIN Indexes: Examples</source>
          <target state="translated">GIN指数。例子</target>
        </trans-unit>
        <trans-unit id="bcdb1f5984e5f5fc37ee2625a5e106b5ace38b47" translate="yes" xml:space="preserve">
          <source>GIN Indexes: Extensibility</source>
          <target state="translated">GIN索引。可扩展性</target>
        </trans-unit>
        <trans-unit id="1f6ebc2a0d191b466ed9b8d366b380c7d0d18de4" translate="yes" xml:space="preserve">
          <source>GIN Indexes: GIN Tips and Tricks</source>
          <target state="translated">GIN索引。GIN提示和技巧</target>
        </trans-unit>
        <trans-unit id="79cd3f5e4f5e10454468404b67550cb2d0ff11bb" translate="yes" xml:space="preserve">
          <source>GIN Indexes: Implementation</source>
          <target state="translated">GIN指数。执行情况</target>
        </trans-unit>
        <trans-unit id="bac90b5d133adfb4770f3d94ae6faf770a933f01" translate="yes" xml:space="preserve">
          <source>GIN Indexes: Limitations</source>
          <target state="translated">GIN指数。局限性</target>
        </trans-unit>
        <trans-unit id="ece4291bbc12d9bc7ed3dfad4dd491c4406b75fd" translate="yes" xml:space="preserve">
          <source>GIN and GiST Index Types</source>
          <target state="translated">GIN和GiST指数类型</target>
        </trans-unit>
        <trans-unit id="838975c5a4d167bd2f6ce5e8ea900f60f03b2972" translate="yes" xml:space="preserve">
          <source>GIN assumes that indexable operators are strict. This means that &lt;code&gt;extractValue&lt;/code&gt; will not be called at all on a null item value (instead, a placeholder index entry is created automatically), and &lt;code&gt;extractQuery&lt;/code&gt; will not be called on a null query value either (instead, the query is presumed to be unsatisfiable). Note however that null key values contained within a non-null composite item or query value are supported.</source>
          <target state="translated">GIN假定可索引运算符是严格的。这意味着将根本不对空项目值调用 &lt;code&gt;extractValue&lt;/code&gt; （相反，将自动创建占位符索引条目），并且也将不对空查询值调用 &lt;code&gt;extractQuery&lt;/code&gt; （相反，假定查询无法满足要求） 。但是请注意，支持包含在非null组合项或查询值中的null键值。</target>
        </trans-unit>
        <trans-unit id="fe2b1de04947c2b348e8de70b6c2f63da721161b" translate="yes" xml:space="preserve">
          <source>GIN can support &amp;ldquo;partial match&amp;rdquo; queries, in which the query does not determine an exact match for one or more keys, but the possible matches fall within a reasonably narrow range of key values (within the key sorting order determined by the &lt;code&gt;compare&lt;/code&gt; support method). The &lt;code&gt;extractQuery&lt;/code&gt; method, instead of returning a key value to be matched exactly, returns a key value that is the lower bound of the range to be searched, and sets the &lt;code&gt;pmatch&lt;/code&gt; flag true. The key range is then scanned using the &lt;code&gt;comparePartial&lt;/code&gt; method. &lt;code&gt;comparePartial&lt;/code&gt; must return zero for a matching index key, less than zero for a non-match that is still within the range to be searched, or greater than zero if the index key is past the range that could match.</source>
          <target state="translated">GIN可以支持&amp;ldquo;部分匹配&amp;rdquo;查询，在该查询中，查询不能确定一个或多个键的精确匹配，但是可能的匹配落在键值的合理范围内（在 &lt;code&gt;compare&lt;/code&gt; 支持方法确定的键排序顺序之内））。该 &lt;code&gt;extractQuery&lt;/code&gt; 方法的，而不是返回的密钥值被精确地匹配时，返回一个密钥值，该值是下界要搜索的范围的，并且将 &lt;code&gt;pmatch&lt;/code&gt; 标志真。然后使用 &lt;code&gt;comparePartial&lt;/code&gt; 方法扫描键范围。 &lt;code&gt;comparePartial&lt;/code&gt; 对于匹配的索引键，必须返回零；对于仍在要搜索的范围内的不匹配项，必须返回零；如果索引键超出了可以匹配的范围，则必须返回零。</target>
        </trans-unit>
        <trans-unit id="614db4420feca405f38d8b066253c12c8348900b" translate="yes" xml:space="preserve">
          <source>GIN index extracts statements of following form out of &lt;code&gt;jsonpath&lt;/code&gt;: &lt;code&gt;accessors_chain&lt;/code&gt; = &lt;code&gt;const&lt;/code&gt;. Accessors chain may consist of &lt;code&gt;.key&lt;/code&gt;, &lt;code&gt;[*]&lt;/code&gt;, and &lt;code&gt;[index]&lt;/code&gt; accessors. &lt;code&gt;jsonb_ops&lt;/code&gt; additionally supports &lt;code&gt;.*&lt;/code&gt; and &lt;code&gt;.**&lt;/code&gt; accessors.</source>
          <target state="translated">GIN索引从 &lt;code&gt;jsonpath&lt;/code&gt; 中提取以下形式的语句： &lt;code&gt;accessors_chain&lt;/code&gt; = &lt;code&gt;const&lt;/code&gt; 。访问器链可能由 &lt;code&gt;.key&lt;/code&gt; ， &lt;code&gt;[*]&lt;/code&gt; 和 &lt;code&gt;[index]&lt;/code&gt; 访问器组成。 &lt;code&gt;jsonb_ops&lt;/code&gt; 还支持 &lt;code&gt;.*&lt;/code&gt; 和 &lt;code&gt;.**&lt;/code&gt; 访问器。</target>
        </trans-unit>
        <trans-unit id="45189d146afca1631f2530069592ce2a3f6f8758" translate="yes" xml:space="preserve">
          <source>GIN indexes</source>
          <target state="translated">GIN指数</target>
        </trans-unit>
        <trans-unit id="b1817ec41a2b97676aa792c5a571f79e3047197e" translate="yes" xml:space="preserve">
          <source>GIN indexes accept different parameters:</source>
          <target state="translated">GIN索引接受不同的参数。</target>
        </trans-unit>
        <trans-unit id="9ae2afa12a8014fb0afa678aad4a0a6fdff0194f" translate="yes" xml:space="preserve">
          <source>GIN indexes are &amp;ldquo;inverted indexes&amp;rdquo; which are appropriate for data values that contain multiple component values, such as arrays. An inverted index contains a separate entry for each component value, and can efficiently handle queries that test for the presence of specific component values.</source>
          <target state="translated">GIN索引是&amp;ldquo;反向索引&amp;rdquo;，适用于包含多个组件值（例如数组）的数据值。倒排索引为每个组件值包含一个单独的条目，并且可以有效地处理查询，以测试特定组件值的存在。</target>
        </trans-unit>
        <trans-unit id="6e3602f0fe2770a2e803379f390135df1f58a159" translate="yes" xml:space="preserve">
          <source>GIN indexes are the preferred text search index type. As inverted indexes, they contain an index entry for each word (lexeme), with a compressed list of matching locations. Multi-word searches can find the first match, then use the index to remove rows that are lacking additional words. GIN indexes store only the words (lexemes) of &lt;code&gt;tsvector&lt;/code&gt; values, and not their weight labels. Thus a table row recheck is needed when using a query that involves weights.</source>
          <target state="translated">GIN索引是首选的文本搜索索引类型。作为反向索引，它们包含每个单词（词素）的索引条目，以及匹配位置的压缩列表。多字搜索可以找到第一个匹配项，然后使用索引删除缺少其他字的行。GIN索引仅存储 &lt;code&gt;tsvector&lt;/code&gt; 值的单词（词法），而不存储其权重标签。因此，当使用涉及权重的查询时，需要对表行进行重新检查。</target>
        </trans-unit>
        <trans-unit id="662e0bcd43903a7d3e17f00c272dcd79f02aa415" translate="yes" xml:space="preserve">
          <source>GIN indexes can be used to efficiently search for keys or key/value pairs occurring within a large number of &lt;code&gt;jsonb&lt;/code&gt; documents (datums). Two GIN &amp;ldquo;operator classes&amp;rdquo; are provided, offering different performance and flexibility trade-offs.</source>
          <target state="translated">GIN索引可用于有效搜索大量 &lt;code&gt;jsonb&lt;/code&gt; 文档（基准）中出现的键或键/值对。提供了两种GIN&amp;ldquo;操作员类别&amp;rdquo;，提供了不同的性能和灵活性权衡。</target>
        </trans-unit>
        <trans-unit id="680a142f22f16149f0a10d5733b44a15bfc9f906" translate="yes" xml:space="preserve">
          <source>GIN is generalized in the sense that the GIN access method code does not need to know the specific operations that it accelerates. Instead, it uses custom strategies defined for particular data types. The strategy defines how keys are extracted from indexed items and query conditions, and how to determine whether a row that contains some of the key values in a query actually satisfies the query.</source>
          <target state="translated">GIN是通用的,因为GIN访问方法代码不需要知道它加速的具体操作。相反,它使用为特定数据类型定义的自定义策略。该策略定义了如何从索引项和查询条件中提取键,以及如何确定包含查询中某些键值的行是否真正满足查询。</target>
        </trans-unit>
        <trans-unit id="2d1d5b806ff667bfec2719e4c38322233f7a1f8b" translate="yes" xml:space="preserve">
          <source>GIN stands for Generalized Inverted Index. GIN is designed for handling cases where the items to be indexed are composite values, and the queries to be handled by the index need to search for element values that appear within the composite items. For example, the items could be documents, and the queries could be searches for documents containing specific words.</source>
          <target state="translated">GIN是Generalized Inverted Index的缩写。GIN是为处理这样的情况而设计的,即待索引的项目是复合值,而索引要处理的查询需要搜索复合项目中出现的元素值。例如,项目可以是文档,而查询可以是搜索包含特定单词的文档。</target>
        </trans-unit>
        <trans-unit id="823f6d975b918a4f4904609a69bccd4f6db0e016" translate="yes" xml:space="preserve">
          <source>GIN version number</source>
          <target state="translated">GIN版本号</target>
        </trans-unit>
        <trans-unit id="d84234ce9f95c2df9a9cb91648dc0629d7b55a78" translate="yes" xml:space="preserve">
          <source>GMT</source>
          <target state="translated">GMT</target>
        </trans-unit>
        <trans-unit id="46e5d5c005d767dc686d5fdb5278440482f67660" translate="yes" xml:space="preserve">
          <source>GRANT</source>
          <target state="translated">GRANT</target>
        </trans-unit>
        <trans-unit id="f96c309d7771b4500d22efff00cb264218c6cf3a" translate="yes" xml:space="preserve">
          <source>GRANT &amp;mdash; define access privileges</source>
          <target state="translated">GRANT-定义访问权限</target>
        </trans-unit>
        <trans-unit id="50381ef340ee08d7a029c8e513ea2dc8126c9d21" translate="yes" xml:space="preserve">
          <source>GRANT on Database Objects</source>
          <target state="translated">数据库对象上的GRANT</target>
        </trans-unit>
        <trans-unit id="040876dd6cec9809d1a84a48115c6451d11d511c" translate="yes" xml:space="preserve">
          <source>GRANT on Roles</source>
          <target state="translated">角色授权书</target>
        </trans-unit>
        <trans-unit id="18b63165da1ffe19e191b11267fd831d16b20629" translate="yes" xml:space="preserve">
          <source>GSSAPI</source>
          <target state="translated">GSSAPI</target>
        </trans-unit>
        <trans-unit id="6b3f2424f13149fada5347cf28d874ce4ce85971" translate="yes" xml:space="preserve">
          <source>GSSAPI Authentication</source>
          <target state="translated">GSSAPI认证</target>
        </trans-unit>
        <trans-unit id="3d0265dcf1697d6c2f5c259d07fa634b6fbdea24" translate="yes" xml:space="preserve">
          <source>GSSAPI is an industry-standard protocol for secure authentication defined in RFC 2743. PostgreSQL supports GSSAPI for use as either an encrypted, authenticated layer, or for authentication only. GSSAPI provides automatic authentication (single sign-on) for systems that support it. The authentication itself is secure. If GSSAPI encryption (see &lt;code&gt;hostgssenc&lt;/code&gt;) or SSL encryption are used, the data sent along the database connection will be encrypted; otherwise, it will not.</source>
          <target state="translated">GSSAPI是RFC 2743中定义的用于安全认证的行业标准协议。PostgreSQL支持GSSAPI用作加密的认证层，或仅用于认证。GSSAPI为支持它的系统提供自动身份验证（单点登录）。身份验证本身是安全的。如果使用GSSAPI加密（请参阅 &lt;code&gt;hostgssenc&lt;/code&gt; ）或SSL加密，则沿数据库连接发送的数据将被加密；否则，不会。</target>
        </trans-unit>
        <trans-unit id="9c340397893e38112dd6e1110b015089ffe980f8" translate="yes" xml:space="preserve">
          <source>GSSAPI support has to be enabled when PostgreSQL is built; see &lt;a href=&quot;https://www.postgresql.org/docs/12/installation.html&quot;&gt;Chapter 16&lt;/a&gt; for more information.</source>
          <target state="translated">构建PostgreSQL时必须启用GSSAPI支持。有关更多信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/installation.html&quot;&gt;第16章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="071a79ebe1f1c0887de7c400f4061aba943bc234" translate="yes" xml:space="preserve">
          <source>GSSAPI support has to be enabled when PostgreSQL is built; see &lt;a href=&quot;https://www.postgresql.org/docs/13/installation.html&quot;&gt;Chapter 16&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a65194631e53d423c8f7dc36b0337ca4d0af275f" translate="yes" xml:space="preserve">
          <source>GSSAPI-encrypted connections encrypt all data sent across the network, including queries and data returned. (No password is sent across the network.) The &lt;code&gt;pg_hba.conf&lt;/code&gt; file allows administrators to specify which hosts can use non-encrypted connections (&lt;code&gt;host&lt;/code&gt;) and which require GSSAPI-encrypted connections (&lt;code&gt;hostgssenc&lt;/code&gt;). Also, clients can specify that they connect to servers only on GSSAPI-encrypted connections (&lt;code&gt;gssencmode=require&lt;/code&gt;).</source>
          <target state="translated">GSSAPI加密的连接对通过网络发送的所有数据进行加密，包括查询和返回的数据。（没有通过网络发送密码。） &lt;code&gt;pg_hba.conf&lt;/code&gt; 文件允许管理员指定哪些主机可以使用非加密连接（ &lt;code&gt;host&lt;/code&gt; ），以及哪些主机需要GSSAPI加密的连接（ &lt;code&gt;hostgssenc&lt;/code&gt; ）。此外，客户端可以指定它们仅通过GSSAPI加密的连接（ &lt;code&gt;gssencmode=require&lt;/code&gt; ）连接到服务器。</target>
        </trans-unit>
        <trans-unit id="5f4a781a866c82c10ec06cfdb99d578fac96f0a9" translate="yes" xml:space="preserve">
          <source>GUC</source>
          <target state="translated">GUC</target>
        </trans-unit>
        <trans-unit id="55d3b12a3edecf2084b5b37090f9f7a53387e200" translate="yes" xml:space="preserve">
          <source>Gaussian-distributed random integer in &lt;code&gt;[lb, ub]&lt;/code&gt;, see below</source>
          <target state="translated">&lt;code&gt;[lb, ub]&lt;/code&gt; 高斯分布随机整数，请参见下文</target>
        </trans-unit>
        <trans-unit id="ae313cc97f019cc02b5747068e2416db0beed99a" translate="yes" xml:space="preserve">
          <source>General Purpose</source>
          <target state="translated">一般用途</target>
        </trans-unit>
        <trans-unit id="3160665d714fc6d7b194361c56057ae8d2d10ef8" translate="yes" xml:space="preserve">
          <source>Generalized Inverted Index</source>
          <target state="translated">广义反向指数</target>
        </trans-unit>
        <trans-unit id="aa5854e74a08fd00bcac0cc44c6f66a2c57b9442" translate="yes" xml:space="preserve">
          <source>Generalized Search Tree</source>
          <target state="translated">广义搜索树</target>
        </trans-unit>
        <trans-unit id="3e7c9f89ced37df1cb7e21ed93f1ae9c43e37c8c" translate="yes" xml:space="preserve">
          <source>Generally, any file system with POSIX semantics can be used for PostgreSQL. Users prefer different file systems for a variety of reasons, including vendor support, performance, and familiarity. Experience suggests that, all other things being equal, one should not expect major performance or behavior changes merely from switching file systems or making minor file system configuration changes.</source>
          <target state="translated">一般来说,任何具有POSIX语义的文件系统都可以用于PostgreSQL。用户出于各种原因喜欢不同的文件系统,包括供应商支持、性能和熟悉程度。经验表明,在所有其他条件都相同的情况下,不应该仅仅通过切换文件系统或进行小的文件系统配置更改来期待重大的性能或行为变化。</target>
        </trans-unit>
        <trans-unit id="e4dfa0a05721faeacd6c28188e09916650d7ec35" translate="yes" xml:space="preserve">
          <source>Generally, the &lt;code&gt;EXPLAIN&lt;/code&gt; output will display details for every plan node which was generated by the query planner. However, there are cases where the executor is able to determine that certain nodes are not required; currently, the only node types to support this are the &lt;code&gt;Append&lt;/code&gt; and &lt;code&gt;MergeAppend&lt;/code&gt; nodes. These node types have the ability to discard subnodes which they are able to determine won't contain any records required by the query. It is possible to determine that nodes have been removed in this way by the presence of a &quot;Subplans Removed&quot; property in the &lt;code&gt;EXPLAIN&lt;/code&gt; output.</source>
          <target state="translated">通常， &lt;code&gt;EXPLAIN&lt;/code&gt; 输出将显示查询计划程序生成的每个计划节点的详细信息。但是，在某些情况下，执行者可以确定不需要某些节点。当前，唯一支持此功能的节点类型是 &lt;code&gt;Append&lt;/code&gt; 和 &lt;code&gt;MergeAppend&lt;/code&gt; 节点。这些节点类型具有丢弃子节点的能力，它们可以确定这些子节点将不包含查询所需的任何记录。通过在 &lt;code&gt;EXPLAIN&lt;/code&gt; 输出中存在&amp;ldquo;已删除子计划&amp;rdquo;属性，可以确定已通过这种方式删除了节点。</target>
        </trans-unit>
        <trans-unit id="affe2a15ea854fded86126b770c099c64d24c777" translate="yes" xml:space="preserve">
          <source>Generally, the system will enforce filter conditions imposed using security policies prior to qualifications that appear in user queries, in order to prevent inadvertent exposure of the protected data to user-defined functions which might not be trustworthy. However, functions and operators marked by the system (or the system administrator) as &lt;code&gt;LEAKPROOF&lt;/code&gt; may be evaluated before policy expressions, as they are assumed to be trustworthy.</source>
          <target state="translated">通常，系统将在出现在用户查询中的资格之前强制执行使用安全策略强加的筛选条件，以防止将受保护的数据无意中暴露给可能不值得信赖的用户定义功能。但是，系统（或系统管理员）标记为 &lt;code&gt;LEAKPROOF&lt;/code&gt; 的功能和操作员可能会在策略表达式之前进行评估，因为它们被认为是可信赖的。</target>
        </trans-unit>
        <trans-unit id="f3eac14aa88e73035cec53cd24d7892747e63a31" translate="yes" xml:space="preserve">
          <source>Generate a series comprising the given array's subscripts.</source>
          <target state="translated">生成一个由给定数组的下标组成的系列。</target>
        </trans-unit>
        <trans-unit id="4a5175300e4854a10a7b94e474436e6a6e890471" translate="yes" xml:space="preserve">
          <source>Generate a series comprising the given array's subscripts. When &lt;em&gt;&lt;code&gt;reverse&lt;/code&gt;&lt;/em&gt; is true, the series is returned in reverse order.</source>
          <target state="translated">生成一个包含给定数组下标的系列。当&lt;em&gt; &lt;code&gt;reverse&lt;/code&gt; &lt;/em&gt;为true时，将以相反的顺序返回该系列。</target>
        </trans-unit>
        <trans-unit id="ad5fcb5a5c8eeebb88c26d2bf0bde7f9fa38281f" translate="yes" xml:space="preserve">
          <source>Generate a series of values, from &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt; to &lt;em&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/em&gt; with a step size of &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">产生一系列的值，从&lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt;到&lt;em&gt; &lt;code&gt;stop&lt;/code&gt; &lt;/em&gt;使用的步长&lt;em&gt; &lt;code&gt;step&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d5fb2cfb648fe3292c4f21944415cd71835246e3" translate="yes" xml:space="preserve">
          <source>Generate a series of values, from &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt; to &lt;em&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/em&gt; with a step size of one</source>
          <target state="translated">产生一系列的值，从&lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt;到&lt;em&gt; &lt;code&gt;stop&lt;/code&gt; &lt;/em&gt;的一个的步长</target>
        </trans-unit>
        <trans-unit id="37f727cfa62167384e5f8947ef57078f0d482808" translate="yes" xml:space="preserve">
          <source>Generate data and load it into the standard tables, replacing any data already present.</source>
          <target state="translated">生成数据并将其加载到标准表格中,替换现有的任何数据。</target>
        </trans-unit>
        <trans-unit id="9dcf1fb2a5619d507a1603ea13343b634907fbb2" translate="yes" xml:space="preserve">
          <source>Generated Columns</source>
          <target state="translated">生成的栏目</target>
        </trans-unit>
        <trans-unit id="75d723afc8209b9ad813733ed0d276b98f57a469" translate="yes" xml:space="preserve">
          <source>Generated columns are, conceptually, updated after &lt;code&gt;BEFORE&lt;/code&gt; triggers have run. Therefore, changes made to base columns in a &lt;code&gt;BEFORE&lt;/code&gt; trigger will be reflected in generated columns. But conversely, it is not allowed to access generated columns in &lt;code&gt;BEFORE&lt;/code&gt; triggers.</source>
          <target state="translated">从概念上讲，生成的列 &lt;code&gt;BEFORE&lt;/code&gt; 触发器运行之前进行更新。因此，在 &lt;code&gt;BEFORE&lt;/code&gt; 触发器中对基本列所做的更改将反映在生成的列中。但是相反，不允许 &lt;code&gt;BEFORE&lt;/code&gt; 触发器之前访问生成的列。</target>
        </trans-unit>
        <trans-unit id="942c0fc170e0c5a1f9b1ae453e356f340b1b4ebb" translate="yes" xml:space="preserve">
          <source>Generated columns maintain access privileges separately from their underlying base columns. So, it is possible to arrange it so that a particular role can read from a generated column but not from the underlying base columns.</source>
          <target state="translated">生成的列与它们的底层基础列分开维护访问权限。所以,可以安排成某一角色可以从生成的列中读取,但不能从底层基础列中读取。</target>
        </trans-unit>
        <trans-unit id="7f0ef22f71ecfc740ab931db74f147c122ec3d69" translate="yes" xml:space="preserve">
          <source>Generates a great amount of debugging output for the &lt;code&gt;LISTEN&lt;/code&gt; and &lt;code&gt;NOTIFY&lt;/code&gt; commands. &lt;a href=&quot;runtime-config-client#GUC-CLIENT-MIN-MESSAGES&quot;&gt;client_min_messages&lt;/a&gt; or &lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-MESSAGES&quot;&gt;log_min_messages&lt;/a&gt; must be &lt;code&gt;DEBUG1&lt;/code&gt; or lower to send this output to the client or server logs, respectively.</source>
          <target state="translated">为 &lt;code&gt;LISTEN&lt;/code&gt; 和 &lt;code&gt;NOTIFY&lt;/code&gt; 命令生成大量调试输出。&lt;a href=&quot;runtime-config-client#GUC-CLIENT-MIN-MESSAGES&quot;&gt;client_min_messages&lt;/a&gt;或&lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-MESSAGES&quot;&gt;log_min_messages&lt;/a&gt;必须为 &lt;code&gt;DEBUG1&lt;/code&gt; 或更低，才能将此输出分别发送到客户端或服务器日志。</target>
        </trans-unit>
        <trans-unit id="0c512aad043f38a5c410a9715731ea7ab925a02c" translate="yes" xml:space="preserve">
          <source>Generates a new random salt string for use in &lt;code&gt;crypt()&lt;/code&gt;. The salt string also tells &lt;code&gt;crypt()&lt;/code&gt; which algorithm to use.</source>
          <target state="translated">生成一个新的随机盐字符串以用于 &lt;code&gt;crypt()&lt;/code&gt; 。盐字符串还告诉 &lt;code&gt;crypt()&lt;/code&gt; 使用哪种算法。</target>
        </trans-unit>
        <trans-unit id="cbde187b61954e6ea30cd14491acf93d47d93995" translate="yes" xml:space="preserve">
          <source>Generates a series comprising the valid subscripts of the &lt;em&gt;&lt;code&gt;dim&lt;/code&gt;&lt;/em&gt;'th dimension of the given array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3315cb9c251ba92b686585eaa006d098cd316db2" translate="yes" xml:space="preserve">
          <source>Generates a series comprising the valid subscripts of the &lt;em&gt;&lt;code&gt;dim&lt;/code&gt;&lt;/em&gt;'th dimension of the given array. When &lt;em&gt;&lt;code&gt;reverse&lt;/code&gt;&lt;/em&gt; is true, returns the series in reverse order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b9efd71e8210e50c6cf31398196b39400f42912" translate="yes" xml:space="preserve">
          <source>Generates a series of values from &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt; to &lt;em&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/em&gt;, with a step size of &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fe64f6ae7efb31df1c280c81e9337ab336a691f" translate="yes" xml:space="preserve">
          <source>Generates a series of values from &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt; to &lt;em&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/em&gt;, with a step size of &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt;. &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt; defaults to 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="447f18f7fd582d437e245ed58834f9f6f0d3572f" translate="yes" xml:space="preserve">
          <source>Generates a version 1 UUID, but uses a random multicast MAC address instead of the real MAC address of the computer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61eee4f4b5d39293f14efcf028cd9d79aa5d58ef" translate="yes" xml:space="preserve">
          <source>Generates a version 1 UUID. This involves the MAC address of the computer and a time stamp. Note that UUIDs of this kind reveal the identity of the computer that created the identifier and the time at which it did so, which might make it unsuitable for certain security-sensitive applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72a73fa7358c1c8df9b5e2fd5fbe3bbadb09cc37" translate="yes" xml:space="preserve">
          <source>Generates a version 3 UUID in the given namespace using the specified input name. The namespace should be one of the special constants produced by the &lt;code&gt;uuid_ns_*()&lt;/code&gt; functions shown in &lt;a href=&quot;uuid-ossp#UUID-OSSP-CONSTANTS&quot;&gt;Table F.33&lt;/a&gt;. (It could be any UUID in theory.) The name is an identifier in the selected namespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23cef3016afd0a928c6e33c378fcd6c9a3819d0e" translate="yes" xml:space="preserve">
          <source>Generates a version 4 UUID, which is derived entirely from random numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abf0eb60bb57f570d739469888a828e2f5865138" translate="yes" xml:space="preserve">
          <source>Generates a version 5 UUID, which works like a version 3 UUID except that SHA-1 is used as a hashing method. Version 5 should be preferred over version 3 because SHA-1 is thought to be more secure than MD5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aed1c9095c07cc7e84b3424230f02a2d9b469cc" translate="yes" xml:space="preserve">
          <source>Generic Security Services Application Programming Interface</source>
          <target state="translated">通用安全服务应用编程接口</target>
        </trans-unit>
        <trans-unit id="8bc48767cdd05b47e355717259ca35db85925a08" translate="yes" xml:space="preserve">
          <source>Generic WAL Records</source>
          <target state="translated">通用的WAL记录</target>
        </trans-unit>
        <trans-unit id="205b89cfc2a1a2269f79b2bc4ed00c40f5cec848" translate="yes" xml:space="preserve">
          <source>Generic WAL assumes that the pages to be modified have standard layout, and in particular that there is no useful data between &lt;code&gt;pd_lower&lt;/code&gt; and &lt;code&gt;pd_upper&lt;/code&gt;.</source>
          <target state="translated">通用WAL假定要修改的页面具有标准布局，尤其是在 &lt;code&gt;pd_lower&lt;/code&gt; 和 &lt;code&gt;pd_upper&lt;/code&gt; 之间没有有用的数据。</target>
        </trans-unit>
        <trans-unit id="651fc79b97c554a5773cb00dd19d49f06b1a6de8" translate="yes" xml:space="preserve">
          <source>Genetic Query Optimizer</source>
          <target state="translated">遗传查询优化器</target>
        </trans-unit>
        <trans-unit id="285a459d41ebc8b40cc4e21eb5058c5046b9a518" translate="yes" xml:space="preserve">
          <source>Genetic Query Optimizer: Further Reading</source>
          <target state="translated">遗传查询优化器。进一步阅读</target>
        </trans-unit>
        <trans-unit id="0fe3a114537a44f8bb8da3ae145d25fd674c9baa" translate="yes" xml:space="preserve">
          <source>Genetic Query Optimizer: Genetic Algorithms</source>
          <target state="translated">遗传查询优化器。遗传算法</target>
        </trans-unit>
        <trans-unit id="a4b0f535ba1259d8c2e707ca90836a3a1579135e" translate="yes" xml:space="preserve">
          <source>Genetic Query Optimizer: Genetic Query Optimization (GEQO) in PostgreSQL</source>
          <target state="translated">遗传查询优化器。PostgreSQL中的遗传查询优化(GEQO)</target>
        </trans-unit>
        <trans-unit id="c07c10eab422b8e5a37b4814c23b452b246b27ed" translate="yes" xml:space="preserve">
          <source>Genetic Query Optimizer: Query Handling as a Complex Optimization Problem</source>
          <target state="translated">遗传查询优化器。查询处理作为一个复杂的优化问题</target>
        </trans-unit>
        <trans-unit id="59a79a1ee234d61d42db147aa7f797d2e6ec2302" translate="yes" xml:space="preserve">
          <source>Geometric Types</source>
          <target state="translated">几何类型</target>
        </trans-unit>
        <trans-unit id="1b872848d87aaa550340d8fe24c7f0a2a9ae8bcb" translate="yes" xml:space="preserve">
          <source>Geometric Types: box</source>
          <target state="translated">几何类型:盒子</target>
        </trans-unit>
        <trans-unit id="92cdb69f3efb505ed8f65eafd9adff3faa140669" translate="yes" xml:space="preserve">
          <source>Geometric Types: circle</source>
          <target state="translated">几何类型:圆</target>
        </trans-unit>
        <trans-unit id="b780ba45a62c07dae122a8391383dec51d0ae3fb" translate="yes" xml:space="preserve">
          <source>Geometric Types: line</source>
          <target state="translated">几何类型:线</target>
        </trans-unit>
        <trans-unit id="93e949ac77b5da81e10c0d00eb14e5b76ecbcd17" translate="yes" xml:space="preserve">
          <source>Geometric Types: lseg</source>
          <target state="translated">几何类型:lseg</target>
        </trans-unit>
        <trans-unit id="70c8994901b16ea96046ff8cb3549fb5591cc7c5" translate="yes" xml:space="preserve">
          <source>Geometric Types: path</source>
          <target state="translated">几何类型:路径</target>
        </trans-unit>
        <trans-unit id="5971b419fcb4741dbee95edc6702d224da6e2f8b" translate="yes" xml:space="preserve">
          <source>Geometric Types: point</source>
          <target state="translated">几何类型:点</target>
        </trans-unit>
        <trans-unit id="a42b9eae0d25dcae6593b119b1ff920376ab3fdb" translate="yes" xml:space="preserve">
          <source>Geometric Types: polygon</source>
          <target state="translated">几何类型:多边形</target>
        </trans-unit>
        <trans-unit id="c0f24750d757100bf5b4c2c76561499175630de1" translate="yes" xml:space="preserve">
          <source>Geometric data types represent two-dimensional spatial objects. &lt;a href=&quot;datatype-geometric#DATATYPE-GEO-TABLE&quot;&gt;Table 8.20&lt;/a&gt; shows the geometric types available in PostgreSQL.</source>
          <target state="translated">几何数据类型表示二维空间对象。&lt;a href=&quot;datatype-geometric#DATATYPE-GEO-TABLE&quot;&gt;表8.20&lt;/a&gt;显示了PostgreSQL中可用的几何类型。</target>
        </trans-unit>
        <trans-unit id="7694ba97cb7c18e18a22a41d6adc199509b697ef" translate="yes" xml:space="preserve">
          <source>Geometric types</source>
          <target state="translated">几何类型</target>
        </trans-unit>
        <trans-unit id="9ae1f34e04075cebb1033f14ff7dd7b2bf91177b" translate="yes" xml:space="preserve">
          <source>Geometric: #</source>
          <target state="translated">几何。#</target>
        </trans-unit>
        <trans-unit id="623ca67b93ccce110311b935c4b0ce7ca78865ad" translate="yes" xml:space="preserve">
          <source>Geometric: # path &amp;#x27;,,)&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="541465ff2784b3862252a679a04558fbc655a79e" translate="yes" xml:space="preserve">
          <source>Geometric: ##</source>
          <target state="translated">几何。##</target>
        </trans-unit>
        <trans-unit id="72e0052efc06dc944e06a8b63310fcb1f4bce4d7" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;amp;&amp;amp;</source>
          <target state="translated">几何：&amp;amp;&amp;amp;</target>
        </trans-unit>
        <trans-unit id="c6f1767ec1ac7b1e533771c3bc6f2d157e3a0ffa" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;amp;&amp;gt;</source>
          <target state="translated">几何：＆&amp;gt;</target>
        </trans-unit>
        <trans-unit id="0efad1957c6995260f5c39d190b260d9567a113b" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;amp;&amp;lt;</source>
          <target state="translated">几何：＆&amp;lt;</target>
        </trans-unit>
        <trans-unit id="0f689675538b5b4ec110540ff41eb289d6bd6b43" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;amp;&amp;lt;|</source>
          <target state="translated">几何：＆&amp;lt;|</target>
        </trans-unit>
        <trans-unit id="f1e472c7b332a52572d117379abc66949f9e31c1" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;gt;&amp;gt;</source>
          <target state="translated">几何：&amp;gt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e6fb2a9acb2064c887124b6f5b0e4e754de5f5fc" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;gt;^</source>
          <target state="translated">几何：&amp;gt; ^</target>
        </trans-unit>
        <trans-unit id="d77e84d344e830ae23e28900f46ab81224e68d7d" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;lt;&amp;lt;</source>
          <target state="translated">几何的：&amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="114e3e68bec04a11161b64f095fcabaa1b93c022" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;lt;&amp;lt;|</source>
          <target state="translated">几何：&amp;lt;&amp;lt; |</target>
        </trans-unit>
        <trans-unit id="3ebddf62e56d977cd85a67e8678d46b2782a23db" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;lt;-&amp;gt;</source>
          <target state="translated">几何：&amp;lt;-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f3447c8a88fb2334b8df577a95ce9dc8220f2dd2" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;lt;@</source>
          <target state="translated">几何：&amp;lt;@</target>
        </trans-unit>
        <trans-unit id="cce9525015da81ce4d350742ece1c53d96c3ca2b" translate="yes" xml:space="preserve">
          <source>Geometric: &amp;lt;^</source>
          <target state="translated">几何：&amp;lt;^</target>
        </trans-unit>
        <trans-unit id="56a2009f06f5c74871588a05282ba0b39fb6ceeb" translate="yes" xml:space="preserve">
          <source>Geometric: *</source>
          <target state="translated">几何。*</target>
        </trans-unit>
        <trans-unit id="fa3ffad94fe9509b3b02c414cf9edaa0a2aba46e" translate="yes" xml:space="preserve">
          <source>Geometric: +</source>
          <target state="translated">几何。+</target>
        </trans-unit>
        <trans-unit id="356d9d70234e609b9b853b2369c157f70b7aebbe" translate="yes" xml:space="preserve">
          <source>Geometric: -</source>
          <target state="translated">几何:-</target>
        </trans-unit>
        <trans-unit id="2ffe2cc10b627cd354dfeb7422da5a985c240d62" translate="yes" xml:space="preserve">
          <source>Geometric: /</source>
          <target state="translated">几何。/</target>
        </trans-unit>
        <trans-unit id="1c2280f6c1d1edcd9860d33a2a8a075c691adc71" translate="yes" xml:space="preserve">
          <source>Geometric: ?#</source>
          <target state="translated">几何学:?</target>
        </trans-unit>
        <trans-unit id="12821b449935c6dc49b03d2b040482308099f146" translate="yes" xml:space="preserve">
          <source>Geometric: ?-</source>
          <target state="translated">几何:?</target>
        </trans-unit>
        <trans-unit id="3cd66d53af1e48242331e1745ba5fc7187566303" translate="yes" xml:space="preserve">
          <source>Geometric: ?- lseg &amp;#x27;&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41659a241d6173118c63109b8d58f3b040547d38" translate="yes" xml:space="preserve">
          <source>Geometric: ?-|</source>
          <target state="translated">几何学:?-|</target>
        </trans-unit>
        <trans-unit id="d6f03fc9c9b0ab0563a28c6910f4a205a373dffb" translate="yes" xml:space="preserve">
          <source>Geometric: ?|</source>
          <target state="translated">几何:?</target>
        </trans-unit>
        <trans-unit id="38b31205d1dae501b1ba03ac0e742900375d3d6b" translate="yes" xml:space="preserve">
          <source>Geometric: ?| lseg &amp;#x27;&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13e94b0d1073bd3bdfb91bcd5a193786583c973b" translate="yes" xml:space="preserve">
          <source>Geometric: ?||</source>
          <target state="translated">几何学:?||</target>
        </trans-unit>
        <trans-unit id="9330c7f285f4544ce63cffaf12c739ac5f145ca1" translate="yes" xml:space="preserve">
          <source>Geometric: @&amp;gt;</source>
          <target state="translated">几何的：@&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5270f97dad19be61277e040028add99dc4c8a2f8" translate="yes" xml:space="preserve">
          <source>Geometric: @-@</source>
          <target state="translated">几何。@-@</target>
        </trans-unit>
        <trans-unit id="fe111f6519f93956916d5072524a2a1cf0002778" translate="yes" xml:space="preserve">
          <source>Geometric: @-@ path &amp;#x27;&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28dfb9d3208de0df87974a869f843209287712a0" translate="yes" xml:space="preserve">
          <source>Geometric: @@</source>
          <target state="translated">Geometric:@@</target>
        </trans-unit>
        <trans-unit id="3c3c043849e3c1e3749e2bdce5b1a842a3084138" translate="yes" xml:space="preserve">
          <source>Geometric: @@ box &amp;#x27;,&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b52a6568265c2c5d617423e6cf36665bbcecd5cd" translate="yes" xml:space="preserve">
          <source>Geometric: area</source>
          <target state="translated">几何:面积</target>
        </trans-unit>
        <trans-unit id="81b6264e52168059ad003a6e2b407928038d86a2" translate="yes" xml:space="preserve">
          <source>Geometric: area,&amp;#x27;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93665e808ca1c14ef16cc6912cf6d87101aae4b0" translate="yes" xml:space="preserve">
          <source>Geometric: bound_box</source>
          <target state="translated">Geometric:bound_box</target>
        </trans-unit>
        <trans-unit id="e0c040881075a6da4960c127c1025ca1c4e3e78e" translate="yes" xml:space="preserve">
          <source>Geometric: bound_box,&amp;#x27;, box &amp;#x27;,&amp;#x27;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39d2105da034c7db21d98973af72a8064f606dda" translate="yes" xml:space="preserve">
          <source>Geometric: box</source>
          <target state="translated">几何:盒子</target>
        </trans-unit>
        <trans-unit id="f2f9f89c4b6f4917d364f4c229b877c630c28339" translate="yes" xml:space="preserve">
          <source>Geometric: box &amp;#x27;,&amp;#x27; # box &amp;#x27;,&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2816ad481532412dc4f968541eb54f6a73270279" translate="yes" xml:space="preserve">
          <source>Geometric: box &amp;#x27;,&amp;#x27; &amp;amp;&amp;amp; box &amp;#x27;,&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2fd06d9fd68d32124c59b325cb0db0d79219bc5" translate="yes" xml:space="preserve">
          <source>Geometric: box &amp;#x27;,&amp;#x27; &amp;amp;&amp;gt; box &amp;#x27;,&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acff8f01767e5f76f5b1d4fd1a990a03aad21fec" translate="yes" xml:space="preserve">
          <source>Geometric: box &amp;#x27;,&amp;#x27; &amp;amp;&amp;lt; box &amp;#x27;,&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6174b595baddb6f900bbe68bd994ef45d5794b9" translate="yes" xml:space="preserve">
          <source>Geometric: box &amp;#x27;,&amp;#x27; &amp;amp;&amp;lt;| box &amp;#x27;,&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c46e012460f34cad22ebb427ed0712715560663" translate="yes" xml:space="preserve">
          <source>Geometric: box &amp;#x27;,&amp;#x27; &amp;lt;&amp;lt;| box &amp;#x27;,&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd84c4808d85b33347dff12aa320353447c00559" translate="yes" xml:space="preserve">
          <source>Geometric: box &amp;#x27;,&amp;#x27; + point &amp;#x27;&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2043406f5483c3b78fe2702d1e60c14292a2b7fc" translate="yes" xml:space="preserve">
          <source>Geometric: box &amp;#x27;,&amp;#x27; - point &amp;#x27;&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef9ed5b74e6ef8d26a18017da8e1beeeec09cd1e" translate="yes" xml:space="preserve">
          <source>Geometric: box &amp;#x27;,&amp;#x27; |&amp;amp;&amp;gt; box &amp;#x27;,&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0efc8325a73507b346ab303c99230f031e5d01e" translate="yes" xml:space="preserve">
          <source>Geometric: box &amp;#x27;,&amp;#x27; |&amp;gt;&amp;gt; box &amp;#x27;,&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b4c443e59431193bcca574cac250450f92759da" translate="yes" xml:space="preserve">
          <source>Geometric: box &amp;#x27;,)&amp;#x27; &amp;gt;^ box &amp;#x27;,)&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab59191ffc41e6e94384185a516bb868f42810c0" translate="yes" xml:space="preserve">
          <source>Geometric: box &amp;#x27;,)&amp;#x27; &amp;lt;^ box &amp;#x27;,)&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fe5ea0c0f9734fffa0671e590985facfaf3a07d" translate="yes" xml:space="preserve">
          <source>Geometric: box&amp;#x27;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9b733d8febdf138608e064b45be416040fbb687" translate="yes" xml:space="preserve">
          <source>Geometric: box&amp;#x27;, point &amp;#x27;&amp;#x27;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="006e03d5685497ae0051c04f0f60f285cd6720c9" translate="yes" xml:space="preserve">
          <source>Geometric: box,,)&amp;#x27;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03bd3a9c2b876396b45f5f79b42b5cdad4adebd2" translate="yes" xml:space="preserve">
          <source>Geometric: box,2&amp;gt;&amp;#x27;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f403cd59f8511c55a29a5613deb6dc17553ae356" translate="yes" xml:space="preserve">
          <source>Geometric: center</source>
          <target state="translated">几何:中心</target>
        </trans-unit>
        <trans-unit id="b8d1e8b02bdbf1095140cb17f5807ecc91d43016" translate="yes" xml:space="preserve">
          <source>Geometric: center,&amp;#x27;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4f391fd63cca84c9f17c34aa7cc7e489332e1f7" translate="yes" xml:space="preserve">
          <source>Geometric: circle</source>
          <target state="translated">几何:圆</target>
        </trans-unit>
        <trans-unit id="c535f92f1ddcd8259b16d0e3bee14e0580797b6f" translate="yes" xml:space="preserve">
          <source>Geometric: circle &amp;#x27;&amp;lt;,1&amp;gt;&amp;#x27; &amp;gt;&amp;gt; circle &amp;#x27;&amp;lt;,1&amp;gt;&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa5e4572ef426454d58bb1dd84794831792d9e66" translate="yes" xml:space="preserve">
          <source>Geometric: circle &amp;#x27;&amp;lt;,1&amp;gt;&amp;#x27; &amp;lt;&amp;lt; circle &amp;#x27;&amp;lt;,1&amp;gt;&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cff985774e188b9f562e91cd8addc996ee66f5e" translate="yes" xml:space="preserve">
          <source>Geometric: circle &amp;#x27;&amp;lt;,1&amp;gt;&amp;#x27; &amp;lt;-&amp;gt; circle &amp;#x27;&amp;lt;,1&amp;gt;&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aca3c18e75d0490dc088bdeee289cf2f2ddb6623" translate="yes" xml:space="preserve">
          <source>Geometric: circle &amp;#x27;&amp;lt;,2&amp;gt;&amp;#x27; @&amp;gt; point &amp;#x27;&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e96c558473932e2346f244a964ddae1b0c5b426" translate="yes" xml:space="preserve">
          <source>Geometric: circle&amp;#x27;, 2.0)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0a8f29a6cfa0086f71a2371a4a9cfa61519981f" translate="yes" xml:space="preserve">
          <source>Geometric: circle,&amp;#x27;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0b3563bc1ec602c1db6eda2dfa3e1d52d9bcc3f" translate="yes" xml:space="preserve">
          <source>Geometric: circle,,)&amp;#x27;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53c6cfb41275da6c404267d632f7f90d89031096" translate="yes" xml:space="preserve">
          <source>Geometric: diagonal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="553006cf848708f4902731c3386a9dc66eabab66" translate="yes" xml:space="preserve">
          <source>Geometric: diagonal,&amp;#x27;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9d52c7012ac5f08fa191553229f86a574d2d1fe" translate="yes" xml:space="preserve">
          <source>Geometric: diameter</source>
          <target state="translated">几何:直径</target>
        </trans-unit>
        <trans-unit id="373415090bda87622f255f56f7a729917c064931" translate="yes" xml:space="preserve">
          <source>Geometric: diameter,2&amp;gt;&amp;#x27;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eba387383e96b60f7dd8fc11f767b059ffe3a921" translate="yes" xml:space="preserve">
          <source>Geometric: height</source>
          <target state="translated">几何:高度</target>
        </trans-unit>
        <trans-unit id="9fe1907c928c52f78e63d26b9f3f3f24fef06655" translate="yes" xml:space="preserve">
          <source>Geometric: height,&amp;#x27;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfc5959ea0a6181524e306d022dfcc8e49a1d83c" translate="yes" xml:space="preserve">
          <source>Geometric: isclosed</source>
          <target state="translated">几何:是封闭的</target>
        </trans-unit>
        <trans-unit id="6bc612f7069d860cd43f5e1d8de4a3377f55aac2" translate="yes" xml:space="preserve">
          <source>Geometric: isclosed,,)&amp;#x27;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f81a6975db9a38b5af5931e1338ccf232987667" translate="yes" xml:space="preserve">
          <source>Geometric: isopen</source>
          <target state="translated">几何:是开放的</target>
        </trans-unit>
        <trans-unit id="9da3cbb89ee4413929959266836080754f0761b5" translate="yes" xml:space="preserve">
          <source>Geometric: isopen,,]&amp;#x27;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9a3900467aaca1b8a4c1362db68f305b19582ef" translate="yes" xml:space="preserve">
          <source>Geometric: length</source>
          <target state="translated">几何:长度</target>
        </trans-unit>
        <trans-unit id="0f477e538e17fdaf626987c0b3e059c4ed218340" translate="yes" xml:space="preserve">
          <source>Geometric: length,)&amp;#x27;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ba5f3a75b551d018972ef798eb335c100716e14" translate="yes" xml:space="preserve">
          <source>Geometric: line</source>
          <target state="translated">几何:线</target>
        </trans-unit>
        <trans-unit id="72246d884c9da412f7faa402c1b15644165242d1" translate="yes" xml:space="preserve">
          <source>Geometric: line&amp;#x27;, point &amp;#x27;&amp;#x27;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="206f9fccbd7deb8bf02553e15b19fa03337233fd" translate="yes" xml:space="preserve">
          <source>Geometric: lseg</source>
          <target state="translated">几何:lseg</target>
        </trans-unit>
        <trans-unit id="a3e0f8989703d9c594a884c56db0eb613ad74516" translate="yes" xml:space="preserve">
          <source>Geometric: lseg &amp;#x27;&amp;#x27; # lseg &amp;#x27;&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cb00d68ff82986196da967a004bf414500fdbc3" translate="yes" xml:space="preserve">
          <source>Geometric: lseg &amp;#x27;&amp;#x27; ?# box &amp;#x27;,&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5370b1ba4e23c335eab44730c33ba038eab3dcde" translate="yes" xml:space="preserve">
          <source>Geometric: lseg &amp;#x27;&amp;#x27; ?-| lseg &amp;#x27;&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac68a0711d9e1d8888e00b92046aa1a1a2a3a5ec" translate="yes" xml:space="preserve">
          <source>Geometric: lseg &amp;#x27;&amp;#x27; ?|| lseg &amp;#x27;&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="602ad64d70c153b03a7b7aac0df2c618dd7413ee" translate="yes" xml:space="preserve">
          <source>Geometric: lseg&amp;#x27;, point &amp;#x27;&amp;#x27;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87ca41bc81644dec1ecec1aaf558379a4bf49a06" translate="yes" xml:space="preserve">
          <source>Geometric: lseg,&amp;#x27;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d54cec15bcab56f2da1b1f390b73632b1dcbf4d" translate="yes" xml:space="preserve">
          <source>Geometric: npoints</source>
          <target state="translated">几何:n点</target>
        </trans-unit>
        <trans-unit id="82f9176da26c349ac3a2fec9cfbb20c91c1ceba2" translate="yes" xml:space="preserve">
          <source>Geometric: npoints,,]&amp;#x27;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28645e62602ce8fec7218147e4987f407e8f9a72" translate="yes" xml:space="preserve">
          <source>Geometric: path</source>
          <target state="translated">几何:路径</target>
        </trans-unit>
        <trans-unit id="6f5880dc04850313da101d9308d336ea96de5d8c" translate="yes" xml:space="preserve">
          <source>Geometric: path &amp;#x27;&amp;#x27; + path &amp;#x27;&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cff8e922e3b31692c9ca250b6025ed31dd8fdd3d" translate="yes" xml:space="preserve">
          <source>Geometric: path &amp;#x27;,,)&amp;#x27; * point &amp;#x27;&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01bbc7843b38974a4c7d9f7e2b9400b56faabea0" translate="yes" xml:space="preserve">
          <source>Geometric: path &amp;#x27;,,)&amp;#x27; * point, sind)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0c3a98f4a21bb6236d0f2cfa15d8ab5a7945f46" translate="yes" xml:space="preserve">
          <source>Geometric: path &amp;#x27;,,)&amp;#x27; / point &amp;#x27;&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="124e9a6db4d0ac040d679077edb6b8ab8a6696d7" translate="yes" xml:space="preserve">
          <source>Geometric: path &amp;#x27;,,)&amp;#x27; / point, sind)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c51b62ccd035da31f83330a680fa86308c2f3d9" translate="yes" xml:space="preserve">
          <source>Geometric: path,,)&amp;#x27;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45ec99c5c4e908e62ccff4e585500d723032cfdc" translate="yes" xml:space="preserve">
          <source>Geometric: pclose</source>
          <target state="translated">几何图形:pclose</target>
        </trans-unit>
        <trans-unit id="b182f6b565883e6e2c646016b78ac68577626b98" translate="yes" xml:space="preserve">
          <source>Geometric: pclose,,]&amp;#x27;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="507989896f0547d05a215ff9f295d24b17e091c7" translate="yes" xml:space="preserve">
          <source>Geometric: point</source>
          <target state="translated">几何:点</target>
        </trans-unit>
        <trans-unit id="a2bd5d2d4b4907f20a470b8849f5a3801b5cf240" translate="yes" xml:space="preserve">
          <source>Geometric: point &amp;#x27;&amp;#x27; ## lseg &amp;#x27;&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4fbb59521d848959fc9c310aa00242e442c3c84" translate="yes" xml:space="preserve">
          <source>Geometric: point &amp;#x27;&amp;#x27; &amp;gt;^ point &amp;#x27;&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98399bfb394dae31e0ee9be7a1510b6d2f29c20d" translate="yes" xml:space="preserve">
          <source>Geometric: point &amp;#x27;&amp;#x27; &amp;lt;@ circle &amp;#x27;&amp;lt;,2&amp;gt;&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5899e5d0e3c89c66550565207bae86ba6b876cca" translate="yes" xml:space="preserve">
          <source>Geometric: point &amp;#x27;&amp;#x27; &amp;lt;^ point &amp;#x27;&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a7ecda7f258e60f6482f618841a959ce963e1eb" translate="yes" xml:space="preserve">
          <source>Geometric: point &amp;#x27;&amp;#x27; ?- point &amp;#x27;&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f37b2dc5b2749acec1a49318ba6543c2d864c85f" translate="yes" xml:space="preserve">
          <source>Geometric: point &amp;#x27;&amp;#x27; ?| point &amp;#x27;&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fde5286b89f54817cc5ab239faa374c00dc4606" translate="yes" xml:space="preserve">
          <source>Geometric: point,&amp;#x27;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8a576ac01a8a1ee78f8ff82f815c76dacfdc290" translate="yes" xml:space="preserve">
          <source>Geometric: point,,)&amp;#x27;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f23b963baba040a9faace3d21a05bf602160384" translate="yes" xml:space="preserve">
          <source>Geometric: point,2&amp;gt;&amp;#x27;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65a338ccdb82881febce734e97c4fdf45d453ff3" translate="yes" xml:space="preserve">
          <source>Geometric: point,]&amp;#x27;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ae9f6bad12ee8c28eb43284381811f2bae31846" translate="yes" xml:space="preserve">
          <source>Geometric: polygon</source>
          <target state="translated">几何:多边形</target>
        </trans-unit>
        <trans-unit id="5b35c0d746dfcc047a0afcd93f0b3c4cd18bde6b" translate="yes" xml:space="preserve">
          <source>Geometric: polygon &amp;#x27;,)&amp;#x27; ~= polygon &amp;#x27;,)&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="869816f787f3c390221cdff48c373141618216b9" translate="yes" xml:space="preserve">
          <source>Geometric: polygon,&amp;#x27;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab05db392d81b824cdb41f7a6fe5d8d14bc9d11f" translate="yes" xml:space="preserve">
          <source>Geometric: polygon,,)&amp;#x27;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5804fd3a3f57f14319c118fa75cb7051954b6773" translate="yes" xml:space="preserve">
          <source>Geometric: polygon,1&amp;gt;&amp;#x27;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6845c24e84d1c6f6af34f8e667ff55b799afc77" translate="yes" xml:space="preserve">
          <source>Geometric: polygon,2&amp;gt;&amp;#x27;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="819b82ef2ad538d3fe48c1ae412245c21d9fd58a" translate="yes" xml:space="preserve">
          <source>Geometric: popen</source>
          <target state="translated">几何学:popen</target>
        </trans-unit>
        <trans-unit id="0ce17112425a0c921d0d37f14277221f7e5cb662" translate="yes" xml:space="preserve">
          <source>Geometric: popen,,)&amp;#x27;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="833a7938b28ff55bf890ede9562c88a3cf3616b2" translate="yes" xml:space="preserve">
          <source>Geometric: radius</source>
          <target state="translated">几何:半径</target>
        </trans-unit>
        <trans-unit id="1c82295a4acd05e88581d706623e57915bba554e" translate="yes" xml:space="preserve">
          <source>Geometric: radius,2&amp;gt;&amp;#x27;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31424f50624bafbef104ec60ff8d6cd6d9806a4a" translate="yes" xml:space="preserve">
          <source>Geometric: slope</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e674485cf8e6967f9fda199dfc4f37a6860ba57a" translate="yes" xml:space="preserve">
          <source>Geometric: slope&amp;#x27;, point &amp;#x27;&amp;#x27;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f7868cefc6080ede3e7599ccdee8580f1c6391a" translate="yes" xml:space="preserve">
          <source>Geometric: width</source>
          <target state="translated">几何:宽度</target>
        </trans-unit>
        <trans-unit id="ecb1f3c3e3bb61f6a55b262498f5de376961e7b6" translate="yes" xml:space="preserve">
          <source>Geometric: width,&amp;#x27;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3d7536af893973e797484588417b811fa49c9c9" translate="yes" xml:space="preserve">
          <source>Geometric: |&amp;amp;&amp;gt;</source>
          <target state="translated">几何：|＆&amp;gt;</target>
        </trans-unit>
        <trans-unit id="dac5ddcfb396044c241822b103826072cea9122a" translate="yes" xml:space="preserve">
          <source>Geometric: |&amp;gt;&amp;gt;</source>
          <target state="translated">几何：| &amp;gt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e1ce90a64a5a3e719604091e787102d24302368f" translate="yes" xml:space="preserve">
          <source>Geometric: ~=</source>
          <target state="translated">几何:~=</target>
        </trans-unit>
        <trans-unit id="3764766959b2e2fca792b770cb84c07ab6ed354f" translate="yes" xml:space="preserve">
          <source>Germ&amp;aacute;n M&amp;eacute;ndez Bravo (Kronuz), 2004 - 2006</source>
          <target state="translated">杰曼&amp;middot;门德斯&amp;middot;布拉沃（克罗努兹），2004年-2006年</target>
        </trans-unit>
        <trans-unit id="a5921456830bc3242d009637ad1fbb6f191cdc48" translate="yes" xml:space="preserve">
          <source>Germ&amp;aacute;n M&amp;eacute;ndez Bravo (Kronuz), 2004&amp;ndash;2006</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8435540f9357c0427826e02b4177ce363970db3c" translate="yes" xml:space="preserve">
          <source>German collation for Austria, default variant</source>
          <target state="translated">奥地利的德文拼写,默认变体</target>
        </trans-unit>
        <trans-unit id="7510fc993536622c741a49aafa894361e7ab10a4" translate="yes" xml:space="preserve">
          <source>German collation with phone book collation type</source>
          <target state="translated">德文整理与电话簿整理类型</target>
        </trans-unit>
        <trans-unit id="564857758dc8e91c1f74d993f78de5567b5c7dfc" translate="yes" xml:space="preserve">
          <source>German collation, default variant</source>
          <target state="translated">德文拼写,默认变体</target>
        </trans-unit>
        <trans-unit id="f27aff0cadc166c49cd93ee1187bf701f6029a5e" translate="yes" xml:space="preserve">
          <source>Get &lt;code&gt;n&lt;/code&gt;-th coordinate of cube (counting from 1).</source>
          <target state="translated">获取立方体的第 &lt;code&gt;n&lt;/code&gt; 个坐标（从1开始计数）。</target>
        </trans-unit>
        <trans-unit id="d35f795aa05a88fb426392aad122ef3b2bb082f7" translate="yes" xml:space="preserve">
          <source>Get &lt;code&gt;n&lt;/code&gt;-th coordinate of cube in following way: n = 2 * k - 1 means lower bound of &lt;code&gt;k&lt;/code&gt;-th dimension, n = 2 * k means upper bound of &lt;code&gt;k&lt;/code&gt;-th dimension. Negative &lt;code&gt;n&lt;/code&gt; denotes the inverse value of the corresponding positive coordinate. This operator is designed for KNN-GiST support.</source>
          <target state="translated">通过以下方式获得立方体的第 &lt;code&gt;n&lt;/code&gt; 个坐标：n = 2 * k-1表示第 &lt;code&gt;k&lt;/code&gt; 维的下界，n = 2 * k表示第 &lt;code&gt;k&lt;/code&gt; 维的上限。负 &lt;code&gt;n&lt;/code&gt; 表示相应正坐标的倒数值。该运算符专为KNN-GiST支持而设计。</target>
        </trans-unit>
        <trans-unit id="cc6f8c8aaf13b3fdd311883db3b903abaee70123" translate="yes" xml:space="preserve">
          <source>Get JSON array element (indexed from zero, negative integers count from the end)</source>
          <target state="translated">获取JSON数组元素(索引从零开始,负整数从末尾开始计算)。</target>
        </trans-unit>
        <trans-unit id="96cd8c94d1b03053f959c0260a5693091dfb369e" translate="yes" xml:space="preserve">
          <source>Get JSON array element as &lt;code&gt;text&lt;/code&gt;</source>
          <target state="translated">获取JSON数组元素作为 &lt;code&gt;text&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf31bd14e1935206dcfd63aadbd1872ba57dea93" translate="yes" xml:space="preserve">
          <source>Get JSON object at the specified path</source>
          <target state="translated">在指定路径获取JSON对象</target>
        </trans-unit>
        <trans-unit id="ef1cbd5cb305475720a9020825d5fd0aab442b3e" translate="yes" xml:space="preserve">
          <source>Get JSON object at the specified path as &lt;code&gt;text&lt;/code&gt;</source>
          <target state="translated">在指定路径下以 &lt;code&gt;text&lt;/code&gt; 获取JSON对象</target>
        </trans-unit>
        <trans-unit id="25fd43d0d3f16339264c4b37b814115f9d3ce410" translate="yes" xml:space="preserve">
          <source>Get JSON object field as &lt;code&gt;text&lt;/code&gt;</source>
          <target state="translated">获取JSON对象字段作为 &lt;code&gt;text&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="073ceb452af411396658b2179c607b15772b77b9" translate="yes" xml:space="preserve">
          <source>Get JSON object field by key</source>
          <target state="translated">按键获取JSON对象字段</target>
        </trans-unit>
        <trans-unit id="a3c9485f60ac0e72f3350d75767b48ed6ff294ae" translate="yes" xml:space="preserve">
          <source>Get current write-ahead log flush location</source>
          <target state="translated">获取当前的写入式日志刷新位置。</target>
        </trans-unit>
        <trans-unit id="ff5bd5ba7d4bd0b1adf164a5c3514a0cde09068d" translate="yes" xml:space="preserve">
          <source>Get current write-ahead log insert location</source>
          <target state="translated">获取当前的写前日志插入位置</target>
        </trans-unit>
        <trans-unit id="6d563af8ba9dd62228b11fa7ee4de03e9c015df2" translate="yes" xml:space="preserve">
          <source>Get current write-ahead log write location</source>
          <target state="translated">获取当前写前日志的写入位置</target>
        </trans-unit>
        <trans-unit id="5a63fc57b07be5ce8ae7fc6091aace9eaf741156" translate="yes" xml:space="preserve">
          <source>Get interval subfield (equivalent to &lt;code&gt;extract&lt;/code&gt;); see &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;Section 9.9.1&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7654b6edcaa442685671e13437c400615fa36a31" translate="yes" xml:space="preserve">
          <source>Get interval subfield; see &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;Section 9.9.1&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6128ac644ecb365c2a1eeec7ff1509ae52372521" translate="yes" xml:space="preserve">
          <source>Get last write-ahead log location received and synced to disk by streaming replication. While streaming replication is in progress this will increase monotonically. If recovery has completed this will remain static at the value of the last WAL record received and synced to disk during recovery. If streaming replication is disabled, or if it has not yet started, the function returns NULL.</source>
          <target state="translated">获取最后一次通过流式复制接收到并同步到磁盘的写前日志位置。当流式复制进行时,这个值将单调地增加。如果恢复已经完成,这个值将保持在恢复过程中最后收到并同步到磁盘的WAL记录的值上。如果流式复制被禁用,或者还没有开始,函数返回NULL。</target>
        </trans-unit>
        <trans-unit id="76a64be22601bc127252c3868430ba6f7837c55b" translate="yes" xml:space="preserve">
          <source>Get last write-ahead log location replayed during recovery. If recovery is still in progress this will increase monotonically. If recovery has completed then this value will remain static at the value of the last WAL record applied during that recovery. When the server has been started normally without recovery the function returns NULL.</source>
          <target state="translated">获取恢复过程中重放的最后一次写头日志位置。如果恢复仍在进行中,该值将单调增加。如果恢复已经完成,那么这个值将保持在恢复期间应用的最后一条WAL记录的值上。当服务器在没有恢复的情况下正常启动时,函数返回NULL。</target>
        </trans-unit>
        <trans-unit id="406fdc630e83917e4241518be673ae1f0d8347d2" translate="yes" xml:space="preserve">
          <source>Get start time of an on-line exclusive backup in progress.</source>
          <target state="translated">获取在线专属备份的开始时间。</target>
        </trans-unit>
        <trans-unit id="dca6c016406c3b0ed8f48fe56cd9e3bf358bbd54" translate="yes" xml:space="preserve">
          <source>Get subfield (equivalent to &lt;code&gt;extract&lt;/code&gt;); see &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;Section 9.9.1&lt;/a&gt;</source>
          <target state="translated">获取子字段（相当于 &lt;code&gt;extract&lt;/code&gt; ）；参见&lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;第9.9.1节&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3152064f9ae3eb1ab6d172e1fe8f75ea161bdf61" translate="yes" xml:space="preserve">
          <source>Get subfield; see &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;Section 9.9.1&lt;/a&gt;</source>
          <target state="translated">获取子字段；参见&lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;第9.9.1节&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4cfad13dc60760cc3b206a5a63697b11a532048c" translate="yes" xml:space="preserve">
          <source>Get time stamp of last transaction replayed during recovery. This is the time at which the commit or abort WAL record for that transaction was generated on the primary. If no transactions have been replayed during recovery, this function returns NULL. Otherwise, if recovery is still in progress this will increase monotonically. If recovery has completed then this value will remain static at the value of the last transaction applied during that recovery. When the server has been started normally without recovery the function returns NULL.</source>
          <target state="translated">获取恢复过程中最后一个事务重放的时间戳,这是该事务在主事务上生成提交或中止WAL记录的时间。这是在主服务器上生成该事务的提交或中止WAL记录的时间。如果在恢复过程中没有事务被重放,这个函数返回NULL。否则,如果恢复仍在进行中,这个值将单调地增加。如果恢复已经完成,那么这个值将保持在恢复期间应用的最后一个事务的值上。当服务器在没有恢复的情况下正常启动时,该函数返回NULL。</target>
        </trans-unit>
        <trans-unit id="9ab69254c214c6784aca932c9cdbfd619399aeab" translate="yes" xml:space="preserve">
          <source>Get timestamp subfield (equivalent to &lt;code id=&quot;extract&quot;&gt;extract&lt;/code&gt;); see &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;Section 9.9.1&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41ba912fbba3eb8b34c259aed583d396fabedb3e" translate="yes" xml:space="preserve">
          <source>Get timestamp subfield; see &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-EXTRACT&quot;&gt;Section 9.9.1&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2286e40b8a539e9f8b5d59de04327253f0b8e306" translate="yes" xml:space="preserve">
          <source>Gets all JSON items returned by JSON path for the specified JSON value and wraps result into an array.</source>
          <target state="translated">获取JSON路径返回的所有JSON值的JSON项目,并将结果包装成一个数组。</target>
        </trans-unit>
        <trans-unit id="69ca4727f266434b20f8a8cff91f85228790e89c" translate="yes" xml:space="preserve">
          <source>Gets all JSON items returned by JSON path for the specified JSON value.</source>
          <target state="translated">获取指定JSON值的JSON路径返回的所有JSON项目。</target>
        </trans-unit>
        <trans-unit id="f74211e2c2ac907544fec9e563a5484f2bc9bf8f" translate="yes" xml:space="preserve">
          <source>Gets the current status of the weak mode</source>
          <target state="translated">获取弱模式的当前状态。</target>
        </trans-unit>
        <trans-unit id="ffe1d3bb8fb75103abea9d97f24675a5e6f74f12" translate="yes" xml:space="preserve">
          <source>Gets the first JSON item returned by JSON path for the specified JSON value. Returns &lt;code&gt;NULL&lt;/code&gt; on no results.</source>
          <target state="translated">获取JSON路径返回的指定JSON值的第一个JSON项。如果没有结果，则返回 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1ea0c334189a899d918625993b37ead61ecb3937" translate="yes" xml:space="preserve">
          <source>GiST</source>
          <target state="translated">GiST</target>
        </trans-unit>
        <trans-unit id="2c7e841b76f37f5f1283940a7342c797bb3bd024" translate="yes" xml:space="preserve">
          <source>GiST Development Site &lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/&quot;&gt;http://www.sai.msu.su/~megera/postgres/gist/&lt;/a&gt;</source>
          <target state="translated">GiST开发站点&lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/&quot;&gt;http://www.sai.msu.su/~megera/postgres/gist/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="77dacc994e0a5c24fbb20b4e435e091dad5586f5" translate="yes" xml:space="preserve">
          <source>GiST Indexes: Built-in Operator Classes</source>
          <target state="translated">GiST索引。内建操作类</target>
        </trans-unit>
        <trans-unit id="22165dcd40882c92f600bb8d95e394930c229760" translate="yes" xml:space="preserve">
          <source>GiST Indexes: Examples</source>
          <target state="translated">GiST指数。例子</target>
        </trans-unit>
        <trans-unit id="cd4fa206206b0d9b9a4a09e74cdc45a9b7bac6d5" translate="yes" xml:space="preserve">
          <source>GiST Indexes: Extensibility</source>
          <target state="translated">GiST索引。可扩展性</target>
        </trans-unit>
        <trans-unit id="1e6e31ed1dfc0534ae7fa938c637d58b4def631a" translate="yes" xml:space="preserve">
          <source>GiST Indexes: Implementation</source>
          <target state="translated">GiST指数。执行情况</target>
        </trans-unit>
        <trans-unit id="494456433e65d5f6cf54c8e3f52f00d35404d83c" translate="yes" xml:space="preserve">
          <source>GiST and SP-GiST indexes can be created for table columns of range types. For instance, to create a GiST index:</source>
          <target state="translated">可以为范围类型的表列创建GiST和SP-GiST索引。例如,要创建一个GiST索引。</target>
        </trans-unit>
        <trans-unit id="64ccd39c4988da1de12e6185509ac6695e61212e" translate="yes" xml:space="preserve">
          <source>GiST index over &lt;code&gt;ltree&lt;/code&gt; (&lt;code&gt;gist_ltree_ops&lt;/code&gt; opclass): &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;@&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;@&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49924620a95a816339f17d76ecc000e2cecd8a90" translate="yes" xml:space="preserve">
          <source>GiST index over &lt;code&gt;ltree&lt;/code&gt;: &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;@&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;@&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;</source>
          <target state="translated">以上的GiST索引 &lt;code&gt;ltree&lt;/code&gt; ： &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;=&lt;/code&gt; ， &lt;code&gt;=&lt;/code&gt; ， &lt;code&gt;&amp;gt;=&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;@&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;@&lt;/code&gt; ， &lt;code&gt;@&lt;/code&gt; ， &lt;code&gt;~&lt;/code&gt; ， &lt;code&gt;?&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="693c5c0cbde228a43b08f1288fe686338587e0d2" translate="yes" xml:space="preserve">
          <source>GiST index over &lt;code&gt;ltree[]&lt;/code&gt; (&lt;code&gt;gist__ltree_ops&lt;/code&gt; opclass): &lt;code&gt;ltree[] &amp;lt;@ ltree&lt;/code&gt;, &lt;code&gt;ltree @&amp;gt; ltree[]&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17c380bccd59920d150dcf1776323ee944932357" translate="yes" xml:space="preserve">
          <source>GiST index over &lt;code&gt;ltree[]&lt;/code&gt;: &lt;code&gt;ltree[] &amp;lt;@ ltree&lt;/code&gt;, &lt;code&gt;ltree @&amp;gt; ltree[]&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;</source>
          <target state="translated">以上的GiST索引 &lt;code&gt;ltree[]&lt;/code&gt; ： &lt;code&gt;ltree[] &amp;lt;@ ltree&lt;/code&gt; ， &lt;code&gt;ltree @&amp;gt; ltree[]&lt;/code&gt; ， &lt;code&gt;@&lt;/code&gt; ， &lt;code&gt;~&lt;/code&gt; ， &lt;code&gt;?&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0d319a311ddbbf36d4e1fdb2142c71c77f7a27e3" translate="yes" xml:space="preserve">
          <source>GiST indexes additionally accept this parameter:</source>
          <target state="translated">GiST索引还可以接受这个参数。</target>
        </trans-unit>
        <trans-unit id="fd10e71b27221cbba626117e71058b4d0b5d0794" translate="yes" xml:space="preserve">
          <source>GiST indexes are also capable of optimizing &amp;ldquo;nearest-neighbor&amp;rdquo; searches, such as</source>
          <target state="translated">GiST索引还能够优化&amp;ldquo;最近邻居&amp;rdquo;搜索，例如</target>
        </trans-unit>
        <trans-unit id="52e06a8812b702e9e01b2b2a18cfa676aaed004f" translate="yes" xml:space="preserve">
          <source>GiST indexes are not a single kind of index, but rather an infrastructure within which many different indexing strategies can be implemented. Accordingly, the particular operators with which a GiST index can be used vary depending on the indexing strategy (the &lt;em&gt;operator class&lt;/em&gt;). As an example, the standard distribution of PostgreSQL includes GiST operator classes for several two-dimensional geometric data types, which support indexed queries using these operators:</source>
          <target state="translated">GiST索引不是单一的索引，而是可以在其中实施许多不同索引策略的基础结构。因此，可以与GiST索引一起使用的特定运算符随索引策略（&lt;em&gt;运算符类&lt;/em&gt;）的不同而不同。例如，PostgreSQL的标准发行版包括针对几种二维几何数据类型的GiST运算符类，它们支持使用这些运算符的索引查询：</target>
        </trans-unit>
        <trans-unit id="8444450d765d03c90597419731d461339d26e37a" translate="yes" xml:space="preserve">
          <source>GiST stands for Generalized Search Tree. It is a balanced, tree-structured access method, that acts as a base template in which to implement arbitrary indexing schemes. B-trees, R-trees and many other indexing schemes can be implemented in GiST.</source>
          <target state="translated">GiST是Generalized Search Tree的缩写。它是一种平衡的、树形结构的访问方法,它作为一个基础模板,可以实现任意的索引方案。B-树、R-树和许多其他索引方案都可以在GiST中实现。</target>
        </trans-unit>
        <trans-unit id="5819778898df55e3a762f0c5728b457970d72cae" translate="yes" xml:space="preserve">
          <source>Git</source>
          <target state="translated">Git</target>
        </trans-unit>
        <trans-unit id="b0f44dac1f3500cf2c64a5e96b25bdc72296caa1" translate="yes" xml:space="preserve">
          <source>Give a role a non-default setting of the &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt; parameter:</source>
          <target state="translated">为角色赋予&lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt;参数的非默认设置：</target>
        </trans-unit>
        <trans-unit id="0d339f7ddc04ed38d6c4f1627fd17d7b3c263479" translate="yes" xml:space="preserve">
          <source>Give a role a non-default, database-specific setting of the &lt;a href=&quot;runtime-config-client#GUC-CLIENT-MIN-MESSAGES&quot;&gt;client_min_messages&lt;/a&gt; parameter:</source>
          <target state="translated">为角色赋予&lt;a href=&quot;runtime-config-client#GUC-CLIENT-MIN-MESSAGES&quot;&gt;client_min_messages&lt;/a&gt;参数的非默认数据库特定设置：</target>
        </trans-unit>
        <trans-unit id="657b05bd06e4a30ca8560408b6cca3b16ee24c04" translate="yes" xml:space="preserve">
          <source>Give a role the ability to create other roles and new databases:</source>
          <target state="translated">赋予角色创建其他角色和新数据库的能力。</target>
        </trans-unit>
        <trans-unit id="7e461b397ac9e789e72233367d6e54d13bd1ea4f" translate="yes" xml:space="preserve">
          <source>Given an index entry &lt;code&gt;p&lt;/code&gt; and a query value &lt;code&gt;q&lt;/code&gt;, this function determines the index entry's &amp;ldquo;distance&amp;rdquo; from the query value. This function must be supplied if the operator class contains any ordering operators. A query using the ordering operator will be implemented by returning index entries with the smallest &amp;ldquo;distance&amp;rdquo; values first, so the results must be consistent with the operator's semantics. For a leaf index entry the result just represents the distance to the index entry; for an internal tree node, the result must be the smallest distance that any child entry could have.</source>
          <target state="translated">给定一个索引条目 &lt;code&gt;p&lt;/code&gt; 和一个查询值 &lt;code&gt;q&lt;/code&gt; ，此函数确定索引条目与查询值的&amp;ldquo;距离&amp;rdquo;。如果运算符类包含任何排序运算符，则必须提供此函数。使用排序运算符的查询将通过首先返回具有最小&amp;ldquo;距离&amp;rdquo;值的索引条目来实现，因此结果必须与运算符的语义一致。对于叶索引条目，结果仅表示到索引条目的距离；对于内部树节点，结果必须是任何子条目可能具有的最小距离。</target>
        </trans-unit>
        <trans-unit id="693396c0b50006bc8bf563a767c6df7376338535" translate="yes" xml:space="preserve">
          <source>Given an index entry &lt;code&gt;p&lt;/code&gt; and a query value &lt;code&gt;q&lt;/code&gt;, this function determines whether the index entry is &amp;ldquo;consistent&amp;rdquo; with the query; that is, could the predicate &amp;ldquo;&lt;code&gt;indexed_column&lt;/code&gt;&lt;code&gt;indexable_operator&lt;/code&gt;&lt;code&gt;q&lt;/code&gt;&amp;rdquo; be true for any row represented by the index entry? For a leaf index entry this is equivalent to testing the indexable condition, while for an internal tree node this determines whether it is necessary to scan the subtree of the index represented by the tree node. When the result is &lt;code&gt;true&lt;/code&gt;, a &lt;code&gt;recheck&lt;/code&gt; flag must also be returned. This indicates whether the predicate is certainly true or only possibly true. If &lt;code&gt;recheck&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; then the index has tested the predicate condition exactly, whereas if &lt;code&gt;recheck&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt; the row is only a candidate match. In that case the system will automatically evaluate the &lt;code&gt;indexable_operator&lt;/code&gt; against the actual row value to see if it is really a match. This convention allows GiST to support both lossless and lossy index structures.</source>
          <target state="translated">给定一个索引条目 &lt;code&gt;p&lt;/code&gt; 和一个查询值 &lt;code&gt;q&lt;/code&gt; ，此函数确定索引条目是否与查询&amp;ldquo;一致&amp;rdquo;；也就是说，谓词&amp;ldquo; &lt;code&gt;indexed_column&lt;/code&gt; &lt;code&gt;indexable_operator&lt;/code&gt; &lt;code&gt;q&lt;/code&gt; &amp;rdquo;对于由索引条目表示的任何行是否为真？对于叶索引条目，这等效于测试可索引条件，而对于内部树节点，这确定是否有必要扫描由树节点表示的索引的子树。当结果为 &lt;code&gt;true&lt;/code&gt; 时，还必须返回一个 &lt;code&gt;recheck&lt;/code&gt; 标志。这表明谓词是肯定的，还是仅可能是真的。如果 &lt;code&gt;recheck&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; 则索引已精确测试了谓词条件，而如果 &lt;code&gt;recheck&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt; ，则该行仅是候选匹配项。在那种情况下，系统将根据实际的行值自动评估 &lt;code&gt;indexable_operator&lt;/code&gt; ，以查看它是否真正匹配。该约定允许GiST支持无损和有损索引结构。</target>
        </trans-unit>
        <trans-unit id="e92d55ae3ac298e4b66632b1af221ac34e3be444" translate="yes" xml:space="preserve">
          <source>Given an index tuple and an indexed value, modifies the indicated attribute of the tuple so that it additionally represents the new value. If any modification was done to the tuple, &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">给定一个索引元组和一个索引值，修改元组的指示属性，使其另外表示新值。如果对元组进行了任何修改，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="769764fd5b04005314c3f8df7317ab69c5882b21" translate="yes" xml:space="preserve">
          <source>Given the cost of the plan, it is entirely reasonable that no JIT was used; the cost of JIT would have been bigger than the potential savings. Adjusting the cost limits will lead to JIT use:</source>
          <target state="translated">考虑到计划的成本,不使用联合运输工具是完全合理的;联合运输工具的成本将大于潜在的节约。调整费用限额将导致使用联合过渡期。</target>
        </trans-unit>
        <trans-unit id="37460509d9524c32ce3522fe588bb30e9b9a9e2c" translate="yes" xml:space="preserve">
          <source>Given the default configuration and only the first function existing, the first and second calls are insecure. Any user could intercept them by creating the second or third function. By matching the argument type exactly and using the &lt;code&gt;VARIADIC&lt;/code&gt; keyword, the third call is secure.</source>
          <target state="translated">给定默认配置，并且只有第一个功能存在，因此第一个和第二个调用是不安全的。任何用户都可以通过创建第二个或第三个函数来拦截它们。通过完全匹配参数类型并使用 &lt;code&gt;VARIADIC&lt;/code&gt; 关键字，第三次调用是安全的。</target>
        </trans-unit>
        <trans-unit id="40af5c52e4886430e556bb2588adddc7f3345e29" translate="yes" xml:space="preserve">
          <source>Given the sample data from the PostgreSQL tutorial (see &lt;a href=&quot;tutorial-sql-intro&quot;&gt;Section 2.1&lt;/a&gt;), this returns:</source>
          <target state="translated">给定PostgreSQL教程中的示例数据（请参阅&lt;a href=&quot;tutorial-sql-intro&quot;&gt;第2.1节&lt;/a&gt;），将返回：</target>
        </trans-unit>
        <trans-unit id="48862a4ac236aec67af11d9ca9afc2c469e5ae88" translate="yes" xml:space="preserve">
          <source>Gives syntax help on the specified SQL command. If &lt;code&gt;command&lt;/code&gt; is not specified, then psql will list all the commands for which syntax help is available. If &lt;code&gt;command&lt;/code&gt; is an asterisk (&lt;code&gt;*&lt;/code&gt;), then syntax help on all SQL commands is shown.</source>
          <target state="translated">提供有关指定SQL命令的语法帮助。如果未指定 &lt;code&gt;command&lt;/code&gt; ，则psql将列出所有可使用语法帮助的命令。如果 &lt;code&gt;command&lt;/code&gt; 是星号（ &lt;code&gt;*&lt;/code&gt; ），则会显示所有SQL命令的语法帮助。</target>
        </trans-unit>
        <trans-unit id="696e22e619af6c7115546ae99d980b04fd02c2c6" translate="yes" xml:space="preserve">
          <source>Gives the distance in statute miles between two points on the Earth's surface.</source>
          <target state="translated">给出地球表面两点之间的距离,单位为法制英里。</target>
        </trans-unit>
        <trans-unit id="b2e72630d76d2483c8fcffc2dffd1c7c6a52ab67" translate="yes" xml:space="preserve">
          <source>Global transaction identifier that was assigned to the transaction</source>
          <target state="translated">分配给交易的全球交易标识符;</target>
        </trans-unit>
        <trans-unit id="31e73c02a46d40c2d70edd740f19c8958fbb213c" translate="yes" xml:space="preserve">
          <source>Global validity checks require extra thought under non-serializable MVCC. For example, a banking application might wish to check that the sum of all credits in one table equals the sum of debits in another table, when both tables are being actively updated. Comparing the results of two successive &lt;code&gt;SELECT sum(...)&lt;/code&gt; commands will not work reliably in Read Committed mode, since the second query will likely include the results of transactions not counted by the first. Doing the two sums in a single repeatable read transaction will give an accurate picture of only the effects of transactions that committed before the repeatable read transaction started &amp;mdash; but one might legitimately wonder whether the answer is still relevant by the time it is delivered. If the repeatable read transaction itself applied some changes before trying to make the consistency check, the usefulness of the check becomes even more debatable, since now it includes some but not all post-transaction-start changes. In such cases a careful person might wish to lock all tables needed for the check, in order to get an indisputable picture of current reality. A &lt;code&gt;SHARE&lt;/code&gt; mode (or higher) lock guarantees that there are no uncommitted changes in the locked table, other than those of the current transaction.</source>
          <target state="translated">对于不可序列化的MVCC，全局有效性检查需要额外的考虑。例如，当两个表都被主动更新时，银行应用程序可能希望检查一个表中的所有贷项总和等于另一表中的借项总和。比较两个连续的 &lt;code&gt;SELECT sum(...)&lt;/code&gt; 的结果命令将无法在&amp;ldquo;读取已提交&amp;rdquo;模式下可靠地工作，因为第二个查询可能包含第一个查询未计算的事务结果。在单个可重复读取事务中进行两个总和将仅给出可重复读取事务开始之前提交的事务的效果的准确图片-但您可能会合理地怀疑答案交付之时是否仍然有意义。如果可重复读事务本身在尝试进行一致性检查之前应用了一些更改，则该检查的用途变得更具争议性，因为现在它包括一些但不是全部的事务开始后更改。在这种情况下，细心的人可能希望锁定检查所需的所有表，以便对当前现实有一个无可争辩的印象。一个 &lt;code&gt;SHARE&lt;/code&gt; 模式（或更高版本）锁定可确保锁定表中没有未提交的更改（当前事务除外）。</target>
        </trans-unit>
        <trans-unit id="7427cf697be16a4ec1d916910128a59d920125e7" translate="yes" xml:space="preserve">
          <source>Glossary</source>
          <target state="translated">Glossary</target>
        </trans-unit>
        <trans-unit id="4a647f902e0d765ea12195a96e4829f8b1e8aa9f" translate="yes" xml:space="preserve">
          <source>Good Practices</source>
          <target state="translated">良好做法</target>
        </trans-unit>
        <trans-unit id="3c09ec28f005ae7495ffdeada3d59d9447d92430" translate="yes" xml:space="preserve">
          <source>Good results will show most (&amp;gt;90%) individual timing calls take less than one microsecond. Average per loop overhead will be even lower, below 100 nanoseconds. This example from an Intel i7-860 system using a TSC clock source shows excellent performance:</source>
          <target state="translated">良好的结果将显示大多数（&amp;gt; 90％）单独的计时呼叫花费不到一微秒的时间。每个循环的平均开销将更低，低于100纳秒。来自使用TSC时钟源的Intel i7-860系统的此示例显示了出色的性能：</target>
        </trans-unit>
        <trans-unit id="c02329c48f348eb633688f33c499b18b31dcb947" translate="yes" xml:space="preserve">
          <source>Grant</source>
          <target state="translated">Grant</target>
        </trans-unit>
        <trans-unit id="01af961ffadccd5726ec885717dd08dd99e478cf" translate="yes" xml:space="preserve">
          <source>Grant SELECT privilege to everyone for all tables (and views) you subsequently create in schema &lt;code&gt;myschema&lt;/code&gt;, and allow role &lt;code&gt;webuser&lt;/code&gt; to INSERT into them too:</source>
          <target state="translated">向您随后在模式 &lt;code&gt;myschema&lt;/code&gt; 中创建的所有表（和视图）的所有人授予SELECT特权，并允许角色 &lt;code&gt;webuser&lt;/code&gt; 也向其中插入：</target>
        </trans-unit>
        <trans-unit id="24617f7e457da3734cfeda27633b2aa731a9c9ef" translate="yes" xml:space="preserve">
          <source>Grant all available privileges to user &lt;code&gt;manuel&lt;/code&gt; on view &lt;code&gt;kinds&lt;/code&gt;:</source>
          <target state="translated">授予所有可用的特权用户 &lt;code&gt;manuel&lt;/code&gt; 在视图 &lt;code&gt;kinds&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6e182dc9d9691657bc39b554f5fd47996c873086" translate="yes" xml:space="preserve">
          <source>Grant all of the privileges available for the object's type. The &lt;code&gt;PRIVILEGES&lt;/code&gt; key word is optional in PostgreSQL, though it is required by strict SQL.</source>
          <target state="translated">授予对象类型可用的所有特权。该 &lt;code&gt;PRIVILEGES&lt;/code&gt; 关键字在PostgreSQL里是可选的，但是严格的SQL要求。</target>
        </trans-unit>
        <trans-unit id="bb6ece16050b16e5f45fddd08ab0ab254c3c1353" translate="yes" xml:space="preserve">
          <source>Grant all privileges on all views in schema &lt;code&gt;public&lt;/code&gt; to role &lt;code&gt;webuser&lt;/code&gt;:</source>
          <target state="translated">向角色 &lt;code&gt;webuser&lt;/code&gt; 授予 &lt;code&gt;public&lt;/code&gt; 模式中所有视图的所有特权：</target>
        </trans-unit>
        <trans-unit id="269d15aac0905b9feb98dc13ab02754db1782270" translate="yes" xml:space="preserve">
          <source>Grant insert privilege to all users on table &lt;code&gt;films&lt;/code&gt;:</source>
          <target state="translated">向所有用户提供插入 &lt;code&gt;films&lt;/code&gt; 插入特权：</target>
        </trans-unit>
        <trans-unit id="ba27670ed37d6c78d0b14c4148d50cc7aab110fa" translate="yes" xml:space="preserve">
          <source>Grant membership in role &lt;code&gt;admins&lt;/code&gt; to user &lt;code&gt;joe&lt;/code&gt;:</source>
          <target state="translated">将角色 &lt;code&gt;admins&lt;/code&gt; 成员资格授予用户 &lt;code&gt;joe&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1f88fd823ea9c3dd2200a42432c3efa9ef706298" translate="yes" xml:space="preserve">
          <source>Granting permission on a table does not automatically extend permissions to any sequences used by the table, including sequences tied to &lt;code&gt;SERIAL&lt;/code&gt; columns. Permissions on sequences must be set separately.</source>
          <target state="translated">授予表权限不会自动将权限扩展到该表使用的任何序列，包括与 &lt;code&gt;SERIAL&lt;/code&gt; 列绑定的序列。序列权限必须单独设置。</target>
        </trans-unit>
        <trans-unit id="599294f23ef04a992bc69ba465066344c3c7cf34" translate="yes" xml:space="preserve">
          <source>Greater than</source>
          <target state="translated">大于</target>
        </trans-unit>
        <trans-unit id="a2919540599e9df0beb579ca8d46bdc142657611" translate="yes" xml:space="preserve">
          <source>Greater than or equal to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b3dd5feef716f81ba8f5a6b4f110f37be61a79c" translate="yes" xml:space="preserve">
          <source>Greater-than comparison</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7c7faa35b86c7d8f2aa278406d57686d0e76cab" translate="yes" xml:space="preserve">
          <source>Greater-than operator</source>
          <target state="translated">大于运算符</target>
        </trans-unit>
        <trans-unit id="6be50f6e20e368774e1648e96e60824f64284093" translate="yes" xml:space="preserve">
          <source>Greater-than-or-equal-to comparison</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b0cd62dcaabb41d866e961c21030484cdf15a5a" translate="yes" xml:space="preserve">
          <source>Greater-than-or-equal-to operator</source>
          <target state="translated">大于或等于运算符</target>
        </trans-unit>
        <trans-unit id="016d8dc207e4a957a80df31d268b5c8c6a8e9e53" translate="yes" xml:space="preserve">
          <source>Greatest common divisor (the largest positive number that divides both inputs with no remainder); returns &lt;code id=&quot;0&quot;&gt;0&lt;/code&gt; if both inputs are zero; available for &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;bigint&lt;/code&gt;, and &lt;code&gt;numeric&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59d5f5b13f13f6d5e8e88a5a92e137f7d64b2954" translate="yes" xml:space="preserve">
          <source>Greek</source>
          <target state="translated">Greek</target>
        </trans-unit>
        <trans-unit id="fafd8001d43d87515ae86352c97c37616a4d6762" translate="yes" xml:space="preserve">
          <source>Greenwich Mean Time</source>
          <target state="translated">格林尼治时间</target>
        </trans-unit>
        <trans-unit id="cf098c159fa893be7ea9fe00bfc173e418306bad" translate="yes" xml:space="preserve">
          <source>Gregorian years AD 1&amp;ndash;99 can be entered by using 4 digits with leading zeros (e.g., &lt;code&gt;0099&lt;/code&gt; is AD 99).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6261b12bce7847fa9426739910b4246568401661" translate="yes" xml:space="preserve">
          <source>Gregorian years AD 1-99 can be entered by using 4 digits with leading zeros (e.g., &lt;code&gt;0099&lt;/code&gt; is AD 99).</source>
          <target state="translated">可以使用4个带前导零的数字来输入公历公元1-99（例如， &lt;code&gt;0099&lt;/code&gt; 是公元99）。</target>
        </trans-unit>
        <trans-unit id="2b13ec9d057eee3b8bf047437042e0b54f1f6425" translate="yes" xml:space="preserve">
          <source>Grouping operations are used in conjunction with grouping sets (see &lt;a href=&quot;queries-table-expressions#QUERIES-GROUPING-SETS&quot;&gt;Section 7.2.4&lt;/a&gt;) to distinguish result rows. The arguments to the &lt;code&gt;GROUPING&lt;/code&gt; operation are not actually evaluated, but they must match exactly expressions given in the &lt;code&gt;GROUP BY&lt;/code&gt; clause of the associated query level. Bits are assigned with the rightmost argument being the least-significant bit; each bit is 0 if the corresponding expression is included in the grouping criteria of the grouping set generating the result row, and 1 if it is not. For example:</source>
          <target state="translated">分组操作与分组集（请参阅&lt;a href=&quot;queries-table-expressions#QUERIES-GROUPING-SETS&quot;&gt;第7.2.4节&lt;/a&gt;）结合使用以区分结果行。 &lt;code&gt;GROUPING&lt;/code&gt; 操作的参数实际上并未进行评估，但它们必须与关联的查询级别的 &lt;code&gt;GROUP BY&lt;/code&gt; 子句中给出的表达式完全匹配。位分配时，最右边的参数是最低有效位；如果相应的表达式包含在生成结果行的分组集的分组条件中，则每个位为0，否则为1。例如：</target>
        </trans-unit>
        <trans-unit id="88d7c69cfe151f010dd11e55984fa5a2e4485f4b" translate="yes" xml:space="preserve">
          <source>Grouping without aggregate expressions effectively calculates the set of distinct values in a column. This can also be achieved using the &lt;code&gt;DISTINCT&lt;/code&gt; clause (see &lt;a href=&quot;queries-select-lists#QUERIES-DISTINCT&quot;&gt;Section 7.3.3&lt;/a&gt;).</source>
          <target state="translated">没有聚合表达式的分组有效地计算了列中一组不同的值。这也可以使用 &lt;code&gt;DISTINCT&lt;/code&gt; 子句来实现（请参见&lt;a href=&quot;queries-select-lists#QUERIES-DISTINCT&quot;&gt;第7.3.3节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="7cf184f4c67ad58283ecb19349720b0cae756829" translate="yes" xml:space="preserve">
          <source>H</source>
          <target state="translated">H</target>
        </trans-unit>
        <trans-unit id="b82d3603eb93c98eb825eb4e6b01ee350ff3fb6d" translate="yes" xml:space="preserve">
          <source>HASH version number</source>
          <target state="translated">HASH版本号</target>
        </trans-unit>
        <trans-unit id="1cc155b76768b5b5fb2f3643a0744204e68a9ccc" translate="yes" xml:space="preserve">
          <source>HBA</source>
          <target state="translated">HBA</target>
        </trans-unit>
        <trans-unit id="0feddc013d3db0d214cc286a21a9e52cacbc17e4" translate="yes" xml:space="preserve">
          <source>HMAC: Keyed-Hashing for Message Authentication.</source>
          <target state="translated">HMAC。信息认证的密钥散列法。</target>
        </trans-unit>
        <trans-unit id="06833bde6c3138c525040c232dbadac4725bac88" translate="yes" xml:space="preserve">
          <source>HOT</source>
          <target state="translated">HOT</target>
        </trans-unit>
        <trans-unit id="c305ce22fa1ddad5ff6a9a241e6067a9f35cad67" translate="yes" xml:space="preserve">
          <source>HP-UX</source>
          <target state="translated">HP-UX</target>
        </trans-unit>
        <trans-unit id="61a2a1882fc631d64e7d30ef57cec31971ea2c09" translate="yes" xml:space="preserve">
          <source>Had there been MCV lists for the two columns, &lt;code&gt;eqjoinsel&lt;/code&gt; would have used direct comparison of the MCV lists to determine the join selectivity within the part of the column populations represented by the MCVs. The estimate for the remainder of the populations follows the same approach shown here.</source>
          <target state="translated">如果两列都有MCV列表，则 &lt;code&gt;eqjoinsel&lt;/code&gt; 将使用MCV列表的直接比较来确定MCV代表的部分列总体内的连接选择性。其余人口的估计数采用此处所示的相同方法。</target>
        </trans-unit>
        <trans-unit id="4bf7a6d465bc019e543ce8b66fbf5cd1235516a8" translate="yes" xml:space="preserve">
          <source>Had we not supplied values for all the subfields of the column, the remaining subfields would have been filled with null values.</source>
          <target state="translated">如果我们没有为该列的所有子字段提供值,那么剩余的子字段就会被填充为空值。</target>
        </trans-unit>
        <trans-unit id="e0c8e4e26ef951b2d257ad48905d56d36c233bc8" translate="yes" xml:space="preserve">
          <source>Handling of Invalid or Ambiguous Timestamps</source>
          <target state="translated">处理无效或不明确的时间戳。</target>
        </trans-unit>
        <trans-unit id="56d01e9677df53b4a2c4ef118ff77a201dd06a2e" translate="yes" xml:space="preserve">
          <source>Has a replication origin been configured in the current session?</source>
          <target state="translated">是否在当前会话中配置了复制原点?</target>
        </trans-unit>
        <trans-unit id="3127cc395c91e262a7a0864c40a7527573818c9c" translate="yes" xml:space="preserve">
          <source>Has the constraint been validated? Currently, can only be false for foreign keys and CHECK constraints</source>
          <target state="translated">约束是否已被验证?目前,对于外键和CHECK约束条件只能为false。</target>
        </trans-unit>
        <trans-unit id="3dc36e4e0152a0239de102d530bd0c47b3d9e3a1" translate="yes" xml:space="preserve">
          <source>Hash Partitioning</source>
          <target state="translated">散列分区</target>
        </trans-unit>
        <trans-unit id="90507c1a5721f22f49292627451907b5c9b469f4" translate="yes" xml:space="preserve">
          <source>Hash functions &lt;code&gt;hash&lt;/code&gt;, &lt;code&gt;hash_murmur2&lt;/code&gt; and &lt;code&gt;hash_fnv1a&lt;/code&gt; accept an input value and an optional seed parameter. In case the seed isn't provided the value of &lt;code&gt;:default_seed&lt;/code&gt; is used, which is initialized randomly unless set by the command-line &lt;code&gt;-D&lt;/code&gt; option. Hash functions can be used to scatter the distribution of random functions such as &lt;code&gt;random_zipfian&lt;/code&gt; or &lt;code&gt;random_exponential&lt;/code&gt;. For instance, the following pgbench script simulates possible real world workload typical for social media and blogging platforms where few accounts generate excessive load:</source>
          <target state="translated">哈希函数 &lt;code&gt;hash&lt;/code&gt; ， &lt;code&gt;hash_murmur2&lt;/code&gt; 和 &lt;code&gt;hash_fnv1a&lt;/code&gt; 接受输入值和可选的种子参数。如果未提供种子，则使用 &lt;code&gt;:default_seed&lt;/code&gt; 的值，除非通过命令行 &lt;code&gt;-D&lt;/code&gt; 选项设置，否则它将随机初始化。哈希函数可用于分散随机函数的分布，例如 &lt;code&gt;random_zipfian&lt;/code&gt; 或 &lt;code&gt;random_exponential&lt;/code&gt; 。例如，以下pgbench脚本模拟了社交媒体和博客平台（通常很少有帐户会产生过多负载）的典型现实工作负载：</target>
        </trans-unit>
        <trans-unit id="cc1cfbcfc5781fb19f027f2126a6d7e099a4d8b1" translate="yes" xml:space="preserve">
          <source>Hash indexes</source>
          <target state="translated">哈希指数</target>
        </trans-unit>
        <trans-unit id="f9f75839548d1e6a1a51f586eb631d2c4a104ff8" translate="yes" xml:space="preserve">
          <source>Hash indexes can only handle simple equality comparisons. The query planner will consider using a hash index whenever an indexed column is involved in a comparison using the &lt;code&gt;=&lt;/code&gt; operator. The following command is used to create a hash index:</source>
          <target state="translated">哈希索引只能处理简单的相等比较。每当使用 &lt;code&gt;=&lt;/code&gt; 运算符进行比较时，如果查询中涉及索引列，查询计划器将考虑使用哈希索引。以下命令用于创建哈希索引：</target>
        </trans-unit>
        <trans-unit id="956456c077f843c8529aa0f90522e368a7e51001" translate="yes" xml:space="preserve">
          <source>Hash-based operations are generally more sensitive to memory availability than equivalent sort-based operations. The memory available for hash tables is computed by multiplying &lt;code&gt;work_mem&lt;/code&gt; by &lt;code&gt;hash_mem_multiplier&lt;/code&gt;. This makes it possible for hash-based operations to use an amount of memory that exceeds the usual &lt;code&gt;work_mem&lt;/code&gt; base amount.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea4ccce2369daab1022355aaafd39217be056ac4" translate="yes" xml:space="preserve">
          <source>Hashes/sec</source>
          <target state="translated">Hashes/sec</target>
        </trans-unit>
        <trans-unit id="fa2065c836a17176e9e4314cc0f9ae6d0e4ea762" translate="yes" xml:space="preserve">
          <source>Having created this trigger, any change in &lt;code&gt;title&lt;/code&gt; or &lt;code&gt;body&lt;/code&gt; will automatically be reflected into &lt;code&gt;tsv&lt;/code&gt;, without the application having to worry about it.</source>
          <target state="translated">创建此触发器后， &lt;code&gt;title&lt;/code&gt; 或 &lt;code&gt;body&lt;/code&gt; 任何更改都将自动反映到 &lt;code&gt;tsv&lt;/code&gt; 中，而应用程序不必担心。</target>
        </trans-unit>
        <trans-unit id="349ced815f5c84c9f5228e606a1b7ba0c2ddee06" translate="yes" xml:space="preserve">
          <source>Having defined the types, we can use them to create tables:</source>
          <target state="translated">在定义了类型之后,我们可以使用它们来创建表。</target>
        </trans-unit>
        <trans-unit id="2723c816765ee34102b273de3e99b00ba0f56303" translate="yes" xml:space="preserve">
          <source>Having the bloom index defined on the table is better than btree in handling this type of search:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="847116884ad55b09c96b3c4dc05ec99dcc5ec687" translate="yes" xml:space="preserve">
          <source>Header extension area length</source>
          <target state="translated">页眉扩展区域长度</target>
        </trans-unit>
        <trans-unit id="977169a2f56615065497cd1735f54129679d50ec" translate="yes" xml:space="preserve">
          <source>Heap</source>
          <target state="translated">Heap</target>
        </trans-unit>
        <trans-unit id="e10aa6b979969f7c629b2451c2c2a904b3d450a7" translate="yes" xml:space="preserve">
          <source>Heap-Only Tuples</source>
          <target state="translated">只堆的图元组</target>
        </trans-unit>
        <trans-unit id="348d00693e12bc983bd092677b90434b5a4d869e" translate="yes" xml:space="preserve">
          <source>Hebrew</source>
          <target state="translated">Hebrew</target>
        </trans-unit>
        <trans-unit id="0107076effd18727f0d6bde8cfc48a85171576c5" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;*&lt;/code&gt; is a shorthand for &amp;ldquo;all columns&amp;rdquo;. &lt;a href=&quot;#ftn.id-1.4.4.6.2.10&quot;&gt;&lt;sup id=&quot;id-1.4.4.6.2.10&quot;&gt;[2]&lt;/sup&gt;&lt;/a&gt; So the same result would be had with:</source>
          <target state="translated">这里 &lt;code&gt;*&lt;/code&gt; 是&amp;ldquo;所有列&amp;rdquo;的简写。&lt;a href=&quot;#ftn.id-1.4.4.6.2.10&quot;&gt;&lt;sup id=&quot;id-1.4.4.6.2.10&quot;&gt;[2]&lt;/sup&gt;&lt;/a&gt;因此，使用以下方法可获得相同的结果：</target>
        </trans-unit>
        <trans-unit id="4c0298ee7318c32798634cdbf2dfdaaab57a634f" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;ANY&lt;/code&gt; can be considered either as introducing a subquery, or as being an aggregate function, if the subquery returns one row with a Boolean value. Thus the standard name cannot be given to these aggregates.</source>
          <target state="translated">这里 &lt;code&gt;ANY&lt;/code&gt; 既可以视为引入子查询，或者作为聚合函数，如果子查询返回一行与一个布尔值。因此，无法为这些聚合指定标准名称。</target>
        </trans-unit>
        <trans-unit id="fa4131a740f8662a6e1405a124ef5fe7cf873c01" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;expression&lt;/code&gt; is an arbitrary value expression that is evaluated for all rows. A set of rows for which all the expressions are equal are considered duplicates, and only the first row of the set is kept in the output. Note that the &amp;ldquo;first row&amp;rdquo; of a set is unpredictable unless the query is sorted on enough columns to guarantee a unique ordering of the rows arriving at the &lt;code&gt;DISTINCT&lt;/code&gt; filter. (&lt;code&gt;DISTINCT ON&lt;/code&gt; processing occurs after &lt;code&gt;ORDER BY&lt;/code&gt; sorting.)</source>
          <target state="translated">这里的 &lt;code&gt;expression&lt;/code&gt; 是一个针对所有行求值的任意值表达式。一组所有表达式均相等的行被视为重复行，并且仅该行的第一行保留在输出中。请注意，除非查询在足够的列上排序以保证到达 &lt;code&gt;DISTINCT&lt;/code&gt; 过滤器的行的唯一顺序，否则集合的&amp;ldquo;第一行&amp;rdquo;是不可预测的。（ &lt;code&gt;DISTINCT ON&lt;/code&gt; 处理发生在 &lt;code&gt;ORDER BY&lt;/code&gt; 排序之后。）</target>
        </trans-unit>
        <trans-unit id="32e70bf63bd6299c1b514b324e5813b6785f48fc" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;sum&lt;/code&gt; is an aggregate function that computes a single value over the entire group. More information about the available aggregate functions can be found in &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.20&lt;/a&gt;.</source>
          <target state="translated">这里 &lt;code&gt;sum&lt;/code&gt; 是一个聚合函数，可计算整个组中的单个值。有关可用的聚合函数的更多信息，请参见&lt;a href=&quot;functions-aggregate&quot;&gt;第9.20节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8d1138b514ed4337e7415d5a15b6a232b2308f96" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;sum&lt;/code&gt; is an aggregate function that computes a single value over the entire group. More information about the available aggregate functions can be found in &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.21&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c74e599f4f4cd10f806357bb4a577d879a636f92" translate="yes" xml:space="preserve">
          <source>Here again, the result row ordering might vary. You can ensure consistent results by using &lt;code&gt;DISTINCT&lt;/code&gt; and &lt;code&gt;ORDER BY&lt;/code&gt; together: &lt;a href=&quot;#ftn.id-1.4.4.6.6.7&quot;&gt;&lt;sup id=&quot;id-1.4.4.6.6.7&quot;&gt;[3]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">同样，结果行的顺序可能会有所不同。通过将 &lt;code&gt;DISTINCT&lt;/code&gt; 和 &lt;code&gt;ORDER BY&lt;/code&gt; 一起使用，可以确保结果一致：&lt;a href=&quot;#ftn.id-1.4.4.6.6.7&quot;&gt;&lt;sup id=&quot;id-1.4.4.6.6.7&quot;&gt;[3]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9361fe781c0dc9515f2a15d806649d45978ad2ff" translate="yes" xml:space="preserve">
          <source>Here are a few more operating-system-specific suggestions. (In each case be sure to use the proper installation directory and user name where we show generic values.)</source>
          <target state="translated">这里有一些更多的操作系统特定的建议。(在每一种情况下,请确保使用正确的安装目录和用户名,我们显示的是通用值。)</target>
        </trans-unit>
        <trans-unit id="33c629349369b081c96a4709bd4c05ca3d526b68" translate="yes" xml:space="preserve">
          <source>Here are examples using &lt;code&gt;width&lt;/code&gt; fields and the &lt;code&gt;-&lt;/code&gt; flag:</source>
          <target state="translated">以下是使用 &lt;code&gt;width&lt;/code&gt; 字段和 &lt;code&gt;-&lt;/code&gt; 标志的示例：</target>
        </trans-unit>
        <trans-unit id="3f1ddfcdc9a3ca5369958338ec3215bfb4261c95" translate="yes" xml:space="preserve">
          <source>Here are examples using &lt;em&gt;&lt;code&gt;width&lt;/code&gt;&lt;/em&gt; fields and the &lt;code&gt;-&lt;/code&gt; flag:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e1f296e08c37893cc7499c23d5ef526f191a997" translate="yes" xml:space="preserve">
          <source>Here are some example collations that might be created:</source>
          <target state="translated">以下是一些可能创建的整理示例。</target>
        </trans-unit>
        <trans-unit id="794bf261c0ef6d9f03e6ee073f42ca9e62437531" translate="yes" xml:space="preserve">
          <source>Here are some examples for the Norwegian language:</source>
          <target state="translated">下面是一些挪威语的例子。</target>
        </trans-unit>
        <trans-unit id="aedfd7af6c8c45fb8ea4b749385a6c955d7ebd4b" translate="yes" xml:space="preserve">
          <source>Here are some examples of &lt;code&gt;WHERE&lt;/code&gt; clauses:</source>
          <target state="translated">以下是 &lt;code&gt;WHERE&lt;/code&gt; 子句的一些示例：</target>
        </trans-unit>
        <trans-unit id="2b46ad535b1f1605c8d8b383d4b83d313d3c5c39" translate="yes" xml:space="preserve">
          <source>Here are some examples of full text search:</source>
          <target state="translated">下面是一些全文检索的例子。</target>
        </trans-unit>
        <trans-unit id="59581a37d8149d77f6e2121b432ef3ab5471d652" translate="yes" xml:space="preserve">
          <source>Here are some examples of path matching:</source>
          <target state="translated">下面是一些路径匹配的例子。</target>
        </trans-unit>
        <trans-unit id="081304796cf08884f88e8e57322d960864d34d64" translate="yes" xml:space="preserve">
          <source>Here are some examples of the basic format conversions:</source>
          <target state="translated">下面是一些基本格式转换的例子。</target>
        </trans-unit>
        <trans-unit id="6671c9ef7af5c4291212558669b68a47697a4f97" translate="yes" xml:space="preserve">
          <source>Here are some examples of the proper syntax for inserting and updating composite columns. First, inserting or updating a whole column:</source>
          <target state="translated">下面举例说明插入和更新复合列的正确语法。首先,插入或更新一整列。</target>
        </trans-unit>
        <trans-unit id="0931022beea83b3afc095873234631b7243eeca4" translate="yes" xml:space="preserve">
          <source>Here are some examples:</source>
          <target state="translated">下面是一些例子。</target>
        </trans-unit>
        <trans-unit id="cff6bd1f9746e782ec9405f845ffac129954f75a" translate="yes" xml:space="preserve">
          <source>Here are some suggestions about the easiest ways to perform common tasks when updating catalog data files.</source>
          <target state="translated">以下是关于更新目录数据文件时执行常见任务的最简单方法的一些建议。</target>
        </trans-unit>
        <trans-unit id="8d395c7f381e1a472cda6f6e9e7b568dac052ead" translate="yes" xml:space="preserve">
          <source>Here are some trivial examples to help you get started. For more information and examples, see &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc.html&quot;&gt;Section 37.3&lt;/a&gt;.</source>
          <target state="translated">以下是一些简单的示例，可帮助您入门。有关更多信息和示例，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc.html&quot;&gt;第37.3节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="26b8e6990652910b8bb15ce27b2a3afd5fd095c9" translate="yes" xml:space="preserve">
          <source>Here are some trivial examples to help you get started. For more information and examples, see &lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc.html&quot;&gt;Section 37.3&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="211fc895cd2c281ef748e752305609850c1006cd" translate="yes" xml:space="preserve">
          <source>Here are some usage examples:</source>
          <target state="translated">下面是一些使用实例。</target>
        </trans-unit>
        <trans-unit id="869c324dd483307e5d715a3f86abbbcd015bfd60" translate="yes" xml:space="preserve">
          <source>Here are two complete examples:</source>
          <target state="translated">这里有两个完整的例子。</target>
        </trans-unit>
        <trans-unit id="461b806fbebb6f513c6608122e9ae50853cfb34f" translate="yes" xml:space="preserve">
          <source>Here are two simple examples of defining composite types:</source>
          <target state="translated">下面是定义复合类型的两个简单例子。</target>
        </trans-unit>
        <trans-unit id="24ca8b33236bc0d0ef50e2dd43fb66e04162b483" translate="yes" xml:space="preserve">
          <source>Here is a complete example:</source>
          <target state="translated">下面是一个完整的例子。</target>
        </trans-unit>
        <trans-unit id="879a2b3e6157baeae30fe41038c69a70091e7ab2" translate="yes" xml:space="preserve">
          <source>Here is a concatenation of two values of unspecified types:</source>
          <target state="translated">这里是两个未指定类型的值的连接。</target>
        </trans-unit>
        <trans-unit id="cc7d83360ed38ff4e831e43a35b15e111bd3cccc" translate="yes" xml:space="preserve">
          <source>Here is a more complete example of bloom index definition and usage, as well as a comparison with equivalent btree indexes. The bloom index is considerably smaller than the btree index, and can perform better.</source>
          <target state="translated">下面以一个比较完整的例子来说明bloom索引的定义和使用方法,以及与同等btree索引的比较。bloom 指数比 btree 指数小得多,可以表现得更好。</target>
        </trans-unit>
        <trans-unit id="5f6e374336fa7e724d2419753cd63165e6b67b04" translate="yes" xml:space="preserve">
          <source>Here is a more complex example: &lt;code&gt;to_timestamp('15:12:02.020.001230', 'HH24:MI:SS.MS.US')&lt;/code&gt; is 15 hours, 12 minutes, and 2 seconds + 20 milliseconds + 1230 microseconds = 2.021230 seconds.</source>
          <target state="translated">这是一个更复杂的示例： &lt;code&gt;to_timestamp('15:12:02.020.001230', 'HH24:MI:SS.MS.US')&lt;/code&gt; 是15小时12分钟2秒+ 20毫秒+ 1230微秒= 2.021230秒。</target>
        </trans-unit>
        <trans-unit id="4b2dfe5ad07694de5eeb1cdf20070a788ef8e7be" translate="yes" xml:space="preserve">
          <source>Here is a sample of data suitable for copying into a table from &lt;code&gt;STDIN&lt;/code&gt;:</source>
          <target state="translated">这是适合从 &lt;code&gt;STDIN&lt;/code&gt; 复制到表中的数据示例：</target>
        </trans-unit>
        <trans-unit id="ea724b816190320574ae29c6484ba706b02e562b" translate="yes" xml:space="preserve">
          <source>Here is a simple example:</source>
          <target state="translated">下面是一个简单的例子。</target>
        </trans-unit>
        <trans-unit id="79fce6a010075477b9d4f3d2b7d0892550a64ad8" translate="yes" xml:space="preserve">
          <source>Here is a snippet of a log file generated in a single-client run:</source>
          <target state="translated">这里是单客户端运行中生成的日志文件的一个片段。</target>
        </trans-unit>
        <trans-unit id="5a5fc7880a4ea236d1b3bb1d32e27412d9d31338" translate="yes" xml:space="preserve">
          <source>Here is a trivial example, just to show what the output looks like:</source>
          <target state="translated">下面是一个微不足道的例子,只是为了展示输出是什么样子的。</target>
        </trans-unit>
        <trans-unit id="196e7b38bd23094a34f08fd4e1d56d0de9737199" translate="yes" xml:space="preserve">
          <source>Here is an example for a search+bind configuration that uses &lt;code&gt;ldapsearchfilter&lt;/code&gt; instead of &lt;code&gt;ldapsearchattribute&lt;/code&gt; to allow authentication by user ID or email address:</source>
          <target state="translated">这是使用 &lt;code&gt;ldapsearchfilter&lt;/code&gt; 而不是 &lt;code&gt;ldapsearchattribute&lt;/code&gt; 允许通过用户ID或电子邮件地址进行身份验证的搜索+绑定配置的示例：</target>
        </trans-unit>
        <trans-unit id="adb407aa80bcb23407a6343cd3fb06a44aaa7159" translate="yes" xml:space="preserve">
          <source>Here is an example for a search+bind configuration that uses DNS SRV discovery to find the host name(s) and port(s) for the LDAP service for the domain name &lt;code&gt;example.net&lt;/code&gt;:</source>
          <target state="translated">这是一个使用DNS SRV发现来查找域名 &lt;code&gt;example.net&lt;/code&gt; 的LDAP服务的主机名和端口的搜索+绑定配置的示例：</target>
        </trans-unit>
        <trans-unit id="8294bedf7f93c4debbc985ac5b71d91485ccb87a" translate="yes" xml:space="preserve">
          <source>Here is an example for a search+bind configuration:</source>
          <target state="translated">下面是一个搜索+绑定配置的例子。</target>
        </trans-unit>
        <trans-unit id="b1012c91578d9866c1a1a935ccf5f74b1c398069" translate="yes" xml:space="preserve">
          <source>Here is an example for a simple-bind LDAP configuration:</source>
          <target state="translated">下面是一个简单绑定LDAP配置的例子。</target>
        </trans-unit>
        <trans-unit id="1e2a8eb0839de265c32ba8726c7fb8ce612f9ebc" translate="yes" xml:space="preserve">
          <source>Here is an example of a dictionary definition using the &lt;code&gt;simple&lt;/code&gt; template:</source>
          <target state="translated">这是使用 &lt;code&gt;simple&lt;/code&gt; 模板的字典定义的示例：</target>
        </trans-unit>
        <trans-unit id="d6c310d42c6ff4f581c1e303b9eef10bb403ca6c" translate="yes" xml:space="preserve">
          <source>Here is an example of a function with an ordinality column added:</source>
          <target state="translated">下面是一个添加了序数列的函数的例子。</target>
        </trans-unit>
        <trans-unit id="39d9a1ec97da0de0b2ebe001d89411c194d0136a" translate="yes" xml:space="preserve">
          <source>Here is an example of a query plan for a query using an aggregate function:</source>
          <target state="translated">下面是一个使用集合函数查询的查询计划的例子。</target>
        </trans-unit>
        <trans-unit id="f6d493babc38181bb9e797ebc36b6dee1ed42248" translate="yes" xml:space="preserve">
          <source>Here is an example of collecting functional-dependency statistics:</source>
          <target state="translated">下面是一个收集功能依赖性统计数据的例子。</target>
        </trans-unit>
        <trans-unit id="d635cae1e0a20113dd837d7519806bc17d144c7b" translate="yes" xml:space="preserve">
          <source>Here is an example of creating a foreign table with &lt;code&gt;postgres_fdw&lt;/code&gt;. First install the extension:</source>
          <target state="translated">这是使用 &lt;code&gt;postgres_fdw&lt;/code&gt; 创建外部表的示例。首先安装扩展：</target>
        </trans-unit>
        <trans-unit id="a9d65bbbca8355ed90ddee51a853e323cb2c5356" translate="yes" xml:space="preserve">
          <source>Here is an example of how wait events can be viewed</source>
          <target state="translated">下面是一个如何查看等待事件的例子</target>
        </trans-unit>
        <trans-unit id="d1ba55b43049bc0f3ea6eba1c4f511076f5487a7" translate="yes" xml:space="preserve">
          <source>Here is an example of how wait events can be viewed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="289e8ce361948510d7bea9298d834548d8a0bcac" translate="yes" xml:space="preserve">
          <source>Here is an example of selecting a sample of a table with &lt;code&gt;SYSTEM_ROWS&lt;/code&gt;. First install the extension:</source>
          <target state="translated">这是一个使用 &lt;code&gt;SYSTEM_ROWS&lt;/code&gt; 选择表样本的示例。首先安装扩展：</target>
        </trans-unit>
        <trans-unit id="a28a21ccc575549b0e4278f1befd6c3171d0c15c" translate="yes" xml:space="preserve">
          <source>Here is an example of selecting a sample of a table with &lt;code&gt;SYSTEM_TIME&lt;/code&gt;. First install the extension:</source>
          <target state="translated">这是一个使用 &lt;code&gt;SYSTEM_TIME&lt;/code&gt; 选择表样本的示例。首先安装扩展：</target>
        </trans-unit>
        <trans-unit id="6c1b25585e57445c9a690160c1f6293b2c2334f6" translate="yes" xml:space="preserve">
          <source>Here is an example of using &lt;code&gt;EXPLAIN EXECUTE&lt;/code&gt; to display the execution plan for a prepared query:</source>
          <target state="translated">这是一个使用 &lt;code&gt;EXPLAIN EXECUTE&lt;/code&gt; 显示准备好的查询的执行计划的示例：</target>
        </trans-unit>
        <trans-unit id="3d0353f1bd1f4e5d0cdada03e8194af993f90dd3" translate="yes" xml:space="preserve">
          <source>Here is an example showing how to initialize a fresh database cluster with &lt;code&gt;sepgsql&lt;/code&gt; functions and security labels installed. Adjust the paths shown as appropriate for your installation:</source>
          <target state="translated">这是一个示例，显示了如何使用安装的 &lt;code&gt;sepgsql&lt;/code&gt; 函数和安全标签初始化一个新的数据库集群。调整显示的路径以适合您的安装：</target>
        </trans-unit>
        <trans-unit id="f5681a46af83bb7c4af1228232eef4280217edbe" translate="yes" xml:space="preserve">
          <source>Here is an example showing how to insert the &lt;code&gt;unaccent&lt;/code&gt; dictionary into a text search configuration:</source>
          <target state="translated">这是显示如何将 &lt;code&gt;unaccent&lt;/code&gt; 词典插入文本搜索配置的示例：</target>
        </trans-unit>
        <trans-unit id="740b499e9d1667a11938c2361c53f8d80be32b73" translate="yes" xml:space="preserve">
          <source>Here is an example showing the effects of &lt;code&gt;LIMIT&lt;/code&gt;:</source>
          <target state="translated">这是显示 &lt;code&gt;LIMIT&lt;/code&gt; 的效果的示例：</target>
        </trans-unit>
        <trans-unit id="b663de54fe9a475edef4cab194ba9fd34363260e" translate="yes" xml:space="preserve">
          <source>Here is an example that selects only the ten highest-ranked matches:</source>
          <target state="translated">下面是一个例子,只选择排名最高的十场比赛。</target>
        </trans-unit>
        <trans-unit id="df8103a128aa015d77a6739520d4e9345c77b089" translate="yes" xml:space="preserve">
          <source>Here is an example that shows how to compare each employee's salary with the average salary in his or her department:</source>
          <target state="translated">下面是一个例子,说明如何将每个员工的工资与所在部门的平均工资进行比较。</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="b75486070871a14c2ef5c89ea4b7f39dda615103" translate="yes" xml:space="preserve">
          <source>Here is another example of resolving an operator with one known and one unknown input:</source>
          <target state="translated">下面是另一个解析一个已知和未知输入的运算符的例子。</target>
        </trans-unit>
        <trans-unit id="862cabf7adcfd5c087659f8a55b3eecf121ea793" translate="yes" xml:space="preserve">
          <source>Here is another example: it calculates the total sales for each product (rather than the total sales of all products):</source>
          <target state="translated">这里还有一个例子:它计算每个产品的总销售额(而不是所有产品的总销售额)。</target>
        </trans-unit>
        <trans-unit id="a6970b339f07dcc03e141391304c0d8752344244" translate="yes" xml:space="preserve">
          <source>Here is sample status output from pg_ctl:</source>
          <target state="translated">下面是pg_ctl的状态输出示例。</target>
        </trans-unit>
        <trans-unit id="1352c501bf85911546ec6a7652f925835c799c63" translate="yes" xml:space="preserve">
          <source>Here is some example output:</source>
          <target state="translated">下面是一些输出示例。</target>
        </trans-unit>
        <trans-unit id="e962869eb6c37279a68d52de2ccf4f45b22a61bc" translate="yes" xml:space="preserve">
          <source>Here is the same plan with cost estimates suppressed:</source>
          <target state="translated">下面是同样的计划,成本估算被抑制。</target>
        </trans-unit>
        <trans-unit id="fabdc0d28afb5f0b655ec42a14587280ddf1ed63" translate="yes" xml:space="preserve">
          <source>Here is the same query, but in YAML format:</source>
          <target state="translated">下面是同样的查询,但采用YAML格式。</target>
        </trans-unit>
        <trans-unit id="760b794b45c32777224d4cbdefb3ac43472e24da" translate="yes" xml:space="preserve">
          <source>Here is the same query, with JSON output formatting:</source>
          <target state="translated">下面是同样的查询,采用JSON输出格式。</target>
        </trans-unit>
        <trans-unit id="a12bd1a7adf1cd80938f005fb42c32962ebef7a7" translate="yes" xml:space="preserve">
          <source>Here is the same search+bind configuration written as a URL:</source>
          <target state="translated">下面是同样的搜索+绑定的配置,写成一个URL。</target>
        </trans-unit>
        <trans-unit id="841d1a406c85c774b7e74eabd4886bcaf8000efc" translate="yes" xml:space="preserve">
          <source>Here it can be seen that column 1 (zip code) fully determines column 5 (city) so the coefficient is 1.0, while city only determines zip code about 42% of the time, meaning that there are many cities (58%) that are represented by more than a single ZIP code.</source>
          <target state="translated">这里可以看到,第1列(邮编)完全决定了第5列(城市),所以系数为1.0,而城市只决定了邮编的42%左右,也就是说有很多城市(58%)的代表不止一个邮编。</target>
        </trans-unit>
        <trans-unit id="0ae0c10bf978a8e41d20283c701cce10abe5e998" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;$1&lt;/code&gt; references the value of the first function argument whenever the function is invoked.</source>
          <target state="translated">每当调用函数时， &lt;code&gt;$1&lt;/code&gt; 引用第一个函数参数的值。</target>
        </trans-unit>
        <trans-unit id="e24bb102552ef59f6370ebf0e5c3297d839673d3" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;ONLY&lt;/code&gt; before &lt;code&gt;cities&lt;/code&gt; indicates that the query should be run over only the &lt;code&gt;cities&lt;/code&gt; table, and not tables below &lt;code&gt;cities&lt;/code&gt; in the inheritance hierarchy. Many of the commands that we have already discussed &amp;mdash; &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt; &amp;mdash; support this &lt;code&gt;ONLY&lt;/code&gt; notation.</source>
          <target state="translated">在这里， &lt;code&gt;ONLY&lt;/code&gt; 之前 &lt;code&gt;cities&lt;/code&gt; 表示查询应运行在唯一的 &lt;code&gt;cities&lt;/code&gt; 如下表，而不是表 &lt;code&gt;cities&lt;/code&gt; 在继承层次。我们已经讨论过的许多命令（ &lt;code&gt;SELECT&lt;/code&gt; ， &lt;code&gt;UPDATE&lt;/code&gt; 和 &lt;code&gt;DELETE&lt;/code&gt; ) &lt;code&gt;ONLY&lt;/code&gt; 支持此表示法。</target>
        </trans-unit>
        <trans-unit id="c60ac8b55debcc4cd6f35118bfe06a2acf106ceb" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;ONLY&lt;/code&gt; keyword indicates that the query should apply only to &lt;code&gt;cities&lt;/code&gt;, and not any tables below &lt;code&gt;cities&lt;/code&gt; in the inheritance hierarchy. Many of the commands that we have already discussed &amp;mdash; &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; &amp;mdash; support the &lt;code&gt;ONLY&lt;/code&gt; keyword.</source>
          <target state="translated">在这里， &lt;code&gt;ONLY&lt;/code&gt; 关键字指示查询应只适用于 &lt;code&gt;cities&lt;/code&gt; ，而不是任何表以下 &lt;code&gt;cities&lt;/code&gt; 的继承层次。我们已经讨论过的许多命令（ &lt;code&gt;SELECT&lt;/code&gt; ， &lt;code&gt;UPDATE&lt;/code&gt; 和 &lt;code&gt;DELETE&lt;/code&gt; ）都支持 &lt;code&gt;ONLY&lt;/code&gt; 关键字。</target>
        </trans-unit>
        <trans-unit id="180331b7141355384ecd89f79e056920df2b9440" translate="yes" xml:space="preserve">
          <source>Here the first field is a non-NULL empty string, the third is NULL.</source>
          <target state="translated">这里第一个字段是一个非NULL的空字符串,第三个字段是NULL。</target>
        </trans-unit>
        <trans-unit id="5f5c637c8dd6f2e0bc8a363ff5737852d1e4d516" translate="yes" xml:space="preserve">
          <source>Here the planner has decided to use a two-step plan: the child plan node visits an index to find the locations of rows matching the index condition, and then the upper plan node actually fetches those rows from the table itself. Fetching rows separately is much more expensive than reading them sequentially, but because not all the pages of the table have to be visited, this is still cheaper than a sequential scan. (The reason for using two plan levels is that the upper plan node sorts the row locations identified by the index into physical order before reading them, to minimize the cost of separate fetches. The &amp;ldquo;bitmap&amp;rdquo; mentioned in the node names is the mechanism that does the sorting.)</source>
          <target state="translated">在这里，计划者决定使用两步计划：子计划节点访问索引以找到与索引条件匹配的行的位置，然后上层计划节点实际上从表本身获取这些行。单独获取行比顺序读取要昂贵得多，但是由于并非必须访问表的所有页面，因此这比顺序扫描便宜。 （使用两个计划级别的原因是，上层计划节点在读取之前将索引标识的行位置按物理顺序排序，以最大程度地减少单独提取的开销。节点名称中提到的&amp;ldquo;位图&amp;rdquo;是一种机制，进行排序。）</target>
        </trans-unit>
        <trans-unit id="09e8656c67ee501e993f2cabda72b9c29cefa0ac" translate="yes" xml:space="preserve">
          <source>Here the query's IP address is covered by the partial index. The following query cannot use the partial index, as it uses an IP address that is excluded from the index:</source>
          <target state="translated">这里查询的IP地址被部分索引覆盖。下面的查询不能使用部分索引,因为它使用的IP地址被排除在索引之外。</target>
        </trans-unit>
        <trans-unit id="2ec31c843165653bc80fe695cd716d3b9ef2fc60" translate="yes" xml:space="preserve">
          <source>Here the sum is taken from the first (lowest) salary up through the current one, including any duplicates of the current one (notice the results for the duplicated salaries).</source>
          <target state="translated">这里的总和是从第一个(最低的)工资一直到当前的工资,包括当前工资的任何重复(注意重复的工资的结果)。</target>
        </trans-unit>
        <trans-unit id="537366727b0a957f32d32f1d223a0385ada41099" translate="yes" xml:space="preserve">
          <source>Here the system has implicitly resolved the unknown-type literal as type &lt;code&gt;float8&lt;/code&gt; before applying the chosen operator. We can verify that &lt;code&gt;float8&lt;/code&gt; and not some other type was used:</source>
          <target state="translated">在这里，系统在应用所选运算符之前已将未知类型的文字隐式解析为 &lt;code&gt;float8&lt;/code&gt; 类型。我们可以验证是否使用了 &lt;code&gt;float8&lt;/code&gt; 而不是其他类型的：</target>
        </trans-unit>
        <trans-unit id="cf1e98ca0f0c927b9d08ba4561b2098f2af147e3" translate="yes" xml:space="preserve">
          <source>Here we can see that &lt;code&gt;tenk1&lt;/code&gt; contains 10000 rows, as do its indexes, but the indexes are (unsurprisingly) much smaller than the table.</source>
          <target state="translated">在这里，我们可以看到 &lt;code&gt;tenk1&lt;/code&gt; 包含10000行，它的索引也一样，但是索引（毫无疑问）比表小得多。</target>
        </trans-unit>
        <trans-unit id="d0eab29aaf89686f1fe2e4313a3e207759c193e4" translate="yes" xml:space="preserve">
          <source>Here we can see that the index returned one candidate row, which was then rejected by a recheck of the index condition. This happens because a GiST index is &amp;ldquo;lossy&amp;rdquo; for polygon containment tests: it actually returns the rows with polygons that overlap the target, and then we have to do the exact containment test on those rows.</source>
          <target state="translated">在这里，我们可以看到索引返回了一个候选行，然后被重新检查索引条件拒绝了。发生这种情况的原因是，对于多边形封闭性测试，GiST索引&amp;ldquo;有损&amp;rdquo;：它实际上返回的多边形与目标重叠的行，然后我们必须对这些行进行精确的封闭性测试。</target>
        </trans-unit>
        <trans-unit id="4d135a143a8ec460162e891ace4cc0562f7f0ea6" translate="yes" xml:space="preserve">
          <source>Here we give a short overview of the stages a query has to pass in order to obtain a result.</source>
          <target state="translated">在这里,我们简要介绍一下查询为了获得结果而必须经过的阶段。</target>
        </trans-unit>
        <trans-unit id="bcbe633ffbd28597ca13c601e922e114369f31f0" translate="yes" xml:space="preserve">
          <source>Here we have relabeled the weather table as &lt;code&gt;W1&lt;/code&gt; and &lt;code&gt;W2&lt;/code&gt; to be able to distinguish the left and right side of the join. You can also use these kinds of aliases in other queries to save some typing, e.g.:</source>
          <target state="translated">在这里，我们将天气表重新标记为 &lt;code&gt;W1&lt;/code&gt; 和 &lt;code&gt;W2&lt;/code&gt; ，以便能够区分联接的左侧和右侧。您还可以在其他查​​询中使用这些别名来保存某些类型，例如：</target>
        </trans-unit>
        <trans-unit id="42307deb2832e0c7af756f3107b84bf8b2ea8057" translate="yes" xml:space="preserve">
          <source>Here we have used &lt;code&gt;setweight&lt;/code&gt; to label the source of each lexeme in the finished &lt;code&gt;tsvector&lt;/code&gt;, and then merged the labeled &lt;code&gt;tsvector&lt;/code&gt; values using the &lt;code&gt;tsvector&lt;/code&gt; concatenation operator &lt;code&gt;||&lt;/code&gt;. (&lt;a href=&quot;textsearch-features#TEXTSEARCH-MANIPULATE-TSVECTOR&quot;&gt;Section 12.4.1&lt;/a&gt; gives details about these operations.)</source>
          <target state="translated">在这里，我们使用 &lt;code&gt;setweight&lt;/code&gt; 在完成的 &lt;code&gt;tsvector&lt;/code&gt; 中标记每个词素的来源，然后使用 &lt;code&gt;tsvector&lt;/code&gt; 并置运算符 &lt;code&gt;||&lt;/code&gt; 合并标记的 &lt;code&gt;tsvector&lt;/code&gt; 值。。（&lt;a href=&quot;textsearch-features#TEXTSEARCH-MANIPULATE-TSVECTOR&quot;&gt;第12.4.1节&lt;/a&gt;提供了有关这些操作的详细信息。）</target>
        </trans-unit>
        <trans-unit id="ebe0ff0a0f834e90a6235b06460f658da331e569" translate="yes" xml:space="preserve">
          <source>Here's a simple example of usage:</source>
          <target state="translated">下面是一个简单的使用实例。</target>
        </trans-unit>
        <trans-unit id="a00d1ad8972f6aee9ca962b7dd2f9cc873a842a4" translate="yes" xml:space="preserve">
          <source>Here's an annotated example of &lt;code&gt;lquery&lt;/code&gt;:</source>
          <target state="translated">这是 &lt;code&gt;lquery&lt;/code&gt; 的带注释的示例：</target>
        </trans-unit>
        <trans-unit id="d49be83bb6ef95a34484a28f1063c126af2cd0f3" translate="yes" xml:space="preserve">
          <source>Here's an example &lt;code&gt;ltxtquery&lt;/code&gt;:</source>
          <target state="translated">这是一个 &lt;code&gt;ltxtquery&lt;/code&gt; 示例：</target>
        </trans-unit>
        <trans-unit id="48493c355bde53a50b460fe64d3981e1bf2c28dd" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;DictFile&lt;/code&gt;, &lt;code&gt;AffFile&lt;/code&gt;, and &lt;code&gt;StopWords&lt;/code&gt; specify the base names of the dictionary, affixes, and stop-words files. The stop-words file has the same format explained above for the &lt;code&gt;simple&lt;/code&gt; dictionary type. The format of the other files is not specified here but is available from the above-mentioned web sites.</source>
          <target state="translated">在这里， &lt;code&gt;DictFile&lt;/code&gt; ， &lt;code&gt;AffFile&lt;/code&gt; 和 &lt;code&gt;StopWords&lt;/code&gt; 指定字典，词缀和停用词文件的基本名称。停用词文件具有与上述 &lt;code&gt;simple&lt;/code&gt; 字典类型相同的格式。其他文件的格式未在此处指定，但可以从上述网站上获得。</target>
        </trans-unit>
        <trans-unit id="a15f0741ab9f0607b3961ed00005a1407be190df" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;db_column:update&lt;/code&gt; will be checked for &lt;code&gt;t1.x&lt;/code&gt;, since it is being updated, &lt;code&gt;db_column:{select update}&lt;/code&gt; will be checked for &lt;code&gt;t1.y&lt;/code&gt;, since it is both updated and referenced, and &lt;code&gt;db_column:select&lt;/code&gt; will be checked for &lt;code&gt;t1.z&lt;/code&gt;, since it is only referenced. &lt;code&gt;db_table:{select update}&lt;/code&gt; will also be checked at the table level.</source>
          <target state="translated">在此，将检查 &lt;code&gt;db_column:update&lt;/code&gt; 的 &lt;code&gt;t1.x&lt;/code&gt; ，因为它正在更新，将检查 &lt;code&gt;db_column:{select update}&lt;/code&gt; 的 &lt;code&gt;t1.y&lt;/code&gt; ，因为它已被更新和引用，并且将检查 &lt;code&gt;db_column:select&lt;/code&gt; 的 &lt;code&gt;t1.z&lt;/code&gt; ，因为仅被引用。 &lt;code&gt;db_table:{select update}&lt;/code&gt; 还将在表级别进行检查。</target>
        </trans-unit>
        <trans-unit id="94323f34e2769fd6d8140ecf86916e1a4ffa6df9" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;english&lt;/code&gt; is the base name of a file of stop words. The file's full name will be &lt;code&gt;$SHAREDIR/tsearch_data/english.stop&lt;/code&gt;, where &lt;code&gt;$SHAREDIR&lt;/code&gt; means the PostgreSQL installation's shared-data directory, often &lt;code&gt;/usr/local/share/postgresql&lt;/code&gt; (use &lt;code&gt;pg_config --sharedir&lt;/code&gt; to determine it if you're not sure). The file format is simply a list of words, one per line. Blank lines and trailing spaces are ignored, and upper case is folded to lower case, but no other processing is done on the file contents.</source>
          <target state="translated">在这里， &lt;code&gt;english&lt;/code&gt; 是停用词文件的基本名称。该文件的全名将为 &lt;code&gt;$SHAREDIR/tsearch_data/english.stop&lt;/code&gt; ，其中 &lt;code&gt;$SHAREDIR&lt;/code&gt; 表示PostgreSQL安装的共享数据目录，通常是 &lt;code&gt;/usr/local/share/postgresql&lt;/code&gt; （如果不使用 &lt;code&gt;pg_config --sharedir&lt;/code&gt; 来确定它）当然）。文件格式只是单词列表，每行一个。空行和尾随空格将被忽略，大写字母将被折叠为小写字母，但是不会对文件内容进行任何其他处理。</target>
        </trans-unit>
        <trans-unit id="1c3b85c63ac80bdd86554daac13d878a06c56b22" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;expression&lt;/code&gt; represents any value expression that does not itself contain window function calls.</source>
          <target state="translated">在这里， &lt;code&gt;expression&lt;/code&gt; 表示本身不包含窗口函数调用的任何值表达式。</target>
        </trans-unit>
        <trans-unit id="b22882051bae4c80aed43f53d018119709936657" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;key&lt;/code&gt; is an element in the index and &lt;code&gt;query&lt;/code&gt; the value being looked up in the index. The &lt;code&gt;StrategyNumber&lt;/code&gt; parameter indicates which operator of your operator class is being applied &amp;mdash; it matches one of the operator numbers in the &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; command.</source>
          <target state="translated">这里， &lt;code&gt;key&lt;/code&gt; 是索引中的一个元素，用于 &lt;code&gt;query&lt;/code&gt; 在索引中查找的值。该 &lt;code&gt;StrategyNumber&lt;/code&gt; 参数指示正在应用该运营商网络运营商级的-它匹配的运营商号码之一 &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="f689631caa32c4a22198886b0f15d59af75c4c1d" translate="yes" xml:space="preserve">
          <source>Here, all the input punctuation was discarded as being space symbols.</source>
          <target state="translated">在这里,所有输入的标点符号都被舍弃为空格符号。</target>
        </trans-unit>
        <trans-unit id="0ca2ace43c2caf64cad6ca5ff508187ff18cbed2" translate="yes" xml:space="preserve">
          <source>Here, all the input punctuation was discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2bea9418baff2dab8ad2f535eead313521a74b5" translate="yes" xml:space="preserve">
          <source>Here, condition has a format similar to the format of regular expressions. It can use groupings &lt;code&gt;[...]&lt;/code&gt; and &lt;code&gt;[^...]&lt;/code&gt;. For example, &lt;code&gt;[AEIOU]Y&lt;/code&gt; means that the last letter of the word is &lt;code&gt;&quot;y&quot;&lt;/code&gt; and the penultimate letter is &lt;code&gt;&quot;a&quot;&lt;/code&gt;, &lt;code&gt;&quot;e&quot;&lt;/code&gt;, &lt;code&gt;&quot;i&quot;&lt;/code&gt;, &lt;code&gt;&quot;o&quot;&lt;/code&gt; or &lt;code&gt;&quot;u&quot;&lt;/code&gt;. &lt;code&gt;[^EY]&lt;/code&gt; means that the last letter is neither &lt;code&gt;&quot;e&quot;&lt;/code&gt; nor &lt;code&gt;&quot;y&quot;&lt;/code&gt;.</source>
          <target state="translated">这里，条件的格式类似于正则表达式的格式。它可以使用分组 &lt;code&gt;[...]&lt;/code&gt; 和 &lt;code&gt;[^...]&lt;/code&gt; 。例如， &lt;code&gt;[AEIOU]Y&lt;/code&gt; 表示单词的最后一个字母为 &lt;code&gt;&quot;y&quot;&lt;/code&gt; ，倒数第二个字母为 &lt;code&gt;&quot;a&quot;&lt;/code&gt; ， &lt;code&gt;&quot;e&quot;&lt;/code&gt; ， &lt;code&gt;&quot;i&quot;&lt;/code&gt; ， &lt;code&gt;&quot;o&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;u&quot;&lt;/code&gt; 。 &lt;code&gt;[^EY]&lt;/code&gt; 表示最后一个字母既不是 &lt;code&gt;&quot;e&quot;&lt;/code&gt; 也不是 &lt;code&gt;&quot;y&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00e7b43ee7c6b641274238949f463079d5bbf579" translate="yes" xml:space="preserve">
          <source>Here, materialization of the &lt;code&gt;WITH&lt;/code&gt; query ensures that &lt;code&gt;very_expensive_function&lt;/code&gt; is evaluated only once per table row, not twice.</source>
          <target state="translated">在这里， &lt;code&gt;WITH&lt;/code&gt; 查询的实现确保了对每张表行仅一次评估 &lt;code&gt;very_expensive_function&lt;/code&gt; ，而不是两次。</target>
        </trans-unit>
        <trans-unit id="eadb56d6708463f3d868c5af1a2244c7c4a3fed2" translate="yes" xml:space="preserve">
          <source>Here, since type &lt;code&gt;real&lt;/code&gt; cannot be implicitly cast to &lt;code&gt;integer&lt;/code&gt;, but &lt;code&gt;integer&lt;/code&gt; can be implicitly cast to &lt;code&gt;real&lt;/code&gt;, the union result type is resolved as &lt;code&gt;real&lt;/code&gt;.</source>
          <target state="translated">在这里，由于不能将 &lt;code&gt;real&lt;/code&gt; 类型隐式转换为 &lt;code&gt;integer&lt;/code&gt; ，但是可以将 &lt;code&gt;integer&lt;/code&gt; 隐式转换为 &lt;code&gt;real&lt;/code&gt; ，因此将联合结果类型解析为 &lt;code&gt;real&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f0dca8cee0ac9d29f980481c680637be6b839c3" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;grouping&lt;/code&gt; value &lt;code&gt;0&lt;/code&gt; in the first four rows shows that those have been grouped normally, over both the grouping columns. The value &lt;code&gt;1&lt;/code&gt; indicates that &lt;code&gt;model&lt;/code&gt; was not grouped by in the next-to-last two rows, and the value &lt;code&gt;3&lt;/code&gt; indicates that neither &lt;code&gt;make&lt;/code&gt; nor &lt;code&gt;model&lt;/code&gt; was grouped by in the last row (which therefore is an aggregate over all the input rows).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfec33c2243bfacb00b180b26c912c2de7a8aad2" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;uppercase&lt;/code&gt; parameter is omitted, so it receives its default value of &lt;code&gt;false&lt;/code&gt;, resulting in lower case output. In positional notation, arguments can be omitted from right to left so long as they have defaults.</source>
          <target state="translated">此处，省略了 &lt;code&gt;uppercase&lt;/code&gt; 参数，因此它接收其默认值 &lt;code&gt;false&lt;/code&gt; ，从而导致小写输出。在位置表示法中，可以将参数从右到左省略，只要它们具有默认值即可。</target>
        </trans-unit>
        <trans-unit id="c823dd873535ad7ccdb6e068431505db91bdcea6" translate="yes" xml:space="preserve">
          <source>Here, the planner has chosen to use a hash join, in which rows of one table are entered into an in-memory hash table, after which the other table is scanned and the hash table is probed for matches to each row. Again note how the indentation reflects the plan structure: the bitmap scan on &lt;code&gt;tenk1&lt;/code&gt; is the input to the Hash node, which constructs the hash table. That's then returned to the Hash Join node, which reads rows from its outer child plan and searches the hash table for each one.</source>
          <target state="translated">在这里，计划者选择使用哈希联接，其中将一个表的行输入到内存中的哈希表中，然后扫描另一个表，并探查哈希表以查找与每一行的匹配项。再次注意缩进是如何反映计划结构的： &lt;code&gt;tenk1&lt;/code&gt; 上的位图扫描是哈希节点的输入，哈希节点构造哈希表。然后将其返回到&amp;ldquo;哈希联接&amp;rdquo;节点，该节点从其外部子计划中读取行，并在哈希表中搜索每个行。</target>
        </trans-unit>
        <trans-unit id="5850a821f06c0b2f442ebe11558a575852c8aeb5" translate="yes" xml:space="preserve">
          <source>Here, the sequence &lt;code&gt;$q$[\t\r\n\v\\]$q$&lt;/code&gt; represents a dollar-quoted literal string &lt;code&gt;[\t\r\n\v\\]&lt;/code&gt;, which will be recognized when the function body is executed by PostgreSQL. But since the sequence does not match the outer dollar quoting delimiter &lt;code&gt;$function$&lt;/code&gt;, it is just some more characters within the constant so far as the outer string is concerned.</source>
          <target state="translated">在这里，序列 &lt;code&gt;$q$[\t\r\n\v\\]$q$&lt;/code&gt; 代表用美元报价的文字字符串 &lt;code&gt;[\t\r\n\v\\]&lt;/code&gt; ，当函数体被识别时由PostgreSQL执行。但是由于该序列与外部美元引用定界符 &lt;code&gt;$function$&lt;/code&gt; 不匹配，因此就外部字符串而言，它只是常量中的一些其他字符。</target>
        </trans-unit>
        <trans-unit id="e42cf0e074b0fa8e95e14f4ebb3e1b606554ddda" translate="yes" xml:space="preserve">
          <source>Here, the unknown-type literal &lt;code&gt;'b'&lt;/code&gt; will be resolved to type &lt;code&gt;text&lt;/code&gt;.</source>
          <target state="translated">在这里，未知类型的文字 &lt;code&gt;'b'&lt;/code&gt; 将解析为 &lt;code&gt;text&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a1e31a79ba26a76d28a87c7ed0407b897f88b5e6" translate="yes" xml:space="preserve">
          <source>Here:</source>
          <target state="translated">Here:</target>
        </trans-unit>
        <trans-unit id="6789cbae03419b1c1cfba25dda2b2a3e23e7e4c6" translate="yes" xml:space="preserve">
          <source>Hex Representation</source>
          <target state="translated">十六进制表示法</target>
        </trans-unit>
        <trans-unit id="120e75d0d27169271eff5b30f1995d939cf69223" translate="yes" xml:space="preserve">
          <source>Hexadecimal digits are &lt;code&gt;0&lt;/code&gt;-&lt;code&gt;9&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt;-&lt;code&gt;f&lt;/code&gt;, and &lt;code&gt;A&lt;/code&gt;-&lt;code&gt;F&lt;/code&gt;. Octal digits are &lt;code&gt;0&lt;/code&gt;-&lt;code&gt;7&lt;/code&gt;.</source>
          <target state="translated">十六进制数字是 &lt;code&gt;0&lt;/code&gt; - &lt;code&gt;9&lt;/code&gt; ， &lt;code&gt;a&lt;/code&gt; - &lt;code&gt;f&lt;/code&gt; ，和 &lt;code&gt;A&lt;/code&gt; - &lt;code&gt;F&lt;/code&gt; 。八进制数字是 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;7&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ffcadc3bbf92f4882971ddc3bc8286e63dfa62c0" translate="yes" xml:space="preserve">
          <source>High Availability</source>
          <target state="translated">高可用性</target>
        </trans-unit>
        <trans-unit id="946223b4ede05fe838dc846e6faf0a89f88f0e1d" translate="yes" xml:space="preserve">
          <source>High Value</source>
          <target state="translated">高价值</target>
        </trans-unit>
        <trans-unit id="c23ab61c10027c96a9184ffc34b5fb7aecf016a1" translate="yes" xml:space="preserve">
          <source>Historically this module depended on the OSSP UUID library, which accounts for the module's name. While the OSSP UUID library can still be found at &lt;a href=&quot;http://www.ossp.org/pkg/lib/uuid/&quot;&gt;http://www.ossp.org/pkg/lib/uuid/&lt;/a&gt;, it is not well maintained, and is becoming increasingly difficult to port to newer platforms. &lt;code&gt;uuid-ossp&lt;/code&gt; can now be built without the OSSP library on some platforms. On FreeBSD, NetBSD, and some other BSD-derived platforms, suitable UUID creation functions are included in the core &lt;code&gt;libc&lt;/code&gt; library. On Linux, macOS, and some other platforms, suitable functions are provided in the &lt;code&gt;libuuid&lt;/code&gt; library, which originally came from the &lt;code&gt;e2fsprogs&lt;/code&gt; project (though on modern Linux it is considered part of &lt;code&gt;util-linux-ng&lt;/code&gt;). When invoking &lt;code&gt;configure&lt;/code&gt;, specify &lt;code&gt;--with-uuid=bsd&lt;/code&gt; to use the BSD functions, or &lt;code&gt;--with-uuid=e2fs&lt;/code&gt; to use &lt;code&gt;e2fsprogs&lt;/code&gt;' &lt;code&gt;libuuid&lt;/code&gt;, or &lt;code&gt;--with-uuid=ossp&lt;/code&gt; to use the OSSP UUID library. More than one of these libraries might be available on a particular machine, so &lt;code&gt;configure&lt;/code&gt; does not automatically choose one.</source>
          <target state="translated">从历史上看，此模块依赖于OSSP UUID库，该库说明了模块的名称。尽管仍然可以在&lt;a href=&quot;http://www.ossp.org/pkg/lib/uuid/&quot;&gt;http://www.ossp.org/pkg/lib/uuid/&lt;/a&gt;上找到OSSP UUID库，但它维护得不好，并且越来越难以移植到较新的平台上。现在可以在某些平台上不使用 &lt;code&gt;uuid-ossp&lt;/code&gt; 库的情况下构建uuid-ossp。在FreeBSD，NetBSD和其他一些BSD衍生的平台上，核心 &lt;code&gt;libc&lt;/code&gt; 库中包含合适的UUID创建功能。在Linux，macOS和其他平台上， &lt;code&gt;libuuid&lt;/code&gt; 库提供了适当的功能，该库最初来自 &lt;code&gt;e2fsprogs&lt;/code&gt; 项目（尽管在现代Linux上，它被视为 &lt;code&gt;util-linux-ng&lt;/code&gt; 的一部分)）。调用 &lt;code&gt;configure&lt;/code&gt; 时，请指定 &lt;code&gt;--with-uuid=bsd&lt;/code&gt; 使用BSD函数，或者指定 &lt;code&gt;--with-uuid=e2fs&lt;/code&gt; 使用 &lt;code&gt;e2fsprogs&lt;/code&gt; 的 &lt;code&gt;libuuid&lt;/code&gt; ，或者指定 &lt;code&gt;--with-uuid=ossp&lt;/code&gt; 使用OSSP UUID库。这些库中的一个以上可能在特定计算机上可用，因此 &lt;code&gt;configure&lt;/code&gt; 不会自动选择一个。</target>
        </trans-unit>
        <trans-unit id="b5584bf16896f3c913b27677d773698adc908eae" translate="yes" xml:space="preserve">
          <source>History of Units</source>
          <target state="translated">单位的历史</target>
        </trans-unit>
        <trans-unit id="70f8bb9a8a5393ef080507a89e4b98d139000d65" translate="yes" xml:space="preserve">
          <source>Home</source>
          <target state="translated">Home</target>
        </trans-unit>
        <trans-unit id="3960ec4ca5fb5e5d8cdb2cc1c5121c003e426517" translate="yes" xml:space="preserve">
          <source>Host</source>
          <target state="translated">Host</target>
        </trans-unit>
        <trans-unit id="7e3d4d69eb95f3292122a5fea9416ed4cba36be3" translate="yes" xml:space="preserve">
          <source>Host name of the connected client, as reported by a reverse DNS lookup of &lt;code&gt;client_addr&lt;/code&gt;. This field will only be non-null for IP connections, and only when &lt;a href=&quot;runtime-config-logging#GUC-LOG-HOSTNAME&quot;&gt;log_hostname&lt;/a&gt; is enabled.</source>
          <target state="translated">连接的客户端的主机名，由 &lt;code&gt;client_addr&lt;/code&gt; 的反向DNS查找报告。对于IP连接，仅当启用&lt;a href=&quot;runtime-config-logging#GUC-LOG-HOSTNAME&quot;&gt;log_hostname&lt;/a&gt;时，此字段才为非空。</target>
        </trans-unit>
        <trans-unit id="67b082e00139eb65670882e9969e878f533f20b1" translate="yes" xml:space="preserve">
          <source>Host name or IP address, or one of &lt;code&gt;all&lt;/code&gt;, &lt;code&gt;samehost&lt;/code&gt;, or &lt;code&gt;samenet&lt;/code&gt;, or null for local connections</source>
          <target state="translated">主机名或IP地址，或 &lt;code&gt;all&lt;/code&gt; ， &lt;code&gt;samehost&lt;/code&gt; 或 &lt;code&gt;samenet&lt;/code&gt; 之一，或本地连接为null</target>
        </trans-unit>
        <trans-unit id="3acb05d9b4db45ddd95be7a72351a5560907bba2" translate="yes" xml:space="preserve">
          <source>Host of the PostgreSQL instance this WAL receiver is connected to. This can be a host name, an IP address, or a directory path if the connection is via Unix socket. (The path case can be distinguished because it will always be an absolute path, beginning with &lt;code&gt;/&lt;/code&gt;.)</source>
          <target state="translated">该WAL接收器连接到的PostgreSQL实例的主机。如果通过Unix套接字进行连接，则可以是主机名，IP地址或目录路径。（可以区分路径大小写，因为它始终是绝对路径，以 &lt;code&gt;/&lt;/code&gt; 开头。）</target>
        </trans-unit>
        <trans-unit id="e716495d010a3dcebf55c7c74d98bdb385a76508" translate="yes" xml:space="preserve">
          <source>Host-Based Authentication</source>
          <target state="translated">基于主机的认证</target>
        </trans-unit>
        <trans-unit id="cc53b246d6c96fb218922a66ec6b6ca310bf3021" translate="yes" xml:space="preserve">
          <source>Hot Standby</source>
          <target state="translated">热备用</target>
        </trans-unit>
        <trans-unit id="d972243453928257bff4b6354fce98c1493ba542" translate="yes" xml:space="preserve">
          <source>Hot Standby feedback propagates upstream, whatever the cascaded arrangement.</source>
          <target state="translated">热待机反馈会向上游传播,无论级联布置如何。</target>
        </trans-unit>
        <trans-unit id="5091beeb3be00f483925a2bb31c058bfcaaaeb31" translate="yes" xml:space="preserve">
          <source>Hot Standby is the term used to describe the ability to connect to the server and run read-only queries while the server is in archive recovery or standby mode. This is useful both for replication purposes and for restoring a backup to a desired state with great precision. The term Hot Standby also refers to the ability of the server to move from recovery through to normal operation while users continue running queries and/or keep their connections open.</source>
          <target state="translated">热备是用来描述在服务器处于归档恢复或待机模式时连接到服务器并运行只读查询的能力的术语。这对于复制目的和高精度地将备份恢复到所需状态都很有用。术语 &quot;热备 &quot;还指服务器从恢复到正常运行的能力,同时用户继续运行查询和/或保持连接开放。</target>
        </trans-unit>
        <trans-unit id="9e25a34e635a123f8958bbe26e7c4843278597fb" translate="yes" xml:space="preserve">
          <source>Hours</source>
          <target state="translated">Hours</target>
        </trans-unit>
        <trans-unit id="b8d371fd69de846ce0d56ec576287b8268a9b53e" translate="yes" xml:space="preserve">
          <source>How Connections Are Established</source>
          <target state="translated">如何建立联系</target>
        </trans-unit>
        <trans-unit id="8cecc82d72d68f9151cb0901cfe40eeac15bfca6" translate="yes" xml:space="preserve">
          <source>How It Works</source>
          <target state="translated">它是如何工作的</target>
        </trans-unit>
        <trans-unit id="a41409a5166c5d74bdffdf63899f116578d1e299" translate="yes" xml:space="preserve">
          <source>How Parallel Query Works</source>
          <target state="translated">平行查询如何工作</target>
        </trans-unit>
        <trans-unit id="7604442ec6b924ac1f168d8f81e9b0b61679f4f6" translate="yes" xml:space="preserve">
          <source>How many concurrent connections can be made to this database. -1 (the default) means no limit.</source>
          <target state="translated">这个数据库可以有多少个并发连接,-1(默认)表示没有限制。-1(默认)表示没有限制。</target>
        </trans-unit>
        <trans-unit id="d98f671ec6200c3b445e94f09f19857316dd290b" translate="yes" xml:space="preserve">
          <source>How many concurrent connections can be made to this database. -1 means no limit.</source>
          <target state="translated">这个数据库可以并发多少个连接。-1表示没有限制。</target>
        </trans-unit>
        <trans-unit id="e914be45633e81e1b35dd5a5a8544fdfa64c8d17" translate="yes" xml:space="preserve">
          <source>How much to compress. Higher levels compress smaller but are slower. 0 disables compression.</source>
          <target state="translated">压缩多少。级别越高压缩越小,但速度越慢。0禁用压缩。</target>
        </trans-unit>
        <trans-unit id="ef6f180b70cdcd17c60a982706ebbdc6fbb46234" translate="yes" xml:space="preserve">
          <source>How the planner determines the cardinality of &lt;code&gt;tenk1&lt;/code&gt; is covered in &lt;a href=&quot;planner-stats&quot;&gt;Section 14.2&lt;/a&gt;, but is repeated here for completeness. The number of pages and rows is looked up in &lt;code&gt;pg_class&lt;/code&gt;:</source>
          <target state="translated">规划者如何确定 &lt;code&gt;tenk1&lt;/code&gt; 的基数已在&lt;a href=&quot;planner-stats&quot;&gt;14.2节中介绍&lt;/a&gt;，但在此重复以确保完整性。在 &lt;code&gt;pg_class&lt;/code&gt; 中查找页数和行数：</target>
        </trans-unit>
        <trans-unit id="94ecf8c7f95f01155b7f0495cbc646415e78c1ae" translate="yes" xml:space="preserve">
          <source>How to choose a good password.</source>
          <target state="translated">如何选择一个好的密码。</target>
        </trans-unit>
        <trans-unit id="2ba82223beeb024535e1c4a0ddfd885368b08372" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;jsonb&lt;/code&gt; will preserve trailing fractional zeroes, as seen in this example, even though those are semantically insignificant for purposes such as equality checks.</source>
          <target state="translated">但是， &lt;code&gt;jsonb&lt;/code&gt; 将保留尾随零，如本例所示，即使它们在语义上无意义（例如，相等性检查）也是如此。</target>
        </trans-unit>
        <trans-unit id="483f78f78539b97c5a6d0e5895b7ea66709bc65e" translate="yes" xml:space="preserve">
          <source>However, a &lt;code&gt;TABLE&lt;/code&gt; function is different from the preceding examples, because it actually returns a &lt;em&gt;set&lt;/em&gt; of records, not just one record.</source>
          <target state="translated">但是， &lt;code&gt;TABLE&lt;/code&gt; 函数与前面的示例不同，因为它实际上返回一&lt;em&gt;组&lt;/em&gt;记录，而不仅仅是一个记录。</target>
        </trans-unit>
        <trans-unit id="5593eb449291b54fa57b6d536402c4a2c8454af7" translate="yes" xml:space="preserve">
          <source>However, a &lt;code&gt;WITH&lt;/code&gt; query can be marked &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; to remove this guarantee. In that case, the &lt;code&gt;WITH&lt;/code&gt; query can be folded into the primary query much as though it were a simple sub-&lt;code&gt;SELECT&lt;/code&gt; in the primary query's &lt;code&gt;FROM&lt;/code&gt; clause. This results in duplicate computations if the primary query refers to that &lt;code&gt;WITH&lt;/code&gt; query more than once; but if each such use requires only a few rows of the &lt;code&gt;WITH&lt;/code&gt; query's total output, &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; can provide a net savings by allowing the queries to be optimized jointly. &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; is ignored if it is attached to a &lt;code&gt;WITH&lt;/code&gt; query that is recursive or is not side-effect-free (i.e., is not a plain &lt;code&gt;SELECT&lt;/code&gt; containing no volatile functions).</source>
          <target state="translated">但是，可以将 &lt;code&gt;WITH&lt;/code&gt; 查询标记为 &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; 以删除此保证。在那种情况下， &lt;code&gt;WITH&lt;/code&gt; 查询可以折叠到主查询中，就像它是主查询的 &lt;code&gt;FROM&lt;/code&gt; 子句中的简单子 &lt;code&gt;SELECT&lt;/code&gt; 一样。如果主查询多次引用该 &lt;code&gt;WITH&lt;/code&gt; 查询，则会导致重复计算；否则，将导致重复计算。但是，如果每种使用都只需要 &lt;code&gt;WITH&lt;/code&gt; 查询的总输出中的几行，则 &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; 可以通过共同优化查询来节省费用。如果将 &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; 附加到 &lt;code&gt;WITH&lt;/code&gt; ,则将其忽略递归查询或非副作用查询（即不是不包含易失函数的普通 &lt;code&gt;SELECT&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b767ca4c454cedd41bdf2ff2cdb11395909dd8d9" translate="yes" xml:space="preserve">
          <source>However, buffering index build needs to call the &lt;code&gt;penalty&lt;/code&gt; function more often, which consumes some extra CPU resources. Also, the buffers used in the buffering build need temporary disk space, up to the size of the resulting index. Buffering can also influence the quality of the resulting index, in both positive and negative directions. That influence depends on various factors, like the distribution of the input data and the operator class implementation.</source>
          <target state="translated">但是，缓冲索引构建需要更频繁地调用 &lt;code&gt;penalty&lt;/code&gt; 函数，这会消耗一些额外的CPU资源。同样，在缓冲构建中使用的缓冲区需要临时磁盘空间，最大为结果索引的大小。缓冲还可以在正向和负向两个方面影响所得索引的质量。这种影响取决于各种因素，例如输入数据的分布和操作员类别的实现。</target>
        </trans-unit>
        <trans-unit id="9ace55465d56f996227de2d5f96f6d4ae754cfc4" translate="yes" xml:space="preserve">
          <source>However, every year divisible by 100 is not a leap year.</source>
          <target state="translated">然而,每一个被100整除的年份都不是闰年。</target>
        </trans-unit>
        <trans-unit id="792feefacc6fed97444972da0544bbf7d0187b3d" translate="yes" xml:space="preserve">
          <source>However, every year divisible by 400 is a leap year after all.</source>
          <target state="translated">然而,每一个被400除以的年份毕竟是一个闰年。</target>
        </trans-unit>
        <trans-unit id="7f65ac3c6b4eb7f83cd55133554a3e43236a59b1" translate="yes" xml:space="preserve">
          <source>However, filtered forms in Microsoft Access generate queries that appear to use &lt;code&gt;expr = NULL&lt;/code&gt; to test for null values, so if you use that interface to access the database you might want to turn this option on. Since expressions of the form &lt;code&gt;expr = NULL&lt;/code&gt; always return the null value (using the SQL standard interpretation), they are not very useful and do not appear often in normal applications so this option does little harm in practice. But new users are frequently confused about the semantics of expressions involving null values, so this option is off by default.</source>
          <target state="translated">但是，Microsoft Access中的筛选表单会生成查询，这些查询似乎使用 &lt;code&gt;expr = NULL&lt;/code&gt; 来测试空值，因此，如果您使用该接口访问数据库，则可能需要打开此选项。由于 &lt;code&gt;expr = NULL&lt;/code&gt; 形式的表达式始终返回空值（使用SQL标准解释），因此它们不是很有用，并且在普通应用程序中不经常出现，因此此选项在实践中几乎没有危害。但是新用户经常对涉及空值的表达式的语义感到困惑，因此默认情况下此选项处于关闭状态。</target>
        </trans-unit>
        <trans-unit id="27fc16525c2f3eccc5221bef3e492bce51567b8a" translate="yes" xml:space="preserve">
          <source>However, if a &lt;code&gt;WITH&lt;/code&gt; query is non-recursive and side-effect-free (that is, it is a &lt;code&gt;SELECT&lt;/code&gt; containing no volatile functions) then it can be folded into the parent query, allowing joint optimization of the two query levels. By default, this happens if the parent query references the &lt;code&gt;WITH&lt;/code&gt; query just once, but not if it references the &lt;code&gt;WITH&lt;/code&gt; query more than once. You can override that decision by specifying &lt;code&gt;MATERIALIZED&lt;/code&gt; to force separate calculation of the &lt;code&gt;WITH&lt;/code&gt; query, or by specifying &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; to force it to be merged into the parent query. The latter choice risks duplicate computation of the &lt;code&gt;WITH&lt;/code&gt; query, but it can still give a net savings if each usage of the &lt;code&gt;WITH&lt;/code&gt; query needs only a small part of the &lt;code&gt;WITH&lt;/code&gt; query's full output.</source>
          <target state="translated">但是，如果 &lt;code&gt;WITH&lt;/code&gt; 查询是非递归且无副作用的（即，它是不包含volatile函数的 &lt;code&gt;SELECT&lt;/code&gt; ），则可以将其折叠到父查询中，从而可以对两个查询级别进行联合优化。默认情况下，出现这种情况，如果父查询引用的 &lt;code&gt;WITH&lt;/code&gt; 查询只有一次，但如果它引用的 &lt;code&gt;WITH&lt;/code&gt; 不止一次查询。您可以通过指定 &lt;code&gt;MATERIALIZED&lt;/code&gt; 来强制对 &lt;code&gt;WITH&lt;/code&gt; 查询进行单独计算，或者通过指定 &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; 来强制将其合并到父查询中来覆盖该决定。后一种选择可能会重复计算 &lt;code&gt;WITH&lt;/code&gt; 查询，但是如果每次使用 &lt;code&gt;WITH&lt;/code&gt; 查询只需要 &lt;code&gt;WITH&lt;/code&gt; 查询全部输出的一小部分，它仍然可以节省净额。</target>
        </trans-unit>
        <trans-unit id="057cccafbf2013b3d5aa591e41a10dbea6d97107" translate="yes" xml:space="preserve">
          <source>However, if the default value is volatile (e.g. &lt;code&gt;clock_timestamp()&lt;/code&gt;) each row will need to be updated with the value calculated at the time &lt;code&gt;ALTER TABLE&lt;/code&gt; is executed. To avoid a potentially lengthy update operation, particularly if you intend to fill the column with mostly nondefault values anyway, it may be preferable to add the column with no default, insert the correct values using &lt;code&gt;UPDATE&lt;/code&gt;, and then add any desired default as described below.</source>
          <target state="translated">但是，如果默认值是易失性的（例如 &lt;code&gt;clock_timestamp()&lt;/code&gt; ），则需要使用执行 &lt;code&gt;ALTER TABLE&lt;/code&gt; 时计算出的值来更新每一行。为避免可能进行冗长的更新操作，特别是如果您打算用几乎所有非默认值填充该列，则最好添加无默认值的列，使用 &lt;code&gt;UPDATE&lt;/code&gt; 插入正确的值，然后添加任何所需的默认值，如下所述。</target>
        </trans-unit>
        <trans-unit id="ad2998ee50884b058602cae8c89653b7c98ab015" translate="yes" xml:space="preserve">
          <source>However, if the default value is volatile (e.g., &lt;code&gt;clock_timestamp()&lt;/code&gt;) each row will need to be updated with the value calculated at the time &lt;code&gt;ALTER TABLE&lt;/code&gt; is executed. To avoid a potentially lengthy update operation, particularly if you intend to fill the column with mostly nondefault values anyway, it may be preferable to add the column with no default, insert the correct values using &lt;code&gt;UPDATE&lt;/code&gt;, and then add any desired default as described below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbbfd51a31cdab8f282fc85ab92999c7b1df44cb" translate="yes" xml:space="preserve">
          <source>However, it is not necessary to remove role memberships involving the role; &lt;code&gt;DROP ROLE&lt;/code&gt; automatically revokes any memberships of the target role in other roles, and of other roles in the target role. The other roles are not dropped nor otherwise affected.</source>
          <target state="translated">但是，不必删除涉及该角色的角色成员资格； &lt;code&gt;DROP ROLE&lt;/code&gt; 自动撤消其他角色中目标角色和目标角色中其他角色的所有成员身份。其他角色不会丢失，也不会受到其他影响。</target>
        </trans-unit>
        <trans-unit id="f99a4fe30aa35a7291430986cdc65efbff8dd39f" translate="yes" xml:space="preserve">
          <source>However, the above does not account for amortization of index reads across repeated index scans.</source>
          <target state="translated">然而,上述情况并没有考虑到重复索引扫描中索引读数的摊销。</target>
        </trans-unit>
        <trans-unit id="8c28ea9e20c2e7864029d4301f424d9903192d30" translate="yes" xml:space="preserve">
          <source>However, the current implementation ignores any supplied array size limits, i.e., the behavior is the same as for arrays of unspecified length.</source>
          <target state="translated">然而,当前的实现忽略了任何提供的数组大小限制,也就是说,行为与未指定长度的数组相同。</target>
        </trans-unit>
        <trans-unit id="e7668db05f29105ac82edf505ab55c50a37483ff" translate="yes" xml:space="preserve">
          <source>However, the first and second calls will prefer more-specific functions, if available:</source>
          <target state="translated">但是,如果有的话,第一次和第二次调用会更倾向于特定的函数。</target>
        </trans-unit>
        <trans-unit id="8dd49b73a6bd91b9638ef49c19702f4c5cff091d" translate="yes" xml:space="preserve">
          <source>However, the index can also be used in queries that do not involve &lt;code&gt;order_nr&lt;/code&gt; at all, e.g.:</source>
          <target state="translated">但是，索引也可以用于完全不涉及 &lt;code&gt;order_nr&lt;/code&gt; 的查询中，例如：</target>
        </trans-unit>
        <trans-unit id="a2b5348adbefd43e71711c0de0facb597d742b53" translate="yes" xml:space="preserve">
          <source>However, the index could not be used for queries like the following, because though the operator &lt;code&gt;?&lt;/code&gt; is indexable, it is not applied directly to the indexed column &lt;code&gt;jdoc&lt;/code&gt;:</source>
          <target state="translated">但是，索引不能用于以下查询，因为尽管运算符 &lt;code&gt;?&lt;/code&gt; 是可索引的，它不直接应用于索引列 &lt;code&gt;jdoc&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="30d62ecc57d7df5a78dd582f05557b7fb23c077b" translate="yes" xml:space="preserve">
          <source>However, the second query may give unexpected results if &lt;code&gt;salesmen&lt;/code&gt;.&lt;code&gt;id&lt;/code&gt; is not a unique key, whereas the first query is guaranteed to raise an error if there are multiple &lt;code&gt;id&lt;/code&gt; matches. Also, if there is no match for a particular &lt;code&gt;accounts&lt;/code&gt;.&lt;code&gt;sales_id&lt;/code&gt; entry, the first query will set the corresponding name fields to NULL, whereas the second query will not update that row at all.</source>
          <target state="translated">但是，如果 &lt;code&gt;salesmen&lt;/code&gt; ，第二个查询可能会给出意外结果。 &lt;code&gt;id&lt;/code&gt; 不是唯一键，但是如果有多个 &lt;code&gt;id&lt;/code&gt; 匹配项，则保证第一个查询会引发错误。另外，如果没有针对特定 &lt;code&gt;accounts&lt;/code&gt; 匹配项。 &lt;code&gt;sales_id&lt;/code&gt; 条目中，第一个查询会将相应的名称字段设置为NULL，而第二个查询根本不会更新该行。</target>
        </trans-unit>
        <trans-unit id="ac0aa3ca3aadbd76b33daf42fe2d9f38b7a21341" translate="yes" xml:space="preserve">
          <source>However, this is not recommended. Floating point numbers should not be used to handle money due to the potential for rounding errors.</source>
          <target state="translated">但是,不建议这样做。浮点数字不应用来处理金钱,因为有可能出现四舍五入的错误。</target>
        </trans-unit>
        <trans-unit id="e7a5e278e5a670634fe4d0890f09f0f07f287151" translate="yes" xml:space="preserve">
          <source>However, this only works for types whose names are also valid as function names. For example, &lt;code&gt;double precision&lt;/code&gt; cannot be used this way, but the equivalent &lt;code&gt;float8&lt;/code&gt; can. Also, the names &lt;code&gt;interval&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt;, and &lt;code&gt;timestamp&lt;/code&gt; can only be used in this fashion if they are double-quoted, because of syntactic conflicts. Therefore, the use of the function-like cast syntax leads to inconsistencies and should probably be avoided.</source>
          <target state="translated">但是，这仅适用于名称也可用作函数名称的类型。例如，不能以这种方式使用 &lt;code&gt;double precision&lt;/code&gt; ，但是可以使用等效的 &lt;code&gt;float8&lt;/code&gt; 。此外，由于语法冲突，如果将名称， &lt;code&gt;time&lt;/code&gt; &lt;code&gt;interval&lt;/code&gt; 和 &lt;code&gt;timestamp&lt;/code&gt; 双引号，则只能以这种方式使用。因此，使用类似函数的强制转换语法会导致不一致，应避免使用。</target>
        </trans-unit>
        <trans-unit id="ab41e0a4da3a7de05a4b7068787924b0e3cb154d" translate="yes" xml:space="preserve">
          <source>However, this quickly becomes tedious for large arrays, and is not helpful if the size of the array is unknown. An alternative method is described in &lt;a href=&quot;functions-comparisons&quot;&gt;Section 9.23&lt;/a&gt;. The above query could be replaced by:</source>
          <target state="translated">但是，这对于大型阵列很快变得很乏味，如果阵列的大小未知，这将无济于事。另一种方法在&lt;a href=&quot;functions-comparisons&quot;&gt;9.23节中&lt;/a&gt;描述。上面的查询可以替换为：</target>
        </trans-unit>
        <trans-unit id="36ec95290f6f5b115ce53145f3f502e1463f93d8" translate="yes" xml:space="preserve">
          <source>However, this quickly becomes tedious for large arrays, and is not helpful if the size of the array is unknown. An alternative method is described in &lt;a href=&quot;functions-comparisons&quot;&gt;Section 9.24&lt;/a&gt;. The above query could be replaced by:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49121f1f7d3b19887ff759c895c872e45fe0450d" translate="yes" xml:space="preserve">
          <source>However, unless a module is specifically designed to be used in this way by non-superusers, this is usually not the right setting to use. Look at &lt;a href=&quot;runtime-config-client#GUC-SESSION-PRELOAD-LIBRARIES&quot;&gt;session_preload_libraries&lt;/a&gt; instead.</source>
          <target state="translated">但是，除非将模块专门设计为非超级用户以这种方式使用，否则通常不是正确的设置。请改为查看&lt;a href=&quot;runtime-config-client#GUC-SESSION-PRELOAD-LIBRARIES&quot;&gt;session_preload_libraries&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f4744bf3a8101c9dd55ef2a04f348b62af8e9994" translate="yes" xml:space="preserve">
          <source>However, while the directory contents are secure, the default client authentication setup allows any local user to connect to the database and even become the database superuser. If you do not trust other local users, we recommend you use one of &lt;code&gt;initdb&lt;/code&gt;'s &lt;code&gt;-W&lt;/code&gt;, &lt;code&gt;--pwprompt&lt;/code&gt; or &lt;code&gt;--pwfile&lt;/code&gt; options to assign a password to the database superuser. Also, specify &lt;code&gt;-A md5&lt;/code&gt; or &lt;code&gt;-A password&lt;/code&gt; so that the default &lt;code&gt;trust&lt;/code&gt; authentication mode is not used; or modify the generated &lt;code&gt;pg_hba.conf&lt;/code&gt; file after running &lt;code&gt;initdb&lt;/code&gt;, but &lt;em&gt;before&lt;/em&gt; you start the server for the first time. (Other reasonable approaches include using &lt;code&gt;peer&lt;/code&gt; authentication or file system permissions to restrict connections. See &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt; for more information.)</source>
          <target state="translated">但是，尽管目录内容是安全的，但默认的客户端身份验证设置允许任何本地用户连接到数据库，甚至成为数据库超级用户。如果您不信任其他本地用户，我们建议您使用 &lt;code&gt;initdb&lt;/code&gt; 的 &lt;code&gt;-W&lt;/code&gt; ，-- &lt;code&gt;--pwprompt&lt;/code&gt; 或 &lt;code&gt;--pwfile&lt;/code&gt; 选项之一来为数据库超级用户分配密码。另外，指定 &lt;code&gt;-A md5&lt;/code&gt; 或 &lt;code&gt;-A password&lt;/code&gt; 以便不使用默认的 &lt;code&gt;trust&lt;/code&gt; 身份验证模式。或在运行 &lt;code&gt;initdb&lt;/code&gt; 之后但&lt;em&gt;之前&lt;/em&gt;修改生成的 &lt;code&gt;pg_hba.conf&lt;/code&gt; 文件&lt;em&gt;&lt;/em&gt;您是第一次启动服务器。（其他合理的方法包括使用 &lt;code&gt;peer&lt;/code&gt; 身份验证或文件系统权限来限制连接。有关更多信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;第20章&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="c256b10902d81d3561c1f226e5f4cb70fe93cebd" translate="yes" xml:space="preserve">
          <source>However, while the directory contents are secure, the default client authentication setup allows any local user to connect to the database and even become the database superuser. If you do not trust other local users, we recommend you use one of &lt;code&gt;initdb&lt;/code&gt;'s &lt;code&gt;-W&lt;/code&gt;, &lt;code&gt;--pwprompt&lt;/code&gt; or &lt;code&gt;--pwfile&lt;/code&gt; options to assign a password to the database superuser. Also, specify &lt;code&gt;-A md5&lt;/code&gt; or &lt;code&gt;-A password&lt;/code&gt; so that the default &lt;code&gt;trust&lt;/code&gt; authentication mode is not used; or modify the generated &lt;code&gt;pg_hba.conf&lt;/code&gt; file after running &lt;code&gt;initdb&lt;/code&gt;, but &lt;em&gt;before&lt;/em&gt; you start the server for the first time. (Other reasonable approaches include using &lt;code&gt;peer&lt;/code&gt; authentication or file system permissions to restrict connections. See &lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt; for more information.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57ff938f130455fd7c5423b61feb93bb1fcef3bc" translate="yes" xml:space="preserve">
          <source>Huge pages are known as large pages on Windows. To use them, you need to assign the user right Lock Pages in Memory to the Windows user account that runs PostgreSQL. You can use Windows Group Policy tool (gpedit.msc) to assign the user right Lock Pages in Memory. To start the database server on the command prompt as a standalone process, not as a Windows service, the command prompt must be run as an administrator or User Access Control (UAC) must be disabled. When the UAC is enabled, the normal command prompt revokes the user right Lock Pages in Memory when started.</source>
          <target state="translated">巨大的页面在Windows上被称为大页面。要使用它们,你需要为运行PostgreSQL的Windows用户账户分配锁定内存中的页面的用户权限。你可以使用Windows组策略工具(gpedit.msc)来分配用户权限Lock Pages in Memory。要在命令提示符上以独立进程而不是Windows服务的方式启动数据库服务器,必须以管理员身份运行命令提示符,或者禁用用户访问控制(UAC)。当启用UAC时,正常的命令提示符在启动时就会撤销用户在内存中的锁页权。</target>
        </trans-unit>
        <trans-unit id="1f8503304967af954a53ebd078e0b78234d12b54" translate="yes" xml:space="preserve">
          <source>Hyperbolic cosine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cd3a73e406381253718a612b965e023a4f56989" translate="yes" xml:space="preserve">
          <source>Hyperbolic sine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9197379568d57d2a0451b5bb547d22e3de876985" translate="yes" xml:space="preserve">
          <source>Hyperbolic tangent</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8bf3846fb1be35204cb20d765d7076251578e99" translate="yes" xml:space="preserve">
          <source>Hyphenated word part, all ASCII</source>
          <target state="translated">连字符字部分,全部为ASCII码</target>
        </trans-unit>
        <trans-unit id="8cdd097739f98ad844abd99f2945f21997a9eb1e" translate="yes" xml:space="preserve">
          <source>Hyphenated word part, all letters</source>
          <target state="translated">连字符词部分,所有字母</target>
        </trans-unit>
        <trans-unit id="e93c4156f46693ca03a7e7a80ab8d3ba346ec445" translate="yes" xml:space="preserve">
          <source>Hyphenated word part, letters and digits</source>
          <target state="translated">连字符的单词部分、字母和数字</target>
        </trans-unit>
        <trans-unit id="5b3864b1f64d7c5d3d32b1aa431d4fc8168f5866" translate="yes" xml:space="preserve">
          <source>Hyphenated word, all ASCII</source>
          <target state="translated">连字符,全部为ASCII码</target>
        </trans-unit>
        <trans-unit id="913f77eb20ad8621544651272e4864006cc9a993" translate="yes" xml:space="preserve">
          <source>Hyphenated word, all letters</source>
          <target state="translated">连字符词,所有字母</target>
        </trans-unit>
        <trans-unit id="f8a2b7bdb3666b53d93dd9a984de988e23d346eb" translate="yes" xml:space="preserve">
          <source>Hyphenated word, letters and digits</source>
          <target state="translated">连字符词、字母和数字</target>
        </trans-unit>
        <trans-unit id="b4d527f11debd0a7c15ff494a4d7c586833b355b" translate="yes" xml:space="preserve">
          <source>I believe this union:</source>
          <target state="translated">我相信这个联盟。</target>
        </trans-unit>
        <trans-unit id="778d85fd9d1cf9d0bbf34776934bafa267e37666" translate="yes" xml:space="preserve">
          <source>ICU &amp;ldquo;root&amp;rdquo; collation. Use this to get a reasonable language-agnostic sort order.</source>
          <target state="translated">ICU&amp;ldquo;根&amp;rdquo;整理。使用它来获得合理的与语言无关的排序顺序。</target>
        </trans-unit>
        <trans-unit id="4186bb5b6042e95ce616f6bfea478c30a4a80a0a" translate="yes" xml:space="preserve">
          <source>ICU allows collations to be customized beyond the basic language+country set that is preloaded by &lt;code&gt;initdb&lt;/code&gt;. Users are encouraged to define their own collation objects that make use of these facilities to suit the sorting behavior to their requirements. See &lt;a href=&quot;http://userguide.icu-project.org/locale&quot;&gt;http://userguide.icu-project.org/locale&lt;/a&gt; and &lt;a href=&quot;http://userguide.icu-project.org/collation/api&quot;&gt;http://userguide.icu-project.org/collation/api&lt;/a&gt; for information on ICU locale naming. The set of acceptable names and attributes depends on the particular ICU version.</source>
          <target state="translated">ICU允许自定义归类规则，而不是由 &lt;code&gt;initdb&lt;/code&gt; 预加载的基本语言+国家/地区集。鼓励用户定义自己的归类对象，这些对象使用这些功能来使排序行为符合其要求。有关ICU语言环境命名的信息，请参见&lt;a href=&quot;http://userguide.icu-project.org/locale&quot;&gt;http://userguide.icu-project.org/locale&lt;/a&gt;和&lt;a href=&quot;http://userguide.icu-project.org/collation/api&quot;&gt;http://userguide.icu-project.org/collat​​ion/api&lt;/a&gt;。可接受的名称和属性集取决于特定的ICU版本。</target>
        </trans-unit>
        <trans-unit id="6f538ad1e5ea2537ef4ecc8ee6d246518b569e28" translate="yes" xml:space="preserve">
          <source>ICU?</source>
          <target state="translated">ICU?</target>
        </trans-unit>
        <trans-unit id="85ddc12eb726993ba7496e593b7b33905cb52428" translate="yes" xml:space="preserve">
          <source>ID of a role that has a member</source>
          <target state="translated">角色的ID,它有一个成员</target>
        </trans-unit>
        <trans-unit id="5e2534334ba3879c3b535d5349da57994812e977" translate="yes" xml:space="preserve">
          <source>ID of a role that is a member of &lt;code&gt;roleid&lt;/code&gt;</source>
          <target state="translated">作为 &lt;code&gt;roleid&lt;/code&gt; 成员的角色的ID</target>
        </trans-unit>
        <trans-unit id="b3334a0f3355b9fb358c2a763909308ff227db92" translate="yes" xml:space="preserve">
          <source>ID of role</source>
          <target state="translated">角色ID</target>
        </trans-unit>
        <trans-unit id="00ab5d608ce03301bac5fabc168033a98fb8425a" translate="yes" xml:space="preserve">
          <source>ID of the role that granted this membership</source>
          <target state="translated">授予该成员资格的角色ID</target>
        </trans-unit>
        <trans-unit id="4acecf86a885801175aac9f839c4e27dfcd0bb71" translate="yes" xml:space="preserve">
          <source>ID of the transaction targeted by the lock, or null if the target is not a transaction ID</source>
          <target state="translated">锁定的交易ID,如果目标不是交易ID,则为空。</target>
        </trans-unit>
        <trans-unit id="4405588c83fcde9e77a297389a5a77edfc33fd81" translate="yes" xml:space="preserve">
          <source>ID of this group</source>
          <target state="translated">该组的ID</target>
        </trans-unit>
        <trans-unit id="364041630f947c82ae36797d2d8b4d8c51f1090b" translate="yes" xml:space="preserve">
          <source>ID of this user</source>
          <target state="translated">该用户的ID</target>
        </trans-unit>
        <trans-unit id="efeddb9b2b9bc9d252eb880921c3b8b3f041d65a" translate="yes" xml:space="preserve">
          <source>ID, in the range 1..&lt;code&gt;shared_buffers&lt;/code&gt;</source>
          <target state="translated">ID，范围为 &lt;code&gt;shared_buffers&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fab9fa5af6726f4fbc7c7dbc87a28acfc40a63e9" translate="yes" xml:space="preserve">
          <source>IEC</source>
          <target state="translated">IEC</target>
        </trans-unit>
        <trans-unit id="91e003cabbbc52544795f505584d809fe4bf1cdc" translate="yes" xml:space="preserve">
          <source>IEEE</source>
          <target state="translated">IEEE</target>
        </trans-unit>
        <trans-unit id="44285b6e9ccd859327d44fd855fe1b27a08233b1" translate="yes" xml:space="preserve">
          <source>IEEE Std 802-2001 specifies the second shown form (with hyphens) as the canonical form for MAC addresses, and specifies the first form (with colons) as the bit-reversed notation, so that 08-00-2b-01-02-03 = 01:00:4D:08:04:0C. This convention is widely ignored nowadays, and it is relevant only for obsolete network protocols (such as Token Ring). PostgreSQL makes no provisions for bit reversal, and all accepted formats use the canonical LSB order.</source>
          <target state="translated">IEEE Std 802-2001规定第二种所示形式(带连字符)为MAC地址的规范形式,并规定第一种形式(带冒号)为位逆记法,所以08-00-2b-01-02-03=01:00:4D:08:04:0C。这个约定现在被广泛忽视,它只与过时的网络协议(如Token Ring)有关。PostgreSQL没有对比特反转做出规定,所有被接受的格式都使用规范的LSB顺序。</target>
        </trans-unit>
        <trans-unit id="c6125697017457f602c07e148a748e8cb804d044" translate="yes" xml:space="preserve">
          <source>IEEE754 specifies that &lt;code&gt;NaN&lt;/code&gt; should not compare equal to any other floating-point value (including &lt;code&gt;NaN&lt;/code&gt;). In order to allow floating-point values to be sorted and used in tree-based indexes, PostgreSQL treats &lt;code&gt;NaN&lt;/code&gt; values as equal, and greater than all non-&lt;code&gt;NaN&lt;/code&gt; values.</source>
          <target state="translated">IEEE754指定 &lt;code&gt;NaN&lt;/code&gt; 不应比较等于任何其他浮点值（包括 &lt;code&gt;NaN&lt;/code&gt; ）。为了允许对浮点值进行排序并在基于树的索引中使用，PostgreSQL将 &lt;code&gt;NaN&lt;/code&gt; 值视为相等，并且大于所有非 &lt;code&gt;NaN&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="0d3a231ed1c6dcab8fa35edd0bd127d0e5d21d84" translate="yes" xml:space="preserve">
          <source>IMPORT FOREIGN SCHEMA</source>
          <target state="translated">导入外国市场</target>
        </trans-unit>
        <trans-unit id="b8d5fc1f41eb794e02ccf1b51b842239e54448da" translate="yes" xml:space="preserve">
          <source>IMPORT FOREIGN SCHEMA &amp;mdash; import table definitions from a foreign server</source>
          <target state="translated">IMPORT FOREIGN SCHEMA &amp;mdash;从外部服务器导入表定义</target>
        </trans-unit>
        <trans-unit id="c20ea07e32d25c072a65368c234d6f5a88f4521a" translate="yes" xml:space="preserve">
          <source>INSERT</source>
          <target state="translated">INSERT</target>
        </trans-unit>
        <trans-unit id="b42f874d7db1e2726d84a76cc0d5b0946a10b15b" translate="yes" xml:space="preserve">
          <source>INSERT &amp;mdash; create new rows in a table</source>
          <target state="translated">INSERT &amp;mdash;在表中创建新行</target>
        </trans-unit>
        <trans-unit id="48ef49cd856e5cecb996e0f1d379dbd5b56b7cb9" translate="yes" xml:space="preserve">
          <source>IP address mask, or null if not applicable</source>
          <target state="translated">IP地址掩码,如果不适用则为空</target>
        </trans-unit>
        <trans-unit id="998514d91724c3d88d4cab07518debfcd96862e2" translate="yes" xml:space="preserve">
          <source>IP address of the client connected to this WAL sender. If this field is null, it indicates that the client is connected via a Unix socket on the server machine.</source>
          <target state="translated">连接到这个WAL发送器的客户端的IP地址。如果该字段为空,则表示客户端是通过服务器机器上的Unix套接字连接的。</target>
        </trans-unit>
        <trans-unit id="26ec3318a4493a39e748c88c589f3baeb8b0af15" translate="yes" xml:space="preserve">
          <source>IP address of the client connected to this backend</source>
          <target state="translated">连接到这个后台的客户端的IP地址。</target>
        </trans-unit>
        <trans-unit id="4da843a738e5c670d4d958349979cce4c9e32eb3" translate="yes" xml:space="preserve">
          <source>IP address of the client connected to this backend. If this field is null, it indicates either that the client is connected via a Unix socket on the server machine or that this is an internal process such as autovacuum.</source>
          <target state="translated">连接到这个后端的客户端的IP地址,如果该字段为空,则表示客户端是通过服务器机器上的Unix套接字连接的,或者是自动吸尘器等内部进程。如果该字段为空,则表示客户端是通过服务器机器上的Unix套接字连接的,或者表示这是一个内部进程,如自动吸尘器。</target>
        </trans-unit>
        <trans-unit id="f4aa7e6cdf843e01253be3fd2becaee731842f78" translate="yes" xml:space="preserve">
          <source>IPC</source>
          <target state="translated">IPC</target>
        </trans-unit>
        <trans-unit id="e5ef9147dc5536f205d6a3c473e0918abe3ea487" translate="yes" xml:space="preserve">
          <source>IPC parameters can be adjusted using &lt;code&gt;sysctl&lt;/code&gt;, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82c9856123dd418f4774d9eae5cdc6c13b4a17dd" translate="yes" xml:space="preserve">
          <source>IPC parameters can be set in the System Administration Manager (SAM) under Kernel Configuration &amp;rarr; Configurable Parameters. Choose Create A New Kernel when you're done.</source>
          <target state="translated">可以在系统管理器（SAM）中的&amp;ldquo;内核配置&amp;rdquo;&amp;rarr;&amp;ldquo;可配置参数&amp;rdquo;下设置IPC参数。完成后，选择&amp;ldquo;创建新内核&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ab288f3447cf3cc34399c5b2b5851efa6c3d80a4" translate="yes" xml:space="preserve">
          <source>IPv4 and IPv6 hosts and networks</source>
          <target state="translated">IPv4和IPv6主机和网络</target>
        </trans-unit>
        <trans-unit id="86de966d86cc975242ef8e4aaaa8450d6855f8c5" translate="yes" xml:space="preserve">
          <source>IPv4 and IPv6 networks</source>
          <target state="translated">IPv4和IPv6网络</target>
        </trans-unit>
        <trans-unit id="570cca22ddf6e073a6dbd2cc896fd406204eb7b0" translate="yes" xml:space="preserve">
          <source>IPv4 or IPv6 host address</source>
          <target state="translated">IPv4或IPv6主机地址</target>
        </trans-unit>
        <trans-unit id="c2e4edd4992d9d0688f940e8473197cf9ffe481e" translate="yes" xml:space="preserve">
          <source>IPv4 or IPv6 network address</source>
          <target state="translated">IPv4或IPv6网络地址</target>
        </trans-unit>
        <trans-unit id="9d11567d01c59efb43ef67bb8206340e658f9d9d" translate="yes" xml:space="preserve">
          <source>ISBN &amp;lt;=&amp;gt; EAN13</source>
          <target state="translated">ISBN &amp;lt;=&amp;gt; EAN13</target>
        </trans-unit>
        <trans-unit id="bb9ab15de59e9d547e927c8c62069791df1e8268" translate="yes" xml:space="preserve">
          <source>ISBN &amp;lt;=&amp;gt; ISBN13</source>
          <target state="translated">ISBN &amp;lt;=&amp;gt; ISBN13</target>
        </trans-unit>
        <trans-unit id="a43d901bb73f40ccaba8783a1129360f50fba85d" translate="yes" xml:space="preserve">
          <source>ISBN13 &amp;lt;=&amp;gt; EAN13</source>
          <target state="translated">ISBN13 &amp;lt;=&amp;gt; EAN13</target>
        </trans-unit>
        <trans-unit id="4497b3ae9c75adbc043fd5847cc29356be8a5644" translate="yes" xml:space="preserve">
          <source>ISBN13, ISMN13, ISSN13 numbers are all EAN13 numbers.</source>
          <target state="translated">ISBN13、ISMN13、ISSN13号均为EAN13号。</target>
        </trans-unit>
        <trans-unit id="95889ddf7167ca49889a166a2e3858db51bb28d5" translate="yes" xml:space="preserve">
          <source>ISMN &amp;lt;=&amp;gt; EAN13</source>
          <target state="translated">ISMN &amp;lt;=&amp;gt; EAN13</target>
        </trans-unit>
        <trans-unit id="d9a94674870da708d9a2ffc2a85d2b1561319391" translate="yes" xml:space="preserve">
          <source>ISMN &amp;lt;=&amp;gt; ISMN13</source>
          <target state="translated">ISMN &amp;lt;=&amp;gt; ISMN13</target>
        </trans-unit>
        <trans-unit id="9f6fa2a3d8d31764fc531c626fb4ec439b13e49d" translate="yes" xml:space="preserve">
          <source>ISMN13 &amp;lt;=&amp;gt; EAN13</source>
          <target state="translated">ISMN13 &amp;lt;=&amp;gt; EAN13</target>
        </trans-unit>
        <trans-unit id="4f325d995b6d028ccc75771b1679537b623521c4" translate="yes" xml:space="preserve">
          <source>ISO</source>
          <target state="translated">ISO</target>
        </trans-unit>
        <trans-unit id="445867d9c88cb9ec795d4d1edb4358f7f32ed23d" translate="yes" xml:space="preserve">
          <source>ISO 8601</source>
          <target state="translated">ISO 8601</target>
        </trans-unit>
        <trans-unit id="03b66feb77a5287d927a40831615b0a53c5c265e" translate="yes" xml:space="preserve">
          <source>ISO 8601 &amp;ldquo;alternative format&amp;rdquo;: same meaning as above</source>
          <target state="translated">ISO 8601&amp;ldquo;替代格式&amp;rdquo;：与上述含义相同</target>
        </trans-unit>
        <trans-unit id="347f83fd1ecbce8da8703c53ec0ee71401af00f9" translate="yes" xml:space="preserve">
          <source>ISO 8601 &amp;ldquo;format with designators&amp;rdquo;: same meaning as above</source>
          <target state="translated">ISO 8601&amp;ldquo;带有指示符的格式&amp;rdquo;：与上述含义相同</target>
        </trans-unit>
        <trans-unit id="249eb6740bd82a6c1db53f9cab25650c97a5d209" translate="yes" xml:space="preserve">
          <source>ISO 8601 day of the week, Monday (&lt;code&gt;1&lt;/code&gt;) to Sunday (&lt;code&gt;7&lt;/code&gt;)</source>
          <target state="translated">ISO 8601的星期几，星期一（ &lt;code&gt;1&lt;/code&gt; ）至星期日（ &lt;code&gt;7&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="9d2092d27bf384f64eb368a2dfd612d31022bd2b" translate="yes" xml:space="preserve">
          <source>ISO 8601 specifies the use of uppercase letter &lt;code&gt;T&lt;/code&gt; to separate the date and time. PostgreSQL accepts that format on input, but on output it uses a space rather than &lt;code&gt;T&lt;/code&gt;, as shown above. This is for readability and for consistency with RFC 3339 as well as some other database systems.</source>
          <target state="translated">ISO 8601指定使用大写字母 &lt;code&gt;T&lt;/code&gt; 分隔日期和时间。PostgreSQL在输入上接受该格式，但是在输出上，它使用空格而不是 &lt;code&gt;T&lt;/code&gt; ，如上所示。这是为了提高可读性和与RFC 3339以及某些其他数据库系统的一致性。</target>
        </trans-unit>
        <trans-unit id="5e8d83297c37a8caa9129a785251aaffead6b3d8" translate="yes" xml:space="preserve">
          <source>ISO 8601 week-numbering year (4 or more digits)</source>
          <target state="translated">ISO 8601周号年(4位或以上)</target>
        </trans-unit>
        <trans-unit id="5113b76aa827aecd1b2fbeb19739776b2cdcbdb5" translate="yes" xml:space="preserve">
          <source>ISO 8601, SQL standard</source>
          <target state="translated">ISO 8601,SQL标准</target>
        </trans-unit>
        <trans-unit id="c4bb947ff5dc5345f70f6892f02bf85a04d4eb7d" translate="yes" xml:space="preserve">
          <source>ISO 8601; January 8 in any mode (recommended format)</source>
          <target state="translated">ISO 8601;1月8日,任何模式(推荐格式)</target>
        </trans-unit>
        <trans-unit id="a83c80f67456b395aa2704158f1dc68957610271" translate="yes" xml:space="preserve">
          <source>ISO 8601; January 8, 1999 in any mode</source>
          <target state="translated">ISO 8601;1999年1月8日,在任何模式下。</target>
        </trans-unit>
        <trans-unit id="b1922fbd22025577b8a5e43c812e096c3b9acffc" translate="yes" xml:space="preserve">
          <source>ISO 8859-1, ECMA 94</source>
          <target state="translated">ISO 8859-1、ECMA 94</target>
        </trans-unit>
        <trans-unit id="276d48941fbc0543fbb5ce642fe1dc3b05b9bb7d" translate="yes" xml:space="preserve">
          <source>ISO 8859-10, ECMA 144</source>
          <target state="translated">ISO 8859-10、ECMA 144</target>
        </trans-unit>
        <trans-unit id="b206da53a9051bf3226d71a6e114418f28766469" translate="yes" xml:space="preserve">
          <source>ISO 8859-13</source>
          <target state="translated">ISO 8859-13</target>
        </trans-unit>
        <trans-unit id="26424d0dadf461ca6901513d3dcfc085ec66b2c7" translate="yes" xml:space="preserve">
          <source>ISO 8859-14</source>
          <target state="translated">ISO 8859-14</target>
        </trans-unit>
        <trans-unit id="b292668cb49c44b020b58d7d79cd50329ab61aed" translate="yes" xml:space="preserve">
          <source>ISO 8859-15</source>
          <target state="translated">ISO 8859-15</target>
        </trans-unit>
        <trans-unit id="6a937cb9225885ed540430a532e08182311c8fb7" translate="yes" xml:space="preserve">
          <source>ISO 8859-16, ASRO SR 14111</source>
          <target state="translated">ISO 8859-16、ASRO SR 14111</target>
        </trans-unit>
        <trans-unit id="5f8eb67d9b294dc7fa2960e49427ec254bf78d3e" translate="yes" xml:space="preserve">
          <source>ISO 8859-2, ECMA 94</source>
          <target state="translated">ISO 8859-2、ECMA 94</target>
        </trans-unit>
        <trans-unit id="34bfa7b1e0970a505b7c18beda35ee12ae67b627" translate="yes" xml:space="preserve">
          <source>ISO 8859-3, ECMA 94</source>
          <target state="translated">ISO 8859-3、ECMA 94</target>
        </trans-unit>
        <trans-unit id="19f1d5efe10cfb525dac348f64f156d08531f5ba" translate="yes" xml:space="preserve">
          <source>ISO 8859-4, ECMA 94</source>
          <target state="translated">ISO 8859-4、ECMA 94</target>
        </trans-unit>
        <trans-unit id="958ae0517642b5a63a0ba42f16e7dba51f3f03b9" translate="yes" xml:space="preserve">
          <source>ISO 8859-5, ECMA 113</source>
          <target state="translated">ISO 8859-5、ECMA 113</target>
        </trans-unit>
        <trans-unit id="edc58fa1dfcc675f8f0e7cd9ba637022f963b9a5" translate="yes" xml:space="preserve">
          <source>ISO 8859-6, ECMA 114</source>
          <target state="translated">ISO 8859-6、ECMA 114</target>
        </trans-unit>
        <trans-unit id="ac642f9b939a7e25fc9c152794f7c55763fbe736" translate="yes" xml:space="preserve">
          <source>ISO 8859-7, ECMA 118</source>
          <target state="translated">ISO 8859-7、ECMA 118</target>
        </trans-unit>
        <trans-unit id="aafb9bf8d9a3dd18a9bc858aa3091007431a81fe" translate="yes" xml:space="preserve">
          <source>ISO 8859-8, ECMA 121</source>
          <target state="translated">ISO 8859-8、ECMA 121</target>
        </trans-unit>
        <trans-unit id="561419819864b8b7eafa254ff17c2c5838572d02" translate="yes" xml:space="preserve">
          <source>ISO 8859-9, ECMA 128</source>
          <target state="translated">ISO 8859-9,ECMA 128</target>
        </trans-unit>
        <trans-unit id="19fa6eb3258ffb4709ac1dfbba399d0753e7e88f" translate="yes" xml:space="preserve">
          <source>ISO-8601 offset for PST</source>
          <target state="translated">ISO-8601 PST偏移量</target>
        </trans-unit>
        <trans-unit id="d9bfc4c480632e7b109f99ac77c51a2a5260171b" translate="yes" xml:space="preserve">
          <source>ISSN</source>
          <target state="translated">ISSN</target>
        </trans-unit>
        <trans-unit id="3941c970e85e394c43837d5b44cc1bf0483f215f" translate="yes" xml:space="preserve">
          <source>ISSN &amp;lt;=&amp;gt; EAN13</source>
          <target state="translated">ISSN &amp;lt;=&amp;gt; EAN13</target>
        </trans-unit>
        <trans-unit id="a203140c0f91a7564ce62d86b204a626e15ee7d8" translate="yes" xml:space="preserve">
          <source>ISSN &amp;lt;=&amp;gt; ISSN13</source>
          <target state="translated">ISSN &amp;lt;=&amp;gt; ISSN13</target>
        </trans-unit>
        <trans-unit id="57b604002c866aad17fa814a63620ac73af4bf08" translate="yes" xml:space="preserve">
          <source>ISSN13 &amp;lt;=&amp;gt; EAN13</source>
          <target state="translated">ISSN13 &amp;lt;=&amp;gt; EAN13</target>
        </trans-unit>
        <trans-unit id="0a6d0a09ee6e1eec933513081c533fbe57cab3a4" translate="yes" xml:space="preserve">
          <source>Ident Authentication</source>
          <target state="translated">身份认证</target>
        </trans-unit>
        <trans-unit id="06b6ace8ca3f18249e8ba4ea9090c0f34564ce1c" translate="yes" xml:space="preserve">
          <source>Identifier</source>
          <target state="translated">Identifier</target>
        </trans-unit>
        <trans-unit id="64ed35bcb9eba82bb5083c305000e3e8e174b736" translate="yes" xml:space="preserve">
          <source>Identifier of the large object that includes this page</source>
          <target state="translated">包含本页面的大对象的标识符。</target>
        </trans-unit>
        <trans-unit id="d19347e41a5213caf5fbef640d085e03cc5288d2" translate="yes" xml:space="preserve">
          <source>Identifies a function taking or returning an unspecified row type.</source>
          <target state="translated">识别一个函数,接受或返回一个未指定的行类型。</target>
        </trans-unit>
        <trans-unit id="9f9c67a87f9e8c8e7cd1eee8d202259f233b1765" translate="yes" xml:space="preserve">
          <source>Identifies a not-yet-resolved type, e.g. of an undecorated string literal.</source>
          <target state="translated">识别一个尚未解析的类型,例如一个未装饰的字符串文字。</target>
        </trans-unit>
        <trans-unit id="c41af45b5400af4443194716d5554aafcc29e526" translate="yes" xml:space="preserve">
          <source>Identifies a not-yet-resolved type, e.g., of an undecorated string literal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7cbe1f08ac13359acc228819549de4cb50db912" translate="yes" xml:space="preserve">
          <source>Identifies a representation of DDL commands that is available to event triggers.</source>
          <target state="translated">识别事件触发器可用的DDL命令的表示。</target>
        </trans-unit>
        <trans-unit id="c10498b4e600d39b28759a6ca1704d299a1166cc" translate="yes" xml:space="preserve">
          <source>Identifies the event for which this trigger fires</source>
          <target state="translated">识别该触发器所触发的事件。</target>
        </trans-unit>
        <trans-unit id="708e5b0969ad9b9e70cb24a115182be857e71a40" translate="yes" xml:space="preserve">
          <source>If 1, OIDs are included in the data; if 0, not. Oid system columns are not supported in PostgreSQL anymore, but the format still contains the indicator.</source>
          <target state="translated">如果为1,则数据中包含OID;如果为0,则不包含。Oid系统列在PostgreSQL中已经不支持了,但格式仍然包含指标。</target>
        </trans-unit>
        <trans-unit id="bb8295c4be7fefd76f1788c97ecf7d786d2a81d6" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;runtime-config-logging#GUC-CLUSTER-NAME&quot;&gt;cluster_name&lt;/a&gt; has been configured the cluster name will also be shown in &lt;code&gt;ps&lt;/code&gt; output:</source>
          <target state="translated">如果已配置&lt;a href=&quot;runtime-config-logging#GUC-CLUSTER-NAME&quot;&gt;cluster_name，&lt;/a&gt;则群集名称还将显示在 &lt;code&gt;ps&lt;/code&gt; 输出中：</target>
        </trans-unit>
        <trans-unit id="8a629049c6dc481b39f88d9e65ac7e85ce3a796f" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;runtime-config-query#GUC-JIT&quot;&gt;jit&lt;/a&gt; is set to &lt;code&gt;off&lt;/code&gt;, or if no JIT implementation is available (for example because the server was compiled without &lt;code&gt;--with-llvm&lt;/code&gt;), JIT will not be performed, even if it would be beneficial based on the above criteria. Setting &lt;a href=&quot;runtime-config-query#GUC-JIT&quot;&gt;jit&lt;/a&gt; to &lt;code&gt;off&lt;/code&gt; has effects at both plan and execution time.</source>
          <target state="translated">如果将&lt;a href=&quot;runtime-config-query#GUC-JIT&quot;&gt;jit&lt;/a&gt;设置为 &lt;code&gt;off&lt;/code&gt; ，或者没有可用的JIT实现（例如，因为服务器在编译时未使用 &lt;code&gt;--with-llvm&lt;/code&gt; ），则即使执行JIT，即使基于上述条件也会有所帮助。将&lt;a href=&quot;runtime-config-query#GUC-JIT&quot;&gt;jit&lt;/a&gt;设置为 &lt;code&gt;off&lt;/code&gt; 对计划和执行时间都有影响。</target>
        </trans-unit>
        <trans-unit id="b58e6f959038162d8a80485253d8424b9f1e1e29" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;runtime-config-replication#GUC-SYNCHRONOUS-STANDBY-NAMES&quot;&gt;synchronous_standby_names&lt;/a&gt; is non-empty, &lt;code&gt;synchronous_commit&lt;/code&gt; also controls whether transaction commits will wait for their WAL records to be processed on the standby server(s).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9523a6aef92c0b8b469d3754e7282b8f5942c267" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;runtime-config-replication#GUC-SYNCHRONOUS-STANDBY-NAMES&quot;&gt;synchronous_standby_names&lt;/a&gt; is non-empty, this parameter also controls whether or not transaction commits will wait for their WAL records to be replicated to the standby server(s). When set to &lt;code&gt;on&lt;/code&gt;, commits will wait until replies from the current synchronous standby(s) indicate they have received the commit record of the transaction and flushed it to disk. This ensures the transaction will not be lost unless both the primary and all synchronous standbys suffer corruption of their database storage. When set to &lt;code&gt;remote_apply&lt;/code&gt;, commits will wait until replies from the current synchronous standby(s) indicate they have received the commit record of the transaction and applied it, so that it has become visible to queries on the standby(s). When set to &lt;code&gt;remote_write&lt;/code&gt;, commits will wait until replies from the current synchronous standby(s) indicate they have received the commit record of the transaction and written it out to their operating system. This setting is sufficient to ensure data preservation even if a standby instance of PostgreSQL were to crash, but not if the standby suffers an operating-system-level crash, since the data has not necessarily reached stable storage on the standby. Finally, the setting &lt;code&gt;local&lt;/code&gt; causes commits to wait for local flush to disk, but not for replication. This is not usually desirable when synchronous replication is in use, but is provided for completeness.</source>
          <target state="translated">如果&lt;a href=&quot;runtime-config-replication#GUC-SYNCHRONOUS-STANDBY-NAMES&quot;&gt;sync_standby_names&lt;/a&gt;为非空，则此参数还控制事务提交是否将等待其WAL记录复制到备用服务器。设置为 &lt;code&gt;on&lt;/code&gt; 时，提交将一直等待，直到当前同步备用数据库的答复指示它们已接收到事务的提交记录并将其刷新到磁盘。这样可以确保事务不会丢失，除非主备用数据库和所有同步备用数据库都遭受数据库存储损坏。当设置为 &lt;code&gt;remote_apply&lt;/code&gt; 时，提交将一直等待，直到当前同步备用数据库的答复指示它们已接收到事务的提交记录并应用了该记录后，该记录才可在备用数据库上的查询中看到。设置为 &lt;code&gt;remote_write&lt;/code&gt; ，提交将一直等到当前同步备用数据库的答复指示它们已收到事务的提交记录并将其写出到操作系统中。即使PostgreSQL的一个备用实例崩溃，此设置也足以确保数据保存，但是即使备用数据库遭受操作系统级崩溃，此设置也足以确保数据保存，因为数据不一定已到达备用数据库上的稳定存储。最后， &lt;code&gt;local&lt;/code&gt; 设置导致提交等待本地刷新到磁盘，而不是复制。当使用同步复制时，这通常不是所希望的，但出于完整性考虑而提供。</target>
        </trans-unit>
        <trans-unit id="1a25dc46209d8ed1ade19ed10060c5c528c285e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;+&lt;/code&gt; is appended to the command name, the sum of the sizes of each relation's partitions is also displayed, along with the relation's description. If &lt;code&gt;n&lt;/code&gt; is combined with &lt;code&gt;+&lt;/code&gt;, two sizes are shown: one including the total size of directly-attached leaf partitions, and another showing the total size of all partitions, including indirectly attached sub-partitions.</source>
          <target state="translated">如果在命令名称后附加 &lt;code&gt;+&lt;/code&gt; ，则还将显示每个关系的分区大小的总和以及该关系的描述。如果 &lt;code&gt;n&lt;/code&gt; 与 &lt;code&gt;+&lt;/code&gt; 组合，则显示两种大小：一种包含直接连接的叶子分区的总大小，另一种显示所有分区的总大小，包括间接连接的子分区。</target>
        </trans-unit>
        <trans-unit id="f1cb07ba733b8d98ef45c815d6dfcd5240fbfb93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;+&lt;/code&gt; is appended to the command name, then the output lines are numbered from 1.</source>
          <target state="translated">如果在命令名称后附加 &lt;code&gt;+&lt;/code&gt; ，则输出行从1开始编号。</target>
        </trans-unit>
        <trans-unit id="070b09cd2b09c6b749465149e9d2da178b70c1ff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;+&lt;/code&gt; is appended to the command name, then the output lines are numbered, with the first line of the function body being line 1.</source>
          <target state="translated">如果在命令名称后附加 &lt;code&gt;+&lt;/code&gt; ，则对输出行进行编号，功能主体的第一行为行1。</target>
        </trans-unit>
        <trans-unit id="2d52331f0d53378e8895c635840bb2a68f08d247" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--latency-limit&lt;/code&gt; is used together with &lt;code&gt;--rate&lt;/code&gt;, a transaction can lag behind so much that it is already over the latency limit when the previous transaction ends, because the latency is calculated from the scheduled start time. Such transactions are not sent to the server, but are skipped altogether and counted separately.</source>
          <target state="translated">如果将 &lt;code&gt;--latency-limit&lt;/code&gt; 与 &lt;code&gt;--rate&lt;/code&gt; 一起使用，则事务可能会滞后很多，以至于上一个事务结束时它已经超过了延迟限制，因为延迟是根据计划的开始时间计算的。此类事务不会发送到服务器，但会完全跳过并单独计数。</target>
        </trans-unit>
        <trans-unit id="5b7745b7624e7dd43bb242cb0d62e7379c97ee2a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ALTER TYPE ... ADD VALUE&lt;/code&gt; (the form that adds a new value to an enum type) is executed inside a transaction block, the new value cannot be used until after the transaction has been committed.</source>
          <target state="translated">如果在事务块内执行 &lt;code&gt;ALTER TYPE ... ADD VALUE&lt;/code&gt; （将新值添加到枚举类型的窗体），则直到提交事务后才能使用新值。</target>
        </trans-unit>
        <trans-unit id="bb077bc49a16e30ee77115d9ffe115d963646660" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AND CHAIN&lt;/code&gt; is specified, a new transaction is immediately started with the same transaction characteristics (see &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt;) as the just finished one. Otherwise, no new transaction is started.</source>
          <target state="translated">如果指定了 &lt;code&gt;AND CHAIN&lt;/code&gt; ，则立即以与刚刚完成的&lt;a href=&quot;sql-set-transaction&quot;&gt;事务&lt;/a&gt;相同的事务特征（请参阅SET TRANSACTION）开始一个新事务。否则，不会启动任何新事务。</target>
        </trans-unit>
        <trans-unit id="d7c08e9bace5b5133ac34adca9a08f4fe042258e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;CALL&lt;/code&gt; is executed in a transaction block, then the called procedure cannot execute transaction control statements. Transaction control statements are only allowed if &lt;code&gt;CALL&lt;/code&gt; is executed in its own transaction.</source>
          <target state="translated">如果在事务块中执行 &lt;code&gt;CALL&lt;/code&gt; ,则被调用的过程将无法执行事务控制语句。仅当在自己的事务中执行 &lt;code&gt;CALL&lt;/code&gt; 时，才允许事务控制语句。</target>
        </trans-unit>
        <trans-unit id="848ec5bbdc5b00e6cc3d9f1bcaa95b1dc8f6e6eb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DEFAULT&lt;/code&gt; is specified, the table will be created as the default partition of the parent table. This option is not available for hash-partitioned tables. A partition key value not fitting into any other partition of the given parent will be routed to the default partition.</source>
          <target state="translated">如果指定了 &lt;code&gt;DEFAULT&lt;/code&gt; ，该表将被创建为父表的默认分区。此选项不适用于哈希分区表。不适合给定父级的任何其他分区的分区键值将被路由到默认分区。</target>
        </trans-unit>
        <trans-unit id="e7358add8de8561a637a99b57db04968568623ff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DISTINCT&lt;/code&gt; is specified in addition to an &lt;code&gt;order_by_clause&lt;/code&gt;, then all the &lt;code&gt;ORDER BY&lt;/code&gt; expressions must match regular arguments of the aggregate; that is, you cannot sort on an expression that is not included in the &lt;code&gt;DISTINCT&lt;/code&gt; list.</source>
          <target state="translated">如果除了 &lt;code&gt;order_by_clause&lt;/code&gt; 之外还指定了 &lt;code&gt;DISTINCT&lt;/code&gt; ，则所有 &lt;code&gt;ORDER BY&lt;/code&gt; 表达式必须匹配聚合的常规参数；否则，也就是说，您不能对 &lt;code&gt;DISTINCT&lt;/code&gt; 列表中未包含的表达式进行排序。</target>
        </trans-unit>
        <trans-unit id="30705d4f5de2e5919df753dbf707be6e61f46c94" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DO&lt;/code&gt; is executed in a transaction block, then the procedure code cannot execute transaction control statements. Transaction control statements are only allowed if &lt;code&gt;DO&lt;/code&gt; is executed in its own transaction.</source>
          <target state="translated">如果在事务块中执行 &lt;code&gt;DO&lt;/code&gt; ，则过程代码无法执行事务控制语句。仅当 &lt;code&gt;DO&lt;/code&gt; 在其自己的事务中执行时，才允许事务控制语句。</target>
        </trans-unit>
        <trans-unit id="0d029254e59ae42060c8fbefb0b0879b5e2662e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DROP EXPRESSION IF EXISTS&lt;/code&gt; is specified and the column is not a stored generated column, no error is thrown. In this case a notice is issued instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df6a86ce0cd5c24d459324e69a0c7e3798125378" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DROP IDENTITY IF EXISTS&lt;/code&gt; is specified and the column is not an identity column, no error is thrown. In this case a notice is issued instead.</source>
          <target state="translated">如果指定了 &lt;code&gt;DROP IDENTITY IF EXISTS&lt;/code&gt; 并且该列不是身份列，则不会引发任何错误。在这种情况下，将发出通知。</target>
        </trans-unit>
        <trans-unit id="895523ab1404bbeb5f8a66ec67423cf5c0e02e37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DROP ROLE&lt;/code&gt; is attempted while dependent objects still remain, it will issue messages identifying which objects need to be reassigned or dropped.</source>
          <target state="translated">如果在仍然保留从属对象的情况下尝试执行 &lt;code&gt;DROP ROLE&lt;/code&gt; ，它将发出消息，指出需要重新分配或删除哪些对象。</target>
        </trans-unit>
        <trans-unit id="da529f5ed28015eb2651a4b68ada28ed62e240c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FILTER&lt;/code&gt; is specified, then only the input rows for which the &lt;code&gt;filter_clause&lt;/code&gt; evaluates to true are fed to the aggregate function; other rows are discarded. For example:</source>
          <target state="translated">如果指定了 &lt;code&gt;FILTER&lt;/code&gt; ，则只有 &lt;code&gt;filter_clause&lt;/code&gt; 评估为true 的输入行才被馈送到聚合函数；其他行将被丢弃。例如：</target>
        </trans-unit>
        <trans-unit id="0bc024c5c56715620389a9f40a0a619b2dabf192" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FILTER&lt;/code&gt; is specified, then only the input rows for which the &lt;code&gt;filter_clause&lt;/code&gt; evaluates to true are fed to the window function; other rows are discarded. Only window functions that are aggregates accept a &lt;code&gt;FILTER&lt;/code&gt; clause.</source>
          <target state="translated">如果指定了 &lt;code&gt;FILTER&lt;/code&gt; ，则只有 &lt;code&gt;filter_clause&lt;/code&gt; 评估为true 的输入行被馈送到window函数；其他行将被丢弃。只有聚合的窗口函数才接受 &lt;code&gt;FILTER&lt;/code&gt; 子句。</target>
        </trans-unit>
        <trans-unit id="cd9e1d53d5d6b7dacb647bc6b43f3a0bb2b3f3ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FINALFUNC_EXTRA&lt;/code&gt; is specified, then in addition to the final state value and any direct arguments, the final function receives extra NULL values corresponding to the aggregate's regular (aggregated) arguments. This is mainly useful to allow correct resolution of the aggregate result type when a polymorphic aggregate is being defined.</source>
          <target state="translated">如果指定了 &lt;code&gt;FINALFUNC_EXTRA&lt;/code&gt; ，则除了最终状态值和任何直接参数之外，最终函数还将接收与聚合的常规（聚合）参数相对应的额外NULL值。当定义多态聚合时，这主要用于允许正确解析聚合结果类型。</target>
        </trans-unit>
        <trans-unit id="79c74fbef6be293db9ab06b3c7837e0fb4b62bf1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FOR UPDATE&lt;/code&gt;, &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt;, &lt;code&gt;FOR SHARE&lt;/code&gt; or &lt;code&gt;FOR KEY SHARE&lt;/code&gt; is specified, the &lt;code&gt;SELECT&lt;/code&gt; statement locks the selected rows against concurrent updates. (See &lt;a href=&quot;sql-select#SQL-FOR-UPDATE-SHARE&quot;&gt;The Locking Clause&lt;/a&gt; below.)</source>
          <target state="translated">如果指定了 &lt;code&gt;FOR UPDATE&lt;/code&gt; ， &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt; ， &lt;code&gt;FOR SHARE&lt;/code&gt; 或 &lt;code&gt;FOR KEY SHARE&lt;/code&gt; ，则 &lt;code&gt;SELECT&lt;/code&gt; 语句将锁定所选行以防止并发更新。（请参阅&lt;a href=&quot;sql-select#SQL-FOR-UPDATE-SHARE&quot;&gt;下面的锁定条款&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="a805c0a50f5da5361e847219abae4a282083ebad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FX&lt;/code&gt; is specified, a separator in the template string matches exactly one character in the input string. But note that the input string character is not required to be the same as the separator from the template string. For example, &lt;code&gt;to_timestamp('2000/JUN', 'FXYYYY MON')&lt;/code&gt; works, but &lt;code&gt;to_timestamp('2000/JUN', 'FXYYYY&amp;nbsp;&amp;nbsp;MON')&lt;/code&gt; returns an error because the second space in the template string consumes the letter &lt;code&gt;J&lt;/code&gt; from the input string.</source>
          <target state="translated">如果指定了 &lt;code&gt;FX&lt;/code&gt; ，则模板字符串中的分隔符正好匹配输入字符串中的一个字符。但是请注意，输入字符串字符不必与模板字符串的分隔符相同。例如， &lt;code&gt;to_timestamp('2000/JUN', 'FXYYYY MON')&lt;/code&gt; 起作用，但是 &lt;code&gt;to_timestamp('2000/JUN', 'FXYYYY&amp;nbsp;&amp;nbsp;MON')&lt;/code&gt; 返回错误，因为模板字符串中的第二个空格消耗了输入中的字母 &lt;code&gt;J&lt;/code&gt; 串。</target>
        </trans-unit>
        <trans-unit id="14af0e221ff15633d3dbc5822cb9a995fc47a018" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GENERIC_XLOG_FULL_IMAGE&lt;/code&gt; is not specified for a registered buffer, the generic WAL record contains a delta between the old and the new page images. This delta is based on byte-by-byte comparison. This is not very compact for the case of moving data within a page, and might be improved in the future.</source>
          <target state="translated">如果未为已注册的缓冲区指定 &lt;code&gt;GENERIC_XLOG_FULL_IMAGE&lt;/code&gt; ，则通用WAL记录将在新旧页面图像之间包含增量。此增量基于逐字节比较。对于在页面内移动数据的情况，这不是很紧凑，并且将来可能会得到改进。</target>
        </trans-unit>
        <trans-unit id="dd5c28224428244bd7b83410c113faa1c8237d3c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GRANT OPTION FOR&lt;/code&gt; is specified, only the grant option for the privilege is revoked, not the privilege itself. Otherwise, both the privilege and the grant option are revoked.</source>
          <target state="translated">如果指定了 &lt;code&gt;GRANT OPTION FOR&lt;/code&gt; ，则仅撤销特权的授予选项，而不撤销特权本身。否则，特权和授予选项都将被吊销。</target>
        </trans-unit>
        <trans-unit id="36e5c2c5c78fde83426abf27ef6c16ab41ff4995" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GRANTED BY&lt;/code&gt; is specified, the grant is recorded as having been done by the specified role. Only database superusers may use this option, except when it names the same role executing the command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1dbb4a5b057fd9d80b4085324de683535f1772c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IF NOT EXISTS&lt;/code&gt; is specified, it is not an error if the type already contains the new value: a notice is issued but no other action is taken. Otherwise, an error will occur if the new value is already present.</source>
          <target state="translated">如果指定了 &lt;code&gt;IF NOT EXISTS&lt;/code&gt; ，则该类型已经包含新值也不会出错：发出通知，但不执行其他任何操作。否则，如果新值已经存在，将发生错误。</target>
        </trans-unit>
        <trans-unit id="713b84661234cdebeb4eb076bfe7612a7ddb758e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NO CYCLE&lt;/code&gt; is specified, any calls to &lt;code&gt;nextval&lt;/code&gt; after the sequence has reached its maximum value will return an error. If neither &lt;code&gt;CYCLE&lt;/code&gt; or &lt;code&gt;NO CYCLE&lt;/code&gt; are specified, &lt;code&gt;NO CYCLE&lt;/code&gt; is the default.</source>
          <target state="translated">如果指定了 &lt;code&gt;NO CYCLE&lt;/code&gt; ,则在序列达到最大值后，对 &lt;code&gt;nextval&lt;/code&gt; 的任何调用都将返回错误。如果未指定 &lt;code&gt;CYCLE&lt;/code&gt; 或 &lt;code&gt;NO CYCLE&lt;/code&gt; ，则默认为 &lt;code&gt;NO CYCLE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="72454c0dc96ec89da5b352eb2463b5c3b5e5fc00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NONE&lt;/code&gt; is selected, the backup manifest will not contain any checksums. Otherwise, it will contain a checksum of each file in the backup using the specified algorithm. In addition, the manifest will always contain a &lt;code&gt;SHA256&lt;/code&gt; checksum of its own contents. The &lt;code&gt;SHA&lt;/code&gt; algorithms are significantly more CPU-intensive than &lt;code&gt;CRC32C&lt;/code&gt;, so selecting one of them may increase the time required to complete the backup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bbdf1bb14119659019986a40e06a497bd2493a9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NULLS LAST&lt;/code&gt; is specified, null values sort after all non-null values; if &lt;code&gt;NULLS FIRST&lt;/code&gt; is specified, null values sort before all non-null values. If neither is specified, the default behavior is &lt;code&gt;NULLS LAST&lt;/code&gt; when &lt;code&gt;ASC&lt;/code&gt; is specified or implied, and &lt;code&gt;NULLS FIRST&lt;/code&gt; when &lt;code&gt;DESC&lt;/code&gt; is specified (thus, the default is to act as though nulls are larger than non-nulls). When &lt;code&gt;USING&lt;/code&gt; is specified, the default nulls ordering depends on whether the operator is a less-than or greater-than operator.</source>
          <target state="translated">如果指定了 &lt;code&gt;NULLS LAST&lt;/code&gt; ，则空值将在所有非空值之后排序；如果指定了 &lt;code&gt;NULLS FIRST&lt;/code&gt; ，则空值将在所有非空值之前排序。如果未指定，则默认行为是在指定或隐含 &lt;code&gt;ASC&lt;/code&gt; 时为 &lt;code&gt;NULLS LAST&lt;/code&gt; ，而在指定 &lt;code&gt;DESC&lt;/code&gt; 时为 &lt;code&gt;NULLS FIRST&lt;/code&gt; （因此，默认值表示空值大于非空值）。当 &lt;code&gt;USING&lt;/code&gt; 被指定，默认空排序取决于运营商是否是一个小于或大于运营商。</target>
        </trans-unit>
        <trans-unit id="8fb56e2e9f0f01bd1fdfbdbf89ac20f3bbcae1c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PARTITION OF&lt;/code&gt; clause is specified then the table is created as a partition of &lt;code&gt;parent_table&lt;/code&gt; with specified bounds.</source>
          <target state="translated">如果指定了 &lt;code&gt;PARTITION OF&lt;/code&gt; 子句，则将表创建为具有指定范围的 &lt;code&gt;parent_table&lt;/code&gt; 的分区。</target>
        </trans-unit>
        <trans-unit id="c7ee0e44f6b6bd7b6f554d708cd5b901ba47c152" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PRIMARY KEY&lt;/code&gt; is specified, and the index's columns are not already marked &lt;code&gt;NOT NULL&lt;/code&gt;, then this command will attempt to do &lt;code&gt;ALTER COLUMN SET NOT NULL&lt;/code&gt; against each such column. That requires a full table scan to verify the column(s) contain no nulls. In all other cases, this is a fast operation.</source>
          <target state="translated">如果指定了 &lt;code&gt;PRIMARY KEY&lt;/code&gt; ，并且索引的列尚未标记为 &lt;code&gt;NOT NULL&lt;/code&gt; ，则此命令将尝试对每个此类列执行 &lt;code&gt;ALTER COLUMN SET NOT NULL&lt;/code&gt; 。这需要全表扫描，以验证列不包含任何空值。在所有其他情况下，这都是快速的操作。</target>
        </trans-unit>
        <trans-unit id="ae2eae0b6691115fff0baa447860d3557c71a926" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RECURSIVE&lt;/code&gt; is specified, it allows a &lt;code&gt;SELECT&lt;/code&gt; subquery to reference itself by name. Such a subquery must have the form</source>
          <target state="translated">如果指定了 &lt;code&gt;RECURSIVE&lt;/code&gt; ，则它允许 &lt;code&gt;SELECT&lt;/code&gt; 子查询按名称引用自己。这样的子查询必须具有以下形式</target>
        </trans-unit>
        <trans-unit id="5c5e50c2f4aff13823fb6c53c60eb5ef4318ca54" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SELECT DISTINCT&lt;/code&gt; is specified, all duplicate rows are removed from the result set (one row is kept from each group of duplicates). &lt;code&gt;SELECT ALL&lt;/code&gt; specifies the opposite: all rows are kept; that is the default.</source>
          <target state="translated">如果指定了 &lt;code&gt;SELECT DISTINCT&lt;/code&gt; ，则将所有重复行从结果集中删除（每组重复项中保留一行）。 &lt;code&gt;SELECT ALL&lt;/code&gt; 则相反：所有行都保留；这是默认值。</target>
        </trans-unit>
        <trans-unit id="04b3f6938761ce362c4ded325b6abaf0a88a5df2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SET LOCAL&lt;/code&gt; is used within a function that has a &lt;code&gt;SET&lt;/code&gt; option for the same variable (see &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;), the effects of the &lt;code&gt;SET LOCAL&lt;/code&gt; command disappear at function exit; that is, the value in effect when the function was called is restored anyway. This allows &lt;code&gt;SET LOCAL&lt;/code&gt; to be used for dynamic or repeated changes of a parameter within a function, while still having the convenience of using the &lt;code&gt;SET&lt;/code&gt; option to save and restore the caller's value. However, a regular &lt;code&gt;SET&lt;/code&gt; command overrides any surrounding function's &lt;code&gt;SET&lt;/code&gt; option; its effects will persist unless rolled back.</source>
          <target state="translated">如果在具有相同变量的 &lt;code&gt;SET&lt;/code&gt; 选项的函数中使用 &lt;code&gt;SET LOCAL&lt;/code&gt; （请参见&lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;），则 &lt;code&gt;SET LOCAL&lt;/code&gt; 命令的效果在函数退出时消失；也就是说，无论如何都将恢复调用该函数时有效的值。这样就可以将 &lt;code&gt;SET LOCAL&lt;/code&gt; 用于函数中参数的动态或重复更改，同时仍然可以方便地使用 &lt;code&gt;SET&lt;/code&gt; 选项保存和恢复调用者的值。但是，常规的 &lt;code&gt;SET&lt;/code&gt; 命令会覆盖所有周围函数的 &lt;code&gt;SET&lt;/code&gt; 选项。除非回滚，否则其影响将持续。</target>
        </trans-unit>
        <trans-unit id="ec901162256017a1ee3d75cc5aa3a5194df885bb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SET TRANSACTION&lt;/code&gt; is executed without a prior &lt;code&gt;START TRANSACTION&lt;/code&gt; or &lt;code&gt;BEGIN&lt;/code&gt;, it emits a warning and otherwise has no effect.</source>
          <target state="translated">如果在没有先前的 &lt;code&gt;START TRANSACTION&lt;/code&gt; 或 &lt;code&gt;BEGIN&lt;/code&gt; 的情况下执行 &lt;code&gt;SET TRANSACTION&lt;/code&gt; ，它将发出警告，否则无效。</target>
        </trans-unit>
        <trans-unit id="c679999524623fe277800e4000b75170afd22ce0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SET&lt;/code&gt; (or equivalently &lt;code&gt;SET SESSION&lt;/code&gt;) is issued within a transaction that is later aborted, the effects of the &lt;code&gt;SET&lt;/code&gt; command disappear when the transaction is rolled back. Once the surrounding transaction is committed, the effects will persist until the end of the session, unless overridden by another &lt;code&gt;SET&lt;/code&gt;.</source>
          <target state="translated">如果在稍后中止的事务中发出 &lt;code&gt;SET&lt;/code&gt; （或等效的 &lt;code&gt;SET SESSION&lt;/code&gt; ），则在回滚该事务时 &lt;code&gt;SET&lt;/code&gt; 命令的效果会消失。一旦提交了周围的事务，效果将一直持续到会话结束，除非被另一个 &lt;code&gt;SET&lt;/code&gt; 覆盖。</target>
        </trans-unit>
        <trans-unit id="9705e1f00e76813c6d22bc3d6eab56b5d6ef9cd2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;WITH ADMIN OPTION&lt;/code&gt; is specified, the member can in turn grant membership in the role to others, and revoke membership in the role as well. Without the admin option, ordinary users cannot do that. A role is not considered to hold &lt;code&gt;WITH ADMIN OPTION&lt;/code&gt; on itself, but it may grant or revoke membership in itself from a database session where the session user matches the role. Database superusers can grant or revoke membership in any role to anyone. Roles having &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can grant or revoke membership in any role that is not a superuser.</source>
          <target state="translated">如果指定了 &lt;code&gt;WITH ADMIN OPTION&lt;/code&gt; ，则成员可以依次将角色的成员资格授予其他人，也可以撤消该角色的成员资格。没有admin选项，普通用户将无法做到这一点。角色不被认为拥有 &lt;code&gt;WITH ADMIN OPTION&lt;/code&gt; 本身，但是它可以从会话用户与角色匹配的数据库会话中授予或撤销成员资格。数据库超级用户可以以任何角色向任何人授予或撤销成员资格。具有 &lt;code&gt;CREATEROLE&lt;/code&gt; 特权的角色可以授予或撤消不是超级用户的任何角色的成员资格。</target>
        </trans-unit>
        <trans-unit id="abd80886f4a2be834b3e10dda7c9db6fa997569b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;WITH GRANT OPTION&lt;/code&gt; is specified, the recipient of the privilege can in turn grant it to others. Without a grant option, the recipient cannot do that. Grant options cannot be granted to &lt;code&gt;PUBLIC&lt;/code&gt;.</source>
          <target state="translated">如果指定了 &lt;code&gt;WITH GRANT OPTION&lt;/code&gt; ，则特权的接收者可以依次将其授予其他人。没有授予选项，接收者将无法做到这一点。授予选项不能授予 &lt;code&gt;PUBLIC&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9373b178281613a72e6b020f7636dc488a5f1d3a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;WITH HOLD&lt;/code&gt; is specified and the transaction that created the cursor successfully commits, the cursor can continue to be accessed by subsequent transactions in the same session. (But if the creating transaction is aborted, the cursor is removed.) A cursor created with &lt;code&gt;WITH HOLD&lt;/code&gt; is closed when an explicit &lt;code&gt;CLOSE&lt;/code&gt; command is issued on it, or the session ends. In the current implementation, the rows represented by a held cursor are copied into a temporary file or memory area so that they remain available for subsequent transactions.</source>
          <target state="translated">如果指定了 &lt;code&gt;WITH HOLD&lt;/code&gt; 并且成功提交了创建游标的事务，则该游标可以继续被同一会话中的后续事务访问。（但是，如果创建事务被中止，则删除游标。）在对它发出显式 &lt;code&gt;CLOSE&lt;/code&gt; 命令或会话结束时，将关闭使用 &lt;code&gt;WITH HOLD&lt;/code&gt; 创建的游标。在当前实现中，由保留的游标表示的行被复制到临时文件或存储区中，以便它们可用于后续事务。</target>
        </trans-unit>
        <trans-unit id="d9dde45619a2d3c398745c13026f768d6b6b6cbb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;\d&lt;/code&gt; is used without a &lt;code&gt;pattern&lt;/code&gt; argument, it is equivalent to &lt;code&gt;\dtvmsE&lt;/code&gt; which will show a list of all visible tables, views, materialized views, sequences and foreign tables. This is purely a convenience measure.</source>
          <target state="translated">如果使用 &lt;code&gt;\d&lt;/code&gt; 而不使用 &lt;code&gt;pattern&lt;/code&gt; 参数，则等效于 &lt;code&gt;\dtvmsE&lt;/code&gt; ，它将显示所有可见表，视图，实例化视图，序列和外部表的列表。这纯粹是一种方便的措施。</target>
        </trans-unit>
        <trans-unit id="99696408eca3e79444094829903879dfb2c22cfc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;\pset columns&lt;/code&gt; is zero, controls the width for the &lt;code&gt;wrapped&lt;/code&gt; format and width for determining if wide output requires the pager or should be switched to the vertical format in expanded auto mode.</source>
          <target state="translated">如果 &lt;code&gt;\pset columns&lt;/code&gt; 是零，控制用于宽度 &lt;code&gt;wrapped&lt;/code&gt; 格式和宽度，用于确定宽输出需要的寻呼机或应当被切换到在扩展自动模式的垂直格式。</target>
        </trans-unit>
        <trans-unit id="65d8ff6e4bb927882e0081eeca2677185a93d180" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;archive_mode&lt;/code&gt; is set to &lt;code&gt;on&lt;/code&gt;, the archiver is not enabled during recovery or standby mode. If the standby server is promoted, it will start archiving after the promotion, but will not archive any WAL it did not generate itself. To get a complete series of WAL files in the archive, you must ensure that all WAL is archived, before it reaches the standby. This is inherently true with file-based log shipping, as the standby can only restore files that are found in the archive, but not if streaming replication is enabled. When a server is not in recovery mode, there is no difference between &lt;code&gt;on&lt;/code&gt; and &lt;code&gt;always&lt;/code&gt; modes.</source>
          <target state="translated">如果 &lt;code&gt;archive_mode&lt;/code&gt; 设置为 &lt;code&gt;on&lt;/code&gt; ，则在恢复或待机模式下不会启用存档器。如果升级备用服务器，它将在升级后开始存档，但不会存档未生成的任何WAL。要在归档文件中获得完整的WAL文件系列，必须确保所有WAL文件都已归档，然后再到达备用数据库。对于基于文件的日志传送，这本质上是正确的，因为备用数据库只能还原在存档中找到的文件，而如果启用了流复制，则不能还原。当服务器不处于恢复模式时， &lt;code&gt;on&lt;/code&gt; 模式和 &lt;code&gt;always&lt;/code&gt; 模式之间没有区别。</target>
        </trans-unit>
        <trans-unit id="6c695d4c8ca7c7dc88430e23d97c617405cca08b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;archive_mode&lt;/code&gt; is set to &lt;code&gt;on&lt;/code&gt;, the archiver is not enabled during recovery or standby mode. If the standby server is promoted, it will start archiving after the promotion, but will not archive any WAL or timeline history files that it did not generate itself. To get a complete series of WAL files in the archive, you must ensure that all WAL is archived, before it reaches the standby. This is inherently true with file-based log shipping, as the standby can only restore files that are found in the archive, but not if streaming replication is enabled. When a server is not in recovery mode, there is no difference between &lt;code&gt;on&lt;/code&gt; and &lt;code&gt;always&lt;/code&gt; modes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c5e023785c0eaf8158798154829baaec24284f3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;filename&lt;/code&gt; is &lt;code&gt;-&lt;/code&gt; (hyphen), then standard input is read until an EOF indication or &lt;code&gt;\q&lt;/code&gt; meta-command. This can be used to intersperse interactive input with input from files. Note however that Readline is not used in this case (much as if &lt;code&gt;-n&lt;/code&gt; had been specified).</source>
          <target state="translated">如果 &lt;code&gt;filename&lt;/code&gt; 是 &lt;code&gt;-&lt;/code&gt; （连字符），则将读取标准输入，直到EOF指示或 &lt;code&gt;\q&lt;/code&gt; 元命令为止。这可用于将交互式输入与文件输入进行穿插。但是请注意，在这种情况下不使用Readline（就像已指定 &lt;code&gt;-n&lt;/code&gt; 一样）。</target>
        </trans-unit>
        <trans-unit id="a4833473639ec21367a52ecaec9a765427862e75" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;filename&lt;/code&gt; is &lt;code&gt;-&lt;/code&gt; (hyphen), then standard input is read until an EOF indication or &lt;code&gt;\q&lt;/code&gt; meta-command. This can be used to intersperse interactive input with input from files. Note that Readline behavior will be used only if it is active at the outermost level.</source>
          <target state="translated">如果 &lt;code&gt;filename&lt;/code&gt; 是 &lt;code&gt;-&lt;/code&gt; （连字符），则将读取标准输入，直到EOF指示或 &lt;code&gt;\q&lt;/code&gt; 元命令为止。这可用于将交互式输入与文件输入进行穿插。请注意，只有在最外层处于活动状态时，才会使用Readline行为。</target>
        </trans-unit>
        <trans-unit id="5d8bdbf29f6ea734e4384d8cec6971a567637c07" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;filename&lt;/code&gt; is specified, the file is edited; after the editor exits, the file's content is copied into the current query buffer. If no &lt;code&gt;filename&lt;/code&gt; is given, the current query buffer is copied to a temporary file which is then edited in the same fashion. Or, if the current query buffer is empty, the most recently executed query is copied to a temporary file and edited in the same fashion.</source>
          <target state="translated">如果指定 &lt;code&gt;filename&lt;/code&gt; ，则文件被编辑；编辑器退出后，文件内容将复制到当前查询缓冲区中。如果未提供 &lt;code&gt;filename&lt;/code&gt; ，则将当前查询缓冲区复制到一个临时文件，然后以相同的方式对其进行编辑。或者，如果当前查询缓冲区为空，则将最近执行的查询复制到临时文件中，并以相同的方式进行编辑。</target>
        </trans-unit>
        <trans-unit id="87b5fa64a8f2d20fd3cdbf376e8372ac5be9682f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;frame_end&lt;/code&gt; is omitted it defaults to &lt;code&gt;CURRENT ROW&lt;/code&gt;. Restrictions are that &lt;code&gt;frame_start&lt;/code&gt; cannot be &lt;code&gt;UNBOUNDED FOLLOWING&lt;/code&gt;, &lt;code&gt;frame_end&lt;/code&gt; cannot be &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt;, and the &lt;code&gt;frame_end&lt;/code&gt; choice cannot appear earlier in the above list of &lt;code&gt;frame_start&lt;/code&gt; and &lt;code&gt;frame_end&lt;/code&gt; options than the &lt;code&gt;frame_start&lt;/code&gt; choice does &amp;mdash; for example &lt;code&gt;RANGE BETWEEN CURRENT ROW AND offset PRECEDING&lt;/code&gt; is not allowed.</source>
          <target state="translated">如果省略 &lt;code&gt;frame_end&lt;/code&gt; ，则默认为 &lt;code&gt;CURRENT ROW&lt;/code&gt; 。限制是 &lt;code&gt;frame_start&lt;/code&gt; 不能 &lt;code&gt;UNBOUNDED FOLLOWING&lt;/code&gt; ， &lt;code&gt;frame_end&lt;/code&gt; 不能 &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt; 和 &lt;code&gt;frame_end&lt;/code&gt; 选择不能在上面的列表中出现较早 &lt;code&gt;frame_start&lt;/code&gt; 和 &lt;code&gt;frame_end&lt;/code&gt; 选项比 &lt;code&gt;frame_start&lt;/code&gt; 选择呢-例如 &lt;code&gt;RANGE BETWEEN CURRENT ROW AND offset PRECEDING&lt;/code&gt; 是不允许的。</target>
        </trans-unit>
        <trans-unit id="c1493aafac52b8fb4240f760d7718dc0ee8aca4b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;genbki.pl&lt;/code&gt; needs to assign an OID to a catalog entry that does not have a manually-assigned OID, it will use a value in the range 10000&amp;mdash;11999. The server's OID counter is set to 12000 at the start of a bootstrap run. Thus objects created by regular SQL commands during the later phases of bootstrap, such as objects created while running the &lt;code&gt;information_schema.sql&lt;/code&gt; script, receive OIDs of 12000 or above.</source>
          <target state="translated">如果 &lt;code&gt;genbki.pl&lt;/code&gt; 需要将OID分配给没有手动分配的OID的目录条目，则它将使用10000-11999范围内的值。引导程序运行开始时，服务器的OID计数器设置为12000。因此，在引导的后续阶段中由常规SQL命令创建的对象（例如在运行 &lt;code&gt;information_schema.sql&lt;/code&gt; 脚本时创建的对象）接收的OID为12000或更高。</target>
        </trans-unit>
        <trans-unit id="e8c7103cc04741a131a5ac6b2ff588f135e3ddcc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;hot_standby&lt;/code&gt; is &lt;code&gt;on&lt;/code&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt; (the default value) and there is a &lt;code&gt;standby.signal&lt;/code&gt; file present, the server will run in Hot Standby mode. However, it may take some time for Hot Standby connections to be allowed, because the server will not accept connections until it has completed sufficient recovery to provide a consistent state against which queries can run. During this period, clients that attempt to connect will be refused with an error message. To confirm the server has come up, either loop trying to connect from the application, or look for these messages in the server logs:</source>
          <target state="translated">如果 &lt;code&gt;hot_standby&lt;/code&gt; 是 &lt;code&gt;on&lt;/code&gt; 在 &lt;code&gt;postgresql.conf&lt;/code&gt; 中（默认值），并有一个 &lt;code&gt;standby.signal&lt;/code&gt; 文件目前，该服务器将在热备份模式下运行。但是，允许热备连接可能要花费一些时间，因为服务器将不接受连接，直到服务器完成足够的恢复以提供可以运行查询的一致状态为止。在此期间，尝试连接的客户端将被拒绝并显示一条错误消息。要确认服务器已启动，请循环尝试从应用程序进行连接，或者在服务器日志中查找以下消息：</target>
        </trans-unit>
        <trans-unit id="2c8e31ec3780ebc59dc482c2ca3c59c045a41221" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;in_range&lt;/code&gt; with &lt;code&gt;less&lt;/code&gt; = true is false for some &lt;code&gt;val1&lt;/code&gt; and &lt;code&gt;base&lt;/code&gt;, it must be false for every &lt;code&gt;val2&lt;/code&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;code&gt;val1&lt;/code&gt; with the same &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">如果对于某些 &lt;code&gt;val1&lt;/code&gt; 和 &lt;code&gt;base&lt;/code&gt; ，具有 &lt;code&gt;less&lt;/code&gt; = true的 &lt;code&gt;in_range&lt;/code&gt; 为false ，则对于具有相同 &lt;code&gt;base&lt;/code&gt; 每个 &lt;code&gt;val2&lt;/code&gt; &lt;code&gt;&amp;gt;=&lt;/code&gt; &lt;code&gt;val1&lt;/code&gt; ，它都必须为false 。</target>
        </trans-unit>
        <trans-unit id="332193353c52bde38e0eb3c661ad221eb1be8b6c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;in_range&lt;/code&gt; with &lt;code&gt;less&lt;/code&gt; = true is false for some &lt;code&gt;val&lt;/code&gt; and &lt;code&gt;base1&lt;/code&gt;, it must be false for every &lt;code&gt;base2&lt;/code&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;code&gt;base1&lt;/code&gt; with the same &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;in_range&lt;/code&gt; 具有 &lt;code&gt;less&lt;/code&gt; = true的值对于某些 &lt;code&gt;val&lt;/code&gt; 和 &lt;code&gt;base1&lt;/code&gt; 为false，则对于每个具有相同 &lt;code&gt;val&lt;/code&gt; 的 &lt;code&gt;base2&lt;/code&gt; &lt;code&gt;&amp;lt;=&lt;/code&gt; &lt;code&gt;base1&lt;/code&gt; 必须为false 。</target>
        </trans-unit>
        <trans-unit id="aa930e16baff55aa31e6852a2b74660f8ec3544e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;in_range&lt;/code&gt; with &lt;code&gt;less&lt;/code&gt; = true is true for some &lt;code&gt;val1&lt;/code&gt; and &lt;code&gt;base&lt;/code&gt;, it must be true for every &lt;code&gt;val2&lt;/code&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;code&gt;val1&lt;/code&gt; with the same &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;in_range&lt;/code&gt; with &lt;code&gt;less&lt;/code&gt; = true对于某些 &lt;code&gt;val1&lt;/code&gt; 和 &lt;code&gt;base&lt;/code&gt; 为true，则对于每个具有相同 &lt;code&gt;base&lt;/code&gt; 的 &lt;code&gt;val2&lt;/code&gt; &lt;code&gt;&amp;lt;=&lt;/code&gt; &lt;code&gt;val1&lt;/code&gt; 必须为true 。</target>
        </trans-unit>
        <trans-unit id="342ab2a9a17f2fb194989decac130f65bf2a3ab2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;in_range&lt;/code&gt; with &lt;code&gt;less&lt;/code&gt; = true is true for some &lt;code&gt;val&lt;/code&gt; and &lt;code&gt;base1&lt;/code&gt;, it must be true for every &lt;code&gt;base2&lt;/code&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;code&gt;base1&lt;/code&gt; with the same &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;in_range&lt;/code&gt; with &lt;code&gt;less&lt;/code&gt; = true对于某些 &lt;code&gt;val&lt;/code&gt; 和 &lt;code&gt;base1&lt;/code&gt; 为true，则对于具有相同 &lt;code&gt;val&lt;/code&gt; 的每个 &lt;code&gt;base2&lt;/code&gt; &lt;code&gt;&amp;gt;=&lt;/code&gt; &lt;code&gt;base1&lt;/code&gt; 必须为true 。</target>
        </trans-unit>
        <trans-unit id="e3506d1e84d2320597dc89468fa4fbfef68d52af" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pager_min_lines&lt;/code&gt; is set to a number greater than the page height, the pager program will not be called unless there are at least this many lines of output to show. The default setting is 0.</source>
          <target state="translated">如果将 &lt;code&gt;pager_min_lines&lt;/code&gt; 设置为大于页面高度的数字，则除非至少要显示这么多的输出行，否则将不会调用寻呼机程序。默认设置为0。</target>
        </trans-unit>
        <trans-unit id="ad57f5bc57449c70be03f78cafa8198c7fecd4a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pattern&lt;/code&gt; does not contain percent signs or underscores, then the pattern only represents the string itself; in that case &lt;code&gt;LIKE&lt;/code&gt; acts like the equals operator. An underscore (&lt;code&gt;_&lt;/code&gt;) in &lt;code&gt;pattern&lt;/code&gt; stands for (matches) any single character; a percent sign (&lt;code&gt;%&lt;/code&gt;) matches any sequence of zero or more characters.</source>
          <target state="translated">如果 &lt;code&gt;pattern&lt;/code&gt; 不包含百分号或下划线，则pattern仅表示字符串本身；在这种情况下， &lt;code&gt;LIKE&lt;/code&gt; 的行为类似于equals运算符。下划线（ &lt;code&gt;_&lt;/code&gt; 中） &lt;code&gt;pattern&lt;/code&gt; 代表（匹配）任何单个字符;百分号（ &lt;code&gt;%&lt;/code&gt; ）与零个或多个字符的任何序列匹配。</target>
        </trans-unit>
        <trans-unit id="929282dbe9432a59498fc7de54e9f120a0c23fde" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pg_resetwal&lt;/code&gt; complains that it cannot determine valid data for &lt;code&gt;pg_control&lt;/code&gt;, you can force it to proceed anyway by specifying the &lt;code&gt;-f&lt;/code&gt; (force) option. In this case plausible values will be substituted for the missing data. Most of the fields can be expected to match, but manual assistance might be needed for the next OID, next transaction ID and epoch, next multitransaction ID and offset, and WAL starting location fields. These fields can be set using the options discussed below. If you are not able to determine correct values for all these fields, &lt;code&gt;-f&lt;/code&gt; can still be used, but the recovered database must be treated with even more suspicion than usual: an immediate dump and reload is imperative. &lt;em&gt;Do not&lt;/em&gt; execute any data-modifying operations in the database before you dump, as any such action is likely to make the corruption worse.</source>
          <target state="translated">如果 &lt;code&gt;pg_resetwal&lt;/code&gt; 抱怨它无法确定 &lt;code&gt;pg_control&lt;/code&gt; 的有效数据，则可以通过指定 &lt;code&gt;-f&lt;/code&gt; （强制）选项来强制其继续进行。在这种情况下，将用合理的值代替丢失的数据。可以预期大多数字段都将匹配，但是下一个OID，下一个事务ID和纪元，下一个多事务ID和偏移量以及WAL起始位置字段可能需要手动协助。可以使用下面讨论的选项设置这些字段。如果您不能为所有这些字段确定正确的值，则仍可以使用 &lt;code&gt;-f&lt;/code&gt; ，但是必须比平时更怀疑地对待恢复的数据库：必须立即进行转储和重装。&lt;em&gt;不要&lt;/em&gt; 在转储之前，请在数据库中执行任何数据修改操作，因为任何此类操作都可能使损坏更加严重。</target>
        </trans-unit>
        <trans-unit id="f13d0730a2d7549daf41a4dfb84c03f31c4b1319" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pg_upgrade&lt;/code&gt; aborted before linking started, the old cluster was unmodified; it can be restarted.</source>
          <target state="translated">如果 &lt;code&gt;pg_upgrade&lt;/code&gt; 在链接开始前被中止，则旧集群未被修改；它可以重新启动。</target>
        </trans-unit>
        <trans-unit id="e188ae9422c6dffedeb340ab362e8934b4b3e43d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;prokind&lt;/code&gt; indicates that the entry is for an aggregate function, there should be a matching row in &lt;code&gt;pg_aggregate&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;prokind&lt;/code&gt; 指示该条目用于聚合函数，则 &lt;code&gt;pg_aggregate&lt;/code&gt; 中应有一个匹配行。</target>
        </trans-unit>
        <trans-unit id="1e29943d28ac675fb4f0be463fde98da976b1859" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;synchronous_standby_names&lt;/code&gt; is empty, the only meaningful settings are &lt;code&gt;on&lt;/code&gt; and &lt;code&gt;off&lt;/code&gt;; &lt;code&gt;remote_apply&lt;/code&gt;, &lt;code&gt;remote_write&lt;/code&gt; and &lt;code&gt;local&lt;/code&gt; all provide the same local synchronization level as &lt;code&gt;on&lt;/code&gt;. The local behavior of all non-&lt;code&gt;off&lt;/code&gt; modes is to wait for local flush of WAL to disk. In &lt;code&gt;off&lt;/code&gt; mode, there is no waiting, so there can be a delay between when success is reported to the client and when the transaction is later guaranteed to be safe against a server crash. (The maximum delay is three times &lt;a href=&quot;runtime-config-wal#GUC-WAL-WRITER-DELAY&quot;&gt;wal_writer_delay&lt;/a&gt;.) Unlike &lt;a href=&quot;runtime-config-wal#GUC-FSYNC&quot;&gt;fsync&lt;/a&gt;, setting this parameter to &lt;code&gt;off&lt;/code&gt; does not create any risk of database inconsistency: an operating system or database crash might result in some recent allegedly-committed transactions being lost, but the database state will be just the same as if those transactions had been aborted cleanly. So, turning &lt;code&gt;synchronous_commit&lt;/code&gt; off can be a useful alternative when performance is more important than exact certainty about the durability of a transaction. For more discussion see &lt;a href=&quot;wal-async-commit&quot;&gt;Section 29.3&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32186644a8227bc9629078cb6964f294409c3b69" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;synchronous_standby_names&lt;/code&gt; is empty, the settings &lt;code&gt;on&lt;/code&gt;, &lt;code&gt;remote_apply&lt;/code&gt;, &lt;code&gt;remote_write&lt;/code&gt; and &lt;code&gt;local&lt;/code&gt; all provide the same synchronization level: transaction commits only wait for local flush to disk.</source>
          <target state="translated">如果 &lt;code&gt;synchronous_standby_names&lt;/code&gt; 是空的，在设置 &lt;code&gt;on&lt;/code&gt; ， &lt;code&gt;remote_apply&lt;/code&gt; ， &lt;code&gt;remote_write&lt;/code&gt; 和 &lt;code&gt;local&lt;/code&gt; 都提供相同的同步水平：提交事务只能等待本地刷新到磁盘。</target>
        </trans-unit>
        <trans-unit id="e17b6ba8e8e554c6fa5ecad07078e794222b7865" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;typarray&lt;/code&gt; is not 0 then it identifies another row in &lt;code&gt;pg_type&lt;/code&gt;, which is the &amp;ldquo;true&amp;rdquo; array type having this type as element</source>
          <target state="translated">如果 &lt;code&gt;typarray&lt;/code&gt; 不为0，则它​​将标识 &lt;code&gt;pg_type&lt;/code&gt; 中的另一行，这是具有该类型作为元素的&amp;ldquo; true&amp;rdquo;数组类型</target>
        </trans-unit>
        <trans-unit id="1643f010e11a8ec209a76b1daf0df11fad85a094" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;typdefaultbin&lt;/code&gt; is not null, it is the &lt;code&gt;nodeToString()&lt;/code&gt; representation of a default expression for the type. This is only used for domains.</source>
          <target state="translated">如果 &lt;code&gt;typdefaultbin&lt;/code&gt; 不为null，则为该 &lt;code&gt;nodeToString()&lt;/code&gt; 的默认表达式的nodeToString（）表示形式。这仅用于域。</target>
        </trans-unit>
        <trans-unit id="a098d6d2d4ed82c302d8bd246178fb2399080947" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;typelem&lt;/code&gt; is not 0 then it identifies another row in &lt;code&gt;pg_type&lt;/code&gt;. The current type can then be subscripted like an array yielding values of type &lt;code&gt;typelem&lt;/code&gt;. A &amp;ldquo;true&amp;rdquo; array type is variable length (&lt;code&gt;typlen&lt;/code&gt; = -1), but some fixed-length (&lt;code&gt;typlen&lt;/code&gt; &amp;gt; 0) types also have nonzero &lt;code&gt;typelem&lt;/code&gt;, for example &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;point&lt;/code&gt;. If a fixed-length type has a &lt;code&gt;typelem&lt;/code&gt; then its internal representation must be some number of values of the &lt;code&gt;typelem&lt;/code&gt; data type with no other data. Variable-length array types have a header defined by the array subroutines.</source>
          <target state="translated">如果 &lt;code&gt;typelem&lt;/code&gt; 不为0，则它​​将在 &lt;code&gt;pg_type&lt;/code&gt; 中标识另一行。然后可以将当前类型下标，就像产生 &lt;code&gt;typelem&lt;/code&gt; 类型值的数组一样。 &amp;ldquo; true&amp;rdquo;数组类型的长度是可变的（ &lt;code&gt;typlen&lt;/code&gt; = -1），但是某些固定长度的类型（ &lt;code&gt;typlen&lt;/code&gt; &amp;gt; 0）也具有非零的 &lt;code&gt;typelem&lt;/code&gt; ，例如 &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;point&lt;/code&gt; 。如果固定长度的类型具有 &lt;code&gt;typelem&lt;/code&gt; 那么它的内部表示必须有一些数量的值 &lt;code&gt;typelem&lt;/code&gt; 没有其它数据的数据类型。可变长度数组类型具有由数组子例程定义的标头。</target>
        </trans-unit>
        <trans-unit id="962e01512a43e6b662e513b46b2720b8eda2c536" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is specified it must be either &lt;code&gt;on&lt;/code&gt; or &lt;code&gt;off&lt;/code&gt; which will enable or disable display of a locale-specific character to separate groups of digits to the left of the decimal marker. If &lt;code&gt;value&lt;/code&gt; is omitted the command toggles between regular and locale-specific numeric output.</source>
          <target state="translated">如果指定了 &lt;code&gt;value&lt;/code&gt; ，则必须将其 &lt;code&gt;on&lt;/code&gt; 或 &lt;code&gt;off&lt;/code&gt; ，这将启用或禁用显示特定于区域的字符以将小数点标记左侧的数字组分开。如果省略 &lt;code&gt;value&lt;/code&gt; ,则该命令在常规和特定于区域的数字输出之间切换。</target>
        </trans-unit>
        <trans-unit id="0ac5be223120c8314531a02347c6041d7cd668b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is specified it must be either &lt;code&gt;on&lt;/code&gt; or &lt;code&gt;off&lt;/code&gt; which will enable or disable display of the table footer (the &lt;code&gt;(n rows)&lt;/code&gt; count). If &lt;code&gt;value&lt;/code&gt; is omitted the command toggles footer display on or off.</source>
          <target state="translated">如果指定了 &lt;code&gt;value&lt;/code&gt; ，则必须将其 &lt;code&gt;on&lt;/code&gt; 或 &lt;code&gt;off&lt;/code&gt; ，这将启用或禁用表脚的显示（ &lt;code&gt;(n rows)&lt;/code&gt; 计数）。如果省略 &lt;code&gt;value&lt;/code&gt; 则该命令将打开或关闭页脚显示。</target>
        </trans-unit>
        <trans-unit id="5cba26a9c2b6ebc7647fabad9eea11f281ddf193" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is specified it must be either &lt;code&gt;on&lt;/code&gt; or &lt;code&gt;off&lt;/code&gt; which will enable or disable tuples-only mode. If &lt;code&gt;value&lt;/code&gt; is omitted the command toggles between regular and tuples-only output. Regular output includes extra information such as column headers, titles, and various footers. In tuples-only mode, only actual table data is shown.</source>
          <target state="translated">If &lt;code&gt;value&lt;/code&gt; is specified it must be either &lt;code&gt;on&lt;/code&gt; or &lt;code&gt;off&lt;/code&gt; which will enable or disable tuples-only mode. If &lt;code&gt;value&lt;/code&gt; is omitted the command toggles between regular and tuples-only output. Regular output includes extra information such as column headers, titles, and various footers. In tuples-only mode, only actual table data is shown.</target>
        </trans-unit>
        <trans-unit id="6fae09f9e5152eceff65217f721d75ba03342e63" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is specified it must be either &lt;code&gt;on&lt;/code&gt; or &lt;code&gt;off&lt;/code&gt;, which will enable or disable expanded mode, or &lt;code&gt;auto&lt;/code&gt;. If &lt;code&gt;value&lt;/code&gt; is omitted the command toggles between the on and off settings. When expanded mode is enabled, query results are displayed in two columns, with the column name on the left and the data on the right. This mode is useful if the data wouldn't fit on the screen in the normal &amp;ldquo;horizontal&amp;rdquo; mode. In the auto setting, the expanded mode is used whenever the query output has more than one column and is wider than the screen; otherwise, the regular mode is used. The auto setting is only effective in the aligned and wrapped formats. In other formats, it always behaves as if the expanded mode is off.</source>
          <target state="translated">如果指定了 &lt;code&gt;value&lt;/code&gt; ，那么它必须是 &lt;code&gt;on&lt;/code&gt; 或 &lt;code&gt;off&lt;/code&gt; ，这将启用或禁用扩展模式或 &lt;code&gt;auto&lt;/code&gt; 。如果省略 &lt;code&gt;value&lt;/code&gt; ，该命令将在on和off设置之间切换。启用扩展模式后，查询结果将显示在两列中，左列名称和右列数据。如果在正常的&amp;ldquo;水平&amp;rdquo;模式下数据无法显示在屏幕上，则此模式很有用。在自动设置中，只要查询输出多于一列并且比屏幕宽，就会使用扩展模式。否则，使用常规模式。自动设置仅在对齐和包装的格式中有效。在其他格式下，它始终表现为关闭扩展模式。</target>
        </trans-unit>
        <trans-unit id="ca01598c7c349232ee9c2f60f218cecf6c2e9b2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weights&lt;/code&gt; is supplied, only occurrences having one of those weights are counted.</source>
          <target state="translated">如果提供了 &lt;code&gt;weights&lt;/code&gt; ，则仅对具有这些权重之一的事件进行计数。</target>
        </trans-unit>
        <trans-unit id="2dc5f92abbdc131542b5a63d7715ef7b5720a0a1" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;&lt;code&gt;do_detoast&lt;/code&gt;&lt;/em&gt; is &lt;code&gt;true&lt;/code&gt;, attribute that will be detoasted as needed. Default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果&lt;em&gt; &lt;code&gt;do_detoast&lt;/code&gt; &lt;/em&gt;为 &lt;code&gt;true&lt;/code&gt; ，则将根据需要删除属性。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ce8f09a4ea0ee9a5326d6de1774ed409702a270" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;&lt;code&gt;new_value&lt;/code&gt;&lt;/em&gt; is not &lt;code&gt;NULL&lt;/code&gt;, behaves identically to &lt;code&gt;jsonb_set&lt;/code&gt;. Otherwise behaves according to the value of &lt;em&gt;&lt;code&gt;null_value_treatment&lt;/code&gt;&lt;/em&gt; which must be one of &lt;code&gt;'raise_exception'&lt;/code&gt;, &lt;code&gt;'use_json_null'&lt;/code&gt;, &lt;code&gt;'delete_key'&lt;/code&gt;, or &lt;code&gt;'return_target'&lt;/code&gt;. The default is &lt;code&gt;'use_json_null'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9855c6593bb788e4a7fc1baab60a566fbf901f03" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;&lt;code&gt;tableforest&lt;/code&gt;&lt;/em&gt; is false, then the resulting XML document looks like this:</source>
          <target state="translated">如果&lt;em&gt; &lt;code&gt;tableforest&lt;/code&gt; &lt;/em&gt;为false，则生成的XML文档如下所示：</target>
        </trans-unit>
        <trans-unit id="c50916d42c87228c370dd43c14046f7ce4402cc5" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;&lt;code&gt;tableforest&lt;/code&gt;&lt;/em&gt; is true, the result is an XML content fragment that looks like this:</source>
          <target state="translated">如果&lt;em&gt; &lt;code&gt;tableforest&lt;/code&gt; &lt;/em&gt;为true，则结果是一个XML内容片段，如下所示：</target>
        </trans-unit>
        <trans-unit id="a00e85c8c38a440ad71ba2067ec654d399028aa3" translate="yes" xml:space="preserve">
          <source>If BC has been specified, negate the year and add one for internal storage. (There is no year zero in the Gregorian calendar, so numerically 1 BC becomes year zero.)</source>
          <target state="translated">如果指定了BC,则否定年份,并添加一个内部存储。(在公历中没有零年,所以数字上1 BC变成零年。)</target>
        </trans-unit>
        <trans-unit id="2a6677efb7a76da9c59cedae433efda4935b91f1" translate="yes" xml:space="preserve">
          <source>If BC was not specified, and if the year field was two digits in length, then adjust the year to four digits. If the field is less than 70, then add 2000, otherwise add 1900.</source>
          <target state="translated">如果没有指定BC,如果年份字段长度为两位数,则将年份调整为四位数。如果该字段少于70,则加2000,否则加1900。</target>
        </trans-unit>
        <trans-unit id="a9b50e5581cb9a085c462f20b706e74a8924f7f1" translate="yes" xml:space="preserve">
          <source>If CSV-format output is enabled in &lt;code&gt;log_destination&lt;/code&gt;, &lt;code&gt;.csv&lt;/code&gt; will be appended to the timestamped log file name to create the file name for CSV-format output. (If &lt;code&gt;log_filename&lt;/code&gt; ends in &lt;code&gt;.log&lt;/code&gt;, the suffix is replaced instead.)</source>
          <target state="translated">如果CSV格式输出，在启用 &lt;code&gt;log_destination&lt;/code&gt; ， &lt;code&gt;.csv&lt;/code&gt; 将被追加到带时间戳的日志文件名来创建CSV格式输出文件名。（如果 &lt;code&gt;log_filename&lt;/code&gt; 以 &lt;code&gt;.log&lt;/code&gt; 结尾，则会替换后缀。）</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
