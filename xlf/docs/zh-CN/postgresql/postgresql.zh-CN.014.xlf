<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="debbd30b66af886f3ad4a4846dc7b2ee2e468eb1" translate="yes" xml:space="preserve">
          <source>If LLVM has the required functionality, emit the data needed to allow perf to profile functions generated by JIT. This writes out files to &lt;code&gt;$HOME/.debug/jit/&lt;/code&gt;; the user is responsible for performing cleanup when desired. The default setting is &lt;code&gt;off&lt;/code&gt;. This parameter can only be set at server start.</source>
          <target state="translated">如果LLVM具有所需的功能，则发出允许perf剖析JIT生成的功能所需的数据。这会将文件写到 &lt;code&gt;$HOME/.debug/jit/&lt;/code&gt; ; 用户负责在需要时执行清理。默认设置为 &lt;code&gt;off&lt;/code&gt; 。该参数只能在服务器启动时设置。</target>
        </trans-unit>
        <trans-unit id="ef3c317e4d741dc71490a33136e9ff9dc5428c13" translate="yes" xml:space="preserve">
          <source>If LLVM has the required functionality, register generated functions with GDB. This makes debugging easier. The default setting is &lt;code&gt;off&lt;/code&gt;. This parameter can only be set at server start.</source>
          <target state="translated">如果LLVM具有所需的功能，请向GDB注册生成的功能。这使调试更加容易。默认设置为 &lt;code&gt;off&lt;/code&gt; 。该参数只能在服务器启动时设置。</target>
        </trans-unit>
        <trans-unit id="efe3f3026039f58c4fe8aa03beba8ad31146f904" translate="yes" xml:space="preserve">
          <source>If OIDs are included in the file, the OID field immediately follows the field-count word. It is a normal field except that it's not included in the field-count. Note that oid system columns are not supported in current versions of PostgreSQL.</source>
          <target state="translated">如果文件中包含了OID,OID字段紧跟在字段计数字后面。它是一个正常的字段,只是它不包含在字段计数中。注意,当前版本的PostgreSQL不支持oid系统列。</target>
        </trans-unit>
        <trans-unit id="8e65f986646d4bd64aa08e3d223eb8fd14aab146" translate="yes" xml:space="preserve">
          <source>If PAM is set up to read &lt;code&gt;/etc/shadow&lt;/code&gt;, authentication will fail because the PostgreSQL server is started by a non-root user. However, this is not an issue when PAM is configured to use LDAP or other authentication methods.</source>
          <target state="translated">如果将PAM设置为读取 &lt;code&gt;/etc/shadow&lt;/code&gt; ，则身份验证将失败，因为PostgreSQL服务器是由非root用户启动的。但是，当PAM配置为使用LDAP或其他身份验证方法时，这不是问题。</target>
        </trans-unit>
        <trans-unit id="415ce588e29ad070811b2db4490099f305d07266" translate="yes" xml:space="preserve">
          <source>If PostgreSQL itself is the cause of the system running out of memory, you can avoid the problem by changing your configuration. In some cases, it may help to lower memory-related configuration parameters, particularly &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;&lt;code&gt;shared_buffers&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt;&lt;code&gt;work_mem&lt;/code&gt;&lt;/a&gt;. In other cases, the problem may be caused by allowing too many connections to the database server itself. In many cases, it may be better to reduce &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;&lt;code&gt;max_connections&lt;/code&gt;&lt;/a&gt; and instead make use of external connection-pooling software.</source>
          <target state="translated">如果PostgreSQL本身是导致系统内存不足的原因，则可以通过更改配置来避免此问题。在某些情况下，这可能有助于降低与内存相关的配置参数，尤其是&lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt; &lt;code&gt;shared_buffers&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt; &lt;code&gt;work_mem&lt;/code&gt; &lt;/a&gt;。在其他情况下，此问题可能是由于允许与数据库服务器本身的连接过多而引起的。在许多情况下，最好减少&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt; &lt;code&gt;max_connections&lt;/code&gt; &lt;/a&gt;，而改用外部连接池软件。</target>
        </trans-unit>
        <trans-unit id="6e051bc67e0a6c331eb48a8b787733592331e28c" translate="yes" xml:space="preserve">
          <source>If PostgreSQL itself is the cause of the system running out of memory, you can avoid the problem by changing your configuration. In some cases, it may help to lower memory-related configuration parameters, particularly &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;&lt;code&gt;shared_buffers&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt;&lt;code&gt;work_mem&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;runtime-config-resource#GUC-HASH-MEM-MULTIPLIER&quot;&gt;&lt;code&gt;hash_mem_multiplier&lt;/code&gt;&lt;/a&gt;. In other cases, the problem may be caused by allowing too many connections to the database server itself. In many cases, it may be better to reduce &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;&lt;code&gt;max_connections&lt;/code&gt;&lt;/a&gt; and instead make use of external connection-pooling software.</source>
          <target state="translated">如果PostgreSQL本身是导致系统内存不足的原因，则可以通过更改配置来避免此问题。在某些情况下，它可能有助于降低与内存相关的配置参数，尤其是&lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt; &lt;code&gt;shared_buffers&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt; &lt;code&gt;work_mem&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;runtime-config-resource#GUC-HASH-MEM-MULTIPLIER&quot;&gt; &lt;code&gt;hash_mem_multiplier&lt;/code&gt; &lt;/a&gt;。在其他情况下，此问题可能是由于允许与数据库服务器本身的连接过多而引起的。在许多情况下，最好减少&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt; &lt;code&gt;max_connections&lt;/code&gt; &lt;/a&gt;，而使用外部连接池软件。</target>
        </trans-unit>
        <trans-unit id="ce5c2e1e6b44cb1c8622c0c5ffed0c31ab912017" translate="yes" xml:space="preserve">
          <source>If PostgreSQL was compiled with OpenLDAP as the LDAP client library, the &lt;code&gt;ldapserver&lt;/code&gt; setting may be omitted. In that case, a list of host names and ports is looked up via RFC 2782 DNS SRV records. The name &lt;code&gt;_ldap._tcp.DOMAIN&lt;/code&gt; is looked up, where &lt;code&gt;DOMAIN&lt;/code&gt; is extracted from &lt;code&gt;ldapbasedn&lt;/code&gt;.</source>
          <target state="translated">如果PostgreSQL是使用OpenLDAP作为LDAP客户端库编译的，则 &lt;code&gt;ldapserver&lt;/code&gt; 设置可以省略。在这种情况下，将通过RFC 2782 DNS SRV记录查找主机名和端口的列表。查找名称 &lt;code&gt;_ldap._tcp.DOMAIN&lt;/code&gt; ，从 &lt;code&gt;ldapbasedn&lt;/code&gt; 中提取 &lt;code&gt;DOMAIN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f92e62044fa208f984d06131f910dfb1c21e1338" translate="yes" xml:space="preserve">
          <source>If SELinux is disabled or not installed, you must set that product up first before installing this module.</source>
          <target state="translated">如果SELinux被禁用或未安装,则必须先设置该产品,然后再安装该模块。</target>
        </trans-unit>
        <trans-unit id="a9341d807a078bf8721a956d7df4d8eca09e01a0" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt; command is executed while a base backup is being taken, and then the template database that the &lt;code&gt;CREATE DATABASE&lt;/code&gt; copied is modified while the base backup is still in progress, it is possible that recovery will cause those modifications to be propagated into the created database as well. This is of course undesirable. To avoid this risk, it is best not to modify any template databases while taking a base backup.</source>
          <target state="translated">如果在执行基本备份时执行了&lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt;命令，然后在仍在进行基本备份的同时修改了 &lt;code&gt;CREATE DATABASE&lt;/code&gt; 复制的模板数据库，则恢复很可能会使这些修改传播到数据库中。创建数据库。这当然是不希望的。为避免这种风险，最好在进行基本备份时不要修改任何模板数据库。</target>
        </trans-unit>
        <trans-unit id="fa1de3a6861be1ec1b6ec90aa7e6b3e06531f1df" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;DROP&lt;/code&gt; command lists multiple objects, &lt;code&gt;CASCADE&lt;/code&gt; is only required when there are dependencies outside the specified group. For example, when saying &lt;code&gt;DROP TABLE tab1, tab2&lt;/code&gt; the existence of a foreign key referencing &lt;code&gt;tab1&lt;/code&gt; from &lt;code&gt;tab2&lt;/code&gt; would not mean that &lt;code&gt;CASCADE&lt;/code&gt; is needed to succeed.</source>
          <target state="translated">如果 &lt;code&gt;DROP&lt;/code&gt; 命令列出了多个对象，则仅当在指定组之外存在依赖项时才需要 &lt;code&gt;CASCADE&lt;/code&gt; 。例如，当说出 &lt;code&gt;DROP TABLE tab1, tab2&lt;/code&gt; ，存在一个引用来自 &lt;code&gt;tab2&lt;/code&gt; 的 &lt;code&gt;tab1&lt;/code&gt; 的外键并不意味着需要 &lt;code&gt;CASCADE&lt;/code&gt; 才能成功。</target>
        </trans-unit>
        <trans-unit id="92e1a30bd1d3658160c72094059d0371a401f9cd" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;SET&lt;/code&gt; clause is attached to a function, then the effects of a &lt;code&gt;SET LOCAL&lt;/code&gt; command executed inside the function for the same variable are restricted to the function: the configuration parameter's prior value is still restored at function exit. However, an ordinary &lt;code&gt;SET&lt;/code&gt; command (without &lt;code&gt;LOCAL&lt;/code&gt;) overrides the &lt;code&gt;SET&lt;/code&gt; clause, much as it would do for a previous &lt;code&gt;SET LOCAL&lt;/code&gt; command: the effects of such a command will persist after function exit, unless the current transaction is rolled back.</source>
          <target state="translated">如果将 &lt;code&gt;SET&lt;/code&gt; 子句附加到函数，则在函数内针对同一变量执行的 &lt;code&gt;SET LOCAL&lt;/code&gt; 命令的作用仅限于该函数：配置参数的先前值仍在函数退出时恢复。但是，普通的 &lt;code&gt;SET&lt;/code&gt; 命令（不带 &lt;code&gt;LOCAL&lt;/code&gt; ）会覆盖 &lt;code&gt;SET&lt;/code&gt; 子句，就像对先前的 &lt;code&gt;SET LOCAL&lt;/code&gt; 命令所做的一样：除非函数返回，否则此命令的作用将在函数退出后继续存在。</target>
        </trans-unit>
        <trans-unit id="9c0a79a4075f581261c7fcce27f70643bea75e21" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;SET&lt;/code&gt; clause is attached to a procedure, then that procedure cannot execute transaction control statements (for example, &lt;code&gt;COMMIT&lt;/code&gt; and &lt;code&gt;ROLLBACK&lt;/code&gt;, depending on the language).</source>
          <target state="translated">如果将 &lt;code&gt;SET&lt;/code&gt; 子句附加到过程，则该过程将无法执行事务控制语句（例如， &lt;code&gt;COMMIT&lt;/code&gt; 和 &lt;code&gt;ROLLBACK&lt;/code&gt; ，具体取决于语言）。</target>
        </trans-unit>
        <trans-unit id="f0bddcb97ee43256f36e19dc04e898959e413d86" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;SET&lt;/code&gt; clause is attached to a procedure, then the effects of a &lt;code&gt;SET LOCAL&lt;/code&gt; command executed inside the procedure for the same variable are restricted to the procedure: the configuration parameter's prior value is still restored at procedure exit. However, an ordinary &lt;code&gt;SET&lt;/code&gt; command (without &lt;code&gt;LOCAL&lt;/code&gt;) overrides the &lt;code&gt;SET&lt;/code&gt; clause, much as it would do for a previous &lt;code&gt;SET LOCAL&lt;/code&gt; command: the effects of such a command will persist after procedure exit, unless the current transaction is rolled back.</source>
          <target state="translated">如果将 &lt;code&gt;SET&lt;/code&gt; 子句附加到过程，则在该过程内针对同一变量执行的 &lt;code&gt;SET LOCAL&lt;/code&gt; 命令的作用仅限于该过程：在过程退出时仍会恢复配置参数的先前值。但是，普通的 &lt;code&gt;SET&lt;/code&gt; 命令（不带 &lt;code&gt;LOCAL&lt;/code&gt; ）会覆盖 &lt;code&gt;SET&lt;/code&gt; 子句，就像对以前的 &lt;code&gt;SET LOCAL&lt;/code&gt; 命令所做的一样：除非过程回滚，否则该命令的作用将在过程退出后继续存在。</target>
        </trans-unit>
        <trans-unit id="902cabcc62fcf46f7c4713fa1c043b73884c956f" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;filename&lt;/code&gt; or &lt;code&gt;|&lt;/code&gt;&lt;code&gt;command&lt;/code&gt; argument is given, the query's output is written to the named file or piped to the given shell command, instead of displaying it as usual. The file or command is written to only if the query successfully returns zero or more tuples, not if the query fails or is a non-data-returning SQL command.</source>
          <target state="translated">如果是 &lt;code&gt;filename&lt;/code&gt; 或 &lt;code&gt;|&lt;/code&gt; 给定 &lt;code&gt;command&lt;/code&gt; 参数，查询的输出将写入指定的文件或通过管道传递到给定的shell命令，而不是像往常一样显示它。仅当查询成功返回零个或多个元组时，才写入文件或命令，如果查询失败或是不返回数据的SQL命令，则不写入文件或命令。</target>
        </trans-unit>
        <trans-unit id="dc2402d507bf01ad0609465ee16a38cc42b24afe" translate="yes" xml:space="preserve">
          <source>If a check constraint, an internal representation of the expression. (It's recommended to use &lt;code&gt;pg_get_constraintdef()&lt;/code&gt; to extract the definition of a check constraint.)</source>
          <target state="translated">如果是检查约束，则为表达式的内部表示。（建议使用 &lt;code&gt;pg_get_constraintdef()&lt;/code&gt; 提取检查约束的定义。）</target>
        </trans-unit>
        <trans-unit id="f25b711856ae449f9c3d73dd4473185e384f4706" translate="yes" xml:space="preserve">
          <source>If a column in the parent table is an identity column, that property is not inherited. A column in the child table can be declared identity column if desired.</source>
          <target state="translated">如果父表中的一列是身份列,那么该属性不会被继承。如果需要的话,子表中的列可以被声明为身份列。</target>
        </trans-unit>
        <trans-unit id="90d9a8592c9a8387fcf3bd4a77c9762fb9a47cc1" translate="yes" xml:space="preserve">
          <source>If a column list is specified, &lt;code&gt;COPY TO&lt;/code&gt; copies only the data in the specified columns to the file. For &lt;code&gt;COPY FROM&lt;/code&gt;, each field in the file is inserted, in order, into the specified column. Table columns not specified in the &lt;code&gt;COPY FROM&lt;/code&gt; column list will receive their default values.</source>
          <target state="translated">如果指定了列列表，则 &lt;code&gt;COPY TO&lt;/code&gt; 仅将指定列中的数据复制到文件中。对于 &lt;code&gt;COPY FROM&lt;/code&gt; ，文件中的每个字段按顺序插入到指定的列中。在 &lt;code&gt;COPY FROM&lt;/code&gt; 列列表中未指定的表列将接收其默认值。</target>
        </trans-unit>
        <trans-unit id="c8c03e9dff51a371ecb3dbf0f3542cbc1ae0bd39" translate="yes" xml:space="preserve">
          <source>If a column list is specified, you only need &lt;code&gt;INSERT&lt;/code&gt; privilege on the listed columns. Similarly, when &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; is specified, you only need &lt;code&gt;UPDATE&lt;/code&gt; privilege on the column(s) that are listed to be updated. However, &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; also requires &lt;code&gt;SELECT&lt;/code&gt; privilege on any column whose values are read in the &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; expressions or &lt;code&gt;condition&lt;/code&gt;.</source>
          <target state="translated">如果指定了列列表，则只需要对列出的列具有 &lt;code&gt;INSERT&lt;/code&gt; 特权。同样，当指定 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 时，您只需要列出要更新的列的 &lt;code&gt;UPDATE&lt;/code&gt; 特权。但是， &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 还需要在 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 表达式或 &lt;code&gt;condition&lt;/code&gt; 中读取其值的任何列上具有 &lt;code&gt;SELECT&lt;/code&gt; 特权。</target>
        </trans-unit>
        <trans-unit id="6ae12c756d83d3fa84f0842896261c6e6de98fbd" translate="yes" xml:space="preserve">
          <source>If a column result is NULL, the corresponding variable is unset rather than being set.</source>
          <target state="translated">如果一个列的结果是NULL,那么对应的变量就会被取消设置而不是被设置。</target>
        </trans-unit>
        <trans-unit id="cd07d38bba484cac13838ebc8d7dd08509069d67" translate="yes" xml:space="preserve">
          <source>If a column's XPath expression returns a non-XML value (limited to string, boolean, or double in XPath 1.0) and the column has a PostgreSQL type other than &lt;code&gt;xml&lt;/code&gt;, the column will be set as if by assigning the value's string representation to the PostgreSQL type. (If the value is a boolean, its string representation is taken to be &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt; if the output column's type category is numeric, otherwise &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.)</source>
          <target state="translated">如果列的XPath表达式返回非XML值（在XPath 1.0中限制为字符串，布尔值或双精度），并且该列具有 &lt;code&gt;xml&lt;/code&gt; 以外的PostgreSQL类型，则该列的设置方式就像是通过将值的字符串表示形式分配给PostgreSQL类型。（如果值是布尔值，则如果输出列的类型类别为数字，则其字符串表示形式将为 &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt; ，否则为 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="3d86c8d327357d64a90febd0e7b2a64229fc6de1" translate="yes" xml:space="preserve">
          <source>If a column's XPath expression returns a non-XML value (which is limited to string, boolean, or double in XPath 1.0) and the column has a PostgreSQL type other than &lt;code&gt;xml&lt;/code&gt;, the column will be set as if by assigning the value's string representation to the PostgreSQL type. (If the value is a boolean, its string representation is taken to be &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt; if the output column's type category is numeric, otherwise &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.)</source>
          <target state="translated">如果列的XPath表达式返回非XML值（在XPath 1.0中限制为字符串，布尔值或双精度），并且该列具有 &lt;code&gt;xml&lt;/code&gt; 以外的PostgreSQL类型，则该列的设置方式类似于通过分配值的字符串表示形式到PostgreSQL类型。（如果值是布尔值，则如果输出列的类型类别为数字，则其字符串表示形式将为 &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt; ，否则为 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="dd49d82e6f7364358b7e1308125e6548ff45efeb" translate="yes" xml:space="preserve">
          <source>If a column's XPath expression returns a non-empty set of XML nodes and the column's PostgreSQL type is &lt;code&gt;xml&lt;/code&gt;, the column will be assigned the expression result exactly, if it is of document or content form. &lt;a href=&quot;#ftn.id-1.5.8.19.7.5.14.2&quot;&gt;&lt;sup id=&quot;id-1.5.8.19.7.5.14.2&quot;&gt;[8]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">如果列的XPath表达式返回一组非空的XML节点，并且该列的PostgreSQL类型是 &lt;code&gt;xml&lt;/code&gt; ，则该列将被精确分配表达式结果（如果它是文档形式或内容形式）。&lt;a href=&quot;#ftn.id-1.5.8.19.7.5.14.2&quot;&gt;&lt;sup id=&quot;id-1.5.8.19.7.5.14.2&quot;&gt;[8]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7f606ba5da3ce72a5b48e1fa0637f31121b0521b" translate="yes" xml:space="preserve">
          <source>If a column's XPath expression returns a non-empty set of XML nodes and the column's PostgreSQL type is &lt;code&gt;xml&lt;/code&gt;, the column will be assigned the expression result exactly, if it is of document or content form. &lt;a href=&quot;#ftn.id-1.5.8.21.7.5.15.2&quot;&gt;&lt;sup id=&quot;id-1.5.8.21.7.5.15.2&quot;&gt;[7]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">如果列的XPath表达式返回一组非空的XML节点，并且该列的PostgreSQL类型是 &lt;code&gt;xml&lt;/code&gt; ，则该列将被精确分配表达式结果（如果它是文档形式或内容形式）。&lt;a href=&quot;#ftn.id-1.5.8.21.7.5.15.2&quot;&gt;&lt;sup id=&quot;id-1.5.8.21.7.5.15.2&quot;&gt;[7]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2001ae15ca417e0e9b4706925c6ddabecd8102f7" translate="yes" xml:space="preserve">
          <source>If a conflicting row has been inserted by an as-yet-uncommitted transaction, the would-be inserter must wait to see if that transaction commits. If it rolls back then there is no conflict. If it commits without deleting the conflicting row again, there is a uniqueness violation. (In practice we just wait for the other transaction to end and then redo the visibility check in toto.)</source>
          <target state="translated">如果一条冲突的记录已经被一个尚未提交的事务插入,潜在的插入者必须等待该事务是否提交。如果它回滚,那么就不存在冲突。如果它没有再次删除冲突的记录就提交了,那么就存在唯一性违规。(在实践中,我们只需等待另一个事务结束,然后重新做可见性检查)。</target>
        </trans-unit>
        <trans-unit id="25c5a233f983a5a11d2f0ce26b28af3fbae3c56b" translate="yes" xml:space="preserve">
          <source>If a conflicting valid row has been deleted by the current transaction, it's okay. (In particular, since an UPDATE always deletes the old row version before inserting the new version, this will allow an UPDATE on a row without changing the key.)</source>
          <target state="translated">如果一条有冲突的有效行已经被当前事务删除了,那就没问题了(特别是,由于UPDATE总是在插入新的版本之前删除旧的行版本,所以这将允许在不改变键的情况下对一条行进行UPDATE)。</target>
        </trans-unit>
        <trans-unit id="2370b745676126171b063e2e2d72095b349175fc" translate="yes" xml:space="preserve">
          <source>If a constraint is deferrable, this clause specifies the default time to check the constraint. If the constraint is &lt;code&gt;INITIALLY IMMEDIATE&lt;/code&gt;, it is checked after each statement. This is the default. If the constraint is &lt;code&gt;INITIALLY DEFERRED&lt;/code&gt;, it is checked only at the end of the transaction. The constraint check time can be altered with the &lt;a href=&quot;sql-set-constraints&quot;&gt;SET CONSTRAINTS&lt;/a&gt; command.</source>
          <target state="translated">如果约束是可延迟的，则此子句指定检查约束的默认时间。如果该约束是 &lt;code&gt;INITIALLY IMMEDIATE&lt;/code&gt; ，则在每个语句之后对其进行检查。这是默认值。如果约束是 &lt;code&gt;INITIALLY DEFERRED&lt;/code&gt; ，则仅在事务结束时进行检查。可以使用&lt;a href=&quot;sql-set-constraints&quot;&gt;SET CONSTRAINTS&lt;/a&gt;命令更改约束检查时间。</target>
        </trans-unit>
        <trans-unit id="45ddd1496c9c8970f749841790d5cc33a1ed958c" translate="yes" xml:space="preserve">
          <source>If a constraint name is provided then the index will be renamed to match the constraint name. Otherwise the constraint will be named the same as the index.</source>
          <target state="translated">如果提供了约束名称,那么索引将被重新命名以匹配约束名称。否则,约束将被命名为与索引相同。</target>
        </trans-unit>
        <trans-unit id="516a948273fe630c2fd2d3bb4954b014ec3a728f" translate="yes" xml:space="preserve">
          <source>If a cursor is closed after a savepoint which is later rolled back, the &lt;code&gt;CLOSE&lt;/code&gt; is not rolled back; that is, the cursor remains closed.</source>
          <target state="translated">如果在保存点之后关闭游标，该保存点随后会回滚，则 &lt;code&gt;CLOSE&lt;/code&gt; 不会回滚；即，光标保持关闭状态。</target>
        </trans-unit>
        <trans-unit id="6755c4a78a3da118c77dadc78bfef40de55f4e2d" translate="yes" xml:space="preserve">
          <source>If a daylight-savings abbreviation is given but the transition &lt;code&gt;rule&lt;/code&gt; field is omitted, the fallback behavior is to use the rule &lt;code&gt;M3.2.0,M11.1.0&lt;/code&gt;, which corresponds to USA practice as of 2020 (that is, spring forward on the second Sunday of March, fall back on the first Sunday of November, both transitions occurring at 2AM prevailing time). Note that this rule does not give correct USA transition dates for years before 2007.</source>
          <target state="translated">如果给出了夏令时的缩写，但忽略了过渡 &lt;code&gt;rule&lt;/code&gt; 字段，则后备行为将使用规则 &lt;code&gt;M3.2.0,M11.1.0&lt;/code&gt; ，该规则与2020年的美国惯例相对应（即，在第二个星期日开始前进） 3月，则回退到11月的第一个星期日，这两个转换均发生在凌晨2点。请注意，此规则并未为2007年之前的年份提供正确的美国过渡日期。</target>
        </trans-unit>
        <trans-unit id="0b8ad01bd9eefe5ae6504ee533b29e5940a9bbcc" translate="yes" xml:space="preserve">
          <source>If a different escape character than backslash is desired, it can be specified using the &lt;code&gt;UESCAPE&lt;/code&gt; clause after the string, for example:</source>
          <target state="translated">如果希望使用与反斜杠不同的转义字符，则可以在字符串后使用 &lt;code&gt;UESCAPE&lt;/code&gt; 子句来指定它，例如：</target>
        </trans-unit>
        <trans-unit id="8c0e309df60d6b04409ae8154560e144f149154e" translate="yes" xml:space="preserve">
          <source>If a dynamically loadable module needs to be opened and the file name specified in the &lt;code&gt;CREATE FUNCTION&lt;/code&gt; or &lt;code&gt;LOAD&lt;/code&gt; command does not have a directory component (i.e., the name does not contain a slash), the system will search this path for the required file.</source>
          <target state="translated">如果需要打开可动态加载的模块，并且在 &lt;code&gt;CREATE FUNCTION&lt;/code&gt; 或 &lt;code&gt;LOAD&lt;/code&gt; 命令中指定的文件名不包含目录组件（即，该名称不包含斜杠），则系统将在此路径中搜索所需的文件。</target>
        </trans-unit>
        <trans-unit id="eead72d18dc8bb550762010fb49abdc92926fc22" translate="yes" xml:space="preserve">
          <source>If a foreign key, list of the equality operators for FK = FK comparisons</source>
          <target state="translated">如果是外键,则列出FK=FK比较的平等运算符。</target>
        </trans-unit>
        <trans-unit id="f2557ac45b6d34f20af024d349a08e662002e006" translate="yes" xml:space="preserve">
          <source>If a foreign key, list of the equality operators for PK = FK comparisons</source>
          <target state="translated">如果是外键,PK=FK比较的平等运算符列表</target>
        </trans-unit>
        <trans-unit id="65b7a7238de39c08afb78813e4651af5cc557847" translate="yes" xml:space="preserve">
          <source>If a foreign key, list of the equality operators for PK = PK comparisons</source>
          <target state="translated">如果是外键,PK=PK比较的平等运算符列表</target>
        </trans-unit>
        <trans-unit id="84b58f81bb95714e62ab14756a76120d62320f41" translate="yes" xml:space="preserve">
          <source>If a foreign key, list of the referenced columns</source>
          <target state="translated">如果是外键,则列出被引用的列。</target>
        </trans-unit>
        <trans-unit id="7870e560cb55fb3708abcfcfa26fc2aa507576ee" translate="yes" xml:space="preserve">
          <source>If a foreign key, the referenced table; else 0</source>
          <target state="translated">如果是外键,则为引用的表;否则为0。</target>
        </trans-unit>
        <trans-unit id="575611ec6feb49c10dfac57d786d3e40ac55a75b" translate="yes" xml:space="preserve">
          <source>If a fractional value is specified with a unit, it will be rounded to a multiple of the next smaller unit if there is one. For example, &lt;code&gt;30.1 GB&lt;/code&gt; will be converted to &lt;code&gt;30822 MB&lt;/code&gt; not &lt;code&gt;32319628902 B&lt;/code&gt;. If the parameter is of integer type, a final rounding to integer occurs after any unit conversion.</source>
          <target state="translated">如果用单位指定分数值，则如果存在小数，则将四舍五入为下一个较小单位的倍数。例如， &lt;code&gt;30.1 GB&lt;/code&gt; 将被转换为 &lt;code&gt;30822 MB&lt;/code&gt; 不 &lt;code&gt;32319628902 B&lt;/code&gt; 。如果参数是整数类型，则在任何单位转换后都会进行最后四舍五入为整数。</target>
        </trans-unit>
        <trans-unit id="302fc67ef061c10f65906072775cc6ba157a3bf8" translate="yes" xml:space="preserve">
          <source>If a fractional value is specified with a unit, it will be rounded to a multiple of the next smaller unit if there is one. For example, &lt;code&gt;30.1 GB&lt;/code&gt; will be converted to &lt;code&gt;30822 MB&lt;/code&gt; not &lt;code&gt;32319628902 B&lt;/code&gt;. If the parameter is of integer type, a final rounding to integer occurs after any units conversion.</source>
          <target state="translated">如果用单位指定分数值，则如果存在小数，则将四舍五入为下一个较小单位的倍数。例如， &lt;code&gt;30.1 GB&lt;/code&gt; 将被转换为 &lt;code&gt;30822 MB&lt;/code&gt; 不 &lt;code&gt;32319628902 B&lt;/code&gt; 。如果参数是整数类型，则在任何单位转换后都会进行最后舍入为整数。</target>
        </trans-unit>
        <trans-unit id="16517351d5f6d1324d494a56b7cbc1349aadbd26" translate="yes" xml:space="preserve">
          <source>If a function executed within a parallel worker acquires locks which are not held by the leader, for example by querying a table not referenced in the query, those locks will be released at worker exit, not end of transaction. If you write a function which does this, and this behavior difference is important to you, mark such functions as &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; to ensure that they execute only in the leader.</source>
          <target state="translated">如果在并行工作程序中执行的函数获取了领导者未持有的锁，例如通过查询查询中未引用的表，则这些锁将在工作程序出口而不是事务结束时释放。如果编写执行此操作的函数，并且这种行为差异对您很重要，则将此类函数标记为 &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; ,以确保它们仅在领导者中执行。</target>
        </trans-unit>
        <trans-unit id="c08af80c4ec0b88bc818f2eba0deaa5cfe1fa698" translate="yes" xml:space="preserve">
          <source>If a function is declared &lt;code&gt;STRICT&lt;/code&gt; with a &lt;code&gt;VARIADIC&lt;/code&gt; argument, the strictness check tests that the variadic array &lt;em&gt;as a whole&lt;/em&gt; is non-null. The function will still be called if the array has null elements.</source>
          <target state="translated">如果使用 &lt;code&gt;VARIADIC&lt;/code&gt; 参数将函数声明为 &lt;code&gt;STRICT&lt;/code&gt; ，则严格性检查将测试可变参数数组&lt;em&gt;整体&lt;/em&gt;是否为非空。如果数组包含空元素，该函数仍将被调用。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3d9a8948caa2988125e4b727f3b2df8159e037f5" translate="yes" xml:space="preserve">
          <source>If a function is declared with a &lt;code&gt;VARIADIC&lt;/code&gt; array parameter, and the call does not use the &lt;code&gt;VARIADIC&lt;/code&gt; keyword, then the function is treated as if the array parameter were replaced by one or more occurrences of its element type, as needed to match the call. After such expansion the function might have effective argument types identical to some non-variadic function. In that case the function appearing earlier in the search path is used, or if the two functions are in the same schema, the non-variadic one is preferred.</source>
          <target state="translated">如果使用 &lt;code&gt;VARIADIC&lt;/code&gt; 数组参数声明了一个函数，并且该调用未使用 &lt;code&gt;VARIADIC&lt;/code&gt; 关键字，则将该函数视为将数组参数替换为一次或多次出现的其元素类型，以匹配该调用。进行此类扩展后，该函数可能具有与某些非变量函数相同的有效参数类型。在这种情况下，将使用搜索路径中较早出现的功能，或者如果两个功能处于同一模式中，则首选非可变功能。</target>
        </trans-unit>
        <trans-unit id="29873e6b07ca3d965e9bf60280fc04e4b50e061e" translate="yes" xml:space="preserve">
          <source>If a generic plan is in use, it will contain parameter symbols &lt;code&gt;$n&lt;/code&gt;, while a custom plan will have the supplied parameter values substituted into it.</source>
          <target state="translated">如果正在使用通用计划，它将包含参数符号 &lt;code&gt;$n&lt;/code&gt; ，而自定义计划将替换提供的参数值。</target>
        </trans-unit>
        <trans-unit id="b9eddb833bc9b9e1959393e089ee3b45e63b93cb" translate="yes" xml:space="preserve">
          <source>If a host name is specified (anything that is not an IP address range or a special key word is treated as a host name), that name is compared with the result of a reverse name resolution of the client's IP address (e.g., reverse DNS lookup, if DNS is used). Host name comparisons are case insensitive. If there is a match, then a forward name resolution (e.g., forward DNS lookup) is performed on the host name to check whether any of the addresses it resolves to are equal to the client's IP address. If both directions match, then the entry is considered to match. (The host name that is used in &lt;code&gt;pg_hba.conf&lt;/code&gt; should be the one that address-to-name resolution of the client's IP address returns, otherwise the line won't be matched. Some host name databases allow associating an IP address with multiple host names, but the operating system will only return one host name when asked to resolve an IP address.)</source>
          <target state="translated">如果指定了主机名（非IP地址范围或特殊关键字的任何内容都被视为主机名），则将该名称与客户端IP地址的反向名称解析结果（例如反向DNS）进行比较查找（如果使用DNS）。主机名比较不区分大小写。如果存在匹配，则对主机名执行前向名称解析（例如，前向DNS查找）以检查其解析为的地址中的任何一个是否等于客户端的IP地址。如果两个方向都匹配，则认为该条目匹配。 （在 &lt;code&gt;pg_hba.conf&lt;/code&gt; 中使用的主机名应该是客户端IP地址的地址到名称解析返回的地址，否则该行将不匹配。某些主机名数据库允许将IP地址与多个主机名相关联，但是当系统要求您解析IP地址时，操作系统只会返回一个主机名。）</target>
        </trans-unit>
        <trans-unit id="29821b670fa593b8c5ed4db6b848a4180ea0c1c3" translate="yes" xml:space="preserve">
          <source>If a limit count is given, no more than that many rows will be returned (but possibly fewer, if the query itself yields fewer rows). &lt;code&gt;LIMIT ALL&lt;/code&gt; is the same as omitting the &lt;code&gt;LIMIT&lt;/code&gt; clause, as is &lt;code&gt;LIMIT&lt;/code&gt; with a NULL argument.</source>
          <target state="translated">如果给出了限制计数，则返回的行数不会超过该行数（但如果查询本身产生的行数较少，则返回的行数可能会更少）。 &lt;code&gt;LIMIT ALL&lt;/code&gt; 与省略 &lt;code&gt;LIMIT&lt;/code&gt; 子句相同， &lt;code&gt;LIMIT&lt;/code&gt; 与NULL参数相同。</target>
        </trans-unit>
        <trans-unit id="2e0f012a9c847bea5735587a0a262fd8fc04fc30" translate="yes" xml:space="preserve">
          <source>If a line number is specified, psql will position the cursor on the specified line of the file or query buffer. Note that if a single all-digits argument is given, psql assumes it is a line number, not a file name.</source>
          <target state="translated">如果指定了行号,psql将把光标定位在文件或查询缓冲区的指定行上。注意,如果给定了一个全数字参数,psql假定它是一个行号,而不是一个文件名。</target>
        </trans-unit>
        <trans-unit id="989ad942cdac74f48ff0f663910b668e0bfcd851" translate="yes" xml:space="preserve">
          <source>If a line number is specified, psql will position the cursor on the specified line of the function body. (Note that the function body typically does not begin on the first line of the file.)</source>
          <target state="translated">如果指定了行号,psql将把光标定位在函数体的指定行上。(注意,函数体通常不从文件的第一行开始。)</target>
        </trans-unit>
        <trans-unit id="f28240e112ab05b43febc5915be398cc2c0ace7d" translate="yes" xml:space="preserve">
          <source>If a line number is specified, psql will position the cursor on the specified line of the view definition.</source>
          <target state="translated">如果指定了行号,psql将把光标定位在视图定义的指定行上。</target>
        </trans-unit>
        <trans-unit id="e1603d0c375b802bfd8ff93da28473ffff6f9ce0" translate="yes" xml:space="preserve">
          <source>If a list of columns is specified, &lt;code&gt;COPY&lt;/code&gt; will only copy the data in the specified columns to or from the file. If there are any columns in the table that are not in the column list, &lt;code&gt;COPY FROM&lt;/code&gt; will insert the default values for those columns.</source>
          <target state="translated">如果指定了列列表，则 &lt;code&gt;COPY&lt;/code&gt; 只会将指定列中的数据复制到文件中或从文件复制。如果表中有任何列不在列列表中，则 &lt;code&gt;COPY FROM&lt;/code&gt; 将为这些列插入默认值。</target>
        </trans-unit>
        <trans-unit id="5d76d1bc7bed56c879e14e369962729e0bb7fe98" translate="yes" xml:space="preserve">
          <source>If a new child node must be added, set &lt;code&gt;resultType&lt;/code&gt; to &lt;code&gt;spgAddNode&lt;/code&gt;. Set &lt;code&gt;nodeLabel&lt;/code&gt; to the label to be used for the new node, and set &lt;code&gt;nodeN&lt;/code&gt; to the index (from zero) at which to insert the node in the node array. After the node has been added, the &lt;code&gt;choose&lt;/code&gt; function will be called again with the modified inner tuple; that call should result in an &lt;code&gt;spgMatchNode&lt;/code&gt; result.</source>
          <target state="translated">如果必须添加新的子节点，请将 &lt;code&gt;resultType&lt;/code&gt; 设置为 &lt;code&gt;spgAddNode&lt;/code&gt; 。将 &lt;code&gt;nodeLabel&lt;/code&gt; 设置为用于新节点的标签，并将 &lt;code&gt;nodeN&lt;/code&gt; 设置为将节点插入节点数组的索引（从零开始）。添加节点后，将使用修改后的内部元组再次调用 &lt;code&gt;choose&lt;/code&gt; 函数；该调用应产生一个 &lt;code&gt;spgMatchNode&lt;/code&gt; 结果。</target>
        </trans-unit>
        <trans-unit id="342f14a4cf8cecaaec4f439a2239828717657aec" translate="yes" xml:space="preserve">
          <source>If a parent column is a generated column, a child column must also be a generated column using the same expression. In the definition of the child column, leave off the &lt;code&gt;GENERATED&lt;/code&gt; clause, as it will be copied from the parent.</source>
          <target state="translated">如果父列是生成的列，则子列也必须是使用相同表达式的生成列。在子列的定义中，请忽略 &lt;code&gt;GENERATED&lt;/code&gt; 子句，因为它将从父列复制而来。</target>
        </trans-unit>
        <trans-unit id="bc7892c6f8a458e96e3334e518119041320e0ca8" translate="yes" xml:space="preserve">
          <source>If a parent column is not a generated column, a child column may be defined to be a generated column or not.</source>
          <target state="translated">如果父列不是生成列,子列可以定义为生成列,也可以不定义。</target>
        </trans-unit>
        <trans-unit id="c6c9e178ba05d52398d348d0978c9f0904579a20" translate="yes" xml:space="preserve">
          <source>If a part of the plan guarantees an ordering on a prefix of the required sort keys, then the planner may instead decide to use an &lt;code&gt;incremental sort&lt;/code&gt; step:</source>
          <target state="translated">如果计划的一部分保证对所需排序键的前缀进行排序，则计划者可以决定使用 &lt;code&gt;incremental sort&lt;/code&gt; 步骤：</target>
        </trans-unit>
        <trans-unit id="01753c01a634660c1afc91855a2bf3e6c0a24915" translate="yes" xml:space="preserve">
          <source>If a problem arises while rebuilding the indexes, such as a uniqueness violation in a unique index, the &lt;code&gt;REINDEX&lt;/code&gt; command will fail but leave behind an &amp;ldquo;invalid&amp;rdquo; new index in addition to the pre-existing one. This index will be ignored for querying purposes because it might be incomplete; however it will still consume update overhead. The psql &lt;code&gt;\d&lt;/code&gt; command will report such an index as &lt;code&gt;INVALID&lt;/code&gt;:</source>
          <target state="translated">如果在重建索引时出现问题，例如唯一索引中的唯一性冲突，则 &lt;code&gt;REINDEX&lt;/code&gt; 命令将失败，但除现有索引外，还会留下&amp;ldquo;无效&amp;rdquo;新索引。出于查询目的，该索引将被忽略，因为它可能不完整。但是它将仍然消耗更新开销。 psql &lt;code&gt;\d&lt;/code&gt; 命令将报告诸如 &lt;code&gt;INVALID&lt;/code&gt; 的索引：</target>
        </trans-unit>
        <trans-unit id="fc2fcf347772c27798939c43c378ac44b8d079f9" translate="yes" xml:space="preserve">
          <source>If a problem arises while scanning the table, such as a deadlock or a uniqueness violation in a unique index, the &lt;code&gt;CREATE INDEX&lt;/code&gt; command will fail but leave behind an &amp;ldquo;invalid&amp;rdquo; index. This index will be ignored for querying purposes because it might be incomplete; however it will still consume update overhead. The psql &lt;code&gt;\d&lt;/code&gt; command will report such an index as &lt;code&gt;INVALID&lt;/code&gt;:</source>
          <target state="translated">如果在扫描表时出现问题，例如死锁或唯一索引中的唯一性冲突，则 &lt;code&gt;CREATE INDEX&lt;/code&gt; 命令将失败，但留下&amp;ldquo;无效&amp;rdquo;索引。出于查询目的，该索引将被忽略，因为它可能不完整。但是它将仍然消耗更新开销。 psql &lt;code&gt;\d&lt;/code&gt; 命令将报告诸如 &lt;code&gt;INVALID&lt;/code&gt; 的索引：</target>
        </trans-unit>
        <trans-unit id="60b7f8c376b0c316858e3c03acae729e9e8e0bbd" translate="yes" xml:space="preserve">
          <source>If a problem like this arises, it may not affect each individual index that is ordered using an affected collation, simply because &lt;em&gt;indexed&lt;/em&gt; values might happen to have the same absolute ordering regardless of the behavioral inconsistency. See &lt;a href=&quot;locale&quot;&gt;Section 23.1&lt;/a&gt; and &lt;a href=&quot;collation&quot;&gt;Section 23.2&lt;/a&gt; for further details about how PostgreSQL uses operating system locales and collations.</source>
          <target state="translated">如果出现这样的问题，它可能不会影响使用受影响的排序规则排序的每个单独索引，这仅仅是因为&lt;em&gt;索引&lt;/em&gt;值可能碰巧具有相同的绝对排序，而与行为不一致无关。有关PostgreSQL如何使用操作系统语言环境和排序规则的更多详细信息，请参见&lt;a href=&quot;locale&quot;&gt;23.1节&lt;/a&gt;和&lt;a href=&quot;collation&quot;&gt;23.2节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="14159bc71155b473a106589680a4763fc75cdf28" translate="yes" xml:space="preserve">
          <source>If a query contains aggregate function calls, but no &lt;code&gt;GROUP BY&lt;/code&gt; clause, grouping still occurs: the result is a single group row (or perhaps no rows at all, if the single row is then eliminated by &lt;code&gt;HAVING&lt;/code&gt;). The same is true if it contains a &lt;code&gt;HAVING&lt;/code&gt; clause, even without any aggregate function calls or &lt;code&gt;GROUP BY&lt;/code&gt; clause.</source>
          <target state="translated">如果查询包含聚合函数调用，但没有 &lt;code&gt;GROUP BY&lt;/code&gt; 子句，则仍会发生分组：结果是单个组行（或者，如果随后通过 &lt;code&gt;HAVING&lt;/code&gt; 消除了单个行，则可能根本没有行）。如果它包含 &lt;code&gt;HAVING&lt;/code&gt; 子句，即使没有任何聚合函数调用或 &lt;code&gt;GROUP BY&lt;/code&gt; 子句，也是如此。</target>
        </trans-unit>
        <trans-unit id="7e2704031f22c0864166ff4a01e062f291652c11" translate="yes" xml:space="preserve">
          <source>If a query that is expected to do so does not produce a parallel plan, you can try reducing &lt;a href=&quot;runtime-config-query#GUC-PARALLEL-SETUP-COST&quot;&gt;parallel_setup_cost&lt;/a&gt; or &lt;a href=&quot;runtime-config-query#GUC-PARALLEL-TUPLE-COST&quot;&gt;parallel_tuple_cost&lt;/a&gt;. Of course, this plan may turn out to be slower than the serial plan which the planner preferred, but this will not always be the case. If you don't get a parallel plan even with very small values of these settings (e.g. after setting them both to zero), there may be some reason why the query planner is unable to generate a parallel plan for your query. See &lt;a href=&quot;when-can-parallel-query-be-used&quot;&gt;Section 15.2&lt;/a&gt; and &lt;a href=&quot;parallel-safety&quot;&gt;Section 15.4&lt;/a&gt; for information on why this may be the case.</source>
          <target state="translated">如果期望这样做不会产生并行计划，则可以尝试减少&lt;a href=&quot;runtime-config-query#GUC-PARALLEL-SETUP-COST&quot;&gt;parallel_setup_cost&lt;/a&gt;或&lt;a href=&quot;runtime-config-query#GUC-PARALLEL-TUPLE-COST&quot;&gt;parallel_tuple_cost&lt;/a&gt;。当然，该计划可能会比计划者偏爱的串行计划要慢，但并非总是如此。如果即使这些设置的值很小，也无法获得并行计划（例如，将它们都设置为零），则可能由于某些原因查询计划者无法为您的查询生成并行计划。有关为何可能会发生这种情况的信息，请参见&lt;a href=&quot;when-can-parallel-query-be-used&quot;&gt;第15.2节&lt;/a&gt;和&lt;a href=&quot;parallel-safety&quot;&gt;第15.4节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e703ec1af7c6fe8daa3820fdcecb57bac64cdaff" translate="yes" xml:space="preserve">
          <source>If a query that is expected to do so does not produce a parallel plan, you can try reducing &lt;a href=&quot;runtime-config-query#GUC-PARALLEL-SETUP-COST&quot;&gt;parallel_setup_cost&lt;/a&gt; or &lt;a href=&quot;runtime-config-query#GUC-PARALLEL-TUPLE-COST&quot;&gt;parallel_tuple_cost&lt;/a&gt;. Of course, this plan may turn out to be slower than the serial plan which the planner preferred, but this will not always be the case. If you don't get a parallel plan even with very small values of these settings (e.g., after setting them both to zero), there may be some reason why the query planner is unable to generate a parallel plan for your query. See &lt;a href=&quot;when-can-parallel-query-be-used&quot;&gt;Section 15.2&lt;/a&gt; and &lt;a href=&quot;parallel-safety&quot;&gt;Section 15.4&lt;/a&gt; for information on why this may be the case.</source>
          <target state="translated">如果期望这样做不会产生并行计划，则可以尝试减少&lt;a href=&quot;runtime-config-query#GUC-PARALLEL-SETUP-COST&quot;&gt;parallel_setup_cost&lt;/a&gt;或&lt;a href=&quot;runtime-config-query#GUC-PARALLEL-TUPLE-COST&quot;&gt;parallel_tuple_cost&lt;/a&gt;。当然，该计划可能会比计划者偏爱的串行计划要慢，但这并非总是如此。如果即使这些设置的值很小，您也无法获得并行计划（例如，将它们都设置为零），则可能由于某些原因，查询计划者无法为您的查询生成并行计划。有关为何可能会发生这种情况的信息，请参见&lt;a href=&quot;when-can-parallel-query-be-used&quot;&gt;第15.2节&lt;/a&gt;和&lt;a href=&quot;parallel-safety&quot;&gt;第15.4节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d78bc381604777d833daa7f8a441adef31412d42" translate="yes" xml:space="preserve">
          <source>If a query's results do not fit on the screen, they are piped through this command. Typical values are &lt;code&gt;more&lt;/code&gt; or &lt;code&gt;less&lt;/code&gt;. Use of the pager can be disabled by setting &lt;code&gt;PSQL_PAGER&lt;/code&gt; or &lt;code&gt;PAGER&lt;/code&gt; to an empty string, or by adjusting the pager-related options of the &lt;code&gt;\pset&lt;/code&gt; command. These variables are examined in the order listed; the first that is set is used. If none of them is set, the default is to use &lt;code&gt;more&lt;/code&gt; on most platforms, but &lt;code&gt;less&lt;/code&gt; on Cygwin.</source>
          <target state="translated">如果查询的结果不能显示在屏幕上，则通过此命令通过管道传递它们。典型值是 &lt;code&gt;more&lt;/code&gt; 或 &lt;code&gt;less&lt;/code&gt; 。可以通过将 &lt;code&gt;PSQL_PAGER&lt;/code&gt; 或 &lt;code&gt;PAGER&lt;/code&gt; 设置为空字符串或通过调整 &lt;code&gt;\pset&lt;/code&gt; 命令的与寻呼机相关的选项来禁用该寻呼机的使用。这些变量按照列出的顺序进行检查。使用设置的第一个。如果未设置它们，则默认值是在大多数平台上使用 &lt;code&gt;more&lt;/code&gt; ，而在Cygwin 上使用 &lt;code&gt;less&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a16d1e24e65d591a8270e12d2132334cb1a5266" translate="yes" xml:space="preserve">
          <source>If a schema name is given (for example, &lt;code&gt;CREATE AGGREGATE myschema.myagg ...&lt;/code&gt;) then the aggregate function is created in the specified schema. Otherwise it is created in the current schema.</source>
          <target state="translated">如果指定了架构名称（例如 &lt;code&gt;CREATE AGGREGATE myschema.myagg ...&lt;/code&gt; ），则将在指定的架构中创建聚合函数。否则，它将在当前架构中创建。</target>
        </trans-unit>
        <trans-unit id="9221069e2f8158080f0dab328adf9a4fc4ac50a4" translate="yes" xml:space="preserve">
          <source>If a schema name is given (for example, &lt;code&gt;CREATE DOMAIN myschema.mydomain ...&lt;/code&gt;) then the domain is created in the specified schema. Otherwise it is created in the current schema. The domain name must be unique among the types and domains existing in its schema.</source>
          <target state="translated">如果提供了架构名称（例如 &lt;code&gt;CREATE DOMAIN myschema.mydomain ...&lt;/code&gt; ），则将在指定的架构中创建域。否则，它将在当前架构中创建。域名在其架构中现有的类型和域之间必须唯一。</target>
        </trans-unit>
        <trans-unit id="2b01ea3ef0736036d56ce2802cb7af1e7ac1551f" translate="yes" xml:space="preserve">
          <source>If a schema name is given (for example, &lt;code&gt;CREATE FOREIGN TABLE myschema.mytable ...&lt;/code&gt;) then the table is created in the specified schema. Otherwise it is created in the current schema. The name of the foreign table must be distinct from the name of any other foreign table, table, sequence, index, view, or materialized view in the same schema.</source>
          <target state="translated">如果指定了架构名称（例如 &lt;code&gt;CREATE FOREIGN TABLE myschema.mytable ...&lt;/code&gt; ），则会在指定的架构中创建表。否则，它将在当前架构中创建。外部表的名称必须与同一架构中任何其他外部表，表，序列，索引，视图或实例化视图的名称不同。</target>
        </trans-unit>
        <trans-unit id="0017dfefecb7c7d878ccd99cec2c2243eb08f548" translate="yes" xml:space="preserve">
          <source>If a schema name is given (for example, &lt;code&gt;CREATE STATISTICS myschema.mystat ...&lt;/code&gt;) then the statistics object is created in the specified schema. Otherwise it is created in the current schema. The name of the statistics object must be distinct from the name of any other statistics object in the same schema.</source>
          <target state="translated">如果指定了架构名称（例如 &lt;code&gt;CREATE STATISTICS myschema.mystat ...&lt;/code&gt; ），则将在指定的架构中创建统计信息对象。否则，它将在当前架构中创建。统计信息对象的名称必须与同一架构中的任何其他统计信息对象的名称不同。</target>
        </trans-unit>
        <trans-unit id="d358a0109b0b0aa95ca587460e4392925dac3d64" translate="yes" xml:space="preserve">
          <source>If a schema name is given (for example, &lt;code&gt;CREATE TABLE myschema.mytable ...&lt;/code&gt;) then the table is created in the specified schema. Otherwise it is created in the current schema. Temporary tables exist in a special schema, so a schema name cannot be given when creating a temporary table. The name of the table must be distinct from the name of any other table, sequence, index, view, or foreign table in the same schema.</source>
          <target state="translated">如果指定了架构名称（例如 &lt;code&gt;CREATE TABLE myschema.mytable ...&lt;/code&gt; ），那么将在指定的架构中创建表。否则，它将在当前架构中创建。临时表存在于特殊的架构中，因此在创建临时表时无法给出架构名称。该表的名称必须与同一架构中任何其他表，序列，索引，视图或外部表的名称不同。</target>
        </trans-unit>
        <trans-unit id="93459b6de8914138c246c45451309801fa4eb75b" translate="yes" xml:space="preserve">
          <source>If a schema name is given (for example, &lt;code&gt;CREATE VIEW myschema.myview ...&lt;/code&gt;) then the view is created in the specified schema. Otherwise it is created in the current schema. Temporary views exist in a special schema, so a schema name cannot be given when creating a temporary view. The name of the view must be distinct from the name of any other view, table, sequence, index or foreign table in the same schema.</source>
          <target state="translated">如果指定了架构名称（例如 &lt;code&gt;CREATE VIEW myschema.myview ...&lt;/code&gt; ），则将在指定的架构中创建视图。否则，它将在当前架构中创建。临时视图存在于特殊的架构中，因此在创建临时视图时无法给出架构名称。视图的名称必须与同一架构中的任何其他视图，表，序列，索引或外部表的名称不同。</target>
        </trans-unit>
        <trans-unit id="f45727194d879f2673b515b0704bca00c0cdc2be" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the operator class is created in the specified schema. Otherwise it is created in the current schema. Two operator classes in the same schema can have the same name only if they are for different index methods.</source>
          <target state="translated">如果给定了模式名称,那么操作者类将在指定的模式中创建,否则将在当前模式中创建。否则会在当前模式中创建。同一模式中的两个操作符类只有在它们用于不同的索引方法时才可以有相同的名称。</target>
        </trans-unit>
        <trans-unit id="924ee280ad5b0efe3a03d3f74bd950473afe0d2b" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the operator family is created in the specified schema. Otherwise it is created in the current schema. Two operator families in the same schema can have the same name only if they are for different index methods.</source>
          <target state="translated">如果给定了模式名,则在指定的模式中创建运算符族,否则在当前模式中创建。否则会在当前模式中创建。同一模式中的两个操作族只有在不同索引方法的情况下才能拥有相同的名称。</target>
        </trans-unit>
        <trans-unit id="d43b98c46599ec5632b8b68a4c4aec5bc7c49e45" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the sequence is created in the specified schema. Otherwise it is created in the current schema. Temporary sequences exist in a special schema, so a schema name cannot be given when creating a temporary sequence. The sequence name must be distinct from the name of any other sequence, table, index, view, or foreign table in the same schema.</source>
          <target state="translated">如果给定了模式名称,那么序列将在指定的模式中创建。否则将在当前模式中创建。临时序列存在于一个特殊的模式中,所以在创建临时序列时不能给出模式名。序列名称必须与同一模式中的其他序列、表、索引、视图或外表的名称不同。</target>
        </trans-unit>
        <trans-unit id="d3a817f61150e098cf1b32f5797358f478896c39" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the text search configuration is created in the specified schema. Otherwise it is created in the current schema.</source>
          <target state="translated">如果给定了模式名称,那么文本搜索配置将在指定的模式中创建。否则将在当前模式中创建。</target>
        </trans-unit>
        <trans-unit id="6aa5bd7767ed3e5d5d615c990a382ab4eccb349b" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the text search dictionary is created in the specified schema. Otherwise it is created in the current schema.</source>
          <target state="translated">如果给定了一个模式名称,那么文本搜索字典将在指定的模式中创建。否则将在当前模式中创建。</target>
        </trans-unit>
        <trans-unit id="3f275ed3d77d7d07fbadd2aeff95331926c88b60" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the text search parser is created in the specified schema. Otherwise it is created in the current schema.</source>
          <target state="translated">如果给定了模式名称,那么文本搜索分析器将在指定的模式中创建,否则将在当前模式中创建。否则将在当前的模式中创建。</target>
        </trans-unit>
        <trans-unit id="c90f2803121a2139271a7f1f2ab6d88702071162" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the text search template is created in the specified schema. Otherwise it is created in the current schema.</source>
          <target state="translated">如果给定了模式名称,那么文本搜索模板将在指定的模式中创建,否则将在当前模式中创建。否则将在当前模式中创建。</target>
        </trans-unit>
        <trans-unit id="3f1b270e2011c6de6a6609606ad6c64491399611" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the type is created in the specified schema. Otherwise it is created in the current schema. The type name must be distinct from the name of any existing type or domain in the same schema. (Because tables have associated data types, the type name must also be distinct from the name of any existing table in the same schema.)</source>
          <target state="translated">如果给定了一个模式名称,那么该类型将在指定的模式中创建,否则将在当前模式中创建。否则将在当前模式中创建。类型名称必须与同一模式中的任何现有类型或域的名称不同(因为表有关联的数据类型,所以类型名称也必须与任何现有表的名称不同。因为表有关联的数据类型,所以类型名也必须与同一模式中的任何现有表的名称不同)。</target>
        </trans-unit>
        <trans-unit id="3270e8102f1d16bb2969879cc26ff629f7438593" translate="yes" xml:space="preserve">
          <source>If a schema name is included, then the function is created in the specified schema. Otherwise it is created in the current schema. The name of the new function must not match any existing function or procedure with the same input argument types in the same schema. However, functions and procedures of different argument types can share a name (this is called &lt;em&gt;overloading&lt;/em&gt;).</source>
          <target state="translated">如果包含模式名称，则会在指定的模式中创建函数。否则，它将在当前架构中创建。新函数的名称不得与相同架构中具有相同输入参数类型的任何现有函数或过程匹配。但是，不同参数类型的函数和过程可以共享一个名称（这称为&lt;em&gt;重载&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="fa9f9c34f552135ee16bf0e254ac4f8936e929d0" translate="yes" xml:space="preserve">
          <source>If a schema name is included, then the procedure is created in the specified schema. Otherwise it is created in the current schema. The name of the new procedure must not match any existing procedure or function with the same input argument types in the same schema. However, procedures and functions of different argument types can share a name (this is called &lt;em&gt;overloading&lt;/em&gt;).</source>
          <target state="translated">如果包含模式名称，那么将在指定的模式中创建过程。否则，它将在当前架构中创建。新过程的名称不得与相同架构中具有相同输入参数类型的任何现有过程或函数匹配。但是，不同参数类型的过程和函数可以共享一个名称（这称为&lt;em&gt;重载&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="dacc047d6b80f30af4e1b3c075ae268658bf910d" translate="yes" xml:space="preserve">
          <source>If a separate session key is requested, a new random key will be generated. Otherwise the S2K key will be used directly as the session key.</source>
          <target state="translated">如果要求使用单独的会话密钥,则会生成一个新的随机密钥,否则将直接使用S2K密钥作为会话密钥。否则将直接使用S2K密钥作为会话密钥。</target>
        </trans-unit>
        <trans-unit id="5829673b8ac4bdf9ef5ccbb615c82963b07e7a46" translate="yes" xml:space="preserve">
          <source>If a sequence object has been created with default parameters, successive &lt;code&gt;nextval&lt;/code&gt; calls will return successive values beginning with 1. Other behaviors can be obtained by using special parameters in the &lt;a href=&quot;sql-createsequence&quot;&gt;CREATE SEQUENCE&lt;/a&gt; command; see its command reference page for more information.</source>
          <target state="translated">如果一个序列对象是带着缺省参数创建的，连续的 &lt;code&gt;nextval&lt;/code&gt; 的调用将返回1，其他行为入手连续值可以通过使用特殊参数获取&lt;a href=&quot;sql-createsequence&quot;&gt;CREATE SEQUENCE&lt;/a&gt;命令; 有关更多信息，请参见其命令参考页面。</target>
        </trans-unit>
        <trans-unit id="f45a6ad1ab211a977ca7a8e8006108f711740038" translate="yes" xml:space="preserve">
          <source>If a subscription is associated with a replication slot, then &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; cannot be executed inside a transaction block.</source>
          <target state="translated">如果预订与复制槽关联，则不能在事务块内部执行 &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4fefee0e29f8ef757e65c2ca97914e54656fff0f" translate="yes" xml:space="preserve">
          <source>If a superuser chooses to issue a &lt;code&gt;GRANT&lt;/code&gt; or &lt;code&gt;REVOKE&lt;/code&gt; command, the command is performed as though it were issued by the owner of the affected object. In particular, privileges granted via such a command will appear to have been granted by the object owner. (For role membership, the membership appears to have been granted by the containing role itself.)</source>
          <target state="translated">如果超级用户选择发出 &lt;code&gt;GRANT&lt;/code&gt; 或 &lt;code&gt;REVOKE&lt;/code&gt; 命令，则该命令的执行就像由受影响对象的所有者发出一样。特别是，通过此类命令授予的特权似乎已由对象所有者授予。（对于角色成员资格，成员资格似乎已由包含角色本身授予。）</target>
        </trans-unit>
        <trans-unit id="bdba0ac2d184c2c84f2cf4f8d54b0cd35c6bae22" translate="yes" xml:space="preserve">
          <source>If a superuser chooses to issue a &lt;code&gt;GRANT&lt;/code&gt; or &lt;code&gt;REVOKE&lt;/code&gt; command, the command is performed as though it were issued by the owner of the affected object. Since all privileges ultimately come from the object owner (possibly indirectly via chains of grant options), it is possible for a superuser to revoke all privileges, but this might require use of &lt;code&gt;CASCADE&lt;/code&gt; as stated above.</source>
          <target state="translated">如果超级用户选择发出 &lt;code&gt;GRANT&lt;/code&gt; 或 &lt;code&gt;REVOKE&lt;/code&gt; 命令，则该命令的执行就像由受影响对象的所有者发出一样。由于所有特权最终都来自对象所有者（可能间接地通过授予选项链），因此超级用户可以撤消所有特权，但是如上所述，这可能需要使用 &lt;code&gt;CASCADE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3105c963db998b17d895e80efc90a4f3ec29f6b5" translate="yes" xml:space="preserve">
          <source>If a table constraint (including foreign keys, but not constraint triggers), list of the constrained columns</source>
          <target state="translated">如果一个表有约束(包括外键,但不包括约束触发),约束列列表</target>
        </trans-unit>
        <trans-unit id="d9d8db43e6826c95f740877ac4ab55e53bc6727a" translate="yes" xml:space="preserve">
          <source>If a table has any descendant tables, it is not permitted to add, rename, or change the type of a column in the parent table without doing the same to the descendants. This ensures that the descendants always have columns matching the parent. Similarly, a &lt;code&gt;CHECK&lt;/code&gt; constraint cannot be renamed in the parent without also renaming it in all descendants, so that &lt;code&gt;CHECK&lt;/code&gt; constraints also match between the parent and its descendants. (That restriction does not apply to index-based constraints, however.) Also, because selecting from the parent also selects from its descendants, a constraint on the parent cannot be marked valid unless it is also marked valid for those descendants. In all of these cases, &lt;code&gt;ALTER TABLE ONLY&lt;/code&gt; will be rejected.</source>
          <target state="translated">如果表有任何后代表，则不允许在父表中添加，重命名或更改列的类型，而不必对后代表进行相同的操作。这样可以确保后代始终具有与父代匹配的列。同样，不能在所有后代中重命名 &lt;code&gt;CHECK&lt;/code&gt; 约束，也不能在所有后代中重命名它，以便 &lt;code&gt;CHECK&lt;/code&gt; 约束在父代及其后代之间也匹配。 （但是，该限制不适用于基于索引的约束。）而且，由于从父级中进行选择还从其后代中进行选择，因此除非将父级约束也标记为对这些后代有效，否则不能将其标记为有效。在所有这些情况下， &lt;code&gt;ALTER TABLE ONLY&lt;/code&gt; 将被拒绝。</target>
        </trans-unit>
        <trans-unit id="f72f4b4a7dd1cbe9511c2732830698755442a3ed" translate="yes" xml:space="preserve">
          <source>If a table has been grouped using &lt;code&gt;GROUP BY&lt;/code&gt;, but only certain groups are of interest, the &lt;code&gt;HAVING&lt;/code&gt; clause can be used, much like a &lt;code&gt;WHERE&lt;/code&gt; clause, to eliminate groups from the result. The syntax is:</source>
          <target state="translated">如果已使用 &lt;code&gt;GROUP BY&lt;/code&gt; 对表进行了分组，但是仅关注某些组，则可以使用 &lt;code&gt;HAVING&lt;/code&gt; 子句（与 &lt;code&gt;WHERE&lt;/code&gt; 子句非常相似）从结果中消除组。语法为：</target>
        </trans-unit>
        <trans-unit id="fd8b65709a6edce92f223fae042df5baecd19362" translate="yes" xml:space="preserve">
          <source>If a tablespace is relocated in this way, the symbolic links inside the main data directory are updated to point to the new location. So the new data directory is ready to be used for a new server instance with all tablespaces in the updated locations.</source>
          <target state="translated">如果以这种方式重新定位一个表空间,主数据目录内的符号链接就会更新为指向新的位置。所以新的数据目录就可以用于新的服务器实例,所有表空间都在更新后的位置上。</target>
        </trans-unit>
        <trans-unit id="58895429ed60b7ffce3462e3dfc985d5ce11688f" translate="yes" xml:space="preserve">
          <source>If a transaction of this sort is going to change the data in the table, then it should use &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; lock mode instead of &lt;code&gt;SHARE&lt;/code&gt; mode. This ensures that only one transaction of this type runs at a time. Without this, a deadlock is possible: two transactions might both acquire &lt;code&gt;SHARE&lt;/code&gt; mode, and then be unable to also acquire &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; mode to actually perform their updates. (Note that a transaction's own locks never conflict, so a transaction can acquire &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; mode when it holds &lt;code&gt;SHARE&lt;/code&gt; mode &amp;mdash; but not if anyone else holds &lt;code&gt;SHARE&lt;/code&gt; mode.) To avoid deadlocks, make sure all transactions acquire locks on the same objects in the same order, and if multiple lock modes are involved for a single object, then transactions should always acquire the most restrictive mode first.</source>
          <target state="translated">如果此类事务要更改表中的数据，则应使用 &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; 锁定模式而不是 &lt;code&gt;SHARE&lt;/code&gt; 模式。这样可以确保一次仅运行一次这种类型的事务。否则，可能会导致死锁：两个事务可能都同时获取 &lt;code&gt;SHARE&lt;/code&gt; 模式，然后又无法获取 &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; 模式来实际执行其更新。 （请注意，事务本身的锁永远不会发生冲突，因此，当事务拥有 &lt;code&gt;SHARE&lt;/code&gt; 模式时，它可以获取 &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; 模式-但如果其他人拥有 &lt;code&gt;SHARE&lt;/code&gt; ,则不会为了避免死锁，请确保所有事务以相同的顺序获取相同对象上的锁，并且如果单个对象涉及多个锁模式，则事务应始终首先获取限制性最强的模式。</target>
        </trans-unit>
        <trans-unit id="2d7eb85ea844d2ba5b981dae6af94a75b4526c2e" translate="yes" xml:space="preserve">
          <source>If a user does not have the required privilege on the table or columns, then in many cases the query will ultimately receive a permission-denied error, in which case this mechanism is invisible in practice. But if the user is reading from a security-barrier view, then the planner might wish to check the statistics of an underlying table that is otherwise inaccessible to the user. In that case, the operator should be leak-proof or the statistics will not be used. There is no direct feedback about that, except that the plan might be suboptimal. If one suspects that this is the case, one could try running the query as a more privileged user, to see if a different plan results.</source>
          <target state="translated">如果用户在表或列上没有所需的权限,那么在很多情况下,查询最终会收到一个权限拒绝的错误,在这种情况下,这个机制在实践中是看不到的。但是,如果用户是从安全屏障视图中读取,那么计划员可能希望检查底层表的统计数据,否则用户无法访问。在这种情况下,操作者应该是防泄密的,否则统计数据将不会被使用。对此没有直接的反馈,只是计划可能是次优的。如果怀疑是这种情况,可以尝试以更有权限的用户身份运行查询,看看是否有不同的计划结果。</target>
        </trans-unit>
        <trans-unit id="6dba31a67ed7f0ca43338760f7f94d591211dfb7" translate="yes" xml:space="preserve">
          <source>If a user holds a privilege with grant option and has granted it to other users then the privileges held by those other users are called dependent privileges. If the privilege or the grant option held by the first user is being revoked and dependent privileges exist, those dependent privileges are also revoked if &lt;code&gt;CASCADE&lt;/code&gt; is specified; if it is not, the revoke action will fail. This recursive revocation only affects privileges that were granted through a chain of users that is traceable to the user that is the subject of this &lt;code&gt;REVOKE&lt;/code&gt; command. Thus, the affected users might effectively keep the privilege if it was also granted through other users.</source>
          <target state="translated">如果一个用户拥有带有授予选项的特权并将其授予其他用户，则这些其他用户所拥有的特权称为从属特权。如果第一个用户拥有的特权或授予选项被吊销并且存在从属特权，则如果指定了 &lt;code&gt;CASCADE&lt;/code&gt; ，则这些从属特权也将被吊销；如果不是，则撤销操作将失败。此递归吊销仅影响通过用户链授予的特权，这些特权可追溯到此 &lt;code&gt;REVOKE&lt;/code&gt; 命令主题的用户。因此，如果还通过其他用户授予了特权，则受影响的用户可能会有效保留该特权。</target>
        </trans-unit>
        <trans-unit id="bd5f3c1cab021783ead43914fa444508c73ceec6" translate="yes" xml:space="preserve">
          <source>If a zero byte (&lt;code&gt;''&lt;/code&gt;), then not a generated column. Otherwise, &lt;code&gt;s&lt;/code&gt; = stored. (Other values might be added in the future.)</source>
          <target state="translated">如果为零字节（ &lt;code&gt;''&lt;/code&gt; ），则不是生成的列。否则， &lt;code&gt;s&lt;/code&gt; =已存储。（将来可能会添加其他值。）</target>
        </trans-unit>
        <trans-unit id="a7c2f91a2488ff29789b7c51189ebdab420b3b17" translate="yes" xml:space="preserve">
          <source>If a zero byte (&lt;code&gt;''&lt;/code&gt;), then not an identity column. Otherwise, &lt;code&gt;a&lt;/code&gt; = generated always, &lt;code&gt;d&lt;/code&gt; = generated by default.</source>
          <target state="translated">如果为零字节（ &lt;code&gt;''&lt;/code&gt; ），则不是标识列。否则， &lt;code&gt;a&lt;/code&gt; =始终生成， &lt;code&gt;d&lt;/code&gt; =默认情况下生成。</target>
        </trans-unit>
        <trans-unit id="ff9b8990736e5c895e3ff32d995dc7be0250f86a" translate="yes" xml:space="preserve">
          <source>If activated, the process writes information about database events into the current &lt;a href=&quot;glossary#GLOSSARY-LOG-FILE&quot;&gt;log file&lt;/a&gt;. When reaching certain time- or volume-dependent criteria, a new log file is created. Also called &lt;em&gt;syslogger&lt;/em&gt;.</source>
          <target state="translated">如果激活，该过程会将有关数据库事件的信息写入当前&lt;a href=&quot;glossary#GLOSSARY-LOG-FILE&quot;&gt;日志文件&lt;/a&gt;。当达到某些依赖于时间或数量的标准时，将创建一个新的日志文件。也称为&lt;em&gt;syslogger&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="5de4b09ad9373970f4d3245c8e5f5878c7360739" translate="yes" xml:space="preserve">
          <source>If all inputs are of the same type, and it is not &lt;code&gt;unknown&lt;/code&gt;, resolve as that type.</source>
          <target state="translated">如果所有输入都属于同一类型，并且不是 &lt;code&gt;unknown&lt;/code&gt; ，请解析为该类型。</target>
        </trans-unit>
        <trans-unit id="2f0d22550a877dd1e7a10ea59bd4e64873db9458" translate="yes" xml:space="preserve">
          <source>If all inputs are of type &lt;code&gt;unknown&lt;/code&gt;, resolve as type &lt;code&gt;text&lt;/code&gt; (the preferred type of the string category). Otherwise, &lt;code&gt;unknown&lt;/code&gt; inputs are ignored for the purposes of the remaining rules.</source>
          <target state="translated">如果所有输入的类型均为 &lt;code&gt;unknown&lt;/code&gt; ，则将其解析为 &lt;code&gt;text&lt;/code&gt; 类型（字符串类别的首选类型）。否则，出于其余规则的目的，将忽略 &lt;code&gt;unknown&lt;/code&gt; 输入。</target>
        </trans-unit>
        <trans-unit id="aa6c40971fdf72080d58a6233c79f7c8dce2a255" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;ORDER BY&lt;/code&gt; expression is a simple name that matches both an output column name and an input column name, &lt;code&gt;ORDER BY&lt;/code&gt; will interpret it as the output column name. This is the opposite of the choice that &lt;code&gt;GROUP BY&lt;/code&gt; will make in the same situation. This inconsistency is made to be compatible with the SQL standard.</source>
          <target state="translated">如果 &lt;code&gt;ORDER BY&lt;/code&gt; 表达式是一个与输出列名和输入列名都匹配的简单名称，则 &lt;code&gt;ORDER BY&lt;/code&gt; 将其解释为输出列名。这与 &lt;code&gt;GROUP BY&lt;/code&gt; 在相同情况下所做的选择相反。使该不一致与SQL标准兼容。</target>
        </trans-unit>
        <trans-unit id="0ad7084c5cdd9f3be36397e8c9220c13ae237d6c" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;existing_window_name&lt;/code&gt; is specified it must refer to an earlier entry in the &lt;code&gt;WINDOW&lt;/code&gt; list; the new window copies its partitioning clause from that entry, as well as its ordering clause if any. In this case the new window cannot specify its own &lt;code&gt;PARTITION BY&lt;/code&gt; clause, and it can specify &lt;code&gt;ORDER BY&lt;/code&gt; only if the copied window does not have one. The new window always uses its own frame clause; the copied window must not specify a frame clause.</source>
          <target state="translated">如果指定了 &lt;code&gt;existing_window_name&lt;/code&gt; ,则它必须引用 &lt;code&gt;WINDOW&lt;/code&gt; 列表中的较早条目；否则，将不再引用。新窗口将复制该条目的分区子句以及其排序子句（如果有）。在这种情况下，新窗口不能指定其自己的 &lt;code&gt;PARTITION BY&lt;/code&gt; 子句，并且仅当复制的窗口没有一个子窗口时，它才能指定 &lt;code&gt;ORDER BY&lt;/code&gt; 。新窗口始终使用其自己的frame子句；复制的窗口不得指定frame子句。</target>
        </trans-unit>
        <trans-unit id="d9f4f0d891ac5ca27debdc2266324be50c274311" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;options&lt;/code&gt; string is specified it must consist of a comma-separated list of one or more &lt;code&gt;option&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;value&lt;/code&gt; pairs. The available options are:</source>
          <target state="translated">如果指定了 &lt;code&gt;options&lt;/code&gt; 字符串，则它必须由一个或多个 &lt;code&gt;option&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; 对的逗号分隔列表组成。可用的选项有：</target>
        </trans-unit>
        <trans-unit id="7cd30de9bbf3f8180a703c4e2d6c583071ea1a34" translate="yes" xml:space="preserve">
          <source>If an OID that does not represent an existing object is passed as argument to one of the above functions, NULL is returned.</source>
          <target state="translated">如果一个不代表现有对象的OID被传递给上述函数的参数,将返回NULL。</target>
        </trans-unit>
        <trans-unit id="ffc31d26a07681f5637a04d968a3f5e70276453d" translate="yes" xml:space="preserve">
          <source>If an aggregate supports moving-aggregate mode, it will improve calculation efficiency when the aggregate is used as a window function for a window with moving frame start (that is, a frame start mode other than &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt;). Conceptually, the forward transition function adds input values to the aggregate's state when they enter the window frame from the bottom, and the inverse transition function removes them again when they leave the frame at the top. So, when values are removed, they are always removed in the same order they were added. Whenever the inverse transition function is invoked, it will thus receive the earliest added but not yet removed argument value(s). The inverse transition function can assume that at least one row will remain in the current state after it removes the oldest row. (When this would not be the case, the window function mechanism simply starts a fresh aggregation, rather than using the inverse transition function.)</source>
          <target state="translated">如果聚合支持移动聚合模式，则当将该聚合用作具有开始帧移动窗口的窗口的窗口函数（即，非 &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt; 以外的帧开始模式）时，它将提高计算效率）。从概念上讲，前向过渡函数在输入值从底部进入窗口框架时将输入值添加到聚合的状态，而逆向过渡函数在它们将帧留在顶部时再次将其删除。因此，当值被删除时，它们总是以添加的顺序被删除。每当调用逆转换函数时，它将因此接收最早添加但尚未删除的参数值。逆转换函数可以假定在删除最旧的行后，至少有一行将保持当前状态。 （如果不是这种情况，则窗口函数机制只是开始新的聚合，而不是使用逆转换函数。）</target>
        </trans-unit>
        <trans-unit id="3eaeb85716c71ac82a1780ada62bc3bcdfffa64e" translate="yes" xml:space="preserve">
          <source>If an arbitrary value expression is used in the select list, it conceptually adds a new virtual column to the returned table. The value expression is evaluated once for each result row, with the row's values substituted for any column references. But the expressions in the select list do not have to reference any columns in the table expression of the &lt;code&gt;FROM&lt;/code&gt; clause; they can be constant arithmetic expressions, for instance.</source>
          <target state="translated">如果在选择列表中使用了任意值表达式，则从概念上讲它将新的虚拟列添加到返回的表中。对于每个结果行，将对值表达式进行一次评估，并用该行的值替换任何列引用。但是选择列表中的表达式不必引用 &lt;code&gt;FROM&lt;/code&gt; 子句的表表达式中的任何列；例如，它们可以是常量算术表达式。</target>
        </trans-unit>
        <trans-unit id="80b1d5b3ba2fcc79e9cc1eabebb22c4a831065de" translate="yes" xml:space="preserve">
          <source>If an automatically updatable view contains a &lt;code&gt;WHERE&lt;/code&gt; condition, the condition restricts which rows of the base relation are available to be modified by &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; statements on the view. However, an &lt;code&gt;UPDATE&lt;/code&gt; is allowed to change a row so that it no longer satisfies the &lt;code&gt;WHERE&lt;/code&gt; condition, and thus is no longer visible through the view. Similarly, an &lt;code&gt;INSERT&lt;/code&gt; command can potentially insert base-relation rows that do not satisfy the &lt;code&gt;WHERE&lt;/code&gt; condition and thus are not visible through the view (&lt;code&gt;ON CONFLICT UPDATE&lt;/code&gt; may similarly affect an existing row not visible through the view). The &lt;code&gt;CHECK OPTION&lt;/code&gt; may be used to prevent &lt;code&gt;INSERT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; commands from creating such rows that are not visible through the view.</source>
          <target state="translated">如果自动可更新视图包含 &lt;code&gt;WHERE&lt;/code&gt; 条件，则该条件将限制可通过视图上的 &lt;code&gt;UPDATE&lt;/code&gt; 和 &lt;code&gt;DELETE&lt;/code&gt; 语句修改基本关系的哪些行。但是，允许 &lt;code&gt;UPDATE&lt;/code&gt; 更改行，使其不再满足 &lt;code&gt;WHERE&lt;/code&gt; 条件，因此不再可通过视图看到。类似地， &lt;code&gt;INSERT&lt;/code&gt; 命令可以潜在地插入不满足 &lt;code&gt;WHERE&lt;/code&gt; 条件的基本关系行，因此在视图中不可见（ &lt;code&gt;ON CONFLICT UPDATE&lt;/code&gt; 可能会影响在视图中不可见的现有行）。的 &lt;code&gt;CHECK OPTION&lt;/code&gt; 可以用来防止 &lt;code&gt;INSERT&lt;/code&gt; 和 &lt;code&gt;UPDATE&lt;/code&gt; 命令创建通过视图不可见的行。</target>
        </trans-unit>
        <trans-unit id="2404db1fa7170a324c806fd815c2c382fbb3ff70" translate="yes" xml:space="preserve">
          <source>If an automatically updatable view is marked with the &lt;code&gt;security_barrier&lt;/code&gt; property then all the view's &lt;code&gt;WHERE&lt;/code&gt; conditions (and any conditions using operators which are marked as &lt;code&gt;LEAKPROOF&lt;/code&gt;) will always be evaluated before any conditions that a user of the view has added. See &lt;a href=&quot;https://www.postgresql.org/docs/12/rules-privileges.html&quot;&gt;Section 40.5&lt;/a&gt; for full details. Note that, due to this, rows which are not ultimately returned (because they do not pass the user's &lt;code&gt;WHERE&lt;/code&gt; conditions) may still end up being locked. &lt;code&gt;EXPLAIN&lt;/code&gt; can be used to see which conditions are applied at the relation level (and therefore do not lock rows) and which are not.</source>
          <target state="translated">如果使用 &lt;code&gt;security_barrier&lt;/code&gt; 属性标记了可自动更新的视图，则将始终在添加视图用户的任何条件之前评估所有视图的 &lt;code&gt;WHERE&lt;/code&gt; 条件（以及使用运算符标记为 &lt;code&gt;LEAKPROOF&lt;/code&gt; 的任何条件）。有关完整详细信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/rules-privileges.html&quot;&gt;第40.5节&lt;/a&gt;。请注意，由于这个原因，最终没有返回的行（因为它们没有通过用户的 &lt;code&gt;WHERE&lt;/code&gt; 条件）可能仍然会被锁定。 &lt;code&gt;EXPLAIN&lt;/code&gt; 可用于查看在关系级别应用了哪些条件（因此不锁定行），哪些没有应用。</target>
        </trans-unit>
        <trans-unit id="079f47cbc1cbed10c9582aabec32812c70758e86" translate="yes" xml:space="preserve">
          <source>If an automatically updatable view is marked with the &lt;code&gt;security_barrier&lt;/code&gt; property then all the view's &lt;code&gt;WHERE&lt;/code&gt; conditions (and any conditions using operators which are marked as &lt;code&gt;LEAKPROOF&lt;/code&gt;) will always be evaluated before any conditions that a user of the view has added. See &lt;a href=&quot;https://www.postgresql.org/docs/13/rules-privileges.html&quot;&gt;Section 40.5&lt;/a&gt; for full details. Note that, due to this, rows which are not ultimately returned (because they do not pass the user's &lt;code&gt;WHERE&lt;/code&gt; conditions) may still end up being locked. &lt;code&gt;EXPLAIN&lt;/code&gt; can be used to see which conditions are applied at the relation level (and therefore do not lock rows) and which are not.</source>
          <target state="translated">如果使用 &lt;code&gt;security_barrier&lt;/code&gt; 属性标记了可自动更新的视图，则将始终在添加视图用户的任何条件之前评估所有视图的 &lt;code&gt;WHERE&lt;/code&gt; 条件（以及使用运算符标记为 &lt;code&gt;LEAKPROOF&lt;/code&gt; 的任何条件）。有关完整详细信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/13/rules-privileges.html&quot;&gt;第40.5节&lt;/a&gt;。请注意，由于这个原因，最终没有返回的行（因为它们没有通过用户的 &lt;code&gt;WHERE&lt;/code&gt; 条件）可能仍然会被锁定。 &lt;code&gt;EXPLAIN&lt;/code&gt; 可用于查看在关系级别应用了哪些条件（因此不锁定行），而哪些没有应用。</target>
        </trans-unit>
        <trans-unit id="5c5594932b933065e06b18f724dcf95bf8608f76" translate="yes" xml:space="preserve">
          <source>If an error in these files is detected at server start, the server will refuse to start. But if an error is detected during a configuration reload, the files are ignored and the old SSL configuration continues to be used. On Windows systems, if an error in these files is detected at backend start, that backend will be unable to establish an SSL connection. In all these cases, the error condition is reported in the server log.</source>
          <target state="translated">如果在服务器启动时检测到这些文件有错误,服务器将拒绝启动。但如果在配置重载时检测到错误,则会忽略这些文件,继续使用旧的SSL配置。在Windows系统上,如果在后端启动时检测到这些文件中的错误,该后端将无法建立SSL连接。在所有这些情况下,错误情况都会在服务器日志中报告。</target>
        </trans-unit>
        <trans-unit id="97b646bc602dad48858332961c1cd79032617933" translate="yes" xml:space="preserve">
          <source>If an error occurs while reading the time zone abbreviation set, no new value is applied and the old set is kept. If the error occurs while starting the database, startup fails.</source>
          <target state="translated">如果在读取时区缩写集时发生错误,则不应用新值,保留旧集。如果在启动数据库时发生错误,则启动失败。</target>
        </trans-unit>
        <trans-unit id="1de87c93627deeafcb3370199aca0fb5ecf8ffbd" translate="yes" xml:space="preserve">
          <source>If an error occurs while restoring the database schema, &lt;code&gt;pg_upgrade&lt;/code&gt; will exit and you will have to revert to the old cluster as outlined in &lt;a href=&quot;pgupgrade#PGUPGRADE-STEP-REVERT&quot;&gt;Step 16&lt;/a&gt; below. To try &lt;code&gt;pg_upgrade&lt;/code&gt; again, you will need to modify the old cluster so the pg_upgrade schema restore succeeds. If the problem is a &lt;code&gt;contrib&lt;/code&gt; module, you might need to uninstall the &lt;code&gt;contrib&lt;/code&gt; module from the old cluster and install it in the new cluster after the upgrade, assuming the module is not being used to store user data.</source>
          <target state="translated">如果在还原数据库模式时发生错误，则 &lt;code&gt;pg_upgrade&lt;/code&gt; 将退出，您将必须还原到旧群集，如下面的&lt;a href=&quot;pgupgrade#PGUPGRADE-STEP-REVERT&quot;&gt;步骤16&lt;/a&gt;所述。要再次尝试 &lt;code&gt;pg_upgrade&lt;/code&gt; ，您将需要修改旧集群，以便pg_upgrade模式还原成功。如果问题是 &lt;code&gt;contrib&lt;/code&gt; 模块，则可能需要从旧群集中卸载 &lt;code&gt;contrib&lt;/code&gt; 模块，并在升级后将其安装在新群集中，前提是该模块未用于存储用户数据。</target>
        </trans-unit>
        <trans-unit id="f87c733146ee0c8066dc39794ef31c58e51824d2" translate="yes" xml:space="preserve">
          <source>If an exclusion constraint, list of the per-column exclusion operators</source>
          <target state="translated">如果是排除约束,则列出每列排除操作符的清单。</target>
        </trans-unit>
        <trans-unit id="5e3f8c180f35468731cc99d8e63857d68ba52649" translate="yes" xml:space="preserve">
          <source>If an expression yields a value of a composite type (row type), then a specific field of the row can be extracted by writing</source>
          <target state="translated">如果一个表达式产生一个复合类型(行类型)的值,那么可以通过编写</target>
        </trans-unit>
        <trans-unit id="4ecdcd8e3d88016c98e66e3a3a5e3c60d566e607" translate="yes" xml:space="preserve">
          <source>If an expression yields a value of an array type, then a specific element of the array value can be extracted by writing</source>
          <target state="translated">如果一个表达式产生了一个数组类型的值,那么可以通过写出</target>
        </trans-unit>
        <trans-unit id="6de9a52dce84b15b69f729bccf651727ae858f41" translate="yes" xml:space="preserve">
          <source>If an index build fails with the &lt;code&gt;CONCURRENTLY&lt;/code&gt; option, this index is left as &amp;ldquo;invalid&amp;rdquo;. Such indexes are useless but it can be convenient to use &lt;code&gt;REINDEX&lt;/code&gt; to rebuild them. Note that only &lt;code&gt;REINDEX INDEX&lt;/code&gt; is able to perform a concurrent build on an invalid index.</source>
          <target state="translated">如果使用 &lt;code&gt;CONCURRENTLY&lt;/code&gt; 选项的索引构建失败，则该索引将保留为&amp;ldquo;无效&amp;rdquo;。这样的索引是没有用的，但是使用 &lt;code&gt;REINDEX&lt;/code&gt; 重建它们会很方便。请注意，只有 &lt;code&gt;REINDEX INDEX&lt;/code&gt; 才能对无效索引执行并发构建。</target>
        </trans-unit>
        <trans-unit id="b3fe0fb957d2052bc5b183b29d4175b03f7dd244" translate="yes" xml:space="preserve">
          <source>If an input file name is just &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;ecpg&lt;/code&gt; reads the program from standard input (and writes to standard output, unless that is overridden with &lt;code&gt;-o&lt;/code&gt;).</source>
          <target state="translated">如果输入文件名就是 &lt;code&gt;-&lt;/code&gt; ， &lt;code&gt;ecpg&lt;/code&gt; 从标准输入读取程序（并写到标准输出，除非是与覆盖 &lt;code&gt;-o&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2ce1cc9d13f2dd4c882f2d9159dd6b972278963b" translate="yes" xml:space="preserve">
          <source>If an option is specified that is valid, but not relevant to the selected operating mode, pg_ctl ignores it.</source>
          <target state="translated">如果指定的选项是有效的,但与所选的工作模式无关,pg_ctl会忽略它。</target>
        </trans-unit>
        <trans-unit id="848fca9ee8526b8eb2fb6fd4b08b921862d216f2" translate="yes" xml:space="preserve">
          <source>If an unquoted colon (&lt;code&gt;:&lt;/code&gt;) followed by a psql variable name appears within an argument, it is replaced by the variable's value, as described in &lt;a href=&quot;app-psql#APP-PSQL-INTERPOLATION&quot;&gt;SQL Interpolation&lt;/a&gt; below. The forms &lt;code&gt;:'variable_name'&lt;/code&gt; and &lt;code&gt;:&quot;variable_name&quot;&lt;/code&gt; described there work as well. The &lt;code&gt;:{?variable_name}&lt;/code&gt; syntax allows testing whether a variable is defined. It is substituted by TRUE or FALSE. Escaping the colon with a backslash protects it from substitution.</source>
          <target state="translated">如果非引用冒号（ &lt;code&gt;:&lt;/code&gt; ），接着是PSQL变量名称出现的参数内，它是由该变量的值取代，如在&lt;a href=&quot;app-psql#APP-PSQL-INTERPOLATION&quot;&gt;SQL插值&lt;/a&gt;下方。此处描述的形式 &lt;code&gt;:'variable_name'&lt;/code&gt; 和 &lt;code&gt;:&quot;variable_name&quot;&lt;/code&gt; 也可以使用。的 &lt;code&gt;:{?variable_name}&lt;/code&gt; 语法允许测试变量是否被定义。用TRUE或FALSE代替。用反斜杠将冒号转义可以保护它免于被替换。</target>
        </trans-unit>
        <trans-unit id="af23873c246a8a5e4a8cad331942f631fec99b40" translate="yes" xml:space="preserve">
          <source>If an unquoted colon (&lt;code&gt;:&lt;/code&gt;) followed by a psql variable name appears within an argument, it is replaced by the variable's value, as described in &lt;a href=&quot;app-psql#APP-PSQL-INTERPOLATION&quot;&gt;SQL Interpolation&lt;/a&gt;. The forms &lt;code&gt;:'variable_name'&lt;/code&gt; and &lt;code&gt;:&quot;variable_name&quot;&lt;/code&gt; described there work as well. The &lt;code&gt;:{?variable_name}&lt;/code&gt; syntax allows testing whether a variable is defined. It is substituted by TRUE or FALSE. Escaping the colon with a backslash protects it from substitution.</source>
          <target state="translated">如果非引用冒号（ &lt;code&gt;:&lt;/code&gt; ），接着是PSQL变量名称出现的参数内，它是由该变量的值取代，如上述&lt;a href=&quot;app-psql#APP-PSQL-INTERPOLATION&quot;&gt;的SQL插值&lt;/a&gt;。其中描述的形式 &lt;code&gt;:'variable_name'&lt;/code&gt; 和 &lt;code&gt;:&quot;variable_name&quot;&lt;/code&gt; 也可以使用。的 &lt;code&gt;:{?variable_name}&lt;/code&gt; 语法允许测试变量是否被定义。用TRUE或FALSE代替。用反斜杠将冒号转义可以保护它免受替换。</target>
        </trans-unit>
        <trans-unit id="e21ea67d0d720310272c7536aaef9fbd409c780b" translate="yes" xml:space="preserve">
          <source>If an upstream standby server is promoted to become new master, downstream servers will continue to stream from the new master if &lt;code&gt;recovery_target_timeline&lt;/code&gt; is set to &lt;code&gt;'latest'&lt;/code&gt; (the default).</source>
          <target state="translated">如果将上游备用服务器提升为新的主服务器，并且将 &lt;code&gt;recovery_target_timeline&lt;/code&gt; 设置为 &lt;code&gt;'latest'&lt;/code&gt; （默认值），则下游服务器将继续从新的主服务器流式传输。</target>
        </trans-unit>
        <trans-unit id="3bd7c108b9d4e211b151f51193b945c5454b1371" translate="yes" xml:space="preserve">
          <source>If any dimension is written as a slice, i.e., contains a colon, then all dimensions are treated as slices. Any dimension that has only a single number (no colon) is treated as being from 1 to the number specified. For example, &lt;code&gt;[2]&lt;/code&gt; is treated as &lt;code&gt;[1:2]&lt;/code&gt;, as in this example:</source>
          <target state="translated">如果将任何维度写为切片，即包含冒号，则所有维度都将视为切片。任何只有一个数字（无冒号）的维将被视为从1到指定的数字。例如，在此示例中，将 &lt;code&gt;[2]&lt;/code&gt; 视为 &lt;code&gt;[1:2]&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="644d831a9e7d5bb7b9cf967c049a8eb98186cce0" translate="yes" xml:space="preserve">
          <source>If any input argument is of a domain type, treat it as being of the domain's base type for all subsequent steps. This ensures that domains act like their base types for purposes of ambiguous-function resolution.</source>
          <target state="translated">如果任何输入参数都是域类型,那么在所有后续步骤中,将其视为域的基本类型。这确保了域的行为与它们的基类型一样,以便于解决模糊函数的问题。</target>
        </trans-unit>
        <trans-unit id="aa9d9b8570b39bd99c0391cf769b6b9a97f8cfdc" translate="yes" xml:space="preserve">
          <source>If any input argument is of a domain type, treat it as being of the domain's base type for all subsequent steps. This ensures that domains act like their base types for purposes of ambiguous-operator resolution.</source>
          <target state="translated">如果任何输入参数是一个域类型,那么在所有后续步骤中,将其视为域的基本类型。这确保了域的行为与它们的基本类型一样,以达到解决模糊操作符的目的。</target>
        </trans-unit>
        <trans-unit id="f08ac7bfcc7896ec3ccba829e9cc32f16385e939" translate="yes" xml:space="preserve">
          <source>If any input arguments are &lt;code&gt;unknown&lt;/code&gt;, check the type categories accepted at those argument positions by the remaining candidates. At each position, select the &lt;code&gt;string&lt;/code&gt; category if any candidate accepts that category. (This bias towards string is appropriate since an unknown-type literal looks like a string.) Otherwise, if all the remaining candidates accept the same type category, select that category; otherwise fail because the correct choice cannot be deduced without more clues. Now discard candidates that do not accept the selected type category. Furthermore, if any candidate accepts a preferred type in that category, discard candidates that accept non-preferred types for that argument. Keep all candidates if none survive these tests. If only one candidate remains, use it; else continue to the next step.</source>
          <target state="translated">如果 &lt;code&gt;unknown&lt;/code&gt; 任何输入参数，请检查其余候选在这些参数位置接受的类型类别。在每个位置选择 &lt;code&gt;string&lt;/code&gt; 类别，如果任何候选人接受该类别。（这种偏向字符串的做法是适当的，因为未知类型的文字看起来像字符串。）否则，如果所有其余候选都接受相同的类型类别，则选择该类别；否则，选择该类别。否则失败，因为没有更多线索就无法推断出正确的选择。现在，丢弃不接受所选类型类别的候选对象。此外，如果任何候选者接受该类别中的首选类型，则丢弃该参数接受非首选类型的候选者。如果没有任何候选人在这些测试中幸存下来，请保留所有候选人。如果只剩下一名候选人，请使用它；否则继续下一步。</target>
        </trans-unit>
        <trans-unit id="88a4eb3b7b2c17b935f14a3d49969dbb3c987944" translate="yes" xml:space="preserve">
          <source>If any input expression has an explicit collation derivation, then all explicitly derived collations among the input expressions must be the same, otherwise an error is raised. If any explicitly derived collation is present, that is the result of the collation combination.</source>
          <target state="translated">如果任何输入表达式有一个显式的整理派生,那么输入表达式中所有显式派生的整理必须是相同的,否则就会出现错误。如果有任何显式派生的整理,那就是整理组合的结果。</target>
        </trans-unit>
        <trans-unit id="848b268c3aef8e0ec228a9fd161ed5d209cdafec" translate="yes" xml:space="preserve">
          <source>If any input is of a domain type, treat it as being of the domain's base type for all subsequent steps. &lt;a href=&quot;#ftn.id-1.5.9.10.9.3.1.1&quot;&gt;&lt;sup id=&quot;id-1.5.9.10.9.3.1.1&quot;&gt;[11]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">如果任何输入属于域类型，则在所有后续步骤中都将其视为域的基本类型。&lt;a href=&quot;#ftn.id-1.5.9.10.9.3.1.1&quot;&gt;&lt;sup id=&quot;id-1.5.9.10.9.3.1.1&quot;&gt;[11]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d5b589b0a29736a2c76abe777e082206c27d9542" translate="yes" xml:space="preserve">
          <source>If any input is of a domain type, treat it as being of the domain's base type for all subsequent steps. &lt;a href=&quot;#ftn.id-1.5.9.10.9.3.1.1&quot;&gt;&lt;sup id=&quot;id-1.5.9.10.9.3.1.1&quot;&gt;[12]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">如果任何输入属于域类型，则在所有后续步骤中都将其视为域的基本类型。&lt;a href=&quot;#ftn.id-1.5.9.10.9.3.1.1&quot;&gt;&lt;sup id=&quot;id-1.5.9.10.9.3.1.1&quot;&gt;[12]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="062ef5413f1971acdecb4ea39fded859da884ac5" translate="yes" xml:space="preserve">
          <source>If any of &lt;code&gt;GROUPING SETS&lt;/code&gt;, &lt;code&gt;ROLLUP&lt;/code&gt; or &lt;code&gt;CUBE&lt;/code&gt; are present as grouping elements, then the &lt;code&gt;GROUP BY&lt;/code&gt; clause as a whole defines some number of independent &lt;code&gt;grouping sets&lt;/code&gt;. The effect of this is equivalent to constructing a &lt;code&gt;UNION ALL&lt;/code&gt; between subqueries with the individual grouping sets as their &lt;code&gt;GROUP BY&lt;/code&gt; clauses. For further details on the handling of grouping sets see &lt;a href=&quot;queries-table-expressions#QUERIES-GROUPING-SETS&quot;&gt;Section 7.2.4&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;GROUPING SETS&lt;/code&gt; ， &lt;code&gt;ROLLUP&lt;/code&gt; 或 &lt;code&gt;CUBE&lt;/code&gt; 中的任何一个作为分组元素存在，则 &lt;code&gt;GROUP BY&lt;/code&gt; 子句总体上将定义一些独立的 &lt;code&gt;grouping sets&lt;/code&gt; 。这样的效果等同于在子查询之间构造 &lt;code&gt;UNION ALL&lt;/code&gt; ，并将各个分组集作为其 &lt;code&gt;GROUP BY&lt;/code&gt; 子句。有关分组集处理的更多详细信息，请参见&lt;a href=&quot;queries-table-expressions#QUERIES-GROUPING-SETS&quot;&gt;第7.2.4节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ee7daf9476f8c0077c19fa91e9fc5b6d1dd5a0b5" translate="yes" xml:space="preserve">
          <source>If any of the child tables are foreign tables whose foreign data wrappers do not support &lt;code&gt;ANALYZE&lt;/code&gt;, those child tables are ignored while gathering inheritance statistics.</source>
          <target state="translated">如果任何子表是其外部数据包装器不支持 &lt;code&gt;ANALYZE&lt;/code&gt; 的外部表，则在收集继承统计信息时将忽略这些子表。</target>
        </trans-unit>
        <trans-unit id="5559a39fd47d326a14a46d78afa053af9afa62f6" translate="yes" xml:space="preserve">
          <source>If any of the columns of a table are TOAST-able, the table will have an associated TOAST table, whose OID is stored in the table's &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;reltoastrelid&lt;/code&gt; entry. On-disk TOASTed values are kept in the TOAST table, as described in more detail below.</source>
          <target state="translated">如果表中的任何列都可以进行TOAST，则该表将具有关联的TOAST表，其OID存储在表的 &lt;code&gt;pg_class&lt;/code&gt; 中。 &lt;code&gt;reltoastrelid&lt;/code&gt; 条目。磁盘上的TOASTed值保存在TOAST表中，如下面更详细的描述。</target>
        </trans-unit>
        <trans-unit id="cf49cd2bc67ee3c3481f1ffe2933861356e2738f" translate="yes" xml:space="preserve">
          <source>If any of the tables referenced by the view are temporary, the view is created as a temporary view (whether &lt;code&gt;TEMPORARY&lt;/code&gt; is specified or not).</source>
          <target state="translated">如果该视图引用的任何表都是临时表，则该视图将创建为临时视图（无论是否指定 &lt;code&gt;TEMPORARY&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e74c2195dcb53833cfc91730aac90c474163ed9c" translate="yes" xml:space="preserve">
          <source>If any post-upgrade processing is required, pg_upgrade will issue warnings as it completes. It will also generate script files that must be run by the administrator. The script files will connect to each database that needs post-upgrade processing. Each script should be run using:</source>
          <target state="translated">如果需要进行任何升级后的处理,pg_upgrade会在完成后发出警告。它还会生成必须由管理员运行的脚本文件,脚本文件会连接到每个需要升级后处理的数据库。脚本文件将连接到每个需要升级后处理的数据库。每个脚本都应该使用以下方法运行。</target>
        </trans-unit>
        <trans-unit id="800a2d135577a55dc7316ea712cf7f6d1165ae24" translate="yes" xml:space="preserve">
          <source>If archive storage size is a concern, you can use gzip to compress the archive files:</source>
          <target state="translated">如果担心存档的存储大小,您可以使用gzip压缩存档文件。</target>
        </trans-unit>
        <trans-unit id="2e48896c1f0ace93b93a8656d8514a4835072596" translate="yes" xml:space="preserve">
          <source>If at all possible, &lt;em&gt;do not&lt;/em&gt; use &lt;code&gt;SIGKILL&lt;/code&gt; to kill the main &lt;code&gt;postgres&lt;/code&gt; server. Doing so will prevent &lt;code&gt;postgres&lt;/code&gt; from freeing the system resources (e.g., shared memory and semaphores) that it holds before terminating. This might cause problems for starting a fresh &lt;code&gt;postgres&lt;/code&gt; run.</source>
          <target state="translated">如果有可能，&lt;em&gt;请不要&lt;/em&gt;使用 &lt;code&gt;SIGKILL&lt;/code&gt; 杀死主 &lt;code&gt;postgres&lt;/code&gt; 服务器。这样做将防止 &lt;code&gt;postgres&lt;/code&gt; 在终止之前释放其持有的系统资源（例如，共享内存和信号灯）。这可能会导致启动新的 &lt;code&gt;postgres&lt;/code&gt; 运行时出现问题。</target>
        </trans-unit>
        <trans-unit id="ed12d9d5c43a1c95cedd4f159ed6ce3a1940c1ed" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;OFFSET&lt;/code&gt; and &lt;code&gt;LIMIT&lt;/code&gt; appear, then &lt;code&gt;OFFSET&lt;/code&gt; rows are skipped before starting to count the &lt;code&gt;LIMIT&lt;/code&gt; rows that are returned.</source>
          <target state="translated">如果同时出现 &lt;code&gt;OFFSET&lt;/code&gt; 和 &lt;code&gt;LIMIT&lt;/code&gt; ，则在开始计算返回的 &lt;code&gt;LIMIT&lt;/code&gt; 行之前，将跳过 &lt;code&gt;OFFSET&lt;/code&gt; 行。</target>
        </trans-unit>
        <trans-unit id="d1beaf85265bd8e8de4c00a803a4295f898d6a9d" translate="yes" xml:space="preserve">
          <source>If both standard input and standard output are a terminal, then psql sets the client encoding to &amp;ldquo;auto&amp;rdquo;, which will detect the appropriate client encoding from the locale settings (&lt;code&gt;LC_CTYPE&lt;/code&gt; environment variable on Unix systems). If this doesn't work out as expected, the client encoding can be overridden using the environment variable &lt;code&gt;PGCLIENTENCODING&lt;/code&gt;.</source>
          <target state="translated">如果标准输入和标准输出均为终端，则psql会将客户端编码设置为&amp;ldquo; auto&amp;rdquo;，这将从区域设置（Unix系统上的 &lt;code&gt;LC_CTYPE&lt;/code&gt; 环境变量）中检测适当的客户端编码。如果无法按预期进行，则可以使用环境变量 &lt;code&gt;PGCLIENTENCODING&lt;/code&gt; 覆盖客户端编码。</target>
        </trans-unit>
        <trans-unit id="124d332dfa6ef76e2334514ac990a431fc574564" translate="yes" xml:space="preserve">
          <source>If cascaded replication is in use the feedback is passed upstream until it eventually reaches the primary. Standbys make no other use of feedback they receive other than to pass upstream.</source>
          <target state="translated">如果使用级联复制,则反馈会在上游传递,直到最终到达主设备。备用机除了向上游传递反馈信息外,不作其他用途。</target>
        </trans-unit>
        <trans-unit id="21ad797b1873a315d3fc0d5c790db4d1476ce970" translate="yes" xml:space="preserve">
          <source>If case-independent matching is specified, the effect is much as if all case distinctions had vanished from the alphabet. When an alphabetic that exists in multiple cases appears as an ordinary character outside a bracket expression, it is effectively transformed into a bracket expression containing both cases, e.g., &lt;code&gt;x&lt;/code&gt; becomes &lt;code&gt;[xX]&lt;/code&gt;. When it appears inside a bracket expression, all case counterparts of it are added to the bracket expression, e.g., &lt;code&gt;[x]&lt;/code&gt; becomes &lt;code&gt;[xX]&lt;/code&gt; and &lt;code&gt;[^x]&lt;/code&gt; becomes &lt;code&gt;[^xX]&lt;/code&gt;.</source>
          <target state="translated">如果指定了不区分大小写的匹配，则效果就好像所有区分大小写都从字母表中消失了一样。当在多种情况下存在的字母显示为括号表达式之外的普通字符时，它会有效地转换为包含两种情况的括号表达式，例如 &lt;code&gt;x&lt;/code&gt; 变为 &lt;code&gt;[xX]&lt;/code&gt; 。当它出现在方括号表达式中时，所有与之对应的大小写都添加到方括号表达式中，例如 &lt;code&gt;[x]&lt;/code&gt; 变为 &lt;code&gt;[xX]&lt;/code&gt; ， &lt;code&gt;[^x]&lt;/code&gt; 成为 &lt;code&gt;[^xX]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cf258208ab5152d2c12b1e28ed793831fd7c461c" translate="yes" xml:space="preserve">
          <source>If column aliases are not supplied, then for a function returning a base data type, the column name is also the same as the function name. For a function returning a composite type, the result columns get the names of the individual attributes of the type.</source>
          <target state="translated">如果没有提供列别名,那么对于返回基础数据类型的函数,列名也与函数名相同。对于返回复合类型的函数,结果列得到该类型的各个属性的名称。</target>
        </trans-unit>
        <trans-unit id="6deaaf1ae6fdc8847b55dec525d8c4461d71750b" translate="yes" xml:space="preserve">
          <source>If consistent response time is more important than update speed, use of pending entries can be disabled by turning off the &lt;code&gt;fastupdate&lt;/code&gt; storage parameter for a GIN index. See &lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt; for details.</source>
          <target state="translated">如果一致的响应时间比更新速度更重要，则可以通过关闭GIN索引的 &lt;code&gt;fastupdate&lt;/code&gt; 存储参数来禁用未决条目的使用。有关详细信息，请参见&lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="41ef4d0c1740eb702f05dcbd27c8d877f11fcd3a" translate="yes" xml:space="preserve">
          <source>If csvlog is included in &lt;code&gt;log_destination&lt;/code&gt;, log entries are output in &amp;ldquo;comma separated value&amp;rdquo; (CSV) format, which is convenient for loading logs into programs. See &lt;a href=&quot;runtime-config-logging#RUNTIME-CONFIG-LOGGING-CSVLOG&quot;&gt;Section 19.8.4&lt;/a&gt; for details. &lt;a href=&quot;runtime-config-logging#GUC-LOGGING-COLLECTOR&quot;&gt;logging_collector&lt;/a&gt; must be enabled to generate CSV-format log output.</source>
          <target state="translated">如果log_destination中包含 &lt;code&gt;log_destination&lt;/code&gt; ，则日志条目以&amp;ldquo;逗号分隔值&amp;rdquo;（CSV）格式输出，这便于将日志加载到程序中。有关详细信息，请参见&lt;a href=&quot;runtime-config-logging#RUNTIME-CONFIG-LOGGING-CSVLOG&quot;&gt;第19.8.4节&lt;/a&gt;。必须启用&lt;a href=&quot;runtime-config-logging#GUC-LOGGING-COLLECTOR&quot;&gt;logging_collector&lt;/a&gt;才能生成CSV格式的日志输出。</target>
        </trans-unit>
        <trans-unit id="ed1042acfa5d378be31e2b80e8d7ffc7bef64f8e" translate="yes" xml:space="preserve">
          <source>If data checksums are enabled, hint bit updates are always WAL-logged and this setting is ignored. You can use this setting to test how much extra WAL-logging would occur if your database had data checksums enabled.</source>
          <target state="translated">如果启用了数据校验和,提示位更新总是被WAL记录,而这个设置被忽略。你可以使用这个设置来测试如果你的数据库启用了数据校验和,会发生多少额外的WAL-logging。</target>
        </trans-unit>
        <trans-unit id="9574b9b4b7b428cee25c96a3966fa8df72a24cd9" translate="yes" xml:space="preserve">
          <source>If different date/time types need to be compared, an implicit cast is applied. A &lt;code&gt;date&lt;/code&gt; value can be cast to &lt;code&gt;timestamp&lt;/code&gt; or &lt;code&gt;timestamptz&lt;/code&gt;, &lt;code&gt;timestamp&lt;/code&gt; can be cast to &lt;code&gt;timestamptz&lt;/code&gt;, and &lt;code&gt;time&lt;/code&gt; to &lt;code&gt;timetz&lt;/code&gt;. However, all but the first of these conversions depend on the current &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; setting, and thus can only be performed within timezone-aware &lt;code&gt;jsonpath&lt;/code&gt; functions.</source>
          <target state="translated">如果需要比较不同的日期/时间类型，则应用隐式强制转换。甲 &lt;code&gt;date&lt;/code&gt; 值可以转换为 &lt;code&gt;timestamp&lt;/code&gt; 或 &lt;code&gt;timestamptz&lt;/code&gt; ， &lt;code&gt;timestamp&lt;/code&gt; 可以转换为 &lt;code&gt;timestamptz&lt;/code&gt; ，和 &lt;code&gt;time&lt;/code&gt; 到 &lt;code&gt;timetz&lt;/code&gt; 。但是，除了第一个以外的所有转换都取决于当前的&lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt;设置，因此只能在时区感知的 &lt;code&gt;jsonpath&lt;/code&gt; 函数中执行。</target>
        </trans-unit>
        <trans-unit id="cf0a4beca9338b9c149bc626eda6f48fc9e5c025" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;toptag&lt;/code&gt; or &lt;code&gt;itemtag&lt;/code&gt; is an empty string, the relevant tag is omitted.</source>
          <target state="translated">如果 &lt;code&gt;toptag&lt;/code&gt; 或 &lt;code&gt;itemtag&lt;/code&gt; 是空字符串，则省略相关标签。</target>
        </trans-unit>
        <trans-unit id="03df124a73c895463360e1ed34f1a74da7815fc6" translate="yes" xml:space="preserve">
          <source>If either &lt;em&gt;&lt;code&gt;toptag&lt;/code&gt;&lt;/em&gt; or &lt;em&gt;&lt;code&gt;itemtag&lt;/code&gt;&lt;/em&gt; is an empty string, the relevant tag is omitted.</source>
          <target state="translated">如果&lt;em&gt; &lt;code&gt;toptag&lt;/code&gt; &lt;/em&gt;或&lt;em&gt; &lt;code&gt;itemtag&lt;/code&gt; &lt;/em&gt;是空字符串，则将省略相关标签。</target>
        </trans-unit>
        <trans-unit id="b92d15119505820507c6255b9360f73a82ee471e" translate="yes" xml:space="preserve">
          <source>If executed during recovery, the &lt;code&gt;CHECKPOINT&lt;/code&gt; command will force a restartpoint (see &lt;a href=&quot;wal-configuration&quot;&gt;Section 29.4&lt;/a&gt;) rather than writing a new checkpoint.</source>
          <target state="translated">如果在恢复期间执行，则 &lt;code&gt;CHECKPOINT&lt;/code&gt; 命令将强制重新启动点（请参见&lt;a href=&quot;wal-configuration&quot;&gt;29.4节&lt;/a&gt;），而不是写入新的检查点。</target>
        </trans-unit>
        <trans-unit id="61ea49c86b3b55d886450b38a9cc42e4e9c69fce" translate="yes" xml:space="preserve">
          <source>If false then no one can connect to this database.</source>
          <target state="translated">如果为false,那么没有人可以连接到这个数据库。</target>
        </trans-unit>
        <trans-unit id="67f61dc72a1244f231103433b1246606e94298b4" translate="yes" xml:space="preserve">
          <source>If false then no one can connect to this database. The default is true, allowing connections (except as restricted by other mechanisms, such as &lt;code&gt;GRANT&lt;/code&gt;/&lt;code&gt;REVOKE CONNECT&lt;/code&gt;).</source>
          <target state="translated">如果为false，则没有人可以连接到该数据库。默认值为true，允许连接（除非受其他机制限制，例如 &lt;code&gt;GRANT&lt;/code&gt; / &lt;code&gt;REVOKE CONNECT&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="068609549b5f3904794ff7927c8befaac0ac4357" translate="yes" xml:space="preserve">
          <source>If false then no one can connect to this database. This is used to protect the &lt;code&gt;template0&lt;/code&gt; database from being altered.</source>
          <target state="translated">如果为false，则没有人可以连接到该数据库。这用于防止 &lt;code&gt;template0&lt;/code&gt; 数据库被更改。</target>
        </trans-unit>
        <trans-unit id="5279e693a4509d44588c8398060bdbb7e4662f3c" translate="yes" xml:space="preserve">
          <source>If false, the index is in process of being dropped, and should be ignored for all purposes (including HOT-safety decisions)</source>
          <target state="translated">如果为假,则该指数正在被删除,并且在所有情况下都应该被忽略(包括HOT-安全决策)。</target>
        </trans-unit>
        <trans-unit id="024b18cb2d326ba0157f9b09e5a42b7967d00fb4" translate="yes" xml:space="preserve">
          <source>If fewer column aliases are specified than the actual table has columns, the remaining columns are not renamed. This syntax is especially useful for self-joins or subqueries.</source>
          <target state="translated">如果指定的列别名比实际表中的列少,那么剩余的列不会被重命名。这种语法对于自连接或子查询特别有用。</target>
        </trans-unit>
        <trans-unit id="7788a3fcadf6ada52028229d6f513ec9b5a33011" translate="yes" xml:space="preserve">
          <source>If for some reason autovacuum fails to clear old XIDs from a table, the system will begin to emit warning messages like this when the database's oldest XIDs reach eleven million transactions from the wraparound point:</source>
          <target state="translated">如果由于某种原因,autovacuum未能清除表中的旧XID,当数据库中最旧的XID从包围点开始达到1100万个事务时,系统就会开始发出这样的警告信息。</target>
        </trans-unit>
        <trans-unit id="8ab96b15ba19344208a4881ae65df7268a6bcc7d" translate="yes" xml:space="preserve">
          <source>If for some reason autovacuum fails to clear old XIDs from a table, the system will begin to emit warning messages like this when the database's oldest XIDs reach ten million transactions from the wraparound point:</source>
          <target state="translated">如果因为某些原因,autovacuum未能清除表中的旧XID,当数据库中最旧的XID从包围点开始达到1000万个事务时,系统就会开始发出这样的警告信息。</target>
        </trans-unit>
        <trans-unit id="80fa6f646b83284df410a911e1de501df6e5b069" translate="yes" xml:space="preserve">
          <source>If forcing index usage does use the index, then there are two possibilities: Either the system is right and using the index is indeed not appropriate, or the cost estimates of the query plans are not reflecting reality. So you should time your query with and without indexes. The &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; command can be useful here.</source>
          <target state="translated">如果强制使用索引确实使用了索引，则有两种可能性：系统是否正确，使用索引确实不合适，或者查询计划的成本估算未反映现实。因此，您应该对有索引和无索引的查询进行计时。在 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 命令可以在这里很有用。</target>
        </trans-unit>
        <trans-unit id="360561360313d63c949a4bb8b50e6444752b1851" translate="yes" xml:space="preserve">
          <source>If four or six digits and a year has already been read, then interpret as a time (&lt;code&gt;HHMM&lt;/code&gt; or &lt;code&gt;HHMMSS&lt;/code&gt;).</source>
          <target state="translated">如果已经读取了四位或六位数字和一年，则将其解释为时间（ &lt;code&gt;HHMM&lt;/code&gt; 或 &lt;code&gt;HHMMSS&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="42c28f0a9935826074d643ae6e75e6be762517ad" translate="yes" xml:space="preserve">
          <source>If given, createuser will issue a prompt for the password of the new user. This is not necessary if you do not plan on using password authentication.</source>
          <target state="translated">如果给定,createuser 将提示新用户输入密码。如果你不打算使用密码验证,则不需要这样做。</target>
        </trans-unit>
        <trans-unit id="ea4e98adccd9512cd68509c9e2207bdcbb1a1273" translate="yes" xml:space="preserve">
          <source>If greater than zero, each bind parameter value logged with a non-error statement-logging message is trimmed to this many bytes. Zero disables logging of bind parameters for non-error statement logs. &lt;code&gt;-1&lt;/code&gt; (the default) allows bind parameters to be logged in full. If this value is specified without units, it is taken as bytes. Only superusers can change this setting.</source>
          <target state="translated">如果大于零，则将用非错误语句记录消息记录的每个绑定参数值修整到这个字节数。零禁用非错误语句日志的绑定参数记录。 &lt;code&gt;-1&lt;/code&gt; （默认值）允许完整记录绑定参数。如果指定的该值不带单位，则以字节为单位。仅超级用户可以更改此设置。</target>
        </trans-unit>
        <trans-unit id="38b5cd71938c46f540f5b875d785655ef9301be2" translate="yes" xml:space="preserve">
          <source>If greater than zero, each bind parameter value reported in error messages is trimmed to this many bytes. Zero (the default) disables including bind parameters in error messages. &lt;code&gt;-1&lt;/code&gt; allows bind parameters to be printed in full. If this value is specified without units, it is taken as bytes.</source>
          <target state="translated">如果大于零，则错误消息中报告的每个绑定参数值都会被修剪为这个字节数。零（默认）禁用在错误消息中包括绑定参数。 &lt;code&gt;-1&lt;/code&gt; 允许完整打印绑定参数。如果指定的该值不带单位，则以字节为单位。</target>
        </trans-unit>
        <trans-unit id="95adc82bd644fa7ad31393ac2f57ca7d35f902fd" translate="yes" xml:space="preserve">
          <source>If greater than zero, the estimated number of distinct values in the column. If less than zero, the negative of the number of distinct values divided by the number of rows. (The negated form is used when &lt;code&gt;ANALYZE&lt;/code&gt; believes that the number of distinct values is likely to increase as the table grows; the positive form is used when the column seems to have a fixed number of possible values.) For example, -1 indicates a unique column in which the number of distinct values is the same as the number of rows.</source>
          <target state="translated">如果大于零，则为列中不同值的估计数量。如果小于零，则为不同值的数量的负数除以行数。（当 &lt;code&gt;ANALYZE&lt;/code&gt; 认为表的增长可能会增加不同值的数量时，使用否定形式；当该列似乎具有固定数量的可能值时，则使用正形式。）例如，-1表示a唯一列，其中不同值的数量与行数相同。</target>
        </trans-unit>
        <trans-unit id="b21def7d275563964950f72033030facdc8caa8d" translate="yes" xml:space="preserve">
          <source>If indexing numbers, we can remove some fractional digits to reduce the range of possible numbers, so for example &lt;em&gt;3.14&lt;/em&gt;159265359, &lt;em&gt;3.14&lt;/em&gt;15926, &lt;em&gt;3.14&lt;/em&gt; will be the same after normalization if only two digits are kept after the decimal point.</source>
          <target state="translated">如果索引号，我们可以删除一些小数位，以减少可能的数字范围，因此，例如&lt;em&gt;3.14&lt;/em&gt; 159265359，&lt;em&gt;3.14&lt;/em&gt; 15926，&lt;em&gt;3.14&lt;/em&gt;将是归一化后相同的，如果只有两个数字都在小数点后保留。</target>
        </trans-unit>
        <trans-unit id="76133018bd86f9f10167401dc275f9ef001f11b2" translate="yes" xml:space="preserve">
          <source>If inverse partial newline-sensitive matching is specified, this affects &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; as with newline-sensitive matching, but not &lt;code&gt;.&lt;/code&gt; and bracket expressions. This isn't very useful but is provided for symmetry.</source>
          <target state="translated">如果指定了反向部分对换行敏感的匹配，则对 &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;$&lt;/code&gt; 的影响与对换行敏感的匹配相同，但对却没有影响 &lt;code&gt;.&lt;/code&gt; 和方括号表达式。这不是很有用，但是是为了对称而提供的。</target>
        </trans-unit>
        <trans-unit id="dcbd0be8463498dfec58ee2ded857848642b3788" translate="yes" xml:space="preserve">
          <source>If it is necessary to have a comma or whitespace in a RADIUS parameter value, that can be done by putting double quotes around the value, but it is tedious because two layers of double-quoting are now required. An example of putting whitespace into RADIUS secret strings is:</source>
          <target state="translated">如果需要在RADIUS参数值中加入逗号或空格,可以通过在值的周围加上双引号来实现,但这很繁琐,因为现在需要两层双引号。在RADIUS秘密字符串中加whitespace的例子是。</target>
        </trans-unit>
        <trans-unit id="c82c509d031e15398bd7fe00861081d6405c8be4" translate="yes" xml:space="preserve">
          <source>If it turns out that the cost estimates are wrong, there are, again, two possibilities. The total cost is computed from the per-row costs of each plan node times the selectivity estimate of the plan node. The costs estimated for the plan nodes can be adjusted via run-time parameters (described in &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-CONSTANTS&quot;&gt;Section 19.7.2&lt;/a&gt;). An inaccurate selectivity estimate is due to insufficient statistics. It might be possible to improve this by tuning the statistics-gathering parameters (see &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;).</source>
          <target state="translated">如果事实证明成本估算是错误的，则有两种可能性。总成本是根据每个计划节点的每行成本乘以计划节点的选择性估算得出的。可以通过运行时参数（在&lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-CONSTANTS&quot;&gt;19.7.2节中介绍&lt;/a&gt;）来调整为计划节点估计的成本。选择性估计不准确是由于统计数据不足。通过调整统计信息收集参数（请参阅&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;）可以改善这一点。</target>
        </trans-unit>
        <trans-unit id="18729ccb1c4146c8bab4ae3596759dabf5573ab7" translate="yes" xml:space="preserve">
          <source>If locale support doesn't work according to the explanation above, check that the locale support in your operating system is correctly configured. To check what locales are installed on your system, you can use the command &lt;code&gt;locale -a&lt;/code&gt; if your operating system provides it.</source>
          <target state="translated">如果根据上述说明，语言环境支持不起作用，请检查是否正确配置了操作系统中的语言环境支持。要检查系统上安装了哪些语言环境，可以在操作系统提供的情况下使用命令 &lt;code&gt;locale -a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="742c773e01d7235a3ab536311ea18ceb446289e6" translate="yes" xml:space="preserve">
          <source>If making a backup, make sure that your database is not being updated. This does not affect the integrity of the backup, but the changed data would of course not be included. If necessary, edit the permissions in the file &lt;code&gt;/usr/local/pgsql/data/pg_hba.conf&lt;/code&gt; (or equivalent) to disallow access from everyone except you. See &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt; for additional information on access control.</source>
          <target state="translated">如果要进行备份，请确保未更新数据库。这不会影响备份的完整性，但是更改后的数据当然不会包括在内。如有必要，请在文件 &lt;code&gt;/usr/local/pgsql/data/pg_hba.conf&lt;/code&gt; （或等效文件）中编辑权限，以禁止除您之外的任何人进行访问。有关访问控制的更多信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;第20章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7635b5eb0e6be90090ac67c5260cad61569c3e50" translate="yes" xml:space="preserve">
          <source>If making a backup, make sure that your database is not being updated. This does not affect the integrity of the backup, but the changed data would of course not be included. If necessary, edit the permissions in the file &lt;code&gt;/usr/local/pgsql/data/pg_hba.conf&lt;/code&gt; (or equivalent) to disallow access from everyone except you. See &lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt; for additional information on access control.</source>
          <target state="translated">如果要进行备份，请确保未更新数据库。这不会影响备份的完整性，但是更改后的数据当然不会包括在内。如有必要，请编辑文件 &lt;code&gt;/usr/local/pgsql/data/pg_hba.conf&lt;/code&gt; （或等效文件）中的权限，以禁止除您之外的任何人进行访问。有关访问控制的更多信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;第20章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c0a6e1d7bfcacfaf25b4fbb67794def2eb6d19f0" translate="yes" xml:space="preserve">
          <source>If more flexibility in copying the backup files is needed, a lower level process can be used for standalone hot backups as well. To prepare for low level standalone hot backups, make sure &lt;code&gt;wal_level&lt;/code&gt; is set to &lt;code&gt;replica&lt;/code&gt; or higher, &lt;code&gt;archive_mode&lt;/code&gt; to &lt;code&gt;on&lt;/code&gt;, and set up an &lt;code&gt;archive_command&lt;/code&gt; that performs archiving only when a &lt;em&gt;switch file&lt;/em&gt; exists. For example:</source>
          <target state="translated">如果在复制备份文件时需要更大的灵活性，则也可以将较低级别的过程用于独立的热备份。要准备低级别的独立热备份，请确保将 &lt;code&gt;wal_level&lt;/code&gt; 设置为 &lt;code&gt;replica&lt;/code&gt; 或更高版本，将 &lt;code&gt;archive_mode&lt;/code&gt; 设置为 &lt;code&gt;on&lt;/code&gt; ，并确保只有在存在&lt;em&gt;切换文件&lt;/em&gt;时才执行归档的 &lt;code&gt;archive_command&lt;/code&gt; 。例如：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b849cfa2234fdad4226b42e149aff052e2ec6ceb" translate="yes" xml:space="preserve">
          <source>If more than one flag bit is specified, the transformations are applied in the order listed.</source>
          <target state="translated">如果指定了一个以上的标志位,则按所列顺序进行转换。</target>
        </trans-unit>
        <trans-unit id="b8368877f8014c70dc2f0a265b592212cfc0ddc8" translate="yes" xml:space="preserve">
          <source>If more than one leaf tuple is supplied, it is expected that the &lt;code&gt;picksplit&lt;/code&gt; function will classify them into more than one node; otherwise it is not possible to split the leaf tuples across multiple pages, which is the ultimate purpose of this operation. Therefore, if the &lt;code&gt;picksplit&lt;/code&gt; function ends up placing all the leaf tuples in the same node, the core SP-GiST code will override that decision and generate an inner tuple in which the leaf tuples are assigned at random to several identically-labeled nodes. Such a tuple is marked &lt;code&gt;allTheSame&lt;/code&gt; to signify that this has happened. The &lt;code&gt;choose&lt;/code&gt; and &lt;code&gt;inner_consistent&lt;/code&gt; functions must take suitable care with such inner tuples. See &lt;a href=&quot;spgist-implementation#SPGIST-ALL-THE-SAME&quot;&gt;Section 65.4.3&lt;/a&gt; for more information.</source>
          <target state="translated">如果提供了多个叶元组，则期望 &lt;code&gt;picksplit&lt;/code&gt; 函数会将它们分类为多个节点；否则，不可能将叶元组拆分为多个页面，这是此操作的最终目的。因此，如果 &lt;code&gt;picksplit&lt;/code&gt; 函数最终将所有叶子元组放置在同一节点中，则核心SP-GiST代码将覆盖该决策，并生成一个内部元组，在其中将叶子元组随机分配给几个相同标签的节点。这样的元组被标记为 &lt;code&gt;allTheSame&lt;/code&gt; ，表示已发生这种情况。在 &lt;code&gt;choose&lt;/code&gt; 和 &lt;code&gt;inner_consistent&lt;/code&gt; 功能必须采取适当的照顾等在内的元组。参见&lt;a href=&quot;spgist-implementation#SPGIST-ALL-THE-SAME&quot;&gt;第65.4.3节&lt;/a&gt; 想要查询更多的信息。</target>
        </trans-unit>
        <trans-unit id="e1854b837fa3254f90682ac28255cbd702178269" translate="yes" xml:space="preserve">
          <source>If more than one option is given, the information is printed in that order, one item per line. If no options are given, all available information is printed, with labels.</source>
          <target state="translated">如果给出一个以上的选项,则按顺序打印信息,每行一个项目。如果没有给出选项,则打印所有可用的信息,并附有标签。</target>
        </trans-unit>
        <trans-unit id="f1a02345ba89ad66d10fbdabf34539cb6dd7d98c" translate="yes" xml:space="preserve">
          <source>If more than one table has a column of the same name, the table name must also be given, as in:</source>
          <target state="translated">如果一个以上的表有同名的列,还必须给出表名,如:。</target>
        </trans-unit>
        <trans-unit id="dd5e9dbc9005fdf88d98048279bb5e957015fc29" translate="yes" xml:space="preserve">
          <source>If multiple CPUs are available in the database server, consider using pg_restore's &lt;code&gt;--jobs&lt;/code&gt; option. This allows concurrent data loading and index creation.</source>
          <target state="translated">如果数据库服务器中有多个CPU，请考虑使用pg_restore的 &lt;code&gt;--jobs&lt;/code&gt; 选项。这允许并发数据加载和索引创建。</target>
        </trans-unit>
        <trans-unit id="87fac9519c05562bef87a4e35aa2a859278b1c40" translate="yes" xml:space="preserve">
          <source>If multiple grouping items are specified in a single &lt;code&gt;GROUP BY&lt;/code&gt; clause, then the final list of grouping sets is the cross product of the individual items. For example:</source>
          <target state="translated">如果在单个 &lt;code&gt;GROUP BY&lt;/code&gt; 子句中指定了多个分组项目，则分组集的最终列表是各个项目的叉积。例如：</target>
        </trans-unit>
        <trans-unit id="b80b5e3c45aa43e720ac77a6f9a3ef8d195c588d" translate="yes" xml:space="preserve">
          <source>If multiple savepoints have the same name, only the one that was most recently defined is released.</source>
          <target state="translated">如果多个保存点的名称相同,则只释放最近定义的那个保存点。</target>
        </trans-unit>
        <trans-unit id="9bb7ddb9b949ac875aa47f26b30ade97f88eab22" translate="yes" xml:space="preserve">
          <source>If multiple script files are specified, the averages are reported separately for each script file.</source>
          <target state="translated">如果指定了多个脚本文件,每个脚本文件的平均数都会单独报告。</target>
        </trans-unit>
        <trans-unit id="e33be9af0afb6da142699266371977c598700dcd" translate="yes" xml:space="preserve">
          <source>If multiple triggers of the same kind are defined for the same event, they will be fired in alphabetical order by name.</source>
          <target state="translated">如果为同一事件定义了多个同类型的触发器,它们将按名称的字母顺序被触发。</target>
        </trans-unit>
        <trans-unit id="65a4d92a17b0442c58eb3e977048325cf5830355" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;ALSO&lt;/code&gt; nor &lt;code&gt;INSTEAD&lt;/code&gt; is specified, &lt;code&gt;ALSO&lt;/code&gt; is the default.</source>
          <target state="translated">如果未指定 &lt;code&gt;ALSO&lt;/code&gt; 或 &lt;code&gt;INSTEAD&lt;/code&gt; ，则默认为 &lt;code&gt;ALSO&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e603a3b3a3e88af33582419d67e19ea60ef676f" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;FOR SEARCH&lt;/code&gt; nor &lt;code&gt;FOR ORDER BY&lt;/code&gt; is specified, &lt;code&gt;FOR SEARCH&lt;/code&gt; is the default.</source>
          <target state="translated">如果未指定 &lt;code&gt;FOR SEARCH&lt;/code&gt; 或 &lt;code&gt;FOR ORDER BY&lt;/code&gt; ，则默认为 &lt;code&gt;FOR SEARCH&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5e9aa69e6e2804ffb3ebc122107e995dd5c9a00a" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;FOR TABLE&lt;/code&gt; nor &lt;code&gt;FOR ALL TABLES&lt;/code&gt; is specified, then the publication starts out with an empty set of tables. That is useful if tables are to be added later.</source>
          <target state="translated">如果未指定 &lt;code&gt;FOR TABLE&lt;/code&gt; 或 &lt;code&gt;FOR ALL TABLES&lt;/code&gt; ，则发布以一组空表开始。如果以后要添加表，这将很有用。</target>
        </trans-unit>
        <trans-unit id="89d1b1553626d39b44b8a8db61a149cf8fdc3227" translate="yes" xml:space="preserve">
          <source>If newline-sensitive matching is specified, &lt;code&gt;.&lt;/code&gt; and bracket expressions using &lt;code&gt;^&lt;/code&gt; will never match the newline character (so that matches will never cross newlines unless the RE explicitly arranges it) and &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; will match the empty string after and before a newline respectively, in addition to matching at beginning and end of string respectively. But the ARE escapes &lt;code&gt;\A&lt;/code&gt; and &lt;code&gt;\Z&lt;/code&gt; continue to match beginning or end of string &lt;em&gt;only&lt;/em&gt;.</source>
          <target state="translated">如果指定了换行敏感匹配，则为 &lt;code&gt;.&lt;/code&gt; 和使用 &lt;code&gt;^&lt;/code&gt; 的方括号表达式将永远不会与换行符匹配（因此，除非RE明确将其匹配，否则匹配将永远不会与换行符交叉），并且 &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;$&lt;/code&gt; 将分别匹配换行符之后和之前的空字符串，除了在开头和结尾处进行匹配之外的字符串。但是ARE逃逸 &lt;code&gt;\A&lt;/code&gt; 和 &lt;code&gt;\Z&lt;/code&gt; 继续匹配开始或结束字符串&lt;em&gt;只&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="eec0fa542613e1975aae2a48b92903dde3eacbb8" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;table_alias&lt;/code&gt; is specified, the function name is used as the table name; in the case of a &lt;code&gt;ROWS FROM()&lt;/code&gt; construct, the first function's name is used.</source>
          <target state="translated">如果未指定 &lt;code&gt;table_alias&lt;/code&gt; ，则将函数名用作表名；否则，将函数名用作表名。对于 &lt;code&gt;ROWS FROM()&lt;/code&gt; 构造，将使用第一个函数的名称。</target>
        </trans-unit>
        <trans-unit id="5c82c2225e73852e8c357908e66b1d12e66520ab" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;weights&lt;/code&gt; are provided, then these defaults are used:</source>
          <target state="translated">如果未提供 &lt;code&gt;weights&lt;/code&gt; ，则使用以下默认值：</target>
        </trans-unit>
        <trans-unit id="0368275c8128ea23b2ee02837095ef288617003c" translate="yes" xml:space="preserve">
          <source>If no collation is explicitly specified, the database system either derives a collation from the columns involved in the expression, or it defaults to the default collation of the database if no column is involved in the expression.</source>
          <target state="translated">如果没有显式指定整理,数据库系统要么从表达式中涉及的列导出整理,要么如果表达式中没有涉及列,则默认为数据库的默认整理。</target>
        </trans-unit>
        <trans-unit id="21307971878d081789f53c6ec3a32e0fa2a71500" translate="yes" xml:space="preserve">
          <source>If no default value is declared explicitly, the default value is the null value. This usually makes sense because a null value can be considered to represent unknown data.</source>
          <target state="translated">如果没有明确声明默认值,默认值是空值。这通常是有意义的,因为空值可以被认为是代表未知数据。</target>
        </trans-unit>
        <trans-unit id="e6bbf77c4f367e9f49f3db1ca226b2a952882830" translate="yes" xml:space="preserve">
          <source>If no exact match is found, see if the function call appears to be a special type conversion request. This happens if the function call has just one argument and the function name is the same as the (internal) name of some data type. Furthermore, the function argument must be either an unknown-type literal, or a type that is binary-coercible to the named data type, or a type that could be converted to the named data type by applying that type's I/O functions (that is, the conversion is either to or from one of the standard string types). When these conditions are met, the function call is treated as a form of &lt;code&gt;CAST&lt;/code&gt; specification. &lt;a href=&quot;#ftn.id-1.5.9.8.4.4.1.2&quot;&gt;&lt;sup id=&quot;id-1.5.9.8.4.4.1.2&quot;&gt;[10]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">如果找不到完全匹配的内容，请查看该函数调用是否似乎是特殊的类型转换请求。如果函数调用只有一个参数并且函数名称与某些数据类型的（内部）名称相同，则会发生这种情况。此外，函数参数必须是未知类型的文字，或者是对指定数据类型可以二进制强制转换的类型，或者是可以通过应用该类型的I / O函数转换为命名数据类型的类型（即是，转换是与标准字符串类型之一进行转换或从标准字符串类型之一进行转换。满足这些条件时，函数调用将视为 &lt;code&gt;CAST&lt;/code&gt; 规范的一种形式。&lt;a href=&quot;#ftn.id-1.5.9.8.4.4.1.2&quot;&gt;&lt;sup id=&quot;id-1.5.9.8.4.4.1.2&quot;&gt;[10]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="35149dcf4bfae750a59efc48da69e479e9799355" translate="yes" xml:space="preserve">
          <source>If no exact match is found, see if the function call appears to be a special type conversion request. This happens if the function call has just one argument and the function name is the same as the (internal) name of some data type. Furthermore, the function argument must be either an unknown-type literal, or a type that is binary-coercible to the named data type, or a type that could be converted to the named data type by applying that type's I/O functions (that is, the conversion is either to or from one of the standard string types). When these conditions are met, the function call is treated as a form of &lt;code&gt;CAST&lt;/code&gt; specification. &lt;a href=&quot;#ftn.id-1.5.9.8.4.4.1.2&quot;&gt;&lt;sup id=&quot;id-1.5.9.8.4.4.1.2&quot;&gt;[11]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">如果找不到完全匹配的内容，请查看该函数调用是否似乎是特殊的类型转换请求。如果函数调用只有一个参数并且函数名称与某些数据类型的（内部）名称相同，则会发生这种情况。此外，函数参数必须是未知类型的文字，或者是对指定数据类型可以二进制强制转换的类型，或者可以通过应用该类型的I / O函数转换为命名数据类型的类型（即是，转换是与标准字符串类型之一进行转换或从标准字符串类型之一进行转换。满足这些条件时，函数调用将视为 &lt;code&gt;CAST&lt;/code&gt; 规范的一种形式。&lt;a href=&quot;#ftn.id-1.5.9.8.4.4.1.2&quot;&gt;&lt;sup id=&quot;id-1.5.9.8.4.4.1.2&quot;&gt;[11]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="93b5e5aff6e0171effd161da742f968f9068eee6" translate="yes" xml:space="preserve">
          <source>If no explicit provision is made for a sign in &lt;code&gt;to_char()&lt;/code&gt;'s pattern, one column will be reserved for the sign, and it will be anchored to (appear just left of) the number. If &lt;code&gt;S&lt;/code&gt; appears just left of some &lt;code&gt;9&lt;/code&gt;'s, it will likewise be anchored to the number.</source>
          <target state="translated">如果没有为 &lt;code&gt;to_char()&lt;/code&gt; 的模式中的符号做任何明确规定，则将为该符号保留一列，并将其固定到该数字（显示在数字的左侧）。如果 &lt;code&gt;S&lt;/code&gt; 刚好出现在 &lt;code&gt;9&lt;/code&gt; 的左边，则它将同样锚定到数字上。</target>
        </trans-unit>
        <trans-unit id="6e409b417f72efc6d96ed16a0afc9bdc881a346a" translate="yes" xml:space="preserve">
          <source>If no function is specified, a blank &lt;code&gt;CREATE FUNCTION&lt;/code&gt; template is presented for editing.</source>
          <target state="translated">如果未指定任何功能，则会显示空白的 &lt;code&gt;CREATE FUNCTION&lt;/code&gt; 模板以供编辑。</target>
        </trans-unit>
        <trans-unit id="bfdbba53034a54f85542008e5a3f670d8b001aa1" translate="yes" xml:space="preserve">
          <source>If no lock mode is specified, then &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt;, the most restrictive mode, is used.</source>
          <target state="translated">如果未指定锁定模式，则使用限制最大的 &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; 模式。</target>
        </trans-unit>
        <trans-unit id="e62fb9f6836054022a0013bdbc9afb997f69a82f" translate="yes" xml:space="preserve">
          <source>If no moving-aggregate implementation is supplied, the aggregate can still be used with moving frames, but PostgreSQL will recompute the whole aggregation whenever the start of the frame moves. Note that whether or not the aggregate supports moving-aggregate mode, PostgreSQL can handle a moving frame end without recalculation; this is done by continuing to add new values to the aggregate's state. This is why use of an aggregate as a window function requires that the final function be read-only: it must not damage the aggregate's state value, so that the aggregation can be continued even after an aggregate result value has been obtained for one set of frame boundaries.</source>
          <target state="translated">如果没有提供移动聚合的实现,聚合仍然可以用于移动的帧,但每当帧的开始移动时,PostgreSQL将重新计算整个聚合。需要注意的是,无论聚合是否支持移动-聚合模式,PostgreSQL都可以处理移动的帧结束,而不需要重新计算;这是通过继续向聚合的状态添加新值来实现的。这就是为什么将聚合作为窗口函数使用时,要求最后的函数是只读的:它不能破坏聚合的状态值,这样即使在获得一组帧边界的聚合结果值后,聚合也可以继续进行。</target>
        </trans-unit>
        <trans-unit id="f9d74d492594986bfbf1fc1386e105965c9b3fc3" translate="yes" xml:space="preserve">
          <source>If no output column name is specified using &lt;code&gt;AS&lt;/code&gt;, the system assigns a default column name. For simple column references, this is the name of the referenced column. For function calls, this is the name of the function. For complex expressions, the system will generate a generic name.</source>
          <target state="translated">如果未使用 &lt;code&gt;AS&lt;/code&gt; 指定输出列名称，则系统会分配一个默认列名称。对于简单的列引用，这是被引用列的名称。对于函数调用，这是函数的名称。对于复杂的表达式，系统将生成一个通用名称。</target>
        </trans-unit>
        <trans-unit id="46eb45e8cda4a2fa8f3f15869002e910f361619b" translate="yes" xml:space="preserve">
          <source>If no role is specified, or the special user name &lt;code&gt;PUBLIC&lt;/code&gt; is used, then the policy applies to all users on the system. To allow all users to access only their own row in a &lt;code&gt;users&lt;/code&gt; table, a simple policy can be used:</source>
          <target state="translated">如果未指定角色，或使用特殊用户名 &lt;code&gt;PUBLIC&lt;/code&gt; ，则该策略将应用于系统上的所有用户。要允许所有用户仅访问 &lt;code&gt;users&lt;/code&gt; 表中自己的行，可以使用一个简单的策略：</target>
        </trans-unit>
        <trans-unit id="6d6b57e5927a5bed9026e109eaaf60a10bd5032f" translate="yes" xml:space="preserve">
          <source>If no synchronous standby names are specified here, then synchronous replication is not enabled and transaction commits will not wait for replication. This is the default configuration. Even when synchronous replication is enabled, individual transactions can be configured not to wait for replication by setting the &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt; parameter to &lt;code&gt;local&lt;/code&gt; or &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">如果此处未指定同步备用名称，则不会启用同步复制，并且事务提交将不等待复制。这是默认配置。即使启用了同步复制，也可以通过将&lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;sync_commit&lt;/a&gt;参数设置为 &lt;code&gt;local&lt;/code&gt; 或 &lt;code&gt;off&lt;/code&gt; ，将单个事务配置为不等待复制。</target>
        </trans-unit>
        <trans-unit id="b499f250be4863620a8af2772b67aa546566a3ec" translate="yes" xml:space="preserve">
          <source>If no table name is available, that is, when mapping a query or a cursor, the string &lt;code&gt;table&lt;/code&gt; is used in the first format, &lt;code&gt;row&lt;/code&gt; in the second format.</source>
          <target state="translated">如果没有可用的表名，也就是说，在映射查询或游标时，将以第一种格式使用字符串 &lt;code&gt;table&lt;/code&gt; ，以第二种格式使用 &lt;code&gt;row&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31cbf099df48b49708d8e3fe1c5398bc9eb2b4ff" translate="yes" xml:space="preserve">
          <source>If no tuples were deleted from the heap, B-tree indexes are still scanned at the &lt;code&gt;VACUUM&lt;/code&gt; cleanup stage when at least one of the following conditions is met: the index statistics are stale, or the index contains deleted pages that can be recycled during cleanup. Index statistics are considered to be stale if the number of newly inserted tuples exceeds the &lt;code&gt;vacuum_cleanup_index_scale_factor&lt;/code&gt; fraction of the total number of heap tuples detected by the previous statistics collection. The total number of heap tuples is stored in the index meta-page. Note that the meta-page does not include this data until &lt;code&gt;VACUUM&lt;/code&gt; finds no dead tuples, so B-tree index scan at the cleanup stage can only be skipped if the second and subsequent &lt;code&gt;VACUUM&lt;/code&gt; cycles detect no dead tuples.</source>
          <target state="translated">如果没有从堆中删除任何元组，则在满足以下至少一项条件时，在 &lt;code&gt;VACUUM&lt;/code&gt; 清理阶段仍会扫描B树索引：索引统计信息已过时，或者索引包含可在清理期间回收的已删除页面。如果新插入的元组的数量超过先前统计信息收集检测到的堆元组总数的 &lt;code&gt;vacuum_cleanup_index_scale_factor&lt;/code&gt; 分数，则索引统计信息被认为是过时的。堆元组的总数存储在索引元页面中。请注意，直到 &lt;code&gt;VACUUM&lt;/code&gt; 未找到任何死元组，元页面才包含此数据，因此只有在第二个和后续 &lt;code&gt;VACUUM&lt;/code&gt; 时才可以跳过清理阶段的B树索引扫描 循环检测不到死元组。</target>
        </trans-unit>
        <trans-unit id="a50a96a1efd9e9515cc7402b6a1585dcf6707637" translate="yes" xml:space="preserve">
          <source>If no view is specified, a blank &lt;code&gt;CREATE VIEW&lt;/code&gt; template is presented for editing.</source>
          <target state="translated">如果未指定 &lt;code&gt;CREATE VIEW&lt;/code&gt; 则显示空白的CREATE VIEW模板以供编辑。</target>
        </trans-unit>
        <trans-unit id="b168c695895a81115afb54900077dcd6394dd9a3" translate="yes" xml:space="preserve">
          <source>If not found, search an internal table to match the token as either a special string (e.g., &lt;code&gt;today&lt;/code&gt;), day (e.g., &lt;code&gt;Thursday&lt;/code&gt;), month (e.g., &lt;code&gt;January&lt;/code&gt;), or noise word (e.g., &lt;code&gt;at&lt;/code&gt;, &lt;code&gt;on&lt;/code&gt;).</source>
          <target state="translated">如果未找到，则搜索内部表以将令牌作为特殊字符串（例如， &lt;code&gt;today&lt;/code&gt; ），日期（例如， &lt;code&gt;Thursday&lt;/code&gt; ），月份（例如， &lt;code&gt;January&lt;/code&gt; ）或干扰词（例如， &lt;code&gt;at&lt;/code&gt; ， &lt;code&gt;on&lt;/code&gt; ）进行匹配。</target>
        </trans-unit>
        <trans-unit id="dc5b189453f6a7ea6efcd19711a7a024dd08877c" translate="yes" xml:space="preserve">
          <source>If not null, an error message indicating why this entry could not be applied</source>
          <target state="translated">如果不为空,则为错误信息,说明为什么不能应用该条目。</target>
        </trans-unit>
        <trans-unit id="8da51845e78e415599c49039ce6e56d900436b63" translate="yes" xml:space="preserve">
          <source>If not null, an error message indicating why this line could not be processed</source>
          <target state="translated">如果不为空,则为错误信息,说明为什么不能处理此行。</target>
        </trans-unit>
        <trans-unit id="96520540e7decec105d922c1561ef9f2b1d6ac9b" translate="yes" xml:space="preserve">
          <source>If on, any error will terminate the current session. By default, this is set to off, so that only FATAL errors will terminate the session.</source>
          <target state="translated">如果开启,任何错误都会终止当前会话。默认情况下,该选项被设置为关闭,因此只有FATAL错误才会终止会话。</target>
        </trans-unit>
        <trans-unit id="22cc3fdc7c909051830d32f3a9f4757f2bc2a2b3" translate="yes" xml:space="preserve">
          <source>If on, emit WAL-related debugging output. This parameter is only available if the &lt;code&gt;WAL_DEBUG&lt;/code&gt; macro was defined when PostgreSQL was compiled.</source>
          <target state="translated">如果启用，则发出与WAL相关的调试输出。仅当在编译PostgreSQL时定义了 &lt;code&gt;WAL_DEBUG&lt;/code&gt; 宏时，此参数才可用。</target>
        </trans-unit>
        <trans-unit id="ea0ac9e4d18cd146b0646e9f1eaaad11f3441b88" translate="yes" xml:space="preserve">
          <source>If on, emit information about lightweight lock usage. Lightweight locks are intended primarily to provide mutual exclusion of access to shared-memory data structures.</source>
          <target state="translated">如果开启,则发出轻量级锁使用信息。轻量级锁主要是为了提供对共享内存数据结构的相互排斥访问。</target>
        </trans-unit>
        <trans-unit id="108192b0a0e55fbd6c757081d9b7601d8b8f83e2" translate="yes" xml:space="preserve">
          <source>If on, emit information about lock usage. Information dumped includes the type of lock operation, the type of lock and the unique identifier of the object being locked or unlocked. Also included are bit masks for the lock types already granted on this object as well as for the lock types awaited on this object. For each lock type a count of the number of granted locks and waiting locks is also dumped as well as the totals. An example of the log file output is shown here:</source>
          <target state="translated">如果开启,则发出有关锁使用的信息。转发的信息包括锁操作的类型、锁的类型以及被锁或解锁对象的唯一标识符。还包括该对象上已经授予的锁类型以及该对象上等待的锁类型的位掩码。对于每一种锁类型,也会转储已授予的锁和等待的锁的数量以及总数。下面是日志文件输出的一个例子。</target>
        </trans-unit>
        <trans-unit id="fb4d7f85e50d03eb97a6b576612fc80288cfa67e" translate="yes" xml:space="preserve">
          <source>If on, emit information about resource usage during sort operations. This parameter is only available if the &lt;code&gt;TRACE_SORT&lt;/code&gt; macro was defined when PostgreSQL was compiled. (However, &lt;code&gt;TRACE_SORT&lt;/code&gt; is currently defined by default.)</source>
          <target state="translated">如果启用，则在排序操作期间发出有关资源使用情况的信息。仅当在编译PostgreSQL时定义了 &lt;code&gt;TRACE_SORT&lt;/code&gt; 宏时，此参数才可用。（但是，当前默认情况下定义了 &lt;code&gt;TRACE_SORT&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="2d6e32677420949906412ec403c3421f5aa432cd" translate="yes" xml:space="preserve">
          <source>If on, emit information about user lock usage. Output is the same as for &lt;code&gt;trace_locks&lt;/code&gt;, only for advisory locks.</source>
          <target state="translated">如果启用，则发出有关用户锁使用情况的信息。输出与 &lt;code&gt;trace_locks&lt;/code&gt; 相同，仅对于咨询锁。</target>
        </trans-unit>
        <trans-unit id="4f521f40c917171fc7c2808f83dd0cac811f61dc" translate="yes" xml:space="preserve">
          <source>If one PostgreSQL server cluster is planned to contain unrelated projects or users that should be, for the most part, unaware of each other, it is recommended to put them into separate databases and adjust authorizations and access controls accordingly. If the projects or users are interrelated, and thus should be able to use each other's resources, they should be put in the same database but probably into separate schemas; this provides a modular structure with namespace isolation and authorization control. More information about managing schemas is in &lt;a href=&quot;ddl-schemas&quot;&gt;Section 5.9&lt;/a&gt;.</source>
          <target state="translated">如果计划一个PostgreSQL服务器群集包含不相关的项目或用户，而这些项目或用户在大多数情况下彼此之间不了解，则建议将它们放在单独的数据库中，并相应地调整授权和访问控制。如果项目或用户是相互关联的，因此应该能够使用彼此的资源，则应将它们放在同一数据库中，但可能放在不同的模式中；这提供了具有名称空间隔离和授权控制的模块化结构。有关管理模式的更多信息，请参见&lt;a href=&quot;ddl-schemas&quot;&gt;5.9节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aa31b9c1a7b9373a56b5ac2143c494c8a9df5d88" translate="yes" xml:space="preserve">
          <source>If one argument of a binary operator invocation is of the &lt;code&gt;unknown&lt;/code&gt; type and the other is of a domain type, next check to see if there is an operator accepting exactly the domain's base type on both sides; if so, use it.</source>
          <target state="translated">如果二进制运算符调用的一个参数是 &lt;code&gt;unknown&lt;/code&gt; 类型，而另一个参数是域类型，则下一步检查是否有一个运算符在两侧都完全接受该域的基本类型；如果是这样，请使用它。</target>
        </trans-unit>
        <trans-unit id="f194f32ef831d4b3157a47fd2652de25dffaf886" translate="yes" xml:space="preserve">
          <source>If one argument of a binary operator invocation is of the &lt;code&gt;unknown&lt;/code&gt; type, then assume it is the same type as the other argument for this check. Invocations involving two &lt;code&gt;unknown&lt;/code&gt; inputs, or a unary operator with an &lt;code&gt;unknown&lt;/code&gt; input, will never find a match at this step.</source>
          <target state="translated">如果二进制运算符调用的一个参数是 &lt;code&gt;unknown&lt;/code&gt; 类型，则假定它与此检查的另一个参数是同一类型。涉及两个调用 &lt;code&gt;unknown&lt;/code&gt; 输入，或与一元运算符 &lt;code&gt;unknown&lt;/code&gt; 输入，将永远不会找到一个匹配在这一步。</target>
        </trans-unit>
        <trans-unit id="b3677d43219ced3f6fdb380478ec70536347404f" translate="yes" xml:space="preserve">
          <source>If one explicitly casts a bit-string value to &lt;code&gt;bit(n)&lt;/code&gt;, it will be truncated or zero-padded on the right to be exactly &lt;code&gt;n&lt;/code&gt; bits, without raising an error. Similarly, if one explicitly casts a bit-string value to &lt;code&gt;bit varying(n)&lt;/code&gt;, it will be truncated on the right if it is more than &lt;code&gt;n&lt;/code&gt; bits.</source>
          <target state="translated">如果将一个位字符串值显式转换为 &lt;code&gt;bit(n)&lt;/code&gt; ，则它将在右边被截断或补零，以正好是 &lt;code&gt;n&lt;/code&gt; 位，而不会引起错误。类似地，如果将一个位字符串值显式转换为 &lt;code&gt;bit varying(n)&lt;/code&gt; ，则如果它超过 &lt;code&gt;n&lt;/code&gt; 位，它将在右侧被截断。</target>
        </trans-unit>
        <trans-unit id="7d503789d22d34918cc5945f90261d6c003a05f3" translate="yes" xml:space="preserve">
          <source>If one explicitly casts a value to &lt;code&gt;character varying(n)&lt;/code&gt; or &lt;code&gt;character(n)&lt;/code&gt;, then an over-length value will be truncated to &lt;code&gt;n&lt;/code&gt; characters without raising an error. (This too is required by the SQL standard.)</source>
          <target state="translated">如果将一个值显式地转换为 &lt;code&gt;character varying(n)&lt;/code&gt; 或 &lt;code&gt;character(n)&lt;/code&gt; ，则超长值将被截断为 &lt;code&gt;n&lt;/code&gt; 个字符而不会引发错误。（这也是SQL标准所必需的。）</target>
        </trans-unit>
        <trans-unit id="1de7610e41ebab1a246a8c49a8f76058b712b92e" translate="yes" xml:space="preserve">
          <source>If one of the list items is the special name &lt;code&gt;$user&lt;/code&gt;, then the schema having the name returned by &lt;code&gt;CURRENT_USER&lt;/code&gt; is substituted, if there is such a schema and the user has &lt;code&gt;USAGE&lt;/code&gt; permission for it. (If not, &lt;code&gt;$user&lt;/code&gt; is ignored.)</source>
          <target state="translated">如果列表项之一是特殊名称 &lt;code&gt;$user&lt;/code&gt; ，那么将替换具有 &lt;code&gt;CURRENT_USER&lt;/code&gt; 返回的名称的模式（如果存在这样的模式，并且用户对其具有 &lt;code&gt;USAGE&lt;/code&gt; 权限）。（否则，将忽略 &lt;code&gt;$user&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="19441d8efa255c5a903fe7f3e4cb160f4e49f55a" translate="yes" xml:space="preserve">
          <source>If only the parser is specified, then the new text search configuration initially has no mappings from token types to dictionaries, and therefore will ignore all words. Subsequent &lt;code&gt;ALTER TEXT SEARCH CONFIGURATION&lt;/code&gt; commands must be used to create mappings to make the configuration useful. Alternatively, an existing text search configuration can be copied.</source>
          <target state="translated">如果仅指定了解析器，则新的文本搜索配置最初没有从令牌类型到字典的映射，因此将忽略所有单词。随后的 &lt;code&gt;ALTER TEXT SEARCH CONFIGURATION&lt;/code&gt; 命令必须用于创建映射以使配置有用。或者，可以复制现有的文本搜索配置。</target>
        </trans-unit>
        <trans-unit id="f8ecaaa3f305e080c140c9a79731fd19853d9256" translate="yes" xml:space="preserve">
          <source>If parentheses appear after &lt;code&gt;\g&lt;/code&gt;, they surround a space-separated list of &lt;code&gt;option&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;value&lt;/code&gt; formatting-option clauses, which are interpreted in the same way as &lt;code&gt;\pset&lt;/code&gt;&lt;code&gt;option&lt;/code&gt;&lt;code&gt;value&lt;/code&gt; commands, but take effect only for the duration of this query. In this list, spaces are not allowed around &lt;code&gt;=&lt;/code&gt; signs, but are required between option clauses. If &lt;code&gt;=&lt;/code&gt;&lt;code&gt;value&lt;/code&gt; is omitted, the named &lt;code&gt;option&lt;/code&gt; is changed in the same way as for &lt;code&gt;\pset&lt;/code&gt;&lt;code&gt;option&lt;/code&gt; with no explicit &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">如果括号在 &lt;code&gt;\g&lt;/code&gt; 后面出现，它们将包围由空格分隔的 &lt;code&gt;option&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; formatting-option子句列表，这些子句的解释方式与 &lt;code&gt;\pset&lt;/code&gt; &lt;code&gt;option&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; 命令相同，但仅在此查询期间有效。在此列表中，在 &lt;code&gt;=&lt;/code&gt; 号前后不允许有空格，但在选项子句之间必须有空格。如果省略 &lt;code&gt;=&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; ，则命名 &lt;code&gt;option&lt;/code&gt; 的更改方式与 &lt;code&gt;\pset&lt;/code&gt; &lt;code&gt;option&lt;/code&gt; ，没有显式 &lt;code&gt;value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1317b8ae94e1b0f60e57dbb20e11b92a9f8c5a7" translate="yes" xml:space="preserve">
          <source>If partial newline-sensitive matching is specified, this affects &lt;code&gt;.&lt;/code&gt; and bracket expressions as with newline-sensitive matching, but not &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt;.</source>
          <target state="translated">如果指定了部分对换行符敏感的匹配，则会影响 &lt;code&gt;.&lt;/code&gt; 和方括号表达式，与换行敏感匹配一样，但不包括 &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;$&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5535f2a09b6cea90f6f2421f76ccf57b35834ee5" translate="yes" xml:space="preserve">
          <source>If pg_checksums is aborted or killed while enabling or disabling checksums, the cluster's data checksum configuration remains unchanged, and pg_checksums can be re-run to perform the same operation.</source>
          <target state="translated">如果在启用或禁用校验和时,pg_checksums被中止或被杀死,则集群的数据校验和配置保持不变,pg_checksums可以重新运行来执行同样的操作。</target>
        </trans-unit>
        <trans-unit id="329ffa5a3154cd15ee165233a8d448dbe8dc1875" translate="yes" xml:space="preserve">
          <source>If pg_rewind fails while processing, then the data folder of the target is likely not in a state that can be recovered. In such a case, taking a new fresh backup is recommended.</source>
          <target state="translated">如果pg_rewind在处理过程中失败,那么目标的数据文件夹很可能不在可以恢复的状态。在这种情况下,建议进行新的备份。</target>
        </trans-unit>
        <trans-unit id="928868bbd3ab201faf3713aebe691a864c3216eb" translate="yes" xml:space="preserve">
          <source>If present, the operator class will become the default operator class for its data type. At most one operator class can be the default for a specific data type and index method.</source>
          <target state="translated">如果存在,该运算符类将成为其数据类型的默认运算符类。对于一个特定的数据类型和索引方法,最多只能有一个运算符类是默认的。</target>
        </trans-unit>
        <trans-unit id="dce8d13840c91deea2eabbef36d881ff8d4820b8" translate="yes" xml:space="preserve">
          <source>If primary restarts while commits are waiting for acknowledgment, those waiting transactions will be marked fully committed once the primary database recovers. There is no way to be certain that all standbys have received all outstanding WAL data at time of the crash of the primary. Some transactions may not show as committed on the standby, even though they show as committed on the primary. The guarantee we offer is that the application will not receive explicit acknowledgment of the successful commit of a transaction until the WAL data is known to be safely received by all the synchronous standbys.</source>
          <target state="translated">如果主数据库重启时,提交的事务正在等待确认,一旦主数据库恢复,这些等待的事务将被标记为完全提交。无法确定在主数据库崩溃时,所有备用数据库都收到了所有未完成的WAL数据。有些事务可能不会在备用机上显示为已提交,即使它们在主数据库上显示为已提交。我们提供的保证是,在所有同步的备用服务器安全地接收到WAL数据之前,应用程序不会收到事务成功提交的明确确认。</target>
        </trans-unit>
        <trans-unit id="cabf4b566b843e529d70b87d853fee3f06c7f4bf" translate="yes" xml:space="preserve">
          <source>If queries are simply broadcast unmodified, functions like &lt;code&gt;random()&lt;/code&gt;, &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt;, and sequences can have different values on different servers. This is because each server operates independently, and because SQL queries are broadcast (and not actual modified rows). If this is unacceptable, either the middleware or the application must query such values from a single server and then use those values in write queries. Another option is to use this replication option with a traditional master-standby setup, i.e. data modification queries are sent only to the master and are propagated to the standby servers via master-standby replication, not by the replication middleware. Care must also be taken that all transactions either commit or abort on all servers, perhaps using two-phase commit (&lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt; and &lt;a href=&quot;sql-commit-prepared&quot;&gt;COMMIT PREPARED&lt;/a&gt;). Pgpool-II and Continuent Tungsten are examples of this type of replication.</source>
          <target state="translated">如果只是简单地广播查询而未修改，则使用 &lt;code&gt;random()&lt;/code&gt; ， &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt; 之类的函数，并且序列在不同的服务器上可以具有不同的值。这是因为每个服务器都独立运行，并且因为SQL查询是广播的（而不是实际修改的行）。如果这是不可接受的，则中间件或应用程序必须从单个服务器查询这些值，然后在写查询中使用这些值。另一个选择是将此复制选项与传统的主备设置一起使用，即，数据修改查询仅发送到主服务器，并通过主备复制而不是复制中间件传播到备用服务器。还必须注意所有事务都可能在两台服务器上提交或中止，也许使用两阶段提交（&lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt;和&lt;a href=&quot;sql-commit-prepared&quot;&gt;COMMIT PREPARED&lt;/a&gt;）。Pgpool-II和连续钨是这种复制的示例。</target>
        </trans-unit>
        <trans-unit id="493b00be39141f1a1aeb09adbc6c889957fa4153" translate="yes" xml:space="preserve">
          <source>If queries are simply broadcast unmodified, functions like &lt;code&gt;random()&lt;/code&gt;, &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt;, and sequences can have different values on different servers. This is because each server operates independently, and because SQL queries are broadcast (and not actual modified rows). If this is unacceptable, either the middleware or the application must query such values from a single server and then use those values in write queries. Another option is to use this replication option with a traditional master-standby setup, i.e., data modification queries are sent only to the master and are propagated to the standby servers via master-standby replication, not by the replication middleware. Care must also be taken that all transactions either commit or abort on all servers, perhaps using two-phase commit (&lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt; and &lt;a href=&quot;sql-commit-prepared&quot;&gt;COMMIT PREPARED&lt;/a&gt;). Pgpool-II and Continuent Tungsten are examples of this type of replication.</source>
          <target state="translated">如果只是简单地广播查询而未修改，则使用 &lt;code&gt;random()&lt;/code&gt; ， &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt; 之类的函数，并且序列在不同的服务器上可以具有不同的值。这是因为每个服务器都独立运行，并且因为SQL查询是广播的（而不是实际修改的行）。如果这是不可接受的，则中间件或应用程序必须从单个服务器查询这些值，然后在写查询中使用这些值。另一个选择是将此复制选项与传统的主备设置一起使用，即，数据修改查询仅发送到主服务器，并通过主备复制而不是复制中间件传播到备用服务器。还必须注意，所有事务都可能在两台服务器上提交或中止，也许使用两阶段提交（&lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt;和&lt;a href=&quot;sql-commit-prepared&quot;&gt;COMMIT PREPARED&lt;/a&gt;）。Pgpool-II和连续钨是此类复制的示例。</target>
        </trans-unit>
        <trans-unit id="f63cea3b2db7baf929d271a8512ae9d2283784c6" translate="yes" xml:space="preserve">
          <source>If recovery finds corrupted WAL data, recovery will halt at that point and the server will not start. In such a case the recovery process could be re-run from the beginning, specifying a &amp;ldquo;recovery target&amp;rdquo; before the point of corruption so that recovery can complete normally. If recovery fails for an external reason, such as a system crash or if the WAL archive has become inaccessible, then the recovery can simply be restarted and it will restart almost from where it failed. Recovery restart works much like checkpointing in normal operation: the server periodically forces all its state to disk, and then updates the &lt;code&gt;pg_control&lt;/code&gt; file to indicate that the already-processed WAL data need not be scanned again.</source>
          <target state="translated">如果恢复发现损坏的WAL数据，恢复将在此时停止，服务器将无法启动。在这种情况下，可以从头开始重新运行恢复过程，在损坏点之前指定一个&amp;ldquo;恢复目标&amp;rdquo;，以便恢复可以正常完成。如果恢复由于外部原因（例如系统崩溃）或WAL存档变得不可访问而失败，则可以简单地重新启动恢复，并且恢复几乎从失败的地方重新开始。恢复重启的工作原理与正常操作中的检查点类似：服务器会定期将其所有状态强制进入磁盘，然后更新 &lt;code&gt;pg_control&lt;/code&gt; 文件以指示不需要再次扫描已处理的WAL数据。</target>
        </trans-unit>
        <trans-unit id="28dab788b6122ef3bd1cdbda4da4f94cd1b6e630" translate="yes" xml:space="preserve">
          <source>If restoring from backup, rename or delete the old installation directory if it is not version-specific. It is a good idea to rename the directory, rather than delete it, in case you have trouble and need to revert to it. Keep in mind the directory might consume significant disk space. To rename the directory, use a command like this:</source>
          <target state="translated">如果从备份中恢复,请重命名或删除旧的安装目录,如果它不是特定版本。最好是重命名该目录,而不是删除它,以防遇到问题需要恢复到该目录。请记住,该目录可能会消耗大量的磁盘空间。要重命名目录,请使用类似这样的命令。</target>
        </trans-unit>
        <trans-unit id="e309c571c391be62f34e7db7a0c0dec41e3362c4" translate="yes" xml:space="preserve">
          <source>If role can log in, this specifies how many concurrent connections the role can make. -1 (the default) means no limit. Note that only normal connections are counted towards this limit. Neither prepared transactions nor background worker connections are counted towards this limit.</source>
          <target state="translated">如果角色可以登录,则指定该角色可以进行多少个并发连接。-1(默认)表示没有限制。请注意,只有正常的连接才会被计入这个限制。准备好的事务和后台工作者的连接都不计入此限制。</target>
        </trans-unit>
        <trans-unit id="62496fbde4961b27e361cbfa11a352d993b40959" translate="yes" xml:space="preserve">
          <source>If row-level security is enabled for a table, but no applicable policies exist, a &amp;ldquo;default deny&amp;rdquo; policy is assumed, so that no rows will be visible or updatable.</source>
          <target state="translated">如果为表启用了行级安全性，但是不存在适用的策略，那么将采用&amp;ldquo;默认拒绝&amp;rdquo;策略，这样就不会有可见或可更新的行。</target>
        </trans-unit>
        <trans-unit id="fe157e3ff3573012872e8150157f95ab8031e531" translate="yes" xml:space="preserve">
          <source>If row-level security is enabled for the table, the relevant &lt;code&gt;SELECT&lt;/code&gt; policies will apply to &lt;code&gt;COPY table TO&lt;/code&gt; statements. Currently, &lt;code&gt;COPY FROM&lt;/code&gt; is not supported for tables with row-level security. Use equivalent &lt;code&gt;INSERT&lt;/code&gt; statements instead.</source>
          <target state="translated">如果为表启用了行级安全性，则相关的 &lt;code&gt;SELECT&lt;/code&gt; 策略将应用于 &lt;code&gt;COPY table TO&lt;/code&gt; 语句。当前，具有行级安全性的表不支持 &lt;code&gt;COPY FROM&lt;/code&gt; 。请使用等效的 &lt;code&gt;INSERT&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="a6aa638ed0fa1c0e796268aac030545b317ec979" translate="yes" xml:space="preserve">
          <source>If running in FreeBSD jails by enabling sysctl's &lt;code&gt;security.jail.sysvipc_allowed&lt;/code&gt;, postmasters running in different jails should be run by different operating system users. This improves security because it prevents non-root users from interfering with shared memory or semaphores in different jails, and it allows the PostgreSQL IPC cleanup code to function properly. (In FreeBSD 6.0 and later the IPC cleanup code does not properly detect processes in other jails, preventing the running of postmasters on the same port in different jails.)</source>
          <target state="translated">如果通过启用sysctl的 &lt;code&gt;security.jail.sysvipc_allowed&lt;/code&gt; 在FreeBSD监狱中运行，则在不同监狱中运行的邮局主管应由不同的操作系统用户运行。这可以提高安全性，因为它可以防止非root用户干扰不同监狱中的共享内存或信号，并且可以使PostgreSQL IPC清理代码正常运行。 （在FreeBSD 6.0及更高版本中，IPC清理代码无法正确检测其他监狱中的进程，从而阻止了邮局主管在不同监狱中的同一端口上运行。）</target>
        </trans-unit>
        <trans-unit id="3d60f2762027b6b57c372852caf475ebc7475d90" translate="yes" xml:space="preserve">
          <source>If running in a FreeBSD jail, you should set its &lt;code&gt;sysvshm&lt;/code&gt; parameter to &lt;code&gt;new&lt;/code&gt;, so that it has its own separate System V shared memory namespace. (Before FreeBSD 11.0, it was necessary to enable shared access to the host's IPC namespace from jails, and take measures to avoid collisions.)</source>
          <target state="translated">如果在FreeBSD监狱中运行，则应将其 &lt;code&gt;sysvshm&lt;/code&gt; 参数设置为 &lt;code&gt;new&lt;/code&gt; ，以使其具有自己独立的System V共享内存名称空间。（在FreeBSD 11.0之前，必须启用从监狱对主机IPC名称空间的共享访问，并采取措施避免冲突。）</target>
        </trans-unit>
        <trans-unit id="abdee92b42312c6177118cbed677697bf85b5620" translate="yes" xml:space="preserve">
          <source>If set to 0, the realm name from the authenticated user principal is stripped off before being passed through the user name mapping (&lt;a href=&quot;auth-username-maps&quot;&gt;Section 20.2&lt;/a&gt;). This is discouraged and is primarily available for backwards compatibility, as it is not secure in multi-realm environments unless &lt;code&gt;krb_realm&lt;/code&gt; is also used. It is recommended to leave &lt;code&gt;include_realm&lt;/code&gt; set to the default (1) and to provide an explicit mapping in &lt;code&gt;pg_ident.conf&lt;/code&gt; to convert principal names to PostgreSQL user names.</source>
          <target state="translated">如果设置为0，则经过身份验证的用户主体的领域名称将在通过用户名映射之前被剥离（&lt;a href=&quot;auth-username-maps&quot;&gt;第20.2节&lt;/a&gt;）。不建议这样做，并且主要可用于向后兼容，因为除非在多领域环境中使用 &lt;code&gt;krb_realm&lt;/code&gt; ,否则它不安全。建议将 &lt;code&gt;include_realm&lt;/code&gt; 设置为默认值（1），并在 &lt;code&gt;pg_ident.conf&lt;/code&gt; 中提供显式映射，以将主体名称转换为PostgreSQL用户名。</target>
        </trans-unit>
        <trans-unit id="752bcd0b9281c38894ddeb4c193f0b06ac531341" translate="yes" xml:space="preserve">
          <source>If set to 1 or less, sending an EOF character (usually &lt;strong&gt;Control&lt;/strong&gt;+&lt;strong&gt;D&lt;/strong&gt;) to an interactive session of psql will terminate the application. If set to a larger numeric value, that many consecutive EOF characters must be typed to make an interactive session terminate. If the variable is set to a non-numeric value, it is interpreted as 10. The default is 0.</source>
          <target state="translated">如果设置为1或更小，向psql的交互式会话发送EOF字符（通常是&lt;strong&gt;Control&lt;/strong&gt; + &lt;strong&gt;D&lt;/strong&gt;）将终止应用程序。如果设置为较大的数值，则必须键入许多连续的EOF字符以使交互式会话终止。如果变量设置为非数字值，则将其解释为10。默认值为0。</target>
        </trans-unit>
        <trans-unit id="f150c6b9d3460dc605d8aac9efe72846ba7bd56d" translate="yes" xml:space="preserve">
          <source>If set to 1, the domain's SAM-compatible name (also known as the NetBIOS name) is used for the &lt;code&gt;include_realm&lt;/code&gt; option. This is the default. If set to 0, the true realm name from the Kerberos user principal name is used.</source>
          <target state="translated">如果设置为1，则将域的SAM兼容名称（也称为NetBIOS名称）用于 &lt;code&gt;include_realm&lt;/code&gt; 选项。这是默认值。如果设置为0，则使用Kerberos用户主体名称中的真实领域名称。</target>
        </trans-unit>
        <trans-unit id="82302c2f8409896da1eb7439e9dc154b96d3a8b4" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;all&lt;/code&gt;, all nonempty input lines are printed to standard output as they are read. (This does not apply to lines read interactively.) To select this behavior on program start-up, use the switch &lt;code&gt;-a&lt;/code&gt;. If set to &lt;code&gt;queries&lt;/code&gt;, psql prints each query to standard output as it is sent to the server. The switch to select this behavior is &lt;code&gt;-e&lt;/code&gt;. If set to &lt;code&gt;errors&lt;/code&gt;, then only failed queries are displayed on standard error output. The switch for this behavior is &lt;code&gt;-b&lt;/code&gt;. If set to &lt;code&gt;none&lt;/code&gt; (the default), then no queries are displayed.</source>
          <target state="translated">如果设置为 &lt;code&gt;all&lt;/code&gt; ，则所有非空输入行在读取时都会打印到标准输出。 （这不适用于以交互方式读取的行。）要在程序启动时选择此行为，请使用开关 &lt;code&gt;-a&lt;/code&gt; 。如果设置为 &lt;code&gt;queries&lt;/code&gt; ，则psql在将每个查询发送到服务器时将其打印到标准输出。选择此行为的开关是 &lt;code&gt;-e&lt;/code&gt; 。如果设置为 &lt;code&gt;errors&lt;/code&gt; ，那么标准错误输出仅显示失败的查询。此行为的开关是 &lt;code&gt;-b&lt;/code&gt; 。如果设置为 &lt;code&gt;none&lt;/code&gt; （默认值），则不显示查询。</target>
        </trans-unit>
        <trans-unit id="4e8e09a59b4bf762d85ca1f3a58b8a4dd3ab9bc9" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;off&lt;/code&gt; (the default), detection of WAL records having references to invalid pages during recovery causes PostgreSQL to raise a PANIC-level error, aborting the recovery. Setting &lt;code&gt;ignore_invalid_pages&lt;/code&gt; to &lt;code&gt;on&lt;/code&gt; causes the system to ignore invalid page references in WAL records (but still report a warning), and continue the recovery. This behavior may &lt;em&gt;cause crashes, data loss, propagate or hide corruption, or other serious problems&lt;/em&gt;. However, it may allow you to get past the PANIC-level error, to finish the recovery, and to cause the server to start up. The parameter can only be set at server start. It only has effect during recovery or in standby mode.</source>
          <target state="translated">如果设置为 &lt;code&gt;off&lt;/code&gt; （默认值），则在恢复期间检测到对无效页面的引用的WAL记录会导致PostgreSQL引发PANIC级别的错误，从而中止恢复。将 &lt;code&gt;ignore_invalid_pages&lt;/code&gt; 设置为 &lt;code&gt;on&lt;/code&gt; 会导致系统忽略WAL记录中的无效页面引用（但仍会报告警告），并继续恢复。此行为可能&lt;em&gt;导致崩溃，数据丢失，传播或隐藏损坏或其他严重问题&lt;/em&gt;。但是，它可能允许您克服PANIC级别的错误，完成恢复并导致服务器启动。该参数只能在服务器启动时设置。它仅在恢复或待机模式下有效。</target>
        </trans-unit>
        <trans-unit id="9981243abcd6bfa6b05982c27d6e7ff810b5e4a9" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;on&lt;/code&gt; (the default), this option causes WAL files to be recycled by renaming them, avoiding the need to create new ones. On COW file systems, it may be faster to create new ones, so the option is given to disable this behavior.</source>
          <target state="translated">如果设置为 &lt;code&gt;on&lt;/code&gt; （默认值），此选项将通过重命名WAL文件来使它们循环使用，而无需创建新文件。在COW文件系统上，创建新文件系统可能更快，因此提供了禁用此行为的选项。</target>
        </trans-unit>
        <trans-unit id="813f1fb7e134b84c20368173806332413bb9e2ea" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;on&lt;/code&gt; (the default), this option causes new WAL files to be filled with zeroes. On some file systems, this ensures that space is allocated before we need to write WAL records. However, &lt;em&gt;Copy-On-Write&lt;/em&gt; (COW) file systems may not benefit from this technique, so the option is given to skip the unnecessary work. If set to &lt;code&gt;off&lt;/code&gt;, only the final byte is written when the file is created so that it has the expected size.</source>
          <target state="translated">如果设置为 &lt;code&gt;on&lt;/code&gt; （默认值），则此选项将使新的WAL文件填充零。在某些文件系统上，这可确保在需要写入WAL记录之前已分配空间。但是，&lt;em&gt;写时复制&lt;/em&gt;（COW）文件系统可能无法从此技术中受益，因此可以选择跳过不必要的工作。如果设置为 &lt;code&gt;off&lt;/code&gt; ，则在创建文件时仅写入最后一个字节，以使其具有预期的大小。</target>
        </trans-unit>
        <trans-unit id="0fba393e4d7deed9cb85ba465e5b27c9e3ab7dd3" translate="yes" xml:space="preserve">
          <source>If set to a non-existent library, JIT will not be available, but no error will be raised. This allows JIT support to be installed separately from the main PostgreSQL package.</source>
          <target state="translated">如果设置为不存在的库,JIT将不可用,但不会引起错误。这允许JIT支持从主PostgreSQL包中单独安装。</target>
        </trans-unit>
        <trans-unit id="b3b3af4f011e1d63d9b8223219828980a0583602" translate="yes" xml:space="preserve">
          <source>If set to on, PostgreSQL will instead report an error but continue to run so that the data flushing operation can be retried in a later checkpoint. Only set it to on after investigating the operating system's treatment of buffered data in case of write-back failure.</source>
          <target state="translated">如果设置为on,PostgreSQL反而会报告一个错误,但继续运行,以便在以后的检查点中重新尝试数据冲洗操作。只有在调查了操作系统对缓冲数据在回写失败时的处理方式后,才将其设置为on。</target>
        </trans-unit>
        <trans-unit id="bbcf79a2d604d4a130bf67d3aa6808540ca830ba" translate="yes" xml:space="preserve">
          <source>If set, do not trace locks for tables below this OID (used to avoid output on system tables).</source>
          <target state="translated">如果设置,则不跟踪此OID以下表的锁(用于避免系统表的输出)。</target>
        </trans-unit>
        <trans-unit id="7b7ecf1b7610990cb56a543c68a5259c46df2a63" translate="yes" xml:space="preserve">
          <source>If set, do not trace locks for tables below this OID. (use to avoid output on system tables)</source>
          <target state="translated">如果设置,则不跟踪此OID以下表的锁。(用于避免系统表的输出)</target>
        </trans-unit>
        <trans-unit id="41deca852e6fe629c05086ec201225e618efe1c2" translate="yes" xml:space="preserve">
          <source>If set, dumps information about all current locks when a deadlock timeout occurs.</source>
          <target state="translated">如果设置,当死锁超时时,转储所有当前锁的信息。</target>
        </trans-unit>
        <trans-unit id="18ea3580271535268c36ef5f8d3f6aa2461f7a29" translate="yes" xml:space="preserve">
          <source>If set, logs system resource usage statistics (memory and CPU) on various B-tree operations.</source>
          <target state="translated">如果设置,则记录各种B树操作的系统资源使用统计(内存和CPU)。</target>
        </trans-unit>
        <trans-unit id="8cd44fecb272ef12a9372f7353f761fae8a5a0b8" translate="yes" xml:space="preserve">
          <source>If set, the name of the database to create, unless overridden on the command line.</source>
          <target state="translated">如果设置,则是要创建的数据库的名称,除非在命令行中被覆盖。</target>
        </trans-unit>
        <trans-unit id="451271dfdfad4c754e04924937d10fe2728cec15" translate="yes" xml:space="preserve">
          <source>If several large tables all become eligible for vacuuming in a short amount of time, all autovacuum workers might become occupied with vacuuming those tables for a long period. This would result in other tables and databases not being vacuumed until a worker becomes available. There is no limit on how many workers might be in a single database, but workers do try to avoid repeating work that has already been done by other workers. Note that the number of running workers does not count towards &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; or &lt;a href=&quot;runtime-config-connection#GUC-SUPERUSER-RESERVED-CONNECTIONS&quot;&gt;superuser_reserved_connections&lt;/a&gt; limits.</source>
          <target state="translated">如果几张大桌子都可以在短时间内进行吸尘工作，则所有自动真空工作人员可能会长时间占用这些桌子。这将导致其他表和数据库在工作人员可用之前不会被清理。一个数据库中可以有多少工作人员没有限制，但是工作人员确实会尝试避免重复其他工作人员已经完成的工作。请注意，正在运行的工作程序数不计入&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;或&lt;a href=&quot;runtime-config-connection#GUC-SUPERUSER-RESERVED-CONNECTIONS&quot;&gt;superuser_reserved_connections&lt;/a&gt;限制。</target>
        </trans-unit>
        <trans-unit id="0c0765d00a52dbd937ed1bff59efeb02a5ce2381" translate="yes" xml:space="preserve">
          <source>If simultaneous snapshots are not possible, one option is to shut down the database server long enough to establish all the frozen snapshots. Another option is to perform a continuous archiving base backup (&lt;a href=&quot;continuous-archiving#BACKUP-BASE-BACKUP&quot;&gt;Section 25.3.2&lt;/a&gt;) because such backups are immune to file system changes during the backup. This requires enabling continuous archiving just during the backup process; restore is done using continuous archive recovery (&lt;a href=&quot;continuous-archiving#BACKUP-PITR-RECOVERY&quot;&gt;Section 25.3.4&lt;/a&gt;).</source>
          <target state="translated">如果不可能同时创建快照，则一种选择是关闭数据库服务器足够长的时间以建立所有冻结的快照。另一种选择是执行连续归档基础备份（&lt;a href=&quot;continuous-archiving#BACKUP-BASE-BACKUP&quot;&gt;第25.3.2节&lt;/a&gt;），因为此类备份在备份期间不受文件系统更改的影响。这要求仅在备份过程中启用连续归档。使用连续归档恢复（&lt;a href=&quot;continuous-archiving#BACKUP-PITR-RECOVERY&quot;&gt;第25.3.4节&lt;/a&gt;）来完成恢复。</target>
        </trans-unit>
        <trans-unit id="7b56d1af18915d5bc67acc7e5f67cf1743ccd0db" translate="yes" xml:space="preserve">
          <source>If specific tables are named in a locking clause, then only rows coming from those tables are locked; any other tables used in the &lt;code&gt;SELECT&lt;/code&gt; are simply read as usual. A locking clause without a table list affects all tables used in the statement. If a locking clause is applied to a view or sub-query, it affects all tables used in the view or sub-query. However, these clauses do not apply to &lt;code&gt;WITH&lt;/code&gt; queries referenced by the primary query. If you want row locking to occur within a &lt;code&gt;WITH&lt;/code&gt; query, specify a locking clause within the &lt;code&gt;WITH&lt;/code&gt; query.</source>
          <target state="translated">如果在锁定子句中指定了特定的表，则仅锁定那些表中的行；像往常一样简单地读取 &lt;code&gt;SELECT&lt;/code&gt; 中使用的任何其他表。没有表列表的锁定子句会影响该语句中使用的所有表。如果将锁定子句应用于视图或子查询，则它将影响该视图或子查询中使用的所有表。但是，这些子句不适用于主查询引用的 &lt;code&gt;WITH&lt;/code&gt; 查询。如果你想行锁到内的发生 &lt;code&gt;WITH&lt;/code&gt; 查询，指定内锁定条款 &lt;code&gt;WITH&lt;/code&gt; 查询。</target>
        </trans-unit>
        <trans-unit id="beba3aa15b0f31c93cbfaa613e20da31b4d61852" translate="yes" xml:space="preserve">
          <source>If specified, the sequence object is created only for this session, and is automatically dropped on session exit. Existing permanent sequences with the same name are not visible (in this session) while the temporary sequence exists, unless they are referenced with schema-qualified names.</source>
          <target state="translated">如果指定,序列对象只为这个会话创建,并在会话退出时自动放弃。当临时序列存在时,现有的同名永久序列不可见(在这个会话中),除非它们被模式限定的名称引用。</target>
        </trans-unit>
        <trans-unit id="96e1f90a66af2b7d727620148bca6f42e74b9d62" translate="yes" xml:space="preserve">
          <source>If specified, the table is created as a temporary table. Refer to &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for details.</source>
          <target state="translated">如果指定，该表将被创建为临时表。有关详细信息，请参考&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a93d62c01130cfe765292bae429e3354023ac5a8" translate="yes" xml:space="preserve">
          <source>If specified, the table is created as a temporary table. Temporary tables are automatically dropped at the end of a session, or optionally at the end of the current transaction (see &lt;code&gt;ON COMMIT&lt;/code&gt; below). Existing permanent tables with the same name are not visible to the current session while the temporary table exists, unless they are referenced with schema-qualified names. Any indexes created on a temporary table are automatically temporary as well.</source>
          <target state="translated">如果指定，该表将被创建为临时表。临时表在会话结束时或在当前事务结束时自动删除（请参见下面的 &lt;code&gt;ON COMMIT&lt;/code&gt; ）。临时表存在时，具有相同名称的现有永久表在当前会话中不可见，除非使用架构限定名称引用它们。在临时表上创建的所有索引也会自动成为临时索引。</target>
        </trans-unit>
        <trans-unit id="e56b4bad12a19e93500049e2da8fe4abf56f18b0" translate="yes" xml:space="preserve">
          <source>If specified, the table is created as an unlogged table. Data written to unlogged tables is not written to the write-ahead log (see &lt;a href=&quot;https://www.postgresql.org/docs/12/wal.html&quot;&gt;Chapter 29&lt;/a&gt;), which makes them considerably faster than ordinary tables. However, they are not crash-safe: an unlogged table is automatically truncated after a crash or unclean shutdown. The contents of an unlogged table are also not replicated to standby servers. Any indexes created on an unlogged table are automatically unlogged as well.</source>
          <target state="translated">如果指定，该表将创建为未记录表。写入未记录表的数据不会写入预写日志（请参阅&lt;a href=&quot;https://www.postgresql.org/docs/12/wal.html&quot;&gt;第29章&lt;/a&gt;），这使它们比普通表快得多。但是，它们不是崩溃安全的：崩溃或异常关闭后，未记录的表会自动被截断。未记录表的内容也不会复制到备用服务器。在未记录表上创建的所有索引也会自动取消记录。</target>
        </trans-unit>
        <trans-unit id="a8596f70e4f839c2549fada82806079e6705f6bb" translate="yes" xml:space="preserve">
          <source>If specified, the table is created as an unlogged table. Data written to unlogged tables is not written to the write-ahead log (see &lt;a href=&quot;https://www.postgresql.org/docs/13/wal.html&quot;&gt;Chapter 29&lt;/a&gt;), which makes them considerably faster than ordinary tables. However, they are not crash-safe: an unlogged table is automatically truncated after a crash or unclean shutdown. The contents of an unlogged table are also not replicated to standby servers. Any indexes created on an unlogged table are automatically unlogged as well.</source>
          <target state="translated">如果指定，该表将创建为未记录的表。写入未记录表的数据不会写入预写日志（请参阅&lt;a href=&quot;https://www.postgresql.org/docs/13/wal.html&quot;&gt;第29章&lt;/a&gt;），这使它们比普通表快得多。但是，它们不是崩溃安全的：崩溃或不正常关机后，未记录的表会自动被截断。未记录表的内容也不会复制到备用服务器。在未记录表上创建的所有索引也会自动取消记录。</target>
        </trans-unit>
        <trans-unit id="498ade4fa6d89cb5e928b12b79fbd85a2d4b6bc5" translate="yes" xml:space="preserve">
          <source>If specified, the table is created as an unlogged table. Refer to &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for details.</source>
          <target state="translated">如果指定，该表将创建为未记录表。有关详细信息，请参考&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="55118ee1dbd9adb1bf85c53f18502dc86e8b6ddb" translate="yes" xml:space="preserve">
          <source>If specified, the view is created as a temporary view. Temporary views are automatically dropped at the end of the current session. Existing permanent relations with the same name are not visible to the current session while the temporary view exists, unless they are referenced with schema-qualified names.</source>
          <target state="translated">如果指定了,则会将视图创建为临时视图。临时视图会在当前会话结束时自动放弃。当临时视图存在时,现有的同名永久关系对当前会话不可见,除非它们被模式限定的名称引用。</target>
        </trans-unit>
        <trans-unit id="6b5dcbb0812dddc20d9371b9207b1cdb23e05524" translate="yes" xml:space="preserve">
          <source>If still not found, throw an error.</source>
          <target state="translated">如果仍未找到,则抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="47cfc3e95fb2a4c5ace1abe2c232997982b636d2" translate="yes" xml:space="preserve">
          <source>If streaming replication is disabled, the paused state may continue indefinitely without a problem. If streaming replication is in progress then WAL records will continue to be received, which will eventually fill available disk space, depending upon the duration of the pause, the rate of WAL generation and available disk space.</source>
          <target state="translated">如果禁用了流式复制,则暂停状态可以无限期地继续下去,不会有问题。如果流式复制正在进行,那么将继续接收WAL记录,最终将填满可用的磁盘空间,这取决于暂停的持续时间、WAL的生成速度和可用的磁盘空间。</target>
        </trans-unit>
        <trans-unit id="07af580d9fd90f0744560609d17c425a1c0582ea" translate="yes" xml:space="preserve">
          <source>If streaming replication is disabled, the paused state may continue indefinitely without problem. While streaming replication is in progress WAL records will continue to be received, which will eventually fill available disk space, depending upon the duration of the pause, the rate of WAL generation and available disk space.</source>
          <target state="translated">如果禁用了流式复制,则暂停状态可以无限期地继续下去而不会出现问题。当流式复制进行时,将继续接收WAL记录,这些记录最终将填满可用的磁盘空间,这取决于暂停的持续时间、WAL的生成速度和可用的磁盘空间。</target>
        </trans-unit>
        <trans-unit id="226224ac165619e504532207642e17cb378b9939" translate="yes" xml:space="preserve">
          <source>If syslog is ultimately logging to a text file, then the effect will be the same either way, and it is best to leave the setting on, since most syslog implementations either cannot handle large messages or would need to be specially configured to handle them. But if syslog is ultimately writing into some other medium, it might be necessary or more useful to keep messages logically together.</source>
          <target state="translated">如果syslog最终是要记录到文本文件,那么无论哪种方式的效果都是一样的,最好是保持这个设置,因为大多数syslog实现要么不能处理大的消息,要么需要特别配置来处理它们。但如果syslog最终要写到其他介质中,那么可能有必要或更有用的是将消息按逻辑保持在一起。</target>
        </trans-unit>
        <trans-unit id="5afa6f87265a39e1ce0df6a7d2ec06e5f9b70a1e" translate="yes" xml:space="preserve">
          <source>If systemd is in use, some care must be taken that IPC resources (including shared memory) are not prematurely removed by the operating system. This is especially of concern when installing PostgreSQL from source. Users of distribution packages of PostgreSQL are less likely to be affected, as the &lt;code&gt;postgres&lt;/code&gt; user is then normally created as a system user.</source>
          <target state="translated">如果正在使用systemd，则必须注意操作系统不会过早删除IPC资源（包括共享内存）。从源代码安装PostgreSQL时，这尤其值得关注。PostgreSQL发行版软件包的用户受影响的可能性较小，因为通常 &lt;code&gt;postgres&lt;/code&gt; 用户创建为系统用户。</target>
        </trans-unit>
        <trans-unit id="0c9f61d1e280ce039975396a48eef3020a367753" translate="yes" xml:space="preserve">
          <source>If systemd is in use, some care must be taken that IPC resources (shared memory and semaphores) are not prematurely removed by the operating system. This is especially of concern when installing PostgreSQL from source. Users of distribution packages of PostgreSQL are less likely to be affected, as the &lt;code&gt;postgres&lt;/code&gt; user is then normally created as a system user.</source>
          <target state="translated">如果使用systemd，则必须注意操作系统不会过早删除IPC资源（共享内存和信号灯）。从源安装PostgreSQL时，这尤其值得关注。PostgreSQL发行版软件包的用户受影响的可能性较小，因为通常 &lt;code&gt;postgres&lt;/code&gt; 用户创建为系统用户。</target>
        </trans-unit>
        <trans-unit id="0cc78b460318c43d7e2a2ae058784201d032436a" translate="yes" xml:space="preserve">
          <source>If table is a partition (see &lt;code&gt;relispartition&lt;/code&gt;), internal representation of the partition bound</source>
          <target state="translated">如果table是一个分区（请参阅 &lt;code&gt;relispartition&lt;/code&gt; ），则该分区的内部表示形式</target>
        </trans-unit>
        <trans-unit id="2f2df2648f2943188802b9abf232f2ee4f995a24" translate="yes" xml:space="preserve">
          <source>If the &amp;ldquo;Access privileges&amp;rdquo; column is empty for a given object, it means the object has default privileges (that is, its privileges entry in the relevant system catalog is null). Default privileges always include all privileges for the owner, and can include some privileges for &lt;code&gt;PUBLIC&lt;/code&gt; depending on the object type, as explained above. The first &lt;code&gt;GRANT&lt;/code&gt; or &lt;code&gt;REVOKE&lt;/code&gt; on an object will instantiate the default privileges (producing, for example, &lt;code&gt;miriam=arwdDxt/miriam&lt;/code&gt;) and then modify them per the specified request. Similarly, entries are shown in &amp;ldquo;Column privileges&amp;rdquo; only for columns with nondefault privileges. (Note: for this purpose, &amp;ldquo;default privileges&amp;rdquo; always means the built-in default privileges for the object's type. An object whose privileges have been affected by an &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt; command will always be shown with an explicit privilege entry that includes the effects of the &lt;code&gt;ALTER&lt;/code&gt;.)</source>
          <target state="translated">如果给定对象的&amp;ldquo;访问权限&amp;rdquo;列为空，则表示该对象具有默认权限（即，其在相关系统目录中的权限条目为空）。如上所述，默认特权始终包含所有者的所有特权，并且可以包含 &lt;code&gt;PUBLIC&lt;/code&gt; 的某些特权，具体取决于对象类型，如上所述。对象上的第一个 &lt;code&gt;GRANT&lt;/code&gt; 或 &lt;code&gt;REVOKE&lt;/code&gt; 将实例化默认特权（例如， &lt;code&gt;miriam=arwdDxt/miriam&lt;/code&gt; ），然后根据指定的请求进行修改。同样，条目仅在具有非默认特权的列中显示在&amp;ldquo;列特权&amp;rdquo;中。（注意：为此，&amp;ldquo;默认特权&amp;rdquo;始终表示该对象类型的内置默认特权。其特权受 &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt; 命令影响的对象将始终显示带有包含效果的显式特权条目。的 &lt;code&gt;ALTER&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="ef8285ef018dbe08eadaac46ca6f457ffb7737a0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--check&lt;/code&gt; option was used, the old cluster was unmodified; it can be restarted.</source>
          <target state="translated">如果使用 &lt;code&gt;--check&lt;/code&gt; 选项，则旧集群未修改；它可以重新启动。</target>
        </trans-unit>
        <trans-unit id="5231ab37a455b02818813f84dceafd365dc3d243" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--link&lt;/code&gt; option was &lt;em&gt;not&lt;/em&gt; used, the old cluster was unmodified; it can be restarted.</source>
          <target state="translated">如果&lt;em&gt;未&lt;/em&gt;使用 &lt;code&gt;--link&lt;/code&gt; 选项，则旧集群未修改；它可以重新启动。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9eaa5641cd34b4f83c2c8d2f48ba3f445ae08243" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--link&lt;/code&gt; option was used, the data files might be shared between the old and new cluster:</source>
          <target state="translated">如果使用 &lt;code&gt;--link&lt;/code&gt; 选项，则数据文件可能在新旧群集之间共享：</target>
        </trans-unit>
        <trans-unit id="e5bb770bf0c6c53be90a08f4aadc13d0d045351b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;DELETE&lt;/code&gt; command contains a &lt;code&gt;RETURNING&lt;/code&gt; clause, the result will be similar to that of a &lt;code&gt;SELECT&lt;/code&gt; statement containing the columns and values defined in the &lt;code&gt;RETURNING&lt;/code&gt; list, computed over the row(s) deleted by the command.</source>
          <target state="translated">如果 &lt;code&gt;DELETE&lt;/code&gt; 命令包含 &lt;code&gt;RETURNING&lt;/code&gt; 子句，则结果将类似于 &lt;code&gt;SELECT&lt;/code&gt; 语句的结果，该SELECT语句包含 &lt;code&gt;RETURNING&lt;/code&gt; 列表中定义的列和值，这些值是在该命令删除的行上计算的。</target>
        </trans-unit>
        <trans-unit id="3edf0bee0b1a18174b6275c32dcc72778ff7f983" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;GROUP BY&lt;/code&gt; clause is specified, or if there are aggregate function calls, the output is combined into groups of rows that match on one or more values, and the results of aggregate functions are computed. If the &lt;code&gt;HAVING&lt;/code&gt; clause is present, it eliminates groups that do not satisfy the given condition. (See &lt;a href=&quot;sql-select#SQL-GROUPBY&quot;&gt;&lt;code&gt;GROUP BY&lt;/code&gt; Clause&lt;/a&gt; and &lt;a href=&quot;sql-select#SQL-HAVING&quot;&gt;&lt;code&gt;HAVING&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">如果指定了 &lt;code&gt;GROUP BY&lt;/code&gt; 子句，或者有聚合函数调用，则将输出组合成与一个或多个值匹配的行组，并计算聚合函数的结果。如果存在 &lt;code&gt;HAVING&lt;/code&gt; 子句，它将消除不满足给定条件的组。（请参阅下面的&lt;a href=&quot;sql-select#SQL-GROUPBY&quot;&gt; &lt;code&gt;GROUP BY&lt;/code&gt; 子句&lt;/a&gt;和&lt;a href=&quot;sql-select#SQL-HAVING&quot;&gt; &lt;code&gt;HAVING&lt;/code&gt; 子句&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="8cba5ea5fe4b174dd3b26b5824e3815a353de168" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;GROUP BY&lt;/code&gt; clause is specified, or if there are aggregate function calls, the output is combined into groups of rows that match on one or more values, and the results of aggregate functions are computed. If the &lt;code&gt;HAVING&lt;/code&gt; clause is present, it eliminates groups that do not satisfy the given condition. (See &lt;a href=&quot;sql-select#SQL-GROUPBY&quot;&gt;GROUP BY Clause&lt;/a&gt; and &lt;a href=&quot;sql-select#SQL-HAVING&quot;&gt;HAVING Clause&lt;/a&gt; below.)</source>
          <target state="translated">如果指定了 &lt;code&gt;GROUP BY&lt;/code&gt; 子句，或者存在聚合函数调用，则将输出组合为与一个或多个值匹配的行组，并计算聚合函数的结果。如果存在 &lt;code&gt;HAVING&lt;/code&gt; 子句，它将消除不满足给定条件的组。（请参阅下面的&lt;a href=&quot;sql-select#SQL-GROUPBY&quot;&gt;GROUP BY子句&lt;/a&gt;和&lt;a href=&quot;sql-select#SQL-HAVING&quot;&gt;HAVING子句&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="e73996306e544b116d96395fc6c635fa64541db1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;INSERT&lt;/code&gt; command contains a &lt;code&gt;RETURNING&lt;/code&gt; clause, the result will be similar to that of a &lt;code&gt;SELECT&lt;/code&gt; statement containing the columns and values defined in the &lt;code&gt;RETURNING&lt;/code&gt; list, computed over the row(s) inserted or updated by the command.</source>
          <target state="translated">如果 &lt;code&gt;INSERT&lt;/code&gt; 命令包含 &lt;code&gt;RETURNING&lt;/code&gt; 子句，则结果将类似于 &lt;code&gt;SELECT&lt;/code&gt; 语句的结果，该SELECT语句包含 &lt;code&gt;RETURNING&lt;/code&gt; 列表中定义的列和值，该列和值是在命令插入或更新的行上计算的。</target>
        </trans-unit>
        <trans-unit id="0cef0ec98d8f962ff98a56a4b6b305bd357183c5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;LIMIT&lt;/code&gt; (or &lt;code&gt;FETCH FIRST&lt;/code&gt;) or &lt;code&gt;OFFSET&lt;/code&gt; clause is specified, the &lt;code&gt;SELECT&lt;/code&gt; statement only returns a subset of the result rows. (See &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;&lt;code&gt;LIMIT&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">如果指定了 &lt;code&gt;LIMIT&lt;/code&gt; （或 &lt;code&gt;FETCH FIRST&lt;/code&gt; ）或 &lt;code&gt;OFFSET&lt;/code&gt; 子句，则 &lt;code&gt;SELECT&lt;/code&gt; 语句仅返回结果行的子集。（请参阅下面的&lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt; &lt;code&gt;LIMIT&lt;/code&gt; 条款&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="4a75230035fa0b522f04007a43794f1e0d2bb911" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;LIMIT&lt;/code&gt; (or &lt;code&gt;FETCH FIRST&lt;/code&gt;) or &lt;code&gt;OFFSET&lt;/code&gt; clause is specified, the &lt;code&gt;SELECT&lt;/code&gt; statement only returns a subset of the result rows. (See &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;LIMIT Clause&lt;/a&gt; below.)</source>
          <target state="translated">如果指定了 &lt;code&gt;LIMIT&lt;/code&gt; （或 &lt;code&gt;FETCH FIRST&lt;/code&gt; ）或 &lt;code&gt;OFFSET&lt;/code&gt; 子句，则 &lt;code&gt;SELECT&lt;/code&gt; 语句仅返回结果行的子集。（请参阅下面的&lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;LIMIT条款&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="72d3a656a8d2961c5ae7c07dee89a103497dda43" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ORDER BY&lt;/code&gt; clause is specified, the returned rows are sorted in the specified order. If &lt;code&gt;ORDER BY&lt;/code&gt; is not given, the rows are returned in whatever order the system finds fastest to produce. (See &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;&lt;code&gt;ORDER BY&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">如果指定了 &lt;code&gt;ORDER BY&lt;/code&gt; 子句，则返回的行将以指定的顺序排序。如果未给出 &lt;code&gt;ORDER BY&lt;/code&gt; ，则以系统认为最快的顺序返回行。（请参阅下面的&lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt; &lt;code&gt;ORDER BY&lt;/code&gt; 子句&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="d8ea2efbcef004128bc9ee33fa0b309eb98d431a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ORDER BY&lt;/code&gt; clause is specified, the returned rows are sorted in the specified order. If &lt;code&gt;ORDER BY&lt;/code&gt; is not given, the rows are returned in whatever order the system finds fastest to produce. (See &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;ORDER BY Clause&lt;/a&gt; below.)</source>
          <target state="translated">如果指定了 &lt;code&gt;ORDER BY&lt;/code&gt; 子句，则返回的行将以指定的顺序排序。如果未给出 &lt;code&gt;ORDER BY&lt;/code&gt; ，则以系统认为最快产生的顺序返回行。（请参阅下面的&lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;ORDER BY子句&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="fcc9caa8fd8396a40199c537204044cd80b03fd9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; command fails for any reason, it becomes a &lt;code&gt;ROLLBACK&lt;/code&gt;: the current transaction is canceled.</source>
          <target state="translated">如果 &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; 命令由于任何原因失败，它将变成 &lt;code&gt;ROLLBACK&lt;/code&gt; ：当前事务被取消。</target>
        </trans-unit>
        <trans-unit id="049a6b3315aa2fcc9292bf280d3fbac8f17f8faa" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;PREPARE&lt;/code&gt; statement that created the statement specified some parameters, a compatible set of parameters must be passed to the &lt;code&gt;EXECUTE&lt;/code&gt; statement, or else an error is raised. Note that (unlike functions) prepared statements are not overloaded based on the type or number of their parameters; the name of a prepared statement must be unique within a database session.</source>
          <target state="translated">如果创建该语句的 &lt;code&gt;PREPARE&lt;/code&gt; 语句指定了一些参数，则必须将一组兼容的参数传递给 &lt;code&gt;EXECUTE&lt;/code&gt; 语句，否则会引发错误。请注意（与函数不同），准备好的语句不会基于其参数的类型或数量而重载。在数据库会话中，准备好的语句的名称必须唯一。</target>
        </trans-unit>
        <trans-unit id="4e671e1df94a35c63462372f63dbaab316b08304" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;UPDATE&lt;/code&gt; command contains a &lt;code&gt;RETURNING&lt;/code&gt; clause, the result will be similar to that of a &lt;code&gt;SELECT&lt;/code&gt; statement containing the columns and values defined in the &lt;code&gt;RETURNING&lt;/code&gt; list, computed over the row(s) updated by the command.</source>
          <target state="translated">如果 &lt;code&gt;UPDATE&lt;/code&gt; 命令包含 &lt;code&gt;RETURNING&lt;/code&gt; 子句，则结果将类似于 &lt;code&gt;SELECT&lt;/code&gt; 语句的结果，该SELECT语句包含 &lt;code&gt;RETURNING&lt;/code&gt; 列表中定义的列和值，该列和值是在命令更新的行上计算的。</target>
        </trans-unit>
        <trans-unit id="e2d169320d1dac51b305dc4371af2fd872eb335a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;WHERE&lt;/code&gt; clause is specified, all rows that do not satisfy the condition are eliminated from the output. (See &lt;a href=&quot;sql-select#SQL-WHERE&quot;&gt;&lt;code&gt;WHERE&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">如果指定了 &lt;code&gt;WHERE&lt;/code&gt; 子句，将从输出中消除所有不满足该条件的行。（请参阅下面的&lt;a href=&quot;sql-select#SQL-WHERE&quot;&gt; &lt;code&gt;WHERE&lt;/code&gt; 子句&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="4af20d29d9d1228c78339d28ff758ffb08bbfc49" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;WHERE&lt;/code&gt; clause is specified, all rows that do not satisfy the condition are eliminated from the output. (See &lt;a href=&quot;sql-select#SQL-WHERE&quot;&gt;WHERE Clause&lt;/a&gt; below.)</source>
          <target state="translated">如果指定了 &lt;code&gt;WHERE&lt;/code&gt; 子句，则从输出中消除所有不满足该条件的行。（请参阅下面的&lt;a href=&quot;sql-select#SQL-WHERE&quot;&gt;WHERE子句&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="92b918e82e1dbdff8d47052fc332ee8551811a46" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;WITH ORDINALITY&lt;/code&gt; clause is specified, an additional column of type &lt;code&gt;bigint&lt;/code&gt; will be added to the function result columns. This column numbers the rows of the function result set, starting from 1. (This is a generalization of the SQL-standard syntax for &lt;code&gt;UNNEST ... WITH ORDINALITY&lt;/code&gt;.) By default, the ordinal column is called &lt;code&gt;ordinality&lt;/code&gt;, but a different column name can be assigned to it using an &lt;code&gt;AS&lt;/code&gt; clause.</source>
          <target state="translated">如果指定了 &lt;code&gt;WITH ORDINALITY&lt;/code&gt; 子句，则将 &lt;code&gt;bigint&lt;/code&gt; 类型的附加列添加到函数结果列中。该 &lt;code&gt;UNNEST ... WITH ORDINALITY&lt;/code&gt; 函数结果集的行编号，从1开始。（这是SQL标准语法的UNNEST ... WITH ORDINALITY的泛化。）默认情况下，该序数列称为 &lt;code&gt;ordinality&lt;/code&gt; ，但其列名称不同可以使用 &lt;code&gt;AS&lt;/code&gt; 子句分配给它。</target>
        </trans-unit>
        <trans-unit id="3a9a2b1e5b5de3befe9a4b97f742aa542e0145cb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;count&lt;/code&gt; expression evaluates to NULL, it is treated as &lt;code&gt;LIMIT ALL&lt;/code&gt;, i.e., no limit. If &lt;code&gt;start&lt;/code&gt; evaluates to NULL, it is treated the same as &lt;code&gt;OFFSET 0&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;count&lt;/code&gt; 表达式的计算结果为NULL，则将其视为 &lt;code&gt;LIMIT ALL&lt;/code&gt; ，即无限制。如果 &lt;code&gt;start&lt;/code&gt; 评估为NULL，则将其与 &lt;code&gt;OFFSET 0&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="b469c74a0f6fb197601cf70011bbae3b5c0a8cbf" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;dictionary&lt;/code&gt; argument is omitted, the text search dictionary named &lt;code&gt;unaccent&lt;/code&gt; and appearing in the same schema as the &lt;code&gt;unaccent()&lt;/code&gt; function itself is used.</source>
          <target state="translated">如果省略 &lt;code&gt;dictionary&lt;/code&gt; 参数，则使用名为 &lt;code&gt;unaccent&lt;/code&gt; 且与 &lt;code&gt;unaccent()&lt;/code&gt; 函数本身位于相同模式的文本搜索词典。</target>
        </trans-unit>
        <trans-unit id="8e92f2cba043fc31ab92cbc203c691c2c492c8d7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;expression&lt;/code&gt; is row-valued, then &lt;code&gt;IS NULL&lt;/code&gt; is true when the row expression itself is null or when all the row's fields are null, while &lt;code&gt;IS NOT NULL&lt;/code&gt; is true when the row expression itself is non-null and all the row's fields are non-null. Because of this behavior, &lt;code&gt;IS NULL&lt;/code&gt; and &lt;code&gt;IS NOT NULL&lt;/code&gt; do not always return inverse results for row-valued expressions; in particular, a row-valued expression that contains both null and non-null fields will return false for both tests. In some cases, it may be preferable to write &lt;code&gt;row&lt;/code&gt;&lt;code&gt;IS DISTINCT FROM NULL&lt;/code&gt; or &lt;code&gt;row&lt;/code&gt;&lt;code&gt;IS NOT DISTINCT FROM NULL&lt;/code&gt;, which will simply check whether the overall row value is null without any additional tests on the row fields.</source>
          <target state="translated">如果 &lt;code&gt;expression&lt;/code&gt; 是列值，则 &lt;code&gt;IS NULL&lt;/code&gt; 当行表达式本身为空或为真时，所有行的字段为空，而 &lt;code&gt;IS NOT NULL&lt;/code&gt; 是真当行表达式本身就是非空，所有该行的字段非空。由于这种行为， &lt;code&gt;IS NULL&lt;/code&gt; 和 &lt;code&gt;IS NOT NULL&lt;/code&gt; 并不总是返回行值表达式的反结果。特别是，同时包含null和non-null字段的行值表达式对于两个测试都将返回false。在某些情况下，最好将 &lt;code&gt;row&lt;/code&gt; &lt;code&gt;IS DISTINCT FROM NULL&lt;/code&gt; 或将 &lt;code&gt;row&lt;/code&gt; &lt;code&gt;IS NOT DISTINCT FROM NULL&lt;/code&gt; 写入，它将简单地检查总行值是否为null，而无需对行字段进行任何其他测试。</target>
        </trans-unit>
        <trans-unit id="8a9d5cf7323804505a12a8a728eb4b811573a010" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;system-username&lt;/code&gt; field starts with a slash (&lt;code&gt;/&lt;/code&gt;), the remainder of the field is treated as a regular expression. (See &lt;a href=&quot;functions-matching#POSIX-SYNTAX-DETAILS&quot;&gt;Section 9.7.3.1&lt;/a&gt; for details of PostgreSQL's regular expression syntax.) The regular expression can include a single capture, or parenthesized subexpression, which can then be referenced in the &lt;code&gt;database-username&lt;/code&gt; field as &lt;code&gt;\1&lt;/code&gt; (backslash-one). This allows the mapping of multiple user names in a single line, which is particularly useful for simple syntax substitutions. For example, these entries</source>
          <target state="translated">如果 &lt;code&gt;system-username&lt;/code&gt; 字段以斜杠（ &lt;code&gt;/&lt;/code&gt; ）开头，则该字段的其余部分将被视为正则表达式。（有关PostgreSQL正则表达式语法的详细信息，请参阅&lt;a href=&quot;functions-matching#POSIX-SYNTAX-DETAILS&quot;&gt;第9.7.3.1节&lt;/a&gt;。）正则表达式可以包含单个捕获或带括号的子表达式，然后可以在 &lt;code&gt;database-username&lt;/code&gt; 名字段中将其引用为 &lt;code&gt;\1&lt;/code&gt; （反斜杠&amp;ldquo;一&amp;rdquo;）。这允许在单个行中映射多个用户名，这对于简单的语法替换特别有用。例如，这些条目</target>
        </trans-unit>
        <trans-unit id="482a504d7c75e328098ffe22edcbb1378a3f6faa" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/em&gt; and &lt;em&gt;&lt;code&gt;values&lt;/code&gt;&lt;/em&gt; arrays are specified, an &lt;em&gt;armor header&lt;/em&gt; is added to the armored format for each key/value pair. Both arrays must be single-dimensional, and they must be of the same length. The keys and values cannot contain any non-ASCII characters.</source>
          <target state="translated">如果指定了&lt;em&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/em&gt;和&lt;em&gt; &lt;code&gt;values&lt;/code&gt; &lt;/em&gt;数组，则会为每个键/值对将&lt;em&gt;装甲标头&lt;/em&gt;添加到装甲格式。两个数组都必须是一维的，并且它们的长度必须相同。键和值不能包含任何非ASCII字符。</target>
        </trans-unit>
        <trans-unit id="7327537568cbffaa257fef6fbd8b81996eaef858" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;&lt;code&gt;silent&lt;/code&gt;&lt;/em&gt; argument is specified and has the &lt;code&gt;true&lt;/code&gt; value, these functions suppress the same errors as the &lt;code&gt;@?&lt;/code&gt; and &lt;code&gt;@@&lt;/code&gt; operators.</source>
          <target state="translated">如果指定了&lt;em&gt; &lt;code&gt;silent&lt;/code&gt; &lt;/em&gt;参数并具有 &lt;code&gt;true&lt;/code&gt; 值，则这些函数将抑制与 &lt;code&gt;@?&lt;/code&gt; 相同的错误。和 &lt;code&gt;@@&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="ceede46190dd53d528fe2b583d1ccadb6cf588b2" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;&lt;code&gt;vars&lt;/code&gt;&lt;/em&gt; argument is specified, it provides an object containing named variables to be substituted into a &lt;code&gt;jsonpath&lt;/code&gt; expression.</source>
          <target state="translated">如果指定了&lt;em&gt; &lt;code&gt;vars&lt;/code&gt; &lt;/em&gt;参数，它将提供一个对象，该对象包含要替换为 &lt;code&gt;jsonpath&lt;/code&gt; 表达式的命名变量。</target>
        </trans-unit>
        <trans-unit id="a173c623ff67d4c364c8db6dbe6ae6c5c5c1b9dd" translate="yes" xml:space="preserve">
          <source>If the S2K key is to be used directly, then only S2K settings will be put into the session key packet. Otherwise the session key will be encrypted with the S2K key and put into the session key packet.</source>
          <target state="translated">如果直接使用S2K密钥,则只将S2K设置放入会话密钥包中,否则将用S2K密钥加密并放入会话密钥包中。否则,会话密钥将用S2K密钥加密,并放入会话密钥包中。</target>
        </trans-unit>
        <trans-unit id="cd334923ca7f6a61f76d5cc9802fe6d4f79f8249" translate="yes" xml:space="preserve">
          <source>If the Serializable transaction isolation level is used for all writes and for all reads which need a consistent view of the data, no other effort is required to ensure consistency. Software from other environments which is written to use serializable transactions to ensure consistency should &amp;ldquo;just work&amp;rdquo; in this regard in PostgreSQL.</source>
          <target state="translated">如果将可序列化事务隔离级别用于需要数据视图一致的所有写入和所有读取，则无需进行其他工作即可确保一致性。在这方面，来自其他环境的软件被编写为使用可序列化的事务来确保一致性，这在PostgreSQL中应&amp;ldquo;正常工作&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="b3a85d8941e78b61fa6dfe5e13735d5c695c638d" translate="yes" xml:space="preserve">
          <source>If the argument begins with &lt;code&gt;|&lt;/code&gt;, then the entire remainder of the line is taken to be the &lt;code&gt;command&lt;/code&gt; to execute, and neither variable interpolation nor backquote expansion are performed in it. The rest of the line is simply passed literally to the shell.</source>
          <target state="translated">如果参数以 &lt;code&gt;|&lt;/code&gt; 开头 ，则将该行的其余部分作为要执行的 &lt;code&gt;command&lt;/code&gt; ，并且不执行变量插值或反引号扩展。该行的其余部分仅按字面意义传递给外壳。</target>
        </trans-unit>
        <trans-unit id="c120a5d678ef79b9fdd905518c659ce62747d5d3" translate="yes" xml:space="preserve">
          <source>If the argument to &lt;code&gt;json_strip_nulls&lt;/code&gt; contains duplicate field names in any object, the result could be semantically somewhat different, depending on the order in which they occur. This is not an issue for &lt;code&gt;jsonb_strip_nulls&lt;/code&gt; since &lt;code&gt;jsonb&lt;/code&gt; values never have duplicate object field names.</source>
          <target state="translated">如果 &lt;code&gt;json_strip_nulls&lt;/code&gt; 的参数在任何对象中都包含重复的字段名称，则结果在语义上可能会有所不同，这取决于它们出现的顺序。这对于 &lt;code&gt;jsonb_strip_nulls&lt;/code&gt; 来说不是问题，因为 &lt;code&gt;jsonb&lt;/code&gt; 值永远不会有重复的对象字段名称。</target>
        </trans-unit>
        <trans-unit id="da41d6b70ef3eb6374e923e599dfca0a856e8010" translate="yes" xml:space="preserve">
          <source>If the array expression yields a null array, the result of &lt;code&gt;ALL&lt;/code&gt; will be null. If the left-hand expression yields null, the result of &lt;code&gt;ALL&lt;/code&gt; is ordinarily null (though a non-strict comparison operator could possibly yield a different result). Also, if the right-hand array contains any null elements and no false comparison result is obtained, the result of &lt;code&gt;ALL&lt;/code&gt; will be null, not true (again, assuming a strict comparison operator). This is in accordance with SQL's normal rules for Boolean combinations of null values.</source>
          <target state="translated">如果数组表达式产生一个空数组，则 &lt;code&gt;ALL&lt;/code&gt; 的结果将为空。如果左侧表达式的结果为null，则 &lt;code&gt;ALL&lt;/code&gt; 的结果通常为null（尽管非严格比较运算符可能会得出不同的结果）。同样，如果右侧数组包含任何null元素，并且没有获得错误的比较结果，则 &lt;code&gt;ALL&lt;/code&gt; 的结果将为null，而不是true（同样，假设使用严格的比较运算符）。这符合SQL的空值布尔组合的常规规则。</target>
        </trans-unit>
        <trans-unit id="ae942e08ca17c439fb984995bab2b3f4a2ace54c" translate="yes" xml:space="preserve">
          <source>If the array expression yields a null array, the result of &lt;code&gt;ANY&lt;/code&gt; will be null. If the left-hand expression yields null, the result of &lt;code&gt;ANY&lt;/code&gt; is ordinarily null (though a non-strict comparison operator could possibly yield a different result). Also, if the right-hand array contains any null elements and no true comparison result is obtained, the result of &lt;code&gt;ANY&lt;/code&gt; will be null, not false (again, assuming a strict comparison operator). This is in accordance with SQL's normal rules for Boolean combinations of null values.</source>
          <target state="translated">如果数组表达式产生一个空数组，则 &lt;code&gt;ANY&lt;/code&gt; 的结果将为空。如果左侧表达式的结果为null，则 &lt;code&gt;ANY&lt;/code&gt; 的结果通常为null（尽管非严格比较运算符可能会得出不同的结果）。同样，如果右侧数组包含任何null元素，并且没有获得真实的比较结果，则 &lt;code&gt;ANY&lt;/code&gt; 的结果将为null，而不是false（同样，假设使用严格的比较运算符）。这符合SQL的空值布尔组合的常规规则。</target>
        </trans-unit>
        <trans-unit id="f33f8fbf54f510b9f47b6952f447521e0e216bb8" translate="yes" xml:space="preserve">
          <source>If the backup process monitors and ensures that all WAL segment files required for the backup are successfully archived then the &lt;code&gt;wait_for_archive&lt;/code&gt; parameter (which defaults to true) can be set to false to have &lt;code&gt;pg_stop_backup&lt;/code&gt; return as soon as the stop backup record is written to the WAL. By default, &lt;code&gt;pg_stop_backup&lt;/code&gt; will wait until all WAL has been archived, which can take some time. This option must be used with caution: if WAL archiving is not monitored correctly then the backup might not include all of the WAL files and will therefore be incomplete and not able to be restored.</source>
          <target state="translated">如果备份过程监视并确保成功备份所需的所有WAL段文件，则可以将 &lt;code&gt;wait_for_archive&lt;/code&gt; 参数（默认为true）设置为false，以在将停止备份记录写入WAL后 &lt;code&gt;pg_stop_backup&lt;/code&gt; 返回pg_stop_backup。。默认情况下， &lt;code&gt;pg_stop_backup&lt;/code&gt; 将等待，直到所有WAL被归档为止，这可能需要一些时间。必须谨慎使用此选项：如果未正确监视WAL归档，则备份可能不包括所有WAL文件，因此将不完整且无法还原。</target>
        </trans-unit>
        <trans-unit id="c791af34bd6ddf53748d0f35d1bff063098edcb5" translate="yes" xml:space="preserve">
          <source>If the backup was taken with file checksums enabled, the following keys will be present:</source>
          <target state="translated">如果备份是在启用文件校验和的情况下进行的,则会出现以下键。</target>
        </trans-unit>
        <trans-unit id="38dbd4a01a3f520d833ada1c842bc701e68bca1c" translate="yes" xml:space="preserve">
          <source>If the cast is marked &lt;code&gt;AS ASSIGNMENT&lt;/code&gt; then it can be invoked implicitly when assigning a value to a column of the target data type. For example, supposing that &lt;code&gt;foo.f1&lt;/code&gt; is a column of type &lt;code&gt;text&lt;/code&gt;, then:</source>
          <target state="translated">如果强制类型转换标记为 &lt;code&gt;AS ASSIGNMENT&lt;/code&gt; ,则在为目标数据类型的列分配值时可以隐式调用它。例如，假设 &lt;code&gt;foo.f1&lt;/code&gt; 是 &lt;code&gt;text&lt;/code&gt; 类型的列，则：</target>
        </trans-unit>
        <trans-unit id="a854dcb7d27eca4b3717769b2da567eec36f84ca" translate="yes" xml:space="preserve">
          <source>If the cast is marked &lt;code&gt;AS IMPLICIT&lt;/code&gt; then it can be invoked implicitly in any context, whether assignment or internally in an expression. (We generally use the term &lt;em&gt;implicit cast&lt;/em&gt; to describe this kind of cast.) For example, consider this query:</source>
          <target state="translated">如果 &lt;code&gt;AS IMPLICIT&lt;/code&gt; 标记为&amp;ldquo;隐含&amp;rdquo;，则可以在任何上下文中隐式调用它，无论是赋值还是内部表达式。（我们通常使用术语&lt;em&gt;隐式&lt;/em&gt;类型转换来描述这种类型的转换。）例如，考虑以下查询：</target>
        </trans-unit>
        <trans-unit id="61cd1b288599e699dce186b3244d616ce3ce9c86" translate="yes" xml:space="preserve">
          <source>If the catalog's &lt;code&gt;.h&lt;/code&gt; file specifies a default value for a column, and a data entry has that same value, &lt;code&gt;reformat_dat_file.pl&lt;/code&gt; will omit it from the data file. This keeps the data representation compact.</source>
          <target state="translated">如果目录的 &lt;code&gt;.h&lt;/code&gt; 文件为列指定了默认值，并且数据条目具有相同的值，则 &lt;code&gt;reformat_dat_file.pl&lt;/code&gt; 将在数据文件中将其忽略。这使数据表示紧凑。</target>
        </trans-unit>
        <trans-unit id="e457eb8bdc9731b8c1605b478c130085944e5e2a" translate="yes" xml:space="preserve">
          <source>If the client character set is defined as &lt;code&gt;SQL_ASCII&lt;/code&gt;, encoding conversion is disabled, regardless of the server's character set. (However, if the server's character set is not &lt;code&gt;SQL_ASCII&lt;/code&gt;, the server will still check that incoming data is valid for that encoding; so the net effect is as though the client character set were the same as the server's.) Just as for the server, use of &lt;code&gt;SQL_ASCII&lt;/code&gt; is unwise unless you are working with all-ASCII data.</source>
          <target state="translated">如果客户端字符集定义为 &lt;code&gt;SQL_ASCII&lt;/code&gt; ，则无论服务器的字符集如何，都将禁用编码转换。（但是，如果服务器的字符集不是 &lt;code&gt;SQL_ASCII&lt;/code&gt; ，则服务器仍将检查传入的数据对于该编码是否有效；因此，最终效果就好像客户端字符集与服务器的字符集相同。） ，除非您使用全ASCII数据，否则使用 &lt;code&gt;SQL_ASCII&lt;/code&gt; 是不明智的。</target>
        </trans-unit>
        <trans-unit id="bae7f3745b8c55d9daa52727f8674ef5381e42f5" translate="yes" xml:space="preserve">
          <source>If the client character set is defined as &lt;code&gt;SQL_ASCII&lt;/code&gt;, encoding conversion is disabled, regardless of the server's character set. Just as for the server, use of &lt;code&gt;SQL_ASCII&lt;/code&gt; is unwise unless you are working with all-ASCII data.</source>
          <target state="translated">如果客户端字符集定义为 &lt;code&gt;SQL_ASCII&lt;/code&gt; ，则无论服务器的字符集如何，都将禁用编码转换。与服务器一样，除非使用全ASCII数据，否则使用 &lt;code&gt;SQL_ASCII&lt;/code&gt; 是不明智的。</target>
        </trans-unit>
        <trans-unit id="0c4deed9a95ca57073b155e9cb8a0f5097708705" translate="yes" xml:space="preserve">
          <source>If the command is written as &lt;code&gt;ALTER FOREIGN TABLE IF EXISTS ...&lt;/code&gt; and the foreign table does not exist, no error is thrown. A notice is issued in this case.</source>
          <target state="translated">如果命令写为 &lt;code&gt;ALTER FOREIGN TABLE IF EXISTS ...&lt;/code&gt; 并且外部表不存在，则不会引发任何错误。在这种情况下发出通知。</target>
        </trans-unit>
        <trans-unit id="63d051a50066f7b8f700301bed696001489f1857" translate="yes" xml:space="preserve">
          <source>If the command returns a nonzero exit status then a warning log message will be written and the database will proceed to start up anyway. An exception is that if the command was terminated by a signal or an error by the shell (such as command not found), the database will not proceed with startup.</source>
          <target state="translated">如果命令返回一个非零的退出状态,那么将写入一个警告日志信息,数据库将继续启动。一个例外的情况是,如果命令被shell的信号或错误(如命令未找到)终止,数据库将不会继续启动。</target>
        </trans-unit>
        <trans-unit id="557bcc8e46db9e939ccd6eb079fcf5557fc3e866" translate="yes" xml:space="preserve">
          <source>If the command returns a nonzero exit status then a warning log message will be written. An exception is that if the command was terminated by a signal or an error by the shell (such as command not found), a fatal error will be raised.</source>
          <target state="translated">如果命令返回一个非零的退出状态,那么将写入一个警告日志信息。一个例外的情况是,如果命令被信号或shell的错误(如命令未找到)终止,将引发一个致命的错误。</target>
        </trans-unit>
        <trans-unit id="6a74eec2662a9cc1d1ed60748980c12a4bf53d33" translate="yes" xml:space="preserve">
          <source>If the commands themselves contain &lt;code&gt;BEGIN&lt;/code&gt;, &lt;code&gt;COMMIT&lt;/code&gt;, or &lt;code&gt;ROLLBACK&lt;/code&gt;, this option will not have the desired effects. Also, if an individual command cannot be executed inside a transaction block, specifying this option will cause the whole transaction to fail.</source>
          <target state="translated">如果命令本身包含 &lt;code&gt;BEGIN&lt;/code&gt; ， &lt;code&gt;COMMIT&lt;/code&gt; 或 &lt;code&gt;ROLLBACK&lt;/code&gt; ，则此选项将不会产生期望的效果。同样，如果不能在事务块内执行单个命令，则指定此选项将导致整个事务失败。</target>
        </trans-unit>
        <trans-unit id="02b4ea2a996ab5d0d7b4386241306a8c9bd92e8f" translate="yes" xml:space="preserve">
          <source>If the compared values are of a collatable data type, the appropriate collation OID will be passed to the comparison support function, using the standard &lt;code&gt;PG_GET_COLLATION()&lt;/code&gt; mechanism.</source>
          <target state="translated">如果比较的值是可归类的数据类型，则将使用标准 &lt;code&gt;PG_GET_COLLATION()&lt;/code&gt; 机制将适当的归类OID传递给比较支持功能。</target>
        </trans-unit>
        <trans-unit id="29c5e362afd4a1ac0e7c03190fce4c0374d970bb" translate="yes" xml:space="preserve">
          <source>If the compress method is lossy for leaf entries, the operator class cannot support index-only scans, and must not define a &lt;code&gt;fetch&lt;/code&gt; function.</source>
          <target state="translated">如果compress方法对于叶条目是有损的，则操作符类不能支持仅索引扫描，并且不能定义 &lt;code&gt;fetch&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="f7447741114d4403590357da345ba571953f8d76" translate="yes" xml:space="preserve">
          <source>If the configuration file contains syntax errors or invalid parameter names, the server will not attempt to apply any settings from it, and therefore all the &lt;code&gt;applied&lt;/code&gt; fields will read as false. In such a case there will be one or more rows with non-null &lt;code&gt;error&lt;/code&gt; fields indicating the problem(s). Otherwise, individual settings will be applied if possible. If an individual setting cannot be applied (e.g., invalid value, or the setting cannot be changed after server start) it will have an appropriate message in the &lt;code&gt;error&lt;/code&gt; field. Another way that an entry might have &lt;code&gt;applied&lt;/code&gt; = false is that it is overridden by a later entry for the same parameter name; this case is not considered an error so nothing appears in the &lt;code&gt;error&lt;/code&gt; field.</source>
          <target state="translated">如果配置文件包含语法错误或无效的参数名称，则服务器将不会尝试应用配置文件中的任何设置，因此所有 &lt;code&gt;applied&lt;/code&gt; 字段都将读为false。在这种情况下，将存在一个或多个带有非空 &lt;code&gt;error&lt;/code&gt; 字段的行，这些错误字段指示问题。否则，将尽可能应用个别设置。如果无法应用单个设置（例如，无效值，或者服务器启动后无法更改设置），则它将在 &lt;code&gt;error&lt;/code&gt; 字段中显示一条适当的消息。条目可能 &lt;code&gt;applied&lt;/code&gt; = false的另一种方式是，对于相同的参数名称，以后的条目会覆盖它；所以没有出现在这种情况下，不被视为一个错误 &lt;code&gt;error&lt;/code&gt; 领域。</target>
        </trans-unit>
        <trans-unit id="6846426f89420f86ff7e1053a00d20ad214d1c83" translate="yes" xml:space="preserve">
          <source>If the configuration parameter &lt;a href=&quot;runtime-config-compatible#GUC-STANDARD-CONFORMING-STRINGS&quot;&gt;standard_conforming_strings&lt;/a&gt; is &lt;code&gt;off&lt;/code&gt;, then PostgreSQL recognizes backslash escapes in both regular and escape string constants. However, as of PostgreSQL 9.1, the default is &lt;code&gt;on&lt;/code&gt;, meaning that backslash escapes are recognized only in escape string constants. This behavior is more standards-compliant, but might break applications which rely on the historical behavior, where backslash escapes were always recognized. As a workaround, you can set this parameter to &lt;code&gt;off&lt;/code&gt;, but it is better to migrate away from using backslash escapes. If you need to use a backslash escape to represent a special character, write the string constant with an &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">如果配置参数&lt;a href=&quot;runtime-config-compatible#GUC-STANDARD-CONFORMING-STRINGS&quot;&gt;standard_conforming_strings&lt;/a&gt;为 &lt;code&gt;off&lt;/code&gt; ，则PostgreSQL会在常规和转义字符串常量中识别反斜杠转义。但是，从PostgreSQL 9.1开始，默认值为 &lt;code&gt;on&lt;/code&gt; ，这意味着仅在转义字符串常量中识别反斜杠转义。此行为更符合标准，但是可能会破坏依赖历史行为的应用程序，在该行为中始终会识别出反斜杠转义符。解决方法是，可以将此参数设置为 &lt;code&gt;off&lt;/code&gt; ，但最好不要使用反斜杠转义符。如果您需要使用反斜杠转义符来表示特殊字符，请使用 &lt;code&gt;E&lt;/code&gt; 编写字符串常量。</target>
        </trans-unit>
        <trans-unit id="7e2bc2b10438374418a16365e82e01c5a0e70ba5" translate="yes" xml:space="preserve">
          <source>If the connection could not be made for any reason (e.g., insufficient privileges, server is not running on the targeted host, etc.), psql will return an error and terminate.</source>
          <target state="translated">如果由于任何原因(如权限不足、服务器不在目标主机上运行等)无法建立连接,psql将返回一个错误并终止。</target>
        </trans-unit>
        <trans-unit id="02930b22f9d6ca1f7733ab529d9a22a91b3fe5c0" translate="yes" xml:space="preserve">
          <source>If the connection is lost, or if it cannot be initially established, with a non-fatal error, pg_receivewal will retry the connection indefinitely, and reestablish streaming as soon as possible. To avoid this behavior, use the &lt;code&gt;-n&lt;/code&gt; parameter.</source>
          <target state="translated">如果连接丢失或无法通过非致命错误初始建立，则pg_receivewal将无限期重试连接，并尽快重新建立流。若要避免此行为，请使用 &lt;code&gt;-n&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="1e7cb7e5b7e9cfa96c974efa30e7317e321f657f" translate="yes" xml:space="preserve">
          <source>If the conversion of a particular character is not possible &amp;mdash; suppose you chose &lt;code&gt;EUC_JP&lt;/code&gt; for the server and &lt;code&gt;LATIN1&lt;/code&gt; for the client, and some Japanese characters are returned that do not have a representation in &lt;code&gt;LATIN1&lt;/code&gt; &amp;mdash; an error is reported.</source>
          <target state="translated">如果无法转换特定字符（假设您为服务器选择了 &lt;code&gt;EUC_JP&lt;/code&gt; ，为客户端选择了 &lt;code&gt;LATIN1&lt;/code&gt; ，并且返回了一些在 &lt;code&gt;LATIN1&lt;/code&gt; 中没有表示形式的日语字符），则会报告错误。</target>
        </trans-unit>
        <trans-unit id="5a6f84dd517ea12fd77c796a6737968d24f658ee" translate="yes" xml:space="preserve">
          <source>If the current query buffer is empty, the most recently sent query is described instead.</source>
          <target state="translated">如果当前查询缓冲区为空,则描述最近发送的查询。</target>
        </trans-unit>
        <trans-unit id="2c57feb4352b9d0e5fa18cf7867721a0200da9c9" translate="yes" xml:space="preserve">
          <source>If the current query buffer is empty, the most recently sent query is re-executed instead.</source>
          <target state="translated">如果当前的查询缓冲区为空,则会重新执行最近发送的查询。</target>
        </trans-unit>
        <trans-unit id="b8dce5eee9d2655efdc5121439aeb8029c6a8bb6" translate="yes" xml:space="preserve">
          <source>If the current query buffer is empty, the most recently sent query is re-executed instead. Except for that behavior, &lt;code&gt;\g&lt;/code&gt; without an argument is essentially equivalent to a semicolon. A &lt;code&gt;\g&lt;/code&gt; with argument is a &amp;ldquo;one-shot&amp;rdquo; alternative to the &lt;code&gt;\o&lt;/code&gt; command.</source>
          <target state="translated">如果当前查询缓冲区为空，则重新执行最近发送的查询。除此行为外，不带参数的 &lt;code&gt;\g&lt;/code&gt; 本质上等效于分号。带参数的 &lt;code&gt;\g&lt;/code&gt; 是 &lt;code&gt;\o&lt;/code&gt; 命令的&amp;ldquo;一次性&amp;rdquo;替代。</target>
        </trans-unit>
        <trans-unit id="8f856d88c69c6abc126b1520b07a26de33c6da81" translate="yes" xml:space="preserve">
          <source>If the current query buffer is empty, the most recently sent query is re-executed instead. Except for that behavior, &lt;code&gt;\g&lt;/code&gt; without any arguments is essentially equivalent to a semicolon. With arguments, &lt;code&gt;\g&lt;/code&gt; provides a &amp;ldquo;one-shot&amp;rdquo; alternative to the &lt;code&gt;\o&lt;/code&gt; command, and additionally allows one-shot adjustments of the output formatting options normally set by &lt;code&gt;\pset&lt;/code&gt;.</source>
          <target state="translated">如果当前查询缓冲区为空，则重新执行最近发送的查询。除此行为外，不带任何参数的 &lt;code&gt;\g&lt;/code&gt; 本质上等效于分号。使用参数， &lt;code&gt;\g&lt;/code&gt; 提供了 &lt;code&gt;\o&lt;/code&gt; 命令的&amp;ldquo;一次性&amp;rdquo;替代，并且还允许一次性调整通常由 &lt;code&gt;\pset&lt;/code&gt; 设置的输出格式选项。</target>
        </trans-unit>
        <trans-unit id="9c1be77262ade382bd3daec36a4b4f5dfa260c3f" translate="yes" xml:space="preserve">
          <source>If the current table output format is unaligned, it is switched to aligned. If it is not unaligned, it is set to unaligned. This command is kept for backwards compatibility. See &lt;code&gt;\pset&lt;/code&gt; for a more general solution.</source>
          <target state="translated">如果当前表的输出格式未对齐，则将其切换为对齐。如果未对齐，则将其设置为未对齐。保留此命令是为了向后兼容。有关更一般的解决方案，请参见 &lt;code&gt;\pset&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6fb10bfb27f2916d0fe2c64c42424fe0e7351c4" translate="yes" xml:space="preserve">
          <source>If the cursor's query includes &lt;code&gt;FOR UPDATE&lt;/code&gt; or &lt;code&gt;FOR SHARE&lt;/code&gt;, then returned rows are locked at the time they are first fetched, in the same way as for a regular &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; command with these options. In addition, the returned rows will be the most up-to-date versions; therefore these options provide the equivalent of what the SQL standard calls a &amp;ldquo;sensitive cursor&amp;rdquo;. (Specifying &lt;code&gt;INSENSITIVE&lt;/code&gt; together with &lt;code&gt;FOR UPDATE&lt;/code&gt; or &lt;code&gt;FOR SHARE&lt;/code&gt; is an error.)</source>
          <target state="translated">如果游标的查询包含 &lt;code&gt;FOR UPDATE&lt;/code&gt; 或 &lt;code&gt;FOR SHARE&lt;/code&gt; ，则返回的行在首次获取时将被锁定，其方式与带有这些选项的常规&lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;命令相同。另外，返回的行将是最新版本；因此，这些选项提供了与SQL标准所谓的&amp;ldquo;敏感游标&amp;rdquo;等效的功能。 （将 &lt;code&gt;INSENSITIVE&lt;/code&gt; 与 &lt;code&gt;FOR UPDATE&lt;/code&gt; 或 &lt;code&gt;FOR SHARE&lt;/code&gt; 一起指定是一个错误。）</target>
        </trans-unit>
        <trans-unit id="41b7137b15f53bed5b5687626dcf24e407280bf1" translate="yes" xml:space="preserve">
          <source>If the data directory allows group read access then certificate files may need to be located outside of the data directory in order to conform to the security requirements outlined above. Generally, group access is enabled to allow an unprivileged user to backup the database, and in that case the backup software will not be able to read the certificate files and will likely error.</source>
          <target state="translated">如果数据目录允许组读取访问,那么证书文件可能需要位于数据目录之外,以符合上述的安全要求。一般情况下,启用组访问权限是为了允许无权用户备份数据库,在这种情况下,备份软件将无法读取证书文件,很可能出现错误。</target>
        </trans-unit>
        <trans-unit id="a675fdbbcb3f3826a4060560a5255875fb5f5fae" translate="yes" xml:space="preserve">
          <source>If the database crashes during the risk window between an asynchronous commit and the writing of the transaction's WAL records, then changes made during that transaction &lt;em&gt;will&lt;/em&gt; be lost. The duration of the risk window is limited because a background process (the &amp;ldquo;WAL writer&amp;rdquo;) flushes unwritten WAL records to disk every &lt;a href=&quot;runtime-config-wal#GUC-WAL-WRITER-DELAY&quot;&gt;wal_writer_delay&lt;/a&gt; milliseconds. The actual maximum duration of the risk window is three times &lt;code&gt;wal_writer_delay&lt;/code&gt; because the WAL writer is designed to favor writing whole pages at a time during busy periods.</source>
          <target state="translated">如果数据库在异步提交和写入事务的WAL记录之间的风险窗口期间崩溃，则在该事务期间所做的更改&lt;em&gt;将&lt;/em&gt;丢失。由于后台进程（&amp;ldquo; WAL &lt;a href=&quot;runtime-config-wal#GUC-WAL-WRITER-DELAY&quot;&gt;编写器&lt;/a&gt; &amp;rdquo;）每隔wal_writer_delay毫秒将未写入的WAL记录刷新到磁盘上，因此风险窗口的持续时间受到限制。风险窗口的实际最大持续时间是 &lt;code&gt;wal_writer_delay&lt;/code&gt; 的三倍,因为WAL编写器被设计为在繁忙时段一次编写整个页面。</target>
        </trans-unit>
        <trans-unit id="74cf7d60a58d8b38555b75db3e52ebabab25c716" translate="yes" xml:space="preserve">
          <source>If the distance function returns &lt;code&gt;*recheck = true&lt;/code&gt; for any leaf node, the original ordering operator's return type must be &lt;code&gt;float8&lt;/code&gt; or &lt;code&gt;float4&lt;/code&gt;, and the distance function's result values must be comparable to those of the original ordering operator, since the executor will sort using both distance function results and recalculated ordering-operator results. Otherwise, the distance function's result values can be any finite &lt;code&gt;float8&lt;/code&gt; values, so long as the relative order of the result values matches the order returned by the ordering operator. (Infinity and minus infinity are used internally to handle cases such as nulls, so it is not recommended that &lt;code&gt;distance&lt;/code&gt; functions return these values.)</source>
          <target state="translated">如果距离函数对任何叶节点返回 &lt;code&gt;*recheck = true&lt;/code&gt; ，则原始排序运算符的返回类型必须为 &lt;code&gt;float8&lt;/code&gt; 或 &lt;code&gt;float4&lt;/code&gt; ，并且距离函数的结果值必须与原始排序运算符的结果值相当，因为执行程序将使用两者进行排序距离函数结果和重新计算的订购经营者结果。否则，距离函数的结果值可以是任何有限的 &lt;code&gt;float8&lt;/code&gt; 值，只要结果值的相对顺序与排序运算符返回的顺序匹配即可。 （内部使用无穷大和负无穷大来处理诸如空值之类的情况，因此不建议 &lt;code&gt;distance&lt;/code&gt; 函数返回这些值。）</target>
        </trans-unit>
        <trans-unit id="ad60be7600e8f04e894b95d59df12f985784fcd2" translate="yes" xml:space="preserve">
          <source>If the expression for any column is not of the correct data type, automatic type conversion will be attempted.</source>
          <target state="translated">如果任何列的表达式不属于正确的数据类型,将尝试自动转换类型。</target>
        </trans-unit>
        <trans-unit id="fd093b6fb186aee51925fae308b6305eb633a2c9" translate="yes" xml:space="preserve">
          <source>If the extension specifies a &lt;code&gt;schema&lt;/code&gt; parameter in its control file, then that schema cannot be overridden with a &lt;code&gt;SCHEMA&lt;/code&gt; clause. Normally, an error will be raised if a &lt;code&gt;SCHEMA&lt;/code&gt; clause is given and it conflicts with the extension's &lt;code&gt;schema&lt;/code&gt; parameter. However, if the &lt;code&gt;CASCADE&lt;/code&gt; clause is also given, then &lt;code&gt;schema_name&lt;/code&gt; is ignored when it conflicts. The given &lt;code&gt;schema_name&lt;/code&gt; will be used for installation of any needed extensions that do not specify &lt;code&gt;schema&lt;/code&gt; in their control files.</source>
          <target state="translated">如果扩展名在其控制文件中指定了 &lt;code&gt;schema&lt;/code&gt; 参数，则无法使用 &lt;code&gt;SCHEMA&lt;/code&gt; 子句覆盖该架构。通常，如果给定了 &lt;code&gt;SCHEMA&lt;/code&gt; 子句，则该错误将与扩展的 &lt;code&gt;schema&lt;/code&gt; 参数冲突。但是，如果还提供了 &lt;code&gt;CASCADE&lt;/code&gt; 子句，则 &lt;code&gt;schema_name&lt;/code&gt; 冲突时将被忽略。给定的 &lt;code&gt;schema_name&lt;/code&gt; 将用于安装任何未在其控制文件中指定 &lt;code&gt;schema&lt;/code&gt; 所需扩展。</target>
        </trans-unit>
        <trans-unit id="a4e9fcc86b43f21a64730501e9eaf321852f905e" translate="yes" xml:space="preserve">
          <source>If the file name is not an absolute path, it is taken as relative to the directory containing the referencing configuration file. Inclusions can be nested.</source>
          <target state="translated">如果文件名不是绝对路径,则取相对于包含引用配置文件的目录。内含物可以是嵌套的。</target>
        </trans-unit>
        <trans-unit id="932910bcbd5980a518e91a591612aedc56d65e69" translate="yes" xml:space="preserve">
          <source>If the final function is declared &amp;ldquo;strict&amp;rdquo;, then it will not be called when the ending state value is null; instead a null result will be returned automatically. (Of course this is just the normal behavior of strict functions.) In any case the final function has the option of returning a null value. For example, the final function for &lt;code&gt;avg&lt;/code&gt; returns null when it sees there were zero input rows.</source>
          <target state="translated">如果将最终函数声明为&amp;ldquo;严格&amp;rdquo;，则当结束状态值为null时将不会调用该函数；而是将自动返回空结果。（当然，这只是严格函数的正常行为。）在任何情况下，最终函数都可以选择返回空值。例如， &lt;code&gt;avg&lt;/code&gt; 的最终函数在看到输入行为零时返回null。</target>
        </trans-unit>
        <trans-unit id="8ca5420e4e4f7f8c6273c3bc64bbb9997a4e67c8" translate="yes" xml:space="preserve">
          <source>If the first argument is an unquoted &lt;code&gt;-n&lt;/code&gt; the trailing newline is not written (nor is the first argument).</source>
          <target state="translated">如果第一个参数是未加引号的 &lt;code&gt;-n&lt;/code&gt; ，则不写结尾的换行符（第一个参数也不是）。</target>
        </trans-unit>
        <trans-unit id="6a7650c2a7562a29717aee3a080c7db1eba72918" translate="yes" xml:space="preserve">
          <source>If the first argument is an unquoted &lt;code&gt;-n&lt;/code&gt; the trailing newline is not written.</source>
          <target state="translated">如果第一个参数是不带引号的 &lt;code&gt;-n&lt;/code&gt; ，则不写结尾的换行符。</target>
        </trans-unit>
        <trans-unit id="62fe782183ded831fa81846fd49b8967105614ff" translate="yes" xml:space="preserve">
          <source>If the function has been defined as returning the &lt;code&gt;record&lt;/code&gt; data type, then an alias or the key word &lt;code&gt;AS&lt;/code&gt; must be present, followed by a column definition list in the form &lt;code&gt;( column_name data_type [, ... ])&lt;/code&gt;. The column definition list must match the actual number and types of columns returned by the function.</source>
          <target state="translated">如果已将函数定义为返回 &lt;code&gt;record&lt;/code&gt; 数据类型，则必须存在别名或关键字 &lt;code&gt;AS&lt;/code&gt; ，然后是形式为 &lt;code&gt;( column_name data_type [, ... ])&lt;/code&gt; 的列定义列表。列定义列表必须匹配该函数返回的实际列数和类型。</target>
        </trans-unit>
        <trans-unit id="dbc510e12f6154bfb8e0fdb71a70e5f4d7892b1d" translate="yes" xml:space="preserve">
          <source>If the function name is unique in its schema, it can be referred to without an argument list:</source>
          <target state="translated">如果函数名在其模式中是唯一的,那么它可以被引用而不需要参数列表。</target>
        </trans-unit>
        <trans-unit id="02e65f28de3d6ebb00042e2e3e922f9485dd13f2" translate="yes" xml:space="preserve">
          <source>If the index AM wishes to cache data across successive index insertions within a SQL statement, it can allocate space in &lt;code&gt;indexInfo-&amp;gt;ii_Context&lt;/code&gt; and store a pointer to the data in &lt;code&gt;indexInfo-&amp;gt;ii_AmCache&lt;/code&gt; (which will be NULL initially).</source>
          <target state="translated">如果索引AM希望在SQL语句内的连续索引插入之间缓存数据，则可以在 &lt;code&gt;indexInfo-&amp;gt;ii_Context&lt;/code&gt; 中分配空间，并将指向数据的指针存储在 &lt;code&gt;indexInfo-&amp;gt;ii_AmCache&lt;/code&gt; 中（最初将为NULL）。</target>
        </trans-unit>
        <trans-unit id="152cfa54f1f6aaa3c6f3e246889a7fbd92291904" translate="yes" xml:space="preserve">
          <source>If the index marked &lt;code&gt;INVALID&lt;/code&gt; is suffixed &lt;code&gt;ccnew&lt;/code&gt;, then it corresponds to the transient index created during the concurrent operation, and the recommended recovery method is to drop it using &lt;code&gt;DROP INDEX&lt;/code&gt;, then attempt &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt; again. If the invalid index is instead suffixed &lt;code&gt;ccold&lt;/code&gt;, it corresponds to the original index which could not be dropped; the recommended recovery method is to just drop said index, since the rebuild proper has been successful.</source>
          <target state="translated">如果标记为 &lt;code&gt;INVALID&lt;/code&gt; 的索引后缀为 &lt;code&gt;ccnew&lt;/code&gt; ，则它对应于在并发操作期间创建的瞬态索引，建议的恢复方法是使用 &lt;code&gt;DROP INDEX&lt;/code&gt; 删除该索引，然后再次尝试 &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt; 。如果无效索引改为后缀 &lt;code&gt;ccold&lt;/code&gt; ，则它对应于无法删除的原始索引；推荐的恢复方法是删除该索引，因为适当的重建已成功。</target>
        </trans-unit>
        <trans-unit id="65ff53fe7f3af3df2bf9787931d50cb513ad0685" translate="yes" xml:space="preserve">
          <source>If the index stores the original indexed data values (and not some lossy representation of them), it is useful to support &lt;a href=&quot;indexes-index-only-scans&quot;&gt;index-only scans&lt;/a&gt;, in which the index returns the actual data not just the TID of the heap tuple. This will only avoid I/O if the visibility map shows that the TID is on an all-visible page; else the heap tuple must be visited anyway to check MVCC visibility. But that is no concern of the access method's.</source>
          <target state="translated">如果索引存储原始索引数据值（而不是它们的某些有损表示），则支持&lt;a href=&quot;indexes-index-only-scans&quot;&gt;仅索引扫描&lt;/a&gt;非常有用，在索引扫描中，索引不仅返回堆元组的TID，而且还返回实际数据。仅当可见性图显示TID在全可见页面上时，才可以避免I / O；否则，无论如何必须访问堆元组以检查MVCC可见性。但这与访问方法无关。</target>
        </trans-unit>
        <trans-unit id="b10149280f25e55a72b1c339ba61c4a0b943ec93" translate="yes" xml:space="preserve">
          <source>If the index supports &lt;a href=&quot;indexes-index-only-scans&quot;&gt;index-only scans&lt;/a&gt; (i.e., &lt;code&gt;amcanreturn&lt;/code&gt; returns true for it), then on success the AM must also check &lt;code&gt;scan-&amp;gt;xs_want_itup&lt;/code&gt;, and if that is true it must return the originally indexed data for the index entry. The data can be returned in the form of an &lt;code&gt;IndexTuple&lt;/code&gt; pointer stored at &lt;code&gt;scan-&amp;gt;xs_itup&lt;/code&gt;, with tuple descriptor &lt;code&gt;scan-&amp;gt;xs_itupdesc&lt;/code&gt;; or in the form of a &lt;code&gt;HeapTuple&lt;/code&gt; pointer stored at &lt;code&gt;scan-&amp;gt;xs_hitup&lt;/code&gt;, with tuple descriptor &lt;code&gt;scan-&amp;gt;xs_hitupdesc&lt;/code&gt;. (The latter format should be used when reconstructing data that might possibly not fit into an &lt;code&gt;IndexTuple&lt;/code&gt;.) In either case, management of the data referenced by the pointer is the access method's responsibility. The data must remain good at least until the next &lt;code&gt;amgettuple&lt;/code&gt;, &lt;code&gt;amrescan&lt;/code&gt;, or &lt;code&gt;amendscan&lt;/code&gt; call for the scan.</source>
          <target state="translated">如果索引支持&lt;a href=&quot;indexes-index-only-scans&quot;&gt;仅索引扫描&lt;/a&gt;（即 &lt;code&gt;amcanreturn&lt;/code&gt; 为其返回true），则成功后AM还必须检查 &lt;code&gt;scan-&amp;gt;xs_want_itup&lt;/code&gt; ，如果是，则它必须返回索引条目的原始索引数据。数据可以以 &lt;code&gt;IndexTuple&lt;/code&gt; 指针的形式返回，该指针存储在 &lt;code&gt;scan-&amp;gt;xs_itup&lt;/code&gt; 中，并具有元组描述符 &lt;code&gt;scan-&amp;gt;xs_itupdesc&lt;/code&gt; ;或采用存储在 &lt;code&gt;scan-&amp;gt;xs_hitup&lt;/code&gt; 中的 &lt;code&gt;HeapTuple&lt;/code&gt; 指针的形式，以及元组描述符 &lt;code&gt;scan-&amp;gt;xs_hitupdesc&lt;/code&gt; 。 （在重建可能不适合 &lt;code&gt;IndexTuple&lt;/code&gt; 的数据时，应使用后一种格式。）在任何一种情况下，指针所引用的数据的管理都是访问方法的责任。数据至少在下一个 &lt;code&gt;amgettuple&lt;/code&gt; ， &lt;code&gt;amrescan&lt;/code&gt; 或 &lt;code&gt;amendscan&lt;/code&gt; 调用之前必须保持良好状态。</target>
        </trans-unit>
        <trans-unit id="5e5145a56a8fb3d00823c8f07c0c1ff1ea7857b4" translate="yes" xml:space="preserve">
          <source>If the indexed column is of a collatable data type, the index collation will be passed to all the support methods, using the standard &lt;code&gt;PG_GET_COLLATION()&lt;/code&gt; mechanism.</source>
          <target state="translated">如果索引列是可排序数据类型，则将使用标准 &lt;code&gt;PG_GET_COLLATION()&lt;/code&gt; 机制将索引排序规则传递给所有支持方法。</target>
        </trans-unit>
        <trans-unit id="7d0af38ac011e98a3b87862ced9f4ed1d8303136" translate="yes" xml:space="preserve">
          <source>If the installation process completes without error, you can now start the server normally.</source>
          <target state="translated">如果安装过程顺利完成,现在可以正常启动服务器了。</target>
        </trans-unit>
        <trans-unit id="801fad259abb36ce1c379ee710b758c893dc848e" translate="yes" xml:space="preserve">
          <source>If the internal structure of &lt;code&gt;box&lt;/code&gt; were an array of four &lt;code&gt;float4&lt;/code&gt; elements, we might instead use:</source>
          <target state="translated">如果 &lt;code&gt;box&lt;/code&gt; 的内部结构是四个 &lt;code&gt;float4&lt;/code&gt; 元素的数组，则可以改用：</target>
        </trans-unit>
        <trans-unit id="e0cb06bd991e3803ab381ac962733573ec921a97" translate="yes" xml:space="preserve">
          <source>If the isolation level, read/write mode, or deferrable mode is specified, the new transaction has those characteristics, as if &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt; was executed.</source>
          <target state="translated">如果指定了隔离级别，读/写模式或可延迟模式，则新事务具有那些特征，就像执行&lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION一样&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="635140eb0238daad7904445c051be894be230f98" translate="yes" xml:space="preserve">
          <source>If the item to retrieve is an element of an array, you have to unnest this array using the &lt;code&gt;[*]&lt;/code&gt; operator. For example, the following path will return location coordinates for all the available track segments:</source>
          <target state="translated">如果要检索的项目是数组的元素，则必须使用 &lt;code&gt;[*]&lt;/code&gt; 运算符取消嵌套该数组。例如，以下路径将返回所有可用轨道段的位置坐标：</target>
        </trans-unit>
        <trans-unit id="97c86aa6976c29ec1d54566b16ef172364cf2f75" translate="yes" xml:space="preserve">
          <source>If the key is larger than the hash block size it will first be hashed and the result will be used as key.</source>
          <target state="translated">如果密钥大于哈希块大小,将首先进行哈希,并将结果作为密钥。</target>
        </trans-unit>
        <trans-unit id="1aa8d866b0b556edb093be4c9a0ab389395324da" translate="yes" xml:space="preserve">
          <source>If the last path item is an object key, it will be created if it is absent and given the new value. If the last path item is an array index, if it is positive the item to set is found by counting from the left, and if negative by counting from the right - &lt;code&gt;-1&lt;/code&gt; designates the rightmost element, and so on. If the item is out of the range -array_length .. array_length -1, and create_missing is true, the new value is added at the beginning of the array if the item is negative, and at the end of the array if it is positive.</source>
          <target state="translated">如果最后一个路径项是对象键，则如果缺少该项并为其指定新值，则将创建它。如果最后一个路径项是数组索引，则如果它是正数，则通过从左数开始找到要设置的项，如果是负数，则从右数开始找到 &lt;code&gt;-1&lt;/code&gt; 表示最右边的元素，依此类推。如果该项超出-array_length .. array_length -1的范围，并且create_missing为true，则如果该项为负，则在数组的开头添加新值；如果为正，则在数组的末尾添加新值。</target>
        </trans-unit>
        <trans-unit id="2188ba6147e78aaca8d5a46e0dc7277dd7c3324b" translate="yes" xml:space="preserve">
          <source>If the modifier &lt;code&gt;n&lt;/code&gt; (&amp;ldquo;nested&amp;rdquo;) is used, or a pattern is specified, then non-root partitioned relations are included, and a column is shown displaying the parent of each partitioned relation.</source>
          <target state="translated">如果使用修饰符 &lt;code&gt;n&lt;/code&gt; （&amp;ldquo;嵌套&amp;rdquo;）或指定了模式，则将包括非根分区关系，并显示一列以显示每个分区关系的父级。</target>
        </trans-unit>
        <trans-unit id="954bfa7fec82935e3cdcd8281374d6651335948e" translate="yes" xml:space="preserve">
          <source>If the new connection is successfully made, the previous connection is closed. If the connection attempt failed (wrong user name, access denied, etc.), the previous connection will only be kept if psql is in interactive mode. When executing a non-interactive script, processing will immediately stop with an error. This distinction was chosen as a user convenience against typos on the one hand, and a safety mechanism that scripts are not accidentally acting on the wrong database on the other hand.</source>
          <target state="translated">如果新连接成功,则关闭之前的连接。如果连接尝试失败(错误的用户名、访问被拒绝等),只有当psql处于交互模式时,之前的连接才会被保留。当执行非交互式脚本时,处理将立即停止,并出现错误。选择这种区分一方面是为了方便用户防止错别字,另一方面也是为了保证脚本不会意外地作用于错误的数据库的安全机制。</target>
        </trans-unit>
        <trans-unit id="f53d72a1eae9ceb05fc2fcc17f8301adebb27e79" translate="yes" xml:space="preserve">
          <source>If the new connection is successfully made, the previous connection is closed. If the connection attempt fails (wrong user name, access denied, etc.), the previous connection will be kept if psql is in interactive mode. But when executing a non-interactive script, processing will immediately stop with an error. This distinction was chosen as a user convenience against typos on the one hand, and a safety mechanism that scripts are not accidentally acting on the wrong database on the other hand.</source>
          <target state="translated">如果新连接成功,则关闭之前的连接。如果连接尝试失败(用户名错误、访问被拒绝等),如果psql处于交互模式,之前的连接将被保留。但在执行非交互式脚本时,处理将立即停止,并出现错误。选择这种区分一方面是为了方便用户防止错别字,另一方面也是一种安全机制,脚本不会意外地作用于错误的数据库。</target>
        </trans-unit>
        <trans-unit id="2a5e26aea388ddd76a8f217c381769165be706df" translate="yes" xml:space="preserve">
          <source>If the new partition is a foreign table, nothing is done to verify that all the rows in the foreign table obey the partition constraint. (See the discussion in &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt; about constraints on the foreign table.)</source>
          <target state="translated">如果新分区是外部表，则不执行任何操作来验证外部表中的所有行均遵守分区约束。（请参阅&lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE中&lt;/a&gt;有关外部表约束的讨论。）</target>
        </trans-unit>
        <trans-unit id="f277321bdd9057205b2810a53bafd6facd91f266" translate="yes" xml:space="preserve">
          <source>If the new partition is a regular table, a full table scan is performed to check that existing rows in the table do not violate the partition constraint. It is possible to avoid this scan by adding a valid &lt;code&gt;CHECK&lt;/code&gt; constraint to the table that allows only rows satisfying the desired partition constraint before running this command. The &lt;code&gt;CHECK&lt;/code&gt; constraint will be used to determine that the table need not be scanned to validate the partition constraint. This does not work, however, if any of the partition keys is an expression and the partition does not accept &lt;code&gt;NULL&lt;/code&gt; values. If attaching a list partition that will not accept &lt;code&gt;NULL&lt;/code&gt; values, also add &lt;code&gt;NOT NULL&lt;/code&gt; constraint to the partition key column, unless it's an expression.</source>
          <target state="translated">如果新分区是常规表，则执行全表扫描以检查表中的现有行没有违反分区约束。可以通过在表中添加有效的 &lt;code&gt;CHECK&lt;/code&gt; 约束来避免这种扫描，该约束仅允许在满足以下条件的行才能运行：的 &lt;code&gt;CHECK&lt;/code&gt; 约束将被用来确定表不需要被扫描验证分区约束。但是，如果任何分区键是一个表达式并且该分区不接受 &lt;code&gt;NULL&lt;/code&gt; 值，则此方法不起作用。如果附加将不接受 &lt;code&gt;NULL&lt;/code&gt; 值的列表分区，则还要添加 &lt;code&gt;NOT NULL&lt;/code&gt; 分区键列的约束，除非它是一个表达式。</target>
        </trans-unit>
        <trans-unit id="48a04ec2659d2ed3b669f8d3fed6c4aa6cc05212" translate="yes" xml:space="preserve">
          <source>If the new value is inconsistent with the tuple prefix, set &lt;code&gt;resultType&lt;/code&gt; to &lt;code&gt;spgSplitTuple&lt;/code&gt;. This action moves all the existing nodes into a new lower-level inner tuple, and replaces the existing inner tuple with a tuple having a single downlink pointing to the new lower-level inner tuple. Set &lt;code&gt;prefixHasPrefix&lt;/code&gt; to indicate whether the new upper tuple should have a prefix, and if so set &lt;code&gt;prefixPrefixDatum&lt;/code&gt; to the prefix value. This new prefix value must be sufficiently less restrictive than the original to accept the new value to be indexed. Set &lt;code&gt;prefixNNodes&lt;/code&gt; to the number of nodes needed in the new tuple, and set &lt;code&gt;prefixNodeLabels&lt;/code&gt; to a palloc'd array holding their labels, or to NULL if node labels are not required. Note that the total size of the new upper tuple must be no more than the total size of the tuple it is replacing; this constrains the lengths of the new prefix and new labels. Set &lt;code&gt;childNodeN&lt;/code&gt; to the index (from zero) of the node that will downlink to the new lower-level inner tuple. Set &lt;code&gt;postfixHasPrefix&lt;/code&gt; to indicate whether the new lower-level inner tuple should have a prefix, and if so set &lt;code&gt;postfixPrefixDatum&lt;/code&gt; to the prefix value. The combination of these two prefixes and the downlink node's label (if any) must have the same meaning as the original prefix, because there is no opportunity to alter the node labels that are moved to the new lower-level tuple, nor to change any child index entries. After the node has been split, the &lt;code&gt;choose&lt;/code&gt; function will be called again with the replacement inner tuple. That call may return an &lt;code&gt;spgAddNode&lt;/code&gt; result, if no suitable node was created by the &lt;code&gt;spgSplitTuple&lt;/code&gt; action. Eventually &lt;code&gt;choose&lt;/code&gt; must return &lt;code&gt;spgMatchNode&lt;/code&gt; to allow the insertion to descend to the next level.</source>
          <target state="translated">如果新值与元组前缀不一致，则将 &lt;code&gt;resultType&lt;/code&gt; 设置为 &lt;code&gt;spgSplitTuple&lt;/code&gt; 。该动作将所有现有节点移动到新的较低级内部元组中，并用具有指向新低级内部元组的单个下行链路的元组来替换现有的内部元组。设置 &lt;code&gt;prefixHasPrefix&lt;/code&gt; 以指示新的上级元组是否应具有前缀，如果是，则将 &lt;code&gt;prefixPrefixDatum&lt;/code&gt; 设置为该前缀值。此新前缀值的限制必须比原始限制少得多，以接受要索引的新值。将 &lt;code&gt;prefixNNodes&lt;/code&gt; 设置为新元组中所需的节点数，并设置 &lt;code&gt;prefixNodeLabels&lt;/code&gt; 到保留有其标签的palloc数组中；如果不需要节点标签，则为NULL。请注意，新的上层元组的总大小必须不超过要替换的元组的总大小；这限制了新前缀和新标签的长度。将 &lt;code&gt;childNodeN&lt;/code&gt; 设置为将下行到新的较低级内部元组的节点的索引（从零开始）。设置 &lt;code&gt;postfixHasPrefix&lt;/code&gt; 以指示新的较低级内部元组是否应具有前缀，如果是，则设置 &lt;code&gt;postfixPrefixDatum&lt;/code&gt; 到前缀值。这两个前缀和下行链路节点标签（如果有的话）的组合必须具有与原始前缀相同的含义，因为没有机会更改移动到新的下级元组的节点标签，也没有任何更改的机会。子索引条目。拆分节点后，将使用替换内部元组再次调用 &lt;code&gt;choose&lt;/code&gt; 函数。如果 &lt;code&gt;spgSplitTuple&lt;/code&gt; 操作未创建合适的节点，则该调用可能返回 &lt;code&gt;spgAddNode&lt;/code&gt; 结果。最终 &lt;code&gt;choose&lt;/code&gt; 必须返回 &lt;code&gt;spgMatchNode&lt;/code&gt; 才能使插入下降到下一个级别。</target>
        </trans-unit>
        <trans-unit id="cad207ddb2eaf025fe9a90fd7f853c4606a19762" translate="yes" xml:space="preserve">
          <source>If the new value matches one of the existing child nodes, set &lt;code&gt;resultType&lt;/code&gt; to &lt;code&gt;spgMatchNode&lt;/code&gt;. Set &lt;code&gt;nodeN&lt;/code&gt; to the index (from zero) of that node in the node array. Set &lt;code&gt;levelAdd&lt;/code&gt; to the increment in &lt;code&gt;level&lt;/code&gt; caused by descending through that node, or leave it as zero if the operator class does not use levels. Set &lt;code&gt;restDatum&lt;/code&gt; to equal &lt;code&gt;leafDatum&lt;/code&gt; if the operator class does not modify datums from one level to the next, or otherwise set it to the modified value to be used as &lt;code&gt;leafDatum&lt;/code&gt; at the next level.</source>
          <target state="translated">如果新值与现有子节点之一匹配，则将 &lt;code&gt;resultType&lt;/code&gt; 设置为 &lt;code&gt;spgMatchNode&lt;/code&gt; 。将 &lt;code&gt;nodeN&lt;/code&gt; 设置为节点数组中该节点的索引（从零开始）。将 &lt;code&gt;levelAdd&lt;/code&gt; 设置为由该节点下降引起的 &lt;code&gt;level&lt;/code&gt; 增量，如果操作员类不使用级别，则将其设置为零。集 &lt;code&gt;restDatum&lt;/code&gt; 等于 &lt;code&gt;leafDatum&lt;/code&gt; 如果操作者类不修改基准从一个层次到下一个，或以其他方式将其设置为修改后的值被用作 &lt;code&gt;leafDatum&lt;/code&gt; 下一级。</target>
        </trans-unit>
        <trans-unit id="b192c266d3e1a4a0032d805a8345acd4fec22c20" translate="yes" xml:space="preserve">
          <source>If the non-unknown inputs are not all of the same type category, fail.</source>
          <target state="translated">如果非未知输入不都是同一类型类别,则失败。</target>
        </trans-unit>
        <trans-unit id="21b9de4f5d381ca1caadda7c1730c20093d98952" translate="yes" xml:space="preserve">
          <source>If the numeric token contains a colon (&lt;code&gt;:&lt;/code&gt;), this is a time string. Include all subsequent digits and colons.</source>
          <target state="translated">如果数字记号包含一个冒号（ &lt;code&gt;:&lt;/code&gt; ），这是一个时间字符串。包括所有后续数字和冒号。</target>
        </trans-unit>
        <trans-unit id="31a587270029792d925fa073ce1717b2b1a5ee50" translate="yes" xml:space="preserve">
          <source>If the numeric token contains a dash (&lt;code&gt;-&lt;/code&gt;), slash (&lt;code&gt;/&lt;/code&gt;), or two or more dots (&lt;code&gt;.&lt;/code&gt;), this is a date string which might have a text month. If a date token has already been seen, it is instead interpreted as a time zone name (e.g., &lt;code&gt;America/New_York&lt;/code&gt;).</source>
          <target state="translated">如果数字令牌包含破折号（ &lt;code&gt;-&lt;/code&gt; ），斜杠（ &lt;code&gt;/&lt;/code&gt; ）或两个或多个点（ &lt;code&gt;.&lt;/code&gt; ），则这是一个日期字符串，可能具有文本月份。如果已经看到日期令牌，则将其解释为时区名称（例如 &lt;code&gt;America/New_York&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2ee076bf4dbead171f4fb25426abca0b1193f6e2" translate="yes" xml:space="preserve">
          <source>If the operating system provides support for using multiple locales within a single program (&lt;code&gt;newlocale&lt;/code&gt; and related functions), or if support for ICU is configured, then when a database cluster is initialized, &lt;code&gt;initdb&lt;/code&gt; populates the system catalog &lt;code&gt;pg_collation&lt;/code&gt; with collations based on all the locales it finds in the operating system at the time.</source>
          <target state="translated">如果操作系统提供对在单个程序中使用多个语言环境的支持（ &lt;code&gt;newlocale&lt;/code&gt; 和相关功能），或者配置了对ICU的支持，则在初始化数据库集群时， &lt;code&gt;initdb&lt;/code&gt; 将基于所有语言环境的归类填充系统目录 &lt;code&gt;pg_collation&lt;/code&gt; 它可以在当时的操作系统中找到。</target>
        </trans-unit>
        <trans-unit id="ac5399d971a7de7c9b73abf76e58c0bf1b2aae3d" translate="yes" xml:space="preserve">
          <source>If the operation does not complete within the timeout (see option &lt;code&gt;-t&lt;/code&gt;), then &lt;code&gt;pg_ctl&lt;/code&gt; exits with a nonzero exit status. But note that the operation might continue in the background and eventually succeed.</source>
          <target state="translated">如果操作未在超时时间内完成（请参阅选项 &lt;code&gt;-t&lt;/code&gt; ），则 &lt;code&gt;pg_ctl&lt;/code&gt; 以非零退出状态退出。但是请注意，该操作可能会在后台继续进行并最终成功。</target>
        </trans-unit>
        <trans-unit id="14ab0f7eed5fb08edbafe519f61a48bda6216b85" translate="yes" xml:space="preserve">
          <source>If the optional &lt;code&gt;NO CYCLE&lt;/code&gt; key word is specified, any calls to &lt;code&gt;nextval&lt;/code&gt; after the sequence has reached its maximum value will return an error. If neither &lt;code&gt;CYCLE&lt;/code&gt; or &lt;code&gt;NO CYCLE&lt;/code&gt; are specified, the old cycle behavior will be maintained.</source>
          <target state="translated">如果指定了可选的 &lt;code&gt;NO CYCLE&lt;/code&gt; 关键字，则在序列达到最大值之后，对 &lt;code&gt;nextval&lt;/code&gt; 的任何调用都将返回错误。如果未指定 &lt;code&gt;CYCLE&lt;/code&gt; 或 &lt;code&gt;NO CYCLE&lt;/code&gt; ，则将保留旧的循环行为。</target>
        </trans-unit>
        <trans-unit id="2dc933189fc3de8b16aa112ce975759af1f0b257" translate="yes" xml:space="preserve">
          <source>If the optional Boolean parameter &lt;code&gt;collatable&lt;/code&gt; is true, column definitions and expressions of the type may carry collation information through use of the &lt;code&gt;COLLATE&lt;/code&gt; clause. It is up to the implementations of the functions operating on the type to actually make use of the collation information; this does not happen automatically merely by marking the type collatable.</source>
          <target state="translated">如果可选的布尔参数 &lt;code&gt;collatable&lt;/code&gt; 为true，则类型的列定义和表达式可以通过使用 &lt;code&gt;COLLATE&lt;/code&gt; 子句来携带排序规则信息。实际使用归类信息取决于在类型上操作的功能的实现。仅通过标记可协作的类型，这不会自动发生。</target>
        </trans-unit>
        <trans-unit id="bdfeb01a261949b7092b2cbd814cde7a65edc244" translate="yes" xml:space="preserve">
          <source>If the ordering of siblings of the same parent is important, include the &lt;em&gt;&lt;code&gt;orderby_fld&lt;/code&gt;&lt;/em&gt; parameter to specify which field to order siblings by. This field can be of any sortable data type. The output column list must include a final integer serial-number column, if and only if &lt;em&gt;&lt;code&gt;orderby_fld&lt;/code&gt;&lt;/em&gt; is specified.</source>
          <target state="translated">如果同一父级的同级兄弟的排序很重要，请包括&lt;em&gt; &lt;code&gt;orderby_fld&lt;/code&gt; &lt;/em&gt;参数以指定对同级兄弟进行排序的字段。该字段可以是任何可排序的数据类型。当且仅当指定&lt;em&gt; &lt;code&gt;orderby_fld&lt;/code&gt; 时&lt;/em&gt;，输出列列表才必须包含最后一个整数序列号列。</target>
        </trans-unit>
        <trans-unit id="3ed5ab7fc15ec983050d9cabedbfee6290fa8126" translate="yes" xml:space="preserve">
          <source>If the output column is a composite (row) type, and the JSON value is a JSON object, the fields of the object are converted to columns of the output row type by recursive application of these rules.</source>
          <target state="translated">如果输出列是复合(行)类型,JSON值是JSON对象,则通过递归应用这些规则将对象的字段转换为输出行类型的列。</target>
        </trans-unit>
        <trans-unit id="c25ff23eb72be3bfb20da8609dc04d07dc26b478" translate="yes" xml:space="preserve">
          <source>If the output column is of type &lt;code&gt;json&lt;/code&gt; or &lt;code&gt;jsonb&lt;/code&gt;, the JSON value is just reproduced exactly.</source>
          <target state="translated">如果输出列的类型为 &lt;code&gt;json&lt;/code&gt; 或 &lt;code&gt;jsonb&lt;/code&gt; ，那么将精确地再现JSON值。</target>
        </trans-unit>
        <trans-unit id="50b9656459eac8e751efab8869d145ae99f220b8" translate="yes" xml:space="preserve">
          <source>If the password is encrypted with SCRAM-SHA-256, it has the format:</source>
          <target state="translated">如果密码是用SCRAM-SHA-256加密的,它的格式是:。</target>
        </trans-unit>
        <trans-unit id="d0f9a0afdced3c84c5a56565915bd16c67d24a36" translate="yes" xml:space="preserve">
          <source>If the path expression returns an empty node-set (typically, when it does not match) for a given row, the column will be set to &lt;code&gt;NULL&lt;/code&gt;, unless a &lt;code&gt;default_expression&lt;/code&gt; is specified; then the value resulting from evaluating that expression is used.</source>
          <target state="translated">如果路径表达式返回给定行的空节点集（通常，当它不匹配时），则该列将被设置为 &lt;code&gt;NULL&lt;/code&gt; ，除非指定了 &lt;code&gt;default_expression&lt;/code&gt; ；否则，该列将被设置为NULL。然后使用通过评估该表达式得出的值。</target>
        </trans-unit>
        <trans-unit id="e0c947f55da31c1d5c1555adf98bd354dc366c84" translate="yes" xml:space="preserve">
          <source>If the primary is isolated from remaining standby servers you should fail over to the best candidate of those other remaining standby servers.</source>
          <target state="translated">如果主服务器与剩余的备用服务器隔离,你应该将故障切换到其他剩余备用服务器中的最佳候选者。</target>
        </trans-unit>
        <trans-unit id="fa67ddcebd2151f0eb68edd839f12d39677af43a" translate="yes" xml:space="preserve">
          <source>If the primary server fails and the standby server becomes the new primary, and then the old primary restarts, you must have a mechanism for informing the old primary that it is no longer the primary. This is sometimes known as STONITH (Shoot The Other Node In The Head), which is necessary to avoid situations where both systems think they are the primary, which will lead to confusion and ultimately data loss.</source>
          <target state="translated">如果主服务器发生故障,备用服务器成为新的主服务器,然后旧的主服务器重新启动,你必须有一个机制来通知旧的主服务器它不再是主服务器。这有时被称为STONITH(Shoot The Other Node In The Head),这是必要的,以避免两个系统都认为自己是主服务器的情况,这将导致混乱并最终导致数据丢失。</target>
        </trans-unit>
        <trans-unit id="5ef10647b0698fbedd9383d4669217342caae5e0" translate="yes" xml:space="preserve">
          <source>If the primary server fails then the standby server should begin failover procedures.</source>
          <target state="translated">如果主服务器出现故障,那么备用服务器应该开始故障转移程序。</target>
        </trans-unit>
        <trans-unit id="3c8481924c3ba4dda86247ddbf4dd7292be6f835" translate="yes" xml:space="preserve">
          <source>If the private key is protected with a passphrase, the server will prompt for the passphrase and will not start until it has been entered. Using a passphrase by default disables the ability to change the server's SSL configuration without a server restart, but see &lt;a href=&quot;runtime-config-connection#GUC-SSL-PASSPHRASE-COMMAND-SUPPORTS-RELOAD&quot;&gt;ssl_passphrase_command_supports_reload&lt;/a&gt;. Furthermore, passphrase-protected private keys cannot be used at all on Windows.</source>
          <target state="translated">如果私钥已使用密码保护，则服务器将提示您输入密码，直到输入密码后服务器才会启动。默认情况下，使用密码短语将禁用在不重新启动服务器的情况下更改服务器SSL配置的功能，但请参阅&lt;a href=&quot;runtime-config-connection#GUC-SSL-PASSPHRASE-COMMAND-SUPPORTS-RELOAD&quot;&gt;ssl_passphrase_command_supports_reload&lt;/a&gt;。此外，在Windows上根本无法使用受密码保护的私钥。</target>
        </trans-unit>
        <trans-unit id="48f80ecbcca6b903e77ef9cdbab43d62afcd07ee" translate="yes" xml:space="preserve">
          <source>If the procedure has any output parameters, then a result row will be returned, containing the values of those parameters.</source>
          <target state="translated">如果存储过程有任何输出参数,那么将返回一个结果行,包含这些参数的值。</target>
        </trans-unit>
        <trans-unit id="1290513a0720d5678ce9e07e692a24b4a58d5efd" translate="yes" xml:space="preserve">
          <source>If the products table is set up so that, say, &lt;code&gt;product_id&lt;/code&gt; is the primary key, then it would be enough to group by &lt;code&gt;product_id&lt;/code&gt; in the above example, since name and price would be &lt;em&gt;functionally dependent&lt;/em&gt; on the product ID, and so there would be no ambiguity about which name and price value to return for each product ID group.</source>
          <target state="translated">如果将products表设置为假设 &lt;code&gt;product_id&lt;/code&gt; 是主键，那么在上面的示例中按 &lt;code&gt;product_id&lt;/code&gt; 分组就足够了，因为名称和价格在&lt;em&gt;功能上取决于&lt;/em&gt;产品ID，因此对于每个产品ID组返回哪个名称和价格值没有任何歧义。</target>
        </trans-unit>
        <trans-unit id="e03a5d6f408539b4e08801b317931a00ecee94a9" translate="yes" xml:space="preserve">
          <source>If the query contains any window functions (see &lt;a href=&quot;tutorial-window&quot;&gt;Section 3.5&lt;/a&gt;, &lt;a href=&quot;functions-window&quot;&gt;Section 9.21&lt;/a&gt; and &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Section 4.2.8&lt;/a&gt;), these functions are evaluated after any grouping, aggregation, and &lt;code&gt;HAVING&lt;/code&gt; filtering is performed. That is, if the query uses any aggregates, &lt;code&gt;GROUP BY&lt;/code&gt;, or &lt;code&gt;HAVING&lt;/code&gt;, then the rows seen by the window functions are the group rows instead of the original table rows from &lt;code&gt;FROM&lt;/code&gt;/&lt;code&gt;WHERE&lt;/code&gt;.</source>
          <target state="translated">如果查询包含任何窗口函数（请参见&lt;a href=&quot;tutorial-window&quot;&gt;第3.5节&lt;/a&gt;，&lt;a href=&quot;functions-window&quot;&gt;第9.21节&lt;/a&gt;和&lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;第4.2.8节&lt;/a&gt;），则在执行任何分组，聚合和 &lt;code&gt;HAVING&lt;/code&gt; 过滤之后，将评估这些函数。即，如果查询使用任何聚合， &lt;code&gt;GROUP BY&lt;/code&gt; 或 &lt;code&gt;HAVING&lt;/code&gt; ，则窗口函数看到的行是组行，而不是 &lt;code&gt;FROM&lt;/code&gt; / &lt;code&gt;WHERE&lt;/code&gt; 中的原始表行。</target>
        </trans-unit>
        <trans-unit id="a48d893df2efd76b2d73680b987bd53b81b2adad" translate="yes" xml:space="preserve">
          <source>If the query contains any window functions (see &lt;a href=&quot;tutorial-window&quot;&gt;Section 3.5&lt;/a&gt;, &lt;a href=&quot;functions-window&quot;&gt;Section 9.22&lt;/a&gt; and &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Section 4.2.8&lt;/a&gt;), these functions are evaluated after any grouping, aggregation, and &lt;code&gt;HAVING&lt;/code&gt; filtering is performed. That is, if the query uses any aggregates, &lt;code&gt;GROUP BY&lt;/code&gt;, or &lt;code&gt;HAVING&lt;/code&gt;, then the rows seen by the window functions are the group rows instead of the original table rows from &lt;code&gt;FROM&lt;/code&gt;/&lt;code&gt;WHERE&lt;/code&gt;.</source>
          <target state="translated">如果查询包含任何窗口函数（请参见&lt;a href=&quot;tutorial-window&quot;&gt;第3.5节&lt;/a&gt;，&lt;a href=&quot;functions-window&quot;&gt;第9.22节&lt;/a&gt;和&lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;第4.2.8节&lt;/a&gt;），则在执行任何分组，聚合和 &lt;code&gt;HAVING&lt;/code&gt; 过滤之后，将评估这些函数。也就是说，如果查询使用任何聚合， &lt;code&gt;GROUP BY&lt;/code&gt; 或 &lt;code&gt;HAVING&lt;/code&gt; ，则窗口函数看到的行将是组行，而不是 &lt;code&gt;FROM&lt;/code&gt; / &lt;code&gt;WHERE&lt;/code&gt; 中的原始表行。</target>
        </trans-unit>
        <trans-unit id="e83ebc0874906fce6a1aa2d76fdc21590b6b98b1" translate="yes" xml:space="preserve">
          <source>If the query fails or does not return one row, no variables are changed.</source>
          <target state="translated">如果查询失败或没有返回一条记录,则不改变变量。</target>
        </trans-unit>
        <trans-unit id="baf42f0acc3f09fcc4a0d0dd54cac78d65c286a5" translate="yes" xml:space="preserve">
          <source>If the query requires joining two or more relations, plans for joining relations are considered after all feasible plans have been found for scanning single relations. The three available join strategies are:</source>
          <target state="translated">如果查询需要加入两个或两个以上的关系,在找到所有可行的扫描单个关系的计划后,再考虑加入关系的计划。三种可用的加入策略是:</target>
        </trans-unit>
        <trans-unit id="2e9c3a0d6f1b6d02143aa6739bb627c7730a051b" translate="yes" xml:space="preserve">
          <source>If the query uses fewer than &lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt; relations, a near-exhaustive search is conducted to find the best join sequence. The planner preferentially considers joins between any two relations for which there exist a corresponding join clause in the &lt;code&gt;WHERE&lt;/code&gt; qualification (i.e., for which a restriction like &lt;code&gt;where rel1.attr1=rel2.attr2&lt;/code&gt; exists). Join pairs with no join clause are considered only when there is no other choice, that is, a particular relation has no available join clauses to any other relation. All possible plans are generated for every join pair considered by the planner, and the one that is (estimated to be) the cheapest is chosen.</source>
          <target state="translated">如果查询所使用的关系少于&lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt;关系，那么将进行近乎穷举的搜索以找到最佳连接顺序。计划者优先考虑在 &lt;code&gt;WHERE&lt;/code&gt; 限定条件中存在对应联接子句的任何两个关系之间的联接（即，存在诸如 &lt;code&gt;where rel1.attr1=rel2.attr2&lt;/code&gt; 类的限制）。仅当没有其他选择时，才考虑不具有join子句的联接对，即，特定关系对任何其他关系都没有可用的join子句。为计划者考虑的每个联接对生成所有可能的计划，并选择（估计）最便宜的一个。</target>
        </trans-unit>
        <trans-unit id="fcb1910db08273fa485c28070ee9179ceccf3c73" translate="yes" xml:space="preserve">
          <source>If the referenced column(s) are changed frequently, it might be wise to add an index to the referencing column(s) so that referential actions associated with the foreign key constraint can be performed more efficiently.</source>
          <target state="translated">如果被引用的列经常发生变化,那么在引用的列上添加一个索引可能是明智之举,这样可以更有效地执行与外键约束相关的引用操作。</target>
        </trans-unit>
        <trans-unit id="2e6cbc38cc65944231eb0e20f1c30488fbd5652a" translate="yes" xml:space="preserve">
          <source>If the role executing &lt;code&gt;GRANT&lt;/code&gt; holds the required privileges indirectly via more than one role membership path, it is unspecified which containing role will be recorded as having done the grant. In such cases it is best practice to use &lt;code&gt;SET ROLE&lt;/code&gt; to become the specific role you want to do the &lt;code&gt;GRANT&lt;/code&gt; as.</source>
          <target state="translated">如果执行 &lt;code&gt;GRANT&lt;/code&gt; 的角色通过多个角色成员资格路径间接持有所需的特权，则未指定哪个包含角色将记录为已完成授予。在这种情况下，最佳实践是使用 &lt;code&gt;SET ROLE&lt;/code&gt; 成为要执行 &lt;code&gt;GRANT&lt;/code&gt; 的特定角色。</target>
        </trans-unit>
        <trans-unit id="24d9b80ef7c6da193a9a22333ae220223fd8b0ac" translate="yes" xml:space="preserve">
          <source>If the role executing &lt;code&gt;REVOKE&lt;/code&gt; holds privileges indirectly via more than one role membership path, it is unspecified which containing role will be used to perform the command. In such cases it is best practice to use &lt;code&gt;SET ROLE&lt;/code&gt; to become the specific role you want to do the &lt;code&gt;REVOKE&lt;/code&gt; as. Failure to do so might lead to revoking privileges other than the ones you intended, or not revoking anything at all.</source>
          <target state="translated">如果执行 &lt;code&gt;REVOKE&lt;/code&gt; 的角色通过一个以上的角色成员资格路径间接持有特权，则未指定将使用哪个包含角色来执行命令。在这种情况下，最佳实践是使用 &lt;code&gt;SET ROLE&lt;/code&gt; 来成为要执行 &lt;code&gt;REVOKE&lt;/code&gt; 的特定角色。否则，可能会导致吊销您想要的特权以外的特权，或者根本不撤销任何特权。</target>
        </trans-unit>
        <trans-unit id="9127d1a2bf0d40475f431a0daa0c09f299f8d847" translate="yes" xml:space="preserve">
          <source>If the same channel name is signaled multiple times from the same transaction with identical payload strings, the database server can decide to deliver a single notification only. On the other hand, notifications with distinct payload strings will always be delivered as distinct notifications. Similarly, notifications from different transactions will never get folded into one notification. Except for dropping later instances of duplicate notifications, &lt;code&gt;NOTIFY&lt;/code&gt; guarantees that notifications from the same transaction get delivered in the order they were sent. It is also guaranteed that messages from different transactions are delivered in the order in which the transactions committed.</source>
          <target state="translated">如果使用相同的有效负载字符串从同一事务中多次发出相同的通道名称信号，则数据库服务器可以决定仅传递单个通知。另一方面，具有不同有效负载字符串的通知将始终作为不同的通知传递。同样，来自不同事务的通知将永远不会折叠成一个通知。除了在以后删除重复通知的实例之外， &lt;code&gt;NOTIFY&lt;/code&gt; 保证来自同一事务的通知按其发送顺序进行传递。还可以保证来自不同事务的消息以提交事务的顺序传递。</target>
        </trans-unit>
        <trans-unit id="eed847052fd81f5459f65863d508269d92317295" translate="yes" xml:space="preserve">
          <source>If the same channel name is signaled multiple times with identical payload strings within the same transaction, only one instance of the notification event is delivered to listeners. On the other hand, notifications with distinct payload strings will always be delivered as distinct notifications. Similarly, notifications from different transactions will never get folded into one notification. Except for dropping later instances of duplicate notifications, &lt;code&gt;NOTIFY&lt;/code&gt; guarantees that notifications from the same transaction get delivered in the order they were sent. It is also guaranteed that messages from different transactions are delivered in the order in which the transactions committed.</source>
          <target state="translated">如果在同一事务中使用相同的有效负载字符串多次发出相同的通道名称信号，则仅将通知事件的一个实例传递给侦听器。另一方面，具有不同有效负载字符串的通知将始终作为不同的通知传递。同样，来自不同事务的通知将永远不会折叠成一个通知。除了在以后删除重复通知的实例之外， &lt;code&gt;NOTIFY&lt;/code&gt; 保证来自同一事务的通知按其发送顺序进行传递。还可以确保来自不同事务的消息以提交事务的顺序传递。</target>
        </trans-unit>
        <trans-unit id="25d36a41307a4d14aa722349a681e2f2a7b7eb16" translate="yes" xml:space="preserve">
          <source>If the same column name exists in more than one parent table, an error is reported unless the data types of the columns match in each of the parent tables. If there is no conflict, then the duplicate columns are merged to form a single column in the new table. If the column name list of the new table contains a column name that is also inherited, the data type must likewise match the inherited column(s), and the column definitions are merged into one. If the new table explicitly specifies a default value for the column, this default overrides any defaults from inherited declarations of the column. Otherwise, any parents that specify default values for the column must all specify the same default, or an error will be reported.</source>
          <target state="translated">如果相同的列名存在于一个以上的父表中,就会报告错误,除非每个父表中的列的数据类型相匹配。如果不存在冲突,那么重复的列将被合并,在新表中形成一个单一的列。如果新表的列名列表中包含一个也是继承的列名,那么数据类型必须同样与继承的列相匹配,并且列定义会被合并成一个列。如果新表明确指定了列的缺省值,这个缺省值会覆盖继承的列声明中的任何缺省值。否则,任何为列指定缺省值的父列必须全部指定相同的缺省值,否则将报告一个错误。</target>
        </trans-unit>
        <trans-unit id="52777f31338be443c8719518578a441085b3242b" translate="yes" xml:space="preserve">
          <source>If the scale of a value to be stored is greater than the declared scale of the column, the system will round the value to the specified number of fractional digits. Then, if the number of digits to the left of the decimal point exceeds the declared precision minus the declared scale, an error is raised.</source>
          <target state="translated">如果要存储的值的比例大于列的声明比例,系统将把值四舍五入到指定的小数点位数。然后,如果小数点左边的数字超过声明的精度减去声明的比例,就会出现错误。</target>
        </trans-unit>
        <trans-unit id="02e920dfe841eca3127cd2deda87b1b0038bf35c" translate="yes" xml:space="preserve">
          <source>If the search path finds multiple functions of identical argument types, only the one appearing earliest in the path is considered. Functions of different argument types are considered on an equal footing regardless of search path position.</source>
          <target state="translated">如果搜索路径找到多个参数类型相同的函数,则只考虑路径中最早出现的那个函数。无论搜索路径的位置如何,不同参数类型的函数都会被同等考虑。</target>
        </trans-unit>
        <trans-unit id="846c48a5a96c2f9f31d852fa93bd025a2ae37209" translate="yes" xml:space="preserve">
          <source>If the search path finds multiple operators with identical argument types, only the one appearing earliest in the path is considered. Operators with different argument types are considered on an equal footing regardless of search path position.</source>
          <target state="translated">如果搜索路径找到多个参数类型相同的操作符,则只考虑路径中最早出现的那个。无论搜索路径的位置如何,具有不同参数类型的运算符都会被同等考虑。</target>
        </trans-unit>
        <trans-unit id="2b252638ccabfce3f83bfcd21c45870e0c2d0f5f" translate="yes" xml:space="preserve">
          <source>If the server encoding is not UTF-8, the Unicode code point identified by one of these escape sequences is converted to the actual server encoding; an error is reported if that's not possible.</source>
          <target state="translated">如果服务器编码不是UTF-8,由这些转义序列之一确定的Unicode码点将被转换为实际的服务器编码;如果不可能,将报告一个错误。</target>
        </trans-unit>
        <trans-unit id="d768fe47d52ad5a0b026e7ffb256e492ca409f05" translate="yes" xml:space="preserve">
          <source>If the server requires password authentication and a password is not available from other sources such as a &lt;code&gt;.pgpass&lt;/code&gt; file, psql will prompt for a password in any case. However, psql will waste a connection attempt finding out that the server wants a password. In some cases it is worth typing &lt;code&gt;-W&lt;/code&gt; to avoid the extra connection attempt.</source>
          <target state="translated">如果服务器要求密码认证，而其他来源（例如 &lt;code&gt;.pgpass&lt;/code&gt; 文件）没有密码，则在任何情况下psql都会提示输入密码。但是，psql将浪费连接尝试，以发现服务器需要密码。在某些情况下，值得输入 &lt;code&gt;-W&lt;/code&gt; 以避免额外的连接尝试。</target>
        </trans-unit>
        <trans-unit id="3c9b16d6feb91ed4af38eb28e886ad3416c7d722" translate="yes" xml:space="preserve">
          <source>If the session user is a database superuser, then a &lt;code&gt;#&lt;/code&gt;, otherwise a &lt;code&gt;&amp;gt;&lt;/code&gt;. (The expansion of this value might change during a database session as the result of the command &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt;.)</source>
          <target state="translated">如果会话用户是数据库超级用户，则为 &lt;code&gt;#&lt;/code&gt; ，否则为 &lt;code&gt;&amp;gt;&lt;/code&gt; 。（此值的扩展可能在数据库会话期间由于命令 &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; 而改变。）</target>
        </trans-unit>
        <trans-unit id="21d4dfd38c56bb0f6178a7f714085ed7cf4b3207" translate="yes" xml:space="preserve">
          <source>If the specified table is a partitioned table, each row is routed to the appropriate partition and inserted into it. If the specified table is a partition, an error will occur if one of the input rows violates the partition constraint.</source>
          <target state="translated">如果指定的表是一个分区表,每条记录都会被路由到相应的分区并插入其中。如果指定的表是分区表,如果有一条输入记录违反了分区约束,就会发生错误。</target>
        </trans-unit>
        <trans-unit id="1b245f2cb2a99bf0f8cbbb31a4d055f1ead828c3" translate="yes" xml:space="preserve">
          <source>If the standard and predefined collations are not sufficient, users can create their own collation objects using the SQL command &lt;a href=&quot;sql-createcollation&quot;&gt;CREATE COLLATION&lt;/a&gt;.</source>
          <target state="translated">如果标准归类和预定义归类不足，则用户可以使用SQL命令&lt;a href=&quot;sql-createcollation&quot;&gt;CREATE COLLATION&lt;/a&gt;创建自己的归类对象。</target>
        </trans-unit>
        <trans-unit id="3b1c783904332e93ac1d7897a9080ae105b88d5b" translate="yes" xml:space="preserve">
          <source>If the standby is promoted to be primary during backup, the backup fails.</source>
          <target state="translated">如果在备份过程中,备用设备被提升为主设备,则备份失败。</target>
        </trans-unit>
        <trans-unit id="ae6c2a2f4f7ec1ece5d1140f847b0d38361211e2" translate="yes" xml:space="preserve">
          <source>If the standby is promoted to the master during online backup, the backup fails.</source>
          <target state="translated">如果在在线备份过程中,备用设备被提升为主设备,则备份失败。</target>
        </trans-unit>
        <trans-unit id="170908acbec1d5cb0f56e23febc172e3426f4e91" translate="yes" xml:space="preserve">
          <source>If the standby server fails then no failover need take place. If the standby server can be restarted, even some time later, then the recovery process can also be restarted immediately, taking advantage of restartable recovery. If the standby server cannot be restarted, then a full new standby server instance should be created.</source>
          <target state="translated">如果备用服务器发生故障,那么不需要进行故障转移。如果备用服务器可以重启,甚至在一段时间后,那么也可以立即重启恢复过程,利用可重启恢复的优势。如果备用服务器不能重启,那么应该创建一个完整的新的备用服务器实例。</target>
        </trans-unit>
        <trans-unit id="05b0c76b7db4a1477637a64b2d47050fce69810a" translate="yes" xml:space="preserve">
          <source>If the standby servers are still running, stop them now using the above instructions.</source>
          <target state="translated">如果备用服务器仍在运行,请使用上述说明立即停止它们。</target>
        </trans-unit>
        <trans-unit id="6049edf261150bf348be6f8bb80514f565d9d8f9" translate="yes" xml:space="preserve">
          <source>If the state transition function is declared &amp;ldquo;strict&amp;rdquo;, then it cannot be called with null inputs. With such a transition function, aggregate execution behaves as follows. Rows with any null input values are ignored (the function is not called and the previous state value is retained). If the initial state value is null, then at the first row with all-nonnull input values, the first argument value replaces the state value, and the transition function is invoked at each subsequent row with all-nonnull input values. This is handy for implementing aggregates like &lt;code&gt;max&lt;/code&gt;. Note that this behavior is only available when &lt;code&gt;state_data_type&lt;/code&gt; is the same as the first &lt;code&gt;arg_data_type&lt;/code&gt;. When these types are different, you must supply a nonnull initial condition or use a nonstrict transition function.</source>
          <target state="translated">如果状态转换函数被声明为&amp;ldquo;严格&amp;rdquo;，则不能使用空输入来调用它。使用这种转换函数，聚合执行的行为如下。输入值为空的行将被忽略（不调用该函数，并且保留先前的状态值）。如果初始状态值为null，则在第一行具有全非空输入值的情况下，第一个自变量值将替换状态值，并且在随后的每一行具有全非空输入值的情况下调用转换函数。这对于实现像 &lt;code&gt;max&lt;/code&gt; 这样的聚合非常方便。请注意，只有当 &lt;code&gt;state_data_type&lt;/code&gt; 与第一个 &lt;code&gt;arg_data_type&lt;/code&gt; 相同时，此行为才可用。当这些类型不同时，必须提供一个非空的初始条件或使用一个非严格的转换函数。</target>
        </trans-unit>
        <trans-unit id="b6d30b33fa764833043e35a291ca75c71eaca53e" translate="yes" xml:space="preserve">
          <source>If the state transition function is not strict, then it will be called unconditionally at each input row, and must deal with null inputs and null state values for itself. This allows the aggregate author to have full control over the aggregate's handling of null values.</source>
          <target state="translated">如果状态转换函数不严格,那么它将在每个输入行无条件调用,必须自己处理空输入和空状态值。这使得集合作者可以完全控制集合对空值的处理。</target>
        </trans-unit>
        <trans-unit id="244bd5a12cbdca1f48ebb0a6febfdca5da532447" translate="yes" xml:space="preserve">
          <source>If the string is declared to be of type &lt;code&gt;varchar&lt;/code&gt;, as might be the case if it comes from a table, then the parser will try to convert it to become &lt;code&gt;text&lt;/code&gt;:</source>
          <target state="translated">如果该字符串声明为 &lt;code&gt;varchar&lt;/code&gt; 类型（如来自表），则解析器将尝试将其转换为 &lt;code&gt;text&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2dcfcecbf90e5089ccafce06b4b0be1f8904c94c" translate="yes" xml:space="preserve">
          <source>If the subtype is considered to have discrete rather than continuous values, the &lt;code&gt;CREATE TYPE&lt;/code&gt; command should specify a &lt;code&gt;canonical&lt;/code&gt; function. The canonicalization function takes an input range value, and must return an equivalent range value that may have different bounds and formatting. The canonical output for two ranges that represent the same set of values, for example the integer ranges &lt;code&gt;[1, 7]&lt;/code&gt; and &lt;code&gt;[1, 8)&lt;/code&gt;, must be identical. It doesn't matter which representation you choose to be the canonical one, so long as two equivalent values with different formattings are always mapped to the same value with the same formatting. In addition to adjusting the inclusive/exclusive bounds format, a canonicalization function might round off boundary values, in case the desired step size is larger than what the subtype is capable of storing. For instance, a range type over &lt;code&gt;timestamp&lt;/code&gt; could be defined to have a step size of an hour, in which case the canonicalization function would need to round off bounds that weren't a multiple of an hour, or perhaps throw an error instead.</source>
          <target state="translated">如果认为子类型具有离散值而不是连续值，则 &lt;code&gt;CREATE TYPE&lt;/code&gt; 命令应指定 &lt;code&gt;canonical&lt;/code&gt; 函数。规范化函数采用输入范围值，并且必须返回可能具有不同范围和格式的等效范围值。代表同一组值的两个范围的规范输出，例如整数范围 &lt;code&gt;[1, 7]&lt;/code&gt; 和 &lt;code&gt;[1, 8)&lt;/code&gt; ，必须相同。只要选择将两种表示形式相同的值始终映射为相同的值，则选择哪种表示形式都没关系。除了调整包含/排除边界格式之外，在所需步长大于子类型能够存储的步长的情况下，规范化函数还可以舍入边界值。例如，可以将 &lt;code&gt;timestamp&lt;/code&gt; 的范围类型定义为一个小时的步长，在这种情况下，规范化功能将需要舍入不是一个小时数倍的边界，或者可能抛出错误。</target>
        </trans-unit>
        <trans-unit id="417d560f70c3f29f36f195f746fd3ca8a01a2c42" translate="yes" xml:space="preserve">
          <source>If the system administrator for the server's machine cannot be trusted, it is necessary for the client to encrypt the data; this way, unencrypted data never appears on the database server. Data is encrypted on the client before being sent to the server, and database results have to be decrypted on the client before being used.</source>
          <target state="translated">如果不能信任服务器机器的系统管理员,就需要客户端对数据进行加密,这样,未加密的数据永远不会出现在数据库服务器上。数据在发送到服务器之前,先在客户端进行加密,数据库的结果必须在客户端进行解密后才能使用。</target>
        </trans-unit>
        <trans-unit id="2b3f5f95bd715dfe464206f06b66a58f56802c50" translate="yes" xml:space="preserve">
          <source>If the table as a whole is exclusive-locked by someone else, &lt;code&gt;pgrowlocks&lt;/code&gt; will be blocked.</source>
          <target state="translated">如果整个表被其他人排他锁定，则 &lt;code&gt;pgrowlocks&lt;/code&gt; 将被阻止。</target>
        </trans-unit>
        <trans-unit id="b50348338bc555a4ab7d45126bfb8dabd633e20f" translate="yes" xml:space="preserve">
          <source>If the table being analyzed has one or more children, &lt;code&gt;ANALYZE&lt;/code&gt; will gather statistics twice: once on the rows of the parent table only, and a second time on the rows of the parent table with all of its children. This second set of statistics is needed when planning queries that traverse the entire inheritance tree. The autovacuum daemon, however, will only consider inserts or updates on the parent table itself when deciding whether to trigger an automatic analyze for that table. If that table is rarely inserted into or updated, the inheritance statistics will not be up to date unless you run &lt;code&gt;ANALYZE&lt;/code&gt; manually.</source>
          <target state="translated">如果要分析的表有一个或多 &lt;code&gt;ANALYZE&lt;/code&gt; 表，则ANALYZE将收集两次统计信息：一次仅在父表的行上，第二次在父表及其所有子表的行上。当计划遍历整个继承树的查询时，需要第二组统计信息。但是，autovacuum守护程序在决定是否触发对该表的自动分析时仅考虑对父表本身进行插入或更新。如果该表很少插入或更新，则继承统计信息不会是最新的，除非您手动运行 &lt;code&gt;ANALYZE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b96d4460f730e99ad2f5da4b8998b3d561a93287" translate="yes" xml:space="preserve">
          <source>If the table being analyzed is completely empty, &lt;code&gt;ANALYZE&lt;/code&gt; will not record new statistics for that table. Any existing statistics will be retained.</source>
          <target state="translated">如果要分析的表完全为空，则 &lt;code&gt;ANALYZE&lt;/code&gt; 不会记录该表的新统计信息。任何现有的统计信息都将保留。</target>
        </trans-unit>
        <trans-unit id="52dc63831209a4c7bb3899cf1fb2ddca1ef42d36" translate="yes" xml:space="preserve">
          <source>If the table is being scanned using an index, this is the OID of the index being used; otherwise, it is zero.</source>
          <target state="translated">如果表正在使用索引进行扫描,这就是正在使用的索引的OID;否则,它为零。</target>
        </trans-unit>
        <trans-unit id="dd0fa542dae151db3f272ca82de26368bfb9872f" translate="yes" xml:space="preserve">
          <source>If the target directory is specified as &lt;code&gt;-&lt;/code&gt; (dash), the tar contents will be written to standard output, suitable for piping to (for example) gzip. This is only allowed if the cluster has no additional tablespaces and WAL streaming is not used.</source>
          <target state="translated">如果将目标目录指定为 &lt;code&gt;-&lt;/code&gt; （破折号），则tar内容将写入标准输出，适用于管道传输到（例如）gzip。仅当群集没有其他表空间并且不使用WAL流时才允许这样做。</target>
        </trans-unit>
        <trans-unit id="9dfb9ffd9573334faeebb68db3d3df9b1f1f0724" translate="yes" xml:space="preserve">
          <source>If the token is an alphabetic string, match up with possible strings:</source>
          <target state="translated">如果标记是一个字母字符串,则与可能的字符串进行匹配。</target>
        </trans-unit>
        <trans-unit id="4f40be80901959628e05aea1c30e86478bf9dbb2" translate="yes" xml:space="preserve">
          <source>If the token is numeric only, then it is either a single field or an ISO 8601 concatenated date (e.g., &lt;code&gt;19990113&lt;/code&gt; for January 13, 1999) or time (e.g., &lt;code&gt;141516&lt;/code&gt; for 14:15:16).</source>
          <target state="translated">如果令牌仅是数字，则它是单个字段或ISO 8601串联日期（例如， &lt;code&gt;19990113&lt;/code&gt; 表示1999年1月13日）或时间（例如 &lt;code&gt;141516&lt;/code&gt; 表示14:15:16）。</target>
        </trans-unit>
        <trans-unit id="003398a89e69d2198b671a9677907bb24f534582" translate="yes" xml:space="preserve">
          <source>If the token is three digits and a year has already been read, then interpret as day of year.</source>
          <target state="translated">如果令牌是三位数,并且已经读出了年份,则解释为年月日。</target>
        </trans-unit>
        <trans-unit id="d3ac616dded1315bedadfd2b91efaa1cf49163f8" translate="yes" xml:space="preserve">
          <source>If the token starts with a plus (&lt;code&gt;+&lt;/code&gt;) or minus (&lt;code&gt;-&lt;/code&gt;), then it is either a numeric time zone or a special field.</source>
          <target state="translated">如果令牌以加号（ &lt;code&gt;+&lt;/code&gt; ）或减号（ &lt;code&gt;-&lt;/code&gt; ）开头，则它可以是数字时区或特殊字段。</target>
        </trans-unit>
        <trans-unit id="611739a43cf34a105bb65434365f4074cf8756df" translate="yes" xml:space="preserve">
          <source>If the transaction modified any run-time parameters with &lt;code&gt;SET&lt;/code&gt; (without the &lt;code&gt;LOCAL&lt;/code&gt; option), those effects persist after &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt;, and will not be affected by any later &lt;code&gt;COMMIT PREPARED&lt;/code&gt; or &lt;code&gt;ROLLBACK PREPARED&lt;/code&gt;. Thus, in this one respect &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; acts more like &lt;code&gt;COMMIT&lt;/code&gt; than &lt;code&gt;ROLLBACK&lt;/code&gt;.</source>
          <target state="translated">如果事务使用 &lt;code&gt;SET&lt;/code&gt; 修改了任何运行时参数（没有 &lt;code&gt;LOCAL&lt;/code&gt; 选项），则这些影响在 &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; 之后仍然存在，并且不会受到以后任何 &lt;code&gt;COMMIT PREPARED&lt;/code&gt; 或 &lt;code&gt;ROLLBACK PREPARED&lt;/code&gt; 的影响。因此，在这一方面， &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; 的行为更像 &lt;code&gt;COMMIT&lt;/code&gt; 而不是 &lt;code&gt;ROLLBACK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="07ad8422becd50d9414841f3815863dc01f955f6" translate="yes" xml:space="preserve">
          <source>If the type being ordered (&lt;code&gt;type1&lt;/code&gt;) is collatable, the appropriate collation OID will be passed to the &lt;code&gt;in_range&lt;/code&gt; function, using the standard PG_GET_COLLATION() mechanism.</source>
          <target state="translated">如果要排序的类型（ &lt;code&gt;type1&lt;/code&gt; ）是可排序的， &lt;code&gt;in_range&lt;/code&gt; 使用标准PG_GET_COLLATION（）机制将适当的排序规则OID传递给in_range函数。</target>
        </trans-unit>
        <trans-unit id="0affc2c3fcf33ac8518f76b37e69d5d8764c5216" translate="yes" xml:space="preserve">
          <source>If the unique constraint is deferrable, there is additional complexity: we need to be able to insert an index entry for a new row, but defer any uniqueness-violation error until end of statement or even later. To avoid unnecessary repeat searches of the index, the index access method should do a preliminary uniqueness check during the initial insertion. If this shows that there is definitely no conflicting live tuple, we are done. Otherwise, we schedule a recheck to occur when it is time to enforce the constraint. If, at the time of the recheck, both the inserted tuple and some other tuple with the same key are live, then the error must be reported. (Note that for this purpose, &amp;ldquo;live&amp;rdquo; actually means &amp;ldquo;any tuple in the index entry's HOT chain is live&amp;rdquo;.) To implement this, the &lt;code&gt;aminsert&lt;/code&gt; function is passed a &lt;code&gt;checkUnique&lt;/code&gt; parameter having one of the following values:</source>
          <target state="translated">如果唯一性约束是可延迟的，则会带来更多的复杂性：我们需要能够为新行插入索引条目，但是将任何违反唯一性的错误推迟到语句结束时或更晚。为避免不必要的重复搜索索引，索引访问方法应在初始插入期间进行初步的唯一性检查。如果这表明绝对没有冲突的活动元组，那么我们就完成了。否则，我们计划在应该执行约束时进行一次重新检查。如果在重新检查时插入的元组和其他具有相同键的元组都处于活动状态，则必须报告错误。 （请注意，为此目的，&amp;ldquo;实时&amp;rdquo;实际上意味着&amp;ldquo;索引条目的HOT链中的任何元组都是实时的&amp;rdquo;。）要实现这一点，必须向 &lt;code&gt;aminsert&lt;/code&gt; 函数传递一个 &lt;code&gt;checkUnique&lt;/code&gt; 具有以下值之一的checkUnique参数：</target>
        </trans-unit>
        <trans-unit id="0ccba0a1dbc7e9db8732870253e268a51ede19e4" translate="yes" xml:space="preserve">
          <source>If the value &lt;code&gt;-&lt;/code&gt; (dash) is specified as target directory, the tar contents will be written to standard output, suitable for piping to for example gzip. This is only possible if the cluster has no additional tablespaces and WAL streaming is not used.</source>
          <target state="translated">如果将值 &lt;code&gt;-&lt;/code&gt; （破折号）指定为目标目录，则tar内容将写入标准输出，适用于通过管道传输到例如gzip。仅当群集没有其他表空间并且不使用WAL流时，才有可能这样做。</target>
        </trans-unit>
        <trans-unit id="444b2da78b5aef7c45b208ec5e7f996fc4602364" translate="yes" xml:space="preserve">
          <source>If the value is 1 (the default) or above, float values are output in shortest-precise format; see &lt;a href=&quot;datatype-numeric#DATATYPE-FLOAT&quot;&gt;Section 8.1.3&lt;/a&gt;. The actual number of digits generated depends only on the value being output, not on the value of this parameter. At most 17 digits are required for &lt;code&gt;float8&lt;/code&gt; values, and 9 for &lt;code&gt;float4&lt;/code&gt; values. This format is both fast and precise, preserving the original binary float value exactly when correctly read. For historical compatibility, values up to 3 are permitted.</source>
          <target state="translated">如果该值为1（默认值）或更高，则浮点值以最短精度格式输出；否则为0。见&lt;a href=&quot;datatype-numeric#DATATYPE-FLOAT&quot;&gt;8.1.3节&lt;/a&gt;。实际生成的位数仅取决于输出的值，而不取决于此参数的值。 &lt;code&gt;float8&lt;/code&gt; 值最多需要17位数字， &lt;code&gt;float4&lt;/code&gt; 值最多需要9 位数字。这种格式既快速又精确，在正确读取时会准确保留原始二进制浮点值。为了历史兼容，允许的值最大为3。</target>
        </trans-unit>
        <trans-unit id="7b8c00d10368663be17d060a1553cbcac67af360" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;always&lt;/code&gt;, then color is used.</source>
          <target state="translated">如果该值 &lt;code&gt;always&lt;/code&gt; ，则使用颜色。</target>
        </trans-unit>
        <trans-unit id="a3241b1b5ac7bee371703180a8744c53db79636d" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;auto&lt;/code&gt; and the standard error stream is associated with a terminal device, then color is used.</source>
          <target state="translated">如果该值为 &lt;code&gt;auto&lt;/code&gt; ，并且标准错误流与终端设备相关联，则使用颜色。</target>
        </trans-unit>
        <trans-unit id="a0cc84e480979f938d4633f92cd03d8f6fccf694" translate="yes" xml:space="preserve">
          <source>If the value is zero or negative, then the output is rounded to a given decimal precision. The precision used is the standard number of digits for the type (&lt;code&gt;FLT_DIG&lt;/code&gt; or &lt;code&gt;DBL_DIG&lt;/code&gt; as appropriate) reduced according to the value of this parameter. (For example, specifying -1 will cause &lt;code&gt;float4&lt;/code&gt; values to be output rounded to 5 significant digits, and &lt;code&gt;float8&lt;/code&gt; values rounded to 14 digits.) This format is slower and does not preserve all the bits of the binary float value, but may be more human-readable.</source>
          <target state="translated">如果值为零或负数，则将输出舍入为给定的十进制精度。使用的精度是根据该参数的值而减少的类型（适当时为 &lt;code&gt;FLT_DIG&lt;/code&gt; 或 &lt;code&gt;DBL_DIG&lt;/code&gt; ）的标准位数。 （例如，指定-1将导致将 &lt;code&gt;float4&lt;/code&gt; 值四舍五入为5个有效数字，而将 &lt;code&gt;float8&lt;/code&gt; 值四舍五入为14个数字。）此格式较慢，不会保留二进制float值的所有位，但可能会更多人类可读的。</target>
        </trans-unit>
        <trans-unit id="1bde8627196fca1b915cdbfcafe6a9bc91cc16ce" translate="yes" xml:space="preserve">
          <source>If the value written for an element is &lt;code&gt;NULL&lt;/code&gt; (in any case variant), the element is taken to be NULL. The presence of any quotes or backslashes disables this and allows the literal string value &amp;ldquo;NULL&amp;rdquo; to be entered. Also, for backward compatibility with pre-8.2 versions of PostgreSQL, the &lt;a href=&quot;runtime-config-compatible#GUC-ARRAY-NULLS&quot;&gt;array_nulls&lt;/a&gt; configuration parameter can be turned &lt;code&gt;off&lt;/code&gt; to suppress recognition of &lt;code&gt;NULL&lt;/code&gt; as a NULL.</source>
          <target state="translated">如果为元素写入的值为 &lt;code&gt;NULL&lt;/code&gt; （在任何情况下都是变体），则该元素被视为NULL。如果存在任何引号或反斜杠，则会禁用此功能，并允许输入文字字符串值&amp;ldquo; NULL&amp;rdquo;。另外，为了与PostgreSQL 8.2之前的版本向后兼容，可以 &lt;code&gt;off&lt;/code&gt; &lt;a href=&quot;runtime-config-compatible#GUC-ARRAY-NULLS&quot;&gt;array_nulls&lt;/a&gt;配置参数以禁止将 &lt;code&gt;NULL&lt;/code&gt; 识别为NULL。</target>
        </trans-unit>
        <trans-unit id="c41c4c976de57b5cc72ea9d7bfdcc6564b8b256b" translate="yes" xml:space="preserve">
          <source>If the view is automatically updatable the system will convert any &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; statement on the view into the corresponding statement on the underlying base relation. &lt;code&gt;INSERT&lt;/code&gt; statements that have an &lt;code&gt;ON CONFLICT UPDATE&lt;/code&gt; clause are fully supported.</source>
          <target state="translated">如果视图是可自动更新的，则系统会将视图上的所有 &lt;code&gt;INSERT&lt;/code&gt; ， &lt;code&gt;UPDATE&lt;/code&gt; 或 &lt;code&gt;DELETE&lt;/code&gt; 语句转换为基础基本关系上的相应语句。完全支持具有 &lt;code&gt;ON CONFLICT UPDATE&lt;/code&gt; 子句的 &lt;code&gt;INSERT&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="650d690f75ae406d20b34e538980576f232072f4" translate="yes" xml:space="preserve">
          <source>If the width comes from a function argument, that argument is consumed before the argument that is used for the format specifier's value. If the width argument is negative, the result is left aligned (as if the &lt;code&gt;-&lt;/code&gt; flag had been specified) within a field of length &lt;code&gt;abs&lt;/code&gt;(&lt;code&gt;width&lt;/code&gt;).</source>
          <target state="translated">如果宽度来自函数参数，则该参数将在用于格式说明符值的参数之前使用。如果width参数为负，则结果在 &lt;code&gt;abs&lt;/code&gt; （ &lt;code&gt;width&lt;/code&gt; ）长度的字段内保持对齐（就像已指定 &lt;code&gt;-&lt;/code&gt; 标志）。</target>
        </trans-unit>
        <trans-unit id="8438b6c9a8a0c469032906dcee3641b321408b8e" translate="yes" xml:space="preserve">
          <source>If the width comes from a function argument, that argument is consumed before the argument that is used for the format specifier's value. If the width argument is negative, the result is left aligned (as if the &lt;code&gt;-&lt;/code&gt; flag had been specified) within a field of length &lt;code&gt;abs&lt;/code&gt;(&lt;em&gt;&lt;code&gt;width&lt;/code&gt;&lt;/em&gt;).</source>
          <target state="translated">如果宽度来自函数自变量，则该自变量将在用于格式说明符值的自变量之前使用。如果width参数为负，则结果在 &lt;code&gt;abs&lt;/code&gt; （&lt;em&gt; &lt;code&gt;width&lt;/code&gt; &lt;/em&gt;）长度的字段内保持对齐（就像已指定 &lt;code&gt;-&lt;/code&gt; 标志）。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ee835cdf2017b10d24cc5c26f6abffc684a96735" translate="yes" xml:space="preserve">
          <source>If there are both &lt;code&gt;unknown&lt;/code&gt; and known-type arguments, and all the known-type arguments have the same type, assume that the &lt;code&gt;unknown&lt;/code&gt; arguments are also of that type, and check which candidates can accept that type at the &lt;code&gt;unknown&lt;/code&gt;-argument positions. If exactly one candidate passes this test, use it. Otherwise, fail.</source>
          <target state="translated">如果同时存在 &lt;code&gt;unknown&lt;/code&gt; 参数和已知类型参数，并且所有已知类型参数都具有相同类型，则假定 &lt;code&gt;unknown&lt;/code&gt; 参数也属于该类型，并检查哪些候选者可以在 &lt;code&gt;unknown&lt;/code&gt; 参数位置接受该类型。如果恰好有一位候选人通过了此测试，请使用它。否则，失败。</target>
        </trans-unit>
        <trans-unit id="13cac4b83f93f0a857eb5390b899f2b2b2cbf1c2" translate="yes" xml:space="preserve">
          <source>If there are conflicting non-default implicit collations among the input expressions, then the combination is deemed to have indeterminate collation. This is not an error condition unless the particular function being invoked requires knowledge of the collation it should apply. If it does, an error will be raised at run-time.</source>
          <target state="translated">如果输入表达式中存在相互冲突的非默认隐式整理,那么这个组合就被认为具有不确定的整理。这不是一个错误条件,除非被调用的特定函数需要知道它应该应用的拼写。如果需要,则会在运行时引发一个错误。</target>
        </trans-unit>
        <trans-unit id="28d65a2d08624ffa80deb6c7246a1682969ee379" translate="yes" xml:space="preserve">
          <source>If there are eight or six digits, and if no other date fields have been previously read, then interpret as a &amp;ldquo;concatenated date&amp;rdquo; (e.g., &lt;code&gt;19990118&lt;/code&gt; or &lt;code&gt;990118&lt;/code&gt;). The interpretation is &lt;code&gt;YYYYMMDD&lt;/code&gt; or &lt;code&gt;YYMMDD&lt;/code&gt;.</source>
          <target state="translated">如果有八位或六位数字，并且以前没有读取过其他日期字段，则将其解释为&amp;ldquo;并置日期&amp;rdquo;（例如 &lt;code&gt;19990118&lt;/code&gt; 或 &lt;code&gt;990118&lt;/code&gt; ）。解释为 &lt;code&gt;YYYYMMDD&lt;/code&gt; 或 &lt;code&gt;YYMMDD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="06c3232f6496ea373f86e0b58b23d8cc590947a5" translate="yes" xml:space="preserve">
          <source>If there are separate indexes on several of the columns referenced in &lt;code&gt;WHERE&lt;/code&gt;, the planner might choose to use an AND or OR combination of the indexes:</source>
          <target state="translated">如果在 &lt;code&gt;WHERE&lt;/code&gt; 中引用的几列上有单独的索引，则计划者可能选择使用索引的AND或OR组合：</target>
        </trans-unit>
        <trans-unit id="99c2725fb0d24809952a5ff770d9ef79057a3c26" translate="yes" xml:space="preserve">
          <source>If there are triggers (&lt;a href=&quot;https://www.postgresql.org/docs/12/triggers.html&quot;&gt;Chapter 38&lt;/a&gt;) on the target table, the data available to &lt;code&gt;RETURNING&lt;/code&gt; is the row as modified by the triggers. Thus, inspecting columns computed by triggers is another common use-case for &lt;code&gt;RETURNING&lt;/code&gt;.</source>
          <target state="translated">如果目标表上有触发器（&lt;a href=&quot;https://www.postgresql.org/docs/12/triggers.html&quot;&gt;第38章&lt;/a&gt;），则 &lt;code&gt;RETURNING&lt;/code&gt; 可用的数据是由触发器修改的行。因此，检查由触发器计算的列是 &lt;code&gt;RETURNING&lt;/code&gt; 的另一个常见用例。</target>
        </trans-unit>
        <trans-unit id="531c18479c37e8661718c4bf106b66a87df84c58" translate="yes" xml:space="preserve">
          <source>If there are triggers (&lt;a href=&quot;https://www.postgresql.org/docs/13/triggers.html&quot;&gt;Chapter 38&lt;/a&gt;) on the target table, the data available to &lt;code&gt;RETURNING&lt;/code&gt; is the row as modified by the triggers. Thus, inspecting columns computed by triggers is another common use-case for &lt;code&gt;RETURNING&lt;/code&gt;.</source>
          <target state="translated">如果目标表上有触发器（&lt;a href=&quot;https://www.postgresql.org/docs/13/triggers.html&quot;&gt;第38章&lt;/a&gt;），则 &lt;code&gt;RETURNING&lt;/code&gt; 可用的数据是由触发器修改的行。因此，检查由触发器计算的列是 &lt;code&gt;RETURNING&lt;/code&gt; 的另一个常见用例。</target>
        </trans-unit>
        <trans-unit id="5b8c31e042fe2150c30030dae6c6269655420443" translate="yes" xml:space="preserve">
          <source>If there is a need to filter or group rows after the window calculations are performed, you can use a sub-select. For example:</source>
          <target state="translated">如果在窗口计算完成后,需要对行进行过滤或分组,可以使用子选择。例如:</target>
        </trans-unit>
        <trans-unit id="cffa77db1a4b360ae7233f9c0f0ce7a0bc209389" translate="yes" xml:space="preserve">
          <source>If there is a record with LSN exactly equal to &lt;code&gt;lsn&lt;/code&gt;, the record will be processed.</source>
          <target state="translated">如果存在LSN完全等于 &lt;code&gt;lsn&lt;/code&gt; 的记录，则将处理该记录。</target>
        </trans-unit>
        <trans-unit id="83cce96057188d3a7386156bf2623596a5029da8" translate="yes" xml:space="preserve">
          <source>If there is an index and we use a query with an indexable &lt;code&gt;WHERE&lt;/code&gt; condition, &lt;code&gt;EXPLAIN&lt;/code&gt; might show a different plan:</source>
          <target state="translated">如果存在索引，并且我们使用具有可索引 &lt;code&gt;WHERE&lt;/code&gt; 条件的查询，则 &lt;code&gt;EXPLAIN&lt;/code&gt; 可能会显示不同的计划：</target>
        </trans-unit>
        <trans-unit id="ed6480e8e6205c3cafadde0e83045f72ff5c9888" translate="yes" xml:space="preserve">
          <source>If there is more than one direct parent for a child table (multiple inheritance), this number tells the order in which the inherited columns are to be arranged. The count starts at 1.</source>
          <target state="translated">如果一个子表有一个以上的直接父表(多重继承),这个数字告诉继承的列的排列顺序。计数从1开始。</target>
        </trans-unit>
        <trans-unit id="b83d35fcbb1d8a1926cc7ad31b3e2d51f2485b81" translate="yes" xml:space="preserve">
          <source>If there is no setting named &lt;em&gt;&lt;code&gt;setting_name&lt;/code&gt;&lt;/em&gt;, &lt;code&gt;current_setting&lt;/code&gt; throws an error unless &lt;em&gt;&lt;code&gt;missing_ok&lt;/code&gt;&lt;/em&gt; is supplied and is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果没有名为&lt;em&gt; &lt;code&gt;setting_name&lt;/code&gt; 的设置&lt;/em&gt;，则除非提供&lt;em&gt; &lt;code&gt;missing_ok&lt;/code&gt; &lt;/em&gt;并且它为 &lt;code&gt;true&lt;/code&gt; ,否则 &lt;code&gt;current_setting&lt;/code&gt; 会引发错误。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="993f6bab11125bc0a23a8d9c66d2ae0ec051d5b8" translate="yes" xml:space="preserve">
          <source>If there's a record with LSN exactly equal to &lt;code&gt;lsn&lt;/code&gt;, the record will be output.</source>
          <target state="translated">如果存在一个LSN完全等于 &lt;code&gt;lsn&lt;/code&gt; 的记录，那么将输出该记录。</target>
        </trans-unit>
        <trans-unit id="51e95a5e2098ab1866ec414690874be8c0926635" translate="yes" xml:space="preserve">
          <source>If these two fundamental requirements are met, then all the data values required by the query are available from the index, so an index-only scan is physically possible. But there is an additional requirement for any table scan in PostgreSQL: it must verify that each retrieved row be &amp;ldquo;visible&amp;rdquo; to the query's MVCC snapshot, as discussed in &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;. Visibility information is not stored in index entries, only in heap entries; so at first glance it would seem that every row retrieval would require a heap access anyway. And this is indeed the case, if the table row has been modified recently. However, for seldom-changing data there is a way around this problem. PostgreSQL tracks, for each page in a table's heap, whether all rows stored in that page are old enough to be visible to all current and future transactions. This information is stored in a bit in the table's &lt;em&gt;visibility map&lt;/em&gt;. An index-only scan, after finding a candidate index entry, checks the visibility map bit for the corresponding heap page. If it's set, the row is known visible and so the data can be returned with no further work. If it's not set, the heap entry must be visited to find out whether it's visible, so no performance advantage is gained over a standard index scan. Even in the successful case, this approach trades visibility map accesses for heap accesses; but since the visibility map is four orders of magnitude smaller than the heap it describes, far less physical I/O is needed to access it. In most situations the visibility map remains cached in memory all the time.</source>
          <target state="translated">如果满足了这两个基本要求，则查询所需的所有数据值都可以从索引中获得，因此从物理上讲仅索引扫描是可能的。但是PostgreSQL中的任何表扫描都有一个额外的要求：它必须验证对查询的MVCC快照&amp;ldquo;可见&amp;rdquo;每条检索到的行，如&lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;第13章所述。&lt;/a&gt;。可见性信息不存储在索引条目中，而仅存储在堆条目中。因此乍一看似乎每行检索都将需要堆访问。如果表行最近被修改，的确是这种情况。但是，对于很少更改数据，有一种方法可以解决此问题。 PostgreSQL针对表堆中的每个页面跟踪该页面中存储的所有行是否足够旧，以至于所有当前和将来的事务均可见。此信息存储在表格的&lt;em&gt;可见性图中&lt;/em&gt;。仅索引扫描在找到候选索引条目之后，检查相应堆页面的可见性映射位。如果已设置，则该行是可见的，因此无需进一步的工作即可返回数据。如果未设置，则必须访问堆条目以了解它是否可见，因此与标准索引扫描相比，不会获得性能优势。即使在成功的情况下，这种方法也将可见性地图访问权换成堆访问权。但是由于可见性图比其描述的堆小四个数量级，因此访问它所需的物理I / O少得多。在大多数情况下，可见性图始终保持缓存在内存中。</target>
        </trans-unit>
        <trans-unit id="56f8e9d448a32277ad7decf19037ed4798402174" translate="yes" xml:space="preserve">
          <source>If these two fundamental requirements are met, then all the data values required by the query are available from the index, so an index-only scan is physically possible. But there is an additional requirement for any table scan in PostgreSQL: it must verify that each retrieved row be &amp;ldquo;visible&amp;rdquo; to the query's MVCC snapshot, as discussed in &lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;. Visibility information is not stored in index entries, only in heap entries; so at first glance it would seem that every row retrieval would require a heap access anyway. And this is indeed the case, if the table row has been modified recently. However, for seldom-changing data there is a way around this problem. PostgreSQL tracks, for each page in a table's heap, whether all rows stored in that page are old enough to be visible to all current and future transactions. This information is stored in a bit in the table's &lt;em&gt;visibility map&lt;/em&gt;. An index-only scan, after finding a candidate index entry, checks the visibility map bit for the corresponding heap page. If it's set, the row is known visible and so the data can be returned with no further work. If it's not set, the heap entry must be visited to find out whether it's visible, so no performance advantage is gained over a standard index scan. Even in the successful case, this approach trades visibility map accesses for heap accesses; but since the visibility map is four orders of magnitude smaller than the heap it describes, far less physical I/O is needed to access it. In most situations the visibility map remains cached in memory all the time.</source>
          <target state="translated">如果满足了这两个基本要求，那么查询所需的所有数据值都可以从索引中获得，因此从物理上来说，仅索引扫描是可能的。但是PostgreSQL中的任何表扫描都有一个额外的要求：它必须验证对查询的MVCC快照&amp;ldquo;可见&amp;rdquo;每条检索到的行，如&lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;第13章所述。&lt;/a&gt;。可见性信息不存储在索引条目中，而仅存储在堆条目中。因此乍一看似乎每行检索都将需要堆访问。如果表行最近被修改，的确是这种情况。但是，对于很少更改数据，有一种方法可以解决此问题。PostgreSQL针对表堆中的每个页面跟踪该页面中存储的所有行是否足够旧，以至于所有当前和将来的事务均可见。该信息存储在表的&lt;em&gt;可见性图中的一小部分&lt;/em&gt;。仅索引扫描在找到候选索引条目之后，检查相应堆页面的可见性映射位。如果已设置，则该行是可见的，因此无需进一步的工作即可返回数据。如果未设置，则必须访问堆条目以了解它是否可见，因此与标准索引扫描相比，不会获得性能优势。即使在成功的情况下，这种方法也将可见性地图访问权换成堆访问权。但是由于可见性图比它描述的堆小四个数量级，因此访问它所需的物理I / O少得多。在大多数情况下，可见性图始终保持缓存在内存中。</target>
        </trans-unit>
        <trans-unit id="8eca355b7b540d6c38ac123a39e5c7bfe77f82a8" translate="yes" xml:space="preserve">
          <source>If this clause is specified, then any values supplied for identity columns are ignored and the default sequence-generated values are applied.</source>
          <target state="translated">如果指定了这个子句,那么为标识列提供的任何值都会被忽略,并应用默认的序列生成的值。</target>
        </trans-unit>
        <trans-unit id="c547d5a570870983467a7ef7a622b57db3de5cb6" translate="yes" xml:space="preserve">
          <source>If this clause is specified, then any values supplied for identity columns defined as &lt;code&gt;GENERATED BY DEFAULT&lt;/code&gt; are ignored and the default sequence-generated values are applied.</source>
          <target state="translated">如果指定了此子句，那么将忽略为定义为 &lt;code&gt;GENERATED BY DEFAULT&lt;/code&gt; 的标识列提供的任何值，并应用默认的序列生成的值。</target>
        </trans-unit>
        <trans-unit id="33eceb951fc008dd28e5a104ea6147dca30fa083" translate="yes" xml:space="preserve">
          <source>If this clause is specified, then any values supplied for identity columns will override the default sequence-generated values.</source>
          <target state="translated">如果指定了这个子句,那么为identity列提供的任何值将覆盖默认的序列生成的值。</target>
        </trans-unit>
        <trans-unit id="bc20641c7b7db884166e9f2d507911850e3a7612" translate="yes" xml:space="preserve">
          <source>If this file exists in the data directory, pg_ctl (in &lt;code&gt;restart&lt;/code&gt; mode) will pass the contents of the file as options to postgres, unless overridden by the &lt;code&gt;-o&lt;/code&gt; option. The contents of this file are also displayed in &lt;code&gt;status&lt;/code&gt; mode.</source>
          <target state="translated">如果该文件存在于数据目录中，则pg_ctl（在 &lt;code&gt;restart&lt;/code&gt; 模式下）会将文件内容作为选项传递给postgres，除非被 &lt;code&gt;-o&lt;/code&gt; 选项覆盖。该文件的内容也以 &lt;code&gt;status&lt;/code&gt; 模式显示。</target>
        </trans-unit>
        <trans-unit id="50767742cba8dcb6350d1c58ae8e0156ac5a9fe6" translate="yes" xml:space="preserve">
          <source>If this happens, you will see a kernel message that looks like this (consult your system documentation and configuration on where to look for such a message):</source>
          <target state="translated">如果发生这种情况,你会看到一个类似于这样的内核消息(请查阅你的系统文档和配置,了解哪里可以找到这样的消息)。</target>
        </trans-unit>
        <trans-unit id="2441da5aa28be6dd0d7fce7180a9ead106be298e" translate="yes" xml:space="preserve">
          <source>If this is a composite type (see &lt;code&gt;typtype&lt;/code&gt;), then this column points to the &lt;code&gt;pg_class&lt;/code&gt; entry that defines the corresponding table. (For a free-standing composite type, the &lt;code&gt;pg_class&lt;/code&gt; entry doesn't really represent a table, but it is needed anyway for the type's &lt;code&gt;pg_attribute&lt;/code&gt; entries to link to.) Zero for non-composite types.</source>
          <target state="translated">如果这是复合类型（请参见 &lt;code&gt;typtype&lt;/code&gt; ），则此列指向定义相应表的 &lt;code&gt;pg_class&lt;/code&gt; 条目。（对于一个独立的复合类型， &lt;code&gt;pg_class&lt;/code&gt; 条目实际上并不代表一个表，但是无论如何，该类型的 &lt;code&gt;pg_attribute&lt;/code&gt; 条目都需要链接到该表。）非复合类型为零。</target>
        </trans-unit>
        <trans-unit id="e7bc989c1a71dcf27e6c15912a9e239eb02b9ff1" translate="yes" xml:space="preserve">
          <source>If this is a domain (see &lt;code&gt;typtype&lt;/code&gt;), then &lt;code&gt;typbasetype&lt;/code&gt; identifies the type that this one is based on. Zero if this type is not a domain.</source>
          <target state="translated">如果这是一个域（请参见 &lt;code&gt;typtype&lt;/code&gt; ），则 &lt;code&gt;typbasetype&lt;/code&gt; 标识该域所基于的类型。如果此类型不是域，则为零。</target>
        </trans-unit>
        <trans-unit id="69cd51fd1807ea0656502f0a70cd88e1db17db63" translate="yes" xml:space="preserve">
          <source>If this is a table or an index, the access method used (heap, B-tree, hash, etc.)</source>
          <target state="translated">如果这是一个表或索引,则使用的访问方法(堆、B-树、哈希等)。</target>
        </trans-unit>
        <trans-unit id="a337fd1770acfe173207c700a1060f857464ec35" translate="yes" xml:space="preserve">
          <source>If this is enabled, &lt;code&gt;TRUNCATE&lt;/code&gt; operations performed directly on partitions are not replicated.</source>
          <target state="translated">如果启用此功能，则不会复制直接在分区上执行的 &lt;code&gt;TRUNCATE&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="6657b3960fa7e0cd88d2aa8dcc3b355ae7df8c2d" translate="yes" xml:space="preserve">
          <source>If this is on, you should create users as &lt;code&gt;username@dbname&lt;/code&gt;. When &lt;code&gt;username&lt;/code&gt; is passed by a connecting client, &lt;code&gt;@&lt;/code&gt; and the database name are appended to the user name and that database-specific user name is looked up by the server. Note that when you create users with names containing &lt;code&gt;@&lt;/code&gt; within the SQL environment, you will need to quote the user name.</source>
          <target state="translated">如果启用，则应将用户创建为 &lt;code&gt;username@dbname&lt;/code&gt; 。当连接的客户端传递 &lt;code&gt;username&lt;/code&gt; ， &lt;code&gt;@&lt;/code&gt; 和数据库名将附加到用户名后，服务器将查找该特定于数据库的用户名。请注意，在SQL环境中使用包含 &lt;code&gt;@&lt;/code&gt; 的名称创建用户时，需要用引号引起来。</target>
        </trans-unit>
        <trans-unit id="8483faa9a2017341557263992633a169be114a21" translate="yes" xml:space="preserve">
          <source>If this option is enabled along with &lt;code&gt;compat_realm&lt;/code&gt;, the user name from the Kerberos UPN is used for authentication. If it is disabled (the default), the SAM-compatible user name is used. By default, these two names are identical for new user accounts.</source>
          <target state="translated">如果将此选项与 &lt;code&gt;compat_realm&lt;/code&gt; 一起启用，则使用Kerberos UPN中的用户名进行身份验证。如果禁用（默认），则使用SAM兼容用户名。默认情况下，这两个名称对于新用户帐户是相同的。</target>
        </trans-unit>
        <trans-unit id="371ee180f233c6aad73716af3849b71651b391c0" translate="yes" xml:space="preserve">
          <source>If this option is not specified and the server supports temporary replication slots (version 10 and later), then a temporary replication slot is automatically used for WAL streaming.</source>
          <target state="translated">如果没有指定这个选项,并且服务器支持临时复制槽(版本10及以后),那么一个临时复制槽将自动用于WAL流。</target>
        </trans-unit>
        <trans-unit id="2f8215b3963efef20de5d0e001e32b15d0b1fd74" translate="yes" xml:space="preserve">
          <source>If this parameter contains an &lt;code&gt;=&lt;/code&gt; sign or starts with a valid URI prefix (&lt;code&gt;postgresql://&lt;/code&gt; or &lt;code&gt;postgres://&lt;/code&gt;), it is treated as a &lt;em&gt;&lt;code&gt;conninfo&lt;/code&gt;&lt;/em&gt; string. See &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html&quot;&gt;Section 33.1&lt;/a&gt; for more information.</source>
          <target state="translated">如果此参数包含 &lt;code&gt;=&lt;/code&gt; 符号或以有效的URI前缀（ &lt;code&gt;postgresql://&lt;/code&gt; 或 &lt;code&gt;postgres://&lt;/code&gt; ）&lt;em&gt; &lt;code&gt;conninfo&lt;/code&gt; &lt;/em&gt;，则将其视为&lt;em&gt;conninfo&lt;/em&gt;字符串。有关更多信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html&quot;&gt;第33.1节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eb980e2e2f9be562491c46b5659937146807845b" translate="yes" xml:space="preserve">
          <source>If this parameter contains an &lt;code&gt;=&lt;/code&gt; sign or starts with a valid URI prefix (&lt;code&gt;postgresql://&lt;/code&gt; or &lt;code&gt;postgres://&lt;/code&gt;), it is treated as a &lt;em&gt;&lt;code&gt;conninfo&lt;/code&gt;&lt;/em&gt; string. See &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;Section 33.1.1&lt;/a&gt; for more information.</source>
          <target state="translated">如果此参数包含 &lt;code&gt;=&lt;/code&gt; 符号或以有效的URI前缀（ &lt;code&gt;postgresql://&lt;/code&gt; 或 &lt;code&gt;postgres://&lt;/code&gt; ）&lt;em&gt; &lt;code&gt;conninfo&lt;/code&gt; &lt;/em&gt;，则将其视为&lt;em&gt;conninfo&lt;/em&gt;字符串。有关更多信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;第33.1.1节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e5a94a371e1e757fb5a74a0f350e7a31fdc8b2c2" translate="yes" xml:space="preserve">
          <source>If this parameter is on, the PostgreSQL server will try to make sure that updates are physically written to disk, by issuing &lt;code&gt;fsync()&lt;/code&gt; system calls or various equivalent methods (see &lt;a href=&quot;runtime-config-wal#GUC-WAL-SYNC-METHOD&quot;&gt;wal_sync_method&lt;/a&gt;). This ensures that the database cluster can recover to a consistent state after an operating system or hardware crash.</source>
          <target state="translated">如果启用此参数，则PostgreSQL服务器将通过发出 &lt;code&gt;fsync()&lt;/code&gt; 系统调用或各种等效方法（请参见&lt;a href=&quot;runtime-config-wal#GUC-WAL-SYNC-METHOD&quot;&gt;wal_sync_method&lt;/a&gt;）来尝试确保将更新实际写入磁盘。这样可以确保在操作系统或硬件崩溃后，数据库集群可以恢复到一致的状态。</target>
        </trans-unit>
        <trans-unit id="fdad70218c14320d183b5258a94b057b0b9b82eb" translate="yes" xml:space="preserve">
          <source>If this produces no response then this step was successful and you can skip over the remainder of this section.</source>
          <target state="translated">如果没有产生任何响应,那么这一步就成功了,你可以跳过本节的剩余部分。</target>
        </trans-unit>
        <trans-unit id="3214ef4d2c8d678533f9cd4aff300140581f95e6" translate="yes" xml:space="preserve">
          <source>If this table is a partition, one cannot perform &lt;code&gt;DROP NOT NULL&lt;/code&gt; on a column if it is marked &lt;code&gt;NOT NULL&lt;/code&gt; in the parent table. To drop the &lt;code&gt;NOT NULL&lt;/code&gt; constraint from all the partitions, perform &lt;code&gt;DROP NOT NULL&lt;/code&gt; on the parent table. Even if there is no &lt;code&gt;NOT NULL&lt;/code&gt; constraint on the parent, such a constraint can still be added to individual partitions, if desired; that is, the children can disallow nulls even if the parent allows them, but not the other way around.</source>
          <target state="translated">如果此表是一个分区，则如果在父表中将其标记为 &lt;code&gt;NOT NULL&lt;/code&gt; ，则无法对列执行 &lt;code&gt;DROP NOT NULL&lt;/code&gt; 。要从所有分区中删除 &lt;code&gt;NOT NULL&lt;/code&gt; 约束，请在父表上执行 &lt;code&gt;DROP NOT NULL&lt;/code&gt; 。即使在父级上没有 &lt;code&gt;NOT NULL&lt;/code&gt; 约束，也可以根据需要将此约束添加到各个分区中。也就是说，即使父母允许，孩子也可以禁止null，反之则不行。</target>
        </trans-unit>
        <trans-unit id="8738e67f4faaa26be7e54ea9f241452e99abdc6a" translate="yes" xml:space="preserve">
          <source>If this value is specified without units, it is taken as milliseconds. A value of zero (the default) disables the timeout.</source>
          <target state="translated">如果此值没有指定单位,则以毫秒为单位。值为0(默认值)则禁用超时。</target>
        </trans-unit>
        <trans-unit id="f32c0180b724efe2a022fcb4332eb4cf7431bae9" translate="yes" xml:space="preserve">
          <source>If this value is specified without units, it is taken as minutes. A value of &lt;code&gt;-1&lt;/code&gt; (the default) disables this feature, effectively setting the snapshot age limit to infinity. This parameter can only be set at server start.</source>
          <target state="translated">如果指定的该值不带单位，则以分钟为单位。值 &lt;code&gt;-1&lt;/code&gt; （默认值）将禁用此功能，从而有效地将快照寿命限制设置为无穷大。该参数只能在服务器启动时设置。</target>
        </trans-unit>
        <trans-unit id="a8ab1040fa10ec473399bfff4fa508c435a17bc0" translate="yes" xml:space="preserve">
          <source>If this variable is set to &lt;code&gt;ignorespace&lt;/code&gt;, lines which begin with a space are not entered into the history list. If set to a value of &lt;code&gt;ignoredups&lt;/code&gt;, lines matching the previous history line are not entered. A value of &lt;code&gt;ignoreboth&lt;/code&gt; combines the two options. If set to &lt;code&gt;none&lt;/code&gt; (the default), all lines read in interactive mode are saved on the history list.</source>
          <target state="translated">如果将此变量设置为 &lt;code&gt;ignorespace&lt;/code&gt; ，则以空格开头的行不会输入到历史记录列表中。如果设置为 &lt;code&gt;ignoredups&lt;/code&gt; 的值，则不会输入与上一个历史记录行匹配的行。 &lt;code&gt;ignoreboth&lt;/code&gt; 的值将两个选项结合在一起。如果设置为 &lt;code&gt;none&lt;/code&gt; （默认值），则以交互方式读取的所有行都将保存在历史记录列表中。</target>
        </trans-unit>
        <trans-unit id="7d49403e63b47e4513b7ffed0983ad8f1cca01fe" translate="yes" xml:space="preserve">
          <source>If this variable is set to &lt;code&gt;true&lt;/code&gt;, a table's access method details are not displayed. This is mainly useful for regression tests.</source>
          <target state="translated">如果此变量设置为 &lt;code&gt;true&lt;/code&gt; ，则不显示表的访问方法详细信息。这主要用于回归测试。</target>
        </trans-unit>
        <trans-unit id="a5769546d2d4414640c8fa6c471f59d18a32f49e" translate="yes" xml:space="preserve">
          <source>If this variable is set to an integer value greater than zero, the results of &lt;code&gt;SELECT&lt;/code&gt; queries are fetched and displayed in groups of that many rows, rather than the default behavior of collecting the entire result set before display. Therefore only a limited amount of memory is used, regardless of the size of the result set. Settings of 100 to 1000 are commonly used when enabling this feature. Keep in mind that when using this feature, a query might fail after having already displayed some rows.</source>
          <target state="translated">如果将此变量设置为大于零的整数值，则将提取 &lt;code&gt;SELECT&lt;/code&gt; 查询的结果并将其显示在这么多行的组中，而不是显示之前收集整个结果集的默认行为。因此，无论结果集的大小如何，仅使用有限的内存量。启用此功能时，通常使用100到1000的设置。请记住，使用此功能时，已经显示了一些行之后查询可能会失败。</target>
        </trans-unit>
        <trans-unit id="76778bde620595af53b04af23a5daa5bc5441843" translate="yes" xml:space="preserve">
          <source>If three or more digits and no date fields have yet been found, interpret as a year (this forces yy-mm-dd ordering of the remaining date fields).</source>
          <target state="translated">如果有三个或三个以上的数字,并且没有找到日期字段,则解释为年(这将迫使剩余的日期字段按yy-mm-dd排序)。</target>
        </trans-unit>
        <trans-unit id="81e3a3432036cda1be2139bb1761dc976c1a75c5" translate="yes" xml:space="preserve">
          <source>If true this index has been chosen as &amp;ldquo;replica identity&amp;rdquo; using &lt;code&gt;ALTER TABLE ... REPLICA IDENTITY USING INDEX ...&lt;/code&gt;</source>
          <target state="translated">如果为true，则已使用 &lt;code&gt;ALTER TABLE ... REPLICA IDENTITY USING INDEX ...&lt;/code&gt; 选择该索引作为&amp;ldquo;副本身份&amp;rdquo; ...使用索引的副本身份...</target>
        </trans-unit>
        <trans-unit id="fb3a87dcd25f91900b7d1fcaa4ea022c5ef4621a" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;DELETE&lt;/code&gt; operations are replicated for tables in the publication.</source>
          <target state="translated">如果为true，则为发布中的表复制 &lt;code&gt;DELETE&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="31ebf4870608c0167855b7d0283c52cc09a7d931" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;INSERT&lt;/code&gt; operations are replicated for tables in the publication.</source>
          <target state="translated">如果为true，则为发布中的表复制 &lt;code&gt;INSERT&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="16194e2fdde132d1c172f912b491836e60827cdc" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;TRUNCATE&lt;/code&gt; operations are replicated for tables in the publication.</source>
          <target state="translated">如果为true，则为发布中的表复制 &lt;code&gt;TRUNCATE&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="1ad3497d81a37523e3d7068e040be2588a6f2a7f" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;UPDATE&lt;/code&gt; operations are replicated for tables in the publication.</source>
          <target state="translated">如果为true，将为发布中的表复制 &lt;code&gt;UPDATE&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="f3f8473e6cf008d85556519e04a9be2df3d673dd" translate="yes" xml:space="preserve">
          <source>If true, operations on a leaf partition are replicated using the identity and schema of its topmost partitioned ancestor mentioned in the publication instead of its own.</source>
          <target state="translated">如果为真,对叶子分区的操作将使用出版物中提到的其最上面的分区祖先的身份和模式而不是它自己的身份和模式进行复制。</target>
        </trans-unit>
        <trans-unit id="ec6d4eb0a14744c8cf642983fb247ca8af2c665e" translate="yes" xml:space="preserve">
          <source>If true, queries must not use the index until the &lt;code&gt;xmin&lt;/code&gt; of this &lt;code&gt;pg_index&lt;/code&gt; row is below their &lt;code&gt;TransactionXmin&lt;/code&gt; event horizon, because the table may contain broken HOT chains with incompatible rows that they can see</source>
          <target state="translated">如果为true，则在该 &lt;code&gt;pg_index&lt;/code&gt; 行的 &lt;code&gt;xmin&lt;/code&gt; 低于其 &lt;code&gt;TransactionXmin&lt;/code&gt; 事件范围之前，查询不得使用索引，因为该表可能包含断开的HOT链，且它们具有不兼容的行，它们可以看到</target>
        </trans-unit>
        <trans-unit id="e8ec7f29c2269b6f390b904f6368378dd35f78e8" translate="yes" xml:space="preserve">
          <source>If true, the index is currently ready for inserts. False means the index must be ignored by &lt;code&gt;INSERT&lt;/code&gt;/&lt;code&gt;UPDATE&lt;/code&gt; operations.</source>
          <target state="translated">如果为true，则索引当前可以插入。False表示索引必须被 &lt;code&gt;INSERT&lt;/code&gt; / &lt;code&gt;UPDATE&lt;/code&gt; 操作忽略。</target>
        </trans-unit>
        <trans-unit id="6c0fcf74070493f9e01640902cbfc0c6b38f7360" translate="yes" xml:space="preserve">
          <source>If true, the index is currently valid for queries. False means the index is possibly incomplete: it must still be modified by &lt;code&gt;INSERT&lt;/code&gt;/&lt;code&gt;UPDATE&lt;/code&gt; operations, but it cannot safely be used for queries. If it is unique, the uniqueness property is not guaranteed true either.</source>
          <target state="translated">如果为true，则索引当前对查询有效。False表示索引可能不完整：仍必须通过 &lt;code&gt;INSERT&lt;/code&gt; / &lt;code&gt;UPDATE&lt;/code&gt; 操作对其进行修改，但不能安全地将其用于查询。如果它是唯一的，则也不保证唯一性属性为true。</target>
        </trans-unit>
        <trans-unit id="ab6de0df41664d3b3675c49edb64211adc3a12b2" translate="yes" xml:space="preserve">
          <source>If true, the stats include inheritance child columns, not just the values in the specified relation</source>
          <target state="translated">如果为 &quot;true&quot;,统计包括继承的子列,而不仅仅是指定关系中的值。</target>
        </trans-unit>
        <trans-unit id="ee7718b7881ae44cc98ca7be7fa2735272d5a098" translate="yes" xml:space="preserve">
          <source>If true, the subscription is enabled and should be replicating.</source>
          <target state="translated">如果为真,则说明该订阅已启用,应进行复制。</target>
        </trans-unit>
        <trans-unit id="aa9a0941d117d4d0d6546de8ecf8d6c048b76081" translate="yes" xml:space="preserve">
          <source>If true, the table was last clustered on this index</source>
          <target state="translated">如果为 &quot;true&quot;,则表示该表最后一次聚类是在这个索引上。</target>
        </trans-unit>
        <trans-unit id="0629da4ff91f39f869bbe66ce6c66a0e0b5d1ffd" translate="yes" xml:space="preserve">
          <source>If true, the uniqueness check is enforced immediately on insertion (irrelevant if &lt;code&gt;indisunique&lt;/code&gt; is not true)</source>
          <target state="translated">如果为true，则在插入时立即执行唯一性检查（如果 &lt;code&gt;indisunique&lt;/code&gt; 不为true，则无关紧要）</target>
        </trans-unit>
        <trans-unit id="588ebeeb8e4b96440c5bf3cc0c1bd5854026d4e7" translate="yes" xml:space="preserve">
          <source>If true, then this database can be cloned by any user with &lt;code&gt;CREATEDB&lt;/code&gt; privileges; if false (the default), then only superusers or the owner of the database can clone it.</source>
          <target state="translated">如果为true，则任何具有 &lt;code&gt;CREATEDB&lt;/code&gt; 特权的用户都可以克隆此数据库；如果为false（默认值），则只有超级用户或数据库所有者才能克隆它。</target>
        </trans-unit>
        <trans-unit id="7d71cd9fec73126b99ae1f7d42db7f62a2b72e24" translate="yes" xml:space="preserve">
          <source>If true, then this database can be cloned by any user with &lt;code&gt;CREATEDB&lt;/code&gt; privileges; if false, then only superusers or the owner of the database can clone it.</source>
          <target state="translated">如果为true，则任何具有 &lt;code&gt;CREATEDB&lt;/code&gt; 特权的用户都可以克隆此数据库；如果为false，则只有超级用户或数据库所有者才能克隆它。</target>
        </trans-unit>
        <trans-unit id="1accbb6daee5f69b5c0f42943992a092e4ba1074" translate="yes" xml:space="preserve">
          <source>If true, this index represents the primary key of the table (&lt;code&gt;indisunique&lt;/code&gt; should always be true when this is true)</source>
          <target state="translated">如果为true，则此索引代表表的主键（如果为true， &lt;code&gt;indisunique&lt;/code&gt; 应始终为true）</target>
        </trans-unit>
        <trans-unit id="0f6e2116d6074f49b9f7bdf86e12bdd873ed8149" translate="yes" xml:space="preserve">
          <source>If true, this index supports an exclusion constraint</source>
          <target state="translated">如果为真,则该索引支持排除约束。</target>
        </trans-unit>
        <trans-unit id="eb9d897ba2f316e5badcbcf694b6980e5d7c7ad0" translate="yes" xml:space="preserve">
          <source>If true, this is a unique index</source>
          <target state="translated">如果为真,这是一个唯一的索引</target>
        </trans-unit>
        <trans-unit id="6763aa747866133b7f56f2197fde582b044036d1" translate="yes" xml:space="preserve">
          <source>If true, this publication automatically includes all tables in the database, including any that will be created in the future.</source>
          <target state="translated">如果为真,本刊将自动包含数据库中的所有表,包括未来将创建的任何表。</target>
        </trans-unit>
        <trans-unit id="2b4a0e4917a40fa5601228c6bffce7ba0283b004" translate="yes" xml:space="preserve">
          <source>If true, this row includes inheritance child columns, not just the values in the specified table</source>
          <target state="translated">如果为真,这一行包括继承子列,而不仅仅是指定表中的值。</target>
        </trans-unit>
        <trans-unit id="b5af22ae5132cfdb3c63b86048053d7c0759cd52" translate="yes" xml:space="preserve">
          <source>If two such transactions concurrently try to change the balance of account 12345, we clearly want the second transaction to start with the updated version of the account's row. Because each command is affecting only a predetermined row, letting it see the updated version of the row does not create any troublesome inconsistency.</source>
          <target state="translated">如果两个这样的事务同时尝试更改12345账户的余额,我们显然希望第二个事务从更新版本的账户行开始。因为每个命令只影响一个预定的行,所以让它看到行的更新版本不会产生任何麻烦的不一致。</target>
        </trans-unit>
        <trans-unit id="286da9748bbda59905be5dc346e8fae92aa0edfb" translate="yes" xml:space="preserve">
          <source>If untrusted users have access to a database that has not adopted a &lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;secure schema usage pattern&lt;/a&gt;, begin your session by removing publicly-writable schemas from &lt;code&gt;search_path&lt;/code&gt;. One can add &lt;code&gt;options=-csearch_path=&lt;/code&gt; to the connection string or issue &lt;code&gt;SELECT pg_catalog.set_config('search_path', '', false)&lt;/code&gt; before other SQL commands. This consideration is not specific to psql; it applies to every interface for executing arbitrary SQL commands.</source>
          <target state="translated">如果不受信任的用户可以访问尚未采用&lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;安全模式使用模式&lt;/a&gt;的数据库，请通过从 &lt;code&gt;search_path&lt;/code&gt; 删除可公开写模式来开始会话。可以在连接字符串中添加 &lt;code&gt;options=-csearch_path=&lt;/code&gt; 或在其他SQL命令之前发出 &lt;code&gt;SELECT pg_catalog.set_config('search_path', '', false)&lt;/code&gt; 。此注意事项并非特定于psql；它适用于执行任意SQL命令的每个接口。</target>
        </trans-unit>
        <trans-unit id="768ed7df41fe42c9b25945d5dff896541bf55b4f" translate="yes" xml:space="preserve">
          <source>If untrusted users have access to a database that has not adopted a &lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;secure schema usage pattern&lt;/a&gt;, do not run pgbench in that database. pgbench uses unqualified names and does not manipulate the search path.</source>
          <target state="translated">如果不受信任的用户可以访问未采用&lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;安全模式使用模式的&lt;/a&gt;数据库，请不要在该数据库中运行pgbench。pgbench使用非限定名称，并且不操纵搜索路径。</target>
        </trans-unit>
        <trans-unit id="91d0d0478151e73c50542244d9425b00c1130633" translate="yes" xml:space="preserve">
          <source>If using WAL archiving or streaming replication, consider disabling them during the restore. To do that, set &lt;code&gt;archive_mode&lt;/code&gt; to &lt;code&gt;off&lt;/code&gt;, &lt;code&gt;wal_level&lt;/code&gt; to &lt;code&gt;minimal&lt;/code&gt;, and &lt;code&gt;max_wal_senders&lt;/code&gt; to zero before loading the dump. Afterwards, set them back to the right values and take a fresh base backup.</source>
          <target state="translated">如果使用WAL归档或流复制，请考虑在还原过程中将其禁用。为此，在加载转储之前，将 &lt;code&gt;archive_mode&lt;/code&gt; 设置为 &lt;code&gt;off&lt;/code&gt; ，将 &lt;code&gt;wal_level&lt;/code&gt; 设置为 &lt;code&gt;minimal&lt;/code&gt; ，将 &lt;code&gt;max_wal_senders&lt;/code&gt; 设置为零。然后，将它们重新设置为正确的值，然后进行新的基本备份。</target>
        </trans-unit>
        <trans-unit id="82f833ab3393a0e44827283b4406b6a15d35b9df" translate="yes" xml:space="preserve">
          <source>If using a pre-9.1 old server that is using a non-default Unix-domain socket directory or a default that differs from the default of the new cluster, set &lt;code&gt;PGHOST&lt;/code&gt; to point to the old server's socket location. (This is not relevant on Windows.)</source>
          <target state="translated">如果使用的是9.1之前的旧服务器，而该服务器使用的是非默认的Unix域套接字目录或与新集群的默认值不同的默认服务器，则将 &lt;code&gt;PGHOST&lt;/code&gt; 设置为指向旧服务器的套接字位置。 （这在Windows上不相关。）</target>
        </trans-unit>
        <trans-unit id="1fc1fe1aaf9532782aa2ed49cabaa7db59b86f4e" translate="yes" xml:space="preserve">
          <source>If waiting is disabled, the requested action is triggered, but there is no feedback about its success. In that case, the server log file or an external monitoring system would have to be used to check the progress and success of the operation.</source>
          <target state="translated">如果禁用了等待,请求的操作就会被触发,但没有关于其成功的反馈。在这种情况下,必须使用服务器日志文件或外部监控系统来检查操作的进度和成功率。</target>
        </trans-unit>
        <trans-unit id="7b03befc0afa9f43bd61408ea6224efc69f041cf" translate="yes" xml:space="preserve">
          <source>If we change the query's selectivity a bit, we might get a very different join plan:</source>
          <target state="translated">如果我们改变一下查询的选择性,可能会得到一个截然不同的连接计划。</target>
        </trans-unit>
        <trans-unit id="3514492aa3ac15aedee53bae788660dc8e748122" translate="yes" xml:space="preserve">
          <source>If we continuously feed the series of WAL files to another machine that has been loaded with the same base backup file, we have a &lt;em&gt;warm standby&lt;/em&gt; system: at any point we can bring up the second machine and it will have a nearly-current copy of the database.</source>
          <target state="translated">如果我们连续将这一系列WAL文件提供给另一台已加载了相同基本备份文件的计算机，则我们将拥有一个&lt;em&gt;热备份&lt;/em&gt;系统：在任何时候，我们都可以启动第二台计算机，并且该计算机将具有近乎最新的副本。数据库。</target>
        </trans-unit>
        <trans-unit id="a739f17951b6e075a348a61e8bb0affec3a10686" translate="yes" xml:space="preserve">
          <source>If we declared &lt;code&gt;cities&lt;/code&gt;.&lt;code&gt;name&lt;/code&gt; to be &lt;code&gt;UNIQUE&lt;/code&gt; or a &lt;code&gt;PRIMARY KEY&lt;/code&gt;, this would not stop the &lt;code&gt;capitals&lt;/code&gt; table from having rows with names duplicating rows in &lt;code&gt;cities&lt;/code&gt;. And those duplicate rows would by default show up in queries from &lt;code&gt;cities&lt;/code&gt;. In fact, by default &lt;code&gt;capitals&lt;/code&gt; would have no unique constraint at all, and so could contain multiple rows with the same name. You could add a unique constraint to &lt;code&gt;capitals&lt;/code&gt;, but this would not prevent duplication compared to &lt;code&gt;cities&lt;/code&gt;.</source>
          <target state="translated">如果我们宣布 &lt;code&gt;cities&lt;/code&gt; 。 &lt;code&gt;name&lt;/code&gt; 为 &lt;code&gt;UNIQUE&lt;/code&gt; 或 &lt;code&gt;PRIMARY KEY&lt;/code&gt; ，这不会阻止 &lt;code&gt;capitals&lt;/code&gt; 表具有名称重复 &lt;code&gt;cities&lt;/code&gt; 中行的行。默认情况下，这些重复的行将显示在 &lt;code&gt;cities&lt;/code&gt; 查询中。实际上，默认情况下， &lt;code&gt;capitals&lt;/code&gt; 根本没有唯一的约束，因此可以包含多个具有相同名称的行。您可以向 &lt;code&gt;capitals&lt;/code&gt; 添加唯一的约束，但是与 &lt;code&gt;cities&lt;/code&gt; 相比，这不能防止重复。</target>
        </trans-unit>
        <trans-unit id="347337a04b51d83bd4c64fbb8fed60949423b25a" translate="yes" xml:space="preserve">
          <source>If we wanted to know what city (or cities) that reading occurred in, we might try:</source>
          <target state="translated">如果我们想知道这个阅读发生在哪个城市(或几个城市),我们可以试试。</target>
        </trans-unit>
        <trans-unit id="d101ff564aae9ba45b998f26d6b5819ae89be6cf" translate="yes" xml:space="preserve">
          <source>If we were to declare this index &lt;code&gt;UNIQUE&lt;/code&gt;, it would prevent creation of rows whose &lt;code&gt;col1&lt;/code&gt; values differ only in case, as well as rows whose &lt;code&gt;col1&lt;/code&gt; values are actually identical. Thus, indexes on expressions can be used to enforce constraints that are not definable as simple unique constraints.</source>
          <target state="translated">如果我们要声明此索引 &lt;code&gt;UNIQUE&lt;/code&gt; ，它将防止创建 &lt;code&gt;col1&lt;/code&gt; 值仅在大小写不同的行以及 &lt;code&gt;col1&lt;/code&gt; 值实际上相同的行。因此，表达式的索引可用于强制执行无法定义为简单唯一约束的约束。</target>
        </trans-unit>
        <trans-unit id="26385616d9682a5e8b9897f0b99ebecc8622b226" translate="yes" xml:space="preserve">
          <source>If what you desire is a one-time check against other rows at row insertion, rather than a continuously-maintained consistency guarantee, a custom &lt;a href=&quot;https://www.postgresql.org/docs/12/triggers.html&quot;&gt;trigger&lt;/a&gt; can be used to implement that. (This approach avoids the dump/reload problem because pg_dump does not reinstall triggers until after reloading data, so that the check will not be enforced during a dump/reload.)</source>
          <target state="translated">如果您希望在插入行时一次性检查其他行，而不是连续保持一致性保证，则可以使用自定义&lt;a href=&quot;https://www.postgresql.org/docs/12/triggers.html&quot;&gt;触发器&lt;/a&gt;来实现这一点。（这种方法避免了转储/重载问题，因为pg_dump直到重载数据后才重新安装触发器，这样在转储/重载过程中不会强制执行检查。）</target>
        </trans-unit>
        <trans-unit id="bccf2a93440f14e5520a966b4714acd9fc9f1297" translate="yes" xml:space="preserve">
          <source>If what you desire is a one-time check against other rows at row insertion, rather than a continuously-maintained consistency guarantee, a custom &lt;a href=&quot;https://www.postgresql.org/docs/13/triggers.html&quot;&gt;trigger&lt;/a&gt; can be used to implement that. (This approach avoids the dump/reload problem because pg_dump does not reinstall triggers until after reloading data, so that the check will not be enforced during a dump/reload.)</source>
          <target state="translated">如果您希望在插入行时一次性检查其他行，而不是连续保持一致性保证，则可以使用自定义&lt;a href=&quot;https://www.postgresql.org/docs/13/triggers.html&quot;&gt;触发器&lt;/a&gt;来实现这一点。（这种方法避免了转储/重载问题，因为pg_dump直到重载数据后才重新安装触发器，这样在转储/重载过程中不会强制执行该检查。）</target>
        </trans-unit>
        <trans-unit id="1a14ecb62361bc225683313f20ed64062f67ccd0" translate="yes" xml:space="preserve">
          <source>If you already have, or suspect you have, orphaned large objects, see the &lt;a href=&quot;https://www.postgresql.org/docs/12/vacuumlo.html&quot;&gt;vacuumlo&lt;/a&gt; module to help you clean them up. It's a good idea to run vacuumlo occasionally as a back-stop to the &lt;code&gt;lo_manage&lt;/code&gt; trigger.</source>
          <target state="translated">如果已经有或怀疑有孤立的大物体，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/vacuumlo.html&quot;&gt;vacuumlo&lt;/a&gt;模块以帮助清理它们。最好偶尔运行vacuumlo作为 &lt;code&gt;lo_manage&lt;/code&gt; 触发器的后挡板。</target>
        </trans-unit>
        <trans-unit id="9d59e957767c53445cccc5f8621efd7719624cb5" translate="yes" xml:space="preserve">
          <source>If you already have, or suspect you have, orphaned large objects, see the &lt;a href=&quot;https://www.postgresql.org/docs/13/vacuumlo.html&quot;&gt;vacuumlo&lt;/a&gt; module to help you clean them up. It's a good idea to run vacuumlo occasionally as a back-stop to the &lt;code&gt;lo_manage&lt;/code&gt; trigger.</source>
          <target state="translated">如果已经有或怀疑有孤立的大物体，请参见&lt;a href=&quot;https://www.postgresql.org/docs/13/vacuumlo.html&quot;&gt;vacuumlo&lt;/a&gt;模块以帮助清理它们。最好偶尔运行vacuumlo作为 &lt;code&gt;lo_manage&lt;/code&gt; 触发器的后援。</target>
        </trans-unit>
        <trans-unit id="f390f29503d5d3e24b107064bb2a33c6ee6ea964" translate="yes" xml:space="preserve">
          <source>If you are adding large amounts of data to an existing table, it might be a win to drop the indexes, load the table, and then recreate the indexes. Of course, the database performance for other users might suffer during the time the indexes are missing. One should also think twice before dropping a unique index, since the error checking afforded by the unique constraint will be lost while the index is missing.</source>
          <target state="translated">如果你要在现有的表中添加大量的数据,那么放弃索引,加载表,然后重新创建索引,这可能是一种胜利。当然,在缺少索引的这段时间里,其他用户的数据库性能可能会受到影响。在放弃唯一索引之前也应该三思而行,因为在索引缺失的时候,唯一约束所提供的错误检查将消失。</target>
        </trans-unit>
        <trans-unit id="f9e2dec1d154e8ddecdda1dfc7964b3ebcabb443" translate="yes" xml:space="preserve">
          <source>If you are installing PostgreSQL yourself, then refer to &lt;a href=&quot;https://www.postgresql.org/docs/12/installation.html&quot;&gt;Chapter 16&lt;/a&gt; for instructions on installation, and return to this guide when the installation is complete. Be sure to follow closely the section about setting up the appropriate environment variables.</source>
          <target state="translated">如果您自己安装PostgreSQL，请参考&lt;a href=&quot;https://www.postgresql.org/docs/12/installation.html&quot;&gt;第16章中的&lt;/a&gt;安装说明，并在安装完成后返回本指南。确保紧密遵循有关设置适当的环境变量的部分。</target>
        </trans-unit>
        <trans-unit id="cd8e24142c807e0a347a699916b6cae27e9af283" translate="yes" xml:space="preserve">
          <source>If you are installing PostgreSQL yourself, then refer to &lt;a href=&quot;https://www.postgresql.org/docs/13/installation.html&quot;&gt;Chapter 16&lt;/a&gt; for instructions on installation, and return to this guide when the installation is complete. Be sure to follow closely the section about setting up the appropriate environment variables.</source>
          <target state="translated">如果您要自己安装PostgreSQL，请参阅&lt;a href=&quot;https://www.postgresql.org/docs/13/installation.html&quot;&gt;第16章&lt;/a&gt;以获取有关安装的说明，并在安装完成后返回本指南。确保紧密遵循有关设置适当的环境变量的部分。</target>
        </trans-unit>
        <trans-unit id="deb64bee8b7a2efcbeba6cf8a6dff70e83085729" translate="yes" xml:space="preserve">
          <source>If you are loading a freshly created table, the fastest method is to create the table, bulk load the table's data using &lt;code&gt;COPY&lt;/code&gt;, then create any indexes needed for the table. Creating an index on pre-existing data is quicker than updating it incrementally as each row is loaded.</source>
          <target state="translated">如果要加载新创建的表，最快的方法是创建表，使用 &lt;code&gt;COPY&lt;/code&gt; 批量加载表数据，然后创建表所需的任何索引。在加载每行时，在现有数据上创建索引比以增量方式更新索引更快。</target>
        </trans-unit>
        <trans-unit id="d87d9e34c581612e87603daaced88774ab9fe111" translate="yes" xml:space="preserve">
          <source>If you are not planning to use prepared transactions, this parameter should be set to zero to prevent accidental creation of prepared transactions. If you are using prepared transactions, you will probably want &lt;code&gt;max_prepared_transactions&lt;/code&gt; to be at least as large as &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;, so that every session can have a prepared transaction pending.</source>
          <target state="translated">如果您不打算使用准备好的交易，则应将此参数设置为零，以防止意外创建准备好的交易。如果使用的是预备事务，则可能希望 &lt;code&gt;max_prepared_transactions&lt;/code&gt; 至少与&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;一样大，以便每个会话都可以有一个待处理的预备事务。</target>
        </trans-unit>
        <trans-unit id="ca7f65648bc353887b727a182f8f612fdb9429de" translate="yes" xml:space="preserve">
          <source>If you are not sure whether PostgreSQL is already available or whether you can use it for your experimentation then you can install it yourself. Doing so is not hard and it can be a good exercise. PostgreSQL can be installed by any unprivileged user; no superuser (root) access is required.</source>
          <target state="translated">如果你不确定是否已经有PostgreSQL,或者是否可以用它来做实验,那么你可以自己安装它。这样做并不难,而且也是一种很好的锻炼。PostgreSQL可以由任何非特权用户安装,不需要超级用户(root)访问。</target>
        </trans-unit>
        <trans-unit id="6c854ded65666fb7e53665772a506fafbd718961" translate="yes" xml:space="preserve">
          <source>If you are running file-based log shipping (&quot;warm standby&quot;), you might need to wait until the next WAL file arrives, which could be as long as the &lt;code&gt;archive_timeout&lt;/code&gt; setting on the primary.</source>
          <target state="translated">如果您正在运行基于文件的日志传送（&amp;ldquo;热备用&amp;rdquo;），则可能需要等到下一个WAL文件到达为止，这可能与主文件上的 &lt;code&gt;archive_timeout&lt;/code&gt; 设置一样长。</target>
        </trans-unit>
        <trans-unit id="100df6210b436366664b5674494d353d329c78c1" translate="yes" xml:space="preserve">
          <source>If you are upgrading a pre-PostgreSQL 9.2 cluster that uses a configuration-file-only directory, you must pass the real data directory location to pg_upgrade, and pass the configuration directory location to the server, e.g. &lt;code&gt;-d /real-data-directory -o '-D /configuration-directory'&lt;/code&gt;.</source>
          <target state="translated">如果要升级使用仅配置文件目录的PostgreSQL 9.2之前的集群，则必须将实际数据目录位置传递给pg_upgrade，并将配置目录位置传递给服务器，例如 &lt;code&gt;-d /real-data-directory -o '-D /configuration-directory'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fc55bda54288eb26294b0ebbfc29f843e85f5f66" translate="yes" xml:space="preserve">
          <source>If you are upgrading a pre-PostgreSQL 9.2 cluster that uses a configuration-file-only directory, you must pass the real data directory location to pg_upgrade, and pass the configuration directory location to the server, e.g., &lt;code&gt;-d /real-data-directory -o '-D /configuration-directory'&lt;/code&gt;.</source>
          <target state="translated">如果要升级使用仅配置文件目录的PostgreSQL 9.2之前的集群，则必须将实际数据目录位置传递给pg_upgrade，并将配置目录位置传递给服务器，例如 &lt;code&gt;-d /real-data-directory -o '-D /configuration-directory'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6433dfa1c8ec93408de2c79d0f13ec3cb038d812" translate="yes" xml:space="preserve">
          <source>If you are upgrading standby servers using methods outlined in section &lt;a href=&quot;pgupgrade#PGUPGRADE-STEP-REPLICAS&quot;&gt;Step 10&lt;/a&gt;, verify that the old standby servers are caught up by running pg_controldata against the old primary and standby clusters. Verify that the &amp;ldquo;Latest checkpoint location&amp;rdquo; values match in all clusters. (There will be a mismatch if old standby servers were shut down before the old primary or if the old standby servers are still running.) Also, change &lt;code&gt;wal_level&lt;/code&gt; to &lt;code&gt;replica&lt;/code&gt; in the &lt;code&gt;postgresql.conf&lt;/code&gt; file on the new primary cluster.</source>
          <target state="translated">如果要使用&lt;a href=&quot;pgupgrade#PGUPGRADE-STEP-REPLICAS&quot;&gt;第10步中&lt;/a&gt;概述的方法升级备用服务器，请通过对旧的主群集和备用群集运行pg_controldata来验证旧的备用服务器是否已被捕获。验证&amp;ldquo;最新检查点位置&amp;rdquo;值在所有群集中均匹配。（会有不匹配，如果原来的备用服务器被以前的老主或者如果旧备用服务器仍在运行关闭。）同时，改变 &lt;code&gt;wal_level&lt;/code&gt; 到 &lt;code&gt;replica&lt;/code&gt; 中 &lt;code&gt;postgresql.conf&lt;/code&gt; 新的主群集上的文件。</target>
        </trans-unit>
        <trans-unit id="a25fedf0ac6ffff68a2762449d5371eee093e033" translate="yes" xml:space="preserve">
          <source>If you are upgrading standby servers using methods outlined in section &lt;a href=&quot;pgupgrade#PGUPGRADE-STEP-REPLICAS&quot;&gt;Step 10&lt;/a&gt;, verify that the old standby servers are caught up by running pg_controldata against the old primary and standby clusters. Verify that the &amp;ldquo;Latest checkpoint location&amp;rdquo; values match in all clusters. (There will be a mismatch if old standby servers were shut down before the old primary or if the old standby servers are still running.) Also, make sure &lt;code&gt;wal_level&lt;/code&gt; is not set to &lt;code&gt;minimal&lt;/code&gt; in the &lt;code&gt;postgresql.conf&lt;/code&gt; file on the new primary cluster.</source>
          <target state="translated">如果要使用&lt;a href=&quot;pgupgrade#PGUPGRADE-STEP-REPLICAS&quot;&gt;第10步中&lt;/a&gt;概述的方法升级备用服务器，请通过对旧的主群集和备用群集运行pg_controldata来验证旧的备用服务器是否已被捕获。验证&amp;ldquo;最新检查点位置&amp;rdquo;值在所有群集中均匹配。（会有不匹配，如果原来的备用服务器被以前的老主或者如果旧备用服务器仍在运行关机。）此外，确保 &lt;code&gt;wal_level&lt;/code&gt; 未设置为 &lt;code&gt;minimal&lt;/code&gt; 的 &lt;code&gt;postgresql.conf&lt;/code&gt; 中新的主群集上的文件。</target>
        </trans-unit>
        <trans-unit id="4f73d78215cef8d2ef14222445477bdca411ef71" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;-X none&lt;/code&gt;, there is no guarantee that all WAL files required for the backup are archived at the end of backup.</source>
          <target state="translated">如果使用 &lt;code&gt;-X none&lt;/code&gt; ，则不能保证备份所需的所有WAL文件都在备份结束时存档。</target>
        </trans-unit>
        <trans-unit id="9d0f772d8182283e7e8eeabb4a80f986e054e96a" translate="yes" xml:space="preserve">
          <source>If you are using a pre-packaged version of PostgreSQL, and you used its provisions for starting the server, then you should also use its provisions for stopping the server. Consult the package-level documentation for details.</source>
          <target state="translated">如果你使用的是PostgreSQL的预打包版本,并且你使用它的规定来启动服务器,那么你也应该使用它的规定来停止服务器。详情请查阅包级文档。</target>
        </trans-unit>
        <trans-unit id="cc432d389e68b3790013be9ab641ccb60838ff96" translate="yes" xml:space="preserve">
          <source>If you are using a pre-packaged version of PostgreSQL, it almost certainly includes provisions for running the server as a background task according to the conventions of your operating system. Using the package's infrastructure to start the server will be much less work than figuring out how to do this yourself. Consult the package-level documentation for details.</source>
          <target state="translated">如果你使用的是预打包的PostgreSQL版本,它几乎可以肯定包含了根据你的操作系统的惯例将服务器作为后台任务运行的规定。使用软件包的基础结构来启动服务器比自己想办法做要省事得多。详情请参考软件包级别的文档。</target>
        </trans-unit>
        <trans-unit id="4ec81265be63b85cd110675b546ea20c69a22e29" translate="yes" xml:space="preserve">
          <source>If you are using a pre-packaged version of PostgreSQL, it may well have a specific convention for where to place the data directory, and it may also provide a script for creating the data directory. In that case you should use that script in preference to running &lt;code&gt;initdb&lt;/code&gt; directly. Consult the package-level documentation for details.</source>
          <target state="translated">如果您使用的是PostgreSQL的预打包版本，则它可能对在何处放置数据目录有特定的约定，并且还可能提供用于创建数据目录的脚本。在这种情况下，您应该优先使用该脚本而不是直接运行 &lt;code&gt;initdb&lt;/code&gt; 。有关详细信息，请查阅软件包级别的文档。</target>
        </trans-unit>
        <trans-unit id="e87540bbfb46f5ca553285a02a78a4413f99dfe1" translate="yes" xml:space="preserve">
          <source>If you are using a version-specific installation directory, e.g. &lt;code&gt;/opt/PostgreSQL/12&lt;/code&gt;, you do not need to move the old cluster. The graphical installers all use version-specific installation directories.</source>
          <target state="translated">如果您使用的是特定于版本的安装目录，例如 &lt;code&gt;/opt/PostgreSQL/12&lt;/code&gt; ，则无需移动旧集群。图形安装程序均使用特定于版本的安装目录。</target>
        </trans-unit>
        <trans-unit id="d8bbcc7b0eac5395154e7966b802a1726a037170" translate="yes" xml:space="preserve">
          <source>If you are using a version-specific installation directory, e.g., &lt;code&gt;/opt/PostgreSQL/13&lt;/code&gt;, you do not need to move the old cluster. The graphical installers all use version-specific installation directories.</source>
          <target state="translated">如果您使用的是特定于版本的安装目录，例如 &lt;code&gt;/opt/PostgreSQL/13&lt;/code&gt; ，则无需移动旧集群。图形化安装程序均使用特定于版本的安装目录。</target>
        </trans-unit>
        <trans-unit id="afb6b5bbb35f9c84113d155adac8b2ce50841366" translate="yes" xml:space="preserve">
          <source>If you are using manual &lt;code&gt;VACUUM&lt;/code&gt; or &lt;code&gt;ANALYZE&lt;/code&gt; commands, don't forget that you need to run them on each child table individually. A command like:</source>
          <target state="translated">如果使用手动 &lt;code&gt;VACUUM&lt;/code&gt; 或 &lt;code&gt;ANALYZE&lt;/code&gt; 命令，请不要忘记需要在每个子表上单独运行它们。像这样的命令：</target>
        </trans-unit>
        <trans-unit id="657742cf08661b004524bce37cea4f60251b3473" translate="yes" xml:space="preserve">
          <source>If you believe a 90% cache rate is an incorrect assumption for your workload, you can increase random_page_cost to better reflect the true cost of random storage reads. Correspondingly, if your data is likely to be completely in cache, such as when the database is smaller than the total server memory, decreasing random_page_cost can be appropriate. Storage that has a low random read cost relative to sequential, e.g. solid-state drives, might also be better modeled with a lower value for random_page_cost.</source>
          <target state="translated">如果你认为90%的缓存率对于你的工作负载是一个不正确的假设,你可以增加random_page_cost来更好地反映随机存储读取的真实成本。相应的,如果你的数据很可能完全在缓存中,比如数据库小于服务器总内存的时候,降低random_page_cost可以是合适的。相对于顺序的存储,随机读取成本较低的存储,例如固态硬盘,采用较低的random_page_cost值来建模可能也会更好。</target>
        </trans-unit>
        <trans-unit id="01590de3b1a45b503095ec546feb704e9b7a0246" translate="yes" xml:space="preserve">
          <source>If you believe a 90% cache rate is an incorrect assumption for your workload, you can increase random_page_cost to better reflect the true cost of random storage reads. Correspondingly, if your data is likely to be completely in cache, such as when the database is smaller than the total server memory, decreasing random_page_cost can be appropriate. Storage that has a low random read cost relative to sequential, e.g., solid-state drives, might also be better modeled with a lower value for random_page_cost, e.g., &lt;code&gt;1.1&lt;/code&gt;.</source>
          <target state="translated">如果您认为90％的高速缓存率是对您的工作负载的错误假设，则可以增加random_page_cost以更好地反映随机存储读取的真实成本。相应地，如果您的数据有可能完全位于缓存中（例如，当数据库小于服务器总内存时），则减少random_page_cost可能是适当的。相对于顺序驱动（例如固态驱动器）而言，具有较低随机读取成本的存储也可以通过对random_page_cost较低的值（例如 &lt;code&gt;1.1&lt;/code&gt; )进行更好的建模。</target>
        </trans-unit>
        <trans-unit id="de352785d4d320deb71e5335924b75625cf49620" translate="yes" xml:space="preserve">
          <source>If you call &lt;code&gt;\set&lt;/code&gt; without a second argument, the variable is set to an empty-string value. To unset (i.e., delete) a variable, use the command &lt;code&gt;\unset&lt;/code&gt;. To show the values of all variables, call &lt;code&gt;\set&lt;/code&gt; without any argument.</source>
          <target state="translated">如果在没有第二个参数的情况下调用 &lt;code&gt;\set&lt;/code&gt; ，则该变量将设置为空字符串值。要取消设置（即删除）变量，请使用命令 &lt;code&gt;\unset&lt;/code&gt; 。要显示所有变量的值，请不带任何参数调用 &lt;code&gt;\set&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0259699cb6f3b30e1cd0e413c4e39248024e19a0" translate="yes" xml:space="preserve">
          <source>If you cannot free up additional space on the disk by deleting other things, you can move some of the database files to other file systems by making use of tablespaces. See &lt;a href=&quot;manage-ag-tablespaces&quot;&gt;Section 22.6&lt;/a&gt; for more information about that.</source>
          <target state="translated">如果无法通过删除其他内容来释放磁盘上的额外空间，则可以通过使用表空间将某些数据库文件移至其他文件系统。有关更多信息，请参见&lt;a href=&quot;manage-ag-tablespaces&quot;&gt;第22.6节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a6b2ee409cca3f880cf89818705f66642823737c" translate="yes" xml:space="preserve">
          <source>If you cannot use &lt;code&gt;COPY&lt;/code&gt;, it might help to use &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt; to create a prepared &lt;code&gt;INSERT&lt;/code&gt; statement, and then use &lt;code&gt;EXECUTE&lt;/code&gt; as many times as required. This avoids some of the overhead of repeatedly parsing and planning &lt;code&gt;INSERT&lt;/code&gt;. Different interfaces provide this facility in different ways; look for &amp;ldquo;prepared statements&amp;rdquo; in the interface documentation.</source>
          <target state="translated">如果不能使用 &lt;code&gt;COPY&lt;/code&gt; ，则可能会使用&lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt;创建一个准备好的 &lt;code&gt;INSERT&lt;/code&gt; 语句，然后根据需要使用 &lt;code&gt;EXECUTE&lt;/code&gt; 多次。这避免了重复分析和计划 &lt;code&gt;INSERT&lt;/code&gt; 的一些开销。不同的接口以不同的方式提供此功能。在界面文档中查找&amp;ldquo;准备好的语句&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="f74f5e82fb19007ba8087ea69c4af7c169641fbd" translate="yes" xml:space="preserve">
          <source>If you cannot, then better do crypto inside client application.</source>
          <target state="translated">如果不能,那么最好在客户端应用里面做加密。</target>
        </trans-unit>
        <trans-unit id="c6938a67160fbaea3812e5c1afc009d637ef7fc7" translate="yes" xml:space="preserve">
          <source>If you declare a column as &lt;code&gt;UNIQUE&lt;/code&gt; or &lt;code&gt;PRIMARY KEY&lt;/code&gt;, the implicitly generated index is case-sensitive. So it's useless for case-insensitive searches, and it won't enforce uniqueness case-insensitively.</source>
          <target state="translated">如果将列声明为 &lt;code&gt;UNIQUE&lt;/code&gt; 或 &lt;code&gt;PRIMARY KEY&lt;/code&gt; ，则隐式生成的索引区分大小写。因此，它对于不区分大小写的搜索没有用，并且不会区分大小写地强制执行唯一性。</target>
        </trans-unit>
        <trans-unit id="bab8b24944cb37a1a0e9e93c41e90f5a2cb6ccb4" translate="yes" xml:space="preserve">
          <source>If you did &lt;em&gt;not&lt;/em&gt; start the new cluster, the old cluster was unmodified except that, when linking started, a &lt;code&gt;.old&lt;/code&gt; suffix was appended to &lt;code&gt;$PGDATA/global/pg_control&lt;/code&gt;. To reuse the old cluster, remove the &lt;code&gt;.old&lt;/code&gt; suffix from &lt;code&gt;$PGDATA/global/pg_control&lt;/code&gt;; you can then restart the old cluster.</source>
          <target state="translated">如果你没有&lt;em&gt;不&lt;/em&gt;启动新的群集，旧的群集，不同的是未经修改的，链接启动时，一个 &lt;code&gt;.old&lt;/code&gt; 为后缀被追加到 &lt;code&gt;$PGDATA/global/pg_control&lt;/code&gt; 。要重用旧集群，请从 &lt;code&gt;$PGDATA/global/pg_control&lt;/code&gt; 删除 &lt;code&gt;.old&lt;/code&gt; 后缀；然后可以重新启动旧群集。</target>
        </trans-unit>
        <trans-unit id="62b2adb362a08de49cfa1c83dea8a83d9bb2213c" translate="yes" xml:space="preserve">
          <source>If you did &lt;em&gt;not&lt;/em&gt; use link mode, do not have or do not want to use rsync, or want an easier solution, skip the instructions in this section and simply recreate the standby servers once pg_upgrade completes and the new primary is running.</source>
          <target state="translated">如果你是&lt;em&gt;不是&lt;/em&gt;使用链接模式，没有或者不想使用rsync，还是希望有一个简单的解决方案，请跳过本节的说明，简单地重建一次pg_upgrade完成和新的主运行的备用服务器。</target>
        </trans-unit>
        <trans-unit id="90981d7a01c90cf36de6cae3508f26abcc450f7b" translate="yes" xml:space="preserve">
          <source>If you did start the new cluster, it has written to shared files and it is unsafe to use the old cluster. The old cluster will need to be restored from backup in this case.</source>
          <target state="translated">如果您确实启动了新的群集,那么它已经写入了共享文件,使用旧群集是不安全的。在这种情况下,需要从备份中恢复旧群集。</target>
        </trans-unit>
        <trans-unit id="47fd87d8debe284e9f481467ae1affc261e54ea8" translate="yes" xml:space="preserve">
          <source>If you do not like the output format for &lt;code&gt;inet&lt;/code&gt; or &lt;code&gt;cidr&lt;/code&gt; values, try the functions &lt;code&gt;host&lt;/code&gt;, &lt;code&gt;text&lt;/code&gt;, and &lt;code&gt;abbrev&lt;/code&gt;.</source>
          <target state="translated">如果您不喜欢 &lt;code&gt;inet&lt;/code&gt; 或 &lt;code&gt;cidr&lt;/code&gt; 值的输出格式，请尝试使用 &lt;code&gt;host&lt;/code&gt; ， &lt;code&gt;text&lt;/code&gt; 和 &lt;code&gt;abbrev&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="f96a8ec302a42bc03e998712a66f544972ee1509" translate="yes" xml:space="preserve">
          <source>If you do not succeed in adjusting the costs to be more appropriate, then you might have to resort to forcing index usage explicitly. You might also want to contact the PostgreSQL developers to examine the issue.</source>
          <target state="translated">如果你不能成功地将成本调整到更合适的位置,那么你可能不得不求助于明确地强制使用索引。你可能还想联系PostgreSQL的开发人员来研究这个问题。</target>
        </trans-unit>
        <trans-unit id="b4cd7de986e411178ee91fc3fe47680a23518cd4" translate="yes" xml:space="preserve">
          <source>If you do not supply the database name then it will default to your user account name. You already discovered this scheme in the previous section using &lt;code&gt;createdb&lt;/code&gt;.</source>
          <target state="translated">如果您不提供数据库名称，那么它将默认为您的用户帐户名称。您已经在上一节中使用 &lt;code&gt;createdb&lt;/code&gt; 发现了该方案。</target>
        </trans-unit>
        <trans-unit id="be339a6a88d4d2b9b65bab603b8e3c0d2fd399fd" translate="yes" xml:space="preserve">
          <source>If you do not want to use your database anymore you can remove it. For example, if you are the owner (creator) of the database &lt;code&gt;mydb&lt;/code&gt;, you can destroy it using the following command:</source>
          <target state="translated">如果您不想再使用数据库，则可以将其删除。例如，如果您是数据库 &lt;code&gt;mydb&lt;/code&gt; 的所有者（创建者），则可以使用以下命令将其销毁：</target>
        </trans-unit>
        <trans-unit id="08e08381cd8f923213bb0bae5a2a61f673142186" translate="yes" xml:space="preserve">
          <source>If you don't have values for all the columns, you can omit some of them. In that case, the columns will be filled with their default values. For example:</source>
          <target state="translated">如果你没有所有列的值,你可以省略其中的一些列。在这种情况下,这些列将用它们的默认值填充。例如:</target>
        </trans-unit>
        <trans-unit id="404e82d0a58303983c4b5022b612f1fb6248be48" translate="yes" xml:space="preserve">
          <source>If you drop and then recreate a function, the new function is not the same entity as the old; you will have to drop existing rules, views, triggers, etc. that refer to the old function. Use &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; to change a function definition without breaking objects that refer to the function. Also, &lt;code&gt;ALTER FUNCTION&lt;/code&gt; can be used to change most of the auxiliary properties of an existing function.</source>
          <target state="translated">如果删除然后重新创建一个函数，则新功能与旧功能不相同；您将必须删除引用旧功能的现有规则，视图，触发器等。使用 &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; 来更改函数定义，而不会破坏引用该函数的对象。同样， &lt;code&gt;ALTER FUNCTION&lt;/code&gt; 可用于更改现有功能的大多数辅助属性。</target>
        </trans-unit>
        <trans-unit id="be307ca6bbc030429d0d787ca8543b0973b17c65" translate="yes" xml:space="preserve">
          <source>If you encounter problems starting &lt;code&gt;psql&lt;/code&gt; then go back to the previous section. The diagnostics of &lt;code&gt;createdb&lt;/code&gt; and &lt;code&gt;psql&lt;/code&gt; are similar, and if the former worked the latter should work as well.</source>
          <target state="translated">如果启动 &lt;code&gt;psql&lt;/code&gt; 时遇到问题，请返回上一部分。 &lt;code&gt;createdb&lt;/code&gt; 和 &lt;code&gt;psql&lt;/code&gt; 的诊断类似，如果前者有效，后者也应有效。</target>
        </trans-unit>
        <trans-unit id="b13cd3cf02514f3a86f3431f0fe84ad64d68a6f3" translate="yes" xml:space="preserve">
          <source>If you feel you need more introductory material, please visit the PostgreSQL &lt;a href=&quot;https://www.postgresql.org&quot;&gt;web site&lt;/a&gt; for links to more resources.</source>
          <target state="translated">如果您觉得需要更多入门资料，请访问PostgreSQL &lt;a href=&quot;https://www.postgresql.org&quot;&gt;网站&lt;/a&gt;以获得更多资源的链接。</target>
        </trans-unit>
        <trans-unit id="27223facca9dbba24447f51ca3cc46e2a4d4b2ed" translate="yes" xml:space="preserve">
          <source>If you get an &amp;ldquo;illegal system call&amp;rdquo; error, it is likely that shared memory or semaphores are not supported in your kernel at all. In that case your only option is to reconfigure the kernel to enable these features.</source>
          <target state="translated">如果收到&amp;ldquo;非法系统调用&amp;rdquo;错误，则可能是内核根本不支持共享内存或信号灯。在这种情况下，您唯一的选择是重新配置内核以启用这些功能。</target>
        </trans-unit>
        <trans-unit id="7aa554ad85b0e28436475081421e4e00eaf4dd3c" translate="yes" xml:space="preserve">
          <source>If you have &lt;a href=&quot;runtime-config-compatible#GUC-STANDARD-CONFORMING-STRINGS&quot;&gt;standard_conforming_strings&lt;/a&gt; turned off, any backslashes you write in literal string constants will need to be doubled. See &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;Section 4.1.2.1&lt;/a&gt; for more information.</source>
          <target state="translated">如果关闭了&lt;a href=&quot;runtime-config-compatible#GUC-STANDARD-CONFORMING-STRINGS&quot;&gt;standard_conforming_strings&lt;/a&gt;，则用文字字符串常量编写的任何反斜杠都需要加倍。有关更多信息，请参见&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;第4.1.2.1节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f61cc65bca02db4eb1ea500b6eae076fd93f0491" translate="yes" xml:space="preserve">
          <source>If you have a dedicated database server with 1GB or more of RAM, a reasonable starting value for &lt;code&gt;shared_buffers&lt;/code&gt; is 25% of the memory in your system. There are some workloads where even larger settings for &lt;code&gt;shared_buffers&lt;/code&gt; are effective, but because PostgreSQL also relies on the operating system cache, it is unlikely that an allocation of more than 40% of RAM to &lt;code&gt;shared_buffers&lt;/code&gt; will work better than a smaller amount. Larger settings for &lt;code&gt;shared_buffers&lt;/code&gt; usually require a corresponding increase in &lt;code&gt;max_wal_size&lt;/code&gt;, in order to spread out the process of writing large quantities of new or changed data over a longer period of time.</source>
          <target state="translated">如果您有一个具有1GB或更大RAM的专用数据库服务器，则 &lt;code&gt;shared_buffers&lt;/code&gt; 的合理起始值应为系统内存的25％。在某些工作负载中，更大的 &lt;code&gt;shared_buffers&lt;/code&gt; 设置是有效的，但是由于PostgreSQL也依赖于操作系统缓存，因此分配给 &lt;code&gt;shared_buffers&lt;/code&gt; 的RAM的40％以上不太可能比较小的RAM 更好。较大的 &lt;code&gt;shared_buffers&lt;/code&gt; 设置通常需要相应增加 &lt;code&gt;max_wal_size&lt;/code&gt; ，以便在更长的时间内分散写入大量新数据或更改数据的过程。</target>
        </trans-unit>
        <trans-unit id="5955ce4878872fc7d42a5cf4a3feceaf0ce085c2" translate="yes" xml:space="preserve">
          <source>If you have a table that contains both billed and unbilled orders, where the unbilled orders take up a small fraction of the total table and yet those are the most-accessed rows, you can improve performance by creating an index on just the unbilled rows. The command to create the index would look like this:</source>
          <target state="translated">如果你有一个包含有已出单和未出单的表,未出单的订单只占总表的一小部分,但这些是访问量最大的行,你可以通过在未出单的行上创建一个索引来提高性能。创建索引的命令是这样的。</target>
        </trans-unit>
        <trans-unit id="3db868f1aa52b4182eabc5a6aaef64ca58b29be3" translate="yes" xml:space="preserve">
          <source>If you have a table whose entire contents are deleted on a periodic basis, consider doing it with &lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt; rather than using &lt;code&gt;DELETE&lt;/code&gt; followed by &lt;code&gt;VACUUM&lt;/code&gt;. &lt;code&gt;TRUNCATE&lt;/code&gt; removes the entire content of the table immediately, without requiring a subsequent &lt;code&gt;VACUUM&lt;/code&gt; or &lt;code&gt;VACUUM FULL&lt;/code&gt; to reclaim the now-unused disk space. The disadvantage is that strict MVCC semantics are violated.</source>
          <target state="translated">如果您有一个表，该表的全部内容会定期删除，请考虑使用&lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt;而不是 &lt;code&gt;DELETE&lt;/code&gt; 和 &lt;code&gt;VACUUM&lt;/code&gt; 进行删除。 &lt;code&gt;TRUNCATE&lt;/code&gt; 立即删除表的全部内容，而无需后续的 &lt;code&gt;VACUUM&lt;/code&gt; 或 &lt;code&gt;VACUUM FULL&lt;/code&gt; 来回收现在未使用的磁盘空间。缺点是违反了严格的MVCC语义。</target>
        </trans-unit>
        <trans-unit id="edada2f4a0ea8a1fe6f35435a51d724440a997b9" translate="yes" xml:space="preserve">
          <source>If you have a user account but it does not have the privileges required to create a database, you will see the following:</source>
          <target state="translated">如果你有一个用户账户,但它没有创建数据库所需的权限,你会看到以下内容。</target>
        </trans-unit>
        <trans-unit id="6e1ffd7834998be91b2b3ef3885c4c95ac1fca94" translate="yes" xml:space="preserve">
          <source>If you have an embedded SQL C source file named &lt;code&gt;prog1.pgc&lt;/code&gt;, you can create an executable program using the following sequence of commands:</source>
          <target state="translated">如果您有一个名为 &lt;code&gt;prog1.pgc&lt;/code&gt; 的嵌入式SQL C源文件，则可以使用以下命令序列创建一个可执行程序：</target>
        </trans-unit>
        <trans-unit id="3a617edae0e90918be65ecbfa41a4edb3f6fbb0d" translate="yes" xml:space="preserve">
          <source>If you have dug into the details of the file system layout of the database, you might be tempted to try to back up or restore only certain individual tables or databases from their respective files or directories. This will &lt;em&gt;not&lt;/em&gt; work because the information contained in these files is not usable without the commit log files, &lt;code&gt;pg_xact/*&lt;/code&gt;, which contain the commit status of all transactions. A table file is only usable with this information. Of course it is also impossible to restore only a table and the associated &lt;code&gt;pg_xact&lt;/code&gt; data because that would render all other tables in the database cluster useless. So file system backups only work for complete backup and restoration of an entire database cluster.</source>
          <target state="translated">如果您已深入研究数据库的文件系统布局的详细信息，则可能会尝试尝试仅从特定文件或目录中备份或还原某些特定表或数据库。这将&lt;em&gt;不&lt;/em&gt;工作，因为这些文件中包含的信息是不可用而不提交日志文件， &lt;code&gt;pg_xact/*&lt;/code&gt; ，其中包含所有提交的交易的状态。表文件仅可用于此信息。当然，仅还原表和关联的 &lt;code&gt;pg_xact&lt;/code&gt; 数据也是不可能的，因为这会使数据库集群中的所有其他表失效。因此，文件系统备份仅适用于完整数据库集群的完整备份和还原。</target>
        </trans-unit>
        <trans-unit id="b1fdfd0de9a85f5bba1c48c08c54c2308c8c0754" translate="yes" xml:space="preserve">
          <source>If you have not set up an external transaction manager to track prepared transactions and ensure they get closed out promptly, it is best to keep the prepared-transaction feature disabled by setting &lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt; to zero. This will prevent accidental creation of prepared transactions that might then be forgotten and eventually cause problems.</source>
          <target state="translated">如果您尚未设置外部事务管理器来跟踪已准备好的交易并确保迅速将其关闭，则最好通过将&lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt;设置为零来保持已禁用的交易功能。这将防止意外创建准备好的交易，该交易可能随后被忘记并最终导致问题。</target>
        </trans-unit>
        <trans-unit id="4113594099b8ceaba5516ae6559f67b321dd3f1a" translate="yes" xml:space="preserve">
          <source>If you have pattern matching needs that go beyond this, consider writing a user-defined function in Perl or Tcl.</source>
          <target state="translated">如果你有超出这个范围的模式匹配需求,可以考虑在Perl或Tcl中编写一个用户定义的函数。</target>
        </trans-unit>
        <trans-unit id="aedcf3e1663bdb52e36d3e2d02ae7396863fa330" translate="yes" xml:space="preserve">
          <source>If you have relocated &lt;code&gt;pg_wal&lt;/code&gt; outside the data directories, rsync must be run on those directories too.</source>
          <target state="translated">如果您已将 &lt;code&gt;pg_wal&lt;/code&gt; 重新定位在数据目录之外，则rsync也必须在这些目录上运行。</target>
        </trans-unit>
        <trans-unit id="66e124e77e26c68b2716b8eb55653604cd884707" translate="yes" xml:space="preserve">
          <source>If you have set &lt;code&gt;shared_memory_type&lt;/code&gt; to &lt;code&gt;sysv&lt;/code&gt;, you might also want to configure your kernel to lock System V shared memory into RAM and prevent it from being paged out to swap. This can be accomplished using the &lt;code&gt;sysctl&lt;/code&gt; setting &lt;code&gt;kern.ipc.shm_use_phys&lt;/code&gt;.</source>
          <target state="translated">如果已将 &lt;code&gt;shared_memory_type&lt;/code&gt; 设置为 &lt;code&gt;sysv&lt;/code&gt; ，则可能还需要配置内核以将System V共享内存锁定到RAM中，并防止将其分页以进行交换。这可以使用 &lt;code&gt;sysctl&lt;/code&gt; 设置 &lt;code&gt;kern.ipc.shm_use_phys&lt;/code&gt; 来完成。</target>
        </trans-unit>
        <trans-unit id="a07426ce8ecfc80c9d7a4edfcb98cf0ba611138f" translate="yes" xml:space="preserve">
          <source>If you have tablespaces, you will need to run a similar rsync command for each tablespace directory, e.g.:</source>
          <target state="translated">如果你有表空间,你需要为每个表空间目录运行一个类似的rsync命令,例如。</target>
        </trans-unit>
        <trans-unit id="74d92589027830b748d75a72665251c799371e5f" translate="yes" xml:space="preserve">
          <source>If you have the space to do so, copy the whole cluster data directory and any tablespaces to a temporary location in case you need them later. Note that this precaution will require that you have enough free space on your system to hold two copies of your existing database. If you do not have enough space, you should at least save the contents of the cluster's &lt;code&gt;pg_wal&lt;/code&gt; subdirectory, as it might contain logs which were not archived before the system went down.</source>
          <target state="translated">如果有足够的空间，请将整个群集数据目录和所有表空间复制到一个临时位置，以备日后需要时使用。请注意，此预防措施将要求您在系统上有足够的可用空间来容纳现有数据库的两个副本。如果没有足够的空间，则至少应保存集群的 &lt;code&gt;pg_wal&lt;/code&gt; 子目录的内容，因为它可能包含在系统关闭之前尚未归档的日志。</target>
        </trans-unit>
        <trans-unit id="c405c350a4bec28b591f01ed6531218b06904979" translate="yes" xml:space="preserve">
          <source>If you have to &amp;ldquo;hop&amp;rdquo; to the database server via some login host, one possible setup could look like this:</source>
          <target state="translated">如果您必须通过某个登录主机&amp;ldquo;跳到&amp;rdquo;数据库服务器，则可能的设置如下所示：</target>
        </trans-unit>
        <trans-unit id="e1467a82f0f1d2aed2302c816a743bd03ff5d6fe" translate="yes" xml:space="preserve">
          <source>If you have turned off &lt;a href=&quot;runtime-config-logging#GUC-UPDATE-PROCESS-TITLE&quot;&gt;update_process_title&lt;/a&gt; then the activity indicator is not updated; the process title is set only once when a new process is launched. On some platforms this saves a measurable amount of per-command overhead; on others it's insignificant.</source>
          <target state="translated">如果您已关闭&lt;a href=&quot;runtime-config-logging#GUC-UPDATE-PROCESS-TITLE&quot;&gt;update_process_title，&lt;/a&gt;则活动指示器不会更新；启动新流程时，流程标题仅设置一次。在某些平台上，这节省了可观的每命令开销。在其他方面则无关紧要。</target>
        </trans-unit>
        <trans-unit id="cdc8af27dd93a99e3339ed60a27d59629c7d68fb" translate="yes" xml:space="preserve">
          <source>If you have unarchived WAL segment files that you saved in step 2, copy them into &lt;code&gt;pg_wal/&lt;/code&gt;. (It is best to copy them, not move them, so you still have the unmodified files if a problem occurs and you have to start over.)</source>
          <target state="translated">如果您具有在步骤2中保存的未存档WAL段文件，请将其复制到 &lt;code&gt;pg_wal/&lt;/code&gt; 。（最好复制它们，而不是移动它们，因此，如果出现问题并且必须重新开始，您仍然拥有未修改的文件。）</target>
        </trans-unit>
        <trans-unit id="f602421c44c7955b1682bc7b3fca54acb52d429c" translate="yes" xml:space="preserve">
          <source>If you modified &lt;code&gt;pg_hba.conf&lt;/code&gt;, restore its original settings. It might also be necessary to adjust other configuration files in the new cluster to match the old cluster, e.g. &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="translated">如果您修改了 &lt;code&gt;pg_hba.conf&lt;/code&gt; ，请恢复其原始设置。可能还需要调整新集群中的其他配置文件以匹配旧集群，例如 &lt;code&gt;postgresql.conf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dbf1fa6cfeb52f4146529fb315f1682db9559aaa" translate="yes" xml:space="preserve">
          <source>If you modified &lt;code&gt;pg_hba.conf&lt;/code&gt;, restore its original settings. It might also be necessary to adjust other configuration files in the new cluster to match the old cluster, e.g., &lt;code&gt;postgresql.conf&lt;/code&gt; (and any files included by it), &lt;code&gt;postgresql.auto.conf&lt;/code&gt;.</source>
          <target state="translated">如果您修改了 &lt;code&gt;pg_hba.conf&lt;/code&gt; ，请恢复其原始设置。可能还需要调整新集群中的其他配置文件以匹配旧集群，例如 &lt;code&gt;postgresql.conf&lt;/code&gt; （及其包含的任何文件）， &lt;code&gt;postgresql.auto.conf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9316b03fae64e8c508527fbd0a6b640ef4256fda" translate="yes" xml:space="preserve">
          <source>If you modify files in &lt;code&gt;.../share/timezonesets/&lt;/code&gt;, it is up to you to make backups &amp;mdash; a normal database dump will not include this directory.</source>
          <target state="translated">如果您在 &lt;code&gt;.../share/timezonesets/&lt;/code&gt; 修改文件，则由您决定进行备份-普通的数据库转储将不包括该目录。</target>
        </trans-unit>
        <trans-unit id="a80020f6d5771b4994b2b6087bde0a758b0dbcc3" translate="yes" xml:space="preserve">
          <source>If you need to modify a table that already exists, see &lt;a href=&quot;ddl-alter&quot;&gt;Section 5.6&lt;/a&gt; later in this chapter.</source>
          <target state="translated">如果需要修改已经存在的表，请参阅本章后面的&lt;a href=&quot;ddl-alter&quot;&gt;5.6&lt;/a&gt;节。</target>
        </trans-unit>
        <trans-unit id="2efd34e960254e7fbc24d4c21228c55d47bceff1" translate="yes" xml:space="preserve">
          <source>If you need to re-create a standby server while transactions are waiting, make sure that the commands pg_start_backup() and pg_stop_backup() are run in a session with &lt;code&gt;synchronous_commit&lt;/code&gt; = &lt;code&gt;off&lt;/code&gt;, otherwise those requests will wait forever for the standby to appear.</source>
          <target state="translated">如果需要在事务等待期间重新创建备用服务器，请确保在 &lt;code&gt;synchronous_commit&lt;/code&gt; = &lt;code&gt;off&lt;/code&gt; 的会话中运行命令pg_start_backup（）和pg_stop_backup（），否则这些请求将永远等待备用数据库出现。</target>
        </trans-unit>
        <trans-unit id="335eb5a28fe752ac43ab7d0bdb87c591351c3327" translate="yes" xml:space="preserve">
          <source>If you no longer need a table, you can remove it using the &lt;a href=&quot;sql-droptable&quot;&gt;DROP TABLE&lt;/a&gt; command. For example:</source>
          <target state="translated">如果不再需要表，则可以使用&lt;a href=&quot;sql-droptable&quot;&gt;DROP TABLE&lt;/a&gt;命令将其删除。例如：</target>
        </trans-unit>
        <trans-unit id="4b094a7de4e477575e2b8864dd2a1871a2ac7be9" translate="yes" xml:space="preserve">
          <source>If you only need randomly-generated (version 4) UUIDs, consider using the &lt;code&gt;gen_random_uuid()&lt;/code&gt; function from the &lt;a href=&quot;pgcrypto&quot;&gt;pgcrypto&lt;/a&gt; module instead.</source>
          <target state="translated">如果只需要随机生成的（版本4）UUID，请考虑使用&lt;a href=&quot;pgcrypto&quot;&gt;pgcrypto&lt;/a&gt;模块中的 &lt;code&gt;gen_random_uuid()&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="c7ec64742024abd88ac376b90c1b4516681087ea" translate="yes" xml:space="preserve">
          <source>If you really cannot keep as many synchronous standbys as requested then you should decrease the number of synchronous standbys that transaction commits must wait for responses from in &lt;code&gt;synchronous_standby_names&lt;/code&gt; (or disable it) and reload the configuration file on the primary server.</source>
          <target state="translated">如果真按要求不能保持尽可能多的同步备用，那么你应该减少同步备用的数量提交事务必须等待响应从 &lt;code&gt;synchronous_standby_names&lt;/code&gt; （或禁用），并重新加载主服务器上的配置文件。</target>
        </trans-unit>
        <trans-unit id="afb9b1746ef64ef43e1c6a611287b8838f8bab6f" translate="yes" xml:space="preserve">
          <source>If you really need to do something like that, you can either write a custom operator or add explicit casts to your query:</source>
          <target state="translated">如果你真的需要做这样的事情,你可以写一个自定义的操作符,或者在你的查询中添加显式casts。</target>
        </trans-unit>
        <trans-unit id="4c6cec6fc682547181945340072f15c49a175a52" translate="yes" xml:space="preserve">
          <source>If you require exact storage and calculations (such as for monetary amounts), use the &lt;code&gt;numeric&lt;/code&gt; type instead.</source>
          <target state="translated">如果您需要精确的存储和计算（例如，金额），请使用 &lt;code&gt;numeric&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="dda0ebbf2c21ed8ce369ceb9f7962ccab8e8d4c2" translate="yes" xml:space="preserve">
          <source>If you see a message similar to:</source>
          <target state="translated">如果你看到类似的信息。</target>
        </trans-unit>
        <trans-unit id="5944bf42cb7e9bed827543dce0bb5da3eb25aaf4" translate="yes" xml:space="preserve">
          <source>If you select the &lt;code&gt;select-only&lt;/code&gt; built-in (also &lt;code&gt;-S&lt;/code&gt;), only the &lt;code&gt;SELECT&lt;/code&gt; is issued.</source>
          <target state="translated">如果选择 &lt;code&gt;select-only&lt;/code&gt; 内置（也为 &lt;code&gt;-S&lt;/code&gt; ），则仅发出 &lt;code&gt;SELECT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c440cbb3c75274ef5533f9dc20d09bc792bb4404" translate="yes" xml:space="preserve">
          <source>If you select the &lt;code&gt;simple-update&lt;/code&gt; built-in (also &lt;code&gt;-N&lt;/code&gt;), steps 4 and 5 aren't included in the transaction. This will avoid update contention on these tables, but it makes the test case even less like TPC-B.</source>
          <target state="translated">如果选择内置的 &lt;code&gt;simple-update&lt;/code&gt; （也为 &lt;code&gt;-N&lt;/code&gt; ），则事务中不包含步骤4和5。这样可以避免在这些表上发生更新争用，但是这会使测试用例像TPC-B一样少。</target>
        </trans-unit>
        <trans-unit id="2410e185ebe01d4bbafd07fc62d71b97897582e4" translate="yes" xml:space="preserve">
          <source>If you set a nonempty value for &lt;code&gt;log_line_prefix&lt;/code&gt;, you should usually make its last character be a space, to provide visual separation from the rest of the log line. A punctuation character can be used too.</source>
          <target state="translated">如果为 &lt;code&gt;log_line_prefix&lt;/code&gt; 设置了非空值，则通常应将其最后一个字符作为空格，以与日志行的其余部分保持视觉上的分隔。也可以使用标点符号。</target>
        </trans-unit>
        <trans-unit id="293043269744dfe0b2be9f58f146808d29c819d1" translate="yes" xml:space="preserve">
          <source>If you simply direct the stderr of &lt;code&gt;postgres&lt;/code&gt; into a file, you will have log output, but the only way to truncate the log file is to stop and restart the server. This might be acceptable if you are using PostgreSQL in a development environment, but few production servers would find this behavior acceptable.</source>
          <target state="translated">如果仅将 &lt;code&gt;postgres&lt;/code&gt; 的stderr定向到文件中，则将有日志输出，但是截断日志文件的唯一方法是停止并重新启动服务器。如果在开发环境中使用PostgreSQL，这可能是可以接受的，但是很少有生产服务器会认为这种行为可以接受。</target>
        </trans-unit>
        <trans-unit id="9ce920b3e4b27527a0945161fb81196b0962a822" translate="yes" xml:space="preserve">
          <source>If you simply write:</source>
          <target state="translated">如果你只是写。</target>
        </trans-unit>
        <trans-unit id="86278d59973a9bff1da8685bc91d01d4bca2172c" translate="yes" xml:space="preserve">
          <source>If you specify a &lt;code&gt;prefix&lt;/code&gt;, that string is prepended to the query's column names to create the variable names to use:</source>
          <target state="translated">如果您指定一个 &lt;code&gt;prefix&lt;/code&gt; ，则该字符串会被添加到查询的列名之前，以创建要使用的变量名：</target>
        </trans-unit>
        <trans-unit id="4293f633ad719b6229d97888e7c493efba01b4c4" translate="yes" xml:space="preserve">
          <source>If you specify a file name without escapes, you should plan to use a log rotation utility to avoid eventually filling the entire disk. In releases prior to 8.4, if no &lt;code&gt;%&lt;/code&gt; escapes were present, PostgreSQL would append the epoch of the new log file's creation time, but this is no longer the case.</source>
          <target state="translated">如果指定的文件名没有转义符，则应计划使用日志轮换实用程序以避免最终填满整个磁盘。在8.4之前的版本中，如果不存在 &lt;code&gt;%&lt;/code&gt; 转义符，PostgreSQL将附加新日志文件创建时间的纪元，但是现在不再如此。</target>
        </trans-unit>
        <trans-unit id="cd2bed205787104a93fce03bc6421721af1bc122" translate="yes" xml:space="preserve">
          <source>If you specify columns, you probably have to escape the parentheses from the shell. (See examples below.)</source>
          <target state="translated">如果你指定了列,你可能要在shell中转义括号。(请看下面的例子。)</target>
        </trans-unit>
        <trans-unit id="c697983f7b5aa306c7f0f7a672c31b1b3cec3536" translate="yes" xml:space="preserve">
          <source>If you suspect corruption of an index on a user table, you can simply rebuild that index, or all indexes on the table, using &lt;code&gt;REINDEX INDEX&lt;/code&gt; or &lt;code&gt;REINDEX TABLE&lt;/code&gt;.</source>
          <target state="translated">如果您怀疑用户表上的索引损坏，则可以使用 &lt;code&gt;REINDEX INDEX&lt;/code&gt; 或 &lt;code&gt;REINDEX TABLE&lt;/code&gt; 重建该索引或表上的所有索引。</target>
        </trans-unit>
        <trans-unit id="634ba98da8d49a37a8349e78baa14c6e91b78095" translate="yes" xml:space="preserve">
          <source>If you use link mode, the upgrade will be much faster (no file copying) and use less disk space, but you will not be able to access your old cluster once you start the new cluster after the upgrade. Link mode also requires that the old and new cluster data directories be in the same file system. (Tablespaces and &lt;code&gt;pg_wal&lt;/code&gt; can be on different file systems.) Clone mode provides the same speed and disk space advantages but does not cause the old cluster to be unusable once the new cluster is started. Clone mode also requires that the old and new data directories be in the same file system. This mode is only available on certain operating systems and file systems.</source>
          <target state="translated">如果使用链接模式，则升级将更快（不复制文件）并且使用更少的磁盘空间，但是一旦升级后启动新集群，您将无法访问旧集群。链接模式还要求新旧群集数据目录位于同一文件系统中。 （表空间和 &lt;code&gt;pg_wal&lt;/code&gt; 可以位于不同的文件系统上。）克隆模式具有相同的速度和磁盘空间优势，但是一旦启动新集群，就不会导致旧集群不可用。克隆模式还要求新旧数据目录位于同一文件系统中。此模式仅在某些操作系统和文件系统上可用。</target>
        </trans-unit>
        <trans-unit id="fe9e0a997d4a5f8ab6d05deb3608c7b48d1004eb" translate="yes" xml:space="preserve">
          <source>If you use streaming replication without file-based continuous archiving, the server might recycle old WAL segments before the standby has received them. If this occurs, the standby will need to be reinitialized from a new base backup. You can avoid this by setting &lt;code&gt;wal_keep_segments&lt;/code&gt; to a value large enough to ensure that WAL segments are not recycled too early, or by configuring a replication slot for the standby. If you set up a WAL archive that's accessible from the standby, these solutions are not required, since the standby can always use the archive to catch up provided it retains enough segments.</source>
          <target state="translated">如果使用流式复制而没有基于文件的连续归档，则服务器可能会在备用数据库收到旧的WAL段之前对其进行回收。如果发生这种情况，则需要从新的基本备份中重新初始化备用数据库。您可以通过将 &lt;code&gt;wal_keep_segments&lt;/code&gt; 设置为足够大的值来确保WAL段不被过早回收，或者为备用数据库配置复制插槽来避免这种情况。如果您设置了可从备用数据库访问的WAL存档，则不需要这些解决方案，因为只要备用数据库保留足够的段，它就可以始终使用该存档进行追赶。</target>
        </trans-unit>
        <trans-unit id="3198519c857584cca4870e5482467b87f1de4701" translate="yes" xml:space="preserve">
          <source>If you use streaming replication without file-based continuous archiving, the server might recycle old WAL segments before the standby has received them. If this occurs, the standby will need to be reinitialized from a new base backup. You can avoid this by setting &lt;code&gt;wal_keep_size&lt;/code&gt; to a value large enough to ensure that WAL segments are not recycled too early, or by configuring a replication slot for the standby. If you set up a WAL archive that's accessible from the standby, these solutions are not required, since the standby can always use the archive to catch up provided it retains enough segments.</source>
          <target state="translated">如果使用流式复制而没有基于文件的连续归档，则服务器可能会在备用数据库收到旧的WAL段之前对其进行回收。如果发生这种情况，则需要从新的基本备份中重新初始化备用数据库。您可以通过将 &lt;code&gt;wal_keep_size&lt;/code&gt; 设置为足够大的值来确保WAL段不被过早回收，或者为备用数据库配置复制插槽来避免这种情况。如果您设置了可从备用数据库访问的WAL存档，则不需要这些解决方案，因为只要备用数据库保留足够的段，它就可以始终使用该存档来进行追赶。</target>
        </trans-unit>
        <trans-unit id="410c6fd96b75590acd8e3654ea56e9babc9667ce" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;\o&lt;/code&gt; command to redirect your query output you might wish to use &lt;code&gt;\qecho&lt;/code&gt; instead of this command.</source>
          <target state="translated">如果使用 &lt;code&gt;\o&lt;/code&gt; 命令重定向查询输出，则可能希望使用 &lt;code&gt;\qecho&lt;/code&gt; 而不是此命令。</target>
        </trans-unit>
        <trans-unit id="0373a56e2165e1341cdef2084a1dbcf9d28e7801" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;\o&lt;/code&gt; command to redirect your query output you might wish to use &lt;code&gt;\qecho&lt;/code&gt; instead of this command. See also &lt;code&gt;\warn&lt;/code&gt;.</source>
          <target state="translated">如果使用 &lt;code&gt;\o&lt;/code&gt; 命令重定向查询输出，则可能希望使用 &lt;code&gt;\qecho&lt;/code&gt; 而不是此命令。另请参见 &lt;code&gt;\warn&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dacf2afd67d1d9e6693b9e34a44e3f31343f07b9" translate="yes" xml:space="preserve">
          <source>If you used link mode and have Streaming Replication (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;) or Log-Shipping (see &lt;a href=&quot;warm-standby&quot;&gt;Section 26.2&lt;/a&gt;) standby servers, you can follow these steps to quickly upgrade them. You will not be running pg_upgrade on the standby servers, but rather rsync on the primary. Do not start any servers yet.</source>
          <target state="translated">如果您使用链接模式并具有Streaming Replication（请参阅&lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;第26.2.5节&lt;/a&gt;）或Log-Shipping（请参阅&lt;a href=&quot;warm-standby&quot;&gt;第26.2节&lt;/a&gt;）备用服务器，则可以按照以下步骤快速升级它们。您将不会在备用服务器上运行pg_upgrade，而是在主服务器上运行rsync。尚未启动任何服务器。</target>
        </trans-unit>
        <trans-unit id="46579b8a1d951df62d56dbc7236dffbdfa323aee" translate="yes" xml:space="preserve">
          <source>If you want an empty string rather than NULL, write double quotes:</source>
          <target state="translated">如果你想要一个空字符串而不是NULL,写双引号。</target>
        </trans-unit>
        <trans-unit id="e23816131f85edfcf8ebf4baf1b8f5a4f82e1a1c" translate="yes" xml:space="preserve">
          <source>If you want the digest as a hexadecimal string, use &lt;code&gt;encode()&lt;/code&gt; on the result. For example:</source>
          <target state="translated">如果要将摘要作为十六进制字符串，请在结果上使用 &lt;code&gt;encode()&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="c7212923c1936242a3a328b31eba624a84bab3c5" translate="yes" xml:space="preserve">
          <source>If you want the system to behave as if it had no locale support, use the special locale name &lt;code&gt;C&lt;/code&gt;, or equivalently &lt;code&gt;POSIX&lt;/code&gt;.</source>
          <target state="translated">如果希望系统表现为不支持语言环境，则使用特殊的语言环境名称 &lt;code&gt;C&lt;/code&gt; 或等效的 &lt;code&gt;POSIX&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f51609486b727fbe8393280c5551d1122917313" translate="yes" xml:space="preserve">
          <source>If you want to add a new method of making the data representation smaller, you must implement it in &lt;code&gt;reformat_dat_file.pl&lt;/code&gt; and also teach &lt;code&gt;Catalog::ParseData()&lt;/code&gt; how to expand the data back into the full representation.</source>
          <target state="translated">如果要添加使数据表示形式更小的新方法，则必须在 &lt;code&gt;reformat_dat_file.pl&lt;/code&gt; 实现它，并且还应教 &lt;code&gt;Catalog::ParseData()&lt;/code&gt; 如何将数据扩展回完整的表示形式。</target>
        </trans-unit>
        <trans-unit id="7f058b6974f7c4fc1a4fda33213fb953c4c820d2" translate="yes" xml:space="preserve">
          <source>If you want to do complicated calculations with these types for anything important, especially if you rely on certain behavior in boundary cases (infinity, underflow), you should evaluate the implementation carefully.</source>
          <target state="translated">如果你想用这些类型做任何重要的复杂计算,特别是当你依赖边界情况下的某些行为(无穷大,下溢),你应该仔细评估实现。</target>
        </trans-unit>
        <trans-unit id="f8d0dd9f6c3474fc520b6c68678cb5772392894d" translate="yes" xml:space="preserve">
          <source>If you want to have a double quote in the output you must precede it with a backslash, for example &lt;code&gt;'\&quot;YYYY Month\&quot;'&lt;/code&gt;. Backslashes are not otherwise special outside of double-quoted strings. Within a double-quoted string, a backslash causes the next character to be taken literally, whatever it is (but this has no special effect unless the next character is a double quote or another backslash).</source>
          <target state="translated">如果要在输出中使用双引号，则必须在其前加上反斜杠，例如 &lt;code&gt;'\&quot;YYYY Month\&quot;'&lt;/code&gt; 。反斜杠在双引号字符串之外不是特殊的。在双引号字符串中，反斜杠使下一个字符按字面意义使用，无论它是什么（但是除非下一个字符是双引号或另一个反斜杠，否则这没有特殊作用）。</target>
        </trans-unit>
        <trans-unit id="b08912c8afafc035000c2b91395d4762ff623ba7" translate="yes" xml:space="preserve">
          <source>If you want to recover to some previous point in time (say, right before the junior DBA dropped your main transaction table), just specify the required &lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-RECOVERY-TARGET&quot;&gt;stopping point&lt;/a&gt;. You can specify the stop point, known as the &amp;ldquo;recovery target&amp;rdquo;, either by date/time, named restore point or by completion of a specific transaction ID. As of this writing only the date/time and named restore point options are very usable, since there are no tools to help you identify with any accuracy which transaction ID to use.</source>
          <target state="translated">如果要恢复到先前的某个时间点（例如，在初级DBA删除主事务表之前），只需指定所需的&lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-RECOVERY-TARGET&quot;&gt;停止点&lt;/a&gt;。您可以按日期/时间，命名的还原点或特定事务ID的完成指定停止点，称为&amp;ldquo;恢复目标&amp;rdquo;。在撰写本文时，只有日期/时间和命名的还原点选项非常有用，因为没有工具可以帮助您准确地确定要使用的交易ID。</target>
        </trans-unit>
        <trans-unit id="f2799eac42b252d1fdead69c5594bb2d3a2059fa" translate="yes" xml:space="preserve">
          <source>If you want to run a parallel dump of a pre-9.2 server, you need to make sure that the database content doesn't change from between the time the master connects to the database until the last worker job has connected to the database. The easiest way to do this is to halt any data modifying processes (DDL and DML) accessing the database before starting the backup. You also need to specify the &lt;code&gt;--no-synchronized-snapshots&lt;/code&gt; parameter when running &lt;code&gt;pg_dump -j&lt;/code&gt; against a pre-9.2 PostgreSQL server.</source>
          <target state="translated">如果要运行9.2之前版本服务器的并行转储，则需要确保从主服务器连接到数据库到最后一个工作者作业连接到数据库之间的时间里，数据库内容没有变化。最简单的方法是在开始备份之前，停止所有访问数据库的数据修改过程（DDL和DML）。在9.2版之前的PostgreSQL服务器上运行 &lt;code&gt;pg_dump -j&lt;/code&gt; 时，还需要指定 &lt;code&gt;--no-synchronized-snapshots&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="1235d6c60bdf10ad9cf9d8bf29ece023d11255aa" translate="yes" xml:space="preserve">
          <source>If you want to see the lines on the screen as they are read you must set the variable &lt;code&gt;ECHO&lt;/code&gt; to &lt;code&gt;all&lt;/code&gt;.</source>
          <target state="translated">如果要在阅读时看到屏幕上的行，则必须将变量 &lt;code&gt;ECHO&lt;/code&gt; 设置为 &lt;code&gt;all&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d777fa853e95af192514bf1aeb804e6308b39ad2" translate="yes" xml:space="preserve">
          <source>If you want to use link mode and you do not want your old cluster to be modified when the new cluster is started, consider using the clone mode. If that is not available, make a copy of the old cluster and upgrade that in link mode. To make a valid copy of the old cluster, use &lt;code&gt;rsync&lt;/code&gt; to create a dirty copy of the old cluster while the server is running, then shut down the old server and run &lt;code&gt;rsync --checksum&lt;/code&gt; again to update the copy with any changes to make it consistent. (&lt;code&gt;--checksum&lt;/code&gt; is necessary because &lt;code&gt;rsync&lt;/code&gt; only has file modification-time granularity of one second.) You might want to exclude some files, e.g. &lt;code&gt;postmaster.pid&lt;/code&gt;, as documented in &lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP&quot;&gt;Section 25.3.3&lt;/a&gt;. If your file system supports file system snapshots or copy-on-write file copies, you can use that to make a backup of the old cluster and tablespaces, though the snapshot and copies must be created simultaneously or while the database server is down.</source>
          <target state="translated">如果要使用链接模式，并且不想在启动新集群时修改旧集群，请考虑使用克隆模式。如果不可用，请复制旧群集，然后以链接模式进行升级。要创建旧集群的有效副本，请在服务器运行时使用 &lt;code&gt;rsync&lt;/code&gt; 创建旧集群的脏副本，然后关闭旧服务器，然后再次运行 &lt;code&gt;rsync --checksum&lt;/code&gt; 以进行任何更改来更新该副本。一致的。 （ &lt;code&gt;--checksum&lt;/code&gt; 是必需的，因为 &lt;code&gt;rsync&lt;/code&gt; 仅具有一秒钟的文件修改时间粒度。）您可能想要排除一些文件，例如 &lt;code&gt;postmaster.pid&lt;/code&gt; ，如&lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP&quot;&gt;第25.3.3节中所述。&lt;/a&gt;。如果您的文件系统支持文件系统快照或写时复制文件副本，尽管必须同时创建快照和副本或在数据库服务器关闭时创建快照，但仍可以使用它来备份旧的集群和表空间。</target>
        </trans-unit>
        <trans-unit id="a968160add8cfcbfd7bfae07842aa9c1a4f8617c" translate="yes" xml:space="preserve">
          <source>If you want to use link mode and you do not want your old cluster to be modified when the new cluster is started, consider using the clone mode. If that is not available, make a copy of the old cluster and upgrade that in link mode. To make a valid copy of the old cluster, use &lt;code&gt;rsync&lt;/code&gt; to create a dirty copy of the old cluster while the server is running, then shut down the old server and run &lt;code&gt;rsync --checksum&lt;/code&gt; again to update the copy with any changes to make it consistent. (&lt;code&gt;--checksum&lt;/code&gt; is necessary because &lt;code&gt;rsync&lt;/code&gt; only has file modification-time granularity of one second.) You might want to exclude some files, e.g., &lt;code&gt;postmaster.pid&lt;/code&gt;, as documented in &lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP&quot;&gt;Section 25.3.3&lt;/a&gt;. If your file system supports file system snapshots or copy-on-write file copies, you can use that to make a backup of the old cluster and tablespaces, though the snapshot and copies must be created simultaneously or while the database server is down.</source>
          <target state="translated">如果要使用链接模式，并且不希望在启动新集群时修改旧集群，请考虑使用克隆模式。如果不可用，请复制旧群集，然后以链接模式进行升级。要创建旧集群的有效副本，请在服务器运行时使用 &lt;code&gt;rsync&lt;/code&gt; 创建旧集群的脏副本，然后关闭旧服务器，然后再次运行 &lt;code&gt;rsync --checksum&lt;/code&gt; 以进行任何更改来更新该副本。持续的。（ &lt;code&gt;--checksum&lt;/code&gt; 是必需的，因为 &lt;code&gt;rsync&lt;/code&gt; 仅具有一秒钟的文件修改时间粒度。）您可能希望排除一些文件，例如 &lt;code&gt;postmaster.pid&lt;/code&gt; ，如&lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP&quot;&gt;第25.3.3节中所述。&lt;/a&gt;。如果您的文件系统支持文件系统快照或写时复制文件副本，尽管必须同时创建快照和副本或在数据库服务器关闭时创建快照，但是可以使用该文件系统来备份旧集群和表空间。</target>
        </trans-unit>
        <trans-unit id="548498a07974c2669fa7d265bb5ed01fd29f2726" translate="yes" xml:space="preserve">
          <source>If you want to use psql to connect to several servers of different major versions, it is recommended that you use the newest version of psql. Alternatively, you can keep around a copy of psql from each major version and be sure to use the version that matches the respective server. But in practice, this additional complication should not be necessary.</source>
          <target state="translated">如果你想用psql连接多个不同主流版本的服务器,建议你使用最新版本的psql。另外,你也可以在身边保留一份各主要版本的psql,并确保使用与各服务器相匹配的版本。但在实际操作中,这种额外的复杂性应该是没有必要的。</target>
        </trans-unit>
        <trans-unit id="c83197bfbed6d42e302edf49770400c3bb7ffc90" translate="yes" xml:space="preserve">
          <source>If you want to use streaming replication, fill in &lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-CONNINFO&quot;&gt;primary_conninfo&lt;/a&gt; with a libpq connection string, including the host name (or IP address) and any additional details needed to connect to the primary server. If the primary needs a password for authentication, the password needs to be specified in &lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-CONNINFO&quot;&gt;primary_conninfo&lt;/a&gt; as well.</source>
          <target state="translated">如果要使用流复制，请使用libpq连接字符串（包括主机名（或IP地址）以及连接到主服务器所需的任何其他详细信息）填充&lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-CONNINFO&quot;&gt;primary_conninfo&lt;/a&gt;。如果主服务器需要密码进行身份验证，则还需要在&lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-CONNINFO&quot;&gt;primary_conninfo中&lt;/a&gt;指定密码。</target>
        </trans-unit>
        <trans-unit id="8304e11449eef667491dd46bf0e842007ab0620d" translate="yes" xml:space="preserve">
          <source>If you want to use streaming replication, set up authentication on the primary server to allow replication connections from the standby server(s); that is, create a role and provide a suitable entry or entries in &lt;code&gt;pg_hba.conf&lt;/code&gt; with the database field set to &lt;code&gt;replication&lt;/code&gt;. Also ensure &lt;code&gt;max_wal_senders&lt;/code&gt; is set to a sufficiently large value in the configuration file of the primary server. If replication slots will be used, ensure that &lt;code&gt;max_replication_slots&lt;/code&gt; is set sufficiently high as well.</source>
          <target state="translated">如果要使用流式复制，请在主服务器上设置身份验证，以允许来自备用服务器的复制连接。也就是说，创建一个角色并在 &lt;code&gt;pg_hba.conf&lt;/code&gt; 中提供一个或多个合适的条目，并将数据库字段设置为 &lt;code&gt;replication&lt;/code&gt; 。还要确保在主服务器的配置文件 &lt;code&gt;max_wal_senders&lt;/code&gt; 设置为足够大的值。如果将使用复制插槽，请确保 &lt;code&gt;max_replication_slots&lt;/code&gt; 设置为足够高。</target>
        </trans-unit>
        <trans-unit id="d505643f0e154d892e49d0ce311315a8a63b86fd" translate="yes" xml:space="preserve">
          <source>If you wish to create a new superuser, you must connect as a superuser, not merely with &lt;code&gt;CREATEROLE&lt;/code&gt; privilege. Being a superuser implies the ability to bypass all access permission checks within the database, so superuserdom should not be granted lightly.</source>
          <target state="translated">如果要创建新的超级用户，则必须以超级用户身份连接，而不仅要具有 &lt;code&gt;CREATEROLE&lt;/code&gt; 特权。成为超级用户意味着能够绕过数据库内的所有访问权限检查，因此不应轻易授予超级用户权限。</target>
        </trans-unit>
        <trans-unit id="dba6f63305bb053e32c8873d900ab4a929146d0b" translate="yes" xml:space="preserve">
          <source>If you wish to drop a role for which the default privileges have been altered, it is necessary to reverse the changes in its default privileges or use &lt;code&gt;DROP OWNED BY&lt;/code&gt; to get rid of the default privileges entry for the role.</source>
          <target state="translated">如果要删除已更改了默认特权的角色，则必须撤消其默认特权的更改，或使用 &lt;code&gt;DROP OWNED BY&lt;/code&gt; 摆脱该角色的默认特权条目。</target>
        </trans-unit>
        <trans-unit id="fe513e6fe150eda65f8a240b4c5ab71cf30d3ea3" translate="yes" xml:space="preserve">
          <source>If you wish to keep the configuration files elsewhere than the data directory, the &lt;code&gt;postgres&lt;/code&gt;&lt;code&gt;-D&lt;/code&gt; command-line option or &lt;code&gt;PGDATA&lt;/code&gt; environment variable must point to the directory containing the configuration files, and the &lt;code&gt;data_directory&lt;/code&gt; parameter must be set in &lt;code&gt;postgresql.conf&lt;/code&gt; (or on the command line) to show where the data directory is actually located. Notice that &lt;code&gt;data_directory&lt;/code&gt; overrides &lt;code&gt;-D&lt;/code&gt; and &lt;code&gt;PGDATA&lt;/code&gt; for the location of the data directory, but not for the location of the configuration files.</source>
          <target state="translated">如果希望将配置文件保留在数据目录之外的其他位置，则 &lt;code&gt;postgres&lt;/code&gt; &lt;code&gt;-D&lt;/code&gt; 命令行选项或 &lt;code&gt;PGDATA&lt;/code&gt; 环境变量必须指向包含配置文件的目录，并且 &lt;code&gt;data_directory&lt;/code&gt; 参数必须在 &lt;code&gt;postgresql.conf&lt;/code&gt; 中设置（或在命令行）以显示数据目录的实际位置。请注意， &lt;code&gt;data_directory&lt;/code&gt; 在数据目录的位置上覆盖了 &lt;code&gt;-D&lt;/code&gt; 和 &lt;code&gt;PGDATA&lt;/code&gt; ，但在配置文件的位置上未覆盖。</target>
        </trans-unit>
        <trans-unit id="5e43ef9c20e530883e37f2ea188b5ba2ab7b89db" translate="yes" xml:space="preserve">
          <source>If you wish, you can specify the configuration file names and locations individually using the parameters &lt;code&gt;config_file&lt;/code&gt;, &lt;code&gt;hba_file&lt;/code&gt; and/or &lt;code&gt;ident_file&lt;/code&gt;. &lt;code&gt;config_file&lt;/code&gt; can only be specified on the &lt;code&gt;postgres&lt;/code&gt; command line, but the others can be set within the main configuration file. If all three parameters plus &lt;code&gt;data_directory&lt;/code&gt; are explicitly set, then it is not necessary to specify &lt;code&gt;-D&lt;/code&gt; or &lt;code&gt;PGDATA&lt;/code&gt;.</source>
          <target state="translated">如果需要，可以使用 &lt;code&gt;config_file&lt;/code&gt; ， &lt;code&gt;hba_file&lt;/code&gt; 和/或 &lt;code&gt;ident_file&lt;/code&gt; 参数分别指定配置文件的名称和位置。 &lt;code&gt;config_file&lt;/code&gt; 只能在 &lt;code&gt;postgres&lt;/code&gt; 命令行上指定，而其他可以在主配置文件中设置。如果显式设置了所有三个参数以及 &lt;code&gt;data_directory&lt;/code&gt; ，则无需指定 &lt;code&gt;-D&lt;/code&gt; 或 &lt;code&gt;PGDATA&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="32daceaa2cf366c2fe6d0715c4458443ee88a963" translate="yes" xml:space="preserve">
          <source>If you're setting up the standby server for high availability purposes, set up WAL archiving, connections and authentication like the primary server, because the standby server will work as a primary server after failover.</source>
          <target state="translated">如果你是为了高可用性的目的而设置备用服务器,请像设置主服务器一样设置WAL归档、连接和认证,因为备用服务器在故障转移后将作为主服务器工作。</target>
        </trans-unit>
        <trans-unit id="c5ac9027a677c31c54f143f0fe38940b45904e3a" translate="yes" xml:space="preserve">
          <source>If you're using a WAL archive, its size can be minimized using the &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-CLEANUP-COMMAND&quot;&gt;archive_cleanup_command&lt;/a&gt; parameter to remove files that are no longer required by the standby server. The pg_archivecleanup utility is designed specifically to be used with &lt;code&gt;archive_cleanup_command&lt;/code&gt; in typical single-standby configurations, see &lt;a href=&quot;pgarchivecleanup&quot;&gt;pg_archivecleanup&lt;/a&gt;. Note however, that if you're using the archive for backup purposes, you need to retain files needed to recover from at least the latest base backup, even if they're no longer needed by the standby.</source>
          <target state="translated">如果您使用的是WAL存档，则可以使用&lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-CLEANUP-COMMAND&quot;&gt;archive_cleanup_command&lt;/a&gt;参数来最小化其大小，以删除备用服务器不再需要的文件。 pg_archivecleanup实用程序专门设计用于在典型的单备用配置中与 &lt;code&gt;archive_cleanup_command&lt;/code&gt; 一起使用，请参阅&lt;a href=&quot;pgarchivecleanup&quot;&gt;pg_archivecleanup&lt;/a&gt;。但是请注意，如果将存档用于备份目的，则即使从备数据库不再需要这些文件，也至少需要保留从最新基础备份中恢复所需的文件。</target>
        </trans-unit>
        <trans-unit id="eede8f4eab7ac7c7f42522f0f50f00f83f33b103" translate="yes" xml:space="preserve">
          <source>If your application needs to use other forms of partitioning not listed above, alternative methods such as inheritance and &lt;code&gt;UNION ALL&lt;/code&gt; views can be used instead. Such methods offer flexibility but do not have some of the performance benefits of built-in declarative partitioning.</source>
          <target state="translated">如果您的应用程序需要使用上面未列出的其他分区形式，则可以使用替代方法，例如继承和 &lt;code&gt;UNION ALL&lt;/code&gt; 视图。此类方法提供了灵活性，但没有内置声明性分区的某些性能优势。</target>
        </trans-unit>
        <trans-unit id="693883e4d7e5062d3b1b4e420d1dcd21d56fe252" translate="yes" xml:space="preserve">
          <source>If your database cluster has any local additions to the &lt;code&gt;template1&lt;/code&gt; database, be careful to restore the output of pg_dump into a truly empty database; otherwise you are likely to get errors due to duplicate definitions of the added objects. To make an empty database without any local additions, copy from &lt;code&gt;template0&lt;/code&gt; not &lt;code&gt;template1&lt;/code&gt;, for example:</source>
          <target state="translated">如果您的数据库集群对 &lt;code&gt;template1&lt;/code&gt; 数据库有任何本地添加，请小心地将pg_dump的输出还原到一个真正的空数据库中；否则，由于添加对象的重复定义，您很可能会出错。要创建没有任何本地添加的空数据库，请从 &lt;code&gt;template0&lt;/code&gt; 而不是 &lt;code&gt;template1&lt;/code&gt; 复制，例如：</target>
        </trans-unit>
        <trans-unit id="bfe8c7a1e0073145cfd43127c90a639a57c975f4" translate="yes" xml:space="preserve">
          <source>If your database is spread across multiple file systems, there might not be any way to obtain exactly-simultaneous frozen snapshots of all the volumes. For example, if your data files and WAL log are on different disks, or if tablespaces are on different file systems, it might not be possible to use snapshot backup because the snapshots &lt;em&gt;must&lt;/em&gt; be simultaneous. Read your file system documentation very carefully before trusting the consistent-snapshot technique in such situations.</source>
          <target state="translated">如果您的数据库分布在多个文件系统中，则可能没有任何方法可以获取所有卷的完全同步的冻结快照。例如，如果数据文件和WAL日志位于不同的磁盘上，或者表空间位于不同的文件系统上，则可能无法使用快照备份，因为快照&lt;em&gt;必须&lt;/em&gt;同时进行。在这种情况下，请在使用一致快照技术之前非常仔细地阅读文件系统文档。</target>
        </trans-unit>
        <trans-unit id="89affde528d7a785d4590b760f08553f5fba2e5e" translate="yes" xml:space="preserve">
          <source>If your installation directory is not version-specific, e.g. &lt;code&gt;/usr/local/pgsql&lt;/code&gt;, it is necessary to move the current PostgreSQL install directory so it does not interfere with the new PostgreSQL installation. Once the current PostgreSQL server is shut down, it is safe to rename the PostgreSQL installation directory; assuming the old directory is &lt;code&gt;/usr/local/pgsql&lt;/code&gt;, you can do:</source>
          <target state="translated">如果您的安装目录不是特定于版本的，例如 &lt;code&gt;/usr/local/pgsql&lt;/code&gt; ，则必须移动当前的PostgreSQL安装目录，以免干扰新的PostgreSQL安装。一旦关闭当前的PostgreSQL服务器，就可以重命名PostgreSQL安装目录了。假设旧目录为 &lt;code&gt;/usr/local/pgsql&lt;/code&gt; ，则可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="b225941ba48c705a72d951ae004bd3007fba63eb" translate="yes" xml:space="preserve">
          <source>If your installation directory is not version-specific, e.g., &lt;code&gt;/usr/local/pgsql&lt;/code&gt;, it is necessary to move the current PostgreSQL install directory so it does not interfere with the new PostgreSQL installation. Once the current PostgreSQL server is shut down, it is safe to rename the PostgreSQL installation directory; assuming the old directory is &lt;code&gt;/usr/local/pgsql&lt;/code&gt;, you can do:</source>
          <target state="translated">如果您的安装目录不是特定于版本的，例如 &lt;code&gt;/usr/local/pgsql&lt;/code&gt; ，则必须移动当前的PostgreSQL安装目录，以免干扰新的PostgreSQL安装。一旦关闭当前的PostgreSQL服务器，就可以安全地重命名PostgreSQL安装目录。假设旧目录为 &lt;code&gt;/usr/local/pgsql&lt;/code&gt; ，则可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="cd01544b621df2f2698aa331ec7e1d502c246c7e" translate="yes" xml:space="preserve">
          <source>If your installation has any local additions to the &lt;code&gt;template1&lt;/code&gt; database, be careful to load the output of pg_restore into a truly empty database; otherwise you are likely to get errors due to duplicate definitions of the added objects. To make an empty database without any local additions, copy from &lt;code&gt;template0&lt;/code&gt; not &lt;code&gt;template1&lt;/code&gt;, for example:</source>
          <target state="translated">如果您的安装对 &lt;code&gt;template1&lt;/code&gt; 数据库有任何本地添加，请小心将pg_restore的输出加载到一个真正的空数据库中。否则，由于添加对象的重复定义，您很可能会出错。要创建没有任何本地添加的空数据库，请从 &lt;code&gt;template0&lt;/code&gt; 而不是 &lt;code&gt;template1&lt;/code&gt; 复制，例如：</target>
        </trans-unit>
        <trans-unit id="fb5ad20ebf8b8594ba828c2e14073cc42a290699" translate="yes" xml:space="preserve">
          <source>If your needs go beyond the capabilities of these conditional expressions, you might want to consider writing a server-side function in a more expressive programming language.</source>
          <target state="translated">如果你的需求超出了这些条件表达式的能力,你可能要考虑用一种更有表现力的编程语言编写一个服务器端函数。</target>
        </trans-unit>
        <trans-unit id="092f5bf3a3fbeb060b8f061dfe4479d40fe497ca" translate="yes" xml:space="preserve">
          <source>If your site administrator has not set things up in the default way, you might have some more work to do. For example, if the database server machine is a remote machine, you will need to set the &lt;code&gt;PGHOST&lt;/code&gt; environment variable to the name of the database server machine. The environment variable &lt;code&gt;PGPORT&lt;/code&gt; might also have to be set. The bottom line is this: if you try to start an application program and it complains that it cannot connect to the database, you should consult your site administrator or, if that is you, the documentation to make sure that your environment is properly set up. If you did not understand the preceding paragraph then read the next section.</source>
          <target state="translated">如果您的站点管理员未以默认方式进行设置，则您可能还有更多工作要做。例如，如果数据库服务器计算机是远程计算机，则需要将 &lt;code&gt;PGHOST&lt;/code&gt; 环境变量设置为数据库服务器计算机的名称。可能还必须设置环境变量 &lt;code&gt;PGPORT&lt;/code&gt; 。底线是这样的：如果您尝试启动一个应用程序并且抱怨它无法连接到数据库，则应该咨询您的站点管理员，或者如果您是您，请向该文档咨询以确保您的环境已正确设置。 。如果您不理解上一段，请阅读下一节。</target>
        </trans-unit>
        <trans-unit id="0e26c0628db89c4d17246b09878aa1c2d36a0d98" translate="yes" xml:space="preserve">
          <source>If your system supports per-user disk quotas, then the database will naturally be subject to whatever quota is placed on the user the server runs as. Exceeding the quota will have the same bad effects as running out of disk space entirely.</source>
          <target state="translated">如果你的系统支持每个用户的磁盘配额,那么数据库自然会受到服务器运行的用户的任何配额的限制。超出配额与磁盘空间完全用完一样,会产生同样的不良后果。</target>
        </trans-unit>
        <trans-unit id="e7e317a782d39f676e51dc31fbaf9497cd40b79f" translate="yes" xml:space="preserve">
          <source>If your table is large enough that a single index really is a bad idea, you should look into using partitioning instead (see &lt;a href=&quot;ddl-partitioning&quot;&gt;Section 5.11&lt;/a&gt;). With that mechanism, the system does understand that the tables and indexes are non-overlapping, so far better performance is possible.</source>
          <target state="translated">如果您的表足够大，以至于单个索引确实不是一个好主意，则应该考虑使用分区（请参阅&lt;a href=&quot;ddl-partitioning&quot;&gt;第5.11节&lt;/a&gt;）。通过这种机制，系统确实知道表和索引是不重叠的，因此可能会有更好的性能。</target>
        </trans-unit>
        <trans-unit id="db517070c58b7073cbfea804db0649d1169a5342" translate="yes" xml:space="preserve">
          <source>If, after running &lt;code&gt;pg_upgrade&lt;/code&gt;, you wish to revert to the old cluster, there are several options:</source>
          <target state="translated">在运行 &lt;code&gt;pg_upgrade&lt;/code&gt; 之后，如果您希望恢复到旧集群，则有以下几种选择：</target>
        </trans-unit>
        <trans-unit id="1101febd9e8e65c65ae1f196aecd9bf8175188c4" translate="yes" xml:space="preserve">
          <source>If, partway through the transaction, we decide we do not want to commit (perhaps we just noticed that Alice's balance went negative), we can issue the command &lt;code&gt;ROLLBACK&lt;/code&gt; instead of &lt;code&gt;COMMIT&lt;/code&gt;, and all our updates so far will be canceled.</source>
          <target state="translated">如果在交易过程中，我们决定不想提交（也许我们刚刚注意到Alice的余额为负），则可以发出命令 &lt;code&gt;ROLLBACK&lt;/code&gt; 而不是 &lt;code&gt;COMMIT&lt;/code&gt; ，并且到目前为止，我们所有的更新都将被取消。</target>
        </trans-unit>
        <trans-unit id="f5024d286e4914e76d806049ed9ed5a9adde6b60" translate="yes" xml:space="preserve">
          <source>Ignore system indexes when reading system tables (but still update the indexes when modifying the tables). This is useful when recovering from damaged system indexes. This parameter cannot be changed after session start.</source>
          <target state="translated">读取系统表时忽略系统索引(但修改表时仍会更新索引)。这在从损坏的系统索引中恢复时很有用。此参数在会话启动后不能更改。</target>
        </trans-unit>
        <trans-unit id="71db18d1300170d2010c351c48755c19862c8762" translate="yes" xml:space="preserve">
          <source>Ignore system indexes when reading system tables, but still update the indexes when modifying the tables. This is useful when recovering from damaged system indexes.</source>
          <target state="translated">读取系统表时忽略系统索引,但修改表时仍会更新索引。这在从损坏的系统索引中恢复时很有用。</target>
        </trans-unit>
        <trans-unit id="e6a48d212210667b487bb3381daba46c6747f8cd" translate="yes" xml:space="preserve">
          <source>Ignore the specified file or directory, which should be expressed as a relative path name, when comparing the list of data files actually present in the backup to those listed in the &lt;code&gt;backup_manifest&lt;/code&gt; file. If a directory is specified, this option affects the entire subtree rooted at that location. Complaints about extra files, missing files, file size differences, or checksum mismatches will be suppressed if the relative path name matches the specified path name. This option can be specified multiple times.</source>
          <target state="translated">在将备份中实际存在的数据文件列表与 &lt;code&gt;backup_manifest&lt;/code&gt; 文件中列出的数据文件列表进行比较时，忽略指定的文件或目录，应将其表示为相对路径名。如果指定了目录，则此选项会影响植根于该位置的整个子树。如果相对路径名与指定的路径名​​匹配，则将避免有关多余文件，文件丢失，文件大小差异或校验和不匹配的投诉。可以多次指定此选项。</target>
        </trans-unit>
        <trans-unit id="78fee1435d74666b84850cd5e82c18229351da5d" translate="yes" xml:space="preserve">
          <source>Ignored</source>
          <target state="translated">Ignored</target>
        </trans-unit>
        <trans-unit id="0bbd8cc216c54e73f7ea687a30b566c0b2c97cbb" translate="yes" xml:space="preserve">
          <source>Ignored for compatibility. Use of these keywords is deprecated; refer to &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for details.</source>
          <target state="translated">忽略兼容性。不建议使用这些关键字；有关详细信息，请参考&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b3a3e33cda0750b99611590eb50e57574fe1fbbc" translate="yes" xml:space="preserve">
          <source>Ignored for conformance with the SQL standard.</source>
          <target state="translated">为了符合SQL标准,忽略了。</target>
        </trans-unit>
        <trans-unit id="007d15b16f1f1a7b26e745777a0d9b8f646f2090" translate="yes" xml:space="preserve">
          <source>Illustrations of how these different formats look can be seen in &lt;a href=&quot;app-psql#APP-PSQL-EXAMPLES&quot;&gt;Examples&lt;/a&gt;, below.</source>
          <target state="translated">这些不同格式的外观说明可在下面的&lt;a href=&quot;app-psql#APP-PSQL-EXAMPLES&quot;&gt;示例中&lt;/a&gt;看到。</target>
        </trans-unit>
        <trans-unit id="61522d42e0f29a20214f69c85ea7d7e480669670" translate="yes" xml:space="preserve">
          <source>Illustrations of how these different formats look can be seen in the &lt;a href=&quot;app-psql#APP-PSQL-EXAMPLES&quot;&gt;Examples&lt;/a&gt; section.</source>
          <target state="translated">在&lt;a href=&quot;app-psql#APP-PSQL-EXAMPLES&quot;&gt;示例&lt;/a&gt;部分中可以看到这些不同格式的外观说明。</target>
        </trans-unit>
        <trans-unit id="ce170f0162eadf29cca12cc3cb0e2275dc4e6504" translate="yes" xml:space="preserve">
          <source>Image equality is &lt;em&gt;almost&lt;/em&gt; the same condition as simple bitwise equality. There is one subtle difference: When indexing a varlena data type, the on-disk representation of two image equal datums may not be bitwise equal due to inconsistent application of TOAST compression on input. Formally, when an operator class's &lt;code&gt;equalimage&lt;/code&gt; function returns &lt;code&gt;true&lt;/code&gt;, it is safe to assume that the &lt;code&gt;datum_image_eq()&lt;/code&gt; C function will always agree with the operator class's &lt;code&gt;order&lt;/code&gt; function (provided that the same collation OID is passed to both the &lt;code&gt;equalimage&lt;/code&gt; and &lt;code&gt;order&lt;/code&gt; functions).</source>
          <target state="translated">图像相等与简单的按位相等&lt;em&gt;几乎&lt;/em&gt;是相同的条件。有一个细微的差别：在为varlena数据类型建立索引时，由于在输入上使用TOAST压缩不一致，所以两个图像相等的数据在磁盘上的表示可能不按位相等。形式上，当运算符类的 &lt;code&gt;equalimage&lt;/code&gt; 函数返回 &lt;code&gt;true&lt;/code&gt; 时，可以安全地假定 &lt;code&gt;datum_image_eq()&lt;/code&gt; C函数将始终与运算符类的 &lt;code&gt;order&lt;/code&gt; 函数一致（假设将相同的整理OID传递给 &lt;code&gt;equalimage&lt;/code&gt; 和 &lt;code&gt;order&lt;/code&gt; 函数）。</target>
        </trans-unit>
        <trans-unit id="bf50e138c7fa8f736f41cea1cb795eaf265d80f2" translate="yes" xml:space="preserve">
          <source>Immediately after connecting as role &lt;code&gt;joe&lt;/code&gt;, a database session will have use of privileges granted directly to &lt;code&gt;joe&lt;/code&gt; plus any privileges granted to &lt;code&gt;admin&lt;/code&gt;, because &lt;code&gt;joe&lt;/code&gt;&amp;ldquo;inherits&amp;rdquo;&lt;code&gt;admin&lt;/code&gt;'s privileges. However, privileges granted to &lt;code&gt;wheel&lt;/code&gt; are not available, because even though &lt;code&gt;joe&lt;/code&gt; is indirectly a member of &lt;code&gt;wheel&lt;/code&gt;, the membership is via &lt;code&gt;admin&lt;/code&gt; which has the &lt;code&gt;NOINHERIT&lt;/code&gt; attribute. After:</source>
          <target state="translated">以角色 &lt;code&gt;joe&lt;/code&gt; 身份连接后，数据库会话将立即使用直接授予 &lt;code&gt;joe&lt;/code&gt; 的特权以及授予 &lt;code&gt;admin&lt;/code&gt; 的任何特权，因为 &lt;code&gt;joe&lt;/code&gt; &amp;ldquo;继承&amp;rdquo;了 &lt;code&gt;admin&lt;/code&gt; 的特权。但是，授予给 &lt;code&gt;wheel&lt;/code&gt; 的特权不可用，因为即使 &lt;code&gt;joe&lt;/code&gt; 间接是 &lt;code&gt;wheel&lt;/code&gt; 的成员，该成员身份还是通过具有 &lt;code&gt;NOINHERIT&lt;/code&gt; 属性的 &lt;code&gt;admin&lt;/code&gt; 进行的。后：</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="23167d1539b634954643857fda589f9a1f99fc34" translate="yes" xml:space="preserve">
          <source>Implementation language or call interface of this function</source>
          <target state="translated">本函数的实现语言或调用接口</target>
        </trans-unit>
        <trans-unit id="41f7b8a75bd6e29a246db5c9ce4b0884fc5122fa" translate="yes" xml:space="preserve">
          <source>Implementation: B-Tree Structure</source>
          <target state="translated">实施。B-树结构</target>
        </trans-unit>
        <trans-unit id="4bd8f1da2c7641aff5a1e24cb79dcae5ba805a8b" translate="yes" xml:space="preserve">
          <source>Implementation: Deduplication</source>
          <target state="translated">实施。重复数据删除</target>
        </trans-unit>
        <trans-unit id="261a75d84276a41b101b0b0b2ac4d845072c8241" translate="yes" xml:space="preserve">
          <source>Implicit conversions should never have surprising or unpredictable outcomes.</source>
          <target state="translated">隐性转换永远不应该有出人意料或不可预知的结果。</target>
        </trans-unit>
        <trans-unit id="4a78c79f95926318ef6fec9862a700583e71fbd0" translate="yes" xml:space="preserve">
          <source>Implicit unit of the parameter</source>
          <target state="translated">参数的隐含单位</target>
        </trans-unit>
        <trans-unit id="60fa0aba1042461c4c2f1fe75e803d3f36549dc2" translate="yes" xml:space="preserve">
          <source>Import only foreign tables matching one of the given table names. Other tables existing in the foreign schema will be ignored.</source>
          <target state="translated">只导入与给定表名之一相匹配的外来表。外来模式中存在的其他表将被忽略。</target>
        </trans-unit>
        <trans-unit id="2775c7ad42c3e8d71ae7e18124278fff473728e1" translate="yes" xml:space="preserve">
          <source>Import operating system collations</source>
          <target state="translated">导入操作系统整理</target>
        </trans-unit>
        <trans-unit id="bd09d7d5cbde0f6a55b8befe57d5d6baee4d6f2b" translate="yes" xml:space="preserve">
          <source>Import table definitions from a remote schema &lt;code&gt;foreign_films&lt;/code&gt; on server &lt;code&gt;film_server&lt;/code&gt;, creating the foreign tables in local schema &lt;code&gt;films&lt;/code&gt;:</source>
          <target state="translated">从服务器 &lt;code&gt;film_server&lt;/code&gt; 上的远程模式 &lt;code&gt;foreign_films&lt;/code&gt; 导入表定义，在本地模式 &lt;code&gt;films&lt;/code&gt; 创建外部表：</target>
        </trans-unit>
        <trans-unit id="4b6d6a30150a506f9b79caf45da5aecb76b0018e" translate="yes" xml:space="preserve">
          <source>Important</source>
          <target state="translated">Important</target>
        </trans-unit>
        <trans-unit id="40baa6b48d8c1dc060a4acaef47611a694c99ef3" translate="yes" xml:space="preserve">
          <source>Importing behavior can be customized with the following options (given in the &lt;code&gt;IMPORT FOREIGN SCHEMA&lt;/code&gt; command):</source>
          <target state="translated">可以使用以下选项来自定义导入行为（在 &lt;code&gt;IMPORT FOREIGN SCHEMA&lt;/code&gt; 命令中提供）：</target>
        </trans-unit>
        <trans-unit id="6cdac824d2a40a7779c6dcbb8d843dee4847ebb5" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;seg#SEG-REPR-TABLE&quot;&gt;Table F.26&lt;/a&gt;, &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;delta&lt;/code&gt; denote floating-point numbers. &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, but not &lt;code&gt;delta&lt;/code&gt;, can be preceded by a certainty indicator.</source>
          <target state="translated">在&lt;a href=&quot;seg#SEG-REPR-TABLE&quot;&gt;表F.26中&lt;/a&gt;， &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;y&lt;/code&gt; 和 &lt;code&gt;delta&lt;/code&gt; 表示浮点数。 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; （但不是 &lt;code&gt;delta&lt;/code&gt; )之前可以带有确定性指示符。</target>
        </trans-unit>
        <trans-unit id="42729a410f5a9327e00095fef5d98f4dbb7419a2" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;sql-keywords-appendix#KEYWORDS-TABLE&quot;&gt;Table C.1&lt;/a&gt; in the column for PostgreSQL we classify as &amp;ldquo;non-reserved&amp;rdquo; those key words that are explicitly known to the parser but are allowed as column or table names. Some key words that are otherwise non-reserved cannot be used as function or data type names and are marked accordingly. (Most of these words represent built-in functions or data types with special syntax. The function or type is still available but it cannot be redefined by the user.) Labeled &amp;ldquo;reserved&amp;rdquo; are those tokens that are not allowed as column or table names. Some reserved key words are allowable as names for functions or data types; this is also shown in the table. If not so marked, a reserved key word is only allowed as an &amp;ldquo;AS&amp;rdquo; column label name.</source>
          <target state="translated">在PostgreSQL列的&lt;a href=&quot;sql-keywords-appendix#KEYWORDS-TABLE&quot;&gt;表C.1&lt;/a&gt;中，我们将解析器明确知道但允许作为列名或表名的那些关键字分类为&amp;ldquo;非保留&amp;rdquo;。某些原本不可保留的关键字不能用作功能或数据类型名称，并进行了相应标记。 （这些词中的大多数代表具有特殊语法的内置函数或数据类型。该函数或类型仍然可用，但用户无法重新定义。）标记为&amp;ldquo;保留&amp;rdquo;的是那些不允许用作列或表名的标记。某些保留的关键字可以用作函数或数据类型的名称。这也显示在表格中。如果没有这样标记，则保留的关键字只能用作&amp;ldquo; AS&amp;rdquo;列标签名称。</target>
        </trans-unit>
        <trans-unit id="5fee127e33ba4c6342d0b89b7e063498409c73cb" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--start&lt;/code&gt; mode, automatically stop replication and exit with normal exit status 0 when receiving reaches the specified LSN. If specified when not in &lt;code&gt;--start&lt;/code&gt; mode, an error is raised.</source>
          <target state="translated">在 &lt;code&gt;--start&lt;/code&gt; 模式下，当接收到达指定的LSN时，将自动停止复制并以正常退出状态0退出。如果未在 &lt;code&gt;--start&lt;/code&gt; 模式下指定，则将引发错误。</target>
        </trans-unit>
        <trans-unit id="3bfcd6bf2f68dc3b43c9cf872d41f5d653495d00" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--start&lt;/code&gt; mode, start replication from the given LSN. For details on the effect of this, see the documentation in &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt;. Ignored in other modes.</source>
          <target state="translated">在 &lt;code&gt;--start&lt;/code&gt; 模式下，从给定的LSN开始复制。有关这样的效果的详细信息，请参阅文件&lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;第48&lt;/a&gt;和&lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;第52.4&lt;/a&gt;。在其他模式下被忽略。</target>
        </trans-unit>
        <trans-unit id="0f9c2a488b212b2dfc605f566bbd946f2f95b3b7" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--start&lt;/code&gt; mode, start replication from the given LSN. For details on the effect of this, see the documentation in &lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt;. Ignored in other modes.</source>
          <target state="translated">在 &lt;code&gt;--start&lt;/code&gt; 模式下，从给定的LSN开始复制。有关这样的效果的详细信息，请参阅文件&lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding.html&quot;&gt;第48&lt;/a&gt;和&lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-replication.html&quot;&gt;第52.4&lt;/a&gt;。在其他模式下被忽略。</target>
        </trans-unit>
        <trans-unit id="12bbea7ca03f59c395276fdbf0ca262376507500" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--start&lt;/code&gt; mode, use the existing logical replication slot named &lt;code&gt;slot_name&lt;/code&gt;. In &lt;code&gt;--create-slot&lt;/code&gt; mode, create the slot with this name. In &lt;code&gt;--drop-slot&lt;/code&gt; mode, delete the slot with this name.</source>
          <target state="translated">在 &lt;code&gt;--start&lt;/code&gt; 模式下，使用名为 &lt;code&gt;slot_name&lt;/code&gt; 的现有逻辑复制插槽。在 &lt;code&gt;--create-slot&lt;/code&gt; 模式下，使用此名称创建插槽。在 &lt;code&gt;--drop-slot&lt;/code&gt; 模式下，删除具有该名称的插槽。</target>
        </trans-unit>
        <trans-unit id="18d7da29e783f36fa5dffa6644b2287183a78875" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;CSV&lt;/code&gt; format, all characters are significant. A quoted value surrounded by white space, or any characters other than &lt;code&gt;DELIMITER&lt;/code&gt;, will include those characters. This can cause errors if you import data from a system that pads &lt;code&gt;CSV&lt;/code&gt; lines with white space out to some fixed width. If such a situation arises you might need to preprocess the &lt;code&gt;CSV&lt;/code&gt; file to remove the trailing white space, before importing the data into PostgreSQL.</source>
          <target state="translated">在 &lt;code&gt;CSV&lt;/code&gt; 格式中，所有字符均有效。用引号引起来的值用空格或除 &lt;code&gt;DELIMITER&lt;/code&gt; 以外的任何字符包围，将包括这些字符。如果从从空白行填充到固定宽度的 &lt;code&gt;CSV&lt;/code&gt; 行的系统中导入数据，则可能会导致错误。如果出现这种情况，在将数据导入PostgreSQL之前，可能需要预处理 &lt;code&gt;CSV&lt;/code&gt; 文件以除去尾随空白。</target>
        </trans-unit>
        <trans-unit id="0153f75e36e8f0039d3aa08af5bcc40422e9783b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;FROM&lt;/code&gt; items, both the standard and PostgreSQL allow &lt;code&gt;AS&lt;/code&gt; to be omitted before an alias that is an unreserved keyword. But this is impractical for output column names, because of syntactic ambiguities.</source>
          <target state="translated">在 &lt;code&gt;FROM&lt;/code&gt; 项中，标准和PostgreSQL都允许在作为未保留关键字的别名之前省略 &lt;code&gt;AS&lt;/code&gt; 。但是由于语法上的歧义，这对于输出列名称是不切实际的。</target>
        </trans-unit>
        <trans-unit id="0a49988bfaefe7a720bbc33d73d20e3ed846b39f" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;GROUPS&lt;/code&gt; mode, the &lt;code&gt;offset&lt;/code&gt; again must yield a non-null, non-negative integer, and the option means that the frame starts or ends the specified number of &lt;em&gt;peer groups&lt;/em&gt; before or after the current row's peer group, where a peer group is a set of rows that are equivalent in the &lt;code&gt;ORDER BY&lt;/code&gt; ordering. (There must be an &lt;code&gt;ORDER BY&lt;/code&gt; clause in the window definition to use &lt;code&gt;GROUPS&lt;/code&gt; mode.)</source>
          <target state="translated">在 &lt;code&gt;GROUPS&lt;/code&gt; 模式下， &lt;code&gt;offset&lt;/code&gt; 必须再次产生一个非空，非负整数，并且该选项表示该帧在当前行的对&lt;em&gt;等组&lt;/em&gt;之前或之后开始或结束指定数目的&lt;em&gt;对&lt;/em&gt;等组，其中对等组是一个在 &lt;code&gt;ORDER BY&lt;/code&gt; 顺序中等效的一组行。 （要使用 &lt;code&gt;GROUPS&lt;/code&gt; 模式，窗口定义中必须有一个 &lt;code&gt;ORDER BY&lt;/code&gt; 子句。）</target>
        </trans-unit>
        <trans-unit id="948c542b2b357818bb888566376ebb0a4005a123" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;RANGE&lt;/code&gt; mode, these options require that the &lt;code&gt;ORDER BY&lt;/code&gt; clause specify exactly one column. The &lt;code&gt;offset&lt;/code&gt; specifies the maximum difference between the value of that column in the current row and its value in preceding or following rows of the frame. The data type of the &lt;code&gt;offset&lt;/code&gt; expression varies depending on the data type of the ordering column. For numeric ordering columns it is typically of the same type as the ordering column, but for datetime ordering columns it is an &lt;code&gt;interval&lt;/code&gt;. For example, if the ordering column is of type &lt;code&gt;date&lt;/code&gt; or &lt;code&gt;timestamp&lt;/code&gt;, one could write &lt;code&gt;RANGE BETWEEN '1 day' PRECEDING AND '10 days' FOLLOWING&lt;/code&gt;. The &lt;code&gt;offset&lt;/code&gt; is still required to be non-null and non-negative, though the meaning of &amp;ldquo;non-negative&amp;rdquo; depends on its data type.</source>
          <target state="translated">在 &lt;code&gt;RANGE&lt;/code&gt; 模式下，这些选项要求 &lt;code&gt;ORDER BY&lt;/code&gt; 子句仅指定一列。的 &lt;code&gt;offset&lt;/code&gt; 指定该列的当前行中的值，并在其之前或之后的帧的行值之间的最大差值。所述的数据类型 &lt;code&gt;offset&lt;/code&gt; 表达取决于排序列的数据类型而变化。对于数字排序列，它通常与排序列的类型相同，但是对于日期时间排序列，它是一个 &lt;code&gt;interval&lt;/code&gt; 。例如，如果订购列的类型为 &lt;code&gt;date&lt;/code&gt; 或 &lt;code&gt;timestamp&lt;/code&gt; ，则可以在 &lt;code&gt;RANGE BETWEEN '1 day' PRECEDING AND '10 days' FOLLOWING&lt;/code&gt; 写入RANGE。的 &lt;code&gt;offset&lt;/code&gt; 尽管&amp;ldquo;非负数&amp;rdquo;的含义取决于其数据类型，但仍要求offset为非null和非负数。</target>
        </trans-unit>
        <trans-unit id="1408d5e7e21bd209b1b9bfad149903cd4485729a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;RANGE&lt;/code&gt; or &lt;code&gt;GROUPS&lt;/code&gt; mode, a &lt;code&gt;frame_start&lt;/code&gt; of &lt;code&gt;CURRENT ROW&lt;/code&gt; means the frame starts with the current row's first &lt;em&gt;peer&lt;/em&gt; row (a row that the window's &lt;code&gt;ORDER BY&lt;/code&gt; clause sorts as equivalent to the current row), while a &lt;code&gt;frame_end&lt;/code&gt; of &lt;code&gt;CURRENT ROW&lt;/code&gt; means the frame ends with the current row's last peer row. In &lt;code&gt;ROWS&lt;/code&gt; mode, &lt;code&gt;CURRENT ROW&lt;/code&gt; simply means the current row.</source>
          <target state="translated">在 &lt;code&gt;RANGE&lt;/code&gt; 或 &lt;code&gt;GROUPS&lt;/code&gt; 模式， &lt;code&gt;frame_start&lt;/code&gt; 的 &lt;code&gt;CURRENT ROW&lt;/code&gt; 意味着当前行的第一帧开始&lt;em&gt;对等&lt;/em&gt;行（行的是，窗口的 &lt;code&gt;ORDER BY&lt;/code&gt; 子句种类等同于当前行），而 &lt;code&gt;frame_end&lt;/code&gt; 的 &lt;code&gt;CURRENT ROW&lt;/code&gt; 意味着帧末端与当前行的最后一个对等行。在 &lt;code&gt;ROWS&lt;/code&gt; 模式下， &lt;code&gt;CURRENT ROW&lt;/code&gt; 仅表示当前行。</target>
        </trans-unit>
        <trans-unit id="30675f2bd0c7573e3e074baf89463cecdcac064e" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ROWS&lt;/code&gt; mode, the &lt;code&gt;offset&lt;/code&gt; must yield a non-null, non-negative integer, and the option means that the frame starts or ends the specified number of rows before or after the current row.</source>
          <target state="translated">在 &lt;code&gt;ROWS&lt;/code&gt; 模式下， &lt;code&gt;offset&lt;/code&gt; 必须产生一个非空，非负整数，并且该选项表示该帧在当前行之前或之后的指定行数开始或结束。</target>
        </trans-unit>
        <trans-unit id="8f056c7130dbabcd038c08071d28f6253ddeb0d1" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;array_position&lt;/code&gt; and &lt;code&gt;array_positions&lt;/code&gt;, each array element is compared to the searched value using &lt;code&gt;IS NOT DISTINCT FROM&lt;/code&gt; semantics.</source>
          <target state="translated">在 &lt;code&gt;array_position&lt;/code&gt; 和 &lt;code&gt;array_positions&lt;/code&gt; 中，使用 &lt;code&gt;IS NOT DISTINCT FROM&lt;/code&gt; 语义将每个数组元素与搜索到的值进行比较。</target>
        </trans-unit>
        <trans-unit id="58eb966bf75cf56a14e39b6e0b483088ba13994e" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;array_position&lt;/code&gt;, &lt;code&gt;NULL&lt;/code&gt; is returned if the value is not found.</source>
          <target state="translated">在 &lt;code&gt;array_position&lt;/code&gt; 中，如果找不到该值，则返回 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6fb1576a237f50776165c9127d1d61a80997b7ea" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;array_positions&lt;/code&gt;, &lt;code&gt;NULL&lt;/code&gt; is returned only if the array is &lt;code&gt;NULL&lt;/code&gt;; if the value is not found in the array, an empty array is returned instead.</source>
          <target state="translated">在 &lt;code&gt;array_positions&lt;/code&gt; ， &lt;code&gt;NULL&lt;/code&gt; 返回只有当阵列是 &lt;code&gt;NULL&lt;/code&gt; ; 如果在数组中找不到该值，则返回一个空数组。</target>
        </trans-unit>
        <trans-unit id="42867f00aff6799a35548d7b4a45bb429b8b6f41" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;encrypt_iv&lt;/code&gt; and &lt;code&gt;decrypt_iv&lt;/code&gt;, the &lt;em&gt;&lt;code&gt;iv&lt;/code&gt;&lt;/em&gt; parameter is the initial value for the CBC mode; it is ignored for ECB. It is clipped or padded with zeroes if not exactly block size. It defaults to all zeroes in the functions without this parameter.</source>
          <target state="translated">在 &lt;code&gt;encrypt_iv&lt;/code&gt; 和 &lt;code&gt;decrypt_iv&lt;/code&gt; 中，&lt;em&gt; &lt;code&gt;iv&lt;/code&gt; &lt;/em&gt;参数是CBC模式的初始值。ECB将忽略它。如果块大小不完全，则将其剪切或填充零。不带该参数的函数默认为全零。</target>
        </trans-unit>
        <trans-unit id="74b9c4f74b2383573102ae88dc002c3f78bfc6aa" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;init&lt;/code&gt; mode, this option analogously specifies the location of the &lt;code&gt;initdb&lt;/code&gt; executable.</source>
          <target state="translated">在 &lt;code&gt;init&lt;/code&gt; 模式下，此选项类似地指定 &lt;code&gt;initdb&lt;/code&gt; 可执行文件的位置。</target>
        </trans-unit>
        <trans-unit id="4b893445cf37926dce5c6e98df69fc0726a60722" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;latex-longtable&lt;/code&gt; format, this controls the proportional width of each column containing a left-aligned data type. It is specified as a whitespace-separated list of values, e.g. &lt;code&gt;'0.2 0.2 0.6'&lt;/code&gt;. Unspecified output columns use the last specified value.</source>
          <target state="translated">在 &lt;code&gt;latex-longtable&lt;/code&gt; 格式，这个控制含有一个左对齐数据类型中每列的宽度成比例。它被指定为用空格分隔的值列表，例如 &lt;code&gt;'0.2 0.2 0.6'&lt;/code&gt; 。未指定的输出列使用最后指定的值。</target>
        </trans-unit>
        <trans-unit id="cf4911342f242c7e8a426e1e90cc4a102540577f" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;latex-longtable&lt;/code&gt; format, this controls the proportional width of each column containing a left-aligned data type. It is specified as a whitespace-separated list of values, e.g., &lt;code&gt;'0.2 0.2 0.6'&lt;/code&gt;. Unspecified output columns use the last specified value.</source>
          <target state="translated">在 &lt;code&gt;latex-longtable&lt;/code&gt; 格式，这个控制含有一个左对齐数据类型中每列的宽度成比例。它被指定为以空格分隔的值列表，例如 &lt;code&gt;'0.2 0.2 0.6'&lt;/code&gt; 。未指定的输出列使用最后指定的值。</target>
        </trans-unit>
        <trans-unit id="9860fa02b7dab9c5038f80534079df8148445840" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;logical&lt;/code&gt; level, the same information is logged as with &lt;code&gt;replica&lt;/code&gt;, plus information needed to allow extracting logical change sets from the WAL. Using a level of &lt;code&gt;logical&lt;/code&gt; will increase the WAL volume, particularly if many tables are configured for &lt;code&gt;REPLICA IDENTITY FULL&lt;/code&gt; and many &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; statements are executed.</source>
          <target state="translated">在 &lt;code&gt;logical&lt;/code&gt; 级别，将记录与 &lt;code&gt;replica&lt;/code&gt; 相同的信息，以及允许从WAL中提取逻辑变更集所需的信息。使用 &lt;code&gt;logical&lt;/code&gt; 级别将增加WAL量，特别是如果为 &lt;code&gt;REPLICA IDENTITY FULL&lt;/code&gt; 配置了许多表并且执行了许多 &lt;code&gt;UPDATE&lt;/code&gt; 和 &lt;code&gt;DELETE&lt;/code&gt; 语句时，尤其如此。</target>
        </trans-unit>
        <trans-unit id="19415b9e6aa0d531e04e643500bbdc24d23674cf" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;minimal&lt;/code&gt; level, WAL-logging of some bulk operations can be safely skipped, which can make those operations much faster (see &lt;a href=&quot;populate#POPULATE-PITR&quot;&gt;Section 14.4.7&lt;/a&gt;). Operations in which this optimization can be applied include:</source>
          <target state="translated">在 &lt;code&gt;minimal&lt;/code&gt; 级别上，可以安全地跳过一些批量操作的WAL日志记录，这可以使这些操作更快（请参见&lt;a href=&quot;populate#POPULATE-PITR&quot;&gt;14.4.7节&lt;/a&gt;）。可以应用此优化的操作包括：</target>
        </trans-unit>
        <trans-unit id="4b6bdb288d87683bcb61f09bf26e72e3f74194ad" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;minimal&lt;/code&gt; level, no information is logged for permanent relations for the remainder of a transaction that creates or rewrites them. This can make operations much faster (see &lt;a href=&quot;populate#POPULATE-PITR&quot;&gt;Section 14.4.7&lt;/a&gt;). Operations that initiate this optimization include:</source>
          <target state="translated">在 &lt;code&gt;minimal&lt;/code&gt; 上，在创建或重写它们的事务的其余部分中，不会记录永久关系的信息。这可以使操作更快（请参见&lt;a href=&quot;populate#POPULATE-PITR&quot;&gt;14.4.7节&lt;/a&gt;）。启动此优化的操作包括：</target>
        </trans-unit>
        <trans-unit id="61bcfc364ae05487e8e54b4d5f3e06b75ec150ff" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;psql&lt;/code&gt;, you will be greeted with the following message:</source>
          <target state="translated">在 &lt;code&gt;psql&lt;/code&gt; 中，将收到以下消息：</target>
        </trans-unit>
        <trans-unit id="d81bf71ad3ee9adb26530d123722b695887e96a2" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;string_to_array&lt;/code&gt;, if the delimiter parameter is NULL, each character in the input string will become a separate element in the resulting array. If the delimiter is an empty string, then the entire input string is returned as a one-element array. Otherwise the input string is split at each occurrence of the delimiter string.</source>
          <target state="translated">在 &lt;code&gt;string_to_array&lt;/code&gt; 中，如果delimiter参数为NULL，则输入字符串中的每个字符将成为结果数组中的单独元素。如果定界符为空字符串，则整个输入字符串将作为一个单元素数组返回。否则，在每次出现分隔符字符串时都会对输入字符串进行拆分。</target>
        </trans-unit>
        <trans-unit id="ecd995c62df4a3324cc5c0dfdf5609bb28cc962a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;string_to_array&lt;/code&gt;, if the null-string parameter is omitted or NULL, none of the substrings of the input will be replaced by NULL. In &lt;code&gt;array_to_string&lt;/code&gt;, if the null-string parameter is omitted or NULL, any null elements in the array are simply skipped and not represented in the output string.</source>
          <target state="translated">在 &lt;code&gt;string_to_array&lt;/code&gt; 中，如果省略null字符串参数或NULL，则输入的任何子字符串都不会被NULL取代。在 &lt;code&gt;array_to_string&lt;/code&gt; 中，如果将null-string参数省略或设置为NULL，则仅跳过数组中的任何null元素，而不在输出字符串中表示该元素。</target>
        </trans-unit>
        <trans-unit id="b1222507b269ef568691d0a9d753a3eda5a5d8e5" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_number&lt;/code&gt;, if non-data template patterns such as &lt;code&gt;L&lt;/code&gt; or &lt;code&gt;TH&lt;/code&gt; are used, the corresponding number of input characters are skipped, whether or not they match the template pattern, unless they are data characters (that is, digits, sign, decimal point, or comma). For example, &lt;code&gt;TH&lt;/code&gt; would skip two non-data characters.</source>
          <target state="translated">在 &lt;code&gt;to_number&lt;/code&gt; 中，如果使用非数据模板模式（例如 &lt;code&gt;L&lt;/code&gt; 或 &lt;code&gt;TH&lt;/code&gt; )，则无论它们是否与模板模式匹配，都会跳过相应数量的输入字符，除非它们是数据字符（即数字，符号，小数点） ，或逗号）。例如， &lt;code&gt;TH&lt;/code&gt; 将跳过两个非数据字符。</target>
        </trans-unit>
        <trans-unit id="da01a26180a4b78ca506a4e26d673346bc64efee" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt;, an ISO 8601 week-numbering date (as distinct from a Gregorian date) can be specified in one of two ways:</source>
          <target state="translated">在 &lt;code&gt;to_timestamp&lt;/code&gt; 和 &lt;code&gt;to_date&lt;/code&gt; 中，可以通过以下两种方式之一指定ISO 8601周编号日期（与公历日期不同）：</target>
        </trans-unit>
        <trans-unit id="f9d931e068d7388b5b9791ba73a39ccc4330b961" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt;, if the year format specification is less than four digits, e.g. &lt;code&gt;YYY&lt;/code&gt;, and the supplied year is less than four digits, the year will be adjusted to be nearest to the year 2020, e.g. &lt;code&gt;95&lt;/code&gt; becomes 1995.</source>
          <target state="translated">在 &lt;code&gt;to_timestamp&lt;/code&gt; 和 &lt;code&gt;to_date&lt;/code&gt; 中，如果年份格式规范小于四位数，例如 &lt;code&gt;YYY&lt;/code&gt; ，并且提供的年份小于四位数，则将调整年份为最接近2020年，例如 &lt;code&gt;95&lt;/code&gt; 变为1995。</target>
        </trans-unit>
        <trans-unit id="d8f4914c4ba597d9e2b92d0c671f4d7641758160" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt;, if the year format specification is less than four digits, e.g., &lt;code&gt;YYY&lt;/code&gt;, and the supplied year is less than four digits, the year will be adjusted to be nearest to the year 2020, e.g., &lt;code&gt;95&lt;/code&gt; becomes 1995.</source>
          <target state="translated">在 &lt;code&gt;to_timestamp&lt;/code&gt; 和 &lt;code&gt;to_date&lt;/code&gt; 中，如果年份格式规范小于四位数，例如 &lt;code&gt;YYY&lt;/code&gt; ，并且提供的年份小于四位数，则将调整年份为最接近2020年，例如 &lt;code&gt;95&lt;/code&gt; 变为1995。</target>
        </trans-unit>
        <trans-unit id="551a2fa16ad6836b39b0369ec3903da168ff58bb" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt;, negative years are treated as signifying BC. If you write both a negative year and an explicit &lt;code&gt;BC&lt;/code&gt; field, you get AD again. An input of year zero is treated as 1 BC.</source>
          <target state="translated">在 &lt;code&gt;to_timestamp&lt;/code&gt; 和 &lt;code&gt;to_date&lt;/code&gt; 中，负年被视为表示BC。如果您同时输入负年份和显式的 &lt;code&gt;BC&lt;/code&gt; 字段，则会再次得到AD。零年的输入被视为1 BC。</target>
        </trans-unit>
        <trans-unit id="4dcc47dcfb30c72df039620b4818cb5cae63885b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt;, the &lt;code&gt;CC&lt;/code&gt; (century) field is accepted but ignored if there is a &lt;code&gt;YYY&lt;/code&gt;, &lt;code&gt;YYYY&lt;/code&gt; or &lt;code&gt;Y,YYY&lt;/code&gt; field. If &lt;code&gt;CC&lt;/code&gt; is used with &lt;code&gt;YY&lt;/code&gt; or &lt;code&gt;Y&lt;/code&gt; then the result is computed as that year in the specified century. If the century is specified but the year is not, the first year of the century is assumed.</source>
          <target state="translated">在 &lt;code&gt;to_timestamp&lt;/code&gt; 和 &lt;code&gt;to_date&lt;/code&gt; 中，如果存在 &lt;code&gt;YYY&lt;/code&gt; ， &lt;code&gt;YYYY&lt;/code&gt; 或 &lt;code&gt;Y,YYY&lt;/code&gt; 字段，则接受 &lt;code&gt;CC&lt;/code&gt; （世纪）字段，但忽略该字段。如果 &lt;code&gt;CC&lt;/code&gt; 与 &lt;code&gt;YY&lt;/code&gt; 或 &lt;code&gt;Y&lt;/code&gt; 一起使用，则结果将计算为指定世纪中的那一年。如果指定了世纪但未指定年份，则假定为世纪的第一年。</target>
        </trans-unit>
        <trans-unit id="34928f49bb5512bad729a0eba587c351c3b66a70" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt;, the &lt;code&gt;YYYY&lt;/code&gt; conversion has a restriction when processing years with more than 4 digits. You must use some non-digit character or template after &lt;code&gt;YYYY&lt;/code&gt;, otherwise the year is always interpreted as 4 digits. For example (with the year 20000): &lt;code&gt;to_date('200001131', 'YYYYMMDD')&lt;/code&gt; will be interpreted as a 4-digit year; instead use a non-digit separator after the year, like &lt;code&gt;to_date('20000-1131', 'YYYY-MMDD')&lt;/code&gt; or &lt;code&gt;to_date('20000Nov31', 'YYYYMonDD')&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;to_timestamp&lt;/code&gt; 和 &lt;code&gt;to_date&lt;/code&gt; 中，当处理多于4位数字的年份时， &lt;code&gt;YYYY&lt;/code&gt; 转换受到限制。您必须在 &lt;code&gt;YYYY&lt;/code&gt; 之后使用一些非数字字符或模板，否则年份始终被解释为4位数字。例如（年份为20000）： &lt;code&gt;to_date('200001131', 'YYYYMMDD')&lt;/code&gt; 将被解释为4位数字的年份；而是在年后使用非数字分隔符，例如 &lt;code&gt;to_date('20000-1131', 'YYYY-MMDD')&lt;/code&gt; &lt;code&gt;to_date('20000Nov31', 'YYYYMonDD')&lt;/code&gt; '）或to_date（'20000Nov31'，'YYYYMonDD'）。</target>
        </trans-unit>
        <trans-unit id="544ec57993b0d566b29bfdeb2a8cf47932beafef" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt;, weekday names or numbers (&lt;code&gt;DAY&lt;/code&gt;, &lt;code&gt;D&lt;/code&gt;, and related field types) are accepted but are ignored for purposes of computing the result. The same is true for quarter (&lt;code&gt;Q&lt;/code&gt;) fields.</source>
          <target state="translated">在 &lt;code&gt;to_timestamp&lt;/code&gt; 和 &lt;code&gt;to_date&lt;/code&gt; 中，接受工作日名称或数字（ &lt;code&gt;DAY&lt;/code&gt; ， &lt;code&gt;D&lt;/code&gt; 和相关字段类型），但出于计算结果的目的而将其忽略。四分之一（ &lt;code&gt;Q&lt;/code&gt; ）字段也是如此。</target>
        </trans-unit>
        <trans-unit id="8902e096eb8211a3103ef8a03507a1e1c0b7839c" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt;, millisecond (&lt;code&gt;MS&lt;/code&gt;) or microsecond (&lt;code&gt;US&lt;/code&gt;) fields are used as the seconds digits after the decimal point. For example &lt;code&gt;to_timestamp('12.3', 'SS.MS')&lt;/code&gt; is not 3 milliseconds, but 300, because the conversion treats it as 12 + 0.3 seconds. So, for the format &lt;code&gt;SS.MS&lt;/code&gt;, the input values &lt;code&gt;12.3&lt;/code&gt;, &lt;code&gt;12.30&lt;/code&gt;, and &lt;code&gt;12.300&lt;/code&gt; specify the same number of milliseconds. To get three milliseconds, one must write &lt;code&gt;12.003&lt;/code&gt;, which the conversion treats as 12 + 0.003 = 12.003 seconds.</source>
          <target state="translated">在 &lt;code&gt;to_timestamp&lt;/code&gt; 中，毫秒（ &lt;code&gt;MS&lt;/code&gt; ）或微秒（ &lt;code&gt;US&lt;/code&gt; ）字段用作小数点后的秒数。例如 &lt;code&gt;to_timestamp('12.3', 'SS.MS')&lt;/code&gt; 不是3毫秒，而是300毫秒，因为转换将其视为12 + 0.3秒。因此，对于格式 &lt;code&gt;SS.MS&lt;/code&gt; ，输入值 &lt;code&gt;12.3&lt;/code&gt; ， &lt;code&gt;12.30&lt;/code&gt; 和 &lt;code&gt;12.300&lt;/code&gt; 指定相同的毫秒数。要获得三毫秒，必须写入 &lt;code&gt;12.003&lt;/code&gt; ，转换将其视为12 + 0.003 = 12.003秒。</target>
        </trans-unit>
        <trans-unit id="64a9c48229747c676385712712a92e7a02f4a20e" translate="yes" xml:space="preserve">
          <source>In AREs, &lt;code&gt;\&lt;/code&gt; followed by an alphanumeric character is either an escape or an error, while in previous releases, it was just another way of writing the alphanumeric. This should not be much of a problem because there was no reason to write such a sequence in earlier releases.</source>
          <target state="translated">在ARE中， &lt;code&gt;\&lt;/code&gt; 后跟字母数字字符是转义字符或错误，而在以前的版本中，这只是写字母数字的另一种方式。这应该没什么大问题，因为没有理由在早期版本中编写这样的序列。</target>
        </trans-unit>
        <trans-unit id="9fd039b2f7ce31cb27cef33f4f533a9fac0c1fbd" translate="yes" xml:space="preserve">
          <source>In AREs, &lt;code&gt;\&lt;/code&gt; remains a special character within &lt;code&gt;[]&lt;/code&gt;, so a literal &lt;code&gt;\&lt;/code&gt; within a bracket expression must be written &lt;code&gt;\\&lt;/code&gt;.</source>
          <target state="translated">在ARE中， &lt;code&gt;\&lt;/code&gt; 仍然是 &lt;code&gt;[]&lt;/code&gt; 中的特殊字符，因此必须将方括号表达式中的文字 &lt;code&gt;\&lt;/code&gt; 写为 &lt;code&gt;\\&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb3ffc95899379ce4e17b50af19efa046a482415" translate="yes" xml:space="preserve">
          <source>In HTML format, this specifies attributes to be placed inside the &lt;code&gt;table&lt;/code&gt; tag. This could for example be &lt;code&gt;cellpadding&lt;/code&gt; or &lt;code&gt;bgcolor&lt;/code&gt;. Note that you probably don't want to specify &lt;code&gt;border&lt;/code&gt; here, as that is already taken care of by &lt;code&gt;\pset border&lt;/code&gt;. If no &lt;code&gt;value&lt;/code&gt; is given, the table attributes are unset.</source>
          <target state="translated">在HTML格式中，这指定要放置在 &lt;code&gt;table&lt;/code&gt; 标记内的属性。例如，可以是 &lt;code&gt;cellpadding&lt;/code&gt; 或 &lt;code&gt;bgcolor&lt;/code&gt; 。请注意，您可能不想在此处指定 &lt;code&gt;border&lt;/code&gt; ，因为 &lt;code&gt;\pset border&lt;/code&gt; 已经解决了这一问题。如果没有给出 &lt;code&gt;value&lt;/code&gt; ，则表属性未设置。</target>
        </trans-unit>
        <trans-unit id="814a324a3771e36f5c269dff83adcdc2f6482fa5" translate="yes" xml:space="preserve">
          <source>In Linux 2.4 and later, the default virtual memory behavior is not optimal for PostgreSQL. Because of the way that the kernel implements memory overcommit, the kernel might terminate the PostgreSQL postmaster (the master server process) if the memory demands of either PostgreSQL or another process cause the system to run out of virtual memory.</source>
          <target state="translated">在Linux 2.4及以后的版本中,默认的虚拟内存行为对PostgreSQL来说并不是最佳的。由于内核实现内存超限的方式,如果PostgreSQL或其他进程的内存需求导致系统的虚拟内存耗尽,内核可能会终止PostgreSQL postmaster(主服务器进程)。</target>
        </trans-unit>
        <trans-unit id="f9db993d9ed52b850a8119db5ab8d068b60a0509" translate="yes" xml:space="preserve">
          <source>In NetBSD 5.0 and later, IPC parameters can be adjusted using &lt;code&gt;sysctl&lt;/code&gt;, for example:</source>
          <target state="translated">在NetBSD 5.0和更高版本中，可以使用 &lt;code&gt;sysctl&lt;/code&gt; 调整IPC参数，例如：</target>
        </trans-unit>
        <trans-unit id="33cf5a32119e2012e85b594bd01ed746ff893ad5" translate="yes" xml:space="preserve">
          <source>In OpenBSD 3.3 and later, IPC parameters can be adjusted using &lt;code&gt;sysctl&lt;/code&gt;, for example:</source>
          <target state="translated">在OpenBSD 3.3和更高版本中，可以使用 &lt;code&gt;sysctl&lt;/code&gt; 调整IPC参数，例如：</target>
        </trans-unit>
        <trans-unit id="d469c640f950b7673c7ae58a9ecc0f315265b7c1" translate="yes" xml:space="preserve">
          <source>In PostgreSQL releases prior to 9.0, large objects did not have access privileges and were, therefore, always readable and writable by all users. Setting this variable to &lt;code&gt;on&lt;/code&gt; disables the new privilege checks, for compatibility with prior releases. The default is &lt;code&gt;off&lt;/code&gt;. Only superusers can change this setting.</source>
          <target state="translated">在9.0之前的PostgreSQL版本中，大对象没有访问权限，因此，所有用户始终可以读取和写入。将此变量设置为 &lt;code&gt;on&lt;/code&gt; 将禁用新的特权检查，以与以前的版本兼容。默认为 &lt;code&gt;off&lt;/code&gt; 。只有超级用户可以更改此设置。</target>
        </trans-unit>
        <trans-unit id="22cd8a67509e8ca7db080a3ecd0b854c45395a98" translate="yes" xml:space="preserve">
          <source>In PostgreSQL releases prior to 9.3, &lt;code&gt;commit_delay&lt;/code&gt; behaved differently and was much less effective: it affected only commits, rather than all WAL flushes, and waited for the entire configured delay even if the WAL flush was completed sooner. Beginning in PostgreSQL 9.3, the first process that becomes ready to flush waits for the configured interval, while subsequent processes wait only until the leader completes the flush operation.</source>
          <target state="translated">在9.3之前的PostgreSQL发行版中， &lt;code&gt;commit_delay&lt;/code&gt; 的行为有所不同，并且效果要差得多：它仅影响提交，而不影响所有WAL刷新，并且即使WAL刷新提前完成，也要等待整个配置的延迟。从PostgreSQL 9.3开始，准备刷新的第一个进程将等待配置的时间间隔，而后续进程仅等待领导者完成刷新操作。</target>
        </trans-unit>
        <trans-unit id="b3a09d320c0eb1af5ebf6fc539b70645d7fbc828" translate="yes" xml:space="preserve">
          <source>In PostgreSQL versions 8.0 through 8.2, the effects of a &lt;code&gt;SET LOCAL&lt;/code&gt; would be canceled by releasing an earlier savepoint, or by successful exit from a PL/pgSQL exception block. This behavior has been changed because it was deemed unintuitive.</source>
          <target state="translated">在PostgreSQL 8.0到8.2版本中，通过释放更早的保存点或成功退出PL / pgSQL异常块，可以取消 &lt;code&gt;SET LOCAL&lt;/code&gt; 的影响。此行为已更改，因为它被认为是不直观的。</target>
        </trans-unit>
        <trans-unit id="a2a2f1f614c98ca12a5b32b40e076079264d9c76" translate="yes" xml:space="preserve">
          <source>In PostgreSQL versions before 7.3, it was customary to avoid creating a shell type at all, by replacing the functions' forward references to the type name with the placeholder pseudo-type &lt;code&gt;opaque&lt;/code&gt;. The &lt;code&gt;cstring&lt;/code&gt; arguments and results also had to be declared as &lt;code&gt;opaque&lt;/code&gt; before 7.3. To support loading of old dump files, &lt;code&gt;CREATE TYPE&lt;/code&gt; will accept I/O functions declared using &lt;code&gt;opaque&lt;/code&gt;, but it will issue a notice and change the function declarations to use the correct types.</source>
          <target state="translated">在7.3之前的PostgreSQL版本中，习惯上完全避免创建外壳类型，方法是使用占位符伪类型 &lt;code&gt;opaque&lt;/code&gt; 替换函数对类型名称的前向引用。在7.3之前， &lt;code&gt;cstring&lt;/code&gt; 参数和结果还必须声明为 &lt;code&gt;opaque&lt;/code&gt; 。为了支持加载旧的转储文件， &lt;code&gt;CREATE TYPE&lt;/code&gt; 将接受使用 &lt;code&gt;opaque&lt;/code&gt; 声明的I / O函数，但是它将发出通知并更改函数声明以使用正确的类型。</target>
        </trans-unit>
        <trans-unit id="b355acb666b0ad4cd57d90f2927cbffb2b6ed9ef" translate="yes" xml:space="preserve">
          <source>In PostgreSQL versions before 7.3, it was necessary to declare handler functions as returning the placeholder type &lt;code&gt;opaque&lt;/code&gt;, rather than &lt;code&gt;language_handler&lt;/code&gt;. To support loading of old dump files, &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; will accept a function declared as returning &lt;code&gt;opaque&lt;/code&gt;, but it will issue a notice and change the function's declared return type to &lt;code&gt;language_handler&lt;/code&gt;.</source>
          <target state="translated">在7.3之前的PostgreSQL版本中，必须将处理程序函数声明为返回占位符类型 &lt;code&gt;opaque&lt;/code&gt; ，而不是 &lt;code&gt;language_handler&lt;/code&gt; 。为了支持加载旧的转储文件， &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; 将接受一个声明为返回 &lt;code&gt;opaque&lt;/code&gt; 的函数，但是它将发出通知并将该函数的声明返回类型更改为 &lt;code&gt;language_handler&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c16c4aa970c78b968d9f432a8088edb5d24051d5" translate="yes" xml:space="preserve">
          <source>In PostgreSQL versions before 7.3, it was necessary to declare trigger functions as returning the placeholder type &lt;code&gt;opaque&lt;/code&gt;, rather than &lt;code&gt;trigger&lt;/code&gt;. To support loading of old dump files, &lt;code&gt;CREATE TRIGGER&lt;/code&gt; will accept a function declared as returning &lt;code&gt;opaque&lt;/code&gt;, but it will issue a notice and change the function's declared return type to &lt;code&gt;trigger&lt;/code&gt;.</source>
          <target state="translated">在7.3之前的PostgreSQL版本中，必须将触发函数声明为返回占位符类型 &lt;code&gt;opaque&lt;/code&gt; ，而不是 &lt;code&gt;trigger&lt;/code&gt; 。为了支持加载旧的转储文件， &lt;code&gt;CREATE TRIGGER&lt;/code&gt; 将接受一个声明为返回 &lt;code&gt;opaque&lt;/code&gt; 的函数，但是它将发出通知并将该函数的声明返回类型更改为 &lt;code&gt;trigger&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3c68aa880bfe2dcd90559cbb12f6681d9282ddb1" translate="yes" xml:space="preserve">
          <source>In PostgreSQL versions before 9.4, freezing was implemented by actually replacing a row's insertion XID with &lt;code&gt;FrozenTransactionId&lt;/code&gt;, which was visible in the row's &lt;code&gt;xmin&lt;/code&gt; system column. Newer versions just set a flag bit, preserving the row's original &lt;code&gt;xmin&lt;/code&gt; for possible forensic use. However, rows with &lt;code&gt;xmin&lt;/code&gt; equal to &lt;code&gt;FrozenTransactionId&lt;/code&gt; (2) may still be found in databases pg_upgrade'd from pre-9.4 versions.</source>
          <target state="translated">在PostgreSQL 9.4之前的版本中，凝固是由在实际更换与行的插入XID实施 &lt;code&gt;FrozenTransactionId&lt;/code&gt; ，这是该行的可见 &lt;code&gt;xmin&lt;/code&gt; 系统列。较新的版本只设置了一个标志位，保留了该行的原始 &lt;code&gt;xmin&lt;/code&gt; 以便可能用于取证。但是，在9.4版之前的版本pg_upgrade中，仍可能找到 &lt;code&gt;xmin&lt;/code&gt; 等于 &lt;code&gt;FrozenTransactionId&lt;/code&gt; （2）的行。</target>
        </trans-unit>
        <trans-unit id="671f1f8fc18839cfcffc25653d6a82f0e2f7003b" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, &lt;em&gt;Class&lt;/em&gt; is an archaic synonym for &lt;em&gt;relation&lt;/em&gt;.</source>
          <target state="translated">在PostgreSQL中，&lt;em&gt;Class&lt;/em&gt;是&lt;em&gt;Relation&lt;/em&gt;的古老同义词。</target>
        </trans-unit>
        <trans-unit id="eadad43cc831b2ff40334680f58601d4f7a10c43" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, a reference to a table name (or alias) in a query is effectively a reference to the composite value of the table's current row. For example, if we had a table &lt;code&gt;inventory_item&lt;/code&gt; as shown &lt;a href=&quot;rowtypes#ROWTYPES-DECLARING&quot;&gt;above&lt;/a&gt;, we could write:</source>
          <target state="translated">在PostgreSQL中，对查询中表名（或别名）的引用实际上是对表当前行的组合值的引用。例如，如果我们有一个表 &lt;code&gt;inventory_item&lt;/code&gt; 如&lt;a href=&quot;rowtypes#ROWTYPES-DECLARING&quot;&gt;上述&lt;/a&gt;，我们可以这样写：</target>
        </trans-unit>
        <trans-unit id="4a86fbee986217732dc6e120d53c8e8d4a6c9100" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, a table can inherit from zero or more other tables, and a query can reference either all rows of a table or all rows of a table plus all of its descendant tables. The latter behavior is the default. For example, the following query finds the names of all cities, including state capitals, that are located at an altitude over 500 feet:</source>
          <target state="translated">在PostgreSQL中,一个表可以从零个或多个其他表继承,一个查询可以引用一个表的所有行,也可以引用一个表的所有行加上其所有的子表。后一种行为是默认的。例如,下面的查询可以查找所有位于海拔500英尺以上的城市(包括州府)的名称。</target>
        </trans-unit>
        <trans-unit id="5bbc940645cf942038016bf2339fe7d4f2c180e0" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, a table can inherit from zero or more other tables, and a query can reference either all rows of a table or all rows of a table plus all of its descendant tables. The latter behavior is the default. For example, the following query finds the names of all cities, including state capitals, that are located at an elevation over 500 feet:</source>
          <target state="translated">在PostgreSQL中,一个表可以从零个或多个其他表继承,一个查询可以引用一个表的所有行,也可以引用一个表的所有行加上其所有的子表。后一种行为是默认的。例如,下面的查询可以查找所有海拔超过500英尺的城市(包括州府)的名称。</target>
        </trans-unit>
        <trans-unit id="74efdce9636de27e76a8b8265ce6cb497dd89fdf" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, a transaction is set up by surrounding the SQL commands of the transaction with &lt;code&gt;BEGIN&lt;/code&gt; and &lt;code&gt;COMMIT&lt;/code&gt; commands. So our banking transaction would actually look like:</source>
          <target state="translated">在PostgreSQL中，通过使用 &lt;code&gt;BEGIN&lt;/code&gt; 和 &lt;code&gt;COMMIT&lt;/code&gt; 命令包围事务的SQL命令来建立事务。因此，我们的银行交易实际上看起来像：</target>
        </trans-unit>
        <trans-unit id="ba3eb2b425968ebc072af7dd5475bc71e9126bfd" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, an &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; of a row does not immediately remove the old version of the row. This approach is necessary to gain the benefits of multiversion concurrency control (MVCC, see &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;): the row version must not be deleted while it is still potentially visible to other transactions. But eventually, an outdated or deleted row version is no longer of interest to any transaction. The space it occupies must then be reclaimed for reuse by new rows, to avoid unbounded growth of disk space requirements. This is done by running &lt;code&gt;VACUUM&lt;/code&gt;.</source>
          <target state="translated">在PostgreSQL中，一行的 &lt;code&gt;UPDATE&lt;/code&gt; 或 &lt;code&gt;DELETE&lt;/code&gt; 不会立即删除该行的旧版本。这种方法对于获得多版本并发控制（MVCC，请参阅&lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;第13章&lt;/a&gt;）的好处是必不可少的：必须删除行版本，而其他交易仍可能看到该行版本。但是最终，过时或已删除的行版本不再对任何事务有意义。然后必须占用它占用的空间，以供新行重用，以避免磁盘空间需求无限制地增长。这是通过运行 &lt;code&gt;VACUUM&lt;/code&gt; 完成的。</target>
        </trans-unit>
        <trans-unit id="6391c36f8926e9d031902999f670ae49ff9d23c6" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, an &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; of a row does not immediately remove the old version of the row. This approach is necessary to gain the benefits of multiversion concurrency control (MVCC, see &lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;): the row version must not be deleted while it is still potentially visible to other transactions. But eventually, an outdated or deleted row version is no longer of interest to any transaction. The space it occupies must then be reclaimed for reuse by new rows, to avoid unbounded growth of disk space requirements. This is done by running &lt;code&gt;VACUUM&lt;/code&gt;.</source>
          <target state="translated">在PostgreSQL中，一行的 &lt;code&gt;UPDATE&lt;/code&gt; 或 &lt;code&gt;DELETE&lt;/code&gt; 不会立即删除该行的旧版本。要获得多版本并发控制（MVCC，请参阅&lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;第13章&lt;/a&gt;）的好处，必须使用这种方法：必须删除行版本，而其他交易仍然可以看到该行版本。但是最终，过时或已删除的行版本不再对任何事务有意义。然后必须占用它占用的空间，以供新行重用，以避免磁盘空间需求无限制地增长。这是通过运行 &lt;code&gt;VACUUM&lt;/code&gt; 完成的。</target>
        </trans-unit>
        <trans-unit id="b304e14a0ece97ffe0ae3c2773ba82b02c4d00d4" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, the term &lt;em&gt;cluster&lt;/em&gt; is also sometimes used to refer to an instance. (Don't confuse this term with the SQL command &lt;code&gt;CLUSTER&lt;/code&gt;.)</source>
          <target state="translated">在PostgreSQL中，术语&lt;em&gt;集群&lt;/em&gt;有时也用于指代实例。（不要将此术语与SQL命令 &lt;code&gt;CLUSTER&lt;/code&gt; 混淆。）</target>
        </trans-unit>
        <trans-unit id="bbda6fce7f63ccb95f1398e8c5c8a9c6bb83f492" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, you can request any of the four standard transaction isolation levels, but internally only three distinct isolation levels are implemented, i.e. PostgreSQL's Read Uncommitted mode behaves like Read Committed. This is because it is the only sensible way to map the standard isolation levels to PostgreSQL's multiversion concurrency control architecture.</source>
          <target state="translated">在PostgreSQL中,你可以请求四个标准事务隔离级别中的任何一个,但内部只实现了三个不同的隔离级别,即PostgreSQL的Read Uncommitted模式的行为与Read Committed类似。这是因为它是将标准隔离级别映射到PostgreSQL的多版本并发控制架构的唯一合理方式。</target>
        </trans-unit>
        <trans-unit id="83cd5c09f1c331276300cecbfba985d6b8844acd" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, you can request any of the four standard transaction isolation levels, but internally only three distinct isolation levels are implemented, i.e., PostgreSQL's Read Uncommitted mode behaves like Read Committed. This is because it is the only sensible way to map the standard isolation levels to PostgreSQL's multiversion concurrency control architecture.</source>
          <target state="translated">在PostgreSQL中,你可以请求四个标准事务隔离级别中的任何一个,但内部只实现了三个不同的隔离级别,也就是说,PostgreSQL的Read Uncommitted模式的行为就像Read Committed。这是因为它是将标准隔离级别映射到PostgreSQL的多版本并发控制架构的唯一合理方式。</target>
        </trans-unit>
        <trans-unit id="759eb406805a5a1c000f22431f41b882c8790352" translate="yes" xml:space="preserve">
          <source>In SCRAM without channel binding, the server chooses a random number that is transmitted to the client to be mixed with the user-supplied password in the transmitted password hash. While this prevents the password hash from being successfully retransmitted in a later session, it does not prevent a fake server between the real server and client from passing through the server's random value and successfully authenticating.</source>
          <target state="translated">在没有信道绑定的SCRAM中,服务器选择一个随机数传送给客户端,与用户提供的密码混合在传送的密码哈希中。虽然这样可以防止密码哈希在以后的会话中被成功重传,但并不能防止真实服务器和客户端之间的假服务器通过服务器的随机值而成功认证。</target>
        </trans-unit>
        <trans-unit id="bbe3d8277f59658a3be0c65846387947fe489961" translate="yes" xml:space="preserve">
          <source>In SQL:2006 and later, both directions of conversion between standard SQL data types and the XML Schema types are specified precisely. However, the rules are expressed using the types and semantics of XQuery/XPath, and have no direct application to the different data model of XPath 1.0.</source>
          <target state="translated">在SQL:2006及以后的版本中,标准SQL数据类型和XML Schema类型之间的转换方向都有精确的规定。但是,这些规则是用XQuery/XPath的类型和语义来表达的,对XPath 1.0的不同数据模型没有直接应用。</target>
        </trans-unit>
        <trans-unit id="1cddd15d85853fd05a956af5b4c400072d8cd616" translate="yes" xml:space="preserve">
          <source>In Solaris 10 and later, and OpenSolaris, the default shared memory and semaphore settings are good enough for most PostgreSQL applications. Solaris now defaults to a &lt;code&gt;SHMMAX&lt;/code&gt; of one-quarter of system RAM. To further adjust this setting, use a project setting associated with the &lt;code&gt;postgres&lt;/code&gt; user. For example, run the following as &lt;code&gt;root&lt;/code&gt;:</source>
          <target state="translated">在Solaris 10和更高版本以及OpenSolaris中，默认的共享内存和信号设置对于大多数PostgreSQL应用程序来说已经足够了。 Solaris现在默认将 &lt;code&gt;SHMMAX&lt;/code&gt; 设置为系统RAM的四分之一。要进一步调整此设置，请使用与 &lt;code&gt;postgres&lt;/code&gt; 用户关联的项目设置。例如，以 &lt;code&gt;root&lt;/code&gt; 身份运行以下命令：</target>
        </trans-unit>
        <trans-unit id="f2711fad286d67111c91bf5304258de9bff55609" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;BEFORE&lt;/code&gt; trigger, the &lt;code&gt;WHEN&lt;/code&gt; condition is evaluated just before the function is or would be executed, so using &lt;code&gt;WHEN&lt;/code&gt; is not materially different from testing the same condition at the beginning of the trigger function. Note in particular that the &lt;code&gt;NEW&lt;/code&gt; row seen by the condition is the current value, as possibly modified by earlier triggers. Also, a &lt;code&gt;BEFORE&lt;/code&gt; trigger's &lt;code&gt;WHEN&lt;/code&gt; condition is not allowed to examine the system columns of the &lt;code&gt;NEW&lt;/code&gt; row (such as &lt;code&gt;ctid&lt;/code&gt;), because those won't have been set yet.</source>
          <target state="translated">在 &lt;code&gt;BEFORE&lt;/code&gt; 触发器中， &lt;code&gt;WHEN&lt;/code&gt; 条件在函数即将执行或即将执行之前就进行了评估，因此使用 &lt;code&gt;WHEN&lt;/code&gt; 与在触发器函数开始时测试相同条件没有实质性区别。特别要注意的是，条件看到的 &lt;code&gt;NEW&lt;/code&gt; 行是当前值，可能会被更早的触发器修改。另外，不允许 &lt;code&gt;BEFORE&lt;/code&gt; 触发器的 &lt;code&gt;WHEN&lt;/code&gt; 条件检查 &lt;code&gt;NEW&lt;/code&gt; 行的系统列（例如 &lt;code&gt;ctid&lt;/code&gt; ），因为尚未设置这些列。</target>
        </trans-unit>
        <trans-unit id="9ce810944c17541339c741b40b793201537de044" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;DELETE&lt;/code&gt;, the data available to &lt;code&gt;RETURNING&lt;/code&gt; is the content of the deleted row. For example:</source>
          <target state="translated">在 &lt;code&gt;DELETE&lt;/code&gt; 中，可用于 &lt;code&gt;RETURNING&lt;/code&gt; 的数据是已删除行的内容。例如：</target>
        </trans-unit>
        <trans-unit id="0d3bf14e9dc0493ac82721df4faae7ba81c88992" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;DROP FUNCTION&lt;/code&gt; clause, the operand data type(s) the function is intended to support must be specified.</source>
          <target state="translated">在 &lt;code&gt;DROP FUNCTION&lt;/code&gt; 子句中，必须指定函数要支持的操作数数据类型。</target>
        </trans-unit>
        <trans-unit id="85532f42163c3739d7f5a6244714ead077b8baea" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;FUNCTION&lt;/code&gt; clause, the operand data type(s) the function is intended to support, if different from the input data type(s) of the function (for B-tree comparison functions and hash functions) or the class's data type (for B-tree sort support functions and all functions in GiST, SP-GiST, GIN and BRIN operator classes). These defaults are correct, and so &lt;code&gt;op_type&lt;/code&gt; need not be specified in &lt;code&gt;FUNCTION&lt;/code&gt; clauses, except for the case of a B-tree sort support function that is meant to support cross-data-type comparisons.</source>
          <target state="translated">在 &lt;code&gt;FUNCTION&lt;/code&gt; 子句中，如果函数的输入数据类型（用于B树比较函数和哈希函数）或类的数据类型（用于B树排序支持功能以及GiST，SP-GiST，GIN和BRIN运算符类中的所有功能）。这些默认值是正确的，因此，除了B树排序支持功能旨在支持跨数据类型比较的情况外，无需在 &lt;code&gt;FUNCTION&lt;/code&gt; 子句中指定 &lt;code&gt;op_type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48b115e1e3ffc8870fd0440011ed57528dd63c06" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;FUNCTION&lt;/code&gt; clause, the operand data type(s) the function is intended to support, if different from the input data type(s) of the function (for B-tree comparison functions and hash functions) or the class's data type (for B-tree sort support functions, B-tree equal image functions, and all functions in GiST, SP-GiST, GIN and BRIN operator classes). These defaults are correct, and so &lt;code&gt;op_type&lt;/code&gt; need not be specified in &lt;code&gt;FUNCTION&lt;/code&gt; clauses, except for the case of a B-tree sort support function that is meant to support cross-data-type comparisons.</source>
          <target state="translated">在 &lt;code&gt;FUNCTION&lt;/code&gt; 子句中，如果函数的输入数据类型（用于B树比较函数和哈希函数）或类的数据类型（用于B树排序支持功能，B树相等图像功能以及GiST，SP-GiST，GIN和BRIN运算符类中的所有功能）。这些默认值是正确的，因此，除了B树排序支持功能旨在支持跨数据类型比较的情况外，无需在 &lt;code&gt;FUNCTION&lt;/code&gt; 子句中指定 &lt;code&gt;op_type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f9bb9a1e74c73e631d5463da369a9644506e4f0" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;SELECT&lt;/code&gt; command, these two policies are combined using &lt;code&gt;OR&lt;/code&gt;, with the net effect being that all rows can be selected. In other command types, only the second policy applies, so that the effects are the same as before.</source>
          <target state="translated">在 &lt;code&gt;SELECT&lt;/code&gt; 命令中，这两个策略是使用 &lt;code&gt;OR&lt;/code&gt; 组合的，其最终效果是可以选择所有行。在其他命令类型中，仅应用第二种策略，因此效果与以前相同。</target>
        </trans-unit>
        <trans-unit id="300ce212406203fa6b094fb383bde2b25f44a159" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;pg_hba.conf&lt;/code&gt; record specifying certificate authentication, the authentication option &lt;code&gt;clientcert&lt;/code&gt; is assumed to be &lt;code&gt;verify-ca&lt;/code&gt; or &lt;code&gt;verify-full&lt;/code&gt;, and it cannot be turned off since a client certificate is necessary for this method. What the &lt;code&gt;cert&lt;/code&gt; method adds to the basic &lt;code&gt;clientcert&lt;/code&gt; certificate validity test is a check that the &lt;code&gt;cn&lt;/code&gt; attribute matches the database user name.</source>
          <target state="translated">在指定证书认证的 &lt;code&gt;pg_hba.conf&lt;/code&gt; 记录中，认证选项 &lt;code&gt;clientcert&lt;/code&gt; 被假定为 &lt;code&gt;verify-ca&lt;/code&gt; 或 &lt;code&gt;verify-full&lt;/code&gt; ，由于该方法需要客户端证书，因此无法将其关闭。哪些 &lt;code&gt;cert&lt;/code&gt; 方法增加了基本 &lt;code&gt;clientcert&lt;/code&gt; 证书有效性测试是检查 &lt;code&gt;cn&lt;/code&gt; 属性数据库的用户名相匹配。</target>
        </trans-unit>
        <trans-unit id="f05e815aa51edd32e8f243de544f1a7fed6f4907" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;to_char&lt;/code&gt; output template string, there are certain patterns that are recognized and replaced with appropriately-formatted data based on the given value. Any text that is not a template pattern is simply copied verbatim. Similarly, in an input template string (for the other functions), template patterns identify the values to be supplied by the input data string. If there are characters in the template string that are not template patterns, the corresponding characters in the input data string are simply skipped over (whether or not they are equal to the template string characters).</source>
          <target state="translated">在 &lt;code&gt;to_char&lt;/code&gt; 输出模板字符串中，基于给定值识别并替换为某些格式的数据的某些模式。非模板模式的任何文本都将被逐字复制。同样，在输入模板字符串（用于其他功能）中，模板模式标识输入数据字符串要提供的值。如果模板字符串中存在不是模板模式的字符，则只需跳过输入数据字符串中的相应字符（无论它们是否等于模板字符串字符）。</target>
        </trans-unit>
        <trans-unit id="78e3bba2064f9d9c2fee2733a54ca75d990eba66" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;hash join&lt;/em&gt; (without the &quot;parallel&quot; prefix), the inner side is executed in full by every cooperating process to build identical copies of the hash table. This may be inefficient if the hash table is large or the plan is expensive. In a &lt;em&gt;parallel hash join&lt;/em&gt;, the inner side is a &lt;em&gt;parallel hash&lt;/em&gt; that divides the work of building a shared hash table over the cooperating processes.</source>
          <target state="translated">在&lt;em&gt;哈希联接&lt;/em&gt;（没有&amp;ldquo; parallel&amp;rdquo;前缀）中，每个协作过程都将完全执行内侧，以构建哈希表的相同副本。如果哈希表很大或计划很昂贵，这可能是无效的。在&lt;em&gt;并行哈希联接中&lt;/em&gt;，内侧是&lt;em&gt;并行哈希&lt;/em&gt;，它将&lt;em&gt;并行&lt;/em&gt;共享工作划分为协作过程。</target>
        </trans-unit>
        <trans-unit id="3480286d445961d6181c445c4ffd40322b928fd9" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;merge join&lt;/em&gt;, the inner side is always a non-parallel plan and therefore executed in full. This may be inefficient, especially if a sort must be performed, because the work and resulting data are duplicated in every cooperating process.</source>
          <target state="translated">在&lt;em&gt;合并联接中&lt;/em&gt;，内侧始终是非并行计划，因此将完全执行。这可能效率很低，尤其是在必须执行某种排序的情况下，因为工作和结果数据在每个合作过程中都是重复的。</target>
        </trans-unit>
        <trans-unit id="400e7c200fdc3546ddf00f5c7ed10cb2ab42e4c0" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;nested loop join&lt;/em&gt;, the inner side is always non-parallel. Although it is executed in full, this is efficient if the inner side is an index scan, because the outer tuples and thus the loops that look up values in the index are divided over the cooperating processes.</source>
          <target state="translated">在&lt;em&gt;嵌套循环连接中&lt;/em&gt;，内侧始终是不平行的。尽管它是完全执行的，但是如果内侧是索引扫描，则这样做是有效的，因为外部元组以及在索引中查找值的循环在合作过程中被划分。</target>
        </trans-unit>
        <trans-unit id="dea6a7ade41e8f01fb686c080220d4159b567183" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;parallel bitmap heap scan&lt;/em&gt;, one process is chosen as the leader. That process performs a scan of one or more indexes and builds a bitmap indicating which table blocks need to be visited. These blocks are then divided among the cooperating processes as in a parallel sequential scan. In other words, the heap scan is performed in parallel, but the underlying index scan is not.</source>
          <target state="translated">在&lt;em&gt;并行位图堆扫描中&lt;/em&gt;，选择一个进程作为领导者。该过程执行一个或多个索引的扫描，并建立一个位图，指示需要访问哪些表块。然后，像在并行顺序扫描中一样，将这些块划分为协作过程。换句话说，堆扫描是并行执行的，但底层索引扫描不是并行执行的。</target>
        </trans-unit>
        <trans-unit id="8227deba10aefb19ed8caa11f69ff745de460ae7" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;parallel index scan&lt;/em&gt; or &lt;em&gt;parallel index-only scan&lt;/em&gt;, the cooperating processes take turns reading data from the index. Currently, parallel index scans are supported only for btree indexes. Each process will claim a single index block and will scan and return all tuples referenced by that block; other process can at the same time be returning tuples from a different index block. The results of a parallel btree scan are returned in sorted order within each worker process.</source>
          <target state="translated">在&lt;em&gt;并行索引扫描&lt;/em&gt;或&lt;em&gt;仅并行索引扫描中&lt;/em&gt;，协作过程轮流从索引中读取数据。当前，仅btree索引支持并行索引扫描。每个进程将声明一个索引块，并将扫描并返回该块引用的所有元组；其他进程可以同时从不同的索引块返回元组。并行btree扫描的结果在每个工作进程中按排序顺序返回。</target>
        </trans-unit>
        <trans-unit id="76601edb0fbc4f9ce17e08d79102a74db01983a7" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;parallel index scan&lt;/em&gt; or &lt;em&gt;parallel index-only scan&lt;/em&gt;, the cooperating processes take turns reading data from the index. Currently, parallel index scans are supported only for btree indexes. Each process will claim a single index block and will scan and return all tuples referenced by that block; other processes can at the same time be returning tuples from a different index block. The results of a parallel btree scan are returned in sorted order within each worker process.</source>
          <target state="translated">在&lt;em&gt;并行索引扫描&lt;/em&gt;或&lt;em&gt;仅并行索引扫描中&lt;/em&gt;，协作过程轮流从索引中读取数据。当前，仅btree索引支持并行索引扫描。每个进程都将声明一个索引块，并将扫描并返回该块引用的所有元组。其他进程可以同时从不同的索引块返回元组。并行btree扫描的结果在每个工作进程中按排序顺序返回。</target>
        </trans-unit>
        <trans-unit id="9434bbdc8aace98fbdb811c879672bca3c9b835e" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;parallel sequential scan&lt;/em&gt;, the table's blocks will be divided among the cooperating processes. Blocks are handed out one at a time, so that access to the table remains sequential.</source>
          <target state="translated">在&lt;em&gt;并行顺序扫描中&lt;/em&gt;，表的块将在协作过程之间分配。一次分发一个块，以便对表的访问保持顺序。</target>
        </trans-unit>
        <trans-unit id="f3fefb800e2db94c9c9a41bf996e2bc5c5260e63" translate="yes" xml:space="preserve">
          <source>In a B-tree leaf page, &lt;code&gt;ctid&lt;/code&gt; points to a heap tuple. In an internal page, the block number part of &lt;code&gt;ctid&lt;/code&gt; points to another page in the index itself, while the offset part (the second number) is ignored and is usually 1.</source>
          <target state="translated">在B树叶子页中， &lt;code&gt;ctid&lt;/code&gt; 指向堆元组。在内部页中， &lt;code&gt;ctid&lt;/code&gt; 的块号部分指向索引本身中的另一页，而偏移量部分（第二个数字）将被忽略，通常为1。</target>
        </trans-unit>
        <trans-unit id="d0a6087a10f85c3bb150e6308e3861061574aa67" translate="yes" xml:space="preserve">
          <source>In a concurrent index build, the index is actually entered into the system catalogs in one transaction, then two table scans occur in two more transactions. Before each table scan, the index build must wait for existing transactions that have modified the table to terminate. After the second scan, the index build must wait for any transactions that have a snapshot (see &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;) predating the second scan to terminate. Then finally the index can be marked ready for use, and the &lt;code&gt;CREATE INDEX&lt;/code&gt; command terminates. Even then, however, the index may not be immediately usable for queries: in the worst case, it cannot be used as long as transactions exist that predate the start of the index build.</source>
          <target state="translated">在并发索引构建中，索引实际上是在一个事务中输入到系统目录中，然后在另外两个事务中进行两次表扫描。在每次表扫描之前，索引构建必须等待修改该表的现有事务终止。在第二次扫描之后，索引构建必须等待在第二次扫描之前终止具有快照的所有事务（请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;第13章&lt;/a&gt;）。然后，最后可以将索引标记为可使用，并且 &lt;code&gt;CREATE INDEX&lt;/code&gt; 命令终止。但是，即使那样，索引也可能无法立即用于查询：在最坏的情况下，只要存在早于索引构建开始的事务，就不能使用该索引。</target>
        </trans-unit>
        <trans-unit id="c15278182867851c1af83a8c951f5ef55e2fcbe1" translate="yes" xml:space="preserve">
          <source>In a concurrent index build, the index is actually entered into the system catalogs in one transaction, then two table scans occur in two more transactions. Before each table scan, the index build must wait for existing transactions that have modified the table to terminate. After the second scan, the index build must wait for any transactions that have a snapshot (see &lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;) predating the second scan to terminate. Then finally the index can be marked ready for use, and the &lt;code&gt;CREATE INDEX&lt;/code&gt; command terminates. Even then, however, the index may not be immediately usable for queries: in the worst case, it cannot be used as long as transactions exist that predate the start of the index build.</source>
          <target state="translated">在并发索引构建中，实际上是通过一个事务将索引输入到系统目录中，然后在另外两个事务中进行两次表扫描。在每个表扫描之前，索引构建必须等待修改该表的现有事务终止。在第二次扫描之后，索引构建必须等待在第二次扫描之前终止具有快照的所有事务（请参见&lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;第13章&lt;/a&gt;）。然后，最后可以将索引标记为可以使用了，然后 &lt;code&gt;CREATE INDEX&lt;/code&gt; 命令终止。但是，即使那样，索引也可能无法立即用于查询：在最坏的情况下，只要存在早于索引构建开始的事务，就不能使用该索引。</target>
        </trans-unit>
        <trans-unit id="f4a542d58c1d654f7da71e85731698e5120795a1" translate="yes" xml:space="preserve">
          <source>In a default installation, none of the above parameters are set explicitly. Instead, the data directory is specified by the &lt;code&gt;-D&lt;/code&gt; command-line option or the &lt;code&gt;PGDATA&lt;/code&gt; environment variable, and the configuration files are all found within the data directory.</source>
          <target state="translated">在默认安装中，以上参数均未明确设置。而是通过 &lt;code&gt;-D&lt;/code&gt; 命令行选项或 &lt;code&gt;PGDATA&lt;/code&gt; 环境变量指定数据目录，并且所有配置文件都在数据目录中找到。</target>
        </trans-unit>
        <trans-unit id="ade0e33e559fe0711e0dbe8eb460618e29475014" translate="yes" xml:space="preserve">
          <source>In a dropped column's &lt;code&gt;pg_attribute&lt;/code&gt; entry, &lt;code&gt;atttypid&lt;/code&gt; is reset to zero, but &lt;code&gt;attlen&lt;/code&gt; and the other fields copied from &lt;code&gt;pg_type&lt;/code&gt; are still valid. This arrangement is needed to cope with the situation where the dropped column's data type was later dropped, and so there is no &lt;code&gt;pg_type&lt;/code&gt; row anymore. &lt;code&gt;attlen&lt;/code&gt; and the other fields can be used to interpret the contents of a row of the table.</source>
          <target state="translated">在下降列的 &lt;code&gt;pg_attribute&lt;/code&gt; 里的条目， &lt;code&gt;atttypid&lt;/code&gt; 重置为零，但 &lt;code&gt;attlen&lt;/code&gt; 和复制等领域 &lt;code&gt;pg_type&lt;/code&gt; 里仍然有效。需要采取这种安排来应对删除的列的数据类型后来被删除的情况，因此不再有 &lt;code&gt;pg_type&lt;/code&gt; 行。 &lt;code&gt;attlen&lt;/code&gt; 和其他字段可用于解释表中一行的内容。</target>
        </trans-unit>
        <trans-unit id="919410546242ad36460212f72d578356bff6291e" translate="yes" xml:space="preserve">
          <source>In a literal that has been determined to be &lt;code&gt;timestamp without time zone&lt;/code&gt;, PostgreSQL will silently ignore any time zone indication. That is, the resulting value is derived from the date/time fields in the input value, and is not adjusted for time zone.</source>
          <target state="translated">在已确定为 &lt;code&gt;timestamp without time zone&lt;/code&gt; 的文字中，PostgreSQL将默默地忽略任何时区指示。即，结果值是从输入值中的日期/时间字段派生的，并且未针对时区进行调整。</target>
        </trans-unit>
        <trans-unit id="fe8c5382c7df4fd888e297e6990fce336207e731" translate="yes" xml:space="preserve">
          <source>In a priority-based synchronous replication, the standbys whose names appear earlier in the list will be used as synchronous standbys. Standbys listed after these will take over the role of synchronous standby if one of current ones should fail.</source>
          <target state="translated">在基于优先级的同步复制中,列表中名字出现较早的备用机将被用作同步备用机。如果当前的一个备份发生故障,这些备份之后列出的备份将接替同步备份的角色。</target>
        </trans-unit>
        <trans-unit id="6be13ad3386e50cb4bfa2ce22e78dd04cec9a6ab" translate="yes" xml:space="preserve">
          <source>In a quorum-based synchronous replication, all the standbys appearing in the list will be used as candidates for synchronous standbys. Even if one of them should fail, the other standbys will keep performing the role of candidates of synchronous standby.</source>
          <target state="translated">在基于法定人数的同步复制中,列表中出现的所有备用机都将被用作同步备用机的候选者。即使其中一个备份失败,其他备份也会继续执行同步备份候选者的角色。</target>
        </trans-unit>
        <trans-unit id="a6cdb6331798b6847433d71683fa652dae3c0858" translate="yes" xml:space="preserve">
          <source>In a rule for &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt; on a view, you can add a &lt;code&gt;RETURNING&lt;/code&gt; clause that emits the view's columns. This clause will be used to compute the outputs if the rule is triggered by an &lt;code&gt;INSERT RETURNING&lt;/code&gt;, &lt;code&gt;UPDATE RETURNING&lt;/code&gt;, or &lt;code&gt;DELETE RETURNING&lt;/code&gt; command respectively. When the rule is triggered by a command without &lt;code&gt;RETURNING&lt;/code&gt;, the rule's &lt;code&gt;RETURNING&lt;/code&gt; clause will be ignored. The current implementation allows only unconditional &lt;code&gt;INSTEAD&lt;/code&gt; rules to contain &lt;code&gt;RETURNING&lt;/code&gt;; furthermore there can be at most one &lt;code&gt;RETURNING&lt;/code&gt; clause among all the rules for the same event. (This ensures that there is only one candidate &lt;code&gt;RETURNING&lt;/code&gt; clause to be used to compute the results.) &lt;code&gt;RETURNING&lt;/code&gt; queries on the view will be rejected if there is no &lt;code&gt;RETURNING&lt;/code&gt; clause in any available rule.</source>
          <target state="translated">在视图上的 &lt;code&gt;INSERT&lt;/code&gt; ， &lt;code&gt;UPDATE&lt;/code&gt; 或 &lt;code&gt;DELETE&lt;/code&gt; 规则中，您可以添加一个 &lt;code&gt;RETURNING&lt;/code&gt; 子句来发出视图的列。如果规则分别由 &lt;code&gt;INSERT RETURNING&lt;/code&gt; ， &lt;code&gt;UPDATE RETURNING&lt;/code&gt; 或 &lt;code&gt;DELETE RETURNING&lt;/code&gt; 命令触发，则此子句将用于计算输出。当规则由不带 &lt;code&gt;RETURNING&lt;/code&gt; 的命令触发时，该规则的 &lt;code&gt;RETURNING&lt;/code&gt; 子句将被忽略。当前的实现只允许无条件的 &lt;code&gt;INSTEAD&lt;/code&gt; 规则包含 &lt;code&gt;RETURNING&lt;/code&gt; ；而且最多只能有一个 &lt;code&gt;RETURNING&lt;/code&gt; 相同事件的所有规则中的子句。（这确保了只有一个候选 &lt;code&gt;RETURNING&lt;/code&gt; 子句可用于计算结果。）如果任何可用规则中都没有 &lt;code&gt;RETURNING&lt;/code&gt; 子句，则视图上的 &lt;code&gt;RETURNING&lt;/code&gt; 查询将被拒绝。</target>
        </trans-unit>
        <trans-unit id="b30170def17c750dae562bb19e988c5bae9da5a7" translate="yes" xml:space="preserve">
          <source>In a simple join query, such as:</source>
          <target state="translated">在一个简单的连接查询中,如:</target>
        </trans-unit>
        <trans-unit id="3e1f4464d1af94cd74998edaeff888eee6d91174" translate="yes" xml:space="preserve">
          <source>In a standby server that exists primarily for high availability, it's best to set the delay parameters relatively short, so that the server cannot fall far behind the primary due to delays caused by standby queries. However, if the standby server is meant for executing long-running queries, then a high or even infinite delay value may be preferable. Keep in mind however that a long-running query could cause other sessions on the standby server to not see recent changes on the primary, if it delays application of WAL records.</source>
          <target state="translated">在一个主要为高可用性而存在的备用服务器中,最好将延迟参数设置得相对较短,这样服务器就不会因为备用查询造成的延迟而远远落后于主服务器。但是,如果备用服务器是为了执行长期运行的查询,那么一个高的甚至是无限的延迟值可能是比较好的。但是请记住,如果一个长期运行的查询延迟了WAL记录的应用,可能会导致备用服务器上的其他会话看不到主服务器上最近的变化。</target>
        </trans-unit>
        <trans-unit id="0a9a7bd917eb1db2204b6427584eda8a4fd3adfe" translate="yes" xml:space="preserve">
          <source>In a table definition, default values are listed after the column data type. For example:</source>
          <target state="translated">在表定义中,默认值列在列数据类型之后。例如:</target>
        </trans-unit>
        <trans-unit id="ea0511eba225911c6d4bd1330fecc7bed6e9ecc3" translate="yes" xml:space="preserve">
          <source>In addition these settings can be preserved between reboots in the file &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;. Doing that is highly recommended.</source>
          <target state="translated">另外，这些设置可以在重新启动之间保留在文件 &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 中。强烈建议您这样做。</target>
        </trans-unit>
        <trans-unit id="096299b269c3119f5fd70cea143f131c4bf07844" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;postgresql.conf&lt;/code&gt;, a PostgreSQL data directory contains a file &lt;code&gt;postgresql.auto.conf&lt;/code&gt;, which has the same format as &lt;code&gt;postgresql.conf&lt;/code&gt; but is intended to be edited automatically, not manually. This file holds settings provided through the &lt;a href=&quot;sql-altersystem&quot;&gt;ALTER SYSTEM&lt;/a&gt; command. This file is read whenever &lt;code&gt;postgresql.conf&lt;/code&gt; is, and its settings take effect in the same way. Settings in &lt;code&gt;postgresql.auto.conf&lt;/code&gt; override those in &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="translated">除 &lt;code&gt;postgresql.conf&lt;/code&gt; 外，PostgreSQL数据目录还包含一个文件 &lt;code&gt;postgresql.auto.conf&lt;/code&gt; ，该文件的格式与 &lt;code&gt;postgresql.conf&lt;/code&gt; 相同，但旨在自动进行编辑，而不是手动进行编辑。该文件包含通过&lt;a href=&quot;sql-altersystem&quot;&gt;ALTER SYSTEM&lt;/a&gt;命令提供的设置。每当 &lt;code&gt;postgresql.conf&lt;/code&gt; 被读取时，都会读取该文件，并且其设置以相同的方式生效。 &lt;code&gt;postgresql.auto.conf&lt;/code&gt; 中的设置将覆盖 &lt;code&gt;postgresql.conf&lt;/code&gt; 中的设置。</target>
        </trans-unit>
        <trans-unit id="8b72ebbfc32b5c7dc9d476e5e61c36ae4f704bc0" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;public&lt;/code&gt; and user-created schemas, each database contains a &lt;code&gt;pg_catalog&lt;/code&gt; schema, which contains the system tables and all the built-in data types, functions, and operators. &lt;code&gt;pg_catalog&lt;/code&gt; is always effectively part of the search path. If it is not named explicitly in the path then it is implicitly searched &lt;em&gt;before&lt;/em&gt; searching the path's schemas. This ensures that built-in names will always be findable. However, you can explicitly place &lt;code&gt;pg_catalog&lt;/code&gt; at the end of your search path if you prefer to have user-defined names override built-in names.</source>
          <target state="translated">除了 &lt;code&gt;public&lt;/code&gt; 和用户创建的架构之外，每个数据库还包含 &lt;code&gt;pg_catalog&lt;/code&gt; 架构，该架构包含系统表以及所有内置数据类型，函数和运算符。 &lt;code&gt;pg_catalog&lt;/code&gt; 始终有效地是搜索路径的一部分。如果未在路径中明确命名，则&lt;em&gt;在&lt;/em&gt;搜索路径的架构&lt;em&gt;之前&lt;/em&gt;将对其进行隐式搜索。这样可以确保始终可以找到内置名称。但是，如果您希望用户定义的名称覆盖内置名称，则可以在搜索路径的末尾显式放置 &lt;code&gt;pg_catalog&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f70bc34b6f3d01fe499b2933dfc1efba4688427d" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;standard_conforming_strings&lt;/code&gt;, the configuration parameters &lt;a href=&quot;runtime-config-compatible#GUC-ESCAPE-STRING-WARNING&quot;&gt;escape_string_warning&lt;/a&gt; and &lt;a href=&quot;runtime-config-compatible#GUC-BACKSLASH-QUOTE&quot;&gt;backslash_quote&lt;/a&gt; govern treatment of backslashes in string constants.</source>
          <target state="translated">除了 &lt;code&gt;standard_conforming_strings&lt;/code&gt; 之外，配置参数&lt;a href=&quot;runtime-config-compatible#GUC-ESCAPE-STRING-WARNING&quot;&gt;escape_string_warning&lt;/a&gt;和&lt;a href=&quot;runtime-config-compatible#GUC-BACKSLASH-QUOTE&quot;&gt;backslash_quote还&lt;/a&gt;控制字符串常量中反斜杠的处理。</target>
        </trans-unit>
        <trans-unit id="ca198320ff48380e299bcbd7319925ded5a95535" translate="yes" xml:space="preserve">
          <source>In addition to individual parameter settings, the &lt;code&gt;postgresql.conf&lt;/code&gt; file can contain &lt;em&gt;include directives&lt;/em&gt;, which specify another file to read and process as if it were inserted into the configuration file at this point. This feature allows a configuration file to be divided into physically separate parts. Include directives simply look like:</source>
          <target state="translated">除了单独的参数设置之外， &lt;code&gt;postgresql.conf&lt;/code&gt; 文件还可以包含&lt;em&gt;include伪指令&lt;/em&gt;，该&lt;em&gt;伪指令&lt;/em&gt;指定另一个要读取和处理的文件，就像此时已将其插入配置文件一样。此功能允许将配置文件分为物理上独立的部分。包含指令看起来就像：</target>
        </trans-unit>
        <trans-unit id="e670e7bf52fa0455274db822ce4cd6907d528db9" translate="yes" xml:space="preserve">
          <source>In addition to ordinary numeric values, the &lt;code&gt;numeric&lt;/code&gt; type allows the special value &lt;code&gt;NaN&lt;/code&gt;, meaning &amp;ldquo;not-a-number&amp;rdquo;. Any operation on &lt;code&gt;NaN&lt;/code&gt; yields another &lt;code&gt;NaN&lt;/code&gt;. When writing this value as a constant in an SQL command, you must put quotes around it, for example &lt;code&gt;UPDATE table SET x = 'NaN'&lt;/code&gt;. On input, the string &lt;code&gt;NaN&lt;/code&gt; is recognized in a case-insensitive manner.</source>
          <target state="translated">除普通数值外， &lt;code&gt;numeric&lt;/code&gt; 类型还允许使用特殊值 &lt;code&gt;NaN&lt;/code&gt; ，即&amp;ldquo;非数字&amp;rdquo;。对 &lt;code&gt;NaN&lt;/code&gt; 的任何操作都会产生另一个 &lt;code&gt;NaN&lt;/code&gt; 。在SQL命令中将此值写为常量时，必须在其 &lt;code&gt;UPDATE table SET x = 'NaN'&lt;/code&gt; 加上引号，例如UPDATE table SET x ='NaN'。输入时，以不区分大小写的方式识别字符串 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e4bbcc684e36efbca1c2d0b6de3932866401bc9a" translate="yes" xml:space="preserve">
          <source>In addition to ordinary numeric values, the floating-point types have several special values:</source>
          <target state="translated">除了普通的数值外,浮点类型还有一些特殊的数值。</target>
        </trans-unit>
        <trans-unit id="19311d87cac186ad5be7afccb28d88535be2bd00" translate="yes" xml:space="preserve">
          <source>In addition to setting global defaults or attaching overrides at the database or role level, you can pass settings to PostgreSQL via shell facilities. Both the server and libpq client library accept parameter values via the shell.</source>
          <target state="translated">除了在数据库或角色级别设置全局默认值或附加覆盖,你还可以通过shell设施将设置传递给PostgreSQL。服务器和libpq客户端库都可以通过shell接受参数值。</target>
        </trans-unit>
        <trans-unit id="a22166b5786a29ccaf8b6526c1e48730c5b76cde" translate="yes" xml:space="preserve">
          <source>In addition to simply finding the rows to be returned by a query, an index may be able to deliver them in a specific sorted order. This allows a query's &lt;code&gt;ORDER BY&lt;/code&gt; specification to be honored without a separate sorting step. Of the index types currently supported by PostgreSQL, only B-tree can produce sorted output &amp;mdash; the other index types return matching rows in an unspecified, implementation-dependent order.</source>
          <target state="translated">除了简单地查找要由查询返回的行外，索引还可以按特定的排序顺序传递它们。这允许查询的 &lt;code&gt;ORDER BY&lt;/code&gt; 规范，而无需单独的排序步骤。在PostgreSQL当前支持的索引类型中，只有B树可以产生排序后的输出-其他索引类型以未指定的，依赖于实现的顺序返回匹配的行。</target>
        </trans-unit>
        <trans-unit id="4ba1e6913eefc780040c670e81ceade68f518709" translate="yes" xml:space="preserve">
          <source>In addition to supporting ordinary index scans, some types of index may wish to support &lt;em&gt;parallel index scans&lt;/em&gt;, which allow multiple backends to cooperate in performing an index scan. The index access method should arrange things so that each cooperating process returns a subset of the tuples that would be performed by an ordinary, non-parallel index scan, but in such a way that the union of those subsets is equal to the set of tuples that would be returned by an ordinary, non-parallel index scan. Furthermore, while there need not be any global ordering of tuples returned by a parallel scan, the ordering of that subset of tuples returned within each cooperating backend must match the requested ordering. The following functions may be implemented to support parallel index scans:</source>
          <target state="translated">除了支持普通索引扫描外，某些类型的索引可能还希望支持&lt;em&gt;并行索引扫描&lt;/em&gt;，这允许多个后端配合执行索引扫描。索引访问方法应该安排事情，以便每个合作进程都返回元组的子集，该子集将通过普通的非并行索引扫描执行，但方式是这些子集的并集等于元组集合将由普通的非并行索引扫描返回。此外，尽管并行扫描不需要返回任何元组的全局顺序，但是在每个协作后端内返回的元组子集的顺序必须与请求的顺序匹配。可以实现以下功能以支持并行索引扫描：</target>
        </trans-unit>
        <trans-unit id="2240e6efaaf6aaec400aa311d695b65a5cb9013d" translate="yes" xml:space="preserve">
          <source>In addition to table and row locks, page-level share/exclusive locks are used to control read/write access to table pages in the shared buffer pool. These locks are released immediately after a row is fetched or updated. Application developers normally need not be concerned with page-level locks, but they are mentioned here for completeness.</source>
          <target state="translated">除了表和行锁,页级共享/独占锁用于控制对共享缓冲池中表页的读/写访问。这些锁在行被获取或更新后立即被释放。应用开发者通常不需要关注页级锁,但为了完整起见,这里还是提到了页级锁。</target>
        </trans-unit>
        <trans-unit id="87509ac7479eedd6c62071274770036abf56ee4c" translate="yes" xml:space="preserve">
          <source>In addition to table-level locks, there are row-level locks, which are listed as below with the contexts in which they are used automatically by PostgreSQL. See &lt;a href=&quot;explicit-locking#ROW-LOCK-COMPATIBILITY&quot;&gt;Table 13.3&lt;/a&gt; for a complete table of row-level lock conflicts. Note that a transaction can hold conflicting locks on the same row, even in different subtransactions; but other than that, two transactions can never hold conflicting locks on the same row. Row-level locks do not affect data querying; they block only &lt;em&gt;writers and lockers&lt;/em&gt; to the same row.</source>
          <target state="translated">除了表级别的锁，还有行级别的锁，下面列出了这些级别的锁以及PostgreSQL自动使用它们的上下文。有关行级锁冲突的完整表，请&lt;a href=&quot;explicit-locking#ROW-LOCK-COMPATIBILITY&quot;&gt;参见表13.3&lt;/a&gt;。请注意，即使在不同的子事务中，事务也可以在同一行上持有冲突的锁。但是除此之外，两个事务永远不能在同一行上持有冲突的锁。行级锁不影响数据查询。它们仅将&lt;em&gt;作家和储物柜&lt;/em&gt;阻止到同一行。</target>
        </trans-unit>
        <trans-unit id="af43dbc6cfa4c0067d413cdf9c6cdab394d34e58" translate="yes" xml:space="preserve">
          <source>In addition to table-level locks, there are row-level locks, which are listed as below with the contexts in which they are used automatically by PostgreSQL. See &lt;a href=&quot;explicit-locking#ROW-LOCK-COMPATIBILITY&quot;&gt;Table 13.3&lt;/a&gt; for a complete table of row-level lock conflicts. Note that a transaction can hold conflicting locks on the same row, even in different subtransactions; but other than that, two transactions can never hold conflicting locks on the same row. Row-level locks do not affect data querying; they block only &lt;em&gt;writers and lockers&lt;/em&gt; to the same row. Row-level locks are released at transaction end or during savepoint rollback, just like table-level locks.</source>
          <target state="translated">除表级锁外，还有行级锁，下面列出了这些行级锁以及PostgreSQL自动使用它们的上下文。有关行级锁冲突的完整表，请&lt;a href=&quot;explicit-locking#ROW-LOCK-COMPATIBILITY&quot;&gt;参见表13.3&lt;/a&gt;。请注意，即使在不同的子事务中，事务也可以在同一行上持有冲突的锁。但是除此之外，两个事务永远不能在同一行上持有冲突的锁。行级锁不影响数据查询。它们仅将&lt;em&gt;作家和储物柜&lt;/em&gt;阻止到同一行。行级锁在事务结束时或在保存点回滚期间释放，就像表级锁一样。</target>
        </trans-unit>
        <trans-unit id="eefa082a90a01551ee9f7be83fe0ecef6e330ce1" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;postgresql.conf&lt;/code&gt; file already mentioned, PostgreSQL uses two other manually-edited configuration files, which control client authentication (their use is discussed in &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;). By default, all three configuration files are stored in the database cluster's data directory. The parameters described in this section allow the configuration files to be placed elsewhere. (Doing so can ease administration. In particular it is often easier to ensure that the configuration files are properly backed-up when they are kept separate.)</source>
          <target state="translated">除了已经提到的 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件之外，PostgreSQL还使用其他两个手动编辑的配置文件来控制客户端身份验证（在&lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;第20章中&lt;/a&gt;讨论了它们的用法）。默认情况下，所有三个配置文件都存储在数据库集群的数据目录中。本节中描述的参数允许将配置文件放置在其他位置。 （这样做可以简化管理。尤其是，将配置文件分开存放时，通常更容易确保正确备份它们。）</target>
        </trans-unit>
        <trans-unit id="c048077d9e3551a271c60d45220784829e1b676a" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;postgresql.conf&lt;/code&gt; file already mentioned, PostgreSQL uses two other manually-edited configuration files, which control client authentication (their use is discussed in &lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;). By default, all three configuration files are stored in the database cluster's data directory. The parameters described in this section allow the configuration files to be placed elsewhere. (Doing so can ease administration. In particular it is often easier to ensure that the configuration files are properly backed-up when they are kept separate.)</source>
          <target state="translated">除了已经提到的 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件之外，PostgreSQL还使用其他两个手动编辑的配置文件来控制客户端身份验证（在&lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;第20章中&lt;/a&gt;讨论了它们的用法）。默认情况下，所有三个配置文件都存储在数据库集群的数据目录中。本节中描述的参数允许将配置文件放置在其他位置。（这样做可以简化管理。特别是，通常更容易确保将它们分开保存时正确备份配置文件。）</target>
        </trans-unit>
        <trans-unit id="06a5b24df3b5e27969bb36917a3a17ae8bb1189b" translate="yes" xml:space="preserve">
          <source>In addition to the SQL-standard &lt;a href=&quot;ddl-priv&quot;&gt;privilege system&lt;/a&gt; available through &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt;, tables can have &lt;em&gt;row security policies&lt;/em&gt; that restrict, on a per-user basis, which rows can be returned by normal queries or inserted, updated, or deleted by data modification commands. This feature is also known as &lt;em&gt;Row-Level Security&lt;/em&gt;. By default, tables do not have any policies, so that if a user has access privileges to a table according to the SQL privilege system, all rows within it are equally available for querying or updating.</source>
          <target state="translated">除了可通过&lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt;使用的SQL标准&lt;a href=&quot;ddl-priv&quot;&gt;特权系统外&lt;/a&gt;，表还可以具有&lt;em&gt;行安全性策略&lt;/em&gt;，这些&lt;em&gt;安全性策略&lt;/em&gt;可按用户限制哪些行可以由普通查询返回，也可以由数据修改命令插入，更新或删除。此功能也称为&lt;em&gt;行级安全性&lt;/em&gt;。默认情况下，表没有任何策略，因此，如果用户根据SQL特权系统具有对表的访问特权，则该表中的所有行均可供查询或更新。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d446f6389cb4793dfefdac41ed8ee8243d8cf0f3" translate="yes" xml:space="preserve">
          <source>In addition to the above operators, the usual comparison operators shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;Table 9.1&lt;/a&gt; are available for type &lt;code&gt;cube&lt;/code&gt;. These operators first compare the first coordinates, and if those are equal, compare the second coordinates, etc. They exist mainly to support the b-tree index operator class for &lt;code&gt;cube&lt;/code&gt;, which can be useful for example if you would like a UNIQUE constraint on a &lt;code&gt;cube&lt;/code&gt; column. Otherwise, this ordering is not of much practical use.</source>
          <target state="translated">除了上述运算符外，&lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;表9.1&lt;/a&gt;中所示的常规比较运算符还可用于 &lt;code&gt;cube&lt;/code&gt; 类型。这些运算符首先比较第一个坐标，如果相等，则比较第二个坐标，依此类推。它们的存在主要是为了支持 &lt;code&gt;cube&lt;/code&gt; 的b树索引运算符类，例如，如果您希望对一个 &lt;code&gt;cube&lt;/code&gt; 列。否则，这种排序没有太大的实际用途。</target>
        </trans-unit>
        <trans-unit id="3a9f075e58ee1768924e20835361c077d43e9c97" translate="yes" xml:space="preserve">
          <source>In addition to the above operators, the usual comparison operators shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;Table 9.1&lt;/a&gt; are available for type &lt;code&gt;seg&lt;/code&gt;. These operators first compare (a) to (c), and if these are equal, compare (b) to (d). That results in reasonably good sorting in most cases, which is useful if you want to use ORDER BY with this type.</source>
          <target state="translated">除了上述运算符外，&lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;表9.1&lt;/a&gt;中所示的常规比较运算符还可用于 &lt;code&gt;seg&lt;/code&gt; 类型。这些运算符首先将（a）与（c）相比较，如果相等，则将（b）与（d）相比较。在大多数情况下，这会导致合理的排序，如果要将此类型与ORDER BY一起使用，则很有用。</target>
        </trans-unit>
        <trans-unit id="58a68bf9280d646b1a85ebb074d2b6ecfecda3df" translate="yes" xml:space="preserve">
          <source>In addition to the format specifiers described above, the special sequence &lt;code&gt;%%&lt;/code&gt; may be used to output a literal &lt;code&gt;%&lt;/code&gt; character.</source>
          <target state="translated">除上述格式说明符外，特殊序列 &lt;code&gt;%%&lt;/code&gt; 可用于输出文字 &lt;code&gt;%&lt;/code&gt; 字符。</target>
        </trans-unit>
        <trans-unit id="8bfea922b7478af1fb30846a7ffdd145169e7fe7" translate="yes" xml:space="preserve">
          <source>In addition to the functions listed in this section, there are a number of functions related to the statistics system that also provide system information. See &lt;a href=&quot;monitoring-stats#MONITORING-STATS-VIEWS&quot;&gt;Section 27.2.2&lt;/a&gt; for more information.</source>
          <target state="translated">除了本节中列出的功能外，还有许多与统计系统有关的功能，这些功能还提供系统信息。有关更多信息，请参见&lt;a href=&quot;monitoring-stats#MONITORING-STATS-VIEWS&quot;&gt;第27.2.2节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2dc53d9aa025a55feab0c728607a475dd6480573" translate="yes" xml:space="preserve">
          <source>In addition to the generic lookup mechanisms, there is a special convention that &lt;code&gt;PGNSP&lt;/code&gt; is replaced by the OID of the &lt;code&gt;pg_catalog&lt;/code&gt; schema, and &lt;code&gt;PGUID&lt;/code&gt; is replaced by the OID of the bootstrap superuser role. These usages are somewhat historical but so far there hasn't been a need to generalize them.</source>
          <target state="translated">除了通用的查找机制外，还有一个特殊约定，即 &lt;code&gt;PGNSP&lt;/code&gt; 被 &lt;code&gt;pg_catalog&lt;/code&gt; 模式的OID替换，而 &lt;code&gt;PGUID&lt;/code&gt; 被引导超级用户角色的OID替换。这些用法有些历史性，但到目前为止，没有必要将其概括。</target>
        </trans-unit>
        <trans-unit id="671caebf932d9cdddfa02cea4a21319996df3fc1" translate="yes" xml:space="preserve">
          <source>In addition to the main syntax described above, there are some special forms and miscellaneous syntactic facilities available.</source>
          <target state="translated">除了上述主要语法外,还有一些特殊形式和杂项语法设施可供选择。</target>
        </trans-unit>
        <trans-unit id="cfdcb8c233fbe99bb0dea34235cb119f257b9a78" translate="yes" xml:space="preserve">
          <source>In addition to the method-specific options listed below, there is one method-independent authentication option &lt;code&gt;clientcert&lt;/code&gt;, which can be specified in any &lt;code&gt;hostssl&lt;/code&gt; record. This option can be set to &lt;code&gt;verify-ca&lt;/code&gt; or &lt;code&gt;verify-full&lt;/code&gt;. Both options require the client to present a valid (trusted) SSL certificate, while &lt;code&gt;verify-full&lt;/code&gt; additionally enforces that the &lt;code&gt;cn&lt;/code&gt; (Common Name) in the certificate matches the username or an applicable mapping. This behavior is similar to the &lt;code&gt;cert&lt;/code&gt; authentication method (see &lt;a href=&quot;auth-cert&quot;&gt;Section 20.12&lt;/a&gt;) but enables pairing the verification of client certificates with any authentication method that supports &lt;code&gt;hostssl&lt;/code&gt; entries.</source>
          <target state="translated">除了下面列出的特定于方法的选项之外，还有一个与方法无关的身份验证选项 &lt;code&gt;clientcert&lt;/code&gt; ，可以在任何 &lt;code&gt;hostssl&lt;/code&gt; 记录中指定该选项。可以将此选项设置为 &lt;code&gt;verify-ca&lt;/code&gt; 或 &lt;code&gt;verify-full&lt;/code&gt; 。这两个选项均要求客户端出示有效（可信）的SSL证书，而 &lt;code&gt;verify-full&lt;/code&gt; 则另外强制证书中的 &lt;code&gt;cn&lt;/code&gt; （公用名）与用户名或适用的映射相匹配。此行为类似于 &lt;code&gt;cert&lt;/code&gt; 身份验证方法（请参阅&lt;a href=&quot;auth-cert&quot;&gt;第20.12节&lt;/a&gt;），但可以将客户端证书的验证与任何支持 &lt;code&gt;hostssl&lt;/code&gt; 的身份验证方法配对 条目。</target>
        </trans-unit>
        <trans-unit id="ddf91010c34fa3b26374dd73b3df519e9da0fd2a" translate="yes" xml:space="preserve">
          <source>In addition to the operators shown in the table, the ordinary B-tree comparison operators (&lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, etc) are defined for types &lt;code&gt;tsvector&lt;/code&gt; and &lt;code&gt;tsquery&lt;/code&gt;. These are not very useful for text searching but allow, for example, unique indexes to be built on columns of these types.</source>
          <target state="translated">除了表中所示的运算符外，还为 &lt;code&gt;tsvector&lt;/code&gt; 和 &lt;code&gt;tsquery&lt;/code&gt; 类型定义了普通的B树比较运算符（ &lt;code&gt;=&lt;/code&gt; ， &lt;code&gt;&amp;lt;&lt;/code&gt; 等）。这些对于文本搜索不是很有用，但是例如允许在这些类型的列上构建唯一索引。</target>
        </trans-unit>
        <trans-unit id="31c46db92025ad200f49ee2517827b67ca69ce01" translate="yes" xml:space="preserve">
          <source>In addition to the socket file itself, which is named &lt;code&gt;.s.PGSQL.nnnn&lt;/code&gt; where &lt;code&gt;nnnn&lt;/code&gt; is the server's port number, an ordinary file named &lt;code&gt;.s.PGSQL.nnnn.lock&lt;/code&gt; will be created in each of the &lt;code&gt;unix_socket_directories&lt;/code&gt; directories. Neither file should ever be removed manually.</source>
          <target state="translated">除了名为 &lt;code&gt;.s.PGSQL.nnnn&lt;/code&gt; 的套接字文件本身（其中 &lt;code&gt;nnnn&lt;/code&gt; 是服务器的端口号）之外，还将在每个 &lt;code&gt;unix_socket_directories&lt;/code&gt; 目录中创建一个名为 &lt;code&gt;.s.PGSQL.nnnn.lock&lt;/code&gt; 的普通文件。都不应该手动删除这两个文件。</target>
        </trans-unit>
        <trans-unit id="f961899526c4ec4b91a471972a05e3809476d8c4" translate="yes" xml:space="preserve">
          <source>In addition to the system catalogs, PostgreSQL provides a number of built-in views. Some system views provide convenient access to some commonly used queries on the system catalogs. Other views provide access to internal server state.</source>
          <target state="translated">除了系统目录,PostgreSQL还提供了一些内置的视图。一些系统视图提供了对系统目录的一些常用查询的方便访问。其他视图则提供了对服务器内部状态的访问。</target>
        </trans-unit>
        <trans-unit id="3e99de7dbe2b503398057fb045bf3c995d4ba6e3" translate="yes" xml:space="preserve">
          <source>In addition to the timezone names and abbreviations, PostgreSQL will accept POSIX-style time zone specifications of the form &lt;code&gt;STD&lt;/code&gt;&lt;code&gt;offset&lt;/code&gt; or &lt;code&gt;STD&lt;/code&gt;&lt;code&gt;offset&lt;/code&gt;&lt;code&gt;DST&lt;/code&gt;, where &lt;code&gt;STD&lt;/code&gt; is a zone abbreviation, &lt;code&gt;offset&lt;/code&gt; is a numeric offset in hours west from UTC, and &lt;code&gt;DST&lt;/code&gt; is an optional daylight-savings zone abbreviation, assumed to stand for one hour ahead of the given offset. For example, if &lt;code&gt;EST5EDT&lt;/code&gt; were not already a recognized zone name, it would be accepted and would be functionally equivalent to United States East Coast time. In this syntax, a zone abbreviation can be a string of letters, or an arbitrary string surrounded by angle brackets (&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;). When a daylight-savings zone abbreviation is present, it is assumed to be used according to the same daylight-savings transition rules used in the IANA time zone database's &lt;code&gt;posixrules&lt;/code&gt; entry. In a standard PostgreSQL installation, &lt;code&gt;posixrules&lt;/code&gt; is the same as &lt;code&gt;US/Eastern&lt;/code&gt;, so that POSIX-style time zone specifications follow USA daylight-savings rules. If needed, you can adjust this behavior by replacing the &lt;code&gt;posixrules&lt;/code&gt; file.</source>
          <target state="translated">除时区名称和缩写外，PostgreSQL还将接受POSIX风格的时区规范，格式为 &lt;code&gt;STD&lt;/code&gt; &lt;code&gt;offset&lt;/code&gt; 或 &lt;code&gt;STD&lt;/code&gt; &lt;code&gt;offset&lt;/code&gt; &lt;code&gt;DST&lt;/code&gt; ，其中 &lt;code&gt;STD&lt;/code&gt; 是时区缩写， &lt;code&gt;offset&lt;/code&gt; 是距UTC时数小时的数字偏移，而 &lt;code&gt;DST&lt;/code&gt; 是可选的夏令时区缩写，假定比给定偏移量早一小时。例如，如果 &lt;code&gt;EST5EDT&lt;/code&gt; 尚不是公认的区域名称，它将被接受并且在功能上等同于美国东海岸时间。在此语法中，区域缩写可以是字母字符串，也可以是尖括号（ &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ）。如果存在夏令时缩写，则假定它是根据IANA时区数据库的 &lt;code&gt;posixrules&lt;/code&gt; 条目中使用的相同的夏令时转换规则来使用的。在标准PostgreSQL安装中， &lt;code&gt;posixrules&lt;/code&gt; 与 &lt;code&gt;US/Eastern&lt;/code&gt; 相同，因此POSIX风格的时区规范遵循美国夏令时规则。如果需要，可以通过替换 &lt;code&gt;posixrules&lt;/code&gt; 文件来调整此行为。</target>
        </trans-unit>
        <trans-unit id="fea3b58443a344cc0a50c8d3b3c320b181f8be81" translate="yes" xml:space="preserve">
          <source>In addition to the timezone names and abbreviations, PostgreSQL will accept POSIX-style time zone specifications, as described in &lt;a href=&quot;datetime-posix-timezone-specs&quot;&gt;Section B.5&lt;/a&gt;. This option is not normally preferable to using a named time zone, but it may be necessary if no suitable IANA time zone entry is available.</source>
          <target state="translated">除时区名称和缩写外，PostgreSQL将接受POSIX样式的时区规范，如&lt;a href=&quot;datetime-posix-timezone-specs&quot;&gt;B.5节&lt;/a&gt;所述。通常，此选项不是使用命名时区的首选，但如果没有合适的IANA时区条目可用，则可能有必要。</target>
        </trans-unit>
        <trans-unit id="5639f9b8e3c76507298cdef9442456212dc91a3a" translate="yes" xml:space="preserve">
          <source>In addition to the typical B-tree search operators, &lt;code&gt;btree_gist&lt;/code&gt; also provides index support for &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; (&amp;ldquo;not equals&amp;rdquo;). This may be useful in combination with an &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt;exclusion constraint&lt;/a&gt;, as described below.</source>
          <target state="translated">除了典型的B树搜索运算符外， &lt;code&gt;btree_gist&lt;/code&gt; 还为 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 提供索引支持（&amp;ldquo;不等于&amp;rdquo;）。如下所述，与&lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt;排除约束条件&lt;/a&gt;结合使用时可能很有用。</target>
        </trans-unit>
        <trans-unit id="b7456acfa95fcaf383cf25fda8119cc53ab8322a" translate="yes" xml:space="preserve">
          <source>In addition to the usual (&lt;em&gt;tight&lt;/em&gt;) RE syntax, in which all characters are significant, there is an &lt;em&gt;expanded&lt;/em&gt; syntax, available by specifying the embedded &lt;code&gt;x&lt;/code&gt; option. In the expanded syntax, white-space characters in the RE are ignored, as are all characters between a &lt;code&gt;#&lt;/code&gt; and the following newline (or the end of the RE). This permits paragraphing and commenting a complex RE. There are three exceptions to that basic rule:</source>
          <target state="translated">除了通常的（&lt;em&gt;严格&lt;/em&gt;）RE语法（其中所有字符均有效）之外，还有一种&lt;em&gt;扩展&lt;/em&gt;语法，可通过指定内嵌 &lt;code&gt;x&lt;/code&gt; 选项获得。在扩展语法中，将忽略RE中的空格字符，以及 &lt;code&gt;#&lt;/code&gt; 和以下换行符（或RE的末尾）之间的所有字符。这允许对复杂的RE进行段落和注释。该基本规则有三个例外：</target>
        </trans-unit>
        <trans-unit id="da522f31f6ebf1b8a6e0efd3ead6600864945861" translate="yes" xml:space="preserve">
          <source>In addition to these facilities borrowed from &lt;code&gt;LIKE&lt;/code&gt;, &lt;code&gt;SIMILAR TO&lt;/code&gt; supports these pattern-matching metacharacters borrowed from POSIX regular expressions:</source>
          <target state="translated">除了从 &lt;code&gt;LIKE&lt;/code&gt; 借用的这些功能之外， &lt;code&gt;SIMILAR TO&lt;/code&gt; 还支持从POSIX正则表达式借用的这些模式匹配元字符：</target>
        </trans-unit>
        <trans-unit id="d5ad168deb41cb8cd3104e11c297f4193822a79b" translate="yes" xml:space="preserve">
          <source>In addition to these functions, any built-in or user-defined general-purpose or statistical aggregate (i.e., not ordered-set or hypothetical-set aggregates) can be used as a window function; see &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.20&lt;/a&gt; for a list of the built-in aggregates. Aggregate functions act as window functions only when an &lt;code&gt;OVER&lt;/code&gt; clause follows the call; otherwise they act as non-window aggregates and return a single row for the entire set.</source>
          <target state="translated">除这些功能外，任何内置或用户定义的通用或统计聚合（即非有序集或假设集的聚合）都可以用作窗口函数；有关内置集合的列表，请参见&lt;a href=&quot;functions-aggregate&quot;&gt;第9.20节&lt;/a&gt;。仅当调用后有 &lt;code&gt;OVER&lt;/code&gt; 子句时，聚合函数才充当窗口函数。否则，它们将充当非窗口聚合，并为整个集合返回一行。</target>
        </trans-unit>
        <trans-unit id="ac449e0956beab252b7444b739cfec2b77010587" translate="yes" xml:space="preserve">
          <source>In addition to these functions, any built-in or user-defined ordinary aggregate (i.e., not ordered-set or hypothetical-set aggregates) can be used as a window function; see &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.21&lt;/a&gt; for a list of the built-in aggregates. Aggregate functions act as window functions only when an &lt;code&gt;OVER&lt;/code&gt; clause follows the call; otherwise they act as plain aggregates and return a single row for the entire set.</source>
          <target state="translated">除这些功能外，任何内置或用户定义的普通聚合（即非有序集或假设集的聚合）都可以用作窗口函数；有关内置聚合的列表，请参见&lt;a href=&quot;functions-aggregate&quot;&gt;第9.21节&lt;/a&gt;。仅当调用后有 &lt;code&gt;OVER&lt;/code&gt; 子句时，聚合函数才充当窗口函数。否则，它们将作为简单的聚合，并为整个集合返回一行。</target>
        </trans-unit>
        <trans-unit id="3b254c4c7b10faf7e76791fc77c4b40ffb55a623" translate="yes" xml:space="preserve">
          <source>In addition to these functions, the SQL &lt;code&gt;OVERLAPS&lt;/code&gt; operator is supported:</source>
          <target state="translated">除了这些功能之外，还支持SQL &lt;code&gt;OVERLAPS&lt;/code&gt; 运算符：</target>
        </trans-unit>
        <trans-unit id="8ce6df37789f3f1d085846c8faae3d98a71b95bb" translate="yes" xml:space="preserve">
          <source>In addition to these specialized operators, the usual comparison operators shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;Table 9.1&lt;/a&gt; are available for types &lt;code&gt;tsvector&lt;/code&gt; and &lt;code&gt;tsquery&lt;/code&gt;. These are not very useful for text searching but allow, for example, unique indexes to be built on columns of these types.</source>
          <target state="translated">除了这些专门的运算符外，&lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;表9.1&lt;/a&gt;中所示的常规比较运算符可用于 &lt;code&gt;tsvector&lt;/code&gt; 和 &lt;code&gt;tsquery&lt;/code&gt; 类型。这些对于文本搜索不是很有用，但是例如允许在这些类型的列上构建唯一索引。</target>
        </trans-unit>
        <trans-unit id="918debfa135a3ee3b32c08e005bfe3898a987217" translate="yes" xml:space="preserve">
          <source>In addition to this list, there are a number of constructs that can be classified as an expression but do not follow any general syntax rules. These generally have the semantics of a function or operator and are explained in the appropriate location in &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;Chapter 9&lt;/a&gt;. An example is the &lt;code&gt;IS NULL&lt;/code&gt; clause.</source>
          <target state="translated">除此列表外，还有许多可归类为表达式但不遵循任何常规语法规则的构造。这些通常具有函数或运算符的语义，并在&lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;第9章&lt;/a&gt;的适当位置进行了说明。一个示例是 &lt;code&gt;IS NULL&lt;/code&gt; 子句。</target>
        </trans-unit>
        <trans-unit id="81a1f6a58eced1ed99e15fcd136cfd9bbcd242dd" translate="yes" xml:space="preserve">
          <source>In addition to this list, there are a number of constructs that can be classified as an expression but do not follow any general syntax rules. These generally have the semantics of a function or operator and are explained in the appropriate location in &lt;a href=&quot;https://www.postgresql.org/docs/13/functions.html&quot;&gt;Chapter 9&lt;/a&gt;. An example is the &lt;code&gt;IS NULL&lt;/code&gt; clause.</source>
          <target state="translated">除了此列表外，还有许多可归类为表达式但不遵循任何常规语法规则的构造。这些通常具有函数或运算符的语义，并在&lt;a href=&quot;https://www.postgresql.org/docs/13/functions.html&quot;&gt;第9章&lt;/a&gt;的适当位置中进行了说明。一个示例是 &lt;code&gt;IS NULL&lt;/code&gt; 子句。</target>
        </trans-unit>
        <trans-unit id="1eea807026cd270d625f43d7ed3f99bcbf28a0f1" translate="yes" xml:space="preserve">
          <source>In addition, B-tree and hash indexes can be created for table columns of range types. For these index types, basically the only useful range operation is equality. There is a B-tree sort ordering defined for range values, with corresponding &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; operators, but the ordering is rather arbitrary and not usually useful in the real world. Range types' B-tree and hash support is primarily meant to allow sorting and hashing internally in queries, rather than creation of actual indexes.</source>
          <target state="translated">另外，可以为范围类型的表列创建B树索引和哈希索引。对于这些索引类型，基本上唯一有用的范围操作是相等。对于范围值定义了B树排序顺序，并带有相应的 &lt;code&gt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&lt;/code&gt; 运算符，但是该顺序相当随意，通常在现实世界中没有用。范围类型的B树和哈希支持主要是为了允许在查询中进行内部排序和哈希，而不是创建实际索引。</target>
        </trans-unit>
        <trans-unit id="ec168afc08cf14d67db79d5a556441966649b178" translate="yes" xml:space="preserve">
          <source>In addition, GIN must have a way to sort the key values stored in the index. The operator class can define the sort ordering by specifying a comparison method:</source>
          <target state="translated">此外,GIN必须有一种方法对存储在索引中的键值进行排序。操作员类可以通过指定比较方法来定义排序顺序。</target>
        </trans-unit>
        <trans-unit id="9f602065328e166c6745869bc0a8f779ad09a07b" translate="yes" xml:space="preserve">
          <source>In addition, PostgreSQL provides the &lt;code&gt;text&lt;/code&gt; type, which stores strings of any length. Although the type &lt;code&gt;text&lt;/code&gt; is not in the SQL standard, several other SQL database management systems have it as well.</source>
          <target state="translated">另外，PostgreSQL提供了 &lt;code&gt;text&lt;/code&gt; 类型，可以存储任意长度的字符串。尽管类型 &lt;code&gt;text&lt;/code&gt; 不在SQL标准中，但其他几种SQL数据库管理系统也具有它。</target>
        </trans-unit>
        <trans-unit id="17853e1fa32c480ecb510d4ac68c8ac2c772dace" translate="yes" xml:space="preserve">
          <source>In addition, a &lt;code&gt;cube&lt;/code&gt; GiST index can be used to find nearest neighbors using the metric operators &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;#&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; in &lt;code&gt;ORDER BY&lt;/code&gt; clauses. For example, the nearest neighbor of the 3-D point (0.5, 0.5, 0.5) could be found efficiently with:</source>
          <target state="translated">另外， &lt;code&gt;cube&lt;/code&gt; GiST索引可用于在 &lt;code&gt;ORDER BY&lt;/code&gt; 子句中使用度量运算符 &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;#&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 来查找最近的邻居。例如，可以有效地找到3-D点的最近邻点（0.5、0.5、0.5）：</target>
        </trans-unit>
        <trans-unit id="cd5ace0daf0d94ba630977ad9ab486e9b148c9ae" translate="yes" xml:space="preserve">
          <source>In addition, any range type that is meant to be used with GiST or SP-GiST indexes should define a subtype difference, or &lt;code&gt;subtype_diff&lt;/code&gt;, function. (The index will still work without &lt;code&gt;subtype_diff&lt;/code&gt;, but it is likely to be considerably less efficient than if a difference function is provided.) The subtype difference function takes two input values of the subtype, and returns their difference (i.e., &lt;code&gt;X&lt;/code&gt; minus &lt;code&gt;Y&lt;/code&gt;) represented as a &lt;code&gt;float8&lt;/code&gt; value. In our example above, the function &lt;code&gt;float8mi&lt;/code&gt; that underlies the regular &lt;code&gt;float8&lt;/code&gt; minus operator can be used; but for any other subtype, some type conversion would be necessary. Some creative thought about how to represent differences as numbers might be needed, too. To the greatest extent possible, the &lt;code&gt;subtype_diff&lt;/code&gt; function should agree with the sort ordering implied by the selected operator class and collation; that is, its result should be positive whenever its first argument is greater than its second according to the sort ordering.</source>
          <target state="translated">此外，任何打算与GiST或SP-GiST索引一起使用的范围类型都应定义一个子类型差异或 &lt;code&gt;subtype_diff&lt;/code&gt; 函数。 （该索引在没有 &lt;code&gt;subtype_diff&lt;/code&gt; 的情况下仍然可以工作，但是它的效率可能比提供差函数的效率低得多。）子类型差函数接受子类型的两个输入值，并返回它们的差（即 &lt;code&gt;X&lt;/code&gt; 减 &lt;code&gt;Y&lt;/code&gt; ）。表示为 &lt;code&gt;float8&lt;/code&gt; 值。在上面的示例中，函数 &lt;code&gt;float8mi&lt;/code&gt; 是常规 &lt;code&gt;float8&lt;/code&gt; 的基础可以使用减号运算符；但对于任何其他子类型，则需要某种类型转换。也可能需要一些关于如何将差异表示为数字的创造性思考。到可能的最大程度时， &lt;code&gt;subtype_diff&lt;/code&gt; 函数应该与由所选择的算类和整理隐含的排序顺序同意; 也就是说，根据排序顺序，只要第一个参数大于第二个参数，其结果就应该为正。</target>
        </trans-unit>
        <trans-unit id="f89a62ed614652316ac7f29133e1961a27612ba6" translate="yes" xml:space="preserve">
          <source>In addition, it is possible to cast integral values to and from type &lt;code&gt;bit&lt;/code&gt;. Casting an integer to &lt;code&gt;bit(n)&lt;/code&gt; copies the rightmost &lt;code&gt;n&lt;/code&gt; bits. Casting an integer to a bit string width wider than the integer itself will sign-extend on the left. Some examples:</source>
          <target state="translated">另外，可以将整数值与 &lt;code&gt;bit&lt;/code&gt; 类型强制转换。将整数转换为 &lt;code&gt;bit(n)&lt;/code&gt; 会复制最右边的 &lt;code&gt;n&lt;/code&gt; 位。将整数强制转换为比整数本身宽的位字符串宽度将在左侧符号扩展。一些例子：</target>
        </trans-unit>
        <trans-unit id="64cf011fc0c858e7c59c2382a3c5f7cd4046f0f4" translate="yes" xml:space="preserve">
          <source>In addition, it is possible to cast integral values to and from type &lt;code&gt;bit&lt;/code&gt;. Some examples:</source>
          <target state="translated">另外，可以将整数值与 &lt;code&gt;bit&lt;/code&gt; 类型强制转换。一些例子：</target>
        </trans-unit>
        <trans-unit id="326abf040e9ce0b0f36784412502b6466458ab9f" translate="yes" xml:space="preserve">
          <source>In addition, the following functions are available to produce analogous mappings of entire schemas or the entire current database:</source>
          <target state="translated">此外,以下函数可用于生成整个模式或整个当前数据库的类似映射。</target>
        </trans-unit>
        <trans-unit id="63461f5526d594ea86f45b63caca8ffcfa146455" translate="yes" xml:space="preserve">
          <source>In addition, the system must not be running in single-user mode. Since the entire database system is running in single process in this situation, no background workers will be available.</source>
          <target state="translated">此外,系统不能以单用户模式运行。因为在这种情况下,整个数据库系统都是在单进程中运行,所以不会有后台工作者。</target>
        </trans-unit>
        <trans-unit id="860432a001dab9d2b568ed0f1f81316664226bda" translate="yes" xml:space="preserve">
          <source>In addition, the system view &lt;a href=&quot;view-pg-settings&quot;&gt;&lt;code&gt;pg_settings&lt;/code&gt;&lt;/a&gt; can be used to view and change session-local values:</source>
          <target state="translated">另外，系统视图&lt;a href=&quot;view-pg-settings&quot;&gt; &lt;code&gt;pg_settings&lt;/code&gt; &lt;/a&gt;可用于查看和更改会话本地值：</target>
        </trans-unit>
        <trans-unit id="22f9e194dfe6bf7349c8ee21bf8580964a36a952" translate="yes" xml:space="preserve">
          <source>In addition, triggers may be defined to fire for &lt;code&gt;TRUNCATE&lt;/code&gt;, though only &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt;.</source>
          <target state="translated">此外，可以将触发器定义为针对 &lt;code&gt;TRUNCATE&lt;/code&gt; 触发，尽管仅针对 &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4414e8f828cfe6654891bf2913265775446349f" translate="yes" xml:space="preserve">
          <source>In addition, when the data in the referenced columns is changed, certain actions are performed on the data in this table's columns. The &lt;code&gt;ON DELETE&lt;/code&gt; clause specifies the action to perform when a referenced row in the referenced table is being deleted. Likewise, the &lt;code&gt;ON UPDATE&lt;/code&gt; clause specifies the action to perform when a referenced column in the referenced table is being updated to a new value. If the row is updated, but the referenced column is not actually changed, no action is done. Referential actions other than the &lt;code&gt;NO ACTION&lt;/code&gt; check cannot be deferred, even if the constraint is declared deferrable. There are the following possible actions for each clause:</source>
          <target state="translated">另外，当更改引用列中的数据时，将对该表的列中的数据执行某些操作。的 &lt;code&gt;ON DELETE&lt;/code&gt; 子句指定动作时在参考表中的参考行要被删除的执行。同样， &lt;code&gt;ON UPDATE&lt;/code&gt; 子句指定在将引用表中的引用列更新为新值时执行的操作。如果该行已更新，但所引用的列实际上未更改，则不会执行任何操作。即使约束被声明为可延迟的，也不能延迟 &lt;code&gt;NO ACTION&lt;/code&gt; 检查以外的引用动作。每个子句有以下可能的操作：</target>
        </trans-unit>
        <trans-unit id="1b40467991cf35c44406fccb1f30c153b6ab6d3c" translate="yes" xml:space="preserve">
          <source>In addition, you can define your own range types; see &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt; for more information.</source>
          <target state="translated">另外，您可以定义自己的范围类型。有关更多信息，请参见&lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b2973b0fbaf7ec1930d4939e2d5982623781db68" translate="yes" xml:space="preserve">
          <source>In addition, you can find rows where the array has all values equal to 10000 with:</source>
          <target state="translated">此外,你可以用以下方法找到数组中所有值都等于10000的行。</target>
        </trans-unit>
        <trans-unit id="0f950ca6f038e5a1c55d020b4e0e3f34ce9c10d7" translate="yes" xml:space="preserve">
          <source>In all binary operations on differently-dimensioned cubes, I assume the lower-dimensional one to be a Cartesian projection, i. e., having zeroes in place of coordinates omitted in the string representation. The above examples are equivalent to:</source>
          <target state="translated">在所有对不同维度立方体的二进制运算中,我假设低维度的那个是笛卡尔投影,即在字符串表示中省略了坐标的位置有零。以上例子相当于。</target>
        </trans-unit>
        <trans-unit id="c1f9a66372442ec0201db0ed9f98b148d01d359a" translate="yes" xml:space="preserve">
          <source>In all but the simplest applications, there are various combinations of indexes that might be useful, and the database developer must make trade-offs to decide which indexes to provide. Sometimes multicolumn indexes are best, but sometimes it's better to create separate indexes and rely on the index-combination feature. For example, if your workload includes a mix of queries that sometimes involve only column &lt;code&gt;x&lt;/code&gt;, sometimes only column &lt;code&gt;y&lt;/code&gt;, and sometimes both columns, you might choose to create two separate indexes on &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, relying on index combination to process the queries that use both columns. You could also create a multicolumn index on &lt;code&gt;(x, y)&lt;/code&gt;. This index would typically be more efficient than index combination for queries involving both columns, but as discussed in &lt;a href=&quot;indexes-multicolumn&quot;&gt;Section 11.3&lt;/a&gt;, it would be almost useless for queries involving only &lt;code&gt;y&lt;/code&gt;, so it should not be the only index. A combination of the multicolumn index and a separate index on &lt;code&gt;y&lt;/code&gt; would serve reasonably well. For queries involving only &lt;code&gt;x&lt;/code&gt;, the multicolumn index could be used, though it would be larger and hence slower than an index on &lt;code&gt;x&lt;/code&gt; alone. The last alternative is to create all three indexes, but this is probably only reasonable if the table is searched much more often than it is updated and all three types of query are common. If one of the types of query is much less common than the others, you'd probably settle for creating just the two indexes that best match the common types.</source>
          <target state="translated">在除最简单的应用程序之外的所有应用程序中，都有各种可能有用的索引组合，并且数据库开发人员必须权衡取舍才能确定要提供的索引。有时候多列索引是最好的，但是有时候创建单独的索引并依靠索引组合功能会更好。例如，如果您的工作负载包含有时仅涉及 &lt;code&gt;x&lt;/code&gt; 列，有时仅涉及 &lt;code&gt;y&lt;/code&gt; 列以及有时同时涉及两列的查询的混合，则您可以选择在 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 上创建两个单独的索引，依靠索引组合来处理那些同时使用两列。您还可以在 &lt;code&gt;(x, y)&lt;/code&gt; 上创建多列索引。对于涉及两个列的查询，此索引通常比索引组合更有效，但是如&lt;a href=&quot;indexes-multicolumn&quot;&gt;第11.3节所述&lt;/a&gt;，对于仅涉及 &lt;code&gt;y&lt;/code&gt; 的查询，它几乎是无用的，因此它不应是唯一的索引。将多列索引和 &lt;code&gt;y&lt;/code&gt; 上的单独索引结合起来可以很好地发挥作用。对于仅涉及 &lt;code&gt;x&lt;/code&gt; 的查询，可以使用多列索引，尽管它比 &lt;code&gt;x&lt;/code&gt; 上的索引更大，因此也较慢单独。最后一种选择是创建所有三个索引，但这仅在表搜索的次数比表更新的次数多并且所有三种查询都通用的情况下才可能是合理的。如果其中一种查询类型比其他查询类型少得多，那么您可能会选择只创建两个与通用类型最匹配的索引。</target>
        </trans-unit>
        <trans-unit id="56df2ff3801249dc12f58c24112c401131ecca16" translate="yes" xml:space="preserve">
          <source>In all cases, a &lt;code&gt;pg_depend&lt;/code&gt; entry indicates that the referenced object cannot be dropped without also dropping the dependent object. However, there are several subflavors identified by &lt;code&gt;deptype&lt;/code&gt;:</source>
          <target state="translated">在所有情况下， &lt;code&gt;pg_depend&lt;/code&gt; 条目指示在不删除依赖对象的情况下不能删除引用对象。但是，有一些由 &lt;code&gt;deptype&lt;/code&gt; 标识的子风味：</target>
        </trans-unit>
        <trans-unit id="05533c0a7856fcfbbc14bb309ca83a1575bf0034" translate="yes" xml:space="preserve">
          <source>In all cases, a &lt;code&gt;pg_shdepend&lt;/code&gt; entry indicates that the referenced object cannot be dropped without also dropping the dependent object. However, there are several subflavors identified by &lt;code&gt;deptype&lt;/code&gt;:</source>
          <target state="translated">在所有情况下， &lt;code&gt;pg_shdepend&lt;/code&gt; 条目指示在不删除依赖对象的情况下不能删除引用对象。但是，有一些由 &lt;code&gt;deptype&lt;/code&gt; 标识的子风味：</target>
        </trans-unit>
        <trans-unit id="dbd9abe4557bc81e394c2c9fabde17d6899807f9" translate="yes" xml:space="preserve">
          <source>In all cases, the &lt;code&gt;Gather&lt;/code&gt; or &lt;code&gt;Gather Merge&lt;/code&gt; node will have exactly one child plan, which is the portion of the plan that will be executed in parallel. If the &lt;code&gt;Gather&lt;/code&gt; or &lt;code&gt;Gather Merge&lt;/code&gt; node is at the very top of the plan tree, then the entire query will execute in parallel. If it is somewhere else in the plan tree, then only the portion of the plan below it will run in parallel. In the example above, the query accesses only one table, so there is only one plan node other than the &lt;code&gt;Gather&lt;/code&gt; node itself; since that plan node is a child of the &lt;code&gt;Gather&lt;/code&gt; node, it will run in parallel.</source>
          <target state="translated">在所有情况下，&amp;ldquo; &lt;code&gt;Gather&lt;/code&gt; 或&amp;ldquo; &lt;code&gt;Gather Merge&lt;/code&gt; 节点将只具有一个子计划，这是将并行执行的计划的一部分。如果&amp;ldquo; &lt;code&gt;Gather&lt;/code&gt; 或&amp;ldquo; &lt;code&gt;Gather Merge&lt;/code&gt; 节点位于计划树的最顶部，则整个查询将并行执行。如果它在计划树中的其他位置，则仅计划下方的部分会并行运行。在上面的示例中，查询仅访问一个表，因此除 &lt;code&gt;Gather&lt;/code&gt; 节点本身外，仅存在一个计划节点。由于该计划节点是 &lt;code&gt;Gather&lt;/code&gt; 节点的子节点，因此它将并行运行。</target>
        </trans-unit>
        <trans-unit id="d4cf1068a339ca5023c2d3ccdb75130df4a1abc8" translate="yes" xml:space="preserve">
          <source>In all cases, the UTC offset associated with a timestamp can be specified explicitly, using either a numeric UTC offset or a time zone abbreviation that corresponds to a fixed UTC offset. The rule just given applies only when it is necessary to infer a UTC offset for a time zone in which the offset varies.</source>
          <target state="translated">在所有情况下,与时间戳相关的UTC偏移都可以明确指定,可以使用数字UTC偏移,也可以使用与固定UTC偏移相对应的时区缩写。刚刚给出的规则只适用于有必要推断出偏移量变化的时区的UTC偏移量时。</target>
        </trans-unit>
        <trans-unit id="14ea16f2c03b44cd074521f1c44532d0da377b9a" translate="yes" xml:space="preserve">
          <source>In all cases, timezone names and abbreviations are recognized case-insensitively. (This is a change from PostgreSQL versions prior to 8.2, which were case-sensitive in some contexts but not others.)</source>
          <target state="translated">在所有情况下,时区名称和缩写都是不区分大小写的。(这是8.2之前的PostgreSQL版本的一个变化,在某些情况下,PostgreSQL的版本是区分大小写的,而在其他情况下则不区分大小写)。</target>
        </trans-unit>
        <trans-unit id="e488767cd28888258245f00283eb8b0744ce50a3" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;ADD FUNCTION&lt;/code&gt; clause, the operand data type(s) the function is intended to support, if different from the input data type(s) of the function. For B-tree comparison functions and hash functions it is not necessary to specify &lt;code&gt;op_type&lt;/code&gt; since the function's input data type(s) are always the correct ones to use. For B-tree sort support functions and all functions in GiST, SP-GiST and GIN operator classes, it is necessary to specify the operand data type(s) the function is to be used with.</source>
          <target state="translated">在 &lt;code&gt;ADD FUNCTION&lt;/code&gt; 子句中，如果函数的输入数据类型不同，则该函数应支持的操作数数据类型。对于B树比较函数和哈希函数，不必指定 &lt;code&gt;op_type&lt;/code&gt; ,因为函数的输入数据类型始终是要使用的正确数据类型。对于B树排序支持功能以及GiST，SP-GiST和GIN运算符类中的所有功能，有必要指定要与该功能一起使用的操作数数据类型。</target>
        </trans-unit>
        <trans-unit id="6fcb4d0603695c9c5c79f801a2ccda42d2230338" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;ADD FUNCTION&lt;/code&gt; clause, the operand data type(s) the function is intended to support, if different from the input data type(s) of the function. For B-tree comparison functions and hash functions it is not necessary to specify &lt;code&gt;op_type&lt;/code&gt; since the function's input data type(s) are always the correct ones to use. For B-tree sort support functions, B-Tree equal image functions, and all functions in GiST, SP-GiST and GIN operator classes, it is necessary to specify the operand data type(s) the function is to be used with.</source>
          <target state="translated">在 &lt;code&gt;ADD FUNCTION&lt;/code&gt; 子句中，如果函数的输入数据类型不同，则该函数应支持的操作数数据类型。对于B树比较函数和哈希函数，不必指定 &lt;code&gt;op_type&lt;/code&gt; ,因为函数的输入数据类型始终是正确的使用类型。对于B树排序支持功能，B树相等的图像函数以及GiST，SP-GiST和GIN运算符类中的所有函数，必须指定要与该函数一起使用的操作数数据类型。</target>
        </trans-unit>
        <trans-unit id="fe60e9f5f727af57aa7582cb64633b2e4aa0e193" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;AFTER&lt;/code&gt; trigger, the &lt;code&gt;WHEN&lt;/code&gt; condition is evaluated just after the row update occurs, and it determines whether an event is queued to fire the trigger at the end of statement. So when an &lt;code&gt;AFTER&lt;/code&gt; trigger's &lt;code&gt;WHEN&lt;/code&gt; condition does not return true, it is not necessary to queue an event nor to re-fetch the row at end of statement. This can result in significant speedups in statements that modify many rows, if the trigger only needs to be fired for a few of the rows.</source>
          <target state="translated">在 &lt;code&gt;AFTER&lt;/code&gt; 触发器中，在行更新发生后立即评估 &lt;code&gt;WHEN&lt;/code&gt; 条件，它确定是否有事件在语句末尾排队触发触发器。因此，当 &lt;code&gt;AFTER&lt;/code&gt; 触发器的 &lt;code&gt;WHEN&lt;/code&gt; 条件未返回true时，就不必将事件排队，也不必在语句末尾重新获取该行。如果只需要为少数几行触发触发器，则可以大大提高修改多行的语句的速度。</target>
        </trans-unit>
        <trans-unit id="9e75cc4e94385e5f68a8354a430b322f15ebd9bc" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;INSERT&lt;/code&gt; command, if &lt;code&gt;ALWAYS&lt;/code&gt; is selected, a user-specified value is only accepted if the &lt;code&gt;INSERT&lt;/code&gt; statement specifies &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt;. If &lt;code&gt;BY DEFAULT&lt;/code&gt; is selected, then the user-specified value takes precedence. See &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt; for details. (In the &lt;code&gt;COPY&lt;/code&gt; command, user-specified values are always used regardless of this setting.)</source>
          <target state="translated">在 &lt;code&gt;INSERT&lt;/code&gt; 命令中，如果 &lt;code&gt;ALWAYS&lt;/code&gt; 选择，则仅当 &lt;code&gt;INSERT&lt;/code&gt; 语句指定 &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt; 时,才接受用户指定的值。如果选择&amp;ldquo;按 &lt;code&gt;BY DEFAULT&lt;/code&gt; 值&amp;rdquo;，则用户指定的值优先。有关详细信息，请参见&lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt;。（在 &lt;code&gt;COPY&lt;/code&gt; 命令中，无论此设置如何，始终使用用户指定的值。）</target>
        </trans-unit>
        <trans-unit id="14d94f7fbda5ba6b714c8d7012a6a4025037bb6e" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;INSERT&lt;/code&gt;, the data available to &lt;code&gt;RETURNING&lt;/code&gt; is the row as it was inserted. This is not so useful in trivial inserts, since it would just repeat the data provided by the client. But it can be very handy when relying on computed default values. For example, when using a &lt;a href=&quot;datatype-numeric#DATATYPE-SERIAL&quot;&gt;&lt;code&gt;serial&lt;/code&gt;&lt;/a&gt; column to provide unique identifiers, &lt;code&gt;RETURNING&lt;/code&gt; can return the ID assigned to a new row:</source>
          <target state="translated">在 &lt;code&gt;INSERT&lt;/code&gt; 中，可用于 &lt;code&gt;RETURNING&lt;/code&gt; 的数据是插入时所在的行。这在琐碎的插入中不是很有用，因为它只会重复客户端提供的数据。但是，在依赖于计算的默认值时，它会非常方便。例如，当使用&lt;a href=&quot;datatype-numeric#DATATYPE-SERIAL&quot;&gt; &lt;code&gt;serial&lt;/code&gt; &lt;/a&gt;列提供唯一标识符时， &lt;code&gt;RETURNING&lt;/code&gt; 可以返回分配给新行的ID：</target>
        </trans-unit>
        <trans-unit id="1b88536e851b3251cb15ede193475eddbb40caec" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;OPERATOR&lt;/code&gt; clause, the operand data type(s) of the operator, or &lt;code&gt;NONE&lt;/code&gt; to signify a left-unary or right-unary operator. The operand data types can be omitted in the normal case where they are the same as the operator class's data type.</source>
          <target state="translated">在 &lt;code&gt;OPERATOR&lt;/code&gt; 子句中，运算符的操作数数据类型，或 &lt;code&gt;NONE&lt;/code&gt; 表示左一元或右一元运算符。在正常情况下，与操作符类的数据类型相同时，可以省略操作数数据类型。</target>
        </trans-unit>
        <trans-unit id="3136757e2f5b87e470c589e7ef9c299933261292" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;OPERATOR&lt;/code&gt; clause, the operand data type(s) of the operator, or &lt;code&gt;NONE&lt;/code&gt; to signify a left-unary or right-unary operator. Unlike the comparable syntax in &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt;, the operand data types must always be specified.</source>
          <target state="translated">在 &lt;code&gt;OPERATOR&lt;/code&gt; 子句中，运算符的操作数数据类型，或 &lt;code&gt;NONE&lt;/code&gt; 表示左一元或右一元运算符。与 &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; 中的类似语法不同，必须始终指定操作数数据类型。</target>
        </trans-unit>
        <trans-unit id="ec2c43425fabe719ab28338af92c22c87b424e40" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;UPDATE&lt;/code&gt; command, if &lt;code&gt;ALWAYS&lt;/code&gt; is selected, any update of the column to any value other than &lt;code&gt;DEFAULT&lt;/code&gt; will be rejected. If &lt;code&gt;BY DEFAULT&lt;/code&gt; is selected, the column can be updated normally. (There is no &lt;code&gt;OVERRIDING&lt;/code&gt; clause for the &lt;code&gt;UPDATE&lt;/code&gt; command.)</source>
          <target state="translated">在 &lt;code&gt;UPDATE&lt;/code&gt; 命令中，如果 &lt;code&gt;ALWAYS&lt;/code&gt; 选择，则拒绝将列更新为 &lt;code&gt;DEFAULT&lt;/code&gt; 以外的任何值。如果选择&amp;ldquo;按 &lt;code&gt;BY DEFAULT&lt;/code&gt; 值&amp;rdquo;，则可以正常更新该列。（ &lt;code&gt;UPDATE&lt;/code&gt; 命令没有 &lt;code&gt;OVERRIDING&lt;/code&gt; 子句。）</target>
        </trans-unit>
        <trans-unit id="4f4865a4556be6b18a0efd231e79cc53e7a18167" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;UPDATE&lt;/code&gt;, the data available to &lt;code&gt;RETURNING&lt;/code&gt; is the new content of the modified row. For example:</source>
          <target state="translated">在 &lt;code&gt;UPDATE&lt;/code&gt; 中，可用于 &lt;code&gt;RETURNING&lt;/code&gt; 的数据是已修改行的新内容。例如：</target>
        </trans-unit>
        <trans-unit id="a9d42b6946ae8752c916da7ef8c706a7f5db4d3a" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;amgetbitmap&lt;/code&gt; index scan, the access method does not keep an index pin on any of the returned tuples. Therefore it is only safe to use such scans with MVCC-compliant snapshots.</source>
          <target state="translated">在 &lt;code&gt;amgetbitmap&lt;/code&gt; 索引扫描中，访问方法不会在返回的任何元组上保留索引销。因此，仅将此类扫描与兼容MVCC的快照一起使用是安全的。</target>
        </trans-unit>
        <trans-unit id="565ae755fcf3f7ba63623b03ac7404b46ed4ecef" translate="yes" xml:space="preserve">
          <source>In an abstract sense, a running PostgreSQL system produces an indefinitely long sequence of WAL records. The system physically divides this sequence into WAL &lt;em&gt;segment files&lt;/em&gt;, which are normally 16MB apiece (although the segment size can be altered during initdb). The segment files are given numeric names that reflect their position in the abstract WAL sequence. When not using WAL archiving, the system normally creates just a few segment files and then &amp;ldquo;recycles&amp;rdquo; them by renaming no-longer-needed segment files to higher segment numbers. It's assumed that segment files whose contents precede the last checkpoint are no longer of interest and can be recycled.</source>
          <target state="translated">从抽象的意义上讲，运行中的PostgreSQL系统会产生无限长的WAL记录序列。系统从物理上将此序列划分为WAL &lt;em&gt;段文件&lt;/em&gt;，通常每个&lt;em&gt;文件&lt;/em&gt;为16MB（尽管段大小可以在initdb期间更改）。段文件被赋予数字名称，以反映它们在抽象WAL序列中的位置。当不使用WAL归档时，系统通常只创建几个段文件，然后通过将不再需要的段文件重命名为较高的段号来&amp;ldquo;回收&amp;rdquo;它们。假定其内容在最后一个检查点之前的段文件不再受关注，可以回收。</target>
        </trans-unit>
        <trans-unit id="f8ac0a1e1d2b4929b34c74cce531be5f95182b00" translate="yes" xml:space="preserve">
          <source>In an exclusive backup, &lt;code&gt;pg_stop_backup&lt;/code&gt; removes the label file and, if it exists, the &lt;code&gt;tablespace_map&lt;/code&gt; file created by &lt;code&gt;pg_start_backup&lt;/code&gt;. In a non-exclusive backup, the contents of the &lt;code&gt;backup_label&lt;/code&gt; and &lt;code&gt;tablespace_map&lt;/code&gt; are returned in the result of the function, and should be written to files in the backup (and not in the data directory). There is an optional second parameter of type &lt;code&gt;boolean&lt;/code&gt;. If false, the &lt;code&gt;pg_stop_backup&lt;/code&gt; will return immediately after the backup is completed without waiting for WAL to be archived. This behavior is only useful for backup software which independently monitors WAL archiving. Otherwise, WAL required to make the backup consistent might be missing and make the backup useless. When this parameter is set to true, &lt;code&gt;pg_stop_backup&lt;/code&gt; will wait for WAL to be archived when archiving is enabled; on the standby, this means that it will wait only when &lt;code&gt;archive_mode = always&lt;/code&gt;. If write activity on the primary is low, it may be useful to run &lt;code&gt;pg_switch_wal&lt;/code&gt; on the primary in order to trigger an immediate segment switch.</source>
          <target state="translated">在排他备份中， &lt;code&gt;pg_stop_backup&lt;/code&gt; 删除标签文件，如果存在，则删除 &lt;code&gt;pg_start_backup&lt;/code&gt; 创建的 &lt;code&gt;tablespace_map&lt;/code&gt; 文件。在非排他性备份中， &lt;code&gt;backup_label&lt;/code&gt; 和 &lt;code&gt;tablespace_map&lt;/code&gt; 的内容在函数结果中返回，并且应写入备份中的文件（而不是数据目录中）。有一个可选的第二个类型为 &lt;code&gt;boolean&lt;/code&gt; 的参数。如果为false， &lt;code&gt;pg_stop_backup&lt;/code&gt; 备份完成后将立即返回，而无需等待WAL被存档。此行为仅对独立监视WAL归档的备份软件有用。否则，可能缺少使备份保持一致所需的WAL，并使备份无用。当此参数设置为true时，启用归档后 &lt;code&gt;pg_stop_backup&lt;/code&gt; 将等待WAL归档；在备用数据库上，这意味着它将仅在 &lt;code&gt;archive_mode = always&lt;/code&gt; 时等待。如果主 &lt;code&gt;pg_switch_wal&lt;/code&gt; 上的写活动较低，则在主节点上运行pg_switch_wal可能会很有用，以触​​发立即段切换。</target>
        </trans-unit>
        <trans-unit id="e7db342c2003b24a0078e3f7501e15f251fcabd3" translate="yes" xml:space="preserve">
          <source>In an index scan, the index access method is responsible for regurgitating the TIDs of all the tuples it has been told about that match the &lt;em&gt;scan keys&lt;/em&gt;. The access method is &lt;em&gt;not&lt;/em&gt; involved in actually fetching those tuples from the index's parent table, nor in determining whether they pass the scan's visibility test or other conditions.</source>
          <target state="translated">在索引扫描中，索引访问方法负责重新告知所有被告知与&lt;em&gt;扫描键&lt;/em&gt;匹配的元组的TID 。访问方法实际上&lt;em&gt;不&lt;/em&gt;涉及从索引的父表中获取那些元组，也不涉及确定它们是否通过了扫描的可见性测试或其他条件。</target>
        </trans-unit>
        <trans-unit id="2aea61eca91fb7f3cae5718d047d4ef52faf5a35" translate="yes" xml:space="preserve">
          <source>In an internal page (not shown), the block number part of &lt;code&gt;ctid&lt;/code&gt; is a &amp;ldquo;downlink&amp;rdquo;, which is a block number of another page in the index itself. The offset part (the second number) of &lt;code&gt;ctid&lt;/code&gt; stores encoded information about the tuple, such as the number of columns present (suffix truncation may have removed unneeded suffix columns). Truncated columns are treated as having the value &amp;ldquo;minus infinity&amp;rdquo;.</source>
          <target state="translated">在内部页（未显示）中， &lt;code&gt;ctid&lt;/code&gt; 的块号部分是&amp;ldquo;下行链路&amp;rdquo;，它是索引本身中另一页的块号。 &lt;code&gt;ctid&lt;/code&gt; 的偏移量部分（第二个数字）存储有关元组的编码信息，例如存在的列数（后缀截断可能已删除了不需要的后缀列）。截断的列被视为值&amp;ldquo;负无穷大&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="f28fd11104e5b0da0e35b4fc535d8db587de4795" translate="yes" xml:space="preserve">
          <source>In an unmodified installation, the file &lt;code&gt;Default&lt;/code&gt; contains all the non-conflicting time zone abbreviations for most of the world. Additional files &lt;code&gt;Australia&lt;/code&gt; and &lt;code&gt;India&lt;/code&gt; are provided for those regions: these files first include the &lt;code&gt;Default&lt;/code&gt; file and then add or modify abbreviations as needed.</source>
          <target state="translated">在未修改的安装中，文件 &lt;code&gt;Default&lt;/code&gt; 包含世界上大多数国家的所有非冲突时区缩写。这些地区还提供了 &lt;code&gt;Australia&lt;/code&gt; 和 &lt;code&gt;India&lt;/code&gt; 其他文件：这些文件首先包含 &lt;code&gt;Default&lt;/code&gt; 文件，然后根据需要添加或修改缩写。</target>
        </trans-unit>
        <trans-unit id="f4e4ae3ee0675010eaef475c4b41d41082a6a6e7" translate="yes" xml:space="preserve">
          <source>In any case, if a recovery target is configured but the archive recovery ends before the target is reached, the server will shut down with a fatal error.</source>
          <target state="translated">在任何情况下,如果配置了恢复目标,但在达到目标之前就结束了归档恢复,服务器将以致命错误关闭。</target>
        </trans-unit>
        <trans-unit id="6faf2b1db0e643ecf8d471d0c7a2c045089265e3" translate="yes" xml:space="preserve">
          <source>In any case, the distance to the end of the frame is limited by the distance to the end of the partition, so that for rows near the partition ends the frame might contain fewer rows than elsewhere.</source>
          <target state="translated">在任何情况下,到框架末端的距离都受限于到分区末端的距离,因此对于靠近分区末端的行,框架中包含的行可能比其他地方少。</target>
        </trans-unit>
        <trans-unit id="25a8baad62a92191ed853f5bfffb689d16144b1a" translate="yes" xml:space="preserve">
          <source>In archive recovery or standby mode, the server periodically performs &lt;em&gt;restartpoints&lt;/em&gt;, which are similar to checkpoints in normal operation: the server forces all its state to disk, updates the &lt;code&gt;pg_control&lt;/code&gt; file to indicate that the already-processed WAL data need not be scanned again, and then recycles any old log segment files in the &lt;code&gt;pg_wal&lt;/code&gt; directory. Restartpoints can't be performed more frequently than checkpoints in the master because restartpoints can only be performed at checkpoint records. A restartpoint is triggered when a checkpoint record is reached if at least &lt;code&gt;checkpoint_timeout&lt;/code&gt; seconds have passed since the last restartpoint, or if WAL size is about to exceed &lt;code&gt;max_wal_size&lt;/code&gt;. However, because of limitations on when a restartpoint can be performed, &lt;code&gt;max_wal_size&lt;/code&gt; is often exceeded during recovery, by up to one checkpoint cycle's worth of WAL. (&lt;code&gt;max_wal_size&lt;/code&gt; is never a hard limit anyway, so you should always leave plenty of headroom to avoid running out of disk space.)</source>
          <target state="translated">在归档恢复或备用模式下，服务器会定期执行&lt;em&gt;重启点&lt;/em&gt;，这些&lt;em&gt;重启&lt;/em&gt;点与正常操作中的检查点类似：服务器将所有状态强制进入磁盘，更新 &lt;code&gt;pg_control&lt;/code&gt; 文件以指示无需再次扫描已处理的WAL数据，然后回收 &lt;code&gt;pg_wal&lt;/code&gt; 目录中的所有旧日志段文件。重新启动点不能比主服务器中的检查点更频繁地执行，因为重新启动点只能在检查点记录中执行。如果自上次重新启动 &lt;code&gt;checkpoint_timeout&lt;/code&gt; 以来至少经过了checkpoint_timeout秒，或者如果WAL大小即将超过 &lt;code&gt;max_wal_size&lt;/code&gt; ，则在达到检查点记录时触发重新启动点。。但是，由于在何时可以执行 &lt;code&gt;max_wal_size&lt;/code&gt; 启动点方面存在限制，因此在恢复过程中经常会超出max_wal_size的值，最多不超过一个检查点周期的WAL。（无论如何， &lt;code&gt;max_wal_size&lt;/code&gt; 从来都不是硬限制，因此，您应该始终留有足够的净空，以避免用完磁盘空间。）</target>
        </trans-unit>
        <trans-unit id="e983613b50e43472d70dff9ae2842d52027c35fe" translate="yes" xml:space="preserve">
          <source>In autocommit-off mode, you must explicitly abandon any failed transaction by entering &lt;code&gt;ABORT&lt;/code&gt; or &lt;code&gt;ROLLBACK&lt;/code&gt;. Also keep in mind that if you exit the session without committing, your work will be lost.</source>
          <target state="translated">在自动提交模式下，必须通过输入 &lt;code&gt;ABORT&lt;/code&gt; 或 &lt;code&gt;ROLLBACK&lt;/code&gt; 显式放弃任何失败的事务。另外请记住，如果您退出会话而不提交，则您的工作将会丢失。</target>
        </trans-unit>
        <trans-unit id="b247fa1a8bf50d6b99053c3d0eeaa42c7ba06baa" translate="yes" xml:space="preserve">
          <source>In both cases, the current row of &lt;code&gt;inventory_item&lt;/code&gt; is passed to the function as a single composite-valued argument. Even though &lt;code&gt;.*&lt;/code&gt; does nothing in such cases, using it is good style, since it makes clear that a composite value is intended. In particular, the parser will consider &lt;code&gt;c&lt;/code&gt; in &lt;code&gt;c.*&lt;/code&gt; to refer to a table name or alias, not to a column name, so that there is no ambiguity; whereas without &lt;code&gt;.*&lt;/code&gt;, it is not clear whether &lt;code&gt;c&lt;/code&gt; means a table name or a column name, and in fact the column-name interpretation will be preferred if there is a column named &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">在这两种情况下，当前行 &lt;code&gt;inventory_item&lt;/code&gt; 被传递给该功能的一个单一的复合值的参数。即使 &lt;code&gt;.*&lt;/code&gt; 在这种情况下什么也不做，但使用它是一种好的样式，因为它明确了要使用复合值。尤其是，解析器将考虑 &lt;code&gt;c&lt;/code&gt; &lt;code&gt;c.*&lt;/code&gt; 中的c引用表名或别名，而不引用列名，因此不会产生歧义。相反，如果没有 &lt;code&gt;.*&lt;/code&gt; ，则不清楚 &lt;code&gt;c&lt;/code&gt; 是表名还是列名，实际上，如果存在名为 &lt;code&gt;c&lt;/code&gt; 的列，则首选列名解释。</target>
        </trans-unit>
        <trans-unit id="f76739639f03e7f45a4a9297ea3a846e096a82c7" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">如果遇到困难，请参阅&lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt;和&lt;a href=&quot;app-psql&quot;&gt;psql，&lt;/a&gt;以获取有关潜在问题和错误消息的讨论。数据库服务器必须在目标主机上运行。同样，libpq前端库使用的任何默认连接设置和环境变量都将适用。</target>
        </trans-unit>
        <trans-unit id="5db2bd59ec0063d8b571ff86647485295dec81a2" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">如果遇到困难，请参阅&lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt;和&lt;a href=&quot;app-psql&quot;&gt;psql，&lt;/a&gt;以获取有关潜在问题和错误消息的讨论。数据库服务器必须在目标主机上运行。同样，libpq前端库使用的任何默认连接设置和环境变量都将适用。</target>
        </trans-unit>
        <trans-unit id="9ba5e7fcf43f6a46fa23c849e18652c98a11d276" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">如果遇到困难，请参见&lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;和&lt;a href=&quot;app-psql&quot;&gt;psql，&lt;/a&gt;以获取有关潜在问题和错误消息的讨论。数据库服务器必须在目标主机上运行。同样，libpq前端库使用的任何默认连接设置和环境变量都将适用。</target>
        </trans-unit>
        <trans-unit id="6eaaf99e6c52738ae42a85a2ea51714fc0796916" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-dropdatabase&quot;&gt;DROP DATABASE&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">如果遇到困难，请参见&lt;a href=&quot;sql-dropdatabase&quot;&gt;DROP DATABASE&lt;/a&gt;和&lt;a href=&quot;app-psql&quot;&gt;psql，&lt;/a&gt;以获取有关潜在问题和错误消息的讨论。数据库服务器必须在目标主机上运行。同样，libpq前端库使用的任何默认连接设置和环境变量都将适用。</target>
        </trans-unit>
        <trans-unit id="94b403e1d0cfae4a4d06e5a4c5a48eb222d916e0" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">如果遇到困难，请参见&lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt;和&lt;a href=&quot;app-psql&quot;&gt;psql，&lt;/a&gt;以获取有关潜在问题和错误消息的讨论。数据库服务器必须在目标主机上运行。同样，libpq前端库使用的任何默认连接设置和环境变量都将适用。</target>
        </trans-unit>
        <trans-unit id="e7c380013a6560b8ccf88c49ec21236d61ed865e" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">如果遇到困难，请参阅&lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt;和&lt;a href=&quot;app-psql&quot;&gt;psql，&lt;/a&gt;以获取有关潜在问题和错误消息的讨论。数据库服务器必须在目标主机上运行。同样，libpq前端库使用的任何默认连接设置和环境变量都将适用。</target>
        </trans-unit>
        <trans-unit id="a390aa69b768b09463593395199c846120ecabb8" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">如果遇到困难，请参见&lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt;和&lt;a href=&quot;app-psql&quot;&gt;psql，&lt;/a&gt;以获取有关潜在问题和错误消息的讨论。数据库服务器必须在目标主机上运行。同样，libpq前端库使用的任何默认连接设置和环境变量都将适用。</target>
        </trans-unit>
        <trans-unit id="2030ab1905e77cb31a87a361f54b214bc88ef0f8" translate="yes" xml:space="preserve">
          <source>In case of multiple inheritance, if one parent column is a generated column, then all parent columns must be generated columns and with the same expression.</source>
          <target state="translated">在多继承的情况下,如果一个父列是生成列,那么所有的父列必须是生成列,并且表达式相同。</target>
        </trans-unit>
        <trans-unit id="93f46ad3e6977f8b4097e1a0c73d806eccff9805" translate="yes" xml:space="preserve">
          <source>In cases where you are accessing single rows randomly within a table, the actual order of the data in the table is unimportant. However, if you tend to access some data more than others, and there is an index that groups them together, you will benefit from using &lt;code&gt;CLUSTER&lt;/code&gt;. If you are requesting a range of indexed values from a table, or a single indexed value that has multiple rows that match, &lt;code&gt;CLUSTER&lt;/code&gt; will help because once the index identifies the table page for the first row that matches, all other rows that match are probably already on the same table page, and so you save disk accesses and speed up the query.</source>
          <target state="translated">如果您要随机访问表中的单个行，则表中数据的实际顺序并不重要。但是，如果您倾向于访问比其他数据更多的数据，并且有一个将它们分组在一起的索引，则可以从使用 &lt;code&gt;CLUSTER&lt;/code&gt; 中受益。如果要从表中请求某个范围的索引值，或者是具有多个匹配行的单个索引值，则 &lt;code&gt;CLUSTER&lt;/code&gt; 将有所帮助，因为一旦索引为匹配的第一行标识了表页面，所有其他匹配的行都可能已经在同一表页面上，因此您可以保存磁盘访问并加快查询速度。</target>
        </trans-unit>
        <trans-unit id="74c2cf6ed852f4b751c92fd9888cb548968dc00d" translate="yes" xml:space="preserve">
          <source>In certain cases using advisory locking methods, especially in queries involving explicit ordering and &lt;code&gt;LIMIT&lt;/code&gt; clauses, care must be taken to control the locks acquired because of the order in which SQL expressions are evaluated. For example:</source>
          <target state="translated">在某些情况下，使用建议性锁定方法，尤其是在涉及显式排序和 &lt;code&gt;LIMIT&lt;/code&gt; 子句的查询中，由于要评估SQL表达式的顺序，因此必须小心控制所获得的锁。例如：</target>
        </trans-unit>
        <trans-unit id="a44c40b70d09319f4150cf272b9356e9931bfa6f" translate="yes" xml:space="preserve">
          <source>In combination with the &lt;code&gt;convert_from&lt;/code&gt; function, this function can be used to read a text file in a specified encoding and convert to the database's encoding:</source>
          <target state="translated">与 &lt;code&gt;convert_from&lt;/code&gt; 函数结合使用，可以使用此函数以指定的编码读取文本文件并将其转换为数据库的编码：</target>
        </trans-unit>
        <trans-unit id="c672c01926d5e97ed50c99a3d3247bc55643b756" translate="yes" xml:space="preserve">
          <source>In contrast to &lt;code&gt;CREATE TABLE AS&lt;/code&gt;, &lt;code&gt;SELECT INTO&lt;/code&gt; does not allow to specify properties like a table's access method with &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-METHOD&quot;&gt;&lt;code&gt;USING method&lt;/code&gt;&lt;/a&gt; or the table's tablespace with &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-TABLESPACE&quot;&gt;&lt;code&gt;TABLESPACE tablespace_name&lt;/code&gt;&lt;/a&gt;. Use &lt;a href=&quot;sql-createtableas&quot;&gt;CREATE TABLE AS&lt;/a&gt; if necessary. Therefore, the default table access method is chosen for the new table. See &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLE-ACCESS-METHOD&quot;&gt;default_table_access_method&lt;/a&gt; for more information.</source>
          <target state="translated">与 &lt;code&gt;CREATE TABLE AS&lt;/code&gt; 相比， &lt;code&gt;SELECT INTO&lt;/code&gt; 不允许使用诸如&lt;a href=&quot;sql-createtable#SQL-CREATETABLE-METHOD&quot;&gt; &lt;code&gt;USING method&lt;/code&gt; &lt;/a&gt;的表访问方法或使用&lt;a href=&quot;sql-createtable#SQL-CREATETABLE-TABLESPACE&quot;&gt; &lt;code&gt;TABLESPACE tablespace_name&lt;/code&gt; &lt;/a&gt;的表空间来指定属性。如有必要，请使用&lt;a href=&quot;sql-createtableas&quot;&gt;CREATE TABLE AS&lt;/a&gt;。因此，为新表选择默认的表访问方法。有关更多信息，请参见&lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLE-ACCESS-METHOD&quot;&gt;default_table_access_method&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="61279093682c79c9f5568d5da222628b6973c973" translate="yes" xml:space="preserve">
          <source>In contrast to a &lt;code&gt;setval&lt;/code&gt; call, a &lt;code&gt;RESTART&lt;/code&gt; operation on a sequence is transactional and blocks concurrent transactions from obtaining numbers from the same sequence. If that's not the desired mode of operation, &lt;code&gt;setval&lt;/code&gt; should be used.</source>
          <target state="translated">与 &lt;code&gt;setval&lt;/code&gt; 调用相反，序列上的 &lt;code&gt;RESTART&lt;/code&gt; 操作是事务性的，并阻止并发事务从同一序列中获取数字。如果这不是所需的操作模式，则应使用 &lt;code&gt;setval&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8047479f58f45c6933e1e0d8cbc566b58e46ed0" translate="yes" xml:space="preserve">
          <source>In database jargon, PostgreSQL uses a client/server model. A PostgreSQL session consists of the following cooperating processes (programs):</source>
          <target state="translated">在数据库术语中,PostgreSQL使用的是客户/服务器模型。一个PostgreSQL会话由以下合作进程(程序)组成。</target>
        </trans-unit>
        <trans-unit id="4ebcdbe0c3b4b06ac68e78641d8a5ee88bcf9f9b" translate="yes" xml:space="preserve">
          <source>In each round, no more than this many buffers will be written by the background writer. Setting this to zero disables background writing. (Note that checkpoints, which are managed by a separate, dedicated auxiliary process, are unaffected.) The default value is 100 buffers. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">在每一轮中，后台编写器将只写这么多缓冲区。将此设置为零将禁用后台写入。（请注意，由单独的专用辅助进程管理的检查点不受影响。）默认值为100个缓冲区。该参数只能在 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件或服务器命令行中设置。</target>
        </trans-unit>
        <trans-unit id="ccd9c3c470f6cf3a148b1b2c45132bef7b97eb77" translate="yes" xml:space="preserve">
          <source>In either case the data to be encrypted is processed as follows:</source>
          <target state="translated">无论在哪种情况下,都会对要加密的数据进行如下处理。</target>
        </trans-unit>
        <trans-unit id="306aa7e6b40f133245f13ca709da9e87be03e6ed" translate="yes" xml:space="preserve">
          <source>In either input mode, if you type a semicolon that is not just before or part of a command entry terminator, it is considered a command separator. When you do type a command entry terminator, the multiple statements you've entered will be executed as a single transaction.</source>
          <target state="translated">在任何一种输入模式下,如果你键入的分号不只是在命令输入结束符之前或者是命令输入结束符的一部分,那么它将被视为命令分隔符。当你键入命令输入结束符时,你输入的多条语句将作为一个事务执行。</target>
        </trans-unit>
        <trans-unit id="52ebde367582fd620a8c225e745609692ba01e89" translate="yes" xml:space="preserve">
          <source>In either notation, parameters that have default values given in the function declaration need not be written in the call at all. But this is particularly useful in named notation, since any combination of parameters can be omitted; while in positional notation parameters can only be omitted from right to left.</source>
          <target state="translated">在这两种符号中,在函数声明中给出的默认值的参数根本不需要写在调用中,但这在命名符号中特别有用,因为任何参数组合都可以省略;而在位置符号中,参数只能从右到左省略。但这在命名符号中特别有用,因为可以省略任何参数组合;而在位置符号中,参数只能从右到左省略。</target>
        </trans-unit>
        <trans-unit id="d831af293a1db32dece4f56906f01bbc94d110b4" translate="yes" xml:space="preserve">
          <source>In fact all the options that can be applied to a column description in &lt;code&gt;CREATE TABLE&lt;/code&gt; can be used here. Keep in mind however that the default value must satisfy the given constraints, or the &lt;code&gt;ADD&lt;/code&gt; will fail. Alternatively, you can add constraints later (see below) after you've filled in the new column correctly.</source>
          <target state="translated">实际上，可以在此处使用可以应用于 &lt;code&gt;CREATE TABLE&lt;/code&gt; 中的列描述的所有选项。但是请记住，默认值必须满足给定的约束，否则 &lt;code&gt;ADD&lt;/code&gt; 将失败。另外，您可以在正确填写新列之后再添加约束（见下文）。</target>
        </trans-unit>
        <trans-unit id="783e59eb801df832fa056e21e4887ace28a8cded" translate="yes" xml:space="preserve">
          <source>In file system terms, a database cluster is a single directory under which all data will be stored. We call this the &lt;em&gt;data directory&lt;/em&gt; or &lt;em&gt;data area&lt;/em&gt;. It is completely up to you where you choose to store your data. There is no default, although locations such as &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt; or &lt;code&gt;/var/lib/pgsql/data&lt;/code&gt; are popular. The data directory must be initialized before being used, using the program &lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt; which is installed with PostgreSQL.</source>
          <target state="translated">用文件系统的术语来说，数据库集群是一个目录，所有数据都将存储在该目录下。我们称其为&lt;em&gt;数据目录&lt;/em&gt;或&lt;em&gt;数据区域&lt;/em&gt;。您完全可以选择存储数据的位置。没有默认值，尽管 &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt; 或 &lt;code&gt;/var/lib/pgsql/data&lt;/code&gt; 等位置很受欢迎。数据目录在使用之前必须使用PostgreSQL随附的&lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt;程序进行初始化。</target>
        </trans-unit>
        <trans-unit id="5989a14e7d9d5d4126144b5b3e9ac84c1a4ebc4b" translate="yes" xml:space="preserve">
          <source>In file system terms, a database cluster is a single directory under which all data will be stored. We call this the &lt;em&gt;data directory&lt;/em&gt; or &lt;em&gt;data area&lt;/em&gt;. It is completely up to you where you choose to store your data. There is no default, although locations such as &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt; or &lt;code&gt;/var/lib/pgsql/data&lt;/code&gt; are popular. To initialize a database cluster, use the command &lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt;, which is installed with PostgreSQL. The desired file system location of your database cluster is indicated by the &lt;code&gt;-D&lt;/code&gt; option, for example:</source>
          <target state="translated">用文件系统的术语来说，数据库集群是一个目录，所有数据都将存储在该目录下。我们称其为&lt;em&gt;数据目录&lt;/em&gt;或&lt;em&gt;数据区域&lt;/em&gt;。选择存储数据的位置完全取决于您。没有默认值，尽管 &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt; 或 &lt;code&gt;/var/lib/pgsql/data&lt;/code&gt; 等位置很受欢迎。要初始化数据库集群，请使用与PostgreSQL一起安装的&lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt;命令。 &lt;code&gt;-D&lt;/code&gt; 选项指示数据库集群所需的文件系统位置，例如：</target>
        </trans-unit>
        <trans-unit id="c6dec459ff41edebdbf286e5c7e7fa61bacc87ff" translate="yes" xml:space="preserve">
          <source>In general it is unsafe to access tables referenced in rebuild scripts until the rebuild scripts have run to completion; doing so could yield incorrect results or poor performance. Tables not referenced in rebuild scripts can be accessed immediately.</source>
          <target state="translated">一般来说,在重建脚本运行完成之前,访问重建脚本中引用的表是不安全的;这样做可能会产生不正确的结果或者性能不佳。在重建脚本中没有引用的表可以立即被访问。</target>
        </trans-unit>
        <trans-unit id="d3d408ce8d9c6617962a7ddfab014057b11931d1" translate="yes" xml:space="preserve">
          <source>In general the array &lt;code&gt;expression&lt;/code&gt; must be parenthesized, but the parentheses can be omitted when the expression to be subscripted is just a column reference or positional parameter. Also, multiple subscripts can be concatenated when the original array is multidimensional. For example:</source>
          <target state="translated">通常，数组 &lt;code&gt;expression&lt;/code&gt; 必须带括号，但是当要下标的表达式只是列引用或位置参数时，可以省略括号。同样，当原始数组为多维时，可以连接多个下标。例如：</target>
        </trans-unit>
        <trans-unit id="a233c74a23b1b0f950c13008071a2c4108299433" translate="yes" xml:space="preserve">
          <source>In general the row &lt;code&gt;expression&lt;/code&gt; must be parenthesized, but the parentheses can be omitted when the expression to be selected from is just a table reference or positional parameter. For example:</source>
          <target state="translated">通常，行 &lt;code&gt;expression&lt;/code&gt; 必须带括号，但是当要选择的表达式只是表引用或位置参数时，可以省略括号。例如：</target>
        </trans-unit>
        <trans-unit id="8c0b63d62e29b9c5a3a626356a3b517fe18e88f9" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;amcheck&lt;/code&gt; can only prove the presence of corruption; it cannot prove its absence.</source>
          <target state="translated">通常， &lt;code&gt;amcheck&lt;/code&gt; 只能证明存在腐败；它不能证明它的缺失。</target>
        </trans-unit>
        <trans-unit id="9e2bc9fd37cc10d6d4e2c0ce13c42250e4fbbee6" translate="yes" xml:space="preserve">
          <source>In general, a unique constraint is violated if there is more than one row in the table where the values of all of the columns included in the constraint are equal. However, two null values are never considered equal in this comparison. That means even in the presence of a unique constraint it is possible to store duplicate rows that contain a null value in at least one of the constrained columns. This behavior conforms to the SQL standard, but we have heard that other SQL databases might not follow this rule. So be careful when developing applications that are intended to be portable.</source>
          <target state="translated">一般来说,如果表中有多于一行的约束条件所包含的所有列的值都相等,则违反了唯一约束条件。然而,在这种比较中,两个空值永远不会被认为是相等的。这意味着即使在存在唯一约束的情况下,也有可能存储在至少一个约束列中包含空值的重复行。这种行为符合SQL标准,但我们听说其他SQL数据库可能不遵循这个规则。所以在开发旨在可移植的应用程序时要小心。</target>
        </trans-unit>
        <trans-unit id="2348b93b2ef61033a339bed35843085ef2b630c2" translate="yes" xml:space="preserve">
          <source>In general, if a function is labeled as being safe when it is restricted or unsafe, or if it is labeled as being restricted when it is in fact unsafe, it may throw errors or produce wrong answers when used in a parallel query. C-language functions could in theory exhibit totally undefined behavior if mislabeled, since there is no way for the system to protect itself against arbitrary C code, but in most likely cases the result will be no worse than for any other function. If in doubt, it is probably best to label functions as &lt;code&gt;UNSAFE&lt;/code&gt;.</source>
          <target state="translated">通常，如果某个函数在受限或不安全时被标记为安全，或者在实际上不安全时被标记为受限，则在并行查询中使用该函数可能会引发错误或产生错误的答案。如果没有正确标注，C语言函数在理论上可能表现出完全未定义的行为，因为系统无法保护自己免受任意C代码的侵害，但是在大多数情况下，其结果不会比其他函数差。如有疑问，最好将功能标记为 &lt;code&gt;UNSAFE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a7edd5220f4e78ad60a17c1f93de6471bf8d5e1f" translate="yes" xml:space="preserve">
          <source>In general, if a table is grouped, columns that are not listed in &lt;code&gt;GROUP BY&lt;/code&gt; cannot be referenced except in aggregate expressions. An example with aggregate expressions is:</source>
          <target state="translated">通常，如果对表进行分组，则除了聚合表达式外，不能引用 &lt;code&gt;GROUP BY&lt;/code&gt; 中未列出的列。具有聚合表达式的示例是：</target>
        </trans-unit>
        <trans-unit id="d1c3c9f3417fc6beedd0acdb2d294853319e6a73" translate="yes" xml:space="preserve">
          <source>In general, log shipping between servers running different major PostgreSQL release levels is not possible. It is the policy of the PostgreSQL Global Development Group not to make changes to disk formats during minor release upgrades, so it is likely that running different minor release levels on primary and standby servers will work successfully. However, no formal support for that is offered and you are advised to keep primary and standby servers at the same release level as much as possible. When updating to a new minor release, the safest policy is to update the standby servers first &amp;mdash; a new minor release is more likely to be able to read WAL files from a previous minor release than vice versa.</source>
          <target state="translated">通常，无法在运行不同主要PostgreSQL版本的服务器之间进行日志传送。 PostgreSQL全球开发小组的政策是在次要发行版升级期间不要更改磁盘格式，因此在主服务器和备用服务器上运行不同的次要发行版级别可能会成功运行。但是，没有为此提供正式支持，建议您将主服务器和备用服务器尽可能保持在同一发行级别。更新到新的次要版本时，最安全的策略是先更新备用服务器-新的次要版本更可能能够从以前的次要版本中读取WAL文件，反之亦然。</target>
        </trans-unit>
        <trans-unit id="379f9f035821f16216f7bd05e1c59664a2c062ce" translate="yes" xml:space="preserve">
          <source>In general, most applications should prefer to store JSON data as &lt;code&gt;jsonb&lt;/code&gt;, unless there are quite specialized needs, such as legacy assumptions about ordering of object keys.</source>
          <target state="translated">通常，大多数应用程序应该将JSON数据存储为 &lt;code&gt;jsonb&lt;/code&gt; ，除非有非常特殊的需求，例如关于对象键顺序的传统假设。</target>
        </trans-unit>
        <trans-unit id="b5f07f22b350f8a6e38078060fd0e008a551cf3e" translate="yes" xml:space="preserve">
          <source>In general, refer to the documentation of a specific module for the recommended way to load that module.</source>
          <target state="translated">一般情况下,请参考特定模块的文档,了解该模块的推荐加载方式。</target>
        </trans-unit>
        <trans-unit id="ee2e987300579f41179429fff2833d7671d0a6f4" translate="yes" xml:space="preserve">
          <source>In general, these operator classes will not outperform the equivalent standard B-tree index methods, and they lack one major feature of the standard B-tree code: the ability to enforce uniqueness. However, they are useful for GIN testing and as a base for developing other GIN operator classes. Also, for queries that test both a GIN-indexable column and a B-tree-indexable column, it might be more efficient to create a multicolumn GIN index that uses one of these operator classes than to create two separate indexes that would have to be combined via bitmap ANDing.</source>
          <target state="translated">一般来说,这些运算符类的性能不会超过等效的标准B树索引方法,而且它们缺乏标准B树代码的一个主要特征:强制执行唯一性的能力。然而,它们对于GIN测试和作为开发其他GIN操作类的基础是有用的。另外,对于同时测试GIN可索引列和B树可索引列的查询来说,创建一个使用这些运算符类之一的多列GIN索引可能比创建两个单独的索引更有效,因为这两个索引必须通过位图ANDing来组合。</target>
        </trans-unit>
        <trans-unit id="d2aa893456da765ab903af76d8c63108ae26c6ce" translate="yes" xml:space="preserve">
          <source>In general, these operator classes will not outperform the equivalent standard B-tree index methods, and they lack one major feature of the standard B-tree code: the ability to enforce uniqueness. However, they provide some other features that are not available with a B-tree index, as described below. Also, these operator classes are useful when a multicolumn GiST index is needed, wherein some of the columns are of data types that are only indexable with GiST but other columns are just simple data types. Lastly, these operator classes are useful for GiST testing and as a base for developing other GiST operator classes.</source>
          <target state="translated">一般来说,这些运算符类的性能不会超过等效的标准B树索引方法,而且它们缺乏标准B树代码的一个主要特征:执行唯一性的能力。然而,它们提供了其他一些B树索引所不具备的功能,如下所述。另外,当需要多列GiST索引时,这些操作符类也很有用,其中一些列是只能用GiST索引的数据类型,但其他列只是简单的数据类型。最后,这些运算符类对于GiST测试和作为开发其他GiST运算符类的基础很有用。</target>
        </trans-unit>
        <trans-unit id="050ef9f5f9df87b4cced8b5539a1b041812d5f42" translate="yes" xml:space="preserve">
          <source>In large tables, performance will be poor unless there is an index on the parent-key field.</source>
          <target state="translated">在大表中,除非在父键字段上有索引,否则性能会很差。</target>
        </trans-unit>
        <trans-unit id="4765e35412cfd4a863f019aa0033f2c20c5f4705" translate="yes" xml:space="preserve">
          <source>In lieu of using replication slots, it is possible to prevent the removal of old WAL segments using &lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SEGMENTS&quot;&gt;wal_keep_segments&lt;/a&gt;, or by storing the segments in an archive using &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt;. However, these methods often result in retaining more WAL segments than required, whereas replication slots retain only the number of segments known to be needed. An advantage of these methods is that they bound the space requirement for &lt;code&gt;pg_wal&lt;/code&gt;; there is currently no way to do this using replication slots.</source>
          <target state="translated">代替使用复制插槽，可以使用&lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SEGMENTS&quot;&gt;wal_keep_segments&lt;/a&gt;或通过使用&lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt;将这些段存储在存档中来防止删除旧的WAL段。但是，这些方法通常会导致保留比所需更多的WAL段，而复制插槽仅保留已知需要的段数。这些方法的优点是它们限制了 &lt;code&gt;pg_wal&lt;/code&gt; 的空间要求；当前无法使用复制插槽来执行此操作。</target>
        </trans-unit>
        <trans-unit id="29c3b7a7ac22ed19dd75a4554e5969e671d90aa0" translate="yes" xml:space="preserve">
          <source>In lieu of using replication slots, it is possible to prevent the removal of old WAL segments using &lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SIZE&quot;&gt;wal_keep_size&lt;/a&gt;, or by storing the segments in an archive using &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt;. However, these methods often result in retaining more WAL segments than required, whereas replication slots retain only the number of segments known to be needed. On the other hand, replication slots can retain so many WAL segments that they fill up the space allocated for &lt;code&gt;pg_wal&lt;/code&gt;; &lt;a href=&quot;runtime-config-replication#GUC-MAX-SLOT-WAL-KEEP-SIZE&quot;&gt;max_slot_wal_keep_size&lt;/a&gt; limits the size of WAL files retained by replication slots.</source>
          <target state="translated">代替使用复制插槽，可以使用&lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SIZE&quot;&gt;wal_keep_size&lt;/a&gt;或通过使用&lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt;将这些段存储在归档文件中来防止删除旧的WAL段。但是，这些方法通常会导致保留比所需更多的WAL段，而复制插槽仅保留已知所需的段数。另一方面，复制槽可以保留这么多的WAL段，以至于它们填满了为 &lt;code&gt;pg_wal&lt;/code&gt; 分配的空间；&lt;a href=&quot;runtime-config-replication#GUC-MAX-SLOT-WAL-KEEP-SIZE&quot;&gt;max_slot_wal_keep_size&lt;/a&gt;限制复制插槽保留的WAL文件的大小。</target>
        </trans-unit>
        <trans-unit id="84baf4a0766c72c5ea2542a507182c8520343dbe" translate="yes" xml:space="preserve">
          <source>In macOS 10.2 and earlier, instead edit these commands in the file &lt;code&gt;/System/Library/StartupItems/SystemTuning/SystemTuning&lt;/code&gt;.</source>
          <target state="translated">在macOS 10.2及更早版本中，请在 &lt;code&gt;/System/Library/StartupItems/SystemTuning/SystemTuning&lt;/code&gt; 文件中编辑这些命令。</target>
        </trans-unit>
        <trans-unit id="6203855ca7fcb59eaeec22abadb1b2a4087a8203" translate="yes" xml:space="preserve">
          <source>In many practical situations, this assumption is usually satisfied; for example, there might be a GUI in the application that only allows selecting compatible city and ZIP code values to use in a query. But if that's not the case, functional dependencies may not be a viable option.</source>
          <target state="translated">在许多实际情况下,这个假设通常是满足的;例如,在应用程序中可能有一个GUI,只允许在查询中选择兼容的城市和ZIP码值来使用。但如果不是这种情况,功能依赖可能不是一个可行的选择。</target>
        </trans-unit>
        <trans-unit id="4b1075485e703bf16e8ab73df82eb829ce78c033" translate="yes" xml:space="preserve">
          <source>In many situations, turning off &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt; for noncritical transactions can provide much of the potential performance benefit of turning off &lt;code&gt;fsync&lt;/code&gt;, without the attendant risks of data corruption.</source>
          <target state="translated">在许多情况下，关闭&lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt;非关键数据可以提供很多关闭的潜在性能优势 &lt;code&gt;fsync&lt;/code&gt; ，不会造成数据损坏的随之而来的风险。</target>
        </trans-unit>
        <trans-unit id="194f1c0784b754fb38f29c78dc946b25933f09f6" translate="yes" xml:space="preserve">
          <source>In most cases &lt;code&gt;regexp_matches()&lt;/code&gt; should be used with the &lt;code&gt;g&lt;/code&gt; flag, since if you only want the first match, it's easier and more efficient to use &lt;code&gt;regexp_match()&lt;/code&gt;. However, &lt;code&gt;regexp_match()&lt;/code&gt; only exists in PostgreSQL version 10 and up. When working in older versions, a common trick is to place a &lt;code&gt;regexp_matches()&lt;/code&gt; call in a sub-select, for example:</source>
          <target state="translated">在大多数情况下，应该将 &lt;code&gt;regexp_matches()&lt;/code&gt; 与 &lt;code&gt;g&lt;/code&gt; 标志一起使用，因为如果您只想要第一个匹配项，则使用 &lt;code&gt;regexp_match()&lt;/code&gt; 会更轻松，更高效。但是， &lt;code&gt;regexp_match()&lt;/code&gt; 仅存在于PostgreSQL 10及更高版本中。在较旧版本中工作时，一个常见的技巧是将 &lt;code&gt;regexp_matches()&lt;/code&gt; 调用放在子选择中，例如：</target>
        </trans-unit>
        <trans-unit id="d60a20da168de2a263b74b28aa44a9c52da8b217" translate="yes" xml:space="preserve">
          <source>In most cases a &lt;code&gt;DELETE&lt;/code&gt; command also needs to read data from columns in the relation that it is deleting from (e.g., in a &lt;code&gt;WHERE&lt;/code&gt; clause or a &lt;code&gt;RETURNING&lt;/code&gt; clause). In this case, &lt;code&gt;SELECT&lt;/code&gt; rights are also required on the relation, and the appropriate &lt;code&gt;SELECT&lt;/code&gt; or &lt;code&gt;ALL&lt;/code&gt; policies will be applied in addition to the &lt;code&gt;DELETE&lt;/code&gt; policies. Thus the user must have access to the row(s) being deleted through a &lt;code&gt;SELECT&lt;/code&gt; or &lt;code&gt;ALL&lt;/code&gt; policy in addition to being granted permission to delete the row(s) via a &lt;code&gt;DELETE&lt;/code&gt; or &lt;code&gt;ALL&lt;/code&gt; policy.</source>
          <target state="translated">在大多数情况下， &lt;code&gt;DELETE&lt;/code&gt; 命令还需要从要删除的关系中的列中读取数据（例如，在 &lt;code&gt;WHERE&lt;/code&gt; 子句或 &lt;code&gt;RETURNING&lt;/code&gt; 子句中）。在这种情况下，该关系上还需要 &lt;code&gt;SELECT&lt;/code&gt; 权限，除了 &lt;code&gt;DELETE&lt;/code&gt; 策略外，还将应用适当的 &lt;code&gt;SELECT&lt;/code&gt; 或 &lt;code&gt;ALL&lt;/code&gt; 策略。因此，除了被授予通过 &lt;code&gt;DELETE&lt;/code&gt; 或 &lt;code&gt;ALL&lt;/code&gt; 策略删除该行的权限外，用户还必须有权通过 &lt;code&gt;SELECT&lt;/code&gt; 或 &lt;code&gt;ALL&lt;/code&gt; 策略删除该行。</target>
        </trans-unit>
        <trans-unit id="82c5561a0275adcd2a2a51ebef8a40a5f37109da" translate="yes" xml:space="preserve">
          <source>In most database designs the majority of columns should be marked not null.</source>
          <target state="translated">在大多数数据库设计中,大多数列都应该标记为非空。</target>
        </trans-unit>
        <trans-unit id="158c99420a44bba9aff343cb614d9616cbae7fa4" translate="yes" xml:space="preserve">
          <source>In most implementations of the &amp;ldquo;not-a-number&amp;rdquo; concept, &lt;code&gt;NaN&lt;/code&gt; is not considered equal to any other numeric value (including &lt;code&gt;NaN&lt;/code&gt;). In order to allow &lt;code&gt;numeric&lt;/code&gt; values to be sorted and used in tree-based indexes, PostgreSQL treats &lt;code&gt;NaN&lt;/code&gt; values as equal, and greater than all non-&lt;code&gt;NaN&lt;/code&gt; values.</source>
          <target state="translated">在&amp;ldquo;非数字&amp;rdquo;概念的大多数实现中， &lt;code&gt;NaN&lt;/code&gt; 不被认为等于任何其他数值（包括 &lt;code&gt;NaN&lt;/code&gt; ）。为了允许对 &lt;code&gt;numeric&lt;/code&gt; 进行排序并在基于树的索引中使用，PostgreSQL将 &lt;code&gt;NaN&lt;/code&gt; 值视为相等，并且大于所有非 &lt;code&gt;NaN&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="cd61e39655eeef5b9bf240531ec53c538d27ed8e" translate="yes" xml:space="preserve">
          <source>In named notation, each argument's name is specified using &lt;code&gt;=&amp;gt;&lt;/code&gt; to separate it from the argument expression. For example:</source>
          <target state="translated">在命名符号中，使用 &lt;code&gt;=&amp;gt;&lt;/code&gt; 指定每个参数的名称，以将其与参数表达式分开。例如：</target>
        </trans-unit>
        <trans-unit id="3a49a039bda09447cda5b6ba6fb7b5f06a1662cb" translate="yes" xml:space="preserve">
          <source>In nearly all cases, you'll need some options to make a useful test. The most important options are &lt;code&gt;-c&lt;/code&gt; (number of clients), &lt;code&gt;-t&lt;/code&gt; (number of transactions), &lt;code&gt;-T&lt;/code&gt; (time limit), and &lt;code&gt;-f&lt;/code&gt; (specify a custom script file). See below for a full list.</source>
          <target state="translated">在几乎所有情况下，您都需要一些选项来进行有用的测试。最重要的选项是 &lt;code&gt;-c&lt;/code&gt; （客户端数量），- &lt;code&gt;-t&lt;/code&gt; （事务数量），- &lt;code&gt;-T&lt;/code&gt; （时间限制）和 &lt;code&gt;-f&lt;/code&gt; （指定自定义脚本文件）。请参阅下面的完整列表。</target>
        </trans-unit>
        <trans-unit id="5a8686c8bc573efc7c7f314b50a2faaa5e4253e1" translate="yes" xml:space="preserve">
          <source>In non-fragment-based headline generation, &lt;code&gt;ts_headline&lt;/code&gt; locates matches for the given &lt;code&gt;query&lt;/code&gt; and chooses a single one to display, preferring matches that have more query words within the allowed headline length. In fragment-based headline generation, &lt;code&gt;ts_headline&lt;/code&gt; locates the query matches and splits each match into &amp;ldquo;fragments&amp;rdquo; of no more than &lt;code&gt;MaxWords&lt;/code&gt; words each, preferring fragments with more query words, and when possible &amp;ldquo;stretching&amp;rdquo; fragments to include surrounding words. The fragment-based mode is thus more useful when the query matches span large sections of the document, or when it's desirable to display multiple matches. In either mode, if no query matches can be identified, then a single fragment of the first &lt;code&gt;MinWords&lt;/code&gt; words in the document will be displayed.</source>
          <target state="translated">在基于非片段的标题生成中， &lt;code&gt;ts_headline&lt;/code&gt; 定位给定 &lt;code&gt;query&lt;/code&gt; 匹配项，并选择一个要显示的匹配项，而是选择在允许的标题长度内具有更多查询词的匹配项。在基于片段的标题生成中， &lt;code&gt;ts_headline&lt;/code&gt; 定位查询匹配项，并将每个匹配项分成不超过 &lt;code&gt;MaxWords&lt;/code&gt; 个单词的&amp;ldquo;片段&amp;rdquo; ，更喜欢包含更多查询词的片段，并在可能的情况下&amp;ldquo;拉伸&amp;rdquo;片段以包含周围的单词。因此，当查询匹配跨文档的大部分内容时，或者需要显示多个匹配项时，基于片段的模式将更加有用。在任何一种模式下，如果都无法识别出查询匹配项，则第一个查询的单个片段 &lt;code&gt;MinWords&lt;/code&gt; 将显示文档中的MinWords单词。</target>
        </trans-unit>
        <trans-unit id="fac5d16972792c7bd805065c712c623a51151c8c" translate="yes" xml:space="preserve">
          <source>In none of these cases is there any provision for schema-qualification; all objects created during bootstrap are expected to be in the &lt;code&gt;pg_catalog&lt;/code&gt; schema.</source>
          <target state="translated">在所有这些情况下，都没有提供模式资格的规定；引导过程中创建的所有对象都应位于 &lt;code&gt;pg_catalog&lt;/code&gt; 模式中。</target>
        </trans-unit>
        <trans-unit id="f2409be7cd8d4efc7e947e3b436a132ef0c47174" translate="yes" xml:space="preserve">
          <source>In normal (non-recovery) mode, if you issue &lt;code&gt;DROP USER&lt;/code&gt; or &lt;code&gt;DROP ROLE&lt;/code&gt; for a role with login capability while that user is still connected then nothing happens to the connected user &amp;mdash; they remain connected. The user cannot reconnect however. This behavior applies in recovery also, so a &lt;code&gt;DROP USER&lt;/code&gt; on the primary does not disconnect that user on the standby.</source>
          <target state="translated">在正常（非恢复）模式下，如果在该用户仍处于连接状态时为具有登录功能的角色发出 &lt;code&gt;DROP USER&lt;/code&gt; 或 &lt;code&gt;DROP ROLE&lt;/code&gt; ，则所连接的用户没有任何反应-他们保持连接状态。但是，用户无法重新连接。此行为也适用于恢复，因此主数据库上的 &lt;code&gt;DROP USER&lt;/code&gt; 不会断开备用数据库上的该用户的连接。</target>
        </trans-unit>
        <trans-unit id="909fab97f09523721a77cc835152b274f406d63c" translate="yes" xml:space="preserve">
          <source>In normal (non-recovery) mode, if you issue &lt;code&gt;DROP USER&lt;/code&gt; or &lt;code&gt;DROP ROLE&lt;/code&gt; for a role with login capability while that user is still connected then nothing happens to the connected user - they remain connected. The user cannot reconnect however. This behavior applies in recovery also, so a &lt;code&gt;DROP USER&lt;/code&gt; on the primary does not disconnect that user on the standby.</source>
          <target state="translated">在正常（非恢复）模式下，如果在该用户仍处于连接状态时为具有登录功能的角色发出 &lt;code&gt;DROP USER&lt;/code&gt; 或 &lt;code&gt;DROP ROLE&lt;/code&gt; ，则连接的用户没有任何反应-他们保持连接状态。但是，用户无法重新连接。此行为也适用于恢复，因此主数据库上的 &lt;code&gt;DROP USER&lt;/code&gt; 不会断开备用数据库上的该用户的连接。</target>
        </trans-unit>
        <trans-unit id="b1729ae1f718e0b63bffb08ae3066f0eb0e77ca2" translate="yes" xml:space="preserve">
          <source>In normal operation, &amp;ldquo;read-only&amp;rdquo; transactions are allowed to use &lt;code&gt;LISTEN&lt;/code&gt; and &lt;code&gt;NOTIFY&lt;/code&gt;, so Hot Standby sessions operate under slightly tighter restrictions than ordinary read-only sessions. It is possible that some of these restrictions might be loosened in a future release.</source>
          <target state="translated">在正常操作中，允许&amp;ldquo;只读&amp;rdquo;事务使用 &lt;code&gt;LISTEN&lt;/code&gt; 和 &lt;code&gt;NOTIFY&lt;/code&gt; ，因此热备会话在比普通只读会话更严格的限制下运行。这些限制中的某些限制可能会在将来的版本中放宽。</target>
        </trans-unit>
        <trans-unit id="d3560745e5e4a4c446630441931abacb2898af6f" translate="yes" xml:space="preserve">
          <source>In normal operation, psql provides a prompt with the name of the database to which psql is currently connected, followed by the string &lt;code&gt;=&amp;gt;&lt;/code&gt;. For example:</source>
          <target state="translated">在正常操作中，psql会提示您输入当前已连接psql的数据库的名称，后跟字符串 &lt;code&gt;=&amp;gt;&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="cd286c2214fff2e0be18b3ddfb09dfdd0278ddbf" translate="yes" xml:space="preserve">
          <source>In older OpenBSD versions, you will need to build a custom kernel to change the IPC parameters. Make sure that the options &lt;code&gt;SYSVSHM&lt;/code&gt; and &lt;code&gt;SYSVSEM&lt;/code&gt; are enabled, too. (They are by default.) The following shows an example of how to set the various parameters in the kernel configuration file:</source>
          <target state="translated">在较旧的OpenBSD版本中，您将需要构建自定义内核来更改IPC参数。确保还启用了选项 &lt;code&gt;SYSVSHM&lt;/code&gt; 和 &lt;code&gt;SYSVSEM&lt;/code&gt; 。（默认情况下是它们。）下面显示了如何在内核配置文件中设置各种参数的示例：</target>
        </trans-unit>
        <trans-unit id="43d5f374be9ab2b9f725372748b33884cde122b3" translate="yes" xml:space="preserve">
          <source>In older macOS versions, you will need to reboot to have changes in the shared memory parameters take effect. As of 10.5 it is possible to change all but &lt;code&gt;SHMMNI&lt;/code&gt; on the fly, using sysctl. But it's still best to set up your preferred values via &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;, so that the values will be kept across reboots.</source>
          <target state="translated">在较早的macOS版本中，您将需要重新启动才能使共享内存参数中的更改生效。从10.5版开始，可以使用sysctl 快速更改除 &lt;code&gt;SHMMNI&lt;/code&gt; 之外的所有内容。但是，仍然最好通过 &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 设置您的首选值，以便在重新启动后保留这些值。</target>
        </trans-unit>
        <trans-unit id="882a1a9442374dfd65845651f73b92d43f44074e" translate="yes" xml:space="preserve">
          <source>In order for the tunnel setup to succeed you must be allowed to connect via &lt;code&gt;ssh&lt;/code&gt; as &lt;code&gt;joe@foo.com&lt;/code&gt;, just as if you had attempted to use &lt;code&gt;ssh&lt;/code&gt; to create a terminal session.</source>
          <target state="translated">为了使隧道设置成功，必须允许您通过 &lt;code&gt;ssh&lt;/code&gt; 以 &lt;code&gt;joe@foo.com&lt;/code&gt; 的身份进行连接，就像您试图使用 &lt;code&gt;ssh&lt;/code&gt; 创建终端会话一样。</target>
        </trans-unit>
        <trans-unit id="d646fc6f64023e87f7f5096950ae7ce2f2e80423" translate="yes" xml:space="preserve">
          <source>In order to access any schema object, &lt;code&gt;db_schema:search&lt;/code&gt; permission is required on the containing schema. When an object is referenced without schema qualification, schemas on which this permission is not present will not be searched (just as if the user did not have &lt;code&gt;USAGE&lt;/code&gt; privilege on the schema). If an explicit schema qualification is present, an error will occur if the user does not have the requisite permission on the named schema.</source>
          <target state="translated">为了访问任何模式对象，必须对包含的模式具有 &lt;code&gt;db_schema:search&lt;/code&gt; 权限。当引用的对象没有模式资格时，将不搜索不存在此许可权的模式（就像用户对模式没有 &lt;code&gt;USAGE&lt;/code&gt; 特权一样）。如果存在显式架构限定，则如果用户对命名架构没有必需的权限，则会发生错误。</target>
        </trans-unit>
        <trans-unit id="233299fd5dfd7550c24147ba5661abe08d2d0d86" translate="yes" xml:space="preserve">
          <source>In order to allow the PostgreSQL query planner to make reasonably informed decisions when optimizing queries, the &lt;a href=&quot;catalog-pg-statistic&quot;&gt;&lt;code&gt;pg_statistic&lt;/code&gt;&lt;/a&gt; data should be up-to-date for all tables used in the query. Normally the &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;autovacuum daemon&lt;/a&gt; will take care of that automatically. But if a table has recently had substantial changes in its contents, you might need to do a manual &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; rather than wait for autovacuum to catch up with the changes.</source>
          <target state="translated">为了使PostgreSQL查询计划者在优化查询时能够做出合理的决策，对于查询中使用的所有表，&lt;a href=&quot;catalog-pg-statistic&quot;&gt; &lt;code&gt;pg_statistic&lt;/code&gt; &lt;/a&gt;数据应该是最新的。通常，&lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;autovacuum守护程序&lt;/a&gt;会自动进行处理。但是，如果表的内容最近发生了重大变化，则可能需要进行手动&lt;a href=&quot;sql-analyze&quot;&gt;分析，&lt;/a&gt;而不是等待自动清空以适应变化。</target>
        </trans-unit>
        <trans-unit id="5bbf891d4248cf5667df821377cc8cc7768e14e9" translate="yes" xml:space="preserve">
          <source>In order to be able to copy the initial table data, the role used for the replication connection must have the &lt;code&gt;SELECT&lt;/code&gt; privilege on a published table (or be a superuser).</source>
          <target state="translated">为了能够复制初始表数据，用于复制连接的角色必须对已发布表具有 &lt;code&gt;SELECT&lt;/code&gt; 特权（或成为超级用户）。</target>
        </trans-unit>
        <trans-unit id="fcaf64f5cce00b8df1baf8d751f9011467d9dba7" translate="yes" xml:space="preserve">
          <source>In order to bootstrap the database system, a freshly initialized system always contains one predefined role. This role is always a &amp;ldquo;superuser&amp;rdquo;, and by default (unless altered when running &lt;code&gt;initdb&lt;/code&gt;) it will have the same name as the operating system user that initialized the database cluster. Customarily, this role will be named &lt;code&gt;postgres&lt;/code&gt;. In order to create more roles you first have to connect as this initial role.</source>
          <target state="translated">为了引导数据库系统，新初始化的系统始终包含一个预定义角色。该角色始终是&amp;ldquo;超级用户&amp;rdquo;，并且默认情况下（除非在运行 &lt;code&gt;initdb&lt;/code&gt; 时进行了更改），它将与初始化数据库集群的操作系统用户具有相同的名称。通常，此角色将命名为 &lt;code&gt;postgres&lt;/code&gt; 。为了创建更多角色，您首先必须作为该初始角色进行连接。</target>
        </trans-unit>
        <trans-unit id="c0b6ace4aa733c9f867afeaddbd70b1a3a0b54f3" translate="yes" xml:space="preserve">
          <source>In order to calculate the union, intersection, or difference of two queries, the two queries must be &amp;ldquo;union compatible&amp;rdquo;, which means that they return the same number of columns and the corresponding columns have compatible data types, as described in &lt;a href=&quot;typeconv-union-case&quot;&gt;Section 10.5&lt;/a&gt;.</source>
          <target state="translated">为了计算两个查询的并集，相交或差，两个查询必须是&amp;ldquo;联合兼容的&amp;rdquo;，这意味着它们返回相同数量的列，并且对应的列具有兼容的数据类型，如&lt;a href=&quot;typeconv-union-case&quot;&gt;第10.5节中&lt;/a&gt;所述。</target>
        </trans-unit>
        <trans-unit id="4415b6dbba894170e74bcc6996dbfa1fb24cd8d1" translate="yes" xml:space="preserve">
          <source>In order to create a database, the PostgreSQL server must be up and running (see &lt;a href=&quot;server-start&quot;&gt;Section 18.3&lt;/a&gt;).</source>
          <target state="translated">为了创建数据库，PostgreSQL服务器必须已启动并正在运行（请参见&lt;a href=&quot;server-start&quot;&gt;第18.3节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3f22ae189397eeb8d6d5706a9610e0f700d2bec8" translate="yes" xml:space="preserve">
          <source>In order to emulate a case-insensitive collation as closely as possible, there are &lt;code&gt;citext&lt;/code&gt;-specific versions of a number of string-processing operators and functions. So, for example, the regular expression operators &lt;code&gt;~&lt;/code&gt; and &lt;code&gt;~*&lt;/code&gt; exhibit the same behavior when applied to &lt;code&gt;citext&lt;/code&gt;: they both match case-insensitively. The same is true for &lt;code&gt;!~&lt;/code&gt; and &lt;code&gt;!~*&lt;/code&gt;, as well as for the &lt;code&gt;LIKE&lt;/code&gt; operators &lt;code&gt;~~&lt;/code&gt; and &lt;code&gt;~~*&lt;/code&gt;, and &lt;code&gt;!~~&lt;/code&gt; and &lt;code&gt;!~~*&lt;/code&gt;. If you'd like to match case-sensitively, you can cast the operator's arguments to &lt;code&gt;text&lt;/code&gt;.</source>
          <target state="translated">为了尽可能接近地模拟不区分大小写的排序规则，存在许多字符串处理运算符和函数的特定于 &lt;code&gt;citext&lt;/code&gt; 的版本。因此，例如，将正则表达式运算符 &lt;code&gt;~&lt;/code&gt; 和 &lt;code&gt;~*&lt;/code&gt; 应用于 &lt;code&gt;citext&lt;/code&gt; 时，它们表现出相同的行为：它们都区分大小写。同样是真正的 &lt;code&gt;!~&lt;/code&gt; 和 &lt;code&gt;!~*&lt;/code&gt; ，以及对 &lt;code&gt;LIKE&lt;/code&gt; 操作符 &lt;code&gt;~~&lt;/code&gt; 并 &lt;code&gt;~~*&lt;/code&gt; ，以及 &lt;code&gt;!~~&lt;/code&gt; 和 &lt;code&gt;!~~*&lt;/code&gt; 。如果要区分大小写，可以将运算符的参数转换为 &lt;code&gt;text&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13c4603c579f552910275f0bbcb4deae55ef3a7a" translate="yes" xml:space="preserve">
          <source>In order to function, this module must be loaded via &lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="translated">为了功能，该模块必须通过被加载&lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt;在 &lt;code&gt;postgresql.conf&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="d81c2662b5a84aa8d5b82fab0b4d606e39ebda86" translate="yes" xml:space="preserve">
          <source>In order to measure the run-time cost of each node in the execution plan, the current implementation of &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; adds profiling overhead to query execution. As a result, running &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; on a query can sometimes take significantly longer than executing the query normally. The amount of overhead depends on the nature of the query, as well as the platform being used. The worst case occurs for plan nodes that in themselves require very little time per execution, and on machines that have relatively slow operating system calls for obtaining the time of day.</source>
          <target state="translated">为了衡量执行计划中每个节点的运行时成本， &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 的当前实现将配置开销添加到查询执行中。结果，在查询上运行 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 有时会比正常执行查询花费更长的时间。开销量取决于查询的性质以及所使用的平台。最坏的情况发生在计划节点本身每次执行只需要很少时间的计划节点上，以及在操作系统调用相对较慢的机器上获取一天中的时间的机器上。</target>
        </trans-unit>
        <trans-unit id="8ef25cb15d96bc5ee47cb922c3476dbfcb096c17" translate="yes" xml:space="preserve">
          <source>In order to prevent this, the following applies to all built-in selectivity estimation functions. When planning a query, in order to be able to use stored statistics, the current user must either have &lt;code&gt;SELECT&lt;/code&gt; privilege on the table or the involved columns, or the operator used must be &lt;code&gt;LEAKPROOF&lt;/code&gt; (more accurately, the function that the operator is based on). If not, then the selectivity estimator will behave as if no statistics are available, and the planner will proceed with default or fall-back assumptions.</source>
          <target state="translated">为了防止这种情况，以下内容适用于所有内置的选择性估计功能。在计划查询时，为了能够使用存储的统计信息，当前用户必须对表或所涉及的列具有 &lt;code&gt;SELECT&lt;/code&gt; 特权，或者所使用的运算符必须为 &lt;code&gt;LEAKPROOF&lt;/code&gt; （更准确地说，该运算符所基于的功能）。如果没有，那么选择性估计器将表现为好像没有可用的统计信息一样，并且计划程序将继续使用默认或后备假设。</target>
        </trans-unit>
        <trans-unit id="6b9560d0a190cd0915dff71499a691135e350ab1" translate="yes" xml:space="preserve">
          <source>In ordinary usage, these parameters are set in &lt;code&gt;postgresql.conf&lt;/code&gt;, although superusers can alter them on-the-fly within their own sessions. Typical usage might be:</source>
          <target state="translated">在普通用法中，这些参数在 &lt;code&gt;postgresql.conf&lt;/code&gt; 中设置，尽管超级用户可以在自己的会话中即时更改它们。典型用法可能是：</target>
        </trans-unit>
        <trans-unit id="70a9b455eedcd0013740b57c24d0da08e7b71441" translate="yes" xml:space="preserve">
          <source>In parameters that specify support function names, you can write a schema name if needed, for example &lt;code&gt;SFUNC = public.sum&lt;/code&gt;. Do not write argument types there, however &amp;mdash; the argument types of the support functions are determined from other parameters.</source>
          <target state="translated">在指定支持功能名称的参数中，可以根据需要编写模式名称，例如 &lt;code&gt;SFUNC = public.sum&lt;/code&gt; 。但是，不要在那里写参数类型-支持函数的参数类型由其他参数确定。</target>
        </trans-unit>
        <trans-unit id="e6503b355c17e530acb3ce1cf1b630a12d5c662a" translate="yes" xml:space="preserve">
          <source>In particular, if there's an index on &lt;code&gt;key&lt;/code&gt;, it will probably be used to fetch just the rows having &lt;code&gt;key = 123&lt;/code&gt;. On the other hand, in</source>
          <target state="translated">特别是，如果在 &lt;code&gt;key&lt;/code&gt; 上有一个索引，则它可能仅用于获取 &lt;code&gt;key = 123&lt;/code&gt; 的行。另一方面，在</target>
        </trans-unit>
        <trans-unit id="e4a5dbfbe9955b3dd014a081adfefb7a2337bd07" translate="yes" xml:space="preserve">
          <source>In particular, when a superuser chooses to &lt;code&gt;SET ROLE&lt;/code&gt; to a non-superuser role, they lose their superuser privileges.</source>
          <target state="translated">特别是，当超级用户选择将 &lt;code&gt;SET ROLE&lt;/code&gt; 设置为非超级用户角色时，他们将失去其超级用户特权。</target>
        </trans-unit>
        <trans-unit id="f584b379c3631dcc4c7bd92f0443efdccb5ba563" translate="yes" xml:space="preserve">
          <source>In plain format, tablespaces will be backed up to the same path they have on the source server, unless the option &lt;code&gt;--tablespace-mapping&lt;/code&gt; is used. Without this option, running a plain format base backup on the same host as the server will not work if tablespaces are in use, because the backup would have to be written to the same directory locations as the original tablespaces.</source>
          <target state="translated">除非使用 &lt;code&gt;--tablespace-mapping&lt;/code&gt; 选项，否则表空间将以纯格式备份到与源服务器上相同的路径。如果没有此选项，则在使用表空间的情况下，在与服务器相同的主机上运行纯格式基础备份将不起作用，因为必须将备份写入与原始表空间相同的目录位置。</target>
        </trans-unit>
        <trans-unit id="cc733581aa12ac8119d8135b89e36cf1d9d3b31b" translate="yes" xml:space="preserve">
          <source>In practice one usually relies on the search path for operators, so as not to have to write anything so ugly as that.</source>
          <target state="translated">在实践中,人们通常会依靠搜索路径来寻找操作符,这样就不用写那么难看的东西了。</target>
        </trans-unit>
        <trans-unit id="a48f8184fbeadfd296ca8b91bd2766492182e822" translate="yes" xml:space="preserve">
          <source>In practice the &lt;em&gt;&lt;code&gt;source_sql&lt;/code&gt;&lt;/em&gt; query should always specify &lt;code&gt;ORDER BY 1&lt;/code&gt; to ensure that values with the same &lt;code&gt;row_name&lt;/code&gt; are brought together. However, ordering of the categories within a group is not important. Also, it is essential to be sure that the order of the &lt;em&gt;&lt;code&gt;category_sql&lt;/code&gt;&lt;/em&gt; query's output matches the specified output column order.</source>
          <target state="translated">实际上，&lt;em&gt; &lt;code&gt;source_sql&lt;/code&gt; &lt;/em&gt;查询应始终指定 &lt;code&gt;ORDER BY 1&lt;/code&gt; ,以确保将具有相同 &lt;code&gt;row_name&lt;/code&gt; 的值放在一起。但是，组中类别的排序并不重要。另外，必须确保&lt;em&gt; &lt;code&gt;category_sql&lt;/code&gt; &lt;/em&gt;查询的输出顺序与指定的输出列顺序匹配。</target>
        </trans-unit>
        <trans-unit id="1937c987be0e7b4e7465a2a7029e3f9255be3a60" translate="yes" xml:space="preserve">
          <source>In practice the SQL query should always specify &lt;code&gt;ORDER BY 1,2&lt;/code&gt; to ensure that the input rows are properly ordered, that is, values with the same &lt;code&gt;row_name&lt;/code&gt; are brought together and correctly ordered within the row. Notice that &lt;code&gt;crosstab&lt;/code&gt; itself does not pay any attention to the second column of the query result; it's just there to be ordered by, to control the order in which the third-column values appear across the page.</source>
          <target state="translated">在实践中，SQL查询应始终指定 &lt;code&gt;ORDER BY 1,2&lt;/code&gt; ,以确保输入行正确排序，即，将具有相同 &lt;code&gt;row_name&lt;/code&gt; 的值放在一起并在行内正确排序。注意， &lt;code&gt;crosstab&lt;/code&gt; 本身并不关注查询结果的第二列。它只是在此排序，以控制第三列值在页面上的显示顺序。</target>
        </trans-unit>
        <trans-unit id="81fbb389dcb4a22896ff56ba2f6a26d52f9a0053" translate="yes" xml:space="preserve">
          <source>In practice, it might be best to check the newest child first, if most inserts go into that child. For simplicity, we have shown the trigger's tests in the same order as in other parts of this example.</source>
          <target state="translated">在实践中,如果大多数插入都进入了最新的子代,那么最好先检查该子代。为了简单起见,我们以与本例其他部分相同的顺序来显示触发器的测试。</target>
        </trans-unit>
        <trans-unit id="06e0b2a62cd9f4eb01f119bc558152c7a9b61c4c" translate="yes" xml:space="preserve">
          <source>In practice, these commands would be wrapped up in an extension.</source>
          <target state="translated">在实践中,这些命令将被包裹在一个扩展中。</target>
        </trans-unit>
        <trans-unit id="79f48feff09a5e6beb49de65d5ed928eb6a28410" translate="yes" xml:space="preserve">
          <source>In principle, cross-references from one initial catalog row to another could be written just by writing the preassigned OID of the referenced row in the referencing field. However, that is against project policy, because it is error-prone, hard to read, and subject to breakage if a newly-assigned OID is renumbered. Therefore &lt;code&gt;genbki.pl&lt;/code&gt; provides mechanisms to write symbolic references instead. The rules are as follows:</source>
          <target state="translated">原则上，从一个初始目录行到另一初始目录行的交叉引用可以仅通过在引用字段中写入被引用行的预分配OID来编写。但是，这违反了项目策略，因为它容易出错，难以读取，并且如果重新分配了新分配的OID可能会损坏。因此， &lt;code&gt;genbki.pl&lt;/code&gt; 提供了替代的方式来编写符号引用。规则如下：</target>
        </trans-unit>
        <trans-unit id="760cef4da4decce6f6d9b7cb2f206b14f10f3fa4" translate="yes" xml:space="preserve">
          <source>In principle, index-only scans can be used with expression indexes. For example, given an index on &lt;code&gt;f(x)&lt;/code&gt; where &lt;code&gt;x&lt;/code&gt; is a table column, it should be possible to execute</source>
          <target state="translated">原则上，仅索引扫描可以与表达式索引一起使用。例如，给定 &lt;code&gt;f(x)&lt;/code&gt; 的索引，其中 &lt;code&gt;x&lt;/code&gt; 是表列，则应该可以执行</target>
        </trans-unit>
        <trans-unit id="50939af3586cb58faf973e37d044bc572b91198e" translate="yes" xml:space="preserve">
          <source>In principle, one can use &lt;code&gt;to_tsquery&lt;/code&gt; if you quote the argument:</source>
          <target state="translated">原则上，如果引用以下参数，则可以使用 &lt;code&gt;to_tsquery&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="25c4a2a950655d8b26ffa359e0be687cbb7c81cd" translate="yes" xml:space="preserve">
          <source>In principle, we could do an index-only scan on this index to satisfy a query like</source>
          <target state="translated">原则上,我们可以在这个索引上做一个只针对索引的扫描,以满足像这样的查询</target>
        </trans-unit>
        <trans-unit id="5a138e4bb79a7d66b0d4bfaffdffcdcbb5964acf" translate="yes" xml:space="preserve">
          <source>In prior releases of PostgreSQL, this was the default except for the &lt;code&gt;stop&lt;/code&gt; mode.</source>
          <target state="translated">在先前的PostgreSQL发行版中，这是默认的模式（ &lt;code&gt;stop&lt;/code&gt; 模式除外）。</target>
        </trans-unit>
        <trans-unit id="75324ba26fc4965d2196117750a2a1059aac25a6" translate="yes" xml:space="preserve">
          <source>In prompt 1 normally &lt;code&gt;=&lt;/code&gt;, but &lt;code&gt;@&lt;/code&gt; if the session is in an inactive branch of a conditional block, or &lt;code&gt;^&lt;/code&gt; if in single-line mode, or &lt;code&gt;!&lt;/code&gt; if the session is disconnected from the database (which can happen if &lt;code&gt;\connect&lt;/code&gt; fails). In prompt 2 &lt;code&gt;%R&lt;/code&gt; is replaced by a character that depends on why psql expects more input: &lt;code&gt;-&lt;/code&gt; if the command simply wasn't terminated yet, but &lt;code&gt;*&lt;/code&gt; if there is an unfinished &lt;code&gt;/* ... */&lt;/code&gt; comment, a single quote if there is an unfinished quoted string, a double quote if there is an unfinished quoted identifier, a dollar sign if there is an unfinished dollar-quoted string, or &lt;code&gt;(&lt;/code&gt; if there is an unmatched left parenthesis. In prompt 3 &lt;code&gt;%R&lt;/code&gt; doesn't produce anything.</source>
          <target state="translated">在提示1中，通常 &lt;code&gt;=&lt;/code&gt; ，但是 &lt;code&gt;@&lt;/code&gt; 如果会话在条件块的非活动分支中，则@；如果在单行模式下则为 &lt;code&gt;^&lt;/code&gt; ，否则为 &lt;code&gt;!&lt;/code&gt; 如果会话与数据库断开连接（如果 &lt;code&gt;\connect&lt;/code&gt; 失败，则可能发生）。在提示符2中， &lt;code&gt;%R&lt;/code&gt; 被一个字符替换，该字符取决于psql期望更多输入的原因： &lt;code&gt;-&lt;/code&gt; 如果命令尚未终止，则 &lt;code&gt;*&lt;/code&gt; ,如果 &lt;code&gt;/* ... */&lt;/code&gt; 未完成/ * ... * /注释，则单引号有一个未完成的带引号的字符串，如果有一个未完成的带引号的标识符，则使用双引号；如果有一个未完成的带美元报价的字符串，则加一个美元符号，或者 &lt;code&gt;(&lt;/code&gt; 如果有不匹配的左括号。在提示符下3 &lt;code&gt;%R&lt;/code&gt; 不会产生任何结果。</target>
        </trans-unit>
        <trans-unit id="55492f505092f7907e8e04b3d9f069e610e9bef1" translate="yes" xml:space="preserve">
          <source>In reference to a &lt;a href=&quot;glossary#GLOSSARY-DATUM&quot;&gt;datum&lt;/a&gt;: the fact that its value cannot be broken down into smaller components.</source>
          <target state="translated">关于&lt;a href=&quot;glossary#GLOSSARY-DATUM&quot;&gt;基准&lt;/a&gt;：不能将其值分解为较小的组成部分的事实。</target>
        </trans-unit>
        <trans-unit id="e2af2f18b8bb379f6a3aaec125d379cfd0547daa" translate="yes" xml:space="preserve">
          <source>In reference to a &lt;a href=&quot;glossary#GLOSSARY-PARTITIONED-TABLE&quot;&gt;partitioned table&lt;/a&gt;: One of the tables that each contain part of the data of the partitioned table, which is said to be the &lt;em&gt;parent&lt;/em&gt;. The partition is itself a table, so it can also be queried directly; at the same time, a partition can sometimes be a partitioned table, allowing hierarchies to be created.</source>
          <target state="translated">关于&lt;a href=&quot;glossary#GLOSSARY-PARTITIONED-TABLE&quot;&gt;分区表&lt;/a&gt;：其中一个表，每个表都包含分区表的部分数据，这些数据被称为&lt;em&gt;父表&lt;/em&gt;。分区本身就是一个表，因此也可以直接查询它；同时，一个分区有时可以是一个分区表，从而允许创建层次结构。</target>
        </trans-unit>
        <trans-unit id="5c9e089ab97a2e09bac9e2f25d906ab6733e4ee0" translate="yes" xml:space="preserve">
          <source>In reference to a &lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;database transaction&lt;/a&gt;: see &lt;a href=&quot;glossary#GLOSSARY-ATOMICITY&quot;&gt;atomicity&lt;/a&gt;.</source>
          <target state="translated">关于&lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;数据库事务&lt;/a&gt;：请参见&lt;a href=&quot;glossary#GLOSSARY-ATOMICITY&quot;&gt;原子性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f06a3856f982e3b72fb625608048db8b0f9e532d" translate="yes" xml:space="preserve">
          <source>In reference to a &lt;a href=&quot;glossary#GLOSSARY-WINDOW-FUNCTION&quot;&gt;window function&lt;/a&gt; in a &lt;a href=&quot;glossary#GLOSSARY-QUERY&quot;&gt;query&lt;/a&gt;, a partition is a user-defined criterion that identifies which neighboring &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;rows&lt;/a&gt; of the &lt;a href=&quot;glossary#GLOSSARY-RESULT-SET&quot;&gt;query's result set&lt;/a&gt; can be considered by the function.</source>
          <target state="translated">在参照本发明的&lt;a href=&quot;glossary#GLOSSARY-WINDOW-FUNCTION&quot;&gt;窗函数&lt;/a&gt;在一个&lt;a href=&quot;glossary#GLOSSARY-QUERY&quot;&gt;查询&lt;/a&gt;，分区是一个用户定义的标准，即哪个相邻标识&lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;行&lt;/a&gt;的的&lt;a href=&quot;glossary#GLOSSARY-RESULT-SET&quot;&gt;查询的结果集&lt;/a&gt;可以由函数被考虑。</target>
        </trans-unit>
        <trans-unit id="ce53e0d0da47b411803cd409013625a3f9ae5431" translate="yes" xml:space="preserve">
          <source>In releases of PostgreSQL before 13 there was no &lt;code&gt;xid8&lt;/code&gt; type, so variants of these functions were provided that used &lt;code&gt;bigint&lt;/code&gt; to represent a 64-bit XID, with a correspondingly distinct snapshot data type &lt;code&gt;txid_snapshot&lt;/code&gt;. These older functions have &lt;code&gt;txid&lt;/code&gt; in their names. They are still supported for backward compatibility, but may be removed from a future release. See &lt;a href=&quot;functions-info#FUNCTIONS-TXID-SNAPSHOT&quot;&gt;Table 9.76&lt;/a&gt;.</source>
          <target state="translated">在13之前的PostgreSQL发行版中，没有 &lt;code&gt;xid8&lt;/code&gt; 类型，因此提供了这些函数的变体，这些变体使用 &lt;code&gt;bigint&lt;/code&gt; 表示64位XID，并具有相应不同的快照数据类型 &lt;code&gt;txid_snapshot&lt;/code&gt; 。这些较早的函数的名称中包含 &lt;code&gt;txid&lt;/code&gt; 。仍支持它们以实现向后兼容，但将来的版本中可能会删除它们。请参阅&lt;a href=&quot;functions-info#FUNCTIONS-TXID-SNAPSHOT&quot;&gt;表9.76&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d2a64129f0b1da1e51ed964ad4579c4ce899b50b" translate="yes" xml:space="preserve">
          <source>In releases prior to 9.6, this parameter also allowed the values &lt;code&gt;archive&lt;/code&gt; and &lt;code&gt;hot_standby&lt;/code&gt;. These are still accepted but mapped to &lt;code&gt;replica&lt;/code&gt;.</source>
          <target state="translated">在9.6之前的版本中，此参数还允许值 &lt;code&gt;archive&lt;/code&gt; 和 &lt;code&gt;hot_standby&lt;/code&gt; 。这些仍被接受，但映射到 &lt;code&gt;replica&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa88d3807e10330acdc1940359127a25a966338d" translate="yes" xml:space="preserve">
          <source>In short then, the most general recipe for removing a role that has been used to own objects is:</source>
          <target state="translated">那么简而言之,删除一个已经被用来拥有对象的角色的最一般的秘诀就是。</target>
        </trans-unit>
        <trans-unit id="d436b991362b7fed721dd789926c009b129d872d" translate="yes" xml:space="preserve">
          <source>In short, this is the difference between abbreviations and full names: abbreviations represent a specific offset from UTC, whereas many of the full names imply a local daylight-savings time rule, and so have two possible UTC offsets. As an example, &lt;code&gt;2014-06-04 12:00 America/New_York&lt;/code&gt; represents noon local time in New York, which for this particular date was Eastern Daylight Time (UTC-4). So &lt;code&gt;2014-06-04 12:00 EDT&lt;/code&gt; specifies that same time instant. But &lt;code&gt;2014-06-04 12:00 EST&lt;/code&gt; specifies noon Eastern Standard Time (UTC-5), regardless of whether daylight savings was nominally in effect on that date.</source>
          <target state="translated">简而言之，这是缩写和全名之间的区别：缩写表示相对于UTC的特定偏移量，而许多全名暗示着当地的夏时制规则，因此具有两个可能的UTC偏移量。例如， &lt;code&gt;2014-06-04 12:00 America/New_York&lt;/code&gt; 代表纽约当地时间中午，这个特定日期是美国东部夏令时间（UTC-4）。因此， &lt;code&gt;2014-06-04 12:00 EDT&lt;/code&gt; 指定了同一时刻。但 &lt;code&gt;2014-06-04 12:00 EST&lt;/code&gt; 指定东部标准时间（UTC-5）中午，无论该日期的夏令时名义上是否生效。</target>
        </trans-unit>
        <trans-unit id="6f11576d9f6f09df7ddccd8a08208061f234c7e9" translate="yes" xml:space="preserve">
          <source>In short, when an RE contains both greedy and non-greedy subexpressions, the total match length is either as long as possible or as short as possible, according to the attribute assigned to the whole RE. The attributes assigned to the subexpressions only affect how much of that match they are allowed to &amp;ldquo;eat&amp;rdquo; relative to each other.</source>
          <target state="translated">简而言之，当一个RE同时包含贪婪和非贪婪子表达式时，根据分配给整个RE的属性，总匹配长度要么尽可能长，要么尽可能短。分配给子表达式的属性仅影响允许它们相对于彼此&amp;ldquo;吃掉&amp;rdquo;的匹配数量。</target>
        </trans-unit>
        <trans-unit id="aee830ec2c7b69b7f24b10ee81fb051f88d3ea9e" translate="yes" xml:space="preserve">
          <source>In short, while an index-only scan is possible given the two fundamental requirements, it will be a win only if a significant fraction of the table's heap pages have their all-visible map bits set. But tables in which a large fraction of the rows are unchanging are common enough to make this type of scan very useful in practice.</source>
          <target state="translated">简而言之,虽然考虑到两个基本要求,只扫描索引是可能的,但只有当表的堆页中有相当一部分设置了它们的全可见映射位时,这种扫描才是胜利的。但是有很大一部分行不变的表是很常见的,这使得这种类型的扫描在实践中非常有用。</target>
        </trans-unit>
        <trans-unit id="81308d755ee35ef99db2fb46ff2f6ea4fdc54a8b" translate="yes" xml:space="preserve">
          <source>In simple cases, the concatenation operator discussed above is preferred over direct use of these functions. However, because the concatenation operator is overloaded to serve all three cases, there are situations where use of one of the functions is helpful to avoid ambiguity. For example consider:</source>
          <target state="translated">在简单的情况下,上面讨论的连接运算符比直接使用这些函数更可取。然而,由于连词运算符在这三种情况下都是超载的,所以在某些情况下,使用其中一个函数有助于避免歧义。例如考虑一下。</target>
        </trans-unit>
        <trans-unit id="4e5a889e9ac805b7a61b2cef1759227b4c01dc82" translate="yes" xml:space="preserve">
          <source>In some cases &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; shows additional execution statistics beyond the plan node execution times and row counts. For example, Sort and Hash nodes provide extra information:</source>
          <target state="translated">在某些情况下， &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 会显示计划节点执行时间和行数以外的其他执行统计信息。例如，&amp;ldquo;排序&amp;rdquo;和&amp;ldquo;哈希&amp;rdquo;节点提供了额外的信息：</target>
        </trans-unit>
        <trans-unit id="e8c81b00bcb69c8ee6819bdd31891ee097641a10" translate="yes" xml:space="preserve">
          <source>In some cases it is possible for a single SQL command to fire more than one kind of trigger. For instance an &lt;code&gt;INSERT&lt;/code&gt; with an &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clause may cause both insert and update operations, so it will fire both kinds of triggers as needed. The transition relations supplied to triggers are specific to their event type; thus an &lt;code&gt;INSERT&lt;/code&gt; trigger will see only the inserted rows, while an &lt;code&gt;UPDATE&lt;/code&gt; trigger will see only the updated rows.</source>
          <target state="translated">在某些情况下，单个SQL命令可能会触发一种以上的触发器。例如，带有 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 子句的 &lt;code&gt;INSERT&lt;/code&gt; 可能同时引起插入和更新操作，因此它将根据需要触发两种触发器。提供给触发器的过渡关系特定于它们的事件类型。因此， &lt;code&gt;INSERT&lt;/code&gt; 触发器将仅看到插入的行，而 &lt;code&gt;UPDATE&lt;/code&gt; 触发器将仅看到更新的行。</target>
        </trans-unit>
        <trans-unit id="f8731dce3dc14a003f46fc2608e777589eba29c9" translate="yes" xml:space="preserve">
          <source>In some cases it is useful to define table functions that can return different column sets depending on how they are invoked. To support this, the table function can be declared as returning the pseudo-type &lt;code&gt;record&lt;/code&gt; with no &lt;code&gt;OUT&lt;/code&gt; parameters. When such a function is used in a query, the expected row structure must be specified in the query itself, so that the system can know how to parse and plan the query. This syntax looks like:</source>
          <target state="translated">在某些情况下，定义可以根据调用方式返回不同列集的表函数很有用。为此，可以将表函数声明为返回不带 &lt;code&gt;OUT&lt;/code&gt; 参数的伪类型 &lt;code&gt;record&lt;/code&gt; 。在查询中使用此类函数时，必须在查询本身中指定预期的行结构，以便系统知道如何解析和计划查询。该语法如下所示：</target>
        </trans-unit>
        <trans-unit id="200831069c2086edb298c7a6b5677910ac8d156b" translate="yes" xml:space="preserve">
          <source>In some cases it is useful to define table functions that can return different column sets depending on how they are invoked. To support this, the table function can be declared as returning the pseudo-type &lt;code&gt;record&lt;/code&gt;. When such a function is used in a query, the expected row structure must be specified in the query itself, so that the system can know how to parse and plan the query. This syntax looks like:</source>
          <target state="translated">在某些情况下，定义可以根据调用方式返回不同列集的表函数很有用。为此，可以将table函数声明为返回伪类型 &lt;code&gt;record&lt;/code&gt; 。在查询中使用此类函数时，必须在查询本身中指定预期的行结构，以便系统知道如何解析和计划查询。该语法如下：</target>
        </trans-unit>
        <trans-unit id="6d89a4f32e25e9b6f4b0aae8fa4c3b33eb2b87fd" translate="yes" xml:space="preserve">
          <source>In some cases it might also be necessary to increase &lt;code&gt;SEMMAP&lt;/code&gt; to be at least on the order of &lt;code&gt;SEMMNS&lt;/code&gt;. If the system has this parameter (many do not), it defines the size of the semaphore resource map, in which each contiguous block of available semaphores needs an entry. When a semaphore set is freed it is either added to an existing entry that is adjacent to the freed block or it is registered under a new map entry. If the map is full, the freed semaphores get lost (until reboot). Fragmentation of the semaphore space could over time lead to fewer available semaphores than there should be.</source>
          <target state="translated">在某些情况下，可能还需要将 &lt;code&gt;SEMMAP&lt;/code&gt; 增加到至少 &lt;code&gt;SEMMNS&lt;/code&gt; 的数量级。如果系统具有此参数（很多没有），则它定义信号灯资源映射的大小，其中每个相邻的可用信号灯块都需要一个条目。释放信号集后，它将被添加到与释放的块相邻的现有条目中，或者将其注册在新的映射条目下。如果映射已满，则释放的信号量会丢失（直到重新启动）。随着时间的流逝，信号量空间的碎片化可能导致可用信号量少于应有的数量。</target>
        </trans-unit>
        <trans-unit id="c2c835a0ebddfd298ae5463818241acfed988912" translate="yes" xml:space="preserve">
          <source>In some cases several distinct distributions are needed which don't correlate with each other and this is when implicit seed parameter comes in handy:</source>
          <target state="translated">在某些情况下,需要几个不同的分布,而这些分布之间并不相关,这时隐式种子参数就派上用场了。</target>
        </trans-unit>
        <trans-unit id="b659c8baf607682082fc2a028333f1abc817539f" translate="yes" xml:space="preserve">
          <source>In some cases the join style is easier to write or faster to execute than the sub-select style.</source>
          <target state="translated">在某些情况下,连接样式比子选择样式更容易编写或更快执行。</target>
        </trans-unit>
        <trans-unit id="cc280a2801256511a801ad6396d782aaf11a1fd5" translate="yes" xml:space="preserve">
          <source>In some cases the planner will prefer a &amp;ldquo;simple&amp;rdquo; index scan plan:</source>
          <target state="translated">在某些情况下，计划人员将首选&amp;ldquo;简单&amp;rdquo;的索引扫描计划：</target>
        </trans-unit>
        <trans-unit id="0752bfbb1e8e2f35c9e16d26381cb349bc520d2f" translate="yes" xml:space="preserve">
          <source>In some cases you might wish to know which table a particular row originated from. There is a system column called &lt;code&gt;tableoid&lt;/code&gt; in each table which can tell you the originating table:</source>
          <target state="translated">在某些情况下，您可能希望知道特定行来自哪个表。每个表中都有一个名为 &lt;code&gt;tableoid&lt;/code&gt; 的系统列，它可以告诉您原始表：</target>
        </trans-unit>
        <trans-unit id="85aa180babf965f446d9b4ca6c81be1df71986fd" translate="yes" xml:space="preserve">
          <source>In some cases, a user will know that a given XPath query will return only a single result (perhaps a unique document identifier) &amp;mdash; if used alongside an XPath query returning multiple results, the single-valued result will appear only on the first row of the result. The solution to this is to use the key field as part of a join against a simpler XPath query. As an example:</source>
          <target state="translated">在某些情况下，用户会知道给定的XPath查询将仅返回单个结果（也许是唯一的文档标识符）-如果与返回多个结果的XPath查询一起使用，则单值结果将仅出现在X的第一行结果。解决方案是将键字段用作对简单XPath查询的联接的一部分。举个例子：</target>
        </trans-unit>
        <trans-unit id="ca377880ca6732de73ffe88d7d610d10f88a2a04" translate="yes" xml:space="preserve">
          <source>In some cases, an external storage product can be accessed either via NFS or a lower-level protocol such as iSCSI. In the latter case, the storage appears as a block device and any available file system can be created on it. That approach might relieve the DBA from having to deal with some of the idiosyncrasies of NFS, but of course the complexity of managing remote storage then happens at other levels.</source>
          <target state="translated">在某些情况下,可以通过NFS或iSCSI等低级协议访问外部存储产品。在后一种情况下,存储以块设备的形式出现,可以在其上创建任何可用的文件系统。这种方法可能会减轻DBA对NFS的一些特殊性的处理,但当然,管理远程存储的复杂性就会发生在其他层次上。</target>
        </trans-unit>
        <trans-unit id="4cdce5fe180ac016fd38728542336a4cccb6659d" translate="yes" xml:space="preserve">
          <source>In some cases, queries with visibly different texts might get merged into a single &lt;code&gt;pg_stat_statements&lt;/code&gt; entry. Normally this will happen only for semantically equivalent queries, but there is a small chance of hash collisions causing unrelated queries to be merged into one entry. (This cannot happen for queries belonging to different users or databases, however.)</source>
          <target state="translated">在某些情况下，文本明显不同的查询可能会合并到一个 &lt;code&gt;pg_stat_statements&lt;/code&gt; 条目中。通常，这仅会在语义上等效的查询中发生，但是散列冲突会导致不相关的查询合并到一个条目中的可能性很小。 （但是，这对于属于不同用户或数据库的查询不会发生。）</target>
        </trans-unit>
        <trans-unit id="3587765c2705ba8328ac5e625d50c99ae816e4fe" translate="yes" xml:space="preserve">
          <source>In some contexts it is important to be sure that row security is not being applied. For example, when taking a backup, it could be disastrous if row security silently caused some rows to be omitted from the backup. In such a situation, you can set the &lt;a href=&quot;runtime-config-client#GUC-ROW-SECURITY&quot;&gt;row_security&lt;/a&gt; configuration parameter to &lt;code&gt;off&lt;/code&gt;. This does not in itself bypass row security; what it does is throw an error if any query's results would get filtered by a policy. The reason for the error can then be investigated and fixed.</source>
          <target state="translated">在某些情况下，确保未应用行安全性很重要。例如，进行备份时，如果行安全性导致在备份中忽略了某些行，则可能是灾难性的。在这种情况下，可以将&lt;a href=&quot;runtime-config-client#GUC-ROW-SECURITY&quot;&gt;row_security&lt;/a&gt;配置参数设置为 &lt;code&gt;off&lt;/code&gt; 。这本身并不绕过行安全性；如果任何查询的结果将被策略过滤，它会引发错误。然后可以调查并确定错误原因。</target>
        </trans-unit>
        <trans-unit id="b9ce77934cf9885a03a2ac3b7887461d3a1cb010" translate="yes" xml:space="preserve">
          <source>In some contexts, backslashes must be doubled compared to what is shown above, because the generic string-literal parser will also reduce pairs of backslashes to one data character; see &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;Section 4.1.2.1&lt;/a&gt;.</source>
          <target state="translated">在某些情况下，与上面显示的相比，反斜杠必须加倍，因为通用字符串文字解析器还将减少成对的反斜杠为一个数据字符。参见&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;第4.1.2.1节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ad2914b6fce7d3aa951198848f0bae1a566122fb" translate="yes" xml:space="preserve">
          <source>In some query plans, it is possible for a subplan node to be executed more than once. For example, the inner index scan will be executed once per outer row in the above nested-loop plan. In such cases, the &lt;code&gt;loops&lt;/code&gt; value reports the total number of executions of the node, and the actual time and rows values shown are averages per-execution. This is done to make the numbers comparable with the way that the cost estimates are shown. Multiply by the &lt;code&gt;loops&lt;/code&gt; value to get the total time actually spent in the node. In the above example, we spent a total of 0.220 milliseconds executing the index scans on &lt;code&gt;tenk2&lt;/code&gt;.</source>
          <target state="translated">在某些查询计划中，子计划节点可能会执行多次。例如，在上面的嵌套循环计划中，内部索引扫描将对每个外部行执行一次。在这种情况下， &lt;code&gt;loops&lt;/code&gt; 值将报告该节点的执行总数，并且显示的实际时间和行值是每次执行的平均值。这样做是为了使数字与显示成本估算的方式具有可比性。乘以 &lt;code&gt;loops&lt;/code&gt; 值即可得出该节点实际花费的总时间。在上面的示例中，我们总共花费了0.220毫秒在 &lt;code&gt;tenk2&lt;/code&gt; 上执行索引扫描。</target>
        </trans-unit>
        <trans-unit id="225981494667f7eae039a8f3a624ead9ac2ba414" translate="yes" xml:space="preserve">
          <source>In some situations it is worthwhile to rebuild indexes periodically with the &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt; command or a series of individual rebuilding steps.</source>
          <target state="translated">在某些情况下，值得使用&lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt;命令或一系列单独的重建步骤定期重建索引。</target>
        </trans-unit>
        <trans-unit id="c7e0f45ec00183e0785ecaf537d621d39641ace7" translate="yes" xml:space="preserve">
          <source>In some situations, examining each possible way in which a query can be executed would take an excessive amount of time and memory space. In particular, this occurs when executing queries involving large numbers of join operations. In order to determine a reasonable (not necessarily optimal) query plan in a reasonable amount of time, PostgreSQL uses a &lt;em&gt;Genetic Query Optimizer&lt;/em&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/geqo.html&quot;&gt;Chapter 59&lt;/a&gt;) when the number of joins exceeds a threshold (see &lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt;).</source>
          <target state="translated">在某些情况下，检查执行查询的每种可能方式都将花费大量时间和内存空间。特别是在执行涉及大量联接操作的查询时，会发生这种情况。为了在合理的时间内确定合理的（不一定是最佳的）查询计划，当连接数超过阈值（请参见&lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt;）时，PostgreSQL使用&lt;em&gt;遗传查询优化器&lt;/em&gt;（请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/geqo.html&quot;&gt;第59章&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="02656e92c47f92204fc3dc37bed1c7e28f95de50" translate="yes" xml:space="preserve">
          <source>In some situations, examining each possible way in which a query can be executed would take an excessive amount of time and memory space. In particular, this occurs when executing queries involving large numbers of join operations. In order to determine a reasonable (not necessarily optimal) query plan in a reasonable amount of time, PostgreSQL uses a &lt;em&gt;Genetic Query Optimizer&lt;/em&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/13/geqo.html&quot;&gt;Chapter 59&lt;/a&gt;) when the number of joins exceeds a threshold (see &lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt;).</source>
          <target state="translated">在某些情况下，检查执行查询的每种可能方式都将花费大量时间和内存空间。特别是在执行涉及大量联接操作的查询时，会发生这种情况。为了在合理的时间内确定合理的（不一定是最佳的）查询计划，当连接数超过阈值（请参见&lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt;）时，PostgreSQL使用&lt;em&gt;遗传查询优化器&lt;/em&gt;（请参见&lt;a href=&quot;https://www.postgresql.org/docs/13/geqo.html&quot;&gt;第59章&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b44a40fdd52559ad494c2c8c248a6de473d41182" translate="yes" xml:space="preserve">
          <source>In standby mode, the server continuously applies WAL received from the master server. The standby server can read WAL from a WAL archive (see &lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;restore_command&lt;/a&gt;) or directly from the master over a TCP connection (streaming replication). The standby server will also attempt to restore any WAL found in the standby cluster's &lt;code&gt;pg_wal&lt;/code&gt; directory. That typically happens after a server restart, when the standby replays again WAL that was streamed from the master before the restart, but you can also manually copy files to &lt;code&gt;pg_wal&lt;/code&gt; at any time to have them replayed.</source>
          <target state="translated">在待机模式下，服务器连续应用从主服务器接收到的WAL。备用服务器可以从WAL存档中读取WAL（请参见&lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;restore_command&lt;/a&gt;），也可以直接通过TCP连接从主服务器中读取WAL （流复制）。备用服务器还将尝试还原在备用群集的 &lt;code&gt;pg_wal&lt;/code&gt; 目录中找到的所有WAL 。这通常发生在服务器重启后，当备用服务器再次重放在重启之前从主服务器流式传输的WAL时，但是您也可以随时手动将文件复制到 &lt;code&gt;pg_wal&lt;/code&gt; 来重放它们。</target>
        </trans-unit>
        <trans-unit id="fe531d3ac4f289af249052c7bd344a8eccac974a" translate="yes" xml:space="preserve">
          <source>In strict SQL, &lt;code&gt;GROUP BY&lt;/code&gt; can only group by columns of the source table but PostgreSQL extends this to also allow &lt;code&gt;GROUP BY&lt;/code&gt; to group by columns in the select list. Grouping by value expressions instead of simple column names is also allowed.</source>
          <target state="translated">在严格的SQL中， &lt;code&gt;GROUP BY&lt;/code&gt; 只能按源表的列进行分组，但是PostgreSQL对此进行了扩展，以允许 &lt;code&gt;GROUP BY&lt;/code&gt; 可以按选择列表中的列进行分组。也允许按值表达式而不是简单的列名分组。</target>
        </trans-unit>
        <trans-unit id="925d63461b4ad93eaf09cda8debcd8a2f6185160" translate="yes" xml:space="preserve">
          <source>In such a column, all entries must use the symbolic format except when writing &lt;code&gt;0&lt;/code&gt; for InvalidOid. (If the column is declared &lt;code&gt;regproc&lt;/code&gt;, you can optionally write &lt;code&gt;-&lt;/code&gt; instead of &lt;code&gt;0&lt;/code&gt;.) &lt;code&gt;genbki.pl&lt;/code&gt; will warn about unrecognized names.</source>
          <target state="translated">在这样的列中，除了为InvalidOid 写入 &lt;code&gt;0&lt;/code&gt; 之外，所有条目都必须使用符号格式。（如果将该列声明为 &lt;code&gt;regproc&lt;/code&gt; ，则可以选择写入 &lt;code&gt;-&lt;/code&gt; 而不是 &lt;code&gt;0&lt;/code&gt; 。） &lt;code&gt;genbki.pl&lt;/code&gt; 将警告无法识别的名称。</target>
        </trans-unit>
        <trans-unit id="f44470ab677292f080ad629e5021dd422bb50329" translate="yes" xml:space="preserve">
          <source>In synchronous multimaster replication, each server can accept write requests, and modified data is transmitted from the original server to every other server before each transaction commits. Heavy write activity can cause excessive locking and commit delays, leading to poor performance. Read requests can be sent to any server. Some implementations use shared disk to reduce the communication overhead. Synchronous multimaster replication is best for mostly read workloads, though its big advantage is that any server can accept write requests &amp;mdash; there is no need to partition workloads between master and standby servers, and because the data changes are sent from one server to another, there is no problem with non-deterministic functions like &lt;code&gt;random()&lt;/code&gt;.</source>
          <target state="translated">在同步多主复制中，每个服务器都可以接受写请求，并且在每个事务提交之前，已修改的数据将从原始服务器传输到每个其他服务器。繁重的写入活动可能导致过多的锁定和提交延迟，从而导致性能下降。读取请求可以发送到任何服务器。一些实现使用共享磁盘来减少通信开销。同步多主复制最适合大多数读取工作负载，尽管它的最大优点是任何服务器都可以接受写请求-无需在主服务器和备用服务器之间划分工作负载，并且由于数据更改是从一台服务器发送到另一台服务器的，因此像 &lt;code&gt;random()&lt;/code&gt; 这样的不确定函数没有问题。</target>
        </trans-unit>
        <trans-unit id="7c4b878fdf07a28c13f143cacc8a5bb3f8880019" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;.affix&lt;/code&gt; file every affix flag is described in the following format:</source>
          <target state="translated">在 &lt;code&gt;.affix&lt;/code&gt; 文件中，每个词缀标志均以以下格式描述：</target>
        </trans-unit>
        <trans-unit id="08a1ad04eb220026fbfc94b398836d4cbc2cae8c" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;offset&lt;/code&gt;&lt;code&gt;PRECEDING&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt;&lt;code&gt;FOLLOWING&lt;/code&gt; frame options, the &lt;code&gt;offset&lt;/code&gt; must be an expression not containing any variables, aggregate functions, or window functions. The meaning of the &lt;code&gt;offset&lt;/code&gt; depends on the frame mode:</source>
          <target state="translated">在 &lt;code&gt;offset&lt;/code&gt; &lt;code&gt;PRECEDING&lt;/code&gt; 和 &lt;code&gt;offset&lt;/code&gt; &lt;code&gt;FOLLOWING&lt;/code&gt; 帧选项中， &lt;code&gt;offset&lt;/code&gt; 必须是不包含任何变量，聚合函数或窗口函数的表达式。 &lt;code&gt;offset&lt;/code&gt; 的含义取决于帧模式：</target>
        </trans-unit>
        <trans-unit id="27bf78dd19410e50d81449e21eeb4a9c340ecbaa" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;prepared&lt;/code&gt; mode, pgbench reuses the parse analysis result starting from the second query iteration, so pgbench runs faster than in other modes.</source>
          <target state="translated">在 &lt;code&gt;prepared&lt;/code&gt; 模式下，pgbench从第二次查询迭代开始重用解析分析结果，因此pgbench的运行速度比其他模式下更快。</target>
        </trans-unit>
        <trans-unit id="7dd20a44a8914e7e3854e6b8cc2dd765d950b1b2" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;template0&lt;/code&gt; database, it could be useful to create collations whose encoding does not match the database encoding, since they could match the encodings of databases later cloned from &lt;code&gt;template0&lt;/code&gt;. This would currently have to be done manually.</source>
          <target state="translated">在 &lt;code&gt;template0&lt;/code&gt; 数据库中，创建其编码与数据库编码不匹配的排序规则可能很有用，因为它们可以与后来从 &lt;code&gt;template0&lt;/code&gt; 克隆的数据库的编码匹配。目前，这必须手动完成。</target>
        </trans-unit>
        <trans-unit id="ee7442c19df868ba3ec76972f6eb3be85838007a" translate="yes" xml:space="preserve">
          <source>In the ISO week-numbering system, it is possible for early-January dates to be part of the 52nd or 53rd week of the previous year, and for late-December dates to be part of the first week of the next year. For example, &lt;code&gt;2005-01-01&lt;/code&gt; is part of the 53rd week of year 2004, and &lt;code&gt;2006-01-01&lt;/code&gt; is part of the 52nd week of year 2005, while &lt;code&gt;2012-12-31&lt;/code&gt; is part of the first week of 2013. It's recommended to use the &lt;code&gt;isoyear&lt;/code&gt; field together with &lt;code&gt;week&lt;/code&gt; to get consistent results.</source>
          <target state="translated">在ISO周编号系统中，一月初的日期可能是上一年的第52或53周的一部分，而十二月末的日期可能是下一年的第一周的一部分。例如， &lt;code&gt;2005-01-01&lt;/code&gt; 是2004年第53周的一部分，而 &lt;code&gt;2006-01-01&lt;/code&gt; 是2005年第52周的一部分，而 &lt;code&gt;2012-12-31&lt;/code&gt; 是2013年第一周的一部分。推荐使用 &lt;code&gt;isoyear&lt;/code&gt; 一起字段 &lt;code&gt;week&lt;/code&gt; 得到一致的结果。</target>
        </trans-unit>
        <trans-unit id="e2cd521bd47287d9192e9d5c00cd5e2a6b143afe" translate="yes" xml:space="preserve">
          <source>In the PostgreSQL parser life is a bit more complicated. There are several different classes of tokens ranging from those that can never be used as an identifier to those that have absolutely no special status in the parser as compared to an ordinary identifier. (The latter is usually the case for functions specified by SQL.) Even reserved key words are not completely reserved in PostgreSQL, but can be used as column labels (for example, &lt;code&gt;SELECT 55 AS CHECK&lt;/code&gt;, even though &lt;code&gt;CHECK&lt;/code&gt; is a reserved key word).</source>
          <target state="translated">在PostgreSQL解析器中，生活有些复杂。与普通标识符相比，令牌有几种不同的类别，从永远不能用作标识符的令牌到在解析器中绝对没有特殊状态的令牌。 （对于SQL指定的函数，通常是后者。）即使保留的关键字在PostgreSQL中也不是完全保留的，但是可以用作列标签（例如， &lt;code&gt;SELECT 55 AS CHECK&lt;/code&gt; ，即使 &lt;code&gt;CHECK&lt;/code&gt; 是保留的关键字）。 。</target>
        </trans-unit>
        <trans-unit id="c06a771ae535ebcc1c02437d6d6edcaa369ff63e" translate="yes" xml:space="preserve">
          <source>In the SQL and POSTGRES styles, day appears before month if DMY field ordering has been specified, otherwise month appears before day. (See &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-INPUT&quot;&gt;Section 8.5.1&lt;/a&gt; for how this setting also affects interpretation of input values.) &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-OUTPUT2-TABLE&quot;&gt;Table 8.15&lt;/a&gt; shows examples.</source>
          <target state="translated">在SQL和POSTGRES样式中，如果已指定DMY字段顺序，则日期显示在月份之前，否则显示日期显示在月份之前。（有关此设置如何影响输入值的解释，请参见&lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-INPUT&quot;&gt;第8.5.1节&lt;/a&gt;。）&lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-OUTPUT2-TABLE&quot;&gt;表8.15&lt;/a&gt;显示了示例。</target>
        </trans-unit>
        <trans-unit id="84b70dca4dd2a2a4e41665aeb47157cc98221d20" translate="yes" xml:space="preserve">
          <source>In the SQL standard, sequences only have a &lt;code&gt;USAGE&lt;/code&gt; privilege, which controls the use of the &lt;code&gt;NEXT VALUE FOR&lt;/code&gt; expression, which is equivalent to the function &lt;code&gt;nextval&lt;/code&gt; in PostgreSQL. The sequence privileges &lt;code&gt;SELECT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; are PostgreSQL extensions. The application of the sequence &lt;code&gt;USAGE&lt;/code&gt; privilege to the &lt;code&gt;currval&lt;/code&gt; function is also a PostgreSQL extension (as is the function itself).</source>
          <target state="translated">在SQL标准中，序列仅具有 &lt;code&gt;USAGE&lt;/code&gt; 特权，该特权控制 &lt;code&gt;NEXT VALUE FOR&lt;/code&gt; 表达式的使用，该表达式等效于PostgreSQL中的 &lt;code&gt;nextval&lt;/code&gt; 函数。序列特权 &lt;code&gt;SELECT&lt;/code&gt; 和 &lt;code&gt;UPDATE&lt;/code&gt; 是PostgreSQL的扩展。将序列 &lt;code&gt;USAGE&lt;/code&gt; 特权应用于 &lt;code&gt;currval&lt;/code&gt; 函数也是PostgreSQL扩展（函数本身也是）。</target>
        </trans-unit>
        <trans-unit id="fcd4626eefede972e087ae6e07462757a1b0e1ce" translate="yes" xml:space="preserve">
          <source>In the SQL standard, the &lt;code&gt;xmlexists&lt;/code&gt; function evaluates an expression in the XML Query language, but PostgreSQL allows only an XPath 1.0 expression, as discussed in &lt;a href=&quot;xml-limits-conformance#FUNCTIONS-XML-LIMITS-XPATH1&quot;&gt;Section D.3.1&lt;/a&gt;.</source>
          <target state="translated">在SQL标准中， &lt;code&gt;xmlexists&lt;/code&gt; 函数使用XML查询语言评估表达式，但是PostgreSQL仅允许XPath 1.0表达式，如&lt;a href=&quot;xml-limits-conformance#FUNCTIONS-XML-LIMITS-XPATH1&quot;&gt;D.3.1节所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="58d7a869224d4569093b25b6e2276773eb285b56" translate="yes" xml:space="preserve">
          <source>In the SQL standard, the &lt;code&gt;xmltable&lt;/code&gt; function evaluates expressions in the XML Query language, but PostgreSQL allows only XPath 1.0 expressions, as discussed in &lt;a href=&quot;xml-limits-conformance#FUNCTIONS-XML-LIMITS-XPATH1&quot;&gt;Section D.3.1&lt;/a&gt;.</source>
          <target state="translated">在SQL标准中， &lt;code&gt;xmltable&lt;/code&gt; 函数使用XML Query语言评估表达式，但是PostgreSQL仅允许XPath 1.0表达式，如&lt;a href=&quot;xml-limits-conformance#FUNCTIONS-XML-LIMITS-XPATH1&quot;&gt;D.3.1节所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9660d94d0a1b58a81d974d699a1bce336010b697" translate="yes" xml:space="preserve">
          <source>In the SQL standard, the notion of objects in the same schema being owned by different users does not exist. Moreover, some implementations do not allow you to create schemas that have a different name than their owner. In fact, the concepts of schema and user are nearly equivalent in a database system that implements only the basic schema support specified in the standard. Therefore, many users consider qualified names to really consist of &lt;code&gt;user_name.table_name&lt;/code&gt;. This is how PostgreSQL will effectively behave if you create a per-user schema for every user.</source>
          <target state="translated">在SQL标准中，不存在由不同用户拥有的同一架构中的对象的概念。此外，某些实现不允许您创建名称与其所有者不同的架构。实际上，模式和用户的概念在仅实现标准中指定的基本模式支持的数据库系统中几乎相同。因此，许多用户认为限定名称实际上由 &lt;code&gt;user_name.table_name&lt;/code&gt; 组成。如果您为每个用户创建每个用户的架构，这就是PostgreSQL的有效行为。</target>
        </trans-unit>
        <trans-unit id="bce55523e60490fd9a9b255e77d45bae3da990ba" translate="yes" xml:space="preserve">
          <source>In the SQL standard, the optional key word &lt;code&gt;AS&lt;/code&gt; can be omitted before an output column name whenever the new column name is a valid column name (that is, not the same as any reserved keyword). PostgreSQL is slightly more restrictive: &lt;code&gt;AS&lt;/code&gt; is required if the new column name matches any keyword at all, reserved or not. Recommended practice is to use &lt;code&gt;AS&lt;/code&gt; or double-quote output column names, to prevent any possible conflict against future keyword additions.</source>
          <target state="translated">在SQL标准中，只要新列名是有效的列名（即与任何保留关键字不同），就可以在输出列名之前省略可选关键字 &lt;code&gt;AS&lt;/code&gt; 。 PostgreSQL的限制更严格：如果新的列名完全匹配任何关键字（保留或不保留），则要求使用 &lt;code&gt;AS&lt;/code&gt; 。推荐的做法是使用 &lt;code&gt;AS&lt;/code&gt; 或双引号输出列名，以防止与将来添加关键字的任何可能的冲突。</target>
        </trans-unit>
        <trans-unit id="60fb33ea7714daeb182a1d8cf938445a4efd08dd" translate="yes" xml:space="preserve">
          <source>In the SQL standard, there is a clear distinction between users and roles, and users do not automatically inherit privileges while roles do. This behavior can be obtained in PostgreSQL by giving roles being used as SQL roles the &lt;code&gt;INHERIT&lt;/code&gt; attribute, while giving roles being used as SQL users the &lt;code&gt;NOINHERIT&lt;/code&gt; attribute. However, PostgreSQL defaults to giving all roles the &lt;code&gt;INHERIT&lt;/code&gt; attribute, for backward compatibility with pre-8.1 releases in which users always had use of permissions granted to groups they were members of.</source>
          <target state="translated">在SQL标准中，用户和角色之间有明显的区别，用户不会像角色那样自动继承特权。在PostgreSQL中，可以通过将被用作SQL角色的角色赋予 &lt;code&gt;INHERIT&lt;/code&gt; 属性，而将被用作SQL用户的角色赋予 &lt;code&gt;NOINHERIT&lt;/code&gt; 属性来获得这种行为。但是，PostgreSQL默认为所有角色赋予 &lt;code&gt;INHERIT&lt;/code&gt; 属性，以便与8.1之前的版本向后兼容，在这些版本中，用户始终使用为其成员所属的组授予的权限。</target>
        </trans-unit>
        <trans-unit id="4d55ecfda5316639c09ff6bb19e9602eb2f98338" translate="yes" xml:space="preserve">
          <source>In the SQL standard, there is one other transaction characteristic that can be set with these commands: the size of the diagnostics area. This concept is specific to embedded SQL, and therefore is not implemented in the PostgreSQL server.</source>
          <target state="translated">在SQL标准中,还有一个事务特性可以用这些命令来设置:诊断区的大小。这个概念是嵌入式SQL所特有的,因此在PostgreSQL服务器中没有实现。</target>
        </trans-unit>
        <trans-unit id="ed36ad7d98cb4d8fee32b855fb6fed744837b0e0" translate="yes" xml:space="preserve">
          <source>In the SQL-92 standard, an &lt;code&gt;ORDER BY&lt;/code&gt; clause can only use output column names or numbers, while a &lt;code&gt;GROUP BY&lt;/code&gt; clause can only use expressions based on input column names. PostgreSQL extends each of these clauses to allow the other choice as well (but it uses the standard's interpretation if there is ambiguity). PostgreSQL also allows both clauses to specify arbitrary expressions. Note that names appearing in an expression will always be taken as input-column names, not as output-column names.</source>
          <target state="translated">在SQL-92标准中， &lt;code&gt;ORDER BY&lt;/code&gt; 子句只能使用输出列名称或数字，而 &lt;code&gt;GROUP BY&lt;/code&gt; 子句只能使用基于输入列名称的表达式。 PostgreSQL扩展了每个子句以允许其他选择（但是如果有歧义，它会使用标准的解释）。 PostgreSQL还允许两个子句都指定任意表达式。请注意，出现在表达式中的名称将始终被视为输入列名称，而不是输出列名称。</target>
        </trans-unit>
        <trans-unit id="b054bfec2bce610e705197d361e44d3c2768bb83" translate="yes" xml:space="preserve">
          <source>In the XQuery/XPath data model, a &lt;em&gt;document node&lt;/em&gt; can have either document form (i.e., exactly one top-level element, with only comments and processing instructions outside of it) or content form (with those constraints relaxed). Its equivalent in XPath 1.0, the &lt;em&gt;root node&lt;/em&gt;, can only be in document form. This is part of the reason an &lt;code&gt;xml&lt;/code&gt; value passed as the context item to any PostgreSQL XPath-based function must be in document form.</source>
          <target state="translated">在XQuery / XPath数据模型中，&lt;em&gt;文档节点&lt;/em&gt;可以具有文档形式（即，仅是一个顶级元素，其外部仅包含注释和处理指令）或内容形式（具有那些约束的放松）。在XPath 1.0中，其等效项（&lt;em&gt;根节点&lt;/em&gt;）只能采用文档形式。这是作为上下文项传递到任何基于PostgreSQL XPath的函数的 &lt;code&gt;xml&lt;/code&gt; 值必须采用文档形式的部分原因。</target>
        </trans-unit>
        <trans-unit id="907c04147bb1d71b5f0459b5e753db080d794777" translate="yes" xml:space="preserve">
          <source>In the above example we would be creating a new partition each month, so it might be wise to write a script that generates the required DDL automatically.</source>
          <target state="translated">在上面的例子中,我们每个月都会创建一个新的分区,所以写一个脚本来自动生成所需的DDL可能是明智的。</target>
        </trans-unit>
        <trans-unit id="652407089ebdeac3fe06a048bf54ac1385a35fc9" translate="yes" xml:space="preserve">
          <source>In the above example, the new password isn't actually echoed when typed, but we show what was typed for clarity. As you see, the password is encrypted before it is sent to the client.</source>
          <target state="translated">在上面的例子中,新的密码在输入时实际上并没有被呼应,但为了清晰起见,我们显示了输入的内容。如你所见,密码在发送给客户端之前已经被加密了。</target>
        </trans-unit>
        <trans-unit id="a28671e837ffe13c54dd539a74a6f7de604de65e" translate="yes" xml:space="preserve">
          <source>In the above output, the free space figures may not match the &lt;code&gt;pgstattuple&lt;/code&gt; output exactly, because the free space map gives us an exact figure, but is not guaranteed to be accurate to the byte.</source>
          <target state="translated">在上面的输出中，可用空间数字可能与 &lt;code&gt;pgstattuple&lt;/code&gt; 输出不完全匹配，因为可用空间映射为我们提供了一个精确数字，但不能保证它对字节准确。</target>
        </trans-unit>
        <trans-unit id="cfee998fb713aa32e0b0a461f86fb14fa87aa018" translate="yes" xml:space="preserve">
          <source>In the above queries, the second form is dangerous because the &lt;code&gt;LIMIT&lt;/code&gt; is not guaranteed to be applied before the locking function is executed. This might cause some locks to be acquired that the application was not expecting, and hence would fail to release (until it ends the session). From the point of view of the application, such locks would be dangling, although still viewable in &lt;code&gt;pg_locks&lt;/code&gt;.</source>
          <target state="translated">在上述查询中，第二种形式很危险，因为不能保证在执行锁定功能之前先应用 &lt;code&gt;LIMIT&lt;/code&gt; 。这可能会导致获取应用程序未预期的某些锁定，因此将无法释放（直到结束会话）。从应用程序的角度来看，尽管在 &lt;code&gt;pg_locks&lt;/code&gt; 中仍然可以看到这些锁，但是它们都是悬挂的。</target>
        </trans-unit>
        <trans-unit id="0422400fe004db1267465196296a34921629ca1c" translate="yes" xml:space="preserve">
          <source>In the above query, the arguments &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are specified positionally, while &lt;code&gt;uppercase&lt;/code&gt; is specified by name. In this example, that adds little except documentation. With a more complex function having numerous parameters that have default values, named or mixed notation can save a great deal of writing and reduce chances for error.</source>
          <target state="translated">在上面的查询中，参数 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 在位置上指定，而 &lt;code&gt;uppercase&lt;/code&gt; 由名称指定。在此示例中，除了文档外几乎没有添加。对于具有许多具有默认值的参数的更复杂的函数，命名或混合符号可以节省大量编写工作，并减少出错的机会。</target>
        </trans-unit>
        <trans-unit id="523e1fdbf28526b9fd09539320b970501acbeb30" translate="yes" xml:space="preserve">
          <source>In the absence of any explicit quantifier, the default for a star symbol is to match any number of labels (that is, &lt;code&gt;{,}&lt;/code&gt;) while the default for a non-star item is to match exactly once (that is, &lt;code&gt;{1}&lt;/code&gt;).</source>
          <target state="translated">在没有任何显式量词的情况下，星号的默认值是匹配任意数量的标签（即 &lt;code&gt;{,}&lt;/code&gt; ），而非星号的默认值则是精确匹配一次（即 &lt;code&gt;{1}&lt;/code&gt; )。）。</target>
        </trans-unit>
        <trans-unit id="12fe4f57925256d624bd6eb274cf2330b45da284" translate="yes" xml:space="preserve">
          <source>In the absence of fatal errors, pg_receivewal will run until terminated by the SIGINT signal (&lt;strong&gt;Control&lt;/strong&gt;+&lt;strong&gt;C&lt;/strong&gt;).</source>
          <target state="translated">在没有致命错误的情况下，pg_receivewal将运行直到被SIGINT信号（&lt;strong&gt;Control&lt;/strong&gt; + &lt;strong&gt;C&lt;/strong&gt;）终止。</target>
        </trans-unit>
        <trans-unit id="e6c9650fa107be76e508c9f6a766e1575673cf8c" translate="yes" xml:space="preserve">
          <source>In the alternative format:</source>
          <target state="translated">在备选格式中:</target>
        </trans-unit>
        <trans-unit id="c2e1ceee33301b36828cf2caae1f68eec137b740" translate="yes" xml:space="preserve">
          <source>In the case of a parallel dump, the snapshot name defined by this option is used rather than taking a new snapshot.</source>
          <target state="translated">在并行转储的情况下,会使用这个选项定义的快照名称,而不是取一个新的快照。</target>
        </trans-unit>
        <trans-unit id="2a04ddae39deed0bb63ddc81c6701d5c2ad86b55" translate="yes" xml:space="preserve">
          <source>In the case of a partitioned table, updating a row might cause it to no longer satisfy the partition constraint of the containing partition. In that case, if there is some other partition in the partition tree for which this row satisfies its partition constraint, then the row is moved to that partition. If there is no such partition, an error will occur. Behind the scenes, the row movement is actually a &lt;code&gt;DELETE&lt;/code&gt; and &lt;code&gt;INSERT&lt;/code&gt; operation.</source>
          <target state="translated">在分区表的情况下，更新行可能导致其不再满足所在分区的分区约束。在这种情况下，如果分区树中存在该行满足其分区约束的其他分区，则该行将移至该分区。如果没有这样的分区，将发生错误。在后台，行移动实际上是 &lt;code&gt;DELETE&lt;/code&gt; 和 &lt;code&gt;INSERT&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="5544906e3d293a0a9ad12a92567f1204d11f1dd6" translate="yes" xml:space="preserve">
          <source>In the case of an exclusion constraint, &lt;code&gt;conkey&lt;/code&gt; is only useful for constraint elements that are simple column references. For other cases, a zero appears in &lt;code&gt;conkey&lt;/code&gt; and the associated index must be consulted to discover the expression that is constrained. (&lt;code&gt;conkey&lt;/code&gt; thus has the same contents as &lt;code&gt;pg_index&lt;/code&gt;.&lt;code&gt;indkey&lt;/code&gt; for the index.)</source>
          <target state="translated">在排除约束的情况下， &lt;code&gt;conkey&lt;/code&gt; 仅对作为简单列引用的约束元素有用。在其他情况下， &lt;code&gt;conkey&lt;/code&gt; 中出现零，并且必须参考关联的索引才能发现受约束的表达式。（ &lt;code&gt;conkey&lt;/code&gt; 因此具有相同内容 &lt;code&gt;pg_index&lt;/code&gt; 。 &lt;code&gt;indkey&lt;/code&gt; 里面用于索引。）</target>
        </trans-unit>
        <trans-unit id="e4fef774ebd3ff2e38db3236bd03a350ace1f35c" translate="yes" xml:space="preserve">
          <source>In the common case where you just want the whole matching substring or &lt;code&gt;NULL&lt;/code&gt; for no match, write something like</source>
          <target state="translated">在通常情况下，您只希望整个匹配的子字符串或 &lt;code&gt;NULL&lt;/code&gt; 而不匹配，请编写类似</target>
        </trans-unit>
        <trans-unit id="d8de3d9b49ffb3cc570c884fc7d3dde953f8a262" translate="yes" xml:space="preserve">
          <source>In the context of &lt;code&gt;INSERT&lt;/code&gt;, entries of a &lt;code&gt;VALUES&lt;/code&gt; list can be &lt;code&gt;DEFAULT&lt;/code&gt; to indicate that the column default should be used here instead of specifying a value:</source>
          <target state="translated">在 &lt;code&gt;INSERT&lt;/code&gt; 的上下文中， &lt;code&gt;VALUES&lt;/code&gt; 列表的条目可以为 &lt;code&gt;DEFAULT&lt;/code&gt; ,以指示此处应使用列默认值而不是指定值：</target>
        </trans-unit>
        <trans-unit id="0a8a6bb89f9ea4433f27de55629e036adfed0508" translate="yes" xml:space="preserve">
          <source>In the current implementation, the fitness of each candidate join sequence is estimated by running the standard planner's join selection and cost estimation code from scratch. To the extent that different candidates use similar sub-sequences of joins, a great deal of work will be repeated. This could be made significantly faster by retaining cost estimates for sub-joins. The problem is to avoid expending unreasonable amounts of memory on retaining that state.</source>
          <target state="translated">在目前的实施中,每个候选连接序列的适合度是通过从头开始运行标准规划者的连接选择和成本估算代码来估计的。如果不同的候选者使用类似的子连接序列,大量的工作将被重复。通过保留子连接的成本估算,可以大大加快速度。问题是要避免在保留该状态上消耗不合理的内存。</target>
        </trans-unit>
        <trans-unit id="7b88d112fefbb18a9a94530a4a12e322eca2805d" translate="yes" xml:space="preserve">
          <source>In the default PostgreSQL configuration, the autovacuum daemon (see &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt;) takes care of automatic analyzing of tables when they are first loaded with data, and as they change throughout regular operation. When autovacuum is disabled, it is a good idea to run &lt;code&gt;ANALYZE&lt;/code&gt; periodically, or just after making major changes in the contents of a table. Accurate statistics will help the planner to choose the most appropriate query plan, and thereby improve the speed of query processing. A common strategy for read-mostly databases is to run &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt; and &lt;code&gt;ANALYZE&lt;/code&gt; once a day during a low-usage time of day. (This will not be sufficient if there is heavy update activity.)</source>
          <target state="translated">在默认的PostgreSQL配置中，autovacuum守护程序（请参见&lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;第24.1.6节&lt;/a&gt;）负责在表首次加载数据时以及在整个常规操作中更改时自动分析表。禁用自动清理后，最好定期运行 &lt;code&gt;ANALYZE&lt;/code&gt; ，或者在对表内容进行重大更改后立即运行ANALYZE。准确的统计信息将帮助计划者选择最合适的查询计划，从而提高查询处理的速度。只读数据库的常见策略是在一天的低使用时间内每天运行一次&lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt;和 &lt;code&gt;ANALYZE&lt;/code&gt; 。 （如果有大量更新活动，这将是不够的。）</target>
        </trans-unit>
        <trans-unit id="4ce2b63a8b5343bbf7125e0114e2a04ce0d2bde8" translate="yes" xml:space="preserve">
          <source>In the default setup this returns:</source>
          <target state="translated">在默认设置中,会返回。</target>
        </trans-unit>
        <trans-unit id="596bcd2b70e5eeabccdcbaf0d79d2c517c798e21" translate="yes" xml:space="preserve">
          <source>In the event of a binary upgrade, upward compatibility is maintained by having the new code recognize old-format data. This will entail a slight performance penalty when processing data that has not yet been modified by the new code. It is possible to force an upgrade of all values in a table column by doing an &lt;code&gt;UPDATE&lt;/code&gt; statement as follows:</source>
          <target state="translated">如果进行二进制升级，则通过使新代码识别旧格式的数据来保持向上兼容性。在处理尚未被新代码修改的数据时，这将导致轻微的性能损失。通过执行以下 &lt;code&gt;UPDATE&lt;/code&gt; 语句，可以强制升级表列中的所有值：</target>
        </trans-unit>
        <trans-unit id="b3a7ad5f630b85b752ae07e66abff996aa3b1a24" translate="yes" xml:space="preserve">
          <source>In the event that an RE could match more than one substring of a given string, the RE matches the one starting earliest in the string. If the RE could match more than one substring starting at that point, either the longest possible match or the shortest possible match will be taken, depending on whether the RE is &lt;em&gt;greedy&lt;/em&gt; or &lt;em&gt;non-greedy&lt;/em&gt;.</source>
          <target state="translated">如果RE可以匹配给定字符串的多个子字符串，则RE匹配字符串中最早的一个子字符串。如果从该点开始RE可以匹配多个子字符串，则根据RE是&lt;em&gt;贪婪的&lt;/em&gt;还是&lt;em&gt;非贪婪的&lt;/em&gt;，将采用最长匹配或最短匹配。</target>
        </trans-unit>
        <trans-unit id="474b9960977cbbea61dc4ac5b333f0b736c6264c" translate="yes" xml:space="preserve">
          <source>In the example above we see that the resulting &lt;code&gt;tsvector&lt;/code&gt; does not contain the words &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;on&lt;/code&gt;, or &lt;code&gt;it&lt;/code&gt;, the word &lt;code&gt;rats&lt;/code&gt; became &lt;code&gt;rat&lt;/code&gt;, and the punctuation sign &lt;code&gt;-&lt;/code&gt; was ignored.</source>
          <target state="translated">在上面的示例中，我们看到生成的 &lt;code&gt;tsvector&lt;/code&gt; 不包含单词 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;on&lt;/code&gt; 或 &lt;code&gt;it&lt;/code&gt; ，单词 &lt;code&gt;rats&lt;/code&gt; 变成 &lt;code&gt;rat&lt;/code&gt; ，并且标点符号 &lt;code&gt;-&lt;/code&gt; 被忽略。</target>
        </trans-unit>
        <trans-unit id="200ce56337643046a5aa2dd5558bb50f57584421" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;WHERE&lt;/code&gt; clause is selecting rows by a column that is not grouped (the expression is only true for sales during the last four weeks), while the &lt;code&gt;HAVING&lt;/code&gt; clause restricts the output to groups with total gross sales over 5000. Note that the aggregate expressions do not necessarily need to be the same in all parts of the query.</source>
          <target state="translated">在上面的示例中， &lt;code&gt;WHERE&lt;/code&gt; 子句按未分组的列选择行（该表达式仅适用于过去四周的销售额），而 &lt;code&gt;HAVING&lt;/code&gt; 子句将输出限制为总销售总额超过5000的组。聚合表达式不一定在查询的所有部分都相同。</target>
        </trans-unit>
        <trans-unit id="31c0dc4f6c95bec1ccb804da7ba6806c38ecea92" translate="yes" xml:space="preserve">
          <source>In the example above, the working table has just a single row in each step, and it takes on the values from 1 through 100 in successive steps. In the 100th step, there is no output because of the &lt;code&gt;WHERE&lt;/code&gt; clause, and so the query terminates.</source>
          <target state="translated">在上面的示例中，工作表在每个步骤中只有一行，并且在连续的步骤中采用1到100的值。在第100步中，由于 &lt;code&gt;WHERE&lt;/code&gt; 子句而没有输出，因此查询终止。</target>
        </trans-unit>
        <trans-unit id="652a8b18a910fe23a9af73c94ce5d441558f1e6b" translate="yes" xml:space="preserve">
          <source>In the examples above, the parser sees an integer array on one side of the concatenation operator, and a constant of undetermined type on the other. The heuristic it uses to resolve the constant's type is to assume it's of the same type as the operator's other input &amp;mdash; in this case, integer array. So the concatenation operator is presumed to represent &lt;code&gt;array_cat&lt;/code&gt;, not &lt;code&gt;array_append&lt;/code&gt;. When that's the wrong choice, it could be fixed by casting the constant to the array's element type; but explicit use of &lt;code&gt;array_append&lt;/code&gt; might be a preferable solution.</source>
          <target state="translated">在上面的示例中，解析器在串联运算符的一侧看到一个整数数组，在另一侧看到一个不确定类型的常量。它用来解析常量类型的试探法是假设它与运算符的其他输入具有相同的类型，在本例中为整数数组。因此，假定串联运算符表示 &lt;code&gt;array_cat&lt;/code&gt; 而不是 &lt;code&gt;array_append&lt;/code&gt; 。如果选择错误，则可以通过将常量转换为数组的元素类型来解决。但是显式使用 &lt;code&gt;array_append&lt;/code&gt; 可能是一个更好的解决方案。</target>
        </trans-unit>
        <trans-unit id="cfb28c6ea0190f478c6d1ce0ce5ab123177f2281" translate="yes" xml:space="preserve">
          <source>In the examples above, the policy expressions consider only the current values in the row to be accessed or updated. This is the simplest and best-performing case; when possible, it's best to design row security applications to work this way. If it is necessary to consult other rows or other tables to make a policy decision, that can be accomplished using sub-&lt;code&gt;SELECT&lt;/code&gt;s, or functions that contain &lt;code&gt;SELECT&lt;/code&gt;s, in the policy expressions. Be aware however that such accesses can create race conditions that could allow information leakage if care is not taken. As an example, consider the following table design:</source>
          <target state="translated">在上面的示例中，策略表达式仅考虑要访问或更新的行中的当前值。这是最简单，性能最好的情况；在可能的情况下，最好设计行安全性应用程序以这种方式工作。如果需要参考其他行或其他表来制定策略决定，则可以使用策略表达式中的sub &lt;code&gt;SELECT&lt;/code&gt; 或包含 &lt;code&gt;SELECT&lt;/code&gt; 的函数来完成。但是请注意，如果不注意，此类访问会造成竞争条件，从而可能导致信息泄漏。例如，请考虑以下表格设计：</target>
        </trans-unit>
        <trans-unit id="2808c388963b5d35c9a7c014fc0aef8465d89479" translate="yes" xml:space="preserve">
          <source>In the examples that follow, we assume that you have created a database named &lt;code&gt;mydb&lt;/code&gt;, as described in the previous chapter, and have been able to start psql.</source>
          <target state="translated">在下面的示例中，我们假设您已经创建了一个名为 &lt;code&gt;mydb&lt;/code&gt; 的数据库，如上一章所述，并且已经能够启动psql。</target>
        </trans-unit>
        <trans-unit id="4bb59306b891fbea63056e89cb36560d344851b8" translate="yes" xml:space="preserve">
          <source>In the first case, the RE as a whole is greedy because &lt;code&gt;Y*&lt;/code&gt; is greedy. It can match beginning at the &lt;code&gt;Y&lt;/code&gt;, and it matches the longest possible string starting there, i.e., &lt;code&gt;Y123&lt;/code&gt;. The output is the parenthesized part of that, or &lt;code&gt;123&lt;/code&gt;. In the second case, the RE as a whole is non-greedy because &lt;code&gt;Y*?&lt;/code&gt; is non-greedy. It can match beginning at the &lt;code&gt;Y&lt;/code&gt;, and it matches the shortest possible string starting there, i.e., &lt;code&gt;Y1&lt;/code&gt;. The subexpression &lt;code&gt;[0-9]{1,3}&lt;/code&gt; is greedy but it cannot change the decision as to the overall match length; so it is forced to match just &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">在第一种情况下，RE整体上是贪婪的，因为 &lt;code&gt;Y*&lt;/code&gt; 是贪婪的。它可以匹配从 &lt;code&gt;Y&lt;/code&gt; 开始的位置，也可以匹配从那里开始的最长的字符串，即 &lt;code&gt;Y123&lt;/code&gt; 。输出是该内容的括号部分，即 &lt;code&gt;123&lt;/code&gt; 。在第二种情况下，RE整体上是非贪婪的，因为 &lt;code&gt;Y*?&lt;/code&gt; 是非贪婪的。它可以匹配一开始 &lt;code&gt;Y&lt;/code&gt; ，并在最短的字符串匹配开始出现，即 &lt;code&gt;Y1&lt;/code&gt; 。子表达式 &lt;code&gt;[0-9]{1,3}&lt;/code&gt; 是贪婪的，但是它不能更改关于总匹配长度的决定；因此它只能匹配 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0afff82ca92cc5d65344944313d08b5825c3e875" translate="yes" xml:space="preserve">
          <source>In the first place, &lt;em&gt;never&lt;/em&gt; believe any test that runs for only a few seconds. Use the &lt;code&gt;-t&lt;/code&gt; or &lt;code&gt;-T&lt;/code&gt; option to make the run last at least a few minutes, so as to average out noise. In some cases you could need hours to get numbers that are reproducible. It's a good idea to try the test run a few times, to find out if your numbers are reproducible or not.</source>
          <target state="translated">首先，&lt;em&gt;不要&lt;/em&gt;相信任何仅运行几秒钟的测试。使用 &lt;code&gt;-t&lt;/code&gt; 或 &lt;code&gt;-T&lt;/code&gt; 选项可以使运行至少持续几分钟，以平均噪音。在某些情况下，您可能需要几个小时才能获得可重现的数字。尝试几次测试是一个好主意，以查明您的数字是否可重复。</target>
        </trans-unit>
        <trans-unit id="d312d02ebaa05f528de247ffd592135c96644932" translate="yes" xml:space="preserve">
          <source>In the first string, the set of trigrams is &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rd &quot;}&lt;/code&gt;. In the second string, the ordered set of trigrams is &lt;code&gt;{&quot; t&quot;,&quot; tw&quot;,&quot;two&quot;,&quot;wo &quot;,&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rds&quot;,&quot;ds &quot;}&lt;/code&gt;. The most similar extent of an ordered set of trigrams in the second string is &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;}&lt;/code&gt;, and the similarity is &lt;code&gt;0.8&lt;/code&gt;.</source>
          <target state="translated">在第一个字符串中，字母组的集合为 &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rd &quot;}&lt;/code&gt; 。在第二个字符串中，三字母组合的有序集合为 &lt;code&gt;{&quot; t&quot;,&quot; tw&quot;,&quot;two&quot;,&quot;wo &quot;,&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rds&quot;,&quot;ds &quot;}&lt;/code&gt; 。第二个字符串中有序三字母组的最相似范围是 &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;}&lt;/code&gt; ，相似度是 &lt;code&gt;0.8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56225072f8eae4ad3b64ee516719e58b357f9e0a" translate="yes" xml:space="preserve">
          <source>In the following explanation, a &lt;em&gt;byte&lt;/em&gt; is assumed to contain 8 bits. In addition, the term &lt;em&gt;item&lt;/em&gt; refers to an individual data value that is stored on a page. In a table, an item is a row; in an index, an item is an index entry.</source>
          <target state="translated">在下面的说明中，假定一个&lt;em&gt;字节&lt;/em&gt;包含8位。另外，术语&lt;em&gt;项&lt;/em&gt;是指存储在页面上的单个数据值。在表中，一项是一行；在索引中，项目是索引条目。</target>
        </trans-unit>
        <trans-unit id="fe808d43052245254bcdc480fec58d6c194f111b" translate="yes" xml:space="preserve">
          <source>In the following sections we will cover each of the above listed items in more detail to give a better understanding of PostgreSQL's internal control and data structures.</source>
          <target state="translated">在下面的章节中,我们将更详细地介绍上面列出的每一项内容,以便更好地了解PostgreSQL的内部控制和数据结构。</target>
        </trans-unit>
        <trans-unit id="f022f75654e730419aa401f110023452d899d615" translate="yes" xml:space="preserve">
          <source>In the following we describe the implementation of a &lt;em&gt;genetic algorithm&lt;/em&gt; to solve the join ordering problem in a manner that is efficient for queries involving large numbers of joins.</source>
          <target state="translated">在下文中，我们描述了一种&lt;em&gt;遗传算法&lt;/em&gt;的实现，该&lt;em&gt;遗传算法&lt;/em&gt;以对涉及大量联接的查询有效的方式来解决联接排序问题。</target>
        </trans-unit>
        <trans-unit id="294ebe645001a682897e9beebf5caf16a1bf1ca5" translate="yes" xml:space="preserve">
          <source>In the general case where more than one field needs to be checked to recognize a cycle, use an array of rows. For example, if we needed to compare fields &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;f2&lt;/code&gt;:</source>
          <target state="translated">在通常情况下，需要检查多个字段以识别一个循环，请使用一组行。例如，如果我们需要比较字段 &lt;code&gt;f1&lt;/code&gt; 和 &lt;code&gt;f2&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="919090babfd7b1e0453e16ae1bb909dd12feef28" translate="yes" xml:space="preserve">
          <source>In the old syntax for &lt;code&gt;CREATE AGGREGATE&lt;/code&gt;, the input data type is specified by a &lt;code&gt;basetype&lt;/code&gt; parameter rather than being written next to the aggregate name. Note that this syntax allows only one input parameter. To define a zero-argument aggregate function with this syntax, specify the &lt;code&gt;basetype&lt;/code&gt; as &lt;code&gt;&quot;ANY&quot;&lt;/code&gt; (not &lt;code&gt;*&lt;/code&gt;). Ordered-set aggregates cannot be defined with the old syntax.</source>
          <target state="translated">在 &lt;code&gt;CREATE AGGREGATE&lt;/code&gt; 的旧语法中，输入数据类型由 &lt;code&gt;basetype&lt;/code&gt; 参数指定，而不是写在聚合名称旁边。请注意，此语法仅允许一个输入参数。要使用此语法定义零参数聚合函数，请将 &lt;code&gt;basetype&lt;/code&gt; 指定为 &lt;code&gt;&quot;ANY&quot;&lt;/code&gt; （不是 &lt;code&gt;*&lt;/code&gt; ）。不能使用旧语法定义有序集的聚合。</target>
        </trans-unit>
        <trans-unit id="405922ab6e8351d0cf2aca13f11379b1afd63c78" translate="yes" xml:space="preserve">
          <source>In the previous chapter we have covered the basics of using SQL to store and access your data in PostgreSQL. We will now discuss some more advanced features of SQL that simplify management and prevent loss or corruption of your data. Finally, we will look at some PostgreSQL extensions.</source>
          <target state="translated">在上一章中,我们已经介绍了使用SQL在PostgreSQL中存储和访问数据的基础知识。现在我们将讨论SQL的一些更高级的功能,这些功能可以简化管理并防止数据丢失或损坏。最后,我们将看看一些PostgreSQL的扩展。</target>
        </trans-unit>
        <trans-unit id="a8c0fa4c3a367177ef284ccecde1c150bc096697" translate="yes" xml:space="preserve">
          <source>In the previous example, we can apply the city name restriction in &lt;code&gt;WHERE&lt;/code&gt;, since it needs no aggregate. This is more efficient than adding the restriction to &lt;code&gt;HAVING&lt;/code&gt;, because we avoid doing the grouping and aggregate calculations for all rows that fail the &lt;code&gt;WHERE&lt;/code&gt; check.</source>
          <target state="translated">在前面的示例中，我们可以在 &lt;code&gt;WHERE&lt;/code&gt; 中应用城市名称限制，因为它不需要聚合。这比对 &lt;code&gt;HAVING&lt;/code&gt; 添加限制更为有效，因为我们避免对未通过 &lt;code&gt;WHERE&lt;/code&gt; 检查的所有行进行分组和汇总计算。</target>
        </trans-unit>
        <trans-unit id="9f29ede0900e9fd39d495275c897cbd33557a707" translate="yes" xml:space="preserve">
          <source>In the previous sections we created tables without specifying any schema names. By default such tables (and other objects) are automatically put into a schema named &amp;ldquo;public&amp;rdquo;. Every new database contains such a schema. Thus, the following are equivalent:</source>
          <target state="translated">在前面的部分中，我们创建了没有指定任何模式名称的表。默认情况下，此类表（和其他对象）会自动放入名为&amp;ldquo; public&amp;rdquo;的架构中。每个新数据库都包含这样的架构。因此，以下内容等效：</target>
        </trans-unit>
        <trans-unit id="0e8d742b91769afdfb8fcfcc89d91cd8ba42839b" translate="yes" xml:space="preserve">
          <source>In the remote sessions opened by &lt;code&gt;postgres_fdw&lt;/code&gt;, the &lt;a href=&quot;runtime-config-client#GUC-SEARCH-PATH&quot;&gt;search_path&lt;/a&gt; parameter is set to just &lt;code&gt;pg_catalog&lt;/code&gt;, so that only built-in objects are visible without schema qualification. This is not an issue for queries generated by &lt;code&gt;postgres_fdw&lt;/code&gt; itself, because it always supplies such qualification. However, this can pose a hazard for functions that are executed on the remote server via triggers or rules on remote tables. For example, if a remote table is actually a view, any functions used in that view will be executed with the restricted search path. It is recommended to schema-qualify all names in such functions, or else attach &lt;code&gt;SET search_path&lt;/code&gt; options (see &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;) to such functions to establish their expected search path environment.</source>
          <target state="translated">在由 &lt;code&gt;postgres_fdw&lt;/code&gt; 打开的远程会话中，&lt;a href=&quot;runtime-config-client#GUC-SEARCH-PATH&quot;&gt;search_path&lt;/a&gt;参数设置为 &lt;code&gt;pg_catalog&lt;/code&gt; ，因此，只有内置对象可见，而没有模式限定。对于由 &lt;code&gt;postgres_fdw&lt;/code&gt; 本身生成的查询，这不是问题，因为它始终提供这种限定。但是，这可能会对通过远程表上的触发器或规则在远程服务器上执行的功能造成危害。例如，如果远程表实际上是视图，则将使用受限的搜索路径来执行该视图中使用的任何功能。建议对此类函数中的所有名称进行模式限定，或附加 &lt;code&gt;SET search_path&lt;/code&gt; 选项（请参阅&lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION）&lt;/a&gt;），以建立其预期的搜索路径环境。</target>
        </trans-unit>
        <trans-unit id="251756f685410e433b657f5b30520cf41b101c14" translate="yes" xml:space="preserve">
          <source>In the same connection as before, issue the command:</source>
          <target state="translated">在与之前相同的连接中,发出命令。</target>
        </trans-unit>
        <trans-unit id="9a85cd84a5c1ae886a05b3cc6a64ec7fb7c99a58" translate="yes" xml:space="preserve">
          <source>In the second form of &lt;code&gt;ALTER POLICY&lt;/code&gt;, the role list, &lt;code&gt;using_expression&lt;/code&gt;, and &lt;code&gt;check_expression&lt;/code&gt; are replaced independently if specified. When one of those clauses is omitted, the corresponding part of the policy is unchanged.</source>
          <target state="translated">在 &lt;code&gt;ALTER POLICY&lt;/code&gt; 的第二种形式中，如果已指定，则角色列表， &lt;code&gt;using_expression&lt;/code&gt; 和 &lt;code&gt;check_expression&lt;/code&gt; 被独立替换。如果省略其中一个子句，则策略的相应部分不变。</target>
        </trans-unit>
        <trans-unit id="2c142401003467ed2967cc5251153e2a0bab24fa" translate="yes" xml:space="preserve">
          <source>In the second mode, which we will call the search+bind mode, the server first binds to the LDAP directory with a fixed user name and password, specified with &lt;code&gt;ldapbinddn&lt;/code&gt; and &lt;code&gt;ldapbindpasswd&lt;/code&gt;, and performs a search for the user trying to log in to the database. If no user and password is configured, an anonymous bind will be attempted to the directory. The search will be performed over the subtree at &lt;code&gt;ldapbasedn&lt;/code&gt;, and will try to do an exact match of the attribute specified in &lt;code&gt;ldapsearchattribute&lt;/code&gt;. Once the user has been found in this search, the server disconnects and re-binds to the directory as this user, using the password specified by the client, to verify that the login is correct. This mode is the same as that used by LDAP authentication schemes in other software, such as Apache &lt;code&gt;mod_authnz_ldap&lt;/code&gt; and &lt;code&gt;pam_ldap&lt;/code&gt;. This method allows for significantly more flexibility in where the user objects are located in the directory, but will cause two separate connections to the LDAP server to be made.</source>
          <target state="translated">在第二种模式下，我们将其称为搜索+绑定模式，服务器首先使用 &lt;code&gt;ldapbinddn&lt;/code&gt; 和 &lt;code&gt;ldapbindpasswd&lt;/code&gt; 指定的固定用户名和密码绑定到LDAP目录，然后对试图登录到该目录的用户执行搜索。数据库。如果未配置用户名和密码，则将尝试匿名绑定到目录。搜索将在 &lt;code&gt;ldapbasedn&lt;/code&gt; 的子树上执行，并将尝试与 &lt;code&gt;ldapsearchattribute&lt;/code&gt; 中指定的属性完全匹配。在此搜索中找到用户后，服务器将使用客户端指定的密码断开连接，并以该用户身份重新绑定到目录，以验证登录名是否正确。此模式与其他软件（例如Apache &lt;code&gt;mod_authnz_ldap&lt;/code&gt; 和 &lt;code&gt;pam_ldap&lt;/code&gt; )中的LDAP认证方案所使用的模式相同。该方法在用户对象在目录中的位置上具有更大的灵活性，但是会导致与LDAP服务器建立两个单独的连接。</target>
        </trans-unit>
        <trans-unit id="138833bfe13a3d8412530f69bb62c741e625ccde" translate="yes" xml:space="preserve">
          <source>In the second query, we could not have written &lt;code&gt;SELECT * FROM test1 GROUP BY x&lt;/code&gt;, because there is no single value for the column &lt;code&gt;y&lt;/code&gt; that could be associated with each group. The grouped-by columns can be referenced in the select list since they have a single value in each group.</source>
          <target state="translated">在第二个查询中，我们无法编写 &lt;code&gt;SELECT * FROM test1 GROUP BY x&lt;/code&gt; ，因为没有与每个组关联的列 &lt;code&gt;y&lt;/code&gt; 单个值。分组列可以在选择列表中引用，因为它们在每个组中都有一个值。</target>
        </trans-unit>
        <trans-unit id="a3f53fb06ae3c0e076406bae29678cb14017000e" translate="yes" xml:space="preserve">
          <source>In the standard, it is not necessary to issue &lt;code&gt;START TRANSACTION&lt;/code&gt; to start a transaction block: any SQL command implicitly begins a block. PostgreSQL's behavior can be seen as implicitly issuing a &lt;code&gt;COMMIT&lt;/code&gt; after each command that does not follow &lt;code&gt;START TRANSACTION&lt;/code&gt; (or &lt;code&gt;BEGIN&lt;/code&gt;), and it is therefore often called &amp;ldquo;autocommit&amp;rdquo;. Other relational database systems might offer an autocommit feature as a convenience.</source>
          <target state="translated">在标准中，不必​​发出 &lt;code&gt;START TRANSACTION&lt;/code&gt; 来启动事务块：任何SQL命令都隐式地开始一个块。PostgreSQL的行为可以看作是在每个不遵循 &lt;code&gt;START TRANSACTION&lt;/code&gt; （或 &lt;code&gt;BEGIN&lt;/code&gt; ）的命令之后隐式发出 &lt;code&gt;COMMIT&lt;/code&gt; ，因此通常被称为&amp;ldquo;自动提交&amp;rdquo;。其他关系数据库系统可能会提供便利的自动提交功能。</target>
        </trans-unit>
        <trans-unit id="127829a1cca08de1cd77d4d1d0c73fe0bf22ed39" translate="yes" xml:space="preserve">
          <source>In the standard, the &lt;code&gt;WITH [ NO ] DATA&lt;/code&gt; clause is required; in PostgreSQL it is optional.</source>
          <target state="translated">在标准中，需要 &lt;code&gt;WITH [ NO ] DATA&lt;/code&gt; 子句；在PostgreSQL中，它是可选的。</target>
        </trans-unit>
        <trans-unit id="7f27aa8e0141e367b925aa8c528ef6250799f203" translate="yes" xml:space="preserve">
          <source>In the strict mode, the specified path must exactly match the structure of the queried JSON document to return an SQL/JSON item, so using this path expression will cause an error. To get the same result as in the lax mode, you have to explicitly unwrap the &lt;code&gt;segments&lt;/code&gt; array:</source>
          <target state="translated">在严格模式下，指定的路径必须与查询的JSON文档的结构完全匹配才能返回SQL / JSON项，因此使用此路径表达式将导致错误。要获得与宽松模式相同的结果，必须显式解开 &lt;code&gt;segments&lt;/code&gt; 数组：</target>
        </trans-unit>
        <trans-unit id="351d4063e5553403441da5e92374ad1230527978" translate="yes" xml:space="preserve">
          <source>In the syntax of &lt;code&gt;CREATE EVENT TRIGGER&lt;/code&gt;, the keywords &lt;code&gt;FUNCTION&lt;/code&gt; and &lt;code&gt;PROCEDURE&lt;/code&gt; are equivalent, but the referenced function must in any case be a function, not a procedure. The use of the keyword &lt;code&gt;PROCEDURE&lt;/code&gt; here is historical and deprecated.</source>
          <target state="translated">在 &lt;code&gt;CREATE EVENT TRIGGER&lt;/code&gt; 的语法中，关键字 &lt;code&gt;FUNCTION&lt;/code&gt; 和 &lt;code&gt;PROCEDURE&lt;/code&gt; 是等效的，但是在任何情况下，引用的函数都必须是函数，而不是过程。在此，关键字 &lt;code&gt;PROCEDURE&lt;/code&gt; 的使用是历史性的，已弃用。</target>
        </trans-unit>
        <trans-unit id="78472b8a63814954829d3aaff5becf4efc83edf2" translate="yes" xml:space="preserve">
          <source>In the syntax of &lt;code&gt;CREATE OPERATOR&lt;/code&gt;, the keywords &lt;code&gt;FUNCTION&lt;/code&gt; and &lt;code&gt;PROCEDURE&lt;/code&gt; are equivalent, but the referenced function must in any case be a function, not a procedure. The use of the keyword &lt;code&gt;PROCEDURE&lt;/code&gt; here is historical and deprecated.</source>
          <target state="translated">在 &lt;code&gt;CREATE OPERATOR&lt;/code&gt; 的语法中，关键字 &lt;code&gt;FUNCTION&lt;/code&gt; 和 &lt;code&gt;PROCEDURE&lt;/code&gt; 是等效的，但是在任何情况下，引用的函数都必须是函数，而不是过程。在此，关键字 &lt;code&gt;PROCEDURE&lt;/code&gt; 的使用是历史性的，已弃用。</target>
        </trans-unit>
        <trans-unit id="57ba8dd34e548ca54ffce2f60f391e867e594c9e" translate="yes" xml:space="preserve">
          <source>In the syntax of &lt;code&gt;CREATE TRIGGER&lt;/code&gt;, the keywords &lt;code&gt;FUNCTION&lt;/code&gt; and &lt;code&gt;PROCEDURE&lt;/code&gt; are equivalent, but the referenced function must in any case be a function, not a procedure. The use of the keyword &lt;code&gt;PROCEDURE&lt;/code&gt; here is historical and deprecated.</source>
          <target state="translated">在 &lt;code&gt;CREATE TRIGGER&lt;/code&gt; 的语法中，关键字 &lt;code&gt;FUNCTION&lt;/code&gt; 和 &lt;code&gt;PROCEDURE&lt;/code&gt; 是等效的，但是在任何情况下，引用的函数都必须是函数，而不是过程。在此，关键字 &lt;code&gt;PROCEDURE&lt;/code&gt; 的使用是历史性的，已弃用。</target>
        </trans-unit>
        <trans-unit id="e9e4c8cc0471f863f66674a10b7573f32e28c279" translate="yes" xml:space="preserve">
          <source>In the text form of a range, an inclusive lower bound is represented by &amp;ldquo;&lt;code&gt;[&lt;/code&gt;&amp;rdquo; while an exclusive lower bound is represented by &amp;ldquo;&lt;code&gt;(&lt;/code&gt;&amp;rdquo;. Likewise, an inclusive upper bound is represented by &amp;ldquo;&lt;code&gt;]&lt;/code&gt;&amp;rdquo;, while an exclusive upper bound is represented by &amp;ldquo;&lt;code&gt;)&lt;/code&gt;&amp;rdquo;. (See &lt;a href=&quot;rangetypes#RANGETYPES-IO&quot;&gt;Section 8.17.5&lt;/a&gt; for more details.)</source>
          <target state="translated">在范围的文本形式中，包含性下限由&amp;ldquo; &lt;code&gt;[&lt;/code&gt; &amp;rdquo; 表示，排他性下限由&amp;ldquo; &lt;code&gt;(&lt;/code&gt; &amp;rdquo; 表示。同样，包含性上界由&amp;ldquo; &lt;code&gt;]&lt;/code&gt; &amp;rdquo; 表示，而排他性上界则表示通过&amp;ldquo; &lt;code&gt;)&lt;/code&gt; &amp;rdquo;。 （有关更多详细信息，请参见&lt;a href=&quot;rangetypes#RANGETYPES-IO&quot;&gt;第8.17.5节&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="87e71fe4fdbdcfebf301c0661fd38f3ccfa52a22" translate="yes" xml:space="preserve">
          <source>In the verbose input format, and in some fields of the more compact input formats, field values can have fractional parts; for example &lt;code&gt;'1.5 week'&lt;/code&gt; or &lt;code&gt;'01:02:03.45'&lt;/code&gt;. Such input is converted to the appropriate number of months, days, and seconds for storage. When this would result in a fractional number of months or days, the fraction is added to the lower-order fields using the conversion factors 1 month = 30 days and 1 day = 24 hours. For example, &lt;code&gt;'1.5 month'&lt;/code&gt; becomes 1 month and 15 days. Only seconds will ever be shown as fractional on output.</source>
          <target state="translated">在冗长的输入格式中，以及在某些更紧凑的输入格式的字段中，字段值可以包含小数部分；例如 &lt;code&gt;'1.5 week'&lt;/code&gt; 或 &lt;code&gt;'01:02:03.45'&lt;/code&gt; 。此类输入将转换为适当的月数，天数和秒数以进行存储。如果这将导致小数个月或几天，那么该分数将使用1个月= 30天和1天= 24小时的转换因子添加到低阶字段中。例如， &lt;code&gt;'1.5 month'&lt;/code&gt; 变为1个月15天。在输出中，仅秒将显示为小数。</target>
        </trans-unit>
        <trans-unit id="352c1b7bd2689ed0c741aae1f8598e4432b2e419" translate="yes" xml:space="preserve">
          <source>In the world of measurements, 6.50 is not the same as 6.5. It may sometimes be critically different. The experimenters usually write down (and publish) the digits they trust. 6.50 is actually a fuzzy interval contained within a bigger and even fuzzier interval, 6.5, with their center points being (probably) the only common feature they share. We definitely do not want such different data items to appear the same.</source>
          <target state="translated">在测量的世界里,6.50和6.5是不一样的。它有时可能会有关键性的不同。实验者通常会写下(并公布)他们所信任的数字。6.50实际上是一个模糊区间,包含在一个更大甚至更模糊的区间6.5内,它们的中心点是(可能)它们唯一的共同特征。我们绝对不希望这样不同的数据项出现相同的情况。</target>
        </trans-unit>
        <trans-unit id="d16185ffce558efd6646fae1f89738ca57d3dd9c" translate="yes" xml:space="preserve">
          <source>In these expressions, the desired time zone &lt;code&gt;zone&lt;/code&gt; can be specified either as a text string (e.g., &lt;code&gt;'America/Los_Angeles'&lt;/code&gt;) or as an interval (e.g., &lt;code&gt;INTERVAL '-08:00'&lt;/code&gt;). In the text case, a time zone name can be specified in any of the ways described in &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;Section 8.5.3&lt;/a&gt;.</source>
          <target state="translated">在这些表达式中，所需的时区 &lt;code&gt;zone&lt;/code&gt; 既可以指定为一个文本串（例如， &lt;code&gt;'America/Los_Angeles'&lt;/code&gt; ）或者一个时间间隔（例如， &lt;code&gt;INTERVAL '-08:00'&lt;/code&gt; ）。在文本情况下，可以以&lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;第8.5.3节中&lt;/a&gt;描述的任何方式指定时区名称。</target>
        </trans-unit>
        <trans-unit id="ccebf94cbd61b9484dc9b7fa83da6e0dd760a88b" translate="yes" xml:space="preserve">
          <source>In these expressions, the desired time zone &lt;code&gt;zone&lt;/code&gt; can be specified either as a text value (e.g., &lt;code&gt;'America/Los_Angeles'&lt;/code&gt;) or as an interval (e.g., &lt;code&gt;INTERVAL '-08:00'&lt;/code&gt;). In the text case, a time zone name can be specified in any of the ways described in &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;Section 8.5.3&lt;/a&gt;. The interval case is only useful for zones that have fixed offsets from UTC, so it is not very common in practice.</source>
          <target state="translated">在这些表达式中，所需的时区 &lt;code&gt;zone&lt;/code&gt; 既可以指定为一个文本值（例如， &lt;code&gt;'America/Los_Angeles'&lt;/code&gt; ）或者一个时间间隔（例如， &lt;code&gt;INTERVAL '-08:00'&lt;/code&gt; ）。在文本情况下，可以以&lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;第8.5.3节中&lt;/a&gt;描述的任何方式指定时区名称。间隔情况仅适用于与UTC具有固定偏移量的区域，因此在实践中不是很常见。</target>
        </trans-unit>
        <trans-unit id="13d5bca14d2cfde080255e10973a28114214ea10" translate="yes" xml:space="preserve">
          <source>In this case the parser looks to see if there is an operator taking &lt;code&gt;text&lt;/code&gt; for both arguments. Since there is, it assumes that the second argument should be interpreted as type &lt;code&gt;text&lt;/code&gt;.</source>
          <target state="translated">在这种情况下，解析器将查看是否有一个运算符将两个参数都用作 &lt;code&gt;text&lt;/code&gt; 。由于存在，因此假定第二个参数应解释为 &lt;code&gt;text&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="d2822670753f6c1107e46ff79d0892389494ad1a" translate="yes" xml:space="preserve">
          <source>In this case there is no MCV information for &lt;code&gt;unique2&lt;/code&gt; because all the values appear to be unique, so we use an algorithm that relies only on the number of distinct values for both relations together with their null fractions:</source>
          <target state="translated">在这种情况下，因为所有值似乎都是唯一的，所以没有用于 &lt;code&gt;unique2&lt;/code&gt; 的 MCV信息，因此我们使用的算法仅依赖于两个关系的不同值的数量及其空分数：</target>
        </trans-unit>
        <trans-unit id="454dfb68a36b15232f0a47fef88c353fb8b457de" translate="yes" xml:space="preserve">
          <source>In this case there is no initial hint for which type to use, since no types are specified in the query. So, the parser looks for all candidate operators and finds that there are candidates accepting both string-category and bit-string-category inputs. Since string category is preferred when available, that category is selected, and then the preferred type for strings, &lt;code&gt;text&lt;/code&gt;, is used as the specific type to resolve the unknown-type literals as.</source>
          <target state="translated">在这种情况下，由于没有在查询中指定任何类型，因此没有针对使用哪种类型的初始提示。因此，解析器将查找所有候选运算符，并发现存在同时接受字符串类别和位字​​符串类别输入的候选者。由于字符串类别在可用时是首选的，因此将选择该类别，然后将字符串的首选类型 &lt;code&gt;text&lt;/code&gt; 用作特定类型，以将未知类型的文字解析为。</target>
        </trans-unit>
        <trans-unit id="643fc82591ff3cc1a1f002cde4bff205b2405706" translate="yes" xml:space="preserve">
          <source>In this case, a regular user cannot reference &lt;code&gt;customer.credit&lt;/code&gt; directly, but a trusted procedure &lt;code&gt;show_credit&lt;/code&gt; allows the user to print the credit card numbers of customers with some of the digits masked out.</source>
          <target state="translated">在这种情况下，普通用户无法直接引用 &lt;code&gt;customer.credit&lt;/code&gt; ，但是受信任的过程 &lt;code&gt;show_credit&lt;/code&gt; 允许用户打印出某些数字被屏蔽的客户的信用卡号。</target>
        </trans-unit>
        <trans-unit id="d737c289d22cb958cf827fb7f26271e5be10a1e7" translate="yes" xml:space="preserve">
          <source>In this case, a row of &lt;code&gt;capitals&lt;/code&gt;&lt;em&gt;inherits&lt;/em&gt; all columns (&lt;code&gt;name&lt;/code&gt;, &lt;code&gt;population&lt;/code&gt;, and &lt;code&gt;altitude&lt;/code&gt;) from its &lt;em&gt;parent&lt;/em&gt;, &lt;code&gt;cities&lt;/code&gt;. The type of the column &lt;code&gt;name&lt;/code&gt; is &lt;code&gt;text&lt;/code&gt;, a native PostgreSQL type for variable length character strings. State capitals have an extra column, &lt;code&gt;state&lt;/code&gt;, that shows their state. In PostgreSQL, a table can inherit from zero or more other tables.</source>
          <target state="translated">在这种情况下，一行 &lt;code&gt;capitals&lt;/code&gt; &lt;em&gt;继承&lt;/em&gt;所有的列（ &lt;code&gt;name&lt;/code&gt; ， &lt;code&gt;population&lt;/code&gt; ，和 &lt;code&gt;altitude&lt;/code&gt; 从）&lt;em&gt;母公司&lt;/em&gt;， &lt;code&gt;cities&lt;/code&gt; 。列 &lt;code&gt;name&lt;/code&gt; 的类型为 &lt;code&gt;text&lt;/code&gt; ，这是PostgreSQL的本机类型，用于可变长度的字符串。州首府还有一个额外的列 &lt;code&gt;state&lt;/code&gt; ，用于显示其州。在PostgreSQL中，一个表可以从零个或多个其他表继承。</target>
        </trans-unit>
        <trans-unit id="a5c8500d7c402e7f06456adc9676ed53904411ff" translate="yes" xml:space="preserve">
          <source>In this case, a row of &lt;code&gt;capitals&lt;/code&gt;&lt;em&gt;inherits&lt;/em&gt; all columns (&lt;code&gt;name&lt;/code&gt;, &lt;code&gt;population&lt;/code&gt;, and &lt;code&gt;elevation&lt;/code&gt;) from its &lt;em&gt;parent&lt;/em&gt;, &lt;code&gt;cities&lt;/code&gt;. The type of the column &lt;code&gt;name&lt;/code&gt; is &lt;code&gt;text&lt;/code&gt;, a native PostgreSQL type for variable length character strings. The &lt;code&gt;capitals&lt;/code&gt; table has an additional column, &lt;code&gt;state&lt;/code&gt;, which shows its state abbreviation. In PostgreSQL, a table can inherit from zero or more other tables.</source>
          <target state="translated">在这种情况下，一行 &lt;code&gt;capitals&lt;/code&gt; &lt;em&gt;继承&lt;/em&gt;所有的列（ &lt;code&gt;name&lt;/code&gt; ， &lt;code&gt;population&lt;/code&gt; ，以及 &lt;code&gt;elevation&lt;/code&gt; 从它）&lt;em&gt;父&lt;/em&gt;， &lt;code&gt;cities&lt;/code&gt; 。列 &lt;code&gt;name&lt;/code&gt; 的类型为 &lt;code&gt;text&lt;/code&gt; ，这是PostgreSQL的本机类型，用于可变长度的字符串。在 &lt;code&gt;capitals&lt;/code&gt; 表具有一个附加列， &lt;code&gt;state&lt;/code&gt; ，其示出其状态的缩写。在PostgreSQL中，一个表可以从零个或多个其他表继承。</target>
        </trans-unit>
        <trans-unit id="613ba4c32d099503d94bd47a030a2a2ad44892dd" translate="yes" xml:space="preserve">
          <source>In this case, the &lt;code&gt;capitals&lt;/code&gt; table &lt;em&gt;inherits&lt;/em&gt; all the columns of its parent table, &lt;code&gt;cities&lt;/code&gt;. State capitals also have an extra column, &lt;code&gt;state&lt;/code&gt;, that shows their state.</source>
          <target state="translated">在这种情况下， &lt;code&gt;capitals&lt;/code&gt; 表&lt;em&gt;继承&lt;/em&gt;其父表的所有列， &lt;code&gt;cities&lt;/code&gt; 。州首府也有一个额外的列 &lt;code&gt;state&lt;/code&gt; ，用于显示其州。</target>
        </trans-unit>
        <trans-unit id="af318a98fb799d225d9e923e2e4473ff3043a3f6" translate="yes" xml:space="preserve">
          <source>In this configuration, the sample &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; above takes 115.9 ms. That's 1061 ns of timing overhead, again a small multiple of what's measured directly by this utility. That much timing overhead means the actual query itself is only taking a tiny fraction of the accounted for time, most of it is being consumed in overhead instead. In this configuration, any &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; totals involving many timed operations would be inflated significantly by timing overhead.</source>
          <target state="translated">在此配置中，上面的示例 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 需要115.9毫秒。这是1061 ns的时序开销，再次是此实用程序直接测量的结果的一小部分。如此多的计时开销意味着实际的查询本身仅占时间的一小部分，而大部分却被消耗在开销中。在这种配置中，任何涉及许多定时操作的 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 总计都会因定时开销而大大增加。</target>
        </trans-unit>
        <trans-unit id="abed36bdd05542db8e718c1091a76817a77d802e" translate="yes" xml:space="preserve">
          <source>In this example above we were allowed to switch from the larger MCS range &lt;code&gt;c1.c1023&lt;/code&gt; to the smaller range &lt;code&gt;c1.c4&lt;/code&gt;, but switching back was denied.</source>
          <target state="translated">在上面的示例中，我们被允许从较大的MCS范围 &lt;code&gt;c1.c1023&lt;/code&gt; 切换到较小的 &lt;code&gt;c1.c4&lt;/code&gt; 范围，但拒绝切换回去。</target>
        </trans-unit>
        <trans-unit id="e7326012a121c41d2c47ed971d8505d7a7de76bf" translate="yes" xml:space="preserve">
          <source>In this example the Update node needs to consider three child tables as well as the originally-mentioned parent table. So there are four input scanning subplans, one per table. For clarity, the Update node is annotated to show the specific target tables that will be updated, in the same order as the corresponding subplans. (These annotations are new as of PostgreSQL 9.5; in prior versions the reader had to intuit the target tables by inspecting the subplans.)</source>
          <target state="translated">在这个例子中,Update节点需要考虑三个子表以及原来提到的父表。所以有四个输入扫描子计划,每个表一个。为了清晰起见,Update节点被注释为显示将被更新的特定目标表,顺序与相应的子计划相同。(这些注释是PostgreSQL 9.5的新内容;在之前的版本中,读者必须通过检查子计划来直观地了解目标表。)</target>
        </trans-unit>
        <trans-unit id="90020459ceef361caea70168cdc85c26559a0eb6" translate="yes" xml:space="preserve">
          <source>In this example the join's output row count is the same as the product of the two scans' row counts, but that's not true in all cases because there can be additional &lt;code&gt;WHERE&lt;/code&gt; clauses that mention both tables and so can only be applied at the join point, not to either input scan. Here's an example:</source>
          <target state="translated">在此示例中，联接的输出行数与两次扫描的行数的乘积相同，但并非在所有情况下都是如此，因为可能存在提及两个表的附加 &lt;code&gt;WHERE&lt;/code&gt; 子句，因此只能在联接点应用，而不要输入扫描。这是一个例子：</target>
        </trans-unit>
        <trans-unit id="f68e5dbd48ccbde70e786ec3f6ee97430aeb6b1e" translate="yes" xml:space="preserve">
          <source>In this example, if &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;(none)&lt;/code&gt;, null is returned, otherwise the value of &lt;code&gt;value&lt;/code&gt; is returned.</source>
          <target state="translated">在此示例中，如果 &lt;code&gt;value&lt;/code&gt; 为 &lt;code&gt;(none)&lt;/code&gt; ，则返回null，否则返回value的 &lt;code&gt;value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6956c57a06842052520c448c372cfcf4ca7298a5" translate="yes" xml:space="preserve">
          <source>In this example, if four standby servers &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt;, &lt;code&gt;s3&lt;/code&gt; and &lt;code&gt;s4&lt;/code&gt; are running, the two standbys &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; will be chosen as synchronous standbys because their names appear early in the list of standby names. &lt;code&gt;s3&lt;/code&gt; is a potential synchronous standby and will take over the role of synchronous standby when either of &lt;code&gt;s1&lt;/code&gt; or &lt;code&gt;s2&lt;/code&gt; fails. &lt;code&gt;s4&lt;/code&gt; is an asynchronous standby since its name is not in the list.</source>
          <target state="translated">在这个例子中，如果四个备用服务器 &lt;code&gt;s1&lt;/code&gt; ， &lt;code&gt;s2&lt;/code&gt; ， &lt;code&gt;s3&lt;/code&gt; 和 &lt;code&gt;s4&lt;/code&gt; 正在运行，两个备用 &lt;code&gt;s1&lt;/code&gt; 和 &lt;code&gt;s2&lt;/code&gt; 将因为他们的名字在备用名称列表中出现较早选为同步备用。 &lt;code&gt;s3&lt;/code&gt; 是潜在的同步备用数据库，当 &lt;code&gt;s1&lt;/code&gt; 或 &lt;code&gt;s2&lt;/code&gt; 中的任何一个发生故障时，它将取代同步备用数据库。 &lt;code&gt;s4&lt;/code&gt; 是异步备用数据库，因为其名称不在列表中。</target>
        </trans-unit>
        <trans-unit id="5ecb1dc9291b661bf70c843bbe812e41c22f83de" translate="yes" xml:space="preserve">
          <source>In this example, if four standby servers &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt;, &lt;code&gt;s3&lt;/code&gt; and &lt;code&gt;s4&lt;/code&gt; are running, transaction commits will wait for replies from at least any two standbys of &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt; and &lt;code&gt;s3&lt;/code&gt;. &lt;code&gt;s4&lt;/code&gt; is an asynchronous standby since its name is not in the list.</source>
          <target state="translated">在此示例中，如果四个备用服务器 &lt;code&gt;s1&lt;/code&gt; ， &lt;code&gt;s2&lt;/code&gt; ， &lt;code&gt;s3&lt;/code&gt; 和 &lt;code&gt;s4&lt;/code&gt; 正在运行，则事务提交将等待来自 &lt;code&gt;s1&lt;/code&gt; ， &lt;code&gt;s2&lt;/code&gt; 和 &lt;code&gt;s3&lt;/code&gt; 至少两个备用服务器的答复。 &lt;code&gt;s4&lt;/code&gt; 是异步备用数据库，因为其名称不在列表中。</target>
        </trans-unit>
        <trans-unit id="52a2cd0a65091e20d376dc71b4672a80c22c4d96" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;TEMPLATE template0&lt;/code&gt; clause is required if the specified locale is different from the one in &lt;code&gt;template1&lt;/code&gt;. (If it is not, then specifying the locale explicitly is redundant.)</source>
          <target state="translated">在此示例中，如果指定的语言环境与 &lt;code&gt;template1&lt;/code&gt; 中的语言环境不同，则需要 &lt;code&gt;TEMPLATE template0&lt;/code&gt; 子句。（如果不是，则显式指定语言环境是多余的。）</target>
        </trans-unit>
        <trans-unit id="8c5f7d8e9b592b4d5a3f718483f7acd727a00e09" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;len&lt;/code&gt; column is omitted and therefore it will have the default value:</source>
          <target state="translated">在此示例中， &lt;code&gt;len&lt;/code&gt; 列被省略，因此它将具有默认值：</target>
        </trans-unit>
        <trans-unit id="3694c54d9cfcf70eda6933c152be42b7c937c601" translate="yes" xml:space="preserve">
          <source>In this example, the columns &lt;code&gt;product_id&lt;/code&gt;, &lt;code&gt;p.name&lt;/code&gt;, and &lt;code&gt;p.price&lt;/code&gt; must be in the &lt;code&gt;GROUP BY&lt;/code&gt; clause since they are referenced in the query select list (but see below). The column &lt;code&gt;s.units&lt;/code&gt; does not have to be in the &lt;code&gt;GROUP BY&lt;/code&gt; list since it is only used in an aggregate expression (&lt;code&gt;sum(...)&lt;/code&gt;), which represents the sales of a product. For each product, the query returns a summary row about all sales of the product.</source>
          <target state="translated">在此示例中，由于在查询选择列表中已引用了列 &lt;code&gt;product_id&lt;/code&gt; ， &lt;code&gt;p.name&lt;/code&gt; 和 &lt;code&gt;p.price&lt;/code&gt; 列，因此它们必须在 &lt;code&gt;GROUP BY&lt;/code&gt; 子句中（但请参见下文）。列 &lt;code&gt;s.units&lt;/code&gt; 不必在 &lt;code&gt;GROUP BY&lt;/code&gt; 列表中，因为它仅用于表示产品销售的聚合表达式（ &lt;code&gt;sum(...)&lt;/code&gt; ）中。对于每种产品，查询将返回有关该产品所有销售额的摘要行。</target>
        </trans-unit>
        <trans-unit id="08a0e2d4d5bc94672e2506daf9e09dfe471fae09" translate="yes" xml:space="preserve">
          <source>In this example, the data type of the second parameter is not specified, so it is inferred from the context in which &lt;code&gt;$2&lt;/code&gt; is used.</source>
          <target state="translated">在此示例中，未指定第二个参数的数据类型，因此可从使用 &lt;code&gt;$2&lt;/code&gt; 的上下文中推断出它。</target>
        </trans-unit>
        <trans-unit id="9ecac118ba12d038d39cec07567975d6d66efcef" translate="yes" xml:space="preserve">
          <source>In this example, the sort order isn't fully specified, and so you might get the San Francisco rows in either order. But you'd always get the results shown above if you do:</source>
          <target state="translated">在这个例子中,排序顺序并没有完全指定,所以你可能会以任何一种顺序得到San Francisco行。但如果你这样做,你总会得到上面所示的结果。</target>
        </trans-unit>
        <trans-unit id="afe2100b24dbf1294da5f781636d42d62e4bc563" translate="yes" xml:space="preserve">
          <source>In this example, the word &lt;code&gt;Brightest&lt;/code&gt; was recognized by the parser as an &lt;code&gt;ASCII word&lt;/code&gt; (alias &lt;code&gt;asciiword&lt;/code&gt;). For this token type the dictionary list is &lt;code&gt;english_ispell&lt;/code&gt; and &lt;code&gt;english_stem&lt;/code&gt;. The word was recognized by &lt;code&gt;english_ispell&lt;/code&gt;, which reduced it to the noun &lt;code&gt;bright&lt;/code&gt;. The word &lt;code&gt;supernovaes&lt;/code&gt; is unknown to the &lt;code&gt;english_ispell&lt;/code&gt; dictionary so it was passed to the next dictionary, and, fortunately, was recognized (in fact, &lt;code&gt;english_stem&lt;/code&gt; is a Snowball dictionary which recognizes everything; that is why it was placed at the end of the dictionary list).</source>
          <target state="translated">在此示例中，解析器将单词 &lt;code&gt;Brightest&lt;/code&gt; 识别为 &lt;code&gt;ASCII word&lt;/code&gt; （别名 &lt;code&gt;asciiword&lt;/code&gt; ）。对于此标记类型，字典列表为 &lt;code&gt;english_ispell&lt;/code&gt; 和 &lt;code&gt;english_stem&lt;/code&gt; 。这个单词被 &lt;code&gt;english_ispell&lt;/code&gt; 识别了，从而将其简化为名词 &lt;code&gt;bright&lt;/code&gt; 。 &lt;code&gt;supernovaes&lt;/code&gt; 这个词在 &lt;code&gt;english_ispell&lt;/code&gt; 字典中是未知的，因此它被传递到下一个字典，而且幸运的是被识别（实际上， &lt;code&gt;english_stem&lt;/code&gt; 是一本能够识别所有内容的Snowball字典；这就是为什么将它放在字典列表的末尾） ）。</target>
        </trans-unit>
        <trans-unit id="3c50776020e0abdc78addf8fd7c7082700a16f21" translate="yes" xml:space="preserve">
          <source>In this example, transaction 82 was late, because its latency (6.173 ms) was over the 5 ms limit. The next two transactions were skipped, because they were already late before they were even started.</source>
          <target state="translated">在这个例子中,事务82迟到了,因为它的延迟(6.173毫秒)超过了5毫秒的限制。接下来的两个事务被跳过,因为它们在开始之前就已经迟到了。</target>
        </trans-unit>
        <trans-unit id="25785dae89df6c58b5b98e5a8b5a16cf8ba5c166" translate="yes" xml:space="preserve">
          <source>In this form, &lt;code&gt;n&lt;/code&gt; counts from 1 to 365, and February 29 is not counted even if it is present. (Thus, a transition occurring on February 29 could not be specified this way. However, days after February have the same numbers whether it's a leap year or not, so that this form is usually more useful than the plain-integer form for transitions on fixed dates.)</source>
          <target state="translated">以这种形式， &lt;code&gt;n&lt;/code&gt; 从1到365进行计数，并且即使存在2月29日也不会被计算在内。（因此，无法以这种方式指定发生在2月29日的转换。但是，无论2月之后的日期是否是leap年，其天数都相同，因此该格式通常比纯整数格式对固定日期。）</target>
        </trans-unit>
        <trans-unit id="630dd124cc8b0f85590f44f07e341462147cb0a6" translate="yes" xml:space="preserve">
          <source>In this group of commands, the letters &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt;, and &lt;code&gt;v&lt;/code&gt; stand for foreign table, index, materialized view, sequence, table, and view, respectively. You can specify any or all of these letters, in any order, to obtain a listing of objects of these types. For example, &lt;code&gt;\dit&lt;/code&gt; lists indexes and tables. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its physical size on disk and its associated description, if any. If &lt;code&gt;pattern&lt;/code&gt; is specified, only objects whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects.</source>
          <target state="translated">在这组命令中，字母 &lt;code&gt;E&lt;/code&gt; ， &lt;code&gt;i&lt;/code&gt; ， &lt;code&gt;m&lt;/code&gt; ， &lt;code&gt;s&lt;/code&gt; ， &lt;code&gt;t&lt;/code&gt; 和 &lt;code&gt;v&lt;/code&gt; 分别代表外来表，索引，实例化视图，序列，表和视图。您可以以任何顺序指定任何或所有这些字母，以获得这些类型的对象的列表。例如， &lt;code&gt;\dit&lt;/code&gt; 列出索引和表。如果在命令名后附加 &lt;code&gt;+&lt;/code&gt; ，则会列出每个对象及其在磁盘上的物理大小及其相关的描述（如果有）。如果 &lt;code&gt;pattern&lt;/code&gt; 被指定，只有这些对象的名称匹配模式的上市。默认情况下，仅显示用户创建的对象。提供图案或 &lt;code&gt;S&lt;/code&gt; 修饰符以包含系统对象。</target>
        </trans-unit>
        <trans-unit id="e1a2b0abebbac2543bf7c44bb0372db4d5e5c034" translate="yes" xml:space="preserve">
          <source>In this group of commands, the letters &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt;, and &lt;code&gt;v&lt;/code&gt; stand for foreign table, index, materialized view, sequence, table, and view, respectively. You can specify any or all of these letters, in any order, to obtain a listing of objects of these types. For example, &lt;code&gt;\dti&lt;/code&gt; lists tables and indexes. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its persistence status (permanent, temporary, or unlogged), physical size on disk, and associated description if any. If &lt;code&gt;pattern&lt;/code&gt; is specified, only objects whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects.</source>
          <target state="translated">在这组命令中，字母 &lt;code&gt;E&lt;/code&gt; ， &lt;code&gt;i&lt;/code&gt; ， &lt;code&gt;m&lt;/code&gt; ， &lt;code&gt;s&lt;/code&gt; ， &lt;code&gt;t&lt;/code&gt; 和 &lt;code&gt;v&lt;/code&gt; 分别代表外部表，索引，实例化视图，序列，表和视图。您可以以任何顺序指定任何或所有这些字母，以获得这些类型的对象的列表。例如， &lt;code&gt;\dti&lt;/code&gt; 列出表和索引。如果在命令名称后附加 &lt;code&gt;+&lt;/code&gt; ，则会列出每个对象及其持久性状态（永久，临时或未记录），磁盘上的物理大小以及相关的描述（如果有）。如果 &lt;code&gt;pattern&lt;/code&gt; 指定时，仅列出名称与模式匹配的对象。默认情况下，仅显示用户创建的对象。提供一个模式或 &lt;code&gt;S&lt;/code&gt; 修饰符以包括系统对象。</target>
        </trans-unit>
        <trans-unit id="76a2e5dcbe213e98e1493b7e930a93660a65d1fc" translate="yes" xml:space="preserve">
          <source>In this module, the Earth is assumed to be perfectly spherical. (If that's too inaccurate for you, you might want to look at the &lt;a href=&quot;http://postgis.net/&quot;&gt;PostGIS&lt;/a&gt; project.)</source>
          <target state="translated">在此模块中，假定地球是完美球形。 （如果这对您来说太不准确了，您可能要看一下&lt;a href=&quot;http://postgis.net/&quot;&gt;PostGIS&lt;/a&gt;项目。）</target>
        </trans-unit>
        <trans-unit id="d0ed0a5a7df9c6e41189a38e83864f5642c8ac48" translate="yes" xml:space="preserve">
          <source>In this module, the Earth is assumed to be perfectly spherical. (If that's too inaccurate for you, you might want to look at the &lt;a href=&quot;https://postgis.net/&quot;&gt;PostGIS&lt;/a&gt; project.)</source>
          <target state="translated">在此模块中，假设地球是完美的球形。（如果这对您来说太不准确了，您可能要看一下&lt;a href=&quot;https://postgis.net/&quot;&gt;PostGIS&lt;/a&gt;项目。）</target>
        </trans-unit>
        <trans-unit id="fdbad3a8ee3be25a94e567ee2f1c55ff6b62875e" translate="yes" xml:space="preserve">
          <source>In this particular example, the correction from the MCV list is fairly small, because the column distribution is actually quite flat (the statistics showing these particular values as being more common than others are mostly due to sampling error). In a more typical case where some values are significantly more common than others, this complicated process gives a useful improvement in accuracy because the selectivity for the most common values is found exactly.</source>
          <target state="translated">在这个特殊的例子中,来自MCV列表的修正是相当小的,因为列的分布实际上是相当平坦的(显示这些特殊值比其他值更常见的统计数据主要是由于抽样误差)。在更典型的情况下,一些值明显比其他值更常见,这个复杂的过程给准确度带来了有益的改善,因为对最常见值的选择性被准确地找到了。</target>
        </trans-unit>
        <trans-unit id="35b50273596d3b9b0a5ab879d1dff2a027177930" translate="yes" xml:space="preserve">
          <source>In this plan, we have a nested-loop join node with two table scans as inputs, or children. The indentation of the node summary lines reflects the plan tree structure. The join's first, or &amp;ldquo;outer&amp;rdquo;, child is a bitmap scan similar to those we saw before. Its cost and row count are the same as we'd get from &lt;code&gt;SELECT ... WHERE unique1 &amp;lt; 10&lt;/code&gt; because we are applying the &lt;code&gt;WHERE&lt;/code&gt; clause &lt;code&gt;unique1 &amp;lt; 10&lt;/code&gt; at that node. The &lt;code&gt;t1.unique2 = t2.unique2&lt;/code&gt; clause is not relevant yet, so it doesn't affect the row count of the outer scan. The nested-loop join node will run its second, or &amp;ldquo;inner&amp;rdquo; child once for each row obtained from the outer child. Column values from the current outer row can be plugged into the inner scan; here, the &lt;code&gt;t1.unique2&lt;/code&gt; value from the outer row is available, so we get a plan and costs similar to what we saw above for a simple &lt;code&gt;SELECT ... WHERE t2.unique2 = constant&lt;/code&gt; case. (The estimated cost is actually a bit lower than what was seen above, as a result of caching that's expected to occur during the repeated index scans on &lt;code&gt;t2&lt;/code&gt;.) The costs of the loop node are then set on the basis of the cost of the outer scan, plus one repetition of the inner scan for each outer row (10 * 7.91, here), plus a little CPU time for join processing.</source>
          <target state="translated">在此计划中，我们有一个嵌套循环联接节点，其中两个表扫描作为输入或子级。节点摘要线的缩进反映了计划树的结构。联接的第一个（或&amp;ldquo;外部&amp;rdquo;）子级是位图扫描，与我们之前看到的类似。它的成本和行数与我们从 &lt;code&gt;SELECT ... WHERE unique1 &amp;lt; 10&lt;/code&gt; 获得的相同，因为我们在该节点上应用 &lt;code&gt;WHERE&lt;/code&gt; 子句 &lt;code&gt;unique1 &amp;lt; 10&lt;/code&gt; 。该 &lt;code&gt;t1.unique2 = t2.unique2&lt;/code&gt; 条款还不相关，因此它不影响外层扫描的行数。嵌套循环连接节点将对从外部子级获得的每一行运行其第二个子级或&amp;ldquo;内部&amp;rdquo;子级。当前外部行中的列值可以插入内部扫描中；在这里， &lt;code&gt;t1.unique2&lt;/code&gt; 外部行的值是可用的，因此我们得到的计划和成本与上面针对简单的 &lt;code&gt;SELECT ... WHERE t2.unique2 = constant&lt;/code&gt; 情况类似。 （由于预期会在 &lt;code&gt;t2&lt;/code&gt; 上进行重复索引扫描期间进行缓存，因此估计的成本实际上比上面看到的要低。）然后，根据节点的成本来设置循环节点的成本。外部扫描，再加上每个外部行的内部扫描重复一次（此处为10 * 7.91），再加上少量的CPU时间用于连接处理。</target>
        </trans-unit>
        <trans-unit id="92ba779e5f5f15aa09f4dc327e10902ae3870fba" translate="yes" xml:space="preserve">
          <source>In this syntax, a zone abbreviation can be a string of letters, such as &lt;code&gt;EST&lt;/code&gt;, or an arbitrary string surrounded by angle brackets, such as &lt;code&gt;&amp;lt;UTC-05&amp;gt;&lt;/code&gt;. Note that the zone abbreviations given here are only used for output, and even then only in some timestamp output formats. The zone abbreviations recognized in timestamp input are determined as explained in &lt;a href=&quot;datetime-config-files&quot;&gt;Section B.4&lt;/a&gt;.</source>
          <target state="translated">在此语法中，区域缩写可以是字母字符串，例如 &lt;code&gt;EST&lt;/code&gt; ，也可以是用尖括号包围的任意字符串，例如 &lt;code&gt;&amp;lt;UTC-05&amp;gt;&lt;/code&gt; 。请注意，此处给出的区域缩写仅用于输出，甚至仅用于某些时间戳输出格式。如&lt;a href=&quot;datetime-config-files&quot;&gt;第B.4节&lt;/a&gt;所述，确定在时间戳输入中识别的区域缩写。</target>
        </trans-unit>
        <trans-unit id="2a65ed7368072bf4eca944cd69c42b40f3442c1c" translate="yes" xml:space="preserve">
          <source>In this syntax, the &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;count&lt;/code&gt; value is required by the standard to be a literal constant, a parameter, or a variable name; as a PostgreSQL extension, other expressions are allowed, but will generally need to be enclosed in parentheses to avoid ambiguity. If &lt;code&gt;count&lt;/code&gt; is omitted in a &lt;code&gt;FETCH&lt;/code&gt; clause, it defaults to 1. &lt;code&gt;ROW&lt;/code&gt; and &lt;code&gt;ROWS&lt;/code&gt; as well as &lt;code&gt;FIRST&lt;/code&gt; and &lt;code&gt;NEXT&lt;/code&gt; are noise words that don't influence the effects of these clauses. According to the standard, the &lt;code&gt;OFFSET&lt;/code&gt; clause must come before the &lt;code&gt;FETCH&lt;/code&gt; clause if both are present; but PostgreSQL is laxer and allows either order.</source>
          <target state="translated">在该语法中， &lt;code&gt;start&lt;/code&gt; 或 &lt;code&gt;count&lt;/code&gt; 值由标准所要求的是一个常量，参数，或变量名;作为PostgreSQL扩展，允许使用其他表达式，但通常需要将其括在括号中以避免歧义。如果在 &lt;code&gt;FETCH&lt;/code&gt; 子句中省略了 &lt;code&gt;count&lt;/code&gt; ，则默认为 &lt;code&gt;ROW&lt;/code&gt; 和 &lt;code&gt;ROWS&lt;/code&gt; 以及 &lt;code&gt;FIRST&lt;/code&gt; 和 &lt;code&gt;NEXT&lt;/code&gt; 是不影响这些子句影响的杂音。根据标准， &lt;code&gt;OFFSET&lt;/code&gt; 子句必须同时出现在 &lt;code&gt;FETCH&lt;/code&gt; 子句之前；但是PostgreSQL比较宽松，并且可以使用任何顺序。</target>
        </trans-unit>
        <trans-unit id="1aad7367e4cf00d23ec40e47a1df35bb1446273c" translate="yes" xml:space="preserve">
          <source>In this syntax, the &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;count&lt;/code&gt; value is required by the standard to be a literal constant, a parameter, or a variable name; as a PostgreSQL extension, other expressions are allowed, but will generally need to be enclosed in parentheses to avoid ambiguity. If &lt;code&gt;count&lt;/code&gt; is omitted in a &lt;code&gt;FETCH&lt;/code&gt; clause, it defaults to 1. The &lt;code&gt;WITH TIES&lt;/code&gt; option is used to return any additional rows that tie for the last place in the result set according to the &lt;code&gt;ORDER BY&lt;/code&gt; clause; &lt;code&gt;ORDER BY&lt;/code&gt; is mandatory in this case. &lt;code&gt;ROW&lt;/code&gt; and &lt;code&gt;ROWS&lt;/code&gt; as well as &lt;code&gt;FIRST&lt;/code&gt; and &lt;code&gt;NEXT&lt;/code&gt; are noise words that don't influence the effects of these clauses. According to the standard, the &lt;code&gt;OFFSET&lt;/code&gt; clause must come before the &lt;code&gt;FETCH&lt;/code&gt; clause if both are present; but PostgreSQL is laxer and allows either order.</source>
          <target state="translated">在该语法中， &lt;code&gt;start&lt;/code&gt; 或 &lt;code&gt;count&lt;/code&gt; 值由标准所要求的是一个常量，参数，或变量名; 作为PostgreSQL扩展，允许使用其他表达式，但通常需要将其括在括号中以避免歧义。如果在 &lt;code&gt;FETCH&lt;/code&gt; 子句中省略了 &lt;code&gt;count&lt;/code&gt; ，则默认值为 &lt;code&gt;WITH TIES&lt;/code&gt; 选项用于根据 &lt;code&gt;ORDER BY&lt;/code&gt; 子句返回与结果集中最后一位相关的所有其他行；否则，默认为1 。在这种情况下，必须使用 &lt;code&gt;ORDER BY&lt;/code&gt; 。 &lt;code&gt;ROW&lt;/code&gt; 和 &lt;code&gt;ROWS&lt;/code&gt; 以及 &lt;code&gt;FIRST&lt;/code&gt; 和 &lt;code&gt;NEXT&lt;/code&gt; 是不影响这些子句效果的干扰词。根据标准，如果两者都存在，则 &lt;code&gt;OFFSET&lt;/code&gt; 子句必须位于 &lt;code&gt;FETCH&lt;/code&gt; 子句之前；否则，它们必须位于FETCH子句之前。但是PostgreSQL比较宽松，并且可以使用任意顺序。</target>
        </trans-unit>
        <trans-unit id="6b9893e81c5b40e27434e52e7429139f563d867e" translate="yes" xml:space="preserve">
          <source>In this type of plan the table rows are fetched in index order, which makes them even more expensive to read, but there are so few that the extra cost of sorting the row locations is not worth it. You'll most often see this plan type for queries that fetch just a single row. It's also often used for queries that have an &lt;code&gt;ORDER BY&lt;/code&gt; condition that matches the index order, because then no extra sorting step is needed to satisfy the &lt;code&gt;ORDER BY&lt;/code&gt;.</source>
          <target state="translated">在这种类型的计划中，表行是按索引顺序获取的，这使它们的读取更加昂贵，但由于行数太少，因此不值得对行位置进行排序所产生的额外成本。对于只会读取一行的查询，您通常会看到这种计划类型。它也经常用于具有与索引顺序匹配的 &lt;code&gt;ORDER BY&lt;/code&gt; 条件的查询，因为这样就不需要额外的排序步骤即可满足 &lt;code&gt;ORDER BY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f14120df06086beebf2309a0093abef8ae36a3dc" translate="yes" xml:space="preserve">
          <source>In this type of plan the table rows are fetched in index order, which makes them even more expensive to read, but there are so few that the extra cost of sorting the row locations is not worth it. You'll most often see this plan type for queries that fetch just a single row. It's also often used for queries that have an &lt;code&gt;ORDER BY&lt;/code&gt; condition that matches the index order, because then no extra sorting step is needed to satisfy the &lt;code&gt;ORDER BY&lt;/code&gt;. In this example, adding &lt;code&gt;ORDER BY unique1&lt;/code&gt; would use the same plan because the index already implicitly provides the requested ordering.</source>
          <target state="translated">在这种类型的计划中，表行是按索引顺序获取的，这使它们的读取更加昂贵，但由于行数太少，因此不值得对行位置进行排序所产生的额外成本。对于只会读取一行的查询，您通常会看到这种计划类型。它也经常用于具有与索引顺序匹配的 &lt;code&gt;ORDER BY&lt;/code&gt; 条件的查询，因为这样就不需要额外的排序步骤即可满足 &lt;code&gt;ORDER BY&lt;/code&gt; 。在此示例中，添加 &lt;code&gt;ORDER BY unique1&lt;/code&gt; 将使用相同的计划，因为索引已经隐式提供了所请求的顺序。</target>
        </trans-unit>
        <trans-unit id="84eb5898e8d8ec4083399d85009281a59b8ba4c6" translate="yes" xml:space="preserve">
          <source>In versions prior to PostgreSQL 9.6, this flag matched only tables, not any other type of relation.</source>
          <target state="translated">在PostgreSQL 9.6之前的版本中,这个标志只匹配表,不匹配任何其他类型的关系。</target>
        </trans-unit>
        <trans-unit id="cccb2030fa433816cbfff6cfc31e7b85686eadc9" translate="yes" xml:space="preserve">
          <source>In writing your archive command, you should assume that the file names to be archived can be up to 64 characters long and can contain any combination of ASCII letters, digits, and dots. It is not necessary to preserve the original relative path (&lt;code&gt;%p&lt;/code&gt;) but it is necessary to preserve the file name (&lt;code&gt;%f&lt;/code&gt;).</source>
          <target state="translated">在编写归档命令时，应假定要归档的文件名最长为64个字符，并且可以包含ASCII字母，数字和点的任意组合。不必保留原始相对路径（ &lt;code&gt;%p&lt;/code&gt; ），但必须保留文件名（ &lt;code&gt;%f&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="faddf9df2a3466cccf3377b581482849c1fd5256" translate="yes" xml:space="preserve">
          <source>Inaccurate time keeping can result in system instability. Test any change to the clock source very carefully. Operating system defaults are sometimes made to favor reliability over best accuracy. And if you are using a virtual machine, look into the recommended time sources compatible with it. Virtual hardware faces additional difficulties when emulating timers, and there are often per operating system settings suggested by vendors.</source>
          <target state="translated">不准确的时间保持会导致系统不稳定。请仔细测试时钟源的任何变化。操作系统的默认值有时会偏重于可靠性而不是最佳的准确性。而如果你使用的是虚拟机,请研究一下与之兼容的推荐时间源。虚拟硬件在模拟定时器时面临额外的困难,而且经常有厂商建议的每操作系统设置。</target>
        </trans-unit>
        <trans-unit id="b4bae0608aa0bb22c524d2d34a5bb2a1f5386f27" translate="yes" xml:space="preserve">
          <source>Incidentally, the &lt;code&gt;BEGIN&lt;/code&gt; key word is used for a different purpose in embedded SQL. You are advised to be careful about the transaction semantics when porting database applications.</source>
          <target state="translated">附带地， &lt;code&gt;BEGIN&lt;/code&gt; 关键字在嵌入式SQL中用于不同的目的。建议您在移植数据库应用程序时注意事务语义。</target>
        </trans-unit>
        <trans-unit id="f56a8df3508e9ed5684baab06fa5e61cef26eebf" translate="yes" xml:space="preserve">
          <source>Include &lt;code&gt;pg_trace.h&lt;/code&gt; if it is not already present in the module(s) containing the probe points, and insert &lt;code&gt;TRACE_POSTGRESQL&lt;/code&gt; probe macros at the desired locations in the source code</source>
          <target state="translated">如果 &lt;code&gt;pg_trace.h&lt;/code&gt; 在包含探测点的模块中尚不存在，则将其包含在内，并在源代码中的所需位置插入 &lt;code&gt;TRACE_POSTGRESQL&lt;/code&gt; 探测宏</target>
        </trans-unit>
        <trans-unit id="2d8b7df7f5c4b05fc8f7d8518fd909017b7c32d2" translate="yes" xml:space="preserve">
          <source>Include SQL commands to clean (drop) databases before recreating them. &lt;code&gt;DROP&lt;/code&gt; commands for roles and tablespaces are added as well.</source>
          <target state="translated">包括SQL命令以在重新创建数据库之前清理（删除）数据库。还添加了角色和表空间的 &lt;code&gt;DROP&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="15af567ab13e6ebab28e457206713f05e4dcc212" translate="yes" xml:space="preserve">
          <source>Include actual startup time and time spent in each node in the output. The overhead of repeatedly reading the system clock can slow down the query significantly on some systems, so it may be useful to set this parameter to &lt;code&gt;FALSE&lt;/code&gt; when only actual row counts, and not exact times, are needed. Run time of the entire statement is always measured, even when node-level timing is turned off with this option. This parameter may only be used when &lt;code&gt;ANALYZE&lt;/code&gt; is also enabled. It defaults to &lt;code&gt;TRUE&lt;/code&gt;.</source>
          <target state="translated">在输出中包括实际的启动时间和在每个节点上花费的时间。在某些系统上，重复读取系统时钟的开销可能会大大降低查询的速度，因此，当仅需要实际的行计数而不是确切的时间时，将此参数设置为 &lt;code&gt;FALSE&lt;/code&gt; 可能很有用。即使使用此选项关闭了节点级计时，也始终会测量整个语句的运行时间。仅当还启用了 &lt;code&gt;ANALYZE&lt;/code&gt; 时，才可以使用此参数。默认为 &lt;code&gt;TRUE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="69fd997380e1370b3a2e3a89721390495f72294b" translate="yes" xml:space="preserve">
          <source>Include files or directories can be used to logically separate portions of the database configuration, rather than having a single large &lt;code&gt;postgresql.conf&lt;/code&gt; file. Consider a company that has two database servers, each with a different amount of memory. There are likely elements of the configuration both will share, for things such as logging. But memory-related parameters on the server will vary between the two. And there might be server specific customizations, too. One way to manage this situation is to break the custom configuration changes for your site into three files. You could add this to the end of your &lt;code&gt;postgresql.conf&lt;/code&gt; file to include them:</source>
          <target state="translated">包含文件或目录可用于在逻辑上分隔数据库配置的各个部分，而不是具有单个大型 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件。考虑一家拥有两个数据库服务器的公司，每个服务器具有不同的内存量。对于诸如日志之类的东西，配置中可能都有共享的元素。但是服务器上与内存相关的参数在这两者之间会有所不同。而且可能还会有特定于服务器的自定义项。解决这种情况的一种方法是将站点的自定义配置更改分为三个文件。您可以将其添加到 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件的末尾以包括它们：</target>
        </trans-unit>
        <trans-unit id="12ee2acead9dafe36942e1a0338b4e8cb8ee012c" translate="yes" xml:space="preserve">
          <source>Include information on WAL record generation. Specifically, include the number of records, number of full page images (fpi) and amount of WAL bytes generated. In text format, only non-zero values are printed. This parameter may only be used when &lt;code&gt;ANALYZE&lt;/code&gt; is also enabled. It defaults to &lt;code&gt;FALSE&lt;/code&gt;.</source>
          <target state="translated">包括有关WAL记录生成的信息。具体来说，包括记录数，整页图像（fpi）数和生成的WAL字节数。在文本格式中，仅打印非零值。仅当还启用了 &lt;code&gt;ANALYZE&lt;/code&gt; 时，才可以使用此参数。默认为 &lt;code&gt;FALSE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="47b7156430746d586783036a5e783795b65f9965" translate="yes" xml:space="preserve">
          <source>Include information on buffer usage. Specifically, include the number of shared blocks hit, read, dirtied, and written, the number of local blocks hit, read, dirtied, and written, and the number of temp blocks read and written. A &lt;em&gt;hit&lt;/em&gt; means that a read was avoided because the block was found already in cache when needed. Shared blocks contain data from regular tables and indexes; local blocks contain data from temporary tables and indexes; while temp blocks contain short-term working data used in sorts, hashes, Materialize plan nodes, and similar cases. The number of blocks &lt;em&gt;dirtied&lt;/em&gt; indicates the number of previously unmodified blocks that were changed by this query; while the number of blocks &lt;em&gt;written&lt;/em&gt; indicates the number of previously-dirtied blocks evicted from cache by this backend during query processing. The number of blocks shown for an upper-level node includes those used by all its child nodes. In text format, only non-zero values are printed. This parameter may only be used when &lt;code&gt;ANALYZE&lt;/code&gt; is also enabled. It defaults to &lt;code&gt;FALSE&lt;/code&gt;.</source>
          <target state="translated">包括有关缓冲区使用情况的信息。具体来说，包括命中，读取，弄脏和写入的共享块数，命中，读取，弄脏和写入的本地块数以及读写的临时块数。一&lt;em&gt;击&lt;/em&gt;意味着避免了读，因为在需要的时候块已经在高速缓存中找到。共享块包含常规表和索引中的数据；本地块包含来自临时表和索引的数据；临时块包含用于排序，散列，实体化计划节点和类似情况的短期工作数据。被&lt;em&gt;弄脏&lt;/em&gt;的块数表示此查询已更改的先前未修改的块数；而&lt;em&gt;写&lt;/em&gt;的块数&lt;em&gt;&lt;/em&gt;指示在查询处理期间此后端从缓存中收回的先前处理的块数。上级节点显示的块数包括其所有子节点使用的块数。在文本格式中，仅打印非零值。仅当还启用了 &lt;code&gt;ANALYZE&lt;/code&gt; 时，才可以使用此参数。默认为 &lt;code&gt;FALSE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="42e6828248f4c65573605405eae9a72feadb86b8" translate="yes" xml:space="preserve">
          <source>Include information on buffer usage. Specifically, include the number of shared blocks hit, read, dirtied, and written, the number of local blocks hit, read, dirtied, and written, the number of temp blocks read and written, and the time spent reading and writing data file blocks (in milliseconds) if &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-IO-TIMING&quot;&gt;track_io_timing&lt;/a&gt; is enabled. A &lt;em&gt;hit&lt;/em&gt; means that a read was avoided because the block was found already in cache when needed. Shared blocks contain data from regular tables and indexes; local blocks contain data from temporary tables and indexes; while temp blocks contain short-term working data used in sorts, hashes, Materialize plan nodes, and similar cases. The number of blocks &lt;em&gt;dirtied&lt;/em&gt; indicates the number of previously unmodified blocks that were changed by this query; while the number of blocks &lt;em&gt;written&lt;/em&gt; indicates the number of previously-dirtied blocks evicted from cache by this backend during query processing. The number of blocks shown for an upper-level node includes those used by all its child nodes. In text format, only non-zero values are printed. It defaults to &lt;code&gt;FALSE&lt;/code&gt;.</source>
          <target state="translated">包括有关缓冲区使用情况的信息。具体来说，包括命中，读取，弄脏和写入的共享块数，命中，读取，弄脏和写入的本地块数，读写的临时块数以及读取和写入数据文件块所花费的时间（以毫秒为单位）是否启用了&lt;a href=&quot;runtime-config-statistics#GUC-TRACK-IO-TIMING&quot;&gt;track_io_timing&lt;/a&gt;。一&lt;em&gt;击&lt;/em&gt;意味着避免了读，因为在需要的时候块已经在高速缓存中找到。共享块包含常规表和索引中的数据；本地块包含来自临时表和索引的数据；临时块包含用于排序，散列，实体化计划节点和类似情况的短期工作数据。被&lt;em&gt;弄脏&lt;/em&gt;的块数&lt;em&gt;&lt;/em&gt;指示此查询更改的先前未修改的块数；而&lt;em&gt;写入&lt;/em&gt;的块数表示此后端在查询处理期间从缓存中逐出的先前处理的块数。上级节点显示的块数包括其所有子节点使用的块数。在文本格式中，仅打印非零值。默认为 &lt;code&gt;FALSE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5cf950011b674c52ed53fd1187206feef3854c98" translate="yes" xml:space="preserve">
          <source>Include information on configuration parameters. Specifically, include options affecting query planning with value different from the built-in default value. This parameter defaults to &lt;code&gt;FALSE&lt;/code&gt;.</source>
          <target state="translated">包括有关配置参数的信息。具体来说，包括影响查询计划的选项，其值与内置默认值不同。此参数默认为 &lt;code&gt;FALSE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd7df900c420c99916abebaeb86bc9b9487e3ff6" translate="yes" xml:space="preserve">
          <source>Include information on the estimated startup and total cost of each plan node, as well as the estimated number of rows and the estimated width of each row. This parameter defaults to &lt;code&gt;TRUE&lt;/code&gt;.</source>
          <target state="translated">包括有关每个计划节点的估计启动和总成本以及估计的行数和估计的每行宽度的信息。此参数默认为 &lt;code&gt;TRUE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b5b5e034a15e397016c3928803cda54f49c8fb74" translate="yes" xml:space="preserve">
          <source>Include large objects in the dump. This is the default behavior except when &lt;code&gt;--schema&lt;/code&gt;, &lt;code&gt;--table&lt;/code&gt;, or &lt;code&gt;--schema-only&lt;/code&gt; is specified. The &lt;code&gt;-b&lt;/code&gt; switch is therefore only useful to add large objects to dumps where a specific schema or table has been requested. Note that blobs are considered data and therefore will be included when &lt;code&gt;--data-only&lt;/code&gt; is used, but not when &lt;code&gt;--schema-only&lt;/code&gt; is.</source>
          <target state="translated">在转储中包括大对象。这是默认行为，除非指定了 &lt;code&gt;--schema&lt;/code&gt; ，-- &lt;code&gt;--table&lt;/code&gt; 或 &lt;code&gt;--schema-only&lt;/code&gt; 。因此， &lt;code&gt;-b&lt;/code&gt; 开关仅在将大型对象添加到请求了特定模式或表的转储时才有用。请注意，blob被视为数据，因此，当使用 &lt;code&gt;--data-only&lt;/code&gt; 时将包括这些blob，但在使用 &lt;code&gt;--schema-only&lt;/code&gt; 时则不包括。</target>
        </trans-unit>
        <trans-unit id="08c7d11c8d4a8d10c948989b5a35951818754be1" translate="yes" xml:space="preserve">
          <source>Include summary information (e.g., totaled timing information) after the query plan. Summary information is included by default when &lt;code&gt;ANALYZE&lt;/code&gt; is used but otherwise is not included by default, but can be enabled using this option. Planning time in &lt;code&gt;EXPLAIN EXECUTE&lt;/code&gt; includes the time required to fetch the plan from the cache and the time required for re-planning, if necessary.</source>
          <target state="translated">在查询计划之后包括摘要信息（例如，总计计时信息）。使用 &lt;code&gt;ANALYZE&lt;/code&gt; 时默认包含摘要信息，否则默认不包含摘要信息，但可以使用此选项启用摘要信息。 &lt;code&gt;EXPLAIN EXECUTE&lt;/code&gt; 中的计划时间包括从缓存中获取计划所需的时间以及必要时进行重新计划的时间。</target>
        </trans-unit>
        <trans-unit id="2f2cb48cc7645d02e5f49dead86862d11be771ed" translate="yes" xml:space="preserve">
          <source>Includes the required WAL (write-ahead log) files in the backup. This will include all write-ahead logs generated during the backup. Unless the method &lt;code&gt;none&lt;/code&gt; is specified, it is possible to start a postmaster in the target directory without the need to consult the log archive, thus making the output a completely standalone backup.</source>
          <target state="translated">在备份中包括所需的WAL（预写日志）文件。这将包括备份期间生成的所有预写日志。除非未指定 &lt;code&gt;none&lt;/code&gt; 方法，否则可以在不需要查询日志存档的情况下在目标目录中启动邮局主管，从而使输出成为完全独立的备份。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
