<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="a096978b727394f0a665fb7212a971c3ee9889e1" translate="yes" xml:space="preserve">
          <source>The implemented SASL mechanisms at the moment are &lt;code&gt;SCRAM-SHA-256&lt;/code&gt; and its variant with channel binding &lt;code&gt;SCRAM-SHA-256-PLUS&lt;/code&gt;. They are described in detail in RFC 7677 and RFC 5802.</source>
          <target state="translated">目前实现的SASL机制是 &lt;code&gt;SCRAM-SHA-256&lt;/code&gt; 及其带有通道绑定 &lt;code&gt;SCRAM-SHA-256-PLUS&lt;/code&gt; 的变体。在RFC 7677和RFC 5802中对它们进行了详细描述。</target>
        </trans-unit>
        <trans-unit id="3994c1cc646c4ef5a61a7d412fe3e39d9a284414" translate="yes" xml:space="preserve">
          <source>The index access costs should be computed using the parameters used by &lt;code&gt;src/backend/optimizer/path/costsize.c&lt;/code&gt;: a sequential disk block fetch has cost &lt;code&gt;seq_page_cost&lt;/code&gt;, a nonsequential fetch has cost &lt;code&gt;random_page_cost&lt;/code&gt;, and the cost of processing one index row should usually be taken as &lt;code&gt;cpu_index_tuple_cost&lt;/code&gt;. In addition, an appropriate multiple of &lt;code&gt;cpu_operator_cost&lt;/code&gt; should be charged for any comparison operators invoked during index processing (especially evaluation of the indexquals themselves).</source>
          <target state="translated">索引访问成本应使用 &lt;code&gt;src/backend/optimizer/path/costsize.c&lt;/code&gt; 使用的参数来计算。c：顺序磁盘块获取的成本为 &lt;code&gt;seq_page_cost&lt;/code&gt; ，非顺序磁盘获取的成本为 &lt;code&gt;random_page_cost&lt;/code&gt; ，并且处理一个索引行的成本通常应视为 &lt;code&gt;cpu_index_tuple_cost&lt;/code&gt; 。另外，应该为索引处理期间调用的任何比较运算符（尤其是对索引的评估本身）收取 &lt;code&gt;cpu_operator_cost&lt;/code&gt; 的适当倍数。</target>
        </trans-unit>
        <trans-unit id="6fef8227d6c9875a9adfc4cf6467a2aea1121c60" translate="yes" xml:space="preserve">
          <source>The index access path being considered. All fields except cost and selectivity values are valid.</source>
          <target state="translated">正在考虑的索引访问路径。除成本和选择性值外,所有字段均有效。</target>
        </trans-unit>
        <trans-unit id="47ab406c0502c2ff0920580c5626f87c7d3ac514" translate="yes" xml:space="preserve">
          <source>The index automatically uses the collation of the underlying column. So a query of the form</source>
          <target state="translated">索引自动使用底层列的整理。所以,一个查询的形式是</target>
        </trans-unit>
        <trans-unit id="d40d5a355329bb21744bf91012270d4b7eadd19f" translate="yes" xml:space="preserve">
          <source>The index cannot have expression columns nor be a partial index. Also, it must be a b-tree index with default sort ordering. These restrictions ensure that the index is equivalent to one that would be built by a regular &lt;code&gt;ADD PRIMARY KEY&lt;/code&gt; or &lt;code&gt;ADD UNIQUE&lt;/code&gt; command.</source>
          <target state="translated">索引不能有表达式列，也不能是部分索引。另外，它必须是具有默认排序顺序的b树索引。这些限制确保索引等于由常规 &lt;code&gt;ADD PRIMARY KEY&lt;/code&gt; 或 &lt;code&gt;ADD UNIQUE&lt;/code&gt; 命令建立的索引。</target>
        </trans-unit>
        <trans-unit id="78493f3623537c9a38e59ae58540f722627b962f" translate="yes" xml:space="preserve">
          <source>The index construction and maintenance functions that an index access method must provide in &lt;code&gt;IndexAmRoutine&lt;/code&gt; are:</source>
          <target state="translated">索引访问方法必须在 &lt;code&gt;IndexAmRoutine&lt;/code&gt; 中提供的索引构造和维护功能是：</target>
        </trans-unit>
        <trans-unit id="3039446ce33001ce11d9ef4cc9e239f9e80ff013" translate="yes" xml:space="preserve">
          <source>The index is being built by the access method-specific code. In this phase, access methods that support progress reporting fill in their own progress data, and the subphase is indicated in this column. Typically, &lt;code&gt;blocks_total&lt;/code&gt; and &lt;code&gt;blocks_done&lt;/code&gt; will contain progress data, as well as potentially &lt;code&gt;tuples_total&lt;/code&gt; and &lt;code&gt;tuples_done&lt;/code&gt;.</source>
          <target state="translated">该索引是由特定于访问方法的代码构建的。在此阶段中，支持进度报告的访问方法将填写其自己的进度数据，并且在此列中指示子阶段。通常， &lt;code&gt;blocks_total&lt;/code&gt; 和 &lt;code&gt;blocks_done&lt;/code&gt; 将包含进度数据，以及潜在的 &lt;code&gt;tuples_total&lt;/code&gt; 和 &lt;code&gt;tuples_done&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8974784c29c6386bf1253069fdf16bf07fbf780" translate="yes" xml:space="preserve">
          <source>The index is created with a signature length of 80 bits, with attributes i1 and i2 mapped to 2 bits, and attribute i3 mapped to 4 bits. We could have omitted the &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;col1&lt;/code&gt;, and &lt;code&gt;col2&lt;/code&gt; specifications since those have the default values.</source>
          <target state="translated">创建的索引的签名长度为80位，属性i1和i2映射为2位，属性i3映射为4位。我们可以省略 &lt;code&gt;length&lt;/code&gt; ， &lt;code&gt;col1&lt;/code&gt; 和 &lt;code&gt;col2&lt;/code&gt; 规范，因为它们具有默认值。</target>
        </trans-unit>
        <trans-unit id="f53b14842204c3afdf4a8da34fde71ed13d02632" translate="yes" xml:space="preserve">
          <source>The index method's strategy number for an operator associated with the operator class.</source>
          <target state="translated">与操作者类相关联的操作者的索引方法的策略号。</target>
        </trans-unit>
        <trans-unit id="62c3a3b1a4517180b23038b6d08f465908556b8b" translate="yes" xml:space="preserve">
          <source>The index method's strategy number for an operator associated with the operator family.</source>
          <target state="translated">指数法对与操作者家族相关联的操作者的策略号。</target>
        </trans-unit>
        <trans-unit id="4a128fb2d5e95c4a7976acace79bbc58b6fb276b" translate="yes" xml:space="preserve">
          <source>The index method's support function number for a function associated with the operator class.</source>
          <target state="translated">指数方法对与运算符类相关联的函数的支持函数号。</target>
        </trans-unit>
        <trans-unit id="8c74967c2b0a4ae3a48c94ba4d59d1361af52eba" translate="yes" xml:space="preserve">
          <source>The index method's support function number for a function associated with the operator family.</source>
          <target state="translated">指数法对与运算符族相关联的函数的支持函数号。</target>
        </trans-unit>
        <trans-unit id="dfbc9f2ec43f190a4f4b92d5261f2d63618ce86e" translate="yes" xml:space="preserve">
          <source>The index search works by extracting trigrams from the regular expression and then looking these up in the index. The more trigrams that can be extracted from the regular expression, the more effective the index search is. Unlike B-tree based searches, the search string need not be left-anchored.</source>
          <target state="translated">索引搜索的工作原理是从正则表达式中提取卦象,然后在索引中查找这些卦象。从正则表达式中提取的卦象越多,索引搜索就越有效。与基于B树的搜索不同,搜索字符串不需要左锚。</target>
        </trans-unit>
        <trans-unit id="76d1075d790db56a70c52b9e9529c4e67b5fd660" translate="yes" xml:space="preserve">
          <source>The index search works by extracting trigrams from the search string and then looking these up in the index. The more trigrams in the search string, the more effective the index search is. Unlike B-tree based searches, the search string need not be left-anchored.</source>
          <target state="translated">索引搜索的工作原理是从搜索字符串中提取卦象,然后在索引中查找这些卦象。搜索字符串中的卦象越多,索引搜索就越有效。与基于B树的搜索不同,搜索字符串不需要左锚。</target>
        </trans-unit>
        <trans-unit id="2ef045e734746214c8ad4568acd243c24cf2fcf6" translate="yes" xml:space="preserve">
          <source>The index supporting a unique, primary key, referential integrity, or exclusion constraint</source>
          <target state="translated">支持唯一、主键、参考完整性或排除约束的索引。</target>
        </trans-unit>
        <trans-unit id="b1f015828c180dda3ed4f3bdc55e0086cb7fcc71" translate="yes" xml:space="preserve">
          <source>The index supporting this constraint, if it's a unique, primary key, foreign key, or exclusion constraint; else 0</source>
          <target state="translated">支持这个约束的索引,如果它是唯一的、主键、外键或排除约束;否则为0。</target>
        </trans-unit>
        <trans-unit id="6c3b8559bb8c83cd05e198719da39b30d3fb1043" translate="yes" xml:space="preserve">
          <source>The index type must support index-only scans. B-tree indexes always do. GiST and SP-GiST indexes support index-only scans for some operator classes but not others. Other index types have no support. The underlying requirement is that the index must physically store, or else be able to reconstruct, the original data value for each index entry. As a counterexample, GIN indexes cannot support index-only scans because each index entry typically holds only part of the original data value.</source>
          <target state="translated">索引类型必须支持只扫描索引。B-树索引总是支持的。GiST 和 SP-GIST 索引对某些运算符类支持只支持索引扫描,但对其他运算符类不支持。其他索引类型不支持。基本的要求是索引必须物理地存储,或者能够重建每个索引条目的原始数据值。作为一个反例,GIN索引不能支持只扫描索引,因为每个索引条目通常只保存原始数据值的一部分。</target>
        </trans-unit>
        <trans-unit id="a6836c640c52510a0b02e594ca8bbfc9b8103067" translate="yes" xml:space="preserve">
          <source>The indicated database user name was not found.</source>
          <target state="translated">未找到指定的数据库用户名。</target>
        </trans-unit>
        <trans-unit id="20e3988dff010547d05b25cba96f92a2ac547dbd" translate="yes" xml:space="preserve">
          <source>The individual elements of a &lt;code&gt;CUBE&lt;/code&gt; or &lt;code&gt;ROLLUP&lt;/code&gt; clause may be either individual expressions, or sublists of elements in parentheses. In the latter case, the sublists are treated as single units for the purposes of generating the individual grouping sets. For example:</source>
          <target state="translated">&lt;code&gt;CUBE&lt;/code&gt; 或 &lt;code&gt;ROLLUP&lt;/code&gt; 子句的单个元素可以是单个表达式，也可以是括号中元素的子列表。在后一种情况下，子列表被视为单个单元，以生成单独的分组集。例如：</target>
        </trans-unit>
        <trans-unit id="478f53ba771627a25e2c5229ba6d54c52bd271c5" translate="yes" xml:space="preserve">
          <source>The individual tables can be added and removed dynamically using &lt;a href=&quot;sql-alterpublication&quot;&gt;ALTER PUBLICATION&lt;/a&gt;. Both the &lt;code&gt;ADD TABLE&lt;/code&gt; and &lt;code&gt;DROP TABLE&lt;/code&gt; operations are transactional; so the table will start or stop replicating at the correct snapshot once the transaction has committed.</source>
          <target state="translated">可以使用&lt;a href=&quot;sql-alterpublication&quot;&gt;ALTER PUBLICATION&lt;/a&gt;动态添加和删除各个表。无论是 &lt;code&gt;ADD TABLE&lt;/code&gt; 和 &lt;code&gt;DROP TABLE&lt;/code&gt; 操作的事务; 因此，一旦提交事务，该表将在正确的快照处开始或停止复制。</target>
        </trans-unit>
        <trans-unit id="55f0b3e0f4002ca62cb368b92a46147d06514b6c" translate="yes" xml:space="preserve">
          <source>The information passed to the client for a notification event includes the notification channel name, the notifying session's server process PID, and the payload string, which is an empty string if it has not been specified.</source>
          <target state="translated">通知事件传递给客户端的信息包括通知通道名、通知会话的服务器进程PID和payload字符串,如果没有指定payload字符串,则为空字符串。</target>
        </trans-unit>
        <trans-unit id="044f2cd515098f5f363f2857b2c2afc07209265a" translate="yes" xml:space="preserve">
          <source>The information schema (&lt;a href=&quot;https://www.postgresql.org/docs/12/information-schema.html&quot;&gt;Chapter 36&lt;/a&gt;) provides an alternative set of views which overlap the functionality of the system views. Since the information schema is SQL-standard whereas the views described here are PostgreSQL-specific, it's usually better to use the information schema if it provides all the information you need.</source>
          <target state="translated">信息模式（&lt;a href=&quot;https://www.postgresql.org/docs/12/information-schema.html&quot;&gt;第36章&lt;/a&gt;）提供了另一组视图，这些视图与系统视图的功能重叠。由于信息模式是SQL标准的，而此处描述的视图是PostgreSQL特定的，因此，如果信息模式提供了您需要的所有信息，通常最好使用该信息模式。</target>
        </trans-unit>
        <trans-unit id="0c18c9f5485d75a93a8e5be63c2bfb9df98cb595" translate="yes" xml:space="preserve">
          <source>The information schema (&lt;a href=&quot;https://www.postgresql.org/docs/13/information-schema.html&quot;&gt;Chapter 36&lt;/a&gt;) provides an alternative set of views which overlap the functionality of the system views. Since the information schema is SQL-standard whereas the views described here are PostgreSQL-specific, it's usually better to use the information schema if it provides all the information you need.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f201ea8f38230c6e8acfb095bb89803ef41bb1b" translate="yes" xml:space="preserve">
          <source>The information to implement this module was collected from several sites, including:</source>
          <target state="translated">实施该模块的信息是从几个网站收集的,包括:</target>
        </trans-unit>
        <trans-unit id="8ffbbc2df15378d40a94e42b70d5fb5af1458af3" translate="yes" xml:space="preserve">
          <source>The initial access privileges; see &lt;a href=&quot;ddl-priv&quot;&gt;Section 5.7&lt;/a&gt; for details</source>
          <target state="translated">初始访问权限；参见&lt;a href=&quot;ddl-priv&quot;&gt;5.7节&lt;/a&gt;的详细信息</target>
        </trans-unit>
        <trans-unit id="8a1054b1ac592ae44e2cf9b51ca38fb26634ef49" translate="yes" xml:space="preserve">
          <source>The initial data in existing subscribed tables are snapshotted and copied in a parallel instance of a special kind of apply process. This process will create its own temporary replication slot and copy the existing data. Once existing data is copied, the worker enters synchronization mode, which ensures that the table is brought up to a synchronized state with the main apply process by streaming any changes that happened during the initial data copy using standard logical replication. Once the synchronization is done, the control of the replication of the table is given back to the main apply process where the replication continues as normal.</source>
          <target state="translated">现有订阅表中的初始数据会在一种特殊的应用进程的并行实例中进行快照和复制。这个进程将创建自己的临时复制槽,并复制现有数据。一旦现有数据被复制,worker就会进入同步模式,通过使用标准的逻辑复制,将初始数据复制过程中发生的任何变化进行流式处理,确保表与主应用进程达到同步状态。同步完成后,将表的复制控制权交还给主应用进程,在主应用进程中继续正常复制。</target>
        </trans-unit>
        <trans-unit id="257568e0871ee2fb3ae1bd84f534adce4db0bec5" translate="yes" xml:space="preserve">
          <source>The initial setting for the state value, when using moving-aggregate mode. This works the same as &lt;code&gt;initial_condition&lt;/code&gt;.</source>
          <target state="translated">使用移动聚合模式时，状态值的初始设置。这与 &lt;code&gt;initial_condition&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="eb62c8458668a0689948660586a0f8259374a819" translate="yes" xml:space="preserve">
          <source>The initial setting for the state value. This must be a string constant in the form accepted for the data type &lt;code&gt;state_data_type&lt;/code&gt;. If not specified, the state value starts out null.</source>
          <target state="translated">状态值的初始设置。这必须是数据类型 &lt;code&gt;state_data_type&lt;/code&gt; 接受的形式的字符串常量。如果未指定，则状态值开始为null。</target>
        </trans-unit>
        <trans-unit id="d82c96a461d121c75c52d8ce64285a1d86e2ab14" translate="yes" xml:space="preserve">
          <source>The initial value of the transition state for moving-aggregate mode. This is a text field containing the initial value in its external string representation. If this field is null, the transition state value starts out null.</source>
          <target state="translated">移动-聚集模式的过渡状态的初始值。这是一个文本字段,包含其外部字符串表示的初始值。如果该字段为空,则过渡状态的初始值为空。</target>
        </trans-unit>
        <trans-unit id="dfef147dfd625c38da29727096d66edbe7450de5" translate="yes" xml:space="preserve">
          <source>The initial value of the transition state. This is a text field containing the initial value in its external string representation. If this field is null, the transition state value starts out null.</source>
          <target state="translated">过渡状态的初始值。这是一个文本字段,包含其外部字符串表示的初始值。如果该字段为空,则过渡状态值为空。</target>
        </trans-unit>
        <trans-unit id="6e8d9c8e49727d756d0711797450f963975e284e" translate="yes" xml:space="preserve">
          <source>The initially assigned data type of a numeric constant is just a starting point for the type resolution algorithms. In most cases the constant will be automatically coerced to the most appropriate type depending on context. When necessary, you can force a numeric value to be interpreted as a specific data type by casting it. For example, you can force a numeric value to be treated as type &lt;code&gt;real&lt;/code&gt; (&lt;code&gt;float4&lt;/code&gt;) by writing:</source>
          <target state="translated">最初分配的数值常量的数据类型只是类型解析算法的起点。在大多数情况下，常量将根据上下文自动强制为最合适的类型。必要时，可以通过强制转换数值将其解释为特定的数据类型。例如，您可以通过编写以下代码来将数值强制为 &lt;code&gt;real&lt;/code&gt; 类型（ &lt;code&gt;float4&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="f4532069877c3839fd18c7cafdf1b166d436f334" translate="yes" xml:space="preserve">
          <source>The inner &lt;code&gt;UNION&lt;/code&gt; is resolved as emitting type &lt;code&gt;text&lt;/code&gt;, according to the rules given above. Then the outer &lt;code&gt;UNION&lt;/code&gt; has inputs of types &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;integer&lt;/code&gt;, leading to the observed error. The problem can be fixed by ensuring that the leftmost &lt;code&gt;UNION&lt;/code&gt; has at least one input of the desired result type.</source>
          <target state="translated">根据上面给出的规则，内部 &lt;code&gt;UNION&lt;/code&gt; 解析为发射类型 &lt;code&gt;text&lt;/code&gt; 。然后，外部 &lt;code&gt;UNION&lt;/code&gt; 具有类型为 &lt;code&gt;text&lt;/code&gt; 和 &lt;code&gt;integer&lt;/code&gt; 的输入，从而导致观察到错误。通过确保最左边的 &lt;code&gt;UNION&lt;/code&gt; 具有至少一个期望结果类型的输入，可以解决此问题。</target>
        </trans-unit>
        <trans-unit id="752b1c95a1eae331cb7a120fbc2cbc7b360efa2f" translate="yes" xml:space="preserve">
          <source>The input for a range value must follow one of the following patterns:</source>
          <target state="translated">范围值的输入必须遵循以下模式之一。</target>
        </trans-unit>
        <trans-unit id="5db960d2928db992e514ea865af6ec0e73cf5806" translate="yes" xml:space="preserve">
          <source>The input format for this type is &lt;code&gt;address/y&lt;/code&gt; where &lt;code&gt;address&lt;/code&gt; is an IPv4 or IPv6 address and &lt;code&gt;y&lt;/code&gt; is the number of bits in the netmask. If the &lt;code&gt;/y&lt;/code&gt; portion is missing, the netmask is 32 for IPv4 and 128 for IPv6, so the value represents just a single host. On display, the &lt;code&gt;/y&lt;/code&gt; portion is suppressed if the netmask specifies a single host.</source>
          <target state="translated">此类型的输入格式为 &lt;code&gt;address/y&lt;/code&gt; ，其中 &lt;code&gt;address&lt;/code&gt; 为IPv4或IPv6地址， &lt;code&gt;y&lt;/code&gt; 为网络掩码中的位数。如果缺少 &lt;code&gt;/y&lt;/code&gt; 部分，则IPv4的网络掩码为32，IPv6的网络掩码为128，因此该值仅表示一个主机。在显示时，如果网络掩码指定单个主机，则 &lt;code&gt;/y&lt;/code&gt; 部分被抑制。</target>
        </trans-unit>
        <trans-unit id="a8be18b330a3d96f66997a77713b943e9dcae523" translate="yes" xml:space="preserve">
          <source>The input format for this type is &lt;code&gt;address/y&lt;/code&gt; where &lt;code&gt;address&lt;/code&gt; is an IPv4 or IPv6 address and &lt;code&gt;y&lt;/code&gt; is the number of bits in the netmask. If the &lt;code&gt;/y&lt;/code&gt; portion is omitted, the netmask is taken to be 32 for IPv4 or 128 for IPv6, so the value represents just a single host. On display, the &lt;code&gt;/y&lt;/code&gt; portion is suppressed if the netmask specifies a single host.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1496dddf6a6d3aece3a51059d08e155ea1323eea" translate="yes" xml:space="preserve">
          <source>The input/output syntax for the JSON data types is as specified in RFC 7159.</source>
          <target state="translated">JSON数据类型的输入/输出语法在RFC 7159中规定。</target>
        </trans-unit>
        <trans-unit id="28b76175a8e4e44a6929b2bbc612975f4e90fb8f" translate="yes" xml:space="preserve">
          <source>The instance handles all key features of a DBMS: read and write access to files and shared memory, assurance of the ACID properties, &lt;a href=&quot;glossary#GLOSSARY-CONNECTION&quot;&gt;connections&lt;/a&gt; to &lt;a href=&quot;glossary#GLOSSARY-CLIENT&quot;&gt;client processes&lt;/a&gt;, privilege verification, crash recovery, replication, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03aa7e8fbd88e7f3d34658426c4782d01d3a8689" translate="yes" xml:space="preserve">
          <source>The intended use of the &lt;code&gt;pause&lt;/code&gt; setting is to allow queries to be executed against the database to check if this recovery target is the most desirable point for recovery. The paused state can be resumed by using &lt;code&gt;pg_wal_replay_resume()&lt;/code&gt; (see &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL-TABLE&quot;&gt;Table 9.86&lt;/a&gt;), which then causes recovery to end. If this recovery target is not the desired stopping point, then shut down the server, change the recovery target settings to a later target and restart to continue recovery.</source>
          <target state="translated">&lt;code&gt;pause&lt;/code&gt; 设置的预期用途是允许对数据库执行查询，以检查此恢复目标是否是最理想的恢复点。可以通过使用 &lt;code&gt;pg_wal_replay_resume()&lt;/code&gt; 恢复暂停状态（请&lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL-TABLE&quot;&gt;参见表9.86&lt;/a&gt;），然后恢复将结束。如果此恢复目标不是所需的停止点，请关闭服务器，将恢复目标设置更改为更高的目标，然后重新启动以继续恢复。</target>
        </trans-unit>
        <trans-unit id="1eb808aeb9bcf9fecdcdeaa1957208268bb0812e" translate="yes" xml:space="preserve">
          <source>The intended use of the &lt;code&gt;pause&lt;/code&gt; setting is to allow queries to be executed against the database to check if this recovery target is the most desirable point for recovery. The paused state can be resumed by using &lt;code&gt;pg_wal_replay_resume()&lt;/code&gt; (see &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL-TABLE&quot;&gt;Table 9.87&lt;/a&gt;), which then causes recovery to end. If this recovery target is not the desired stopping point, then shut down the server, change the recovery target settings to a later target and restart to continue recovery.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eae9a7b2978d9149a7d3a255f37f5ad888745278" translate="yes" xml:space="preserve">
          <source>The intended use of this setting is that logical replication systems set it to &lt;code&gt;replica&lt;/code&gt; when they are applying replicated changes. The effect of that will be that triggers and rules (that have not been altered from their default configuration) will not fire on the replica. See the &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; clauses &lt;code&gt;ENABLE TRIGGER&lt;/code&gt; and &lt;code&gt;ENABLE RULE&lt;/code&gt; for more information.</source>
          <target state="translated">预期使用此设置的是逻辑复制系统将其设置为 &lt;code&gt;replica&lt;/code&gt; 的时候都采用复制的更改。这样做的结果是触发器和规则（尚未从其默认配置更改的触发器和规则）将不会在副本服务器上触发。有关更多信息，请参见&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;子句 &lt;code&gt;ENABLE TRIGGER&lt;/code&gt; 和 &lt;code&gt;ENABLE RULE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e73e54c88ad65514d99a46ba805b5445c9c890d2" translate="yes" xml:space="preserve">
          <source>The intent of this feature is to allow administrators to reduce the I/O impact of these commands on concurrent database activity. There are many situations where it is not important that maintenance commands like &lt;code&gt;VACUUM&lt;/code&gt; and &lt;code&gt;ANALYZE&lt;/code&gt; finish quickly; however, it is usually very important that these commands do not significantly interfere with the ability of the system to perform other database operations. Cost-based vacuum delay provides a way for administrators to achieve this.</source>
          <target state="translated">此功能的目的是允许管理员减少这些命令对并发数据库活动的I / O影响。在许多情况下，快速完成诸如 &lt;code&gt;VACUUM&lt;/code&gt; 和 &lt;code&gt;ANALYZE&lt;/code&gt; 之类的维护命令并不重要；但是，通常非常重要的是这些命令不要显着干扰系统执行其他数据库操作的能力。基于成本的真空延迟为管理员提供了一种方法。</target>
        </trans-unit>
        <trans-unit id="3ce7c282b1076520793e0399674bfd41329343fd" translate="yes" xml:space="preserve">
          <source>The intent of this feature is to allow debugging or performance-measurement libraries to be loaded into specific sessions without an explicit &lt;code&gt;LOAD&lt;/code&gt; command being given. For example, &lt;a href=&quot;auto-explain&quot;&gt;auto_explain&lt;/a&gt; could be enabled for all sessions under a given user name by setting this parameter with &lt;code&gt;ALTER ROLE SET&lt;/code&gt;. Also, this parameter can be changed without restarting the server (but changes only take effect when a new session is started), so it is easier to add new modules this way, even if they should apply to all sessions.</source>
          <target state="translated">此功能的目的是允许将调试或性能评估库加载到特定会话中，而无需给出明确的 &lt;code&gt;LOAD&lt;/code&gt; 命令。例如，通过使用 &lt;code&gt;ALTER ROLE SET&lt;/code&gt; 设置此参数，可以为给定用户名下的所有会话启用&lt;a href=&quot;auto-explain&quot;&gt;auto_explain&lt;/a&gt;。此外，可以在不重新启动服务器的情况下更改此参数（但是更改仅在启动新会话时才生效），因此，即使应将新模块应用于所有会话，也更容易以这种方式添加新模块。</target>
        </trans-unit>
        <trans-unit id="a2719b729cd7a399352ec70d46ec3bef1938f299" translate="yes" xml:space="preserve">
          <source>The intent of this feature is to allow unprivileged users to load debugging or performance-measurement libraries into specific sessions without requiring an explicit &lt;code&gt;LOAD&lt;/code&gt; command. To that end, it would be typical to set this parameter using the &lt;code&gt;PGOPTIONS&lt;/code&gt; environment variable on the client or by using &lt;code&gt;ALTER ROLE SET&lt;/code&gt;.</source>
          <target state="translated">此功能的目的是允许非特权用户将调试或性能测量库加载到特定会话中，而无需显式的 &lt;code&gt;LOAD&lt;/code&gt; 命令。为此，通常使用客户机上的 &lt;code&gt;PGOPTIONS&lt;/code&gt; 环境变量或使用 &lt;code&gt;ALTER ROLE SET&lt;/code&gt; 来设置此参数。</target>
        </trans-unit>
        <trans-unit id="410143821cb3667d869f89c45a8792b1a3405b2c" translate="yes" xml:space="preserve">
          <source>The interface was changed in version 8.4, to reflect the new FSM implementation introduced in the same version.</source>
          <target state="translated">该接口在8.4版本中进行了修改,以反映同一版本中引入的新的FSM实现。</target>
        </trans-unit>
        <trans-unit id="e6f5b2286acbba014ef24a9c86063e430de3bd3b" translate="yes" xml:space="preserve">
          <source>The internal representation of one value of an SQL data type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2585564a6c8456926cf3442c468ac844142dcda1" translate="yes" xml:space="preserve">
          <source>The internal transaction ID type (&lt;code&gt;xid&lt;/code&gt;) is 32 bits wide and wraps around every 4 billion transactions. However, these functions export a 64-bit format that is extended with an &amp;ldquo;epoch&amp;rdquo; counter so it will not wrap around during the life of an installation. The data type used by these functions, &lt;code&gt;txid_snapshot&lt;/code&gt;, stores information about transaction ID visibility at a particular moment in time. Its components are described in &lt;a href=&quot;functions-info#FUNCTIONS-TXID-SNAPSHOT-PARTS&quot;&gt;Table 9.75&lt;/a&gt;.</source>
          <target state="translated">内部事务ID类型（ &lt;code&gt;xid&lt;/code&gt; ）为32位宽，每40亿个事务回绕一次。但是，这些函数会导出64位格式，并使用&amp;ldquo; epoch&amp;rdquo;计数器扩展该格式，因此在安装期间不会回绕。这些函数使用的数据类型 &lt;code&gt;txid_snapshot&lt;/code&gt; 存储有关特定时间的事务ID可见性的信息。其组件在&lt;a href=&quot;functions-info#FUNCTIONS-TXID-SNAPSHOT-PARTS&quot;&gt;表9.75&lt;/a&gt;中描述。</target>
        </trans-unit>
        <trans-unit id="5975b3720301fef7c0533cfc1f13765af09e30a8" translate="yes" xml:space="preserve">
          <source>The internal transaction ID type &lt;code&gt;xid&lt;/code&gt; is 32 bits wide and wraps around every 4 billion transactions. However, the functions shown in &lt;a href=&quot;functions-info#FUNCTIONS-PG-SNAPSHOT&quot;&gt;Table 9.74&lt;/a&gt; use a 64-bit type &lt;code&gt;xid8&lt;/code&gt; that does not wrap around during the life of an installation, and can be converted to &lt;code&gt;xid&lt;/code&gt; by casting if required. The data type &lt;code&gt;pg_snapshot&lt;/code&gt; stores information about transaction ID visibility at a particular moment in time. Its components are described in &lt;a href=&quot;functions-info#FUNCTIONS-PG-SNAPSHOT-PARTS&quot;&gt;Table 9.75&lt;/a&gt;. &lt;code&gt;pg_snapshot&lt;/code&gt;'s textual representation is &lt;code&gt;xmin:xmax:xip_list&lt;/code&gt;. For example &lt;code&gt;10:20:10,14,15&lt;/code&gt; means &lt;code&gt;xmin=10, xmax=20, xip_list=10, 14, 15&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed88f1a587353da5320c94618461fa62d026126f" translate="yes" xml:space="preserve">
          <source>The inverse operation, producing a character string value from &lt;code&gt;xml&lt;/code&gt;, uses the function &lt;code&gt;xmlserialize&lt;/code&gt;:</source>
          <target state="translated">通过 &lt;code&gt;xmlserialize&lt;/code&gt; 函数从 &lt;code&gt;xml&lt;/code&gt; 生成字符串值的逆运算：</target>
        </trans-unit>
        <trans-unit id="7d6e11429a0e8345e13107b3c0d526111bff86da" translate="yes" xml:space="preserve">
          <source>The isolation level of a transaction determines what data the transaction can see when other transactions are running concurrently:</source>
          <target state="translated">事务的隔离级别决定了当其他事务并发运行时,该事务能看到哪些数据。</target>
        </trans-unit>
        <trans-unit id="e2ee987ab1ca440434d3e02dd908e8550d18dae5" translate="yes" xml:space="preserve">
          <source>The items themselves are stored in space allocated backwards from the end of unallocated space. The exact structure varies depending on what the table is to contain. Tables and sequences both use a structure named &lt;code&gt;HeapTupleHeaderData&lt;/code&gt;, described below.</source>
          <target state="translated">项目本身存储在从未分配空间的末尾向后分配的空间中。确切的结构取决于表所包含的内容。表和序列都使用名为 &lt;code&gt;HeapTupleHeaderData&lt;/code&gt; 的结构，如下所述。</target>
        </trans-unit>
        <trans-unit id="e475eb2d988c6851551d574040f066c9556a439f" translate="yes" xml:space="preserve">
          <source>The join condition of an inner join can be written either in the &lt;code&gt;WHERE&lt;/code&gt; clause or in the &lt;code&gt;JOIN&lt;/code&gt; clause. For example, these table expressions are equivalent:</source>
          <target state="translated">可以在 &lt;code&gt;WHERE&lt;/code&gt; 子句或 &lt;code&gt;JOIN&lt;/code&gt; 子句中编写内部联接的联接条件。例如，这些表表达式是等效的：</target>
        </trans-unit>
        <trans-unit id="61d61ab7e2b00d48bd33fdcfe38f2676100e3a4c" translate="yes" xml:space="preserve">
          <source>The join condition specified with &lt;code&gt;ON&lt;/code&gt; can also contain conditions that do not relate directly to the join. This can prove useful for some queries but needs to be thought out carefully. For example:</source>
          <target state="translated">用 &lt;code&gt;ON&lt;/code&gt; 指定的连接条件还可以包含与连接不直接相关的条件。对于某些查询，这可能很有用，但需要仔细考虑。例如：</target>
        </trans-unit>
        <trans-unit id="3614aab2546a7b09e20ddc9fc01ce0160043ffc8" translate="yes" xml:space="preserve">
          <source>The join selectivity estimator function for this operator.</source>
          <target state="translated">该算子的连接选择性估计函数。</target>
        </trans-unit>
        <trans-unit id="d643834432c9495e055ac02fd710963d0e899ceb" translate="yes" xml:space="preserve">
          <source>The join selectivity estimator function for this operator; write NONE to remove existing selectivity estimator.</source>
          <target state="translated">该运算符的连接选择性估计函数;写NONE以删除现有的选择性估计函数。</target>
        </trans-unit>
        <trans-unit id="105b61ba49be801d77c8efa5f2d2e79da5107648" translate="yes" xml:space="preserve">
          <source>The journal that keeps track of the changes in the &lt;a href=&quot;glossary#GLOSSARY-DB-CLUSTER&quot;&gt;database cluster&lt;/a&gt; as user- and system-invoked operations take place. It comprises many individual &lt;a href=&quot;glossary#GLOSSARY-WAL-RECORD&quot;&gt;WAL records&lt;/a&gt; written sequentially to &lt;a href=&quot;glossary#GLOSSARY-WAL-FILE&quot;&gt;WAL files&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e444824ca1c6f24ef2a354622bc8815bf038f6fd" translate="yes" xml:space="preserve">
          <source>The key and parent-key fields can be any data type, but they must be the same type. Note that the &lt;em&gt;&lt;code&gt;start_with&lt;/code&gt;&lt;/em&gt; value must be entered as a text string, regardless of the type of the key field.</source>
          <target state="translated">键和父键字段可以是任何数据类型，但是它们必须是相同的类型。请注意，无论键字段的类型如何，都必须将&lt;em&gt; &lt;code&gt;start_with&lt;/code&gt; &lt;/em&gt;值输入为文本字符串。</target>
        </trans-unit>
        <trans-unit id="5ed049b1b7aaa3ba51ad6c118d926aadc8da74a8" translate="yes" xml:space="preserve">
          <source>The key field(s) for the index are specified as column names, or alternatively as expressions written in parentheses. Multiple fields can be specified if the index method supports multicolumn indexes.</source>
          <target state="translated">索引的关键字段被指定为列名,或者是写在括号里的表达式。如果索引方法支持多列索引,可以指定多个字段。</target>
        </trans-unit>
        <trans-unit id="d640126eef92261555823243becabed1414b9599" translate="yes" xml:space="preserve">
          <source>The key part of a catalog header file is a C structure definition describing the layout of each row of the catalog. This begins with a &lt;code&gt;CATALOG&lt;/code&gt; macro, which so far as the C compiler is concerned is just shorthand for &lt;code&gt;typedef struct FormData_catalogname&lt;/code&gt;. Each field in the struct gives rise to a catalog column. Fields can be annotated using the BKI property macros described in &lt;code&gt;genbki.h&lt;/code&gt;, for example to define a default value for a field or mark it as nullable or not nullable. The &lt;code&gt;CATALOG&lt;/code&gt; line can also be annotated, with some other BKI property macros described in &lt;code&gt;genbki.h&lt;/code&gt;, to define other properties of the catalog as a whole, such as whether it is a shared relation.</source>
          <target state="translated">目录头文件的关键部分是C结构定义，它描述目录的每一行的布局。从 &lt;code&gt;CATALOG&lt;/code&gt; 宏开始，就C编译器而言，它只是 &lt;code&gt;typedef struct FormData_catalogname&lt;/code&gt; 的简写。结构中的每个字段都会产生一个目录列。可以使用 &lt;code&gt;genbki.h&lt;/code&gt; 中描述的BKI属性宏来注释字段，例如，为字段定义默认值或将其标记为可为空或不可为空。也可以使用 &lt;code&gt;genbki.h&lt;/code&gt; 中描述的其他一些BKI属性宏对 &lt;code&gt;CATALOG&lt;/code&gt; 行进行注释，以定义整个目录的其他属性，例如是否为共享关系。</target>
        </trans-unit>
        <trans-unit id="84768082ee997613deb3f74ec096a132ad1ca977" translate="yes" xml:space="preserve">
          <source>The key part of all this is to set up a recovery configuration that describes how you want to recover and how far the recovery should run. The one thing that you absolutely must specify is the &lt;code&gt;restore_command&lt;/code&gt;, which tells PostgreSQL how to retrieve archived WAL file segments. Like the &lt;code&gt;archive_command&lt;/code&gt;, this is a shell command string. It can contain &lt;code&gt;%f&lt;/code&gt;, which is replaced by the name of the desired log file, and &lt;code&gt;%p&lt;/code&gt;, which is replaced by the path name to copy the log file to. (The path name is relative to the current working directory, i.e., the cluster's data directory.) Write &lt;code&gt;%%&lt;/code&gt; if you need to embed an actual &lt;code&gt;%&lt;/code&gt; character in the command. The simplest useful command is something like:</source>
          <target state="translated">所有这一切的关键部分是建立一个恢复配置，该配置描述了您要如何恢复以及恢复应进行多长时间。您绝对必须指定的一件事是 &lt;code&gt;restore_command&lt;/code&gt; ，它告诉PostgreSQL如何检索已归档的WAL文件段。像 &lt;code&gt;archive_command&lt;/code&gt; 一样，这是一个shell命令字符串。它可以包含 &lt;code&gt;%f&lt;/code&gt; （用所需的日志文件的名称替换）和 &lt;code&gt;%p&lt;/code&gt; （用将日志文件复制到的路径名）替换。 （路径名称是相对于当前工作目录（即群集的数据目录）的。）如果需要在命令中嵌入实际的 &lt;code&gt;%&lt;/code&gt; 字符，请输入 &lt;code&gt;%%&lt;/code&gt; 。最简单的有用命令是：</target>
        </trans-unit>
        <trans-unit id="6ce0e2cb46720b77226f610a445bda26007f0b40" translate="yes" xml:space="preserve">
          <source>The key word &lt;code&gt;COLUMN&lt;/code&gt; is noise and can be omitted.</source>
          <target state="translated">关键字 &lt;code&gt;COLUMN&lt;/code&gt; 是噪音，可以省略。</target>
        </trans-unit>
        <trans-unit id="5b5ac0f06c70f1fb5409349bf24004b2a55d2f18" translate="yes" xml:space="preserve">
          <source>The key word &lt;code&gt;EXTERNAL&lt;/code&gt; is allowed for SQL conformance, but it is optional since, unlike in SQL, this feature applies to all functions not only external ones.</source>
          <target state="translated">允许使用 &lt;code&gt;EXTERNAL&lt;/code&gt; 关键字来实现SQL一致性，但是它是可选的，因为与SQL不同，此功能不仅适用于外部功能，还适用于所有功能。</target>
        </trans-unit>
        <trans-unit id="7b66b886be54f4dad1fc59336fb968283aedd583" translate="yes" xml:space="preserve">
          <source>The key word &lt;code&gt;EXTERNAL&lt;/code&gt; is allowed for SQL conformance, but it is optional since, unlike in SQL, this feature applies to all procedures not only external ones.</source>
          <target state="translated">允许使用 &lt;code&gt;EXTERNAL&lt;/code&gt; 关键字来实现SQL一致性，但是它是可选的，因为与SQL不同，此功能不仅适用于外部过程，而且还适用于所有过程。</target>
        </trans-unit>
        <trans-unit id="f14ab28890a5b7ef2546dae62a05463965282a2c" translate="yes" xml:space="preserve">
          <source>The key word &lt;code&gt;ILIKE&lt;/code&gt; can be used instead of &lt;code&gt;LIKE&lt;/code&gt; to make the match case-insensitive according to the active locale. This is not in the SQL standard but is a PostgreSQL extension.</source>
          <target state="translated">根据活动的语言环境，可以使用关键字 &lt;code&gt;ILIKE&lt;/code&gt; 代替 &lt;code&gt;LIKE&lt;/code&gt; 来使匹配不区分大小写。这不是SQL标准，而是PostgreSQL扩展。</target>
        </trans-unit>
        <trans-unit id="56bcc837725f3c99bfbefa9f4ad797df653bb446" translate="yes" xml:space="preserve">
          <source>The key word &lt;code&gt;PUBLIC&lt;/code&gt; indicates that the privileges are to be granted to all roles, including those that might be created later. &lt;code&gt;PUBLIC&lt;/code&gt; can be thought of as an implicitly defined group that always includes all roles. Any particular role will have the sum of privileges granted directly to it, privileges granted to any role it is presently a member of, and privileges granted to &lt;code&gt;PUBLIC&lt;/code&gt;.</source>
          <target state="translated">关键字 &lt;code&gt;PUBLIC&lt;/code&gt; 表示将向所有角色授予特权，包括以后可能创建的特权。可以将 &lt;code&gt;PUBLIC&lt;/code&gt; 视为始终包含所有角色的隐式定义的组。任何特定角色都将具有直接授予它的特权，授予当前它所属的任何角色的特权以及授予 &lt;code&gt;PUBLIC&lt;/code&gt; 的特权的总和。</target>
        </trans-unit>
        <trans-unit id="099dc57512200b2d79974967fc17d8da0e67f388" translate="yes" xml:space="preserve">
          <source>The key word &lt;code&gt;ROW&lt;/code&gt; is optional when there is more than one expression in the list.</source>
          <target state="translated">当列表中有多个表达式时，关键字 &lt;code&gt;ROW&lt;/code&gt; 是可选的。</target>
        </trans-unit>
        <trans-unit id="f75dcd3d9f2023dad0df5e4baecf4f11764e4ecf" translate="yes" xml:space="preserve">
          <source>The key words &lt;code&gt;BINARY&lt;/code&gt;, &lt;code&gt;INSENSITIVE&lt;/code&gt;, and &lt;code&gt;SCROLL&lt;/code&gt; can appear in any order.</source>
          <target state="translated">关键字 &lt;code&gt;BINARY&lt;/code&gt; ， &lt;code&gt;INSENSITIVE&lt;/code&gt; 和 &lt;code&gt;SCROLL&lt;/code&gt; 可以按任何顺序出现。</target>
        </trans-unit>
        <trans-unit id="933ba0b83729a47d657b68dbaf9310c7b7c42eff" translate="yes" xml:space="preserve">
          <source>The key words &lt;code&gt;TRUE&lt;/code&gt; and &lt;code&gt;FALSE&lt;/code&gt; are the preferred (SQL-compliant) method for writing Boolean constants in SQL queries. But you can also use the string representations by following the generic string-literal constant syntax described in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS-GENERIC&quot;&gt;Section 4.1.2.7&lt;/a&gt;, for example &lt;code&gt;'yes'::boolean&lt;/code&gt;.</source>
          <target state="translated">关键字 &lt;code&gt;TRUE&lt;/code&gt; 和 &lt;code&gt;FALSE&lt;/code&gt; 是在SQL查询中编写布尔常量的首选（兼容SQL）方法。但是，您也可以按照&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS-GENERIC&quot;&gt;第4.1.2.7节中&lt;/a&gt;描述的通用字符串文字常量语法来使用字符串表示形式，例如 &lt;code&gt;'yes'::boolean&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="301ce5b56290e04645decb19cd60fcc9e64d775e" translate="yes" xml:space="preserve">
          <source>The keytab file is generated by the Kerberos software; see the Kerberos documentation for details. The following example is for MIT-compatible Kerberos 5 implementations:</source>
          <target state="translated">keytab 文件是由 Kerberos 软件生成的,详情请参见 Kerberos 文档。下面的例子是针对与 MIT 兼容的 Kerberos 5 实现的。</target>
        </trans-unit>
        <trans-unit id="77aaa5ebf06bbbd98db8e2f5ba28cce520375eb5" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;ANY&lt;/code&gt;, coupled with &lt;code&gt;num_sync&lt;/code&gt;, specifies a quorum-based synchronous replication and makes transaction commits wait until their WAL records are replicated to &lt;em&gt;at least&lt;/em&gt;&lt;code&gt;num_sync&lt;/code&gt; listed standbys. For example, a setting of &lt;code&gt;ANY 3 (s1, s2, s3, s4)&lt;/code&gt; will cause each commit to proceed as soon as at least any three standbys of &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt;, &lt;code&gt;s3&lt;/code&gt; and &lt;code&gt;s4&lt;/code&gt; reply.</source>
          <target state="translated">关键字 &lt;code&gt;ANY&lt;/code&gt; 与 &lt;code&gt;num_sync&lt;/code&gt; 结合使用，指定了基于仲裁的同步复制，并使事务提交等到其WAL记录复制到&lt;em&gt;至少&lt;/em&gt; &lt;code&gt;num_sync&lt;/code&gt; 列出的备用数据库。例如， &lt;code&gt;ANY 3 (s1, s2, s3, s4)&lt;/code&gt; 都会导致每次提交都至少在 &lt;code&gt;s1&lt;/code&gt; ， &lt;code&gt;s2&lt;/code&gt; ， &lt;code&gt;s3&lt;/code&gt; 和 &lt;code&gt;s4&lt;/code&gt; 的至少三个备用状态回复时继续进行。</target>
        </trans-unit>
        <trans-unit id="f98af4e22fce388807986209bcfe098613dae4c1" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;FIRST&lt;/code&gt;, coupled with &lt;code&gt;num_sync&lt;/code&gt;, specifies a priority-based synchronous replication and makes transaction commits wait until their WAL records are replicated to &lt;code&gt;num_sync&lt;/code&gt; synchronous standbys chosen based on their priorities. For example, a setting of &lt;code&gt;FIRST 3 (s1, s2, s3, s4)&lt;/code&gt; will cause each commit to wait for replies from three higher-priority standbys chosen from standby servers &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt;, &lt;code&gt;s3&lt;/code&gt; and &lt;code&gt;s4&lt;/code&gt;. The standbys whose names appear earlier in the list are given higher priority and will be considered as synchronous. Other standby servers appearing later in this list represent potential synchronous standbys. If any of the current synchronous standbys disconnects for whatever reason, it will be replaced immediately with the next-highest-priority standby. The keyword &lt;code&gt;FIRST&lt;/code&gt; is optional.</source>
          <target state="translated">关键字 &lt;code&gt;FIRST&lt;/code&gt; 与 &lt;code&gt;num_sync&lt;/code&gt; 结合使用，指定了基于优先级的同步复制，并使事务提交等待，直到其WAL记录复制到根据其优先级选择的 &lt;code&gt;num_sync&lt;/code&gt; 同步备用数据库中。例如，设置 &lt;code&gt;FIRST 3 (s1, s2, s3, s4)&lt;/code&gt; 将导致每个提交都等待来自备用服务器 &lt;code&gt;s1&lt;/code&gt; ， &lt;code&gt;s2&lt;/code&gt; ， &lt;code&gt;s3&lt;/code&gt; 和 &lt;code&gt;s4&lt;/code&gt; 的三个优先级较高的备用服务器的答复。。名称在列表中较早出现的备用数据库具有更高的优先级，并将被视为同步数据库。此列表后面出现的其他备用服务器代表潜在的同步备用服务器。如果任何当前同步备用数据库由于某种原因断开连接，它将立即替换为次高优先级备用数据库。关键字 &lt;code&gt;FIRST&lt;/code&gt; 是可选的。</target>
        </trans-unit>
        <trans-unit id="c6753d4b26b83ec9737507aab616ad0a90dffe5e" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;STORED&lt;/code&gt; is required to signify that the column will be computed on write and will be stored on disk.</source>
          <target state="translated">必须使用关键字 &lt;code&gt;STORED&lt;/code&gt; 来表示该列将在写入时进行计算并将存储在磁盘上。</target>
        </trans-unit>
        <trans-unit id="436779e1054adc0e89a0677ecb406409dda7f240" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;STORED&lt;/code&gt; is required to signify that the column will be computed on write. (The computed value will be presented to the foreign-data wrapper for storage and must be returned on reading.)</source>
          <target state="translated">需要关键字 &lt;code&gt;STORED&lt;/code&gt; 表示该列将在写入时进行计算。（计算出的值将呈现给外部数据包装器进行存储，并且必须在读取时返回。）</target>
        </trans-unit>
        <trans-unit id="5edd7a55d1b24539fc9cfa0bcf24706822731dd3" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;STORED&lt;/code&gt; must be specified to choose the stored kind of generated column. See &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for more details.</source>
          <target state="translated">必须指定关键字 &lt;code&gt;STORED&lt;/code&gt; 才能选择所生成列的存储类型。有关更多详细信息，请参见&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e643395261c7f81c30fc2a4e61b7aaf97e975625" translate="yes" xml:space="preserve">
          <source>The label provider associated with this label.</source>
          <target state="translated">与此标签相关联的标签提供者。</target>
        </trans-unit>
        <trans-unit id="468c79531b62d3d36755c25fe6c2c2d1c6c04f9c" translate="yes" xml:space="preserve">
          <source>The label provider determines whether a given label is valid and whether it is permissible to assign that label to a given object. The meaning of a given label is likewise at the discretion of the label provider. PostgreSQL places no restrictions on whether or how a label provider must interpret security labels; it merely provides a mechanism for storing them. In practice, this facility is intended to allow integration with label-based mandatory access control (MAC) systems such as SE-Linux. Such systems make all access control decisions based on object labels, rather than traditional discretionary access control (DAC) concepts such as users and groups.</source>
          <target state="translated">标签提供者决定某个标签是否有效,以及是否允许将该标签分配给某个对象。给定标签的含义同样由标签提供者来决定。PostgreSQL对标签提供者是否必须解释安全标签或如何解释安全标签没有任何限制;它只是提供了一个存储标签的机制。在实践中,这个设施旨在允许与基于标签的强制访问控制(MAC)系统(如SE-Linux)集成。这类系统基于对象标签而不是传统的自由裁量访问控制(DAC)概念(如用户和组)做出所有访问控制决定。</target>
        </trans-unit>
        <trans-unit id="8eaf1d04fc556db25e421838f63ccbd315696008" translate="yes" xml:space="preserve">
          <source>The label provider determines whether a given label is valid and whether it is permissible to assign that label to a given object. The meaning of a given label is likewise at the discretion of the label provider. PostgreSQL places no restrictions on whether or how a label provider must interpret security labels; it merely provides a mechanism for storing them. In practice, this facility is intended to allow integration with label-based mandatory access control (MAC) systems such as SELinux. Such systems make all access control decisions based on object labels, rather than traditional discretionary access control (DAC) concepts such as users and groups.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2fab09475b65e9983ce79215513aca004922a64" translate="yes" xml:space="preserve">
          <source>The lag times reported in the &lt;code&gt;pg_stat_replication&lt;/code&gt; view are measurements of the time taken for recent WAL to be written, flushed and replayed and for the sender to know about it. These times represent the commit delay that was (or would have been) introduced by each synchronous commit level, if the remote server was configured as a synchronous standby. For an asynchronous standby, the &lt;code&gt;replay_lag&lt;/code&gt; column approximates the delay before recent transactions became visible to queries. If the standby server has entirely caught up with the sending server and there is no more WAL activity, the most recently measured lag times will continue to be displayed for a short time and then show NULL.</source>
          <target state="translated">&lt;code&gt;pg_stat_replication&lt;/code&gt; 视图中报告的滞后时间是对最近的WAL被写入，刷新和重放以及发送方知道所花费的时间的度量。如果将远程服务器配置为同步备用服务器，则这些时间表示每个同步提交级别引入的（或将要引入的）提交延迟。对于异步备用数据库， &lt;code&gt;replay_lag&lt;/code&gt; 列近似查询最近的事务变为可见之前的延迟。如果备用服务器已完全跟上发送服务器的速度，并且不再有WAL活动，则最近测量的延迟时间将继续显示一小段时间，然后显示NULL。</target>
        </trans-unit>
        <trans-unit id="eb0c7351bd920c1bdbdffe727ba791d1a927eafe" translate="yes" xml:space="preserve">
          <source>The largest part of shared memory is known as &lt;em&gt;shared buffers&lt;/em&gt; and is used to mirror part of data files, organized into pages. When a page is modified, it is called a dirty page until it is written back to the file system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bee0490b803b85b6819bd67e0eb5d37f8061673f" translate="yes" xml:space="preserve">
          <source>The largest statistics target among the columns being analyzed determines the number of table rows sampled to prepare the statistics. Increasing the target causes a proportional increase in the time and space needed to do &lt;code&gt;ANALYZE&lt;/code&gt;.</source>
          <target state="translated">要分析的列中最大的统计信息目标确定为准备统计信息而采样的表行数。增加目标会导致进行 &lt;code&gt;ANALYZE&lt;/code&gt; 所需的时间和空间成比例地增加。</target>
        </trans-unit>
        <trans-unit id="08ac6817284c2739892a594416144a19a2fc3c3b" translate="yes" xml:space="preserve">
          <source>The last example shows that the checks include whether namespaces are correctly matched.</source>
          <target state="translated">最后一个例子表明,检查内容包括是否正确匹配了命名空间。</target>
        </trans-unit>
        <trans-unit id="b141d1efe06f21d25a717b844dfa4141ae98f099" translate="yes" xml:space="preserve">
          <source>The last five parameters are pass-by-reference outputs:</source>
          <target state="translated">最后五个参数是逐个参考输出。</target>
        </trans-unit>
        <trans-unit id="640860dcca4728ae99db3adc4362cf72e26f4370" translate="yes" xml:space="preserve">
          <source>The last line could also be:</source>
          <target state="translated">最后一行也可以是。</target>
        </trans-unit>
        <trans-unit id="a268591c13ee52793b16cb868a71b9f235920223" translate="yes" xml:space="preserve">
          <source>The last line is useful in verifying that the client is trying to connect to the right place. If there is in fact no server running there, the kernel error message will typically be either &lt;code&gt;Connection refused&lt;/code&gt; or &lt;code&gt;No such file or directory&lt;/code&gt;, as illustrated. (It is important to realize that &lt;code&gt;Connection refused&lt;/code&gt; in this context does &lt;em&gt;not&lt;/em&gt; mean that the server got your connection request and rejected it. That case will produce a different message, as shown in &lt;a href=&quot;client-authentication-problems&quot;&gt;Section 20.15&lt;/a&gt;.) Other error messages such as &lt;code&gt;Connection timed out&lt;/code&gt; might indicate more fundamental problems, like lack of network connectivity.</source>
          <target state="translated">最后一行对于验证客户端是否尝试连接到正确的位置很有用。如果实际上那里没有服务器在运行，则内核错误消息通常将是 &lt;code&gt;Connection refused&lt;/code&gt; 或 &lt;code&gt;No such file or directory&lt;/code&gt; ，如图所示。 （很重要的一点是，在这种情况下 &lt;code&gt;Connection refused&lt;/code&gt; &lt;em&gt;并不&lt;/em&gt;意味着服务器获得了您的连接请求并拒绝了它。这种情况将产生不同的消息，如&lt;a href=&quot;client-authentication-problems&quot;&gt;第20.15节&lt;/a&gt;所示。）其他错误消息（例如 &lt;code&gt;Connection timed out&lt;/code&gt; 可能表示更根本的问题，例如缺乏网络连接。</target>
        </trans-unit>
        <trans-unit id="cca952ade3d373926896de08f3f6cd0f1c245369" translate="yes" xml:space="preserve">
          <source>The last line printed out by &lt;code&gt;psql&lt;/code&gt; is the prompt, and it indicates that &lt;code&gt;psql&lt;/code&gt; is listening to you and that you can type SQL queries into a work space maintained by &lt;code&gt;psql&lt;/code&gt;. Try out these commands:</source>
          <target state="translated">由 &lt;code&gt;psql&lt;/code&gt; 打印的最后一行是提示符，它表明 &lt;code&gt;psql&lt;/code&gt; 正在监听您，并且您可以在 &lt;code&gt;psql&lt;/code&gt; 维护的工作空间中键入SQL查询。试用以下命令：</target>
        </trans-unit>
        <trans-unit id="4a2bf24f5739dd825710ff53126984ef2f6e0852" translate="yes" xml:space="preserve">
          <source>The last modification time of the file as reported by the server at the time of the backup. Unlike the other fields stored in the backup, this field is not used by &lt;a href=&quot;app-pgverifybackup&quot;&gt;pg_verifybackup&lt;/a&gt;. It is included only for informational purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb5a300b26673b4a75043297a6f146dcd49c5439" translate="yes" xml:space="preserve">
          <source>The last sequence value written to disk. If caching is used, this value can be greater than the last value handed out from the sequence. Null if the sequence has not been read from yet. Also, if the current user does not have &lt;code&gt;USAGE&lt;/code&gt; or &lt;code&gt;SELECT&lt;/code&gt; privilege on the sequence, the value is null.</source>
          <target state="translated">写入磁盘的最后一个序列值。如果使用缓存，则该值可以大于从序列中分发的最后一个值。如果尚未从中读取序列，则为Null。另外，如果当前用户对该序列没有 &lt;code&gt;USAGE&lt;/code&gt; 或 &lt;code&gt;SELECT&lt;/code&gt; 特权，则该值为null。</target>
        </trans-unit>
        <trans-unit id="3ddb6dca4d033d643b4947fa1e0c4bfe448712f8" translate="yes" xml:space="preserve">
          <source>The last six input formats shown above are not part of any standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8146be3b6220418f9831589eda3884a4555e4dfa" translate="yes" xml:space="preserve">
          <source>The last two states are seen only when &lt;a href=&quot;runtime-config-replication#GUC-MAX-SLOT-WAL-KEEP-SIZE&quot;&gt;max_slot_wal_keep_size&lt;/a&gt; is non-negative. If &lt;code&gt;restart_lsn&lt;/code&gt; is NULL, this field is null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fe313657b9f725a4a4c3652ad1d9e1c661ac0d8" translate="yes" xml:space="preserve">
          <source>The latter is syntactically valid, but it represents a call of a single-argument aggregate function with two &lt;code&gt;ORDER BY&lt;/code&gt; keys (the second one being rather useless since it's a constant).</source>
          <target state="translated">后者在语法上是有效的，但是它表示使用两个 &lt;code&gt;ORDER BY&lt;/code&gt; 键的单参数聚合函数的调用（第二个键相当恒定，因此非常没用）。</target>
        </trans-unit>
        <trans-unit id="ec920275f2c822a2a5adceef23c754e25dadccba" translate="yes" xml:space="preserve">
          <source>The lax mode facilitates matching of a JSON document structure and path expression if the JSON data does not conform to the expected schema. If an operand does not match the requirements of a particular operation, it can be automatically wrapped as an SQL/JSON array or unwrapped by converting its elements into an SQL/JSON sequence before performing this operation. Besides, comparison operators automatically unwrap their operands in the lax mode, so you can compare SQL/JSON arrays out-of-the-box. An array of size 1 is considered equal to its sole element. Automatic unwrapping is not performed only when:</source>
          <target state="translated">如果JSON数据不符合预期的模式,宽松模式便于匹配JSON文档结构和路径表达式。如果操作数不符合特定操作的要求,可以将其自动封装为SQL/JSON数组,或者在执行该操作前将其元素转换为SQL/JSON序列进行解包。此外,比较运算符在宽松模式下会自动解包其操作数,因此可以对SQL/JSON数组进行开箱即用的比较。一个大小为1的数组被认为等于它的唯一元素。自动解包并非只在以下情况下执行。</target>
        </trans-unit>
        <trans-unit id="c52a670d06775855c2164b78f437c77c8a3136cd" translate="yes" xml:space="preserve">
          <source>The least downtime can be achieved by installing the new server in a different directory and running both the old and the new servers in parallel, on different ports. Then you can use something like:</source>
          <target state="translated">通过将新服务器安装在不同的目录下,并在不同的端口上同时运行新旧服务器,可以达到最少的停机时间。那么你就可以使用这样的方法。</target>
        </trans-unit>
        <trans-unit id="082fd8f2f5ff84b43f58645d6265cd8d6ba42c18" translate="yes" xml:space="preserve">
          <source>The left-hand side is a row constructor, as described in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Section 4.2.13&lt;/a&gt;. The right-hand side is a parenthesized subquery, which must return exactly as many columns as there are expressions in the left-hand row. Furthermore, the subquery cannot return more than one row. (If it returns zero rows, the result is taken to be null.) The left-hand side is evaluated and compared row-wise to the single subquery result row.</source>
          <target state="translated">左侧是行构造器，如&lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;第4.2.13节中&lt;/a&gt;所述。右侧是带括号的子查询，该子查询必须返回与左侧行中的表达式一样多的列。此外，子查询不能返回多于一行。 （如果返回零行，则结果为空。）将评估左侧并将其按行与单个子查询结果行进行比较。</target>
        </trans-unit>
        <trans-unit id="f44070270517992cebfd8a7909698b4367aa0cae" translate="yes" xml:space="preserve">
          <source>The left-hand side of this form of &lt;code&gt;ALL&lt;/code&gt; is a row constructor, as described in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Section 4.2.13&lt;/a&gt;. The right-hand side is a parenthesized subquery, which must return exactly as many columns as there are expressions in the left-hand row. The left-hand expressions are evaluated and compared row-wise to each row of the subquery result, using the given &lt;code&gt;operator&lt;/code&gt;. The result of &lt;code&gt;ALL&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if the comparison returns true for all subquery rows (including the case where the subquery returns no rows). The result is &amp;ldquo;false&amp;rdquo; if the comparison returns false for any subquery row. The result is NULL if no comparison with a subquery row returns false, and at least one comparison returns NULL.</source>
          <target state="translated">这种形式的 &lt;code&gt;ALL&lt;/code&gt; 的左侧是行构造函数，如&lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;第4.2.13节&lt;/a&gt;所述。右侧是带括号的子查询，该子查询必须返回的行数与左侧行中的表达式一样多。使用给定的 &lt;code&gt;operator&lt;/code&gt; ，对左侧表达式进行求值并将其与子查询结果的每一行进行逐行比较。如果比较对所有子查询行都返回true（包括子查询不返回任何行的情况），则 &lt;code&gt;ALL&lt;/code&gt; 的结果为&amp;ldquo; true&amp;rdquo;。如果比较对于任何子查询行返回false，则结果为&amp;ldquo; false&amp;rdquo;。如果没有与子查询行的比较返回false，则结果为NULL，并且至少一个比较返回NULL。</target>
        </trans-unit>
        <trans-unit id="3a495b6469d287a27574f63256e96477ed641f86" translate="yes" xml:space="preserve">
          <source>The left-hand side of this form of &lt;code&gt;ANY&lt;/code&gt; is a row constructor, as described in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Section 4.2.13&lt;/a&gt;. The right-hand side is a parenthesized subquery, which must return exactly as many columns as there are expressions in the left-hand row. The left-hand expressions are evaluated and compared row-wise to each row of the subquery result, using the given &lt;code&gt;operator&lt;/code&gt;. The result of &lt;code&gt;ANY&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if the comparison returns true for any subquery row. The result is &amp;ldquo;false&amp;rdquo; if the comparison returns false for every subquery row (including the case where the subquery returns no rows). The result is NULL if no comparison with a subquery row returns true, and at least one comparison returns NULL.</source>
          <target state="translated">这种形式的 &lt;code&gt;ANY&lt;/code&gt; 的左侧是行构造器，如&lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;第4.2.13节中&lt;/a&gt;所述。右侧是带括号的子查询，该子查询必须返回与左侧行中的表达式一样多的列。使用给定的 &lt;code&gt;operator&lt;/code&gt; ，对左侧表达式进行求值并将其与子查询结果的每一行进行逐行比较。如果比较对任何子查询行返回true，则 &lt;code&gt;ANY&lt;/code&gt; 的结果为&amp;ldquo; true&amp;rdquo;。如果比较为每个子查询行返回false（包括子查询不返回任何行的情况），则结果为&amp;ldquo; false&amp;rdquo;。如果没有与子查询行的比较返回真，则结果为NULL，并且至少一个比较返回NULL。</target>
        </trans-unit>
        <trans-unit id="afdaf261917f03fc0c447e59e3d5a8be456d89c2" translate="yes" xml:space="preserve">
          <source>The left-hand side of this form of &lt;code&gt;IN&lt;/code&gt; is a row constructor, as described in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Section 4.2.13&lt;/a&gt;. The right-hand side is a parenthesized subquery, which must return exactly as many columns as there are expressions in the left-hand row. The left-hand expressions are evaluated and compared row-wise to each row of the subquery result. The result of &lt;code&gt;IN&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if any equal subquery row is found. The result is &amp;ldquo;false&amp;rdquo; if no equal row is found (including the case where the subquery returns no rows).</source>
          <target state="translated">这种形式的 &lt;code&gt;IN&lt;/code&gt; 的左侧是行构造函数，如&lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;第4.2.13节&lt;/a&gt;所述。右侧是带括号的子查询，该子查询必须返回与左侧行中的表达式一样多的列。评估左侧表达式并将其逐行与子查询结果的每一行进行比较。如果找到相等的子查询行，则 &lt;code&gt;IN&lt;/code&gt; 的结果为&amp;ldquo; true&amp;rdquo;。如果找不到相等的行（包括子查询不返回任何行的情况），则结果为&amp;ldquo; false&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="a1d433de59d411f27b86b3382eba3a1fea3e9e5d" translate="yes" xml:space="preserve">
          <source>The left-hand side of this form of &lt;code&gt;NOT IN&lt;/code&gt; is a row constructor, as described in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Section 4.2.13&lt;/a&gt;. The right-hand side is a parenthesized subquery, which must return exactly as many columns as there are expressions in the left-hand row. The left-hand expressions are evaluated and compared row-wise to each row of the subquery result. The result of &lt;code&gt;NOT IN&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if only unequal subquery rows are found (including the case where the subquery returns no rows). The result is &amp;ldquo;false&amp;rdquo; if any equal row is found.</source>
          <target state="translated">这种形式的 &lt;code&gt;NOT IN&lt;/code&gt; 的左侧是行构造函数，如&lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;第4.2.13节&lt;/a&gt;所述。右侧是带括号的子查询，该子查询必须返回与左侧行中的表达式一样多的列。评估左侧表达式并将其逐行与子查询结果的每一行进行比较。如果仅发现不相等的子查询行（包括子查询不返回任何行的情况），则 &lt;code&gt;NOT IN&lt;/code&gt; 的结果为&amp;ldquo; true&amp;rdquo;。如果找到相等的行，则结果为&amp;ldquo; false&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="4585d75ed76ee1f40b5daa39dfcad2d39fb7784d" translate="yes" xml:space="preserve">
          <source>The left-of/right-of/adjacent operators always return false when an empty range is involved; that is, an empty range is not considered to be either before or after any other range.</source>
          <target state="translated">当涉及到空范围时,左/右/相邻运算符总是返回false;也就是说,空范围不会被认为是在任何其他范围之前或之后。</target>
        </trans-unit>
        <trans-unit id="2f5d1e6e1b59ebb3b7a2ceefdc5f69123a880bd7" translate="yes" xml:space="preserve">
          <source>The length of a &lt;code&gt;tsvector&lt;/code&gt; (lexemes + positions) must be less than 1 megabyte</source>
          <target state="translated">&lt;code&gt;tsvector&lt;/code&gt; 的长度（词素+位置）必须小于1兆字节</target>
        </trans-unit>
        <trans-unit id="fb55102e4d77862d8595a399532f60d05305a61a" translate="yes" xml:space="preserve">
          <source>The length of each lexeme must be less than 2 kilobytes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72cf9ee51b093da890b7dcc27caaf482e19db7ab" translate="yes" xml:space="preserve">
          <source>The length of each lexeme must be less than 2K bytes</source>
          <target state="translated">每个词素的长度必须小于2K字节。</target>
        </trans-unit>
        <trans-unit id="07e3cb5f7b40e6d63b3d5d01d67980671a6f7bf1" translate="yes" xml:space="preserve">
          <source>The library file name is typically given as just a bare file name, which is sought in the server's library search path (set by &lt;a href=&quot;runtime-config-client#GUC-DYNAMIC-LIBRARY-PATH&quot;&gt;dynamic_library_path&lt;/a&gt;). Alternatively it can be given as a full path name. In either case the platform's standard shared library file name extension may be omitted. See &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-c.html#XFUNC-C-DYNLOAD&quot;&gt;Section 37.10.1&lt;/a&gt; for more information on this topic.</source>
          <target state="translated">库文件名通常仅作为裸文件名提供，在服务器的库搜索路径（由&lt;a href=&quot;runtime-config-client#GUC-DYNAMIC-LIBRARY-PATH&quot;&gt;dynamic_library_path&lt;/a&gt;设置）中查找。或者，可以将其作为完整路径名给出。无论哪种情况，都可以省略平台的标准共享库文件扩展名。有关此主题的更多信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-c.html#XFUNC-C-DYNLOAD&quot;&gt;37.10.1节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ca07c214a1fa57e76fa5efc5dc421655af5b85fc" translate="yes" xml:space="preserve">
          <source>The library file name is typically given as just a bare file name, which is sought in the server's library search path (set by &lt;a href=&quot;runtime-config-client#GUC-DYNAMIC-LIBRARY-PATH&quot;&gt;dynamic_library_path&lt;/a&gt;). Alternatively it can be given as a full path name. In either case the platform's standard shared library file name extension may be omitted. See &lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc-c.html#XFUNC-C-DYNLOAD&quot;&gt;Section 37.10.1&lt;/a&gt; for more information on this topic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb9d5172bb2076ce6b62f3e5058e20954eddcb55" translate="yes" xml:space="preserve">
          <source>The libxml2 library does seem to always return node-sets to PostgreSQL with their members in the same relative order they had in the input document. Its documentation does not commit to this behavior, and an XPath 1.0 expression cannot control it.</source>
          <target state="translated">libxml2库似乎总是以输入文档中成员的相对顺序返回节点集到PostgreSQL。它的文档并没有承诺这种行为,而且XPath 1.0表达式也不能控制它。</target>
        </trans-unit>
        <trans-unit id="e92855a9b20ea0f884a230e63ef7768d88fd5352" translate="yes" xml:space="preserve">
          <source>The limitations of pg_restore are detailed below.</source>
          <target state="translated">pg_restore的局限性详细如下。</target>
        </trans-unit>
        <trans-unit id="87e598717783e82b1e191a7f90cf401c4ee0b779" translate="yes" xml:space="preserve">
          <source>The line number inside the current statement, starting from &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">当前语句中的行号，从 &lt;code&gt;1&lt;/code&gt; 开始。</target>
        </trans-unit>
        <trans-unit id="d10565a24d6154d743d122e032098869756ae365" translate="yes" xml:space="preserve">
          <source>The list below shows the available lock modes and the contexts in which they are used automatically by PostgreSQL. You can also acquire any of these locks explicitly with the command &lt;a href=&quot;sql-lock&quot;&gt;LOCK&lt;/a&gt;. Remember that all of these lock modes are table-level locks, even if the name contains the word &amp;ldquo;row&amp;rdquo;; the names of the lock modes are historical. To some extent the names reflect the typical usage of each lock mode &amp;mdash; but the semantics are all the same. The only real difference between one lock mode and another is the set of lock modes with which each conflicts (see &lt;a href=&quot;explicit-locking#TABLE-LOCK-COMPATIBILITY&quot;&gt;Table 13.2&lt;/a&gt;). Two transactions cannot hold locks of conflicting modes on the same table at the same time. (However, a transaction never conflicts with itself. For example, it might acquire &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock and later acquire &lt;code&gt;ACCESS SHARE&lt;/code&gt; lock on the same table.) Non-conflicting lock modes can be held concurrently by many transactions. Notice in particular that some lock modes are self-conflicting (for example, an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock cannot be held by more than one transaction at a time) while others are not self-conflicting (for example, an &lt;code&gt;ACCESS SHARE&lt;/code&gt; lock can be held by multiple transactions).</source>
          <target state="translated">下面的列表显示了可用的锁定模式以及PostgreSQL自动使用它们的上下文。您还可以使用&lt;a href=&quot;sql-lock&quot;&gt;LOCK&lt;/a&gt;命令显式获取这些锁中的任何一个。请记住，所有这些锁定模式都是表级锁定，即使名称中包含单词&amp;ldquo; row&amp;rdquo;；锁定模式的名称是历史性的。名称在某种程度上反映了每种锁定模式的典型用法-但语义都相同。一个锁定模式与另一个锁定模式之间的唯一真正区别是，每个锁定模式相互冲突（请&lt;a href=&quot;explicit-locking#TABLE-LOCK-COMPATIBILITY&quot;&gt;参见表13.2&lt;/a&gt;）。两个事务不能同时在同一张表上持有冲突模式的锁。 （但是，交易永远不会与自身发生冲突。例如，它可能获得 &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; 锁，然后在同一表上获取 &lt;code&gt;ACCESS SHARE&lt;/code&gt; 锁。）许多事务可以同时保持无冲突的锁模式。特别要注意的是，某些锁定模式是自冲突的（例如，一次不能由一个以上的事务持有 &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; 锁定），而另一些则不是自冲突的（例如，可以由 &lt;code&gt;ACCESS SHARE&lt;/code&gt; 锁定来保持）。多次交易）。</target>
        </trans-unit>
        <trans-unit id="4e69c1b0ac656b6b15e1946ebe2102bdb20487dd" translate="yes" xml:space="preserve">
          <source>The list of built-in functions is in &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;Chapter 9&lt;/a&gt;. Other functions can be added by the user.</source>
          <target state="translated">内置函数的列表在&lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;第9章中&lt;/a&gt;。用户可以添加其他功能。</target>
        </trans-unit>
        <trans-unit id="98078b1844b2f5121863d76d0e6ccd8659c9a105" translate="yes" xml:space="preserve">
          <source>The list of built-in functions is in &lt;a href=&quot;https://www.postgresql.org/docs/13/functions.html&quot;&gt;Chapter 9&lt;/a&gt;. Other functions can be added by the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="034ee84c98b899e3f08ab6a22f176f2b0b9c945d" translate="yes" xml:space="preserve">
          <source>The list of output expressions after &lt;code&gt;SELECT&lt;/code&gt; can be empty, producing a zero-column result table. This is not valid syntax according to the SQL standard. PostgreSQL allows it to be consistent with allowing zero-column tables. However, an empty list is not allowed when &lt;code&gt;DISTINCT&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; 之后的输出表达式列表可以为空，从而生成零列结果表。根据SQL标准，这是无效的语法。PostgreSQL允许它与允许零列表保持一致。但是，使用 &lt;code&gt;DISTINCT&lt;/code&gt; 时不允许有空列表。</target>
        </trans-unit>
        <trans-unit id="8494c9c3de42f371358e2a2e5b1c91631cba7c4b" translate="yes" xml:space="preserve">
          <source>The listing file consists of a header and one line for each item, e.g.:</source>
          <target state="translated">清单文件包括一个标题和每项的一行,例如:</target>
        </trans-unit>
        <trans-unit id="c073ed3743a7cc8517210053a4e46a167f30e3ab" translate="yes" xml:space="preserve">
          <source>The literal &lt;code&gt;1.2&lt;/code&gt; is of type &lt;code&gt;numeric&lt;/code&gt;, and the &lt;code&gt;integer&lt;/code&gt; value &lt;code&gt;1&lt;/code&gt; can be cast implicitly to &lt;code&gt;numeric&lt;/code&gt;, so that type is used.</source>
          <target state="translated">文字 &lt;code&gt;1.2&lt;/code&gt; 的类型为 &lt;code&gt;numeric&lt;/code&gt; ，并且 &lt;code&gt;integer&lt;/code&gt; 数值 &lt;code&gt;1&lt;/code&gt; 可以隐式转换为 &lt;code&gt;numeric&lt;/code&gt; ，因此使用该类型。</target>
        </trans-unit>
        <trans-unit id="81389809d8e329e135cb6738d28db71cfa07fe84" translate="yes" xml:space="preserve">
          <source>The local shell command to execute to archive a completed WAL file segment. Any &lt;code&gt;%p&lt;/code&gt; in the string is replaced by the path name of the file to archive, and any &lt;code&gt;%f&lt;/code&gt; is replaced by only the file name. (The path name is relative to the working directory of the server, i.e., the cluster's data directory.) Use &lt;code&gt;%%&lt;/code&gt; to embed an actual &lt;code&gt;%&lt;/code&gt; character in the command. It is important for the command to return a zero exit status only if it succeeds. For more information see &lt;a href=&quot;continuous-archiving#BACKUP-ARCHIVING-WAL&quot;&gt;Section 25.3.1&lt;/a&gt;.</source>
          <target state="translated">执行本地shell命令以归档完整的WAL文件段。字符串中的任何 &lt;code&gt;%p&lt;/code&gt; 都将替换为要归档的文件的路径名，而任何 &lt;code&gt;%f&lt;/code&gt; 都将仅替换为文件名。 （路径名相对于服务器的工作目录，即集群的数据目录。）使用 &lt;code&gt;%%&lt;/code&gt; 在命令中嵌入实际的 &lt;code&gt;%&lt;/code&gt; 字符。重要的是，只有成功执行命令，命令才返回零退出状态。有关更多信息，请参见&lt;a href=&quot;continuous-archiving#BACKUP-ARCHIVING-WAL&quot;&gt;第25.3.1节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0c6814fd70a4837bf3123c78d06664813ae5c2c3" translate="yes" xml:space="preserve">
          <source>The local shell command to execute to retrieve an archived segment of the WAL file series. This parameter is required for archive recovery, but optional for streaming replication. Any &lt;code&gt;%f&lt;/code&gt; in the string is replaced by the name of the file to retrieve from the archive, and any &lt;code&gt;%p&lt;/code&gt; is replaced by the copy destination path name on the server. (The path name is relative to the current working directory, i.e., the cluster's data directory.) Any &lt;code&gt;%r&lt;/code&gt; is replaced by the name of the file containing the last valid restart point. That is the earliest file that must be kept to allow a restore to be restartable, so this information can be used to truncate the archive to just the minimum required to support restarting from the current restore. &lt;code&gt;%r&lt;/code&gt; is typically only used by warm-standby configurations (see &lt;a href=&quot;warm-standby&quot;&gt;Section 26.2&lt;/a&gt;). Write &lt;code&gt;%%&lt;/code&gt; to embed an actual &lt;code&gt;%&lt;/code&gt; character.</source>
          <target state="translated">执行以检索WAL文件系列的已归档段的本地shell命令。此参数对于存档恢复是必需的，而对于流复制则是可选的。字符串中的任何 &lt;code&gt;%f&lt;/code&gt; 都将替换为要从存档中检索的文件名，而任何 &lt;code&gt;%p&lt;/code&gt; 都将被服务器上的复制目标路径名替换。 （路径名称是相对于当前工作目录（即群集的数据目录）的。）任何 &lt;code&gt;%r&lt;/code&gt; 都将替换为包含最后一个有效重启点的文件的名称。那是必须保留的最早的文件，以使还原可重新启动，因此该信息可用于将归档文件截断为仅支持从当前还原重新启动所需的最小值。 &lt;code&gt;%r&lt;/code&gt; 通常仅用于热备份配置（请参见&lt;a href=&quot;warm-standby&quot;&gt;第26.2节&lt;/a&gt;）。写 &lt;code&gt;%%&lt;/code&gt; 嵌入实际的 &lt;code&gt;%&lt;/code&gt; 字符。</target>
        </trans-unit>
        <trans-unit id="1eefb4d9f04f196c0b255cf3b0eec2ac11926c27" translate="yes" xml:space="preserve">
          <source>The locale settings influence the following SQL features:</source>
          <target state="translated">本地化设置会影响以下SQL功能。</target>
        </trans-unit>
        <trans-unit id="7a32d4357c6c565a2645be6e8f5dcd4ff20db468" translate="yes" xml:space="preserve">
          <source>The location must be an existing, empty directory that is owned by the PostgreSQL operating system user. All objects subsequently created within the tablespace will be stored in files underneath this directory. The location must not be on removable or transient storage, as the cluster might fail to function if the tablespace is missing or lost.</source>
          <target state="translated">该位置必须是PostgreSQL操作系统用户拥有的现有空目录。随后在表空间内创建的所有对象都将存储在该目录下的文件中。该位置必须不在可移动或瞬时存储上,因为如果表空间丢失或失去,集群可能无法运行。</target>
        </trans-unit>
        <trans-unit id="b667dea533a6876f6f89e862e7e520ec6a41f7d3" translate="yes" xml:space="preserve">
          <source>The location of the history file can be set explicitly via the &lt;code&gt;HISTFILE&lt;/code&gt; psql variable or the &lt;code&gt;PSQL_HISTORY&lt;/code&gt; environment variable.</source>
          <target state="translated">可以通过 &lt;code&gt;HISTFILE&lt;/code&gt; psql变量或 &lt;code&gt;PSQL_HISTORY&lt;/code&gt; 环境变量显式设置历史文件的位置。</target>
        </trans-unit>
        <trans-unit id="b9e8edabe8e574f621a1a9a4ab6a0372f27514c2" translate="yes" xml:space="preserve">
          <source>The lock mode specifies which locks this lock conflicts with. Lock modes are described in &lt;a href=&quot;explicit-locking&quot;&gt;Section 13.3&lt;/a&gt;.</source>
          <target state="translated">锁定模式指定与该锁定冲突的锁定。锁定模式在&lt;a href=&quot;explicit-locking&quot;&gt;13.3节&lt;/a&gt;中介绍。</target>
        </trans-unit>
        <trans-unit id="11e9f2a01b63d9d65afbfe49635022cefcf4e76a" translate="yes" xml:space="preserve">
          <source>The locking clause has the general form</source>
          <target state="translated">锁定条款的一般形式为</target>
        </trans-unit>
        <trans-unit id="91a41283b7fcf940c9ed38d5616364c7bd0504f5" translate="yes" xml:space="preserve">
          <source>The locking clauses cannot be used in contexts where returned rows cannot be clearly identified with individual table rows; for example they cannot be used with aggregation.</source>
          <target state="translated">锁定子句不能用于返回的记录不能与单个表行清晰识别的情况下;例如,它们不能用于聚合。</target>
        </trans-unit>
        <trans-unit id="5be2e9c7a10ee3339b74248910b8189ec3602ecb" translate="yes" xml:space="preserve">
          <source>The logging collector is designed to never lose messages. This means that in case of extremely high load, server processes could be blocked while trying to send additional log messages when the collector has fallen behind. In contrast, syslog prefers to drop messages if it cannot write them, which means it may fail to log some messages in such cases but it will not block the rest of the system.</source>
          <target state="translated">日志收集器被设计为永不丢失消息。这意味着在极高负载的情况下,当收集器落后时,服务器进程可能会在试图发送额外的日志消息时被阻塞。相比之下,syslog在无法写入消息的情况下更倾向于丢弃消息,这意味着在这种情况下,它可能会无法记录一些消息,但它不会阻塞系统的其他部分。</target>
        </trans-unit>
        <trans-unit id="e54879093a2f0566d1aa83e68c13d2dd946cc6fd" translate="yes" xml:space="preserve">
          <source>The logical replication apply process currently only fires row triggers, not statement triggers. The initial table synchronization, however, is implemented like a &lt;code&gt;COPY&lt;/code&gt; command and thus fires both row and statement triggers for &lt;code&gt;INSERT&lt;/code&gt;.</source>
          <target state="translated">逻辑复制应用过程当前仅触发行触发器，而不触发语句触发器。但是，初始表同步的实现类似于 &lt;code&gt;COPY&lt;/code&gt; 命令，因此会为 &lt;code&gt;INSERT&lt;/code&gt; 触发行和语句触发器。</target>
        </trans-unit>
        <trans-unit id="497c1b112de3cb7224f97eec3f477dda0c464f33" translate="yes" xml:space="preserve">
          <source>The lower bound of a range can be omitted, meaning that all points less than the upper bound are included in the range. Likewise, if the upper bound of the range is omitted, then all points greater than the lower bound are included in the range. If both lower and upper bounds are omitted, all values of the element type are considered to be in the range.</source>
          <target state="translated">范围的下限可以省略,意味着所有小于上限的点都包含在范围内。同样,如果省略了范围的上界,那么所有大于下界的点都包含在范围内。如果下界和上界都被省略,则元素类型的所有值都被认为在范围内。</target>
        </trans-unit>
        <trans-unit id="57c98e1829ac48ed92032df563adc8eac7513b47" translate="yes" xml:space="preserve">
          <source>The lower bound of a range can be omitted, meaning that all values less than the upper bound are included in the range, e.g., &lt;code&gt;(,3]&lt;/code&gt;. Likewise, if the upper bound of the range is omitted, then all values greater than the lower bound are included in the range. If both lower and upper bounds are omitted, all values of the element type are considered to be in the range. Specifying a missing bound as inclusive is automatically converted to exclusive, e.g., &lt;code&gt;[,]&lt;/code&gt; is converted to &lt;code&gt;(,)&lt;/code&gt;. You can think of these missing values as +/-infinity, but they are special range type values and are considered to be beyond any range element type's +/-infinity values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2bb8fcfd48d2a42926444acc296752b10019e69" translate="yes" xml:space="preserve">
          <source>The machine used is an Intel Mobile Core i3.</source>
          <target state="translated">使用的机器是英特尔移动酷睿i3。</target>
        </trans-unit>
        <trans-unit id="a9f59ce368a2e8f66b6b7f102badc5b6a6bb9471" translate="yes" xml:space="preserve">
          <source>The magic that makes the two loosely coupled servers work together is simply a &lt;code&gt;restore_command&lt;/code&gt; used on the standby that, when asked for the next WAL file, waits for it to become available from the primary. Normal recovery processing would request a file from the WAL archive, reporting failure if the file was unavailable. For standby processing it is normal for the next WAL file to be unavailable, so the standby must wait for it to appear. For files ending in &lt;code&gt;.history&lt;/code&gt; there is no need to wait, and a non-zero return code must be returned. A waiting &lt;code&gt;restore_command&lt;/code&gt; can be written as a custom script that loops after polling for the existence of the next WAL file. There must also be some way to trigger failover, which should interrupt the &lt;code&gt;restore_command&lt;/code&gt;, break the loop and return a file-not-found error to the standby server. This ends recovery and the standby will then come up as a normal server.</source>
          <target state="translated">使两个松散耦合的服务器协同工作的魔力仅仅是在备用数据库上使用的 &lt;code&gt;restore_command&lt;/code&gt; ，当要求下一个WAL文件时，它等待主数据库中的该文件变为可用。正常的恢复处理将向WAL存档请求一个文件，如果该文件不可用，则会报告失败。对于备用数据库处理，正常情况是下一个WAL文件不可用，因此备用数据库必须等待它出现。对于以 &lt;code&gt;.history&lt;/code&gt; 结尾的文件，无需等待，并且必须返回非零的返回码。可以将等待的 &lt;code&gt;restore_command&lt;/code&gt; 编写为自定义脚本，该脚本将在轮询下一个WAL文件的存在之后循环执行。还必须有某种方式来触发故障转移，这将中断 &lt;code&gt;restore_command&lt;/code&gt; ，中断循环并向备用服务器返回一个文件未找到的错误。这样就结束了恢复，然后备用数据库将作为普通服务器启动。</target>
        </trans-unit>
        <trans-unit id="ce18091b48e231b7d70d5b7f47f40d4962ad395e" translate="yes" xml:space="preserve">
          <source>The main advantage of using the MVCC model of concurrency control rather than locking is that in MVCC locks acquired for querying (reading) data do not conflict with locks acquired for writing data, and so reading never blocks writing and writing never blocks reading. PostgreSQL maintains this guarantee even when providing the strictest level of transaction isolation through the use of an innovative &lt;em&gt;Serializable Snapshot Isolation&lt;/em&gt; (SSI) level.</source>
          <target state="translated">使用并发控制的MVCC模型而不是锁定的主要优点是，在MVCC中，为查询（读取）数据而获取的锁与为写入数据而获取的锁不冲突，因此读取永远不会阻止写入，而写入永远不会阻止读取。即使通过使用创新的可&lt;em&gt;序列化快照隔离&lt;/em&gt;（SSI）级别提供最严格的事务隔离级别，PostgreSQL仍保持这种保证。</target>
        </trans-unit>
        <trans-unit id="44c8536b44aa283079c384b9a03db01c74d90dd9" translate="yes" xml:space="preserve">
          <source>The main disadvantage of this approach is that searches must scan the list of pending entries in addition to searching the regular index, and so a large list of pending entries will slow searches significantly. Another disadvantage is that, while most updates are fast, an update that causes the pending list to become &amp;ldquo;too large&amp;rdquo; will incur an immediate cleanup cycle and thus be much slower than other updates. Proper use of autovacuum can minimize both of these problems.</source>
          <target state="translated">这种方法的主要缺点是，搜索除了搜索常规索引外，还必须扫描未决条目列表，因此，大量未决条目列表将大大降低搜索速度。另一个缺点是，尽管大多数更新速度很快，但导致挂起的列表变得&amp;ldquo;太大&amp;rdquo;的更新将导致立即清除周期，因此比其他更新要慢得多。正确使用自动真空可以将这两个问题最小化。</target>
        </trans-unit>
        <trans-unit id="4ddd5b9589c157b509c992d47b1a2271d0f14677" translate="yes" xml:space="preserve">
          <source>The main limitation of the single-parameter form of &lt;code&gt;crosstab&lt;/code&gt; is that it treats all values in a group alike, inserting each value into the first available column. If you want the value columns to correspond to specific categories of data, and some groups might not have data for some of the categories, that doesn't work well. The two-parameter form of &lt;code&gt;crosstab&lt;/code&gt; handles this case by providing an explicit list of the categories corresponding to the output columns.</source>
          <target state="translated">&lt;code&gt;crosstab&lt;/code&gt; 的单参数形式的主要局限性在于，它会将组中的所有值都一样对待，并将每个值插入到第一个可用列中。如果您希望值列对应于特定的数据类别，并且某些组可能没有某些类别的数据，则效果不佳。 &lt;code&gt;crosstab&lt;/code&gt; 的两参数形式通过提供与输出列相对应的类别的显式列表来处理这种情况。</target>
        </trans-unit>
        <trans-unit id="c0c0e4e09c0e4b312acc4efbfbf35b08e17ec465" translate="yes" xml:space="preserve">
          <source>The main purpose of this option is to allow taking a base backup when the server has no free replication slots. Using a replication slot is almost always preferred, because it prevents needed WAL from being removed by the server during the backup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="778d9031e427ea1e84edd5ec78787ba6c076cbf5" translate="yes" xml:space="preserve">
          <source>The main purpose of this option is to allow taking a base backup when the server is out of free replication slots. Using replication slots is almost always preferred, because it prevents needed WAL from being removed by the server during the backup.</source>
          <target state="translated">此选项的主要目的是允许在服务器没有可用复制槽时进行基础备份。使用复制槽几乎总是首选,因为它可以防止所需的WAL在备份期间被服务器删除。</target>
        </trans-unit>
        <trans-unit id="29caa328c42873be4b6687bd164a1f6cd134599f" translate="yes" xml:space="preserve">
          <source>The main reason for providing the option to specify multiple changes in a single &lt;code&gt;ALTER TABLE&lt;/code&gt; is that multiple table scans or rewrites can thereby be combined into a single pass over the table.</source>
          <target state="translated">提供在单个 &lt;code&gt;ALTER TABLE&lt;/code&gt; 中指定多个更改的选项的主要原因是，因此可以将多个表扫描或重写合并为对表的单次传递。</target>
        </trans-unit>
        <trans-unit id="cb4b3004c02ae1c44498a4d45ad098f017583f6e" translate="yes" xml:space="preserve">
          <source>The main reason not to use &lt;code&gt;FOR UPDATE&lt;/code&gt; with &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; is if you need the cursor to be scrollable, or to be insensitive to the subsequent updates (that is, continue to show the old data). If this is a requirement, pay close heed to the caveats shown above.</source>
          <target state="translated">不将 &lt;code&gt;FOR UPDATE&lt;/code&gt; 与 &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; 一起使用的主要原因是，如果您需要游标可滚动或对后续更新不敏感（即继续显示旧数据）。如果这是必需的，请密切注意上面显示的警告。</target>
        </trans-unit>
        <trans-unit id="4a8b7d5e4956ce1f0f4b5a2c51be8faff6d42ee8" translate="yes" xml:space="preserve">
          <source>The majority of the information defining an operator family is not in its &lt;code&gt;pg_opfamily&lt;/code&gt; row, but in the associated rows in &lt;a href=&quot;catalog-pg-amop&quot;&gt;&lt;code&gt;pg_amop&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;catalog-pg-amproc&quot;&gt;&lt;code&gt;pg_amproc&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;catalog-pg-opclass&quot;&gt;&lt;code&gt;pg_opclass&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">定义运算符族的大多数信息都不在其 &lt;code&gt;pg_opfamily&lt;/code&gt; 行中，而是在&lt;a href=&quot;catalog-pg-amop&quot;&gt; &lt;code&gt;pg_amop&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;catalog-pg-amproc&quot;&gt; &lt;code&gt;pg_amproc&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;catalog-pg-opclass&quot;&gt; &lt;code&gt;pg_opclass&lt;/code&gt; &lt;/a&gt;中的关联行中。</target>
        </trans-unit>
        <trans-unit id="84e832e692fdd3f5ebc26e5d5addbf853c3e6115" translate="yes" xml:space="preserve">
          <source>The mandatory &lt;code&gt;COLUMNS&lt;/code&gt; clause specifies the list of columns in the output table. Each entry describes a single column. See the syntax summary above for the format. The column name and type are required; the path, default and nullability clauses are optional.</source>
          <target state="translated">强制的 &lt;code&gt;COLUMNS&lt;/code&gt; 子句指定输出表中的列列表。每个条目描述一栏。有关格式，请参见上面的语法摘要。列名和类型是必需的；path，default和nullability子句是可选的。</target>
        </trans-unit>
        <trans-unit id="1ed034d07246f2d9a932c645c69a5fd7f25b6f13" translate="yes" xml:space="preserve">
          <source>The map is conservative in the sense that we make sure that whenever a bit is set, we know the condition is true, but if a bit is not set, it might or might not be true. Visibility map bits are only set by vacuum, but are cleared by any data-modifying operations on a page.</source>
          <target state="translated">该映射是保守的,因为我们确保每当一个位被设置时,我们都知道条件是真的,但如果一个位没有被设置,它可能会或不可能是真的。可见度图位只被真空设置,但会被页面上任何数据修改操作清除。</target>
        </trans-unit>
        <trans-unit id="08696b64b531889519840be43314b0f033492f9a" translate="yes" xml:space="preserve">
          <source>The match distance in a &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; (FOLLOWED BY) &lt;code&gt;tsquery&lt;/code&gt; operator cannot be more than 16,384</source>
          <target state="translated">&lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; （FOLLOWED BY） &lt;code&gt;tsquery&lt;/code&gt; 运算符中的匹配距离不能超过16,384</target>
        </trans-unit>
        <trans-unit id="0adc4fae7a170393939bebd8f752ad648c1e97c9" translate="yes" xml:space="preserve">
          <source>The matching code in the C module could then follow this skeleton:</source>
          <target state="translated">C模块中的匹配代码就可以按照这个骨架进行。</target>
        </trans-unit>
        <trans-unit id="628cd5529e4eb158401ec35941dd337c440c275a" translate="yes" xml:space="preserve">
          <source>The maximum allowed precision when explicitly specified in the type declaration is 1000; &lt;code&gt;NUMERIC&lt;/code&gt; without a specified precision is subject to the limits described in &lt;a href=&quot;datatype-numeric#DATATYPE-NUMERIC-TABLE&quot;&gt;Table 8.2&lt;/a&gt;.</source>
          <target state="translated">在类型声明中明确指定的最大允许精度为1000；没有规定精度的 &lt;code&gt;NUMERIC&lt;/code&gt; 受&lt;a href=&quot;datatype-numeric#DATATYPE-NUMERIC-TABLE&quot;&gt;表8.2中&lt;/a&gt;所述的限制。</target>
        </trans-unit>
        <trans-unit id="f276734cd29218873896bf82d393e1b3527b68e3" translate="yes" xml:space="preserve">
          <source>The maximum number of buffers that can be registered for a generic WAL record is &lt;code&gt;MAX_GENERIC_XLOG_PAGES&lt;/code&gt;. An error will be thrown if this limit is exceeded.</source>
          <target state="translated">通用WAL记录可以注册的最大缓冲区数是 &lt;code&gt;MAX_GENERIC_XLOG_PAGES&lt;/code&gt; 。如果超出此限制，将引发错误。</target>
        </trans-unit>
        <trans-unit id="62795c0abeb86c3cb2f44c4d31a9efa4ab1b021c" translate="yes" xml:space="preserve">
          <source>The maximum number of columns for a table is further reduced as the tuple being stored must fit in a single 8192-byte heap page. For example, excluding the tuple header, a tuple made up of 1600 &lt;code&gt;int&lt;/code&gt; columns would consume 6400 bytes and could be stored in a heap page, but a tuple of 1600 &lt;code&gt;bigint&lt;/code&gt; columns would consume 12800 bytes and would therefore not fit inside a heap page. Variable-length fields of types such as &lt;code&gt;text&lt;/code&gt;, &lt;code&gt;varchar&lt;/code&gt;, and &lt;code&gt;char&lt;/code&gt; can have their values stored out of line in the table's TOAST table when the values are large enough to require it. Only an 18-byte pointer must remain inside the tuple in the table's heap. For shorter length variable-length fields, either a 4-byte or 1-byte field header is used and the value is stored inside the heap tuple.</source>
          <target state="translated">由于要存储的元组必须适合单个8192字节的堆页面，因此表的最大列数进一步减少。例如，不包括元组标头，由1600个 &lt;code&gt;int&lt;/code&gt; 列组成的元组将占用6400字节并可以存储在堆页面中，但是具有1600个 &lt;code&gt;bigint&lt;/code&gt; 列的元组将消耗12800个字节，因此不适合放入堆页面中。类型的可变长度字段，例如 &lt;code&gt;text&lt;/code&gt; ， &lt;code&gt;varchar&lt;/code&gt; 和 &lt;code&gt;char&lt;/code&gt; 当值足够大时，可以将其值存储在表的TOAST表中。表堆中的元组中只能保留18个字节的指针。对于较短长度的可变长度字段，将使用4字节或1字节的字段标头，并将该值存储在堆元组内部。</target>
        </trans-unit>
        <trans-unit id="5febb5cd9beb7e14dc02349a0fabc85e580c54fa" translate="yes" xml:space="preserve">
          <source>The maximum number of commands to store in the command history (default 500). If set to a negative value, no limit is applied.</source>
          <target state="translated">存储在命令历史记录中的命令的最大数量(默认为500)。如果设置为负值,则没有限制。</target>
        </trans-unit>
        <trans-unit id="db38918ed0ba22959c7e085e2da67d6ae9e85522" translate="yes" xml:space="preserve">
          <source>The maximum number of entries in the array fields can be controlled on a column-by-column basis using the &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt; command, or globally by setting the &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; run-time parameter.</source>
          <target state="translated">数组字段中的最大条目数可以使用 &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt; 命令逐列控制，也可以通过设置&lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt;运行时参数来全局控制。</target>
        </trans-unit>
        <trans-unit id="d3e538107920d935aeb7ce10873e4d969580a999" translate="yes" xml:space="preserve">
          <source>The maximum number of rows to return. For details see &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;&lt;code&gt;LIMIT&lt;/code&gt; Clause&lt;/a&gt;.</source>
          <target state="translated">要返回的最大行数。有关详细信息，请参阅&lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt; &lt;code&gt;LIMIT&lt;/code&gt; 子句&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="758de2e2b468c97aa92a9251f6473d290c2c8830" translate="yes" xml:space="preserve">
          <source>The maximum number of rows to return. For details see &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;LIMIT Clause&lt;/a&gt; in the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="196f6ebe76be64ba3b271dddfbd4d6c8ae41617e" translate="yes" xml:space="preserve">
          <source>The maximum number of seconds to wait when attempting connection before returning that the server is not responding. Setting to 0 disables. The default is 3 seconds.</source>
          <target state="translated">试图连接时,在返回服务器没有响应之前等待的最大秒数。设置为0则禁用。默认为3秒。</target>
        </trans-unit>
        <trans-unit id="3aa8188a6b3b3fb92b1108055edfe63bc9db8999" translate="yes" xml:space="preserve">
          <source>The maximum time that a table can go unvacuumed is two billion transactions minus the &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt; value at the time of the last aggressive vacuum. If it were to go unvacuumed for longer than that, data loss could result. To ensure that this does not happen, autovacuum is invoked on any table that might contain unfrozen rows with XIDs older than the age specified by the configuration parameter &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-FREEZE-MAX-AGE&quot;&gt;autovacuum_freeze_max_age&lt;/a&gt;. (This will happen even if autovacuum is disabled.)</source>
          <target state="translated">一个表可以排空的最长时间为20亿个事务减去上一次主动真空 &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt; 时的vacuum_freeze_min_age值。如果将其抽空的时间更长，则可能导致数据丢失。为了确保不会发生这种情况，将对可能包含未冻结行的XID超过配置参数&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-FREEZE-MAX-AGE&quot;&gt;autovacuum_freeze_max_age&lt;/a&gt;指定的年龄的任何表调用autovacuum。 （即使禁用了自动真空，也会发生这种情况。）</target>
        </trans-unit>
        <trans-unit id="a2f6e9f6c92be1d6e4dbdfb81636d51c2482b4e7" translate="yes" xml:space="preserve">
          <source>The maximum transfer rate of data transferred from the server. Values are in kilobytes per second. Use a suffix of &lt;code&gt;M&lt;/code&gt; to indicate megabytes per second. A suffix of &lt;code&gt;k&lt;/code&gt; is also accepted, and has no effect. Valid values are between 32 kilobytes per second and 1024 megabytes per second.</source>
          <target state="translated">从服务器传输的数据的最大传输速率。值以每秒千字节为单位。使用后缀 &lt;code&gt;M&lt;/code&gt; 表示每秒兆字节。后缀 &lt;code&gt;k&lt;/code&gt; 也被接受，并且没有效果。有效值介于每秒32 KB和每秒1024 MB之间。</target>
        </trans-unit>
        <trans-unit id="aad15d96db29ca223b68ad77ebaeeab386249ae0" translate="yes" xml:space="preserve">
          <source>The meaning of the fields is as follows:</source>
          <target state="translated">这些领域的含义如下:</target>
        </trans-unit>
        <trans-unit id="cd3a4582b6d44983f8eaba4187d7e09c6429edc7" translate="yes" xml:space="preserve">
          <source>The meaning of this parameter, and its default value, changed in PostgreSQL 12; see &lt;a href=&quot;datatype-numeric#DATATYPE-FLOAT&quot;&gt;Section 8.1.3&lt;/a&gt; for further discussion.</source>
          <target state="translated">该参数的含义及其默认值已在PostgreSQL 12中更改；参见&lt;a href=&quot;datatype-numeric#DATATYPE-FLOAT&quot;&gt;8.1.3节&lt;/a&gt;进一步讨论。</target>
        </trans-unit>
        <trans-unit id="c7b63395362512b01d4281cff1f264dd9fa16bd8" translate="yes" xml:space="preserve">
          <source>The meanings of &lt;code&gt;PARALLEL SAFE&lt;/code&gt;, &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt;, and &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; are the same as in &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;. An aggregate will not be considered for parallelization if it is marked &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; (which is the default!) or &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt;. Note that the parallel-safety markings of the aggregate's support functions are not consulted by the planner, only the marking of the aggregate itself.</source>
          <target state="translated">&lt;code&gt;PARALLEL SAFE&lt;/code&gt; ， &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; 和 &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; 的含义与&lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION中&lt;/a&gt;的含义相同。如果聚合被标记为 &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; （这是默认设置！）或 &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; ,则将不考虑对其进行并行化。请注意，计划人员不咨询骨料支持功能的平行安全标记，而仅咨询骨料本身的标记。</target>
        </trans-unit>
        <trans-unit id="d9104f9afa808fa94ea8a0bf0c8363adf4ab748e" translate="yes" xml:space="preserve">
          <source>The mechanism that converts &lt;code&gt;(+-)&lt;/code&gt; to regular ranges isn't completely accurate in determining the number of significant digits for the boundaries. For example, it adds an extra digit to the lower boundary if the resulting interval includes a power of ten:</source>
          <target state="translated">将 &lt;code&gt;(+-)&lt;/code&gt; 转换为规则范围的机制在确定边界的有效位数方面并不完全准确。例如，如果结果间隔包含十的幂，它将在下边界添加一个额外的数字：</target>
        </trans-unit>
        <trans-unit id="221c60f17786086e4d1d8637638f0c8d9f6223fa" translate="yes" xml:space="preserve">
          <source>The members of a group role can use the privileges of the role in two ways. First, every member of a group can explicitly do &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt; to temporarily &amp;ldquo;become&amp;rdquo; the group role. In this state, the database session has access to the privileges of the group role rather than the original login role, and any database objects created are considered owned by the group role not the login role. Second, member roles that have the &lt;code&gt;INHERIT&lt;/code&gt; attribute automatically have use of the privileges of roles of which they are members, including any privileges inherited by those roles. As an example, suppose we have done:</source>
          <target state="translated">组角色的成员可以通过两种方式使用角色的特权。首先，组中的每个成员都可以显式执行&lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt;以暂时&amp;ldquo;成为&amp;rdquo;组角色。在这种状态下，数据库会话有权访问组角色而不是原始登录角色的特权，并且创建的任何数据库对象都被视为由组角色而非登录角色拥有。其次，具有 &lt;code&gt;INHERIT&lt;/code&gt; 属性的成员角色会自动使用其所属成员角色的特权，包括这些角色继承的所有特权。例如，假设我们已经完成：</target>
        </trans-unit>
        <trans-unit id="c531d86ffa3bb917e6ad2f8783d407b8d81b1be4" translate="yes" xml:space="preserve">
          <source>The mentioned transformations and compilations are normally done automatically using the &lt;em&gt;makefiles&lt;/em&gt; shipped with the PostgreSQL source distribution.</source>
          <target state="translated">上面提到的转换和编译通常是使用PostgreSQL源代码发布随附的&lt;em&gt;makefile&lt;/em&gt;自动完成的。</target>
        </trans-unit>
        <trans-unit id="8cd29d65e9431541c4a7e3d8e7bf9c8ca5af8963" translate="yes" xml:space="preserve">
          <source>The message is encrypted with a symmetric key.</source>
          <target state="translated">信息是用对称密钥加密的。</target>
        </trans-unit>
        <trans-unit id="bb36ba49fd3ad58b447d4a645799893632a3669c" translate="yes" xml:space="preserve">
          <source>The message is public-key encrypted, but the key ID has been removed. That means you will need to try all your secret keys on it to see which one decrypts it. &lt;code&gt;pgcrypto&lt;/code&gt; itself does not produce such messages.</source>
          <target state="translated">该消息是公共密钥加密的，但是密钥ID已被删除。这意味着您将需要尝试所有密钥以查看哪个密钥对其进行了解密。 &lt;code&gt;pgcrypto&lt;/code&gt; 本身不会产生这样的消息。</target>
        </trans-unit>
        <trans-unit id="80b9ed75dbe3c0d3f0a0153cbc3b5f5a6c2e4216" translate="yes" xml:space="preserve">
          <source>The metasyntax forms described in &lt;a href=&quot;functions-matching#POSIX-METASYNTAX&quot;&gt;Section 9.7.3.4&lt;/a&gt; do not exist in XQuery.</source>
          <target state="translated">&lt;a href=&quot;functions-matching#POSIX-METASYNTAX&quot;&gt;X9.7中&lt;/a&gt;不存在第9.7.3.4节中描述的元语法形式。</target>
        </trans-unit>
        <trans-unit id="5167d97b5af2d410349f4f14e2833acb2e09f087" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;ANY&lt;/code&gt; specifies a quorum-based synchronous replication and makes transaction commits wait until their WAL records are replicated to &lt;em&gt;at least&lt;/em&gt; the requested number of synchronous standbys in the list.</source>
          <target state="translated">方法 &lt;code&gt;ANY&lt;/code&gt; 指定基于仲裁的同步复制，并使事务提交等待，直到将其WAL记录复制到列表&lt;em&gt;中至少&lt;/em&gt;需要的同步备用数据库数量。</target>
        </trans-unit>
        <trans-unit id="f49f419e2b9a22a4fc79b879fb7d7ed163340aa2" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;FIRST&lt;/code&gt; specifies a priority-based synchronous replication and makes transaction commits wait until their WAL records are replicated to the requested number of synchronous standbys chosen based on their priorities. The standbys whose names appear earlier in the list are given higher priority and will be considered as synchronous. Other standby servers appearing later in this list represent potential synchronous standbys. If any of the current synchronous standbys disconnects for whatever reason, it will be replaced immediately with the next-highest-priority standby.</source>
          <target state="translated">方法 &lt;code&gt;FIRST&lt;/code&gt; 指定基于优先级的同步复制，并使事务提交等待，直到其WAL记录被复制到根据优先级选择的请求数量的同步备用数据库中。名称在列表中较早出现的备用数据库具有更高的优先级，并将被视为同步数据库。此列表后面出现的其他备用服务器代表潜在的同步备用服务器。如果任何当前同步备用数据库由于某种原因断开连接，它将立即替换为次高优先级备用数据库。</target>
        </trans-unit>
        <trans-unit id="3b4f76e9dc87199736499aa89b071e2462e85235" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;md5&lt;/code&gt; uses a custom less secure challenge-response mechanism. It prevents password sniffing and avoids storing passwords on the server in plain text but provides no protection if an attacker manages to steal the password hash from the server. Also, the MD5 hash algorithm is nowadays no longer considered secure against determined attacks.</source>
          <target state="translated">方法 &lt;code&gt;md5&lt;/code&gt; 使用自定义的不太安全的质询-响应机制。它防止密码嗅探，并避免将密码以纯文本格式存储在服务器上，但是如果攻击者设法从服务器上窃取密码哈希，则不会提供任何保护。同样，如今，MD5哈希算法不再被认为可以抵御确定的攻击。</target>
        </trans-unit>
        <trans-unit id="bbe98735c0b460f287d0e1fc8bbe8558da46b394" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;password&lt;/code&gt; sends the password in clear-text and is therefore vulnerable to password &amp;ldquo;sniffing&amp;rdquo; attacks. It should always be avoided if possible. If the connection is protected by SSL encryption then &lt;code&gt;password&lt;/code&gt; can be used safely, though. (Though SSL certificate authentication might be a better choice if one is depending on using SSL).</source>
          <target state="translated">该方法 &lt;code&gt;password&lt;/code&gt; 以明文发送密码，因此容易受到密码&amp;ldquo;嗅探&amp;rdquo;攻击。如果可能，应始终避免使用它。如果连接受SSL加密保护，则可以安全使用 &lt;code&gt;password&lt;/code&gt; 。（尽管如果使用SSL证书，则使用SSL证书身份验证可能是更好的选择）。</target>
        </trans-unit>
        <trans-unit id="c4e1d81897ac3ef5344a09ff3085827106ec9fad" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;scram-sha-256&lt;/code&gt; performs SCRAM-SHA-256 authentication, as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc7677&quot;&gt;RFC 7677&lt;/a&gt;. It is a challenge-response scheme that prevents password sniffing on untrusted connections and supports storing passwords on the server in a cryptographically hashed form that is thought to be secure.</source>
          <target state="translated">如&lt;a href=&quot;https://tools.ietf.org/html/rfc7677&quot;&gt;RFC 7677中&lt;/a&gt;所述， &lt;code&gt;scram-sha-256&lt;/code&gt; 方法执行SCRAM-SHA-256身份验证。它是一种质询-响应方案，可以防止对不信任的连接进行密码嗅探，并支持以加密哈希形式将密码存储在服务器上，这被认为是安全的。</target>
        </trans-unit>
        <trans-unit id="4d38dbf255ad283e492b192c046e51eef7da09c0" translate="yes" xml:space="preserve">
          <source>The method a client application must use to detect notification events depends on which PostgreSQL application programming interface it uses. With the libpq library, the application issues &lt;code&gt;LISTEN&lt;/code&gt; as an ordinary SQL command, and then must periodically call the function &lt;code&gt;PQnotifies&lt;/code&gt; to find out whether any notification events have been received. Other interfaces such as libpgtcl provide higher-level methods for handling notify events; indeed, with libpgtcl the application programmer should not even issue &lt;code&gt;LISTEN&lt;/code&gt; or &lt;code&gt;UNLISTEN&lt;/code&gt; directly. See the documentation for the interface you are using for more details.</source>
          <target state="translated">客户端应用程序检测通知事件所必须使用的方法取决于其使用的PostgreSQL应用程序编程接口。使用libpq库，应用程序将 &lt;code&gt;LISTEN&lt;/code&gt; 作为普通SQL命令发出，然后必须定期调用函数 &lt;code&gt;PQnotifies&lt;/code&gt; 来确定是否已接收到任何通知事件。其他接口（例如libpgtcl）提供了用于处理通知事件的更高级方法。实际上，使用libpgtcl，应用程序程序员甚至不应直接发出 &lt;code&gt;LISTEN&lt;/code&gt; 或 &lt;code&gt;UNLISTEN&lt;/code&gt; 。有关更多详细信息，请参见所用接口的文档。</target>
        </trans-unit>
        <trans-unit id="820cf6d702543aba9dfe85b2f79f3d6774753e9a" translate="yes" xml:space="preserve">
          <source>The method described in this section has been obsoleted by the use of stored generated columns, as described in &lt;a href=&quot;textsearch-tables#TEXTSEARCH-TABLES-INDEX&quot;&gt;Section 12.2.2&lt;/a&gt;.</source>
          <target state="translated">如&lt;a href=&quot;textsearch-tables#TEXTSEARCH-TABLES-INDEX&quot;&gt;第12.2.2&lt;/a&gt;节中所述，本节中描述的方法已被使用存储的生成列淘汰。</target>
        </trans-unit>
        <trans-unit id="318a555813c808d85dcecb5209b3a3a236dc9ab5" translate="yes" xml:space="preserve">
          <source>The method for triggering failover is an important part of planning and design. One potential option is the &lt;code&gt;restore_command&lt;/code&gt; command. It is executed once for each WAL file, but the process running the &lt;code&gt;restore_command&lt;/code&gt; is created and dies for each file, so there is no daemon or server process, and signals or a signal handler cannot be used. Therefore, the &lt;code&gt;restore_command&lt;/code&gt; is not suitable to trigger failover. It is possible to use a simple timeout facility, especially if used in conjunction with a known &lt;code&gt;archive_timeout&lt;/code&gt; setting on the primary. However, this is somewhat error prone since a network problem or busy primary server might be sufficient to initiate failover. A notification mechanism such as the explicit creation of a trigger file is ideal, if this can be arranged.</source>
          <target state="translated">触发故障转移的方法是规划和设计的重要组成部分。一个可能的选项是 &lt;code&gt;restore_command&lt;/code&gt; 命令。它对每个WAL文件执行一次，但是运行 &lt;code&gt;restore_command&lt;/code&gt; 的进程将为每个文件创建并死亡，因此没有守护程序或服务器进程，并且不能使用信号或信号处理程序。因此， &lt;code&gt;restore_command&lt;/code&gt; 不适合触发故障转移。可以使用简单的超时工具，尤其是与已知的 &lt;code&gt;archive_timeout&lt;/code&gt; 结合使用时设置在主要。但是，这有点容易出错，因为网络问题或繁忙的主服务器可能足以启动故障转移。如果可以安排通知机制，例如显式创建触发器文件，则是理想的选择。</target>
        </trans-unit>
        <trans-unit id="9ecf9a698c1e522b9c1de1bf5af789211b8be7ed" translate="yes" xml:space="preserve">
          <source>The millennium</source>
          <target state="translated">千年</target>
        </trans-unit>
        <trans-unit id="d49286ea0d415b0aad37189b731269fb41a33f65" translate="yes" xml:space="preserve">
          <source>The minute component of the time zone offset</source>
          <target state="translated">时区偏移的分钟分量</target>
        </trans-unit>
        <trans-unit id="70c1dd6d1f4cd9d65c5ea9908ee66b76d8b0f4e4" translate="yes" xml:space="preserve">
          <source>The minutes field (0 - 59)</source>
          <target state="translated">分钟领域(0-59)</target>
        </trans-unit>
        <trans-unit id="8e27da07ae7efc7685d90ec013484c3ec2a72626" translate="yes" xml:space="preserve">
          <source>The minutes field (0&amp;ndash;59)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f58bb99f67c9dd4fa543f324ba0a954d9aeea2c7" translate="yes" xml:space="preserve">
          <source>The missing positions 1,2,4 are because of stop words. Ranks calculated for documents with and without stop words are quite different:</source>
          <target state="translated">缺少的第1,2,4位是由于句号。有停顿词和没有停顿词的文件计算出的等级是完全不同的。</target>
        </trans-unit>
        <trans-unit id="7efece902ce6baec1dac421e4950dc636bcb9bc8" translate="yes" xml:space="preserve">
          <source>The mixed notation combines positional and named notation. However, as already mentioned, named arguments cannot precede positional arguments. For example:</source>
          <target state="translated">混合符号结合了位置符号和命名符号。但是,如前所述,命名参数不能在位置参数之前。例如:</target>
        </trans-unit>
        <trans-unit id="dfdfde6fd27332a6600ccf2d0ac2ce0c45f7420f" translate="yes" xml:space="preserve">
          <source>The mode of a function, procedure, or aggregate argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Note that &lt;code&gt;ALTER EXTENSION&lt;/code&gt; does not actually pay any attention to &lt;code&gt;OUT&lt;/code&gt; arguments, since only the input arguments are needed to determine the function's identity. So it is sufficient to list the &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, and &lt;code&gt;VARIADIC&lt;/code&gt; arguments.</source>
          <target state="translated">函数，过程或聚合参数的模式： &lt;code&gt;IN&lt;/code&gt; ， &lt;code&gt;OUT&lt;/code&gt; ， &lt;code&gt;INOUT&lt;/code&gt; 或 &lt;code&gt;VARIADIC&lt;/code&gt; 。如果省略，则默认值为 &lt;code&gt;IN&lt;/code&gt; 。请注意， &lt;code&gt;ALTER EXTENSION&lt;/code&gt; 实际上并不关注 &lt;code&gt;OUT&lt;/code&gt; 参数，因为仅需要输入参数即可确定函数的身份。因此，列出 &lt;code&gt;IN&lt;/code&gt; ， &lt;code&gt;INOUT&lt;/code&gt; 和 &lt;code&gt;VARIADIC&lt;/code&gt; 参数就足够了。</target>
        </trans-unit>
        <trans-unit id="68b58e6626dcfa87dd99931a1610596ebfd41322" translate="yes" xml:space="preserve">
          <source>The mode of a function, procedure, or aggregate argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Note that &lt;code&gt;COMMENT&lt;/code&gt; does not actually pay any attention to &lt;code&gt;OUT&lt;/code&gt; arguments, since only the input arguments are needed to determine the function's identity. So it is sufficient to list the &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, and &lt;code&gt;VARIADIC&lt;/code&gt; arguments.</source>
          <target state="translated">函数，过程或聚合参数的模式： &lt;code&gt;IN&lt;/code&gt; ， &lt;code&gt;OUT&lt;/code&gt; ， &lt;code&gt;INOUT&lt;/code&gt; 或 &lt;code&gt;VARIADIC&lt;/code&gt; 。如果省略，则默认值为 &lt;code&gt;IN&lt;/code&gt; 。请注意， &lt;code&gt;COMMENT&lt;/code&gt; 实际上并没有对 &lt;code&gt;OUT&lt;/code&gt; 参数给予任何关注，因为仅需要输入参数即可确定函数的身份。因此，列出 &lt;code&gt;IN&lt;/code&gt; ， &lt;code&gt;INOUT&lt;/code&gt; 和 &lt;code&gt;VARIADIC&lt;/code&gt; 参数就足够了。</target>
        </trans-unit>
        <trans-unit id="d48b93746498257a59bb7fe4e61442dbe73691fd" translate="yes" xml:space="preserve">
          <source>The mode of a function, procedure, or aggregate argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Note that &lt;code&gt;SECURITY LABEL&lt;/code&gt; does not actually pay any attention to &lt;code&gt;OUT&lt;/code&gt; arguments, since only the input arguments are needed to determine the function's identity. So it is sufficient to list the &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, and &lt;code&gt;VARIADIC&lt;/code&gt; arguments.</source>
          <target state="translated">函数，过程或聚合参数的模式： &lt;code&gt;IN&lt;/code&gt; ， &lt;code&gt;OUT&lt;/code&gt; ， &lt;code&gt;INOUT&lt;/code&gt; 或 &lt;code&gt;VARIADIC&lt;/code&gt; 。如果省略，则默认值为 &lt;code&gt;IN&lt;/code&gt; 。请注意，由于仅需要输入参数来确定函数的身份，因此 &lt;code&gt;SECURITY LABEL&lt;/code&gt; 实际上不会对 &lt;code&gt;OUT&lt;/code&gt; 参数给予任何关注。因此，列出 &lt;code&gt;IN&lt;/code&gt; ， &lt;code&gt;INOUT&lt;/code&gt; 和 &lt;code&gt;VARIADIC&lt;/code&gt; 参数就足够了。</target>
        </trans-unit>
        <trans-unit id="45f33dca690dafc673c0eaa64fba7b4d58d74383" translate="yes" xml:space="preserve">
          <source>The mode of an argument: &lt;code&gt;IN&lt;/code&gt; or &lt;code&gt;VARIADIC&lt;/code&gt;. (Aggregate functions do not support &lt;code&gt;OUT&lt;/code&gt; arguments.) If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Only the last argument can be marked &lt;code&gt;VARIADIC&lt;/code&gt;.</source>
          <target state="translated">参数的模式： &lt;code&gt;IN&lt;/code&gt; 或 &lt;code&gt;VARIADIC&lt;/code&gt; 。（聚合函数不支持 &lt;code&gt;OUT&lt;/code&gt; 参数。）如果省略，则默认值为 &lt;code&gt;IN&lt;/code&gt; 。只有最后一个参数可以标记为 &lt;code&gt;VARIADIC&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4568485f8330f08f8282bc3a9f4e6ab0835ae883" translate="yes" xml:space="preserve">
          <source>The mode of an argument: &lt;code&gt;IN&lt;/code&gt; or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;.</source>
          <target state="translated">参数的模式： &lt;code&gt;IN&lt;/code&gt; 或 &lt;code&gt;VARIADIC&lt;/code&gt; 。如果省略，则默认值为 &lt;code&gt;IN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d77ba6d205a4cdad089faf693afa61d51e9631c2" translate="yes" xml:space="preserve">
          <source>The mode of an argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. (&lt;code&gt;OUT&lt;/code&gt; arguments are currently not supported for procedures. Use &lt;code&gt;INOUT&lt;/code&gt; instead.)</source>
          <target state="translated">参数的模式： &lt;code&gt;IN&lt;/code&gt; ， &lt;code&gt;INOUT&lt;/code&gt; 或 &lt;code&gt;VARIADIC&lt;/code&gt; 。如果省略，则默认值为 &lt;code&gt;IN&lt;/code&gt; 。（过程当前不支持 &lt;code&gt;OUT&lt;/code&gt; 参数。请改用 &lt;code&gt;INOUT&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="38c566bf6c299177523daede4805416a31c75adc" translate="yes" xml:space="preserve">
          <source>The mode of an argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Note that &lt;code&gt;ALTER FUNCTION&lt;/code&gt; does not actually pay any attention to &lt;code&gt;OUT&lt;/code&gt; arguments, since only the input arguments are needed to determine the function's identity. So it is sufficient to list the &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, and &lt;code&gt;VARIADIC&lt;/code&gt; arguments.</source>
          <target state="translated">参数的模式： &lt;code&gt;IN&lt;/code&gt; ， &lt;code&gt;OUT&lt;/code&gt; ， &lt;code&gt;INOUT&lt;/code&gt; 或 &lt;code&gt;VARIADIC&lt;/code&gt; 。如果省略，则默认值为 &lt;code&gt;IN&lt;/code&gt; 。请注意， &lt;code&gt;ALTER FUNCTION&lt;/code&gt; 实际上并不关注 &lt;code&gt;OUT&lt;/code&gt; 参数，因为仅需要输入参数即可确定函数的身份。因此，列出 &lt;code&gt;IN&lt;/code&gt; ， &lt;code&gt;INOUT&lt;/code&gt; 和 &lt;code&gt;VARIADIC&lt;/code&gt; 参数就足够了。</target>
        </trans-unit>
        <trans-unit id="0c0698969a82046af9f337be0b0bf94de3d24ca9" translate="yes" xml:space="preserve">
          <source>The mode of an argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Note that &lt;code&gt;DROP FUNCTION&lt;/code&gt; does not actually pay any attention to &lt;code&gt;OUT&lt;/code&gt; arguments, since only the input arguments are needed to determine the function's identity. So it is sufficient to list the &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, and &lt;code&gt;VARIADIC&lt;/code&gt; arguments.</source>
          <target state="translated">参数的模式： &lt;code&gt;IN&lt;/code&gt; ， &lt;code&gt;OUT&lt;/code&gt; ， &lt;code&gt;INOUT&lt;/code&gt; 或 &lt;code&gt;VARIADIC&lt;/code&gt; 。如果省略，则默认值为 &lt;code&gt;IN&lt;/code&gt; 。请注意，由于仅需要输入参数来确定函数的标识，因此 &lt;code&gt;DROP FUNCTION&lt;/code&gt; 实际上并不关注 &lt;code&gt;OUT&lt;/code&gt; 参数。因此，列出 &lt;code&gt;IN&lt;/code&gt; ， &lt;code&gt;INOUT&lt;/code&gt; 和 &lt;code&gt;VARIADIC&lt;/code&gt; 参数就足够了。</target>
        </trans-unit>
        <trans-unit id="6f4ca0b892fae54672225fff5e45afe9a23bd3fa" translate="yes" xml:space="preserve">
          <source>The mode of an argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Only &lt;code&gt;OUT&lt;/code&gt; arguments can follow a &lt;code&gt;VARIADIC&lt;/code&gt; one. Also, &lt;code&gt;OUT&lt;/code&gt; and &lt;code&gt;INOUT&lt;/code&gt; arguments cannot be used together with the &lt;code&gt;RETURNS TABLE&lt;/code&gt; notation.</source>
          <target state="translated">参数的模式： &lt;code&gt;IN&lt;/code&gt; ， &lt;code&gt;OUT&lt;/code&gt; ， &lt;code&gt;INOUT&lt;/code&gt; 或 &lt;code&gt;VARIADIC&lt;/code&gt; 。如果省略，则默认值为 &lt;code&gt;IN&lt;/code&gt; 。只有 &lt;code&gt;OUT&lt;/code&gt; 参数可以跟随 &lt;code&gt;VARIADIC&lt;/code&gt; 。同样， &lt;code&gt;OUT&lt;/code&gt; 和 &lt;code&gt;INOUT&lt;/code&gt; 参数不能与 &lt;code&gt;RETURNS TABLE&lt;/code&gt; 表示法一起使用。</target>
        </trans-unit>
        <trans-unit id="51a81b68008882e6907064e5a6c6b245cdf62054" translate="yes" xml:space="preserve">
          <source>The modification of data that is already in the database is referred to as updating. You can update individual rows, all the rows in a table, or a subset of all rows. Each column can be updated separately; the other columns are not affected.</source>
          <target state="translated">对数据库中已有数据的修改称为更新。您可以更新单个行、表中的所有行或所有行的子集。每一列可以单独更新,其他列不受影响。</target>
        </trans-unit>
        <trans-unit id="853b75e3f66e460231939e7956e83ee3b696375d" translate="yes" xml:space="preserve">
          <source>The module also provides a data type &lt;code&gt;lo&lt;/code&gt;, which is really just a domain of the &lt;code&gt;oid&lt;/code&gt; type. This is useful for differentiating database columns that hold large object references from those that are OIDs of other things. You don't have to use the &lt;code&gt;lo&lt;/code&gt; type to use the trigger, but it may be convenient to use it to keep track of which columns in your database represent large objects that you are managing with the trigger. It is also rumored that the ODBC driver gets confused if you don't use &lt;code&gt;lo&lt;/code&gt; for BLOB columns.</source>
          <target state="translated">该模块还提供了数据类型 &lt;code&gt;lo&lt;/code&gt; ，它实际上只是 &lt;code&gt;oid&lt;/code&gt; 类型的一个域。这对于区分包含大对象引用的数据库列和其他OID的数据库列很有用。您不必使用 &lt;code&gt;lo&lt;/code&gt; 类型来使用触发器，但是使用它来跟踪数据库中哪些列代表您正在使用触发器管理的大对象可能会很方便。也有传言说，如果您不对BLOB列使用 &lt;code&gt;lo&lt;/code&gt; ，则ODBC驱动程序会感到困惑。</target>
        </trans-unit>
        <trans-unit id="81ca0d62d96cb007036c4e8c71ad66419c59e2b5" translate="yes" xml:space="preserve">
          <source>The module must be loaded by adding &lt;code&gt;pg_stat_statements&lt;/code&gt; to &lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;, because it requires additional shared memory. This means that a server restart is needed to add or remove the module.</source>
          <target state="translated">必须通过将 &lt;code&gt;pg_stat_statements&lt;/code&gt; 添加到 &lt;code&gt;postgresql.conf&lt;/code&gt; 中的&lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt;中来加载该模块，因为它需要附加的共享内存。这意味着需要重新启动服务器才能添加或删除模块。</target>
        </trans-unit>
        <trans-unit id="d72e93f82e4421713f65eb6d758581a8fbe9cccf" translate="yes" xml:space="preserve">
          <source>The module provides a C function &lt;code&gt;pg_buffercache_pages&lt;/code&gt; that returns a set of records, plus a view &lt;code&gt;pg_buffercache&lt;/code&gt; that wraps the function for convenient use.</source>
          <target state="translated">该模块提供了一个C函数 &lt;code&gt;pg_buffercache_pages&lt;/code&gt; ，该函数返回一组记录，以及一个视图 &lt;code&gt;pg_buffercache&lt;/code&gt; ，该视图包装了该函数以便于使用。</target>
        </trans-unit>
        <trans-unit id="32a787e9d3c71749ae7c7075bc8cc6c86f32c2a0" translate="yes" xml:space="preserve">
          <source>The module provides no SQL-accessible functions. To use it, simply load it into the server. You can load it into an individual session:</source>
          <target state="translated">该模块不提供SQL可访问的功能。要使用它,只需将其加载到服务器中即可。你可以把它加载到一个单独的会话中。</target>
        </trans-unit>
        <trans-unit id="7b136900f1dbee2d882f7a554d2840c344beb60e" translate="yes" xml:space="preserve">
          <source>The module requires additional shared memory proportional to &lt;code&gt;pg_stat_statements.max&lt;/code&gt;. Note that this memory is consumed whenever the module is loaded, even if &lt;code&gt;pg_stat_statements.track&lt;/code&gt; is set to &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">该模块需要与 &lt;code&gt;pg_stat_statements.max&lt;/code&gt; 成比例的附加共享内存。请注意，即使 &lt;code&gt;pg_stat_statements.track&lt;/code&gt; 设置为 &lt;code&gt;none&lt;/code&gt; ，只要加载模块，就会消耗此内存。</target>
        </trans-unit>
        <trans-unit id="e9ad875208f4afcd97973304af9fd6ef485a5b48" translate="yes" xml:space="preserve">
          <source>The monitoring information about subscription is visible in &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-SUBSCRIPTION&quot;&gt;&lt;code&gt;pg_stat_subscription&lt;/code&gt;&lt;/a&gt;. This view contains one row for every subscription worker. A subscription can have zero or more active subscription workers depending on its state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96530f50681b8674942f17d7870b9786b275bddf" translate="yes" xml:space="preserve">
          <source>The monitoring information about subscription is visible in &lt;a href=&quot;monitoring-stats#PG-STAT-SUBSCRIPTION&quot;&gt;&lt;code&gt;pg_stat_subscription&lt;/code&gt;&lt;/a&gt;. This view contains one row for every subscription worker. A subscription can have zero or more active subscription workers depending on its state.</source>
          <target state="translated">有关订阅的监视信息在&lt;a href=&quot;monitoring-stats#PG-STAT-SUBSCRIPTION&quot;&gt; &lt;code&gt;pg_stat_subscription&lt;/code&gt; 中&lt;/a&gt;可见。该视图为每个订阅工作器包含一行。一个订阅可以有零个或多个活动的订阅工作器，具体取决于其状态。</target>
        </trans-unit>
        <trans-unit id="e4f2efea26fbea2f4a0f53659ea7db3de7f00c25" translate="yes" xml:space="preserve">
          <source>The most common reason for conflict between standby queries and WAL replay is &amp;ldquo;early cleanup&amp;rdquo;. Normally, PostgreSQL allows cleanup of old row versions when there are no transactions that need to see them to ensure correct visibility of data according to MVCC rules. However, this rule can only be applied for transactions executing on the master. So it is possible that cleanup on the master will remove row versions that are still visible to a transaction on the standby.</source>
          <target state="translated">备用查询和WAL重播之间发生冲突的最常见原因是&amp;ldquo;早期清理&amp;rdquo;。通常，当没有事务需要查看旧行版本以确保根据MVCC规则正确显示数据时，PostgreSQL允许清除旧行版本。但是，此规则仅适用于在主服务器上执行的事务。因此，有可能主服务器上的清理将删除备用服务器上的事务仍可见的行版本。</target>
        </trans-unit>
        <trans-unit id="731bbf4edb90976573e528f87d62ab4f72b17368" translate="yes" xml:space="preserve">
          <source>The most critical part of the display is the estimated statement execution cost, which is the planner's guess at how long it will take to run the statement (measured in cost units that are arbitrary, but conventionally mean disk page fetches). Actually two numbers are shown: the start-up cost before the first row can be returned, and the total cost to return all the rows. For most queries the total cost is what matters, but in contexts such as a subquery in &lt;code&gt;EXISTS&lt;/code&gt;, the planner will choose the smallest start-up cost instead of the smallest total cost (since the executor will stop after getting one row, anyway). Also, if you limit the number of rows to return with a &lt;code&gt;LIMIT&lt;/code&gt; clause, the planner makes an appropriate interpolation between the endpoint costs to estimate which plan is really the cheapest.</source>
          <target state="translated">显示中最关键的部分是估计的语句执行成本，这是计划者对运行该语句将花费多长时间的猜测（以任意成本单位衡量，但通常是指磁盘页的获取）。实际上显示了两个数字：可以返回第一行之前的启动成本，以及返回所有行的总成本。对于大多数查询来说，总成本是很重要的，但是在诸如 &lt;code&gt;EXISTS&lt;/code&gt; 中的子查询之类的环境中，计划者将选择最小的启动成本，而不是最小的总成本（因为执行器无论如何会在获得一行之后停止运行）。另外，如果您限制返回的行数为 &lt;code&gt;LIMIT&lt;/code&gt; 子句中，计划者在端点成本之间进行适当的插值，以估计哪个计划确实最便宜。</target>
        </trans-unit>
        <trans-unit id="413b816a60a8ce6de7ad09a5ffb4362dd48af1ec" translate="yes" xml:space="preserve">
          <source>The most fundamental way to set these parameters is to edit the file &lt;code&gt;postgresql.conf&lt;/code&gt;, which is normally kept in the data directory. A default copy is installed when the database cluster directory is initialized. An example of what this file might look like is:</source>
          <target state="translated">设置这些参数的最基本方法是编辑文件 &lt;code&gt;postgresql.conf&lt;/code&gt; ，该文件通常保存在数据目录中。初始化数据库集群目录时，将安装默认副本。该文件的外观示例如下：</target>
        </trans-unit>
        <trans-unit id="e306bed63f3a1d9eca423326fcf07e6b9edcc6b0" translate="yes" xml:space="preserve">
          <source>The most important disk monitoring task of a database administrator is to make sure the disk doesn't become full. A filled data disk will not result in data corruption, but it might prevent useful activity from occurring. If the disk holding the WAL files grows full, database server panic and consequent shutdown might occur.</source>
          <target state="translated">数据库管理员最重要的磁盘监控任务是确保磁盘不会满。充满数据的磁盘不会导致数据损坏,但它可能会阻止有用的活动发生。如果存放WAL文件的磁盘满了,可能会发生数据库服务器恐慌和随之而来的关闭。</target>
        </trans-unit>
        <trans-unit id="877dc37c3736494355fb75407dc41fe0e6f84483" translate="yes" xml:space="preserve">
          <source>The most interesting options are probably &lt;code&gt;compress-algo&lt;/code&gt; and &lt;code&gt;unicode-mode&lt;/code&gt;. The rest should have reasonable defaults.</source>
          <target state="translated">最有趣的选项可能是 &lt;code&gt;compress-algo&lt;/code&gt; 和 &lt;code&gt;unicode-mode&lt;/code&gt; 。其余应具有合理的默认值。</target>
        </trans-unit>
        <trans-unit id="9a6d131c4243d30d96e0db292f1623b359a016fb" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a &lt;em&gt;planner support function&lt;/em&gt; to use for this function. See &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-optimization.html&quot;&gt;Section 37.11&lt;/a&gt; for details. You must be superuser to use this option.</source>
          <target state="translated">用于此功能的&lt;em&gt;计划程序支持功能&lt;/em&gt;的名称（可选，由模式限定）。有关详细信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-optimization.html&quot;&gt;第37.11节&lt;/a&gt;。您必须是超级用户才能使用此选项。</target>
        </trans-unit>
        <trans-unit id="1902fa4c4f3be48a1f8af8f713baf8e7dfa86fb2" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a &lt;em&gt;planner support function&lt;/em&gt; to use for this function. See &lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc-optimization.html&quot;&gt;Section 37.11&lt;/a&gt; for details. You must be superuser to use this option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14b6fcb4c63d755a00d7e0670d638ed746023a2d" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a domain to be created.</source>
          <target state="translated">要创建的域的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="38611bfc887263be7f78673bf7d9d5cdb57c578a" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a function that is an index method support function for the operator class.</source>
          <target state="translated">操作符类的索引方法支持函数的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="5902522e953f867bcf2f16270ac0968cc20f9546" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a function that is an index method support function for the operator family. If no argument list is specified, the name must be unique in its schema.</source>
          <target state="translated">运算符族的索引方法支持函数的名称(可选择模式限定)。如果没有指定参数列表,那么这个名称在模式中必须是唯一的。</target>
        </trans-unit>
        <trans-unit id="d845c7a3b53e4177570415c0bc3bcd5b3195e4e2" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a sequence to be altered.</source>
          <target state="translated">要改变的序列的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="86f2ddbdf403f4ceac3ce1673bf568f23dd1ad99" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a sequence.</source>
          <target state="translated">序列的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="ac3e3dd701383980ee625dc0305504430477533a" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a specific table or materialized view to vacuum. If the specified table is a partitioned table, all of its leaf partitions are vacuumed.</source>
          <target state="translated">要吸尘的特定表或实体化视图的名称(可选择模式限定)。如果指定的表是一个分区表,那么它的所有叶分区都会被抽空。</target>
        </trans-unit>
        <trans-unit id="53bb17c6184a24ee8382a2d75581d17a4a86859a" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a table to truncate. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, only that table is truncated. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, the table and all its descendant tables (if any) are truncated. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">要截断的表的名称（可选，由模式限定）。如果在表名之前指定了 &lt;code&gt;ONLY&lt;/code&gt; ，则仅该表被截断。如果未指定 &lt;code&gt;ONLY&lt;/code&gt; ，则该表及其所有后代表（如果有）将被截断。（可选）可以在表名之后指定 &lt;code&gt;*&lt;/code&gt; ,以明确指示包括后代表。</target>
        </trans-unit>
        <trans-unit id="2e64f1d6069ef5fc5ed6316b39d72b0e2b06f901" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a type to be created.</source>
          <target state="translated">要创建的类型的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="f9bf344cdc87b1adaf5636fb2ebcad9f1ddba5b6" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a view to be created.</source>
          <target state="translated">要创建的视图的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="b639552e986e941a3c10c2544ec995a239ffb6e3" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing &lt;code&gt;btree&lt;/code&gt; operator family that describes the sort ordering associated with an ordering operator.</source>
          <target state="translated">现有 &lt;code&gt;btree&lt;/code&gt; 运算符家族的名称（可选，由模式限定），描述与排序运算符关联的排序顺序。</target>
        </trans-unit>
        <trans-unit id="34900785f9149eeefbc60e92cda94ca173cd04e7" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing aggregate function.</source>
          <target state="translated">现有聚合函数的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="578ce1660a308750d3e750170be95b160d2b4eaa" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing collation.</source>
          <target state="translated">现有整理的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="f41ad29e0b7f082d84fd62fd8cb20d2acca4d7fc" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing conversion.</source>
          <target state="translated">现有转换的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="3906d435eac2789ae790437fa866de097132bd5f" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing domain.</source>
          <target state="translated">一个现有域名的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="d79e2ff622e47d59db15f73c173411091fa8fabb" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing function. If no argument list is specified, the name must be unique in its schema.</source>
          <target state="translated">一个现有函数的名称(可选择模式限定)。如果没有指定参数列表,则该名称在模式中必须是唯一的。</target>
        </trans-unit>
        <trans-unit id="e19891aa77a7fd37f7b714112d5a229b9e2c2c1e" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing materialized view.</source>
          <target state="translated">现有物化视图的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="d3c124f08f1d17279d8902cee277b8d4f1a183ad" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing operator class.</source>
          <target state="translated">现有操作者类的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="38e2880de321890fbbcce2e9729e127a62b40b76" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing operator family.</source>
          <target state="translated">现有操作员家族的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="054a0dca285caf1e015006f488ef65a3eecedbf4" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing operator.</source>
          <target state="translated">现有操作者的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="77adb5998ee2e3aabde213dad5e54fd26872e3dc" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing procedure. If no argument list is specified, the name must be unique in its schema.</source>
          <target state="translated">一个现有存储过程的名称(可选择模式限定)。如果没有指定参数列表,那么这个名字在模式中必须是唯一的。</target>
        </trans-unit>
        <trans-unit id="f544776c8e3c1cef33633f466a66f32aea31c3fe" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing table or view. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, only that table is scanned. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, the table and all its descendant tables (if any) are scanned. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">现有表或视图的名称（可选，由模式限定）。如果在表名之前 &lt;code&gt;ONLY&lt;/code&gt; 指定了ONLY，则仅扫描该表。如果未指定 &lt;code&gt;ONLY&lt;/code&gt; ，则扫描该表及其所有后代表（如果有）。（可选）可以在表名之后指定 &lt;code&gt;*&lt;/code&gt; ,以明确指示包括后代表。</target>
        </trans-unit>
        <trans-unit id="fed47b49b5a2826cdd529f07291a0b91365295e5" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing table to alter. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, only that table is altered. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, the table and all its descendant tables (if any) are altered. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">要更改的现有表的名称（可选的模式限定）。如果在表名之前 &lt;code&gt;ONLY&lt;/code&gt; 指定了ONLY，则仅更改该表。如果未指定 &lt;code&gt;ONLY&lt;/code&gt; ，则该表及其所有后代表（如果有）将被更改。（可选）可以在表名之后指定 &lt;code&gt;*&lt;/code&gt; ,以明确指示包括后代表。</target>
        </trans-unit>
        <trans-unit id="9e39d635b5a89d3591bd7fd7ce4ecbe9ffd4c1d5" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing table to lock. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, only that table is locked. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, the table and all its descendant tables (if any) are locked. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">要锁定的现有表的名称（可选，由模式限定）。如果在表名之前指定了 &lt;code&gt;ONLY&lt;/code&gt; ，则仅该表被锁定。如果未指定 &lt;code&gt;ONLY&lt;/code&gt; ，则表及其所有后代表（如果有）将被锁定。 （可选）可以在表名之后指定 &lt;code&gt;*&lt;/code&gt; ,以明确指示包括后代表。</target>
        </trans-unit>
        <trans-unit id="7b428f5695f116b2abd1edd43a6b7f791e930f67" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing table.</source>
          <target state="translated">现有表的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="d6bac31933d004e229772d4577bb5205aa40d1b4" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing text search configuration.</source>
          <target state="translated">现有文本搜索配置的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="c30fa81fa2fa2992c5e25e7be26425ba28f70618" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing text search dictionary.</source>
          <target state="translated">现有文本搜索字典的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="6764c434bb1917335a8e7ae9bad93f1fcc49fc17" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing text search parser.</source>
          <target state="translated">现有文本搜索解析器的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="dcc71c03641d807db453dbb54b0a2fce72902867" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing text search template.</source>
          <target state="translated">现有文本搜索模板的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="c07fc33a37601af59ca6761edf035f64fe688e76" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing view.</source>
          <target state="translated">现有视图的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="5f3b87270ccb7b31876399c63171eeddc6c5acd0" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an index to remove.</source>
          <target state="translated">要删除的索引的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="4d1a15fbadbb463eba7072f8d97b36fff8e4db35" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an operator associated with the operator class.</source>
          <target state="translated">与操作符类相关联的操作符的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="f55c07895028de262598e75436d631175b201a69" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an operator associated with the operator family.</source>
          <target state="translated">与操作者家族相关联的操作者的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="b2bd7b76dedcec38eb17eed38f1b959f8bd417a7" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the aggregate function to create.</source>
          <target state="translated">要创建的聚合函数的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="a93a4bd4bc9034a1432f189ca88e837333dc130b" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the data type to remove.</source>
          <target state="translated">要删除的数据类型的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="985217a7a1fa0c3a567eb7244b6b8b146f2c7b30" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the foreign table to drop.</source>
          <target state="translated">要删除的外表的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="c10f31992b2571e70d614bb2d060a79ba59a8a33" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the function to create.</source>
          <target state="translated">要创建的函数的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="83e9847814c3ba939cbc4f420e1c3c7c00a69552" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the materialized view to be created.</source>
          <target state="translated">要创建的物化视图的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="2255582209b1f3da815e53122bc13a8a7b84cf00" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the materialized view to refresh.</source>
          <target state="translated">要刷新的物质化视图的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="2db1fb74b2f868165f2c5564d755e2f43c24353f" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the materialized view to remove.</source>
          <target state="translated">要删除的物化视图的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="9df0359ba8b94b06eb25b013152842f292a7b4df" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the procedure to create.</source>
          <target state="translated">要创建的存储过程的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="4cd07bcb956404ed169f912452a4480e70e115e4" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the procedure.</source>
          <target state="translated">程序的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="2a4c2e1b22bdcbf405362b9ae17fa1fbce426df2" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the sequence to be created.</source>
          <target state="translated">要创建的序列的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="048a9ab4e359ce8b95a4959e9df97e30c4e65d60" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the statistics object to be altered.</source>
          <target state="translated">要更改的统计对象的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="f52881167770a0af5eb7409ca2185b9c04bac337" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the statistics object to be created.</source>
          <target state="translated">要创建的统计对象的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="4b423cb4d9cc1b2bcdad9b8dd172fb72d89e4e2c" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the statistics object to drop.</source>
          <target state="translated">要删除的统计对象的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="b61d21dada065f46c4c7b2b7d604e26966040dc1" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table containing the column(s) the statistics are computed on.</source>
          <target state="translated">包含计算统计列的表的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="8defd757e6f0ae34c512e774b626ccf674726eab" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table for which the trigger is defined.</source>
          <target state="translated">定义触发器的表的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="4d5698a39cc31b5f7b88bdd408f67f5c7638f5d5" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table or view that the rule applies to.</source>
          <target state="translated">规则适用的表或视图的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="b756bc816e4bf98b49581640b12dbf571a3be447" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table or view the rule applies to.</source>
          <target state="translated">规则所适用的表或视图的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="1babb726cd58996c0c81dade9eb62f3731eca7ef" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table that the policy is on.</source>
          <target state="translated">策略所在表的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="66f5ae5d2b295f1ee2b970f57d5d9ecd6bf021d8" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table the policy applies to.</source>
          <target state="translated">策略所适用的表的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="2163decbe5c6781dc3c30049b04dc6fe3b754ccd" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table to be created.</source>
          <target state="translated">要创建的表的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="7faaacd9226a4e88c9e4c1c3c739210417e124ce" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table to delete rows from. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, matching rows are deleted from the named table only. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, matching rows are also deleted from any tables inheriting from the named table. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">要从中删除行的表的名称（可选，由模式限定）。如果在表名之前指定了 &lt;code&gt;ONLY&lt;/code&gt; ，则仅从命名表中删除匹配的行。如果未指定 &lt;code&gt;ONLY&lt;/code&gt; ，则匹配的行也会从继承自命名表的所有表中删除。 （可选）可以在表名之后指定 &lt;code&gt;*&lt;/code&gt; ,以明确指示包括后代表。</target>
        </trans-unit>
        <trans-unit id="2a919fb8f51d9d6b6757a121c98308d8b2e355a9" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table to drop.</source>
          <target state="translated">要删除的表的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="805225c1106f83d7720b93b38e959f1241d2a307" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table to update. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, matching rows are updated in the named table only. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, matching rows are also updated in any tables inheriting from the named table. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">要更新的表的名称（可选，由模式限定）。如果在表名之前指定了 &lt;code&gt;ONLY&lt;/code&gt; ,则仅在命名表中更新匹配的行。如果未指定 &lt;code&gt;ONLY&lt;/code&gt; ,则在从命名表继承的任何表中匹配行也将更新。 （可选）可以在表名之后指定 &lt;code&gt;*&lt;/code&gt; ,以明确指示包括后代表。</target>
        </trans-unit>
        <trans-unit id="56ec5e8966f4a00d4b5c2a7c99ee7bd04c931eab" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table, view, or foreign table the trigger is for.</source>
          <target state="translated">触发器所在的表、视图或外表的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="72a54509c9fcd2a9291f8a3e62487b349d23e646" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the view to remove.</source>
          <target state="translated">要删除的视图的名称(可选择模式限定)。</target>
        </trans-unit>
        <trans-unit id="359f50eaf29e3eca920ffd05f6355f20cb0c9f2e" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of a specific table to analyze. If omitted, all regular tables, partitioned tables, and materialized views in the current database are analyzed (but not foreign tables). If the specified table is a partitioned table, both the inheritance statistics of the partitioned table as a whole and statistics of the individual partitions are updated.</source>
          <target state="translated">要分析的特定表的名称(可能是模式限定的)。如果省略,则分析当前数据库中的所有常规表、分区表和实体化视图(但不包括外表)。如果指定的表是一个分区表,那么分区表作为一个整体的继承统计和各个分区的统计都会更新。</target>
        </trans-unit>
        <trans-unit id="a0cd47e6e1a9ee5389b9c55e40402c5ad699bfc0" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of a table.</source>
          <target state="translated">一个表的名称(可能是模式限定的)。</target>
        </trans-unit>
        <trans-unit id="36578a59c82b2f2c476f7f18ac9898c7cebf4713" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of an existing domain to alter.</source>
          <target state="translated">要更改的现有域的名称(可能是模式限定的)。</target>
        </trans-unit>
        <trans-unit id="c76b8e93831ffb6b044097c12ef94efed652a62a" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of an existing foreign table to alter. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, only that table is altered. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, the table and all its descendant tables (if any) are altered. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">要更改的现有外部表的名称（可能是模式限定的）。如果在表名之前 &lt;code&gt;ONLY&lt;/code&gt; 指定了ONLY，则仅更改该表。如果未指定 &lt;code&gt;ONLY&lt;/code&gt; ，则该表及其所有后代表（如果有）将被更改。（可选）可以在表名之后指定 &lt;code&gt;*&lt;/code&gt; ,以明确指示包括后代表。</target>
        </trans-unit>
        <trans-unit id="fc6c50c1390116c899b9f1d7b2719134752e51ac" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of an existing index to alter.</source>
          <target state="translated">要更改的现有索引的名称(可能是模式限定的)。</target>
        </trans-unit>
        <trans-unit id="f3966882870cfe613d0a8e73355b9179fb2c810a" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of an existing type to alter.</source>
          <target state="translated">要更改的现有类型的名称(可能是模式限定的)。</target>
        </trans-unit>
        <trans-unit id="06da0274ecfe82f800f0ab5a5f38a984e49a92a1" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of the table to be indexed.</source>
          <target state="translated">要建立索引的表的名称(可能是模式限定的)。</target>
        </trans-unit>
        <trans-unit id="a158ac6caffff3f341ed81dff98d22b9af284fcf" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;test1_id_index&lt;/code&gt; can be chosen freely, but you should pick something that enables you to remember later what the index was for.</source>
          <target state="translated">名称 &lt;code&gt;test1_id_index&lt;/code&gt; 可以自由选择，但是您应该选择一些名称，以便稍后记住该索引的用途。</target>
        </trans-unit>
        <trans-unit id="27865390113cdcda66f400351749779a6e670188" translate="yes" xml:space="preserve">
          <source>The name can be any string of less than &lt;code&gt;NAMEDATALEN&lt;/code&gt; characters (64 characters in a standard build). Only printable ASCII characters may be used in the &lt;code&gt;cluster_name&lt;/code&gt; value. Other characters will be replaced with question marks (&lt;code&gt;?&lt;/code&gt;). No name is shown if this parameter is set to the empty string &lt;code&gt;''&lt;/code&gt; (which is the default). This parameter can only be set at server start.</source>
          <target state="translated">名称可以是少于 &lt;code&gt;NAMEDATALEN&lt;/code&gt; 个字符（标准构建中为64个字符）的任何字符串。 &lt;code&gt;cluster_name&lt;/code&gt; 值中只能使用可打印的ASCII字符。其他字符将替换为问号（ &lt;code&gt;?&lt;/code&gt; ）。如果此参数设置为空字符串 &lt;code&gt;''&lt;/code&gt; （默认），则不显示名称。该参数只能在服务器启动时设置。</target>
        </trans-unit>
        <trans-unit id="0be2813c09731c2a742fdb24fc852c07e13e3ed7" translate="yes" xml:space="preserve">
          <source>The name of a &lt;code&gt;table_name&lt;/code&gt; column. Used to infer arbiter indexes. Follows &lt;code&gt;CREATE INDEX&lt;/code&gt; format. &lt;code&gt;SELECT&lt;/code&gt; privilege on &lt;code&gt;index_column_name&lt;/code&gt; is required.</source>
          <target state="translated">&lt;code&gt;table_name&lt;/code&gt; 列的名称。用于推断仲裁者索引。遵循 &lt;code&gt;CREATE INDEX&lt;/code&gt; 格式。必须具有 &lt;code&gt;index_column_name&lt;/code&gt; 的 &lt;code&gt;SELECT&lt;/code&gt; 特权。</target>
        </trans-unit>
        <trans-unit id="347e4a2b8b46492f607cf8e79afee93d1d470e6b" translate="yes" xml:space="preserve">
          <source>The name of a b-tree operator class for the subtype.</source>
          <target state="translated">子类型的b树操作类的名称。</target>
        </trans-unit>
        <trans-unit id="84001d19bb8ee2bc0f3fd3214b7948ea87315d70" translate="yes" xml:space="preserve">
          <source>The name of a base-type property to be modified; see above for possible values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e4c963309e1915e51f2989fadcd94d4d9264511" translate="yes" xml:space="preserve">
          <source>The name of a column in the new materialized view. If column names are not provided, they are taken from the output column names of the query.</source>
          <target state="translated">新物化视图中的列名。如果没有提供列名,则取自查询的输出列名。</target>
        </trans-unit>
        <trans-unit id="38a996c1d10563af1a139319a2d1ffd30fc57281" translate="yes" xml:space="preserve">
          <source>The name of a column in the new table. If column names are not provided, they are taken from the output column names of the query.</source>
          <target state="translated">新表中的列名。如果没有提供列名,则取自查询的输出列名。</target>
        </trans-unit>
        <trans-unit id="88674d0aca3396b42507d5f644ff534993edea22" translate="yes" xml:space="preserve">
          <source>The name of a column in the table named by &lt;code&gt;table_name&lt;/code&gt;. The column name can be qualified with a subfield name or array subscript, if needed. (Inserting into only some fields of a composite column leaves the other fields null.) When referencing a column with &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt;, do not include the table's name in the specification of a target column. For example, &lt;code&gt;INSERT INTO table_name ... ON CONFLICT DO UPDATE SET table_name.col = 1&lt;/code&gt; is invalid (this follows the general behavior for &lt;code&gt;UPDATE&lt;/code&gt;).</source>
          <target state="translated">表中以 &lt;code&gt;table_name&lt;/code&gt; 命名的列的名称。如果需要，可以使用子字段名称或数组下标来限定列名称。 （仅插入到复合列的某些字段中，而其他字段为null。）当使用 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 引用列时，请勿在目标列的规范中包括该表的名称。例如， &lt;code&gt;INSERT INTO table_name ... ON CONFLICT DO UPDATE SET table_name.col = 1&lt;/code&gt; 无效（这遵循 &lt;code&gt;UPDATE&lt;/code&gt; 的一般行为）。</target>
        </trans-unit>
        <trans-unit id="37965fca46dac2ae8978b3ba3784bd4c0e6d710a" translate="yes" xml:space="preserve">
          <source>The name of a column in the table named by &lt;code&gt;table_name&lt;/code&gt;. The column name can be qualified with a subfield name or array subscript, if needed. Do not include the table's name in the specification of a target column &amp;mdash; for example, &lt;code&gt;UPDATE table_name SET table_name.col = 1&lt;/code&gt; is invalid.</source>
          <target state="translated">表中以 &lt;code&gt;table_name&lt;/code&gt; 命名的列的名称。如果需要，可以使用子字段名称或数组下标来限定列名称。不要在目标列的规范中包括表的名称-例如， &lt;code&gt;UPDATE table_name SET table_name.col = 1&lt;/code&gt; 无效。</target>
        </trans-unit>
        <trans-unit id="43b0ac7767512f2c3828414a44343ffbdea05c48" translate="yes" xml:space="preserve">
          <source>The name of a column of the table.</source>
          <target state="translated">表中一列的名称。</target>
        </trans-unit>
        <trans-unit id="66eab6eba8b42b05c2deccc82d07f73f07802b19" translate="yes" xml:space="preserve">
          <source>The name of a column to be created in the new table.</source>
          <target state="translated">要在新表中创建的列名。</target>
        </trans-unit>
        <trans-unit id="b107b21b5ebe28c88ce9e0df68fea5f76d67283a" translate="yes" xml:space="preserve">
          <source>The name of a database to create.</source>
          <target state="translated">要创建的数据库名称。</target>
        </trans-unit>
        <trans-unit id="2836c4dd7800c0b2de8f3f3ed8ae3591f1a8fd6b" translate="yes" xml:space="preserve">
          <source>The name of a difference function for the subtype.</source>
          <target state="translated">子类型的差异函数的名称。</target>
        </trans-unit>
        <trans-unit id="cc2b3b4a893c2c09d0bead8670c584d57f2b3d8a" translate="yes" xml:space="preserve">
          <source>The name of a function that converts an array of modifier(s) for the type into internal form.</source>
          <target state="translated">将类型的修饰符数组转换为内部形式的函数名称。</target>
        </trans-unit>
        <trans-unit id="9cfae7f4211e6fa9e0eeadb788b0238e1401f532" translate="yes" xml:space="preserve">
          <source>The name of a function that converts data from the type's external binary form to its internal form.</source>
          <target state="translated">将数据从类型的外部二进制形式转换为内部形式的函数名称。</target>
        </trans-unit>
        <trans-unit id="b8ec9150353430f953f8a2508fb1cc00d06ec3ad" translate="yes" xml:space="preserve">
          <source>The name of a function that converts data from the type's external textual form to its internal form.</source>
          <target state="translated">将数据从类型的外部文本形式转换为内部形式的函数名称。</target>
        </trans-unit>
        <trans-unit id="e45bf619f83208134b19be3fe39ffa394657e429" translate="yes" xml:space="preserve">
          <source>The name of a function that converts data from the type's internal form to its external binary form.</source>
          <target state="translated">将数据从类型的内部形式转换为外部二进制形式的函数名称。</target>
        </trans-unit>
        <trans-unit id="ec568fe6711779cbc4fe49c405863a46d77641d0" translate="yes" xml:space="preserve">
          <source>The name of a function that converts data from the type's internal form to its external textual form.</source>
          <target state="translated">将数据从类型的内部形式转换为外部文本形式的函数名称。</target>
        </trans-unit>
        <trans-unit id="a4232581838ec7343a99a8c7be95b2e49c198605" translate="yes" xml:space="preserve">
          <source>The name of a function that converts the internal form of the type's modifier(s) to external textual form.</source>
          <target state="translated">将类型修改器的内部形式转换为外部文本形式的函数名称。</target>
        </trans-unit>
        <trans-unit id="4ebc5121bc2fa18e076b2f1de0b2de537a76ba61" translate="yes" xml:space="preserve">
          <source>The name of a function that performs statistical analysis for the data type.</source>
          <target state="translated">对数据类型进行统计分析的函数名称。</target>
        </trans-unit>
        <trans-unit id="8693551fac54570d94fac46289d20bd3cbf6ee4e" translate="yes" xml:space="preserve">
          <source>The name of a function, procedure, or aggregate argument. Note that &lt;code&gt;ALTER EXTENSION&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the function's identity.</source>
          <target state="translated">函数，过程或聚合参数的名称。请注意， &lt;code&gt;ALTER EXTENSION&lt;/code&gt; 实际上并不关注参数名称，因为仅需要参数数据类型来确定函数的身份。</target>
        </trans-unit>
        <trans-unit id="6fe30dcb3f4583c58770f03da94374abd82c96ab" translate="yes" xml:space="preserve">
          <source>The name of a function, procedure, or aggregate argument. Note that &lt;code&gt;COMMENT&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the function's identity.</source>
          <target state="translated">函数，过程或聚合参数的名称。请注意， &lt;code&gt;COMMENT&lt;/code&gt; 实际上并没有对参数名称给予任何关注，因为仅需要参数数据类型来确定函数的身份。</target>
        </trans-unit>
        <trans-unit id="037ed7ab4666d9436acdd62556426330fa27de4d" translate="yes" xml:space="preserve">
          <source>The name of a function, procedure, or aggregate argument. Note that &lt;code&gt;SECURITY LABEL&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the function's identity.</source>
          <target state="translated">函数，过程或聚合参数的名称。请注意，由于只需要参数数据类型来确定函数的标识，因此 &lt;code&gt;SECURITY LABEL&lt;/code&gt; 实际上并不注意参数名称。</target>
        </trans-unit>
        <trans-unit id="85d26a05a8c2a48486d4d983a4308017ec19fa06" translate="yes" xml:space="preserve">
          <source>The name of a role whose objects will be dropped, and whose privileges will be revoked.</source>
          <target state="translated">角色的名称,其对象将被删除,其权限将被取消。</target>
        </trans-unit>
        <trans-unit id="2d651ee55d17fde141e789374afa64231439951d" translate="yes" xml:space="preserve">
          <source>The name of a role. The ownership of all the objects within the current database, and of all shared objects (databases, tablespaces), owned by this role will be reassigned to &lt;code&gt;new_role&lt;/code&gt;.</source>
          <target state="translated">角色名称。该角色拥有的当前数据库中所有对象以及所有共享对象（数据库，表空间）的所有权将重新分配给 &lt;code&gt;new_role&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a41f912a967bc6187a0ff565790395916fca2f2a" translate="yes" xml:space="preserve">
          <source>The name of a rule to create. This must be distinct from the name of any other rule for the same table. Multiple rules on the same table and same event type are applied in alphabetical name order.</source>
          <target state="translated">要创建的规则的名称。该名称必须与同一张表的任何其他规则的名称不同。同一表和同一事件类型上的多条规则按字母名称顺序应用。</target>
        </trans-unit>
        <trans-unit id="16dbd653daa2713c731e96ec7016300d7b0623c9" translate="yes" xml:space="preserve">
          <source>The name of a run-time parameter. Available parameters are documented in &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; and on the &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; reference page. In addition, there are a few parameters that can be shown but not set:</source>
          <target state="translated">运行时参数的名称。可用参数都记录在&lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;第19&lt;/a&gt;和上&lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt;参考页。此外，还有一些参数可以显示但不能设置：</target>
        </trans-unit>
        <trans-unit id="aee34bf395a3fa67b708559214834f0819e94a8b" translate="yes" xml:space="preserve">
          <source>The name of a run-time parameter. Available parameters are documented in &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; and on the &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; reference page. In addition, there are a few parameters that can be shown but not set:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdb5b09a2e8ba40ee029ef0bb0deb2b715d29f64" translate="yes" xml:space="preserve">
          <source>The name of a schema to be created. If this is omitted, the &lt;code&gt;user_name&lt;/code&gt; is used as the schema name. The name cannot begin with &lt;code&gt;pg_&lt;/code&gt;, as such names are reserved for system schemas.</source>
          <target state="translated">要创建的模式的名称。如果省略此参数，则将 &lt;code&gt;user_name&lt;/code&gt; 用作架构名称。该名称不能以 &lt;code&gt;pg_&lt;/code&gt; 开头，因为此类名称是为系统架构保留的。</target>
        </trans-unit>
        <trans-unit id="19552fb60b57524fdf3c4ba971f713deaf575934" translate="yes" xml:space="preserve">
          <source>The name of a schema.</source>
          <target state="translated">模式的名称。</target>
        </trans-unit>
        <trans-unit id="bec37b1bb0aae7199fe140e94c49fd869d890cc2" translate="yes" xml:space="preserve">
          <source>The name of a specific column to analyze. Defaults to all columns.</source>
          <target state="translated">要分析的特定列的名称。默认为所有列。</target>
        </trans-unit>
        <trans-unit id="f4dd69da6250801b1a99f96f4fc7a1fc3fc7a5ca" translate="yes" xml:space="preserve">
          <source>The name of a specific column to analyze. Defaults to all columns. If a column list is specified, &lt;code&gt;ANALYZE&lt;/code&gt; must also be specified.</source>
          <target state="translated">要分析的特定列的名称。默认为所有列。如果指定了列列表，则还必须指定 &lt;code&gt;ANALYZE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d277ce7dc1369544c960227202849bca34e3070" translate="yes" xml:space="preserve">
          <source>The name of a standby server for this purpose is the &lt;code&gt;application_name&lt;/code&gt; setting of the standby, as set in the standby's connection information. In case of a physical replication standby, this should be set in the &lt;code&gt;primary_conninfo&lt;/code&gt; setting; the default is the setting of &lt;a href=&quot;runtime-config-logging#GUC-CLUSTER-NAME&quot;&gt;cluster_name&lt;/a&gt; if set, else &lt;code&gt;walreceiver&lt;/code&gt;. For logical replication, this can be set in the connection information of the subscription, and it defaults to the subscription name. For other replication stream consumers, consult their documentation.</source>
          <target state="translated">为此目的，备用服务器的名称是备用服务器的 &lt;code&gt;application_name&lt;/code&gt; 设置，如备用服务器的连接信息中所设置。如果是物理复制备用数据库，则应在 &lt;code&gt;primary_conninfo&lt;/code&gt; 设置中进行设置。默认值是&lt;a href=&quot;runtime-config-logging#GUC-CLUSTER-NAME&quot;&gt;cluster_name&lt;/a&gt;的设置（如果已设置），否则是 &lt;code&gt;walreceiver&lt;/code&gt; 。对于逻辑复制，可以在订阅的连接信息中设置它，并且默认为订阅名称。对于其他复制流使用者，请查阅其文档。</target>
        </trans-unit>
        <trans-unit id="c8bcdb2c75dca6dff745c6b72d3eafa935add170" translate="yes" xml:space="preserve">
          <source>The name of a subscription to be dropped.</source>
          <target state="translated">要放弃的订阅名称。</target>
        </trans-unit>
        <trans-unit id="10c04b3f0b50c7a796c21e054204f49c5305809f" translate="yes" xml:space="preserve">
          <source>The name of a subscription whose properties are to be altered.</source>
          <target state="translated">属性将被更改的订阅的名称。</target>
        </trans-unit>
        <trans-unit id="a917fa888db788a84ebf308d993302ba69b3956f" translate="yes" xml:space="preserve">
          <source>The name of a table column to be covered by the computed statistics. At least two column names must be given; the order of the column names is insignificant.</source>
          <target state="translated">计算的统计数据所涵盖的表列名。必须至少提供两个列名;列名的顺序无关紧要。</target>
        </trans-unit>
        <trans-unit id="547022940eaa9d3307e6377842b21fffa3dea285" translate="yes" xml:space="preserve">
          <source>The name of a table storage parameter.</source>
          <target state="translated">表存储参数的名称。</target>
        </trans-unit>
        <trans-unit id="25f3d061a48202d36e2eddaaf0e7e422750642c9" translate="yes" xml:space="preserve">
          <source>The name of a tablespace to be created. The name cannot begin with &lt;code&gt;pg_&lt;/code&gt;, as such names are reserved for system tablespaces.</source>
          <target state="translated">要创建的表空间的名称。该名称不能以 &lt;code&gt;pg_&lt;/code&gt; 开头，因为此类名称是为系统表空间保留的。</target>
        </trans-unit>
        <trans-unit id="f526639651b0458136ca498c2f2f2ac4fbd6800d" translate="yes" xml:space="preserve">
          <source>The name of a tablespace.</source>
          <target state="translated">表空间的名称。</target>
        </trans-unit>
        <trans-unit id="3f86890bb22a9b09c6fb6202e966b0cb90e86399" translate="yes" xml:space="preserve">
          <source>The name of a template-specific option to be set for this dictionary.</source>
          <target state="translated">要为该字典设置的模板特定选项的名称。</target>
        </trans-unit>
        <trans-unit id="d2fc4bb5096ba459cde4afbb76fdac536da62aa5" translate="yes" xml:space="preserve">
          <source>The name of a text search dictionary to be consulted for the specified token type(s). If multiple dictionaries are listed, they are consulted in the specified order.</source>
          <target state="translated">要为指定的标记类型查询的文本搜索字典的名称,如果列出多个字典,则按指定顺序查询。如果列出多个字典,则按指定顺序查询。</target>
        </trans-unit>
        <trans-unit id="b2ade2843219f0c75eecbdfb9ad26e157949ac15" translate="yes" xml:space="preserve">
          <source>The name of a text search dictionary to be replaced in the mapping.</source>
          <target state="translated">在映射中要替换的文本搜索字典的名称。</target>
        </trans-unit>
        <trans-unit id="c2e4d9635ee5eae77abbb98d0d04f44a7382134a" translate="yes" xml:space="preserve">
          <source>The name of a text search dictionary to be substituted for &lt;code&gt;old_dictionary&lt;/code&gt;.</source>
          <target state="translated">替代 &lt;code&gt;old_dictionary&lt;/code&gt; 的文本搜索字典的名称。</target>
        </trans-unit>
        <trans-unit id="e536a7c03f29f8cbc17f3a583238f110ae4c9ca6" translate="yes" xml:space="preserve">
          <source>The name of a token type that is emitted by the configuration's parser.</source>
          <target state="translated">由配置解析器发出的令牌类型的名称。</target>
        </trans-unit>
        <trans-unit id="e42ab0f9b2f16ce7c6531f791e195b576f9b5e7b" translate="yes" xml:space="preserve">
          <source>The name of a variable used to filter events. This makes it possible to restrict the firing of the trigger to a subset of the cases in which it is supported. Currently the only supported &lt;code&gt;filter_variable&lt;/code&gt; is &lt;code&gt;TAG&lt;/code&gt;.</source>
          <target state="translated">用于过滤事件的变量的名称。这使得可以将触发器的触发限制为支持触发器的情况的子集。当前唯一支持的 &lt;code&gt;filter_variable&lt;/code&gt; 是 &lt;code&gt;TAG&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cbbf80f6f4c468a122711e341fba3efb95ed9b4e" translate="yes" xml:space="preserve">
          <source>The name of an argument.</source>
          <target state="translated">争论的名称。</target>
        </trans-unit>
        <trans-unit id="e982fa6e95b8aff320484711c377b6849476a259" translate="yes" xml:space="preserve">
          <source>The name of an argument. Note that &lt;code&gt;ALTER AGGREGATE&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the aggregate function's identity.</source>
          <target state="translated">参数的名称。请注意， &lt;code&gt;ALTER AGGREGATE&lt;/code&gt; 实际上并不关注参数名称，因为仅需要参数数据类型来确定聚合函数的标识。</target>
        </trans-unit>
        <trans-unit id="56b0baceffec189e51468368e1573f50c02b2801" translate="yes" xml:space="preserve">
          <source>The name of an argument. Note that &lt;code&gt;ALTER FUNCTION&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the function's identity.</source>
          <target state="translated">参数的名称。请注意， &lt;code&gt;ALTER FUNCTION&lt;/code&gt; 实际上并不关注参数名称，因为仅需要参数数据类型来确定函数的身份。</target>
        </trans-unit>
        <trans-unit id="da880762c1ed4640b76217347360561ae983a357" translate="yes" xml:space="preserve">
          <source>The name of an argument. Note that &lt;code&gt;ALTER PROCEDURE&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the procedure's identity.</source>
          <target state="translated">参数的名称。请注意， &lt;code&gt;ALTER PROCEDURE&lt;/code&gt; 实际上并不关注参数名称，因为仅需要参数数据类型来确定过程的身份。</target>
        </trans-unit>
        <trans-unit id="0681d59ee9000bab536592eb7b8ddac88b06215c" translate="yes" xml:space="preserve">
          <source>The name of an argument. Note that &lt;code&gt;DROP AGGREGATE&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the aggregate function's identity.</source>
          <target state="translated">参数的名称。请注意， &lt;code&gt;DROP AGGREGATE&lt;/code&gt; 实际上并不关注参数名称，因为仅需要参数数据类型来确定聚合函数的身份。</target>
        </trans-unit>
        <trans-unit id="5f97c790620d0347b2dc1f2b503ffe310415155c" translate="yes" xml:space="preserve">
          <source>The name of an argument. Note that &lt;code&gt;DROP FUNCTION&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the function's identity.</source>
          <target state="translated">参数的名称。注意，由于仅需要参数数据类型来确定函数的标识，因此 &lt;code&gt;DROP FUNCTION&lt;/code&gt; 实际上并没有对参数名称给予任何关注。</target>
        </trans-unit>
        <trans-unit id="75484c7635e6405e3d0e3238f7f514ab40e45aaa" translate="yes" xml:space="preserve">
          <source>The name of an argument. Note that &lt;code&gt;DROP PROCEDURE&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the procedure's identity.</source>
          <target state="translated">参数的名称。请注意， &lt;code&gt;DROP PROCEDURE&lt;/code&gt; 实际上并不关注参数名称，因为仅需要参数数据类型来确定过程的身份。</target>
        </trans-unit>
        <trans-unit id="6264b5b03c956e34b1a101cf23f2e7ebcfb44a8b" translate="yes" xml:space="preserve">
          <source>The name of an argument. Some languages (including SQL and PL/pgSQL) let you use the name in the function body. For other languages the name of an input argument is just extra documentation, so far as the function itself is concerned; but you can use input argument names when calling a function to improve readability (see &lt;a href=&quot;sql-syntax-calling-funcs&quot;&gt;Section 4.3&lt;/a&gt;). In any case, the name of an output argument is significant, because it defines the column name in the result row type. (If you omit the name for an output argument, the system will choose a default column name.)</source>
          <target state="translated">参数的名称。某些语言（包括SQL和PL / pgSQL）使您可以在函数主体中使用名称。对于其他语言，就功能本身而言，输入参数的名称只是额外的文档。但是您可以在调用函数以提高可读性时使用输入参数名称（请参见&lt;a href=&quot;sql-syntax-calling-funcs&quot;&gt;第4.3节&lt;/a&gt;）。在任何情况下，输出参数的名称都是有效的，因为它在结果行类型中定义了列名称。 （如果省略输出参数的名称，则系统将选择默认列名称。）</target>
        </trans-unit>
        <trans-unit id="375094d89a9e7c5813b8961536891f0759815217" translate="yes" xml:space="preserve">
          <source>The name of an argument. This is currently only useful for documentation purposes. If omitted, the argument has no name.</source>
          <target state="translated">一个参数的名称。目前,这只对文档有用。如果省略,则该参数没有名称。</target>
        </trans-unit>
        <trans-unit id="ed524d1ea7eb8aeebc2ae58ea9eeac500ae4de68" translate="yes" xml:space="preserve">
          <source>The name of an attribute (column) for the composite type.</source>
          <target state="translated">复合类型的属性(列)名称。</target>
        </trans-unit>
        <trans-unit id="6a17e927a8bc128615b789bf21656b4af0a59747" translate="yes" xml:space="preserve">
          <source>The name of an existing access method.</source>
          <target state="translated">现有访问方法的名称。</target>
        </trans-unit>
        <trans-unit id="ebcda1893633e936b520a2a0321ab231b1b0ba97" translate="yes" xml:space="preserve">
          <source>The name of an existing collation to be associated with a column of a composite type, or with a range type.</source>
          <target state="translated">要与复合类型的列或范围类型相关联的现有整理的名称。</target>
        </trans-unit>
        <trans-unit id="6a99a7164db5effbf0ea0eafd9c39dd9aa197443" translate="yes" xml:space="preserve">
          <source>The name of an existing collation to copy. The new collation will have the same properties as the existing one, but it will be an independent object.</source>
          <target state="translated">要复制的现有整理的名称。新的整理将具有与现有整理相同的属性,但它将是一个独立的对象。</target>
        </trans-unit>
        <trans-unit id="af62875da4376911af8fd6633488eb76e3df9aa2" translate="yes" xml:space="preserve">
          <source>The name of an existing data type that the new type will have the same representation as. The values of &lt;code&gt;internallength&lt;/code&gt;, &lt;code&gt;passedbyvalue&lt;/code&gt;, &lt;code&gt;alignment&lt;/code&gt;, and &lt;code&gt;storage&lt;/code&gt; are copied from that type, unless overridden by explicit specification elsewhere in this &lt;code&gt;CREATE TYPE&lt;/code&gt; command.</source>
          <target state="translated">新类型将具有相同表示形式的现有数据类型的名称。除非从此 &lt;code&gt;CREATE TYPE&lt;/code&gt; 命令的其他地方显式指定覆盖，否则将从该类型复制 &lt;code&gt;internallength&lt;/code&gt; ， &lt;code&gt;passedbyvalue&lt;/code&gt; ， &lt;code&gt;alignment&lt;/code&gt; 和 &lt;code&gt;storage&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="269f93ea4a18405eca9d42f3c25429fa59f4bc3d" translate="yes" xml:space="preserve">
          <source>The name of an existing data type to become a column of the composite type.</source>
          <target state="translated">现有数据类型的名称,成为复合类型的一列。</target>
        </trans-unit>
        <trans-unit id="9a63f99fdd0bce011ca8d049908cd4539b298e7c" translate="yes" xml:space="preserve">
          <source>The name of an existing foreign server to use for the foreign table. For details on defining a server, see &lt;a href=&quot;sql-createserver&quot;&gt;CREATE SERVER&lt;/a&gt;.</source>
          <target state="translated">用于外部表的现有外部服务器的名称。有关定义服务器的详细信息，请参见&lt;a href=&quot;sql-createserver&quot;&gt;CREATE SERVER&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f2454ed01e6d27ce51d6d152286d9f4044a0971f" translate="yes" xml:space="preserve">
          <source>The name of an existing foreign-data wrapper.</source>
          <target state="translated">现有的外来数据封装器的名称。</target>
        </trans-unit>
        <trans-unit id="215bb96ed8aefedc59bc2785aaa4809857f9f3b1" translate="yes" xml:space="preserve">
          <source>The name of an existing index.</source>
          <target state="translated">现有索引的名称。</target>
        </trans-unit>
        <trans-unit id="dcfd6d7a1b6a134c08f28bb84b429370f63f9bf9" translate="yes" xml:space="preserve">
          <source>The name of an existing policy to alter.</source>
          <target state="translated">要更改的现有政策的名称。</target>
        </trans-unit>
        <trans-unit id="d3e43edda0ed2c669ea64ea4de1cacab37227192" translate="yes" xml:space="preserve">
          <source>The name of an existing procedural language. For backward compatibility, the name can be enclosed by single quotes.</source>
          <target state="translated">现有程序语言的名称。为了向后兼容,该名称可以用单引号括起来。</target>
        </trans-unit>
        <trans-unit id="dbc811803ec9f6996f00764f5d9b3a696bbe0492" translate="yes" xml:space="preserve">
          <source>The name of an existing publication whose definition is to be altered.</source>
          <target state="translated">现有出版物的名称,其定义将被修改;</target>
        </trans-unit>
        <trans-unit id="e43f43145062802662e910809c0dbf5106a36151" translate="yes" xml:space="preserve">
          <source>The name of an existing publication.</source>
          <target state="translated">现有出版物的名称;</target>
        </trans-unit>
        <trans-unit id="51d243f6e89c7e39326aaa5f0f4dbaf017f84cd3" translate="yes" xml:space="preserve">
          <source>The name of an existing role of which the current role is a member. If &lt;code&gt;FOR ROLE&lt;/code&gt; is omitted, the current role is assumed.</source>
          <target state="translated">当前角色是成员的现有角色的名称。如果忽略 &lt;code&gt;FOR ROLE&lt;/code&gt; ，则假定为当前角色。</target>
        </trans-unit>
        <trans-unit id="55490c4e62932d1546a037c62cdff84638b0e3d3" translate="yes" xml:space="preserve">
          <source>The name of an existing role to grant or revoke privileges for. This parameter, and all the other parameters in &lt;code&gt;abbreviated_grant_or_revoke&lt;/code&gt;, act as described under &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; or &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt;, except that one is setting permissions for a whole class of objects rather than specific named objects.</source>
          <target state="translated">要为其授予或撤销特权的现有角色的名称。这个参数，并在所有其他参数 &lt;code&gt;abbreviated_grant_or_revoke&lt;/code&gt; ，作用下所述&lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt;或&lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt;，不同的是一个被设定的权限一整类的对象，而不是特定的命名的对象。</target>
        </trans-unit>
        <trans-unit id="c635ecbb1c53d1706cdab235bd6da7bb6c713113" translate="yes" xml:space="preserve">
          <source>The name of an existing rule to alter.</source>
          <target state="translated">要更改的现有规则的名称。</target>
        </trans-unit>
        <trans-unit id="313ea254effb62079628babb9fa1cbd9eaa5bbb0" translate="yes" xml:space="preserve">
          <source>The name of an existing schema.</source>
          <target state="translated">现有模式的名称。</target>
        </trans-unit>
        <trans-unit id="5f4188f167a8cf646d3b7406994faa33188bb313" translate="yes" xml:space="preserve">
          <source>The name of an existing schema. If specified, the default privileges are altered for objects later created in that schema. If &lt;code&gt;IN SCHEMA&lt;/code&gt; is omitted, the global default privileges are altered. &lt;code&gt;IN SCHEMA&lt;/code&gt; is not allowed when setting privileges for schemas, since schemas can't be nested.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc48699243fdc0b302f46f2ff91dbd816b03aa4b" translate="yes" xml:space="preserve">
          <source>The name of an existing schema. If specified, the default privileges are altered for objects later created in that schema. If &lt;code&gt;IN SCHEMA&lt;/code&gt; is omitted, the global default privileges are altered. &lt;code&gt;IN SCHEMA&lt;/code&gt; is not allowed when using &lt;code&gt;ON SCHEMAS&lt;/code&gt; as schemas can't be nested.</source>
          <target state="translated">现有模式的名称。如果指定，将更改以后在该架构中创建的对象的默认特权。如果省略 &lt;code&gt;IN SCHEMA&lt;/code&gt; ，则更改全局默认特权。使用 &lt;code&gt;ON SCHEMAS&lt;/code&gt; 时不允许使用 &lt;code&gt;IN SCHEMA&lt;/code&gt; ,因为无法嵌套架构。</target>
        </trans-unit>
        <trans-unit id="02ea513b553c81e6e8bfffc28bfc183407ce6f92" translate="yes" xml:space="preserve">
          <source>The name of an existing server for which the user mapping is to be created.</source>
          <target state="translated">要创建用户映射的现有服务器的名称。</target>
        </trans-unit>
        <trans-unit id="94ab6bc9007ffe24527bb571f8caf6972fd6e32c" translate="yes" xml:space="preserve">
          <source>The name of an existing server.</source>
          <target state="translated">现有服务器的名称。</target>
        </trans-unit>
        <trans-unit id="7b99635b20ef9c6fbf704b3d5683df0c76ea50a5" translate="yes" xml:space="preserve">
          <source>The name of an existing tablespace.</source>
          <target state="translated">现有表空间的名称。</target>
        </trans-unit>
        <trans-unit id="1fba9536f8e094817879340972f3fc186e59ac3a" translate="yes" xml:space="preserve">
          <source>The name of an existing text search configuration to copy.</source>
          <target state="translated">要复制的现有文本搜索配置的名称。</target>
        </trans-unit>
        <trans-unit id="e62d3905f77c5380a51ef346837f8bb973da087a" translate="yes" xml:space="preserve">
          <source>The name of an existing trigger to alter.</source>
          <target state="translated">要更改的触发器的名称。</target>
        </trans-unit>
        <trans-unit id="39eaed243c343dcf7cbdeda1eb27256bd699e984" translate="yes" xml:space="preserve">
          <source>The name of an existing user that is mapped to foreign server. &lt;code&gt;CURRENT_USER&lt;/code&gt; and &lt;code&gt;USER&lt;/code&gt; match the name of the current user. When &lt;code&gt;PUBLIC&lt;/code&gt; is specified, a so-called public mapping is created that is used when no user-specific mapping is applicable.</source>
          <target state="translated">映射到外部服务器的现有用户的名称。 &lt;code&gt;CURRENT_USER&lt;/code&gt; 和 &lt;code&gt;USER&lt;/code&gt; 与当前用户的名称匹配。当指定 &lt;code&gt;PUBLIC&lt;/code&gt; 时，将创建一个所谓的公共映射，当没有特定于用户的映射适用时，将使用该映射。</target>
        </trans-unit>
        <trans-unit id="7ff3e30c52fed6a21d64c778f1c3cb5bfde69e2e" translate="yes" xml:space="preserve">
          <source>The name of an index-method-specific storage parameter.</source>
          <target state="translated">索引方法专用存储参数的名称。</target>
        </trans-unit>
        <trans-unit id="391b7b7e4f5957c20764197abfbac06a778f9581" translate="yes" xml:space="preserve">
          <source>The name of an index-method-specific storage parameter. See &lt;a href=&quot;sql-createindex#SQL-CREATEINDEX-STORAGE-PARAMETERS&quot;&gt;Index Storage Parameters&lt;/a&gt; below for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="094d120f87047ccaf9df626ee5c7800b9676897f" translate="yes" xml:space="preserve">
          <source>The name of an index-method-specific storage parameter. See &lt;a href=&quot;sql-createindex#SQL-CREATEINDEX-STORAGE-PARAMETERS&quot;&gt;Index Storage Parameters&lt;/a&gt; for details.</source>
          <target state="translated">特定于索引方法的存储参数的名称。有关详细信息，请参见&lt;a href=&quot;sql-createindex#SQL-CREATEINDEX-STORAGE-PARAMETERS&quot;&gt;索引存储参数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b4f0f37a4747ead833ac927d954e2f698dfd533d" translate="yes" xml:space="preserve">
          <source>The name of an index.</source>
          <target state="translated">索引的名称。</target>
        </trans-unit>
        <trans-unit id="905bf1ebfe51e20690887bb37e5649f46c622ebf" translate="yes" xml:space="preserve">
          <source>The name of an installed extension.</source>
          <target state="translated">安装的分机名称。</target>
        </trans-unit>
        <trans-unit id="31791bd4a497bca0b376ada0235a5c621eadda59" translate="yes" xml:space="preserve">
          <source>The name of an object to be added to or removed from the extension. Names of tables, aggregates, domains, foreign tables, functions, operators, operator classes, operator families, procedures, routines, sequences, text search objects, types, and views can be schema-qualified.</source>
          <target state="translated">要添加到扩展中或从扩展中删除的对象的名称。表、集合、域、外表、函数、运算符、运算符类、运算符族、过程、例程、序列、文本搜索对象、类型和视图的名称可以用模式限定。</target>
        </trans-unit>
        <trans-unit id="649c7c5351f25263eb73a851a860d7f29c995641" translate="yes" xml:space="preserve">
          <source>The name of an open cursor to close.</source>
          <target state="translated">打开的光标的名称,要关闭。</target>
        </trans-unit>
        <trans-unit id="cd55222991d683c14fbae3099b3d272c1928bd18" translate="yes" xml:space="preserve">
          <source>The name of an operator class parameter. See below for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b92d299708f5e6b56970b9d25ff76f34c8756f5" translate="yes" xml:space="preserve">
          <source>The name of an operator class. See below for details.</source>
          <target state="translated">操作员类的名称。详见下文。</target>
        </trans-unit>
        <trans-unit id="4bf28d916074af135f4ae230a1fccbd417f00476" translate="yes" xml:space="preserve">
          <source>The name of an output column in the &lt;code&gt;RETURNS TABLE&lt;/code&gt; syntax. This is effectively another way of declaring a named &lt;code&gt;OUT&lt;/code&gt; parameter, except that &lt;code&gt;RETURNS TABLE&lt;/code&gt; also implies &lt;code&gt;RETURNS SETOF&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RETURNS TABLE&lt;/code&gt; 语法中的输出列的名称。实际上，这是声明命名 &lt;code&gt;OUT&lt;/code&gt; 参数的另一种方法，除了 &lt;code&gt;RETURNS TABLE&lt;/code&gt; 还暗含 &lt;code&gt;RETURNS SETOF&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7860b7ca240f288c9e09edb9a6f18857751787c5" translate="yes" xml:space="preserve">
          <source>The name of next WAL segment file should be larger than any WAL segment file name currently existing in the directory &lt;code&gt;pg_wal&lt;/code&gt; under the data directory. These names are also in hexadecimal and have three parts. The first part is the &amp;ldquo;timeline ID&amp;rdquo; and should usually be kept the same. For example, if &lt;code&gt;00000001000000320000004A&lt;/code&gt; is the largest entry in &lt;code&gt;pg_wal&lt;/code&gt;, use &lt;code&gt;-l 00000001000000320000004B&lt;/code&gt; or higher.</source>
          <target state="translated">下一个WAL段文件的名称应大于数据目录下 &lt;code&gt;pg_wal&lt;/code&gt; 目录中当前存在的任何WAL段文件名。这些名称也以十六进制表示，分为三个部分。第一部分是&amp;ldquo;时间轴ID&amp;rdquo;，通常应保持不变。例如，如果 &lt;code&gt;00000001000000320000004A&lt;/code&gt; 是 &lt;code&gt;pg_wal&lt;/code&gt; 中最大的条目，请使用 &lt;code&gt;-l 00000001000000320000004B&lt;/code&gt; 或更高版本。</target>
        </trans-unit>
        <trans-unit id="d8e7a2287904ed813d9d1d342dd594453e6a492a" translate="yes" xml:space="preserve">
          <source>The name of the access method to be created.</source>
          <target state="translated">要创建的访问方法的名称。</target>
        </trans-unit>
        <trans-unit id="a1d2d753926a3554219bc61e5340b3472157868a" translate="yes" xml:space="preserve">
          <source>The name of the attribute to add, alter, or drop.</source>
          <target state="translated">要添加、更改或删除的属性名称。</target>
        </trans-unit>
        <trans-unit id="5c7d389a37d0c9ede9dd1bea0952aff86a55c92e" translate="yes" xml:space="preserve">
          <source>The name of the canonicalization function for the range type.</source>
          <target state="translated">范围类型的规范化函数的名称。</target>
        </trans-unit>
        <trans-unit id="243c7e9e7dd348f6643caec550e3f500eb8cc280" translate="yes" xml:space="preserve">
          <source>The name of the collation to use for the index. By default, the index uses the collation declared for the column to be indexed or the result collation of the expression to be indexed. Indexes with non-default collations can be useful for queries that involve expressions using non-default collations.</source>
          <target state="translated">要为索引使用的整理名称。默认情况下,索引使用为要索引的列声明的整理方式或要索引的表达式的结果整理方式。对于涉及使用非默认整理方式的表达式的查询来说,使用非默认整理方式的索引是很有用的。</target>
        </trans-unit>
        <trans-unit id="77f1c321d574cf562cfe00eca4e768698060a618" translate="yes" xml:space="preserve">
          <source>The name of the collation. The collation name can be schema-qualified.</source>
          <target state="translated">整理的名称。整理名称可以是模式限定的。</target>
        </trans-unit>
        <trans-unit id="ceb886814d1ec273ae0613d250c7095ff800d469" translate="yes" xml:space="preserve">
          <source>The name of the collation. The collation name can be schema-qualified. If it is not, the collation is defined in the current schema. The collation name must be unique within that schema. (The system catalogs can contain collations with the same name for other encodings, but these are ignored if the database encoding does not match.)</source>
          <target state="translated">整理的名称。整理名称可以是模式限定的。如果不是,则在当前的模式中定义整理。整理名称在该模式中必须是唯一的。(系统目录可以包含对其他编码具有相同名称的整理,但如果数据库编码不匹配,这些整理将被忽略。)</target>
        </trans-unit>
        <trans-unit id="9f63d4696a4bbfab6f19c7c4c3231039f6a920b8" translate="yes" xml:space="preserve">
          <source>The name of the conversion. The conversion name can be schema-qualified.</source>
          <target state="translated">转换的名称。转换名称可以是模式限定的。</target>
        </trans-unit>
        <trans-unit id="0a0e15e0eec7998677fce35d40af5b0838f2cb6f" translate="yes" xml:space="preserve">
          <source>The name of the conversion. The conversion name can be schema-qualified. If it is not, the conversion is defined in the current schema. The conversion name must be unique within a schema.</source>
          <target state="translated">转换的名称。转换名称可以是模式限定的。如果不是,则在当前模式中定义转换。转换名称在一个模式中必须是唯一的。</target>
        </trans-unit>
        <trans-unit id="c9574a7a1218329dadec3b5ae9047230517d66aa" translate="yes" xml:space="preserve">
          <source>The name of the current database.</source>
          <target state="translated">当前数据库的名称。</target>
        </trans-unit>
        <trans-unit id="1d7349ab2501bed854162775079bf683be5a7fac" translate="yes" xml:space="preserve">
          <source>The name of the cursor</source>
          <target state="translated">光标的名称</target>
        </trans-unit>
        <trans-unit id="b6d5b083913d1c8495981451aeb22d6a26cea7b8" translate="yes" xml:space="preserve">
          <source>The name of the cursor to be created.</source>
          <target state="translated">要创建的光标的名称。</target>
        </trans-unit>
        <trans-unit id="88e407c8ddef33e57e58fe4ab21cafbf53e15168" translate="yes" xml:space="preserve">
          <source>The name of the cursor to use in a &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; condition. The row to be deleted is the one most recently fetched from this cursor. The cursor must be a non-grouping query on the &lt;code&gt;DELETE&lt;/code&gt;'s target table. Note that &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; cannot be specified together with a Boolean condition. See &lt;a href=&quot;sql-declare&quot;&gt;DECLARE&lt;/a&gt; for more information about using cursors with &lt;code&gt;WHERE CURRENT OF&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; 条件中使用的游标名称。要删除的行是此游标最近获取的行。游标必须是对 &lt;code&gt;DELETE&lt;/code&gt; 的目标表的非分组查询。注意，不能将 &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; 与布尔条件一起指定。有关在 &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; 中使用游标的更多信息，请参见&lt;a href=&quot;sql-declare&quot;&gt;DECLARE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="38020942de5ae8771a5e3d0b598b6d0ab023caec" translate="yes" xml:space="preserve">
          <source>The name of the cursor to use in a &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; condition. The row to be updated is the one most recently fetched from this cursor. The cursor must be a non-grouping query on the &lt;code&gt;UPDATE&lt;/code&gt;'s target table. Note that &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; cannot be specified together with a Boolean condition. See &lt;a href=&quot;sql-declare&quot;&gt;DECLARE&lt;/a&gt; for more information about using cursors with &lt;code&gt;WHERE CURRENT OF&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; 条件中使用的游标名称。要更新的行是此游标最近获取的行。游标必须是 &lt;code&gt;UPDATE&lt;/code&gt; 的目标表上的非分组查询。注意，不能将 &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; 与布尔条件一起指定。有关在 &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; 中使用游标的更多信息，请参见&lt;a href=&quot;sql-declare&quot;&gt;DECLARE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a37403f5a4aea39da3b7fe089d21ee355979a3e1" translate="yes" xml:space="preserve">
          <source>The name of the data type of the transform.</source>
          <target state="translated">变换的数据类型名称。</target>
        </trans-unit>
        <trans-unit id="af7361a3be8ca4eab2c0f2265411cfd60f5af420" translate="yes" xml:space="preserve">
          <source>The name of the database the configuration variable should be set in.</source>
          <target state="translated">配置变量应设置的数据库名称。</target>
        </trans-unit>
        <trans-unit id="84b00afcd962f475515c1915126400e90b5a9818" translate="yes" xml:space="preserve">
          <source>The name of the database this slot is associated with, or null. Only logical slots have an associated database.</source>
          <target state="translated">该槽所关联的数据库名称,或为空。只有逻辑槽才有关联的数据库。</target>
        </trans-unit>
        <trans-unit id="2a89c928e3a93a0e913b45ef5c9ea96a08977f60" translate="yes" xml:space="preserve">
          <source>The name of the database to remove.</source>
          <target state="translated">要删除的数据库名称;</target>
        </trans-unit>
        <trans-unit id="0fd3bf3f6aa3e86ff6150d84d8e17149c266ae35" translate="yes" xml:space="preserve">
          <source>The name of the database whose attributes are to be altered.</source>
          <target state="translated">要更改属性的数据库名称。</target>
        </trans-unit>
        <trans-unit id="0944e5dfd14965f192e2a8ef7a09d183046338d3" translate="yes" xml:space="preserve">
          <source>The name of the database you are currently connected to. This is set every time you connect to a database (including program start-up), but can be changed or unset.</source>
          <target state="translated">你当前连接的数据库名称。每次连接到数据库时(包括程序启动)都会设置这个名称,但可以更改或取消设置。</target>
        </trans-unit>
        <trans-unit id="11232ebb2f1cf69c5f3c6cd470c6a4d13d479f8e" translate="yes" xml:space="preserve">
          <source>The name of the element type that the range type will represent ranges of.</source>
          <target state="translated">范围类型将代表范围的元素类型的名称。</target>
        </trans-unit>
        <trans-unit id="2c439c06e3cc89c7e2b7094efdc072f8eaa5f405" translate="yes" xml:space="preserve">
          <source>The name of the end function for the parser.</source>
          <target state="translated">解析器的结束函数的名称。</target>
        </trans-unit>
        <trans-unit id="4682e028a8481b8dc70802bb5909c69f9733e336" translate="yes" xml:space="preserve">
          <source>The name of the event that triggers a call to the given function. See &lt;a href=&quot;https://www.postgresql.org/docs/12/event-trigger-definition.html&quot;&gt;Section 39.1&lt;/a&gt; for more information on event names.</source>
          <target state="translated">触发调用给定函数的事件的名称。有关事件名称的更多信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/event-trigger-definition.html&quot;&gt;39.1节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="48923e41b7df203b0e79b78492f062da75beedf7" translate="yes" xml:space="preserve">
          <source>The name of the event that triggers a call to the given function. See &lt;a href=&quot;https://www.postgresql.org/docs/13/event-trigger-definition.html&quot;&gt;Section 39.1&lt;/a&gt; for more information on event names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28c26a8cf1a6172d4db73edd5254e5a34f8a5967" translate="yes" xml:space="preserve">
          <source>The name of the event trigger to remove.</source>
          <target state="translated">要删除的事件触发器的名称。</target>
        </trans-unit>
        <trans-unit id="850574c01fb5268b0342a8b6bb42720569d55e9d" translate="yes" xml:space="preserve">
          <source>The name of the existing operator family to add this operator class to. If not specified, a family named the same as the operator class is used (creating it, if it doesn't already exist).</source>
          <target state="translated">要添加该操作类的现有操作族的名称。如果没有指定,则使用与运算符类相同的族名(如果不存在,则创建它)。</target>
        </trans-unit>
        <trans-unit id="e1cc11f5fc0531b3a520c5755578268d661fb876" translate="yes" xml:space="preserve">
          <source>The name of the extension that the function is to depend on.</source>
          <target state="translated">函数要依赖的扩展名。</target>
        </trans-unit>
        <trans-unit id="6af23b7fd50d16bb7de156bad92b5bd09f67edbf" translate="yes" xml:space="preserve">
          <source>The name of the extension that the index is to depend on.</source>
          <target state="translated">索引要依赖的扩展名。</target>
        </trans-unit>
        <trans-unit id="0076c726a59acb3194ce3e4e3b9519a8daeff897" translate="yes" xml:space="preserve">
          <source>The name of the extension that the materialized view is to depend on (or no longer dependent on, if &lt;code&gt;NO&lt;/code&gt; is specified). A materialized view that's marked as dependent on an extension is automatically dropped when the extension is dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc831ae12120e6fd5fdd21a20fd1a1e7bd573e67" translate="yes" xml:space="preserve">
          <source>The name of the extension that the materialized view is to depend on.</source>
          <target state="translated">物化视图要依赖的扩展名。</target>
        </trans-unit>
        <trans-unit id="4f55051df080e15b2a3119833fb2677544739012" translate="yes" xml:space="preserve">
          <source>The name of the extension that the procedure is to depend on.</source>
          <target state="translated">程序要依赖的扩展名。</target>
        </trans-unit>
        <trans-unit id="eb5ffaeae34b0a924ba5f2135444604598a2a8e1" translate="yes" xml:space="preserve">
          <source>The name of the extension that the trigger is to depend on (or no longer dependent on, if &lt;code&gt;NO&lt;/code&gt; is specified). A trigger that's marked as dependent on an extension is automatically dropped when the extension is dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a35573e050ab73e125502a3b5564abce7fd88f9" translate="yes" xml:space="preserve">
          <source>The name of the extension that the trigger is to depend on.</source>
          <target state="translated">触发器要依赖的扩展名。</target>
        </trans-unit>
        <trans-unit id="88e9cf7b26c10377ec9b042f69222e5d8682e8ed" translate="yes" xml:space="preserve">
          <source>The name of the extension to be installed. PostgreSQL will create the extension using details from the file &lt;code&gt;SHAREDIR/extension/&lt;/code&gt;&lt;code&gt;extension_name&lt;/code&gt;&lt;code&gt;.control&lt;/code&gt;.</source>
          <target state="translated">要安装的扩展名。PostgreSQL将创建一个使用细节从文件扩展名 &lt;code&gt;SHAREDIR/extension/&lt;/code&gt; &lt;code&gt;extension_name&lt;/code&gt; &lt;code&gt;.control&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6fa04f440c0a0fbd9ef5c8562fd34285144f5e9" translate="yes" xml:space="preserve">
          <source>The name of the final function called to compute the aggregate's result after all input rows have been traversed, when using moving-aggregate mode. This works the same as &lt;code&gt;ffunc&lt;/code&gt;, except that its first argument's type is &lt;code&gt;mstate_data_type&lt;/code&gt; and extra dummy arguments are specified by writing &lt;code&gt;MFINALFUNC_EXTRA&lt;/code&gt;. The aggregate result type determined by &lt;code&gt;mffunc&lt;/code&gt; or &lt;code&gt;mstate_data_type&lt;/code&gt; must match that determined by the aggregate's regular implementation.</source>
          <target state="translated">使用移动聚合模式时，在遍历所有输入行之后将用来计算聚合结果的最终函数的名称。除了第一个参数的类型是 &lt;code&gt;mstate_data_type&lt;/code&gt; ,并且通过写入 &lt;code&gt;MFINALFUNC_EXTRA&lt;/code&gt; 来指定额外的伪参数外，此功能与 &lt;code&gt;ffunc&lt;/code&gt; 相同。由 &lt;code&gt;mffunc&lt;/code&gt; 或 &lt;code&gt;mstate_data_type&lt;/code&gt; 确定的聚合结果类型必须与由聚合的常规实现确定的结果类型匹配。</target>
        </trans-unit>
        <trans-unit id="f5f06809f2c728bd2159e0f8d844d66eca27a10c" translate="yes" xml:space="preserve">
          <source>The name of the final function called to compute the aggregate's result after all input rows have been traversed. For a normal aggregate, this function must take a single argument of type &lt;code&gt;state_data_type&lt;/code&gt;. The return data type of the aggregate is defined as the return type of this function. If &lt;code&gt;ffunc&lt;/code&gt; is not specified, then the ending state value is used as the aggregate's result, and the return type is &lt;code&gt;state_data_type&lt;/code&gt;.</source>
          <target state="translated">在遍历所有输入行之后，用来计算聚合结果的最终函数的名称。对于普通聚合，此函数必须采用 &lt;code&gt;state_data_type&lt;/code&gt; 类型的单个参数。聚集的返回数据类型定义为该函数的返回类型。如果未指定 &lt;code&gt;ffunc&lt;/code&gt; ，则将结束状态值用作聚合的结果，返回类型为 &lt;code&gt;state_data_type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="72c35b2edf9735176f859431671ff1f17e5d197c" translate="yes" xml:space="preserve">
          <source>The name of the foreign server to be created.</source>
          <target state="translated">要创建的外国服务器的名称。</target>
        </trans-unit>
        <trans-unit id="c3a096f51b1b0afdadcf653b248a2d3f34aa4744" translate="yes" xml:space="preserve">
          <source>The name of the foreign-data wrapper that manages the server.</source>
          <target state="translated">管理服务器的对外数据封装器的名称。</target>
        </trans-unit>
        <trans-unit id="d54745f11f4179244c18fb9a79fb68702588d241" translate="yes" xml:space="preserve">
          <source>The name of the foreign-data wrapper to be created.</source>
          <target state="translated">要创建的外国数据包装器的名称。</target>
        </trans-unit>
        <trans-unit id="1fdbb3b7aa9f05df80cfbaca84874bb5ff3faf75" translate="yes" xml:space="preserve">
          <source>The name of the forward state transition function to be called for each input row in moving-aggregate mode. This is exactly like the regular transition function, except that its first argument and result are of type &lt;code&gt;mstate_data_type&lt;/code&gt;, which might be different from &lt;code&gt;state_data_type&lt;/code&gt;.</source>
          <target state="translated">在移动聚合模式下为每个输入行调用的前向状态转换函数的名称。这与常规转换函数完全相同，不同之 &lt;code&gt;mstate_data_type&lt;/code&gt; 于其第一个参数和结果的类型为mstate_data_type，可能与 &lt;code&gt;state_data_type&lt;/code&gt; 不同。</target>
        </trans-unit>
        <trans-unit id="644a4d91bed7658870a145ab3141d930ef90e912" translate="yes" xml:space="preserve">
          <source>The name of the function for converting the type from the SQL environment to the language. It must take one argument of type &lt;code&gt;internal&lt;/code&gt; and return type &lt;code&gt;internal&lt;/code&gt;. The actual argument will be of the type for the transform, and the function should be coded as if it were. (But it is not allowed to declare an SQL-level function returning &lt;code&gt;internal&lt;/code&gt; without at least one argument of type &lt;code&gt;internal&lt;/code&gt;.) The actual return value will be something specific to the language implementation. If no argument list is specified, the function name must be unique in its schema.</source>
          <target state="translated">用于将类型从SQL环境转换为语言的函数的名称。它必须接受一个类型为 &lt;code&gt;internal&lt;/code&gt; 的参数，并返回类型 &lt;code&gt;internal&lt;/code&gt; 。实际参数将是转换的类型，并且应将函数编码为好像是这样。 （但不允许声明一个SQL级函数，而 &lt;code&gt;internal&lt;/code&gt; 函数必须至少具有一个类型为 &lt;code&gt;internal&lt;/code&gt; 的参数。）实际的返回值将特定于该语言实现。如果未指定参数列表，则函数名称在其架构中必须唯一。</target>
        </trans-unit>
        <trans-unit id="72f3b32f063bc50605b229238d27a5869c6aa7b9" translate="yes" xml:space="preserve">
          <source>The name of the function for converting the type from the language to the SQL environment. It must take one argument of type &lt;code&gt;internal&lt;/code&gt; and return the type that is the type for the transform. The actual argument value will be something specific to the language implementation. If no argument list is specified, the function name must be unique in its schema.</source>
          <target state="translated">用于将类型从语言转换为SQL环境的函数的名称。它必须接受一个类型为 &lt;code&gt;internal&lt;/code&gt; 的参数，并返回作为转换类型的类型。实际参数值将是特定于语言实现的值。如果未指定参数列表，则函数名称在其架构中必须唯一。</target>
        </trans-unit>
        <trans-unit id="67cb877b3731a337b10795d0e7186566d6a3d1e1" translate="yes" xml:space="preserve">
          <source>The name of the get-next-token function for the parser.</source>
          <target state="translated">解析器的get-next-token函数的名称。</target>
        </trans-unit>
        <trans-unit id="6d1ebf156ba07f5a77467c8ec4ff708f33b3fc16" translate="yes" xml:space="preserve">
          <source>The name of the group (role) to modify.</source>
          <target state="translated">要修改的组(角色)名称。</target>
        </trans-unit>
        <trans-unit id="2ed53b580ba0bc8625e75a9560c3a6e88d077a4d" translate="yes" xml:space="preserve">
          <source>The name of the headline function for the parser (a function that summarizes a set of tokens).</source>
          <target state="translated">解析器的标题函数名称(总结一组标记的函数)。</target>
        </trans-unit>
        <trans-unit id="a3a747073ce359aa3857b433256c5b13312b5a04" translate="yes" xml:space="preserve">
          <source>The name of the index access method the operator class is for.</source>
          <target state="translated">操作员类的索引访问方法的名称。</target>
        </trans-unit>
        <trans-unit id="ed18a236c732efe90dba559278f7adbf5db0ca9c" translate="yes" xml:space="preserve">
          <source>The name of the index access method the operator family is for.</source>
          <target state="translated">操作符族的索引访问方法的名称。</target>
        </trans-unit>
        <trans-unit id="c45cc6bfca0d231f36cbda7b1370cd41ed1d67b6" translate="yes" xml:space="preserve">
          <source>The name of the index method this operator class is for.</source>
          <target state="translated">这个运算符类的索引方法的名称。</target>
        </trans-unit>
        <trans-unit id="615794124cec123ffa046fc334d0b7cb274ccdc2" translate="yes" xml:space="preserve">
          <source>The name of the index method this operator family is for.</source>
          <target state="translated">这个操作族的索引方法的名称。</target>
        </trans-unit>
        <trans-unit id="4bb90538453113f1fb57ae8f2d37c35f322febf6" translate="yes" xml:space="preserve">
          <source>The name of the index method to be used. Choices are &lt;code&gt;btree&lt;/code&gt;, &lt;code&gt;hash&lt;/code&gt;, &lt;code&gt;gist&lt;/code&gt;, &lt;code&gt;spgist&lt;/code&gt;, &lt;code&gt;gin&lt;/code&gt;, and &lt;code&gt;brin&lt;/code&gt;. The default method is &lt;code&gt;btree&lt;/code&gt;.</source>
          <target state="translated">要使用的索引方法的名称。选择为 &lt;code&gt;btree&lt;/code&gt; ， &lt;code&gt;hash&lt;/code&gt; ， &lt;code&gt;gist&lt;/code&gt; ， &lt;code&gt;spgist&lt;/code&gt; ， &lt;code&gt;gin&lt;/code&gt; 和 &lt;code&gt;brin&lt;/code&gt; 。默认方法是 &lt;code&gt;btree&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb830e2432e53c927391aeee88f93bb4667bcae4" translate="yes" xml:space="preserve">
          <source>The name of the index to be created. No schema name can be included here; the index is always created in the same schema as its parent table. If the name is omitted, PostgreSQL chooses a suitable name based on the parent table's name and the indexed column name(s).</source>
          <target state="translated">要创建的索引的名称。这里不能包含模式名,索引总是在与父表相同的模式中创建的,如果省略了名称,PostgreSQL会根据父表的名称和索引列名选择合适的名称。如果省略了名称,PostgreSQL会根据父表的名称和索引的列名选择一个合适的名称。</target>
        </trans-unit>
        <trans-unit id="a4663fb986b280170b92707494282c81c2899c4f" translate="yes" xml:space="preserve">
          <source>The name of the init function for the template.</source>
          <target state="translated">模板的初始函数名称。</target>
        </trans-unit>
        <trans-unit id="f00fd5139904e6694b429785636163e14a782210" translate="yes" xml:space="preserve">
          <source>The name of the inverse state transition function to be used in moving-aggregate mode. This function has the same argument and result types as &lt;code&gt;msfunc&lt;/code&gt;, but it is used to remove a value from the current aggregate state, rather than add a value to it. The inverse transition function must have the same strictness attribute as the forward state transition function.</source>
          <target state="translated">在移动聚合模式下使用的逆状态转换函数的名称。此函数的参数和结果类型与 &lt;code&gt;msfunc&lt;/code&gt; 相同，但用于从当前聚合状态中删除值，而不是向其添加值。逆转换函数必须具有与前向状态转换函数相同的严格性属性。</target>
        </trans-unit>
        <trans-unit id="3d95c2fd2534c7b2ce3a1746cb2c27650d29fdc4" translate="yes" xml:space="preserve">
          <source>The name of the language of the transform.</source>
          <target state="translated">变换的语言名称。</target>
        </trans-unit>
        <trans-unit id="26a3e76d4aff5006209caa326a5bf1517ad79006" translate="yes" xml:space="preserve">
          <source>The name of the language that the function is implemented in. It can be &lt;code&gt;sql&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;internal&lt;/code&gt;, or the name of a user-defined procedural language, e.g. &lt;code&gt;plpgsql&lt;/code&gt;. Enclosing the name in single quotes is deprecated and requires matching case.</source>
          <target state="translated">函数所使用的语言的名称。它可以是 &lt;code&gt;sql&lt;/code&gt; ， &lt;code&gt;c&lt;/code&gt; ， &lt;code&gt;internal&lt;/code&gt; 或用户定义的过程语言的名称，例如 &lt;code&gt;plpgsql&lt;/code&gt; 。不建议将名称用单引号引起来，并且需要大小写匹配。</target>
        </trans-unit>
        <trans-unit id="c42d1caf7aebd169681e8521779ebec6bdd5b337" translate="yes" xml:space="preserve">
          <source>The name of the language that the function is implemented in. It can be &lt;code&gt;sql&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;internal&lt;/code&gt;, or the name of a user-defined procedural language, e.g., &lt;code&gt;plpgsql&lt;/code&gt;. Enclosing the name in single quotes is deprecated and requires matching case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b5713bc5c339abbdacc15961df416377c21c0e3" translate="yes" xml:space="preserve">
          <source>The name of the language that the procedure is implemented in. It can be &lt;code&gt;sql&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;internal&lt;/code&gt;, or the name of a user-defined procedural language, e.g. &lt;code&gt;plpgsql&lt;/code&gt;. Enclosing the name in single quotes is deprecated and requires matching case.</source>
          <target state="translated">实现过程的语言的名称。它可以是 &lt;code&gt;sql&lt;/code&gt; ， &lt;code&gt;c&lt;/code&gt; ， &lt;code&gt;internal&lt;/code&gt; 或用户定义的过程语言的名称，例如 &lt;code&gt;plpgsql&lt;/code&gt; 。不建议将名称用单引号引起来，并且需要大小写匹配。</target>
        </trans-unit>
        <trans-unit id="6442a7baa7c6ad1af9dfd2863b84c1d799ed57dc" translate="yes" xml:space="preserve">
          <source>The name of the language that the procedure is implemented in. It can be &lt;code&gt;sql&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;internal&lt;/code&gt;, or the name of a user-defined procedural language, e.g., &lt;code&gt;plpgsql&lt;/code&gt;. Enclosing the name in single quotes is deprecated and requires matching case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86f56142098dd6b61f4dc395fb22e1f6084da31b" translate="yes" xml:space="preserve">
          <source>The name of the lexize function for the template.</source>
          <target state="translated">模板的 lexize 函数的名称。</target>
        </trans-unit>
        <trans-unit id="78bf3c88f1577390b2b7639c878108066bdde80d" translate="yes" xml:space="preserve">
          <source>The name of the lextypes function for the parser (a function that returns information about the set of token types it produces).</source>
          <target state="translated">解析器的 lextypes 函数名称(一个返回它所产生的标记类型集信息的函数)。</target>
        </trans-unit>
        <trans-unit id="99c5d2489b4f3028ca831f4f9b0e7e15704ecdca" translate="yes" xml:space="preserve">
          <source>The name of the new procedural language. The name must be unique among the languages in the database.</source>
          <target state="translated">新程序语言的名称。该名称在数据库中的语言中必须是唯一的。</target>
        </trans-unit>
        <trans-unit id="bf36b4ea435ecc1c1aaf6ed21ca9df2c4c0596b3" translate="yes" xml:space="preserve">
          <source>The name of the new publication.</source>
          <target state="translated">新出版物的名称。</target>
        </trans-unit>
        <trans-unit id="dc580686d337370d500fabd6d8d4233f2a645d1a" translate="yes" xml:space="preserve">
          <source>The name of the new role.</source>
          <target state="translated">新角色的名称。</target>
        </trans-unit>
        <trans-unit id="9deb527e5d18a4a607e93b3c59b44924e3848af5" translate="yes" xml:space="preserve">
          <source>The name of the new subscription.</source>
          <target state="translated">新订阅的名称。</target>
        </trans-unit>
        <trans-unit id="84ca9243f0b08a6130478bf4d0fddd3954c72484" translate="yes" xml:space="preserve">
          <source>The name of the object to be commented. Names of tables, aggregates, collations, conversions, domains, foreign tables, functions, indexes, operators, operator classes, operator families, procedures, routines, sequences, statistics, text search objects, types, and views can be schema-qualified. When commenting on a column, &lt;code&gt;relation_name&lt;/code&gt; must refer to a table, view, composite type, or foreign table.</source>
          <target state="translated">要注释的对象的名称。表，集合，排序规则，转换，域，外部表，函数，索引，运算符，运算符类，运算符族，过程，例程，序列，统计信息，文本搜索对象，类型和视图的名称可以通过模式限定。在对列进行注释时， &lt;code&gt;relation_name&lt;/code&gt; 必须引用表，视图，组合类型或外部表。</target>
        </trans-unit>
        <trans-unit id="0ad7f76d8fb02cb1c406ee55180e013d61f5632a" translate="yes" xml:space="preserve">
          <source>The name of the object to be labeled. Names of tables, aggregates, domains, foreign tables, functions, procedures, routines, sequences, types, and views can be schema-qualified.</source>
          <target state="translated">要标注的对象名称。表、集合、域、外表、函数、过程、例程、序列、类型和视图的名称可以用模式限定。</target>
        </trans-unit>
        <trans-unit id="d73d0a54fa511d10e86523f09232c08b9e6d5db1" translate="yes" xml:space="preserve">
          <source>The name of the object to which this label applies, as text.</source>
          <target state="translated">该标签所适用的对象名称,为文本。</target>
        </trans-unit>
        <trans-unit id="42c399b3a656097491cae7892f14f5784153a41c" translate="yes" xml:space="preserve">
          <source>The name of the operator class to be created. The name can be schema-qualified.</source>
          <target state="translated">要创建的运算符类的名称。该名称可以是模式限定的。</target>
        </trans-unit>
        <trans-unit id="3c9b852f5483728a82051e673011a9205c74fef8" translate="yes" xml:space="preserve">
          <source>The name of the operator family to be created. The name can be schema-qualified.</source>
          <target state="translated">要创建的操作员族的名称。该名称可以是模式限定的。</target>
        </trans-unit>
        <trans-unit id="aa3dee6563b812e00d9ce856987f40752c4ba957" translate="yes" xml:space="preserve">
          <source>The name of the operator to be defined. See above for allowable characters. The name can be schema-qualified, for example &lt;code&gt;CREATE OPERATOR myschema.+ (...)&lt;/code&gt;. If not, then the operator is created in the current schema. Two operators in the same schema can have the same name if they operate on different data types. This is called &lt;em&gt;overloading&lt;/em&gt;.</source>
          <target state="translated">要定义的运算符的名称。有关允许的字符，请参见上文。该名称可以是模式限定的，例如 &lt;code&gt;CREATE OPERATOR myschema.+ (...)&lt;/code&gt; 。如果不是，则在当前架构中创建运算符。如果同一模式中的两个运算符对不同的数据类型进行运算，则它们可以具有相同的名称。这称为&lt;em&gt;超载&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="89042cdb5d6d0a5c95dd63eb06cd01f0a55a975c" translate="yes" xml:space="preserve">
          <source>The name of the policy</source>
          <target state="translated">政策名称</target>
        </trans-unit>
        <trans-unit id="b729bdecc076d261a6f2aa96bf01271915d37a2a" translate="yes" xml:space="preserve">
          <source>The name of the policy to be created. This must be distinct from the name of any other policy for the table.</source>
          <target state="translated">要创建的策略的名称。必须与表的任何其他策略名称不同。</target>
        </trans-unit>
        <trans-unit id="e268e30430f81e017c4a875eccb62cdf9b012871" translate="yes" xml:space="preserve">
          <source>The name of the policy to drop.</source>
          <target state="translated">要放弃的政策名称。</target>
        </trans-unit>
        <trans-unit id="e49a87c2d393345ad07affbe76b904f4fe401c81" translate="yes" xml:space="preserve">
          <source>The name of the prepared statement to deallocate.</source>
          <target state="translated">准备好的报表名称,以便进行分配。</target>
        </trans-unit>
        <trans-unit id="96c3920c719f442187d159c204dd3612ea686ae5" translate="yes" xml:space="preserve">
          <source>The name of the prepared statement to execute.</source>
          <target state="translated">准备执行的语句名称。</target>
        </trans-unit>
        <trans-unit id="655476f7c7223e1c8c574d3f749ecc5208b3f1a9" translate="yes" xml:space="preserve">
          <source>The name of the procedural language the code is written in. If omitted, the default is &lt;code&gt;plpgsql&lt;/code&gt;.</source>
          <target state="translated">编写代码所用的过程语言的名称。如果省略，则默认值为 &lt;code&gt;plpgsql&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="03668e7125b4437e3ffadf3e4e590be0e7efc658" translate="yes" xml:space="preserve">
          <source>The name of the provider with which this label is to be associated. The named provider must be loaded and must consent to the proposed labeling operation. If exactly one provider is loaded, the provider name may be omitted for brevity.</source>
          <target state="translated">与该标签相关联的供应商的名称。被命名的提供者必须被加载,并且必须同意拟议的标签操作。如果只加载了一个提供者,为了简洁起见,提供者名称可以省略。</target>
        </trans-unit>
        <trans-unit id="4982a7a5e8149f1e3c35391b81b9f53d77cb4f02" translate="yes" xml:space="preserve">
          <source>The name of the role that will be made the new owner of the affected objects.</source>
          <target state="translated">将成为受影响对象的新所有者的角色名称。</target>
        </trans-unit>
        <trans-unit id="d91a150acbfef5a5067b673c038cee51df98a783" translate="yes" xml:space="preserve">
          <source>The name of the role to remove.</source>
          <target state="translated">要删除的角色名称。</target>
        </trans-unit>
        <trans-unit id="f2c76cbbaae9ad7b16ccf9e7e0922d982cd4547e" translate="yes" xml:space="preserve">
          <source>The name of the role whose attributes are to be altered.</source>
          <target state="translated">属性要改变的角色名称。</target>
        </trans-unit>
        <trans-unit id="a2cca4e02caca1d1f07a5556d0d3f7be637865d7" translate="yes" xml:space="preserve">
          <source>The name of the rule to drop.</source>
          <target state="translated">要放弃的规则名称。</target>
        </trans-unit>
        <trans-unit id="fc701ae189d9b3d813db243f4da26ea0b33711ef" translate="yes" xml:space="preserve">
          <source>The name of the savepoint to destroy.</source>
          <target state="translated">要销毁的保存点的名称。</target>
        </trans-unit>
        <trans-unit id="4816861b05e3da72c531801eafbb94d541e0e94f" translate="yes" xml:space="preserve">
          <source>The name of the schema in which to install the extension's objects, given that the extension allows its contents to be relocated. The named schema must already exist. If not specified, and the extension's control file does not specify a schema either, the current default object creation schema is used.</source>
          <target state="translated">安装扩展对象的模式名称,因为扩展允许其内容被重新定位。命名的模式必须已经存在。如果没有指定,并且扩展的控制文件也没有指定模式,则使用当前默认的对象创建模式。</target>
        </trans-unit>
        <trans-unit id="42eda784d25f0da5728fd9204f655f7fcdcb985b" translate="yes" xml:space="preserve">
          <source>The name of the schema to which the table will be moved.</source>
          <target state="translated">表将被移动到的模式的名称。</target>
        </trans-unit>
        <trans-unit id="baf4061d3be604bdc194c1f14606449bf4b0f2d6" translate="yes" xml:space="preserve">
          <source>The name of the shared memory allocation. NULL for unused memory and &lt;code&gt;&amp;lt;anonymous&amp;gt;&lt;/code&gt; for anonymous allocations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac04d5a0b8ecbdd03c9da31af0a4b7d10ec89b66" translate="yes" xml:space="preserve">
          <source>The name of the source data type of the cast.</source>
          <target state="translated">投放的源数据类型的名称。</target>
        </trans-unit>
        <trans-unit id="2294ddf1df955220bbac238988facccf0c6a0592" translate="yes" xml:space="preserve">
          <source>The name of the specific index, table, or database to be reindexed. Index and table names can be schema-qualified. Presently, &lt;code&gt;REINDEX DATABASE&lt;/code&gt; and &lt;code&gt;REINDEX SYSTEM&lt;/code&gt; can only reindex the current database, so their parameter must match the current database's name.</source>
          <target state="translated">要重新建立索引的特定索引，表或数据库的名称。索引和表名可以是模式限定的。当前， &lt;code&gt;REINDEX DATABASE&lt;/code&gt; 和 &lt;code&gt;REINDEX SYSTEM&lt;/code&gt; 只能重新索引当前数据库，因此它们的参数必须与当前数据库的名称匹配。</target>
        </trans-unit>
        <trans-unit id="1371535897b887a5106cddf678bff07e0c5f80a9" translate="yes" xml:space="preserve">
          <source>The name of the start function for the parser.</source>
          <target state="translated">解析器的启动函数名称。</target>
        </trans-unit>
        <trans-unit id="015f67e7eaa6c3588c5e9952c547a024ac10153d" translate="yes" xml:space="preserve">
          <source>The name of the state transition function to be called for each input row. For a normal &lt;code&gt;N&lt;/code&gt;-argument aggregate function, the &lt;code&gt;sfunc&lt;/code&gt; must take &lt;code&gt;N&lt;/code&gt;+1 arguments, the first being of type &lt;code&gt;state_data_type&lt;/code&gt; and the rest matching the declared input data type(s) of the aggregate. The function must return a value of type &lt;code&gt;state_data_type&lt;/code&gt;. This function takes the current state value and the current input data value(s), and returns the next state value.</source>
          <target state="translated">每个输入行要调用的状态转换函数的名称。对于普通的 &lt;code&gt;N&lt;/code&gt; 参数聚合函数， &lt;code&gt;sfunc&lt;/code&gt; 必须采用 &lt;code&gt;N&lt;/code&gt; +1个参数，第一个参数为 &lt;code&gt;state_data_type&lt;/code&gt; 类型，其余参数与聚合的声明输入数据类型匹配。该函数必须返回 &lt;code&gt;state_data_type&lt;/code&gt; 类型的值。该函数获取当前状态值和当前输入数据值，然后返回下一个状态值。</target>
        </trans-unit>
        <trans-unit id="98dfcac96a79ab8d2309606485d5d666ca4e2daa" translate="yes" xml:space="preserve">
          <source>The name of the table and column to update</source>
          <target state="translated">要更新的表和列的名称</target>
        </trans-unit>
        <trans-unit id="86a9a516ee162e483fd6f8fbe8dac2f83cc35633" translate="yes" xml:space="preserve">
          <source>The name of the table on which this trigger acts.</source>
          <target state="translated">触发器作用的表的名称。</target>
        </trans-unit>
        <trans-unit id="df029c5f6289a56399018c193966351757b130e4" translate="yes" xml:space="preserve">
          <source>The name of the table to attach as a new partition or to detach from this table.</source>
          <target state="translated">要作为新分区附加的表的名称,或要从该表上分离的表的名称。</target>
        </trans-unit>
        <trans-unit id="910f7a94c4794ba13cd804620ae6f535c8697348" translate="yes" xml:space="preserve">
          <source>The name of the tablespace that will be associated with the new database, or &lt;code&gt;DEFAULT&lt;/code&gt; to use the template database's tablespace. This tablespace will be the default tablespace used for objects created in this database. See &lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt; for more information.</source>
          <target state="translated">将与新数据库关联的表空间的名称，或者为 &lt;code&gt;DEFAULT&lt;/code&gt; 以使用模板数据库的表空间。该表空间将是用于在此数据库中创建的对象的默认表空间。有关更多信息，请参见&lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2adc75b40aac253d8d3fd83763a5999e795d523d" translate="yes" xml:space="preserve">
          <source>The name of the tablespace to which the table will be moved.</source>
          <target state="translated">表将被移动到的表空间的名称。</target>
        </trans-unit>
        <trans-unit id="ed5faf3ddd011b5c76e052594331ee12feb17ee5" translate="yes" xml:space="preserve">
          <source>The name of the target data type of the cast.</source>
          <target state="translated">投放的目标数据类型的名称。</target>
        </trans-unit>
        <trans-unit id="f5d196df67f8715141577ca0dfa1d0026e0d7817" translate="yes" xml:space="preserve">
          <source>The name of the template from which to create the new database, or &lt;code&gt;DEFAULT&lt;/code&gt; to use the default template (&lt;code&gt;template1&lt;/code&gt;).</source>
          <target state="translated">从中创建新数据库的模板的名称，或者 &lt;code&gt;DEFAULT&lt;/code&gt; 使用默认模板的模板（ &lt;code&gt;template1&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="38cd3261917960f8e539d80ae266a773e2ca894a" translate="yes" xml:space="preserve">
          <source>The name of the text search configuration to be created. The name can be schema-qualified.</source>
          <target state="translated">要创建的文本搜索配置的名称。该名称可以是模式限定的。</target>
        </trans-unit>
        <trans-unit id="7715676ee8a2df410a7d9b5d6a75ed5f4bbb933b" translate="yes" xml:space="preserve">
          <source>The name of the text search dictionary to be created. The name can be schema-qualified.</source>
          <target state="translated">要创建的文本搜索字典的名称。该名称可以是模式限定的。</target>
        </trans-unit>
        <trans-unit id="08a42806dfcb8f125b19f0057086523042a36ad3" translate="yes" xml:space="preserve">
          <source>The name of the text search parser to be created. The name can be schema-qualified.</source>
          <target state="translated">要创建的文本搜索解析器的名称。该名称可以是模式限定的。</target>
        </trans-unit>
        <trans-unit id="24ce45ce2160196c06edff30b966c8ad75ac789f" translate="yes" xml:space="preserve">
          <source>The name of the text search parser to use for this configuration.</source>
          <target state="translated">此配置要使用的文本搜索解析器的名称。</target>
        </trans-unit>
        <trans-unit id="84cb2dc1f232e52ae9a92c0bb4186a0059e53aa7" translate="yes" xml:space="preserve">
          <source>The name of the text search template that will define the basic behavior of this dictionary.</source>
          <target state="translated">文本搜索模板的名称,它将定义这个字典的基本行为。</target>
        </trans-unit>
        <trans-unit id="1584a807877a42990d603d823d759977f3901ddc" translate="yes" xml:space="preserve">
          <source>The name of the text search template to be created. The name can be schema-qualified.</source>
          <target state="translated">要创建的文本搜索模板的名称。该名称可以是模式限定的。</target>
        </trans-unit>
        <trans-unit id="d0987d8df78c216eed09875fd5ebec69f27a40ed" translate="yes" xml:space="preserve">
          <source>The name of the trigger to remove.</source>
          <target state="translated">要删除的触发器的名称。</target>
        </trans-unit>
        <trans-unit id="afd08ce0efd0e1d1a3450afd63d3251269afcb61" translate="yes" xml:space="preserve">
          <source>The name of the user who will own the tablespace. If omitted, defaults to the user executing the command. Only superusers can create tablespaces, but they can assign ownership of tablespaces to non-superusers.</source>
          <target state="translated">拥有表空间的用户名称。如果省略,则默认为执行该命令的用户。只有超级用户可以创建表空间,但他们可以将表空间的所有权分配给非超级用户。</target>
        </trans-unit>
        <trans-unit id="1c1d8e2ccb4524cb644f6e39612aee840de9a90d" translate="yes" xml:space="preserve">
          <source>The name or IP addresses of the RADIUS servers to connect to. This parameter is required.</source>
          <target state="translated">要连接的RADIUS服务器的名称或IP地址。这个参数是必须的。</target>
        </trans-unit>
        <trans-unit id="21389222271889edde6e7b3bd3c9fdd837bca670" translate="yes" xml:space="preserve">
          <source>The name parameter will be MD5-hashed, so the cleartext cannot be derived from the generated UUID. The generation of UUIDs by this method has no random or environment-dependent element and is therefore reproducible.</source>
          <target state="translated">名称参数将被MD5哈希,所以不能从生成的UUID中得出明文。这种方法生成的UUID没有随机的或与环境相关的元素,因此是可重复的。</target>
        </trans-unit>
        <trans-unit id="ee74a07e23c9dea72df5a27b777fb65b403c0393" translate="yes" xml:space="preserve">
          <source>The name stems from the fact that this table should not be readable by the public since it contains passwords. &lt;a href=&quot;view-pg-user&quot;&gt;&lt;code&gt;pg_user&lt;/code&gt;&lt;/a&gt; is a publicly readable view on &lt;code&gt;pg_shadow&lt;/code&gt; that blanks out the password field.</source>
          <target state="translated">该名称源于以下事实：该表包含密码，因此不应该被公众读取。&lt;a href=&quot;view-pg-user&quot;&gt; &lt;code&gt;pg_user&lt;/code&gt; &lt;/a&gt;是 &lt;code&gt;pg_shadow&lt;/code&gt; 上的公共可读视图，该视图空白了password字段。</target>
        </trans-unit>
        <trans-unit id="5d07e8a1b061fb282161f125ed44c357f0d17c75" translate="yes" xml:space="preserve">
          <source>The name to give the new trigger. This must be distinct from the name of any other trigger for the same table. The name cannot be schema-qualified &amp;mdash; the trigger inherits the schema of its table. For a constraint trigger, this is also the name to use when modifying the trigger's behavior using &lt;code&gt;SET CONSTRAINTS&lt;/code&gt;.</source>
          <target state="translated">赋予新触发器的名称。该名称必须与同一表的任何其他触发器的名称不同。名称不能为架构限定的-触发器继承其表的架构。对于约束触发器，这也是使用 &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; 修改触发器的行为时要使用的名称。</target>
        </trans-unit>
        <trans-unit id="7b32b1efee504dab33e5254f802082429e271272" translate="yes" xml:space="preserve">
          <source>The name to give the new trigger. This name must be unique within the database.</source>
          <target state="translated">新触发器的名称。这个名字在数据库中必须是唯一的。</target>
        </trans-unit>
        <trans-unit id="11fed6031dec77608082f3fa5b2080d3486c35aa" translate="yes" xml:space="preserve">
          <source>The name to give to the new savepoint.</source>
          <target state="translated">新保存点的名称。</target>
        </trans-unit>
        <trans-unit id="cf734951b344df7b211da487949af76d60fe726b" translate="yes" xml:space="preserve">
          <source>The names of opclasses and opfamilies are only unique within an access method, so they are represented by &lt;code&gt;access_method_name&lt;/code&gt;&lt;code&gt;/&lt;/code&gt;&lt;code&gt;object_name&lt;/code&gt;.</source>
          <target state="translated">opclass和opfamily的名称仅在访问方法中是唯一的，因此它们由 &lt;code&gt;access_method_name&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; &lt;code&gt;object_name&lt;/code&gt; 表示。</target>
        </trans-unit>
        <trans-unit id="d60acc58684395b40a907774a02224d52b1340e7" translate="yes" xml:space="preserve">
          <source>The naming of output columns here is different from that done in the &lt;code&gt;FROM&lt;/code&gt; clause (see &lt;a href=&quot;queries-table-expressions#QUERIES-TABLE-ALIASES&quot;&gt;Section 7.2.1.2&lt;/a&gt;). It is possible to rename the same column twice, but the name assigned in the select list is the one that will be passed on.</source>
          <target state="translated">输出列的命名与 &lt;code&gt;FROM&lt;/code&gt; 子句中的命名不同（请参见&lt;a href=&quot;queries-table-expressions#QUERIES-TABLE-ALIASES&quot;&gt;7.2.1.2节&lt;/a&gt;）。可以重命名同一列两次，但是在选择列表中分配的名称是将要传递的名称。</target>
        </trans-unit>
        <trans-unit id="8c0fc2cb480be9bb9c51a4bc9a223616db655fd1" translate="yes" xml:space="preserve">
          <source>The negator of this operator.</source>
          <target state="translated">这个运算符的否定者。</target>
        </trans-unit>
        <trans-unit id="c48796461ad5a772c7e7652201b09a6a57e675ec" translate="yes" xml:space="preserve">
          <source>The new column is initially filled with whatever default value is given (null if you don't specify a &lt;code&gt;DEFAULT&lt;/code&gt; clause).</source>
          <target state="translated">最初，新列将填充给定的默认值（如果未指定 &lt;code&gt;DEFAULT&lt;/code&gt; 子句，则为null ）。</target>
        </trans-unit>
        <trans-unit id="99a5a709438ce00d416364163ad8901072e9ceb4" translate="yes" xml:space="preserve">
          <source>The new comment, written as a string literal; or &lt;code&gt;NULL&lt;/code&gt; to drop the comment.</source>
          <target state="translated">新注释，以字符串文字形式表示；或 &lt;code&gt;NULL&lt;/code&gt; 以删除注释。</target>
        </trans-unit>
        <trans-unit id="91d67a443bb1c7292a967c48bc783941c67a9238" translate="yes" xml:space="preserve">
          <source>The new connection can re-use connection parameters from the previous connection; not only database name, user, host, and port, but other settings such as &lt;code&gt;sslmode&lt;/code&gt;. By default, parameters are re-used in the positional syntax, but not when a &lt;code&gt;conninfo&lt;/code&gt; string is given. Passing a first argument of &lt;code&gt;-reuse-previous=on&lt;/code&gt; or &lt;code&gt;-reuse-previous=off&lt;/code&gt; overrides that default. If parameters are re-used, then any parameter not explicitly specified as a positional parameter or in the &lt;code&gt;conninfo&lt;/code&gt; string is taken from the existing connection's parameters. An exception is that if the &lt;code&gt;host&lt;/code&gt; setting is changed from its previous value using the positional syntax, any &lt;code&gt;hostaddr&lt;/code&gt; setting present in the existing connection's parameters is dropped. When the command neither specifies nor reuses a particular parameter, the libpq default is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="510132e01b735c3f8d5397d2880131961e5b0f83" translate="yes" xml:space="preserve">
          <source>The new contents of the query buffer are then re-parsed according to the normal rules of psql, treating the whole buffer as a single line. Any complete queries are immediately executed; that is, if the query buffer contains or ends with a semicolon, everything up to that point is executed and removed from the query buffer. Whatever remains in the query buffer is redisplayed. Type semicolon or &lt;code&gt;\g&lt;/code&gt; to send it, or &lt;code&gt;\r&lt;/code&gt; to cancel it by clearing the query buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0eef4b2f503cdd8ca575c4d5c2db5edd06b1406" translate="yes" xml:space="preserve">
          <source>The new contents of the query buffer are then re-parsed according to the normal rules of psql, treating the whole buffer as a single line. Any complete queries are immediately executed; that is, if the query buffer contains or ends with a semicolon, everything up to that point is executed. Whatever remains will wait in the query buffer; type semicolon or &lt;code&gt;\g&lt;/code&gt; to send it, or &lt;code&gt;\r&lt;/code&gt; to cancel it by clearing the query buffer. Treating the buffer as a single line primarily affects meta-commands: whatever is in the buffer after a meta-command will be taken as argument(s) to the meta-command, even if it spans multiple lines. (Thus you cannot make meta-command-using scripts this way. Use &lt;code&gt;\i&lt;/code&gt; for that.)</source>
          <target state="translated">然后根据psql的常规规则重新解析查询缓冲区的新内容，将整个缓冲区视为一行。任何完整的查询都会立即执行；也就是说，如果查询缓冲区包含分号或以分号结尾，则执行该操作。剩下的将在查询缓冲区中等待；键入分号或 &lt;code&gt;\g&lt;/code&gt; 发送它，或键入 &lt;code&gt;\r&lt;/code&gt; 通过清除查询缓冲区来取消它。将缓冲区视为单行主要影响元命令：元命令后缓冲区中的内容将被视为元命令的参数，即使它跨越多行也是如此。 （因此，您不能以这种方式制作使用元命令的脚本。为此，请使用 &lt;code&gt;\i&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="8c2269882cf52ae9f068a61edc3b778c3a536ff9" translate="yes" xml:space="preserve">
          <source>The new declaration of the tables would look like this:</source>
          <target state="translated">新的表格声明是这样的。</target>
        </trans-unit>
        <trans-unit id="abb08cd78d70403e2ed01ba829b0b0e107ad79e1" translate="yes" xml:space="preserve">
          <source>The new default tablespace of the database.</source>
          <target state="translated">数据库的新默认表空间。</target>
        </trans-unit>
        <trans-unit id="bd696aa29e06c8bdaa37006c64334315b20f98b5" translate="yes" xml:space="preserve">
          <source>The new name for the constraint.</source>
          <target state="translated">该约束的新名称。</target>
        </trans-unit>
        <trans-unit id="1897f67b69c5b7376acb8d806a5382da72697a70" translate="yes" xml:space="preserve">
          <source>The new name for the domain.</source>
          <target state="translated">域的新名称。</target>
        </trans-unit>
        <trans-unit id="212f3ea5ee1a7012ae1ea00ecf4feddc77a325c7" translate="yes" xml:space="preserve">
          <source>The new name for the foreign server.</source>
          <target state="translated">国外服务器的新名称。</target>
        </trans-unit>
        <trans-unit id="10044e9774ec8f7e4eeef4126404d9a4c8740bba" translate="yes" xml:space="preserve">
          <source>The new name for the foreign-data wrapper.</source>
          <target state="translated">外国数据包装器的新名称。</target>
        </trans-unit>
        <trans-unit id="c11d926987759462d0f175b4415bf3358d9ff337" translate="yes" xml:space="preserve">
          <source>The new name for the index.</source>
          <target state="translated">索引的新名称。</target>
        </trans-unit>
        <trans-unit id="33305417939d3b3756d6c5255331fe9d857743c1" translate="yes" xml:space="preserve">
          <source>The new name for the materialized view.</source>
          <target state="translated">物化视图的新名称。</target>
        </trans-unit>
        <trans-unit id="d0bd51a33ddf1dfa219e2e91d0e8c933e6563371" translate="yes" xml:space="preserve">
          <source>The new name for the policy.</source>
          <target state="translated">政策的新名称。</target>
        </trans-unit>
        <trans-unit id="20931af42c3c5e46457e70a88b633cec676d6b34" translate="yes" xml:space="preserve">
          <source>The new name for the publication.</source>
          <target state="translated">该出版物的新名称。</target>
        </trans-unit>
        <trans-unit id="afd5b43d5185c06c93949d1324710b679e0f98bd" translate="yes" xml:space="preserve">
          <source>The new name for the rule.</source>
          <target state="translated">该规则的新名称。</target>
        </trans-unit>
        <trans-unit id="b48d77b2ef95f7c457090bcbbe943d0c70311b15" translate="yes" xml:space="preserve">
          <source>The new name for the sequence.</source>
          <target state="translated">序列的新名称。</target>
        </trans-unit>
        <trans-unit id="fc2f67f3244cee265dae6b633cc864544be564aa" translate="yes" xml:space="preserve">
          <source>The new name for the statistics object.</source>
          <target state="translated">统计对象的新名称。</target>
        </trans-unit>
        <trans-unit id="5e567bc00743ec90ea48cd87ca4d4d39aaaf2a0e" translate="yes" xml:space="preserve">
          <source>The new name for the subscription.</source>
          <target state="translated">订阅的新名称。</target>
        </trans-unit>
        <trans-unit id="bb15ea9a2978ce58ebb2c54bd4908c64b61e3ec5" translate="yes" xml:space="preserve">
          <source>The new name for the trigger.</source>
          <target state="translated">触发器的新名称。</target>
        </trans-unit>
        <trans-unit id="db155d6348c19b7d3227f389aca4111ed1c5bd26" translate="yes" xml:space="preserve">
          <source>The new name for the type.</source>
          <target state="translated">该类型的新名称。</target>
        </trans-unit>
        <trans-unit id="c523989c2e7068afb2501bed469e5428f5fdb7a8" translate="yes" xml:space="preserve">
          <source>The new name for the view.</source>
          <target state="translated">视图的新名称。</target>
        </trans-unit>
        <trans-unit id="f2b9a6bf2f60ce509d60ec6a402dbd4fb867b9c2" translate="yes" xml:space="preserve">
          <source>The new name of the aggregate function.</source>
          <target state="translated">聚合函数的新名称。</target>
        </trans-unit>
        <trans-unit id="aedc4948fc467788ca8aa2ca7751c93796b91571" translate="yes" xml:space="preserve">
          <source>The new name of the attribute to be renamed.</source>
          <target state="translated">要重命名的属性的新名称。</target>
        </trans-unit>
        <trans-unit id="e113491ed22e052f8e080471ba08c58dedb8ea64" translate="yes" xml:space="preserve">
          <source>The new name of the collation.</source>
          <target state="translated">整理的新名称。</target>
        </trans-unit>
        <trans-unit id="4c4b7b49d6b58b2034ea06105277cd50556d40cb" translate="yes" xml:space="preserve">
          <source>The new name of the conversion.</source>
          <target state="translated">改造的新名称。</target>
        </trans-unit>
        <trans-unit id="7bd49806ce97a6cf0ae2db0f7447c28e5ce8134f" translate="yes" xml:space="preserve">
          <source>The new name of the database.</source>
          <target state="translated">数据库的新名称。</target>
        </trans-unit>
        <trans-unit id="75a4aa01c626eb3410b405c18307300931670062" translate="yes" xml:space="preserve">
          <source>The new name of the event trigger.</source>
          <target state="translated">事件触发器的新名称。</target>
        </trans-unit>
        <trans-unit id="e4d75585a773a6cebff31b74551567f8918ab64f" translate="yes" xml:space="preserve">
          <source>The new name of the function.</source>
          <target state="translated">该函数的新名称。</target>
        </trans-unit>
        <trans-unit id="2911d96c910b5a17b53eadc422fecbb845a71e4b" translate="yes" xml:space="preserve">
          <source>The new name of the group.</source>
          <target state="translated">集团的新名称。</target>
        </trans-unit>
        <trans-unit id="01ed3bb6171bf404a649ad2b2a5598d4f2218b1d" translate="yes" xml:space="preserve">
          <source>The new name of the language</source>
          <target state="translated">语文的新名称</target>
        </trans-unit>
        <trans-unit id="5629a006f70e9712f7f3f90081ef5ec794958fe9" translate="yes" xml:space="preserve">
          <source>The new name of the operator class.</source>
          <target state="translated">操作员类的新名称。</target>
        </trans-unit>
        <trans-unit id="cac8082223d146caa1279e011dcbd9499e966dea" translate="yes" xml:space="preserve">
          <source>The new name of the operator family.</source>
          <target state="translated">运营商家族的新名称。</target>
        </trans-unit>
        <trans-unit id="b633cb5bdc25233c7a8bdbb49f3cdbe73d120c26" translate="yes" xml:space="preserve">
          <source>The new name of the procedure.</source>
          <target state="translated">程序的新名称。</target>
        </trans-unit>
        <trans-unit id="3a9dddb1e76ff061e88bc3524aee453d2bee494e" translate="yes" xml:space="preserve">
          <source>The new name of the role.</source>
          <target state="translated">角色的新名称。</target>
        </trans-unit>
        <trans-unit id="2cf77fbb7b0d27045bc13b02630747a959116461" translate="yes" xml:space="preserve">
          <source>The new name of the schema. The new name cannot begin with &lt;code&gt;pg_&lt;/code&gt;, as such names are reserved for system schemas.</source>
          <target state="translated">模式的新名称。新名称不能以 &lt;code&gt;pg_&lt;/code&gt; 开头，因为此类名称是为系统架构保留的。</target>
        </trans-unit>
        <trans-unit id="a8efb3edcac41dbb05c4e401ddd6f8995c994227" translate="yes" xml:space="preserve">
          <source>The new name of the tablespace. The new name cannot begin with &lt;code&gt;pg_&lt;/code&gt;, as such names are reserved for system tablespaces.</source>
          <target state="translated">表空间的新名称。新名称不能以 &lt;code&gt;pg_&lt;/code&gt; 开头，因为此类名称是为系统表空间保留的。</target>
        </trans-unit>
        <trans-unit id="5bc002f16673653b0690b28fc66ef20f059c3d17" translate="yes" xml:space="preserve">
          <source>The new name of the text search configuration.</source>
          <target state="translated">文字搜索配置的新名称。</target>
        </trans-unit>
        <trans-unit id="61d4e96018e9afca4b18c94ddcebcfce618c7e91" translate="yes" xml:space="preserve">
          <source>The new name of the text search dictionary.</source>
          <target state="translated">文字搜索词典的新名称。</target>
        </trans-unit>
        <trans-unit id="b0ee20d36931a187480bdf33645d746804cd8021" translate="yes" xml:space="preserve">
          <source>The new name of the text search parser.</source>
          <target state="translated">文本搜索解析器的新名称。</target>
        </trans-unit>
        <trans-unit id="1aa4447ea683fc5f23d92a99564476e94e7ba4f8" translate="yes" xml:space="preserve">
          <source>The new name of the text search template.</source>
          <target state="translated">文字搜索模板的新名称。</target>
        </trans-unit>
        <trans-unit id="1cf431c1643a8759a28879f52b1cc3af8c233902" translate="yes" xml:space="preserve">
          <source>The new operator family is initially empty. It should be populated by issuing subsequent &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; commands to add contained operator classes, and optionally &lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt; commands to add &amp;ldquo;loose&amp;rdquo; operators and their corresponding support functions.</source>
          <target state="translated">新的操作员系列最初是空的。应该通过发出后续的 &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; 命令来添加所包含的运算符类，并可选地通过 &lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt; 命令来添加&amp;ldquo;松散&amp;rdquo;运算符及其相应的支持功能来填充它。</target>
        </trans-unit>
        <trans-unit id="f4c637105948973c0a153e08837179c7cca26481" translate="yes" xml:space="preserve">
          <source>The new owner of the aggregate function.</source>
          <target state="translated">聚合函数的新所有者。</target>
        </trans-unit>
        <trans-unit id="6e427a5a254b743496752784773d8f681fc927a5" translate="yes" xml:space="preserve">
          <source>The new owner of the collation.</source>
          <target state="translated">整理的新主人。</target>
        </trans-unit>
        <trans-unit id="696c05a86f35e15f1b9049294a231e9c92db726b" translate="yes" xml:space="preserve">
          <source>The new owner of the conversion.</source>
          <target state="translated">改造的新主人。</target>
        </trans-unit>
        <trans-unit id="8c3476b50bc477a63585319a4ee66bd132d319a7" translate="yes" xml:space="preserve">
          <source>The new owner of the database.</source>
          <target state="translated">数据库的新主人。</target>
        </trans-unit>
        <trans-unit id="d33f9460834c9ae8c6bbf2129c64d4ae9c681396" translate="yes" xml:space="preserve">
          <source>The new owner of the function. Note that if the function is marked &lt;code&gt;SECURITY DEFINER&lt;/code&gt;, it will subsequently execute as the new owner.</source>
          <target state="translated">该函数的新所有者。请注意，如果该功能标记为 &lt;code&gt;SECURITY DEFINER&lt;/code&gt; ，它将随后以新所有者的身份执行。</target>
        </trans-unit>
        <trans-unit id="df4e6318da1bb722216c2b84ac2c4e660006a7bf" translate="yes" xml:space="preserve">
          <source>The new owner of the language</source>
          <target state="translated">语文的新主人</target>
        </trans-unit>
        <trans-unit id="f528312a4f330c09f0db9a04fb7594d8a6881296" translate="yes" xml:space="preserve">
          <source>The new owner of the large object</source>
          <target state="translated">大物件的新主人</target>
        </trans-unit>
        <trans-unit id="042ac141d75c40bbad49229676115d2c3f46dc44" translate="yes" xml:space="preserve">
          <source>The new owner of the operator class.</source>
          <target state="translated">运营商类的新主人。</target>
        </trans-unit>
        <trans-unit id="690e510771eb7df59bdf5e81e98ce1c088ae0a0a" translate="yes" xml:space="preserve">
          <source>The new owner of the operator family.</source>
          <target state="translated">运营商家族的新主人。</target>
        </trans-unit>
        <trans-unit id="9786082232a6fabf8fef79154a67d7d246e8ac12" translate="yes" xml:space="preserve">
          <source>The new owner of the operator.</source>
          <target state="translated">运营商的新主人。</target>
        </trans-unit>
        <trans-unit id="3597f21e2766a9a6fcb13ac8067e53ff7ef13d45" translate="yes" xml:space="preserve">
          <source>The new owner of the procedure. Note that if the procedure is marked &lt;code&gt;SECURITY DEFINER&lt;/code&gt;, it will subsequently execute as the new owner.</source>
          <target state="translated">该过程的新所有者。请注意，如果该过程标记为 &lt;code&gt;SECURITY DEFINER&lt;/code&gt; ，则它将随后作为新所有者执行。</target>
        </trans-unit>
        <trans-unit id="69d41d917f1d5469eff45e378f228e62ac815b74" translate="yes" xml:space="preserve">
          <source>The new owner of the schema.</source>
          <target state="translated">模式的新主人。</target>
        </trans-unit>
        <trans-unit id="db70ea94e40096f71c45b13de8eea08d1af85b1d" translate="yes" xml:space="preserve">
          <source>The new owner of the tablespace.</source>
          <target state="translated">表空间的新主人。</target>
        </trans-unit>
        <trans-unit id="e5c9278160aed343baae5e000f62f65dff7fc448" translate="yes" xml:space="preserve">
          <source>The new owner of the text search configuration.</source>
          <target state="translated">文字搜索配置的新主人。</target>
        </trans-unit>
        <trans-unit id="aa73a2e5e347d201842eebdd89d547d089c6c8be" translate="yes" xml:space="preserve">
          <source>The new owner of the text search dictionary.</source>
          <target state="translated">文字搜索词典的新主人。</target>
        </trans-unit>
        <trans-unit id="edb8e480bb54a06edf443d08eda6114457bafd19" translate="yes" xml:space="preserve">
          <source>The new role will automatically inherit privileges of roles it is a member of. This is the default.</source>
          <target state="translated">新角色将自动继承其所属角色的权限。这是默认的。</target>
        </trans-unit>
        <trans-unit id="9a32a2a68f765041e1e9d89874f5db158ceae654" translate="yes" xml:space="preserve">
          <source>The new role will not automatically inherit privileges of roles it is a member of.</source>
          <target state="translated">新角色不会自动继承其所属角色的特权。</target>
        </trans-unit>
        <trans-unit id="9261c055206b3b24159966bd5e49b879f7e13689" translate="yes" xml:space="preserve">
          <source>The new schema for the aggregate function.</source>
          <target state="translated">聚合函数的新模式。</target>
        </trans-unit>
        <trans-unit id="4dc45ae2528649758dd2b3da76e3b1bde5aae0c1" translate="yes" xml:space="preserve">
          <source>The new schema for the collation.</source>
          <target state="translated">整理的新模式。</target>
        </trans-unit>
        <trans-unit id="fa5c853ff4ce0885678abb91184961581c7c86e8" translate="yes" xml:space="preserve">
          <source>The new schema for the conversion.</source>
          <target state="translated">转换的新模式。</target>
        </trans-unit>
        <trans-unit id="94f971cb399c2e27724257d01667804b12528aea" translate="yes" xml:space="preserve">
          <source>The new schema for the domain.</source>
          <target state="translated">域名的新模式。</target>
        </trans-unit>
        <trans-unit id="ffcd3334bad17af07bda4b5f314843b54c035a01" translate="yes" xml:space="preserve">
          <source>The new schema for the extension.</source>
          <target state="translated">扩展的新模式。</target>
        </trans-unit>
        <trans-unit id="892a2ed0bb951cfb6e7f263bc8da7d70f88d788a" translate="yes" xml:space="preserve">
          <source>The new schema for the function.</source>
          <target state="translated">该函数的新模式。</target>
        </trans-unit>
        <trans-unit id="f75cbb7e0424884c76eaf66a88fc00d8e62673a7" translate="yes" xml:space="preserve">
          <source>The new schema for the materialized view.</source>
          <target state="translated">物化视图的新模式。</target>
        </trans-unit>
        <trans-unit id="f6752ffe51d8560507628fd3fa3becd8329772f1" translate="yes" xml:space="preserve">
          <source>The new schema for the operator class.</source>
          <target state="translated">运营商类的新模式。</target>
        </trans-unit>
        <trans-unit id="91c91f016c0e190b6282eebefe2a49a89e2c716c" translate="yes" xml:space="preserve">
          <source>The new schema for the operator family.</source>
          <target state="translated">运营商家族的新模式。</target>
        </trans-unit>
        <trans-unit id="a28f607105e64dc0674bab3c516a94057914430b" translate="yes" xml:space="preserve">
          <source>The new schema for the operator.</source>
          <target state="translated">运营商的新模式。</target>
        </trans-unit>
        <trans-unit id="5b76b1ebef9ac79184347fc03689e8ad83b75ad3" translate="yes" xml:space="preserve">
          <source>The new schema for the procedure.</source>
          <target state="translated">程序的新模式。</target>
        </trans-unit>
        <trans-unit id="e1ef41d9bc55a3a445826b83357df117508b85c8" translate="yes" xml:space="preserve">
          <source>The new schema for the sequence.</source>
          <target state="translated">顺序的新模式。</target>
        </trans-unit>
        <trans-unit id="051afa3d07978a274fc9c7a36c2e3cc09b60a787" translate="yes" xml:space="preserve">
          <source>The new schema for the statistics object.</source>
          <target state="translated">统计对象的新模式。</target>
        </trans-unit>
        <trans-unit id="b33b53d7a11df09b3be2d48051dd92657dd5246a" translate="yes" xml:space="preserve">
          <source>The new schema for the text search configuration.</source>
          <target state="translated">文本搜索配置的新模式。</target>
        </trans-unit>
        <trans-unit id="ef261ca400ba6b8c404f8ae1051c9ddf74db7470" translate="yes" xml:space="preserve">
          <source>The new schema for the text search dictionary.</source>
          <target state="translated">文本搜索词典的新模式。</target>
        </trans-unit>
        <trans-unit id="6ee901249db3b5665acf6e566a8134c2dd5623bb" translate="yes" xml:space="preserve">
          <source>The new schema for the text search parser.</source>
          <target state="translated">文本搜索解析器的新模式。</target>
        </trans-unit>
        <trans-unit id="0a8618e7f7d0e904983cf7fb40badda672a564d7" translate="yes" xml:space="preserve">
          <source>The new schema for the text search template.</source>
          <target state="translated">文本搜索模板的新模式。</target>
        </trans-unit>
        <trans-unit id="2dae7eeaa9912635729239a107cfdb2251e22f7c" translate="yes" xml:space="preserve">
          <source>The new schema for the type.</source>
          <target state="translated">该类型的新模式。</target>
        </trans-unit>
        <trans-unit id="9da42308b2dd3741e38d355739234da9161529c8" translate="yes" xml:space="preserve">
          <source>The new schema for the view.</source>
          <target state="translated">视图的新模式。</target>
        </trans-unit>
        <trans-unit id="10efc2ba412402b38cf8661a03b9c2fa3f9344e1" translate="yes" xml:space="preserve">
          <source>The new security label, written as a string literal; or &lt;code&gt;NULL&lt;/code&gt; to drop the security label.</source>
          <target state="translated">新的安全标签，以字符串文字形式表示；或 &lt;code&gt;NULL&lt;/code&gt; 以删除安全标签。</target>
        </trans-unit>
        <trans-unit id="e179748e50d17a45a45be3da432d0626ce9f1871" translate="yes" xml:space="preserve">
          <source>The new server can now be safely started, and then any rsync'ed standby servers.</source>
          <target state="translated">现在可以安全地启动新服务器,然后启动任何rsync'ed备用服务器。</target>
        </trans-unit>
        <trans-unit id="9cccbe82fdca6cb05f61febaafdcdbee82d07beb" translate="yes" xml:space="preserve">
          <source>The new user will be a superuser.</source>
          <target state="translated">新用户将是一个超级用户。</target>
        </trans-unit>
        <trans-unit id="c54c521c104ba07a131d94a8006311919b30f264" translate="yes" xml:space="preserve">
          <source>The new user will be allowed to create databases.</source>
          <target state="translated">新用户将被允许创建数据库。</target>
        </trans-unit>
        <trans-unit id="d45b0936a7b0d005278d7069b144bbda44325062" translate="yes" xml:space="preserve">
          <source>The new user will be allowed to create new roles (that is, this user will have &lt;code&gt;CREATEROLE&lt;/code&gt; privilege).</source>
          <target state="translated">新用户将被允许创建新角色（即，该用户将具有 &lt;code&gt;CREATEROLE&lt;/code&gt; 特权）。</target>
        </trans-unit>
        <trans-unit id="f77c7b82b1f36620c7d5c97f31d6b3e8156045cd" translate="yes" xml:space="preserve">
          <source>The new user will be allowed to log in (that is, the user name can be used as the initial session user identifier). This is the default.</source>
          <target state="translated">新用户将被允许登录(即用户名可以作为初始会话用户标识符)。这是默认的。</target>
        </trans-unit>
        <trans-unit id="20d6f51c275f9b74aaf81f7d6a5623641aaaf3e3" translate="yes" xml:space="preserve">
          <source>The new user will have the &lt;code&gt;REPLICATION&lt;/code&gt; privilege, which is described more fully in the documentation for &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;.</source>
          <target state="translated">新用户将具有 &lt;code&gt;REPLICATION&lt;/code&gt; 特权，有关&lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;的文档中对此进行了更详细的描述。</target>
        </trans-unit>
        <trans-unit id="5ea6c8532360a87549f7c059f52122ef9c601695" translate="yes" xml:space="preserve">
          <source>The new user will not be a superuser. This is the default.</source>
          <target state="translated">新用户不会是超级用户。这是默认的。</target>
        </trans-unit>
        <trans-unit id="72c465f76c8179666632ce0c6f15419c4133425d" translate="yes" xml:space="preserve">
          <source>The new user will not be allowed to create databases. This is the default.</source>
          <target state="translated">新用户将不被允许创建数据库。这是默认的。</target>
        </trans-unit>
        <trans-unit id="32dd0b63f5a01c58c0731e9846c0b6a55a21f4f0" translate="yes" xml:space="preserve">
          <source>The new user will not be allowed to create new roles. This is the default.</source>
          <target state="translated">新用户将不被允许创建新角色。这是默认的。</target>
        </trans-unit>
        <trans-unit id="87cc74c8ed55ae4e670446b51aab48e450dbc14b" translate="yes" xml:space="preserve">
          <source>The new user will not be allowed to log in. (A role without login privilege is still useful as a means of managing database permissions.)</source>
          <target state="translated">新用户将不被允许登录。(没有登录权限的角色作为管理数据库权限的一种手段仍然是有用的。)</target>
        </trans-unit>
        <trans-unit id="a13d7c8eff958866dd3c2de41dd7c33e5dff939b" translate="yes" xml:space="preserve">
          <source>The new user will not have the &lt;code&gt;REPLICATION&lt;/code&gt; privilege, which is described more fully in the documentation for &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;.</source>
          <target state="translated">新用户将没有 &lt;code&gt;REPLICATION&lt;/code&gt; 特权，有关&lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;的文档中对此进行了更详细的描述。</target>
        </trans-unit>
        <trans-unit id="127849b8d3eea48eada06bb9a69ad7d49b073868" translate="yes" xml:space="preserve">
          <source>The new value for a table storage parameter. This might be a number or a word depending on the parameter.</source>
          <target state="translated">表存储参数的新值。根据参数的不同,可能是一个数字或一个字。</target>
        </trans-unit>
        <trans-unit id="c290b36401426b8422b4d66e484cd2e82d3b87ce" translate="yes" xml:space="preserve">
          <source>The new value for an index-method-specific storage parameter. This might be a number or a word depending on the parameter.</source>
          <target state="translated">特定索引方法存储参数的新值。根据参数的不同,它可能是一个数字或一个字。</target>
        </trans-unit>
        <trans-unit id="c34da01d538b4bb95a9dcedad6f42505d9964bfa" translate="yes" xml:space="preserve">
          <source>The new value of the column</source>
          <target state="translated">列的新值</target>
        </trans-unit>
        <trans-unit id="9cc0b73abbe4bf474235a0a153fa246959f47339" translate="yes" xml:space="preserve">
          <source>The new value to be added to an enum type's list of values, or the new name to be given to an existing value. Like all enum literals, it needs to be quoted.</source>
          <target state="translated">要添加到枚举类型的值列表中的新值,或者给现有值起的新名字。像所有的枚举字面值一样,它需要被引用。</target>
        </trans-unit>
        <trans-unit id="3abd3f485b5c74bf1e64463613b4fb3d9ef53408" translate="yes" xml:space="preserve">
          <source>The new value to use for a template-specific option. If the equal sign and value are omitted, then any previous setting for the option is removed from the dictionary, allowing the default to be used.</source>
          <target state="translated">用于模板特定选项的新值。如果省略了等号和值,那么之前对该选项的任何设置都会从字典中删除,允许使用默认值。</target>
        </trans-unit>
        <trans-unit id="54266d9e3dff5c3d85bb17314ebcd06db8a0c4e2" translate="yes" xml:space="preserve">
          <source>The next example shows how to obtain the union of the tables &lt;code&gt;distributors&lt;/code&gt; and &lt;code&gt;actors&lt;/code&gt;, restricting the results to those that begin with the letter W in each table. Only distinct rows are wanted, so the key word &lt;code&gt;ALL&lt;/code&gt; is omitted.</source>
          <target state="translated">下一个示例显示如何获取表 &lt;code&gt;distributors&lt;/code&gt; 和 &lt;code&gt;actors&lt;/code&gt; 并集，将结果限制为每个表中以字母W开头的结果。只需要不同的行，因此省略了关键字 &lt;code&gt;ALL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0b983bad83edd443b7b8ce4de658661eaff249f8" translate="yes" xml:space="preserve">
          <source>The next step is to set the session to use the new configuration, which was created in the &lt;code&gt;public&lt;/code&gt; schema:</source>
          <target state="translated">下一步是将会话设置为使用在 &lt;code&gt;public&lt;/code&gt; 模式中创建的新配置：</target>
        </trans-unit>
        <trans-unit id="69b04f7d07fe975427e0f7bf99be4fe924c78cc6" translate="yes" xml:space="preserve">
          <source>The non-default GIN operator class &lt;code&gt;jsonb_path_ops&lt;/code&gt; supports indexing the &lt;code&gt;@&amp;gt;&lt;/code&gt; operator only. An example of creating an index with this operator class is:</source>
          <target state="translated">非默认GIN运算符类 &lt;code&gt;jsonb_path_ops&lt;/code&gt; 仅支持对 &lt;code&gt;@&amp;gt;&lt;/code&gt; 运算符进行索引。使用此运算符类创建索引的示例是：</target>
        </trans-unit>
        <trans-unit id="1d49459b2ff80f4c26bb14ba35712908d50a4f44" translate="yes" xml:space="preserve">
          <source>The normal PostgreSQL query optimizer performs a &lt;em&gt;near-exhaustive search&lt;/em&gt; over the space of alternative strategies. This algorithm, first introduced in IBM's System R database, produces a near-optimal join order, but can take an enormous amount of time and memory space when the number of joins in the query grows large. This makes the ordinary PostgreSQL query optimizer inappropriate for queries that join a large number of tables.</source>
          <target state="translated">普通的PostgreSQL查询优化器对替代策略的空间进行了&lt;em&gt;几乎穷举的搜索&lt;/em&gt;。该算法最初在IBM的System R数据库中引入，产生了接近最佳的连接顺序，但是当查询中的连接数量增加时，可能会花费大量的时间和内存空间。这使得普通的PostgreSQL查询优化器不适用于连接大量表的查询。</target>
        </trans-unit>
        <trans-unit id="ddb0abe82fae0bb47141f78e86913e1352bb274e" translate="yes" xml:space="preserve">
          <source>The notations &lt;code&gt;varchar(n)&lt;/code&gt; and &lt;code&gt;char(n)&lt;/code&gt; are aliases for &lt;code&gt;character varying(n)&lt;/code&gt; and &lt;code&gt;character(n)&lt;/code&gt;, respectively. &lt;code&gt;character&lt;/code&gt; without length specifier is equivalent to &lt;code&gt;character(1)&lt;/code&gt;. If &lt;code&gt;character varying&lt;/code&gt; is used without length specifier, the type accepts strings of any size. The latter is a PostgreSQL extension.</source>
          <target state="translated">标记 &lt;code&gt;varchar(n)&lt;/code&gt; 和 &lt;code&gt;char(n)&lt;/code&gt; 分别是 &lt;code&gt;character varying(n)&lt;/code&gt; 和 &lt;code&gt;character(n)&lt;/code&gt; 的别名。 &lt;code&gt;character&lt;/code&gt; 而不长度说明等同于 &lt;code&gt;character(1)&lt;/code&gt; 。如果使用不带长度说明 &lt;code&gt;character varying&lt;/code&gt; ，则该类型接受任何大小的字符串。后者是PostgreSQL扩展。</target>
        </trans-unit>
        <trans-unit id="fbc61286b42787c186b2be652915f7206bb4ed7e" translate="yes" xml:space="preserve">
          <source>The number of &lt;em&gt;key columns&lt;/em&gt; in the index, not counting any &lt;em&gt;included columns&lt;/em&gt;, which are merely stored and do not participate in the index semantics</source>
          <target state="translated">索引中的&lt;em&gt;关键列&lt;/em&gt;的数量，不计算任何&lt;em&gt;包含的列&lt;/em&gt;，这些仅存储且不参与索引语义</target>
        </trans-unit>
        <trans-unit id="32236378278e06cdc1ed2783abcf03baa463efaf" translate="yes" xml:space="preserve">
          <source>The number of WAL segment files in &lt;code&gt;pg_wal&lt;/code&gt; directory depends on &lt;code&gt;min_wal_size&lt;/code&gt;, &lt;code&gt;max_wal_size&lt;/code&gt; and the amount of WAL generated in previous checkpoint cycles. When old log segment files are no longer needed, they are removed or recycled (that is, renamed to become future segments in the numbered sequence). If, due to a short-term peak of log output rate, &lt;code&gt;max_wal_size&lt;/code&gt; is exceeded, the unneeded segment files will be removed until the system gets back under this limit. Below that limit, the system recycles enough WAL files to cover the estimated need until the next checkpoint, and removes the rest. The estimate is based on a moving average of the number of WAL files used in previous checkpoint cycles. The moving average is increased immediately if the actual usage exceeds the estimate, so it accommodates peak usage rather than average usage to some extent. &lt;code&gt;min_wal_size&lt;/code&gt; puts a minimum on the amount of WAL files recycled for future usage; that much WAL is always recycled for future use, even if the system is idle and the WAL usage estimate suggests that little WAL is needed.</source>
          <target state="translated">&lt;code&gt;pg_wal&lt;/code&gt; 目录中WAL段文件的数量取决于 &lt;code&gt;min_wal_size&lt;/code&gt; ， &lt;code&gt;max_wal_size&lt;/code&gt; 以及先前检查点周期中生成的WAL数量。当不再需要旧的日志段文件时，它们将被删除或回收（即，重命名以按编号顺序成为将来的段）。如果由于日志输出速率的短期峰值而 &lt;code&gt;max_wal_size&lt;/code&gt; 如果超出该限制，则将删除不需要的段文件，直到系统恢复到该限制以下。低于该限制，系统将循环使用足够的WAL文件来满足估计的需求，直到下一个检查点为止，然后删除其余的文件。该估计基于先前检查点周期中使用的WAL文件数量的移动平均值。如果实际使用量超出了估计量，则移动平均立即增加，因此它在某种程度上适应了峰值使用量，而不是平均使用量。 &lt;code&gt;min_wal_size&lt;/code&gt; 对回收的WAL文件数量进行最小化以备将来使用。即使系统处于空闲状态，并且WAL的使用情况估计表明需要使用很少的WAL，也总是会回收大量的WAL以供将来使用。</target>
        </trans-unit>
        <trans-unit id="e63ffb99c780c2d3b3feec330c071c01fcbaec0d" translate="yes" xml:space="preserve">
          <source>The number of bytes that can be written to WAL such that this slot is not in danger of getting in state &quot;lost&quot;. It is NULL for lost slots, as well as if &lt;code&gt;max_slot_wal_keep_size&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8748e9fef55cda632ea0102b0e063bbbb95c6586" translate="yes" xml:space="preserve">
          <source>The number of columns in partition key</source>
          <target state="translated">分区键的列数</target>
        </trans-unit>
        <trans-unit id="edbeec849445e687cd12eea0389ae4b06b732e80" translate="yes" xml:space="preserve">
          <source>The number of direct ancestors this column has. A column with a nonzero number of ancestors cannot be dropped nor renamed.</source>
          <target state="translated">该列的直接祖先数。祖先数不为零的列不能被删除或重命名。</target>
        </trans-unit>
        <trans-unit id="d7208773dc180e0dd7b3e10265b4f310a20ba88e" translate="yes" xml:space="preserve">
          <source>The number of direct inheritance ancestors this constraint has. A constraint with a nonzero number of ancestors cannot be dropped nor renamed.</source>
          <target state="translated">该约束的直接继承祖先的数量。祖先数量不为零的约束条件不能被删除或重新命名。</target>
        </trans-unit>
        <trans-unit id="8301961997733ca48d253481eefaad3008a00674" translate="yes" xml:space="preserve">
          <source>The number of dirty buffers written in each round is based on the number of new buffers that have been needed by server processes during recent rounds. The average recent need is multiplied by &lt;code&gt;bgwriter_lru_multiplier&lt;/code&gt; to arrive at an estimate of the number of buffers that will be needed during the next round. Dirty buffers are written until there are that many clean, reusable buffers available. (However, no more than &lt;code&gt;bgwriter_lru_maxpages&lt;/code&gt; buffers will be written per round.) Thus, a setting of 1.0 represents a &amp;ldquo;just in time&amp;rdquo; policy of writing exactly the number of buffers predicted to be needed. Larger values provide some cushion against spikes in demand, while smaller values intentionally leave writes to be done by server processes. The default is 2.0. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">在每一轮中写入的脏缓冲区的数量基于服务器进程在最近各轮中需要的新缓冲区的数量。将最近的平均需求乘以 &lt;code&gt;bgwriter_lru_multiplier&lt;/code&gt; 即可得出下一轮将需要的缓冲区数量的估计值。写入脏缓冲区，直到有许多可用的干净可重用缓冲区为止。 （但是，不超过 &lt;code&gt;bgwriter_lru_maxpages&lt;/code&gt; 因此，设置为1.0表示准确地写入预计需要的缓冲区数量的&amp;ldquo;及时&amp;rdquo;策略。较大的值可缓解需求高峰，而较小的值则有意让写操作由服务器进程完成。默认值为2.0。该参数只能在 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件或服务器命令行中设置。</target>
        </trans-unit>
        <trans-unit id="3d25f5401af5c842168f311144ea17e37058d652" translate="yes" xml:space="preserve">
          <source>The number of distinct nonnull data values in the column. A value greater than zero is the actual number of distinct values. A value less than zero is the negative of a multiplier for the number of rows in the table; for example, a column in which about 80% of the values are nonnull and each nonnull value appears about twice on average could be represented by &lt;code&gt;stadistinct&lt;/code&gt; = -0.4. A zero value means the number of distinct values is unknown.</source>
          <target state="translated">列中不同的非空数据值的数量。大于零的值是不同值的实际数量。小于零的值是表中行数乘数的负数；例如，其中 &lt;code&gt;stadistinct&lt;/code&gt; = -0.4 表示一列，其中大约80％的值是非空值，每个非空值平均出现大约两次。零值表示不同值的数量未知。</target>
        </trans-unit>
        <trans-unit id="8289805730489472578e3f27b2f1d288c0d7dec6" translate="yes" xml:space="preserve">
          <source>The number of iterations of the S2K algorithm to use. It must be a value between 1024 and 65011712, inclusive.</source>
          <target state="translated">要使用的S2K算法的迭代次数。它必须是一个介于1024和65011712之间的数值,包括在内。</target>
        </trans-unit>
        <trans-unit id="9f0e73558363d09e86314a049abfbcf61eaf5cbd" translate="yes" xml:space="preserve">
          <source>The number of lexemes must be less than 2&lt;sup&gt;64&lt;/sup&gt;</source>
          <target state="translated">词素数必须少于2 &lt;sup&gt;64&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d2adf53592a4a37e557ef19975d87459fecab27a" translate="yes" xml:space="preserve">
          <source>The number of milliseconds to wait before reporting an authentication failure. The default is 0.</source>
          <target state="translated">报告认证失败前等待的毫秒数。默认值为0。</target>
        </trans-unit>
        <trans-unit id="4848e62664c3602823768b8a292b1248da926aa5" translate="yes" xml:space="preserve">
          <source>The number of nodes (lexemes + operators) in a &lt;code&gt;tsquery&lt;/code&gt; must be less than 32,768</source>
          <target state="translated">&lt;code&gt;tsquery&lt;/code&gt; 中的节点数（词素+运算符）必须少于32,768</target>
        </trans-unit>
        <trans-unit id="e36ab63c8c21311a28348db0c90c93619e02161d" translate="yes" xml:space="preserve">
          <source>The number of query cancels and the reason for them can be viewed using the &lt;code&gt;pg_stat_database_conflicts&lt;/code&gt; system view on the standby server. The &lt;code&gt;pg_stat_database&lt;/code&gt; system view also contains summary information.</source>
          <target state="translated">查询取消的数量及其原因可以使用备用服务器上的 &lt;code&gt;pg_stat_database_conflicts&lt;/code&gt; 系统视图查看。该 &lt;code&gt;pg_stat_database&lt;/code&gt; 系统视图也包含摘要信息。</target>
        </trans-unit>
        <trans-unit id="9d730ed06cd7648c33a05712cd3d40df8021dd41" translate="yes" xml:space="preserve">
          <source>The number of repetitions of the index scan that should be factored into the cost estimates. This will typically be greater than one when considering a parameterized scan for use in the inside of a nestloop join. Note that the cost estimates should still be for just one scan; a larger &lt;em&gt;&lt;code&gt;loop_count&lt;/code&gt;&lt;/em&gt; means that it may be appropriate to allow for some caching effects across multiple scans.</source>
          <target state="translated">索引扫描的重复次数应计入成本估算中。当考虑在嵌套循环连接内部使用参数化扫描时，该值通常大于一。请注意，成本估算仍应仅进行一次扫描。较大的&lt;em&gt; &lt;code&gt;loop_count&lt;/code&gt; &lt;/em&gt;意味着可能需要在多次扫描中获得一些缓存效果。</target>
        </trans-unit>
        <trans-unit id="166b286d18f619fbe9f6a3ea1bb840802689109b" translate="yes" xml:space="preserve">
          <source>The number of rows returned or affected by the last SQL query, or 0 if the query failed or did not report a row count.</source>
          <target state="translated">最后一次SQL查询返回的行数或受影响的行数,如果查询失败或没有报告行数,则为0。</target>
        </trans-unit>
        <trans-unit id="1d69a3b171c0833334cc425ee7e0d762adec494e" translate="yes" xml:space="preserve">
          <source>The number of rows to skip before starting to return rows. For details see &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;&lt;code&gt;LIMIT&lt;/code&gt; Clause&lt;/a&gt;.</source>
          <target state="translated">开始返回行之前要跳过的行数。有关详细信息，请参阅&lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt; &lt;code&gt;LIMIT&lt;/code&gt; 子句&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="94382b43faed8152ee9a457cefa14e2d7062f389" translate="yes" xml:space="preserve">
          <source>The number of rows to skip before starting to return rows. For details see &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;LIMIT Clause&lt;/a&gt; in the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aade2c0dad75a39b57c1da4c3274b381a44640e8" translate="yes" xml:space="preserve">
          <source>The number of the ISO 8601 week-numbering week of the year. By definition, ISO weeks start on Mondays and the first week of a year contains January 4 of that year. In other words, the first Thursday of a year is in week 1 of that year.</source>
          <target state="translated">一年中ISO 8601周编号周的编号。根据定义,ISO周从周一开始,一年的第一周包含当年的1月4日。换句话说,一年中的第一个星期四是该年的第1周。</target>
        </trans-unit>
        <trans-unit id="4cb2d1007085e9fe567cf2f04104acbb29523d8d" translate="yes" xml:space="preserve">
          <source>The number of the column</source>
          <target state="translated">栏目编号</target>
        </trans-unit>
        <trans-unit id="17b9b1cbc38db2adfa96c6b3cafb442db5c59e27" translate="yes" xml:space="preserve">
          <source>The number of the column. Ordinary columns are numbered from 1 up. System columns, such as &lt;code&gt;ctid&lt;/code&gt;, have (arbitrary) negative numbers.</source>
          <target state="translated">列号。普通列从1开始编号。系统列（例如 &lt;code&gt;ctid&lt;/code&gt; ）具有（任意）负数。</target>
        </trans-unit>
        <trans-unit id="d5de13da859bcae07a08d4b002774933f9c4b34a" translate="yes" xml:space="preserve">
          <source>The number of the described column</source>
          <target state="translated">所述栏目的编号</target>
        </trans-unit>
        <trans-unit id="8054a525924b0216f44b2c15796e49dd9491e9dd" translate="yes" xml:space="preserve">
          <source>The numbers provided by &lt;code&gt;BUFFERS&lt;/code&gt; help to identify which parts of the query are the most I/O-intensive.</source>
          <target state="translated">&lt;code&gt;BUFFERS&lt;/code&gt; 提供的数字有助于确定查询的哪些部分是I / O最密集的部分。</target>
        </trans-unit>
        <trans-unit id="a9a9a9a7a626d48ccbaac2fc53aad8be63a44035" translate="yes" xml:space="preserve">
          <source>The numerical, unique, sequentially-assigned identifier that each transaction receives when it first causes a database modification. Frequently abbreviated as &lt;em&gt;xid&lt;/em&gt;. When stored on disk, xids are only 32-bits wide, so only approximately four billion write transaction IDs can be generated; to permit the system to run for longer than that, &lt;em&gt;epochs&lt;/em&gt; are used, also 32 bits wide. When the counter reaches the maximum xid value, it starts over at &lt;code&gt;3&lt;/code&gt; (values under that are reserved) and the epoch value is incremented by one. In some contexts, the epoch and xid values are considered together as a single 64-bit value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23f1e0aeb5175fc6ed920199dd580b15702c2054" translate="yes" xml:space="preserve">
          <source>The object which describes a WAL range always has three keys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f439f1411e4ff73cafff6f9e11f463408382ecb" translate="yes" xml:space="preserve">
          <source>The object which describes a single file contains either a &lt;code&gt;Path&lt;/code&gt; key or an &lt;code&gt;Encoded-Path&lt;/code&gt; key. Normally, the &lt;code&gt;Path&lt;/code&gt; key will be present. The associated string value is the path of the file relative to the root of the backup directory. Files located in a user-defined tablespace will have paths whose first two components are &lt;code&gt;pg_tblspc&lt;/code&gt; and the OID of the tablespace. If the path is not a string that is legal in UTF-8, or if the user requests that encoded paths be used for all files, then the &lt;code&gt;Encoded-Path&lt;/code&gt; key will be present instead. This stores the same data, but it is encoded as a string of hexadecimal digits. Each pair of hexadecimal digits in the string represents a single octet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3001cae2699919156e01018ff603c7cc3b34ddd4" translate="yes" xml:space="preserve">
          <source>The object's key-value pairs, represented as an array of objects containing three fields: &lt;code&gt;&quot;key&quot;&lt;/code&gt;, &lt;code&gt;&quot;value&quot;&lt;/code&gt;, and &lt;code&gt;&quot;id&quot;&lt;/code&gt;; &lt;code&gt;&quot;id&quot;&lt;/code&gt; is a unique identifier of the object the key-value pair belongs to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c96b4217f4ff70cb5052589aed86a75a58ea381a" translate="yes" xml:space="preserve">
          <source>The obsolete options &lt;code&gt;SORT1&lt;/code&gt;, &lt;code&gt;SORT2&lt;/code&gt;, &lt;code&gt;LTCMP&lt;/code&gt;, and &lt;code&gt;GTCMP&lt;/code&gt; were formerly used to specify the names of sort operators associated with a merge-joinable operator. This is no longer necessary, since information about associated operators is found by looking at B-tree operator families instead. If one of these options is given, it is ignored except for implicitly setting &lt;code&gt;MERGES&lt;/code&gt; true.</source>
          <target state="translated">过时的选项 &lt;code&gt;SORT1&lt;/code&gt; ， &lt;code&gt;SORT2&lt;/code&gt; ， &lt;code&gt;LTCMP&lt;/code&gt; 和 &lt;code&gt;GTCMP&lt;/code&gt; 以前用于指定与可合并合并运算符关联的排序运算符的名称。这不再是必需的，因为有关关联的运算符的信息是通过查看B树运算符族来找到的。如果给出了这些选项之一，则将其忽略，除非将 &lt;code&gt;MERGES&lt;/code&gt; 隐式设置为 true。</target>
        </trans-unit>
        <trans-unit id="c4bf61bc0ae75f599a4b04ad0336e82b98b0a3d1" translate="yes" xml:space="preserve">
          <source>The octet with decimal value 92 (backslash) is doubled in the output. Details are in &lt;a href=&quot;datatype-binary#DATATYPE-BINARY-RESESC&quot;&gt;Table 8.8&lt;/a&gt;.</source>
          <target state="translated">在输出中，十进制值92（反斜杠）的八位字节加倍。详细信息在&lt;a href=&quot;datatype-binary#DATATYPE-BINARY-RESESC&quot;&gt;表8.8中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ed338423cb1bcb126644c1e6c22121f438859be7" translate="yes" xml:space="preserve">
          <source>The offset at which the allocation starts. NULL for anonymous allocations and unused memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bf48e5f27220de9fe763df392dfdaead2007f3b" translate="yes" xml:space="preserve">
          <source>The offset fields specify the hours, and optionally minutes and seconds, difference from UTC. They have the format &lt;code&gt;hh&lt;/code&gt;[&lt;code&gt;:&lt;/code&gt;&lt;code&gt;mm&lt;/code&gt;[&lt;code&gt;:&lt;/code&gt;&lt;code&gt;ss&lt;/code&gt;]] optionally with a leading sign (&lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;). The positive sign is used for zones &lt;em&gt;west&lt;/em&gt; of Greenwich. (Note that this is the opposite of the ISO-8601 sign convention used elsewhere in PostgreSQL.) &lt;code&gt;hh&lt;/code&gt; can have one or two digits; &lt;code&gt;mm&lt;/code&gt; and &lt;code&gt;ss&lt;/code&gt; (if used) must have two.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51b42992b2dbbebe4441f992b139d475f2a6576d" translate="yes" xml:space="preserve">
          <source>The old indexes are dropped. The &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; session locks for the indexes and the table are released.</source>
          <target state="translated">旧索引已删除。索引和表的 &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; 会话锁被释放。</target>
        </trans-unit>
        <trans-unit id="aff5f1b14035796efdcabc3055a299cc4fcb8ba7" translate="yes" xml:space="preserve">
          <source>The old indexes have &lt;code&gt;pg_index.indisready&lt;/code&gt; switched to &amp;ldquo;false&amp;rdquo; to prevent any new tuple insertions, after waiting for running queries that might reference the old index to complete.</source>
          <target state="translated">在等待可能引用旧索引的运行查询完成后，将旧索引的 &lt;code&gt;pg_index.indisready&lt;/code&gt; 切换为&amp;ldquo; false&amp;rdquo;以防止任何新的元组插入。</target>
        </trans-unit>
        <trans-unit id="05be6eb32947b010e242b9b77a81ac45522407a1" translate="yes" xml:space="preserve">
          <source>The oldest transaction affecting the system catalogs that this slot needs the database to retain. &lt;code&gt;VACUUM&lt;/code&gt; cannot remove catalog tuples deleted by any later transaction.</source>
          <target state="translated">影响该插槽需要数据库保留的系统目录的最旧事务。 &lt;code&gt;VACUUM&lt;/code&gt; 无法删除任何以后的事务删除的目录元组。</target>
        </trans-unit>
        <trans-unit id="5faf9118a5f5509db65f9f3d1a55a7c88d7b4faa" translate="yes" xml:space="preserve">
          <source>The oldest transaction that this slot needs the database to retain. &lt;code&gt;VACUUM&lt;/code&gt; cannot remove tuples deleted by any later transaction.</source>
          <target state="translated">该插槽需要数据库保留的最旧事务。 &lt;code&gt;VACUUM&lt;/code&gt; 无法删除任何后续事务删除的元组。</target>
        </trans-unit>
        <trans-unit id="f97ff854cd0196d6cae74ec459d42c99253ddda9" translate="yes" xml:space="preserve">
          <source>The only feature of AREs that is actually incompatible with POSIX EREs is that &lt;code&gt;\&lt;/code&gt; does not lose its special significance inside bracket expressions. All other ARE features use syntax which is illegal or has undefined or unspecified effects in POSIX EREs; the &lt;code&gt;***&lt;/code&gt; syntax of directors likewise is outside the POSIX syntax for both BREs and EREs.</source>
          <target state="translated">实际上与POSIX ERE不兼容的ARE的唯一功能是 &lt;code&gt;\&lt;/code&gt; 不会在方括号表达式内失去其特殊的意义。所有其他ARE功能均使用非法语法，或在POSIX ERE中具有未定义或未指定作用的语法；Director 的 &lt;code&gt;***&lt;/code&gt; 语法同样在BRE和ERE的POSIX语法之外。</target>
        </trans-unit>
        <trans-unit id="8a1895f6d1a24facb26fe1c49448d16cf40a3e4a" translate="yes" xml:space="preserve">
          <source>The only firm requirement for using NFS with PostgreSQL is that the file system is mounted using the &lt;code&gt;hard&lt;/code&gt; option. With the &lt;code&gt;hard&lt;/code&gt; option, processes can &amp;ldquo;hang&amp;rdquo; indefinitely if there are network problems, so this configuration will require a careful monitoring setup. The &lt;code&gt;soft&lt;/code&gt; option will interrupt system calls in case of network problems, but PostgreSQL will not repeat system calls interrupted in this way, so any such interruption will result in an I/O error being reported.</source>
          <target state="translated">将NFS与PostgreSQL一起使用的唯一确定要求是使用 &lt;code&gt;hard&lt;/code&gt; 选项挂载文件系统。如果使用 &lt;code&gt;hard&lt;/code&gt; 选项，则在出现网络问题时进程可以无限期&amp;ldquo;挂起&amp;rdquo;，因此此配置将需要仔细的监视设置。该 &lt;code&gt;soft&lt;/code&gt; 选项将中断的网络出现问题，系统调用，但PostgreSQL将不重复的系统调用以这种方式中断，因此任何这样的中断将导致报告中的I / O错误。</target>
        </trans-unit>
        <trans-unit id="a396e16c5e2752bf51d263513d40dc846694333b" translate="yes" xml:space="preserve">
          <source>The only parameter required by the &lt;code&gt;synonym&lt;/code&gt; template is &lt;code&gt;SYNONYMS&lt;/code&gt;, which is the base name of its configuration file &amp;mdash; &lt;code&gt;my_synonyms&lt;/code&gt; in the above example. The file's full name will be &lt;code&gt;$SHAREDIR/tsearch_data/my_synonyms.syn&lt;/code&gt; (where &lt;code&gt;$SHAREDIR&lt;/code&gt; means the PostgreSQL installation's shared-data directory). The file format is just one line per word to be substituted, with the word followed by its synonym, separated by white space. Blank lines and trailing spaces are ignored.</source>
          <target state="translated">&lt;code&gt;synonym&lt;/code&gt; 模板所需的唯一参数是 &lt;code&gt;SYNONYMS&lt;/code&gt; ，这是其配置文件的基本名称，即上例中的 &lt;code&gt;my_synonyms&lt;/code&gt; 。该文件的全名将为 &lt;code&gt;$SHAREDIR/tsearch_data/my_synonyms.syn&lt;/code&gt; （其中 &lt;code&gt;$SHAREDIR&lt;/code&gt; 表示PostgreSQL安装的共享数据目录）。文件格式只是每个单词要替换的一行，单词后跟同义词，由空格分隔。空行和尾随空格将被忽略。</target>
        </trans-unit>
        <trans-unit id="a030d7c4538742e2439ddd895553830f470ea35b" translate="yes" xml:space="preserve">
          <source>The operations that occur on both primary and standby servers are normal continuous archiving and recovery tasks. The only point of contact between the two database servers is the archive of WAL files that both share: primary writing to the archive, standby reading from the archive. Care must be taken to ensure that WAL archives from separate primary servers do not become mixed together or confused. The archive need not be large if it is only required for standby operation.</source>
          <target state="translated">主服务器和备用服务器上发生的操作都是正常的连续归档和恢复任务。两个数据库服务器之间唯一的接触点是两者共享的WAL文件的存档:主服务器向存档写入,备用服务器从存档中读取。必须注意确保来自不同主服务器的WAL归档不会混在一起或混淆。如果只需要备用操作,则存档不需要很大。</target>
        </trans-unit>
        <trans-unit id="78a77532759d107a293f71b3071e91121689e001" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;!=&lt;/code&gt; is mapped to &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; on input, so these two names are always equivalent.</source>
          <target state="translated">操作符 &lt;code&gt;!=&lt;/code&gt; 在输入时映射到 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ，因此这两个名称始终相等。</target>
        </trans-unit>
        <trans-unit id="7680d70684ff5657bfcc4e3b94f75e49715485f1" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;~~&lt;/code&gt; is equivalent to &lt;code&gt;LIKE&lt;/code&gt;, and &lt;code&gt;~~*&lt;/code&gt; corresponds to &lt;code&gt;ILIKE&lt;/code&gt;. There are also &lt;code&gt;!~~&lt;/code&gt; and &lt;code&gt;!~~*&lt;/code&gt; operators that represent &lt;code&gt;NOT LIKE&lt;/code&gt; and &lt;code&gt;NOT ILIKE&lt;/code&gt;, respectively. All of these operators are PostgreSQL-specific.</source>
          <target state="translated">运算符 &lt;code&gt;~~&lt;/code&gt; 等效于 &lt;code&gt;LIKE&lt;/code&gt; ，而 &lt;code&gt;~~*&lt;/code&gt; 等效于 &lt;code&gt;ILIKE&lt;/code&gt; 。还有 &lt;code&gt;!~~&lt;/code&gt; 和 &lt;code&gt;!~~*&lt;/code&gt; 运算符分别表示 &lt;code&gt;NOT LIKE&lt;/code&gt; 和 &lt;code&gt;NOT ILIKE&lt;/code&gt; 。所有这些运算符都是特定于PostgreSQL的。</target>
        </trans-unit>
        <trans-unit id="bd4509fc82896a3a7a34fb1c8f105531cc74d101" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;~~&lt;/code&gt; is equivalent to &lt;code&gt;LIKE&lt;/code&gt;, and &lt;code&gt;~~*&lt;/code&gt; corresponds to &lt;code&gt;ILIKE&lt;/code&gt;. There are also &lt;code&gt;!~~&lt;/code&gt; and &lt;code&gt;!~~*&lt;/code&gt; operators that represent &lt;code&gt;NOT LIKE&lt;/code&gt; and &lt;code&gt;NOT ILIKE&lt;/code&gt;, respectively. All of these operators are PostgreSQL-specific. You may see these operator names in &lt;code&gt;EXPLAIN&lt;/code&gt; output and similar places, since the parser actually translates &lt;code&gt;LIKE&lt;/code&gt; et al. to these operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d017a3795e4c2a850feefb2cba71cdbcd408d49" translate="yes" xml:space="preserve">
          <source>The operator class identifies the operators to be used by the index for that column. For example, a B-tree index on the type &lt;code&gt;int4&lt;/code&gt; would use the &lt;code&gt;int4_ops&lt;/code&gt; class; this operator class includes comparison functions for values of type &lt;code&gt;int4&lt;/code&gt;. In practice the default operator class for the column's data type is usually sufficient. The main reason for having operator classes is that for some data types, there could be more than one meaningful index behavior. For example, we might want to sort a complex-number data type either by absolute value or by real part. We could do this by defining two operator classes for the data type and then selecting the proper class when making an index. The operator class determines the basic sort ordering (which can then be modified by adding sort options &lt;code&gt;COLLATE&lt;/code&gt;, &lt;code&gt;ASC&lt;/code&gt;/&lt;code&gt;DESC&lt;/code&gt; and/or &lt;code&gt;NULLS FIRST&lt;/code&gt;/&lt;code&gt;NULLS LAST&lt;/code&gt;).</source>
          <target state="translated">operator类标识该列的索引要使用的运算符。例如，类型为 &lt;code&gt;int4&lt;/code&gt; 的B树索引将使用 &lt;code&gt;int4_ops&lt;/code&gt; 类。此运算符类包含类型为 &lt;code&gt;int4&lt;/code&gt; 的值的比较函数。实际上，列数据类型的默认运算符类通常就足够了。具有运算符类的主要原因是，对于某些数据类型，可能存在多个有意义的索引行为。例如，我们可能想按绝对值或实数对复数数据类型进行排序。为此，我们可以为数据类型定义两个运算符类，然后在创建索引时选择适当的类。运算符类确定基本的排序顺序（然后可以通过添加排序选项 &lt;code&gt;COLLATE&lt;/code&gt; ， &lt;code&gt;ASC&lt;/code&gt; / &lt;code&gt;DESC&lt;/code&gt; 和/或 &lt;code&gt;NULLS FIRST&lt;/code&gt; / &lt;code&gt;NULLS LAST&lt;/code&gt; 进行修改）。</target>
        </trans-unit>
        <trans-unit id="79d3ccfc646e039879a5fc434785db86b4443933" translate="yes" xml:space="preserve">
          <source>The operator classes &lt;code&gt;text_pattern_ops&lt;/code&gt;, &lt;code&gt;varchar_pattern_ops&lt;/code&gt;, and &lt;code&gt;bpchar_pattern_ops&lt;/code&gt; support B-tree indexes on the types &lt;code&gt;text&lt;/code&gt;, &lt;code&gt;varchar&lt;/code&gt;, and &lt;code&gt;char&lt;/code&gt; respectively. The difference from the default operator classes is that the values are compared strictly character by character rather than according to the locale-specific collation rules. This makes these operator classes suitable for use by queries involving pattern matching expressions (&lt;code&gt;LIKE&lt;/code&gt; or POSIX regular expressions) when the database does not use the standard &amp;ldquo;C&amp;rdquo; locale. As an example, you might index a &lt;code&gt;varchar&lt;/code&gt; column like this:</source>
          <target state="translated">运算符类 &lt;code&gt;text_pattern_ops&lt;/code&gt; ， &lt;code&gt;varchar_pattern_ops&lt;/code&gt; 和 &lt;code&gt;bpchar_pattern_ops&lt;/code&gt; 支持分别针对 &lt;code&gt;text&lt;/code&gt; ， &lt;code&gt;varchar&lt;/code&gt; 和 &lt;code&gt;char&lt;/code&gt; 类型的B树索引。与默认运算符类的不同之处在于，将严格按字符对值进行比较，而不是根据特定于区域设置的整理规则进行比较。当数据库不使用标准&amp;ldquo; C&amp;rdquo;语言环境时，这使这些运算符类适合包含模式匹配表达式（ &lt;code&gt;LIKE&lt;/code&gt; 或POSIX正则表达式）的查询使用。例如，您可以像这样对 &lt;code&gt;varchar&lt;/code&gt; 列建立索引：</target>
        </trans-unit>
        <trans-unit id="33bad4a7b35adf68e8d48de054b950c2d1ec9c35" translate="yes" xml:space="preserve">
          <source>The operator family this entry is for</source>
          <target state="translated">该条目所对应的运营商系列</target>
        </trans-unit>
        <trans-unit id="223e98e65916141080aa613ffd5f9982aa449061" translate="yes" xml:space="preserve">
          <source>The operator name is a sequence of up to &lt;code&gt;NAMEDATALEN&lt;/code&gt;-1 (63 by default) characters from the following list:</source>
          <target state="translated">操作员名称是以下列表中最多 &lt;code&gt;NAMEDATALEN&lt;/code&gt; -1（默认为63）个字符的序列：</target>
        </trans-unit>
        <trans-unit id="e93319af4ff4ab58e4fcfce194629f2f03f458a1" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;@&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;@&lt;/code&gt; are equivalent to PostgreSQL's built-in operators of the same names, except that they work only on integer arrays that do not contain nulls, while the built-in operators work for any array type. This restriction makes them faster than the built-in operators in many cases.</source>
          <target state="translated">运算符 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; ， &lt;code&gt;@&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;@&lt;/code&gt; 等同于PostgreSQL的同名内置运算符，不同之处在于它们仅适用于不包含null的整数数组，而内置运算符适用于任何数组类型。在许多情况下，此限制使它们比内置运算符更快。</target>
        </trans-unit>
        <trans-unit id="a0d063cd8a5cd2a97ff1408a1433cc81fe5925af" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;&amp;lt;@&lt;/code&gt;, &lt;code&gt;@&amp;gt;&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt; have analogues &lt;code&gt;^&amp;lt;@&lt;/code&gt;, &lt;code&gt;^@&amp;gt;&lt;/code&gt;, &lt;code&gt;^@&lt;/code&gt;, &lt;code&gt;^~&lt;/code&gt;, which are the same except they do not use indexes. These are useful only for testing purposes.</source>
          <target state="translated">运算符 &lt;code&gt;&amp;lt;@&lt;/code&gt; ， &lt;code&gt;@&amp;gt;&lt;/code&gt; ， &lt;code&gt;@&lt;/code&gt; 和 &lt;code&gt;~&lt;/code&gt; 具有类似物 &lt;code&gt;^&amp;lt;@&lt;/code&gt; ， &lt;code&gt;^@&amp;gt;&lt;/code&gt; ， &lt;code&gt;^@&lt;/code&gt; 和 &lt;code&gt;^~&lt;/code&gt; ，除了不使用索引外，它们是相同的。这些仅用于测试目的。</target>
        </trans-unit>
        <trans-unit id="fbca8888a118f48ef45503ea9b2b65638278cb3a" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;AND&lt;/code&gt; and &lt;code&gt;OR&lt;/code&gt; are commutative, that is, you can switch the left and right operand without affecting the result. But see &lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;Section 4.2.14&lt;/a&gt; for more information about the order of evaluation of subexpressions.</source>
          <target state="translated">运算符 &lt;code&gt;AND&lt;/code&gt; 和 &lt;code&gt;OR&lt;/code&gt; 是可交换的，也就是说，您可以在不影响结果的情况下切换左右操作数。但是有关子表达式求值顺序的更多信息，请参见&lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;第4.2.14节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ab3b948d9f1df6a05c6208cb2087918561197bec" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;AND&lt;/code&gt; and &lt;code&gt;OR&lt;/code&gt; are commutative, that is, you can switch the left and right operands without affecting the result. (However, it is not guaranteed that the left operand is evaluated before the right operand. See &lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;Section 4.2.14&lt;/a&gt; for more information about the order of evaluation of subexpressions.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afda15b721563ddc4ee8a5707f908cf503dfae35" translate="yes" xml:space="preserve">
          <source>The operators provided by the &lt;code&gt;hstore&lt;/code&gt; module are shown in &lt;a href=&quot;hstore#HSTORE-OP-TABLE&quot;&gt;Table F.7&lt;/a&gt;, the functions in &lt;a href=&quot;hstore#HSTORE-FUNC-TABLE&quot;&gt;Table F.8&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; 模块提供的运算符在&lt;a href=&quot;hstore#HSTORE-OP-TABLE&quot;&gt;表F.7&lt;/a&gt;中显示，功能在&lt;a href=&quot;hstore#HSTORE-FUNC-TABLE&quot;&gt;表F.8中显示&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="43de536c659d022d6659ab7d7ed96e1f9a44966b" translate="yes" xml:space="preserve">
          <source>The operators should not be defined by SQL functions. A SQL function is likely to be inlined into the calling query, which will prevent the optimizer from recognizing that the query matches an index.</source>
          <target state="translated">操作符不应该由SQL函数定义。SQL函数很可能在调用的查询中内联,这将阻止优化器识别出查询与索引匹配。</target>
        </trans-unit>
        <trans-unit id="c7779f9394f3c14857d843cdc250d88697a649fe" translate="yes" xml:space="preserve">
          <source>The optimal value for this option depends on the hardware setup of the server, of the client, and of the network. Factors include the number of CPU cores and the disk setup. A good place to start is the number of CPU cores on the server, but values larger than that can also lead to faster restore times in many cases. Of course, values that are too high will lead to decreased performance because of thrashing.</source>
          <target state="translated">这个选项的最佳值取决于服务器、客户端和网络的硬件设置。因素包括CPU核数和磁盘设置。一个好的起点是服务器上的CPU核数,但大于这个值在很多情况下也会导致更快的还原时间。当然,数值过高会因为打乱而导致性能下降。</target>
        </trans-unit>
        <trans-unit id="d0eb1545843db39f7e5b62a874b3d76a7289a03a" translate="yes" xml:space="preserve">
          <source>The optimizer can also use a B-tree index for queries involving the pattern matching operators &lt;code&gt;LIKE&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt;&lt;em&gt;if&lt;/em&gt; the pattern is a constant and is anchored to the beginning of the string &amp;mdash; for example, &lt;code&gt;col LIKE 'foo%'&lt;/code&gt; or &lt;code&gt;col ~ '^foo'&lt;/code&gt;, but not &lt;code&gt;col LIKE '%bar'&lt;/code&gt;. However, if your database does not use the C locale you will need to create the index with a special operator class to support indexing of pattern-matching queries; see &lt;a href=&quot;indexes-opclass&quot;&gt;Section 11.10&lt;/a&gt; below. It is also possible to use B-tree indexes for &lt;code&gt;ILIKE&lt;/code&gt; and &lt;code&gt;~*&lt;/code&gt;, but only if the pattern starts with non-alphabetic characters, i.e., characters that are not affected by upper/lower case conversion.</source>
          <target state="translated">优化器还可以使用B树索引进行涉及模式匹配运算符 &lt;code&gt;LIKE&lt;/code&gt; 和 &lt;code&gt;~&lt;/code&gt; 查询，&lt;em&gt;如果&lt;/em&gt;模式是一个常量并且锚定在字符串的开头，例如 &lt;code&gt;col LIKE 'foo%'&lt;/code&gt; 或 &lt;code&gt;col ~ '^foo'&lt;/code&gt; ，而不是 &lt;code&gt;col LIKE '%bar'&lt;/code&gt; 。但是，如果数据库不使用C语言环境，则需要使用特殊的运算符类创建索引以支持模式匹配查询的索引。请参阅下面的&lt;a href=&quot;indexes-opclass&quot;&gt;11.10节&lt;/a&gt;。也可以将B树索引用于 &lt;code&gt;ILIKE&lt;/code&gt; 和 &lt;code&gt;~*&lt;/code&gt; ，但仅当模式以非字母字符（即不受大写/小写转换影响的字符）开头时。</target>
        </trans-unit>
        <trans-unit id="8627270becb595b05140641f72d8445a0f79aa4e" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;STORED&lt;/code&gt; is not standard but is also used by other SQL implementations. The SQL standard does not specify the storage of generated columns.</source>
          <target state="translated">选项 &lt;code&gt;STORED&lt;/code&gt; 不是标准的，但其他SQL实现也使用该选项。SQL标准未指定所生成列的存储。</target>
        </trans-unit>
        <trans-unit id="a815faad2e87479a66432f285e1a514f8c1d46e0" translate="yes" xml:space="preserve">
          <source>The option is called &lt;code&gt;--dbname&lt;/code&gt; for consistency with other client applications, but because pg_basebackup doesn't connect to any particular database in the cluster, any database name in the connection string will be ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="734d38a3ce131eec63febbaae7def3c5bde63bbb" translate="yes" xml:space="preserve">
          <source>The option is called &lt;code&gt;--dbname&lt;/code&gt; for consistency with other client applications, but because pg_basebackup doesn't connect to any particular database in the cluster, database name in the connection string will be ignored.</source>
          <target state="translated">为了与其他客户端应用程序保持一致，该选项称为 &lt;code&gt;--dbname&lt;/code&gt; ，但是由于pg_basebackup没有连接到集群中的任何特定数据库，因此连接字符串中的数据库名称将被忽略。</target>
        </trans-unit>
        <trans-unit id="0db5016ffe3da0ce1e6c9b806713d2a3baee1dd9" translate="yes" xml:space="preserve">
          <source>The option is called &lt;code&gt;--dbname&lt;/code&gt; for consistency with other client applications, but because pg_dumpall needs to connect to many databases, the database name in the connection string will be ignored. Use the &lt;code&gt;-l&lt;/code&gt; option to specify the name of the database used for the initial connection, which will dump global objects and discover what other databases should be dumped.</source>
          <target state="translated">为了与其他客户端应用程序保持一致，该选项称为 &lt;code&gt;--dbname&lt;/code&gt; ，但是由于pg_dumpall需要连接到许多数据库，因此连接字符串中的数据库名称将被忽略。使用 &lt;code&gt;-l&lt;/code&gt; 选项指定用于初始连接的数据库的名称，该数据库将转储全局对象并发现应转储的其他数据库。</target>
        </trans-unit>
        <trans-unit id="b6f402f5f677410d43632fdfdda39802e1f95c15" translate="yes" xml:space="preserve">
          <source>The option is called &lt;code&gt;--dbname&lt;/code&gt; for consistency with other client applications, but because pg_receivewal doesn't connect to any particular database in the cluster, database name in the connection string will be ignored.</source>
          <target state="translated">为了与其他客户端应用程序保持一致，该选项称为 &lt;code&gt;--dbname&lt;/code&gt; ，但是由于pg_receivewal没有连接到集群中的任何特定数据库，因此连接字符串中的数据库名称将被忽略。</target>
        </trans-unit>
        <trans-unit id="c7c64ec896dfd3c50e33366b062eb4c419c8b0b7" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;CYCLE&lt;/code&gt; key word can be used to enable the sequence to wrap around when the &lt;code&gt;maxvalue&lt;/code&gt; or &lt;code&gt;minvalue&lt;/code&gt; has been reached by an ascending or descending sequence respectively. If the limit is reached, the next number generated will be the &lt;code&gt;minvalue&lt;/code&gt; or &lt;code&gt;maxvalue&lt;/code&gt;, respectively.</source>
          <target state="translated">可选的 &lt;code&gt;CYCLE&lt;/code&gt; 关键字可用于在序列分别由升序或降序达到 &lt;code&gt;maxvalue&lt;/code&gt; 或 &lt;code&gt;minvalue&lt;/code&gt; 时使序列环绕。如果达到限制，则生成的下一个数字将分别是 &lt;code&gt;minvalue&lt;/code&gt; 或 &lt;code&gt;maxvalue&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2bdec9ebdf4b00fd140bf7dd49f116ee6c5a4a50" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;GROUP BY&lt;/code&gt; clause has the general form</source>
          <target state="translated">可选的 &lt;code&gt;GROUP BY&lt;/code&gt; 子句具有一般形式</target>
        </trans-unit>
        <trans-unit id="9c06d7f3daaeb4524eeb820424e28a6752ac9545" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;HAVING&lt;/code&gt; clause has the general form</source>
          <target state="translated">可选的 &lt;code&gt;HAVING&lt;/code&gt; 子句具有一般形式</target>
        </trans-unit>
        <trans-unit id="e76a720d25d7bf8d3cf5b4abaa11a67203b026f7" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;INCLUDE&lt;/code&gt; clause specifies a list of columns which will be included in the index as &lt;em&gt;non-key&lt;/em&gt; columns. A non-key column cannot be used in an index scan search qualification, and it is disregarded for purposes of any uniqueness or exclusion constraint enforced by the index. However, an index-only scan can return the contents of non-key columns without having to visit the index's table, since they are available directly from the index entry. Thus, addition of non-key columns allows index-only scans to be used for queries that otherwise could not use them.</source>
          <target state="translated">可选的 &lt;code&gt;INCLUDE&lt;/code&gt; 子句指定列的列表，这些列将作为&lt;em&gt;非键&lt;/em&gt;列包含在索引中。非关键列不能在索引扫描搜索限定条件中使用，并且出于索引强制实施的任何唯一性或排除约束的目的而将其忽略。但是，仅索引扫描可以返回非键列的内容，而不必访问索引表，因为它们可以直接从索引条目获得。因此，添加非关键列可以将仅索引扫描用于原本无法使用它们的查询。</target>
        </trans-unit>
        <trans-unit id="2aa8e8dd6edbe127a1d3d92fe785e89d8eca0bac" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;INHERITS&lt;/code&gt; clause specifies a list of tables from which the new foreign table automatically inherits all columns. Parent tables can be plain tables or foreign tables. See the similar form of &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for more details.</source>
          <target state="translated">可选的 &lt;code&gt;INHERITS&lt;/code&gt; 子句指定一个表列表，新的外部表将从该表中自动继承所有列。父表可以是普通表或外部表。有关更多详细信息，请参见类似形式的&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d357ec942143a3e86ce2ca9c6595bccf9733322e" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;INHERITS&lt;/code&gt; clause specifies a list of tables from which the new table automatically inherits all columns. Parent tables can be plain tables or foreign tables.</source>
          <target state="translated">可选的 &lt;code&gt;INHERITS&lt;/code&gt; 子句指定一个表列表，新表将从中自动继承所有列。父表可以是普通表或外部表。</target>
        </trans-unit>
        <trans-unit id="935c04d83e4414228c1da5a13e9997ce0d9aed17" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;LANGUAGE&lt;/code&gt; clause can be written either before or after the code block.</source>
          <target state="translated">可选的 &lt;code&gt;LANGUAGE&lt;/code&gt; 子句可以在代码块之前或之后编写。</target>
        </trans-unit>
        <trans-unit id="4b362bf605fea7a639d64d32d41debf1c9b97b1a" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;ON CONFLICT&lt;/code&gt; clause specifies an alternative action to raising a unique violation or exclusion constraint violation error. For each individual row proposed for insertion, either the insertion proceeds, or, if an &lt;em&gt;arbiter&lt;/em&gt; constraint or index specified by &lt;em&gt;&lt;code&gt;conflict_target&lt;/code&gt;&lt;/em&gt; is violated, the alternative &lt;em&gt;&lt;code&gt;conflict_action&lt;/code&gt;&lt;/em&gt; is taken. &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; simply avoids inserting a row as its alternative action. &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; updates the existing row that conflicts with the row proposed for insertion as its alternative action.</source>
          <target state="translated">可选的 &lt;code&gt;ON CONFLICT&lt;/code&gt; 子句指定了引发唯一违反或排除约束违反错误的替代操作。对于提出的用于插入每个单独的行，无论插入的进行，或者，如果一个&lt;em&gt;判优器&lt;/em&gt;通过指定的约束或索引&lt;em&gt; &lt;code&gt;conflict_target&lt;/code&gt; &lt;/em&gt;被违反，替代&lt;em&gt; &lt;code&gt;conflict_action&lt;/code&gt; &lt;/em&gt;取。 &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; 只是避免插入一行作为其替代操作。 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 更新现有行，该行与作为替代操作建议插入的行冲突。</target>
        </trans-unit>
        <trans-unit id="d5dd05dee5b8b79438a7ed8440a1b3f1d3a71ea3" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;ORDER BY&lt;/code&gt; clause has this general form:</source>
          <target state="translated">可选的 &lt;code&gt;ORDER BY&lt;/code&gt; 子句具有以下一般形式：</target>
        </trans-unit>
        <trans-unit id="7116353ef7e307ca01f79a625c49cbb834ed45dc" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;PARTITION BY&lt;/code&gt; clause specifies a strategy of partitioning the table. The table thus created is called a &lt;em&gt;partitioned&lt;/em&gt; table. The parenthesized list of columns or expressions forms the &lt;em&gt;partition key&lt;/em&gt; for the table. When using range or hash partitioning, the partition key can include multiple columns or expressions (up to 32, but this limit can be altered when building PostgreSQL), but for list partitioning, the partition key must consist of a single column or expression.</source>
          <target state="translated">可选的 &lt;code&gt;PARTITION BY&lt;/code&gt; 子句指定对表进行分区的策略。这样创建的表称为&lt;em&gt;分区&lt;/em&gt;表。带括号的列或表达式列表构成表的&lt;em&gt;分区键&lt;/em&gt;。使用范围分区或哈希分区时，分区键可以包括多个列或表达式（最多32个，但是在构建PostgreSQL时可以更改此限制），但是对于列表分区，分区键必须由单个列或表达式组成。</target>
        </trans-unit>
        <trans-unit id="f6243054cea2c976be92eb3f4ea9df686539e824" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;RECURSIVE&lt;/code&gt; modifier changes &lt;code&gt;WITH&lt;/code&gt; from a mere syntactic convenience into a feature that accomplishes things not otherwise possible in standard SQL. Using &lt;code&gt;RECURSIVE&lt;/code&gt;, a &lt;code&gt;WITH&lt;/code&gt; query can refer to its own output. A very simple example is this query to sum the integers from 1 through 100:</source>
          <target state="translated">可选的 &lt;code&gt;RECURSIVE&lt;/code&gt; 修饰符将 &lt;code&gt;WITH&lt;/code&gt; 从单纯的语法方便性变为一种功能，该功能完成了标准SQL不可能完成的任务。使用 &lt;code&gt;RECURSIVE&lt;/code&gt; ， &lt;code&gt;WITH&lt;/code&gt; 查询可以引用其自身的输出。一个非常简单的示例是此查询将1到100之间的整数相加：</target>
        </trans-unit>
        <trans-unit id="fadff698169cd4951ccc6a878ef428bb081f97f0" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;REPEATABLE&lt;/code&gt; clause specifies a &lt;code&gt;seed&lt;/code&gt; number or expression to use for generating random numbers within the sampling method. The seed value can be any non-null floating-point value. Two queries that specify the same seed and &lt;code&gt;argument&lt;/code&gt; values will select the same sample of the table, if the table has not been changed meanwhile. But different seed values will usually produce different samples. If &lt;code&gt;REPEATABLE&lt;/code&gt; is not given then a new random sample is selected for each query, based upon a system-generated seed. Note that some add-on sampling methods do not accept &lt;code&gt;REPEATABLE&lt;/code&gt;, and will always produce new samples on each use.</source>
          <target state="translated">可选的 &lt;code&gt;REPEATABLE&lt;/code&gt; 子句指定用于在采样方法内生成随机数的 &lt;code&gt;seed&lt;/code&gt; 数或表达式。种子值可以是任何非空浮点值。如果同时没有更改表，则两个指定相同种子和 &lt;code&gt;argument&lt;/code&gt; 值的查询将选择该表的相同样本。但是不同的种子值通常会产生不同的样本。如果未给出 &lt;code&gt;REPEATABLE&lt;/code&gt; ，则根据系统生成的种子为每个查询选择一个新的随机样本。请注意，某些附加采样方法不接受 &lt;code&gt;REPEATABLE&lt;/code&gt; ，并且每次使用时都会产生新的采样。</target>
        </trans-unit>
        <trans-unit id="8777d7f8d07792d4f3e98ee0b8208d63db9f0b46" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;RETURNING&lt;/code&gt; clause causes &lt;code&gt;DELETE&lt;/code&gt; to compute and return value(s) based on each row actually deleted. Any expression using the table's columns, and/or columns of other tables mentioned in &lt;code&gt;USING&lt;/code&gt;, can be computed. The syntax of the &lt;code&gt;RETURNING&lt;/code&gt; list is identical to that of the output list of &lt;code&gt;SELECT&lt;/code&gt;.</source>
          <target state="translated">可选的 &lt;code&gt;RETURNING&lt;/code&gt; 子句使 &lt;code&gt;DELETE&lt;/code&gt; 根据实际删除的每一行计算并返回值。可以计算使用该表的列和/或 &lt;code&gt;USING&lt;/code&gt; 中提到的其他表的列的任何表达式。 &lt;code&gt;RETURNING&lt;/code&gt; 列表的语法与 &lt;code&gt;SELECT&lt;/code&gt; 的输出列表的语法相同。</target>
        </trans-unit>
        <trans-unit id="3578c21272426a6d018e36dbe114df05af571e18" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;RETURNING&lt;/code&gt; clause causes &lt;code&gt;INSERT&lt;/code&gt; to compute and return value(s) based on each row actually inserted (or updated, if an &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clause was used). This is primarily useful for obtaining values that were supplied by defaults, such as a serial sequence number. However, any expression using the table's columns is allowed. The syntax of the &lt;code&gt;RETURNING&lt;/code&gt; list is identical to that of the output list of &lt;code&gt;SELECT&lt;/code&gt;. Only rows that were successfully inserted or updated will be returned. For example, if a row was locked but not updated because an &lt;code&gt;ON CONFLICT DO UPDATE ... WHERE&lt;/code&gt; clause &lt;code&gt;condition&lt;/code&gt; was not satisfied, the row will not be returned.</source>
          <target state="translated">可选的 &lt;code&gt;RETURNING&lt;/code&gt; 子句使 &lt;code&gt;INSERT&lt;/code&gt; 根据实际插入（或使用 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 子句进行更新）的每一行返回值。这对于获取默认提供的值（例如序列号）非常有用。但是，允许使用表列的任何表达式。 &lt;code&gt;RETURNING&lt;/code&gt; 列表的语法与 &lt;code&gt;SELECT&lt;/code&gt; 的输出列表的语法相同。仅返回成功插入或更新的行。例如，如果由于未满足 &lt;code&gt;ON CONFLICT DO UPDATE ... WHERE&lt;/code&gt; 子句 &lt;code&gt;condition&lt;/code&gt; 而导致一行被锁定但未更新，则不会返回该行。</target>
        </trans-unit>
        <trans-unit id="26fec39eb66cc8ba300ea17034aad6e1ab719ea0" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;RETURNING&lt;/code&gt; clause causes &lt;code&gt;UPDATE&lt;/code&gt; to compute and return value(s) based on each row actually updated. Any expression using the table's columns, and/or columns of other tables mentioned in &lt;code&gt;FROM&lt;/code&gt;, can be computed. The new (post-update) values of the table's columns are used. The syntax of the &lt;code&gt;RETURNING&lt;/code&gt; list is identical to that of the output list of &lt;code&gt;SELECT&lt;/code&gt;.</source>
          <target state="translated">可选的 &lt;code&gt;RETURNING&lt;/code&gt; 子句使 &lt;code&gt;UPDATE&lt;/code&gt; 根据实际更新的每一行计算并返回值。可以计算使用该表的列和/或 &lt;code&gt;FROM&lt;/code&gt; 中提到的其他表的列的任何表达式。使用表列的新（更新后）值。 &lt;code&gt;RETURNING&lt;/code&gt; 列表的语法与 &lt;code&gt;SELECT&lt;/code&gt; 的输出列表的语法相同。</target>
        </trans-unit>
        <trans-unit id="7038a19db2dc16317b16f8d00a20421d7087db41" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;WHERE&lt;/code&gt; clause has the general form</source>
          <target state="translated">可选的 &lt;code&gt;WHERE&lt;/code&gt; 子句具有一般形式</target>
        </trans-unit>
        <trans-unit id="7792c91023d2f01afcab3c87bb09f61e0ba95957" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;WHERE&lt;/code&gt;, &lt;code&gt;GROUP BY&lt;/code&gt;, and &lt;code&gt;HAVING&lt;/code&gt; clauses in the table expression specify a pipeline of successive transformations performed on the table derived in the &lt;code&gt;FROM&lt;/code&gt; clause. All these transformations produce a virtual table that provides the rows that are passed to the select list to compute the output rows of the query.</source>
          <target state="translated">表表达式中的可选 &lt;code&gt;WHERE&lt;/code&gt; ， &lt;code&gt;GROUP BY&lt;/code&gt; 和 &lt;code&gt;HAVING&lt;/code&gt; 子句指定对 &lt;code&gt;FROM&lt;/code&gt; 子句派生的表执行的连续转换的管道。所有这些转换都会生成一个虚拟表，该表提供传递到选择列表的行，以计算查询的输出行。</target>
        </trans-unit>
        <trans-unit id="8a3824e49e923ca91de9f24e0e18785c61620d57" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;WINDOW&lt;/code&gt; clause has the general form</source>
          <target state="translated">可选的 &lt;code&gt;WINDOW&lt;/code&gt; 子句具有一般形式</target>
        </trans-unit>
        <trans-unit id="0734bf4cc1224dac3864d0137b3f27ef1692d40c" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;WITH&lt;/code&gt; clause specifies &lt;em&gt;storage parameters&lt;/em&gt; for the index. Each index method has its own set of allowed storage parameters. The B-tree, hash, GiST and SP-GiST index methods all accept this parameter:</source>
          <target state="translated">可选的 &lt;code&gt;WITH&lt;/code&gt; 子句指定索引的&lt;em&gt;存储参数&lt;/em&gt;。每个索引方法都有自己的一组允许的存储参数。B树，哈希，GiST和SP-GiST索引方法都接受此参数：</target>
        </trans-unit>
        <trans-unit id="a2ab89e063673dbb227b7d91abdf56f04b8f9bc9" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;XMLNAMESPACES&lt;/code&gt; clause gives a comma-separated list of namespace definitions, where each &lt;code&gt;namespace_uri&lt;/code&gt; is a &lt;code&gt;text&lt;/code&gt; expression and each &lt;code&gt;namespace_name&lt;/code&gt; is a simple identifier. It specifies the XML namespaces used in the document and their aliases. A default namespace specification is not currently supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="058389bedd0ce52c16be7bfd9114242b91506b69" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;XMLNAMESPACES&lt;/code&gt; clause is a comma-separated list of namespaces. It specifies the XML namespaces used in the document and their aliases. A default namespace specification is not currently supported.</source>
          <target state="translated">可选的 &lt;code&gt;XMLNAMESPACES&lt;/code&gt; 子句是用逗号分隔的名称空间列表。它指定了文档中使用的XML名称空间及其别名。当前不支持默认名称空间规范。</target>
        </trans-unit>
        <trans-unit id="57ded7b498b198ec6bfc70d87458a99fd28a21d6" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;analyze_function&lt;/code&gt; performs type-specific statistics collection for columns of the data type. By default, &lt;code&gt;ANALYZE&lt;/code&gt; will attempt to gather statistics using the type's &amp;ldquo;equals&amp;rdquo; and &amp;ldquo;less-than&amp;rdquo; operators, if there is a default b-tree operator class for the type. For non-scalar types this behavior is likely to be unsuitable, so it can be overridden by specifying a custom analysis function. The analysis function must be declared to take a single argument of type &lt;code&gt;internal&lt;/code&gt;, and return a &lt;code&gt;boolean&lt;/code&gt; result. The detailed API for analysis functions appears in &lt;code&gt;src/include/commands/vacuum.h&lt;/code&gt;.</source>
          <target state="translated">可选的 &lt;code&gt;analyze_function&lt;/code&gt; 对数据类型的列执行特定于类型的统计信息收集。默认情况下，如果该类型具有默认的b-tree运算符类，则 &lt;code&gt;ANALYZE&lt;/code&gt; 将尝试使用该类型的&amp;ldquo;等于&amp;rdquo;和&amp;ldquo;小于&amp;rdquo;运算符来收集统计信息。对于非标量类型，此行为可能不合适，因此可以通过指定自定义分析函数来覆盖它。分析函数必须声明为采用类型 &lt;code&gt;internal&lt;/code&gt; 的单个参数，并返回 &lt;code&gt;boolean&lt;/code&gt; 结果。分析功能的详细API出现在 &lt;code&gt;src/include/commands/vacuum.h&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="7747a49a90a7a4edd6982d5e13265f6731caae73" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;canonical&lt;/code&gt; function must take one argument of the range type being defined, and return a value of the same type. This is used to convert range values to a canonical form, when applicable. See &lt;a href=&quot;rangetypes#RANGETYPES-DEFINING&quot;&gt;Section 8.17.8&lt;/a&gt; for more information. Creating a &lt;code&gt;canonical&lt;/code&gt; function is a bit tricky, since it must be defined before the range type can be declared. To do this, you must first create a shell type, which is a placeholder type that has no properties except a name and an owner. This is done by issuing the command &lt;code&gt;CREATE TYPE name&lt;/code&gt;, with no additional parameters. Then the function can be declared using the shell type as argument and result, and finally the range type can be declared using the same name. This automatically replaces the shell type entry with a valid range type.</source>
          <target state="translated">可选的 &lt;code&gt;canonical&lt;/code&gt; 函数必须采用一个已定义范围类型的参数，并返回相同类型的值。适用时，它用于将范围值转换为规范形式。有关更多信息，请参见&lt;a href=&quot;rangetypes#RANGETYPES-DEFINING&quot;&gt;第8.17.8节&lt;/a&gt;。创建 &lt;code&gt;canonical&lt;/code&gt; 函数有些棘手，因为必须先声明它，然后才能声明范围类型。为此，必须首先创建一个外壳类型，该外壳类型是一个占位符类型，除了名称和所有者外，没有任何属性。这是通过发出命令 &lt;code&gt;CREATE TYPE name&lt;/code&gt; 完成的，没有其他参数。然后可以使用shell类型作为参数和结果声明函数，最后可以使用相同的名称声明范围类型。这将自动用有效的范围类型替换外壳类型条目。</target>
        </trans-unit>
        <trans-unit id="e405c33bd06f9fd7d49a367fa9d3ceab7c5a9a0c" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;flag&lt;/code&gt; string may include one or more of the characters &lt;code&gt;i&lt;/code&gt; for case-insensitive match, &lt;code&gt;m&lt;/code&gt; to allow &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; to match at newlines, &lt;code&gt;s&lt;/code&gt; to allow &lt;code&gt;.&lt;/code&gt; to match a newline, and &lt;code&gt;q&lt;/code&gt; to quote the whole pattern (reducing the behavior to a simple substring match).</source>
          <target state="translated">可选的 &lt;code&gt;flag&lt;/code&gt; 字符串可以包括一个或多个字符 &lt;code&gt;i&lt;/code&gt; ,用于不区分大小写的匹配； &lt;code&gt;m&lt;/code&gt; 用于允许 &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;$&lt;/code&gt; 匹配换行符， &lt;code&gt;s&lt;/code&gt; 用于允许 &lt;code&gt;.&lt;/code&gt; 匹配换行符， &lt;code&gt;q&lt;/code&gt; 引用整个模式（将行为简化为简单的子字符串匹配）。</target>
        </trans-unit>
        <trans-unit id="6929038d2d7ee1cd89d49d3d8b27997b9126c9d2" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;frame_clause&lt;/code&gt; can be one of</source>
          <target state="translated">可选的 &lt;code&gt;frame_clause&lt;/code&gt; 可以是以下之一</target>
        </trans-unit>
        <trans-unit id="1a0ad788554501dd9d4e6143a34e5057b31ec466" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;frame_clause&lt;/code&gt; defines the &lt;em&gt;window frame&lt;/em&gt; for window functions that depend on the frame (not all do). The window frame is a set of related rows for each row of the query (called the &lt;em&gt;current row&lt;/em&gt;). The &lt;code&gt;frame_clause&lt;/code&gt; can be one of</source>
          <target state="translated">可选的 &lt;code&gt;frame_clause&lt;/code&gt; 定义依赖于&lt;em&gt;框架&lt;/em&gt;的窗口功能的&lt;em&gt;窗口&lt;/em&gt;框架（并非全部如此）。窗口框架是查询的每一行（称为&lt;em&gt;当前行&lt;/em&gt;）的一组相关行。该 &lt;code&gt;frame_clause&lt;/code&gt; 可以是一个</target>
        </trans-unit>
        <trans-unit id="78c603df9d8f5aec2127eee4c089f14a6a63935b" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;like_option&lt;/code&gt; clauses specify which additional properties of the original table to copy. Specifying &lt;code&gt;INCLUDING&lt;/code&gt; copies the property, specifying &lt;code&gt;EXCLUDING&lt;/code&gt; omits the property. &lt;code&gt;EXCLUDING&lt;/code&gt; is the default. If multiple specifications are made for the same kind of object, the last one is used. The available options are:</source>
          <target state="translated">可选的 &lt;code&gt;like_option&lt;/code&gt; 子句指定要复制原始表的哪些其他属性。指定 &lt;code&gt;INCLUDING&lt;/code&gt; 将复制属性，指定 &lt;code&gt;EXCLUDING&lt;/code&gt; 将忽略该属性。 &lt;code&gt;EXCLUDING&lt;/code&gt; 是默认设置。如果对同一类型的对象制定了多种规格，则使用最后一种规格。可用的选项有：</target>
        </trans-unit>
        <trans-unit id="3b1514641d42b559d683d1926252a8c2e4d381f2" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;receive_function&lt;/code&gt; converts the type's external binary representation to the internal representation. If this function is not supplied, the type cannot participate in binary input. The binary representation should be chosen to be cheap to convert to internal form, while being reasonably portable. (For example, the standard integer data types use network byte order as the external binary representation, while the internal representation is in the machine's native byte order.) The receive function should perform adequate checking to ensure that the value is valid. The receive function can be declared as taking one argument of type &lt;code&gt;internal&lt;/code&gt;, or as taking three arguments of types &lt;code&gt;internal&lt;/code&gt;, &lt;code&gt;oid&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;. The first argument is a pointer to a &lt;code&gt;StringInfo&lt;/code&gt; buffer holding the received byte string; the optional arguments are the same as for the text input function. The receive function must return a value of the data type itself. Usually, a receive function should be declared STRICT; if it is not, it will be called with a NULL first parameter when reading a NULL input value. The function must still return NULL in this case, unless it raises an error. (This case is mainly meant to support domain receive functions, which might need to reject NULL inputs.) Similarly, the optional &lt;code&gt;send_function&lt;/code&gt; converts from the internal representation to the external binary representation. If this function is not supplied, the type cannot participate in binary output. The send function must be declared as taking one argument of the new data type. The send function must return type &lt;code&gt;bytea&lt;/code&gt;. Send functions are not invoked for NULL values.</source>
          <target state="translated">可选的 &lt;code&gt;receive_function&lt;/code&gt; 将类型的外部二进制表示形式转换为内部表示形式。如果未提供此功能，则该类型不能参与二进制输入。应选择二进制表示形式，以便便宜地转换为内部形式，同时又具有合理的可移植性。 （例如，标准整数数据类型使用网络字节顺序作为外部二进制表示，而内部表示以计算机的本机字节顺序表示。）receive函数应进行适当的检查以确保该值有效。可以将接收函数声明为采用类型为 &lt;code&gt;internal&lt;/code&gt; 的一个参数，或者声明为采用类型 &lt;code&gt;internal&lt;/code&gt; ， &lt;code&gt;oid&lt;/code&gt; ， &lt;code&gt;integer&lt;/code&gt; 的三个参数。第一个参数是指向保存接收到的字节字符串的 &lt;code&gt;StringInfo&lt;/code&gt; 缓冲区的指针；可选参数与文本输入功能相同。接收函数必须返回数据类型本身的值。通常，接收函数应声明为STRICT；如果不是，则在读取NULL输入值时将使用NULL第一个参数调用它。在这种情况下，该函数仍必须返回NULL，除非它引发错误。 （这种情况主要是为了支持域接收功能，可能需要拒绝NULL输入。）类似，可选的 &lt;code&gt;send_function&lt;/code&gt; 从内部表示形式转换为外部二进制表示形式。如果未提供此功能，则该类型不能参与二进制输出。必须将send函数声明为采用新数据类型的一个参数。send函数必须返回类型 &lt;code&gt;bytea&lt;/code&gt; 。不为NULL值调用发送函数。</target>
        </trans-unit>
        <trans-unit id="7d7acb9837f1f10a2e0445707407528f679ac86a" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;sequence_options&lt;/code&gt; clause can be used to override the options of the sequence. See &lt;a href=&quot;sql-createsequence&quot;&gt;CREATE SEQUENCE&lt;/a&gt; for details.</source>
          <target state="translated">可选的 &lt;code&gt;sequence_options&lt;/code&gt; 子句可用于覆盖序列的选项。有关详细信息，请参见&lt;a href=&quot;sql-createsequence&quot;&gt;CREATE SEQUENCE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7bcdb21e727a9ca38cf42b2a6d25b5e2872506f6" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;subtype_diff&lt;/code&gt; function must take two values of the &lt;code&gt;subtype&lt;/code&gt; type as argument, and return a &lt;code&gt;double precision&lt;/code&gt; value representing the difference between the two given values. While this is optional, providing it allows much greater efficiency of GiST indexes on columns of the range type. See &lt;a href=&quot;rangetypes#RANGETYPES-DEFINING&quot;&gt;Section 8.17.8&lt;/a&gt; for more information.</source>
          <target state="translated">可选的 &lt;code&gt;subtype_diff&lt;/code&gt; 函数必须将 &lt;code&gt;subtype&lt;/code&gt; 类型类型的两个值作为参数，并返回一个 &lt;code&gt;double precision&lt;/code&gt; 值，该值表示两个给定值之间的差。虽然这是可选的，但提供此选项可以使range类型的列上的GiST索引效率更高。有关更多信息，请参见&lt;a href=&quot;rangetypes#RANGETYPES-DEFINING&quot;&gt;第8.17.8节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1325ceadd1cae01690d39e7c916f8ac8cf741797" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;type_modifier_input_function&lt;/code&gt; and &lt;code&gt;type_modifier_output_function&lt;/code&gt; are needed if the type supports modifiers, that is optional constraints attached to a type declaration, such as &lt;code&gt;char(5)&lt;/code&gt; or &lt;code&gt;numeric(30,2)&lt;/code&gt;. PostgreSQL allows user-defined types to take one or more simple constants or identifiers as modifiers. However, this information must be capable of being packed into a single non-negative integer value for storage in the system catalogs. The &lt;code&gt;type_modifier_input_function&lt;/code&gt; is passed the declared modifier(s) in the form of a &lt;code&gt;cstring&lt;/code&gt; array. It must check the values for validity (throwing an error if they are wrong), and if they are correct, return a single non-negative &lt;code&gt;integer&lt;/code&gt; value that will be stored as the column &amp;ldquo;typmod&amp;rdquo;. Type modifiers will be rejected if the type does not have a &lt;code&gt;type_modifier_input_function&lt;/code&gt;. The &lt;code&gt;type_modifier_output_function&lt;/code&gt; converts the internal integer typmod value back to the correct form for user display. It must return a &lt;code&gt;cstring&lt;/code&gt; value that is the exact string to append to the type name; for example &lt;code&gt;numeric&lt;/code&gt;'s function might return &lt;code&gt;(30,2)&lt;/code&gt;. It is allowed to omit the &lt;code&gt;type_modifier_output_function&lt;/code&gt;, in which case the default display format is just the stored typmod integer value enclosed in parentheses.</source>
          <target state="translated">如果类型支持修饰符，则需要可选的 &lt;code&gt;type_modifier_input_function&lt;/code&gt; 和 &lt;code&gt;type_modifier_output_function&lt;/code&gt; ，修饰符是附加到类型声明的可选约束，例如 &lt;code&gt;char(5)&lt;/code&gt; 或 &lt;code&gt;numeric(30,2)&lt;/code&gt; 。 PostgreSQL允许用户定义的类型将一个或多个简单的常量或标识符用作修饰符。但是，此信息必须能够打包为单个非负整数值，以存储在系统目录中。所述 &lt;code&gt;type_modifier_input_function&lt;/code&gt; 传递所声明的形式改性剂 &lt;code&gt;cstring&lt;/code&gt; 数组。它必须检查值的有效性（如果错误，则抛出错误），如果正确，则返回单个非负数 &lt;code&gt;integer&lt;/code&gt; 将存储为&amp;ldquo; typmod&amp;rdquo;列的整数值。如果类型没有 &lt;code&gt;type_modifier_input_function&lt;/code&gt; ,则类型修饰符将被拒绝。所述 &lt;code&gt;type_modifier_output_function&lt;/code&gt; 转换内部整数值修饰符输入回到正确的形式显示给用户。它必须返回一个 &lt;code&gt;cstring&lt;/code&gt; 值，该值是要附加到类型名称后面的确切字符串。例如， &lt;code&gt;numeric&lt;/code&gt; 函数可能返回 &lt;code&gt;(30,2)&lt;/code&gt; 。允许省略 &lt;code&gt;type_modifier_output_function&lt;/code&gt; ，在这种情况下，默认显示格式只是括号内存储的typmod整数值。</target>
        </trans-unit>
        <trans-unit id="af1ecc2cb7dfd4fb66fffd97bf916a5a132fb429" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;AS data_type&lt;/code&gt; changes the data type of the sequence. Valid types are &lt;code&gt;smallint&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;, and &lt;code&gt;bigint&lt;/code&gt;.</source>
          <target state="translated">可选子句 &lt;code&gt;AS data_type&lt;/code&gt; 更改序列的数据类型。有效类型为 &lt;code&gt;smallint&lt;/code&gt; ， &lt;code&gt;integer&lt;/code&gt; 和 &lt;code&gt;bigint&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6491ae8d81a26646c521265ecd71bb3dba07346" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;AS data_type&lt;/code&gt; specifies the data type of the sequence. Valid types are &lt;code&gt;smallint&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;, and &lt;code&gt;bigint&lt;/code&gt;. &lt;code&gt;bigint&lt;/code&gt; is the default. The data type determines the default minimum and maximum values of the sequence.</source>
          <target state="translated">可选子句 &lt;code&gt;AS data_type&lt;/code&gt; 指定序列的数据类型。有效类型为 &lt;code&gt;smallint&lt;/code&gt; ， &lt;code&gt;integer&lt;/code&gt; 和 &lt;code&gt;bigint&lt;/code&gt; 。 &lt;code&gt;bigint&lt;/code&gt; 是默认设置。数据类型确定序列的默认最小值和最大值。</target>
        </trans-unit>
        <trans-unit id="4ef52006c6e494bfa443e060a826bdc36541e6b7" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;CACHE cache&lt;/code&gt; specifies how many sequence numbers are to be preallocated and stored in memory for faster access. The minimum value is 1 (only one value can be generated at a time, i.e., no cache), and this is also the default.</source>
          <target state="translated">可选的子句 &lt;code&gt;CACHE cache&lt;/code&gt; 指定要预分配多少序列号，并将其存储在内存中以加快访问速度。最小值为1（一次只能生成一个值，即没有缓存），这也是默认值。</target>
        </trans-unit>
        <trans-unit id="e1922af2324c94734b798d29c69dd1e6a8cd6788" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;INCREMENT BY increment&lt;/code&gt; specifies which value is added to the current sequence value to create a new value. A positive value will make an ascending sequence, a negative one a descending sequence. The default value is 1.</source>
          <target state="translated">可选子句 &lt;code&gt;INCREMENT BY increment&lt;/code&gt; 指定将哪个值添加到当前序列值以创建新值。正值将形成一个升序，负值将形成一个降序。预设值为1。</target>
        </trans-unit>
        <trans-unit id="129d57b7ace9b8671169f53fc01dbaf732d5dd2a" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;MAXVALUE maxvalue&lt;/code&gt; determines the maximum value for the sequence. If &lt;code&gt;NO MAXVALUE&lt;/code&gt; is specified, the defaults of the maximum value of the data type and -1 for ascending and descending sequences, respectively, will be used. If neither option is specified, the current maximum value will be maintained.</source>
          <target state="translated">可选子句 &lt;code&gt;MAXVALUE maxvalue&lt;/code&gt; 确定序列的最大值。如果指定了 &lt;code&gt;NO MAXVALUE&lt;/code&gt; ，则将分别使用数据类型的最大值和-1的升序和降序序列的默认值。如果未指定任何选项，则将保持当前最大值。</target>
        </trans-unit>
        <trans-unit id="636d2219bc9ef5ee8fa4e79b4cd4c563ed5f1551" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;MAXVALUE maxvalue&lt;/code&gt; determines the maximum value for the sequence. If this clause is not supplied or &lt;code&gt;NO MAXVALUE&lt;/code&gt; is specified, then default values will be used. The default for an ascending sequence is the maximum value of the data type. The default for a descending sequence is -1.</source>
          <target state="translated">可选子句 &lt;code&gt;MAXVALUE maxvalue&lt;/code&gt; 确定序列的最大值。如果未提供此子句或指定了 &lt;code&gt;NO MAXVALUE&lt;/code&gt; ，则将使用默认值。升序的默认值是数据类型的最大值。降序的默认值为-1。</target>
        </trans-unit>
        <trans-unit id="c5eb2614e0e305c391d790e5028cc9a0dac1d3fe" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;MINVALUE minvalue&lt;/code&gt; determines the minimum value a sequence can generate. If &lt;code&gt;NO MINVALUE&lt;/code&gt; is specified, the defaults of 1 and the minimum value of the data type for ascending and descending sequences, respectively, will be used. If neither option is specified, the current minimum value will be maintained.</source>
          <target state="translated">可选子句 &lt;code&gt;MINVALUE minvalue&lt;/code&gt; 确定序列可以生成的最小值。如果指定了 &lt;code&gt;NO MINVALUE&lt;/code&gt; ，则将分别使用默认值1和升序和降序数据类型的最小值。如果未指定任何选项，则将保持当前的最小值。</target>
        </trans-unit>
        <trans-unit id="e9e2bcb7eb75a3afb340c5c1fc227a8406ff8640" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;MINVALUE minvalue&lt;/code&gt; determines the minimum value a sequence can generate. If this clause is not supplied or &lt;code&gt;NO MINVALUE&lt;/code&gt; is specified, then defaults will be used. The default for an ascending sequence is 1. The default for a descending sequence is the minimum value of the data type.</source>
          <target state="translated">可选子句 &lt;code&gt;MINVALUE minvalue&lt;/code&gt; 确定序列可以生成的最小值。如果未提供此子句或指定了 &lt;code&gt;NO MINVALUE&lt;/code&gt; ，则将使用默认值。升序的默认值为1。降序的默认值为数据类型的最小值。</target>
        </trans-unit>
        <trans-unit id="fcd2de5b18440bca469ca6adbeb6f5f5db2e6405" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;RESTART [ WITH restart ]&lt;/code&gt; changes the current value of the sequence. This is similar to calling the &lt;code&gt;setval&lt;/code&gt; function with &lt;code&gt;is_called&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt;: the specified value will be returned by the &lt;em&gt;next&lt;/em&gt; call of &lt;code&gt;nextval&lt;/code&gt;. Writing &lt;code&gt;RESTART&lt;/code&gt; with no &lt;code&gt;restart&lt;/code&gt; value is equivalent to supplying the start value that was recorded by &lt;code&gt;CREATE SEQUENCE&lt;/code&gt; or last set by &lt;code&gt;ALTER SEQUENCE START WITH&lt;/code&gt;.</source>
          <target state="translated">可选子句 &lt;code&gt;RESTART [ WITH restart ]&lt;/code&gt; 更改序列的当前值。这类似于使用 &lt;code&gt;is_called&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; 调用 &lt;code&gt;setval&lt;/code&gt; 函数：&lt;em&gt;下一次&lt;/em&gt;调用 &lt;code&gt;nextval&lt;/code&gt; 将返回指定的值。没有 &lt;code&gt;restart&lt;/code&gt; 值的情况下写入 &lt;code&gt;RESTART&lt;/code&gt; 等同于提供由 &lt;code&gt;CREATE SEQUENCE&lt;/code&gt; 记录或由 &lt;code&gt;ALTER SEQUENCE START WITH&lt;/code&gt; 设置的最后一个起始值。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0fb28acc2fa41aa8ead28a09cd415f780a8cadf0" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;START WITH start&lt;/code&gt; allows the sequence to begin anywhere. The default starting value is &lt;code&gt;minvalue&lt;/code&gt; for ascending sequences and &lt;code&gt;maxvalue&lt;/code&gt; for descending ones.</source>
          <target state="translated">可选的子句 &lt;code&gt;START WITH start&lt;/code&gt; 允许序列从任何地方开始。缺省初始值是 &lt;code&gt;minvalue&lt;/code&gt; 对于升序序列和 &lt;code&gt;maxvalue&lt;/code&gt; 为下降的。</target>
        </trans-unit>
        <trans-unit id="eb785729e5f5d903e46bb6918c0a11aa04baffd1" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;START WITH start&lt;/code&gt; changes the recorded start value of the sequence. This has no effect on the &lt;em&gt;current&lt;/em&gt; sequence value; it simply sets the value that future &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt; commands will use.</source>
          <target state="translated">可选的子句 &lt;code&gt;START WITH start&lt;/code&gt; 更改记录的序列起始值。这对&lt;em&gt;当前&lt;/em&gt;序列值没有影响。它只是设置将来的 &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt; 命令将使用的值。</target>
        </trans-unit>
        <trans-unit id="1713a9e1e99f66c0bcfe7df0c08c776ea8b0c311" translate="yes" xml:space="preserve">
          <source>The optional constraint clauses specify constraints (tests) that new or updated rows must satisfy for an insert or update operation to succeed. A constraint is an SQL object that helps define the set of valid values in the table in various ways.</source>
          <target state="translated">可选的约束子句指定了新的或更新的记录必须满足的约束(测试),以便插入或更新操作成功。约束是一个SQL对象,它以各种方式帮助定义表中的有效值集。</target>
        </trans-unit>
        <trans-unit id="e18e0d61bcb7c9d71d791c91de29bb60405c83c7" translate="yes" xml:space="preserve">
          <source>The optional flag &lt;code&gt;PASSEDBYVALUE&lt;/code&gt; indicates that values of this data type are passed by value, rather than by reference. Types passed by value must be fixed-length, and their internal representation cannot be larger than the size of the &lt;code&gt;Datum&lt;/code&gt; type (4 bytes on some machines, 8 bytes on others).</source>
          <target state="translated">可选标志 &lt;code&gt;PASSEDBYVALUE&lt;/code&gt; 指示此数据类型的值是通过值而不是通过引用传递的。按值传递的类型必须为固定长度，并且它们的内部表示形式不能大于 &lt;code&gt;Datum&lt;/code&gt; 类型的大小（某些计算机上为4字节，其他计算机上为8字节）。</target>
        </trans-unit>
        <trans-unit id="96f5588e1c2e2855ea8548eee4502bfe5b21503f" translate="yes" xml:space="preserve">
          <source>The optional parameter &lt;code&gt;PATTERN&lt;/code&gt; can be the name of a text search object, optionally schema-qualified. If &lt;code&gt;PATTERN&lt;/code&gt; is omitted then information about all visible objects will be displayed. &lt;code&gt;PATTERN&lt;/code&gt; can be a regular expression and can provide &lt;em&gt;separate&lt;/em&gt; patterns for the schema and object names. The following examples illustrate this:</source>
          <target state="translated">可选参数 &lt;code&gt;PATTERN&lt;/code&gt; 可以是文本搜索对象的名称，可以选择是模式限定的。如果省略 &lt;code&gt;PATTERN&lt;/code&gt; ，则将显示有关所有可见对象的信息。 &lt;code&gt;PATTERN&lt;/code&gt; 可以是正则表达式，并且可以为模式和对象名称提供&lt;em&gt;单独的&lt;/em&gt;模式。以下示例说明了这一点：</target>
        </trans-unit>
        <trans-unit id="de01abc64ad555117df4d2eb14da2dc8395e780a" translate="yes" xml:space="preserve">
          <source>The optional third argument of the function is an array of namespace mappings. This array should be a two-dimensional &lt;code&gt;text&lt;/code&gt; array with the length of the second axis being equal to 2 (i.e., it should be an array of arrays, each of which consists of exactly 2 elements). The first element of each array entry is the namespace name (alias), the second the namespace URI. It is not required that aliases provided in this array be the same as those being used in the XML document itself (in other words, both in the XML document and in the &lt;code&gt;xpath&lt;/code&gt; function context, aliases are &lt;em&gt;local&lt;/em&gt;).</source>
          <target state="translated">该函数的第三个可选参数是名称空间映射的数组。该数组应该是二维 &lt;code&gt;text&lt;/code&gt; 数组，第二轴的长度等于2（即，它应该是一个数组数组，每个数组都由2个元素组成）。每个数组条目的第一个元素是名称空间名称（别名），第二个元素是名称空间URI。不需要此数组中提供的别名与XML文档本身中使用的别名相同（换句话说，在XML文档和 &lt;code&gt;xpath&lt;/code&gt; 函数上下文中，别名都是&lt;em&gt;local&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="3d0c8a9e2cea5113636abde4ca21364d5044faa7" translate="yes" xml:space="preserve">
          <source>The optional user-defined method are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7c4a4f219f0aa64d3de98d0b070691b60ede2a2" translate="yes" xml:space="preserve">
          <source>The optional user-defined method is:</source>
          <target state="translated">可选的用户定义方法是:</target>
        </trans-unit>
        <trans-unit id="84a938a7941f222eb580e7e8263bbd7142209820" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;--docdir&lt;/code&gt;, &lt;code&gt;--pkgincludedir&lt;/code&gt;, &lt;code&gt;--localedir&lt;/code&gt;, &lt;code&gt;--mandir&lt;/code&gt;, &lt;code&gt;--sharedir&lt;/code&gt;, &lt;code&gt;--sysconfdir&lt;/code&gt;, &lt;code&gt;--cc&lt;/code&gt;, &lt;code&gt;--cppflags&lt;/code&gt;, &lt;code&gt;--cflags&lt;/code&gt;, &lt;code&gt;--cflags_sl&lt;/code&gt;, &lt;code&gt;--ldflags&lt;/code&gt;, &lt;code&gt;--ldflags_sl&lt;/code&gt;, and &lt;code&gt;--libs&lt;/code&gt; were added in PostgreSQL 8.1. The option &lt;code&gt;--htmldir&lt;/code&gt; was added in PostgreSQL 8.4. The option &lt;code&gt;--ldflags_ex&lt;/code&gt; was added in PostgreSQL 9.0.</source>
          <target state="translated">选项 &lt;code&gt;--docdir&lt;/code&gt; ， &lt;code&gt;--pkgincludedir&lt;/code&gt; ， &lt;code&gt;--localedir&lt;/code&gt; ， &lt;code&gt;--mandir&lt;/code&gt; ， &lt;code&gt;--sharedir&lt;/code&gt; ， &lt;code&gt;--sysconfdir&lt;/code&gt; ， &lt;code&gt;--cc&lt;/code&gt; ， &lt;code&gt;--cppflags&lt;/code&gt; ， &lt;code&gt;--cflags&lt;/code&gt; ， &lt;code&gt;--cflags_sl&lt;/code&gt; ， &lt;code&gt;--ldflags&lt;/code&gt; ， &lt;code&gt;--ldflags_sl&lt;/code&gt; ，和 &lt;code&gt;--libs&lt;/code&gt; 是在PostgreSQL 8.1中添加的。在PostgreSQL 8.4中添加了 &lt;code&gt;--htmldir&lt;/code&gt; 选项。选项 &lt;code&gt;--ldflags_ex&lt;/code&gt; 已添加到PostgreSQL 9.0中。</target>
        </trans-unit>
        <trans-unit id="fabb800956bbdc09009ffd9f1b017eb0d6e1abef" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;-D&lt;/code&gt;, &lt;code&gt;-l&lt;/code&gt;, &lt;code&gt;-E&lt;/code&gt;, &lt;code&gt;-O&lt;/code&gt;, and &lt;code&gt;-T&lt;/code&gt; correspond to options of the underlying SQL command &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt;; see there for more information about them.</source>
          <target state="translated">选项 &lt;code&gt;-D&lt;/code&gt; ， &lt;code&gt;-l&lt;/code&gt; ， &lt;code&gt;-E&lt;/code&gt; ， &lt;code&gt;-O&lt;/code&gt; 和 &lt;code&gt;-T&lt;/code&gt; 对应于基础SQL命令&lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE的&lt;/a&gt;选项；请参阅此处以获取有关它们的更多信息。</target>
        </trans-unit>
        <trans-unit id="b59022ce6b09c2f629170565a77c3c19be85bd9c" translate="yes" xml:space="preserve">
          <source>The options can appear in any order.</source>
          <target state="translated">这些选项可以以任何顺序出现。</target>
        </trans-unit>
        <trans-unit id="83b4362928db8b9651a7b14a89534a668d30b89b" translate="yes" xml:space="preserve">
          <source>The options described here are used mainly for debugging purposes, and in some cases to assist with recovery of severely damaged databases. There should be no reason to use them in a production database setup. They are listed here only for use by PostgreSQL system developers. Furthermore, these options might change or be removed in a future release without notice.</source>
          <target state="translated">这里所描述的选项主要用于调试目的,在某些情况下用于协助恢复严重损坏的数据库。在生产型数据库的设置中,应该没有理由使用它们。这里列出的这些选项仅供PostgreSQL系统开发人员使用。此外,这些选项可能会在未来的版本中改变或删除,恕不另行通知。</target>
        </trans-unit>
        <trans-unit id="f8dd3a92af0a56bfda8d9752b838ef4b2d6a4df2" translate="yes" xml:space="preserve">
          <source>The order 3501 might be among the billed or unbilled orders.</source>
          <target state="translated">3501号订单可能属于已出单或未出单的订单。</target>
        </trans-unit>
        <trans-unit id="abcd49a17f5a3270a489cdc6cf5f6ae4822bbd01" translate="yes" xml:space="preserve">
          <source>The order doesn't matter. It does not necessarily determine in which order the constraints are checked.</source>
          <target state="translated">顺序并不重要。它不一定决定检查约束条件的顺序。</target>
        </trans-unit>
        <trans-unit id="4885441a3f0959533bfa66d30ac9b400042a2243" translate="yes" xml:space="preserve">
          <source>The order of evaluation of subexpressions is not defined. In particular, the inputs of an operator or function are not necessarily evaluated left-to-right or in any other fixed order.</source>
          <target state="translated">子表达式的评估顺序没有规定。特别是,一个运算符或函数的输入不一定从左到右或以任何其他固定的顺序进行评估。</target>
        </trans-unit>
        <trans-unit id="89519eed893d527079231a8a6443c77bf1a65103" translate="yes" xml:space="preserve">
          <source>The order of the pairs is not significant (and may not be reproduced on output). Whitespace between pairs or around the &lt;code&gt;=&amp;gt;&lt;/code&gt; sign is ignored. Double-quote keys and values that include whitespace, commas, &lt;code&gt;=&lt;/code&gt;s or &lt;code&gt;&amp;gt;&lt;/code&gt;s. To include a double quote or a backslash in a key or value, escape it with a backslash.</source>
          <target state="translated">配对的顺序并不重要（并且可能不会在输出中复制）。线对之间或 &lt;code&gt;=&amp;gt;&lt;/code&gt; 符号周围的空格将被忽略。双引号键和值，包括空格，逗号， &lt;code&gt;=&lt;/code&gt; s或 &lt;code&gt;&amp;gt;&lt;/code&gt; s。要在键或值中包含双引号或反斜杠，请使用反斜杠对其进行转义。</target>
        </trans-unit>
        <trans-unit id="6a0d0d4551f2d45fd2b79524bceb16c2da137ff6" translate="yes" xml:space="preserve">
          <source>The ordering of the values in an enum type is the order in which the values were listed when the type was created. All standard comparison operators and related aggregate functions are supported for enums. For example:</source>
          <target state="translated">枚举类型中的值的顺序是创建类型时列出的值的顺序。枚举支持所有标准的比较运算符和相关的集合函数。例如:</target>
        </trans-unit>
        <trans-unit id="4a1c45805d8830616db8f03a352b425367265a0b" translate="yes" xml:space="preserve">
          <source>The ordinal number refers to the ordinal (left-to-right) position of the index column.</source>
          <target state="translated">序数指的是索引列的序数(从左到右)位置。</target>
        </trans-unit>
        <trans-unit id="542906884bd50e7620583567769e2555be971b00" translate="yes" xml:space="preserve">
          <source>The ordinal number refers to the ordinal (left-to-right) position of the output column. This feature makes it possible to define an ordering on the basis of a column that does not have a unique name. This is never absolutely necessary because it is always possible to assign a name to an output column using the &lt;code&gt;AS&lt;/code&gt; clause.</source>
          <target state="translated">序号是指输出列的序数位置（从左到右）。通过此功能，可以基于没有唯一名称的列来定义顺序。这绝对不是绝对必要的，因为始终可以使用 &lt;code&gt;AS&lt;/code&gt; 子句为输出列分配名称。</target>
        </trans-unit>
        <trans-unit id="b06b3bbd9847482f4b77272cbdd9dddfd2293b02" translate="yes" xml:space="preserve">
          <source>The ordinary qualified-column-name syntax &lt;code&gt;table_name&lt;/code&gt;&lt;code&gt;.&lt;/code&gt;&lt;code&gt;column_name&lt;/code&gt; can be understood as applying &lt;a href=&quot;sql-expressions#FIELD-SELECTION&quot;&gt;field selection&lt;/a&gt; to the composite value of the table's current row. (For efficiency reasons, it's not actually implemented that way.)</source>
          <target state="translated">普通的限定列名称语法 &lt;code&gt;table_name&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; &lt;code&gt;column_name&lt;/code&gt; 可以理解为将&lt;a href=&quot;sql-expressions#FIELD-SELECTION&quot;&gt;字段选择&lt;/a&gt;应用于表的当前行的复合值。（出于效率考虑，实际上并没有采用这种方式。）</target>
        </trans-unit>
        <trans-unit id="26d29240df565151bc026ac25aff13ab3efc3c48" translate="yes" xml:space="preserve">
          <source>The origin node's LSN up to which data has been replicated.</source>
          <target state="translated">数据被复制到的源节点的LSN。</target>
        </trans-unit>
        <trans-unit id="0c0890af1d3eba99328b2705ec2de494e2103157" translate="yes" xml:space="preserve">
          <source>The other clauses specify optional operator optimization clauses. Their meaning is detailed in &lt;a href=&quot;https://www.postgresql.org/docs/12/xoper-optimization.html&quot;&gt;Section 37.15&lt;/a&gt;.</source>
          <target state="translated">其他子句指定可选的运算符优化子句。它们的含义在&lt;a href=&quot;https://www.postgresql.org/docs/12/xoper-optimization.html&quot;&gt;第37.15节中&lt;/a&gt;有详细说明。</target>
        </trans-unit>
        <trans-unit id="9473f0f0dfb8c5d74bfb5c710889c3c431764eb1" translate="yes" xml:space="preserve">
          <source>The other clauses specify optional operator optimization clauses. Their meaning is detailed in &lt;a href=&quot;https://www.postgresql.org/docs/13/xoper-optimization.html&quot;&gt;Section 37.15&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="968a2d78a8c8100f337e33a5ce08a9f2a42bbad9" translate="yes" xml:space="preserve">
          <source>The other locale categories can be changed whenever desired by setting the server configuration parameters that have the same name as the locale categories (see &lt;a href=&quot;runtime-config-client#RUNTIME-CONFIG-CLIENT-FORMAT&quot;&gt;Section 19.11.2&lt;/a&gt; for details). The values that are chosen by &lt;code&gt;initdb&lt;/code&gt; are actually only written into the configuration file &lt;code&gt;postgresql.conf&lt;/code&gt; to serve as defaults when the server is started. If you remove these assignments from &lt;code&gt;postgresql.conf&lt;/code&gt; then the server will inherit the settings from its execution environment.</source>
          <target state="translated">通过设置与语言环境类别名称相同的服务器配置参数，可以随时更改其他语言环境类别（有关详细信息，请参见&lt;a href=&quot;runtime-config-client#RUNTIME-CONFIG-CLIENT-FORMAT&quot;&gt;19.11.2节&lt;/a&gt;）。实际上，由 &lt;code&gt;initdb&lt;/code&gt; 选择的值仅写入配置文件 &lt;code&gt;postgresql.conf&lt;/code&gt; 中,以在服务器启动时用作默认值。如果从 &lt;code&gt;postgresql.conf&lt;/code&gt; 中删除这些分配，则服务器将从其执行环境继承设置。</target>
        </trans-unit>
        <trans-unit id="c995e27c615e98c0f723cb03133efd117f67f54f" translate="yes" xml:space="preserve">
          <source>The other locale settings &lt;a href=&quot;runtime-config-client#GUC-LC-MESSAGES&quot;&gt;lc_messages&lt;/a&gt;, &lt;a href=&quot;runtime-config-client#GUC-LC-MONETARY&quot;&gt;lc_monetary&lt;/a&gt;, &lt;a href=&quot;runtime-config-client#GUC-LC-NUMERIC&quot;&gt;lc_numeric&lt;/a&gt;, and &lt;a href=&quot;runtime-config-client#GUC-LC-TIME&quot;&gt;lc_time&lt;/a&gt; are not fixed per database and are not set by this command. If you want to make them the default for a specific database, you can use &lt;code&gt;ALTER DATABASE ... SET&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f628b39443abf4900d7c741215add2d55c377a2" translate="yes" xml:space="preserve">
          <source>The other required settings have default values that are sufficient for a basic setup.</source>
          <target state="translated">其他所需设置的默认值足以满足基本设置。</target>
        </trans-unit>
        <trans-unit id="37e3a8e885deb65cc32448cece3ed8b5de192c3e" translate="yes" xml:space="preserve">
          <source>The other three operators are defined in terms of &lt;code&gt;=&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt; in the obvious way, and must act consistently with them.</source>
          <target state="translated">其他三个运算符以明显的方式用 &lt;code&gt;=&lt;/code&gt; 和 &lt;code&gt;&amp;lt;&lt;/code&gt; 定义，并且必须与它们一致。</target>
        </trans-unit>
        <trans-unit id="cca1af5395645eeb86ba526f8d241c5ba5b41b07" translate="yes" xml:space="preserve">
          <source>The output columns are described in &lt;a href=&quot;pgstattuple#PGSTATAPPROX-COLUMNS&quot;&gt;Table F.23&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pgstattuple#PGSTATAPPROX-COLUMNS&quot;&gt;表F.23&lt;/a&gt;中描述了输出列。</target>
        </trans-unit>
        <trans-unit id="2061781f2ae71dd3ed97908a6bff9dc965e50b4d" translate="yes" xml:space="preserve">
          <source>The output columns are described in &lt;a href=&quot;pgstattuple#PGSTATTUPLE-COLUMNS&quot;&gt;Table F.22&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pgstattuple#PGSTATTUPLE-COLUMNS&quot;&gt;表F.22&lt;/a&gt;中描述了输出列。</target>
        </trans-unit>
        <trans-unit id="a9d41f9345eb262fbbccef45f4cf925c1a6818ef" translate="yes" xml:space="preserve">
          <source>The output columns are:</source>
          <target state="translated">输出栏为:</target>
        </trans-unit>
        <trans-unit id="ddee20dbbcf56a7d470d5e18264fdb853ffab834" translate="yes" xml:space="preserve">
          <source>The output format of the date/time types can be set to one of the four styles ISO 8601, SQL (Ingres), traditional POSTGRES (Unix date format), or German. The default is the ISO format. (The SQL standard requires the use of the ISO 8601 format. The name of the &amp;ldquo;SQL&amp;rdquo; output format is a historical accident.) &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-OUTPUT-TABLE&quot;&gt;Table 8.14&lt;/a&gt; shows examples of each output style. The output of the &lt;code&gt;date&lt;/code&gt; and &lt;code&gt;time&lt;/code&gt; types is generally only the date or time part in accordance with the given examples. However, the POSTGRES style outputs date-only values in ISO format.</source>
          <target state="translated">日期/时间类型的输出格式可以设置为ISO 8601，SQL（Ingres），传统POSTGRES（Unix日期格式）或德语四种样式之一。默认为ISO格式。（SQL标准要求使用ISO 8601格式。&amp;ldquo; SQL&amp;rdquo;输出格式的名称是历史性的意外。）&lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-OUTPUT-TABLE&quot;&gt;表8.14&lt;/a&gt;显示了每种输出样式的示例。根据给定示例， &lt;code&gt;date&lt;/code&gt; 和 &lt;code&gt;time&lt;/code&gt; 类型的输出通常仅是日期或时间部分。但是，POSTGRES样式以ISO格式输出仅日期的值。</target>
        </trans-unit>
        <trans-unit id="ca0d537c6aa930d0ccd3e11ab06cbea4823708c4" translate="yes" xml:space="preserve">
          <source>The output format of the interval type can be set to one of the four styles &lt;code&gt;sql_standard&lt;/code&gt;, &lt;code&gt;postgres&lt;/code&gt;, &lt;code&gt;postgres_verbose&lt;/code&gt;, or &lt;code&gt;iso_8601&lt;/code&gt;, using the command &lt;code&gt;SET intervalstyle&lt;/code&gt;. The default is the &lt;code&gt;postgres&lt;/code&gt; format. &lt;a href=&quot;datatype-datetime#INTERVAL-STYLE-OUTPUT-TABLE&quot;&gt;Table 8.18&lt;/a&gt; shows examples of each output style.</source>
          <target state="translated">使用命令 &lt;code&gt;SET intervalstyle&lt;/code&gt; ，可以将间隔类型的输出格式设置为 &lt;code&gt;sql_standard&lt;/code&gt; ， &lt;code&gt;postgres&lt;/code&gt; ， &lt;code&gt;postgres_verbose&lt;/code&gt; 或 &lt;code&gt;iso_8601&lt;/code&gt; 四种样式之一。默认为 &lt;code&gt;postgres&lt;/code&gt; 格式。&lt;a href=&quot;datatype-datetime#INTERVAL-STYLE-OUTPUT-TABLE&quot;&gt;表8.18&lt;/a&gt;显示了每种输出样式的示例。</target>
        </trans-unit>
        <trans-unit id="46e4d541f5041111722fb3ba79a2c654be039359" translate="yes" xml:space="preserve">
          <source>The output is a multiline string, with one line per node in the binary tree within the page. Only those nodes that are not zero are printed. The so-called &quot;next&quot; pointer, which points to the next slot to be returned from the page, is also printed.</source>
          <target state="translated">输出的是一个多行字符串,页面内二进制树的每个节点都有一行。只有那些不为零的节点才会被打印出来。所谓的 &quot;next &quot;指针,也会被打印出来,它指向页面中要返回的下一个槽。</target>
        </trans-unit>
        <trans-unit id="ad08831002285835cd9adfadf104f64de7aa0e5d" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;command&lt;/code&gt;, similar to ordinary &amp;ldquo;back-tick&amp;rdquo; substitution.</source>
          <target state="translated">&lt;code&gt;command&lt;/code&gt; 的输出，类似于普通的&amp;ldquo;反back&amp;rdquo;替代。</target>
        </trans-unit>
        <trans-unit id="f5a340fab5cd2f5c7335b7c6ceb29826d0789ea6" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;pg_config --configure&lt;/code&gt; contains shell quotation marks so arguments with spaces are represented correctly. Therefore, using &lt;code&gt;eval&lt;/code&gt; is required for proper results.</source>
          <target state="translated">&lt;code&gt;pg_config --configure&lt;/code&gt; 的输出包含shell引号，因此带有空格的参数可以正确表示。因此，需要使用 &lt;code&gt;eval&lt;/code&gt; 才能获得正确的结果。</target>
        </trans-unit>
        <trans-unit id="6a81f92d4917ee9ed4622690e19a83d472fca1d6" translate="yes" xml:space="preserve">
          <source>The output of the &lt;code&gt;iso_8601&lt;/code&gt; style matches the &amp;ldquo;format with designators&amp;rdquo; described in section 4.4.3.2 of the ISO 8601 standard.</source>
          <target state="translated">&lt;code&gt;iso_8601&lt;/code&gt; 样式的输出与ISO 8601标准的4.4.3.2节中描述的&amp;ldquo;带有指示符的格式&amp;rdquo;相匹配。</target>
        </trans-unit>
        <trans-unit id="2ff8c3f12c0cc1fd0eb9b2845008220be0844b33" translate="yes" xml:space="preserve">
          <source>The output of the &lt;code&gt;postgres&lt;/code&gt; style matches the output of PostgreSQL releases prior to 8.4 when the &lt;a href=&quot;runtime-config-client#GUC-DATESTYLE&quot;&gt;DateStyle&lt;/a&gt; parameter was set to &lt;code&gt;ISO&lt;/code&gt;.</source>
          <target state="translated">当&lt;a href=&quot;runtime-config-client#GUC-DATESTYLE&quot;&gt;DateStyle&lt;/a&gt;参数设置为 &lt;code&gt;ISO&lt;/code&gt; 时， &lt;code&gt;postgres&lt;/code&gt; 样式的输出与8.4之前的PostgreSQL版本的输出匹配。</target>
        </trans-unit>
        <trans-unit id="1546f3a4ad8e76189b8c8e44c823160ec87aa0b6" translate="yes" xml:space="preserve">
          <source>The output of the &lt;code&gt;postgres_verbose&lt;/code&gt; style matches the output of PostgreSQL releases prior to 8.4 when the &lt;code&gt;DateStyle&lt;/code&gt; parameter was set to non-&lt;code&gt;ISO&lt;/code&gt; output.</source>
          <target state="translated">当 &lt;code&gt;DateStyle&lt;/code&gt; 参数设置为非 &lt;code&gt;ISO&lt;/code&gt; 输出时， &lt;code&gt;postgres_verbose&lt;/code&gt; 样式的输出与8.4之前的PostgreSQL版本的输出匹配。</target>
        </trans-unit>
        <trans-unit id="c7adcbeb9a00e6f9f8d55d348527ceb949cebeb0" translate="yes" xml:space="preserve">
          <source>The output should be:</source>
          <target state="translated">输出应该是:</target>
        </trans-unit>
        <trans-unit id="7d18635316d58c0f1b2d1367a93ab0ee048d2342" translate="yes" xml:space="preserve">
          <source>The overall file layout is: open square bracket, one or more sets of curly braces each of which represents a catalog row, close square bracket. Write a comma after each closing curly brace.</source>
          <target state="translated">文件的整体布局是:打开方括号,一组或多组大括号,每组大括号代表一个目录行,关闭方括号。在每个收尾大括号后写一个逗号。</target>
        </trans-unit>
        <trans-unit id="8de7f224fb0466b959b163b48657edcd9f526ad8" translate="yes" xml:space="preserve">
          <source>The owner of a foreign server can alter user mappings for that server for any user. Also, a user can alter a user mapping for their own user name if &lt;code&gt;USAGE&lt;/code&gt; privilege on the server has been granted to the user.</source>
          <target state="translated">外部服务器的所有者可以为任何用户更改该服务器的用户映射。同样，如果已将服务器上的 &lt;code&gt;USAGE&lt;/code&gt; 特权授予该用户，则用户可以更改其自己的用户名的用户映射。</target>
        </trans-unit>
        <trans-unit id="70e088bcc4a224d8f310f80a737853c522321de9" translate="yes" xml:space="preserve">
          <source>The owner of a foreign server can create user mappings for that server for any user. Also, a user can create a user mapping for their own user name if &lt;code&gt;USAGE&lt;/code&gt; privilege on the server has been granted to the user.</source>
          <target state="translated">外部服务器的所有者可以为任何用户为该服务器创建用户映射。另外，如果已将服务器上的 &lt;code&gt;USAGE&lt;/code&gt; 特权授予该用户，则用户可以为其自己的用户名创建用户映射。</target>
        </trans-unit>
        <trans-unit id="85f81248211a9e60d13a1c97f497ca0b1b6a21d0" translate="yes" xml:space="preserve">
          <source>The owner of a foreign server can drop user mappings for that server for any user. Also, a user can drop a user mapping for their own user name if &lt;code&gt;USAGE&lt;/code&gt; privilege on the server has been granted to the user.</source>
          <target state="translated">外部服务器的所有者可以为任何用户删除该服务器的用户映射。同样，如果已将服务器上的 &lt;code&gt;USAGE&lt;/code&gt; 特权授予该用户，则用户可以删除其自己的用户名的用户映射。</target>
        </trans-unit>
        <trans-unit id="6963c00112713ecda93817baf7fc7475ab9e7155" translate="yes" xml:space="preserve">
          <source>The papal bull of February 1582 decreed that 10 days should be dropped from October 1582 so that 15 October should follow immediately after 4 October. This was observed in Italy, Poland, Portugal, and Spain. Other Catholic countries followed shortly after, but Protestant countries were reluctant to change, and the Greek Orthodox countries didn't change until the start of the 20th century. The reform was observed by Great Britain and its dominions (including what is now the USA) in 1752. Thus 2 September 1752 was followed by 14 September 1752. This is why Unix systems that have the &lt;code&gt;cal&lt;/code&gt; program produce the following:</source>
          <target state="translated">1582年2月的罗马教皇公牛宣布，从1582年10月起，应删除10天，以便在10月4日之后立即跟随10月15日。在意大利，波兰，葡萄牙和西班牙观察到这种情况。此后不久，其他天主教国家也紧随其后，但新教国家不愿改变，希腊东正教国家直到20世纪初才改变。1752年，英国及其统治地区（包括现在的美国）进行了改革。因此1752年9月2日之后是1752年9月14日。这就是为什么使用 &lt;code&gt;cal&lt;/code&gt; 程序的Unix系统产生以下内容的原因：</target>
        </trans-unit>
        <trans-unit id="265188275c6e5e56d9f827410bd00598d6ffb2ea" translate="yes" xml:space="preserve">
          <source>The parameter &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-ACTIVITIES&quot;&gt;track_activities&lt;/a&gt; enables monitoring of the current command being executed by any server process.</source>
          <target state="translated">参数&lt;a href=&quot;runtime-config-statistics#GUC-TRACK-ACTIVITIES&quot;&gt;track_activities&lt;/a&gt;允许监视任何服务器进程正在执行的当前命令。</target>
        </trans-unit>
        <trans-unit id="e1be1796cec7a4cb2472b6d31337e6a73b1f4697" translate="yes" xml:space="preserve">
          <source>The parameter &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-COUNTS&quot;&gt;track_counts&lt;/a&gt; controls whether statistics are collected about table and index accesses.</source>
          <target state="translated">参数&lt;a href=&quot;runtime-config-statistics#GUC-TRACK-COUNTS&quot;&gt;track_counts&lt;/a&gt;控制是否收集有关表和索引访问的统计信息。</target>
        </trans-unit>
        <trans-unit id="c3e68d3468b41bd94198c06d139a59af78cfd7be" translate="yes" xml:space="preserve">
          <source>The parameter &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-FUNCTIONS&quot;&gt;track_functions&lt;/a&gt; enables tracking of usage of user-defined functions.</source>
          <target state="translated">参数&lt;a href=&quot;runtime-config-statistics#GUC-TRACK-FUNCTIONS&quot;&gt;track_functions&lt;/a&gt;允许跟踪用户定义函数的使用。</target>
        </trans-unit>
        <trans-unit id="8df18f4279a1a3adf31a5aebfa3bc87053f75fc7" translate="yes" xml:space="preserve">
          <source>The parameter &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-IO-TIMING&quot;&gt;track_io_timing&lt;/a&gt; enables monitoring of block read and write times.</source>
          <target state="translated">参数&lt;a href=&quot;runtime-config-statistics#GUC-TRACK-IO-TIMING&quot;&gt;track_io_timing&lt;/a&gt;允许监视块的读写时间。</target>
        </trans-unit>
        <trans-unit id="fc99094ae896ae637595cea62c377dc56ce6f9fd" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;count&lt;/code&gt; specifies the maximum number of rows to return, while &lt;code&gt;start&lt;/code&gt; specifies the number of rows to skip before starting to return rows. When both are specified, &lt;code&gt;start&lt;/code&gt; rows are skipped before starting to count the &lt;code&gt;count&lt;/code&gt; rows to be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d547546da964747acd19cdd9eb1f2bdf8c4f57e8" translate="yes" xml:space="preserve">
          <source>The parameter &lt;em&gt;&lt;code&gt;nulls&lt;/code&gt;&lt;/em&gt; determines whether null values should be included in the output. If true, null values in columns are represented as:</source>
          <target state="translated">参数&lt;em&gt; &lt;code&gt;nulls&lt;/code&gt; &lt;/em&gt;确定输出中是否应包含null值。如果为true，则列中的空值表示为：</target>
        </trans-unit>
        <trans-unit id="0b194e705f492d2a9e697965a54eb7bc8ec38435" translate="yes" xml:space="preserve">
          <source>The parameter &lt;em&gt;&lt;code&gt;targetns&lt;/code&gt;&lt;/em&gt; specifies the desired XML namespace of the result. If no particular namespace is wanted, an empty string should be passed.</source>
          <target state="translated">参数&lt;em&gt; &lt;code&gt;targetns&lt;/code&gt; &lt;/em&gt;指定结果的所需XML名称空间。如果不需要特定的名称空间，则应传递一个空字符串。</target>
        </trans-unit>
        <trans-unit id="9da16630f92a321b59e356eb1f16f45959c31e24" translate="yes" xml:space="preserve">
          <source>The parameter data type(s) of the function.</source>
          <target state="translated">函数的参数数据类型。</target>
        </trans-unit>
        <trans-unit id="5d10e331ebaa600753d0a6fe423faa9e38a0555a" translate="yes" xml:space="preserve">
          <source>The parameter is the name of a table. The result is a set of records, with one row for each locked row within the table. The output columns are shown in &lt;a href=&quot;pgrowlocks#PGROWLOCKS-COLUMNS&quot;&gt;Table F.20&lt;/a&gt;.</source>
          <target state="translated">该参数是表的名称。结果是一组记录，表中的每个锁定行都有一行。输出列显示在&lt;a href=&quot;pgrowlocks#PGROWLOCKS-COLUMNS&quot;&gt;表F.20中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2c2a6968b73a82456119add43eff37f88e4a3336" translate="yes" xml:space="preserve">
          <source>The parameter name</source>
          <target state="translated">参数名称</target>
        </trans-unit>
        <trans-unit id="10634e221a9f53cda3c36547bc9c020dce985fe4" translate="yes" xml:space="preserve">
          <source>The parameter symbols used to replace constants in representative query texts start from the next number after the highest &lt;code&gt;$&lt;/code&gt;&lt;code&gt;n&lt;/code&gt; parameter in the original query text, or &lt;code&gt;$1&lt;/code&gt; if there was none. It's worth noting that in some cases there may be hidden parameter symbols that affect this numbering. For example, PL/pgSQL uses hidden parameter symbols to insert values of function local variables into queries, so that a PL/pgSQL statement like &lt;code&gt;SELECT i + 1 INTO j&lt;/code&gt; would have representative text like &lt;code&gt;SELECT i + $2&lt;/code&gt;.</source>
          <target state="translated">用于替换代表性查询文本中常量的参数符号从原始查询文本中最高 &lt;code&gt;$&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; 参数之后的下一个数字开始，如果没有 &lt;code&gt;$1&lt;/code&gt; 。值得注意的是，在某些情况下，可能存在影响此编号的隐藏参数符号。例如，PL / pgSQL使用隐藏的参数符号将函数局部变量的值插入查询中，因此，像 &lt;code&gt;SELECT i + 1 INTO j&lt;/code&gt; 这样的PL / pgSQL语句将具有代表文本，例如 &lt;code&gt;SELECT i + $2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61c677b727193bb37a9911ff1962107228c69d5b" translate="yes" xml:space="preserve">
          <source>The parameter value</source>
          <target state="translated">参数值</target>
        </trans-unit>
        <trans-unit id="bbcaadaf51c94b64fefad474400e1f3834e2ed35" translate="yes" xml:space="preserve">
          <source>The parameters can appear in any order, not only that illustrated above, and most are optional. You must register two or more functions (using &lt;code&gt;CREATE FUNCTION&lt;/code&gt;) before defining the type. The support functions &lt;code&gt;input_function&lt;/code&gt; and &lt;code&gt;output_function&lt;/code&gt; are required, while the functions &lt;code&gt;receive_function&lt;/code&gt;, &lt;code&gt;send_function&lt;/code&gt;, &lt;code&gt;type_modifier_input_function&lt;/code&gt;, &lt;code&gt;type_modifier_output_function&lt;/code&gt; and &lt;code&gt;analyze_function&lt;/code&gt; are optional. Generally these functions have to be coded in C or another low-level language.</source>
          <target state="translated">参数可以以任何顺序出现，不仅是上面显示的顺序，而且大多数是可选的。在定义类型之前，必须注册两个或多个函数（使用 &lt;code&gt;CREATE FUNCTION&lt;/code&gt; ）。支持功能 &lt;code&gt;input_function&lt;/code&gt; 和 &lt;code&gt;output_function&lt;/code&gt; 是必需的，而函数 &lt;code&gt;receive_function&lt;/code&gt; ， &lt;code&gt;send_function&lt;/code&gt; ， &lt;code&gt;type_modifier_input_function&lt;/code&gt; ， &lt;code&gt;type_modifier_output_function&lt;/code&gt; 和 &lt;code&gt;analyze_function&lt;/code&gt; 是可选的。通常，这些功能必须使用C或其他低级语言进行编码。</target>
        </trans-unit>
        <trans-unit id="35c28a20bb52660d5ea22014191009de5ae11925" translate="yes" xml:space="preserve">
          <source>The parameters for the &lt;code&gt;MOVE&lt;/code&gt; command are identical to those of the &lt;code&gt;FETCH&lt;/code&gt; command; refer to &lt;a href=&quot;sql-fetch&quot;&gt;FETCH&lt;/a&gt; for details on syntax and usage.</source>
          <target state="translated">&lt;code&gt;MOVE&lt;/code&gt; 命令的参数与 &lt;code&gt;FETCH&lt;/code&gt; 命令的参数相同。有关语法和用法的详细信息，请参阅&lt;a href=&quot;sql-fetch&quot;&gt;FETCH&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c486bfa67e493a85ca76bb0a5dfe71e780089bca" translate="yes" xml:space="preserve">
          <source>The parameters of &lt;code&gt;CREATE AGGREGATE&lt;/code&gt; can be written in any order, not just the order illustrated above.</source>
          <target state="translated">&lt;code&gt;CREATE AGGREGATE&lt;/code&gt; 的参数可以以任何顺序编写，而不仅仅是上面说明的顺序。</target>
        </trans-unit>
        <trans-unit id="d0f868092f1804769e10c18a42faa0f07b1980df" translate="yes" xml:space="preserve">
          <source>The parameters representing table and field names are copied as-is into the SQL queries that &lt;code&gt;connectby&lt;/code&gt; generates internally. Therefore, include double quotes if the names are mixed-case or contain special characters. You may also need to schema-qualify the table name.</source>
          <target state="translated">代表表名和字段名的参数按原样复制到 &lt;code&gt;connectby&lt;/code&gt; 内部生成的SQL查询中。因此，如果名称是大小写混合的或包含特殊字符，请用双引号引起来。您可能还需要对表名进行模式限定。</target>
        </trans-unit>
        <trans-unit id="7230bb5c0f71b8c1dd5a14e1c76f97c166b31063" translate="yes" xml:space="preserve">
          <source>The parentheses are required here to show that &lt;code&gt;compositecol&lt;/code&gt; is a column name not a table name, or that &lt;code&gt;mytable&lt;/code&gt; is a table name not a schema name in the second case.</source>
          <target state="translated">在第二种情况下，这里需要使用括号来表明 &lt;code&gt;compositecol&lt;/code&gt; 是列名而不是表名，或者 &lt;code&gt;mytable&lt;/code&gt; 是表名而不是架构名。</target>
        </trans-unit>
        <trans-unit id="3872d508fa039522a5d3058284138f504197106f" translate="yes" xml:space="preserve">
          <source>The parentheses in the last example are required. See &lt;a href=&quot;arrays&quot;&gt;Section 8.15&lt;/a&gt; for more about arrays.</source>
          <target state="translated">最后一个示例中的括号是必需的。有关数组的更多信息，请参见&lt;a href=&quot;arrays&quot;&gt;第8.15节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ba38ce516ae1d7c833e7896243109df28d306a9d" translate="yes" xml:space="preserve">
          <source>The parentheses or brackets indicate whether the lower and upper bounds are exclusive or inclusive, as described previously. Notice that the final pattern is &lt;code&gt;empty&lt;/code&gt;, which represents an empty range (a range that contains no points).</source>
          <target state="translated">如前所述，括号或方括号指示上限和下限是互斥的还是包含的。请注意，最终模式为 &lt;code&gt;empty&lt;/code&gt; ，它表示一个空范围（不包含点的范围）。</target>
        </trans-unit>
        <trans-unit id="09b446449a4319a7ef9115b3be9989109d17ce7e" translate="yes" xml:space="preserve">
          <source>The parser has to check the query string (which arrives as plain text) for valid syntax. If the syntax is correct a &lt;em&gt;parse tree&lt;/em&gt; is built up and handed back; otherwise an error is returned. The parser and lexer are implemented using the well-known Unix tools bison and flex.</source>
          <target state="translated">解析器必须检查查询字符串（以纯文本形式到达）的有效语法。如果语法正确，则将建立一个&lt;em&gt;解析树&lt;/em&gt;并递归；否则返回错误。解析器和词法分析器使用著名的Unix工具bison和flex实现。</target>
        </trans-unit>
        <trans-unit id="6ff5674ed423bd0fd40e474001e355555798b1f1" translate="yes" xml:space="preserve">
          <source>The parser initially marks the constants as being of type &lt;code&gt;integer&lt;/code&gt; and &lt;code&gt;numeric&lt;/code&gt; respectively. There is no &lt;code&gt;integer&lt;/code&gt;&lt;code&gt;+&lt;/code&gt;&lt;code&gt;numeric&lt;/code&gt; operator in the system catalogs, but there is a &lt;code&gt;numeric&lt;/code&gt;&lt;code&gt;+&lt;/code&gt;&lt;code&gt;numeric&lt;/code&gt; operator. The query will therefore succeed if a cast from &lt;code&gt;integer&lt;/code&gt; to &lt;code&gt;numeric&lt;/code&gt; is available and is marked &lt;code&gt;AS IMPLICIT&lt;/code&gt; &amp;mdash; which in fact it is. The parser will apply the implicit cast and resolve the query as if it had been written</source>
          <target state="translated">解析器最初将常量标记为 &lt;code&gt;integer&lt;/code&gt; 和 &lt;code&gt;numeric&lt;/code&gt; 类型。系统目录中没有 &lt;code&gt;integer&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;numeric&lt;/code&gt; 运算符，但是有 &lt;code&gt;numeric&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;numeric&lt;/code&gt; 运算符。因此，如果可以使用从 &lt;code&gt;integer&lt;/code&gt; 到 &lt;code&gt;numeric&lt;/code&gt; 的转换并将其标记为 &lt;code&gt;AS IMPLICIT&lt;/code&gt; （实际上是），则查询将成功。解析器将应用隐式强制转换并解析查询，就像它已经被编写一样</target>
        </trans-unit>
        <trans-unit id="25f13c18d68a86fdbefd4291a356d75813cdb2e5" translate="yes" xml:space="preserve">
          <source>The parser is defined in the file &lt;code&gt;gram.y&lt;/code&gt; and consists of a set of &lt;em&gt;grammar rules&lt;/em&gt; and &lt;em&gt;actions&lt;/em&gt; that are executed whenever a rule is fired. The code of the actions (which is actually C code) is used to build up the parse tree.</source>
          <target state="translated">解析器在文件 &lt;code&gt;gram.y&lt;/code&gt; 中定义，由一组&lt;em&gt;语法规则&lt;/em&gt;和每当触发规则时执行的&lt;em&gt;动作&lt;/em&gt;组成。操作代码（实际上是C代码）用于构建解析树。</target>
        </trans-unit>
        <trans-unit id="1857339fc15ab225bd01ccd9d926ca70975b0fc9" translate="yes" xml:space="preserve">
          <source>The parser learns from the &lt;code&gt;pg_cast&lt;/code&gt; catalog that &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;varchar&lt;/code&gt; are binary-compatible, meaning that one can be passed to a function that accepts the other without doing any physical conversion. Therefore, no type conversion call is really inserted in this case.</source>
          <target state="translated">解析器从 &lt;code&gt;pg_cast&lt;/code&gt; 目录中得知 &lt;code&gt;text&lt;/code&gt; 和 &lt;code&gt;varchar&lt;/code&gt; 是二进制兼容的，这意味着一个可以传递给接受另一个的函数，而无需进行任何物理转换。因此，在这种情况下，实际上不会插入任何类型转换调用。</target>
        </trans-unit>
        <trans-unit id="0e756c19d42be08cb71cc09834d6f8f8f843f91e" translate="yes" xml:space="preserve">
          <source>The parser stage creates a parse tree using only fixed rules about the syntactic structure of SQL. It does not make any lookups in the system catalogs, so there is no possibility to understand the detailed semantics of the requested operations. After the parser completes, the &lt;em&gt;transformation process&lt;/em&gt; takes the tree handed back by the parser as input and does the semantic interpretation needed to understand which tables, functions, and operators are referenced by the query. The data structure that is built to represent this information is called the &lt;em&gt;query tree&lt;/em&gt;.</source>
          <target state="translated">解析器阶段仅使用有关SQL语法结构的固定规则来创建解析树。它不会在系统目录中进行任何查找，因此无法了解所请求操作的详细语义。解析器完成后，&lt;em&gt;转换过程&lt;/em&gt;将解析器返回的树作为输入，并进行语义解释以了解查询所引用的表，函数和运算符。用来表示此信息的数据结构称为&lt;em&gt;查询树&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="ebdbb42aa00d24e0d513d01a8c9b666b615ba1dd" translate="yes" xml:space="preserve">
          <source>The parser's notion of a &amp;ldquo;letter&amp;rdquo; is determined by the database's locale setting, specifically &lt;code&gt;lc_ctype&lt;/code&gt;. Words containing only the basic ASCII letters are reported as a separate token type, since it is sometimes useful to distinguish them. In most European languages, token types &lt;code&gt;word&lt;/code&gt; and &lt;code&gt;asciiword&lt;/code&gt; should be treated alike.</source>
          <target state="translated">解析器的&amp;ldquo;字母&amp;rdquo;概念由数据库的语言环境设置（特别是 &lt;code&gt;lc_ctype&lt;/code&gt; )确定。仅包含基本ASCII字母的单词被报告为单独的令牌类型，因为有时区分它们有时很有用。在大多数欧洲语言中，应将令牌类型 &lt;code&gt;word&lt;/code&gt; 和 &lt;code&gt;asciiword&lt;/code&gt; 视为相同。</target>
        </trans-unit>
        <trans-unit id="9c43fc6c8c7c3f14d277b633b89dfade64caf03b" translate="yes" xml:space="preserve">
          <source>The part of PostgreSQL that is devoted to determining (&lt;em&gt;planning&lt;/em&gt;) the most efficient way to execute &lt;a href=&quot;glossary#GLOSSARY-QUERY&quot;&gt;queries&lt;/a&gt;. Also known as &lt;em&gt;query optimizer&lt;/em&gt;, &lt;em&gt;optimizer&lt;/em&gt;, or simply &lt;em&gt;planner&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a4e5a431eb644b141f3790b8cfbc5fd53514f52" translate="yes" xml:space="preserve">
          <source>The partial transaction isolation provided by Read Committed mode is adequate for many applications, and this mode is fast and simple to use; however, it is not sufficient for all cases. Applications that do complex queries and updates might require a more rigorously consistent view of the database than Read Committed mode provides.</source>
          <target state="translated">Read Committed模式提供的部分事务隔离对许多应用来说是足够的,这种模式使用起来快速而简单;但是,它并不是对所有情况都足够。做复杂查询和更新的应用程序可能需要比读承诺模式提供的数据库视图更加严格一致。</target>
        </trans-unit>
        <trans-unit id="eb9b101fa3ff04c41a301e2ea58c51b731736d02" translate="yes" xml:space="preserve">
          <source>The partition bound specification for a new partition. Refer to &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for more details on the syntax of the same.</source>
          <target state="translated">新分区的分区绑定规范。有关相同语法的更多详细信息，请参考&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a843f1857d3445c37bfb25c214ac7c60e2eda3b2" translate="yes" xml:space="preserve">
          <source>The password is always stored encrypted in the system catalogs. The &lt;code&gt;ENCRYPTED&lt;/code&gt; keyword has no effect, but is accepted for backwards compatibility. The method of encryption is determined by the configuration parameter &lt;a href=&quot;runtime-config-connection#GUC-PASSWORD-ENCRYPTION&quot;&gt;password_encryption&lt;/a&gt;. If the presented password string is already in MD5-encrypted or SCRAM-encrypted format, then it is stored as-is regardless of &lt;code&gt;password_encryption&lt;/code&gt; (since the system cannot decrypt the specified encrypted password string, to encrypt it in a different format). This allows reloading of encrypted passwords during dump/restore.</source>
          <target state="translated">密码始终以加密方式存储在系统目录中。该 &lt;code&gt;ENCRYPTED&lt;/code&gt; 关键字没有作用，但是接受向后兼容性。加密方法由配置参数&lt;a href=&quot;runtime-config-connection#GUC-PASSWORD-ENCRYPTION&quot;&gt;password_encryption&lt;/a&gt;确定。如果显示的密码字符串已经采用MD5加密或SCRAM加密的格式，则无论 &lt;code&gt;password_encryption&lt;/code&gt; 如何都按原样存储（因为系统无法解密指定的加密密码字符串，因此无法以其他格式对其进行加密）。这样可以在转储/还原期间重新加载加密的密码。</target>
        </trans-unit>
        <trans-unit id="d6a56dd735da3ef3f125939acf3298322bea99f6" translate="yes" xml:space="preserve">
          <source>The path at your site might be different. Contact your site administrator or check the installation instructions to correct the situation.</source>
          <target state="translated">您网站的路径可能不同。请联系您的站点管理员或查看安装说明以纠正这种情况。</target>
        </trans-unit>
        <trans-unit id="ae4a259e6f096215a3bc76dbbbf4ab5a1fa7063f" translate="yes" xml:space="preserve">
          <source>The path expression contains &lt;code&gt;type()&lt;/code&gt; or &lt;code&gt;size()&lt;/code&gt; methods that return the type and the number of elements in the array, respectively.</source>
          <target state="translated">路径表达式包含 &lt;code&gt;type()&lt;/code&gt; 或 &lt;code&gt;size()&lt;/code&gt; 方法，分别返回数组中元素的类型和数量。</target>
        </trans-unit>
        <trans-unit id="665f879c5dd1bad744ce39b38be0ec7bfa475f6e" translate="yes" xml:space="preserve">
          <source>The path name of the input or output file. An input file name can be an absolute or relative path, but an output file name must be an absolute path. Windows users might need to use an &lt;code&gt;E''&lt;/code&gt; string and double any backslashes used in the path name.</source>
          <target state="translated">输入或输出文件的路径名。输入文件名可以是绝对路径或相对路径，但是输出文件名必须是绝对路径。Windows用户可能需要使用 &lt;code&gt;E''&lt;/code&gt; 字符串并将路径名中使用的所有反斜杠加倍。</target>
        </trans-unit>
        <trans-unit id="acfece2d4d4a40c54bd9f721a413e8f8e6ea9b4c" translate="yes" xml:space="preserve">
          <source>The pattern characters &lt;code&gt;S&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;D&lt;/code&gt;, and &lt;code&gt;G&lt;/code&gt; represent the sign, currency symbol, decimal point, and thousands separator characters defined by the current locale (see &lt;a href=&quot;runtime-config-client#GUC-LC-MONETARY&quot;&gt;lc_monetary&lt;/a&gt; and &lt;a href=&quot;runtime-config-client#GUC-LC-NUMERIC&quot;&gt;lc_numeric&lt;/a&gt;). The pattern characters period and comma represent those exact characters, with the meanings of decimal point and thousands separator, regardless of locale.</source>
          <target state="translated">模式字符 &lt;code&gt;S&lt;/code&gt; ， &lt;code&gt;L&lt;/code&gt; ， &lt;code&gt;D&lt;/code&gt; 和 &lt;code&gt;G&lt;/code&gt; 表示符号，货币符号，小数点和由当前语言环境定义的数千个分隔符（请参见&lt;a href=&quot;runtime-config-client#GUC-LC-MONETARY&quot;&gt;lc_monetary&lt;/a&gt;和&lt;a href=&quot;runtime-config-client#GUC-LC-NUMERIC&quot;&gt;lc_numeric&lt;/a&gt;）。模式字符的句点和逗号表示这些确切的字符，具有小数点和千位分隔符的含义，与语言环境无关。</target>
        </trans-unit>
        <trans-unit id="0f3ba6e11e445232d30834cd144281a86bebafa9" translate="yes" xml:space="preserve">
          <source>The pattern matching operators of all three kinds do not support nondeterministic collations. If required, apply a different collation to the expression to work around this limitation.</source>
          <target state="translated">所有三种模式匹配运算符都不支持非确定性的整理。如果需要,可以在表达式中应用不同的排列方式来解决这个限制。</target>
        </trans-unit>
        <trans-unit id="53ad7762f98479cbca28b8363660cbfe1cf95173" translate="yes" xml:space="preserve">
          <source>The payload of the notifications consists of the table name, a letter to indicate which type of operation was performed, and column name/value pairs for primary key columns. Each part is separated from the next by a comma. For ease of parsing using regular expressions, table and column names are always wrapped in double quotes, and data values are always wrapped in single quotes. Embedded quotes are doubled.</source>
          <target state="translated">通知的有效载荷包括表名、表示执行了哪种类型操作的字母以及主键列的列名/值对。每个部分之间用逗号隔开。为了便于使用正则表达式进行解析,表名和列名总是用双引号包裹,数据值总是用单引号包裹。嵌入的引号是双引号。</target>
        </trans-unit>
        <trans-unit id="99b6bf90a9bb8e6d618127a1a2c46cd208469261" translate="yes" xml:space="preserve">
          <source>The peer authentication method works by obtaining the client's operating system user name from the kernel and using it as the allowed database user name (with optional user name mapping). This method is only supported on local connections.</source>
          <target state="translated">对等体认证方法的工作原理是从内核获取客户端的操作系统用户名,并将其作为允许的数据库用户名(可选择用户名映射)。这种方法只支持本地连接。</target>
        </trans-unit>
        <trans-unit id="919e0066d8303b60f8d9dce39383d269124b1827" translate="yes" xml:space="preserve">
          <source>The per-index statistics are particularly useful to determine which indexes are being used and how effective they are.</source>
          <target state="translated">每个指数的统计数据对于确定哪些指数被使用以及它们的效果如何特别有用。</target>
        </trans-unit>
        <trans-unit id="2b32037bdcf53d4293fda5e00a43bb07b50f376a" translate="yes" xml:space="preserve">
          <source>The performance of an R-tree index can largely depend on the initial order of input values. It may be very helpful to sort the input table on the &lt;code&gt;seg&lt;/code&gt; column; see the script &lt;code&gt;sort-segments.pl&lt;/code&gt; for an example.</source>
          <target state="translated">R树索引的性能在很大程度上取决于输入值的初始顺序。在 &lt;code&gt;seg&lt;/code&gt; 列上对输入表进行排序可能非常有帮助；有关示例，请参见脚本 &lt;code&gt;sort-segments.pl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="794af340a68964153b03ef2b6d22753d285cf9d8" translate="yes" xml:space="preserve">
          <source>The period (&lt;code&gt;.&lt;/code&gt;) is used in numeric constants, and to separate schema, table, and column names.</source>
          <target state="translated">句点（ &lt;code&gt;.&lt;/code&gt; ）用于数字常量，并用于分隔模式，表和列名。</target>
        </trans-unit>
        <trans-unit id="1dd06a0691afe3884d57662cd23df0c2e7cc6503" translate="yes" xml:space="preserve">
          <source>The pg_config utility prints configuration parameters of the currently installed version of PostgreSQL. It is intended, for example, to be used by software packages that want to interface to PostgreSQL to facilitate finding the required header files and libraries.</source>
          <target state="translated">pg_config工具可以打印当前安装的PostgreSQL版本的配置参数。例如,它的目的是让那些想与PostgreSQL接口的软件包使用,以方便查找所需的头文件和库。</target>
        </trans-unit>
        <trans-unit id="38257de71aaf3c94498314a3023e95f97988a3ee" translate="yes" xml:space="preserve">
          <source>The phenomena which are prohibited at various levels are:</source>
          <target state="translated">各级禁止的现象有:</target>
        </trans-unit>
        <trans-unit id="23f998eae14382a70d2324fb449ffb907b06c285" translate="yes" xml:space="preserve">
          <source>The phrases &lt;code&gt;LIKE&lt;/code&gt;, &lt;code&gt;ILIKE&lt;/code&gt;, &lt;code&gt;NOT LIKE&lt;/code&gt;, and &lt;code&gt;NOT ILIKE&lt;/code&gt; are generally treated as operators in PostgreSQL syntax; for example they can be used in &lt;code&gt;expression&lt;/code&gt;&lt;code&gt;operator&lt;/code&gt; ANY (&lt;code&gt;subquery&lt;/code&gt;) constructs, although an &lt;code&gt;ESCAPE&lt;/code&gt; clause cannot be included there. In some obscure cases it may be necessary to use the underlying operator names instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb2bc77065c28244748a514edbbf72d360f29dfc" translate="yes" xml:space="preserve">
          <source>The physical location of the row version within its table. Note that although the &lt;code&gt;ctid&lt;/code&gt; can be used to locate the row version very quickly, a row's &lt;code&gt;ctid&lt;/code&gt; will change if it is updated or moved by &lt;code&gt;VACUUM FULL&lt;/code&gt;. Therefore &lt;code&gt;ctid&lt;/code&gt; is useless as a long-term row identifier. A primary key should be used to identify logical rows.</source>
          <target state="translated">行版本在其表中的物理位置。请注意，尽管可以使用 &lt;code&gt;ctid&lt;/code&gt; 来快速定位行版本，但是如果通过 &lt;code&gt;VACUUM FULL&lt;/code&gt; 更新或移动了该行的 &lt;code&gt;ctid&lt;/code&gt; ,则该ctid将会更改。因此， &lt;code&gt;ctid&lt;/code&gt; 不能用作长期行标识符。应该使用主键来标识逻辑行。</target>
        </trans-unit>
        <trans-unit id="ed43e04d92b420464b4279a7468ab8888b8672c6" translate="yes" xml:space="preserve">
          <source>The planner assumes that the two conditions are independent, so that the individual selectivities of the clauses can be multiplied together:</source>
          <target state="translated">规划师假设这两个条件是独立的,那么各个条款的选择性就可以相乘。</target>
        </trans-unit>
        <trans-unit id="5f8b19a5896d87add8af3e241d28d22aabc60ce5" translate="yes" xml:space="preserve">
          <source>The planner cannot automatically determine whether a user-defined function or aggregate is parallel safe, parallel restricted, or parallel unsafe, because this would require predicting every operation which the function could possibly perform. In general, this is equivalent to the Halting Problem and therefore impossible. Even for simple functions where it could conceivably be done, we do not try, since this would be expensive and error-prone. Instead, all user-defined functions are assumed to be parallel unsafe unless otherwise marked. When using &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; or &lt;a href=&quot;sql-alterfunction&quot;&gt;ALTER FUNCTION&lt;/a&gt;, markings can be set by specifying &lt;code&gt;PARALLEL SAFE&lt;/code&gt;, &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt;, or &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; as appropriate. When using &lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt;, the &lt;code&gt;PARALLEL&lt;/code&gt; option can be specified with &lt;code&gt;SAFE&lt;/code&gt;, &lt;code&gt;RESTRICTED&lt;/code&gt;, or &lt;code&gt;UNSAFE&lt;/code&gt; as the corresponding value.</source>
          <target state="translated">计划者无法自动确定用户定义的函数或集合是并行安全的，并行受限的还是并行不安全的，因为这将需要预测该函数可能执行的每个操作。通常，这等效于停止问题，因此是不可能的。即使对于可能可以实现的简单功能，我们也不会尝试，因为这样做会很昂贵并且容易出错。取而代之的是，除非另有说明，否则所有用户定义函数均假定为并行不安全的。使用&lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;或&lt;a href=&quot;sql-alterfunction&quot;&gt;ALTER FUNCTION时&lt;/a&gt;，可以通过指定 &lt;code&gt;PARALLEL SAFE&lt;/code&gt; ， &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; 或 &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; 来设置标记。使用时&lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt;，可以使用 &lt;code&gt;SAFE&lt;/code&gt; ， &lt;code&gt;RESTRICTED&lt;/code&gt; 或 &lt;code&gt;UNSAFE&lt;/code&gt; 作为对应值来指定 &lt;code&gt;PARALLEL&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="9b371bcb4f76e8388ab2f98830da7c42b56f6e59" translate="yes" xml:space="preserve">
          <source>The planner classifies operations involved in a query as either &lt;em&gt;parallel safe&lt;/em&gt;, &lt;em&gt;parallel restricted&lt;/em&gt;, or &lt;em&gt;parallel unsafe&lt;/em&gt;. A parallel safe operation is one which does not conflict with the use of parallel query. A parallel restricted operation is one which cannot be performed in a parallel worker, but which can be performed in the leader while parallel query is in use. Therefore, parallel restricted operations can never occur below a &lt;code&gt;Gather&lt;/code&gt; or &lt;code&gt;Gather Merge&lt;/code&gt; node, but can occur elsewhere in a plan which contains such a node. A parallel unsafe operation is one which cannot be performed while parallel query is in use, not even in the leader. When a query contains anything which is parallel unsafe, parallel query is completely disabled for that query.</source>
          <target state="translated">计划者将查询中涉及的操作分类为&lt;em&gt;并行安全&lt;/em&gt;，&lt;em&gt;并行受限&lt;/em&gt;或&lt;em&gt;并行不安全&lt;/em&gt;。并行安全操作是一种与并行查询的使用不冲突的操作。并行受限操作是不能在并行工作程序中执行的操作，但是可以在使用并行查询时在领导者中执行。因此，并行限制操作永远不会在&amp;ldquo; &lt;code&gt;Gather&lt;/code&gt; 或&amp;ldquo; &lt;code&gt;Gather Merge&lt;/code&gt; 节点，但可以出现在包含此类节点的计划中的其他位置。并行不安全操作是在使用并行查询时无法执行的操作，即使在领导者中也是如此。当查询包含并行不安全的任何内容时，该查询将完全禁用并行查询。</target>
        </trans-unit>
        <trans-unit id="41ec537c1145f33dc399ea4d0d8e72c677f37799" translate="yes" xml:space="preserve">
          <source>The planner estimates the selectivity for each condition individually, arriving at the same 1% estimates as above. Then it assumes that the conditions are independent, and so it multiplies their selectivities, producing a final selectivity estimate of just 0.01%. This is a significant underestimate, as the actual number of rows matching the conditions (100) is two orders of magnitude higher.</source>
          <target state="translated">规划者估计每个条件的选择性,得出与上述相同的1%的估计值。然后它假设这些条件是独立的,因此它乘以它们的选择性,得出最终的选择性估计值只有0.01%。这是一个明显的低估,因为符合条件的实际行数(100)要高出两个数量级。</target>
        </trans-unit>
        <trans-unit id="12ef35e8963b60e1a1f66c8c5c86ede0e85c0b68" translate="yes" xml:space="preserve">
          <source>The planner examines the &lt;code&gt;WHERE&lt;/code&gt; clause condition and looks up the selectivity function for the operator &lt;code&gt;&amp;lt;&lt;/code&gt; in &lt;code&gt;pg_operator&lt;/code&gt;. This is held in the column &lt;code&gt;oprrest&lt;/code&gt;, and the entry in this case is &lt;code&gt;scalarltsel&lt;/code&gt;. The &lt;code&gt;scalarltsel&lt;/code&gt; function retrieves the histogram for &lt;code&gt;unique1&lt;/code&gt; from &lt;code&gt;pg_statistic&lt;/code&gt;. For manual queries it is more convenient to look in the simpler &lt;code&gt;pg_stats&lt;/code&gt; view:</source>
          <target state="translated">计划者检查 &lt;code&gt;WHERE&lt;/code&gt; 子句条件，并在 &lt;code&gt;pg_operator&lt;/code&gt; 中查找运算符 &lt;code&gt;&amp;lt;&lt;/code&gt; 的选择性函数。这保存在 &lt;code&gt;oprrest&lt;/code&gt; 列中，在这种情况下，条目为 &lt;code&gt;scalarltsel&lt;/code&gt; 。该 &lt;code&gt;scalarltsel&lt;/code&gt; 功能检索直方图 &lt;code&gt;unique1&lt;/code&gt; 从 &lt;code&gt;pg_statistic&lt;/code&gt; 里。对于手动查询，在更简单的 &lt;code&gt;pg_stats&lt;/code&gt; 视图中查找更为方便：</target>
        </trans-unit>
        <trans-unit id="55eece76171cb5150093319bc0d23d3c3262a30e" translate="yes" xml:space="preserve">
          <source>The planner examines the condition and determines the selectivity of this clause to be 1%. By comparing this estimate and the actual number of rows, we see that the estimate is very accurate (in fact exact, as the table is very small). Changing the &lt;code&gt;WHERE&lt;/code&gt; condition to use the &lt;code&gt;b&lt;/code&gt; column, an identical plan is generated. But observe what happens if we apply the same condition on both columns, combining them with &lt;code&gt;AND&lt;/code&gt;:</source>
          <target state="translated">计划者检查条件并将该子句的选择性确定为1％。通过将该估算值与实际的行数进行比较，我们可以看到估算值非常准确（实际上是准确的，因为表很小）。将 &lt;code&gt;WHERE&lt;/code&gt; 条件更改为使用 &lt;code&gt;b&lt;/code&gt; 列，将生成相同的计划。但是，观察，如果我们应用在两列相同的条件下，它们相结合会发生什么 &lt;code&gt;AND&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7a1338924ef7e4d51c210a157253f9f111c3a5a5" translate="yes" xml:space="preserve">
          <source>The planner may implement an &lt;code&gt;ORDER BY&lt;/code&gt; clause in several ways. The above example shows that such an ordering clause may be implemented implicitly. The planner may also add an explicit &lt;code&gt;sort&lt;/code&gt; step:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccbe97e96812fba17e36b64c7a8a14a6a5fc672b" translate="yes" xml:space="preserve">
          <source>The planner thinks (quite correctly) that this sample table is too small to bother with an index scan, so we have a plain sequential scan in which all the rows got rejected by the filter condition. But if we force an index scan to be used, we see:</source>
          <target state="translated">规划师认为(非常正确),这个样本表太小了,不需要进行索引扫描,所以我们进行了普通的顺序扫描,其中所有的行都被过滤条件拒绝了。但如果我们强制使用索引扫描,我们看到。</target>
        </trans-unit>
        <trans-unit id="9e657fb9f6d61f80be4eb7b46475ad5f607f9e2a" translate="yes" xml:space="preserve">
          <source>The planner will consider satisfying an &lt;code&gt;ORDER BY&lt;/code&gt; specification either by scanning an available index that matches the specification, or by scanning the table in physical order and doing an explicit sort. For a query that requires scanning a large fraction of the table, an explicit sort is likely to be faster than using an index because it requires less disk I/O due to following a sequential access pattern. Indexes are more useful when only a few rows need be fetched. An important special case is &lt;code&gt;ORDER BY&lt;/code&gt; in combination with &lt;code&gt;LIMIT&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;: an explicit sort will have to process all the data to identify the first &lt;code&gt;n&lt;/code&gt; rows, but if there is an index matching the &lt;code&gt;ORDER BY&lt;/code&gt;, the first &lt;code&gt;n&lt;/code&gt; rows can be retrieved directly, without scanning the remainder at all.</source>
          <target state="translated">计划者将考虑通过扫描与规范匹配的可用索引，或通过按物理顺序扫描表并进行显式排序来满足 &lt;code&gt;ORDER BY&lt;/code&gt; 规范。对于需要扫描大部分表的查询，显式排序可能比使用索引更快，因为由于遵循顺序访问模式，因此它需要较少的磁盘I / O。当仅需要获取几行时，索引会更有用。一个重要的特殊情况是 &lt;code&gt;ORDER BY&lt;/code&gt; 与 &lt;code&gt;LIMIT&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; 结合：显式排序将必须处理所有数据以标识前 &lt;code&gt;n&lt;/code&gt; 行，但是如果存在与 &lt;code&gt;ORDER BY&lt;/code&gt; 匹配的索引，则前 &lt;code&gt;n&lt;/code&gt; 行 可以直接检索行，而无需扫描其余所有行。</target>
        </trans-unit>
        <trans-unit id="f13fe03a32c9bbc1e61cf84d9ac188afb139c0ce" translate="yes" xml:space="preserve">
          <source>The planner will merge sub-queries into upper queries if the resulting &lt;code&gt;FROM&lt;/code&gt; list would have no more than this many items. Smaller values reduce planning time but might yield inferior query plans. The default is eight. For more information see &lt;a href=&quot;explicit-joins&quot;&gt;Section 14.3&lt;/a&gt;.</source>
          <target state="translated">如果生成的 &lt;code&gt;FROM&lt;/code&gt; 列表所包含的项目不多，则计划者会将子查询合并到较高的查询中。较小的值会减少计划时间，但可能会产生劣等的查询计划。默认值为八。有关更多信息，请参见&lt;a href=&quot;explicit-joins&quot;&gt;第14.3节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7e54dd315c563119cab38a459210d1e25c17b541" translate="yes" xml:space="preserve">
          <source>The planner will rewrite explicit &lt;code&gt;JOIN&lt;/code&gt; constructs (except &lt;code&gt;FULL JOIN&lt;/code&gt;s) into lists of &lt;code&gt;FROM&lt;/code&gt; items whenever a list of no more than this many items would result. Smaller values reduce planning time but might yield inferior query plans.</source>
          <target state="translated">每当产生的列表 &lt;code&gt;FROM&lt;/code&gt; 不超过这个数目时，计划器就会将显式的 &lt;code&gt;JOIN&lt;/code&gt; 构造（ &lt;code&gt;FULL JOIN&lt;/code&gt; 除外）重写为FROM项的列表。较小的值会减少计划时间，但可能会产生劣等的查询计划。</target>
        </trans-unit>
        <trans-unit id="51459135e7da0626e3461453ee190521c7ca83f8" translate="yes" xml:space="preserve">
          <source>The planner's information about the query being processed.</source>
          <target state="translated">规划师关于正在处理的查询信息。</target>
        </trans-unit>
        <trans-unit id="1577e921445112f0dec558626039eff4a0e20d9e" translate="yes" xml:space="preserve">
          <source>The planner's search procedure actually works with data structures called &lt;em&gt;paths&lt;/em&gt;, which are simply cut-down representations of plans containing only as much information as the planner needs to make its decisions. After the cheapest path is determined, a full-fledged &lt;em&gt;plan tree&lt;/em&gt; is built to pass to the executor. This represents the desired execution plan in sufficient detail for the executor to run it. In the rest of this section we'll ignore the distinction between paths and plans.</source>
          <target state="translated">计划者的搜索过程实际上是与称为&lt;em&gt;path的&lt;/em&gt;数据结构一起使用的，该数据结构只是计划的简化表示，其中仅包含计划者做出决策所需的信息。确定最便宜的路径后，将构建完整的&lt;em&gt;计划树&lt;/em&gt;以传递给执行者。这足够详细地表示了所需的执行计划，供执行者运行。在本节的其余部分，我们将忽略路径和计划之间的区别。</target>
        </trans-unit>
        <trans-unit id="4a55c4b471813d250b09c8e9cf01cec1bc297015" translate="yes" xml:space="preserve">
          <source>The planner/optimizer starts by generating plans for scanning each individual relation (table) used in the query. The possible plans are determined by the available indexes on each relation. There is always the possibility of performing a sequential scan on a relation, so a sequential scan plan is always created. Assume an index is defined on a relation (for example a B-tree index) and a query contains the restriction &lt;code&gt;relation.attribute OPR constant&lt;/code&gt;. If &lt;code&gt;relation.attribute&lt;/code&gt; happens to match the key of the B-tree index and &lt;code&gt;OPR&lt;/code&gt; is one of the operators listed in the index's &lt;em&gt;operator class&lt;/em&gt;, another plan is created using the B-tree index to scan the relation. If there are further indexes present and the restrictions in the query happen to match a key of an index, further plans will be considered. Index scan plans are also generated for indexes that have a sort ordering that can match the query's &lt;code&gt;ORDER BY&lt;/code&gt; clause (if any), or a sort ordering that might be useful for merge joining (see below).</source>
          <target state="translated">规划器/优化器首先生成用于扫描查询中使用的每个单独关系（表）的计划。可能的计划由每个关系上的可用索引确定。总是有可能对关系执行顺序扫描，因此总是会创建顺序扫描计划。假设在关系（例如B树索引）上定义了索引，并且查询包含限制 &lt;code&gt;relation.attribute OPR constant&lt;/code&gt; 。属性OPR常量。如果 &lt;code&gt;relation.attribute&lt;/code&gt; 恰好与B树索引的键匹配，并且 &lt;code&gt;OPR&lt;/code&gt; 是索引的&lt;em&gt;运算符类中&lt;/em&gt;列出的&lt;em&gt;运算符之一&lt;/em&gt;，则使用B树索引创建另一个计划以扫描该关系。如果存在其他索引，并且查询中的限制恰好与索引的键匹配，则将考虑其他计划。还会为具有可以与查询的 &lt;code&gt;ORDER BY&lt;/code&gt; 子句匹配的排序顺序（如果有）或对合并联接有用的排序顺序的索引生成索引扫描计划。</target>
        </trans-unit>
        <trans-unit id="af6fcc949e29ec6b5395bb9895c598ac00851a39" translate="yes" xml:space="preserve">
          <source>The policy above implicitly provides a &lt;code&gt;WITH CHECK&lt;/code&gt; clause identical to its &lt;code&gt;USING&lt;/code&gt; clause, so that the constraint applies both to rows selected by a command (so a manager cannot &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt; existing rows belonging to a different manager) and to rows modified by a command (so rows belonging to a different manager cannot be created via &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt;).</source>
          <target state="translated">上面的策略隐式提供了与其 &lt;code&gt;USING&lt;/code&gt; 子句相同的 &lt;code&gt;WITH CHECK&lt;/code&gt; 子句，因此该约束既适用于命令选择的行（因此管理器不能 &lt;code&gt;SELECT&lt;/code&gt; ， &lt;code&gt;UPDATE&lt;/code&gt; 或 &lt;code&gt;DELETE&lt;/code&gt; 属于其他管理器的现有行）和修改的行通过命令（因此不能通过 &lt;code&gt;INSERT&lt;/code&gt; 或 &lt;code&gt;UPDATE&lt;/code&gt; 创建属于不同管理器的行）。</target>
        </trans-unit>
        <trans-unit id="332f3ca0119d1ff928cc3032c43d7a8c6d076ef7" translate="yes" xml:space="preserve">
          <source>The port number at which the database server is listening.</source>
          <target state="translated">数据库服务器监听的端口号。</target>
        </trans-unit>
        <trans-unit id="3946be524d4d21ed59a4396709c558221452e965" translate="yes" xml:space="preserve">
          <source>The port number on the RADIUS servers to connect to. If no port is specified, the default port &lt;code&gt;1812&lt;/code&gt; will be used.</source>
          <target state="translated">RADIUS服务器上要连接的端口号。如果未指定端口，则将使用默认端口 &lt;code&gt;1812&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e70d1aceb09cc5ddba7934344393827032e6f65c" translate="yes" xml:space="preserve">
          <source>The port numbers to connect to on the RADIUS servers. If no port is specified, the default RADIUS port (&lt;code&gt;1812&lt;/code&gt;) will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d78397caeb854681d204384441be23fbf5963377" translate="yes" xml:space="preserve">
          <source>The possible privileges are:</source>
          <target state="translated">可能的特权是:</target>
        </trans-unit>
        <trans-unit id="f40d6965a9bc397fb0c918307a4356333c6e9be1" translate="yes" xml:space="preserve">
          <source>The possible types of qualified join are:</source>
          <target state="translated">可能的合格加入类型有:</target>
        </trans-unit>
        <trans-unit id="150d329b119d4f11b9ac2cd02c8c0d218611bacb" translate="yes" xml:space="preserve">
          <source>The potential for bloat in non-B-tree indexes has not been well researched. It is a good idea to periodically monitor the index's physical size when using any non-B-tree index type.</source>
          <target state="translated">对非B树索引膨胀的可能性还没有进行充分的研究。在使用任何非B树索引类型时,定期监测索引的物理大小是一个好主意。</target>
        </trans-unit>
        <trans-unit id="d757a72d029cfb4caba9e0b1db29785724f4d19a" translate="yes" xml:space="preserve">
          <source>The preceding statement is not true on Microsoft Windows: there, any changes in the &lt;code&gt;pg_hba.conf&lt;/code&gt; file are immediately applied by subsequent new connections.</source>
          <target state="translated">前面的语句在Microsoft Windows上是不正确的：在那里， &lt;code&gt;pg_hba.conf&lt;/code&gt; 文件中的任何更改都将由后续的新连接立即应用。</target>
        </trans-unit>
        <trans-unit id="252c412e1c63dfae47e051caef322b62e83bb886" translate="yes" xml:space="preserve">
          <source>The precise rule that is applied in such cases is that an invalid timestamp that appears to fall within a jump-forward daylight savings transition is assigned the UTC offset that prevailed in the time zone just before the transition, while an ambiguous timestamp that could fall on either side of a jump-back transition is assigned the UTC offset that prevailed just after the transition. In most time zones this is equivalent to saying that &amp;ldquo;the standard-time interpretation is preferred when in doubt&amp;rdquo;.</source>
          <target state="translated">在这种情况下应用的精确规则是，为看起来似乎属于前跳夏令时转换范围内的无效时间戳记分配了在转换之前时区中普遍存在的UTC偏移，而可能会落在该时间戳记上的模棱两可向后跳过渡的任一侧分配的是UTC偏移，该偏移恰好在过渡后出现。在大多数时区，这等同于说&amp;ldquo;有疑问时最好使用标准时间解释&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="28bfcc19c7bbea45feb0d0e7674c45c3d0b2a8ce" translate="yes" xml:space="preserve">
          <source>The precision must be positive, the scale zero or positive. Alternatively:</source>
          <target state="translated">精度必须为正,刻度为零或正。或者:</target>
        </trans-unit>
        <trans-unit id="3ffc8a93a54e6689bf8eb9af624f2ca2cef390c0" translate="yes" xml:space="preserve">
          <source>The predefined aggregate functions are described in &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.20&lt;/a&gt;. Other aggregate functions can be added by the user.</source>
          <target state="translated">预定义的聚合函数在&lt;a href=&quot;functions-aggregate&quot;&gt;第9.20节中&lt;/a&gt;进行了描述。用户可以添加其他聚合函数。</target>
        </trans-unit>
        <trans-unit id="e0a2c0ac127cccc7aaf6bb36feba44f57ab9026a" translate="yes" xml:space="preserve">
          <source>The predefined aggregate functions are described in &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.21&lt;/a&gt;. Other aggregate functions can be added by the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85290651a145a4790c306bf3090be3ac088ff86f" translate="yes" xml:space="preserve">
          <source>The preferred key type is &amp;ldquo;DSA and Elgamal&amp;rdquo;.</source>
          <target state="translated">首选的密钥类型是&amp;ldquo; DSA和Elgamal&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="9dcad895255c51069330af5d11a7861de5e972db" translate="yes" xml:space="preserve">
          <source>The preferred way of creating any of the standard procedural languages is just:</source>
          <target state="translated">创建任何一种标准程序语言的首选方式只是。</target>
        </trans-unit>
        <trans-unit id="1d193e74c38ebc3f88cf6c96d5dc626c1a851ce8" translate="yes" xml:space="preserve">
          <source>The preferred way to add and remove members of roles that are being used as groups is to use &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; and &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt;.</source>
          <target state="translated">添加和删​​除用作组的角色成员的首选方法是使用&lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt;和&lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="56dfc8a10ef1e4c4eee74088145c35840ecca451" translate="yes" xml:space="preserve">
          <source>The prefixes used for hyphenation were also compiled from:</source>
          <target state="translated">用于连词的前缀也是从。</target>
        </trans-unit>
        <trans-unit id="21fd2dec3de8b8ad1e5f622c8c13eab56cd148d6" translate="yes" xml:space="preserve">
          <source>The presence of &lt;code&gt;HAVING&lt;/code&gt; turns a query into a grouped query even if there is no &lt;code&gt;GROUP BY&lt;/code&gt; clause. This is the same as what happens when the query contains aggregate functions but no &lt;code&gt;GROUP BY&lt;/code&gt; clause. All the selected rows are considered to form a single group, and the &lt;code&gt;SELECT&lt;/code&gt; list and &lt;code&gt;HAVING&lt;/code&gt; clause can only reference table columns from within aggregate functions. Such a query will emit a single row if the &lt;code&gt;HAVING&lt;/code&gt; condition is true, zero rows if it is not true.</source>
          <target state="translated">即使没有 &lt;code&gt;GROUP BY&lt;/code&gt; 子句， &lt;code&gt;HAVING&lt;/code&gt; 的存在也会将查询转换为分组查询。这与查询包含聚合函数但不包含 &lt;code&gt;GROUP BY&lt;/code&gt; 子句的情况相同。所有选定的行都被视为形成一个单一的组，并且 &lt;code&gt;SELECT&lt;/code&gt; 列表和 &lt;code&gt;HAVING&lt;/code&gt; 子句只能引用聚合函数中的表列。如果 &lt;code&gt;HAVING&lt;/code&gt; 条件为true，则此查询将发出单行；如果条件为true，则将发出零行。</target>
        </trans-unit>
        <trans-unit id="48e01dab4eaf7172ed513c36aea408ac9dcff0a1" translate="yes" xml:space="preserve">
          <source>The previous example with &lt;code&gt;unique1 &amp;lt; 1000&lt;/code&gt; was an oversimplification of what &lt;code&gt;scalarltsel&lt;/code&gt; really does; now that we have seen an example of the use of MCVs, we can fill in some more detail. The example was correct as far as it went, because since &lt;code&gt;unique1&lt;/code&gt; is a unique column it has no MCVs (obviously, no value is any more common than any other value). For a non-unique column, there will normally be both a histogram and an MCV list, and &lt;em&gt;the histogram does not include the portion of the column population represented by the MCVs&lt;/em&gt;. We do things this way because it allows more precise estimation. In this situation &lt;code&gt;scalarltsel&lt;/code&gt; directly applies the condition (e.g., &amp;ldquo;&amp;lt; 1000&amp;rdquo;) to each value of the MCV list, and adds up the frequencies of the MCVs for which the condition is true. This gives an exact estimate of the selectivity within the portion of the table that is MCVs. The histogram is then used in the same way as above to estimate the selectivity in the portion of the table that is not MCVs, and then the two numbers are combined to estimate the overall selectivity. For example, consider</source>
          <target state="translated">前面的 &lt;code&gt;unique1 &amp;lt; 1000&lt;/code&gt; 示例是对 &lt;code&gt;scalarltsel&lt;/code&gt; 实际功能的简化。现在，我们已经看到了使用MCV的示例，我们可以填写一些更详细的信息。该示例到目前为止是正确的，因为因为 &lt;code&gt;unique1&lt;/code&gt; 是唯一列，所以它没有MCV（显然，没有任何值比其他任何值更常见）。对于非唯一列，通常将同时具有直方图和MCV列表，并且&lt;em&gt;直方图不包括由MCV表示的列总体的一部分&lt;/em&gt;。我们这样做是因为它可以进行更精确的估算。在这种情况下 &lt;code&gt;scalarltsel&lt;/code&gt; 直接将条件（例如，&amp;ldquo; &amp;lt;1000&amp;rdquo;）应用于MCV列表的每个值，并将条件成立的MCV的频率相加。这样可以在表中的MCV部分中准确估算出选择性。然后，以与上述相同的方式使用直方图来估计表格中非MCV部分的选择性，然后将这两个数字组合起来以估计总体选择性。例如，考虑</target>
        </trans-unit>
        <trans-unit id="bb34259f0365c548655973db55e1cb8224129b77" translate="yes" xml:space="preserve">
          <source>The primary and standby server work together to provide this capability, though the servers are only loosely coupled. The primary server operates in continuous archiving mode, while each standby server operates in continuous recovery mode, reading the WAL files from the primary. No changes to the database tables are required to enable this capability, so it offers low administration overhead compared to some other replication solutions. This configuration also has relatively low performance impact on the primary server.</source>
          <target state="translated">主服务器和备用服务器一起工作以提供这种功能,尽管服务器只是松散地耦合。主服务器以连续存档模式运行,而每个备用服务器以连续恢复模式运行,从主服务器读取WAL文件。启用此功能无需更改数据库表,因此与其他一些复制解决方案相比,它的管理开销较低。这种配置对主服务器的性能影响也比较小。</target>
        </trans-unit>
        <trans-unit id="0da66f61871c96b75f9ab923507bcc1a24b7f889" translate="yes" xml:space="preserve">
          <source>The primary and standby servers are in many ways loosely connected. Actions on the primary will have an effect on the standby. As a result, there is potential for negative interactions or conflicts between them. The easiest conflict to understand is performance: if a huge data load is taking place on the primary then this will generate a similar stream of WAL records on the standby, so standby queries may contend for system resources, such as I/O.</source>
          <target state="translated">主服务器和备用服务器在很多方面都是松散联系的。主服务器上的行动将对备用服务器产生影响。因此,它们之间有可能发生负面的交互或冲突。最容易理解的冲突是性能:如果主服务器上发生了巨大的数据负载,那么这将在备用服务器上产生类似的WAL记录流,因此备用查询可能会争夺系统资源,如I/O。</target>
        </trans-unit>
        <trans-unit id="798c0c5f43fda644a454b46372f29e554497fa2e" translate="yes" xml:space="preserve">
          <source>The primary error message and associated SQLSTATE code for the most recent failed query in the current psql session, or an empty string and &lt;code&gt;00000&lt;/code&gt; if no error has occurred in the current session.</source>
          <target state="translated">当前psql会话中最近一次失败查询的主要错误消息和相关的SQLSTATE代码，如果当前会话中未发生错误，则返回一个空字符串和 &lt;code&gt;00000&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ab145e1a33deb5fe3582f237dbec8cdd7e1d8ca" translate="yes" xml:space="preserve">
          <source>The primary goal of developing GIN indexes was to create support for highly scalable full-text search in PostgreSQL, and there are often situations when a full-text search returns a very large set of results. Moreover, this often happens when the query contains very frequent words, so that the large result set is not even useful. Since reading many tuples from the disk and sorting them could take a lot of time, this is unacceptable for production. (Note that the index search itself is very fast.)</source>
          <target state="translated">开发GIN索引的主要目标是为PostgreSQL中的高可扩展性全文搜索创建支持,经常会出现全文搜索返回非常大的结果集的情况。而且,这种情况经常发生在查询包含非常频繁的词时,这样大的结果集甚至没有用。因为从磁盘中读取许多元组并对它们进行排序可能会花费大量的时间,这对于生产来说是不可接受的。(注意,索引搜索本身的速度是非常快的)。</target>
        </trans-unit>
        <trans-unit id="6c7d00d06905a4bbc00c744c0f27a07f33dd5060" translate="yes" xml:space="preserve">
          <source>The primary key constraint should name a set of columns that is different from the set of columns named by any unique constraint defined for the same table. (Otherwise, the unique constraint is redundant and will be discarded.)</source>
          <target state="translated">主键约束应该命名一组列,这组列与为同一张表定义的任何唯一约束所命名的列不同。否则,唯一约束是多余的,将被丢弃)。</target>
        </trans-unit>
        <trans-unit id="095c1f180ee69bf2f8a1425ef17c7371474cd375" translate="yes" xml:space="preserve">
          <source>The primary query and the &lt;code&gt;WITH&lt;/code&gt; queries are all (notionally) executed at the same time. This implies that the effects of a data-modifying statement in &lt;code&gt;WITH&lt;/code&gt; cannot be seen from other parts of the query, other than by reading its &lt;code&gt;RETURNING&lt;/code&gt; output. If two such data-modifying statements attempt to modify the same row, the results are unspecified.</source>
          <target state="translated">主查询和 &lt;code&gt;WITH&lt;/code&gt; 查询都（名义上）同时执行。这意味着在 &lt;code&gt;WITH&lt;/code&gt; 中的数据修改语句的效果无法从查询的其他部分看到，除非读取其 &lt;code&gt;RETURNING&lt;/code&gt; 输出。如果两个这样的数据修改语句试图修改同一行，则结果不确定。</target>
        </trans-unit>
        <trans-unit id="9af619375db4792c2c6568b4b82266a2578d8e4a" translate="yes" xml:space="preserve">
          <source>The primary use of unlogged tables is for storing transient work data that must be shared across processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ea3da5c410e9ce91a550f33e83dec4f1762b9fe" translate="yes" xml:space="preserve">
          <source>The privileges necessary to execute this command are left implementation-defined by the standard.</source>
          <target state="translated">执行该命令所需的权限由标准规定。</target>
        </trans-unit>
        <trans-unit id="3d054afefddca1f4fd0c80061650d8bf2f8607fd" translate="yes" xml:space="preserve">
          <source>The privileges required by other commands are listed on the reference page of the respective command.</source>
          <target state="translated">其他命令所需的权限列在各命令的参考页面上。</target>
        </trans-unit>
        <trans-unit id="304d4014e67dda82fac817f06e9aef50bfd659e4" translate="yes" xml:space="preserve">
          <source>The privileges required to create a conversion might be changed in a future release.</source>
          <target state="translated">创建转换所需的权限可能会在未来的版本中改变。</target>
        </trans-unit>
        <trans-unit id="1eb7e4f8bb27785f30b9b8a7055a803cd67b6df6" translate="yes" xml:space="preserve">
          <source>The privileges that have been granted for a particular object are displayed as a list of &lt;code&gt;aclitem&lt;/code&gt; entries, where each &lt;code&gt;aclitem&lt;/code&gt; describes the permissions of one grantee that have been granted by a particular grantor. For example, &lt;code&gt;calvin=r*w/hobbes&lt;/code&gt; specifies that the role &lt;code&gt;calvin&lt;/code&gt; has the privilege &lt;code&gt;SELECT&lt;/code&gt; (&lt;code&gt;r&lt;/code&gt;) with grant option (&lt;code&gt;*&lt;/code&gt;) as well as the non-grantable privilege &lt;code&gt;UPDATE&lt;/code&gt; (&lt;code&gt;w&lt;/code&gt;), both granted by the role &lt;code&gt;hobbes&lt;/code&gt;. If &lt;code&gt;calvin&lt;/code&gt; also has some privileges on the same object granted by a different grantor, those would appear as a separate &lt;code&gt;aclitem&lt;/code&gt; entry. An empty grantee field in an &lt;code&gt;aclitem&lt;/code&gt; stands for &lt;code&gt;PUBLIC&lt;/code&gt;.</source>
          <target state="translated">已被授予特定对象的特权显示为列表 &lt;code&gt;aclitem&lt;/code&gt; 条目，每个 &lt;code&gt;aclitem&lt;/code&gt; 介绍了已授予特定押一个被授权者的权限。例如， &lt;code&gt;calvin=r*w/hobbes&lt;/code&gt; 指定角色 &lt;code&gt;calvin&lt;/code&gt; 具有带授予选项（ &lt;code&gt;*&lt;/code&gt; ）的特权 &lt;code&gt;SELECT&lt;/code&gt; （ &lt;code&gt;r&lt;/code&gt; ）以及不可授予的特权 &lt;code&gt;UPDATE&lt;/code&gt; （ &lt;code&gt;w&lt;/code&gt; ），两者均由角色 &lt;code&gt;hobbes&lt;/code&gt; 授予。如果 &lt;code&gt;calvin&lt;/code&gt; 对不同授予者授予的同一对象也具有某些特权，则这些特权将显示为单独的 &lt;code&gt;aclitem&lt;/code&gt; 条目。一个 &lt;code&gt;aclitem&lt;/code&gt; 受赠人空白字段代表 &lt;code&gt;PUBLIC&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="146fa2f880a1a0967ddf597dd80c4df17c9e7c69" translate="yes" xml:space="preserve">
          <source>The procedural language code to be executed. This must be specified as a string literal, just as in &lt;code&gt;CREATE FUNCTION&lt;/code&gt;. Use of a dollar-quoted literal is recommended.</source>
          <target state="translated">要执行的过程语言代码。必须将其指定为字符串文字，就像在 &lt;code&gt;CREATE FUNCTION&lt;/code&gt; 中一样。建议使用美元报价文字。</target>
        </trans-unit>
        <trans-unit id="6f86ee50294a4a7a3fef4b5b2297c9c5402611ba" translate="yes" xml:space="preserve">
          <source>The procedural language to be used must already have been installed into the current database by means of &lt;code&gt;CREATE EXTENSION&lt;/code&gt;. &lt;code&gt;plpgsql&lt;/code&gt; is installed by default, but other languages are not.</source>
          <target state="translated">必须已经通过 &lt;code&gt;CREATE EXTENSION&lt;/code&gt; 将要使用的过程语言安装到当前数据库中。默认情况下已安装 &lt;code&gt;plpgsql&lt;/code&gt; ，但未安装其他语言。</target>
        </trans-unit>
        <trans-unit id="eeffbbfe4a95a1cfc7af97774b63ebc4c95bcc67" translate="yes" xml:space="preserve">
          <source>The procedure for making a base backup using the low level APIs contains a few more steps than the &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt; method, but is relatively simple. It is very important that these steps are executed in sequence, and that the success of a step is verified before proceeding to the next step.</source>
          <target state="translated">使用低级API进行基本备份的过程比&lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt;方法包含更多的步骤，但是相对简单。依次执行这些步骤，并在继续进行下一步之前验证步骤的成功是非常重要的。</target>
        </trans-unit>
        <trans-unit id="0cb38c62a0e05e7bd2148e42b61d27ee2ab30693" translate="yes" xml:space="preserve">
          <source>The procedure will now execute with whatever search path is used by its caller.</source>
          <target state="translated">现在,过程将以其调用者使用的任何搜索路径执行。</target>
        </trans-unit>
        <trans-unit id="4b5bcbc092d024a0a7543e925fc016ccd66517c6" translate="yes" xml:space="preserve">
          <source>The process ID of the backend currently connected to.</source>
          <target state="translated">当前连接的后台的进程ID。</target>
        </trans-unit>
        <trans-unit id="34795750bd1d44ec3bd68f7c69b56e729608c717" translate="yes" xml:space="preserve">
          <source>The process ID of the session using this slot if the slot is currently actively being used. &lt;code&gt;NULL&lt;/code&gt; if inactive.</source>
          <target state="translated">当前正在使用该插槽的会话的进程ID。如果不活动，则为 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="32a4bb7cc46bcf50934800d5f3c98570d230e94a" translate="yes" xml:space="preserve">
          <source>The process for an exclusive backup is mostly the same as for a non-exclusive one, but it differs in a few key steps. This type of backup can only be taken on a primary and does not allow concurrent backups. Moreover, because it creates a backup label file, as described below, it can block automatic restart of the master server after a crash. On the other hand, the erroneous removal of this file from a backup or standby is a common mistake, which can result in serious data corruption. If it is necessary to use this method, the following steps may be used.</source>
          <target state="translated">独占性备份的流程与非独占性备份的流程基本相同,但有几个关键步骤不同。这种类型的备份只能在主设备上进行,不允许并发备份。此外,由于它会创建一个备份标签文件,如下所述,它可以阻止主服务器在崩溃后自动重启。另一方面,从备份或备用中错误地删除该文件是一个常见的错误,这可能导致严重的数据损坏。如果必须使用此方法,可采用以下步骤。</target>
        </trans-unit>
        <trans-unit id="3ac18966156d31cda12f7c9ac2957f1b7e5f24a9" translate="yes" xml:space="preserve">
          <source>The process of collecting statistics from data in &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;tables&lt;/a&gt; and other &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relations&lt;/a&gt; to help the &lt;a href=&quot;glossary#GLOSSARY-PLANNER&quot;&gt;query planner&lt;/a&gt; to make decisions about how to execute &lt;a href=&quot;glossary#GLOSSARY-QUERY&quot;&gt;queries&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="164dce5302a4d4d5322e298ad9a4e62c23cc3474" translate="yes" xml:space="preserve">
          <source>The process of removing outdated &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;tuple versions&lt;/a&gt; from tables or materialized views, and other closely related processing required by PostgreSQL's implementation of &lt;a href=&quot;glossary#GLOSSARY-MVCC&quot;&gt;MVCC&lt;/a&gt;. This can be initiated through the use of the &lt;code&gt;VACUUM&lt;/code&gt; command, but can also be handled automatically via &lt;a href=&quot;glossary#GLOSSARY-AUTOVACUUM&quot;&gt;autovacuum&lt;/a&gt; processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e312719075282712af63a4478358c161b9ce7c1" translate="yes" xml:space="preserve">
          <source>The process of retrieving or the command to retrieve data from a database is called a &lt;em&gt;query&lt;/em&gt;. In SQL the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; command is used to specify queries. The general syntax of the &lt;code&gt;SELECT&lt;/code&gt; command is</source>
          <target state="translated">检索过程或从数据库检索数据的命令称为&lt;em&gt;查询&lt;/em&gt;。在SQL中，&lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;命令用于指定查询。 &lt;code&gt;SELECT&lt;/code&gt; 命令的一般语法是</target>
        </trans-unit>
        <trans-unit id="b0bd352dde02b38bfa623807b29516cb539dd331" translate="yes" xml:space="preserve">
          <source>The program &lt;a href=&quot;app-createdb&quot;&gt;createdb&lt;/a&gt; is a wrapper program around this command, provided for convenience.</source>
          <target state="translated">&lt;a href=&quot;app-createdb&quot;&gt;createdb&lt;/a&gt;程序是围绕此命令的包装程序，为方便起见而提供。</target>
        </trans-unit>
        <trans-unit id="3eff284be443ff432de37efc6563b33dc2f6e837" translate="yes" xml:space="preserve">
          <source>The prompts psql issues can be customized to your preference. The three variables &lt;code&gt;PROMPT1&lt;/code&gt;, &lt;code&gt;PROMPT2&lt;/code&gt;, and &lt;code&gt;PROMPT3&lt;/code&gt; contain strings and special escape sequences that describe the appearance of the prompt. Prompt 1 is the normal prompt that is issued when psql requests a new command. Prompt 2 is issued when more input is expected during command entry, for example because the command was not terminated with a semicolon or a quote was not closed. Prompt 3 is issued when you are running an SQL &lt;code&gt;COPY FROM STDIN&lt;/code&gt; command and you need to type in a row value on the terminal.</source>
          <target state="translated">可以根据您的喜好自定义提示psql问题。三个变量 &lt;code&gt;PROMPT1&lt;/code&gt; ， &lt;code&gt;PROMPT2&lt;/code&gt; 和 &lt;code&gt;PROMPT3&lt;/code&gt; 包含字符串和特殊的转义序列，用于描述提示的外观。提示1是psql请求新命令时发出的普通提示。当在命令输入期间需要更多输入时（例如，因为命令未使用分号终止或未关闭引号），将发出提示2。当您运行SQL &lt;code&gt;COPY FROM STDIN&lt;/code&gt; 命令并且您需要在终端上输入行值时，将发出提示3 。</target>
        </trans-unit>
        <trans-unit id="beda63023776d34df94471c0f164755d13f940bc" translate="yes" xml:space="preserve">
          <source>The property of a &lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;transaction&lt;/a&gt; that either all its operations complete as a single unit or none do. In addition, if a system failure occurs during the execution of a transaction, no partial results are visible after recovery. This is one of the ACID properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60437688afa311c4869b8b3f6a8991364e3687d3" translate="yes" xml:space="preserve">
          <source>The property of certain &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relations&lt;/a&gt; that the changes to them are not reflected in the &lt;a href=&quot;glossary#GLOSSARY-WAL&quot;&gt;WAL&lt;/a&gt;. This disables replication and crash recovery for these relations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb5f3d4498a374f31c0813bda303e196477c5021" translate="yes" xml:space="preserve">
          <source>The property that some information has been pre-computed and stored for later use, rather than computing it on-the-fly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83b4c095224b564ce4e74b023e585d03df96a6dc" translate="yes" xml:space="preserve">
          <source>The property that the data in the &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; is always in compliance with &lt;a href=&quot;glossary#GLOSSARY-CONSTRAINT&quot;&gt;integrity constraints&lt;/a&gt;. Transactions may be allowed to violate some of the constraints transiently before it commits, but if such violations are not resolved by the time it commits, such a transaction is automatically &lt;a href=&quot;glossary#GLOSSARY-ROLLBACK&quot;&gt;rolled back&lt;/a&gt;. This is one of the ACID properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6435c94ce6f1ff88843d11bc1738457d2390918" translate="yes" xml:space="preserve">
          <source>The property that the effects of a transaction are not visible to &lt;a href=&quot;glossary#GLOSSARY-CONCURRENCY&quot;&gt;concurrent transactions&lt;/a&gt; before it commits. This is one of the ACID properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b52632ebba8d8fdc7d9a5f3df0121e320094037" translate="yes" xml:space="preserve">
          <source>The provided functions are shown in &lt;a href=&quot;earthdistance#EARTHDISTANCE-CUBE-FUNCTIONS&quot;&gt;Table F.5&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;earthdistance#EARTHDISTANCE-CUBE-FUNCTIONS&quot;&gt;表F.5&lt;/a&gt;中显示了提供的功能。</target>
        </trans-unit>
        <trans-unit id="5afa1f9b64bd52e3a56222e3e5d393c2eefea25a" translate="yes" xml:space="preserve">
          <source>The purpose is to limit the impact of pg_basebackup on the running server.</source>
          <target state="translated">目的是限制pg_basebackup对运行中的服务器的影响。</target>
        </trans-unit>
        <trans-unit id="5073941a47e032b26bcb9d69507584568abea85b" translate="yes" xml:space="preserve">
          <source>The purpose of a &lt;code&gt;WINDOW&lt;/code&gt; clause is to specify the behavior of &lt;em&gt;window functions&lt;/em&gt; appearing in the query's &lt;a href=&quot;sql-select#SQL-SELECT-LIST&quot;&gt;&lt;code&gt;SELECT&lt;/code&gt; List&lt;/a&gt; or &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;&lt;code&gt;ORDER BY&lt;/code&gt; Clause&lt;/a&gt;. These functions can reference the &lt;code&gt;WINDOW&lt;/code&gt; clause entries by name in their &lt;code&gt;OVER&lt;/code&gt; clauses. A &lt;code&gt;WINDOW&lt;/code&gt; clause entry does not have to be referenced anywhere, however; if it is not used in the query it is simply ignored. It is possible to use window functions without any &lt;code&gt;WINDOW&lt;/code&gt; clause at all, since a window function call can specify its window definition directly in its &lt;code&gt;OVER&lt;/code&gt; clause. However, the &lt;code&gt;WINDOW&lt;/code&gt; clause saves typing when the same window definition is needed for more than one window function.</source>
          <target state="translated">&lt;code&gt;WINDOW&lt;/code&gt; 子句的目的是指定出现在查询的&lt;a href=&quot;sql-select#SQL-SELECT-LIST&quot;&gt; &lt;code&gt;SELECT&lt;/code&gt; &lt;/a&gt; List或&lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt; &lt;code&gt;ORDER BY&lt;/code&gt; &lt;/a&gt;子句中的&lt;em&gt;窗口函数&lt;/em&gt;的行为。这些函数可以在其 &lt;code&gt;OVER&lt;/code&gt; 子句中按名称引用 &lt;code&gt;WINDOW&lt;/code&gt; 子句条目。但是， &lt;code&gt;WINDOW&lt;/code&gt; 子句条目不必在任何地方引用。如果查询中未使用它，则将其忽略。可以根本不使用任何 &lt;code&gt;WINDOW&lt;/code&gt; 子句来使用窗口函数，因为窗口函数调用可以直接在其 &lt;code&gt;OVER&lt;/code&gt; 子句中指定其窗口定义。但是， &lt;code&gt;WINDOW&lt;/code&gt; 当一个以上的窗口函数需要相同的窗口定义时，子句将节省键入内容。</target>
        </trans-unit>
        <trans-unit id="b96262653baf1cfb436f7851543f2559b2750e87" translate="yes" xml:space="preserve">
          <source>The purpose of a &lt;code&gt;WINDOW&lt;/code&gt; clause is to specify the behavior of &lt;em&gt;window functions&lt;/em&gt; appearing in the query's &lt;a href=&quot;sql-select#SQL-SELECT-LIST&quot;&gt;&lt;code&gt;SELECT&lt;/code&gt; list&lt;/a&gt; or &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;&lt;code&gt;ORDER BY&lt;/code&gt;&lt;/a&gt; clause. These functions can reference the &lt;code&gt;WINDOW&lt;/code&gt; clause entries by name in their &lt;code&gt;OVER&lt;/code&gt; clauses. A &lt;code&gt;WINDOW&lt;/code&gt; clause entry does not have to be referenced anywhere, however; if it is not used in the query it is simply ignored. It is possible to use window functions without any &lt;code&gt;WINDOW&lt;/code&gt; clause at all, since a window function call can specify its window definition directly in its &lt;code&gt;OVER&lt;/code&gt; clause. However, the &lt;code&gt;WINDOW&lt;/code&gt; clause saves typing when the same window definition is needed for more than one window function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a79e1e6c48912d3a19f2334c5cde8a4adb3de10" translate="yes" xml:space="preserve">
          <source>The purpose of an index, of course, is to support scans for tuples matching an indexable &lt;code&gt;WHERE&lt;/code&gt; condition, often called a &lt;em&gt;qualifier&lt;/em&gt; or &lt;em&gt;scan key&lt;/em&gt;. The semantics of index scanning are described more fully in &lt;a href=&quot;index-scanning&quot;&gt;Section 61.3&lt;/a&gt;, below. An index access method can support &amp;ldquo;plain&amp;rdquo; index scans, &amp;ldquo;bitmap&amp;rdquo; index scans, or both. The scan-related functions that an index access method must or may provide are:</source>
          <target state="translated">当然，索引的目的是支持对与可索引的 &lt;code&gt;WHERE&lt;/code&gt; 条件匹配的元组进行扫描，通常将其称为&lt;em&gt;限定符&lt;/em&gt;或&lt;em&gt;扫描键&lt;/em&gt;。索引扫描的语义在下面的&lt;a href=&quot;index-scanning&quot;&gt;第61.3节中&lt;/a&gt;有更详细的描述。索引访问方法可以支持&amp;ldquo;普通&amp;rdquo;索引扫描，&amp;ldquo;位图&amp;rdquo;索引扫描或两者。索引访问方法必须或可能提供的与扫描相关的功能是：</target>
        </trans-unit>
        <trans-unit id="71dfcd4f15fca395ab847bf8654ecc1126908484" translate="yes" xml:space="preserve">
          <source>The quantifiers &lt;code&gt;{1,1}&lt;/code&gt; and &lt;code&gt;{1,1}?&lt;/code&gt; can be used to force greediness or non-greediness, respectively, on a subexpression or a whole RE. This is useful when you need the whole RE to have a greediness attribute different from what's deduced from its elements. As an example, suppose that we are trying to separate a string containing some digits into the digits and the parts before and after them. We might try to do that like this:</source>
          <target state="translated">量词 &lt;code&gt;{1,1}&lt;/code&gt; 和 &lt;code&gt;{1,1}?&lt;/code&gt; 可以分别用于在子表达式或整个RE上强制使用贪婪或不贪婪。当您需要整个RE具有不同于从其元素推断出的贪婪属性时，这很有用。例如，假设我们试图将包含一些数字的字符串分成数字以及数字前后的部分。我们可以尝试这样做：</target>
        </trans-unit>
        <trans-unit id="343b9e25e0029b4f349abf2c9eb3c709d6c9db46" translate="yes" xml:space="preserve">
          <source>The quarter of the year (1 - 4) that the date is in</source>
          <target state="translated">日期所在的年份(1-4)的季度。</target>
        </trans-unit>
        <trans-unit id="4b7ab2f4293b424598bc3b854175b38f8e2117d5" translate="yes" xml:space="preserve">
          <source>The quarter of the year (1&amp;ndash;4) that the date is in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c024cf5d71d6d58e1719ea5b88c2edd0af4738d" translate="yes" xml:space="preserve">
          <source>The queried JSON data contain nested arrays. In this case, only the outermost array is unwrapped, while all the inner arrays remain unchanged. Thus, implicit unwrapping can only go one level down within each path evaluation step.</source>
          <target state="translated">查询的JSON数据包含嵌套的数组。在这种情况下,只有最外层的数组被解包,而所有内部数组保持不变。因此,隐式解包只能在每个路径评估步骤中向下一级。</target>
        </trans-unit>
        <trans-unit id="9ec83a60a4572c2a39f277feef2e26e14c05d5aa" translate="yes" xml:space="preserve">
          <source>The query above specifies that the &lt;code&gt;english&lt;/code&gt; configuration is to be used to parse and normalize the strings. Alternatively we could omit the configuration parameters:</source>
          <target state="translated">上面的查询指定将使用 &lt;code&gt;english&lt;/code&gt; 配置来解析和规范化字符串。或者，我们可以省略配置参数：</target>
        </trans-unit>
        <trans-unit id="755893eaea71f45690b0b8daa7c44ccecde3f16e" translate="yes" xml:space="preserve">
          <source>The query is running inside of another query that is already parallel. For example, if a function called by a parallel query issues an SQL query itself, that query will never use a parallel plan. This is a limitation of the current implementation, but it may not be desirable to remove this limitation, since it could result in a single query using a very large number of processes.</source>
          <target state="translated">查询运行在另一个已经并行的查询里面。例如,如果一个被并行查询调用的函数自己发出了一个SQL查询,那么该查询将永远不会使用并行计划。这是当前实现的一个限制,但可能不希望取消这个限制,因为它可能导致一个查询使用非常多的进程。</target>
        </trans-unit>
        <trans-unit id="5a0a949650f6ba760f80fb27f318b51f13c26bd4" translate="yes" xml:space="preserve">
          <source>The query might be suspended during execution. In any situation in which the system thinks that partial or incremental execution might occur, no parallel plan is generated. For example, a cursor created using &lt;a href=&quot;sql-declare&quot;&gt;DECLARE CURSOR&lt;/a&gt; will never use a parallel plan. Similarly, a PL/pgSQL loop of the form &lt;code&gt;FOR x IN query LOOP .. END LOOP&lt;/code&gt; will never use a parallel plan, because the parallel query system is unable to verify that the code in the loop is safe to execute while parallel query is active.</source>
          <target state="translated">该查询可能在执行期间被挂起。在系统认为可能发生部分或增量执行的任何情况下，都不会生成并行计划。例如，使用&lt;a href=&quot;sql-declare&quot;&gt;DECLARE CURSOR&lt;/a&gt;创建的游标将永远不会使用并行计划。同样，形式 &lt;code&gt;FOR x IN query LOOP .. END LOOP&lt;/code&gt; 的PL / pgSQL循环将永远不会使用并行计划，因为在并行查询处于活动状态时，并行查询系统无法验证循环中的代码是否可以安全执行。</target>
        </trans-unit>
        <trans-unit id="bdfa8875f3090d46606e95d96800e6f18174861f" translate="yes" xml:space="preserve">
          <source>The query must reference only columns stored in the index. For example, given an index on columns &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; of a table that also has a column &lt;code&gt;z&lt;/code&gt;, these queries could use index-only scans:</source>
          <target state="translated">该查询必须仅引用存储在索引中的列。例如，给定在还具有 &lt;code&gt;z&lt;/code&gt; 列的表的 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 列上的索引，这些查询可以使用仅索引扫描：</target>
        </trans-unit>
        <trans-unit id="c50468726e4134a52ce71c84ac34c354a3e1b957" translate="yes" xml:space="preserve">
          <source>The query optimizer takes &lt;code&gt;LIMIT&lt;/code&gt; into account when generating query plans, so you are very likely to get different plans (yielding different row orders) depending on what you give for &lt;code&gt;LIMIT&lt;/code&gt; and &lt;code&gt;OFFSET&lt;/code&gt;. Thus, using different &lt;code&gt;LIMIT&lt;/code&gt;/&lt;code&gt;OFFSET&lt;/code&gt; values to select different subsets of a query result &lt;em&gt;will give inconsistent results&lt;/em&gt; unless you enforce a predictable result ordering with &lt;code&gt;ORDER BY&lt;/code&gt;. This is not a bug; it is an inherent consequence of the fact that SQL does not promise to deliver the results of a query in any particular order unless &lt;code&gt;ORDER BY&lt;/code&gt; is used to constrain the order.</source>
          <target state="translated">查询优化器在生成查询计划时会考虑 &lt;code&gt;LIMIT&lt;/code&gt; ，因此根据 &lt;code&gt;LIMIT&lt;/code&gt; 和 &lt;code&gt;OFFSET&lt;/code&gt; 给出的结果，您很可能会获得不同的计划（产生不同的行顺序）。因此，除非您使用 &lt;code&gt;ORDER BY&lt;/code&gt; 强制执行可预测的结果排序，否则使用不同的 &lt;code&gt;LIMIT&lt;/code&gt; / &lt;code&gt;OFFSET&lt;/code&gt; 值来选择查询结果的不同子集&lt;em&gt;将产生不一致的结果&lt;/em&gt;。这不是错误；这是一个固有的结果，即除非使用 &lt;code&gt;ORDER BY&lt;/code&gt; 约束该顺序，否则SQL不会保证以任何特定顺序传递查询结果。</target>
        </trans-unit>
        <trans-unit id="9591ec91d27bd94fc1ed0042a9c68fc7e7f8799e" translate="yes" xml:space="preserve">
          <source>The query planner takes &lt;code&gt;LIMIT&lt;/code&gt; into account when generating a query plan, so you are very likely to get different plans (yielding different row orders) depending on what you use for &lt;code&gt;LIMIT&lt;/code&gt; and &lt;code&gt;OFFSET&lt;/code&gt;. Thus, using different &lt;code&gt;LIMIT&lt;/code&gt;/&lt;code&gt;OFFSET&lt;/code&gt; values to select different subsets of a query result &lt;em&gt;will give inconsistent results&lt;/em&gt; unless you enforce a predictable result ordering with &lt;code&gt;ORDER BY&lt;/code&gt;. This is not a bug; it is an inherent consequence of the fact that SQL does not promise to deliver the results of a query in any particular order unless &lt;code&gt;ORDER BY&lt;/code&gt; is used to constrain the order.</source>
          <target state="translated">查询计划程序在生成查询计划时会考虑 &lt;code&gt;LIMIT&lt;/code&gt; ，因此根据 &lt;code&gt;LIMIT&lt;/code&gt; 和 &lt;code&gt;OFFSET&lt;/code&gt; 的使用方式，您很可能会获得不同的计划（产生不同的行顺序）。因此，除非您使用 &lt;code&gt;ORDER BY&lt;/code&gt; 强制执行可预测的结果排序，否则使用不同的 &lt;code&gt;LIMIT&lt;/code&gt; / &lt;code&gt;OFFSET&lt;/code&gt; 值来选择查询结果的不同子集&lt;em&gt;将产生不一致的结果&lt;/em&gt;。这不是错误；这是一个固有的结果，即除非使用 &lt;code&gt;ORDER BY&lt;/code&gt; 约束该顺序，否则SQL不会保证以任何特定顺序传递查询结果。</target>
        </trans-unit>
        <trans-unit id="4af81e08bfabc175af6208808228c3292ec1d219" translate="yes" xml:space="preserve">
          <source>The query rewriter is discussed in some detail in &lt;a href=&quot;https://www.postgresql.org/docs/12/rules.html&quot;&gt;Chapter 40&lt;/a&gt;, so there is no need to cover it here. We will only point out that both the input and the output of the rewriter are query trees, that is, there is no change in the representation or level of semantic detail in the trees. Rewriting can be thought of as a form of macro expansion.</source>
          <target state="translated">在&lt;a href=&quot;https://www.postgresql.org/docs/12/rules.html&quot;&gt;第40章&lt;/a&gt;中将详细讨论查询重写器，因此在此无需赘述。我们只会指出重写器的输入和输出都是查询树，也就是说，树中语义细节的表示或级别没有变化。重写可以被认为是宏扩展的一种形式。</target>
        </trans-unit>
        <trans-unit id="294de92ad34c3155980be69ecc50bda8db23e6c8" translate="yes" xml:space="preserve">
          <source>The query rewriter is discussed in some detail in &lt;a href=&quot;https://www.postgresql.org/docs/13/rules.html&quot;&gt;Chapter 40&lt;/a&gt;, so there is no need to cover it here. We will only point out that both the input and the output of the rewriter are query trees, that is, there is no change in the representation or level of semantic detail in the trees. Rewriting can be thought of as a form of macro expansion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84cbe05d8623ccd8c2adba905f772e1af6572a6b" translate="yes" xml:space="preserve">
          <source>The query string submitted by the client to create this prepared statement. For prepared statements created via SQL, this is the &lt;code&gt;PREPARE&lt;/code&gt; statement submitted by the client. For prepared statements created via the frontend/backend protocol, this is the text of the prepared statement itself.</source>
          <target state="translated">客户端提交的用于创建此准备好的语句的查询字符串。对于通过SQL创建的准备好的语句，这是客户端提交的 &lt;code&gt;PREPARE&lt;/code&gt; 语句。对于通过前端/后端协议创建的准备好的语句，这是准备好的语句本身的文本。</target>
        </trans-unit>
        <trans-unit id="b1d53885b655d33f7ad2a2d0f4ca8ce4c9afa697" translate="yes" xml:space="preserve">
          <source>The query that is actually sent to the remote server for execution can be examined using &lt;code&gt;EXPLAIN VERBOSE&lt;/code&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;EXPLAIN VERBOSE&lt;/code&gt; 检查实际发送到远程服务器以执行的查询。</target>
        </trans-unit>
        <trans-unit id="bb7170c364ffc0983c042ed7b707bee01230d841" translate="yes" xml:space="preserve">
          <source>The query tree created by the transformation process is structurally similar to the raw parse tree in most places, but it has many differences in detail. For example, a &lt;code&gt;FuncCall&lt;/code&gt; node in the parse tree represents something that looks syntactically like a function call. This might be transformed to either a &lt;code&gt;FuncExpr&lt;/code&gt; or &lt;code&gt;Aggref&lt;/code&gt; node depending on whether the referenced name turns out to be an ordinary function or an aggregate function. Also, information about the actual data types of columns and expression results is added to the query tree.</source>
          <target state="translated">在大多数地方，由转换过程创建的查询树在结构上与原始解析树相似，但是在细节上有许多差异。例如，语法分析树中的 &lt;code&gt;FuncCall&lt;/code&gt; 节点表示某种在语法上类似于函数调用的内容。可以将其转换为 &lt;code&gt;FuncExpr&lt;/code&gt; 或 &lt;code&gt;Aggref&lt;/code&gt; 节点，具体取决于所引用的名称是普通函数还是聚合函数。同样，有关列和表达式结果的实际数据类型的信息也添加到查询树中。</target>
        </trans-unit>
        <trans-unit id="85e8ce3a8f2eab045a32523ebad51fd65a628dc9" translate="yes" xml:space="preserve">
          <source>The query uses any function marked &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt;. Most system-defined functions are &lt;code&gt;PARALLEL SAFE&lt;/code&gt;, but user-defined functions are marked &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; by default. See the discussion of &lt;a href=&quot;parallel-safety&quot;&gt;Section 15.4&lt;/a&gt;.</source>
          <target state="translated">该查询使用标记为 &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; 的任何函数。大多数系统定义的函数都是 &lt;code&gt;PARALLEL SAFE&lt;/code&gt; ，但是默认情况下，用户定义的函数被标记为 &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; 。参见&lt;a href=&quot;parallel-safety&quot;&gt;第15.4节&lt;/a&gt;的讨论。</target>
        </trans-unit>
        <trans-unit id="ae584697a944b3092f1bdba0372976965b96c14e" translate="yes" xml:space="preserve">
          <source>The query writes any data or locks any database rows. If a query contains a data-modifying operation either at the top level or within a CTE, no parallel plans for that query will be generated. As an exception, the commands &lt;code&gt;CREATE TABLE ... AS&lt;/code&gt;, &lt;code&gt;SELECT INTO&lt;/code&gt;, and &lt;code&gt;CREATE MATERIALIZED VIEW&lt;/code&gt; which create a new table and populate it can use a parallel plan.</source>
          <target state="translated">该查询将写入任何数据或锁定任何数据库行。如果查询在顶层或CTE内包含数据修改操作，则不会为该查询生成并行计划。作为例外，用于创建新表并填充该表的命令 &lt;code&gt;CREATE TABLE ... AS&lt;/code&gt; ， &lt;code&gt;SELECT INTO&lt;/code&gt; 和 &lt;code&gt;CREATE MATERIALIZED VIEW&lt;/code&gt; 可以使用并行计划。</target>
        </trans-unit>
        <trans-unit id="646431d95f05f7752d11dec325de9bca5192ab21" translate="yes" xml:space="preserve">
          <source>The radius of the Earth is obtained from the &lt;code&gt;earth()&lt;/code&gt; function. It is given in meters. But by changing this one function you can change the module to use some other units, or to use a different value of the radius that you feel is more appropriate.</source>
          <target state="translated">地球半径是从 &lt;code&gt;earth()&lt;/code&gt; 函数获得的。它以米为单位。但是，通过更改此功能，您可以更改模块以使用其他一些单位，或者使用您认为更合适的半径值。</target>
        </trans-unit>
        <trans-unit id="33dd011e0a27c9e4a8da0750e328420ec5636341" translate="yes" xml:space="preserve">
          <source>The range type's &lt;code&gt;subtype&lt;/code&gt; can be any type with an associated b-tree operator class (to determine the ordering of values for the range type). Normally the subtype's default b-tree operator class is used to determine ordering; to use a non-default operator class, specify its name with &lt;code&gt;subtype_opclass&lt;/code&gt;. If the subtype is collatable, and you want to use a non-default collation in the range's ordering, specify the desired collation with the &lt;code&gt;collation&lt;/code&gt; option.</source>
          <target state="translated">范围类型的 &lt;code&gt;subtype&lt;/code&gt; 可以是具有关联的b树运算符类的任何类型（以确定范围类型的值的顺序）。通常，子类型的默认b-tree运算符类用于确定顺序。要使用非默认运算符类，请使用 &lt;code&gt;subtype_opclass&lt;/code&gt; 指定其名称。如果子类型是可排序的，并且您要在范围的排序中使用非默认排序规则，请使用 &lt;code&gt;collation&lt;/code&gt; 选项指定所需的排序规则。</target>
        </trans-unit>
        <trans-unit id="45e371c3b97fa5eccf6d1070963f8eb35bb332f4" translate="yes" xml:space="preserve">
          <source>The rate is targeted by starting transactions along a Poisson-distributed schedule time line. The expected start time schedule moves forward based on when the client first started, not when the previous transaction ended. That approach means that when transactions go past their original scheduled end time, it is possible for later ones to catch up again.</source>
          <target state="translated">通过沿着泊松分布的计划时间线开始交易来锁定比率。预期的开始时间安排是根据客户第一次开始的时间,而不是前一次交易结束的时间向前移动的。这种方法意味着,当交易超过了原定的结束时间,后面的交易有可能再次赶上。</target>
        </trans-unit>
        <trans-unit id="f993d6ebc7309b2d31242d61b21f2b56ac8f6a72" translate="yes" xml:space="preserve">
          <source>The reason for separating raw parsing from semantic analysis is that system catalog lookups can only be done within a transaction, and we do not wish to start a transaction immediately upon receiving a query string. The raw parsing stage is sufficient to identify the transaction control commands (&lt;code&gt;BEGIN&lt;/code&gt;, &lt;code&gt;ROLLBACK&lt;/code&gt;, etc), and these can then be correctly executed without any further analysis. Once we know that we are dealing with an actual query (such as &lt;code&gt;SELECT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt;), it is okay to start a transaction if we're not already in one. Only then can the transformation process be invoked.</source>
          <target state="translated">将原始解析与语义分析分开的原因是，系统目录查找只能在事务内完成，并且我们不希望在收到查询字符串后立即启动事务。原始解析阶段足以识别事务控制命令（ &lt;code&gt;BEGIN&lt;/code&gt; ， &lt;code&gt;ROLLBACK&lt;/code&gt; 等），然后可以正确执行这些命令而无需任何进一步的分析。一旦知道要处理的是实际查询（例如 &lt;code&gt;SELECT&lt;/code&gt; 或 &lt;code&gt;UPDATE&lt;/code&gt; ），就可以开始事务（如果我们还不在其中）。只有这样，才能调用转换过程。</target>
        </trans-unit>
        <trans-unit id="2555cbea73ebf259be548a413cb3f00d947e85ce" translate="yes" xml:space="preserve">
          <source>The reason that periodic vacuuming solves the problem is that &lt;code&gt;VACUUM&lt;/code&gt; will mark rows as &lt;em&gt;frozen&lt;/em&gt;, indicating that they were inserted by a transaction that committed sufficiently far in the past that the effects of the inserting transaction are certain to be visible to all current and future transactions. Normal XIDs are compared using modulo-2&lt;sup&gt;32&lt;/sup&gt; arithmetic. This means that for every normal XID, there are two billion XIDs that are &amp;ldquo;older&amp;rdquo; and two billion that are &amp;ldquo;newer&amp;rdquo;; another way to say it is that the normal XID space is circular with no endpoint. Therefore, once a row version has been created with a particular normal XID, the row version will appear to be &amp;ldquo;in the past&amp;rdquo; for the next two billion transactions, no matter which normal XID we are talking about. If the row version still exists after more than two billion transactions, it will suddenly appear to be in the future. To prevent this, PostgreSQL reserves a special XID, &lt;code&gt;FrozenTransactionId&lt;/code&gt;, which does not follow the normal XID comparison rules and is always considered older than every normal XID. Frozen row versions are treated as if the inserting XID were &lt;code&gt;FrozenTransactionId&lt;/code&gt;, so that they will appear to be &amp;ldquo;in the past&amp;rdquo; to all normal transactions regardless of wraparound issues, and so such row versions will be valid until deleted, no matter how long that is.</source>
          <target state="translated">定期清理可以解决此问题的原因是 &lt;code&gt;VACUUM&lt;/code&gt; 会将行标记为&lt;em&gt;冻结&lt;/em&gt;，这表明它们是由过去已提交足够远的事务插入的，因此该插入事务的影响对于所有当前和将来的事务都是可见的。使用模2 &lt;sup&gt;32&lt;/sup&gt;比较普通XID&lt;sup&gt;&lt;/sup&gt;算术。这意味着对于每个普通的XID，有20亿个&amp;ldquo;旧&amp;rdquo; XID和20亿个&amp;ldquo;新&amp;rdquo; XID。换句话说，正常的XID空间是没有端点的循环。因此，一旦使用特定的普通XID创建了行版本，无论我们谈论的是哪个普通XID，该行版本都将成为接下来20亿次交易的&amp;ldquo;过去&amp;rdquo;。如果行版本在经过20亿次交易后仍然存在，那么它将突然出现在将来。为了防止这种情况，PostgreSQL保留了一个特殊的XID &lt;code&gt;FrozenTransactionId&lt;/code&gt; ，它不遵循常规XID比较规则，并且始终被认为比每个常规XID都旧。冻结的行版本被视为插入的XID是 &lt;code&gt;FrozenTransactionId&lt;/code&gt; ，这样它们对于所有常规事务来说似乎都是&amp;ldquo;过去的&amp;rdquo;，而不管折回问题如何，因此，无论行多长时间，此类行版本在删除之前都有效。</target>
        </trans-unit>
        <trans-unit id="3e52350494447bb6f36961ad4e797bd18a9eb61e" translate="yes" xml:space="preserve">
          <source>The reason that single quotes must be doubled, as shown in &lt;a href=&quot;datatype-binary#DATATYPE-BINARY-SQLESC&quot;&gt;Table 8.7&lt;/a&gt;, is that this is true for any string literal in a SQL command. The generic string-literal parser consumes the outermost single quotes and reduces any pair of single quotes to one data character. What the &lt;code&gt;bytea&lt;/code&gt; input function sees is just one single quote, which it treats as a plain data character. However, the &lt;code&gt;bytea&lt;/code&gt; input function treats backslashes as special, and the other behaviors shown in &lt;a href=&quot;datatype-binary#DATATYPE-BINARY-SQLESC&quot;&gt;Table 8.7&lt;/a&gt; are implemented by that function.</source>
          <target state="translated">如&lt;a href=&quot;datatype-binary#DATATYPE-BINARY-SQLESC&quot;&gt;表8.7&lt;/a&gt;所示，单引号必须加倍的原因是，这对于SQL命令中的任何字符串文字都是正确的。通用字符串文字解析器使用最外面的单引号，并将任何一对单引号都减少为一个数据字符。什么 &lt;code&gt;bytea&lt;/code&gt; 输入功能看到的只是一个单引号，它把作为一个普通的数据字符。但是， &lt;code&gt;bytea&lt;/code&gt; 输入函数将反斜杠视为特殊字符，&lt;a href=&quot;datatype-binary#DATATYPE-BINARY-SQLESC&quot;&gt;表8.7&lt;/a&gt;中所示的其他行为由该函数实现。</target>
        </trans-unit>
        <trans-unit id="035f0c664448dfa923a884566e84523654a5a8a5" translate="yes" xml:space="preserve">
          <source>The recommended method for configuring shared memory in macOS is to create a file named &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;, containing variable assignments such as:</source>
          <target state="translated">在macOS中配置共享内存的推荐方法是创建一个名为 &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 的文件，其中包含变量分配，例如：</target>
        </trans-unit>
        <trans-unit id="b6faaba60ea4ceaac002ffa0497dd503d8d8e004" translate="yes" xml:space="preserve">
          <source>The recommended recovery method in such cases is to drop the index and try again to perform &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt;. (Another possibility is to rebuild the index with &lt;code&gt;REINDEX INDEX CONCURRENTLY&lt;/code&gt;).</source>
          <target state="translated">在这种情况下，建议的恢复方法是删除索引，然后再次尝试执行 &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt; 。（另一种可能性是使用 &lt;code&gt;REINDEX INDEX CONCURRENTLY&lt;/code&gt; 重建索引）。</target>
        </trans-unit>
        <trans-unit id="65854068ac8d3288768569a456ffe6db4148ee2b" translate="yes" xml:space="preserve">
          <source>The recommended recovery method in such cases is to drop the invalid index and try again to perform &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt;. The concurrent index created during the processing has a name ending in the suffix &lt;code&gt;ccnew&lt;/code&gt;, or &lt;code&gt;ccold&lt;/code&gt; if it is an old index definition which we failed to drop. Invalid indexes can be dropped using &lt;code&gt;DROP INDEX&lt;/code&gt;, including invalid toast indexes.</source>
          <target state="translated">在这种情况下，建议的恢复方法是删除无效索引，然后再次尝试执行 &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt; 。在处理过程中产生的并发指数有一个名字的后缀结尾 &lt;code&gt;ccnew&lt;/code&gt; ，或者 &lt;code&gt;ccold&lt;/code&gt; 如果是，我们没能放下旧的索引定义。可以使用 &lt;code&gt;DROP INDEX&lt;/code&gt; 删除无效的索引，包括无效的吐司索引。</target>
        </trans-unit>
        <trans-unit id="dfc0dfd0875395d5ad4e9971dc3ba071b3c62b6b" translate="yes" xml:space="preserve">
          <source>The recommended syntax for referencing an ordered-set aggregate is to write &lt;code&gt;ORDER BY&lt;/code&gt; between the direct and aggregated argument specifications, in the same style as in &lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt;. However, it will also work to omit &lt;code&gt;ORDER BY&lt;/code&gt; and just run the direct and aggregated argument specifications into a single list. In this abbreviated form, if &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; was used in both the direct and aggregated argument lists, write &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; only once.</source>
          <target state="translated">推荐的引用有序集合聚合的语法是在直接参数和聚合参数规范之间编写 &lt;code&gt;ORDER BY&lt;/code&gt; ，其样式与&lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt;中的样式相同。但是，它也可以忽略 &lt;code&gt;ORDER BY&lt;/code&gt; ,而只将直接参数和聚合参数指定运行到单个列表中。在这个缩写形式，如果 &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; 在双方使用的直接和聚集参数列表，写 &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; 只有一次。</target>
        </trans-unit>
        <trans-unit id="2c54b57bbcf06dd2c13692d0332c35778b6cad50" translate="yes" xml:space="preserve">
          <source>The recursive query evaluation algorithm produces its output in breadth-first search order. You can display the results in depth-first search order by making the outer query &lt;code&gt;ORDER BY&lt;/code&gt; a &amp;ldquo;path&amp;rdquo; column constructed in this way.</source>
          <target state="translated">递归查询评估算法以广度优先搜索顺序产生其输出。通过使外部查询 &lt;code&gt;ORDER BY&lt;/code&gt; 以这种方式构造的&amp;ldquo;路径&amp;rdquo;列，可以按深度优先的搜索顺序显示结果。</target>
        </trans-unit>
        <trans-unit id="10c71ff4aa80650437aaee9d5a8e7f1f079dae18" translate="yes" xml:space="preserve">
          <source>The referenced object (which must be a role) is mentioned as the target of a dependent policy object.</source>
          <target state="translated">被引用的对象(必须是一个角色)被提及为依赖的策略对象的目标。</target>
        </trans-unit>
        <trans-unit id="c023a7885506a46d5cd80a1b95eea9a1b30194d8" translate="yes" xml:space="preserve">
          <source>The referenced object (which must be a role) is mentioned in the ACL (access control list, i.e., privileges list) of the dependent object. (A &lt;code&gt;SHARED_DEPENDENCY_ACL&lt;/code&gt; entry is not made for the owner of the object, since the owner will have a &lt;code&gt;SHARED_DEPENDENCY_OWNER&lt;/code&gt; entry anyway.)</source>
          <target state="translated">在从属对象的ACL（访问控制列表，即特权列表）中提到了引用的对象（必须是角色）。（由于对象的所有者 &lt;code&gt;SHARED_DEPENDENCY_ACL&lt;/code&gt; 条目，因此不会为对象的所有者创建 &lt;code&gt;SHARED_DEPENDENCY_OWNER&lt;/code&gt; 条目。）</target>
        </trans-unit>
        <trans-unit id="b0815ccf510952893128b6ac3763e885ed6f0544" translate="yes" xml:space="preserve">
          <source>The referenced object (which must be a role) is the owner of the dependent object.</source>
          <target state="translated">被引用的对象(必须是一个角色)是依赖对象的所有者。</target>
        </trans-unit>
        <trans-unit id="a3a42d2bcdc41726ac7929beb724897943cebede" translate="yes" xml:space="preserve">
          <source>The regular expression flag letters defined by XQuery are related to but not the same as the option letters for POSIX (&lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.23&lt;/a&gt;). While the &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt; options behave the same, others do not:</source>
          <target state="translated">XQuery定义的正则表达式标志字母与POSIX的选项字母相关但不相同（&lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;表9.23&lt;/a&gt;）。尽管 &lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;q&lt;/code&gt; 选项的行为相同，但其他选项却不一样：</target>
        </trans-unit>
        <trans-unit id="ae81b35c4a3c7dab3568d7bb9b480ebd9e7e6d71" translate="yes" xml:space="preserve">
          <source>The regular expression flag letters defined by XQuery are related to but not the same as the option letters for POSIX (&lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.24&lt;/a&gt;). While the &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt; options behave the same, others do not:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba9e7d00d7dfab39d193126f7366a926fa396e54" translate="yes" xml:space="preserve">
          <source>The relevant files have to be installed into &lt;code&gt;$pkglibdir/bitcode/$extension/&lt;/code&gt; and a summary of them into &lt;code&gt;$pkglibdir/bitcode/$extension.index.bc&lt;/code&gt;, where &lt;code&gt;$pkglibdir&lt;/code&gt; is the directory returned by &lt;code&gt;pg_config --pkglibdir&lt;/code&gt; and &lt;code&gt;$extension&lt;/code&gt; is the base name of the extension's shared library.</source>
          <target state="translated">相关文件必须安装到 &lt;code&gt;$pkglibdir/bitcode/$extension/&lt;/code&gt; ，并将它们的摘要安装到 &lt;code&gt;$pkglibdir/bitcode/$extension.index.bc&lt;/code&gt; ，其中 &lt;code&gt;$pkglibdir&lt;/code&gt; 是 &lt;code&gt;pg_config --pkglibdir&lt;/code&gt; 返回的目录，而 &lt;code&gt;$extension&lt;/code&gt; 是扩展程序共享库的基本名称。</target>
        </trans-unit>
        <trans-unit id="6ba726b7abb409f8a48dfda787ffd9ea8e7624bd" translate="yes" xml:space="preserve">
          <source>The relevant settings can be changed in &lt;code&gt;/etc/system&lt;/code&gt;, for example:</source>
          <target state="translated">可以在 &lt;code&gt;/etc/system&lt;/code&gt; 中更改相关设置，例如：</target>
        </trans-unit>
        <trans-unit id="7fd56dd803d0f7d0e1d83485ba93a1ea518a48b4" translate="yes" xml:space="preserve">
          <source>The remaining defaults are quite generously sized, and usually do not require changes.</source>
          <target state="translated">其余默认值的大小相当宽裕,通常不需要更改。</target>
        </trans-unit>
        <trans-unit id="e214a53b19603c5bd3de31f71ebb545b28127eb2" translate="yes" xml:space="preserve">
          <source>The remaining five input formats are not part of any standard.</source>
          <target state="translated">其余五种输入格式不属于任何标准。</target>
        </trans-unit>
        <trans-unit id="a23206cc28b1e52f80477ca74330c7ee7d48a063" translate="yes" xml:space="preserve">
          <source>The remaining forms change the session default for a run-time configuration variable for a PostgreSQL database. Whenever a new session is subsequently started in that database, the specified value becomes the session default value. The database-specific default overrides whatever setting is present in &lt;code&gt;postgresql.conf&lt;/code&gt; or has been received from the &lt;code&gt;postgres&lt;/code&gt; command line. Only the database owner or a superuser can change the session defaults for a database. Certain variables cannot be set this way, or can only be set by a superuser.</source>
          <target state="translated">其余形式更改了PostgreSQL数据库运行时配置变量的会话默认值。每当随后在该数据库中启动新会话时，指定的值即成为会话默认值。特定于数据库的默认设置将覆盖 &lt;code&gt;postgresql.conf&lt;/code&gt; 中存在的设置或从 &lt;code&gt;postgres&lt;/code&gt; 命令行接收到的任何设置。只有数据库所有者或超级用户才能更改数据库的会话默认值。某些变量不能以这种方式设置，或者只能由超级用户设置。</target>
        </trans-unit>
        <trans-unit id="657f4dc87f97eb4fa07203598556b9c37fdd908d" translate="yes" xml:space="preserve">
          <source>The remaining locale categories can be changed later when the server is started. You can also use &lt;code&gt;--locale&lt;/code&gt; to set the default for all locale categories, including collation order and character set classes. All server locale values (&lt;code&gt;lc_*&lt;/code&gt;) can be displayed via &lt;code&gt;SHOW ALL&lt;/code&gt;. More details can be found in &lt;a href=&quot;locale&quot;&gt;Section 23.1&lt;/a&gt;.</source>
          <target state="translated">服务器启动以后，可以更改其余的区域设置类别。您也可以使用 &lt;code&gt;--locale&lt;/code&gt; 设置所有语言环境类别的默认值，包括排序规则和字符集类。可以通过 &lt;code&gt;SHOW ALL&lt;/code&gt; 显示所有服务器的语言环境值（ &lt;code&gt;lc_*&lt;/code&gt; ）。更多细节可以在&lt;a href=&quot;locale&quot;&gt;第23.1节中&lt;/a&gt;找到。</target>
        </trans-unit>
        <trans-unit id="39583e46f87084afedd4c54635cee3575eddc6c6" translate="yes" xml:space="preserve">
          <source>The remaining variants change a role's session default for a configuration variable, either for all databases or, when the &lt;code&gt;IN DATABASE&lt;/code&gt; clause is specified, only for sessions in the named database. If &lt;code&gt;ALL&lt;/code&gt; is specified instead of a role name, this changes the setting for all roles. Using &lt;code&gt;ALL&lt;/code&gt; with &lt;code&gt;IN DATABASE&lt;/code&gt; is effectively the same as using the command &lt;code&gt;ALTER DATABASE ... SET ...&lt;/code&gt;.</source>
          <target state="translated">其余的变体将更改配置变量的角色会话默认值，无论是对于所有数据库，还是在指定 &lt;code&gt;IN DATABASE&lt;/code&gt; 子句时，仅针对命名数据库中的会话。如果指定了 &lt;code&gt;ALL&lt;/code&gt; 而不是角色名称，则将更改所有角色的设置。在 &lt;code&gt;IN DATABASE&lt;/code&gt; 中使用 &lt;code&gt;ALL&lt;/code&gt; 与在命令 &lt;code&gt;ALTER DATABASE ... SET ...&lt;/code&gt; 使用相同。</target>
        </trans-unit>
        <trans-unit id="5290f23dd3a823420c1c9cce7d4e8058bd8eb3fa" translate="yes" xml:space="preserve">
          <source>The remaining variants change the owner and the name of the publication.</source>
          <target state="translated">其余变体则改变了所有者和出版物的名称。</target>
        </trans-unit>
        <trans-unit id="fd818ebf2b83e4b29f88c818dcaf7941b628e1ea" translate="yes" xml:space="preserve">
          <source>The remote schema to import from. The specific meaning of a remote schema depends on the foreign data wrapper in use.</source>
          <target state="translated">要导入的远程模式。远程模式的具体含义取决于所使用的外来数据封装器。</target>
        </trans-unit>
        <trans-unit id="c2f6cfebe2ad1dd2cbdde5a3b92b04d140d615ff" translate="yes" xml:space="preserve">
          <source>The remote transaction uses &lt;code&gt;SERIALIZABLE&lt;/code&gt; isolation level when the local transaction has &lt;code&gt;SERIALIZABLE&lt;/code&gt; isolation level; otherwise it uses &lt;code&gt;REPEATABLE READ&lt;/code&gt; isolation level. This choice ensures that if a query performs multiple table scans on the remote server, it will get snapshot-consistent results for all the scans. A consequence is that successive queries within a single transaction will see the same data from the remote server, even if concurrent updates are occurring on the remote server due to other activities. That behavior would be expected anyway if the local transaction uses &lt;code&gt;SERIALIZABLE&lt;/code&gt; or &lt;code&gt;REPEATABLE READ&lt;/code&gt; isolation level, but it might be surprising for a &lt;code&gt;READ COMMITTED&lt;/code&gt; local transaction. A future PostgreSQL release might modify these rules.</source>
          <target state="translated">远程事务使用 &lt;code&gt;SERIALIZABLE&lt;/code&gt; 当本地事务具有隔离级别 &lt;code&gt;SERIALIZABLE&lt;/code&gt; 隔离级别;否则，它将使用 &lt;code&gt;REPEATABLE READ&lt;/code&gt; 隔离级别。此选择可确保如果查询在远程服务器上执行多个表扫描，它将为所有扫描获取快照一致的结果。结果是，即使由于其他活动而在远程服务器上发生并发更新，单个事务中的连续查询也将从远程服务器看到相同的数据。如果本地事务使用 &lt;code&gt;SERIALIZABLE&lt;/code&gt; 或 &lt;code&gt;REPEATABLE READ&lt;/code&gt; 隔离级别，则无论如何都会发生该行为，但对于 &lt;code&gt;READ COMMITTED&lt;/code&gt; 来说可能令人惊讶本地交易。将来的Pos​​tgreSQL版本可能会修改这些规则。</target>
        </trans-unit>
        <trans-unit id="b784ef85aba666ab41976b71fec7b8c205701bef" translate="yes" xml:space="preserve">
          <source>The reported &lt;code&gt;index_size&lt;/code&gt; will normally correspond to one more page than is accounted for by &lt;code&gt;internal_pages + leaf_pages + empty_pages + deleted_pages&lt;/code&gt;, because it also includes the index's metapage.</source>
          <target state="translated">报告的 &lt;code&gt;index_size&lt;/code&gt; 通常比因 &lt;code&gt;internal_pages + leaf_pages + empty_pages + deleted_pages&lt;/code&gt; 所占的页面多一格，因为它还包括索引的元页面。</target>
        </trans-unit>
        <trans-unit id="55f0c215e7b27076f4a6dfbf779db270819931cc" translate="yes" xml:space="preserve">
          <source>The reported lag times are not predictions of how long it will take for the standby to catch up with the sending server assuming the current rate of replay. Such a system would show similar times while new WAL is being generated, but would differ when the sender becomes idle. In particular, when the standby has caught up completely, &lt;code&gt;pg_stat_replication&lt;/code&gt; shows the time taken to write, flush and replay the most recent reported WAL location rather than zero as some users might expect. This is consistent with the goal of measuring synchronous commit and transaction visibility delays for recent write transactions. To reduce confusion for users expecting a different model of lag, the lag columns revert to NULL after a short time on a fully replayed idle system. Monitoring systems should choose whether to represent this as missing data, zero or continue to display the last known value.</source>
          <target state="translated">假设当前的重放速率，所报告的滞后时间并不是对备用服务器追上发送服务器将花费多长时间的预测。这样的系统在生成新的WAL时将显示相似的时间，但是在发送方变为空闲时将有所不同。特别是，当备用数据库完全赶上时， &lt;code&gt;pg_stat_replication&lt;/code&gt; 显示了写入，刷新和重播最近报告的WAL位置所花费的时间，而不是某些用户可能期望的零。这与测量最近写入事务的同步提交和事务可见性延迟的目标一致。为了减少对于期望使用不同延迟模型的用户的困惑，在完全重播的空闲系统上，延迟列会在短时间后恢复为NULL。监视系统应选择将其表示为丢失的数据，零还是继续显示最后的已知值。</target>
        </trans-unit>
        <trans-unit id="a645551df2ec2063cbaae776527e78ce19d49632" translate="yes" xml:space="preserve">
          <source>The representative query texts are kept in an external disk file, and do not consume shared memory. Therefore, even very lengthy query texts can be stored successfully. However, if many long query texts are accumulated, the external file might grow unmanageably large. As a recovery method if that happens, &lt;code&gt;pg_stat_statements&lt;/code&gt; may choose to discard the query texts, whereupon all existing entries in the &lt;code&gt;pg_stat_statements&lt;/code&gt; view will show null &lt;code&gt;query&lt;/code&gt; fields, though the statistics associated with each &lt;code&gt;queryid&lt;/code&gt; are preserved. If this happens, consider reducing &lt;code&gt;pg_stat_statements.max&lt;/code&gt; to prevent recurrences.</source>
          <target state="translated">代表性查询文本保存在外部磁盘文件中，并且不占用共享内存。因此，即使很长的查询文本也可以成功存储。但是，如果积累了许多长查询文本，则外部文件可能会变得难以管理。作为一种恢复方法（如果发生这种情况）， &lt;code&gt;pg_stat_statements&lt;/code&gt; 可以选择放弃查询文本，从而 &lt;code&gt;pg_stat_statements&lt;/code&gt; 视图中的所有现有条目将显示空 &lt;code&gt;query&lt;/code&gt; 字段，尽管会保留与每个 &lt;code&gt;queryid&lt;/code&gt; 相关的统计信息。如果发生这种情况，请考虑减少 &lt;code&gt;pg_stat_statements.max&lt;/code&gt; 以防止再次发生。</target>
        </trans-unit>
        <trans-unit id="af46176f2702f864ba766599fbfd240339b13483" translate="yes" xml:space="preserve">
          <source>The required &lt;code&gt;COLUMNS&lt;/code&gt; clause specifies the column(s) that will be produced in the output table. See the syntax summary above for the format. A name is required for each column, as is a data type (unless &lt;code&gt;FOR ORDINALITY&lt;/code&gt; is specified, in which case type &lt;code&gt;integer&lt;/code&gt; is implicit). The path, default and nullability clauses are optional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e8d7c0fc3cb406e8f13266456fbfe6097e7dd7f" translate="yes" xml:space="preserve">
          <source>The required &lt;code&gt;row_expression&lt;/code&gt; argument is an XPath 1.0 expression (given as &lt;code&gt;text&lt;/code&gt;) that is evaluated, passing the XML value &lt;code&gt;document_expression&lt;/code&gt; as its context item, to obtain a set of XML nodes. These nodes are what &lt;code&gt;xmltable&lt;/code&gt; transforms into output rows. No rows will be produced if the &lt;code&gt;document_expression&lt;/code&gt; is null, nor if the &lt;code&gt;row_expression&lt;/code&gt; produces an empty node-set or any value other than a node-set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ec95cfaa7fde5c159e36da65695933b4d1251cc" translate="yes" xml:space="preserve">
          <source>The required &lt;code&gt;row_expression&lt;/code&gt; argument is an XPath 1.0 expression that is evaluated, passing the &lt;code&gt;document_expression&lt;/code&gt; as its context item, to obtain a set of XML nodes. These nodes are what &lt;code&gt;xmltable&lt;/code&gt; transforms into output rows. No rows will be produced if the &lt;code&gt;document_expression&lt;/code&gt; is null, nor if the &lt;code&gt;row_expression&lt;/code&gt; produces an empty node-set or any value other than a node-set.</source>
          <target state="translated">必需的 &lt;code&gt;row_expression&lt;/code&gt; 参数是一个XPath 1.0表达式，该表达式经过评估，将 &lt;code&gt;document_expression&lt;/code&gt; 作为其上下文项传递，以获得一组XML节点。这些节点是 &lt;code&gt;xmltable&lt;/code&gt; 转换成输出行的对象。如果 &lt;code&gt;document_expression&lt;/code&gt; 为null，或者 &lt;code&gt;row_expression&lt;/code&gt; 产生空的节点集或除节点集以外的任何值，则不会产生任何行。</target>
        </trans-unit>
        <trans-unit id="b11399ca691e0ca5b399e8672e2715124cece495" translate="yes" xml:space="preserve">
          <source>The requirement to escape &lt;em&gt;non-printable&lt;/em&gt; octets varies depending on locale settings. In some instances you can get away with leaving them unescaped.</source>
          <target state="translated">对&lt;em&gt;不可打印&lt;/em&gt;八位字节进行转义的要求取决于语言环境设置。在某些情况下，您可以使它们保持原样。</target>
        </trans-unit>
        <trans-unit id="b1fdcf794bda35b8905b9d7b4d4c5b307eaf0f21" translate="yes" xml:space="preserve">
          <source>The resolution can be done either by changing data on the subscriber so that it does not conflict with the incoming change or by skipping the transaction that conflicts with the existing data. The transaction can be skipped by calling the &lt;a href=&quot;functions-admin#PG-REPLICATION-ORIGIN-ADVANCE&quot;&gt;&lt;code&gt;pg_replication_origin_advance()&lt;/code&gt;&lt;/a&gt; function with a &lt;em&gt;&lt;code&gt;node_name&lt;/code&gt;&lt;/em&gt; corresponding to the subscription name, and a position. The current position of origins can be seen in the &lt;a href=&quot;view-pg-replication-origin-status&quot;&gt;&lt;code&gt;pg_replication_origin_status&lt;/code&gt;&lt;/a&gt; system view.</source>
          <target state="translated">可以通过更改订户上的数据以使其与传入的更改不冲突，或者跳过与现有数据冲突的事务来解决该问题。可以通过调用&lt;a href=&quot;functions-admin#PG-REPLICATION-ORIGIN-ADVANCE&quot;&gt; &lt;code&gt;pg_replication_origin_advance()&lt;/code&gt; &lt;/a&gt;函数（带有与预订名称相对应的&lt;em&gt; &lt;code&gt;node_name&lt;/code&gt; &lt;/em&gt;和位置）来跳过事务。原点的当前位置可以在&lt;a href=&quot;view-pg-replication-origin-status&quot;&gt; &lt;code&gt;pg_replication_origin_status&lt;/code&gt; &lt;/a&gt;系统视图中看到。</target>
        </trans-unit>
        <trans-unit id="723a98a8202cef2494a119e8677686ce411c0bb4" translate="yes" xml:space="preserve">
          <source>The response indicates that the large object received object ID 152801, which can be used to access the newly-created large object in the future. For the sake of readability, it is recommended to always associate a human-readable comment with every object. Both OIDs and comments can be viewed with the &lt;code&gt;\lo_list&lt;/code&gt; command.</source>
          <target state="translated">该响应指示大对象接收到对象ID 152801，该对象ID将来可用于访问新创建的大对象。为了便于阅读，建议始终将人类可读的注释与每个对象相关联。OID和注释都可以使用 &lt;code&gt;\lo_list&lt;/code&gt; 命令查看。</target>
        </trans-unit>
        <trans-unit id="2934d0e903001f7986e041f38eab1c8c1f288032" translate="yes" xml:space="preserve">
          <source>The restriction for the join is &lt;code&gt;t2.unique2 = t1.unique2&lt;/code&gt;. The operator is just our familiar &lt;code&gt;=&lt;/code&gt;, however the selectivity function is obtained from the &lt;code&gt;oprjoin&lt;/code&gt; column of &lt;code&gt;pg_operator&lt;/code&gt;, and is &lt;code&gt;eqjoinsel&lt;/code&gt;. &lt;code&gt;eqjoinsel&lt;/code&gt; looks up the statistical information for both &lt;code&gt;tenk2&lt;/code&gt; and &lt;code&gt;tenk1&lt;/code&gt;:</source>
          <target state="translated">连接的限制为 &lt;code&gt;t2.unique2 = t1.unique2&lt;/code&gt; 。运营商只是我们熟悉的 &lt;code&gt;=&lt;/code&gt; ，但是从获得的选择性功能 &lt;code&gt;oprjoin&lt;/code&gt; 列 &lt;code&gt;pg_operator&lt;/code&gt; 表，并 &lt;code&gt;eqjoinsel&lt;/code&gt; 。 &lt;code&gt;eqjoinsel&lt;/code&gt; 查找 &lt;code&gt;tenk2&lt;/code&gt; 和 &lt;code&gt;tenk1&lt;/code&gt; 的统计信息：</target>
        </trans-unit>
        <trans-unit id="42ea840e6963b1db2f144f830a72190a8a92d8a7" translate="yes" xml:space="preserve">
          <source>The restriction on &lt;code&gt;tenk1&lt;/code&gt;, &lt;code&gt;unique1 &amp;lt; 50&lt;/code&gt;, is evaluated before the nested-loop join. This is handled analogously to the previous range example. This time the value 50 falls into the first bucket of the &lt;code&gt;unique1&lt;/code&gt; histogram:</source>
          <target state="translated">在嵌套循环连接之前评估对 &lt;code&gt;tenk1&lt;/code&gt; 的限制， &lt;code&gt;unique1 &amp;lt; 50&lt;/code&gt; 。与前面的范围示例类似地进行处理。这次，值50落入 &lt;code&gt;unique1&lt;/code&gt; 直方图的第一个存储桶中：</target>
        </trans-unit>
        <trans-unit id="80154a0c17a7ca3699a207d67e1600353cb2e59b" translate="yes" xml:space="preserve">
          <source>The restriction selectivity estimator function for this operator.</source>
          <target state="translated">该算子的限制选择性估计函数。</target>
        </trans-unit>
        <trans-unit id="c1e9d6876e675991a0158e89b5c587ee7ffe971a" translate="yes" xml:space="preserve">
          <source>The restriction selectivity estimator function for this operator; write NONE to remove existing selectivity estimator.</source>
          <target state="translated">该运算符的限制选择性估计函数;写NONE以删除现有的选择性估计函数。</target>
        </trans-unit>
        <trans-unit id="bff27a668430c02df3bea2ab6b32530d85a3310d" translate="yes" xml:space="preserve">
          <source>The result has the same type as the first argument &amp;mdash; but there is a subtlety. What is actually returned is the first argument of the implied &lt;code&gt;=&lt;/code&gt; operator, and in some cases that will have been promoted to match the second argument's type. For example, &lt;code&gt;NULLIF(1, 2.2)&lt;/code&gt; yields &lt;code&gt;numeric&lt;/code&gt;, because there is no &lt;code&gt;integer&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;numeric&lt;/code&gt; operator, only &lt;code&gt;numeric&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;numeric&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e176f734fe6408fc6b88696f88ea896277748c08" translate="yes" xml:space="preserve">
          <source>The result is equivalent to replacing the target data directory with the source one. Only changed blocks from relation files are copied; all other files are copied in full, including configuration files. The advantage of pg_rewind over taking a new base backup, or tools like rsync, is that pg_rewind does not require reading through unchanged blocks in the cluster. This makes it a lot faster when the database is large and only a small fraction of blocks differ between the clusters.</source>
          <target state="translated">其结果相当于将目标数据目录替换为源数据目录。只有关系文件中的更改块会被复制,其他所有文件都会被完整复制,包括配置文件。与采取新的基础备份,或者像rsync这样的工具相比,pg_rewind的优势在于,pg_rewind不需要读取集群中未改变的块。这使得当数据库很大,而且集群之间只有一小部分块不同时,速度会快很多。</target>
        </trans-unit>
        <trans-unit id="71c257a34cf97f05e33ccd5803182c14ff7c7772" translate="yes" xml:space="preserve">
          <source>The result looks like &lt;code&gt;/CN=Somebody /C=Some country/O=Some organization&lt;/code&gt;.</source>
          <target state="translated">结果看起来像 &lt;code&gt;/CN=Somebody /C=Some country/O=Some organization&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="465e9b5b70493d1bded19fc1f9a4a0487651fc46" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;EXCEPT&lt;/code&gt; does not contain any duplicate rows unless the &lt;code&gt;ALL&lt;/code&gt; option is specified. With &lt;code&gt;ALL&lt;/code&gt;, a row that has &lt;code&gt;m&lt;/code&gt; duplicates in the left table and &lt;code&gt;n&lt;/code&gt; duplicates in the right table will appear max(&lt;code&gt;m&lt;/code&gt;-&lt;code&gt;n&lt;/code&gt;,0) times in the result set. &lt;code&gt;DISTINCT&lt;/code&gt; can be written to explicitly specify the default behavior of eliminating duplicate rows.</source>
          <target state="translated">除非指定了 &lt;code&gt;ALL&lt;/code&gt; 选项，否则 &lt;code&gt;EXCEPT&lt;/code&gt; 的结果将不包含任何重复的行。使用 &lt;code&gt;ALL&lt;/code&gt; 时，在左表中具有 &lt;code&gt;m&lt;/code&gt; 个重复项且在右表中具有 &lt;code&gt;n&lt;/code&gt; 个重复项的行将在结果集中出现max（ &lt;code&gt;m&lt;/code&gt; - &lt;code&gt;n&lt;/code&gt; ，0）次。可以编写 &lt;code&gt;DISTINCT&lt;/code&gt; 来明确指定消除重复行的默认行为。</target>
        </trans-unit>
        <trans-unit id="8e065829e339ca2263a957857644dcd1c568a754" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;INTERSECT&lt;/code&gt; does not contain any duplicate rows unless the &lt;code&gt;ALL&lt;/code&gt; option is specified. With &lt;code&gt;ALL&lt;/code&gt;, a row that has &lt;code&gt;m&lt;/code&gt; duplicates in the left table and &lt;code&gt;n&lt;/code&gt; duplicates in the right table will appear min(&lt;code&gt;m&lt;/code&gt;,&lt;code&gt;n&lt;/code&gt;) times in the result set. &lt;code&gt;DISTINCT&lt;/code&gt; can be written to explicitly specify the default behavior of eliminating duplicate rows.</source>
          <target state="translated">除非指定 &lt;code&gt;ALL&lt;/code&gt; 选项，否则 &lt;code&gt;INTERSECT&lt;/code&gt; 的结果不包含任何重复的行。使用 &lt;code&gt;ALL&lt;/code&gt; 时，在左表中具有 &lt;code&gt;m&lt;/code&gt; 个重复项而在右表中具有 &lt;code&gt;n&lt;/code&gt; 个重复项的行将在结果集中出现min（ &lt;code&gt;m&lt;/code&gt; ， &lt;code&gt;n&lt;/code&gt; ）次。可以编写 &lt;code&gt;DISTINCT&lt;/code&gt; 来明确指定消除重复行的默认行为。</target>
        </trans-unit>
        <trans-unit id="2ef35ef4ee4e7ace61e6bdb22721c0932c911c40" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;UNION&lt;/code&gt; does not contain any duplicate rows unless the &lt;code&gt;ALL&lt;/code&gt; option is specified. &lt;code&gt;ALL&lt;/code&gt; prevents elimination of duplicates. (Therefore, &lt;code&gt;UNION ALL&lt;/code&gt; is usually significantly quicker than &lt;code&gt;UNION&lt;/code&gt;; use &lt;code&gt;ALL&lt;/code&gt; when you can.) &lt;code&gt;DISTINCT&lt;/code&gt; can be written to explicitly specify the default behavior of eliminating duplicate rows.</source>
          <target state="translated">除非指定了 &lt;code&gt;ALL&lt;/code&gt; 选项，否则 &lt;code&gt;UNION&lt;/code&gt; 的结果不包含任何重复的行。 &lt;code&gt;ALL&lt;/code&gt; 防止重复项的消除。（因此， &lt;code&gt;UNION ALL&lt;/code&gt; 通常比 &lt;code&gt;UNION&lt;/code&gt; 快得多；请尽可能使用 &lt;code&gt;ALL&lt;/code&gt; 。）可以编写 &lt;code&gt;DISTINCT&lt;/code&gt; 来明确指定消除重复行的默认行为。</target>
        </trans-unit>
        <trans-unit id="72402b7b0b331fd1b54d5308fde49885c6b05ef8" translate="yes" xml:space="preserve">
          <source>The result of a database content mapping looks like this:</source>
          <target state="translated">数据库内容映射的结果是这样的。</target>
        </trans-unit>
        <trans-unit id="5bf0f22088cf3019c1a1b1dbed662be7a69e9148" translate="yes" xml:space="preserve">
          <source>The result of a schema content mapping looks like this:</source>
          <target state="translated">模式内容映射的结果是这样的。</target>
        </trans-unit>
        <trans-unit id="31f7fafc96662c4abec5838f93938c08f12e39f5" translate="yes" xml:space="preserve">
          <source>The result of each path evaluation step can be processed by one or more &lt;code&gt;jsonpath&lt;/code&gt; operators and methods listed in &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH-OPERATORS&quot;&gt;Section 9.15.2.3&lt;/a&gt;. Each method name must be preceded by a dot. For example, you can get an array size:</source>
          <target state="translated">每个路径评估步骤的结果都可以由&lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH-OPERATORS&quot;&gt;第9.15.2.3节中&lt;/a&gt;列出的一个或多个 &lt;code&gt;jsonpath&lt;/code&gt; 运算符和方法处理。每个方法名称前必须加一个点。例如，您可以获得一个数组大小：</target>
        </trans-unit>
        <trans-unit id="ec7ce6cfc1de15ad9d69c5a41b7880b123d8687e" translate="yes" xml:space="preserve">
          <source>The result of each path evaluation step can be processed by one or more &lt;code&gt;jsonpath&lt;/code&gt; operators and methods listed in &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH-OPERATORS&quot;&gt;Section 9.16.2.2&lt;/a&gt;. Each method name must be preceded by a dot. For example, you can get the size of an array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c39389298dad4176af2cd2f4f928038308a6b18" translate="yes" xml:space="preserve">
          <source>The result of successfully committing a group of transactions is inconsistent with all possible orderings of running those transactions one at a time.</source>
          <target state="translated">成功提交一组事务的结果与每次运行这些事务的所有可能顺序不一致。</target>
        </trans-unit>
        <trans-unit id="f90d6b2c73e8ea4c0551da0df475a8d425331eb2" translate="yes" xml:space="preserve">
          <source>The result of the &lt;code&gt;union&lt;/code&gt; function must be a value of the index's storage type, whatever that is (it might or might not be different from the indexed column's type). The &lt;code&gt;union&lt;/code&gt; function should return a pointer to newly &lt;code&gt;palloc()&lt;/code&gt;ed memory. You can't just return the input value as-is, even if there is no type change.</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; 函数的结果必须是索引的存储类型的值，无论该值是什么（它可能与索引列的类型相同或不同）。该 &lt;code&gt;union&lt;/code&gt; 函数应该返回一个指向新 &lt;code&gt;palloc()&lt;/code&gt; 版内存。即使没有类型更改，也不能照原样返回输入值。</target>
        </trans-unit>
        <trans-unit id="1b294fef53c3a5221592cc68d2bcc8aa48d712cd" translate="yes" xml:space="preserve">
          <source>The result of the function is a single record. The &lt;em&gt;&lt;code&gt;lsn&lt;/code&gt;&lt;/em&gt; column holds the backup's ending write-ahead log location (which again can be ignored). The second and third columns are &lt;code&gt;NULL&lt;/code&gt; when ending an exclusive backup; after a non-exclusive backup they hold the desired contents of the label and tablespace map files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4a9c39c953a9312145a45ccbb983953c2e08ee1" translate="yes" xml:space="preserve">
          <source>The result of the previous two inserts looks like this:</source>
          <target state="translated">前面两个插入的结果是这样的。</target>
        </trans-unit>
        <trans-unit id="b464f588a5c51e3217548207540b5bba236a02d5" translate="yes" xml:space="preserve">
          <source>The result returned by &lt;code&gt;setval&lt;/code&gt; is just the value of its second argument.</source>
          <target state="translated">&lt;code&gt;setval&lt;/code&gt; 返回的结果只是其第二个参数的值。</target>
        </trans-unit>
        <trans-unit id="94a3bc7cb16b6aa14b4272070826c46eaa5db71f" translate="yes" xml:space="preserve">
          <source>The result type of the &lt;code&gt;datetime()&lt;/code&gt; and &lt;code&gt;datetime(template)&lt;/code&gt; methods can be &lt;code&gt;date&lt;/code&gt;, &lt;code&gt;timetz&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;timestamptz&lt;/code&gt;, or &lt;code&gt;timestamp&lt;/code&gt;. Both methods determine their result type dynamically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5675fc85ce2eab9d13414767f82a9b7b9d9a68bc" translate="yes" xml:space="preserve">
          <source>The resulting dump can be restored with psql:</source>
          <target state="translated">结果的dump可以用psql恢复。</target>
        </trans-unit>
        <trans-unit id="bd98dcbc013dfe386ef25cd013047250a70319f2" translate="yes" xml:space="preserve">
          <source>The results of the &lt;code&gt;in_range&lt;/code&gt; function must be consistent with the sort ordering imposed by the operator family. To be precise, given any fixed values of &lt;code&gt;offset&lt;/code&gt; and &lt;code&gt;sub&lt;/code&gt;, then:</source>
          <target state="translated">&lt;code&gt;in_range&lt;/code&gt; 函数的结果必须与运算符系列施加的排序顺序一致。确切地说，给定 &lt;code&gt;offset&lt;/code&gt; 和 &lt;code&gt;sub&lt;/code&gt; 的任何固定值，则：</target>
        </trans-unit>
        <trans-unit id="09c3bbabf641766b5c1086657a825502c1601a40" translate="yes" xml:space="preserve">
          <source>The results of two queries can be combined using the set operations union, intersection, and difference. The syntax is</source>
          <target state="translated">两个查询的结果可以使用集合运算union、intersection和difference进行组合。语法是</target>
        </trans-unit>
        <trans-unit id="6af5cccdc36b9ba47ebe00f94b9f0ae450f2173e" translate="yes" xml:space="preserve">
          <source>The return data type (optionally schema-qualified). The return type can be a base, composite, or domain type, or can reference the type of a table column. Depending on the implementation language it might also be allowed to specify &amp;ldquo;pseudo-types&amp;rdquo; such as &lt;code&gt;cstring&lt;/code&gt;. If the function is not supposed to return a value, specify &lt;code&gt;void&lt;/code&gt; as the return type.</source>
          <target state="translated">返回数据类型（可选，通过模式限定）。返回类型可以是基本类型，复合类型或域类型，或者可以引用表列的类型。根据实现语言的不同，也可以允许指定&amp;ldquo;伪类型&amp;rdquo;，例如 &lt;code&gt;cstring&lt;/code&gt; 。如果该函数不应该返回值，则将 &lt;code&gt;void&lt;/code&gt; 指定为返回类型。</target>
        </trans-unit>
        <trans-unit id="68f515e9225e3a8bd926fdcf278047adb080a143" translate="yes" xml:space="preserve">
          <source>The return type of a cast function must be identical to or binary-coercible to the cast's target type.</source>
          <target state="translated">铸函数的返回类型必须与铸函数的目标类型相同或可二进制计算。</target>
        </trans-unit>
        <trans-unit id="e79b9ffc9a06ade0f94c181bff76d0c5e0055f02" translate="yes" xml:space="preserve">
          <source>The return type of each function is &lt;code&gt;xml&lt;/code&gt;.</source>
          <target state="translated">每个函数的返回类型为 &lt;code&gt;xml&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ccb6d89ec3d8d5f1a14886d00086edc74d4f798" translate="yes" xml:space="preserve">
          <source>The return value is static information about an operator class and collation. Returning &lt;code&gt;true&lt;/code&gt; indicates that the &lt;code&gt;order&lt;/code&gt; function for the operator class is guaranteed to only return &lt;code&gt;0&lt;/code&gt; (&amp;ldquo;arguments are equal&amp;rdquo;) when its &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; arguments are also interchangeable without any loss of semantic information. Not registering an &lt;code&gt;equalimage&lt;/code&gt; function or returning &lt;code&gt;false&lt;/code&gt; indicates that this condition cannot be assumed to hold.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae53d800dbf466337096571156e983ea2cef4a1a" translate="yes" xml:space="preserve">
          <source>The returned columns correspond to the fields in the &lt;code&gt;BrinMemTuple&lt;/code&gt; and &lt;code&gt;BrinValues&lt;/code&gt; structs. See &lt;code&gt;src/include/access/brin_tuple.h&lt;/code&gt; for details.</source>
          <target state="translated">返回的列对应于 &lt;code&gt;BrinMemTuple&lt;/code&gt; 和 &lt;code&gt;BrinValues&lt;/code&gt; 结构中的字段。有关详细信息，请参见 &lt;code&gt;src/include/access/brin_tuple.h&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cbe5a0ea635cc6baf516f6e2eb370c36b529a917" translate="yes" xml:space="preserve">
          <source>The returned columns correspond to the fields in the &lt;code&gt;PageHeaderData&lt;/code&gt; struct. See &lt;code&gt;src/include/storage/bufpage.h&lt;/code&gt; for details.</source>
          <target state="translated">返回的列与 &lt;code&gt;PageHeaderData&lt;/code&gt; 结构中的字段相对应。有关详细信息，请参见 &lt;code&gt;src/include/storage/bufpage.h&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9ce8dcca026fdd1326a0feb6d5dcbe4fd79aa2a7" translate="yes" xml:space="preserve">
          <source>The rewriting forms of &lt;code&gt;ALTER TABLE&lt;/code&gt; are not MVCC-safe. After a table rewrite, the table will appear empty to concurrent transactions, if they are using a snapshot taken before the rewrite occurred. See &lt;a href=&quot;mvcc-caveats&quot;&gt;Section 13.5&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;ALTER TABLE&lt;/code&gt; 的重写形式不是MVCC安全的。在表重写之后，如果并发事务使用的是在重写发生之前拍摄的快照，则该表将对并发事务显示为空。有关更多详细信息，请参见&lt;a href=&quot;mvcc-caveats&quot;&gt;第13.5节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9dd9c3f397a07f60ffdbedaa5659c2ca90ab6d90" translate="yes" xml:space="preserve">
          <source>The right to drop an object, or to alter its definition in any way, is not treated as a grantable privilege; it is inherent in the owner, and cannot be granted or revoked. (However, a similar effect can be obtained by granting or revoking membership in the role that owns the object; see below.) The owner implicitly has all grant options for the object, too.</source>
          <target state="translated">撤销一个对象或以任何方式改变其定义的权利不被视为可授予的特权;它是所有者固有的,不能授予或撤销。然而,通过授予或撤销拥有对象的角色的成员资格,可以获得类似的效果;见下文)。所有者也隐含地拥有该物体的所有授予选择权。</target>
        </trans-unit>
        <trans-unit id="1485f3d0af50f7ad2c38bab6ab4b82f7cade74e8" translate="yes" xml:space="preserve">
          <source>The right to modify or destroy an object is always the privilege of the owner only.</source>
          <target state="translated">修改或毁坏物体的权利永远只属于所有者的特权。</target>
        </trans-unit>
        <trans-unit id="081b4bb5f9bb63c56a6d0ef4a59ec5296ea9be8b" translate="yes" xml:space="preserve">
          <source>The right to modify or destroy an object is inherent in being the object's owner, and cannot be granted or revoked in itself. (However, like all privileges, that right can be inherited by members of the owning role; see &lt;a href=&quot;role-membership&quot;&gt;Section 21.3&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4b02a1fae471a2cfa0b9f0f9afcb866f7eeb267" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized expression, which must yield an array value. The left-hand expression is evaluated and compared to each element of the array using the given &lt;code&gt;operator&lt;/code&gt;, which must yield a Boolean result. The result of &lt;code&gt;ALL&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if all comparisons yield true (including the case where the array has zero elements). The result is &amp;ldquo;false&amp;rdquo; if any false result is found.</source>
          <target state="translated">右边是带括号的表达式，必须产生一个数组值。将使用给定的 &lt;code&gt;operator&lt;/code&gt; 评估左侧表达式并将其与数组的每个元素进行比较，该运算符必须产生布尔结果。如果所有比较结果都为真（包括数组具有零个元素的情况），则 &lt;code&gt;ALL&lt;/code&gt; 的结果为&amp;ldquo;真&amp;rdquo;。如果发现任何错误结果，则结果为&amp;ldquo; false&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="0854056fb124d8ec388aaba4b2f113f43a992144" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized expression, which must yield an array value. The left-hand expression is evaluated and compared to each element of the array using the given &lt;code&gt;operator&lt;/code&gt;, which must yield a Boolean result. The result of &lt;code&gt;ANY&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if any true result is obtained. The result is &amp;ldquo;false&amp;rdquo; if no true result is found (including the case where the array has zero elements).</source>
          <target state="translated">右边是带括号的表达式，必须产生一个数组值。将使用给定的 &lt;code&gt;operator&lt;/code&gt; 评估左侧表达式并将其与数组的每个元素进行比较，该运算符必须产生布尔结果。如果获得任何真实结果，则 &lt;code&gt;ANY&lt;/code&gt; 的结果为&amp;ldquo; true&amp;rdquo;。如果找不到正确的结果（包括数组具有零个元素的情况），则结果为&amp;ldquo; false&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="4cadd4592ac992256e9ca190e2ede2776b0f06bb" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized list of scalar expressions. The result is &amp;ldquo;true&amp;rdquo; if the left-hand expression's result is equal to any of the right-hand expressions. This is a shorthand notation for</source>
          <target state="translated">右侧是带括号的标量表达式列表。如果左侧表达式的结果等于任何右侧表达式，则结果为&amp;ldquo; true&amp;rdquo;。这是的简写</target>
        </trans-unit>
        <trans-unit id="9a6bece97382db0f9b6ad5060523f2f32e422503" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized list of scalar expressions. The result is &amp;ldquo;true&amp;rdquo; if the left-hand expression's result is unequal to all of the right-hand expressions. This is a shorthand notation for</source>
          <target state="translated">右侧是带括号的标量表达式列表。如果左侧表达式的结果与所有右侧表达式都不相等，则结果为&amp;ldquo; true&amp;rdquo;。这是的简写</target>
        </trans-unit>
        <trans-unit id="4623e53b09512588ad13e7eaadc6e34f6d36d750" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized subquery, which must return exactly one column. The left-hand expression is evaluated and compared to each row of the subquery result using the given &lt;code&gt;operator&lt;/code&gt;, which must yield a Boolean result. The result of &lt;code&gt;ALL&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if all rows yield true (including the case where the subquery returns no rows). The result is &amp;ldquo;false&amp;rdquo; if any false result is found. The result is NULL if no comparison with a subquery row returns false, and at least one comparison returns NULL.</source>
          <target state="translated">右侧是带括号的子查询，该查询必须恰好返回一列。使用给定的 &lt;code&gt;operator&lt;/code&gt; ，将评估左侧表达式并将其与子查询结果的每一行进行比较，该运算符必须产生布尔结果。如果所有行都为真（包括子查询不返回任何行的情况），则 &lt;code&gt;ALL&lt;/code&gt; 的结果为&amp;ldquo; true&amp;rdquo;。如果发现任何错误结果，则结果为&amp;ldquo; false&amp;rdquo;。如果没有与子查询行的比较返回false，则结果为NULL，并且至少一个比较返回NULL。</target>
        </trans-unit>
        <trans-unit id="89b47774fd6157f8ca176076b1ed18f995c2daef" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized subquery, which must return exactly one column. The left-hand expression is evaluated and compared to each row of the subquery result using the given &lt;code&gt;operator&lt;/code&gt;, which must yield a Boolean result. The result of &lt;code&gt;ANY&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if any true result is obtained. The result is &amp;ldquo;false&amp;rdquo; if no true result is found (including the case where the subquery returns no rows).</source>
          <target state="translated">右侧是带括号的子查询，该查询必须恰好返回一列。使用给定的 &lt;code&gt;operator&lt;/code&gt; ，将评估左侧表达式并将其与子查询结果的每一行进行比较，该运算符必须产生布尔结果。如果获得任何真实结果，则 &lt;code&gt;ANY&lt;/code&gt; 的结果为&amp;ldquo; true&amp;rdquo;。如果找不到正确的结果（包括子查询不返回任何行的情况），则结果为&amp;ldquo; false&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="a7873b5839bfc7065dc6edeb7940049a4cb53216" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized subquery, which must return exactly one column. The left-hand expression is evaluated and compared to each row of the subquery result. The result of &lt;code&gt;IN&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if any equal subquery row is found. The result is &amp;ldquo;false&amp;rdquo; if no equal row is found (including the case where the subquery returns no rows).</source>
          <target state="translated">右侧是带括号的子查询，该查询必须恰好返回一列。评估左侧表达式并将其与子查询结果的每一行进行比较。如果找到相等的子查询行，则 &lt;code&gt;IN&lt;/code&gt; 的结果为&amp;ldquo; true&amp;rdquo;。如果找不到相等的行（包括子查询不返回任何行的情况），则结果为&amp;ldquo; false&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="0ca2d475edb7fe77a4b6be61177af0a4c222988e" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized subquery, which must return exactly one column. The left-hand expression is evaluated and compared to each row of the subquery result. The result of &lt;code&gt;NOT IN&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if only unequal subquery rows are found (including the case where the subquery returns no rows). The result is &amp;ldquo;false&amp;rdquo; if any equal row is found.</source>
          <target state="translated">右侧是带括号的子查询，该查询必须恰好返回一列。评估左侧表达式并将其与子查询结果的每一行进行比较。如果仅找到不相等的子查询行（包括子查询不返回任何行的情况），则 &lt;code&gt;NOT IN&lt;/code&gt; 的结果为&amp;ldquo; true&amp;rdquo;。如果找到相等的行，则结果为&amp;ldquo; false&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="60ffe49fd73a1dfeb0ff0a3cd27bc012700f7f66" translate="yes" xml:space="preserve">
          <source>The risk that is taken by using asynchronous commit is of data loss, not data corruption. If the database should crash, it will recover by replaying WAL up to the last record that was flushed. The database will therefore be restored to a self-consistent state, but any transactions that were not yet flushed to disk will not be reflected in that state. The net effect is therefore loss of the last few transactions. Because the transactions are replayed in commit order, no inconsistency can be introduced &amp;mdash; for example, if transaction B made changes relying on the effects of a previous transaction A, it is not possible for A's effects to be lost while B's effects are preserved.</source>
          <target state="translated">使用异步提交承担的风险是数据丢失，而不是数据损坏。如果数据库崩溃，它将通过重播WAL直到刷新的最后一条记录来恢复。因此，数据库将还原到一个自洽状态，但是尚未刷新到磁盘的任何事务都不会反映在该状态下。因此，最终结果是最后几笔交易的损失。因为事务是按提交顺序重播的，所以不会引起不一致的情况-例如，如果事务B依赖于先前事务A的影响进行了更改，则在保留B的影响的同时A的影响也不会丢失。</target>
        </trans-unit>
        <trans-unit id="458aee8243a88af8890a3686268fbeeebdc768b4" translate="yes" xml:space="preserve">
          <source>The role attributes &lt;code&gt;LOGIN&lt;/code&gt;, &lt;code&gt;SUPERUSER&lt;/code&gt;, &lt;code&gt;CREATEDB&lt;/code&gt;, and &lt;code&gt;CREATEROLE&lt;/code&gt; can be thought of as special privileges, but they are never inherited as ordinary privileges on database objects are. You must actually &lt;code&gt;SET ROLE&lt;/code&gt; to a specific role having one of these attributes in order to make use of the attribute. Continuing the above example, we might choose to grant &lt;code&gt;CREATEDB&lt;/code&gt; and &lt;code&gt;CREATEROLE&lt;/code&gt; to the &lt;code&gt;admin&lt;/code&gt; role. Then a session connecting as role &lt;code&gt;joe&lt;/code&gt; would not have these privileges immediately, only after doing &lt;code&gt;SET ROLE admin&lt;/code&gt;.</source>
          <target state="translated">可以将角色属性 &lt;code&gt;LOGIN&lt;/code&gt; ， &lt;code&gt;SUPERUSER&lt;/code&gt; ， &lt;code&gt;CREATEDB&lt;/code&gt; 和 &lt;code&gt;CREATEROLE&lt;/code&gt; 视为特殊特权，但它们永远不会像数据库对象的普通特权那样被继承。实际上，您必须将 &lt;code&gt;SET ROLE&lt;/code&gt; 为具有这些属性之一的特定角色，才能使用该属性。继续上面的例子，我们可以选择授予 &lt;code&gt;CREATEDB&lt;/code&gt; 和 &lt;code&gt;CREATEROLE&lt;/code&gt; 到 &lt;code&gt;admin&lt;/code&gt; 角色。然后，仅在执行 &lt;code&gt;SET ROLE admin&lt;/code&gt; 之后，以角色 &lt;code&gt;joe&lt;/code&gt; 身份连接的会话将不会立即具有这些特权。</target>
        </trans-unit>
        <trans-unit id="cc4f14a678d35107865a506875d403f1fabcef04" translate="yes" xml:space="preserve">
          <source>The role name of the user who will own the new database, or &lt;code&gt;DEFAULT&lt;/code&gt; to use the default (namely, the user executing the command). To create a database owned by another role, you must be a direct or indirect member of that role, or be a superuser.</source>
          <target state="translated">谁将会拥有新数据库，或者用户的角色名 &lt;code&gt;DEFAULT&lt;/code&gt; 使用缺省的（即，用户执行命令）。要创建另一个角色拥有的数据库，您必须是该角色的直接或间接成员，或者是超级用户。</target>
        </trans-unit>
        <trans-unit id="e0cd094fcb28a6d1c971a4fe5ea4b6668f0b2297" translate="yes" xml:space="preserve">
          <source>The role name of the user who will own the new schema. If omitted, defaults to the user executing the command. To create a schema owned by another role, you must be a direct or indirect member of that role, or be a superuser.</source>
          <target state="translated">将拥有新模式的用户的角色名称。如果省略,默认为执行该命令的用户。要创建一个由其他角色拥有的模式,你必须是该角色的直接或间接成员,或者是超级用户。</target>
        </trans-unit>
        <trans-unit id="288659e152f65b17d46027cdd207a204fb13225f" translate="yes" xml:space="preserve">
          <source>The role used for the replication connection must have the &lt;code&gt;REPLICATION&lt;/code&gt; attribute (or be a superuser). Access for the role must be configured in &lt;code&gt;pg_hba.conf&lt;/code&gt; and it must have the &lt;code&gt;LOGIN&lt;/code&gt; attribute.</source>
          <target state="translated">用于复制连接的角色必须具有 &lt;code&gt;REPLICATION&lt;/code&gt; 属性（或是超级用户）。该角色的访问权限必须在 &lt;code&gt;pg_hba.conf&lt;/code&gt; 中配置，并且必须具有 &lt;code&gt;LOGIN&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="ae4f6c3527bb773eca24ae98fe7bc2235694a76b" translate="yes" xml:space="preserve">
          <source>The role used for the replication connection must have the &lt;code&gt;REPLICATION&lt;/code&gt; attribute (or be a superuser). If the role lacks &lt;code&gt;SUPERUSER&lt;/code&gt; and &lt;code&gt;BYPASSRLS&lt;/code&gt;, publisher row security policies can execute. If the role does not trust all table owners, include &lt;code&gt;options=-crow_security=off&lt;/code&gt; in the connection string; if a table owner then adds a row security policy, that setting will cause replication to halt rather than execute the policy. Access for the role must be configured in &lt;code&gt;pg_hba.conf&lt;/code&gt; and it must have the &lt;code&gt;LOGIN&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7270c8298ccd5ab28e0386f721a4bd64642b81f5" translate="yes" xml:space="preserve">
          <source>The role(s) to which the policy applies. Multiple roles can be specified at one time. To apply the policy to all roles, use &lt;code&gt;PUBLIC&lt;/code&gt;.</source>
          <target state="translated">该策略适用的角色。一次可以指定多个角色。要将策略应用于所有角色，请使用 &lt;code&gt;PUBLIC&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="672dc56056e4468fca330096a6f7988e99426d64" translate="yes" xml:space="preserve">
          <source>The role(s) to which the policy is to be applied. The default is &lt;code&gt;PUBLIC&lt;/code&gt;, which will apply the policy to all roles.</source>
          <target state="translated">将策略应用到的角色。默认值为 &lt;code&gt;PUBLIC&lt;/code&gt; ，它将对所有角色应用策略。</target>
        </trans-unit>
        <trans-unit id="da08283627fb6b277f73d5b0ddf0372ed6cb0f5d" translate="yes" xml:space="preserve">
          <source>The roles to which the policy is applied</source>
          <target state="translated">政策所适用的角色</target>
        </trans-unit>
        <trans-unit id="0b502eae099c8f10d1ed4ef0c354669f63bce361" translate="yes" xml:space="preserve">
          <source>The roles to which this policy applies</source>
          <target state="translated">本政策所适用的角色</target>
        </trans-unit>
        <trans-unit id="acd6a9c4a0e56d2f8f09c7b30b75a454cb6c1d08" translate="yes" xml:space="preserve">
          <source>The rows considered by a window function are those of the &amp;ldquo;virtual table&amp;rdquo; produced by the query's &lt;code&gt;FROM&lt;/code&gt; clause as filtered by its &lt;code&gt;WHERE&lt;/code&gt;, &lt;code&gt;GROUP BY&lt;/code&gt;, and &lt;code&gt;HAVING&lt;/code&gt; clauses if any. For example, a row removed because it does not meet the &lt;code&gt;WHERE&lt;/code&gt; condition is not seen by any window function. A query can contain multiple window functions that slice up the data in different ways using different &lt;code&gt;OVER&lt;/code&gt; clauses, but they all act on the same collection of rows defined by this virtual table.</source>
          <target state="translated">窗口函数考虑的行是查询的 &lt;code&gt;FROM&lt;/code&gt; 子句生成的&amp;ldquo;虚拟表&amp;rdquo;的行，并由其 &lt;code&gt;WHERE&lt;/code&gt; ， &lt;code&gt;GROUP BY&lt;/code&gt; 和 &lt;code&gt;HAVING&lt;/code&gt; 子句（如果有）过滤。例如，任何窗口函数都看不到因为不满足 &lt;code&gt;WHERE&lt;/code&gt; 条件而被删除的行。一个查询可以包含多个窗口函数，这些窗口函数使用不同的 &lt;code&gt;OVER&lt;/code&gt; 子句以不同的方式分割数据，但是它们都作用于该虚拟表定义的同一行集合上。</target>
        </trans-unit>
        <trans-unit id="ac9a42afd27bb82c7fefe7d8456c8e56005d3e20" translate="yes" xml:space="preserve">
          <source>The rows skipped by an &lt;code&gt;OFFSET&lt;/code&gt; clause still have to be computed inside the server; therefore a large &lt;code&gt;OFFSET&lt;/code&gt; might be inefficient.</source>
          <target state="translated">&lt;code&gt;OFFSET&lt;/code&gt; 子句跳过的行仍必须在服务器内部进行计算；因此，较大的 &lt;code&gt;OFFSET&lt;/code&gt; 可能效率不高。</target>
        </trans-unit>
        <trans-unit id="9c6595d74dd986e8e704f616ce70f02f89a3b6e5" translate="yes" xml:space="preserve">
          <source>The rule firing mechanism is also affected by the configuration variable &lt;a href=&quot;runtime-config-client#GUC-SESSION-REPLICATION-ROLE&quot;&gt;session_replication_role&lt;/a&gt;, analogous to triggers as described above.</source>
          <target state="translated">规则触发机制还受到配置变量&lt;a href=&quot;runtime-config-client#GUC-SESSION-REPLICATION-ROLE&quot;&gt;session_replication_role的影响&lt;/a&gt;，类似于上述触发器。</target>
        </trans-unit>
        <trans-unit id="77cbd29a44e08d42c19c09374140fe6b3a2c7eb5" translate="yes" xml:space="preserve">
          <source>The rules file has the following format:</source>
          <target state="translated">规则文件的格式如下:</target>
        </trans-unit>
        <trans-unit id="20f26d0e3be07fc8411c53cf4fec028b4fb7ddc1" translate="yes" xml:space="preserve">
          <source>The rules given in the preceding sections will result in assignment of non-&lt;code&gt;unknown&lt;/code&gt; data types to all expressions in a SQL query, except for unspecified-type literals that appear as simple output columns of a &lt;code&gt;SELECT&lt;/code&gt; command. For example, in</source>
          <target state="translated">前面各节中给出的规则将导致将非 &lt;code&gt;unknown&lt;/code&gt; 数据类型分配给SQL查询中的所有表达式，但未指定类型的文字会显示为 &lt;code&gt;SELECT&lt;/code&gt; 命令的简单输出列。例如，在</target>
        </trans-unit>
        <trans-unit id="a710b4d0128d22b5baa147d345de94a14b25c08a" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;1...2&lt;/code&gt;, or &lt;code&gt;1 .. 2&lt;/code&gt;, or &lt;code&gt;1..2&lt;/code&gt; (spaces around the range operator are ignored)</source>
          <target state="translated">与 &lt;code&gt;1...2&lt;/code&gt; 或 &lt;code&gt;1 .. 2&lt;/code&gt; 或 &lt;code&gt;1..2&lt;/code&gt; 相同（范围运算符周围的空格将被忽略）</target>
        </trans-unit>
        <trans-unit id="e6e201d82f084cc5d95195c10944ee93631d8df0" translate="yes" xml:space="preserve">
          <source>The same, and also reset any associated sequence generators:</source>
          <target state="translated">同样的,还要重置任何相关的序列发生器。</target>
        </trans-unit>
        <trans-unit id="241b8d226e8b5f79ed0ec6888a0ce004af81b21c" translate="yes" xml:space="preserve">
          <source>The same, but counting only word occurrences with weight &lt;code&gt;A&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt;:</source>
          <target state="translated">相同，但仅计算权重为 &lt;code&gt;A&lt;/code&gt; 或 &lt;code&gt;B&lt;/code&gt; 的单词出现次数：</target>
        </trans-unit>
        <trans-unit id="d2d2e57444e30e19980ec9c24adfc53e9305e592" translate="yes" xml:space="preserve">
          <source>The same, but only execute the function if column &lt;code&gt;balance&lt;/code&gt; is specified as a target in the &lt;code&gt;UPDATE&lt;/code&gt; command:</source>
          <target state="translated">相同，但是仅当在 &lt;code&gt;UPDATE&lt;/code&gt; 命令中将列 &lt;code&gt;balance&lt;/code&gt; 指定为目标时才执行该函数：</target>
        </trans-unit>
        <trans-unit id="002437cb1427716a633526fb7913d4100317c440" translate="yes" xml:space="preserve">
          <source>The same, specified as a table constraint:</source>
          <target state="translated">同样的,指定为表约束。</target>
        </trans-unit>
        <trans-unit id="788d460ac0c5a82665dae9bd0fa72bfb74260b32" translate="yes" xml:space="preserve">
          <source>The same, using regular expression notation to consolidate the switches:</source>
          <target state="translated">同样的,用正则表达式符号来巩固开关。</target>
        </trans-unit>
        <trans-unit id="bfae0e75e1b6288495d53b506d9a241bf9d03b6d" translate="yes" xml:space="preserve">
          <source>The same, when the column has a default expression that won't automatically cast to the new data type:</source>
          <target state="translated">同样的,当列的默认表达式不会自动投向新的数据类型。</target>
        </trans-unit>
        <trans-unit id="d799562b98253554741c727e0742611d0f2a5b8b" translate="yes" xml:space="preserve">
          <source>The sample results shown on this page assume that the server parameter &lt;a href=&quot;runtime-config-client#GUC-BYTEA-OUTPUT&quot;&gt;&lt;code&gt;bytea_output&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;escape&lt;/code&gt; (the traditional PostgreSQL format).</source>
          <target state="translated">此页面上显示的示例结果假定服务器参数&lt;a href=&quot;runtime-config-client#GUC-BYTEA-OUTPUT&quot;&gt; &lt;code&gt;bytea_output&lt;/code&gt; &lt;/a&gt;设置为 &lt;code&gt;escape&lt;/code&gt; （传统的PostgreSQL格式）。</target>
        </trans-unit>
        <trans-unit id="63cecb1fda6e05d04ffb99e00faba23729910dbf" translate="yes" xml:space="preserve">
          <source>The savepoint to roll back to.</source>
          <target state="translated">要回滚到的保存点。</target>
        </trans-unit>
        <trans-unit id="237920c06713568a0627b8a6cf3c35b4a6fcf5f1" translate="yes" xml:space="preserve">
          <source>The scalar ordering operators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, etc) do not make a lot of sense for any practical purpose but sorting. These operators first compare the first coordinates, and if those are equal, compare the second coordinates, etc. They exist mainly to support the b-tree index operator class for &lt;code&gt;cube&lt;/code&gt;, which can be useful for example if you would like a UNIQUE constraint on a &lt;code&gt;cube&lt;/code&gt; column.</source>
          <target state="translated">标量排序运算符（ &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;=&lt;/code&gt; 等）对于实际用途而言，除了排序没有多大意义。这些运算符首先比较第一个坐标，如果相等，则比较第二个坐标，依此类推。它们主要用于支持 &lt;code&gt;cube&lt;/code&gt; 的b树索引运算符类，例如，如果您希望对一个 &lt;code&gt;cube&lt;/code&gt; 列。</target>
        </trans-unit>
        <trans-unit id="c8365d330a7b8ee61b52ae905279178001855d43" translate="yes" xml:space="preserve">
          <source>The schema containing the &lt;code&gt;citext&lt;/code&gt; operators must be in the current &lt;code&gt;search_path&lt;/code&gt; (typically &lt;code&gt;public&lt;/code&gt;); if it is not, the normal case-sensitive &lt;code&gt;text&lt;/code&gt; operators will be invoked instead.</source>
          <target state="translated">包含 &lt;code&gt;citext&lt;/code&gt; 运算符的模式必须在当前 &lt;code&gt;search_path&lt;/code&gt; 中（通常是 &lt;code&gt;public&lt;/code&gt; ）；如果不是，则将调用普通的区分大小写的 &lt;code&gt;text&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="a1b72adef26aba98ed5b9a11c3f8d9f992851abe" translate="yes" xml:space="preserve">
          <source>The schema definitions are not replicated, and the published tables must exist on the subscriber. Only regular tables may be the target of replication. For example, you can't replicate to a view.</source>
          <target state="translated">模式定义不被复制,发布的表必须存在于订阅者上。只有常规表可以成为复制的目标。例如,你不能复制到视图。</target>
        </trans-unit>
        <trans-unit id="459a237a85ce3b91cf8ef1e52361b976ab47c1f2" translate="yes" xml:space="preserve">
          <source>The schema in which the imported foreign tables will be created.</source>
          <target state="translated">创建导入的外来表的模式。</target>
        </trans-unit>
        <trans-unit id="01865c073aef636c813a71a650ffa6b695ee5717" translate="yes" xml:space="preserve">
          <source>The schemes shown here assume that the values of a row's key column(s) never change, or at least do not change enough to require it to move to another partition. An &lt;code&gt;UPDATE&lt;/code&gt; that attempts to do that will fail because of the &lt;code&gt;CHECK&lt;/code&gt; constraints. If you need to handle such cases, you can put suitable update triggers on the child tables, but it makes management of the structure much more complicated.</source>
          <target state="translated">此处显示的方案假定行的键列的值从不改变，或者至少没有改变得足以使它移动到另一个分区。由于 &lt;code&gt;CHECK&lt;/code&gt; 约束，尝试执行此操作的 &lt;code&gt;UPDATE&lt;/code&gt; 将失败。如果需要处理这种情况，则可以在子表上放置适当的更新触发器，但这会使结构的管理变得更加复杂。</target>
        </trans-unit>
        <trans-unit id="ec9b55e40d83c1563492fc665bcf7be0f37fb815" translate="yes" xml:space="preserve">
          <source>The scripts can be run in any order and can be deleted once they have been run.</source>
          <target state="translated">脚本可以按照任何顺序运行,一旦运行就可以删除。</target>
        </trans-unit>
        <trans-unit id="5351b57ec30c67488f197082c674a1ac3697572e" translate="yes" xml:space="preserve">
          <source>The search filter to use when doing search+bind authentication. Occurrences of &lt;code&gt;$username&lt;/code&gt; will be replaced with the user name. This allows for more flexible search filters than &lt;code&gt;ldapsearchattribute&lt;/code&gt;.</source>
          <target state="translated">搜索+绑定身份验证时使用的搜索过滤器。的出现 &lt;code&gt;$username&lt;/code&gt; 会与用户名进行更换。与 &lt;code&gt;ldapsearchattribute&lt;/code&gt; 相比，这提供了更灵活的搜索过滤器。</target>
        </trans-unit>
        <trans-unit id="cc9e6cb9abd2e41c04bc258bc4b8a29867d6da64" translate="yes" xml:space="preserve">
          <source>The search path can be altered at run time. The command is:</source>
          <target state="translated">在运行时可以改变搜索路径。命令是:</target>
        </trans-unit>
        <trans-unit id="478354e0ca1e05b1455044d0dbe23d731c182378" translate="yes" xml:space="preserve">
          <source>The search path works in the same way for data type names, function names, and operator names as it does for table names. Data type and function names can be qualified in exactly the same way as table names. If you need to write a qualified operator name in an expression, there is a special provision: you must write</source>
          <target state="translated">搜索路径对数据类型名、函数名和运算符名的作用方式与对表名的作用方式相同。数据类型名和函数名的限定方式与表名完全相同。如果你需要在表达式中写一个限定的运算符名,有一个特殊的规定:你必须写下</target>
        </trans-unit>
        <trans-unit id="90f585a0c61cda16f1f2f37af64c77ecb164389f" translate="yes" xml:space="preserve">
          <source>The second approach combines any authentication method for &lt;code&gt;hostssl&lt;/code&gt; entries with the verification of client certificates by setting the &lt;code&gt;clientcert&lt;/code&gt; authentication option to &lt;code&gt;verify-ca&lt;/code&gt; or &lt;code&gt;verify-full&lt;/code&gt;. The former option only enforces that the certificate is valid, while the latter also ensures that the &lt;code&gt;cn&lt;/code&gt; (Common Name) in the certificate matches the user name or an applicable mapping.</source>
          <target state="translated">第二种方法结合了任何认证方法 &lt;code&gt;hostssl&lt;/code&gt; 通过设置与客户端证书的验证项 &lt;code&gt;clientcert&lt;/code&gt; 认证选项来 &lt;code&gt;verify-ca&lt;/code&gt; 或 &lt;code&gt;verify-full&lt;/code&gt; 。前一个选项仅强制执行证书有效，而后一个选项还确保证书中的 &lt;code&gt;cn&lt;/code&gt; （通用名）与用户名或适用的映射匹配。</target>
        </trans-unit>
        <trans-unit id="4e7e9d77036e0c9575b0fa838e7bb55bd546fa0a" translate="yes" xml:space="preserve">
          <source>The second argument must be a well formed XML document. In particular, it must have a single root node element.</source>
          <target state="translated">第二个参数必须是一个成型的XML文档。特别是,它必须有一个单一的根节点元素。</target>
        </trans-unit>
        <trans-unit id="971af670862eab67d21e45dbeea285001e2a069e" translate="yes" xml:space="preserve">
          <source>The second example will store cities and their associated geographical location:</source>
          <target state="translated">第二个例子将存储城市及其相关的地理位置。</target>
        </trans-unit>
        <trans-unit id="a8fdfc2d4d4050aa9351fe7e549967c0e1502821" translate="yes" xml:space="preserve">
          <source>The second form changes the name of the database. Only the database owner or a superuser can rename a database; non-superuser owners must also have the &lt;code&gt;CREATEDB&lt;/code&gt; privilege. The current database cannot be renamed. (Connect to a different database if you need to do that.)</source>
          <target state="translated">第二种形式更改数据库的名称。只有数据库所有者或超级用户才能重命名数据库；非超级用户所有者还必须具有 &lt;code&gt;CREATEDB&lt;/code&gt; 特权。当前数据库无法重命名。（如果需要，请连接到其他数据库。）</target>
        </trans-unit>
        <trans-unit id="5f97cd14403d43a28906f958a63aa9be74a831f3" translate="yes" xml:space="preserve">
          <source>The second form is a PostgreSQL extension. It fills the columns from the left with as many values as are given, and the rest will be defaulted.</source>
          <target state="translated">第二个表格是PostgreSQL的扩展。它从左边开始用给定的值填充列,其余的将是默认值。</target>
        </trans-unit>
        <trans-unit id="001f55ae6b12f7691ee493402996a3cedd18d43d" translate="yes" xml:space="preserve">
          <source>The second form of &lt;code&gt;CREATE TYPE&lt;/code&gt; creates an enumerated (enum) type, as described in &lt;a href=&quot;datatype-enum&quot;&gt;Section 8.7&lt;/a&gt;. Enum types take a list of quoted labels, each of which must be less than &lt;code&gt;NAMEDATALEN&lt;/code&gt; bytes long (64 bytes in a standard PostgreSQL build). (It is possible to create an enumerated type with zero labels, but such a type cannot be used to hold values before at least one label is added using &lt;a href=&quot;sql-altertype&quot;&gt;ALTER TYPE&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;CREATE TYPE&lt;/code&gt; 的第二种形式创建枚举（枚举）类型，如&lt;a href=&quot;datatype-enum&quot;&gt;第8.7节&lt;/a&gt;所述。枚举类型带有一个带引号的标签列表，每个标签必须小于 &lt;code&gt;NAMEDATALEN&lt;/code&gt; 字节长（标准PostgreSQL构建中为64字节）。（可以使用零标签创建枚举类型，但是在使用&lt;a href=&quot;sql-altertype&quot;&gt;ALTER TYPE&lt;/a&gt;添加至少一个标签之前，不能使用这种类型来保存值。）</target>
        </trans-unit>
        <trans-unit id="9646c72014e3dc0cdbc889805cc625cb2e00d4a4" translate="yes" xml:space="preserve">
          <source>The second implementation of the rule system is a technique called &lt;em&gt;query rewriting&lt;/em&gt;. The &lt;em&gt;rewrite system&lt;/em&gt; is a module that exists between the &lt;em&gt;parser stage&lt;/em&gt; and the &lt;em&gt;planner/optimizer&lt;/em&gt;. This technique is still implemented.</source>
          <target state="translated">规则系统的第二种实现是一种称为&lt;em&gt;查询重写&lt;/em&gt;的技术。的&lt;em&gt;重写系统&lt;/em&gt;是，之间存在模块&lt;em&gt;分析器阶段&lt;/em&gt;和&lt;em&gt;规划器/优化&lt;/em&gt;。该技术仍在实施。</target>
        </trans-unit>
        <trans-unit id="b82fe6094f17ae862d5ae179aa9cdfdad11af121" translate="yes" xml:space="preserve">
          <source>The second line is the command that would be invoked in restart mode.</source>
          <target state="translated">第二行是在重启模式下会调用的命令。</target>
        </trans-unit>
        <trans-unit id="5e54d9500bd7199e013e0c26f4d1118e580aabf7" translate="yes" xml:space="preserve">
          <source>The second part of the module relies on representing Earth locations as values of type &lt;code&gt;point&lt;/code&gt;, in which the first component is taken to represent longitude in degrees, and the second component is taken to represent latitude in degrees. Points are taken as (longitude, latitude) and not vice versa because longitude is closer to the intuitive idea of x-axis and latitude to y-axis.</source>
          <target state="translated">模块的第二部分依赖于将地球位置表示为 &lt;code&gt;point&lt;/code&gt; 类型的值，其中第一个分量表示度数（经度），第二个分量表示度数的纬度。点被视为（经度，纬度），反之亦然，因为经度更接近x轴和y轴的直觉性。</target>
        </trans-unit>
        <trans-unit id="07476921b1bd87798420cb9dffdda71ef3f07ce3" translate="yes" xml:space="preserve">
          <source>The second variant changes the name of the role. Database superusers can rename any role. Roles having &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can rename non-superuser roles. The current session user cannot be renamed. (Connect as a different user if you need to do that.) Because &lt;code&gt;MD5&lt;/code&gt;-encrypted passwords use the role name as cryptographic salt, renaming a role clears its password if the password is &lt;code&gt;MD5&lt;/code&gt;-encrypted.</source>
          <target state="translated">第二个变体更改角色的名称。数据库超级用户可以重命名任何角色。具有 &lt;code&gt;CREATEROLE&lt;/code&gt; 特权的角色可以重命名非超级用户角色。当前会话用户无法重命名。（如果需要，请以其他用户身份连接。）由于 &lt;code&gt;MD5&lt;/code&gt; 加密的密码使用角色名称作为加密盐，因此，如果密码是 &lt;code&gt;MD5&lt;/code&gt; 加密的，重命名角色将清除其密码。</target>
        </trans-unit>
        <trans-unit id="ee438b765dcc18ec34d603a483697e804f9db58b" translate="yes" xml:space="preserve">
          <source>The seconds field, including any fractional seconds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfe4da30b9c6bff8e95fbde2fcc03500be370613" translate="yes" xml:space="preserve">
          <source>The seconds field, including fractional parts (0 - 59&lt;a href=&quot;#ftn.id-1.5.8.14.12.5.11.16.2.1.1&quot;&gt;&lt;sup id=&quot;id-1.5.8.14.12.5.11.16.2.1.1&quot;&gt;[7]&lt;/sup&gt;&lt;/a&gt;)</source>
          <target state="translated">秒字段，包括小数部分（0-59 &lt;a href=&quot;#ftn.id-1.5.8.14.12.5.11.16.2.1.1&quot;&gt;&lt;sup id=&quot;id-1.5.8.14.12.5.11.16.2.1.1&quot;&gt;[7]&lt;/sup&gt;&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="663b58f51194288bd80b435fbc5e648d8e6f6580" translate="yes" xml:space="preserve">
          <source>The seconds field, including fractional parts, multiplied by 1 000 000; note that this includes full seconds</source>
          <target state="translated">秒字段,包括小数部分,乘以1 000 000;注意,这包括整数秒。</target>
        </trans-unit>
        <trans-unit id="2d44e15dba826649cac46abaee1bc5cb23f259a3" translate="yes" xml:space="preserve">
          <source>The seconds field, including fractional parts, multiplied by 1000. Note that this includes full seconds.</source>
          <target state="translated">秒字段,包括小数部分,乘以1000。请注意,这包括整数秒。</target>
        </trans-unit>
        <trans-unit id="7bfc04444cf0b5a28dd815138a4bbbe840cd72f0" translate="yes" xml:space="preserve">
          <source>The security label applied to this object.</source>
          <target state="translated">适用于此对象的安全标签。</target>
        </trans-unit>
        <trans-unit id="b47689b397bbce6da7cf131cc329c56ad0b8b0d2" translate="yes" xml:space="preserve">
          <source>The security model of SELinux describes all the access control rules as relationships between a subject entity (typically, a client of the database) and an object entity (such as a database object), each of which is identified by a security label. If access to an unlabeled object is attempted, the object is treated as if it were assigned the label &lt;code&gt;unlabeled_t&lt;/code&gt;.</source>
          <target state="translated">SELinux的安全模型将所有访问控制规则描述为主题实体（通常是数据库的客户端）与对象实体（例如数据库对象）之间的关系，每个实体都由安全标签标识。如果尝试访问未标记的对象，则将该对象视为为其分配了标签 &lt;code&gt;unlabeled_t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="230231accae0954bfa7e47d9f5e404dcd469b2c5" translate="yes" xml:space="preserve">
          <source>The security policy of SELinux also has rules to control whether or not particular accesses are logged. By default, access violations are logged, but allowed accesses are not.</source>
          <target state="translated">SELinux的安全策略也有规则来控制是否记录特定的访问。默认情况下,违反访问规定的行为会被记录,但允许的访问不会被记录。</target>
        </trans-unit>
        <trans-unit id="dbcd4d113ca55d30a1adafc062bb48c13c7f8e98" translate="yes" xml:space="preserve">
          <source>The seed can also be set by invoking the function &lt;code&gt;setseed&lt;/code&gt;:</source>
          <target state="translated">种子也可以通过调用 &lt;code&gt;setseed&lt;/code&gt; 函数来设置：</target>
        </trans-unit>
        <trans-unit id="1c3344ee525a48fbaf283fc79a5b884444be3dcb" translate="yes" xml:space="preserve">
          <source>The segment [a, b] contains the segment [c, d], that is, a &amp;lt;= c and b &amp;gt;= d.</source>
          <target state="translated">段[a，b]包含段[c，d]，即a &amp;lt;= c和b&amp;gt; = d。</target>
        </trans-unit>
        <trans-unit id="0167ae8a0ef2744b5f058f32dbb8df42b67bb33e" translate="yes" xml:space="preserve">
          <source>The segment [a, b] is contained in [c, d], that is, a &amp;gt;= c and b &amp;lt;= d.</source>
          <target state="translated">段[a，b]包含在[c，d]中，即a&amp;gt; = c和b &amp;lt;= d。</target>
        </trans-unit>
        <trans-unit id="2f9dfe875337796db870c4bb2a262e2bbef3945b" translate="yes" xml:space="preserve">
          <source>The segments [a, b] and [c, d] overlap.</source>
          <target state="translated">段[a,b]和[c,d]重合。</target>
        </trans-unit>
        <trans-unit id="b10711fce98e1c5fe5a4897a9961ed9ae2f37aef" translate="yes" xml:space="preserve">
          <source>The semantics of SQL/JSON path predicates and operators generally follow SQL. At the same time, to provide a most natural way of working with JSON data, SQL/JSON path syntax uses some of the JavaScript conventions:</source>
          <target state="translated">SQL/JSON路径谓词和操作符的语义一般遵循SQL。同时,为了提供一种最自然的处理JSON数据的方式,SQL/JSON路径语法使用了JavaScript的一些约定。</target>
        </trans-unit>
        <trans-unit id="fd623d8bcf9db9273d58642da7f1fb001cf303e9" translate="yes" xml:space="preserve">
          <source>The semantics of SQL/JSON path predicates and operators generally follow SQL. At the same time, to provide a natural way of working with JSON data, SQL/JSON path syntax uses some JavaScript conventions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca2f632c9b81511535163336539f86f918d83e9e" translate="yes" xml:space="preserve">
          <source>The semicolon (&lt;code&gt;;&lt;/code&gt;) terminates an SQL command. It cannot appear anywhere within a command, except within a string constant or quoted identifier.</source>
          <target state="translated">分号（ &lt;code&gt;;&lt;/code&gt; ）终止SQL命令。除了字符串常量或带引号的标识符外，它不能出现在命令中的任何位置。</target>
        </trans-unit>
        <trans-unit id="7c68a3eca090a3377bf1a78fea499d56ec605109" translate="yes" xml:space="preserve">
          <source>The sequence created for a &lt;code&gt;serial&lt;/code&gt; column is automatically dropped when the owning column is dropped. You can drop the sequence without dropping the column, but this will force removal of the column default expression.</source>
          <target state="translated">删除拥有的列时，将自动删除为 &lt;code&gt;serial&lt;/code&gt; 列创建的序列。您可以删除序列而不删除列，但是这将强制删除列默认表达式。</target>
        </trans-unit>
        <trans-unit id="b5a5d93057bd5edff8daf4648c4c935388f9e10e" translate="yes" xml:space="preserve">
          <source>The sequence name can be schema-qualified if necessary:</source>
          <target state="translated">如果有必要,序列名可以进行模式限定。</target>
        </trans-unit>
        <trans-unit id="c6a359aa04dbc4531fddf8d09e8fef46d55e14f6" translate="yes" xml:space="preserve">
          <source>The sequence to be operated on by a sequence function is specified by a &lt;code&gt;regclass&lt;/code&gt; argument, which is simply the OID of the sequence in the &lt;code&gt;pg_class&lt;/code&gt; system catalog. You do not have to look up the OID by hand, however, since the &lt;code&gt;regclass&lt;/code&gt; data type's input converter will do the work for you. Just write the sequence name enclosed in single quotes so that it looks like a literal constant. For compatibility with the handling of ordinary SQL names, the string will be converted to lower case unless it contains double quotes around the sequence name. Thus:</source>
          <target state="translated">序列函数要操作的序列由 &lt;code&gt;regclass&lt;/code&gt; 参数指定，该参数只是 &lt;code&gt;pg_class&lt;/code&gt; 系统目录中序列的OID 。但是，您不必手动查找OID，因为 &lt;code&gt;regclass&lt;/code&gt; 数据类型的输入转换器将为您完成工作。只需编写用单引号引起来的序列名称，使其看起来像文字常量。为了与普通SQL名称的处理兼容，除非字符串在序列名称周围包含双引号，否则它将转换为小写。从而：</target>
        </trans-unit>
        <trans-unit id="ea7d18fda0e93393ee728bac05185520e2d92f5c" translate="yes" xml:space="preserve">
          <source>The server log might contain more information about an authentication failure than is reported to the client. If you are confused about the reason for a failure, check the server log.</source>
          <target state="translated">服务器日志可能包含了比报告给客户端的认证失败更多的信息。如果你对失败的原因感到困惑,请检查服务器日志。</target>
        </trans-unit>
        <trans-unit id="4ca1254319f0477050eedb4dcb243dbc28231770" translate="yes" xml:space="preserve">
          <source>The server name must be unique within the database.</source>
          <target state="translated">服务器名称在数据库中必须是唯一的。</target>
        </trans-unit>
        <trans-unit id="7c59301168d9556837d6ae02c071fa4e2e245b97" translate="yes" xml:space="preserve">
          <source>The server process is idle. This event type indicates a process waiting for activity in its main processing loop. &lt;code&gt;wait_event&lt;/code&gt; will identify the specific wait point; see &lt;a href=&quot;monitoring-stats#WAIT-EVENT-ACTIVITY-TABLE&quot;&gt;Table 27.5&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31a48413f524a2e22ba2b89cc5a923ac95e25337" translate="yes" xml:space="preserve">
          <source>The server process is waiting for a heavyweight lock. Heavyweight locks, also known as lock manager locks or simply locks, primarily protect SQL-visible objects such as tables. However, they are also used to ensure mutual exclusion for certain internal operations such as relation extension. &lt;code&gt;wait_event&lt;/code&gt; will identify the type of lock awaited; see &lt;a href=&quot;monitoring-stats#WAIT-EVENT-LOCK-TABLE&quot;&gt;Table 27.11&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f51ae65c30da3ee23ba46209eb3c2d669b578e3" translate="yes" xml:space="preserve">
          <source>The server process is waiting for a lightweight lock. Most such locks protect a particular data structure in shared memory. &lt;code&gt;wait_event&lt;/code&gt; will contain a name identifying the purpose of the lightweight lock. (Some locks have specific names; others are part of a group of locks each with a similar purpose.) See &lt;a href=&quot;monitoring-stats#WAIT-EVENT-LWLOCK-TABLE&quot;&gt;Table 27.12&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1282755dbc7fcbac3f92fb89910bc9353d2096ee" translate="yes" xml:space="preserve">
          <source>The server process is waiting for a timeout to expire. &lt;code&gt;wait_event&lt;/code&gt; will identify the specific wait point; see &lt;a href=&quot;monitoring-stats#WAIT-EVENT-TIMEOUT-TABLE&quot;&gt;Table 27.13&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e0987499e5a13bf6c786db17c89cc8ef22d6f54" translate="yes" xml:space="preserve">
          <source>The server process is waiting for activity on a socket connected to a user application. Thus, the server expects something to happen that is independent of its internal processes. &lt;code&gt;wait_event&lt;/code&gt; will identify the specific wait point; see &lt;a href=&quot;monitoring-stats#WAIT-EVENT-CLIENT-TABLE&quot;&gt;Table 27.7&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b31b52ace66848125879633c9823a38b3287ac3" translate="yes" xml:space="preserve">
          <source>The server process is waiting for an I/O operation to complete. &lt;code&gt;wait_event&lt;/code&gt; will identify the specific wait point; see &lt;a href=&quot;monitoring-stats#WAIT-EVENT-IO-TABLE&quot;&gt;Table 27.9&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8bb014aedce015b73f39d1e5ca61f9c69eeed52" translate="yes" xml:space="preserve">
          <source>The server process is waiting for exclusive access to a data buffer. Buffer pin waits can be protracted if another process holds an open cursor that last read data from the buffer in question. See &lt;a href=&quot;monitoring-stats#WAIT-EVENT-BUFFERPIN-TABLE&quot;&gt;Table 27.6&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9849ed38bcc2dc42a7bd3ba776b5832e6dd4516" translate="yes" xml:space="preserve">
          <source>The server process is waiting for some condition defined by an extension module. See &lt;a href=&quot;monitoring-stats#WAIT-EVENT-EXTENSION-TABLE&quot;&gt;Table 27.8&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fff16781ff90b488a09e62468878f27f389a70f" translate="yes" xml:space="preserve">
          <source>The server process is waiting for some interaction with another server process. &lt;code&gt;wait_event&lt;/code&gt; will identify the specific wait point; see &lt;a href=&quot;monitoring-stats#WAIT-EVENT-IPC-TABLE&quot;&gt;Table 27.10&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac56c0453261e732a23fed94e0a24c8f95cc0488" translate="yes" xml:space="preserve">
          <source>The server reads these files at server start and whenever the server configuration is reloaded. On Windows systems, they are also re-read whenever a new backend process is spawned for a new client connection.</source>
          <target state="translated">服务器在服务器启动时以及每当服务器配置被重新加载时,都会读取这些文件。在Windows系统中,每当为新的客户端连接生成一个新的后端进程时,也会重新读取这些文件。</target>
        </trans-unit>
        <trans-unit id="d0d31219164213fd90b64aadc8577b6089ce02b9" translate="yes" xml:space="preserve">
          <source>The server sends an AuthenticationSASL message. It includes a list of SASL authentication mechanisms that the server can accept. This will be &lt;code&gt;SCRAM-SHA-256-PLUS&lt;/code&gt; and &lt;code&gt;SCRAM-SHA-256&lt;/code&gt; if the server is built with SSL support, or else just the latter.</source>
          <target state="translated">服务器发送AuthenticationSASL消息。它包括服务器可以接受的SASL身份验证机制的列表。如果服务器是使用SSL支持构建的，则将是 &lt;code&gt;SCRAM-SHA-256-PLUS&lt;/code&gt; 和 &lt;code&gt;SCRAM-SHA-256&lt;/code&gt; ，否则将是后者。</target>
        </trans-unit>
        <trans-unit id="b019b1a1b7d85dded861255aa6e59d8f9921d05a" translate="yes" xml:space="preserve">
          <source>The server will occasionally request the client to perform a flush and report the flush position to the server. This setting is in addition to that, to perform flushes more frequently.</source>
          <target state="translated">服务器会偶尔要求客户端进行一次刷新,并向服务器报告刷新位置。这个设置是除此之外,为了更频繁地执行刷新。</target>
        </trans-unit>
        <trans-unit id="7b8da77a2b390601e3adff073821408d13cdbea6" translate="yes" xml:space="preserve">
          <source>The server's checkpointer process automatically performs a checkpoint every so often. A checkpoint is begun every &lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-TIMEOUT&quot;&gt;checkpoint_timeout&lt;/a&gt; seconds, or if &lt;a href=&quot;runtime-config-wal#GUC-MAX-WAL-SIZE&quot;&gt;max_wal_size&lt;/a&gt; is about to be exceeded, whichever comes first. The default settings are 5 minutes and 1 GB, respectively. If no WAL has been written since the previous checkpoint, new checkpoints will be skipped even if &lt;code&gt;checkpoint_timeout&lt;/code&gt; has passed. (If WAL archiving is being used and you want to put a lower limit on how often files are archived in order to bound potential data loss, you should adjust the &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-TIMEOUT&quot;&gt;archive_timeout&lt;/a&gt; parameter rather than the checkpoint parameters.) It is also possible to force a checkpoint by using the SQL command &lt;code&gt;CHECKPOINT&lt;/code&gt;.</source>
          <target state="translated">服务器的检查点进程会每隔一段时间自动执行一个检查点。每隔&lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-TIMEOUT&quot;&gt;checkpoint_timeout&lt;/a&gt;秒或如果将要超出&lt;a href=&quot;runtime-config-wal#GUC-MAX-WAL-SIZE&quot;&gt;max_wal_size时&lt;/a&gt;（以先到者为准）开始检查点。默认设置分别为5分钟和1 GB。如果自上一个检查点以来未写入WAL，则即使 &lt;code&gt;checkpoint_timeout&lt;/code&gt; 已通过，也会跳过新的检查点。 （如果正在使用WAL归档，并且您希望对文件的存储频率设置较低的限制以限制潜在的数据丢失，则应该调整&lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-TIMEOUT&quot;&gt;archive_timeout&lt;/a&gt;参数而不是checkpoint参数。）也可以强制使用checkpoint通过使用SQL命令 &lt;code&gt;CHECKPOINT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c205218c3546e4b301b493a03547b46277844636" translate="yes" xml:space="preserve">
          <source>The server's version number as a string, for example &lt;code&gt;9.6.2&lt;/code&gt;, &lt;code&gt;10.1&lt;/code&gt; or &lt;code&gt;11beta1&lt;/code&gt;, and in numeric form, for example &lt;code&gt;90602&lt;/code&gt; or &lt;code&gt;100001&lt;/code&gt;. These are set every time you connect to a database (including program start-up), but can be changed or unset.</source>
          <target state="translated">服务器的版本号作为一个字符串，例如 &lt;code&gt;9.6.2&lt;/code&gt; ， &lt;code&gt;10.1&lt;/code&gt; 或 &lt;code&gt;11beta1&lt;/code&gt; ，并以数字形式，例如 &lt;code&gt;90602&lt;/code&gt; 或 &lt;code&gt;100001&lt;/code&gt; 。每次您连接到数据库（包括程序启动）时都进行设置，但是可以更改或取消设置。</target>
        </trans-unit>
        <trans-unit id="5a84cc79fdbb16a887f43ceaad26726c6755ffe1" translate="yes" xml:space="preserve">
          <source>The session default transaction modes can also be set by setting the configuration parameters &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-ISOLATION&quot;&gt;default_transaction_isolation&lt;/a&gt;, &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-READ-ONLY&quot;&gt;default_transaction_read_only&lt;/a&gt;, and &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-DEFERRABLE&quot;&gt;default_transaction_deferrable&lt;/a&gt;. (In fact &lt;code&gt;SET SESSION CHARACTERISTICS&lt;/code&gt; is just a verbose equivalent for setting these variables with &lt;code&gt;SET&lt;/code&gt;.) This means the defaults can be set in the configuration file, via &lt;code&gt;ALTER DATABASE&lt;/code&gt;, etc. Consult &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; for more information.</source>
          <target state="translated">还可以通过设置配置参数&lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-ISOLATION&quot;&gt;default_transaction_isolation&lt;/a&gt;，&lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-READ-ONLY&quot;&gt;default_transaction_read_only&lt;/a&gt;和&lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-DEFERRABLE&quot;&gt;default_transaction_deferrable&lt;/a&gt;来设置会话默认事务模式。（实际上， &lt;code&gt;SET SESSION CHARACTERISTICS&lt;/code&gt; 只是使用 &lt;code&gt;SET&lt;/code&gt; 设置这些变量的冗长等效项。）这意味着可以通过 &lt;code&gt;ALTER DATABASE&lt;/code&gt; 等在配置文件中设置默认值。有关更多信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;第19章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2aaa3b9320a8aa3d463da80f8c085ef96d144a67" translate="yes" xml:space="preserve">
          <source>The session default transaction modes can also be set by setting the configuration parameters &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-ISOLATION&quot;&gt;default_transaction_isolation&lt;/a&gt;, &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-READ-ONLY&quot;&gt;default_transaction_read_only&lt;/a&gt;, and &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-DEFERRABLE&quot;&gt;default_transaction_deferrable&lt;/a&gt;. (In fact &lt;code&gt;SET SESSION CHARACTERISTICS&lt;/code&gt; is just a verbose equivalent for setting these variables with &lt;code&gt;SET&lt;/code&gt;.) This means the defaults can be set in the configuration file, via &lt;code&gt;ALTER DATABASE&lt;/code&gt;, etc. Consult &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6723e0bdad2077d09fd447f64653c3402fb21a9f" translate="yes" xml:space="preserve">
          <source>The session user identifier can be changed only if the initial session user (the &lt;em&gt;authenticated user&lt;/em&gt;) had the superuser privilege. Otherwise, the command is accepted only if it specifies the authenticated user name.</source>
          <target state="translated">仅当初始会话用户（经过&lt;em&gt;身份验证的用户&lt;/em&gt;）具有超级用户特权时，才能更改会话用户标识符。否则，仅当命令指定了经过身份验证的用户名时，该命令才会被接受。</target>
        </trans-unit>
        <trans-unit id="715d310203fd1767744b0e3abc3cbaadfd49947d" translate="yes" xml:space="preserve">
          <source>The session user identifier is initially set to be the (possibly authenticated) user name provided by the client. The current user identifier is normally equal to the session user identifier, but might change temporarily in the context of &lt;code&gt;SECURITY DEFINER&lt;/code&gt; functions and similar mechanisms; it can also be changed by &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt;. The current user identifier is relevant for permission checking.</source>
          <target state="translated">会话用户标识符最初设置为客户端提供的（可能经过身份验证的）用户名。当前用户标识符通常等于会话用户标识符，但是在 &lt;code&gt;SECURITY DEFINER&lt;/code&gt; 功能和类似机制的上下文中可能会暂时更改；当前用户标识符通常等于会话用户标识符。也可以通过&lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt;进行更改。当前用户标识符与权限检查相关。</target>
        </trans-unit>
        <trans-unit id="94dcf85932be3ca953bb5dbee89cd4f7713067fb" translate="yes" xml:space="preserve">
          <source>The set of database roles a given client connection can connect as is determined by the client authentication setup, as explained in &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;. (Thus, a client is not limited to connect as the role matching its operating system user, just as a person's login name need not match his or her real name.) Since the role identity determines the set of privileges available to a connected client, it is important to carefully configure privileges when setting up a multiuser environment.</source>
          <target state="translated">给定客户端连接可以连接的数据库角色集，这由客户端身份验证设置确定，如&lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;第20章中所述&lt;/a&gt;。（因此，客户端的连接角色不限于与操作系统用户匹配的对象，就像人的登录名不需要与他或她的真实姓名匹配一样。）由于角色标识确定了连接的客户端可用的特权集，在设置多用户环境时，仔细配置特权很重要。</target>
        </trans-unit>
        <trans-unit id="116c57f39b5a10aa3016899fd490e3422c042da6" translate="yes" xml:space="preserve">
          <source>The set of database roles a given client connection can connect as is determined by the client authentication setup, as explained in &lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;. (Thus, a client is not limited to connect as the role matching its operating system user, just as a person's login name need not match his or her real name.) Since the role identity determines the set of privileges available to a connected client, it is important to carefully configure privileges when setting up a multiuser environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9e7e3efb30616b981cfefa41268aa6951e3d5f2" translate="yes" xml:space="preserve">
          <source>The setting &lt;code&gt;RemoveIPC&lt;/code&gt; in &lt;code&gt;logind.conf&lt;/code&gt; controls whether IPC objects are removed when a user fully logs out. System users are exempt. This setting defaults to on in stock systemd, but some operating system distributions default it to off.</source>
          <target state="translated">设定 &lt;code&gt;RemoveIPC&lt;/code&gt; 在 &lt;code&gt;logind.conf&lt;/code&gt; 控制是否当用户完全注销IPC对象被删除。系统用户免税。在stock systemd中，此设置默认为on，但某些操作系统发行版将其默认为off。</target>
        </trans-unit>
        <trans-unit id="64eba0ac674f39ed469aa292d2c2a8445eebc9f9" translate="yes" xml:space="preserve">
          <source>The setting of some parameters on the standby will need reconfiguration if they have been changed on the primary. For these parameters, the value on the standby must be equal to or greater than the value on the primary. Therefore, if you want to increase these values, you should do so on all standby servers first, before applying the changes to the primary server. Conversely, if you want to decrease these values, you should do so on the primary server first, before applying the changes to all standby servers. If these parameters are not set high enough then the standby will refuse to start. Higher values can then be supplied and the server restarted to begin recovery again. These parameters are:</source>
          <target state="translated">如果在主设备上更改了某些参数,则需要重新配置备用设备上的某些参数。对于这些参数,备用服务器上的值必须等于或大于主服务器上的值。因此,如果要增加这些值,应先在所有备用服务器上增加,然后再将更改应用到主服务器上。相反,如果您要减少这些值,则应先在主服务器上这样做,然后再将更改应用到所有备用服务器上。如果这些参数设置得不够高,那么备用服务器将拒绝启动。然后可以提供更高的值,并重新启动服务器,再次开始恢复。这些参数是</target>
        </trans-unit>
        <trans-unit id="8f66060d984a3d43717aaa1c8e7136685e2e6d1f" translate="yes" xml:space="preserve">
          <source>The shared lock table tracks locks on &lt;code&gt;max_locks_per_transaction&lt;/code&gt; * (&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; + &lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt;) objects (e.g., tables); hence, no more than this many distinct objects can be locked at any one time. This parameter controls the average number of object locks allocated for each transaction; individual transactions can lock more objects as long as the locks of all transactions fit in the lock table. This is &lt;em&gt;not&lt;/em&gt; the number of rows that can be locked; that value is unlimited. The default, 64, has historically proven sufficient, but you might need to raise this value if you have queries that touch many different tables in a single transaction, e.g. query of a parent table with many children. This parameter can only be set at server start.</source>
          <target state="translated">共享锁表跟踪 &lt;code&gt;max_locks_per_transaction&lt;/code&gt; *（&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; + &lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt;）对象（例如表）上的锁；因此，在任何时候最多只能锁定许多不同的对象。此参数控制为每个事务分配的平均对象锁数；只要所有事务的锁都适合锁表，单个事务就可以锁定更多对象。这&lt;em&gt;不是&lt;/em&gt;可以锁定的行数；这个价值是无限的。默认值64在历史上已被证明是足够的，但是如果您有在单个事务中涉及许多不同表的查询（例如，具有多个子表的父表的查询），则可能需要提高该值。该参数只能在服务器启动时设置。</target>
        </trans-unit>
        <trans-unit id="f3a2293e6351084a16aac1acbf3842262fd1322f" translate="yes" xml:space="preserve">
          <source>The shared lock table tracks locks on &lt;code&gt;max_locks_per_transaction&lt;/code&gt; * (&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; + &lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt;) objects (e.g., tables); hence, no more than this many distinct objects can be locked at any one time. This parameter controls the average number of object locks allocated for each transaction; individual transactions can lock more objects as long as the locks of all transactions fit in the lock table. This is &lt;em&gt;not&lt;/em&gt; the number of rows that can be locked; that value is unlimited. The default, 64, has historically proven sufficient, but you might need to raise this value if you have queries that touch many different tables in a single transaction, e.g., query of a parent table with many children. This parameter can only be set at server start.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed8d27015cd393d0e4d2ed8b1d7004db3e56b61f" translate="yes" xml:space="preserve">
          <source>The shared memory size settings can be changed via the &lt;code&gt;sysctl&lt;/code&gt; interface. For example, to allow 16 GB:</source>
          <target state="translated">共享内存大小设置可以通过 &lt;code&gt;sysctl&lt;/code&gt; 接口进行更改。例如，要允许16 GB：</target>
        </trans-unit>
        <trans-unit id="068843c57f60fb86ac3cb60c430b5300612b2f9d" translate="yes" xml:space="preserve">
          <source>The shared predicate lock table tracks locks on &lt;code&gt;max_pred_locks_per_transaction&lt;/code&gt; * (&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; + &lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt;) objects (e.g., tables); hence, no more than this many distinct objects can be locked at any one time. This parameter controls the average number of object locks allocated for each transaction; individual transactions can lock more objects as long as the locks of all transactions fit in the lock table. This is &lt;em&gt;not&lt;/em&gt; the number of rows that can be locked; that value is unlimited. The default, 64, has generally been sufficient in testing, but you might need to raise this value if you have clients that touch many different tables in a single serializable transaction. This parameter can only be set at server start.</source>
          <target state="translated">共享谓词锁定表跟踪 &lt;code&gt;max_pred_locks_per_transaction&lt;/code&gt; *（&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; + &lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt;）对象（例如表）上的锁；因此，在任何时候最多只能锁定许多不同的对象。此参数控制为每个事务分配的平均对象锁数；只要所有事务的锁都适合锁定表，单个事务就可以锁定更多对象。这&lt;em&gt;不是&lt;/em&gt;可以锁定的行数。这个价值是无限的。默认值64通常足以进行测试，但是如果您的客户端在单个可序列化事务中触摸许多不同​​的表，则可能需要提高该值。该参数只能在服务器启动时设置。</target>
        </trans-unit>
        <trans-unit id="ca5a87d53a78cc8149d60b5d1c35e814aa59a259" translate="yes" xml:space="preserve">
          <source>The shared secrets used when talking securely to the RADIUS server. This must have exactly the same value on the PostgreSQL and RADIUS servers. It is recommended that this be a string of at least 16 characters. This parameter is required.</source>
          <target state="translated">与RADIUS服务器安全对话时使用的共享秘密。这在PostgreSQL和RADIUS服务器上必须有完全相同的值。建议使用至少16个字符的字符串。这个参数是必须的。</target>
        </trans-unit>
        <trans-unit id="1aeeff6b5f410ecdf1f1d99d13f99d22c13ce407" translate="yes" xml:space="preserve">
          <source>The shared secrets used when talking securely to the RADIUS servers. This must have exactly the same value on the PostgreSQL and RADIUS servers. It is recommended that this be a string of at least 16 characters. This parameter is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58e38019afd1ad1853e1d01481b88d4b91b8d05a" translate="yes" xml:space="preserve">
          <source>The sharp (&lt;code&gt;#&lt;/code&gt;) sign is a comment delimiter. It may appear at any position in a line. The rest of the line will be skipped.</source>
          <target state="translated">尖号（ &lt;code&gt;#&lt;/code&gt; ）是注释定界符。它可能出现在一行中的任何位置。该行的其余部分将被跳过。</target>
        </trans-unit>
        <trans-unit id="67cfcf8acce2ecc45db3a0f17045ee10928b08a1" translate="yes" xml:space="preserve">
          <source>The short procedure for configuring a standby server using this alternative method is as follows. For full details of each step, refer to previous sections as noted.</source>
          <target state="translated">使用这种替代方法配置备用服务器的简单操作步骤如下。各个步骤的详细内容,请参考前面的章节,如有说明。</target>
        </trans-unit>
        <trans-unit id="968f59638db3803d09dafd7e362f7206431f6346" translate="yes" xml:space="preserve">
          <source>The simple comparison operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;=&lt;/code&gt; compare the lower bounds first, and only if those are equal, compare the upper bounds. These comparisons are not usually very useful for ranges, but are provided to allow B-tree indexes to be constructed on ranges.</source>
          <target state="translated">简单的比较运算符 &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;=&lt;/code&gt; 和 &lt;code&gt;&amp;gt;=&lt;/code&gt; 首先比较下限，并且只有在相等时才比较上限。这些比较通常对范围不是很有用，但是提供这些比较是为了允许在范围上构造B树索引。</target>
        </trans-unit>
        <trans-unit id="8ea620de73d7bb2e034a3dc8ebd2dd0118f06f72" translate="yes" xml:space="preserve">
          <source>The simplest kind of extended statistics tracks &lt;em&gt;functional dependencies&lt;/em&gt;, a concept used in definitions of database normal forms. We say that column &lt;code&gt;b&lt;/code&gt; is functionally dependent on column &lt;code&gt;a&lt;/code&gt; if knowledge of the value of &lt;code&gt;a&lt;/code&gt; is sufficient to determine the value of &lt;code&gt;b&lt;/code&gt;, that is there are no two rows having the same value of &lt;code&gt;a&lt;/code&gt; but different values of &lt;code&gt;b&lt;/code&gt;. In a fully normalized database, functional dependencies should exist only on primary keys and superkeys. However, in practice many data sets are not fully normalized for various reasons; intentional denormalization for performance reasons is a common example. Even in a fully normalized database, there may be partial correlation between some columns, which can be expressed as partial functional dependency.</source>
          <target state="translated">最简单的扩展统计信息跟踪&lt;em&gt;功能依赖关系&lt;/em&gt;，这是用于定义数据库标准格式的概念。我们说，列 &lt;code&gt;b&lt;/code&gt; 函数依赖于列 &lt;code&gt;a&lt;/code&gt; 如果的价值的认识 &lt;code&gt;a&lt;/code&gt; 足以确定的值 &lt;code&gt;b&lt;/code&gt; ，即存在具有相同的值没有两行 &lt;code&gt;a&lt;/code&gt; ，但不同的值 &lt;code&gt;b&lt;/code&gt; 。在完全规范化的数据库中，功能依赖项仅应存在于主键和超键上。但是，实际上，由于种种原因，许多数据集没有完全标准化。出于性能原因的有意非正规化是一个常见的示例。即使在完全规范化的数据库中，某些列之间也可能存在部分相关性，这可以表示为部分功能依赖性。</target>
        </trans-unit>
        <trans-unit id="218e0e862d91c332c13bb63fca705baa68ee5396" translate="yes" xml:space="preserve">
          <source>The simplest kind of select list is &lt;code&gt;*&lt;/code&gt; which emits all columns that the table expression produces. Otherwise, a select list is a comma-separated list of value expressions (as defined in &lt;a href=&quot;sql-expressions&quot;&gt;Section 4.2&lt;/a&gt;). For instance, it could be a list of column names:</source>
          <target state="translated">选择列表最简单的一种是 &lt;code&gt;*&lt;/code&gt; ，它发出表表达式产生的所有列。否则，选择列表是用逗号分隔的值表达式列表（如&lt;a href=&quot;sql-expressions&quot;&gt;第4.2节中&lt;/a&gt;所定义）。例如，它可以是列名称的列表：</target>
        </trans-unit>
        <trans-unit id="95ff410c0d68dcd6b5d1a3a14a5e05f946ef4e40" translate="yes" xml:space="preserve">
          <source>The simplest option for removing old data is to drop the partition that is no longer necessary:</source>
          <target state="translated">删除旧数据最简单的选择是放弃不再需要的分区。</target>
        </trans-unit>
        <trans-unit id="9d938ffa1d7d07edb850b5b705fb8034d9885325" translate="yes" xml:space="preserve">
          <source>The size of the block range is determined at index creation time by the &lt;code&gt;pages_per_range&lt;/code&gt; storage parameter. The number of index entries will be equal to the size of the relation in pages divided by the selected value for &lt;code&gt;pages_per_range&lt;/code&gt;. Therefore, the smaller the number, the larger the index becomes (because of the need to store more index entries), but at the same time the summary data stored can be more precise and more data blocks can be skipped during an index scan.</source>
          <target state="translated">块范围的大小在创建索引时由 &lt;code&gt;pages_per_range&lt;/code&gt; 存储参数确定。索引条目的数量等于页面中关系的大小除以 &lt;code&gt;pages_per_range&lt;/code&gt; 的选定值。因此，数字越小，索引就越大（由于需要存储更多的索引条目），但是同时存储的摘要数据可以更精确，并且在索引扫描期间可以跳过更多的数据块。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
