<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="833c4d41d72807ff8bff00dc171b711add76bff2" translate="yes" xml:space="preserve">
          <source>This node's LSN at which &lt;code&gt;remote_lsn&lt;/code&gt; has been replicated. Used to flush commit records before persisting data to disk when using asynchronous commits.</source>
          <target state="translated">已在其中复制 &lt;code&gt;remote_lsn&lt;/code&gt; 的该节点的LSN 。使用异步提交时，用于在将数据持久保存到磁盘之前刷新提交记录。</target>
        </trans-unit>
        <trans-unit id="388063f0d1bc8c68724a848b5427707b09f5e0a2" translate="yes" xml:space="preserve">
          <source>This notation behaves differently depending on context; see &lt;a href=&quot;rowtypes#ROWTYPES-USAGE&quot;&gt;Section 8.16.5&lt;/a&gt; for details.</source>
          <target state="translated">根据上下文的不同，此表示法的行为也有所不同。有关详细信息，请参见&lt;a href=&quot;rowtypes#ROWTYPES-USAGE&quot;&gt;第8.16.5节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ff98e9774f8c6e6fad6dce4d14a177af4ff71408" translate="yes" xml:space="preserve">
          <source>This operator supports hash joins</source>
          <target state="translated">该运算符支持哈希连接</target>
        </trans-unit>
        <trans-unit id="2c90e947b03275ac339cbaa9aa960fdd656aa3ae" translate="yes" xml:space="preserve">
          <source>This operator supports merge joins</source>
          <target state="translated">该操作符支持合并连接</target>
        </trans-unit>
        <trans-unit id="033a065728054a33c7f38b0e616194e5c2c3aaa5" translate="yes" xml:space="preserve">
          <source>This option allows running &lt;code&gt;pg_dump -j&lt;/code&gt; against a pre-9.2 server, see the documentation of the &lt;code&gt;-j&lt;/code&gt; parameter for more details.</source>
          <target state="translated">此选项允许在9.2之前的服务器上运行 &lt;code&gt;pg_dump -j&lt;/code&gt; ，有关更多详细信息，请参见 &lt;code&gt;-j&lt;/code&gt; 参数的文档。</target>
        </trans-unit>
        <trans-unit id="67692a76bdedd175ae4ea2832082e8bfa1d20815" translate="yes" xml:space="preserve">
          <source>This option always affects transfer of the data directory. Transfer of WAL files is only affected if the collection method is &lt;code&gt;fetch&lt;/code&gt;.</source>
          <target state="translated">此选项始终会影响数据目录的传输。仅当收集方法为 &lt;code&gt;fetch&lt;/code&gt; 时,才会影响WAL文件的传输。</target>
        </trans-unit>
        <trans-unit id="66b9c3dfa7b75f649757901e5e89c1862e7c3ada" translate="yes" xml:space="preserve">
          <source>This option can be set by any user. Because of that, the libraries that can be loaded are restricted to those appearing in the &lt;code&gt;plugins&lt;/code&gt; subdirectory of the installation's standard library directory. (It is the database administrator's responsibility to ensure that only &amp;ldquo;safe&amp;rdquo; libraries are installed there.) Entries in &lt;code&gt;local_preload_libraries&lt;/code&gt; can specify this directory explicitly, for example &lt;code&gt;$libdir/plugins/mylib&lt;/code&gt;, or just specify the library name &amp;mdash; &lt;code&gt;mylib&lt;/code&gt; would have the same effect as &lt;code&gt;$libdir/plugins/mylib&lt;/code&gt;.</source>
          <target state="translated">任何用户都可以设置此选项。因此，可以加载的库仅限于安装在标准库目录的 &lt;code&gt;plugins&lt;/code&gt; 子目录中的库。 （数据库管理员有责任确保仅在其中安装&amp;ldquo;安全&amp;rdquo;库。） &lt;code&gt;local_preload_libraries&lt;/code&gt; 中的条目可以显式指定此目录，例如 &lt;code&gt;$libdir/plugins/mylib&lt;/code&gt; ，或仅指定库名 &lt;code&gt;mylib&lt;/code&gt; 将具有相同的名称。效果为 &lt;code&gt;$libdir/plugins/mylib&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a0fc1ca8b2fbb1af9a9d77b22b8df428dc16da8" translate="yes" xml:space="preserve">
          <source>This option can only be used in combination with one or more &lt;code&gt;-c&lt;/code&gt; and/or &lt;code&gt;-f&lt;/code&gt; options. It causes psql to issue a &lt;code&gt;BEGIN&lt;/code&gt; command before the first such option and a &lt;code&gt;COMMIT&lt;/code&gt; command after the last one, thereby wrapping all the commands into a single transaction. This ensures that either all the commands complete successfully, or no changes are applied.</source>
          <target state="translated">该选项只能与一个或多个 &lt;code&gt;-c&lt;/code&gt; 和/或 &lt;code&gt;-f&lt;/code&gt; 选项结合使用。它使psql 在第一个这样的选项之前发出 &lt;code&gt;BEGIN&lt;/code&gt; 命令，在最后一个之后发出 &lt;code&gt;COMMIT&lt;/code&gt; 命令，从而将所有命令包装到一个事务中。这样可以确保所有命令都成功完成，或者不应用任何更改。</target>
        </trans-unit>
        <trans-unit id="bd1e801996f18e878c7421f7a76634808df68609" translate="yes" xml:space="preserve">
          <source>This option can only be used together with &lt;code&gt;-X stream&lt;/code&gt;. It causes WAL streaming to use the specified replication slot. If the base backup is intended to be used as a streaming-replication standby using a replication slot, the standby should then use the same replication slot name as &lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-SLOT-NAME&quot;&gt;primary_slot_name&lt;/a&gt;. This ensures that the primary server does not remove any necessary WAL data in the time between the end of the base backup and the start of streaming replication on the new standby.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4af26bb42d56efbdd77ea30d507197b50c1c0a6e" translate="yes" xml:space="preserve">
          <source>This option can only be used together with &lt;code&gt;-X stream&lt;/code&gt;. It causes the WAL streaming to use the specified replication slot. If the base backup is intended to be used as a streaming replication standby using replication slots, it should then use the same replication slot name in &lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-SLOT-NAME&quot;&gt;primary_slot_name&lt;/a&gt;. That way, it is ensured that the server does not remove any necessary WAL data in the time between the end of the base backup and the start of streaming replication.</source>
          <target state="translated">该选项只能与 &lt;code&gt;-X stream&lt;/code&gt; 一起使用。这将导致WAL流使用指定的复制插槽。如果打算将基本备份用作使用复制插槽的流复制备用数据库，则应在&lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-SLOT-NAME&quot;&gt;primary_slot_name中&lt;/a&gt;使用相同的复制插槽名称。这样，可以确保服务器在基本备份结束到流复制开始之间不删除任何必要的WAL数据。</target>
        </trans-unit>
        <trans-unit id="6dcf604d43dc6007ea78136bf7b33be7b4e62ae3" translate="yes" xml:space="preserve">
          <source>This option cannot be used to remove the support function altogether, since it must name a new support function. Use &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; if you need to do that.</source>
          <target state="translated">此选项不能完全删除支持功能，因为它必须命名一个新的支持功能。如果需要，请使用 &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd8d44929298a4cbf2c87cec1c31093bc64b155b" translate="yes" xml:space="preserve">
          <source>This option causes &lt;code&gt;pg_receivewal&lt;/code&gt; to not force WAL data to be flushed to disk. This is faster, but means that a subsequent operating system crash can leave the WAL segments corrupt. Generally, this option is useful for testing but should not be used when doing WAL archiving on a production deployment.</source>
          <target state="translated">该选项使 &lt;code&gt;pg_receivewal&lt;/code&gt; 不会强制将WAL数据刷新到磁盘。这更快，但是意味着随后的操作系统崩溃可能会使WAL段损坏。通常，此选项对于测试很有用，但在生产部署上进行WAL归档时不应使用。</target>
        </trans-unit>
        <trans-unit id="0a83f03d78ff431f987c79d1993890ac0162fd03" translate="yes" xml:space="preserve">
          <source>This option causes creation of a replication slot named by the &lt;code&gt;--slot&lt;/code&gt; option before starting the backup. An error is raised if the slot already exists.</source>
          <target state="translated">此选项导致在开始备份之前创建由 &lt;code&gt;--slot&lt;/code&gt; 选项命名的复制插槽。如果插槽已存在，则会引发错误。</target>
        </trans-unit>
        <trans-unit id="019a3bff9bc43aecc3893ea645652e695f875fd1" translate="yes" xml:space="preserve">
          <source>This option controls the behavior of automatically updatable views. When this option is specified, &lt;code&gt;INSERT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; commands on the view will be checked to ensure that new rows satisfy the view-defining condition (that is, the new rows are checked to ensure that they are visible through the view). If they are not, the update will be rejected. If the &lt;code&gt;CHECK OPTION&lt;/code&gt; is not specified, &lt;code&gt;INSERT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; commands on the view are allowed to create rows that are not visible through the view. The following check options are supported:</source>
          <target state="translated">此选项控制自动更新视图的行为。指定此选项后，将检查视图上的 &lt;code&gt;INSERT&lt;/code&gt; 和 &lt;code&gt;UPDATE&lt;/code&gt; 命令以确保新行满足视图定义条件（即，检查新行以确保它们在视图中可见）。如果不是，则更新将被拒绝。如果未指定 &lt;code&gt;CHECK OPTION&lt;/code&gt; ，则允许视图上的 &lt;code&gt;INSERT&lt;/code&gt; 和 &lt;code&gt;UPDATE&lt;/code&gt; 命令创建在视图中不可见的行。支持以下检查选项：</target>
        </trans-unit>
        <trans-unit id="2fa12085b7bbeed5763de22cebaafe8cc79d4acb" translate="yes" xml:space="preserve">
          <source>This option controls whether &lt;code&gt;postgres_fdw&lt;/code&gt; allows foreign tables to be modified using &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; commands. It can be specified for a foreign table or a foreign server. A table-level option overrides a server-level option. The default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">此选项控制 &lt;code&gt;postgres_fdw&lt;/code&gt; 是否允许使用 &lt;code&gt;INSERT&lt;/code&gt; ， &lt;code&gt;UPDATE&lt;/code&gt; 和 &lt;code&gt;DELETE&lt;/code&gt; 命令修改外部表。可以为外部表或外部服务器指定它。表级选项将覆盖服务器级选项。默认值为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c306234b370cc56fe65c31871921559cfe86c86e" translate="yes" xml:space="preserve">
          <source>This option controls whether column &lt;code&gt;COLLATE&lt;/code&gt; options are included in the definitions of foreign tables imported from a foreign server. The default is &lt;code&gt;true&lt;/code&gt;. You might need to turn this off if the remote server has a different set of collation names than the local server does, which is likely to be the case if it's running on a different operating system.</source>
          <target state="translated">此选项控制从外部服务器导入的外部表的定义中是否包括列 &lt;code&gt;COLLATE&lt;/code&gt; 选项。默认值为 &lt;code&gt;true&lt;/code&gt; 。如果远程服务器具有与本地服务器不同的排序规则名称集，则可能需要关闭此功能（如果它在不同的操作系统上运行，则可能是这种情况）。</target>
        </trans-unit>
        <trans-unit id="9a2c7892fe0f505a8ed2a71e7d9d8917529e89f4" translate="yes" xml:space="preserve">
          <source>This option controls whether column &lt;code&gt;DEFAULT&lt;/code&gt; expressions are included in the definitions of foreign tables imported from a foreign server. The default is &lt;code&gt;false&lt;/code&gt;. If you enable this option, be wary of defaults that might get computed differently on the local server than they would be on the remote server; &lt;code&gt;nextval()&lt;/code&gt; is a common source of problems. The &lt;code&gt;IMPORT&lt;/code&gt; will fail altogether if an imported default expression uses a function or operator that does not exist locally.</source>
          <target state="translated">此选项控制从外部服务器导入的外部表的定义中是否包括列 &lt;code&gt;DEFAULT&lt;/code&gt; 表达式。默认值为 &lt;code&gt;false&lt;/code&gt; 。如果启用此选项，请警惕默认值，这些默认值在本地服务器上的计算方式可能与在远程服务器上的计算方式有所不同； &lt;code&gt;nextval()&lt;/code&gt; 是常见的问题来源。该 &lt;code&gt;IMPORT&lt;/code&gt; 如果导入的默认表达式使用不存在于本地的函数或运营商将完全失败。</target>
        </trans-unit>
        <trans-unit id="c777fcd8f37f1faf36e546a259bf3994c8ebf0b0" translate="yes" xml:space="preserve">
          <source>This option controls whether column &lt;code&gt;NOT NULL&lt;/code&gt; constraints are included in the definitions of foreign tables imported from a foreign server. The default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">此选项控制从外部服务器导入的外部表的定义中是否包括列 &lt;code&gt;NOT NULL&lt;/code&gt; 约束。默认值为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4534428c01b535724cfe3334dea2585c43336e1" translate="yes" xml:space="preserve">
          <source>This option disables the use of dollar quoting for function bodies, and forces them to be quoted using SQL standard string syntax.</source>
          <target state="translated">这个选项禁止在函数体中使用美元引号,并强制使用SQL标准字符串语法进行引号。</target>
        </trans-unit>
        <trans-unit id="1e5b8577c4f91feed1cbbbf28c3713fcd0567f3a" translate="yes" xml:space="preserve">
          <source>This option dumps out the server's internal configuration variables, descriptions, and defaults in tab-delimited &lt;code&gt;COPY&lt;/code&gt; format. It is designed primarily for use by administration tools.</source>
          <target state="translated">此选项以制表符分隔的 &lt;code&gt;COPY&lt;/code&gt; 格式转储服务器的内部配置变量，描述和默认值。它主要设计用于管理工具。</target>
        </trans-unit>
        <trans-unit id="39d1d4f9b39a2419e5e71963676b76de7092eb75" translate="yes" xml:space="preserve">
          <source>This option has no effect on &lt;code&gt;-N&lt;/code&gt;/&lt;code&gt;--exclude-schema&lt;/code&gt;, &lt;code&gt;-T&lt;/code&gt;/&lt;code&gt;--exclude-table&lt;/code&gt;, or &lt;code&gt;--exclude-table-data&lt;/code&gt;. An exclude pattern failing to match any objects is not considered an error.</source>
          <target state="translated">此选项对 &lt;code&gt;-N&lt;/code&gt; / &lt;code&gt;--exclude-schema&lt;/code&gt; ， &lt;code&gt;-T&lt;/code&gt; / &lt;code&gt;--exclude-table&lt;/code&gt; 或 &lt;code&gt;--exclude-table-data&lt;/code&gt; 没有影响。无法匹配任何对象的排除模式不视为错误。</target>
        </trans-unit>
        <trans-unit id="44b5c0279373253dcf944caef48c35c814e3748e" translate="yes" xml:space="preserve">
          <source>This option has the same effect as the option of the same name in &lt;a href=&quot;app-pgreceivewal&quot;&gt;pg_receivewal&lt;/a&gt;. See the description there.</source>
          <target state="translated">该选项与&lt;a href=&quot;app-pgreceivewal&quot;&gt;pg_receivewal&lt;/a&gt;中具有相同名称的选项具有相同的作用。参见那里的描述。</target>
        </trans-unit>
        <trans-unit id="e156f33e8e3c423b7dd6e39f40b8d2b97fdc7406" translate="yes" xml:space="preserve">
          <source>This option is a comma-separated list of names of PostgreSQL extensions that are installed, in compatible versions, on both the local and remote servers. Functions and operators that are immutable and belong to a listed extension will be considered shippable to the remote server. This option can only be specified for foreign servers, not per-table.</source>
          <target state="translated">这个选项是一个以逗号分隔的PostgreSQL扩展名称列表,这些扩展在本地和远程服务器上都安装了兼容版本。属于所列扩展的不可更改的函数和操作符将被认为可以被运到远程服务器。这个选项只能为国外服务器指定,不能为每个表指定。</target>
        </trans-unit>
        <trans-unit id="dd3ca03402c96b67aa550ad0869d48010fb66dab" translate="yes" xml:space="preserve">
          <source>This option is deprecated since it does not allow access to the full functionality of &lt;a href=&quot;runtime-config-connection#GUC-LISTEN-ADDRESSES&quot;&gt;listen_addresses&lt;/a&gt;. It's usually better to set &lt;code&gt;listen_addresses&lt;/code&gt; directly.</source>
          <target state="translated">不建议使用此选项，因为它不允许访问&lt;a href=&quot;runtime-config-connection#GUC-LISTEN-ADDRESSES&quot;&gt;listen_addresses&lt;/a&gt;的全部功能。通常最好直接设置 &lt;code&gt;listen_addresses&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b68d58ae84a3ecac214be2012e7c336871134f8" translate="yes" xml:space="preserve">
          <source>This option is effective only when restoring directly into a database, not when producing SQL script output.</source>
          <target state="translated">这个选项只有在直接还原到数据库中时才有效,在产生SQL脚本输出时无效。</target>
        </trans-unit>
        <trans-unit id="968dc4a560c532375e657416e7cf0bbd50ef3170" translate="yes" xml:space="preserve">
          <source>This option is for debugging problems that cause a server process to die abnormally. The ordinary strategy in this situation is to notify all other server processes that they must terminate and then reinitialize the shared memory and semaphores. This is because an errant server process could have corrupted some shared state before terminating. This option specifies that &lt;code&gt;postgres&lt;/code&gt; will not reinitialize shared data structures. A knowledgeable system programmer can then use a debugger to examine shared memory and semaphore state.</source>
          <target state="translated">此选项用于调试导致服务器进程异常终止的问题。在这种情况下，通常的策略是通知所有其他服务器进程它们必须终止，然后重新初始化共享内存和信号灯。这是因为错误的服务器进程可能在终止之前破坏了某些共享状态。该选项指定 &lt;code&gt;postgres&lt;/code&gt; 将不重新初始化共享数据结构。然后，经验丰富的系统程序员可以使用调试器检查共享内存和信号量状态。</target>
        </trans-unit>
        <trans-unit id="42927906afa65b972047e92608a8fe2f81b95297" translate="yes" xml:space="preserve">
          <source>This option is for debugging problems that cause a server process to die abnormally. The ordinary strategy in this situation is to notify all other server processes that they must terminate and then reinitialize the shared memory and semaphores. This is because an errant server process could have corrupted some shared state before terminating. This option specifies that &lt;code&gt;postgres&lt;/code&gt; will stop all other server processes by sending the signal &lt;code&gt;SIGSTOP&lt;/code&gt;, but will not cause them to terminate. This permits system programmers to collect core dumps from all server processes by hand.</source>
          <target state="translated">此选项用于调试导致服务器进程异常终止的问题。在这种情况下，通常的策略是通知所有其他服务器进程它们必须终止，然后重新初始化共享内存和信号灯。这是因为错误的服务器进程可能在终止之前破坏了某些共享状态。此选项指定 &lt;code&gt;postgres&lt;/code&gt; 将通过发送信号 &lt;code&gt;SIGSTOP&lt;/code&gt; 来停止所有其他服务器进程，但不会导致它们终止。这允许系统程序员从所有服务器进程中手动收集核心转储。</target>
        </trans-unit>
        <trans-unit id="a2fa6b1b1272f22fc7098675bb1c64f065394241" translate="yes" xml:space="preserve">
          <source>This option is for use by in-place upgrade utilities. Its use for other purposes is not recommended or supported. The behavior of the option may change in future releases without notice.</source>
          <target state="translated">此选项供原地升级实用程序使用。不建议或不支持将其用于其他目的。该选项的行为可能会在未来的版本中改变,恕不另行通知。</target>
        </trans-unit>
        <trans-unit id="efc4bf4d899439505edd24a5ec7b6f3018597535" translate="yes" xml:space="preserve">
          <source>This option is incompatible with &lt;code&gt;--synchronous&lt;/code&gt;.</source>
          <target state="translated">此选项与 &lt;code&gt;--synchronous&lt;/code&gt; 不兼容。</target>
        </trans-unit>
        <trans-unit id="1e4f9dc483d33770bfc633e073d626e91a285814" translate="yes" xml:space="preserve">
          <source>This option is like &lt;code&gt;FINALFUNC_MODIFY&lt;/code&gt;, but it describes the behavior of the moving-aggregate final function.</source>
          <target state="translated">此选项类似于 &lt;code&gt;FINALFUNC_MODIFY&lt;/code&gt; ，但是它描述了移动聚集最终函数的行为。</target>
        </trans-unit>
        <trans-unit id="ae64748d4bfb71bb191824f72616015218279c62" translate="yes" xml:space="preserve">
          <source>This option is meant for other programs that interact with a server instance, such as &lt;a href=&quot;app-pg-ctl&quot;&gt;pg_ctl&lt;/a&gt;, to query configuration parameter values. User-facing applications should instead use &lt;a href=&quot;sql-show&quot;&gt;SHOW&lt;/a&gt; or the &lt;code&gt;pg_settings&lt;/code&gt; view.</source>
          <target state="translated">此选项用于与服务器实例进行交互的其他程序，例如&lt;a href=&quot;app-pg-ctl&quot;&gt;pg_ctl&lt;/a&gt;，以查询配置参数值。面向用户的应用程序应改用&lt;a href=&quot;sql-show&quot;&gt;SHOW&lt;/a&gt;或 &lt;code&gt;pg_settings&lt;/code&gt; 视图。</target>
        </trans-unit>
        <trans-unit id="23fe24f85cebd351b3b05171efa5d22c8435d8a9" translate="yes" xml:space="preserve">
          <source>This option is never essential, since clusterdb will automatically prompt for a password if the server demands password authentication. However, clusterdb will waste a connection attempt finding out that the server wants a password. In some cases it is worth typing &lt;code&gt;-W&lt;/code&gt; to avoid the extra connection attempt.</source>
          <target state="translated">此选项从不是必需的，因为如果服务器要求密码验证，则clusterdb会自动提示输入密码。但是，clusterdb将浪费连接尝试，以发现服务器需要密码。在某些情况下，值得输入 &lt;code&gt;-W&lt;/code&gt; 以避免额外的连接尝试。</target>
        </trans-unit>
        <trans-unit id="f254a9b047ca402de17693af7a288974f935b320" translate="yes" xml:space="preserve">
          <source>This option is never essential, since createdb will automatically prompt for a password if the server demands password authentication. However, createdb will waste a connection attempt finding out that the server wants a password. In some cases it is worth typing &lt;code&gt;-W&lt;/code&gt; to avoid the extra connection attempt.</source>
          <target state="translated">此选项从不是必需的，因为如果服务器要求密码验证，则createdb会自动提示输入密码。但是，createdb将浪费连接尝试，因为它发现服务器需要密码。在某些情况下，值得输入 &lt;code&gt;-W&lt;/code&gt; 以避免额外的连接尝试。</target>
        </trans-unit>
        <trans-unit id="157ee8063fde732007da77e5a7853bb1478d9344" translate="yes" xml:space="preserve">
          <source>This option is never essential, since createuser will automatically prompt for a password if the server demands password authentication. However, createuser will waste a connection attempt finding out that the server wants a password. In some cases it is worth typing &lt;code&gt;-W&lt;/code&gt; to avoid the extra connection attempt.</source>
          <target state="translated">此选项从不是必需的，因为如果服务器要求密码验证，则createuser会自动提示输入密码。但是，createuser会浪费连接尝试，因为发现服务器需要密码。在某些情况下，值得输入 &lt;code&gt;-W&lt;/code&gt; 以避免额外的连接尝试。</target>
        </trans-unit>
        <trans-unit id="a83ff3482275d0139a05f884462c1cbde3746882" translate="yes" xml:space="preserve">
          <source>This option is never essential, since dropdb will automatically prompt for a password if the server demands password authentication. However, dropdb will waste a connection attempt finding out that the server wants a password. In some cases it is worth typing &lt;code&gt;-W&lt;/code&gt; to avoid the extra connection attempt.</source>
          <target state="translated">此选项从不是必需的，因为如果服务器要求密码验证，则dropdb会自动提示输入密码。但是，dropdb会浪费连接尝试，以发现服务器需要密码。在某些情况下，值得输入 &lt;code&gt;-W&lt;/code&gt; 以避免额外的连接尝试。</target>
        </trans-unit>
        <trans-unit id="8e23fb76571b4a9d33af9f1ddf6f1f50ba682fde" translate="yes" xml:space="preserve">
          <source>This option is never essential, since dropuser will automatically prompt for a password if the server demands password authentication. However, dropuser will waste a connection attempt finding out that the server wants a password. In some cases it is worth typing &lt;code&gt;-W&lt;/code&gt; to avoid the extra connection attempt.</source>
          <target state="translated">此选项从不是必需的，因为如果服务器要求密码验证，则dropuser会自动提示输入密码。但是，dropuser会浪费连接尝试，因为发现服务器需要密码。在某些情况下，值得输入 &lt;code&gt;-W&lt;/code&gt; 以避免额外的连接尝试。</target>
        </trans-unit>
        <trans-unit id="d7fdd419219d3924efcfbfee9fcca516b8868b92" translate="yes" xml:space="preserve">
          <source>This option is never essential, since pg_basebackup will automatically prompt for a password if the server demands password authentication. However, pg_basebackup will waste a connection attempt finding out that the server wants a password. In some cases it is worth typing &lt;code&gt;-W&lt;/code&gt; to avoid the extra connection attempt.</source>
          <target state="translated">该选项从不是必需的，因为如果服务器要求密码验证，则pg_basebackup会自动提示输入密码。但是，pg_basebackup会浪费连接尝试，以发现服务器需要密码。在某些情况下，值得输入 &lt;code&gt;-W&lt;/code&gt; 以避免额外的连接尝试。</target>
        </trans-unit>
        <trans-unit id="3e876a82eec6b6016da4b2fff5952e7b1eae2117" translate="yes" xml:space="preserve">
          <source>This option is never essential, since pg_dump will automatically prompt for a password if the server demands password authentication. However, pg_dump will waste a connection attempt finding out that the server wants a password. In some cases it is worth typing &lt;code&gt;-W&lt;/code&gt; to avoid the extra connection attempt.</source>
          <target state="translated">这个选项从来都不是必须的，因为如果服务器要求密码认证，pg_dump会自动提示输入密码。但是，pg_dump会浪费连接尝试，发现服务器需要密码。在某些情况下，值得输入 &lt;code&gt;-W&lt;/code&gt; 以避免额外的连接尝试。</target>
        </trans-unit>
        <trans-unit id="27e4143fa6008ebc17a6f2bd2303d88c172e5590" translate="yes" xml:space="preserve">
          <source>This option is never essential, since pg_dumpall will automatically prompt for a password if the server demands password authentication. However, pg_dumpall will waste a connection attempt finding out that the server wants a password. In some cases it is worth typing &lt;code&gt;-W&lt;/code&gt; to avoid the extra connection attempt.</source>
          <target state="translated">这个选项从来都不是必须的，因为如果服务器要求密码认证，pg_dumpall将自动提示输入密码。但是，pg_dumpall将浪费连接尝试，以发现服务器需要密码。在某些情况下，值得输入 &lt;code&gt;-W&lt;/code&gt; 以避免额外的连接尝试。</target>
        </trans-unit>
        <trans-unit id="eb179ceeb157dc043c6e084a77ba22cf202bd214" translate="yes" xml:space="preserve">
          <source>This option is never essential, since pg_receivewal will automatically prompt for a password if the server demands password authentication. However, pg_receivewal will waste a connection attempt finding out that the server wants a password. In some cases it is worth typing &lt;code&gt;-W&lt;/code&gt; to avoid the extra connection attempt.</source>
          <target state="translated">这个选项从来都不是必须的，因为如果服务器要求密码认证，pg_receivewal会自动提示输入密码。但是，pg_receivewal将浪费连接尝试，以发现服务器需要密码。在某些情况下，值得输入 &lt;code&gt;-W&lt;/code&gt; 以避免额外的连接尝试。</target>
        </trans-unit>
        <trans-unit id="5f63e7019adc4bf629542d951d6d5ad2c631d4cd" translate="yes" xml:space="preserve">
          <source>This option is never essential, since pg_recvlogical will automatically prompt for a password if the server demands password authentication. However, pg_recvlogical will waste a connection attempt finding out that the server wants a password. In some cases it is worth typing &lt;code&gt;-W&lt;/code&gt; to avoid the extra connection attempt.</source>
          <target state="translated">这个选项从来都不是必须的，因为如果服务器要求密码认证，pg_recvologic将自动提示输入密码。但是，pg_recvologic将浪费连接尝试，以发现服务器需要密码。在某些情况下，值得输入 &lt;code&gt;-W&lt;/code&gt; 以避免额外的连接尝试。</target>
        </trans-unit>
        <trans-unit id="c89398ef361ce35bb760f8007920d0c1cab1f07e" translate="yes" xml:space="preserve">
          <source>This option is never essential, since pg_restore will automatically prompt for a password if the server demands password authentication. However, pg_restore will waste a connection attempt finding out that the server wants a password. In some cases it is worth typing &lt;code&gt;-W&lt;/code&gt; to avoid the extra connection attempt.</source>
          <target state="translated">这个选项从来都不是必须的，因为如果服务器要求密码认证，pg_restore会自动提示输入密码。但是，pg_restore会浪费连接尝试，发现服务器需要密码。在某些情况下，值得输入 &lt;code&gt;-W&lt;/code&gt; 以避免额外的连接尝试。</target>
        </trans-unit>
        <trans-unit id="95a2ae73f9f018a5089634f6a2f0aa09f43ae7cf" translate="yes" xml:space="preserve">
          <source>This option is never essential, since psql will automatically prompt for a password if the server demands password authentication. However, psql will waste a connection attempt finding out that the server wants a password. In some cases it is worth typing &lt;code&gt;-W&lt;/code&gt; to avoid the extra connection attempt.</source>
          <target state="translated">此选项从不是必需的，因为如果服务器要求密码验证，则psql将自动提示输入密码。但是，psql会浪费连接尝试，以便发现服务器需要密码。在某些情况下，值得输入 &lt;code&gt;-W&lt;/code&gt; 以避免额外的连接尝试。</target>
        </trans-unit>
        <trans-unit id="7a901f15557b845dee3a28d047b1c6eaa3bd5227" translate="yes" xml:space="preserve">
          <source>This option is never essential, since reindexdb will automatically prompt for a password if the server demands password authentication. However, reindexdb will waste a connection attempt finding out that the server wants a password. In some cases it is worth typing &lt;code&gt;-W&lt;/code&gt; to avoid the extra connection attempt.</source>
          <target state="translated">此选项从不是必需的，因为如果服务器要求密码验证，则reindexdb将自动提示输入密码。但是，reindexdb会浪费连接尝试，因为发现服务器需要密码。在某些情况下，值得输入 &lt;code&gt;-W&lt;/code&gt; 以避免额外的连接尝试。</target>
        </trans-unit>
        <trans-unit id="dbc79a1fac3829f416356bb18d094f1758bd877c" translate="yes" xml:space="preserve">
          <source>This option is never essential, since vacuumdb will automatically prompt for a password if the server demands password authentication. However, vacuumdb will waste a connection attempt finding out that the server wants a password. In some cases it is worth typing &lt;code&gt;-W&lt;/code&gt; to avoid the extra connection attempt.</source>
          <target state="translated">此选项从不是必需的，因为如果服务器要求密码验证，vacuumdb会自动提示输入密码。但是，vacuumdb会浪费连接尝试，因为发现服务器需要密码。在某些情况下，值得输入 &lt;code&gt;-W&lt;/code&gt; 以避免额外的连接尝试。</target>
        </trans-unit>
        <trans-unit id="dda9882d48af54bf77af6c2ab2fac746520d065c" translate="yes" xml:space="preserve">
          <source>This option is not allowed when using &lt;code&gt;--progress&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdca7882144557a657e3bff6adae96d14c901833" translate="yes" xml:space="preserve">
          <source>This option is not beneficial for a dump which is intended only for disaster recovery. It could be useful for a dump used to load a copy of the database for reporting or other read-only load sharing while the original database continues to be updated. Without it the dump may reflect a state which is not consistent with any serial execution of the transactions eventually committed. For example, if batch processing techniques are used, a batch may show as closed in the dump without all of the items which are in the batch appearing.</source>
          <target state="translated">这个选项对于仅用于灾难恢复的转储来说是不利的。对于用于加载数据库副本的转储来说,它可能是有用的,因为在原始数据库继续更新的同时,它还可以用于报告或其他只读负载共享。如果没有它,dump可能反映的状态与最终提交的事务的任何串行执行不一致。例如,如果使用了批处理技术,一个批处理可能会在转储中显示为已关闭,而没有出现该批处理中的所有项目。</target>
        </trans-unit>
        <trans-unit id="1596ca6548e67cb8844cfbb65595e0b71113d97f" translate="yes" xml:space="preserve">
          <source>This option is obsolete but still accepted for backward compatibility.</source>
          <target state="translated">这个选项已经过时,但为了向后兼容,仍然被接受。</target>
        </trans-unit>
        <trans-unit id="e30db5eac1f2738189322576d23177c26d58b051" translate="yes" xml:space="preserve">
          <source>This option is obsolete but still accepted for backwards compatibility.</source>
          <target state="translated">这个选项已经过时,但为了向后兼容,仍然被接受。</target>
        </trans-unit>
        <trans-unit id="227e2cf57ba512d3c77422f415b31285dea4085a" translate="yes" xml:space="preserve">
          <source>This option is only allowed if there is at least one &lt;code&gt;UNIQUE&lt;/code&gt; index on the materialized view which uses only column names and includes all rows; that is, it must not be an expression index or include a &lt;code&gt;WHERE&lt;/code&gt; clause.</source>
          <target state="translated">仅当 &lt;code&gt;UNIQUE&lt;/code&gt; 化视图上至少有一个UNIQUE索引仅使用列名并包括所有行时，才允许使用此选项；也就是说，它不能是表达式索引或包含 &lt;code&gt;WHERE&lt;/code&gt; 子句。</target>
        </trans-unit>
        <trans-unit id="c4296d287e293665ac5a27dd6a9adf50943b9468" translate="yes" xml:space="preserve">
          <source>This option is only available for servers running PostgreSQL 12 and later.</source>
          <target state="translated">这个选项只适用于运行PostgreSQL 12及以后的服务器。</target>
        </trans-unit>
        <trans-unit id="e60792d332e761d9c0448cb84d4e71c131b9f16f" translate="yes" xml:space="preserve">
          <source>This option is only available for servers running PostgreSQL 13 and later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b30b52665fa2ce02b72d1a4b69125f19a948988b" translate="yes" xml:space="preserve">
          <source>This option is only available for servers running PostgreSQL 9.6 and later.</source>
          <target state="translated">这个选项只适用于运行PostgreSQL 9.6及以上版本的服务器。</target>
        </trans-unit>
        <trans-unit id="37e0bc099903a971ee1851f56b57d535fe28abb3" translate="yes" xml:space="preserve">
          <source>This option is only meaningful for the plain-text format. For the archive formats, you can specify the option when you call &lt;code&gt;pg_restore&lt;/code&gt;.</source>
          <target state="translated">此选项仅对纯文本格式有意义。对于归档格式，可以在调用 &lt;code&gt;pg_restore&lt;/code&gt; 时指定选项。</target>
        </trans-unit>
        <trans-unit id="32d675434a5906af1a52811945caa7f3758ed1a6" translate="yes" xml:space="preserve">
          <source>This option is relevant only when creating a data-only dump. It instructs pg_dump to include commands to temporarily disable triggers on the target tables while the data is reloaded. Use this if you have referential integrity checks or other triggers on the tables that you do not want to invoke during data reload.</source>
          <target state="translated">这个选项只适用于创建纯数据转储的时候,它指示pg_dump包含在目标表上暂时禁用触发器的命令。它指示pg_dump在重载数据时包含命令来暂时禁用目标表上的触发器。如果你在表上有引用完整性检查或其他触发器,而你又不想在数据重载期间调用,那么就使用这个选项。</target>
        </trans-unit>
        <trans-unit id="e55f65ea72f8a90277e680e4be1296a1699e5d3e" translate="yes" xml:space="preserve">
          <source>This option is relevant only when creating a data-only dump. It instructs pg_dumpall to include commands to temporarily disable triggers on the target tables while the data is reloaded. Use this if you have referential integrity checks or other triggers on the tables that you do not want to invoke during data reload.</source>
          <target state="translated">这个选项只适用于创建纯数据转储时。它指示pg_dumpall在重载数据时,包含命令来暂时禁用目标表上的触发器。如果在数据重载期间不想在表上使用引用完整性检查或其他触发器,可以使用这个选项。</target>
        </trans-unit>
        <trans-unit id="36d07ffa5564debc3dc316ccc0efca57402fc186" translate="yes" xml:space="preserve">
          <source>This option is relevant only when dumping the contents of a table which has row security. By default, pg_dump will set &lt;a href=&quot;runtime-config-client#GUC-ROW-SECURITY&quot;&gt;row_security&lt;/a&gt; to off, to ensure that all data is dumped from the table. If the user does not have sufficient privileges to bypass row security, then an error is thrown. This parameter instructs pg_dump to set &lt;a href=&quot;runtime-config-client#GUC-ROW-SECURITY&quot;&gt;row_security&lt;/a&gt; to on instead, allowing the user to dump the parts of the contents of the table that they have access to.</source>
          <target state="translated">仅当转储具有行安全性的表的内容时，此选项才相关。默认情况下，pg_dump会将&lt;a href=&quot;runtime-config-client#GUC-ROW-SECURITY&quot;&gt;row_security&lt;/a&gt;设置为off，以确保从表中转储所有数据。如果用户没有足够的特权绕过行安全性，那么将引发错误。此参数指示pg_dump改为将&lt;a href=&quot;runtime-config-client#GUC-ROW-SECURITY&quot;&gt;row_security&lt;/a&gt;设置为on，从而允许用户转储他们有权访问的表的内容部分。</target>
        </trans-unit>
        <trans-unit id="a7d02ec8b27bc6590e144e516d9c202d42175dc3" translate="yes" xml:space="preserve">
          <source>This option is relevant only when performing a data-only restore. It instructs pg_restore to execute commands to temporarily disable triggers on the target tables while the data is reloaded. Use this if you have referential integrity checks or other triggers on the tables that you do not want to invoke during data reload.</source>
          <target state="translated">这个选项只适用于只还原数据的时候。它指示pg_restore在重新加载数据时,执行命令来暂时禁用目标表上的触发器。如果你在表上有引用完整性检查或其他触发器,而你又不想在数据重载期间调用,那么就使用这个选项。</target>
        </trans-unit>
        <trans-unit id="215e331321ddcb53a6c0155b5517f0808745ff2d" translate="yes" xml:space="preserve">
          <source>This option is relevant only when restoring the contents of a table which has row security. By default, pg_restore will set &lt;a href=&quot;runtime-config-client#GUC-ROW-SECURITY&quot;&gt;row_security&lt;/a&gt; to off, to ensure that all data is restored in to the table. If the user does not have sufficient privileges to bypass row security, then an error is thrown. This parameter instructs pg_restore to set &lt;a href=&quot;runtime-config-client#GUC-ROW-SECURITY&quot;&gt;row_security&lt;/a&gt; to on instead, allowing the user to attempt to restore the contents of the table with row security enabled. This might still fail if the user does not have the right to insert the rows from the dump into the table.</source>
          <target state="translated">仅当还原具有行安全性的表的内容时，此选项才相关。默认情况下，pg_restore会将&lt;a href=&quot;runtime-config-client#GUC-ROW-SECURITY&quot;&gt;row_security&lt;/a&gt;设置为off，以确保将所有数据还原到表中。如果用户没有足够的特权绕过行安全性，那么将引发错误。该参数指示pg_restore改为将&lt;a href=&quot;runtime-config-client#GUC-ROW-SECURITY&quot;&gt;row_security&lt;/a&gt;设置为on，从而允许用户尝试在启用行安全性的情况下还原表的内容。如果用户无权将转储中的行插入表中，这可能仍然会失败。</target>
        </trans-unit>
        <trans-unit id="669c8d507812e76e70b7a6698088435172bcb4c4" translate="yes" xml:space="preserve">
          <source>This option is required.</source>
          <target state="translated">此选项是必须的。</target>
        </trans-unit>
        <trans-unit id="e8e2f962f48b10705c69e42af3599ebbe139dded" translate="yes" xml:space="preserve">
          <source>This option is similar to, but for historical reasons not identical to, specifying &lt;code&gt;--section=data&lt;/code&gt;.</source>
          <target state="translated">此选项与 &lt;code&gt;--section=data&lt;/code&gt; 相似，但由于历史原因不同。</target>
        </trans-unit>
        <trans-unit id="fcf8c055342b65365f647de20886432a97a9fb3f" translate="yes" xml:space="preserve">
          <source>This option is the inverse of &lt;code&gt;--data-only&lt;/code&gt;. It is similar to, but for historical reasons not identical to, specifying &lt;code&gt;--section=pre-data --section=post-data&lt;/code&gt;.</source>
          <target state="translated">此选项与 &lt;code&gt;--data-only&lt;/code&gt; 相反。它与 &lt;code&gt;--section=pre-data --section=post-data&lt;/code&gt; 相似，但由于历史原因不同。</target>
        </trans-unit>
        <trans-unit id="f0ef2836d01c5b66262cf8fb0f99f24d0487c16e" translate="yes" xml:space="preserve">
          <source>This option is useful to analyze a database that was newly populated from a restored dump or by &lt;code&gt;pg_upgrade&lt;/code&gt;. This option will try to create some statistics as fast as possible, to make the database usable, and then produce full statistics in the subsequent stages.</source>
          <target state="translated">此选项对于分析从还原的转储或 &lt;code&gt;pg_upgrade&lt;/code&gt; 新填充的数据库很有用。此选项将尝试尽快创建一些统计信息，以使数据库可用，然后在后续阶段中生成完整的统​​计信息。</target>
        </trans-unit>
        <trans-unit id="077e267cb6b3ecfbfb03040a23b63baaeb817565" translate="yes" xml:space="preserve">
          <source>This option is useful when needing to synchronize the dump with a logical replication slot (see &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;) or with a concurrent session.</source>
          <target state="translated">当需要将转储与逻辑复制插槽（请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;第48章&lt;/a&gt;）或并发会话同步时，此选项很有用。</target>
        </trans-unit>
        <trans-unit id="7de6209f5a71b1972a88650d25f0745aff575b91" translate="yes" xml:space="preserve">
          <source>This option is useful when needing to synchronize the dump with a logical replication slot (see &lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;) or with a concurrent session.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3633c4f24d10d4cb48c93fba1de68cf9fa92f151" translate="yes" xml:space="preserve">
          <source>This option may not be used when the materialized view is not already populated.</source>
          <target state="translated">当物化视图尚未填充时,不可使用此选项。</target>
        </trans-unit>
        <trans-unit id="3512c53edd5cba187313504c9c38bb9bebba16b9" translate="yes" xml:space="preserve">
          <source>This option prevents the creation of a temporary replication slot during the backup even if it's supported by the server.</source>
          <target state="translated">此选项可防止在备份期间创建临时复制槽,即使服务器支持。</target>
        </trans-unit>
        <trans-unit id="a3c0cee7bd9ef9a16e32247c016aeb298ec61871" translate="yes" xml:space="preserve">
          <source>This option should be specified if the replication client of pg_receivewal is configured on the server as a synchronous standby, to ensure that timely feedback is sent to the server.</source>
          <target state="translated">如果服务器上配置了pg_receivewal的复制客户端作为同步备用,则应指定该选项,以保证及时向服务器发送反馈信息。</target>
        </trans-unit>
        <trans-unit id="3e2f9ae86d0526f44e2335b7a077c0c7bf363ea0" translate="yes" xml:space="preserve">
          <source>This option specifies the authentication method for local users via TCP/IP connections used in &lt;code&gt;pg_hba.conf&lt;/code&gt; (&lt;code&gt;host&lt;/code&gt; lines).</source>
          <target state="translated">该选项为 &lt;code&gt;pg_hba.conf&lt;/code&gt; （ &lt;code&gt;host&lt;/code&gt; 行）中使用的TCP / IP连接指定本地用户的身份验证方法。</target>
        </trans-unit>
        <trans-unit id="804c43ea411a36eef9c28b7d23a8aedda99cd7ef" translate="yes" xml:space="preserve">
          <source>This option specifies the authentication method for local users via Unix-domain socket connections used in &lt;code&gt;pg_hba.conf&lt;/code&gt; (&lt;code&gt;local&lt;/code&gt; lines).</source>
          <target state="translated">此选项为通过 &lt;code&gt;pg_hba.conf&lt;/code&gt; （ &lt;code&gt;local&lt;/code&gt; 行）中使用的Unix域套接字连接为本地用户指定身份验证方法。</target>
        </trans-unit>
        <trans-unit id="73ac8a9ea2f27acca3addec852f67d4b056e3a63" translate="yes" xml:space="preserve">
          <source>This option specifies the default authentication method for local users used in &lt;code&gt;pg_hba.conf&lt;/code&gt; (&lt;code&gt;host&lt;/code&gt; and &lt;code&gt;local&lt;/code&gt; lines). &lt;code&gt;initdb&lt;/code&gt; will prepopulate &lt;code&gt;pg_hba.conf&lt;/code&gt; entries using the specified authentication method for non-replication as well as replication connections.</source>
          <target state="translated">此选项为 &lt;code&gt;pg_hba.conf&lt;/code&gt; 中使用的本地用户（ &lt;code&gt;host&lt;/code&gt; 和 &lt;code&gt;local&lt;/code&gt; 行）指定默认的身份验证方法。对于非复制以及复制连接， &lt;code&gt;initdb&lt;/code&gt; 将使用指定的身份验证方法预填充 &lt;code&gt;pg_hba.conf&lt;/code&gt; 条目。</target>
        </trans-unit>
        <trans-unit id="33880c0202e463453735147893fedee96072b505" translate="yes" xml:space="preserve">
          <source>This option specifies the directory where the database cluster should be stored. This is the only information required by &lt;code&gt;initdb&lt;/code&gt;, but you can avoid writing it by setting the &lt;code&gt;PGDATA&lt;/code&gt; environment variable, which can be convenient since the database server (&lt;code&gt;postgres&lt;/code&gt;) can find the database directory later by the same variable.</source>
          <target state="translated">此选项指定数据库集群应存储的目录。这是 &lt;code&gt;initdb&lt;/code&gt; 唯一需要的信息，但是您可以通过设置 &lt;code&gt;PGDATA&lt;/code&gt; 环境变量来避免编写该信息，这很方便，因为数据库服务器（ &lt;code&gt;postgres&lt;/code&gt; ）以后可以通过相同的变量查找数据库目录。</target>
        </trans-unit>
        <trans-unit id="2481fe81f534e308eab6b927c279c7c516c6f6c9" translate="yes" xml:space="preserve">
          <source>This option specifies the directory where the write-ahead log should be stored.</source>
          <target state="translated">这个选项指定了存储写前日志的目录。</target>
        </trans-unit>
        <trans-unit id="e5ab029306c7aba204799ea5d9a25ae6a49ed455" translate="yes" xml:space="preserve">
          <source>This option specifies the number of rows &lt;code&gt;postgres_fdw&lt;/code&gt; should get in each fetch operation. It can be specified for a foreign table or a foreign server. The option specified on a table overrides an option specified for the server. The default is &lt;code&gt;100&lt;/code&gt;.</source>
          <target state="translated">此选项指定 &lt;code&gt;postgres_fdw&lt;/code&gt; 在每个提取操作中应获得的行数。可以为外部表或外部服务器指定它。在表上指定的选项将覆盖为服务器指定的选项。默认值为 &lt;code&gt;100&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="647df7560822159475f98885467e55eb675890f8" translate="yes" xml:space="preserve">
          <source>This option specifies the target data directory that is synchronized with the source. The target server must be shut down cleanly before running pg_rewind</source>
          <target state="translated">这个选项指定了与源服务器同步的目标数据目录。在运行pg_rewind之前,目标服务器必须被干净地关闭。</target>
        </trans-unit>
        <trans-unit id="ff01b505d4bc957630a4ef6552d6b1f3f78071f5" translate="yes" xml:space="preserve">
          <source>This option specifies whether the final function is a pure function that does not modify its arguments. &lt;code&gt;READ_ONLY&lt;/code&gt; indicates it does not; the other two values indicate that it may change the transition state value. See &lt;a href=&quot;sql-createaggregate#SQL-CREATEAGGREGATE-NOTES&quot;&gt;Notes&lt;/a&gt; below for more detail. The default is &lt;code&gt;READ_ONLY&lt;/code&gt;, except for ordered-set aggregates, for which the default is &lt;code&gt;READ_WRITE&lt;/code&gt;.</source>
          <target state="translated">此选项指定最终函数是否为不修改其参数的纯函数。 &lt;code&gt;READ_ONLY&lt;/code&gt; 表示没有；其他两个值表示它可能会更改过渡状态值。有关更多详细信息，请参见下面的&lt;a href=&quot;sql-createaggregate#SQL-CREATEAGGREGATE-NOTES&quot;&gt;注释&lt;/a&gt;。缺省值为 &lt;code&gt;READ_ONLY&lt;/code&gt; ，有序集合除外，缺省值为 &lt;code&gt;READ_WRITE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a7f68a96aa921444e2d40ac76a43185ab6a9f312" translate="yes" xml:space="preserve">
          <source>This option will make no difference if there are no read-write transactions active when pg_dump is started. If read-write transactions are active, the start of the dump may be delayed for an indeterminate length of time. Once running, performance with or without the switch is the same.</source>
          <target state="translated">如果pg_dump启动时没有读写事务,这个选项没有任何区别。如果读写事务是活动的,那么转储的启动可能会被延迟一段不确定的时间。一旦运行,有无切换的性能是一样的。</target>
        </trans-unit>
        <trans-unit id="a1a6fd10746c87d481fd1e3f7d6dfee998b43bb9" translate="yes" xml:space="preserve">
          <source>This option, which can be specified for a column of a foreign table, gives the column name to use for the column on the remote server. If this option is omitted, the column's name is used.</source>
          <target state="translated">这个选项可以为外表的一列指定,它给出了远程服务器上该列要使用的列名。如果省略这个选项,则使用列名。</target>
        </trans-unit>
        <trans-unit id="4af1de2d1bcdacfc86aa091d4dc53d1aa115b546" translate="yes" xml:space="preserve">
          <source>This option, which can be specified for a foreign server, is a numeric value that is added to the estimated startup cost of any foreign-table scan on that server. This represents the additional overhead of establishing a connection, parsing and planning the query on the remote side, etc. The default value is &lt;code&gt;100&lt;/code&gt;.</source>
          <target state="translated">可以为外部服务器指定的此选项是一个数字值，该值被添加到该服务器上任何外部表扫描的估计启动成本中。这表示建立连接，在远程侧解析和计划查询等的额外开销。默认值为 &lt;code&gt;100&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca3fd60b70e15baee78bd32e8d43582b1c2df725" translate="yes" xml:space="preserve">
          <source>This option, which can be specified for a foreign server, is a numeric value that is used as extra cost per-tuple for foreign-table scans on that server. This represents the additional overhead of data transfer between servers. You might increase or decrease this number to reflect higher or lower network delay to the remote server. The default value is &lt;code&gt;0.01&lt;/code&gt;.</source>
          <target state="translated">可以为外部服务器指定的此选项是一个数值，用作该服务器上的外部表扫描的每元组额外费用。这代表了服务器之间数据传输的额外开销。您可以增加或减少此数字，以反映远程服务器的较高或较低的网络延迟。默认值为 &lt;code&gt;0.01&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6db445412c679c14afee682db0f908555cd61891" translate="yes" xml:space="preserve">
          <source>This option, which can be specified for a foreign table or a foreign server, controls whether &lt;code&gt;postgres_fdw&lt;/code&gt; issues remote &lt;code&gt;EXPLAIN&lt;/code&gt; commands to obtain cost estimates. A setting for a foreign table overrides any setting for its server, but only for that table. The default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">可以为外部表或外部服务器指定此选项，它控制 &lt;code&gt;postgres_fdw&lt;/code&gt; 是否发出远程 &lt;code&gt;EXPLAIN&lt;/code&gt; 命令以获得成本估算。外部表的设置会覆盖其服务器的所有设置，但仅适用于该表。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b3bc87c793b518f8cb8ef921546c45361e5e8ae" translate="yes" xml:space="preserve">
          <source>This option, which can be specified for a foreign table, gives the schema name to use for the foreign table on the remote server. If this option is omitted, the name of the foreign table's schema is used.</source>
          <target state="translated">这个选项可以为外表指定,它给出了远程服务器上的外表要使用的模式名称。如果省略此选项,则使用外表的模式名称。</target>
        </trans-unit>
        <trans-unit id="f9bf0730e389ac20110b162cce98c39dc1dadc6b" translate="yes" xml:space="preserve">
          <source>This option, which can be specified for a foreign table, gives the table name to use for the foreign table on the remote server. If this option is omitted, the foreign table's name is used.</source>
          <target state="translated">这个选项可以为外表指定,它给出了远程服务器上的外表要使用的表名。如果省略此选项,则使用外表的名称。</target>
        </trans-unit>
        <trans-unit id="03ad95dc874ed74ab0a774486c7f7e813aede7b9" translate="yes" xml:space="preserve">
          <source>This optional clause specifies the table access method to use to store the contents for the new materialized view; the method needs be an access method of type &lt;code&gt;TABLE&lt;/code&gt;. See &lt;a href=&quot;tableam&quot;&gt;Chapter 60&lt;/a&gt; for more information. If this option is not specified, the default table access method is chosen for the new materialized view. See &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLE-ACCESS-METHOD&quot;&gt;default_table_access_method&lt;/a&gt; for more information.</source>
          <target state="translated">此可选子句指定用于存储新实例化视图内容的表访问方法；该方法必须是 &lt;code&gt;TABLE&lt;/code&gt; 类型的访问方法。有关更多信息，请参见&lt;a href=&quot;tableam&quot;&gt;第60章&lt;/a&gt;。如果未指定此选项，则为新的实例化视图选择默认的表访问方法。有关更多信息，请参见&lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLE-ACCESS-METHOD&quot;&gt;default_table_access_method&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="55edaedc2635dc462befb01330512122e702699e" translate="yes" xml:space="preserve">
          <source>This optional clause specifies the table access method to use to store the contents for the new table; the method needs be an access method of type &lt;code&gt;TABLE&lt;/code&gt;. See &lt;a href=&quot;tableam&quot;&gt;Chapter 60&lt;/a&gt; for more information. If this option is not specified, the default table access method is chosen for the new table. See &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLE-ACCESS-METHOD&quot;&gt;default_table_access_method&lt;/a&gt; for more information.</source>
          <target state="translated">这个可选的子句指定用于存储新表内容的表访问方法。该方法必须是 &lt;code&gt;TABLE&lt;/code&gt; 类型的访问方法。有关更多信息，请参见&lt;a href=&quot;tableam&quot;&gt;第60章&lt;/a&gt;。如果未指定此选项，则为新表选择默认的表访问方法。有关更多信息，请参见&lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLE-ACCESS-METHOD&quot;&gt;default_table_access_method&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1d07ee1bbba1bc08763833fec13cc7baed7c30f7" translate="yes" xml:space="preserve">
          <source>This optional parameter specifies a shell command that will be executed at every restartpoint. The purpose of &lt;code&gt;archive_cleanup_command&lt;/code&gt; is to provide a mechanism for cleaning up old archived WAL files that are no longer needed by the standby server. Any &lt;code&gt;%r&lt;/code&gt; is replaced by the name of the file containing the last valid restart point. That is the earliest file that must be &lt;em&gt;kept&lt;/em&gt; to allow a restore to be restartable, and so all files earlier than &lt;code&gt;%r&lt;/code&gt; may be safely removed. This information can be used to truncate the archive to just the minimum required to support restart from the current restore. The &lt;a href=&quot;pgarchivecleanup&quot;&gt;pg_archivecleanup&lt;/a&gt; module is often used in &lt;code&gt;archive_cleanup_command&lt;/code&gt; for single-standby configurations, for example:</source>
          <target state="translated">此可选参数指定将在每个重新启动点执行的shell命令。 &lt;code&gt;archive_cleanup_command&lt;/code&gt; 的目的是提供一种机制来清理备用服务器不再需要的旧的已归档WAL文件。任何 &lt;code&gt;%r&lt;/code&gt; 都将替换为包含最后一个有效重启点的文件名。这是必须&lt;em&gt;保留&lt;/em&gt;的最早的文件，以使还原可重新启动，因此可以安全地删除 &lt;code&gt;%r&lt;/code&gt; 之前的所有文件。此信息可用于将归档文件截断为仅支持从当前还原中重新启动所需的最小值。所述&lt;a href=&quot;pgarchivecleanup&quot;&gt;pg_archivecleanup&lt;/a&gt;模块通常用于 &lt;code&gt;archive_cleanup_command&lt;/code&gt; 对于单待机配置，例如：</target>
        </trans-unit>
        <trans-unit id="a1986f363d2c74bd434d8d6240e4cfb3cd3d030a" translate="yes" xml:space="preserve">
          <source>This overrides &lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-DURATION-SAMPLE&quot;&gt;log_min_duration_sample&lt;/a&gt;, meaning that queries with duration exceeding this setting are not subject to sampling and are always logged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a73490037361c0f29250fb41ec57cf1fa01ef705" translate="yes" xml:space="preserve">
          <source>This package has applications to astronomical databases as well. Astronomers will probably want to change &lt;code&gt;earth()&lt;/code&gt; to return a radius of &lt;code&gt;180/pi()&lt;/code&gt; so that distances are in degrees.</source>
          <target state="translated">该软件包也适用于天文数据库。天文学家可能希望更改 &lt;code&gt;earth()&lt;/code&gt; 以返回 &lt;code&gt;180/pi()&lt;/code&gt; 的半径，以使距离以度为单位。</target>
        </trans-unit>
        <trans-unit id="ccbc9227762cc1b1b338f8650f8f4de4947b9bb4" translate="yes" xml:space="preserve">
          <source>This page describes usage of cursors at the SQL command level. If you are trying to use cursors inside a PL/pgSQL function, the rules are different &amp;mdash; see &lt;a href=&quot;https://www.postgresql.org/docs/12/plpgsql-cursors.html&quot;&gt;Section 42.7&lt;/a&gt;.</source>
          <target state="translated">本页在SQL命令级别描述游标的用法。如果您尝试在PL / pgSQL函数中使用游标，则规则有所不同-请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/plpgsql-cursors.html&quot;&gt;第42.7节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="56562eeab71ceb4b4deb48e8b0753e859819b0d5" translate="yes" xml:space="preserve">
          <source>This page describes usage of cursors at the SQL command level. If you are trying to use cursors inside a PL/pgSQL function, the rules are different &amp;mdash; see &lt;a href=&quot;https://www.postgresql.org/docs/12/plpgsql-cursors.html#PLPGSQL-CURSOR-USING&quot;&gt;Section 42.7.3&lt;/a&gt;.</source>
          <target state="translated">本页在SQL命令级别描述游标的用法。如果您尝试在PL / pgSQL函数中使用游标，则规则有所不同-请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/plpgsql-cursors.html#PLPGSQL-CURSOR-USING&quot;&gt;第42.7.3节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="547b9cb1aa4d24d0c574063f39b87dc0659b1ba0" translate="yes" xml:space="preserve">
          <source>This page describes usage of cursors at the SQL command level. If you are trying to use cursors inside a PL/pgSQL function, the rules are different &amp;mdash; see &lt;a href=&quot;https://www.postgresql.org/docs/13/plpgsql-cursors.html&quot;&gt;Section 42.7&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4868f00986f7826fff46f8caaf65132226af2073" translate="yes" xml:space="preserve">
          <source>This page describes usage of cursors at the SQL command level. If you are trying to use cursors inside a PL/pgSQL function, the rules are different &amp;mdash; see &lt;a href=&quot;https://www.postgresql.org/docs/13/plpgsql-cursors.html#PLPGSQL-CURSOR-USING&quot;&gt;Section 42.7.3&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f12b1cf7624fdc2fc587dd45a6d547cd93a31157" translate="yes" xml:space="preserve">
          <source>This parameter adjusts the number of digits used for textual output of floating-point values, including &lt;code&gt;float4&lt;/code&gt;, &lt;code&gt;float8&lt;/code&gt;, and geometric data types.</source>
          <target state="translated">此参数调整的用于浮点值的文本输出，包括数字的数 &lt;code&gt;float4&lt;/code&gt; ， &lt;code&gt;float8&lt;/code&gt; ，和几何数据类型。</target>
        </trans-unit>
        <trans-unit id="2c8c19d46b2082ce8ad9cb949c44fbf4a9d2bc51" translate="yes" xml:space="preserve">
          <source>This parameter can be changed at any time; the behavior for any one transaction is determined by the setting in effect when it commits. It is therefore possible, and useful, to have some transactions commit synchronously and others asynchronously. For example, to make a single multistatement transaction commit asynchronously when the default is the opposite, issue &lt;code&gt;SET LOCAL synchronous_commit TO OFF&lt;/code&gt; within the transaction.</source>
          <target state="translated">该参数可以随时更改。任何一项事务的行为都由提交时生效的设置决定。因此，使某些事务同步提交而其他事务异步提交是可能且有用的。例如，要使单个多语句事务在缺省值相反时异步提交，请在事务内发出 &lt;code&gt;SET LOCAL synchronous_commit TO OFF&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c374abd82fae67b6ad47305ef8df0f9c2c332166" translate="yes" xml:space="preserve">
          <source>This parameter can be changed at run time by superusers, but a setting done that way will only persist until the end of the client connection, so this method should be reserved for development purposes. The recommended way to set this parameter is in the &lt;code&gt;postgresql.conf&lt;/code&gt; configuration file.</source>
          <target state="translated">超级用户可以在运行时更改此参数，但是以这种方式进行的设置将一直保留到客户端连接结束，因此应保留此方法用于开发目的。推荐的设置此参数的方法是在 &lt;code&gt;postgresql.conf&lt;/code&gt; 配置文件中。</target>
        </trans-unit>
        <trans-unit id="fb2aeee56cb3f5ebc1b1a01c4c8dad28553fc839" translate="yes" xml:space="preserve">
          <source>This parameter can only be set at server start.</source>
          <target state="translated">此参数只能在服务器启动时设置。</target>
        </trans-unit>
        <trans-unit id="548ece31c9a5607a8e7aaa0cea1df9acffd23d07" translate="yes" xml:space="preserve">
          <source>This parameter can only be set at server start. The default value is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">该参数只能在服务器启动时设置。默认值是 &lt;code&gt;off&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3c2e150a470aea3c7b743c7181598f9938b94089" translate="yes" xml:space="preserve">
          <source>This parameter can only be set at server start. This setting has no effect if the server is not in standby mode.</source>
          <target state="translated">此参数只能在服务器启动时设置。如果服务器不在待机模式下,此设置没有效果。</target>
        </trans-unit>
        <trans-unit id="01ece1ab64d1d476c41b0db27bab26dffaa5d23d" translate="yes" xml:space="preserve">
          <source>This parameter can only be set by superusers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aea2a5594193af5a590a3ea36df84b74060812a5" translate="yes" xml:space="preserve">
          <source>This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">此参数只能在 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件或服务器命令行中设置。</target>
        </trans-unit>
        <trans-unit id="fcd4c1beac4f16c5f89019faf29b34c84fa4d317" translate="yes" xml:space="preserve">
          <source>This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. If this parameter is changed while the WAL receiver process is running, that process is signaled to shut down and expected to restart with the new setting (except if &lt;code&gt;primary_conninfo&lt;/code&gt; is an empty string). This setting has no effect if the server is not in standby mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc5df5bbc83b51e3d05d700128363b10537046bc" translate="yes" xml:space="preserve">
          <source>This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. It is ignored unless &lt;code&gt;archive_mode&lt;/code&gt; was enabled at server start. If &lt;code&gt;archive_command&lt;/code&gt; is an empty string (the default) while &lt;code&gt;archive_mode&lt;/code&gt; is enabled, WAL archiving is temporarily disabled, but the server continues to accumulate WAL segment files in the expectation that a command will soon be provided. Setting &lt;code&gt;archive_command&lt;/code&gt; to a command that does nothing but return true, e.g. &lt;code&gt;/bin/true&lt;/code&gt; (&lt;code&gt;REM&lt;/code&gt; on Windows), effectively disables archiving, but also breaks the chain of WAL files needed for archive recovery, so it should only be used in unusual circumstances.</source>
          <target state="translated">此参数只能在 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件或服务器命令行中设置。除非在服务器启动时启用了 &lt;code&gt;archive_mode&lt;/code&gt; ，否则它将被忽略。如果在启用 &lt;code&gt;archive_mode&lt;/code&gt; 的情况下 &lt;code&gt;archive_command&lt;/code&gt; 是空字符串（默认值），则将暂时禁用WAL归档，但是服务器将继续累积WAL段文件，以期将很快提供命令。将 &lt;code&gt;archive_command&lt;/code&gt; 设置为除了返回true之外什么都不做的命令，例如 &lt;code&gt;/bin/true&lt;/code&gt; （在Windows上为 &lt;code&gt;REM&lt;/code&gt; ），可以有效地禁用归档，但也会破坏归档恢复所需的WAL文件链，因此仅应在特殊情况下使用。</target>
        </trans-unit>
        <trans-unit id="c874dee97d89cfa2b94fc70ed86e608ff9b3dc48" translate="yes" xml:space="preserve">
          <source>This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. It is ignored unless &lt;code&gt;archive_mode&lt;/code&gt; was enabled at server start. If &lt;code&gt;archive_command&lt;/code&gt; is an empty string (the default) while &lt;code&gt;archive_mode&lt;/code&gt; is enabled, WAL archiving is temporarily disabled, but the server continues to accumulate WAL segment files in the expectation that a command will soon be provided. Setting &lt;code&gt;archive_command&lt;/code&gt; to a command that does nothing but return true, e.g., &lt;code&gt;/bin/true&lt;/code&gt; (&lt;code&gt;REM&lt;/code&gt; on Windows), effectively disables archiving, but also breaks the chain of WAL files needed for archive recovery, so it should only be used in unusual circumstances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0a1a0889c9528b4413a436f9a00fb8ec805219f" translate="yes" xml:space="preserve">
          <source>This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. The default is &lt;code&gt;'%m [%p] '&lt;/code&gt; which logs a time stamp and the process ID.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e07235f8bb7f2137e8d29b1c48712e024bfd7c79" translate="yes" xml:space="preserve">
          <source>This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">此参数只能在 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件或服务器命令行中设置。默认值为 &lt;code&gt;on&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb9c9e485e73ed5f7ad6e8a64043056d9f542ea8" translate="yes" xml:space="preserve">
          <source>This parameter contains a comma-separated list of C function names. If an error is raised and the name of the internal C function where the error happens matches a value in the list, then a backtrace is written to the server log together with the error message. This can be used to debug specific areas of the source code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab121fa8e3ea34fd830e0e6103b67d7f977831b1" translate="yes" xml:space="preserve">
          <source>This parameter controls the default deferrable status of each new transaction. It currently has no effect on read-write transactions or those operating at isolation levels lower than &lt;code&gt;serializable&lt;/code&gt;. The default is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">此参数控制每个新事务的默认可延期状态。目前，它对读写事务或隔离级别低于可 &lt;code&gt;serializable&lt;/code&gt; 事务没有影响。默认为 &lt;code&gt;off&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="86c77e7afe5c211d78ef603e06178e261dcf6c72" translate="yes" xml:space="preserve">
          <source>This parameter determines whether changes in a partitioned table (or on its partitions) contained in the publication will be published using the identity and schema of the partitioned table rather than that of the individual partitions that are actually changed; the latter is the default. Enabling this allows the changes to be replicated into a non-partitioned table or a partitioned table consisting of a different set of partitions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4b6ea430b61a904ec5971253ee54b2fa2eddfa5" translate="yes" xml:space="preserve">
          <source>This parameter determines whether the passphrase command set by &lt;code&gt;ssl_passphrase_command&lt;/code&gt; will also be called during a configuration reload if a key file needs a passphrase. If this parameter is off (the default), then &lt;code&gt;ssl_passphrase_command&lt;/code&gt; will be ignored during a reload and the SSL configuration will not be reloaded if a passphrase is needed. That setting is appropriate for a command that requires a TTY for prompting, which might not be available when the server is running. Setting this parameter to on might be appropriate if the passphrase is obtained from a file, for example.</source>
          <target state="translated">此参数确定是否在密钥文件需要密码短语的情况下在配置重载期间调用由 &lt;code&gt;ssl_passphrase_command&lt;/code&gt; 设置的密码短语命令。如果关闭此参数（默认设置），则在重新加载期间 &lt;code&gt;ssl_passphrase_command&lt;/code&gt; 将被忽略，并且如果需要密码，则不会重新加载SSL配置。该设置适用于需要TTY提示的命令，该命令在服务器运行时可能不可用。例如，如果从文件中获取密码，则将此参数设置为on可能是合适的。</target>
        </trans-unit>
        <trans-unit id="d4f4eed730ec55ccc4eaff2dacaa08b0b2fcb82f" translate="yes" xml:space="preserve">
          <source>This parameter determines which DML operations will be published by the new publication to the subscribers. The value is comma-separated list of operations. The allowed operations are &lt;code&gt;insert&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt;, and &lt;code&gt;truncate&lt;/code&gt;. The default is to publish all actions, and so the default value for this option is &lt;code&gt;'insert, update, delete, truncate'&lt;/code&gt;.</source>
          <target state="translated">此参数确定新发布将向订阅者发布哪些DML操作。该值是逗号分隔的操作列表。允许的操作是 &lt;code&gt;insert&lt;/code&gt; ， &lt;code&gt;update&lt;/code&gt; ， &lt;code&gt;delete&lt;/code&gt; 和 &lt;code&gt;truncate&lt;/code&gt; 。默认值为发布所有操作，因此此选项的默认值为 &lt;code&gt;'insert, update, delete, truncate'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c366805ffcbad04565bd73b6d69694df15ae916" translate="yes" xml:space="preserve">
          <source>This parameter enables &lt;code&gt;sepgsql&lt;/code&gt; to function in permissive mode, regardless of the system setting. The default is off. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">无论系统设置如何，此参数 &lt;code&gt;sepgsql&lt;/code&gt; 使sepgsql在许可模式下运行。默认为关闭。此参数只能在 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件或服务器命令行中设置。</target>
        </trans-unit>
        <trans-unit id="a8293e99f1916de3cd3eb1e1f2ed9f1e458fe46c" translate="yes" xml:space="preserve">
          <source>This parameter enables per-database user names. It is off by default. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">此参数启用每个数据库的用户名。默认情况下它是关闭的。此参数只能在 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件或服务器命令行中设置。</target>
        </trans-unit>
        <trans-unit id="5f5fcb1a1b2c04d28c8162ce15f61ea3ecacd8ad" translate="yes" xml:space="preserve">
          <source>This parameter enables the &lt;em&gt;logging collector&lt;/em&gt;, which is a background process that captures log messages sent to stderr and redirects them into log files. This approach is often more useful than logging to syslog, since some types of messages might not appear in syslog output. (One common example is dynamic-linker failure messages; another is error messages produced by scripts such as &lt;code&gt;archive_command&lt;/code&gt;.) This parameter can only be set at server start.</source>
          <target state="translated">此参数启用&lt;em&gt;日志收集器&lt;/em&gt;，这是一个后台进程，用于捕获发送到stderr的日志消息并将其重定向到日志文件中。这种方法通常比登录syslog更有用，因为某些类型的消息可能不会出现在syslog输出中。（一个常见的示例是动态链接器失败消息；另一个是由诸如 &lt;code&gt;archive_command&lt;/code&gt; 之类的脚本产生的错误消息。）只能在服务器启动时设置此参数。</target>
        </trans-unit>
        <trans-unit id="5b0de510e67bd8744ec5eabde4b996ce5f2b54bc" translate="yes" xml:space="preserve">
          <source>This parameter enables the printing of audit messages regardless of the system policy settings. The default is off, which means that messages will be printed according to the system settings.</source>
          <target state="translated">此参数可以不考虑系统策略设置,打印审计信息,默认为关闭,即根据系统设置打印信息。默认值为关闭,这意味着将根据系统设置打印消息。</target>
        </trans-unit>
        <trans-unit id="38b076e09722f67dcc2931b6f7d49ce3816bbff6" translate="yes" xml:space="preserve">
          <source>This parameter forces all possible logging to be turned on, regardless of the system policy.</source>
          <target state="translated">此参数强制开启所有可能的日志记录,无论系统策略如何。</target>
        </trans-unit>
        <trans-unit id="5b77a5363fdf0aac9e0a3daf60d7960abab567a4" translate="yes" xml:space="preserve">
          <source>This parameter is intended for use with streaming replication deployments; however, if the parameter is specified it will be honored in all cases except crash recovery. &lt;code&gt;hot_standby_feedback&lt;/code&gt; will be delayed by use of this feature which could lead to bloat on the master; use both together with care.</source>
          <target state="translated">此参数适用于流复制部署；但是，如果指定了该参数，则在崩溃恢复以外的所有情况下都将使用该参数。使用此功能将延迟 &lt;code&gt;hot_standby_feedback&lt;/code&gt; ，这可能会导致主服务器膨胀。谨慎使用。</target>
        </trans-unit>
        <trans-unit id="9661b0520a182dcd9a1573ee14abaaf7af72f4ef" translate="yes" xml:space="preserve">
          <source>This parameter is intended to be used to check for bugs in the WAL redo routines. When enabled, full-page images of any buffers modified in conjunction with the WAL record are added to the record. If the record is subsequently replayed, the system will first apply each record and then test whether the buffers modified by the record match the stored images. In certain cases (such as hint bits), minor variations are acceptable, and will be ignored. Any unexpected differences will result in a fatal error, terminating recovery.</source>
          <target state="translated">这个参数是用来检查WAL重做例程中的错误。当启用时,与WAL记录一起修改的任何缓冲区的全页图像都会添加到记录中。如果该记录随后被重播,系统将首先应用每个记录,然后测试被记录修改的缓冲区是否与存储的图像匹配。在某些情况下(如提示位),轻微的变化是可以接受的,并将被忽略。任何意外的差异都会导致致命的错误,终止恢复。</target>
        </trans-unit>
        <trans-unit id="79e45ac588c210513ee2f2dfb89a49d85d30136b" translate="yes" xml:space="preserve">
          <source>This parameter is irrelevant on Windows, which does not have Unix-domain sockets.</source>
          <target state="translated">这个参数与Windows无关,因为Windows没有Unix-domain套接字。</target>
        </trans-unit>
        <trans-unit id="1f6a521703b967c04e55a5a7440712a5d7f90432" translate="yes" xml:space="preserve">
          <source>This parameter is irrelevant on systems, notably Solaris as of Solaris 10, that ignore socket permissions entirely. There, one can achieve a similar effect by pointing &lt;code&gt;unix_socket_directories&lt;/code&gt; to a directory having search permission limited to the desired audience.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d64ae81fa444da28c76340e9acb4f864a787cd0" translate="yes" xml:space="preserve">
          <source>This parameter is irrelevant on systems, notably Solaris as of Solaris 10, that ignore socket permissions entirely. There, one can achieve a similar effect by pointing &lt;code&gt;unix_socket_directories&lt;/code&gt; to a directory having search permission limited to the desired audience. This parameter is also irrelevant on Windows, which does not have Unix-domain sockets.</source>
          <target state="translated">此参数与完全忽略套接字许可权的系统（尤其是Solaris 10或更高版本的Solaris）无关。在那里，通过将 &lt;code&gt;unix_socket_directories&lt;/code&gt; 指向具有仅限于所需受众的搜索权限的目录，可以达到类似的效果。在没有Unix域套接字的Windows上，该参数也无关紧要。</target>
        </trans-unit>
        <trans-unit id="3dd094f0736aa3ae7edd4ff5cd79706a00b54ce9" translate="yes" xml:space="preserve">
          <source>This parameter is normally on. When set to &lt;code&gt;off&lt;/code&gt;, it disables validation of the function body string during &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;. Disabling validation avoids side effects of the validation process and avoids false positives due to problems such as forward references. Set this parameter to &lt;code&gt;off&lt;/code&gt; before loading functions on behalf of other users; pg_dump does so automatically.</source>
          <target state="translated">此参数通常是打开的。设置为 &lt;code&gt;off&lt;/code&gt; 时，它将在&lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;期间禁用对函数体字符串的验证。禁用验证可避免验证过程的副作用，并避免由于诸如前向引用之类的问题而导致误报。在代表其他用户加载功能之前，请将此参数设置为 &lt;code&gt;off&lt;/code&gt; 。pg_dump会自动这样做。</target>
        </trans-unit>
        <trans-unit id="757f13945c2c0187d0950790cc03fde26586d7a4" translate="yes" xml:space="preserve">
          <source>This parameter is not supported on Windows, and must be zero.</source>
          <target state="translated">此参数在Windows上不支持,必须为零。</target>
        </trans-unit>
        <trans-unit id="de5a8a2ca644671b2bea31a3c7534d0ee40e2165" translate="yes" xml:space="preserve">
          <source>This parameter is not supported on Windows. Any setting will be ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2763e8b9da5e6a86b4f3be45fa54afbb6338381" translate="yes" xml:space="preserve">
          <source>This parameter is only available if the &lt;code&gt;BTREE_BUILD_STATS&lt;/code&gt; macro was defined when PostgreSQL was compiled.</source>
          <target state="translated">仅当编译PostgreSQL时定义了 &lt;code&gt;BTREE_BUILD_STATS&lt;/code&gt; 宏时，此参数才可用。</target>
        </trans-unit>
        <trans-unit id="c80b12aeb2b9de43621c9a7ca80fead69181cd4d" translate="yes" xml:space="preserve">
          <source>This parameter is only available if the &lt;code&gt;LOCK_DEBUG&lt;/code&gt; macro was defined when PostgreSQL was compiled.</source>
          <target state="translated">仅当在编译PostgreSQL时定义了 &lt;code&gt;LOCK_DEBUG&lt;/code&gt; 宏时，此参数才可用。</target>
        </trans-unit>
        <trans-unit id="5c8a9b81edbcb0f5ee50f2aa2c3229e2b238c0d5" translate="yes" xml:space="preserve">
          <source>This parameter is required.</source>
          <target state="translated">此参数为必填项。</target>
        </trans-unit>
        <trans-unit id="230b46508e1bcacd6e7909740fdc39adfae605d5" translate="yes" xml:space="preserve">
          <source>This parameter is useful in configurations where a node in recovery needs to control the amount of time to wait for new WAL data to be available. For example, in archive recovery, it is possible to make the recovery more responsive in the detection of a new WAL log file by reducing the value of this parameter. On a system with low WAL activity, increasing it reduces the amount of requests necessary to access WAL archives, something useful for example in cloud environments where the amount of times an infrastructure is accessed is taken into account.</source>
          <target state="translated">该参数在配置中很有用,在这些配置中,恢复中的节点需要控制等待新WAL数据的时间。例如,在归档恢复中,通过降低该参数的值,可以使恢复在检测到新的WAL日志文件时反应更加迅速。在WAL活动较少的系统中,增加该参数可减少访问WAL存档所需的请求量,这在考虑基础设施被访问次数的云环境中非常有用。</target>
        </trans-unit>
        <trans-unit id="60b8dda68ddec78bdd153122213269123706aba2" translate="yes" xml:space="preserve">
          <source>This parameter may be either &lt;code&gt;local&lt;/code&gt; or &lt;code&gt;cascaded&lt;/code&gt;, and is equivalent to specifying &lt;code&gt;WITH [ CASCADED | LOCAL ] CHECK OPTION&lt;/code&gt; (see below). This option can be changed on existing views using &lt;a href=&quot;sql-alterview&quot;&gt;ALTER VIEW&lt;/a&gt;.</source>
          <target state="translated">该参数可以是 &lt;code&gt;local&lt;/code&gt; 或 &lt;code&gt;cascaded&lt;/code&gt; ，并且相当于指定 &lt;code&gt;WITH [ CASCADED | LOCAL ] CHECK OPTION&lt;/code&gt; （请参阅下文）。可以使用&lt;a href=&quot;sql-alterview&quot;&gt;ALTER VIEW&lt;/a&gt;在现有视图上更改此选项。</target>
        </trans-unit>
        <trans-unit id="e8076b1a53637e369327b419272c25be1f35d885" translate="yes" xml:space="preserve">
          <source>This parameter specifies a list of standby servers using either of the following syntaxes:</source>
          <target state="translated">该参数使用以下任一语法指定备用服务器的列表。</target>
        </trans-unit>
        <trans-unit id="e3119205c74e3feadc21f1edb96559651e07399f" translate="yes" xml:space="preserve">
          <source>This parameter specifies a shell command that will be executed once only at the end of recovery. This parameter is optional. The purpose of the &lt;code&gt;recovery_end_command&lt;/code&gt; is to provide a mechanism for cleanup following replication or recovery. Any &lt;code&gt;%r&lt;/code&gt; is replaced by the name of the file containing the last valid restart point, like in &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-CLEANUP-COMMAND&quot;&gt;archive_cleanup_command&lt;/a&gt;.</source>
          <target state="translated">此参数指定将仅在恢复结束时执行一次的Shell命令。此参数是可选的。 &lt;code&gt;recovery_end_command&lt;/code&gt; 的目的是提供一种在复制或恢复后进行清理的机制。任何 &lt;code&gt;%r&lt;/code&gt; 都将替换为包含最后一个有效重启点的文件的名称，例如&lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-CLEANUP-COMMAND&quot;&gt;archive_cleanup_command&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cc3d884be2df2669703142223fbc549ce1860529" translate="yes" xml:space="preserve">
          <source>This parameter specifies that recovery should end as soon as a consistent state is reached, i.e. as early as possible. When restoring from an online backup, this means the point where taking the backup ended.</source>
          <target state="translated">此参数指定恢复应在达到一致状态后尽快结束,即尽早结束。从在线备份恢复时,指的是备份结束的时间点。</target>
        </trans-unit>
        <trans-unit id="4aaac74b096ffa8fd2b689ffdb61db6bf8bb5409" translate="yes" xml:space="preserve">
          <source>This parameter specifies that recovery should end as soon as a consistent state is reached, i.e., as early as possible. When restoring from an online backup, this means the point where taking the backup ended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="038ead23d053aaeb92ffc414e5b17ac7f1401e33" translate="yes" xml:space="preserve">
          <source>This parameter specifies the LSN of the write-ahead log location up to which recovery will proceed. The precise stopping point is also influenced by &lt;a href=&quot;runtime-config-wal#GUC-RECOVERY-TARGET-INCLUSIVE&quot;&gt;recovery_target_inclusive&lt;/a&gt;. This parameter is parsed using the system data type &lt;a href=&quot;datatype-pg-lsn&quot;&gt;&lt;code&gt;pg_lsn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此参数指定将继续进行恢复的预写日志位置的LSN。精确的停止点还受&lt;a href=&quot;runtime-config-wal#GUC-RECOVERY-TARGET-INCLUSIVE&quot;&gt;recovery_target_inclusive的&lt;/a&gt;影响。使用系统数据类型&lt;a href=&quot;datatype-pg-lsn&quot;&gt; &lt;code&gt;pg_lsn&lt;/code&gt; &lt;/a&gt;解析此参数。</target>
        </trans-unit>
        <trans-unit id="efffdc4221077284f352653adef6ab331dce1918" translate="yes" xml:space="preserve">
          <source>This parameter specifies the default table access method to use when creating tables or materialized views if the &lt;code&gt;CREATE&lt;/code&gt; command does not explicitly specify an access method, or when &lt;code&gt;SELECT ... INTO&lt;/code&gt; is used, which does not allow to specify a table access method. The default is &lt;code&gt;heap&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;CREATE&lt;/code&gt; 命令没有显式指定访问方法，或者使用 &lt;code&gt;SELECT ... INTO&lt;/code&gt; 不允许指定表访问方法，则此参数指定在创建表或实例化视图时要使用的默认表访问方法。默认值为 &lt;code&gt;heap&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5eccd6d9a8a05839ca4090c77807db10a5ab201b" translate="yes" xml:space="preserve">
          <source>This parameter specifies the named restore point (created with &lt;code&gt;pg_create_restore_point()&lt;/code&gt;) to which recovery will proceed.</source>
          <target state="translated">此参数指定恢复将进行到的命名还原点（使用 &lt;code&gt;pg_create_restore_point()&lt;/code&gt; 创建）。</target>
        </trans-unit>
        <trans-unit id="867f446a2e7adc40927cc70cf6283de855e50f8d" translate="yes" xml:space="preserve">
          <source>This parameter specifies the time stamp up to which recovery will proceed. The precise stopping point is also influenced by &lt;a href=&quot;runtime-config-wal#GUC-RECOVERY-TARGET-INCLUSIVE&quot;&gt;recovery_target_inclusive&lt;/a&gt;.</source>
          <target state="translated">此参数指定恢复将进行的时间戳。精确的停止点还受&lt;a href=&quot;runtime-config-wal#GUC-RECOVERY-TARGET-INCLUSIVE&quot;&gt;recovery_target_inclusive的&lt;/a&gt;影响。</target>
        </trans-unit>
        <trans-unit id="8874d47b3d5a339b6f4f727528a118f988fbf4ff" translate="yes" xml:space="preserve">
          <source>This parameter specifies the transaction ID up to which recovery will proceed. Keep in mind that while transaction IDs are assigned sequentially at transaction start, transactions can complete in a different numeric order. The transactions that will be recovered are those that committed before (and optionally including) the specified one. The precise stopping point is also influenced by &lt;a href=&quot;runtime-config-wal#GUC-RECOVERY-TARGET-INCLUSIVE&quot;&gt;recovery_target_inclusive&lt;/a&gt;.</source>
          <target state="translated">此参数指定将要进行恢复的事务ID。请记住，虽然在交易开始时按顺序分配了交易ID，但交易可以以不同的数字顺序完成。将要恢复的事务是在指定的事务之前（并可选地包括）进行的事务。精确的停止点还受&lt;a href=&quot;runtime-config-wal#GUC-RECOVERY-TARGET-INCLUSIVE&quot;&gt;recovery_target_inclusive的&lt;/a&gt;影响。</target>
        </trans-unit>
        <trans-unit id="8107ac8a053e104cbe77d39e7e4ed7f575d4cd68" translate="yes" xml:space="preserve">
          <source>This parses the document text in its parameter and returns true if the document is well-formed XML. (Note: this is an alias for the standard PostgreSQL function &lt;code&gt;xml_is_well_formed()&lt;/code&gt;. The name &lt;code&gt;xml_valid()&lt;/code&gt; is technically incorrect since validity and well-formedness have different meanings in XML.)</source>
          <target state="translated">这将解析其参数中的文档文本，如果文档是格式正确的XML，则返回true。（注意：这是标准PostgreSQL函数 &lt;code&gt;xml_is_well_formed()&lt;/code&gt; 的别名。由于有效性和格式正确在XML中的含义不同，名称 &lt;code&gt;xml_valid()&lt;/code&gt; 在技​​术上不正确。）</target>
        </trans-unit>
        <trans-unit id="55ccf48fdd4beed006b2ceea636ca3d5535efe1b" translate="yes" xml:space="preserve">
          <source>This problem can be fixed by creating a statistics object that directs &lt;code&gt;ANALYZE&lt;/code&gt; to calculate functional-dependency multivariate statistics on the two columns:</source>
          <target state="translated">可以通过创建一个统计对象来解决此问题，该对象指示 &lt;code&gt;ANALYZE&lt;/code&gt; 在两列上计算功能相关的多元统计信息：</target>
        </trans-unit>
        <trans-unit id="ed38ced0d51c221c24b167e4e04cc1cf521a37be" translate="yes" xml:space="preserve">
          <source>This process collects statistical information about the &lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;instance&lt;/a&gt;'s activities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc382ec8b1a79d496a545a65f41a47da71a48e61" translate="yes" xml:space="preserve">
          <source>This process is inherently nondeterministic, because of the randomized choices made during both the initial population selection and subsequent &amp;ldquo;mutation&amp;rdquo; of the best candidates. To avoid surprising changes of the selected plan, each run of the GEQO algorithm restarts its random number generator with the current &lt;a href=&quot;runtime-config-query#GUC-GEQO-SEED&quot;&gt;geqo_seed&lt;/a&gt; parameter setting. As long as &lt;code&gt;geqo_seed&lt;/code&gt; and the other GEQO parameters are kept fixed, the same plan will be generated for a given query (and other planner inputs such as statistics). To experiment with different search paths, try changing &lt;code&gt;geqo_seed&lt;/code&gt;.</source>
          <target state="translated">这个过程本质上是不确定的，因为在最初的总体选择和随后的最佳候选人&amp;ldquo;变异&amp;rdquo;过程中都做出了随机选择。为了避免所选计划的意外更改，每次运行GEQO算法都会使用当前的&lt;a href=&quot;runtime-config-query#GUC-GEQO-SEED&quot;&gt;geqo_seed&lt;/a&gt;参数设置重新启动其随机数生成器。只要 &lt;code&gt;geqo_seed&lt;/code&gt; 和其他GEQO参数保持固定，就将为给定查询生成相同的计划（以及其他计划程序输入，例如统计信息）。要尝试不同的搜索路径，请尝试更改 &lt;code&gt;geqo_seed&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c97c4b9be9f2b4404173b6ba238590cba29edc4b" translate="yes" xml:space="preserve">
          <source>This produces a text array if there's a match, or &lt;code&gt;NULL&lt;/code&gt; if not, the same as &lt;code&gt;regexp_match()&lt;/code&gt; would do. Without the sub-select, this query would produce no output at all for table rows without a match, which is typically not the desired behavior.</source>
          <target state="translated">如果存在匹配项，则会生成一个文本数组；否则，将生成 &lt;code&gt;NULL&lt;/code&gt; ，与 &lt;code&gt;regexp_match()&lt;/code&gt; 相同。如果没有子选择，则此查询将对不匹配的表行完全不产生任何输出，这通常不是所需的行为。</target>
        </trans-unit>
        <trans-unit id="bc14695b218efe7dec594359c6d20dcaf55f8c15" translate="yes" xml:space="preserve">
          <source>This provides the full power of the SQL query mechanism (&lt;a href=&quot;https://www.postgresql.org/docs/12/queries.html&quot;&gt;Chapter 7&lt;/a&gt;) for computing the rows to be inserted.</source>
          <target state="translated">这提供了SQL查询机制（&lt;a href=&quot;https://www.postgresql.org/docs/12/queries.html&quot;&gt;第7章&lt;/a&gt;）的全部功能，用于计算要插入的行。</target>
        </trans-unit>
        <trans-unit id="5e8d60ba924f5d2eca90b070e9581aa9a0f1247c" translate="yes" xml:space="preserve">
          <source>This provides the full power of the SQL query mechanism (&lt;a href=&quot;https://www.postgresql.org/docs/13/queries.html&quot;&gt;Chapter 7&lt;/a&gt;) for computing the rows to be inserted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9d073846645e6925e79e0c3d11f6f147a90ca99" translate="yes" xml:space="preserve">
          <source>This query can use an index if one has been defined on the result of the &lt;code&gt;lower(col1)&lt;/code&gt; function:</source>
          <target state="translated">如果在 &lt;code&gt;lower(col1)&lt;/code&gt; 函数的结果上定义了一个索引，则此查询可以使用索引：</target>
        </trans-unit>
        <trans-unit id="685680c205a35176edb0e50018d5cb6373c36816" translate="yes" xml:space="preserve">
          <source>This query could also be written</source>
          <target state="translated">这个查询也可以写成</target>
        </trans-unit>
        <trans-unit id="fbd78ff71b7c52624fbdd5dd58209049c5f353fd" translate="yes" xml:space="preserve">
          <source>This query effectively moves rows from &lt;code&gt;products&lt;/code&gt; to &lt;code&gt;products_log&lt;/code&gt;. The &lt;code&gt;DELETE&lt;/code&gt; in &lt;code&gt;WITH&lt;/code&gt; deletes the specified rows from &lt;code&gt;products&lt;/code&gt;, returning their contents by means of its &lt;code&gt;RETURNING&lt;/code&gt; clause; and then the primary query reads that output and inserts it into &lt;code&gt;products_log&lt;/code&gt;.</source>
          <target state="translated">该查询有效地将行从 &lt;code&gt;products&lt;/code&gt; 移动到 &lt;code&gt;products_log&lt;/code&gt; 。的 &lt;code&gt;DELETE&lt;/code&gt; 在 &lt;code&gt;WITH&lt;/code&gt; 删除从指定的行 &lt;code&gt;products&lt;/code&gt; ，由它的方式回到其内容 &lt;code&gt;RETURNING&lt;/code&gt; 条款;然后主查询读取该输出，并将其插入 &lt;code&gt;products_log&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="022c5b0eea8d62f63af6a712dbf2b1ba8308d986" translate="yes" xml:space="preserve">
          <source>This query is called a &lt;em&gt;left outer join&lt;/em&gt; because the table mentioned on the left of the join operator will have each of its rows in the output at least once, whereas the table on the right will only have those rows output that match some row of the left table. When outputting a left-table row for which there is no right-table match, empty (null) values are substituted for the right-table columns.</source>
          <target state="translated">该查询称为&lt;em&gt;左外部联接，&lt;/em&gt;因为联接运算符左侧提到的表将在输出中至少包含其每一行，而右侧表仅具有与该表中某些行匹配的那些行。左桌子。当输出没有右表匹配项的左表行时，将空（空）值替换为右表列。</target>
        </trans-unit>
        <trans-unit id="177886fdfa19f957f8c9f12b4d04756d588aa024" translate="yes" xml:space="preserve">
          <source>This query produces a single composite-valued column, so we might get output like:</source>
          <target state="translated">这个查询产生一个单一的复合值列,所以我们可能会得到这样的输出。</target>
        </trans-unit>
        <trans-unit id="6ff805b5878a400bc03d5c21def35ab5370b1a9c" translate="yes" xml:space="preserve">
          <source>This query retrieves the third quarter pay of all employees:</source>
          <target state="translated">此查询可检索所有员工的第三季度工资。</target>
        </trans-unit>
        <trans-unit id="f2463afc5c9099ca3f1d4275282addba1fd3ebec" translate="yes" xml:space="preserve">
          <source>This query shows all defined operator families and all the operators included in each family:</source>
          <target state="translated">该查询显示所有已定义的运算符族以及每个族中包含的所有运算符。</target>
        </trans-unit>
        <trans-unit id="54e5aac3750ebc9ffb7663de95bf9e99bb00e49b" translate="yes" xml:space="preserve">
          <source>This query will loop if the &lt;code&gt;link&lt;/code&gt; relationships contain cycles. Because we require a &amp;ldquo;depth&amp;rdquo; output, just changing &lt;code&gt;UNION ALL&lt;/code&gt; to &lt;code&gt;UNION&lt;/code&gt; would not eliminate the looping. Instead we need to recognize whether we have reached the same row again while following a particular path of links. We add two columns &lt;code&gt;path&lt;/code&gt; and &lt;code&gt;cycle&lt;/code&gt; to the loop-prone query:</source>
          <target state="translated">如果 &lt;code&gt;link&lt;/code&gt; 关系包含循环，则此查询将循环。因为我们需要&amp;ldquo;深度&amp;rdquo;输出，所以仅将 &lt;code&gt;UNION ALL&lt;/code&gt; 更改为 &lt;code&gt;UNION&lt;/code&gt; 并不能消除循环。相反，我们需要识别在遵循特定链接路径时是否再次到达同一行。我们向容易循环的查询中添加两列 &lt;code&gt;path&lt;/code&gt; 和 &lt;code&gt;cycle&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="99e758d16683ea2408024769a36931bb47e964b5" translate="yes" xml:space="preserve">
          <source>This query will match any label path that:</source>
          <target state="translated">此查询将匹配任何标签路径,即:</target>
        </trans-unit>
        <trans-unit id="2fdf2ab9a1267601ff578f17895042ec3f81192c" translate="yes" xml:space="preserve">
          <source>This query will match any word in a &lt;code&gt;tsvector&lt;/code&gt; that begins with &amp;ldquo;super&amp;rdquo;.</source>
          <target state="translated">此查询将匹配 &lt;code&gt;tsvector&lt;/code&gt; 中以&amp;ldquo; super&amp;rdquo;开头的任何单词。</target>
        </trans-unit>
        <trans-unit id="57af393c8374427869919ed9d1490df9f15189d7" translate="yes" xml:space="preserve">
          <source>This query will not use the custom operator. The parser will first see if there is a &lt;code&gt;mytext&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;mytext&lt;/code&gt; operator (&lt;a href=&quot;typeconv-oper#OP-RESOL-EXACT-UNKNOWN&quot;&gt;Step 2.a&lt;/a&gt;), which there is not; then it will consider the domain's base type &lt;code&gt;text&lt;/code&gt;, and see if there is a &lt;code&gt;text&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;text&lt;/code&gt; operator (&lt;a href=&quot;typeconv-oper#OP-RESOL-EXACT-DOMAIN&quot;&gt;Step 2.b&lt;/a&gt;), which there is; so it resolves the &lt;code&gt;unknown&lt;/code&gt;-type literal as &lt;code&gt;text&lt;/code&gt; and uses the &lt;code&gt;text&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;text&lt;/code&gt; operator. The only way to get the custom operator to be used is to explicitly cast the literal:</source>
          <target state="translated">此查询将不使用自定义运算符。解析器将首先查看是否存在 &lt;code&gt;mytext&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;mytext&lt;/code&gt; 运算符（&lt;a href=&quot;typeconv-oper#OP-RESOL-EXACT-UNKNOWN&quot;&gt;步骤2.a&lt;/a&gt;），否则就没有；然后它将考虑域的基本类型 &lt;code&gt;text&lt;/code&gt; ，并查看是否存在 &lt;code&gt;text&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;text&lt;/code&gt; 运算符（&lt;a href=&quot;typeconv-oper#OP-RESOL-EXACT-DOMAIN&quot;&gt;步骤2.b&lt;/a&gt;）；因此它将 &lt;code&gt;unknown&lt;/code&gt; 类型的文字解析为 &lt;code&gt;text&lt;/code&gt; 并使用 &lt;code&gt;text&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;text&lt;/code&gt; 运算符。获取要使用的自定义运算符的唯一方法是显式转换文字：</target>
        </trans-unit>
        <trans-unit id="5e1307cd9ebfbfd4618c4e4fa0b6171f2574b87f" translate="yes" xml:space="preserve">
          <source>This query will use the configuration set by &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config&lt;/a&gt;.</source>
          <target state="translated">该查询将使用&lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config&lt;/a&gt;设置的配置。</target>
        </trans-unit>
        <trans-unit id="772d10eaef65ba067a9a91fb64ad922fec135eca" translate="yes" xml:space="preserve">
          <source>This query would remove all direct and indirect subparts of a product.</source>
          <target state="translated">该查询将删除产品的所有直接和间接子项。</target>
        </trans-unit>
        <trans-unit id="31069b011561af14dacd4c6e9f8a75852a903c9c" translate="yes" xml:space="preserve">
          <source>This record matches connection attempts made using TCP/IP, but only when the connection is made with GSSAPI encryption.</source>
          <target state="translated">该记录匹配使用TCP/IP进行的连接尝试,但仅当连接是通过GSSAPI加密进行的。</target>
        </trans-unit>
        <trans-unit id="c9fabd411db1c8bc15edbea94205d1cbeda901f1" translate="yes" xml:space="preserve">
          <source>This record matches connection attempts made using TCP/IP, but only when the connection is made with SSL encryption.</source>
          <target state="translated">该记录匹配使用TCP/IP进行的连接尝试,但只有在使用SSL加密进行连接时才会匹配。</target>
        </trans-unit>
        <trans-unit id="4881dcf03549dbbd4f3907276b28052ef74959c1" translate="yes" xml:space="preserve">
          <source>This record matches connection attempts made using TCP/IP. &lt;code&gt;host&lt;/code&gt; records match SSL or non-SSL connection attempts as well as GSSAPI encrypted or non-GSSAPI encrypted connection attempts.</source>
          <target state="translated">该记录与使用TCP / IP进行的连接尝试匹配。 &lt;code&gt;host&lt;/code&gt; 记录匹配SSL或非SSL连接尝试以及GSSAPI加密或非GSSAPI加密连接尝试。</target>
        </trans-unit>
        <trans-unit id="980501924f376459d15d0a5c5db8499b7255c1bb" translate="yes" xml:space="preserve">
          <source>This record matches connection attempts using Unix-domain sockets. Without a record of this type, Unix-domain socket connections are disallowed.</source>
          <target state="translated">该记录匹配使用Unix-domain套接字的连接尝试。如果没有这种类型的记录,Unix域套接字连接是不允许的。</target>
        </trans-unit>
        <trans-unit id="0feefb6f7cf4b291e2319a9344c59b819e8fd16b" translate="yes" xml:space="preserve">
          <source>This record type has the opposite behavior of &lt;code&gt;hostgssenc&lt;/code&gt;; it only matches connection attempts made over TCP/IP that do not use GSSAPI encryption.</source>
          <target state="translated">这种记录类型具有 &lt;code&gt;hostgssenc&lt;/code&gt; 的相反行为; 它仅与不使用GSSAPI加密的通过TCP / IP进行的连接尝试匹配。</target>
        </trans-unit>
        <trans-unit id="42de4ec30f5134f52861e4d13f8e0897d5515f16" translate="yes" xml:space="preserve">
          <source>This record type has the opposite behavior of &lt;code&gt;hostssl&lt;/code&gt;; it only matches connection attempts made over TCP/IP that do not use SSL.</source>
          <target state="translated">这种记录类型具有 &lt;code&gt;hostssl&lt;/code&gt; 的相反行为; 它仅与不使用SSL的通过TCP / IP进行的连接尝试匹配。</target>
        </trans-unit>
        <trans-unit id="bdac87a685f48979a0382e2f425d5422b1cea994" translate="yes" xml:space="preserve">
          <source>This reference page does not describe the embedded SQL language. See &lt;a href=&quot;https://www.postgresql.org/docs/12/ecpg.html&quot;&gt;Chapter 35&lt;/a&gt; for more information on that topic.</source>
          <target state="translated">该参考页未介绍嵌入式SQL语言。有关该主题的更多信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/ecpg.html&quot;&gt;第35章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d3fc02a75c04d8edd3f600f6578a82bc3af1af4c" translate="yes" xml:space="preserve">
          <source>This reference page does not describe the embedded SQL language. See &lt;a href=&quot;https://www.postgresql.org/docs/13/ecpg.html&quot;&gt;Chapter 35&lt;/a&gt; for more information on that topic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9455758ac29d288f9d863b3b9a52a001aafdf9d3" translate="yes" xml:space="preserve">
          <source>This references a function that is responsible for executing &amp;ldquo;inline&amp;rdquo; anonymous code blocks (&lt;a href=&quot;sql-do&quot;&gt;DO&lt;/a&gt; blocks). Zero if inline blocks are not supported.</source>
          <target state="translated">这引用了负责执行&amp;ldquo;内联&amp;rdquo;匿名代码块（&lt;a href=&quot;sql-do&quot;&gt;DO&lt;/a&gt;块）的函数。如果不支持嵌入式块，则为零。</target>
        </trans-unit>
        <trans-unit id="d1bdaa47f9aa6f846a6b5a2e5bd41bcbcff51ce1" translate="yes" xml:space="preserve">
          <source>This references a language validator function that is responsible for checking the syntax and validity of new functions when they are created. Zero if no validator is provided.</source>
          <target state="translated">该函数引用了一个语言验证器函数,它负责检查新函数创建时的语法和有效性。如果没有提供验证器,则为零。</target>
        </trans-unit>
        <trans-unit id="3578784aa58f3b4c597b7efb7e0f5cb34cc12bb9" translate="yes" xml:space="preserve">
          <source>This represents a not-null constraint.</source>
          <target state="translated">这代表了一个非空的约束。</target>
        </trans-unit>
        <trans-unit id="d0d26f9c2c294dc6bad121a60a45edf3f61c2846" translate="yes" xml:space="preserve">
          <source>This restriction applies only to cases where the planner would need to execute a user-defined operator on one or more values from &lt;code&gt;pg_statistic&lt;/code&gt;. Thus the planner is permitted to use generic statistical information, such as the fraction of null values or the number of distinct values in a column, regardless of access privileges.</source>
          <target state="translated">此限制仅适用于计划者需要对 &lt;code&gt;pg_statistic&lt;/code&gt; 中的一个或多个值执行用户定义的运算符的情况。因此，无论访问权限如何，都允许计划者使用常规统计信息，例如空值的分数或一列中不同值的数量。</target>
        </trans-unit>
        <trans-unit id="9c63585630ca8ea8585e254ea84b2de23abf28ba" translate="yes" xml:space="preserve">
          <source>This restriction is made to reduce ambiguity. There is still ambiguity if an &lt;code&gt;ORDER BY&lt;/code&gt; item is a simple name that could match either an output column name or a column from the table expression. The output column is used in such cases. This would only cause confusion if you use &lt;code&gt;AS&lt;/code&gt; to rename an output column to match some other table column's name.</source>
          <target state="translated">进行此限制是为了减少歧义。如果 &lt;code&gt;ORDER BY&lt;/code&gt; 项是一个简单名称，可以匹配输出列名称或表表达式中的列，则仍然存在歧义。在这种情况下使用输出列。仅当您使用 &lt;code&gt;AS&lt;/code&gt; 重命名输出列以使其与其他表列的名称匹配时，这才会引起混淆。</target>
        </trans-unit>
        <trans-unit id="d4b4e7539fae825407db528c4ddfb962b1364a94" translate="yes" xml:space="preserve">
          <source>This returns &lt;code&gt;description&lt;/code&gt; if it is not null, otherwise &lt;code&gt;short_description&lt;/code&gt; if it is not null, otherwise &lt;code&gt;(none)&lt;/code&gt;.</source>
          <target state="translated">如果不为null，则返回 &lt;code&gt;description&lt;/code&gt; ;如果不为null，则 &lt;code&gt;short_description&lt;/code&gt; ；否则为 &lt;code&gt;(none)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56453523ba12fcdc5569aa80495dc2ebae8ffdff" translate="yes" xml:space="preserve">
          <source>This returns &lt;code&gt;true&lt;/code&gt; if the entered password is correct.</source>
          <target state="translated">如果输入的密码正确，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5e450193561cf91ce82c2251b4755de760a2b210" translate="yes" xml:space="preserve">
          <source>This scheme has a number of advantages compared to a more straightforward approach such as allowing row values to span pages. Assuming that queries are usually qualified by comparisons against relatively small key values, most of the work of the executor will be done using the main row entry. The big values of TOASTed attributes will only be pulled out (if selected at all) at the time the result set is sent to the client. Thus, the main table is much smaller and more of its rows fit in the shared buffer cache than would be the case without any out-of-line storage. Sort sets shrink also, and sorts will more often be done entirely in memory. A little test showed that a table containing typical HTML pages and their URLs was stored in about half of the raw data size including the TOAST table, and that the main table contained only about 10% of the entire data (the URLs and some small HTML pages). There was no run time difference compared to an un-TOASTed comparison table, in which all the HTML pages were cut down to 7 kB to fit.</source>
          <target state="translated">与允许行值跨页等更直接的方法相比,这种方案有很多优势。假设查询通常是通过对相对较小的键值进行比较来限定的,那么执行者的大部分工作将使用主行条目来完成。TOASTed属性的大值只会在结果集发送到客户端时才会被拉出来(如果有选择的话)。因此,主表比没有任何行外存储的情况下,主表要小得多,更多的行适合在共享缓冲区缓存中。排序集也会缩小,排序更多时候会完全在内存中完成。一个小测试表明,一个包含典型HTML页面及其URL的表,包括TOAST表在内的原始数据大小约为一半,而主表只包含整个数据(URL和一些小的HTML页面)的10%左右。与未TOAST化的对比表相比,在运行时间上没有任何差异,其中所有的HTML页面被削减到7 kB以适应。</target>
        </trans-unit>
        <trans-unit id="931ae4ac07974a516a75c4a0fb5344d4de15b384" translate="yes" xml:space="preserve">
          <source>This script allows each iteration of the transaction to reference different, randomly-chosen rows. (This example also shows why it's important for each client session to have its own variables &amp;mdash; otherwise they'd not be independently touching different rows.)</source>
          <target state="translated">该脚本允许事务的每次迭代都引用不同的，随机选择的行。（此示例还显示了为什么每个客户端会话都有自己的变量很重要，否则它们将不会独立地涉及不同的行。）</target>
        </trans-unit>
        <trans-unit id="a06cc7d2225d879e4baf3b5d87eff2d8fceb78b2" translate="yes" xml:space="preserve">
          <source>This script will attempt to verify that you have done all the configuration steps correctly, and then it will run the regression tests for the &lt;code&gt;sepgsql&lt;/code&gt; module.</source>
          <target state="translated">该脚本将尝试验证您是否正确完成了所有配置步骤，然后将对 &lt;code&gt;sepgsql&lt;/code&gt; 模块运行回归测试。</target>
        </trans-unit>
        <trans-unit id="b4abfec97901c9f5545ed7f9d531e3f594a60d05" translate="yes" xml:space="preserve">
          <source>This second example shows a multiplication table with rows sorted in reverse numerical order and columns with an independent, ascending numerical order.</source>
          <target state="translated">第二个例子显示了一个乘法表,该表的行按相反的数字顺序排列,列按独立的升序数字顺序排列。</target>
        </trans-unit>
        <trans-unit id="70517dd03c7a023f4b63122ef2607a8bb09453ad" translate="yes" xml:space="preserve">
          <source>This section concerns limits that are not inherent in the libxml2 library, but apply to the current implementation in PostgreSQL.</source>
          <target state="translated">这一节涉及到的限制不是libxml2库中固有的,而是适用于PostgreSQL中的当前实现。</target>
        </trans-unit>
        <trans-unit id="4e94a4091d1abb9ffbdb35b9bc5912877ddcba29" translate="yes" xml:space="preserve">
          <source>This section covers B-Tree index implementation details that may be of use to advanced users. See &lt;code&gt;src/backend/access/nbtree/README&lt;/code&gt; in the source distribution for a much more detailed, internals-focused description of the B-Tree implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9c2d04552ba91a05718611a7d18eeefc7243226" translate="yes" xml:space="preserve">
          <source>This section covers implementation details and other tricks that are useful for implementers of SP-GiST operator classes to know.</source>
          <target state="translated">本节涵盖了实现细节和其他技巧,对于SP-GIST运算符类的实现者来说,了解这些细节是很有用的。</target>
        </trans-unit>
        <trans-unit id="82ea52fe608db7eb14abb1bc47e7a0d7e788e138" translate="yes" xml:space="preserve">
          <source>This section covers parameters that may be used when only inserting new rows. Parameters &lt;em&gt;exclusively&lt;/em&gt; used with the &lt;code&gt;ON CONFLICT&lt;/code&gt; clause are described separately.</source>
          <target state="translated">本节介绍仅插入新行时可以使用的参数。参数&lt;em&gt;专门&lt;/em&gt;与所用的 &lt;code&gt;ON CONFLICT&lt;/code&gt; 子句分别描述。</target>
        </trans-unit>
        <trans-unit id="e7807f695e34f4b1eac9463bb59bd4074598384a" translate="yes" xml:space="preserve">
          <source>This section describes a PostgreSQL-specific way to create an autoincrementing column. Another way is to use the SQL-standard identity column feature, described at &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;.</source>
          <target state="translated">本节介绍了PostgreSQL特定的创建自动增量列的方法。另一种方法是使用SQL标准身份列功能，如&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4f81e5e9f39108fa574970aa59c9663d6ba95ff1" translate="yes" xml:space="preserve">
          <source>This section describes additional functions and operators that are useful in connection with text search.</source>
          <target state="translated">本节介绍了与文本搜索有关的其他功能和操作符。</target>
        </trans-unit>
        <trans-unit id="c2ae13af2d3ddf62ac5901d20f9f9c54bb6f2eab" translate="yes" xml:space="preserve">
          <source>This section describes functions and operators for examining and manipulating binary strings, that is values of type &lt;code&gt;bytea&lt;/code&gt;. Many of these are equivalent, in purpose and syntax, to the text-string functions described in the previous section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2cbf42b02f5c651095d7686f2a3413bfe1a3d1d" translate="yes" xml:space="preserve">
          <source>This section describes functions and operators for examining and manipulating bit strings, that is values of the types &lt;code&gt;bit&lt;/code&gt; and &lt;code&gt;bit varying&lt;/code&gt;. (While only type &lt;code&gt;bit&lt;/code&gt; is mentioned in these tables, values of type &lt;code&gt;bit varying&lt;/code&gt; can be used interchangeably.) Bit strings support the usual comparison operators shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;Table 9.1&lt;/a&gt;, as well as the operators shown in &lt;a href=&quot;functions-bitstring#FUNCTIONS-BIT-STRING-OP-TABLE&quot;&gt;Table 9.14&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a4f8d994f18d2a21002c3a9cf18de77dd441569" translate="yes" xml:space="preserve">
          <source>This section describes functions and operators for examining and manipulating bit strings, that is values of the types &lt;code&gt;bit&lt;/code&gt; and &lt;code&gt;bit varying&lt;/code&gt;. Aside from the usual comparison operators, the operators shown in &lt;a href=&quot;functions-bitstring#FUNCTIONS-BIT-STRING-OP-TABLE&quot;&gt;Table 9.14&lt;/a&gt; can be used. Bit string operands of &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, and &lt;code&gt;#&lt;/code&gt; must be of equal length. When bit shifting, the original length of the string is preserved, as shown in the examples.</source>
          <target state="translated">本节介绍了用于检查和操作位字符串的函数和运算符，这些位字符串是 &lt;code&gt;bit&lt;/code&gt; 和 &lt;code&gt;bit varying&lt;/code&gt; 类型的值。除了通常的比较运算符外，还可以使用&lt;a href=&quot;functions-bitstring#FUNCTIONS-BIT-STRING-OP-TABLE&quot;&gt;表9.14中&lt;/a&gt;所示的运算符。 &lt;code&gt;&amp;amp;&lt;/code&gt; ， &lt;code&gt;|&lt;/code&gt; 的位字符串操作数 ，并且 &lt;code&gt;#&lt;/code&gt; 的长度必须相等。如示例所示，当进行位移时，将保留字符串的原始长度。</target>
        </trans-unit>
        <trans-unit id="4e0fe72449b8f5ee00166f169b410f0184155751" translate="yes" xml:space="preserve">
          <source>This section describes functions and operators for examining and manipulating string values. Strings in this context include values of the types &lt;code&gt;character&lt;/code&gt;, &lt;code&gt;character varying&lt;/code&gt;, and &lt;code&gt;text&lt;/code&gt;. Except where noted, these functions and operators are declared to accept and return type &lt;code&gt;text&lt;/code&gt;. They will interchangeably accept &lt;code&gt;character varying&lt;/code&gt; arguments. Values of type &lt;code&gt;character&lt;/code&gt; will be converted to &lt;code&gt;text&lt;/code&gt; before the function or operator is applied, resulting in stripping any trailing spaces in the &lt;code&gt;character&lt;/code&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87c3af132af71e9d06f2e69bc9cb2fabb82cfdae" translate="yes" xml:space="preserve">
          <source>This section describes functions and operators for examining and manipulating string values. Strings in this context include values of the types &lt;code&gt;character&lt;/code&gt;, &lt;code&gt;character varying&lt;/code&gt;, and &lt;code&gt;text&lt;/code&gt;. Unless otherwise noted, all of the functions listed below work on all of these types, but be wary of potential effects of automatic space-padding when using the &lt;code&gt;character&lt;/code&gt; type. Some functions also exist natively for the bit-string types.</source>
          <target state="translated">本节介绍了用于检查和操作字符串值的函数和运算符。在这种情况下，字符串包括 &lt;code&gt;character&lt;/code&gt; ， &lt;code&gt;character varying&lt;/code&gt; 和 &lt;code&gt;text&lt;/code&gt; 类型的值。除非另有说明，否则下面列出的所有功能均可在所有这些类型上使用，但请注意在使用 &lt;code&gt;character&lt;/code&gt; 类型时自动空格填充的潜在影响。对于位串类型，本机还存在一些功能。</target>
        </trans-unit>
        <trans-unit id="33495850b72b20959dd4e9cc8d5ffd57ebaf33b2" translate="yes" xml:space="preserve">
          <source>This section describes functions and operators for examining and manipulating values of type &lt;code&gt;bytea&lt;/code&gt;.</source>
          <target state="translated">本节介绍用于检查和操作 &lt;code&gt;bytea&lt;/code&gt; 类型的值的函数和运算符。</target>
        </trans-unit>
        <trans-unit id="4e496c508c41ace731778c7db8e284ddab372720" translate="yes" xml:space="preserve">
          <source>This section describes functions for operating on &lt;em&gt;sequence objects&lt;/em&gt;, also called sequence generators or just sequences. Sequence objects are special single-row tables created with &lt;a href=&quot;sql-createsequence&quot;&gt;CREATE SEQUENCE&lt;/a&gt;. Sequence objects are commonly used to generate unique identifiers for rows of a table. The sequence functions, listed in &lt;a href=&quot;functions-sequence#FUNCTIONS-SEQUENCE-TABLE&quot;&gt;Table 9.50&lt;/a&gt;, provide simple, multiuser-safe methods for obtaining successive sequence values from sequence objects.</source>
          <target state="translated">本节介绍了对&lt;em&gt;序列对象&lt;/em&gt;进行操作的功能，也称为序列生成器或仅称为序列。序列对象是使用&lt;a href=&quot;sql-createsequence&quot;&gt;CREATE SEQUENCE&lt;/a&gt;创建的特殊单行表。序列对象通常用于为表的行生成唯一的标识符。&lt;a href=&quot;functions-sequence#FUNCTIONS-SEQUENCE-TABLE&quot;&gt;表9.50中&lt;/a&gt;列出的序列函数提供了用于从序列对象中获取连续序列值的简单，多用户安全的方法。</target>
        </trans-unit>
        <trans-unit id="5bbad968fc5872c67f7bc619db0866c3845188b7" translate="yes" xml:space="preserve">
          <source>This section describes functions that possibly return more than one row. The most widely used functions in this class are series generating functions, as detailed in &lt;a href=&quot;functions-srf#FUNCTIONS-SRF-SERIES&quot;&gt;Table 9.61&lt;/a&gt; and &lt;a href=&quot;functions-srf#FUNCTIONS-SRF-SUBSCRIPTS&quot;&gt;Table 9.62&lt;/a&gt;. Other, more specialized set-returning functions are described elsewhere in this manual. See &lt;a href=&quot;queries-table-expressions#QUERIES-TABLEFUNCTIONS&quot;&gt;Section 7.2.1.4&lt;/a&gt; for ways to combine multiple set-returning functions.</source>
          <target state="translated">本节介绍可能返回多个行的函数。此类中使用最广泛的函数是系列生成函数，如&lt;a href=&quot;functions-srf#FUNCTIONS-SRF-SERIES&quot;&gt;表9.61&lt;/a&gt;和&lt;a href=&quot;functions-srf#FUNCTIONS-SRF-SUBSCRIPTS&quot;&gt;表9.62&lt;/a&gt;所详述。其他更专门的设定返回功能在本手册的其他地方介绍。有关组合多个置位返回功能的方法，请参见&lt;a href=&quot;queries-table-expressions#QUERIES-TABLEFUNCTIONS&quot;&gt;第7.2.1.4节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3dfa6ccb5fc708e17b3c2138c2ea27f1c67b607b" translate="yes" xml:space="preserve">
          <source>This section describes several specialized constructs for making multiple comparisons between groups of values. These forms are syntactically related to the subquery forms of the previous section, but do not involve subqueries. The forms involving array subexpressions are PostgreSQL extensions; the rest are SQL-compliant. All of the expression forms documented in this section return Boolean (true/false) results.</source>
          <target state="translated">本节介绍了几个专门的结构,用于在一组值之间进行多重比较。这些形式在语法上与上一节的子查询形式有关,但不涉及子查询。涉及数组子表达式的形式是PostgreSQL的扩展,其余的形式都是符合SQL的。本节中记录的所有表达式都会返回布尔(真/假)结果。</target>
        </trans-unit>
        <trans-unit id="57f85eb5e6f2d55d8369ac9b3abade0eafd046e8" translate="yes" xml:space="preserve">
          <source>This section describes the SQL-compliant conditional expressions available in PostgreSQL.</source>
          <target state="translated">本节介绍PostgreSQL中可用的符合SQL的条件表达式。</target>
        </trans-unit>
        <trans-unit id="5da57e6e3608b9fe086d7f3b55296f911c387483" translate="yes" xml:space="preserve">
          <source>This section describes the SQL-compliant subquery expressions available in PostgreSQL. All of the expression forms documented in this section return Boolean (true/false) results.</source>
          <target state="translated">本节介绍了PostgreSQL中可用的符合SQL的子查询表达式。本节中记录的所有表达式都会返回布尔(真/假)结果。</target>
        </trans-unit>
        <trans-unit id="161fd87db311749fb3c7966d6e4c44e430dceb4a" translate="yes" xml:space="preserve">
          <source>This section describes the settings that apply only for the duration of the recovery. They must be reset for any subsequent recovery you wish to perform.</source>
          <target state="translated">本节介绍了仅适用于恢复期间的设置。对于您希望执行的任何后续恢复,必须重新设置这些设置。</target>
        </trans-unit>
        <trans-unit id="ec4289c6ae60dc86583f63bcfa1ab2282875f421" translate="yes" xml:space="preserve">
          <source>This section describes the storage format at the level of files and directories.</source>
          <target state="translated">本节介绍了文件和目录层面的存储格式。</target>
        </trans-unit>
        <trans-unit id="ba5d2422f445963cd3ce879f09ea9078bbeca96e" translate="yes" xml:space="preserve">
          <source>This section describes:</source>
          <target state="translated">本节介绍:</target>
        </trans-unit>
        <trans-unit id="6ece9977ad348713454c60a551c6e69fda61960b" translate="yes" xml:space="preserve">
          <source>This section discusses how to upgrade your database data from one PostgreSQL release to a newer one.</source>
          <target state="translated">本节将讨论如何将数据库数据从一个PostgreSQL版本升级到一个新的版本。</target>
        </trans-unit>
        <trans-unit id="48ea0981b8339378a93a9c98caccd890ae95e94c" translate="yes" xml:space="preserve">
          <source>This section introduces multivariate variant of MCV (most-common values) lists, a straightforward extension of the per-column statistics described in &lt;a href=&quot;row-estimation-examples&quot;&gt;Section 70.1&lt;/a&gt;. These statistics address the limitation by storing individual values, but it is naturally more expensive, both in terms of building the statistics in &lt;code&gt;ANALYZE&lt;/code&gt;, storage and planning time.</source>
          <target state="translated">本节介绍MCV（最常用的值）列表的多元变体，这是&lt;a href=&quot;row-estimation-examples&quot;&gt;第70.1节中&lt;/a&gt;描述的每列统计信息的直接扩展。这些统计信息通过存储单个值来解决限制，但是就构建 &lt;code&gt;ANALYZE&lt;/code&gt; 中的统计信息，存储和计划时间而言，自然要贵得多。</target>
        </trans-unit>
        <trans-unit id="b7347f9c564588e3c1f50679c373c1a34d851437" translate="yes" xml:space="preserve">
          <source>This section presents some of the resulting differences you may encounter.</source>
          <target state="translated">本节介绍了您可能遇到的一些由此产生的差异。</target>
        </trans-unit>
        <trans-unit id="987de3a2c28c06d130851059547cd1a57f333d64" translate="yes" xml:space="preserve">
          <source>This section provides an overview of TOAST (The Oversized-Attribute Storage Technique).</source>
          <target state="translated">本节提供了TOAST(超大属性存储技术)的概述。</target>
        </trans-unit>
        <trans-unit id="22e2c735002756aac0cd53f48c77e94addceba8d" translate="yes" xml:space="preserve">
          <source>This section provides an overview of the page format used within PostgreSQL tables and indexes.&lt;a href=&quot;#ftn.id-1.10.21.8.2.2&quot;&gt;&lt;sup id=&quot;id-1.10.21.8.2.2&quot;&gt;[15]&lt;/sup&gt;&lt;/a&gt; Sequences and TOAST tables are formatted just like a regular table.</source>
          <target state="translated">本节概述了PostgreSQL表和索引中使用的页面格式。&lt;a href=&quot;#ftn.id-1.10.21.8.2.2&quot;&gt;&lt;sup id=&quot;id-1.10.21.8.2.2&quot;&gt;[15]&lt;/sup&gt;&lt;/a&gt;序列和TOAST表的格式类似于常规表。</target>
        </trans-unit>
        <trans-unit id="4b7ff27c909be2ddf359caa08cc7dd7e70850531" translate="yes" xml:space="preserve">
          <source>This sets only the minimum number of segments retained in &lt;code&gt;pg_wal&lt;/code&gt;; the system might need to retain more segments for WAL archival or to recover from a checkpoint. If &lt;code&gt;wal_keep_segments&lt;/code&gt; is zero (the default), the system doesn't keep any extra segments for standby purposes, so the number of old WAL segments available to standby servers is a function of the location of the previous checkpoint and status of WAL archiving. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">这仅设置了 &lt;code&gt;pg_wal&lt;/code&gt; 中保留的最小段数；系统可能需要保留更多的段以进行WAL归档或从检查点恢复。如果 &lt;code&gt;wal_keep_segments&lt;/code&gt; 为零（默认值），则系统不会为备用目的保留任何额外的段，因此备用服务器可用的旧WAL段的数量取决于先前检查点的位置和WAL归档状态的函数。此参数只能在 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件或服务器命令行中设置。</target>
        </trans-unit>
        <trans-unit id="60c40705443d693c37c2a4350a7f0525d8e96e6c" translate="yes" xml:space="preserve">
          <source>This sets only the minimum size of segments retained in &lt;code&gt;pg_wal&lt;/code&gt;; the system might need to retain more segments for WAL archival or to recover from a checkpoint. If &lt;code&gt;wal_keep_size&lt;/code&gt; is zero (the default), the system doesn't keep any extra segments for standby purposes, so the number of old WAL segments available to standby servers is a function of the location of the previous checkpoint and status of WAL archiving. If this value is specified without units, it is taken as megabytes. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52a9b5608610577ceec8bb54f78e5c4867056fa3" translate="yes" xml:space="preserve">
          <source>This sets the number of workers that should be used to assist a parallel scan of this table. If not set, the system will determine a value based on the relation size. The actual number of workers chosen by the planner or by utility statements that use parallel scans may be less, for example due to the setting of &lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt;.</source>
          <target state="translated">这设置了应用于辅助对该表进行并行扫描的工作程序数。如果未设置，则系统将根据关系大小确定一个值。例如，由于设置了&lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt;，计划者或使用并行扫描的实用程序语句选择的实际工作者数量可能会更少。</target>
        </trans-unit>
        <trans-unit id="fc2b98f968a25c7e42b52a06c47e3ef33cd30253" translate="yes" xml:space="preserve">
          <source>This setting constrains the total space used at any instant by all temporary files used by a given PostgreSQL process. It should be noted that disk space used for explicit temporary tables, as opposed to temporary files used behind-the-scenes in query execution, does &lt;em&gt;not&lt;/em&gt; count against this limit.</source>
          <target state="translated">此设置限制了给定PostgreSQL进程使用的所有临时文件在任何时刻使用的总空间。应该注意的是，用于显式临时表的磁盘空间（与在查询执行中在后台使用的临时文件相对）&lt;em&gt;不&lt;/em&gt;计入此限制。</target>
        </trans-unit>
        <trans-unit id="139dfa45f922c9380ccf94aed30326869ecb29b0" translate="yes" xml:space="preserve">
          <source>This setting controls usage of the fast update technique described in &lt;a href=&quot;gin-implementation#GIN-FAST-UPDATE&quot;&gt;Section 66.4.1&lt;/a&gt;. It is a Boolean parameter: &lt;code&gt;ON&lt;/code&gt; enables fast update, &lt;code&gt;OFF&lt;/code&gt; disables it. (Alternative spellings of &lt;code&gt;ON&lt;/code&gt; and &lt;code&gt;OFF&lt;/code&gt; are allowed as described in &lt;a href=&quot;config-setting&quot;&gt;Section 19.1&lt;/a&gt;.) The default is &lt;code&gt;ON&lt;/code&gt;.</source>
          <target state="translated">此设置控制&lt;a href=&quot;gin-implementation#GIN-FAST-UPDATE&quot;&gt;第66.4.1节中&lt;/a&gt;描述的快速更新技术的使用。它是一个布尔参数： &lt;code&gt;ON&lt;/code&gt; 启用快速更新， &lt;code&gt;OFF&lt;/code&gt; 禁用它。 （如&lt;a href=&quot;config-setting&quot;&gt;第19.1节&lt;/a&gt;所述，允许使用交替拼写的 &lt;code&gt;ON&lt;/code&gt; 和 &lt;code&gt;OFF&lt;/code&gt; 。）默认值为 &lt;code&gt;ON&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cf3f9cd2ec6037cc1a1e53b4e2acfa5803c6cdf6" translate="yes" xml:space="preserve">
          <source>This setting controls usage of the fast update technique described in &lt;a href=&quot;gin-implementation#GIN-FAST-UPDATE&quot;&gt;Section 66.4.1&lt;/a&gt;. It is a Boolean parameter: &lt;code&gt;ON&lt;/code&gt; enables fast update, &lt;code&gt;OFF&lt;/code&gt; disables it. The default is &lt;code&gt;ON&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88c5ee85f398c9445f5170ac51b66b98052f302e" translate="yes" xml:space="preserve">
          <source>This setting does not attempt to guarantee that an error will be generated under any particular circumstances. In fact, if the correct results can be generated from (for example) a cursor which has materialized a result set, no error will be generated even if the underlying rows in the referenced table have been vacuumed away. Some tables cannot safely be vacuumed early, and so will not be affected by this setting, such as system catalogs. For such tables this setting will neither reduce bloat nor create a possibility of a &amp;ldquo;snapshot too old&amp;rdquo; error on scanning.</source>
          <target state="translated">此设置并不试图保证在任何特定情况下都会产生错误。实际上，如果可以从（例如）实现了结果集的游标生成正确的结果，则即使引用表中的基础行已被清除，也不会产生错误。某些表无法安全地尽早清理，因此不受此设置的影响，例如系统目录。对于此类表，此设置既不会减少膨胀，也不会在扫描时产生&amp;ldquo;快照太旧&amp;rdquo;错误的可能性。</target>
        </trans-unit>
        <trans-unit id="a17178f6f108f66e558374c8c51711f31a5f8a53" translate="yes" xml:space="preserve">
          <source>This setting does not override the behavior of &lt;code&gt;old_snapshot_threshold&lt;/code&gt; on the primary; a snapshot on the standby which exceeds the primary's age threshold can become invalid, resulting in cancellation of transactions on the standby. This is because &lt;code&gt;old_snapshot_threshold&lt;/code&gt; is intended to provide an absolute limit on the time which dead rows can contribute to bloat, which would otherwise be violated because of the configuration of a standby.</source>
          <target state="translated">此设置不会覆盖 &lt;code&gt;old_snapshot_threshold&lt;/code&gt; 在主数据库上的行为；备用数据库上超过主数据库的使用期限阈值的快照可能变得无效，从而导致备用数据库上的事务被取消。这是因为 &lt;code&gt;old_snapshot_threshold&lt;/code&gt; 旨在对死行可能导致膨胀的时间提供绝对限制，否则将由于备用数据库的配置而被破坏。</target>
        </trans-unit>
        <trans-unit id="75e909e2915702b5ef44ed6b9bc45b154af3c719" translate="yes" xml:space="preserve">
          <source>This setting has lower priority than &lt;code&gt;log_min_duration_statement&lt;/code&gt;, meaning that statements with durations exceeding &lt;code&gt;log_min_duration_statement&lt;/code&gt; are not subject to sampling and are always logged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30bbbf8d25fa89c91c122a573c367986c6688ee4" translate="yes" xml:space="preserve">
          <source>This setting has no effect if &lt;code&gt;G&lt;/code&gt; is specified in &lt;code&gt;-I&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fcceaeb0992bcd64acc1981c44ad2c4975f0743" translate="yes" xml:space="preserve">
          <source>This setting has no effect if no recovery target is set. If &lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY&quot;&gt;hot_standby&lt;/a&gt; is not enabled, a setting of &lt;code&gt;pause&lt;/code&gt; will act the same as &lt;code&gt;shutdown&lt;/code&gt;.</source>
          <target state="translated">如果未设置恢复目标，则此设置无效。如果未启用&lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY&quot;&gt;hot_standby，&lt;/a&gt;则 &lt;code&gt;pause&lt;/code&gt; 设置的作用与 &lt;code&gt;shutdown&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="b54b0267f4e95220b4cbe85438dae82b1b7a7e5d" translate="yes" xml:space="preserve">
          <source>This setting has no effect if no recovery target is set. If &lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY&quot;&gt;hot_standby&lt;/a&gt; is not enabled, a setting of &lt;code&gt;pause&lt;/code&gt; will act the same as &lt;code&gt;shutdown&lt;/code&gt;. If the recovery target is reached while a promotion is ongoing, a setting of &lt;code&gt;pause&lt;/code&gt; will act the same as &lt;code&gt;promote&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aff67729130b72538eec21d5c35d1c92d507ac67" translate="yes" xml:space="preserve">
          <source>This setting only affects log messages printed as a result of &lt;a href=&quot;runtime-config-logging#GUC-LOG-STATEMENT&quot;&gt;log_statement&lt;/a&gt;, &lt;a href=&quot;runtime-config-logging#GUC-LOG-DURATION&quot;&gt;log_duration&lt;/a&gt;, and related settings. Non-zero values of this setting add some overhead, particularly if parameters are sent in binary form, since then conversion to text is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="243a6a2a0cf02294a9fc7bce185732812dc50642" translate="yes" xml:space="preserve">
          <source>This shell syntax can get tedious quickly. Therefore the wrapper program &lt;a href=&quot;app-pg-ctl&quot;&gt;pg_ctl&lt;/a&gt; is provided to simplify some tasks. For example:</source>
          <target state="translated">这种shell语法很快就会变得乏味。因此，提供了包装程序&lt;a href=&quot;app-pg-ctl&quot;&gt;pg_ctl&lt;/a&gt;来简化某些任务。例如：</target>
        </trans-unit>
        <trans-unit id="1732a07a9954b37aedbdc19948ece5c409757c1b" translate="yes" xml:space="preserve">
          <source>This shortest-precise output format is much faster to generate than the historical rounded format.</source>
          <target state="translated">这种最短精确的输出格式比历史上的四舍五入格式生成速度快得多。</target>
        </trans-unit>
        <trans-unit id="98021c2c2c1d427e7a19ee968ec54370a03719cc" translate="yes" xml:space="preserve">
          <source>This should be used if the view is intended to provide row-level security. See &lt;a href=&quot;https://www.postgresql.org/docs/12/rules-privileges.html&quot;&gt;Section 40.5&lt;/a&gt; for full details.</source>
          <target state="translated">如果该视图旨在提供行级安全性，则应使用此方法。有关完整详细信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/rules-privileges.html&quot;&gt;第40.5节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ba8bb8c29738e1638f51e3c6948a3404fcdfbaa0" translate="yes" xml:space="preserve">
          <source>This should be used if the view is intended to provide row-level security. See &lt;a href=&quot;https://www.postgresql.org/docs/13/rules-privileges.html&quot;&gt;Section 40.5&lt;/a&gt; for full details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="207a8bf754b11f0d0bc92abd250767a3408a12a5" translate="yes" xml:space="preserve">
          <source>This should give:</source>
          <target state="translated">这应该给。</target>
        </trans-unit>
        <trans-unit id="8430336b76d6ed211113aaafd34defc44406bde4" translate="yes" xml:space="preserve">
          <source>This simple example is like an inner join on &lt;code&gt;col2&lt;/code&gt;, but it produces at most one output row for each &lt;code&gt;tab1&lt;/code&gt; row, even if there are several matching &lt;code&gt;tab2&lt;/code&gt; rows:</source>
          <target state="translated">这个简单的示例就像 &lt;code&gt;col2&lt;/code&gt; 上的内部联接一样，但是即使有几个匹配的 &lt;code&gt;tab2&lt;/code&gt; 行，它也为每个 &lt;code&gt;tab1&lt;/code&gt; 行最多生成一个输出行：</target>
        </trans-unit>
        <trans-unit id="ef082c18dfaad5c1a6c1b5da836306677be5d419" translate="yes" xml:space="preserve">
          <source>This situation might arise from use of a view that contains a join; the view's &lt;code&gt;SELECT&lt;/code&gt; rule will be inserted in place of the view reference, yielding a query much like the above. Normally, the planner will try to collapse the subquery into the parent, yielding:</source>
          <target state="translated">这种情况可能是由于使用包含联接的视图引起的。该视图的 &lt;code&gt;SELECT&lt;/code&gt; 规则将插入到视图引用的位置，从而产生类似于上面的查询。通常，计划者将尝试将子查询折叠到父查询中，从而得到：</target>
        </trans-unit>
        <trans-unit id="a39e33486ee442780bd96095dc0388345e0cdf9e" translate="yes" xml:space="preserve">
          <source>This solution requires that index scans be &amp;ldquo;synchronous&amp;rdquo;: we have to fetch each heap tuple immediately after scanning the corresponding index entry. This is expensive for a number of reasons. An &amp;ldquo;asynchronous&amp;rdquo; scan in which we collect many TIDs from the index, and only visit the heap tuples sometime later, requires much less index locking overhead and can allow a more efficient heap access pattern. Per the above analysis, we must use the synchronous approach for non-MVCC-compliant snapshots, but an asynchronous scan is workable for a query using an MVCC snapshot.</source>
          <target state="translated">此解决方案要求索引扫描是&amp;ldquo;同步的&amp;rdquo;：我们必须在扫描相应的索引条目后立即获取每个堆元组。由于许多原因，这很昂贵。 &amp;ldquo;异步&amp;rdquo;扫描中，我们从索引中收集了许多TID，并且仅在以后的某个时间访问堆元组，它需要的索引锁定开销要少得多，并且可以提供更有效的堆访问模式。根据以上分析，我们必须对不符合MVCC的快照使用同步方法，但是对于使用MVCC快照的查询，异步扫描是可行的。</target>
        </trans-unit>
        <trans-unit id="58431f9279cf2f016596c7e33d4276e32dc1fc57" translate="yes" xml:space="preserve">
          <source>This sort of arrangement gives a unique name for each configuration file variation. This can help eliminate ambiguity when several servers have their configurations all stored in one place, such as in a version control repository. (Storing database configuration files under version control is another good practice to consider.)</source>
          <target state="translated">这种安排为每个配置文件的变化提供了一个独特的名称。当几台服务器的配置都存储在一个地方时,例如在版本控制仓库中,这可以帮助消除歧义。将数据库配置文件存储在版本控制下是另一种值得考虑的好做法)。</target>
        </trans-unit>
        <trans-unit id="9da156a75ef112b4defafc29639879cb4c7837ee" translate="yes" xml:space="preserve">
          <source>This specifies that the combination of values in the indicated columns is unique across the whole table, though any one of the columns need not be (and ordinarily isn't) unique.</source>
          <target state="translated">这指定了指定列中的值的组合在整个表中是唯一的,尽管任何一列不需要(通常也不是)唯一。</target>
        </trans-unit>
        <trans-unit id="50433f72840feb7b225965b424dc31d63bcc0468" translate="yes" xml:space="preserve">
          <source>This specifies whether the trigger function should be fired once for every row affected by the trigger event, or just once per SQL statement. If neither is specified, &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt; is the default. Constraint triggers can only be specified &lt;code&gt;FOR EACH ROW&lt;/code&gt;.</source>
          <target state="translated">这指定是针对受触发事件影响的每一行触发一次触发函数，还是针对每个SQL语句仅触发一次。如果未指定，则 &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt; 是默认值。约束触发器只能指定 &lt;code&gt;FOR EACH ROW&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="65ec2d513cde79958e874b751ab72a29f3d98df0" translate="yes" xml:space="preserve">
          <source>This standby's &lt;code&gt;xmin&lt;/code&gt; horizon reported by &lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY-FEEDBACK&quot;&gt;hot_standby_feedback&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY-FEEDBACK&quot;&gt;hot_standby_feedback&lt;/a&gt;报告此备用数据库的 &lt;code&gt;xmin&lt;/code&gt; 范围。</target>
        </trans-unit>
        <trans-unit id="a5eb77416f4fbff585a0d52973a7eb52599177c4" translate="yes" xml:space="preserve">
          <source>This statement is partially compatible with the &lt;code&gt;ALTER FUNCTION&lt;/code&gt; statement in the SQL standard. The standard allows more properties of a function to be modified, but does not provide the ability to rename a function, make a function a security definer, attach configuration parameter values to a function, or change the owner, schema, or volatility of a function. The standard also requires the &lt;code&gt;RESTRICT&lt;/code&gt; key word, which is optional in PostgreSQL.</source>
          <target state="translated">该语句与SQL标准中的 &lt;code&gt;ALTER FUNCTION&lt;/code&gt; 语句部分兼容。该标准允许修改功能的更多属性，但不提供重命名功能，将功能设置为安全定义程序，将配置参数值附加到功能或更改功能的所有者，架构或易变性的功能。 。该标准还需要 &lt;code&gt;RESTRICT&lt;/code&gt; 关键字，该关键字在PostgreSQL中是可选的。</target>
        </trans-unit>
        <trans-unit id="bab59343a0c1e996fdb8d33ae8133f4f89f5db11" translate="yes" xml:space="preserve">
          <source>This statement is partially compatible with the &lt;code&gt;ALTER PROCEDURE&lt;/code&gt; statement in the SQL standard. The standard allows more properties of a procedure to be modified, but does not provide the ability to rename a procedure, make a procedure a security definer, attach configuration parameter values to a procedure, or change the owner, schema, or volatility of a procedure. The standard also requires the &lt;code&gt;RESTRICT&lt;/code&gt; key word, which is optional in PostgreSQL.</source>
          <target state="translated">该语句与SQL标准中的 &lt;code&gt;ALTER PROCEDURE&lt;/code&gt; 语句部分兼容。该标准允许修改过程的更多属性，但不提供重命名过程，使过程成为安全定义程序，将配置参数值附加到过程或更改过程的所有者，模式或易变性的功能。 。该标准还需要 &lt;code&gt;RESTRICT&lt;/code&gt; 关键字，该关键字在PostgreSQL中是可选的。</target>
        </trans-unit>
        <trans-unit id="67eeb572930074f1aa2002423769801647479601" translate="yes" xml:space="preserve">
          <source>This statement is partially compatible with the &lt;code&gt;ALTER ROUTINE&lt;/code&gt; statement in the SQL standard. See under &lt;a href=&quot;sql-alterfunction&quot;&gt;ALTER FUNCTION&lt;/a&gt; and &lt;a href=&quot;sql-alterprocedure&quot;&gt;ALTER PROCEDURE&lt;/a&gt; for more details. Allowing routine names to refer to aggregate functions is a PostgreSQL extension.</source>
          <target state="translated">该语句与SQL标准中的 &lt;code&gt;ALTER ROUTINE&lt;/code&gt; 语句部分兼容。有关更多详细信息，请参见&amp;ldquo; &lt;a href=&quot;sql-alterfunction&quot;&gt;ALTER FUNCTION&amp;rdquo;&lt;/a&gt;和&amp;ldquo; &lt;a href=&quot;sql-alterprocedure&quot;&gt;ALTER PROCEDURE&lt;/a&gt; &amp;rdquo;下的内容。允许例程名称引用聚合函数是PostgreSQL扩展。</target>
        </trans-unit>
        <trans-unit id="18979809699a0da3f5c4a5180cc7bf11bc2207bc" translate="yes" xml:space="preserve">
          <source>This syntax is also available in PostgreSQL.</source>
          <target state="translated">这种语法在PostgreSQL中也可以使用。</target>
        </trans-unit>
        <trans-unit id="90c440913cb92e8f17aef62117fa623f19d86749" translate="yes" xml:space="preserve">
          <source>This syntax is not as commonly used as the one above, but we show it here to help you understand the following topics.</source>
          <target state="translated">这个语法不像上面的语法那样常用,但我们在这里展示它来帮助你理解下面的主题。</target>
        </trans-unit>
        <trans-unit id="5b79ba66ac4c531cc13f46e2424e3fe201d124e6" translate="yes" xml:space="preserve">
          <source>This table sampling method accepts a single floating-point argument that is the maximum number of milliseconds to spend reading the table. This gives you direct control over how long the query takes, at the price that the size of the sample becomes hard to predict. The resulting sample will contain as many rows as could be read in the specified time, unless the whole table has been read first.</source>
          <target state="translated">这个表抽样方法接受一个浮点参数,这个参数是读取表的最大毫秒数。这使你可以直接控制查询所需的时间,但代价是样本的大小变得难以预测。所得到的样本将包含在指定时间内可以读取的行数,除非整个表已经被先读取。</target>
        </trans-unit>
        <trans-unit id="5d13a701183ff5565141456253121184e55459bd" translate="yes" xml:space="preserve">
          <source>This table sampling method accepts a single integer argument that is the maximum number of rows to read. The resulting sample will always contain exactly that many rows, unless the table does not contain enough rows, in which case the whole table is selected.</source>
          <target state="translated">这个表格取样方法接受一个整数参数,这个参数是要读取的最大行数。所得的样本将始终包含恰好相同的行数,除非表的行数不够,在这种情况下,整个表都会被选中。</target>
        </trans-unit>
        <trans-unit id="e5f2abc30d834e5b2c40918a5861662c490e2353" translate="yes" xml:space="preserve">
          <source>This technique can be used with &lt;code&gt;UNIQUE&lt;/code&gt; and &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraints too; the indexes are created implicitly when the constraint is created. Example:</source>
          <target state="translated">该技术也可以与 &lt;code&gt;UNIQUE&lt;/code&gt; 和 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 约束一起使用。创建约束时隐式创建索引。例：</target>
        </trans-unit>
        <trans-unit id="3d162e1cfd2d4961b90fb7a1a7999e3946102a8e" translate="yes" xml:space="preserve">
          <source>This tells the function handler how to invoke the function. It might be the actual source code of the function for interpreted languages, a link symbol, a file name, or just about anything else, depending on the implementation language/call convention.</source>
          <target state="translated">它告诉函数处理程序如何调用函数。它可能是解释语言中函数的实际源代码,一个链接符号,一个文件名,或者其他任何东西,这取决于实现语言/调用惯例。</target>
        </trans-unit>
        <trans-unit id="72d8bd7d6c5c610d060a644d5f6d4b8415bd748f" translate="yes" xml:space="preserve">
          <source>This term is also used to refer to some multi-step queries to mean that the data resulting from executing a given step is stored in memory (with the possibility of spilling to disk), so that it can be read multiple times by another step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42eb8ea69f4fadfd409e3ec9f1c7e2ee2c91d332" translate="yes" xml:space="preserve">
          <source>This term is sometimes used to refer to an instance or to a host.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dac95036f8bd7557b8674ac649d38c8259cd51f" translate="yes" xml:space="preserve">
          <source>This term is used in &lt;a href=&quot;glossary#GLOSSARY-MATERIALIZED-VIEW&quot;&gt;materialized view&lt;/a&gt;, to mean that the data derived from the view's query is stored on disk separately from the sources of that data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="952d3091870b548dd58edb38d79a5b0fc4d8774a" translate="yes" xml:space="preserve">
          <source>This terminates backup mode. On a primary, it also performs an automatic switch to the next WAL segment. On a standby, it is not possible to automatically switch WAL segments, so you may wish to run &lt;code&gt;pg_switch_wal&lt;/code&gt; on the primary to perform a manual switch. The reason for the switch is to arrange for the last WAL segment file written during the backup interval to be ready to archive.</source>
          <target state="translated">这将终止备份模式。在主数据库上，它还会自动切换到下一个WAL段。在备用数据库上，无法自动切换WAL段，因此您可能希望在主 &lt;code&gt;pg_switch_wal&lt;/code&gt; 上运行pg_switch_wal来执行手动切换。进行此切换的原因是安排备份间隔期间写入的最后一个WAL段文件准备好存档。</target>
        </trans-unit>
        <trans-unit id="c97b686a9ecca6b8afcf92aa63be38096470c601" translate="yes" xml:space="preserve">
          <source>This timestamp could validly be rendered as either 2:30 UTC-4 or 1:30 UTC-5; the timestamp output code chooses the latter.</source>
          <target state="translated">该时间戳可以有效地呈现为2:30 UTC-4或1:30 UTC-5;时间戳输出代码选择后者。</target>
        </trans-unit>
        <trans-unit id="5bfd78cb22d7d6657a7d8e56f10eceb750ab13b4" translate="yes" xml:space="preserve">
          <source>This type of index is most useful when a table has many attributes and queries test arbitrary combinations of them. A traditional btree index is faster than a bloom index, but it can require many btree indexes to support all possible queries where one needs only a single bloom index. Note however that bloom indexes only support equality queries, whereas btree indexes can also perform inequality and range searches.</source>
          <target state="translated">当一个表有很多属性,并且查询测试这些属性的任意组合时,这种类型的索引最有用。传统的btree索引比bloom索引快,但它可能需要许多btree索引来支持所有可能的查询,而我们只需要一个bloom索引。但是请注意,bloom索引只支持平等查询,而btree索引也可以执行不平等和范围搜索。</target>
        </trans-unit>
        <trans-unit id="a47ad5551aa3274bc0c3233a9d21f8ee9873b817" translate="yes" xml:space="preserve">
          <source>This usually means just what it suggests: you tried to start another server on the same port where one is already running. However, if the kernel error message is not &lt;code&gt;Address already in use&lt;/code&gt; or some variant of that, there might be a different problem. For example, trying to start a server on a reserved port number might draw something like:</source>
          <target state="translated">这通常意味着它的含义：您试图在已运行同一端口的另一台服务器上启动另一台服务器。但是，如果内核错误消息不是 &lt;code&gt;Address already in use&lt;/code&gt; 或该地址的某种变体，则可能存在其他问题。例如，尝试在保留的端口号上启动服务器可能会画出以下内容：</target>
        </trans-unit>
        <trans-unit id="3923b38241d597877e4759e25323172e3016ea9a" translate="yes" xml:space="preserve">
          <source>This usually results in a better plan than planning the subquery separately. (For example, the outer &lt;code&gt;WHERE&lt;/code&gt; conditions might be such that joining X to A first eliminates many rows of A, thus avoiding the need to form the full logical output of the subquery.) But at the same time, we have increased the planning time; here, we have a five-way join problem replacing two separate three-way join problems. Because of the exponential growth of the number of possibilities, this makes a big difference. The planner tries to avoid getting stuck in huge join search problems by not collapsing a subquery if more than &lt;code&gt;from_collapse_limit&lt;/code&gt;&lt;code&gt;FROM&lt;/code&gt; items would result in the parent query. You can trade off planning time against quality of plan by adjusting this run-time parameter up or down.</source>
          <target state="translated">与单独计划子查询相比，这通常会导致更好的计划。 （例如，外部 &lt;code&gt;WHERE&lt;/code&gt; 条件可能使得首先将X连接到A消除了A的许多行，从而避免了形成子查询的完整逻辑输出的需要。）但是，与此同时，我们增加了计划时间;在这里，我们有一个五向联接问题，代替了两个单独的三向联接问题。由于可能性数量呈指数增长，因此差异很大。如果超过 &lt;code&gt;from_collapse_limit&lt;/code&gt; &lt;code&gt;FROM&lt;/code&gt; 项会导致父查询失败，那么计划者将通过不折叠子查询来避免陷入巨大的联接搜索问题。您可以通过向上或向下调整运行时间参数来权衡计划时间与计划质量。</target>
        </trans-unit>
        <trans-unit id="f7d3526fb85f461f5326ed5d5597e3881ab88546" translate="yes" xml:space="preserve">
          <source>This utility can only be run by the user who initialized the cluster because it requires read access to the data directory. You can specify the data directory on the command line, or use the environment variable &lt;code&gt;PGDATA&lt;/code&gt;. This utility supports the options &lt;code&gt;-V&lt;/code&gt; and &lt;code&gt;--version&lt;/code&gt;, which print the pg_controldata version and exit. It also supports options &lt;code&gt;-?&lt;/code&gt; and &lt;code&gt;--help&lt;/code&gt;, which output the supported arguments.</source>
          <target state="translated">该实用程序只能由初始化集群的用户运行，因为它需要对数据目录的读取访问权限。您可以在命令行上指定数据目录，或使用环境变量 &lt;code&gt;PGDATA&lt;/code&gt; 。该实用程序支持 &lt;code&gt;-V&lt;/code&gt; 和 &lt;code&gt;--version&lt;/code&gt; 选项，这些选项可打印pg_controldata版本并退出。它还支持选项 &lt;code&gt;-?&lt;/code&gt; 和 &lt;code&gt;--help&lt;/code&gt; ，输出支持的参数。</target>
        </trans-unit>
        <trans-unit id="23e7baae96eaae6ec7f8f90d39ec37038a1d3983" translate="yes" xml:space="preserve">
          <source>This utility can only be run by the user who installed the server, because it requires read-only access to the data directory.</source>
          <target state="translated">该实用程序只能由安装服务器的用户运行,因为它需要对数据目录的只读访问。</target>
        </trans-unit>
        <trans-unit id="63c8b87fb5e6f05eb7f41b9abcb56cbe448e2808" translate="yes" xml:space="preserve">
          <source>This utility can only be run by the user who installed the server, because it requires read/write access to the data directory. For safety reasons, you must specify the data directory on the command line. &lt;code&gt;pg_resetwal&lt;/code&gt; does not use the environment variable &lt;code&gt;PGDATA&lt;/code&gt;.</source>
          <target state="translated">该实用程序只能由安装服务器的用户运行，因为它需要对数据目录的读/写访问权限。出于安全原因，必须在命令行上指定数据目录。 &lt;code&gt;pg_resetwal&lt;/code&gt; 不使用环境变量 &lt;code&gt;PGDATA&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e50692fa3aa9f732d24bdd19e107158cb244fbb0" translate="yes" xml:space="preserve">
          <source>This utility, like most other PostgreSQL utilities, also uses the environment variables supported by libpq (see &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;).</source>
          <target state="translated">与大多数其他PostgreSQL实用程序一样，该实用程序也使用libpq支持的环境变量（请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;第33.14节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="22f89c28349abae20f5bec16bf71f19805aa29b4" translate="yes" xml:space="preserve">
          <source>This utility, like most other PostgreSQL utilities, also uses the environment variables supported by libpq (see &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;). However, it does not read &lt;code&gt;PGDATABASE&lt;/code&gt; when a database name is not supplied.</source>
          <target state="translated">与大多数其他PostgreSQL实用程序一样，该实用程序也使用libpq支持的环境变量（请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;第33.14节&lt;/a&gt;）。但是，未提供数据库名称时，它不会读取 &lt;code&gt;PGDATABASE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ebba67bddc3774511062564b5b840a56795391c" translate="yes" xml:space="preserve">
          <source>This utility, like most other PostgreSQL utilities, also uses the environment variables supported by libpq (see &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba59d34f5f61746151b52a91611a5ea9de2d786e" translate="yes" xml:space="preserve">
          <source>This utility, like most other PostgreSQL utilities, also uses the environment variables supported by libpq (see &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;). However, it does not read &lt;code&gt;PGDATABASE&lt;/code&gt; when a database name is not supplied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f64ddd714f65036056a8efca366deffd5cb8370" translate="yes" xml:space="preserve">
          <source>This utility, like most other PostgreSQL utilities, uses the environment variables supported by libpq (see &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;).</source>
          <target state="translated">与大多数其他PostgreSQL实用程序一样，该实用程序使用libpq支持的环境变量（请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;第33.14节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6a43c517a861a8d1e9432380381094a29b0e1db6" translate="yes" xml:space="preserve">
          <source>This utility, like most other PostgreSQL utilities, uses the environment variables supported by libpq (see &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="891e0f3b431a5b76a5e7675d6f5b4cfd398567dc" translate="yes" xml:space="preserve">
          <source>This value is the default.</source>
          <target state="translated">此值为默认值。</target>
        </trans-unit>
        <trans-unit id="6e84fec0574a10e039e309ea4e9bfbbae84d5f20" translate="yes" xml:space="preserve">
          <source>This variable can be set to the values &lt;code&gt;default&lt;/code&gt;, &lt;code&gt;verbose&lt;/code&gt;, &lt;code&gt;terse&lt;/code&gt;, or &lt;code&gt;sqlstate&lt;/code&gt; to control the verbosity of error reports. (See also &lt;code&gt;\errverbose&lt;/code&gt;, for use when you want a verbose version of the error you just got.)</source>
          <target state="translated">可以将此变量设置为值 &lt;code&gt;default&lt;/code&gt; ， &lt;code&gt;verbose&lt;/code&gt; ， &lt;code&gt;terse&lt;/code&gt; 或 &lt;code&gt;sqlstate&lt;/code&gt; ,以控制错误报告的详细程度。 （另请参见 &lt;code&gt;\errverbose&lt;/code&gt; ，用于当您想要刚刚得到的错误的详细版本时使用。）</target>
        </trans-unit>
        <trans-unit id="b047288ac9be4f5ef83b6fcef3edce3028098d1c" translate="yes" xml:space="preserve">
          <source>This variable can be set to the values &lt;code&gt;never&lt;/code&gt;, &lt;code&gt;errors&lt;/code&gt;, or &lt;code&gt;always&lt;/code&gt; to control whether &lt;code&gt;CONTEXT&lt;/code&gt; fields are displayed in messages from the server. The default is &lt;code&gt;errors&lt;/code&gt; (meaning that context will be shown in error messages, but not in notice or warning messages). This setting has no effect when &lt;code&gt;VERBOSITY&lt;/code&gt; is set to &lt;code&gt;terse&lt;/code&gt; or &lt;code&gt;sqlstate&lt;/code&gt;. (See also &lt;code&gt;\errverbose&lt;/code&gt;, for use when you want a verbose version of the error you just got.)</source>
          <target state="translated">可以将此变量设置为值 &lt;code&gt;never&lt;/code&gt; ， &lt;code&gt;errors&lt;/code&gt; 或 &lt;code&gt;always&lt;/code&gt; ,以控制是否在服务器消息中显示 &lt;code&gt;CONTEXT&lt;/code&gt; 字段。默认值为 &lt;code&gt;errors&lt;/code&gt; （意味着上下文将显示在错误消息中，而不显示在通知或警告消息中）。此设置没有任何效果 &lt;code&gt;VERBOSITY&lt;/code&gt; 设置为 &lt;code&gt;terse&lt;/code&gt; 或 &lt;code&gt;sqlstate&lt;/code&gt; 。 （另请参见 &lt;code&gt;\errverbose&lt;/code&gt; ，用于当您想要刚刚得到的错误的详细版本时使用。）</target>
        </trans-unit>
        <trans-unit id="8ec30cffc79914e7e50180450597583323f64746" translate="yes" xml:space="preserve">
          <source>This variable controls whether to raise an error in lieu of applying a row security policy. When set to &lt;code&gt;on&lt;/code&gt;, policies apply normally. When set to &lt;code&gt;off&lt;/code&gt;, queries fail which would otherwise apply at least one policy. The default is &lt;code&gt;on&lt;/code&gt;. Change to &lt;code&gt;off&lt;/code&gt; where limited row visibility could cause incorrect results; for example, pg_dump makes that change by default. This variable has no effect on roles which bypass every row security policy, to wit, superusers and roles with the &lt;code&gt;BYPASSRLS&lt;/code&gt; attribute.</source>
          <target state="translated">该变量控制是否代替应用行安全策略而引发错误。设置为 &lt;code&gt;on&lt;/code&gt; 时，策略将正常应用。设置为 &lt;code&gt;off&lt;/code&gt; 时，查询将失败，否则将应用至少一种策略。默认值为 &lt;code&gt;on&lt;/code&gt; 。更改为 &lt;code&gt;off&lt;/code&gt; ，以限制行可见性可能导致错误的结果；例如，pg_dump默认进行更改。此变量对绕过每行安全策略的角色，具有 &lt;code&gt;BYPASSRLS&lt;/code&gt; 属性的机智，超级用户和角色没有影响。</target>
        </trans-unit>
        <trans-unit id="3a6e57232329d24f7b297105fcb53de791463fcf" translate="yes" xml:space="preserve">
          <source>This variable is also not used when creating databases. By default, a new database inherits its tablespace setting from the template database it is copied from.</source>
          <target state="translated">创建数据库时也不使用这个变量。默认情况下,新数据库会从它所复制的模板数据库中继承其表空间设置。</target>
        </trans-unit>
        <trans-unit id="96dcd0eeb5a806520fa3d76a941adb54cde586df" translate="yes" xml:space="preserve">
          <source>This variable is not used for temporary tables; for them, &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt; is consulted instead.</source>
          <target state="translated">该变量不用于临时表。对于他们，将参考&lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c9610b064ff12036d0dbbd211a65bbda376efe2c" translate="yes" xml:space="preserve">
          <source>This variable is the name of the JIT provider library to be used (see &lt;a href=&quot;jit-extensibility#JIT-PLUGGABLE&quot;&gt;Section 31.4.2&lt;/a&gt;). The default is &lt;code&gt;llvmjit&lt;/code&gt;. This parameter can only be set at server start.</source>
          <target state="translated">此变量是要使用的JIT提供程序库的名称（请参见&lt;a href=&quot;jit-extensibility#JIT-PLUGGABLE&quot;&gt;第31.4.2节&lt;/a&gt;）。默认值为 &lt;code&gt;llvmjit&lt;/code&gt; 。该参数只能在服务器启动时设置。</target>
        </trans-unit>
        <trans-unit id="e6364d91b8c705de69fb141059f0b5ecd041ff5d" translate="yes" xml:space="preserve">
          <source>This variable specifies one or more shared libraries that are to be preloaded at connection start. It contains a comma-separated list of library names, where each name is interpreted as for the &lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt; command. Whitespace between entries is ignored; surround a library name with double quotes if you need to include whitespace or commas in the name. The parameter value only takes effect at the start of the connection. Subsequent changes have no effect. If a specified library is not found, the connection attempt will fail.</source>
          <target state="translated">此变量指定在连接开始时要预加载的一个或多个共享库。它包含以逗号分隔的库名称列表，其中每个名称的解释与&lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt;命令相同。条目之间的空格将被忽略；如果您需要在库名称中包含空格或逗号，请用双引号引起来。参数值仅在连接开始时生效。后续更改无效。如果找不到指定的库，则连接尝试将失败。</target>
        </trans-unit>
        <trans-unit id="2cd177877be9e8c77ea886c4ef3d6df8ca9e8ff0" translate="yes" xml:space="preserve">
          <source>This variable specifies one or more shared libraries that are to be preloaded at connection start. It contains a comma-separated list of library names, where each name is interpreted as for the &lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt; command. Whitespace between entries is ignored; surround a library name with double quotes if you need to include whitespace or commas in the name. The parameter value only takes effect at the start of the connection. Subsequent changes have no effect. If a specified library is not found, the connection attempt will fail. Only superusers can change this setting.</source>
          <target state="translated">此变量指定在连接开始时要预加载的一个或多个共享库。它包含以逗号分隔的库名称列表，其中每个名称的解释与&lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt;命令相同。条目之间的空格将被忽略；如果您需要在库名称中包含空格或逗号，请用双引号引起来。参数值仅在连接开始时生效。后续更改无效。如果找不到指定的库，则连接尝试将失败。只有超级用户可以更改此设置。</target>
        </trans-unit>
        <trans-unit id="9894de0e5352de9dfea84284d95098f1e2c92234" translate="yes" xml:space="preserve">
          <source>This variable specifies one or more shared libraries to be preloaded at server start. It contains a comma-separated list of library names, where each name is interpreted as for the &lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt; command. Whitespace between entries is ignored; surround a library name with double quotes if you need to include whitespace or commas in the name. This parameter can only be set at server start. If a specified library is not found, the server will fail to start.</source>
          <target state="translated">此变量指定服务器启动时要预加载的一个或多个共享库。它包含以逗号分隔的库名称列表，其中每个名称的解释与&lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt;命令相同。条目之间的空格将被忽略；如果您需要在库名称中包含空格或逗号，请用双引号引起来。该参数只能在服务器启动时设置。如果找不到指定的库，则服务器将无法启动。</target>
        </trans-unit>
        <trans-unit id="a6a915d9ae632e6aef6922feee6cf3ba5d4a2ff6" translate="yes" xml:space="preserve">
          <source>This variable specifies tablespaces in which to create temporary objects (temp tables and indexes on temp tables) when a &lt;code&gt;CREATE&lt;/code&gt; command does not explicitly specify a tablespace. Temporary files for purposes such as sorting large data sets are also created in these tablespaces.</source>
          <target state="translated">当 &lt;code&gt;CREATE&lt;/code&gt; 命令未明确指定表空间时，此变量指定在其中创建临时对象（临时表和临时表上的索引）的表空间。在这些表空间中还创建了用于排序大型数据集等目的的临时文件。</target>
        </trans-unit>
        <trans-unit id="f5d218762619bb59129fccf6c7fc7392957b7115" translate="yes" xml:space="preserve">
          <source>This variable specifies the default tablespace in which to create objects (tables and indexes) when a &lt;code&gt;CREATE&lt;/code&gt; command does not explicitly specify a tablespace. It also determines the tablespace that a partitioned relation will direct future partitions to.</source>
          <target state="translated">当 &lt;code&gt;CREATE&lt;/code&gt; 命令未明确指定表空间时，此变量指定在其中创建对象（表和索引）的默认表空间。它还确定分区关系将将来的分区定向到的表空间。</target>
        </trans-unit>
        <trans-unit id="aa9f42e1d0645607acfe05a083c6feee4e9b8b48" translate="yes" xml:space="preserve">
          <source>This variable specifies the order in which schemas are searched when an object (table, data type, function, etc.) is referenced by a simple name with no schema specified. When there are objects of identical names in different schemas, the one found first in the search path is used. An object that is not in any of the schemas in the search path can only be referenced by specifying its containing schema with a qualified (dotted) name.</source>
          <target state="translated">这个变量指定了当一个对象(表、数据类型、函数等)被简单的名称引用而没有指定模式时,模式的搜索顺序。当不同模式中存在名称相同的对象时,将使用在搜索路径中最先找到的对象。一个不在搜索路径中任何一个模式中的对象,只能通过用限定(点)名指定其包含的模式来引用。</target>
        </trans-unit>
        <trans-unit id="5053ca7743fcc4bdc3ab5765d75a2a61d6e73363" translate="yes" xml:space="preserve">
          <source>This variant of the &lt;code&gt;GRANT&lt;/code&gt; command gives specific privileges on a database object to one or more roles. These privileges are added to those already granted, if any.</source>
          <target state="translated">&lt;code&gt;GRANT&lt;/code&gt; 命令的此变体将一个数据库对象的特定特权授予一个或多个角色。这些特权将添加到已授予的特权（如果有）中。</target>
        </trans-unit>
        <trans-unit id="5fb709052776e6c45691491df6bfccba610d1b30" translate="yes" xml:space="preserve">
          <source>This variant of the &lt;code&gt;GRANT&lt;/code&gt; command grants membership in a role to one or more other roles. Membership in a role is significant because it conveys the privileges granted to a role to each of its members.</source>
          <target state="translated">&lt;code&gt;GRANT&lt;/code&gt; 命令的此变体将一个角色的成员资格授予一个或多个其他角色。角色的成员资格意义重大，因为它可以将授予角色的特权传达给每个成员。</target>
        </trans-unit>
        <trans-unit id="d4d8e8957d26c9fb345fec5b62e4899e915fe79e" translate="yes" xml:space="preserve">
          <source>This view can be helpful for checking whether planned changes in the authentication configuration file will work, or for diagnosing a previous failure. Note that this view reports on the &lt;em&gt;current&lt;/em&gt; contents of the file, not on what was last loaded by the server.</source>
          <target state="translated">该视图有助于检查身份验证配置文件中的计划更改是否将起作用，或者有助于诊断先前的故障。请注意，此视图报告文件的&lt;em&gt;当前&lt;/em&gt;内容，而不报告服务器上次加载的内容。</target>
        </trans-unit>
        <trans-unit id="ded4110d64c07701bd32e461534d6aff35fce772" translate="yes" xml:space="preserve">
          <source>This view is helpful for checking whether planned changes in the configuration files will work, or for diagnosing a previous failure. Note that this view reports on the &lt;em&gt;current&lt;/em&gt; contents of the files, not on what was last applied by the server. (The &lt;a href=&quot;view-pg-settings&quot;&gt;&lt;code&gt;pg_settings&lt;/code&gt;&lt;/a&gt; view is usually sufficient to determine that.)</source>
          <target state="translated">该视图有助于检查配置文件中的计划更改是否将起作用，或者有助于诊断先前的故障。请注意，此视图报告文件的&lt;em&gt;当前&lt;/em&gt;内容，而不报告服务器上一次应用的内容。（&lt;a href=&quot;view-pg-settings&quot;&gt; &lt;code&gt;pg_settings&lt;/code&gt; &lt;/a&gt;视图通常足以确定这一点。）</target>
        </trans-unit>
        <trans-unit id="b5f7617dee4bd0dacfc46b9c395f294c122bc12e" translate="yes" xml:space="preserve">
          <source>This view will support &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt;. All the columns from the &lt;code&gt;films&lt;/code&gt; table will be updatable, whereas the computed columns &lt;code&gt;country&lt;/code&gt; and &lt;code&gt;avg_rating&lt;/code&gt; will be read-only.</source>
          <target state="translated">该视图将支持 &lt;code&gt;INSERT&lt;/code&gt; ， &lt;code&gt;UPDATE&lt;/code&gt; 和 &lt;code&gt;DELETE&lt;/code&gt; 。 &lt;code&gt;films&lt;/code&gt; 表中的所有列都将是可更新的，而计算出的列 &lt;code&gt;country&lt;/code&gt; 和 &lt;code&gt;avg_rating&lt;/code&gt; 将是只读的。</target>
        </trans-unit>
        <trans-unit id="5744bd9bfe826277ab362eee3d81a2f8763c59df" translate="yes" xml:space="preserve">
          <source>This way you can also use LDAP for connection parameter lookup as described in &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-ldap.html&quot;&gt;Section 33.17&lt;/a&gt;. See &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;Section 33.1.2&lt;/a&gt; for more information on all the available connection options.</source>
          <target state="translated">这样，您还可以使用LDAP进行连接参数查找，如&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-ldap.html&quot;&gt;第33.17节&lt;/a&gt;所述。有关所有可用连接选项的更多信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;第33.1.2节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b22d5c1a856e76f215fc30c2a78dfdff1f3c75c1" translate="yes" xml:space="preserve">
          <source>This way you can also use LDAP for connection parameter lookup as described in &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-ldap.html&quot;&gt;Section 33.17&lt;/a&gt;. See &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;Section 33.1.2&lt;/a&gt; for more information on all the available connection options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fc85cb1dbf306614c53ff81c420fe96724ef4bd" translate="yes" xml:space="preserve">
          <source>This wiki page provides a brief overview, security design, architecture, administration and upcoming features.</source>
          <target state="translated">这个维基页面提供了一个简单的概述,安全设计,架构,管理和即将到来的功能。</target>
        </trans-unit>
        <trans-unit id="a7facb549adad733a90a16ab11be82cd587ad267" translate="yes" xml:space="preserve">
          <source>This will also find related words such as &lt;code&gt;friends&lt;/code&gt; and &lt;code&gt;friendly&lt;/code&gt;, since all these are reduced to the same normalized lexeme.</source>
          <target state="translated">由于所有这些都归结为相同的标准化词素，因此还会找到相关的单词，例如 &lt;code&gt;friends&lt;/code&gt; 和 &lt;code&gt;friendly&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ac371241bbb2e0a4e09eb743c54a9583dbf830b" translate="yes" xml:space="preserve">
          <source>This will create a database named &lt;code&gt;korean&lt;/code&gt; that uses the character set &lt;code&gt;EUC_KR&lt;/code&gt;, and locale &lt;code&gt;ko_KR&lt;/code&gt;. Another way to accomplish this is to use this SQL command:</source>
          <target state="translated">这将创建一个名为 &lt;code&gt;korean&lt;/code&gt; 的数据库，该数据库使用字符集 &lt;code&gt;EUC_KR&lt;/code&gt; 和语言环境 &lt;code&gt;ko_KR&lt;/code&gt; 。完成此操作的另一种方法是使用以下SQL命令：</target>
        </trans-unit>
        <trans-unit id="fcc2d5a65486c9c94a37090b57dae833aa54736a" translate="yes" xml:space="preserve">
          <source>This will create a table with one row per left item, and an array of right items. Now this is pretty useless without some way of using the array; that's why there is an array enumerator. You can do</source>
          <target state="translated">这将创建一个表格,每个左项有一行,右项有一个数组。如果没有使用数组的方法,这是很无用的;这就是为什么有一个数组枚举器。你可以用</target>
        </trans-unit>
        <trans-unit id="456202e5286a667b495d0d080a420980563fc127" translate="yes" xml:space="preserve">
          <source>This will create a view based on the &lt;code&gt;comedies&lt;/code&gt; view, showing only films with &lt;code&gt;kind = 'Comedy'&lt;/code&gt; and &lt;code&gt;classification = 'U'&lt;/code&gt;. Any attempt to &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; a row in the view will be rejected if the new row doesn't have &lt;code&gt;classification = 'U'&lt;/code&gt;, but the film &lt;code&gt;kind&lt;/code&gt; will not be checked.</source>
          <target state="translated">这将基于 &lt;code&gt;comedies&lt;/code&gt; 视图创建一个视图，仅显示 &lt;code&gt;kind = 'Comedy'&lt;/code&gt; 和 &lt;code&gt;classification = 'U'&lt;/code&gt; 电影。如果新行的 &lt;code&gt;classification = 'U'&lt;/code&gt; ，则对视图中的行进行 &lt;code&gt;INSERT&lt;/code&gt; 或 &lt;code&gt;UPDATE&lt;/code&gt; 的任何尝试都将被拒绝，但是不会检查胶片的 &lt;code&gt;kind&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b7310496c1ef4e42c77607893ab0567ee3cd08f0" translate="yes" xml:space="preserve">
          <source>This will create a view containing the columns that are in the &lt;code&gt;film&lt;/code&gt; table at the time of view creation. Though &lt;code&gt;*&lt;/code&gt; was used to create the view, columns added later to the table will not be part of the view.</source>
          <target state="translated">这将创建一个视图，其中包含在创建视图时 &lt;code&gt;film&lt;/code&gt; 表中的列。尽管使用 &lt;code&gt;*&lt;/code&gt; 来创建视图，但是稍后添加到表中的列将不属于视图。</target>
        </trans-unit>
        <trans-unit id="ec4f0e34512b88917e6ee4edf638401662483cd5" translate="yes" xml:space="preserve">
          <source>This will create a view that checks both the &lt;code&gt;kind&lt;/code&gt; and &lt;code&gt;classification&lt;/code&gt; of new rows.</source>
          <target state="translated">这将创建一个检查新行的 &lt;code&gt;kind&lt;/code&gt; 和 &lt;code&gt;classification&lt;/code&gt; 的视图。</target>
        </trans-unit>
        <trans-unit id="80307af5f039905f035882871ac20bb16cdaf4a5" translate="yes" xml:space="preserve">
          <source>This will fail if the current user has no permissions to terminate other connections. Required permissions are the same as with &lt;code&gt;pg_terminate_backend&lt;/code&gt;, described in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-SIGNAL&quot;&gt;Section 9.27.2&lt;/a&gt;. This will also fail if we are not able to terminate connections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4e6c3b1ee3c6ae0ce592e53fe304140df76442d" translate="yes" xml:space="preserve">
          <source>This will match paths that contain the label &lt;code&gt;Europe&lt;/code&gt; and any label beginning with &lt;code&gt;Russia&lt;/code&gt; (case-insensitive), but not paths containing the label &lt;code&gt;Transportation&lt;/code&gt;. The location of these words within the path is not important. Also, when &lt;code&gt;%&lt;/code&gt; is used, the word can be matched to any underscore-separated word within a label, regardless of position.</source>
          <target state="translated">这将匹配包含标签 &lt;code&gt;Europe&lt;/code&gt; 的路径和任何以 &lt;code&gt;Russia&lt;/code&gt; 开头的标签（不区分大小写），但不包含包含 &lt;code&gt;Transportation&lt;/code&gt; 标签的路径。这些单词在路径中的位置并不重要。同样，当使用 &lt;code&gt;%&lt;/code&gt; 时，该单词可以与标签中任何下划线分隔的单词匹配，而与位置无关。</target>
        </trans-unit>
        <trans-unit id="7070480e63fc28db9b2bfc400f51e909df548e18" translate="yes" xml:space="preserve">
          <source>This will not work since the name &lt;code&gt;item&lt;/code&gt; is taken to be a table name, not a column name of &lt;code&gt;on_hand&lt;/code&gt;, per SQL syntax rules. You must write it like this:</source>
          <target state="translated">这将不起作用，因为按照SQL语法规则，名称 &lt;code&gt;item&lt;/code&gt; 被视为表名，而不是 &lt;code&gt;on_hand&lt;/code&gt; 的列名。您必须这样写：</target>
        </trans-unit>
        <trans-unit id="dc724810451e07ee1624d0d89bd9f99d8b85081f" translate="yes" xml:space="preserve">
          <source>This will produce a result something like:</source>
          <target state="translated">这将产生一个类似的结果。</target>
        </trans-unit>
        <trans-unit id="cc934f85b42e420c854cb082c555601046530eec" translate="yes" xml:space="preserve">
          <source>This will return a table of two columns and three rows. It's effectively equivalent to:</source>
          <target state="translated">这将返回一个两列三行的表格。它实际上相当于:</target>
        </trans-unit>
        <trans-unit id="00d87bb57d3abbae7f2092f201fbf64e1ef1e407" translate="yes" xml:space="preserve">
          <source>This will return all the items in the right hand table for an entry in the left hand table. This is a very common construct in SQL.</source>
          <target state="translated">这将为左手表中的一个条目返回右手表中的所有项目。这在SQL中是一个非常常见的结构。</target>
        </trans-unit>
        <trans-unit id="9684b1543ba00fa275566c42af863391caa86e12" translate="yes" xml:space="preserve">
          <source>This will return all values in the text column for which there is a continuous extent in the corresponding ordered trigram set that is sufficiently similar to the trigram set of &lt;code&gt;word&lt;/code&gt;, sorted from best match to worst. The index will be used to make this a fast operation even over very large data sets.</source>
          <target state="translated">这将返回文本列中的所有值，在该列中，对应的有序三字组中有一个连续范围，该范围与 &lt;code&gt;word&lt;/code&gt; 组足够相似，从最佳匹配到最差排序。即使在非常大的数据集上，索引也将用于使此操作快速进行。</target>
        </trans-unit>
        <trans-unit id="9601b6fc7f3154db7fc5d9d05b2c9284f9d222e6" translate="yes" xml:space="preserve">
          <source>This will return all values in the text column that are sufficiently similar to &lt;code&gt;word&lt;/code&gt;, sorted from best match to worst. The index will be used to make this a fast operation even over very large data sets.</source>
          <target state="translated">这将返回text列中与 &lt;code&gt;word&lt;/code&gt; 足够相似的所有值，从最佳匹配到最差排序。即使在非常大的数据集上，索引也将用于使此操作快速进行。</target>
        </trans-unit>
        <trans-unit id="0e0c4ccba178d64fe3f5a4a8f9774cdd12a6ce9f" translate="yes" xml:space="preserve">
          <source>This will save the setting (but not set it immediately). In subsequent connections by this role it will appear as though &lt;code&gt;SET enable_indexscan TO off&lt;/code&gt; had been executed just before the session started. You can still alter this setting during the session; it will only be the default. To remove a role-specific default setting, use &lt;code&gt;ALTER ROLE rolename RESET varname&lt;/code&gt;. Note that role-specific defaults attached to roles without &lt;code&gt;LOGIN&lt;/code&gt; privilege are fairly useless, since they will never be invoked.</source>
          <target state="translated">这将保存设置（但不会立即设置）。在通过该角色进行的后续连接中，将好像在会话开始之前已执行 &lt;code&gt;SET enable_indexscan TO off&lt;/code&gt; 一样。您仍然可以在会话期间更改此设置；它只是默认值。要删除特定于角色的默认设置，请使用 &lt;code&gt;ALTER ROLE rolename RESET varname&lt;/code&gt; 角色名RESET varname。请注意，附加到不具有 &lt;code&gt;LOGIN&lt;/code&gt; 特权的角色的特定于角色的默认设置是相当无用的，因为它们将永远不会被调用。</target>
        </trans-unit>
        <trans-unit id="c957489b768ad1121e70ecf58707bd37aac80d87" translate="yes" xml:space="preserve">
          <source>This will save the setting (but not set it immediately). In subsequent connections to this database it will appear as though &lt;code&gt;SET geqo TO off;&lt;/code&gt; had been executed just before the session started. Note that users can still alter this setting during their sessions; it will only be the default. To undo any such setting, use &lt;code&gt;ALTER DATABASE dbname RESET varname&lt;/code&gt;.</source>
          <target state="translated">这将保存设置（但不会立即设置）。在与该数据库的后续连接中，将好像 &lt;code&gt;SET geqo TO off;&lt;/code&gt; 在会话开始之前已执行。请注意，用户仍可以在会话期间更改此设置。它只是默认值。要撤消任何此类设置，请使用 &lt;code&gt;ALTER DATABASE dbname RESET varname&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e04d0ca6130cc2fa0f50fc16bc721bc9344ebb8a" translate="yes" xml:space="preserve">
          <source>This will succeed only if each existing entry in the column can be converted to the new type by an implicit cast. If a more complex conversion is needed, you can add a &lt;code&gt;USING&lt;/code&gt; clause that specifies how to compute the new values from the old.</source>
          <target state="translated">仅当可以通过隐式强制转换将列中的每个现有条目转换为新类型时，此操作才会成功。如果需要更复杂的转换，则可以添加 &lt;code&gt;USING&lt;/code&gt; 子句，该子句指定如何从旧的值计算新值。</target>
        </trans-unit>
        <trans-unit id="07f6af6a1757ce5004ed8f1bbb0c1ac5b13f2237" translate="yes" xml:space="preserve">
          <source>This will work too:</source>
          <target state="translated">这也可以。</target>
        </trans-unit>
        <trans-unit id="2518d47395fb2d8240dcc264bbc1439e37da1fb7" translate="yes" xml:space="preserve">
          <source>This works OK as far as querying goes, but it gets ugly when you need to update several rows, for one thing.</source>
          <target state="translated">就查询而言,这个方法还行,但是当你需要更新几条记录时,就会变得很丑陋。</target>
        </trans-unit>
        <trans-unit id="745e343b5d1e33e36d85f39d0c717159c4f6b58f" translate="yes" xml:space="preserve">
          <source>This works anywhere a table name is expected, including the table modification commands and the data access commands discussed in the following chapters. (For brevity we will speak of tables only, but the same ideas apply to other kinds of named objects, such as types and functions.)</source>
          <target state="translated">这适用于任何需要表名的地方,包括下面章节中讨论的表修改命令和数据访问命令。为了简洁起见,我们只谈表,但同样的思想也适用于其他类型的命名对象,如类型和函数。</target>
        </trans-unit>
        <trans-unit id="2957424d9ef693c1b1a96a104ee978e9de4983b8" translate="yes" xml:space="preserve">
          <source>This works because PostgreSQL's implementation evaluates only as many rows of a &lt;code&gt;WITH&lt;/code&gt; query as are actually fetched by the parent query. Using this trick in production is not recommended, because other systems might work differently. Also, it usually won't work if you make the outer query sort the recursive query's results or join them to some other table, because in such cases the outer query will usually try to fetch all of the &lt;code&gt;WITH&lt;/code&gt; query's output anyway.</source>
          <target state="translated">之所以可行，是因为PostgreSQL的实现仅对 &lt;code&gt;WITH&lt;/code&gt; 查询的行进行评估，而该行与父查询实际获取的行数相同。不建议在生产中使用此技巧，因为其他系统可能会以不同的方式工作。同样，如果您使外部查询对递归查询的结果进行排序或将它们连接到其他表，则通常将不起作用，因为在这种情况下，外部查询通常将始终尝试获取所有 &lt;code&gt;WITH&lt;/code&gt; 查询的输出。</target>
        </trans-unit>
        <trans-unit id="3f4e84fb95c842771a51ab73c2b062507d6eff5c" translate="yes" xml:space="preserve">
          <source>This works in both regular SQL commands and meta-commands; there is more detail in &lt;a href=&quot;app-psql#APP-PSQL-INTERPOLATION&quot;&gt;SQL Interpolation&lt;/a&gt;, below.</source>
          <target state="translated">这在常规SQL命令和元命令中均有效；在下面的&amp;ldquo; &lt;a href=&quot;app-psql#APP-PSQL-INTERPOLATION&quot;&gt;SQL插值&amp;rdquo;中&lt;/a&gt;有更多详细信息。</target>
        </trans-unit>
        <trans-unit id="94c314a6fc9266b79d71f9330565442779b31db1" translate="yes" xml:space="preserve">
          <source>This works reasonably well, but has a number of drawbacks:</source>
          <target state="translated">这样做的效果还算不错,但也有不少缺点。</target>
        </trans-unit>
        <trans-unit id="fb7380b7f7c690853b919f0af451d457543e80c8" translate="yes" xml:space="preserve">
          <source>This works similarly to the previous example.</source>
          <target state="translated">这与前面的例子类似。</target>
        </trans-unit>
        <trans-unit id="1e6ed82ca645f9e4d9f11c1613a5711464a40bfe" translate="yes" xml:space="preserve">
          <source>This works the same for all constraint types except not-null constraints. To drop a not null constraint use:</source>
          <target state="translated">除了非空约束外,这对所有约束类型都是一样的。要放弃一个非空约束,可以使用。</target>
        </trans-unit>
        <trans-unit id="6c526d5097db889159006cee4ad293de5eee6b33" translate="yes" xml:space="preserve">
          <source>This would be accomplished by the following query:</source>
          <target state="translated">这可以通过以下查询来实现。</target>
        </trans-unit>
        <trans-unit id="6009d7325db9d9fecfe7a5f56808293dedf32ff8" translate="yes" xml:space="preserve">
          <source>Though PostgreSQL provides nonblocking read/write access to table data, nonblocking read/write access is not currently offered for every index access method implemented in PostgreSQL. The various index types are handled as follows:</source>
          <target state="translated">虽然PostgreSQL提供了对表数据的非阻塞读/写访问,但目前并没有为PostgreSQL中实现的每一种索引访问方法提供非阻塞读/写访问。各种索引类型的处理方法如下。</target>
        </trans-unit>
        <trans-unit id="f2b387dafa062f79d85fee46034cc439a5b198ed" translate="yes" xml:space="preserve">
          <source>Three different bits are used to store information about page-level visibility. The all-visible bit in the visibility map indicates that every tuple in the corresponding page of the relation is visible to every current and future transaction. The all-frozen bit in the visibility map indicates that every tuple in the page is frozen; that is, no future vacuum will need to modify the page until such time as a tuple is inserted, updated, deleted, or locked on that page. The page header's &lt;code&gt;PD_ALL_VISIBLE&lt;/code&gt; bit has the same meaning as the all-visible bit in the visibility map, but is stored within the data page itself rather than in a separate data structure. These two bits will normally agree, but the page's all-visible bit can sometimes be set while the visibility map bit is clear after a crash recovery. The reported values can also disagree because of a change that occurs after &lt;code&gt;pg_visibility&lt;/code&gt; examines the visibility map and before it examines the data page. Any event that causes data corruption can also cause these bits to disagree.</source>
          <target state="translated">三个不同的位用于存储有关页面级可见性的信息。可见性图中的所有可见位指示该关系的相应页面中的每个元组对于每个当前和将来的事务都是可见的。可见性图中的全冻结位表示页面中的每个元组都被冻结；也就是说，在元组被插入，更新，删除或锁定到该页面之前，将来不再需要修改页面。页面标题的 &lt;code&gt;PD_ALL_VISIBLE&lt;/code&gt; 该位与可见性图中的全可见位具有相同的含义，但存储在数据页本身中，而不是存储在单独的数据结构中。这两个位通常会一致，但是有时可以在崩溃恢复后清除可见性映射位的同时设置页面的全可见位。报告的值也可能不一致，因为在 &lt;code&gt;pg_visibility&lt;/code&gt; 检查可见性图之后并且在检查数据页之前发生了更改。任何导致数据损坏的事件都可能导致这些位不一致。</target>
        </trans-unit>
        <trans-unit id="3eb05e9b0f9498e4b2b12babd625a604206f4c79" translate="yes" xml:space="preserve">
          <source>Through simulation of the evolutionary operations &lt;em&gt;recombination&lt;/em&gt;, &lt;em&gt;mutation&lt;/em&gt;, and &lt;em&gt;selection&lt;/em&gt; new generations of search points are found that show a higher average fitness than their ancestors.</source>
          <target state="translated">通过模拟进化操作的&lt;em&gt;重组&lt;/em&gt;，&lt;em&gt;突变&lt;/em&gt;和&lt;em&gt;选择&lt;/em&gt;，发现了新一代搜索点，其平均适应度高于其祖先。</target>
        </trans-unit>
        <trans-unit id="55c41901b0118a14f05a3e31103cd618a4a206c3" translate="yes" xml:space="preserve">
          <source>Through simulation of the evolutionary operations &lt;em&gt;recombination&lt;/em&gt;, &lt;em&gt;mutation&lt;/em&gt;, and &lt;em&gt;selection&lt;/em&gt; new generations of search points are found that show a higher average fitness than their ancestors. &lt;a href=&quot;geqo-intro2#GEQO-FIGURE&quot;&gt;Figure 59.1&lt;/a&gt; illustrates these steps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c27dce1f6609095e9fe5fc64a23bbb9715cf9868" translate="yes" xml:space="preserve">
          <source>Throughout running a transaction, a server process holds an exclusive lock on the transaction's virtual transaction ID. If a permanent ID is assigned to the transaction (which normally happens only if the transaction changes the state of the database), it also holds an exclusive lock on the transaction's permanent transaction ID until it ends. When a process finds it necessary to wait specifically for another transaction to end, it does so by attempting to acquire share lock on the other transaction's ID (either virtual or permanent ID depending on the situation). That will succeed only when the other transaction terminates and releases its locks.</source>
          <target state="translated">在事务运行的整个过程中,服务器进程对事务的虚拟事务ID持有一个独占锁。如果给事务分配了一个永久的ID(通常只有在事务改变数据库的状态时才会发生),它也会在事务的永久事务ID上持有一个独占锁,直到事务结束。当一个进程发现有必要专门等待另一个事务结束时,它就会通过尝试获取另一个事务ID(根据情况,可以是虚拟ID,也可以是永久ID)上的共享锁来实现。只有当另一个事务终止并释放其锁时,这才会成功。</target>
        </trans-unit>
        <trans-unit id="28362fc6bf38f9ce00db5bd7a58a7c2aea63ad0d" translate="yes" xml:space="preserve">
          <source>Thu, Thur, Thurs</source>
          <target state="translated">星期四、四、五</target>
        </trans-unit>
        <trans-unit id="76031ddf92450ba52c1e3945097079807a9065c2" translate="yes" xml:space="preserve">
          <source>Thursday</source>
          <target state="translated">Thursday</target>
        </trans-unit>
        <trans-unit id="e159393321d195e0b9a1e51cafce029229164b8f" translate="yes" xml:space="preserve">
          <source>Thus far, our queries have only accessed one table at a time. Queries can access multiple tables at once, or access the same table in such a way that multiple rows of the table are being processed at the same time. A query that accesses multiple rows of the same or different tables at one time is called a &lt;em&gt;join&lt;/em&gt; query. As an example, say you wish to list all the weather records together with the location of the associated city. To do that, we need to compare the &lt;code&gt;city&lt;/code&gt; column of each row of the &lt;code&gt;weather&lt;/code&gt; table with the &lt;code&gt;name&lt;/code&gt; column of all rows in the &lt;code&gt;cities&lt;/code&gt; table, and select the pairs of rows where these values match.</source>
          <target state="translated">到目前为止，我们的查询一次只能访问一个表。查询可以一次访问多个表，也可以以同时处理表的多行的方式访问同一表。一次访问相同或不同表的多行的查询称为&lt;em&gt;联接&lt;/em&gt;查询。例如，假设您希望列出所有天气记录以及相关城市的位置。为此，我们需要将 &lt;code&gt;weather&lt;/code&gt; 表每一行的 &lt;code&gt;city&lt;/code&gt; 列与 &lt;code&gt;cities&lt;/code&gt; 表中所有行的 &lt;code&gt;name&lt;/code&gt; 列进行比较，然后选择这些值匹配的行对。</target>
        </trans-unit>
        <trans-unit id="33d92a6f947116307ff818dcd12f8100aa0644a8" translate="yes" xml:space="preserve">
          <source>Thus, the &lt;code&gt;strict_word_similarity(text, text)&lt;/code&gt; function is useful for finding the similarity to whole words, while &lt;code&gt;word_similarity(text, text)&lt;/code&gt; is more suitable for finding the similarity for parts of words.</source>
          <target state="translated">因此， &lt;code&gt;strict_word_similarity(text, text)&lt;/code&gt; 函数对于查找与整个单词的相似性很有用，而 &lt;code&gt;word_similarity(text, text)&lt;/code&gt; 则更适合于查找单词各部分的相似性。</target>
        </trans-unit>
        <trans-unit id="6c9c074c03b31acd5f7a7e20ed6e667b03762dad" translate="yes" xml:space="preserve">
          <source>Thus, the &lt;code&gt;strict_word_similarity&lt;/code&gt; function is useful for finding the similarity to whole words, while &lt;code&gt;word_similarity&lt;/code&gt; is more suitable for finding the similarity for parts of words.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae8d95556da752362e5bc888aa863b02957f8964" translate="yes" xml:space="preserve">
          <source>Thus, these functions can be used directly when the input query produces &lt;code&gt;row_name&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; columns of type &lt;code&gt;text&lt;/code&gt;, and you want 2, 3, or 4 output values columns. In all other ways they behave exactly as described above for the general &lt;code&gt;crosstab&lt;/code&gt; function.</source>
          <target state="translated">因此，当输入查询生成类型为 &lt;code&gt;text&lt;/code&gt; 的 &lt;code&gt;row_name&lt;/code&gt; 和 &lt;code&gt;value&lt;/code&gt; 列并且您需要2、3或4个输出值列时，可以直接使用这些函数。它们在所有其他方面的行为都与上述常规 &lt;code&gt;crosstab&lt;/code&gt; 函数完全相同。</target>
        </trans-unit>
        <trans-unit id="4db015abd914b1b3990881a3d9a556ca3470734a" translate="yes" xml:space="preserve">
          <source>Thus, we have created an integer column and arranged for its default values to be assigned from a sequence generator. A &lt;code&gt;NOT NULL&lt;/code&gt; constraint is applied to ensure that a null value cannot be inserted. (In most cases you would also want to attach a &lt;code&gt;UNIQUE&lt;/code&gt; or &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraint to prevent duplicate values from being inserted by accident, but this is not automatic.) Lastly, the sequence is marked as &amp;ldquo;owned by&amp;rdquo; the column, so that it will be dropped if the column or table is dropped.</source>
          <target state="translated">因此，我们创建了一个整数列，并安排其默认值从序列生成器中分配。甲 &lt;code&gt;NOT NULL&lt;/code&gt; 约束被施加，以确保空值不能被插入。 （在大多数情况下，您还希望附加一个 &lt;code&gt;UNIQUE&lt;/code&gt; 或 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 约束，以防止意外插入重复的值，但这不是自动的。）最后，该序列被标记为该列&amp;ldquo;拥有&amp;rdquo;，因此该列如果删除了列或表，则将删除它们。</target>
        </trans-unit>
        <trans-unit id="824c19a1cbeb13e4af22007a250bca9cc9d5aa71" translate="yes" xml:space="preserve">
          <source>Time at which the last data page checksum failure was detected in this database (or on a shared object), or NULL if data checksums are not enabled.</source>
          <target state="translated">在本数据库(或共享对象)中检测到最后一次数据页校验失败的时间,如果没有启用数据校验,则为NULL。</target>
        </trans-unit>
        <trans-unit id="31a4493404d403e4b069700b973d39eee08d905b" translate="yes" xml:space="preserve">
          <source>Time at which the transaction was prepared for commit</source>
          <target state="translated">交易准备提交的时间</target>
        </trans-unit>
        <trans-unit id="c312600dc8a52a3cdeb07b3c4822cc0aa7fc3793" translate="yes" xml:space="preserve">
          <source>Time at which these statistics were last reset</source>
          <target state="translated">这些统计数据最后被重置的时间</target>
        </trans-unit>
        <trans-unit id="b42073a799486b6bcd7e2d53dba2eb7477ef1dac" translate="yes" xml:space="preserve">
          <source>Time elapsed between flushing recent WAL locally and receiving notification that this standby server has written and flushed it (but not yet applied it). This can be used to gauge the delay that &lt;code&gt;synchronous_commit&lt;/code&gt; level &lt;code&gt;on&lt;/code&gt; incurred while committing if this server was configured as a synchronous standby.</source>
          <target state="translated">从本地刷新最近的WAL到接收到该备用服务器已写入并刷新（但尚未应用）通知的时间。这可以用来，以判断所述延迟 &lt;code&gt;synchronous_commit&lt;/code&gt; 水平 &lt;code&gt;on&lt;/code&gt; ，同时提交如果此服务器被配置为同步待机发生。</target>
        </trans-unit>
        <trans-unit id="e0c7f5fcbdb1638dc5b20b8d46067760a93260d7" translate="yes" xml:space="preserve">
          <source>Time elapsed between flushing recent WAL locally and receiving notification that this standby server has written it (but not yet flushed it or applied it). This can be used to gauge the delay that &lt;code&gt;synchronous_commit&lt;/code&gt; level &lt;code&gt;remote_write&lt;/code&gt; incurred while committing if this server was configured as a synchronous standby.</source>
          <target state="translated">从本地刷新最近的WAL到接收到该备用服务器已写入（但尚未刷新或应用它）通知的时间。这可以用来，以判断所述延迟 &lt;code&gt;synchronous_commit&lt;/code&gt; 水平 &lt;code&gt;remote_write&lt;/code&gt; 而提交如果此服务器被配置为同步待机发生。</target>
        </trans-unit>
        <trans-unit id="87f2fef0ff3885ece1737c889873c3a7dd9caea0" translate="yes" xml:space="preserve">
          <source>Time elapsed between flushing recent WAL locally and receiving notification that this standby server has written, flushed and applied it. This can be used to gauge the delay that &lt;code&gt;synchronous_commit&lt;/code&gt; level &lt;code&gt;remote_apply&lt;/code&gt; incurred while committing if this server was configured as a synchronous standby.</source>
          <target state="translated">从本地刷新最近的WAL到接收到该备用服务器已写入，刷新并应用它的通知之间经过了一段时间。这可以用来，以判断所述延迟 &lt;code&gt;synchronous_commit&lt;/code&gt; 水平 &lt;code&gt;remote_apply&lt;/code&gt; 而提交如果此服务器被配置为同步待机发生。</target>
        </trans-unit>
        <trans-unit id="ad92df2acc969fab807c3d10901a294d8ff7f754" translate="yes" xml:space="preserve">
          <source>Time is before 12:00</source>
          <target state="translated">时间是12:00之前</target>
        </trans-unit>
        <trans-unit id="43b71e95a19ea4a6f1b340ce357037e706d5a3cf" translate="yes" xml:space="preserve">
          <source>Time is on or after 12:00</source>
          <target state="translated">时间是在12:00或之后</target>
        </trans-unit>
        <trans-unit id="9bd0601e2f87239d97d77738bf3ca024a85d5838" translate="yes" xml:space="preserve">
          <source>Time of last write-ahead log location reported to origin WAL sender</source>
          <target state="translated">向原WAL发送者报告的最后一次写前日志位置的时间。</target>
        </trans-unit>
        <trans-unit id="689e239460d59d7671ce2c908f91fa122b359c25" translate="yes" xml:space="preserve">
          <source>Time of the last failed archival operation</source>
          <target state="translated">最后一次归档操作失败的时间</target>
        </trans-unit>
        <trans-unit id="8cb8f733cf5d5d099965d55bbe98e4d1fa3e9d29" translate="yes" xml:space="preserve">
          <source>Time of the last successful archive operation</source>
          <target state="translated">最后一次成功归档操作的时间</target>
        </trans-unit>
        <trans-unit id="21397053368fe3010616b276ed5043a12f8cb11f" translate="yes" xml:space="preserve">
          <source>Time spent reading data file blocks by backends in this database, in milliseconds</source>
          <target state="translated">该数据库中后端读取数据文件块所花费的时间,以毫秒为单位。</target>
        </trans-unit>
        <trans-unit id="9cb2109efc7cd77762a155d13e3d4c7d5ccbfbcd" translate="yes" xml:space="preserve">
          <source>Time spent reading data file blocks by backends in this database, in milliseconds (if &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-IO-TIMING&quot;&gt;track_io_timing&lt;/a&gt; is enabled, otherwise zero)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="555585fed0e713bf1b368cbbf5bba5754318a952" translate="yes" xml:space="preserve">
          <source>Time spent writing data file blocks by backends in this database, in milliseconds</source>
          <target state="translated">后端在该数据库中写入数据文件块所花费的时间,以毫秒为单位。</target>
        </trans-unit>
        <trans-unit id="f85753033657b7d08aa205efa2bc11551bdaa55d" translate="yes" xml:space="preserve">
          <source>Time spent writing data file blocks by backends in this database, in milliseconds (if &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-IO-TIMING&quot;&gt;track_io_timing&lt;/a&gt; is enabled, otherwise zero)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7c6e9c6e492ee3767af155479b912c5dbab4797" translate="yes" xml:space="preserve">
          <source>Time stamp with milliseconds</source>
          <target state="translated">时间戳与毫秒</target>
        </trans-unit>
        <trans-unit id="60f359c6300b47ebed0b97fcdfa3cace5afca052" translate="yes" xml:space="preserve">
          <source>Time stamp with milliseconds (as a Unix epoch)</source>
          <target state="translated">时间戳,以毫秒为单位 (Unix epoch)</target>
        </trans-unit>
        <trans-unit id="4ac2d64d58668aa63843fa9aac25d77d00659a02" translate="yes" xml:space="preserve">
          <source>Time stamp without milliseconds</source>
          <target state="translated">不含毫秒的时间戳</target>
        </trans-unit>
        <trans-unit id="51bb8ad970c492c6e4e04fdc998b0e86ee08e582" translate="yes" xml:space="preserve">
          <source>Time when the &lt;code&gt;state&lt;/code&gt; was last changed</source>
          <target state="translated">时值 &lt;code&gt;state&lt;/code&gt; 上次更改</target>
        </trans-unit>
        <trans-unit id="d762072c616665b71d7c55c79cd97af33543bb34" translate="yes" xml:space="preserve">
          <source>Time when the current transaction was started</source>
          <target state="translated">当前交易开始的时间</target>
        </trans-unit>
        <trans-unit id="11625d6eed69f1fabf53d97fbcee125227cacb32" translate="yes" xml:space="preserve">
          <source>Time when the currently active query was started, or if &lt;code&gt;state&lt;/code&gt; is not &lt;code&gt;active&lt;/code&gt;, when the last query was started</source>
          <target state="translated">启动当前活动的查询的时间，或者如果 &lt;code&gt;state&lt;/code&gt; 不是 &lt;code&gt;active&lt;/code&gt; ，则开始上一次查询的时间</target>
        </trans-unit>
        <trans-unit id="94633bb8d7222b0ec4b3348ef60e473c680e5d05" translate="yes" xml:space="preserve">
          <source>Time when the most recent query was started</source>
          <target state="translated">最近一次查询开始的时间</target>
        </trans-unit>
        <trans-unit id="25af4b3f3521f87fcd782cc01e0d9b93c6165347" translate="yes" xml:space="preserve">
          <source>Time when this process was started</source>
          <target state="translated">这个过程开始的时间</target>
        </trans-unit>
        <trans-unit id="933cb365f238bab1b9f23247a7559754209bd8c6" translate="yes" xml:space="preserve">
          <source>Time when this process was started, i.e., when the client connected to this WAL sender</source>
          <target state="translated">这个进程启动的时间,即客户端连接到这个WAL发送器的时间。</target>
        </trans-unit>
        <trans-unit id="559b0a476d9e562ad140be918c065bb024b1f003" translate="yes" xml:space="preserve">
          <source>Time when this process was started. For client backends, this is the time the client connected to the server.</source>
          <target state="translated">这个进程启动的时间。对于客户端后端,这是客户端连接到服务器的时间。</target>
        </trans-unit>
        <trans-unit id="cc12d0007d4c73cf73c1568b7bfdf5da27728eae" translate="yes" xml:space="preserve">
          <source>Time when this process' current transaction was started, or null if no transaction is active. If the current query is the first of its transaction, this column is equal to the &lt;code&gt;query_start&lt;/code&gt; column.</source>
          <target state="translated">开始该进程的当前事务的时间；如果没有活动的事务，则为null。如果当前查询是它的第一个事务，则此列等于 &lt;code&gt;query_start&lt;/code&gt; 列。</target>
        </trans-unit>
        <trans-unit id="fbdc0abebabeabc5d4b770a667845ccc3c799e2b" translate="yes" xml:space="preserve">
          <source>Time zone abbreviation</source>
          <target state="translated">时区缩写</target>
        </trans-unit>
        <trans-unit id="e460672f042e9a6f5cb5587fff9b633a5f807f4f" translate="yes" xml:space="preserve">
          <source>Time zone abbreviations defined in the configuration file override non-timezone meanings built into PostgreSQL. For example, the &lt;code&gt;Australia&lt;/code&gt; configuration file defines &lt;code&gt;SAT&lt;/code&gt; (for South Australian Standard Time). When this file is active, &lt;code&gt;SAT&lt;/code&gt; will not be recognized as an abbreviation for Saturday.</source>
          <target state="translated">配置文件中定义的时区缩写会覆盖PostgreSQL内置的非时区含义。例如， &lt;code&gt;Australia&lt;/code&gt; 配置文件定义了 &lt;code&gt;SAT&lt;/code&gt; （适用于南澳大利亚标准时间）。当此文件处于活动状态时， &lt;code&gt;SAT&lt;/code&gt; 将不会被视为星期六的缩写。</target>
        </trans-unit>
        <trans-unit id="37a9001f0d01c5209af64be7dc1968df4b54e043" translate="yes" xml:space="preserve">
          <source>Time zone name</source>
          <target state="translated">时区名称</target>
        </trans-unit>
        <trans-unit id="d9837496505fa39574debf57863d4c5a7a7e1fa2" translate="yes" xml:space="preserve">
          <source>Time zones, and time-zone conventions, are influenced by political decisions, not just earth geometry. Time zones around the world became somewhat standardized during the 1900s, but continue to be prone to arbitrary changes, particularly with respect to daylight-savings rules. PostgreSQL uses the widely-used IANA (Olson) time zone database for information about historical time zone rules. For times in the future, the assumption is that the latest known rules for a given time zone will continue to be observed indefinitely far into the future.</source>
          <target state="translated">时区和时区惯例不仅受到地球几何学的影响,还受到政治决定的影响。世界各地的时区在1900年代变得有些标准化,但仍然容易发生任意变化,特别是在夏令时规则方面。PostgreSQL使用广泛使用的IANA(Olson)时区数据库来获取历史时区规则的信息。对于未来的时间,假设给定时区的最新已知规则在未来很远的地方仍将无限期地被遵守。</target>
        </trans-unit>
        <trans-unit id="51e0ae72446d2bbeb8c3c3c8b1ad7cfa9371d4af" translate="yes" xml:space="preserve">
          <source>Timeline from which to read log records. The default is to use the value in &lt;code&gt;startseg&lt;/code&gt;, if that is specified; otherwise, the default is 1.</source>
          <target state="translated">从中读取日志记录的时间轴。默认值是使用 &lt;code&gt;startseg&lt;/code&gt; 中的值（如果已指定）。否则，默认值为1。</target>
        </trans-unit>
        <trans-unit id="1a493fe5eba595d570a4b23a6ba4061eb25ab8ef" translate="yes" xml:space="preserve">
          <source>Timeline number of last write-ahead log location received and flushed to disk, the initial value of this field being the timeline number of the first log location used when WAL receiver is started</source>
          <target state="translated">接收到的最后一个写前日志位置的时间线号并刷新到磁盘,该字段的初始值是WAL接收器启动时使用的第一个日志位置的时间线号。</target>
        </trans-unit>
        <trans-unit id="ae2147bbbd74fc0ea70c9f9c1ab21cda42f12f26" translate="yes" xml:space="preserve">
          <source>Timers used on older PC hardware include the 8254 Programmable Interval Timer (PIT), the real-time clock (RTC), the Advanced Programmable Interrupt Controller (APIC) timer, and the Cyclone timer. These timers aim for millisecond resolution.</source>
          <target state="translated">旧PC硬件上使用的定时器包括8254可编程间隔定时器(PIT)、实时时钟(RTC)、高级可编程中断控制器(APIC)定时器和Cyclone定时器。这些定时器的目标是毫秒级的分辨率。</target>
        </trans-unit>
        <trans-unit id="87f6f783967c5bb200b51b61ac60c7b2d206bb65" translate="yes" xml:space="preserve">
          <source>Timespan types</source>
          <target state="translated">时间跨度类型</target>
        </trans-unit>
        <trans-unit id="239e2086e6fe0c5571eca32707440c4ba53f1fcd" translate="yes" xml:space="preserve">
          <source>Timezone settings given as numbers or intervals are internally translated to POSIX timezone syntax. For example, after &lt;code&gt;SET TIME ZONE -7&lt;/code&gt;, &lt;code&gt;SHOW TIME ZONE&lt;/code&gt; would report &lt;code&gt;&amp;lt;-07&amp;gt;+07&lt;/code&gt;.</source>
          <target state="translated">以数字或间隔指定的时区设置在内部转换为POSIX时区语法。例如，在 &lt;code&gt;SET TIME ZONE -7&lt;/code&gt; 之后， &lt;code&gt;SHOW TIME ZONE&lt;/code&gt; 将报告 &lt;code&gt;&amp;lt;-07&amp;gt;+07&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d19ceca501465c339e3bcf2bc0d8ff02bb697d6c" translate="yes" xml:space="preserve">
          <source>Tip</source>
          <target state="translated">Tip</target>
        </trans-unit>
        <trans-unit id="7e007f7fc0996f8d4eac8a1e1e90b6f80a635659" translate="yes" xml:space="preserve">
          <source>To abort all changes:</source>
          <target state="translated">要中止所有的改变。</target>
        </trans-unit>
        <trans-unit id="a1de6dbe0b98af8c297b94378a5d03d8bb0f5d29" translate="yes" xml:space="preserve">
          <source>To access a field of a composite column, one writes a dot and the field name, much like selecting a field from a table name. In fact, it's so much like selecting from a table name that you often have to use parentheses to keep from confusing the parser. For example, you might try to select some subfields from our &lt;code&gt;on_hand&lt;/code&gt; example table with something like:</source>
          <target state="translated">要访问复合列的字段，需要写一个点和字段名，就像从表名中选择一个字段一样。实际上，这就像从表名中进行选择一样，您通常必须使用括号来避免混淆解析器。例如，您可以尝试从 &lt;code&gt;on_hand&lt;/code&gt; 示例表中选择一些子字段，例如：</target>
        </trans-unit>
        <trans-unit id="017b192526f458780b51a75f9b3b25aefc868352" translate="yes" xml:space="preserve">
          <source>To access foreign data, you need to create a &lt;em&gt;foreign server&lt;/em&gt; object, which defines how to connect to a particular external data source according to the set of options used by its supporting foreign data wrapper. Then you need to create one or more &lt;em&gt;foreign tables&lt;/em&gt;, which define the structure of the remote data. A foreign table can be used in queries just like a normal table, but a foreign table has no storage in the PostgreSQL server. Whenever it is used, PostgreSQL asks the foreign data wrapper to fetch data from the external source, or transmit data to the external source in the case of update commands.</source>
          <target state="translated">要访问外部数据，您需要创建一个&lt;em&gt;外部服务器&lt;/em&gt;对象，该对象根据其支持的外部数据包装程序使用的选项集定义如何连接到特定的外部数据源。然后，您需要创建一个或多个&lt;em&gt;外部表&lt;/em&gt;，这些&lt;em&gt;表&lt;/em&gt;定义了远程数据的结构。外部表可以像普通表一样用于查询，但是外部表在PostgreSQL服务器中没有存储。无论何时使用PostgreSQL，PostgreSQL都会要求外部数据包装器从外部源获取数据，或者在使用更新命令的情况下将数据传输到外部源。</target>
        </trans-unit>
        <trans-unit id="c882ff143aff4abbe56ed4decc5353a3e40be0c7" translate="yes" xml:space="preserve">
          <source>To achieve a similar effect when running a transaction at the &lt;code&gt;REPEATABLE READ&lt;/code&gt; or &lt;code&gt;SERIALIZABLE&lt;/code&gt; isolation level, you have to execute the &lt;code&gt;LOCK TABLE&lt;/code&gt; statement before executing any &lt;code&gt;SELECT&lt;/code&gt; or data modification statement. A &lt;code&gt;REPEATABLE READ&lt;/code&gt; or &lt;code&gt;SERIALIZABLE&lt;/code&gt; transaction's view of data will be frozen when its first &lt;code&gt;SELECT&lt;/code&gt; or data modification statement begins. A &lt;code&gt;LOCK TABLE&lt;/code&gt; later in the transaction will still prevent concurrent writes &amp;mdash; but it won't ensure that what the transaction reads corresponds to the latest committed values.</source>
          <target state="translated">为了在 &lt;code&gt;REPEATABLE READ&lt;/code&gt; 或 &lt;code&gt;SERIALIZABLE&lt;/code&gt; 隔离级别下运行事务时达到类似的效果，必须在执行任何 &lt;code&gt;SELECT&lt;/code&gt; 或数据修改语句之前执行 &lt;code&gt;LOCK TABLE&lt;/code&gt; 语句。当 &lt;code&gt;REPEATABLE READ&lt;/code&gt; 或 &lt;code&gt;SERIALIZABLE&lt;/code&gt; 事务处理的数据视图的第一个 &lt;code&gt;SELECT&lt;/code&gt; 或数据修改语句开始时，将冻结该视图。事务后面的 &lt;code&gt;LOCK TABLE&lt;/code&gt; 仍将阻止并发写入-但不能确保事务读取的内容与最新的提交值相对应。</target>
        </trans-unit>
        <trans-unit id="0b48da783d51f53cd43e5c00aa186c9d8deaec51" translate="yes" xml:space="preserve">
          <source>To add a (multicolumn) unique constraint to a table:</source>
          <target state="translated">要在表中添加(多列)唯一约束。</target>
        </trans-unit>
        <trans-unit id="7c2dc11d3fbd2d572d80e9f7f2427e18b8265aab" translate="yes" xml:space="preserve">
          <source>To add a &lt;code&gt;NOT NULL&lt;/code&gt; constraint to a domain:</source>
          <target state="translated">要将 &lt;code&gt;NOT NULL&lt;/code&gt; 约束添加到域：</target>
        </trans-unit>
        <trans-unit id="05f31d6bcf939e6d5e9a463994e90aee8d1e54a8" translate="yes" xml:space="preserve">
          <source>To add a Unix user account to your system, look for a command &lt;code&gt;useradd&lt;/code&gt; or &lt;code&gt;adduser&lt;/code&gt;. The user name postgres is often used, and is assumed throughout this book, but you can use another name if you like.</source>
          <target state="translated">要将Unix用户帐户添加到系统中，请查找命令 &lt;code&gt;useradd&lt;/code&gt; 或 &lt;code&gt;adduser&lt;/code&gt; 。经常使用用户名postgres，并且在本书中都使用该用户名，但是如果您愿意，可以使用其他名称。</target>
        </trans-unit>
        <trans-unit id="ebfcefdd7e6dd46087f7db4f56ad55b502aa3b38" translate="yes" xml:space="preserve">
          <source>To add a check constraint only to a table and not to its children:</source>
          <target state="translated">要只向表而不是其子表添加检查约束。</target>
        </trans-unit>
        <trans-unit id="bb3438d5034c17e4d50c71f282c86de2e7e88a0e" translate="yes" xml:space="preserve">
          <source>To add a check constraint to a domain:</source>
          <target state="translated">要在域中添加一个检查约束。</target>
        </trans-unit>
        <trans-unit id="b2e451d1684f5b60db7be22ba4fea7da5b7b7b9e" translate="yes" xml:space="preserve">
          <source>To add a check constraint to a table and all its children:</source>
          <target state="translated">为表及其所有子表添加一个检查约束。</target>
        </trans-unit>
        <trans-unit id="18521a2d32e7178b56eb305ab469851b96ca3009" translate="yes" xml:space="preserve">
          <source>To add a column and fill it with a value different from the default to be used later:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="174131dc66d4970ba5125ca4661ff1a19109b4b9" translate="yes" xml:space="preserve">
          <source>To add a column of type &lt;code&gt;varchar&lt;/code&gt; to a table:</source>
          <target state="translated">要将 &lt;code&gt;varchar&lt;/code&gt; 类型的列添加到表中：</target>
        </trans-unit>
        <trans-unit id="9b1aeaa1dc1643fc190e738e9d094e62f17c2e7e" translate="yes" xml:space="preserve">
          <source>To add a column with a non-null default:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1c2f4fa0ab2023d587d3b98db8f6427264ba706" translate="yes" xml:space="preserve">
          <source>To add a column, use a command like:</source>
          <target state="translated">要添加一列,请使用类似命令。</target>
        </trans-unit>
        <trans-unit id="0f37ab4f4bb9bd95a03c2a18bda2edd2159fb3ba" translate="yes" xml:space="preserve">
          <source>To add a constraint, the table constraint syntax is used. For example:</source>
          <target state="translated">要添加一个约束,使用表约束语法。例如:</target>
        </trans-unit>
        <trans-unit id="552cd578dc1fe8e243759547fbc657cae049fb54" translate="yes" xml:space="preserve">
          <source>To add a foreign key constraint to a table with the least impact on other work:</source>
          <target state="translated">要在对其他工作影响最小的情况下,在表中添加外键约束。</target>
        </trans-unit>
        <trans-unit id="0ab66f0fba250760a2399696fd0b16e5bf040c43" translate="yes" xml:space="preserve">
          <source>To add a foreign key constraint to a table:</source>
          <target state="translated">要在表中添加一个外键约束。</target>
        </trans-unit>
        <trans-unit id="d58a827d4f546e75e64876a110b2a9ae7702ffe0" translate="yes" xml:space="preserve">
          <source>To add a new attribute to a composite type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3411926179ac8624e69940712a6f3380af5e790a" translate="yes" xml:space="preserve">
          <source>To add a new attribute to a type:</source>
          <target state="translated">为类型添加新属性。</target>
        </trans-unit>
        <trans-unit id="db77b529c04682a830e59457f320121602d467bb" translate="yes" xml:space="preserve">
          <source>To add a new child table to handle new data, create an empty child table just as the original children were created above:</source>
          <target state="translated">要添加一个新的子表来处理新的数据,就像上面创建原始子表一样,创建一个空子表。</target>
        </trans-unit>
        <trans-unit id="9161ab2c4e67b5fb82cc744c9d3774972dec4893" translate="yes" xml:space="preserve">
          <source>To add a new value to an enum type in a particular sort position:</source>
          <target state="translated">在特定的排序位置为枚举类型添加一个新值。</target>
        </trans-unit>
        <trans-unit id="a31abc40dd1208477736069bb4013695302376d8" translate="yes" xml:space="preserve">
          <source>To add a not-null constraint to a column:</source>
          <target state="translated">为列添加一个非空约束。</target>
        </trans-unit>
        <trans-unit id="cb6a3f80db2bc2ad72d4c62c4940bdf89c57476e" translate="yes" xml:space="preserve">
          <source>To add a not-null constraint, which cannot be written as a table constraint, use this syntax:</source>
          <target state="translated">要添加一个不能写成表约束的非空约束,使用这个语法。</target>
        </trans-unit>
        <trans-unit id="6bad209cf083236dccc11fc40cf4f91317deadaf" translate="yes" xml:space="preserve">
          <source>To add a table to a publication, the invoking user must have ownership rights on the table. The &lt;code&gt;FOR ALL TABLES&lt;/code&gt; clause requires the invoking user to be a superuser.</source>
          <target state="translated">要将表添加到发布中，调用用户必须对该表具有所有权。将 &lt;code&gt;FOR ALL TABLES&lt;/code&gt; 条款要求调用用户是超级用户。</target>
        </trans-unit>
        <trans-unit id="0ae21ae330630cd68145a9fe01a93dd7045defb6" translate="yes" xml:space="preserve">
          <source>To add an automatically named primary key constraint to a table, noting that a table can only ever have one primary key:</source>
          <target state="translated">要给表添加一个自动命名的主键约束,注意一个表永远只能有一个主键。</target>
        </trans-unit>
        <trans-unit id="afa12cb0c308a9db161baf8949e517c49dc4c5c8" translate="yes" xml:space="preserve">
          <source>To add an existing function to the &lt;code&gt;hstore&lt;/code&gt; extension:</source>
          <target state="translated">要将现有功能添加到 &lt;code&gt;hstore&lt;/code&gt; 扩展中：</target>
        </trans-unit>
        <trans-unit id="22b234bd9cd26b96824fe520230d7c5e449fc297" translate="yes" xml:space="preserve">
          <source>To add tables to a publication, the user must have ownership rights on the table. To create a publication that publishes all tables automatically, the user must be a superuser.</source>
          <target state="translated">要将表添加到出版物中,用户必须拥有表的所有权。要创建一个自动发布所有表的出版物,用户必须是超级用户。</target>
        </trans-unit>
        <trans-unit id="83730299a560c3c0731431f81b51c2abe2442fdf" translate="yes" xml:space="preserve">
          <source>To address these difficulties, we recommend using date/time types that contain both date and time when using time zones. We do &lt;em&gt;not&lt;/em&gt; recommend using the type &lt;code&gt;time with time zone&lt;/code&gt; (though it is supported by PostgreSQL for legacy applications and for compliance with the SQL standard). PostgreSQL assumes your local time zone for any type containing only date or time.</source>
          <target state="translated">为了解决这些困难，建议您在使用时区时使用同时包含日期和时间的日期/时间类型。我们&lt;em&gt;不&lt;/em&gt;建议使用 &lt;code&gt;time with time zone&lt;/code&gt; 类型（尽管PostgreSQL支持遗留应用程序并符合SQL标准）。PostgreSQL假定您的本地时区为仅包含日期或时间的任何类型。</target>
        </trans-unit>
        <trans-unit id="b7065094627525a073a51f64da60efc6b8e9bee4" translate="yes" xml:space="preserve">
          <source>To adjust the search path that is automatically set for a function:</source>
          <target state="translated">调整函数自动设置的搜索路径。</target>
        </trans-unit>
        <trans-unit id="454e8b704e7b145c0be218174873a9c9a43d4489" translate="yes" xml:space="preserve">
          <source>To adjust the search path that is automatically set for a procedure:</source>
          <target state="translated">调整程序自动设置的搜索路径。</target>
        </trans-unit>
        <trans-unit id="43832a6258ef921e1a75d9d839da59e22b5679fa" translate="yes" xml:space="preserve">
          <source>To allow many users to use one database without interfering with each other.</source>
          <target state="translated">允许多个用户使用一个数据库而不互相干扰。</target>
        </trans-unit>
        <trans-unit id="69f1ad561f1cfb2e35cd3c6eff1bf6db4e335624" translate="yes" xml:space="preserve">
          <source>To alter the default collation order or character set classes, use the &lt;code&gt;--lc-collate&lt;/code&gt; and &lt;code&gt;--lc-ctype&lt;/code&gt; options. Collation orders other than &lt;code&gt;C&lt;/code&gt; or &lt;code&gt;POSIX&lt;/code&gt; also have a performance penalty. For these reasons it is important to choose the right locale when running &lt;code&gt;initdb&lt;/code&gt;.</source>
          <target state="translated">要更改默认排序规则顺序或字符集类，请使用 &lt;code&gt;--lc-collate&lt;/code&gt; 和 &lt;code&gt;--lc-ctype&lt;/code&gt; 选项。除 &lt;code&gt;C&lt;/code&gt; 或 &lt;code&gt;POSIX&lt;/code&gt; 以外的其他排序规则也有性能损失。由于这些原因，在运行 &lt;code&gt;initdb&lt;/code&gt; 时选择正确的语言环境很重要。</target>
        </trans-unit>
        <trans-unit id="2add0ec4b26fbbc0bb9c1c7436006edf85689aa1" translate="yes" xml:space="preserve">
          <source>To alter the default encoding, use the &lt;code&gt;--encoding&lt;/code&gt;. More details can be found in &lt;a href=&quot;multibyte&quot;&gt;Section 23.3&lt;/a&gt;.</source>
          <target state="translated">要更改默认编码，请使用 &lt;code&gt;--encoding&lt;/code&gt; 。更多细节可以在&lt;a href=&quot;multibyte&quot;&gt;第23.3节中&lt;/a&gt;找到。</target>
        </trans-unit>
        <trans-unit id="1826e1649b94ce735f6431fdd9a17150394fd248" translate="yes" xml:space="preserve">
          <source>To alter the server you must be the owner of the server. Additionally to alter the owner, you must own the server and also be a direct or indirect member of the new owning role, and you must have &lt;code&gt;USAGE&lt;/code&gt; privilege on the server's foreign-data wrapper. (Note that superusers satisfy all these criteria automatically.)</source>
          <target state="translated">要更改服务器，您必须是服务器的所有者。此外，要更改所有者，您必须拥有服务器，并且还必须是新拥有角色的直接或间接成员，并且必须对服务器的外部数据包装程序具有 &lt;code&gt;USAGE&lt;/code&gt; 特权。（请注意，超级用户会自动满足所有这些条件。）</target>
        </trans-unit>
        <trans-unit id="7ddeb73fb5d4e79b9c3c1e564a7ef4c6351feb67" translate="yes" xml:space="preserve">
          <source>To analyze a table, one must ordinarily be the table's owner or a superuser. However, database owners are allowed to analyze all tables in their databases, except shared catalogs. (The restriction for shared catalogs means that a true database-wide &lt;code&gt;ANALYZE&lt;/code&gt; can only be performed by a superuser.) &lt;code&gt;ANALYZE&lt;/code&gt; will skip over any tables that the calling user does not have permission to analyze.</source>
          <target state="translated">要分析表，通常必须是表的所有者或超级用户。但是，允许数据库所有者分析其数据库中的所有表（共享目录除外）。（共享目录的限制意味着真正的数据库范围的 &lt;code&gt;ANALYZE&lt;/code&gt; 只能由超级用户执行。） &lt;code&gt;ANALYZE&lt;/code&gt; 将跳过调用用户没有权限进行分析的任何表。</target>
        </trans-unit>
        <trans-unit id="3ceea8787427d383c0bca554922094f48e526fe4" translate="yes" xml:space="preserve">
          <source>To assign privileges, the &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; command is used. For example, if &lt;code&gt;joe&lt;/code&gt; is an existing role, and &lt;code&gt;accounts&lt;/code&gt; is an existing table, the privilege to update the table can be granted with:</source>
          <target state="translated">要分配特权，请使用&lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt;命令。例如，如果 &lt;code&gt;joe&lt;/code&gt; 是现有角色， &lt;code&gt;accounts&lt;/code&gt; 是现有表，则可以使用以下方法授予更新表的特权：</target>
        </trans-unit>
        <trans-unit id="841afb234a29a395e3e0830fae028e72521f88ca" translate="yes" xml:space="preserve">
          <source>To attach a default column value to an updatable view:</source>
          <target state="translated">将默认列值附加到可更新视图中。</target>
        </trans-unit>
        <trans-unit id="c91056b552b812becaf03884b78b11880acaa830" translate="yes" xml:space="preserve">
          <source>To attach a default partition to a partitioned table:</source>
          <target state="translated">要将默认分区附加到分区表上。</target>
        </trans-unit>
        <trans-unit id="903700b262c75e1e9a2686570b8d3d9a905f0191" translate="yes" xml:space="preserve">
          <source>To attach a partition to a hash-partitioned table:</source>
          <target state="translated">将分区附加到哈希分区表上。</target>
        </trans-unit>
        <trans-unit id="816912ec3804829192e5b4b51ed04c4c04e0fc1d" translate="yes" xml:space="preserve">
          <source>To attach a partition to a list-partitioned table:</source>
          <target state="translated">将分区附加到列表分区表。</target>
        </trans-unit>
        <trans-unit id="38cc90d5c14d343f7257c521bec65b2a2c788861" translate="yes" xml:space="preserve">
          <source>To attach a partition to a range-partitioned table:</source>
          <target state="translated">要将分区附加到范围分区表上。</target>
        </trans-unit>
        <trans-unit id="a338146ab7e1a8a6c29211a64020a73e715d047f" translate="yes" xml:space="preserve">
          <source>To avoid blocking concurrent transactions that obtain numbers from the same sequence, a &lt;code&gt;nextval&lt;/code&gt; operation is never rolled back; that is, once a value has been fetched it is considered used and will not be returned again. This is true even if the surrounding transaction later aborts, or if the calling query ends up not using the value. For example an &lt;code&gt;INSERT&lt;/code&gt; with an &lt;code&gt;ON CONFLICT&lt;/code&gt; clause will compute the to-be-inserted tuple, including doing any required &lt;code&gt;nextval&lt;/code&gt; calls, before detecting any conflict that would cause it to follow the &lt;code&gt;ON CONFLICT&lt;/code&gt; rule instead. Such cases will leave unused &amp;ldquo;holes&amp;rdquo; in the sequence of assigned values. Thus, PostgreSQL sequence objects &lt;em&gt;cannot be used to obtain &amp;ldquo;gapless&amp;rdquo; sequences&lt;/em&gt;.</source>
          <target state="translated">为了避免阻塞从相同序列中获取数字的并发事务，绝不会回退 &lt;code&gt;nextval&lt;/code&gt; 操作；也就是说，一旦获取了值，就将其视为已使用，并且不会再次返回。即使周围的事务稍后中止，或者调用查询最终不使用该值也是如此。例如，带有 &lt;code&gt;ON CONFLICT&lt;/code&gt; 子句的 &lt;code&gt;INSERT&lt;/code&gt; 将计算要插入的元组，包括执行任何必需的 &lt;code&gt;nextval&lt;/code&gt; 调用，然后再检测到任何可能导致其遵循 &lt;code&gt;ON CONFLICT&lt;/code&gt; 规则的冲突。这样的情况将在分配值的序列中留下未使用的&amp;ldquo;漏洞&amp;rdquo;。因此，PostgreSQL序列对象&lt;em&gt;无法用于获取&amp;ldquo;无间隙&amp;rdquo;序列&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="77db4bef2cb8a0ae44c281dac0dfd436dc1a536b" translate="yes" xml:space="preserve">
          <source>To avoid confusion with the non-slice case, it's best to use slice syntax for all dimensions, e.g., &lt;code&gt;[1:2][1:1]&lt;/code&gt;, not &lt;code&gt;[2][1:1]&lt;/code&gt;.</source>
          <target state="translated">To avoid confusion with the non-slice case, it's best to use slice syntax for all dimensions, e.g., &lt;code&gt;[1:2][1:1]&lt;/code&gt; , not &lt;code&gt;[2][1:1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2abfccf591d4ddb924887ea39256c518691d084" translate="yes" xml:space="preserve">
          <source>To avoid flooding the I/O system with a burst of page writes, writing dirty buffers during a checkpoint is spread over a period of time. That period is controlled by &lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-COMPLETION-TARGET&quot;&gt;checkpoint_completion_target&lt;/a&gt;, which is given as a fraction of the checkpoint interval. The I/O rate is adjusted so that the checkpoint finishes when the given fraction of &lt;code&gt;checkpoint_timeout&lt;/code&gt; seconds have elapsed, or before &lt;code&gt;max_wal_size&lt;/code&gt; is exceeded, whichever is sooner. With the default value of 0.5, PostgreSQL can be expected to complete each checkpoint in about half the time before the next checkpoint starts. On a system that's very close to maximum I/O throughput during normal operation, you might want to increase &lt;code&gt;checkpoint_completion_target&lt;/code&gt; to reduce the I/O load from checkpoints. The disadvantage of this is that prolonging checkpoints affects recovery time, because more WAL segments will need to be kept around for possible use in recovery. Although &lt;code&gt;checkpoint_completion_target&lt;/code&gt; can be set as high as 1.0, it is best to keep it less than that (perhaps 0.9 at most) since checkpoints include some other activities besides writing dirty buffers. A setting of 1.0 is quite likely to result in checkpoints not being completed on time, which would result in performance loss due to unexpected variation in the number of WAL segments needed.</source>
          <target state="translated">为了避免大量的页面写操作淹没I / O系统，在检查点期间写脏缓冲区的过程会分散一段时间。该时间段由&lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-COMPLETION-TARGET&quot;&gt;checkpoint_completion_target&lt;/a&gt;控制，它是检查点间隔的一部分。调整I / O速率，以便在给定的 &lt;code&gt;checkpoint_timeout&lt;/code&gt; 秒分数已过或超过 &lt;code&gt;max_wal_size&lt;/code&gt; 时（以较早者为准），检查点完成。默认值为0.5，可以期望PostgreSQL在下一个检查点开始之前的大约一半时间内完成每个检查点。在正常运行期间非常接近最大I / O吞吐量的系统上，您可能需要增加 &lt;code&gt;checkpoint_completion_target&lt;/code&gt; 减少检查点的I / O负载。这样做的缺点是延长检查点会影响恢复时间，因为将需要保留更多的WAL段以用于恢复。尽管 &lt;code&gt;checkpoint_completion_target&lt;/code&gt; 可以设置为1.0，但最好使其小于此值（最多为0.9），因为检查点除了写脏缓冲区之外还包括其他活动。设置为1.0很有可能导致检查点无法按时完成，这将由于所需WAL段数的意外变化而导致性能损失。</target>
        </trans-unit>
        <trans-unit id="3b5b7ab793933b28d259bd7231f552d4046ed360" translate="yes" xml:space="preserve">
          <source>To back up your database installation, type:</source>
          <target state="translated">要备份您的数据库安装,键入。</target>
        </trans-unit>
        <trans-unit id="f94848a530617c32c61eaedaa18cb50416b23aee" translate="yes" xml:space="preserve">
          <source>To be able to create a cast, you must own the source or the target data type and have &lt;code&gt;USAGE&lt;/code&gt; privilege on the other type. To create a binary-coercible cast, you must be superuser. (This restriction is made because an erroneous binary-coercible cast conversion can easily crash the server.)</source>
          <target state="translated">为了能够创建演员表，您必须拥有源或目标数据类型，并且对另一种类型具有 &lt;code&gt;USAGE&lt;/code&gt; 特权。要创建二进制可强制转换，您必须是超级用户。（之所以做出此限制，是因为错误的二进制强制转换转换很容易使服务器崩溃。）</target>
        </trans-unit>
        <trans-unit id="9403a03a717e8159d4311e7a77af5d9d4fb13286" translate="yes" xml:space="preserve">
          <source>To be able to create a collation, you must have &lt;code&gt;CREATE&lt;/code&gt; privilege on the destination schema.</source>
          <target state="translated">为了能够创建排序规则，您必须在目标架构上具有 &lt;code&gt;CREATE&lt;/code&gt; 特权。</target>
        </trans-unit>
        <trans-unit id="004ac46cbced6bb34d9fcdda47baad54a412d6db" translate="yes" xml:space="preserve">
          <source>To be able to create a composite type, you must have &lt;code&gt;USAGE&lt;/code&gt; privilege on all attribute types.</source>
          <target state="translated">为了能够创建复合类型，您必须对所有属性类型都具有 &lt;code&gt;USAGE&lt;/code&gt; 特权。</target>
        </trans-unit>
        <trans-unit id="20b3394619973d7ff2a0ab6610243d2596213934" translate="yes" xml:space="preserve">
          <source>To be able to create a conversion, you must have &lt;code&gt;EXECUTE&lt;/code&gt; privilege on the function and &lt;code&gt;CREATE&lt;/code&gt; privilege on the destination schema.</source>
          <target state="translated">为了能够创建转换，您必须对函数具有 &lt;code&gt;EXECUTE&lt;/code&gt; 特权，对目标架构具有 &lt;code&gt;CREATE&lt;/code&gt; 特权。</target>
        </trans-unit>
        <trans-unit id="295a1d858678a24280b233e415d3074c116b7910" translate="yes" xml:space="preserve">
          <source>To be able to create a domain, you must have &lt;code&gt;USAGE&lt;/code&gt; privilege on the underlying type.</source>
          <target state="translated">为了能够创建域，您必须对基础类型具有 &lt;code&gt;USAGE&lt;/code&gt; 特权。</target>
        </trans-unit>
        <trans-unit id="0e4637b6352c01797fe0bddb86f23c5c0081af1c" translate="yes" xml:space="preserve">
          <source>To be able to create a foreign table, you must have &lt;code&gt;USAGE&lt;/code&gt; privilege on the foreign server, as well as &lt;code&gt;USAGE&lt;/code&gt; privilege on all column types used in the table.</source>
          <target state="translated">为了能够创建外部表，您必须在外部服务器上具有 &lt;code&gt;USAGE&lt;/code&gt; 特权，并且必须对表中 &lt;code&gt;USAGE&lt;/code&gt; 所有列类型具有USAGE特权。</target>
        </trans-unit>
        <trans-unit id="0ce885ed17ee0914c81250038c5ba73a1255a62b" translate="yes" xml:space="preserve">
          <source>To be able to create a function, you must have &lt;code&gt;USAGE&lt;/code&gt; privilege on the argument types and the return type.</source>
          <target state="translated">为了能够创建函数，您必须对参数类型和返回类型具有 &lt;code&gt;USAGE&lt;/code&gt; 特权。</target>
        </trans-unit>
        <trans-unit id="c3349946c487347d94244d5f0d2b8cbf6db2014c" translate="yes" xml:space="preserve">
          <source>To be able to create a procedure, you must have &lt;code&gt;USAGE&lt;/code&gt; privilege on the argument types.</source>
          <target state="translated">为了能够创建过程，您必须对参数类型具有 &lt;code&gt;USAGE&lt;/code&gt; 特权。</target>
        </trans-unit>
        <trans-unit id="3e8d0cffcf604ddb9a2b21dd6b9ecc772bbb4ea7" translate="yes" xml:space="preserve">
          <source>To be able to create a table, you must have &lt;code&gt;USAGE&lt;/code&gt; privilege on all column types or the type in the &lt;code&gt;OF&lt;/code&gt; clause, respectively.</source>
          <target state="translated">为了能够创建表，您必须分别对所有列类型或 &lt;code&gt;OF&lt;/code&gt; 子句中的类型具有 &lt;code&gt;USAGE&lt;/code&gt; 特权。</target>
        </trans-unit>
        <trans-unit id="7c3d9e2e6a7511d1edae30a9dff5bd26d7e819ca" translate="yes" xml:space="preserve">
          <source>To be able to create a transform, you must own and have &lt;code&gt;USAGE&lt;/code&gt; privilege on the type, have &lt;code&gt;USAGE&lt;/code&gt; privilege on the language, and own and have &lt;code&gt;EXECUTE&lt;/code&gt; privilege on the from-SQL and to-SQL functions, if specified.</source>
          <target state="translated">为了能够创建转换，你必须拥有并懂得 &lt;code&gt;USAGE&lt;/code&gt; 的类型特权，有 &lt;code&gt;USAGE&lt;/code&gt; 特权的语言，自己的和有 &lt;code&gt;EXECUTE&lt;/code&gt; 对从-SQL和-SQL函数的特权，如果指定。</target>
        </trans-unit>
        <trans-unit id="492ecbb35318f60a13457061cf57ee1399559558" translate="yes" xml:space="preserve">
          <source>To be able to create an aggregate function, you must have &lt;code&gt;USAGE&lt;/code&gt; privilege on the argument types, the state type(s), and the return type, as well as &lt;code&gt;EXECUTE&lt;/code&gt; privilege on the supporting functions.</source>
          <target state="translated">为了能够创建聚合函数，您必须对参数类型，状态类型和返回类型具有 &lt;code&gt;USAGE&lt;/code&gt; 特权，并且必须对支持函数具有 &lt;code&gt;EXECUTE&lt;/code&gt; 特权。</target>
        </trans-unit>
        <trans-unit id="6ec21fb5fc656c37513106d994c36fd0ac97b19a" translate="yes" xml:space="preserve">
          <source>To be able to create an operator, you must have &lt;code&gt;USAGE&lt;/code&gt; privilege on the argument types and the return type, as well as &lt;code&gt;EXECUTE&lt;/code&gt; privilege on the underlying function. If a commutator or negator operator is specified, you must own these operators.</source>
          <target state="translated">为了能够创建运算符，您必须对参数类型和返回类型具有 &lt;code&gt;USAGE&lt;/code&gt; 特权，并且对基础函数具有 &lt;code&gt;EXECUTE&lt;/code&gt; 特权。如果指定了换向或负运算符，则您必须拥有这些运算符。</target>
        </trans-unit>
        <trans-unit id="1576f76a79f37902dec9d1049cfafa4fa8226f10" translate="yes" xml:space="preserve">
          <source>To be able to drop a cast, you must own the source or the target data type. These are the same privileges that are required to create a cast.</source>
          <target state="translated">要想放弃一个数据投递,您必须拥有源数据或目标数据类型。这些权限与创建一个数据集所需的权限相同。</target>
        </trans-unit>
        <trans-unit id="f24771db16a8b952d2aba66eabbf00ce04304eb5" translate="yes" xml:space="preserve">
          <source>To be able to drop a transform, you must own the type and the language. These are the same privileges that are required to create a transform.</source>
          <target state="translated">为了能够放弃一个变换,您必须拥有类型和语言。这些权限与创建变体所需的权限相同。</target>
        </trans-unit>
        <trans-unit id="6b5f4f9a5727d863fa1595ea99bd05f639d52879" translate="yes" xml:space="preserve">
          <source>To be useful, an index access method must also have one or more &lt;em&gt;operator families&lt;/em&gt; and &lt;em&gt;operator classes&lt;/em&gt; defined in &lt;a href=&quot;catalog-pg-opfamily&quot;&gt;&lt;code&gt;pg_opfamily&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;catalog-pg-opclass&quot;&gt;&lt;code&gt;pg_opclass&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;catalog-pg-amop&quot;&gt;&lt;code&gt;pg_amop&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;catalog-pg-amproc&quot;&gt;&lt;code&gt;pg_amproc&lt;/code&gt;&lt;/a&gt;. These entries allow the planner to determine what kinds of query qualifications can be used with indexes of this access method. Operator families and classes are described in &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html&quot;&gt;Section 37.16&lt;/a&gt;, which is prerequisite material for reading this chapter.</source>
          <target state="translated">为了有用，索引访问方法还必须具有在&lt;a href=&quot;catalog-pg-opfamily&quot;&gt; &lt;code&gt;pg_opfamily&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;catalog-pg-opclass&quot;&gt; &lt;code&gt;pg_opclass&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;catalog-pg-amop&quot;&gt; &lt;code&gt;pg_amop&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;catalog-pg-amproc&quot;&gt; &lt;code&gt;pg_amproc&lt;/code&gt; 中&lt;/a&gt;定义的一个或多个&lt;em&gt;运算符系列&lt;/em&gt;和&lt;em&gt;运算符类&lt;/em&gt;。这些条目使计划者可以确定可以与该访问方法的索引一起使用的查询资格类型。在&lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html&quot;&gt;第37.16节&lt;/a&gt;中介绍了操作符族和类，这是阅读本章的前提材料。</target>
        </trans-unit>
        <trans-unit id="3c0d2058fa7ce3c9ef9d1a489e052901ecfbd7ee" translate="yes" xml:space="preserve">
          <source>To be useful, an index access method must also have one or more &lt;em&gt;operator families&lt;/em&gt; and &lt;em&gt;operator classes&lt;/em&gt; defined in &lt;a href=&quot;catalog-pg-opfamily&quot;&gt;&lt;code&gt;pg_opfamily&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;catalog-pg-opclass&quot;&gt;&lt;code&gt;pg_opclass&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;catalog-pg-amop&quot;&gt;&lt;code&gt;pg_amop&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;catalog-pg-amproc&quot;&gt;&lt;code&gt;pg_amproc&lt;/code&gt;&lt;/a&gt;. These entries allow the planner to determine what kinds of query qualifications can be used with indexes of this access method. Operator families and classes are described in &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html&quot;&gt;Section 37.16&lt;/a&gt;, which is prerequisite material for reading this chapter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20a4c4c99064dacb5bf122b1b529d83437bd93dc" translate="yes" xml:space="preserve">
          <source>To begin a SASL authentication exchange, the server sends an AuthenticationSASL message. It includes a list of SASL authentication mechanisms that the server can accept, in the server's preferred order.</source>
          <target state="translated">要开始一个SASL认证交换,服务器发送一个AuthenticationSASL消息。它包括服务器可以接受的SASL认证机制的列表,按照服务器的首选顺序。</target>
        </trans-unit>
        <trans-unit id="5d863c4c1d2466cf7360c719b28ca35b233ce142" translate="yes" xml:space="preserve">
          <source>To begin a new transaction with the same snapshot as an already existing transaction, first export the snapshot from the existing transaction. That will return the snapshot identifier, for example:</source>
          <target state="translated">要使用与现有事务相同的快照开始一个新事务,首先从现有事务中导出快照。例如,这将返回快照标识符。</target>
        </trans-unit>
        <trans-unit id="f5f67d1858f44978073928296e3d5bdf0c554243" translate="yes" xml:space="preserve">
          <source>To begin a transaction block:</source>
          <target state="translated">要开始一个交易块。</target>
        </trans-unit>
        <trans-unit id="8d63fb8b018b45b6ca4678226dc5b5b97fddd13a" translate="yes" xml:space="preserve">
          <source>To build this module, include the option &lt;code&gt;--with-selinux&lt;/code&gt; in your PostgreSQL &lt;code&gt;configure&lt;/code&gt; command. Be sure that the &lt;code&gt;libselinux-devel&lt;/code&gt; RPM is installed at build time.</source>
          <target state="translated">要构建此模块，请在PostgreSQL &lt;code&gt;configure&lt;/code&gt; 命令中包括 &lt;code&gt;--with-selinux&lt;/code&gt; 选项。确保在构建时安装了 &lt;code&gt;libselinux-devel&lt;/code&gt; RPM。</target>
        </trans-unit>
        <trans-unit id="d7fa621baea0b3b0913b5bf5570b502c47b4a36d" translate="yes" xml:space="preserve">
          <source>To call a function (not a procedure), use &lt;code&gt;SELECT&lt;/code&gt; instead.</source>
          <target state="translated">要调用函数（而不是过程），请改用 &lt;code&gt;SELECT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5bfe5b3536a1a2fad1b91e3fc2b1b162c62c4bf" translate="yes" xml:space="preserve">
          <source>To cancel a running query, send the &lt;code&gt;SIGINT&lt;/code&gt; signal to the process running that command. To terminate a backend process cleanly, send &lt;code&gt;SIGTERM&lt;/code&gt; to that process. See also &lt;code&gt;pg_cancel_backend&lt;/code&gt; and &lt;code&gt;pg_terminate_backend&lt;/code&gt; in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-SIGNAL&quot;&gt;Section 9.26.2&lt;/a&gt; for the SQL-callable equivalents of these two actions.</source>
          <target state="translated">要取消正在运行的查询，请将 &lt;code&gt;SIGINT&lt;/code&gt; 信号发送到运行该命令的进程。要干净地终止后端进程，请将 &lt;code&gt;SIGTERM&lt;/code&gt; 发送到该进程。另请参见 &lt;code&gt;pg_cancel_backend&lt;/code&gt; &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-SIGNAL&quot;&gt;节中的&lt;/a&gt;pg_cancel_backend和 &lt;code&gt;pg_terminate_backend&lt;/code&gt; ，以获取这两个动作的SQL调用等效项。</target>
        </trans-unit>
        <trans-unit id="afc70d4ddd1752f4bd9d1625d9e107d9520e6ba4" translate="yes" xml:space="preserve">
          <source>To cancel a running query, send the &lt;code&gt;SIGINT&lt;/code&gt; signal to the process running that command. To terminate a backend process cleanly, send &lt;code&gt;SIGTERM&lt;/code&gt; to that process. See also &lt;code&gt;pg_cancel_backend&lt;/code&gt; and &lt;code&gt;pg_terminate_backend&lt;/code&gt; in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-SIGNAL&quot;&gt;Section 9.27.2&lt;/a&gt; for the SQL-callable equivalents of these two actions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7124694e949a1f4440b60306713bd6c20059c689" translate="yes" xml:space="preserve">
          <source>To change an index's fill factor (assuming that the index method supports it):</source>
          <target state="translated">要改变一个索引的填充因子(假设索引方法支持它)。</target>
        </trans-unit>
        <trans-unit id="6955113ac82d44bffe42ad325ae4781dcb416e27" translate="yes" xml:space="preserve">
          <source>To change an integer column containing Unix timestamps to &lt;code&gt;timestamp with time zone&lt;/code&gt; via a &lt;code&gt;USING&lt;/code&gt; clause:</source>
          <target state="translated">通过 &lt;code&gt;USING&lt;/code&gt; 子句将包含Unix时间戳的整数列更改为 &lt;code&gt;timestamp with time zone&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9c297dad60dcd6cd314e12568c335bf0cd7fff41" translate="yes" xml:space="preserve">
          <source>To change options of a foreign table:</source>
          <target state="translated">要改变外来表的选项。</target>
        </trans-unit>
        <trans-unit id="99d1020f0ea652992c1f3cc6d0862f5775f34f3d" translate="yes" xml:space="preserve">
          <source>To change the owner of the aggregate function &lt;code&gt;myavg&lt;/code&gt; for type &lt;code&gt;integer&lt;/code&gt; to &lt;code&gt;joe&lt;/code&gt;:</source>
          <target state="translated">要将 &lt;code&gt;integer&lt;/code&gt; 类型的聚合函数 &lt;code&gt;myavg&lt;/code&gt; 的所有者更改为 &lt;code&gt;joe&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ef10e3fcd3c6781c71305649cddcd491edef3899" translate="yes" xml:space="preserve">
          <source>To change the owner of the collation &lt;code&gt;en_US&lt;/code&gt; to &lt;code&gt;joe&lt;/code&gt;:</source>
          <target state="translated">要将归类的所有者 &lt;code&gt;en_US&lt;/code&gt; 更改为 &lt;code&gt;joe&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e2210eee6a53d3f3138510ccb5b7192d71091c40" translate="yes" xml:space="preserve">
          <source>To change the owner of the conversion &lt;code&gt;iso_8859_1_to_utf8&lt;/code&gt; to &lt;code&gt;joe&lt;/code&gt;:</source>
          <target state="translated">要将转换 &lt;code&gt;iso_8859_1_to_utf8&lt;/code&gt; 的所有者更改为 &lt;code&gt;joe&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9315eb7f46fb852d6250bffd8c242174b624ca93" translate="yes" xml:space="preserve">
          <source>To change the owner of the function &lt;code&gt;sqrt&lt;/code&gt; for type &lt;code&gt;integer&lt;/code&gt; to &lt;code&gt;joe&lt;/code&gt;:</source>
          <target state="translated">要将 &lt;code&gt;integer&lt;/code&gt; 类型的函数 &lt;code&gt;sqrt&lt;/code&gt; 的所有者更改为 &lt;code&gt;joe&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e02af5ff31aa7df16e74fe6528519fcbdbfdd4a0" translate="yes" xml:space="preserve">
          <source>To change the owner of the procedure &lt;code&gt;insert_data&lt;/code&gt; with two arguments of type &lt;code&gt;integer&lt;/code&gt; to &lt;code&gt;joe&lt;/code&gt;:</source>
          <target state="translated">要将具有两个 &lt;code&gt;integer&lt;/code&gt; 类型的参数的过程 &lt;code&gt;insert_data&lt;/code&gt; 的所有者更改为 &lt;code&gt;joe&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="5e3fa5d60b34896d63a2a5418d8361fead53b69f" translate="yes" xml:space="preserve">
          <source>To change the owner of the type &lt;code&gt;email&lt;/code&gt; to &lt;code&gt;joe&lt;/code&gt;:</source>
          <target state="translated">要将 &lt;code&gt;email&lt;/code&gt; 类型的所有者更改为 &lt;code&gt;joe&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3ba22599c15d79141f2290f4581a20c44866aa92" translate="yes" xml:space="preserve">
          <source>To change the schema of the &lt;code&gt;hstore&lt;/code&gt; extension to &lt;code&gt;utils&lt;/code&gt;:</source>
          <target state="translated">要将 &lt;code&gt;hstore&lt;/code&gt; 扩展的架构更改为 &lt;code&gt;utils&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0a49ec78abaf3db529ca1802f32d2a37a26f5e05" translate="yes" xml:space="preserve">
          <source>To change the schema of the function &lt;code&gt;sqrt&lt;/code&gt; for type &lt;code&gt;integer&lt;/code&gt; to &lt;code&gt;maths&lt;/code&gt;:</source>
          <target state="translated">要将 &lt;code&gt;integer&lt;/code&gt; 类型的函数 &lt;code&gt;sqrt&lt;/code&gt; 的模式更改为 &lt;code&gt;maths&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="961024d3f9ac4941122ab86c292598b33e9c7465" translate="yes" xml:space="preserve">
          <source>To change the schema of the procedure &lt;code&gt;insert_data&lt;/code&gt; with two arguments of type &lt;code&gt;integer&lt;/code&gt; to &lt;code&gt;accounting&lt;/code&gt;:</source>
          <target state="translated">要将具有两个 &lt;code&gt;integer&lt;/code&gt; 类型的参数的过程 &lt;code&gt;insert_data&lt;/code&gt; 的模式更改为 &lt;code&gt;accounting&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e1017843ce076fcbd256ae42991691e946e03d4f" translate="yes" xml:space="preserve">
          <source>To change the schema of the type &lt;code&gt;email&lt;/code&gt; to &lt;code&gt;customers&lt;/code&gt;:</source>
          <target state="translated">更改 &lt;code&gt;email&lt;/code&gt; 给 &lt;code&gt;customers&lt;/code&gt; 电子邮件类型的模式：</target>
        </trans-unit>
        <trans-unit id="02fa2f5cd59b1c854d3ebaeb3ad99f4c5cde5f62" translate="yes" xml:space="preserve">
          <source>To change the types of two existing columns in one operation:</source>
          <target state="translated">要在一次操作中改变两个现有列的类型。</target>
        </trans-unit>
        <trans-unit id="049a5efebaaac49c898beb6813a00487d2d41002" translate="yes" xml:space="preserve">
          <source>To check the total size of the data contained in &lt;code&gt;measurement&lt;/code&gt; table described in &lt;a href=&quot;ddl-partitioning#DDL-PARTITIONING-DECLARATIVE-EXAMPLE&quot;&gt;Section 5.11.2.1&lt;/a&gt;, one could use the following query:</source>
          <target state="translated">要检查&lt;a href=&quot;ddl-partitioning#DDL-PARTITIONING-DECLARATIVE-EXAMPLE&quot;&gt;第5.11.2.1节&lt;/a&gt;中描述的 &lt;code&gt;measurement&lt;/code&gt; 表中包含的数据的总大小，可以使用以下查询：</target>
        </trans-unit>
        <trans-unit id="8a3decf48834644b5c1569c04cccf33236b32d5a" translate="yes" xml:space="preserve">
          <source>To check whether a value is or is not null, use the predicates:</source>
          <target state="translated">要检查一个值是否为空,使用谓词。</target>
        </trans-unit>
        <trans-unit id="d6ba3615ed77c16bfcd03c7a57a0a7efbe26986a" translate="yes" xml:space="preserve">
          <source>To clean a single table &lt;code&gt;foo&lt;/code&gt; in a database named &lt;code&gt;xyzzy&lt;/code&gt;, and analyze a single column &lt;code&gt;bar&lt;/code&gt; of the table for the optimizer:</source>
          <target state="translated">要在名为 &lt;code&gt;xyzzy&lt;/code&gt; 的数据库中清理单个表 &lt;code&gt;foo&lt;/code&gt; ，并为优化程序分析表的单个列 &lt;code&gt;bar&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="03d008a394089139c42aa272f11af61d21af849c" translate="yes" xml:space="preserve">
          <source>To clean a single table &lt;code&gt;onek&lt;/code&gt;, analyze it for the optimizer and print a detailed vacuum activity report:</source>
          <target state="translated">要清理单个表 &lt;code&gt;onek&lt;/code&gt; ，请对它进行优化分析并打印详细的真空活动报告：</target>
        </trans-unit>
        <trans-unit id="0223c4eeb9d8178bcdc05a32e433b2a9dbbbd79a" translate="yes" xml:space="preserve">
          <source>To clean and analyze for the optimizer a database named &lt;code&gt;bigdb&lt;/code&gt;:</source>
          <target state="translated">要为优化器清理和分析名为 &lt;code&gt;bigdb&lt;/code&gt; 的数据库：</target>
        </trans-unit>
        <trans-unit id="2ebd0dab8ff9260010700d5784ae60c43d956fbb" translate="yes" xml:space="preserve">
          <source>To clean the database &lt;code&gt;test&lt;/code&gt;:</source>
          <target state="translated">清理数据库 &lt;code&gt;test&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d36a88d4536d1564194241cddefae5029a567721" translate="yes" xml:space="preserve">
          <source>To cluster a single table &lt;code&gt;foo&lt;/code&gt; in a database named &lt;code&gt;xyzzy&lt;/code&gt;:</source>
          <target state="translated">要将单个表 &lt;code&gt;foo&lt;/code&gt; 聚集到名为 &lt;code&gt;xyzzy&lt;/code&gt; 的数据库中：</target>
        </trans-unit>
        <trans-unit id="cab04f1bb9371b8d93c069fac5fea1fc0c16730c" translate="yes" xml:space="preserve">
          <source>To cluster the database &lt;code&gt;test&lt;/code&gt;:</source>
          <target state="translated">集群数据库 &lt;code&gt;test&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8068924d6aaad9348ff2cc80e45e87a55218c74c" translate="yes" xml:space="preserve">
          <source>To combine multiple indexes, the system scans each needed index and prepares a &lt;em&gt;bitmap&lt;/em&gt; in memory giving the locations of table rows that are reported as matching that index's conditions. The bitmaps are then ANDed and ORed together as needed by the query. Finally, the actual table rows are visited and returned. The table rows are visited in physical order, because that is how the bitmap is laid out; this means that any ordering of the original indexes is lost, and so a separate sort step will be needed if the query has an &lt;code&gt;ORDER BY&lt;/code&gt; clause. For this reason, and because each additional index scan adds extra time, the planner will sometimes choose to use a simple index scan even though additional indexes are available that could have been used as well.</source>
          <target state="translated">为了合并多个索引，系统将扫描每个需要的索引，并在内存中准备一个&lt;em&gt;位图，&lt;/em&gt;以提供报告为与该索引的条件匹配的表行的位置。然后根据查询的需要对位图进行&amp;ldquo;与&amp;rdquo;或&amp;ldquo;或&amp;rdquo;运算。最后，访问并返回实际的表行。表行是按物理顺序访问的，因为这是位图的布局方式。这意味着原始索引的任何排序都将丢失，因此如果查询具有 &lt;code&gt;ORDER BY&lt;/code&gt; 子句，则需要一个单独的排序步骤。出于这个原因，并且由于每次附加索引扫描都会增加额外的时间，因此计划程序有时会选择使用简单的索引扫描，即使也可以使用其他可用的索引。</target>
        </trans-unit>
        <trans-unit id="00ca92af0e53c4377a2cb5350ec6b01f99364b8e" translate="yes" xml:space="preserve">
          <source>To commit a prepared transaction, you must be either the same user that executed the transaction originally, or a superuser. But you do not have to be in the same session that executed the transaction.</source>
          <target state="translated">要提交一个准备好的事务,你必须是最初执行事务的同一个用户,或者是一个超级用户。但你不必在执行事务的同一个会话中。</target>
        </trans-unit>
        <trans-unit id="6c2c489f97856e1040807fb30de91b1ff577ac3f" translate="yes" xml:space="preserve">
          <source>To commit the current transaction and make all changes permanent:</source>
          <target state="translated">提交当前的交易,并使所有更改永久化。</target>
        </trans-unit>
        <trans-unit id="8722e0a102936bb4e4c8a1d09a997df3bf85a004" translate="yes" xml:space="preserve">
          <source>To complicate matters, some jurisdictions have used the same timezone abbreviation to mean different UTC offsets at different times; for example, in Moscow &lt;code&gt;MSK&lt;/code&gt; has meant UTC+3 in some years and UTC+4 in others. PostgreSQL interprets such abbreviations according to whatever they meant (or had most recently meant) on the specified date; but, as with the &lt;code&gt;EST&lt;/code&gt; example above, this is not necessarily the same as local civil time on that date.</source>
          <target state="translated">使事情复杂化的是，某些管辖区使用了相同的时区缩写来表示不同时间的不同UTC偏移量；例如，在莫斯科， &lt;code&gt;MSK&lt;/code&gt; 在某些年份中表示UTC + 3，在另一些年份中表示UTC + 4。PostgreSQL根据指定日期的含义（或最近的含义）解释这些缩写。但是，与上面的 &lt;code&gt;EST&lt;/code&gt; 示例一样，该时间不必与该日期的当地民事时间相同。</target>
        </trans-unit>
        <trans-unit id="e97a3d957963e8fcc423128adb2cd06a9c70b0e8" translate="yes" xml:space="preserve">
          <source>To configure a standby server to use pg_archivecleanup, put this into its &lt;code&gt;postgresql.conf&lt;/code&gt; configuration file:</source>
          <target state="translated">要将备用服务器配置为使用pg_archivecleanup，请将其放入其 &lt;code&gt;postgresql.conf&lt;/code&gt; 配置文件中：</target>
        </trans-unit>
        <trans-unit id="15b03f0e740dbe1dcdd3d494e8fe7ef028e5cebd" translate="yes" xml:space="preserve">
          <source>To configure the standby to use this slot, &lt;code&gt;primary_slot_name&lt;/code&gt; should be configured on the standby. Here is a simple example:</source>
          <target state="translated">要将备用数据库配置为使用此插槽，应在备用数据库上配置 &lt;code&gt;primary_slot_name&lt;/code&gt; 。这是一个简单的示例：</target>
        </trans-unit>
        <trans-unit id="6290ec10542845d0ddebfa7746333f2a489b6d0f" translate="yes" xml:space="preserve">
          <source>To connect to a particular database, a user must not only pass the &lt;code&gt;pg_hba.conf&lt;/code&gt; checks, but must have the &lt;code&gt;CONNECT&lt;/code&gt; privilege for the database. If you wish to restrict which users can connect to which databases, it's usually easier to control this by granting/revoking &lt;code&gt;CONNECT&lt;/code&gt; privilege than to put the rules in &lt;code&gt;pg_hba.conf&lt;/code&gt; entries.</source>
          <target state="translated">要连接到特定的数据库，用户不仅必须通过 &lt;code&gt;pg_hba.conf&lt;/code&gt; 检查，而且必须具有数据库的 &lt;code&gt;CONNECT&lt;/code&gt; 特权。如果您想限制哪些用户可以连接到哪些数据库，通常比授予 &lt;code&gt;pg_hba.conf&lt;/code&gt; 条目更容易，通过授予/撤销 &lt;code&gt;CONNECT&lt;/code&gt; 特权来控制它。</target>
        </trans-unit>
        <trans-unit id="1ebc848d3357434419fff443659c293fb158987a" translate="yes" xml:space="preserve">
          <source>To connect to this server using psql, specify this port with the -p option:</source>
          <target state="translated">要使用psql连接到这个服务器,请使用-p选项指定这个端口。</target>
        </trans-unit>
        <trans-unit id="301edb0319104a266e632783cd094629d966049a" translate="yes" xml:space="preserve">
          <source>To convert a JSON value to the SQL type of an output column, the following rules are applied in sequence:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4410b5e31b45b8b22ca1d9903ef6943e81eb2ac0" translate="yes" xml:space="preserve">
          <source>To convert a column to a different data type, use a command like:</source>
          <target state="translated">要将列转换为不同的数据类型,请使用类似命令。</target>
        </trans-unit>
        <trans-unit id="54f9ec7b4c57109e2602a2ff40352802cb0d1e0f" translate="yes" xml:space="preserve">
          <source>To convert a traditional 48 bit MAC address in EUI-48 format to modified EUI-64 format to be included as the host portion of an IPv6 address, use &lt;code&gt;macaddr8_set7bit&lt;/code&gt; as shown:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fef5624a1d1e08c22d86e5fbc6f1e0129dd604df" translate="yes" xml:space="preserve">
          <source>To copy a table completely, the short form using the &lt;code&gt;TABLE&lt;/code&gt; command can also be used:</source>
          <target state="translated">要完全复制表，还可以使用使用 &lt;code&gt;TABLE&lt;/code&gt; 命令的缩写形式：</target>
        </trans-unit>
        <trans-unit id="e75e99b9c752d67b15f22015a111ca5f58da271e" translate="yes" xml:space="preserve">
          <source>To copy data from a file into the &lt;code&gt;country&lt;/code&gt; table:</source>
          <target state="translated">要将数据从文件复制到 &lt;code&gt;country&lt;/code&gt; 表：</target>
        </trans-unit>
        <trans-unit id="a1392415e4938e657b0920236ebe7bdc0d105f5e" translate="yes" xml:space="preserve">
          <source>To copy into a compressed file, you can pipe the output through an external compression program:</source>
          <target state="translated">要复制成压缩文件,可以通过外部压缩程序进行管道输出。</target>
        </trans-unit>
        <trans-unit id="2b0e96672f8aca7577ebe018bf4d51d014d00c0c" translate="yes" xml:space="preserve">
          <source>To copy into a file just the countries whose names start with 'A':</source>
          <target state="translated">将名字以 &quot;A &quot;开头的国家复制到文件中。</target>
        </trans-unit>
        <trans-unit id="c81ceaa4f7c9941558ec032310e1d81872cc8cae" translate="yes" xml:space="preserve">
          <source>To create a B-Tree index with deduplication disabled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9938c28d5e04efe3b2ed6d4b9e038b44b264feb1" translate="yes" xml:space="preserve">
          <source>To create a GIN index with fast updates disabled:</source>
          <target state="translated">要创建一个禁用快速更新的GIN索引。</target>
        </trans-unit>
        <trans-unit id="70b56f88ded64f4ee2c9afba4799fc0371abf06b" translate="yes" xml:space="preserve">
          <source>To create a GiST index on a point attribute so that we can efficiently use box operators on the result of the conversion function:</source>
          <target state="translated">在点属性上创建一个GiST索引,这样我们就可以有效地在转换函数的结果上使用框运算符。</target>
        </trans-unit>
        <trans-unit id="b3aea2a10769e18a2aeada094ee0d0b98f9fa398" translate="yes" xml:space="preserve">
          <source>To create a backup of a local database where the tablespace in &lt;code&gt;/opt/ts&lt;/code&gt; is relocated to &lt;code&gt;./backup/ts&lt;/code&gt;:</source>
          <target state="translated">要创建本地数据库的备份，其中 &lt;code&gt;/opt/ts&lt;/code&gt; 中的表空间已重定位到 &lt;code&gt;./backup/ts&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6459c1471fe7288d512cf1eb3beb6d53897abf59" translate="yes" xml:space="preserve">
          <source>To create a backup of a single-tablespace local database and compress this with bzip2:</source>
          <target state="translated">创建一个单表空间本地数据库的备份,并使用bzip2进行压缩。</target>
        </trans-unit>
        <trans-unit id="3c249aecad18bf81babc126ff3cabfeb813ea5fd" translate="yes" xml:space="preserve">
          <source>To create a backup of the local server with one compressed tar file for each tablespace, and store it in the directory &lt;code&gt;backup&lt;/code&gt;, showing a progress report while running:</source>
          <target state="translated">要为每个表空间使用一个压缩的tar文件创建本地服务器的备份，并将其存储在目录 &lt;code&gt;backup&lt;/code&gt; 中，在运行时显示进度报告：</target>
        </trans-unit>
        <trans-unit id="4512427b0bf3312fa6a876ae68c686a59bfc1e1a" translate="yes" xml:space="preserve">
          <source>To create a base backup of the server at &lt;code&gt;mydbserver&lt;/code&gt; and store it in the local directory &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt;:</source>
          <target state="translated">要在 &lt;code&gt;mydbserver&lt;/code&gt; 上创建服务器的基本备份并将其存储在本地目录 &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="eb53f87e549c2e3131e5b7c882b46686f7575ac8" translate="yes" xml:space="preserve">
          <source>To create a base backup of the server at &lt;code&gt;mydbserver&lt;/code&gt; and verify the integrity of the backup:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb0df0e57b686171379ea519fb078ba09100debf" translate="yes" xml:space="preserve">
          <source>To create a base backup of the server at &lt;code&gt;mydbserver&lt;/code&gt;, move the manifest somewhere outside the backup directory, and verify the backup:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dd9c8299d9f5843b300e409173ef3b9254191b7" translate="yes" xml:space="preserve">
          <source>To create a collation from an existing collation:</source>
          <target state="translated">要从现有的整理中创建一个整理。</target>
        </trans-unit>
        <trans-unit id="3c3ab8737c7f5d3cbae3bfe2663adcc61cd53c0e" translate="yes" xml:space="preserve">
          <source>To create a collation from the operating system locale &lt;code&gt;fr_FR.utf8&lt;/code&gt; (assuming the current database encoding is &lt;code&gt;UTF8&lt;/code&gt;):</source>
          <target state="translated">要从操作系统语言环境 &lt;code&gt;fr_FR.utf8&lt;/code&gt; 创建排序规则（假设当前数据库编码为 &lt;code&gt;UTF8&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="c6f995f6b55b09e4192f2da33dedebef3c0f9550" translate="yes" xml:space="preserve">
          <source>To create a collation using the ICU provider using German phone book sort order:</source>
          <target state="translated">使用德国电话簿排序顺序,使用ICU提供者创建一个整理。</target>
        </trans-unit>
        <trans-unit id="37400e312eb41c20789506b2aff48f51d113fb06" translate="yes" xml:space="preserve">
          <source>To create a conversion from encoding &lt;code&gt;UTF8&lt;/code&gt; to &lt;code&gt;LATIN1&lt;/code&gt; using &lt;code&gt;myfunc&lt;/code&gt;:</source>
          <target state="translated">要使用 &lt;code&gt;myfunc&lt;/code&gt; 创建从 &lt;code&gt;UTF8&lt;/code&gt; 编码到 &lt;code&gt;LATIN1&lt;/code&gt; 的转换：</target>
        </trans-unit>
        <trans-unit id="89d026413429cbe22fa30a37ce5992d4ad7a1deb" translate="yes" xml:space="preserve">
          <source>To create a database &lt;code&gt;music2&lt;/code&gt; with a different locale and a different character set encoding:</source>
          <target state="translated">要创建具有不同语言环境和不同字符集编码的数据库 &lt;code&gt;music2&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ddf790c056f93f33fa0d0613c7b46f81031cf7b9" translate="yes" xml:space="preserve">
          <source>To create a database &lt;code&gt;music&lt;/code&gt; with a different locale:</source>
          <target state="translated">要创建具有不同语言环境的数据库 &lt;code&gt;music&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="77c7a58e702554d6a54a59128c311148147ebec1" translate="yes" xml:space="preserve">
          <source>To create a database &lt;code&gt;sales&lt;/code&gt; owned by user &lt;code&gt;salesapp&lt;/code&gt; with a default tablespace of &lt;code&gt;salesspace&lt;/code&gt;:</source>
          <target state="translated">要创建一个数据库， &lt;code&gt;sales&lt;/code&gt; 由用户拥有 &lt;code&gt;salesapp&lt;/code&gt; 用的默认表空间 &lt;code&gt;salesspace&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3228293205178b589ad42b9758471b3eb9d23e95" translate="yes" xml:space="preserve">
          <source>To create a database by copying &lt;code&gt;template0&lt;/code&gt;, use:</source>
          <target state="translated">要通过复制 &lt;code&gt;template0&lt;/code&gt; 创建数据库，请使用：</target>
        </trans-unit>
        <trans-unit id="98c1e5ccbfb7a38c808d162facd87b5b3f873eb5" translate="yes" xml:space="preserve">
          <source>To create a database, you must be a superuser or have the special &lt;code&gt;CREATEDB&lt;/code&gt; privilege. See &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;.</source>
          <target state="translated">要创建数据库，您必须是超级用户或具有特殊的 &lt;code&gt;CREATEDB&lt;/code&gt; 特权。请参阅&lt;a href=&quot;sql-createrole&quot;&gt;创建角色&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d728f64aca75037086b1f8f773c55b39dbc706f2" translate="yes" xml:space="preserve">
          <source>To create a generated column, use the &lt;code&gt;GENERATED ALWAYS AS&lt;/code&gt; clause in &lt;code&gt;CREATE TABLE&lt;/code&gt;, for example:</source>
          <target state="translated">要创建生成的列，请使用 &lt;code&gt;CREATE TABLE&lt;/code&gt; 中的 &lt;code&gt;GENERATED ALWAYS AS&lt;/code&gt; 子句，例如：</target>
        </trans-unit>
        <trans-unit id="fe6d46bed46bf76a565070a6f714a6f85543fb8b" translate="yes" xml:space="preserve">
          <source>To create a new database, in this example named &lt;code&gt;mydb&lt;/code&gt;, you use the following command:</source>
          <target state="translated">要创建一个新数据库，在此示例中名为 &lt;code&gt;mydb&lt;/code&gt; ，请使用以下命令：</target>
        </trans-unit>
        <trans-unit id="944120cb7dfcbcf00146c8068b87b4b7681b58f2" translate="yes" xml:space="preserve">
          <source>To create a new database:</source>
          <target state="translated">要创建一个新的数据库:</target>
        </trans-unit>
        <trans-unit id="164615fbd4052417b63e19f9e6150d9fa43cadd5" translate="yes" xml:space="preserve">
          <source>To create a new row, use the &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt; command. The command requires the table name and column values. For example, consider the products table from &lt;a href=&quot;https://www.postgresql.org/docs/12/ddl.html&quot;&gt;Chapter 5&lt;/a&gt;:</source>
          <target state="translated">要创建新行，请使用&lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt;命令。该命令需要表名称和列值。例如，考虑&lt;a href=&quot;https://www.postgresql.org/docs/12/ddl.html&quot;&gt;第5章中&lt;/a&gt;的产品表：</target>
        </trans-unit>
        <trans-unit id="0b0381516c88992d8b9c8e464528fb80a6968228" translate="yes" xml:space="preserve">
          <source>To create a new row, use the &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt; command. The command requires the table name and column values. For example, consider the products table from &lt;a href=&quot;https://www.postgresql.org/docs/13/ddl.html&quot;&gt;Chapter 5&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e4a9625799af4fa2c817e41733ba1818843f4bc" translate="yes" xml:space="preserve">
          <source>To create a nondeterministic collation, specify the property &lt;code&gt;deterministic = false&lt;/code&gt; to &lt;code&gt;CREATE COLLATION&lt;/code&gt;, for example:</source>
          <target state="translated">要创建非确定性排序规则，请为 &lt;code&gt;CREATE COLLATION&lt;/code&gt; 指定属性 &lt;code&gt;deterministic = false&lt;/code&gt; ，例如：</target>
        </trans-unit>
        <trans-unit id="1bece4672c16769d53407f8ac1fce152578224a4" translate="yes" xml:space="preserve">
          <source>To create a partial index that suits our example, use a command such as this:</source>
          <target state="translated">要创建一个适合本例的部分索引,请使用这样的命令。</target>
        </trans-unit>
        <trans-unit id="94c4a05ba1b161a82cb7f1cede5c13fa27ff0d31" translate="yes" xml:space="preserve">
          <source>To create a publication, the invoking user must have the &lt;code&gt;CREATE&lt;/code&gt; privilege for the current database. (Of course, superusers bypass this check.)</source>
          <target state="translated">若要创建发布，调用用户必须对当前数据库具有 &lt;code&gt;CREATE&lt;/code&gt; 特权。（当然，超级用户会绕过此检查。）</target>
        </trans-unit>
        <trans-unit id="4e19fe1acbe2c89906009c9ae7f5b9b8e50b0116" translate="yes" xml:space="preserve">
          <source>To create a publication, the user must have the &lt;code&gt;CREATE&lt;/code&gt; privilege in the database.</source>
          <target state="translated">若要创建发布，用户必须在数据库中具有 &lt;code&gt;CREATE&lt;/code&gt; 特权。</target>
        </trans-unit>
        <trans-unit id="82818a82b8737a5ccba600431c5567222d5f7217" translate="yes" xml:space="preserve">
          <source>To create a schema, the invoking user must have the &lt;code&gt;CREATE&lt;/code&gt; privilege for the current database. (Of course, superusers bypass this check.)</source>
          <target state="translated">要创建模式，调用用户必须对当前数据库具有 &lt;code&gt;CREATE&lt;/code&gt; 特权。（当然，超级用户会绕过此检查。）</target>
        </trans-unit>
        <trans-unit id="5e16e57c628302c59115654ccf739b24bc40990c" translate="yes" xml:space="preserve">
          <source>To create a schema, use the &lt;a href=&quot;sql-createschema&quot;&gt;CREATE SCHEMA&lt;/a&gt; command. Give the schema a name of your choice. For example:</source>
          <target state="translated">要创建模式，请使用&lt;a href=&quot;sql-createschema&quot;&gt;CREATE SCHEMA&lt;/a&gt;命令。给模式一个您选择的名称。例如：</target>
        </trans-unit>
        <trans-unit id="7c076c41c550c9d20ce9da7cb634e90253f684fe" translate="yes" xml:space="preserve">
          <source>To create a server certificate whose identity can be validated by clients, first create a certificate signing request (CSR) and a public/private key file:</source>
          <target state="translated">要创建一个身份可以被客户端验证的服务器证书,首先要创建一个证书签名请求(CSR)和一个公钥/私钥文件。</target>
        </trans-unit>
        <trans-unit id="7b7bd094f458984cd99ccbc500517389e47e3d27" translate="yes" xml:space="preserve">
          <source>To create a simple self-signed certificate for the server, valid for 365 days, use the following OpenSSL command, replacing &lt;code&gt;dbhost.yourdomain.com&lt;/code&gt; with the server's host name:</source>
          <target state="translated">要为服务器创建简单的自签名证书（有效期为365天），请使用以下OpenSSL命令，将 &lt;code&gt;dbhost.yourdomain.com&lt;/code&gt; 替换为服务器的主机名：</target>
        </trans-unit>
        <trans-unit id="cdc276e86df85d79d1975e1aab1405440c49a4a5" translate="yes" xml:space="preserve">
          <source>To create a subscription, the user must be a superuser.</source>
          <target state="translated">要创建一个订阅,用户必须是超级用户。</target>
        </trans-unit>
        <trans-unit id="f62ecd7fc3b3c7cddbee7892269e1b205e56b9f5" translate="yes" xml:space="preserve">
          <source>To create a table alias, write</source>
          <target state="translated">要创建一个表的别名,写</target>
        </trans-unit>
        <trans-unit id="a36b6ab5a3c0f86da9166604c99b7556b78e53d3" translate="yes" xml:space="preserve">
          <source>To create a table, you use the aptly named &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; command. In this command you specify at least a name for the new table, the names of the columns and the data type of each column. For example:</source>
          <target state="translated">要创建表，请使用适当命名的&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;命令。在此命令中，您至少要为新表指定一个名称，各列的名称以及各列的数据类型。例如：</target>
        </trans-unit>
        <trans-unit id="ef7e4c5658e9c01ed12be2b853f9a21a21c0a775" translate="yes" xml:space="preserve">
          <source>To create a tablespace &lt;code&gt;dbspace&lt;/code&gt; at file system location &lt;code&gt;/data/dbs&lt;/code&gt;, first create the directory using operating system facilities and set the correct ownership:</source>
          <target state="translated">要在文件系统位置 &lt;code&gt;/data/dbs&lt;/code&gt; 上创建表空间 &lt;code&gt;dbspace&lt;/code&gt; ，请首先使用操作系统工具创建目录并设置正确的所有权：</target>
        </trans-unit>
        <trans-unit id="c90745ea9680b02fd1264be6b5adf41862e7bb1b" translate="yes" xml:space="preserve">
          <source>To create a tablespace owned by a different database user, use a command like this:</source>
          <target state="translated">要创建一个由不同数据库用户拥有的表空间,请使用这样的命令。</target>
        </trans-unit>
        <trans-unit id="59a1849fe63b24cb0890dd29697e64e3955e0989" translate="yes" xml:space="preserve">
          <source>To create a transform for type &lt;code&gt;hstore&lt;/code&gt; and language &lt;code&gt;plpythonu&lt;/code&gt;, first set up the type and the language:</source>
          <target state="translated">要创建一个变换型 &lt;code&gt;hstore&lt;/code&gt; 和语言 &lt;code&gt;plpythonu&lt;/code&gt; ，首次设立的类型和语言：</target>
        </trans-unit>
        <trans-unit id="82e9f78b5e0935384e76288e143c8285785f8f57" translate="yes" xml:space="preserve">
          <source>To create a trigger on a table, the user must have the &lt;code&gt;TRIGGER&lt;/code&gt; privilege on the table. The user must also have &lt;code&gt;EXECUTE&lt;/code&gt; privilege on the trigger function.</source>
          <target state="translated">要在表上创建触发器，用户必须在表上具有 &lt;code&gt;TRIGGER&lt;/code&gt; 特权。用户还必须具有触发功能的 &lt;code&gt;EXECUTE&lt;/code&gt; 特权。</target>
        </trans-unit>
        <trans-unit id="2ad55cc89474d269f7ab84efbc2f63c3cf2a776a" translate="yes" xml:space="preserve">
          <source>To create a unique B-tree index on the column &lt;code&gt;title&lt;/code&gt; in the table &lt;code&gt;films&lt;/code&gt;:</source>
          <target state="translated">在 &lt;code&gt;films&lt;/code&gt; 表的列 &lt;code&gt;title&lt;/code&gt; 上创建唯一的B树索引：</target>
        </trans-unit>
        <trans-unit id="5ac8384bf603c41e77fc0497788f00754dc4f97d" translate="yes" xml:space="preserve">
          <source>To create a unique B-tree index on the column &lt;code&gt;title&lt;/code&gt; with included columns &lt;code&gt;director&lt;/code&gt; and &lt;code&gt;rating&lt;/code&gt; in the table &lt;code&gt;films&lt;/code&gt;:</source>
          <target state="translated">要在列 &lt;code&gt;title&lt;/code&gt; 上创建一个唯一的B树索引，并在表格 &lt;code&gt;films&lt;/code&gt; 包含所包含的列 &lt;code&gt;director&lt;/code&gt; 和 &lt;code&gt;rating&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2771d4c58e957e52b458e2099556c1af64484a04" translate="yes" xml:space="preserve">
          <source>To create a user &lt;code&gt;joe&lt;/code&gt; on the default database server with prompting for some additional attributes:</source>
          <target state="translated">要在默认数据库服务器上创建用户 &lt;code&gt;joe&lt;/code&gt; 并提示一些其他属性，请执行以下操作：</target>
        </trans-unit>
        <trans-unit id="237677bf7f6116190203bde2a56293c2c9744671" translate="yes" xml:space="preserve">
          <source>To create a user &lt;code&gt;joe&lt;/code&gt; on the default database server:</source>
          <target state="translated">要在默认数据库服务器上创建用户 &lt;code&gt;joe&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c626cd27d2903b041a265be4cbc4cd70ada6c091" translate="yes" xml:space="preserve">
          <source>To create an Ispell dictionary perform these steps:</source>
          <target state="translated">要创建一个 Ispell 字典,请执行这些步骤。</target>
        </trans-unit>
        <trans-unit id="7f623c21177eb05a9c2c99ce655edbf1921ade3c" translate="yes" xml:space="preserve">
          <source>To create an assignment cast from type &lt;code&gt;bigint&lt;/code&gt; to type &lt;code&gt;int4&lt;/code&gt; using the function &lt;code&gt;int4(bigint)&lt;/code&gt;:</source>
          <target state="translated">要使用函数 &lt;code&gt;int4(bigint)&lt;/code&gt; 创建从 &lt;code&gt;bigint&lt;/code&gt; 类型到 &lt;code&gt;int4&lt;/code&gt; 类型的转换：</target>
        </trans-unit>
        <trans-unit id="7e425065f3f16826d8585cb251e9294cec898cef" translate="yes" xml:space="preserve">
          <source>To create an index on the column &lt;code&gt;code&lt;/code&gt; in the table &lt;code&gt;films&lt;/code&gt; and have the index reside in the tablespace &lt;code&gt;indexspace&lt;/code&gt;:</source>
          <target state="translated">上创建列的索引 &lt;code&gt;code&lt;/code&gt; 表中的 &lt;code&gt;films&lt;/code&gt; 和具有索引驻留在表 &lt;code&gt;indexspace&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="51282a9a6eaf7d1d2c775ba39707e66f5cc8d2ab" translate="yes" xml:space="preserve">
          <source>To create an index on the expression &lt;code&gt;lower(title)&lt;/code&gt;, allowing efficient case-insensitive searches:</source>
          <target state="translated">要在表达式 &lt;code&gt;lower(title)&lt;/code&gt; 上创建索引，允许有效的不区分大小写的搜索：</target>
        </trans-unit>
        <trans-unit id="05080049ba907f8e2ebb4f8e83189ac4df6eae27" translate="yes" xml:space="preserve">
          <source>To create an index with non-default collation:</source>
          <target state="translated">要创建一个非默认整理的索引。</target>
        </trans-unit>
        <trans-unit id="ae5e619c87b8495a3c775c2e057cf9cc24726284" translate="yes" xml:space="preserve">
          <source>To create an index with non-default fill factor:</source>
          <target state="translated">创建一个非默认填充因子的索引。</target>
        </trans-unit>
        <trans-unit id="aa7ca2ae5a8ba1b87ad938de2374091c155e63c3" translate="yes" xml:space="preserve">
          <source>To create an index with non-default sort ordering of nulls:</source>
          <target state="translated">创建一个非默认的空值排序的索引。</target>
        </trans-unit>
        <trans-unit id="3bfa732afcdfdf06839ce25d42124ae300659f8e" translate="yes" xml:space="preserve">
          <source>To create an index without locking out writes to the table:</source>
          <target state="translated">要创建一个索引,而不锁定对表的写入。</target>
        </trans-unit>
        <trans-unit id="5c56e64ec1ccb1bef0256a294be67b1b84c00ee6" translate="yes" xml:space="preserve">
          <source>To create binary I/O functions for an existing base type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d53339e9d8aae8b8d5f4abfe2e3853a4dcdbc60c" translate="yes" xml:space="preserve">
          <source>To create functions in a procedural language, a user must have the &lt;code&gt;USAGE&lt;/code&gt; privilege for the language. By default, &lt;code&gt;USAGE&lt;/code&gt; is granted to &lt;code&gt;PUBLIC&lt;/code&gt; (i.e., everyone) for trusted languages. This can be revoked if desired.</source>
          <target state="translated">要使用过程语言创建函数，用户必须具有该语言的 &lt;code&gt;USAGE&lt;/code&gt; 特权。默认情况下， &lt;code&gt;USAGE&lt;/code&gt; 被授予 &lt;code&gt;PUBLIC&lt;/code&gt; （即每个人）可信赖的语言。如果需要，可以将其撤消。</target>
        </trans-unit>
        <trans-unit id="128acbfc6605f02795881a6d5e5df2f768c7238b" translate="yes" xml:space="preserve">
          <source>To create or access objects in a schema, write a &lt;em&gt;qualified name&lt;/em&gt; consisting of the schema name and table name separated by a dot:</source>
          <target state="translated">要在架构中创建或访问对象，请写一个&lt;em&gt;限定名称&lt;/em&gt;，该&lt;em&gt;名称&lt;/em&gt;由架构名称和表名称组成，并用点号分隔：</target>
        </trans-unit>
        <trans-unit id="319b11f872179f690e1c636d54351f3fcf40ca66" translate="yes" xml:space="preserve">
          <source>To create the database &lt;code&gt;demo&lt;/code&gt; using the default database server:</source>
          <target state="translated">要使用默认数据库服务器创建数据库 &lt;code&gt;demo&lt;/code&gt; ，请执行以下操作：</target>
        </trans-unit>
        <trans-unit id="e89ca2b57992709dac0e0f7f21762ad921861100" translate="yes" xml:space="preserve">
          <source>To create the database &lt;code&gt;demo&lt;/code&gt; using the server on host &lt;code&gt;eden&lt;/code&gt;, port 5000, using the &lt;code&gt;template0&lt;/code&gt; template database, here is the command-line command and the underlying SQL command:</source>
          <target state="translated">要使用 &lt;code&gt;template0&lt;/code&gt; 模板数据库，使用主机 &lt;code&gt;eden&lt;/code&gt; 端口5000 上的服务器创建数据库 &lt;code&gt;demo&lt;/code&gt; ，这是命令行命令和基础SQL命令：</target>
        </trans-unit>
        <trans-unit id="7ed18302d2f5c67326d42076e0c535c3180f4594" translate="yes" xml:space="preserve">
          <source>To create the same user &lt;code&gt;joe&lt;/code&gt; using the server on host &lt;code&gt;eden&lt;/code&gt;, port 5000, with attributes explicitly specified, taking a look at the underlying command:</source>
          <target state="translated">要使用主机 &lt;code&gt;eden&lt;/code&gt; 的端口5000 上的服务器创建相同的用户 &lt;code&gt;joe&lt;/code&gt; ，并显式指定了属性，请查看基础命令：</target>
        </trans-unit>
        <trans-unit id="04dfb9f7e981bc2d21a15704ba7750b7d32766f0" translate="yes" xml:space="preserve">
          <source>To create the user &lt;code&gt;joe&lt;/code&gt; as a superuser, and assign a password immediately:</source>
          <target state="translated">要将用户 &lt;code&gt;joe&lt;/code&gt; 创建为超级用户，并立即分配密码：</target>
        </trans-unit>
        <trans-unit id="babc49c12d3facd66590239c46cb7e620e0bfd11" translate="yes" xml:space="preserve">
          <source>To deal with default (anonymous) namespaces, do something like this:</source>
          <target state="translated">要处理默认(匿名)的命名空间,可以这样做。</target>
        </trans-unit>
        <trans-unit id="344821e66e6da00575ec49ea28e499cd7bece96a" translate="yes" xml:space="preserve">
          <source>To deal with text in different Unicode normalization forms, it is also an option to use the functions/expressions &lt;code&gt;normalize&lt;/code&gt; and &lt;code&gt;is normalized&lt;/code&gt; to preprocess or check the strings, instead of using nondeterministic collations. There are different trade-offs for each approach.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd9e4512d47fc711a9256823ffecbf1d45d4bd71" translate="yes" xml:space="preserve">
          <source>To deal with the case where &lt;code&gt;pg_control&lt;/code&gt; is corrupt, we should support the possibility of scanning existing log segments in reverse order &amp;mdash; newest to oldest &amp;mdash; in order to find the latest checkpoint. This has not been implemented yet. &lt;code&gt;pg_control&lt;/code&gt; is small enough (less than one disk page) that it is not subject to partial-write problems, and as of this writing there have been no reports of database failures due solely to the inability to read &lt;code&gt;pg_control&lt;/code&gt; itself. So while it is theoretically a weak spot, &lt;code&gt;pg_control&lt;/code&gt; does not seem to be a problem in practice.</source>
          <target state="translated">为了处理 &lt;code&gt;pg_control&lt;/code&gt; 损坏的情况，我们应该支持以相反的顺序（最新到最旧）扫描现有日志段的可能性，以便找到最新的检查点。尚未实现。 &lt;code&gt;pg_control&lt;/code&gt; 足够小（少于一个磁盘页面），因此不会出现部分写入问题，并且在撰写本文时，还没有关于数据库故障的报告，这完全是由于无法读取 &lt;code&gt;pg_control&lt;/code&gt; 本身引起的。因此，尽管从理论上讲它是一个弱点，但在实际中 &lt;code&gt;pg_control&lt;/code&gt; 似乎不是问题。</target>
        </trans-unit>
        <trans-unit id="39c5bf42838c1568d98d59b59281df581edfb974" translate="yes" xml:space="preserve">
          <source>To deal with this problem, PostgreSQL has a notion of &lt;em&gt;timelines&lt;/em&gt;. Whenever an archive recovery completes, a new timeline is created to identify the series of WAL records generated after that recovery. The timeline ID number is part of WAL segment file names so a new timeline does not overwrite the WAL data generated by previous timelines. It is in fact possible to archive many different timelines. While that might seem like a useless feature, it's often a lifesaver. Consider the situation where you aren't quite sure what point-in-time to recover to, and so have to do several point-in-time recoveries by trial and error until you find the best place to branch off from the old history. Without timelines this process would soon generate an unmanageable mess. With timelines, you can recover to &lt;em&gt;any&lt;/em&gt; prior state, including states in timeline branches that you abandoned earlier.</source>
          <target state="translated">为了解决这个问题，PostgreSQL有一个&lt;em&gt;时间表&lt;/em&gt;的概念。每当档案恢复完成时，都会创建一个新的时间表来标识在恢复之后生成的一系列WAL记录。时间线ID号是WAL段文件名的一部分，因此新的时间线不会覆盖以前时间线生成的WAL数据。实际上，可以存档许多不同的时间表。虽然这似乎是一个无用的功能，但它通常是救生员。考虑一下您不太确定要恢复到哪个时间点的情况，因此必须通过反复试验进行几次时间点恢复，直到找到从旧历史中获得最佳分支的最佳位置。没有时间表，这个过程很快就会造成混乱。使用时间表，您可以恢复到&lt;em&gt;任何时间&lt;/em&gt; 先前状态，包括您先前放弃的时间轴分支中的状态。</target>
        </trans-unit>
        <trans-unit id="6d2134c754d1f2a6c1e2e46af69683b00472282e" translate="yes" xml:space="preserve">
          <source>To declare a cursor:</source>
          <target state="translated">要声明一个游标。</target>
        </trans-unit>
        <trans-unit id="84af5092ab2a247997e10ca0d1bc473758fcfac3" translate="yes" xml:space="preserve">
          <source>To define a new thesaurus dictionary, use the &lt;code&gt;thesaurus&lt;/code&gt; template. For example:</source>
          <target state="translated">要定义新的词库词典，请使用 &lt;code&gt;thesaurus&lt;/code&gt; 模板。例如：</target>
        </trans-unit>
        <trans-unit id="986fed59a4009699f6854122fd2da5a9d70e789c" translate="yes" xml:space="preserve">
          <source>To define a tablespace, use the &lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt; command, for example::</source>
          <target state="translated">要定义表空间，请使用&lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt;命令，例如：</target>
        </trans-unit>
        <trans-unit id="3322b8a3e9208d1b84d64763aa4d498d5f5f9b90" translate="yes" xml:space="preserve">
          <source>To define a unique constraint for a group of columns, write it as a table constraint with the column names separated by commas:</source>
          <target state="translated">要为一组列定义唯一的约束,将其写成表约束,列名用逗号分隔。</target>
        </trans-unit>
        <trans-unit id="13984f59bd22b2e9a275f04bd11f7f208d4ebb22" translate="yes" xml:space="preserve">
          <source>To destroy a group role, use &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt;:</source>
          <target state="translated">要销毁组角色，请使用&lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="64a4ab0af63189bc2f7d08c702da849479dd3444" translate="yes" xml:space="preserve">
          <source>To destroy the database &lt;code&gt;demo&lt;/code&gt; on the default database server:</source>
          <target state="translated">要销毁默认数据库服务器上的数据库 &lt;code&gt;demo&lt;/code&gt; ，请执行以下操作：</target>
        </trans-unit>
        <trans-unit id="f03b9dc196b5135db2ccadd50b164e25c9e5713e" translate="yes" xml:space="preserve">
          <source>To destroy the database &lt;code&gt;demo&lt;/code&gt; using the server on host &lt;code&gt;eden&lt;/code&gt;, port 5000, with verification and a peek at the underlying command:</source>
          <target state="translated">要使用主机 &lt;code&gt;eden&lt;/code&gt; 端口5000 上的服务器销毁数据库 &lt;code&gt;demo&lt;/code&gt; ，请进行验证并查看基本命令：</target>
        </trans-unit>
        <trans-unit id="df964b5603cc1f31ca3e16e223d4d090f27c044b" translate="yes" xml:space="preserve">
          <source>To destroy two foreign tables, &lt;code&gt;films&lt;/code&gt; and &lt;code&gt;distributors&lt;/code&gt;:</source>
          <target state="translated">销毁两个外国桌子， &lt;code&gt;films&lt;/code&gt; 和 &lt;code&gt;distributors&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="5ec6a07ba428b18226f2b5a402d4961467e4a4ea" translate="yes" xml:space="preserve">
          <source>To destroy two statistics objects in different schemas, without failing if they don't exist:</source>
          <target state="translated">销毁不同模式下的两个统计对象,如果它们不存在,则不会失败。</target>
        </trans-unit>
        <trans-unit id="81af71b34f901bb661a7e2f097b2993687db9cf7" translate="yes" xml:space="preserve">
          <source>To destroy two tables, &lt;code&gt;films&lt;/code&gt; and &lt;code&gt;distributors&lt;/code&gt;:</source>
          <target state="translated">销毁两张桌子， &lt;code&gt;films&lt;/code&gt; 和 &lt;code&gt;distributors&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b252fd181d3818b104f824d7c95b6854e6d1ece7" translate="yes" xml:space="preserve">
          <source>To detach a partition from a partitioned table:</source>
          <target state="translated">要从分区表中分离出一个分区。</target>
        </trans-unit>
        <trans-unit id="0044107f538078feefff2c648b605c188ca65c2e" translate="yes" xml:space="preserve">
          <source>To determine the appropriate binary format for the actual tuple data you should consult the PostgreSQL source, in particular the &lt;code&gt;*send&lt;/code&gt; and &lt;code&gt;*recv&lt;/code&gt; functions for each column's data type (typically these functions are found in the &lt;code&gt;src/backend/utils/adt/&lt;/code&gt; directory of the source distribution).</source>
          <target state="translated">要为实际的元组数据确定适当的二进制格式，应查阅PostgreSQL的资料，特别是每列数据类型的 &lt;code&gt;*send&lt;/code&gt; 和 &lt;code&gt;*recv&lt;/code&gt; 函数（通常在以下目录的 &lt;code&gt;src/backend/utils/adt/&lt;/code&gt; 目录中找到这些函数）源代码分发）。</target>
        </trans-unit>
        <trans-unit id="e31d0944ab57fd8cade86828e515e67c0b9e0ae8" translate="yes" xml:space="preserve">
          <source>To determine the order of the concatenation, an &lt;code&gt;ORDER BY&lt;/code&gt; clause may be added to the aggregate call as described in &lt;a href=&quot;sql-expressions#SYNTAX-AGGREGATES&quot;&gt;Section 4.2.7&lt;/a&gt;. For example:</source>
          <target state="translated">为了确定连接的顺序，可以将 &lt;code&gt;ORDER BY&lt;/code&gt; 子句添加到聚合调用中，如&lt;a href=&quot;sql-expressions#SYNTAX-AGGREGATES&quot;&gt;第4.2.7节中&lt;/a&gt;所述。例如：</target>
        </trans-unit>
        <trans-unit id="1cc82b13558ed0c2d82c9bba8c5ef830aa7a5ef2" translate="yes" xml:space="preserve">
          <source>To determine the set of existing roles, examine the &lt;code&gt;pg_roles&lt;/code&gt; system catalog, for example</source>
          <target state="translated">要确定一组现有角色，请检查 &lt;code&gt;pg_roles&lt;/code&gt; 系统目录，例如</target>
        </trans-unit>
        <trans-unit id="0b4a4628e23a852dc21a12a35a6273456e5d0a74" translate="yes" xml:space="preserve">
          <source>To determine the set of existing tablespaces, examine the &lt;a href=&quot;catalog-pg-tablespace&quot;&gt;&lt;code&gt;pg_tablespace&lt;/code&gt;&lt;/a&gt; system catalog, for example</source>
          <target state="translated">要确定现有表空间的集合，请检查&lt;a href=&quot;catalog-pg-tablespace&quot;&gt; &lt;code&gt;pg_tablespace&lt;/code&gt; &lt;/a&gt;系统目录，例如</target>
        </trans-unit>
        <trans-unit id="67be13fb22fe0a90f5bd44f329bd0f53bd1ebaeb" translate="yes" xml:space="preserve">
          <source>To determine whether JIT compilation should be used, the total estimated cost of a query (see &lt;a href=&quot;https://www.postgresql.org/docs/12/planner-stats-details.html&quot;&gt;Chapter 70&lt;/a&gt; and &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-CONSTANTS&quot;&gt;Section 19.7.2&lt;/a&gt;) is used. The estimated cost of the query will be compared with the setting of &lt;a href=&quot;runtime-config-query#GUC-JIT-ABOVE-COST&quot;&gt;jit_above_cost&lt;/a&gt;. If the cost is higher, JIT compilation will be performed. Two further decisions are then needed. Firstly, if the estimated cost is more than the setting of &lt;a href=&quot;runtime-config-query#GUC-JIT-INLINE-ABOVE-COST&quot;&gt;jit_inline_above_cost&lt;/a&gt;, short functions and operators used in the query will be inlined. Secondly, if the estimated cost is more than the setting of &lt;a href=&quot;runtime-config-query#GUC-JIT-OPTIMIZE-ABOVE-COST&quot;&gt;jit_optimize_above_cost&lt;/a&gt;, expensive optimizations are applied to improve the generated code. Each of these options increases the JIT compilation overhead, but can reduce query execution time considerably.</source>
          <target state="translated">要确定JIT编译是否应该被使用，查询的总费用估计（见&lt;a href=&quot;https://www.postgresql.org/docs/12/planner-stats-details.html&quot;&gt;第70&lt;/a&gt;和&lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-CONSTANTS&quot;&gt;第19.7.2&lt;/a&gt;）被使用。查询的估计成本将与&lt;a href=&quot;runtime-config-query#GUC-JIT-ABOVE-COST&quot;&gt;jit_above_cost&lt;/a&gt;的设置进行比较。如果成本较高，将执行JIT编译。然后需要两个进一步的决定。首先，如果估计成本大于&lt;a href=&quot;runtime-config-query#GUC-JIT-INLINE-ABOVE-COST&quot;&gt;jit_inline_above_cost&lt;/a&gt;的设置，则将内联查询中使用的短函数和运算符。其次，如果估算成本大于&lt;a href=&quot;runtime-config-query#GUC-JIT-OPTIMIZE-ABOVE-COST&quot;&gt;jit_optimize_above_cost&lt;/a&gt;的设置，需要进行昂贵的优化以改进生成的代码。这些选项中的每一个都增加了JIT编译的开销，但是可以大大减少查询的执行时间。</target>
        </trans-unit>
        <trans-unit id="fd4e4acd3d33ab5ee068584350285b4aee8a5f68" translate="yes" xml:space="preserve">
          <source>To determine whether JIT compilation should be used, the total estimated cost of a query (see &lt;a href=&quot;https://www.postgresql.org/docs/13/planner-stats-details.html&quot;&gt;Chapter 70&lt;/a&gt; and &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-CONSTANTS&quot;&gt;Section 19.7.2&lt;/a&gt;) is used. The estimated cost of the query will be compared with the setting of &lt;a href=&quot;runtime-config-query#GUC-JIT-ABOVE-COST&quot;&gt;jit_above_cost&lt;/a&gt;. If the cost is higher, JIT compilation will be performed. Two further decisions are then needed. Firstly, if the estimated cost is more than the setting of &lt;a href=&quot;runtime-config-query#GUC-JIT-INLINE-ABOVE-COST&quot;&gt;jit_inline_above_cost&lt;/a&gt;, short functions and operators used in the query will be inlined. Secondly, if the estimated cost is more than the setting of &lt;a href=&quot;runtime-config-query#GUC-JIT-OPTIMIZE-ABOVE-COST&quot;&gt;jit_optimize_above_cost&lt;/a&gt;, expensive optimizations are applied to improve the generated code. Each of these options increases the JIT compilation overhead, but can reduce query execution time considerably.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff46a0305932a1f3445ee6313f1d0daf52062e57" translate="yes" xml:space="preserve">
          <source>To disable automatic setting of &lt;code&gt;search_path&lt;/code&gt; for a function:</source>
          <target state="translated">禁用功能的 &lt;code&gt;search_path&lt;/code&gt; 的自动设置：</target>
        </trans-unit>
        <trans-unit id="77fbee93c3d08bf4bda4ad9e741740820f97d1d4" translate="yes" xml:space="preserve">
          <source>To disable automatic setting of &lt;code&gt;search_path&lt;/code&gt; for a procedure:</source>
          <target state="translated">要为过程禁用自动设置 &lt;code&gt;search_path&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0b6c666b2d88a7708fb69cf0c000987713ddc46b" translate="yes" xml:space="preserve">
          <source>To disable index scans by default in the database &lt;code&gt;test&lt;/code&gt;:</source>
          <target state="translated">要在数据库 &lt;code&gt;test&lt;/code&gt; 默认禁用索引扫描：</target>
        </trans-unit>
        <trans-unit id="974aa31fe110ad158240e77cb25b55cdcd0f2bb8" translate="yes" xml:space="preserve">
          <source>To drop a column from a table:</source>
          <target state="translated">要从表中删除一列。</target>
        </trans-unit>
        <trans-unit id="7563d557973f5540735b227a3024deefab9a8f9a" translate="yes" xml:space="preserve">
          <source>To drop a role:</source>
          <target state="translated">要放弃一个角色。</target>
        </trans-unit>
        <trans-unit id="ea1476cc270643bf4c0daffe9f6762c612c57a68" translate="yes" xml:space="preserve">
          <source>To drop a schema if it's empty (all objects in it have been dropped), use:</source>
          <target state="translated">如果一个模式是空的(其中的所有对象都已被删除),请使用。</target>
        </trans-unit>
        <trans-unit id="98f5a15e760ae655ecd92960d3186ff62d5da1a9" translate="yes" xml:space="preserve">
          <source>To drop a schema including all contained objects, use:</source>
          <target state="translated">要放弃一个包括所有包含对象的模式,使用。</target>
        </trans-unit>
        <trans-unit id="ae7da2be12d9a6b52a1340412503a9cc6c084b6b" translate="yes" xml:space="preserve">
          <source>To drop the cast from type &lt;code&gt;text&lt;/code&gt; to type &lt;code&gt;int&lt;/code&gt;:</source>
          <target state="translated">要将类型从 &lt;code&gt;text&lt;/code&gt; 转换为 &lt;code&gt;int&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="5d7ae6be69ee16ba6ee8e2f538a3a91b6b9353cc" translate="yes" xml:space="preserve">
          <source>To drop the collation named &lt;code&gt;german&lt;/code&gt;:</source>
          <target state="translated">删除归类为 &lt;code&gt;german&lt;/code&gt; 的排序规则：</target>
        </trans-unit>
        <trans-unit id="765c47319b0ff7251415602face256f2933e7d23" translate="yes" xml:space="preserve">
          <source>To drop the conversion named &lt;code&gt;myname&lt;/code&gt;:</source>
          <target state="translated">删除名为 &lt;code&gt;myname&lt;/code&gt; 的转换：</target>
        </trans-unit>
        <trans-unit id="a5dd444bb871586a10018bf6ff6b8b8550a2c9a8" translate="yes" xml:space="preserve">
          <source>To drop the database and recreate it from the dump:</source>
          <target state="translated">要放弃数据库并从转储中重新创建数据库。</target>
        </trans-unit>
        <trans-unit id="95246e041a3a0cc9fdc71cc859d3bf606b576692" translate="yes" xml:space="preserve">
          <source>To drop the policy called &lt;code&gt;p1&lt;/code&gt; on the table named &lt;code&gt;my_table&lt;/code&gt;:</source>
          <target state="translated">在名为 &lt;code&gt;my_table&lt;/code&gt; 的表上删除名为 &lt;code&gt;p1&lt;/code&gt; 的策略：</target>
        </trans-unit>
        <trans-unit id="9a5bae2f9602e17d08d292952c8a5d8f7ac34691" translate="yes" xml:space="preserve">
          <source>To drop the rewrite rule &lt;code&gt;newrule&lt;/code&gt;:</source>
          <target state="translated">删除重写规则 &lt;code&gt;newrule&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="110d9c4f62582ddf4909360dee5c526218c434e0" translate="yes" xml:space="preserve">
          <source>To drop the routine &lt;code&gt;foo&lt;/code&gt; for type &lt;code&gt;integer&lt;/code&gt;:</source>
          <target state="translated">删除 &lt;code&gt;integer&lt;/code&gt; 类型的例程 &lt;code&gt;foo&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c536a04fe8d2446d8d61338be4ba1bab5c783796" translate="yes" xml:space="preserve">
          <source>To drop the transform for type &lt;code&gt;hstore&lt;/code&gt; and language &lt;code&gt;plpythonu&lt;/code&gt;:</source>
          <target state="translated">要删除的变换类型 &lt;code&gt;hstore&lt;/code&gt; 和语言 &lt;code&gt;plpythonu&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="5caa707f178a9cc755d7e779932a23df8fa2f1ca" translate="yes" xml:space="preserve">
          <source>To dump a database called &lt;code&gt;mydb&lt;/code&gt; into a SQL-script file:</source>
          <target state="translated">要将名为 &lt;code&gt;mydb&lt;/code&gt; 的数据库转储到SQL脚本文件中：</target>
        </trans-unit>
        <trans-unit id="8121f62b8666545b2e2e99dedbccab51245f9807" translate="yes" xml:space="preserve">
          <source>To dump a database into a custom-format archive file:</source>
          <target state="translated">要将数据库转储到一个自定义格式的存档文件中。</target>
        </trans-unit>
        <trans-unit id="d437ca9f46ee2993ef3f0545d06bedd57d2c6b4f" translate="yes" xml:space="preserve">
          <source>To dump a database into a directory-format archive in parallel with 5 worker jobs:</source>
          <target state="translated">将数据库转储到一个目录格式的存档中,同时有5个工作任务。</target>
        </trans-unit>
        <trans-unit id="31fa398ad5cf2d5e038474c944b981aa565b1e44" translate="yes" xml:space="preserve">
          <source>To dump a database into a directory-format archive:</source>
          <target state="translated">要将数据库转储到一个目录格式的档案中。</target>
        </trans-unit>
        <trans-unit id="ad76ea44a0ef53ad9ef9efb8caa4b902f280c164" translate="yes" xml:space="preserve">
          <source>To dump a single table named &lt;code&gt;mytab&lt;/code&gt;:</source>
          <target state="translated">要转储名为 &lt;code&gt;mytab&lt;/code&gt; 的单个表：</target>
        </trans-unit>
        <trans-unit id="8d511ed087693f26bd4759bf8b1d27193b49e5e6" translate="yes" xml:space="preserve">
          <source>To dump all database objects except for tables whose names begin with &lt;code&gt;ts_&lt;/code&gt;:</source>
          <target state="translated">要转储除名称以 &lt;code&gt;ts_&lt;/code&gt; 开头的表以外的所有数据库对象：</target>
        </trans-unit>
        <trans-unit id="5105a7d069d122946e3111a4bbe722d0a3cd0a79" translate="yes" xml:space="preserve">
          <source>To dump all databases:</source>
          <target state="translated">要转储所有数据库。</target>
        </trans-unit>
        <trans-unit id="999dcebdfcf4047b6459cc6ecf19931338457350" translate="yes" xml:space="preserve">
          <source>To dump all schemas whose names start with &lt;code&gt;east&lt;/code&gt; or &lt;code&gt;west&lt;/code&gt; and end in &lt;code&gt;gsm&lt;/code&gt;, excluding any schemas whose names contain the word &lt;code&gt;test&lt;/code&gt;:</source>
          <target state="translated">转储所有名称以 &lt;code&gt;east&lt;/code&gt; 或 &lt;code&gt;west&lt;/code&gt; 开头并以 &lt;code&gt;gsm&lt;/code&gt; 结尾的模式，不包括名称包含单词 &lt;code&gt;test&lt;/code&gt; 的所有模式：</target>
        </trans-unit>
        <trans-unit id="5301289a56ba7d9472a3d1bd5a043059fbfce396" translate="yes" xml:space="preserve">
          <source>To dump all tables whose names start with &lt;code&gt;emp&lt;/code&gt; in the &lt;code&gt;detroit&lt;/code&gt; schema, except for the table named &lt;code&gt;employee_log&lt;/code&gt;:</source>
          <target state="translated">要在 &lt;code&gt;detroit&lt;/code&gt; 模式中转储名称以 &lt;code&gt;emp&lt;/code&gt; 开头的所有表，除了名为 &lt;code&gt;employee_log&lt;/code&gt; 的表外：</target>
        </trans-unit>
        <trans-unit id="6f5c9b25307e1ce17bf381cf6cff0bda0e9cf7e6" translate="yes" xml:space="preserve">
          <source>To ease transition from the &lt;code&gt;md5&lt;/code&gt; method to the newer SCRAM method, if &lt;code&gt;md5&lt;/code&gt; is specified as a method in &lt;code&gt;pg_hba.conf&lt;/code&gt; but the user's password on the server is encrypted for SCRAM (see below), then SCRAM-based authentication will automatically be chosen instead.</source>
          <target state="translated">为了便于从 &lt;code&gt;md5&lt;/code&gt; 方法过渡到较新的SCRAM方法，如果在 &lt;code&gt;pg_hba.conf&lt;/code&gt; 中将 &lt;code&gt;md5&lt;/code&gt; 指定为方法，但是服务器上的用户密码已为SCRAM加密（请参见下文），则将自动选择基于SCRAM的身份验证。</target>
        </trans-unit>
        <trans-unit id="88489631fd89d19542342fc6ed140890035ad782" translate="yes" xml:space="preserve">
          <source>To enable WAL archiving, set the &lt;a href=&quot;runtime-config-wal#GUC-WAL-LEVEL&quot;&gt;wal_level&lt;/a&gt; configuration parameter to &lt;code&gt;replica&lt;/code&gt; or higher, &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-MODE&quot;&gt;archive_mode&lt;/a&gt; to &lt;code&gt;on&lt;/code&gt;, and specify the shell command to use in the &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt; configuration parameter. In practice these settings will always be placed in the &lt;code&gt;postgresql.conf&lt;/code&gt; file. In &lt;code&gt;archive_command&lt;/code&gt;, &lt;code&gt;%p&lt;/code&gt; is replaced by the path name of the file to archive, while &lt;code&gt;%f&lt;/code&gt; is replaced by only the file name. (The path name is relative to the current working directory, i.e., the cluster's data directory.) Use &lt;code&gt;%%&lt;/code&gt; if you need to embed an actual &lt;code&gt;%&lt;/code&gt; character in the command. The simplest useful command is something like:</source>
          <target state="translated">要启用WAL归档，请将&lt;a href=&quot;runtime-config-wal#GUC-WAL-LEVEL&quot;&gt;wal_level&lt;/a&gt;配置参数设置为 &lt;code&gt;replica&lt;/code&gt; 或更高版本，将&lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-MODE&quot;&gt;archive_mode设置&lt;/a&gt;为 &lt;code&gt;on&lt;/code&gt; ，并在&lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt;配置参数中指定要使用的shell命令。实际上，这些设置将始终放置在 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件中。在 &lt;code&gt;archive_command&lt;/code&gt; 中， &lt;code&gt;%p&lt;/code&gt; 由要归档的文件的路径名替换，而 &lt;code&gt;%f&lt;/code&gt; 仅由文件名替换。（路径名是相对于当前工作目录（即群集的数据目录）的。）如果需要嵌入实际的 &lt;code&gt;%&lt;/code&gt; ,请使用 &lt;code&gt;%%&lt;/code&gt; 。命令中的字符。最简单的有用命令是：</target>
        </trans-unit>
        <trans-unit id="163a2853661a9a827e1b4d5f0ebf9245d216aeaf" translate="yes" xml:space="preserve">
          <source>To enable automatic character set conversion, you have to tell PostgreSQL the character set (encoding) you would like to use in the client. There are several ways to accomplish this:</source>
          <target state="translated">要启用自动字符集转换,你必须告诉PostgreSQL你想在客户端使用的字符集(编码)。有几种方法可以完成这个任务。</target>
        </trans-unit>
        <trans-unit id="61f220328ec4a4eaf272f16874cf3e03c4c355b3" translate="yes" xml:space="preserve">
          <source>To enable event logging in the database server, modify &lt;a href=&quot;runtime-config-logging#GUC-LOG-DESTINATION&quot;&gt;log_destination&lt;/a&gt; to include &lt;code&gt;eventlog&lt;/code&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="translated">要在数据库服务器中启用事件日志记录，请修改&lt;a href=&quot;runtime-config-logging#GUC-LOG-DESTINATION&quot;&gt;log_destination&lt;/a&gt;以将 &lt;code&gt;eventlog&lt;/code&gt; 包含在 &lt;code&gt;postgresql.conf&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="a794df8102be7ea9270fd8cde81341bb2ca2e8b9" translate="yes" xml:space="preserve">
          <source>To enable messages to be translated to the user's preferred language, NLS must have been selected at build time (&lt;code&gt;configure --enable-nls&lt;/code&gt;). All other locale support is built in automatically.</source>
          <target state="translated">为了使消息能够翻译成用户的首选语言，必须在构建时选择NLS（ &lt;code&gt;configure --enable-nls&lt;/code&gt; ）。所有其他语言环境支持是自动内置的。</target>
        </trans-unit>
        <trans-unit id="33769b6666be88b23bc239c6978f70ef47bd7c0c" translate="yes" xml:space="preserve">
          <source>To enable this module, add &lt;code&gt;'$libdir/passwordcheck'&lt;/code&gt; to &lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;, then restart the server.</source>
          <target state="translated">要启用此模块，请将 &lt;code&gt;'$libdir/passwordcheck'&lt;/code&gt; 添加到 &lt;code&gt;postgresql.conf&lt;/code&gt; 中的&lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt;中，然后重新启动服务器。</target>
        </trans-unit>
        <trans-unit id="49d847ac2d6554d00f1cf26dcadd69be9408d2b9" translate="yes" xml:space="preserve">
          <source>To ensure the integrity of the entire database structure, PostgreSQL makes sure that you cannot drop objects that other objects still depend on. For example, attempting to drop the products table we considered in &lt;a href=&quot;ddl-constraints#DDL-CONSTRAINTS-FK&quot;&gt;Section 5.4.5&lt;/a&gt;, with the orders table depending on it, would result in an error message like this:</source>
          <target state="translated">为了确保整个数据库结构的完整性，PostgreSQL确保您不能删除其他对象仍然依赖的对象。例如，尝试删除&lt;a href=&quot;ddl-constraints#DDL-CONSTRAINTS-FK&quot;&gt;第5.4.5节中&lt;/a&gt;考虑的产品表（取决于订单表），将导致如下错误消息：</target>
        </trans-unit>
        <trans-unit id="4eb94062de7d5c68db4eebe8d5792a4bae6fa4de" translate="yes" xml:space="preserve">
          <source>To establish a savepoint and later undo the effects of all commands executed after it was established:</source>
          <target state="translated">建立一个保存点,并在建立后撤销所有命令的效果。</target>
        </trans-unit>
        <trans-unit id="cc6a8d9f6b4e580d2ee11faae1f76e83795f9119" translate="yes" xml:space="preserve">
          <source>To establish and later destroy a savepoint:</source>
          <target state="translated">建立并随后销毁一个保存点。</target>
        </trans-unit>
        <trans-unit id="4d022cb095a28d12057cc4d30c9ed630d8c4a81c" translate="yes" xml:space="preserve">
          <source>To examine a list of the currently outstanding locks in a database server, use the &lt;a href=&quot;view-pg-locks&quot;&gt;&lt;code&gt;pg_locks&lt;/code&gt;&lt;/a&gt; system view. For more information on monitoring the status of the lock manager subsystem, refer to &lt;a href=&quot;https://www.postgresql.org/docs/12/monitoring.html&quot;&gt;Chapter 27&lt;/a&gt;.</source>
          <target state="translated">要检查数据库服务器中当前未完成的锁的列表，请使用&lt;a href=&quot;view-pg-locks&quot;&gt; &lt;code&gt;pg_locks&lt;/code&gt; &lt;/a&gt;系统视图。有关监视锁管理器子系统状态的更多信息，请参阅&lt;a href=&quot;https://www.postgresql.org/docs/12/monitoring.html&quot;&gt;第27章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4fad6ad49ad4e437a0cb62af93e6ae25b097ac33" translate="yes" xml:space="preserve">
          <source>To examine a list of the currently outstanding locks in a database server, use the &lt;a href=&quot;view-pg-locks&quot;&gt;&lt;code&gt;pg_locks&lt;/code&gt;&lt;/a&gt; system view. For more information on monitoring the status of the lock manager subsystem, refer to &lt;a href=&quot;https://www.postgresql.org/docs/13/monitoring.html&quot;&gt;Chapter 27&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee179a7e650337f5be46128f8c744f60566325a2" translate="yes" xml:space="preserve">
          <source>To examine the query plan PostgreSQL is using for a prepared statement, use &lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt;, for example</source>
          <target state="translated">要检查PostgreSQL用于准备语句的查询计划，请使用&lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt;，例如</target>
        </trans-unit>
        <trans-unit id="9ab98980692e8ae3b65879ae33d5792b980cffc7" translate="yes" xml:space="preserve">
          <source>To exclude data for all tables in the database, see &lt;code&gt;--schema-only&lt;/code&gt;.</source>
          <target state="translated">要排除数据库中所有表的数据，请参见 &lt;code&gt;--schema-only&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd00aea3b9256ff7a4422dd7af6985b4801677da" translate="yes" xml:space="preserve">
          <source>To exclude table data for only a subset of tables in the database, see &lt;code&gt;--exclude-table-data&lt;/code&gt;.</source>
          <target state="translated">要仅排除数据库中一部分表的表数据，请参见 &lt;code&gt;--exclude-table-data&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6162526b00490b1f2f1658b53775455d6ca15472" translate="yes" xml:space="preserve">
          <source>To export a public key in ASCII-armor format:</source>
          <target state="translated">导出ASCII-armor格式的公钥。</target>
        </trans-unit>
        <trans-unit id="a23b559273ee4d257c470044a91813e890937385" translate="yes" xml:space="preserve">
          <source>To export a secret key in ASCII-armor format:</source>
          <target state="translated">导出ASCII-armor格式的密匙。</target>
        </trans-unit>
        <trans-unit id="86f886ace5f866856fb04921712ddce243cc4f95" translate="yes" xml:space="preserve">
          <source>To facilitate controlled execution of such queries, GIN has a configurable soft upper limit on the number of rows returned: the &lt;code&gt;gin_fuzzy_search_limit&lt;/code&gt; configuration parameter. It is set to 0 (meaning no limit) by default. If a non-zero limit is set, then the returned set is a subset of the whole result set, chosen at random.</source>
          <target state="translated">为了促进此类查询的受控执行，GIN对于返回的行数具有可配置的软上限： &lt;code&gt;gin_fuzzy_search_limit&lt;/code&gt; 配置参数。默认情况下，它设置为0（表示无限制）。如果设置了非零限制，则返回的集是整个结果集的子集，是随机选择的。</target>
        </trans-unit>
        <trans-unit id="fabf2744d8a8f45bc9091582373665b13db0b3ab" translate="yes" xml:space="preserve">
          <source>To find an available OID for a new pre-loaded row, run the script &lt;code&gt;src/include/catalog/unused_oids&lt;/code&gt;. It prints inclusive ranges of unused OIDs (e.g., the output line &amp;ldquo;45-900&amp;rdquo; means OIDs 45 through 900 have not been allocated yet). Currently, OIDs 1-9999 are reserved for manual assignment; the &lt;code&gt;unused_oids&lt;/code&gt; script simply looks through the catalog headers and &lt;code&gt;.dat&lt;/code&gt; files to see which ones do not appear. You can also use the &lt;code&gt;duplicate_oids&lt;/code&gt; script to check for mistakes. (&lt;code&gt;genbki.pl&lt;/code&gt; will assign OIDs for any rows that didn't get one hand-assigned to them, and it will also detect duplicate OIDs at compile time.)</source>
          <target state="translated">要为新的预加载行找到可用的OID，请运行脚本 &lt;code&gt;src/include/catalog/unused_oids&lt;/code&gt; 。它打印未使用的OID的范围（例如，输出行&amp;ldquo; 45-900&amp;rdquo;表示尚未分配OID 45至900）。当前，OID 1-9999保留用于手动分配。该 &lt;code&gt;unused_oids&lt;/code&gt; 脚本只是看起来通过目录标题和 &lt;code&gt;.dat&lt;/code&gt; 文件，看看哪些不会出现的。您也可以使用 &lt;code&gt;duplicate_oids&lt;/code&gt; 脚本检查错误。 （ &lt;code&gt;genbki.pl&lt;/code&gt; 将为没有手动分配给它们的任何行分配OID，并且还将在编译时检测到重复的OID。）</target>
        </trans-unit>
        <trans-unit id="83324513227c6e220838375b162eb3efe60ff368" translate="yes" xml:space="preserve">
          <source>To find an available OID for a new pre-loaded row, run the script &lt;code&gt;src/include/catalog/unused_oids&lt;/code&gt;. It prints inclusive ranges of unused OIDs (e.g., the output line &lt;code&gt;45-900&lt;/code&gt; means OIDs 45 through 900 have not been allocated yet). Currently, OIDs 1&amp;ndash;9999 are reserved for manual assignment; the &lt;code&gt;unused_oids&lt;/code&gt; script simply looks through the catalog headers and &lt;code&gt;.dat&lt;/code&gt; files to see which ones do not appear. You can also use the &lt;code&gt;duplicate_oids&lt;/code&gt; script to check for mistakes. (&lt;code&gt;genbki.pl&lt;/code&gt; will assign OIDs for any rows that didn't get one hand-assigned to them, and it will also detect duplicate OIDs at compile time.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7b4d89e57b00cb717b3a45dca9a44135790f4f2" translate="yes" xml:space="preserve">
          <source>To force immediate reclamation of space occupied by a dropped column, you can execute one of the forms of &lt;code&gt;ALTER TABLE&lt;/code&gt; that performs a rewrite of the whole table. This results in reconstructing each row with the dropped column replaced by a null value.</source>
          <target state="translated">要强制立即回收被删除的列占用的空间，您可以执行 &lt;code&gt;ALTER TABLE&lt;/code&gt; 的一种形式来重写整个表。这将导致重建的每一行都将被删除的列替换为空值。</target>
        </trans-unit>
        <trans-unit id="e539dee4c479de5ce6227904539c51905413b8a2" translate="yes" xml:space="preserve">
          <source>To force the planner to follow the join order laid out by explicit &lt;code&gt;JOIN&lt;/code&gt;s, set the &lt;a href=&quot;runtime-config-query#GUC-JOIN-COLLAPSE-LIMIT&quot;&gt;join_collapse_limit&lt;/a&gt; run-time parameter to 1. (Other possible values are discussed below.)</source>
          <target state="translated">要强制计划者遵循显式 &lt;code&gt;JOIN&lt;/code&gt; 所列出的联接顺序，请将&lt;a href=&quot;runtime-config-query#GUC-JOIN-COLLAPSE-LIMIT&quot;&gt;join_collapse_limit&lt;/a&gt;运行时参数设置为1。（其他可能的值将在下面讨论。）</target>
        </trans-unit>
        <trans-unit id="8b97e829e4f12bf390f60edd12090a6e21acdc24" translate="yes" xml:space="preserve">
          <source>To generate a new key:</source>
          <target state="translated">要生成一个新的密钥。</target>
        </trans-unit>
        <trans-unit id="e2c066b392d0690f674361c2e00b7a60bde09ccb" translate="yes" xml:space="preserve">
          <source>To get &lt;code&gt;doc_num&lt;/code&gt; on every line, the solution is to use two invocations of &lt;code&gt;xpath_table&lt;/code&gt; and join the results:</source>
          <target state="translated">要在每一行上获取 &lt;code&gt;doc_num&lt;/code&gt; ，解决方案是使用 &lt;code&gt;xpath_table&lt;/code&gt; 的两次调用并结合结果：</target>
        </trans-unit>
        <trans-unit id="69c96837968de4279f15cf969e5e70dc5b6c75e5" translate="yes" xml:space="preserve">
          <source>To get out of &lt;code&gt;psql&lt;/code&gt;, type:</source>
          <target state="translated">要退出 &lt;code&gt;psql&lt;/code&gt; ，请输入：</target>
        </trans-unit>
        <trans-unit id="f841c80668fce3c31645a5d7959f701a568c379f" translate="yes" xml:space="preserve">
          <source>To get the start time of segments with such values instead, you have to filter out irrelevant segments before returning the start time, so the filter expression is applied to the previous step, and the path used in the condition is different:</source>
          <target state="translated">如果要用这样的值来代替获取段的起始时间,就必须在返回起始时间前过滤掉不相关的段,所以过滤表达式应用于上一步,条件中使用的路径也不同。</target>
        </trans-unit>
        <trans-unit id="a23cfe85547c2cef9463af3fca5fe0719f145cc1" translate="yes" xml:space="preserve">
          <source>To get the start times of segments with such values, you have to filter out irrelevant segments before returning the start times, so the filter expression is applied to the previous step, and the path used in the condition is different:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c348e1fb7d6b60d5bb3b8782cdcf8ec28351c7b2" translate="yes" xml:space="preserve">
          <source>To give a schema-qualified operator name in &lt;code&gt;com_op&lt;/code&gt; or the other optional arguments, use the &lt;code&gt;OPERATOR()&lt;/code&gt; syntax, for example:</source>
          <target state="translated">要在 &lt;code&gt;com_op&lt;/code&gt; 或其他可选参数中提供模式限定的运算符名称，请使用 &lt;code&gt;OPERATOR()&lt;/code&gt; 语法，例如：</target>
        </trans-unit>
        <trans-unit id="181dc64889b2ae0155da88752e6851b32114a550" translate="yes" xml:space="preserve">
          <source>To guarantee true serializability PostgreSQL uses &lt;em&gt;predicate locking&lt;/em&gt;, which means that it keeps locks which allow it to determine when a write would have had an impact on the result of a previous read from a concurrent transaction, had it run first. In PostgreSQL these locks do not cause any blocking and therefore can &lt;em&gt;not&lt;/em&gt; play any part in causing a deadlock. They are used to identify and flag dependencies among concurrent Serializable transactions which in certain combinations can lead to serialization anomalies. In contrast, a Read Committed or Repeatable Read transaction which wants to ensure data consistency may need to take out a lock on an entire table, which could block other users attempting to use that table, or it may use &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; or &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; which not only can block other transactions but cause disk access.</source>
          <target state="translated">为了保证真正的可序列化性，PostgreSQL使用&lt;em&gt;谓词锁定&lt;/em&gt;，这意味着它保持锁定，从而使它可以确定一次写入是否会对先后从并发事务中读取的结果产生影响（如果先执行）。在PostgreSQL中，这些锁不会引起任何阻塞，因此&lt;em&gt;不能&lt;/em&gt;在导致死锁方面发挥任何作用。它们用于识别并标记并发可序列化事务之间的依赖性，这在某些组合中可能导致序列化异常。相反，想要确保数据一致性的Read Committed或Repeatable Read事务可能需要对整个表进行锁定，这可能会阻止其他试图使用该表的用户，或者可能使用 &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 或 &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; 不仅会阻止其他事务，还会导致磁盘访问。</target>
        </trans-unit>
        <trans-unit id="f68a15ec78f387befd6d0298f8810f1045e197b1" translate="yes" xml:space="preserve">
          <source>To illustrate the difference, if &lt;code&gt;x&lt;/code&gt; is an XML value, these two queries in an SQL:2006 environment would produce true and false, respectively:</source>
          <target state="translated">为了说明差异，如果 &lt;code&gt;x&lt;/code&gt; 是XML值，则在SQL：2006环境中的这两个查询将分别产生true和false：</target>
        </trans-unit>
        <trans-unit id="33e38f50067618192123a7a6ea2a2035a90e4fb0" translate="yes" xml:space="preserve">
          <source>To illustrate the use of array types, we create this table:</source>
          <target state="translated">为了说明数组类型的使用,我们创建这个表。</target>
        </trans-unit>
        <trans-unit id="7b5b94d4b187e4064dd8c2d93482d78bbe19ae50" translate="yes" xml:space="preserve">
          <source>To illustrate this, let's implement the following policy on the many-to-many relationship example above: when someone wants to remove a product that is still referenced by an order (via &lt;code&gt;order_items&lt;/code&gt;), we disallow it. If someone removes an order, the order items are removed as well:</source>
          <target state="translated">为了说明这一点，让我们在上面的多对多关系示例上实施以下策略：当某人想要删除仍由订单引用的产品时（通过 &lt;code&gt;order_items&lt;/code&gt; ），我们将其禁止。如果有人删除了订单，则订单项也将被删除：</target>
        </trans-unit>
        <trans-unit id="7f35959c3ce0c736cba407ce1950e3b7f93b092e" translate="yes" xml:space="preserve">
          <source>To implement an access method, an implementor will typically need to implement an AM-specific type of tuple table slot (see &lt;a href=&quot;https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=src/include/executor/tuptable.h;hb=HEAD&quot;&gt;&lt;code&gt;src/include/executor/tuptable.h&lt;/code&gt;&lt;/a&gt;), which allows code outside the access method to hold references to tuples of the AM, and to access the columns of the tuple.</source>
          <target state="translated">要实现访问方法，实现者通常将需要实现AM特定类型的元组表插槽（请参阅&lt;a href=&quot;https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=src/include/executor/tuptable.h;hb=HEAD&quot;&gt; &lt;code&gt;src/include/executor/tuptable.h&lt;/code&gt; &lt;/a&gt;），这允许访问方法外的代码保存对AM元组的引用。 ，并访问元组的列。</target>
        </trans-unit>
        <trans-unit id="ea65817bb743af7def6e62b531aec8b8c7c1a366" translate="yes" xml:space="preserve">
          <source>To implement full text searching there must be a function to create a &lt;code&gt;tsvector&lt;/code&gt; from a document and a &lt;code&gt;tsquery&lt;/code&gt; from a user query. Also, we need to return results in a useful order, so we need a function that compares documents with respect to their relevance to the query. It's also important to be able to display the results nicely. PostgreSQL provides support for all of these functions.</source>
          <target state="translated">要实现全文搜索，必须有一个从文档创建 &lt;code&gt;tsvector&lt;/code&gt; 和从用户查询创建 &lt;code&gt;tsquery&lt;/code&gt; 的功能。同样，我们需要以有用的顺序返回结果，因此我们需要一个函数来比较文档与查询的相关性。能够很好地显示结果也很重要。PostgreSQL支持所有这些功能。</target>
        </trans-unit>
        <trans-unit id="f90b4fcb28ef9c823a8d7810618ebba2004bd7be" translate="yes" xml:space="preserve">
          <source>To implement sub-partitioning, specify the &lt;code&gt;PARTITION BY&lt;/code&gt; clause in the commands used to create individual partitions, for example:</source>
          <target state="translated">要实现子分区，请在用于创建单个分区的命令中指定 &lt;code&gt;PARTITION BY&lt;/code&gt; 子句，例如：</target>
        </trans-unit>
        <trans-unit id="846839113d5d394eb45527ccc7c7a96f15b009ec" translate="yes" xml:space="preserve">
          <source>To implement transactional support in a manner that allows different table access methods be accessed within a single transaction, it likely is necessary to closely integrate with the machinery in &lt;code&gt;src/backend/access/transam/xlog.c&lt;/code&gt;.</source>
          <target state="translated">为了以允许在单个事务中访问不同表访问方法的方式实现事务支持，可能有必要与 &lt;code&gt;src/backend/access/transam/xlog.c&lt;/code&gt; 中的机制紧密集成。</target>
        </trans-unit>
        <trans-unit id="a0b8cb073edc0febf35e9cd737b45bb493e96aed" translate="yes" xml:space="preserve">
          <source>To import a log file into this table, use the &lt;code&gt;COPY FROM&lt;/code&gt; command:</source>
          <target state="translated">要将日志文件导入此表，请使用 &lt;code&gt;COPY FROM&lt;/code&gt; 命令：</target>
        </trans-unit>
        <trans-unit id="28e732fd3da22b22756fa7755e21953801d94a6c" translate="yes" xml:space="preserve">
          <source>To improve such estimates, &lt;code&gt;ANALYZE&lt;/code&gt; can collect MCV lists on combinations of columns. Similarly to functional dependencies and n-distinct coefficients, it's impractical to do this for every possible column grouping. Even more so in this case, as the MCV list (unlike functional dependencies and n-distinct coefficients) does store the common column values. So data is collected only for those groups of columns appearing together in a statistics object defined with the &lt;code&gt;mcv&lt;/code&gt; option.</source>
          <target state="translated">为了改善这种估计， &lt;code&gt;ANALYZE&lt;/code&gt; 可以收集列组合上的MCV列表。与功能依赖项和n系数不同，对每种可能的列分组执行此操作都是不切实际的。在这种情况下更是如此，因为MCV列表（与功能依赖性和n系数不同）确实存储了公共列值。因此，仅针对在使用 &lt;code&gt;mcv&lt;/code&gt; 选项定义的统计信息对象中同时出现的那些列组收集数据。</target>
        </trans-unit>
        <trans-unit id="726a8877a697c9a76f8ec5b5c68e9adbda1257f4" translate="yes" xml:space="preserve">
          <source>To improve such estimates, &lt;code&gt;ANALYZE&lt;/code&gt; can collect n-distinct statistics for groups of columns. As before, it's impractical to do this for every possible column grouping, so data is collected only for those groups of columns appearing together in a statistics object defined with the &lt;code&gt;ndistinct&lt;/code&gt; option. Data will be collected for each possible combination of two or more columns from the set of listed columns.</source>
          <target state="translated">为了改善这种估计， &lt;code&gt;ANALYZE&lt;/code&gt; 可以收集列组的n个不同的统计信息。和以前一样，对每个可能的列分组都执行此操作是不切实际的，因此仅收集在使用 &lt;code&gt;ndistinct&lt;/code&gt; 选项定义的统计对象中一起出现的那些列组的数据。将从列出的列集中为两个或更多列的每种可能组合收集数据。</target>
        </trans-unit>
        <trans-unit id="6fc7cc9bd907a538cf92f4185feaaa71d0884dc6" translate="yes" xml:space="preserve">
          <source>To include a literal &lt;code&gt;]&lt;/code&gt; in the list, make it the first character (after &lt;code&gt;^&lt;/code&gt;, if that is used). To include a literal &lt;code&gt;-&lt;/code&gt;, make it the first or last character, or the second endpoint of a range. To use a literal &lt;code&gt;-&lt;/code&gt; as the first endpoint of a range, enclose it in &lt;code&gt;[.&lt;/code&gt; and &lt;code&gt;.]&lt;/code&gt; to make it a collating element (see below). With the exception of these characters, some combinations using &lt;code&gt;[&lt;/code&gt; (see next paragraphs), and escapes (AREs only), all other special characters lose their special significance within a bracket expression. In particular, &lt;code&gt;\&lt;/code&gt; is not special when following ERE or BRE rules, though it is special (as introducing an escape) in AREs.</source>
          <target state="translated">要在列表中包含文字 &lt;code&gt;]&lt;/code&gt; ，请使其成为第一个字符（如果使用 &lt;code&gt;^&lt;/code&gt; ，则在其后）。要包含文字 &lt;code&gt;-&lt;/code&gt; ，使其成为范围的第一个或最后一个字符，或第二个端点。要使用文字 &lt;code&gt;-&lt;/code&gt; 作为范围的第一个端点，请将其括在 &lt;code&gt;[.&lt;/code&gt; 和 &lt;code&gt;.]&lt;/code&gt; 作为整理元素（请参见下文）。除了这些字符，使用 &lt;code&gt;[&lt;/code&gt; 的某些组合（请参阅下面的段落）和转义符（仅用于ARE）之外，所有其他特殊字符在方括号表达式中都失去其特殊意义。特别地， &lt;code&gt;\&lt;/code&gt; 在遵循ERE或BRE规则时不是特殊的，尽管它在ARE中是特殊的（引入了转义）。</target>
        </trans-unit>
        <trans-unit id="4184bf034050051b34f3bc62384d8d2db0c8c933" translate="yes" xml:space="preserve">
          <source>To include the escape character in the identifier literally, write it twice.</source>
          <target state="translated">要在标识符中加入转义字符,写两次。</target>
        </trans-unit>
        <trans-unit id="e84215b046c65219d5ce30b242beef53ee6e7a36" translate="yes" xml:space="preserve">
          <source>To include the escape character in the string literally, write it twice.</source>
          <target state="translated">要将转义字符按字面意思写在字符串中,请写两次。</target>
        </trans-unit>
        <trans-unit id="78f88921a54fbd43b8bb79b923defafecfc3cd3f" translate="yes" xml:space="preserve">
          <source>To include whitespace in an argument you can quote it with single quotes. To include a single quote in an argument, write two single quotes within single-quoted text. Anything contained in single quotes is furthermore subject to C-like substitutions for &lt;code&gt;\n&lt;/code&gt; (new line), &lt;code&gt;\t&lt;/code&gt; (tab), &lt;code&gt;\b&lt;/code&gt; (backspace), &lt;code&gt;\r&lt;/code&gt; (carriage return), &lt;code&gt;\f&lt;/code&gt; (form feed), &lt;code&gt;\&lt;/code&gt;&lt;code&gt;digits&lt;/code&gt; (octal), and &lt;code&gt;\x&lt;/code&gt;&lt;code&gt;digits&lt;/code&gt; (hexadecimal). A backslash preceding any other character within single-quoted text quotes that single character, whatever it is.</source>
          <target state="translated">要在参数中包含空格，可以用单引号将其引起来。要在参数中包含单引号，请在单引号引起来的文本中写两个单引号。此外，单引号中包含的所有内容都可以通过 &lt;code&gt;\n&lt;/code&gt; （换行）， &lt;code&gt;\t&lt;/code&gt; （制表符）， &lt;code&gt;\b&lt;/code&gt; （退格键）， &lt;code&gt;\r&lt;/code&gt; （回车符）， &lt;code&gt;\f&lt;/code&gt; （换页符）， &lt;code&gt;\&lt;/code&gt; &lt;code&gt;digits&lt;/code&gt; （八进制）和 &lt;code&gt;\x&lt;/code&gt; &lt;code&gt;digits&lt;/code&gt; （十六进制）。单引号文本中任何其他字符前面的反斜杠都会引用该单个字符，无论它是什么。</target>
        </trans-unit>
        <trans-unit id="1f2cb44f0c5a3aa8e112ae7be973fd139113c473" translate="yes" xml:space="preserve">
          <source>To index the original phrase as well as the substitute, just include it in the right-hand part of the definition:</source>
          <target state="translated">要为原词组和替代词编制索引,只需将其包含在定义的右侧部分。</target>
        </trans-unit>
        <trans-unit id="95ef2591a1c7f1278d7f81a1fe53a76759cd33d8" translate="yes" xml:space="preserve">
          <source>To indicate that a type is an array, specify the type of the array elements using the &lt;code&gt;ELEMENT&lt;/code&gt; key word. For example, to define an array of 4-byte integers (&lt;code&gt;int4&lt;/code&gt;), specify &lt;code&gt;ELEMENT = int4&lt;/code&gt;. More details about array types appear below.</source>
          <target state="translated">要指示类型是数组，请使用 &lt;code&gt;ELEMENT&lt;/code&gt; 关键字指定数组元素的类型。例如，要定义一个4字节整数（ &lt;code&gt;int4&lt;/code&gt; ）的数组，请指定 &lt;code&gt;ELEMENT = int4&lt;/code&gt; 。有关数组类型的更多详细信息显示在下面。</target>
        </trans-unit>
        <trans-unit id="dfac2991049d03ecd33ce1361a3f4d83513beefd" translate="yes" xml:space="preserve">
          <source>To indicate the delimiter to be used between values in the external representation of arrays of this type, &lt;code&gt;delimiter&lt;/code&gt; can be set to a specific character. The default delimiter is the comma (&lt;code&gt;,&lt;/code&gt;). Note that the delimiter is associated with the array element type, not the array type itself.</source>
          <target state="translated">为了指示在此类型的数组的外部表示形式中的值之间使用 &lt;code&gt;delimiter&lt;/code&gt; 可以将定界符设置为特定字符。默认的定界符是逗号（ &lt;code&gt;,&lt;/code&gt; ）。请注意，分隔符与数组元素类型相关联，而不与数组类型本身相关联。</target>
        </trans-unit>
        <trans-unit id="f9cbc2cc662f87e5cddcf234e0f6469fdfb69842" translate="yes" xml:space="preserve">
          <source>To inform the planner about functional dependencies, &lt;code&gt;ANALYZE&lt;/code&gt; can collect measurements of cross-column dependency. Assessing the degree of dependency between all sets of columns would be prohibitively expensive, so data collection is limited to those groups of columns appearing together in a statistics object defined with the &lt;code&gt;dependencies&lt;/code&gt; option. It is advisable to create &lt;code&gt;dependencies&lt;/code&gt; statistics only for column groups that are strongly correlated, to avoid unnecessary overhead in both &lt;code&gt;ANALYZE&lt;/code&gt; and later query planning.</source>
          <target state="translated">为了通知计划者有关功能的依赖性， &lt;code&gt;ANALYZE&lt;/code&gt; 可以收集跨列依赖性的度量。评估所有列集之间的依赖程度将是非常昂贵的，因此数据收集仅限于在 &lt;code&gt;dependencies&lt;/code&gt; 项选项定义的统计对象中一起出现的那些列组。建议仅为高度相关的列组创建 &lt;code&gt;dependencies&lt;/code&gt; 统计信息，以避免在 &lt;code&gt;ANALYZE&lt;/code&gt; 和以后的查询计划中产生不必要的开销。</target>
        </trans-unit>
        <trans-unit id="5d0fceb23b95d26529865353175f08c16f67334c" translate="yes" xml:space="preserve">
          <source>To initialize a database cluster manually, run &lt;code&gt;initdb&lt;/code&gt; and specify the desired file system location of the database cluster with the &lt;code&gt;-D&lt;/code&gt; option, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40cf525f7b3d73ebe89741dbac88fd30351f8be3" translate="yes" xml:space="preserve">
          <source>To insert a percent sign into your prompt, write &lt;code&gt;%%&lt;/code&gt;. The default prompts are &lt;code&gt;'%/%R%# '&lt;/code&gt; for prompts 1 and 2, and &lt;code&gt;'&amp;gt;&amp;gt; '&lt;/code&gt; for prompt 3.</source>
          <target state="translated">要将百分号插入提示符，请输入 &lt;code&gt;%%&lt;/code&gt; 。对于提示1和2，默认提示为 &lt;code&gt;'%/%R%# '&lt;/code&gt; 对于提示3，默认提示为' &lt;code&gt;'&amp;gt;&amp;gt; '&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6d883ec7d3bf5a2c0cbb45370c83314d637adfd" translate="yes" xml:space="preserve">
          <source>To insert a percent sign into your prompt, write &lt;code&gt;%%&lt;/code&gt;. The default prompts are &lt;code&gt;'%/%R%x%# '&lt;/code&gt; for prompts 1 and 2, and &lt;code&gt;'&amp;gt;&amp;gt; '&lt;/code&gt; for prompt 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1ee9bbe110857fcf2f7841b805a4e345fe77366" translate="yes" xml:space="preserve">
          <source>To insert a row consisting entirely of default values:</source>
          <target state="translated">插入完全由默认值组成的行。</target>
        </trans-unit>
        <trans-unit id="d5156cf333413525236a7d8f0063c5f452f5f26a" translate="yes" xml:space="preserve">
          <source>To insert multiple rows using the multirow &lt;code&gt;VALUES&lt;/code&gt; syntax:</source>
          <target state="translated">要使用多行 &lt;code&gt;VALUES&lt;/code&gt; 语法插入多行：</target>
        </trans-unit>
        <trans-unit id="74b9c8be569e80f1c859ef51f10adea40ff85de7" translate="yes" xml:space="preserve">
          <source>To insert the next value of the sequence into the &lt;code&gt;serial&lt;/code&gt; column, specify that the &lt;code&gt;serial&lt;/code&gt; column should be assigned its default value. This can be done either by excluding the column from the list of columns in the &lt;code&gt;INSERT&lt;/code&gt; statement, or through the use of the &lt;code&gt;DEFAULT&lt;/code&gt; key word.</source>
          <target state="translated">要将序列的下一个值插入 &lt;code&gt;serial&lt;/code&gt; 列，请指定应为 &lt;code&gt;serial&lt;/code&gt; 列分配其默认值。这可以通过从 &lt;code&gt;INSERT&lt;/code&gt; 语句的列列表中排除该列来完成，也可以通过使用 &lt;code&gt;DEFAULT&lt;/code&gt; 关键字来完成。</target>
        </trans-unit>
        <trans-unit id="9325a56bbba931c18bc288d06702b77030782fe9" translate="yes" xml:space="preserve">
          <source>To inspect the currently available locales, use the query &lt;code&gt;SELECT * FROM pg_collation&lt;/code&gt;, or the command &lt;code&gt;\dOS+&lt;/code&gt; in psql.</source>
          <target state="translated">要检查当前可用的语言环境，请使用查询 &lt;code&gt;SELECT * FROM pg_collation&lt;/code&gt; 或psql中的命令 &lt;code&gt;\dOS+&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="396cd46392c72184b16377243ca319a056a0005a" translate="yes" xml:space="preserve">
          <source>To intersperse text output in between query results, use &lt;code&gt;\qecho&lt;/code&gt;.</source>
          <target state="translated">要在查询结果之间 &lt;code&gt;\qecho&lt;/code&gt; 文本输出，请使用\ qecho。</target>
        </trans-unit>
        <trans-unit id="11793d6d388c3ed014d8177be32ebeaaabfb3f69" translate="yes" xml:space="preserve">
          <source>To join the table &lt;code&gt;films&lt;/code&gt; with the table &lt;code&gt;distributors&lt;/code&gt;:</source>
          <target state="translated">要与餐桌 &lt;code&gt;distributors&lt;/code&gt; 一起加入餐桌 &lt;code&gt;films&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="628b8c5cdb42f7dc53d8569d2746c631140dbcd9" translate="yes" xml:space="preserve">
          <source>To learn more about the SQL/JSON standard, see &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#SQLTR-19075-6&quot;&gt;[sqltr-19075-6]&lt;/a&gt;. For details on JSON types supported in PostgreSQL, see &lt;a href=&quot;datatype-json&quot;&gt;Section 8.14&lt;/a&gt;.</source>
          <target state="translated">要了解有关SQL / JSON标准的更多信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#SQLTR-19075-6&quot;&gt;[sqltr-19075-6]&lt;/a&gt;。有关PostgreSQL支持的JSON类型的详细信息，请参见&lt;a href=&quot;datatype-json&quot;&gt;第8.14节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fa2a7ac21257e516bad1e8308a714c724e5e994e" translate="yes" xml:space="preserve">
          <source>To learn more about the SQL/JSON standard, see &lt;a href=&quot;https://www.postgresql.org/docs/13/biblio.html#SQLTR-19075-6&quot;&gt;[sqltr-19075-6]&lt;/a&gt;. For details on JSON types supported in PostgreSQL, see &lt;a href=&quot;datatype-json&quot;&gt;Section 8.14&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="889344cf4fa47381ec5fba6605b2194e6f5635b8" translate="yes" xml:space="preserve">
          <source>To list keys:</source>
          <target state="translated">要列出钥匙。</target>
        </trans-unit>
        <trans-unit id="1746b8a797d81baecf4e64517cb9e2b4e171ea4d" translate="yes" xml:space="preserve">
          <source>To look up functions taking arguments or returning values of a specific data type, use your pager's search capability to scroll through the &lt;code&gt;\df&lt;/code&gt; output.</source>
          <target state="translated">要查找带有参数或返回特定数据类型值的函数，请使用您的寻呼机的搜索功能来滚动 &lt;code&gt;\df&lt;/code&gt; 输出。</target>
        </trans-unit>
        <trans-unit id="f63105a6bdca6f2a502122ad5fab70a09773a1ea" translate="yes" xml:space="preserve">
          <source>To make a registration:</source>
          <target state="translated">要进行注册。</target>
        </trans-unit>
        <trans-unit id="21a3f307d9fb66d4c9cdb328cd1d7f268094c295" translate="yes" xml:space="preserve">
          <source>To make effective use of the index-only scan feature, you might choose to create a &lt;em&gt;covering index&lt;/em&gt;, which is an index specifically designed to include the columns needed by a particular type of query that you run frequently. Since queries typically need to retrieve more columns than just the ones they search on, PostgreSQL allows you to create an index in which some columns are just &amp;ldquo;payload&amp;rdquo; and are not part of the search key. This is done by adding an &lt;code&gt;INCLUDE&lt;/code&gt; clause listing the extra columns. For example, if you commonly run queries like</source>
          <target state="translated">为了有效利用仅索引扫描功能，您可以选择创建&lt;em&gt;覆盖索引&lt;/em&gt;，该索引是专门设计为包括经常运行的特定查询类型所需的列的索引。由于查询通常需要检索的列多于查询的列，因此PostgreSQL允许您创建一个索引，其中某些列只是&amp;ldquo;有效载荷&amp;rdquo;而不是搜索键的一部分。这可以通过添加列出额外列的 &lt;code&gt;INCLUDE&lt;/code&gt; 子句来完成。例如，如果您通常运行类似</target>
        </trans-unit>
        <trans-unit id="5f2951feb65ad64d0c55b52fdde9cfe0496f2a09" translate="yes" xml:space="preserve">
          <source>To make it easier to build custom text search configurations, a configuration is built up from simpler database objects. PostgreSQL's text search facility provides four types of configuration-related database objects:</source>
          <target state="translated">为了更方便地建立自定义的文本搜索配置,配置是由较简单的数据库对象建立起来的。PostgreSQL的文本搜索设施提供了四种类型的配置相关数据库对象。</target>
        </trans-unit>
        <trans-unit id="32e1597b40ce1accf80ccac6a6e7b7c63bd5a013" translate="yes" xml:space="preserve">
          <source>To make it harder for people to break things, there is a limit of 100 on the number of dimensions of cubes. This is set in &lt;code&gt;cubedata.h&lt;/code&gt; if you need something bigger.</source>
          <target state="translated">为了使人们更难以打破事物，多维数据集的维数限制为100。如果需要更大的参数，可以在 &lt;code&gt;cubedata.h&lt;/code&gt; 中设置。</target>
        </trans-unit>
        <trans-unit id="76612115b359bc164a8d942bcbc6e3a7da781870" translate="yes" xml:space="preserve">
          <source>To make the backup, you can use the pg_dumpall command from the version you are currently running; see &lt;a href=&quot;backup-dump#BACKUP-DUMP-ALL&quot;&gt;Section 25.1.2&lt;/a&gt; for more details. For best results, however, try to use the pg_dumpall command from PostgreSQL 12.1, since this version contains bug fixes and improvements over older versions. While this advice might seem idiosyncratic since you haven't installed the new version yet, it is advisable to follow it if you plan to install the new version in parallel with the old version. In that case you can complete the installation normally and transfer the data later. This will also decrease the downtime.</source>
          <target state="translated">要进行备份，可以使用当前正在运行的版本中的pg_dumpall命令。有关更多详细信息，请参见&lt;a href=&quot;backup-dump#BACKUP-DUMP-ALL&quot;&gt;第25.1.2节&lt;/a&gt;。为了获得最佳结果，请尝试使用PostgreSQL 12.1中的pg_dumpall命令，因为此版本包含错误修复和对旧版本的改进。尽管由于尚未安装新版本，所以此建议似乎有些特殊，但是，如果您打算与旧版本并行安装新版本，建议您遵循该建议。在这种情况下，您可以正常完成安装并稍后传输数据。这也将减少停机时间。</target>
        </trans-unit>
        <trans-unit id="10dbb8485ad8b8028e702262aa6a7b5834c5457f" translate="yes" xml:space="preserve">
          <source>To make the backup, you can use the pg_dumpall command from the version you are currently running; see &lt;a href=&quot;backup-dump#BACKUP-DUMP-ALL&quot;&gt;Section 25.1.2&lt;/a&gt; for more details. For best results, however, try to use the pg_dumpall command from PostgreSQL 13.1, since this version contains bug fixes and improvements over older versions. While this advice might seem idiosyncratic since you haven't installed the new version yet, it is advisable to follow it if you plan to install the new version in parallel with the old version. In that case you can complete the installation normally and transfer the data later. This will also decrease the downtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e42d34197cf02a7569c42521d0a78b2a30e87e2d" translate="yes" xml:space="preserve">
          <source>To make these settings persist over reboots, modify &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;.</source>
          <target state="translated">要使这些设置在重新启动后仍然存在，请修改 &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec5d47aae5aa8ab0f1d50656eb690fc96ff2b236" translate="yes" xml:space="preserve">
          <source>To make these settings persist over reboots, see &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16fb8688ad143822900835b4d9dfbd8b94a6f1bd" translate="yes" xml:space="preserve">
          <source>To make use of the backup, you will need to keep all the WAL segment files generated during and after the file system backup. To aid you in doing this, the base backup process creates a &lt;em&gt;backup history file&lt;/em&gt; that is immediately stored into the WAL archive area. This file is named after the first WAL segment file that you need for the file system backup. For example, if the starting WAL file is &lt;code&gt;0000000100001234000055CD&lt;/code&gt; the backup history file will be named something like &lt;code&gt;0000000100001234000055CD.007C9330.backup&lt;/code&gt;. (The second part of the file name stands for an exact position within the WAL file, and can ordinarily be ignored.) Once you have safely archived the file system backup and the WAL segment files used during the backup (as specified in the backup history file), all archived WAL segments with names numerically less are no longer needed to recover the file system backup and can be deleted. However, you should consider keeping several backup sets to be absolutely certain that you can recover your data.</source>
          <target state="translated">要使用备份，您将需要保留在文件系统备份期间和之后生成的所有WAL段文件。为了帮助您执行此操作，基本备份过程将创建一个&lt;em&gt;备份历史文件&lt;/em&gt;，该&lt;em&gt;文件&lt;/em&gt;将立即存储到WAL存档区域中。该文件以文件系统备份所需的第一个WAL段文件命名。例如，如果起始WAL文件为 &lt;code&gt;0000000100001234000055CD&lt;/code&gt; ,则备份历史记录文件的名称将类似于 &lt;code&gt;0000000100001234000055CD.007C9330.backup&lt;/code&gt; 。。（文件名的第二部分代表WAL文件中的确切位置，通常可以忽略。）安全归档文件系统备份和备份期间使用的WAL段文件后（在备份历史记录中指定）文件），则不再需要使用名称在数字上更少的所有已归档WAL段来恢复文件系统备份，并且可以将其删除。但是，您应该考虑保留几个备份集，以确保可以恢复数据。</target>
        </trans-unit>
        <trans-unit id="837f5c3ebb10e0d282d6e0a633fa9a3ba3bd9b54" translate="yes" xml:space="preserve">
          <source>To make use of this option the server must be built with GSSAPI support. Otherwise, the &lt;code&gt;hostgssenc&lt;/code&gt; record is ignored except for logging a warning that it cannot match any connections.</source>
          <target state="translated">要使用此选项，必须使用GSSAPI支持来构建服务器。否则， &lt;code&gt;hostgssenc&lt;/code&gt; 记录将被忽略，但会记录一条警告，指出该记录无法匹配任何连接。</target>
        </trans-unit>
        <trans-unit id="da85971aae5c8da752be674039f1e182750b7050" translate="yes" xml:space="preserve">
          <source>To make use of this option the server must be built with SSL support. Furthermore, SSL must be enabled by setting the &lt;a href=&quot;runtime-config-connection#GUC-SSL&quot;&gt;ssl&lt;/a&gt; configuration parameter (see &lt;a href=&quot;ssl-tcp&quot;&gt;Section 18.9&lt;/a&gt; for more information). Otherwise, the &lt;code&gt;hostssl&lt;/code&gt; record is ignored except for logging a warning that it cannot match any connections.</source>
          <target state="translated">要使用此选项，必须使用SSL支持来构建服务器。此外，必须通过设置&lt;a href=&quot;runtime-config-connection#GUC-SSL&quot;&gt;ssl&lt;/a&gt;配置参数来启用SSL（有关更多信息，请参见&lt;a href=&quot;ssl-tcp&quot;&gt;第18.9节&lt;/a&gt;）。否则， &lt;code&gt;hostssl&lt;/code&gt; 记录将被忽略，除了会记录一条警告，指出该记录无法匹配任何连接。</target>
        </trans-unit>
        <trans-unit id="3f4fbb22a44e979c8471b584d8cdd3143713ac75" translate="yes" xml:space="preserve">
          <source>To mark a column as not-null:</source>
          <target state="translated">标记一列为非空。</target>
        </trans-unit>
        <trans-unit id="f74bd55605f3a01ec683a6cc2669467803377606" translate="yes" xml:space="preserve">
          <source>To mark a trigger as being dependent on an extension:</source>
          <target state="translated">将一个触发器标记为依赖于一个扩展。</target>
        </trans-unit>
        <trans-unit id="c90682a525c8ca51473c2dabbbd5e3caebbcf407" translate="yes" xml:space="preserve">
          <source>To mark the function &lt;code&gt;sqrt&lt;/code&gt; for type &lt;code&gt;integer&lt;/code&gt; as being dependent on the extension &lt;code&gt;mathlib&lt;/code&gt;:</source>
          <target state="translated">要将 &lt;code&gt;integer&lt;/code&gt; 类型的函数 &lt;code&gt;sqrt&lt;/code&gt; 标记为依赖于扩展 &lt;code&gt;mathlib&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a87f0d3b5cf6424cb45c1011ca70e93d95e07f0b" translate="yes" xml:space="preserve">
          <source>To mark the procedure &lt;code&gt;insert_data(integer, integer)&lt;/code&gt; as being dependent on the extension &lt;code&gt;myext&lt;/code&gt;:</source>
          <target state="translated">要将过程 &lt;code&gt;insert_data(integer, integer)&lt;/code&gt; 标记为依赖于扩展名 &lt;code&gt;myext&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4e51d812b2e54f1c7bfb9e394f6c2840143f55cf" translate="yes" xml:space="preserve">
          <source>To match a literal underscore or percent sign without matching other characters, the respective character in &lt;code&gt;pattern&lt;/code&gt; must be preceded by the escape character. The default escape character is the backslash but a different one can be selected by using the &lt;code&gt;ESCAPE&lt;/code&gt; clause. To match the escape character itself, write two escape characters.</source>
          <target state="translated">若要匹配文字下划线或百分号而又不匹配其他字符，则 &lt;code&gt;pattern&lt;/code&gt; 的各个字符必须以转义字符开头。默认的转义字符是反斜杠，但是可以使用 &lt;code&gt;ESCAPE&lt;/code&gt; 子句选择其他反斜杠。要匹配转义符本身，请写两个转义符。</target>
        </trans-unit>
        <trans-unit id="7e09584e2c2503d2bf224a496615b4861e94b3c2" translate="yes" xml:space="preserve">
          <source>To move a table to a different schema:</source>
          <target state="translated">要将一个表移动到另一个模式。</target>
        </trans-unit>
        <trans-unit id="9d011ac99577ed35b95668f7ed24ce9848185382" translate="yes" xml:space="preserve">
          <source>To move a table to a different tablespace:</source>
          <target state="translated">要将一个表移动到不同的表空间。</target>
        </trans-unit>
        <trans-unit id="57daeef8cdb28166a441c43e57ab1dd9215bcf07" translate="yes" xml:space="preserve">
          <source>To move an index to a different tablespace:</source>
          <target state="translated">要将一个索引移动到不同的表空间。</target>
        </trans-unit>
        <trans-unit id="23d5f69d43a2751745b91c696b1be2d6f922bf4b" translate="yes" xml:space="preserve">
          <source>To move the domain into a different schema:</source>
          <target state="translated">要将域移动到不同的模式中。</target>
        </trans-unit>
        <trans-unit id="ea05678bf7924aa16dd7d33be9bf040afd714f48" translate="yes" xml:space="preserve">
          <source>To move the ordered-set aggregate &lt;code&gt;mypercentile&lt;/code&gt; with direct argument of type &lt;code&gt;float8&lt;/code&gt; and aggregated argument of type &lt;code&gt;integer&lt;/code&gt; into schema &lt;code&gt;myschema&lt;/code&gt;:</source>
          <target state="translated">要将具有 &lt;code&gt;float8&lt;/code&gt; 类型的直接参数和 &lt;code&gt;integer&lt;/code&gt; 类型的聚合参数的有序集合聚合 &lt;code&gt;mypercentile&lt;/code&gt; 移动到模式 &lt;code&gt;myschema&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="4d7dd7e920e4885b23e892227ca575284224505b" translate="yes" xml:space="preserve">
          <source>To organize database objects into logical groups to make them more manageable.</source>
          <target state="translated">要把数据库对象组织成逻辑组,使其更容易管理。</target>
        </trans-unit>
        <trans-unit id="5f2fab70f4674d6404b7fc489c77334e4ba71503" translate="yes" xml:space="preserve">
          <source>To perform a WAL-logged data update using the generic WAL record facility, follow these steps:</source>
          <target state="translated">要使用通用 WAL 记录工具执行 WAL 记录数据更新,请遵循这些步骤。</target>
        </trans-unit>
        <trans-unit id="6ddc039b48dc0b7fc5e1030df7201c9c49ee4806" translate="yes" xml:space="preserve">
          <source>To pick an appropriate iteration count, consider that the original DES crypt was designed to have the speed of 4 hashes per second on the hardware of that time. Slower than 4 hashes per second would probably dampen usability. Faster than 100 hashes per second is probably too fast.</source>
          <target state="translated">要选择一个合适的迭代次数,考虑到最初的DES密码在当时的硬件上被设计成每秒4次哈希的速度。比每秒4次哈希更慢可能会影响可用性。快于每秒100次哈希的速度可能太快了。</target>
        </trans-unit>
        <trans-unit id="23bef6aee4ed8528c2ee117da497c8f55faa7e35" translate="yes" xml:space="preserve">
          <source>To prepare for remote access using &lt;code&gt;postgres_fdw&lt;/code&gt;:</source>
          <target state="translated">准备使用 &lt;code&gt;postgres_fdw&lt;/code&gt; 进行远程访问：</target>
        </trans-unit>
        <trans-unit id="3a386c565eb5f05e54673a40938f1d71b0ca70e6" translate="yes" xml:space="preserve">
          <source>To present search results it is ideal to show a part of each document and how it is related to the query. Usually, search engines show fragments of the document with marked search terms. PostgreSQL provides a function &lt;code&gt;ts_headline&lt;/code&gt; that implements this functionality.</source>
          <target state="translated">要显示搜索结果，最好显示每个文档的一部分以及它与查询的关系。通常，搜索引擎会显示带有标记搜索词的文档片段。PostgreSQL提供了实现此功能的函数 &lt;code&gt;ts_headline&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91610d07afcd9d2407804f922d11df9315715c95" translate="yes" xml:space="preserve">
          <source>To prevent spoofing on TCP connections, either use SSL certificates and make sure that clients check the server's certificate, or use GSSAPI encryption (or both, if they're on separate connections).</source>
          <target state="translated">为了防止TCP连接上的欺骗,要么使用SSL证书,并确保客户端检查服务器的证书,要么使用GSSAPI加密(或者两者兼而有之,如果他们是在不同的连接上)。</target>
        </trans-unit>
        <trans-unit id="42f51c2695b73fa0a4e3d791c3132ceaa8c8104e" translate="yes" xml:space="preserve">
          <source>To prevent spoofing with GSSAPI, the server must be configured to accept only &lt;code&gt;hostgssenc&lt;/code&gt; connections (&lt;a href=&quot;auth-pg-hba-conf&quot;&gt;Section 20.1&lt;/a&gt;) and use &lt;code&gt;gss&lt;/code&gt; authentication with them. The TCP client must connect using &lt;code&gt;gssencmode=require&lt;/code&gt;.</source>
          <target state="translated">为了防止使用GSSAPI进行欺骗，必须将服务器配置为仅接受 &lt;code&gt;hostgssenc&lt;/code&gt; 连接（&lt;a href=&quot;auth-pg-hba-conf&quot;&gt;第20.1节&lt;/a&gt;），并对其进行 &lt;code&gt;gss&lt;/code&gt; 身份验证。TCP客户端必须使用 &lt;code&gt;gssencmode=require&lt;/code&gt; 进行连接。</target>
        </trans-unit>
        <trans-unit id="a9ff680f80545ba63d8e750795a7c5531ae0e64d" translate="yes" xml:space="preserve">
          <source>To prevent spoofing with SSL, the server must be configured to accept only &lt;code&gt;hostssl&lt;/code&gt; connections (&lt;a href=&quot;auth-pg-hba-conf&quot;&gt;Section 20.1&lt;/a&gt;) and have SSL key and certificate files (&lt;a href=&quot;ssl-tcp&quot;&gt;Section 18.9&lt;/a&gt;). The TCP client must connect using &lt;code&gt;sslmode=verify-ca&lt;/code&gt; or &lt;code&gt;verify-full&lt;/code&gt; and have the appropriate root certificate file installed (&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-ssl.html#LIBQ-SSL-CERTIFICATES&quot;&gt;Section 33.18.1&lt;/a&gt;).</source>
          <target state="translated">为了防止使用SSL进行欺骗，必须将服务器配置为仅接受 &lt;code&gt;hostssl&lt;/code&gt; 连接（&lt;a href=&quot;auth-pg-hba-conf&quot;&gt;第20.1节&lt;/a&gt;），并具有SSL密钥和证书文件（&lt;a href=&quot;ssl-tcp&quot;&gt;第18.9节&lt;/a&gt;）。 TCP客户端必须使用 &lt;code&gt;sslmode=verify-ca&lt;/code&gt; 或 &lt;code&gt;verify-full&lt;/code&gt; 进行连接,并安装了适当的根证书文件（&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-ssl.html#LIBQ-SSL-CERTIFICATES&quot;&gt;第33.18.1节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="72a7be887fc7e47acf6f1ec4ef9b556ceb37c5e4" translate="yes" xml:space="preserve">
          <source>To prevent spoofing with SSL, the server must be configured to accept only &lt;code&gt;hostssl&lt;/code&gt; connections (&lt;a href=&quot;auth-pg-hba-conf&quot;&gt;Section 20.1&lt;/a&gt;) and have SSL key and certificate files (&lt;a href=&quot;ssl-tcp&quot;&gt;Section 18.9&lt;/a&gt;). The TCP client must connect using &lt;code&gt;sslmode=verify-ca&lt;/code&gt; or &lt;code&gt;verify-full&lt;/code&gt; and have the appropriate root certificate file installed (&lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-ssl.html#LIBQ-SSL-CERTIFICATES&quot;&gt;Section 33.18.1&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc27b676093ff9c2ed0caeb8bb451423cb6132ec" translate="yes" xml:space="preserve">
          <source>To prevent the operation from waiting for other transactions to commit, use either the &lt;code&gt;NOWAIT&lt;/code&gt; or &lt;code&gt;SKIP LOCKED&lt;/code&gt; option. With &lt;code&gt;NOWAIT&lt;/code&gt;, the statement reports an error, rather than waiting, if a selected row cannot be locked immediately. With &lt;code&gt;SKIP LOCKED&lt;/code&gt;, any selected rows that cannot be immediately locked are skipped. Skipping locked rows provides an inconsistent view of the data, so this is not suitable for general purpose work, but can be used to avoid lock contention with multiple consumers accessing a queue-like table. Note that &lt;code&gt;NOWAIT&lt;/code&gt; and &lt;code&gt;SKIP LOCKED&lt;/code&gt; apply only to the row-level lock(s) &amp;mdash; the required &lt;code&gt;ROW SHARE&lt;/code&gt; table-level lock is still taken in the ordinary way (see &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;). You can use &lt;a href=&quot;sql-lock&quot;&gt;LOCK&lt;/a&gt; with the &lt;code&gt;NOWAIT&lt;/code&gt; option first, if you need to acquire the table-level lock without waiting.</source>
          <target state="translated">为防止该操作等待其他事务提交，请使用 &lt;code&gt;NOWAIT&lt;/code&gt; 或 &lt;code&gt;SKIP LOCKED&lt;/code&gt; 选项。使用 &lt;code&gt;NOWAIT&lt;/code&gt; ，如果无法立即锁定所选行，则该语句报告错误，而不是等待。使用&amp;ldquo; &lt;code&gt;SKIP LOCKED&lt;/code&gt; ，将跳过所有不能立即锁定的选定行。跳过锁定的行会提供不一致的数据视图，因此这不适用于一般用途，但可用于避免多个使用者访问类似队列的表时发生锁争用。请注意， &lt;code&gt;NOWAIT&lt;/code&gt; 和 &lt;code&gt;SKIP LOCKED&lt;/code&gt; 仅适用于行级锁-所需的行 &lt;code&gt;ROW SHARE&lt;/code&gt; 表级锁定仍以普通方式进行（请参阅&lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;第13章&lt;/a&gt;）。如果需要不等待就获取表级锁，则可以先将&lt;a href=&quot;sql-lock&quot;&gt;LOCK&lt;/a&gt;与 &lt;code&gt;NOWAIT&lt;/code&gt; 选项一起使用。</target>
        </trans-unit>
        <trans-unit id="b553159d4136d5984c4e16bd4d3e8a393e646772" translate="yes" xml:space="preserve">
          <source>To prevent the operation from waiting for other transactions to commit, use either the &lt;code&gt;NOWAIT&lt;/code&gt; or &lt;code&gt;SKIP LOCKED&lt;/code&gt; option. With &lt;code&gt;NOWAIT&lt;/code&gt;, the statement reports an error, rather than waiting, if a selected row cannot be locked immediately. With &lt;code&gt;SKIP LOCKED&lt;/code&gt;, any selected rows that cannot be immediately locked are skipped. Skipping locked rows provides an inconsistent view of the data, so this is not suitable for general purpose work, but can be used to avoid lock contention with multiple consumers accessing a queue-like table. Note that &lt;code&gt;NOWAIT&lt;/code&gt; and &lt;code&gt;SKIP LOCKED&lt;/code&gt; apply only to the row-level lock(s) &amp;mdash; the required &lt;code&gt;ROW SHARE&lt;/code&gt; table-level lock is still taken in the ordinary way (see &lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;). You can use &lt;a href=&quot;sql-lock&quot;&gt;LOCK&lt;/a&gt; with the &lt;code&gt;NOWAIT&lt;/code&gt; option first, if you need to acquire the table-level lock without waiting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fafa62267d5a132b9de46d4638dc16e7682262f" translate="yes" xml:space="preserve">
          <source>To prevent unencrypted passwords from being sent across the network, written to the server log or otherwise stolen by a database administrator, PostgreSQL allows the user to supply pre-encrypted passwords. Many client programs make use of this functionality and encrypt the password before sending it to the server.</source>
          <target state="translated">为了防止未加密的密码在网络上发送、写入服务器日志或被数据库管理员窃取,PostgreSQL允许用户提供预加密的密码。许多客户端程序利用这一功能,在向服务器发送密码之前对密码进行加密。</target>
        </trans-unit>
        <trans-unit id="750038db302e8d94eb0a926900beb6c3bdd93c4b" translate="yes" xml:space="preserve">
          <source>To prevent unprivileged users from exploiting the authentication rights of the unix user the postgres server is running as to escalate to superuser rights, only the superuser may set this option on a user mapping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c451daeed477af5e11625a2ad40100dc2bdf1542" translate="yes" xml:space="preserve">
          <source>To print your current working directory, use &lt;code&gt;\! pwd&lt;/code&gt;.</source>
          <target state="translated">要打印当前的工作目录，请使用 &lt;code&gt;\! pwd&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a131063e73631c22faf8847eb9eabb84d102d285" translate="yes" xml:space="preserve">
          <source>To process values of data type &lt;code&gt;xml&lt;/code&gt;, PostgreSQL offers the functions &lt;code&gt;xpath&lt;/code&gt; and &lt;code&gt;xpath_exists&lt;/code&gt;, which evaluate XPath 1.0 expressions, and the &lt;code&gt;XMLTABLE&lt;/code&gt; table function.</source>
          <target state="translated">为了处理 &lt;code&gt;xml&lt;/code&gt; 数据类型的值，PostgreSQL提供了 &lt;code&gt;xpath&lt;/code&gt; 和 &lt;code&gt;xpath_exists&lt;/code&gt; 函数（用于评估XPath 1.0表达式）以及 &lt;code&gt;XMLTABLE&lt;/code&gt; 表函数。</target>
        </trans-unit>
        <trans-unit id="98d5d2d83e0f32f0cf968b16a03133578932bc09" translate="yes" xml:space="preserve">
          <source>To produce a value of type &lt;code&gt;xml&lt;/code&gt; from character data, use the function &lt;code&gt;xmlparse&lt;/code&gt;:</source>
          <target state="translated">要从字符数据生成 &lt;code&gt;xml&lt;/code&gt; 类型的值，请使用 &lt;code&gt;xmlparse&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="fbc26abf86484eb02c81e19a75b343ee2d71adcb" translate="yes" xml:space="preserve">
          <source>To protect against loss of very old data due to &lt;em&gt;transaction ID wraparound&lt;/em&gt; or &lt;em&gt;multixact ID wraparound&lt;/em&gt;.</source>
          <target state="translated">为了防止由于&lt;em&gt;事务ID &lt;/em&gt;&lt;em&gt;换行&lt;/em&gt;或&lt;em&gt;multixact ID换行&lt;/em&gt;而丢失非常旧的数据。</target>
        </trans-unit>
        <trans-unit id="aecbc3cb94c5315064318106fc3dd71a1faa9ab3" translate="yes" xml:space="preserve">
          <source>To protect password information stored as a user mapping option, the &lt;code&gt;umoptions&lt;/code&gt; column will read as null unless one of the following applies:</source>
          <target state="translated">为了保护作为用户映射选项存储的密码信息，除非满足以下条件之一，否则 &lt;code&gt;umoptions&lt;/code&gt; 列将显示为null：</target>
        </trans-unit>
        <trans-unit id="51b2cfa383e2f1702167bdd2ca292f075ce10dc7" translate="yes" xml:space="preserve">
          <source>To provide a concrete example, assume that the top node is a &lt;code&gt;MergeJoin&lt;/code&gt; node. Before any merge can be done two rows have to be fetched (one from each subplan). So the executor recursively calls itself to process the subplans (it starts with the subplan attached to &lt;code&gt;lefttree&lt;/code&gt;). The new top node (the top node of the left subplan) is, let's say, a &lt;code&gt;Sort&lt;/code&gt; node and again recursion is needed to obtain an input row. The child node of the &lt;code&gt;Sort&lt;/code&gt; might be a &lt;code&gt;SeqScan&lt;/code&gt; node, representing actual reading of a table. Execution of this node causes the executor to fetch a row from the table and return it up to the calling node. The &lt;code&gt;Sort&lt;/code&gt; node will repeatedly call its child to obtain all the rows to be sorted. When the input is exhausted (as indicated by the child node returning a NULL instead of a row), the &lt;code&gt;Sort&lt;/code&gt; code performs the sort, and finally is able to return its first output row, namely the first one in sorted order. It keeps the remaining rows stored so that it can deliver them in sorted order in response to later demands.</source>
          <target state="translated">为了提供一个具体的示例，假定顶级节点是 &lt;code&gt;MergeJoin&lt;/code&gt; 节点。在进行任何合并之前，必须获取两行（每个子计划中的每一行）。因此，执行者以递归方式调用自己来处理子计划（它从附加到 &lt;code&gt;lefttree&lt;/code&gt; 的子计划开始）。假设新的顶部节点（左子计划的顶部节点）是 &lt;code&gt;Sort&lt;/code&gt; 节点，并且再次需要递归才能获得输入行。 &lt;code&gt;Sort&lt;/code&gt; 的子节点可能是 &lt;code&gt;SeqScan&lt;/code&gt; 节点，代表表的实际读取。执行此节点会使执行程序从表中获取一行，并将其返回到调用节点。该 &lt;code&gt;Sort&lt;/code&gt; 节点将反复调用其子级以获得所有要排序的行。当输入耗尽时（如子节点返回NULL而不是一行所指示）， &lt;code&gt;Sort&lt;/code&gt; 代码执行排序，最后能够返回其第一行输出，即按排序顺序的第一行。它会保留剩余的行，以便可以响应以后的需求按排序顺序交付它们。</target>
        </trans-unit>
        <trans-unit id="f8f2f6c60f59be342f296675cbb6d7d227bbb0e5" translate="yes" xml:space="preserve">
          <source>To put our new schema in the path, we use:</source>
          <target state="translated">要把我们的新模式放在路径中,我们使用。</target>
        </trans-unit>
        <trans-unit id="d2ab4b8e95ce2374ac017800199c82360e8ede52" translate="yes" xml:space="preserve">
          <source>To put this together, assume we have tables &lt;code&gt;t1&lt;/code&gt;:</source>
          <target state="translated">综上所述，假设我们有表 &lt;code&gt;t1&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f8f25452daa9e8fa2f75b3821f5a1a4903c6db98" translate="yes" xml:space="preserve">
          <source>To query the current client encoding:</source>
          <target state="translated">查询当前客户端的编码。</target>
        </trans-unit>
        <trans-unit id="9cf10f5f8dca749b86d683a9d81cf1278b14624d" translate="yes" xml:space="preserve">
          <source>To quit the session, type EOF (&lt;strong&gt;Control&lt;/strong&gt;+&lt;strong&gt;D&lt;/strong&gt;, usually). If you've entered any text since the last command entry terminator, then EOF will be taken as a command entry terminator, and another EOF will be needed to exit.</source>
          <target state="translated">要退出会话，请键入EOF（通常是&lt;strong&gt;Control&lt;/strong&gt; + &lt;strong&gt;D&lt;/strong&gt;）。如果自上一个命令输入终止符以来输入了​​任何文本，则EOF将被视为命令输入终止符，并且需要另一个EOF退出。</target>
        </trans-unit>
        <trans-unit id="d36fa75ce18b12e898c68aa49a95948a9fcf9202" translate="yes" xml:space="preserve">
          <source>To read the data you need to examine each attribute in turn. First check whether the field is NULL according to the null bitmap. If it is, go to the next. Then make sure you have the right alignment. If the field is a fixed width field, then all the bytes are simply placed. If it's a variable length field (attlen = -1) then it's a bit more complicated. All variable-length data types share the common header structure &lt;code&gt;struct varlena&lt;/code&gt;, which includes the total length of the stored value and some flag bits. Depending on the flags, the data can be either inline or in a TOAST table; it might be compressed, too (see &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt;).</source>
          <target state="translated">要读取数据，您需要依次检查每个属性。首先根据空位图检查该字段是否为NULL。如果是，请转到下一个。然后确保对齐正确。如果该字段是固定宽度的字段，则所有字节都将被简单放置。如果它是一个可变长度的字段（attlen = -1），则要复杂一些。所有长度可变的数据类型都共享公用的标头结构 &lt;code&gt;struct varlena&lt;/code&gt; ，其中包括存储值的总长度和一些标志位。根据标志的不同，数据可以是内联的或在TOAST表中。它也可能被压缩（请参阅&lt;a href=&quot;storage-toast&quot;&gt;第68.2节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="f9866d0ae8c9c03df48b8c82014bb3ec303fe38d" translate="yes" xml:space="preserve">
          <source>To recover or reuse disk space occupied by updated or deleted rows.</source>
          <target state="translated">恢复或重新使用更新或删除的行所占用的磁盘空间。</target>
        </trans-unit>
        <trans-unit id="0ec6cf49dce03885d6924bd642450bf7ec8ca2bb" translate="yes" xml:space="preserve">
          <source>To recover successfully using continuous archiving (also called &amp;ldquo;online backup&amp;rdquo; by many database vendors), you need a continuous sequence of archived WAL files that extends back at least as far as the start time of your backup. So to get started, you should set up and test your procedure for archiving WAL files &lt;em&gt;before&lt;/em&gt; you take your first base backup. Accordingly, we first discuss the mechanics of archiving WAL files.</source>
          <target state="translated">要使用连续归档（许多数据库供应商也称为&amp;ldquo;在线备份&amp;rdquo;）成功恢复，您需要连续的WAL归档文件序列，该序列至少可以延伸到备份的开始时间。因此，开始之前，您应该设置并测试用于存档WAL文件的过程，&lt;em&gt;然后&lt;/em&gt;再进行第一次基本备份。因此，我们首先讨论归档WAL文件的机制。</target>
        </trans-unit>
        <trans-unit id="d53b3ac0ed6d158f6c1a488d4a5b85260dfbebb1" translate="yes" xml:space="preserve">
          <source>To recreate a primary key constraint, without blocking updates while the index is rebuilt:</source>
          <target state="translated">要重新创建一个主键约束,在重建索引时不阻止更新。</target>
        </trans-unit>
        <trans-unit id="f2cdf032afa04bfde3b56e7422c93b52014fb3ad" translate="yes" xml:space="preserve">
          <source>To refer to the JSON data to be queried (the &lt;em&gt;context item&lt;/em&gt;), use the &lt;code&gt;$&lt;/code&gt; sign in the path expression. It can be followed by one or more &lt;a href=&quot;datatype-json#TYPE-JSONPATH-ACCESSORS&quot;&gt;accessor operators&lt;/a&gt;, which go down the JSON structure level by level to retrieve the content of context item. Each operator that follows deals with the result of the previous evaluation step.</source>
          <target state="translated">要引用要查询的JSON数据（&lt;em&gt;上下文项&lt;/em&gt;），请在路径表达式中使用 &lt;code&gt;$&lt;/code&gt; 符号。它后面可以跟随一个或多个&lt;a href=&quot;datatype-json#TYPE-JSONPATH-ACCESSORS&quot;&gt;访问运算符&lt;/a&gt;，这些运算符逐级下降到JSON结构中以检索上下文项的内容。随后的每个运算符都会处理上一个评估步骤的结果。</target>
        </trans-unit>
        <trans-unit id="62d35a44cda58220e85434adb6b5a58ad9f84bd9" translate="yes" xml:space="preserve">
          <source>To refer to the JSON value being queried (the &lt;em&gt;context item&lt;/em&gt;), use the &lt;code&gt;$&lt;/code&gt; variable in the path expression. It can be followed by one or more &lt;a href=&quot;datatype-json#TYPE-JSONPATH-ACCESSORS&quot;&gt;accessor operators&lt;/a&gt;, which go down the JSON structure level by level to retrieve sub-items of the context item. Each operator that follows deals with the result of the previous evaluation step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3f35bb3c3217f63e284e67100cd585c002369af" translate="yes" xml:space="preserve">
          <source>To register a Windows event log library with the operating system, issue this command:</source>
          <target state="translated">要向操作系统注册Windows事件日志库,请发出此命令。</target>
        </trans-unit>
        <trans-unit id="dcb97cb35602cb8d8e37b3f72ca29c284ab19a82" translate="yes" xml:space="preserve">
          <source>To reindex the database &lt;code&gt;test&lt;/code&gt;:</source>
          <target state="translated">重新索引数据库 &lt;code&gt;test&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="138f6f46f9b12919030644b082f862e4465c8a0a" translate="yes" xml:space="preserve">
          <source>To reindex the table &lt;code&gt;foo&lt;/code&gt; and the index &lt;code&gt;bar&lt;/code&gt; in a database named &lt;code&gt;abcd&lt;/code&gt;:</source>
          <target state="translated">要在名为 &lt;code&gt;abcd&lt;/code&gt; 的数据库中为表 &lt;code&gt;foo&lt;/code&gt; 和索引 &lt;code&gt;bar&lt;/code&gt; 编制索引：</target>
        </trans-unit>
        <trans-unit id="e5057bddf51642163d4a618fef89da2f20efe141" translate="yes" xml:space="preserve">
          <source>To reload an archive file into a (freshly created) database named &lt;code&gt;newdb&lt;/code&gt;:</source>
          <target state="translated">要将存档文件重新加载到名为 &lt;code&gt;newdb&lt;/code&gt; 的（新创建的）数据库中：</target>
        </trans-unit>
        <trans-unit id="3b7e0dad208d77313671288bf71252a8aeccebaa" translate="yes" xml:space="preserve">
          <source>To reload an archive file into the same database it was dumped from, discarding the current contents of that database:</source>
          <target state="translated">将存档文件重新加载到它所转储的同一数据库中,同时丢弃该数据库的当前内容。</target>
        </trans-unit>
        <trans-unit id="27e3d3483ae6968cc1f2c3ce744fe6ae6e8dc36d" translate="yes" xml:space="preserve">
          <source>To reload database(s) from this file, you can use:</source>
          <target state="translated">要从这个文件中重新加载数据库,你可以使用。</target>
        </trans-unit>
        <trans-unit id="ae1f253d1ca56a0ccbe7b45bc0b81811cbddeeaf" translate="yes" xml:space="preserve">
          <source>To reload such a script into a (freshly created) database named &lt;code&gt;newdb&lt;/code&gt;:</source>
          <target state="translated">要将这样的脚本重新加载到（新创建的）名为 &lt;code&gt;newdb&lt;/code&gt; 的数据库中：</target>
        </trans-unit>
        <trans-unit id="bddc1307f67d5937507c3936d2f30649aec06219" translate="yes" xml:space="preserve">
          <source>To reload the dump into a new database called &lt;code&gt;newdb&lt;/code&gt;:</source>
          <target state="translated">要将转储重新加载到名为 &lt;code&gt;newdb&lt;/code&gt; 的新数据库中：</target>
        </trans-unit>
        <trans-unit id="aaf515c8d58cd92994dfa8743f12dbbc2da1e757" translate="yes" xml:space="preserve">
          <source>To remove a &lt;code&gt;NOT NULL&lt;/code&gt; constraint from a domain:</source>
          <target state="translated">要从域中删除 &lt;code&gt;NOT NULL&lt;/code&gt; 约束：</target>
        </trans-unit>
        <trans-unit id="43d57a60bc9ae4720c85f65f48b02b03c6794f87" translate="yes" xml:space="preserve">
          <source>To remove a check constraint from a domain:</source>
          <target state="translated">要从一个域中删除一个检查约束。</target>
        </trans-unit>
        <trans-unit id="9a9e31afd39806417b7470fbbe1579d5f02a99b3" translate="yes" xml:space="preserve">
          <source>To remove a check constraint from a table and all its children:</source>
          <target state="translated">从表及其所有子表中删除一个检查约束。</target>
        </trans-unit>
        <trans-unit id="0e497bf41a3189343b6ead8f2d75b97c2d5c2bcf" translate="yes" xml:space="preserve">
          <source>To remove a check constraint from one table only:</source>
          <target state="translated">仅从一个表中删除一个检查约束。</target>
        </trans-unit>
        <trans-unit id="828d46eba3a55278c8fef7d5b286efdc8ef06ffe" translate="yes" xml:space="preserve">
          <source>To remove a column, use a command like:</source>
          <target state="translated">要删除一列,请使用类似命令。</target>
        </trans-unit>
        <trans-unit id="38b773bd2feefcad9281dad1181f9587cfd50577" translate="yes" xml:space="preserve">
          <source>To remove a constraint you need to know its name. If you gave it a name then that's easy. Otherwise the system assigned a generated name, which you need to find out. The psql command &lt;code&gt;\d tablename&lt;/code&gt; can be helpful here; other interfaces might also provide a way to inspect table details. Then the command is:</source>
          <target state="translated">要删除约束，您需要知道其名称。如果您给它起个名字，那很容易。否则，系统会分配一个生成的名称，您需要找出该名称。psql命令 &lt;code&gt;\d tablename&lt;/code&gt; 在这里可能会有所帮助；其他接口也可能提供检查表详细信息的方法。然后命令是：</target>
        </trans-unit>
        <trans-unit id="9d7bf31a2f8f86534f45191efcc458666b31374c" translate="yes" xml:space="preserve">
          <source>To remove a not-null constraint from a column:</source>
          <target state="translated">要从列中删除一个非空约束。</target>
        </trans-unit>
        <trans-unit id="4f18a4496457502cea39c274b659cf7a0e3dd2ca" translate="yes" xml:space="preserve">
          <source>To remove an empty tablespace, use the &lt;a href=&quot;sql-droptablespace&quot;&gt;DROP TABLESPACE&lt;/a&gt; command.</source>
          <target state="translated">要删除空的表空间，请使用&lt;a href=&quot;sql-droptablespace&quot;&gt;DROP TABLESPACE&lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="9d6c89dfb4f37ed7623a88212bd89770872746a5" translate="yes" xml:space="preserve">
          <source>To remove an index, use the &lt;code&gt;DROP INDEX&lt;/code&gt; command. Indexes can be added to and removed from tables at any time.</source>
          <target state="translated">要删除索引，请使用 &lt;code&gt;DROP INDEX&lt;/code&gt; 命令。索引可以随时添加到表中或从表中删除。</target>
        </trans-unit>
        <trans-unit id="863c52a00c465065e0fd5b5b9e4219a452bdd2e6" translate="yes" xml:space="preserve">
          <source>To remove any default value, use:</source>
          <target state="translated">要删除任何默认值,请使用。</target>
        </trans-unit>
        <trans-unit id="4da4a9003d8a732be59d4e186cdb4572715ec792" translate="yes" xml:space="preserve">
          <source>To remove multiple aggregate functions in one command:</source>
          <target state="translated">要在一个命令中删除多个集合函数。</target>
        </trans-unit>
        <trans-unit id="9b21c46be28b23a3a07faf23f47b9607ffc3c2e4" translate="yes" xml:space="preserve">
          <source>To remove old data quickly, simply drop the child table that is no longer necessary:</source>
          <target state="translated">要快速删除旧数据,只需将不再需要的子表删除即可。</target>
        </trans-unit>
        <trans-unit id="65fd62c46521a14a29fb65a65dedbdfbb6d6b06a" translate="yes" xml:space="preserve">
          <source>To remove schema &lt;code&gt;mystuff&lt;/code&gt; from the database, along with everything it contains:</source>
          <target state="translated">要从数据库及其所有内容中删除模式 &lt;code&gt;mystuff&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e78e623783230e4cc0e151a3cb51e4033af11214" translate="yes" xml:space="preserve">
          <source>To remove tablespace &lt;code&gt;mystuff&lt;/code&gt; from the system:</source>
          <target state="translated">要从系统中删除表空间 &lt;code&gt;mystuff&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c2a01c776d1c085c3540b493a34415d36ce80315" translate="yes" xml:space="preserve">
          <source>To remove the aggregate function &lt;code&gt;myavg&lt;/code&gt; for type &lt;code&gt;integer&lt;/code&gt;:</source>
          <target state="translated">删除 &lt;code&gt;integer&lt;/code&gt; 类型的聚合函数 &lt;code&gt;myavg&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="18432f9ba2212a860ecc264cd27f66a7159842e5" translate="yes" xml:space="preserve">
          <source>To remove the child table from the inheritance hierarchy table but retain access to it as a table in its own right:</source>
          <target state="translated">将子表从继承层次表中删除,但保留对子表的访问权,将其作为一个独立的表。</target>
        </trans-unit>
        <trans-unit id="886afd40ec1a253663f53b4cfe1afde02afa622c" translate="yes" xml:space="preserve">
          <source>To remove the data type &lt;code&gt;box&lt;/code&gt;:</source>
          <target state="translated">要删除数据类型 &lt;code&gt;box&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="635ed4f05863a9f71083e43a22035c0726192374" translate="yes" xml:space="preserve">
          <source>To remove the domain &lt;code&gt;box&lt;/code&gt;:</source>
          <target state="translated">删除域 &lt;code&gt;box&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="82d262101f6ede3cfc7b9b800d5bff7eebc905f2" translate="yes" xml:space="preserve">
          <source>To remove the extension &lt;code&gt;hstore&lt;/code&gt; from the current database:</source>
          <target state="translated">要从当前数据库中删除扩展名 &lt;code&gt;hstore&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="494e3e330fb09e7b6316ea0f77db993749794bdb" translate="yes" xml:space="preserve">
          <source>To remove the hypothetical-set aggregate function &lt;code&gt;myrank&lt;/code&gt;, which takes an arbitrary list of ordering columns and a matching list of direct arguments:</source>
          <target state="translated">要删除假设集的集合函数 &lt;code&gt;myrank&lt;/code&gt; ，该函数需要一个任意的排序列列表和一个匹配的直接参数列表：</target>
        </trans-unit>
        <trans-unit id="cbcb6cb74fb44eda858f0ac7e28a925c61f87522" translate="yes" xml:space="preserve">
          <source>To remove the sequence &lt;code&gt;serial&lt;/code&gt;:</source>
          <target state="translated">删除序列 &lt;code&gt;serial&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1b7ff8809c902f7b43d3c36cc0a9d83ff1ce8a61" translate="yes" xml:space="preserve">
          <source>To remove these entries again:</source>
          <target state="translated">要再次删除这些条目。</target>
        </trans-unit>
        <trans-unit id="4108ee2cc9d5481b40105aec05235dc19894777f" translate="yes" xml:space="preserve">
          <source>To remove user &lt;code&gt;joe&lt;/code&gt; from the default database server:</source>
          <target state="translated">要从默认数据库服务器中删除用户 &lt;code&gt;joe&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="72cfb1afee008e173ec2d90c24909e8d66dcffdd" translate="yes" xml:space="preserve">
          <source>To remove user &lt;code&gt;joe&lt;/code&gt; using the server on host &lt;code&gt;eden&lt;/code&gt;, port 5000, with verification and a peek at the underlying command:</source>
          <target state="translated">要使用主机 &lt;code&gt;eden&lt;/code&gt; 端口5000 上的服务器删除用户 &lt;code&gt;joe&lt;/code&gt; ，并进行验证并查看基本命令：</target>
        </trans-unit>
        <trans-unit id="e37544649a72b8a59f8c0b68b1aacebc069fd9f8" translate="yes" xml:space="preserve">
          <source>To rename a check constraint on a domain:</source>
          <target state="translated">要重新命名域上的检查约束。</target>
        </trans-unit>
        <trans-unit id="b83e0f282dba779e1c589b71830e43ea103d9012" translate="yes" xml:space="preserve">
          <source>To rename a column:</source>
          <target state="translated">要重新命名一列。</target>
        </trans-unit>
        <trans-unit id="b5e5da677db2fffdfcf0e82e91bd6cc552c32de7" translate="yes" xml:space="preserve">
          <source>To rename a data type:</source>
          <target state="translated">重命名数据类型。</target>
        </trans-unit>
        <trans-unit id="7d71c65ad2b7649e53d418d1384b99760b8cbf7d" translate="yes" xml:space="preserve">
          <source>To rename a table:</source>
          <target state="translated">要重新命名一个表。</target>
        </trans-unit>
        <trans-unit id="bebd170e762f96e494ba703054401a1292e6a4cd" translate="yes" xml:space="preserve">
          <source>To rename an enum value:</source>
          <target state="translated">重命名一个枚举值。</target>
        </trans-unit>
        <trans-unit id="3d7cb45901b32ab3bbca6ee1b7fd15872ac86082" translate="yes" xml:space="preserve">
          <source>To rename an existing column:</source>
          <target state="translated">要重新命名一个现有的列。</target>
        </trans-unit>
        <trans-unit id="385765b2179fde3d6b2824f89a1271dbcc7b0710" translate="yes" xml:space="preserve">
          <source>To rename an existing constraint:</source>
          <target state="translated">重新命名现有约束。</target>
        </trans-unit>
        <trans-unit id="19c54adeb02c0368e819e3163324f15879d5d129" translate="yes" xml:space="preserve">
          <source>To rename an existing index:</source>
          <target state="translated">要重新命名一个现有的索引。</target>
        </trans-unit>
        <trans-unit id="14be6b17313dbc046405c1a325a71641d10beb04" translate="yes" xml:space="preserve">
          <source>To rename an existing rule:</source>
          <target state="translated">重命名现有规则。</target>
        </trans-unit>
        <trans-unit id="56da100cf20dd052a2da93853002e3fdb0762cc7" translate="yes" xml:space="preserve">
          <source>To rename an existing table:</source>
          <target state="translated">重命名现有表格。</target>
        </trans-unit>
        <trans-unit id="6bbd8f56914d76dfacdfc65adea299ab3845b458" translate="yes" xml:space="preserve">
          <source>To rename an existing trigger:</source>
          <target state="translated">重新命名一个现有的触发器。</target>
        </trans-unit>
        <trans-unit id="cdf19eae86ecfc217b5d5f46e0856386ad5eae2f" translate="yes" xml:space="preserve">
          <source>To rename the aggregate function &lt;code&gt;myavg&lt;/code&gt; for type &lt;code&gt;integer&lt;/code&gt; to &lt;code&gt;my_average&lt;/code&gt;:</source>
          <target state="translated">要将 &lt;code&gt;integer&lt;/code&gt; 类型的聚合函数 &lt;code&gt;myavg&lt;/code&gt; 重命名为 &lt;code&gt;my_average&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="73c57928390ad7de8bef0ca57d35d82c58caddbc" translate="yes" xml:space="preserve">
          <source>To rename the collation &lt;code&gt;de_DE&lt;/code&gt; to &lt;code&gt;german&lt;/code&gt;:</source>
          <target state="translated">要将排序规则 &lt;code&gt;de_DE&lt;/code&gt; 重命名为 &lt;code&gt;german&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a17ea574108719c0205b5d2e7a7cb84dbc9485ae" translate="yes" xml:space="preserve">
          <source>To rename the conversion &lt;code&gt;iso_8859_1_to_utf8&lt;/code&gt; to &lt;code&gt;latin1_to_unicode&lt;/code&gt;:</source>
          <target state="translated">要将转换 &lt;code&gt;iso_8859_1_to_utf8&lt;/code&gt; 重命名为 &lt;code&gt;latin1_to_unicode&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="294d57ccf76b0a74a2d7f7f68af3ab1df25411cd" translate="yes" xml:space="preserve">
          <source>To rename the function &lt;code&gt;sqrt&lt;/code&gt; for type &lt;code&gt;integer&lt;/code&gt; to &lt;code&gt;square_root&lt;/code&gt;:</source>
          <target state="translated">要将 &lt;code&gt;integer&lt;/code&gt; 类型的函数 &lt;code&gt;sqrt&lt;/code&gt; 重命名为 &lt;code&gt;square_root&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fe4158dd5c515d2058cc9b30dfc63ceb0718218d" translate="yes" xml:space="preserve">
          <source>To rename the materialized view &lt;code&gt;foo&lt;/code&gt; to &lt;code&gt;bar&lt;/code&gt;:</source>
          <target state="translated">要将物化视图 &lt;code&gt;foo&lt;/code&gt; 重命名为 &lt;code&gt;bar&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="bb76974774fa71ac10b20040500aca23ab2159c9" translate="yes" xml:space="preserve">
          <source>To rename the procedure &lt;code&gt;insert_data&lt;/code&gt; with two arguments of type &lt;code&gt;integer&lt;/code&gt; to &lt;code&gt;insert_record&lt;/code&gt;:</source>
          <target state="translated">要将带有两个 &lt;code&gt;integer&lt;/code&gt; 类型的参数的过程 &lt;code&gt;insert_data&lt;/code&gt; 重命名为 &lt;code&gt;insert_record&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f62e25c88ab08cbb7e93b34f512b78b01a264d89" translate="yes" xml:space="preserve">
          <source>To rename the routine &lt;code&gt;foo&lt;/code&gt; for type &lt;code&gt;integer&lt;/code&gt; to &lt;code&gt;foobar&lt;/code&gt;:</source>
          <target state="translated">要将 &lt;code&gt;integer&lt;/code&gt; 类型的例程 &lt;code&gt;foo&lt;/code&gt; 重命名为 &lt;code&gt;foobar&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a1263372069e771787275bba5c32ba81c76bacbb" translate="yes" xml:space="preserve">
          <source>To rename the view &lt;code&gt;foo&lt;/code&gt; to &lt;code&gt;bar&lt;/code&gt;:</source>
          <target state="translated">要将视图 &lt;code&gt;foo&lt;/code&gt; 重命名为 &lt;code&gt;bar&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="26bdd6f1e45a99315aafab5faba4caedc29cd14b" translate="yes" xml:space="preserve">
          <source>To reorder database items, it is first necessary to dump the table of contents of the archive:</source>
          <target state="translated">要对数据库项目进行重新排序,首先要对档案的目录表进行转储。</target>
        </trans-unit>
        <trans-unit id="3e91986eabef2675111d76504a2dca941d4323fb" translate="yes" xml:space="preserve">
          <source>To replace the current definition of an existing function, use &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt;. It is not possible to change the name or argument types of a function this way (if you tried, you would actually be creating a new, distinct function). Also, &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; will not let you change the return type of an existing function. To do that, you must drop and recreate the function. (When using &lt;code&gt;OUT&lt;/code&gt; parameters, that means you cannot change the types of any &lt;code&gt;OUT&lt;/code&gt; parameters except by dropping the function.)</source>
          <target state="translated">要替换现有功能的当前定义，请使用 &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; 。无法以这种方式更改函数的名称或参数类型（如果尝试过，则实际上是在创建一个新的，不同的函数）。同样， &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; 将不允许您更改现有函数的返回类型。为此，必须删除并重新创建该函数。（使用 &lt;code&gt;OUT&lt;/code&gt; 参数时，这意味着您只能通过删除函数来更改任何 &lt;code&gt;OUT&lt;/code&gt; 参数的类型。）</target>
        </trans-unit>
        <trans-unit id="e07e56e3dea5794b7967ede7f52d55f75fb914f4" translate="yes" xml:space="preserve">
          <source>To replace the current definition of an existing procedure, use &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt;. It is not possible to change the name or argument types of a procedure this way (if you tried, you would actually be creating a new, distinct procedure).</source>
          <target state="translated">要替换现有过程的当前定义，请使用 &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; 。无法以这种方式更改过程的名称或参数类型（如果尝试过，则实际上是在创建一个新的，不同的过程）。</target>
        </trans-unit>
        <trans-unit id="d4a3314b1af2194d4a9d0e3864d532cddd54f341" translate="yes" xml:space="preserve">
          <source>To represent lexemes containing whitespace or punctuation, surround them with quotes:</source>
          <target state="translated">表示含有空格或标点符号的词条,请用引号包围。</target>
        </trans-unit>
        <trans-unit id="e9ee960ea9a62dbb00e555c52be286d5babe0b9b" translate="yes" xml:space="preserve">
          <source>To reproduce the build configuration of the current PostgreSQL installation, run the following command:</source>
          <target state="translated">要重现当前PostgreSQL安装的构建配置,运行以下命令。</target>
        </trans-unit>
        <trans-unit id="c852628026196abd448f5bcdf2f61ec1a2440fe6" translate="yes" xml:space="preserve">
          <source>To require the client to supply a trusted certificate, place certificates of the root certificate authorities (CAs) you trust in a file in the data directory, set the parameter &lt;a href=&quot;runtime-config-connection#GUC-SSL-CA-FILE&quot;&gt;ssl_ca_file&lt;/a&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt; to the new file name, and add the authentication option &lt;code&gt;clientcert=verify-ca&lt;/code&gt; or &lt;code&gt;clientcert=verify-full&lt;/code&gt; to the appropriate &lt;code&gt;hostssl&lt;/code&gt; line(s) in &lt;code&gt;pg_hba.conf&lt;/code&gt;. A certificate will then be requested from the client during SSL connection startup. (See &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-ssl.html&quot;&gt;Section 33.18&lt;/a&gt; for a description of how to set up certificates on the client.)</source>
          <target state="translated">要要求客户提供受信任的证书，你在数据目录中的文件信任的根证书颁发机构（CA）的地方证书，设置参数&lt;a href=&quot;runtime-config-connection#GUC-SSL-CA-FILE&quot;&gt;ssl_ca_file&lt;/a&gt;在 &lt;code&gt;postgresql.conf&lt;/code&gt; 中的新文件名，并添加认证选项 &lt;code&gt;clientcert=verify-ca&lt;/code&gt; 或 &lt;code&gt;clientcert=verify-full&lt;/code&gt; 到 &lt;code&gt;pg_hba.conf&lt;/code&gt; 中的相应 &lt;code&gt;hostssl&lt;/code&gt; 行。然后，在SSL连接启动期间将从客户端请求证书。 （有关如何在客户端上设置证书的说明，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-ssl.html&quot;&gt;第33.18节&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="2089cdf040a512976a9ff54157e13cd1f1bda41c" translate="yes" xml:space="preserve">
          <source>To require the client to supply a trusted certificate, place certificates of the root certificate authorities (CAs) you trust in a file in the data directory, set the parameter &lt;a href=&quot;runtime-config-connection#GUC-SSL-CA-FILE&quot;&gt;ssl_ca_file&lt;/a&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt; to the new file name, and add the authentication option &lt;code&gt;clientcert=verify-ca&lt;/code&gt; or &lt;code&gt;clientcert=verify-full&lt;/code&gt; to the appropriate &lt;code&gt;hostssl&lt;/code&gt; line(s) in &lt;code&gt;pg_hba.conf&lt;/code&gt;. A certificate will then be requested from the client during SSL connection startup. (See &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-ssl.html&quot;&gt;Section 33.18&lt;/a&gt; for a description of how to set up certificates on the client.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aa65fcf4333fcf0b551df531e03fa872e27a539" translate="yes" xml:space="preserve">
          <source>To retrieve data from a table, the table is &lt;em&gt;queried&lt;/em&gt;. An SQL &lt;code&gt;SELECT&lt;/code&gt; statement is used to do this. The statement is divided into a select list (the part that lists the columns to be returned), a table list (the part that lists the tables from which to retrieve the data), and an optional qualification (the part that specifies any restrictions). For example, to retrieve all the rows of table &lt;code&gt;weather&lt;/code&gt;, type:</source>
          <target state="translated">要从表中检索数据，请&lt;em&gt;查询&lt;/em&gt;表。SQL &lt;code&gt;SELECT&lt;/code&gt; 语句用于执行此操作。该语句分为一个选择列表（列出要返回的列的部分），一个表列表（列出从中检索数据的表的部分）和一个可选的限定条件（指定任何限制的部分） 。例如，要检索表 &lt;code&gt;weather&lt;/code&gt; 的所有行，请输入：</target>
        </trans-unit>
        <trans-unit id="7bfba777df1f29aa913bd5d40ce1d4c73c765650" translate="yes" xml:space="preserve">
          <source>To retrieve the available track segments, you need to use the &lt;code&gt;.key&lt;/code&gt; accessor operator for all the preceding JSON objects:</source>
          <target state="translated">要检索可用的轨道段，您需要对所有前面的JSON对象使用 &lt;code&gt;.key&lt;/code&gt; 访问器运算符：</target>
        </trans-unit>
        <trans-unit id="ae19836eec0ecd61d32d5ba96b2322d307b8b7c9" translate="yes" xml:space="preserve">
          <source>To retrieve the available track segments, you need to use the &lt;code&gt;.key&lt;/code&gt; accessor operator to descend through surrounding JSON objects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="522d3e3911dd6d630d42f4c9f3f4511ffe28f774" translate="yes" xml:space="preserve">
          <source>To retrieve the contents of an array, you typically use the &lt;code&gt;[*]&lt;/code&gt; operator. For example, the following path will return the location coordinates for all the available track segments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb967f785473e839c4078f1c39fcb9477a78913b" translate="yes" xml:space="preserve">
          <source>To return the coordinates of the first segment only, you can specify the corresponding subscript in the &lt;code&gt;[]&lt;/code&gt; accessor operator. Note that the SQL/JSON arrays are 0-relative:</source>
          <target state="translated">要仅返回第一段的坐标，可以在 &lt;code&gt;[]&lt;/code&gt; 访问运算符中指定相应的下标。请注意，SQL / JSON数组是相对于0的：</target>
        </trans-unit>
        <trans-unit id="2997dac29f70ddf8f3e7c83a1acb7272e5aecc0e" translate="yes" xml:space="preserve">
          <source>To return the coordinates of the first segment only, you can specify the corresponding subscript in the &lt;code&gt;[]&lt;/code&gt; accessor operator. Recall that JSON array indexes are 0-relative:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ff702ac9e947fb4cd3f752235dd9e8f46729035" translate="yes" xml:space="preserve">
          <source>To return to the default encoding:</source>
          <target state="translated">返回默认编码。</target>
        </trans-unit>
        <trans-unit id="39f7eef3c39aee4bb525459a86951007badf6cc0" translate="yes" xml:space="preserve">
          <source>To revoke a previously-granted privilege, use the fittingly named &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="406cc6a0a28c1612b545a71cb3737c23188fdb8b" translate="yes" xml:space="preserve">
          <source>To revoke a privilege, use the fittingly named &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; command:</source>
          <target state="translated">要撤消特权，请使用适当命名的&lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt;命令：</target>
        </trans-unit>
        <trans-unit id="e18502fe2468ae34b02daa8dc891d75789cf38d6" translate="yes" xml:space="preserve">
          <source>To roll back a prepared transaction, you must be either the same user that executed the transaction originally, or a superuser. But you do not have to be in the same session that executed the transaction.</source>
          <target state="translated">要回滚已准备好的事务,你必须是最初执行事务的同一个用户,或者是超级用户。但你不必在执行事务的同一个会话中。</target>
        </trans-unit>
        <trans-unit id="e4ea9597dfb8955018f00e4ee84fd5fc8eae4064" translate="yes" xml:space="preserve">
          <source>To search for a value in an array, each value must be checked. This can be done manually, if you know the size of the array. For example:</source>
          <target state="translated">要在数组中搜索一个值,必须检查每个值。如果你知道数组的大小,这可以手动完成。比如说</target>
        </trans-unit>
        <trans-unit id="69b97083ddc183a0945aabca7a025e7b75b30250" translate="yes" xml:space="preserve">
          <source>To send a notification you can also use the function &lt;code&gt;pg_notify(text, text)&lt;/code&gt;. The function takes the channel name as the first argument and the payload as the second. The function is much easier to use than the &lt;code&gt;NOTIFY&lt;/code&gt; command if you need to work with non-constant channel names and payloads.</source>
          <target state="translated">要发送通知，您还可以使用 &lt;code&gt;pg_notify(text, text)&lt;/code&gt; 函数。该函数将通道名称作为第一个参数，将有效负载作为第二个参数。如果需要使用非恒定通道名称和有效负载，则该功能比 &lt;code&gt;NOTIFY&lt;/code&gt; 命令更易于使用。</target>
        </trans-unit>
        <trans-unit id="0a86001d56e96cd630855718e6c84e4c20be116d" translate="yes" xml:space="preserve">
          <source>To set a new default for a column, use a command like:</source>
          <target state="translated">要为一列设置新的默认值,请使用类似命令。</target>
        </trans-unit>
        <trans-unit id="d61997ef9694eace869cea24bbcc67002c9d4dc7" translate="yes" xml:space="preserve">
          <source>To set a variable, use the psql meta-command &lt;code&gt;\set&lt;/code&gt;. For example,</source>
          <target state="translated">要设置变量，请使用psql元命令 &lt;code&gt;\set&lt;/code&gt; 。例如，</target>
        </trans-unit>
        <trans-unit id="1474ee12a3dc56b938508517724586f81f6e63ce" translate="yes" xml:space="preserve">
          <source>To set an element of an array constant to NULL, write &lt;code&gt;NULL&lt;/code&gt; for the element value. (Any upper- or lower-case variant of &lt;code&gt;NULL&lt;/code&gt; will do.) If you want an actual string value &amp;ldquo;NULL&amp;rdquo;, you must put double quotes around it.</source>
          <target state="translated">要将数组常量的元素设置为NULL，请为元素值写入 &lt;code&gt;NULL&lt;/code&gt; 。（任何大写或小写的 &lt;code&gt;NULL&lt;/code&gt; 变体都可以。）如果要使用实际的字符串值&amp;ldquo; NULL&amp;rdquo;，则必须在其前后加上双引号。</target>
        </trans-unit>
        <trans-unit id="b72ae8178b03bffc3e97e1ff9f2d6120eb29fe1d" translate="yes" xml:space="preserve">
          <source>To set the transaction isolation level of a transaction, use the command &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt;.</source>
          <target state="translated">要设置事务的事务隔离级别，请使用命令&lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4100879263231dfae5d8c1d12f7f89131b8b4c4d" translate="yes" xml:space="preserve">
          <source>To set up a group role, first create the role:</source>
          <target state="translated">要设置组角色,首先要创建角色。</target>
        </trans-unit>
        <trans-unit id="0840fa596df18f796bffaaea8cb71ad58fdfa8cf" translate="yes" xml:space="preserve">
          <source>To set up the standby server, restore the base backup taken from primary server (see &lt;a href=&quot;continuous-archiving#BACKUP-PITR-RECOVERY&quot;&gt;Section 25.3.4&lt;/a&gt;). Create a file &lt;code&gt;standby.signal&lt;/code&gt; in the standby's cluster data directory. Set &lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;restore_command&lt;/a&gt; to a simple command to copy files from the WAL archive. If you plan to have multiple standby servers for high availability purposes, make sure that &lt;code&gt;recovery_target_timeline&lt;/code&gt; is set to &lt;code&gt;latest&lt;/code&gt; (the default), to make the standby server follow the timeline change that occurs at failover to another standby.</source>
          <target state="translated">要设置备用服务器，请还原从主服务器获取的基本备份（请参阅&lt;a href=&quot;continuous-archiving#BACKUP-PITR-RECOVERY&quot;&gt;第25.3.4节&lt;/a&gt;）。在备用数据库的集群数据目录中创建一个文件 &lt;code&gt;standby.signal&lt;/code&gt; 。将&lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;restore_command&lt;/a&gt;设置为一个简单命令，以从WAL存档中复制文件。如果计划具有多个备用服务器以实现高可用性，请确保将 &lt;code&gt;recovery_target_timeline&lt;/code&gt; 设置为 &lt;code&gt;latest&lt;/code&gt; （默认值），以使备用服务器遵循故障转移到另一个备用服务器时发生的时间线更改。</target>
        </trans-unit>
        <trans-unit id="5849cdcb821c47fc2718617bba0084cf85489ef6" translate="yes" xml:space="preserve">
          <source>To show the current search path, use the following command:</source>
          <target state="translated">要显示当前的搜索路径,请使用以下命令。</target>
        </trans-unit>
        <trans-unit id="c7b88e1f0fb39dd04eb638f67e6c58bab151183a" translate="yes" xml:space="preserve">
          <source>To show the plan for a simple query on a table with a single &lt;code&gt;integer&lt;/code&gt; column and 10000 rows:</source>
          <target state="translated">要显示对具有单个 &lt;code&gt;integer&lt;/code&gt; 列和10000行的表进行简单查询的计划：</target>
        </trans-unit>
        <trans-unit id="290d88a25608fc889befd23db33e59b88bf74d38" translate="yes" xml:space="preserve">
          <source>To show the space used by TOAST tables, use a query like the following:</source>
          <target state="translated">要显示TOAST表使用的空间,使用类似下面的查询。</target>
        </trans-unit>
        <trans-unit id="eeb7477a4c4b89c5dfe00ff91f3aab61ad3c8fbd" translate="yes" xml:space="preserve">
          <source>To simplify typing, commands that consists of several words do not have to be quoted. Thus it is fine to type &lt;strong&gt;&lt;code&gt;\help alter table&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">为了简化键入，不必引用由几个单词组成的命令。因此可以键入&lt;strong&gt; &lt;code&gt;\help alter table&lt;/code&gt; &lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="a8d550c244dcf6d72fa7225070e337e07ebb8470" translate="yes" xml:space="preserve">
          <source>To solve this performance problem, PostgreSQL supports &lt;em&gt;index-only scans&lt;/em&gt;, which can answer queries from an index alone without any heap access. The basic idea is to return values directly out of each index entry instead of consulting the associated heap entry. There are two fundamental restrictions on when this method can be used:</source>
          <target state="translated">为了解决此性能问题，PostgreSQL支持&lt;em&gt;仅索引扫描&lt;/em&gt;，该&lt;em&gt;扫描&lt;/em&gt;可以仅从索引回答查询，而无需任何堆访问。基本思想是直接从每个索引条目中返回值，而不是查询关联的堆条目。何时可以使用此方法有两个基本限制：</target>
        </trans-unit>
        <trans-unit id="142d0651fdf015e04d576467b1aca4229d0b4cfb" translate="yes" xml:space="preserve">
          <source>To solve this problem, PostgreSQL allows a transaction to &lt;em&gt;export&lt;/em&gt; the snapshot it is using. As long as the exporting transaction remains open, other transactions can &lt;em&gt;import&lt;/em&gt; its snapshot, and thereby be guaranteed that they see exactly the same view of the database that the first transaction sees. But note that any database changes made by any one of these transactions remain invisible to the other transactions, as is usual for changes made by uncommitted transactions. So the transactions are synchronized with respect to pre-existing data, but act normally for changes they make themselves.</source>
          <target state="translated">为了解决此问题，PostgreSQL允许事务&lt;em&gt;导出&lt;/em&gt;其正在使用的快照。只要导出的事务保持打开状态，其他事务就可以&lt;em&gt;导入&lt;/em&gt;其快照，从而可以保证它们看到的数据库视图与第一个事务完全相同。但是请注意，由这些事务中的任何一个进行的任何数据库更改对于其他事务都是不可见的，这与未提交的事务进行的更改一样。因此，事务相对于预先存在的数据是同步的，但对于它们自己进行的更改通常会采取行动。</target>
        </trans-unit>
        <trans-unit id="e123382d05d38fbf63b38f935a0571d58e1f08cc" translate="yes" xml:space="preserve">
          <source>To specify a different event source name (see &lt;a href=&quot;runtime-config-logging#GUC-EVENT-SOURCE&quot;&gt;event_source&lt;/a&gt;), use the &lt;code&gt;/n&lt;/code&gt; and &lt;code&gt;/i&lt;/code&gt; options:</source>
          <target state="translated">要指定其他事件源名称（请参阅&lt;a href=&quot;runtime-config-logging#GUC-EVENT-SOURCE&quot;&gt;event_source&lt;/a&gt;），请使用 &lt;code&gt;/n&lt;/code&gt; 和 &lt;code&gt;/i&lt;/code&gt; 选项：</target>
        </trans-unit>
        <trans-unit id="565b2254b0db4b12b69a3f496fe0855d4e311ee0" translate="yes" xml:space="preserve">
          <source>To specify an upper-case or mixed-case name in &lt;code&gt;-t&lt;/code&gt; and related switches, you need to double-quote the name; else it will be folded to lower case (see &lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;Patterns&lt;/a&gt; below). But double quotes are special to the shell, so in turn they must be quoted. Thus, to dump a single table with a mixed-case name, you need something like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="333792e531c8f32efba6f6ddb4b9558b3b16db75" translate="yes" xml:space="preserve">
          <source>To specify an upper-case or mixed-case name in &lt;code&gt;-t&lt;/code&gt; and related switches, you need to double-quote the name; else it will be folded to lower case (see &lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;Patterns&lt;/a&gt;). But double quotes are special to the shell, so in turn they must be quoted. Thus, to dump a single table with a mixed-case name, you need something like</source>
          <target state="translated">要在 &lt;code&gt;-t&lt;/code&gt; 和相关开关中指定大写或大小写混合的名称，您需要将名称双引号；否则它将被折叠成小写（请参阅&lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;Patterns&lt;/a&gt;）。但是双引号对于shell来说是特殊的，因此反过来必须使用双引号。因此，要转储具有大小写混合名称的单个表，您需要</target>
        </trans-unit>
        <trans-unit id="b8a91bc31974f5e5387a73acf127cc171d44ea38" translate="yes" xml:space="preserve">
          <source>To specify which database server pg_dump should contact, use the command line options &lt;code&gt;-h host&lt;/code&gt; and &lt;code&gt;-p port&lt;/code&gt;. The default host is the local host or whatever your &lt;code&gt;PGHOST&lt;/code&gt; environment variable specifies. Similarly, the default port is indicated by the &lt;code&gt;PGPORT&lt;/code&gt; environment variable or, failing that, by the compiled-in default. (Conveniently, the server will normally have the same compiled-in default.)</source>
          <target state="translated">要指定应与哪个数据库服务器pg_dump联系，请使用命令行选项 &lt;code&gt;-h host&lt;/code&gt; 和 &lt;code&gt;-p port&lt;/code&gt; 。默认主机是本地主机或您的 &lt;code&gt;PGHOST&lt;/code&gt; 环境变量指定的主机。同样，默认端口由 &lt;code&gt;PGPORT&lt;/code&gt; 环境变量指示，否则，由编译后的默认指示。 （通常，服务器通常具有相同的内置默认值。）</target>
        </trans-unit>
        <trans-unit id="b8ff8afd5bb22ed648c2e1e515d2f8e282c556cb" translate="yes" xml:space="preserve">
          <source>To specify which rows are visible or modifiable according to a policy, an expression is required that returns a Boolean result. This expression will be evaluated for each row prior to any conditions or functions coming from the user's query. (The only exceptions to this rule are &lt;code&gt;leakproof&lt;/code&gt; functions, which are guaranteed to not leak information; the optimizer may choose to apply such functions ahead of the row-security check.) Rows for which the expression does not return &lt;code&gt;true&lt;/code&gt; will not be processed. Separate expressions may be specified to provide independent control over the rows which are visible and the rows which are allowed to be modified. Policy expressions are run as part of the query and with the privileges of the user running the query, although security-definer functions can be used to access data not available to the calling user.</source>
          <target state="translated">要指定根据策略哪些行是可见的或可修改的，需要一个返回布尔结果的表达式。在用户查询产生任何条件或函数之前，将为每一行评估该表达式。 （此规则的唯一例外是 &lt;code&gt;leakproof&lt;/code&gt; 函数，保证不会泄漏信息；优化器可以选择在行安全检查之前应用此类函数。）表达式不返回 &lt;code&gt;true&lt;/code&gt; 的行将不会被处理。可以指定单独的表达式以提供对可见行和允许修改行的独立控制。策略表达式作为查询的一部分运行，并具有运行查询的用户的特权，尽管安全定义器功能可用于访问主叫用户不可用的数据。</target>
        </trans-unit>
        <trans-unit id="d640746b2c70f04616145411ddf1ea54e8f0eff4" translate="yes" xml:space="preserve">
          <source>To start &lt;code&gt;postgres&lt;/code&gt; in the background using default values, type:</source>
          <target state="translated">要使用默认值在后台启动 &lt;code&gt;postgres&lt;/code&gt; ，请输入：</target>
        </trans-unit>
        <trans-unit id="101c9345ec9b8869dda1a4c2ec2f4ff5869b5099" translate="yes" xml:space="preserve">
          <source>To start &lt;code&gt;postgres&lt;/code&gt; with a specific port, e.g. 1234:</source>
          <target state="translated">要使用特定端口（例如1234）启动 &lt;code&gt;postgres&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0d1fa6d44b3018cfb38f5330bc5f7830f724bd55" translate="yes" xml:space="preserve">
          <source>To start &lt;code&gt;postgres&lt;/code&gt; with a specific port, e.g., 1234:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f290a7625948bd090c0e63e75ca4290799de7fe3" translate="yes" xml:space="preserve">
          <source>To start a single-user mode server, use a command like</source>
          <target state="translated">要启动单用户模式的服务器,请使用以下命令,如</target>
        </trans-unit>
        <trans-unit id="d719f25eade71e1fabc96df0f987f16d1127fb5e" translate="yes" xml:space="preserve">
          <source>To start in SSL mode, files containing the server certificate and private key must exist. By default, these files are expected to be named &lt;code&gt;server.crt&lt;/code&gt; and &lt;code&gt;server.key&lt;/code&gt;, respectively, in the server's data directory, but other names and locations can be specified using the configuration parameters &lt;a href=&quot;runtime-config-connection#GUC-SSL-CERT-FILE&quot;&gt;ssl_cert_file&lt;/a&gt; and &lt;a href=&quot;runtime-config-connection#GUC-SSL-KEY-FILE&quot;&gt;ssl_key_file&lt;/a&gt;.</source>
          <target state="translated">要以SSL模式启动，必须​​存在包含服务器证书和私钥的文件。默认情况下，这些文件应该在服务器的数据目录中分别命名为 &lt;code&gt;server.crt&lt;/code&gt; 和 &lt;code&gt;server.key&lt;/code&gt; ，但是可以使用配置参数&lt;a href=&quot;runtime-config-connection#GUC-SSL-CERT-FILE&quot;&gt;ssl_cert_file&lt;/a&gt;和&lt;a href=&quot;runtime-config-connection#GUC-SSL-KEY-FILE&quot;&gt;ssl_key_file&lt;/a&gt;来指定其他名称和位置。</target>
        </trans-unit>
        <trans-unit id="0d7e48565791a62e0096773265d70badc454279d" translate="yes" xml:space="preserve">
          <source>To start the server in standby mode, create a file called &lt;code&gt;standby.signal&lt;/code&gt; in the data directory. The server will enter recovery and will not stop recovery when the end of archived WAL is reached, but will keep trying to continue recovery by connecting to the sending server as specified by the &lt;code&gt;primary_conninfo&lt;/code&gt; setting and/or by fetching new WAL segments using &lt;code&gt;restore_command&lt;/code&gt;. For this mode, the parameters from this section and &lt;a href=&quot;runtime-config-replication#RUNTIME-CONFIG-REPLICATION-STANDBY&quot;&gt;Section 19.6.3&lt;/a&gt; are of interest. Parameters from &lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-RECOVERY-TARGET&quot;&gt;Section 19.5.5&lt;/a&gt; will also be applied but are typically not useful in this mode.</source>
          <target state="translated">要以待机模式启动服务器， &lt;code&gt;standby.signal&lt;/code&gt; 在数据目录中创建一个名为standby.signal的文件。到达已归档的WAL结束时，服务器将进入恢复状态，并且不会停止恢复，但是将通过 &lt;code&gt;primary_conninfo&lt;/code&gt; 设置指定的连接到发送服务器和/或通过使用 &lt;code&gt;restore_command&lt;/code&gt; 获取新的WAL段来继续尝试继续恢复。对于此模式，需要注意本节和&lt;a href=&quot;runtime-config-replication#RUNTIME-CONFIG-REPLICATION-STANDBY&quot;&gt;第19.6.3&lt;/a&gt;节中的参数。&lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-RECOVERY-TARGET&quot;&gt;第19.5.5节中的&lt;/a&gt;参数也将应用，但通常在此模式下不可用。</target>
        </trans-unit>
        <trans-unit id="58559fc6e49f271c8ef253d540e88016fc097dd2" translate="yes" xml:space="preserve">
          <source>To start the server in targeted recovery mode, create a file called &lt;code&gt;recovery.signal&lt;/code&gt; in the data directory. If both &lt;code&gt;standby.signal&lt;/code&gt; and &lt;code&gt;recovery.signal&lt;/code&gt; files are created, standby mode takes precedence. Targeted recovery mode ends when the archived WAL is fully replayed, or when &lt;code&gt;recovery_target&lt;/code&gt; is reached. In this mode, the parameters from both this section and &lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-RECOVERY-TARGET&quot;&gt;Section 19.5.5&lt;/a&gt; will be used.</source>
          <target state="translated">要以目标恢复模式启动服务器，请在数据目录中创建一个名为 &lt;code&gt;recovery.signal&lt;/code&gt; 的文件。如果同时创建了 &lt;code&gt;standby.signal&lt;/code&gt; 和 &lt;code&gt;recovery.signal&lt;/code&gt; 文件，则待机模式优先。当完全重播已归档的WAL或达到 &lt;code&gt;recovery_target&lt;/code&gt; 时，目标恢复模式结束。在这种模式下，将使用本节和&lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-RECOVERY-TARGET&quot;&gt;19.5.5&lt;/a&gt;节中的参数。</target>
        </trans-unit>
        <trans-unit id="9d341372ce0cfe667939ee30d204c0837e61558e" translate="yes" xml:space="preserve">
          <source>To start the server using port 5433, and running without &lt;code&gt;fsync&lt;/code&gt;, use:</source>
          <target state="translated">要使用端口5433启动服务器并在没有 &lt;code&gt;fsync&lt;/code&gt; 的情况下运行，请使用：</target>
        </trans-unit>
        <trans-unit id="741786fb73cdee8a94bd2c27689a09674c4f86b0" translate="yes" xml:space="preserve">
          <source>To start the server, waiting until the server is accepting connections:</source>
          <target state="translated">要启动服务器,等到服务器接受连接。</target>
        </trans-unit>
        <trans-unit id="1e232c4fd74a8cef6ce964e0f028fd1b8e4b0c9b" translate="yes" xml:space="preserve">
          <source>To stop the server, use:</source>
          <target state="translated">要停止服务器,使用。</target>
        </trans-unit>
        <trans-unit id="3e14a268ee248e30a81dcc736a7cb520ff381afb" translate="yes" xml:space="preserve">
          <source>To stream the write-ahead log from the server at &lt;code&gt;mydbserver&lt;/code&gt; and store it in the local directory &lt;code&gt;/usr/local/pgsql/archive&lt;/code&gt;:</source>
          <target state="translated">要从 &lt;code&gt;mydbserver&lt;/code&gt; 的服务器流式传输预写日志并将其存储在本地目录 &lt;code&gt;/usr/local/pgsql/archive&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="0c30744e41f4e0393724c62af8eb916c4e9f5d86" translate="yes" xml:space="preserve">
          <source>To sum the column &lt;code&gt;len&lt;/code&gt; of all films and group the results by &lt;code&gt;kind&lt;/code&gt;:</source>
          <target state="translated">总结所有电影的 &lt;code&gt;len&lt;/code&gt; 列，并将结果按 &lt;code&gt;kind&lt;/code&gt; 分组：</target>
        </trans-unit>
        <trans-unit id="a6a50b5a600cffd4f7b634f4dde62436d9843ce3" translate="yes" xml:space="preserve">
          <source>To sum the column &lt;code&gt;len&lt;/code&gt; of all films, group the results by &lt;code&gt;kind&lt;/code&gt; and show those group totals that are less than 5 hours:</source>
          <target state="translated">综上所述列 &lt;code&gt;len&lt;/code&gt; 个所有片，组的结果由 &lt;code&gt;kind&lt;/code&gt; 和显示这些组总计是少于5小时：</target>
        </trans-unit>
        <trans-unit id="1a9fccec8e53d2c310f94aa58faf4ad93d29d232" translate="yes" xml:space="preserve">
          <source>To support &amp;ldquo;partial match&amp;rdquo; queries, an operator class must provide the &lt;code&gt;comparePartial&lt;/code&gt; method, and its &lt;code&gt;extractQuery&lt;/code&gt; method must set the &lt;code&gt;pmatch&lt;/code&gt; parameter when a partial-match query is encountered. See &lt;a href=&quot;gin-implementation#GIN-PARTIAL-MATCH&quot;&gt;Section 66.4.2&lt;/a&gt; for details.</source>
          <target state="translated">为了支持&amp;ldquo;部分匹配&amp;rdquo;查询，操作员类必须提供 &lt;code&gt;comparePartial&lt;/code&gt; 方法，并且在遇到部分匹配查询时，其 &lt;code&gt;extractQuery&lt;/code&gt; 方法必须设置 &lt;code&gt;pmatch&lt;/code&gt; 参数。有关详细信息，请参见&lt;a href=&quot;gin-implementation#GIN-PARTIAL-MATCH&quot;&gt;第66.4.2节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aca3788124b57b993c2721a04dc97e7cfe9aa1d6" translate="yes" xml:space="preserve">
          <source>To support matching of rows which include elements without a default B-tree operator class, the following operators are defined for composite type comparison: &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;*&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;*&amp;lt;&lt;/code&gt;, &lt;code&gt;*&amp;lt;=&lt;/code&gt;, &lt;code&gt;*&amp;gt;&lt;/code&gt;, and &lt;code&gt;*&amp;gt;=&lt;/code&gt;. These operators compare the internal binary representation of the two rows. Two rows might have a different binary representation even though comparisons of the two rows with the equality operator is true. The ordering of rows under these comparison operators is deterministic but not otherwise meaningful. These operators are used internally for materialized views and might be useful for other specialized purposes such as replication and B-Tree deduplication (see &lt;a href=&quot;btree-implementation#BTREE-DEDUPLICATION&quot;&gt;Section 63.4.2&lt;/a&gt;). They are not intended to be generally useful for writing queries, though.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c766280bc71ea6c99fe469d91b62dcecd981191" translate="yes" xml:space="preserve">
          <source>To support matching of rows which include elements without a default B-tree operator class, the following operators are defined for composite type comparison: &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;*&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;*&amp;lt;&lt;/code&gt;, &lt;code&gt;*&amp;lt;=&lt;/code&gt;, &lt;code&gt;*&amp;gt;&lt;/code&gt;, and &lt;code&gt;*&amp;gt;=&lt;/code&gt;. These operators compare the internal binary representation of the two rows. Two rows might have a different binary representation even though comparisons of the two rows with the equality operator is true. The ordering of rows under these comparison operators is deterministic but not otherwise meaningful. These operators are used internally for materialized views and might be useful for other specialized purposes such as replication but are not intended to be generally useful for writing queries.</source>
          <target state="translated">为了支持包含没有默认B-tree运算符类的元素的行的匹配，为复合类型比较定义了以下运算符： &lt;code&gt;*=&lt;/code&gt; ， &lt;code&gt;*&amp;lt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;*&amp;lt;&lt;/code&gt; ， &lt;code&gt;*&amp;lt;=&lt;/code&gt; ， &lt;code&gt;*&amp;gt;&lt;/code&gt; 和 &lt;code&gt;*&amp;gt;=&lt;/code&gt; 。这些运算符比较两行的内部二进制表示形式。即使两行与相等运算符的比较为真，两行​​也可能具有不同的二进制表示形式。这些比较运算符下的行顺序是确定性的，但没有其他意义。这些运算符在内部用于物化视图，并且可能对其他特殊目的（例如复制）有用，但通常不适用于编写查询。</target>
        </trans-unit>
        <trans-unit id="78257dbeaf1e3faf2c5d4978a0aec796a742cc0e" translate="yes" xml:space="preserve">
          <source>To terminate an individual session while allowing other sessions to continue, use &lt;code&gt;pg_terminate_backend()&lt;/code&gt; (see &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-SIGNAL-TABLE&quot;&gt;Table 9.83&lt;/a&gt;) or send a SIGTERM signal to the child process associated with the session.</source>
          <target state="translated">要在允许其他会话继续进行的同时终止单个会话，请使用 &lt;code&gt;pg_terminate_backend()&lt;/code&gt; （&lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-SIGNAL-TABLE&quot;&gt;参见表9.83&lt;/a&gt;）或向与该会话关联的子进程发送SIGTERM信号。</target>
        </trans-unit>
        <trans-unit id="7094d9589b47d1412c9f6e48415db4d099361388" translate="yes" xml:space="preserve">
          <source>To terminate an individual session while allowing other sessions to continue, use &lt;code&gt;pg_terminate_backend()&lt;/code&gt; (see &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-SIGNAL-TABLE&quot;&gt;Table 9.84&lt;/a&gt;) or send a SIGTERM signal to the child process associated with the session.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b948441d5404b9b545e1ffba5fe2679215c93a3d" translate="yes" xml:space="preserve">
          <source>To terminate the &lt;code&gt;postgres&lt;/code&gt; server normally, the signals &lt;code&gt;SIGTERM&lt;/code&gt;, &lt;code&gt;SIGINT&lt;/code&gt;, or &lt;code&gt;SIGQUIT&lt;/code&gt; can be used. The first will wait for all clients to terminate before quitting, the second will forcefully disconnect all clients, and the third will quit immediately without proper shutdown, resulting in a recovery run during restart.</source>
          <target state="translated">要正常终止 &lt;code&gt;postgres&lt;/code&gt; 服务器，可以使用信号 &lt;code&gt;SIGTERM&lt;/code&gt; ， &lt;code&gt;SIGINT&lt;/code&gt; 或 &lt;code&gt;SIGQUIT&lt;/code&gt; 。第一个将在退出之前等待所有客户端终止，第二个将强行断开所有客户端的连接，第三个将在没有适当关闭的情况下立即退出，从而导致在重新启动期间进行恢复。</target>
        </trans-unit>
        <trans-unit id="bff9e4861d994fa404b9d306224e5e46521976c6" translate="yes" xml:space="preserve">
          <source>To test the dictionary, you can try</source>
          <target state="translated">要测试字典,你可以尝试</target>
        </trans-unit>
        <trans-unit id="f7848817fe1c28c6bfbe8e65d2117ae56c0839fe" translate="yes" xml:space="preserve">
          <source>To test the dictionary, you can try:</source>
          <target state="translated">要测试字典,你可以试试。</target>
        </trans-unit>
        <trans-unit id="c037e68aa2a278c5321043e5bd649588e1ed1409" translate="yes" xml:space="preserve">
          <source>To that end, SQL allows you to define constraints on columns and tables. Constraints give you as much control over the data in your tables as you wish. If a user attempts to store data in a column that would violate a constraint, an error is raised. This applies even if the value came from the default value definition.</source>
          <target state="translated">为此,SQL允许你对列和表定义约束。约束可以让你随心所欲地控制表中的数据。如果用户试图在违反约束的列中存储数据,就会出现错误。即使该值来自默认值定义,这也适用。</target>
        </trans-unit>
        <trans-unit id="1cc21a302cf460d16fd25ba3a4c82bca11c0140f" translate="yes" xml:space="preserve">
          <source>To the database server it will then look as though you are really user &lt;code&gt;joe&lt;/code&gt; on host &lt;code&gt;foo.com&lt;/code&gt; connecting to &lt;code&gt;localhost&lt;/code&gt; in that context, and it will use whatever authentication procedure was configured for connections from this user and host. Note that the server will not think the connection is SSL-encrypted, since in fact it is not encrypted between the SSH server and the PostgreSQL server. This should not pose any extra security risk as long as they are on the same machine.</source>
          <target state="translated">对于数据库服务器，在该上下文中看起来好像您真的是主机 &lt;code&gt;foo.com&lt;/code&gt; 上的用户 &lt;code&gt;joe&lt;/code&gt; 在连接到 &lt;code&gt;localhost&lt;/code&gt; ，并且它将使用为该用户和主机的连接配置的任何身份验证过程。请注意，服务器不会认为该连接是SSL加密的，因为实际上在SSH服务器和PostgreSQL服务器之间未对连接进行加密。只要它们在同一台计算机上，就不会造成任何额外的安全风险。</target>
        </trans-unit>
        <trans-unit id="d272ad6e12f47f5e40efbd76a7ae268c798205f5" translate="yes" xml:space="preserve">
          <source>To the database server it will then look as though you are user &lt;code&gt;joe&lt;/code&gt; on host &lt;code&gt;foo.com&lt;/code&gt; connecting to the &lt;code&gt;localhost&lt;/code&gt; bind address, and it will use whatever authentication procedure was configured for connections by that user to that bind address. Note that the server will not think the connection is SSL-encrypted, since in fact it is not encrypted between the SSH server and the PostgreSQL server. This should not pose any extra security risk because they are on the same machine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27fa29cd778cfa5bac13b40048f336e41ba246ff" translate="yes" xml:space="preserve">
          <source>To track the age of the oldest unfrozen XIDs in a database, &lt;code&gt;VACUUM&lt;/code&gt; stores XID statistics in the system tables &lt;code&gt;pg_class&lt;/code&gt; and &lt;code&gt;pg_database&lt;/code&gt;. In particular, the &lt;code&gt;relfrozenxid&lt;/code&gt; column of a table's &lt;code&gt;pg_class&lt;/code&gt; row contains the freeze cutoff XID that was used by the last aggressive &lt;code&gt;VACUUM&lt;/code&gt; for that table. All rows inserted by transactions with XIDs older than this cutoff XID are guaranteed to have been frozen. Similarly, the &lt;code&gt;datfrozenxid&lt;/code&gt; column of a database's &lt;code&gt;pg_database&lt;/code&gt; row is a lower bound on the unfrozen XIDs appearing in that database &amp;mdash; it is just the minimum of the per-table &lt;code&gt;relfrozenxid&lt;/code&gt; values within the database. A convenient way to examine this information is to execute queries such as:</source>
          <target state="translated">为了跟踪数据库中最老的未冻结XID 的年龄， &lt;code&gt;VACUUM&lt;/code&gt; 将XID统计信息存储在系统表 &lt;code&gt;pg_class&lt;/code&gt; 和 &lt;code&gt;pg_database&lt;/code&gt; 中。特别是，表 &lt;code&gt;pg_class&lt;/code&gt; 行的 &lt;code&gt;relfrozenxid&lt;/code&gt; 列包含该表的最后主动 &lt;code&gt;VACUUM&lt;/code&gt; 使用的冻结截止XID 。 XID早于该截止XID的事务所插入的所有行都将被冻结。同样，数据库 &lt;code&gt;pg_database&lt;/code&gt; 行的 &lt;code&gt;datfrozenxid&lt;/code&gt; 列是该数据库中出现的未冻结XID的下限-这只是每表 &lt;code&gt;relfrozenxid&lt;/code&gt; 的最小值数据库中的值。检查此信息的便捷方法是执行查询，例如：</target>
        </trans-unit>
        <trans-unit id="bec719f5a6615a3436f6843fbf1b1db8f209ea62" translate="yes" xml:space="preserve">
          <source>To trigger failover of a log-shipping standby server, run &lt;code&gt;pg_ctl promote&lt;/code&gt;, call &lt;code&gt;pg_promote()&lt;/code&gt;, or create a trigger file with the file name and path specified by the &lt;code&gt;promote_trigger_file&lt;/code&gt;. If you're planning to use &lt;code&gt;pg_ctl promote&lt;/code&gt; or to call &lt;code&gt;pg_promote()&lt;/code&gt; to fail over, &lt;code&gt;promote_trigger_file&lt;/code&gt; is not required. If you're setting up the reporting servers that are only used to offload read-only queries from the primary, not for high availability purposes, you don't need to promote it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab93659339e52adb4a11b32e33a244aa5b607ece" translate="yes" xml:space="preserve">
          <source>To trigger failover of a log-shipping standby server, run &lt;code&gt;pg_ctl promote&lt;/code&gt;, call &lt;code&gt;pg_promote&lt;/code&gt;, or create a trigger file with the file name and path specified by the &lt;code&gt;promote_trigger_file&lt;/code&gt;. If you're planning to use &lt;code&gt;pg_ctl promote&lt;/code&gt; or to call &lt;code&gt;pg_promote&lt;/code&gt; to fail over, &lt;code&gt;promote_trigger_file&lt;/code&gt; is not required. If you're setting up the reporting servers that are only used to offload read-only queries from the primary, not for high availability purposes, you don't need to promote it.</source>
          <target state="translated">要触发日志传送备用服务器的故障转移，请运行 &lt;code&gt;pg_ctl promote&lt;/code&gt; &lt;code&gt;pg_promote&lt;/code&gt; ，调用pg_promote，或者使用文件的名称和路径创建一个触发文件，该文件名和路径由 &lt;code&gt;promote_trigger_file&lt;/code&gt; 指定。如果您打算使用 &lt;code&gt;pg_ctl promote&lt;/code&gt; &lt;code&gt;pg_promote&lt;/code&gt; 或调用pg_promote进行故障转移，则不需要 &lt;code&gt;promote_trigger_file&lt;/code&gt; 。如果要设置仅用于从主服务器上卸载只读查询（而不是出于高可用性目的）的报表服务器，则无需升级它。</target>
        </trans-unit>
        <trans-unit id="8afd9598c39f6e70f137c025d2dd4395fe84fd38" translate="yes" xml:space="preserve">
          <source>To undo the effects of the commands executed after &lt;code&gt;my_savepoint&lt;/code&gt; was established:</source>
          <target state="translated">要撤消在建立 &lt;code&gt;my_savepoint&lt;/code&gt; 之后执行的命令的影响：</target>
        </trans-unit>
        <trans-unit id="fdbbd3b7380f7c99f49bcfa3a98c5897db3e04c3" translate="yes" xml:space="preserve">
          <source>To unregister the event log library from the operating system, issue this command:</source>
          <target state="translated">要从操作系统中取消注册事件日志库,请发出此命令。</target>
        </trans-unit>
        <trans-unit id="04ca9b3d12432d00b33dc0196874addb1efae8ee" translate="yes" xml:space="preserve">
          <source>To update data statistics used by the PostgreSQL query planner.</source>
          <target state="translated">更新PostgreSQL查询计划器使用的数据统计。</target>
        </trans-unit>
        <trans-unit id="17b36c6a109313b445886e7e15a5a71d21fc608f" translate="yes" xml:space="preserve">
          <source>To update existing rows, use the &lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt; command. This requires three pieces of information:</source>
          <target state="translated">要更新现有行，请使用&lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt;命令。这需要三项信息：</target>
        </trans-unit>
        <trans-unit id="bfdb73ad446ce465aedfcde295a04d6e546563ff" translate="yes" xml:space="preserve">
          <source>To update the &lt;code&gt;hstore&lt;/code&gt; extension to version 2.0:</source>
          <target state="translated">要将 &lt;code&gt;hstore&lt;/code&gt; 扩展更新到版本2.0：</target>
        </trans-unit>
        <trans-unit id="5c75aa506204ac6f6a642540af590f22a822261f" translate="yes" xml:space="preserve">
          <source>To update the visibility map, which speeds up &lt;a href=&quot;indexes-index-only-scans&quot;&gt;index-only scans&lt;/a&gt;.</source>
          <target state="translated">要更新可见性图，这将加速&lt;a href=&quot;indexes-index-only-scans&quot;&gt;仅索引扫描&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d9d6d4049d4d6f7a80e714c7b5defc7ca6ffbb75" translate="yes" xml:space="preserve">
          <source>To upgrade an existing installation from &lt;code&gt;md5&lt;/code&gt; to &lt;code&gt;scram-sha-256&lt;/code&gt;, after having ensured that all client libraries in use are new enough to support SCRAM, set &lt;code&gt;password_encryption = 'scram-sha-256'&lt;/code&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;, make all users set new passwords, and change the authentication method specifications in &lt;code&gt;pg_hba.conf&lt;/code&gt; to &lt;code&gt;scram-sha-256&lt;/code&gt;.</source>
          <target state="translated">要将现有安装从 &lt;code&gt;md5&lt;/code&gt; 升级到 &lt;code&gt;scram-sha-256&lt;/code&gt; ，请确保已使用的所有客户端库都足够新以支持SCRAM，然后在 &lt;code&gt;postgresql.conf&lt;/code&gt; 中设置 &lt;code&gt;password_encryption = 'scram-sha-256'&lt;/code&gt; ，使所有用户均设置为new密码，并将 &lt;code&gt;pg_hba.conf&lt;/code&gt; 中的身份验证方法规范更改为 &lt;code&gt;scram-sha-256&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5c1dafd2ac169280b07d90746edddfeb0fb7e3f0" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;ALTER POLICY&lt;/code&gt;, you must own the table that the policy applies to.</source>
          <target state="translated">要使用 &lt;code&gt;ALTER POLICY&lt;/code&gt; ，您必须拥有该策略适用的表。</target>
        </trans-unit>
        <trans-unit id="8f6f185d569782026545f1b03aa2b8da54e54fce" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;ALTER RULE&lt;/code&gt;, you must own the table or view that the rule applies to.</source>
          <target state="translated">要使用 &lt;code&gt;ALTER RULE&lt;/code&gt; ，您必须拥有该规则适用的表或视图。</target>
        </trans-unit>
        <trans-unit id="66f7c52e4029da55c8222ce24959b959b971e824" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;IMPORT FOREIGN SCHEMA&lt;/code&gt;, the user must have &lt;code&gt;USAGE&lt;/code&gt; privilege on the foreign server, as well as &lt;code&gt;CREATE&lt;/code&gt; privilege on the target schema.</source>
          <target state="translated">要使用 &lt;code&gt;IMPORT FOREIGN SCHEMA&lt;/code&gt; ，用户必须在外部服务器上具有 &lt;code&gt;USAGE&lt;/code&gt; 特权，并在目标架构上具有 &lt;code&gt;CREATE&lt;/code&gt; 特权。</target>
        </trans-unit>
        <trans-unit id="530dbd614178074a579a490a0ab956d80ef8434a" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;ORDINALITY&lt;/code&gt; together with a column definition list, you must use the &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; syntax and put the column definition list inside &lt;code&gt;ROWS FROM( ... )&lt;/code&gt;.</source>
          <target state="translated">要将 &lt;code&gt;ORDINALITY&lt;/code&gt; 与列定义列表一起使用，必须使用 &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; 语法并将列定义列表放入 &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ca1d65da43222b484ff3cb107702a15116b7a77" translate="yes" xml:space="preserve">
          <source>To use BSD Authentication, the PostgreSQL user account (that is, the operating system user running the server) must first be added to the &lt;code&gt;auth&lt;/code&gt; group. The &lt;code&gt;auth&lt;/code&gt; group exists by default on OpenBSD systems.</source>
          <target state="translated">要使用BSD身份验证，必须首先将PostgreSQL用户帐户（即运行服务器的操作系统用户）添加到 &lt;code&gt;auth&lt;/code&gt; 组中。该 &lt;code&gt;auth&lt;/code&gt; 组默认情况下在OpenBSD系统存在。</target>
        </trans-unit>
        <trans-unit id="624d53b3d98397bc183e4f4a83d89ad1b366e0d6" translate="yes" xml:space="preserve">
          <source>To use a different policy for rows that are being added to the table compared to those rows that are visible, multiple policies can be combined. This pair of policies would allow all users to view all rows in the &lt;code&gt;users&lt;/code&gt; table, but only modify their own:</source>
          <target state="translated">要对要添加到表中的行使用与可见行相比不同的策略，可以组合多个策略。这对策略将允许所有用户查看 &lt;code&gt;users&lt;/code&gt; 表中的所有行，但只能修改自己的行：</target>
        </trans-unit>
        <trans-unit id="b5918c2e1e45dcb5d119151af6621e2293acc38e" translate="yes" xml:space="preserve">
          <source>To use cascading replication, set up the cascading standby so that it can accept replication connections (that is, set &lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY&quot;&gt;hot_standby&lt;/a&gt;, and configure &lt;a href=&quot;auth-pg-hba-conf&quot;&gt;host-based authentication&lt;/a&gt;). You will also need to set &lt;code&gt;primary_conninfo&lt;/code&gt; in the downstream standby to point to the cascading standby.</source>
          <target state="translated">要使用级联复制，请设置级联备用数据库，以便它可以接受复制连接（即，设置&lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt;和&lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY&quot;&gt;hot_standby&lt;/a&gt;，并配置&lt;a href=&quot;auth-pg-hba-conf&quot;&gt;基于主机的身份验证&lt;/a&gt;）。您还需要在下游备用数据库中设置 &lt;code&gt;primary_conninfo&lt;/code&gt; 以指向级联备用数据库。</target>
        </trans-unit>
        <trans-unit id="204c9fc68f0716e2f79b30bbdabc1054f228c62c" translate="yes" xml:space="preserve">
          <source>To use colorized output, set the environment variable &lt;code&gt;PG_COLOR&lt;/code&gt; as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e28d80b37aa18075f5d4cc483ffa5b0226809b8f" translate="yes" xml:space="preserve">
          <source>To use declarative partitioning in this case, use the following steps:</source>
          <target state="translated">要在这种情况下使用声明式分区,请使用以下步骤。</target>
        </trans-unit>
        <trans-unit id="c24fdd930cccd16791dba8614e06b7437b950109" translate="yes" xml:space="preserve">
          <source>To use pg_config, supply one or more of the following options:</source>
          <target state="translated">要使用pg_config,请提供以下一个或多个选项。</target>
        </trans-unit>
        <trans-unit id="8b164c8911c184b1eed541e609fde5b54cf0537e" translate="yes" xml:space="preserve">
          <source>To use streaming replication, set up a file-based log-shipping standby server as described in &lt;a href=&quot;warm-standby&quot;&gt;Section 26.2&lt;/a&gt;. The step that turns a file-based log-shipping standby into streaming replication standby is setting the &lt;code&gt;primary_conninfo&lt;/code&gt; setting to point to the primary server. Set &lt;a href=&quot;runtime-config-connection#GUC-LISTEN-ADDRESSES&quot;&gt;listen_addresses&lt;/a&gt; and authentication options (see &lt;code&gt;pg_hba.conf&lt;/code&gt;) on the primary so that the standby server can connect to the &lt;code&gt;replication&lt;/code&gt; pseudo-database on the primary server (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-AUTHENTICATION&quot;&gt;Section 26.2.5.1&lt;/a&gt;).</source>
          <target state="translated">要使用流复制，请按照&lt;a href=&quot;warm-standby&quot;&gt;第26.2节中的说明&lt;/a&gt;设置基于文件的日志传送备用服务器。将基于文件的日志传送备用数据库转换为流复制备用数据库的步骤是将 &lt;code&gt;primary_conninfo&lt;/code&gt; 设置设置为指向主服务器。在主服务器上设置&lt;a href=&quot;runtime-config-connection#GUC-LISTEN-ADDRESSES&quot;&gt;listen_addresses&lt;/a&gt;和身份验证选项（请参阅 &lt;code&gt;pg_hba.conf&lt;/code&gt; ），以便备用服务器可以连接到主服务器上的 &lt;code&gt;replication&lt;/code&gt; 伪数据库（请参见&lt;a href=&quot;warm-standby#STREAMING-REPLICATION-AUTHENTICATION&quot;&gt;26.2.5.1节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d41a57b888d94c07385a12eb346d75263c49a383" translate="yes" xml:space="preserve">
          <source>To use this facility, just write an &lt;code&gt;array_type_oid =&amp;gt; nnnn&lt;/code&gt; metadata field in the scalar type's &lt;code&gt;pg_type&lt;/code&gt; entry, specifying the OID to use for the array type. You may then omit the &lt;code&gt;typarray&lt;/code&gt; field, since it will be filled automatically with that OID.</source>
          <target state="translated">要使用此功能，只需在标量类型的 &lt;code&gt;pg_type&lt;/code&gt; 条目中写入 &lt;code&gt;array_type_oid =&amp;gt; nnnn&lt;/code&gt; 元数据字段，并指定要用于数组类型的OID。然后，您可以省略 &lt;code&gt;typarray&lt;/code&gt; 字段，因为它将使用该OID自动填充。</target>
        </trans-unit>
        <trans-unit id="ed41221f827f590a776bd2d7b32a2a20c13339d7" translate="yes" xml:space="preserve">
          <source>To use this module, you must include &lt;code&gt;sepgsql&lt;/code&gt; in the &lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt; parameter in &lt;code&gt;postgresql.conf&lt;/code&gt;. The module will not function correctly if loaded in any other manner. Once the module is loaded, you should execute &lt;code&gt;sepgsql.sql&lt;/code&gt; in each database. This will install functions needed for security label management, and assign initial security labels.</source>
          <target state="translated">要使用此模块，必须在 &lt;code&gt;postgresql.conf&lt;/code&gt; 的&lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt;参数中包含 &lt;code&gt;sepgsql&lt;/code&gt; 。如果以任何其他方式加载，模块将无法正常运行。加载模块后，应在每个数据库中执行 &lt;code&gt;sepgsql.sql&lt;/code&gt; 。这将安装安全标签管理所需的功能，并分配初始安全标签。</target>
        </trans-unit>
        <trans-unit id="5fe488ba1b87ef7cbcb5c901cbf44cb2fcec20d8" translate="yes" xml:space="preserve">
          <source>To use, create a &lt;code&gt;BEFORE INSERT&lt;/code&gt; (or optionally &lt;code&gt;BEFORE INSERT OR UPDATE&lt;/code&gt;) trigger using this function. Specify two trigger arguments: the name of the integer column to be modified, and the name of the sequence object that will supply values. (Actually, you can specify any number of pairs of such names, if you'd like to update more than one autoincrementing column.)</source>
          <target state="translated">要使用该函数，请创建一个 &lt;code&gt;BEFORE INSERT&lt;/code&gt; （或可选的 &lt;code&gt;BEFORE INSERT OR UPDATE&lt;/code&gt; ）触发器。指定两个触发器参数：要修改的整数列的名称，以及将提供值的序列对象的名称。（实际上，如果您要更新多个自动递增列，则可以指定任意数量的成对名称。）</target>
        </trans-unit>
        <trans-unit id="b06330e3e364688bdf4415b2dee7148b99079ba6" translate="yes" xml:space="preserve">
          <source>To use, create a &lt;code&gt;BEFORE INSERT&lt;/code&gt; and/or &lt;code&gt;UPDATE&lt;/code&gt; trigger using this function. Specify a single trigger argument: the name of the text column to be modified.</source>
          <target state="translated">要使用此功能，请创建一个 &lt;code&gt;BEFORE INSERT&lt;/code&gt; 和/或 &lt;code&gt;UPDATE&lt;/code&gt; 触发器。指定一个触发器参数：要修改的文本列的名称。</target>
        </trans-unit>
        <trans-unit id="813ca35a99340fc74c82b99013f68fdb28a1bd3f" translate="yes" xml:space="preserve">
          <source>To use, create a &lt;code&gt;BEFORE UPDATE&lt;/code&gt; trigger using this function. Specify a single trigger argument: the name of the column to be modified. The column must be of type &lt;code&gt;timestamp&lt;/code&gt; or &lt;code&gt;timestamp with time zone&lt;/code&gt;.</source>
          <target state="translated">若要使用，请使用此函数创建一个 &lt;code&gt;BEFORE UPDATE&lt;/code&gt; 触发器。指定一个触发器参数：要修改的列的名称。该列的类型必须为 &lt;code&gt;timestamp&lt;/code&gt; 或 &lt;code&gt;timestamp with time zone&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d651aa40a647d96848db306e9d4e53d2fd74d529" translate="yes" xml:space="preserve">
          <source>To vacuum a table, one must ordinarily be the table's owner or a superuser. However, database owners are allowed to vacuum all tables in their databases, except shared catalogs. (The restriction for shared catalogs means that a true database-wide &lt;code&gt;VACUUM&lt;/code&gt; can only be performed by a superuser.) &lt;code&gt;VACUUM&lt;/code&gt; will skip over any tables that the calling user does not have permission to vacuum.</source>
          <target state="translated">要清理桌子，通常必须是桌子的所有者或超级用户。但是，允许数据库所有者清理其数据库中的所有表，共享目录除外。（共享目录的限制意味着真正的数据库范围的 &lt;code&gt;VACUUM&lt;/code&gt; 只能由超级用户执行。） &lt;code&gt;VACUUM&lt;/code&gt; 会跳过主叫用户无权清除的任何表。</target>
        </trans-unit>
        <trans-unit id="f11c4d150da0b305c6b3a53698ddafc986a15372" translate="yes" xml:space="preserve">
          <source>To verify a backup while ignoring a file that was added manually to the backup directory, and also skipping checksum verification:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b12aef90b0765da4396291cbd68b40200f811baa" translate="yes" xml:space="preserve">
          <source>To write a composite value as a literal constant, enclose the field values within parentheses and separate them by commas. You can put double quotes around any field value, and must do so if it contains commas or parentheses. (More details appear &lt;a href=&quot;rowtypes#ROWTYPES-IO-SYNTAX&quot;&gt;below&lt;/a&gt;.) Thus, the general format of a composite constant is the following:</source>
          <target state="translated">要将复合值写为文字常量，请将字段值括在括号中，并用逗号分隔。您可以在任何字段值两边加上双引号，并且如果包含逗号或括号，则必须使用双引号。（更多详细信息显示&lt;a href=&quot;rowtypes#ROWTYPES-IO-SYNTAX&quot;&gt;在下面&lt;/a&gt;。）因此，复合常量的一般格式如下：</target>
        </trans-unit>
        <trans-unit id="36be791e0428b306325653957972a9f27bc7282d" translate="yes" xml:space="preserve">
          <source>To write an array value as a literal constant, enclose the element values within curly braces and separate them by commas. (If you know C, this is not unlike the C syntax for initializing structures.) You can put double quotes around any element value, and must do so if it contains commas or curly braces. (More details appear below.) Thus, the general format of an array constant is the following:</source>
          <target state="translated">要将一个数组的值写成一个文字常量,将元素值用大括号括起来,并用逗号隔开。(如果你懂C语言,这与C语言的结构初始化语法不同)你可以在任何元素值周围加上双引号,如果包含逗号或大括号,则必须如此。(如果你了解C语言,这与C语言中初始化结构的语法并无二致。)你可以在任何元素值周围加上双引号,如果它包含逗号或大括号,则必须这样做。(更多细节出现在下面。)因此,数组常量的一般格式如下。</target>
        </trans-unit>
        <trans-unit id="a1573410db1a5214d17bb9421a6156f411884884" translate="yes" xml:space="preserve">
          <source>To write an operator class for a complex data type which has values included within another type, it's possible to use the inclusion support functions alongside the corresponding operators, as shown in &lt;a href=&quot;brin-extensibility#BRIN-EXTENSIBILITY-INCLUSION-TABLE&quot;&gt;Table 67.3&lt;/a&gt;. It requires only a single additional function, which can be written in any language. More functions can be defined for additional functionality. All operators are optional. Some operators require other operators, as shown as dependencies on the table.</source>
          <target state="translated">要为复杂的数据类型编写一个运算符类，该值在另一种类型中包含值，可以将包含支持功能与相应的运算符一起使用，如&lt;a href=&quot;brin-extensibility#BRIN-EXTENSIBILITY-INCLUSION-TABLE&quot;&gt;表67.3&lt;/a&gt;所示。它只需要一个附加功能，就可以用任何语言编写。可以为更多功能定义更多功能。所有运算符都是可选的。一些运算符需要其他运算符，如对表的依赖性所示。</target>
        </trans-unit>
        <trans-unit id="c41930744b3f03d751f8aa722eaefe121e7c4135" translate="yes" xml:space="preserve">
          <source>To write an operator class for a data type that implements a totally ordered set, it is possible to use the minmax support functions alongside the corresponding operators, as shown in &lt;a href=&quot;brin-extensibility#BRIN-EXTENSIBILITY-MINMAX-TABLE&quot;&gt;Table 67.2&lt;/a&gt;. All operator class members (functions and operators) are mandatory.</source>
          <target state="translated">要为实现完全有序集的数据类型编写一个运算符类，可以将minmax支持函数与相应的运算符一起使用，如&lt;a href=&quot;brin-extensibility#BRIN-EXTENSIBILITY-MINMAX-TABLE&quot;&gt;表67.2&lt;/a&gt;所示。所有操作员类成员（功能和操作员）都是必需的。</target>
        </trans-unit>
        <trans-unit id="d4a3b1136e1641950f065b8d855140afc16cbb62" translate="yes" xml:space="preserve">
          <source>Toggles the display of output column name headings and row count footer. This command is equivalent to &lt;code&gt;\pset tuples_only&lt;/code&gt; and is provided for convenience.</source>
          <target state="translated">切换输出列名称标题和行计数页脚的显示。此命令等效于 &lt;code&gt;\pset tuples_only&lt;/code&gt; 并且为方便起见而提供。</target>
        </trans-unit>
        <trans-unit id="db8eba10da49a68fddbc05012de430b49248b9b2" translate="yes" xml:space="preserve">
          <source>Tokens such as &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;VALUES&lt;/code&gt; in the example above are examples of &lt;em&gt;key words&lt;/em&gt;, that is, words that have a fixed meaning in the SQL language. The tokens &lt;code&gt;MY_TABLE&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are examples of &lt;em&gt;identifiers&lt;/em&gt;. They identify names of tables, columns, or other database objects, depending on the command they are used in. Therefore they are sometimes simply called &amp;ldquo;names&amp;rdquo;. Key words and identifiers have the same lexical structure, meaning that one cannot know whether a token is an identifier or a key word without knowing the language. A complete list of key words can be found in &lt;a href=&quot;sql-keywords-appendix&quot;&gt;Appendix C&lt;/a&gt;.</source>
          <target state="translated">上例中的 &lt;code&gt;SELECT&lt;/code&gt; ， &lt;code&gt;UPDATE&lt;/code&gt; 或 &lt;code&gt;VALUES&lt;/code&gt; 之类的标记是&lt;em&gt;关键字的&lt;/em&gt;示例，即在SQL语言中具有固定含义的单词。标记 &lt;code&gt;MY_TABLE&lt;/code&gt; 和 &lt;code&gt;A&lt;/code&gt; 是&lt;em&gt;标识符的&lt;/em&gt;示例。它们根据使用的命令来标识表，列或其他数据库对象的名称。因此，有时将它们简称为&amp;ldquo;名称&amp;rdquo;。关键字和标识符具有相同的词汇结构，这意味着在不了解语言的情况下无法知道令牌是标识符还是关键字。关键字的完整列表可以在&lt;a href=&quot;sql-keywords-appendix&quot;&gt;附录C中&lt;/a&gt;找到。</target>
        </trans-unit>
        <trans-unit id="7fdf6469a5fdbc62b046cf253917814a2537bbac" translate="yes" xml:space="preserve">
          <source>Too large or small integer and double constants, as well as integer arithmetic operators (&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt;) raise errors on overflows.</source>
          <target state="translated">整数或双精度常数太大或太小，以及整数算术运算符（ &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;-&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; 和 &lt;code&gt;/&lt;/code&gt; ）都会在溢出时引发错误。</target>
        </trans-unit>
        <trans-unit id="d299b72cc8e4fe0852effc6e9ba7475bfceb97f7" translate="yes" xml:space="preserve">
          <source>Top-level transaction identifier of this backend, if any.</source>
          <target state="translated">这个后台的顶层交易标识符,如果有的话。</target>
        </trans-unit>
        <trans-unit id="a230feca93e9b8afbf572850a80bd7ee57cef2d3" translate="yes" xml:space="preserve">
          <source>Total amount of WAL bytes generated by the statement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d83687b2ce879fb045fc3cb3c8969197fea57f55" translate="yes" xml:space="preserve">
          <source>Total amount of data that will be streamed. This is estimated and reported as of the beginning of &lt;code&gt;streaming database files&lt;/code&gt; phase. Note that this is only an approximation since the database may change during &lt;code&gt;streaming database files&lt;/code&gt; phase and WAL log may be included in the backup later. This is always the same value as &lt;code&gt;backup_streamed&lt;/code&gt; once the amount of data streamed exceeds the estimated total size. If the estimation is disabled in pg_basebackup (i.e., &lt;code&gt;--no-estimate-size&lt;/code&gt; option is specified), this is &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b94a11c6c4384bcb235fe450b134cbeae2334827" translate="yes" xml:space="preserve">
          <source>Total amount of data written to temporary files by queries in this database. All temporary files are counted, regardless of why the temporary file was created, and regardless of the &lt;a href=&quot;runtime-config-logging#GUC-LOG-TEMP-FILES&quot;&gt;log_temp_files&lt;/a&gt; setting.</source>
          <target state="translated">通过此数据库中的查询写入临时文件的数据总量。无论创建临时文件的原因以及&lt;a href=&quot;runtime-config-logging#GUC-LOG-TEMP-FILES&quot;&gt;log_temp_files&lt;/a&gt;设置如何，都将对所有临时文件进行计数。</target>
        </trans-unit>
        <trans-unit id="048f9cb0c1fef49da291331aa694810bbf7c5eaf" translate="yes" xml:space="preserve">
          <source>Total amount of shared memory available (bytes or pages)</source>
          <target state="translated">可用的共享内存总量(字节或页数)</target>
        </trans-unit>
        <trans-unit id="c89a5c064950bd223dd4b0d4940f5906ef93b42c" translate="yes" xml:space="preserve">
          <source>Total amount of time that has been spent in the portion of checkpoint processing where files are synchronized to disk, in milliseconds</source>
          <target state="translated">在检查点处理中,文件同步到磁盘的部分所花费的总时间,以毫秒为单位。</target>
        </trans-unit>
        <trans-unit id="3e73c325b1deeb96ed9f601ced16f69bc748b945" translate="yes" xml:space="preserve">
          <source>Total amount of time that has been spent in the portion of checkpoint processing where files are written to disk, in milliseconds</source>
          <target state="translated">在检查点处理中将文件写入磁盘的部分所花费的总时间,以毫秒为单位。</target>
        </trans-unit>
        <trans-unit id="71415a93ebff8bf2944bf82c235b10d6a4874b3a" translate="yes" xml:space="preserve">
          <source>Total disk space used by indexes attached to the specified table</source>
          <target state="translated">指定表的索引所使用的总磁盘空间。</target>
        </trans-unit>
        <trans-unit id="a7f95b912814449591b52712042e3e25ade209c4" translate="yes" xml:space="preserve">
          <source>Total disk space used by the specified table, including all indexes and TOAST data</source>
          <target state="translated">指定表使用的总磁盘空间,包括所有索引和TOAST数据。</target>
        </trans-unit>
        <trans-unit id="1ee9b213fd39d43e6dff25c490fe089aa0f14ead" translate="yes" xml:space="preserve">
          <source>Total free space in bytes</source>
          <target state="translated">总可用空间(单位:字节)</target>
        </trans-unit>
        <trans-unit id="57d76893f09fe684f4b71eeb58289be5bae9b545" translate="yes" xml:space="preserve">
          <source>Total free space in bytes (estimated)</source>
          <target state="translated">总可用空间(单位:字节)(估计)</target>
        </trans-unit>
        <trans-unit id="a1b33dddd9dc06b94a7dc19125345a3ba04c6ba7" translate="yes" xml:space="preserve">
          <source>Total index size in bytes</source>
          <target state="translated">总索引大小(字节)</target>
        </trans-unit>
        <trans-unit id="f6e222d69efe669c5fefda27390cf10ca078aa0d" translate="yes" xml:space="preserve">
          <source>Total length of dead tuples in bytes</source>
          <target state="translated">死亡元组的总长度(字节)</target>
        </trans-unit>
        <trans-unit id="d6a855ca8640e026c82ad34a21c2afe4864021a0" translate="yes" xml:space="preserve">
          <source>Total length of dead tuples in bytes (exact)</source>
          <target state="translated">死元组的总长度,以字节为单位(精确)</target>
        </trans-unit>
        <trans-unit id="998db26f06b8a72881082a9b3df052ec2d49b9d8" translate="yes" xml:space="preserve">
          <source>Total length of live tuples in bytes</source>
          <target state="translated">有效元组的总长度(字节)</target>
        </trans-unit>
        <trans-unit id="5de5b16f6d80a5b30ec964c09c76bd5a80231924" translate="yes" xml:space="preserve">
          <source>Total length of live tuples in bytes (estimated)</source>
          <target state="translated">以字节为单位的有效元组总长度(估计)</target>
        </trans-unit>
        <trans-unit id="6ccd38e7f39b55f68908c8f44a285a49297c5b87" translate="yes" xml:space="preserve">
          <source>Total number of WAL full page images generated by the statement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1b5a1338a4346cf6785e1053f9330facfc3876a" translate="yes" xml:space="preserve">
          <source>Total number of WAL records generated by the statement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1ce6625b6e47aeee73d2c1b1b71597cc6a9a9eb" translate="yes" xml:space="preserve">
          <source>Total number of blocks to be processed in the current phase.</source>
          <target state="translated">当前阶段要处理的区块总数。</target>
        </trans-unit>
        <trans-unit id="a3f02827d30602c98795371990fc0010531688f8" translate="yes" xml:space="preserve">
          <source>Total number of heap blocks in the table. This number is reported as of the beginning of &lt;code&gt;seq scanning heap&lt;/code&gt;.</source>
          <target state="translated">表中的堆块总数。从 &lt;code&gt;seq scanning heap&lt;/code&gt; 开始时开始报告此数字。</target>
        </trans-unit>
        <trans-unit id="4e4181d322bb75a54b26cb82d6a33040c9b04e2f" translate="yes" xml:space="preserve">
          <source>Total number of heap blocks in the table. This number is reported as of the beginning of the scan; blocks added later will not be (and need not be) visited by this &lt;code&gt;VACUUM&lt;/code&gt;.</source>
          <target state="translated">表中的堆块总数。在扫描开始时报告此数字。 &lt;code&gt;VACUUM&lt;/code&gt; 不会（也不需要）访问以后添加的块。</target>
        </trans-unit>
        <trans-unit id="034537a9255995f3a8c4229411cb79c84839a103" translate="yes" xml:space="preserve">
          <source>Total number of heap blocks that will be sampled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="139c9a494fed3d2e3c71e34a5377d33fc050686f" translate="yes" xml:space="preserve">
          <source>Total number of local block cache hits by the statement</source>
          <target state="translated">语句的本地块缓存点击总数</target>
        </trans-unit>
        <trans-unit id="0444ce0d25e58c3dd39f796bef3ec3b458f342a6" translate="yes" xml:space="preserve">
          <source>Total number of local blocks dirtied by the statement</source>
          <target state="translated">被报表弄脏的当地区块总数。</target>
        </trans-unit>
        <trans-unit id="fa8d6c141a66861c96281f0f98242227f5426245" translate="yes" xml:space="preserve">
          <source>Total number of local blocks read by the statement</source>
          <target state="translated">语句读取的本地块总数</target>
        </trans-unit>
        <trans-unit id="c4c74b725d95cc43eb047faf06c7999e553ed6e3" translate="yes" xml:space="preserve">
          <source>Total number of local blocks written by the statement</source>
          <target state="translated">声明所写的本地块总数</target>
        </trans-unit>
        <trans-unit id="45b980cf18ac4474aa05feb6af93d1110cc5268b" translate="yes" xml:space="preserve">
          <source>Total number of lockers to wait for, when applicable.</source>
          <target state="translated">需要等待的储物柜总数(如适用):</target>
        </trans-unit>
        <trans-unit id="52c88d84e12390f95fdf71590482ec7e55e73347" translate="yes" xml:space="preserve">
          <source>Total number of rows retrieved or affected by the statement</source>
          <target state="translated">检索到的或受该语句影响的记录总数</target>
        </trans-unit>
        <trans-unit id="2c19070c91bef841456a88dfe27bbe57dee0681a" translate="yes" xml:space="preserve">
          <source>Total number of shared block cache hits by the statement</source>
          <target state="translated">语句的共享块缓存总点击次数</target>
        </trans-unit>
        <trans-unit id="a10785244a51d5a13cdcecb0439b9565a7085faf" translate="yes" xml:space="preserve">
          <source>Total number of shared blocks dirtied by the statement</source>
          <target state="translated">被声明弄脏的共享区块总数。</target>
        </trans-unit>
        <trans-unit id="b53a3b5f4cb61c2d5cff8b511400281b57ffd420" translate="yes" xml:space="preserve">
          <source>Total number of shared blocks read by the statement</source>
          <target state="translated">声明读取的共享区块总数</target>
        </trans-unit>
        <trans-unit id="80f7d9d3865345cc690816c3728dd14e4bb7e4b9" translate="yes" xml:space="preserve">
          <source>Total number of shared blocks written by the statement</source>
          <target state="translated">声明所写的共享区块总数</target>
        </trans-unit>
        <trans-unit id="0dec74abab5b22125ad8d3417834f7d11deb6460" translate="yes" xml:space="preserve">
          <source>Total number of tablespaces that will be streamed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d52c8d86744555c33141f6cf6855a23715ba448" translate="yes" xml:space="preserve">
          <source>Total number of temp blocks read by the statement</source>
          <target state="translated">语句读取的临时块总数</target>
        </trans-unit>
        <trans-unit id="d68b8452834fec0662460159475cf3a49ba37364" translate="yes" xml:space="preserve">
          <source>Total number of temp blocks written by the statement</source>
          <target state="translated">语句所写的临时块总数。</target>
        </trans-unit>
        <trans-unit id="7fc7e0f8478eebbe50dca363939606b67ef16e62" translate="yes" xml:space="preserve">
          <source>Total number of tuples to be processed in the current phase.</source>
          <target state="translated">当前阶段要处理的元组总数。</target>
        </trans-unit>
        <trans-unit id="7a2e3368cba08aab3bbc52e0db6c41724c5181bc" translate="yes" xml:space="preserve">
          <source>Total time spent executing the statement, in milliseconds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68f2ac9e60d0e97728209a16e26e37eeb3dc266b" translate="yes" xml:space="preserve">
          <source>Total time spent in the statement, in milliseconds</source>
          <target state="translated">在报表中花费的总时间(毫秒)</target>
        </trans-unit>
        <trans-unit id="4dc28fb55c553e60327ba7c4192353b9fe9a42ae" translate="yes" xml:space="preserve">
          <source>Total time spent in this function and all other functions called by it, in milliseconds</source>
          <target state="translated">本函数和所有其他函数所花费的总时间,以毫秒为单位。</target>
        </trans-unit>
        <trans-unit id="128b607d292f1a55909a9645569d2e8961a6c971" translate="yes" xml:space="preserve">
          <source>Total time spent in this function itself, not including other functions called by it, in milliseconds</source>
          <target state="translated">这个函数本身花费的总时间,不包括被它调用的其他函数,以毫秒为单位。</target>
        </trans-unit>
        <trans-unit id="3de803593f31c4639f990558ee1a07af5052d1e1" translate="yes" xml:space="preserve">
          <source>Total time spent planning the statement, in milliseconds (if &lt;code&gt;pg_stat_statements.track_planning&lt;/code&gt; is enabled, otherwise zero)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fdfbad291288b3e0fb3447fb003299fb7e4adba" translate="yes" xml:space="preserve">
          <source>Total time the statement spent reading blocks, in milliseconds (if &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-IO-TIMING&quot;&gt;track_io_timing&lt;/a&gt; is enabled, otherwise zero)</source>
          <target state="translated">语句花费在读取块上的总时间（以毫秒为单位）（如果启用了&lt;a href=&quot;runtime-config-statistics#GUC-TRACK-IO-TIMING&quot;&gt;track_io_timing&lt;/a&gt;，则为零）</target>
        </trans-unit>
        <trans-unit id="b2bf126392434f87ab4af3802a7e86186f9be4fd" translate="yes" xml:space="preserve">
          <source>Total time the statement spent writing blocks, in milliseconds (if &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-IO-TIMING&quot;&gt;track_io_timing&lt;/a&gt; is enabled, otherwise zero)</source>
          <target state="translated">语句花费的总时间（以毫秒为单位）（如果启用了&lt;a href=&quot;runtime-config-statistics#GUC-TRACK-IO-TIMING&quot;&gt;track_io_timing&lt;/a&gt;，否则为零）</target>
        </trans-unit>
        <trans-unit id="3b612e72ed8b42ec172f3e6dbff27929a0f89575" translate="yes" xml:space="preserve">
          <source>Traditional Chinese</source>
          <target state="translated">中国传统</target>
        </trans-unit>
        <trans-unit id="bb7f41346d8c75d2dd240c360bc90f8fc8bf4ce2" translate="yes" xml:space="preserve">
          <source>Traditional Chinese, Taiwanese</source>
          <target state="translated">繁体中文、台湾语</target>
        </trans-unit>
        <trans-unit id="9af7edd2b08bdbc2ff56eb3fefef8426307788e0" translate="yes" xml:space="preserve">
          <source>Traditional Postgres format: 1 year 2 months 3 days 4 hours 5 minutes 6 seconds</source>
          <target state="translated">传统的Postgres格式。1年 2个月 3天 4小时 5分钟 6秒</target>
        </trans-unit>
        <trans-unit id="d71728de27860673275b28c16ef5e7f90331435b" translate="yes" xml:space="preserve">
          <source>Traditionally, implementing a new index access method meant a lot of difficult work. It was necessary to understand the inner workings of the database, such as the lock manager and Write-Ahead Log. The GiST interface has a high level of abstraction, requiring the access method implementer only to implement the semantics of the data type being accessed. The GiST layer itself takes care of concurrency, logging and searching the tree structure.</source>
          <target state="translated">传统上,实现一种新的索引访问方法意味着很多困难的工作。必须了解数据库的内部工作原理,如锁管理器和Write-Ahead日志。GiST接口具有高度的抽象性,要求访问方法实现者只需要实现被访问数据类型的语义。GiST层本身负责并发、日志和搜索树结构。</target>
        </trans-unit>
        <trans-unit id="e44f86c162c3284066aeae3888c8a4b415d14e56" translate="yes" xml:space="preserve">
          <source>Traditionally, the configuration and data files used by a database cluster are stored together within the cluster's data directory, commonly referred to as &lt;code&gt;PGDATA&lt;/code&gt; (after the name of the environment variable that can be used to define it). A common location for &lt;code&gt;PGDATA&lt;/code&gt; is &lt;code&gt;/var/lib/pgsql/data&lt;/code&gt;. Multiple clusters, managed by different server instances, can exist on the same machine.</source>
          <target state="translated">传统上，数据库集群使用的配置和数据文件一起存储在集群的数据目录（通常称为 &lt;code&gt;PGDATA&lt;/code&gt; （可用于定义环境变量的名称之后）。 &lt;code&gt;PGDATA&lt;/code&gt; 的常见位置是 &lt;code&gt;/var/lib/pgsql/data&lt;/code&gt; 。由不同服务器实例管理的多个集群可以存在于同一台计算机上。</target>
        </trans-unit>
        <trans-unit id="1a7b7c1b33d161f45804730c70b75175dccd9883" translate="yes" xml:space="preserve">
          <source>Transaction</source>
          <target state="translated">Transaction</target>
        </trans-unit>
        <trans-unit id="06d8ffe65391f0da38d503880772215ed8a2200b" translate="yes" xml:space="preserve">
          <source>Transaction ID</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20805c5f220ddf62c478af0fa328fd76b59b6fbd" translate="yes" xml:space="preserve">
          <source>Transaction ID (0 if none is assigned)</source>
          <target state="translated">交易ID(如果没有指定,则为0)</target>
        </trans-unit>
        <trans-unit id="18878616c87726806d6badd68af497dae4b41656" translate="yes" xml:space="preserve">
          <source>Transaction ID of locker, or multixact ID if multitransaction</source>
          <target state="translated">储物柜的交易ID,如果是多交易,则为多确切ID。</target>
        </trans-unit>
        <trans-unit id="10ae26a42b974bab55e86677c8854e6023be47c7" translate="yes" xml:space="preserve">
          <source>Transaction IDs of lockers (more than one if multitransaction)</source>
          <target state="translated">储物柜的交易ID(如果是多交易,则多于一个)</target>
        </trans-unit>
        <trans-unit id="1b857f9c61d290e017488262bdfa776200c8930d" translate="yes" xml:space="preserve">
          <source>Transaction Identifier</source>
          <target state="translated">交易标识符</target>
        </trans-unit>
        <trans-unit id="362cc7ebfcc8b6860ba84b6be6157ee564a4269e" translate="yes" xml:space="preserve">
          <source>Transaction Isolation</source>
          <target state="translated">交易隔离</target>
        </trans-unit>
        <trans-unit id="6e3fee17c38273e0e622dcdfde38cb6e3e451ec0" translate="yes" xml:space="preserve">
          <source>Transaction Isolation: Read Committed Isolation Level</source>
          <target state="translated">事务隔离。读取承诺隔离级别</target>
        </trans-unit>
        <trans-unit id="0295f8efef0a16226ca1dadeb7b1cef90dbc2ba8" translate="yes" xml:space="preserve">
          <source>Transaction Isolation: Repeatable Read Isolation Level</source>
          <target state="translated">事务隔离。可重复读取隔离级别</target>
        </trans-unit>
        <trans-unit id="fdc308a16f76158b2289592e32f76f134ccb174a" translate="yes" xml:space="preserve">
          <source>Transaction Isolation: Serializable Isolation Level</source>
          <target state="translated">事务隔离。可序列化隔离级别</target>
        </trans-unit>
        <trans-unit id="b163af0dec8e2d414f03eeaa5a4aa6c8443bd48e" translate="yes" xml:space="preserve">
          <source>Transaction Processing Performance Council</source>
          <target state="translated">交易处理绩效委员会</target>
        </trans-unit>
        <trans-unit id="783653ce8aabc988ab1fbf0b7b77def9554206d6" translate="yes" xml:space="preserve">
          <source>Transaction identifiers are also 32-bit quantities. In a long-lived database it is possible for transaction IDs to wrap around. This is not a fatal problem given appropriate maintenance procedures; see &lt;a href=&quot;https://www.postgresql.org/docs/12/maintenance.html&quot;&gt;Chapter 24&lt;/a&gt; for details. It is unwise, however, to depend on the uniqueness of transaction IDs over the long term (more than one billion transactions).</source>
          <target state="translated">交易标识符也是32位的数量。在寿命长的数据库中，事务ID可能会回绕。如果采取适当的维护程序，这不是致命的问题；有关详细信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/maintenance.html&quot;&gt;第24章&lt;/a&gt;。但是，长期依赖交易ID（超过十亿笔交易）的唯一性是不明智的。</target>
        </trans-unit>
        <trans-unit id="81482fe22076261a7285e457dec778b14a2c3695" translate="yes" xml:space="preserve">
          <source>Transaction identifiers are also 32-bit quantities. In a long-lived database it is possible for transaction IDs to wrap around. This is not a fatal problem given appropriate maintenance procedures; see &lt;a href=&quot;https://www.postgresql.org/docs/13/maintenance.html&quot;&gt;Chapter 24&lt;/a&gt; for details. It is unwise, however, to depend on the uniqueness of transaction IDs over the long term (more than one billion transactions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad3cae69d174599e4cc4c127a9de08ea538533e3" translate="yes" xml:space="preserve">
          <source>Transaction management commands</source>
          <target state="translated">事务管理命令</target>
        </trans-unit>
        <trans-unit id="244648d2a2b4c5e9f046005998c3282e5c7fd698" translate="yes" xml:space="preserve">
          <source>Transaction management commands that explicitly set non-read-only state:</source>
          <target state="translated">明确设置非只读状态的事务管理命令。</target>
        </trans-unit>
        <trans-unit id="032a6a2e156459be12da14ed3e107d4113138cfd" translate="yes" xml:space="preserve">
          <source>Transaction management commands:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bae2f8d1524dbc31720a0e3939f64fa26db9b78" translate="yes" xml:space="preserve">
          <source>Transaction one attempts to acquire a row-level lock on the specified row, but it cannot: transaction two already holds such a lock. So it waits for transaction two to complete. Thus, transaction one is blocked on transaction two, and transaction two is blocked on transaction one: a deadlock condition. PostgreSQL will detect this situation and abort one of the transactions.</source>
          <target state="translated">事务一试图在指定的行上获取一个行级锁,但它不能:事务二已经拥有这样一个锁。所以它等待事务二完成。因此,事务一被阻塞在事务二上,而事务二被阻塞在事务一上:一个死锁条件。PostgreSQL会检测到这种情况,并中止其中一个事务。</target>
        </trans-unit>
        <trans-unit id="2df50b58a3e87095cd42c2f4034bc6e5e6a2ae50" translate="yes" xml:space="preserve">
          <source>Transaction status &quot;hint bits&quot; written on the primary are not WAL-logged, so data on the standby will likely re-write the hints again on the standby. Thus, the standby server will still perform disk writes even though all users are read-only; no changes occur to the data values themselves. Users will still write large sort temporary files and re-generate relcache info files, so no part of the database is truly read-only during hot standby mode. Note also that writes to remote databases using dblink module, and other operations outside the database using PL functions will still be possible, even though the transaction is read-only locally.</source>
          <target state="translated">在主机上写入的事务状态 &quot;提示位 &quot;不会被WAL记录,因此备用机上的数据很可能会在备用机上再次重写提示。因此,即使所有用户都是只读,备用服务器仍然会进行磁盘写入;数据值本身不会发生变化。用户仍然会写入大的排序临时文件和重新生成relcache信息文件,所以在热备模式下,数据库的任何部分都不是真正的只读。另外需要注意的是,使用dblink模块向远程数据库写入数据,以及使用PL函数在数据库外进行的其他操作仍然可以进行,即使事务在本地是只读的。</target>
        </trans-unit>
        <trans-unit id="9115fef6aaf514e06f30c02d5ba3730bf585a59c" translate="yes" xml:space="preserve">
          <source>Transaction status: an empty string when not in a transaction block, or &lt;code&gt;*&lt;/code&gt; when in a transaction block, or &lt;code&gt;!&lt;/code&gt; when in a failed transaction block, or &lt;code&gt;?&lt;/code&gt; when the transaction state is indeterminate (for example, because there is no connection).</source>
          <target state="translated">事务状态：不在事务块中时为空字符串，在事务块中时为 &lt;code&gt;*&lt;/code&gt; ，或 &lt;code&gt;!&lt;/code&gt; 在失败的交易区块中时，还是 &lt;code&gt;?&lt;/code&gt; 当事务状态不确定时（例如，因为没有连接）。</target>
        </trans-unit>
        <trans-unit id="47ebfa32d50285675f9d154d8a4546223948507a" translate="yes" xml:space="preserve">
          <source>TransactionId</source>
          <target state="translated">TransactionId</target>
        </trans-unit>
        <trans-unit id="d071bbfced054416a7f289525ebee94bea79198f" translate="yes" xml:space="preserve">
          <source>Transactions in progress at the time of the snapshot. A transaction ID that is &lt;code&gt;xmin &amp;lt;= X &amp;lt; xmax&lt;/code&gt; and not in this list was already completed at the time of the snapshot, and thus is either visible or dead according to its commit status. This list does not include the transaction IDs of subtransactions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a16fa9a914d72a0c50c04e0fc3597d3f514a314" translate="yes" xml:space="preserve">
          <source>Transactions per second (TPS)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01df28d63a600d976f605002c1c87ca85d599d36" translate="yes" xml:space="preserve">
          <source>Transactions started during hot standby may issue the following commands:</source>
          <target state="translated">在热备期间启动的事务可以发出以下命令。</target>
        </trans-unit>
        <trans-unit id="3cf9ced370da4876292141e53b2b552a9cf764b7" translate="yes" xml:space="preserve">
          <source>Transactions started during hot standby will never be assigned a transaction ID and cannot write to the system write-ahead log. Therefore, the following actions will produce error messages:</source>
          <target state="translated">在热备期间启动的事务将永远不会被分配一个事务ID,也不能写入系统写前日志。因此,以下操作将产生错误信息。</target>
        </trans-unit>
        <trans-unit id="479ffbbc1b67ed11701ba8d2dcae959b56067bd4" translate="yes" xml:space="preserve">
          <source>Transactions that last more than &lt;code&gt;limit&lt;/code&gt; milliseconds are counted and reported separately, as &lt;em&gt;late&lt;/em&gt;.</source>
          <target state="translated">持续时间超过 &lt;code&gt;limit&lt;/code&gt; 毫秒的事务将被计数，并分别报告为&lt;em&gt;晚期&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="4dd0b9585e0aac48b40c541fafaca4f31c93300a" translate="yes" xml:space="preserve">
          <source>Transition function</source>
          <target state="translated">过渡功能</target>
        </trans-unit>
        <trans-unit id="efa82358149d07c8578392dc98215d57f7bd3811" translate="yes" xml:space="preserve">
          <source>Translates a textual collation name to its OID. A similar result is obtained by casting the string to type &lt;code&gt;regcollation&lt;/code&gt; (see &lt;a href=&quot;datatype-oid&quot;&gt;Section 8.19&lt;/a&gt;); however, this function will return &lt;code&gt;NULL&lt;/code&gt; rather than throwing an error if the name is not found. Also unlike the cast, this does not accept a numeric OID as input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccc164c92dd7b3fef9b61d3c82842d6ee1da4302" translate="yes" xml:space="preserve">
          <source>Translates a textual function or procedure name (with argument types) to its OID. A similar result is obtained by casting the string to type &lt;code&gt;regprocedure&lt;/code&gt; (see &lt;a href=&quot;datatype-oid&quot;&gt;Section 8.19&lt;/a&gt;); however, this function will return &lt;code&gt;NULL&lt;/code&gt; rather than throwing an error if the name is not found. Also unlike the cast, this does not accept a numeric OID as input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef72ee486a99d329e919f18b88ce76c0b03976ee" translate="yes" xml:space="preserve">
          <source>Translates a textual function or procedure name to its OID. A similar result is obtained by casting the string to type &lt;code&gt;regproc&lt;/code&gt; (see &lt;a href=&quot;datatype-oid&quot;&gt;Section 8.19&lt;/a&gt;); however, this function will return &lt;code&gt;NULL&lt;/code&gt; rather than throwing an error if the name is not found or is ambiguous. Also unlike the cast, this does not accept a numeric OID as input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3df810a8802c3de4a8975fa62010e275f6693c7" translate="yes" xml:space="preserve">
          <source>Translates a textual operator name (with parameter types) to its OID. A similar result is obtained by casting the string to type &lt;code&gt;regoperator&lt;/code&gt; (see &lt;a href=&quot;datatype-oid&quot;&gt;Section 8.19&lt;/a&gt;); however, this function will return &lt;code&gt;NULL&lt;/code&gt; rather than throwing an error if the name is not found. Also unlike the cast, this does not accept a numeric OID as input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92746faa205cd6961adce584e99c5f21cb92c46c" translate="yes" xml:space="preserve">
          <source>Translates a textual operator name to its OID. A similar result is obtained by casting the string to type &lt;code&gt;regoper&lt;/code&gt; (see &lt;a href=&quot;datatype-oid&quot;&gt;Section 8.19&lt;/a&gt;); however, this function will return &lt;code&gt;NULL&lt;/code&gt; rather than throwing an error if the name is not found or is ambiguous. Also unlike the cast, this does not accept a numeric OID as input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfb773d5eee2a49b6ea78ef980db2e7f30639736" translate="yes" xml:space="preserve">
          <source>Translates a textual relation name to its OID. A similar result is obtained by casting the string to type &lt;code&gt;regclass&lt;/code&gt; (see &lt;a href=&quot;datatype-oid&quot;&gt;Section 8.19&lt;/a&gt;); however, this function will return &lt;code&gt;NULL&lt;/code&gt; rather than throwing an error if the name is not found. Also unlike the cast, this does not accept a numeric OID as input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="098dc5926b87a21bd111e9afaa29f8b1770028be" translate="yes" xml:space="preserve">
          <source>Translates a textual role name to its OID. A similar result is obtained by casting the string to type &lt;code&gt;regrole&lt;/code&gt; (see &lt;a href=&quot;datatype-oid&quot;&gt;Section 8.19&lt;/a&gt;); however, this function will return &lt;code&gt;NULL&lt;/code&gt; rather than throwing an error if the name is not found. Also unlike the cast, this does not accept a numeric OID as input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb42818718f6870ecc3a5e4e2716f5845d22f9af" translate="yes" xml:space="preserve">
          <source>Translates a textual schema name to its OID. A similar result is obtained by casting the string to type &lt;code&gt;regnamespace&lt;/code&gt; (see &lt;a href=&quot;datatype-oid&quot;&gt;Section 8.19&lt;/a&gt;); however, this function will return &lt;code&gt;NULL&lt;/code&gt; rather than throwing an error if the name is not found. Also unlike the cast, this does not accept a numeric OID as input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4723217fb81c0d95526fe2c01ae95fbd721b1761" translate="yes" xml:space="preserve">
          <source>Translates a textual type name to its OID. A similar result is obtained by casting the string to type &lt;code&gt;regtype&lt;/code&gt; (see &lt;a href=&quot;datatype-oid&quot;&gt;Section 8.19&lt;/a&gt;); however, this function will return &lt;code&gt;NULL&lt;/code&gt; rather than throwing an error if the name is not found. Also unlike the cast, this does not accept a numeric OID as input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59a6244fac8a9c9d9686484f98e57e4b38d7e551" translate="yes" xml:space="preserve">
          <source>Translates the given qualified MLS/MCS range into raw format if the mcstrans daemon is running.</source>
          <target state="translated">如果mcstrans守护进程正在运行,则将给定的限定MLS/MCS范围翻译成原始格式。</target>
        </trans-unit>
        <trans-unit id="731119f8198322e42d9eac5b43c02d9adc999a6f" translate="yes" xml:space="preserve">
          <source>Translates the given raw MLS/MCS range into qualified format if the mcstrans daemon is running.</source>
          <target state="translated">如果mcstrans守护进程正在运行,则将给定的原始MLS/MCS范围翻译成限定格式。</target>
        </trans-unit>
        <trans-unit id="ac26a7a94ea2e66490f932b6415a09ef6f2a913c" translate="yes" xml:space="preserve">
          <source>Translation</source>
          <target state="translated">Translation</target>
        </trans-unit>
        <trans-unit id="6ba02139a90ba90fe7b0f004a77e148246991531" translate="yes" xml:space="preserve">
          <source>Transmission Control Protocol (TCP) / Internet Protocol (IP)</source>
          <target state="translated">传输控制协议(TCP)/互联网协议(IP)</target>
        </trans-unit>
        <trans-unit id="0078eb875cd6a9009a98bbca564ba5b0c49f0742" translate="yes" xml:space="preserve">
          <source>Treat given time stamp &lt;em&gt;without time zone&lt;/em&gt; as located in the specified time zone</source>
          <target state="translated">将&lt;em&gt;不带时区的&lt;/em&gt;给定时间戳视为位于指定时区中</target>
        </trans-unit>
        <trans-unit id="525e69424eac00831ef279c5d86304725cc5771e" translate="yes" xml:space="preserve">
          <source>Treating the buffer as a single line primarily affects meta-commands: whatever is in the buffer after a meta-command will be taken as argument(s) to the meta-command, even if it spans multiple lines. (Thus you cannot make meta-command-using scripts this way. Use &lt;code&gt;\i&lt;/code&gt; for that.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22ea8d02160441883e871c64b4bf207437c3c434" translate="yes" xml:space="preserve">
          <source>Tree level of the root page</source>
          <target state="translated">根页面的树级</target>
        </trans-unit>
        <trans-unit id="d3f06a581b2b66fa7a3965ddeb6fb307f7be20ba" translate="yes" xml:space="preserve">
          <source>Trigger</source>
          <target state="translated">Trigger</target>
        </trans-unit>
        <trans-unit id="9451e7469c06f9b530822204de7004d1e937be5b" translate="yes" xml:space="preserve">
          <source>Trigger name (must be unique among triggers of same table)</source>
          <target state="translated">触发器名称(必须在同一张表的触发器中是唯一的)</target>
        </trans-unit>
        <trans-unit id="e20ca83547dde923f083f9c8fa915e58f12e5b0e" translate="yes" xml:space="preserve">
          <source>Trigger name (must be unique)</source>
          <target state="translated">触发器名称(必须是唯一的</target>
        </trans-unit>
        <trans-unit id="1a556d389e53119654090ed90caa41185b3f9c1f" translate="yes" xml:space="preserve">
          <source>Trigger-Based Master-Standby Replication</source>
          <target state="translated">基于触发器的主备复制</target>
        </trans-unit>
        <trans-unit id="b403b55ee83f5cefbd6403b1202345b597667eeb" translate="yes" xml:space="preserve">
          <source>Trigger-Based Repl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="358d2d9b79bd7e7b52f1a586b3f6090ae9e39c21" translate="yes" xml:space="preserve">
          <source>Trigger-based replication systems such as Slony, Londiste and Bucardo won't run on the standby at all, though they will run happily on the primary server as long as the changes are not sent to standby servers to be applied. WAL replay is not trigger-based so you cannot relay from the standby to any system that requires additional database writes or relies on the use of triggers.</source>
          <target state="translated">基于触发器的复制系统,如Slony、Londiste和Bucardo根本不会在备用服务器上运行,尽管它们会在主服务器上愉快地运行,只要不将更改发送到备用服务器上应用。WAL重放不是基于触发器的,所以你不能从备用服务器中继到任何需要额外的数据库写入或依赖使用触发器的系统。</target>
        </trans-unit>
        <trans-unit id="ec9dd8da4cbb76e8113d156c57ac6bcb808fcaed" translate="yes" xml:space="preserve">
          <source>Triggers or rules will be needed to route rows to the desired child table, unless the application is explicitly aware of the partitioning scheme. Triggers may be complicated to write, and will be much slower than the tuple routing performed internally by declarative partitioning.</source>
          <target state="translated">除非应用程序明确知道分区方案,否则将需要触发器或规则将行路由到所需的子表。触发器的编写可能很复杂,而且比声明式分区内部执行的元组路由要慢得多。</target>
        </trans-unit>
        <trans-unit id="e5d696aa282753969e978fb0a8849d8e4a8fd3c1" translate="yes" xml:space="preserve">
          <source>Triggers that are specified to fire &lt;code&gt;INSTEAD OF&lt;/code&gt; the trigger event must be marked &lt;code&gt;FOR EACH ROW&lt;/code&gt;, and can only be defined on views. &lt;code&gt;BEFORE&lt;/code&gt; and &lt;code&gt;AFTER&lt;/code&gt; triggers on a view must be marked as &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt;.</source>
          <target state="translated">指定要触发 &lt;code&gt;INSTEAD OF&lt;/code&gt; 触发事件的触发器必须标记为 &lt;code&gt;FOR EACH ROW&lt;/code&gt; ，并且只能在视图上定义。视图上的 &lt;code&gt;BEFORE&lt;/code&gt; 和 &lt;code&gt;AFTER&lt;/code&gt; 触发器必须标记为 &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9fc33655c302a2026e3c03ef9f67004fc688e0bc" translate="yes" xml:space="preserve">
          <source>Trigram matching is a very useful tool when used in conjunction with a full text index. In particular it can help to recognize misspelled input words that will not be matched directly by the full text search mechanism.</source>
          <target state="translated">卦象匹配与全文索引结合使用时,是一个非常有用的工具。特别是它可以帮助识别拼写错误的输入词,而这些词不会被全文搜索机制直接匹配。</target>
        </trans-unit>
        <trans-unit id="c47b56bcac7cb1a1a1a2b8b071447953ef205236" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;member&lt;/code&gt; can grant membership in &lt;code&gt;roleid&lt;/code&gt; to others</source>
          <target state="translated">如果 &lt;code&gt;member&lt;/code&gt; 可以将 &lt;code&gt;roleid&lt;/code&gt; 成员身份授予其他人，则为true</target>
        </trans-unit>
        <trans-unit id="27b88e660e42da283a963fedfe7ddba5acc1eb37" translate="yes" xml:space="preserve">
          <source>True if GSSAPI authentication was used for this connection</source>
          <target state="translated">如果该连接使用了GSSAPI认证,则为真。</target>
        </trans-unit>
        <trans-unit id="f0294acd5dcbc0ec5fe0501f3d6e4f6631feaea3" translate="yes" xml:space="preserve">
          <source>True if GSSAPI encryption is in use on this connection</source>
          <target state="translated">如果该连接上使用了GSSAPI加密,则为真。</target>
        </trans-unit>
        <trans-unit id="249fa4238b509d9384131b077e4a974fe52e87b7" translate="yes" xml:space="preserve">
          <source>True if SSL compression is in use, false if not, or NULL if SSL is not in use on this connection</source>
          <target state="translated">如果使用SSL压缩,则为true;如果不使用,则为false;如果该连接不使用SSL,则为NULL。</target>
        </trans-unit>
        <trans-unit id="b09e7e431be1f0ef9d3f61bae90a5b84de49fc09" translate="yes" xml:space="preserve">
          <source>True if SSL is used on this connection</source>
          <target state="translated">如果在此连接上使用SSL,则为真。</target>
        </trans-unit>
        <trans-unit id="73fc59a0dc7300971fbdc23724099ed0b896857f" translate="yes" xml:space="preserve">
          <source>True if an on-line exclusive backup is still in progress.</source>
          <target state="translated">如果在线专属备份仍在进行中,则为真。</target>
        </trans-unit>
        <trans-unit id="012e79baddd407b1c921d97d791e3cf55a10cb4d" translate="yes" xml:space="preserve">
          <source>True if constraint trigger is deferrable</source>
          <target state="translated">如果约束触发是可推迟的,则为真。</target>
        </trans-unit>
        <trans-unit id="8d2220de13bd9a2d96db7735aed49d6345d08164" translate="yes" xml:space="preserve">
          <source>True if constraint trigger is initially deferred</source>
          <target state="translated">如果约束触发器最初被推迟,则为真。</target>
        </trans-unit>
        <trans-unit id="23d7a2135b9ce4e46ed5cd1464346506b9a106a5" translate="yes" xml:space="preserve">
          <source>True if currently observing daylight savings</source>
          <target state="translated">如果目前实行夏令时,则为真。</target>
        </trans-unit>
        <trans-unit id="6c9e701104bae2b464c2020db78d7e9600016eaa" translate="yes" xml:space="preserve">
          <source>True if extension can be relocated to another schema</source>
          <target state="translated">如果扩展可以被重新定位到另一个模式,则为真。</target>
        </trans-unit>
        <trans-unit id="13194a8bcdf4e8395775186edb8919bbe57277d7" translate="yes" xml:space="preserve">
          <source>True if language is considered trusted</source>
          <target state="translated">如果语言被认为是可信的,则为真</target>
        </trans-unit>
        <trans-unit id="f48edc9cc0d1d8a7aedf7f448e48a3a8e2dfdc7e" translate="yes" xml:space="preserve">
          <source>True if language may be created by a database owner</source>
          <target state="translated">如果语言可以由数据库所有者创建,则为真。</target>
        </trans-unit>
        <trans-unit id="64e3a4a3dce2e5bcd672ebfd09e86521c286718f" translate="yes" xml:space="preserve">
          <source>True if lock is held, false if lock is awaited</source>
          <target state="translated">锁定时为真,等待时为假。</target>
        </trans-unit>
        <trans-unit id="3b6ef157f06387be075989a37f516c89a4bd0a37" translate="yes" xml:space="preserve">
          <source>True if lock was taken via fast path, false if taken via main lock table</source>
          <target state="translated">如果通过快速路径锁定,则为真;如果通过主锁表锁定,则为假。</target>
        </trans-unit>
        <trans-unit id="ad71d91044693983ff02d60ae2955e48c5fc2452" translate="yes" xml:space="preserve">
          <source>True if locker is a multitransaction</source>
          <target state="translated">如果锁定器是一个多交易,则为真。</target>
        </trans-unit>
        <trans-unit id="fda8e2d43deca4588633ff2520ae6d5cec5b396c" translate="yes" xml:space="preserve">
          <source>True if materialized view has (or recently had) any indexes</source>
          <target state="translated">如果物化视图有(或最近有)任何索引,则为真。</target>
        </trans-unit>
        <trans-unit id="0f8da21d8e6ff2b7a2076689ef9d08e87aef74dd" translate="yes" xml:space="preserve">
          <source>True if materialized view is currently populated</source>
          <target state="translated">如果当前填充的是物化视图,则为真。</target>
        </trans-unit>
        <trans-unit id="99506ea5356b9ad791ad9c495955d35220b0a84f" translate="yes" xml:space="preserve">
          <source>True if only superusers are allowed to install this extension</source>
          <target state="translated">如果只有超级用户可以安装此扩展,则为真。</target>
        </trans-unit>
        <trans-unit id="7438a25765f88fed7fec2543e2f22ba8fa0da65d" translate="yes" xml:space="preserve">
          <source>True if only superusers are allowed to install this extension (but see &lt;code&gt;trusted&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a35a480c8856109ea6f28e3f43d8363e78cf83fe" translate="yes" xml:space="preserve">
          <source>True if recovery is paused.</source>
          <target state="translated">暂停恢复时为真。</target>
        </trans-unit>
        <trans-unit id="f63f3a290f4cbaf52602d088d18db98a25a18728" translate="yes" xml:space="preserve">
          <source>True if recovery is still in progress.</source>
          <target state="translated">如果还在恢复中,则为真。</target>
        </trans-unit>
        <trans-unit id="952d1d48ba36745c7442261d09e7833e6a695b65" translate="yes" xml:space="preserve">
          <source>True if relation is populated (this is true for all relations other than some materialized views)</source>
          <target state="translated">如果关系被填充,则为真(除了一些物化视图外,所有关系都是如此)</target>
        </trans-unit>
        <trans-unit id="8415173c3c9124dc63f70c0e4fc258f7f25295a4" translate="yes" xml:space="preserve">
          <source>True if row level security (when enabled) will also apply to table owner; see &lt;a href=&quot;catalog-pg-policy&quot;&gt;&lt;code&gt;pg_policy&lt;/code&gt;&lt;/a&gt; catalog</source>
          <target state="translated">如果行级安全性（启用时）也适用于表所有者，则为true；否则为true。参见&lt;a href=&quot;catalog-pg-policy&quot;&gt; &lt;code&gt;pg_policy&lt;/code&gt; &lt;/a&gt;目录</target>
        </trans-unit>
        <trans-unit id="84b8ae8060dc19fffeb8070b76ac95ebd9162532" translate="yes" xml:space="preserve">
          <source>True if row security is enabled on the table</source>
          <target state="translated">如果表中的行安全被启用,则为真。</target>
        </trans-unit>
        <trans-unit id="c016f5a7ce842e21ac5e05ef1d678380be642aaa" translate="yes" xml:space="preserve">
          <source>True if table has (or once had) rules</source>
          <target state="translated">如果表有(或曾经有)规则,则为真。</target>
        </trans-unit>
        <trans-unit id="86d78d4068510676f3b29858a7d35e8046be10f2" translate="yes" xml:space="preserve">
          <source>True if table has (or once had) rules; see &lt;a href=&quot;catalog-pg-rewrite&quot;&gt;&lt;code&gt;pg_rewrite&lt;/code&gt;&lt;/a&gt; catalog</source>
          <target state="translated">如果表具有（或曾经具有）规则，则为true；否则为true。参见&lt;a href=&quot;catalog-pg-rewrite&quot;&gt; &lt;code&gt;pg_rewrite&lt;/code&gt; &lt;/a&gt;目录</target>
        </trans-unit>
        <trans-unit id="bbd3dd1777eb1a65592ad8111a5ec7282e029b6a" translate="yes" xml:space="preserve">
          <source>True if table has (or once had) triggers</source>
          <target state="translated">如果表有(或曾经有)触发器,则为真。</target>
        </trans-unit>
        <trans-unit id="232c6e9f5f95405c7928ec2722737febf663144a" translate="yes" xml:space="preserve">
          <source>True if table has (or once had) triggers; see &lt;a href=&quot;catalog-pg-trigger&quot;&gt;&lt;code&gt;pg_trigger&lt;/code&gt;&lt;/a&gt; catalog</source>
          <target state="translated">如果表具有（或曾经具有）触发器，则为true；否则为true。参见&lt;a href=&quot;catalog-pg-trigger&quot;&gt; &lt;code&gt;pg_trigger&lt;/code&gt; &lt;/a&gt;目录</target>
        </trans-unit>
        <trans-unit id="66b69b4d62a4378bccf42a60097c0c71c291ce56" translate="yes" xml:space="preserve">
          <source>True if table has (or recently had) any indexes</source>
          <target state="translated">如果表有(或最近有)任何索引,则为真。</target>
        </trans-unit>
        <trans-unit id="e7bd1fe139d42d7b1519b72cb282ee9cb54850bb" translate="yes" xml:space="preserve">
          <source>True if table has row level security enabled; see &lt;a href=&quot;catalog-pg-policy&quot;&gt;&lt;code&gt;pg_policy&lt;/code&gt;&lt;/a&gt; catalog</source>
          <target state="translated">如果表启用了行级安全性，则为true；否则为false。参见&lt;a href=&quot;catalog-pg-policy&quot;&gt; &lt;code&gt;pg_policy&lt;/code&gt; &lt;/a&gt;目录</target>
        </trans-unit>
        <trans-unit id="955515f99b28aae950e8f042fb8a268a1914bd68" translate="yes" xml:space="preserve">
          <source>True if table or index has (or once had) any inheritance children</source>
          <target state="translated">如果表或索引有(或曾经有)任何继承子代,则为真。</target>
        </trans-unit>
        <trans-unit id="a519990c88d7093181aaba6f5c8906c338ebda6d" translate="yes" xml:space="preserve">
          <source>True if table or index is a partition</source>
          <target state="translated">如果表或索引是一个分区,则为真</target>
        </trans-unit>
        <trans-unit id="6faf5538e123802b74af773b1f794f3bde782ef0" translate="yes" xml:space="preserve">
          <source>True if the current role has superuser privileges.</source>
          <target state="translated">如果当前角色有超级用户权限,则为真。</target>
        </trans-unit>
        <trans-unit id="49c5deda46593d87b8da1a0a8664bee6e99c35a8" translate="yes" xml:space="preserve">
          <source>True if the extension can be installed by non-superusers with appropriate privileges</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42ccdc48d1316985de4ceff096fc1090b18ac5fc" translate="yes" xml:space="preserve">
          <source>True if the rule is an &lt;code&gt;INSTEAD&lt;/code&gt; rule</source>
          <target state="translated">如果规则是 &lt;code&gt;INSTEAD&lt;/code&gt; 规则，则为True</target>
        </trans-unit>
        <trans-unit id="cb4d292a249d96e18b80c58763a501bbad7d05de" translate="yes" xml:space="preserve">
          <source>True if the type is a preferred cast target within its &lt;code&gt;typcategory&lt;/code&gt;</source>
          <target state="translated">如果类型是其类型中的首选 &lt;code&gt;typcategory&lt;/code&gt; 目标，则为True</target>
        </trans-unit>
        <trans-unit id="c404ccf3e65aa528ab96ca3872357652195dd689" translate="yes" xml:space="preserve">
          <source>True if the type is defined, false if this is a placeholder entry for a not-yet-defined type. When &lt;code&gt;typisdefined&lt;/code&gt; is false, nothing except the type name, namespace, and OID can be relied on.</source>
          <target state="translated">如果定义了类型，则为true；如果这是尚未定义的类型的占位符条目，则为false。如果 &lt;code&gt;typisdefined&lt;/code&gt; 为false，则除了类型名称，名称空间和OID之外，别无其他依赖。</target>
        </trans-unit>
        <trans-unit id="bf25c33cad22135a1491bee944b6f10caae211df" translate="yes" xml:space="preserve">
          <source>True if the value can be applied successfully</source>
          <target state="translated">如果该值可以成功应用,则为真</target>
        </trans-unit>
        <trans-unit id="32b0c20ba6a36c06232673842b1188efcec879d2" translate="yes" xml:space="preserve">
          <source>True if this is a daylight-savings abbreviation</source>
          <target state="translated">如果这是夏令时的缩写,则为真。</target>
        </trans-unit>
        <trans-unit id="36393d0a0fd9ddbaafe14fa3d4329cc46ba38ce7" translate="yes" xml:space="preserve">
          <source>True if this is a table and it has (or recently had) any indexes</source>
          <target state="translated">如果这是一个表,并且它有(或最近有)任何索引,则为真。</target>
        </trans-unit>
        <trans-unit id="26ed87abfb4393c79c8c847eb10dc8103b4a50c1" translate="yes" xml:space="preserve">
          <source>True if this is a temporary replication slot. Temporary slots are not saved to disk and are automatically dropped on error or when the session has finished.</source>
          <target state="translated">如果这是一个临时复制槽,则为真。临时插槽不会保存在磁盘上,并在出错或会话结束时自动放弃。</target>
        </trans-unit>
        <trans-unit id="ef96945409922985d107491ffa09903856c28a62" translate="yes" xml:space="preserve">
          <source>True if this is a trusted language, which means that it is believed not to grant access to anything outside the normal SQL execution environment. Only superusers can create functions in untrusted languages.</source>
          <target state="translated">如果这是一种受信任的语言,这意味着相信它不会授予对正常的SQL执行环境之外的任何东西的访问权,则为真。只有超级用户可以用不信任的语言创建函数。</target>
        </trans-unit>
        <trans-unit id="c204724b18388c85e2216fcb59a67a33fb072e1d" translate="yes" xml:space="preserve">
          <source>True if this is the default conversion</source>
          <target state="translated">如果这是默认的转换,则为真</target>
        </trans-unit>
        <trans-unit id="965b2818c43a8348e19c577671df21f2fc196f83" translate="yes" xml:space="preserve">
          <source>True if this operator class is the default for &lt;code&gt;opcintype&lt;/code&gt;</source>
          <target state="translated">如果此操作符类是 &lt;code&gt;opcintype&lt;/code&gt; 的默认值，则为True</target>
        </trans-unit>
        <trans-unit id="3bd82801197995cc7c2f18df7e169fd34abd4933" translate="yes" xml:space="preserve">
          <source>True if this slot is currently actively being used</source>
          <target state="translated">如果此插槽目前正在使用,则为真。</target>
        </trans-unit>
        <trans-unit id="df76a619896b77be64d0f3cb65694575b20c8bda" translate="yes" xml:space="preserve">
          <source>True if this table is shared across all databases in the cluster. Only certain system catalogs (such as &lt;code&gt;pg_database&lt;/code&gt;) are shared.</source>
          <target state="translated">如果此表在集群中的所有数据库之间共享，则为True。仅共享某些系统目录（例如 &lt;code&gt;pg_database&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="00d7d10a299138dca72b8e64f880eb593bd8c0c1" translate="yes" xml:space="preserve">
          <source>True if this type is a preferred type within its type category, else false. The default is false. Be very careful about creating a new preferred type within an existing type category, as this could cause surprising changes in behavior.</source>
          <target state="translated">如果该类型是其类型类别中的首选类型,则为true,否则为false。默认为false。在现有的类型类别中创建一个新的首选类型时要非常小心,因为这可能会导致令人惊讶的行为变化。</target>
        </trans-unit>
        <trans-unit id="9def5bf7a41790ac3b8e30f1fc70c1fdbb898bec" translate="yes" xml:space="preserve">
          <source>True if this type's operations can use collation information. The default is false.</source>
          <target state="translated">如果该类型的操作可以使用整理信息,则为true。默认为false。</target>
        </trans-unit>
        <trans-unit id="e0ad09cb04969121b61e35716b0db046d9cadd81" translate="yes" xml:space="preserve">
          <source>True if this version of this extension is currently installed</source>
          <target state="translated">如果当前安装了该扩展的这个版本,则为真。</target>
        </trans-unit>
        <trans-unit id="ab9af1736eb3931ab0baf9949ee8108e0d2bfebd" translate="yes" xml:space="preserve">
          <source>True if trigger is internally generated (usually, to enforce the constraint identified by &lt;code&gt;tgconstraint&lt;/code&gt;)</source>
          <target state="translated">如果在内部生成触发器，则为True（通常是为了强制执行 &lt;code&gt;tgconstraint&lt;/code&gt; 标识的约束）</target>
        </trans-unit>
        <trans-unit id="5ca548743e2786b08e3fd52b9381c1735b9c020c" translate="yes" xml:space="preserve">
          <source>True to pass extra dummy arguments to &lt;code&gt;aggfinalfn&lt;/code&gt;</source>
          <target state="translated">将多余的伪参数传递给 &lt;code&gt;aggfinalfn&lt;/code&gt; 为True</target>
        </trans-unit>
        <trans-unit id="164596b2be84a485eca692d6a04580df3d74a2aa" translate="yes" xml:space="preserve">
          <source>True to pass extra dummy arguments to &lt;code&gt;aggmfinalfn&lt;/code&gt;</source>
          <target state="translated">将多余的伪参数传递给 &lt;code&gt;aggmfinalfn&lt;/code&gt; 为True</target>
        </trans-unit>
        <trans-unit id="6d4ee65593919418e1bd8e29f7e952e96736cb58" translate="yes" xml:space="preserve">
          <source>Truncate the table &lt;code&gt;othertable&lt;/code&gt;, and cascade to any tables that reference &lt;code&gt;othertable&lt;/code&gt; via foreign-key constraints:</source>
          <target state="translated">截断表 &lt;code&gt;othertable&lt;/code&gt; 和级联引用任何表 &lt;code&gt;othertable&lt;/code&gt; 通过外键约束：</target>
        </trans-unit>
        <trans-unit id="1dc17db6052d197657f4b66cc0edb567325a2bbb" translate="yes" xml:space="preserve">
          <source>Truncate the tables &lt;code&gt;bigtable&lt;/code&gt; and &lt;code&gt;fattable&lt;/code&gt;:</source>
          <target state="translated">截断 &lt;code&gt;bigtable&lt;/code&gt; 和 &lt;code&gt;fattable&lt;/code&gt; 表：</target>
        </trans-unit>
        <trans-unit id="00f1193a7fa78df4b4d56560c05dd84766a6e43f" translate="yes" xml:space="preserve">
          <source>Truncate to specified precision in the specified time zone; see &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-TRUNC&quot;&gt;Section 9.9.2&lt;/a&gt;</source>
          <target state="translated">在指定的时区中将其截断为指定的精度；见&lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-TRUNC&quot;&gt;9.9.2节&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="be6b9181b48ae3b21719c3424b9df5c25e4cf704" translate="yes" xml:space="preserve">
          <source>Truncate to specified precision; see &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-TRUNC&quot;&gt;Section 9.9.2&lt;/a&gt;</source>
          <target state="translated">截断为指定的精度；见&lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-TRUNC&quot;&gt;9.9.2节&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f15d827fb86d12905958801116bae0132b24288b" translate="yes" xml:space="preserve">
          <source>Truncates &lt;em&gt;&lt;code&gt;v&lt;/code&gt;&lt;/em&gt; to &lt;em&gt;&lt;code&gt;s&lt;/code&gt;&lt;/em&gt; decimal places</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20d769e0b499920cf570c76fa726c85ce63bdb4b" translate="yes" xml:space="preserve">
          <source>Truncates the visibility map for the given relation. This function is useful if you believe that the visibility map for the relation is corrupt and wish to force rebuilding it. The first &lt;code&gt;VACUUM&lt;/code&gt; executed on the given relation after this function is executed will scan every page in the relation and rebuild the visibility map. (Until that is done, queries will treat the visibility map as containing all zeroes.)</source>
          <target state="translated">截断给定关系的可见性图。如果您认为该关系的可见性图已损坏并且希望强制重建它，则此功能很有用。执行此功能后，在给定关系上执行的第一个 &lt;code&gt;VACUUM&lt;/code&gt; 将扫描关系中的每个页面并重建可见性图。 （在此之前，查询将可视性映射表视为包含所有零。）</target>
        </trans-unit>
        <trans-unit id="f44660614a2ee1a0637096613f6651f9ec6d18c3" translate="yes" xml:space="preserve">
          <source>Truncates to integer (towards zero)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fc0100312a64373efd7c390d92763a84341669f" translate="yes" xml:space="preserve">
          <source>Trust Authentication</source>
          <target state="translated">信任认证</target>
        </trans-unit>
        <trans-unit id="6525fd8384c1b1a98745cafdc4fe870534c5b3c9" translate="yes" xml:space="preserve">
          <source>Trust both system and database administrator.</source>
          <target state="translated">同时信任系统和数据库管理员。</target>
        </trans-unit>
        <trans-unit id="0303d1058ff834ee7d3f9e41bfb45de83313adee" translate="yes" xml:space="preserve">
          <source>Trusted procedures are similar to security definer functions or setuid commands. SELinux provides a feature to allow trusted code to run using a security label different from that of the client, generally for the purpose of providing highly controlled access to sensitive data (e.g. rows might be omitted, or the precision of stored values might be reduced). Whether or not a function acts as a trusted procedure is controlled by its security label and the operating system security policy. For example:</source>
          <target state="translated">可信程序类似于安全定义器函数或setuid命令。SELinux提供了一个功能,允许受信任的代码使用不同于客户端的安全标签运行,通常是为了对敏感数据提供高度控制的访问(例如,行可能被省略,或者存储值的精度可能被降低)。一个函数是否作为受信任的存储过程是由它的安全标签和操作系统的安全策略控制的。例如:</target>
        </trans-unit>
        <trans-unit id="16d4cf557b86ec41315e510d2c0a1e98aa461ec5" translate="yes" xml:space="preserve">
          <source>Trusted procedures are similar to security definer functions or setuid commands. SELinux provides a feature to allow trusted code to run using a security label different from that of the client, generally for the purpose of providing highly controlled access to sensitive data (e.g., rows might be omitted, or the precision of stored values might be reduced). Whether or not a function acts as a trusted procedure is controlled by its security label and the operating system security policy. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dda25f309687ab89f219c2e9ed7108ec29e77f02" translate="yes" xml:space="preserve">
          <source>Try to parse WAL files stored in the specified directory, rather than in &lt;code&gt;pg_wal&lt;/code&gt;. This may be useful if the backup is stored in a separate location from the WAL archive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66a91624c0de6e82ae0fef2e1f06a35f0bd22897" translate="yes" xml:space="preserve">
          <source>Trying to update the same row twice in a single statement is not supported. Only one of the modifications takes place, but it is not easy (and sometimes not possible) to reliably predict which one. This also applies to deleting a row that was already updated in the same statement: only the update is performed. Therefore you should generally avoid trying to modify a single row twice in a single statement. In particular avoid writing &lt;code&gt;WITH&lt;/code&gt; sub-statements that could affect the same rows changed by the main statement or a sibling sub-statement. The effects of such a statement will not be predictable.</source>
          <target state="translated">不支持在单个语句中尝试两次更新同一行。只有一种修改发生，但要可靠地预测哪一种修改并不容易（有时甚至是不可能）。这也适用于删除同一条语句中已更新的行：仅执行更新。因此，通常应避免在单个语句中尝试两次修改单个行。特别要避免编写 &lt;code&gt;WITH&lt;/code&gt; 子语句，这可能会影响由主语句或同级子语句更改的同一行。这种陈述的影响是不可预测的。</target>
        </trans-unit>
        <trans-unit id="b26f6753852a596fe51a0b24ba50ca61c0a5cc05" translate="yes" xml:space="preserve">
          <source>Tsearch2 Development Site &lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/tsearch/V2/&quot;&gt;http://www.sai.msu.su/~megera/postgres/gist/tsearch/V2/&lt;/a&gt;</source>
          <target state="translated">Tsearch2开发站点&lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/tsearch/V2/&quot;&gt;http://www.sai.msu.su/~megera/postgres/gist/tsearch/V2/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cfb00a997a076b71d83b496d4907048db3c803c8" translate="yes" xml:space="preserve">
          <source>Tue, Tues</source>
          <target state="translated">星期二,星期二</target>
        </trans-unit>
        <trans-unit id="42e43b612a5dfae57ddf5929f0fb945ae83cbf61" translate="yes" xml:space="preserve">
          <source>Tuesday</source>
          <target state="translated">Tuesday</target>
        </trans-unit>
        <trans-unit id="c41a2be51027c17da2914785c19c9af65da7231f" translate="yes" xml:space="preserve">
          <source>Tuple</source>
          <target state="translated">Tuple</target>
        </trans-unit>
        <trans-unit id="de9422afddf78236a21b50c7a1aae8eadf26c4b6" translate="yes" xml:space="preserve">
          <source>Tuple ID (TID) of locked row</source>
          <target state="translated">锁定行的元组ID(TID)。</target>
        </trans-unit>
        <trans-unit id="a288c729f3b11b14057ff94886b8d82b1b114cb1" translate="yes" xml:space="preserve">
          <source>Tuple Identifier</source>
          <target state="translated">元组标识符</target>
        </trans-unit>
        <trans-unit id="7f26ca0c5d69bec575e9ec24eeec65dfcec7bd62" translate="yes" xml:space="preserve">
          <source>Tuple deforming is the process of transforming an on-disk tuple (see &lt;a href=&quot;storage-page-layout#STORAGE-TUPLE-LAYOUT&quot;&gt;Section 68.6.1&lt;/a&gt;) into its in-memory representation. It can be accelerated by creating a function specific to the table layout and the number of columns to be extracted.</source>
          <target state="translated">元组变形是将磁盘上的元组（请参见&lt;a href=&quot;storage-page-layout#STORAGE-TUPLE-LAYOUT&quot;&gt;第68.6.1节&lt;/a&gt;）转换为其内存中表示的过程。通过创建特定于表布局和要提取的列数的函数可以加快此过程。</target>
        </trans-unit>
        <trans-unit id="86e46b735d6cd66502b1333be16b366c854a2020" translate="yes" xml:space="preserve">
          <source>Tuple number targeted by the lock within the page, or null if the target is not a tuple</source>
          <target state="translated">锁定在页面内的元组编号,如果目标不是元组,则为空。</target>
        </trans-unit>
        <trans-unit id="538a8ce3fbdcaee00a14353bd57bcf3600c6e0d0" translate="yes" xml:space="preserve">
          <source>Tuples</source>
          <target state="translated">Tuples</target>
        </trans-unit>
        <trans-unit id="ab650a1a4b8fdf3a4053ce8d277d335dd82e5447" translate="yes" xml:space="preserve">
          <source>Turkish</source>
          <target state="translated">Turkish</target>
        </trans-unit>
        <trans-unit id="f4049144a6e32c443901c30714628293045b3669" translate="yes" xml:space="preserve">
          <source>Turn off &lt;a href=&quot;runtime-config-wal#GUC-FSYNC&quot;&gt;fsync&lt;/a&gt;; there is no need to flush data to disk.</source>
          <target state="translated">关闭&lt;a href=&quot;runtime-config-wal#GUC-FSYNC&quot;&gt;fsync&lt;/a&gt; ; 无需将数据刷新到磁盘。</target>
        </trans-unit>
        <trans-unit id="bd6d343fd0c3083f0c7e90c0e461974b687534bf" translate="yes" xml:space="preserve">
          <source>Turn off &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt;; there is no need to guard against partial page writes.</source>
          <target state="translated">关闭&lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; ; 无需防止部分页面写入。</target>
        </trans-unit>
        <trans-unit id="df8b7a87a09ca0a552f551d1eb119e7c2b44535c" translate="yes" xml:space="preserve">
          <source>Turn off &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt;; there might be no need to force WAL writes to disk on every commit. This setting does risk transaction loss (though not data corruption) in case of a crash of the &lt;em&gt;database&lt;/em&gt;.</source>
          <target state="translated">关闭&lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;sync_commit&lt;/a&gt; ; 可能不需要在每次提交时都强制将WAL写到磁盘。如果&lt;em&gt;数据库&lt;/em&gt;崩溃，此设置会带来事务丢失（但不会破坏数据）的风险。</target>
        </trans-unit>
        <trans-unit id="c25473f6f439ed3d685a7fc2f4053fbeaf6af493" translate="yes" xml:space="preserve">
          <source>Turn off printing of column names and result row count footers, etc. This is equivalent to &lt;code&gt;\t&lt;/code&gt; or &lt;code&gt;\pset tuples_only&lt;/code&gt;.</source>
          <target state="translated">关闭列名称和结果行计数页脚等的打印。这等效于 &lt;code&gt;\t&lt;/code&gt; 或 &lt;code&gt;\pset tuples_only&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c452943219408586e340ca7eae9dc9861f0212c" translate="yes" xml:space="preserve">
          <source>Turn on autocommit of transactions. In this mode, each SQL command is automatically committed unless it is inside an explicit transaction block. In the default mode, commands are committed only when &lt;code&gt;EXEC SQL COMMIT&lt;/code&gt; is issued.</source>
          <target state="translated">打开事务自动提交。在这种模式下，每个SQL命令都将自动提交，除非它在显式事务块内。在默认模式下，仅在发出 &lt;code&gt;EXEC SQL COMMIT&lt;/code&gt; 时提交命令。</target>
        </trans-unit>
        <trans-unit id="082802bc6506a1fb8c80b6b9796c7710bdeb3763" translate="yes" xml:space="preserve">
          <source>Turn on the expanded table formatting mode. This is equivalent to &lt;code&gt;\x&lt;/code&gt; or &lt;code&gt;\pset expanded&lt;/code&gt;.</source>
          <target state="translated">打开扩展的表格格式设置模式。这等效于 &lt;code&gt;\x&lt;/code&gt; 或 &lt;code&gt;\pset expanded&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="11fbfd634f8b43b8d0336222eeb84c04d42fc674" translate="yes" xml:space="preserve">
          <source>Turning &lt;code&gt;deduplicate_items&lt;/code&gt; off via &lt;code&gt;ALTER INDEX&lt;/code&gt; prevents future insertions from triggering deduplication, but does not in itself make existing posting list tuples use the standard tuple representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ac524768d250e29de07aaee53faeda03896b32c" translate="yes" xml:space="preserve">
          <source>Turning &lt;code&gt;fastupdate&lt;/code&gt; off via &lt;code&gt;ALTER INDEX&lt;/code&gt; prevents future insertions from going into the list of pending index entries, but does not in itself flush previous entries. You might want to &lt;code&gt;VACUUM&lt;/code&gt; the table or call &lt;code&gt;gin_clean_pending_list&lt;/code&gt; function afterward to ensure the pending list is emptied.</source>
          <target state="translated">谈到 &lt;code&gt;fastupdate&lt;/code&gt; 关闭通过 &lt;code&gt;ALTER INDEX&lt;/code&gt; 防止未来的插入而进入待定索引条目列表，但其本身冲洗以前的条目没有。您可能想对表进行 &lt;code&gt;VACUUM&lt;/code&gt; 或事后调用 &lt;code&gt;gin_clean_pending_list&lt;/code&gt; 函数，以确保清空待处理列表。</target>
        </trans-unit>
        <trans-unit id="f12445322d4c10bb21d0f4cf2ccb90ed3605df43" translate="yes" xml:space="preserve">
          <source>Turning off this parameter does not affect use of WAL archiving for point-in-time recovery (PITR) (see &lt;a href=&quot;continuous-archiving&quot;&gt;Section 25.3&lt;/a&gt;).</source>
          <target state="translated">禁用此参数不会影响使用WAL归档进行时间点恢复（PITR）（请参阅&lt;a href=&quot;continuous-archiving&quot;&gt;第25.3节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1686b206d7cc35bb7f5514f93be0cb2800c13338" translate="yes" xml:space="preserve">
          <source>Turning this parameter off speeds normal operation, but might lead to either unrecoverable data corruption, or silent data corruption, after a system failure. The risks are similar to turning off &lt;code&gt;fsync&lt;/code&gt;, though smaller, and it should be turned off only based on the same circumstances recommended for that parameter.</source>
          <target state="translated">禁用此参数可加快正常操作的速度，但在系统故障后可能会导致不可恢复的数据损坏或静默数据损坏。风险与关闭 &lt;code&gt;fsync&lt;/code&gt; 相似，尽管较小，但仅应根据针对该参数建议的相同情况将其关闭。</target>
        </trans-unit>
        <trans-unit id="93c364b56baaa4f87c84df84869c49e931e78c4b" translate="yes" xml:space="preserve">
          <source>Turning this parameter on can reduce the WAL volume without increasing the risk of unrecoverable data corruption, but at the cost of some extra CPU spent on the compression during WAL logging and on the decompression during WAL replay.</source>
          <target state="translated">开启这个参数可以减少WAL体积,而不会增加不可恢复的数据损坏的风险,但代价是在WAL记录期间的压缩和WAL重放期间的解压缩上花费一些额外的CPU。</target>
        </trans-unit>
        <trans-unit id="1fbf2fe24b1539aa2687ce60e2adbf515dad4763" translate="yes" xml:space="preserve">
          <source>Turns on HTML query output format. If the HTML format is already on, it is switched back to the default aligned text format. This command is for compatibility and convenience, but see &lt;code&gt;\pset&lt;/code&gt; about setting other output options.</source>
          <target state="translated">打开HTML查询输出格式。如果HTML格式已打开，则将其切换回默认的对齐文本格式。此命令是为了兼容性和方便起见，但有关设置其他输出选项的信息，请参见 &lt;code&gt;\pset&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2dd2e8d41b109545398675ecaa4d48e806818d15" translate="yes" xml:space="preserve">
          <source>Tutorial: Advanced Features</source>
          <target state="translated">教程。高级功能</target>
        </trans-unit>
        <trans-unit id="462c9e67f015d8940f17ef1bf7e40741a0bcf586" translate="yes" xml:space="preserve">
          <source>Tutorial: Getting Started</source>
          <target state="translated">教程。入门</target>
        </trans-unit>
        <trans-unit id="2d479f44cf7a48c33abced080cd7b547c6bd3a7b" translate="yes" xml:space="preserve">
          <source>Tutorial: The SQL Language</source>
          <target state="translated">教程。SQL语言</target>
        </trans-unit>
        <trans-unit id="d96f74ad720891d7859b479263f4e39be9378130" translate="yes" xml:space="preserve">
          <source>Two GiST index operator classes are provided: &lt;code&gt;gist__int_ops&lt;/code&gt; (used by default) is suitable for small- to medium-size data sets, while &lt;code&gt;gist__intbig_ops&lt;/code&gt; uses a larger signature and is more suitable for indexing large data sets (i.e., columns containing a large number of distinct array values). The implementation uses an RD-tree data structure with built-in lossy compression.</source>
          <target state="translated">提供了两种GiST索引运算符类： &lt;code&gt;gist__int_ops&lt;/code&gt; （默认使用）适用于中小型数据集，而 &lt;code&gt;gist__intbig_ops&lt;/code&gt; 使用较大的签名，更适用于索引大型数据集（即包含大量数据集的列）不同的数组值）。该实现使用带有内置有损压缩的RD树数据结构。</target>
        </trans-unit>
        <trans-unit id="fd21e98bab637ed7f2ea4e4b5c263e9096bd942d" translate="yes" xml:space="preserve">
          <source>Two functions are considered the same if they have the same names and &lt;em&gt;input&lt;/em&gt; argument types, ignoring any &lt;code&gt;OUT&lt;/code&gt; parameters. Thus for example these declarations conflict:</source>
          <target state="translated">如果两个函数具有相同的名称和&lt;em&gt;输入&lt;/em&gt;参数类型，而忽略任何 &lt;code&gt;OUT&lt;/code&gt; 参数，则认为它们是相同的。因此，例如，这些声明冲突：</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
