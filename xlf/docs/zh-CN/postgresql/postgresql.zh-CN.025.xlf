<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="1daf3db24fd8109b791952bf2bea84cc95a73e77" translate="yes" xml:space="preserve">
          <source>Two parameterized GiST index operator classes are provided: &lt;code&gt;gist__int_ops&lt;/code&gt; (used by default) is suitable for small- to medium-size data sets, while &lt;code&gt;gist__intbig_ops&lt;/code&gt; uses a larger signature and is more suitable for indexing large data sets (i.e., columns containing a large number of distinct array values). The implementation uses an RD-tree data structure with built-in lossy compression.</source>
          <target state="translated">提供了两个参数化的GiST索引运算符类： &lt;code&gt;gist__int_ops&lt;/code&gt; （默认使用）适用于中小型数据集，而 &lt;code&gt;gist__intbig_ops&lt;/code&gt; 使用较大的签名，更适用于索引大型数据集（即包含大量数字的列）不同的数组值）。该实现使用带有内置有损压缩的RD树数据结构。</target>
        </trans-unit>
        <trans-unit id="662248ac968d8ab661b9569a6e6849ae788e24f8" translate="yes" xml:space="preserve">
          <source>Two significant incompatibilities exist between AREs and the ERE syntax recognized by pre-7.4 releases of PostgreSQL:</source>
          <target state="translated">在ARES和PostgreSQL 7.4之前的版本所识别的ERE语法之间存在两个重要的不兼容性。</target>
        </trans-unit>
        <trans-unit id="6a32f2ed2800b3a048eac6f3c98ed4d6f0004a87" translate="yes" xml:space="preserve">
          <source>Two string constants that are only separated by whitespace &lt;em&gt;with at least one newline&lt;/em&gt; are concatenated and effectively treated as if the string had been written as one constant. For example:</source>
          <target state="translated">将仅用空格&lt;em&gt;和至少一个换行符&lt;/em&gt;分隔的两个字符串常量进行连接，并有效地将其视为已将字符串写为一个常量。例如：</target>
        </trans-unit>
        <trans-unit id="90b63e2a4e205cf20d0c53869ecd885349050bdf" translate="yes" xml:space="preserve">
          <source>Two tablespaces are automatically created when the database cluster is initialized. The &lt;code&gt;pg_global&lt;/code&gt; tablespace is used for shared system catalogs. The &lt;code&gt;pg_default&lt;/code&gt; tablespace is the default tablespace of the &lt;code&gt;template1&lt;/code&gt; and &lt;code&gt;template0&lt;/code&gt; databases (and, therefore, will be the default tablespace for other databases as well, unless overridden by a &lt;code&gt;TABLESPACE&lt;/code&gt; clause in &lt;code&gt;CREATE DATABASE&lt;/code&gt;).</source>
          <target state="translated">初始化数据库集群时，将自动创建两个表空间。所述 &lt;code&gt;pg_global&lt;/code&gt; 表空间用于共享系统目录。所述 &lt;code&gt;pg_default&lt;/code&gt; 表是的缺省表 &lt;code&gt;template1&lt;/code&gt; 和 &lt;code&gt;template0&lt;/code&gt; 中数据库（和，因此，对于其它的数据库中的缺省表，除非通过重写 &lt;code&gt;TABLESPACE&lt;/code&gt; 子句中 &lt;code&gt;CREATE DATABASE&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c5b854b5685b242cd142ae86c5c04afbc5fc30b6" translate="yes" xml:space="preserve">
          <source>Two types can be &lt;em&gt;binary coercible&lt;/em&gt;, which means that the conversion can be performed &amp;ldquo;for free&amp;rdquo; without invoking any function. This requires that corresponding values use the same internal representation. For instance, the types &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;varchar&lt;/code&gt; are binary coercible both ways. Binary coercibility is not necessarily a symmetric relationship. For example, the cast from &lt;code&gt;xml&lt;/code&gt; to &lt;code&gt;text&lt;/code&gt; can be performed for free in the present implementation, but the reverse direction requires a function that performs at least a syntax check. (Two types that are binary coercible both ways are also referred to as binary compatible.)</source>
          <target state="translated">两种类型可以是&lt;em&gt;二进制强制的&lt;/em&gt;，这意味着可以&amp;ldquo;免费&amp;rdquo;执行转换而无需调用任何功能。这要求相应的值使用相同的内部表示形式。例如， &lt;code&gt;text&lt;/code&gt; 和 &lt;code&gt;varchar&lt;/code&gt; 类型都是二进制可强制的。二进制强制性不一定是对称关系。例如，在本实现中，可以免费执行从 &lt;code&gt;xml&lt;/code&gt; 到 &lt;code&gt;text&lt;/code&gt; ，但是相反的方向需要至少执行语法检查的功能。 （两种都可以二进制强制的类型也称为二进制兼容。）</target>
        </trans-unit>
        <trans-unit id="51632bd25b09e4b06271cc8939c29fce73a7a60c" translate="yes" xml:space="preserve">
          <source>Two useful flags exist in &lt;code&gt;pg_database&lt;/code&gt; for each database: the columns &lt;code&gt;datistemplate&lt;/code&gt; and &lt;code&gt;datallowconn&lt;/code&gt;. &lt;code&gt;datistemplate&lt;/code&gt; can be set to indicate that a database is intended as a template for &lt;code&gt;CREATE DATABASE&lt;/code&gt;. If this flag is set, the database can be cloned by any user with &lt;code&gt;CREATEDB&lt;/code&gt; privileges; if it is not set, only superusers and the owner of the database can clone it. If &lt;code&gt;datallowconn&lt;/code&gt; is false, then no new connections to that database will be allowed (but existing sessions are not terminated simply by setting the flag false). The &lt;code&gt;template0&lt;/code&gt; database is normally marked &lt;code&gt;datallowconn = false&lt;/code&gt; to prevent its modification. Both &lt;code&gt;template0&lt;/code&gt; and &lt;code&gt;template1&lt;/code&gt; should always be marked with &lt;code&gt;datistemplate = true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_database&lt;/code&gt; 中对于每个数据库都有两个有用的标志： &lt;code&gt;datistemplate&lt;/code&gt; 和 &lt;code&gt;datallowconn&lt;/code&gt; 列。可以将 &lt;code&gt;datistemplate&lt;/code&gt; 设置为指示数据库打算用作 &lt;code&gt;CREATE DATABASE&lt;/code&gt; 的模板。如果设置了此标志，则任何具有 &lt;code&gt;CREATEDB&lt;/code&gt; 特权的用户都可以克隆该数据库；如果未设置，则只有超级用户和数据库所有者才能克隆它。如果 &lt;code&gt;datallowconn&lt;/code&gt; 为false，则将不允许与该数据库建立新连接（但不能仅通过将标志设置为false来终止现有会话）。所述 &lt;code&gt;template0&lt;/code&gt; 中数据库通常标记 &lt;code&gt;datallowconn = false&lt;/code&gt; 以防止其修改。无论 &lt;code&gt;template0&lt;/code&gt; 中和 &lt;code&gt;template1&lt;/code&gt; 应该总是被打上 &lt;code&gt;datistemplate = true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ba8214ba00d79461864d0001c2912a5c18b7b9a" translate="yes" xml:space="preserve">
          <source>Two-phase commit commands - &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt;, &lt;code&gt;COMMIT PREPARED&lt;/code&gt;, &lt;code&gt;ROLLBACK PREPARED&lt;/code&gt; because even read-only transactions need to write WAL in the prepare phase (the first phase of two phase commit).</source>
          <target state="translated">两阶段提交命令 &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; ， &lt;code&gt;COMMIT PREPARED&lt;/code&gt; ， &lt;code&gt;ROLLBACK PREPARED&lt;/code&gt; ,因为即使是只读事务也需要在准备阶段（两阶段提交的第一阶段）写入WAL。</target>
        </trans-unit>
        <trans-unit id="2e2bfc913787b0e6ea8551f81e2791cd42f7a318" translate="yes" xml:space="preserve">
          <source>Two-phase commit commands: &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt;, &lt;code&gt;COMMIT PREPARED&lt;/code&gt;, &lt;code&gt;ROLLBACK PREPARED&lt;/code&gt; because even read-only transactions need to write WAL in the prepare phase (the first phase of two phase commit).</source>
          <target state="translated">两阶段提交命令： &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; ， &lt;code&gt;COMMIT PREPARED&lt;/code&gt; ， &lt;code&gt;ROLLBACK PREPARED&lt;/code&gt; ,因为即使是只读事务也需要在准备阶段（两阶段提交的第一阶段）写入WAL。</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="caa2352205156323130852be37f36d8839e386c6" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;ltree&lt;/code&gt; has the usual comparison operators &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;. Comparison sorts in the order of a tree traversal, with the children of a node sorted by label text. In addition, the specialized operators shown in &lt;a href=&quot;ltree#LTREE-OP-TABLE&quot;&gt;Table F.13&lt;/a&gt; are available.</source>
          <target state="translated">&lt;code&gt;ltree&lt;/code&gt; 类型具有通常的比较运算符 &lt;code&gt;=&lt;/code&gt; ， &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;=&lt;/code&gt; ， &lt;code&gt;&amp;gt;=&lt;/code&gt; 。比较按树遍历的顺序排序，节点的子级按标签文本排序。此外，还有&lt;a href=&quot;ltree#LTREE-OP-TABLE&quot;&gt;表F.13&lt;/a&gt;中所示的专门运算符。</target>
        </trans-unit>
        <trans-unit id="5e1573953474c6c0a25673b1f064154b46a8a93e" translate="yes" xml:space="preserve">
          <source>Type Conversion</source>
          <target state="translated">类型转换</target>
        </trans-unit>
        <trans-unit id="0f621c80a40b4c3bb2242b9a8d5ab32c97b28181" translate="yes" xml:space="preserve">
          <source>Type modifier input function, or 0 if type does not support modifiers</source>
          <target state="translated">类型修饰输入函数,如果类型不支持修饰,则为0。</target>
        </trans-unit>
        <trans-unit id="49427798b611e70520545325588242b32904d7b8" translate="yes" xml:space="preserve">
          <source>Type modifier output function, or 0 to use the standard format</source>
          <target state="translated">类型修饰输出功能,或0使用标准格式。</target>
        </trans-unit>
        <trans-unit id="13f4f7c42905c25fa5436f830df968dd5cfd652c" translate="yes" xml:space="preserve">
          <source>Type of connection</source>
          <target state="translated">连接类型</target>
        </trans-unit>
        <trans-unit id="4a864d40476979903a17a15ee7653201ddd8043f" translate="yes" xml:space="preserve">
          <source>Type of current backend. Possible types are &lt;code&gt;autovacuum launcher&lt;/code&gt;, &lt;code&gt;autovacuum worker&lt;/code&gt;, &lt;code&gt;logical replication launcher&lt;/code&gt;, &lt;code&gt;logical replication worker&lt;/code&gt;, &lt;code&gt;parallel worker&lt;/code&gt;, &lt;code&gt;background writer&lt;/code&gt;, &lt;code&gt;client backend&lt;/code&gt;, &lt;code&gt;checkpointer&lt;/code&gt;, &lt;code&gt;startup&lt;/code&gt;, &lt;code&gt;walreceiver&lt;/code&gt;, &lt;code&gt;walsender&lt;/code&gt; and &lt;code&gt;walwriter&lt;/code&gt;. In addition, background workers registered by extensions may have additional types.</source>
          <target state="translated">当前后端的类型。可能的类型是 &lt;code&gt;autovacuum launcher&lt;/code&gt; ， &lt;code&gt;autovacuum worker&lt;/code&gt; ， &lt;code&gt;logical replication launcher&lt;/code&gt; ， &lt;code&gt;logical replication worker&lt;/code&gt; ， &lt;code&gt;parallel worker&lt;/code&gt; ， &lt;code&gt;background writer&lt;/code&gt; ， &lt;code&gt;client backend&lt;/code&gt; ， &lt;code&gt;checkpointer&lt;/code&gt; ， &lt;code&gt;startup&lt;/code&gt; ， &lt;code&gt;walreceiver&lt;/code&gt; ， &lt;code&gt;walsender&lt;/code&gt; 和 &lt;code&gt;walwriter&lt;/code&gt; 。此外，通过扩展名注册的后台工作人员可能具有其他类型。</target>
        </trans-unit>
        <trans-unit id="c82ff0d03f044b1bc03e6d585b2bc9ad0f83dd9c" translate="yes" xml:space="preserve">
          <source>Type of data stored in index, or zero if same as &lt;code&gt;opcintype&lt;/code&gt;</source>
          <target state="translated">索引中存储的数据类型；如果与 &lt;code&gt;opcintype&lt;/code&gt; 相同，则为零</target>
        </trans-unit>
        <trans-unit id="4055eb85cfd66c39ef30f33fb4b4a5d50d592112" translate="yes" xml:space="preserve">
          <source>Type of object this entry is for: &lt;code&gt;r&lt;/code&gt; = relation (table, view), &lt;code&gt;S&lt;/code&gt; = sequence, &lt;code&gt;f&lt;/code&gt; = function, &lt;code&gt;T&lt;/code&gt; = type, &lt;code&gt;n&lt;/code&gt; = schema</source>
          <target state="translated">该条目用于的对象类型： &lt;code&gt;r&lt;/code&gt; =关系（表，视图）， &lt;code&gt;S&lt;/code&gt; =序列， &lt;code&gt;f&lt;/code&gt; =函数， &lt;code&gt;T&lt;/code&gt; =类型， &lt;code&gt;n&lt;/code&gt; =模式</target>
        </trans-unit>
        <trans-unit id="3399c96b222ffc038be1234147fc38489a358880" translate="yes" xml:space="preserve">
          <source>Type of the JSON item (see &lt;code&gt;json_typeof&lt;/code&gt;)</source>
          <target state="translated">JSON项目的类型（请参阅 &lt;code&gt;json_typeof&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="c6f5ec2f1c5458817693d6d76b369073909c045e" translate="yes" xml:space="preserve">
          <source>Type of the SQL/JSON item</source>
          <target state="translated">SQL/JSON项的类型</target>
        </trans-unit>
        <trans-unit id="00a9fa45d41b5ea65aa7f18aa2626b820f2f9cef" translate="yes" xml:space="preserve">
          <source>Type of the left operand</source>
          <target state="translated">左操作数的类型</target>
        </trans-unit>
        <trans-unit id="21ac751dedd0b562597b93f21b2acf37d95f8772" translate="yes" xml:space="preserve">
          <source>Type of the lockable object: &lt;code&gt;relation&lt;/code&gt;, &lt;code&gt;extend&lt;/code&gt;, &lt;code&gt;frozenid&lt;/code&gt;, &lt;code&gt;page&lt;/code&gt;, &lt;code&gt;tuple&lt;/code&gt;, &lt;code&gt;transactionid&lt;/code&gt;, &lt;code&gt;virtualxid&lt;/code&gt;, &lt;code&gt;spectoken&lt;/code&gt;, &lt;code&gt;object&lt;/code&gt;, &lt;code&gt;userlock&lt;/code&gt;, or &lt;code&gt;advisory&lt;/code&gt;. (See also &lt;a href=&quot;monitoring-stats#WAIT-EVENT-LOCK-TABLE&quot;&gt;Table 27.11&lt;/a&gt;.)</source>
          <target state="translated">可锁定对象的类型： &lt;code&gt;relation&lt;/code&gt; ， &lt;code&gt;extend&lt;/code&gt; ， &lt;code&gt;frozenid&lt;/code&gt; ， &lt;code&gt;page&lt;/code&gt; ， &lt;code&gt;tuple&lt;/code&gt; ， &lt;code&gt;transactionid&lt;/code&gt; ， &lt;code&gt;virtualxid&lt;/code&gt; ， &lt;code&gt;spectoken&lt;/code&gt; ， &lt;code&gt;object&lt;/code&gt; ， &lt;code&gt;userlock&lt;/code&gt; 或 &lt;code&gt;advisory&lt;/code&gt; 。（另请参阅&lt;a href=&quot;monitoring-stats#WAIT-EVENT-LOCK-TABLE&quot;&gt;表27.11&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="767fb9969a4cc64a16553ca389e0f0b5a4e5c458" translate="yes" xml:space="preserve">
          <source>Type of the lockable object: &lt;code&gt;relation&lt;/code&gt;, &lt;code&gt;extend&lt;/code&gt;, &lt;code&gt;page&lt;/code&gt;, &lt;code&gt;tuple&lt;/code&gt;, &lt;code&gt;transactionid&lt;/code&gt;, &lt;code&gt;virtualxid&lt;/code&gt;, &lt;code&gt;object&lt;/code&gt;, &lt;code&gt;userlock&lt;/code&gt;, or &lt;code&gt;advisory&lt;/code&gt;</source>
          <target state="translated">可锁定对象的类型： &lt;code&gt;relation&lt;/code&gt; ， &lt;code&gt;extend&lt;/code&gt; ， &lt;code&gt;page&lt;/code&gt; ， &lt;code&gt;tuple&lt;/code&gt; ， &lt;code&gt;transactionid&lt;/code&gt; ， &lt;code&gt;virtualxid&lt;/code&gt; ， &lt;code&gt;object&lt;/code&gt; ， &lt;code&gt;userlock&lt;/code&gt; 或 &lt;code&gt;advisory&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="727af93962dbd00f156d10d2619e6fe4d2766070" translate="yes" xml:space="preserve">
          <source>Type of the result</source>
          <target state="translated">结果类型</target>
        </trans-unit>
        <trans-unit id="4b171dbb72682b90735ae1019128b1fa8fc68223" translate="yes" xml:space="preserve">
          <source>Type of the right operand</source>
          <target state="translated">右操作数的类型</target>
        </trans-unit>
        <trans-unit id="886a7edda3ba752fafb210f2d1fc042903763b8a" translate="yes" xml:space="preserve">
          <source>Type of the server (optional)</source>
          <target state="translated">服务器的类型(可选</target>
        </trans-unit>
        <trans-unit id="b84c44ea065844d42eb4ff46ceca0a63ebb5fb0f" translate="yes" xml:space="preserve">
          <source>Typed Tables</source>
          <target state="translated">类型表</target>
        </trans-unit>
        <trans-unit id="0e36cf7838eed64c7c287419b5db638ff701a9f7" translate="yes" xml:space="preserve">
          <source>Typed tables implement a subset of the SQL standard. According to the standard, a typed table has columns corresponding to the underlying composite type as well as one other column that is the &amp;ldquo;self-referencing column&amp;rdquo;. PostgreSQL does not support self-referencing columns explicitly.</source>
          <target state="translated">类型表实现SQL标准的子集。根据该标准，类型化表具有与基础复合类型相对应的列以及另一列，即&amp;ldquo;自引用列&amp;rdquo;。PostgreSQL不明确支持自引用列。</target>
        </trans-unit>
        <trans-unit id="5754e4191a491637e871b6ade422b1bcee16cbbf" translate="yes" xml:space="preserve">
          <source>Types of extended statistics enabled for this record</source>
          <target state="translated">为该记录启用的扩展统计类型</target>
        </trans-unit>
        <trans-unit id="30b55d03eac01f6040e3abe9feb9e154100f2081" translate="yes" xml:space="preserve">
          <source>Typical examples of an IPv4 address range specified this way are &lt;code&gt;172.20.143.89/32&lt;/code&gt; for a single host, or &lt;code&gt;172.20.143.0/24&lt;/code&gt; for a small network, or &lt;code&gt;10.6.0.0/16&lt;/code&gt; for a larger one. An IPv6 address range might look like &lt;code&gt;::1/128&lt;/code&gt; for a single host (in this case the IPv6 loopback address) or &lt;code&gt;fe80::7a31:c1ff:0000:0000/96&lt;/code&gt; for a small network. &lt;code&gt;0.0.0.0/0&lt;/code&gt; represents all IPv4 addresses, and &lt;code&gt;::0/0&lt;/code&gt; represents all IPv6 addresses. To specify a single host, use a mask length of 32 for IPv4 or 128 for IPv6. In a network address, do not omit trailing zeroes.</source>
          <target state="translated">IPv4地址范围的典型实例指定这种方式是 &lt;code&gt;172.20.143.89/32&lt;/code&gt; 用于单个主机，或 &lt;code&gt;172.20.143.0/24&lt;/code&gt; 为小型网络，或 &lt;code&gt;10.6.0.0/16&lt;/code&gt; 放大一个。对于单个主机，IPv6地址范围可能看起来像是 &lt;code&gt;::1/128&lt;/code&gt; （在本例中为IPv6环回地址），对于小型网络 &lt;code&gt;fe80::7a31:c1ff:0000:0000/96&lt;/code&gt; ，则可能是fe80 :: 7a31：c1ff：0000：0000/96。 &lt;code&gt;0.0.0.0/0&lt;/code&gt; 代表所有IPv4地址，而 &lt;code&gt;::0/0&lt;/code&gt; 代表所有IPv6地址。要指定单个主机，对于IPv4使用32的掩码长度，对于IPv6使用128的掩码长度。在网络地址中，不要省略尾随零。</target>
        </trans-unit>
        <trans-unit id="3ba7280f9a6416aff842d582d030dc0d547a8079" translate="yes" xml:space="preserve">
          <source>Typical examples would be:</source>
          <target state="translated">典型的例子是:</target>
        </trans-unit>
        <trans-unit id="c3ae6c139f98be74a60c4eaf214c1269190843b0" translate="yes" xml:space="preserve">
          <source>Typical output from pgbench looks like:</source>
          <target state="translated">pgbench的典型输出是这样的。</target>
        </trans-unit>
        <trans-unit id="4f215729680a38802cfd4b9559a7e299252d552b" translate="yes" xml:space="preserve">
          <source>Typical output from this plugin, used over the SQL logical decoding interface, might be:</source>
          <target state="translated">这个插件的典型输出,在SQL逻辑解码接口上使用,可能是。</target>
        </trans-unit>
        <trans-unit id="5d9380cc46b3004a735b71b1ddc5769ac9cc9d80" translate="yes" xml:space="preserve">
          <source>Typically a role being used as a group would not have the &lt;code&gt;LOGIN&lt;/code&gt; attribute, though you can set it if you wish.</source>
          <target state="translated">通常，用作角色的角色没有 &lt;code&gt;LOGIN&lt;/code&gt; 属性，尽管您可以根据需要进行设置。</target>
        </trans-unit>
        <trans-unit id="0c79e0bb5747a47177b68165db0b8e29d1e90432" translate="yes" xml:space="preserve">
          <source>Typically an &lt;code&gt;UPDATE&lt;/code&gt; command also needs to read data from columns in the relation being updated (e.g., in a &lt;code&gt;WHERE&lt;/code&gt; clause or a &lt;code&gt;RETURNING&lt;/code&gt; clause, or in an expression on the right hand side of the &lt;code&gt;SET&lt;/code&gt; clause). In this case, &lt;code&gt;SELECT&lt;/code&gt; rights are also required on the relation being updated, and the appropriate &lt;code&gt;SELECT&lt;/code&gt; or &lt;code&gt;ALL&lt;/code&gt; policies will be applied in addition to the &lt;code&gt;UPDATE&lt;/code&gt; policies. Thus the user must have access to the row(s) being updated through a &lt;code&gt;SELECT&lt;/code&gt; or &lt;code&gt;ALL&lt;/code&gt; policy in addition to being granted permission to update the row(s) via an &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;ALL&lt;/code&gt; policy.</source>
          <target state="translated">通常， &lt;code&gt;UPDATE&lt;/code&gt; 命令还需要从要更新的关系中的列中读取数据（例如，在 &lt;code&gt;WHERE&lt;/code&gt; 子句或 &lt;code&gt;RETURNING&lt;/code&gt; 子句中，或者在 &lt;code&gt;SET&lt;/code&gt; 子句右侧的表达式中）。在这种情况下，还需要对更新的关系具有 &lt;code&gt;SELECT&lt;/code&gt; 权限，并且除了 &lt;code&gt;UPDATE&lt;/code&gt; 策略外，还将应用适当的 &lt;code&gt;SELECT&lt;/code&gt; 或 &lt;code&gt;ALL&lt;/code&gt; 策略。因此，用户除了有权通过 &lt;code&gt;UPDATE&lt;/code&gt; 或UPDATE来更新行外，还必须有权通过 &lt;code&gt;SELECT&lt;/code&gt; 或 &lt;code&gt;ALL&lt;/code&gt; 策略访问正在更新的行。 &lt;code&gt;ALL&lt;/code&gt; 政策。</target>
        </trans-unit>
        <trans-unit id="4a5dff53d37ef582f6443160c6077ab3c024f6ad" translate="yes" xml:space="preserve">
          <source>Typically libraries like libpq only add new functionality, again unless mentioned in the release notes.</source>
          <target state="translated">通常像libpq这样的库只是增加新的功能,同样除非在发行说明中提到。</target>
        </trans-unit>
        <trans-unit id="74be98305cce33f0717978700ff85879bd035ba2" translate="yes" xml:space="preserve">
          <source>Typically that would be written in an extension's creation script, and users would do this to install the extension:</source>
          <target state="translated">通常情况下,这将被写在扩展的创建脚本中,用户将这样做来安装扩展。</target>
        </trans-unit>
        <trans-unit id="d506067679b9e62e7a37578f7129dcc3d999cc58" translate="yes" xml:space="preserve">
          <source>Typically this includes new SQL command capabilities and not changes in behavior, unless specifically mentioned in the release notes.</source>
          <target state="translated">通常这包括新的SQL命令功能,而不是行为的改变,除非在发布说明中特别提到。</target>
        </trans-unit>
        <trans-unit id="3822092fc5f3e669e643e30f8ce5e23c88a10d9c" translate="yes" xml:space="preserve">
          <source>Typically weights are used to mark words from special areas of the document, like the title or an initial abstract, so they can be treated with more or less importance than words in the document body.</source>
          <target state="translated">通常,权重用于标记文档中特殊区域的词,如标题或初始摘要,因此它们可以比文档正文中的词更重要或更不重要。</target>
        </trans-unit>
        <trans-unit id="75ec6d184c198c058b18b104c2264bc1718aff70" translate="yes" xml:space="preserve">
          <source>UNION, CASE, and Related Constructs</source>
          <target state="translated">UNION、CASE及相关结构</target>
        </trans-unit>
        <trans-unit id="e85ec09bfd030dc1a5734a458795c226244fc313" translate="yes" xml:space="preserve">
          <source>UNLISTEN</source>
          <target state="translated">UNLISTEN</target>
        </trans-unit>
        <trans-unit id="4e75e16efe1381bdf958afc52921070dcac9674c" translate="yes" xml:space="preserve">
          <source>UNLISTEN &amp;mdash; stop listening for a notification</source>
          <target state="translated">取消收听-停止收听通知</target>
        </trans-unit>
        <trans-unit id="e42fbf3248836a2bda1822a0f26f66440fa0c899" translate="yes" xml:space="preserve">
          <source>UPC &amp;lt;=&amp;gt; EAN13</source>
          <target state="translated">UPC &amp;lt;=&amp;gt; EAN13</target>
        </trans-unit>
        <trans-unit id="8ea457eae40d594e81201972c4abd897fed37408" translate="yes" xml:space="preserve">
          <source>UPC numbers are a subset of the EAN13 numbers (they are basically EAN13 without the first &lt;code&gt;0&lt;/code&gt; digit).</source>
          <target state="translated">UPC编号是EAN13编号的子集（它们基本上是EAN13，没有前 &lt;code&gt;0&lt;/code&gt; 个数字）。</target>
        </trans-unit>
        <trans-unit id="52c6c1812015585dc1092393a1f244f60d68c60a" translate="yes" xml:space="preserve">
          <source>UPDATE</source>
          <target state="translated">UPDATE</target>
        </trans-unit>
        <trans-unit id="391f048e928d94ac0bc9a0124d925ff0ab247d37" translate="yes" xml:space="preserve">
          <source>UPDATE &amp;mdash; update rows of a table</source>
          <target state="translated">UPDATE &amp;mdash;更新表的行</target>
        </trans-unit>
        <trans-unit id="0e2d9b0777a485c1276de0803c12a7d76fbc5c39" translate="yes" xml:space="preserve">
          <source>URL</source>
          <target state="translated">URL</target>
        </trans-unit>
        <trans-unit id="5bc5065b4243467de49ffd6feb4dc052247ba467" translate="yes" xml:space="preserve">
          <source>URL locations can be canonicalized to make equivalent URLs match:</source>
          <target state="translated">URL位置可以进行规范化,使等价的URL匹配。</target>
        </trans-unit>
        <trans-unit id="5e1156d91b64895766702da1dac1a03bdacc18d8" translate="yes" xml:space="preserve">
          <source>URL path</source>
          <target state="translated">URL路径</target>
        </trans-unit>
        <trans-unit id="bdfd4d8d6952777c39403b2d2e2f8a2a52bf255f" translate="yes" xml:space="preserve">
          <source>UTC</source>
          <target state="translated">UTC</target>
        </trans-unit>
        <trans-unit id="618f65101275eae124d9a7c9c7a5431c588e88d8" translate="yes" xml:space="preserve">
          <source>UTF</source>
          <target state="translated">UTF</target>
        </trans-unit>
        <trans-unit id="006a48ffb6b1c6d449c6f984e56102797a110071" translate="yes" xml:space="preserve">
          <source>UTF-8 (8-bit UCS/Unicode Transformation Format) is defined here.</source>
          <target state="translated">这里定义了UTF-8(8位UCS/Unicode转换格式)。</target>
        </trans-unit>
        <trans-unit id="7fa9ad7f9065e92883a9407e908d043b05c218a2" translate="yes" xml:space="preserve">
          <source>UTF8</source>
          <target state="translated">UTF8</target>
        </trans-unit>
        <trans-unit id="21bf75a5255af008f6315cb6aca4bb3bdccee521" translate="yes" xml:space="preserve">
          <source>UUID</source>
          <target state="translated">UUID</target>
        </trans-unit>
        <trans-unit id="cd5f8485e99e1466105fe2ccda1a6e32ac64f458" translate="yes" xml:space="preserve">
          <source>UUID Functions</source>
          <target state="translated">UUID功能</target>
        </trans-unit>
        <trans-unit id="0b3aa0aafa91ea5c6d6154167ed0f9530a1ec26c" translate="yes" xml:space="preserve">
          <source>UUID Type</source>
          <target state="translated">UUID类型</target>
        </trans-unit>
        <trans-unit id="0a7e35cb9fd13ab0f8bc30cc95fe3965c0075fa2" translate="yes" xml:space="preserve">
          <source>Unary plus (no operation)</source>
          <target state="translated">单数加(无操作</target>
        </trans-unit>
        <trans-unit id="c93712543c02319baab11b2b81799e7e791b6f5f" translate="yes" xml:space="preserve">
          <source>Unary plus (no operation); unlike addition, this can iterate over multiple values</source>
          <target state="translated">单一加法(无操作);与加法不同的是,它可以对多个值进行迭代。</target>
        </trans-unit>
        <trans-unit id="bbfa247ab63ebe054b1f625efaac8d7d2ed2786f" translate="yes" xml:space="preserve">
          <source>Unconditionally trace locks on this table (OID).</source>
          <target state="translated">无条件地跟踪此表的锁(OID)。</target>
        </trans-unit>
        <trans-unit id="1a26494bd46f598c2d3b286cc32f8f8da4c3c529" translate="yes" xml:space="preserve">
          <source>Undo that, restoring whatever setting was effective in &lt;code&gt;postgresql.conf&lt;/code&gt;:</source>
          <target state="translated">撤消该操作，恢复在 &lt;code&gt;postgresql.conf&lt;/code&gt; 中有效的设置：</target>
        </trans-unit>
        <trans-unit id="d82f20269a7ba351c65d96d467573f44ed2241db" translate="yes" xml:space="preserve">
          <source>Undo the above, so that subsequently-created tables won't have any more permissions than normal:</source>
          <target state="translated">撤销上面的操作,这样以后创建的表就不会有比正常表更多的权限。</target>
        </trans-unit>
        <trans-unit id="69537adb0c6a954242641822e574baa70cf65b67" translate="yes" xml:space="preserve">
          <source>Unexpected results might be obtained if a &lt;code&gt;cache&lt;/code&gt; setting greater than one is used for a sequence object that will be used concurrently by multiple sessions. Each session will allocate and cache successive sequence values during one access to the sequence object and increase the sequence object's &lt;code&gt;last_value&lt;/code&gt; accordingly. Then, the next &lt;code&gt;cache&lt;/code&gt;-1 uses of &lt;code&gt;nextval&lt;/code&gt; within that session simply return the preallocated values without touching the sequence object. So, any numbers allocated but not used within a session will be lost when that session ends, resulting in &amp;ldquo;holes&amp;rdquo; in the sequence.</source>
          <target state="translated">如果将大于一个的 &lt;code&gt;cache&lt;/code&gt; 设置用于将由多个会话同时使用的序列对象，则可能会得到意外的结果。每个会话将在一次访问序列对象期间分配和缓存连续的序列值，并相应地增加序列对象的 &lt;code&gt;last_value&lt;/code&gt; 。然后，该会话内的 &lt;code&gt;nextval&lt;/code&gt; 的下一个 &lt;code&gt;cache&lt;/code&gt; -1使用nextval只需返回预分配的值，而无需触摸序列对象。因此，会话中分配但未使用的任何数字都将在该会话结束时丢失，从而导致序列中的&amp;ldquo;漏洞&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="bac601add3bc88ae7a8e23e81f98747db513fcef" translate="yes" xml:space="preserve">
          <source>Unfortunately, there is no well-defined method for determining ideal values for the cost variables. They are best treated as averages over the entire mix of queries that a particular installation will receive. This means that changing them on the basis of just a few experiments is very risky.</source>
          <target state="translated">遗憾的是,没有一个明确的方法来确定费用变量的理想值。它们最好是作为一个特定装置将收到的所有查询的平均数来处理。这意味着,仅凭几次试验就改变它们是非常危险的。</target>
        </trans-unit>
        <trans-unit id="5477f70b1eea785630b35cd84e386522cded5715" translate="yes" xml:space="preserve">
          <source>Unicode Transformation Format</source>
          <target state="translated">统一码转换格式</target>
        </trans-unit>
        <trans-unit id="8de2de87fc64e84d8c1aa641cad76e717bc7b29c" translate="yes" xml:space="preserve">
          <source>Unicode, 8-bit</source>
          <target state="translated">统一码,8位</target>
        </trans-unit>
        <trans-unit id="93a858d6fa1dc81e7eaad3250789d05cb036b8fa" translate="yes" xml:space="preserve">
          <source>Unified Hangul Code</source>
          <target state="translated">统一韩语代码</target>
        </trans-unit>
        <trans-unit id="67ef7a3b2dde1ee8d6d2f80347f89266789839b9" translate="yes" xml:space="preserve">
          <source>Uniform Resource Locator</source>
          <target state="translated">统一资源定位器</target>
        </trans-unit>
        <trans-unit id="86a932dd65a48b174d2aada36f1bfffd412deac8" translate="yes" xml:space="preserve">
          <source>Unique Indexes</source>
          <target state="translated">独特索引</target>
        </trans-unit>
        <trans-unit id="77df08227da6ac685804effa87058e13d84c4065" translate="yes" xml:space="preserve">
          <source>Unique constraint</source>
          <target state="translated">独特的制约因素</target>
        </trans-unit>
        <trans-unit id="94adb10ebc944ac8b8156528bb8fd8dc3337202a" translate="yes" xml:space="preserve">
          <source>Unique constraints (and hence primary keys) on partitioned tables must include all the partition key columns. This limitation exists because PostgreSQL can only enforce uniqueness in each partition individually.</source>
          <target state="translated">分区表上的唯一约束(因此是主键)必须包括所有的分区键列。这种限制的存在是因为PostgreSQL只能在每个分区中单独执行唯一性。</target>
        </trans-unit>
        <trans-unit id="b4e5e39c7a8efbcd5a2b7282c47950080c8841cd" translate="yes" xml:space="preserve">
          <source>Unique constraints and primary keys are not inherited in the current implementation. This makes the combination of inheritance and unique constraints rather dysfunctional.</source>
          <target state="translated">在目前的实施中,唯一约束和主键是不被继承的。这就使得继承和独特的约束条件结合在一起相当不正常。</target>
        </trans-unit>
        <trans-unit id="a46827700fc4ef4d046ba4ec7203d49efc58d66f" translate="yes" xml:space="preserve">
          <source>Unique constraints ensure that the data contained in a column, or a group of columns, is unique among all the rows in the table. The syntax is:</source>
          <target state="translated">独特的约束条件确保了一列或一组列中包含的数据在表中所有行中是唯一的。其语法是:</target>
        </trans-unit>
        <trans-unit id="b9aef8c8c0041d90e74399130137479516c8ba5f" translate="yes" xml:space="preserve">
          <source>Unique constraints on partitioned tables must include all the partition key columns. This limitation exists because PostgreSQL can only enforce uniqueness in each partition individually.</source>
          <target state="translated">分区表的唯一性约束必须包括所有的分区键列。这种限制的存在是因为PostgreSQL只能在每个分区中单独执行唯一性。</target>
        </trans-unit>
        <trans-unit id="9ef954009038fb621257b004ec6cd8cd826ed58e" translate="yes" xml:space="preserve">
          <source>Unique prefixes of these strings are also accepted, for example &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;n&lt;/code&gt;. Leading or trailing whitespace is ignored, and case does not matter.</source>
          <target state="translated">这些字符串的唯一前缀也可以接受，例如 &lt;code&gt;t&lt;/code&gt; 或 &lt;code&gt;n&lt;/code&gt; 。前导或尾随空格将被忽略，大小写无关紧要。</target>
        </trans-unit>
        <trans-unit id="f49788f44915bd3a94e16e6f26e2424dc403e286" translate="yes" xml:space="preserve">
          <source>Universal Product Codes</source>
          <target state="translated">通用产品代码</target>
        </trans-unit>
        <trans-unit id="b3357a0d067580c052d7ebc854b226e0d5262199" translate="yes" xml:space="preserve">
          <source>Universally Unique Identifier</source>
          <target state="translated">通用唯一标识符</target>
        </trans-unit>
        <trans-unit id="49e71ce661ccc6dfcd03e849d0ea4cd3cac1c011" translate="yes" xml:space="preserve">
          <source>Unix System V</source>
          <target state="translated">Unix系统V</target>
        </trans-unit>
        <trans-unit id="356c3f979b3eb09e01dc5a248ce81de4df5a2076" translate="yes" xml:space="preserve">
          <source>Unix-like operating systems enforce various kinds of resource limits that might interfere with the operation of your PostgreSQL server. Of particular importance are limits on the number of processes per user, the number of open files per process, and the amount of memory available to each process. Each of these have a &amp;ldquo;hard&amp;rdquo; and a &amp;ldquo;soft&amp;rdquo; limit. The soft limit is what actually counts but it can be changed by the user up to the hard limit. The hard limit can only be changed by the root user. The system call &lt;code&gt;setrlimit&lt;/code&gt; is responsible for setting these parameters. The shell's built-in command &lt;code&gt;ulimit&lt;/code&gt; (Bourne shells) or &lt;code&gt;limit&lt;/code&gt; (csh) is used to control the resource limits from the command line. On BSD-derived systems the file &lt;code&gt;/etc/login.conf&lt;/code&gt; controls the various resource limits set during login. See the operating system documentation for details. The relevant parameters are &lt;code&gt;maxproc&lt;/code&gt;, &lt;code&gt;openfiles&lt;/code&gt;, and &lt;code&gt;datasize&lt;/code&gt;. For example:</source>
          <target state="translated">类似于Unix的操作系统强制执行各种资源限制，这些资源限制可能会干扰PostgreSQL服务器的操作。特别重要的是限制每个用户的进程数，每个进程的打开文件数以及每个进程可用的内存量。这些每个都有一个&amp;ldquo;硬&amp;rdquo;和&amp;ldquo;软&amp;rdquo;限制。软限制是实际要考虑的内容，但用户可以更改为硬限制。硬限制只能由root用户更改。系统调用 &lt;code&gt;setrlimit&lt;/code&gt; 负责设置这些参数。 Shell的内置命令 &lt;code&gt;ulimit&lt;/code&gt; （Bourne shell）或 &lt;code&gt;limit&lt;/code&gt; （csh）用于从命令行控制资源限制。在BSD衍生的系统上，文件 &lt;code&gt;/etc/login.conf&lt;/code&gt; 控制登录期间设置的各种资源限制。有关详细信息，请参见操作系统文档。相关参数是 &lt;code&gt;maxproc&lt;/code&gt; ， &lt;code&gt;openfiles&lt;/code&gt; 和 &lt;code&gt;datasize&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="3a738963ffda0371927d9ea96b648a8947fa84b5" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;WITH HOLD&lt;/code&gt; is specified, the cursor created by this command can only be used within the current transaction. Thus, &lt;code&gt;DECLARE&lt;/code&gt; without &lt;code&gt;WITH HOLD&lt;/code&gt; is useless outside a transaction block: the cursor would survive only to the completion of the statement. Therefore PostgreSQL reports an error if such a command is used outside a transaction block. Use &lt;a href=&quot;sql-begin&quot;&gt;BEGIN&lt;/a&gt; and &lt;a href=&quot;sql-commit&quot;&gt;COMMIT&lt;/a&gt; (or &lt;a href=&quot;sql-rollback&quot;&gt;ROLLBACK&lt;/a&gt;) to define a transaction block.</source>
          <target state="translated">除非指定了 &lt;code&gt;WITH HOLD&lt;/code&gt; ，否则此命令创建的游标只能在当前事务中使用。因此，不带 &lt;code&gt;WITH HOLD&lt;/code&gt; 的 &lt;code&gt;DECLARE&lt;/code&gt; 在事务块之外是无用的：游标只能生存到语句完成。因此，如果在事务块外使用这样的命令，PostgreSQL将报告错误。使用&lt;a href=&quot;sql-begin&quot;&gt;BEGIN&lt;/a&gt;和&lt;a href=&quot;sql-commit&quot;&gt;COMMIT&lt;/a&gt;（或&lt;a href=&quot;sql-rollback&quot;&gt;ROLLBACK&lt;/a&gt;）定义一个事务块。</target>
        </trans-unit>
        <trans-unit id="f36df6a348af57e59d7545a3e535407a26fb9186" translate="yes" xml:space="preserve">
          <source>Unless it is passed an &lt;code&gt;-X&lt;/code&gt; option, psql attempts to read and execute commands from the system-wide startup file (&lt;code&gt;psqlrc&lt;/code&gt;) and then the user's personal startup file (&lt;code&gt;~/.psqlrc&lt;/code&gt;), after connecting to the database but before accepting normal commands. These files can be used to set up the client and/or the server to taste, typically with &lt;code&gt;\set&lt;/code&gt; and &lt;code&gt;SET&lt;/code&gt; commands.</source>
          <target state="translated">除非传递了 &lt;code&gt;-X&lt;/code&gt; 选项，否则psql会先尝试从系统级启动文件（ &lt;code&gt;psqlrc&lt;/code&gt; ）中读取命令并执行命令，然后再从用户的个人启动文件（ &lt;code&gt;~/.psqlrc&lt;/code&gt; ）中读取并执行命令，然后再连接到数据库但在接受常规命令之前。这些文件通常可用于 &lt;code&gt;\set&lt;/code&gt; 和 &lt;code&gt;SET&lt;/code&gt; 命令，以用于设置客户端和/或服务器以进行测试。</target>
        </trans-unit>
        <trans-unit id="6ebac9c6005801410e118c32c680d55ed8b8c195" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt;, there is no large performance advantage to loading a library at session start rather than when it is first used. There is some advantage, however, when connection pooling is used.</source>
          <target state="translated">与&lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt;不同，在会话开始时（而不是在首次使用时）加载库没有太大的性能优势。但是，使用连接池时有一些优点。</target>
        </trans-unit>
        <trans-unit id="36f97215c9ceadf639797c9ff18cfda7e2adaae5" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;INHERITS&lt;/code&gt;, the new table and original table are completely decoupled after creation is complete. Changes to the original table will not be applied to the new table, and it is not possible to include data of the new table in scans of the original table.</source>
          <target state="translated">与 &lt;code&gt;INHERITS&lt;/code&gt; 不同，新表和原始表在创建完成后完全解耦。对原始表的更改将不会应用于新表，并且不可能在原始表的扫描中包括新表的数据。</target>
        </trans-unit>
        <trans-unit id="155a510971d12c46f75bfa7a5024bf809f98a32b" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;statement_timeout&lt;/code&gt;, this timeout can only occur while waiting for locks. Note that if &lt;code&gt;statement_timeout&lt;/code&gt; is nonzero, it is rather pointless to set &lt;code&gt;lock_timeout&lt;/code&gt; to the same or larger value, since the statement timeout would always trigger first. If &lt;code&gt;log_min_error_statement&lt;/code&gt; is set to &lt;code&gt;ERROR&lt;/code&gt; or lower, the statement that timed out will be logged.</source>
          <target state="translated">与 &lt;code&gt;statement_timeout&lt;/code&gt; 不同，此超时只能在等待锁时发生。请注意，如果 &lt;code&gt;statement_timeout&lt;/code&gt; 不为零，则将 &lt;code&gt;lock_timeout&lt;/code&gt; 设置为相同或更大的值是毫无意义的，因为语句超时总是会首先触发。如果将 &lt;code&gt;log_min_error_statement&lt;/code&gt; 设置为 &lt;code&gt;ERROR&lt;/code&gt; 或更低，则将记录超时的语句。</target>
        </trans-unit>
        <trans-unit id="01f67f25338b64081817dcfc5c06974c9678164c" translate="yes" xml:space="preserve">
          <source>Unlike an XQuery/XPath sequence, which can contain any desired items in any desired order, an XPath 1.0 node-set has no guaranteed order and, like any set, does not allow multiple appearances of the same item.</source>
          <target state="translated">与XQuery/XPath序列不同,XQuery/XPath序列可以以任何所需的顺序包含任何所需的项目,而XPath 1.0节点集没有保证的顺序,并且像任何集合一样,不允许同一项目多次出现。</target>
        </trans-unit>
        <trans-unit id="7bd39bd8bedec3e142d1db4767a229ec44898026" translate="yes" xml:space="preserve">
          <source>Unlike most other meta-commands, the entire remainder of the line is always taken to be the argument(s) of &lt;code&gt;\!&lt;/code&gt;, and neither variable interpolation nor backquote expansion are performed in the arguments. The rest of the line is simply passed literally to the shell.</source>
          <target state="translated">与大多数其他元命令不同，该行的其余部分始终被视为 &lt;code&gt;\!&lt;/code&gt; 的参数。，并且不会在参数中执行变量插值或反引号扩展。该行的其余部分仅按字面意义传递给外壳。</target>
        </trans-unit>
        <trans-unit id="f03bc80a9071747274c116c1e2637b147c1236d6" translate="yes" xml:space="preserve">
          <source>Unlike most other meta-commands, the entire remainder of the line is always taken to be the argument(s) of &lt;code&gt;\ef&lt;/code&gt;, and neither variable interpolation nor backquote expansion are performed in the arguments.</source>
          <target state="translated">与大多数其他元命令不同，该行的其余部分始终被视为 &lt;code&gt;\ef&lt;/code&gt; 的参数，并且在参数中既不执行变量内插也不执行反引号扩展。</target>
        </trans-unit>
        <trans-unit id="2ad59f5d51ac2d51e40eadad80e70c35b9563ffa" translate="yes" xml:space="preserve">
          <source>Unlike most other meta-commands, the entire remainder of the line is always taken to be the argument(s) of &lt;code&gt;\ev&lt;/code&gt;, and neither variable interpolation nor backquote expansion are performed in the arguments.</source>
          <target state="translated">与大多数其他元命令不同，该行的其余部分始终被视为 &lt;code&gt;\ev&lt;/code&gt; 的参数，并且在参数中既不执行变量内插也不执行反引号扩展。</target>
        </trans-unit>
        <trans-unit id="969a2dc5b4f67a3964fc411e75789aab5f823e51" translate="yes" xml:space="preserve">
          <source>Unlike most other meta-commands, the entire remainder of the line is always taken to be the argument(s) of &lt;code&gt;\help&lt;/code&gt;, and neither variable interpolation nor backquote expansion are performed in the arguments.</source>
          <target state="translated">与大多数其他元命令不同，该行的其余部分始终被视为 &lt;code&gt;\help&lt;/code&gt; 的参数，并且在参数中既不执行变量内插也不执行反引号扩展。</target>
        </trans-unit>
        <trans-unit id="1bcb7b9bd68e7cf599cb0566f121f159d3638a90" translate="yes" xml:space="preserve">
          <source>Unlike most other meta-commands, the entire remainder of the line is always taken to be the argument(s) of &lt;code&gt;\sf&lt;/code&gt;, and neither variable interpolation nor backquote expansion are performed in the arguments.</source>
          <target state="translated">与大多数其他元命令不同，该行的其余部分始终被视为 &lt;code&gt;\sf&lt;/code&gt; 的参数，并且在参数中既不执行变量插值也不执行反引号扩展。</target>
        </trans-unit>
        <trans-unit id="b3d8189c59a9d485c225bb21085a7dacfbf70328" translate="yes" xml:space="preserve">
          <source>Unlike most other meta-commands, the entire remainder of the line is always taken to be the argument(s) of &lt;code&gt;\sv&lt;/code&gt;, and neither variable interpolation nor backquote expansion are performed in the arguments.</source>
          <target state="translated">与大多数其他元命令不同，该行的其余部分始终被视为 &lt;code&gt;\sv&lt;/code&gt; 的参数，并且在参数中既不执行变量插值也不执行反引号扩展。</target>
        </trans-unit>
        <trans-unit id="af5b4f9ec65cdc48545903249d2323c25ceebafa" translate="yes" xml:space="preserve">
          <source>Unlike most system catalogs, &lt;code&gt;pg_database&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_database&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">与大多数系统目录不同， &lt;code&gt;pg_database&lt;/code&gt; 在群集的所有数据库之间共享：每个群集只有一个 &lt;code&gt;pg_database&lt;/code&gt; 副本，而不是每个数据库一个。</target>
        </trans-unit>
        <trans-unit id="b4e709aa40757d88375a6ee47a77d6e0698e4303" translate="yes" xml:space="preserve">
          <source>Unlike most system catalogs, &lt;code&gt;pg_db_role_setting&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_db_role_setting&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">与大多数系统目录不同， &lt;code&gt;pg_db_role_setting&lt;/code&gt; 在群集的所有数据库之间共享：每个群集只有一个 &lt;code&gt;pg_db_role_setting&lt;/code&gt; 副本，而不是每个数据库一个副本。</target>
        </trans-unit>
        <trans-unit id="2dbf1c1060e2c0aacae52353ec7fcd45b3ccceac" translate="yes" xml:space="preserve">
          <source>Unlike most system catalogs, &lt;code&gt;pg_pltemplate&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_pltemplate&lt;/code&gt; per cluster, not one per database. This allows the information to be accessible in each database as it is needed.</source>
          <target state="translated">与大多数系统目录不同， &lt;code&gt;pg_pltemplate&lt;/code&gt; 在群集的所有数据库之间共享：每个群集只有一个 &lt;code&gt;pg_pltemplate&lt;/code&gt; 副本，而不是每个数据库一个。这样就可以根据需要在每个数据库中访问该信息。</target>
        </trans-unit>
        <trans-unit id="90ff2576b542214d688a9eed4987d1a4510c063b" translate="yes" xml:space="preserve">
          <source>Unlike most system catalogs, &lt;code&gt;pg_replication_origin&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_replication_origin&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">与大多数系统目录不同， &lt;code&gt;pg_replication_origin&lt;/code&gt; 在群集的所有数据库之间共享：每个群集只有一个 &lt;code&gt;pg_replication_origin&lt;/code&gt; 副本，而不是每个数据库一个。</target>
        </trans-unit>
        <trans-unit id="091dfd81e1c158b99b74cd5401b694679d3d2a31" translate="yes" xml:space="preserve">
          <source>Unlike most system catalogs, &lt;code&gt;pg_shdepend&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_shdepend&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">与大多数系统目录不同， &lt;code&gt;pg_shdepend&lt;/code&gt; 在群集的所有数据库之间共享：每个群集只有一个 &lt;code&gt;pg_shdepend&lt;/code&gt; 副本，而不是每个数据库一个。</target>
        </trans-unit>
        <trans-unit id="b1cd5b470b7693ec3b4e72d1482e8ab6f1102fe7" translate="yes" xml:space="preserve">
          <source>Unlike most system catalogs, &lt;code&gt;pg_shdescription&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_shdescription&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">与大多数系统目录不同， &lt;code&gt;pg_shdescription&lt;/code&gt; 在群集的所有数据库之间共享：每个群集只有一个 &lt;code&gt;pg_shdescription&lt;/code&gt; 副本，而不是每个数据库一个。</target>
        </trans-unit>
        <trans-unit id="45f9981f7d01238e6386247ed7e8c9b367559cb4" translate="yes" xml:space="preserve">
          <source>Unlike most system catalogs, &lt;code&gt;pg_shseclabel&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_shseclabel&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">与大多数系统目录不同， &lt;code&gt;pg_shseclabel&lt;/code&gt; 在群集的所有数据库之间共享：每个群集只有一个 &lt;code&gt;pg_shseclabel&lt;/code&gt; 副本，而不是每个数据库一个。</target>
        </trans-unit>
        <trans-unit id="eec8ee0cfbfbe1f6f908ff68c376680c64650f41" translate="yes" xml:space="preserve">
          <source>Unlike most system catalogs, &lt;code&gt;pg_subscription&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_subscription&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">与大多数系统目录不同， &lt;code&gt;pg_subscription&lt;/code&gt; 在群集的所有数据库之间共享：每个群集只有一个 &lt;code&gt;pg_subscription&lt;/code&gt; 副本，而不是每个数据库一个。</target>
        </trans-unit>
        <trans-unit id="0b07b56a669f78b6086b457c5748686a76e734e9" translate="yes" xml:space="preserve">
          <source>Unlike most system catalogs, &lt;code&gt;pg_tablespace&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_tablespace&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">与大多数系统目录不同， &lt;code&gt;pg_tablespace&lt;/code&gt; 在集群的所有数据库之间共享：每个集群只有一个 &lt;code&gt;pg_tablespace&lt;/code&gt; 副本，而每个数据库没有一个副本。</target>
        </trans-unit>
        <trans-unit id="92c63faeedbf5e16bc5b93cceba5f7d683c79fc1" translate="yes" xml:space="preserve">
          <source>Unlike the WAL receiver of a PostgreSQL standby server, pg_receivewal by default flushes WAL data only when a WAL file is closed. The option &lt;code&gt;--synchronous&lt;/code&gt; must be specified to flush WAL data in real time. Since pg_receivewal does not apply WAL, you should not allow it to become a synchronous standby when &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt; equals &lt;code&gt;remote_apply&lt;/code&gt;. If it does, it will appear to be a standby that never catches up, and will cause transaction commits to block. To avoid this, you should either configure an appropriate value for &lt;a href=&quot;runtime-config-replication#GUC-SYNCHRONOUS-STANDBY-NAMES&quot;&gt;synchronous_standby_names&lt;/a&gt;, or specify &lt;code&gt;application_name&lt;/code&gt; for pg_receivewal that does not match it, or change the value of &lt;code&gt;synchronous_commit&lt;/code&gt; to something other than &lt;code&gt;remote_apply&lt;/code&gt;.</source>
          <target state="translated">与PostgreSQL备用服务器的WAL接收器不同，默认情况下pg_receivewal仅在关闭WAL文件时才刷新WAL数据。必须指定选项 &lt;code&gt;--synchronous&lt;/code&gt; 才能实时刷新WAL数据。由于pg_receivewal不适用WAL，你不应该让它成为一个同步待机时&lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt;等于 &lt;code&gt;remote_apply&lt;/code&gt; 。如果是这样，它将看起来像一个永远不会追上的备用数据库，并且将导致事务提交被阻塞。为了避免这种情况，您应该为&lt;a href=&quot;runtime-config-replication#GUC-SYNCHRONOUS-STANDBY-NAMES&quot;&gt;synchronous_standby_names&lt;/a&gt;配置一个适当的值，或者为与之不匹配的pg_receivewal 指定 &lt;code&gt;application_name&lt;/code&gt; ，或者将 &lt;code&gt;synchronous_commit&lt;/code&gt; 的值更改为除 &lt;code&gt;remote_apply&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="209b27f026f1a4e49e27f779263f8527ec3c4bc5" translate="yes" xml:space="preserve">
          <source>Unlike the case when adding a constraint to a regular table, nothing is done to verify the constraint is correct; rather, this action simply declares that some new condition should be assumed to hold for all rows in the foreign table. (See the discussion in &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;.) If the constraint is marked &lt;code&gt;NOT VALID&lt;/code&gt;, then it isn't assumed to hold, but is only recorded for possible future use.</source>
          <target state="translated">与将约束添加到常规表的情况不同，没有做任何事情来验证约束是正确的。相反，此操作只是声明应假定某些新条件适用于外表中的所有行。（请参阅&lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE中&lt;/a&gt;的讨论。）如果约束标记为 &lt;code&gt;NOT VALID&lt;/code&gt; ，则不假定该约束成立，而仅记录该约束以备将来使用。</target>
        </trans-unit>
        <trans-unit id="8b364554eb1587843dacba831a236e3430803901" translate="yes" xml:space="preserve">
          <source>Unlike the case with privileges, membership in a role cannot be granted to &lt;code&gt;PUBLIC&lt;/code&gt;. Note also that this form of the command does not allow the noise word &lt;code&gt;GROUP&lt;/code&gt; in &lt;code&gt;role_specification&lt;/code&gt;.</source>
          <target state="translated">与具有特权的情况不同，不能将角色的成员资格授予 &lt;code&gt;PUBLIC&lt;/code&gt; 。还要注意，该命令的这种形式不允许在 &lt;code&gt;role_specification&lt;/code&gt; 中使用干扰词 &lt;code&gt;GROUP&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e0b1d236f8fe0f3fb7bccf02c7559e609f29c15" translate="yes" xml:space="preserve">
          <source>Unlike the case with privileges, membership in a role cannot be granted to &lt;code&gt;PUBLIC&lt;/code&gt;. Note also that this form of the command does not allow the noise word &lt;code&gt;GROUP&lt;/code&gt;.</source>
          <target state="translated">与具有特权的情况不同，不能将角色的成员资格授予 &lt;code&gt;PUBLIC&lt;/code&gt; 。还要注意，这种形式的命令不允许使用噪声字 &lt;code&gt;GROUP&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d61210b660dd2a2ba353539f0d486b1b1e1ca0f9" translate="yes" xml:space="preserve">
          <source>Unlike the standard C function &lt;code&gt;sprintf&lt;/code&gt;, PostgreSQL's &lt;code&gt;format&lt;/code&gt; function allows format specifiers with and without &lt;code&gt;position&lt;/code&gt; fields to be mixed in the same format string. A format specifier without a &lt;code&gt;position&lt;/code&gt; field always uses the next argument after the last argument consumed. In addition, the &lt;code&gt;format&lt;/code&gt; function does not require all function arguments to be used in the format string. For example:</source>
          <target state="translated">与标准C函数 &lt;code&gt;sprintf&lt;/code&gt; 不同，PostgreSQL的 &lt;code&gt;format&lt;/code&gt; 函数允许带有和不带有 &lt;code&gt;position&lt;/code&gt; 字段的格式说明符混合在同一格式字符串中。没有 &lt;code&gt;position&lt;/code&gt; 字段的格式说明符始终使用最后一个参数之后的下一个参数。另外， &lt;code&gt;format&lt;/code&gt; 函数不需要在格式字符串中使用所有函数参数。例如：</target>
        </trans-unit>
        <trans-unit id="42d22ba12e56f3a8c0a56dce7ddb132f01963118" translate="yes" xml:space="preserve">
          <source>Unlike the standard C function &lt;code&gt;sprintf&lt;/code&gt;, PostgreSQL's &lt;code&gt;format&lt;/code&gt; function allows format specifiers with and without &lt;em&gt;&lt;code&gt;position&lt;/code&gt;&lt;/em&gt; fields to be mixed in the same format string. A format specifier without a &lt;em&gt;&lt;code&gt;position&lt;/code&gt;&lt;/em&gt; field always uses the next argument after the last argument consumed. In addition, the &lt;code&gt;format&lt;/code&gt; function does not require all function arguments to be used in the format string. For example:</source>
          <target state="translated">与标准C函数 &lt;code&gt;sprintf&lt;/code&gt; 不同，PostgreSQL的 &lt;code&gt;format&lt;/code&gt; 函数允许带有和不带有&lt;em&gt; &lt;code&gt;position&lt;/code&gt; &lt;/em&gt;字段的格式说明符混合在同一格式字符串中。没有&lt;em&gt; &lt;code&gt;position&lt;/code&gt; &lt;/em&gt;字段的格式说明符始终使用最后一个参数之后的下一个参数。另外， &lt;code&gt;format&lt;/code&gt; 函数不需要在格式字符串中使用所有函数参数。例如：</target>
        </trans-unit>
        <trans-unit id="56340fd933fcc44d2d615474f7eee7f478fca5bb" translate="yes" xml:space="preserve">
          <source>Unlogged</source>
          <target state="translated">Unlogged</target>
        </trans-unit>
        <trans-unit id="b45f16ac00bccd2d97ad31eb4586a8a733d1ed1a" translate="yes" xml:space="preserve">
          <source>Unsets (deletes) the psql variable &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">取消设置（删除）psql变量 &lt;code&gt;name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b27e09825b38c1619e31484868bfeb48e96d8d2" translate="yes" xml:space="preserve">
          <source>Unsigned integer</source>
          <target state="translated">无符号整数</target>
        </trans-unit>
        <trans-unit id="50b79815e623c9d659af2f6f4f16ea14ba889265" translate="yes" xml:space="preserve">
          <source>Unused column contain zeroes. For example, &lt;code&gt;oprleft&lt;/code&gt; is zero for a prefix operator.</source>
          <target state="translated">未使用的列包含零。例如，对于前缀运算符， &lt;code&gt;oprleft&lt;/code&gt; 为零。</target>
        </trans-unit>
        <trans-unit id="2038bdec9210202d0d9d74839e3925ff0cd91ba1" translate="yes" xml:space="preserve">
          <source>Up</source>
          <target state="translated">Up</target>
        </trans-unit>
        <trans-unit id="d7530c6545fdfa9b651c7e47222acdb144b78573" translate="yes" xml:space="preserve">
          <source>Updatable Views</source>
          <target state="translated">可更新的意见</target>
        </trans-unit>
        <trans-unit id="fb91e24fa52d8d2b32937bf04d843f730319a902" translate="yes" xml:space="preserve">
          <source>Update</source>
          <target state="translated">Update</target>
        </trans-unit>
        <trans-unit id="6f08e7604a29958aee71de0f6521d5ea65d07570" translate="yes" xml:space="preserve">
          <source>Update &lt;code&gt;autoprewarm.blocks&lt;/code&gt; immediately. This may be useful if the autoprewarm worker is not running but you anticipate running it after the next restart. The return value is the number of records written to &lt;code&gt;autoprewarm.blocks&lt;/code&gt;.</source>
          <target state="translated">立即更新 &lt;code&gt;autoprewarm.blocks&lt;/code&gt; 。如果自动预热工作程序未运行，但您希望在下一次重新启动后运行它，这可能很有用。返回值是写入 &lt;code&gt;autoprewarm.blocks&lt;/code&gt; 的记录数。</target>
        </trans-unit>
        <trans-unit id="dd357ab63dd67dab2769f9aad042acbec503d583" translate="yes" xml:space="preserve">
          <source>Update a pre-9.1 installation of &lt;code&gt;hstore&lt;/code&gt; into extension style:</source>
          <target state="translated">将 &lt;code&gt;hstore&lt;/code&gt; 的9.1之前的安装更新为扩展样式：</target>
        </trans-unit>
        <trans-unit id="155fdafe50a3b57765513f60c5758d6496a123b2" translate="yes" xml:space="preserve">
          <source>Update contact names in an accounts table to match the currently assigned salesmen:</source>
          <target state="translated">更新账户表中的联系人姓名,以匹配当前分配的业务员。</target>
        </trans-unit>
        <trans-unit id="a54b58d6201c8e67be3e5d043168cab0aaf4bd7b" translate="yes" xml:space="preserve">
          <source>Update statistics in a summary table to match the current data:</source>
          <target state="translated">更新汇总表中的统计数据,使其与当前数据相匹配。</target>
        </trans-unit>
        <trans-unit id="a72e347972a409d75e922a98a8cb86184a8c091e" translate="yes" xml:space="preserve">
          <source>Update the collation's version. See &lt;a href=&quot;sql-altercollation#SQL-ALTERCOLLATION-NOTES&quot;&gt;Notes&lt;/a&gt; below.</source>
          <target state="translated">更新排序规则的版本。请参阅下面的&lt;a href=&quot;sql-altercollation#SQL-ALTERCOLLATION-NOTES&quot;&gt;注释&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="886aa2619ee6c1b5dcabc291df392328e61fad29" translate="yes" xml:space="preserve">
          <source>Update the sequence value after a &lt;code&gt;COPY FROM&lt;/code&gt;:</source>
          <target state="translated">在 &lt;code&gt;COPY FROM&lt;/code&gt; 之后更新序列值：</target>
        </trans-unit>
        <trans-unit id="40cf1fe41c48155dea09e4ac1106c72553cfd43c" translate="yes" xml:space="preserve">
          <source>Updates statistics used by the planner to determine the most efficient way to execute a query.</source>
          <target state="translated">更新规划器使用的统计数据,以确定执行查询的最有效方式。</target>
        </trans-unit>
        <trans-unit id="dd8ce06e479993fd7940ea48abaafb1c49415931" translate="yes" xml:space="preserve">
          <source>Updating Data</source>
          <target state="translated">更新数据</target>
        </trans-unit>
        <trans-unit id="bbfacc342802549d59dc86ad3b2d308cd32c8b65" translate="yes" xml:space="preserve">
          <source>Updating a GIN index tends to be slow because of the intrinsic nature of inverted indexes: inserting or updating one heap row can cause many inserts into the index (one for each key extracted from the indexed item). As of PostgreSQL 8.4, GIN is capable of postponing much of this work by inserting new tuples into a temporary, unsorted list of pending entries. When the table is vacuumed or autoanalyzed, or when &lt;code&gt;gin_clean_pending_list&lt;/code&gt; function is called, or if the pending list becomes larger than &lt;a href=&quot;runtime-config-client#GUC-GIN-PENDING-LIST-LIMIT&quot;&gt;gin_pending_list_limit&lt;/a&gt;, the entries are moved to the main GIN data structure using the same bulk insert techniques used during initial index creation. This greatly improves GIN index update speed, even counting the additional vacuum overhead. Moreover the overhead work can be done by a background process instead of in foreground query processing.</source>
          <target state="translated">由于反向索引的内在本质，更新GIN索引的速度往往很慢：插入或更新一个堆行会导致对索引的多次插入（从索引项中提取的每个键一个插入）。从PostgreSQL 8.4开始，GIN可以通过将新的元组插入到临时的，未排序的未决条目列表中来推迟很多工作。 &lt;code&gt;gin_clean_pending_list&lt;/code&gt; 或自动分析表时，或者调用gin_clean_pending_list函数时，或者待处理列表大于&lt;a href=&quot;runtime-config-client#GUC-GIN-PENDING-LIST-LIMIT&quot;&gt;gin_pending_list_limit时&lt;/a&gt;，则使用在初始索引创建期间使用的批量插入技术将条目移至主要GIN数据结构。即使不计算额外的真空开销，这也大大提高了GIN索引的更新速度。此外，开销工作可以通过后台处理而不是在前台查询处理中完成。</target>
        </trans-unit>
        <trans-unit id="f5a2d3257a7cb0893d951688c3d6595c16276249" translate="yes" xml:space="preserve">
          <source>Updating the partition key of a row might cause it to be moved into a different partition where this row satisfies the partition bounds.</source>
          <target state="translated">更新一行的分区键可能会导致它被移动到不同的分区中,在那里这行满足分区界限。</target>
        </trans-unit>
        <trans-unit id="cf5d0b369531663af264541c44e93e18c3ec6ca5" translate="yes" xml:space="preserve">
          <source>Upgrading a PostgreSQL Cluster</source>
          <target state="translated">升级PostgreSQL集群</target>
        </trans-unit>
        <trans-unit id="953812b4543e49a3e367bde451848478a686a885" translate="yes" xml:space="preserve">
          <source>Upgrading a PostgreSQL Cluster: Upgrading Data via Replication</source>
          <target state="translated">升级PostgreSQL集群。通过复制升级数据</target>
        </trans-unit>
        <trans-unit id="2a87484838982cc6d197b8aae2ccdf6a9936eca6" translate="yes" xml:space="preserve">
          <source>Upgrading a PostgreSQL Cluster: Upgrading Data via pg_dumpall</source>
          <target state="translated">升级PostgreSQL集群。通过pg_dumpall升级数据。</target>
        </trans-unit>
        <trans-unit id="725bfd4bce7d201deda730473db6dfc713d4524b" translate="yes" xml:space="preserve">
          <source>Upgrading a PostgreSQL Cluster: Upgrading Data via pg_upgrade</source>
          <target state="translated">升级PostgreSQL集群。通过pg_upgrade升级数据</target>
        </trans-unit>
        <trans-unit id="4b80cb33cf9b567178f3f5855946aac8c80e285f" translate="yes" xml:space="preserve">
          <source>Upon creation, a constraint is given one of three characteristics: &lt;code&gt;DEFERRABLE INITIALLY DEFERRED&lt;/code&gt;, &lt;code&gt;DEFERRABLE INITIALLY IMMEDIATE&lt;/code&gt;, or &lt;code&gt;NOT DEFERRABLE&lt;/code&gt;. The third class is always &lt;code&gt;IMMEDIATE&lt;/code&gt; and is not affected by the &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; command. The first two classes start every transaction in the indicated mode, but their behavior can be changed within a transaction by &lt;code&gt;SET CONSTRAINTS&lt;/code&gt;.</source>
          <target state="translated">创建后， &lt;code&gt;DEFERRABLE INITIALLY DEFERRED&lt;/code&gt; 约束提供以下三个特征之一：可初始延迟，可 &lt;code&gt;DEFERRABLE INITIALLY IMMEDIATE&lt;/code&gt; 或 &lt;code&gt;NOT DEFERRABLE&lt;/code&gt; 。第三类始终为 &lt;code&gt;IMMEDIATE&lt;/code&gt; ，不受 &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; 命令的影响。前两个类以指示的模式启动每个事务，但是可以通过 &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; 更改它们在事务内的行为。</target>
        </trans-unit>
        <trans-unit id="2d7a654640c2b50b3e7df60aeeabb5b08422ed24" translate="yes" xml:space="preserve">
          <source>Upper Limit</source>
          <target state="translated">上限</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="b4f04a10cb842d23a6e0c14dfb525ccfc19a7eeb" translate="yes" xml:space="preserve">
          <source>Usage notes for date/time formatting:</source>
          <target state="translated">日期/时间格式的使用说明。</target>
        </trans-unit>
        <trans-unit id="c18762bb9fd2f772e7a3cc1038dad6521a3cdc73" translate="yes" xml:space="preserve">
          <source>Usage notes for numeric formatting:</source>
          <target state="translated">数字格式的使用说明。</target>
        </trans-unit>
        <trans-unit id="c17fd067f164433138f454d194adc8307cae8bca" translate="yes" xml:space="preserve">
          <source>Usage of &lt;em&gt;edge recombination crossover&lt;/em&gt; which is especially suited to keep edge losses low for the solution of the TSP by means of a GA;</source>
          <target state="translated">&lt;em&gt;边缘重组交叉的&lt;/em&gt;使用，特别适用于通过GA解决TSP的问题时保持较低的边缘损耗；</target>
        </trans-unit>
        <trans-unit id="8cb6064dc167ff3a0e3b42195a78e15770baa73c" translate="yes" xml:space="preserve">
          <source>Usage of a &lt;em&gt;steady state&lt;/em&gt; GA (replacement of the least fit individuals in a population, not whole-generational replacement) allows fast convergence towards improved query plans. This is essential for query handling with reasonable time;</source>
          <target state="translated">使用&lt;em&gt;稳定状态的&lt;/em&gt; GA（替换总体中最不适合的个体，而不是全世代替换）可以快速收敛到改进的查询计划。这对于在合理的时间内处理查询至关重要。</target>
        </trans-unit>
        <trans-unit id="fc32adaef16ee6908ebadfca82b7126506f9473f" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt;'s &lt;code&gt;\ddp&lt;/code&gt; command to obtain information about existing assignments of default privileges. The meaning of the privilege display is the same as explained for &lt;code&gt;\dp&lt;/code&gt; in &lt;a href=&quot;ddl-priv&quot;&gt;Section 5.7&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt;的 &lt;code&gt;\ddp&lt;/code&gt; 命令获取有关默认权限的现有分配的信息。特权显示的意义是一样的说明 &lt;code&gt;\dp&lt;/code&gt; 在&lt;a href=&quot;ddl-priv&quot;&gt;第5.7节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6ba1f539905474c7406568a7a7f9b3f0d11b5735" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt; to change the attributes of a role, and &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt; to remove a role. All the attributes specified by &lt;code&gt;CREATE ROLE&lt;/code&gt; can be modified by later &lt;code&gt;ALTER ROLE&lt;/code&gt; commands.</source>
          <target state="translated">使用&lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt;更改角色的属性，并使用&lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt;删除角色。由 &lt;code&gt;CREATE ROLE&lt;/code&gt; 指定的所有属性都可以在以后的 &lt;code&gt;ALTER ROLE&lt;/code&gt; 命令中进行修改。</target>
        </trans-unit>
        <trans-unit id="c7488ebe056d7926158f410bc5c4336c809c61a3" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-call&quot;&gt;CALL&lt;/a&gt; to execute a procedure.</source>
          <target state="translated">使用&lt;a href=&quot;sql-call&quot;&gt;CALL&lt;/a&gt;执行过程。</target>
        </trans-unit>
        <trans-unit id="63fbf455d11c44c5877b87a971f27977e59c85ca" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-commit&quot;&gt;COMMIT&lt;/a&gt; or &lt;a href=&quot;sql-rollback&quot;&gt;ROLLBACK&lt;/a&gt; to terminate a transaction block.</source>
          <target state="translated">使用&lt;a href=&quot;sql-commit&quot;&gt;COMMIT&lt;/a&gt;或&lt;a href=&quot;sql-rollback&quot;&gt;ROLLBACK&lt;/a&gt;终止事务块。</target>
        </trans-unit>
        <trans-unit id="aa95bc5e0df28b02065365fe45c3e1b0d1eafbd6" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-commit&quot;&gt;COMMIT&lt;/a&gt; to successfully terminate a transaction.</source>
          <target state="translated">使用&lt;a href=&quot;sql-commit&quot;&gt;COMMIT&lt;/a&gt;成功终止事务。</target>
        </trans-unit>
        <trans-unit id="66e6213ccf4796834fff65a2132381a6fc00d716" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; to load all the rows in one command, instead of using a series of &lt;code&gt;INSERT&lt;/code&gt; commands. The &lt;code&gt;COPY&lt;/code&gt; command is optimized for loading large numbers of rows; it is less flexible than &lt;code&gt;INSERT&lt;/code&gt;, but incurs significantly less overhead for large data loads. Since &lt;code&gt;COPY&lt;/code&gt; is a single command, there is no need to disable autocommit if you use this method to populate a table.</source>
          <target state="translated">使用&lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt;可以在一个命令中加载所有行，而不是使用一系列 &lt;code&gt;INSERT&lt;/code&gt; 命令。该 &lt;code&gt;COPY&lt;/code&gt; 命令被用于装载大量行的优化; 它不如 &lt;code&gt;INSERT&lt;/code&gt; 灵活，但是对于大数据加载而言，所产生的开销却少得多。由于 &lt;code&gt;COPY&lt;/code&gt; 是单个命令，因此如果使用此方法填充表，则无需禁用自动提交。</target>
        </trans-unit>
        <trans-unit id="09047c3a617e15ed6b5d857521bdd8e734e0300e" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; to add new roles, and &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt; to remove a role.</source>
          <target state="translated">使用&lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;添加新角色，并使用&lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt;删除角色。</target>
        </trans-unit>
        <trans-unit id="9b4d3d6618c9949a9ad76ab0ddb5874169d923d3" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-dropcast&quot;&gt;DROP CAST&lt;/a&gt; to remove user-defined casts.</source>
          <target state="translated">使用&lt;a href=&quot;sql-dropcast&quot;&gt;DROP CAST&lt;/a&gt;删除用户定义的强制类型转换。</target>
        </trans-unit>
        <trans-unit id="f593b5e915433730446b465706be5f4af789f7c8" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-dropdatabase&quot;&gt;DROP DATABASE&lt;/a&gt; to remove a database.</source>
          <target state="translated">使用&lt;a href=&quot;sql-dropdatabase&quot;&gt;DROP DATABASE&lt;/a&gt;删除数据库。</target>
        </trans-unit>
        <trans-unit id="f6d31dd4270e5743088ace63fb2eb93db009e693" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-dropindex&quot;&gt;DROP INDEX&lt;/a&gt; to remove an index.</source>
          <target state="translated">使用&lt;a href=&quot;sql-dropindex&quot;&gt;DROP INDEX&lt;/a&gt;删除索引。</target>
        </trans-unit>
        <trans-unit id="c243eaa6db16e01a7e2d96464804f5badfa4a886" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-droplanguage&quot;&gt;DROP LANGUAGE&lt;/a&gt; to drop procedural languages.</source>
          <target state="translated">使用&lt;a href=&quot;sql-droplanguage&quot;&gt;DROP LANGUAGE&lt;/a&gt;删除过程语言。</target>
        </trans-unit>
        <trans-unit id="611b170ec13c2b52270c3dae6f1ab02cf82d138c" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-dropoperator&quot;&gt;DROP OPERATOR&lt;/a&gt; to delete user-defined operators from a database. Use &lt;a href=&quot;sql-alteroperator&quot;&gt;ALTER OPERATOR&lt;/a&gt; to modify operators in a database.</source>
          <target state="translated">使用&lt;a href=&quot;sql-dropoperator&quot;&gt;DROP OPERATOR&lt;/a&gt;从数据库中删除用户定义的运算符。使用&lt;a href=&quot;sql-alteroperator&quot;&gt;ALTER OPERATOR&lt;/a&gt;修改数据库中的运算符。</target>
        </trans-unit>
        <trans-unit id="58497b86e7746a484024506bf39de0e9955831f3" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-droptransform&quot;&gt;DROP TRANSFORM&lt;/a&gt; to remove transforms.</source>
          <target state="translated">使用&lt;a href=&quot;sql-droptransform&quot;&gt;DROP TRANSFORM&lt;/a&gt;删除变换。</target>
        </trans-unit>
        <trans-unit id="b075359ef1491da7c72c666849ad06ca28042837" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-droptrigger&quot;&gt;DROP TRIGGER&lt;/a&gt; to remove a trigger.</source>
          <target state="translated">使用&lt;a href=&quot;sql-droptrigger&quot;&gt;DROP TRIGGER&lt;/a&gt;删除触发器。</target>
        </trans-unit>
        <trans-unit id="e27e35b2729f99b5a4d57cb1356ed22041def512" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-release-savepoint&quot;&gt;RELEASE SAVEPOINT&lt;/a&gt; to destroy a savepoint without discarding the effects of commands executed after it was established.</source>
          <target state="translated">使用&lt;a href=&quot;sql-release-savepoint&quot;&gt;RELEASE SAVEPOINT&lt;/a&gt;销毁一个保存点，而不会丢弃建立该保存点后执行的命令的效果。</target>
        </trans-unit>
        <trans-unit id="54340c6db432893de03388140d111cf79cc5bd33" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-rollback&quot;&gt;ROLLBACK&lt;/a&gt; to abort a transaction.</source>
          <target state="translated">使用&lt;a href=&quot;sql-rollback&quot;&gt;ROLLBACK&lt;/a&gt;中止事务。</target>
        </trans-unit>
        <trans-unit id="b54ec80fcdd9c1cc0a780b0c3e10b24a114e978c" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-rollback-to&quot;&gt;ROLLBACK TO SAVEPOINT&lt;/a&gt; to rollback to a savepoint. Use &lt;a href=&quot;sql-release-savepoint&quot;&gt;RELEASE SAVEPOINT&lt;/a&gt; to destroy a savepoint, keeping the effects of commands executed after it was established.</source>
          <target state="translated">使用&lt;a href=&quot;sql-rollback-to&quot;&gt;ROLLBACK TO SAVEPOINT&lt;/a&gt;回滚到保存点。使用&lt;a href=&quot;sql-release-savepoint&quot;&gt;RELEASE SAVEPOINT&lt;/a&gt;销毁一个保存点，并在建立保存点后保持命令执行的效果。</target>
        </trans-unit>
        <trans-unit id="f8f348396f663d6710748aac99721ad4f0c1192d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;DROP COLLATION&lt;/code&gt; to remove user-defined collations.</source>
          <target state="translated">使用 &lt;code&gt;DROP COLLATION&lt;/code&gt; 删除用户定义的排序规则。</target>
        </trans-unit>
        <trans-unit id="f84b3986ffc86a297e493d0aa18ef741b0d79725" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;DROP CONVERSION&lt;/code&gt; to remove user-defined conversions.</source>
          <target state="translated">使用 &lt;code&gt;DROP CONVERSION&lt;/code&gt; 删除用户定义的转换。</target>
        </trans-unit>
        <trans-unit id="ff15db4e13f780cb214c1fb5755bb245ba8cdda8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;DROP SEQUENCE&lt;/code&gt; to remove a sequence.</source>
          <target state="translated">使用 &lt;code&gt;DROP SEQUENCE&lt;/code&gt; 删除序列。</target>
        </trans-unit>
        <trans-unit id="15726e7944bcacfcfd9200215f0e42b66131bfdd" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;OUT&lt;/code&gt; parameters to define the return type implicitly. The same example could also be done this way:</source>
          <target state="translated">使用 &lt;code&gt;OUT&lt;/code&gt; 参数隐式定义返回类型。同样的例子也可以这样：</target>
        </trans-unit>
        <trans-unit id="67538321bf9a606c6338bda53e8523a0fee89c08" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;\lo_list&lt;/code&gt; to find out the large object's OID.</source>
          <target state="translated">使用 &lt;code&gt;\lo_list&lt;/code&gt; 找出大对象的OID。</target>
        </trans-unit>
        <trans-unit id="2965f87f5b2b233b83696be719d6f81a6a38ddaa" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;restore_command&lt;/code&gt; defined in the target cluster configuration to retrieve WAL files from the WAL archive if these files are no longer available in the &lt;code&gt;pg_wal&lt;/code&gt; directory.</source>
          <target state="translated">如果在 &lt;code&gt;pg_wal&lt;/code&gt; 目录中不再有这些文件，请使用在目标集群配置中定义的 &lt;code&gt;restore_command&lt;/code&gt; 从WAL档案中检索WAL文件。</target>
        </trans-unit>
        <trans-unit id="5c1ddd9e45a36cc1cb06c4712dd45f333163ae53" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;separator&lt;/code&gt; as the field separator for unaligned output. This is equivalent to &lt;code&gt;\pset fieldsep&lt;/code&gt; or &lt;code&gt;\f&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;separator&lt;/code&gt; 作为未对齐输出的字段分隔符。这等效于 &lt;code&gt;\pset fieldsep&lt;/code&gt; 或 &lt;code&gt;\f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f33f5b37daa8a924b75643b07be4642a71a3839" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;separator&lt;/code&gt; as the record separator for unaligned output. This is equivalent to &lt;code&gt;\pset recordsep&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;separator&lt;/code&gt; 作为未对齐输出的记录分隔符。这等效于 &lt;code&gt;\pset recordsep&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5d5c3e044f569ed4a54b5c8b2aeebf1c2b6cc75" translate="yes" xml:space="preserve">
          <source>Use GSSAPI to authenticate the user. This is only available for TCP/IP connections. See &lt;a href=&quot;gssapi-auth&quot;&gt;Section 20.6&lt;/a&gt; for details. It can be used in conjunction with GSSAPI encryption.</source>
          <target state="translated">使用GSSAPI对用户进行身份验证。这仅适用于TCP / IP连接。有关详细信息，请参见&lt;a href=&quot;gssapi-auth&quot;&gt;第20.6节&lt;/a&gt;。它可以与GSSAPI加密结合使用。</target>
        </trans-unit>
        <trans-unit id="aeb12709af5299bd1b78d1fc87510677adf5e4d9" translate="yes" xml:space="preserve">
          <source>Use SSPI to authenticate the user. This is only available on Windows. See &lt;a href=&quot;sspi-auth&quot;&gt;Section 20.7&lt;/a&gt; for details.</source>
          <target state="translated">使用SSPI对用户进行身份验证。仅在Windows上可用。有关详细信息，请参见&lt;a href=&quot;sspi-auth&quot;&gt;第20.7节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="09a0b632c4471d6df190780101d005ba97319161" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;serializable&lt;/code&gt; transaction for the dump, to ensure that the snapshot used is consistent with later database states; but do this by waiting for a point in the transaction stream at which no anomalies can be present, so that there isn't a risk of the dump failing or causing other transactions to roll back with a &lt;code&gt;serialization_failure&lt;/code&gt;. See &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt; for more information about transaction isolation and concurrency control.</source>
          <target state="translated">对转储使用可 &lt;code&gt;serializable&lt;/code&gt; 事务，以确保使用的快照与以后的数据库状态一致；但这要通过等待事务流中不会出现异常的点来完成，这样就不会存在转储失败或导致其他事务因 &lt;code&gt;serialization_failure&lt;/code&gt; 而回滚的风险。有关事务隔离和并发控制的更多信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;第13章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9ca5d4bab09764f17142fbf20ac5e71fb208ada4" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;serializable&lt;/code&gt; transaction for the dump, to ensure that the snapshot used is consistent with later database states; but do this by waiting for a point in the transaction stream at which no anomalies can be present, so that there isn't a risk of the dump failing or causing other transactions to roll back with a &lt;code&gt;serialization_failure&lt;/code&gt;. See &lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt; for more information about transaction isolation and concurrency control.</source>
          <target state="translated">对转储使用可 &lt;code&gt;serializable&lt;/code&gt; 事务，以确保使用的快照与更高版本的数据库状态一致；但这要通过等待事务流中不会出现异常的点来完成，这样就不会存在转储失败或导致其他事务因 &lt;code&gt;serialization_failure&lt;/code&gt; 而回滚的风险。有关事务隔离和并发控制的更多信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;第13章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2c1cd79ab101e360e9a13e652ea38bf6edc2d76e" translate="yes" xml:space="preserve">
          <source>Use an &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt;exclusion constraint&lt;/a&gt; to enforce the rule that a cage at a zoo can contain only one kind of animal:</source>
          <target state="translated">使用&lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt;排除约束&lt;/a&gt;来强制执行以下规则：动物园的笼子只能容纳一种动物：</target>
        </trans-unit>
        <trans-unit id="f3ff396f1aa38be47c72d90438e9b5c8fc599d4d" translate="yes" xml:space="preserve">
          <source>Use checksums on data pages to help detect corruption by the I/O system that would otherwise be silent. Enabling checksums may incur a noticeable performance penalty. If set, checksums are calculated for all objects, in all databases. All checksum failures will be reported in the &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-DATABASE-VIEW&quot;&gt;&lt;code&gt;pg_stat_database&lt;/code&gt;&lt;/a&gt; view.</source>
          <target state="translated">在数据页上使用校验和，以帮助检测I / O系统的损坏，否则这些损坏将是静默的。启用校验和可能会导致明显的性能损失。如果设置，将为所有数据库中的所有对象计算校验和。所有校验和失败都将在&lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-DATABASE-VIEW&quot;&gt; &lt;code&gt;pg_stat_database&lt;/code&gt; &lt;/a&gt;视图中报告。</target>
        </trans-unit>
        <trans-unit id="ed495ec2e832a44d27151818dc3a53eb05f6485b" translate="yes" xml:space="preserve">
          <source>Use checksums on data pages to help detect corruption by the I/O system that would otherwise be silent. Enabling checksums may incur a noticeable performance penalty. If set, checksums are calculated for all objects, in all databases. All checksum failures will be reported in the &lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-VIEW&quot;&gt;pg_stat_database&lt;/a&gt; view.</source>
          <target state="translated">在数据页上使用校验和，以帮助检测I / O系统的损坏，否则这些损坏将是静默的。启用校验和可能会导致明显的性能损失。如果设置，将为所有数据库中的所有对象计算校验和。所有校验和失败都将在&lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-VIEW&quot;&gt;pg_stat_database&lt;/a&gt;视图中报告。</target>
        </trans-unit>
        <trans-unit id="ce023d8439552305d2edc6e2bf4149ad204ec26c" translate="yes" xml:space="preserve">
          <source>Use conditional commands (i.e. add an &lt;code&gt;IF EXISTS&lt;/code&gt; clause) to drop database objects. This option is not valid unless &lt;code&gt;--clean&lt;/code&gt; is also specified.</source>
          <target state="translated">使用条件命令（即添加 &lt;code&gt;IF EXISTS&lt;/code&gt; 子句）删除数据库对象。除非还指定了 &lt;code&gt;--clean&lt;/code&gt; ,否则此选项无效。</target>
        </trans-unit>
        <trans-unit id="d755e67717cdd34225a86cde8e3134de7095e52a" translate="yes" xml:space="preserve">
          <source>Use conditional commands (i.e. add an &lt;code&gt;IF EXISTS&lt;/code&gt; clause) to drop databases and other objects. This option is not valid unless &lt;code&gt;--clean&lt;/code&gt; is also specified.</source>
          <target state="translated">使用条件命令（即添加 &lt;code&gt;IF EXISTS&lt;/code&gt; 子句）删除数据库和其他对象。除非还指定了 &lt;code&gt;--clean&lt;/code&gt; ,否则此选项无效。</target>
        </trans-unit>
        <trans-unit id="723b15fd565cd7b73cc4c9f69508e6bb65d787d0" translate="yes" xml:space="preserve">
          <source>Use conditional commands (i.e. add an &lt;code&gt;IF EXISTS&lt;/code&gt; clause) when cleaning database objects. This option is not valid unless &lt;code&gt;--clean&lt;/code&gt; is also specified.</source>
          <target state="translated">清理数据库对象时，请使用条件命令（即添加 &lt;code&gt;IF EXISTS&lt;/code&gt; 子句）。除非还指定了 &lt;code&gt;--clean&lt;/code&gt; ,否则此选项无效。</target>
        </trans-unit>
        <trans-unit id="e393204f90a01988137d09cb6497fb713cc35dc8" translate="yes" xml:space="preserve">
          <source>Use conditional commands (i.e., add an &lt;code&gt;IF EXISTS&lt;/code&gt; clause) to drop database objects. This option is not valid unless &lt;code&gt;--clean&lt;/code&gt; is also specified.</source>
          <target state="translated">使用条件命令（即添加 &lt;code&gt;IF EXISTS&lt;/code&gt; 子句）删除数据库对象。除非还指定了 &lt;code&gt;--clean&lt;/code&gt; ,否则此选项无效。</target>
        </trans-unit>
        <trans-unit id="03fb63958860db5f3f91183fba351eaf47350bb0" translate="yes" xml:space="preserve">
          <source>Use conditional commands (i.e., add an &lt;code&gt;IF EXISTS&lt;/code&gt; clause) to drop databases and other objects. This option is not valid unless &lt;code&gt;--clean&lt;/code&gt; is also specified.</source>
          <target state="translated">使用条件命令（即添加 &lt;code&gt;IF EXISTS&lt;/code&gt; 子句）删除数据库和其他对象。除非还指定了 &lt;code&gt;--clean&lt;/code&gt; ,否则此选项无效。</target>
        </trans-unit>
        <trans-unit id="7dab14262df7a0d62d0ac14dd30b69bdadab90b1" translate="yes" xml:space="preserve">
          <source>Use conditional commands (i.e., add an &lt;code&gt;IF EXISTS&lt;/code&gt; clause) when cleaning database objects. This option is not valid unless &lt;code&gt;--clean&lt;/code&gt; is also specified.</source>
          <target state="translated">清理数据库对象时，请使用条件命令（即，添加 &lt;code&gt;IF EXISTS&lt;/code&gt; 子句）。除非还指定了 &lt;code&gt;--clean&lt;/code&gt; ,否则此选项无效。</target>
        </trans-unit>
        <trans-unit id="f8dc23b011f6f1a62e695d4c31ea4636fb489dcc" translate="yes" xml:space="preserve">
          <source>Use efficient file cloning (also known as &amp;ldquo;reflinks&amp;rdquo; on some systems) instead of copying files to the new cluster. This can result in near-instantaneous copying of the data files, giving the speed advantages of &lt;code&gt;-k&lt;/code&gt;/&lt;code&gt;--link&lt;/code&gt; while leaving the old cluster untouched.</source>
          <target state="translated">使用有效的文件克隆（在某些系统上也称为&amp;ldquo; reflinks&amp;rdquo;），而不是将文件复制到新集群。这可能会导致几乎瞬时复制数据文件，从而在不影响旧群集的情况下提供 &lt;code&gt;-k&lt;/code&gt; / &lt;code&gt;--link&lt;/code&gt; 的速度优势。</target>
        </trans-unit>
        <trans-unit id="717457386c7410d1c0caadadb8bcf5cee9b94ef2" translate="yes" xml:space="preserve">
          <source>Use genetic query optimization to plan queries with at least this many &lt;code&gt;FROM&lt;/code&gt; items involved. (Note that a &lt;code&gt;FULL OUTER JOIN&lt;/code&gt; construct counts as only one &lt;code&gt;FROM&lt;/code&gt; item.) The default is 12. For simpler queries it is usually best to use the regular, exhaustive-search planner, but for queries with many tables the exhaustive search takes too long, often longer than the penalty of executing a suboptimal plan. Thus, a threshold on the size of the query is a convenient way to manage use of GEQO.</source>
          <target state="translated">使用遗传查询优化来计划至少涉及这么多 &lt;code&gt;FROM&lt;/code&gt; 项的查询。（请注意， &lt;code&gt;FULL OUTER JOIN&lt;/code&gt; 构造仅计为一个 &lt;code&gt;FROM&lt;/code&gt; 项。）默认值为12。对于更简单的查询，通常最好使用常规的穷举搜索计划程序，但是对于具有多个表的查询，穷举搜索会花费很长时间。 ，通常比执行次优计划的代价要长。因此，查询大小的阈值是管理GEQO使用的便捷方法。</target>
        </trans-unit>
        <trans-unit id="a0976de4de13332a56e83de88d1173b0054dd784" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;INHERITS&lt;/code&gt; creates a persistent relationship between the new child table and its parent table(s). Schema modifications to the parent(s) normally propagate to children as well, and by default the data of the child table is included in scans of the parent(s).</source>
          <target state="translated">使用 &lt;code&gt;INHERITS&lt;/code&gt; 将在新的子表及其父表之间创建持久关系。对父级的架构修改通常也会传播到子级，默认情况下，子级表的数据包含在对父级的扫描中。</target>
        </trans-unit>
        <trans-unit id="9e4eb26aa371684361e3e419e078890b371282ac" translate="yes" xml:space="preserve">
          <source>Use of most of these functions requires PostgreSQL to have been built with &lt;code&gt;configure --with-libxml&lt;/code&gt;.</source>
          <target state="translated">要使用其中的大多数功能，需要使用 &lt;code&gt;configure --with-libxml&lt;/code&gt; 构建PostgreSQL 。</target>
        </trans-unit>
        <trans-unit id="c68e27d415e6287dfc4c6988546eee3d268cda34" translate="yes" xml:space="preserve">
          <source>Use of symbolic references is enabled in a particular catalog column by attaching &lt;code&gt;BKI_LOOKUP(lookuprule)&lt;/code&gt; to the column's definition, where &lt;code&gt;lookuprule&lt;/code&gt; is the name of the referenced catalog, e.g. &lt;code&gt;pg_proc&lt;/code&gt;. &lt;code&gt;BKI_LOOKUP&lt;/code&gt; can be attached to columns of type &lt;code&gt;Oid&lt;/code&gt;, &lt;code&gt;regproc&lt;/code&gt;, &lt;code&gt;oidvector&lt;/code&gt;, or &lt;code&gt;Oid[]&lt;/code&gt;; in the latter two cases it implies performing a lookup on each element of the array.</source>
          <target state="translated">通过将 &lt;code&gt;BKI_LOOKUP(lookuprule)&lt;/code&gt; 附加到列的定义，可以在特定的目录列中使用符号引用，其中 &lt;code&gt;lookuprule&lt;/code&gt; 是所引用目录的名称，例如 &lt;code&gt;pg_proc&lt;/code&gt; 。 &lt;code&gt;BKI_LOOKUP&lt;/code&gt; 可以附加到 &lt;code&gt;Oid&lt;/code&gt; ， &lt;code&gt;regproc&lt;/code&gt; ， &lt;code&gt;oidvector&lt;/code&gt; 或 &lt;code&gt;Oid[]&lt;/code&gt; 类型的列上；在后两种情况下，它意味着对数组的每个元素执行查找。</target>
        </trans-unit>
        <trans-unit id="3fb4ce36062b56e26da7090e374ab7610c6e2ceb" translate="yes" xml:space="preserve">
          <source>Use of symbolic references is enabled in a particular catalog column by attaching &lt;code&gt;BKI_LOOKUP(lookuprule)&lt;/code&gt; to the column's definition, where &lt;code&gt;lookuprule&lt;/code&gt; is the name of the referenced catalog, e.g., &lt;code&gt;pg_proc&lt;/code&gt;. &lt;code&gt;BKI_LOOKUP&lt;/code&gt; can be attached to columns of type &lt;code&gt;Oid&lt;/code&gt;, &lt;code&gt;regproc&lt;/code&gt;, &lt;code&gt;oidvector&lt;/code&gt;, or &lt;code&gt;Oid[]&lt;/code&gt;; in the latter two cases it implies performing a lookup on each element of the array.</source>
          <target state="translated">通过将 &lt;code&gt;BKI_LOOKUP(lookuprule)&lt;/code&gt; 附加到列的定义，可以在特定的目录列中使用符号引用，其中 &lt;code&gt;lookuprule&lt;/code&gt; 是所引用目录的名称，例如 &lt;code&gt;pg_proc&lt;/code&gt; 。 &lt;code&gt;BKI_LOOKUP&lt;/code&gt; 可以附加到 &lt;code&gt;Oid&lt;/code&gt; ， &lt;code&gt;regproc&lt;/code&gt; ， &lt;code&gt;oidvector&lt;/code&gt; 或 &lt;code&gt;Oid[]&lt;/code&gt; 类型的列上；在后两种情况下，它意味着对数组的每个元素执行查找。</target>
        </trans-unit>
        <trans-unit id="7de245d3c3aa0bf5e90f594f4cb93e3038943a92" translate="yes" xml:space="preserve">
          <source>Use of the &lt;code&gt;RETURNING&lt;/code&gt; clause requires &lt;code&gt;SELECT&lt;/code&gt; privilege on all columns mentioned in &lt;code&gt;RETURNING&lt;/code&gt;. If you use the &lt;code&gt;query&lt;/code&gt; clause to insert rows from a query, you of course need to have &lt;code&gt;SELECT&lt;/code&gt; privilege on any table or column used in the query.</source>
          <target state="translated">使用 &lt;code&gt;RETURNING&lt;/code&gt; 子句需要 &lt;code&gt;RETURNING&lt;/code&gt; 中提到的所有列都具有 &lt;code&gt;SELECT&lt;/code&gt; 特权。如果使用 &lt;code&gt;query&lt;/code&gt; 子句从查询中插入行，那么您当然需要对查询中使用的任何表或列具有 &lt;code&gt;SELECT&lt;/code&gt; 特权。</target>
        </trans-unit>
        <trans-unit id="2aa84cc2dc2791298c5a401376b7bb182eec75e7" translate="yes" xml:space="preserve">
          <source>Use real data for experimentation. Using test data for setting up indexes will tell you what indexes you need for the test data, but that is all.</source>
          <target state="translated">使用真实数据进行实验。使用测试数据来设置索引会告诉你测试数据需要什么索引,但仅此而已。</target>
        </trans-unit>
        <trans-unit id="740a1a424b9afbaad4fd5f97eac328593356e696" translate="yes" xml:space="preserve">
          <source>Use semicolon followed by two newlines, rather than just newline, as the command entry terminator.</source>
          <target state="translated">使用分号后的两个换行,而不是仅仅使用换行,作为命令输入的结束符。</target>
        </trans-unit>
        <trans-unit id="493672dde3eb1e21802c93c463663707684dc28f" translate="yes" xml:space="preserve">
          <source>Use separate session key. Public-key encryption always uses a separate session key; this option is for symmetric-key encryption, which by default uses the S2K key directly.</source>
          <target state="translated">使用单独的会话密钥。公钥加密总是使用单独的会话密钥;这个选项适用于对称密钥加密,默认情况下,它直接使用S2K密钥。</target>
        </trans-unit>
        <trans-unit id="93c526253accc03345c125a338a69425d93d7a5c" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;sql-dropview&quot;&gt;DROP VIEW&lt;/a&gt; statement to drop views.</source>
          <target state="translated">使用&lt;a href=&quot;sql-dropview&quot;&gt;DROP VIEW&lt;/a&gt;语句删除视图。</target>
        </trans-unit>
        <trans-unit id="0d8fcf6d0e2c0c387fa9db23f6382b953340061f" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;CONCURRENTLY&lt;/code&gt; option. See &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt; for further information.</source>
          <target state="translated">使用 &lt;code&gt;CONCURRENTLY&lt;/code&gt; 选项。有关更多信息，请参见&lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3b4b457d273cfa55849542aa4f8ee8d5c092684f" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;CONCURRENTLY&lt;/code&gt; option. See &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt;, where all the caveats of this option are explained in detail.</source>
          <target state="translated">使用 &lt;code&gt;CONCURRENTLY&lt;/code&gt; 选项。请参阅&lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt;，其中详细说明了此选项的所有警告。</target>
        </trans-unit>
        <trans-unit id="49e85f329c30105292985206289324c8f90af224" translate="yes" xml:space="preserve">
          <source>Use the alternative column-list syntax to do the same update:</source>
          <target state="translated">使用另一种列列表语法来进行同样的更新。</target>
        </trans-unit>
        <trans-unit id="c367993bbb1f90b5675f542abe2a7cf24ff8d497" translate="yes" xml:space="preserve">
          <source>Use the manifest file at the specified path, rather than one located in the root of the backup directory.</source>
          <target state="translated">使用指定路径上的清单文件,而不是位于备份目录根部的文件。</target>
        </trans-unit>
        <trans-unit id="9ae2307b8f401e6a987e3d05544bf2939cd859f9" translate="yes" xml:space="preserve">
          <source>Use the specified operating system locale for the &lt;code&gt;LC_COLLATE&lt;/code&gt; locale category.</source>
          <target state="translated">将指定的操作系统语言环境用于 &lt;code&gt;LC_COLLATE&lt;/code&gt; 语言环境类别。</target>
        </trans-unit>
        <trans-unit id="55a394e7b9e61f2a206b4b6967eab6c67d2c7b7c" translate="yes" xml:space="preserve">
          <source>Use the specified operating system locale for the &lt;code&gt;LC_CTYPE&lt;/code&gt; locale category.</source>
          <target state="translated">将指定的操作系统语言环境用于 &lt;code&gt;LC_CTYPE&lt;/code&gt; 语言环境类别。</target>
        </trans-unit>
        <trans-unit id="b2aa6b91b4c4ba84fa390b2a6da37aa75a60894a" translate="yes" xml:space="preserve">
          <source>Use the specified synchronized snapshot when making a dump of the database (see &lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION-TABLE&quot;&gt;Table 9.87&lt;/a&gt; for more details).</source>
          <target state="translated">转储数据库时，请使用指定的同步快照（有关更多详细信息，请&lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION-TABLE&quot;&gt;参见表9.87&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="f01c307a5f93cc4ea8d811925d49d9a9c26369ed" translate="yes" xml:space="preserve">
          <source>Use the specified synchronized snapshot when making a dump of the database (see &lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION-TABLE&quot;&gt;Table 9.88&lt;/a&gt; for more details).</source>
          <target state="translated">转储数据库时，请使用指定的同步快照（有关更多详细信息，请&lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION-TABLE&quot;&gt;参见表9.88&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ee78ab2ce0e01deb66fa480713a33b2c2b35d2ab" translate="yes" xml:space="preserve">
          <source>Use the specified value of &lt;code&gt;extra_float_digits&lt;/code&gt; when dumping floating-point data, instead of the maximum available precision. Routine dumps made for backup purposes should not use this option.</source>
          <target state="translated">转储浮点数据时，请使用指定的 &lt;code&gt;extra_float_digits&lt;/code&gt; 值，而不是最大可用精度。出于备份目的而进行的例行转储不应使用此选项。</target>
        </trans-unit>
        <trans-unit id="af4516f566a55d94c31709c01f556432e3bd7291" translate="yes" xml:space="preserve">
          <source>Use the specified value of extra_float_digits when dumping floating-point data, instead of the maximum available precision. Routine dumps made for backup purposes should not use this option.</source>
          <target state="translated">当转储浮点数据时,使用指定的 extra_float_digits 值,而不是最大的可用精度。为了备份而进行的常规转储不应该使用这个选项。</target>
        </trans-unit>
        <trans-unit id="6f31da9aa85cb07454372ac17645a52a84247324" translate="yes" xml:space="preserve">
          <source>Use this sequence in an &lt;code&gt;INSERT&lt;/code&gt; command:</source>
          <target state="translated">在 &lt;code&gt;INSERT&lt;/code&gt; 命令中使用以下顺序：</target>
        </trans-unit>
        <trans-unit id="29370364d5a3aa7edfb47c0679c084d535a999d7" translate="yes" xml:space="preserve">
          <source>Used to allow inference of partial unique indexes. Any indexes that satisfy the predicate (which need not actually be partial indexes) can be inferred. Follows &lt;code&gt;CREATE INDEX&lt;/code&gt; format. &lt;code&gt;SELECT&lt;/code&gt; privilege on any column appearing within &lt;code&gt;index_predicate&lt;/code&gt; is required.</source>
          <target state="translated">用于允许推断部分唯一索引。可以推断出满足谓词的任何索引（实际上不一定是部分索引）。遵循 &lt;code&gt;CREATE INDEX&lt;/code&gt; 格式。需要对出现在 &lt;code&gt;index_predicate&lt;/code&gt; 中的任何列具有 &lt;code&gt;SELECT&lt;/code&gt; 特权。</target>
        </trans-unit>
        <trans-unit id="60a26aae579e4125ce2ef1b4188cb642a6c52362" translate="yes" xml:space="preserve">
          <source>Used to compute the maximum amount of memory that hash-based operations can use. The final limit is determined by multiplying &lt;code&gt;work_mem&lt;/code&gt; by &lt;code&gt;hash_mem_multiplier&lt;/code&gt;. The default value is 1.0, which makes hash-based operations subject to the same simple &lt;code&gt;work_mem&lt;/code&gt; maximum as sort-based operations.</source>
          <target state="translated">用于计算基于散列的操作可以使用的最大内存量。最终限制是通过将 &lt;code&gt;work_mem&lt;/code&gt; 乘以hash_mem_multiplier来 &lt;code&gt;hash_mem_multiplier&lt;/code&gt; 。默认值为1.0，这使基于散列的操作与基于排序的操作受相同的简单 &lt;code&gt;work_mem&lt;/code&gt; 最大限制。</target>
        </trans-unit>
        <trans-unit id="1bfbb286795d184b793a60a1094e6c47b8ed4218" translate="yes" xml:space="preserve">
          <source>Useful values for production work probably range from a small number of hours to a few days. Small values (such as &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1min&lt;/code&gt;) are only allowed because they may sometimes be useful for testing. While a setting as high as &lt;code&gt;60d&lt;/code&gt; is allowed, please note that in many workloads extreme bloat or transaction ID wraparound may occur in much shorter time frames.</source>
          <target state="translated">生产工作的有用值可能从几个小时到几天不等。仅允许使用较小的值（例如 &lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;1min&lt;/code&gt; ），因为它们有时可能对测试有用。尽管允许的设置最高为 &lt;code&gt;60d&lt;/code&gt; ，但请注意，在许多工作负载中，可能会在很短的时间内发生极端的膨胀或事务ID环绕。</target>
        </trans-unit>
        <trans-unit id="9f8a2389a20ca0752aa9e95093515517e90e194c" translate="yes" xml:space="preserve">
          <source>User</source>
          <target state="translated">User</target>
        </trans-unit>
        <trans-unit id="0aa9c997122e493dfcfb31ff0542b184a558e6ef" translate="yes" xml:space="preserve">
          <source>User Name Maps</source>
          <target state="translated">用户名地图</target>
        </trans-unit>
        <trans-unit id="657c8b98d31db02ca6e2f49846863d392059fe65" translate="yes" xml:space="preserve">
          <source>User bypasses every row level security policy, see &lt;a href=&quot;ddl-rowsecurity&quot;&gt;Section 5.8&lt;/a&gt; for more information.</source>
          <target state="translated">用户绕过每个行级安全策略，有关更多信息，请参见&lt;a href=&quot;ddl-rowsecurity&quot;&gt;第5.8节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="17a367250b51dc731bdf8cbd166e2c6618238172" translate="yes" xml:space="preserve">
          <source>User can create databases</source>
          <target state="translated">用户可以创建数据库</target>
        </trans-unit>
        <trans-unit id="0cd638046cbfe5c1f3e3cd84a3d83b310d114f21" translate="yes" xml:space="preserve">
          <source>User can initiate streaming replication and put the system in and out of backup mode.</source>
          <target state="translated">用户可以启动流式复制,并使系统进入和退出备份模式。</target>
        </trans-unit>
        <trans-unit id="62ff3be7aa18f82b61ae56cce7156698ab778283" translate="yes" xml:space="preserve">
          <source>User is a superuser</source>
          <target state="translated">用户是超级用户</target>
        </trans-unit>
        <trans-unit id="4aef5e6fb407d9fa24def89a2aaec4ed9412ef6a" translate="yes" xml:space="preserve">
          <source>User mapping</source>
          <target state="translated">用户图谱</target>
        </trans-unit>
        <trans-unit id="0381065a82fe9d6c10d8cd3e9089f5c14f9312b8" translate="yes" xml:space="preserve">
          <source>User mapping specific options, as &amp;ldquo;keyword=value&amp;rdquo; strings</source>
          <target state="translated">用户映射特定选项，如&amp;ldquo;关键字=值&amp;rdquo;字符串</target>
        </trans-unit>
        <trans-unit id="542fc71480dec743e60c20434ec6dd5838fc4b52" translate="yes" xml:space="preserve">
          <source>User name</source>
          <target state="translated">用户名称</target>
        </trans-unit>
        <trans-unit id="0966c5e99e856745941e09bf863b1894eaa04766" translate="yes" xml:space="preserve">
          <source>User name for the user to run the service as. For domain users, use the format &lt;code&gt;DOMAIN\username&lt;/code&gt;.</source>
          <target state="translated">用户用于运行服务的用户名。对于域用户，请使用 &lt;code&gt;DOMAIN\username&lt;/code&gt; 格式。</target>
        </trans-unit>
        <trans-unit id="ae03b2f53e94d67697836cc9ddba3d24303f1bd3" translate="yes" xml:space="preserve">
          <source>User name maps are defined in the ident map file, which by default is named &lt;code&gt;pg_ident.conf&lt;/code&gt; and is stored in the cluster's data directory. (It is possible to place the map file elsewhere, however; see the &lt;a href=&quot;runtime-config-file-locations#GUC-IDENT-FILE&quot;&gt;ident_file&lt;/a&gt; configuration parameter.) The ident map file contains lines of the general form:</source>
          <target state="translated">用户名映射在ident映射文件中定义，该文件默认情况下名为 &lt;code&gt;pg_ident.conf&lt;/code&gt; ，并存储在集群的数据目录中。（但是，可以将映射文件放置在其他位置；请参见&lt;a href=&quot;runtime-config-file-locations#GUC-IDENT-FILE&quot;&gt;ident_file&lt;/a&gt;配置参数。）ident映射文件包含以下常规形式的行：</target>
        </trans-unit>
        <trans-unit id="26c83bd5ba1faee58ca4dfcad77ca8603bcdb897" translate="yes" xml:space="preserve">
          <source>User name of the mapping. &lt;code&gt;CURRENT_USER&lt;/code&gt; and &lt;code&gt;USER&lt;/code&gt; match the name of the current user. &lt;code&gt;PUBLIC&lt;/code&gt; is used to match all present and future user names in the system.</source>
          <target state="translated">映射的用户名。 &lt;code&gt;CURRENT_USER&lt;/code&gt; 和 &lt;code&gt;USER&lt;/code&gt; 与当前用户的名称匹配。 &lt;code&gt;PUBLIC&lt;/code&gt; 用于匹配系统中所有当前和将来的用户名。</target>
        </trans-unit>
        <trans-unit id="5f782be03fcdc443b383e428fe084103c7519032" translate="yes" xml:space="preserve">
          <source>User name to connect as (not the user name to create).</source>
          <target state="translated">连接的用户名(不是创建的用户名)。</target>
        </trans-unit>
        <trans-unit id="58a48e5ec3f1ddd8734180ce7a8bcf7ce3e61813" translate="yes" xml:space="preserve">
          <source>User name to connect as (not the user name to drop).</source>
          <target state="translated">连接的用户名(不是要删除的用户名)。</target>
        </trans-unit>
        <trans-unit id="6c7c5d855fc83ff64eb10669f8523b7d11212f01" translate="yes" xml:space="preserve">
          <source>User name to connect as.</source>
          <target state="translated">连接的用户名。</target>
        </trans-unit>
        <trans-unit id="104f2eb40da0056ec5533c282848e3fce154c0c2" translate="yes" xml:space="preserve">
          <source>User name to connect as. Defaults to current operating system user name.</source>
          <target state="translated">连接的用户名。默认为当前操作系统的用户名。</target>
        </trans-unit>
        <trans-unit id="d47cce93b040f97f45693a064d2ec0fe0d47cbfa" translate="yes" xml:space="preserve">
          <source>User-defined constraint triggers (created with &lt;code&gt;CREATE CONSTRAINT TRIGGER&lt;/code&gt;) also give rise to an entry in this table.</source>
          <target state="translated">用户定义的约束触发器（使用 &lt;code&gt;CREATE CONSTRAINT TRIGGER&lt;/code&gt; 创建）也会在该表中产生一个条目。</target>
        </trans-unit>
        <trans-unit id="c0ef205df825ba4213dcb43cc225636454550c49" translate="yes" xml:space="preserve">
          <source>User-defined types</source>
          <target state="translated">用户定义类型</target>
        </trans-unit>
        <trans-unit id="08a19bf7678e0c925ef7e00adabbc0a5965212bf" translate="yes" xml:space="preserve">
          <source>Users (roles) that are to be added to or removed from the group. The users must already exist; &lt;code&gt;ALTER GROUP&lt;/code&gt; does not create or drop users.</source>
          <target state="translated">要添加到组或从组中删除的用户（角色）。用户必须已经存在； &lt;code&gt;ALTER GROUP&lt;/code&gt; 不会创建或删除用户。</target>
        </trans-unit>
        <trans-unit id="c368e154de403e348ebf85b5c480f63c95e940b6" translate="yes" xml:space="preserve">
          <source>Users accustomed to working with other SQL database management systems might be disappointed by the performance of the &lt;code&gt;count&lt;/code&gt; aggregate when it is applied to the entire table. A query like:</source>
          <target state="translated">将 &lt;code&gt;count&lt;/code&gt; 聚合应用于整个表时，习惯于使用其他SQL数据库管理系统的用户可能会感到失望。查询如下：</target>
        </trans-unit>
        <trans-unit id="ec14cfda8b568c538e7a2b35ec4764216fe766a6" translate="yes" xml:space="preserve">
          <source>Users can define their own range types. The most common reason to do this is to use ranges over subtypes not provided among the built-in range types. For example, to define a new range type of subtype &lt;code&gt;float8&lt;/code&gt;:</source>
          <target state="translated">用户可以定义自己的范围类型。这样做的最常见原因是对内置范围类型中未提供的子类型使用范围。例如，要定义子类型 &lt;code&gt;float8&lt;/code&gt; 的新范围类型：</target>
        </trans-unit>
        <trans-unit id="9a9efc48c7a0e88a7803961454d90d55b5ba0528" translate="yes" xml:space="preserve">
          <source>Users of a cluster do not necessarily have the privilege to access every database in the cluster. Sharing of role names means that there cannot be different roles named, say, &lt;code&gt;joe&lt;/code&gt; in two databases in the same cluster; but the system can be configured to allow &lt;code&gt;joe&lt;/code&gt; access to only some of the databases.</source>
          <target state="translated">集群的用户不一定具有访问集群中每个数据库的特权。角色名称的共享意味着在同一集群中的两个数据库中不能有不同的角色，例如 &lt;code&gt;joe&lt;/code&gt; 。但是系统可以配置为仅允许 &lt;code&gt;joe&lt;/code&gt; 访问某些数据库。</target>
        </trans-unit>
        <trans-unit id="4944fa9df06f02dea3273ddeb97bb2eab5830741" translate="yes" xml:space="preserve">
          <source>Users of a cluster do not necessarily have the privilege to access every database in the cluster. Sharing of user names means that there cannot be different users named, say, &lt;code&gt;joe&lt;/code&gt; in two databases in the same cluster; but the system can be configured to allow &lt;code&gt;joe&lt;/code&gt; access to only some of the databases.</source>
          <target state="translated">集群的用户不一定具有访问集群中每个数据库的特权。共享用户名意味着在同一群集中的两个数据库中不能有不同的用户，例如 &lt;code&gt;joe&lt;/code&gt; 。但是系统可以配置为仅允许 &lt;code&gt;joe&lt;/code&gt; 访问某些数据库。</target>
        </trans-unit>
        <trans-unit id="655defefcbd5cf77a94fb403c6b891d5f809540a" translate="yes" xml:space="preserve">
          <source>Users should be clear that tables that are regularly and heavily updated on the primary server will quickly cause cancellation of longer running queries on the standby. In such cases the setting of a finite value for &lt;code&gt;max_standby_archive_delay&lt;/code&gt; or &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; can be considered similar to setting &lt;code&gt;statement_timeout&lt;/code&gt;.</source>
          <target state="translated">用户应清楚了解，在主服务器上定期且大量更新的表将迅速导致取消备用数据库上运行时间较长的查询。在这种情况下，可以将 &lt;code&gt;max_standby_archive_delay&lt;/code&gt; 或 &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; 的有限值设置与设置 &lt;code&gt;statement_timeout&lt;/code&gt; 相似。</target>
        </trans-unit>
        <trans-unit id="dc34515c6a1d7984b3e11718da650ce1ef5ed348" translate="yes" xml:space="preserve">
          <source>Users sometimes try to declare operators applying just to a domain type. This is possible but is not nearly as useful as it might seem, because the operator resolution rules are designed to select operators applying to the domain's base type. As an example consider</source>
          <target state="translated">用户有时会尝试声明只适用于域类型的操作符。这是有可能的,但并不像看起来那么有用,因为运算符解析规则被设计为选择适用于域的基本类型的运算符。作为一个例子,请考虑</target>
        </trans-unit>
        <trans-unit id="1772f82727e2e70cce145a14908f76eba9dee789" translate="yes" xml:space="preserve">
          <source>Users sometimes wonder why host names are handled in this seemingly complicated way, with two name resolutions including a reverse lookup of the client's IP address. This complicates use of the feature in case the client's reverse DNS entry is not set up or yields some undesirable host name. It is done primarily for efficiency: this way, a connection attempt requires at most two resolver lookups, one reverse and one forward. If there is a resolver problem with some address, it becomes only that client's problem. A hypothetical alternative implementation that only did forward lookups would have to resolve every host name mentioned in &lt;code&gt;pg_hba.conf&lt;/code&gt; during every connection attempt. That could be quite slow if many names are listed. And if there is a resolver problem with one of the host names, it becomes everyone's problem.</source>
          <target state="translated">用户有时会想知道为什么用这种看似复杂的方式来处理主机名，并具有两个名称解析，其中包括对客户端IP地址的反向查找。如果未设置客户端的反向DNS条目或产生某些不良的主机名，则会使该功能的使用复杂化。这样做主要是为了提高效率：通过这种方式，连接尝试最多需要两次解析器查找，一次反向查找和一次正向查找。如果某个地址存在解析器问题，则仅成为该客户的问题。假设只做正向查找的替代实现，必须解析 &lt;code&gt;pg_hba.conf&lt;/code&gt; 中提到的每个主机名。在每次连接尝试期间。如果列出了许多名称，那可能会很慢。而且，如果其中一个主机名存在解析器问题，那么它将成为每个人的问题。</target>
        </trans-unit>
        <trans-unit id="4adcca052990f33f0c6c8200c5c596110e4cd88f" translate="yes" xml:space="preserve">
          <source>Users will be able to tell whether their session is read-only by issuing &lt;code&gt;SHOW transaction_read_only&lt;/code&gt;. In addition, a set of functions (&lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;Table 9.85&lt;/a&gt;) allow users to access information about the standby server. These allow you to write programs that are aware of the current state of the database. These can be used to monitor the progress of recovery, or to allow you to write complex programs that restore the database to particular states.</source>
          <target state="translated">用户可以通过发出 &lt;code&gt;SHOW transaction_read_only&lt;/code&gt; 来判断其会话是否为只读。另外，一组功能（&lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;表9.85&lt;/a&gt;）允许用户访问有关备用服务器的信息。这些使您可以编写了解数据库当前状态的程序。这些可用于监视恢复进度，或允许您编写将数据库恢复到特定状态的复杂程序。</target>
        </trans-unit>
        <trans-unit id="83c06bb19535af77b0a89cf5ee576459c7758e4d" translate="yes" xml:space="preserve">
          <source>Users will be able to tell whether their session is read-only by issuing &lt;code&gt;SHOW transaction_read_only&lt;/code&gt;. In addition, a set of functions (&lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;Table 9.86&lt;/a&gt;) allow users to access information about the standby server. These allow you to write programs that are aware of the current state of the database. These can be used to monitor the progress of recovery, or to allow you to write complex programs that restore the database to particular states.</source>
          <target state="translated">用户将可以通过发出 &lt;code&gt;SHOW transaction_read_only&lt;/code&gt; 来判断其会话是否为只读。另外，一组功能（&lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;表9.86&lt;/a&gt;）允许用户访问有关备用服务器的信息。这些使您可以编写了解数据库当前状态的程序。这些可用于监视恢复进度，或允许您编写将数据库恢复到特定状态的复杂程序。</target>
        </trans-unit>
        <trans-unit id="28e2bf0df748000aab563d6b102d035c272f7dd2" translate="yes" xml:space="preserve">
          <source>Users will stop waiting if a fast shutdown is requested. However, as when using asynchronous replication, the server will not fully shutdown until all outstanding WAL records are transferred to the currently connected standby servers.</source>
          <target state="translated">如果要求快速关机,用户将停止等待。但是,与使用异步复制时一样,服务器不会完全关闭,直到所有未完成的WAL记录被转移到当前连接的备用服务器上。</target>
        </trans-unit>
        <trans-unit id="00379b69f39e7e2d3d7c05f05b12ede542302d0d" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;sql-security-label&quot;&gt;SECURITY LABEL&lt;/a&gt; on an object additionally requires &lt;code&gt;relabelfrom&lt;/code&gt; permission for the object in conjunction with its old security label and &lt;code&gt;relabelto&lt;/code&gt; permission for the object in conjunction with its new security label. (In cases where multiple label providers are installed and the user tries to set a security label, but it is not managed by SELinux, only &lt;code&gt;setattr&lt;/code&gt; should be checked here. This is currently not done due to implementation restrictions.)</source>
          <target state="translated">使用&lt;a href=&quot;sql-security-label&quot;&gt;防伪标签&lt;/a&gt;的物体上还需要 &lt;code&gt;relabelfrom&lt;/code&gt; 在其旧的安全标签，并结合对象权限 &lt;code&gt;relabelto&lt;/code&gt; 在其新的防伪标签一起的对象权限。（如果安装了多个标签提供程序，并且用户尝试设置安全标签，但该标签不是由SELinux管理的，则此处仅应检查 &lt;code&gt;setattr&lt;/code&gt; 。由于实施限制，当前不执行此操作。）</target>
        </trans-unit>
        <trans-unit id="7ba7d6f6db215ecebd0a0dd010a3ef4d72762c57" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt; on this view, specifically updating the &lt;code&gt;setting&lt;/code&gt; column, is the equivalent of issuing &lt;code&gt;SET&lt;/code&gt; commands. For example, the equivalent of</source>
          <target state="translated">在此视图上使用&lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt;（特别是更新 &lt;code&gt;setting&lt;/code&gt; 列）等效于发出 &lt;code&gt;SET&lt;/code&gt; 命令。例如，相当于</target>
        </trans-unit>
        <trans-unit id="9f4a279994eeee7b66ef6f4b6c4072e3efe337a2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ALL&lt;/code&gt; for a policy means that it will apply to all commands, regardless of the type of command. If an &lt;code&gt;ALL&lt;/code&gt; policy exists and more specific policies exist, then both the &lt;code&gt;ALL&lt;/code&gt; policy and the more specific policy (or policies) will be applied. Additionally, &lt;code&gt;ALL&lt;/code&gt; policies will be applied to both the selection side of a query and the modification side, using the &lt;code&gt;USING&lt;/code&gt; expression for both cases if only a &lt;code&gt;USING&lt;/code&gt; expression has been defined.</source>
          <target state="translated">对策略使用 &lt;code&gt;ALL&lt;/code&gt; 意味着它将适用于所有命令，而不管命令的类型如何。如果存在 &lt;code&gt;ALL&lt;/code&gt; 策略且存在更具体的策略，则将同时应用 &lt;code&gt;ALL&lt;/code&gt; 策略和更具体的一个或多个策略。此外，如果仅定义了 &lt;code&gt;USING&lt;/code&gt; 表达式，则在两种情况下都 &lt;code&gt;USING&lt;/code&gt; 表达式，将 &lt;code&gt;ALL&lt;/code&gt; 策略都应用于查询的选择端和修改端。</target>
        </trans-unit>
        <trans-unit id="b1caa6904d1b2e3c70cf23410fccedf2e858e4cc" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;DELETE&lt;/code&gt; for a policy means that it will apply to &lt;code&gt;DELETE&lt;/code&gt; commands. Only rows that pass this policy will be seen by a &lt;code&gt;DELETE&lt;/code&gt; command. There can be rows that are visible through a &lt;code&gt;SELECT&lt;/code&gt; that are not available for deletion, if they do not pass the &lt;code&gt;USING&lt;/code&gt; expression for the &lt;code&gt;DELETE&lt;/code&gt; policy.</source>
          <target state="translated">对策略使用 &lt;code&gt;DELETE&lt;/code&gt; 意味着它将应用于 &lt;code&gt;DELETE&lt;/code&gt; 命令。 &lt;code&gt;DELETE&lt;/code&gt; 命令将仅显示通过此策略的行。如果没有通过 &lt;code&gt;DELETE&lt;/code&gt; 策略的 &lt;code&gt;USING&lt;/code&gt; 表达式，则可能存在通过 &lt;code&gt;SELECT&lt;/code&gt; 可见的行，这些行不可删除。</target>
        </trans-unit>
        <trans-unit id="8ba736c87dfcbb2c8e16a4a5fbcf41dc4d34ae6e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;INSERT&lt;/code&gt; for a policy means that it will apply to &lt;code&gt;INSERT&lt;/code&gt; commands. Rows being inserted that do not pass this policy will result in a policy violation error, and the entire &lt;code&gt;INSERT&lt;/code&gt; command will be aborted. An &lt;code&gt;INSERT&lt;/code&gt; policy cannot have a &lt;code&gt;USING&lt;/code&gt; expression, as it only applies in cases where records are being added to the relation.</source>
          <target state="translated">对策略使用 &lt;code&gt;INSERT&lt;/code&gt; 意味着它将应用于 &lt;code&gt;INSERT&lt;/code&gt; 命令。插入的未通过此策略的行将导致违反策略错误，并且整个 &lt;code&gt;INSERT&lt;/code&gt; 命令将被中止。一个 &lt;code&gt;INSERT&lt;/code&gt; 政策不能有 &lt;code&gt;USING&lt;/code&gt; 表达式，因为它仅适用于在记录被添加到该关系的情况。</target>
        </trans-unit>
        <trans-unit id="4584b8b01123eb82dc7847c4d9677c40b0e5bba4" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ONLY&lt;/code&gt; to add or drop a constraint on only the partitioned table is supported as long as there are no partitions. Once partitions exist, using &lt;code&gt;ONLY&lt;/code&gt; will result in an error as adding or dropping constraints on only the partitioned table, when partitions exist, is not supported. Instead, constraints on the partitions themselves can be added and (if they are not present in the parent table) dropped.</source>
          <target state="translated">使用 &lt;code&gt;ONLY&lt;/code&gt; 添加或删除仅在分区表的约束，因为没有分区，支持长。一旦分区存在，则使用 &lt;code&gt;ONLY&lt;/code&gt; 将导致一个错误，添加或仅在分区表中，当分区存在取消约束，不被支持。相反，可以添加对分区本身的约束，并且可以删除（如果它们不在父表中）。</target>
        </trans-unit>
        <trans-unit id="9191967f0b2195c21483c93a60dfe19fe3e18ef8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;PGCLIENTENCODING&lt;/code&gt;. If the environment variable &lt;code&gt;PGCLIENTENCODING&lt;/code&gt; is defined in the client's environment, that client encoding is automatically selected when a connection to the server is made. (This can subsequently be overridden using any of the other methods mentioned above.)</source>
          <target state="translated">使用 &lt;code&gt;PGCLIENTENCODING&lt;/code&gt; 。如果在客户端环境中定义了环境变量 &lt;code&gt;PGCLIENTENCODING&lt;/code&gt; ,则在与服务器建立连接时会自动选择该客户端编码。（随后可以使用上述任何其他方法覆盖此方法。）</target>
        </trans-unit>
        <trans-unit id="de75f251dab5b0ad3801e8b63609c603b9f339f8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;SELECT&lt;/code&gt; for a policy means that it will apply to &lt;code&gt;SELECT&lt;/code&gt; queries and whenever &lt;code&gt;SELECT&lt;/code&gt; permissions are required on the relation the policy is defined for. The result is that only those records from the relation that pass the &lt;code&gt;SELECT&lt;/code&gt; policy will be returned during a &lt;code&gt;SELECT&lt;/code&gt; query, and that queries that require &lt;code&gt;SELECT&lt;/code&gt; permissions, such as &lt;code&gt;UPDATE&lt;/code&gt;, will also only see those records that are allowed by the &lt;code&gt;SELECT&lt;/code&gt; policy. A &lt;code&gt;SELECT&lt;/code&gt; policy cannot have a &lt;code&gt;WITH CHECK&lt;/code&gt; expression, as it only applies in cases where records are being retrieved from the relation.</source>
          <target state="translated">对策略使用 &lt;code&gt;SELECT&lt;/code&gt; 意味着它将应用于 &lt;code&gt;SELECT&lt;/code&gt; 查询，并且在为该策略定义的关系上需要 &lt;code&gt;SELECT&lt;/code&gt; 权限时。结果是，在 &lt;code&gt;SELECT&lt;/code&gt; 查询期间，只会返回通过 &lt;code&gt;SELECT&lt;/code&gt; 策略的关系中的那些记录，而需要 &lt;code&gt;SELECT&lt;/code&gt; 权限的查询（例如 &lt;code&gt;UPDATE&lt;/code&gt; ）也将仅看到 &lt;code&gt;SELECT&lt;/code&gt; 策略所允许的那些记录。一个 &lt;code&gt;SELECT&lt;/code&gt; 政策不能有 &lt;code&gt;WITH CHECK&lt;/code&gt; 表达，因为它仅适用于在正在从关系检索到的记录情况。</target>
        </trans-unit>
        <trans-unit id="8ea11f118aea185625aef767542a580e19f76285" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;SET client_encoding TO&lt;/code&gt;. Setting the client encoding can be done with this SQL command:</source>
          <target state="translated">使用 &lt;code&gt;SET client_encoding TO&lt;/code&gt; 。可以使用以下SQL命令来设置客户端编码：</target>
        </trans-unit>
        <trans-unit id="c3e9a2e659e09abe2efa2c5be22d40b62c3aee16" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;Type=notify&lt;/code&gt; requires that the server binary was built with &lt;code&gt;configure --with-systemd&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;Type=notify&lt;/code&gt; 要求服务器二进制文件是使用 &lt;code&gt;configure --with-systemd&lt;/code&gt; 构建的。</target>
        </trans-unit>
        <trans-unit id="5f17447546dfac5a3cba43658b86d3ae11e9f49a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;UPDATE&lt;/code&gt; for a policy means that it will apply to &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; and &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; commands, as well as auxiliary &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clauses of &lt;code&gt;INSERT&lt;/code&gt; commands. Since &lt;code&gt;UPDATE&lt;/code&gt; involves pulling an existing record and replacing it with a new modified record, &lt;code&gt;UPDATE&lt;/code&gt; policies accept both a &lt;code&gt;USING&lt;/code&gt; expression and a &lt;code&gt;WITH CHECK&lt;/code&gt; expression. The &lt;code&gt;USING&lt;/code&gt; expression determines which records the &lt;code&gt;UPDATE&lt;/code&gt; command will see to operate against, while the &lt;code&gt;WITH CHECK&lt;/code&gt; expression defines which modified rows are allowed to be stored back into the relation.</source>
          <target state="translated">对策略使用 &lt;code&gt;UPDATE&lt;/code&gt; 意味着它将应用于 &lt;code&gt;UPDATE&lt;/code&gt; ， &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 和 &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; 命令以及 &lt;code&gt;INSERT&lt;/code&gt; 命令的辅助 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 子句。由于 &lt;code&gt;UPDATE&lt;/code&gt; 涉及提取现有记录并将其替换为新的修改后的记录，因此 &lt;code&gt;UPDATE&lt;/code&gt; 策略同时接受 &lt;code&gt;USING&lt;/code&gt; 表达式和 &lt;code&gt;WITH CHECK&lt;/code&gt; 表达式。在 &lt;code&gt;USING&lt;/code&gt; 表达式确定其中记录了 &lt;code&gt;UPDATE&lt;/code&gt; 命令将看到打击操作，而 &lt;code&gt;WITH CHECK&lt;/code&gt; 表达式定义允许哪些修改的行存储回关系中。</target>
        </trans-unit>
        <trans-unit id="4872b905960b3b0bb609a1d1f16d8a8085172d7f" translate="yes" xml:space="preserve">
          <source>Using WAL results in a significantly reduced number of disk writes, because only the log file needs to be flushed to disk to guarantee that a transaction is committed, rather than every data file changed by the transaction. The log file is written sequentially, and so the cost of syncing the log is much less than the cost of flushing the data pages. This is especially true for servers handling many small transactions touching different parts of the data store. Furthermore, when the server is processing many small concurrent transactions, one &lt;code&gt;fsync&lt;/code&gt; of the log file may suffice to commit many transactions.</source>
          <target state="translated">使用WAL会大大减少磁盘写入次数，因为仅需要将日志文件刷新到磁盘以保证事务已提交，而不是每个数据文件都会被事务更改。日志文件是按顺序写入的，因此同步日志的成本比刷新数据页的成本低得多。对于处理许多涉及数据存储不同部分的小事务的服务器而言，尤其如此。此外，当服务器正在处理许多小的并发事务时，日志文件的一个 &lt;code&gt;fsync&lt;/code&gt; 可能足以提交许多事务。</target>
        </trans-unit>
        <trans-unit id="c4792021563cf0153c3bbaaa6301ad807dbacef8" translate="yes" xml:space="preserve">
          <source>Using a SHA hash function provides a cryptographically secure digest of each file for users who wish to verify that the backup has not been tampered with, while the CRC32C algorithm provides a checksum that is much faster to calculate; it is good at catching errors due to accidental changes but is not resistant to malicious modifications. Note that, to be useful against an adversary who has access to the backup, the backup manifest would need to be stored securely elsewhere or otherwise verified not to have been modified since the backup was taken.</source>
          <target state="translated">使用SHA散列函数为希望验证备份未被篡改的用户提供了每个文件的加密安全摘要,而CRC32C算法则提供了一个计算速度更快的校验和;它善于捕捉因意外更改而产生的错误,但无法抵御恶意修改。需要注意的是,要想对有访问权的对手有用,备份清单需要安全地存储在其他地方,或者以其他方式验证自备份以来没有被修改过。</target>
        </trans-unit>
        <trans-unit id="2e62e4e51350449dc0eec4f1e12ec4aa76a1f3f9" translate="yes" xml:space="preserve">
          <source>Using a separate script file is advisable any time you want to use more than a single command in the archiving process. This allows all complexity to be managed within the script, which can be written in a popular scripting language such as bash or perl.</source>
          <target state="translated">当你想在归档过程中使用一个以上的命令时,建议使用一个单独的脚本文件。这样可以在脚本中管理所有的复杂性,脚本可以用流行的脚本语言(如bash或perl)编写。</target>
        </trans-unit>
        <trans-unit id="b28cc95da9f9c8ec1f9441e5caff1c654ea239b4" translate="yes" xml:space="preserve">
          <source>Using a simple integer &lt;code&gt;offset&lt;/code&gt; is preferred when defining an abbreviation whose offset from UTC has never changed, as such abbreviations are much cheaper to process than those that require consulting a time zone definition.</source>
          <target state="translated">在定义一个与UTC的偏移量从未更改过的缩写时，首选使用简单的整数 &lt;code&gt;offset&lt;/code&gt; ，因为与需要咨询时区定义的缩写相比，这种缩写的处理成本要低得多。</target>
        </trans-unit>
        <trans-unit id="d159535298801ecd67e86d11daf24d3f29bae4e5" translate="yes" xml:space="preserve">
          <source>Using a table:</source>
          <target state="translated">使用表格。</target>
        </trans-unit>
        <trans-unit id="97a7d609ae1fc837ff854c4a8fe8b3cbd1349e8b" translate="yes" xml:space="preserve">
          <source>Using an existing graphical frontend tool like pgAdmin or an office suite with ODBC or JDBC support to create and manipulate a database. These possibilities are not covered in this tutorial.</source>
          <target state="translated">使用现有的图形化前端工具(如pgAdmin)或支持ODBC或JDBC的办公套件来创建和操作数据库。这些可能性在本教程中没有涉及。</target>
        </trans-unit>
        <trans-unit id="9b0ce3043e87fd971bf85082c10b3ea412051c05" translate="yes" xml:space="preserve">
          <source>Using filter expressions at different nesting levels is also allowed. The following example first filters all segments by location, and then returns high heart rate values for these segments, if available:</source>
          <target state="translated">也允许使用不同嵌套级别的过滤表达式。下面的例子首先按位置过滤所有段,然后返回这些段的高心率值(如果可用)。</target>
        </trans-unit>
        <trans-unit id="3f87542d489a5d09a003c3d32c1fdd090240fb1a" translate="yes" xml:space="preserve">
          <source>Using huge pages reduces overhead when using large contiguous chunks of memory, as PostgreSQL does, particularly when using large values of &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;. To use this feature in PostgreSQL you need a kernel with &lt;code&gt;CONFIG_HUGETLBFS=y&lt;/code&gt; and &lt;code&gt;CONFIG_HUGETLB_PAGE=y&lt;/code&gt;. You will also have to adjust the kernel setting &lt;code&gt;vm.nr_hugepages&lt;/code&gt;. To estimate the number of huge pages needed, start PostgreSQL without huge pages enabled and check the postmaster's anonymous shared memory segment size, as well as the system's huge page size, using the &lt;code&gt;/proc&lt;/code&gt; file system. This might look like:</source>
          <target state="translated">与PostgreSQL一样，使用大的页面可以减少使用大块连续的内存时的开销，尤其是当使用大的&lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;值时。要在PostgreSQL中使用此功能，您需要具有 &lt;code&gt;CONFIG_HUGETLBFS=y&lt;/code&gt; 和 &lt;code&gt;CONFIG_HUGETLB_PAGE=y&lt;/code&gt; 的内核。您还必须调整内核设置 &lt;code&gt;vm.nr_hugepages&lt;/code&gt; 。要估计所需的大页面数，请在未启用大页面的情况下启动PostgreSQL，并使用 &lt;code&gt;/proc&lt;/code&gt; 文件系统检查邮局局长的匿名共享内存段大小以及系统的大页面大小。可能看起来像：</target>
        </trans-unit>
        <trans-unit id="c0f4579fb33ddb8969cb60774c58272e5c781549" translate="yes" xml:space="preserve">
          <source>Using just common sense, it appears more convenient to store such data as intervals, rather than pairs of numbers. In practice, it even turns out more efficient in most applications.</source>
          <target state="translated">仅凭常识,将此类数据存储为区间而非数字对似乎更方便。实际上,在大多数应用中,它甚至被证明更有效率。</target>
        </trans-unit>
        <trans-unit id="a8fc95773ce3956bab8c2e8bf2027d9e849d1b1f" translate="yes" xml:space="preserve">
          <source>Using psql on a recently vacuumed or analyzed database, you can issue queries to see the disk usage of any table:</source>
          <target state="translated">在最近吸尘或分析过的数据库上使用psql,可以发出查询,查看任何表的磁盘使用情况。</target>
        </trans-unit>
        <trans-unit id="65181e02239e5820a5b7c0dec699536af98e9eef" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;CASCADE&lt;/code&gt; option might make the command recurse to objects owned by other users.</source>
          <target state="translated">使用 &lt;code&gt;CASCADE&lt;/code&gt; 选项可能会使命令递归到其他用户拥有的对象。</target>
        </trans-unit>
        <trans-unit id="a3919689ac7e30c1a7b51bdbeb0b298903ed7b06" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;CASCADE&lt;/code&gt; option might make the command remove objects in other schemas besides the one(s) named.</source>
          <target state="translated">使用 &lt;code&gt;CASCADE&lt;/code&gt; 选项可能会使命令除去命名模式以外的其他模式中的对象。</target>
        </trans-unit>
        <trans-unit id="9d956f8965b7e70f75d823768214bbad6a425210" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;\encoding&lt;/code&gt; command in psql. &lt;code&gt;\encoding&lt;/code&gt; allows you to change client encoding on the fly. For example, to change the encoding to &lt;code&gt;SJIS&lt;/code&gt;, type:</source>
          <target state="translated">在psql中使用 &lt;code&gt;\encoding&lt;/code&gt; 命令。 &lt;code&gt;\encoding&lt;/code&gt; 允许您即时更改客户端编码。例如，要将编码更改为 &lt;code&gt;SJIS&lt;/code&gt; ，请输入：</target>
        </trans-unit>
        <trans-unit id="ce95ab1950e8fbb1a63e8b189b58b6a856d611e2" translate="yes" xml:space="preserve">
          <source>Using the configuration variable &lt;a href=&quot;runtime-config-client#GUC-CLIENT-ENCODING&quot;&gt;client_encoding&lt;/a&gt;. If the &lt;code&gt;client_encoding&lt;/code&gt; variable is set, that client encoding is automatically selected when a connection to the server is made. (This can subsequently be overridden using any of the other methods mentioned above.)</source>
          <target state="translated">使用配置变量&lt;a href=&quot;runtime-config-client#GUC-CLIENT-ENCODING&quot;&gt;client_encoding&lt;/a&gt;。如果设置了 &lt;code&gt;client_encoding&lt;/code&gt; 变量，则在与服务器建立连接时会自动选择该客户端编码。（随后可以使用上述任何其他方法覆盖此方法。）</target>
        </trans-unit>
        <trans-unit id="7b44d852d97da519564a9d99f8e49c858203cdb6" translate="yes" xml:space="preserve">
          <source>Using the operators &lt;code&gt;UNION&lt;/code&gt;, &lt;code&gt;INTERSECT&lt;/code&gt;, and &lt;code&gt;EXCEPT&lt;/code&gt;, the output of more than one &lt;code&gt;SELECT&lt;/code&gt; statement can be combined to form a single result set. The &lt;code&gt;UNION&lt;/code&gt; operator returns all rows that are in one or both of the result sets. The &lt;code&gt;INTERSECT&lt;/code&gt; operator returns all rows that are strictly in both result sets. The &lt;code&gt;EXCEPT&lt;/code&gt; operator returns the rows that are in the first result set but not in the second. In all three cases, duplicate rows are eliminated unless &lt;code&gt;ALL&lt;/code&gt; is specified. The noise word &lt;code&gt;DISTINCT&lt;/code&gt; can be added to explicitly specify eliminating duplicate rows. Notice that &lt;code&gt;DISTINCT&lt;/code&gt; is the default behavior here, even though &lt;code&gt;ALL&lt;/code&gt; is the default for &lt;code&gt;SELECT&lt;/code&gt; itself. (See &lt;a href=&quot;sql-select#SQL-UNION&quot;&gt;&lt;code&gt;UNION&lt;/code&gt; Clause&lt;/a&gt;, &lt;a href=&quot;sql-select#SQL-INTERSECT&quot;&gt;&lt;code&gt;INTERSECT&lt;/code&gt; Clause&lt;/a&gt;, and &lt;a href=&quot;sql-select#SQL-EXCEPT&quot;&gt;&lt;code&gt;EXCEPT&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">使用运算符 &lt;code&gt;UNION&lt;/code&gt; ， &lt;code&gt;INTERSECT&lt;/code&gt; 和 &lt;code&gt;EXCEPT&lt;/code&gt; ，可以组合多个 &lt;code&gt;SELECT&lt;/code&gt; 语句的输出以形成单个结果集。该 &lt;code&gt;UNION&lt;/code&gt; 操作符返回在一个或两个结果集的所有行。该 &lt;code&gt;INTERSECT&lt;/code&gt; 操作符返回严格在这两个结果集的所有行。该 &lt;code&gt;EXCEPT&lt;/code&gt; 操作符返回在第一个结果集，但不是在第二行。在所有三种情况下，除非指定了 &lt;code&gt;ALL&lt;/code&gt; ，否则将消除重复的行。可以添加干扰词 &lt;code&gt;DISTINCT&lt;/code&gt; 来明确指定消除重复行。注意 &lt;code&gt;DISTINCT&lt;/code&gt; 即使 &lt;code&gt;ALL&lt;/code&gt; 是 &lt;code&gt;SELECT&lt;/code&gt; 本身的默认值，也是默认行为。 （请参阅下面的&lt;a href=&quot;sql-select#SQL-UNION&quot;&gt; &lt;code&gt;UNION&lt;/code&gt; 子句&lt;/a&gt;，&lt;a href=&quot;sql-select#SQL-INTERSECT&quot;&gt; &lt;code&gt;INTERSECT&lt;/code&gt; 子句&lt;/a&gt;和&lt;a href=&quot;sql-select#SQL-EXCEPT&quot;&gt; &lt;code&gt;EXCEPT&lt;/code&gt; 子句&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="60ff87ccea487ea3e7de59df62d12a0091443a0c" translate="yes" xml:space="preserve">
          <source>Using the operators &lt;code&gt;UNION&lt;/code&gt;, &lt;code&gt;INTERSECT&lt;/code&gt;, and &lt;code&gt;EXCEPT&lt;/code&gt;, the output of more than one &lt;code&gt;SELECT&lt;/code&gt; statement can be combined to form a single result set. The &lt;code&gt;UNION&lt;/code&gt; operator returns all rows that are in one or both of the result sets. The &lt;code&gt;INTERSECT&lt;/code&gt; operator returns all rows that are strictly in both result sets. The &lt;code&gt;EXCEPT&lt;/code&gt; operator returns the rows that are in the first result set but not in the second. In all three cases, duplicate rows are eliminated unless &lt;code&gt;ALL&lt;/code&gt; is specified. The noise word &lt;code&gt;DISTINCT&lt;/code&gt; can be added to explicitly specify eliminating duplicate rows. Notice that &lt;code&gt;DISTINCT&lt;/code&gt; is the default behavior here, even though &lt;code&gt;ALL&lt;/code&gt; is the default for &lt;code&gt;SELECT&lt;/code&gt; itself. (See &lt;a href=&quot;sql-select#SQL-UNION&quot;&gt;UNION Clause&lt;/a&gt;, &lt;a href=&quot;sql-select#SQL-INTERSECT&quot;&gt;INTERSECT Clause&lt;/a&gt;, and &lt;a href=&quot;sql-select#SQL-EXCEPT&quot;&gt;EXCEPT Clause&lt;/a&gt; below.)</source>
          <target state="translated">使用运算符 &lt;code&gt;UNION&lt;/code&gt; ， &lt;code&gt;INTERSECT&lt;/code&gt; 和 &lt;code&gt;EXCEPT&lt;/code&gt; ，可以组合多个 &lt;code&gt;SELECT&lt;/code&gt; 语句的输出以形成单个结果集。该 &lt;code&gt;UNION&lt;/code&gt; 操作符返回在一个或两个结果集的所有行。该 &lt;code&gt;INTERSECT&lt;/code&gt; 操作符返回严格在这两个结果集的所有行。该 &lt;code&gt;EXCEPT&lt;/code&gt; 操作符返回在第一个结果集，但不是在第二行。在所有三种情况下，除非指定了 &lt;code&gt;ALL&lt;/code&gt; ，否则将消除重复的行。可以添加干扰词 &lt;code&gt;DISTINCT&lt;/code&gt; 来明确指定消除重复行。请注意， &lt;code&gt;DISTINCT&lt;/code&gt; 即使 &lt;code&gt;ALL&lt;/code&gt; 是 &lt;code&gt;SELECT&lt;/code&gt; 本身的默认值，也是默认行为。（请参阅下面的&lt;a href=&quot;sql-select#SQL-UNION&quot;&gt;UNION子句&lt;/a&gt;，&lt;a href=&quot;sql-select#SQL-INTERSECT&quot;&gt;INTERSECT子句&lt;/a&gt;和&lt;a href=&quot;sql-select#SQL-EXCEPT&quot;&gt;EXCEPT子句&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="345d4ccffce95dcf05491c18eea8197735fd71fd" translate="yes" xml:space="preserve">
          <source>Using this command, it is possible to either add privileges or restrict one's privileges. If the session user role has the &lt;code&gt;INHERIT&lt;/code&gt; attribute, then it automatically has all the privileges of every role that it could &lt;code&gt;SET ROLE&lt;/code&gt; to; in this case &lt;code&gt;SET ROLE&lt;/code&gt; effectively drops all the privileges assigned directly to the session user and to the other roles it is a member of, leaving only the privileges available to the named role. On the other hand, if the session user role has the &lt;code&gt;NOINHERIT&lt;/code&gt; attribute, &lt;code&gt;SET ROLE&lt;/code&gt; drops the privileges assigned directly to the session user and instead acquires the privileges available to the named role.</source>
          <target state="translated">使用此命令，可以添加特权或限制一个人的特权。如果会话用户角色具有 &lt;code&gt;INHERIT&lt;/code&gt; 属性，则它将自动拥有可以 &lt;code&gt;SET ROLE&lt;/code&gt; 角色的每个角色的所有特权。在这种情况下， &lt;code&gt;SET ROLE&lt;/code&gt; 有效地放弃直接分配给会话用户及其成员的其他角色的所有特权，仅保留命名角色可用的特权。另一方面，如果会话用户角色具有 &lt;code&gt;NOINHERIT&lt;/code&gt; 属性，则 &lt;code&gt;SET ROLE&lt;/code&gt; 将丢弃直接分配给会话用户的特权，而是获取可用于命名角色的特权。</target>
        </trans-unit>
        <trans-unit id="bf3833196f5808681a4549e6dae3e11c17ff7d14" translate="yes" xml:space="preserve">
          <source>Using this option is subtly different from writing &lt;code&gt;psql &amp;lt; filename&lt;/code&gt;. In general, both will do what you expect, but using &lt;code&gt;-f&lt;/code&gt; enables some nice features such as error messages with line numbers. There is also a slight chance that using this option will reduce the start-up overhead. On the other hand, the variant using the shell's input redirection is (in theory) guaranteed to yield exactly the same output you would have received had you entered everything by hand.</source>
          <target state="translated">使用此选项与编写 &lt;code&gt;psql &amp;lt; filename&lt;/code&gt; 稍有不同。通常，两者都能达到您的期望，但是使用 &lt;code&gt;-f&lt;/code&gt; 可以启用一些不错的功能，例如带有行号的错误消息。使用此选项还可能会减少启动开销。另一方面，使用shell的输入重定向的变体在理论上可以保证产生与您手工输入的所有内容完全相同的输出。</target>
        </trans-unit>
        <trans-unit id="bb94658d71fedbd45e9091422be0f40e3960ad97" translate="yes" xml:space="preserve">
          <source>Usually, a row reflecting an incorrect entry will have values for only the &lt;code&gt;line_number&lt;/code&gt; and &lt;code&gt;error&lt;/code&gt; fields.</source>
          <target state="translated">通常，反映错误条目的行将仅具有 &lt;code&gt;line_number&lt;/code&gt; 和 &lt;code&gt;error&lt;/code&gt; 字段的值。</target>
        </trans-unit>
        <trans-unit id="0a83488e309bcd16565cc48e7357404309c680f8" translate="yes" xml:space="preserve">
          <source>VACUUM</source>
          <target state="translated">VACUUM</target>
        </trans-unit>
        <trans-unit id="615ff5ce2e5448f0eae82299f9e03df2b83f7a7d" translate="yes" xml:space="preserve">
          <source>VACUUM &amp;mdash; garbage-collect and optionally analyze a database</source>
          <target state="translated">VACUUM &amp;mdash;垃圾收集并有选择地分析数据库</target>
        </trans-unit>
        <trans-unit id="b3cba55338b3625665f9ea5a7e33ff9db26da1af" translate="yes" xml:space="preserve">
          <source>VALUES</source>
          <target state="translated">VALUES</target>
        </trans-unit>
        <trans-unit id="7e2bb4ebd8bb3d86c6acc1d3b34b4607a8278459" translate="yes" xml:space="preserve">
          <source>VALUES &amp;mdash; compute a set of rows</source>
          <target state="translated">VALUES &amp;mdash;计算一组行</target>
        </trans-unit>
        <trans-unit id="df605145d9028810fbbd6bb82ba2cbbdf49fe2f6" translate="yes" xml:space="preserve">
          <source>VALUES Lists</source>
          <target state="translated">VALUES 列表</target>
        </trans-unit>
        <trans-unit id="5fe15df2c7882707d49fdc0903788dfd022b02ca" translate="yes" xml:space="preserve">
          <source>Vacuum</source>
          <target state="translated">Vacuum</target>
        </trans-unit>
        <trans-unit id="49310dbe4a27690da5f29db4c406ef0b0e02e27a" translate="yes" xml:space="preserve">
          <source>Vacuum all databases.</source>
          <target state="translated">对所有数据库进行抽真空。</target>
        </trans-unit>
        <trans-unit id="d78bc05489ae0681fdd181a90fe2d3af72c88331" translate="yes" xml:space="preserve">
          <source>Vacuum all four standard tables before running the test. With neither &lt;code&gt;-n&lt;/code&gt; nor &lt;code&gt;-v&lt;/code&gt;, pgbench will vacuum the &lt;code&gt;pgbench_tellers&lt;/code&gt; and &lt;code&gt;pgbench_branches&lt;/code&gt; tables, and will truncate &lt;code&gt;pgbench_history&lt;/code&gt;.</source>
          <target state="translated">在运行测试之前，先抽真空所有四个标准表。如果既不使用 &lt;code&gt;-n&lt;/code&gt; 也不使用 &lt;code&gt;-v&lt;/code&gt; ，则pgbench将 &lt;code&gt;pgbench_tellers&lt;/code&gt; 和 &lt;code&gt;pgbench_branches&lt;/code&gt; 表，并截断 &lt;code&gt;pgbench_history&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="558c7ef6cec7040888bc23237bf5bc10ac6c115d" translate="yes" xml:space="preserve">
          <source>Vacuum also allows removal of old files from the &lt;code&gt;pg_xact&lt;/code&gt; subdirectory, which is why the default is a relatively low 200 million transactions. This parameter can only be set at server start, but the setting can be reduced for individual tables by changing table storage parameters. For more information see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;Section 24.1.5&lt;/a&gt;.</source>
          <target state="translated">Vacuum还允许从 &lt;code&gt;pg_xact&lt;/code&gt; 子目录中删除旧文件，这就是为什么默认值是相对较低的2亿个事务。只能在服务器启动时设置此参数，但是可以通过更改表存储参数来减少单个表的设置。有关更多信息，请参见&lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;第24.1.5节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f4af123f2e65a46f53e9a9ee64ca03a1079be929" translate="yes" xml:space="preserve">
          <source>Vacuum maintains a &lt;a href=&quot;storage-vm&quot;&gt;visibility map&lt;/a&gt; for each table to keep track of which pages contain only tuples that are known to be visible to all active transactions (and all future transactions, until the page is again modified). This has two purposes. First, vacuum itself can skip such pages on the next run, since there is nothing to clean up.</source>
          <target state="translated">Vacuum 为每个表维护一个&lt;a href=&quot;storage-vm&quot;&gt;可见性图&lt;/a&gt;，以跟踪哪些页面仅包含已知对所有活动事务（以及所有将来的事务可见，直到再次修改该页面）可见的元组。这有两个目的。首先，真空本身可以在下一次运行时跳过此类页面，因为没有什么需要清理的。</target>
        </trans-unit>
        <trans-unit id="8fb0ba1bca8b404cfdbdb7679f9f4d296fc6f1fa" translate="yes" xml:space="preserve">
          <source>Vacuuming multixacts also allows removal of old files from the &lt;code&gt;pg_multixact/members&lt;/code&gt; and &lt;code&gt;pg_multixact/offsets&lt;/code&gt; subdirectories, which is why the default is a relatively low 400 million multixacts. This parameter can only be set at server start, but the setting can be reduced for individual tables by changing table storage parameters. For more information see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-MULTIXACT-WRAPAROUND&quot;&gt;Section 24.1.5.1&lt;/a&gt;.</source>
          <target state="translated">清理multixacts还可以从 &lt;code&gt;pg_multixact/members&lt;/code&gt; 和 &lt;code&gt;pg_multixact/offsets&lt;/code&gt; 子目录中删除旧文件，这就是为什么默认值为相对较低的4亿个multixacts的原因。只能在服务器启动时设置此参数，但是可以通过更改表存储参数来减少单个表的设置。有关更多信息，请参见&lt;a href=&quot;routine-vacuuming#VACUUM-FOR-MULTIXACT-WRAPAROUND&quot;&gt;第24.1.5.1节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ac19d033655fd012b97b53639462b257da978e6a" translate="yes" xml:space="preserve">
          <source>Valid Types</source>
          <target state="translated">有效类型</target>
        </trans-unit>
        <trans-unit id="c7e5f1bbc3dc93b5ff6072a3bc81757a3ed075d7" translate="yes" xml:space="preserve">
          <source>Valid input for the time stamp types consists of the concatenation of a date and a time, followed by an optional time zone, followed by an optional &lt;code&gt;AD&lt;/code&gt; or &lt;code&gt;BC&lt;/code&gt;. (Alternatively, &lt;code&gt;AD&lt;/code&gt;/&lt;code&gt;BC&lt;/code&gt; can appear before the time zone, but this is not the preferred ordering.) Thus:</source>
          <target state="translated">时间戳记类型的有效输入包括日期和时间的串联，后跟一个可选的时区，再跟一个可选的 &lt;code&gt;AD&lt;/code&gt; 或 &lt;code&gt;BC&lt;/code&gt; 。 （或者， &lt;code&gt;AD&lt;/code&gt; / &lt;code&gt;BC&lt;/code&gt; 可以出现在时区之前，但这不是首选顺序。）因此：</target>
        </trans-unit>
        <trans-unit id="c3fd0054c277594413eaed1c75df986510128d67" translate="yes" xml:space="preserve">
          <source>Valid input for these types consists of a time of day followed by an optional time zone. (See &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-TIME-TABLE&quot;&gt;Table 8.11&lt;/a&gt; and &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONE-TABLE&quot;&gt;Table 8.12&lt;/a&gt;.) If a time zone is specified in the input for &lt;code&gt;time without time zone&lt;/code&gt;, it is silently ignored. You can also specify a date but it will be ignored, except when you use a time zone name that involves a daylight-savings rule, such as &lt;code&gt;America/New_York&lt;/code&gt;. In this case specifying the date is required in order to determine whether standard or daylight-savings time applies. The appropriate time zone offset is recorded in the &lt;code&gt;time with time zone&lt;/code&gt; value.</source>
          <target state="translated">这些类型的有效输入包括一天中的时间，然后是可选的时区。 （请参阅&lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-TIME-TABLE&quot;&gt;表8.11&lt;/a&gt;和&lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONE-TABLE&quot;&gt;表8.12&lt;/a&gt;。）如果在输入中为 &lt;code&gt;time without time zone&lt;/code&gt; 指定了时区，则将忽略该时区。您还可以指定一个日期，但是它将被忽略，除非您使用的是涉及夏时制的时区名称，例如 &lt;code&gt;America/New_York&lt;/code&gt; 。在这种情况下，需要指定日期才能确定标准时间还是夏令时。 &lt;code&gt;time with time zone&lt;/code&gt; 值的时间会记录适当的时区偏移量。</target>
        </trans-unit>
        <trans-unit id="844edfde8ce5da216439f5cc862b141254fb9d4a" translate="yes" xml:space="preserve">
          <source>Valid memory units are &lt;code&gt;B&lt;/code&gt; (bytes), &lt;code&gt;kB&lt;/code&gt; (kilobytes), &lt;code&gt;MB&lt;/code&gt; (megabytes), &lt;code&gt;GB&lt;/code&gt; (gigabytes), and &lt;code&gt;TB&lt;/code&gt; (terabytes). The multiplier for memory units is 1024, not 1000.</source>
          <target state="translated">有效的内存单位是 &lt;code&gt;B&lt;/code&gt; （字节）， &lt;code&gt;kB&lt;/code&gt; （千字节）， &lt;code&gt;MB&lt;/code&gt; （兆字节）， &lt;code&gt;GB&lt;/code&gt; （千兆字节）和 &lt;code&gt;TB&lt;/code&gt; （兆字节）。存储单元的乘数为1024，而不是1000。</target>
        </trans-unit>
        <trans-unit id="239bf25206857881980ea876d3982e5ae2994831" translate="yes" xml:space="preserve">
          <source>Valid starting points for standby queries are generated at each checkpoint on the master. If the standby is shut down while the master is in a shutdown state, it might not be possible to re-enter Hot Standby until the primary is started up, so that it generates further starting points in the WAL logs. This situation isn't a problem in the most common situations where it might happen. Generally, if the primary is shut down and not available anymore, that's likely due to a serious failure that requires the standby being converted to operate as the new primary anyway. And in situations where the primary is being intentionally taken down, coordinating to make sure the standby becomes the new primary smoothly is also standard procedure.</source>
          <target state="translated">待机查询的有效起点是在主站的每个检查点生成的。如果待机在主站处于关闭状态时被关闭,那么在主站启动之前,可能无法重新进入热待机状态,从而在WAL日志中生成更多的起始点。这种情况在最常见的情况下并不是问题,它可能会发生。一般来说,如果主站被关闭,不能再使用,那很可能是由于严重的故障,无论如何都需要将待机转换为新的主站运行。而在主设备被故意关闭的情况下,协调确保备用设备顺利成为新的主设备也是标准程序。</target>
        </trans-unit>
        <trans-unit id="36d562c59f538b4cf6287a1bc49b7023b220600a" translate="yes" xml:space="preserve">
          <source>Valid time units are &lt;code&gt;us&lt;/code&gt; (microseconds), &lt;code&gt;ms&lt;/code&gt; (milliseconds), &lt;code&gt;s&lt;/code&gt; (seconds), &lt;code&gt;min&lt;/code&gt; (minutes), &lt;code&gt;h&lt;/code&gt; (hours), and &lt;code&gt;d&lt;/code&gt; (days).</source>
          <target state="translated">有效时间单位是 &lt;code&gt;us&lt;/code&gt; （微秒）， &lt;code&gt;ms&lt;/code&gt; （毫秒）， &lt;code&gt;s&lt;/code&gt; （秒）， &lt;code&gt;min&lt;/code&gt; （分钟）， &lt;code&gt;h&lt;/code&gt; （小时）和 &lt;code&gt;d&lt;/code&gt; （天）。</target>
        </trans-unit>
        <trans-unit id="dfda311a4ab9af803299c88d82467b20a4636196" translate="yes" xml:space="preserve">
          <source>Valid values for &lt;code&gt;field&lt;/code&gt; are:</source>
          <target state="translated">该 &lt;code&gt;field&lt;/code&gt; 有效值为：</target>
        </trans-unit>
        <trans-unit id="10d7649316ac64615f5264b37dbb56375dda92e2" translate="yes" xml:space="preserve">
          <source>Valid variable names can contain letters, digits, and underscores. See &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;Variables&lt;/a&gt; below for details. Variable names are case-sensitive.</source>
          <target state="translated">有效的变量名称可以包含字母，数字和下划线。有关详细信息，请参见下面的&lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;变量&lt;/a&gt;。变量名称区分大小写。</target>
        </trans-unit>
        <trans-unit id="4e71de8159ccd805dfaf84c4abe0cc37c7fd0bef" translate="yes" xml:space="preserve">
          <source>Valid variable names can contain letters, digits, and underscores. See the section &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;Variables&lt;/a&gt; below for details. Variable names are case-sensitive.</source>
          <target state="translated">有效的变量名称可以包含字母，数字和下划线。有关详细信息，请参见下面的&lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;变量&lt;/a&gt;部分。变量名称区分大小写。</target>
        </trans-unit>
        <trans-unit id="6495bdc388499bc5f8ab2cec7e4d413da357e199" translate="yes" xml:space="preserve">
          <source>Validate the catalog entries for the specified operator class, so far as the access method can reasonably do that. For example, this might include testing that all required support functions are provided. The &lt;code&gt;amvalidate&lt;/code&gt; function must return false if the opclass is invalid. Problems should be reported with &lt;code&gt;ereport&lt;/code&gt; messages.</source>
          <target state="translated">验证指定操作员类的目录条目，只要访问方法可以合理地做到这一点即可。例如，这可能包括测试是否提供了所有必需的支持功能。该 &lt;code&gt;amvalidate&lt;/code&gt; 如果的opclass是无效的函数必须返回false。问题应通过 &lt;code&gt;ereport&lt;/code&gt; 消息报告。</target>
        </trans-unit>
        <trans-unit id="89711f6e0ac15ee4534c22e657dbb299816df29f" translate="yes" xml:space="preserve">
          <source>Validates an invalid number (clears the invalid flag)</source>
          <target state="translated">验证一个无效的数字(清除无效标志)。</target>
        </trans-unit>
        <trans-unit id="589311b6a2805b6a0281872c806ce0f19f6dd7a2" translate="yes" xml:space="preserve">
          <source>Validates an invalid number (clears the invalid flag).</source>
          <target state="translated">验证一个无效的数字(清除无效标志)。</target>
        </trans-unit>
        <trans-unit id="a914a2300c495dde9a239ee72a952fef70648b1b" translate="yes" xml:space="preserve">
          <source>Value Example</source>
          <target state="translated">价值示例</target>
        </trans-unit>
        <trans-unit id="892634b1322b72a29145754cdb909390816e79df" translate="yes" xml:space="preserve">
          <source>Value Expressions</source>
          <target state="translated">价值表达式</target>
        </trans-unit>
        <trans-unit id="b69a17e345014c4860d42b3ea12bfd1d74a98205" translate="yes" xml:space="preserve">
          <source>Value Expressions: Aggregate Expressions</source>
          <target state="translated">值表达式。聚合表达式</target>
        </trans-unit>
        <trans-unit id="62258d667ea100846bebdafcf33e6ba0d80bc0cf" translate="yes" xml:space="preserve">
          <source>Value Expressions: Array Constructors</source>
          <target state="translated">值表达式。阵列构造函数</target>
        </trans-unit>
        <trans-unit id="538d0773b42800a1dced9ebd66981d039270223a" translate="yes" xml:space="preserve">
          <source>Value Expressions: Collation Expressions</source>
          <target state="translated">值表达式。整理表达式</target>
        </trans-unit>
        <trans-unit id="09b3d5a6d9bce4eae0f96433329fd2780b515b1d" translate="yes" xml:space="preserve">
          <source>Value Expressions: Column References</source>
          <target state="translated">值表达式。列引用</target>
        </trans-unit>
        <trans-unit id="0f5899e3893a9e71da04384ff81d2b0668b66cce" translate="yes" xml:space="preserve">
          <source>Value Expressions: Expression Evaluation Rules</source>
          <target state="translated">值表达式。表达式评价规则</target>
        </trans-unit>
        <trans-unit id="7a33243a5a764268dbc19c7b5d5ffb815f2b2494" translate="yes" xml:space="preserve">
          <source>Value Expressions: Field Selection</source>
          <target state="translated">值表达式。字段选择</target>
        </trans-unit>
        <trans-unit id="fc2734409ea30f439f8007a816c89fd5d4964498" translate="yes" xml:space="preserve">
          <source>Value Expressions: Function Calls</source>
          <target state="translated">值表达式。函数调用</target>
        </trans-unit>
        <trans-unit id="06ab5a8d541c803b5a6f5f5baa72444250b7d0c9" translate="yes" xml:space="preserve">
          <source>Value Expressions: Operator Invocations</source>
          <target state="translated">值表达式。操作符调用</target>
        </trans-unit>
        <trans-unit id="e5f7f7098e87803a977afb22b3e716623af90f8e" translate="yes" xml:space="preserve">
          <source>Value Expressions: Positional Parameters</source>
          <target state="translated">值表达式。位置参数</target>
        </trans-unit>
        <trans-unit id="c58f459ac2b52cf9d74d05fef53f0cf74dcac929" translate="yes" xml:space="preserve">
          <source>Value Expressions: Row Constructors</source>
          <target state="translated">值表达式。行构造器</target>
        </trans-unit>
        <trans-unit id="2c538998fa55638c7ded3a8a283b8e9feb0bd885" translate="yes" xml:space="preserve">
          <source>Value Expressions: Scalar Subqueries</source>
          <target state="translated">值表达式。标量子查询</target>
        </trans-unit>
        <trans-unit id="1da69c14dd40700afb2c0a8abd86f7b740450e6f" translate="yes" xml:space="preserve">
          <source>Value Expressions: Subscripts</source>
          <target state="translated">值表达式。子条</target>
        </trans-unit>
        <trans-unit id="cccb4f69d3a8cb038ef6a413bb2c663923cd9fc0" translate="yes" xml:space="preserve">
          <source>Value Expressions: Type Casts</source>
          <target state="translated">值表达式。类型转换</target>
        </trans-unit>
        <trans-unit id="3715da19fdcfeeba7fe50bb93e020a8b25f6a530" translate="yes" xml:space="preserve">
          <source>Value Expressions: Window Function Calls</source>
          <target state="translated">值表达式。窗口函数调用</target>
        </trans-unit>
        <trans-unit id="bf4f8a0decbb4b4fd4371821f1c74ba9a1594ce9" translate="yes" xml:space="preserve">
          <source>Value Storage</source>
          <target state="translated">价值存储</target>
        </trans-unit>
        <trans-unit id="2977eb7ab7cb1230619c6002ed4cbbc6cc756fa6" translate="yes" xml:space="preserve">
          <source>Value expressions are used in a variety of contexts, such as in the target list of the &lt;code&gt;SELECT&lt;/code&gt; command, as new column values in &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt;, or in search conditions in a number of commands. The result of a value expression is sometimes called a &lt;em&gt;scalar&lt;/em&gt;, to distinguish it from the result of a table expression (which is a table). Value expressions are therefore also called &lt;em&gt;scalar expressions&lt;/em&gt; (or even simply &lt;em&gt;expressions&lt;/em&gt;). The expression syntax allows the calculation of values from primitive parts using arithmetic, logical, set, and other operations.</source>
          <target state="translated">值表达式可在各种上下文中使用，例如在 &lt;code&gt;SELECT&lt;/code&gt; 命令的目标列表中，在 &lt;code&gt;INSERT&lt;/code&gt; 或 &lt;code&gt;UPDATE&lt;/code&gt; 中用作新列值，或在许多命令中用于搜索条件。值表达式的结果有时称为&lt;em&gt;标量&lt;/em&gt;，以将其与表表达式（即表）的结果区分开。因此值表达式也叫做&lt;em&gt;标量表达式&lt;/em&gt;（或者甚至干脆&lt;em&gt;表达式&lt;/em&gt;）。表达式语法允许使用算术，逻辑，集合和其他运算从原始部分计算值。</target>
        </trans-unit>
        <trans-unit id="114f96aeed1ddb1f81a693ccadc122b00691f706" translate="yes" xml:space="preserve">
          <source>Value that &lt;code&gt;RESET&lt;/code&gt; would reset the parameter to in the current session</source>
          <target state="translated">&lt;code&gt;RESET&lt;/code&gt; 会将当前会话中的参数重置为的值</target>
        </trans-unit>
        <trans-unit id="28c18b9457473dab8964985ffc208f4a1973292c" translate="yes" xml:space="preserve">
          <source>Value to be assigned to the parameter</source>
          <target state="translated">要分配给该参数的值</target>
        </trans-unit>
        <trans-unit id="f84541e98210f793e8890e82c64afbe27a9c9a73" translate="yes" xml:space="preserve">
          <source>Value used to perform comparison with JSON &lt;code&gt;false&lt;/code&gt; literal</source>
          <target state="translated">用于与JSON &lt;code&gt;false&lt;/code&gt; 文字进行比较的值</target>
        </trans-unit>
        <trans-unit id="f129faa853bacb07b12134ac4fd986301a263b11" translate="yes" xml:space="preserve">
          <source>Value used to perform comparison with JSON &lt;code&gt;null&lt;/code&gt; value</source>
          <target state="translated">用于与JSON &lt;code&gt;null&lt;/code&gt; 值进行比较的值</target>
        </trans-unit>
        <trans-unit id="8a792873148b2fe92c538941fe93212a85f960e9" translate="yes" xml:space="preserve">
          <source>Value used to perform comparison with JSON &lt;code&gt;true&lt;/code&gt; literal</source>
          <target state="translated">用于与JSON &lt;code&gt;true&lt;/code&gt; 文字进行比较的值</target>
        </trans-unit>
        <trans-unit id="e8086792911df062e24caa3131a5135743c9b16c" translate="yes" xml:space="preserve">
          <source>Value/Predicate</source>
          <target state="translated">Value/Predicate</target>
        </trans-unit>
        <trans-unit id="1f1cb2e6759dab2334119644e8cf129ac32ce11d" translate="yes" xml:space="preserve">
          <source>Values are stored internally as 64-bit floating point numbers. This means that numbers with more than about 16 significant digits will be truncated.</source>
          <target state="translated">值在内部存储为64位浮点数。这意味着超过16位有效数字的数字将被截断。</target>
        </trans-unit>
        <trans-unit id="6d7efb522647e3ca74917dae6abd528277b3ab9e" translate="yes" xml:space="preserve">
          <source>Values needed to run one PostgreSQL instance</source>
          <target state="translated">运行一个PostgreSQL实例所需的值</target>
        </trans-unit>
        <trans-unit id="8d380e11f26f75eaba033d74818adbe55ddca1de" translate="yes" xml:space="preserve">
          <source>Values of the &lt;code&gt;numeric&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, and &lt;code&gt;bigint&lt;/code&gt; data types can be cast to &lt;code&gt;money&lt;/code&gt;. Conversion from the &lt;code&gt;real&lt;/code&gt; and &lt;code&gt;double precision&lt;/code&gt; data types can be done by casting to &lt;code&gt;numeric&lt;/code&gt; first, for example:</source>
          <target state="translated">该值 &lt;code&gt;numeric&lt;/code&gt; ， &lt;code&gt;int&lt;/code&gt; 和 &lt;code&gt;bigint&lt;/code&gt; 数据类型可以转换为 &lt;code&gt;money&lt;/code&gt; 。从 &lt;code&gt;real&lt;/code&gt; &lt;code&gt;double precision&lt;/code&gt; 和双精度数据类型的转换可以通过首先转换为 &lt;code&gt;numeric&lt;/code&gt; 来完成，例如：</target>
        </trans-unit>
        <trans-unit id="6a94b34531e2a116d1ab90afc1f71919f7dc0067" translate="yes" xml:space="preserve">
          <source>Values of the &lt;code&gt;pg_mcv_list&lt;/code&gt; can be obtained only from the &lt;code&gt;pg_statistic_ext_data.stxdmcv&lt;/code&gt; column.</source>
          <target state="translated">&lt;code&gt;pg_mcv_list&lt;/code&gt; 的值只能从 &lt;code&gt;pg_statistic_ext_data.stxdmcv&lt;/code&gt; 列中获得。</target>
        </trans-unit>
        <trans-unit id="850035024c129e8a798d30d9fc0a41ee9af84afc" translate="yes" xml:space="preserve">
          <source>Values of the &lt;code&gt;pg_mcv_list&lt;/code&gt; type can be obtained only from the &lt;code&gt;pg_statistic_ext_data&lt;/code&gt;.&lt;code&gt;stxdmcv&lt;/code&gt; column.</source>
          <target state="translated">只能从 &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; 获得 &lt;code&gt;pg_mcv_list&lt;/code&gt; 类型的值。 &lt;code&gt;stxdmcv&lt;/code&gt; 列。</target>
        </trans-unit>
        <trans-unit id="3b87bdbb02446940728e896c08b8825bde2b21b0" translate="yes" xml:space="preserve">
          <source>Values of this domain are allowed to be null. This is the default.</source>
          <target state="translated">该域的值允许为空。这是默认值。</target>
        </trans-unit>
        <trans-unit id="d29119abb7de6b63218065ed67e351db8dc51728" translate="yes" xml:space="preserve">
          <source>Values of this domain are prevented from being null (but see notes below).</source>
          <target state="translated">这个域的值被防止为空(但见下面的注释)。</target>
        </trans-unit>
        <trans-unit id="0d30cecbfdbc76e7857e49ac92bd25f13ef34d9b" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;character&lt;/code&gt; are physically padded with spaces to the specified width &lt;code&gt;n&lt;/code&gt;, and are stored and displayed that way. However, trailing spaces are treated as semantically insignificant and disregarded when comparing two values of type &lt;code&gt;character&lt;/code&gt;. In collations where whitespace is significant, this behavior can produce unexpected results; for example &lt;code&gt;SELECT 'a '::CHAR(2) collate &quot;C&quot; &amp;lt; E'a\n'::CHAR(2)&lt;/code&gt; returns true, even though &lt;code&gt;C&lt;/code&gt; locale would consider a space to be greater than a newline. Trailing spaces are removed when converting a &lt;code&gt;character&lt;/code&gt; value to one of the other string types. Note that trailing spaces &lt;em&gt;are&lt;/em&gt; semantically significant in &lt;code&gt;character varying&lt;/code&gt; and &lt;code&gt;text&lt;/code&gt; values, and when using pattern matching, that is &lt;code&gt;LIKE&lt;/code&gt; and regular expressions.</source>
          <target state="translated">&lt;code&gt;character&lt;/code&gt; 类型的值实际上用空格填充到指定的宽度 &lt;code&gt;n&lt;/code&gt; ，并以这种方式存储和显示。但是，在比较两个 &lt;code&gt;character&lt;/code&gt; 类型的值时，尾随空格被视为语义上无关紧要的并且被忽略。在空白很重要的排序规则中，此行为会产生意外的结果；例如 &lt;code&gt;SELECT 'a '::CHAR(2) collate &quot;C&quot; &amp;lt; E'a\n'::CHAR(2)&lt;/code&gt; 返回true，即使 &lt;code&gt;C&lt;/code&gt; 语言环境认为空格大于换行符也是如此。将 &lt;code&gt;character&lt;/code&gt; 值转换为其他字符串类型之一时，将删除尾部空格。需要注意的是尾部的空格&lt;em&gt;是&lt;/em&gt;语义上显著的 &lt;code&gt;character varying&lt;/code&gt; 和 &lt;code&gt;text&lt;/code&gt; 值，以及使用模式匹配时（如 &lt;code&gt;LIKE&lt;/code&gt; 和正则表达式）。</target>
        </trans-unit>
        <trans-unit id="0d0e8ddc497a1b9c951f5949c5d9e1b70b9a22cd" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;path&lt;/code&gt; are specified using any of the following syntaxes:</source>
          <target state="translated">使用以下任何一种语法来指定 &lt;code&gt;path&lt;/code&gt; 类型的值：</target>
        </trans-unit>
        <trans-unit id="d80b51f9c7fc6e7a8b7e3fe299274555e9a2ae02" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;polygon&lt;/code&gt; are specified using any of the following syntaxes:</source>
          <target state="translated">使用以下任何一种语法指定 &lt;code&gt;polygon&lt;/code&gt; 类型的值：</target>
        </trans-unit>
        <trans-unit id="e5a16467bfe399e24f49eb7fdb667ccec5d8723e" translate="yes" xml:space="preserve">
          <source>Values set with &lt;code&gt;ALTER DATABASE&lt;/code&gt; and &lt;code&gt;ALTER ROLE&lt;/code&gt; are applied only when starting a fresh database session. They override values obtained from the configuration files or server command line, and constitute defaults for the rest of the session. Note that some settings cannot be changed after server start, and so cannot be set with these commands (or the ones listed below).</source>
          <target state="translated">使用 &lt;code&gt;ALTER DATABASE&lt;/code&gt; 和 &lt;code&gt;ALTER ROLE&lt;/code&gt; 设置的值仅在启动新的数据库会话时适用。它们会覆盖从配置文件或服务器命令行获取的值，并构成其余会话的默认值。请注意，服务器启动后无法更改某些设置，因此无法使用这些命令（或下面列出的命令）进行设置。</target>
        </trans-unit>
        <trans-unit id="818a4a9f523da08f985a8d7bb8387b916781ef1a" translate="yes" xml:space="preserve">
          <source>Values set with &lt;code&gt;ALTER SYSTEM&lt;/code&gt; will be effective after the next server configuration reload, or after the next server restart in the case of parameters that can only be changed at server start. A server configuration reload can be commanded by calling the SQL function &lt;code&gt;pg_reload_conf()&lt;/code&gt;, running &lt;code&gt;pg_ctl reload&lt;/code&gt;, or sending a SIGHUP signal to the main server process.</source>
          <target state="translated">在下一次服务器配置重新加载之后，或者对于只能在服务器启动时更改的参数，在下一个服务器重新启动之后，使用 &lt;code&gt;ALTER SYSTEM&lt;/code&gt; 设置的值将生效。可以通过调用SQL函数 &lt;code&gt;pg_reload_conf()&lt;/code&gt; ，运行 &lt;code&gt;pg_ctl reload&lt;/code&gt; 或向主服务器进程发送SIGHUP信号来命令服务器配置重新加载。</target>
        </trans-unit>
        <trans-unit id="8e2a94acd55e77d304a8881179a17d08010c723b" translate="yes" xml:space="preserve">
          <source>Values to be inserted into a table are converted to the destination column's data type according to the following steps.</source>
          <target state="translated">要插入到表中的值按照以下步骤转换为目标列的数据类型。</target>
        </trans-unit>
        <trans-unit id="543a387448ddbbf661178992c3adaa7b069168fb" translate="yes" xml:space="preserve">
          <source>Values: 0 - Without salt. Dangerous! 1 - With salt but with fixed iteration count. 3 - Variable iteration count. Default: 3 Applies to: pgp_sym_encrypt</source>
          <target state="translated">价值。0,不加盐 危险! 1-有盐但有固定的迭代次数。3-迭代次数可变。默认值:3 适用于:pgp_sym_encrypt。</target>
        </trans-unit>
        <trans-unit id="e85fa17c91ce0d6924e2ed0119f352ea3f8fb549" translate="yes" xml:space="preserve">
          <source>Values: 0 - no compression 1 - ZIP compression 2 - ZLIB compression (= ZIP plus meta-data and block CRCs) Default: 0 Applies to: pgp_sym_encrypt, pgp_pub_encrypt</source>
          <target state="translated">值:0-无压缩 1-ZIP压缩 2-ZLIB压缩 (=ZIP加元数据和块CRCs)默认值:0 适用于:pgp_sym_encrypt,pgp_pub_sym_encrypt,pgp_pub_sym_encrypt,pgp_pub_sym_encrypt,pgp_pub_sym_encrypt。0-无压缩 1-ZIP压缩 2-ZLIB压缩 (=ZIP加上元数据和块CRCs)默认值:0 适用于:pgp_sym_encrypt,pgp_pub_encrypt。</target>
        </trans-unit>
        <trans-unit id="52218ba89357173a5dfb8618986a1e8fdfb757a3" translate="yes" xml:space="preserve">
          <source>Values: 0, 1 Default: 0 Applies to: pgp_sym_encrypt</source>
          <target state="translated">数值:0,1 默认值:0 0,1 默认值:0 适用于:pgp_sym_encrypt</target>
        </trans-unit>
        <trans-unit id="922303e052dbc79ebb5e801b79cffb9186efe35c" translate="yes" xml:space="preserve">
          <source>Values: 0, 1 Default: 0 Applies to: pgp_sym_encrypt, pgp_pub_encrypt</source>
          <target state="translated">值:0,1 默认值:0 适用于:pgp_sym_encrypt,pgp_pub_encrypt 0,1 默认值:0 适用于:pgp_sym_encrypt,pgp_pub_encrypt。</target>
        </trans-unit>
        <trans-unit id="bbe411494b7a8541ba3eda983d9fa94b6f7dde40" translate="yes" xml:space="preserve">
          <source>Values: 0, 1 Default: 0 Applies to: pgp_sym_encrypt, pgp_pub_encrypt, pgp_sym_decrypt, pgp_pub_decrypt</source>
          <target state="translated">值:0,1 默认值:0 适用于:pgp_sym_encrypt,pgp_pub_encrypt,pgp_sym_decrypt,pgp_pub_decrypt 0,1 默认值:0 适用于:pgp_sym_encrypt,pgp_pub_encrypt,pgp_sym_decrypt,pgp_pub_decrypt.</target>
        </trans-unit>
        <trans-unit id="87f52252bc49eca143f466418a46bf231d397765" translate="yes" xml:space="preserve">
          <source>Values: 0, 1-9 Default: 6 Applies to: pgp_sym_encrypt, pgp_pub_encrypt</source>
          <target state="translated">值:0,1-9 默认值:6 适用于:pgp_sym_encrypt,pgp_pub_encrypt 0,1-9 默认值:6 适用于:pgp_sym_encrypt,pgp_pub_encrypt。</target>
        </trans-unit>
        <trans-unit id="631bb9d3f376659e6d97cddb0d8676370c2c08b3" translate="yes" xml:space="preserve">
          <source>Values: bf, aes, aes128, aes192, aes256 Default: use cipher-algo Applies to: pgp_sym_encrypt</source>
          <target state="translated">值:bf,aes,aes128,aes192,aes256 默认值:use cipher-algo 适用于:pgp_sym_encrypt。</target>
        </trans-unit>
        <trans-unit id="e9d1d35bfb5be3f756eb7a018b33d9e394f847ba" translate="yes" xml:space="preserve">
          <source>Values: bf, aes128, aes192, aes256 (OpenSSL-only: &lt;code&gt;3des&lt;/code&gt;, &lt;code&gt;cast5&lt;/code&gt;) Default: aes128 Applies to: pgp_sym_encrypt, pgp_pub_encrypt</source>
          <target state="translated">值：bf，aes128，aes192，aes256（仅OpenSSL： &lt;code&gt;3des&lt;/code&gt; 和 &lt;code&gt;cast5&lt;/code&gt; ）默认值：aes128适用于：pgp_sym_encrypt，pgp_pub_encrypt</target>
        </trans-unit>
        <trans-unit id="777af837f1de8927748898b65d1060bc773bad7b" translate="yes" xml:space="preserve">
          <source>Values: md5, sha1 Default: sha1 Applies to: pgp_sym_encrypt</source>
          <target state="translated">值:md5,sha1 默认值:sha1 适用于:pgp_sym_encrypt。</target>
        </trans-unit>
        <trans-unit id="19de69cb601f53a4ea7af22a65c71ae63251365c" translate="yes" xml:space="preserve">
          <source>Variable</source>
          <target state="translated">Variable</target>
        </trans-unit>
        <trans-unit id="a0b72534c52ce05719721c1bfff6524b4aef3cf8" translate="yes" xml:space="preserve">
          <source>Variable interpolation will not be performed within quoted SQL literals and identifiers. Therefore, a construction such as &lt;code&gt;':foo'&lt;/code&gt; doesn't work to produce a quoted literal from a variable's value (and it would be unsafe if it did work, since it wouldn't correctly handle quotes embedded in the value).</source>
          <target state="translated">变量内插将不会在带引号的SQL文字和标识符内执行。因此，诸如 &lt;code&gt;':foo'&lt;/code&gt; 之类的构造不适用于从变量的值中产生带引号的文字（并且如果起作用，将是不安全的，因为它将无法正确处理嵌入在值中的引号）。</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="f20578601408732c8ea02e8d928be3d22ba16637" translate="yes" xml:space="preserve">
          <source>Variables that control psql's behavior generally cannot be unset or set to invalid values. An &lt;code&gt;\unset&lt;/code&gt; command is allowed but is interpreted as setting the variable to its default value. A &lt;code&gt;\set&lt;/code&gt; command without a second argument is interpreted as setting the variable to &lt;code&gt;on&lt;/code&gt;, for control variables that accept that value, and is rejected for others. Also, control variables that accept the values &lt;code&gt;on&lt;/code&gt; and &lt;code&gt;off&lt;/code&gt; will also accept other common spellings of Boolean values, such as &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">控制psql行为的变量通常不能取消设置或设置为无效值。允许使用 &lt;code&gt;\unset&lt;/code&gt; 命令，但将其解释为将变量设置为其默认值。甲 &lt;code&gt;\set&lt;/code&gt; 没有第二个参数的命令将被解释为变量设置为 &lt;code&gt;on&lt;/code&gt; ，对于接受该值控制变量，并且将被拒绝他人。同样，接受 &lt;code&gt;on&lt;/code&gt; 和 &lt;code&gt;off&lt;/code&gt; 值的控制变量也将接受布尔值的其他常见拼写，例如 &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="71d1d14c3d8bef73e900f87a2c49118ec1795b0b" translate="yes" xml:space="preserve">
          <source>Various other settings related to &amp;ldquo;semaphore undo&amp;rdquo;, such as &lt;code&gt;SEMMNU&lt;/code&gt; and &lt;code&gt;SEMUME&lt;/code&gt;, do not affect PostgreSQL.</source>
          <target state="translated">与&amp;ldquo;信号量撤消&amp;rdquo;相关的各种其他设置（例如 &lt;code&gt;SEMMNU&lt;/code&gt; 和 &lt;code&gt;SEMUME&lt;/code&gt; ）不会影响PostgreSQL。</target>
        </trans-unit>
        <trans-unit id="bd6240cba4fe3aa73d43764309d30fb6d3d037a4" translate="yes" xml:space="preserve">
          <source>Various parameters have been mentioned above in &lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;Section 26.5.2&lt;/a&gt; and &lt;a href=&quot;hot-standby#HOT-STANDBY-ADMIN&quot;&gt;Section 26.5.3&lt;/a&gt;.</source>
          <target state="translated">上文&lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;第26.5.2 &lt;/a&gt;&lt;a href=&quot;hot-standby#HOT-STANDBY-ADMIN&quot;&gt;节&lt;/a&gt;和第26.5.3 节中提到了各种参数。</target>
        </trans-unit>
        <trans-unit id="d5b3325956fac55ce90bb38fba311678783c4a5a" translate="yes" xml:space="preserve">
          <source>Verification is performed using the same procedures as those used by index scans themselves, which may be user-defined operator class code. For example, B-Tree index verification relies on comparisons made with one or more B-Tree support function 1 routines. See &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-SUPPORT&quot;&gt;Section 37.16.3&lt;/a&gt; for details of operator class support functions.</source>
          <target state="translated">验证使用与索引扫描本身相同的过程执行，该过程可以是用户定义的操作员类代码。例如，B-Tree索引验证依赖于使用一个或多个B-Tree支持功能1例程进行的比较。有关操作员类别支持功能的详细信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-SUPPORT&quot;&gt;37.16.3节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="61976158db30bfdbe77805af6f5914f1244b7a45" translate="yes" xml:space="preserve">
          <source>Verification is performed using the same procedures as those used by index scans themselves, which may be user-defined operator class code. For example, B-Tree index verification relies on comparisons made with one or more B-Tree support function 1 routines. See &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-SUPPORT&quot;&gt;Section 37.16.3&lt;/a&gt; for details of operator class support functions.</source>
          <target state="translated">验证使用与索引扫描本身相同的过程执行，该过程可以是用户定义的操作员类代码。例如，B-Tree索引验证依赖于使用一个或多个B-Tree支持功能1例程进行的比较。有关操作员类别支持功能的详细信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-SUPPORT&quot;&gt;第37.16.3节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="875530bb85a9bc9a572c1b81ee549fe16ccb6d4b" translate="yes" xml:space="preserve">
          <source>Version and Platform Compatibility</source>
          <target state="translated">版本和平台兼容性</target>
        </trans-unit>
        <trans-unit id="1d9929f1f28bbd8834745a088bfee2450b12d5d8" translate="yes" xml:space="preserve">
          <source>Version name</source>
          <target state="translated">版本名称</target>
        </trans-unit>
        <trans-unit id="2597e3332e662024a1086db859f74acc32e53a21" translate="yes" xml:space="preserve">
          <source>Version name for the extension</source>
          <target state="translated">分机的版本名称</target>
        </trans-unit>
        <trans-unit id="29156f5ef29fca0492cf46682a435025e1953ccd" translate="yes" xml:space="preserve">
          <source>Version number</source>
          <target state="translated">版本号</target>
        </trans-unit>
        <trans-unit id="637ea0ea7f40808c77700c1c4f68ba0087e0490c" translate="yes" xml:space="preserve">
          <source>Version of SSL in use, or NULL if SSL is not in use on this connection</source>
          <target state="translated">使用中的SSL版本,如果该连接没有使用SSL,则为NULL。</target>
        </trans-unit>
        <trans-unit id="20a77b4ce23e6a598792ebba9c5fa53b934c43a3" translate="yes" xml:space="preserve">
          <source>Version of the server (optional)</source>
          <target state="translated">服务器的版本(可选</target>
        </trans-unit>
        <trans-unit id="2002aefc5b11f637b7466ee1a13c20a9e6171391" translate="yes" xml:space="preserve">
          <source>Vertical tab (ASCII 11)</source>
          <target state="translated">垂直选项卡(ASCII 11)</target>
        </trans-unit>
        <trans-unit id="9fe85f9993f6a26e677373400348d89af1072a3c" translate="yes" xml:space="preserve">
          <source>Very long-lived write transactions</source>
          <target state="translated">寿命非常长的写入交易</target>
        </trans-unit>
        <trans-unit id="30f98f07baa783307d6eeb3e956be798331b0ca1" translate="yes" xml:space="preserve">
          <source>Victor Wagner &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:vitus@cryptocom.ru&quot;&gt;vitus@cryptocom.ru&lt;/a&gt;&amp;gt;&lt;/code&gt;, Cryptocom LTD</source>
          <target state="translated">Victor Wagner &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:vitus@cryptocom.ru&quot;&gt;vitus@cryptocom.ru&lt;/a&gt;&amp;gt;&lt;/code&gt; ，加密货币有限公司</target>
        </trans-unit>
        <trans-unit id="1d6b8a691f0d907efa971075035a145a937381ac" translate="yes" xml:space="preserve">
          <source>Vietnamese</source>
          <target state="translated">Vietnamese</target>
        </trans-unit>
        <trans-unit id="69bd4ef9fbd0894a22759c3766b859defbdedbc8" translate="yes" xml:space="preserve">
          <source>View</source>
          <target state="translated">View</target>
        </trans-unit>
        <trans-unit id="bf0400b0f3aafc0bb49249e45dc8694f8cdb7fdb" translate="yes" xml:space="preserve">
          <source>View Name</source>
          <target state="translated">查看名称</target>
        </trans-unit>
        <trans-unit id="33ef89bbb476e8982fc98b280a43e4c9b99ae10c" translate="yes" xml:space="preserve">
          <source>View all the locks currently outstanding, all the locks on relations in a particular database, all the locks on a particular relation, or all the locks held by a particular PostgreSQL session.</source>
          <target state="translated">查看当前所有未完成的锁,特定数据库中关系的所有锁,特定关系的所有锁,或特定PostgreSQL会话的所有锁。</target>
        </trans-unit>
        <trans-unit id="cbe38ed5293f170b37453ef21637367ceda0f0b8" translate="yes" xml:space="preserve">
          <source>View definition (a reconstructed &lt;code&gt;SELECT&lt;/code&gt; query)</source>
          <target state="translated">视图定义（重建的 &lt;code&gt;SELECT&lt;/code&gt; 查询）</target>
        </trans-unit>
        <trans-unit id="94f66a08ed3a699a66860df21a573d573a238197" translate="yes" xml:space="preserve">
          <source>Viewing Locks</source>
          <target state="translated">查看锁</target>
        </trans-unit>
        <trans-unit id="24be61285e096fa817d4cdb0a0ed8294ea5bd2fb" translate="yes" xml:space="preserve">
          <source>Views</source>
          <target state="translated">Views</target>
        </trans-unit>
        <trans-unit id="c43c0cfc302cb10077693176e5e074e56b5aa3e7" translate="yes" xml:space="preserve">
          <source>Views can be used in almost any place a real table can be used. Building views upon other views is not uncommon.</source>
          <target state="translated">视图可以用在几乎所有可以使用真实表格的地方。在其他视图的基础上建立视图是很常见的。</target>
        </trans-unit>
        <trans-unit id="8e39d0decda3838416b25ba5106b0efbe06c4023" translate="yes" xml:space="preserve">
          <source>Virtual ID of the transaction targeted by the lock, or null if the target is not a virtual transaction ID</source>
          <target state="translated">锁定目标交易的虚拟ID,如果目标不是虚拟交易ID,则为空。</target>
        </trans-unit>
        <trans-unit id="811a0b30888086bd25c748477319220487f25d50" translate="yes" xml:space="preserve">
          <source>Virtual ID of the transaction that is holding or awaiting this lock</source>
          <target state="translated">持有或等待此锁的交易的虚拟ID。</target>
        </trans-unit>
        <trans-unit id="4e4ba211a7e69b2432d26b396c51c526655c765b" translate="yes" xml:space="preserve">
          <source>Virtual transaction ID (backendID/localXID)</source>
          <target state="translated">虚拟交易ID(backendID/localXID)</target>
        </trans-unit>
        <trans-unit id="588b3f896da2cfeabe798008bfd5617b36ad005b" translate="yes" xml:space="preserve">
          <source>Visibility map (fork)</source>
          <target state="translated">可见度图(分叉)</target>
        </trans-unit>
        <trans-unit id="e2415cb7f63df0c9de23362326ad3c37a9adfc96" translate="yes" xml:space="preserve">
          <source>W</source>
          <target state="translated">W</target>
        </trans-unit>
        <trans-unit id="588c142955d93338aefe3c6dd59baf541f7f60c7" translate="yes" xml:space="preserve">
          <source>WAL</source>
          <target state="translated">WAL</target>
        </trans-unit>
        <trans-unit id="1d1c95a48c1cec72e7cde457f1faf1b2311bbdfd" translate="yes" xml:space="preserve">
          <source>WAL Configuration</source>
          <target state="translated">WAL配置</target>
        </trans-unit>
        <trans-unit id="dc7b27e2b628547b61cdbe01ad5b4d44572d2c25" translate="yes" xml:space="preserve">
          <source>WAL Internals</source>
          <target state="translated">WAL内部</target>
        </trans-unit>
        <trans-unit id="cd824454d5f714596ff079dcd401902ac18dd100" translate="yes" xml:space="preserve">
          <source>WAL also makes it possible to support on-line backup and point-in-time recovery, as described in &lt;a href=&quot;continuous-archiving&quot;&gt;Section 25.3&lt;/a&gt;. By archiving the WAL data we can support reverting to any time instant covered by the available WAL data: we simply install a prior physical backup of the database, and replay the WAL log just as far as the desired time. What's more, the physical backup doesn't have to be an instantaneous snapshot of the database state &amp;mdash; if it is made over some period of time, then replaying the WAL log for that period will fix any internal inconsistencies.</source>
          <target state="translated">WAL还可以支持在线备份和时间点恢复，如&lt;a href=&quot;continuous-archiving&quot;&gt;第25.3节中&lt;/a&gt;所述。通过存档WAL数据，我们可以支持恢复到可用WAL数据所覆盖的任何时刻：我们只需安装数据库的先前物理备份，然后将WAL日志重播到所需时间即可。而且，物理备份不必是数据库状态的即时快照-如果是在一段时间内进行的，则在此期间重播WAL日志将解决任何内部不一致问题。</target>
        </trans-unit>
        <trans-unit id="56d9842b4dd6ff8912c8130e9ac002eac147ee40" translate="yes" xml:space="preserve">
          <source>WAL archiver (process)</source>
          <target state="translated">WAL存档器(进程)</target>
        </trans-unit>
        <trans-unit id="52a8587a456d98f221f4f9bce63c226fcda62f9a" translate="yes" xml:space="preserve">
          <source>WAL file</source>
          <target state="translated">WAL文件</target>
        </trans-unit>
        <trans-unit id="e4adb460b94535160dc5514c2f3243fad9448dc8" translate="yes" xml:space="preserve">
          <source>WAL file control commands will not work during recovery, e.g. &lt;code&gt;pg_start_backup&lt;/code&gt;, &lt;code&gt;pg_switch_wal&lt;/code&gt; etc.</source>
          <target state="translated">WAL文件控制命令在恢复期间将不起作用，例如 &lt;code&gt;pg_start_backup&lt;/code&gt; ， &lt;code&gt;pg_switch_wal&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="0dc06e1a1b8ef3a3c8739d9743e015585588e2e0" translate="yes" xml:space="preserve">
          <source>WAL file control commands will not work during recovery, e.g., &lt;code&gt;pg_start_backup&lt;/code&gt;, &lt;code&gt;pg_switch_wal&lt;/code&gt; etc.</source>
          <target state="translated">WAL文件控制命令在恢复期间将不起作用，例如 &lt;code&gt;pg_start_backup&lt;/code&gt; ， &lt;code&gt;pg_switch_wal&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="9b2801865ae804dc7013c1520108c058b7f6c30a" translate="yes" xml:space="preserve">
          <source>WAL is automatically enabled; no action is required from the administrator except ensuring that the disk-space requirements for the WAL logs are met, and that any necessary tuning is done (see &lt;a href=&quot;wal-configuration&quot;&gt;Section 29.4&lt;/a&gt;).</source>
          <target state="translated">WAL自动启用；除了确保满足WAL日志的磁盘空间要求并已进行任何必要的调整（请参阅&lt;a href=&quot;wal-configuration&quot;&gt;第29.4节&lt;/a&gt;）外，管理员无需执行任何操作。</target>
        </trans-unit>
        <trans-unit id="c356b4888573bfd6af6c126f717a43c96a7d21b4" translate="yes" xml:space="preserve">
          <source>WAL location at which to start reading. The default is to start reading the first valid log record found in the earliest file found.</source>
          <target state="translated">开始读取的WAL位置。默认情况下,开始读取最早找到的文件中的第一条有效日志记录。</target>
        </trans-unit>
        <trans-unit id="4873b80cfe4fe4ff618ed5cd62f9b47043675a98" translate="yes" xml:space="preserve">
          <source>WAL logs are stored in the directory &lt;code&gt;pg_wal&lt;/code&gt; under the data directory, as a set of segment files, normally each 16 MB in size (but the size can be changed by altering the &lt;code&gt;--wal-segsize&lt;/code&gt; initdb option). Each segment is divided into pages, normally 8 kB each (this size can be changed via the &lt;code&gt;--with-wal-blocksize&lt;/code&gt; configure option). The log record headers are described in &lt;code&gt;access/xlogrecord.h&lt;/code&gt;; the record content is dependent on the type of event that is being logged. Segment files are given ever-increasing numbers as names, starting at &lt;code&gt;000000010000000000000000&lt;/code&gt;. The numbers do not wrap, but it will take a very, very long time to exhaust the available stock of numbers.</source>
          <target state="translated">WAL日志作为一组段文件存储在data目录下的 &lt;code&gt;pg_wal&lt;/code&gt; 目录中，通常每个文件的大小为16 MB（但可以通过更改 &lt;code&gt;--wal-segsize&lt;/code&gt; initdb选项来更改大小）。每个段均分为几页，通常每页8 kB（可通过 &lt;code&gt;--with-wal-blocksize&lt;/code&gt; 配置选项更改此大小）。日志记录头在 &lt;code&gt;access/xlogrecord.h&lt;/code&gt; 中描述；记录的内容取决于正在记录的事件的类型。段文件的名称越来越多，从 &lt;code&gt;000000010000000000000000&lt;/code&gt; 开始。数字不会自动换行，但是要耗尽可用的数字库存将需要非常非常长的时间。</target>
        </trans-unit>
        <trans-unit id="fce41bc59a921956886daa163cc3371dfbffcdb7" translate="yes" xml:space="preserve">
          <source>WAL logs are stored in the directory &lt;code&gt;pg_wal&lt;/code&gt; under the data directory, as a set of segment files, normally each 16 MB in size (but the size can be changed by altering the &lt;code&gt;--wal-segsize&lt;/code&gt; initdb option). Each segment is divided into pages, normally 8 kB each (this size can be changed via the &lt;code&gt;--with-wal-blocksize&lt;/code&gt; configure option). The log record headers are described in &lt;code&gt;access/xlogrecord.h&lt;/code&gt;; the record content is dependent on the type of event that is being logged. Segment files are given ever-increasing numbers as names, starting at &lt;code&gt;000000010000000000000001&lt;/code&gt;. The numbers do not wrap, but it will take a very, very long time to exhaust the available stock of numbers.</source>
          <target state="translated">WAL日志作为一组段文件存储在data目录下的 &lt;code&gt;pg_wal&lt;/code&gt; 目录中，通常每个文件大小为16 MB（但可以通过更改 &lt;code&gt;--wal-segsize&lt;/code&gt; initdb选项来更改大小）。每个段均分为几页，通常每页8 kB（可通过 &lt;code&gt;--with-wal-blocksize&lt;/code&gt; 配置选项更改此大小）。日志记录头在 &lt;code&gt;access/xlogrecord.h&lt;/code&gt; 中描述；记录的内容取决于正在记录的事件的类型。段文件的名称越来越多，从 &lt;code&gt;000000010000000000000001&lt;/code&gt; 开始。这些数字不会自动换行，但是要耗尽可用的数字库存将需要非常非常长的时间。</target>
        </trans-unit>
        <trans-unit id="f9cabc60b441504c082bc1d5bf727636abc5fa64" translate="yes" xml:space="preserve">
          <source>WAL record</source>
          <target state="translated">WAL记录</target>
        </trans-unit>
        <trans-unit id="5fa55cdd1f960e02b270cbf81d5d051cfdadab50" translate="yes" xml:space="preserve">
          <source>WAL record construction can be canceled between any of the above steps by calling &lt;code&gt;GenericXLogAbort(state)&lt;/code&gt;. This will discard all changes to the page image copies.</source>
          <target state="translated">可以通过调用 &lt;code&gt;GenericXLogAbort(state)&lt;/code&gt; 取消上述任何步骤之间的WAL记录构造。这将放弃对页面图像副本的所有更改。</target>
        </trans-unit>
        <trans-unit id="ec0756aa72f12460643a103d61be69d319455e3e" translate="yes" xml:space="preserve">
          <source>WAL records are appended to the WAL logs as each new record is written. The insert position is described by a Log Sequence Number (LSN) that is a byte offset into the logs, increasing monotonically with each new record. LSN values are returned as the datatype &lt;a href=&quot;datatype-pg-lsn&quot;&gt;&lt;code&gt;pg_lsn&lt;/code&gt;&lt;/a&gt;. Values can be compared to calculate the volume of WAL data that separates them, so they are used to measure the progress of replication and recovery.</source>
          <target state="translated">在写入每个新记录时，WAL记录将附加到WAL日志中。插入位置由日志序列号（LSN）描述，该序列号是日志中的字节偏移量，随每个新记录单调增加。LSN值作为数据类型&lt;a href=&quot;datatype-pg-lsn&quot;&gt; &lt;code&gt;pg_lsn&lt;/code&gt; &lt;/a&gt;返回。可以比较这些值以计算将它们分开的WAL数据量，因此可以将它们用于衡量复制和恢复的进度。</target>
        </trans-unit>
        <trans-unit id="d60f7a41c7594f9d60365bb80cc500438858f049" translate="yes" xml:space="preserve">
          <source>WAL segment</source>
          <target state="translated">WAL部分</target>
        </trans-unit>
        <trans-unit id="85207d0ebcdb97d98e8f6e4d0d99438888bd2967" translate="yes" xml:space="preserve">
          <source>WAL segments that cannot be found in the archive will be sought in &lt;code&gt;pg_wal/&lt;/code&gt;; this allows use of recent un-archived segments. However, segments that are available from the archive will be used in preference to files in &lt;code&gt;pg_wal/&lt;/code&gt;.</source>
          <target state="translated">在档案中找不到的WAL段将在 &lt;code&gt;pg_wal/&lt;/code&gt; 中查找；这允许使用最近未归档的段。但是，归档中可用的段将优先于 &lt;code&gt;pg_wal/&lt;/code&gt; 文件使用。</target>
        </trans-unit>
        <trans-unit id="a848a0c06549fd9cb5d11422d342ef502df6d940" translate="yes" xml:space="preserve">
          <source>WAL writer (process)</source>
          <target state="translated">WAL作家(进程)</target>
        </trans-unit>
        <trans-unit id="670936924f36e223ed7101a5577c1a95fc54d46f" translate="yes" xml:space="preserve">
          <source>WIDE Project</source>
          <target state="translated">WIDE项目</target>
        </trans-unit>
        <trans-unit id="0c238a027f49a7325c81b6fcad74df656598a8d1" translate="yes" xml:space="preserve">
          <source>WITH Queries</source>
          <target state="translated">与查询</target>
        </trans-unit>
        <trans-unit id="62c72223105cadaf945f1907d7cca51ac5e11a9a" translate="yes" xml:space="preserve">
          <source>WITH Queries: Data-Modifying Statements in WITH</source>
          <target state="translated">WITH查询。在WITH中修改数据的语句</target>
        </trans-unit>
        <trans-unit id="81a33ebe9b068dc28117b34d20aebb31ffcc15d4" translate="yes" xml:space="preserve">
          <source>WITH Queries: SELECT in WITH</source>
          <target state="translated">WITH查询。SELECT中的WITH</target>
        </trans-unit>
        <trans-unit id="b3c1b6ed1901fdc76c7650d703ade5c43c418ba9" translate="yes" xml:space="preserve">
          <source>Wait Event Name</source>
          <target state="translated">等待事件名称</target>
        </trans-unit>
        <trans-unit id="cfecc9a9e7dbc0650b752c6d733646645d5d3acd" translate="yes" xml:space="preserve">
          <source>Wait Event Type</source>
          <target state="translated">等待事件类型</target>
        </trans-unit>
        <trans-unit id="b1541ea954698c8eaec6697e4064951737b7ac58" translate="yes" xml:space="preserve">
          <source>Wait event name if backend is currently waiting, otherwise NULL. See &lt;a href=&quot;monitoring-stats#WAIT-EVENT-ACTIVITY-TABLE&quot;&gt;Table 27.5&lt;/a&gt; through &lt;a href=&quot;monitoring-stats#WAIT-EVENT-TIMEOUT-TABLE&quot;&gt;Table 27.13&lt;/a&gt;.</source>
          <target state="translated">如果后端当前正在等待，则等待事件名称，否则为NULL。请参阅&lt;a href=&quot;monitoring-stats#WAIT-EVENT-ACTIVITY-TABLE&quot;&gt;表27.5&lt;/a&gt;通过&lt;a href=&quot;monitoring-stats#WAIT-EVENT-TIMEOUT-TABLE&quot;&gt;表27.13&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7d1dd06a2c6e4048cfa872860c567be1efcd7c2b" translate="yes" xml:space="preserve">
          <source>Wait event name if backend is currently waiting, otherwise NULL. See &lt;a href=&quot;monitoring-stats#WAIT-EVENT-TABLE&quot;&gt;Table 27.4&lt;/a&gt; for details.</source>
          <target state="translated">如果后端当前正在等待，则等待事件名称，否则为NULL。有关详细信息，请&lt;a href=&quot;monitoring-stats#WAIT-EVENT-TABLE&quot;&gt;参见表27.4&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e0d176395064480d6a06595b0b0b2f5082eb7376" translate="yes" xml:space="preserve">
          <source>Wait event type name if backend is currently waiting, otherwise NULL. See &lt;a href=&quot;monitoring-stats#WAIT-EVENT-TABLE&quot;&gt;Table 27.4&lt;/a&gt; for details.</source>
          <target state="translated">如果后端当前正在等待，则等待事件类型名称，否则为NULL。有关详细信息，请&lt;a href=&quot;monitoring-stats#WAIT-EVENT-TABLE&quot;&gt;参见表27.4&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d814f74425edb745c0f36dde73fdb494bc74e548" translate="yes" xml:space="preserve">
          <source>Wait for the operation to complete. This is supported for the modes &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;, &lt;code&gt;restart&lt;/code&gt;, &lt;code&gt;promote&lt;/code&gt;, and &lt;code&gt;register&lt;/code&gt;, and is the default for those modes.</source>
          <target state="translated">等待操作完成。 &lt;code&gt;start&lt;/code&gt; ， &lt;code&gt;stop&lt;/code&gt; ， &lt;code&gt;restart&lt;/code&gt; ， &lt;code&gt;promote&lt;/code&gt; 和 &lt;code&gt;register&lt;/code&gt; 模式都支持此模式，这是这些模式的默认模式。</target>
        </trans-unit>
        <trans-unit id="dd618adedec17e6469d06a5651fc5072c2cb8b33" translate="yes" xml:space="preserve">
          <source>Waiting a new WAL segment created by copying an existing one to reach stable storage.</source>
          <target state="translated">等待一个通过复制现有的WAL段创建的新WAL段达到稳定的存储。</target>
        </trans-unit>
        <trans-unit id="d1f87abf987753c903a49d1bd2c679d42224c9ed" translate="yes" xml:space="preserve">
          <source>Waiting due to a call to &lt;code&gt;pg_sleep&lt;/code&gt; or a sibling function.</source>
          <target state="translated">由于调用 &lt;code&gt;pg_sleep&lt;/code&gt; 或同级函数而等待。</target>
        </trans-unit>
        <trans-unit id="7b263c588c8a9b03696257b8f7a21247383c1982" translate="yes" xml:space="preserve">
          <source>Waiting during base backup when throttling activity.</source>
          <target state="translated">节流活动时,在基地备份期间等待。</target>
        </trans-unit>
        <trans-unit id="af48f8ee80431258cbd39e7f8a24022d589cd2d4" translate="yes" xml:space="preserve">
          <source>Waiting during recovery when WAL data is not available from any source (&lt;code&gt;pg_wal&lt;/code&gt;, archive or stream).</source>
          <target state="translated">当无法从任何来源（ &lt;code&gt;pg_wal&lt;/code&gt; ，档案或流）获得WAL数据时，在恢复期间等待。</target>
        </trans-unit>
        <trans-unit id="d62ddea7d6b1ce8c2e8479d95982f02c6ba59204" translate="yes" xml:space="preserve">
          <source>Waiting for I/O a subtransaction buffer.</source>
          <target state="translated">等待I/O一个子事务缓冲区。</target>
        </trans-unit>
        <trans-unit id="b41198be2ca46788de05f6339f5abc58ad97837a" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a &lt;code&gt;NOTIFY&lt;/code&gt; message SLRU buffer.</source>
          <target state="translated">在 &lt;code&gt;NOTIFY&lt;/code&gt; 消息SLRU缓冲区上等待I / O。</target>
        </trans-unit>
        <trans-unit id="10b267052de8e5af8879f9629c8e82adc667c91f" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a clog (transaction status) buffer.</source>
          <target state="translated">在堵塞(事务状态)缓冲区上等待I/O。</target>
        </trans-unit>
        <trans-unit id="e58154eef4dbe4cc36348aa199353c80f25bfc90" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a commit timestamp SLRU buffer.</source>
          <target state="translated">在提交时间戳SLRU缓冲区上等待I/O。</target>
        </trans-unit>
        <trans-unit id="8bbc9325a896b8fd7a70abd45c23e5faa43a813b" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a data page.</source>
          <target state="translated">在数据页上等待I/O。</target>
        </trans-unit>
        <trans-unit id="b97519258b555ff83c2d8f7537b4d0c3849dc3b0" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a multixact member SLRU buffer.</source>
          <target state="translated">等待多act成员SLRU缓冲区的I/O。</target>
        </trans-unit>
        <trans-unit id="5520e2be332ddadef5e822360efad62eedfb3753" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a multixact offset SLRU buffer.</source>
          <target state="translated">等待多精确偏移SLRU缓冲区的I/O。</target>
        </trans-unit>
        <trans-unit id="8a704e423e485baf39382a4b61985268bdbe9816" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a multixact offset buffer.</source>
          <target state="translated">在多重精确偏移缓冲区上等待I/O。</target>
        </trans-unit>
        <trans-unit id="567d45c24a3c7adfee8a01424ebb678b04e38b31" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a multixact_member buffer.</source>
          <target state="translated">在 multixact_member 缓冲区上等待 I/O。</target>
        </trans-unit>
        <trans-unit id="f5580fedd445b2fc16dfac5701d5e862d784f551" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a replication slot.</source>
          <target state="translated">在复制槽上等待I/O。</target>
        </trans-unit>
        <trans-unit id="e6bc836d70082711faa785a87bbd568bb40a26f2" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a serializable transaction conflict SLRU buffer.</source>
          <target state="translated">在可序列化事务冲突SLRU缓冲区上等待I/O。</target>
        </trans-unit>
        <trans-unit id="3cf608c43f24f0741708f464c3bfab6ed45555c1" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a sub-transaction SLRU buffer.</source>
          <target state="translated">在子事务SLRU缓冲区上等待I/O。</target>
        </trans-unit>
        <trans-unit id="e164de805b3886359f5010f6a7deb581bdf00ae0" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a transaction status SLRU buffer.</source>
          <target state="translated">在事务状态SLRU缓冲区上等待I/O。</target>
        </trans-unit>
        <trans-unit id="8eda0ee8cd8803033853db58b70b41cefa970a11" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on an async (notify) buffer.</source>
          <target state="translated">在异步(通知)缓冲区上等待I/O。</target>
        </trans-unit>
        <trans-unit id="abba94e34c19d07b07ce80f08b906e7d03736163" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on an oldserxid buffer.</source>
          <target state="translated">在oldserxid缓冲区上等待I/O。</target>
        </trans-unit>
        <trans-unit id="89be09a6258d69b36b9e65eae64f0556be147bdd" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on commit timestamp buffer.</source>
          <target state="translated">等待提交时间戳缓冲区的I/O。</target>
        </trans-unit>
        <trans-unit id="785bfc0b8ad80cb03e1bb84a54b286b13aa0651d" translate="yes" xml:space="preserve">
          <source>Waiting for SLRU data to reach durable storage during a checkpoint or database shutdown.</source>
          <target state="translated">在检查点或数据库关闭期间,等待SLRU数据到达持久存储。</target>
        </trans-unit>
        <trans-unit id="003d2dd01b2593677f27df1a51eb75521d66a25d" translate="yes" xml:space="preserve">
          <source>Waiting for SLRU data to reach durable storage following a page write.</source>
          <target state="translated">等待SLRU数据在页面写入后到达持久存储。</target>
        </trans-unit>
        <trans-unit id="da4c5fd8e7b43af2a409040c541ebf56ba090a42" translate="yes" xml:space="preserve">
          <source>Waiting for SLRU data to reach stable storage during a checkpoint or database shutdown.</source>
          <target state="translated">在检查点或数据库关闭期间,等待SLRU数据达到稳定存储。</target>
        </trans-unit>
        <trans-unit id="a795b2d3551897df90d4dc06b1de18f13711e4ef" translate="yes" xml:space="preserve">
          <source>Waiting for SLRU data to reach stable storage following a page write.</source>
          <target state="translated">等待SLRU数据在页面写入后达到稳定存储。</target>
        </trans-unit>
        <trans-unit id="3f43eca07331b8b4d48d83deb11f1187e3222c57" translate="yes" xml:space="preserve">
          <source>Waiting for SSL while attempting connection.</source>
          <target state="translated">试图连接时等待SSL。</target>
        </trans-unit>
        <trans-unit id="cea499b505dfbcd4c53729e4e78e2f60a5e0dfa9" translate="yes" xml:space="preserve">
          <source>Waiting for TBM shared iterator lock.</source>
          <target state="translated">等待TBM共享迭代器锁。</target>
        </trans-unit>
        <trans-unit id="28f5fe1f96a90cf6f89027f31d1f8fff440aadd4" translate="yes" xml:space="preserve">
          <source>Waiting for WAL buffers to be written to disk.</source>
          <target state="translated">等待WAL缓冲区写入磁盘。</target>
        </trans-unit>
        <trans-unit id="984062f9c9b976e8df42046bfd109717db60ade5" translate="yes" xml:space="preserve">
          <source>Waiting for WAL files required for a backup to be successfully archived.</source>
          <target state="translated">等待备份所需的WAL文件成功归档。</target>
        </trans-unit>
        <trans-unit id="e5f443781f65a70ffb9eadd8d00b62bec73ed570" translate="yes" xml:space="preserve">
          <source>Waiting for WAL from a stream at recovery.</source>
          <target state="translated">在恢复时等待来自流的WAL。</target>
        </trans-unit>
        <trans-unit id="ce0b3cbfc2a21133aecfeb0025076a64608b1920" translate="yes" xml:space="preserve">
          <source>Waiting for WAL from any kind of source (local, archive or stream) at recovery.</source>
          <target state="translated">在恢复时等待来自任何来源(本地、存档或流)的WAL。</target>
        </trans-unit>
        <trans-unit id="c3d04b47f170d0a017b5a8840ab7fd732b861077" translate="yes" xml:space="preserve">
          <source>Waiting for WAL to be flushed in WAL sender process.</source>
          <target state="translated">在WAL发送过程中等待WAL刷新。</target>
        </trans-unit>
        <trans-unit id="f4a5e554d691351f284f09d8db7f55190422b270" translate="yes" xml:space="preserve">
          <source>Waiting for WAL to reach durable storage during bootstrapping.</source>
          <target state="translated">等待WAL在引导过程中达到耐用的存储。</target>
        </trans-unit>
        <trans-unit id="35934124d45c41b66cac20041da4f7acc6c09234" translate="yes" xml:space="preserve">
          <source>Waiting for WAL to reach stable storage during bootstrapping.</source>
          <target state="translated">在引导过程中等待WAL达到稳定的存储。</target>
        </trans-unit>
        <trans-unit id="b82237d07a68b8fa940123851d375627fb31efe7" translate="yes" xml:space="preserve">
          <source>Waiting for a WAL file to reach durable storage.</source>
          <target state="translated">等候WAL文件到达耐用的贮存。</target>
        </trans-unit>
        <trans-unit id="2347bde945d2a1ac488cc00b97f03eb25edf886c" translate="yes" xml:space="preserve">
          <source>Waiting for a WAL file to reach stable storage.</source>
          <target state="translated">等待WAL文件达到稳定存储。</target>
        </trans-unit>
        <trans-unit id="52ca09d978f55744184f7d9cdb893379dab55dfe" translate="yes" xml:space="preserve">
          <source>Waiting for a barrier event to be processed by all backends.</source>
          <target state="translated">等待所有后端处理障碍事件。</target>
        </trans-unit>
        <trans-unit id="b64554949a794fe8845162525251d4f832f615ae" translate="yes" xml:space="preserve">
          <source>Waiting for a checkpoint to complete.</source>
          <target state="translated">等待检查点完成。</target>
        </trans-unit>
        <trans-unit id="fbe85ec49696086b315ad919340a19fe4137e208" translate="yes" xml:space="preserve">
          <source>Waiting for a checkpoint to start.</source>
          <target state="translated">等待检查点开始。</target>
        </trans-unit>
        <trans-unit id="318c8efea6418e0ce484fc89483b1eb1ff78690d" translate="yes" xml:space="preserve">
          <source>Waiting for a logical replication remote server to change state.</source>
          <target state="translated">等待逻辑复制远程服务器改变状态。</target>
        </trans-unit>
        <trans-unit id="9be1a8f95aa3da64fa571808ebb5f548539f1390" translate="yes" xml:space="preserve">
          <source>Waiting for a logical replication remote server to send data for initial table synchronization.</source>
          <target state="translated">等待逻辑复制远程服务器发送数据进行初始表同步。</target>
        </trans-unit>
        <trans-unit id="d59d3373d5959bbfb7f16fd5cf3905eaaca00840" translate="yes" xml:space="preserve">
          <source>Waiting for a new WAL segment created by copying an existing one to reach durable storage.</source>
          <target state="translated">等待通过复制现有的WAL段创建的新的WAL段到达持久存储。</target>
        </trans-unit>
        <trans-unit id="bdee33be52627bad37addf1e4cb4de672175760f" translate="yes" xml:space="preserve">
          <source>Waiting for a newly created timeline history file to reach durable storage.</source>
          <target state="translated">等待新创建的时间线历史文件到达持久存储。</target>
        </trans-unit>
        <trans-unit id="a86020a20952ecd2adfecfb302ee0a5d59b93de9" translate="yes" xml:space="preserve">
          <source>Waiting for a newly created timeline history file to reach stable storage.</source>
          <target state="translated">等待新创建的时间线历史文件达到稳定存储。</target>
        </trans-unit>
        <trans-unit id="b0cdef84441eaddf22ea692b65eccf4c082d170e" translate="yes" xml:space="preserve">
          <source>Waiting for a newly initialized WAL file to reach durable storage.</source>
          <target state="translated">等待新初始化的WAL文件到达持久存储。</target>
        </trans-unit>
        <trans-unit id="6fe40708f510b2425a56df962113c332035d1ebb" translate="yes" xml:space="preserve">
          <source>Waiting for a newly initialized WAL file to reach stable storage.</source>
          <target state="translated">等待一个新初始化的WAL文件达到稳定的存储。</target>
        </trans-unit>
        <trans-unit id="a99635b6aefa182932d6d8ac35e0fadee6f58362" translate="yes" xml:space="preserve">
          <source>Waiting for a read during a file copy operation.</source>
          <target state="translated">在文件复制操作中等待读取。</target>
        </trans-unit>
        <trans-unit id="1b1c7ee0bc940e8ff954a9dc21e088de25e160e7" translate="yes" xml:space="preserve">
          <source>Waiting for a read during recheck of the data directory lock file.</source>
          <target state="translated">在重新检查数据目录锁文件时,等待读取。</target>
        </trans-unit>
        <trans-unit id="9ae33919f01ffd845bcfe367fc1ce42274883982" translate="yes" xml:space="preserve">
          <source>Waiting for a read during reorder buffer management.</source>
          <target state="translated">在重新排序缓冲区管理期间,等待读取。</target>
        </trans-unit>
        <trans-unit id="21b0b22bdd6995f4c8facc815a7958bc78a4df11" translate="yes" xml:space="preserve">
          <source>Waiting for a read from a WAL file.</source>
          <target state="translated">等待WAL文件的读取。</target>
        </trans-unit>
        <trans-unit id="7c0a57a09d41e3dd4b6c43069589a550983cdfbc" translate="yes" xml:space="preserve">
          <source>Waiting for a read from a buffered file.</source>
          <target state="translated">等待从缓冲文件中读取。</target>
        </trans-unit>
        <trans-unit id="9d7f43727962110ab0f659fc3569b92c09e1e4c3" translate="yes" xml:space="preserve">
          <source>Waiting for a read from a relation data file.</source>
          <target state="translated">等待从关系数据文件读取。</target>
        </trans-unit>
        <trans-unit id="b5434d2dc36bc6e479cf33762dac4cdbbad013ab" translate="yes" xml:space="preserve">
          <source>Waiting for a read from a replication slot control file.</source>
          <target state="translated">等待复制槽控制文件的读取。</target>
        </trans-unit>
        <trans-unit id="d17e29530adb24a2c7484307af3bcddda11a2aae" translate="yes" xml:space="preserve">
          <source>Waiting for a read from a timeline history file during a walsender timeline command.</source>
          <target state="translated">在walsender时间轴命令期间,等待从时间轴历史文件读取。</target>
        </trans-unit>
        <trans-unit id="0d8e0677108348e6cb25c6439df96979d79370b4" translate="yes" xml:space="preserve">
          <source>Waiting for a read from a timeline history file during walsender timeline command.</source>
          <target state="translated">在walsender时间轴命令中等待从时间轴历史文件中读取。</target>
        </trans-unit>
        <trans-unit id="b83f25adf4d23330ec82b288f382bbfe80bca47f" translate="yes" xml:space="preserve">
          <source>Waiting for a read from the &lt;code&gt;pg_control&lt;/code&gt; file.</source>
          <target state="translated">等待从 &lt;code&gt;pg_control&lt;/code&gt; 文件读取。</target>
        </trans-unit>
        <trans-unit id="bb87f9075b737550478460fe92ea81d5a8e44f1b" translate="yes" xml:space="preserve">
          <source>Waiting for a read from the control file.</source>
          <target state="translated">等待控制文件的读取。</target>
        </trans-unit>
        <trans-unit id="b13a29b976f4d9243fad247169f0d2821ffe4aa3" translate="yes" xml:space="preserve">
          <source>Waiting for a read of a logical mapping during reorder buffer management.</source>
          <target state="translated">在重排序缓冲区管理过程中,等待逻辑映射的读取。</target>
        </trans-unit>
        <trans-unit id="94303f5f840422428a360dcb8cf874ed8d7188d8" translate="yes" xml:space="preserve">
          <source>Waiting for a read of a serialized historical catalog snapshot.</source>
          <target state="translated">等待读取一个系列化的历史目录快照。</target>
        </trans-unit>
        <trans-unit id="2ab04c92d0fda0e18fe65ce97ed4f4a6278c8bda" translate="yes" xml:space="preserve">
          <source>Waiting for a read of a timeline history file.</source>
          <target state="translated">等待读取时间线历史文件。</target>
        </trans-unit>
        <trans-unit id="c0e334fe7275467445ed31f445bb0d89fc42ea11" translate="yes" xml:space="preserve">
          <source>Waiting for a read of a two phase state file.</source>
          <target state="translated">等待两相状态文件的读取。</target>
        </trans-unit>
        <trans-unit id="24f5541db52af4f2f83a5aff926cb570ad37ea9a" translate="yes" xml:space="preserve">
          <source>Waiting for a read of an SLRU page.</source>
          <target state="translated">等待一个SLRU页面的阅读。</target>
        </trans-unit>
        <trans-unit id="ab3bd50798c846431f5c99cd295ac155af5c3628" translate="yes" xml:space="preserve">
          <source>Waiting for a read of the relation map file.</source>
          <target state="translated">等待关系图文件的读取。</target>
        </trans-unit>
        <trans-unit id="653fed415a1560b6108907354641e1d02603af7f" translate="yes" xml:space="preserve">
          <source>Waiting for a read when creating a new WAL segment by copying an existing one.</source>
          <target state="translated">通过复制现有的WAL段创建新的WAL段时,正在等待读取。</target>
        </trans-unit>
        <trans-unit id="8b50fdc4779713a2250434752ac096729a9b9e3d" translate="yes" xml:space="preserve">
          <source>Waiting for a read while adding a line to the data directory lock file.</source>
          <target state="translated">等待读取,同时在数据目录锁文件中添加一行。</target>
        </trans-unit>
        <trans-unit id="764d5f916fab0f4117b0be0cbd2e731f54a839fb" translate="yes" xml:space="preserve">
          <source>Waiting for a relation data file to be extended.</source>
          <target state="translated">等待关系数据文件的扩展。</target>
        </trans-unit>
        <trans-unit id="2d4550cc931e0694f7888372505856f6d3c09005" translate="yes" xml:space="preserve">
          <source>Waiting for a relation data file to be truncated.</source>
          <target state="translated">等待关系数据文件被截断。</target>
        </trans-unit>
        <trans-unit id="56656077995a3c3ccd9b20b71affc54ffa5f3b73" translate="yes" xml:space="preserve">
          <source>Waiting for a relation data file to reach durable storage.</source>
          <target state="translated">等待关系数据文件到达持久存储。</target>
        </trans-unit>
        <trans-unit id="196784ad8df1886187ea3f9758445468708682d5" translate="yes" xml:space="preserve">
          <source>Waiting for a relation data file to reach stable storage.</source>
          <target state="translated">等待关系数据文件达到稳定存储。</target>
        </trans-unit>
        <trans-unit id="e193dd315e3b35e9bfde686ab2df07cc942ef67f" translate="yes" xml:space="preserve">
          <source>Waiting for a replication origin to become inactive so it can be dropped.</source>
          <target state="translated">等待复制原点变得不活跃,以便可以放弃。</target>
        </trans-unit>
        <trans-unit id="2c6dd21f72774436bf4201a14e0bef224865f318" translate="yes" xml:space="preserve">
          <source>Waiting for a replication origin to become inactive to be dropped.</source>
          <target state="translated">等到复制原点不活跃就会被丢弃。</target>
        </trans-unit>
        <trans-unit id="a2c385c9c429e881d994641cd053fdd40d599ca4" translate="yes" xml:space="preserve">
          <source>Waiting for a replication slot control file to reach durable storage while restoring it to memory.</source>
          <target state="translated">等待复制槽控制文件到达持久存储,同时将其恢复到内存。</target>
        </trans-unit>
        <trans-unit id="933e401eade88c4d239f909f0d7a24552c57d2a6" translate="yes" xml:space="preserve">
          <source>Waiting for a replication slot control file to reach durable storage.</source>
          <target state="translated">等待复制槽控制文件到达持久存储。</target>
        </trans-unit>
        <trans-unit id="51efea4b8a37a030875e22581e67a71b2c0b921b" translate="yes" xml:space="preserve">
          <source>Waiting for a replication slot control file to reach stable storage while restoring it to memory.</source>
          <target state="translated">等待复制槽控制文件达到稳定存储,同时将其恢复到内存。</target>
        </trans-unit>
        <trans-unit id="3360d7e3a23f4e402f25182926d976cf44db39f3" translate="yes" xml:space="preserve">
          <source>Waiting for a replication slot control file to reach stable storage.</source>
          <target state="translated">等待复制槽控制文件达到稳定存储。</target>
        </trans-unit>
        <trans-unit id="494ade39222b8fb62d122bed2c1029dcb97e4b7f" translate="yes" xml:space="preserve">
          <source>Waiting for a replication slot to become inactive so it can be dropped.</source>
          <target state="translated">等待复制槽变得不活跃,以便可以放弃。</target>
        </trans-unit>
        <trans-unit id="199501dcba57d5c5271ac74b95e191bf236cb733" translate="yes" xml:space="preserve">
          <source>Waiting for a replication slot to become inactive to be dropped.</source>
          <target state="translated">等待复制槽的不活跃被丢弃。</target>
        </trans-unit>
        <trans-unit id="6e324c985d50a900618f8748e92b810be7e79671" translate="yes" xml:space="preserve">
          <source>Waiting for a serialized historical catalog snapshot to reach durable storage.</source>
          <target state="translated">等待序列化的历史目录快照达到持久存储。</target>
        </trans-unit>
        <trans-unit id="863f50afd3c1563b85fb65b1a42b5b1ae705dfb7" translate="yes" xml:space="preserve">
          <source>Waiting for a serialized historical catalog snapshot to reach stable storage.</source>
          <target state="translated">等待序列化的历史目录快照达到稳定存储。</target>
        </trans-unit>
        <trans-unit id="b66c979e7938ef913ce663fc865d33095c21de87" translate="yes" xml:space="preserve">
          <source>Waiting for a snapshot for a &lt;code&gt;READ ONLY DEFERRABLE&lt;/code&gt; transaction.</source>
          <target state="translated">等待快照以进行 &lt;code&gt;READ ONLY DEFERRABLE&lt;/code&gt; 事务。</target>
        </trans-unit>
        <trans-unit id="111cfd0a418a3a5087e98e0082a0895f0e94e2f0" translate="yes" xml:space="preserve">
          <source>Waiting for a timeline history file received via streaming replication to reach durable storage.</source>
          <target state="translated">等待通过流式复制接收的时间线历史文件到达持久存储。</target>
        </trans-unit>
        <trans-unit id="e483dd61b2e17583a1594dcda6e591f3ac3e513f" translate="yes" xml:space="preserve">
          <source>Waiting for a timeline history file received via streaming replication to reach stable storage.</source>
          <target state="translated">等待通过流式复制接收到的时间线历史文件达到稳定存储。</target>
        </trans-unit>
        <trans-unit id="2853dc0fde120da340c58317ae296218c97a1c94" translate="yes" xml:space="preserve">
          <source>Waiting for a transaction to finish.</source>
          <target state="translated">等待交易完成。</target>
        </trans-unit>
        <trans-unit id="e24c900a389bc0f02e97f81a8ce41fbab7e291af" translate="yes" xml:space="preserve">
          <source>Waiting for a two phase state file to reach durable storage.</source>
          <target state="translated">等待两阶段状态文件达到持久存储。</target>
        </trans-unit>
        <trans-unit id="157ed476e7697e7a1cadb6976248a98472434e0a" translate="yes" xml:space="preserve">
          <source>Waiting for a two phase state file to reach stable storage.</source>
          <target state="translated">等待两相状态文件达到稳定存储。</target>
        </trans-unit>
        <trans-unit id="85a6ffd0d68eb37b547774e0919378d07b939300" translate="yes" xml:space="preserve">
          <source>Waiting for a write during a file copy operation.</source>
          <target state="translated">在文件复制操作中等待写。</target>
        </trans-unit>
        <trans-unit id="32492adb76e65f3fe0a6e72f8951521baef55fec" translate="yes" xml:space="preserve">
          <source>Waiting for a write during reorder buffer management.</source>
          <target state="translated">在重新排序缓冲区管理期间,等待写。</target>
        </trans-unit>
        <trans-unit id="ba450cd205c3dd8e5640b537d57ff27410f1253d" translate="yes" xml:space="preserve">
          <source>Waiting for a write of a WAL page during bootstrapping.</source>
          <target state="translated">在引导过程中等待WAL页面的写入。</target>
        </trans-unit>
        <trans-unit id="8705f070fa23d795eb616cd9e31b50566ca67cc3" translate="yes" xml:space="preserve">
          <source>Waiting for a write of a newly created timeline history file.</source>
          <target state="translated">等待新创建的时间轴历史文件的写入。</target>
        </trans-unit>
        <trans-unit id="8d1760404310ebeadc931ff2c4124968d47b107a" translate="yes" xml:space="preserve">
          <source>Waiting for a write of a serialized historical catalog snapshot.</source>
          <target state="translated">等待连载历史目录快照的写入。</target>
        </trans-unit>
        <trans-unit id="b37297f957be6d38118691421e743bea3d403b7c" translate="yes" xml:space="preserve">
          <source>Waiting for a write of a timeline history file received via streaming replication.</source>
          <target state="translated">等待通过流式复制接收到的时间线历史文件的写入。</target>
        </trans-unit>
        <trans-unit id="be49d8c0c1b4685519fdd85850348ecd44be9749" translate="yes" xml:space="preserve">
          <source>Waiting for a write of a two phase state file.</source>
          <target state="translated">等待两相状态文件的写入。</target>
        </trans-unit>
        <trans-unit id="53aeb8cdb283bc1d47f777ad7b24ec161b846ee7" translate="yes" xml:space="preserve">
          <source>Waiting for a write of an SLRU page.</source>
          <target state="translated">等着写一个SLRU的页面。</target>
        </trans-unit>
        <trans-unit id="1465353979b7faf0b115892be0b212bb41254cd5" translate="yes" xml:space="preserve">
          <source>Waiting for a write of logical rewrite mappings.</source>
          <target state="translated">等待逻辑重写映射的写入。</target>
        </trans-unit>
        <trans-unit id="262bd0eebb54ede821d500429e0af687cc713958" translate="yes" xml:space="preserve">
          <source>Waiting for a write of mapping data during a logical rewrite.</source>
          <target state="translated">在逻辑重写过程中,等待映射数据的写入。</target>
        </trans-unit>
        <trans-unit id="3b9bd51d9cae106255dd99b45134793e8fe5ca42" translate="yes" xml:space="preserve">
          <source>Waiting for a write to a WAL file.</source>
          <target state="translated">等待对WAL文件的写入。</target>
        </trans-unit>
        <trans-unit id="251086a074c439cbe743d7c3bb152d463c21bb7b" translate="yes" xml:space="preserve">
          <source>Waiting for a write to a buffered file.</source>
          <target state="translated">等待对缓冲文件的写入。</target>
        </trans-unit>
        <trans-unit id="8b47e588513cf133674bba56df9090d2883dd101" translate="yes" xml:space="preserve">
          <source>Waiting for a write to a relation data file.</source>
          <target state="translated">等待对关系数据文件的写入。</target>
        </trans-unit>
        <trans-unit id="299b50c23e70d2d279fbb4a9694963e890bfee88" translate="yes" xml:space="preserve">
          <source>Waiting for a write to a replication slot control file.</source>
          <target state="translated">等待对复制槽控制文件的写入。</target>
        </trans-unit>
        <trans-unit id="c78572013cf870b1d5b2f14bfe069a7a53092ec4" translate="yes" xml:space="preserve">
          <source>Waiting for a write to the &lt;code&gt;pg_control&lt;/code&gt; file.</source>
          <target state="translated">等待写入 &lt;code&gt;pg_control&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="f26411046b5f9c53b1644f439224f22b40020be7" translate="yes" xml:space="preserve">
          <source>Waiting for a write to the control file.</source>
          <target state="translated">等待对控制文件的写入。</target>
        </trans-unit>
        <trans-unit id="f75228f5ef22ab61abd11733484809e768dbf43c" translate="yes" xml:space="preserve">
          <source>Waiting for a write to the relation map file.</source>
          <target state="translated">等待对关系图文件的写入。</target>
        </trans-unit>
        <trans-unit id="49fdc5304647deaf1df0e95e8d9b82ecf63a8d41" translate="yes" xml:space="preserve">
          <source>Waiting for a write to update the &lt;code&gt;pg_control&lt;/code&gt; file.</source>
          <target state="translated">等待写更新 &lt;code&gt;pg_control&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="d4dc5be0a61a88b12bee2628ecf09d1b773c4c35" translate="yes" xml:space="preserve">
          <source>Waiting for a write to update the control file.</source>
          <target state="translated">等待写入更新控制文件。</target>
        </trans-unit>
        <trans-unit id="610d140534d98776f4ceaac82401a792839d1b45" translate="yes" xml:space="preserve">
          <source>Waiting for a write when creating a new WAL segment by copying an existing one.</source>
          <target state="translated">通过复制一个现有的WAL段来创建一个新的WAL段时,等待写入。</target>
        </trans-unit>
        <trans-unit id="e8e6f804ba2f5656426f9c3ccd5ba5ebd95a87d4" translate="yes" xml:space="preserve">
          <source>Waiting for a write while adding a line to the data directory lock file.</source>
          <target state="translated">在向数据目录锁文件添加一行时,等待写。</target>
        </trans-unit>
        <trans-unit id="0696197c3d3d4067137d8fe428f74da050d0c268" translate="yes" xml:space="preserve">
          <source>Waiting for a write while creating the data directory lock file.</source>
          <target state="translated">在创建数据目录锁文件时,等待写入。</target>
        </trans-unit>
        <trans-unit id="2fa5fc8fd5be1292b1cb40d3c83b93e702c367e3" translate="yes" xml:space="preserve">
          <source>Waiting for a write while initializing a new WAL file.</source>
          <target state="translated">在初始化一个新的WAL文件时,等待写。</target>
        </trans-unit>
        <trans-unit id="734b565bcfa5ca2fc97c773bf856a02689576213" translate="yes" xml:space="preserve">
          <source>Waiting for action on logical replication worker to finish.</source>
          <target state="translated">等待逻辑复制工的动作完成。</target>
        </trans-unit>
        <trans-unit id="d26e6e2627cb32e8a27e81f318db98a11e54cd12" translate="yes" xml:space="preserve">
          <source>Waiting for activity from a child process while executing a &lt;code&gt;Gather&lt;/code&gt; plan node.</source>
          <target state="translated">在执行&amp;ldquo; &lt;code&gt;Gather&lt;/code&gt; 计划节点时等待子进程的活动。</target>
        </trans-unit>
        <trans-unit id="a1613179ffe75070217dd36a5f12906b74afc2ab" translate="yes" xml:space="preserve">
          <source>Waiting for activity from child process when executing &lt;code&gt;Gather&lt;/code&gt; node.</source>
          <target state="translated">执行 &lt;code&gt;Gather&lt;/code&gt; 节点时，等待子进程的活动。</target>
        </trans-unit>
        <trans-unit id="6126b8aaccca6a7a91b7220ca50f325ae2373721" translate="yes" xml:space="preserve">
          <source>Waiting for an asynchronous prefetch from a relation data file.</source>
          <target state="translated">等待从关系数据文件中异步预取。</target>
        </trans-unit>
        <trans-unit id="7ceade57b19a1c5eb1845d4c821b850186cc2839" translate="yes" xml:space="preserve">
          <source>Waiting for an elected Parallel Hash participant to allocate a hash table.</source>
          <target state="translated">等待当选的Parallel Hash参与者分配一个哈希表。</target>
        </trans-unit>
        <trans-unit id="7ae35732e2bfced9301c45c422a5bb06a774ed38" translate="yes" xml:space="preserve">
          <source>Waiting for an elected Parallel Hash participant to allocate more batches.</source>
          <target state="translated">等待当选的Parallel Hash参与者分配更多的批次。</target>
        </trans-unit>
        <trans-unit id="fb366154c77101be0d76ea7c08df266aa7b65be9" translate="yes" xml:space="preserve">
          <source>Waiting for an elected Parallel Hash participant to allocate the initial hash table.</source>
          <target state="translated">等待当选的并行哈希参与者分配初始哈希表。</target>
        </trans-unit>
        <trans-unit id="7cf1c258cd35461c3f1727fa0a9eacebdd04769c" translate="yes" xml:space="preserve">
          <source>Waiting for an elected Parallel Hash participant to decide on future batch growth.</source>
          <target state="translated">等待当选的Parallel Hash参与者来决定未来的批量增长。</target>
        </trans-unit>
        <trans-unit id="07635fd669dda3c946a486e6f1b23b449441353e" translate="yes" xml:space="preserve">
          <source>Waiting for an elected Parallel Hash participant to finish allocating more buckets.</source>
          <target state="translated">等待当选的Parallel Hash参与者完成更多桶的分配。</target>
        </trans-unit>
        <trans-unit id="5801375733f68124f62514d2e4570d9207fd757f" translate="yes" xml:space="preserve">
          <source>Waiting for an immediate synchronization of a relation data file to durable storage.</source>
          <target state="translated">等待立即将关系数据文件同步到持久存储。</target>
        </trans-unit>
        <trans-unit id="4e246fb175c5f149773d0331209040875fd42182" translate="yes" xml:space="preserve">
          <source>Waiting for an immediate synchronization of a relation data file to stable storage.</source>
          <target state="translated">等待关系数据文件立即同步到稳定存储。</target>
        </trans-unit>
        <trans-unit id="7259a212cd02dc7285b0b4c7fac8d9b3dccce991" translate="yes" xml:space="preserve">
          <source>Waiting for an update to the &lt;code&gt;pg_control&lt;/code&gt; file to reach durable storage.</source>
          <target state="translated">等待对 &lt;code&gt;pg_control&lt;/code&gt; 文件的更新以达到持久存储。</target>
        </trans-unit>
        <trans-unit id="95d64a2fc217b281e035d77c750609359d54019d" translate="yes" xml:space="preserve">
          <source>Waiting for an update to the control file to reach stable storage.</source>
          <target state="translated">等待控制文件的更新,以达到稳定的存储。</target>
        </trans-unit>
        <trans-unit id="77a6d736fc930334f93ec4961120d3fbb33658a7" translate="yes" xml:space="preserve">
          <source>Waiting for another process to be attached to a shared message queue.</source>
          <target state="translated">等待另一个进程连接到共享消息队列。</target>
        </trans-unit>
        <trans-unit id="fcf18468a43ecee10b4dea21dad9d1ae0888b697" translate="yes" xml:space="preserve">
          <source>Waiting for any activity when processing replies from WAL receiver in WAL sender process.</source>
          <target state="translated">在WAL发送过程中处理WAL接收方的回复时,等待任何活动。</target>
        </trans-unit>
        <trans-unit id="27bad1ed6561f03baa1813e29bc1d6a9f97d039b" translate="yes" xml:space="preserve">
          <source>Waiting for background worker to shut down.</source>
          <target state="translated">等着背景工关闭。</target>
        </trans-unit>
        <trans-unit id="17b78b2404a9c8efe7417660102cb11bcbc99fa4" translate="yes" xml:space="preserve">
          <source>Waiting for background worker to start up.</source>
          <target state="translated">等待后台工作人员启动。</target>
        </trans-unit>
        <trans-unit id="1092cdc7eb9ee3391d3a4d79e4f2cbbadb7d2536" translate="yes" xml:space="preserve">
          <source>Waiting for changes to a relation data file to reach durable storage.</source>
          <target state="translated">等待关系数据文件的变化达到持久存储。</target>
        </trans-unit>
        <trans-unit id="121ce51ab6e249cf929aa9e0635dd5196c724d55" translate="yes" xml:space="preserve">
          <source>Waiting for changes to a relation data file to reach stable storage.</source>
          <target state="translated">等待关系数据文件的变化达到稳定存储。</target>
        </trans-unit>
        <trans-unit id="06baf37c4d00743bd8f1d4776619f21e41c7e849" translate="yes" xml:space="preserve">
          <source>Waiting for confirmation from a remote server during synchronous replication.</source>
          <target state="translated">在同步复制过程中,等待远程服务器的确认。</target>
        </trans-unit>
        <trans-unit id="7aedff25c55dbcd34ea828efe5df0cac10c04231" translate="yes" xml:space="preserve">
          <source>Waiting for confirmation from remote server during synchronous replication.</source>
          <target state="translated">在同步复制过程中,等待远程服务器的确认。</target>
        </trans-unit>
        <trans-unit id="06dd73106355257e55c5973700b35599b6ab2aa8" translate="yes" xml:space="preserve">
          <source>Waiting for data to reach durable storage while adding a line to the data directory lock file.</source>
          <target state="translated">等待数据到达持久存储,同时在数据目录锁文件中增加一行。</target>
        </trans-unit>
        <trans-unit id="bf1a2cd56f85be8ddf428ad8cd1741cd6c232ca4" translate="yes" xml:space="preserve">
          <source>Waiting for data to reach durable storage while assigning a new WAL sync method.</source>
          <target state="translated">在分配新的WAL同步方法的同时,等待数据到达持久存储。</target>
        </trans-unit>
        <trans-unit id="7393e0800215c6dc732cf1bd3e9c0f59b66e27cf" translate="yes" xml:space="preserve">
          <source>Waiting for data to reach durable storage while creating the data directory lock file.</source>
          <target state="translated">在创建数据目录锁文件的同时,等待数据到达持久存储。</target>
        </trans-unit>
        <trans-unit id="e096887a303519506fcd67516869ace11ad3e59e" translate="yes" xml:space="preserve">
          <source>Waiting for data to reach stable storage while adding a line to the data directory lock file.</source>
          <target state="translated">等待数据达到稳定存储,同时在数据目录锁文件中添加一行。</target>
        </trans-unit>
        <trans-unit id="fe0ab1a16e2329bfa52c27e76aa50ab788d415cf" translate="yes" xml:space="preserve">
          <source>Waiting for data to reach stable storage while assigning WAL sync method.</source>
          <target state="translated">等待数据达到稳定存储,同时分配WAL同步方式。</target>
        </trans-unit>
        <trans-unit id="0a67fcfeb93618a5687879b86795e36261b23961" translate="yes" xml:space="preserve">
          <source>Waiting for data to reach stable storage while creating the data directory lock file.</source>
          <target state="translated">等待数据达到稳定存储,同时创建数据目录锁文件。</target>
        </trans-unit>
        <trans-unit id="1f817023f7f1aeed83afe73b277506f04bbf5f51" translate="yes" xml:space="preserve">
          <source>Waiting for group leader to clear transaction id at transaction end.</source>
          <target state="translated">等待组长在交易结束时清除交易ID。</target>
        </trans-unit>
        <trans-unit id="9ad12c44c511affe8e5b28dfe797e5442cb69ba2" translate="yes" xml:space="preserve">
          <source>Waiting for group leader to update transaction status at transaction end.</source>
          <target state="translated">等待组长在交易结束时更新交易状态。</target>
        </trans-unit>
        <trans-unit id="6303bec3edc9303d1de1e17ffbef9d10deeb2ec7" translate="yes" xml:space="preserve">
          <source>Waiting for logical replication remote server to change state.</source>
          <target state="translated">等待逻辑复制远程服务器改变状态。</target>
        </trans-unit>
        <trans-unit id="a171ef7b847c02147b5330baa42032a3b728b099" translate="yes" xml:space="preserve">
          <source>Waiting for logical replication remote server to send data for initial table synchronization.</source>
          <target state="translated">等待逻辑复制远程服务器发送数据进行初始表同步。</target>
        </trans-unit>
        <trans-unit id="f7b87a554b163e3c4b56d071e13d3bb40ae9dcd8" translate="yes" xml:space="preserve">
          <source>Waiting for logical rewrite mappings to reach durable storage during a checkpoint.</source>
          <target state="translated">在检查点期间等待逻辑重写映射到达持久存储。</target>
        </trans-unit>
        <trans-unit id="d0128fffe323c5eab36d0b583264686f6fdc14a9" translate="yes" xml:space="preserve">
          <source>Waiting for logical rewrite mappings to reach durable storage.</source>
          <target state="translated">等待逻辑重写映射达到持久存储。</target>
        </trans-unit>
        <trans-unit id="a1252663514ce3e310a8ccaa53abc308558932c1" translate="yes" xml:space="preserve">
          <source>Waiting for logical rewrite mappings to reach stable storage during a checkpoint.</source>
          <target state="translated">在检查点期间,等待逻辑重写映射达到稳定存储。</target>
        </trans-unit>
        <trans-unit id="754897ce0cd2e99fe42e75806589d9d45f48b612" translate="yes" xml:space="preserve">
          <source>Waiting for logical rewrite mappings to reach stable storage.</source>
          <target state="translated">等待逻辑重写映射达到稳定存储。</target>
        </trans-unit>
        <trans-unit id="1012667842a00603eeb152c4741dc06b3a218b04" translate="yes" xml:space="preserve">
          <source>Waiting for mapping data to reach durable storage during a logical rewrite.</source>
          <target state="translated">在逻辑重写期间,等待映射数据到达持久存储。</target>
        </trans-unit>
        <trans-unit id="ddcc4581e90866cae66b033e94adc36e9d35b43d" translate="yes" xml:space="preserve">
          <source>Waiting for mapping data to reach stable storage during a logical rewrite.</source>
          <target state="translated">在逻辑重写过程中,等待映射数据达到稳定存储。</target>
        </trans-unit>
        <trans-unit id="b8552e94ff493c563b97bc367629ad56d62866bf" translate="yes" xml:space="preserve">
          <source>Waiting for other Parallel Hash participants to finish hashing the inner relation.</source>
          <target state="translated">等待其他Parallel Hash参与者完成内部关系的散列。</target>
        </trans-unit>
        <trans-unit id="e11479178e59844fd7fe15f1ce4eb490d0773d60" translate="yes" xml:space="preserve">
          <source>Waiting for other Parallel Hash participants to finish inserting tuples into new buckets.</source>
          <target state="translated">等待其他Parallel Hash参与者完成将元组插入到新桶中。</target>
        </trans-unit>
        <trans-unit id="7c11b60c1a40d4f8d29e90353a8affe9075ec7f0" translate="yes" xml:space="preserve">
          <source>Waiting for other Parallel Hash participants to finish loading a hash table.</source>
          <target state="translated">等待其他并行哈希参与者完成加载哈希表。</target>
        </trans-unit>
        <trans-unit id="5413b25ebacbf60f6298ddfd13544237708b4afd" translate="yes" xml:space="preserve">
          <source>Waiting for other Parallel Hash participants to finish partitioning the outer relation.</source>
          <target state="translated">等待其他Parallel Hash参与者完成外部关系的分割。</target>
        </trans-unit>
        <trans-unit id="5d8612704b7ac31605b00f1b5ae0376a34a38614" translate="yes" xml:space="preserve">
          <source>Waiting for other Parallel Hash participants to finish repartitioning.</source>
          <target state="translated">等待其他Parallel Hash参与者完成重新分区。</target>
        </trans-unit>
        <trans-unit id="6ddf8230dce1afc618c7942a19d13a4e06fbab65" translate="yes" xml:space="preserve">
          <source>Waiting for other Parallel Hash participants to finishing repartitioning.</source>
          <target state="translated">等待其他Parallel Hash参与者完成重新分区。</target>
        </trans-unit>
        <trans-unit id="7ddcd3a1c9792343c59de081cc3c348d37cc1494" translate="yes" xml:space="preserve">
          <source>Waiting for other process to be attached in shared message queue.</source>
          <target state="translated">在共享消息队列中等待其他进程加入。</target>
        </trans-unit>
        <trans-unit id="ea1e4d605c6dfe012718f5d6b6342a2c1167a5ba" translate="yes" xml:space="preserve">
          <source>Waiting for parallel &lt;code&gt;CREATE INDEX&lt;/code&gt; workers to finish heap scan.</source>
          <target state="translated">等待并行的 &lt;code&gt;CREATE INDEX&lt;/code&gt; 工作程序完成堆扫描。</target>
        </trans-unit>
        <trans-unit id="2c0e5b890525a78c621a8bd9247fc1bb58a1d9d0" translate="yes" xml:space="preserve">
          <source>Waiting for parallel bitmap scan to become initialized.</source>
          <target state="translated">等待平行位图扫描初始化。</target>
        </trans-unit>
        <trans-unit id="54d8ebcdd8df7afcbc1ca990a46b504e44b8711d" translate="yes" xml:space="preserve">
          <source>Waiting for parallel query dynamic shared memory allocation lock.</source>
          <target state="translated">等待并行查询动态共享内存分配锁。</target>
        </trans-unit>
        <trans-unit id="1fc906f71278562c97c85008b2e438b9bb00035c" translate="yes" xml:space="preserve">
          <source>Waiting for parallel query dynamic shared memory allocation.</source>
          <target state="translated">等待并行查询动态共享内存分配。</target>
        </trans-unit>
        <trans-unit id="6b2ad8cbb3533dbd2f7a9b18414fee3c1da25764" translate="yes" xml:space="preserve">
          <source>Waiting for parallel workers to finish computing.</source>
          <target state="translated">等待并行工作者完成计算。</target>
        </trans-unit>
        <trans-unit id="be528b921033388197b955d3bbbb7b2e892893ec" translate="yes" xml:space="preserve">
          <source>Waiting for recovery conflict resolution for a vacuum cleanup.</source>
          <target state="translated">等待恢复冲突解决的真空清理。</target>
        </trans-unit>
        <trans-unit id="98c345abde177b384e76034b5919030c1a291113" translate="yes" xml:space="preserve">
          <source>Waiting for recovery conflict resolution for dropping a tablespace.</source>
          <target state="translated">等待恢复冲突解决掉一个表空间。</target>
        </trans-unit>
        <trans-unit id="7d3620b94d83d3288e29f36d6b41b0a233781347" translate="yes" xml:space="preserve">
          <source>Waiting for recovery to be resumed.</source>
          <target state="translated">等待恢复。</target>
        </trans-unit>
        <trans-unit id="d884014cf602749f289dbc7c7fc61acad84fa09d" translate="yes" xml:space="preserve">
          <source>Waiting for standby promotion.</source>
          <target state="translated">等待待机推广。</target>
        </trans-unit>
        <trans-unit id="8cb227e761e8b1bc97dcd2f57c98b273168fa6eb" translate="yes" xml:space="preserve">
          <source>Waiting for startup process to send initial data for streaming replication.</source>
          <target state="translated">等待启动过程发送初始数据进行流式复制。</target>
        </trans-unit>
        <trans-unit id="575b51c84a8a278b78f70ac32550deee0ade954c" translate="yes" xml:space="preserve">
          <source>Waiting for the &lt;code&gt;pg_control&lt;/code&gt; file to reach durable storage.</source>
          <target state="translated">等待 &lt;code&gt;pg_control&lt;/code&gt; 文件到达持久存储。</target>
        </trans-unit>
        <trans-unit id="4de10813baf47bfe4c27cf4c7969243299b919ed" translate="yes" xml:space="preserve">
          <source>Waiting for the control file to reach stable storage.</source>
          <target state="translated">等待控制文件达到稳定存储。</target>
        </trans-unit>
        <trans-unit id="7dd0de4ea463c3d55bd0ecf6a2a3ba4fdd4c90a5" translate="yes" xml:space="preserve">
          <source>Waiting for the group leader to clear the transaction ID at end of a parallel operation.</source>
          <target state="translated">在并行操作结束时,等待组长清除交易ID。</target>
        </trans-unit>
        <trans-unit id="1d874537780129e3ca666a787de17aa9ba412019" translate="yes" xml:space="preserve">
          <source>Waiting for the group leader to update transaction status at end of a parallel operation.</source>
          <target state="translated">在并行操作结束时,等待组长更新交易状态。</target>
        </trans-unit>
        <trans-unit id="681bd23f805b6da445bd3d82fc4a46addc600e13" translate="yes" xml:space="preserve">
          <source>Waiting for the page number needed to continue a parallel B-tree scan to become available.</source>
          <target state="translated">等待继续进行平行B树扫描所需的页码。</target>
        </trans-unit>
        <trans-unit id="19a27081e7292e225f5308f76e3b7bb1b53bae9d" translate="yes" xml:space="preserve">
          <source>Waiting for the relation map file to reach durable storage.</source>
          <target state="translated">等待关系图文件到达持久存储。</target>
        </trans-unit>
        <trans-unit id="c939d0ba9c27dac2f7d8824016725fedd49ef586" translate="yes" xml:space="preserve">
          <source>Waiting for the relation map file to reach stable storage.</source>
          <target state="translated">等待关系图文件达到稳定存储。</target>
        </trans-unit>
        <trans-unit id="9e983510c142fcea08d4f84210ccfa6323d4b28e" translate="yes" xml:space="preserve">
          <source>Waiting for truncate of mapping data during a logical rewrite.</source>
          <target state="translated">在逻辑重写过程中等待映射数据的截断。</target>
        </trans-unit>
        <trans-unit id="c7be20b27094dae3303ee1fadc67011cd3751be8" translate="yes" xml:space="preserve">
          <source>Waiting in WAL receiver to establish connection to remote server.</source>
          <target state="translated">在WAL接收器中等待与远程服务器建立连接。</target>
        </trans-unit>
        <trans-unit id="8b6df6362589c923614f910bed59cf34ff945324" translate="yes" xml:space="preserve">
          <source>Waiting in WAL receiver to receive data from remote server.</source>
          <target state="translated">在WAL接收器中等待从远程服务器接收数据。</target>
        </trans-unit>
        <trans-unit id="cb632d8f0ca89d0c5cd00cc7485e8835401d24f7" translate="yes" xml:space="preserve">
          <source>Waiting in a cost-based vacuum delay point.</source>
          <target state="translated">在基于成本的真空延迟点中等待。</target>
        </trans-unit>
        <trans-unit id="bb83e82efa5858b6db8ad5949e98eced2a90463a" translate="yes" xml:space="preserve">
          <source>Waiting in an extension.</source>
          <target state="translated">在分机中等待。</target>
        </trans-unit>
        <trans-unit id="feb270e93605e72d07d6bcedd0737f5a39e22df0" translate="yes" xml:space="preserve">
          <source>Waiting in background writer process, hibernating.</source>
          <target state="translated">在后台作者过程中等待,休眠。</target>
        </trans-unit>
        <trans-unit id="88eefbfbae399c6feea1548c69357a5e9736f5ab" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of WAL receiver process.</source>
          <target state="translated">在WAL接收过程的主循环中等待。</target>
        </trans-unit>
        <trans-unit id="375265f881add8dd9c33130678344167b52a9588" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of WAL sender process.</source>
          <target state="translated">在WAL发送者进程的主循环中等待。</target>
        </trans-unit>
        <trans-unit id="f5e173311caac73154fc23d76aed32502c099d08" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of WAL writer process.</source>
          <target state="translated">在WAL编写过程的主循环中等待。</target>
        </trans-unit>
        <trans-unit id="3a633670f0870c8e9a937ee6b4ff3e55e43509be" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of archiver process.</source>
          <target state="translated">在存档过程的主循环中等待。</target>
        </trans-unit>
        <trans-unit id="7acb76585737d883d007ddb658d4cfd89597eb50" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of autovacuum launcher process.</source>
          <target state="translated">在自动真空发射器进程的主循环中等待。</target>
        </trans-unit>
        <trans-unit id="7e6e41b3df7e89238ff4283ef4198a69ebe76109" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of background writer process background worker.</source>
          <target state="translated">在后台写手处理后台工作者的主循环中等待。</target>
        </trans-unit>
        <trans-unit id="4468be3c04a316f7404c95b5e3ff6208ba74e229" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of background writer process.</source>
          <target state="translated">在后台写程序的主循环中等待。</target>
        </trans-unit>
        <trans-unit id="d193be75953171ebbce3b3db2cde50e60c132491" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of checkpointer process.</source>
          <target state="translated">在checkpointer进程的主循环中等待。</target>
        </trans-unit>
        <trans-unit id="db02418c7eb01a5eb05765091cb30a31f71aa88d" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of logical apply process.</source>
          <target state="translated">在逻辑应用过程的主循环中等待。</target>
        </trans-unit>
        <trans-unit id="82a745dd84bf90f7ae367a6c7dc035147ac68293" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of logical launcher process.</source>
          <target state="translated">在逻辑发射器进程的主循环中等待。</target>
        </trans-unit>
        <trans-unit id="56edcd7dc5636046884520046ede7d834d729f36" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of logical replication apply process.</source>
          <target state="translated">在逻辑复制应用过程的主循环中等待。</target>
        </trans-unit>
        <trans-unit id="9560c436af4a42ef660a92403ce9cdd3a8693974" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of logical replication launcher process.</source>
          <target state="translated">在逻辑复制启动器进程的主循环中等待。</target>
        </trans-unit>
        <trans-unit id="1679d413ddb6f0377771d12a5f1423b023c45511" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of startup process for WAL to arrive, during streaming recovery.</source>
          <target state="translated">在流媒体恢复期间,在启动过程的主循环中等待WAL的到来。</target>
        </trans-unit>
        <trans-unit id="fd3c72bbecc0f184f22e57ca78f3e93236b96e1a" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of statistics collector process.</source>
          <target state="translated">在统计收集器进程的主循环中等待。</target>
        </trans-unit>
        <trans-unit id="1e0772397293bff630517da7bd7ffb1ab81b17f5" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of syslogger process.</source>
          <target state="translated">在syslogger进程的主循环中等待。</target>
        </trans-unit>
        <trans-unit id="54f59b1a36db7407d20232e85176d4c1a23692f4" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of the archiver process.</source>
          <target state="translated">在存档过程的主循环中等待。</target>
        </trans-unit>
        <trans-unit id="212f0884ddfbc91689a2a97c09aafbcd3f389116" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of the statistics collector process.</source>
          <target state="translated">在统计收集器进程的主循环中等待。</target>
        </trans-unit>
        <trans-unit id="3b4ceca9ff1b34dd3a21d5a1be2bf8a9aa711a70" translate="yes" xml:space="preserve">
          <source>Waiting in process that called &lt;code&gt;pg_sleep&lt;/code&gt;.</source>
          <target state="translated">正在等待调用 &lt;code&gt;pg_sleep&lt;/code&gt; 的进程。</target>
        </trans-unit>
        <trans-unit id="8d789f564ccad610d19b36929dbb0ef518eb37c8" translate="yes" xml:space="preserve">
          <source>Waiting to access a data page in memory.</source>
          <target state="translated">等待访问内存中的数据页。</target>
        </trans-unit>
        <trans-unit id="a4ae79783ab5a39da6e76c4478527282bcedbc6a" translate="yes" xml:space="preserve">
          <source>Waiting to access a parallel query's information about composite types.</source>
          <target state="translated">等待访问并行查询的复合类型信息。</target>
        </trans-unit>
        <trans-unit id="90d1b409aa03dee9b02a04e2a2e3f64452f3400a" translate="yes" xml:space="preserve">
          <source>Waiting to access a parallel query's information about type modifiers that identify anonymous record types.</source>
          <target state="translated">等待访问并行查询的类型修饰符信息,以识别匿名记录类型。</target>
        </trans-unit>
        <trans-unit id="b1030c503e3237c1219d1eea28582a6ddcbee56c" translate="yes" xml:space="preserve">
          <source>Waiting to access a shared TID bitmap during a parallel bitmap index scan.</source>
          <target state="translated">在并行位图索引扫描期间,等待访问共享的TID位图。</target>
        </trans-unit>
        <trans-unit id="7eba3915c1db0580d2b281d905946603d4982aff" translate="yes" xml:space="preserve">
          <source>Waiting to access a shared tuple store during parallel query.</source>
          <target state="translated">在并行查询期间等待访问共享元组存储。</target>
        </trans-unit>
        <trans-unit id="129d2539d77dbbde3d4d4e8ea2141ca238f7d876" translate="yes" xml:space="preserve">
          <source>Waiting to access predicate lock information used by serializable transactions.</source>
          <target state="translated">等待访问可序列化事务使用的谓词锁信息。</target>
        </trans-unit>
        <trans-unit id="c7319b09761891c0f9227dbd3732f4b9eaeb8739" translate="yes" xml:space="preserve">
          <source>Waiting to access the &lt;code&gt;NOTIFY&lt;/code&gt; message SLRU cache.</source>
          <target state="translated">等待访问 &lt;code&gt;NOTIFY&lt;/code&gt; 消息SLRU缓存。</target>
        </trans-unit>
        <trans-unit id="af1ca2e2935e52e66c06e90f2e54befc88f72df7" translate="yes" xml:space="preserve">
          <source>Waiting to access the commit timestamp SLRU cache.</source>
          <target state="translated">等待访问提交时间戳SLRU缓存。</target>
        </trans-unit>
        <trans-unit id="0184a02009f44f4d2a88cbd98d9dfe8231fceb5e" translate="yes" xml:space="preserve">
          <source>Waiting to access the list of finished serializable transactions.</source>
          <target state="translated">等待访问完成的可序列化交易列表。</target>
        </trans-unit>
        <trans-unit id="55fba80517e3090a2255d706ee1972631c869d74" translate="yes" xml:space="preserve">
          <source>Waiting to access the list of predicate locks held by serializable transactions.</source>
          <target state="translated">等待访问可序列化事务持有的谓词锁列表。</target>
        </trans-unit>
        <trans-unit id="f47f83daf5272307314e793a722029f6849c834f" translate="yes" xml:space="preserve">
          <source>Waiting to access the list of predicate locks held by the current serializable transaction during a parallel query.</source>
          <target state="translated">在并行查询期间,等待访问当前可序列化事务所持有的谓词锁列表。</target>
        </trans-unit>
        <trans-unit id="0d72c61a42652b27a772dd6eed5858254b3939df" translate="yes" xml:space="preserve">
          <source>Waiting to access the multixact member SLRU cache.</source>
          <target state="translated">等待访问多act成员SLRU缓存。</target>
        </trans-unit>
        <trans-unit id="c0c797a16c61c341fd52d3f66bf04186016fb3de" translate="yes" xml:space="preserve">
          <source>Waiting to access the multixact offset SLRU cache.</source>
          <target state="translated">等待访问多算法偏移SLRU缓存。</target>
        </trans-unit>
        <trans-unit id="860e2d04d5faad33e65a1c939bd5f4775f44e584" translate="yes" xml:space="preserve">
          <source>Waiting to access the serializable transaction conflict SLRU cache.</source>
          <target state="translated">等待访问可序列化事务冲突SLRU缓存。</target>
        </trans-unit>
        <trans-unit id="a8c61dc32e3583de9339bc9f5339255eccb847d4" translate="yes" xml:space="preserve">
          <source>Waiting to access the shared per-process data structures (typically, to get a snapshot or report a session's transaction ID).</source>
          <target state="translated">等待访问共享的每个进程数据结构(通常是为了获取快照或报告会话的事务ID)。</target>
        </trans-unit>
        <trans-unit id="6be8feecbd6665e987b15bc5fe4b1aa15dcee557" translate="yes" xml:space="preserve">
          <source>Waiting to access the sub-transaction SLRU cache.</source>
          <target state="translated">等待访问子交易SLRU缓存。</target>
        </trans-unit>
        <trans-unit id="bb9c50c150b703d0eb8293a5862178e36f3db67f" translate="yes" xml:space="preserve">
          <source>Waiting to access the transaction status SLRU cache.</source>
          <target state="translated">等待访问事务状态SLRU缓存。</target>
        </trans-unit>
        <trans-unit id="453521c4c18069faa9fd0afad3d83ca7731d1096" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a lock on a non-relation database object.</source>
          <target state="translated">等待获取一个非关系数据库对象的锁。</target>
        </trans-unit>
        <trans-unit id="373b1f9b0bfcc9c3b92c4d65ca011a20f7f7ee7b" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a lock on a page of a relation.</source>
          <target state="translated">等待获取关系页上的锁。</target>
        </trans-unit>
        <trans-unit id="e1e200aae0e4f2353a2c19cd08c7d6ee7ce7f912" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a lock on a relation.</source>
          <target state="translated">等待获得关系的锁定。</target>
        </trans-unit>
        <trans-unit id="caf9078aaa0a5a46ce631268ce4c46ea2cb0e198" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a lock on a tuple.</source>
          <target state="translated">等待获得一个元组的锁定。</target>
        </trans-unit>
        <trans-unit id="20d61e9ac29e8e57ca0786825f9ae212af87d782" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a lock on page of a relation.</source>
          <target state="translated">等待获取关系页的锁。</target>
        </trans-unit>
        <trans-unit id="60529117b6f828f517a439e0152cfca12a03780e" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a pin on a buffer.</source>
          <target state="translated">等待获取缓冲区的引脚。</target>
        </trans-unit>
        <trans-unit id="9dff15d412549524e8b05e08b4e658a978321307" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a speculative insertion lock.</source>
          <target state="translated">等候取得投机插手锁。</target>
        </trans-unit>
        <trans-unit id="6f1d92a10ff6e0f42c232bac9cd39b9515b5e1f1" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a user lock.</source>
          <target state="translated">等待获取用户锁。</target>
        </trans-unit>
        <trans-unit id="b864edb73d7fdb51b089c159fd2e24aac209fa44" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a virtual transaction ID lock.</source>
          <target state="translated">等待获取虚拟交易ID锁。</target>
        </trans-unit>
        <trans-unit id="feee645b171eddc5255ea3172e0b6eaae2f3531e" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a virtual xid lock.</source>
          <target state="translated">等待获取虚拟xid锁。</target>
        </trans-unit>
        <trans-unit id="0cff112c15e1e7f938ee8722e01003e541c3a9b9" translate="yes" xml:space="preserve">
          <source>Waiting to acquire an advisory user lock.</source>
          <target state="translated">等待获得咨询用户锁。</target>
        </trans-unit>
        <trans-unit id="fb4afc5fd680e2c4a5249b716bc3eb3612204493" translate="yes" xml:space="preserve">
          <source>Waiting to acquire an exclusive pin on a buffer.</source>
          <target state="translated">等待获得缓冲区的专属引脚。</target>
        </trans-unit>
        <trans-unit id="f4b782a596b50a85963931c1ce8ff87a36ab9e82" translate="yes" xml:space="preserve">
          <source>Waiting to add a message in shared invalidation queue.</source>
          <target state="translated">等待在共享无效队列中添加消息。</target>
        </trans-unit>
        <trans-unit id="e0bc3fce7ad76f7cd0de9cfb2f8867086e1cad27" translate="yes" xml:space="preserve">
          <source>Waiting to add a message to the shared catalog invalidation queue.</source>
          <target state="translated">等待向共享目录无效队列添加消息。</target>
        </trans-unit>
        <trans-unit id="a30c5b64b9088c9bea1b788c2d9cad490d0feadc" translate="yes" xml:space="preserve">
          <source>Waiting to add or examine locks for backends, or waiting to join or exit a locking group (used by parallel query).</source>
          <target state="translated">等待为后端添加或检查锁,或等待加入或退出锁组(并行查询使用)。</target>
        </trans-unit>
        <trans-unit id="4234f3768471935481a7a5ac70e216c3b3196d0a" translate="yes" xml:space="preserve">
          <source>Waiting to add or examine predicate lock information.</source>
          <target state="translated">等待添加或检查谓词锁信息。</target>
        </trans-unit>
        <trans-unit id="cd6ab73b17fc50224d6ba20de7b66c56a5168edd" translate="yes" xml:space="preserve">
          <source>Waiting to allocate a new OID.</source>
          <target state="translated">等待分配一个新的OID。</target>
        </trans-unit>
        <trans-unit id="c6110497bf2fb4e7dd3e567f14149228534e81be" translate="yes" xml:space="preserve">
          <source>Waiting to allocate a new transaction ID.</source>
          <target state="translated">等待分配一个新的交易ID。</target>
        </trans-unit>
        <trans-unit id="922ece807fb5d0e3eca745374502101b8e2f9883" translate="yes" xml:space="preserve">
          <source>Waiting to allocate or assign a transaction id.</source>
          <target state="translated">等待分配或分配一个交易ID。</target>
        </trans-unit>
        <trans-unit id="4df1187e247ec9e3885764b731ccac5a81693366" translate="yes" xml:space="preserve">
          <source>Waiting to allocate or assign an OID.</source>
          <target state="translated">等待分配或分配一个OID。</target>
        </trans-unit>
        <trans-unit id="36e78f99b93b8582ddda9533616d35bad0cb3435" translate="yes" xml:space="preserve">
          <source>Waiting to allocate or exchange a chunk of memory or update counters during Parallel Hash plan execution.</source>
          <target state="translated">在并行哈希计划执行过程中,等待分配或交换一大块内存或更新计数器。</target>
        </trans-unit>
        <trans-unit id="aea0084a8686cdd126b6dc0b70e3bb510372f940" translate="yes" xml:space="preserve">
          <source>Waiting to allocate or free a replication slot.</source>
          <target state="translated">等待分配或释放复制槽。</target>
        </trans-unit>
        <trans-unit id="392b0fcbf6923b50ad00d9bcdf711922567f010a" translate="yes" xml:space="preserve">
          <source>Waiting to apply WAL at recovery because it is delayed.</source>
          <target state="translated">在恢复时等待应用WAL,因为它是延迟的。</target>
        </trans-unit>
        <trans-unit id="6a88aa7353a070ee85e5931747ec79047e6808c8" translate="yes" xml:space="preserve">
          <source>Waiting to apply WAL during recovery because of a delay setting.</source>
          <target state="translated">在恢复过程中,由于设置了延迟,等待应用WAL。</target>
        </trans-unit>
        <trans-unit id="417e2e4d470ba2ea215e899c1f2f47a808b6cd1d" translate="yes" xml:space="preserve">
          <source>Waiting to associate a data block with a buffer in the buffer pool.</source>
          <target state="translated">等待将一个数据块与缓冲池中的缓冲区关联。</target>
        </trans-unit>
        <trans-unit id="441c3081779de229e60de2154d2224a6b45068d6" translate="yes" xml:space="preserve">
          <source>Waiting to begin a checkpoint.</source>
          <target state="translated">等待开始检查点。</target>
        </trans-unit>
        <trans-unit id="0b5eba1b1476e67df8c9026fe8a8423164cbbbaf" translate="yes" xml:space="preserve">
          <source>Waiting to choose the next subplan during Parallel Append plan execution.</source>
          <target state="translated">在并行追加计划执行过程中,等待选择下一个子计划。</target>
        </trans-unit>
        <trans-unit id="ef3a63e38286ce146119c1f18cfc00a196004cf5" translate="yes" xml:space="preserve">
          <source>Waiting to create or drop a tablespace.</source>
          <target state="translated">等待创建或删除一个表空间。</target>
        </trans-unit>
        <trans-unit id="11402cb956b4c4ad7b4f3ee48f5957e1d0e2837b" translate="yes" xml:space="preserve">
          <source>Waiting to create or drop the tablespace.</source>
          <target state="translated">等待创建或删除表空间。</target>
        </trans-unit>
        <trans-unit id="33c72accbdd4730b372dab88dd65b76db73de627" translate="yes" xml:space="preserve">
          <source>Waiting to create, drop or use a replication origin.</source>
          <target state="translated">等待创建、放弃或使用复制原点。</target>
        </trans-unit>
        <trans-unit id="65bc84d857a25120993bfa2901196e8db0fe8c4c" translate="yes" xml:space="preserve">
          <source>Waiting to elect a Parallel Hash participant to allocate a hash table.</source>
          <target state="translated">等待选出一个并行哈希参与者来分配一个哈希表。</target>
        </trans-unit>
        <trans-unit id="f4f746425fc465e7164c9c695db3b4635155f935" translate="yes" xml:space="preserve">
          <source>Waiting to elect a Parallel Hash participant to allocate more batches.</source>
          <target state="translated">等待选出一个并行哈希参与者来分配更多的批次。</target>
        </trans-unit>
        <trans-unit id="639eee9765487a635a37650a7d0fb63770b1ca2a" translate="yes" xml:space="preserve">
          <source>Waiting to elect a Parallel Hash participant to allocate more buckets.</source>
          <target state="translated">等待选出一个并行哈希参与者来分配更多的桶。</target>
        </trans-unit>
        <trans-unit id="e5677145792ffce4d3d31df1e9a789e136de6ea8" translate="yes" xml:space="preserve">
          <source>Waiting to elect a Parallel Hash participant to allocate the initial hash table.</source>
          <target state="translated">等待选出一个并行哈希参与者来分配初始哈希表。</target>
        </trans-unit>
        <trans-unit id="065be077f679b5dad73d4b8a473bd2b28958e69a" translate="yes" xml:space="preserve">
          <source>Waiting to elect a Parallel Hash participant to decide on future batch growth.</source>
          <target state="translated">等待选举出一个并行哈希参与者,以决定未来的批量增长。</target>
        </trans-unit>
        <trans-unit id="51f5db2c59767bd472dd0b1faf70ac07aafa7a96" translate="yes" xml:space="preserve">
          <source>Waiting to ensure that a table selected for autovacuum still needs vacuuming.</source>
          <target state="translated">等待确保被选为自动吸尘的桌子还需要吸尘。</target>
        </trans-unit>
        <trans-unit id="ef13562f4466bb31b5bf871e5d3f767784c48032" translate="yes" xml:space="preserve">
          <source>Waiting to ensure that the table it has selected for a vacuum still needs vacuuming.</source>
          <target state="translated">等确保自己选择的吸尘台还需要吸尘。</target>
        </trans-unit>
        <trans-unit id="d69f496f29eae75635234b22654119ee74ecb1dc" translate="yes" xml:space="preserve">
          <source>Waiting to execute &lt;code&gt;pg_xact_status&lt;/code&gt; or update the oldest transaction ID available to it.</source>
          <target state="translated">等待执行 &lt;code&gt;pg_xact_status&lt;/code&gt; 或更新可用的最旧的事务ID。</target>
        </trans-unit>
        <trans-unit id="7d2e90490a1d7b7d270317787f40bff2e1d72ee9" translate="yes" xml:space="preserve">
          <source>Waiting to execute &lt;code&gt;txid_status&lt;/code&gt; or update the oldest transaction id available to it.</source>
          <target state="translated">等待执行 &lt;code&gt;txid_status&lt;/code&gt; 或更新可用的最早的事务ID。</target>
        </trans-unit>
        <trans-unit id="905b59818613073e2e260c6b0fb7d68bf3c39843" translate="yes" xml:space="preserve">
          <source>Waiting to extend a relation.</source>
          <target state="translated">等待扩展关系。</target>
        </trans-unit>
        <trans-unit id="d1ff05f0321453c7e170463f2183122fba046afb" translate="yes" xml:space="preserve">
          <source>Waiting to fill a dynamic shared memory backing file with zeroes.</source>
          <target state="translated">等待用零点填充动态共享内存备份文件。</target>
        </trans-unit>
        <trans-unit id="f8b7f54188ceea3dc5def955dc47ae1f28373839" translate="yes" xml:space="preserve">
          <source>Waiting to find or allocate space in shared memory.</source>
          <target state="translated">等待在共享内存中寻找或分配空间。</target>
        </trans-unit>
        <trans-unit id="fb53c073cc374cfb75fd8b826e6b4d7eb6cc9003" translate="yes" xml:space="preserve">
          <source>Waiting to get a snapshot or clearing a transaction id at transaction end.</source>
          <target state="translated">等待获取快照或在交易结束时清除交易ID。</target>
        </trans-unit>
        <trans-unit id="e384d346b49ba85024e06c032fcf3ccf1737b636" translate="yes" xml:space="preserve">
          <source>Waiting to get the start location of a scan on a table for synchronized scans.</source>
          <target state="translated">等待获取同步扫描的表上扫描的起始位置。</target>
        </trans-unit>
        <trans-unit id="77a61ca13921177e3120d7941bf5fe7710333ad3" translate="yes" xml:space="preserve">
          <source>Waiting to insert WAL data into a memory buffer.</source>
          <target state="translated">等待将WAL数据插入内存缓冲区。</target>
        </trans-unit>
        <trans-unit id="9a6beee315605623099d06c2371ae56da6b46cc7" translate="yes" xml:space="preserve">
          <source>Waiting to insert WAL into a memory buffer.</source>
          <target state="translated">等待将WAL插入内存缓冲区。</target>
        </trans-unit>
        <trans-unit id="cadbcac0880c9c035e541586388a47501c362c88" translate="yes" xml:space="preserve">
          <source>Waiting to manage an extension's space allocation in shared memory.</source>
          <target state="translated">等待管理共享内存中扩展的空间分配。</target>
        </trans-unit>
        <trans-unit id="fe4ce59b2db271f1abfb91f4099370c7dcadc0ae" translate="yes" xml:space="preserve">
          <source>Waiting to manage fsync requests.</source>
          <target state="translated">等待管理fsync请求。</target>
        </trans-unit>
        <trans-unit id="e3141c5d05c342451c8644a34df11be83dd434ad" translate="yes" xml:space="preserve">
          <source>Waiting to manage space allocation in shared memory.</source>
          <target state="translated">等待管理共享内存中的空间分配。</target>
        </trans-unit>
        <trans-unit id="fac57a518044fa2f05c64ea1dd8ce9527a59af1f" translate="yes" xml:space="preserve">
          <source>Waiting to obtain a valid snapshot for a &lt;code&gt;READ ONLY DEFERRABLE&lt;/code&gt; transaction.</source>
          <target state="translated">等待获取 &lt;code&gt;READ ONLY DEFERRABLE&lt;/code&gt; 快照事务的有效快照。</target>
        </trans-unit>
        <trans-unit id="b97c8584b996285f48aeab64ef02658839acbba9" translate="yes" xml:space="preserve">
          <source>Waiting to perform an operation on a list of locks held by serializable transactions.</source>
          <target state="translated">等待对可序列化事务持有的锁列表进行操作。</target>
        </trans-unit>
        <trans-unit id="d8589a1b8c66d6f8e4debafdd099f1a4b71a5b13" translate="yes" xml:space="preserve">
          <source>Waiting to perform an operation on a serializable transaction in a parallel query.</source>
          <target state="translated">等待在并行查询中对可序列化事务执行操作。</target>
        </trans-unit>
        <trans-unit id="d2ade432e382335fbb1d6fb86bda4500ee8c2cbb" translate="yes" xml:space="preserve">
          <source>Waiting to perform checkpoint.</source>
          <target state="translated">等待执行检查点。</target>
        </trans-unit>
        <trans-unit id="3e379fd689c1e6c70aa9f8b650b7c7fb7692028c" translate="yes" xml:space="preserve">
          <source>Waiting to read data from the client while establishing a GSSAPI session.</source>
          <target state="translated">在建立GSSAPI会话时,等待从客户端读取数据。</target>
        </trans-unit>
        <trans-unit id="1908bfbabea7a0ab1bbde739ebc0330fc7517b79" translate="yes" xml:space="preserve">
          <source>Waiting to read data from the client.</source>
          <target state="translated">等待从客户端读取数据。</target>
        </trans-unit>
        <trans-unit id="05dd640e8c1d54ebf01054c0befd12ca4f14b63e" translate="yes" xml:space="preserve">
          <source>Waiting to read or record conflicting serializable transactions.</source>
          <target state="translated">等待读取或记录冲突的可序列化事务。</target>
        </trans-unit>
        <trans-unit id="0afe38ebe7d995583b3d1a5cd94b6fbc8cf1b845" translate="yes" xml:space="preserve">
          <source>Waiting to read or truncate multixact information.</source>
          <target state="translated">等待读取或截断多条信息。</target>
        </trans-unit>
        <trans-unit id="89e6d605086c4806a8e8361ed20ce472bcc5d0c1" translate="yes" xml:space="preserve">
          <source>Waiting to read or update &lt;code&gt;NOTIFY&lt;/code&gt; messages.</source>
          <target state="translated">等待阅读或更新 &lt;code&gt;NOTIFY&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="aa2ee7fba8bdd1b9ba46fd013db4148ed8d4f325" translate="yes" xml:space="preserve">
          <source>Waiting to read or update a &lt;code&gt;pg_filenode.map&lt;/code&gt; file (used to track the filenode assignments of certain system catalogs).</source>
          <target state="translated">等待读取或更新 &lt;code&gt;pg_filenode.map&lt;/code&gt; 文件（用于跟踪某些系统目录的filenode分配）。</target>
        </trans-unit>
        <trans-unit id="f06b28a219ba82487eff75cb07672ef51a1fba36" translate="yes" xml:space="preserve">
          <source>Waiting to read or update a &lt;code&gt;pg_internal.init&lt;/code&gt; relation cache initialization file.</source>
          <target state="translated">等待读取或更新 &lt;code&gt;pg_internal.init&lt;/code&gt; 关系缓存初始化文件。</target>
        </trans-unit>
        <trans-unit id="29aea2dafdc907848a947f9ada3488409914bca8" translate="yes" xml:space="preserve">
          <source>Waiting to read or update a process' fast-path lock information.</source>
          <target state="translated">等待读取或更新进程的快速路径锁信息。</target>
        </trans-unit>
        <trans-unit id="a018a1a15593b5af23414939d50aec3fcb48c5cb" translate="yes" xml:space="preserve">
          <source>Waiting to read or update background worker state.</source>
          <target state="translated">等待读取或更新背景工作者状态。</target>
        </trans-unit>
        <trans-unit id="98f949b18dca9797ce85a82873e92ff14c18778a" translate="yes" xml:space="preserve">
          <source>Waiting to read or update dynamic shared memory allocation information.</source>
          <target state="translated">等待读取或更新动态共享内存分配信息。</target>
        </trans-unit>
        <trans-unit id="cea27617060567594092b7422c38330bfc2e5ee2" translate="yes" xml:space="preserve">
          <source>Waiting to read or update dynamic shared memory state.</source>
          <target state="translated">等待读取或更新动态共享内存状态。</target>
        </trans-unit>
        <trans-unit id="9ba9dcf3b19a57aaa5ade4bb0b3f5c3178217365" translate="yes" xml:space="preserve">
          <source>Waiting to read or update information about &amp;ldquo;heavyweight&amp;rdquo; locks.</source>
          <target state="translated">等待读取或更新有关&amp;ldquo;重量级&amp;rdquo;锁的信息。</target>
        </trans-unit>
        <trans-unit id="3aef06dd768e3617fde4dd6b5fb7f38e7fb0ef3c" translate="yes" xml:space="preserve">
          <source>Waiting to read or update information about serializable transactions.</source>
          <target state="translated">等待读取或更新可序列化事务的信息。</target>
        </trans-unit>
        <trans-unit id="5b94e34a6c9a38b9de8ddbf38266ea41569caa0e" translate="yes" xml:space="preserve">
          <source>Waiting to read or update information about synchronous replicas.</source>
          <target state="translated">等待读取或更新同步复制的信息。</target>
        </trans-unit>
        <trans-unit id="8db953a370c198b1e5b5a6d588d15d8ed6771d32" translate="yes" xml:space="preserve">
          <source>Waiting to read or update information about the state of synchronous replication.</source>
          <target state="translated">等待读取或更新同步复制的状态信息。</target>
        </trans-unit>
        <trans-unit id="7be479f3c24eeb847b5e44a9bf4f341c29d1834b" translate="yes" xml:space="preserve">
          <source>Waiting to read or update multixact member mappings.</source>
          <target state="translated">等待读取或更新多act成员映射。</target>
        </trans-unit>
        <trans-unit id="548a78a89a3c004e9ad475a70fb6f1bb50c1151e" translate="yes" xml:space="preserve">
          <source>Waiting to read or update multixact offset mappings.</source>
          <target state="translated">等待读取或更新多精确偏移映射。</target>
        </trans-unit>
        <trans-unit id="ed18ac469b6f870e80be0efbf5c76a4d5c79b754" translate="yes" xml:space="preserve">
          <source>Waiting to read or update notification messages.</source>
          <target state="translated">等待阅读或更新通知信息。</target>
        </trans-unit>
        <trans-unit id="76d4dfb568ccc6112df58f601dc5c426ad5d62a8" translate="yes" xml:space="preserve">
          <source>Waiting to read or update old snapshot control information.</source>
          <target state="translated">等待读取或更新旧的快照控制信息。</target>
        </trans-unit>
        <trans-unit id="6ce0cc66a076e07f94b764161b2bddd57ada2509" translate="yes" xml:space="preserve">
          <source>Waiting to read or update replication slot state.</source>
          <target state="translated">等待读取或更新复制槽状态。</target>
        </trans-unit>
        <trans-unit id="fff67315163276ff44c96c0a78a1830dd666732b" translate="yes" xml:space="preserve">
          <source>Waiting to read or update shared multixact state.</source>
          <target state="translated">等待读取或更新共享的多act状态。</target>
        </trans-unit>
        <trans-unit id="b79ef3c6f580409e99c1e495bc8e24c202fbe7ed" translate="yes" xml:space="preserve">
          <source>Waiting to read or update shared notification state.</source>
          <target state="translated">等待读取或更新共享通知状态。</target>
        </trans-unit>
        <trans-unit id="af64ba8ecf87cac9594cd6dc3c61c2e7ddf060d1" translate="yes" xml:space="preserve">
          <source>Waiting to read or update sub-transaction information.</source>
          <target state="translated">等待读取或更新子交易信息。</target>
        </trans-unit>
        <trans-unit id="c25e2fc156128ae3093a921e12431593e8862638" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the &lt;code&gt;pg_control&lt;/code&gt; file or create a new WAL file.</source>
          <target state="translated">等待读取或更新 &lt;code&gt;pg_control&lt;/code&gt; 文件或创建新的WAL文件。</target>
        </trans-unit>
        <trans-unit id="bdb0edf32466a645cdde40c21227abb2a0bb1f30" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the control file or creation of a new WAL file.</source>
          <target state="translated">等待读取或更新控制文件或创建新的WAL文件。</target>
        </trans-unit>
        <trans-unit id="017527ae52f7de277c3c95bf02bbacf34474f0f5" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the current state of autovacuum workers.</source>
          <target state="translated">等待阅读或更新自动吸尘器工人的现状。</target>
        </trans-unit>
        <trans-unit id="221da797b029fb896c5fbaed99fd507a4ef2a941" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the fast-path lock information.</source>
          <target state="translated">等待读取或更新快速路径锁信息。</target>
        </trans-unit>
        <trans-unit id="744cbcf49721354a8aff1c310f4ca421dbb8db3a" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the last value set for a transaction commit timestamp.</source>
          <target state="translated">等待读取或更新为事务提交时间戳设置的最后一个值。</target>
        </trans-unit>
        <trans-unit id="e9baf36ef5d66bb0ea1e99230d14314cf70bc406" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the last value set for the transaction timestamp.</source>
          <target state="translated">等待读取或更新为交易时间戳设置的最后一个值。</target>
        </trans-unit>
        <trans-unit id="e381bb78e4f640c21175ed08f51ed2c3a71544c7" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the progress of one replication origin.</source>
          <target state="translated">等待读取或更新一个复制原点的进度。</target>
        </trans-unit>
        <trans-unit id="15f6ffef563dec9ba786a7f233d5003f5ed45d14" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the replication progress.</source>
          <target state="translated">等待读取或更新复制进度。</target>
        </trans-unit>
        <trans-unit id="9ed2e28217e033a2eda63210c67632651e72f60a" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the state of logical replication workers.</source>
          <target state="translated">等待读取或更新逻辑复制工作者的状态。</target>
        </trans-unit>
        <trans-unit id="defd9a9d465fec9edd19efb8c557ca9acbf7364b" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the state of prepared transactions.</source>
          <target state="translated">等待读取或更新准备交易的状态。</target>
        </trans-unit>
        <trans-unit id="3dc7e6836006d3d5cbb7a9151c1a348063bbcc88" translate="yes" xml:space="preserve">
          <source>Waiting to read or update transaction commit timestamps.</source>
          <target state="translated">等待读取或更新事务提交时间戳。</target>
        </trans-unit>
        <trans-unit id="22fb7890af933754ae7b2b3d81b6bd6e23c2cc52" translate="yes" xml:space="preserve">
          <source>Waiting to read or update transaction status.</source>
          <target state="translated">等待读取或更新交易状态。</target>
        </trans-unit>
        <trans-unit id="1691bd5ffa74ce0764d59f613b874fce42907700" translate="yes" xml:space="preserve">
          <source>Waiting to read or update vacuum-related information for a B-tree index.</source>
          <target state="translated">等待读取或更新B树索引的真空相关信息。</target>
        </trans-unit>
        <trans-unit id="7909f678b84800f1b2a16328d0f20ff93a738a0c" translate="yes" xml:space="preserve">
          <source>Waiting to read or write a data page in memory.</source>
          <target state="translated">等待读取或写入内存中的数据页。</target>
        </trans-unit>
        <trans-unit id="ba3f3c6d87b25a2add5f41dc054490a6748416d8" translate="yes" xml:space="preserve">
          <source>Waiting to read or write relation cache initialization file.</source>
          <target state="translated">等待读写关系缓存初始化文件。</target>
        </trans-unit>
        <trans-unit id="56e29e2fa37b4e49226f461d31f27cc492afa177" translate="yes" xml:space="preserve">
          <source>Waiting to read while creating the data directory lock file.</source>
          <target state="translated">在创建数据目录锁文件时,等待读取。</target>
        </trans-unit>
        <trans-unit id="22b6a17e9f6b4570d83c86bfc0b1331afbfa69c0" translate="yes" xml:space="preserve">
          <source>Waiting to receive bytes from a shared message queue.</source>
          <target state="translated">等待从共享消息队列中接收字节。</target>
        </trans-unit>
        <trans-unit id="9ce53a35add68653a7082475749be3845de4e91c" translate="yes" xml:space="preserve">
          <source>Waiting to replace a page in WAL buffers.</source>
          <target state="translated">等待替换WAL缓冲区的页面。</target>
        </trans-unit>
        <trans-unit id="c84c4a6cb5ccf93e74ddb23312f4a777174ed071" translate="yes" xml:space="preserve">
          <source>Waiting to retrieve messages from the shared catalog invalidation queue.</source>
          <target state="translated">等待从共享目录无效队列中检索消息。</target>
        </trans-unit>
        <trans-unit id="e3b17dffde0ea5035f1032f34d22df0ea10ab951" translate="yes" xml:space="preserve">
          <source>Waiting to retrieve or remove messages from shared invalidation queue.</source>
          <target state="translated">等待从共享无效队列中检索或删除消息。</target>
        </trans-unit>
        <trans-unit id="4f507f65bfda2fa748e9dfb44f6b949cbab52bf9" translate="yes" xml:space="preserve">
          <source>Waiting to retrieve or store information about serializable transactions.</source>
          <target state="translated">等待检索或存储可序列化事务的信息。</target>
        </trans-unit>
        <trans-unit id="eda502d0abfb7f1427a080a8bf7103d25fc2176f" translate="yes" xml:space="preserve">
          <source>Waiting to select the starting location of a synchronized table scan.</source>
          <target state="translated">等待选择同步表扫描的起始位置。</target>
        </trans-unit>
        <trans-unit id="c9928fb30a8b9bafde30f4c1a7932ab2be3ad802" translate="yes" xml:space="preserve">
          <source>Waiting to send bytes to a shared message queue.</source>
          <target state="translated">等待向共享消息队列发送字节。</target>
        </trans-unit>
        <trans-unit id="352defc191b1b37d8d934ce574b79689999451d7" translate="yes" xml:space="preserve">
          <source>Waiting to setup, drop or use replication origin.</source>
          <target state="translated">等待设置、放弃或使用复制原点。</target>
        </trans-unit>
        <trans-unit id="25cb6ca2b8d634f565c4d46066dc5f3462003ea1" translate="yes" xml:space="preserve">
          <source>Waiting to synchronize workers during Parallel Hash Join plan execution.</source>
          <target state="translated">在并行Hash Join计划执行期间,等待同步工人。</target>
        </trans-unit>
        <trans-unit id="9266129c75950e38bd53efc5efcc13655677392e" translate="yes" xml:space="preserve">
          <source>Waiting to update &lt;code&gt;pg_database&lt;/code&gt;.&lt;code&gt;datfrozenxid&lt;/code&gt; and &lt;code&gt;pg_database&lt;/code&gt;.&lt;code&gt;datminmxid&lt;/code&gt;.</source>
          <target state="translated">等待更新 &lt;code&gt;pg_database&lt;/code&gt; 。 &lt;code&gt;datfrozenxid&lt;/code&gt; 和 &lt;code&gt;pg_database&lt;/code&gt; 。 &lt;code&gt;datminmxid&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb44735a3aba3220d386c9b3faf0ba38310b7b2b" translate="yes" xml:space="preserve">
          <source>Waiting to update limit on &lt;code&gt;NOTIFY&lt;/code&gt; message storage.</source>
          <target state="translated">等待更新 &lt;code&gt;NOTIFY&lt;/code&gt; 消息存储的限制。</target>
        </trans-unit>
        <trans-unit id="bedfd2279a25f8b35eba1268870241ba6990c56e" translate="yes" xml:space="preserve">
          <source>Waiting to update limits on transaction id and multixact consumption.</source>
          <target state="translated">等待更新交易ID和多倍消费的限制。</target>
        </trans-unit>
        <trans-unit id="99b1822a05f8be538a4edd0d27d811178799d3aa" translate="yes" xml:space="preserve">
          <source>Waiting to update the &lt;code&gt;postgresql.auto.conf&lt;/code&gt; file.</source>
          <target state="translated">等待更新 &lt;code&gt;postgresql.auto.conf&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="7f7ad4b1674906a82b48581d682f5005d47dd119" translate="yes" xml:space="preserve">
          <source>Waiting to update the relation map file used to store catalog to filenode mapping.</source>
          <target state="translated">等待更新用于存储目录到文件节点映射的关系图文件。</target>
        </trans-unit>
        <trans-unit id="8dc204f5803f3077a290dca7bb374395f034529e" translate="yes" xml:space="preserve">
          <source>Waiting to write a protocol message to a shared message queue.</source>
          <target state="translated">等待向共享消息队列写入协议消息。</target>
        </trans-unit>
        <trans-unit id="2d0728d153f9f18004a22e4fb271924454b6a556" translate="yes" xml:space="preserve">
          <source>Waiting to write data to the client.</source>
          <target state="translated">等待向客户端写入数据。</target>
        </trans-unit>
        <trans-unit id="65a1974782cb646a2959736cb6599731cefd99f2" translate="yes" xml:space="preserve">
          <source>Waiting to write zero bytes to a dynamic shared memory backing file.</source>
          <target state="translated">等待向动态共享内存备份文件写入零字节。</target>
        </trans-unit>
        <trans-unit id="0929df55dd9f72fd6c1d910f07bdae3bd6e941bb" translate="yes" xml:space="preserve">
          <source>Warm and hot standby servers can be kept current by reading a stream of write-ahead log (WAL) records. If the main server fails, the standby contains almost all of the data of the main server, and can be quickly made the new master database server. This can be synchronous or asynchronous and can only be done for the entire database server.</source>
          <target state="translated">温热备用服务器可以通过读取写前日志(WAL)记录流来保持最新状态。如果主服务器发生故障,备用服务器几乎包含了主服务器的所有数据,可以迅速成为新的主数据库服务器。这可以是同步的,也可以是异步的,并且只能对整个数据库服务器进行。</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="a016c375864acf9c142cbb1359e053c54d4d9438" translate="yes" xml:space="preserve">
          <source>We already saw that &lt;code&gt;ORDER BY&lt;/code&gt; can be omitted if the ordering of rows is not important. It is also possible to omit &lt;code&gt;PARTITION BY&lt;/code&gt;, in which case there is a single partition containing all rows.</source>
          <target state="translated">我们已经看到，如果行的顺序不重要，则可以省略 &lt;code&gt;ORDER BY&lt;/code&gt; 。也可以省略 &lt;code&gt;PARTITION BY&lt;/code&gt; ，在这种情况下，存在一个包含所有行的分区。</target>
        </trans-unit>
        <trans-unit id="836ee2eeb6e7ae6444006848acb871065ea3b213" translate="yes" xml:space="preserve">
          <source>We already saw the MCV information for &lt;code&gt;stringu1&lt;/code&gt;, and here is its histogram:</source>
          <target state="translated">我们已经看到了 &lt;code&gt;stringu1&lt;/code&gt; 的MCV信息，这是它的直方图：</target>
        </trans-unit>
        <trans-unit id="4916a888ae7040005cd716f2c3e28e1930fe1e1c" translate="yes" xml:space="preserve">
          <source>We also want a guarantee that once a transaction is completed and acknowledged by the database system, it has indeed been permanently recorded and won't be lost even if a crash ensues shortly thereafter. For example, if we are recording a cash withdrawal by Bob, we do not want any chance that the debit to his account will disappear in a crash just after he walks out the bank door. A transactional database guarantees that all the updates made by a transaction are logged in permanent storage (i.e., on disk) before the transaction is reported complete.</source>
          <target state="translated">我们还希望保证,一旦交易完成并被数据库系统确认,它确实已经被永久记录,即使随后不久发生崩溃,也不会丢失。例如,如果我们记录了Bob的一次现金取款,我们不希望在他走出银行大门后,他的账户中的借记就在一次崩溃中消失。事务性数据库保证在事务报告完成之前,事务所做的所有更新都被记录在永久存储中(即磁盘上)。</target>
        </trans-unit>
        <trans-unit id="6743dd465747bd2e107f6841f4c88e12a10fdc63" translate="yes" xml:space="preserve">
          <source>We can also access arbitrary rectangular slices of an array, or subarrays. An array slice is denoted by writing &lt;code&gt;lower-bound:upper-bound&lt;/code&gt; for one or more array dimensions. For example, this query retrieves the first item on Bill's schedule for the first two days of the week:</source>
          <target state="translated">我们还可以访问数组或子数组的任意矩形切片。数组切片通过为一个或多个数组维编写 &lt;code&gt;lower-bound:upper-bound&lt;/code&gt; 来表示。例如，此查询在一周的前两天检索比尔时间表中的第一项：</target>
        </trans-unit>
        <trans-unit id="26d5e00c2932aa021f71e1c7987bbc84382d9b85" translate="yes" xml:space="preserve">
          <source>We can also choose to return &lt;code&gt;NULL&lt;/code&gt;, instead of the lower-cased word, if it is not found in the stop words file. This behavior is selected by setting the dictionary's &lt;code&gt;Accept&lt;/code&gt; parameter to &lt;code&gt;false&lt;/code&gt;. Continuing the example:</source>
          <target state="translated">如果在停用词文件中找不到 &lt;code&gt;NULL&lt;/code&gt; ，则我们也可以选择返回NULL，而不是小写单词。通过将字典的 &lt;code&gt;Accept&lt;/code&gt; 参数设置为 &lt;code&gt;false&lt;/code&gt; 可以选择此行为。继续示例：</target>
        </trans-unit>
        <trans-unit id="dfd312f5fc4d67101d851237062bdba159c0ec59" translate="yes" xml:space="preserve">
          <source>We can also join a table against itself. This is called a &lt;em&gt;self join&lt;/em&gt;. As an example, suppose we wish to find all the weather records that are in the temperature range of other weather records. So we need to compare the &lt;code&gt;temp_lo&lt;/code&gt; and &lt;code&gt;temp_hi&lt;/code&gt; columns of each &lt;code&gt;weather&lt;/code&gt; row to the &lt;code&gt;temp_lo&lt;/code&gt; and &lt;code&gt;temp_hi&lt;/code&gt; columns of all other &lt;code&gt;weather&lt;/code&gt; rows. We can do this with the following query:</source>
          <target state="translated">我们还可以针对自己加入表格。这称为&lt;em&gt;自连接&lt;/em&gt;。例如，假设我们希望找到其他天气记录的温度范围内的所有天气记录。因此，我们需要比较 &lt;code&gt;temp_lo&lt;/code&gt; 和 &lt;code&gt;temp_hi&lt;/code&gt; 每列 &lt;code&gt;weather&lt;/code&gt; 一行到 &lt;code&gt;temp_lo&lt;/code&gt; 和 &lt;code&gt;temp_hi&lt;/code&gt; 所有其他列 &lt;code&gt;weather&lt;/code&gt; 行。我们可以使用以下查询来做到这一点：</target>
        </trans-unit>
        <trans-unit id="4dc6beb3b0e1bef62d183184143ea3d3ef810b4c" translate="yes" xml:space="preserve">
          <source>We can change the rewriting rules just by updating the table:</source>
          <target state="translated">我们可以通过更新表来改变改写规则。</target>
        </trans-unit>
        <trans-unit id="ee2618785314089b8d336377e9a207db9405d3b4" translate="yes" xml:space="preserve">
          <source>We can create a GIN index (&lt;a href=&quot;textsearch-indexes&quot;&gt;Section 12.9&lt;/a&gt;) to speed up text searches:</source>
          <target state="translated">我们可以创建一个GIN索引（&lt;a href=&quot;textsearch-indexes&quot;&gt;第12.9节&lt;/a&gt;）来加速文本搜索：</target>
        </trans-unit>
        <trans-unit id="c7821bbb704a2ac952eb9690616bfdd424400d47" translate="yes" xml:space="preserve">
          <source>We can do inheritance:</source>
          <target state="translated">我们可以做继承。</target>
        </trans-unit>
        <trans-unit id="d91685339d290a8a5e3f0243e992defd515e095f" translate="yes" xml:space="preserve">
          <source>We can then see that an administrator connecting over a network will not see any records, due to the restrictive policy:</source>
          <target state="translated">然后我们可以看到,由于限制性策略,通过网络连接的管理员将看不到任何记录。</target>
        </trans-unit>
        <trans-unit id="9e7ee16addc76bca0dc0a634456700165327da1e" translate="yes" xml:space="preserve">
          <source>We can update an individual subfield of a composite column:</source>
          <target state="translated">我们可以更新复合列的单个子字段。</target>
        </trans-unit>
        <trans-unit id="dbaecdebc4248cd30d99181acc6ee4648ce55281" translate="yes" xml:space="preserve">
          <source>We choose not to index or search some token types that the built-in configuration does handle:</source>
          <target state="translated">我们选择不索引或搜索一些内置配置可以处理的标记类型。</target>
        </trans-unit>
        <trans-unit id="f68910847b8b293ecced82107bbdb7c9e86be5f0" translate="yes" xml:space="preserve">
          <source>We could also have written:</source>
          <target state="translated">我们也可以写。</target>
        </trans-unit>
        <trans-unit id="1af074a97ee1433a54eef949ce0f504465ee61b0" translate="yes" xml:space="preserve">
          <source>We could simplify this by creating a SQL function that inserts a label at a specified position in a path:</source>
          <target state="translated">我们可以通过创建一个在路径中指定位置插入标签的SQL函数来简化这一过程。</target>
        </trans-unit>
        <trans-unit id="10ed1bedde4f0b0f00a9838d665bf3bd179f0836" translate="yes" xml:space="preserve">
          <source>We define the synonym dictionary like this:</source>
          <target state="translated">我们对同义词词典的定义是这样的。</target>
        </trans-unit>
        <trans-unit id="d488cdbcb41070244eeea7399c07a12ab608b66e" translate="yes" xml:space="preserve">
          <source>We do not need a perfectly consistent file system backup as the starting point. Any internal inconsistency in the backup will be corrected by log replay (this is not significantly different from what happens during crash recovery). So we do not need a file system snapshot capability, just tar or a similar archiving tool.</source>
          <target state="translated">我们不需要一个完全一致的文件系统备份作为起点。备份中任何内部不一致的地方都会通过日志重放来纠正(这与崩溃恢复时的情况没有明显区别)。所以我们不需要文件系统快照功能,只需要tar或类似的归档工具。</target>
        </trans-unit>
        <trans-unit id="7d9a8fa7a3f06527b3bcf2908ca8717c376647ee" translate="yes" xml:space="preserve">
          <source>We have already discussed constants in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS&quot;&gt;Section 4.1.2&lt;/a&gt;. The following sections discuss the remaining options.</source>
          <target state="translated">我们已经在&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS&quot;&gt;4.1.2节中&lt;/a&gt;讨论了常量。以下各节讨论其余选项。</target>
        </trans-unit>
        <trans-unit id="a1ef9ac43045748116a115e49374f363a8ba372f" translate="yes" xml:space="preserve">
          <source>We know that most queries will access just the last week's, month's or quarter's data, since the main use of this table will be to prepare online reports for management. To reduce the amount of old data that needs to be stored, we decide to only keep the most recent 3 years worth of data. At the beginning of each month we will remove the oldest month's data. In this situation we can use partitioning to help us meet all of our different requirements for the measurements table.</source>
          <target state="translated">我们知道,大多数查询只会访问上周、本月或季度的数据,因为这个表的主要用途是为管理层准备在线报告。为了减少需要存储的旧数据量,我们决定只保留最近3年的数据。在每个月的月初,我们将删除最老的一个月的数据。在这种情况下,我们可以使用分区来帮助我们满足我们对测量表的所有不同要求。</target>
        </trans-unit>
        <trans-unit id="8a993aca05617d8df040114000bd6876b7a6bbb8" translate="yes" xml:space="preserve">
          <source>We know that the foreign keys disallow creation of orders that do not relate to any products. But what if a product is removed after an order is created that references it? SQL allows you to handle that as well. Intuitively, we have a few options:</source>
          <target state="translated">我们知道,外键不允许创建与任何产品无关的订单。但是如果在创建了一个引用产品的订单后,产品被删除了怎么办?SQL允许你也处理这个问题。直观地说,我们有几个选择。</target>
        </trans-unit>
        <trans-unit id="afd1ca25954ba7db5e426cd93dec87fb2f18cad3" translate="yes" xml:space="preserve">
          <source>We might hope that the data would somehow be routed to the &lt;code&gt;capitals&lt;/code&gt; table, but this does not happen: &lt;code&gt;INSERT&lt;/code&gt; always inserts into exactly the table specified. In some cases it is possible to redirect the insertion using a rule (see &lt;a href=&quot;https://www.postgresql.org/docs/12/rules.html&quot;&gt;Chapter 40&lt;/a&gt;). However that does not help for the above case because the &lt;code&gt;cities&lt;/code&gt; table does not contain the column &lt;code&gt;state&lt;/code&gt;, and so the command will be rejected before the rule can be applied.</source>
          <target state="translated">我们可能希望将数据以某种方式路由到 &lt;code&gt;capitals&lt;/code&gt; 表，但这不会发生： &lt;code&gt;INSERT&lt;/code&gt; 总是完全插入到指定的表中。在某些情况下，可以使用规则重定向插入（请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/rules.html&quot;&gt;第40章&lt;/a&gt;）。但是，这对上述情况没有帮助，因为 &lt;code&gt;cities&lt;/code&gt; 表不包含column &lt;code&gt;state&lt;/code&gt; ，因此在应用规则之前，该命令将被拒绝。</target>
        </trans-unit>
        <trans-unit id="b41ce96b205209d5c52d43184eb3122bcf4d7162" translate="yes" xml:space="preserve">
          <source>We might hope that the data would somehow be routed to the &lt;code&gt;capitals&lt;/code&gt; table, but this does not happen: &lt;code&gt;INSERT&lt;/code&gt; always inserts into exactly the table specified. In some cases it is possible to redirect the insertion using a rule (see &lt;a href=&quot;https://www.postgresql.org/docs/13/rules.html&quot;&gt;Chapter 40&lt;/a&gt;). However that does not help for the above case because the &lt;code&gt;cities&lt;/code&gt; table does not contain the column &lt;code&gt;state&lt;/code&gt;, and so the command will be rejected before the rule can be applied.</source>
          <target state="translated">我们可能希望将数据以某种方式路由到 &lt;code&gt;capitals&lt;/code&gt; 表，但这不会发生： &lt;code&gt;INSERT&lt;/code&gt; 总是完全插入到指定的表中。在某些情况下，可以使用规则重定向插入（请参见&lt;a href=&quot;https://www.postgresql.org/docs/13/rules.html&quot;&gt;第40章&lt;/a&gt;）。但是，这对上述情况没有帮助，因为 &lt;code&gt;cities&lt;/code&gt; 表不包含column &lt;code&gt;state&lt;/code&gt; ，因此在应用规则之前，该命令将被拒绝。</target>
        </trans-unit>
        <trans-unit id="668bafcded25fc8a525c39fc8ba11f8e8e98aa03" translate="yes" xml:space="preserve">
          <source>We might want to insert data and have the server automatically locate the child table into which the row should be added. We could do this with a more complex trigger function, for example:</source>
          <target state="translated">我们可能想插入数据,并让服务器自动定位子表,将该行添加到子表中。我们可以通过一个更复杂的触发函数来实现,比如说。</target>
        </trans-unit>
        <trans-unit id="1aa4d9dcdf43d5b53cef629cb08b1cf507249faa" translate="yes" xml:space="preserve">
          <source>We must redefine the trigger function each month so that it always points to the current child table. The trigger definition does not need to be updated, however.</source>
          <target state="translated">我们必须每个月重新定义触发函数,使其始终指向当前的子表。不过,触发器定义不需要更新。</target>
        </trans-unit>
        <trans-unit id="1597c32eb07ab6cca066ebab3e65392f57896307" translate="yes" xml:space="preserve">
          <source>We recommend that active production databases be vacuumed frequently (at least nightly), in order to remove dead rows. After adding or deleting a large number of rows, it might be a good idea to issue a &lt;code&gt;VACUUM ANALYZE&lt;/code&gt; command for the affected table. This will update the system catalogs with the results of all recent changes, and allow the PostgreSQL query planner to make better choices in planning queries.</source>
          <target state="translated">我们建议经常（至少每晚）对活动的生产数据库进行清理，以删除死行。添加或删除大量行后，最好对受影响的表发出 &lt;code&gt;VACUUM ANALYZE&lt;/code&gt; 命令。这将使用所有最近更改的结果来更新系统目录，并允许PostgreSQL查询计划程序在计划查询时做出更好的选择。</target>
        </trans-unit>
        <trans-unit id="4e67abf5ade818ba6d22ea4bc6d74fa648515393" translate="yes" xml:space="preserve">
          <source>We reject the &lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt; command across the board, because any module loaded could easily circumvent security policy enforcement.</source>
          <target state="translated">我们拒绝全面执行&lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt;命令，因为任何加载的模块都可以轻松绕过安全策略的实施。</target>
        </trans-unit>
        <trans-unit id="977603731abefa85626583cf9841c1f7f86bb5c7" translate="yes" xml:space="preserve">
          <source>We require the index access method to apply these tests itself, which means that it must reach into the heap to check the commit status of any row that is shown to have a duplicate key according to the index contents. This is without a doubt ugly and non-modular, but it saves redundant work: if we did a separate probe then the index lookup for a conflicting row would be essentially repeated while finding the place to insert the new row's index entry. What's more, there is no obvious way to avoid race conditions unless the conflict check is an integral part of insertion of the new index entry.</source>
          <target state="translated">我们要求索引访问方法自己应用这些测试,这意味着它必须深入到堆中,根据索引内容检查任何显示有重复键的行的提交状态。这无疑是丑陋的、非模式化的,但它节省了多余的工作:如果我们做一个单独的探针,那么对冲突行的索引查找基本上是重复的,同时还要找到插入新行索引项的地方。更重要的是,没有明显的方法来避免竞赛条件,除非冲突检查是插入新索引条目的一个组成部分。</target>
        </trans-unit>
        <trans-unit id="61809ffaa1e9bec3b74e00f63e536c6b27a9b1ac" translate="yes" xml:space="preserve">
          <source>We say that in this situation the orders table is the &lt;em&gt;referencing&lt;/em&gt; table and the products table is the &lt;em&gt;referenced&lt;/em&gt; table. Similarly, there are referencing and referenced columns.</source>
          <target state="translated">我们说在这种情况下，订单表是&lt;em&gt;引用&lt;/em&gt;表，产品表是&lt;em&gt;引用&lt;/em&gt;表。同样，也有引用和引用列。</target>
        </trans-unit>
        <trans-unit id="926fa8d618ecd63d98d203881339877369fb9e8a" translate="yes" xml:space="preserve">
          <source>We say that the first two constraints are column constraints, whereas the third one is a table constraint because it is written separately from any one column definition. Column constraints can also be written as table constraints, while the reverse is not necessarily possible, since a column constraint is supposed to refer to only the column it is attached to. (PostgreSQL doesn't enforce that rule, but you should follow it if you want your table definitions to work with other database systems.) The above example could also be written as:</source>
          <target state="translated">我们说前两个约束是列约束,而第三个约束是表约束,因为它是与任何一个列定义分开写的。列约束也可以写成表约束,而反过来就不一定了,因为一个列约束应该只指它所连接的列。(PostgreSQL并没有强制执行这个规则,但如果你想让你的表定义与其他数据库系统一起工作,你就应该遵循这个规则)。上面的例子也可以写成</target>
        </trans-unit>
        <trans-unit id="61ad12c01cac6b9fd7b6ff658816ff5bf8b904a2" translate="yes" xml:space="preserve">
          <source>We store these documents in a table named &lt;code&gt;api&lt;/code&gt;, in a &lt;code&gt;jsonb&lt;/code&gt; column named &lt;code&gt;jdoc&lt;/code&gt;. If a GIN index is created on this column, queries like the following can make use of the index:</source>
          <target state="translated">我们将这些文档存储在名为 &lt;code&gt;api&lt;/code&gt; 的表中，位于名为 &lt;code&gt;jdoc&lt;/code&gt; 的 &lt;code&gt;jsonb&lt;/code&gt; 列中。如果在此列上创建了GIN索引，则如下查询可以利用该索引：</target>
        </trans-unit>
        <trans-unit id="c00287a4e7374c9957df5b25550d2f8b5bf2d466" translate="yes" xml:space="preserve">
          <source>We use the following terms below: The &lt;em&gt;precision&lt;/em&gt; of a &lt;code&gt;numeric&lt;/code&gt; is the total count of significant digits in the whole number, that is, the number of digits to both sides of the decimal point. The &lt;em&gt;scale&lt;/em&gt; of a &lt;code&gt;numeric&lt;/code&gt; is the count of decimal digits in the fractional part, to the right of the decimal point. So the number 23.5141 has a precision of 6 and a scale of 4. Integers can be considered to have a scale of zero.</source>
          <target state="translated">我们用下面的以下条款：该&lt;em&gt;精度&lt;/em&gt; A的 &lt;code&gt;numeric&lt;/code&gt; 是在整个数显著数字的总数，也就是数字小数点两边的号码。该&lt;em&gt;规模&lt;/em&gt;一的 &lt;code&gt;numeric&lt;/code&gt; 是小数部分十进制数字的计数，小数点右边。因此，数字23.5141的精度为6，小数位数为4。可以将整数视为小数位数为零。</target>
        </trans-unit>
        <trans-unit id="c61d0c97e5f7c008c140e2ad3c2ca5a1fbcdb590" translate="yes" xml:space="preserve">
          <source>We use the non-partitioned &lt;code&gt;measurement&lt;/code&gt; table above. To implement partitioning using inheritance, use the following steps:</source>
          <target state="translated">我们使用上面未分区的 &lt;code&gt;measurement&lt;/code&gt; 表。要使用继承实现分区，请使用以下步骤：</target>
        </trans-unit>
        <trans-unit id="a22e103a166cab5bebeb6c6bf8216ec0f41d1ce6" translate="yes" xml:space="preserve">
          <source>We use the same &lt;code&gt;measurement&lt;/code&gt; table we used above. To implement partitioning using inheritance, use the following steps:</source>
          <target state="translated">我们使用与上面相同的 &lt;code&gt;measurement&lt;/code&gt; 表。要使用继承实现分区，请使用以下步骤：</target>
        </trans-unit>
        <trans-unit id="87bb5356e299e65f3820ac3133d7b4e088f6bde2" translate="yes" xml:space="preserve">
          <source>We use the word &lt;em&gt;item&lt;/em&gt; to refer to a composite value that is to be indexed, and the word &lt;em&gt;key&lt;/em&gt; to refer to an element value. GIN always stores and searches for keys, not item values per se.</source>
          <target state="translated">我们使用单词&lt;em&gt;item&lt;/em&gt;来引用要索引的复合值，并使用单词&lt;em&gt;key&lt;/em&gt;来引用元素值。GIN总是存储和搜索键，而不是项值本身。</target>
        </trans-unit>
        <trans-unit id="aaac10448fb5e7278bf16580755bd9621bfb54f1" translate="yes" xml:space="preserve">
          <source>We want our application to be able to say &lt;code&gt;INSERT INTO measurement ...&lt;/code&gt; and have the data be redirected into the appropriate child table. We can arrange that by attaching a suitable trigger function to the master table. If data will be added only to the latest child, we can use a very simple trigger function:</source>
          <target state="translated">我们希望我们的应用程序能够说出 &lt;code&gt;INSERT INTO measurement ...&lt;/code&gt; 并将数据重定向到适当的子表中。我们可以通过在主表上附加合适的触发函数来安排它。如果仅将数据添加到最新的子级，则可以使用非常简单的触发函数：</target>
        </trans-unit>
        <trans-unit id="cdc05935dfdf1c41e4dbff177f8b502be331c045" translate="yes" xml:space="preserve">
          <source>We will use a PostgreSQL-specific synonym list and store it in &lt;code&gt;$SHAREDIR/tsearch_data/pg_dict.syn&lt;/code&gt;. The file contents look like:</source>
          <target state="translated">我们将使用特定于PostgreSQL的同义词列表，并将其存储在 &lt;code&gt;$SHAREDIR/tsearch_data/pg_dict.syn&lt;/code&gt; 。文件内容如下：</target>
        </trans-unit>
        <trans-unit id="963adbfe40be253cf091e436ca27447ef3a470bc" translate="yes" xml:space="preserve">
          <source>Wed, Weds</source>
          <target state="translated">星期三,星期三</target>
        </trans-unit>
        <trans-unit id="5656b9b79b0316fc611a9c30d2ffac25228b8371" translate="yes" xml:space="preserve">
          <source>Wednesday</source>
          <target state="translated">Wednesday</target>
        </trans-unit>
        <trans-unit id="7d75266a53b99ce4d80d337862ea1edd8ba1b1a1" translate="yes" xml:space="preserve">
          <source>Weeks</source>
          <target state="translated">Weeks</target>
        </trans-unit>
        <trans-unit id="fdeddc33f6adb1db2fc6d6142f8a57019f70774f" translate="yes" xml:space="preserve">
          <source>Weights are typically used to reflect document structure, for example by marking title words differently from body words. Text search ranking functions can assign different priorities to the different weight markers.</source>
          <target state="translated">权重通常用于反映文档结构,例如通过对标题词和正文词进行不同的标记。文本搜索排名功能可以为不同的权重标记分配不同的优先级。</target>
        </trans-unit>
        <trans-unit id="683c9370be61bfcd03e58355d7c86c6e1369d2d9" translate="yes" xml:space="preserve">
          <source>Western European</source>
          <target state="translated">西欧</target>
        </trans-unit>
        <trans-unit id="e82bc7cf6e54b2e4257e788dff104c1e42da4e0b" translate="yes" xml:space="preserve">
          <source>What Is JIT compilation?</source>
          <target state="translated">什么是JIT编译?</target>
        </trans-unit>
        <trans-unit id="9d446878c466219c122696ab7b32c54ff789d87e" translate="yes" xml:space="preserve">
          <source>What Is JIT compilation?: Inlining</source>
          <target state="translated">什么是JIT编译?内联</target>
        </trans-unit>
        <trans-unit id="ca44cc7300ef1dcac2b672637a01e3b0a0da90f7" translate="yes" xml:space="preserve">
          <source>What Is JIT compilation?: JIT Accelerated Operations</source>
          <target state="translated">什么是JIT编译?JIT加速作业</target>
        </trans-unit>
        <trans-unit id="760d95b57cc4647ff2722b6cf5ee7f34082cc25e" translate="yes" xml:space="preserve">
          <source>What Is JIT compilation?: Optimization</source>
          <target state="translated">什么是JIT编译?优化</target>
        </trans-unit>
        <trans-unit id="6026d88e883e805146a8bbfee4583738ccfd77d8" translate="yes" xml:space="preserve">
          <source>What Is the &amp;ldquo;Transaction&amp;rdquo; Actually Performed in pgbench?</source>
          <target state="translated">pgbench中实际执行的&amp;ldquo;事务&amp;rdquo;是什么？</target>
        </trans-unit>
        <trans-unit id="6c8a97eccbb7e55f60d7659738855ee30c65e97d" translate="yes" xml:space="preserve">
          <source>What has really happened here is that the two unknown literals are resolved to &lt;code&gt;text&lt;/code&gt; by default, allowing the &lt;code&gt;||&lt;/code&gt; operator to be resolved as &lt;code&gt;text&lt;/code&gt; concatenation. Then the &lt;code&gt;text&lt;/code&gt; result of the operator is converted to &lt;code&gt;bpchar&lt;/code&gt; (&amp;ldquo;blank-padded char&amp;rdquo;, the internal name of the &lt;code&gt;character&lt;/code&gt; data type) to match the target column type. (Since the conversion from &lt;code&gt;text&lt;/code&gt; to &lt;code&gt;bpchar&lt;/code&gt; is binary-coercible, this conversion does not insert any real function call.) Finally, the sizing function &lt;code&gt;bpchar(bpchar, integer, boolean)&lt;/code&gt; is found in the system catalog and applied to the operator's result and the stored column length. This type-specific function performs the required length check and addition of padding spaces.</source>
          <target state="translated">真正发生的是，默认情况下，两个未知文字被解析为 &lt;code&gt;text&lt;/code&gt; ，从而允许 &lt;code&gt;||&lt;/code&gt; 。要解析为 &lt;code&gt;text&lt;/code&gt; 串联的运算符。然后，将运算符的 &lt;code&gt;text&lt;/code&gt; 结果转换为 &lt;code&gt;bpchar&lt;/code&gt; （&amp;ldquo;空白字符&amp;rdquo;， &lt;code&gt;character&lt;/code&gt; 数据类型的内部名称）以匹配目标列类型。 （由于从 &lt;code&gt;text&lt;/code&gt; 到 &lt;code&gt;bpchar&lt;/code&gt; 的转换是二进制强制的，因此此转换不会插入任何实函数调用。）最后，调整大小的函数 &lt;code&gt;bpchar(bpchar, integer, boolean)&lt;/code&gt; 可在系统目录中找到，并应用于操作员的结果和存储的列长。此特定于类型的功能执行所需的长度检查并添加填充空间。</target>
        </trans-unit>
        <trans-unit id="dfcede4e6134968fca6be5ab22337a4021df7d2f" translate="yes" xml:space="preserve">
          <source>What is a &amp;ldquo;system user&amp;rdquo; is determined at systemd compile time from the &lt;code&gt;SYS_UID_MAX&lt;/code&gt; setting in &lt;code&gt;/etc/login.defs&lt;/code&gt;.</source>
          <target state="translated">什么是&amp;ldquo;系统用户&amp;rdquo;，是在系统编译时根据 &lt;code&gt;/etc/login.defs&lt;/code&gt; 中的 &lt;code&gt;SYS_UID_MAX&lt;/code&gt; 设置确定的。</target>
        </trans-unit>
        <trans-unit id="c3b062bdc5b358d8bc1d0ea5b87500675ecf488c" translate="yes" xml:space="preserve">
          <source>What is essentially happening here is a join between &lt;code&gt;films&lt;/code&gt; and &lt;code&gt;producers&lt;/code&gt;, with all successfully joined &lt;code&gt;films&lt;/code&gt; rows being marked for deletion. This syntax is not standard. A more standard way to do it is:</source>
          <target state="translated">这实际上是 &lt;code&gt;films&lt;/code&gt; 和 &lt;code&gt;producers&lt;/code&gt; 之间的结合，所有成功加入的 &lt;code&gt;films&lt;/code&gt; 行都标记为删除。此语法不是标准语法。一个更标准的方法是：</target>
        </trans-unit>
        <trans-unit id="e6eec3dfd99f17e2a6e53d2f854ed352bd2c2826" translate="yes" xml:space="preserve">
          <source>What locales are available on your system under what names depends on what was provided by the operating system vendor and what was installed. On most Unix systems, the command &lt;code&gt;locale -a&lt;/code&gt; will provide a list of available locales. Windows uses more verbose locale names, such as &lt;code&gt;German_Germany&lt;/code&gt; or &lt;code&gt;Swedish_Sweden.1252&lt;/code&gt;, but the principles are the same.</source>
          <target state="translated">系统上以什么名称提供的哪些语言环境取决于操作系统供应商提供的内容和安装的内容。在大多数Unix系统上，命令 &lt;code&gt;locale -a&lt;/code&gt; 将提供可用语言环境的列表。 Windows使用更详细的语言环境名称，例如 &lt;code&gt;German_Germany&lt;/code&gt; 或 &lt;code&gt;Swedish_Sweden.1252&lt;/code&gt; ，但是原理是相同的。</target>
        </trans-unit>
        <trans-unit id="40680439c20fb6866bd543023ba55a7dbd37c92b" translate="yes" xml:space="preserve">
          <source>What this does is to record the links created by pg_upgrade's link mode that connect files in the old and new clusters on the primary server. It then finds matching files in the standby's old cluster and creates links for them in the standby's new cluster. Files that were not linked on the primary are copied from the primary to the standby. (They are usually small.) This provides rapid standby upgrades. Unfortunately, rsync needlessly copies files associated with temporary and unlogged tables because these files don't normally exist on standby servers.</source>
          <target state="translated">这样做的目的是记录pg_upgrade的链接模式所创建的链接,这些链接连接了主服务器上新旧集群中的文件,然后在备用服务器的旧集群中找到匹配的文件,并在备用服务器的新集群中为它们创建链接。然后在备用服务器的旧集群中找到匹配的文件,并在备用服务器的新集群中为它们创建链接。在主服务器上没有链接的文件将从主服务器复制到备用服务器。(它们通常很小。)这提供了快速的备用升级。不幸的是,rsync不必要地复制与临时表和未记录表相关的文件,因为这些文件通常不存在于备用服务器上。</target>
        </trans-unit>
        <trans-unit id="a446c8d9e480b9f0f6cbcd76fef7e2bcda6c700b" translate="yes" xml:space="preserve">
          <source>What's more, when you load data into a table with existing foreign key constraints, each new row requires an entry in the server's list of pending trigger events (since it is the firing of a trigger that checks the row's foreign key constraint). Loading many millions of rows can cause the trigger event queue to overflow available memory, leading to intolerable swapping or even outright failure of the command. Therefore it may be &lt;em&gt;necessary&lt;/em&gt;, not just desirable, to drop and re-apply foreign keys when loading large amounts of data. If temporarily removing the constraint isn't acceptable, the only other recourse may be to split up the load operation into smaller transactions.</source>
          <target state="translated">而且，将数据加载到具有现有外键约束的表中时，每个新行都需要在服务器的未决触发事件列表中添加一个条目（因为触发该行的触发器会检查该行的外键约束）。加载数百万行可能会导致触发事件队列溢出可用内存，从而导致无法忍受的交换甚至是命令的彻底失败。因此，在加载大量数据时，可能有&lt;em&gt;必要&lt;/em&gt;（不只是希望）删除并重新应用外键。如果暂时删除约束是不可接受的，则唯一的其他方法可能是将装入操作拆分为较小的事务。</target>
        </trans-unit>
        <trans-unit id="f0604f8d2119324fb427a16a8668c529701bc1a2" translate="yes" xml:space="preserve">
          <source>Whatever data was in the column disappears. Table constraints involving the column are dropped, too. However, if the column is referenced by a foreign key constraint of another table, PostgreSQL will not silently drop that constraint. You can authorize dropping everything that depends on the column by adding &lt;code&gt;CASCADE&lt;/code&gt;:</source>
          <target state="translated">列中的所有数据都会消失。涉及该列的表约束也被删除。但是，如果该列被另一个表的外键约束引用，则PostgreSQL将不会默默地删除该约束。您可以通过添加 &lt;code&gt;CASCADE&lt;/code&gt; 来授权删除所有依赖于该列的内容：</target>
        </trans-unit>
        <trans-unit id="769bb19e615b7f8e2809e5882e2d05a18f57a531" translate="yes" xml:space="preserve">
          <source>When</source>
          <target state="translated">When</target>
        </trans-unit>
        <trans-unit id="a60fe559ad2643627bd47ea3eceb6f63037101eb" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;runtime-config-logging#GUC-LOG-LOCK-WAITS&quot;&gt;log_lock_waits&lt;/a&gt; is set, this parameter also determines the amount of time to wait before a log message is issued about the lock wait. If you are trying to investigate locking delays you might want to set a shorter than normal &lt;code&gt;deadlock_timeout&lt;/code&gt;.</source>
          <target state="translated">当&lt;a href=&quot;runtime-config-logging#GUC-LOG-LOCK-WAITS&quot;&gt;log_lock_waits&lt;/a&gt;被设置时，这个参数也决定的时间量，以等待发出关于锁等待一个日志消息之前。如果尝试调查锁定延迟，则可能需要设置比正常的 &lt;code&gt;deadlock_timeout&lt;/code&gt; 短的时间。</target>
        </trans-unit>
        <trans-unit id="48421d6240bf9ea87a63b5a2373cb0ad9cf5cd58" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--include-foreign-data&lt;/code&gt; is specified, pg_dump does not check that the foreign table is writable. Therefore, there is no guarantee that the results of a foreign table dump can be successfully restored.</source>
          <target state="translated">当指定 &lt;code&gt;--include-foreign-data&lt;/code&gt; 时，pg_dump不会检查外部表是否可写。因此，不能保证可以成功还原外部表转储的结果。</target>
        </trans-unit>
        <trans-unit id="57e37b6a94a28e9acbd6287be1d60c38f8541fd8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--source-server&lt;/code&gt; option is used, pg_rewind also uses the environment variables supported by libpq (see &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;).</source>
          <target state="translated">当使用 &lt;code&gt;--source-server&lt;/code&gt; 选项时，pg_rewind也使用libpq支持的环境变量（参见&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;第33.14节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2797c2b01f0d49dcbbe6a48419d9e0d238c086dc" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--source-server&lt;/code&gt; option is used, pg_rewind also uses the environment variables supported by libpq (see &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;).</source>
          <target state="translated">当使用 &lt;code&gt;--source-server&lt;/code&gt; 选项时，pg_rewind也使用libpq支持的环境变量（请参见&lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-envars.html&quot;&gt;第33.14节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1854281aa73e4f5b1f721e95b9f05123b0ade134" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-n&lt;/code&gt; is specified, pg_dump makes no attempt to dump any other database objects that the selected schema(s) might depend upon. Therefore, there is no guarantee that the results of a specific-schema dump can be successfully restored by themselves into a clean database.</source>
          <target state="translated">当指定 &lt;code&gt;-n&lt;/code&gt; 时，pg_dump不会尝试转储所选模式可能依赖的任何其他数据库对象。因此，不能保证特定模式转储的结果可以自己成功地恢复到干净的数据库中。</target>
        </trans-unit>
        <trans-unit id="5fef81c501efe3e088f4b73c9a697af2561cb6dc" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-t&lt;/code&gt; is specified, pg_dump makes no attempt to dump any other database objects that the selected table(s) might depend upon. Therefore, there is no guarantee that the results of a specific-table dump can be successfully restored by themselves into a clean database.</source>
          <target state="translated">当指定 &lt;code&gt;-t&lt;/code&gt; 时，pg_dump不会尝试转储所选表可能依赖的任何其他数据库对象。因此，不能保证自己可以成功地将特定表转储的结果还原到干净的数据库中。</target>
        </trans-unit>
        <trans-unit id="8c86589858bd9989813c8435013ddbc1a41c69f7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-t&lt;/code&gt; is specified, pg_restore makes no attempt to restore any other database objects that the selected table(s) might depend upon. Therefore, there is no guarantee that a specific-table restore into a clean database will succeed.</source>
          <target state="translated">当 &lt;code&gt;-t&lt;/code&gt; 指定的，那么pg_restore没有试图还原任何其他数据库对象的选择的表（一个或多个）可能取决于。因此，不能保证将特定表还原到干净的数据库将成功。</target>
        </trans-unit>
        <trans-unit id="6dd3feb588f68391e70d37037327ad64b7721fd7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;ALTER&lt;/code&gt; command is executed, &lt;code&gt;setattr&lt;/code&gt; will be checked on the object being modified for each object types, except for subsidiary objects such as the indexes or triggers of a table, where permissions are instead checked on the parent object. In some cases, additional permissions are required:</source>
          <target state="translated">当执行 &lt;code&gt;ALTER&lt;/code&gt; 命令时，将针对每种对象类型在要修改的对象上检查 &lt;code&gt;setattr&lt;/code&gt; ，但子对象（如表的索引或触发器）除外，在子对象上将检查父对象的权限。在某些情况下，需要其他权限：</target>
        </trans-unit>
        <trans-unit id="95ea06756271ccb08739b45bacb4e5cf14e003e6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;CREATE INDEX&lt;/code&gt; is invoked on a partitioned table, the default behavior is to recurse to all partitions to ensure they all have matching indexes. Each partition is first checked to determine whether an equivalent index already exists, and if so, that index will become attached as a partition index to the index being created, which will become its parent index. If no matching index exists, a new index will be created and automatically attached; the name of the new index in each partition will be determined as if no index name had been specified in the command. If the &lt;code&gt;ONLY&lt;/code&gt; option is specified, no recursion is done, and the index is marked invalid. (&lt;code&gt;ALTER INDEX ... ATTACH PARTITION&lt;/code&gt; marks the index valid, once all partitions acquire matching indexes.) Note, however, that any partition that is created in the future using &lt;code&gt;CREATE TABLE ... PARTITION OF&lt;/code&gt; will automatically have a matching index, regardless of whether &lt;code&gt;ONLY&lt;/code&gt; is specified.</source>
          <target state="translated">在分区表上调用 &lt;code&gt;CREATE INDEX&lt;/code&gt; 时，默认行为是递归到所有分区，以确保它们都具有匹配的索引。首先检查每个分区以确定是否已存在等效索引，如果存在，则该索引将作为分区索引附加到要创建的索引，该索引将成为其父索引。如果不存在匹配的索引，将创建一个新索引并自动将其附加；将确定每个分区中新索引的名称，就像在命令中未指定索引名称一样。如果指定了 &lt;code&gt;ONLY&lt;/code&gt; 选项，则不执行任何递归操作，并将索引标记为无效。 （ &lt;code&gt;ALTER INDEX ... ATTACH PARTITION&lt;/code&gt; 一旦所有分区都获得了匹配的索引，就将该索引标记为有效。）但是，请注意，以后使用 &lt;code&gt;CREATE TABLE ... PARTITION OF&lt;/code&gt; 创建的任何分区都会自动具有匹配的索引，而不管是否指定了 &lt;code&gt;ONLY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0c15e2e86d36f47a57239a8f802301f2d222dbb6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; is used to replace an existing function, the ownership and permissions of the function do not change. All other function properties are assigned the values specified or implied in the command. You must own the function to replace it (this includes being a member of the owning role).</source>
          <target state="translated">使用 &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; 替换现有功能时，该功能的所有权和权限不会更改。所有其他功能属性都被分配了命令中指定或隐含的值。您必须拥有替换该功能的功能（包括成为拥有角色的成员）。</target>
        </trans-unit>
        <trans-unit id="db55d63efcb8b5298291fde068a29837b503dfcf" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; is used to replace an existing procedure, the ownership and permissions of the procedure do not change. All other procedure properties are assigned the values specified or implied in the command. You must own the procedure to replace it (this includes being a member of the owning role).</source>
          <target state="translated">当使用 &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; 替换现有过程时，该过程的所有权和权限不会更改。所有其他过程属性都分配了命令中指定或隐含的值。您必须拥有替换它的过程（包括成为拥有角色的成员）。</target>
        </trans-unit>
        <trans-unit id="11b7e02139c0fd56fa0d0c0d7e02cacf1863b7dd" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;CREATE OR REPLACE VIEW&lt;/code&gt; is used on an existing view, only the view's defining SELECT rule is changed. Other view properties, including ownership, permissions, and non-SELECT rules, remain unchanged. You must own the view to replace it (this includes being a member of the owning role).</source>
          <target state="translated">在现有视图上使用 &lt;code&gt;CREATE OR REPLACE VIEW&lt;/code&gt; 时，仅更改视图的定义SELECT规则。其他视图属性（包括所有权，权限和非SELECT规则）保持不变。您必须拥有视图才能替换它（包括成为拥有角色的成员）。</target>
        </trans-unit>
        <trans-unit id="b2b68d33a4076adb362da4bb710ac3317fb09cf8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;DROP&lt;/code&gt; command is executed, &lt;code&gt;drop&lt;/code&gt; will be checked on the object being removed. Permissions will be also checked for objects dropped indirectly via &lt;code&gt;CASCADE&lt;/code&gt;. Deletion of objects contained within a particular schema (tables, views, sequences and procedures) additionally requires &lt;code&gt;remove_name&lt;/code&gt; on the schema.</source>
          <target state="translated">当执行 &lt;code&gt;DROP&lt;/code&gt; 命令时，将检查要删除的对象是否 &lt;code&gt;drop&lt;/code&gt; 。还将检查通过 &lt;code&gt;CASCADE&lt;/code&gt; 间接删除的对象的权限。删除特定模式（表，视图，序列和过程）中包含的对象还需要 &lt;code&gt;remove_name&lt;/code&gt; 上的remove_name。</target>
        </trans-unit>
        <trans-unit id="f47c9d6dc4a8942d1dd522d4978fe59346f8ad48" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;GROUP BY&lt;/code&gt; is present, or any aggregate functions are present, it is not valid for the &lt;code&gt;SELECT&lt;/code&gt; list expressions to refer to ungrouped columns except within aggregate functions or when the ungrouped column is functionally dependent on the grouped columns, since there would otherwise be more than one possible value to return for an ungrouped column. A functional dependency exists if the grouped columns (or a subset thereof) are the primary key of the table containing the ungrouped column.</source>
          <target state="translated">当存在 &lt;code&gt;GROUP BY&lt;/code&gt; 或存在任何聚合函数时， &lt;code&gt;SELECT&lt;/code&gt; 列表表达式除非在聚合函数内或未分组的列在功能上取决于分组的列时，否则引用无效分组的列无效，因为否则会更多一个未分组的列返回一个可能的值。如果分组的列（或其子集）是包含未分组的列的表的主键，则存在功能依赖性。</target>
        </trans-unit>
        <trans-unit id="a61a8feeb668ae119fbcd691b6fc8464f954d0c9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;NOTIFY&lt;/code&gt; is used to signal the occurrence of changes to a particular table, a useful programming technique is to put the &lt;code&gt;NOTIFY&lt;/code&gt; in a statement trigger that is triggered by table updates. In this way, notification happens automatically when the table is changed, and the application programmer cannot accidentally forget to do it.</source>
          <target state="translated">当使用 &lt;code&gt;NOTIFY&lt;/code&gt; 来表示特定表发生更改时，一种有用的编程技术是将 &lt;code&gt;NOTIFY&lt;/code&gt; 放入由表更新触发的语句触发器中。这样，当表被更改时，通知会自动发生，并且应用程序程序员不会意外忘记这样做。</target>
        </trans-unit>
        <trans-unit id="693b980fbbb477839ff0fa0e6f6f64c259b4b463" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;RESTART IDENTITY&lt;/code&gt; is specified, the implied &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt; operations are also done transactionally; that is, they will be rolled back if the surrounding transaction does not commit. Be aware that if any additional sequence operations are done on the restarted sequences before the transaction rolls back, the effects of these operations on the sequences will be rolled back, but not their effects on &lt;code&gt;currval()&lt;/code&gt;; that is, after the transaction &lt;code&gt;currval()&lt;/code&gt; will continue to reflect the last sequence value obtained inside the failed transaction, even though the sequence itself may no longer be consistent with that. This is similar to the usual behavior of &lt;code&gt;currval()&lt;/code&gt; after a failed transaction.</source>
          <target state="translated">当指定了 &lt;code&gt;RESTART IDENTITY&lt;/code&gt; 时，隐式的 &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt; 操作也将以事务方式完成；也就是说，如果周围的事务没有提交，它们将被回滚。请注意，如果在事务回滚之前对重新启动的序列执行了任何其他序列操作，则这些操作对序列的影响将被回滚，但不会对 &lt;code&gt;currval()&lt;/code&gt; 产生影响。也就是说，在事务 &lt;code&gt;currval()&lt;/code&gt; 之后，它将继续反映在失败的事务内部获得的最后一个序列值，即使序列本身可能不再与此一致。这类似于事务失败后 &lt;code&gt;currval()&lt;/code&gt; 的通常行为。</target>
        </trans-unit>
        <trans-unit id="96d946d891d853517e02080ffe41ee5e79e55c40" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;RESTART IDENTITY&lt;/code&gt; is specified, the implied &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt; operations are also done transactionally; that is, they will be rolled back if the surrounding transaction does not commit. This is unlike the normal behavior of &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt;. Be aware that if any additional sequence operations are done on the restarted sequences before the transaction rolls back, the effects of these operations on the sequences will be rolled back, but not their effects on &lt;code&gt;currval()&lt;/code&gt;; that is, after the transaction &lt;code&gt;currval()&lt;/code&gt; will continue to reflect the last sequence value obtained inside the failed transaction, even though the sequence itself may no longer be consistent with that. This is similar to the usual behavior of &lt;code&gt;currval()&lt;/code&gt; after a failed transaction.</source>
          <target state="translated">当指定了 &lt;code&gt;RESTART IDENTITY&lt;/code&gt; 时，隐式的 &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt; 操作也将以事务方式完成；也就是说，如果周围的事务没有提交，它们将被回滚。这与 &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt; 的正常行为不同。请注意，如果在事务回滚之前对重新启动的序列执行了任何其他序列操作，则这些操作对序列的影响将被回滚，但不会对 &lt;code&gt;currval()&lt;/code&gt; 产生影响。也就是说，在交易 &lt;code&gt;currval()&lt;/code&gt; 之后即使序列本身可能不再与此保持一致，它将继续反映在失败的事务中获得的最后一个序列值。这类似于事务失败后 &lt;code&gt;currval()&lt;/code&gt; 的通常行为。</target>
        </trans-unit>
        <trans-unit id="1dd38b054f6c38892cf4b53376368a92afaa9614" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; changes the mode of a constraint from &lt;code&gt;DEFERRED&lt;/code&gt; to &lt;code&gt;IMMEDIATE&lt;/code&gt;, the new mode takes effect retroactively: any outstanding data modifications that would have been checked at the end of the transaction are instead checked during the execution of the &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; command. If any such constraint is violated, the &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; fails (and does not change the constraint mode). Thus, &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; can be used to force checking of constraints to occur at a specific point in a transaction.</source>
          <target state="translated">当 &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; 将约束的模式从 &lt;code&gt;DEFERRED&lt;/code&gt; 更改为 &lt;code&gt;IMMEDIATE&lt;/code&gt; 时，新模式将追溯生效：在执行 &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; 命令时，将检查在事务结束时已检查的所有未完成的数据修改。如果违反了任何此类约束，则 &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; 会失败（并且不会更改约束模式）。因此， &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; 可用于强制检查约束以在事务的特定点发生。</target>
        </trans-unit>
        <trans-unit id="c0b169cb5b7cb17bff71441e629815508752132d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;VALUES&lt;/code&gt; is used in &lt;code&gt;INSERT&lt;/code&gt;, the values are all automatically coerced to the data type of the corresponding destination column. When it's used in other contexts, it might be necessary to specify the correct data type. If the entries are all quoted literal constants, coercing the first is sufficient to determine the assumed type for all:</source>
          <target state="translated">当 &lt;code&gt;VALUES&lt;/code&gt; 中使用 &lt;code&gt;INSERT&lt;/code&gt; ，这些值都是自动强制为相应的目的地列的数据类型。在其他上下文中使用它时，可能有必要指定正确的数据类型。如果所有条目都是用引号括起来的文字常量，则强制第一个足以确定所有假定的类型：</target>
        </trans-unit>
        <trans-unit id="45ae9ff8fa95f77c4ea16390adcefafbd4f890d9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;VERBOSE&lt;/code&gt; is specified, &lt;code&gt;ANALYZE&lt;/code&gt; emits progress messages to indicate which table is currently being processed. Various statistics about the tables are printed as well.</source>
          <target state="translated">当 &lt;code&gt;VERBOSE&lt;/code&gt; 被指定时， &lt;code&gt;ANALYZE&lt;/code&gt; 发出进度信息，指示哪个表是当前正被处理。还将打印有关表格的各种统计信息。</target>
        </trans-unit>
        <trans-unit id="14f1458fcf796362f90bd6b53ff757eaee1e2939" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;VERBOSE&lt;/code&gt; is specified, &lt;code&gt;VACUUM&lt;/code&gt; emits progress messages to indicate which table is currently being processed. Various statistics about the tables are printed as well.</source>
          <target state="translated">当 &lt;code&gt;VERBOSE&lt;/code&gt; 被指定时， &lt;code&gt;VACUUM&lt;/code&gt; 发出进度信息，指示哪个表是当前正被处理。还将打印有关表格的各种统计信息。</target>
        </trans-unit>
        <trans-unit id="f54823d23e5df73c9472414a7a83e6ba082b1ce2" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;\e&lt;/code&gt;, &lt;code&gt;\ef&lt;/code&gt;, or &lt;code&gt;\ev&lt;/code&gt; is used with a line number argument, this variable specifies the command-line argument used to pass the starting line number to the user's editor. For editors such as Emacs or vi, this is a plus sign. Include a trailing space in the value of the variable if there needs to be space between the option name and the line number. Examples:</source>
          <target state="translated">当 &lt;code&gt;\e&lt;/code&gt; ， &lt;code&gt;\ef&lt;/code&gt; 或 &lt;code&gt;\ev&lt;/code&gt; 与行号参数一起使用时，此变量指定用于将起始行号传递给用户的编辑器的命令行参数。对于Emacs或vi等编辑器，这是一个加号。如果选项名称和行号之间需要有空格，请在变量的值中包含尾随空格。例子：</target>
        </trans-unit>
        <trans-unit id="880bf87755564e46a3f310f5734ab8ac6764465b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;archive_mode&lt;/code&gt; is enabled, completed WAL segments are sent to archive storage by setting &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt;. In addition to &lt;code&gt;off&lt;/code&gt;, to disable, there are two modes: &lt;code&gt;on&lt;/code&gt;, and &lt;code&gt;always&lt;/code&gt;. During normal operation, there is no difference between the two modes, but when set to &lt;code&gt;always&lt;/code&gt; the WAL archiver is enabled also during archive recovery or standby mode. In &lt;code&gt;always&lt;/code&gt; mode, all files restored from the archive or streamed with streaming replication will be archived (again). See &lt;a href=&quot;warm-standby#CONTINUOUS-ARCHIVING-IN-STANDBY&quot;&gt;Section 26.2.9&lt;/a&gt; for details.</source>
          <target state="translated">当 &lt;code&gt;archive_mode&lt;/code&gt; 启用，完成WAL段被设置发送到归档存储&lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt;。除了 &lt;code&gt;off&lt;/code&gt; ，to disable之外，还有两种模式： &lt;code&gt;on&lt;/code&gt; 和 &lt;code&gt;always&lt;/code&gt; 。在正常操作期间，两种模式之间没有区别，但是当设置为 &lt;code&gt;always&lt;/code&gt; ，在存档恢复或待机模式下也会启用WAL存档器。在 &lt;code&gt;always&lt;/code&gt; 模式下，将从存档还原的文件或通过流复制进行流传输的所有文件都将被存档（再次）。有关详细信息，请参见&lt;a href=&quot;warm-standby#CONTINUOUS-ARCHIVING-IN-STANDBY&quot;&gt;第26.2.9节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="46cdaf5a9c68bb7dda3e95a7d23c6fce30bcf59a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;commit_delay&lt;/code&gt; is set to zero (the default), it is still possible for a form of group commit to occur, but each group will consist only of sessions that reach the point where they need to flush their commit records during the window in which the previous flush operation (if any) is occurring. At higher client counts a &amp;ldquo;gangway effect&amp;rdquo; tends to occur, so that the effects of group commit become significant even when &lt;code&gt;commit_delay&lt;/code&gt; is zero, and thus explicitly setting &lt;code&gt;commit_delay&lt;/code&gt; tends to help less. Setting &lt;code&gt;commit_delay&lt;/code&gt; can only help when (1) there are some concurrently committing transactions, and (2) throughput is limited to some degree by commit rate; but with high rotational latency this setting can be effective in increasing transaction throughput with as few as two clients (that is, a single committing client with one sibling transaction).</source>
          <target state="translated">当 &lt;code&gt;commit_delay&lt;/code&gt; 设置为零（默认值）时，仍可能发生某种形式的组提交，但是每个组将仅由会话组成，这些会话到达需要在窗口中刷新提交记录的点。发生先前的冲洗操作（如果有）。在较高的客户数量下，往往会发生&amp;ldquo;通道效应&amp;rdquo;，因此即使 &lt;code&gt;commit_delay&lt;/code&gt; 为零，组提交的影响也变得很明显，因此显式设置 &lt;code&gt;commit_delay&lt;/code&gt; 的帮助会有所减少。设置 &lt;code&gt;commit_delay&lt;/code&gt; 仅当（1）有一些同时提交的事务，并且（2）吞吐量在一定程度上受提交率限制时才有帮助；但此设置具有很高的轮转延迟，可以有效地增加多达两个客户端的事务吞吐量（即，一个提交客户端具有一个同级事务）。</target>
        </trans-unit>
        <trans-unit id="639e6544c619e9aa79e7a25d85adc789836438b5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;default_tablespace&lt;/code&gt; is set to anything but an empty string, it supplies an implicit &lt;code&gt;TABLESPACE&lt;/code&gt; clause for &lt;code&gt;CREATE TABLE&lt;/code&gt; and &lt;code&gt;CREATE INDEX&lt;/code&gt; commands that do not have an explicit one.</source>
          <target state="translated">当 &lt;code&gt;default_tablespace&lt;/code&gt; 设置为除空字符串以外的任何值时，它将为 &lt;code&gt;CREATE TABLE&lt;/code&gt; 和 &lt;code&gt;CREATE INDEX&lt;/code&gt; 命令提供隐式 &lt;code&gt;TABLESPACE&lt;/code&gt; 子句，而这些子句没有显式的子句。</target>
        </trans-unit>
        <trans-unit id="26b9fcc2ea9102afd846d23d5a3d7acf06ea6fcf" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;extractQuery&lt;/code&gt; returns a null key in &lt;code&gt;queryKeys[]&lt;/code&gt;, the corresponding &lt;code&gt;check[]&lt;/code&gt; element is true if the indexed item contains a null key; that is, the semantics of &lt;code&gt;check[]&lt;/code&gt; are like &lt;code&gt;IS NOT DISTINCT FROM&lt;/code&gt;. The &lt;code&gt;consistent&lt;/code&gt; function can examine the corresponding &lt;code&gt;nullFlags[]&lt;/code&gt; element if it needs to tell the difference between a regular value match and a null match.</source>
          <target state="translated">当 &lt;code&gt;extractQuery&lt;/code&gt; 在 &lt;code&gt;queryKeys[]&lt;/code&gt; 返回空键时，如果索引项包含空键，则对应的 &lt;code&gt;check[]&lt;/code&gt; 元素为true；否则，为false。也就是说， &lt;code&gt;check[]&lt;/code&gt; 的语义类似于 &lt;code&gt;IS NOT DISTINCT FROM&lt;/code&gt; 。如果 &lt;code&gt;consistent&lt;/code&gt; 函数需要告知常规值匹配和空匹配之间的差异，则可以检查相应的 &lt;code&gt;nullFlags[]&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="e521d3acb4576333ab5bee010106dc1a1c2bc018" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;geqo_threshold&lt;/code&gt; is exceeded, the join sequences considered are determined by heuristics, as described in &lt;a href=&quot;https://www.postgresql.org/docs/12/geqo.html&quot;&gt;Chapter 59&lt;/a&gt;. Otherwise the process is the same.</source>
          <target state="translated">&lt;code&gt;geqo_threshold&lt;/code&gt; 超过&lt;a href=&quot;https://www.postgresql.org/docs/12/geqo.html&quot;&gt;第59章&lt;/a&gt;所述，当超过geqo_threshold时，所考虑的连接序列将通过启发式方法确定。否则，过程是相同的。</target>
        </trans-unit>
        <trans-unit id="5dc55d7e2d48050cd0f6633337d76448e1d4e69c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;geqo_threshold&lt;/code&gt; is exceeded, the join sequences considered are determined by heuristics, as described in &lt;a href=&quot;https://www.postgresql.org/docs/13/geqo.html&quot;&gt;Chapter 59&lt;/a&gt;. Otherwise the process is the same.</source>
          <target state="translated">当超过 &lt;code&gt;geqo_threshold&lt;/code&gt; 时，所考虑的连接顺序由启发式方法确定，如&lt;a href=&quot;https://www.postgresql.org/docs/13/geqo.html&quot;&gt;第59章&lt;/a&gt;所述。否则，过程是相同的。</target>
        </trans-unit>
        <trans-unit id="d28ef38bf9e5530ece862031c842201d36ddd349" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter determines the directory in which log files will be created. It can be specified as an absolute path, or relative to the cluster data directory. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. The default is &lt;code&gt;log&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;logging_collector&lt;/code&gt; 启用，这个参数决定了日志文件将被创建的目录。可以将其指定为绝对路径，也可以相对于集群数据目录指定。此参数只能在 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件或服务器命令行中设置。默认值为 &lt;code&gt;log&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3acb8f6d64e7dee8bb588e16430447375cec4a1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter determines the maximum amount of time to use an individual log file, after which a new log file will be created. If this value is specified without units, it is taken as minutes. The default is 24 hours. Set to zero to disable time-based creation of new log files. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">当 &lt;code&gt;logging_collector&lt;/code&gt; 启用，这个参数决定的时候使用一个单独的日志文件，在这之后，新的日志文件将被创建的最大金额。如果指定的该值不带单位，则以分钟为单位。默认值为24小时。设置为零可禁用基于时间的新日志文件创建。此参数只能在 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件或服务器命令行中设置。</target>
        </trans-unit>
        <trans-unit id="6ba6806c5a61bd0e7df256b20d72936b6dfff344" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter determines the maximum size of an individual log file. After this amount of data has been emitted into a log file, a new log file will be created. If this value is specified without units, it is taken as kilobytes. The default is 10 megabytes. Set to zero to disable size-based creation of new log files. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">当 &lt;code&gt;logging_collector&lt;/code&gt; 被启用，此参数决定单个日志文件的最大尺寸。在将大量数据发送到日志文件之后，将创建一个新的日志文件。如果指定的该值不带单位，则以千字节为单位。默认值为10 MB。设置为零可禁用基于大小的新日志文件的创建。此参数只能在 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件或服务器命令行中设置。</target>
        </trans-unit>
        <trans-unit id="33d04df6ccc65336486b417a686759bd20169c58" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter sets the file names of the created log files. The value is treated as a &lt;code&gt;strftime&lt;/code&gt; pattern, so &lt;code&gt;%&lt;/code&gt;-escapes can be used to specify time-varying file names. (Note that if there are any time-zone-dependent &lt;code&gt;%&lt;/code&gt;-escapes, the computation is done in the zone specified by &lt;a href=&quot;runtime-config-logging#GUC-LOG-TIMEZONE&quot;&gt;log_timezone&lt;/a&gt;.) The supported &lt;code&gt;%&lt;/code&gt;-escapes are similar to those listed in the Open Group's &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html&quot;&gt;strftime&lt;/a&gt; specification. Note that the system's &lt;code&gt;strftime&lt;/code&gt; is not used directly, so platform-specific (nonstandard) extensions do not work. The default is &lt;code&gt;postgresql-%Y-%m-%d_%H%M%S.log&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;logging_collector&lt;/code&gt; 启用，这个参数设置创建的日志文件的文件名。该值被视为 &lt;code&gt;strftime&lt;/code&gt; 模式，因此 &lt;code&gt;%&lt;/code&gt; -escapes可用于指定随时间变化的文件名。 （请注意，如果存在任何与时区有关的 &lt;code&gt;%&lt;/code&gt; -escapes，则在&lt;a href=&quot;runtime-config-logging#GUC-LOG-TIMEZONE&quot;&gt;log_timezone&lt;/a&gt;指定的区域中进行计算。）支持的 &lt;code&gt;%&lt;/code&gt; -escapes与Open Group的&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html&quot;&gt;strftime&lt;/a&gt;规范中列出的％ -escapes相似。请注意，系统的 &lt;code&gt;strftime&lt;/code&gt; 不能直接使用，因此特定于平台的（非标准）扩展名不起作用。默认值为 &lt;code&gt;postgresql-%Y-%m-%d_%H%M%S.log&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de9428c551b8b57c64cfa71598ced7921a3ab10e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter sets the file names of the created log files. The value is treated as a &lt;code&gt;strftime&lt;/code&gt; pattern, so &lt;code&gt;%&lt;/code&gt;-escapes can be used to specify time-varying file names. (Note that if there are any time-zone-dependent &lt;code&gt;%&lt;/code&gt;-escapes, the computation is done in the zone specified by &lt;a href=&quot;runtime-config-logging#GUC-LOG-TIMEZONE&quot;&gt;log_timezone&lt;/a&gt;.) The supported &lt;code&gt;%&lt;/code&gt;-escapes are similar to those listed in the Open Group's &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html&quot;&gt;strftime&lt;/a&gt; specification. Note that the system's &lt;code&gt;strftime&lt;/code&gt; is not used directly, so platform-specific (nonstandard) extensions do not work. The default is &lt;code&gt;postgresql-%Y-%m-%d_%H%M%S.log&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;logging_collector&lt;/code&gt; 启用，这个参数设置创建的日志文件的文件名。该值被视为 &lt;code&gt;strftime&lt;/code&gt; 模式，因此 &lt;code&gt;%&lt;/code&gt; -escapes可用于指定随时间变化的文件名。（请注意，如果存在任何与时区相关的 &lt;code&gt;%&lt;/code&gt; -escapes，则在&lt;a href=&quot;runtime-config-logging#GUC-LOG-TIMEZONE&quot;&gt;log_timezone&lt;/a&gt;指定的区域中进行计算。）受支持的 &lt;code&gt;%&lt;/code&gt; -escapes与Open Group的&lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html&quot;&gt;strftime&lt;/a&gt;规范中列出的类似。请注意，系统的 &lt;code&gt;strftime&lt;/code&gt; 不能直接使用，因此特定于平台的（非标准）扩展名不起作用。默认值为 &lt;code&gt;postgresql-%Y-%m-%d_%H%M%S.log&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="912a8bc2db1f94954749b8b7569bc346c69e11ee" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter will cause PostgreSQL to truncate (overwrite), rather than append to, any existing log file of the same name. However, truncation will occur only when a new file is being opened due to time-based rotation, not during server startup or size-based rotation. When off, pre-existing files will be appended to in all cases. For example, using this setting in combination with a &lt;code&gt;log_filename&lt;/code&gt; like &lt;code&gt;postgresql-%H.log&lt;/code&gt; would result in generating twenty-four hourly log files and then cyclically overwriting them. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">当 &lt;code&gt;logging_collector&lt;/code&gt; 启用，该参数将导致PostgreSQL截断（覆盖），而不是附加到同名的任何现有日志文件。但是，截断仅在由于基于时间的旋转而打开新文件时发生，而不在服务器启动或基于大小的旋转过程中发生。禁用时，在所有情况下都将附加先前存在的文件。例如，结合使用此设置和 &lt;code&gt;log_filename&lt;/code&gt; (如 &lt;code&gt;postgresql-%H.log&lt;/code&gt; ),将导致每小时生成二十四个日志文件，然后周期性地覆盖它们。此参数只能在 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件或服务器命令行中设置。</target>
        </trans-unit>
        <trans-unit id="ac2a30741ea2b8dcb498e785772cf2a514f01258" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;on&lt;/code&gt; (the default), each SQL command is automatically committed upon successful completion. To postpone commit in this mode, you must enter a &lt;code&gt;BEGIN&lt;/code&gt; or &lt;code&gt;START TRANSACTION&lt;/code&gt; SQL command. When &lt;code&gt;off&lt;/code&gt; or unset, SQL commands are not committed until you explicitly issue &lt;code&gt;COMMIT&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt;. The autocommit-off mode works by issuing an implicit &lt;code&gt;BEGIN&lt;/code&gt; for you, just before any command that is not already in a transaction block and is not itself a &lt;code&gt;BEGIN&lt;/code&gt; or other transaction-control command, nor a command that cannot be executed inside a transaction block (such as &lt;code&gt;VACUUM&lt;/code&gt;).</source>
          <target state="translated">当 &lt;code&gt;on&lt;/code&gt; （默认值），每个SQL命令被自动成功完成后提交。要以这种模式推迟提交，必须输入 &lt;code&gt;BEGIN&lt;/code&gt; 或 &lt;code&gt;START TRANSACTION&lt;/code&gt; SQL命令。当 &lt;code&gt;off&lt;/code&gt; 或取消，SQL命令不会提交，直到你明确地发出 &lt;code&gt;COMMIT&lt;/code&gt; 或 &lt;code&gt;END&lt;/code&gt; 。自动提交模式通过向您发出隐式 &lt;code&gt;BEGIN&lt;/code&gt; 来工作，该隐式BEGIN紧接在尚未在事务块中且本身不是 &lt;code&gt;BEGIN&lt;/code&gt; 或其他事务控制命令的任何命令，或不能在事务块内部执行的命令之前（例如 &lt;code&gt;VACUUM&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c85a8f652ce31ff087a3b7cc628918aedc0afe36" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;pg_stat_statements&lt;/code&gt; is loaded, it tracks statistics across all databases of the server. To access and manipulate these statistics, the module provides a view, &lt;code&gt;pg_stat_statements&lt;/code&gt;, and the utility functions &lt;code&gt;pg_stat_statements_reset&lt;/code&gt; and &lt;code&gt;pg_stat_statements&lt;/code&gt;. These are not available globally but can be enabled for a specific database with &lt;code&gt;CREATE EXTENSION pg_stat_statements&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;pg_stat_statements&lt;/code&gt; 被加载，它跟踪整个服务器的所有数据库的统计数据。为了访问和处理这些统计信息，模块提供了一个视图 &lt;code&gt;pg_stat_statements&lt;/code&gt; 以及实用程序函数 &lt;code&gt;pg_stat_statements_reset&lt;/code&gt; 和 &lt;code&gt;pg_stat_statements&lt;/code&gt; 。这些不是全局可用的，但可以使用 &lt;code&gt;CREATE EXTENSION pg_stat_statements&lt;/code&gt; 为特定的数据库启用。</target>
        </trans-unit>
        <trans-unit id="5c48693eca5bd4dca7f7f71afdfbb3d41be3ea38" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;postgres_fdw&lt;/code&gt; encounters a join between foreign tables on the same foreign server, it sends the entire join to the foreign server, unless for some reason it believes that it will be more efficient to fetch rows from each table individually, or unless the table references involved are subject to different user mappings. While sending the &lt;code&gt;JOIN&lt;/code&gt; clauses, it takes the same precautions as mentioned above for the &lt;code&gt;WHERE&lt;/code&gt; clauses.</source>
          <target state="translated">当 &lt;code&gt;postgres_fdw&lt;/code&gt; 在同一外部服务器上的外部表之间遇到连接时，它将整个连接发送到外部服务器，除非出于某种原因，它认为单独从每个表中获取行会更有效，或者除非涉及到表引用服从不同的用户映射。发送 &lt;code&gt;JOIN&lt;/code&gt; 子句时，采取与上述 &lt;code&gt;WHERE&lt;/code&gt; 子句相同的预防措施。</target>
        </trans-unit>
        <trans-unit id="8c8497bbbc5c881081d121fdf01a588723979b05" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;program&lt;/code&gt; is specified, &lt;code&gt;command&lt;/code&gt; is executed by psql and the data passed from or to &lt;code&gt;command&lt;/code&gt; is routed between the server and the client. Again, the execution privileges are those of the local user, not the server, and no SQL superuser privileges are required.</source>
          <target state="translated">当 &lt;code&gt;program&lt;/code&gt; 被指定， &lt;code&gt;command&lt;/code&gt; 被执行PSQL和从或到传递的数据 &lt;code&gt;command&lt;/code&gt; 在服务器和客户端之间路由。同样，执行特权是本地用户的特权，而不是服务器的特权，并且不需要SQL超级用户特权。</target>
        </trans-unit>
        <trans-unit id="6840df87dd751c0fab0c6f46649358f6b34c5849" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;slot_name&lt;/code&gt; is set to &lt;code&gt;NONE&lt;/code&gt;, there will be no replication slot associated with the subscription. This can be used if the replication slot will be created later manually. Such subscriptions must also have both &lt;code&gt;enabled&lt;/code&gt; and &lt;code&gt;create_slot&lt;/code&gt; set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;slot_name&lt;/code&gt; 设置为 &lt;code&gt;NONE&lt;/code&gt; 时，将没有与预订关联的复制插槽。如果复制插槽将在以后手动创建，则可以使用它。此类订阅还必须同时将 &lt;code&gt;enabled&lt;/code&gt; 和 &lt;code&gt;create_slot&lt;/code&gt; 设置为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3788a4cfcb030ae27460c4ddd94f0d92885c664" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;temp_tablespaces&lt;/code&gt; is set interactively, specifying a nonexistent tablespace is an error, as is specifying a tablespace for which the user does not have &lt;code&gt;CREATE&lt;/code&gt; privilege. However, when using a previously set value, nonexistent tablespaces are ignored, as are tablespaces for which the user lacks &lt;code&gt;CREATE&lt;/code&gt; privilege. In particular, this rule applies when using a value set in &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="translated">当以 &lt;code&gt;temp_tablespaces&lt;/code&gt; 方式设置temp_tablespaces时，指定不存在的表空间是错误的，指定用户不具有 &lt;code&gt;CREATE&lt;/code&gt; 特权的表空间也是如此。但是，使用先前设置的值时，不存在的表空间将被忽略，用户缺少 &lt;code&gt;CREATE&lt;/code&gt; 特权的表空间也会被忽略。特别是在使用 &lt;code&gt;postgresql.conf&lt;/code&gt; 中设置的值时，此规则适用。</target>
        </trans-unit>
        <trans-unit id="9c068d98cbad8e288e90e4c1dd972e7c59abbaa3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;tgconstraint&lt;/code&gt; is nonzero, &lt;code&gt;tgconstrrelid&lt;/code&gt;, &lt;code&gt;tgconstrindid&lt;/code&gt;, &lt;code&gt;tgdeferrable&lt;/code&gt;, and &lt;code&gt;tginitdeferred&lt;/code&gt; are largely redundant with the referenced &lt;code&gt;pg_constraint&lt;/code&gt; entry. However, it is possible for a non-deferrable trigger to be associated with a deferrable constraint: foreign key constraints can have some deferrable and some non-deferrable triggers.</source>
          <target state="translated">当 &lt;code&gt;tgconstraint&lt;/code&gt; 为非零值时， &lt;code&gt;tgconstrrelid&lt;/code&gt; ， &lt;code&gt;tgconstrindid&lt;/code&gt; ， &lt;code&gt;tgdeferrable&lt;/code&gt; 和 &lt;code&gt;tginitdeferred&lt;/code&gt; 对于引用的 &lt;code&gt;pg_constraint&lt;/code&gt; 项在很大程度上是多余的。但是，不可延迟的触发器可能与可延迟的约束相关联：外键约束可以具有一些可延迟的触发器和一些不可延迟的触发器。</target>
        </trans-unit>
        <trans-unit id="19d575b88117ece85c7a87c6ea7ead5a6532b19a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;trust&lt;/code&gt; authentication is specified, PostgreSQL assumes that anyone who can connect to the server is authorized to access the database with whatever database user name they specify (even superuser names). Of course, restrictions made in the &lt;code&gt;database&lt;/code&gt; and &lt;code&gt;user&lt;/code&gt; columns still apply. This method should only be used when there is adequate operating-system-level protection on connections to the server.</source>
          <target state="translated">当指定了 &lt;code&gt;trust&lt;/code&gt; 认证时，PostgreSQL假定可以连接到服务器的任何人都可以使用他们指定的任何数据库用户名（甚至超级用户名）访问数据库。当然，在 &lt;code&gt;database&lt;/code&gt; 和 &lt;code&gt;user&lt;/code&gt; 列中所做的限制仍然适用。仅在与服务器的连接上具有足够的操作系统级保护时，才应使用此方法。</target>
        </trans-unit>
        <trans-unit id="966280f7c40171987c3cbc983291b38e3a71017e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;use_remote_estimate&lt;/code&gt; is true, &lt;code&gt;postgres_fdw&lt;/code&gt; obtains row count and cost estimates from the remote server and then adds &lt;code&gt;fdw_startup_cost&lt;/code&gt; and &lt;code&gt;fdw_tuple_cost&lt;/code&gt; to the cost estimates. When &lt;code&gt;use_remote_estimate&lt;/code&gt; is false, &lt;code&gt;postgres_fdw&lt;/code&gt; performs local row count and cost estimation and then adds &lt;code&gt;fdw_startup_cost&lt;/code&gt; and &lt;code&gt;fdw_tuple_cost&lt;/code&gt; to the cost estimates. This local estimation is unlikely to be very accurate unless local copies of the remote table's statistics are available. Running &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; on the foreign table is the way to update the local statistics; this will perform a scan of the remote table and then calculate and store statistics just as though the table were local. Keeping local statistics can be a useful way to reduce per-query planning overhead for a remote table &amp;mdash; but if the remote table is frequently updated, the local statistics will soon be obsolete.</source>
          <target state="translated">当 &lt;code&gt;use_remote_estimate&lt;/code&gt; 为true时， &lt;code&gt;postgres_fdw&lt;/code&gt; 从远程服务器获取行数和成本估算，然后将 &lt;code&gt;fdw_startup_cost&lt;/code&gt; 和 &lt;code&gt;fdw_tuple_cost&lt;/code&gt; 添加到成本估算中。当 &lt;code&gt;use_remote_estimate&lt;/code&gt; 为false时， &lt;code&gt;postgres_fdw&lt;/code&gt; 执行本地行计数和成本估算，然后将 &lt;code&gt;fdw_startup_cost&lt;/code&gt; 和 &lt;code&gt;fdw_tuple_cost&lt;/code&gt; 添加到成本估算中。除非可获得远程表统计信息的本地副本，否则此本地估计不太可能非常准确。运行&lt;a href=&quot;sql-analyze&quot;&gt;分析&lt;/a&gt;在外表上是更新本地统计信息的方法；这将执行对远程表的扫描，然后像表是本地表一样计算和存储统计信息。保留本地统计信息可能是减少远程表按查询进行计划的开销的一种有用方法-但是，如果频繁更新远程表，则本地统计信息很快就会过时。</target>
        </trans-unit>
        <trans-unit id="fb7e09297d71df57df7c85aea76275071123b814" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;wal_level&lt;/code&gt; is &lt;code&gt;minimal&lt;/code&gt; and a transaction commits after creating or rewriting a permanent relation, this setting determines how to persist the new data. If the data is smaller than this setting, write it to the WAL log; otherwise, use an fsync of affected files. Depending on the properties of your storage, raising or lowering this value might help if such commits are slowing concurrent transactions. If this value is specified without units, it is taken as kilobytes. The default is two megabytes (&lt;code&gt;2MB&lt;/code&gt;).</source>
          <target state="translated">当 &lt;code&gt;wal_level&lt;/code&gt; 是 &lt;code&gt;minimal&lt;/code&gt; ，创造或改写永久关系后提交事务，此设置确定如何坚持新的数据。如果数据小于此设置，则将其写入WAL日志；否则，将其写入WAL日志。否则，请使用fsync受影响的文件。根据此类存储的属性，如果此类提交使并发事务变慢，则提高或降低此值可能会有所帮助。如果指定的该值不带单位，则以千字节为单位。缺省值为2兆字节（ &lt;code&gt;2MB&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f04447293cfe5a43fce5bd6f976cc350e753a232" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;wal_level&lt;/code&gt; is &lt;code&gt;minimal&lt;/code&gt; some SQL commands are optimized to avoid WAL logging, as described in &lt;a href=&quot;populate#POPULATE-PITR&quot;&gt;Section 14.4.7&lt;/a&gt;. If archiving or streaming replication were turned on during execution of one of these statements, WAL would not contain enough information for archive recovery. (Crash recovery is unaffected.) For this reason, &lt;code&gt;wal_level&lt;/code&gt; can only be changed at server start. However, &lt;code&gt;archive_command&lt;/code&gt; can be changed with a configuration file reload. If you wish to temporarily stop archiving, one way to do it is to set &lt;code&gt;archive_command&lt;/code&gt; to the empty string (&lt;code&gt;''&lt;/code&gt;). This will cause WAL files to accumulate in &lt;code&gt;pg_wal/&lt;/code&gt; until a working &lt;code&gt;archive_command&lt;/code&gt; is re-established.</source>
          <target state="translated">当 &lt;code&gt;wal_level&lt;/code&gt; 是 &lt;code&gt;minimal&lt;/code&gt; 一些SQL命令被优化，以避免WAL日志记录，如上述&lt;a href=&quot;populate#POPULATE-PITR&quot;&gt;第14.4.7节&lt;/a&gt;。如果在执行这些语句之一的过程中打开了归档或流复制，则WAL将没有足够的信息来进行归档恢复。 （崩溃恢复不受影响。）因此，只能在服务器启动时更改 &lt;code&gt;wal_level&lt;/code&gt; 。但是，可以通过重新加载配置文件来更改 &lt;code&gt;archive_command&lt;/code&gt; 。如果您希望暂时停止归档，一种方法是将 &lt;code&gt;archive_command&lt;/code&gt; 设置为空字符串（ &lt;code&gt;''&lt;/code&gt; ）。这将导致WAL文件在 &lt;code&gt;pg_wal/&lt;/code&gt; 累积，直到工作 &lt;code&gt;archive_command&lt;/code&gt; 重新建立了archive_command。</target>
        </trans-unit>
        <trans-unit id="bc54463c4a91042c587b320f65f275bd091c2193" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;&lt;code&gt;heapallindexed&lt;/code&gt;&lt;/em&gt; verification is performed, there is generally a greatly increased chance of detecting single-bit errors, since strict binary equality is tested, and the indexed attributes within the heap are tested.</source>
          <target state="translated">当执行&lt;em&gt; &lt;code&gt;heapallindexed&lt;/code&gt; &lt;/em&gt;验证时，通常会大大增加检测单位错误的机会，这是因为测试了严格的二进制相等性，并且测试了堆中的索引属性。</target>
        </trans-unit>
        <trans-unit id="668fe437dfa47692f950b23dc7849bfb4637dcda" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;&lt;code&gt;loop_count&lt;/code&gt;&lt;/em&gt; is greater than one, the returned numbers should be averages expected for any one scan of the index.</source>
          <target state="translated">当&lt;em&gt; &lt;code&gt;loop_count&lt;/code&gt; &lt;/em&gt;大于1时，返回的数字应该是对索引的任何一次扫描所期望的平均值。</target>
        </trans-unit>
        <trans-unit id="36ef5495d24b79877e9b0ce1d70303e79e6501c2" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt; is positive, zero rows are returned if &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt; is greater than &lt;em&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/em&gt;. Conversely, when &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt; is negative, zero rows are returned if &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt; is less than &lt;em&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/em&gt;. Zero rows are also returned for &lt;code&gt;NULL&lt;/code&gt; inputs. It is an error for &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt; to be zero. Some examples follow:</source>
          <target state="translated">当&lt;em&gt; &lt;code&gt;step&lt;/code&gt; &lt;/em&gt;为正时，如果&lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt;大于&lt;em&gt; &lt;code&gt;stop&lt;/code&gt; &lt;/em&gt;，则返回零行。相反，当&lt;em&gt; &lt;code&gt;step&lt;/code&gt; &lt;/em&gt;为负数时，如果&lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt;小于&lt;em&gt; &lt;code&gt;stop&lt;/code&gt; &lt;/em&gt;，则返回零行。 &lt;code&gt;NULL&lt;/code&gt; 输入也返回零行。&lt;em&gt; &lt;code&gt;step&lt;/code&gt; &lt;/em&gt;为零是错误的。以下是一些示例：</target>
        </trans-unit>
        <trans-unit id="80eeda2a3957217fb0ef90a74740dda9cf0f27e8" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt; is positive, zero rows are returned if &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt; is greater than &lt;em&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/em&gt;. Conversely, when &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt; is negative, zero rows are returned if &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt; is less than &lt;em&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/em&gt;. Zero rows are also returned if any input is &lt;code&gt;NULL&lt;/code&gt;. It is an error for &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt; to be zero. Some examples follow:</source>
          <target state="translated">当&lt;em&gt; &lt;code&gt;step&lt;/code&gt; &lt;/em&gt;为正时，如果&lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt;大于&lt;em&gt; &lt;code&gt;stop&lt;/code&gt; &lt;/em&gt;，则返回零行。相反，当&lt;em&gt; &lt;code&gt;step&lt;/code&gt; &lt;/em&gt;为负数时，如果&lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt;小于&lt;em&gt; &lt;code&gt;stop&lt;/code&gt; &lt;/em&gt;，则返回零行。如果任何输入为 &lt;code&gt;NULL&lt;/code&gt; ,则还返回零行。&lt;em&gt; &lt;code&gt;step&lt;/code&gt; &lt;/em&gt;为零是错误的。以下是一些示例：</target>
        </trans-unit>
        <trans-unit id="4d1d230678ad6398ea1b726af7844a229cc8f13e" translate="yes" xml:space="preserve">
          <source>When Can Parallel Query Be Used?</source>
          <target state="translated">什么时候可以使用并行查询?</target>
        </trans-unit>
        <trans-unit id="1ace675b775ff95ec59fcdc66447d15d12e35d34" translate="yes" xml:space="preserve">
          <source>When Color is Used</source>
          <target state="translated">使用颜色时</target>
        </trans-unit>
        <trans-unit id="8c5a55e381f3b4b99fc5f9dc03b78c3fc758ed84" translate="yes" xml:space="preserve">
          <source>When GSSAPI uses Kerberos, it uses a standard principal in the format &lt;code&gt;servicename/hostname@realm&lt;/code&gt;. The PostgreSQL server will accept any principal that is included in the keytab used by the server, but care needs to be taken to specify the correct principal details when making the connection from the client using the &lt;code&gt;krbsrvname&lt;/code&gt; connection parameter. (See also &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;Section 33.1.2&lt;/a&gt;.) The installation default can be changed from the default &lt;code&gt;postgres&lt;/code&gt; at build time using &lt;code&gt;./configure --with-krb-srvnam=&lt;/code&gt;&lt;code&gt;whatever&lt;/code&gt;. In most environments, this parameter never needs to be changed. Some Kerberos implementations might require a different service name, such as Microsoft Active Directory which requires the service name to be in upper case (&lt;code&gt;POSTGRES&lt;/code&gt;).</source>
          <target state="translated">当GSSAPI使用Kerberos时，它使用格式为 &lt;code&gt;servicename/hostname@realm&lt;/code&gt; 的标准主体。 PostgreSQL服务器将接受服务器使用的密钥表中包含的任何主体，但是在使用 &lt;code&gt;krbsrvname&lt;/code&gt; 连接参数从客户端进行连接时，需要小心指定正确的主体详细信息。 （另请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;第33.1.2节&lt;/a&gt;。）可以使用 &lt;code&gt;./configure --with-krb-srvnam=&lt;/code&gt; &lt;code&gt;whatever&lt;/code&gt; 值，在构建时从默认 &lt;code&gt;postgres&lt;/code&gt; 更改安装默认值。。在大多数环境中，无需更改此参数。某些Kerberos实现可能需要不同的服务名称，例如Microsoft Active Directory，它要求服务名称为大写（ &lt;code&gt;POSTGRES&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d0d3dbcdfb1b49d79ff3ed10298c962dc04c9d92" translate="yes" xml:space="preserve">
          <source>When GSSAPI uses Kerberos, it uses a standard principal in the format &lt;code&gt;servicename/hostname@realm&lt;/code&gt;. The PostgreSQL server will accept any principal that is included in the keytab used by the server, but care needs to be taken to specify the correct principal details when making the connection from the client using the &lt;code&gt;krbsrvname&lt;/code&gt; connection parameter. (See also &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;Section 33.1.2&lt;/a&gt;.) The installation default can be changed from the default &lt;code&gt;postgres&lt;/code&gt; at build time using &lt;code&gt;./configure --with-krb-srvnam=&lt;/code&gt;&lt;code&gt;whatever&lt;/code&gt;. In most environments, this parameter never needs to be changed. Some Kerberos implementations might require a different service name, such as Microsoft Active Directory which requires the service name to be in upper case (&lt;code&gt;POSTGRES&lt;/code&gt;).</source>
          <target state="translated">当GSSAPI使用Kerberos时，它使用格式为 &lt;code&gt;servicename/hostname@realm&lt;/code&gt; 的标准主体。PostgreSQL服务器将接受服务器使用的密钥表中包含的任何主体，但是在使用 &lt;code&gt;krbsrvname&lt;/code&gt; 连接参数从客户端进行连接时，需要注意指定正确的主体详细信息。（另请参见&lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;第33.1.2节&lt;/a&gt;。）可以使用 &lt;code&gt;./configure --with-krb-srvnam=&lt;/code&gt; &lt;code&gt;whatever&lt;/code&gt; 值，在构建时从默认的 &lt;code&gt;postgres&lt;/code&gt; 更改安装默认值。。在大多数环境中，无需更改此参数。某些Kerberos实现可能需要不同的服务名称，例如Microsoft Active Directory，它要求服务名称为大写（ &lt;code&gt;POSTGRES&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="cb176371849755f8e3fddd6c5c7996731ba8719c" translate="yes" xml:space="preserve">
          <source>When Hot Standby is active, this parameter determines how long the standby server should wait before canceling standby queries that conflict with about-to-be-applied WAL entries, as described in &lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;Section 26.5.2&lt;/a&gt;. &lt;code&gt;max_standby_archive_delay&lt;/code&gt; applies when WAL data is being read from WAL archive (and is therefore not current). If this value is specified without units, it is taken as milliseconds. The default is 30 seconds. A value of -1 allows the standby to wait forever for conflicting queries to complete. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">当热备用处于活动状态时，此参数确定备用服务器在取消与将要应用的WAL条目冲突的备用查询之前应等待的时间，如&lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;第26.5.2节中&lt;/a&gt;所述。从WAL归档中读取WAL数据时， &lt;code&gt;max_standby_archive_delay&lt;/code&gt; 适用（因此不是最新的）。如果指定的该值不带单位，则以毫秒为单位。默认值为30秒。值-1允许备用数据库永远等待冲突的查询完成。此参数只能在 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件或服务器命令行中设置。</target>
        </trans-unit>
        <trans-unit id="0ec8116773102304d6d7b1390f1e98f30e3bb2ff" translate="yes" xml:space="preserve">
          <source>When Hot Standby is active, this parameter determines how long the standby server should wait before canceling standby queries that conflict with about-to-be-applied WAL entries, as described in &lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;Section 26.5.2&lt;/a&gt;. &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; applies when WAL data is being received via streaming replication. If this value is specified without units, it is taken as milliseconds. The default is 30 seconds. A value of -1 allows the standby to wait forever for conflicting queries to complete. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">当热备用处于活动状态时，此参数确定备用服务器在取消与将要应用的WAL条目冲突的备用查询之前应等待的时间，如&lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;第26.5.2节中&lt;/a&gt;所述。 &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; 适用于通过流复制接收WAL数据时。如果指定的该值不带单位，则以毫秒为单位。默认值为30秒。值-1允许备用数据库永远等待冲突的查询完成。此参数只能在 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件或服务器命令行中设置。</target>
        </trans-unit>
        <trans-unit id="0f0d78fac0ffb73c1a9e09c7cc14d11764cc7556" translate="yes" xml:space="preserve">
          <source>When PostgreSQL maps SQL data values to XML (as in &lt;code&gt;xmlelement&lt;/code&gt;), or XML to SQL (as in the output columns of &lt;code&gt;xmltable&lt;/code&gt;), except for a few cases treated specially, PostgreSQL simply assumes that the XML data type's XPath 1.0 string form will be valid as the text-input form of the SQL datatype, and conversely. This rule has the virtue of simplicity while producing, for many data types, results similar to the mappings specified in the standard.</source>
          <target state="translated">当PostgreSQL将SQL数据值映射到XML（如 &lt;code&gt;xmlelement&lt;/code&gt; ）或XML 映射到SQL（如 &lt;code&gt;xmltable&lt;/code&gt; 的输出列）时，除特殊处理的几种情况外，PostgreSQL只是假定XML数据类型的XPath 1.0字符串形式为相反，它作为SQL数据类型的文本输入形式有效。对于许多数据类型，此规则具有简单性，同时可以生成类似于标准中指定的映射的结果。</target>
        </trans-unit>
        <trans-unit id="4181958cdfd24c8fd1ab7073c5b2ff83fa0a559f" translate="yes" xml:space="preserve">
          <source>When SCRAM-SHA-256 is used in PostgreSQL, the server will ignore the user name that the client sends in the &lt;code&gt;client-first-message&lt;/code&gt;. The user name that was already sent in the startup message is used instead. PostgreSQL supports multiple character encodings, while SCRAM dictates UTF-8 to be used for the user name, so it might be impossible to represent the PostgreSQL user name in UTF-8.</source>
          <target state="translated">在PostgreSQL中使用SCRAM-SHA-256时，服务器将忽略客户端在 &lt;code&gt;client-first-message&lt;/code&gt; 中发送的用户名。而是使用已在启动消息中发送的用户名。 PostgreSQL支持多种字符编码，而SCRAM规定将UTF-8用作用户名，因此可能无法用UTF-8表示PostgreSQL用户名。</target>
        </trans-unit>
        <trans-unit id="b543779d02e501d6f789fd6a94efbe4d169a8312" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;FROM&lt;/code&gt; clause is present, what essentially happens is that the target table is joined to the tables mentioned in the &lt;code&gt;from_item&lt;/code&gt; list, and each output row of the join represents an update operation for the target table. When using &lt;code&gt;FROM&lt;/code&gt; you should ensure that the join produces at most one output row for each row to be modified. In other words, a target row shouldn't join to more than one row from the other table(s). If it does, then only one of the join rows will be used to update the target row, but which one will be used is not readily predictable.</source>
          <target state="translated">当存在 &lt;code&gt;FROM&lt;/code&gt; 子句时，本质上会发生的是将目标表连接到 &lt;code&gt;from_item&lt;/code&gt; 列表中提到的表，并且连接的每个输出行都代表目标表的更新操作。使用 &lt;code&gt;FROM&lt;/code&gt; 时，应确保该联接为要修改的每一行最多产生一个输出行。换句话说，目标行不应与其他表中的一行连接在一起。如果是这样，那么将仅使用联接行之一来更新目标行，但是将很难预测将使用哪一行。</target>
        </trans-unit>
        <trans-unit id="4cd20efcfa95fdaaa37532258734ec47bc3eda12" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;FROM&lt;/code&gt; clause is present, what essentially happens is that the target table is joined to the tables mentioned in the &lt;code&gt;from_list&lt;/code&gt;, and each output row of the join represents an update operation for the target table. When using &lt;code&gt;FROM&lt;/code&gt; you should ensure that the join produces at most one output row for each row to be modified. In other words, a target row shouldn't join to more than one row from the other table(s). If it does, then only one of the join rows will be used to update the target row, but which one will be used is not readily predictable.</source>
          <target state="translated">当存在 &lt;code&gt;FROM&lt;/code&gt; 子句时，本质上是将目标表连接到 &lt;code&gt;from_list&lt;/code&gt; 中提到的表，并且连接的每个输出行都代表目标表的更新操作。使用 &lt;code&gt;FROM&lt;/code&gt; 时，应确保该联接为要修改的每一行最多产生一个输出行。换句话说，目标行不应与其他表中的行合并。如果是这样，那么将仅使用联接行之一来更新目标行，但是将很难预测将使用哪一行。</target>
        </trans-unit>
        <trans-unit id="0a80d67f6221f67e848e31748e5e7aded5d6746e" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;FROM&lt;/code&gt; item contains &lt;code&gt;LATERAL&lt;/code&gt; cross-references, evaluation proceeds as follows: for each row of the &lt;code&gt;FROM&lt;/code&gt; item providing the cross-referenced column(s), or set of rows of multiple &lt;code&gt;FROM&lt;/code&gt; items providing the columns, the &lt;code&gt;LATERAL&lt;/code&gt; item is evaluated using that row or row set's values of the columns. The resulting row(s) are joined as usual with the rows they were computed from. This is repeated for each row or set of rows from the column source table(s).</source>
          <target state="translated">当 &lt;code&gt;FROM&lt;/code&gt; 项包含 &lt;code&gt;LATERAL&lt;/code&gt; 交叉引用，评价如下进行：针对的每一行 &lt;code&gt;FROM&lt;/code&gt; 项提供多个的行的交叉引用列（S），或组 &lt;code&gt;FROM&lt;/code&gt; 提供的列项时， &lt;code&gt;LATERAL&lt;/code&gt; 项是使用评价该行或行集的列值。像往常一样，将结果行与从中计算出的行连接在一起。对列源表中的每一行或每一行行重复此操作。</target>
        </trans-unit>
        <trans-unit id="9131be6a2fce2c0e060d15eb98b8c743d3328da0" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;UNIQUE&lt;/code&gt; or &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraint is not deferrable, PostgreSQL checks for uniqueness immediately whenever a row is inserted or modified. The SQL standard says that uniqueness should be enforced only at the end of the statement; this makes a difference when, for example, a single command updates multiple key values. To obtain standard-compliant behavior, declare the constraint as &lt;code&gt;DEFERRABLE&lt;/code&gt; but not deferred (i.e., &lt;code&gt;INITIALLY IMMEDIATE&lt;/code&gt;). Be aware that this can be significantly slower than immediate uniqueness checking.</source>
          <target state="translated">当 &lt;code&gt;UNIQUE&lt;/code&gt; 或 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 约束不可延迟时，无论何时插入或修改行，PostgreSQL都会立即检查其唯一性。 SQL标准指出，唯一性应仅在语句末尾执行；例如，当一个命令更新多个键值时，这会有所不同。为了获得符合标准的行为，请将约束声明为 &lt;code&gt;DEFERRABLE&lt;/code&gt; 而不是被延迟（即， &lt;code&gt;INITIALLY IMMEDIATE&lt;/code&gt; ）。请注意，这比立即唯一性检查要慢得多。</target>
        </trans-unit>
        <trans-unit id="d7633f6759da586e80f43626088973d06a48ea56" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;pg_cast&lt;/code&gt; entry has different source and target types and a function that takes more than one argument, it represents converting from one type to another and applying a length coercion in a single step. When no such entry is available, coercion to a type that uses a type modifier involves two steps, one to convert between data types and a second to apply the modifier.</source>
          <target state="translated">当一个 &lt;code&gt;pg_cast&lt;/code&gt; 条目具有不同的源和目标类型，并且一个函数接受一个以上的参数时，它表示从一种类型转换为另一种类型并在一个步骤中施加长度强制。如果没有这样的条目，强制转换为使用类型修饰符的类型将涉及两个步骤，一个步骤在数据类型之间进行转换，第二个步骤应用该修饰符。</target>
        </trans-unit>
        <trans-unit id="88f0e69da747f3bb16cb53c469a234fbf587434e" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;timestamp with time zone&lt;/code&gt; value is output, it is always converted from UTC to the current &lt;code&gt;timezone&lt;/code&gt; zone, and displayed as local time in that zone. To see the time in another time zone, either change &lt;code&gt;timezone&lt;/code&gt; or use the &lt;code&gt;AT TIME ZONE&lt;/code&gt; construct (see &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-ZONECONVERT&quot;&gt;Section 9.9.3&lt;/a&gt;).</source>
          <target state="translated">当输出 &lt;code&gt;timestamp with time zone&lt;/code&gt; 值的时间戳时，总是将其从UTC转换为当前 &lt;code&gt;timezone&lt;/code&gt; 区，并在该时区中显示为本地时间。要查看其他时区的时间，请更改 &lt;code&gt;timezone&lt;/code&gt; 或使用 &lt;code&gt;AT TIME ZONE&lt;/code&gt; 构造（请参见&lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-ZONECONVERT&quot;&gt;第9.9.3节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="27629e4b11182354bc4cc1d2c2660d2bd8a7f20c" translate="yes" xml:space="preserve">
          <source>When a cast has different source and target types and a function that takes more than one argument, it supports converting from one type to another and applying a length coercion in a single step. When no such entry is available, coercion to a type that uses a type modifier involves two cast steps, one to convert between data types and a second to apply the modifier.</source>
          <target state="translated">当一个浇铸具有不同的源类型和目标类型,并且一个函数需要多个参数时,它支持从一种类型转换到另一种类型,并在一个步骤中应用长度胁迫。当没有这样的条目时,对使用类型修饰符的类型的胁迫涉及两个浇铸步骤,一个步骤用于在数据类型之间转换,第二个步骤用于应用修饰符。</target>
        </trans-unit>
        <trans-unit id="49788d41c6b6cbdafb9c157dde66cc21e7ad5c8d" translate="yes" xml:space="preserve">
          <source>When a cast is applied to a value expression of a known type, it represents a run-time type conversion. The cast will succeed only if a suitable type conversion operation has been defined. Notice that this is subtly different from the use of casts with constants, as shown in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS-GENERIC&quot;&gt;Section 4.1.2.7&lt;/a&gt;. A cast applied to an unadorned string literal represents the initial assignment of a type to a literal constant value, and so it will succeed for any type (if the contents of the string literal are acceptable input syntax for the data type).</source>
          <target state="translated">将强制转换应用于已知类型的值表达式时，它表示运行时类型转换。仅在定义了适当的类型转换操作后，转换才会成功。注意，这与使用带有常量的强制类型转换有细微的区别，如&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS-GENERIC&quot;&gt;第4.1.2.7节&lt;/a&gt;所示。应用于未经修饰的字符串文字的强制转换表示将类型初始分配给文字常量值，因此，对于任何类型，该转换都会成功（如果字符串文字的内容对于数据类型而言是可接受的输入语法）。</target>
        </trans-unit>
        <trans-unit id="cf5e183edf65b04ea968b8cbec71c03d82d34814" translate="yes" xml:space="preserve">
          <source>When a character string value is cast to or from type &lt;code&gt;xml&lt;/code&gt; without going through &lt;code&gt;XMLPARSE&lt;/code&gt; or &lt;code&gt;XMLSERIALIZE&lt;/code&gt;, respectively, the choice of &lt;code&gt;DOCUMENT&lt;/code&gt; versus &lt;code&gt;CONTENT&lt;/code&gt; is determined by the &amp;ldquo;XML option&amp;rdquo;  session configuration parameter, which can be set using the standard command:</source>
          <target state="translated">当将字符串值强制转换为 &lt;code&gt;xml&lt;/code&gt; 类型或从xml类型强制转换而无需分别通过 &lt;code&gt;XMLPARSE&lt;/code&gt; 或 &lt;code&gt;XMLSERIALIZE&lt;/code&gt; 进行转换时， &lt;code&gt;DOCUMENT&lt;/code&gt; vs &lt;code&gt;CONTENT&lt;/code&gt; 的选择由&amp;ldquo; XML option&amp;rdquo;会话配置参数确定，可以使用标准命令来设置：</target>
        </trans-unit>
        <trans-unit id="42fc13aa34e4743bab6d0037fe542f1b13a66649" translate="yes" xml:space="preserve">
          <source>When a column is added with &lt;code&gt;ADD COLUMN&lt;/code&gt; and a non-volatile &lt;code&gt;DEFAULT&lt;/code&gt; is specified, the default is evaluated at the time of the statement and the result stored in the table's metadata. That value will be used for the column for all existing rows. If no &lt;code&gt;DEFAULT&lt;/code&gt; is specified, NULL is used. In neither case is a rewrite of the table required.</source>
          <target state="translated">当在列中添加 &lt;code&gt;ADD COLUMN&lt;/code&gt; 并指定了非易失性 &lt;code&gt;DEFAULT&lt;/code&gt; 时，将在声明时评估默认值，并将结果存储在表的元数据中。该值将用于所有现有行的列。如果未指定 &lt;code&gt;DEFAULT&lt;/code&gt; ，则使用NULL。无论哪种情况都不需要重写表。</target>
        </trans-unit>
        <trans-unit id="4617ca746c05eccbac9e1250d759f5bd44319fcd" translate="yes" xml:space="preserve">
          <source>When a conflicting query is short, it's typically desirable to allow it to complete by delaying WAL application for a little bit; but a long delay in WAL application is usually not desirable. So the cancel mechanism has parameters, &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay&lt;/a&gt;, that define the maximum allowed delay in WAL application. Conflicting queries will be canceled once it has taken longer than the relevant delay setting to apply any newly-received WAL data. There are two parameters so that different delay values can be specified for the case of reading WAL data from an archive (i.e., initial recovery from a base backup or &amp;ldquo;catching up&amp;rdquo; a standby server that has fallen far behind) versus reading WAL data via streaming replication.</source>
          <target state="translated">当冲突查询很短时，通常希望通过延迟WAL应用程序一点来使其完成。但是通常不希望WAL应用程序长时间延迟。因此，取消机制具有参数&lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt;和&lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay&lt;/a&gt;，这些参数定义WAL应用程序中允许的最大延迟。一旦冲突查询花费的时间超过了相关延迟设置以应用任何新接收到的WAL数据的时间，就会被取消。有两个参数，因此可以为从存档中读取WAL数据（即从基本备份中进行初始恢复或&amp;ldquo;追赶&amp;rdquo;落后的备用服务器）与通过WAL数据读取而指定不同的延迟值。流复制。</target>
        </trans-unit>
        <trans-unit id="fe9942af75508e96643f23b2bb2b19c3cb29a5d8" translate="yes" xml:space="preserve">
          <source>When a connection to the database server as database user &lt;code&gt;someuser&lt;/code&gt; is requested, PostgreSQL will attempt to bind anonymously (since &lt;code&gt;ldapbinddn&lt;/code&gt; was not specified) to the LDAP server, perform a search for &lt;code&gt;(uid=someuser)&lt;/code&gt; under the specified base DN. If an entry is found, it will then attempt to bind using that found information and the password supplied by the client. If that second connection succeeds, the database access is granted.</source>
          <target state="translated">当请求以数据库用户 &lt;code&gt;someuser&lt;/code&gt; 身份连接到数据库服务器时，PostgreSQL将尝试匿名绑定（由于未指定 &lt;code&gt;ldapbinddn&lt;/code&gt; ）到LDAP服务器，并在指定的基本DN下执行搜索 &lt;code&gt;(uid=someuser)&lt;/code&gt; 。如果找到一个条目，它将尝试使用找到的信息和客户端提供的密码进行绑定。如果第二个连接成功，则将授予数据库访问权限。</target>
        </trans-unit>
        <trans-unit id="48781ec5a4acd4a7481b8c8839149e95712b5009" translate="yes" xml:space="preserve">
          <source>When a connection to the database server as database user &lt;code&gt;someuser&lt;/code&gt; is requested, PostgreSQL will attempt to bind to the LDAP server using the DN &lt;code&gt;cn=someuser, dc=example, dc=net&lt;/code&gt; and the password provided by the client. If that connection succeeds, the database access is granted.</source>
          <target state="translated">当请求以数据库用户 &lt;code&gt;someuser&lt;/code&gt; 的身份连接到数据库服务器时，PostgreSQL将尝试使用DN &lt;code&gt;cn=someuser, dc=example, dc=net&lt;/code&gt; 和客户端提供的密码来绑定到LDAP服务器。如果该连接成功，则将授予数据库访问权限。</target>
        </trans-unit>
        <trans-unit id="c225436eedb2c4fcd16a275b1ddffc50962ab028" translate="yes" xml:space="preserve">
          <source>When a constant's value has been ignored for purposes of matching the query to other queries, the constant is replaced by a parameter symbol, such as &lt;code&gt;$1&lt;/code&gt;, in the &lt;code&gt;pg_stat_statements&lt;/code&gt; display. The rest of the query text is that of the first query that had the particular &lt;code&gt;queryid&lt;/code&gt; hash value associated with the &lt;code&gt;pg_stat_statements&lt;/code&gt; entry.</source>
          <target state="translated">为了使查询与其他查询匹配而忽略了常量的值时，该常量将在 &lt;code&gt;pg_stat_statements&lt;/code&gt; 显示中替换为参数符号，例如 &lt;code&gt;$1&lt;/code&gt; 。查询文本的其余部分是第一个查询的文本，该查询具有与 &lt;code&gt;pg_stat_statements&lt;/code&gt; 条目关联的特定 &lt;code&gt;queryid&lt;/code&gt; 哈希值。</target>
        </trans-unit>
        <trans-unit id="ecb409e448668771f827d8fbf0e7974aed415eec" translate="yes" xml:space="preserve">
          <source>When a data-only dump is chosen and the option &lt;code&gt;--disable-triggers&lt;/code&gt; is used, pg_dump emits commands to disable triggers on user tables before inserting the data, and then commands to re-enable them after the data has been inserted. If the restore is stopped in the middle, the system catalogs might be left in the wrong state.</source>
          <target state="translated">当选择了仅数据转储并且使用了 &lt;code&gt;--disable-triggers&lt;/code&gt; 选项时，pg_dump发出命令以在插入数据之前禁用用户表上的触发器，然后在插入数据后发出命令以重新启用它们。如果还原在中间停止，则系统目录可能处于错误状态。</target>
        </trans-unit>
        <trans-unit id="2bb4292f30931b17f0bc254f84df53dc22a84368" translate="yes" xml:space="preserve">
          <source>When a direct database connection is specified using the &lt;code&gt;-d&lt;/code&gt; option, pg_restore internally executes SQL statements. If you have problems running pg_restore, make sure you are able to select information from the database using, for example, &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt;. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">当使用 &lt;code&gt;-d&lt;/code&gt; 选项指定直接数据库连接时，pg_restore在内部执行SQL语句。如果在运行pg_restore时遇到问题，请确保能够使用例如&lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt;从数据库中选择信息。同样，libpq前端库使用的任何默认连接设置和环境变量都将适用。</target>
        </trans-unit>
        <trans-unit id="70b0a551bd1d82e60af1e6e20328604ac27e04a2" translate="yes" xml:space="preserve">
          <source>When a domain has multiple &lt;code&gt;CHECK&lt;/code&gt; constraints, they will be tested in alphabetical order by name. (PostgreSQL versions before 9.5 did not honor any particular firing order for &lt;code&gt;CHECK&lt;/code&gt; constraints.)</source>
          <target state="translated">当域具有多个 &lt;code&gt;CHECK&lt;/code&gt; 约束时，将按名称的字母顺序对它们进行测试。（9.5之前的PostgreSQL版本不遵循 &lt;code&gt;CHECK&lt;/code&gt; 约束的任何特定触发顺序。）</target>
        </trans-unit>
        <trans-unit id="d2882ec668c4758898724ea8c42f8d7a46c5af40" translate="yes" xml:space="preserve">
          <source>When a function in the &lt;code&gt;FROM&lt;/code&gt; clause is suffixed by &lt;code&gt;WITH ORDINALITY&lt;/code&gt;, a &lt;code&gt;bigint&lt;/code&gt; column is appended to the function's output column(s), which starts from 1 and increments by 1 for each row of the function's output. This is most useful in the case of set returning functions such as &lt;code&gt;unnest()&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;FROM&lt;/code&gt; 子句中的函数以 &lt;code&gt;WITH ORDINALITY&lt;/code&gt; 作为后缀时， &lt;code&gt;bigint&lt;/code&gt; 列将附加到函数的输出列，该列从1开始，对于函数输出的每一行以1递增。这在设置返回函数（例如 &lt;code&gt;unnest()&lt;/code&gt; )的情况下最有用。</target>
        </trans-unit>
        <trans-unit id="82ae6b8670e18414fb24938a0f2cc8a6d1070788" translate="yes" xml:space="preserve">
          <source>When a function in the &lt;code&gt;FROM&lt;/code&gt; clause is suffixed by &lt;code&gt;WITH ORDINALITY&lt;/code&gt;, a &lt;code&gt;bigint&lt;/code&gt; column is appended to the output which starts from 1 and increments by 1 for each row of the function's output. This is most useful in the case of set returning functions such as &lt;code&gt;unnest()&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;FROM&lt;/code&gt; 子句中的函数以 &lt;code&gt;WITH ORDINALITY&lt;/code&gt; 作为后缀时， &lt;code&gt;bigint&lt;/code&gt; 列将附加到输出，该列从1开始，对于函数输出的每一行以1递增。这在设置返回函数（例如 &lt;code&gt;unnest()&lt;/code&gt; )的情况下最有用。</target>
        </trans-unit>
        <trans-unit id="cc5d8fb3f4d70c3c0f1dea589130a29e4dae23e6" translate="yes" xml:space="preserve">
          <source>When a heap entry is to be deleted (by &lt;code&gt;VACUUM&lt;/code&gt;), all its index entries must be removed first.</source>
          <target state="translated">当要删除堆条目（通过 &lt;code&gt;VACUUM&lt;/code&gt; ）时，必须首先删除其所有索引条目。</target>
        </trans-unit>
        <trans-unit id="00af93fe8454ff02af34b94554824196fc81e8fc" translate="yes" xml:space="preserve">
          <source>When a locking clause appears at the top level of a &lt;code&gt;SELECT&lt;/code&gt; query, the rows that are locked are exactly those that are returned by the query; in the case of a join query, the rows locked are those that contribute to returned join rows. In addition, rows that satisfied the query conditions as of the query snapshot will be locked, although they will not be returned if they were updated after the snapshot and no longer satisfy the query conditions. If a &lt;code&gt;LIMIT&lt;/code&gt; is used, locking stops once enough rows have been returned to satisfy the limit (but note that rows skipped over by &lt;code&gt;OFFSET&lt;/code&gt; will get locked). Similarly, if a locking clause is used in a cursor's query, only rows actually fetched or stepped past by the cursor will be locked.</source>
          <target state="translated">当锁定子句出现在 &lt;code&gt;SELECT&lt;/code&gt; 查询的顶级时，被锁定的行与查询返回的行完全相同。对于联接查询，锁定的行是那些有助于返回联接行的行。另外，满足查询条件的行将自查询快照起被锁定，尽管如果在快照后对其进行更新并且不再满足查询条件，则不会返回这些行。如果使用 &lt;code&gt;LIMIT&lt;/code&gt; ,则一旦返回了足够的行以满足限制，锁定就会停止（但请注意，被 &lt;code&gt;OFFSET&lt;/code&gt; 跳过的行将被锁定）。同样，如果在游标的查询中使用了锁定子句，则仅锁定实际被游标读取或跳过的行。</target>
        </trans-unit>
        <trans-unit id="ef95b8a60ebd804a0c28a2e00cab45258a43a0d6" translate="yes" xml:space="preserve">
          <source>When a locking clause appears in a sub-&lt;code&gt;SELECT&lt;/code&gt;, the rows locked are those returned to the outer query by the sub-query. This might involve fewer rows than inspection of the sub-query alone would suggest, since conditions from the outer query might be used to optimize execution of the sub-query. For example,</source>
          <target state="translated">当锁定子句出现在子 &lt;code&gt;SELECT&lt;/code&gt; 中时，锁定的行是子查询返回给外部查询的行。这可能涉及比仅检查子查询建议的行少的行，因为来自外部查询的条件可能用于优化子查询的执行。例如，</target>
        </trans-unit>
        <trans-unit id="bfc7a3d97debfcf5d558fe06d1809283c70c4abd" translate="yes" xml:space="preserve">
          <source>When a non-owner of an object attempts to &lt;code&gt;GRANT&lt;/code&gt; privileges on the object, the command will fail outright if the user has no privileges whatsoever on the object. As long as some privilege is available, the command will proceed, but it will grant only those privileges for which the user has grant options. The &lt;code&gt;GRANT ALL PRIVILEGES&lt;/code&gt; forms will issue a warning message if no grant options are held, while the other forms will issue a warning if grant options for any of the privileges specifically named in the command are not held. (In principle these statements apply to the object owner as well, but since the owner is always treated as holding all grant options, the cases can never occur.)</source>
          <target state="translated">当一个对象尝试的非所有者 &lt;code&gt;GRANT&lt;/code&gt; 对象上的特权，该命令将彻底如果用户没有任何特权的对象失败。只要有某些特权，该命令就会继续执行，但是它将只授予用户具有授予选项的那些特权。在 &lt;code&gt;GRANT ALL PRIVILEGES&lt;/code&gt; ，如果没有授权选项，举办形式将发出一个警告信息，而如果任何的命令特别命名的权限的授权选项，没有举行其他形式将发出警告。 （原则上，这些声明也适用于对象所有者，但是由于所有者总是被视为拥有所有授予选项，因此永远不会发生这种情况。）</target>
        </trans-unit>
        <trans-unit id="89d5be09265c0f260930da66e4dbc18e249c5a52" translate="yes" xml:space="preserve">
          <source>When a non-owner of an object attempts to &lt;code&gt;REVOKE&lt;/code&gt; privileges on the object, the command will fail outright if the user has no privileges whatsoever on the object. As long as some privilege is available, the command will proceed, but it will revoke only those privileges for which the user has grant options. The &lt;code&gt;REVOKE ALL PRIVILEGES&lt;/code&gt; forms will issue a warning message if no grant options are held, while the other forms will issue a warning if grant options for any of the privileges specifically named in the command are not held. (In principle these statements apply to the object owner as well, but since the owner is always treated as holding all grant options, the cases can never occur.)</source>
          <target state="translated">当对象的非所有者尝试 &lt;code&gt;REVOKE&lt;/code&gt; 该对象的特权时，如果用户对该对象没有任何特权，则该命令将完全失败。只要有某些特权，该命令就会继续执行，但是只会撤消用户具有授予选项的那些特权。在 &lt;code&gt;REVOKE ALL PRIVILEGES&lt;/code&gt; ，如果没有授权选项，举办形式将发出一个警告信息，而如果任何的命令特别命名的权限的授权选项，没有举行其他形式将发出警告。 （原则上，这些声明也适用于对象所有者，但是由于所有者总是被视为拥有所有授予选项，因此永远不会发生这种情况。）</target>
        </trans-unit>
        <trans-unit id="0029c76ef03f694dc7bb9ed004592d4eb27d7674" translate="yes" xml:space="preserve">
          <source>When a partitioned table is added to a publication, all of its existing and future partitions are implicitly considered to be part of the publication. So, even operations that are performed directly on a partition are also published via publications that its ancestors are part of.</source>
          <target state="translated">当一个分区表被添加到出版物中时,它的所有现有的和未来的分区都被隐含地认为是出版物的一部分。因此,即使是直接在分区上进行的操作,也会通过其祖先所属的出版物来发布。</target>
        </trans-unit>
        <trans-unit id="81fc5d42be5663314dba2e99345c9e9036540107" translate="yes" xml:space="preserve">
          <source>When a password is specified in &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; or &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt;, this parameter determines the algorithm to use to encrypt the password. The default value is &lt;code&gt;md5&lt;/code&gt;, which stores the password as an MD5 hash (&lt;code&gt;on&lt;/code&gt; is also accepted, as alias for &lt;code&gt;md5&lt;/code&gt;). Setting this parameter to &lt;code&gt;scram-sha-256&lt;/code&gt; will encrypt the password with SCRAM-SHA-256.</source>
          <target state="translated">在&lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;或&lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE中&lt;/a&gt;指定了密码后，此参数将确定用于加密密码的算法。默认值为 &lt;code&gt;md5&lt;/code&gt; ，它将密码存储为MD5哈希（也接受 &lt;code&gt;on&lt;/code&gt; 作为 &lt;code&gt;md5&lt;/code&gt; 的别名）。将此参数设置为 &lt;code&gt;scram-sha-256&lt;/code&gt; 将使用SCRAM-SHA-256加密密码。</target>
        </trans-unit>
        <trans-unit id="a045ad36bdf763a5564eafc812cd1f70e538ac02" translate="yes" xml:space="preserve">
          <source>When a query involves multiple window functions, it is possible to write out each one with a separate &lt;code&gt;OVER&lt;/code&gt; clause, but this is duplicative and error-prone if the same windowing behavior is wanted for several functions. Instead, each windowing behavior can be named in a &lt;code&gt;WINDOW&lt;/code&gt; clause and then referenced in &lt;code&gt;OVER&lt;/code&gt;. For example:</source>
          <target state="translated">当查询涉及多个窗口函数时，可以用单独的 &lt;code&gt;OVER&lt;/code&gt; 子句写出每个窗口函数，但是如果多个函数都希望使用相同的窗口行为，则这是重复的并且容易出错。而是可以在 &lt;code&gt;WINDOW&lt;/code&gt; 子句中命名每个窗口行为，然后在 &lt;code&gt;OVER&lt;/code&gt; 中引用。例如：</target>
        </trans-unit>
        <trans-unit id="6b051ff28261e8c6e18971fa6cb50736f0add4f7" translate="yes" xml:space="preserve">
          <source>When a query only involves two or three tables, there aren't many join orders to worry about. But the number of possible join orders grows exponentially as the number of tables expands. Beyond ten or so input tables it's no longer practical to do an exhaustive search of all the possibilities, and even for six or seven tables planning might take an annoyingly long time. When there are too many input tables, the PostgreSQL planner will switch from exhaustive search to a &lt;em&gt;genetic&lt;/em&gt; probabilistic search through a limited number of possibilities. (The switch-over threshold is set by the &lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt; run-time parameter.) The genetic search takes less time, but it won't necessarily find the best possible plan.</source>
          <target state="translated">当查询仅涉及两个或三个表时，不必担心很多连接顺序。但是，随着表数量的扩展，可能的连接顺序数量呈指数增长。超过十个左右的输入表后，对所有可能性进行详尽的搜索不再可行，甚至对于六个或七个表来说，规划也可能需要很长时间。当输入表太多时，PostgreSQL计划器将通过有限的可能性从穷举搜索切换到&lt;em&gt;遗传&lt;/em&gt;概率搜索。 （切换阈值由&lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt;运行时参数设置。）遗传搜索花费的时间更少，但不一定能找到最佳方案。</target>
        </trans-unit>
        <trans-unit id="52a265f5fc62979fde73128f8ace62054feb152e" translate="yes" xml:space="preserve">
          <source>When a schema-qualified operator name is used in the &lt;code&gt;OPERATOR&lt;/code&gt; syntax, as for example in:</source>
          <target state="translated">在 &lt;code&gt;OPERATOR&lt;/code&gt; 语法中使用模式限定的运算符名称时，例如：</target>
        </trans-unit>
        <trans-unit id="07d688620d10b715a262026cbd31ef1489999e7d" translate="yes" xml:space="preserve">
          <source>When a sequential scan and sort is used, a temporary sort file is also created, so that the peak temporary space requirement is as much as double the table size, plus the index sizes. This method is often faster than the index scan method, but if the disk space requirement is intolerable, you can disable this choice by temporarily setting &lt;a href=&quot;runtime-config-query#GUC-ENABLE-SORT&quot;&gt;enable_sort&lt;/a&gt; to &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">当使用顺序扫描和排序时，还会创建一个临时排序文件，因此临时空间峰值需求是表大小加索引大小的两倍。此方法通常比索引扫描方法快，但是如果磁盘空间需求无法忍受，则可以通过将&lt;a href=&quot;runtime-config-query#GUC-ENABLE-SORT&quot;&gt;enable_sort&lt;/a&gt;临时设置为 &lt;code&gt;off&lt;/code&gt; 来禁用此选择。</target>
        </trans-unit>
        <trans-unit id="f0770f15e6049d266a12140bc7f33a5609b9c35a" translate="yes" xml:space="preserve">
          <source>When a single element is pushed onto either the beginning or end of a one-dimensional array, the result is an array with the same lower bound subscript as the array operand. For example:</source>
          <target state="translated">当一个元素被推送到一维数组的开头或结尾时,结果是一个与数组操作数相同的下界下标的数组。例如,在一维数组的开头或结尾推入单个元素时,结果是一个与数组操作数相同的下限下标的数组。</target>
        </trans-unit>
        <trans-unit id="f80cd58c4f6747cdabdfc227aecb194029c6f93d" translate="yes" xml:space="preserve">
          <source>When a standby first attaches to the primary, it will not yet be properly synchronized. This is described as &lt;code&gt;catchup&lt;/code&gt; mode. Once the lag between standby and primary reaches zero for the first time we move to real-time &lt;code&gt;streaming&lt;/code&gt; state. The catch-up duration may be long immediately after the standby has been created. If the standby is shut down, then the catch-up period will increase according to the length of time the standby has been down. The standby is only able to become a synchronous standby once it has reached &lt;code&gt;streaming&lt;/code&gt; state. This state can be viewed using the &lt;code&gt;pg_stat_replication&lt;/code&gt; view.</source>
          <target state="translated">当备用数据库首次连接到主数据库时，它将尚未正确同步。这称为 &lt;code&gt;catchup&lt;/code&gt; 模式。一旦备用数据库和主要数据库之间的时差首次达到零，我们便进入实时 &lt;code&gt;streaming&lt;/code&gt; 状态。创建备用数据库后，追赶时间可能会很长。如果备用数据库已关闭，则追赶时间将根据备用数据库已关闭的时间长度而增加。备用服务器仅在达到 &lt;code&gt;streaming&lt;/code&gt; 状态后才能成为同步备用服务器。可以使用 &lt;code&gt;pg_stat_replication&lt;/code&gt; 视图查看该状态。</target>
        </trans-unit>
        <trans-unit id="ad5c61ffccbfb5effcfe0a2c8686ec7385263d29" translate="yes" xml:space="preserve">
          <source>When a subscription is dropped and recreated, the synchronization information is lost. This means that the data has to be resynchronized afterwards.</source>
          <target state="translated">当一个订阅被删除并重新创建时,同步信息会丢失。这意味着之后必须重新同步数据。</target>
        </trans-unit>
        <trans-unit id="b46a9ad23681ef38bc14d25148f1365c37846a4e" translate="yes" xml:space="preserve">
          <source>When a table has a default partition, defining a new partition changes the partition constraint for the default partition. The default partition can't contain any rows that would need to be moved to the new partition, and will be scanned to verify that none are present. This scan, like the scan of the new partition, can be avoided if an appropriate &lt;code&gt;CHECK&lt;/code&gt; constraint is present. Also like the scan of the new partition, it is always skipped when the default partition is a foreign table.</source>
          <target state="translated">当表具有默认分区时，定义新分区将更改默认分区的分区约束。默认分区不能包含任何需要移动到新分区的行，并且将对其进行扫描以确认不存在任何行。如果存在适当的 &lt;code&gt;CHECK&lt;/code&gt; 约束，则可以避免像新分区的扫描一样进行此扫描。就像扫描新分区一样，当默认分区是外部表时，总是会跳过它。</target>
        </trans-unit>
        <trans-unit id="152306185769e157a52b3f97557867eb083f11a7" translate="yes" xml:space="preserve">
          <source>When a table has an existing &lt;code&gt;DEFAULT&lt;/code&gt; partition and a new partition is added to it, the default partition must be scanned to verify that it does not contain any rows which properly belong in the new partition. If the default partition contains a large number of rows, this may be slow. The scan will be skipped if the default partition is a foreign table or if it has a constraint which proves that it cannot contain rows which should be placed in the new partition.</source>
          <target state="translated">当表具有现有的 &lt;code&gt;DEFAULT&lt;/code&gt; 分区并向其添加了新分区时，必须扫描默认分区以验证其不包含任何正确属于新分区的行。如果默认分区包含大量行，这可能会很慢。如果默认分区是一个外部表，或者如果它具有一个约束，证明它不能包含应放在新分区中的行，则将跳过扫描。</target>
        </trans-unit>
        <trans-unit id="43b2ea07826933a7c581c975e04300af317cf31d" translate="yes" xml:space="preserve">
          <source>When a table has multiple &lt;code&gt;CHECK&lt;/code&gt; constraints, they will be tested for each row in alphabetical order by name, after checking &lt;code&gt;NOT NULL&lt;/code&gt; constraints. (PostgreSQL versions before 9.5 did not honor any particular firing order for &lt;code&gt;CHECK&lt;/code&gt; constraints.)</source>
          <target state="translated">当一个表具有多个 &lt;code&gt;CHECK&lt;/code&gt; 约束时，将在检查 &lt;code&gt;NOT NULL&lt;/code&gt; 约束后按名称的字母顺序对每一行进行测试。（9.5之前的PostgreSQL版本不遵循 &lt;code&gt;CHECK&lt;/code&gt; 约束的任何特定触发顺序。）</target>
        </trans-unit>
        <trans-unit id="082c9f9ffee26ce9be34e1d589e0da24d6b1e31a" translate="yes" xml:space="preserve">
          <source>When a table is being clustered, an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock is acquired on it. This prevents any other database operations (both reads and writes) from operating on the table until the &lt;code&gt;CLUSTER&lt;/code&gt; is finished.</source>
          <target state="translated">对表进行集群时，将在其上获取 &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; 锁。这样可以防止对表执行任何其他数据库操作（读取和写入），直到 &lt;code&gt;CLUSTER&lt;/code&gt; 完成为止。</target>
        </trans-unit>
        <trans-unit id="7d4eb9118baea2c47a40ccbe4939e2face5ca64c" translate="yes" xml:space="preserve">
          <source>When a table is clustered, PostgreSQL remembers which index it was clustered by. The form &lt;code&gt;CLUSTER table_name&lt;/code&gt; reclusters the table using the same index as before. You can also use the &lt;code&gt;CLUSTER&lt;/code&gt; or &lt;code&gt;SET WITHOUT CLUSTER&lt;/code&gt; forms of &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; to set the index to be used for future cluster operations, or to clear any previous setting.</source>
          <target state="translated">当一个表被集群时，PostgreSQL会记住该表被集群的索引。表格 &lt;code&gt;CLUSTER table_name&lt;/code&gt; 使用与以前相同的索引重新组合了表。您还可以使用&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;的 &lt;code&gt;CLUSTER&lt;/code&gt; 或 &lt;code&gt;SET WITHOUT CLUSTER&lt;/code&gt; 形式来设置用于将来的集群操作的索引，或清除任何先前的设置。</target>
        </trans-unit>
        <trans-unit id="8eb320e131f3533a19b92cb04f708af68aba5d79" translate="yes" xml:space="preserve">
          <source>When a table is clustered, it is physically reordered based on the index information. Clustering is a one-time operation: when the table is subsequently updated, the changes are not clustered. That is, no attempt is made to store new or updated rows according to their index order. (If one wishes, one can periodically recluster by issuing the command again. Also, setting the table's &lt;code&gt;fillfactor&lt;/code&gt; storage parameter to less than 100% can aid in preserving cluster ordering during updates, since updated rows are kept on the same page if enough space is available there.)</source>
          <target state="translated">对表进行集群时，将根据索引信息对其进行物理重新排序。集群是一项一次性操作：表在随后进行更新时，更改不会集群。即，没有尝试根据索引的顺序存储新行或更新行。 （如果愿意，可以通过再次发出命令来定期重新进行集群。而且，将表的 &lt;code&gt;fillfactor&lt;/code&gt; 存储参数设置为小于100％可以有助于在更新期间保留集群顺序，因为如果有足够的空间，则更新的行将保留在同一页上在那里可用。）</target>
        </trans-unit>
        <trans-unit id="49a3d5e22ae2844ff5c06f47ba492689eb79f5ba" translate="yes" xml:space="preserve">
          <source>When a table is created, it contains no data. The first thing to do before a database can be of much use is to insert data. Data is conceptually inserted one row at a time. Of course you can also insert more than one row, but there is no way to insert less than one row. Even if you know only some column values, a complete row must be created.</source>
          <target state="translated">当一个表被创建时,它不包含任何数据。在数据库能够发挥多大作用之前,首先要做的就是插入数据。从概念上讲,数据是一次插入一行的。当然你也可以插入多行,但没有办法插入少于一行的数据。即使你只知道一些列值,也必须创建一个完整的行。</target>
        </trans-unit>
        <trans-unit id="85bad0d57dfc672246f13e6ad8d8a435cc923083" translate="yes" xml:space="preserve">
          <source>When a table or index exceeds 1 GB, it is divided into gigabyte-sized &lt;em&gt;segments&lt;/em&gt;. The first segment's file name is the same as the filenode; subsequent segments are named filenode.1, filenode.2, etc. This arrangement avoids problems on platforms that have file size limitations. (Actually, 1 GB is just the default segment size. The segment size can be adjusted using the configuration option &lt;code&gt;--with-segsize&lt;/code&gt; when building PostgreSQL.) In principle, free space map and visibility map forks could require multiple segments as well, though this is unlikely to happen in practice.</source>
          <target state="translated">当表或索引超过1 GB时，它将被分为千兆字节大小的&lt;em&gt;段&lt;/em&gt;。第一段的文件名与filenode相同；随后的段分别命名为filenode.1，filenode.2等。这种安排可以避免在文件大小受限制的平台上出现问题。 （实际上，默认段大小为1 GB。在构建PostgreSQL时，可以使用配置选项 &lt;code&gt;--with-segsize&lt;/code&gt; 来调整段大小。）原则上，尽管可用空间图和可见性图派生也可能需要多个段实际上这不太可能发生。</target>
        </trans-unit>
        <trans-unit id="10a45cc60012ed72f0453155b208d80983750321" translate="yes" xml:space="preserve">
          <source>When a table reference names a table that is the parent of a table inheritance hierarchy, the table reference produces rows of not only that table but all of its descendant tables, unless the key word &lt;code&gt;ONLY&lt;/code&gt; precedes the table name. However, the reference produces only the columns that appear in the named table &amp;mdash; any columns added in subtables are ignored.</source>
          <target state="translated">当表引用命名为表继承层次结构的父级的表时，该表引用不仅会生成该表的行，还会生成其所有后代表的行，除非关键字 &lt;code&gt;ONLY&lt;/code&gt; 在表名之前。但是，该引用仅产生出现在命名表中的列-子表中添加的任何列都将被忽略。</target>
        </trans-unit>
        <trans-unit id="238107619ce9861ed394df0ebec618f90c2d4272" translate="yes" xml:space="preserve">
          <source>When a typed table is created, then the data types of the columns are determined by the underlying composite type and are not specified by the &lt;code&gt;CREATE TABLE&lt;/code&gt; command. But the &lt;code&gt;CREATE TABLE&lt;/code&gt; command can add defaults and constraints to the table and can specify storage parameters.</source>
          <target state="translated">创建类型表时，列的数据类型由基础复合类型确定，而不由 &lt;code&gt;CREATE TABLE&lt;/code&gt; 命令指定。但是 &lt;code&gt;CREATE TABLE&lt;/code&gt; 命令可以向表添加默认值和约束，并可以指定存储参数。</target>
        </trans-unit>
        <trans-unit id="40ca1a4315d7efd053d1772d2a1868caf568479c" translate="yes" xml:space="preserve">
          <source>When a value is to be used as an SQL literal or identifier, it is safest to arrange for it to be quoted. To quote the value of a variable as an SQL literal, write a colon followed by the variable name in single quotes. To quote the value as an SQL identifier, write a colon followed by the variable name in double quotes. These constructs deal correctly with quotes and other special characters embedded within the variable value. The previous example would be more safely written this way:</source>
          <target state="translated">当一个值被用作SQL文字或标识符时,最安全的做法是安排它被引用。要引用一个变量的值作为SQL文字,在变量名后面写一个冒号,并使用单引号。要将变量的值作为SQL标识符来引用,请在变量名后面用双引号写一个冒号。这些结构可以正确处理变量值中嵌入的引号和其他特殊字符。前面的例子这样写会更安全。</target>
        </trans-unit>
        <trans-unit id="55eaed5a13493b2841925c6347f0f009f1c69d52" translate="yes" xml:space="preserve">
          <source>When a view is locked, all relations appearing in the view definition query are also locked recursively with the same lock mode.</source>
          <target state="translated">当一个视图被锁定时,所有出现在视图定义查询中的关系也会以相同的锁定模式递归锁定。</target>
        </trans-unit>
        <trans-unit id="0731d9c33a2135d592b4234920022cbe73ac4232" translate="yes" xml:space="preserve">
          <source>When acquiring locks automatically for commands that reference tables, PostgreSQL always uses the least restrictive lock mode possible. &lt;code&gt;LOCK TABLE&lt;/code&gt; provides for cases when you might need more restrictive locking. For example, suppose an application runs a transaction at the &lt;code&gt;READ COMMITTED&lt;/code&gt; isolation level and needs to ensure that data in a table remains stable for the duration of the transaction. To achieve this you could obtain &lt;code&gt;SHARE&lt;/code&gt; lock mode over the table before querying. This will prevent concurrent data changes and ensure subsequent reads of the table see a stable view of committed data, because &lt;code&gt;SHARE&lt;/code&gt; lock mode conflicts with the &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; lock acquired by writers, and your &lt;code&gt;LOCK TABLE name IN SHARE MODE&lt;/code&gt; statement will wait until any concurrent holders of &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; mode locks commit or roll back. Thus, once you obtain the lock, there are no uncommitted writes outstanding; furthermore none can begin until you release the lock.</source>
          <target state="translated">当自动获取引用表的命令的锁时，PostgreSQL始终使用限制最小的锁模式。 &lt;code&gt;LOCK TABLE&lt;/code&gt; 提供了您可能需要更多限制性锁定的情况。例如，假设应用程序在 &lt;code&gt;READ COMMITTED&lt;/code&gt; 隔离级别上运行事务，并且需要确保表中的数据在事务期间保持稳定。为此，您可以在查询之前在表上获得 &lt;code&gt;SHARE&lt;/code&gt; 锁定模式。这将防止并发数据更改，并确保后续读取表时能看到已提交数据的稳定视图，因为 &lt;code&gt;SHARE&lt;/code&gt; 锁定模式与编写者和您获取的 &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; 锁定冲突 &lt;code&gt;LOCK TABLE name IN SHARE MODE&lt;/code&gt; 语句将等待，直到 &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; 模式锁的任何并发持有者提交或回滚。因此，一旦获得了锁，就不会有未提交的未完成的写操作。此外，在您释放锁之前，任何人都无法开始。</target>
        </trans-unit>
        <trans-unit id="b867fce21cdcff5c6925a3d0a1d7eb430184e42c" translate="yes" xml:space="preserve">
          <source>When adding an &lt;code&gt;interval&lt;/code&gt; value to (or subtracting an &lt;code&gt;interval&lt;/code&gt; value from) a &lt;code&gt;timestamp with time zone&lt;/code&gt; value, the days component advances or decrements the date of the &lt;code&gt;timestamp with time zone&lt;/code&gt; by the indicated number of days, keeping the time of day the same. Across daylight saving time changes (when the session time zone is set to a time zone that recognizes DST), this means &lt;code&gt;interval '1 day'&lt;/code&gt; does not necessarily equal &lt;code&gt;interval '24 hours'&lt;/code&gt;. For example, with the session time zone set to &lt;code&gt;America/Denver&lt;/code&gt;:</source>
          <target state="translated">在 &lt;code&gt;timestamp with time zone&lt;/code&gt; 值的时间戳上添加 &lt;code&gt;interval&lt;/code&gt; 值（或从中减去 &lt;code&gt;interval&lt;/code&gt; 值）时，days组件 &lt;code&gt;timestamp with time zone&lt;/code&gt; 的时间戳记的日期增加或减少指定的天数，从而使一天中的时间保持不变。在夏令时期间（当会话时区设置为可识别DST的时区时），这意味着 &lt;code&gt;interval '1 day'&lt;/code&gt; 不一定等于 &lt;code&gt;interval '24 hours'&lt;/code&gt; 。例如，将会话时区设置为 &lt;code&gt;America/Denver&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="71a870f6af21f8dafd4cc733a991bd99fd9d13ef" translate="yes" xml:space="preserve">
          <source>When adding an &lt;code&gt;interval&lt;/code&gt; value to (or subtracting an &lt;code&gt;interval&lt;/code&gt; value from) a &lt;code&gt;timestamp with time zone&lt;/code&gt; value, the days component advances or decrements the date of the &lt;code&gt;timestamp with time zone&lt;/code&gt; by the indicated number of days. Across daylight saving time changes (when the session time zone is set to a time zone that recognizes DST), this means &lt;code&gt;interval '1 day'&lt;/code&gt; does not necessarily equal &lt;code&gt;interval '24 hours'&lt;/code&gt;. For example, with the session time zone set to &lt;code&gt;CST7CDT&lt;/code&gt;, &lt;code&gt;timestamp with time zone '2005-04-02 12:00-07' + interval '1 day'&lt;/code&gt; will produce &lt;code&gt;timestamp with time zone '2005-04-03 12:00-06'&lt;/code&gt;, while adding &lt;code&gt;interval '24 hours'&lt;/code&gt; to the same initial &lt;code&gt;timestamp with time zone&lt;/code&gt; produces &lt;code&gt;timestamp with time zone '2005-04-03 13:00-06'&lt;/code&gt;, as there is a change in daylight saving time at &lt;code&gt;2005-04-03 02:00&lt;/code&gt; in time zone &lt;code&gt;CST7CDT&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;timestamp with time zone&lt;/code&gt; 值的时间戳上添加 &lt;code&gt;interval&lt;/code&gt; 值（或从中减去 &lt;code&gt;interval&lt;/code&gt; 值）时，天组件 &lt;code&gt;timestamp with time zone&lt;/code&gt; 的时间戳记的日期提前或减少指定的天数。跨夏令时更改（将会话时区设置为可识别DST的时区），这意味着 &lt;code&gt;interval '1 day'&lt;/code&gt; 不一定等于 &lt;code&gt;interval '24 hours'&lt;/code&gt; 。例如，将会 &lt;code&gt;CST7CDT&lt;/code&gt; 时区设置为CST7CDT， &lt;code&gt;timestamp with time zone '2005-04-02 12:00-07' + interval '1 day'&lt;/code&gt; &lt;code&gt;timestamp with time zone '2005-04-03 12:00-06'&lt;/code&gt; +间隔为'1天'将产生时区为'2005-04-03 12：00-的时间戳06'，同时添加 &lt;code&gt;interval '24 hours'&lt;/code&gt; 到 &lt;code&gt;timestamp with time zone&lt;/code&gt; 的相同初始时间戳会产生 &lt;code&gt;timestamp with time zone '2005-04-03 13:00-06'&lt;/code&gt; ，因为夏时制时间在 &lt;code&gt;2005-04-03 02:00&lt;/code&gt; 在时区 &lt;code&gt;CST7CDT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1434d3ccf06b603b0c31a66fe4b553e885790f9" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;Append&lt;/code&gt; node is used in a parallel plan, each process will execute the child plans in the order in which they appear, so that all participating processes cooperate to execute the first child plan until it is complete and then move to the second plan at around the same time. When a &lt;code&gt;Parallel Append&lt;/code&gt; is used instead, the executor will instead spread out the participating processes as evenly as possible across its child plans, so that multiple child plans are executed simultaneously. This avoids contention, and also avoids paying the startup cost of a child plan in those processes that never execute it.</source>
          <target state="translated">当在并行计划中使用 &lt;code&gt;Append&lt;/code&gt; 节点时，每个流程将按照它们出现的顺序执行子计划，以便所有参与的流程合作执行第一个子计划，直到完成为止，然后移至第二个计划。大约在同一时间。相反，当使用 &lt;code&gt;Parallel Append&lt;/code&gt; ，执行者将在其子计划中尽可能平均地分散参与的进程，以便同时执行多个子计划。这样可以避免争用，也可以避免在从未执行子计划的进程中支付子计划的启动成本。</target>
        </trans-unit>
        <trans-unit id="5e4864e701f86b03083b18f6c388ffa7cee629fe" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;INSERT&lt;/code&gt; command has an auxiliary &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clause, if the &lt;code&gt;UPDATE&lt;/code&gt; path is taken, the row to be updated is first checked against the &lt;code&gt;USING&lt;/code&gt; expressions of any &lt;code&gt;UPDATE&lt;/code&gt; policies, and then the new updated row is checked against the &lt;code&gt;WITH CHECK&lt;/code&gt; expressions. Note, however, that unlike a standalone &lt;code&gt;UPDATE&lt;/code&gt; command, if the existing row does not pass the &lt;code&gt;USING&lt;/code&gt; expressions, an error will be thrown (the &lt;code&gt;UPDATE&lt;/code&gt; path will &lt;em&gt;never&lt;/em&gt; be silently avoided).</source>
          <target state="translated">当 &lt;code&gt;INSERT&lt;/code&gt; 命令具有辅助的 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 子句时，如果采用 &lt;code&gt;UPDATE&lt;/code&gt; 路径，则首先根据任何 &lt;code&gt;UPDATE&lt;/code&gt; 策略的 &lt;code&gt;USING&lt;/code&gt; 表达式检查要更新的行，然后根据 &lt;code&gt;WITH CHECK&lt;/code&gt; 表达式检查新的更新的行。但是请注意，与独立的 &lt;code&gt;UPDATE&lt;/code&gt; 命令不同，如果现有行未通过 &lt;code&gt;USING&lt;/code&gt; 表达式，则将引发错误（&lt;em&gt;永远不会&lt;/em&gt;静默地避免 &lt;code&gt;UPDATE&lt;/code&gt; 路径）。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f5ddde61a4b6e8647a9abfe81db27fb6ec9b4388" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;N&lt;/code&gt;-dimensional array is pushed onto the beginning or end of an &lt;code&gt;N+1&lt;/code&gt;-dimensional array, the result is analogous to the element-array case above. Each &lt;code&gt;N&lt;/code&gt;-dimensional sub-array is essentially an element of the &lt;code&gt;N+1&lt;/code&gt;-dimensional array's outer dimension. For example:</source>
          <target state="translated">当将 &lt;code&gt;N&lt;/code&gt; 维数组推到 &lt;code&gt;N+1&lt;/code&gt; 维数组的开头或结尾时，结果类似于上述元素数组的情况。每个 &lt;code&gt;N&lt;/code&gt; 维子数组本质上是 &lt;code&gt;N+1&lt;/code&gt; 维数组外部维度的元素。例如：</target>
        </trans-unit>
        <trans-unit id="31260cf4fd42afa924c8ee13fbb974bf90d187b0" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; command affects an inheritance hierarchy, the output might look like this:</source>
          <target state="translated">当 &lt;code&gt;UPDATE&lt;/code&gt; 或 &lt;code&gt;DELETE&lt;/code&gt; 命令影响继承层次结构时，输出可能如下所示：</target>
        </trans-unit>
        <trans-unit id="5c47d72e8415ae2214a0b4c8ffca096b8ee4f7c5" translate="yes" xml:space="preserve">
          <source>When an aggregate expression appears in a subquery (see &lt;a href=&quot;sql-expressions#SQL-SYNTAX-SCALAR-SUBQUERIES&quot;&gt;Section 4.2.11&lt;/a&gt; and &lt;a href=&quot;functions-subquery&quot;&gt;Section 9.22&lt;/a&gt;), the aggregate is normally evaluated over the rows of the subquery. But an exception occurs if the aggregate's arguments (and &lt;code&gt;filter_clause&lt;/code&gt; if any) contain only outer-level variables: the aggregate then belongs to the nearest such outer level, and is evaluated over the rows of that query. The aggregate expression as a whole is then an outer reference for the subquery it appears in, and acts as a constant over any one evaluation of that subquery. The restriction about appearing only in the result list or &lt;code&gt;HAVING&lt;/code&gt; clause applies with respect to the query level that the aggregate belongs to.</source>
          <target state="translated">当聚合表达式出现在子查询中时（请参见&lt;a href=&quot;sql-expressions#SQL-SYNTAX-SCALAR-SUBQUERIES&quot;&gt;第4.2.11节&lt;/a&gt;和&lt;a href=&quot;functions-subquery&quot;&gt;第9.22节&lt;/a&gt;），通常会在子查询的行上对聚合进行求值。但是，如果聚合的参数（和 &lt;code&gt;filter_clause&lt;/code&gt; ,如果有的话）仅包含外层变量，则会发生异常：然后，该聚合属于最接近的外层变量，并在该查询的行上进行求值。总体上来说，聚合表达式是它所出现的子查询的外部引用，并且充当该子查询的任何评估的常量。仅在结果列表或 &lt;code&gt;HAVING&lt;/code&gt; 子句中出现的限制适用于聚合所属的查询级别。</target>
        </trans-unit>
        <trans-unit id="3611155577957d7d62aaa216921a5999dd2f0cc2" translate="yes" xml:space="preserve">
          <source>When an aggregate expression appears in a subquery (see &lt;a href=&quot;sql-expressions#SQL-SYNTAX-SCALAR-SUBQUERIES&quot;&gt;Section 4.2.11&lt;/a&gt; and &lt;a href=&quot;functions-subquery&quot;&gt;Section 9.23&lt;/a&gt;), the aggregate is normally evaluated over the rows of the subquery. But an exception occurs if the aggregate's arguments (and &lt;code&gt;filter_clause&lt;/code&gt; if any) contain only outer-level variables: the aggregate then belongs to the nearest such outer level, and is evaluated over the rows of that query. The aggregate expression as a whole is then an outer reference for the subquery it appears in, and acts as a constant over any one evaluation of that subquery. The restriction about appearing only in the result list or &lt;code&gt;HAVING&lt;/code&gt; clause applies with respect to the query level that the aggregate belongs to.</source>
          <target state="translated">当聚合表达式出现在子查询中时（请参见&lt;a href=&quot;sql-expressions#SQL-SYNTAX-SCALAR-SUBQUERIES&quot;&gt;第4.2.11节&lt;/a&gt;和&lt;a href=&quot;functions-subquery&quot;&gt;第9.23节&lt;/a&gt;），通常会在子查询的行上对聚合进行求值。但是，如果聚合的参数（和 &lt;code&gt;filter_clause&lt;/code&gt; 如果有的话）仅包含外层变量，则会发生异常：然后，该聚合属于最接近的外层变量，并在该查询的行上进行求值。总体上来说，聚合表达式是对其出现的子查询的外部引用，并充当该子查询的任何评估的常量。仅在结果列表或 &lt;code&gt;HAVING&lt;/code&gt; 子句中出现的限制适用于聚合所属的查询级别。</target>
        </trans-unit>
        <trans-unit id="34d2b87c80e1af3054e4c9d4d3c71d80a5607eb6" translate="yes" xml:space="preserve">
          <source>When an aggregate function is used as a window function, it aggregates over the rows within the current row's window frame. An aggregate used with &lt;code&gt;ORDER BY&lt;/code&gt; and the default window frame definition produces a &amp;ldquo;running sum&amp;rdquo; type of behavior, which may or may not be what's wanted. To obtain aggregation over the whole partition, omit &lt;code&gt;ORDER BY&lt;/code&gt; or use &lt;code&gt;ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING&lt;/code&gt;. Other frame specifications can be used to obtain other effects.</source>
          <target state="translated">当将聚合函数用作窗口函数时，它将在当前行的窗口框架内的行上聚合。与 &lt;code&gt;ORDER BY&lt;/code&gt; 和默认窗口框架定义一起使用的聚合会产生&amp;ldquo;运行总和&amp;rdquo;类型的行为，这可能是或可能不是想要的。要获得整个分区上的聚合，请忽略 &lt;code&gt;ORDER BY&lt;/code&gt; 或在 &lt;code&gt;ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING&lt;/code&gt; 使用ROWS。其他框架规格可用于获得其他效果。</target>
        </trans-unit>
        <trans-unit id="64b60eb6cf1570c88f1c1631b3c6e4c5824a2f8b" translate="yes" xml:space="preserve">
          <source>When an alias is applied to the output of a &lt;code&gt;JOIN&lt;/code&gt; clause, the alias hides the original name(s) within the &lt;code&gt;JOIN&lt;/code&gt;. For example:</source>
          <target state="translated">将别名应用于 &lt;code&gt;JOIN&lt;/code&gt; 子句的输出时，别名会将 &lt;code&gt;JOIN&lt;/code&gt; 内的原始名称隐藏起来。例如：</target>
        </trans-unit>
        <trans-unit id="0151521ad4c1bed3dd275586a7870760908f04a0" translate="yes" xml:space="preserve">
          <source>When an application receives this error message, it should abort the current transaction and retry the whole transaction from the beginning. The second time through, the transaction will see the previously-committed change as part of its initial view of the database, so there is no logical conflict in using the new version of the row as the starting point for the new transaction's update.</source>
          <target state="translated">当应用程序收到这个错误消息时,应该中止当前事务,从头开始重试整个事务。第二次重试时,事务将把之前提交的变更作为数据库初始视图的一部分,因此使用新版本的行作为新事务更新的起点并不存在逻辑冲突。</target>
        </trans-unit>
        <trans-unit id="4ee9b3bf4967c5d2fb0d054d753f418145337cf0" translate="yes" xml:space="preserve">
          <source>When an enum type is created, its members are assigned sort-order positions 1..&lt;code&gt;n&lt;/code&gt;. But members added later might be given negative or fractional values of &lt;code&gt;enumsortorder&lt;/code&gt;. The only requirement on these values is that they be correctly ordered and unique within each enum type.</source>
          <target state="translated">创建枚举类型时，将为其成员分配排序位置1 .. &lt;code&gt;n&lt;/code&gt; 。但是，稍后添加的成员可能会得到 &lt;code&gt;enumsortorder&lt;/code&gt; 的负值或分数值。对这些值的唯一要求是它们在每种枚举类型中的正确顺序和唯一性。</target>
        </trans-unit>
        <trans-unit id="0950043f7233c157a718d379ee2b34585d4ee731" translate="yes" xml:space="preserve">
          <source>When an index is declared unique, multiple table rows with equal indexed values are not allowed. Null values are not considered equal. A multicolumn unique index will only reject cases where all indexed columns are equal in multiple rows.</source>
          <target state="translated">当一个索引被声明为唯一时,不允许有多个索引值相等的表行。空值不被认为是相等的。多列唯一索引只会拒绝多行中所有索引列相等的情况。</target>
        </trans-unit>
        <trans-unit id="4aa9424b6df0026312433f3f9260dd9161451961" translate="yes" xml:space="preserve">
          <source>When an index page split is necessary, this function decides which entries on the page are to stay on the old page, and which are to move to the new page.</source>
          <target state="translated">当需要对索引页进行拆分时,该功能决定页面上哪些条目要留在旧页,哪些条目要移动到新页。</target>
        </trans-unit>
        <trans-unit id="d0d21498c252827ceaa7947111042a06bc38a5a5" translate="yes" xml:space="preserve">
          <source>When an index scan is used, a temporary copy of the table is created that contains the table data in the index order. Temporary copies of each index on the table are created as well. Therefore, you need free space on disk at least equal to the sum of the table size and the index sizes.</source>
          <target state="translated">当使用索引扫描时,会创建一个表的临时副本,该副本按照索引顺序包含表数据。表上每个索引的临时副本也会被创建。因此,你需要磁盘上的可用空间至少等于表大小和索引大小之和。</target>
        </trans-unit>
        <trans-unit id="dad624a33f1e64269d27c153de83dc5212addec4" translate="yes" xml:space="preserve">
          <source>When an object is created, it is assigned an owner. The owner is normally the role that executed the creation statement. For most kinds of objects, the initial state is that only the owner (or a superuser) can do anything with the object. To allow other roles to use it, &lt;em&gt;privileges&lt;/em&gt; must be granted.</source>
          <target state="translated">创建对象后，将为其分配一个所有者。所有者通常是执行创建语句的角色。对于大多数对象，初始状态是只有所有者（或超级用户）才能对对象执行任何操作。要允许其他角色使用它，必须授予&lt;em&gt;特权&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="016db50c093e11f2c3975978fc13dbb74ccca023" translate="yes" xml:space="preserve">
          <source>When an operator or function of the underlying type is applied to a domain value, the domain is automatically down-cast to the underlying type. Thus, for example, the result of &lt;code&gt;mytable.id - 1&lt;/code&gt; is considered to be of type &lt;code&gt;integer&lt;/code&gt; not &lt;code&gt;posint&lt;/code&gt;. We could write &lt;code&gt;(mytable.id - 1)::posint&lt;/code&gt; to cast the result back to &lt;code&gt;posint&lt;/code&gt;, causing the domain's constraints to be rechecked. In this case, that would result in an error if the expression had been applied to an &lt;code&gt;id&lt;/code&gt; value of 1. Assigning a value of the underlying type to a field or variable of the domain type is allowed without writing an explicit cast, but the domain's constraints will be checked.</source>
          <target state="translated">当基础类型的运算符或函数应用于域值时，该域会自动向下转换为基础类型。因此，例如， &lt;code&gt;mytable.id - 1&lt;/code&gt; 的结果被认为是 &lt;code&gt;integer&lt;/code&gt; 类型，而不是 &lt;code&gt;posint&lt;/code&gt; 类型。我们可以编写 &lt;code&gt;(mytable.id - 1)::posint&lt;/code&gt; 将结果转换回 &lt;code&gt;posint&lt;/code&gt; ，从而导致重新检查域的约束。在这种情况下，如果将表达式应用于 &lt;code&gt;id&lt;/code&gt; 值为1 ，则将导致错误。允许在不编写显式强制转换的情况下，将基础类型的值分配给域类型的字段或变量，但是域的约束将被检查。</target>
        </trans-unit>
        <trans-unit id="9d220c80b589197cba0d859444da322b0880222c" translate="yes" xml:space="preserve">
          <source>When archiving WAL data, we need to capture the contents of each segment file once it is filled, and save that data somewhere before the segment file is recycled for reuse. Depending on the application and the available hardware, there could be many different ways of &amp;ldquo;saving the data somewhere&amp;rdquo;: we could copy the segment files to an NFS-mounted directory on another machine, write them onto a tape drive (ensuring that you have a way of identifying the original name of each file), or batch them together and burn them onto CDs, or something else entirely. To provide the database administrator with flexibility, PostgreSQL tries not to make any assumptions about how the archiving will be done. Instead, PostgreSQL lets the administrator specify a shell command to be executed to copy a completed segment file to wherever it needs to go. The command could be as simple as a &lt;code&gt;cp&lt;/code&gt;, or it could invoke a complex shell script &amp;mdash; it's all up to you.</source>
          <target state="translated">归档WAL数据时，我们需要在每个段文件填充后捕获它们的内容，并将该数据保存在回收段文件以供重用之前的某个位置。根据应用程序和可用硬件的不同，可以有许多不同的&amp;ldquo;将数据保存到某处&amp;rdquo;的方式：我们可以将段文件复制到另一台计算机上NFS挂载的目录中，然后将它们写入磁带驱动器（确保您拥有一种识别每个文件的原始名称的方法），或将它们一起批处理并刻录到CD或其他任何东西上。为了给数据库管理员提供灵活性，PostgreSQL尝试不对如何完成归档做任何假设。取而代之的是，PostgreSQL让管理员指定要执行的shell命令，以将完整的段文件复制到需要的位置。该命令可能像 &lt;code&gt;cp&lt;/code&gt; ，或者它可以调用复杂的shell脚本-一切取决于您。</target>
        </trans-unit>
        <trans-unit id="c3d93c6ecb33c6eb94db27d2fba2d265ff994790" translate="yes" xml:space="preserve">
          <source>When autosummarization is enabled, each time a page range is filled a request is sent to autovacuum for it to execute a targeted summarization for that range, to be fulfilled at the end of the next worker run on the same database. If the request queue is full, the request is not recorded and a message is sent to the server log:</source>
          <target state="translated">当启用自动总结时,每次当一个页面范围被填满时,都会向autovacuum发送一个请求,让它对该范围执行一次有针对性的总结,在同一数据库上的下一个worker运行结束时完成。如果请求队列已满,则不记录该请求,并向服务器日志发送一条消息。</target>
        </trans-unit>
        <trans-unit id="f660851bc52c800a20554ffeb6a7df92726f03b4" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;-b&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; are given, the behavior is to output large objects, when data is being dumped, see the &lt;code&gt;-b&lt;/code&gt; documentation.</source>
          <target state="translated">当同时给出 &lt;code&gt;-b&lt;/code&gt; 和 &lt;code&gt;-B&lt;/code&gt; 时，行为是输出大对象，转储数据时，请参见 &lt;code&gt;-b&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="ad45f5349fac03bd7966e305b187db06383f5ed7" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;-n&lt;/code&gt; and &lt;code&gt;-N&lt;/code&gt; are given for the same schema name, the &lt;code&gt;-N&lt;/code&gt; switch wins and the schema is excluded.</source>
          <target state="translated">当为相同的模式名称同时指定 &lt;code&gt;-n&lt;/code&gt; 和 &lt;code&gt;-N&lt;/code&gt; 时， &lt;code&gt;-N&lt;/code&gt; 开关获胜，并且该模式被排除。</target>
        </trans-unit>
        <trans-unit id="ede3b8af7caafd954943fe5f04f3a1cc429ba018" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;-n&lt;/code&gt; and &lt;code&gt;-N&lt;/code&gt; are given, the behavior is to dump just the schemas that match at least one &lt;code&gt;-n&lt;/code&gt; switch but no &lt;code&gt;-N&lt;/code&gt; switches. If &lt;code&gt;-N&lt;/code&gt; appears without &lt;code&gt;-n&lt;/code&gt;, then schemas matching &lt;code&gt;-N&lt;/code&gt; are excluded from what is otherwise a normal dump.</source>
          <target state="translated">当同时给出 &lt;code&gt;-n&lt;/code&gt; 和 &lt;code&gt;-N&lt;/code&gt; 时，行为是仅转储与至少一个 &lt;code&gt;-n&lt;/code&gt; 开关匹配但不与 &lt;code&gt;-N&lt;/code&gt; 开关匹配的模式。如果 &lt;code&gt;-N&lt;/code&gt; 不带 &lt;code&gt;-n&lt;/code&gt; 出现，则与 &lt;code&gt;-N&lt;/code&gt; 匹配的模式将从正常转储中排除。</target>
        </trans-unit>
        <trans-unit id="031547c5dfb59556734ca49134f210c68e4c5520" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;-t&lt;/code&gt; and &lt;code&gt;-T&lt;/code&gt; are given, the behavior is to dump just the tables that match at least one &lt;code&gt;-t&lt;/code&gt; switch but no &lt;code&gt;-T&lt;/code&gt; switches. If &lt;code&gt;-T&lt;/code&gt; appears without &lt;code&gt;-t&lt;/code&gt;, then tables matching &lt;code&gt;-T&lt;/code&gt; are excluded from what is otherwise a normal dump.</source>
          <target state="translated">当同时给出 &lt;code&gt;-t&lt;/code&gt; 和 &lt;code&gt;-T&lt;/code&gt; 时，行为是仅转储与至少一个 &lt;code&gt;-t&lt;/code&gt; 开关匹配但不与 &lt;code&gt;-T&lt;/code&gt; 开关匹配的表。如果 &lt;code&gt;-T&lt;/code&gt; 不带 &lt;code&gt;-t&lt;/code&gt; 出现，则与 &lt;code&gt;-T&lt;/code&gt; 匹配的表将从正常转储中排除。</target>
        </trans-unit>
        <trans-unit id="6e63ae1dfc17974e0be483ba0ff638bbea32a3b3" translate="yes" xml:space="preserve">
          <source>When casting from &lt;code&gt;EAN13&lt;/code&gt; to another type, there is a run-time check that the value is within the domain of the other type, and an error is thrown if not. The other casts are simply relabelings that will always succeed.</source>
          <target state="translated">从 &lt;code&gt;EAN13&lt;/code&gt; 转换为另一种类型时，将在运行时检查该值是否在另一种类型的域之内，否则将引发错误。其他强制类型转换只是重新标记，将始终成功。</target>
        </trans-unit>
        <trans-unit id="9b112e4a8b6a5ae3071dcef7339526c0bc3d3e45" translate="yes" xml:space="preserve">
          <source>When changing this value, consider also adjusting &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS&quot;&gt;max_parallel_workers&lt;/a&gt;, &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-MAINTENANCE&quot;&gt;max_parallel_maintenance_workers&lt;/a&gt;, and &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-PER-GATHER&quot;&gt;max_parallel_workers_per_gather&lt;/a&gt;.</source>
          <target state="translated">更改此值时，还应考虑调整&lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS&quot;&gt;max_parallel_workers&lt;/a&gt;，&lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-MAINTENANCE&quot;&gt;max_parallel_maintenance_workers&lt;/a&gt;和&lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-PER-GATHER&quot;&gt;max_parallel_workers_per_gather&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="db437265a89a8152322953823332b5732e1c0d00" translate="yes" xml:space="preserve">
          <source>When choosing OIDs for a patch that is not expected to be committed immediately, best practice is to use a group of more-or-less consecutive OIDs starting with some random choice in the range 8000&amp;mdash;9999. This minimizes the risk of OID collisions with other patches being developed concurrently. To keep the 8000&amp;mdash;9999 range free for development purposes, after a patch has been committed to the master git repository its OIDs should be renumbered into available space below that range. Typically, this will be done near the end of each development cycle, moving all OIDs consumed by patches committed in that cycle at the same time. The script &lt;code&gt;renumber_oids.pl&lt;/code&gt; can be used for this purpose. If an uncommitted patch is found to have OID conflicts with some recently-committed patch, &lt;code&gt;renumber_oids.pl&lt;/code&gt; may also be useful for recovering from that situation.</source>
          <target state="translated">为不希望立即提交的补丁程序选择OID时，最佳实践是使用一组或多或少连续的OID，从8000-9999范围内的一些随机选择开始。这将与同时开发的其他补丁程序发生OID冲突的风险降到最低。为了使8000-9999范围自由用于开发目的，在将补丁提交到主git存储库后，其OID应重新编号为该范围以下的可用空间。通常，这将在每个开发周期结束时完成，同时移动该周期中提交的补丁所消耗的所有OID。脚本 &lt;code&gt;renumber_oids.pl&lt;/code&gt; 可用于此目的。如果发现未提交的补丁程序与最近提交的某个补丁程序有OID冲突，请 &lt;code&gt;renumber_oids.pl&lt;/code&gt; 对于从这种情况中恢复可能也很有用。</target>
        </trans-unit>
        <trans-unit id="9881b7b2a51c119b916b26c12b2f50a595bc868b" translate="yes" xml:space="preserve">
          <source>When compiled with OpenSSL, there will be more algorithms available. Also public-key encryption functions will be faster as OpenSSL has more optimized BIGNUM functions.</source>
          <target state="translated">用OpenSSL编译后,会有更多的算法可用。同时由于OpenSSL有更多优化的BIGNUM函数,公钥加密函数也会更快。</target>
        </trans-unit>
        <trans-unit id="5f2a4f35ae5e876b04f4e8702b5ef942899c0855" translate="yes" xml:space="preserve">
          <source>When compiled with zlib, PGP encryption functions are able to compress data before encrypting.</source>
          <target state="translated">当用zlib编译时,PGP加密函数能够在加密前对数据进行压缩。</target>
        </trans-unit>
        <trans-unit id="4526356cc9d2b5524d1c0613a2cac8e5545975fc" translate="yes" xml:space="preserve">
          <source>When compiling the preprocessed C code files, the compiler needs to be able to find the ECPG header files in the PostgreSQL include directory. Therefore, you might have to use the &lt;code&gt;-I&lt;/code&gt; option when invoking the compiler (e.g., &lt;code&gt;-I/usr/local/pgsql/include&lt;/code&gt;).</source>
          <target state="translated">编译预处理的C代码文件时，编译器需要能够在PostgreSQL包含目录中找到ECPG头文件。因此，在调用编译器时，您可能必须使用 &lt;code&gt;-I&lt;/code&gt; 选项（例如， &lt;code&gt;-I/usr/local/pgsql/include&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f6cfdda77ce1539f64bc346b96c3160b7466725a" translate="yes" xml:space="preserve">
          <source>When computing the selectivity for a query involving functionally dependent columns, the planner adjusts the per-condition selectivity estimates using the dependency coefficients so as not to produce an underestimate.</source>
          <target state="translated">当计算一个涉及功能依赖列的查询的选择性时,规划器使用依赖系数调整每个条件的选择性估计,以避免产生低估。</target>
        </trans-unit>
        <trans-unit id="29ea042e28fa2362fa9c26ca7e49e9bd0ec5e906" translate="yes" xml:space="preserve">
          <source>When connecting to the database make sure you have a ticket for a principal matching the requested database user name. For example, for database user name &lt;code&gt;fred&lt;/code&gt;, principal &lt;code&gt;fred@EXAMPLE.COM&lt;/code&gt; would be able to connect. To also allow principal &lt;code&gt;fred/users.example.com@EXAMPLE.COM&lt;/code&gt;, use a user name map, as described in &lt;a href=&quot;auth-username-maps&quot;&gt;Section 20.2&lt;/a&gt;.</source>
          <target state="translated">连接到数据库时，请确保您具有与请求的数据库用户名匹配的主体票证。例如，对于数据库用户名 &lt;code&gt;fred&lt;/code&gt; ，主体 &lt;code&gt;fred@EXAMPLE.COM&lt;/code&gt; 将可以连接。要还允许主体 &lt;code&gt;fred/users.example.com@EXAMPLE.COM&lt;/code&gt; ，请使用用户名映射，如&lt;a href=&quot;auth-username-maps&quot;&gt;第20.2节中&lt;/a&gt;所述。</target>
        </trans-unit>
        <trans-unit id="7fb2d529ca9e4c06995d0fca116b867907b7f0d6" translate="yes" xml:space="preserve">
          <source>When connecting to the database server, a client must specify in its connection request the name of the database it wants to connect to. It is not possible to access more than one database per connection. However, an application is not restricted in the number of connections it opens to the same or other databases. Databases are physically separated and access control is managed at the connection level. If one PostgreSQL server instance is to house projects or users that should be separate and for the most part unaware of each other, it is therefore recommended to put them into separate databases. If the projects or users are interrelated and should be able to use each other's resources, they should be put in the same database but possibly into separate schemas. Schemas are a purely logical structure and who can access what is managed by the privilege system. More information about managing schemas is in &lt;a href=&quot;ddl-schemas&quot;&gt;Section 5.9&lt;/a&gt;.</source>
          <target state="translated">连接到数据库服务器时，客户端必须在其连接请求中指定要连接的数据库的名称。每个连接最多只能访问一个数据库。但是，应用程序在打开到相同或其他数据库的连接数方面不受限制。数据库在物理上是分离的，并且访问控制是在连接级别上进行管理的。如果一个PostgreSQL服务器实例用于容纳应该分开的项目或用户，并且大多数情况下彼此不了解，则建议将它们放在单独的数据库中。如果项目或用户是相互关联的，并且应该能够使用彼此的资源，则应将它们放在同一数据库中，但可能放在单独的架构中。模式是纯粹的逻辑结构，谁可以访问特权系统管理的内容。有关管理模式的更多信息，请参见&lt;a href=&quot;ddl-schemas&quot;&gt;5.9节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a8b02ea043cf0c79a30fc9e7d7d2f7eb7a91ce38" translate="yes" xml:space="preserve">
          <source>When connecting to the database server, a client must specify the database name in its connection request. It is not possible to access more than one database per connection. However, clients can open multiple connections to the same database, or different databases. Database-level security has two components: access control (see &lt;a href=&quot;auth-pg-hba-conf&quot;&gt;Section 20.1&lt;/a&gt;), managed at the connection level, and authorization control (see &lt;a href=&quot;ddl-priv&quot;&gt;Section 5.7&lt;/a&gt;), managed via the grant system. Foreign data wrappers (see &lt;a href=&quot;postgres-fdw&quot;&gt;postgres_fdw&lt;/a&gt;) allow for objects within one database to act as proxies for objects in other database or clusters. The older dblink module (see &lt;a href=&quot;https://www.postgresql.org/docs/13/dblink.html&quot;&gt;dblink&lt;/a&gt;) provides a similar capability. By default, all users can connect to all databases using all connection methods.</source>
          <target state="translated">连接到数据库服务器时，客户端必须在其连接请求中指定数据库名称。每个连接最多只能访问一个数据库。但是，客户端可以打开与同一数据库或不同数据库的多个连接。数据库级安全性包含两个组件：访问控制（请参阅&lt;a href=&quot;auth-pg-hba-conf&quot;&gt;第20.1节&lt;/a&gt;），在连接级别进行管理；以及授权控制（请参阅&lt;a href=&quot;ddl-priv&quot;&gt;第5.7节&lt;/a&gt;），通过授予系统进行管理。外部数据包装器（请参阅&lt;a href=&quot;postgres-fdw&quot;&gt;postgres_fdw&lt;/a&gt;）允许一个数据库中的对象充当其他数据库或集群中对象的代理。较早的dblink模块（请参阅&lt;a href=&quot;https://www.postgresql.org/docs/13/dblink.html&quot;&gt;dblink&lt;/a&gt;）提供了类似的功能。默认情况下，所有用户都可以使用所有连接方法连接到所有数据库。</target>
        </trans-unit>
        <trans-unit id="12d0d4ecddcc515b05d012f2d76c53d27fb85b80" translate="yes" xml:space="preserve">
          <source>When continuous WAL archiving is used in a standby, there are two different scenarios: the WAL archive can be shared between the primary and the standby, or the standby can have its own WAL archive. When the standby has its own WAL archive, set &lt;code&gt;archive_mode&lt;/code&gt; to &lt;code&gt;always&lt;/code&gt;, and the standby will call the archive command for every WAL segment it receives, whether it's by restoring from the archive or by streaming replication. The shared archive can be handled similarly, but the &lt;code&gt;archive_command&lt;/code&gt; must test if the file being archived exists already, and if the existing file has identical contents. This requires more care in the &lt;code&gt;archive_command&lt;/code&gt;, as it must be careful to not overwrite an existing file with different contents, but return success if the exactly same file is archived twice. And all that must be done free of race conditions, if two servers attempt to archive the same file at the same time.</source>
          <target state="translated">在备用数据库中使用连续WAL归档时，有两种不同的方案：WAL归档文件可以在主数据库和备用数据库之间共享，或者备用数据库可以拥有自己的WAL归档文件。当备用数据库拥有自己的WAL归档文件时，请将 &lt;code&gt;archive_mode&lt;/code&gt; 设置为 &lt;code&gt;always&lt;/code&gt; ，备用数据库将针对接收到的每个WAL段调用归档命令，无论是通过从归档文件还原还是通过流复制进行。共享归档文件的处理方式类似，但是 &lt;code&gt;archive_command&lt;/code&gt; 必须测试正在归档的文件是否已经存在，以及现有文件的内容是否相同。这需要在 &lt;code&gt;archive_command&lt;/code&gt; 中多加注意，因为必须小心不要覆盖内容不同的现有文件，但是如果完全相同的文件被存档两次，则返回成功。如果两台服务器尝试同时存档同一文件，则必须在没有竞争条件的情况下完成所有这些操作。</target>
        </trans-unit>
        <trans-unit id="206b825e98c6a586acace075380fd147e6696a55" translate="yes" xml:space="preserve">
          <source>When converting textual JSON input into &lt;code&gt;jsonb&lt;/code&gt;, the primitive types described by RFC 7159 are effectively mapped onto native PostgreSQL types, as shown in &lt;a href=&quot;datatype-json#JSON-TYPE-MAPPING-TABLE&quot;&gt;Table 8.23&lt;/a&gt;. Therefore, there are some minor additional constraints on what constitutes valid &lt;code&gt;jsonb&lt;/code&gt; data that do not apply to the &lt;code&gt;json&lt;/code&gt; type, nor to JSON in the abstract, corresponding to limits on what can be represented by the underlying data type. Notably, &lt;code&gt;jsonb&lt;/code&gt; will reject numbers that are outside the range of the PostgreSQL &lt;code&gt;numeric&lt;/code&gt; data type, while &lt;code&gt;json&lt;/code&gt; will not. Such implementation-defined restrictions are permitted by RFC 7159. However, in practice such problems are far more likely to occur in other implementations, as it is common to represent JSON's &lt;code&gt;number&lt;/code&gt; primitive type as IEEE 754 double precision floating point (which RFC 7159 explicitly anticipates and allows for). When using JSON as an interchange format with such systems, the danger of losing numeric precision compared to data originally stored by PostgreSQL should be considered.</source>
          <target state="translated">将文本JSON输入转换为 &lt;code&gt;jsonb&lt;/code&gt; 时，RFC 7159描述的原始类型将有效地映射到本地PostgreSQL类型，如&lt;a href=&quot;datatype-json#JSON-TYPE-MAPPING-TABLE&quot;&gt;表8.23&lt;/a&gt;所示。因此，对于构成有效 &lt;code&gt;jsonb&lt;/code&gt; 数据的内容存在一些较小的附加约束，这些约束既不适用于 &lt;code&gt;json&lt;/code&gt; 类型，也不适用于抽象的JSON，这对应于基础数据类型可以表示的内容的限制。值得注意的是， &lt;code&gt;jsonb&lt;/code&gt; 将拒绝PostgreSQL &lt;code&gt;numeric&lt;/code&gt; 数据类型范围之外的数字，而 &lt;code&gt;json&lt;/code&gt; 将不会。RFC 7159允许此类实现定义的限制。但是，实际上，在其他实现中更容易出现此类问题，因为通常将JSON的 &lt;code&gt;number&lt;/code&gt; 基元类型表示为IEEE 754双精度浮点数（RFC 7159明确预期这种情况）并允许）。当使用JSON作为此类系统的交换格式时，应考虑与PostgreSQL最初存储的数据相比失去数字精度的危险。</target>
        </trans-unit>
        <trans-unit id="e063ec55d6b5085c54d075810d580142922489d3" translate="yes" xml:space="preserve">
          <source>When creating a comment on a constraint, a trigger, a rule or a policy these parameters specify the name of the table or domain on which that object is defined.</source>
          <target state="translated">在创建约束、触发器、规则或策略的注释时,这些参数指定了定义该对象的表或域的名称。</target>
        </trans-unit>
        <trans-unit id="696e17ed5a7d60938c1cece83fb1d6b1c0903390" translate="yes" xml:space="preserve">
          <source>When creating a hash partition, a modulus and remainder must be specified. The modulus must be a positive integer, and the remainder must be a non-negative integer less than the modulus. Typically, when initially setting up a hash-partitioned table, you should choose a modulus equal to the number of partitions and assign every table the same modulus and a different remainder (see examples, below). However, it is not required that every partition have the same modulus, only that every modulus which occurs among the partitions of a hash-partitioned table is a factor of the next larger modulus. This allows the number of partitions to be increased incrementally without needing to move all the data at once. For example, suppose you have a hash-partitioned table with 8 partitions, each of which has modulus 8, but find it necessary to increase the number of partitions to 16. You can detach one of the modulus-8 partitions, create two new modulus-16 partitions covering the same portion of the key space (one with a remainder equal to the remainder of the detached partition, and the other with a remainder equal to that value plus 8), and repopulate them with data. You can then repeat this -- perhaps at a later time -- for each modulus-8 partition until none remain. While this may still involve a large amount of data movement at each step, it is still better than having to create a whole new table and move all the data at once.</source>
          <target state="translated">当创建哈希分区时,必须指定模数和余数,模数必须是正整数,余数必须是小于模数的非负整数。模数必须是一个正整数,余数必须是一个小于模数的非负整数。通常情况下,当最初设置一个哈希分区表时,您应该选择一个与分区数量相等的模数,并为每个表分配相同的模数和不同的余数(参见下面的示例)。但是,并不要求每个分区都有相同的模数,只要求在哈希分区表的分区之间出现的每个模数都是下一个较大模数的系数。这样就可以逐步增加分区的数量,而不需要一次性移动所有的数据。例如,假设你有一个有8个分区的哈希分区表,每个分区的模数是8,但发现有必要将分区的数量增加到16。你可以分离其中一个模数为8的分区,创建两个新的模数为16的分区,覆盖键空间的相同部分(一个分区的剩余量等于被分离分区的剩余量,另一个分区的剩余量等于该值加8),然后用数据重新填充它们。然后,你可以重复这样做--也许在以后的时间--对每个模数-8的分区进行操作,直到没有剩余。虽然这在每一步都可能涉及到大量的数据移动,但仍比必须创建一个全新的表并一次性移动所有数据要好。</target>
        </trans-unit>
        <trans-unit id="dc592c55de3b2852cc094ece1e21e03a790645cd" translate="yes" xml:space="preserve">
          <source>When creating a list partition, &lt;code&gt;NULL&lt;/code&gt; can be specified to signify that the partition allows the partition key column to be null. However, there cannot be more than one such list partition for a given parent table. &lt;code&gt;NULL&lt;/code&gt; cannot be specified for range partitions.</source>
          <target state="translated">创建列表分区时，可以指定 &lt;code&gt;NULL&lt;/code&gt; 表示该分区允许分区键列为空。但是，给定的父表最多只能有一个这样的列表分区。无法为范围分区指定 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="959c4be92ae7a89cd93733c9fb53bfb204d0cf54" translate="yes" xml:space="preserve">
          <source>When creating a range partition involving more than one column, it can also make sense to use &lt;code&gt;MAXVALUE&lt;/code&gt; as part of the lower bound, and &lt;code&gt;MINVALUE&lt;/code&gt; as part of the upper bound. For example, a partition defined using &lt;code&gt;FROM (0, MAXVALUE) TO (10, MAXVALUE)&lt;/code&gt; allows any rows where the first partition key column is greater than 0 and less than or equal to 10. Similarly, a partition defined using &lt;code&gt;FROM ('a', MINVALUE) TO ('b', MINVALUE)&lt;/code&gt; allows any rows where the first partition key column starts with &quot;a&quot;.</source>
          <target state="translated">创建包含多列的范围分区时，也可以将 &lt;code&gt;MAXVALUE&lt;/code&gt; 用作下限，而将 &lt;code&gt;MINVALUE&lt;/code&gt; 用作上限。例如，使用 &lt;code&gt;FROM (0, MAXVALUE) TO (10, MAXVALUE)&lt;/code&gt; 定义的分区允许第一行分区键列大于0且小于或等于10的任何行。类似地，使用 &lt;code&gt;FROM ('a', MINVALUE) TO ('b', MINVALUE)&lt;/code&gt; 允许第一个分区键列以&amp;ldquo; a&amp;rdquo;开头的任何行。</target>
        </trans-unit>
        <trans-unit id="57bc08d42f10eaae11d2af1199ad3605b863277f" translate="yes" xml:space="preserve">
          <source>When creating a range partition, the lower bound specified with &lt;code&gt;FROM&lt;/code&gt; is an inclusive bound, whereas the upper bound specified with &lt;code&gt;TO&lt;/code&gt; is an exclusive bound. That is, the values specified in the &lt;code&gt;FROM&lt;/code&gt; list are valid values of the corresponding partition key columns for this partition, whereas those in the &lt;code&gt;TO&lt;/code&gt; list are not. Note that this statement must be understood according to the rules of row-wise comparison (&lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;Section 9.23.5&lt;/a&gt;). For example, given &lt;code&gt;PARTITION BY RANGE (x,y)&lt;/code&gt;, a partition bound &lt;code&gt;FROM (1, 2) TO (3, 4)&lt;/code&gt; allows &lt;code&gt;x=1&lt;/code&gt; with any &lt;code&gt;y&amp;gt;=2&lt;/code&gt;, &lt;code&gt;x=2&lt;/code&gt; with any non-null &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;x=3&lt;/code&gt; with any &lt;code&gt;y&amp;lt;4&lt;/code&gt;.</source>
          <target state="translated">创建范围分区时，由 &lt;code&gt;FROM&lt;/code&gt; 指定的下限是一个包含边界，而由 &lt;code&gt;TO&lt;/code&gt; 指定的上限是一个排他边界。也就是说，在 &lt;code&gt;FROM&lt;/code&gt; 列表中指定的值是此分区的相应分区键列的有效值，而在 &lt;code&gt;TO&lt;/code&gt; 列表中的值不是。请注意，必须根据行比较规则（&lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;第9.23.5节&lt;/a&gt;）来理解此语句。例如，给定 &lt;code&gt;PARTITION BY RANGE (x,y)&lt;/code&gt; ， &lt;code&gt;FROM (1, 2) TO (3, 4)&lt;/code&gt; 绑定的分区允许 &lt;code&gt;x=1&lt;/code&gt; 且任何 &lt;code&gt;y&amp;gt;=2&lt;/code&gt; ， &lt;code&gt;x=2&lt;/code&gt; 任意非null &lt;code&gt;y&lt;/code&gt; ，和 &lt;code&gt;x=3&lt;/code&gt; 与任何 &lt;code&gt;y&amp;lt;4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e7765f2e543f0af71f77765315c7b66c2db81da2" translate="yes" xml:space="preserve">
          <source>When creating a range partition, the lower bound specified with &lt;code&gt;FROM&lt;/code&gt; is an inclusive bound, whereas the upper bound specified with &lt;code&gt;TO&lt;/code&gt; is an exclusive bound. That is, the values specified in the &lt;code&gt;FROM&lt;/code&gt; list are valid values of the corresponding partition key columns for this partition, whereas those in the &lt;code&gt;TO&lt;/code&gt; list are not. Note that this statement must be understood according to the rules of row-wise comparison (&lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;Section 9.24.5&lt;/a&gt;). For example, given &lt;code&gt;PARTITION BY RANGE (x,y)&lt;/code&gt;, a partition bound &lt;code&gt;FROM (1, 2) TO (3, 4)&lt;/code&gt; allows &lt;code&gt;x=1&lt;/code&gt; with any &lt;code&gt;y&amp;gt;=2&lt;/code&gt;, &lt;code&gt;x=2&lt;/code&gt; with any non-null &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;x=3&lt;/code&gt; with any &lt;code&gt;y&amp;lt;4&lt;/code&gt;.</source>
          <target state="translated">创建范围分区时，由 &lt;code&gt;FROM&lt;/code&gt; 指定的下限是一个包含边界，而由 &lt;code&gt;TO&lt;/code&gt; 指定的上限是一个排他边界。也就是说，在 &lt;code&gt;FROM&lt;/code&gt; 列表中指定的值是此分区的相应分区键列的有效值，而在 &lt;code&gt;TO&lt;/code&gt; 列表中的值不是。请注意，必须根据逐行比较的规则（&lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;第9.24.5节&lt;/a&gt;）来理解此语句。例如，给定 &lt;code&gt;PARTITION BY RANGE (x,y)&lt;/code&gt; ， &lt;code&gt;FROM (1, 2) TO (3, 4)&lt;/code&gt; 绑定的分区允许 &lt;code&gt;x=1&lt;/code&gt; 且任何 &lt;code&gt;y&amp;gt;=2&lt;/code&gt; ， &lt;code&gt;x=2&lt;/code&gt; 任意非null &lt;code&gt;y&lt;/code&gt; ，和 &lt;code&gt;x=3&lt;/code&gt; 与任何 &lt;code&gt;y&amp;lt;4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="812122c3d99be13340fb205c1949bf12eabae44b" translate="yes" xml:space="preserve">
          <source>When creating a replication slot (the default behavior), &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; cannot be executed inside a transaction block.</source>
          <target state="translated">创建复制插槽（默认行为）时，无法在事务块内部执行 &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de7cd6bf9e49c5d84cc8863ddd6e1c17c3e9e579" translate="yes" xml:space="preserve">
          <source>When creating a slot, use the specified logical decoding output plugin. See &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;. This option has no effect if the slot already exists.</source>
          <target state="translated">创建插槽时，请使用指定的逻辑解码输出插件。参见&lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;第48章&lt;/a&gt;。如果插槽已存在，则此选项无效。</target>
        </trans-unit>
        <trans-unit id="1423e49aad04fb2810f02511e3e72b04f513e2b2" translate="yes" xml:space="preserve">
          <source>When creating a slot, use the specified logical decoding output plugin. See &lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;. This option has no effect if the slot already exists.</source>
          <target state="translated">创建插槽时，请使用指定的逻辑解码输出插件。参见&lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding.html&quot;&gt;第48章&lt;/a&gt;。如果插槽已存在，则此选项无效。</target>
        </trans-unit>
        <trans-unit id="005a2c498e4cc6e0542ca9414edc2d0ef17812bb" translate="yes" xml:space="preserve">
          <source>When creating a subscription, the remote host is not reachable or in an unclear state. In that case, the subscription can be created using the &lt;code&gt;connect = false&lt;/code&gt; option. The remote host will then not be contacted at all. This is what pg_dump uses. The remote replication slot will then have to be created manually before the subscription can be activated.</source>
          <target state="translated">创建订阅时，远程主机不可访问或状态不清楚。在这种情况下，可以使用 &lt;code&gt;connect = false&lt;/code&gt; 选项创建订阅。这样就根本不会联系远程主机。这就是pg_dump使用的。然后必须先手动创建远程复制插槽，然后才能激活订阅。</target>
        </trans-unit>
        <trans-unit id="34ca2fb6b711dd16e241f960cfce7ef591df396f" translate="yes" xml:space="preserve">
          <source>When creating a subscription, the replication slot already exists. In that case, the subscription can be created using the &lt;code&gt;create_slot = false&lt;/code&gt; option to associate with the existing slot.</source>
          <target state="translated">创建预订时，复制插槽已存在。在这种情况下，可以使用 &lt;code&gt;create_slot = false&lt;/code&gt; 选项与现有插槽关联来创建订阅。</target>
        </trans-unit>
        <trans-unit id="16abed6745cbdfc58355b822cc58590cd4574664" translate="yes" xml:space="preserve">
          <source>When creating an index on a partitioned table, this column is set to the number of partitions on which the index has been completed.</source>
          <target state="translated">在分区表上创建索引时,此列设置为索引已完成的分区数。</target>
        </trans-unit>
        <trans-unit id="0cf84112606c62d754e9e14623f4cabe94d1c440" translate="yes" xml:space="preserve">
          <source>When creating an index on a partitioned table, this column is set to the total number of partitions on which the index is to be created.</source>
          <target state="translated">当在分区表上创建索引时,此列设置为要在其上创建索引的分区总数。</target>
        </trans-unit>
        <trans-unit id="0f225feca5ba0ff2fa1c5fa9fb76ca1ce05ad30d" translate="yes" xml:space="preserve">
          <source>When dealing with an &lt;code&gt;allTheSame&lt;/code&gt; tuple, a &lt;code&gt;choose&lt;/code&gt; result of &lt;code&gt;spgMatchNode&lt;/code&gt; is interpreted to mean that the new value can be assigned to any of the equivalent nodes; the core code will ignore the supplied &lt;code&gt;nodeN&lt;/code&gt; value and descend into one of the nodes at random (so as to keep the tree balanced). It is an error for &lt;code&gt;choose&lt;/code&gt; to return &lt;code&gt;spgAddNode&lt;/code&gt;, since that would make the nodes not all equivalent; the &lt;code&gt;spgSplitTuple&lt;/code&gt; action must be used if the value to be inserted doesn't match the existing nodes.</source>
          <target state="translated">当与处理 &lt;code&gt;allTheSame&lt;/code&gt; 元组，一个 &lt;code&gt;choose&lt;/code&gt; 的结果 &lt;code&gt;spgMatchNode&lt;/code&gt; 被解释为新的值可以被分配到任何相当于节点;核心代码将忽略提供的 &lt;code&gt;nodeN&lt;/code&gt; 值，并随机下降到其中一个节点中（以保持树的平衡）。 &lt;code&gt;choose&lt;/code&gt; 返回 &lt;code&gt;spgAddNode&lt;/code&gt; 是错误的，因为这会使节点不完全相等。的 &lt;code&gt;spgSplitTuple&lt;/code&gt; 必须使用行动，如果要被插入的值不匹配的现有节点。</target>
        </trans-unit>
        <trans-unit id="cc81dfaf2529806492d6926ee92f707f3d6c4c1b" translate="yes" xml:space="preserve">
          <source>When dealing with an &lt;code&gt;allTheSame&lt;/code&gt; tuple, the &lt;code&gt;inner_consistent&lt;/code&gt; function should return either all or none of the nodes as targets for continuing the index search, since they are all equivalent. This may or may not require any special-case code, depending on how much the &lt;code&gt;inner_consistent&lt;/code&gt; function normally assumes about the meaning of the nodes.</source>
          <target state="translated">处理 &lt;code&gt;allTheSame&lt;/code&gt; 元组时， &lt;code&gt;inner_consistent&lt;/code&gt; 函数应返回所有节点或不返回任何节点作为继续进行索引搜索的目标，因为它们都是等效的。这可能需要也可能不需要任何特殊情况的代码，具体取决于 &lt;code&gt;inner_consistent&lt;/code&gt; 函数通常假定的节点含义。</target>
        </trans-unit>
        <trans-unit id="b32b90019e8bbf81fee22cbcc2778aa7cfddfd6c" translate="yes" xml:space="preserve">
          <source>When dealing with multiple-argument aggregate functions, note that the &lt;code&gt;ORDER BY&lt;/code&gt; clause goes after all the aggregate arguments. For example, write this:</source>
          <target state="translated">处理多参数聚合函数时，请注意， &lt;code&gt;ORDER BY&lt;/code&gt; 子句位于所有聚合参数之后。例如，编写以下代码：</target>
        </trans-unit>
        <trans-unit id="ec8f5c244f8f3ee5e69ba2a3cc1d82f9a3714553" translate="yes" xml:space="preserve">
          <source>When dealing with outer joins, you might see join plan nodes with both &amp;ldquo;Join Filter&amp;rdquo; and plain &amp;ldquo;Filter&amp;rdquo; conditions attached. Join Filter conditions come from the outer join's &lt;code&gt;ON&lt;/code&gt; clause, so a row that fails the Join Filter condition could still get emitted as a null-extended row. But a plain Filter condition is applied after the outer-join rules and so acts to remove rows unconditionally. In an inner join there is no semantic difference between these types of filters.</source>
          <target state="translated">在处理外部联接时，您可能会看到同时附有&amp;ldquo;联接过滤器&amp;rdquo;和普通&amp;ldquo;过滤器&amp;rdquo;条件的联接计划节点。联接过滤器条件来自外部联接的 &lt;code&gt;ON&lt;/code&gt; 子句，因此未通过联接过滤器条件的行仍可能作为空扩展的行发出。但是在外部联接规则之后应用了普通的Filter条件，因此可以无条件删除行。在内部联接中，这些类型的过滤器之间没有语义差异。</target>
        </trans-unit>
        <trans-unit id="8a4bff252219a510e2ce0b73debb16a2f8ba45f1" translate="yes" xml:space="preserve">
          <source>When deciding what is a longer or shorter match, match lengths are measured in characters, not collating elements. An empty string is considered longer than no match at all. For example: &lt;code&gt;bb*&lt;/code&gt; matches the three middle characters of &lt;code&gt;abbbc&lt;/code&gt;; &lt;code&gt;(week|wee)(night|knights)&lt;/code&gt; matches all ten characters of &lt;code&gt;weeknights&lt;/code&gt;; when &lt;code&gt;(.*).*&lt;/code&gt; is matched against &lt;code&gt;abc&lt;/code&gt; the parenthesized subexpression matches all three characters; and when &lt;code&gt;(a*)*&lt;/code&gt; is matched against &lt;code&gt;bc&lt;/code&gt; both the whole RE and the parenthesized subexpression match an empty string.</source>
          <target state="translated">在确定什么是更长或更短的匹配时，匹配长度以字符而不是元素排序。空字符串被认为比不匹配要长。例如： &lt;code&gt;bb*&lt;/code&gt; 匹配 &lt;code&gt;abbbc&lt;/code&gt; 的三个中间字符； &lt;code&gt;(week|wee)(night|knights)&lt;/code&gt; 相匹配的所有十个字符 &lt;code&gt;weeknights&lt;/code&gt; ;当 &lt;code&gt;(.*).*&lt;/code&gt; 与 &lt;code&gt;abc&lt;/code&gt; 匹配时，带括号的子表达式将匹配所有三个字符；当 &lt;code&gt;(a*)*&lt;/code&gt; 与 &lt;code&gt;bc&lt;/code&gt; 匹配时，整个RE和带括号的子表达式都匹配一个空字符串。</target>
        </trans-unit>
        <trans-unit id="158e24683a0dfaf92eb2d2d99535563f16d12035" translate="yes" xml:space="preserve">
          <source>When defining a path, you can also use one or more &lt;em&gt;filter expressions&lt;/em&gt; that work similarly to the &lt;code&gt;WHERE&lt;/code&gt; clause in SQL. A filter expression begins with a question mark and provides a condition in parentheses:</source>
          <target state="translated">定义路径时，还可以使用一个或多个&lt;em&gt;过滤器表达式&lt;/em&gt;，这些&lt;em&gt;表达式&lt;/em&gt;与SQL中的 &lt;code&gt;WHERE&lt;/code&gt; 子句类似。过滤器表达式以问号开头，并在括号中提供条件：</target>
        </trans-unit>
        <trans-unit id="f51f30bba3581f1e69eb69eac04311486d90890a" translate="yes" xml:space="preserve">
          <source>When defining the path, you can also use one or more &lt;em&gt;filter expressions&lt;/em&gt; that work similar to the &lt;code&gt;WHERE&lt;/code&gt; clause in SQL. A filter expression begins with a question mark and provides a condition in parentheses:</source>
          <target state="translated">定义路径时，还可以使用一个或多个&lt;em&gt;过滤器表达式&lt;/em&gt;，它们的工作方式类似于SQL中的 &lt;code&gt;WHERE&lt;/code&gt; 子句。过滤器表达式以问号开头，并在括号中提供条件：</target>
        </trans-unit>
        <trans-unit id="359ea83f4fdb1b7fa655731f901be35273bbf743" translate="yes" xml:space="preserve">
          <source>When dropping a subscription that is associated with a replication slot on the remote host (the normal state), &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; will connect to the remote host and try to drop the replication slot as part of its operation. This is necessary so that the resources allocated for the subscription on the remote host are released. If this fails, either because the remote host is not reachable or because the remote replication slot cannot be dropped or does not exist or never existed, the &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; command will fail. To proceed in this situation, disassociate the subscription from the replication slot by executing &lt;code&gt;ALTER SUBSCRIPTION ... SET (slot_name = NONE)&lt;/code&gt;. After that, &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; will no longer attempt any actions on a remote host. Note that if the remote replication slot still exists, it should then be dropped manually; otherwise it will continue to reserve WAL and might eventually cause the disk to fill up. See also &lt;a href=&quot;logical-replication-subscription#LOGICAL-REPLICATION-SUBSCRIPTION-SLOT&quot;&gt;Section 30.2.1&lt;/a&gt;.</source>
          <target state="translated">删除与远程主机上的复制插槽相关联的预订（正常状态）时， &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; 将连接到远程主机，并尝试删除复制插槽作为其操作的一部分。这是必要的，以便释放为远程主机上的订阅分配的资源。如果失败，或者由于远程主机不可访问，或者由于远程复制插槽无法删除，不存在或从不存在，则 &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; 命令将失败。要在这种情况下继续进行，请通过执行 &lt;code&gt;ALTER SUBSCRIPTION ... SET (slot_name = NONE)&lt;/code&gt; 将订阅与复制插槽解除关联。在那之后， &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; 将不再尝试对远程主机执行任何操作。请注意，如果远程复制插槽仍然存在，则应手动删除它；否则它将继续保留WAL，并可能最终导致磁盘装满。另见&lt;a href=&quot;logical-replication-subscription#LOGICAL-REPLICATION-SUBSCRIPTION-SLOT&quot;&gt;第30.2.1节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="16b8b09fc04797b1f4bd77cb938d65220f3c98d4" translate="yes" xml:space="preserve">
          <source>When dropping a subscription, the remote host is not reachable. In that case, disassociate the slot from the subscription using &lt;code&gt;ALTER SUBSCRIPTION&lt;/code&gt; before attempting to drop the subscription. If the remote database instance no longer exists, no further action is then necessary. If, however, the remote database instance is just unreachable, the replication slot should then be dropped manually; otherwise it would continue to reserve WAL and might eventually cause the disk to fill up. Such cases should be carefully investigated.</source>
          <target state="translated">删除订阅时，无法访问远程主机。在这种情况下，请在尝试删除 &lt;code&gt;ALTER SUBSCRIPTION&lt;/code&gt; 之前，使用ALTER SUBSCRIPTION将插槽与订阅解除关联。如果远程数据库实例不再存在，则无需采取进一步的措施。但是，如果远程数据库实例只是不可访问的，则应手动删除复制插槽；否则，必须手动删除复制插槽。否则它将继续保留WAL，并可能最终导致磁盘装满。此类情况应仔细调查。</target>
        </trans-unit>
        <trans-unit id="aef261ef51923658a5c92b355545488277ab638d" translate="yes" xml:space="preserve">
          <source>When dropping a subscription, the replication slot should be kept. This could be useful when the subscriber database is being moved to a different host and will be activated from there. In that case, disassociate the slot from the subscription using &lt;code&gt;ALTER SUBSCRIPTION&lt;/code&gt; before attempting to drop the subscription.</source>
          <target state="translated">删除订阅时，应保留复制插槽。当订户数据库移至其他主机并从该主机激活时，这可能很有用。在这种情况下，请在尝试删除 &lt;code&gt;ALTER SUBSCRIPTION&lt;/code&gt; 之前，使用ALTER SUBSCRIPTION将插槽与订阅解除关联。</target>
        </trans-unit>
        <trans-unit id="7012bb7adb09426a92f880209bcb563fe9379138" translate="yes" xml:space="preserve">
          <source>When dumping data for a table partition, make the &lt;code&gt;COPY&lt;/code&gt; or &lt;code&gt;INSERT&lt;/code&gt; statements target the root of the partitioning hierarchy that contains it, rather than the partition itself. This causes the appropriate partition to be re-determined for each row when the data is loaded. This may be useful when reloading data on a server where rows do not always fall into the same partitions as they did on the original server. That could happen, for example, if the partitioning column is of type text and the two systems have different definitions of the collation used to sort the partitioning column.</source>
          <target state="translated">转储表分区的数据时，使 &lt;code&gt;COPY&lt;/code&gt; 或 &lt;code&gt;INSERT&lt;/code&gt; 语句的目标是包含该分区的分区层次结构的根，而不是分区本身。这将导致在加载数据时为每行重新确定适当的分区。当在服务器上重新加载数据时，行并不总是与原始服务器上的分区相同，这可能很有用。例如，如果分区列是文本类型，并且两个系统对用于对分区列进行排序的排序规则定义不同，则可能会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="b3c4665e18254fa2583d0b9a6ca4200ef73e4faf" translate="yes" xml:space="preserve">
          <source>When dumping logical replication subscriptions, pg_dump will generate &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; commands that use the &lt;code&gt;connect = false&lt;/code&gt; option, so that restoring the subscription does not make remote connections for creating a replication slot or for initial table copy. That way, the dump can be restored without requiring network access to the remote servers. It is then up to the user to reactivate the subscriptions in a suitable way. If the involved hosts have changed, the connection information might have to be changed. It might also be appropriate to truncate the target tables before initiating a new full table copy.</source>
          <target state="translated">转储逻辑复制订阅时，pg_dump将生成使用 &lt;code&gt;connect = false&lt;/code&gt; 选项的 &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; 命令，因此恢复订阅不会建立用于创建复制插槽或初始表副本的远程连接。这样，可以还原转储而无需访问远程服务器的网络。然后由用户以合适的方式重新激活订阅。如果所涉及的主机已更改，则可能必须更改连接信息。在启动新的完整表副本之前，截断目标表也可能是适当的。</target>
        </trans-unit>
        <trans-unit id="edeac7aa265daa84ac15a79b57465693d865b8ff" translate="yes" xml:space="preserve">
          <source>When either stderr or csvlog are included, the file &lt;code&gt;current_logfiles&lt;/code&gt; is created to record the location of the log file(s) currently in use by the logging collector and the associated logging destination. This provides a convenient way to find the logs currently in use by the instance. Here is an example of this file's content:</source>
          <target state="translated">当包括stderr或csvlog时，将创建文件 &lt;code&gt;current_logfiles&lt;/code&gt; 来记录日志收集器和关联的日志目标当前正在使用的日志文件的位置。这提供了一种方便的方法来查找实例当前正在使用的日志。这是此文件内容的示例：</target>
        </trans-unit>
        <trans-unit id="0bf7e84c79ef7d8674ff36f5bd69afa904df5b94" translate="yes" xml:space="preserve">
          <source>When encrypting with a public key:</source>
          <target state="translated">用公钥加密时。</target>
        </trans-unit>
        <trans-unit id="d8c4c4accb682e67b5f8b1813c77704fe93cbcb0" translate="yes" xml:space="preserve">
          <source>When encrypting with a symmetric key (i.e., a password):</source>
          <target state="translated">用对称密钥(即密码)加密时。</target>
        </trans-unit>
        <trans-unit id="db0cd6f3816a8188a89deee57f710a1baaa98cf3" translate="yes" xml:space="preserve">
          <source>When entering &lt;code&gt;bytea&lt;/code&gt; values in escape format, octets of certain values &lt;em&gt;must&lt;/em&gt; be escaped, while all octet values &lt;em&gt;can&lt;/em&gt; be escaped. In general, to escape an octet, convert it into its three-digit octal value and precede it by a backslash. Backslash itself (octet decimal value 92) can alternatively be represented by double backslashes. &lt;a href=&quot;datatype-binary#DATATYPE-BINARY-SQLESC&quot;&gt;Table 8.7&lt;/a&gt; shows the characters that must be escaped, and gives the alternative escape sequences where applicable.</source>
          <target state="translated">当进入 &lt;code&gt;bytea&lt;/code&gt; 逃生格式的值，某些价值观的八位字节&lt;em&gt;必须&lt;/em&gt;进行转义，而所有字节的值&lt;em&gt;可以&lt;/em&gt;被转义。通常，要转义八位字节，请将其转换为三位数的八进制值，并在其前加反斜杠。反斜杠本身（八位字节的十进制值92）也可以用双反斜杠表示。&lt;a href=&quot;datatype-binary#DATATYPE-BINARY-SQLESC&quot;&gt;表8.7&lt;/a&gt;显示了必须转义的字符，并在适用时给出了其他转义序列。</target>
        </trans-unit>
        <trans-unit id="0b723af7e86ecb6fa9f1f4fcf436b5692ddd09fd" translate="yes" xml:space="preserve">
          <source>When establishing a unique constraint for a multi-level partition hierarchy, all the columns in the partition key of the target partitioned table, as well as those of all its descendant partitioned tables, must be included in the constraint definition.</source>
          <target state="translated">在为多级分区层次结构建立唯一约束时,目标分区表的分区键中的所有列以及其所有下级分区表的列都必须包含在约束定义中。</target>
        </trans-unit>
        <trans-unit id="5828ba22818bd784c0d1de682badc9fdcf5283f1" translate="yes" xml:space="preserve">
          <source>When estimating the selectivity, the planner applies all the conditions on items in the MCV list, and then sums the frequencies of the matching ones. See &lt;code&gt;mcv_clauselist_selectivity&lt;/code&gt; in &lt;code&gt;src/backend/statistics/mcv.c&lt;/code&gt; for details.</source>
          <target state="translated">在估计选择性时，计划者将所有条件应用于MCV列表中的项目，然后将匹配项的频率求和。有关详细 &lt;code&gt;mcv_clauselist_selectivity&lt;/code&gt; ，请参见 &lt;code&gt;src/backend/statistics/mcv.c&lt;/code&gt; 中的mcv_clauselist_selectivity。</target>
        </trans-unit>
        <trans-unit id="716da7567a674fa423040a77262890c91b3b1491" translate="yes" xml:space="preserve">
          <source>When estimating with functional dependencies, the planner assumes that conditions on the involved columns are compatible and hence redundant. If they are incompatible, the correct estimate would be zero rows, but that possibility is not considered. For example, given a query like</source>
          <target state="translated">当对功能依赖性进行估计时,规划师假设相关列的条件是兼容的,因此是多余的。如果它们不兼容,正确的估计将是零行,但这种可能性没有考虑。例如,给定一个查询,如</target>
        </trans-unit>
        <trans-unit id="064d226f0b61cda9a60ca08881b4d97cee01ca7a" translate="yes" xml:space="preserve">
          <source>When executed on a primary, the function also creates a backup history file in the write-ahead log archive area. The history file includes the label given to &lt;code&gt;pg_start_backup&lt;/code&gt;, the starting and ending write-ahead log locations for the backup, and the starting and ending times of the backup. The return value is the backup's ending write-ahead log location (which again can be ignored). After recording the ending location, the current write-ahead log insertion point is automatically advanced to the next write-ahead log file, so that the ending write-ahead log file can be archived immediately to complete the backup.</source>
          <target state="translated">在主要数据库上执行时，该功能还会在预写日志归档区域中创建备份历史记录文件。历史记录文件包含给 &lt;code&gt;pg_start_backup&lt;/code&gt; 的标签，备份的开始和结束预写日志位置以及备份的开始和结束时间。返回值是备份的结束预写日志位置（再次可以忽略）。记录结束位置后，当前的预写日志插入点将自动前进到下一个预写日志文件，以便可以立即归档结束的预写日志文件以完成备份。</target>
        </trans-unit>
        <trans-unit id="f889c44a7c84c84f84b08b78362ee8d2fe32a7ef" translate="yes" xml:space="preserve">
          <source>When executed on a primary, this function also creates a backup history file in the write-ahead log archive area. The history file includes the label given to &lt;code&gt;pg_start_backup&lt;/code&gt;, the starting and ending write-ahead log locations for the backup, and the starting and ending times of the backup. After recording the ending location, the current write-ahead log insertion point is automatically advanced to the next write-ahead log file, so that the ending write-ahead log file can be archived immediately to complete the backup.</source>
          <target state="translated">在主要数据库上执行时，此功能还会在预写日志归档区域中创建备份历史记录文件。历史记录文件包括给 &lt;code&gt;pg_start_backup&lt;/code&gt; 的标签，备份的开始和结束预写日志位置以及备份的开始和结束时间。记录结束位置后，当前的预写日志插入点将自动前进到下一个预写日志文件，以便可以立即归档结束的预写日志文件以完成备份。</target>
        </trans-unit>
        <trans-unit id="b575c812fb039c331ed73bad6b9599e79ed09b9b" translate="yes" xml:space="preserve">
          <source>When executed, the example D script gives output such as:</source>
          <target state="translated">当执行时,D脚本示例给出了这样的输出。</target>
        </trans-unit>
        <trans-unit id="9b9cbbd3bd8e290879a575143872c711e1071acb" translate="yes" xml:space="preserve">
          <source>When executing a parallel plan, you can use &lt;code&gt;EXPLAIN (ANALYZE, VERBOSE)&lt;/code&gt; to display per-worker statistics for each plan node. This may be useful in determining whether the work is being evenly distributed between all plan nodes and more generally in understanding the performance characteristics of the plan.</source>
          <target state="translated">执行并行计划时，可以使用 &lt;code&gt;EXPLAIN (ANALYZE, VERBOSE)&lt;/code&gt; 显示每个计划节点的按工作人员统计。这对于确定工作是否在所有计划节点之间平均分配以及更普遍地理解计划的性能特征很有用。</target>
        </trans-unit>
        <trans-unit id="f5c9db9afb12cc927dcae6f85bc0fefc8f88ecba" translate="yes" xml:space="preserve">
          <source>When executing pg_rewind using an online cluster as source which has been recently promoted, it is necessary to execute a &lt;code&gt;CHECKPOINT&lt;/code&gt; after promotion so as its control file reflects up-to-date timeline information, which is used by pg_rewind to check if the target cluster can be rewound using the designated source cluster.</source>
          <target state="translated">当使用最近升级过的在线集群作为源执行pg_rewind时，有必要在升级后执行 &lt;code&gt;CHECKPOINT&lt;/code&gt; ，以便其控制文件反映最新的时间轴信息，pg_rewind使用该信息来检查目标集群是否可以使用指定的源群集倒带。</target>
        </trans-unit>
        <trans-unit id="bc2e3d886cd659c186dac8f9dc7a3737bab777bf" translate="yes" xml:space="preserve">
          <source>When executing pg_rewind using an online cluster as source which has been recently promoted, it is necessary to execute a &lt;code&gt;CHECKPOINT&lt;/code&gt; after promotion such that its control file reflects up-to-date timeline information, which is used by pg_rewind to check if the target cluster can be rewound using the designated source cluster.</source>
          <target state="translated">使用最近升级的在线集群作为源执行pg_rewind时，有必要在升级后执行 &lt;code&gt;CHECKPOINT&lt;/code&gt; ，以便其控制文件反映最新的时间轴信息，pg_rewind使用该信息来检查目标集群是否可以使用指定的源群集倒带。</target>
        </trans-unit>
        <trans-unit id="45578e8de56cf79c1bab7717b9b7f3794e4ce080" translate="yes" xml:space="preserve">
          <source>When executing pg_rewind using an online cluster as source, a role having sufficient permissions to execute the functions used by pg_rewind on the source cluster can be used instead of a superuser. Here is how to create such a role, named &lt;code&gt;rewind_user&lt;/code&gt; here:</source>
          <target state="translated">当使用在线集群作为源执行pg_rewind时，可以使用具有足够权限在源集群上执行pg_rewind使用的功能的角色来代替超级用户。以下是如何创建这样的角色的方法，该角色在此处名为 &lt;code&gt;rewind_user&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9d8da664aa55aa1d9ba572665740c9977324d898" translate="yes" xml:space="preserve">
          <source>When false, the command will not try to refresh table information. &lt;code&gt;REFRESH PUBLICATION&lt;/code&gt; should then be executed separately. The default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果为false，则该命令将不会尝试刷新表信息。然后应分别执行 &lt;code&gt;REFRESH PUBLICATION&lt;/code&gt; 。默认值为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d12b7ebd6720c102addd509acf7a1b3a9bca1905" translate="yes" xml:space="preserve">
          <source>When host names are specified in &lt;code&gt;pg_hba.conf&lt;/code&gt;, you should make sure that name resolution is reasonably fast. It can be of advantage to set up a local name resolution cache such as &lt;code&gt;nscd&lt;/code&gt;. Also, you may wish to enable the configuration parameter &lt;code&gt;log_hostname&lt;/code&gt; to see the client's host name instead of the IP address in the log.</source>
          <target state="translated">当在 &lt;code&gt;pg_hba.conf&lt;/code&gt; 中指定了主机名时，您应该确保名称解析相当快。设置本地名称解析缓存（例如 &lt;code&gt;nscd&lt;/code&gt; )可能是有利的。另外，您可能希望启用配置参数 &lt;code&gt;log_hostname&lt;/code&gt; 来查看客户端的主机名，而不是日志中的IP地址。</target>
        </trans-unit>
        <trans-unit id="72b7c985f760c5c9e2832f32ef829164b2539557" translate="yes" xml:space="preserve">
          <source>When ident is specified for a local (non-TCP/IP) connection, peer authentication (see &lt;a href=&quot;auth-peer&quot;&gt;Section 20.9&lt;/a&gt;) will be used instead.</source>
          <target state="translated">当为本地（非TCP / IP）连接指定了ident时，将使用对等身份验证（请参见&lt;a href=&quot;auth-peer&quot;&gt;第20.9节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="81c1aa17a38d25550246efe2b31fe8f5cb3b0dba" translate="yes" xml:space="preserve">
          <source>When indexes are not used, it can be useful for testing to force their use. There are run-time parameters that can turn off various plan types (see &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-ENABLE&quot;&gt;Section 19.7.1&lt;/a&gt;). For instance, turning off sequential scans (&lt;code&gt;enable_seqscan&lt;/code&gt;) and nested-loop joins (&lt;code&gt;enable_nestloop&lt;/code&gt;), which are the most basic plans, will force the system to use a different plan. If the system still chooses a sequential scan or nested-loop join then there is probably a more fundamental reason why the index is not being used; for example, the query condition does not match the index. (What kind of query can use what kind of index is explained in the previous sections.)</source>
          <target state="translated">当不使用索引时，对强制使用索引很有用。有一些运行时参数可以关闭各种计划类型（请参见&lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-ENABLE&quot;&gt;第19.7.1节&lt;/a&gt;）。例如，关闭最基本的计划即顺序扫描（ &lt;code&gt;enable_seqscan&lt;/code&gt; ）和嵌套循环联接（ &lt;code&gt;enable_nestloop&lt;/code&gt; ），将迫使系统使用其他计划。如果系统仍然选择顺序扫描或嵌套循环连接，则可能是没有使用索引的更根本的原因。例如，查询条件与索引不匹配。 （前面几节已经说明了哪种查询可以使用哪种索引。）</target>
        </trans-unit>
        <trans-unit id="9e50d0004d8680329345366b2774f5ebb4ad654f" translate="yes" xml:space="preserve">
          <source>When inserting a lot of data at the same time, consider using the &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; command. It is not as flexible as the &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt; command, but is more efficient. Refer to &lt;a href=&quot;populate&quot;&gt;Section 14.4&lt;/a&gt; for more information on improving bulk loading performance.</source>
          <target state="translated">同时插入大量数据时，请考虑使用&lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt;命令。它不像&lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt;命令那样灵活，但是效率更高。有关提高批量装载性能的更多信息，请参见&lt;a href=&quot;populate&quot;&gt;第14.4节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dfb95bd9b76a1aa6b1bb1f21c135d8d5ba87cb03" translate="yes" xml:space="preserve">
          <source>When issuing queries in a database where some users mistrust other users, observe security precautions from &lt;a href=&quot;typeconv-func&quot;&gt;Section 10.3&lt;/a&gt; when writing function calls.</source>
          <target state="translated">在某些用户不信任其他用户的数据库中发出查询时，编写函数调用时请遵守&lt;a href=&quot;typeconv-func&quot;&gt;第10.3节中的&lt;/a&gt;安全预防措施。</target>
        </trans-unit>
        <trans-unit id="4ed9176dec0c08e99a6d40ec733c0b7bac5bbcf2" translate="yes" xml:space="preserve">
          <source>When it is essential to force evaluation order, a &lt;code&gt;CASE&lt;/code&gt; construct (see &lt;a href=&quot;functions-conditional&quot;&gt;Section 9.17&lt;/a&gt;) can be used. For example, this is an untrustworthy way of trying to avoid division by zero in a &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="translated">如果必须强制执行评估命令，则可以使用 &lt;code&gt;CASE&lt;/code&gt; 构造（请参见&lt;a href=&quot;functions-conditional&quot;&gt;第9.17节&lt;/a&gt;）。例如，这是一种试图避免在 &lt;code&gt;WHERE&lt;/code&gt; 子句中被零除的不可靠方法：</target>
        </trans-unit>
        <trans-unit id="f8882a94a7fafb56987fef2a0a2e2d4eb96df827" translate="yes" xml:space="preserve">
          <source>When it is essential to force evaluation order, a &lt;code&gt;CASE&lt;/code&gt; construct (see &lt;a href=&quot;functions-conditional&quot;&gt;Section 9.18&lt;/a&gt;) can be used. For example, this is an untrustworthy way of trying to avoid division by zero in a &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="translated">如果必须强制执行评估命令，则可以使用 &lt;code&gt;CASE&lt;/code&gt; 构造（请参见&lt;a href=&quot;functions-conditional&quot;&gt;第9.18节&lt;/a&gt;）。例如，这是一种试图避免在 &lt;code&gt;WHERE&lt;/code&gt; 子句中被零除的不可靠方法：</target>
        </trans-unit>
        <trans-unit id="d43ae9852bbd4e7fca0407119c0359f8ae17da03" translate="yes" xml:space="preserve">
          <source>When loading large amounts of data into an installation that uses WAL archiving or streaming replication, it might be faster to take a new base backup after the load has completed than to process a large amount of incremental WAL data. To prevent incremental WAL logging while loading, disable archiving and streaming replication, by setting &lt;a href=&quot;runtime-config-wal#GUC-WAL-LEVEL&quot;&gt;wal_level&lt;/a&gt; to &lt;code&gt;minimal&lt;/code&gt;, &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-MODE&quot;&gt;archive_mode&lt;/a&gt; to &lt;code&gt;off&lt;/code&gt;, and &lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt; to zero. But note that changing these settings requires a server restart.</source>
          <target state="translated">将大量数据加载到使用WAL归档或流复制的安装中时，加载完成后进行新的基本备份可能比处理大量增量WAL数据更快。为了防止增量WAL记录在装载时禁用归档和流复制，通过设置&lt;a href=&quot;runtime-config-wal#GUC-WAL-LEVEL&quot;&gt;wal_level&lt;/a&gt;到 &lt;code&gt;minimal&lt;/code&gt; ，&lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-MODE&quot;&gt;archive_mode&lt;/a&gt;到 &lt;code&gt;off&lt;/code&gt; ，并&lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt;为零。但是请注意，更改这些设置需要重新启动服务器。</target>
        </trans-unit>
        <trans-unit id="a320947bd6f8b1714ed336d766e812f876be824d" translate="yes" xml:space="preserve">
          <source>When logging to event log is enabled, this parameter determines the program name used to identify PostgreSQL messages in the log. The default is &lt;code&gt;PostgreSQL&lt;/code&gt;. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">启用记录到事件日志后，此参数确定用于在日志中标识PostgreSQL消息的程序名称。默认值为 &lt;code&gt;PostgreSQL&lt;/code&gt; 。该参数只能在 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件或服务器命令行中设置。</target>
        </trans-unit>
        <trans-unit id="688b202e83ca61ee5187e2a33b6d2092af8c2739" translate="yes" xml:space="preserve">
          <source>When logging to syslog and this is on (the default), then each message will be prefixed by an increasing sequence number (such as &lt;code&gt;[2]&lt;/code&gt;). This circumvents the &amp;ldquo;--- last message repeated N times ---&amp;rdquo; suppression that many syslog implementations perform by default. In more modern syslog implementations, repeated message suppression can be configured (for example, &lt;code&gt;$RepeatedMsgReduction&lt;/code&gt; in rsyslog), so this might not be necessary. Also, you could turn this off if you actually want to suppress repeated messages.</source>
          <target state="translated">登录到syslog且此日志处于打开状态（默认设置）时，每条消息都将以递增的序列号作为前缀（例如 &lt;code&gt;[2]&lt;/code&gt; ）。这可以避免许多系统日志实现默认执行的&amp;ldquo; ---最后消息重复N次---&amp;rdquo;抑制。在更现代的syslog实现中，可以配置重复消息抑制（例如，rsyslog中的 &lt;code&gt;$RepeatedMsgReduction&lt;/code&gt; RepeatedMsgReduction），因此可能没有必要。另外，如果您确实想抑制重复的消息，则可以将其关闭。</target>
        </trans-unit>
        <trans-unit id="ba8a396481d44a42fb2aa24b4ad06150638300e9" translate="yes" xml:space="preserve">
          <source>When logging to syslog is enabled, this parameter determines how messages are delivered to syslog. When on (the default), messages are split by lines, and long lines are split so that they will fit into 1024 bytes, which is a typical size limit for traditional syslog implementations. When off, PostgreSQL server log messages are delivered to the syslog service as is, and it is up to the syslog service to cope with the potentially bulky messages.</source>
          <target state="translated">当启用日志记录到syslog时,这个参数决定了消息如何传递到syslog。当开启时(默认值),消息是按行分割的,长行被分割成1024字节,这是传统syslog实现的典型大小限制。当关闭时,PostgreSQL服务器的日志信息会被原封不动地传送到syslog服务上,由syslog服务来处理这些潜在的庞大信息。</target>
        </trans-unit>
        <trans-unit id="80ff0840aef3199452ea4eb2990b10a8d1c55939" translate="yes" xml:space="preserve">
          <source>When logging to syslog is enabled, this parameter determines the program name used to identify PostgreSQL messages in syslog logs. The default is &lt;code&gt;postgres&lt;/code&gt;. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">启用登录到syslog后，此参数确定用于在syslog日志中标识PostgreSQL消息的程序名称。默认值为 &lt;code&gt;postgres&lt;/code&gt; 。该参数只能在 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件或服务器命令行中设置。</target>
        </trans-unit>
        <trans-unit id="985b03993881f4457d8f0c3b34d9b7b01342f4d8" translate="yes" xml:space="preserve">
          <source>When logging to syslog is enabled, this parameter determines the syslog &amp;ldquo;facility&amp;rdquo; to be used. You can choose from &lt;code&gt;LOCAL0&lt;/code&gt;, &lt;code&gt;LOCAL1&lt;/code&gt;, &lt;code&gt;LOCAL2&lt;/code&gt;, &lt;code&gt;LOCAL3&lt;/code&gt;, &lt;code&gt;LOCAL4&lt;/code&gt;, &lt;code&gt;LOCAL5&lt;/code&gt;, &lt;code&gt;LOCAL6&lt;/code&gt;, &lt;code&gt;LOCAL7&lt;/code&gt;; the default is &lt;code&gt;LOCAL0&lt;/code&gt;. See also the documentation of your system's syslog daemon. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">启用登录到syslog时，此参数确定要使用的syslog&amp;ldquo;设备&amp;rdquo;。您可以从 &lt;code&gt;LOCAL0&lt;/code&gt; ， &lt;code&gt;LOCAL1&lt;/code&gt; ， &lt;code&gt;LOCAL2&lt;/code&gt; ， &lt;code&gt;LOCAL3&lt;/code&gt; ， &lt;code&gt;LOCAL4&lt;/code&gt; ， &lt;code&gt;LOCAL5&lt;/code&gt; ， &lt;code&gt;LOCAL6&lt;/code&gt; ， &lt;code&gt;LOCAL7&lt;/code&gt; 中选择；默认值为 &lt;code&gt;LOCAL0&lt;/code&gt; 。另请参阅系统syslog守护程序的文档。该参数只能在 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件或服务器命令行中设置。</target>
        </trans-unit>
        <trans-unit id="6d9a3edba4451cb3d18020f74c5a06ee8a7a52bd" translate="yes" xml:space="preserve">
          <source>When managing the server directly, you can control the type of shutdown by sending different signals to the &lt;code&gt;postgres&lt;/code&gt; process:</source>
          <target state="translated">直接管理服务器时，可以通过向 &lt;code&gt;postgres&lt;/code&gt; 进程发送不同的信号来控制关闭的类型：</target>
        </trans-unit>
        <trans-unit id="b30985843aab3e94f2bd3bce331e8a5523cabcbb" translate="yes" xml:space="preserve">
          <source>When more than one expression is specified, the later values are used to sort rows that are equal according to the earlier values. Each expression can be followed by an optional &lt;code&gt;ASC&lt;/code&gt; or &lt;code&gt;DESC&lt;/code&gt; keyword to set the sort direction to ascending or descending. &lt;code&gt;ASC&lt;/code&gt; order is the default. Ascending order puts smaller values first, where &amp;ldquo;smaller&amp;rdquo; is defined in terms of the &lt;code&gt;&amp;lt;&lt;/code&gt; operator. Similarly, descending order is determined with the &lt;code&gt;&amp;gt;&lt;/code&gt; operator. &lt;a href=&quot;#ftn.id-1.5.6.9.5.10&quot;&gt;&lt;sup id=&quot;id-1.5.6.9.5.10&quot;&gt;[5]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">如果指定了多个表达式，则根据较早的值，使用较晚的值对相等的行进行排序。每个表达式后可以跟一个可选的 &lt;code&gt;ASC&lt;/code&gt; 或 &lt;code&gt;DESC&lt;/code&gt; 关键字，以将排序方向设置为升序或降序。默认为 &lt;code&gt;ASC&lt;/code&gt; 顺序。升序将较小的值放在第一位，其中&amp;ldquo;较小&amp;rdquo;是根据 &lt;code&gt;&amp;lt;&lt;/code&gt; 运算符定义的。同样，降序由 &lt;code&gt;&amp;gt;&lt;/code&gt; 运算符确定。&lt;a href=&quot;#ftn.id-1.5.6.9.5.10&quot;&gt;&lt;sup id=&quot;id-1.5.6.9.5.10&quot;&gt;[5]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="11912d8e839cffb71f2e5fc45344859e046a9cbc" translate="yes" xml:space="preserve">
          <source>When more than one row is specified, all the rows must have the same number of elements. The data types of the resulting table's columns are determined by combining the explicit or inferred types of the expressions appearing in that column, using the same rules as for &lt;code&gt;UNION&lt;/code&gt; (see &lt;a href=&quot;typeconv-union-case&quot;&gt;Section 10.5&lt;/a&gt;).</source>
          <target state="translated">指定多个行时，所有行必须具有相同数量的元素。所得到的表的列的数据类型由作为用于组合显式或推断类型出现在该列中的表达式，使用相同的规则来确定 &lt;code&gt;UNION&lt;/code&gt; （见&lt;a href=&quot;typeconv-union-case&quot;&gt;第10.5节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="dcff81a7a0194a63301c74dc5ce189cffc265222" translate="yes" xml:space="preserve">
          <source>When multiple policies apply to a given query, they are combined using either &lt;code&gt;OR&lt;/code&gt; (for permissive policies, which are the default) or using &lt;code&gt;AND&lt;/code&gt; (for restrictive policies). This is similar to the rule that a given role has the privileges of all roles that they are a member of. Permissive vs. restrictive policies are discussed further below.</source>
          <target state="translated">当多个策略应用于给定查询时，它们将使用 &lt;code&gt;OR&lt;/code&gt; （对于允许的策略，这是默认设置）或使用 &lt;code&gt;AND&lt;/code&gt; （对于限制性的策略）进行组合。这类似于给定角色具有其所隶属的所有角色的特权的规则。宽松政策与限制性政策在下面进一步讨论。</target>
        </trans-unit>
        <trans-unit id="269b9ef4adee76f3240604e5767201bc6ee01e71" translate="yes" xml:space="preserve">
          <source>When multiple policies of different command types apply to the same command (for example, &lt;code&gt;SELECT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; policies applied to an &lt;code&gt;UPDATE&lt;/code&gt; command), then the user must have both types of permissions (for example, permission to select rows from the relation as well as permission to update them). Thus the expressions for one type of policy are combined with the expressions for the other type of policy using the &lt;code&gt;AND&lt;/code&gt; operator.</source>
          <target state="translated">当不同命令类型的多个策略应用于同一命令时（例如， &lt;code&gt;SELECT&lt;/code&gt; 和 &lt;code&gt;UPDATE&lt;/code&gt; 策略应用于 &lt;code&gt;UPDATE&lt;/code&gt; 命令），则用户必须同时具有两种权限（例如，从关系中选择行的权限以及进行更新的权限）。因此，使用 &lt;code&gt;AND&lt;/code&gt; 运算符将一种策略类型的表达式与另一种策略类型的表达式组合在一起。</target>
        </trans-unit>
        <trans-unit id="556057cb09a8742cb36bd19c1657e03ac61a815b" translate="yes" xml:space="preserve">
          <source>When multiple policies of the same command type apply to the same command, then there must be at least one &lt;code&gt;PERMISSIVE&lt;/code&gt; policy granting access to the relation, and all of the &lt;code&gt;RESTRICTIVE&lt;/code&gt; policies must pass. Thus all the &lt;code&gt;PERMISSIVE&lt;/code&gt; policy expressions are combined using &lt;code&gt;OR&lt;/code&gt;, all the &lt;code&gt;RESTRICTIVE&lt;/code&gt; policy expressions are combined using &lt;code&gt;AND&lt;/code&gt;, and the results are combined using &lt;code&gt;AND&lt;/code&gt;. If there are no &lt;code&gt;PERMISSIVE&lt;/code&gt; policies, then access is denied.</source>
          <target state="translated">当同一命令类型的多个策略应用于同一命令时，则必须至少有一个 &lt;code&gt;PERMISSIVE&lt;/code&gt; 策略授予对该关系的访问权限，并且所有 &lt;code&gt;RESTRICTIVE&lt;/code&gt; 策略都必须通过。因此，所有的 &lt;code&gt;PERMISSIVE&lt;/code&gt; 策略表达式使用组合 &lt;code&gt;OR&lt;/code&gt; ，所有 &lt;code&gt;RESTRICTIVE&lt;/code&gt; 策略表达式使用结合 &lt;code&gt;AND&lt;/code&gt; ，结果使用相结合 &lt;code&gt;AND&lt;/code&gt; 。如果没有 &lt;code&gt;PERMISSIVE&lt;/code&gt; 策略，则拒绝访问。</target>
        </trans-unit>
        <trans-unit id="5d6d15be5ddf45a51b853b506d5d1a1d2068106c" translate="yes" xml:space="preserve">
          <source>When multiple window functions are used, all the window functions having syntactically equivalent &lt;code&gt;PARTITION BY&lt;/code&gt; and &lt;code&gt;ORDER BY&lt;/code&gt; clauses in their window definitions are guaranteed to be evaluated in a single pass over the data. Therefore they will see the same sort ordering, even if the &lt;code&gt;ORDER BY&lt;/code&gt; does not uniquely determine an ordering. However, no guarantees are made about the evaluation of functions having different &lt;code&gt;PARTITION BY&lt;/code&gt; or &lt;code&gt;ORDER BY&lt;/code&gt; specifications. (In such cases a sort step is typically required between the passes of window function evaluations, and the sort is not guaranteed to preserve ordering of rows that its &lt;code&gt;ORDER BY&lt;/code&gt; sees as equivalent.)</source>
          <target state="translated">当使用多个窗口函数时，保证所有在窗口定义中具有句法上等效的 &lt;code&gt;PARTITION BY&lt;/code&gt; 和 &lt;code&gt;ORDER BY&lt;/code&gt; 子句的窗口函数都可以通过一次数据传递来进行评估。因此，即使 &lt;code&gt;ORDER BY&lt;/code&gt; 不能唯一地确定顺序，他们也将看到相同的排序顺序。但是，不能保证对具有不同 &lt;code&gt;PARTITION BY&lt;/code&gt; 或 &lt;code&gt;ORDER BY&lt;/code&gt; 规范的功能进行评估。 （在这种情况下，通常在两次传递窗口函数评估之间需要一个排序步骤，并且不能保证该排序保留其 &lt;code&gt;ORDER BY&lt;/code&gt; 视为等效的行的顺序。）</target>
        </trans-unit>
        <trans-unit id="34f31d5224ac605a926f4e92907e12ec5add9474" translate="yes" xml:space="preserve">
          <source>When multiple workers are running, the autovacuum cost delay parameters (see &lt;a href=&quot;runtime-config-resource#RUNTIME-CONFIG-RESOURCE-VACUUM-COST&quot;&gt;Section 19.4.4&lt;/a&gt;) are &amp;ldquo;balanced&amp;rdquo; among all the running workers, so that the total I/O impact on the system is the same regardless of the number of workers actually running. However, any workers processing tables whose per-table &lt;code&gt;autovacuum_vacuum_cost_delay&lt;/code&gt; or &lt;code&gt;autovacuum_vacuum_cost_limit&lt;/code&gt; storage parameters have been set are not considered in the balancing algorithm.</source>
          <target state="translated">当多个工人正在运行时，自动真空成本延迟参数（请参阅&lt;a href=&quot;runtime-config-resource#RUNTIME-CONFIG-RESOURCE-VACUUM-COST&quot;&gt;第19.4.4节&lt;/a&gt;）在所有正在运行的工人之间&amp;ldquo;平衡&amp;rdquo;，因此，无论实际运行的工人数量如何，对系统的总I / O影响都是相同的。但是，在平衡算法中不考虑处理已设置每表 &lt;code&gt;autovacuum_vacuum_cost_delay&lt;/code&gt; 或 &lt;code&gt;autovacuum_vacuum_cost_limit&lt;/code&gt; 存储参数的工作表。</target>
        </trans-unit>
        <trans-unit id="84f11ff5e7225ec364ea450b05da5b31bd525923" translate="yes" xml:space="preserve">
          <source>When no final &lt;code&gt;ELSE&lt;/code&gt; clause is provided to a &lt;code&gt;CASE&lt;/code&gt;, the default value is &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">如果没有为 &lt;code&gt;CASE&lt;/code&gt; 提供最终的 &lt;code&gt;ELSE&lt;/code&gt; 子句，则默认值为 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb2d002b299026c6a8e3abc29ae594e572a6b112" translate="yes" xml:space="preserve">
          <source>When non-serializable writes are possible, to ensure the current validity of a row and protect it against concurrent updates one must use &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt;, &lt;code&gt;SELECT FOR SHARE&lt;/code&gt;, or an appropriate &lt;code&gt;LOCK TABLE&lt;/code&gt; statement. (&lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; and &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; lock just the returned rows against concurrent updates, while &lt;code&gt;LOCK TABLE&lt;/code&gt; locks the whole table.) This should be taken into account when porting applications to PostgreSQL from other environments.</source>
          <target state="translated">当可能进行不可序列化的写操作时，为了确保行的当前有效性并防止发生并发更新，必须使用 &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; ， &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; 或适当的 &lt;code&gt;LOCK TABLE&lt;/code&gt; 语句。 （ &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 和 &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; 仅将返回的行锁定为并发更新，而 &lt;code&gt;LOCK TABLE&lt;/code&gt; 锁定整个表。）从其他环境将应用程序移植到PostgreSQL时，应考虑到这一点。</target>
        </trans-unit>
        <trans-unit id="8d5d4ed5a8f5b52f15315d7a651b9128c1d498f8" translate="yes" xml:space="preserve">
          <source>When not all owned objects are to be transferred to the same successor owner, it's best to handle the exceptions manually and then perform the above steps to mop up.</source>
          <target state="translated">当不是所有拥有的对象都要转移给同一个继承者所有者时,最好是手动处理异常,然后再执行上述步骤进行清理。</target>
        </trans-unit>
        <trans-unit id="ed8afcb65f27d90b88c36a924e96931352e55b61" translate="yes" xml:space="preserve">
          <source>When not using the &lt;code&gt;ROWS FROM()&lt;/code&gt; syntax, the &lt;code&gt;column_definition&lt;/code&gt; list replaces the column alias list that could otherwise be attached to the &lt;code&gt;FROM&lt;/code&gt; item; the names in the column definitions serve as column aliases. When using the &lt;code&gt;ROWS FROM()&lt;/code&gt; syntax, a &lt;code&gt;column_definition&lt;/code&gt; list can be attached to each member function separately; or if there is only one member function and no &lt;code&gt;WITH ORDINALITY&lt;/code&gt; clause, a &lt;code&gt;column_definition&lt;/code&gt; list can be written in place of a column alias list following &lt;code&gt;ROWS FROM()&lt;/code&gt;.</source>
          <target state="translated">当不使用 &lt;code&gt;ROWS FROM()&lt;/code&gt; 语法时， &lt;code&gt;column_definition&lt;/code&gt; 列表将替换本可以附加到 &lt;code&gt;FROM&lt;/code&gt; 项目的列别名列表。列定义中的名称用作列别名。当使用 &lt;code&gt;ROWS FROM()&lt;/code&gt; 语法时，可以将 &lt;code&gt;column_definition&lt;/code&gt; 列表分别附加到每个成员函数。或者，如果只有一个成员函数而没有 &lt;code&gt;WITH ORDINALITY&lt;/code&gt; 子句，则可以在 &lt;code&gt;ROWS FROM()&lt;/code&gt; 之后编写 &lt;code&gt;column_definition&lt;/code&gt; 列表，以代替列别名列表。</target>
        </trans-unit>
        <trans-unit id="89c266fb8eeefdc22c382f51ddfa36d2cdf3fd08" translate="yes" xml:space="preserve">
          <source>When objects are created without specifying a particular target schema, they will be placed in the first valid schema named in &lt;code&gt;search_path&lt;/code&gt;. An error is reported if the search path is empty.</source>
          <target state="translated">如果在未指定特定目标架构的情况下创建对象，则会将它们放置在 &lt;code&gt;search_path&lt;/code&gt; 中命名的第一个有效架构中。如果搜索路径为空，则会报告错误。</target>
        </trans-unit>
        <trans-unit id="99ff2ff0bf302907b157207503609b9e0138a5a9" translate="yes" xml:space="preserve">
          <source>When on, a warning is issued if a backslash (&lt;code&gt;\&lt;/code&gt;) appears in an ordinary string literal (&lt;code&gt;'...'&lt;/code&gt; syntax) and &lt;code&gt;standard_conforming_strings&lt;/code&gt; is off. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">启用时，如果在普通字符串文字（ &lt;code&gt;'...'&lt;/code&gt; 语法）中出现反斜杠（ &lt;code&gt;\&lt;/code&gt; ）且 &lt;code&gt;standard_conforming_strings&lt;/code&gt; 关闭，则发出警告。默认值为 &lt;code&gt;on&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a39a26ef7d5c306f15cfec242fa1908a71ae3775" translate="yes" xml:space="preserve">
          <source>When on, expressions of the form &lt;code&gt;expr = NULL&lt;/code&gt; (or &lt;code&gt;NULL = expr&lt;/code&gt;) are treated as &lt;code&gt;expr IS NULL&lt;/code&gt;, that is, they return true if &lt;code&gt;expr&lt;/code&gt; evaluates to the null value, and false otherwise. The correct SQL-spec-compliant behavior of &lt;code&gt;expr = NULL&lt;/code&gt; is to always return null (unknown). Therefore this parameter defaults to &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">启用时，将 &lt;code&gt;expr = NULL&lt;/code&gt; （或 &lt;code&gt;NULL = expr&lt;/code&gt; ）形式的表达式视为 &lt;code&gt;expr IS NULL&lt;/code&gt; ，即，如果 &lt;code&gt;expr&lt;/code&gt; 的计算结果为null ，则它们返回true，否则返回false。正确的SQL-spec兼容行为 &lt;code&gt;expr = NULL&lt;/code&gt; 总是返回null（未知）。因此，此参数默认为 &lt;code&gt;off&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd83814e734e8771d44c1de9842876866f19a1c6" translate="yes" xml:space="preserve">
          <source>When on, the parser will emit a warning for any construct that might have changed meanings since PostgreSQL 9.4 as a result of changes in operator precedence. This is useful for auditing applications to see if precedence changes have broken anything; but it is not meant to be kept turned on in production, since it will warn about some perfectly valid, standard-compliant SQL code. The default is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">启用后，解析器将针对自PostgreSQL 9.4起由于运算符优先级更改而可能含义发生变化的任何构造发出警告。这对于审核应用程序以查看优先级更改是否破坏了任何内容很有用；但由于要警告某些完全有效且符合标准的SQL代码，因此不应在生产中保持打开状态。默认为 &lt;code&gt;off&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f61f3e69afe30c64a291d60390d7c29326445c47" translate="yes" xml:space="preserve">
          <source>When operators and support functions are added to a family with &lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt;, they are not part of any specific operator class within the family, but are just &amp;ldquo;loose&amp;rdquo; within the family. This indicates that these operators and functions are compatible with the family's semantics, but are not required for correct functioning of any specific index. (Operators and functions that are so required should be declared as part of an operator class, instead; see &lt;a href=&quot;sql-createopclass&quot;&gt;CREATE OPERATOR CLASS&lt;/a&gt;.) PostgreSQL will allow loose members of a family to be dropped from the family at any time, but members of an operator class cannot be dropped without dropping the whole class and any indexes that depend on it. Typically, single-data-type operators and functions are part of operator classes because they are needed to support an index on that specific data type, while cross-data-type operators and functions are made loose members of the family.</source>
          <target state="translated">当使用 &lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt; 将操作员和支持功能添加到一个系列中时，它们不属于该系列中任何特定的操作员类别，而只是该系列中的&amp;ldquo;松散&amp;rdquo;。这表明这些运算符和函数与该族的语义兼容，但对于任何特定索引的正确运行而言并不是必需的。 （需要的操作符和函数应声明为操作符类的一部分；请参见&lt;a href=&quot;sql-createopclass&quot;&gt;CREATE OPERATOR CLASS&lt;/a&gt;。）PostgreSQL允许在任何时候从家族中删除家族的松散成员，但是如果不删除整个类和依赖它的任何索引，就不能删除运算符类的成员。通常，单数据类型的运算符和函数是运算符类的一部分，因为需要它们来支持该特定数据类型的索引，而跨数据类型的运算符和函数则成为该族的松散成员。</target>
        </trans-unit>
        <trans-unit id="0f2ad4b5a54137b2f0c70ae82420f67c0b1b6ea3" translate="yes" xml:space="preserve">
          <source>When queries or updates access a large percentage of a single partition, performance can be improved by taking advantage of sequential scan of that partition instead of using an index and random access reads scattered across the whole table.</source>
          <target state="translated">当查询或更新访问单个分区的大比例时,可以利用对该分区的顺序扫描来提高性能,而不是使用索引和分散在整个表上的随机访问读。</target>
        </trans-unit>
        <trans-unit id="2540d43e50d1abeb1a847d9db340690266815c23" translate="yes" xml:space="preserve">
          <source>When relying on Serializable transactions to prevent anomalies, it is important that any data read from a permanent user table not be considered valid until the transaction which read it has successfully committed. This is true even for read-only transactions, except that data read within a &lt;em&gt;deferrable&lt;/em&gt; read-only transaction is known to be valid as soon as it is read, because such a transaction waits until it can acquire a snapshot guaranteed to be free from such problems before starting to read any data. In all other cases applications must not depend on results read during a transaction that later aborted; instead, they should retry the transaction until it succeeds.</source>
          <target state="translated">当依靠Serializable事务来防止异常时，从永久用户表中读取的任何数据都必须被视为有效，直到读取该事务的事务已成功提交，这一点很重要。即使对于只读事务也是如此，除了已知在&lt;em&gt;可延迟&lt;/em&gt;只读事务中读取的数据一被读取就立即有效，因为这样的事务一直等到它可以获取保证没有此类快照的快照为止。开始读取任何数据之前出现问题。在所有其他情况下，应用程序都不能依赖于后来中止的事务期间读取的结果；相反，他们应该重试事务，直到成功为止。</target>
        </trans-unit>
        <trans-unit id="0f545c1f8d440a6a74e5e5cae7b49a8321ce778e" translate="yes" xml:space="preserve">
          <source>When repeated &lt;code&gt;CREATE FUNCTION&lt;/code&gt; calls refer to the same object file, the file is only loaded once per session. To unload and reload the file (perhaps during development), start a new session.</source>
          <target state="translated">当重复的 &lt;code&gt;CREATE FUNCTION&lt;/code&gt; 调用引用相同的目标文件时，该文件在每个会话中仅加载一次。要卸载和重新加载文件（可能在开发过程中），请开始一个新的会话。</target>
        </trans-unit>
        <trans-unit id="63cb3d013e86db6ef5ef57500326cdf863814f3a" translate="yes" xml:space="preserve">
          <source>When repeated &lt;code&gt;CREATE PROCEDURE&lt;/code&gt; calls refer to the same object file, the file is only loaded once per session. To unload and reload the file (perhaps during development), start a new session.</source>
          <target state="translated">当重复的 &lt;code&gt;CREATE PROCEDURE&lt;/code&gt; 调用引用相同的目标文件时，该文件在每个会话中仅加载一次。要卸载和重新加载文件（可能在开发过程中），请开始一个新的会话。</target>
        </trans-unit>
        <trans-unit id="b358e9fc6a1b297fd0b37a45eac263be99236636" translate="yes" xml:space="preserve">
          <source>When replacing an existing definition, the argument types, result type, and number of direct arguments may not be changed. Also, the new definition must be of the same kind (ordinary aggregate, ordered-set aggregate, or hypothetical-set aggregate) as the old one.</source>
          <target state="translated">当替换一个现有的定义时,参数类型、结果类型和直接参数的数量不能改变,同时,新定义必须与旧定义的种类相同(普通集合、有序集合或假设集合)。此外,新定义必须与旧定义的种类相同(普通集合、有序集合、或假设集合)。</target>
        </trans-unit>
        <trans-unit id="bf16a952f545e26cfee0e603603bfd07e12cf881" translate="yes" xml:space="preserve">
          <source>When replacing an existing function with &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt;, there are restrictions on changing parameter names. You cannot change the name already assigned to any input parameter (although you can add names to parameters that had none before). If there is more than one output parameter, you cannot change the names of the output parameters, because that would change the column names of the anonymous composite type that describes the function's result. These restrictions are made to ensure that existing calls of the function do not stop working when it is replaced.</source>
          <target state="translated">用 &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; 替换现有函数时，在更改参数名称方面存在限制。您不能更改已经分配给任何输入参数的名称（尽管您可以将名称添加到之前没有输入的参数中）。如果有多个输出参数，则不能更改输出参数的名称，因为这将更改描述函数结果的匿名复合类型的列名称。进行这些限制是为了确保函数的现有调用在被替换时不会停止工作。</target>
        </trans-unit>
        <trans-unit id="c4f24499d5667a6f6b8b67600774aa56a3d4c33d" translate="yes" xml:space="preserve">
          <source>When replicating between partitioned tables, the actual replication originates, by default, from the leaf partitions on the publisher, so partitions on the publisher must also exist on the subscriber as valid target tables. (They could either be leaf partitions themselves, or they could be further subpartitioned, or they could even be independent tables.) Publications can also specify that changes are to be replicated using the identity and schema of the partitioned root table instead of that of the individual leaf partitions in which the changes actually originate (see &lt;a href=&quot;sql-createpublication&quot;&gt;CREATE PUBLICATION&lt;/a&gt;).</source>
          <target state="translated">在分区表之间进行复制时，默认情况下，实际复制源自发布者上的叶分区，因此发布者上的分区也必须作为有效目标表存在于订阅者上。（它们本身可以是叶分区，也可以进一步细分，甚至可以是独立的表。）出版物还可以指定要使用分区根表的标识和架构（而不是分区根表的标识和架构）来复制更改。实际发生更改的各个叶分区（请参阅&lt;a href=&quot;sql-createpublication&quot;&gt;CREATE PUBLICATION&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="80773f67cc3b08f5dcb6c36638c7da08b5a16582" translate="yes" xml:space="preserve">
          <source>When requesting synchronous replication, each commit of a write transaction will wait until confirmation is received that the commit has been written to the write-ahead log on disk of both the primary and standby server. The only possibility that data can be lost is if both the primary and the standby suffer crashes at the same time. This can provide a much higher level of durability, though only if the sysadmin is cautious about the placement and management of the two servers. Waiting for confirmation increases the user's confidence that the changes will not be lost in the event of server crashes but it also necessarily increases the response time for the requesting transaction. The minimum wait time is the round-trip time between primary to standby.</source>
          <target state="translated">当请求同步复制时,写事务的每次提交都会等到收到确认,确认提交已经写入主服务器和备用服务器磁盘上的写前日志。数据丢失的唯一可能是主服务器和备用服务器同时发生崩溃。这可以提供更高的耐用性,不过前提是系统管理员对两个服务器的位置和管理要谨慎。等待确认增加了用户对服务器崩溃时不会丢失更改的信心,但也必然增加了请求事务的响应时间。最短的等待时间是主服务器到备用服务器之间的往返时间。</target>
        </trans-unit>
        <trans-unit id="7cbfd2d18fb6178afa3088b0725b2bc3fcdf04fe" translate="yes" xml:space="preserve">
          <source>When restoring data to a pre-existing table and the option &lt;code&gt;--disable-triggers&lt;/code&gt; is used, pg_restore emits commands to disable triggers on user tables before inserting the data, then emits commands to re-enable them after the data has been inserted. If the restore is stopped in the middle, the system catalogs might be left in the wrong state.</source>
          <target state="translated">当将数据恢复到预先存在的表并使用选项 &lt;code&gt;--disable-triggers&lt;/code&gt; 时，pg_restore在插入数据之前发出命令以禁用用户表上的触发器，然后在插入数据后发出命令以重新启用它们。如果还原在中间停止，则系统目录可能处于错误状态。</target>
        </trans-unit>
        <trans-unit id="ade7c8c975218ba23dcef154671330d11fa5728d" translate="yes" xml:space="preserve">
          <source>When revoking membership in a role, &lt;code&gt;GRANT OPTION&lt;/code&gt; is instead called &lt;code&gt;ADMIN OPTION&lt;/code&gt;, but the behavior is similar. Note also that this form of the command does not allow the noise word &lt;code&gt;GROUP&lt;/code&gt;.</source>
          <target state="translated">撤销角色成员身份时， &lt;code&gt;GRANT OPTION&lt;/code&gt; 改为 &lt;code&gt;ADMIN OPTION&lt;/code&gt; ，但是行为类似。还要注意，该命令的形式不允许使用噪声字 &lt;code&gt;GROUP&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2378e777cb7029b72a32e416964ca17fb134eb03" translate="yes" xml:space="preserve">
          <source>When revoking membership in a role, &lt;code&gt;GRANT OPTION&lt;/code&gt; is instead called &lt;code&gt;ADMIN OPTION&lt;/code&gt;, but the behavior is similar. This form of the command also allows a &lt;code&gt;GRANTED BY&lt;/code&gt; option, but that option is currently ignored (except for checking the existence of the named role). Note also that this form of the command does not allow the noise word &lt;code&gt;GROUP&lt;/code&gt; in &lt;code&gt;role_specification&lt;/code&gt;.</source>
          <target state="translated">撤销角色成员身份时， &lt;code&gt;GRANT OPTION&lt;/code&gt; 改为 &lt;code&gt;ADMIN OPTION&lt;/code&gt; ，但行为类似。这种形式的命令还允许使用 &lt;code&gt;GRANTED BY&lt;/code&gt; 选项，但是该选项当前被忽略（除了检查命名角色的存在以外）。还要注意，该命令的这种形式不允许在 &lt;code&gt;role_specification&lt;/code&gt; 中使用干扰词 &lt;code&gt;GROUP&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f68adac31376cf57c26d631be30fdfc9650022d2" translate="yes" xml:space="preserve">
          <source>When revoking privileges on a table, the corresponding column privileges (if any) are automatically revoked on each column of the table, as well. On the other hand, if a role has been granted privileges on a table, then revoking the same privileges from individual columns will have no effect.</source>
          <target state="translated">当撤销表上的权限时,表的每一列上相应的列权限(如果有的话)也会自动撤销。另一方面,如果一个角色在表上被授予了权限,那么撤销各个列的相同权限将不会有任何影响。</target>
        </trans-unit>
        <trans-unit id="300dad807edac8d993f28c0997a914c75b99f4bc" translate="yes" xml:space="preserve">
          <source>When rounding values, the &lt;code&gt;numeric&lt;/code&gt; type rounds ties away from zero, while (on most machines) the &lt;code&gt;real&lt;/code&gt; and &lt;code&gt;double precision&lt;/code&gt; types round ties to the nearest even number. For example:</source>
          <target state="translated">在对值进行四舍五入时， &lt;code&gt;numeric&lt;/code&gt; 类型会将零位四舍五入，而（在大多数机器上） &lt;code&gt;real&lt;/code&gt; 和 &lt;code&gt;double precision&lt;/code&gt; 类型将四舍五入到最接近的偶数。例如：</target>
        </trans-unit>
        <trans-unit id="5f76f7c7b77ca49ded558a0639a8d27cc09a3811" translate="yes" xml:space="preserve">
          <source>When row security is enabled on a table (with &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE ... ENABLE ROW LEVEL SECURITY&lt;/a&gt;), all normal access to the table for selecting rows or modifying rows must be allowed by a row security policy. (However, the table's owner is typically not subject to row security policies.) If no policy exists for the table, a default-deny policy is used, meaning that no rows are visible or can be modified. Operations that apply to the whole table, such as &lt;code&gt;TRUNCATE&lt;/code&gt; and &lt;code&gt;REFERENCES&lt;/code&gt;, are not subject to row security.</source>
          <target state="translated">当在表上启用行安全性（使用&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE ... ENABLE ROW LEVEL SECURITY&lt;/a&gt;）时，行安全性策略必须允许对表的所有普通访问以选择行或修改行。（但是，表的所有者通常不受行安全策略的约束。）如果表不存在任何策略，则使用默认拒绝策略，这意味着没有可见的行或可以修改的行。适用于整个表的操作（例如 &lt;code&gt;TRUNCATE&lt;/code&gt; 和 &lt;code&gt;REFERENCES&lt;/code&gt; )不受行安全性的限制。</target>
        </trans-unit>
        <trans-unit id="226f5e12ea7fb1c629a76bb1b3cc1943cd4502fc" translate="yes" xml:space="preserve">
          <source>When running a long test on hardware that can handle a lot of transactions, the log files can become very large. The &lt;code&gt;--sampling-rate&lt;/code&gt; option can be used to log only a random sample of transactions.</source>
          <target state="translated">在可以处理大量事务的硬件上进行长时间测试时，日志文件可能会变得非常大。该 &lt;code&gt;--sampling-rate&lt;/code&gt; 选项可用于只记录交易的随机样本。</target>
        </trans-unit>
        <trans-unit id="4051fc47591e058546d74bee2aa79ca3ea360af8" translate="yes" xml:space="preserve">
          <source>When running a standby server, you must set this parameter to the same or higher value than on the master server. Otherwise, queries will not be allowed in the standby server.</source>
          <target state="translated">运行备用服务器时,必须将此参数设置为与主服务器相同或更高的值。否则,将不允许在备用服务器中进行查询。</target>
        </trans-unit>
        <trans-unit id="0becdbc99cfe7674fb7d475f00ec87ca3a5a28cc" translate="yes" xml:space="preserve">
          <source>When running at the &lt;code&gt;serializable&lt;/code&gt; isolation level, a deferrable read-only SQL transaction may be delayed before it is allowed to proceed. However, once it begins executing it does not incur any of the overhead required to ensure serializability; so serialization code will have no reason to force it to abort because of concurrent updates, making this option suitable for long-running read-only transactions.</source>
          <target state="translated">在可 &lt;code&gt;serializable&lt;/code&gt; 隔离级别上运行时，可延迟的只读SQL事务可能会在允许继续进行之前被延迟。但是，一旦开始执行，就不会产生确保可序列化性所需的任何开销。因此，序列化代码将没有理由由于并发更新而使其中止，从而使该选项适用于长时间运行的只读事务。</target>
        </trans-unit>
        <trans-unit id="d1a67057ea54f0f16f47cefbf38d78344e7ecca6" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;on&lt;/code&gt;, if a statement in a transaction block generates an error, the error is ignored and the transaction continues. When set to &lt;code&gt;interactive&lt;/code&gt;, such errors are only ignored in interactive sessions, and not when reading script files. When set to &lt;code&gt;off&lt;/code&gt; (the default), a statement in a transaction block that generates an error aborts the entire transaction. The error rollback mode works by issuing an implicit &lt;code&gt;SAVEPOINT&lt;/code&gt; for you, just before each command that is in a transaction block, and then rolling back to the savepoint if the command fails.</source>
          <target state="translated">设置为 &lt;code&gt;on&lt;/code&gt; 时，如果事务块中的语句生成错误，则该错误将被忽略，事务将继续。设置为 &lt;code&gt;interactive&lt;/code&gt; ，此类错误仅在交互式会话中被忽略，而在读取脚本文件时则不会被忽略。设置为 &lt;code&gt;off&lt;/code&gt; （默认值）时，事务块中的一条语句会产生错误，从而中止整个事务。错误回滚模式的工作方式是：在事务块中的每个命令之前向您发出一个隐式 &lt;code&gt;SAVEPOINT&lt;/code&gt; ，然后在命令失败时回滚到保存点。</target>
        </trans-unit>
        <trans-unit id="549604915bc0a6d5cfb5cf7a10c720e97be80363" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;remote_apply&lt;/code&gt;, commits will wait until replies from the current synchronous standby(s) indicate they have received the commit record of the transaction and applied it, so that it has become visible to queries on the standby(s), and also written to durable storage on the standbys. This will cause much larger commit delays than previous settings since it waits for WAL replay. When set to &lt;code&gt;on&lt;/code&gt;, commits wait until replies from the current synchronous standby(s) indicate they have received the commit record of the transaction and flushed it to durable storage. This ensures the transaction will not be lost unless both the primary and all synchronous standbys suffer corruption of their database storage. When set to &lt;code&gt;remote_write&lt;/code&gt;, commits will wait until replies from the current synchronous standby(s) indicate they have received the commit record of the transaction and written it to their file systems. This setting ensures data preservation if a standby instance of PostgreSQL crashes, but not if the standby suffers an operating-system-level crash because the data has not necessarily reached durable storage on the standby. The setting &lt;code&gt;local&lt;/code&gt; causes commits to wait for local flush to disk, but not for replication. This is usually not desirable when synchronous replication is in use, but is provided for completeness.</source>
          <target state="translated">当设置为 &lt;code&gt;remote_apply&lt;/code&gt; 时，提交将一直等待，直到当前同步备用数据库的答复表明他们已接收到事务的提交记录并应用了该记录后，提交对备用数据库上的查询才可见，并已写入备用数据库上的持久存储。这将导致比以前的设置大得多的提交延迟，因为它等待WAL重放。当设置为 &lt;code&gt;on&lt;/code&gt; 时，提交将等待直到当前同步备用数据库的答复指示它们已接收到事务的提交记录并将其刷新到持久性存储中。这样可以确保事务不会丢失，除非主备用数据库和所有同步备用数据库都遭受数据库存储损坏。设置为 &lt;code&gt;remote_write&lt;/code&gt; 时，提交将一直等到当前同步备用数据库的答复指示它们已接收到事务的提交记录并将其写入其文件系统。如果PostgreSQL的一个备用实例崩溃，此设置可确保数据保存，但如果备用数据库遭受操作系统级别的崩溃，则该设置可确保数据保存，因为数据不一定已到达备用数据库上的持久存储。 &lt;code&gt;local&lt;/code&gt; 设置导致提交等待本地刷新到磁盘，但不等待复制。当使用同步复制时，通常这是不希望的，但为了完整性起见，提供了此功能。</target>
        </trans-unit>
        <trans-unit id="43e9cba78fc8dadeb25eba89d19fc5d8c6ee61b8" translate="yes" xml:space="preserve">
          <source>When set to off, which is the default, PostgreSQL will raise a PANIC-level error on failure to flush modified data files to the file system. This causes the database server to crash. This parameter can only be set at server start.</source>
          <target state="translated">当设置为关闭(默认值)时,PostgreSQL会在未能将修改的数据文件刷新到文件系统时引发PANIC级别的错误。这将导致数据库服务器崩溃。这个参数只能在服务器启动时设置。</target>
        </trans-unit>
        <trans-unit id="6cbaca794cc78ed3c2b124781f712501c0ff4934" translate="yes" xml:space="preserve">
          <source>When set to on, which is the default, PostgreSQL will automatically reinitialize after a backend crash. Leaving this value set to on is normally the best way to maximize the availability of the database. However, in some circumstances, such as when PostgreSQL is being invoked by clusterware, it may be useful to disable the restart so that the clusterware can gain control and take any actions it deems appropriate.</source>
          <target state="translated">当设置为开启时,PostgreSQL会在后台崩溃后自动重新初始化。将这个值设置为on通常是最大限度地提高数据库可用性的最佳方式,但在某些情况下,例如当PostgreSQL被集群软件调用时,禁用PostgreSQL可能是有用的。然而,在某些情况下,例如当PostgreSQL被群集软件调用时,禁用重启可能是有用的,这样群集软件就可以获得控制权,并采取任何它认为合适的行动。</target>
        </trans-unit>
        <trans-unit id="a7b55871d6d7b3f171d441751dee834b0868dec6" translate="yes" xml:space="preserve">
          <source>When set, &lt;code&gt;debug_pretty_print&lt;/code&gt; indents the messages produced by &lt;code&gt;debug_print_parse&lt;/code&gt;, &lt;code&gt;debug_print_rewritten&lt;/code&gt;, or &lt;code&gt;debug_print_plan&lt;/code&gt;. This results in more readable but much longer output than the &amp;ldquo;compact&amp;rdquo; format used when it is off. It is on by default.</source>
          <target state="translated">设置后， &lt;code&gt;debug_pretty_print&lt;/code&gt; 缩进由 &lt;code&gt;debug_print_parse&lt;/code&gt; ， &lt;code&gt;debug_print_rewritten&lt;/code&gt; 或 &lt;code&gt;debug_print_plan&lt;/code&gt; 生成的消息。与关闭时使用的&amp;ldquo;压缩&amp;rdquo;格式相比，这将导致更具可读性，但输出更长的时间。默认情况下它是打开的。</target>
        </trans-unit>
        <trans-unit id="9655c6cce4ab0fb89202aa42165255e7c2310c07" translate="yes" xml:space="preserve">
          <source>When setting any of these parameters, a relative path will be interpreted with respect to the directory in which &lt;code&gt;postgres&lt;/code&gt; is started.</source>
          <target state="translated">设置这些参数中的任何一个时，将相对于启动 &lt;code&gt;postgres&lt;/code&gt; 的目录解释相对路径。</target>
        </trans-unit>
        <trans-unit id="f5cba5ccebd44827dbe97e5c58205ecd19cd5549" translate="yes" xml:space="preserve">
          <source>When several data types share near-identical sorting semantics, their operator classes can be grouped into an operator family. Doing so is advantageous because it allows the planner to make deductions about cross-type comparisons. Each operator class within the family should contain the single-type operators (and associated support functions) for its input data type, while cross-type comparison operators and support functions are &amp;ldquo;loose&amp;rdquo; in the family. It is recommendable that a complete set of cross-type operators be included in the family, thus ensuring that the planner can represent any comparison conditions that it deduces from transitivity.</source>
          <target state="translated">当几种数据类型共享几乎相同的排序语义时，可以将它们的运算符类别分组为一个运算符族。这样做是有利的，因为它允许计划者对交叉类型比较进行推论。系列中的每个运算符类都应包含其输入数据类型的单类型运算符（和关联的支持功能），而交叉类型比较运算符和支持功能在该系列中是&amp;ldquo;松散的&amp;rdquo;。建议在该系列中包括一整套交叉类型的运算符，从而确保规划器可以代表由传递性推论得出的任何比较条件。</target>
        </trans-unit>
        <trans-unit id="cb221d1e490779006a131832600e7b4ca11a22c2" translate="yes" xml:space="preserve">
          <source>When showing progress (option &lt;code&gt;-P&lt;/code&gt;), use a timestamp (Unix epoch) instead of the number of seconds since the beginning of the run. The unit is in seconds, with millisecond precision after the dot. This helps compare logs generated by various tools.</source>
          <target state="translated">显示进度（选项 &lt;code&gt;-P&lt;/code&gt; ）时，请使用时间戳记（Unix时期），而不是自运行开始以来的秒数。单位为秒，点后为毫秒精度。这有助于比较各种工具生成的日志。</target>
        </trans-unit>
        <trans-unit id="cc026cecf0c9d705d368f497265f6e7182739df8" translate="yes" xml:space="preserve">
          <source>When sorting &lt;code&gt;inet&lt;/code&gt; or &lt;code&gt;cidr&lt;/code&gt; data types, IPv4 addresses will always sort before IPv6 addresses, including IPv4 addresses encapsulated or mapped to IPv6 addresses, such as ::10.2.3.4 or ::ffff:10.4.3.2.</source>
          <target state="translated">在排序 &lt;code&gt;inet&lt;/code&gt; 或 &lt;code&gt;cidr&lt;/code&gt; 数据类型时，IPv4地址将始终在IPv6地址之前排序，包括封装或映射到IPv6地址的IPv4地址，例如:: 10.2.3.4或:: ffff：10.4.3.2。</target>
        </trans-unit>
        <trans-unit id="00112c1a0dfb2756ee57aac0f953ab1b28e8aa6b" translate="yes" xml:space="preserve">
          <source>When specified, mandates that corresponding &lt;code&gt;index_column_name&lt;/code&gt; or &lt;code&gt;index_expression&lt;/code&gt; use a particular collation in order to be matched during inference. Typically this is omitted, as collations usually do not affect whether or not a constraint violation occurs. Follows &lt;code&gt;CREATE INDEX&lt;/code&gt; format.</source>
          <target state="translated">指定后，授权相应的 &lt;code&gt;index_column_name&lt;/code&gt; 或 &lt;code&gt;index_expression&lt;/code&gt; 使用特定的排序规则，以便在推理期间进行匹配。通常会省略此步骤，因为归类通常不影响是否发生约束冲突。遵循 &lt;code&gt;CREATE INDEX&lt;/code&gt; 格式。</target>
        </trans-unit>
        <trans-unit id="49ab9aed56a17743958b35c4487c001e52ad9448" translate="yes" xml:space="preserve">
          <source>When specified, mandates that corresponding &lt;code&gt;index_column_name&lt;/code&gt; or &lt;code&gt;index_expression&lt;/code&gt; use particular operator class in order to be matched during inference. Typically this is omitted, as the &lt;em&gt;equality&lt;/em&gt; semantics are often equivalent across a type's operator classes anyway, or because it's sufficient to trust that the defined unique indexes have the pertinent definition of equality. Follows &lt;code&gt;CREATE INDEX&lt;/code&gt; format.</source>
          <target state="translated">指定后，授权相应的 &lt;code&gt;index_column_name&lt;/code&gt; 或 &lt;code&gt;index_expression&lt;/code&gt; 使用特定的运算符类，以便在推理期间进行匹配。通常，这会被省略，因为&lt;em&gt;相等&lt;/em&gt;语义无论如何在类型的运算符类中通常都是等效的，或者因为足以信任已定义的唯一索引具有适当的相等定义。遵循 &lt;code&gt;CREATE INDEX&lt;/code&gt; 格式。</target>
        </trans-unit>
        <trans-unit id="cb6cddffb6a42656d1b6071c587cfd75339041b2" translate="yes" xml:space="preserve">
          <source>When specifying a function by name rather than by OID, the allowed input is the same as for the &lt;code&gt;regprocedure&lt;/code&gt; data type (see &lt;a href=&quot;datatype-oid&quot;&gt;Section 8.19&lt;/a&gt;). An example is:</source>
          <target state="translated">当通过名称而不是通过OID指定函数时，允许的输入与 &lt;code&gt;regprocedure&lt;/code&gt; 数据类型相同（请参见&lt;a href=&quot;datatype-oid&quot;&gt;第8.19节&lt;/a&gt;）。一个例子是：</target>
        </trans-unit>
        <trans-unit id="f47b14844e6f65e1969fe664f76645a83ada8978" translate="yes" xml:space="preserve">
          <source>When specifying the &lt;code&gt;program&lt;/code&gt; option, keep in mind that the option string is executed by the shell. If you need to pass any arguments to the command that come from an untrusted source, you must be careful to strip or escape any characters that might have special meaning to the shell. For security reasons, it is best to use a fixed command string, or at least avoid passing any user input in it.</source>
          <target state="translated">指定 &lt;code&gt;program&lt;/code&gt; 选项时，请记住，选项字符串由外壳执行。如果需要将来自不受信任来源的任何参数传递给命令，则必须小心删除或转义对shell可能具有特殊含义的任何字符。出于安全原因，最好使用固定的命令字符串，或者至少避免在其中传递任何用户输入。</target>
        </trans-unit>
        <trans-unit id="a86f4916e3e42d9bf0f446f6ed8f6c9365f0b9b8" translate="yes" xml:space="preserve">
          <source>When starting a client session via libpq, parameter settings can be specified using the &lt;code&gt;PGOPTIONS&lt;/code&gt; environment variable. Settings established in this way constitute defaults for the life of the session, but do not affect other sessions. For historical reasons, the format of &lt;code&gt;PGOPTIONS&lt;/code&gt; is similar to that used when launching the &lt;code&gt;postgres&lt;/code&gt; command; specifically, the &lt;code&gt;-c&lt;/code&gt; flag must be specified. For example,</source>
          <target state="translated">通过libpq启动客户端会话时，可以使用 &lt;code&gt;PGOPTIONS&lt;/code&gt; 环境变量指定参数设置。以这种方式建立的设置构成会话生命周期的默认值，但不影响其他会话。由于历史原因， &lt;code&gt;PGOPTIONS&lt;/code&gt; 的格式类似于启动 &lt;code&gt;postgres&lt;/code&gt; 命令时使用的格式；具体来说，必须指定 &lt;code&gt;-c&lt;/code&gt; 标志。例如，</target>
        </trans-unit>
        <trans-unit id="8b3e57832327b1f4cd35e9869284543eb2583802" translate="yes" xml:space="preserve">
          <source>When starting the target, PostgreSQL replays all the required WAL, resulting in a data directory in a consistent state.</source>
          <target state="translated">当启动目标时,PostgreSQL会重播所有需要的WAL,从而使数据目录处于一致的状态。</target>
        </trans-unit>
        <trans-unit id="80810b3a36d5394cd36078211fe98f572205f903" translate="yes" xml:space="preserve">
          <source>When suitable, query results can be shown in a crosstab representation with the &lt;code&gt;\crosstabview&lt;/code&gt; command:</source>
          <target state="translated">如果合适，查询结果可以使用 &lt;code&gt;\crosstabview&lt;/code&gt; 命令以交叉表表示形式显示：</target>
        </trans-unit>
        <trans-unit id="4333b702c3660525cc0e63ef6d85c05931c74735" translate="yes" xml:space="preserve">
          <source>When tar format is used, it is the user's responsibility to unpack each tar file before starting a PostgreSQL server that uses the data. If there are additional tablespaces, the tar files for them need to be unpacked in the correct locations. In this case the symbolic links for those tablespaces will be created by the server according to the contents of the &lt;code&gt;tablespace_map&lt;/code&gt; file that is included in the &lt;code&gt;base.tar&lt;/code&gt; file.</source>
          <target state="translated">使用tar格式时，在启动使用该数据的PostgreSQL服务器之前，用户有责任解压缩每个tar文件。如果还有其他表空间，则需要将它们的tar文件解压缩到正确的位置。在这种情况下，服务器将根据 &lt;code&gt;base.tar&lt;/code&gt; 文件中包含的 &lt;code&gt;tablespace_map&lt;/code&gt; 文件的内容为这些表空间创建符号链接。</target>
        </trans-unit>
        <trans-unit id="a4ddbde0da0e9c11c9f3ba6aaa05f9fc0b15fe03" translate="yes" xml:space="preserve">
          <source>When tar format is used, the write-ahead log files will be included in the &lt;code&gt;base.tar&lt;/code&gt; file.</source>
          <target state="translated">使用tar格式时，预写日志文件将包含在 &lt;code&gt;base.tar&lt;/code&gt; 文件中。</target>
        </trans-unit>
        <trans-unit id="7e8dcb5224676a60278f816ad09b8db2eb2d49b5" translate="yes" xml:space="preserve">
          <source>When tar format is used, the write-ahead log files will be written to a separate file named &lt;code&gt;pg_wal.tar&lt;/code&gt; (if the server is a version earlier than 10, the file will be named &lt;code&gt;pg_xlog.tar&lt;/code&gt;).</source>
          <target state="translated">使用tar格式时，预写日志文件将被写入一个名为 &lt;code&gt;pg_wal.tar&lt;/code&gt; 的单独文件中（如果服务器的版本早于10，该文件将被命名为 &lt;code&gt;pg_xlog.tar&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a46f34ffb8c110010cfd3fe050b49b5689c1e534" translate="yes" xml:space="preserve">
          <source>When tar format mode is used, it is the user's responsibility to unpack each tar file before starting the PostgreSQL server. If there are additional tablespaces, the tar files for them need to be unpacked in the correct locations. In this case the symbolic links for those tablespaces will be created by the server according to the contents of the &lt;code&gt;tablespace_map&lt;/code&gt; file that is included in the &lt;code&gt;base.tar&lt;/code&gt; file.</source>
          <target state="translated">使用tar格式模式时，在启动PostgreSQL服务器之前，用户有责任解压缩每个tar文件。如果还有其他表空间，则需要将它们的tar文件解压缩到正确的位置。在这种情况下，服务器将根据 &lt;code&gt;base.tar&lt;/code&gt; 文件中包含的 &lt;code&gt;tablespace_map&lt;/code&gt; 文件的内容为这些表空间创建符号链接。</target>
        </trans-unit>
        <trans-unit id="34c7d99e4e21933c48e46c135fcf1d89d1aca09e" translate="yes" xml:space="preserve">
          <source>When tar format mode is used, the write-ahead log files will be written to a separate file named &lt;code&gt;pg_wal.tar&lt;/code&gt; (if the server is a version earlier than 10, the file will be named &lt;code&gt;pg_xlog.tar&lt;/code&gt;).</source>
          <target state="translated">当使用tar格式模式时，预写日志文件将被写入一个名为 &lt;code&gt;pg_wal.tar&lt;/code&gt; 的单独文件中（如果服务器的版本早于10，该文件将被命名为 &lt;code&gt;pg_xlog.tar&lt;/code&gt; ）。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
