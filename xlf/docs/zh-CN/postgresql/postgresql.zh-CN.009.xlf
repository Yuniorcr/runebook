<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="2fd647ad9469bb58fc1688a31c856ba421945ca2" translate="yes" xml:space="preserve">
          <source>All queries in the &lt;code&gt;WITH&lt;/code&gt; list are computed. These effectively serve as temporary tables that can be referenced in the &lt;code&gt;FROM&lt;/code&gt; list. A &lt;code&gt;WITH&lt;/code&gt; query that is referenced more than once in &lt;code&gt;FROM&lt;/code&gt; is computed only once, unless specified otherwise with &lt;code&gt;NOT MATERIALIZED&lt;/code&gt;. (See &lt;a href=&quot;sql-select#SQL-WITH&quot;&gt;&lt;code&gt;WITH&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">将计算 &lt;code&gt;WITH&lt;/code&gt; 列表中的所有查询。这些有效地用作可以在 &lt;code&gt;FROM&lt;/code&gt; 列表中引用的临时表。一个 &lt;code&gt;WITH&lt;/code&gt; 被不止一次地引用了查询 &lt;code&gt;FROM&lt;/code&gt; 只计算一次，除非另有说明 &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; 。（请参阅下面的&lt;a href=&quot;sql-select#SQL-WITH&quot;&gt; &lt;code&gt;WITH&lt;/code&gt; 子句&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="d5d88441c9f02c86f8bfc47e2413965c87d4afdf" translate="yes" xml:space="preserve">
          <source>All queries in the &lt;code&gt;WITH&lt;/code&gt; list are computed. These effectively serve as temporary tables that can be referenced in the &lt;code&gt;FROM&lt;/code&gt; list. A &lt;code&gt;WITH&lt;/code&gt; query that is referenced more than once in &lt;code&gt;FROM&lt;/code&gt; is computed only once, unless specified otherwise with &lt;code&gt;NOT MATERIALIZED&lt;/code&gt;. (See &lt;a href=&quot;sql-select#SQL-WITH&quot;&gt;WITH Clause&lt;/a&gt; below.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f087ce49a12f5467c1e1d2b10a821f36bb151962" translate="yes" xml:space="preserve">
          <source>All rows in the temporary table will be deleted at the end of each transaction block. Essentially, an automatic &lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt; is done at each commit.</source>
          <target state="translated">临时表中的所有行将在每个事务块的末尾删除。本质上，每次提交都会执行一次自动&lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2033a72b30b992b55fdec7e008bb0316322a754e" translate="yes" xml:space="preserve">
          <source>All rows in the temporary table will be deleted at the end of each transaction block. Essentially, an automatic &lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt; is done at each commit. When used on a partitioned table, this is not cascaded to its partitions.</source>
          <target state="translated">临时表中的所有行将在每个事务块的末尾删除。本质上，每次提交都会执行一次自动&lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt;。在分区表上使用时，它不会级联到其分区。</target>
        </trans-unit>
        <trans-unit id="6dcf0dcfbfdd9c5f88b82f71ae9c913b23c0891e" translate="yes" xml:space="preserve">
          <source>All rows inserted into a partitioned table will be routed to one of the &lt;em&gt;partitions&lt;/em&gt; based on the value of the partition key. Each partition has a subset of the data defined by its &lt;em&gt;partition bounds&lt;/em&gt;. The currently supported partitioning methods are range, list, and hash.</source>
          <target state="translated">插入到分区表中的所有行会被路由到一个&lt;em&gt;分区&lt;/em&gt;根据分区键的值。每个分区都有由其&lt;em&gt;分区范围&lt;/em&gt;定义的数据子集。当前支持的分区方法是范围，列表和哈希。</target>
        </trans-unit>
        <trans-unit id="4513787ec30b4d30ebbb9895538f30d98e3df810" translate="yes" xml:space="preserve">
          <source>All standard and predefined collations are deterministic, all user-defined collations are deterministic by default. While nondeterministic collations give a more &amp;ldquo;correct&amp;rdquo; behavior, especially when considering the full power of Unicode and its many special cases, they also have some drawbacks. Foremost, their use leads to a performance penalty. Also, certain operations are not possible with nondeterministic collations, such as pattern matching operations. Therefore, they should be used only in cases where they are specifically wanted.</source>
          <target state="translated">默认情况下，所有标准归类和预定义归类都是确定性的，所有用户定义归类都是确定性的。尽管不确定性排序规则提供了更&amp;ldquo;正确&amp;rdquo;的行为，尤其是考虑到Unicode的全部功能及其许多特殊情况时，它们也有一些缺点。首先，使用它们会导致性能下降。同样，某些不确定的归类操作是不可能的，例如模式匹配操作。因此，仅在特别需要它们的情况下才应使用它们。</target>
        </trans-unit>
        <trans-unit id="25b4cbd01fbf767d95283abe0881812c05362a17" translate="yes" xml:space="preserve">
          <source>All standard and predefined collations are deterministic, all user-defined collations are deterministic by default. While nondeterministic collations give a more &amp;ldquo;correct&amp;rdquo; behavior, especially when considering the full power of Unicode and its many special cases, they also have some drawbacks. Foremost, their use leads to a performance penalty. Note, in particular, that B-tree cannot use deduplication with indexes that use a nondeterministic collation. Also, certain operations are not possible with nondeterministic collations, such as pattern matching operations. Therefore, they should be used only in cases where they are specifically wanted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33701db90942013a1dfc5834530a8ecffe185cf9" translate="yes" xml:space="preserve">
          <source>All statements of the current transaction can only see rows committed before the first query or data-modification statement was executed in this transaction.</source>
          <target state="translated">当前事务的所有语句只能看到在本事务中执行第一个查询或数据修改语句之前提交的行。</target>
        </trans-unit>
        <trans-unit id="2e14dc15c0e8ebe018dfe9b3ade39c8f85c910d9" translate="yes" xml:space="preserve">
          <source>All statements of the current transaction can only see rows committed before the first query or data-modification statement was executed in this transaction. If a pattern of reads and writes among concurrent serializable transactions would create a situation which could not have occurred for any serial (one-at-a-time) execution of those transactions, one of them will be rolled back with a &lt;code&gt;serialization_failure&lt;/code&gt; error.</source>
          <target state="translated">当前事务的所有语句只能看到在该事务中执行第一个查询或数据修改语句之前提交的行。如果并发可序列化事务之间的读写模式会导致这种事务的任何串行（一次）执行都不可能发生的情况，则其中一个将回滚，并出现 &lt;code&gt;serialization_failure&lt;/code&gt; 错误。</target>
        </trans-unit>
        <trans-unit id="333b8b7d294d7e593e47c576e136baad90efa83c" translate="yes" xml:space="preserve">
          <source>All system-defined SQL objects reside in schema &lt;code&gt;pg_catalog&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd69152cf9c28ea6bdb8489a69a762ca6be86225" translate="yes" xml:space="preserve">
          <source>All systems would have the same &lt;code&gt;shared.conf&lt;/code&gt;. Each server with a particular amount of memory could share the same &lt;code&gt;memory.conf&lt;/code&gt;; you might have one for all servers with 8GB of RAM, another for those having 16GB. And finally &lt;code&gt;server.conf&lt;/code&gt; could have truly server-specific configuration information in it.</source>
          <target state="translated">所有系统都将具有相同的 &lt;code&gt;shared.conf&lt;/code&gt; 。每个具有特定内存量的服务器都可以共享相同的 &lt;code&gt;memory.conf&lt;/code&gt; ；对于所有具有8GB RAM的服务器，您可能会有一个服务器；对于具有16GB的服务器，可能会有一个服务器。最后， &lt;code&gt;server.conf&lt;/code&gt; 中可能包含真正的服务器特定的配置信息。</target>
        </trans-unit>
        <trans-unit id="fdb84efbad86954ba5aa82c861c3c65c57c671dd" translate="yes" xml:space="preserve">
          <source>All table rows are structured in the same way. There is a fixed-size header (occupying 23 bytes on most machines), followed by an optional null bitmap, an optional object ID field, and the user data. The header is detailed in &lt;a href=&quot;storage-page-layout#HEAPTUPLEHEADERDATA-TABLE&quot;&gt;Table 68.4&lt;/a&gt;. The actual user data (columns of the row) begins at the offset indicated by &lt;code&gt;t_hoff&lt;/code&gt;, which must always be a multiple of the MAXALIGN distance for the platform. The null bitmap is only present if the &lt;em&gt;HEAP_HASNULL&lt;/em&gt; bit is set in &lt;code&gt;t_infomask&lt;/code&gt;. If it is present it begins just after the fixed header and occupies enough bytes to have one bit per data column (that is, the number of bits that equals the attribute count in &lt;code&gt;t_infomask2&lt;/code&gt;). In this list of bits, a 1 bit indicates not-null, a 0 bit is a null. When the bitmap is not present, all columns are assumed not-null. The object ID is only present if the &lt;em&gt;HEAP_HASOID_OLD&lt;/em&gt; bit is set in &lt;code&gt;t_infomask&lt;/code&gt;. If present, it appears just before the &lt;code&gt;t_hoff&lt;/code&gt; boundary. Any padding needed to make &lt;code&gt;t_hoff&lt;/code&gt; a MAXALIGN multiple will appear between the null bitmap and the object ID. (This in turn ensures that the object ID is suitably aligned.)</source>
          <target state="translated">所有表行的结构均相同。有一个固定大小的标头（在大多数计算机上占23个字节），后跟一个可选的空位图，一个可选的对象ID字段以及用户数据。&lt;a href=&quot;storage-page-layout#HEAPTUPLEHEADERDATA-TABLE&quot;&gt;表68.4中&lt;/a&gt;详细介绍了标题。实际用户数据（行的列）从 &lt;code&gt;t_hoff&lt;/code&gt; 指示的偏移量开始，该偏移量必须始终是平台的MAXALIGN距离的倍数。仅当在&lt;em&gt;t_infomask&lt;/em&gt;中设置了&lt;em&gt;HEAP_HASNULL&lt;/em&gt;位时，才出现 &lt;code&gt;t_infomask&lt;/code&gt; 。如果存在，它将在固定头之后立即开始，并且占用足够的字节以使每个数据列具有一位（即，等于 &lt;code&gt;t_infomask2&lt;/code&gt; 中的属性计数的位数））。在此位列表中，1位表示非空，0位表示空。当位图不存在时，所有列均假定为非空。如果该对象ID是唯一存在&lt;em&gt;HEAP_HASOID_OLD&lt;/em&gt;位在设置 &lt;code&gt;t_infomask&lt;/code&gt; 。如果存在，它将出现在 &lt;code&gt;t_hoff&lt;/code&gt; 边界之前。将 &lt;code&gt;t_hoff&lt;/code&gt; 设为 MAXALIGN倍数所需的任何填充将出现在空位图和对象ID之间。 （这反过来又可以确保对象ID正确对齐。）</target>
        </trans-unit>
        <trans-unit id="07e8311d5ee709346fa3f96903022cdc35bc8edc" translate="yes" xml:space="preserve">
          <source>All tables in the current database in a tablespace can be moved by using the &lt;code&gt;ALL IN TABLESPACE&lt;/code&gt; form, which will lock all tables to be moved first and then move each one. This form also supports &lt;code&gt;OWNED BY&lt;/code&gt;, which will only move tables owned by the roles specified. If the &lt;code&gt;NOWAIT&lt;/code&gt; option is specified then the command will fail if it is unable to acquire all of the locks required immediately. Note that system catalogs are not moved by this command; use &lt;code&gt;ALTER DATABASE&lt;/code&gt; or explicit &lt;code&gt;ALTER TABLE&lt;/code&gt; invocations instead if desired. The &lt;code&gt;information_schema&lt;/code&gt; relations are not considered part of the system catalogs and will be moved. See also &lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;ALL IN TABLESPACE&lt;/code&gt; 表单移动表空间中当前数据库中的所有表，该表单将锁定所有要先移动的表，然后再移动每个表。此表单还支持 &lt;code&gt;OWNED BY&lt;/code&gt; ，它将仅移动指定角色所拥有的表。如果指定了 &lt;code&gt;NOWAIT&lt;/code&gt; 选项，则如果该命令无法立即获取所有必需的锁，则该命令将失败。请注意，该命令不会移动系统目录。如果需要，请改用 &lt;code&gt;ALTER DATABASE&lt;/code&gt; 或显式的 &lt;code&gt;ALTER TABLE&lt;/code&gt; 调用。该 &lt;code&gt;information_schema&lt;/code&gt; 关系不被认为是系统目录的一部分，将被移动。另请参见&lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fba1b0761d495deac6051791b1b8f0b77af030f7" translate="yes" xml:space="preserve">
          <source>All the GiST support methods are normally called in short-lived memory contexts; that is, &lt;code&gt;CurrentMemoryContext&lt;/code&gt; will get reset after each tuple is processed. It is therefore not very important to worry about pfree'ing everything you palloc. However, in some cases it's useful for a support method to cache data across repeated calls. To do that, allocate the longer-lived data in &lt;code&gt;fcinfo-&amp;gt;flinfo-&amp;gt;fn_mcxt&lt;/code&gt;, and keep a pointer to it in &lt;code&gt;fcinfo-&amp;gt;flinfo-&amp;gt;fn_extra&lt;/code&gt;. Such data will survive for the life of the index operation (e.g., a single GiST index scan, index build, or index tuple insertion). Be careful to pfree the previous value when replacing a &lt;code&gt;fn_extra&lt;/code&gt; value, or the leak will accumulate for the duration of the operation.</source>
          <target state="translated">通常在短期内存上下文中调用所有GiST支持方法。也就是说，在处理每个元组之后， &lt;code&gt;CurrentMemoryContext&lt;/code&gt; 将被重置。因此，担心pfreeing分配palloc的所有内容并不是很重要。但是，在某些情况下，对于支持方法在重复调用之间缓存数据很有用。为此，请在 &lt;code&gt;fcinfo-&amp;gt;flinfo-&amp;gt;fn_mcxt&lt;/code&gt; 分配寿命更长的数据，并在 &lt;code&gt;fcinfo-&amp;gt;flinfo-&amp;gt;fn_extra&lt;/code&gt; 中保留指向它的指针。这样的数据将在索引操作的整个生命周期（例如，单个GiST索引扫描，索引构建或索引元组插入）中保留下来。替换 &lt;code&gt;fn_extra&lt;/code&gt; 值时，请小心释放先前的值，否则在操作期间将累积泄漏。</target>
        </trans-unit>
        <trans-unit id="1775f572f652b9b020df7dce36fbde055a9f9549" translate="yes" xml:space="preserve">
          <source>All the SP-GiST support methods are normally called in a short-lived memory context; that is, &lt;code&gt;CurrentMemoryContext&lt;/code&gt; will be reset after processing of each tuple. It is therefore not very important to worry about pfree'ing everything you palloc. (The &lt;code&gt;config&lt;/code&gt; method is an exception: it should try to avoid leaking memory. But usually the &lt;code&gt;config&lt;/code&gt; method need do nothing but assign constants into the passed parameter struct.)</source>
          <target state="translated">通常在短期内存上下文中调用所有SP-GiST支持方法。也就是说，在处理每个元组之后，将重置 &lt;code&gt;CurrentMemoryContext&lt;/code&gt; 。因此，担心pfreeing分配palloc的所有内容并不是很重要。（ &lt;code&gt;config&lt;/code&gt; 方法是一个例外：它应尽量避免泄漏内存。但是通常 &lt;code&gt;config&lt;/code&gt; 方法不需要做任何事情，只不过将常量分配给传递的参数struct。）</target>
        </trans-unit>
        <trans-unit id="45bde084b879a44097ffbb7f22a89ae3a6f15f28" translate="yes" xml:space="preserve">
          <source>All the actions except &lt;code&gt;RENAME&lt;/code&gt; and &lt;code&gt;SET SCHEMA&lt;/code&gt; can be combined into a list of multiple alterations to apply in parallel. For example, it is possible to add several columns and/or alter the type of several columns in a single command.</source>
          <target state="translated">除了 &lt;code&gt;RENAME&lt;/code&gt; 和 &lt;code&gt;SET SCHEMA&lt;/code&gt; 之外的所有动作都可以组合成多个更改列表以并行应用。例如，可以在单个命令中添加几列和/或更改几列的类型。</target>
        </trans-unit>
        <trans-unit id="510081c46bee5d125d10e16db44ba6aa06aa8209" translate="yes" xml:space="preserve">
          <source>All the aggregates listed in &lt;a href=&quot;functions-aggregate#FUNCTIONS-ORDEREDSET-TABLE&quot;&gt;Table 9.57&lt;/a&gt; ignore null values in their sorted input. For those that take a &lt;code&gt;fraction&lt;/code&gt; parameter, the fraction value must be between 0 and 1; an error is thrown if not. However, a null fraction value simply produces a null result.</source>
          <target state="translated">&lt;a href=&quot;functions-aggregate#FUNCTIONS-ORDEREDSET-TABLE&quot;&gt;表9.57中&lt;/a&gt;列出的所有聚合在其排序的输入中都会忽略空值。对于带有 &lt;code&gt;fraction&lt;/code&gt; 参数的变量，小数值必须在0到1之间；如果没有，则会引发错误。但是，空分数值只会产生空结果。</target>
        </trans-unit>
        <trans-unit id="51ab62b62647a9e48b750694e717b8b41fe65f92" translate="yes" xml:space="preserve">
          <source>All the backslash commands of a given conditional block must appear in the same source file. If EOF is reached on the main input file or an &lt;code&gt;\include&lt;/code&gt;-ed file before all local &lt;code&gt;\if&lt;/code&gt;-blocks have been closed, then psql will raise an error.</source>
          <target state="translated">给定条件块的所有反斜杠命令必须出现在同一源文件中。如果在所有本地 &lt;code&gt;\if&lt;/code&gt; -blocks关闭之前，在主输入文件或 &lt;code&gt;\include&lt;/code&gt; -ed文件上达到EOF ，则psql将引发错误。</target>
        </trans-unit>
        <trans-unit id="c3df3ceb9c111c6a03e79138ef843c3f5502324f" translate="yes" xml:space="preserve">
          <source>All the constraints that refer to the index are changed to refer to the new index definition, and the names of the indexes are changed. At this point, &lt;code&gt;pg_index.indisvalid&lt;/code&gt; is switched to &amp;ldquo;true&amp;rdquo; for the new index and to &amp;ldquo;false&amp;rdquo; for the old, and a cache invalidation is done causing all sessions that referenced the old index to be invalidated.</source>
          <target state="translated">引用索引的所有约束都将更改为引用新的索引定义，并且索引的名称也会更改。此时，对于新索引， &lt;code&gt;pg_index.indisvalid&lt;/code&gt; 切换为&amp;ldquo; true&amp;rdquo;，对于旧索引，pg_index.indisvalid切换为&amp;ldquo; false&amp;rdquo;，并且执行了高速缓存无效化，使所有引用旧索引的会话均无效。</target>
        </trans-unit>
        <trans-unit id="58e9eb20e27c19e1e0424c58bd8a9c7b575ba760" translate="yes" xml:space="preserve">
          <source>All the date/time data types also accept the special literal value &lt;code&gt;now&lt;/code&gt; to specify the current date and time (again, interpreted as the transaction start time). Thus, the following three all return the same result:</source>
          <target state="translated">所有日期/时间类型还接受特殊的文本值 &lt;code&gt;now&lt;/code&gt; 到指定当前日期和时间（再次，解释为交易开始时间）。因此，以下三个都返回相同的结果：</target>
        </trans-unit>
        <trans-unit id="04a9db0f3580dacac057df2d96a2b53bd9011eea" translate="yes" xml:space="preserve">
          <source>All the details can be found in &lt;code&gt;src/include/access/htup_details.h&lt;/code&gt;.</source>
          <target state="translated">所有详细信息都可以在 &lt;code&gt;src/include/access/htup_details.h&lt;/code&gt; 中找到。</target>
        </trans-unit>
        <trans-unit id="7055165401c8e4a16f7e52ca1e39b100c0c219f9" translate="yes" xml:space="preserve">
          <source>All the details can be found in &lt;code&gt;src/include/storage/bufpage.h&lt;/code&gt;.</source>
          <target state="translated">所有详细信息都可以在 &lt;code&gt;src/include/storage/bufpage.h&lt;/code&gt; 中找到。</target>
        </trans-unit>
        <trans-unit id="11f6c8098d40647f8499682bcc9a9b6ba89c0f7d" translate="yes" xml:space="preserve">
          <source>All the forms of ALTER TABLE that act on a single table, except &lt;code&gt;RENAME&lt;/code&gt;, &lt;code&gt;SET SCHEMA&lt;/code&gt;, &lt;code&gt;ATTACH PARTITION&lt;/code&gt;, and &lt;code&gt;DETACH PARTITION&lt;/code&gt; can be combined into a list of multiple alterations to be applied together. For example, it is possible to add several columns and/or alter the type of several columns in a single command. This is particularly useful with large tables, since only one pass over the table need be made.</source>
          <target state="translated">除 &lt;code&gt;RENAME&lt;/code&gt; ， &lt;code&gt;SET SCHEMA&lt;/code&gt; ， &lt;code&gt;ATTACH PARTITION&lt;/code&gt; 和 &lt;code&gt;DETACH PARTITION&lt;/code&gt; 之外，所有作用于单个表的ALTER TABLE形式都可以组合成一个多个变更列表，以一起应用。例如，可以在单个命令中添加几列和/或更改几列的类型。这对于大型表特别有用，因为只需要对表进行一次遍历。</target>
        </trans-unit>
        <trans-unit id="f31e857d83f608bd0b8b4018bcb4f55f12705482" translate="yes" xml:space="preserve">
          <source>All the functions and operators described below that take &lt;code&gt;time&lt;/code&gt; or &lt;code&gt;timestamp&lt;/code&gt; inputs actually come in two variants: one that takes &lt;code&gt;time with time zone&lt;/code&gt; or &lt;code&gt;timestamp with time zone&lt;/code&gt;, and one that takes &lt;code&gt;time without time zone&lt;/code&gt; or &lt;code&gt;timestamp without time zone&lt;/code&gt;. For brevity, these variants are not shown separately. Also, the &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt; operators come in commutative pairs (for example both date + integer and integer + date); we show only one of each such pair.</source>
          <target state="translated">下面介绍的所有需要 &lt;code&gt;time&lt;/code&gt; 或 &lt;code&gt;timestamp&lt;/code&gt; 输入的功能和运算符实际上有两种变体：一种在 &lt;code&gt;time with time zone&lt;/code&gt; 或 &lt;code&gt;timestamp with time zone&lt;/code&gt; 变体，一种在 &lt;code&gt;time without time zone&lt;/code&gt; 或在 &lt;code&gt;timestamp without time zone&lt;/code&gt; 。为简便起见，这些变体未单独显示。另外， &lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;*&lt;/code&gt; 运算符是可交换的（例如，日期+整数和整数+日期）；我们只显示每对这样的一对。</target>
        </trans-unit>
        <trans-unit id="782a3c585f1fd27c2deebeab5aeef9142292fec9" translate="yes" xml:space="preserve">
          <source>All the items of the &lt;code&gt;path&lt;/code&gt; parameter of &lt;code&gt;jsonb_set&lt;/code&gt; as well as &lt;code&gt;jsonb_insert&lt;/code&gt; except the last item must be present in the &lt;code&gt;target&lt;/code&gt;. If &lt;code&gt;create_missing&lt;/code&gt; is false, all items of the &lt;code&gt;path&lt;/code&gt; parameter of &lt;code&gt;jsonb_set&lt;/code&gt; must be present. If these conditions are not met the &lt;code&gt;target&lt;/code&gt; is returned unchanged.</source>
          <target state="translated">&lt;code&gt;jsonb_set&lt;/code&gt; 和 &lt;code&gt;jsonb_insert&lt;/code&gt; 的 &lt;code&gt;path&lt;/code&gt; 参数的所有项目（最后一个项目除外）都必须存在于 &lt;code&gt;target&lt;/code&gt; 中。如果 &lt;code&gt;create_missing&lt;/code&gt; 为false， &lt;code&gt;jsonb_set&lt;/code&gt; 必须存在jsonb_set的 &lt;code&gt;path&lt;/code&gt; 参数的所有项目。如果不满足这些条件，则 &lt;code&gt;target&lt;/code&gt; 将保持不变。</target>
        </trans-unit>
        <trans-unit id="16b021d730b6ad62e07cfcc798d60a9ae4e55f2d" translate="yes" xml:space="preserve">
          <source>All the other details are the same as explained in the previous item.</source>
          <target state="translated">其他细节都与上一项中的解释相同。</target>
        </trans-unit>
        <trans-unit id="58d1929aa1a1a6a3046413da0a4c92627889c5ff" translate="yes" xml:space="preserve">
          <source>All the text search functions that accept an optional &lt;code&gt;regconfig&lt;/code&gt; argument will use the configuration specified by &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config&lt;/a&gt; when that argument is omitted.</source>
          <target state="translated">当省略该参数时，所有接受可选 &lt;code&gt;regconfig&lt;/code&gt; 参数的文本搜索功能都将使用&lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config&lt;/a&gt;指定的配置。</target>
        </trans-unit>
        <trans-unit id="5fd8eaf630761d65327b4b1a07fcbae46e8425a5" translate="yes" xml:space="preserve">
          <source>All these actions are performed using the &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; command, whose reference page contains details beyond those given here.</source>
          <target state="translated">所有这些操作都是使用&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;命令执行的，该命令的参考页包含此处未提供的详细信息。</target>
        </trans-unit>
        <trans-unit id="b94dc0adfca08e05341c41a7517a1ba1c57ee9cc" translate="yes" xml:space="preserve">
          <source>All these functions are intended to be used to lock application-defined resources, which can be identified either by a single 64-bit key value or two 32-bit key values (note that these two key spaces do not overlap). If another session already holds a conflicting lock on the same resource identifier, the functions will either wait until the resource becomes available, or return a &lt;code&gt;false&lt;/code&gt; result, as appropriate for the function. Locks can be either shared or exclusive: a shared lock does not conflict with other shared locks on the same resource, only with exclusive locks. Locks can be taken at session level (so that they are held until released or the session ends) or at transaction level (so that they are held until the current transaction ends; there is no provision for manual release). Multiple session-level lock requests stack, so that if the same resource identifier is locked three times there must then be three unlock requests to release the resource in advance of session end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fddab2dff735a90badf611e7a98983fea7c65273" translate="yes" xml:space="preserve">
          <source>All these functions require object OIDs to identify the object to be checked. If you want to test an object by name, it is convenient to use the OID alias types (&lt;code&gt;regclass&lt;/code&gt;, &lt;code&gt;regtype&lt;/code&gt;, &lt;code&gt;regprocedure&lt;/code&gt;, &lt;code&gt;regoperator&lt;/code&gt;, &lt;code&gt;regconfig&lt;/code&gt;, or &lt;code&gt;regdictionary&lt;/code&gt;), for example:</source>
          <target state="translated">所有这些功能都需要对象OID来标识要检查的对象。如果 &lt;code&gt;regtype&lt;/code&gt; 名称测试对象，则可以方便地使用OID别名类型（ &lt;code&gt;regclass&lt;/code&gt; ，regtype， &lt;code&gt;regprocedure&lt;/code&gt; ， &lt;code&gt;regoperator&lt;/code&gt; ， &lt;code&gt;regconfig&lt;/code&gt; 或 &lt;code&gt;regdictionary&lt;/code&gt; ），例如：</target>
        </trans-unit>
        <trans-unit id="5eb86c80e753870bd74e864dca4813e41a9bf81c" translate="yes" xml:space="preserve">
          <source>All this is encrypted with the session key and placed in the data packet.</source>
          <target state="translated">所有这些都是用会话密钥加密并放在数据包中。</target>
        </trans-unit>
        <trans-unit id="79ae9218d6216a25f546357f769737d4eb8e6a9b" translate="yes" xml:space="preserve">
          <source>All this is happening within the transaction block, so none of it is visible to other database sessions. When and if you commit the transaction block, the committed actions become visible as a unit to other sessions, while the rolled-back actions never become visible at all.</source>
          <target state="translated">所有这些都发生在事务块中,所以其他数据库会话不可见。当你提交事务块时,已提交的操作会作为一个单元对其他会话可见,而回滚的操作则完全不可见。</target>
        </trans-unit>
        <trans-unit id="f5fad09671c41f98ab40f3e4d5ed6015e3ae8fcb" translate="yes" xml:space="preserve">
          <source>All timezone-aware dates and times are stored internally in UTC. They are converted to local time in the zone specified by the &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; configuration parameter before being displayed to the client.</source>
          <target state="translated">所有可识别时区的日期和时间都内部存储在UTC中。在将它们显示给客户端之前，它们会在&lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt;配置参数指定的区域中转换为本地时间。</target>
        </trans-unit>
        <trans-unit id="d5322b3927e2a3af2ef8b19f81ff10045b29cd91" translate="yes" xml:space="preserve">
          <source>All transaction IDs before this one have been replaced with a permanent (&amp;ldquo;frozen&amp;rdquo;) transaction ID in this database. This is used to track whether the database needs to be vacuumed in order to prevent transaction ID wraparound or to allow &lt;code&gt;pg_xact&lt;/code&gt; to be shrunk. It is the minimum of the per-table &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relfrozenxid&lt;/code&gt; values.</source>
          <target state="translated">在此数据库中，此之前的所有交易ID已被永久（&amp;ldquo;冻结&amp;rdquo;）交易ID取代。这用于跟踪是否需要 &lt;code&gt;pg_xact&lt;/code&gt; 数据库以防止事务ID 绕回或缩小pg_xact。它是每个表 &lt;code&gt;pg_class&lt;/code&gt; 的最小值。 &lt;code&gt;relfrozenxid&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="086e1ad2933d663306e6cec529b31029a01389df" translate="yes" xml:space="preserve">
          <source>All transaction IDs before this one have been replaced with a permanent (&amp;ldquo;frozen&amp;rdquo;) transaction ID in this table. This is used to track whether the table needs to be vacuumed in order to prevent transaction ID wraparound or to allow &lt;code&gt;pg_xact&lt;/code&gt; to be shrunk. Zero (&lt;code&gt;InvalidTransactionId&lt;/code&gt;) if the relation is not a table.</source>
          <target state="translated">此表之前的所有交易ID已被永久（&amp;ldquo;冻结&amp;rdquo;）交易ID取代。这用于跟踪是否需要 &lt;code&gt;pg_xact&lt;/code&gt; 表以防止事务ID 绕回或允许pg_xact收缩。如果该关系不是表，则为零（ &lt;code&gt;InvalidTransactionId&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f420391c504d54ccc175474041008eed502760b8" translate="yes" xml:space="preserve">
          <source>All type conversion rules are designed with several principles in mind:</source>
          <target state="translated">所有类型转换规则的设计都要考虑到几个原则。</target>
        </trans-unit>
        <trans-unit id="109d3489123ca72cb87beebd6d4f929a800626a1" translate="yes" xml:space="preserve">
          <source>All values must be single-quoted. Escape single quotes used within a value with a backslash. Backslashes meant as data can, but need not, be doubled; this follows Perl's rules for simple quoted literals. Note that backslashes appearing as data will be treated as escapes by the bootstrap scanner, according to the same rules as for escape string constants (see &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS-ESCAPE&quot;&gt;Section 4.1.2.2&lt;/a&gt;); for example &lt;code&gt;\t&lt;/code&gt; converts to a tab character. If you actually want a backslash in the final value, you will need to write four of them: Perl strips two, leaving &lt;code&gt;\\&lt;/code&gt; for the bootstrap scanner to see.</source>
          <target state="translated">所有值都必须用单引号引起来。用反斜杠转义值中使用的单引号。表示数据的反斜杠可以但不必加倍；这遵循Perl的简单引用文字规则。请注意，按照与转义字符串常量相同的规则（请参阅&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS-ESCAPE&quot;&gt;第4.1.2.2节&lt;/a&gt;），引导扫描程序会将出现在数据中的反斜杠视为转义。例如 &lt;code&gt;\t&lt;/code&gt; 转换为制表符。如果您实际上想在最终值中使用反斜杠，则需要编写其中的四个：Perl剥离两个，剩下的 &lt;code&gt;\\&lt;/code&gt; 供引导扫描程序查看。</target>
        </trans-unit>
        <trans-unit id="b86517f687c2cdb1c2c9f1b4d883ebc3f627ec3f" translate="yes" xml:space="preserve">
          <source>All weather records belonging to Hayward are removed.</source>
          <target state="translated">所有属于海沃德的天气记录都被删除。</target>
        </trans-unit>
        <trans-unit id="ad7019350bb4e8cf04fe867a5271fe82db68f450" translate="yes" xml:space="preserve">
          <source>All work was done by Teodor Sigaev (&lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:teodor@sigaev.ru&quot;&gt;teodor@sigaev.ru&lt;/a&gt;&amp;gt;&lt;/code&gt;) and Oleg Bartunov (&lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:oleg@sai.msu.su&quot;&gt;oleg@sai.msu.su&lt;/a&gt;&amp;gt;&lt;/code&gt;). See &lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/&quot;&gt;http://www.sai.msu.su/~megera/postgres/gist/&lt;/a&gt; for additional information. Andrey Oktyabrski did a great work on adding new functions and operations.</source>
          <target state="translated">所有工作都是由Teodor Sigaev（ &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:teodor@sigaev.ru&quot;&gt;teodor@sigaev.ru&lt;/a&gt;&amp;gt;&lt;/code&gt; ）和Oleg Bartunov（ &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:oleg@sai.msu.su&quot;&gt;oleg@sai.msu.su&lt;/a&gt;&amp;gt;&lt;/code&gt; ）完成的。有关其他信息，请参见&lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/&quot;&gt;http://www.sai.msu.su/~megera/postgres/gist/&lt;/a&gt;。Andrey Oktyabrski在添加新功能和操作方面做得很棒。</target>
        </trans-unit>
        <trans-unit id="4288707b0efed23059331a4d938505610024687d" translate="yes" xml:space="preserve">
          <source>All work was done by Teodor Sigaev (&lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:teodor@stack.net&quot;&gt;teodor@stack.net&lt;/a&gt;&amp;gt;&lt;/code&gt;) and Oleg Bartunov (&lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:oleg@sai.msu.su&quot;&gt;oleg@sai.msu.su&lt;/a&gt;&amp;gt;&lt;/code&gt;). See &lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/&quot;&gt;http://www.sai.msu.su/~megera/postgres/gist/&lt;/a&gt; for additional information. Authors would like to thank Eugeny Rodichev for helpful discussions. Comments and bug reports are welcome.</source>
          <target state="translated">所有工作都是由Teodor Sigaev（ &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:teodor@stack.net&quot;&gt;teodor@stack.net&lt;/a&gt;&amp;gt;&lt;/code&gt; ）和Oleg Bartunov（ &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:oleg@sai.msu.su&quot;&gt;oleg@sai.msu.su&lt;/a&gt;&amp;gt;&lt;/code&gt; ）完成的。有关其他信息，请参见&lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/&quot;&gt;http://www.sai.msu.su/~megera/postgres/gist/&lt;/a&gt;。作者要感谢Eugeny Rodichev的有益讨论。欢迎发表评论和错误报告。</target>
        </trans-unit>
        <trans-unit id="f34719d5f269658e4173abae81da05904e2f90b4" translate="yes" xml:space="preserve">
          <source>Allow executing programs on the database server as the user the database runs as with COPY and other functions which allow executing a server-side program.</source>
          <target state="translated">允许以数据库运行的用户身份在数据库服务器上执行程序,如COPY等允许执行服务器端程序的功能。</target>
        </trans-unit>
        <trans-unit id="cb7c466538ce28419fa5a720e552c9faf281f480" translate="yes" xml:space="preserve">
          <source>Allow question mark as placeholder for compatibility reasons. This used to be the default long ago.</source>
          <target state="translated">由于兼容性的原因,允许将问号作为占位符。这在很久以前是默认的。</target>
        </trans-unit>
        <trans-unit id="45c4206b6f2ee2080c8508868577dbea292b358b" translate="yes" xml:space="preserve">
          <source>Allow reading files from any location the database can access on the server with COPY and other file-access functions.</source>
          <target state="translated">允许通过COPY和其他文件访问功能从服务器上数据库可以访问的任何位置读取文件。</target>
        </trans-unit>
        <trans-unit id="4f03ae30c79df36f9c350de6f69bb0b74ebd9a17" translate="yes" xml:space="preserve">
          <source>Allow the connection unconditionally. This method allows anyone that can connect to the PostgreSQL database server to login as any PostgreSQL user they wish, without the need for a password or any other authentication. See &lt;a href=&quot;auth-trust&quot;&gt;Section 20.4&lt;/a&gt; for details.</source>
          <target state="translated">无条件允许连接。此方法允许可以连接到PostgreSQL数据库服务器的任何人以他们希望的任何PostgreSQL用户身份登录，而无需密码或任何其他身份验证。有关详细信息，请参见&lt;a href=&quot;auth-trust&quot;&gt;第20.4节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="015b98532a3fe432082ea0986c77ac2b5c3dbd03" translate="yes" xml:space="preserve">
          <source>Allow writing to files in any location the database can access on the server with COPY and other file-access functions.</source>
          <target state="translated">允许通过COPY和其他文件访问功能对服务器上数据库可以访问的任何位置的文件进行写入。</target>
        </trans-unit>
        <trans-unit id="f8d71f61a1ee50e974ca597aaf1819fc96625f9e" translate="yes" xml:space="preserve">
          <source>Allowed Access</source>
          <target state="translated">允许访问</target>
        </trans-unit>
        <trans-unit id="76b9c247fd0d4d88ff31bffe6ae1c77fef7baa54" translate="yes" xml:space="preserve">
          <source>Allowed values of an enum parameter (null for non-enum values)</source>
          <target state="translated">一个枚举参数的允许值(非枚举值为空)。</target>
        </trans-unit>
        <trans-unit id="52773c9887de8a80602d4df5e04153e486ddd9ba" translate="yes" xml:space="preserve">
          <source>Allowed, but not in PG</source>
          <target state="translated">允许,但在PG中不允许</target>
        </trans-unit>
        <trans-unit id="70154177253445e1612a606653b6fcdbcd216626" translate="yes" xml:space="preserve">
          <source>Allows &lt;a href=&quot;sql-delete&quot;&gt;DELETE&lt;/a&gt; of a row from a table, view, etc. (In practice, any nontrivial &lt;code&gt;DELETE&lt;/code&gt; command will require &lt;code&gt;SELECT&lt;/code&gt; privilege as well, since it must reference table columns to determine which rows to delete.)</source>
          <target state="translated">允许从表，视图等中&lt;a href=&quot;sql-delete&quot;&gt;删除&lt;/a&gt;行。（实际上，任何非平凡的 &lt;code&gt;DELETE&lt;/code&gt; 命令也需要 &lt;code&gt;SELECT&lt;/code&gt; 特权，因为它必须引用表列以确定要删除的行。）</target>
        </trans-unit>
        <trans-unit id="892a331d54a97c6a90c5cbe15f359d1d4e9d66bd" translate="yes" xml:space="preserve">
          <source>Allows &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt; of a new row into a table, view, etc. Can be granted on specific column(s), in which case only those columns may be assigned to in the &lt;code&gt;INSERT&lt;/code&gt; command (other columns will therefore receive default values). Also allows use of &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; FROM.</source>
          <target state="translated">允许&lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt;一个新行的成表，视图，等。可以在特定列（一个或多个），在这种情况下，只有那些列可以在被分配给被授予 &lt;code&gt;INSERT&lt;/code&gt; 命令（其它列将因此接收默认值）。还允许使用&lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; FROM。</target>
        </trans-unit>
        <trans-unit id="91a5de46959e59448d7fbb7e22418ff9bdc9f1e0" translate="yes" xml:space="preserve">
          <source>Allows &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; from any column, or specific column(s), of a table, view, materialized view, or other table-like object. Also allows use of &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; TO. This privilege is also needed to reference existing column values in &lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;sql-delete&quot;&gt;DELETE&lt;/a&gt;. For sequences, this privilege also allows use of the &lt;code&gt;currval&lt;/code&gt; function. For large objects, this privilege allows the object to be read.</source>
          <target state="translated">允许从表，视图，实例化视图或其他类似表的对象的任何列或特定列中进行&lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;。还允许使用&lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; TO。引用&lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt;或&lt;a href=&quot;sql-delete&quot;&gt;DELETE中&lt;/a&gt;现有的列值也需要此特权。对于序列，此特权还允许使用 &lt;code&gt;currval&lt;/code&gt; 函数。对于大型对象，此特权允许读取对象。</target>
        </trans-unit>
        <trans-unit id="504fe161b61ac15d1f6a3f6705ae69c3e419baf8" translate="yes" xml:space="preserve">
          <source>Allows &lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt; on a table, view, etc.</source>
          <target state="translated">允许在表，视图等上执行&lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="82bfc74ea2d5fe544ab86144ec140977da660bfb" translate="yes" xml:space="preserve">
          <source>Allows &lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt; of any column, or specific column(s), of a table, view, etc. (In practice, any nontrivial &lt;code&gt;UPDATE&lt;/code&gt; command will require &lt;code&gt;SELECT&lt;/code&gt; privilege as well, since it must reference table columns to determine which rows to update, and/or to compute new values for columns.) &lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt; and &lt;code&gt;SELECT ... FOR SHARE&lt;/code&gt; also require this privilege on at least one column, in addition to the &lt;code&gt;SELECT&lt;/code&gt; privilege. For sequences, this privilege allows use of the &lt;code&gt;nextval&lt;/code&gt; and &lt;code&gt;setval&lt;/code&gt; functions. For large objects, this privilege allows writing or truncating the object.</source>
          <target state="translated">允许对表，视图等的任何列或特定列进行&lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt;。（实际上，任何非平凡的 &lt;code&gt;UPDATE&lt;/code&gt; 命令也将具有 &lt;code&gt;SELECT&lt;/code&gt; 特权，因为它必须引用表列来确定要更新的行，并且/或计算列的新值。） &lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt; 和 &lt;code&gt;SELECT ... FOR SHARE&lt;/code&gt; 除了 &lt;code&gt;SELECT&lt;/code&gt; 特权外，还对至少一列具有此特权。对于序列，此特权允许使用 &lt;code&gt;nextval&lt;/code&gt; 和 &lt;code&gt;setval&lt;/code&gt; 函数。对于大型对象，此特权允许写入或截断对象。</target>
        </trans-unit>
        <trans-unit id="8b7544659291101bf531ad89a7c0f68e28dd25e9" translate="yes" xml:space="preserve">
          <source>Allows calling a function or procedure, including use of any operators that are implemented on top of the function. This is the only type of privilege that is applicable to functions and procedures.</source>
          <target state="translated">允许调用函数或过程,包括使用在函数之上实现的任何运算符。这是唯一适用于函数和程序的特权类型。</target>
        </trans-unit>
        <trans-unit id="572f9c4ee818f964a8f341a7ab3b49d87de0de38" translate="yes" xml:space="preserve">
          <source>Allows creation of a foreign key constraint referencing a table, or specific column(s) of a table.</source>
          <target state="translated">允许创建一个引用表或表的特定列的外键约束。</target>
        </trans-unit>
        <trans-unit id="3f1fc4350d1383af032d326e29b30797181bb0ee" translate="yes" xml:space="preserve">
          <source>Allows creation of a trigger on a table, view, etc.</source>
          <target state="translated">允许在表、视图等上创建一个触发器。</target>
        </trans-unit>
        <trans-unit id="d221a1c104e0d63607ae68533525fac6cb3d90ab" translate="yes" xml:space="preserve">
          <source>Allows definition of user-visible parameters that control operator class behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cd1d90a2a8e348dc3397a5abdad6812b9706afc" translate="yes" xml:space="preserve">
          <source>Allows for mapping between system and database user names. See &lt;a href=&quot;auth-username-maps&quot;&gt;Section 20.2&lt;/a&gt; for details.</source>
          <target state="translated">允许在系统和数据库用户名之间进行映射。有关详细信息，请参见&lt;a href=&quot;auth-username-maps&quot;&gt;第20.2节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="62730a57186fa6b4b57c86a98eed1f6819a0f0da" translate="yes" xml:space="preserve">
          <source>Allows for mapping between system and database user names. See &lt;a href=&quot;auth-username-maps&quot;&gt;Section 20.2&lt;/a&gt; for details. For a GSSAPI/Kerberos principal, such as &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; (or, less commonly, &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt;), the user name used for mapping is &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; (or &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt;, respectively), unless &lt;code&gt;include_realm&lt;/code&gt; has been set to 0, in which case &lt;code&gt;username&lt;/code&gt; (or &lt;code&gt;username/hostbased&lt;/code&gt;) is what is seen as the system user name when mapping.</source>
          <target state="translated">允许在系统用户名和数据库用户名之间进行映射。有关详细信息，请参见&lt;a href=&quot;auth-username-maps&quot;&gt;第20.2节&lt;/a&gt;。对于GSSAPI / Kerberos主体，例如 &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; （或更不常见的是 &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt; ），用于映射的用户名是 &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; （或 &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt; )。），除非 &lt;code&gt;include_realm&lt;/code&gt; 设置为0 ，否则在映射时， &lt;code&gt;username&lt;/code&gt; （或 &lt;code&gt;username/hostbased&lt;/code&gt; ）被视为系统用户名。</target>
        </trans-unit>
        <trans-unit id="3a8e3ba433eb210e869a35f227d0944a825933f7" translate="yes" xml:space="preserve">
          <source>Allows for mapping between system and database user names. See &lt;a href=&quot;auth-username-maps&quot;&gt;Section 20.2&lt;/a&gt; for details. For a SSPI/Kerberos principal, such as &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; (or, less commonly, &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt;), the user name used for mapping is &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; (or &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt;, respectively), unless &lt;code&gt;include_realm&lt;/code&gt; has been set to 0, in which case &lt;code&gt;username&lt;/code&gt; (or &lt;code&gt;username/hostbased&lt;/code&gt;) is what is seen as the system user name when mapping.</source>
          <target state="translated">允许在系统用户名和数据库用户名之间进行映射。有关详细信息，请参见&lt;a href=&quot;auth-username-maps&quot;&gt;第20.2节&lt;/a&gt;。对于SSPI / Kerberos主体，例如 &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; （或更不常见的是 &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt; ），用于映射的用户名是 &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; （或 &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt; )。分别），除非 &lt;code&gt;include_realm&lt;/code&gt; 设置为0 ，否则在映射时， &lt;code&gt;username&lt;/code&gt; （或 &lt;code&gt;username/hostbased&lt;/code&gt; ）就是系统用户名。</target>
        </trans-unit>
        <trans-unit id="20552df65c50fc0052b6d2499b3762b86d6eff44" translate="yes" xml:space="preserve">
          <source>Allows modification of the structure of system tables as well as certain other risky actions on system tables. This is otherwise not allowed even for superusers. Ill-advised use of this setting can cause irretrievable data loss or seriously corrupt the database system. Only superusers can change this setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b64278e6ff1ecca0c4404ebfb33c1f4ece933ea1" translate="yes" xml:space="preserve">
          <source>Allows modification of the structure of system tables. This is used by &lt;code&gt;initdb&lt;/code&gt;. This parameter can only be set at server start.</source>
          <target state="translated">允许修改系统表的结构。由 &lt;code&gt;initdb&lt;/code&gt; 使用。该参数只能在服务器启动时设置。</target>
        </trans-unit>
        <trans-unit id="f71053472aff6714ed79ad6bf71416990ec41156" translate="yes" xml:space="preserve">
          <source>Allows multiple master servers</source>
          <target state="translated">允许多个主服务器</target>
        </trans-unit>
        <trans-unit id="7e9d5d5ab57892df439ee070a4596c150e6f73e7" translate="yes" xml:space="preserve">
          <source>Allows remote clients to connect via TCP/IP (Internet domain) connections. Without this option, only local connections are accepted. This option is equivalent to setting &lt;code&gt;listen_addresses&lt;/code&gt; to &lt;code&gt;*&lt;/code&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt; or via &lt;code&gt;-h&lt;/code&gt;.</source>
          <target state="translated">允许远程客户端通过TCP / IP（Internet域）连接进行连接。如果没有此选项，则仅接受本地连接。此选项等效于在 &lt;code&gt;postgresql.conf&lt;/code&gt; 中或通过 &lt;code&gt;-h&lt;/code&gt; 将 &lt;code&gt;listen_addresses&lt;/code&gt; 设置为 &lt;code&gt;*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="003e89305b8189195bfe70e6a4f7ecd0e58a566e" translate="yes" xml:space="preserve">
          <source>Allows sampling the duration of completed statements that ran for at least the specified amount of time. This produces the same kind of log entries as &lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-DURATION-STATEMENT&quot;&gt;log_min_duration_statement&lt;/a&gt;, but only for a subset of the executed statements, with sample rate controlled by &lt;a href=&quot;runtime-config-logging#GUC-LOG-STATEMENT-SAMPLE-RATE&quot;&gt;log_statement_sample_rate&lt;/a&gt;. For example, if you set it to &lt;code&gt;100ms&lt;/code&gt; then all SQL statements that run 100ms or longer will be considered for sampling. Enabling this parameter can be helpful when the traffic is too high to log all queries. If this value is specified without units, it is taken as milliseconds. Setting this to zero samples all statement durations. &lt;code&gt;-1&lt;/code&gt; (the default) disables sampling statement durations. Only superusers can change this setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63eeac10a55f83f249e5c5462559d1f7da0f93f8" translate="yes" xml:space="preserve">
          <source>Allows temporary tables to be created while using the database.</source>
          <target state="translated">允许在使用数据库时创建临时表。</target>
        </trans-unit>
        <trans-unit id="08e9a64b986b6e59ae70cdec6ed43f46a0d1ac74" translate="yes" xml:space="preserve">
          <source>Allows the grantee to connect to the database. This privilege is checked at connection startup (in addition to checking any restrictions imposed by &lt;code&gt;pg_hba.conf&lt;/code&gt;).</source>
          <target state="translated">允许被授权者连接到数据库。在连接启动时检查此特权（除了检查 &lt;code&gt;pg_hba.conf&lt;/code&gt; 施加的任何限制）。</target>
        </trans-unit>
        <trans-unit id="755cae42faeb86185341cbd11d37dba18dac7fda" translate="yes" xml:space="preserve">
          <source>Allows the leader process to execute the query plan under &lt;code&gt;Gather&lt;/code&gt; and &lt;code&gt;Gather Merge&lt;/code&gt; nodes instead of waiting for worker processes. The default is &lt;code&gt;on&lt;/code&gt;. Setting this value to &lt;code&gt;off&lt;/code&gt; reduces the likelihood that workers will become blocked because the leader is not reading tuples fast enough, but requires the leader process to wait for worker processes to start up before the first tuples can be produced. The degree to which the leader can help or hinder performance depends on the plan type, number of workers and query duration.</source>
          <target state="translated">允许领导者进程在&amp;ldquo; &lt;code&gt;Gather&lt;/code&gt; 和&amp;ldquo; &lt;code&gt;Gather Merge&lt;/code&gt; 节点下执行查询计划，而不是等待工作进程。默认值为 &lt;code&gt;on&lt;/code&gt; 。将此值设置为 &lt;code&gt;off&lt;/code&gt; 可以减少由于领导者没有足够快地读取元组而导致工作人员被阻塞的可能性，但是要求领导者进程等待工作者进程启动才能生成第一个元组。领导者可以帮助或阻碍绩效的程度取决于计划类型，工作人员数量和查询持续时间。</target>
        </trans-unit>
        <trans-unit id="65de6c1d93f488d023688afb5ecd9e64a2816fb2" translate="yes" xml:space="preserve">
          <source>Allows the structure of system tables to be modified. This is used by &lt;code&gt;initdb&lt;/code&gt;.</source>
          <target state="translated">允许修改系统表的结构。由 &lt;code&gt;initdb&lt;/code&gt; 使用。</target>
        </trans-unit>
        <trans-unit id="eb3d21c22361245b017a84ef20398543e1812a86" translate="yes" xml:space="preserve">
          <source>Allows the use of parallel queries for testing purposes even in cases where no performance benefit is expected. The allowed values of &lt;code&gt;force_parallel_mode&lt;/code&gt; are &lt;code&gt;off&lt;/code&gt; (use parallel mode only when it is expected to improve performance), &lt;code&gt;on&lt;/code&gt; (force parallel query for all queries for which it is thought to be safe), and &lt;code&gt;regress&lt;/code&gt; (like &lt;code&gt;on&lt;/code&gt;, but with additional behavior changes as explained below).</source>
          <target state="translated">允许将并行查询用于测试目的，即使在预期不会带来性能收益的情况下也是如此。的允许值 &lt;code&gt;force_parallel_mode&lt;/code&gt; 是 &lt;code&gt;off&lt;/code&gt; （使用并行模式下，只有当它有望提高性能）， &lt;code&gt;on&lt;/code&gt; （力并行查询，以供其被认为是安全的所有查询），并 &lt;code&gt;regress&lt;/code&gt; （像 &lt;code&gt;on&lt;/code&gt; ，但额外的行为改变如下所述）。</target>
        </trans-unit>
        <trans-unit id="8f83e0d9b7de16d5d69bb100f20671e8c51dd641" translate="yes" xml:space="preserve">
          <source>Allows users in the same group as the cluster owner to read all cluster files created by &lt;code&gt;initdb&lt;/code&gt;. This option is ignored on Windows as it does not support POSIX-style group permissions.</source>
          <target state="translated">允许与集群所有者在同一组中的用户读取 &lt;code&gt;initdb&lt;/code&gt; 创建的所有集群文件。在Windows上，此选项将被忽略，因为它不支持POSIX样式的组权限。</target>
        </trans-unit>
        <trans-unit id="4cc45bc94d25b1e0d694fb6d8a93df9410ca68c9" translate="yes" xml:space="preserve">
          <source>Almost all &lt;code&gt;DROP&lt;/code&gt; commands in PostgreSQL support specifying &lt;code&gt;CASCADE&lt;/code&gt;. Of course, the nature of the possible dependencies varies with the type of the object. You can also write &lt;code&gt;RESTRICT&lt;/code&gt; instead of &lt;code&gt;CASCADE&lt;/code&gt; to get the default behavior, which is to prevent dropping objects that any other objects depend on.</source>
          <target state="translated">PostgreSQL中几乎所有的 &lt;code&gt;DROP&lt;/code&gt; 命令都支持指定 &lt;code&gt;CASCADE&lt;/code&gt; 。当然，可能的依赖关系的性质随对象的类型而变化。您还可以编写 &lt;code&gt;RESTRICT&lt;/code&gt; 而不是 &lt;code&gt;CASCADE&lt;/code&gt; 以获得默认行为，这是为了防止丢弃任何其他对象所依赖的对象。</target>
        </trans-unit>
        <trans-unit id="328cfccc1cde2a65060e2ec7ece0e64b0b2e4b32" translate="yes" xml:space="preserve">
          <source>Also be careful when making up test data, which is often unavoidable when the application is not yet in production. Values that are very similar, completely random, or inserted in sorted order will skew the statistics away from the distribution that real data would have.</source>
          <target state="translated">在编造测试数据时也要小心,当应用程序还未投入生产时,这往往是不可避免的。非常相似的值、完全随机的值或按排序插入的值会使统计数据偏离真实数据的分布。</target>
        </trans-unit>
        <trans-unit id="1e6eb3c256a63ce7e1a4b490a67bfd7124a09fa5" translate="yes" xml:space="preserve">
          <source>Also calculate statistics for use by the optimizer.</source>
          <target state="translated">同时计算统计数据,供优化器使用。</target>
        </trans-unit>
        <trans-unit id="1310f648148c138c431f0390dd1598c9ea4cf18b" translate="yes" xml:space="preserve">
          <source>Also known as &lt;em&gt;WAL segment&lt;/em&gt; or &lt;em&gt;WAL segment file&lt;/em&gt;. Each of the sequentially-numbered files that provide storage space for &lt;a href=&quot;glossary#GLOSSARY-WAL&quot;&gt;WAL&lt;/a&gt;. The files are all of the same predefined size and are written in sequential order, interspersing changes as they occur in multiple simultaneous sessions. If the system crashes, the files are read in order, and each of the changes is replayed to restore the system to the state it was in before the crash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f5b262e2738c5ae943ae295de4ef09eb42b98a8" translate="yes" xml:space="preserve">
          <source>Also note that some element types, such as &lt;code&gt;timestamp&lt;/code&gt;, have a notion of &quot;infinity&quot;, which is just another value that can be stored. This is different from &lt;code&gt;MINVALUE&lt;/code&gt; and &lt;code&gt;MAXVALUE&lt;/code&gt;, which are not real values that can be stored, but rather they are ways of saying that the value is unbounded. &lt;code&gt;MAXVALUE&lt;/code&gt; can be thought of as being greater than any other value, including &quot;infinity&quot; and &lt;code&gt;MINVALUE&lt;/code&gt; as being less than any other value, including &quot;minus infinity&quot;. Thus the range &lt;code&gt;FROM ('infinity') TO (MAXVALUE)&lt;/code&gt; is not an empty range; it allows precisely one value to be stored &amp;mdash; &quot;infinity&quot;.</source>
          <target state="translated">还要注意，某些元素类型（例如 &lt;code&gt;timestamp&lt;/code&gt; ）具有&amp;ldquo;无限&amp;rdquo;的概念，这只是可以存储的另一个值。这不同于 &lt;code&gt;MINVALUE&lt;/code&gt; 和 &lt;code&gt;MAXVALUE&lt;/code&gt; ，后者不是可以存储的实数值，而是它们用来表示该值是无界的。可以认为 &lt;code&gt;MAXVALUE&lt;/code&gt; 大于任何其他值，包括&amp;ldquo;无穷大&amp;rdquo;，而 &lt;code&gt;MINVALUE&lt;/code&gt; 小于任何其他值，包括&amp;ldquo;负无穷大&amp;rdquo;。因此， &lt;code&gt;FROM ('infinity') TO (MAXVALUE)&lt;/code&gt; 的范围不是空范围；它只允许存储一个值-&amp;ldquo;无穷大&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="7722ff63b95d490d6107aefdee57299789fdc839" translate="yes" xml:space="preserve">
          <source>Also of note to those converting from other environments is the fact that &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; does not ensure that a concurrent transaction will not update or delete a selected row. To do that in PostgreSQL you must actually update the row, even if no values need to be changed. &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt;&lt;em&gt;temporarily blocks&lt;/em&gt; other transactions from acquiring the same lock or executing an &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; which would affect the locked row, but once the transaction holding this lock commits or rolls back, a blocked transaction will proceed with the conflicting operation unless an actual &lt;code&gt;UPDATE&lt;/code&gt; of the row was performed while the lock was held.</source>
          <target state="translated">对于那些从其他环境进行转换的人，还要注意的是 &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 不能确保并发事务不会更新或删除所选行。为此，即使不需要更改任何值，您也必须实际上更新该行。 &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; &lt;em&gt;暂时阻止&lt;/em&gt;其他事务获取相同的锁或执行会影响锁定行的 &lt;code&gt;UPDATE&lt;/code&gt; 或 &lt;code&gt;DELETE&lt;/code&gt; ，但是一旦持有此锁的事务提交或回滚，除非进行实际的 &lt;code&gt;UPDATE&lt;/code&gt; ,否则被阻塞的事务将继续执行冲突操作。持有锁时执行了该行的。</target>
        </trans-unit>
        <trans-unit id="89140b7833f6956c6f82e686c2158ff1b251e443" translate="yes" xml:space="preserve">
          <source>Also see the prefix operator &lt;code&gt;^@&lt;/code&gt; and corresponding &lt;code&gt;starts_with&lt;/code&gt; function, which are useful in cases where simply matching the beginning of a string is needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43ae5053feb0121ca9119b68bf8c270c3a3bfe40" translate="yes" xml:space="preserve">
          <source>Also unlike &lt;code&gt;INHERITS&lt;/code&gt;, columns and constraints copied by &lt;code&gt;LIKE&lt;/code&gt; are not merged with similarly named columns and constraints. If the same name is specified explicitly or in another &lt;code&gt;LIKE&lt;/code&gt; clause, an error is signaled.</source>
          <target state="translated">同样与 &lt;code&gt;INHERITS&lt;/code&gt; 不同， &lt;code&gt;LIKE&lt;/code&gt; 复制的列和约束不会与名称相似的列和约束合并。如果显式指定了相同的名称，或者在另一个 &lt;code&gt;LIKE&lt;/code&gt; 子句中指定了相同的名称，则将指示错误。</target>
        </trans-unit>
        <trans-unit id="4bd7db918c0ec048fb1da60e94aef9f53bffd77b" translate="yes" xml:space="preserve">
          <source>Also you can use an index on the &lt;code&gt;t&lt;/code&gt; column for word similarity or strict word similarity. Typical queries are:</source>
          <target state="translated">您也可以使用 &lt;code&gt;t&lt;/code&gt; 列上的索引来实现单词相似性或严格单词相似性。典型的查询是：</target>
        </trans-unit>
        <trans-unit id="d4ce61ad95c8576f718ac10e1c2327127884475a" translate="yes" xml:space="preserve">
          <source>Also you can use the standard SQL syntax &lt;code&gt;SET NAMES&lt;/code&gt; for this purpose:</source>
          <target state="translated">您也可以为此使用标准的SQL语法 &lt;code&gt;SET NAMES&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a6c555a30398b57943351e6fa4960aad56c86fc4" translate="yes" xml:space="preserve">
          <source>Also, &lt;code&gt;*&lt;/code&gt; can be attached to a lexeme to specify prefix matching:</source>
          <target state="translated">此外， &lt;code&gt;*&lt;/code&gt; 可以附加到词素上以指定前缀匹配：</target>
        </trans-unit>
        <trans-unit id="9a92606f5ea158e9240f422542ed2e1cf20e61fc" translate="yes" xml:space="preserve">
          <source>Also, GIN index supports &lt;code&gt;@@&lt;/code&gt; and &lt;code&gt;@?&lt;/code&gt; operators, which perform &lt;code&gt;jsonpath&lt;/code&gt; matching.</source>
          <target state="translated">另外，GIN索引支持 &lt;code&gt;@@&lt;/code&gt; 和 &lt;code&gt;@?&lt;/code&gt; 运算符，它们执行 &lt;code&gt;jsonpath&lt;/code&gt; 匹配。</target>
        </trans-unit>
        <trans-unit id="33ec741b0c71e2493174674607bdd7cee851a3f4" translate="yes" xml:space="preserve">
          <source>Also, a reverse lookup is necessary to implement the suffix matching feature, because the actual client host name needs to be known in order to match it against the pattern.</source>
          <target state="translated">同时,为了实现后缀匹配功能,还需要进行反向查找,因为需要知道实际的客户主机名才能与模式进行匹配。</target>
        </trans-unit>
        <trans-unit id="dbee7ce8bd2c9aaff2ced252585c86f91ebda134" translate="yes" xml:space="preserve">
          <source>Also, a trigger definition can specify a Boolean &lt;code&gt;WHEN&lt;/code&gt; condition, which will be tested to see whether the trigger should be fired. In row-level triggers the &lt;code&gt;WHEN&lt;/code&gt; condition can examine the old and/or new values of columns of the row. Statement-level triggers can also have &lt;code&gt;WHEN&lt;/code&gt; conditions, although the feature is not so useful for them since the condition cannot refer to any values in the table.</source>
          <target state="translated">另外，触发器定义可以指定布尔 &lt;code&gt;WHEN&lt;/code&gt; 条件，将对其进行测试以查看是否应触发触发器。在行级触发器中， &lt;code&gt;WHEN&lt;/code&gt; 条件可以检查该行的列的旧值和/或新值。语句级触发器也可以具有 &lt;code&gt;WHEN&lt;/code&gt; 条件，尽管该功能对它们没有太大用处，因为条件不能引用表中的任何值。</target>
        </trans-unit>
        <trans-unit id="51c091c0aef22b8b4cc2fa3614299c508ab0362c" translate="yes" xml:space="preserve">
          <source>Also, by default there is limited information available about the selectivity of functions. However, if you create an expression index that uses a function call, useful statistics will be gathered about the function, which can greatly improve query plans that use the expression index.</source>
          <target state="translated">另外,默认情况下,关于函数的选择性的信息有限。但是,如果创建一个使用函数调用的表达式索引,就会收集到关于函数的有用统计数据,这可以大大改善使用表达式索引的查询计划。</target>
        </trans-unit>
        <trans-unit id="918098440d0526280449d26ec531d4e4ea959670" translate="yes" xml:space="preserve">
          <source>Also, for B-tree indexes, a freshly-constructed index is slightly faster to access than one that has been updated many times because logically adjacent pages are usually also physically adjacent in a newly built index. (This consideration does not apply to non-B-tree indexes.) It might be worthwhile to reindex periodically just to improve access speed.</source>
          <target state="translated">另外,对于B树索引来说,新构建的索引比已经更新过多次的索引访问速度稍快,因为在新构建的索引中,逻辑上相邻的页面通常也是物理上相邻的。(这个考虑不适用于非B树索引。)为了提高访问速度,定期重新编制索引可能是值得的。</target>
        </trans-unit>
        <trans-unit id="be3a3382ab5cfef83a6b9ee1e118c05d47eb696d" translate="yes" xml:space="preserve">
          <source>Also, for data types for which there is a natural distance metric, &lt;code&gt;btree_gist&lt;/code&gt; defines a distance operator &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt;, and provides GiST index support for nearest-neighbor searches using this operator. Distance operators are provided for &lt;code&gt;int2&lt;/code&gt;, &lt;code&gt;int4&lt;/code&gt;, &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;float4&lt;/code&gt;, &lt;code&gt;float8&lt;/code&gt;, &lt;code&gt;timestamp with time zone&lt;/code&gt;, &lt;code&gt;timestamp without time zone&lt;/code&gt;, &lt;code&gt;time without time zone&lt;/code&gt;, &lt;code&gt;date&lt;/code&gt;, &lt;code&gt;interval&lt;/code&gt;, &lt;code&gt;oid&lt;/code&gt;, and &lt;code&gt;money&lt;/code&gt;.</source>
          <target state="translated">同样，对于具有自然距离度量的数据类型， &lt;code&gt;btree_gist&lt;/code&gt; 定义距离运算符 &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; ，并为使用该运算符的最近邻居搜索提供GiST索引支持。提供远程运营商 &lt;code&gt;int2&lt;/code&gt; ， &lt;code&gt;int4&lt;/code&gt; ， &lt;code&gt;int8&lt;/code&gt; ， &lt;code&gt;float4&lt;/code&gt; 变量， &lt;code&gt;float8&lt;/code&gt; ， &lt;code&gt;timestamp with time zone&lt;/code&gt; ， &lt;code&gt;timestamp without time zone&lt;/code&gt; ， &lt;code&gt;time without time zone&lt;/code&gt; ， &lt;code&gt;date&lt;/code&gt; ， &lt;code&gt;interval&lt;/code&gt; ， &lt;code&gt;oid&lt;/code&gt; ，和 &lt;code&gt;money&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf0cd04ab9ab1bc3d1ec06d42e614cb3d497974a" translate="yes" xml:space="preserve">
          <source>Also, if you are using prepared transactions, the &lt;code&gt;virtualtransaction&lt;/code&gt; column can be joined to the &lt;code&gt;transaction&lt;/code&gt; column of the &lt;a href=&quot;view-pg-prepared-xacts&quot;&gt;&lt;code&gt;pg_prepared_xacts&lt;/code&gt;&lt;/a&gt; view to get more information on prepared transactions that hold locks. (A prepared transaction can never be waiting for a lock, but it continues to hold the locks it acquired while running.) For example:</source>
          <target state="translated">另外，如果您使用的是预备事务，则可以将 &lt;code&gt;virtualtransaction&lt;/code&gt; 列与&lt;a href=&quot;view-pg-prepared-xacts&quot;&gt; &lt;code&gt;pg_prepared_xacts&lt;/code&gt; &lt;/a&gt;视图的 &lt;code&gt;transaction&lt;/code&gt; 列连接，以获取有关持有锁的预备事务的更多信息。（一个准备好的事务永远不能等待锁，但是它将继续保持它在运行时获取的锁。）例如：</target>
        </trans-unit>
        <trans-unit id="2258b90b04fd050fcb19ba25fa34dc828faad6f7" translate="yes" xml:space="preserve">
          <source>Also, lexemes in a &lt;code&gt;tsquery&lt;/code&gt; can be labeled with &lt;code&gt;*&lt;/code&gt; to specify prefix matching:</source>
          <target state="translated">此外， &lt;code&gt;tsquery&lt;/code&gt; 中的词素可以用 &lt;code&gt;*&lt;/code&gt; 标记以指定前缀匹配：</target>
        </trans-unit>
        <trans-unit id="d1e5125c3a43842c6c788a2be18af72f0169e16b" translate="yes" xml:space="preserve">
          <source>Also, since &lt;code&gt;myschema&lt;/code&gt; is the first element in the path, new objects would by default be created in it.</source>
          <target state="translated">另外，由于 &lt;code&gt;myschema&lt;/code&gt; 是路径中的第一个元素，因此默认情况下将在其中创建新对象。</target>
        </trans-unit>
        <trans-unit id="706af9f63feb30c802747e00ad8bdfe7aa3a186c" translate="yes" xml:space="preserve">
          <source>Also, some element types have a notion of &amp;ldquo;infinity&amp;rdquo;, but that is just another value so far as the range type mechanisms are concerned. For example, in timestamp ranges, &lt;code&gt;[today,]&lt;/code&gt; means the same thing as &lt;code&gt;[today,)&lt;/code&gt;. But &lt;code&gt;[today,infinity]&lt;/code&gt; means something different from &lt;code&gt;[today,infinity)&lt;/code&gt; &amp;mdash; the latter excludes the special &lt;code&gt;timestamp&lt;/code&gt; value &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">同样，某些元素类型具有&amp;ldquo;无穷大&amp;rdquo;的概念，但是就范围类型机制而言，这只是另一个值。例如，在时间戳范围内， &lt;code&gt;[today,]&lt;/code&gt; 与 &lt;code&gt;[today,)&lt;/code&gt; 含义相同。但是 &lt;code&gt;[today,infinity]&lt;/code&gt; 的含义不同于 &lt;code&gt;[today,infinity)&lt;/code&gt; -后者不包括特殊的 &lt;code&gt;timestamp&lt;/code&gt; 值 &lt;code&gt;infinity&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00fb5de01709ab2f402939d3439d7bfb11e30b51" translate="yes" xml:space="preserve">
          <source>Also, system catalogs may contain rows with &lt;code&gt;xmin&lt;/code&gt; equal to &lt;code&gt;BootstrapTransactionId&lt;/code&gt; (1), indicating that they were inserted during the first phase of initdb. Like &lt;code&gt;FrozenTransactionId&lt;/code&gt;, this special XID is treated as older than every normal XID.</source>
          <target state="translated">同样，系统目录可能包含 &lt;code&gt;xmin&lt;/code&gt; 等于 &lt;code&gt;BootstrapTransactionId&lt;/code&gt; （1）的行，表明它们是在initdb的第一阶段插入的。像 &lt;code&gt;FrozenTransactionId&lt;/code&gt; 一样，此特殊XID被视为比每个普通XID都旧。</target>
        </trans-unit>
        <trans-unit id="93ed94df22ab24f81f04b111c95a216ff81d38c0" translate="yes" xml:space="preserve">
          <source>Also, the Unicode escape syntax for string constants only works when the configuration parameter &lt;a href=&quot;runtime-config-compatible#GUC-STANDARD-CONFORMING-STRINGS&quot;&gt;standard_conforming_strings&lt;/a&gt; is turned on. This is because otherwise this syntax could confuse clients that parse the SQL statements to the point that it could lead to SQL injections and similar security issues. If the parameter is set to off, this syntax will be rejected with an error message.</source>
          <target state="translated">同样，仅在打开配置参数&lt;a href=&quot;runtime-config-compatible#GUC-STANDARD-CONFORMING-STRINGS&quot;&gt;standard_conforming_strings&lt;/a&gt;时，字符串常量的Unicode转义语法才起作用。这是因为否则该语法可能会使解析SQL语句的客户端感到困惑，以至于可能导致SQL注入和类似的安全问题。如果参数设置为off，则此语法将被拒绝并显示一条错误消息。</target>
        </trans-unit>
        <trans-unit id="58147b7f84be2ece7907815ce52ec7ae85d6c7bf" translate="yes" xml:space="preserve">
          <source>Also, there is no concept of a &lt;code&gt;public&lt;/code&gt; schema in the SQL standard. For maximum conformance to the standard, you should not use the &lt;code&gt;public&lt;/code&gt; schema.</source>
          <target state="translated">另外，SQL标准中没有 &lt;code&gt;public&lt;/code&gt; 模式的概念。为了最大程度地符合标准，您不应使用 &lt;code&gt;public&lt;/code&gt; 架构。</target>
        </trans-unit>
        <trans-unit id="e584a70e0fd9b688e02349b1f5470dd3aa568b45" translate="yes" xml:space="preserve">
          <source>Also, these output format options can be set for just one query by using &lt;code&gt;\g&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cae58275d441413bb378869b203fcfca0525ccf0" translate="yes" xml:space="preserve">
          <source>Also, unlike a regular &lt;code&gt;Append&lt;/code&gt; node, which can only have partial children when used within a parallel plan, a &lt;code&gt;Parallel Append&lt;/code&gt; node can have both partial and non-partial child plans. Non-partial children will be scanned by only a single process, since scanning them more than once would produce duplicate results. Plans that involve appending multiple results sets can therefore achieve coarse-grained parallelism even when efficient partial plans are not available. For example, consider a query against a partitioned table which can be only be implemented efficiently by using an index that does not support parallel scans. The planner might choose a &lt;code&gt;Parallel Append&lt;/code&gt; of regular &lt;code&gt;Index Scan&lt;/code&gt; plans; each individual index scan would have to be executed to completion by a single process, but different scans could be performed at the same time by different processes.</source>
          <target state="translated">同样，与常规 &lt;code&gt;Append&lt;/code&gt; 节点不同，常规追加节点在并行计划中使用时只能具有部分子项，而 &lt;code&gt;Parallel Append&lt;/code&gt; 节点可以同时具有部分和非部分子计划。非部分孩子只能通过一个过程进行扫描，因为多次扫描它们会产生重复的结果。因此，即使没有有效的局部计划，涉及附加多个结果集的计划也可以实现粗粒度的并行性。例如，考虑针对分区表的查询，该查询只能通过使用不支持并行扫描的索引来有效地实现。计划者可以选择定期 &lt;code&gt;Index Scan&lt;/code&gt; 的 &lt;code&gt;Parallel Append&lt;/code&gt; 计划; 每个单独的索引扫描都必须由单个进程执行才能完成，但是不同的进程可以同时执行不同的扫描。</target>
        </trans-unit>
        <trans-unit id="b84c371dd525a0259c19e76190985b0466e52c07" translate="yes" xml:space="preserve">
          <source>Also, unlike a regular &lt;code&gt;Append&lt;/code&gt; node, which can only have partial children when used within a parallel plan, a &lt;code&gt;Parallel Append&lt;/code&gt; node can have both partial and non-partial child plans. Non-partial children will be scanned by only a single process, since scanning them more than once would produce duplicate results. Plans that involve appending multiple results sets can therefore achieve coarse-grained parallelism even when efficient partial plans are not available. For example, consider a query against a partitioned table which can only be implemented efficiently by using an index that does not support parallel scans. The planner might choose a &lt;code&gt;Parallel Append&lt;/code&gt; of regular &lt;code&gt;Index Scan&lt;/code&gt; plans; each individual index scan would have to be executed to completion by a single process, but different scans could be performed at the same time by different processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e805152c6a1ae1d9757b9c8152236b48ab4b4867" translate="yes" xml:space="preserve">
          <source>Also, you can force a segment switch manually with &lt;code&gt;pg_switch_wal&lt;/code&gt; if you want to ensure that a just-finished transaction is archived as soon as possible. Other utility functions related to WAL management are listed in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;Table 9.84&lt;/a&gt;.</source>
          <target state="translated">另外，如果您要确保尽快完成刚刚完成的交易，则可以使用 &lt;code&gt;pg_switch_wal&lt;/code&gt; 手动强制分段切换。&lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;表9.84&lt;/a&gt;列出了与WAL管理有关的其他实用程序功能。</target>
        </trans-unit>
        <trans-unit id="68eb2f93808c112d45a946f93f2d0964eca95823" translate="yes" xml:space="preserve">
          <source>Also, you can force a segment switch manually with &lt;code&gt;pg_switch_wal&lt;/code&gt; if you want to ensure that a just-finished transaction is archived as soon as possible. Other utility functions related to WAL management are listed in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;Table 9.85&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfbace446db7c85291e8910dc869f82f6687c559" translate="yes" xml:space="preserve">
          <source>Also, you can write several possibly-modified labels separated with &lt;code&gt;|&lt;/code&gt; (OR) to match any of those labels, and you can put &lt;code&gt;!&lt;/code&gt; (NOT) at the start to match any label that doesn't match any of the alternatives.</source>
          <target state="translated">另外，您可以编写多个可能的已修改标签，并用 &lt;code&gt;|&lt;/code&gt; 分隔。（OR）来匹配任何这些标签，然后您可以输入 &lt;code&gt;!&lt;/code&gt; （NOT）开头，以匹配与任何其他选项都不匹配的任何标签。</target>
        </trans-unit>
        <trans-unit id="71f210fdceeda15fb7f9067d7b92e4afb40e583b" translate="yes" xml:space="preserve">
          <source>Also, you can write several possibly-modified non-star items separated with &lt;code&gt;|&lt;/code&gt; (OR) to match any of those items, and you can put &lt;code&gt;!&lt;/code&gt; (NOT) at the start of a non-star group to match any label that doesn't match any of the alternatives. A quantifier, if any, goes at the end of the group; it means some number of matches for the group as a whole (that is, some number of labels matching or not matching any of the alternatives).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b36099e7952ab489f13b56454238da5e639dbc6" translate="yes" xml:space="preserve">
          <source>Alter server &lt;code&gt;foo&lt;/code&gt;, add connection options:</source>
          <target state="translated">更改服务器 &lt;code&gt;foo&lt;/code&gt; ，添加连接选项：</target>
        </trans-unit>
        <trans-unit id="a729ebcf94a23a3c93f6e08f02b494c47b57ffb8" translate="yes" xml:space="preserve">
          <source>Alter server &lt;code&gt;foo&lt;/code&gt;, change version, change &lt;code&gt;host&lt;/code&gt; option:</source>
          <target state="translated">更改服务器 &lt;code&gt;foo&lt;/code&gt; ，更改版本，更改 &lt;code&gt;host&lt;/code&gt; 选项：</target>
        </trans-unit>
        <trans-unit id="530e5f9a6ec30da1a641c6dc46a96ff1039a1901" translate="yes" xml:space="preserve">
          <source>Alter the current session user instead of an explicitly identified role.</source>
          <target state="translated">改变当前会话用户,而不是明确指定的角色。</target>
        </trans-unit>
        <trans-unit id="7d634d2fd0bd3ab5f5b0921201011f77ef8d5f96" translate="yes" xml:space="preserve">
          <source>Alter the current user instead of an explicitly identified role.</source>
          <target state="translated">改变当前用户,而不是一个明确的角色。</target>
        </trans-unit>
        <trans-unit id="2e8aee10a5d127f616d1a417fe30c8e06fd3852f" translate="yes" xml:space="preserve">
          <source>Alternative Method for Log Shipping</source>
          <target state="translated">原木运输的替代方法</target>
        </trans-unit>
        <trans-unit id="8cd965c3bba9ba8b09a134d95e9a1fe544bc4537" translate="yes" xml:space="preserve">
          <source>Alternative location for the command history file. Tilde (&lt;code&gt;~&lt;/code&gt;) expansion is performed.</source>
          <target state="translated">命令历史记录文件的备用位置。进行波浪（ &lt;code&gt;~&lt;/code&gt; ）扩展。</target>
        </trans-unit>
        <trans-unit id="0c3a5aa0af507c3b23d9de2d04bd2190286c2e39" translate="yes" xml:space="preserve">
          <source>Alternative location of the user's &lt;code&gt;.psqlrc&lt;/code&gt; file. Tilde (&lt;code&gt;~&lt;/code&gt;) expansion is performed.</source>
          <target state="translated">用户的 &lt;code&gt;.psqlrc&lt;/code&gt; 文件的备用位置。进行波浪（ &lt;code&gt;~&lt;/code&gt; ）扩展。</target>
        </trans-unit>
        <trans-unit id="2541ab725e8ecd177759c1c8be6f800623e60558" translate="yes" xml:space="preserve">
          <source>Alternative spelling for &lt;code&gt;TEMPORARY&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TEMPORARY&lt;/code&gt; 的替代拼写。</target>
        </trans-unit>
        <trans-unit id="af1d73d4699e1562f8a1d0921440facf6a0e5f14" translate="yes" xml:space="preserve">
          <source>Alternative syntaxes for referencing ordered-set aggregates are described under &lt;a href=&quot;sql-alteraggregate&quot;&gt;ALTER AGGREGATE&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;sql-alteraggregate&quot;&gt;ALTER AGGREGATE&lt;/a&gt;下描述了用于引用有序集合聚合的替代语法。</target>
        </trans-unit>
        <trans-unit id="23e53579bffe248a96cd7c7da0e62e9be194d4f8" translate="yes" xml:space="preserve">
          <source>Alternatively, C-style block comments can be used:</source>
          <target state="translated">另外,也可以使用C型块注释。</target>
        </trans-unit>
        <trans-unit id="7ff9d2f8aa56be6c9fb839910a0ca959de998790" translate="yes" xml:space="preserve">
          <source>Alternatively, a &lt;code&gt;time_zone_name&lt;/code&gt; can be given, referencing a zone name defined in the IANA timezone database. The zone's definition is consulted to see whether the abbreviation is or has been in use in that zone, and if so, the appropriate meaning is used &amp;mdash; that is, the meaning that was currently in use at the timestamp whose value is being determined, or the meaning in use immediately before that if it wasn't current at that time, or the oldest meaning if it was used only after that time. This behavior is essential for dealing with abbreviations whose meaning has historically varied. It is also allowed to define an abbreviation in terms of a zone name in which that abbreviation does not appear; then using the abbreviation is just equivalent to writing out the zone name.</source>
          <target state="translated">或者，可以给定 &lt;code&gt;time_zone_name&lt;/code&gt; ，引用IANA时区数据库中定义的时区名称。请参考区域的定义，以查看该区域中是否使用了该缩写，如果使用了该缩写，则使用适当的含义，即，正在确定其值的时间戳当前使用的含义，或者如果当时不是最新的，则使用之前的含义；如果仅在那个时候之后使用，则使用最早的含义。此行为对于处理含义在历史上有所不同的缩写必不可少。还可以根据区域名称定义缩写，在该区域中不出现该缩写；那么使用缩写等同于写出区域名称。</target>
        </trans-unit>
        <trans-unit id="15a06f8c724e47a1d8815847200662f59207ad21" translate="yes" xml:space="preserve">
          <source>Alternatively, a regular server session can be started with &lt;code&gt;-P&lt;/code&gt; included in its command line options. The method for doing this varies across clients, but in all libpq-based clients, it is possible to set the &lt;code&gt;PGOPTIONS&lt;/code&gt; environment variable to &lt;code&gt;-P&lt;/code&gt; before starting the client. Note that while this method does not require locking out other clients, it might still be wise to prevent other users from connecting to the damaged database until repairs have been completed.</source>
          <target state="translated">或者，可以使用命令行选项中包含的 &lt;code&gt;-P&lt;/code&gt; 来启动常规服务器会话。这样做的方法因客户端而异，但是在所有基于libpq的客户端中，可以在启动客户端之前将 &lt;code&gt;PGOPTIONS&lt;/code&gt; 环境变量设置为 &lt;code&gt;-P&lt;/code&gt; 。请注意，尽管此方法不需要锁定其他客户端，但在修复完成之前，阻止其他用户连接到损坏的数据库可能仍然是明智的选择。</target>
        </trans-unit>
        <trans-unit id="d114129fd255b4feb38503a136823f1a3243ffae" translate="yes" xml:space="preserve">
          <source>Alternatively, an arbitrary expression can determine what rows are to be considered distinct:</source>
          <target state="translated">另外,一个任意的表达式可以决定哪些行被认为是不同的。</target>
        </trans-unit>
        <trans-unit id="a31da7f4a4f7c70e9c7e0520f23700364a2f38f8" translate="yes" xml:space="preserve">
          <source>Alternatively, any of the following forms can be used for input:</source>
          <target state="translated">另外,也可以使用以下任何一种形式进行输入。</target>
        </trans-unit>
        <trans-unit id="33e9e4beffd0551e6388808105bbbc2dfb18bd73" translate="yes" xml:space="preserve">
          <source>Alternatively, bit-string constants can be specified in hexadecimal notation, using a leading &lt;code&gt;X&lt;/code&gt; (upper or lower case), e.g., &lt;code&gt;X'1FF'&lt;/code&gt;. This notation is equivalent to a bit-string constant with four binary digits for each hexadecimal digit.</source>
          <target state="translated">或者，可以使用前导 &lt;code&gt;X&lt;/code&gt; （大写或小写）（例如 &lt;code&gt;X'1FF'&lt;/code&gt; ）以十六进制表示法指定位字符串常量。此表示法等效于每个十六进制数具有四个二进制数字的位字符串常量。</target>
        </trans-unit>
        <trans-unit id="251d43a6c1d9b6a2f5aefc3ac8e6be39b17e09eb" translate="yes" xml:space="preserve">
          <source>Alternatively, if only one character is given on a line, instances of that character are deleted; this is useful in languages where accents are represented by separate characters.</source>
          <target state="translated">另外,如果一行中只给出一个字符,则删除该字符的实例;这在重音由单独字符表示的语言中很有用。</target>
        </trans-unit>
        <trans-unit id="d591ed10c7ebb943dc2bac83e217250069a02625" translate="yes" xml:space="preserve">
          <source>Alternatively, if the operator class does not provide a &lt;code&gt;compare&lt;/code&gt; method, GIN will look up the default btree operator class for the index key data type, and use its comparison function. It is recommended to specify the comparison function in a GIN operator class that is meant for just one data type, as looking up the btree operator class costs a few cycles. However, polymorphic GIN operator classes (such as &lt;code&gt;array_ops&lt;/code&gt;) typically cannot specify a single comparison function.</source>
          <target state="translated">或者，如果运算符类未提供 &lt;code&gt;compare&lt;/code&gt; 方法，则GIN将为索引键数据类型查找默认的btree运算符类，并使用其比较功能。建议在仅用于一种数据类型的GIN运算符类中指定比较函数，因为查找btree运算符类需要花费几个周期。但是，多态GIN运算符类（例如 &lt;code&gt;array_ops&lt;/code&gt; ）通常不能指定单个比较函数。</target>
        </trans-unit>
        <trans-unit id="72ceaece99de5916dec6956aa5625927bc2fa200" translate="yes" xml:space="preserve">
          <source>Alternatively, if the user account was created incorrectly or cannot be changed, it is recommended to set</source>
          <target state="translated">或者,如果用户账户创建错误或无法更改,建议将用户账户设置为</target>
        </trans-unit>
        <trans-unit id="60d8933bc73d549d63a859713e0214c4534a9558" translate="yes" xml:space="preserve">
          <source>Alternatively, one may want to create and populate the new child table before adding it to the table hierarchy. This could allow data to be loaded, checked, and transformed before being made visible to queries on the parent table.</source>
          <target state="translated">或者,人们可能希望在将新的子表添加到表的层次结构之前,先创建和填充新的子表。这可以使数据在对父表的查询可见之前被加载、检查和转换。</target>
        </trans-unit>
        <trans-unit id="3ff1004e1f07326010cba19c9e266164c058052f" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;a href=&quot;sql-reassign-owned&quot;&gt;REASSIGN OWNED&lt;/a&gt; command can be used to reassign ownership of all objects owned by the role-to-be-dropped to a single other role. Because &lt;code&gt;REASSIGN OWNED&lt;/code&gt; cannot access objects in other databases, it is necessary to run it in each database that contains objects owned by the role. (Note that the first such &lt;code&gt;REASSIGN OWNED&lt;/code&gt; will change the ownership of any shared-across-databases objects, that is databases or tablespaces, that are owned by the role-to-be-dropped.)</source>
          <target state="translated">或者，可以使用&lt;a href=&quot;sql-reassign-owned&quot;&gt;REASSIGN OWNED&lt;/a&gt;命令将要删除的角色拥有的所有对象的所有权重新分配给单个其他角色。由于 &lt;code&gt;REASSIGN OWNED&lt;/code&gt; 无法访问其他数据库中的对象，因此有必要在包含该角色拥有的对象的每个数据库中运行它。（请注意，第一个这样的 &lt;code&gt;REASSIGN OWNED&lt;/code&gt; 将更改要删除的角色所拥有的任何跨数据库共享对象（即数据库或表空间）的所有权。）</target>
        </trans-unit>
        <trans-unit id="0e1e66b725216c8606cc4bf9032cf0c74ece07f1" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;code&gt;generate_subscripts&lt;/code&gt; function can be used. For example:</source>
          <target state="translated">或者，可以使用 &lt;code&gt;generate_subscripts&lt;/code&gt; 函数。例如：</target>
        </trans-unit>
        <trans-unit id="15fba016cd90434c268101e2e3dcfba0bf0a2532" translate="yes" xml:space="preserve">
          <source>Alternatively, use the &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; parameter:</source>
          <target state="translated">或者，使用&lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt;参数：</target>
        </trans-unit>
        <trans-unit id="0f4a86811d0aa22382b5cf9bd26c67192af09d76" translate="yes" xml:space="preserve">
          <source>Alternatively, use the short commands:</source>
          <target state="translated">或者,使用短命令。</target>
        </trans-unit>
        <trans-unit id="65a8f599c00acf998716acc089534f17921d2aa4" translate="yes" xml:space="preserve">
          <source>Alternatively, you can run &lt;code&gt;initdb&lt;/code&gt; via the &lt;a href=&quot;app-pg-ctl&quot;&gt;pg_ctl&lt;/a&gt; program like so:</source>
          <target state="translated">另外，您可以通过&lt;a href=&quot;app-pg-ctl&quot;&gt;pg_ctl&lt;/a&gt;程序运行 &lt;code&gt;initdb&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="98a5c461c82a79025a521674df6f9b47d5588e09" translate="yes" xml:space="preserve">
          <source>Alternatively, you could modify &lt;code&gt;passwordcheck&lt;/code&gt; to reject pre-encrypted passwords, but forcing users to set their passwords in clear text carries its own security risks.</source>
          <target state="translated">或者，您可以修改 &lt;code&gt;passwordcheck&lt;/code&gt; 以拒绝预加密的密码，但是强制用户以明文形式设置其密码会带来自身的安全风险。</target>
        </trans-unit>
        <trans-unit id="5a5bc9685c86de23aa2f7e6abe79e2df58ea2f24" translate="yes" xml:space="preserve">
          <source>Alternatively, you might prefer to use an external log rotation program if you have one that you are already using with other server software. For example, the rotatelogs tool included in the Apache distribution can be used with PostgreSQL. One way to do this is to pipe the server's stderr output to the desired program. If you start the server with &lt;code&gt;pg_ctl&lt;/code&gt;, then stderr is already redirected to stdout, so you just need a pipe command, for example:</source>
          <target state="translated">或者，如果您已经在使用其他服务器软件，则可能更喜欢使用外部日志轮换程序。例如，Apache发行版中包含的rotatelogs工具可与PostgreSQL一起使用。一种方法是将服务器的stderr输出通过管道传递到所需程序。如果使用 &lt;code&gt;pg_ctl&lt;/code&gt; 启动服务器，则stderr已经被重定向到stdout，因此您只需要管道命令，例如：</target>
        </trans-unit>
        <trans-unit id="a4473ced05716c4f54d00426c2fe62cbfc81eb98" translate="yes" xml:space="preserve">
          <source>Alternatively, you'll get this when attempting Unix-domain socket communication to a local server:</source>
          <target state="translated">另外,当你尝试与本地服务器进行Unix域套接字通信时,你也会得到这个信息。</target>
        </trans-unit>
        <trans-unit id="3070b53c6b7161861f801a0276cbe1623e985387" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;ALTER DOMAIN ADD CONSTRAINT&lt;/code&gt; attempts to verify that existing stored data satisfies the new constraint, this check is not bulletproof, because the command cannot &amp;ldquo;see&amp;rdquo; table rows that are newly inserted or updated and not yet committed. If there is a hazard that concurrent operations might insert bad data, the way to proceed is to add the constraint using the &lt;code&gt;NOT VALID&lt;/code&gt; option, commit that command, wait until all transactions started before that commit have finished, and then issue &lt;code&gt;ALTER DOMAIN VALIDATE CONSTRAINT&lt;/code&gt; to search for data violating the constraint. This method is reliable because once the constraint is committed, all new transactions are guaranteed to enforce it against new values of the domain type.</source>
          <target state="translated">尽管 &lt;code&gt;ALTER DOMAIN ADD CONSTRAINT&lt;/code&gt; 尝试验证现有存储的数据是否满足新约束，但此检查不是防弹的，因为该命令无法&amp;ldquo;看到&amp;rdquo;新插入或更新且尚未提交的表行。如果存在并发操作可能会插入错误数据的危险，则继续的方法是使用 &lt;code&gt;NOT VALID&lt;/code&gt; 选项添加约束，提交该命令，等待所有开始的事务在该提交之前完成，然后发出 &lt;code&gt;ALTER DOMAIN VALIDATE CONSTRAINT&lt;/code&gt; 搜索违反约束的数据。此方法之所以可靠，是因为一旦提交了约束，就可以保证所有新事务都针对域类型的新值强制实施该约束。</target>
        </trans-unit>
        <trans-unit id="6e4d5c62b36bd1bff5096ffffc66d8713544d380" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;COALESCE&lt;/code&gt;, &lt;code&gt;GREATEST&lt;/code&gt;, and &lt;code&gt;LEAST&lt;/code&gt; are syntactically similar to functions, they are not ordinary functions, and thus cannot be used with explicit &lt;code&gt;VARIADIC&lt;/code&gt; array arguments.</source>
          <target state="translated">尽管 &lt;code&gt;COALESCE&lt;/code&gt; ， &lt;code&gt;GREATEST&lt;/code&gt; 和 &lt;code&gt;LEAST&lt;/code&gt; 在语法上类似于函数，但它们不是普通函数，因此不能与显式 &lt;code&gt;VARIADIC&lt;/code&gt; 数组参数一起使用。</target>
        </trans-unit>
        <trans-unit id="757c32acfdc3edc5e4ae1b7ef733e95e7cd6d851" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;FOR UPDATE&lt;/code&gt; appears in the SQL standard, the standard allows it only as an option of &lt;code&gt;DECLARE CURSOR&lt;/code&gt;. PostgreSQL allows it in any &lt;code&gt;SELECT&lt;/code&gt; query as well as in sub-&lt;code&gt;SELECT&lt;/code&gt;s, but this is an extension. The &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt;, &lt;code&gt;FOR SHARE&lt;/code&gt; and &lt;code&gt;FOR KEY SHARE&lt;/code&gt; variants, as well as the &lt;code&gt;NOWAIT&lt;/code&gt; and &lt;code&gt;SKIP LOCKED&lt;/code&gt; options, do not appear in the standard.</source>
          <target state="translated">尽管 &lt;code&gt;FOR UPDATE&lt;/code&gt; 出现在SQL标准中，但该标准仅允许将它作为 &lt;code&gt;DECLARE CURSOR&lt;/code&gt; 的选项。PostgreSQL允许它在任何 &lt;code&gt;SELECT&lt;/code&gt; 查询以及子 &lt;code&gt;SELECT&lt;/code&gt; 中使用，但这是一个扩展。该 &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt; ， &lt;code&gt;FOR SHARE&lt;/code&gt; 和 &lt;code&gt;FOR KEY SHARE&lt;/code&gt; 变体，以及作为 &lt;code&gt;NOWAIT&lt;/code&gt; 和 &lt;code&gt;SKIP LOCKED&lt;/code&gt; 选项，不会出现在标准的。</target>
        </trans-unit>
        <trans-unit id="53588eb1af9a260bf16537d83fb7f9095237ab92" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;initdb&lt;/code&gt; will attempt to create the specified data directory, it might not have permission if the parent directory of the desired data directory is root-owned. To initialize in such a setup, create an empty data directory as root, then use &lt;code&gt;chown&lt;/code&gt; to assign ownership of that directory to the database user account, then &lt;code&gt;su&lt;/code&gt; to become the database user to run &lt;code&gt;initdb&lt;/code&gt;.</source>
          <target state="translated">尽管 &lt;code&gt;initdb&lt;/code&gt; 会尝试创建指定的数据目录，但是如果所需数据目录的父目录是root拥有的，则它可能没有权限。要在这种设置中进行初始化，请创建一个空的数据目录作为root用户，然后使用 &lt;code&gt;chown&lt;/code&gt; 将该目录的所有权分配给数据库用户帐户，然后使用 &lt;code&gt;su&lt;/code&gt; 成为运行 &lt;code&gt;initdb&lt;/code&gt; 的数据库用户。</target>
        </trans-unit>
        <trans-unit id="2c9e9e73d67adcca66915f7f142192b4fd5640e0" translate="yes" xml:space="preserve">
          <source>Although PostgreSQL does not attempt to enforce constraints on foreign tables, it does assume that they are correct for purposes of query optimization. If there are rows visible in the foreign table that do not satisfy a declared constraint, queries on the table might produce incorrect answers. It is the user's responsibility to ensure that the constraint definition matches reality.</source>
          <target state="translated">虽然PostgreSQL并不试图在外表上强制执行约束,但为了查询优化的目的,它确实假设这些约束是正确的。如果外表中可见的行不满足声明的约束,那么对该表的查询可能会产生错误的答案。确保约束定义与现实相符是用户的责任。</target>
        </trans-unit>
        <trans-unit id="d1a0d48f05bfdc6cec6860f8c1c04ca18ef39017" translate="yes" xml:space="preserve">
          <source>Although PostgreSQL supports Julian Date notation for input and output of dates (and also uses Julian dates for some internal datetime calculations), it does not observe the nicety of having dates run from noon to noon. PostgreSQL treats a Julian Date as running from midnight to midnight.</source>
          <target state="translated">虽然PostgreSQL支持Julian Date符号来输入和输出日期(也使用Julian日期来进行一些内部的日期时间计算),但它并没有遵守日期从中午到中午的良好习惯。PostgreSQL将一个朱利安日期视为从午夜到午夜的运行。</target>
        </trans-unit>
        <trans-unit id="aa5958132d1510aabee9c8eff036ee687a13c3b5" translate="yes" xml:space="preserve">
          <source>Although all built-in WAL-logged modules have their own types of WAL records, there is also a generic WAL record type, which describes changes to pages in a generic way. This is useful for extensions that provide custom access methods, because they cannot register their own WAL redo routines.</source>
          <target state="translated">虽然所有内置的WAL记录模块都有自己的WAL记录类型,但也有一种通用的WAL记录类型,它以通用的方式描述页面的变化。这对于提供自定义访问方法的扩展来说很有用,因为它们不能注册自己的WAL重做例程。</target>
        </trans-unit>
        <trans-unit id="d6ab224f94330d8699a9bed333303bd23f1e0345" translate="yes" xml:space="preserve">
          <source>Although enum types are primarily intended for static sets of values, there is support for adding new values to an existing enum type, and for renaming values (see &lt;a href=&quot;sql-altertype&quot;&gt;ALTER TYPE&lt;/a&gt;). Existing values cannot be removed from an enum type, nor can the sort ordering of such values be changed, short of dropping and re-creating the enum type.</source>
          <target state="translated">尽管枚举类型主要用于静态值集，但支持将新值添加到现有枚举类型并重命名值（请参阅&lt;a href=&quot;sql-altertype&quot;&gt;ALTER TYPE&lt;/a&gt;）。不能从枚举类型中删除现有值，也不能更改此类值的排序顺序，除非删除并重新创建枚举类型。</target>
        </trans-unit>
        <trans-unit id="94ec3fef4f0a92e5c738b8e891b93184d80ce08d" translate="yes" xml:space="preserve">
          <source>Although indexes in PostgreSQL do not need maintenance or tuning, it is still important to check which indexes are actually used by the real-life query workload. Examining index usage for an individual query is done with the &lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt; command; its application for this purpose is illustrated in &lt;a href=&quot;using-explain&quot;&gt;Section 14.1&lt;/a&gt;. It is also possible to gather overall statistics about index usage in a running server, as described in &lt;a href=&quot;monitoring-stats&quot;&gt;Section 27.2&lt;/a&gt;.</source>
          <target state="translated">尽管PostgreSQL中的索引不需要维护或调整，但检查实际查询工作负载实际使用了哪些索引仍然很重要。检查单个查询的索引使用情况是通过&lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt;命令完成的；在&lt;a href=&quot;using-explain&quot;&gt;14.1节中&lt;/a&gt;说明了它的应用。如&lt;a href=&quot;monitoring-stats&quot;&gt;第27.2节中&lt;/a&gt;所述，还可以收集有关正在运行的服务器中索引使用情况的总体统计信息。</target>
        </trans-unit>
        <trans-unit id="b565c24300a11b353aca42f1a3c2fd6f15be280e" translate="yes" xml:space="preserve">
          <source>Although inheritance is frequently useful, it has not been integrated with unique constraints or foreign keys, which limits its usefulness. See &lt;a href=&quot;ddl-inherit&quot;&gt;Section 5.10&lt;/a&gt; for more detail.</source>
          <target state="translated">尽管继承通常是有用的，但它尚未与唯一的约束或外键集成在一起，这限制了它的实用性。有关更多详细信息，请参见&lt;a href=&quot;ddl-inherit&quot;&gt;第5.10节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d3850ba882b09b2bdad99e045dd0ac52d33bb527" translate="yes" xml:space="preserve">
          <source>Although it is possible to copy a database other than &lt;code&gt;template1&lt;/code&gt; by specifying its name as the template, this is not (yet) intended as a general-purpose &amp;ldquo;&lt;code&gt;COPY DATABASE&lt;/code&gt;&amp;rdquo; facility. The principal limitation is that no other sessions can be connected to the template database while it is being copied. &lt;code&gt;CREATE DATABASE&lt;/code&gt; will fail if any other connection exists when it starts; otherwise, new connections to the template database are locked out until &lt;code&gt;CREATE DATABASE&lt;/code&gt; completes. See &lt;a href=&quot;manage-ag-templatedbs&quot;&gt;Section 22.3&lt;/a&gt; for more information.</source>
          <target state="translated">尽管可以通过将 &lt;code&gt;template1&lt;/code&gt; 名称指定为模板来复制除template1以外的数据库，但尚未将其用作通用的&amp;ldquo; &lt;code&gt;COPY DATABASE&lt;/code&gt; &amp;rdquo;工具。主要限制是，在复制模板数据库时，无法将其他会话连接到模板数据库。如果启动时存在任何其他连接，则 &lt;code&gt;CREATE DATABASE&lt;/code&gt; 将失败。否则，将锁定与模板数据库的新连接，直到 &lt;code&gt;CREATE DATABASE&lt;/code&gt; 完成。有关更多信息，请参见&lt;a href=&quot;manage-ag-templatedbs&quot;&gt;第22.3节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9f2cb95ff60fc4e9f012557faa268bb5d908ed75" translate="yes" xml:space="preserve">
          <source>Although most forms of &lt;code&gt;ADD table_constraint&lt;/code&gt; require an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock, &lt;code&gt;ADD FOREIGN KEY&lt;/code&gt; requires only a &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; lock. Note that &lt;code&gt;ADD FOREIGN KEY&lt;/code&gt; also acquires a &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; lock on the referenced table, in addition to the lock on the table on which the constraint is declared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f7a4620dd953ee89678c8af93ba6b1281ecf21b" translate="yes" xml:space="preserve">
          <source>Although per-column tweaking of &lt;code&gt;ANALYZE&lt;/code&gt; frequency might not be very productive, you might find it worthwhile to do per-column adjustment of the level of detail of the statistics collected by &lt;code&gt;ANALYZE&lt;/code&gt;. Columns that are heavily used in &lt;code&gt;WHERE&lt;/code&gt; clauses and have highly irregular data distributions might require a finer-grain data histogram than other columns. See &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt;, or change the database-wide default using the &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; configuration parameter.</source>
          <target state="translated">尽管对 &lt;code&gt;ANALYZE&lt;/code&gt; 频率进行逐列调整可能不会很有效，但是您可能发现有必要对 &lt;code&gt;ANALYZE&lt;/code&gt; 收集的统计信息的详细程度进行逐列调整。在 &lt;code&gt;WHERE&lt;/code&gt; 子句中大量使用且数据分布非常不规则的列可能需要比其他列更细粒度的数据直方图。请参阅 &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt; ，或使用&lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt;配置参数更改数据库范围的默认值。</target>
        </trans-unit>
        <trans-unit id="072197dff3ba1069a6848a4f3fc276518f8dd8e2" translate="yes" xml:space="preserve">
          <source>Although the &lt;code&gt;date&lt;/code&gt; type cannot have an associated time zone, the &lt;code&gt;time&lt;/code&gt; type can. Time zones in the real world have little meaning unless associated with a date as well as a time, since the offset can vary through the year with daylight-saving time boundaries.</source>
          <target state="translated">尽管 &lt;code&gt;date&lt;/code&gt; 类型不能具有关联的时区，但是 &lt;code&gt;time&lt;/code&gt; 类型可以。除非与日期和时间相关联，否则现实世界中的时区几乎没有意义，因为偏移量会随着夏时制的时限在一年中变化。</target>
        </trans-unit>
        <trans-unit id="28fdae260b7b429ca2fc81de6c0ad8518d3a56e2" translate="yes" xml:space="preserve">
          <source>Although the &lt;code&gt;jsonb_path_ops&lt;/code&gt; operator class supports only queries with the &lt;code&gt;@&amp;gt;&lt;/code&gt;, &lt;code&gt;@@&lt;/code&gt; and &lt;code&gt;@?&lt;/code&gt; operators, it has notable performance advantages over the default operator class &lt;code&gt;jsonb_ops&lt;/code&gt;. A &lt;code&gt;jsonb_path_ops&lt;/code&gt; index is usually much smaller than a &lt;code&gt;jsonb_ops&lt;/code&gt; index over the same data, and the specificity of searches is better, particularly when queries contain keys that appear frequently in the data. Therefore search operations typically perform better than with the default operator class.</source>
          <target state="translated">尽管 &lt;code&gt;jsonb_path_ops&lt;/code&gt; 运算符类仅支持带有 &lt;code&gt;@&amp;gt;&lt;/code&gt; ， &lt;code&gt;@@&lt;/code&gt; 和 &lt;code&gt;@?&lt;/code&gt; 的查询。运算符，它比默认的运算符类 &lt;code&gt;jsonb_ops&lt;/code&gt; 具有明显的性能优势。一个 &lt;code&gt;jsonb_path_ops&lt;/code&gt; 指数通常比小得多 &lt;code&gt;jsonb_ops&lt;/code&gt; 指数在相同的数据，并且搜索的特异性较好，特别是当查询包含在数据频繁出现的密钥。因此，搜索操作通常比默认运算符类具有更好的性能。</target>
        </trans-unit>
        <trans-unit id="b3909c49c0f3069cf4fdb831ccd03572195110f1" translate="yes" xml:space="preserve">
          <source>Although the error conditions possible on the client side are quite varied and application-dependent, a few of them might be directly related to how the server was started. Conditions other than those shown below should be documented with the respective client application.</source>
          <target state="translated">虽然客户端可能出现的错误情况相当多,而且取决于应用程序,但其中一些可能与服务器的启动方式直接相关。除了下面显示的情况外,其他的情况应该在相应的客户端应用程序中进行记录。</target>
        </trans-unit>
        <trans-unit id="707d4aa12dd0762aad5c962d956cb0615faa21aa" translate="yes" xml:space="preserve">
          <source>Although the main point of a prepared statement is to avoid repeated parse analysis and planning of the statement, PostgreSQL will force re-analysis and re-planning of the statement before using it whenever database objects used in the statement have undergone definitional (DDL) changes since the previous use of the prepared statement. Also, if the value of &lt;a href=&quot;runtime-config-client#GUC-SEARCH-PATH&quot;&gt;search_path&lt;/a&gt; changes from one use to the next, the statement will be re-parsed using the new &lt;code&gt;search_path&lt;/code&gt;. (This latter behavior is new as of PostgreSQL 9.3.) These rules make use of a prepared statement semantically almost equivalent to re-submitting the same query text over and over, but with a performance benefit if no object definitions are changed, especially if the best plan remains the same across uses. An example of a case where the semantic equivalence is not perfect is that if the statement refers to a table by an unqualified name, and then a new table of the same name is created in a schema appearing earlier in the &lt;code&gt;search_path&lt;/code&gt;, no automatic re-parse will occur since no object used in the statement changed. However, if some other change forces a re-parse, the new table will be referenced in subsequent uses.</source>
          <target state="translated">尽管准备好的语句的主要目的是避免重复分析和规划语句，但是只要语句中使用的数据库对象发生了定义（DDL）更改，PostgreSQL都会在使用前强制重新分析和重新规划语句自上次使用预处理语句以来。另外，如果&lt;a href=&quot;runtime-config-client#GUC-SEARCH-PATH&quot;&gt;search_path&lt;/a&gt;的值从一种用法更改为另一种用法，则将使用新的 &lt;code&gt;search_path&lt;/code&gt; 重新解析该语句。。 （后一种行为在PostgreSQL 9.3中是新的。）这些规则在语义上几乎等同于一次又一次地重新提交相同的查询文本，这在语义上几乎等同于使用预准备语句，但是如果不更改对象定义，则可以提高性能，特别是如果最佳计划在不同用途之间保持不变。语义对等不完美的情况的一个示例是，如果该语句使用不合格的名称引用表，然后在较早出现在 &lt;code&gt;search_path&lt;/code&gt; 中的模式中创建了一个具有相同名称的新表，则不会自动重新由于语句中使用的对象未更改，因此将进行解析。但是，如果其他一些更改强制重新解析，则在随后的使用中将引用新表。</target>
        </trans-unit>
        <trans-unit id="7b64c47c816d918ee8eceb31b5a14f4992da7fb7" translate="yes" xml:space="preserve">
          <source>Although the syntax of &lt;code&gt;CREATE TEMPORARY TABLE&lt;/code&gt; resembles that of the SQL standard, the effect is not the same. In the standard, temporary tables are defined just once and automatically exist (starting with empty contents) in every session that needs them. PostgreSQL instead requires each session to issue its own &lt;code&gt;CREATE TEMPORARY TABLE&lt;/code&gt; command for each temporary table to be used. This allows different sessions to use the same temporary table name for different purposes, whereas the standard's approach constrains all instances of a given temporary table name to have the same table structure.</source>
          <target state="translated">尽管 &lt;code&gt;CREATE TEMPORARY TABLE&lt;/code&gt; 的语法与SQL标准的语法相似，但是效果并不相同。在标准中，临时表仅定义一次，并在每个需要它们的会话中自动存在（从空内容开始）。 PostgreSQL而是要求每个会话为要使用的每个临时表发出自己的 &lt;code&gt;CREATE TEMPORARY TABLE&lt;/code&gt; 命令。这允许不同的会话出于不同的目的而使用相同的临时表名称，而标准的方法将给定临时表名称的所有实例约束为具有相同的表结构。</target>
        </trans-unit>
        <trans-unit id="9eb832cbf2f7969f569f8af2de92f22dbf429240" translate="yes" xml:space="preserve">
          <source>Although the system will let you set &lt;code&gt;random_page_cost&lt;/code&gt; to less than &lt;code&gt;seq_page_cost&lt;/code&gt;, it is not physically sensible to do so. However, setting them equal makes sense if the database is entirely cached in RAM, since in that case there is no penalty for touching pages out of sequence. Also, in a heavily-cached database you should lower both values relative to the CPU parameters, since the cost of fetching a page already in RAM is much smaller than it would normally be.</source>
          <target state="translated">尽管系统允许您将 &lt;code&gt;random_page_cost&lt;/code&gt; 设置为小于 &lt;code&gt;seq_page_cost&lt;/code&gt; ，但这在物理上并不明智。但是，如果将数据库完全缓存在RAM中，则将它们设置为相等是有意义的，因为在这种情况下，按顺序触摸页面不会造成任何损失。同样，在高速缓存的数据库中，您应该降低两个值，相对于CPU参数，这是因为获取RAM中已经存在的页面的成本比通常要小得多。</target>
        </trans-unit>
        <trans-unit id="f375eb3005a104e4e3133bc9460b959aca6d956c" translate="yes" xml:space="preserve">
          <source>Although these queries will work without an index, most applications will find this approach too slow, except perhaps for occasional ad-hoc searches. Practical use of text searching usually requires creating an index.</source>
          <target state="translated">虽然这些查询在没有索引的情况下也能工作,但大多数应用程序会发现这种方法太慢了,也许除了偶尔的临时搜索。实际使用文本搜索通常需要创建一个索引。</target>
        </trans-unit>
        <trans-unit id="d6a53bc14c2fd9a760550de48fb80767bf99cae5" translate="yes" xml:space="preserve">
          <source>Although this query runs much faster than with either of the single indexes, we pay a large penalty in index size. Each of the single-column btree indexes occupies 214 MB, so the total space needed is over 1.2GB, more than 8 times the space used by the bloom index.</source>
          <target state="translated">虽然这个查询的运行速度比使用任何一个单索引都要快得多,但是我们在索引大小上付出了很大的代价。每一个单列btree索引都占据了214MB,因此所需的总空间超过了1.2GB,是bloom索引使用空间的8倍多。</target>
        </trans-unit>
        <trans-unit id="a490262673b6e67e6cc0b4de26fba601b493618f" translate="yes" xml:space="preserve">
          <source>Although this query runs much faster than with either of the single indexes, we pay a penalty in index size. Each of the single-column btree indexes occupies 2 MB, so the total space needed is 12 MB, eight times the space used by the bloom index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1200f8928e7bfeba98e8bc2cff21bdd8b6159a1f" translate="yes" xml:space="preserve">
          <source>Although this query's restrictions are superficially similar to the previous example, the semantics are different because a row must be emitted for each row of A that has no matching row in the join of B and C. Therefore the planner has no choice of join order here: it must join B to C and then join A to that result. Accordingly, this query takes less time to plan than the previous query. In other cases, the planner might be able to determine that more than one join order is safe. For example, given:</source>
          <target state="translated">虽然这个查询的限制表面上与前一个例子相似,但语义是不同的,因为A的每一条记录在B和C的连接中没有匹配的记录,就必须发出一条记录,因此,规划者在这里没有选择连接顺序:它必须将B连接到C,然后将A连接到该结果。相应地,这个查询的规划时间比前一个查询要少。在其他情况下,规划者可能能够确定不止一个连接顺序是安全的。例如,给定</target>
        </trans-unit>
        <trans-unit id="7ef8d68c90c214bb77efeec7b9a407cfbeffef4b" translate="yes" xml:space="preserve">
          <source>Although tuples are a lockable type of object, information about row-level locks is stored on disk, not in memory, and therefore row-level locks normally do not appear in this view. If a process is waiting for a row-level lock, it will usually appear in the view as waiting for the permanent transaction ID of the current holder of that row lock.</source>
          <target state="translated">虽然tuple是一种可锁定的对象类型,但有关行级锁的信息存储在磁盘上,而不是在内存中,因此行级锁通常不会出现在该视图中。如果一个进程正在等待行级锁,它通常会在视图中显示为等待该行锁的当前持有者的永久事务ID。</target>
        </trans-unit>
        <trans-unit id="72059384cd793d17d014692386f1a5b268fab6d4" translate="yes" xml:space="preserve">
          <source>Although you can use any output format with this feature, the default &lt;code&gt;aligned&lt;/code&gt; format tends to look bad because each group of &lt;code&gt;FETCH_COUNT&lt;/code&gt; rows will be formatted separately, leading to varying column widths across the row groups. The other output formats work better.</source>
          <target state="translated">尽管可以使用此功能使用任何输出格式，但是默认的 &lt;code&gt;aligned&lt;/code&gt; 格式看起来很糟糕，因为每组 &lt;code&gt;FETCH_COUNT&lt;/code&gt; 行将分别设置格式，从而导致行组中的列宽变化。其他输出格式效果更好。</target>
        </trans-unit>
        <trans-unit id="29489a7d34435843e1ff1804b48da3fef28fc6ed" translate="yes" xml:space="preserve">
          <source>Although you cannot update a sequence directly, you can use a query like:</source>
          <target state="translated">虽然你不能直接更新序列,但你可以使用一个查询,如。</target>
        </trans-unit>
        <trans-unit id="d408d29d181fe5f178e0df0934db0a473f3e4b2d" translate="yes" xml:space="preserve">
          <source>Always -1 in storage, but when loaded into a row descriptor in memory this might be updated to cache the offset of the attribute within the row</source>
          <target state="translated">在存储中总是-1,但是当加载到内存中的行描述符时,可能会被更新为缓存行中属性的偏移量。</target>
        </trans-unit>
        <trans-unit id="6dadde15ce0973a00fe9eb264f6b51766c085e93" translate="yes" xml:space="preserve">
          <source>Always run &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; first. This command collects statistics about the distribution of the values in the table. This information is required to estimate the number of rows returned by a query, which is needed by the planner to assign realistic costs to each possible query plan. In absence of any real statistics, some default values are assumed, which are almost certain to be inaccurate. Examining an application's index usage without having run &lt;code&gt;ANALYZE&lt;/code&gt; is therefore a lost cause. See &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Section 24.1.3&lt;/a&gt; and &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information.</source>
          <target state="translated">始终先运行&lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt;。此命令收集有关表中值分布的统计信息。需要此信息来估计查询返回的行数，计划人员需要此信息才能为每个可能的查询计划分配实际成本。在没有任何实际统计信息的情况下，将假定一些默认值，这些默认值几乎可以肯定是不准确的。因此，在不运行 &lt;code&gt;ANALYZE&lt;/code&gt; 的情况下检查应用程序的索引使用情况是一个失败的原因。有关更多信息，请参见&lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;第24.1.3节&lt;/a&gt;和&lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;第24.1.6节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fee90b9468a8f0a4929baba6bf4b3942f402f50f" translate="yes" xml:space="preserve">
          <source>Always run the pg_upgrade binary of the new server, not the old one. pg_upgrade requires the specification of the old and new cluster's data and executable (&lt;code&gt;bin&lt;/code&gt;) directories. You can also specify user and port values, and whether you want the data files linked or cloned instead of the default copy behavior.</source>
          <target state="translated">始终运行新服务器的pg_upgrade二进制文件，而不是旧服务器。 pg_upgrade需要指定新旧集群的数据和可执行文件（ &lt;code&gt;bin&lt;/code&gt; ）目录。您还可以指定用户和端口值，以及是否要链接或克隆数据文件，而不是默认的复制行为。</target>
        </trans-unit>
        <trans-unit id="ed314eaaeb4f7d7933efa77539bb6dd24179fb4e" translate="yes" xml:space="preserve">
          <source>American National Standards Institute</source>
          <target state="translated">美国国家标准协会</target>
        </trans-unit>
        <trans-unit id="9b0f6aa450d937f102baa99a591a10b175502ace" translate="yes" xml:space="preserve">
          <source>American Standard Code for Information Interchange</source>
          <target state="translated">美国信息交换标准代码</target>
        </trans-unit>
        <trans-unit id="f772502aac0c6acdc4a93caa9a6a863fee25bd39" translate="yes" xml:space="preserve">
          <source>Among all relational operators the most difficult one to process and optimize is the &lt;em&gt;join&lt;/em&gt;. The number of possible query plans grows exponentially with the number of joins in the query. Further optimization effort is caused by the support of a variety of &lt;em&gt;join methods&lt;/em&gt; (e.g., nested loop, hash join, merge join in PostgreSQL) to process individual joins and a diversity of &lt;em&gt;indexes&lt;/em&gt; (e.g., B-tree, hash, GiST and GIN in PostgreSQL) as access paths for relations.</source>
          <target state="translated">在所有关系运算符中，最难处理和优化的是&lt;em&gt;联接&lt;/em&gt;。可能的查询计划的数量随着查询中联接的数量呈指数增长。进一步的优化工作是由对各种&lt;em&gt;连接方法&lt;/em&gt;（例如PostgreSQL中的嵌套循环，哈希连接，合并连接）的支持引起的，以处理单个连接以及&lt;em&gt;索引&lt;/em&gt;的多样性（例如B-tree，hash，GiST和GIN） PostgreSQL）作为关系的访问路径。</target>
        </trans-unit>
        <trans-unit id="a06f60f435b117a486b4b9306faa4f936e74dfd4" translate="yes" xml:space="preserve">
          <source>Amount of data streamed. This counter only advances when the phase is &lt;code&gt;streaming database files&lt;/code&gt; or &lt;code&gt;transferring wal files&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb98c34253bd6741e222de32790839f4b0bbf938" translate="yes" xml:space="preserve">
          <source>An &amp;ldquo;ordering&amp;rdquo; operator entry indicates that an index of this operator family can be scanned to return rows in the order represented by &lt;code&gt;ORDER BY&lt;/code&gt;&lt;code&gt;indexed_column&lt;/code&gt;&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;constant&lt;/code&gt;. Such an operator could return any sortable data type, though again its left-hand input type must match the index's column data type. The exact semantics of the &lt;code&gt;ORDER BY&lt;/code&gt; are specified by the &lt;code&gt;amopsortfamily&lt;/code&gt; column, which must reference a B-tree operator family for the operator's result type.</source>
          <target state="translated">&amp;ldquo;排序&amp;rdquo;运算符条目指示可以对该运算符系列的索引进行扫描，以按 &lt;code&gt;ORDER BY&lt;/code&gt; &lt;code&gt;indexed_column&lt;/code&gt; &lt;code&gt;operator&lt;/code&gt; &lt;code&gt;constant&lt;/code&gt; 表示的顺序返回行。这样的运算符可以返回任何可排序的数据类型，尽管它的左侧输入类型必须再次与索引的列数据类型匹配。 &lt;code&gt;amopsortfamily&lt;/code&gt; 列指定了 &lt;code&gt;ORDER BY&lt;/code&gt; 的确切语义，该列必须引用B树运算符族作为运算符的结果类型。</target>
        </trans-unit>
        <trans-unit id="6d377056771f89a3a21b9faebc41fe3335e17744" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;attribute&lt;/a&gt; found in a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; or &lt;a href=&quot;glossary#GLOSSARY-VIEW&quot;&gt;view&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef1279b86476578e5585aff75989181f73dcffd4" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;=&lt;/code&gt; operator must be an equivalence relation; that is, for all non-null values &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt; of the data type:</source>
          <target state="translated">一个 &lt;code&gt;=&lt;/code&gt; 操作者必须是等价关系; 也就是说，对于数据类型的所有非空值 &lt;code&gt;A&lt;/code&gt; ， &lt;code&gt;B&lt;/code&gt; ， &lt;code&gt;C&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c4237e342da22e5fcef0feed597ee14805fa3aa4" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;equalimage&lt;/code&gt; function must have the signature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="009a293231558c68203740163c433bc30d08defc" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;in_range&lt;/code&gt; function must have the signature</source>
          <target state="translated">一个 &lt;code&gt;in_range&lt;/code&gt; 函数必须有签名</target>
        </trans-unit>
        <trans-unit id="89039523af081d32fe0dcce5afd61336bd5c01d2" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;options&lt;/code&gt; support function must have the signature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="857fc13a44d4059f0989bb54c261a11965498b57" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;unaccent&lt;/code&gt; dictionary accepts the following options:</source>
          <target state="translated">不 &lt;code&gt;unaccent&lt;/code&gt; 字典接受以下选项：</target>
        </trans-unit>
        <trans-unit id="044945d1a76181f7c4bcb8b32669d47c02d34474" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;aggregate expression&lt;/em&gt; represents the application of an aggregate function across the rows selected by a query. An aggregate function reduces multiple inputs to a single output value, such as the sum or average of the inputs. The syntax of an aggregate expression is one of the following:</source>
          <target state="translated">一个&lt;em&gt;聚集表达式&lt;/em&gt;表示跨由查询所选择的行的集合函数的应用。聚合函数将多个输入减少为单个输出值，例如输入的总和或平均值。聚合表达式的语法是以下之一：</target>
        </trans-unit>
        <trans-unit id="9cf57ce9f4c43bfd5a2501334071928e81cfc082" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;operator class&lt;/em&gt; can be specified for each column of an index. The operator class identifies the operators to be used by the index for that column. For example, a B-tree index on four-byte integers would use the &lt;code&gt;int4_ops&lt;/code&gt; class; this operator class includes comparison functions for four-byte integers. In practice the default operator class for the column's data type is usually sufficient. The main point of having operator classes is that for some data types, there could be more than one meaningful ordering. For example, we might want to sort a complex-number data type either by absolute value or by real part. We could do this by defining two operator classes for the data type and then selecting the proper class when creating an index. More information about operator classes is in &lt;a href=&quot;indexes-opclass&quot;&gt;Section 11.10&lt;/a&gt; and in &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html&quot;&gt;Section 37.16&lt;/a&gt;.</source>
          <target state="translated">可以为索引的每一列指定一个&lt;em&gt;运算符类&lt;/em&gt;。 operator类标识该列的索引要使用的运算符。例如，在四字节整数上的B树索引将使用 &lt;code&gt;int4_ops&lt;/code&gt; 类。此运算符类包含用于四字节整数的比较函数。实际上，列数据类型的默认运算符类通常就足够了。拥有运算符类的要点是，对于某些数据类型，可能会有不止一种有意义的排序。例如，我们可能想按绝对值或实数对复数数据类型进行排序。为此，我们可以为数据类型定义两个运算符类，然后在创建索引时选择适当的类。有关运算符类的更多信息，请参见&lt;a href=&quot;indexes-opclass&quot;&gt;第11.10节&lt;/a&gt;和&lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html&quot;&gt;第37.16节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1cd3ddc4485e8a07b58b1b313130fa7a0d1e8729" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;operator class&lt;/em&gt; with optional parameters can be specified for each column of an index. The operator class identifies the operators to be used by the index for that column. For example, a B-tree index on four-byte integers would use the &lt;code&gt;int4_ops&lt;/code&gt; class; this operator class includes comparison functions for four-byte integers. In practice the default operator class for the column's data type is usually sufficient. The main point of having operator classes is that for some data types, there could be more than one meaningful ordering. For example, we might want to sort a complex-number data type either by absolute value or by real part. We could do this by defining two operator classes for the data type and then selecting the proper class when creating an index. More information about operator classes is in &lt;a href=&quot;indexes-opclass&quot;&gt;Section 11.10&lt;/a&gt; and in &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html&quot;&gt;Section 37.16&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48d61fa80ff015b13be4db7ffab694d479aec5c7" translate="yes" xml:space="preserve">
          <source>An ARE can begin with &lt;em&gt;embedded options&lt;/em&gt;: a sequence &lt;code&gt;(?&lt;/code&gt;&lt;code&gt;xyz&lt;/code&gt;&lt;code&gt;)&lt;/code&gt; (where &lt;code&gt;xyz&lt;/code&gt; is one or more alphabetic characters) specifies options affecting the rest of the RE. These options override any previously determined options &amp;mdash; in particular, they can override the case-sensitivity behavior implied by a regex operator, or the &lt;code&gt;flags&lt;/code&gt; parameter to a regex function. The available option letters are shown in &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.23&lt;/a&gt;. Note that these same option letters are used in the &lt;code&gt;flags&lt;/code&gt; parameters of regex functions.</source>
          <target state="translated">ARE可以从&lt;em&gt;嵌入式选项&lt;/em&gt;开始：序列 &lt;code&gt;(?&lt;/code&gt; &lt;code&gt;xyz&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; （其中 &lt;code&gt;xyz&lt;/code&gt; 是一个或多个字母字符）指定影响其余RE的选项。这些选项将覆盖所有先前确定的选项-特别是，它们可以覆盖正则表达式运算符或正则表达式函数的 &lt;code&gt;flags&lt;/code&gt; 参数所隐含的区分大小写行为。可用的选项字母如&lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;表9.23&lt;/a&gt;所示。请注意，这些相同的选项字母在正则表达式函数的 &lt;code&gt;flags&lt;/code&gt; 参数中使用。</target>
        </trans-unit>
        <trans-unit id="451a7edefd1d33d9d12316f5963ee8b77dc6c002" translate="yes" xml:space="preserve">
          <source>An ARE can begin with &lt;em&gt;embedded options&lt;/em&gt;: a sequence &lt;code&gt;(?&lt;/code&gt;&lt;code&gt;xyz&lt;/code&gt;&lt;code&gt;)&lt;/code&gt; (where &lt;code&gt;xyz&lt;/code&gt; is one or more alphabetic characters) specifies options affecting the rest of the RE. These options override any previously determined options &amp;mdash; in particular, they can override the case-sensitivity behavior implied by a regex operator, or the &lt;code&gt;flags&lt;/code&gt; parameter to a regex function. The available option letters are shown in &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.24&lt;/a&gt;. Note that these same option letters are used in the &lt;code&gt;flags&lt;/code&gt; parameters of regex functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8303919571de789ee40617113cb585782a02b887" translate="yes" xml:space="preserve">
          <source>An IP address range is specified using standard numeric notation for the range's starting address, then a slash (&lt;code&gt;/&lt;/code&gt;) and a CIDR mask length. The mask length indicates the number of high-order bits of the client IP address that must match. Bits to the right of this should be zero in the given IP address. There must not be any white space between the IP address, the &lt;code&gt;/&lt;/code&gt;, and the CIDR mask length.</source>
          <target state="translated">IP地址范围是使用标准数字符号指定范围的起始地址，然后是斜杠（ &lt;code&gt;/&lt;/code&gt; ）和CIDR掩码长度。掩码长度表示必须匹配的客户端IP地址的高位位数。在给定的IP地址中，其右边的位应为零。 IP地址， &lt;code&gt;/&lt;/code&gt; 和CIDR掩码长度之间不得有任何空格。</target>
        </trans-unit>
        <trans-unit id="4d44878e850b43c3405e5eb1f7f363ec736fdcdb" translate="yes" xml:space="preserve">
          <source>An RE can begin with one of two special &lt;em&gt;director&lt;/em&gt; prefixes. If an RE begins with &lt;code&gt;***:&lt;/code&gt;, the rest of the RE is taken as an ARE. (This normally has no effect in PostgreSQL, since REs are assumed to be AREs; but it does have an effect if ERE or BRE mode had been specified by the &lt;code&gt;flags&lt;/code&gt; parameter to a regex function.) If an RE begins with &lt;code&gt;***=&lt;/code&gt;, the rest of the RE is taken to be a literal string, with all characters considered ordinary characters.</source>
          <target state="translated">RE可以以两个特殊的&lt;em&gt;导演&lt;/em&gt;前缀之一开头。如果RE以 &lt;code&gt;***:&lt;/code&gt; 开头，则其余的RE将被视为ARE。（由于假定RE是ARE，因此在PostgreSQL中通常无效；但是，如果正则表达式函数的 &lt;code&gt;flags&lt;/code&gt; 参数指定了ERE或BRE模式，则它确实有效。）如果RE以 &lt;code&gt;***=&lt;/code&gt; 开头，其余的RE视为文字字符串，所有字符均视为普通字符。</target>
        </trans-unit>
        <trans-unit id="f92f9e66ed8af2bcc3cdde26f5c0bbb45e8250e2" translate="yes" xml:space="preserve">
          <source>An RE cannot end with a backslash (&lt;code&gt;\&lt;/code&gt;).</source>
          <target state="translated">RE不能以反斜杠（ &lt;code&gt;\&lt;/code&gt; ）结尾。</target>
        </trans-unit>
        <trans-unit id="081369b9016058fa6fc78b0eda53f1fad864ebdf" translate="yes" xml:space="preserve">
          <source>An RE consisting of two or more branches connected by the &lt;code&gt;|&lt;/code&gt; operator is always greedy.</source>
          <target state="translated">由两个或多个由 &lt;code&gt;|&lt;/code&gt; 连接的分支组成的RE 。操作员总是很贪婪。</target>
        </trans-unit>
        <trans-unit id="d49fecf670a244dc0b1f819b231bb69a34573ff1" translate="yes" xml:space="preserve">
          <source>An RFC 4516 LDAP URL. This is an alternative way to write some of the other LDAP options in a more compact and standard form. The format is</source>
          <target state="translated">一个RFC 4516 LDAP URL。这是一种以更紧凑、更标准的形式书写一些其他LDAP选项的替代方式。其格式是</target>
        </trans-unit>
        <trans-unit id="f7312c64a5fb73a6994e92da5b12fd76cc61e03e" translate="yes" xml:space="preserve">
          <source>An SHA1 hash of the random prefix and data is appended.</source>
          <target state="translated">随机前缀和数据的SHA1哈希值被附加。</target>
        </trans-unit>
        <trans-unit id="c3a965fc350f5f7dc5c4c1f8d246e2c0ef7db3f8" translate="yes" xml:space="preserve">
          <source>An SQL command that is used to allow a &lt;a href=&quot;glossary#GLOSSARY-USER&quot;&gt;user&lt;/a&gt; or &lt;a href=&quot;glossary#GLOSSARY-ROLE&quot;&gt;role&lt;/a&gt; to access specific objects within the &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6dc35165836f5ddf8c81146786e84d00be18739" translate="yes" xml:space="preserve">
          <source>An SQL command used to add new data into a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8802fb5ebf1fb183b8afc9517e0fb8a334aaa1ec" translate="yes" xml:space="preserve">
          <source>An SQL command used to modify &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;rows&lt;/a&gt; that may already exist in a specified &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt;. It cannot create or remove rows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2cced83fa51a6d9077bcc4256624ffa5277885e" translate="yes" xml:space="preserve">
          <source>An SQL command which removes &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;rows&lt;/a&gt; from a given &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; or &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0fe55953856dbcea542a9b75d2a05e987bd7029" translate="yes" xml:space="preserve">
          <source>An SQL statement defining an object to be created within the schema. Currently, only &lt;code&gt;CREATE TABLE&lt;/code&gt;, &lt;code&gt;CREATE VIEW&lt;/code&gt;, &lt;code&gt;CREATE INDEX&lt;/code&gt;, &lt;code&gt;CREATE SEQUENCE&lt;/code&gt;, &lt;code&gt;CREATE TRIGGER&lt;/code&gt; and &lt;code&gt;GRANT&lt;/code&gt; are accepted as clauses within &lt;code&gt;CREATE SCHEMA&lt;/code&gt;. Other kinds of objects may be created in separate commands after the schema is created.</source>
          <target state="translated">定义要在架构内创建的对象的SQL语句。当前，只有 &lt;code&gt;CREATE TABLE&lt;/code&gt; ， &lt;code&gt;CREATE VIEW&lt;/code&gt; ， &lt;code&gt;CREATE INDEX&lt;/code&gt; ， &lt;code&gt;CREATE SEQUENCE&lt;/code&gt; ， &lt;code&gt;CREATE TRIGGER&lt;/code&gt; 和 &lt;code&gt;GRANT&lt;/code&gt; 被接受为 &lt;code&gt;CREATE SCHEMA&lt;/code&gt; 中的子句。创建架构后，可以在单独的命令中创建其他类型的对象。</target>
        </trans-unit>
        <trans-unit id="48fae02660a1ba4984826c61b82cac7e0aec9ce9" translate="yes" xml:space="preserve">
          <source>An SQL/JSON path expression is typically written in an SQL query as an SQL character string literal, so it must be enclosed in single quotes, and any single quotes desired within the value must be doubled (see &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;Section 4.1.2.1&lt;/a&gt;). Some forms of path expressions require string literals within them. These embedded string literals follow JavaScript/ECMAScript conventions: they must be surrounded by double quotes, and backslash escapes may be used within them to represent otherwise-hard-to-type characters. In particular, the way to write a double quote within an embedded string literal is &lt;code&gt;\&quot;&lt;/code&gt;, and to write a backslash itself, you must write &lt;code&gt;\\&lt;/code&gt;. Other special backslash sequences include those recognized in JSON strings: &lt;code&gt;\b&lt;/code&gt;, &lt;code&gt;\f&lt;/code&gt;, &lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt;, &lt;code&gt;\t&lt;/code&gt;, &lt;code&gt;\v&lt;/code&gt; for various ASCII control characters, and &lt;code&gt;\uNNNN&lt;/code&gt; for a Unicode character identified by its 4-hex-digit code point. The backslash syntax also includes two cases not allowed by JSON: &lt;code&gt;\xNN&lt;/code&gt; for a character code written with only two hex digits, and &lt;code&gt;\u{N...}&lt;/code&gt; for a character code written with 1 to 6 hex digits.</source>
          <target state="translated">SQL / JSON路径表达式通常以SQL字符串文字形式写在SQL查询中，因此必须将其括在单引号中，并且值中所需的任何单引号必须加倍（请参见&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;4.1.2.1节&lt;/a&gt;）。某些形式的路径表达式需要在其中包含字符串文字。这些嵌入的字符串文字遵循JavaScript / ECMAScript约定：它们必须用双引号引起来，并且在其中可以使用反斜杠转义符来表示否则很难键入的字符。特别地，在嵌入式字符串文字中写双引号的方式是 &lt;code&gt;\&quot;&lt;/code&gt; ，而写反斜杠本身则必须写 &lt;code&gt;\\&lt;/code&gt; 。其他特殊的反斜杠序列包括JSON字符串中识别的那些： &lt;code&gt;\b&lt;/code&gt; ， &lt;code&gt;\f&lt;/code&gt; ， &lt;code&gt;\n&lt;/code&gt; ， &lt;code&gt;\r&lt;/code&gt; ， &lt;code&gt;\t&lt;/code&gt; ， &lt;code&gt;\v&lt;/code&gt; 表示各种ASCII控制字符，而 &lt;code&gt;\uNNNN&lt;/code&gt; 表示由4位十六进制代码点标识的Unicode字符。反斜杠语法还包括JSON不允许的两种情况： &lt;code&gt;\xNN&lt;/code&gt; 表示只用两个十六进制数字写的字符代码， &lt;code&gt;\u{N...}&lt;/code&gt; 表示只用1到6个十六进制数字写的字符代码。</target>
        </trans-unit>
        <trans-unit id="a47144dcc7f07df67a82e2f341e637ce0d341143" translate="yes" xml:space="preserve">
          <source>An additional caveat, if the goal is to avoid recalculating &lt;code&gt;f(x)&lt;/code&gt;, is that the planner won't necessarily match uses of &lt;code&gt;f(x)&lt;/code&gt; that aren't in indexable &lt;code&gt;WHERE&lt;/code&gt; clauses to the index column. It will usually get this right in simple queries such as shown above, but not in queries that involve joins. These deficiencies may be remedied in future versions of PostgreSQL.</source>
          <target state="translated">如果要避免重新计算 &lt;code&gt;f(x)&lt;/code&gt; ，则另外一个警告是，计划者不必将不在可索引 &lt;code&gt;WHERE&lt;/code&gt; 子句中的 &lt;code&gt;f(x)&lt;/code&gt; 用法与索引列匹配。通常，在如上所示的简单查询中，这样做会正确，但在涉及联接的查询中则不会。这些缺陷可以在PostgreSQL的未来版本中进行纠正。</target>
        </trans-unit>
        <trans-unit id="7407a4adf6d27ef60782fee33abc21dda639d1bb" translate="yes" xml:space="preserve">
          <source>An additional expectation is that &lt;code&gt;in_range&lt;/code&gt; functions should, if practical, avoid throwing an error if &lt;code&gt;base&lt;/code&gt;&lt;code&gt;+&lt;/code&gt;&lt;code&gt;offset&lt;/code&gt; or &lt;code&gt;base&lt;/code&gt;&lt;code&gt;-&lt;/code&gt;&lt;code&gt;offset&lt;/code&gt; would overflow. The correct comparison result can be determined even if that value would be out of the data type's range. Note that if the data type includes concepts such as &amp;ldquo;infinity&amp;rdquo; or &amp;ldquo;NaN&amp;rdquo;, extra care may be needed to ensure that &lt;code&gt;in_range&lt;/code&gt;'s results agree with the normal sort order of the operator family.</source>
          <target state="translated">另一个期望是，如果可行， &lt;code&gt;in_range&lt;/code&gt; 函数应避免在 &lt;code&gt;base&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;offset&lt;/code&gt; 或 &lt;code&gt;base&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; &lt;code&gt;offset&lt;/code&gt; 溢出时抛出错误。即使该值超出数据类型的范围，也可以确定正确的比较结果。请注意，如果数据类型包含诸如&amp;ldquo; infinity&amp;rdquo;或&amp;ldquo; NaN&amp;rdquo;之类的概念，则可能需要格外小心，以确保 &lt;code&gt;in_range&lt;/code&gt; 的结果与运算符族的正常排序顺序一致。</target>
        </trans-unit>
        <trans-unit id="eb253cb4aa708d5943b4ee75823919dac326e149" translate="yes" xml:space="preserve">
          <source>An additional heuristic provided by the parser allows improved determination of the proper casting behavior among groups of types that have implicit casts. Data types are divided into several basic &lt;em&gt;type categories&lt;/em&gt;, including &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;numeric&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;bitstring&lt;/code&gt;, &lt;code&gt;datetime&lt;/code&gt;, &lt;code&gt;timespan&lt;/code&gt;, &lt;code&gt;geometric&lt;/code&gt;, &lt;code&gt;network&lt;/code&gt;, and user-defined. (For a list see &lt;a href=&quot;catalog-pg-type#CATALOG-TYPCATEGORY-TABLE&quot;&gt;Table 51.63&lt;/a&gt;; but note it is also possible to create custom type categories.) Within each category there can be one or more &lt;em&gt;preferred types&lt;/em&gt;, which are preferred when there is a choice of possible types. With careful selection of preferred types and available implicit casts, it is possible to ensure that ambiguous expressions (those with multiple candidate parsing solutions) can be resolved in a useful way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="534defd7e745925ed14ebff65872ea3017b9134a" translate="yes" xml:space="preserve">
          <source>An additional heuristic provided by the parser allows improved determination of the proper casting behavior among groups of types that have implicit casts. Data types are divided into several basic &lt;em&gt;type categories&lt;/em&gt;, including &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;numeric&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;bitstring&lt;/code&gt;, &lt;code&gt;datetime&lt;/code&gt;, &lt;code&gt;timespan&lt;/code&gt;, &lt;code&gt;geometric&lt;/code&gt;, &lt;code&gt;network&lt;/code&gt;, and user-defined. (For a list see &lt;a href=&quot;catalog-pg-type#CATALOG-TYPCATEGORY-TABLE&quot;&gt;Table 51.64&lt;/a&gt;; but note it is also possible to create custom type categories.) Within each category there can be one or more &lt;em&gt;preferred types&lt;/em&gt;, which are preferred when there is a choice of possible types. With careful selection of preferred types and available implicit casts, it is possible to ensure that ambiguous expressions (those with multiple candidate parsing solutions) can be resolved in a useful way.</source>
          <target state="translated">解析器提供的其他启发式方法可以改进对具有隐式强制类型转换的类型组之间正确强制转换行为的确定。数据类型分为几个基本&lt;em&gt;类型类别&lt;/em&gt;，包括 &lt;code&gt;boolean&lt;/code&gt; ， &lt;code&gt;numeric&lt;/code&gt; ， &lt;code&gt;string&lt;/code&gt; ， &lt;code&gt;bitstring&lt;/code&gt; ， &lt;code&gt;datetime&lt;/code&gt; ， &lt;code&gt;timespan&lt;/code&gt; ， &lt;code&gt;geometric&lt;/code&gt; ， &lt;code&gt;network&lt;/code&gt; 和用户定义的。 （有关列表，请参阅&lt;a href=&quot;catalog-pg-type#CATALOG-TYPCATEGORY-TABLE&quot;&gt;表51.64&lt;/a&gt;；但是请注意，也可以创建自定义类型类别。）在每个类别中，可以有一个或多个&lt;em&gt;首选类型。&lt;/em&gt;，当可以选择可能的类型时首选。通过仔细选择首选类型和可用的隐式强制转换，可以确保可以用一种有用的方式来解决歧义表达式（具有多个候选解析解的表达式）。</target>
        </trans-unit>
        <trans-unit id="7fc0f4d6b418b13b44c7318de707eba4cc69a20d" translate="yes" xml:space="preserve">
          <source>An additional property of most of the OID alias types is the creation of dependencies. If a constant of one of these types appears in a stored expression (such as a column default expression or view), it creates a dependency on the referenced object. For example, if a column has a default expression &lt;code&gt;nextval('my_seq'::regclass)&lt;/code&gt;, PostgreSQL understands that the default expression depends on the sequence &lt;code&gt;my_seq&lt;/code&gt;; the system will not let the sequence be dropped without first removing the default expression. &lt;code&gt;regrole&lt;/code&gt; is the only exception for the property. Constants of this type are not allowed in such expressions.</source>
          <target state="translated">大多数OID别名类型的另一个属性是依赖关系的创建。如果这些类型之一的常量出现在存储的表达式（例如列默认表达式或视图）中，则它将创建对引用对象的依赖关系。例如，如果一列具有默认表达式 &lt;code&gt;nextval('my_seq'::regclass)&lt;/code&gt; ，则PostgreSQL理解默认表达式取决于序列 &lt;code&gt;my_seq&lt;/code&gt; ；在不先删除默认表达式的情况下，系统将不允许删除序列。 &lt;code&gt;regrole&lt;/code&gt; 是该属性的唯一例外。在此类表达式中不允许使用此类常量。</target>
        </trans-unit>
        <trans-unit id="458e50f0c0fe0a599acde7428114320c8fb97644" translate="yes" xml:space="preserve">
          <source>An aggregate can optionally support &lt;em&gt;moving-aggregate mode&lt;/em&gt;, as described in &lt;a href=&quot;https://www.postgresql.org/docs/12/xaggr.html#XAGGR-MOVING-AGGREGATES&quot;&gt;Section 37.12.1&lt;/a&gt;. This requires specifying the &lt;code&gt;MSFUNC&lt;/code&gt;, &lt;code&gt;MINVFUNC&lt;/code&gt;, and &lt;code&gt;MSTYPE&lt;/code&gt; parameters, and optionally the &lt;code&gt;MSSPACE&lt;/code&gt;, &lt;code&gt;MFINALFUNC&lt;/code&gt;, &lt;code&gt;MFINALFUNC_EXTRA&lt;/code&gt;, &lt;code&gt;MFINALFUNC_MODIFY&lt;/code&gt;, and &lt;code&gt;MINITCOND&lt;/code&gt; parameters. Except for &lt;code&gt;MINVFUNC&lt;/code&gt;, these parameters work like the corresponding simple-aggregate parameters without &lt;code&gt;M&lt;/code&gt;; they define a separate implementation of the aggregate that includes an inverse transition function.</source>
          <target state="translated">聚合可以选择支持&lt;em&gt;移动聚合模式&lt;/em&gt;，如&lt;a href=&quot;https://www.postgresql.org/docs/12/xaggr.html#XAGGR-MOVING-AGGREGATES&quot;&gt;第37.12.1节中所述&lt;/a&gt;。这需要指定 &lt;code&gt;MSFUNC&lt;/code&gt; ， &lt;code&gt;MINVFUNC&lt;/code&gt; 和 &lt;code&gt;MSTYPE&lt;/code&gt; 参数，以及可选的 &lt;code&gt;MSSPACE&lt;/code&gt; ， &lt;code&gt;MFINALFUNC&lt;/code&gt; ， &lt;code&gt;MFINALFUNC_EXTRA&lt;/code&gt; ， &lt;code&gt;MFINALFUNC_MODIFY&lt;/code&gt; 和 &lt;code&gt;MINITCOND&lt;/code&gt; 参数。除了 &lt;code&gt;MINVFUNC&lt;/code&gt; 以外，这些参数的工作方式与不带 &lt;code&gt;M&lt;/code&gt; 的相应简单聚合参数相同；它们定义了包含逆转换函数的聚合的单独实现。</target>
        </trans-unit>
        <trans-unit id="29fb09a88b1e0b362734b37fcd73ac91f7b1c450" translate="yes" xml:space="preserve">
          <source>An aggregate can optionally support &lt;em&gt;moving-aggregate mode&lt;/em&gt;, as described in &lt;a href=&quot;https://www.postgresql.org/docs/13/xaggr.html#XAGGR-MOVING-AGGREGATES&quot;&gt;Section 37.12.1&lt;/a&gt;. This requires specifying the &lt;code&gt;MSFUNC&lt;/code&gt;, &lt;code&gt;MINVFUNC&lt;/code&gt;, and &lt;code&gt;MSTYPE&lt;/code&gt; parameters, and optionally the &lt;code&gt;MSSPACE&lt;/code&gt;, &lt;code&gt;MFINALFUNC&lt;/code&gt;, &lt;code&gt;MFINALFUNC_EXTRA&lt;/code&gt;, &lt;code&gt;MFINALFUNC_MODIFY&lt;/code&gt;, and &lt;code&gt;MINITCOND&lt;/code&gt; parameters. Except for &lt;code&gt;MINVFUNC&lt;/code&gt;, these parameters work like the corresponding simple-aggregate parameters without &lt;code&gt;M&lt;/code&gt;; they define a separate implementation of the aggregate that includes an inverse transition function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d679ad2d9aaa3f73ccadb1adf16347c9d1df070" translate="yes" xml:space="preserve">
          <source>An aggregate can optionally support &lt;em&gt;partial aggregation&lt;/em&gt;, as described in &lt;a href=&quot;https://www.postgresql.org/docs/12/xaggr.html#XAGGR-PARTIAL-AGGREGATES&quot;&gt;Section 37.12.4&lt;/a&gt;. This requires specifying the &lt;code&gt;COMBINEFUNC&lt;/code&gt; parameter. If the &lt;code&gt;state_data_type&lt;/code&gt; is &lt;code&gt;internal&lt;/code&gt;, it's usually also appropriate to provide the &lt;code&gt;SERIALFUNC&lt;/code&gt; and &lt;code&gt;DESERIALFUNC&lt;/code&gt; parameters so that parallel aggregation is possible. Note that the aggregate must also be marked &lt;code&gt;PARALLEL SAFE&lt;/code&gt; to enable parallel aggregation.</source>
          <target state="translated">聚合可以选择支持&lt;em&gt;部分聚合&lt;/em&gt;，如&lt;a href=&quot;https://www.postgresql.org/docs/12/xaggr.html#XAGGR-PARTIAL-AGGREGATES&quot;&gt;第37.12.4节所述&lt;/a&gt;。这需要指定 &lt;code&gt;COMBINEFUNC&lt;/code&gt; 参数。如果 &lt;code&gt;state_data_type&lt;/code&gt; 是 &lt;code&gt;internal&lt;/code&gt; ，则通常还应该提供 &lt;code&gt;SERIALFUNC&lt;/code&gt; 和 &lt;code&gt;DESERIALFUNC&lt;/code&gt; 参数，以便可以进行并行聚合。请注意，还必须将聚合标记为 &lt;code&gt;PARALLEL SAFE&lt;/code&gt; 才能启用并行聚合。</target>
        </trans-unit>
        <trans-unit id="f7e84609c5356ef9572b92f634b5a8669d5cf54b" translate="yes" xml:space="preserve">
          <source>An aggregate can optionally support &lt;em&gt;partial aggregation&lt;/em&gt;, as described in &lt;a href=&quot;https://www.postgresql.org/docs/13/xaggr.html#XAGGR-PARTIAL-AGGREGATES&quot;&gt;Section 37.12.4&lt;/a&gt;. This requires specifying the &lt;code&gt;COMBINEFUNC&lt;/code&gt; parameter. If the &lt;code&gt;state_data_type&lt;/code&gt; is &lt;code&gt;internal&lt;/code&gt;, it's usually also appropriate to provide the &lt;code&gt;SERIALFUNC&lt;/code&gt; and &lt;code&gt;DESERIALFUNC&lt;/code&gt; parameters so that parallel aggregation is possible. Note that the aggregate must also be marked &lt;code&gt;PARALLEL SAFE&lt;/code&gt; to enable parallel aggregation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dfc7ac5613e772bc99452f1945c3b220614eb51" translate="yes" xml:space="preserve">
          <source>An aggregate expression</source>
          <target state="translated">一个集合表达式</target>
        </trans-unit>
        <trans-unit id="e0807075b6b78aa07561f78a847dd6293e2860ad" translate="yes" xml:space="preserve">
          <source>An aggregate expression can only appear in the result list or &lt;code&gt;HAVING&lt;/code&gt; clause of a &lt;code&gt;SELECT&lt;/code&gt; command. It is forbidden in other clauses, such as &lt;code&gt;WHERE&lt;/code&gt;, because those clauses are logically evaluated before the results of aggregates are formed.</source>
          <target state="translated">聚合表达式只能出现在 &lt;code&gt;SELECT&lt;/code&gt; 命令的结果列表或 &lt;code&gt;HAVING&lt;/code&gt; 子句中。在其他子句（例如 &lt;code&gt;WHERE&lt;/code&gt; ）中禁止使用该子句，因为这些子句是在形成聚合结果之前进行逻辑评估的。</target>
        </trans-unit>
        <trans-unit id="d5cc6417758e002213e0379735846ccb8b7a9410" translate="yes" xml:space="preserve">
          <source>An aggregate function can provide an initial condition, that is, an initial value for the internal state value. This is specified and stored in the database as a value of type &lt;code&gt;text&lt;/code&gt;, but it must be a valid external representation of a constant of the state value data type. If it is not supplied then the state value starts out null.</source>
          <target state="translated">聚合函数可以提供初始条件，即内部状态值的初始值。它是作为 &lt;code&gt;text&lt;/code&gt; 类型的值指定并存储在数据库中的，但是它必须是状态值数据类型的常量的有效外部表示形式。如果未提供，则状态值开始为null。</target>
        </trans-unit>
        <trans-unit id="4c0a9d3ddcc76a8af6ce90bf3fe2aed9cae7fe77" translate="yes" xml:space="preserve">
          <source>An aggregate function is identified by its name and input data type(s). Two aggregates in the same schema can have the same name if they operate on different input types. The name and input data type(s) of an aggregate must also be distinct from the name and input data type(s) of every ordinary function in the same schema. This behavior is identical to overloading of ordinary function names (see &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;).</source>
          <target state="translated">聚合函数通过其名称和输入数据类型进行标识。如果同一聚合中的两个聚合操作不同的输入类型，则它们可以具有相同的名称。集合的名称和输入数据类型还必须与同一模式中每个普通函数的名称和输入数据类型不同。此行为与重载普通函数名称相同（请参见&lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2b3e0e3a20d60ad454bd8cd7d186466b528e1274" translate="yes" xml:space="preserve">
          <source>An aggregate function whose &lt;code&gt;state_data_type&lt;/code&gt; is &lt;code&gt;internal&lt;/code&gt; can participate in parallel aggregation only if it has a &lt;code&gt;serialfunc&lt;/code&gt; function, which must serialize the aggregate state into a &lt;code&gt;bytea&lt;/code&gt; value for transmission to another process. This function must take a single argument of type &lt;code&gt;internal&lt;/code&gt; and return type &lt;code&gt;bytea&lt;/code&gt;. A corresponding &lt;code&gt;deserialfunc&lt;/code&gt; is also required.</source>
          <target state="translated">一个集合函数，其 &lt;code&gt;state_data_type&lt;/code&gt; 是 &lt;code&gt;internal&lt;/code&gt; 可以参与聚合平行仅当它具有 &lt;code&gt;serialfunc&lt;/code&gt; 函数，它必须序列聚集状态成 &lt;code&gt;bytea&lt;/code&gt; 用于传输到另一个的过程值。该函数必须接受一个类型为 &lt;code&gt;internal&lt;/code&gt; 的单个参数，并返回类型为 &lt;code&gt;bytea&lt;/code&gt; 的参数。还需要相应的 &lt;code&gt;deserialfunc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="df00344c6606cf49c7be60428adf4c46220a9708" translate="yes" xml:space="preserve">
          <source>An alias can be provided in the same way as for a table. If an alias is written, a column alias list can also be written to provide substitute names for one or more attributes of the function's composite return type, including the column added by &lt;code&gt;ORDINALITY&lt;/code&gt; if present.</source>
          <target state="translated">可以使用与表相同的方式提供别名。如果编写了别名，则还可以编写列别名列表以提供函数复合返回类型的一个或多个属性的替代名称，包括由 &lt;code&gt;ORDINALITY&lt;/code&gt; 添加的列（如果存在）。</target>
        </trans-unit>
        <trans-unit id="a0250a12b43f45cb324a618ef9cdbd68812da4e5" translate="yes" xml:space="preserve">
          <source>An alternative backup strategy is to directly copy the files that PostgreSQL uses to store the data in the database; &lt;a href=&quot;creating-cluster&quot;&gt;Section 18.2&lt;/a&gt; explains where these files are located. You can use whatever method you prefer for doing file system backups; for example:</source>
          <target state="translated">另一种备份策略是直接复制PostgreSQL用于将数据存储在数据库中的文件。&lt;a href=&quot;creating-cluster&quot;&gt;第18.2节&lt;/a&gt;介绍了这些文件的位置。您可以使用自己喜欢的任何方法进行文件系统备份。例如：</target>
        </trans-unit>
        <trans-unit id="b61de693c26d02887a03f9b9c2b1cd2f4c796982" translate="yes" xml:space="preserve">
          <source>An alternative file-system backup approach is to make a &amp;ldquo;consistent snapshot&amp;rdquo; of the data directory, if the file system supports that functionality (and you are willing to trust that it is implemented correctly). The typical procedure is to make a &amp;ldquo;frozen snapshot&amp;rdquo; of the volume containing the database, then copy the whole data directory (not just parts, see above) from the snapshot to a backup device, then release the frozen snapshot. This will work even while the database server is running. However, a backup created in this way saves the database files in a state as if the database server was not properly shut down; therefore, when you start the database server on the backed-up data, it will think the previous server instance crashed and will replay the WAL log. This is not a problem; just be aware of it (and be sure to include the WAL files in your backup). You can perform a &lt;code&gt;CHECKPOINT&lt;/code&gt; before taking the snapshot to reduce recovery time.</source>
          <target state="translated">另一种文件系统备份方法是，如果文件系统支持该功能（并且您愿意相信它已正确实现），则为数据目录创建&amp;ldquo;一致的快照&amp;rdquo;。典型的过程是制作包含数据库的卷的&amp;ldquo;冻结快照&amp;rdquo;，然后将整个数据目录（不仅仅是部分，请参见上文）从快照复制到备份设备，然后释放冻结快照。即使数据库服务器正在运行，这也将起作用。但是，以这种方式创建的备份会将数据库文件保存为某种状态，就好像数据库服务器未正确关闭一样。因此，当您在备份的数据上启动数据库服务器时，它将认为先前的服务器实例崩溃了，并且将重播WAL日志。这不是问题;请注意这一点（并确保在备份中包含WAL文件）。您可以执行 &lt;code&gt;CHECKPOINT&lt;/code&gt; 采取快照，以减少恢复时间之前。</target>
        </trans-unit>
        <trans-unit id="c3c3283b5d81a417bf78d55aa00de334b32f532e" translate="yes" xml:space="preserve">
          <source>An alternative syntax, which conforms to the SQL standard by using the keyword &lt;code&gt;ARRAY&lt;/code&gt;, can be used for one-dimensional arrays. &lt;code&gt;pay_by_quarter&lt;/code&gt; could have been defined as:</source>
          <target state="translated">通过使用关键字 &lt;code&gt;ARRAY&lt;/code&gt; 符合SQL标准的另一种语法可以用于一维数组。 &lt;code&gt;pay_by_quarter&lt;/code&gt; 本可以定义为：</target>
        </trans-unit>
        <trans-unit id="638c7c832e5e9b62d5fb5f6d733b2905e931d645" translate="yes" xml:space="preserve">
          <source>An alternative to the built-in standby mode described in the previous sections is to use a &lt;code&gt;restore_command&lt;/code&gt; that polls the archive location. This was the only option available in versions 8.4 and below. See the &lt;a href=&quot;https://www.postgresql.org/docs/12/pgstandby.html&quot;&gt;pg_standby&lt;/a&gt; module for a reference implementation of this.</source>
          <target state="translated">前面各节中描述的内置备用模式的替代方法是使用 &lt;code&gt;restore_command&lt;/code&gt; 来轮询存档位置。这是8.4及以下版本中唯一可用的选项。有关此&lt;a href=&quot;https://www.postgresql.org/docs/12/pgstandby.html&quot;&gt;方法&lt;/a&gt;的参考实现，请参见pg_standby模块。</target>
        </trans-unit>
        <trans-unit id="a8b7165adb636504ac5f79579ceffb000f734741" translate="yes" xml:space="preserve">
          <source>An alternative to the built-in standby mode described in the previous sections is to use a &lt;code&gt;restore_command&lt;/code&gt; that polls the archive location. This was the only option available in versions 8.4 and below. See the &lt;a href=&quot;https://www.postgresql.org/docs/13/pgstandby.html&quot;&gt;pg_standby&lt;/a&gt; module for a reference implementation of this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa59772716d4044140c10df2d8b7a5924c081417" translate="yes" xml:space="preserve">
          <source>An alternative way to specify connection parameters is in a &lt;em&gt;&lt;code&gt;conninfo&lt;/code&gt;&lt;/em&gt; string or a URI, which is used instead of a database name. This mechanism give you very wide control over the connection. For example:</source>
          <target state="translated">指定连接参数的另一种方法是使用&lt;em&gt; &lt;code&gt;conninfo&lt;/code&gt; &lt;/em&gt;字符串或URI，而不是使用数据库名称。此机制使您可以非常广泛地控制连接。例如：</target>
        </trans-unit>
        <trans-unit id="8ec33e5bc23fcb877ba4c42aa95a3a9f21f59a6d" translate="yes" xml:space="preserve">
          <source>An arbitrary identifier that later identifies this transaction for &lt;code&gt;COMMIT PREPARED&lt;/code&gt; or &lt;code&gt;ROLLBACK PREPARED&lt;/code&gt;. The identifier must be written as a string literal, and must be less than 200 bytes long. It must not be the same as the identifier used for any currently prepared transaction.</source>
          <target state="translated">稍后将此事务标识为 &lt;code&gt;COMMIT PREPARED&lt;/code&gt; 或 &lt;code&gt;ROLLBACK PREPARED&lt;/code&gt; 的任意标识符。标识符必须以字符串文字形式编写，并且必须小于200个字节。它不能与用于任何当前准备的事务的标识符相同。</target>
        </trans-unit>
        <trans-unit id="154d8a4c4e542e35a1befe68e1484bcdb9bfce9b" translate="yes" xml:space="preserve">
          <source>An arbitrary name given to this particular prepared statement. It must be unique within a single session and is subsequently used to execute or deallocate a previously prepared statement.</source>
          <target state="translated">给这个特定的已准备好的语句的任意名称。该名称在一个会话中必须是唯一的,随后用于执行或重新分配先前准备的语句。</target>
        </trans-unit>
        <trans-unit id="8cfd518cee734d4e6e12ef304061cfa2c5efcc5d" translate="yes" xml:space="preserve">
          <source>An array can also be constructed by using the functions &lt;code&gt;array_prepend&lt;/code&gt;, &lt;code&gt;array_append&lt;/code&gt;, or &lt;code&gt;array_cat&lt;/code&gt;. The first two only support one-dimensional arrays, but &lt;code&gt;array_cat&lt;/code&gt; supports multidimensional arrays. Some examples:</source>
          <target state="translated">也可以使用 &lt;code&gt;array_prepend&lt;/code&gt; ， &lt;code&gt;array_append&lt;/code&gt; 或 &lt;code&gt;array_cat&lt;/code&gt; 函数构造一个数组。前两个仅支持一维数组，但是 &lt;code&gt;array_cat&lt;/code&gt; 支持多维数组。一些例子：</target>
        </trans-unit>
        <trans-unit id="b9253fad046b597c92ebf100d62457d49600956f" translate="yes" xml:space="preserve">
          <source>An array can also be updated at a single element:</source>
          <target state="translated">一个数组也可以在单个元素上进行更新。</target>
        </trans-unit>
        <trans-unit id="207ba5c2689d9a2decbdf9a201e85765c620f79a" translate="yes" xml:space="preserve">
          <source>An array constructor</source>
          <target state="translated">一个数组构造函数</target>
        </trans-unit>
        <trans-unit id="22dde08afcbb8b9d32ea23d688400ce811c7d712" translate="yes" xml:space="preserve">
          <source>An array constructor is an expression that builds an array value using values for its member elements. A simple array constructor consists of the key word &lt;code&gt;ARRAY&lt;/code&gt;, a left square bracket &lt;code&gt;[&lt;/code&gt;, a list of expressions (separated by commas) for the array element values, and finally a right square bracket &lt;code&gt;]&lt;/code&gt;. For example:</source>
          <target state="translated">数组构造函数是一个表达式，该表达式使用其成员元素的值构建数组值。一个简单的数组构造函数由关键字 &lt;code&gt;ARRAY&lt;/code&gt; ，左方括号 &lt;code&gt;[&lt;/code&gt; ，用于数组元素值的表达式列表（用逗号分隔）和最后一个右方括号 &lt;code&gt;]&lt;/code&gt; 组成。例如：</target>
        </trans-unit>
        <trans-unit id="7dbcd90a7826ddce4d84f03c4037551f65cc619b" translate="yes" xml:space="preserve">
          <source>An array containing codes for the enabled statistic kinds; valid values are: &lt;code&gt;d&lt;/code&gt; for n-distinct statistics, &lt;code&gt;f&lt;/code&gt; for functional dependency statistics, and &lt;code&gt;m&lt;/code&gt; for most common values (MCV) list statistics</source>
          <target state="translated">一个数组，其中包含启用的统计类型的代码；有效值是： &lt;code&gt;d&lt;/code&gt; 用于n个不同统计量， &lt;code&gt;f&lt;/code&gt; 用于功能相关性统计量， &lt;code&gt;m&lt;/code&gt; 用于最常用值（MCV）列表统计量</target>
        </trans-unit>
        <trans-unit id="27ac7c03cbb87eb7b9fd6d5d5942fb204a13357b" translate="yes" xml:space="preserve">
          <source>An array containing the IDs of the roles in this group</source>
          <target state="translated">包含该组角色ID的数组。</target>
        </trans-unit>
        <trans-unit id="96036220e810514b07282609308d02f0cce74ab2" translate="yes" xml:space="preserve">
          <source>An array of attribute numbers, indicating which table columns are covered by this statistics object; for example a value of &lt;code&gt;1 3&lt;/code&gt; would mean that the first and the third table columns are covered</source>
          <target state="translated">属性编号数组，指示此统计信息对象覆盖哪些表列；例如，值 &lt;code&gt;1 3&lt;/code&gt; 表示覆盖了第一和第三表列</target>
        </trans-unit>
        <trans-unit id="b19c35ad447cc03eaa08f8712bc2b7258decc833" translate="yes" xml:space="preserve">
          <source>An array slice expression likewise yields null if the array itself or any of the subscript expressions are null. However, in other cases such as selecting an array slice that is completely outside the current array bounds, a slice expression yields an empty (zero-dimensional) array instead of null. (This does not match non-slice behavior and is done for historical reasons.) If the requested slice partially overlaps the array bounds, then it is silently reduced to just the overlapping region instead of returning null.</source>
          <target state="translated">如果数组本身或任何下标表达式为空,数组分片表达式同样会产生空。然而,在其他情况下,例如选择一个完全在当前数组边界之外的数组分片,分片表达式会产生一个空的(零维)数组,而不是null(这与非分片行为不一致,是出于历史原因)。(这与非分片行为不一致,是出于历史原因。)如果请求的分片部分与数组边界重叠,那么它将被静默地缩减到只有重叠区域,而不是返回空。</target>
        </trans-unit>
        <trans-unit id="1acc2bad9c714dff64f3a38358f5e30f839c8b6c" translate="yes" xml:space="preserve">
          <source>An array subscript expression will return null if either the array itself or any of the subscript expressions are null. Also, null is returned if a subscript is outside the array bounds (this case does not raise an error). For example, if &lt;code&gt;schedule&lt;/code&gt; currently has the dimensions &lt;code&gt;[1:3][1:2]&lt;/code&gt; then referencing &lt;code&gt;schedule[3][3]&lt;/code&gt; yields NULL. Similarly, an array reference with the wrong number of subscripts yields a null rather than an error.</source>
          <target state="translated">如果数组本身或任何下标表达式为null，则数组下标表达式将返回null。另外，如果下标超出数组范围，则返回null（这种情况不会引发错误）。例如，如果 &lt;code&gt;schedule&lt;/code&gt; 当前具有维度 &lt;code&gt;[1:3][1:2]&lt;/code&gt; ,则引用 &lt;code&gt;schedule[3][3]&lt;/code&gt; 产生NULL。同样，下标数目错误的数组引用会产生null而不是错误。</target>
        </trans-unit>
        <trans-unit id="0832096d10a386e248df7b28cfa12adfe25aab94" translate="yes" xml:space="preserve">
          <source>An array value can be replaced completely:</source>
          <target state="translated">一个数组的值可以被完全替换。</target>
        </trans-unit>
        <trans-unit id="af4fc25fcb8b1fcdab019c9c24576221478e42a1" translate="yes" xml:space="preserve">
          <source>An array with the data types of the function arguments. This includes all arguments (including &lt;code&gt;OUT&lt;/code&gt; and &lt;code&gt;INOUT&lt;/code&gt; arguments); however, if all the arguments are &lt;code&gt;IN&lt;/code&gt; arguments, this field will be null. Note that subscripting is 1-based, whereas for historical reasons &lt;code&gt;proargtypes&lt;/code&gt; is subscripted from 0.</source>
          <target state="translated">具有函数参数的数据类型的数组。这包括所有参数（包括 &lt;code&gt;OUT&lt;/code&gt; 和 &lt;code&gt;INOUT&lt;/code&gt; 参数）；但是，如果所有参数均为 &lt;code&gt;IN&lt;/code&gt; 参数，则此字段为null。请注意，下标是从1开始的，而由于历史原因， &lt;code&gt;proargtypes&lt;/code&gt; 是从0下标的。</target>
        </trans-unit>
        <trans-unit id="b1056fb2643af14679cc3ecd97ee8851fd6939a7" translate="yes" xml:space="preserve">
          <source>An array with the data types of the function arguments. This includes only input arguments (including &lt;code&gt;INOUT&lt;/code&gt; and &lt;code&gt;VARIADIC&lt;/code&gt; arguments), and thus represents the call signature of the function.</source>
          <target state="translated">具有函数参数的数据类型的数组。这仅包括输入参数（包括 &lt;code&gt;INOUT&lt;/code&gt; 和 &lt;code&gt;VARIADIC&lt;/code&gt; 参数），因此代表函数的调用签名。</target>
        </trans-unit>
        <trans-unit id="56e64d796da368f4732fec1eac245d18f34b8c2b" translate="yes" xml:space="preserve">
          <source>An array with the modes of the function arguments, encoded as &lt;code&gt;i&lt;/code&gt; for &lt;code&gt;IN&lt;/code&gt; arguments, &lt;code&gt;o&lt;/code&gt; for &lt;code&gt;OUT&lt;/code&gt; arguments, &lt;code&gt;b&lt;/code&gt; for &lt;code&gt;INOUT&lt;/code&gt; arguments, &lt;code&gt;v&lt;/code&gt; for &lt;code&gt;VARIADIC&lt;/code&gt; arguments, &lt;code&gt;t&lt;/code&gt; for &lt;code&gt;TABLE&lt;/code&gt; arguments. If all the arguments are &lt;code&gt;IN&lt;/code&gt; arguments, this field will be null. Note that subscripts correspond to positions of &lt;code&gt;proallargtypes&lt;/code&gt; not &lt;code&gt;proargtypes&lt;/code&gt;.</source>
          <target state="translated">具有函数参数模式的数组，编码为 &lt;code&gt;i&lt;/code&gt; 表示 &lt;code&gt;IN&lt;/code&gt; 参数， &lt;code&gt;o&lt;/code&gt; 表示 &lt;code&gt;OUT&lt;/code&gt; 参数， &lt;code&gt;b&lt;/code&gt; 表示 &lt;code&gt;INOUT&lt;/code&gt; 参数， &lt;code&gt;v&lt;/code&gt; 表示 &lt;code&gt;VARIADIC&lt;/code&gt; 参数， &lt;code&gt;t&lt;/code&gt; 表示 &lt;code&gt;TABLE&lt;/code&gt; 参数。如果所有参数均为 &lt;code&gt;IN&lt;/code&gt; 参数，则此字段为null。请注意，下标对应于 &lt;code&gt;proallargtypes&lt;/code&gt; 而不是 &lt;code&gt;proargtypes&lt;/code&gt; 的位置。</target>
        </trans-unit>
        <trans-unit id="19750404179dcfe4198dc9453208db71584c69d3" translate="yes" xml:space="preserve">
          <source>An array with the names of the function arguments. Arguments without a name are set to empty strings in the array. If none of the arguments have a name, this field will be null. Note that subscripts correspond to positions of &lt;code&gt;proallargtypes&lt;/code&gt; not &lt;code&gt;proargtypes&lt;/code&gt;.</source>
          <target state="translated">具有函数参数名称的数组。没有名称的参数在数组中设置为空字符串。如果所有参数都没有名称，则此字段为null。请注意，下标对应于 &lt;code&gt;proallargtypes&lt;/code&gt; 而不是 &lt;code&gt;proargtypes&lt;/code&gt; 的位置。</target>
        </trans-unit>
        <trans-unit id="f01a907c7341c3e9fdd4bc077438737e13efc650" translate="yes" xml:space="preserve">
          <source>An asterisk (&lt;code&gt;*&lt;/code&gt;) can be placed at the end of a synonym in the configuration file. This indicates that the synonym is a prefix. The asterisk is ignored when the entry is used in &lt;code&gt;to_tsvector()&lt;/code&gt;, but when it is used in &lt;code&gt;to_tsquery()&lt;/code&gt;, the result will be a query item with the prefix match marker (see &lt;a href=&quot;textsearch-controls#TEXTSEARCH-PARSING-QUERIES&quot;&gt;Section 12.3.2&lt;/a&gt;). For example, suppose we have these entries in &lt;code&gt;$SHAREDIR/tsearch_data/synonym_sample.syn&lt;/code&gt;:</source>
          <target state="translated">可以在配置文件中的同义词末尾添加星号（ &lt;code&gt;*&lt;/code&gt; ）。这表明同义词是前缀。当在 &lt;code&gt;to_tsvector()&lt;/code&gt; 中使用该条目时，将忽略星号，但是在 &lt;code&gt;to_tsquery()&lt;/code&gt; 中使用该条目时，结果将是带有前缀匹配标记的查询项（请参见&lt;a href=&quot;textsearch-controls#TEXTSEARCH-PARSING-QUERIES&quot;&gt;第12.3.2节&lt;/a&gt;）。例如，假设我们在 &lt;code&gt;$SHAREDIR/tsearch_data/synonym_sample.syn&lt;/code&gt; 具有以下条目：</target>
        </trans-unit>
        <trans-unit id="c86af8f966441072cea93666c92eea93103579c8" translate="yes" xml:space="preserve">
          <source>An automatically updatable view may contain a mix of updatable and non-updatable columns. A column is updatable if it is a simple reference to an updatable column of the underlying base relation; otherwise the column is read-only, and an error will be raised if an &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; statement attempts to assign a value to it.</source>
          <target state="translated">自动更新的视图可能包含可更新列和不可更新列的混合。如果列是对基础基础关系的可更新列的简单引用，则该列是可更新的；否则，该列为只读，并且如果 &lt;code&gt;INSERT&lt;/code&gt; 或 &lt;code&gt;UPDATE&lt;/code&gt; 语句尝试为其分配值，则会引发错误。</target>
        </trans-unit>
        <trans-unit id="e72cb7e6b41938a2b612c62d6738c18d8f8e1034" translate="yes" xml:space="preserve">
          <source>An element with a certain name and data type found within a &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;tuple&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13229daa72676e5cc65b4f01d9a20d25d5a2a7d0" translate="yes" xml:space="preserve">
          <source>An encrypted PGP message consists of 2 parts, or &lt;em&gt;packets&lt;/em&gt;:</source>
          <target state="translated">加密的PGP消息由2部分或&lt;em&gt;数据包组成&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="09f724c84938e490e8dc9343f32211856b8b0d2e" translate="yes" xml:space="preserve">
          <source>An entry given in IPv4 format will match only IPv4 connections, and an entry given in IPv6 format will match only IPv6 connections, even if the represented address is in the IPv4-in-IPv6 range. Note that entries in IPv6 format will be rejected if the system's C library does not have support for IPv6 addresses.</source>
          <target state="translated">以IPv4格式给出的条目将只匹配IPv4连接,以IPv6格式给出的条目将只匹配IPv6连接,即使代表的地址在IPv4-in-IPv6范围内。注意,如果系统的C库不支持IPv6地址,IPv6格式的条目将被拒绝。</target>
        </trans-unit>
        <trans-unit id="938494e5885c658c095719a63c4ba845fac9421d" translate="yes" xml:space="preserve">
          <source>An entry's &lt;code&gt;amopmethod&lt;/code&gt; must match the &lt;code&gt;opfmethod&lt;/code&gt; of its containing operator family (including &lt;code&gt;amopmethod&lt;/code&gt; here is an intentional denormalization of the catalog structure for performance reasons). Also, &lt;code&gt;amoplefttype&lt;/code&gt; and &lt;code&gt;amoprighttype&lt;/code&gt; must match the &lt;code&gt;oprleft&lt;/code&gt; and &lt;code&gt;oprright&lt;/code&gt; fields of the referenced &lt;code&gt;pg_operator&lt;/code&gt; entry.</source>
          <target state="translated">一个条目的 &lt;code&gt;amopmethod&lt;/code&gt; 必须匹配 &lt;code&gt;opfmethod&lt;/code&gt; 其包含运营商的家庭（包括 &lt;code&gt;amopmethod&lt;/code&gt; 这里是目录结构的性能方面的原因故意非规范化）。另外， &lt;code&gt;amoplefttype&lt;/code&gt; 和 &lt;code&gt;amoprighttype&lt;/code&gt; 必须与引用的 &lt;code&gt;pg_operator&lt;/code&gt; 条目的 &lt;code&gt;oprleft&lt;/code&gt; 和 &lt;code&gt;oprright&lt;/code&gt; 字段匹配。</target>
        </trans-unit>
        <trans-unit id="d1d1086ba8d92dc57d5ff412fcf067dd0fa10959" translate="yes" xml:space="preserve">
          <source>An enum value occupies four bytes on disk. The length of an enum value's textual label is limited by the &lt;code&gt;NAMEDATALEN&lt;/code&gt; setting compiled into PostgreSQL; in standard builds this means at most 63 bytes.</source>
          <target state="translated">枚举值在磁盘上占用四个字节。枚举值的文本标签的长度受编译到PostgreSQL中的 &lt;code&gt;NAMEDATALEN&lt;/code&gt; 设置的限制；在标准版本中，这意味着最多63个字节。</target>
        </trans-unit>
        <trans-unit id="7d926b20cea28dde9ab53148cbd01bb72e3b71c1" translate="yes" xml:space="preserve">
          <source>An error like:</source>
          <target state="translated">这样的错误。</target>
        </trans-unit>
        <trans-unit id="1642e5d8f757211902e7fce377a379427b2967a5" translate="yes" xml:space="preserve">
          <source>An established line of communication between a client process and a &lt;a href=&quot;glossary#GLOSSARY-BACKEND&quot;&gt;backend&lt;/a&gt; process, usually over a network, supporting a &lt;a href=&quot;glossary#GLOSSARY-SESSION&quot;&gt;session&lt;/a&gt;. This term is sometimes used as a synonym for session.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73f7ed75cabe931d593b5e23922ed970c7f9a2c6" translate="yes" xml:space="preserve">
          <source>An event trigger function is declared to return &lt;code&gt;event_trigger.&lt;/code&gt;</source>
          <target state="translated">声明了一个事件触发函数以返回 &lt;code&gt;event_trigger.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e5d03b1b3e9330df5ef72cedfa521226e3904563" translate="yes" xml:space="preserve">
          <source>An example command to insert a row would be:</source>
          <target state="translated">插入一行的命令示例为</target>
        </trans-unit>
        <trans-unit id="d3e47d13cc2aa85cb2cac79171bd5ba58c06a033" translate="yes" xml:space="preserve">
          <source>An example implementation of my_options() and parameters use from other support functions are given below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77db1d337bb2340f6b1a45dac50171d5552245cf" translate="yes" xml:space="preserve">
          <source>An example is:</source>
          <target state="translated">一个例子是:</target>
        </trans-unit>
        <trans-unit id="ab2ae23169c6ecf2d8724ae3dd48f5aec7d41be5" translate="yes" xml:space="preserve">
          <source>An example of &lt;code&gt;synchronous_standby_names&lt;/code&gt; for a priority-based multiple synchronous standbys is:</source>
          <target state="translated">的一个例子 &lt;code&gt;synchronous_standby_names&lt;/code&gt; 为基于优先级的多个同步备用是：</target>
        </trans-unit>
        <trans-unit id="a98fc82d0f241f92e10ef779f12a66f98cdb0af5" translate="yes" xml:space="preserve">
          <source>An example of &lt;code&gt;synchronous_standby_names&lt;/code&gt; for a quorum-based multiple synchronous standbys is:</source>
          <target state="translated">的一个例子 &lt;code&gt;synchronous_standby_names&lt;/code&gt; 用于基于定额多个同步备用是：</target>
        </trans-unit>
        <trans-unit id="dd7d7ba1d423d1278de206e487f072bf081d0594" translate="yes" xml:space="preserve">
          <source>An example of a common way to break this assumption is to reference a user-defined function in a &lt;code&gt;CHECK&lt;/code&gt; expression, and then change the behavior of that function. PostgreSQL does not disallow that, but it will not notice if there are rows in the table that now violate the &lt;code&gt;CHECK&lt;/code&gt; constraint. That would cause a subsequent database dump and reload to fail. The recommended way to handle such a change is to drop the constraint (using &lt;code&gt;ALTER TABLE&lt;/code&gt;), adjust the function definition, and re-add the constraint, thereby rechecking it against all table rows.</source>
          <target state="translated">打破此假设的常见方法的一个示例是在 &lt;code&gt;CHECK&lt;/code&gt; 表达式中引用用户定义的函数，然后更改该函数的行为。 PostgreSQL不允许这样做，但是它不会注意到表中是否存在违反 &lt;code&gt;CHECK&lt;/code&gt; 约束的行。这将导致随后的数据库转储和重新加载失败。推荐的处理此类更改的方法是删除约束（使用 &lt;code&gt;ALTER TABLE&lt;/code&gt; ），调整函数定义并重新添加约束，从而针对所有表行对其进行重新检查。</target>
        </trans-unit>
        <trans-unit id="0fc2dcac68631535509b1c9851983c8f16591ded" translate="yes" xml:space="preserve">
          <source>An example of a common way to break this assumption is to reference a user-defined function in a &lt;code&gt;CHECK&lt;/code&gt; expression, and then change the behavior of that function. PostgreSQL does not disallow that, but it will not notice if there are stored values of the domain type that now violate the &lt;code&gt;CHECK&lt;/code&gt; constraint. That would cause a subsequent database dump and reload to fail. The recommended way to handle such a change is to drop the constraint (using &lt;code&gt;ALTER DOMAIN&lt;/code&gt;), adjust the function definition, and re-add the constraint, thereby rechecking it against stored data.</source>
          <target state="translated">打破此假设的常见方法的一个示例是在 &lt;code&gt;CHECK&lt;/code&gt; 表达式中引用用户定义的函数，然后更改该函数的行为。 PostgreSQL不允许这样做，但是它不会注意到是否存在违反 &lt;code&gt;CHECK&lt;/code&gt; 约束的域类型存储值。这将导致随后的数据库转储和重新加载失败。推荐的处理此类更改的方法是删除约束（使用 &lt;code&gt;ALTER DOMAIN&lt;/code&gt; ），调整函数定义并重新添加约束，从而根据存储的数据重新检查约束。</target>
        </trans-unit>
        <trans-unit id="f4d8042a8aacf4dd946a6de3a479fedbae68b9bb" translate="yes" xml:space="preserve">
          <source>An example of an ordered-set aggregate call is:</source>
          <target state="translated">一个有序集合调用的例子是:</target>
        </trans-unit>
        <trans-unit id="9b9fd9076643bacdf456e68d66e8b722bd4cc414" translate="yes" xml:space="preserve">
          <source>An example of the problem situation is an administrator on the primary server running &lt;code&gt;DROP TABLE&lt;/code&gt; on a table that is currently being queried on the standby server. Clearly the standby query cannot continue if the &lt;code&gt;DROP TABLE&lt;/code&gt; is applied on the standby. If this situation occurred on the primary, the &lt;code&gt;DROP TABLE&lt;/code&gt; would wait until the other query had finished. But when &lt;code&gt;DROP TABLE&lt;/code&gt; is run on the primary, the primary doesn't have information about what queries are running on the standby, so it will not wait for any such standby queries. The WAL change records come through to the standby while the standby query is still running, causing a conflict. The standby server must either delay application of the WAL records (and everything after them, too) or else cancel the conflicting query so that the &lt;code&gt;DROP TABLE&lt;/code&gt; can be applied.</source>
          <target state="translated">问题情况的一个示例是主服务器上的管理员在当前正在备用服务器上查询的 &lt;code&gt;DROP TABLE&lt;/code&gt; 上运行DROP TABLE。显然，如果将 &lt;code&gt;DROP TABLE&lt;/code&gt; 应用于备用数据库，则备用数据库查询将无法继续。如果在主数据库上发生这种情况，则 &lt;code&gt;DROP TABLE&lt;/code&gt; 将等待，直到另一个查询完成。但是当 &lt;code&gt;DROP TABLE&lt;/code&gt; 时在主数据库上运行时，主数据库没有有关在备用数据库上运行的查询的信息，因此它不会等待任何此类备用数据库查询。在备用查询仍在运行时，WAL更改记录将传递到备用数据库，从而引起冲突。备用服务器必须延迟WAL记录（及其后的所有内容）的应用，或者取消冲突的查询，以便可以应用 &lt;code&gt;DROP TABLE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c0584ea6554a34671913f19351974da1f1774aa3" translate="yes" xml:space="preserve">
          <source>An example of what this means:</source>
          <target state="translated">举个例子来说明这个意思。</target>
        </trans-unit>
        <trans-unit id="24ac5f040ccbfd7714847e1bf2aa5f6494899ae9" translate="yes" xml:space="preserve">
          <source>An example where &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; could be undesirable is</source>
          <target state="translated">可能不希望使用 &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; 的示例是</target>
        </trans-unit>
        <trans-unit id="17447c2100c81f31ba62252077dc9a9361cd71f9" translate="yes" xml:space="preserve">
          <source>An example with one unspecified argument:</source>
          <target state="translated">一个例子,有一个未说明的参数。</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">一个例子:</target>
        </trans-unit>
        <trans-unit id="79f0ca45e1236a1cb1c9feb4290eadf0487b4ef6" translate="yes" xml:space="preserve">
          <source>An exception is that if the command was terminated by a signal (other than SIGTERM, which is used as part of a database server shutdown) or an error by the shell (such as command not found), then recovery will abort and the server will not start up.</source>
          <target state="translated">一个例外的情况是,如果命令被一个信号(除了SIGTERM,它作为数据库服务器关闭的一部分)或shell的错误(如命令未找到)终止,那么恢复将中止,服务器将无法启动。</target>
        </trans-unit>
        <trans-unit id="fcd7932740e5471bcd0a087d5b26ec1edd628fbb" translate="yes" xml:space="preserve">
          <source>An explicit attribute name need not be specified if the attribute value is a column reference, in which case the column's name will be used as the attribute name by default. In other cases, the attribute must be given an explicit name. So this example is valid:</source>
          <target state="translated">如果属性值是列引用,则不需要指定显式属性名,在这种情况下,默认使用列名作为属性名。在其他情况下,必须给属性一个显式名称。所以这个例子是有效的。</target>
        </trans-unit>
        <trans-unit id="a0537d02ca5df21a5cff0228c3c1f8c6cfa4f59b" translate="yes" xml:space="preserve">
          <source>An explicit type cast can usually be omitted if there is no ambiguity as to the type that a value expression must produce (for example, when it is assigned to a table column); the system will automatically apply a type cast in such cases. However, automatic casting is only done for casts that are marked &amp;ldquo;OK to apply implicitly&amp;rdquo; in the system catalogs. Other casts must be invoked with explicit casting syntax. This restriction is intended to prevent surprising conversions from being applied silently.</source>
          <target state="translated">如果对于值表达式必须产生的类型没有歧义（例如，当将其分配给表列时），通常可以省略显式类型转换。在这种情况下，系统会自动应用类型转换。但是，仅对在系统目录中标记为&amp;ldquo;可以隐式应用&amp;rdquo;的强制转换进行自动强制转换。必须使用显式转换语法调用其他转换。此限制旨在防止意外地进行意外转换。</target>
        </trans-unit>
        <trans-unit id="8eb162f28e2597cd06bef15cc6b421aa23ae9738" translate="yes" xml:space="preserve">
          <source>An expression based on one or more columns of the table. The expression usually must be written with surrounding parentheses, as shown in the syntax. However, the parentheses can be omitted if the expression has the form of a function call.</source>
          <target state="translated">基于表格中一列或多列的表达式。表达式通常必须用周围的括号来写,如语法所示。但是,如果表达式的形式是函数调用,则可以省略括号。</target>
        </trans-unit>
        <trans-unit id="dfb3ba678ed8043b837cdccde74a8dfa30c47a0d" translate="yes" xml:space="preserve">
          <source>An expression or integer constant indicating how to sort the result rows. This expression can refer to the columns of the &lt;code&gt;VALUES&lt;/code&gt; result as &lt;code&gt;column1&lt;/code&gt;, &lt;code&gt;column2&lt;/code&gt;, etc. For more details see &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;&lt;code&gt;ORDER BY&lt;/code&gt; Clause&lt;/a&gt;.</source>
          <target state="translated">表示如何对结果行进行排序的表达式或整数常量。该表达式可以将 &lt;code&gt;VALUES&lt;/code&gt; 结果的列称为 &lt;code&gt;column1&lt;/code&gt; ， &lt;code&gt;column2&lt;/code&gt; 等。有关更多详细信息，请参见&lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt; &lt;code&gt;ORDER BY&lt;/code&gt; 子句&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b2f105d127b4d4c78a65c31c4341d9a688ca047d" translate="yes" xml:space="preserve">
          <source>An expression or integer constant indicating how to sort the result rows. This expression can refer to the columns of the &lt;code&gt;VALUES&lt;/code&gt; result as &lt;code&gt;column1&lt;/code&gt;, &lt;code&gt;column2&lt;/code&gt;, etc. For more details see &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;ORDER BY Clause&lt;/a&gt; in the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf2a060cd8aff34f17e0e2630c016f3f2cecf035" translate="yes" xml:space="preserve">
          <source>An expression or value to assign to the corresponding column.</source>
          <target state="translated">要分配给相应列的表达式或值。</target>
        </trans-unit>
        <trans-unit id="346258a0cd22cd6472088d2210ee4c5f296cc7a7" translate="yes" xml:space="preserve">
          <source>An expression that returns a value of type &lt;code&gt;boolean&lt;/code&gt;. Only rows for which this expression returns &lt;code&gt;true&lt;/code&gt; will be deleted.</source>
          <target state="translated">该表达式返回 &lt;code&gt;boolean&lt;/code&gt; 类型的值。仅此表达式返回 &lt;code&gt;true&lt;/code&gt; 的行将被删除。</target>
        </trans-unit>
        <trans-unit id="3b5a1cfe641c92cec7cffaf0f485f58266a8e8c9" translate="yes" xml:space="preserve">
          <source>An expression that returns a value of type &lt;code&gt;boolean&lt;/code&gt;. Only rows for which this expression returns &lt;code&gt;true&lt;/code&gt; will be updated, although all rows will be locked when the &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; action is taken. Note that &lt;code&gt;condition&lt;/code&gt; is evaluated last, after a conflict has been identified as a candidate to update.</source>
          <target state="translated">该表达式返回 &lt;code&gt;boolean&lt;/code&gt; 类型的值。尽管执行 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 操作时所有行都将被锁定，但仅此表达式返回 &lt;code&gt;true&lt;/code&gt; 的行将被更新。请注意，在确定冲突为要更新的候选对象之后，最后评估 &lt;code&gt;condition&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="51d351d5b4985c09126cf102d05f81d64ae9d961" translate="yes" xml:space="preserve">
          <source>An expression that returns a value of type &lt;code&gt;boolean&lt;/code&gt;. Only rows for which this expression returns &lt;code&gt;true&lt;/code&gt; will be updated.</source>
          <target state="translated">该表达式返回 &lt;code&gt;boolean&lt;/code&gt; 类型的值。仅此表达式返回 &lt;code&gt;true&lt;/code&gt; 的行将被更新。</target>
        </trans-unit>
        <trans-unit id="6469ea06c0d7a0f1185226a5a8416487a9a270db" translate="yes" xml:space="preserve">
          <source>An expression to assign to the column. The expression can use the old values of this and other columns in the table.</source>
          <target state="translated">要分配给列的表达式。该表达式可以使用本列和表中其他列的旧值。</target>
        </trans-unit>
        <trans-unit id="8157c1c94fdd707dcc3e7f541c66bda5c99059b6" translate="yes" xml:space="preserve">
          <source>An expression to be computed and returned by the &lt;code&gt;DELETE&lt;/code&gt; command after each row is deleted. The expression can use any column names of the table named by &lt;code&gt;table_name&lt;/code&gt; or table(s) listed in &lt;code&gt;USING&lt;/code&gt;. Write &lt;code&gt;*&lt;/code&gt; to return all columns.</source>
          <target state="translated">&lt;code&gt;DELETE&lt;/code&gt; 每一行后，由DELETE命令计算并返回的表达式。该表达式可以使用以 &lt;code&gt;table_name&lt;/code&gt; 或 &lt;code&gt;USING&lt;/code&gt; 中列出的表命名的表的任何列名。输入 &lt;code&gt;*&lt;/code&gt; 以返回所有列。</target>
        </trans-unit>
        <trans-unit id="05948f44935d2d1795c3b150edf4c95d54d4a6f0" translate="yes" xml:space="preserve">
          <source>An expression to be computed and returned by the &lt;code&gt;INSERT&lt;/code&gt; command after each row is inserted or updated. The expression can use any column names of the table named by &lt;code&gt;table_name&lt;/code&gt;. Write &lt;code&gt;*&lt;/code&gt; to return all columns of the inserted or updated row(s).</source>
          <target state="translated">插入或更新每一行后， &lt;code&gt;INSERT&lt;/code&gt; 命令要计算并返回的表达式。该表达式可以使用由 &lt;code&gt;table_name&lt;/code&gt; 命名的表的任何列名称。写入 &lt;code&gt;*&lt;/code&gt; 返回插入或更新的行的所有列。</target>
        </trans-unit>
        <trans-unit id="711a38c8f40969b059c836aa598a46d28bd6408a" translate="yes" xml:space="preserve">
          <source>An expression to be computed and returned by the &lt;code&gt;UPDATE&lt;/code&gt; command after each row is updated. The expression can use any column names of the table named by &lt;code&gt;table_name&lt;/code&gt; or table(s) listed in &lt;code&gt;FROM&lt;/code&gt;. Write &lt;code&gt;*&lt;/code&gt; to return all columns.</source>
          <target state="translated">每行更新后，由 &lt;code&gt;UPDATE&lt;/code&gt; 命令计算并返回的表达式。该表达式可以使用由 &lt;code&gt;table_name&lt;/code&gt; 或 &lt;code&gt;FROM&lt;/code&gt; 中列出的表命名的表的任何列名。输入 &lt;code&gt;*&lt;/code&gt; 以返回所有列。</target>
        </trans-unit>
        <trans-unit id="1a2196f96cc62fad9b61f7b17e09f3003661a8d1" translate="yes" xml:space="preserve">
          <source>An expression to be used as default value if the parameter is not specified. The expression has to be coercible to the argument type of the parameter. All input parameters following a parameter with a default value must have default values as well.</source>
          <target state="translated">如果没有指定参数,则使用表达式作为默认值。该表达式必须与参数的参数类型一致。所有跟在默认值参数后面的输入参数也必须有默认值。</target>
        </trans-unit>
        <trans-unit id="33129ed19c1151cbd1e641d74c28498304306825" translate="yes" xml:space="preserve">
          <source>An expression to be used as default value if the parameter is not specified. The expression has to be coercible to the argument type of the parameter. Only input (including &lt;code&gt;INOUT&lt;/code&gt;) parameters can have a default value. All input parameters following a parameter with a default value must have default values as well.</source>
          <target state="translated">如果未指定参数，则用作默认值的表达式。该表达式必须对参数的参数类型具有强制性。仅输入（包括 &lt;code&gt;INOUT&lt;/code&gt; ）参数可以具有默认值。具有默认值的参数之后的所有输入参数也必须具有默认值。</target>
        </trans-unit>
        <trans-unit id="e3cc897e9290dc3056730f190eeba85a57f89dca" translate="yes" xml:space="preserve">
          <source>An external program can call the &lt;code&gt;pg_walfile_name_offset()&lt;/code&gt; function (see &lt;a href=&quot;functions-admin&quot;&gt;Section 9.26&lt;/a&gt;) to find out the file name and the exact byte offset within it of the current end of WAL. It can then access the WAL file directly and copy the data from the last known end of WAL through the current end over to the standby servers. With this approach, the window for data loss is the polling cycle time of the copying program, which can be very small, and there is no wasted bandwidth from forcing partially-used segment files to be archived. Note that the standby servers' &lt;code&gt;restore_command&lt;/code&gt; scripts can only deal with whole WAL files, so the incrementally copied data is not ordinarily made available to the standby servers. It is of use only when the primary dies &amp;mdash; then the last partial WAL file is fed to the standby before allowing it to come up. The correct implementation of this process requires cooperation of the &lt;code&gt;restore_command&lt;/code&gt; script with the data copying program.</source>
          <target state="translated">外部程序可以调用 &lt;code&gt;pg_walfile_name_offset()&lt;/code&gt; 函数（请参见&lt;a href=&quot;functions-admin&quot;&gt;第9.26节&lt;/a&gt;）以找出文件名以及WAL当前末尾中的确切字节偏移量。然后，它可以直接访问WAL文件，并将数据从WAL的最后已知端到当前端复制到备用服务器。使用这种方法，数据丢失的时间就是复制程序的轮询周期时间，这可能非常小，并且不会因为强制使用部分使用的段文件而浪费带宽。请注意，备用服务器的 &lt;code&gt;restore_command&lt;/code&gt; 脚本只能处理整个WAL文件，因此增量复制的数据通常不可供备用服务器使用。仅当主节点失效时才使用它-然后，最后的部分WAL文件在允许它出现之前被馈送到备用数据库。要正确执行此过程，需要 &lt;code&gt;restore_command&lt;/code&gt; 脚本与数据复制程序配合。</target>
        </trans-unit>
        <trans-unit id="e349b01fb7be05aa32f87d20348ac32cf9165b0a" translate="yes" xml:space="preserve">
          <source>An external program can call the &lt;code&gt;pg_walfile_name_offset()&lt;/code&gt; function (see &lt;a href=&quot;functions-admin&quot;&gt;Section 9.27&lt;/a&gt;) to find out the file name and the exact byte offset within it of the current end of WAL. It can then access the WAL file directly and copy the data from the last known end of WAL through the current end over to the standby servers. With this approach, the window for data loss is the polling cycle time of the copying program, which can be very small, and there is no wasted bandwidth from forcing partially-used segment files to be archived. Note that the standby servers' &lt;code&gt;restore_command&lt;/code&gt; scripts can only deal with whole WAL files, so the incrementally copied data is not ordinarily made available to the standby servers. It is of use only when the primary dies &amp;mdash; then the last partial WAL file is fed to the standby before allowing it to come up. The correct implementation of this process requires cooperation of the &lt;code&gt;restore_command&lt;/code&gt; script with the data copying program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94b6e6917365cf5b071c6d2030b18320b138edde" translate="yes" xml:space="preserve">
          <source>An immediate-mode shutdown is equivalent to a server crash, and will therefore cause loss of any unflushed asynchronous commits.</source>
          <target state="translated">即时模式关闭相当于服务器崩溃,因此将导致任何未刷新异步提交的损失。</target>
        </trans-unit>
        <trans-unit id="40eea77fc7125e69a1e10d852d75c5913c0b8a4f" translate="yes" xml:space="preserve">
          <source>An important advantage of pg_dump over the other backup methods described later is that pg_dump's output can generally be re-loaded into newer versions of PostgreSQL, whereas file-level backups and continuous archiving are both extremely server-version-specific. pg_dump is also the only method that will work when transferring a database to a different machine architecture, such as going from a 32-bit to a 64-bit server.</source>
          <target state="translated">pg_dump与后面介绍的其他备份方法相比,一个重要的优势是pg_dump的输出一般可以重新加载到PostgreSQL的新版本中,而文件级备份和持续归档都是极度依赖服务器版本的,pg_dump也是唯一能在将数据库转移到不同机器架构时工作的方法,比如从32位服务器转移到64位服务器。</target>
        </trans-unit>
        <trans-unit id="779e5fbc91351efe2bbe3fc71a519dfce1b2cb29" translate="yes" xml:space="preserve">
          <source>An important health indicator of streaming replication is the amount of WAL records generated in the primary, but not yet applied in the standby. You can calculate this lag by comparing the current WAL write location on the primary with the last WAL location received by the standby. These locations can be retrieved using &lt;code&gt;pg_current_wal_lsn&lt;/code&gt; on the primary and &lt;code&gt;pg_last_wal_receive_lsn&lt;/code&gt; on the standby, respectively (see &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;Table 9.84&lt;/a&gt; and &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;Table 9.85&lt;/a&gt; for details). The last WAL receive location in the standby is also displayed in the process status of the WAL receiver process, displayed using the &lt;code&gt;ps&lt;/code&gt; command (see &lt;a href=&quot;monitoring-ps&quot;&gt;Section 27.1&lt;/a&gt; for details).</source>
          <target state="translated">流复制的重要健康指标是在主数据库中生成但尚未在备用数据库中应用的WAL记录的数量。您可以通过将主数据库上的当前WAL写入位置与备用数据库收到的最后一个WAL位置进行比较来计算此延迟。可以使用 &lt;code&gt;pg_current_wal_lsn&lt;/code&gt; 上的pg_current_wal_lsn和备用数据库上的 &lt;code&gt;pg_last_wal_receive_lsn&lt;/code&gt; 检索这些位置（有关详细信息，请&lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;参见表9.84&lt;/a&gt;和&lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;表9.85&lt;/a&gt;）。备用数据库中最后一个WAL接收位置也显示在WAL接收器进程的进程状态中，使用 &lt;code&gt;ps&lt;/code&gt; 命令显示（有关详细信息，请参见&lt;a href=&quot;monitoring-ps&quot;&gt;27.1节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="5e354ee44c574fe1a74c62c071de207a2e99bd9d" translate="yes" xml:space="preserve">
          <source>An important health indicator of streaming replication is the amount of WAL records generated in the primary, but not yet applied in the standby. You can calculate this lag by comparing the current WAL write location on the primary with the last WAL location received by the standby. These locations can be retrieved using &lt;code&gt;pg_current_wal_lsn&lt;/code&gt; on the primary and &lt;code&gt;pg_last_wal_receive_lsn&lt;/code&gt; on the standby, respectively (see &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;Table 9.85&lt;/a&gt; and &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;Table 9.86&lt;/a&gt; for details). The last WAL receive location in the standby is also displayed in the process status of the WAL receiver process, displayed using the &lt;code&gt;ps&lt;/code&gt; command (see &lt;a href=&quot;monitoring-ps&quot;&gt;Section 27.1&lt;/a&gt; for details).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8738ccf906ae7704aa616ed666eef87dd66384c2" translate="yes" xml:space="preserve">
          <source>An important restriction, however, is that each database's character set must be compatible with the database's &lt;code&gt;LC_CTYPE&lt;/code&gt; (character classification) and &lt;code&gt;LC_COLLATE&lt;/code&gt; (string sort order) locale settings. For &lt;code&gt;C&lt;/code&gt; or &lt;code&gt;POSIX&lt;/code&gt; locale, any character set is allowed, but for other libc-provided locales there is only one character set that will work correctly. (On Windows, however, UTF-8 encoding can be used with any locale.) If you have ICU support configured, ICU-provided locales can be used with most but not all server-side encodings.</source>
          <target state="translated">但是，一个重要的限制是每个数据库的字符集必须与数据库的 &lt;code&gt;LC_CTYPE&lt;/code&gt; （字符分类）和 &lt;code&gt;LC_COLLATE&lt;/code&gt; （字符串排序顺序）区域设置兼容。对于 &lt;code&gt;C&lt;/code&gt; 或 &lt;code&gt;POSIX&lt;/code&gt; 语言环境，允许使用任何字符集，但是对于其他libc提供的语言环境，只有一个字符集可以正常工作。 （但是，在Windows上，UTF-8编码可以与任何语言环境一起使用。）如果配置了ICU支持，则ICU提供的语言环境可以与大多数（但不是全部）服务器端编码一起使用。</target>
        </trans-unit>
        <trans-unit id="0f5ae435c6587408d50bbebe9d66abc0ceb67394" translate="yes" xml:space="preserve">
          <source>An index access method handler function must be declared to accept a single argument of type &lt;code&gt;internal&lt;/code&gt; and to return the pseudo-type &lt;code&gt;index_am_handler&lt;/code&gt;. The argument is a dummy value that simply serves to prevent handler functions from being called directly from SQL commands. The result of the function must be a palloc'd struct of type &lt;code&gt;IndexAmRoutine&lt;/code&gt;, which contains everything that the core code needs to know to make use of the index access method. The &lt;code&gt;IndexAmRoutine&lt;/code&gt; struct, also called the access method's &lt;em&gt;API struct&lt;/em&gt;, includes fields specifying assorted fixed properties of the access method, such as whether it can support multicolumn indexes. More importantly, it contains pointers to support functions for the access method, which do all of the real work to access indexes. These support functions are plain C functions and are not visible or callable at the SQL level. The support functions are described in &lt;a href=&quot;index-functions&quot;&gt;Section 61.2&lt;/a&gt;.</source>
          <target state="translated">必须声明索引访问方法处理程序函数以接受类型为 &lt;code&gt;internal&lt;/code&gt; 的单个参数并返回伪类型 &lt;code&gt;index_am_handler&lt;/code&gt; 。该参数是一个伪值，仅用于防止直接从SQL命令调用处理函数。该函数的结果必须是类型为 &lt;code&gt;IndexAmRoutine&lt;/code&gt; 的palloc结构，该结构包含核心代码使用索引访问方法需要了解的所有内容。该 &lt;code&gt;IndexAmRoutine&lt;/code&gt; 结构，也被称为访问方法的&lt;em&gt;API结构&lt;/em&gt;包括指定访问方法的各种固定属性的字段，例如它是否可以支持多列索引。更重要的是，它包含支持访问方法功能的指针，这些方法完成访问索引的所有实际工作。这些支持函数是普通的C函数，在SQL级别不可见或不可调用。支持功能在&lt;a href=&quot;index-functions&quot;&gt;第61.2节&lt;/a&gt;中描述。</target>
        </trans-unit>
        <trans-unit id="bb532d7978fa5df32b453f561220dfbe06086e40" translate="yes" xml:space="preserve">
          <source>An index access method handler is declared to return &lt;code&gt;index_am_handler&lt;/code&gt;.</source>
          <target state="translated">声明索引访问方法处理程序以返回 &lt;code&gt;index_am_handler&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b07d3910aeda52b29f538101381247d79d370d4" translate="yes" xml:space="preserve">
          <source>An index can be defined on more than one column of a table. For example, if you have a table of this form:</source>
          <target state="translated">一个索引可以定义在一个表的多个列上。例如,如果你有一个这样的表格。</target>
        </trans-unit>
        <trans-unit id="c6cedebd8f5962a85979ac8b01f76ed8117fa855" translate="yes" xml:space="preserve">
          <source>An index can support only one collation per index column. If multiple collations are of interest, multiple indexes may be needed.</source>
          <target state="translated">一个索引只能支持每个索引列的一个整理。如果对多个整理感兴趣,可能需要多个索引。</target>
        </trans-unit>
        <trans-unit id="af32b6cb0c87ebb15770ca088fe87a22f82c7725" translate="yes" xml:space="preserve">
          <source>An index column need not be just a column of the underlying table, but can be a function or scalar expression computed from one or more columns of the table. This feature is useful to obtain fast access to tables based on the results of computations.</source>
          <target state="translated">索引列不一定只是底层表的一列,可以是由表的一列或多列计算出来的函数或标量表达式。这个功能对于根据计算结果快速访问表很有用。</target>
        </trans-unit>
        <trans-unit id="38f15f32a54b60a4d97bf16f8c60ceef26c5914e" translate="yes" xml:space="preserve">
          <source>An index definition can specify an &lt;em&gt;operator class&lt;/em&gt; for each column of an index.</source>
          <target state="translated">索引定义可以为索引的每一列指定一个&lt;em&gt;运算符类&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="0ef2323f17ff30aac9494d8039a3c3612271c42a" translate="yes" xml:space="preserve">
          <source>An index field can be an expression computed from the values of one or more columns of the table row. This feature can be used to obtain fast access to data based on some transformation of the basic data. For example, an index computed on &lt;code&gt;upper(col)&lt;/code&gt; would allow the clause &lt;code&gt;WHERE upper(col) = 'JIM'&lt;/code&gt; to use an index.</source>
          <target state="translated">索引字段可以是根据表行的一个或多个列的值计算的表达式。该功能可用于基于基本数据的某种转换来快速访问数据。例如，在 &lt;code&gt;upper(col)&lt;/code&gt; 上计算的索引将允许子句 &lt;code&gt;WHERE upper(col) = 'JIM'&lt;/code&gt; 使用索引。</target>
        </trans-unit>
        <trans-unit id="3aeae44b3c790fd037b93e2535adf3aedad79c0a" translate="yes" xml:space="preserve">
          <source>An index has become &amp;ldquo;bloated&amp;rdquo;, that is it contains many empty or nearly-empty pages. This can occur with B-tree indexes in PostgreSQL under certain uncommon access patterns. &lt;code&gt;REINDEX&lt;/code&gt; provides a way to reduce the space consumption of the index by writing a new version of the index without the dead pages. See &lt;a href=&quot;routine-reindex&quot;&gt;Section 24.2&lt;/a&gt; for more information.</source>
          <target state="translated">索引已变得&amp;ldquo; blo肿&amp;rdquo;，即它包含许多空页面或近空页面。在某些不常见的访问模式下，PostgreSQL中的B树索引可能会发生这种情况。 &lt;code&gt;REINDEX&lt;/code&gt; 提供了一种通过编写没有死页的新版本索引来减少索引空间消耗的方法。有关更多信息，请参见&lt;a href=&quot;routine-reindex&quot;&gt;第24.2节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="121b8423d6baa50b53be4c3d49a8a3b7e064ae7d" translate="yes" xml:space="preserve">
          <source>An index has become corrupted, and no longer contains valid data. Although in theory this should never happen, in practice indexes can become corrupted due to software bugs or hardware failures. &lt;code&gt;REINDEX&lt;/code&gt; provides a recovery method.</source>
          <target state="translated">索引已损坏，并且不再包含有效数据。尽管从理论上讲这永远不会发生，但实际上索引可能由于软件错误或硬件故障而损坏。 &lt;code&gt;REINDEX&lt;/code&gt; 提供了一种恢复方法。</target>
        </trans-unit>
        <trans-unit id="fd114c1d6538ba92c251db5881779687c2ba09a7" translate="yes" xml:space="preserve">
          <source>An index scan must maintain a pin on the index page holding the item last returned by &lt;code&gt;amgettuple&lt;/code&gt;, and &lt;code&gt;ambulkdelete&lt;/code&gt; cannot delete entries from pages that are pinned by other backends. The need for this rule is explained below.</source>
          <target state="translated">索引扫描必须在索引页面上保持一个 &lt;code&gt;amgettuple&lt;/code&gt; ，该 &lt;code&gt;ambulkdelete&lt;/code&gt; 由amgettuple最后返回的项目，并且ambulkdelete无法从其他后端固定的页面上删除条目。下面说明了此规则的必要性。</target>
        </trans-unit>
        <trans-unit id="091f10c301d94d87ecd9a27b3366c6d6b064df7e" translate="yes" xml:space="preserve">
          <source>An index stored in ascending order with nulls first can satisfy either &lt;code&gt;ORDER BY x ASC NULLS FIRST&lt;/code&gt; or &lt;code&gt;ORDER BY x DESC NULLS LAST&lt;/code&gt; depending on which direction it is scanned in.</source>
          <target state="translated">根据索引的扫描方向，首先以空值升序存储的索引可以满足 &lt;code&gt;ORDER BY x ASC NULLS FIRST&lt;/code&gt; 或 &lt;code&gt;ORDER BY x DESC NULLS LAST&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b9a05a65dbb6edc07d784a35f9d93afabbd7c69" translate="yes" xml:space="preserve">
          <source>An individual index is defined by a &lt;a href=&quot;catalog-pg-class&quot;&gt;&lt;code&gt;pg_class&lt;/code&gt;&lt;/a&gt; entry that describes it as a physical relation, plus a &lt;a href=&quot;catalog-pg-index&quot;&gt;&lt;code&gt;pg_index&lt;/code&gt;&lt;/a&gt; entry that shows the logical content of the index &amp;mdash; that is, the set of index columns it has and the semantics of those columns, as captured by the associated operator classes. The index columns (key values) can be either simple columns of the underlying table or expressions over the table rows. The index access method normally has no interest in where the index key values come from (it is always handed precomputed key values) but it will be very interested in the operator class information in &lt;code&gt;pg_index&lt;/code&gt;. Both of these catalog entries can be accessed as part of the &lt;code&gt;Relation&lt;/code&gt; data structure that is passed to all operations on the index.</source>
          <target state="translated">单个索引由&lt;a href=&quot;catalog-pg-class&quot;&gt; &lt;code&gt;pg_class&lt;/code&gt; &lt;/a&gt;条目（将其描述为物理关系）加上&lt;a href=&quot;catalog-pg-index&quot;&gt; &lt;code&gt;pg_index&lt;/code&gt; &lt;/a&gt;条目定义，该条目显示索引的逻辑内容，即具有的索引列的集合以及这些列的语义，如关联的运算符类。索引列（键值）可以是基础表的简单列，也可以是表行上的表达式。索引访问方法通常对索引键值的来源不感兴趣（它总是传递给预先计算的键值），但是它将对 &lt;code&gt;pg_index&lt;/code&gt; 中的运算符类信息非常感兴趣。这两个目录条目都可以作为 &lt;code&gt;Relation&lt;/code&gt; 一部分进行访问 传递给索引上所有操作的数据结构。</target>
        </trans-unit>
        <trans-unit id="c51c50438ea0481d3519a43885b20aa32e128cb3" translate="yes" xml:space="preserve">
          <source>An input argument for the procedure call. See &lt;a href=&quot;sql-syntax-calling-funcs&quot;&gt;Section 4.3&lt;/a&gt; for the full details on function and procedure call syntax, including use of named parameters.</source>
          <target state="translated">过程调用的输入参数。有关函数和过程调用语法（包括命名参数的使用）的完整详细信息，请参见&lt;a href=&quot;sql-syntax-calling-funcs&quot;&gt;第4.3节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="73ddb8fe436cada6d2cfbe35b934979d06f7b361" translate="yes" xml:space="preserve">
          <source>An input data type on which the aggregate function operates. To reference a zero-argument aggregate function, write &lt;code&gt;*&lt;/code&gt; in place of the list of argument specifications. To reference an ordered-set aggregate function, write &lt;code&gt;ORDER BY&lt;/code&gt; between the direct and aggregated argument specifications.</source>
          <target state="translated">聚合函数所基于的输入数据类型。要引用零参数聚合函数，请写 &lt;code&gt;*&lt;/code&gt; 代替参数规范列表。要引用有序集合的聚合函数，请在直接参数和聚合参数规范之间编写 &lt;code&gt;ORDER BY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a9fa698ac8ae654cf211647b74f7c8723ee0347" translate="yes" xml:space="preserve">
          <source>An input data type on which this aggregate function operates. To create a zero-argument aggregate function, write &lt;code&gt;*&lt;/code&gt; in place of the list of argument specifications. (An example of such an aggregate is &lt;code&gt;count(*)&lt;/code&gt;.)</source>
          <target state="translated">此聚合函数在其上操作的输入数据类型。要创建零参数聚合函数，请在参数说明列表中写 &lt;code&gt;*&lt;/code&gt; 。（这种聚合的一个示例是 &lt;code&gt;count(*)&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="2c437a292efa6b573c836047b51a1cf9f32df694" translate="yes" xml:space="preserve">
          <source>An introduction to the btree index implementation can be found in &lt;code&gt;src/backend/access/nbtree/README&lt;/code&gt;.</source>
          <target state="translated">btree索引实现的简介可以在 &lt;code&gt;src/backend/access/nbtree/README&lt;/code&gt; 中找到。</target>
        </trans-unit>
        <trans-unit id="43d220b2360555baed12a7c95e72685b6f39b9dd" translate="yes" xml:space="preserve">
          <source>An n-dimensional cube represented by a pair of its diagonally opposite corners</source>
          <target state="translated">一个n维的立方体,由一对对角线表示。</target>
        </trans-unit>
        <trans-unit id="49b0e219e8853ca29533ecae37f9efd990522911" translate="yes" xml:space="preserve">
          <source>An object can be assigned to a new owner with an &lt;code&gt;ALTER&lt;/code&gt; command of the appropriate kind for the object, for example</source>
          <target state="translated">例如，可以使用适合该对象类型的 &lt;code&gt;ALTER&lt;/code&gt; 命令将该对象分配给新所有者</target>
        </trans-unit>
        <trans-unit id="261a27538e7f1d6cc0124e706ea14d5684e6fe5c" translate="yes" xml:space="preserve">
          <source>An object's owner can choose to revoke their own ordinary privileges, for example to make a table read-only for themselves as well as others. But owners are always treated as holding all grant options, so they can always re-grant their own privileges.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd7347c4e72d5111690a2e6b553a4bb95eecefbe" translate="yes" xml:space="preserve">
          <source>An obsolete type name that formerly served many of the above purposes.</source>
          <target state="translated">一个过时的类型名称,以前有许多上述用途。</target>
        </trans-unit>
        <trans-unit id="e67e0cc488404bddd9185d257d8376a78bb5f89d" translate="yes" xml:space="preserve">
          <source>An older syntax based on &quot;:=&quot; is supported for backward compatibility:</source>
          <target state="translated">为了向后兼容,支持基于&quot;:=&quot;的旧语法。</target>
        </trans-unit>
        <trans-unit id="a2ec14d06c6e5e0d12a30237502776f169012b3d" translate="yes" xml:space="preserve">
          <source>An open cursor's name.</source>
          <target state="translated">一个打开的光标的名字。</target>
        </trans-unit>
        <trans-unit id="fdaf617bcf458038608559aa52135b2d0fb280c4" translate="yes" xml:space="preserve">
          <source>An operation and SQL keyword used in &lt;a href=&quot;glossary#GLOSSARY-QUERY&quot;&gt;queries&lt;/a&gt; for combining data from multiple &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relations&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="907b1845a90ba08c2bd64d8aae44246179e07fc0" translate="yes" xml:space="preserve">
          <source>An operator class for BRIN can optionally specify the following method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a82dcbae2eb28872acc9a82bc62d7f28fc52dc06" translate="yes" xml:space="preserve">
          <source>An operator class for GIN can optionally supply the following methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56d15480825e451d724a77515f8cbd596240aa64" translate="yes" xml:space="preserve">
          <source>An operator class for bloom indexes requires only a hash function for the indexed data type and an equality operator for searching. This example shows the operator class definition for the &lt;code&gt;text&lt;/code&gt; data type:</source>
          <target state="translated">Bloom索引的运算符类仅需要用于索引数据类型的哈希函数和用于搜索的相等运算符。此示例显示了 &lt;code&gt;text&lt;/code&gt; 数据类型的运算符类定义：</target>
        </trans-unit>
        <trans-unit id="6eb7653b3723c58c344a731c25071cc3711f5e86" translate="yes" xml:space="preserve">
          <source>An operator class is actually just a subset of a larger structure called an &lt;em&gt;operator family&lt;/em&gt;. In cases where several data types have similar behaviors, it is frequently useful to define cross-data-type operators and allow these to work with indexes. To do this, the operator classes for each of the types must be grouped into the same operator family. The cross-type operators are members of the family, but are not associated with any single class within the family.</source>
          <target state="translated">操作员类实际上只是一个更大的结构的子集，称为&lt;em&gt;操作员族&lt;/em&gt;。在几种数据类型具有相似行为的情况下，定义跨数据类型运算符并允许它们与索引一起使用通常很有用。为此，必须将每种类型的操作员类别归为同一操作员族。交叉类型运算符是该家族的成员，但与该家族中的任何单个类别都不相关。</target>
        </trans-unit>
        <trans-unit id="f7d235f30c792ff196a94c50c4549a98a2d7a764" translate="yes" xml:space="preserve">
          <source>An operator class must also provide a function to check if an indexed item matches the query. It comes in two flavors, a Boolean &lt;code&gt;consistent&lt;/code&gt; function, and a ternary &lt;code&gt;triConsistent&lt;/code&gt; function. &lt;code&gt;triConsistent&lt;/code&gt; covers the functionality of both, so providing &lt;code&gt;triConsistent&lt;/code&gt; alone is sufficient. However, if the Boolean variant is significantly cheaper to calculate, it can be advantageous to provide both. If only the Boolean variant is provided, some optimizations that depend on refuting index items before fetching all the keys are disabled.</source>
          <target state="translated">运算符类还必须提供一个函数来检查索引项是否与查询匹配。它有两种形式，布尔 &lt;code&gt;consistent&lt;/code&gt; 函数和三元 &lt;code&gt;triConsistent&lt;/code&gt; 函数。 &lt;code&gt;triConsistent&lt;/code&gt; 涵盖了两者的功能，因此仅提供 &lt;code&gt;triConsistent&lt;/code&gt; 就足够了。但是，如果布尔变量的计算成本大大降低，则同时提供这两个变量可能会很有利。如果仅提供布尔变量，则会禁用某些依赖于在获取所有键之前反驳索引项的优化。</target>
        </trans-unit>
        <trans-unit id="6e523c5f9d2c574da0fb6483337cb467c258e68f" translate="yes" xml:space="preserve">
          <source>An operator class's &lt;code&gt;opcmethod&lt;/code&gt; must match the &lt;code&gt;opfmethod&lt;/code&gt; of its containing operator family. Also, there must be no more than one &lt;code&gt;pg_opclass&lt;/code&gt; row having &lt;code&gt;opcdefault&lt;/code&gt; true for any given combination of &lt;code&gt;opcmethod&lt;/code&gt; and &lt;code&gt;opcintype&lt;/code&gt;.</source>
          <target state="translated">运营商级的 &lt;code&gt;opcmethod&lt;/code&gt; 必须匹配 &lt;code&gt;opfmethod&lt;/code&gt; 其包含运营商家庭。另外，对于任何给定的 &lt;code&gt;opcmethod&lt;/code&gt; 和 &lt;code&gt;opcintype&lt;/code&gt; 组合，最多只能有一个 &lt;code&gt;pg_opclass&lt;/code&gt; 行具有 &lt;code&gt;opcdefault&lt;/code&gt; true 。</target>
        </trans-unit>
        <trans-unit id="0a6550b54250a9ead01f2b3553646b2303a4a1ed" translate="yes" xml:space="preserve">
          <source>An operator invocation</source>
          <target state="translated">操作符调用</target>
        </trans-unit>
        <trans-unit id="61b072351eb6c6fa27b9ae84a318cc236116df90" translate="yes" xml:space="preserve">
          <source>An operator name is a sequence of up to &lt;code&gt;NAMEDATALEN&lt;/code&gt;-1 (63 by default) characters from the following list:</source>
          <target state="translated">操作员名称是以下列表中最多 &lt;code&gt;NAMEDATALEN&lt;/code&gt; -1（默认为63）个字符的序列：</target>
        </trans-unit>
        <trans-unit id="d3a80b67bf09fd16cb2674622b6e5dcf9a0716b6" translate="yes" xml:space="preserve">
          <source>An operator used to derive the statistics stored in the &lt;code&gt;N&lt;/code&gt;th &amp;ldquo;slot&amp;rdquo;. For example, a histogram slot would show the &lt;code&gt;&amp;lt;&lt;/code&gt; operator that defines the sort order of the data.</source>
          <target state="translated">用于导出存储在第 &lt;code&gt;N&lt;/code&gt; 个&amp;ldquo;插槽&amp;rdquo;中的统计信息的运算符。例如，直方图槽将显示 &lt;code&gt;&amp;lt;&lt;/code&gt; 运算符，该运算符定义了数据的排序顺序。</target>
        </trans-unit>
        <trans-unit id="36745dfcd4a31015998a201702d690d18fcba0c2" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;+&lt;/code&gt; produces more details.</source>
          <target state="translated">可选 &lt;code&gt;+&lt;/code&gt; 产生更多详细信息。</target>
        </trans-unit>
        <trans-unit id="15280e346b927d3a2d54ca3d61b3ae948a862eb2" translate="yes" xml:space="preserve">
          <source>An optional collation for the domain. If no collation is specified, the underlying data type's default collation is used. The underlying type must be collatable if &lt;code&gt;COLLATE&lt;/code&gt; is specified.</source>
          <target state="translated">域的可选归类。如果未指定排序规则，则使用基础数据类型的默认排序规则。如果指定 &lt;code&gt;COLLATE&lt;/code&gt; ,则基础类型必须可整理。</target>
        </trans-unit>
        <trans-unit id="60e65907bee0f7f6070fd34b3f416cb8bb6f6e36" translate="yes" xml:space="preserve">
          <source>An optional comma-separated list of arguments to be provided to the function when the trigger is executed. The arguments are literal string constants. Simple names and numeric constants can be written here, too, but they will all be converted to strings. Please check the description of the implementation language of the trigger function to find out how these arguments can be accessed within the function; it might be different from normal function arguments.</source>
          <target state="translated">当触发器被执行时,提供给函数的参数的一个以逗号分隔的可选列表。参数是字符串常量。简单的名称和数字常量也可以写在这里,但它们都会被转换为字符串。请检查触发函数的实现语言的描述,以了解如何在函数中访问这些参数;它可能与普通函数参数不同。</target>
        </trans-unit>
        <trans-unit id="c4ca636c20fca55bda068decba0ca12e4c60f9d3" translate="yes" xml:space="preserve">
          <source>An optional list of columns to be copied. If no column list is specified, all columns of the table except generated columns will be copied.</source>
          <target state="translated">可选的要复制的列列表。如果没有指定列列表,那么除了生成的列之外,表中的所有列都将被复制。</target>
        </trans-unit>
        <trans-unit id="f37b6dea6bba7854fbb2a25222ccbd3742c1fd86" translate="yes" xml:space="preserve">
          <source>An optional list of names to be used for columns of the view. If not given, the column names are deduced from the query.</source>
          <target state="translated">视图中列名的可选列表。如果没有给出,则从查询中推断出列名。</target>
        </trans-unit>
        <trans-unit id="a1745e8f3d8a818bb59434a30224b4bc70bd52ef" translate="yes" xml:space="preserve">
          <source>An optional name for a column or table constraint. If the constraint is violated, the constraint name is present in error messages, so constraint names like &lt;code&gt;col must be positive&lt;/code&gt; can be used to communicate helpful constraint information to client applications. (Double-quotes are needed to specify constraint names that contain spaces.) If a constraint name is not specified, the system generates a name.</source>
          <target state="translated">列或表约束的可选名称。如果违反了约束，则约束名称将出现在错误消息中，因此可以使用诸如 &lt;code&gt;col must be positive&lt;/code&gt; 约束名称来将有用的约束信息传达给客户端应用程序。（需要双引号指定包含空格的约束名称。）如果未指定约束名称，则系统将生成一个名称。</target>
        </trans-unit>
        <trans-unit id="f3ae3fadcc76fcc5b9297de7bc96718990dc996d" translate="yes" xml:space="preserve">
          <source>An optional name for a constraint. If not specified, the system generates a name.</source>
          <target state="translated">约束的可选名称。如果没有指定,系统会生成一个名称。</target>
        </trans-unit>
        <trans-unit id="bd6568613ce7c67d34419866e38138da4ce733d2" translate="yes" xml:space="preserve">
          <source>An output column's name can be used to refer to the column's value in &lt;code&gt;ORDER BY&lt;/code&gt; and &lt;code&gt;GROUP BY&lt;/code&gt; clauses, but not in the &lt;code&gt;WHERE&lt;/code&gt; or &lt;code&gt;HAVING&lt;/code&gt; clauses; there you must write out the expression instead.</source>
          <target state="translated">输出列的名称可用于引用 &lt;code&gt;ORDER BY&lt;/code&gt; 和 &lt;code&gt;GROUP BY&lt;/code&gt; 子句中的列的值，但不能用于 &lt;code&gt;WHERE&lt;/code&gt; 或 &lt;code&gt;HAVING&lt;/code&gt; 子句中。在那里，您必须写出表达式。</target>
        </trans-unit>
        <trans-unit id="b29ad290e8bd770fdebcb84bad7370f20ace4e23" translate="yes" xml:space="preserve">
          <source>Analogous statements with inverted conditions hold when &lt;code&gt;less&lt;/code&gt; = false.</source>
          <target state="translated">当 &lt;code&gt;less&lt;/code&gt; = false 时，具有相反条件的类似语句成立。</target>
        </trans-unit>
        <trans-unit id="602ef0777e13fcee9897969f97ef1e867cdf140e" translate="yes" xml:space="preserve">
          <source>Analogous to &lt;code&gt;ON DELETE&lt;/code&gt; there is also &lt;code&gt;ON UPDATE&lt;/code&gt; which is invoked when a referenced column is changed (updated). The possible actions are the same. In this case, &lt;code&gt;CASCADE&lt;/code&gt; means that the updated values of the referenced column(s) should be copied into the referencing row(s).</source>
          <target state="translated">类似于 &lt;code&gt;ON DELETE&lt;/code&gt; ，当更改（更新）引用的列​​时，也会调用 &lt;code&gt;ON UPDATE&lt;/code&gt; 。可能的动作是相同的。在这种情况下， &lt;code&gt;CASCADE&lt;/code&gt; 意味着应将引用列的更新值复制到引用行中。</target>
        </trans-unit>
        <trans-unit id="8e26143bf38a350af73fba34493a3e7479767511" translate="yes" xml:space="preserve">
          <source>Analytic function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f0e68d1e2fd04310f44d64aff40ca304bd44245" translate="yes" xml:space="preserve">
          <source>Analyze (operation)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c83db21cadbb2756e96e53b9c14b7e7a2b514a6" translate="yes" xml:space="preserve">
          <source>Ancient distributions might not have the &lt;code&gt;sysctl&lt;/code&gt; program, but equivalent changes can be made by manipulating the &lt;code&gt;/proc&lt;/code&gt; file system:</source>
          <target state="translated">古代发行版可能没有 &lt;code&gt;sysctl&lt;/code&gt; 程序，但是可以通过操纵 &lt;code&gt;/proc&lt;/code&gt; 文件系统进行等效的更改：</target>
        </trans-unit>
        <trans-unit id="0d93beb44d205136520d673b54b56936f6980aa2" translate="yes" xml:space="preserve">
          <source>And finally create the transform to connect them all together:</source>
          <target state="translated">最后创建变换,将它们连接在一起。</target>
        </trans-unit>
        <trans-unit id="43c2b85844ed32a3fb79c6e1b9f3ea8d1ebdd551" translate="yes" xml:space="preserve">
          <source>And finally, most disk drives have caches. Some are write-through while some are write-back, and the same concerns about data loss exist for write-back drive caches as for disk controller caches. Consumer-grade IDE and SATA drives are particularly likely to have write-back caches that will not survive a power failure. Many solid-state drives (SSD) also have volatile write-back caches.</source>
          <target state="translated">最后,大多数磁盘驱动器都有缓存。有些是穿透式的,有些是回写式的,回写式驱动器缓存与磁盘控制器缓存存在同样的数据丢失问题。消费级IDE和SATA硬盘特别可能具有回写缓存,在断电时无法存活。许多固态硬盘(SSD)也有不稳定的回写缓存。</target>
        </trans-unit>
        <trans-unit id="f5abe4b1cbcb838f669f793ea91def6b18bb7e30" translate="yes" xml:space="preserve">
          <source>And on the subscriber database:</source>
          <target state="translated">而在订户数据库中。</target>
        </trans-unit>
        <trans-unit id="e24853104ecb700e47b83196c8cd650b56525c5b" translate="yes" xml:space="preserve">
          <source>And the &lt;code&gt;.dict&lt;/code&gt; file has the following structure:</source>
          <target state="translated">而 &lt;code&gt;.dict&lt;/code&gt; 文件的结构如下：</target>
        </trans-unit>
        <trans-unit id="588ca16f318d70344d76b4537a5c7291a5cee916" translate="yes" xml:space="preserve">
          <source>And the matching code in the C module could then follow this skeleton:</source>
          <target state="translated">而C模块中的匹配代码就可以按照这个骨架进行。</target>
        </trans-unit>
        <trans-unit id="680044bb057f2caf79b08b39f3f6077a48b66315" translate="yes" xml:space="preserve">
          <source>And to get 2-D cubes ordered by the first coordinate of the upper right corner descending:</source>
          <target state="translated">并得到按右上角第一个坐标降序排列的二维立方体。</target>
        </trans-unit>
        <trans-unit id="6871b449d2c079d96e59fe6f124b014ba15535f8" translate="yes" xml:space="preserve">
          <source>And we can specify subfields as targets for &lt;code&gt;INSERT&lt;/code&gt;, too:</source>
          <target state="translated">我们也可以指定子字段作为 &lt;code&gt;INSERT&lt;/code&gt; 的目标：</target>
        </trans-unit>
        <trans-unit id="a145997c5dd507c46627dcb8aa745e601bfd3eab" translate="yes" xml:space="preserve">
          <source>And, if the function is called with an argument of type &lt;code&gt;integer&lt;/code&gt;, the parser will try to convert that to &lt;code&gt;text&lt;/code&gt;:</source>
          <target state="translated">并且，如果使用 &lt;code&gt;integer&lt;/code&gt; 类型的参数调用该函数，则解析器将尝试将其转换为 &lt;code&gt;text&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7848b33d4bfc790590d465569216a9f6ae690895" translate="yes" xml:space="preserve">
          <source>Anonymous allocations are allocations that have been made with &lt;code&gt;ShmemAlloc()&lt;/code&gt; directly, rather than via &lt;code&gt;ShmemInitStruct()&lt;/code&gt; or &lt;code&gt;ShmemInitHash()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20ab5b725ed73e7635d9823c37915d8903343a0f" translate="yes" xml:space="preserve">
          <source>Another alternative worth considering is to use &lt;code&gt;INSTEAD OF&lt;/code&gt; triggers (see &lt;a href=&quot;sql-createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;) in place of rules.</source>
          <target state="translated">另一个值得考虑的替代方法是使用 &lt;code&gt;INSTEAD OF&lt;/code&gt; 触发器（请参见&lt;a href=&quot;sql-createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;）代替规则。</target>
        </trans-unit>
        <trans-unit id="e823a73742793d80b913d4d208ddb3ca9056df81" translate="yes" xml:space="preserve">
          <source>Another approach is to create a separate &lt;code&gt;tsvector&lt;/code&gt; column to hold the output of &lt;code&gt;to_tsvector&lt;/code&gt;. To keep this column automatically up to date with its source data, use a stored generated column. This example is a concatenation of &lt;code&gt;title&lt;/code&gt; and &lt;code&gt;body&lt;/code&gt;, using &lt;code&gt;coalesce&lt;/code&gt; to ensure that one field will still be indexed when the other is &lt;code&gt;NULL&lt;/code&gt;:</source>
          <target state="translated">另一种方法是创建一个单独的 &lt;code&gt;tsvector&lt;/code&gt; 列，以保存 &lt;code&gt;to_tsvector&lt;/code&gt; 的输出。要使此列自动保持其源数据的最新状态，请使用存储的已生成列。此示例是 &lt;code&gt;title&lt;/code&gt; 和 &lt;code&gt;body&lt;/code&gt; 的串联，使用 &lt;code&gt;coalesce&lt;/code&gt; 来确保当另一个字段为 &lt;code&gt;NULL&lt;/code&gt; 时仍对一个字段进行索引：</target>
        </trans-unit>
        <trans-unit id="c88aeeb193209d03f36ea4052749971eef461a5a" translate="yes" xml:space="preserve">
          <source>Another approach to querying is to exploit containment, for example:</source>
          <target state="translated">另一种查询方法是利用遏制,例如。</target>
        </trans-unit>
        <trans-unit id="0f6657768acd9084b11e644584f044a4fc45d8af" translate="yes" xml:space="preserve">
          <source>Another approach, which can be used with or without altering &lt;code&gt;vm.overcommit_memory&lt;/code&gt;, is to set the process-specific &lt;em&gt;OOM score adjustment&lt;/em&gt; value for the postmaster process to &lt;code&gt;-1000&lt;/code&gt;, thereby guaranteeing it will not be targeted by the OOM killer. The simplest way to do this is to execute</source>
          <target state="translated">可以在不更改 &lt;code&gt;vm.overcommit_memory&lt;/code&gt; 的情况下使用或不更改vm.overcommit_memory的另一种方法是，将postmaster进程的特定于进程的&lt;em&gt;OOM分数调整&lt;/em&gt;值设置为 &lt;code&gt;-1000&lt;/code&gt; ，从而确保它不会成为OOM杀手的目标。最简单的方法是执行</target>
        </trans-unit>
        <trans-unit id="0157777d67f21431cd43979bf17bb15a2c6fa069" translate="yes" xml:space="preserve">
          <source>Another caveat when building a unique index concurrently is that the uniqueness constraint is already being enforced against other transactions when the second table scan begins. This means that constraint violations could be reported in other queries prior to the index becoming available for use, or even in cases where the index build eventually fails. Also, if a failure does occur in the second scan, the &amp;ldquo;invalid&amp;rdquo; index continues to enforce its uniqueness constraint afterwards.</source>
          <target state="translated">同时构建唯一索引时的另一个警告是，当第二次表扫描开始时，已经对其他事务强制执行了唯一性约束。这意味着可以在索引可用之前甚至在索引构建最终失败的情况下，在其他查询中报告违反约束的情况。此外，如果在第二次扫描中确实发生了故障，则&amp;ldquo;无效&amp;rdquo;索引之后将继续执行其唯一性约束。</target>
        </trans-unit>
        <trans-unit id="8366e5720bf81785c8af920367ca1956fa9f6126" translate="yes" xml:space="preserve">
          <source>Another common reason for copying &lt;code&gt;template0&lt;/code&gt; instead of &lt;code&gt;template1&lt;/code&gt; is that new encoding and locale settings can be specified when copying &lt;code&gt;template0&lt;/code&gt;, whereas a copy of &lt;code&gt;template1&lt;/code&gt; must use the same settings it does. This is because &lt;code&gt;template1&lt;/code&gt; might contain encoding-specific or locale-specific data, while &lt;code&gt;template0&lt;/code&gt; is known not to.</source>
          <target state="translated">为复制另一个常见原因 &lt;code&gt;template0&lt;/code&gt; 而不是 &lt;code&gt;template1&lt;/code&gt; 的是，新的编码和区域设置可以复制时指定 &lt;code&gt;template0&lt;/code&gt; 中，而副本 &lt;code&gt;template1&lt;/code&gt; 必须用它做同样的设置。这是因为 &lt;code&gt;template1&lt;/code&gt; 可能包含特定于编码或特定于语言环境的数据，而众所周知 &lt;code&gt;template0&lt;/code&gt; 却不包含。</target>
        </trans-unit>
        <trans-unit id="fbb209aa36c1a4990c8b7ddd6d829419598146fa" translate="yes" xml:space="preserve">
          <source>Another consideration is that a &lt;code&gt;setval&lt;/code&gt; executed on such a sequence will not be noticed by other sessions until they have used up any preallocated values they have cached.</source>
          <target state="translated">另一个考虑因素是，在其他会话上，除非它们用尽了已缓存的任何预分配的值，否则其他会话不会注意到在此序列上执行的 &lt;code&gt;setval&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3dd197e47ceae278b1382e01aa4231fc834370d4" translate="yes" xml:space="preserve">
          <source>Another disadvantage of the rule approach is that there is no simple way to force an error if the set of rules doesn't cover the insertion date; the data will silently go into the master table instead.</source>
          <target state="translated">规则方法的另一个缺点是,如果规则集没有覆盖插入日期,没有简单的方法强制出错,数据将默默地进入主表,而不是。</target>
        </trans-unit>
        <trans-unit id="b74b279225b01a4f9a49098a715c0c2cd2860bb8" translate="yes" xml:space="preserve">
          <source>Another effect of &lt;code&gt;RECURSIVE&lt;/code&gt; is that &lt;code&gt;WITH&lt;/code&gt; queries need not be ordered: a query can reference another one that is later in the list. (However, circular references, or mutual recursion, are not implemented.) Without &lt;code&gt;RECURSIVE&lt;/code&gt;, &lt;code&gt;WITH&lt;/code&gt; queries can only reference sibling &lt;code&gt;WITH&lt;/code&gt; queries that are earlier in the &lt;code&gt;WITH&lt;/code&gt; list.</source>
          <target state="translated">&lt;code&gt;RECURSIVE&lt;/code&gt; 的另一个效果是，不需要对 &lt;code&gt;WITH&lt;/code&gt; 查询进行排序：查询可以引用列表中后面的另一个查询。（但是，不会实现循环引用或相互递归。）如果没有 &lt;code&gt;RECURSIVE&lt;/code&gt; ，则 &lt;code&gt;WITH&lt;/code&gt; 查询只能引用 &lt;code&gt;WITH&lt;/code&gt; 列表中较早的同级 &lt;code&gt;WITH&lt;/code&gt; 查询。</target>
        </trans-unit>
        <trans-unit id="f949f8323c537df82042ad10748a3400dd5e3c94" translate="yes" xml:space="preserve">
          <source>Another example &amp;mdash; the PostgreSQL mailing list archives contained 910,989 unique words with 57,491,343 lexemes in 461,020 messages.</source>
          <target state="translated">另一个示例-PostgreSQL邮件列表档案包含461,020条消息中的910,989个唯一单词和57,491,343个词素。</target>
        </trans-unit>
        <trans-unit id="e840dc5efd9dcea852680d04861f5d19522482d9" translate="yes" xml:space="preserve">
          <source>Another example demonstrating these concepts is that all these queries mean the same thing:</source>
          <target state="translated">另一个证明这些概念的例子是,所有这些查询的意思都是一样的。</target>
        </trans-unit>
        <trans-unit id="448793ead43f5a4696dde796c384f50ddecfec35" translate="yes" xml:space="preserve">
          <source>Another example with &lt;code&gt;--rate=100&lt;/code&gt; and &lt;code&gt;--latency-limit=5&lt;/code&gt; (note the additional &lt;code&gt;schedule_lag&lt;/code&gt; column):</source>
          <target state="translated">另一个示例 &lt;code&gt;--rate=100&lt;/code&gt; 和 &lt;code&gt;--latency-limit=5&lt;/code&gt; （请注意附加的 &lt;code&gt;schedule_lag&lt;/code&gt; 列）：</target>
        </trans-unit>
        <trans-unit id="1eb54ef0acd3e1a10201fcaabd71c9780026708a" translate="yes" xml:space="preserve">
          <source>Another form of table aliasing gives temporary names to the columns of the table, as well as the table itself:</source>
          <target state="translated">另一种形式的表别名为表的列以及表本身赋予临时名称。</target>
        </trans-unit>
        <trans-unit id="52020177212290ca0e1ac022789f990b2cddb766" translate="yes" xml:space="preserve">
          <source>Another identifier type used by the system is &lt;code&gt;xid&lt;/code&gt;, or transaction (abbreviated</source>
          <target state="translated">系统使用的另一种标识符类型是 &lt;code&gt;xid&lt;/code&gt; 或transaction（缩写为</target>
        </trans-unit>
        <trans-unit id="aed7ef2e15652a392b1a6ed9c8e4d99caec1a67e" translate="yes" xml:space="preserve">
          <source>Another important point is that when a server process is asked to display any of these statistics, it first fetches the most recent report emitted by the collector process and then continues to use this snapshot for all statistical views and functions until the end of its current transaction. So the statistics will show static information as long as you continue the current transaction. Similarly, information about the current queries of all sessions is collected when any such information is first requested within a transaction, and the same information will be displayed throughout the transaction. This is a feature, not a bug, because it allows you to perform several queries on the statistics and correlate the results without worrying that the numbers are changing underneath you. But if you want to see new results with each query, be sure to do the queries outside any transaction block. Alternatively, you can invoke &lt;code&gt;pg_stat_clear_snapshot&lt;/code&gt;(), which will discard the current transaction's statistics snapshot (if any). The next use of statistical information will cause a new snapshot to be fetched.</source>
          <target state="translated">另一个重要的一点是，当要求服务器进程显示这些统计信息中的任何一个时，它首先获取收集器进程发出的最新报告，然后继续将该快照用于所有统计视图和功能，直到其当前事务结束为止。因此，只要您继续当前事务，统计信息就会显示静态信息。类似地，当在事务中首次请求任何此类信息时，将收集有关所有会话的当前查询的信息，并且在整个事务中将显示相同的信息。这是一个功能，而不是错误，因为它使您可以对统计信息执行多个查询并关联结果，而不必担心数字在您下方变化。但是，如果您想在每个查询中看到新结果，确保在任何事务块之外进行查询。或者，您可以调用 &lt;code&gt;pg_stat_clear_snapshot&lt;/code&gt; （），它将丢弃当前事务的统计信息快照（如果有）。下次使用统计信息将导致获取新快照。</target>
        </trans-unit>
        <trans-unit id="b8503372565f5e8246e4f400f8ddf376d816116a" translate="yes" xml:space="preserve">
          <source>Another important property of transactional databases is closely related to the notion of atomic updates: when multiple transactions are running concurrently, each one should not be able to see the incomplete changes made by others. For example, if one transaction is busy totalling all the branch balances, it would not do for it to include the debit from Alice's branch but not the credit to Bob's branch, nor vice versa. So transactions must be all-or-nothing not only in terms of their permanent effect on the database, but also in terms of their visibility as they happen. The updates made so far by an open transaction are invisible to other transactions until the transaction completes, whereupon all the updates become visible simultaneously.</source>
          <target state="translated">事务性数据库的另一个重要属性与原子更新的概念密切相关:当多个事务同时运行时,每个事务都不应该看到其他事务所做的不完整的更改。例如,如果一个事务正忙于总计所有分支的余额,那么它就不能包括Alice分支的借方,而不包括Bob分支的贷方,反之亦然。所以,交易必须是全有或全无的,不仅是在它们对数据库的永久影响方面,而且是在它们发生时的可见性方面。一个开放的事务到目前为止所做的更新对其他事务来说是不可见的,直到事务完成,这时所有的更新同时变得可见。</target>
        </trans-unit>
        <trans-unit id="23097e202fa3204d32b939bd963d1f1a19f9bc71" translate="yes" xml:space="preserve">
          <source>Another limitation is that when an inner tuple's node points to a set of leaf tuples, those tuples must all be in the same index page. (This is a design decision to reduce seeking and save space in the links that chain such tuples together.) If the set of leaf tuples grows too large for a page, a split is performed and an intermediate inner tuple is inserted. For this to fix the problem, the new inner tuple &lt;em&gt;must&lt;/em&gt; divide the set of leaf values into more than one node group. If the operator class's &lt;code&gt;picksplit&lt;/code&gt; function fails to do that, the SP-GiST core resorts to extraordinary measures described in &lt;a href=&quot;spgist-implementation#SPGIST-ALL-THE-SAME&quot;&gt;Section 65.4.3&lt;/a&gt;.</source>
          <target state="translated">另一个限制是，当内部元组的节点指向一组叶元组时，这些元组必须全部在同一索引页中。 （这是一个设计决策，旨在减少查找并节省将此类元组链接在一起的链接中的空间。）如果叶元组的集合对于页面而言太大，则会执行拆分并插入中间的内部元组。为解决此问题，新的内部元组&lt;em&gt;必须&lt;/em&gt;将一组叶子值划分为多个节点组。如果操作员类的 &lt;code&gt;picksplit&lt;/code&gt; 函数不能做到这一点，则SP-GiST核心将采取&lt;a href=&quot;spgist-implementation#SPGIST-ALL-THE-SAME&quot;&gt;第65.4.3节中&lt;/a&gt;描述的特殊措施。</target>
        </trans-unit>
        <trans-unit id="3c5682b61a20f627d46e59c868bdcce430ea3716" translate="yes" xml:space="preserve">
          <source>Another limitation of the same kind is that a &lt;code&gt;CASE&lt;/code&gt; cannot prevent evaluation of an aggregate expression contained within it, because aggregate expressions are computed before other expressions in a &lt;code&gt;SELECT&lt;/code&gt; list or &lt;code&gt;HAVING&lt;/code&gt; clause are considered. For example, the following query can cause a division-by-zero error despite seemingly having protected against it:</source>
          <target state="translated">同类的另一个局限性是 &lt;code&gt;CASE&lt;/code&gt; 不能阻止对其中包含的聚合表达式的求值，因为聚合表达式是在考虑 &lt;code&gt;SELECT&lt;/code&gt; 列表或 &lt;code&gt;HAVING&lt;/code&gt; 子句中的其他表达式之前计算出来的。例如，尽管以下查询似乎已对其进行了保护，但以下查询仍可能导致被零除的错误：</target>
        </trans-unit>
        <trans-unit id="0e130eb29a636a2e4db63836c537e80b5eb47453" translate="yes" xml:space="preserve">
          <source>Another nonstandard extension is that following the escape character with a letter or digit provides access to the escape sequences defined for POSIX regular expressions; see &lt;a href=&quot;functions-matching#POSIX-CHARACTER-ENTRY-ESCAPES-TABLE&quot;&gt;Table 9.20&lt;/a&gt;, &lt;a href=&quot;functions-matching#POSIX-CLASS-SHORTHAND-ESCAPES-TABLE&quot;&gt;Table 9.21&lt;/a&gt;, and &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-ESCAPES-TABLE&quot;&gt;Table 9.22&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a59e6837fb64d2b0ae7bbcb08e5b72fd153fb2c" translate="yes" xml:space="preserve">
          <source>Another option for &lt;code&gt;local&lt;/code&gt; connections is for clients to use &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNECT-REQUIREPEER&quot;&gt;&lt;code&gt;requirepeer&lt;/code&gt;&lt;/a&gt; to specify the required owner of the server process connected to the socket.</source>
          <target state="translated">&lt;code&gt;local&lt;/code&gt; 连接的另一个选项是让客户端使用&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNECT-REQUIREPEER&quot;&gt; &lt;code&gt;requirepeer&lt;/code&gt; &lt;/a&gt;来指定连接到套接字的服务器进程的必需所有者。</target>
        </trans-unit>
        <trans-unit id="306459cbdd31101692b05f06a566b18b0bdf0e20" translate="yes" xml:space="preserve">
          <source>Another option for &lt;code&gt;local&lt;/code&gt; connections is for clients to use &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNECT-REQUIREPEER&quot;&gt;&lt;code&gt;requirepeer&lt;/code&gt;&lt;/a&gt; to specify the required owner of the server process connected to the socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb5714af00c74e15b8a5da4136ed86aaafa447c5" translate="yes" xml:space="preserve">
          <source>Another option is to increase &lt;a href=&quot;runtime-config-replication#GUC-VACUUM-DEFER-CLEANUP-AGE&quot;&gt;vacuum_defer_cleanup_age&lt;/a&gt; on the primary server, so that dead rows will not be cleaned up as quickly as they normally would be. This will allow more time for queries to execute before they are canceled on the standby, without having to set a high &lt;code&gt;max_standby_streaming_delay&lt;/code&gt;. However it is difficult to guarantee any specific execution-time window with this approach, since &lt;code&gt;vacuum_defer_cleanup_age&lt;/code&gt; is measured in transactions executed on the primary server.</source>
          <target state="translated">另一个选择是增加主服务器上的&lt;a href=&quot;runtime-config-replication#GUC-VACUUM-DEFER-CLEANUP-AGE&quot;&gt;vacuum_defer_cleanup_age&lt;/a&gt;，以使死行不会像平时那样快地被清理。这将使查询有更多时间在备用数据库上取消之前执行，而不必设置较高的 &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; 。但是，用这种方法很难保证任何特定的执行时间窗口，因为 &lt;code&gt;vacuum_defer_cleanup_age&lt;/code&gt; 是在主服务器上执行的事务中测量的。</target>
        </trans-unit>
        <trans-unit id="7e21e953eee19c97f61f831dca8e524d5dd57839" translate="yes" xml:space="preserve">
          <source>Another option is to use rsync to perform a file system backup. This is done by first running rsync while the database server is running, then shutting down the database server long enough to do an &lt;code&gt;rsync --checksum&lt;/code&gt;. (&lt;code&gt;--checksum&lt;/code&gt; is necessary because &lt;code&gt;rsync&lt;/code&gt; only has file modification-time granularity of one second.) The second rsync will be quicker than the first, because it has relatively little data to transfer, and the end result will be consistent because the server was down. This method allows a file system backup to be performed with minimal downtime.</source>
          <target state="translated">另一种选择是使用rsync来执行文件系统备份。首先通过在数据库服务器运行时运行rsync，然后关闭数据库服务器足够长的时间来执行 &lt;code&gt;rsync --checksum&lt;/code&gt; 来完成此操作。 （ &lt;code&gt;--checksum&lt;/code&gt; 是必需的，因为 &lt;code&gt;rsync&lt;/code&gt; 仅具有一秒钟的文件修改时间粒度。）第二个rsync将比第一个更快，因为它要传输的数据相对较少，并且最终结果将是一致的，因为服务器是下。此方法允许在最少停机时间的情况下执行文件系统备份。</target>
        </trans-unit>
        <trans-unit id="7c34c9f74979196480818c068869e2f214816a27" translate="yes" xml:space="preserve">
          <source>Another option that is often preferable is to remove the partition from the partitioned table but retain access to it as a table in its own right:</source>
          <target state="translated">另一个通常更可取的选择是将分区从分区表中移除,但保留对它作为一个表本身的访问。</target>
        </trans-unit>
        <trans-unit id="2a69438b1163aac867f43267272d34d1c58b2559" translate="yes" xml:space="preserve">
          <source>Another point to keep in mind is that by default, execute privilege is granted to &lt;code&gt;PUBLIC&lt;/code&gt; for newly created functions (see &lt;a href=&quot;ddl-priv&quot;&gt;Section 5.7&lt;/a&gt; for more information). Frequently you will wish to restrict use of a security definer function to only some users. To do that, you must revoke the default &lt;code&gt;PUBLIC&lt;/code&gt; privileges and then grant execute privilege selectively. To avoid having a window where the new function is accessible to all, create it and set the privileges within a single transaction. For example:</source>
          <target state="translated">要记住的另一点是，默认情况下，对新创建的函数， &lt;code&gt;PUBLIC&lt;/code&gt; 被授予执行特权（有关更多信息，请参见&lt;a href=&quot;ddl-priv&quot;&gt;5.7节&lt;/a&gt;）。通常，您希望将安全定义器功能的使用仅限于某些用户。为此，您必须撤消默认的 &lt;code&gt;PUBLIC&lt;/code&gt; 特权，然后有选择地授予执行特权。为了避免有一个可供所有人使用新功能的窗口，请创建该功能并在单个事务中设置特权。例如：</target>
        </trans-unit>
        <trans-unit id="c64ca403c18f38074dbf9506c7423e6c0d47b0ca" translate="yes" xml:space="preserve">
          <source>Another possibility is to create a configuration file directory and put this information into files there. For example, a &lt;code&gt;conf.d&lt;/code&gt; directory could be referenced at the end of &lt;code&gt;postgresql.conf&lt;/code&gt;:</source>
          <target state="translated">另一种可能性是创建一个配置文件目录，并将此信息放入那里的文件中。例如，可以在 &lt;code&gt;postgresql.conf&lt;/code&gt; 的末尾引用 &lt;code&gt;conf.d&lt;/code&gt; 目录：</target>
        </trans-unit>
        <trans-unit id="e15bc878f1b5a7c697e8423bcee242bc5167d6a2" translate="yes" xml:space="preserve">
          <source>Another possibility is to store the documents as simple text files in the file system. In this case, the database can be used to store the full text index and to execute searches, and some unique identifier can be used to retrieve the document from the file system. However, retrieving files from outside the database requires superuser permissions or special function support, so this is usually less convenient than keeping all the data inside PostgreSQL. Also, keeping everything inside the database allows easy access to document metadata to assist in indexing and display.</source>
          <target state="translated">另一种可能性是将文件作为简单的文本文件存储在文件系统中。在这种情况下,数据库可以用来存储全文索引和执行搜索,并且可以使用一些独特的标识符从文件系统中检索文件。但是,从数据库外部检索文件需要超级用户权限或特殊函数支持,所以这通常不如将所有数据保存在PostgreSQL内部方便。另外,把所有的东西都保存在数据库内,可以方便地访问文件元数据,以协助索引和显示。</target>
        </trans-unit>
        <trans-unit id="8fbada3201971de13171c32bf7cda835bc3fd1af" translate="yes" xml:space="preserve">
          <source>Another possible type of join is a merge join, illustrated here:</source>
          <target state="translated">另一种可能的连接类型是合并连接,在此说明。</target>
        </trans-unit>
        <trans-unit id="19829ac1739436800f592d8b7c21c52fef4c33d8" translate="yes" xml:space="preserve">
          <source>Another possible use for a partial index is to exclude values from the index that the typical query workload is not interested in; this is shown in &lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX2&quot;&gt;Example 11.2&lt;/a&gt;. This results in the same advantages as listed above, but it prevents the &amp;ldquo;uninteresting&amp;rdquo; values from being accessed via that index, even if an index scan might be profitable in that case. Obviously, setting up partial indexes for this kind of scenario will require a lot of care and experimentation.</source>
          <target state="translated">部分索引的另一种可能用法是从索引中排除典型查询工作负载不感兴趣的值；如&lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX2&quot;&gt;例11.2&lt;/a&gt;所示。这具有与上面列出的相同的优点，但是即使在这种情况下索引扫描可能是有利的，它也可以防止通过该索引访问&amp;ldquo;不感兴趣的&amp;rdquo;值。显然，为这种情况设置部分索引将需要大量的注意和试验。</target>
        </trans-unit>
        <trans-unit id="f28a354a8ba88184cb3beacb89675afbd6c03d21" translate="yes" xml:space="preserve">
          <source>Another production-grade approach to managing log output is to send it to syslog and let syslog deal with file rotation. To do this, set the configuration parameter &lt;code&gt;log_destination&lt;/code&gt; to &lt;code&gt;syslog&lt;/code&gt; (to log to syslog only) in &lt;code&gt;postgresql.conf&lt;/code&gt;. Then you can send a &lt;code&gt;SIGHUP&lt;/code&gt; signal to the syslog daemon whenever you want to force it to start writing a new log file. If you want to automate log rotation, the logrotate program can be configured to work with log files from syslog.</source>
          <target state="translated">管理日志输出的另一种生产级方法是将其发送到syslog，并让syslog处理文件轮换。为此，请将 &lt;code&gt;postgresql.conf&lt;/code&gt; 中的配置参数 &lt;code&gt;log_destination&lt;/code&gt; 设置为 &lt;code&gt;syslog&lt;/code&gt; （仅记录到syslog）。然后，只要您想强制它开始写入新的日志文件，就可以将 &lt;code&gt;SIGHUP&lt;/code&gt; 信号发送到syslog守护程序。如果要自动执行日志轮换，可以将logrotate程序配置为使用syslog中的日志文件。</target>
        </trans-unit>
        <trans-unit id="0d7e78b3e262e81affaac44d4c64dc15d4edfbba" translate="yes" xml:space="preserve">
          <source>Another reason to use &lt;code&gt;FOR UPDATE&lt;/code&gt; is that without it, a subsequent &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; might fail if the cursor query does not meet the SQL standard's rules for being &amp;ldquo;simply updatable&amp;rdquo; (in particular, the cursor must reference just one table and not use grouping or &lt;code&gt;ORDER BY&lt;/code&gt;). Cursors that are not simply updatable might work, or might not, depending on plan choice details; so in the worst case, an application might work in testing and then fail in production. If &lt;code&gt;FOR UPDATE&lt;/code&gt; is specified, the cursor is guaranteed to be updatable.</source>
          <target state="translated">使用 &lt;code&gt;FOR UPDATE&lt;/code&gt; 的另一个原因是，如果没有它，则如果游标查询不符合SQL标准的&amp;ldquo;仅可更新&amp;rdquo;规则，则后续的 &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; 可能会失败（特别是，游标必须仅引用一个表并且不使用分组）或 &lt;code&gt;ORDER BY&lt;/code&gt; ）。根据计划选择的详细信息，不能简单更新的游标可能会起作用，也可能不会起作用。因此在最坏的情况下，应用程序可能会在测试中工作，然后在生产中失败。如果指定了 &lt;code&gt;FOR UPDATE&lt;/code&gt; ，则保证游标是可更新的。</target>
        </trans-unit>
        <trans-unit id="6f33d845713febc0898090d451e4ee3ef8ebffb5" translate="yes" xml:space="preserve">
          <source>Another requirement for a multiple-data-type family is that any implicit or binary-coercion casts that are defined between data types included in the operator family must not change the associated sort ordering.</source>
          <target state="translated">对多数据类型族的另一个要求是,在包含在运算符族中的数据类型之间定义的任何隐式或二元胁迫投掷都不能改变相关的排序。</target>
        </trans-unit>
        <trans-unit id="9114df95c9c9d6782e38dbaee1edab69dd63ee66" translate="yes" xml:space="preserve">
          <source>Another response could be this:</source>
          <target state="translated">另一个对策可以是这样。</target>
        </trans-unit>
        <trans-unit id="67c38a78e448cde09317f71b64feae68f30e256d" translate="yes" xml:space="preserve">
          <source>Another risk of data loss is posed by the disk platter write operations themselves. Disk platters are divided into sectors, commonly 512 bytes each. Every physical read or write operation processes a whole sector. When a write request arrives at the drive, it might be for some multiple of 512 bytes (PostgreSQL typically writes 8192 bytes, or 16 sectors, at a time), and the process of writing could fail due to power loss at any time, meaning some of the 512-byte sectors were written while others were not. To guard against such failures, PostgreSQL periodically writes full page images to permanent WAL storage &lt;em&gt;before&lt;/em&gt; modifying the actual page on disk. By doing this, during crash recovery PostgreSQL can restore partially-written pages from WAL. If you have file-system software that prevents partial page writes (e.g., ZFS), you can turn off this page imaging by turning off the &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; parameter. Battery-Backed Unit (BBU) disk controllers do not prevent partial page writes unless they guarantee that data is written to the BBU as full (8kB) pages.</source>
          <target state="translated">数据磁盘拼写操作本身也会带来数据丢失的另一风险。磁盘盘分为多个扇区，每个扇区通常为512字节。每个物理读或写操作都处理整个扇区。当写入请求到达驱动器时，它可能是512字节的某个倍数（PostgreSQL通常一次写入8192字节或16个扇区），并且写入过程可能随时因断电而失败，这意味着某些512字节的扇区已写入，而其他则未写入。为了防止此类故障，PostgreSQL会在将WFS永久存储&lt;em&gt;之前&lt;/em&gt;定期将整页图像写入永久性WAL存储中&lt;em&gt;。&lt;/em&gt;修改磁盘上的实际页面。这样，在崩溃恢复期间，PostgreSQL可以从WAL还原部分编写的页面。如果您具有防止部分页面写入的文件系统软件（例如ZFS），则可以通过关闭&lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt;参数来关闭此页面映像。电池后备单元（BBU）磁盘控制器不会阻止部分页面写入，除非它们保证数据以完整（8kB）页面写入到BBU。</target>
        </trans-unit>
        <trans-unit id="a64140ba6c591322306ded2e563c831d5063eb12" translate="yes" xml:space="preserve">
          <source>Another special feature is that during input, you can write &lt;code&gt;?&lt;/code&gt; in place of the check digit, and the correct check digit will be inserted automatically.</source>
          <target state="translated">另一个特殊功能是在输入过程中，您可以编写 &lt;code&gt;?&lt;/code&gt; 代替校验位，正确的校验位将被自动插入。</target>
        </trans-unit>
        <trans-unit id="d8a7029d22a4fea1aec3f6a0a7967d7366ab11c8" translate="yes" xml:space="preserve">
          <source>Another special syntactical behavior associated with composite values is that we can use &lt;em&gt;functional notation&lt;/em&gt; for extracting a field of a composite value. The simple way to explain this is that the notations &lt;code&gt;field(table)&lt;/code&gt; and &lt;code&gt;table.field&lt;/code&gt; are interchangeable. For example, these queries are equivalent:</source>
          <target state="translated">与复合值相关的另一种特殊语法行为是，我们可以使用&lt;em&gt;功能符号&lt;/em&gt;来提取复合值的字段。解释此问题的简单方法是，记号 &lt;code&gt;field(table)&lt;/code&gt; 和 &lt;code&gt;table.field&lt;/code&gt; 是可互换的。例如，这些查询是等效的：</target>
        </trans-unit>
        <trans-unit id="2d14ebbe44cc336bb06782ca5c2e2a5afdbf5d04" translate="yes" xml:space="preserve">
          <source>Another type of extra information is the number of rows removed by a filter condition:</source>
          <target state="translated">另一种类型的额外信息是被过滤条件删除的行数。</target>
        </trans-unit>
        <trans-unit id="de04ff7f29beb7d9f803262abe6fbc7f7a247ce7" translate="yes" xml:space="preserve">
          <source>Another type of statistics stored for each column are most-common value lists. This allows very accurate estimates for individual columns, but may result in significant misestimates for queries with conditions on multiple columns.</source>
          <target state="translated">另一种为每一列存储的统计数据是最常见值列表。这可以对单个列进行非常精确的估计,但对于有多列条件的查询来说,可能会导致严重的错误估计。</target>
        </trans-unit>
        <trans-unit id="aef386cf940d64dd2d0246974eb986d99db04233" translate="yes" xml:space="preserve">
          <source>Another useful tool for monitoring database activity is the &lt;code&gt;pg_locks&lt;/code&gt; system table. It allows the database administrator to view information about the outstanding locks in the lock manager. For example, this capability can be used to:</source>
          <target state="translated">监视数据库活动的另一个有用工具是 &lt;code&gt;pg_locks&lt;/code&gt; 系统表。它允许数据库管理员在锁管理器中查看有关未完成锁的信息。例如，此功能可用于：</target>
        </trans-unit>
        <trans-unit id="973de1b89f5a19d8493a281c676145e3c2762491" translate="yes" xml:space="preserve">
          <source>Another value expression in parentheses (used to group subexpressions and override precedence)</source>
          <target state="translated">括号中的另一个值表达式(用于对子表达式进行分组并覆盖优先级)。</target>
        </trans-unit>
        <trans-unit id="6edaee98c73d284626179be9ad3ba0277589e38b" translate="yes" xml:space="preserve">
          <source>Another way to accomplish the same thing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a50bf5d6a0c79646db228f587b35fc8dbea931f" translate="yes" xml:space="preserve">
          <source>Another way to do it is:</source>
          <target state="translated">另一种方法是。</target>
        </trans-unit>
        <trans-unit id="09b69091260be1fa872b4a938337bcecea2b0096" translate="yes" xml:space="preserve">
          <source>Another way to get the same effect is to use the &lt;code&gt;regclass&lt;/code&gt; alias type, which will print the table OID symbolically:</source>
          <target state="translated">获得相同效果的另一种方法是使用 &lt;code&gt;regclass&lt;/code&gt; 别名类型，该类型将象征性地打印表OID：</target>
        </trans-unit>
        <trans-unit id="77f482e38cebbd37d2bd4865436228573a9f332c" translate="yes" xml:space="preserve">
          <source>Another way to obtain the same result as &lt;code&gt;\copy ... to&lt;/code&gt; is to use the SQL &lt;code&gt;COPY ... TO STDOUT&lt;/code&gt; command and terminate it with &lt;code&gt;\g filename&lt;/code&gt; or &lt;code&gt;\g |program&lt;/code&gt;. Unlike &lt;code&gt;\copy&lt;/code&gt;, this method allows the command to span multiple lines; also, variable interpolation and backquote expansion can be used.</source>
          <target state="translated">获得与 &lt;code&gt;\copy ... to&lt;/code&gt; 相同结果的另一种方法是使用SQL &lt;code&gt;COPY ... TO STDOUT&lt;/code&gt; 命令并以 &lt;code&gt;\g filename&lt;/code&gt; 或 &lt;code&gt;\g |program&lt;/code&gt; 终止它。与 &lt;code&gt;\copy&lt;/code&gt; 不同，此方法允许命令跨越多行。同样，可以使用变量插值和反引号扩展。</target>
        </trans-unit>
        <trans-unit id="af0ee54bbb9066194d74463e9d95fe7b567d2abb" translate="yes" xml:space="preserve">
          <source>Another way to return multiple columns is to use a &lt;code&gt;TABLE&lt;/code&gt; function:</source>
          <target state="translated">返回多列的另一种方法是使用 &lt;code&gt;TABLE&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="886fca6d2b20a157de482df72d3dea2c336eadc6" translate="yes" xml:space="preserve">
          <source>Another way to think about a discrete range type is that there is a clear idea of a &amp;ldquo;next&amp;rdquo; or &amp;ldquo;previous&amp;rdquo; value for each element value. Knowing that, it is possible to convert between inclusive and exclusive representations of a range's bounds, by choosing the next or previous element value instead of the one originally given. For example, in an integer range type &lt;code&gt;[4,8]&lt;/code&gt; and &lt;code&gt;(3,9)&lt;/code&gt; denote the same set of values; but this would not be so for a range over numeric.</source>
          <target state="translated">考虑离散范围类型的另一种方法是，每个元素值都有一个&amp;ldquo;下一个&amp;rdquo;或&amp;ldquo;上一个&amp;rdquo;值的清晰概念。知道这一点，可以通过选择下一个或上一个元素值而不是最初指定的值来在范围边界的包含表示和排除表示之间进行转换。例如，在整数范围中，类型 &lt;code&gt;[4,8]&lt;/code&gt; 和 &lt;code&gt;(3,9)&lt;/code&gt; 表示同一组值；但是对于数字范围则不是这样。</target>
        </trans-unit>
        <trans-unit id="d84849349152ff8e618adbfaeb1704c4dc99ecf7" translate="yes" xml:space="preserve">
          <source>Another way to work with angles measured in degrees is to use the unit transformation functions &lt;code&gt;radians()&lt;/code&gt; and &lt;code&gt;degrees()&lt;/code&gt; shown earlier. However, using the degree-based trigonometric functions is preferred, as that way avoids round-off error for special cases such as &lt;code&gt;sind(30)&lt;/code&gt;.</source>
          <target state="translated">处理以度为单位的角度的另一种方法是使用前面显示的单位转换函数 &lt;code&gt;radians()&lt;/code&gt; 和 &lt;code&gt;degrees()&lt;/code&gt; 。但是，最好使用基于度的三角函数，因为这样可以避免在诸如 &lt;code&gt;sind(30)&lt;/code&gt; 之类的特殊情况下产生舍入误差。</target>
        </trans-unit>
        <trans-unit id="efdd30de2aea5b5d5befd3533f098d92f63380ab" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;VALUES&lt;/code&gt;, &lt;code&gt;EXECUTE&lt;/code&gt;, &lt;code&gt;DECLARE&lt;/code&gt;, &lt;code&gt;CREATE TABLE AS&lt;/code&gt;, or &lt;code&gt;CREATE MATERIALIZED VIEW AS&lt;/code&gt; statement, whose execution plan you wish to see.</source>
          <target state="translated">您希望 &lt;code&gt;CREATE MATERIALIZED VIEW AS&lt;/code&gt; 其执行计划的任何 &lt;code&gt;SELECT&lt;/code&gt; ， &lt;code&gt;INSERT&lt;/code&gt; ， &lt;code&gt;UPDATE&lt;/code&gt; ， &lt;code&gt;DELETE&lt;/code&gt; ， &lt;code&gt;VALUES&lt;/code&gt; ， &lt;code&gt;EXECUTE&lt;/code&gt; ， &lt;code&gt;DECLARE&lt;/code&gt; ， &lt;code&gt;CREATE TABLE AS&lt;/code&gt; 或CREATE MATERIALIZED VIEW AS语句。</target>
        </trans-unit>
        <trans-unit id="386ffc8dd49c3fb7f2ddd349b2b9b4201e8b40ad" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, or &lt;code&gt;VALUES&lt;/code&gt; statement.</source>
          <target state="translated">任何 &lt;code&gt;SELECT&lt;/code&gt; ， &lt;code&gt;INSERT&lt;/code&gt; ， &lt;code&gt;UPDATE&lt;/code&gt; ， &lt;code&gt;DELETE&lt;/code&gt; 或 &lt;code&gt;VALUES&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="450e11982aec06ef4f3dbb171ba6a8eb1e20a7be" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;cidr&lt;/code&gt; value can be cast to &lt;code&gt;inet&lt;/code&gt; implicitly or explicitly; therefore, the functions shown above as operating on &lt;code&gt;inet&lt;/code&gt; also work on &lt;code&gt;cidr&lt;/code&gt; values. (Where there are separate functions for &lt;code&gt;inet&lt;/code&gt; and &lt;code&gt;cidr&lt;/code&gt;, it is because the behavior should be different for the two cases.) Also, it is permitted to cast an &lt;code&gt;inet&lt;/code&gt; value to &lt;code&gt;cidr&lt;/code&gt;. When this is done, any bits to the right of the netmask are silently zeroed to create a valid &lt;code&gt;cidr&lt;/code&gt; value. In addition, you can cast a text value to &lt;code&gt;inet&lt;/code&gt; or &lt;code&gt;cidr&lt;/code&gt; using normal casting syntax: for example, &lt;code&gt;inet(expression)&lt;/code&gt; or &lt;code&gt;colname::cidr&lt;/code&gt;.</source>
          <target state="translated">任何 &lt;code&gt;cidr&lt;/code&gt; 值都可以隐式或显式转换为 &lt;code&gt;inet&lt;/code&gt; ；因此，上面显示为在 &lt;code&gt;inet&lt;/code&gt; 上运行的功能也适用于 &lt;code&gt;cidr&lt;/code&gt; 值。 （在 &lt;code&gt;inet&lt;/code&gt; 和 &lt;code&gt;cidr&lt;/code&gt; 有单独的函数的地方，这是因为这两种情况的行为应该不同。）而且，允许将 &lt;code&gt;inet&lt;/code&gt; 值 &lt;code&gt;cidr&lt;/code&gt; 为cidr。当做到这一点，在网络掩码的权利的任何位被默默零创建一个有效的 &lt;code&gt;cidr&lt;/code&gt; 值。此外，您可以使用常规转换语法将文本值转换为 &lt;code&gt;inet&lt;/code&gt; 或 &lt;code&gt;cidr&lt;/code&gt; ：例如 &lt;code&gt;inet(expression)&lt;/code&gt; 或 &lt;code&gt;colname::cidr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8208175702ffb5cdd4ede5051892cf19b0e69014" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;cidr&lt;/code&gt; value can be cast to &lt;code&gt;inet&lt;/code&gt; implicitly; therefore, the operators and functions shown below as operating on &lt;code&gt;inet&lt;/code&gt; also work on &lt;code&gt;cidr&lt;/code&gt; values. (Where there are separate functions for &lt;code&gt;inet&lt;/code&gt; and &lt;code&gt;cidr&lt;/code&gt;, it is because the behavior should be different for the two cases.) Also, it is permitted to cast an &lt;code&gt;inet&lt;/code&gt; value to &lt;code&gt;cidr&lt;/code&gt;. When this is done, any bits to the right of the netmask are silently zeroed to create a valid &lt;code&gt;cidr&lt;/code&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97a5e9f25fdf2d6789317985300af494edaa42f6" translate="yes" xml:space="preserve">
          <source>Any SQL conditional expression (returning &lt;code&gt;boolean&lt;/code&gt;). The condition expression cannot refer to any tables except &lt;code&gt;NEW&lt;/code&gt; and &lt;code&gt;OLD&lt;/code&gt;, and cannot contain aggregate functions.</source>
          <target state="translated">任何SQL条件表达式（返回 &lt;code&gt;boolean&lt;/code&gt; ）。条件表达式不能引用除 &lt;code&gt;NEW&lt;/code&gt; 和 &lt;code&gt;OLD&lt;/code&gt; 之外的任何表，并且不能包含聚合函数。</target>
        </trans-unit>
        <trans-unit id="7f04645af195b0769f156d1c9178d5413d13947d" translate="yes" xml:space="preserve">
          <source>Any SQL conditional expression (returning &lt;code&gt;boolean&lt;/code&gt;). The conditional expression cannot contain any aggregate or window functions. This expression will be added to queries that refer to the table if row level security is enabled. Rows for which the expression returns true will be visible. Any rows for which the expression returns false or null will not be visible to the user (in a &lt;code&gt;SELECT&lt;/code&gt;), and will not be available for modification (in an &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt;). Such rows are silently suppressed; no error is reported.</source>
          <target state="translated">任何SQL条件表达式（返回 &lt;code&gt;boolean&lt;/code&gt; ）。条件表达式不能包含任何聚合或窗口函数。如果启用了行级安全性，则此表达式将添加到引用该表的查询中。表达式返回true的行将可见。表达式返回false或null的任何行对用户都不可见（在 &lt;code&gt;SELECT&lt;/code&gt; 中），并且不可修改（在 &lt;code&gt;UPDATE&lt;/code&gt; 或 &lt;code&gt;DELETE&lt;/code&gt; 中）。这样的行被静默抑制；没有错误的报告。</target>
        </trans-unit>
        <trans-unit id="9d0a8e5978d0613618d7d621bf1cd5c083979c7e" translate="yes" xml:space="preserve">
          <source>Any SQL conditional expression (returning &lt;code&gt;boolean&lt;/code&gt;). The conditional expression cannot contain any aggregate or window functions. This expression will be used in &lt;code&gt;INSERT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; queries against the table if row level security is enabled. Only rows for which the expression evaluates to true will be allowed. An error will be thrown if the expression evaluates to false or null for any of the records inserted or any of the records that result from the update. Note that the &lt;code&gt;check_expression&lt;/code&gt; is evaluated against the proposed new contents of the row, not the original contents.</source>
          <target state="translated">任何SQL条件表达式（返回 &lt;code&gt;boolean&lt;/code&gt; ）。条件表达式不能包含任何聚合或窗口函数。如果启用了行级安全性，则该表达式将在针对表的 &lt;code&gt;INSERT&lt;/code&gt; 和 &lt;code&gt;UPDATE&lt;/code&gt; 查询中使用。仅允许表达式计算为true的行。如果对于任何插入的记录或更新产生的任何记录，表达式的计算结果为false或null，则将引发错误。请注意， &lt;code&gt;check_expression&lt;/code&gt; 是针对该行的建议新内容而不是原始内容进行评估的。</target>
        </trans-unit>
        <trans-unit id="3e356ac9cfe76e1d8f07ddb1a43d7eac6d271ea2" translate="yes" xml:space="preserve">
          <source>Any character in &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; that matches a character in the &lt;em&gt;&lt;code&gt;from&lt;/code&gt;&lt;/em&gt; set is replaced by the corresponding character in the &lt;em&gt;&lt;code&gt;to&lt;/code&gt;&lt;/em&gt; set. If &lt;em&gt;&lt;code&gt;from&lt;/code&gt;&lt;/em&gt; is longer than &lt;em&gt;&lt;code&gt;to&lt;/code&gt;&lt;/em&gt;, occurrences of the extra characters in &lt;em&gt;&lt;code&gt;from&lt;/code&gt;&lt;/em&gt; are removed.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt;中与&lt;em&gt; &lt;code&gt;from&lt;/code&gt; &lt;/em&gt;集中的字符匹配的任何字符都将替换为&lt;em&gt; &lt;code&gt;to&lt;/code&gt; &lt;/em&gt;集中的相应字符。如果&lt;em&gt; &lt;code&gt;from&lt;/code&gt; &lt;/em&gt;的长度大于&lt;em&gt; &lt;code&gt;to&lt;/code&gt; &lt;/em&gt;的长度，则会删除&lt;em&gt; &lt;code&gt;from&lt;/code&gt; &lt;/em&gt;中多余字符的出现。</target>
        </trans-unit>
        <trans-unit id="12f81b0886507c6c81c137ed43e36901064a888a" translate="yes" xml:space="preserve">
          <source>Any developer of a new &lt;code&gt;table access method&lt;/code&gt; can refer to the existing &lt;code&gt;heap&lt;/code&gt; implementation present in &lt;code&gt;src/backend/access/heap/heapam_handler.c&lt;/code&gt; for details of its implementation.</source>
          <target state="translated">任何使用新 &lt;code&gt;table access method&lt;/code&gt; 开发人员都可以参考 &lt;code&gt;src/backend/access/heap/heapam_handler.c&lt;/code&gt; 中存在的现有 &lt;code&gt;heap&lt;/code&gt; 实现，以了解其实现的详细信息。</target>
        </trans-unit>
        <trans-unit id="144550beabeed185659254b872d28c678638c93a" translate="yes" xml:space="preserve">
          <source>Any digest algorithm OpenSSL supports is automatically picked up. This is not possible with ciphers, which need to be supported explicitly.</source>
          <target state="translated">任何OpenSSL支持的摘要算法都会被自动接收。这对于密码算法来说是不可能的,因为密码算法需要被明确支持。</target>
        </trans-unit>
        <trans-unit id="c4c8c401fe264a209ebccf99c5f886fc113da7d7" translate="yes" xml:space="preserve">
          <source>Any file or directory beginning with &lt;code&gt;pgsql_tmp&lt;/code&gt; can be omitted from the backup. These files are removed on postmaster start and the directories will be recreated as needed.</source>
          <target state="translated">备份中可以省略以 &lt;code&gt;pgsql_tmp&lt;/code&gt; 开头的任何文件或目录。这些文件在邮局主管启动后将被删除，并将根据需要重新创建目录。</target>
        </trans-unit>
        <trans-unit id="a836141ba30a8aa1360f43439d3c24535024a80a" translate="yes" xml:space="preserve">
          <source>Any generation expressions of copied column definitions will be copied. By default, new columns will be regular base columns.</source>
          <target state="translated">复制的列定义的任何生成表达式都将被复制。默认情况下,新列将是常规的基础列。</target>
        </trans-unit>
        <trans-unit id="5e18734ff6a37a9bb9fd3457eedcb31fb70163d6" translate="yes" xml:space="preserve">
          <source>Any identity specifications of copied column definitions will be copied. A new sequence is created for each identity column of the new table, separate from the sequences associated with the old table.</source>
          <target state="translated">复制的列定义的任何身份规格都将被复制。为新表的每个身份列创建一个新序列,与旧表关联的序列分开。</target>
        </trans-unit>
        <trans-unit id="feba919d6ac95ebb1703749287894bc69e982374" translate="yes" xml:space="preserve">
          <source>Any memberships in the group role are automatically revoked (but the member roles are not otherwise affected).</source>
          <target state="translated">组角色中的任何成员资格都会自动撤销(但成员角色不会受到其他影响)。</target>
        </trans-unit>
        <trans-unit id="13a56d22fdbd5ea4aa4d99bf869d62836d2a9dbc" translate="yes" xml:space="preserve">
          <source>Any object that can be created with a &lt;code&gt;CREATE&lt;/code&gt; command. Most objects are specific to one database, and are commonly known as &lt;em&gt;local objects&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f42a74d5d4ceddfdc2731676cd56c9941e931e10" translate="yes" xml:space="preserve">
          <source>Any other backslashed character that is not mentioned in the above table will be taken to represent itself. However, beware of adding backslashes unnecessarily, since that might accidentally produce a string matching the end-of-data marker (&lt;code&gt;\.&lt;/code&gt;) or the null string (&lt;code&gt;\N&lt;/code&gt; by default). These strings will be recognized before any other backslash processing is done.</source>
          <target state="translated">上表中未提及的任何其他反斜杠字符都将代表其自身。但是，请注意不要不必要地添加反斜杠，因为这可能会意外地生成与数据结尾标记（ &lt;code&gt;\.&lt;/code&gt; ）或空字符串（默认为 &lt;code&gt;\N&lt;/code&gt; ）匹配的字符串。在完成任何其他反斜杠处理之前，将识别这些字符串。</target>
        </trans-unit>
        <trans-unit id="59556037a647190d9808748d3940223c9b60fa38" translate="yes" xml:space="preserve">
          <source>Any other character following a backslash is taken literally. Thus, to include a backslash character, write two backslashes (&lt;code&gt;\\&lt;/code&gt;). Also, a single quote can be included in an escape string by writing &lt;code&gt;\'&lt;/code&gt;, in addition to the normal way of &lt;code&gt;''&lt;/code&gt;.</source>
          <target state="translated">反斜杠后的所有其他字符均按字面意义使用。因此，要包含反斜杠字符，请写两个反斜杠（ &lt;code&gt;\\&lt;/code&gt; ）。另外，除常规的 &lt;code&gt;''&lt;/code&gt; 之外，还可以通过写 &lt;code&gt;\'&lt;/code&gt; 将单引号包含在转义字符串中。</target>
        </trans-unit>
        <trans-unit id="deecfecd8837d0982d5dc84b37df7cbf1f0b77cf" translate="yes" xml:space="preserve">
          <source>Any process, possibly remote, that establishes a &lt;a href=&quot;glossary#GLOSSARY-SESSION&quot;&gt;session&lt;/a&gt; by &lt;a href=&quot;glossary#GLOSSARY-CONNECTION&quot;&gt;connecting&lt;/a&gt; to an &lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;instance&lt;/a&gt; to interact with a &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6176992a355fd17e3c78216ef8246e171f7a7f5d" translate="yes" xml:space="preserve">
          <source>Any rows whose updated values do not pass the &lt;code&gt;WITH CHECK&lt;/code&gt; expression will cause an error, and the entire command will be aborted. If only a &lt;code&gt;USING&lt;/code&gt; clause is specified, then that clause will be used for both &lt;code&gt;USING&lt;/code&gt; and &lt;code&gt;WITH CHECK&lt;/code&gt; cases.</source>
          <target state="translated">更新值未通过 &lt;code&gt;WITH CHECK&lt;/code&gt; 表达式的任何行都将导致错误，并且整个命令将被中止。如果仅指定了 &lt;code&gt;USING&lt;/code&gt; 子句，则该子句将用于 &lt;code&gt;USING&lt;/code&gt; 和 &lt;code&gt;WITH CHECK&lt;/code&gt; 情况。</target>
        </trans-unit>
        <trans-unit id="e53b9947d34df736f27a314411d8d097ccb99c38" translate="yes" xml:space="preserve">
          <source>Any two opposite corners can be supplied on input, but the values will be reordered as needed to store the upper right and lower left corners, in that order.</source>
          <target state="translated">可以在输入时提供任意两个相反的角,但数值将根据需要重新排序,以存储右上角和左下角的顺序。</target>
        </trans-unit>
        <trans-unit id="9cd48f92d0048ad74a4b2a1c77759555487aa4a5" translate="yes" xml:space="preserve">
          <source>Any value of &lt;a href=&quot;runtime-config-client#GUC-EXTRA-FLOAT-DIGITS&quot;&gt;extra_float_digits&lt;/a&gt; greater than 0 selects the shortest-precise format.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-client#GUC-EXTRA-FLOAT-DIGITS&quot;&gt;extra_float_digits的&lt;/a&gt;任何大于0的值都将选择最短格式。</target>
        </trans-unit>
        <trans-unit id="6e1092ad7e1aa0d329dcf1a1dc88a2fd1167428b" translate="yes" xml:space="preserve">
          <source>Anything you enter in psql that begins with an unquoted backslash is a psql meta-command that is processed by psql itself. These commands make psql more useful for administration or scripting. Meta-commands are often called slash or backslash commands.</source>
          <target state="translated">在psql中输入的任何以未加引号的反斜线开头的内容都是psql元命令,由psql自己处理。这些命令使psql在管理或脚本编写方面更加有用。元命令通常被称为斜线或反斜线命令。</target>
        </trans-unit>
        <trans-unit id="ca34db883b90f5136d142c2d8962aac808f06344" translate="yes" xml:space="preserve">
          <source>Append the server log output to &lt;code&gt;filename&lt;/code&gt;. If the file does not exist, it is created. The umask is set to 077, so access to the log file is disallowed to other users by default.</source>
          <target state="translated">将服务器日志输出追加到 &lt;code&gt;filename&lt;/code&gt; 。如果该文件不存在，则会创建它。umask设置为077，因此默认情况下其他用户不允许访问日志文件。</target>
        </trans-unit>
        <trans-unit id="8837d91fde54bfbd4c7276bc104dbd7eb57e326a" translate="yes" xml:space="preserve">
          <source>Appendix A. PostgreSQL Error Codes</source>
          <target state="translated">附录A.PostgreSQL错误代码</target>
        </trans-unit>
        <trans-unit id="8f525f98762ab18cc61fb77a68f4661a9eaa0966" translate="yes" xml:space="preserve">
          <source>Appendix B. Date/Time Support</source>
          <target state="translated">附录B.日期/时间支持</target>
        </trans-unit>
        <trans-unit id="0a4fd0d75b5e8cb67c2577d915d2f158e36d619c" translate="yes" xml:space="preserve">
          <source>Appendix C. SQL Key Words</source>
          <target state="translated">附录C.SQL 关键字</target>
        </trans-unit>
        <trans-unit id="2d3d6ce5d75b048ec4b4bfd56085229d360ae080" translate="yes" xml:space="preserve">
          <source>Appendix D. SQL Conformance</source>
          <target state="translated">附录D.</target>
        </trans-unit>
        <trans-unit id="1c760d4057771bdbd912b1a26d17b99309626b19" translate="yes" xml:space="preserve">
          <source>Appendix E. Release Notes</source>
          <target state="translated">附录E.发行说明</target>
        </trans-unit>
        <trans-unit id="3cc083a7e98cb9a510c3b8e9fe828f669dae8eb2" translate="yes" xml:space="preserve">
          <source>Appendix F. Additional Supplied Modules</source>
          <target state="translated">附录F.额外提供的模块</target>
        </trans-unit>
        <trans-unit id="0a757b9f46902730f7dbc09c2b987bcc9b1402c2" translate="yes" xml:space="preserve">
          <source>Appendix G. Additional Supplied Programs</source>
          <target state="translated">附录G.额外提供的方案</target>
        </trans-unit>
        <trans-unit id="f731ac7aad79287ad6a9d70b29b7d9f22f9d74ad" translate="yes" xml:space="preserve">
          <source>Appendix K. PostgreSQL Limits</source>
          <target state="translated">附录K.PostgreSQL的限制</target>
        </trans-unit>
        <trans-unit id="6b2f6b4afe56f03c3636cff98cc090e912a2978a" translate="yes" xml:space="preserve">
          <source>Appendix L. Acronyms</source>
          <target state="translated">附录L.缩略语</target>
        </trans-unit>
        <trans-unit id="f60b3f6b35cf4c13bfaa5fa9f25882503add453a" translate="yes" xml:space="preserve">
          <source>Appendix M. Glossary</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea37fd5c2add8dc11cd4eac4e99886acbe263edc" translate="yes" xml:space="preserve">
          <source>Appendix N. Color Support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e2daf479a3e3b6ca8645aabab30691c459271fc" translate="yes" xml:space="preserve">
          <source>Appendix: Additional Supplied Modules</source>
          <target state="translated">附录。额外提供的模块</target>
        </trans-unit>
        <trans-unit id="212a37d7af38255a5010be41cf96e1919f1f65fe" translate="yes" xml:space="preserve">
          <source>Appendix: Color Support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fe175a1da37b9c50cabd865124df334aa3597f0" translate="yes" xml:space="preserve">
          <source>Appendix: Date/Time Support</source>
          <target state="translated">附录。日期/时间支持</target>
        </trans-unit>
        <trans-unit id="a8d8b25f2c37eff5457e8db6ccb6dece99f46eb0" translate="yes" xml:space="preserve">
          <source>Appendix: SQL Conformance</source>
          <target state="translated">附录:SQL一致性</target>
        </trans-unit>
        <trans-unit id="1f6da0679b0bcee42966e5109a37944191c26ca8" translate="yes" xml:space="preserve">
          <source>Appendixes</source>
          <target state="translated">Appendixes</target>
        </trans-unit>
        <trans-unit id="2fc28e50f7d7e95a87ebbb410bfe469fb51248d4" translate="yes" xml:space="preserve">
          <source>Appends an element to the end of an array (same as the &lt;code&gt;anyarray&lt;/code&gt;&lt;code&gt;||&lt;/code&gt;&lt;code&gt;anyelement&lt;/code&gt; operator).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99005fc867cd3e54c80bd91ee175bcce277708d9" translate="yes" xml:space="preserve">
          <source>Applicable Object Types</source>
          <target state="translated">适用对象类型</target>
        </trans-unit>
        <trans-unit id="a63f73a380e6bb14bdd2ad6b10a8f68e5d42a5ad" translate="yes" xml:space="preserve">
          <source>Application Programming Interface</source>
          <target state="translated">应用编程接口</target>
        </trans-unit>
        <trans-unit id="2f16f8fd5e0553e004d0e86eda56a845aa102673" translate="yes" xml:space="preserve">
          <source>Application name</source>
          <target state="translated">应用名称</target>
        </trans-unit>
        <trans-unit id="b03ebc2274f172652f6125e87dba0dd896ad4421" translate="yes" xml:space="preserve">
          <source>Application of Multiple Policies</source>
          <target state="translated">多重政策的应用</target>
        </trans-unit>
        <trans-unit id="00135b8aa11b060725023cffb44e0b589a9f25a0" translate="yes" xml:space="preserve">
          <source>Application of a vacuum cleanup record from WAL conflicts with queries accessing the target page on the standby, whether or not the data to be removed is visible.</source>
          <target state="translated">应用WAL的真空清理记录,与在待机状态下访问目标页面的查询发生冲突,无论要删除的数据是否可见。</target>
        </trans-unit>
        <trans-unit id="3256ed72d4783ec493be93406d6bd97d0d7b90f1" translate="yes" xml:space="preserve">
          <source>Application of a vacuum cleanup record from WAL conflicts with standby transactions whose snapshots can still &amp;ldquo;see&amp;rdquo; any of the rows to be removed.</source>
          <target state="translated">来自WAL的真空清除记录的应用与备用事务冲突，这些事务的快照仍可以&amp;ldquo;查看&amp;rdquo;要删除的任何行。</target>
        </trans-unit>
        <trans-unit id="76c74bd071dd73f01696fddbbffc77712a479faf" translate="yes" xml:space="preserve">
          <source>Applications</source>
          <target state="translated">Applications</target>
        </trans-unit>
        <trans-unit id="6b5428213daf1d5aba6d1295a6bbb19c08864fc0" translate="yes" xml:space="preserve">
          <source>Applications that wanted precise values have historically had to set &lt;a href=&quot;runtime-config-client#GUC-EXTRA-FLOAT-DIGITS&quot;&gt;extra_float_digits&lt;/a&gt; to 3 to obtain them. For maximum compatibility between versions, they should continue to do so.</source>
          <target state="translated">想要精确值的应用程序历来必须将&lt;a href=&quot;runtime-config-client#GUC-EXTRA-FLOAT-DIGITS&quot;&gt;extra_float_digits&lt;/a&gt;设置为3才能获得它们。为了获得版本之间的最大兼容性，他们应该继续这样做。</target>
        </trans-unit>
        <trans-unit id="ed624d6999cad953cb5b1bedd94e985196972ebd" translate="yes" xml:space="preserve">
          <source>Applications that wish to use backslash as escape should be modified to use escape string syntax (&lt;code&gt;E'...'&lt;/code&gt;), because the default behavior of ordinary strings is now to treat backslash as an ordinary character, per SQL standard. This variable can be enabled to help locate code that needs to be changed.</source>
          <target state="translated">希望将反斜杠用作转义的应用程序应修改为使用转义字符串语法（ &lt;code&gt;E'...'&lt;/code&gt; ），因为根据SQL标准，普通字符串的默认行为现在是将反斜杠视为普通字符。可以启用此变量来帮助查找需要更改的代码。</target>
        </trans-unit>
        <trans-unit id="85980229b9ae48d13b46796fb33f530f87d73b8b" translate="yes" xml:space="preserve">
          <source>Applications using this level must be prepared to retry transactions due to serialization failures.</source>
          <target state="translated">使用此级别的应用程序必须准备好因序列化失败而重试事务。</target>
        </trans-unit>
        <trans-unit id="55278f2bfbaabfad19c2fee75ec3133e8897d48a" translate="yes" xml:space="preserve">
          <source>Apply modifications to the page images obtained in the previous step.</source>
          <target state="translated">对上一步获得的页面图片进行修改。</target>
        </trans-unit>
        <trans-unit id="068d74cbbe7303d0ad643d8aa0d60cbff0956278" translate="yes" xml:space="preserve">
          <source>Apply the WAL from the source cluster, starting from the checkpoint created at failover. (Strictly speaking, pg_rewind doesn't apply the WAL, it just creates a backup label file that makes PostgreSQL start by replaying all WAL from that checkpoint forward.)</source>
          <target state="translated">从源集群应用WAL,从故障转移时创建的检查点开始。(严格来说,pg_rewind并不应用WAL,它只是创建了一个备份标签文件,使PostgreSQL从该检查点开始重放所有WAL。)</target>
        </trans-unit>
        <trans-unit id="e486b3d6c0bcfe71e975768cf7354a58fa17fa9a" translate="yes" xml:space="preserve">
          <source>Approximate average size (in bytes) of the transition state data for moving-aggregate mode, or zero to use a default estimate</source>
          <target state="translated">移动-聚合模式下过渡状态数据的近似平均大小(以字节为单位),或者使用默认估计值为零。</target>
        </trans-unit>
        <trans-unit id="caafece427e1163ffa963b4dffa3cc2b00260a07" translate="yes" xml:space="preserve">
          <source>Approximate average size (in bytes) of the transition state data, or zero to use a default estimate</source>
          <target state="translated">过渡状态数据的近似平均大小(以字节为单位),或使用默认估计值为零。</target>
        </trans-unit>
        <trans-unit id="753bf6e471b3480498401484488505d0888a0767" translate="yes" xml:space="preserve">
          <source>Approximate floating-point number converted from a JSON number or string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d737059a7023272b67d00f7bdeb9dfcc94048eda" translate="yes" xml:space="preserve">
          <source>Approximate floating-point number converted from an SQL/JSON number or a string</source>
          <target state="translated">从SQL/JSON数字或字符串转换而来的近似浮点数。</target>
        </trans-unit>
        <trans-unit id="c0b0f0e736e61c866d8d2ac574b894e925e89613" translate="yes" xml:space="preserve">
          <source>Approximate value of &amp;pi;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="befde54a108cb9dc6ad6e0ebd28720531a6855e6" translate="yes" xml:space="preserve">
          <source>Apr</source>
          <target state="translated">Apr</target>
        </trans-unit>
        <trans-unit id="a0393902db1f516ef5f95f6830938558a88fb23c" translate="yes" xml:space="preserve">
          <source>April</source>
          <target state="translated">April</target>
        </trans-unit>
        <trans-unit id="af4f4762f9bd3f0f4a10caf5b6e63dc4ce543724" translate="yes" xml:space="preserve">
          <source>Arabic</source>
          <target state="translated">Arabic</target>
        </trans-unit>
        <trans-unit id="2e6a8c2f54eea95c918815af873f318c8b75d1ee" translate="yes" xml:space="preserve">
          <source>Arbitrary text that serves as the description of this object</source>
          <target state="translated">作为该对象描述的任意文本。</target>
        </trans-unit>
        <trans-unit id="a4183b8dc44cf7f7f1da3bacb0f01f6cc6331a8b" translate="yes" xml:space="preserve">
          <source>Archaic term for a &lt;a href=&quot;glossary#GLOSSARY-WAL-RECORD&quot;&gt;WAL record&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b040b4179b8b00702858fdb4c1afec3d6d284509" translate="yes" xml:space="preserve">
          <source>Architecture</source>
          <target state="translated">Architecture</target>
        </trans-unit>
        <trans-unit id="c2745399d3dc1caef67349072200fb056fc4129e" translate="yes" xml:space="preserve">
          <source>Architecture: Initial Snapshot</source>
          <target state="translated">架构。初步快照</target>
        </trans-unit>
        <trans-unit id="a57a286a92ae143de1dc965b902d9ecc2dfd66af" translate="yes" xml:space="preserve">
          <source>Are &lt;code&gt;aclitem&lt;/code&gt;s equal? (Notice that type &lt;code&gt;aclitem&lt;/code&gt; lacks the usual set of comparison operators; it has only equality. In turn, &lt;code&gt;aclitem&lt;/code&gt; arrays can only be compared for equality.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67a9118149c6042fe6daa560647e16f79a2d3d97" translate="yes" xml:space="preserve">
          <source>Are horizontally aligned?</source>
          <target state="translated">是否水平对齐?</target>
        </trans-unit>
        <trans-unit id="0277a553173b27be90f022d132a83d4b3aaf7ebc" translate="yes" xml:space="preserve">
          <source>Are lines parallel?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae62863d19a1f09ae83d96496ecb5be1da1e9570" translate="yes" xml:space="preserve">
          <source>Are lines perpendicular?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8897c493ba700783f2c64a4d0f20f14b01d7b1e3" translate="yes" xml:space="preserve">
          <source>Are parallel?</source>
          <target state="translated">是平行的吗?</target>
        </trans-unit>
        <trans-unit id="b0f274d71a2fb179ee895325d1f8e8eba6d7eaf4" translate="yes" xml:space="preserve">
          <source>Are points horizontally aligned (that is, have same y coordinate)?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fd10598c5b40d1cb91d9f056ebf89eb9d7aa121" translate="yes" xml:space="preserve">
          <source>Are points vertically aligned (that is, have same x coordinate)?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cba229ff1c565c58441b7f5908ac5643aeb85b7" translate="yes" xml:space="preserve">
          <source>Are the left JSON path/value entries contained at the top level within the right JSON value?</source>
          <target state="translated">左侧JSON路径/值条目是否包含在右侧JSON值的顶层?</target>
        </trans-unit>
        <trans-unit id="7f5f796f9f81b0556b03d7a49d7711d325d01584" translate="yes" xml:space="preserve">
          <source>Are the ranges adjacent?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95ac96b9bb2b90c235c16c3c150acca2ceb1786a" translate="yes" xml:space="preserve">
          <source>Are the two &lt;code&gt;seg&lt;/code&gt;s equal?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdbf4786edf9f977d2039f0d91270c27aa5a8043" translate="yes" xml:space="preserve">
          <source>Are these objects the same? Available for &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ea55540eda7f3ae150bdf50ff88e357b0470bd4" translate="yes" xml:space="preserve">
          <source>Are vertically aligned?</source>
          <target state="translated">是否垂直排列?</target>
        </trans-unit>
        <trans-unit id="54486629b7690ae513c392c789d163e099b5b87d" translate="yes" xml:space="preserve">
          <source>Argument Type</source>
          <target state="translated">参数类型</target>
        </trans-unit>
        <trans-unit id="227b299c7388311800207bda7f4dca4cbfe39510" translate="yes" xml:space="preserve">
          <source>Argument Type(s)</source>
          <target state="translated">Argument Type(s)</target>
        </trans-unit>
        <trans-unit id="a051df2e8379a7a94517621abf96e2d1c250d0c1" translate="yes" xml:space="preserve">
          <source>Argument strings to pass to trigger, each NULL-terminated</source>
          <target state="translated">传递给触发器的参数字符串,每个都是以NULL结尾的。</target>
        </trans-unit>
        <trans-unit id="3106eca9fcc5b17fbc0ab862b2b3e2e5d8ec1882" translate="yes" xml:space="preserve">
          <source>Arranges to save future query results to the file &lt;code&gt;filename&lt;/code&gt; or pipe future results to the shell command &lt;code&gt;command&lt;/code&gt;. If no argument is specified, the query output is reset to the standard output.</source>
          <target state="translated">安排将将来的查询结果保存到文件 &lt;code&gt;filename&lt;/code&gt; 或将将来的结果通过管道传递到shell命令 &lt;code&gt;command&lt;/code&gt; 。如果未指定任何参数，则查询输出将重置为标准输出。</target>
        </trans-unit>
        <trans-unit id="7a061ed91f80bf08d4b0e706de1a73a36b812215" translate="yes" xml:space="preserve">
          <source>Array Comparisons</source>
          <target state="translated">阵列比较</target>
        </trans-unit>
        <trans-unit id="2cce75772b9783560b7ecdf1a652525e088ff999" translate="yes" xml:space="preserve">
          <source>Array Comparisons: ALL (array)</source>
          <target state="translated">阵列比较。ALL(数组)</target>
        </trans-unit>
        <trans-unit id="ebbce493c47b875446149a16fbeabd59af95b506" translate="yes" xml:space="preserve">
          <source>Array Comparisons: ANY/SOME (array)</source>
          <target state="translated">阵列比较。ANY/SOME (数组)</target>
        </trans-unit>
        <trans-unit id="266d7d8ad9ef21fb1cf43acafe88df1627794e31" translate="yes" xml:space="preserve">
          <source>Array Comparisons: IN</source>
          <target state="translated">阵列比较。IN</target>
        </trans-unit>
        <trans-unit id="cb5525261d1827b03403d3e1f7d54e339ee3bdc7" translate="yes" xml:space="preserve">
          <source>Array Comparisons: NOT IN</source>
          <target state="translated">阵列比较。不在</target>
        </trans-unit>
        <trans-unit id="378bd5c012fe9a2d09b80c0502903a9f1a4e46ef" translate="yes" xml:space="preserve">
          <source>Array Functions and Operators</source>
          <target state="translated">阵列函数和操作符</target>
        </trans-unit>
        <trans-unit id="1847f280fe6a7cfd6c208240da7d0ab7f1c91ffb" translate="yes" xml:space="preserve">
          <source>Array Types</source>
          <target state="translated">阵列类型</target>
        </trans-unit>
        <trans-unit id="989d38553686cf9420b0efeacfb98e0cb0491104" translate="yes" xml:space="preserve">
          <source>Array element accessor. &lt;code&gt;subscript&lt;/code&gt; can be given in two forms: &lt;code&gt;index&lt;/code&gt; or &lt;code&gt;start_index to end_index&lt;/code&gt;. The first form returns a single array element by its index. The second form returns an array slice by the range of indexes, including the elements that correspond to the provided &lt;code&gt;start_index&lt;/code&gt; and &lt;code&gt;end_index&lt;/code&gt;.</source>
          <target state="translated">数组元素访问器。 &lt;code&gt;subscript&lt;/code&gt; 可以两种形式给出： &lt;code&gt;index&lt;/code&gt; 或 &lt;code&gt;start_index to end_index&lt;/code&gt; 。第一种形式通过其索引返回单个数组元素。第二种形式按索引范围返回数组切片，包括与提供的 &lt;code&gt;start_index&lt;/code&gt; 和 &lt;code&gt;end_index&lt;/code&gt; 对应的元素。</target>
        </trans-unit>
        <trans-unit id="88048034955012a6a9f12b6c23a529e19a83c1b1" translate="yes" xml:space="preserve">
          <source>Array of &lt;code&gt;WHERE&lt;/code&gt;-clause filter conditions for the extension's configuration table(s), or &lt;code&gt;NULL&lt;/code&gt; if none</source>
          <target state="translated">扩展配置表的WHERE- &lt;code&gt;WHERE&lt;/code&gt; 过滤条件数组，如果没有，则为 &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="01ffa4580cea8a6c482fb4eea9629be04c79e61e" translate="yes" xml:space="preserve">
          <source>Array of &lt;code&gt;regclass&lt;/code&gt; OIDs for the extension's configuration table(s), or &lt;code&gt;NULL&lt;/code&gt; if none</source>
          <target state="translated">扩展配置表的 &lt;code&gt;regclass&lt;/code&gt; OID 数组，如果没有，则为 &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="24c2e81a77c22cd6c4b27ed6a767d8a3da693d5f" translate="yes" xml:space="preserve">
          <source>Array of item identifiers pointing to the actual items. Each entry is an (offset,length) pair. 4 bytes per item.</source>
          <target state="translated">指向实际项目的项目标识符阵列。每个条目是一个(偏移量,长度)对。每个项目4个字节。</target>
        </trans-unit>
        <trans-unit id="be15b795f8a08c896c323efe48ed797caf42d6d4" translate="yes" xml:space="preserve">
          <source>Array of subscribed publication names. These reference the publications on the publisher server. For more on publications see &lt;a href=&quot;logical-replication-publication&quot;&gt;Section 30.1&lt;/a&gt;.</source>
          <target state="translated">订阅的出版物名称的数组。这些引用发布服务器上的发布。有关出版物的更多信息，请参见&lt;a href=&quot;logical-replication-publication&quot;&gt;第30.1节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ee988191e1f320445ced1a772858430505143153" translate="yes" xml:space="preserve">
          <source>Array types</source>
          <target state="translated">阵列类型</target>
        </trans-unit>
        <trans-unit id="31177effc11eb7035c25f786c3b9f262ea8dee25" translate="yes" xml:space="preserve">
          <source>Array: &amp;amp;&amp;amp;</source>
          <target state="translated">数组：&amp;amp;&amp;amp;</target>
        </trans-unit>
        <trans-unit id="24e29718edd609d75b45a77aa875138df131bbd7" translate="yes" xml:space="preserve">
          <source>Array: &amp;gt;</source>
          <target state="translated">数组：&amp;gt;</target>
        </trans-unit>
        <trans-unit id="811842a370e6ca7314ad3ee641887ae43eed6200" translate="yes" xml:space="preserve">
          <source>Array: &amp;gt;=</source>
          <target state="translated">数组：&amp;gt; =</target>
        </trans-unit>
        <trans-unit id="736b98ce8f814e8462d7673c06a73e5d2921d61d" translate="yes" xml:space="preserve">
          <source>Array: &amp;lt;</source>
          <target state="translated">数组：&amp;lt;</target>
        </trans-unit>
        <trans-unit id="72683d381cd2860b3b1a8eab0a2c5eedfb795924" translate="yes" xml:space="preserve">
          <source>Array: &amp;lt;&amp;gt;</source>
          <target state="translated">数组：&amp;lt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="397f0e2a9b9f910336a8ea8c6c32ba6704d652eb" translate="yes" xml:space="preserve">
          <source>Array: &amp;lt;=</source>
          <target state="translated">数组：&amp;lt;=</target>
        </trans-unit>
        <trans-unit id="5df64d9374ce5e9d00462533f6beea8afb43679c" translate="yes" xml:space="preserve">
          <source>Array: &amp;lt;@</source>
          <target state="translated">数组：&amp;lt;@</target>
        </trans-unit>
        <trans-unit id="3fe38b2f63794530437e3485d0c38785ad75e487" translate="yes" xml:space="preserve">
          <source>Array: 1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7d17f1eb33a5388e6bfb317a245a8c37e5b460a" translate="yes" xml:space="preserve">
          <source>Array: =</source>
          <target state="translated">阵列:=</target>
        </trans-unit>
        <trans-unit id="db0f2c477d3b5e5a1ea32beab72408f0ff3b2f71" translate="yes" xml:space="preserve">
          <source>Array: @&amp;gt;</source>
          <target state="translated">数组：@&amp;gt;</target>
        </trans-unit>
        <trans-unit id="150a65359d97d4ee8b8c087554e227e4e463443a" translate="yes" xml:space="preserve">
          <source>Array: ARRAY</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dcd3d1ce93d0ca2cb3e60332e931604f93cc026" translate="yes" xml:space="preserve">
          <source>Array: ARRAY &amp;amp;&amp;amp; ARRAY</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64b37c182a6bd42ba7b5eb841ce25916a3a3c807" translate="yes" xml:space="preserve">
          <source>Array: ARRAY &amp;lt;@ ARRAY</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78d1bb5bc6001f266e8878cdac676402e49a8545" translate="yes" xml:space="preserve">
          <source>Array: ARRAY @&amp;gt; ARRAY</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c09f59eadf2bb3b4328b3f453d0a6c85ef136cb" translate="yes" xml:space="preserve">
          <source>Array: IS NOT DISTINCT FROM</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bc80d05bcc1cb0f4e5e941af2a29b9db0657f22" translate="yes" xml:space="preserve">
          <source>Array: NULL</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9bbda7ebf850fa729d9606dbdfd7d1f3599ec47" translate="yes" xml:space="preserve">
          <source>Array: array_append</source>
          <target state="translated">Array:array_append</target>
        </trans-unit>
        <trans-unit id="af82c1377e93f02d0993b9aadeb7d8e17521a1bc" translate="yes" xml:space="preserve">
          <source>Array: array_cat</source>
          <target state="translated">Array:array_cat</target>
        </trans-unit>
        <trans-unit id="243f29a4a2e10d2646f7903c1f4a2d39c2a3d0a4" translate="yes" xml:space="preserve">
          <source>Array: array_dims</source>
          <target state="translated">阵列:array_dims</target>
        </trans-unit>
        <trans-unit id="5beacc0ab51ffbcd3c4683bef89fb252cd5ecd4f" translate="yes" xml:space="preserve">
          <source>Array: array_fill</source>
          <target state="translated">Array:array_fill</target>
        </trans-unit>
        <trans-unit id="0a700d1340312f7d432d241fb96c7d69e0d7cbc8" translate="yes" xml:space="preserve">
          <source>Array: array_length</source>
          <target state="translated">Array:array_length</target>
        </trans-unit>
        <trans-unit id="e39f07efeb19c70308a1b05104d42f13e6750589" translate="yes" xml:space="preserve">
          <source>Array: array_lower</source>
          <target state="translated">Array:array_lower</target>
        </trans-unit>
        <trans-unit id="55bec9b1ab2dd7b5615b888955aa1685d7d9176c" translate="yes" xml:space="preserve">
          <source>Array: array_ndims</source>
          <target state="translated">Array:array_ndims</target>
        </trans-unit>
        <trans-unit id="6abfbc8e90ab3825fd22a987883a8130d8647c22" translate="yes" xml:space="preserve">
          <source>Array: array_position</source>
          <target state="translated">Array:array_position</target>
        </trans-unit>
        <trans-unit id="dc8f46967ae5b46ce3023fe830845635cbddc3a2" translate="yes" xml:space="preserve">
          <source>Array: array_positions</source>
          <target state="translated">Array:array_positions</target>
        </trans-unit>
        <trans-unit id="170bb418b8b592fa19a657e9b3372281a737a509" translate="yes" xml:space="preserve">
          <source>Array: array_prepend</source>
          <target state="translated">Array:array_prepend</target>
        </trans-unit>
        <trans-unit id="23c081b8640d7683a9a9eb917682404db2a9d9cf" translate="yes" xml:space="preserve">
          <source>Array: array_remove</source>
          <target state="translated">Array:array_remove</target>
        </trans-unit>
        <trans-unit id="0bb70da04daab39f1a179be9e60eceee76a3242d" translate="yes" xml:space="preserve">
          <source>Array: array_replace</source>
          <target state="translated">阵列:array_replace</target>
        </trans-unit>
        <trans-unit id="d1576bf750554857f928eff64376711410524f13" translate="yes" xml:space="preserve">
          <source>Array: array_to_string</source>
          <target state="translated">Array:array_to_string</target>
        </trans-unit>
        <trans-unit id="f1d1655c390920a19930233b2ba0cbcc608406ea" translate="yes" xml:space="preserve">
          <source>Array: array_upper</source>
          <target state="translated">Array:array_upper</target>
        </trans-unit>
        <trans-unit id="f07fdded6b4337ac290721bed8d559d25ce497d7" translate="yes" xml:space="preserve">
          <source>Array: cardinality</source>
          <target state="translated">阵列:基数</target>
        </trans-unit>
        <trans-unit id="4d56c61f6754af386d1ad55522ee718a6d173e5b" translate="yes" xml:space="preserve">
          <source>Array: select * from unnest as x</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b45177789238b533ec64ce75c721f78be3e3490d" translate="yes" xml:space="preserve">
          <source>Array: string_to_array</source>
          <target state="translated">Array:string_to_array</target>
        </trans-unit>
        <trans-unit id="1b1aca770dcf002c23a04ca801aee9819ce75321" translate="yes" xml:space="preserve">
          <source>Array: unnest</source>
          <target state="translated">阵列:嵌套</target>
        </trans-unit>
        <trans-unit id="8cbda94f98fa6831a0fab631dfd36cfb855d6147" translate="yes" xml:space="preserve">
          <source>Array: ||</source>
          <target state="translated">阵列。||</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="7ff0d6e651880818d49ef5a4d284aa7441e9760b" translate="yes" xml:space="preserve">
          <source>Arrays are not sets; searching for specific array elements can be a sign of database misdesign. Consider using a separate table with a row for each item that would be an array element. This will be easier to search, and is likely to scale better for a large number of elements.</source>
          <target state="translated">数组不是集合;搜索特定的数组元素可能是数据库设计错误的标志。考虑使用一个单独的表,为每一个将成为数组元素的项目添加一行。这将更容易搜索,而且对于大量元素来说,可能会有更好的扩展。</target>
        </trans-unit>
        <trans-unit id="86a798d810f86ee1f57761b0f4f378302a450ab0" translate="yes" xml:space="preserve">
          <source>As PostgreSQL stands, this doesn't occur. Large objects are treated as objects in their own right; a table entry can reference a large object by OID, but there can be multiple table entries referencing the same large object OID, so the system doesn't delete the large object just because you change or remove one such entry.</source>
          <target state="translated">按照PostgreSQL的现状,不会出现这种情况。大对象本身就被视为对象,一个表项可以通过OID引用一个大对象,但可以有多个表项引用同一个大对象OID,所以系统不会因为你改变或删除一个这样的表项就删除大对象。</target>
        </trans-unit>
        <trans-unit id="96ee90014e2be91ae6a2c0ff19bfbdac86380915" translate="yes" xml:space="preserve">
          <source>As a consequence, it is unwise to use functions with side effects as part of complex expressions. It is particularly dangerous to rely on side effects or evaluation order in &lt;code&gt;WHERE&lt;/code&gt; and &lt;code&gt;HAVING&lt;/code&gt; clauses, since those clauses are extensively reprocessed as part of developing an execution plan. Boolean expressions (&lt;code&gt;AND&lt;/code&gt;/&lt;code&gt;OR&lt;/code&gt;/&lt;code&gt;NOT&lt;/code&gt; combinations) in those clauses can be reorganized in any manner allowed by the laws of Boolean algebra.</source>
          <target state="translated">因此，将带有副作用的函数用作复杂表达式的一部分是不明智的。在 &lt;code&gt;WHERE&lt;/code&gt; 和 &lt;code&gt;HAVING&lt;/code&gt; 子句中依赖副作用或评估顺序特别危险，因为这些子句在制定执行计划时会被大量重新处理。这些子句中的布尔表达式（ &lt;code&gt;AND&lt;/code&gt; / &lt;code&gt;OR&lt;/code&gt; / &lt;code&gt;NOT&lt;/code&gt; 组合）可以按照布尔代数定律允许的任何方式进行重组。</target>
        </trans-unit>
        <trans-unit id="c00aa4eef1a46e7541eb69499cd40ccfaa63754a" translate="yes" xml:space="preserve">
          <source>As a convenience, there is a program you can execute from the shell to create new databases, &lt;code&gt;createdb&lt;/code&gt;.</source>
          <target state="translated">为了方便起见，您可以从外壳执行一个程序来创建新数据库 &lt;code&gt;createdb&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d25ac520ed3e5e990af0f244faf971c940fd4e71" translate="yes" xml:space="preserve">
          <source>As a general rule, if you get spurious parser errors for commands that contain any of the listed key words as an identifier you should try to quote the identifier to see if the problem goes away.</source>
          <target state="translated">一般来说,如果你的命令包含任何一个列出的关键词作为标识符,就会出现虚假的解析器错误,你应该尝试引用该标识符,看看问题是否会消失。</target>
        </trans-unit>
        <trans-unit id="95a9f6ed53fa85650318ffc030c2493caa298423" translate="yes" xml:space="preserve">
          <source>As a partial guard against this type of error, variable-length or nullable fields should not be made directly visible to the C compiler. This is accomplished by wrapping them in &lt;code&gt;#ifdef CATALOG_VARLEN&lt;/code&gt; ... &lt;code&gt;#endif&lt;/code&gt; (where &lt;code&gt;CATALOG_VARLEN&lt;/code&gt; is a symbol that is never defined). This prevents C code from carelessly trying to access fields that might not be there or might be at some other offset. As an independent guard against creating incorrect rows, we require all columns that should be non-nullable to be marked so in &lt;code&gt;pg_attribute&lt;/code&gt;. The bootstrap code will automatically mark catalog columns as &lt;code&gt;NOT NULL&lt;/code&gt; if they are fixed-width and are not preceded by any nullable column. Where this rule is inadequate, you can force correct marking by using &lt;code&gt;BKI_FORCE_NOT_NULL&lt;/code&gt; and &lt;code&gt;BKI_FORCE_NULL&lt;/code&gt; annotations as needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a80a71669f88eae465ab66545f1b21816ccdfcd" translate="yes" xml:space="preserve">
          <source>As a partial guard against this type of error, variable-length or nullable fields should not be made directly visible to the C compiler. This is accomplished by wrapping them in &lt;code&gt;#ifdef CATALOG_VARLEN&lt;/code&gt; ... &lt;code&gt;#endif&lt;/code&gt; (where &lt;code&gt;CATALOG_VARLEN&lt;/code&gt; is a symbol that is never defined). This prevents C code from carelessly trying to access fields that might not be there or might be at some other offset. As an independent guard against creating incorrect rows, we require all columns that should be non-nullable to be marked so in &lt;code&gt;pg_attribute&lt;/code&gt;. The bootstrap code will automatically mark catalog columns as &lt;code&gt;NOT NULL&lt;/code&gt; if they are fixed-width and are not preceded by any nullable column. Where this rule is inadequate, you can force correct marking by using &lt;code&gt;BKI_FORCE_NOT_NULL&lt;/code&gt; and &lt;code&gt;BKI_FORCE_NULL&lt;/code&gt; annotations as needed. But note that &lt;code&gt;NOT NULL&lt;/code&gt; constraints are only enforced in the executor, not against tuples that are generated by random C code, so care is still needed when manually creating or updating catalog rows.</source>
          <target state="translated">作为防止此类错误的部分保护措施，可变长度或可为空的字段不应对C编译器直接可见。这可以通过将它们包装在 &lt;code&gt;#ifdef CATALOG_VARLEN&lt;/code&gt; ... &lt;code&gt;#endif&lt;/code&gt; （其中 &lt;code&gt;CATALOG_VARLEN&lt;/code&gt; 是从未定义的符号）中来完成。这样可以防止C代码粗心地尝试访问可能不存在或处于其他偏移量的字段。为了防止创建不正确的行，我们要求将所有不可为空的列都标记为 &lt;code&gt;pg_attribute&lt;/code&gt; 。引导代码将自动将目录列标记为 &lt;code&gt;NOT NULL&lt;/code&gt; 如果它们是固定宽度的，并且前面没有任何可为空的列。如果该规则不足，则可以根据需要使用 &lt;code&gt;BKI_FORCE_NOT_NULL&lt;/code&gt; 和 &lt;code&gt;BKI_FORCE_NULL&lt;/code&gt; 注释来强制进行正确的标记。但是请注意， &lt;code&gt;NOT NULL&lt;/code&gt; 约束仅在执行程序中强制执行，而不是针对由随机C代码生成的元组执行，因此在手动创建或更新目录行时仍需要谨慎。</target>
        </trans-unit>
        <trans-unit id="47b0b4c39b5ede77f7f7daa11745dc4255dd8757" translate="yes" xml:space="preserve">
          <source>As a partitioned table does not have any data directly, attempts to use &lt;code&gt;TRUNCATE&lt;/code&gt;&lt;code&gt;ONLY&lt;/code&gt; on a partitioned table will always return an error.</source>
          <target state="translated">由于分区表没有直接任何数据，因此尝试在分区表上 &lt;code&gt;ONLY&lt;/code&gt; 使用 &lt;code&gt;TRUNCATE&lt;/code&gt; 总是会返回错误。</target>
        </trans-unit>
        <trans-unit id="ff2aae32fe6bdd83d73023e8256b2cd3508deffa" translate="yes" xml:space="preserve">
          <source>As a result, you cannot create additional indexes that exist solely on the standby, nor statistics that exist solely on the standby. If these administration commands are needed, they should be executed on the primary, and eventually those changes will propagate to the standby.</source>
          <target state="translated">因此,你不能创建只存在于备用机上的额外索引,也不能创建只存在于备用机上的统计数据。如果需要这些管理命令,应该在主设备上执行,最终这些更改会传播到备用设备上。</target>
        </trans-unit>
        <trans-unit id="94f064aeef44b2237a7b84960c6af3e282dc0f3d" translate="yes" xml:space="preserve">
          <source>As a rule of thumb, &lt;code&gt;queryid&lt;/code&gt; values can be assumed to be stable and comparable only so long as the underlying server version and catalog metadata details stay exactly the same. Two servers participating in replication based on physical WAL replay can be expected to have identical &lt;code&gt;queryid&lt;/code&gt; values for the same query. However, logical replication schemes do not promise to keep replicas identical in all relevant details, so &lt;code&gt;queryid&lt;/code&gt; will not be a useful identifier for accumulating costs across a set of logical replicas. If in doubt, direct testing is recommended.</source>
          <target state="translated">根据经验，仅当基础服务器版本和目录元数据详细信息保持完全相同时，才能假定 &lt;code&gt;queryid&lt;/code&gt; 值是稳定且可比较的。可以预期，基于物理WAL重播参与复制的两台服务器对于同一查询具有相同的 &lt;code&gt;queryid&lt;/code&gt; 值。但是，逻辑复制方案不保证所有相关细节的副本都相同，因此 &lt;code&gt;queryid&lt;/code&gt; 将不是在一组逻辑副本之间累积成本的有用标识符。如有疑问，建议直接测试。</target>
        </trans-unit>
        <trans-unit id="84cdd8b719c9d8f34c7f1d4c72b4f9ce0fe4768b" translate="yes" xml:space="preserve">
          <source>As a safety device, an aggressive vacuum scan will occur for any table whose multixact-age is greater than &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE&quot;&gt;autovacuum_multixact_freeze_max_age&lt;/a&gt;. Aggressive vacuum scans will also occur progressively for all tables, starting with those that have the oldest multixact-age, if the amount of used member storage space exceeds the amount 50% of the addressable storage space. Both of these kinds of aggressive scans will occur even if autovacuum is nominally disabled.</source>
          <target state="translated">作为安全设备，任何multixact-age大于&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE&quot;&gt;autovacuum_multixact_freeze_max_age的&lt;/a&gt;表都将进行主动真空扫描。如果使用的成员存储空间量超过了可寻址存储空间的50％，则从具有最老的multixact-age的表开始，所有表也将逐渐进行积极的真空扫描。即使自动真空被禁用，这两种主动扫描都将发生。</target>
        </trans-unit>
        <trans-unit id="2b18e01bd003b97bb977c2d73b7cfc8923da784c" translate="yes" xml:space="preserve">
          <source>As a sanity check, &lt;code&gt;seg&lt;/code&gt; rejects intervals with the lower bound greater than the upper, for example &lt;code&gt;5 .. 2&lt;/code&gt;.</source>
          <target state="translated">作为完整性检查， &lt;code&gt;seg&lt;/code&gt; 拒绝下限大于上限的间隔，例如 &lt;code&gt;5 .. 2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e65f5f3343ba0b45af614f4022a156a7c42809b5" translate="yes" xml:space="preserve">
          <source>As a simple example, here is how to create a policy on the &lt;code&gt;account&lt;/code&gt; relation to allow only members of the &lt;code&gt;managers&lt;/code&gt; role to access rows, and only rows of their accounts:</source>
          <target state="translated">作为一个简单的示例，下面是如何在 &lt;code&gt;account&lt;/code&gt; 关系上创建策略以仅允许 &lt;code&gt;managers&lt;/code&gt; 角色成员访问其帐户的行以及帐户的行：</target>
        </trans-unit>
        <trans-unit id="05f66f343edd96e743819d53bcce1284f5be3d29" translate="yes" xml:space="preserve">
          <source>As a special exception to the general principle that the structures must match, an array may contain a primitive value:</source>
          <target state="translated">作为结构必须匹配的一般原则的一个特殊例外,一个数组可以包含一个基元值。</target>
        </trans-unit>
        <trans-unit id="4dafe6722800c895e7fb824e24cdc22785e38231" translate="yes" xml:space="preserve">
          <source>As a workaround to allow PostgreSQL to use indexes with &lt;code&gt;LIKE&lt;/code&gt; clauses under a non-C locale, several custom operator classes exist. These allow the creation of an index that performs a strict character-by-character comparison, ignoring locale comparison rules. Refer to &lt;a href=&quot;indexes-opclass&quot;&gt;Section 11.10&lt;/a&gt; for more information. Another approach is to create indexes using the &lt;code&gt;C&lt;/code&gt; collation, as discussed in &lt;a href=&quot;collation&quot;&gt;Section 23.2&lt;/a&gt;.</source>
          <target state="translated">作为允许PostgreSQL 在非C语言环境下使用带有 &lt;code&gt;LIKE&lt;/code&gt; 子句的索引的解决方法，存在几个自定义运算符类。这些允许创建执行严格的逐字符比较的索引，而忽略区域设置比较规则。有关更多信息，请参见&lt;a href=&quot;indexes-opclass&quot;&gt;第11.10节&lt;/a&gt;。另一种方法是使用 &lt;code&gt;C&lt;/code&gt; 归类创建索引，如&lt;a href=&quot;collation&quot;&gt;第23.2节中所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="38727bf2878bdfdd88e444d27be405dc29a205b6" translate="yes" xml:space="preserve">
          <source>As above, but import only the two tables &lt;code&gt;actors&lt;/code&gt; and &lt;code&gt;directors&lt;/code&gt; (if they exist):</source>
          <target state="translated">如上所述，但仅导入两个表 &lt;code&gt;actors&lt;/code&gt; 和 &lt;code&gt;directors&lt;/code&gt; （如果存在）：</target>
        </trans-unit>
        <trans-unit id="fc0ab2ce564629da1cade53f45b45700cfa6ba3f" translate="yes" xml:space="preserve">
          <source>As an alternative to the &lt;code&gt;-D&lt;/code&gt; option, you can set the environment variable &lt;code&gt;PGDATA&lt;/code&gt;.</source>
          <target state="translated">作为 &lt;code&gt;-D&lt;/code&gt; 选项的替代方法，您可以设置环境变量 &lt;code&gt;PGDATA&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="431e9cdc01712eabff181abecb6b83e3af47f9a9" translate="yes" xml:space="preserve">
          <source>As an alternative, it is sometimes more convenient to create the new table outside the partition structure, and make it a proper partition later. This allows the data to be loaded, checked, and transformed prior to it appearing in the partitioned table:</source>
          <target state="translated">作为一种替代方法,有时更方便的做法是在分区结构之外创建新表,并在以后使其成为一个适当的分区。这样就可以在数据出现在分区表之前对其进行加载、检查和转换。</target>
        </trans-unit>
        <trans-unit id="dbbe816df8235daf5a726cf6177c485cd14e8ef4" translate="yes" xml:space="preserve">
          <source>As an example of using the output produced by these functions, &lt;a href=&quot;functions-xml#XSLT-XML-HTML&quot;&gt;Example 9.1&lt;/a&gt; shows an XSLT stylesheet that converts the output of &lt;code&gt;table_to_xml_and_xmlschema&lt;/code&gt; to an HTML document containing a tabular rendition of the table data. In a similar manner, the results from these functions can be converted into other XML-based formats.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0e3b2ce01a4421ab4c72defc488724bdaa1c1a4" translate="yes" xml:space="preserve">
          <source>As an example of using the output produced by these functions, &lt;a href=&quot;functions-xml#XSLT-XML-HTML&quot;&gt;Figure 9.1&lt;/a&gt; shows an XSLT stylesheet that converts the output of &lt;code&gt;table_to_xml_and_xmlschema&lt;/code&gt; to an HTML document containing a tabular rendition of the table data. In a similar manner, the results from these functions can be converted into other XML-based formats.</source>
          <target state="translated">作为使用这些函数产生的输出的示例，&lt;a href=&quot;functions-xml#XSLT-XML-HTML&quot;&gt;图9.1&lt;/a&gt;显示了一个XSLT样式表，该表将 &lt;code&gt;table_to_xml_and_xmlschema&lt;/code&gt; 的输出转换为包含表数据表格格式表示的HTML文档。以类似的方式，这些函数的结果可以转换为其他基于XML的格式。</target>
        </trans-unit>
        <trans-unit id="0d1f3783f0bee859f0f7fd07d8117b96c39c5dbf" translate="yes" xml:space="preserve">
          <source>As an example we will create a configuration &lt;code&gt;pg&lt;/code&gt;, starting by duplicating the built-in &lt;code&gt;english&lt;/code&gt; configuration:</source>
          <target state="translated">作为示例，我们将创建一个配置 &lt;code&gt;pg&lt;/code&gt; ，首先复制内置的 &lt;code&gt;english&lt;/code&gt; 配置：</target>
        </trans-unit>
        <trans-unit id="faf1ed368ea36c292232738719a6fc50ce56d002" translate="yes" xml:space="preserve">
          <source>As an example, &lt;code&gt;CET-1CEST,M3.5.0,M10.5.0/3&lt;/code&gt; describes current (as of 2020) timekeeping practice in Paris. This specification says that standard time has the abbreviation &lt;code&gt;CET&lt;/code&gt; and is one hour ahead (east) of UTC; daylight savings time has the abbreviation &lt;code&gt;CEST&lt;/code&gt; and is implicitly two hours ahead of UTC; daylight savings time begins on the last Sunday in March at 2AM CET and ends on the last Sunday in October at 3AM CEST.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75dd3c213ab262bc0285b838849480821b38de49" translate="yes" xml:space="preserve">
          <source>As an example, consider a table &lt;code&gt;mytab&lt;/code&gt;, initially containing:</source>
          <target state="translated">例如，考虑一个表 &lt;code&gt;mytab&lt;/code&gt; ，该表最初包含：</target>
        </trans-unit>
        <trans-unit id="90c5a9e56ec693f6e6129ec5a5d9bccec6f61c69" translate="yes" xml:space="preserve">
          <source>As an example, if an &lt;code&gt;UPDATE&lt;/code&gt; is issued, then the &lt;code&gt;ALL&lt;/code&gt; policy will be applicable both to what the &lt;code&gt;UPDATE&lt;/code&gt; will be able to select as rows to be updated (applying the &lt;code&gt;USING&lt;/code&gt; expression), and to the resulting updated rows, to check if they are permitted to be added to the table (applying the &lt;code&gt;WITH CHECK&lt;/code&gt; expression, if defined, and the &lt;code&gt;USING&lt;/code&gt; expression otherwise). If an &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; command attempts to add rows to the table that do not pass the &lt;code&gt;ALL&lt;/code&gt; policy's &lt;code&gt;WITH CHECK&lt;/code&gt; expression, the entire command will be aborted.</source>
          <target state="translated">例如，如果发出 &lt;code&gt;UPDATE&lt;/code&gt; ，则 &lt;code&gt;ALL&lt;/code&gt; 策略将适用于 &lt;code&gt;UPDATE&lt;/code&gt; 能够选择哪些行作为要更新的行（应用 &lt;code&gt;USING&lt;/code&gt; 表达式）以及生成的更新行，以检查它们是否适用允许将其添加到表中（如果定义了，则 &lt;code&gt;USING&lt;/code&gt; &lt;code&gt;WITH CHECK&lt;/code&gt; 表达式，否则使用USING表达式）。如果 &lt;code&gt;INSERT&lt;/code&gt; 或 &lt;code&gt;UPDATE&lt;/code&gt; 命令尝试向表中添加未通过 &lt;code&gt;ALL&lt;/code&gt; 策略的 &lt;code&gt;WITH CHECK&lt;/code&gt; 表达式的行，则整个命令将被中止。</target>
        </trans-unit>
        <trans-unit id="939804fcee1e20d77d25bd0bcffade6b732e6187" translate="yes" xml:space="preserve">
          <source>As an example, suppose that user &lt;code&gt;miriam&lt;/code&gt; creates table &lt;code&gt;mytable&lt;/code&gt; and does:</source>
          <target state="translated">例如，假设用户 &lt;code&gt;miriam&lt;/code&gt; 创建表 &lt;code&gt;mytable&lt;/code&gt; 并执行以下操作：</target>
        </trans-unit>
        <trans-unit id="7dea5d7bb31aa71940b0966bc7e8fd7ee8f021dd" translate="yes" xml:space="preserve">
          <source>As an example, the full definition of the built-in TPC-B-like transaction is:</source>
          <target state="translated">举个例子,内置的类似TPC-B的事务的完整定义是:</target>
        </trans-unit>
        <trans-unit id="cfc78f7c719c6f7419eadd4a007ca5004840837d" translate="yes" xml:space="preserve">
          <source>As an example, we can find the highest low-temperature reading anywhere with:</source>
          <target state="translated">举个例子,我们可以在任何地方找到最高的低温读数与。</target>
        </trans-unit>
        <trans-unit id="dddf73cd98dcce7c884fe24956533693e61e8e3f" translate="yes" xml:space="preserve">
          <source>As an example:</source>
          <target state="translated">举个例子:</target>
        </trans-unit>
        <trans-unit id="b50a75f7dfe3aa7965ef5d4e176cb3485c343ba0" translate="yes" xml:space="preserve">
          <source>As an extension to the SQL standard, PostgreSQL allows there to be just one escape-double-quote separator, in which case the third regular expression is taken as empty; or no separators, in which case the first and third regular expressions are taken as empty.</source>
          <target state="translated">作为对SQL标准的扩展,PostgreSQL允许只有一个转义双引号分隔符,在这种情况下,第三个正则表达式被当作空;或者没有分隔符,在这种情况下,第一个和第三个正则表达式被当作空。</target>
        </trans-unit>
        <trans-unit id="fa9c14e462aa9732a24d51e00bd5d77bf7a81cc2" translate="yes" xml:space="preserve">
          <source>As another example, if one often does queries like:</source>
          <target state="translated">再举个例子,如果经常做这样的查询。</target>
        </trans-unit>
        <trans-unit id="a99c411c58f58d7e7474741b999e04e5e53fd82b" translate="yes" xml:space="preserve">
          <source>As before, however, PostgreSQL does not enforce the size restriction in any case.</source>
          <target state="translated">然而,和之前一样,PostgreSQL在任何情况下都不会执行大小限制。</target>
        </trans-unit>
        <trans-unit id="6c4c55629e9060b4cdfbd0fb1ea96b264210b4b6" translate="yes" xml:space="preserve">
          <source>As before, the estimated number of rows is just the product of this with the cardinality of &lt;code&gt;tenk1&lt;/code&gt;:</source>
          <target state="translated">像以前一样，估计的行数只是这与 &lt;code&gt;tenk1&lt;/code&gt; 的基数的乘积：</target>
        </trans-unit>
        <trans-unit id="7a87fbf380bd12f56579ba8b09d2dfca1e87a7aa" translate="yes" xml:space="preserve">
          <source>As described in &lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;Section 4.2.14&lt;/a&gt;, there are various situations in which subexpressions of an expression are evaluated at different times, so that the principle that &amp;ldquo;&lt;code&gt;CASE&lt;/code&gt; evaluates only necessary subexpressions&amp;rdquo; is not ironclad. For example a constant &lt;code&gt;1/0&lt;/code&gt; subexpression will usually result in a division-by-zero failure at planning time, even if it's within a &lt;code&gt;CASE&lt;/code&gt; arm that would never be entered at run time.</source>
          <target state="translated">如&lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;第4.2.14节&lt;/a&gt;所述，在多种情况下，表达式的子表达式会在不同的时间进行评估，因此&amp;ldquo; &lt;code&gt;CASE&lt;/code&gt; 仅评估必要的子表达式&amp;rdquo; 的原则并没有被牢记。例如，恒定的 &lt;code&gt;1/0&lt;/code&gt; 子表达式通常会在计划时导致除以零的失败，即使它在 &lt;code&gt;CASE&lt;/code&gt; 分支中，也永远不会在运行时输入。</target>
        </trans-unit>
        <trans-unit id="518e3cc29b2ad22029595abb39bdf434ee471900" translate="yes" xml:space="preserve">
          <source>As described in the previous section, transaction commit is normally &lt;em&gt;synchronous&lt;/em&gt;: the server waits for the transaction's WAL records to be flushed to permanent storage before returning a success indication to the client. The client is therefore guaranteed that a transaction reported to be committed will be preserved, even in the event of a server crash immediately after. However, for short transactions this delay is a major component of the total transaction time. Selecting asynchronous commit mode means that the server returns success as soon as the transaction is logically completed, before the WAL records it generated have actually made their way to disk. This can provide a significant boost in throughput for small transactions.</source>
          <target state="translated">如上一节所述，事务提交通常是&lt;em&gt;同步的&lt;/em&gt;：服务器在将成功指示返回给客户端之前，等待事务的WAL记录刷新到永久存储。因此，即使在此后立即发生服务器崩溃的情况下，也可以保证客户端将保留报告为已提交的事务。但是，对于短交易，此延迟是总交易时间的主要组成部分。选择异步提交模式意味着在逻辑上完成事务之后，服务器将在生成的WAL记录实际进入磁盘之前返回成功。这可以大大提高小事务的吞吐量。</target>
        </trans-unit>
        <trans-unit id="64a53cc76e5b39051f25182477eec0422ea4a682" translate="yes" xml:space="preserve">
          <source>As explained above, it is possible to create indexes on partitioned tables and they are applied automatically to the entire hierarchy. This is very convenient, as not only the existing partitions will become indexed, but also any partitions that are created in the future will. One limitation is that it's not possible to use the &lt;code&gt;CONCURRENTLY&lt;/code&gt; qualifier when creating such a partitioned index. To overcome long lock times, it is possible to use &lt;code&gt;CREATE INDEX ON ONLY&lt;/code&gt; the partitioned table; such an index is marked invalid, and the partitions do not get the index applied automatically. The indexes on partitions can be created separately using &lt;code&gt;CONCURRENTLY&lt;/code&gt;, and later &lt;em&gt;attached&lt;/em&gt; to the index on the parent using &lt;code&gt;ALTER INDEX .. ATTACH PARTITION&lt;/code&gt;. Once indexes for all partitions are attached to the parent index, the parent index is marked valid automatically. Example:</source>
          <target state="translated">如上所述，可以在分区表上创建索引，并将它们自动应用于整个层次结构。这非常方便，因为不仅现有分区将被索引，而且将来创建的任何分区也将被索引。一个限制是创建这样的分区索引时不能使用 &lt;code&gt;CONCURRENTLY&lt;/code&gt; 限定符。为了克服较长的锁定时间，可以 &lt;code&gt;CREATE INDEX ON ONLY&lt;/code&gt; 在分区表上使用CREATE INDEX；这样的索引被标记为无效，并且分区不会自动应用该索引。可以使用 &lt;code&gt;CONCURRENTLY&lt;/code&gt; 分别创建分区上的索引，然后使用&lt;em&gt;附加&lt;/em&gt;到父级上的索引 &lt;code&gt;ALTER INDEX .. ATTACH PARTITION&lt;/code&gt; 。将所有分区的索引附加到父索引后，父索引会自动标记为有效。例：</target>
        </trans-unit>
        <trans-unit id="fb2dc582124a2fe2747429c6ba796f17d561c7c2" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;ddl-priv&quot;&gt;Section 5.7&lt;/a&gt;, the default privileges for any object type normally grant all grantable permissions to the object owner, and may grant some privileges to &lt;code&gt;PUBLIC&lt;/code&gt; as well. However, this behavior can be changed by altering the global default privileges with &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt;.</source>
          <target state="translated">如&lt;a href=&quot;ddl-priv&quot;&gt;第5.7节&lt;/a&gt;所述，任何对象类型的默认特权通常都会向对象所有者授予所有可授予的权限，并且可能还会向 &lt;code&gt;PUBLIC&lt;/code&gt; 授予某些特权。但是，可以通过使用 &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt; 更改全局默认特权来更改此行为。</target>
        </trans-unit>
        <trans-unit id="7cfc29a245774c7f93be3cd482cd2720e2efb253" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;multivariate-statistics-examples#FUNCTIONAL-DEPENDENCIES&quot;&gt;Section 70.2.1&lt;/a&gt;, functional dependencies are very cheap and efficient type of statistics, but their main limitation is their global nature (only tracking dependencies at the column level, not between individual column values).</source>
          <target state="translated">如&lt;a href=&quot;multivariate-statistics-examples#FUNCTIONAL-DEPENDENCIES&quot;&gt;第70.2.1节所述&lt;/a&gt;，功能依赖是非常便宜和高效的统计类型，但是它们的主要局限性是它们的全局性质（仅在列级别跟踪依赖，而不是在单个列值之间跟踪）。</target>
        </trans-unit>
        <trans-unit id="c5ba1476be535d17f697ff078bc8840ec5998688" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;planner-stats&quot;&gt;Section 14.2&lt;/a&gt;, the planner can determine cardinality of &lt;code&gt;t&lt;/code&gt; using the number of pages and rows obtained from &lt;code&gt;pg_class&lt;/code&gt;:</source>
          <target state="translated">如&lt;a href=&quot;planner-stats&quot;&gt;第14.2节&lt;/a&gt;所述，计划者可以使用从 &lt;code&gt;pg_class&lt;/code&gt; 获得的页数和行数来确定 &lt;code&gt;t&lt;/code&gt; 的基数：</target>
        </trans-unit>
        <trans-unit id="39801241473f144107571af31829d77f27364c9d" translate="yes" xml:space="preserve">
          <source>As far as the operator class is concerned, returning &lt;code&gt;true&lt;/code&gt; indicates that deduplication is safe (or safe for the collation whose OID was passed to its &lt;code&gt;equalimage&lt;/code&gt; function). However, the core code will only deem deduplication safe for an index when &lt;em&gt;every&lt;/em&gt; indexed column uses an operator class that registers an &lt;code&gt;equalimage&lt;/code&gt; function, and each function actually returns &lt;code&gt;true&lt;/code&gt; when called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="149ce91ff7ffadae424c16cab2b4c0512100eae4" translate="yes" xml:space="preserve">
          <source>As in basic &lt;code&gt;tsquery&lt;/code&gt; input, weight(s) can be attached to each lexeme to restrict it to match only &lt;code&gt;tsvector&lt;/code&gt; lexemes of those weight(s). For example:</source>
          <target state="translated">就像在基本 &lt;code&gt;tsquery&lt;/code&gt; 输入中一样，可以将权重附加到每个词素上，以限制它仅匹配那些权重的 &lt;code&gt;tsvector&lt;/code&gt; 词素。例如：</target>
        </trans-unit>
        <trans-unit id="1c139aca10977b17d5102cc7674b71010f5c568f" translate="yes" xml:space="preserve">
          <source>As is standard in SQL, all functions return NULL, if any of the arguments are NULL. This may create security risks on careless usage.</source>
          <target state="translated">作为标准的SQL函数,如果任何参数是NULL,所有函数都返回NULL。这可能会对不小心使用造成安全风险。</target>
        </trans-unit>
        <trans-unit id="585d0521870959cf15a89091a2347acd4003a598" translate="yes" xml:space="preserve">
          <source>As is typical of client/server applications, the client and the server can be on different hosts. In that case they communicate over a TCP/IP network connection. You should keep this in mind, because the files that can be accessed on a client machine might not be accessible (or might only be accessible using a different file name) on the database server machine.</source>
          <target state="translated">如同典型的客户/服务器应用程序一样,客户和服务器可以在不同的主机上。在这种情况下,它们通过TCP/IP网络连接进行通信。你应该记住这一点,因为在客户端机器上可以访问的文件在数据库服务器机器上可能无法访问(或者可能只能使用不同的文件名访问)。</target>
        </trans-unit>
        <trans-unit id="29fce103d97e5fc966f97584895b606dc9b97769" translate="yes" xml:space="preserve">
          <source>As long as WAL disk usage stays below this setting, old WAL files are always recycled for future use at a checkpoint, rather than removed. This can be used to ensure that enough WAL space is reserved to handle spikes in WAL usage, for example when running large batch jobs. If this value is specified without units, it is taken as megabytes. The default is 80 MB. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">只要WAL磁盘使用率保持低于此设置，旧的WAL文件将始终在检查点被回收以备将来使用，而不是被删除。这可以用来确保保留足够的WAL空间来处理WAL使用率的峰值，例如在运行大型批处理作业时。如果指定的该值不带单位，则以兆字节为单位。默认值为80 MB。该参数只能在 &lt;code&gt;postgresql.conf&lt;/code&gt; 文件或服务器命令行中设置。</target>
        </trans-unit>
        <trans-unit id="935b68a13a63015aa5e693b61464b2a9c3100546" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, each (active) subscription receives changes from a replication slot on the remote (publishing) side. Normally, the remote replication slot is created automatically when the subscription is created using &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; and it is dropped automatically when the subscription is dropped using &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt;. In some situations, however, it can be useful or necessary to manipulate the subscription and the underlying replication slot separately. Here are some scenarios:</source>
          <target state="translated">如前所述，每个（活动）订阅都从远程（发布）端的复制插槽接收更改。通常，使用 &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; 创建订阅时会自动创建远程复制插槽，而使用 &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; 删除订阅时会自动删除远程复制插槽。但是，在某些情况下，单独操作预订和基础复制插槽可能是有用或必要的。以下是一些方案：</target>
        </trans-unit>
        <trans-unit id="6d35d01797be09599719c5fbe0e98e1d8b777874" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;Section 13.2.3&lt;/a&gt;, Serializable transactions are just Repeatable Read transactions which add nonblocking monitoring for dangerous patterns of read/write conflicts. When a pattern is detected which could cause a cycle in the apparent order of execution, one of the transactions involved is rolled back to break the cycle.</source>
          <target state="translated">如&lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;第13.2.3节所述&lt;/a&gt;，可序列化事务只是可重复读取事务，它添加了对危险的读写冲突模式的无阻塞监视。当检测到可能导致明显执行顺序中的周期的模式时，所涉及的事务之一将回滚以破坏周期。</target>
        </trans-unit>
        <trans-unit id="820f9f6df5cbde09a17525e7847d0d2dfe09b2c4" translate="yes" xml:space="preserve">
          <source>As mentioned, there are multiple types of TOAST pointer datums. The oldest and most common type is a pointer to out-of-line data stored in a &lt;em&gt;TOAST table&lt;/em&gt; that is separate from, but associated with, the table containing the TOAST pointer datum itself. These &lt;em&gt;on-disk&lt;/em&gt; pointer datums are created by the TOAST management code (in &lt;code&gt;access/common/toast_internals.c&lt;/code&gt;) when a tuple to be stored on disk is too large to be stored as-is. Further details appear in &lt;a href=&quot;storage-toast#STORAGE-TOAST-ONDISK&quot;&gt;Section 68.2.1&lt;/a&gt;. Alternatively, a TOAST pointer datum can contain a pointer to out-of-line data that appears elsewhere in memory. Such datums are necessarily short-lived, and will never appear on-disk, but they are very useful for avoiding copying and redundant processing of large data values. Further details appear in &lt;a href=&quot;storage-toast#STORAGE-TOAST-INMEMORY&quot;&gt;Section 68.2.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7967f9ae1b2dfb5df2376dc5e14f007c840b5d2" translate="yes" xml:space="preserve">
          <source>As mentioned, there are multiple types of TOAST pointer datums. The oldest and most common type is a pointer to out-of-line data stored in a &lt;em&gt;TOAST table&lt;/em&gt; that is separate from, but associated with, the table containing the TOAST pointer datum itself. These &lt;em&gt;on-disk&lt;/em&gt; pointer datums are created by the TOAST management code (in &lt;code&gt;access/heap/tuptoaster.c&lt;/code&gt;) when a tuple to be stored on disk is too large to be stored as-is. Further details appear in &lt;a href=&quot;storage-toast#STORAGE-TOAST-ONDISK&quot;&gt;Section 68.2.1&lt;/a&gt;. Alternatively, a TOAST pointer datum can contain a pointer to out-of-line data that appears elsewhere in memory. Such datums are necessarily short-lived, and will never appear on-disk, but they are very useful for avoiding copying and redundant processing of large data values. Further details appear in &lt;a href=&quot;storage-toast#STORAGE-TOAST-INMEMORY&quot;&gt;Section 68.2.2&lt;/a&gt;.</source>
          <target state="translated">如前所述，有多种类型的TOAST指针基准。最古老和最常见的类型是指向存储在&lt;em&gt;TOAST&lt;/em&gt;表中的脱机数据的指针，该表与包含TOAST指针数据本身的表分离但关联。当要存储在磁盘上的元组太大而不能按原样存储时，这些&lt;em&gt;磁盘上的&lt;/em&gt;指针基准由TOAST管理代码（在 &lt;code&gt;access/heap/tuptoaster.c&lt;/code&gt; 中）创建。更多详细信息，请参见&lt;a href=&quot;storage-toast#STORAGE-TOAST-ONDISK&quot;&gt;第68.2.1节。&lt;/a&gt;。或者，TOAST指针数据可以包含指向内存中其他位置出现的离线数据的指针。这样的数据必然是短暂的，并且永远不会出现在磁盘上，但是它们对于避免复制和冗余处理大数据值非常有用。更多详细信息，请参见&lt;a href=&quot;storage-toast#STORAGE-TOAST-INMEMORY&quot;&gt;第68.2.2节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e83c3b33db2892f30f5c07aab1da708113577a83" translate="yes" xml:space="preserve">
          <source>As noted above, if the server crashes during the backup it may not be possible to restart until the &lt;code&gt;backup_label&lt;/code&gt; file has been manually deleted from the &lt;code&gt;PGDATA&lt;/code&gt; directory. Note that it is very important to never remove the &lt;code&gt;backup_label&lt;/code&gt; file when restoring a backup, because this will result in corruption. Confusion about when it is appropriate to remove this file is a common cause of data corruption when using this method; be very certain that you remove the file only on an existing master and never when building a standby or restoring a backup, even if you are building a standby that will subsequently be promoted to a new master.</source>
          <target state="translated">如上所述，如果服务器在备份过程中崩溃，则可能无法重新启动，直到从 &lt;code&gt;PGDATA&lt;/code&gt; 目录中手动删除了 &lt;code&gt;backup_label&lt;/code&gt; 文件。请注意，在还原备份时切勿删除 &lt;code&gt;backup_label&lt;/code&gt; 文件，因为这将导致损坏，这一点非常重要。使用此方法时，关于何时删除该文件的困惑是导致数据损坏的常见原因；确保您仅在现有的主数据库上删除文件，而在构建备用数据库或还原备份时绝对不要删除文件，即使您要构建随后将被提升为新主数据库的备用数据库也是如此。</target>
        </trans-unit>
        <trans-unit id="b565015dcc8ef588510a75b03d00c798591daa60" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 8.4, &lt;code&gt;amvacuumcleanup&lt;/code&gt; will also be called at completion of an &lt;code&gt;ANALYZE&lt;/code&gt; operation. In this case &lt;code&gt;stats&lt;/code&gt; is always NULL and any return value will be ignored. This case can be distinguished by checking &lt;code&gt;info-&amp;gt;analyze_only&lt;/code&gt;. It is recommended that the access method do nothing except post-insert cleanup in such a call, and that only in an autovacuum worker process.</source>
          <target state="translated">从PostgreSQL 8.4开始，在完成 &lt;code&gt;ANALYZE&lt;/code&gt; 操作时还将调用 &lt;code&gt;amvacuumcleanup&lt;/code&gt; 。在这种情况下， &lt;code&gt;stats&lt;/code&gt; 始终为NULL，任何返回值都将被忽略。通过检查 &lt;code&gt;info-&amp;gt;analyze_only&lt;/code&gt; 可以区分这种情况。建议访问方法除了在此类调用中进行插入后清理外，不执行任何操作，并且仅在自动清理工作进程中进行。</target>
        </trans-unit>
        <trans-unit id="41cf08ef1ae95fce9351d2775b5ca30eb5967a1b" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 8.4, this advice is less necessary since delayed indexing is used (see &lt;a href=&quot;gin-implementation#GIN-FAST-UPDATE&quot;&gt;Section 66.4.1&lt;/a&gt; for details). But for very large updates it may still be best to drop and recreate the index.</source>
          <target state="translated">从PostgreSQL 8.4开始，由于使用了延迟索引，因此该建议不再那么必要（有关详细信息，请参见&lt;a href=&quot;gin-implementation#GIN-FAST-UPDATE&quot;&gt;第66.4.1节&lt;/a&gt;）。但是对于非常大的更新，仍然最好删除并重新创建索引。</target>
        </trans-unit>
        <trans-unit id="fd60ea8bf7dbb2005dc3edad9e036817a4cf429d" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 9.0, &lt;code&gt;hstore&lt;/code&gt; uses a different internal representation than previous versions. This presents no obstacle for dump/restore upgrades since the text representation (used in the dump) is unchanged.</source>
          <target state="translated">从PostgreSQL 9.0开始， &lt;code&gt;hstore&lt;/code&gt; 使用与以前版本不同的内部表示形式。这对转储/还原升级没有任何障碍，因为文本表示形式（在转储中使用）保持不变。</target>
        </trans-unit>
        <trans-unit id="280a05cda72f4f22e9db55fedf9a21987eec509c" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 9.1, most procedural languages have been made into &amp;ldquo;extensions&amp;rdquo;, and should therefore be installed with &lt;a href=&quot;sql-createextension&quot;&gt;CREATE EXTENSION&lt;/a&gt; not &lt;code&gt;CREATE LANGUAGE&lt;/code&gt;. Direct use of &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; should now be confined to extension installation scripts. If you have a &amp;ldquo;bare&amp;rdquo; language in your database, perhaps as a result of an upgrade, you can convert it to an extension using &lt;code&gt;CREATE EXTENSION langname FROM unpackaged&lt;/code&gt;.</source>
          <target state="translated">从PostgreSQL 9.1开始，大多数过程语言都已被制成&amp;ldquo;扩展名&amp;rdquo;，因此应使用&lt;a href=&quot;sql-createextension&quot;&gt;CREATE EXTENSION&lt;/a&gt;而不是 &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; 进行安装。现在，直接使用 &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; 的操作应仅限于扩展安装脚本。如果您的数据库中存在&amp;ldquo;裸&amp;rdquo;语言（可能是升级的结果），则可以使用 &lt;code&gt;CREATE EXTENSION langname FROM unpackaged&lt;/code&gt; 将其转换为扩展名。</target>
        </trans-unit>
        <trans-unit id="ad6c1afacf960c00b0b43cc22652add17660a754" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 9.1, most procedural languages have been made into &amp;ldquo;extensions&amp;rdquo;, and should therefore be removed with &lt;a href=&quot;sql-dropextension&quot;&gt;DROP EXTENSION&lt;/a&gt; not &lt;code&gt;DROP LANGUAGE&lt;/code&gt;.</source>
          <target state="translated">从PostgreSQL 9.1开始，大多数过程语言都已被制成&amp;ldquo;扩展名&amp;rdquo;，因此应使用&lt;a href=&quot;sql-dropextension&quot;&gt;DROP EXTENSION&lt;/a&gt;而不是 &lt;code&gt;DROP LANGUAGE&lt;/code&gt; 删除。</target>
        </trans-unit>
        <trans-unit id="9efc7bda1a790af9716120cc8586743f8662e379" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 9.1, null key values can be included in the index. Also, placeholder nulls are included in the index for indexed items that are null or contain no keys according to &lt;code&gt;extractValue&lt;/code&gt;. This allows searches that should find empty items to do so.</source>
          <target state="translated">从PostgreSQL 9.1开始，空键值可以包含在索引中。此外，根据 &lt;code&gt;extractValue&lt;/code&gt; 的索引项为null或不包含任何键的索引项中，占位符null包含在索引中。这样一来，应该可以找到空项目的搜索。</target>
        </trans-unit>
        <trans-unit id="41a7562cb3e64fe55b5aa379cb00b42fdb0e1138" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 9.1, you can attach a &lt;code&gt;COLLATE&lt;/code&gt; specification to &lt;code&gt;citext&lt;/code&gt; columns or data values. Currently, &lt;code&gt;citext&lt;/code&gt; operators will honor a non-default &lt;code&gt;COLLATE&lt;/code&gt; specification while comparing case-folded strings, but the initial folding to lower case is always done according to the database's &lt;code&gt;LC_CTYPE&lt;/code&gt; setting (that is, as though &lt;code&gt;COLLATE &quot;default&quot;&lt;/code&gt; were given). This may be changed in a future release so that both steps follow the input &lt;code&gt;COLLATE&lt;/code&gt; specification.</source>
          <target state="translated">从PostgreSQL 9.1开始，您可以将 &lt;code&gt;COLLATE&lt;/code&gt; 规范附加到 &lt;code&gt;citext&lt;/code&gt; 列或数据值。当前， &lt;code&gt;citext&lt;/code&gt; 运算符在比较大小写折叠的字符串时将 &lt;code&gt;COLLATE&lt;/code&gt; 非默认的COLLATE规范，但是始终根据数据库的 &lt;code&gt;LC_CTYPE&lt;/code&gt; 设置（即，好像给了 &lt;code&gt;COLLATE &quot;default&quot;&lt;/code&gt; ）来完成将小写的初始折叠。在将来的发行版中可能会对此进行更改，以便两个步骤都遵循输入的 &lt;code&gt;COLLATE&lt;/code&gt; 规范。</target>
        </trans-unit>
        <trans-unit id="9cdab33dd907fd023cacb62f21aa10cc62e305ca" translate="yes" xml:space="preserve">
          <source>As pg_rewind copies configuration files entirely from the source, it may be required to correct the configuration used for recovery before restarting the target server, especially if the target is reintroduced as a standby of the source. If you restart the server after the rewind operation has finished but without configuring recovery, the target may again diverge from the primary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df8c2a751dfbd5be0d7c157dabee58d14e6c8985" translate="yes" xml:space="preserve">
          <source>As previously stated, when a JSON value is input and then printed without any additional processing, &lt;code&gt;json&lt;/code&gt; outputs the same text that was input, while &lt;code&gt;jsonb&lt;/code&gt; does not preserve semantically-insignificant details such as whitespace. For example, note the differences here:</source>
          <target state="translated">如前所述，当输入JSON值然后在不进行任何其他处理的情况下进行打印时， &lt;code&gt;json&lt;/code&gt; 输出与输入相同的文本，而 &lt;code&gt;jsonb&lt;/code&gt; 则不会保留语义无关紧要的细节，例如空格。例如，请注意此处的区别：</target>
        </trans-unit>
        <trans-unit id="1442483656b1d2da488c86cbbe647b9c3925f511" translate="yes" xml:space="preserve">
          <source>As seen in the second example, the element name can be omitted if the content value is a column reference, in which case the column name is used by default. Otherwise, a name must be specified.</source>
          <target state="translated">从第二个例子中可以看出,如果内容值是列引用,那么元素名可以省略,在这种情况下,默认使用列名。否则,必须指定一个名称。</target>
        </trans-unit>
        <trans-unit id="fbfde401bab7c53809229a3d8a380b7c73d7b56a" translate="yes" xml:space="preserve">
          <source>As seen in this example, when the query is an &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt; command, the actual work of applying the table changes is done by a top-level Insert, Update, or Delete plan node. The plan nodes underneath this node perform the work of locating the old rows and/or computing the new data. So above, we see the same sort of bitmap table scan we've seen already, and its output is fed to an Update node that stores the updated rows. It's worth noting that although the data-modifying node can take a considerable amount of run time (here, it's consuming the lion's share of the time), the planner does not currently add anything to the cost estimates to account for that work. That's because the work to be done is the same for every correct query plan, so it doesn't affect planning decisions.</source>
          <target state="translated">如本例所示，当查询为 &lt;code&gt;INSERT&lt;/code&gt; ， &lt;code&gt;UPDATE&lt;/code&gt; 或 &lt;code&gt;DELETE&lt;/code&gt; 时命令，应用表更改的实际工作由顶级&amp;ldquo;插入&amp;rdquo;，&amp;ldquo;更新&amp;rdquo;或&amp;ldquo;删除&amp;rdquo;计划节点完成。在该节点下面的计划节点执行定位旧行和/或计算新数据的工作。因此，在上面，我们看到了已经看到的相同类型的位图表扫描，并且其输出被馈送到存储更新行的Update节点。值得注意的是，尽管数据修改节点会花费大量的运行时间（在这里，这消耗了大部分时间），但是计划人员当前并未在成本估算中添加任何内容来说明这项工作。这是因为每个正确的查询计划要完成的工作都是相同的，因此不会影响计划决策。</target>
        </trans-unit>
        <trans-unit id="c1072787f6d22b0aaf6039c0a8fa7f37aca0290a" translate="yes" xml:space="preserve">
          <source>As shown above, all comparison operators are binary operators that return values of type &lt;code&gt;boolean&lt;/code&gt;. Thus, expressions like &lt;code&gt;1 &amp;lt; 2 &amp;lt; 3&lt;/code&gt; are not valid (because there is no &lt;code&gt;&amp;lt;&lt;/code&gt; operator to compare a Boolean value with &lt;code&gt;3&lt;/code&gt;). Use the &lt;code&gt;BETWEEN&lt;/code&gt; predicates shown below to perform range tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="299b9141677294c0e2aa3b93c3483b8a98e2f995" translate="yes" xml:space="preserve">
          <source>As shown above, the &lt;code&gt;union&lt;/code&gt; function's first &lt;code&gt;internal&lt;/code&gt; argument is actually a &lt;code&gt;GistEntryVector&lt;/code&gt; pointer. The second argument is a pointer to an integer variable, which can be ignored. (It used to be required that the &lt;code&gt;union&lt;/code&gt; function store the size of its result value into that variable, but this is no longer necessary.)</source>
          <target state="translated">如上所示， &lt;code&gt;union&lt;/code&gt; 函数的第一个 &lt;code&gt;internal&lt;/code&gt; 参数实际上是 &lt;code&gt;GistEntryVector&lt;/code&gt; 指针。第二个参数是指向整数变量的指针，可以将其忽略。（过去要求并 &lt;code&gt;union&lt;/code&gt; 函数将其结果值的大小存储到该变量中，但这不再是必需的。）</target>
        </trans-unit>
        <trans-unit id="e49718fcf44bf904fec83a97285f69086516abb8" translate="yes" xml:space="preserve">
          <source>As shown here, the &lt;code&gt;rank&lt;/code&gt; function produces a numerical rank for each distinct &lt;code&gt;ORDER BY&lt;/code&gt; value in the current row's partition, using the order defined by the &lt;code&gt;ORDER BY&lt;/code&gt; clause. &lt;code&gt;rank&lt;/code&gt; needs no explicit parameter, because its behavior is entirely determined by the &lt;code&gt;OVER&lt;/code&gt; clause.</source>
          <target state="translated">如此处所示， &lt;code&gt;rank&lt;/code&gt; 函数使用 &lt;code&gt;ORDER BY&lt;/code&gt; 子句定义的顺序为当前行分区中的每个不同的 &lt;code&gt;ORDER BY&lt;/code&gt; 值生成一个数字等级。 &lt;code&gt;rank&lt;/code&gt; 不需要显式参数，因为它的行为完全由 &lt;code&gt;OVER&lt;/code&gt; 子句确定。</target>
        </trans-unit>
        <trans-unit id="7278da1d6766bb19352b261eabd292dd18fce4c5" translate="yes" xml:space="preserve">
          <source>As shown in &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-BTREE-STRAT-TABLE&quot;&gt;Table 37.2&lt;/a&gt;, a btree operator class must provide five comparison operators, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;. One might expect that &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; should also be part of the operator class, but it is not, because it would almost never be useful to use a &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; WHERE clause in an index search. (For some purposes, the planner treats &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; as associated with a btree operator class; but it finds that operator via the &lt;code&gt;=&lt;/code&gt; operator's negator link, rather than from &lt;code&gt;pg_amop&lt;/code&gt;.)</source>
          <target state="translated">如&lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-BTREE-STRAT-TABLE&quot;&gt;表37.2&lt;/a&gt;所示，btree运算符类必须提供五个比较运算符 &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;=&lt;/code&gt; ， &lt;code&gt;=&lt;/code&gt; ， &lt;code&gt;&amp;gt;=&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&lt;/code&gt; 。可能希望 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 也应该属于运算符类，但事实并非如此，因为在索引搜索中使用 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; WHERE子句几乎永远不会有用。 （出于某些目的，计划者将 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 视为与btree运算符类相关联；但它通过 &lt;code&gt;=&lt;/code&gt; 运算符的求反符链接而不是从 &lt;code&gt;pg_amop&lt;/code&gt; 找到该运算符。）</target>
        </trans-unit>
        <trans-unit id="2b7658bd4634c80bfa02d903fd89d9f89cfdf0c3" translate="yes" xml:space="preserve">
          <source>As shown in &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-BTREE-SUPPORT-TABLE&quot;&gt;Table 37.8&lt;/a&gt;, btree defines one required and two optional support functions.</source>
          <target state="translated">如&lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-BTREE-SUPPORT-TABLE&quot;&gt;表37.8&lt;/a&gt;所示，btree定义了一个必需的功能和两个可选的支持功能。</target>
        </trans-unit>
        <trans-unit id="e2e2d713a7e1c4b73e9dae4d9b294d20af0dfdbd" translate="yes" xml:space="preserve">
          <source>As shown in &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-BTREE-STRAT-TABLE&quot;&gt;Table 37.3&lt;/a&gt;, a btree operator class must provide five comparison operators, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;. One might expect that &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; should also be part of the operator class, but it is not, because it would almost never be useful to use a &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; WHERE clause in an index search. (For some purposes, the planner treats &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; as associated with a btree operator class; but it finds that operator via the &lt;code&gt;=&lt;/code&gt; operator's negator link, rather than from &lt;code&gt;pg_amop&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd9a67840a67dabf7761754a18fc846d1c2e26f5" translate="yes" xml:space="preserve">
          <source>As shown in &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-BTREE-SUPPORT-TABLE&quot;&gt;Table 37.9&lt;/a&gt;, btree defines one required and four optional support functions. The five user-defined methods are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01827ef18402ec5bd4e9a302a910b59d06b2ca2b" translate="yes" xml:space="preserve">
          <source>As shown in the previous section, the table expression in the &lt;code&gt;SELECT&lt;/code&gt; command constructs an intermediate virtual table by possibly combining tables, views, eliminating rows, grouping, etc. This table is finally passed on to processing by the &lt;em&gt;select list&lt;/em&gt;. The select list determines which &lt;em&gt;columns&lt;/em&gt; of the intermediate table are actually output.</source>
          <target state="translated">如前一部分所示， &lt;code&gt;SELECT&lt;/code&gt; 命令中的表表达式通过可能的组合表，视图，消除行，分组等来构造中间虚拟表。该表最终由&lt;em&gt;选择列表&lt;/em&gt;传递给处理。选择列表确定实际输出中间表的哪些&lt;em&gt;列&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="a1a6ed6a1882593d5ac926bd03fffe04913abef7" translate="yes" xml:space="preserve">
          <source>As shown previously, when writing a composite value you can write double quotes around any individual field value. You &lt;em&gt;must&lt;/em&gt; do so if the field value would otherwise confuse the composite-value parser. In particular, fields containing parentheses, commas, double quotes, or backslashes must be double-quoted. To put a double quote or backslash in a quoted composite field value, precede it with a backslash. (Also, a pair of double quotes within a double-quoted field value is taken to represent a double quote character, analogously to the rules for single quotes in SQL literal strings.) Alternatively, you can avoid quoting and use backslash-escaping to protect all data characters that would otherwise be taken as composite syntax.</source>
          <target state="translated">如前所示，编写复合值时，您可以在任何单个字段值周围写双引号。你&lt;em&gt;必须&lt;/em&gt;这样做，如果该字段的值，否则混淆复合数值分析器。特别是，包含括号，逗号，双引号或反斜杠的字段必须用双引号引起来。要将双引号或反斜杠放在带引号的复合字段值中，请在其前面加上反斜杠。 （此外，双引号字段值内的一对双引号也代表双引号字符，类似于SQL文字字符串中单引号的规则。）另外，您可以避免引号并使用反斜杠转义来保护所有否则将被视为复合语法的数据字符。</target>
        </trans-unit>
        <trans-unit id="bf6c49e3bf726dc38d17652f47395db71e4e4fbd" translate="yes" xml:space="preserve">
          <source>As shown previously, when writing an array value you can use double quotes around any individual array element. You &lt;em&gt;must&lt;/em&gt; do so if the element value would otherwise confuse the array-value parser. For example, elements containing curly braces, commas (or the data type's delimiter character), double quotes, backslashes, or leading or trailing whitespace must be double-quoted. Empty strings and strings matching the word &lt;code&gt;NULL&lt;/code&gt; must be quoted, too. To put a double quote or backslash in a quoted array element value, precede it with a backslash. Alternatively, you can avoid quotes and use backslash-escaping to protect all data characters that would otherwise be taken as array syntax.</source>
          <target state="translated">如前所示，在编写数组值时，可以在任何单个数组元素周围使用双引号。你&lt;em&gt;必须&lt;/em&gt;这样做，如果元素数值可能混淆数组数值分析器。例如，包含大括号，逗号（或数据类型的定界符），双引号，反斜杠或前导或尾随空格的元素必须用双引号引起来。空字符串和与单词 &lt;code&gt;NULL&lt;/code&gt; 匹配的字符串也必须加引号。要将双引号或反斜杠放在带引号的数组元素值中，请在其前面加上反斜杠。另外，您可以避免使用引号，并使用反斜杠转义来保护所有数据字符，否则这些字符将被视为数组语法。</target>
        </trans-unit>
        <trans-unit id="8a1775eb12b1097993052bc9db7c32cd0419a0ce" translate="yes" xml:space="preserve">
          <source>As shown, an array data type is named by appending square brackets (&lt;code&gt;[]&lt;/code&gt;) to the data type name of the array elements. The above command will create a table named &lt;code&gt;sal_emp&lt;/code&gt; with a column of type &lt;code&gt;text&lt;/code&gt; (&lt;code&gt;name&lt;/code&gt;), a one-dimensional array of type &lt;code&gt;integer&lt;/code&gt; (&lt;code&gt;pay_by_quarter&lt;/code&gt;), which represents the employee's salary by quarter, and a two-dimensional array of &lt;code&gt;text&lt;/code&gt; (&lt;code&gt;schedule&lt;/code&gt;), which represents the employee's weekly schedule.</source>
          <target state="translated">如图所示，通过将方括号（ &lt;code&gt;[]&lt;/code&gt; ）附加到数组元素的数据类型名称来命名数组数据类型。上面的命令将创建一个名为 &lt;code&gt;sal_emp&lt;/code&gt; 的表，该表具有一列类型为 &lt;code&gt;text&lt;/code&gt; （ &lt;code&gt;name&lt;/code&gt; ）的列，一个一维类型的 &lt;code&gt;integer&lt;/code&gt; （ &lt;code&gt;pay_by_quarter&lt;/code&gt; ）数组，该数组按季度代表员工的薪水，以及一列二维的 &lt;code&gt;text&lt;/code&gt; 数组（ &lt;code&gt;schedule&lt;/code&gt; ）。 ，代表员工的每周时间表。</target>
        </trans-unit>
        <trans-unit id="e0b46ae37bd20da5e49ea599dd897a3ac9299776" translate="yes" xml:space="preserve">
          <source>As the above example suggests, a &lt;code&gt;tsquery&lt;/code&gt; is not just raw text, any more than a &lt;code&gt;tsvector&lt;/code&gt; is. A &lt;code&gt;tsquery&lt;/code&gt; contains search terms, which must be already-normalized lexemes, and may combine multiple terms using AND, OR, NOT, and FOLLOWED BY operators. (For syntax details see &lt;a href=&quot;datatype-textsearch#DATATYPE-TSQUERY&quot;&gt;Section 8.11.2&lt;/a&gt;.) There are functions &lt;code&gt;to_tsquery&lt;/code&gt;, &lt;code&gt;plainto_tsquery&lt;/code&gt;, and &lt;code&gt;phraseto_tsquery&lt;/code&gt; that are helpful in converting user-written text into a proper &lt;code&gt;tsquery&lt;/code&gt;, primarily by normalizing words appearing in the text. Similarly, &lt;code&gt;to_tsvector&lt;/code&gt; is used to parse and normalize a document string. So in practice a text search match would look more like this:</source>
          <target state="translated">如以上示例所示， &lt;code&gt;tsquery&lt;/code&gt; 不仅是原始文本，还不止是 &lt;code&gt;tsvector&lt;/code&gt; 。一个 &lt;code&gt;tsquery&lt;/code&gt; 包含搜索词，它必须是已经标准化词素，并且可以使用AND多个方面，OR，NOT结合起来，并随后运营商。（有关语法的详细信息，请参见&lt;a href=&quot;datatype-textsearch#DATATYPE-TSQUERY&quot;&gt;第8.11.2节&lt;/a&gt;。）有 &lt;code&gt;to_tsquery&lt;/code&gt; ， &lt;code&gt;plainto_tsquery&lt;/code&gt; 和 &lt;code&gt;phraseto_tsquery&lt;/code&gt; 函数，它们有助于将用户编写的文本转换为适当的 &lt;code&gt;tsquery&lt;/code&gt; ，主要是通过标准化文本中出现的单词来实现。同样， &lt;code&gt;to_tsvector&lt;/code&gt; 用于解析和规范化文档字符串。因此，在实践中，文本搜索匹配看起来更像这样：</target>
        </trans-unit>
        <trans-unit id="6b22935fd06acdc1c0f8d1431b124c6c0f7b088d" translate="yes" xml:space="preserve">
          <source>As the last example demonstrates, the regexp split functions ignore zero-length matches that occur at the start or end of the string or immediately after a previous match. This is contrary to the strict definition of regexp matching that is implemented by &lt;code&gt;regexp_match&lt;/code&gt; and &lt;code&gt;regexp_matches&lt;/code&gt;, but is usually the most convenient behavior in practice. Other software systems such as Perl use similar definitions.</source>
          <target state="translated">如最后一个示例所示，正则表达式拆分函数将忽略零长度的匹配，该匹配发生在字符串的开头或结尾或紧接在上一个匹配之后。这与 &lt;code&gt;regexp_match&lt;/code&gt; 和 &lt;code&gt;regexp_matches&lt;/code&gt; 实现的regexp匹配的严格定义相反，但实际上通常是最方便的行为。其他软件系统（例如Perl）也使用类似的定义。</target>
        </trans-unit>
        <trans-unit id="0378825838c0e066e87e6d5b0be89bee2dd5620d" translate="yes" xml:space="preserve">
          <source>As usual, null values in the rows are combined per the normal rules of SQL Boolean expressions. Two rows are considered equal if all their corresponding members are non-null and equal; the rows are unequal if any corresponding members are non-null and unequal; otherwise the result of that row comparison is unknown (null). If all the per-row results are either unequal or null, with at least one null, then the result of &lt;code&gt;IN&lt;/code&gt; is null.</source>
          <target state="translated">通常，将按照SQL布尔表达式的常规规则合并行中的空值。如果两行的所有对应成员均为非null且相等，则认为两行相等；如果任何相应的成员为非空且不相等，则行不相等；否则，该行比较的结果未知（空）。如果所有的每行结果都不相等或为null，并且至少有一个null，则 &lt;code&gt;IN&lt;/code&gt; 的结果为null。</target>
        </trans-unit>
        <trans-unit id="0b8508c03666af11ade2c1725a303ade508dcc57" translate="yes" xml:space="preserve">
          <source>As usual, null values in the rows are combined per the normal rules of SQL Boolean expressions. Two rows are considered equal if all their corresponding members are non-null and equal; the rows are unequal if any corresponding members are non-null and unequal; otherwise the result of that row comparison is unknown (null). If all the per-row results are either unequal or null, with at least one null, then the result of &lt;code&gt;NOT IN&lt;/code&gt; is null.</source>
          <target state="translated">通常，将按照SQL布尔表达式的常规规则合并行中的空值。如果两行的所有对应成员均为非null且相等，则将其视为相等。如果任何相应的成员为非空且不相等，则行不相等；否则，该行比较的结果未知（空）。如果所有的每行结果都不相等或为null，且至少有一个null，则 &lt;code&gt;NOT IN&lt;/code&gt; 的结果为null。</target>
        </trans-unit>
        <trans-unit id="00f8ed65d004834d267f75de424eb5e9aec68c8b" translate="yes" xml:space="preserve">
          <source>As visible here, JIT was used, but inlining and expensive optimization were not. If &lt;a href=&quot;runtime-config-query#GUC-JIT-INLINE-ABOVE-COST&quot;&gt;jit_inline_above_cost&lt;/a&gt; or &lt;a href=&quot;runtime-config-query#GUC-JIT-OPTIMIZE-ABOVE-COST&quot;&gt;jit_optimize_above_cost&lt;/a&gt; were also lowered, that would change.</source>
          <target state="translated">如此处所示，使用了JIT，但没有使用内联和昂贵的优化。如果&lt;a href=&quot;runtime-config-query#GUC-JIT-INLINE-ABOVE-COST&quot;&gt;jit_inline_above_cost&lt;/a&gt;或&lt;a href=&quot;runtime-config-query#GUC-JIT-OPTIMIZE-ABOVE-COST&quot;&gt;jit_optimize_above_cost&lt;/a&gt;也降低了，那将会改变。</target>
        </trans-unit>
        <trans-unit id="e991d7170113bfec3a30551fcd7b4c1810192115" translate="yes" xml:space="preserve">
          <source>As we can see, a complex table hierarchy could require a substantial amount of DDL. In the above example we would be creating a new child table each month, so it might be wise to write a script that generates the required DDL automatically.</source>
          <target state="translated">我们可以看到,一个复杂的表层次结构可能需要大量的DDL。在上面的例子中,我们每个月都要创建一个新的子表,所以最好写一个脚本来自动生成所需的DDL。</target>
        </trans-unit>
        <trans-unit id="13f137c0044f99ee6629a214a80858091639b3df" translate="yes" xml:space="preserve">
          <source>As we saw in the previous section, the query planner needs to estimate the number of rows retrieved by a query in order to make good choices of query plans. This section provides a quick look at the statistics that the system uses for these estimates.</source>
          <target state="translated">正如我们在上一节中所看到的,查询规划器需要估计查询所检索的行数,以便做好查询计划的选择。本节将快速介绍系统用于这些估计的统计数据。</target>
        </trans-unit>
        <trans-unit id="6a378a5df8689a29e440cf7e593b2b7b017debb3" translate="yes" xml:space="preserve">
          <source>As well as tables, this option can be used to dump the definition of matching views, materialized views, foreign tables, and sequences. It will not dump the contents of views or materialized views, and the contents of foreign tables will only be dumped if the corresponding foreign server is specified with &lt;code&gt;--include-foreign-data&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e28715fe2eadf5afacb168abae8c272e3eef5af1" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;EXISTS&lt;/code&gt;, it's unwise to assume that the subquery will be evaluated completely.</source>
          <target state="translated">与 &lt;code&gt;EXISTS&lt;/code&gt; 一样，假设子查询将被完全评估是不明智的。</target>
        </trans-unit>
        <trans-unit id="22733a70e9587403334559bc9fffe583566e0a7a" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;LIKE&lt;/code&gt;, a backslash disables the special meaning of any of these metacharacters. A different escape character can be specified with &lt;code&gt;ESCAPE&lt;/code&gt;, or the escape capability can be disabled by writing &lt;code&gt;ESCAPE ''&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="181bd891b583b10919f382d152707212af1347e4" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;LIKE&lt;/code&gt;, a backslash disables the special meaning of any of these metacharacters; or a different escape character can be specified with &lt;code&gt;ESCAPE&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;LIKE&lt;/code&gt; 一样，反斜杠会禁用任何这些元字符的特殊含义；或可以使用 &lt;code&gt;ESCAPE&lt;/code&gt; 指定其他转义字符。</target>
        </trans-unit>
        <trans-unit id="8c360e616acbe7a6ddce202d4edfd50d452f4ba5" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;SIMILAR TO&lt;/code&gt;, the specified pattern must match the entire data string, or else the function fails and returns null. To indicate the part of the pattern for which the matching data sub-string is of interest, the pattern should contain two occurrences of the escape character followed by a double quote (&lt;code&gt;&quot;&lt;/code&gt;). The text matching the portion of the pattern between these separators is returned when the match is successful.</source>
          <target state="translated">与 &lt;code&gt;SIMILAR TO&lt;/code&gt; 一样，指定的模式必须匹配整个数据字符串，否则函数将失败并返回null。为了指示感兴趣的匹配数据子字符串的模式部分，该模式应包含两次出现的转义字符，后跟双引号（ &lt;code&gt;&quot;&lt;/code&gt; ）。与这些分隔符之间的模式部分匹配的文本为匹配成功时返回。</target>
        </trans-unit>
        <trans-unit id="2f915404c792b4b375081401e8be4799b6fdf5c9" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;pgstattuple&lt;/code&gt;, the results are accumulated page-by-page, and should not be expected to represent an instantaneous snapshot of the whole index.</source>
          <target state="translated">与 &lt;code&gt;pgstattuple&lt;/code&gt; 一样，结果是逐页累积的，不应期望代表整个索引的瞬时快照。</target>
        </trans-unit>
        <trans-unit id="fd70faee0fe9a1b62ee5a071b1f7e464081b1189" translate="yes" xml:space="preserve">
          <source>As with any security settings, it's important to test and ensure that the system is behaving as expected. Using the example above, this demonstrates that the permission system is working properly.</source>
          <target state="translated">与任何安全设置一样,测试并确保系统的行为符合预期是很重要的。使用上面的例子,这表明权限系统工作正常。</target>
        </trans-unit>
        <trans-unit id="f8169958f7a4429a1d75d6cb1d9f2e4af52ed1d2" translate="yes" xml:space="preserve">
          <source>As with any server daemon that is accessible to the outside world, it is advisable to run PostgreSQL under a separate user account. This user account should only own the data that is managed by the server, and should not be shared with other daemons. (For example, using the user &lt;code&gt;nobody&lt;/code&gt; is a bad idea.) In particular, it is advisable that this user account not own the PostgreSQL executable files, to ensure that a compromised server process could not modify those executables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f9153f6ce7772c623a80d637e2a8064efd48ff4" translate="yes" xml:space="preserve">
          <source>As with any server daemon that is accessible to the outside world, it is advisable to run PostgreSQL under a separate user account. This user account should only own the data that is managed by the server, and should not be shared with other daemons. (For example, using the user &lt;code&gt;nobody&lt;/code&gt; is a bad idea.) It is not advisable to install executables owned by this user because compromised systems could then modify their own binaries.</source>
          <target state="translated">与外界可以访问的任何服务器守护程序一样，建议在一个单独的用户帐户下运行PostgreSQL。该用户帐户应仅拥有服务器管理的数据，而不应与其他守护程序共享。（例如，使用用户 &lt;code&gt;nobody&lt;/code&gt; 是一个坏主意。）不建议安装该用户拥有的可执行文件，因为受感染的系统随后可能会修改其自己的二进制文件。</target>
        </trans-unit>
        <trans-unit id="c718a2b52c9e3b6c8aed088c8f0e6614024fc446" translate="yes" xml:space="preserve">
          <source>As with base backups, the easiest way to produce a standalone hot backup is to use the &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt; tool. If you include the &lt;code&gt;-X&lt;/code&gt; parameter when calling it, all the write-ahead log required to use the backup will be included in the backup automatically, and no special action is required to restore the backup.</source>
          <target state="translated">与基本备份一样，生成独立热备份的最简单方法是使用&lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt;工具。如果在调用时包括 &lt;code&gt;-X&lt;/code&gt; 参数，则使用备份所需的所有预写日志将自动包含在备份中，并且不需要特殊操作即可还原备份。</target>
        </trans-unit>
        <trans-unit id="478aba2ebcc8faa95902624459b6a85534e22480" translate="yes" xml:space="preserve">
          <source>As with dropping a column, you need to add &lt;code&gt;CASCADE&lt;/code&gt; if you want to drop a constraint that something else depends on. An example is that a foreign key constraint depends on a unique or primary key constraint on the referenced column(s).</source>
          <target state="translated">与删除列一样，如果要删除其他依赖项的约束，则需要添加 &lt;code&gt;CASCADE&lt;/code&gt; 。一个示例是外键约束取决于所引用列的唯一或主键约束。</target>
        </trans-unit>
        <trans-unit id="f3f0c2f615e83e516256da21365a0381f69d219d" translate="yes" xml:space="preserve">
          <source>As with other PostgreSQL text search configuration files, the rules file must be stored in UTF-8 encoding. The data is automatically translated into the current database's encoding when loaded. Any lines containing untranslatable characters are silently ignored, so that rules files can contain rules that are not applicable in the current encoding.</source>
          <target state="translated">与其他PostgreSQL文本搜索配置文件一样,规则文件必须以UTF-8编码存储。数据加载时,会自动翻译成当前数据库的编码。任何包含不可翻译字符的行都会被默默忽略,因此规则文件可以包含在当前编码中不适用的规则。</target>
        </trans-unit>
        <trans-unit id="10502eec64e33ad71eb02c8495b055a53abfa416" translate="yes" xml:space="preserve">
          <source>As with the plain file-system-backup technique, this method can only support restoration of an entire database cluster, not a subset. Also, it requires a lot of archival storage: the base backup might be bulky, and a busy system will generate many megabytes of WAL traffic that have to be archived. Still, it is the preferred backup technique in many situations where high reliability is needed.</source>
          <target state="translated">与普通的文件系统备份技术一样,这种方法只能支持恢复整个数据库集群,而不是子集。另外,它还需要大量的归档存储:基础备份可能很笨重,一个繁忙的系统会产生许多兆字节的WAL流量,必须进行归档。不过,在很多需要高可靠性的情况下,它还是首选的备份技术。</target>
        </trans-unit>
        <trans-unit id="41912914d23f57d6b4964446c4839bcd6bf6e2ec" translate="yes" xml:space="preserve">
          <source>As with vacuuming for space recovery, frequent updates of statistics are more useful for heavily-updated tables than for seldom-updated ones. But even for a heavily-updated table, there might be no need for statistics updates if the statistical distribution of the data is not changing much. A simple rule of thumb is to think about how much the minimum and maximum values of the columns in the table change. For example, a &lt;code&gt;timestamp&lt;/code&gt; column that contains the time of row update will have a constantly-increasing maximum value as rows are added and updated; such a column will probably need more frequent statistics updates than, say, a column containing URLs for pages accessed on a website. The URL column might receive changes just as often, but the statistical distribution of its values probably changes relatively slowly.</source>
          <target state="translated">与空间恢复的清理一样，频繁更新统计信息对于频繁更新的表比对很少更新的表更有用。但是，即使对于大量更新的表，如果数据的统计分布变化不大，也可能不需要更新统计信息。一个简单的经验法则是考虑表中列的最小值和最大值有多少变化。例如， &lt;code&gt;timestamp&lt;/code&gt; 随着行的添加和更新，包含行更新时间的列的最大值将不断增加；此类列可能需要比包含网站上访问页面的URL的列更频繁的统计信息更新。URL列可能会经常接收更改，但是其值的统计分布可能相对缓慢地变化。</target>
        </trans-unit>
        <trans-unit id="25d8d489832d7110fbb67ed9e2a0a908cb5a5e5d" translate="yes" xml:space="preserve">
          <source>As you can see, in this skeleton we're dealing with a data type where &lt;code&gt;union(X, Y, Z) = union(union(X, Y), Z)&lt;/code&gt;. It's easy enough to support data types where this is not the case, by implementing the proper union algorithm in this GiST support method.</source>
          <target state="translated">如您所见，在此框架中，我们处理的数据类型为 &lt;code&gt;union(X, Y, Z) = union(union(X, Y), Z)&lt;/code&gt; 。通过在此GiST支持方法中实现适当的联合算法，可以轻松支持非这种情况的数据类型。</target>
        </trans-unit>
        <trans-unit id="bf9aec8aa0de7661a07d98a75f47c3b69757e7a1" translate="yes" xml:space="preserve">
          <source>As you see, pg_dump writes its result to the standard output. We will see below how this can be useful. While the above command creates a text file, pg_dump can create files in other formats that allow for parallelism and more fine-grained control of object restoration.</source>
          <target state="translated">正如你所看到的,pg_dump将其结果写入标准输出。下面我们将看到这一点是如何有用的。虽然上面的命令创建的是一个文本文件,pg_dump也可以创建其他格式的文件,这样就可以实现并行化和更精细的对象还原控制。</target>
        </trans-unit>
        <trans-unit id="21e1923806603d461ddac0e0413cc2a388550aac" translate="yes" xml:space="preserve">
          <source>As you see, the constraint definition comes after the data type, just like default value definitions. Default values and constraints can be listed in any order. A check constraint consists of the key word &lt;code&gt;CHECK&lt;/code&gt; followed by an expression in parentheses. The check constraint expression should involve the column thus constrained, otherwise the constraint would not make too much sense.</source>
          <target state="translated">如您所见，约束定义位于数据类型之后，就像默认值定义一样。默认值和约束可以任何顺序列出。检查约束由关键字 &lt;code&gt;CHECK&lt;/code&gt; 以及括号中的表达式组成。检查约束表达式应包含受约束的列，否则约束不会有太大意义。</target>
        </trans-unit>
        <trans-unit id="d1b9d2baec69327019075ccf63fb47f3a04b6635" translate="yes" xml:space="preserve">
          <source>As you see, the expression for the new value can refer to the existing value(s) in the row. We also left out the &lt;code&gt;WHERE&lt;/code&gt; clause. If it is omitted, it means that all rows in the table are updated. If it is present, only those rows that match the &lt;code&gt;WHERE&lt;/code&gt; condition are updated. Note that the equals sign in the &lt;code&gt;SET&lt;/code&gt; clause is an assignment while the one in the &lt;code&gt;WHERE&lt;/code&gt; clause is a comparison, but this does not create any ambiguity. Of course, the &lt;code&gt;WHERE&lt;/code&gt; condition does not have to be an equality test. Many other operators are available (see &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;Chapter 9&lt;/a&gt;). But the expression needs to evaluate to a Boolean result.</source>
          <target state="translated">如您所见，新值的表达式可以引用该行中的现有值。我们还省略了 &lt;code&gt;WHERE&lt;/code&gt; 子句。如果省略，则表示表中的所有行均已更新。如果存在，则仅更新那些与 &lt;code&gt;WHERE&lt;/code&gt; 条件匹配的行。请注意， &lt;code&gt;SET&lt;/code&gt; 子句中的等号是一个赋值，而 &lt;code&gt;WHERE&lt;/code&gt; 子句中的等号是一个比较，但这不会造成任何歧义。当然， &lt;code&gt;WHERE&lt;/code&gt; 条件不必是相等性测试。还有许多其他运算符可用（请参阅&lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;第9章&lt;/a&gt;）。但是表达式需要计算为布尔结果。</target>
        </trans-unit>
        <trans-unit id="439358cf5e5d4c690518e4e11abfb19b1e44a30e" translate="yes" xml:space="preserve">
          <source>As you see, the expression for the new value can refer to the existing value(s) in the row. We also left out the &lt;code&gt;WHERE&lt;/code&gt; clause. If it is omitted, it means that all rows in the table are updated. If it is present, only those rows that match the &lt;code&gt;WHERE&lt;/code&gt; condition are updated. Note that the equals sign in the &lt;code&gt;SET&lt;/code&gt; clause is an assignment while the one in the &lt;code&gt;WHERE&lt;/code&gt; clause is a comparison, but this does not create any ambiguity. Of course, the &lt;code&gt;WHERE&lt;/code&gt; condition does not have to be an equality test. Many other operators are available (see &lt;a href=&quot;https://www.postgresql.org/docs/13/functions.html&quot;&gt;Chapter 9&lt;/a&gt;). But the expression needs to evaluate to a Boolean result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="313a697ffb23a7210631919b2999246578e93b67" translate="yes" xml:space="preserve">
          <source>Aside from avoiding the time for the archiver or WAL sender to process the WAL data, doing this will actually make certain commands faster, because they are designed not to write WAL at all if &lt;code&gt;wal_level&lt;/code&gt; is &lt;code&gt;minimal&lt;/code&gt;. (They can guarantee crash safety more cheaply by doing an &lt;code&gt;fsync&lt;/code&gt; at the end than by writing WAL.) This applies to the following commands:</source>
          <target state="translated">除了避免时间存档或WAL发送处理WAL数据，这样做实际上会使某些命令更快，因为它们被设计完全不写WAL如果 &lt;code&gt;wal_level&lt;/code&gt; 是 &lt;code&gt;minimal&lt;/code&gt; 。（与编写WAL相比，通过在最后进行 &lt;code&gt;fsync&lt;/code&gt; 可以更便宜地保证崩溃安全。）这适用于以下命令：</target>
        </trans-unit>
        <trans-unit id="b1744fb0dcc66faea0f0e11e29ee96bb68e2530a" translate="yes" xml:space="preserve">
          <source>Aside from avoiding the time for the archiver or WAL sender to process the WAL data, doing this will actually make certain commands faster, because they do not to write WAL at all if &lt;code&gt;wal_level&lt;/code&gt; is &lt;code&gt;minimal&lt;/code&gt; and the current subtransaction (or top-level transaction) created or truncated the table or index they change. (They can guarantee crash safety more cheaply by doing an &lt;code&gt;fsync&lt;/code&gt; at the end than by writing WAL.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba62da50a0cd807fd06ac3427894951fdffc554f" translate="yes" xml:space="preserve">
          <source>Aside from preventing cycles, the array value is often useful in its own right as representing the &amp;ldquo;path&amp;rdquo; taken to reach any particular row.</source>
          <target state="translated">除了防止循环外，数组值通常还可以单独用来表示到达任何特定行的&amp;ldquo;路径&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="f08bd4c872560fdf37016b1456326d2f1f83a30c" translate="yes" xml:space="preserve">
          <source>Aside from the index's own internal consistency requirements, concurrent updates create issues about consistency between the parent table (the &lt;em&gt;heap&lt;/em&gt;) and the index. Because PostgreSQL separates accesses and updates of the heap from those of the index, there are windows in which the index might be inconsistent with the heap. We handle this problem with the following rules:</source>
          <target state="translated">除了索引本身的内部一致性要求之外，并发更新还会创建有关父表（&lt;em&gt;堆&lt;/em&gt;）与索引之间一致性的问题。因为PostgreSQL将堆的访问和更新与索引的访问和更新分开，所以在某些窗口中索引可能与堆不一致。我们使用以下规则处理此问题：</target>
        </trans-unit>
        <trans-unit id="66acedea6ec5e6c71ffc128f764e1116af5e0326" translate="yes" xml:space="preserve">
          <source>Assign a literal constant default value for the column &lt;code&gt;name&lt;/code&gt;, arrange for the default value of column &lt;code&gt;did&lt;/code&gt; to be generated by selecting the next value of a sequence object, and make the default value of &lt;code&gt;modtime&lt;/code&gt; be the time at which the row is inserted:</source>
          <target state="translated">分配该列的文本常量缺省值 &lt;code&gt;name&lt;/code&gt; ，安排列的默认值 &lt;code&gt;did&lt;/code&gt; 通过选择一个序列对象的下一个值来产生，并且使的默认值 &lt;code&gt;modtime&lt;/code&gt; 是在该行被插入的时间：</target>
        </trans-unit>
        <trans-unit id="1bfbe2935df02c420c8e520ec3e42a7fba80f23c" translate="yes" xml:space="preserve">
          <source>Assigns the specified &lt;em&gt;&lt;code&gt;weight&lt;/code&gt;&lt;/em&gt; to each element of the &lt;em&gt;&lt;code&gt;vector&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75a4d3134c8b9723881f294a52dd576fc9852c4b" translate="yes" xml:space="preserve">
          <source>Assigns the specified &lt;em&gt;&lt;code&gt;weight&lt;/code&gt;&lt;/em&gt; to elements of the &lt;em&gt;&lt;code&gt;vector&lt;/code&gt;&lt;/em&gt; that are listed in &lt;em&gt;&lt;code&gt;lexemes&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f079970016568a6988faea4629841a26d4520b05" translate="yes" xml:space="preserve">
          <source>Associated sort operator (zero if none)</source>
          <target state="translated">相关的排序运算符(如果没有,则为零</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="d530f867f7438d52f3d933c2185ee58e5795fb55" translate="yes" xml:space="preserve">
          <source>Assume a table like this:</source>
          <target state="translated">假设有一张这样的表格。</target>
        </trans-unit>
        <trans-unit id="d62cfe7fee7bb0995d8fe897df02204b5ae94b18" translate="yes" xml:space="preserve">
          <source>Assume we have dumped a database called &lt;code&gt;mydb&lt;/code&gt; into a custom-format dump file:</source>
          <target state="translated">假设我们已经将名为 &lt;code&gt;mydb&lt;/code&gt; 的数据库转储到了自定义格式的转储文件中：</target>
        </trans-unit>
        <trans-unit id="00714db2b04e92390b518c92e4ea170b71450adc" translate="yes" xml:space="preserve">
          <source>Assuming that there is a table called &lt;code&gt;table1&lt;/code&gt;, this command would retrieve all rows and all user-defined columns from &lt;code&gt;table1&lt;/code&gt;. (The method of retrieval depends on the client application. For example, the psql program will display an ASCII-art table on the screen, while client libraries will offer functions to extract individual values from the query result.) The select list specification &lt;code&gt;*&lt;/code&gt; means all columns that the table expression happens to provide. A select list can also select a subset of the available columns or make calculations using the columns. For example, if &lt;code&gt;table1&lt;/code&gt; has columns named &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt; (and perhaps others) you can make the following query:</source>
          <target state="translated">假设有一个表叫做 &lt;code&gt;table1&lt;/code&gt; 的，这个命令会从检索所有行和用户定义的列 &lt;code&gt;table1&lt;/code&gt; 。（检索方法取决于客户端应用程序。例如，psql程序将在屏幕上显示ASCII艺术表，而客户端库将提供从查询结果中提取单个值的功能。）选择列表规范 &lt;code&gt;*&lt;/code&gt; 表示表表达式恰好提供的所有列。选择列表还可以选择可用列的子集或使用这些列进行计算。例如，如果 &lt;code&gt;table1&lt;/code&gt; 包含名为 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 的列 （可能还有其他），您可以进行以下查询：</target>
        </trans-unit>
        <trans-unit id="89e7e252c06bfdf34cb9f5a168b455ee141acee7" translate="yes" xml:space="preserve">
          <source>Async. MM Repl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6a8e2732fbce126a0a797cdd1e90b4272d9f93c" translate="yes" xml:space="preserve">
          <source>Asynchronous Commit</source>
          <target state="translated">异步承诺</target>
        </trans-unit>
        <trans-unit id="1d15a4a3147c0af21cd5fba27008e02e7487f287" translate="yes" xml:space="preserve">
          <source>Asynchronous I/O depends on an effective &lt;code&gt;posix_fadvise&lt;/code&gt; function, which some operating systems lack. If the function is not present then setting this parameter to anything but zero will result in an error. On some operating systems (e.g., Solaris), the function is present but does not actually do anything.</source>
          <target state="translated">异步I / O取决于有效的 &lt;code&gt;posix_fadvise&lt;/code&gt; 函数，某些操作系统缺少该函数。如果该功能不存在，则将此参数设置为除零以外的任何值都将导致错误。在某些操作系统（例如Solaris）上，该功能存在但实际上不做任何事情。</target>
        </trans-unit>
        <trans-unit id="abb97da8205f09a691f99d2fcdea6f23dc61d65e" translate="yes" xml:space="preserve">
          <source>Asynchronous Multimaster Replication</source>
          <target state="translated">异步多主站复制</target>
        </trans-unit>
        <trans-unit id="00b2ec7d525c7895ab7759ef95defc6c17d534cd" translate="yes" xml:space="preserve">
          <source>Asynchronous commit introduces the risk of data loss. There is a short time window between the report of transaction completion to the client and the time that the transaction is truly committed (that is, it is guaranteed not to be lost if the server crashes). Thus asynchronous commit should not be used if the client will take external actions relying on the assumption that the transaction will be remembered. As an example, a bank would certainly not use asynchronous commit for a transaction recording an ATM's dispensing of cash. But in many scenarios, such as event logging, there is no need for a strong guarantee of this kind.</source>
          <target state="translated">异步提交引入了数据丢失的风险。从向客户端报告事务完成到事务真正提交(即保证在服务器崩溃时不会丢失)之间有一个很短的时间窗口。因此,如果客户端会依靠交易会被记住的假设而采取外部行动,就不应该使用异步提交。举个例子,银行肯定不会使用异步提交来记录ATM机发放现金的事务。但在很多场景下,比如事件记录,就不需要这种强有力的保证。</target>
        </trans-unit>
        <trans-unit id="d90c24d882782b103f7c8579885000885b06b013" translate="yes" xml:space="preserve">
          <source>Asynchronous commit provides behavior different from setting &lt;a href=&quot;runtime-config-wal#GUC-FSYNC&quot;&gt;fsync&lt;/a&gt; = off. &lt;code&gt;fsync&lt;/code&gt; is a server-wide setting that will alter the behavior of all transactions. It disables all logic within PostgreSQL that attempts to synchronize writes to different portions of the database, and therefore a system crash (that is, a hardware or operating system crash, not a failure of PostgreSQL itself) could result in arbitrarily bad corruption of the database state. In many scenarios, asynchronous commit provides most of the performance improvement that could be obtained by turning off &lt;code&gt;fsync&lt;/code&gt;, but without the risk of data corruption.</source>
          <target state="translated">异步提交提供的行为不同于将&lt;a href=&quot;runtime-config-wal#GUC-FSYNC&quot;&gt;fsync&lt;/a&gt; = off 设置的行为。 &lt;code&gt;fsync&lt;/code&gt; 是服务器范围的设置，它将更改所有事务的行为。它会禁用PostgreSQL中试图将写入同步到数据库不同部分的所有逻辑，因此系统崩溃（即，硬件或操作系统崩溃，而不是PostgreSQL本身发生故障）可能会导致数据库的任意严重损坏州。在许多情况下，异步提交可以提供大多数性能改进，可以通过关闭 &lt;code&gt;fsync&lt;/code&gt; 来获得，但没有数据损坏的风险。</target>
        </trans-unit>
        <trans-unit id="38108f139265527283b18b5d33c78a6ddd380598" translate="yes" xml:space="preserve">
          <source>At a more basic level, it is not clear that solving query optimization with a GA algorithm designed for TSP is appropriate. In the TSP case, the cost associated with any substring (partial tour) is independent of the rest of the tour, but this is certainly not true for query optimization. Thus it is questionable whether edge recombination crossover is the most effective mutation procedure.</source>
          <target state="translated">在更基本的层面上,用为TSP设计的GA算法解决查询优化并不清楚是否合适。在TSP的情况下,与任何子串(局部游)相关的成本都是独立于游的其他部分的,但对于查询优化来说,这肯定不是真的。因此,边缘重组交叉是否是最有效的突变程序是值得怀疑的。</target>
        </trans-unit>
        <trans-unit id="4d29cf5673a23d613acb6f0d1c22f5f4b6b78fcf" translate="yes" xml:space="preserve">
          <source>At all times, PostgreSQL maintains a &lt;em&gt;write ahead log&lt;/em&gt; (WAL) in the &lt;code&gt;pg_wal/&lt;/code&gt; subdirectory of the cluster's data directory. The log records every change made to the database's data files. This log exists primarily for crash-safety purposes: if the system crashes, the database can be restored to consistency by &amp;ldquo;replaying&amp;rdquo; the log entries made since the last checkpoint. However, the existence of the log makes it possible to use a third strategy for backing up databases: we can combine a file-system-level backup with backup of the WAL files. If recovery is needed, we restore the file system backup and then replay from the backed-up WAL files to bring the system to a current state. This approach is more complex to administer than either of the previous approaches, but it has some significant benefits:</source>
          <target state="translated">PostgreSQL始终在 &lt;code&gt;pg_wal/&lt;/code&gt; 维护一个预&lt;em&gt;写日志&lt;/em&gt;（WAL）。集群数据目录的子目录。日志记录了对数据库数据文件所做的所有更改。该日志主要用于崩溃安全目的：如果系统崩溃，则可以通过&amp;ldquo;重播&amp;rdquo;自上一个检查点以来创建的日志条目来恢复数据库的一致性。但是，日志的存在使得可以使用第三种策略来备份数据库：我们可以将文件系统级备份与WAL文件备份结合在一起。如果需要恢复，我们将还原文件系统备份，然后从备份的WAL文件中重播以使系统进入当前状态。与以前的任何一种方法相比，这种方法的管理更为复杂，但具有一些明显的好处：</target>
        </trans-unit>
        <trans-unit id="d0aa9f0f7a8b54305272b705ab4c8ce4332faa1e" translate="yes" xml:space="preserve">
          <source>At compile time, &lt;code&gt;transaction__start&lt;/code&gt; is converted to a macro called &lt;code&gt;TRACE_POSTGRESQL_TRANSACTION_START&lt;/code&gt; (notice the underscores are single here), which is available by including &lt;code&gt;pg_trace.h&lt;/code&gt;. Add the macro call to the appropriate location in the source code. In this case, it looks like the following:</source>
          <target state="translated">在编译时， &lt;code&gt;transaction__start&lt;/code&gt; 会转换为名为 &lt;code&gt;TRACE_POSTGRESQL_TRANSACTION_START&lt;/code&gt; 的宏（注意，这里的下划线是单个的），可以通过包含 &lt;code&gt;pg_trace.h&lt;/code&gt; 来使用它。将宏调用添加到源代码中的适当位置。在这种情况下，它看起来如下所示：</target>
        </trans-unit>
        <trans-unit id="1c05bc819458daf00162775e69bb6f11e3009ae1" translate="yes" xml:space="preserve">
          <source>At least as of version 5.1, it should not be necessary to do any special configuration for such parameters as &lt;code&gt;SHMMAX&lt;/code&gt;, as it appears this is configured to allow all memory to be used as shared memory. That is the sort of configuration commonly used for other databases such as DB/2.</source>
          <target state="translated">至少从5.1版开始，没有必要对诸如 &lt;code&gt;SHMMAX&lt;/code&gt; 之类的参数进行任何特殊配置，因为它似乎已配置为允许所有内存都用作共享内存。这种配置通常用于其他数据库，例如DB / 2。</target>
        </trans-unit>
        <trans-unit id="df036c0dc6f1685c583f36a683953e72b19d8691" translate="yes" xml:space="preserve">
          <source>At least one of &lt;code&gt;LEFTARG&lt;/code&gt; and &lt;code&gt;RIGHTARG&lt;/code&gt; must be defined. For binary operators, both must be defined. For right unary operators, only &lt;code&gt;LEFTARG&lt;/code&gt; should be defined, while for left unary operators only &lt;code&gt;RIGHTARG&lt;/code&gt; should be defined.</source>
          <target state="translated">必须至少定义 &lt;code&gt;LEFTARG&lt;/code&gt; 和 &lt;code&gt;RIGHTARG&lt;/code&gt; 之一。对于二进制运算符，必​​须同时定义两者。对于右一元运算符，仅应定义 &lt;code&gt;LEFTARG&lt;/code&gt; ，而对于左一元运算符，仅应定义 &lt;code&gt;RIGHTARG&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="81523154b2540393f2eb08b2e64447cb44f3b4fa" translate="yes" xml:space="preserve">
          <source>At least one of the following options must be specified to select an action:</source>
          <target state="translated">必须指定以下至少一个选项来选择行动:</target>
        </trans-unit>
        <trans-unit id="b72121826b7e4651c5d94f2436d0c7ffe3e3c260" translate="yes" xml:space="preserve">
          <source>At least one of these two things has to be ensured, or the PostgreSQL server will be very unreliable.</source>
          <target state="translated">这两点至少要保证其中之一,否则PostgreSQL服务器将非常不可靠。</target>
        </trans-unit>
        <trans-unit id="1571c46302d3bf43b10096af00c294a218c61c85" translate="yes" xml:space="preserve">
          <source>At least one row per subscription, showing information about the subscription workers. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-SUBSCRIPTION&quot;&gt;&lt;code&gt;pg_stat_subscription&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8eaf93cff7d6986839d33f973b6b2eb6f3e3612" translate="yes" xml:space="preserve">
          <source>At least one row per subscription, showing information about the subscription workers. See &lt;a href=&quot;monitoring-stats#PG-STAT-SUBSCRIPTION&quot;&gt;pg_stat_subscription&lt;/a&gt; for details.</source>
          <target state="translated">每个订阅至少有一行，显示有关订阅工作程序的信息。有关详细信息，请参见&lt;a href=&quot;monitoring-stats#PG-STAT-SUBSCRIPTION&quot;&gt;pg_stat_subscription&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7d5c8007175669495e5c5ec2b3f06db9f4615159" translate="yes" xml:space="preserve">
          <source>At present, any table used as the target of a data-modifying statement in &lt;code&gt;WITH&lt;/code&gt; must not have a conditional rule, nor an &lt;code&gt;ALSO&lt;/code&gt; rule, nor an &lt;code&gt;INSTEAD&lt;/code&gt; rule that expands to multiple statements.</source>
          <target state="translated">当前，任何在 &lt;code&gt;WITH&lt;/code&gt; 中用作数据修改语句目标的表都不得具有条件规则， &lt;code&gt;ALSO&lt;/code&gt; 规则，扩展为多个语句的 &lt;code&gt;INSTEAD&lt;/code&gt; 规则。</target>
        </trans-unit>
        <trans-unit id="ff0acb0e759b914c8ac0d92fbd4b06b6c52abe9f" translate="yes" xml:space="preserve">
          <source>At present, it's assumed that the sort order for an ordering operator is the default for the referenced operator family, i.e., &lt;code&gt;ASC NULLS LAST&lt;/code&gt;. This might someday be relaxed by adding additional columns to specify sort options explicitly.</source>
          <target state="translated">目前，假定排序运算符的排序顺序是所引用运算符系列的默认设置，即 &lt;code&gt;ASC NULLS LAST&lt;/code&gt; 。有朝一日，可以通过添加其他列来显式指定排序选项来放松这种情况。</target>
        </trans-unit>
        <trans-unit id="0da87b74c1c3af23d284a826d817211a0d50dbca" translate="yes" xml:space="preserve">
          <source>At present, the &lt;code&gt;soundex&lt;/code&gt;, &lt;code&gt;metaphone&lt;/code&gt;, &lt;code&gt;dmetaphone&lt;/code&gt;, and &lt;code&gt;dmetaphone_alt&lt;/code&gt; functions do not work well with multibyte encodings (such as UTF-8).</source>
          <target state="translated">目前， &lt;code&gt;soundex&lt;/code&gt; ， &lt;code&gt;metaphone&lt;/code&gt; ， &lt;code&gt;dmetaphone&lt;/code&gt; 和 &lt;code&gt;dmetaphone_alt&lt;/code&gt; 函数不适用于多字节编码（例如UTF-8）。</target>
        </trans-unit>
        <trans-unit id="a78a49f80284f34a995726cc4689e41d04fb4798" translate="yes" xml:space="preserve">
          <source>At present, this setting is supported only on Linux and Windows. The setting is ignored on other systems when set to &lt;code&gt;try&lt;/code&gt;.</source>
          <target state="translated">目前，仅Linux和Windows支持此设置。设置为 &lt;code&gt;try&lt;/code&gt; 时，在其他系统上将忽略该设置。</target>
        </trans-unit>
        <trans-unit id="965d1f5ec334a9d95d86fe2f92675d08806b41f2" translate="yes" xml:space="preserve">
          <source>At startup, the standby begins by restoring all WAL available in the archive location, calling &lt;code&gt;restore_command&lt;/code&gt;. Once it reaches the end of WAL available there and &lt;code&gt;restore_command&lt;/code&gt; fails, it tries to restore any WAL available in the &lt;code&gt;pg_wal&lt;/code&gt; directory. If that fails, and streaming replication has been configured, the standby tries to connect to the primary server and start streaming WAL from the last valid record found in archive or &lt;code&gt;pg_wal&lt;/code&gt;. If that fails or streaming replication is not configured, or if the connection is later disconnected, the standby goes back to step 1 and tries to restore the file from the archive again. This loop of retries from the archive, &lt;code&gt;pg_wal&lt;/code&gt;, and via streaming replication goes on until the server is stopped or failover is triggered by a trigger file.</source>
          <target state="translated">在启动时，备用数据库通过还原存档位置中所有可用的WAL并调用 &lt;code&gt;restore_command&lt;/code&gt; 来开始。一旦到达那里可用的WAL的结尾并且 &lt;code&gt;restore_command&lt;/code&gt; 失败，它将尝试恢复 &lt;code&gt;pg_wal&lt;/code&gt; 目录中可用的任何WAL 。如果失败，并且已经配置了流复制，则备用数据库尝试连接到主服务器，并从archive或 &lt;code&gt;pg_wal&lt;/code&gt; 中找到的最后一个有效记录开始流WAL 。如果失败或未配置流复制，或者如果以后断开了连接，则备用数据库将返回步骤1，并尝试再次从存档中还原文件。从档案 &lt;code&gt;pg_wal&lt;/code&gt; 重试此循环，并通过流复制继续进行，直到服务器停止或触发文件触发故障转移为止。</target>
        </trans-unit>
        <trans-unit id="55d8465dd064f760adc6de27f3c71c491c82a460" translate="yes" xml:space="preserve">
          <source>At the &lt;code&gt;REPEATABLE READ&lt;/code&gt; or &lt;code&gt;SERIALIZABLE&lt;/code&gt; transaction isolation level this would cause a serialization failure (with a &lt;code&gt;SQLSTATE&lt;/code&gt; of &lt;code&gt;'40001'&lt;/code&gt;), so there is no possibility of receiving rows out of order under these isolation levels.</source>
          <target state="translated">在 &lt;code&gt;REPEATABLE READ&lt;/code&gt; 或 &lt;code&gt;SERIALIZABLE&lt;/code&gt; 事务隔离级别，这将导致序列化失败（ &lt;code&gt;SQLSTATE&lt;/code&gt; 为 &lt;code&gt;'40001'&lt;/code&gt; ），因此在这些隔离级别下，不可能乱序接收行。</target>
        </trans-unit>
        <trans-unit id="f4f71998c9c0aa9a84a8100c70ee8a9266c4e5a9" translate="yes" xml:space="preserve">
          <source>At the beginning of the backup, a checkpoint needs to be performed on the source server. This can take some time (especially if the option &lt;code&gt;--checkpoint=fast&lt;/code&gt; is not used), during which pg_basebackup will appear to be idle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9934a1c03bcddc43aaddd8a50e8957f0b10bf33" translate="yes" xml:space="preserve">
          <source>At the beginning of the backup, a checkpoint needs to be written on the server the backup is taken from. Especially if the option &lt;code&gt;--checkpoint=fast&lt;/code&gt; is not used, this can take some time during which pg_basebackup will be appear to be idle.</source>
          <target state="translated">在备份开始时，需要在获取备份的服务器上写入一个检查点。特别是如果不使用 &lt;code&gt;--checkpoint=fast&lt;/code&gt; 选项，这可能会花费一些时间，在此期间pg_basebackup会显示为空闲。</target>
        </trans-unit>
        <trans-unit id="0a42b715d6522241c83704ed30aede2b52fb0a06" translate="yes" xml:space="preserve">
          <source>At the default &amp;ldquo;scale factor&amp;rdquo; of 1, the tables initially contain this many rows:</source>
          <target state="translated">在默认的&amp;ldquo;比例因子&amp;rdquo;为1时，表最初包含以下行：</target>
        </trans-unit>
        <trans-unit id="1c903746f8f0e8094ed1c641f98efb9a635313ed" translate="yes" xml:space="preserve">
          <source>At the end of each session, &lt;code&gt;UNLISTEN *&lt;/code&gt; is automatically executed.</source>
          <target state="translated">在每个会话结束时，将自动执行 &lt;code&gt;UNLISTEN *&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8cd262012c4caf6374bfb34cbb6a915df644c90b" translate="yes" xml:space="preserve">
          <source>At the end of recovery, &lt;code&gt;AccessExclusiveLocks&lt;/code&gt; held by prepared transactions will require twice the normal number of lock table entries. If you plan on running either a large number of concurrent prepared transactions that normally take &lt;code&gt;AccessExclusiveLocks&lt;/code&gt;, or you plan on having one large transaction that takes many &lt;code&gt;AccessExclusiveLocks&lt;/code&gt;, you are advised to select a larger value of &lt;code&gt;max_locks_per_transaction&lt;/code&gt;, perhaps as much as twice the value of the parameter on the primary server. You need not consider this at all if your setting of &lt;code&gt;max_prepared_transactions&lt;/code&gt; is 0.</source>
          <target state="translated">恢复结束时，准备好的事务持有的 &lt;code&gt;AccessExclusiveLocks&lt;/code&gt; 将需要锁表条目的正常数量的两倍。如果计划运行通常要使用 &lt;code&gt;AccessExclusiveLocks&lt;/code&gt; 的大量并发准备事务，或者计划要使用很多 &lt;code&gt;AccessExclusiveLocks&lt;/code&gt; 的大型事务，则建议选择较大的 &lt;code&gt;max_locks_per_transaction&lt;/code&gt; 值，可能是最大值的两倍。主服务器上的参数。如果您将 &lt;code&gt;max_prepared_transactions&lt;/code&gt; 设置为0 ，则完全不需要考虑这一点。</target>
        </trans-unit>
        <trans-unit id="14547baffec9c8ba5963d60806059645bd69fca9" translate="yes" xml:space="preserve">
          <source>At the prompt, the user can type in SQL commands. Ordinarily, input lines are sent to the server when a command-terminating semicolon is reached. An end of line does not terminate a command. Thus commands can be spread over several lines for clarity. If the command was sent and executed without error, the results of the command are displayed on the screen.</source>
          <target state="translated">在提示符下,用户可以输入SQL命令。通常情况下,当到达命令结束的分号时,输入行会被发送到服务器。行结束不会终止一个命令。因此,为了清晰起见,命令可以分布在几行中。如果命令被发送并无误地执行,命令的结果将显示在屏幕上。</target>
        </trans-unit>
        <trans-unit id="a73b24b0f045657de48b1ab740f05e1e597825d0" translate="yes" xml:space="preserve">
          <source>At the same time, &lt;code&gt;strict_word_similarity(text, text)&lt;/code&gt; selects an extent of words in the second string. In the example above, &lt;code&gt;strict_word_similarity(text, text)&lt;/code&gt; would select the extent of a single word &lt;code&gt;'words'&lt;/code&gt;, whose set of trigrams is &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rds&quot;,&quot;ds &quot;}&lt;/code&gt;.</source>
          <target state="translated">同时， &lt;code&gt;strict_word_similarity(text, text)&lt;/code&gt; 选择第二个字符串中单词的范围。在上面的示例中， &lt;code&gt;strict_word_similarity(text, text)&lt;/code&gt; 将选择单个单词 &lt;code&gt;'words'&lt;/code&gt; 的范围，该单词的字母组合为 &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rds&quot;,&quot;ds &quot;}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d1227060ad6250b9807827bf5fbb82f644935b87" translate="yes" xml:space="preserve">
          <source>At the same time, &lt;code&gt;strict_word_similarity&lt;/code&gt; selects an extent of words in the second string. In the example above, &lt;code&gt;strict_word_similarity&lt;/code&gt; would select the extent of a single word &lt;code&gt;'words'&lt;/code&gt;, whose set of trigrams is &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rds&quot;,&quot;ds &quot;}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="416a07de78793e22bb0ac6ecdc4a78f4b476ae54" translate="yes" xml:space="preserve">
          <source>At the time of creation, all existing heap pages are scanned and a summary index tuple is created for each range, including the possibly-incomplete range at the end. As new pages are filled with data, page ranges that are already summarized will cause the summary information to be updated with data from the new tuples. When a new page is created that does not fall within the last summarized range, that range does not automatically acquire a summary tuple; those tuples remain unsummarized until a summarization run is invoked later, creating initial summaries. This process can be invoked manually using the &lt;code&gt;brin_summarize_range(regclass, bigint)&lt;/code&gt; or &lt;code&gt;brin_summarize_new_values(regclass)&lt;/code&gt; functions; automatically when &lt;code&gt;VACUUM&lt;/code&gt; processes the table; or by automatic summarization executed by autovacuum, as insertions occur. (This last trigger is disabled by default and can be enabled with the &lt;code&gt;autosummarize&lt;/code&gt; parameter.) Conversely, a range can be de-summarized using the &lt;code&gt;brin_desummarize_range(regclass, bigint)&lt;/code&gt; function, which is useful when the index tuple is no longer a very good representation because the existing values have changed.</source>
          <target state="translated">在创建时，将扫描所有现有的堆页面，并为每个范围（包括最后可能不完整的范围）创建一个摘要索引元组。当新页面充满数据时，已经汇总的页面范围将导致汇总信息被来自新元组的数据更新。当创建的新页面不在上一个汇总范围内时，该范围不会自动获取汇总元组；这些元组将保持未摘要状态，直到稍后调用摘要运行以创建初始摘要。可以使用 &lt;code&gt;brin_summarize_range(regclass, bigint)&lt;/code&gt; 或 &lt;code&gt;brin_summarize_new_values(regclass)&lt;/code&gt; 函数手动调用此过程。 &lt;code&gt;VACUUM&lt;/code&gt; 时自动处理表；或通过自动真空执行自动汇总（发生插入）。（最后一个触发器默认情况下处于禁用状态，并且可以使用 &lt;code&gt;autosummarize&lt;/code&gt; 参数启用。）相反，可以使用 &lt;code&gt;brin_desummarize_range(regclass, bigint)&lt;/code&gt; 函数对范围进行汇总，当索引元组不再是一个很好的索引时，该功能将非常有用表示形式，因为现有值已更改。</target>
        </trans-unit>
        <trans-unit id="570ab49c8c4979d8f2b45f71407d683f61c768c4" translate="yes" xml:space="preserve">
          <source>At this point &lt;code&gt;pg_proc.dat&lt;/code&gt; has all three columns, &lt;code&gt;prokind&lt;/code&gt;, &lt;code&gt;proisagg&lt;/code&gt;, and &lt;code&gt;proiswindow&lt;/code&gt;, though they will appear only in rows where they have non-default values.</source>
          <target state="translated">此时， &lt;code&gt;pg_proc.dat&lt;/code&gt; 具有所有三列 &lt;code&gt;prokind&lt;/code&gt; ， &lt;code&gt;proisagg&lt;/code&gt; 和 &lt;code&gt;proiswindow&lt;/code&gt; ，尽管它们仅出现在具有非默认值的行中。</target>
        </trans-unit>
        <trans-unit id="394da4678018ab888c36788be82e3560af3396a8" translate="yes" xml:space="preserve">
          <source>At this point, you will have an index on the &lt;code&gt;t&lt;/code&gt; column that you can use for similarity searching. A typical query is</source>
          <target state="translated">此时，您将在 &lt;code&gt;t&lt;/code&gt; 列上有一个索引，可用于相似性搜索。一个典型的查询是</target>
        </trans-unit>
        <trans-unit id="2a3a5c5f47d6770989533a4fd46849cfebf7e2e9" translate="yes" xml:space="preserve">
          <source>At this writing, there are several limitations of the continuous archiving technique. These will probably be fixed in future releases:</source>
          <target state="translated">在写这篇文章时,连续存档技术有几个限制。这些限制可能会在未来的版本中得到修正。</target>
        </trans-unit>
        <trans-unit id="41dded417052424bdcf3c39f6c8664147fae6806" translate="yes" xml:space="preserve">
          <source>Atom</source>
          <target state="translated">Atom</target>
        </trans-unit>
        <trans-unit id="f3023cb8188912c321e51f84008e15af7ab75428" translate="yes" xml:space="preserve">
          <source>Atomic</source>
          <target state="translated">Atomic</target>
        </trans-unit>
        <trans-unit id="7dfdf2c7a48eb8aa0595b9fdbbeea1555b65d328" translate="yes" xml:space="preserve">
          <source>Atomicity</source>
          <target state="translated">Atomicity</target>
        </trans-unit>
        <trans-unit id="cfaa3dc03c49871e78cddda27fc42c3f092dc0c4" translate="yes" xml:space="preserve">
          <source>Attach a comment to the table &lt;code&gt;mytable&lt;/code&gt;:</source>
          <target state="translated">在表 &lt;code&gt;mytable&lt;/code&gt; 上添加注释：</target>
        </trans-unit>
        <trans-unit id="b30d15695b4486ee3edc48c2da787bd31caa82e5" translate="yes" xml:space="preserve">
          <source>Attaching a partition acquires a &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock on the parent table, in addition to &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; locks on the table to be attached and on the default partition (if any).</source>
          <target state="translated">除了要附加的表和默认分区（如果有）上的 &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; 锁之外，附加分区还需要在父表上获得 &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; 锁。</target>
        </trans-unit>
        <trans-unit id="d4f51e4421d7c33f901d2846a5f5963016f01207" translate="yes" xml:space="preserve">
          <source>Attempt to allow server crashes to produce core files, on platforms where this is possible, by lifting any soft resource limit placed on core files. This is useful in debugging or diagnosing problems by allowing a stack trace to be obtained from a failed server process.</source>
          <target state="translated">在可能的平台上,通过取消对核心文件的软资源限制,尝试允许服务器崩溃产生核心文件。这对调试或诊断问题很有用,因为可以从失败的服务器进程中获得堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="22d313995c5aa4824bbbe6a43fa47548d5dd9981" translate="yes" xml:space="preserve">
          <source>Attempt to insert a new stock item along with the quantity of stock. If the item already exists, instead update the stock count of the existing item. To do this without failing the entire transaction, use savepoints:</source>
          <target state="translated">试图插入一个新的库存项目以及库存数量。如果该项目已经存在,则更新现有项目的库存数量。为了不使整个交易失败,请使用保存点。</target>
        </trans-unit>
        <trans-unit id="77a267ab017550f3c7b55ed8bceaa27e998a453f" translate="yes" xml:space="preserve">
          <source>Attempt to terminate all existing connections to the target database before dropping it. See &lt;a href=&quot;sql-dropdatabase&quot;&gt;DROP DATABASE&lt;/a&gt; for more information on this option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="918622fae6a483ce282b6f622cf8bcadbed1c7e1" translate="yes" xml:space="preserve">
          <source>Attempt to terminate all existing connections to the target database. It doesn't terminate if prepared transactions, active logical replication slots or subscriptions are present in the target database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76eb27398e988091546915b412edd431f3061249" translate="yes" xml:space="preserve">
          <source>Attempting to drop a table that does not exist is an error. Nevertheless, it is common in SQL script files to unconditionally try to drop each table before creating it, ignoring any error messages, so that the script works whether or not the table exists. (If you like, you can use the &lt;code&gt;DROP TABLE IF EXISTS&lt;/code&gt; variant to avoid the error messages, but this is not standard SQL.)</source>
          <target state="translated">尝试删除不存在的表是一个错误。但是，在SQL脚本文件中，常见的做法是在创建表之前无条件地尝试删除每个表，而忽略任何错误消息，以使脚本无论表是否存在都可以工作。（如果愿意，可以使用 &lt;code&gt;DROP TABLE IF EXISTS&lt;/code&gt; 变量来避免出现错误消息，但这不是标准的SQL。）</target>
        </trans-unit>
        <trans-unit id="a0d00292b426c90d6f3e1dbff7f81bbe2e552240" translate="yes" xml:space="preserve">
          <source>Attempting to enter a date using a mixture of ISO 8601 week-numbering fields and Gregorian date fields is nonsensical, and will cause an error. In the context of an ISO 8601 week-numbering year, the concept of a &amp;ldquo;month&amp;rdquo; or &amp;ldquo;day of month&amp;rdquo; has no meaning. In the context of a Gregorian year, the ISO week has no meaning.</source>
          <target state="translated">尝试使用ISO 8601周编号字段和公历日期字段的混合输入日期是没有意义的，并且会导致错误。在ISO 8601周编号年份的上下文中，&amp;ldquo;月&amp;rdquo;或&amp;ldquo;月中的某天&amp;rdquo;的概念没有意义。在公历年份中，ISO周没有意义。</target>
        </trans-unit>
        <trans-unit id="a086d942884a301b827479029ba19c2746237425" translate="yes" xml:space="preserve">
          <source>Attribute</source>
          <target state="translated">Attribute</target>
        </trans-unit>
        <trans-unit id="c85e1c86ef58d9df3e2aa30f481d2a46d06ccc08" translate="yes" xml:space="preserve">
          <source>Attribute to match against the user name in the search when doing search+bind authentication. If no attribute is specified, the &lt;code&gt;uid&lt;/code&gt; attribute will be used.</source>
          <target state="translated">执行搜索+绑定身份验证时与搜索中的用户名匹配的属性。如果未指定任何属性，则将使用 &lt;code&gt;uid&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="666a0c222579ebcb139d2bf4bc0c9f0b94222439" translate="yes" xml:space="preserve">
          <source>Attribute-level foreign data wrapper options, as &amp;ldquo;keyword=value&amp;rdquo; strings</source>
          <target state="translated">属性级别的外部数据包装器选项，如&amp;ldquo; keyword = value&amp;rdquo;字符串</target>
        </trans-unit>
        <trans-unit id="81543c9a145dd6869d89d4e634466bddb425f66f" translate="yes" xml:space="preserve">
          <source>Attribute-level options, as &amp;ldquo;keyword=value&amp;rdquo; strings</source>
          <target state="translated">属性级别选项，如&amp;ldquo;关键字=值&amp;rdquo;字符串</target>
        </trans-unit>
        <trans-unit id="75629af51d7c7f120dbb5b462013bfa48af33285" translate="yes" xml:space="preserve">
          <source>Aug</source>
          <target state="translated">Aug</target>
        </trans-unit>
        <trans-unit id="69d97c5797dc7d211aaa4e9229db5c8466d4edef" translate="yes" xml:space="preserve">
          <source>August</source>
          <target state="translated">August</target>
        </trans-unit>
        <trans-unit id="9ac07ce6cd52d678fbe1229a683f5eafa07e3b6a" translate="yes" xml:space="preserve">
          <source>Authenticate using SSL client certificates. See &lt;a href=&quot;auth-cert&quot;&gt;Section 20.12&lt;/a&gt; for details.</source>
          <target state="translated">使用SSL客户端证书进行身份验证。有关详细信息，请参见&lt;a href=&quot;auth-cert&quot;&gt;第20.12节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b62091287fb724791ca34488a0ab2a9fac4a1e4d" translate="yes" xml:space="preserve">
          <source>Authenticate using a RADIUS server. See &lt;a href=&quot;auth-radius&quot;&gt;Section 20.11&lt;/a&gt; for details.</source>
          <target state="translated">使用RADIUS服务器进行身份验证。有关详细信息，请参见&lt;a href=&quot;auth-radius&quot;&gt;第20.11节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="82054cdf870e919ceb8345be400ef8ccd343353b" translate="yes" xml:space="preserve">
          <source>Authenticate using an LDAP server. See &lt;a href=&quot;auth-ldap&quot;&gt;Section 20.10&lt;/a&gt; for details.</source>
          <target state="translated">使用LDAP服务器进行身份验证。有关详细信息，请参见&lt;a href=&quot;auth-ldap&quot;&gt;第20.10节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="55d3191d61e9daf8a3de6d8c5454a6099b6e7e03" translate="yes" xml:space="preserve">
          <source>Authenticate using the BSD Authentication service provided by the operating system. See &lt;a href=&quot;auth-bsd&quot;&gt;Section 20.14&lt;/a&gt; for details.</source>
          <target state="translated">使用操作系统提供的BSD身份验证服务进行身份验证。有关详细信息，请参见&lt;a href=&quot;auth-bsd&quot;&gt;第20.14节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="99ad70b6f56fd0c0d9729bfab969bd959ae5fb53" translate="yes" xml:space="preserve">
          <source>Authenticate using the Pluggable Authentication Modules (PAM) service provided by the operating system. See &lt;a href=&quot;auth-pam&quot;&gt;Section 20.13&lt;/a&gt; for details.</source>
          <target state="translated">使用操作系统提供的可插拔身份验证模块（PAM）服务进行身份验证。有关详细信息，请参见&lt;a href=&quot;auth-pam&quot;&gt;第20.13节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6ad4053a30971cdd0eca5d90cab892f9f383ba3e" translate="yes" xml:space="preserve">
          <source>Authentication Methods</source>
          <target state="translated">认证方法</target>
        </trans-unit>
        <trans-unit id="98fb3925f64e0642987c3e7beb38bbfbcaa16576" translate="yes" xml:space="preserve">
          <source>Authentication Problems</source>
          <target state="translated">认证问题</target>
        </trans-unit>
        <trans-unit id="bcf5b4f7c9dc716b472b6e8b3f05c043e93a5b63" translate="yes" xml:space="preserve">
          <source>Authentication failures and related problems generally manifest themselves through error messages like the following:</source>
          <target state="translated">认证失败及相关问题一般通过以下错误信息表现出来。</target>
        </trans-unit>
        <trans-unit id="4a2641463bda57c970dcaba44cead46536e41155" translate="yes" xml:space="preserve">
          <source>Authentication method</source>
          <target state="translated">认证方式</target>
        </trans-unit>
        <trans-unit id="5fda23d62015b99fb2a9f86b38bcdf2bdf7609c8" translate="yes" xml:space="preserve">
          <source>Author</source>
          <target state="translated">Author</target>
        </trans-unit>
        <trans-unit id="ae017ff45a4a035cd29d47f616f68029f16fd0e1" translate="yes" xml:space="preserve">
          <source>Automatic Vacuuming</source>
          <target state="translated">自动吸尘</target>
        </trans-unit>
        <trans-unit id="7c977c91d67cb7d94506d78b8621aa22f728f9df" translate="yes" xml:space="preserve">
          <source>Automatic verification of the structural integrity of indexes plays a role in the general testing of new or proposed PostgreSQL features that could plausibly allow a logical inconsistency to be introduced. Verification of table structure and associated visibility and transaction status information plays a similar role. One obvious testing strategy is to call &lt;code&gt;amcheck&lt;/code&gt; functions continuously when running the standard regression tests. See &lt;a href=&quot;https://www.postgresql.org/docs/12/regress-run.html&quot;&gt;Section 32.1&lt;/a&gt; for details on running the tests.</source>
          <target state="translated">索引结构完整性的自动验证在新的或提议的PostgreSQL功能的常规测试中扮演着重要的角色，这些功能有可能允许引入逻辑上的不一致。验证表结构以及相关的可见性和交易状态信息的作用相似。一种明显的测试策略是在运行标准回归测试时连续调用 &lt;code&gt;amcheck&lt;/code&gt; 函数。有关运行测试的详细信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/regress-run.html&quot;&gt;第32.1节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dd9a137c5bedfde09ac590ac67aee8327d8ab3c7" translate="yes" xml:space="preserve">
          <source>Automatic verification of the structural integrity of indexes plays a role in the general testing of new or proposed PostgreSQL features that could plausibly allow a logical inconsistency to be introduced. Verification of table structure and associated visibility and transaction status information plays a similar role. One obvious testing strategy is to call &lt;code&gt;amcheck&lt;/code&gt; functions continuously when running the standard regression tests. See &lt;a href=&quot;https://www.postgresql.org/docs/13/regress-run.html&quot;&gt;Section 32.1&lt;/a&gt; for details on running the tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="820a99cec2958e050680c6f99db97b790304fa53" translate="yes" xml:space="preserve">
          <source>Automatically drop objects (tables, functions, etc.) that are contained in the schema, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">自动删除架构中包含的对象（表，函数等），然后自动删除依赖于这些对象的所有对象（请参见&lt;a href=&quot;ddl-depend&quot;&gt;第5.14节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="7996658087a343e0aa2b3cf4b1db038fe35de48f" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the access method (such as operator classes, operator families, and indexes), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">自动删除依赖于访问方法的对象（例如，运算符类，运算符系列和索引），并依次删除所有依赖于那些对象的对象（请参阅&lt;a href=&quot;ddl-depend&quot;&gt;第5.14节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="baccb8c23deca0c76a8a79a9c5f9953c38de8bc4" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the affected objects, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">自动删除依赖于受影响对象的对象，并依次删除依赖于那些对象的所有对象（请参见&lt;a href=&quot;ddl-depend&quot;&gt;第5.14节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="38e895c6814216f5b3e9484010061f8b91dc249f" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the aggregate function (such as views using it), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">自动删除依赖于聚合函数的对象（例如，使用该函数的视图），并依次删除依赖于这些对象的所有对象（请参见&lt;a href=&quot;ddl-depend&quot;&gt;第5.14节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="abc0b1d37273a9737a10dc3892acfa6c92fe5d93" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the collation, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">自动删除依赖于排序规则的对象，然后自动丢弃依赖于那些对象的所有对象（请参见&lt;a href=&quot;ddl-depend&quot;&gt;第5.14节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="745a5a5b00e94aac1eab4bd026b0c3eb4c8c446e" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the constraint, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">自动删除依赖于约束的对象，并依次删除依赖于那些对象的所有对象（请参见&lt;a href=&quot;ddl-depend&quot;&gt;第5.14节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="e6ef4a74296e736f065e1732a22c73d138658014" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the domain (such as table columns), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">自动删除依赖于域的对象（例如表列），并依次删除依赖于这些对象的所有对象（请参见&lt;a href=&quot;ddl-depend&quot;&gt;第5.14节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="660862c86777512d4fcfc8d0ae2ba2705d79fc1b" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the dropped column or constraint (for example, views referencing the column), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">自动删除依赖于所删除的列或约束的对象（例如，引用该列的视图），并依次删除所有依赖于那些对象的对象（请参阅&lt;a href=&quot;ddl-depend&quot;&gt;第5.14节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ce7ac7937862e4e4126fdf7e2c5724e3de1e23e6" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the extension, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">自动删除依赖于扩展名的对象，然后丢弃依赖于这些对象的所有对象（请参见&lt;a href=&quot;ddl-depend&quot;&gt;第5.14节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6bd522b5b8653034eb0b6145f2ce2e5dacb2cba0" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the foreign table (such as views), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">自动删除依赖于外部表的对象（例如视图），然后自动删除依赖于那些对象的所有对象（请参见&lt;a href=&quot;ddl-depend&quot;&gt;第5.14节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a988e483f220bf7f0532dd68b502a2b7076edf0a" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the foreign-data wrapper (such as foreign tables and servers), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">自动删除依赖于外部数据包装器的对象（例如，外部表和服务器），然后自动删除依赖于那些对象的所有对象（请参阅&lt;a href=&quot;ddl-depend&quot;&gt;第5.14节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="e27007381181e414122b1ae56cdfd1a6d1dab2ad" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the function (such as operators or triggers), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">自动删除依赖于该功能的对象（例如运算符或触发器），并依次删除所有依赖于那些对象的对象（请参阅&lt;a href=&quot;ddl-depend&quot;&gt;第5.14节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1b9c92f0f554dcfb206e40bfd135fab8fe00e7e2" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the index, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">自动删除依赖于索引的对象，并依次删除依赖于那些对象的所有对象（请参见&lt;a href=&quot;ddl-depend&quot;&gt;第5.14节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="bcb27d2712f35ddb733c1f98ff51f21d7d424aaa" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the language (such as functions in the language), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">自动删除依赖于该语言的对象（例如该语言中的函数），并依次删除所有依赖于那些对象的对象（请参阅&lt;a href=&quot;ddl-depend&quot;&gt;第5.14节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2f6d0323ae070e0fb6a9170cf88c29d107b33c44" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the materialized view (such as other materialized views, or regular views), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">自动放置依赖于实例化视图的对象（例如其他实例化视图或常规视图），然后自动放置依赖于那些对象的所有对象（请参阅&lt;a href=&quot;ddl-depend&quot;&gt;第5.14节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="bf9e6848c526fa45713feaa1a3f98743157a4884" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the operator (such as views using it), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">自动删除依赖于运算符的对象（例如，使用该对象的视图），并依次删除所有依赖于这些对象的对象（请参见&lt;a href=&quot;ddl-depend&quot;&gt;第5.14节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="cbbaf53e6f678b4c8cf5eec8a71b6a7c2ee4f9ea" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the operator class (such as indexes), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">自动删除依赖于运算符类的对象（例如索引），并依次删除所有依赖于那些对象的对象（请参见&lt;a href=&quot;ddl-depend&quot;&gt;第5.14节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="eb5de09991d91e56b807fa44deb753015952ad1e" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the operator family, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">自动删除依赖于操作员系列的对象，并依次删除依赖于那些对象的所有对象（请参见&lt;a href=&quot;ddl-depend&quot;&gt;第5.14节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="e459a28af6e31c3e35e65f3a6c2487c577b6fa29" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the procedure, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">自动删除依赖于该过程的对象，并依次删除依赖于那些对象的所有对象（请参见&lt;a href=&quot;ddl-depend&quot;&gt;第5.14节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b0c32bf11160fbc2a809f14fb04d0b4471ad9003" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the rule, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">自动删除依赖于规则的对象，并依次删除依赖于那些对象的所有对象（请参见&lt;a href=&quot;ddl-depend&quot;&gt;第5.14节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="de054c43bd92a23004c72d1888e8a17d538b0b78" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the sequence, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">自动删除依赖于序列的对象，并依次删除依赖于那些对象的所有对象（请参见&lt;a href=&quot;ddl-depend&quot;&gt;第5.14节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="bb69e1d5d516109b91608eb01c14e7c1738edbdf" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the server (such as user mappings), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">自动删除依赖于服务器的对象（例如用户映射），并依次删除所有依赖于那些对象的对象（请参阅&lt;a href=&quot;ddl-depend&quot;&gt;第5.14节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="40e6c61745089f774dd3e41d1dc840b568fe3b30" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the table (such as views), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">自动删除依赖于表的对象（例如视图），然后自动删除依赖于那些对象的所有对象（请参见&lt;a href=&quot;ddl-depend&quot;&gt;第5.14节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="53f104557d2e3eaa82997c5ded39fd7f6ba0b2a2" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the text search configuration, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">自动删除依赖于文本搜索配置的对象，并依次删除依赖于那些对象的所有对象（请参见&lt;a href=&quot;ddl-depend&quot;&gt;第5.14节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="c790e11a342e191d26db4cfa94c2202262cf7507" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the text search dictionary, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">自动删除依赖于文本搜索字典的对象，并依次删除依赖于那些对象的所有对象（请参见&lt;a href=&quot;ddl-depend&quot;&gt;第5.14节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="5ce0aa99a0b061d5935384944655cf0dc2b98983" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the text search parser, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">自动删除依赖于文本搜索解析器的对象，并依次删除所有依赖于那些对象的对象（请参见&lt;a href=&quot;ddl-depend&quot;&gt;第5.14节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="24a3aa8af1a85db5b902e0817649894b200120f5" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the text search template, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">自动删除依赖于文本搜索模板的对象，并依次删除依赖于那些对象的所有对象（请参阅&lt;a href=&quot;ddl-depend&quot;&gt;第5.14节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="52e34eb24e551596b0414271aef19a7a92f41187" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the transform, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">自动删除依赖于转换的对象，并依次删除依赖于那些对象的所有对象（请参见&lt;a href=&quot;ddl-depend&quot;&gt;第5.14节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="5430ece32ada38350ecf74986f0bbc942e6e3cfc" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the trigger, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">自动删除依赖于触发器的对象，并依次删除所有依赖于那些对象的对象（请参阅&lt;a href=&quot;ddl-depend&quot;&gt;第5.14节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="946c18a9096115a846e5ed6451faa1e38fe8c835" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the type (such as table columns, functions, and operators), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">自动删除依赖于类型的对象（例如表列，函数和运算符），然后自动删除依赖于那些对象的所有对象（请参见&lt;a href=&quot;ddl-depend&quot;&gt;第5.14节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3d1c86e5f361718e066619a34ceb6e0c61659055" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the view (such as other views), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">自动删除依赖于该视图的对象（例如其他视图），并依次删除所有依赖于那些对象的对象（请参见&lt;a href=&quot;ddl-depend&quot;&gt;第5.14节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3b54adcbf7578fd1e32a97c6d995480099f4e4ee" translate="yes" xml:space="preserve">
          <source>Automatically generate certain C code from SQL code. Currently, this works for &lt;code&gt;EXEC SQL TYPE&lt;/code&gt;.</source>
          <target state="translated">从SQL代码自动生成某些C代码。目前，这适用于 &lt;code&gt;EXEC SQL TYPE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02a28684ac310395befcd622074bd92c8287b214" translate="yes" xml:space="preserve">
          <source>Automatically install any extensions that this extension depends on that are not already installed. Their dependencies are likewise automatically installed, recursively. The &lt;code&gt;SCHEMA&lt;/code&gt; clause, if given, applies to all extensions that get installed this way. Other options of the statement are not applied to automatically-installed extensions; in particular, their default versions are always selected.</source>
          <target state="translated">自动安装此扩展依赖的所有扩展（尚未安装）。它们的依存关系同样会递归自动安装。该 &lt;code&gt;SCHEMA&lt;/code&gt; 条款，如果给，适用于获得这种方式安装的所有扩展。该语句的其他选项不适用于自动安装的扩展程序；特别是，始终选择其默认版本。</target>
        </trans-unit>
        <trans-unit id="82114421ee75a29b216b45460b9e22d194a04f14" translate="yes" xml:space="preserve">
          <source>Automatically propagate the operation to typed tables of the type being altered, and their descendants.</source>
          <target state="translated">自动将操作传播到被修改的类型的类型表,以及它们的子代。</target>
        </trans-unit>
        <trans-unit id="8cbbea802a2969bf6986433c47646c8510fbfd3b" translate="yes" xml:space="preserve">
          <source>Automatically restart sequences owned by columns of the truncated table(s).</source>
          <target state="translated">自动重新启动被截断的表的列所拥有的序列。</target>
        </trans-unit>
        <trans-unit id="5642bfdf85a2050b70397bd1e7d1e3fa447f8560" translate="yes" xml:space="preserve">
          <source>Automatically stop replication and exit with normal exit status 0 when receiving reaches the specified LSN.</source>
          <target state="translated">当接收到指定LSN时,自动停止复制并以正常退出状态0退出。</target>
        </trans-unit>
        <trans-unit id="39275b6e09e38bef3ed571db2ef1da8d2f155a4e" translate="yes" xml:space="preserve">
          <source>Automatically truncate all tables that have foreign-key references to any of the named tables, or to any tables added to the group due to &lt;code&gt;CASCADE&lt;/code&gt;.</source>
          <target state="translated">自动截断所有对任何已命名表或因 &lt;code&gt;CASCADE&lt;/code&gt; 而添加到组的表具有外键引用的表。</target>
        </trans-unit>
        <trans-unit id="1e085180a439697544c8e28954b594a79f078a9d" translate="yes" xml:space="preserve">
          <source>Autovacuum (process)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63b02d90144047f7b0ae09ab6bb39285e944deab" translate="yes" xml:space="preserve">
          <source>Autovacuum is not active during recovery. It will start normally at the end of recovery.</source>
          <target state="translated">在恢复期间,自动吸尘不活跃。它将在恢复结束时正常启动。</target>
        </trans-unit>
        <trans-unit id="d7773c835487baf5b5c0ec83d176517e017c8f8a" translate="yes" xml:space="preserve">
          <source>Autovacuum worker or launcher waiting to update or read the current state of autovacuum workers.</source>
          <target state="translated">自动吸尘工或发射器等待更新或读取自动吸尘工的当前状态。</target>
        </trans-unit>
        <trans-unit id="4aa1cd4d844c5afaaef04eccf35c0da21524cd29" translate="yes" xml:space="preserve">
          <source>Autovacuum workers generally don't block other commands. If a process attempts to acquire a lock that conflicts with the &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock held by autovacuum, lock acquisition will interrupt the autovacuum. For conflicting lock modes, see &lt;a href=&quot;explicit-locking#TABLE-LOCK-COMPATIBILITY&quot;&gt;Table 13.2&lt;/a&gt;. However, if the autovacuum is running to prevent transaction ID wraparound (i.e., the autovacuum query name in the &lt;code&gt;pg_stat_activity&lt;/code&gt; view ends with &lt;code&gt;(to prevent wraparound)&lt;/code&gt;), the autovacuum is not automatically interrupted.</source>
          <target state="translated">自动真空工作人员通常不会阻止其他命令。如果某个进程试图获取与由autovacuum持有的 &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; 锁冲突的锁，则锁获取将中断该autovacuum。有关冲突的锁定模式，请&lt;a href=&quot;explicit-locking#TABLE-LOCK-COMPATIBILITY&quot;&gt;参见表13.2&lt;/a&gt;。但是，如果运行autovacuum以防止事务ID绕回（即 &lt;code&gt;pg_stat_activity&lt;/code&gt; 视图中的autovacuum查询名以 &lt;code&gt;(to prevent wraparound)&lt;/code&gt; 绕回）结尾），则autovacuum不会自动中断。</target>
        </trans-unit>
        <trans-unit id="0edc11f659c78d515f96650dad0f6708f4c07fcc" translate="yes" xml:space="preserve">
          <source>Availability of WAL files claimed by this slot. Possible values are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df5a7bec123e69676856b9a816b4c6aef10e3a78" translate="yes" xml:space="preserve">
          <source>Available Client Character Sets</source>
          <target state="translated">可用的客户端字符集</target>
        </trans-unit>
        <trans-unit id="820b74a0a5297b8b6e88df74e84d5e81e977acf2" translate="yes" xml:space="preserve">
          <source>Available cipher suite details will vary across OpenSSL versions. Use the command &lt;code&gt;openssl ciphers -v 'HIGH:MEDIUM:+3DES:!aNULL'&lt;/code&gt; to see actual details for the currently installed OpenSSL version. Note that this list is filtered at run time based on the server key type.</source>
          <target state="translated">可用的密码套件详细信息将在OpenSSL版本中有所不同。使用命令 &lt;code&gt;openssl ciphers -v 'HIGH:MEDIUM:+3DES:!aNULL'&lt;/code&gt; 查看当前安装的OpenSSL版本的实际详细信息。请注意，此列表在运行时根据服务器密钥类型进行过滤。</target>
        </trans-unit>
        <trans-unit id="ba149cade6a0a4e50af1ecb3e25946c72c71094e" translate="yes" xml:space="preserve">
          <source>Average density of leaf pages</source>
          <target state="translated">叶子的平均密度</target>
        </trans-unit>
        <trans-unit id="f099162f6d15d176bb9a41f82a80ea2cb1d18cf4" translate="yes" xml:space="preserve">
          <source>Average number of transactions that are executed per second, totaled across all sessions active for a measured run. This is used as a measure of the performance characteristics of an instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4903dacf2f00d069a2643728e3f02486ff810d77" translate="yes" xml:space="preserve">
          <source>Average width in bytes of column's entries</source>
          <target state="translated">列的平均宽度,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="3e9553fca4b719e6a36df1dda8f90b143771ffd9" translate="yes" xml:space="preserve">
          <source>B-Tree Indexes</source>
          <target state="translated">B树指数</target>
        </trans-unit>
        <trans-unit id="68486e8aa60ef6bf0ca374b07c2662a92ae24f27" translate="yes" xml:space="preserve">
          <source>B-Tree Support Functions</source>
          <target state="translated">B树支持功能</target>
        </trans-unit>
        <trans-unit id="717b6f33b42cc7559340881ecec59b687e47a41c" translate="yes" xml:space="preserve">
          <source>B-Tree deduplication is just as effective with &amp;ldquo;duplicates&amp;rdquo; that contain a NULL value, even though NULL values are never equal to each other according to the &lt;code&gt;=&lt;/code&gt; member of any B-Tree operator class. As far as any part of the implementation that understands the on-disk B-Tree structure is concerned, NULL is just another value from the domain of indexed values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bea9fad8fb62f91da10ba766f66a246a745ab74" translate="yes" xml:space="preserve">
          <source>B-Tree indexes are not directly aware that under MVCC, there might be multiple extant versions of the same logical table row; to an index, each tuple is an independent object that needs its own index entry. &amp;ldquo;Version duplicates&amp;rdquo; may sometimes accumulate and adversely affect query latency and throughput. This typically occurs with &lt;code&gt;UPDATE&lt;/code&gt;-heavy workloads where most individual updates cannot apply the HOT optimization (often because at least one indexed column gets modified, necessitating a new set of index tuple versions &amp;mdash; one new tuple for &lt;em&gt;each and every&lt;/em&gt; index). In effect, B-Tree deduplication ameliorates index bloat caused by version churn. Note that even the tuples from a unique index are not necessarily &lt;em&gt;physically&lt;/em&gt; unique when stored on disk due to version churn. The deduplication optimization is selectively applied within unique indexes. It targets those pages that appear to have version duplicates. The high level goal is to give &lt;code&gt;VACUUM&lt;/code&gt; more time to run before an &amp;ldquo;unnecessary&amp;rdquo; page split caused by version churn can take place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9504ad9e3e7718bba2e8ff2d49bd5578d047ea98" translate="yes" xml:space="preserve">
          <source>B-tree equivalent functionality for several data types</source>
          <target state="translated">多个数据类型的B树等效功能</target>
        </trans-unit>
        <trans-unit id="905661856e09f20be385c26d6a37cee5d0959557" translate="yes" xml:space="preserve">
          <source>B-tree index over &lt;code&gt;ltree&lt;/code&gt;: &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ltree&lt;/code&gt; 上的 B树索引： &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;=&lt;/code&gt; ， &lt;code&gt;=&lt;/code&gt; ， &lt;code&gt;&amp;gt;=&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bdeef32a168111374c1be4cd04224fef89dc4b4b" translate="yes" xml:space="preserve">
          <source>B-tree index pages that have become completely empty are reclaimed for re-use. However, there is still a possibility of inefficient use of space: if all but a few index keys on a page have been deleted, the page remains allocated. Therefore, a usage pattern in which most, but not all, keys in each range are eventually deleted will see poor use of space. For such usage patterns, periodic reindexing is recommended.</source>
          <target state="translated">B-tree索引页如果已经完全空了,就会被回收重新使用。然而,仍有可能出现空间使用效率低下的情况:如果一个页面上除少数索引键外的所有键都被删除了,该页面仍被分配。因此,如果每个范围内的大部分(但不是全部)键最终都被删除的使用模式会出现空间使用效率低下的情况。对于这种使用模式,建议定期重新索引。</target>
        </trans-unit>
        <trans-unit id="065de2528617033a42220233cd1c35a251757908" translate="yes" xml:space="preserve">
          <source>B-tree indexes additionally accept this parameter:</source>
          <target state="translated">B树索引还接受这个参数。</target>
        </trans-unit>
        <trans-unit id="4e65573a03a3b33fe194962539e298b25562884c" translate="yes" xml:space="preserve">
          <source>B-tree indexes also accept these parameters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b33f3c038c507d02cde94014e083413eba3062f2" translate="yes" xml:space="preserve">
          <source>B-tree indexes can also be used to retrieve data in sorted order. This is not always faster than a simple scan and sort, but it is often helpful.</source>
          <target state="translated">B-tree索引也可以用来按排序顺序检索数据。这并不总是比简单的扫描和排序更快,但它通常是有用的。</target>
        </trans-unit>
        <trans-unit id="c1aa64fe8a588b4b8c3bb44a5ae5f195209958ec" translate="yes" xml:space="preserve">
          <source>B-tree version number</source>
          <target state="translated">B-tree版本号</target>
        </trans-unit>
        <trans-unit id="ee82358aad15ad2f88908ab7225b36322cd1065a" translate="yes" xml:space="preserve">
          <source>B-tree, GiST and SP-GiST indexes</source>
          <target state="translated">B-树、GiST和SP-GiST指数。</target>
        </trans-unit>
        <trans-unit id="16921be12274c9c7c84517bda5d89a5ff3df5941" translate="yes" xml:space="preserve">
          <source>B-trees can handle equality and range queries on data that can be sorted into some ordering. In particular, the PostgreSQL query planner will consider using a B-tree index whenever an indexed column is involved in a comparison using one of these operators:</source>
          <target state="translated">B树可以处理对可以排序成某种顺序的数据的平等和范围查询。特别是,每当使用这些运算符之一的比较中涉及到索引列时,PostgreSQL查询规划器会考虑使用B树索引。</target>
        </trans-unit>
        <trans-unit id="90fe59b25bb93f64682a57a1af270b45d31afdca" translate="yes" xml:space="preserve">
          <source>B.1. Date/Time Input Interpretation</source>
          <target state="translated">B.1.日期/时间输入解释</target>
        </trans-unit>
        <trans-unit id="9899d2230f4a93f14e01b57b593ac9983fb8a83d" translate="yes" xml:space="preserve">
          <source>B.2. Handling of Invalid or Ambiguous Timestamps</source>
          <target state="translated">B.2.处理无效或模糊的时间戳</target>
        </trans-unit>
        <trans-unit id="3840db4e415d986c6609f0316669636755ab2262" translate="yes" xml:space="preserve">
          <source>B.3. Date/Time Key Words</source>
          <target state="translated">B.3.日期/时间关键词</target>
        </trans-unit>
        <trans-unit id="922ab4c02bf090b11d909a4d188dbe702c610716" translate="yes" xml:space="preserve">
          <source>B.4. Date/Time Configuration Files</source>
          <target state="translated">B.4.日期/时间配置文件</target>
        </trans-unit>
        <trans-unit id="58922b284be009208c01702b42070c1a181d5b29" translate="yes" xml:space="preserve">
          <source>B.5. History of Units</source>
          <target state="translated">B.5.单位的历史</target>
        </trans-unit>
        <trans-unit id="9355cc4eed5770d5dfbba1271ff86061632e7258" translate="yes" xml:space="preserve">
          <source>B.5. POSIX Time Zone Specifications</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc2d5b79639788bc98e2a3a622f6560e3933f91" translate="yes" xml:space="preserve">
          <source>B.6. History of Units</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3598517c826f1480a241800ce73f781ae2b1cd6a" translate="yes" xml:space="preserve">
          <source>BEGIN</source>
          <target state="translated">BEGIN</target>
        </trans-unit>
        <trans-unit id="e87cf2c2aaae478fefafcf671d30d2bd91ab190c" translate="yes" xml:space="preserve">
          <source>BEGIN &amp;mdash; start a transaction block</source>
          <target state="translated">开始-开始交易块</target>
        </trans-unit>
        <trans-unit id="e3b1705472dc241e491b245a0698901129b83705" translate="yes" xml:space="preserve">
          <source>BIGNUM math</source>
          <target state="translated">BIGNUM数学</target>
        </trans-unit>
        <trans-unit id="c7854587bf0a26f0dd0236c46e64d140a0d9aa2a" translate="yes" xml:space="preserve">
          <source>BKI</source>
          <target state="translated">BKI</target>
        </trans-unit>
        <trans-unit id="a8e02c60c1fbe70ac08216f4d50adb47cd1b1f47" translate="yes" xml:space="preserve">
          <source>BREs differ from EREs in several respects. In BREs, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, and &lt;code&gt;?&lt;/code&gt; are ordinary characters and there is no equivalent for their functionality. The delimiters for bounds are &lt;code&gt;\{&lt;/code&gt; and &lt;code&gt;\}&lt;/code&gt;, with &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; by themselves ordinary characters. The parentheses for nested subexpressions are &lt;code&gt;\(&lt;/code&gt; and &lt;code&gt;\)&lt;/code&gt;, with &lt;code&gt;(&lt;/code&gt; and &lt;code&gt;)&lt;/code&gt; by themselves ordinary characters. &lt;code&gt;^&lt;/code&gt; is an ordinary character except at the beginning of the RE or the beginning of a parenthesized subexpression, &lt;code&gt;$&lt;/code&gt; is an ordinary character except at the end of the RE or the end of a parenthesized subexpression, and &lt;code&gt;*&lt;/code&gt; is an ordinary character if it appears at the beginning of the RE or the beginning of a parenthesized subexpression (after a possible leading &lt;code&gt;^&lt;/code&gt;). Finally, single-digit back references are available, and &lt;code&gt;\&amp;lt;&lt;/code&gt; and &lt;code&gt;\&amp;gt;&lt;/code&gt; are synonyms for &lt;code&gt;[[:&amp;lt;:]]&lt;/code&gt; and &lt;code&gt;[[:&amp;gt;:]]&lt;/code&gt; respectively; no other escapes are available in BREs.</source>
          <target state="translated">BRE在几个方面与ERE不同。在BRE中， &lt;code&gt;|&lt;/code&gt; ， &lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;?&lt;/code&gt; 是普通字符，其功能没有等效之处。边界的分隔符是 &lt;code&gt;\{&lt;/code&gt; 和 &lt;code&gt;\}&lt;/code&gt; ，其中 &lt;code&gt;{&lt;/code&gt; 和 &lt;code&gt;}&lt;/code&gt; 本身就是普通字符。嵌套子表达式的括号是 &lt;code&gt;\(&lt;/code&gt; 和 &lt;code&gt;\)&lt;/code&gt; ，其中 &lt;code&gt;(&lt;/code&gt; 和 &lt;code&gt;)&lt;/code&gt; 本身是普通字符。 &lt;code&gt;^&lt;/code&gt; 是普通字符，除了RE的开头或带括号的子表达式的开头 &lt;code&gt;$&lt;/code&gt; 是一个普通字符，除了RE的末尾或带括号的子表达式的末尾， &lt;code&gt;*&lt;/code&gt; 是一个普通字符，如果它出现在RE的开头或带括号的子表达式的开头（可能在前导 &lt;code&gt;^&lt;/code&gt; 之后）。最后，可以使用一位数字的反向引用，并且 &lt;code&gt;\&amp;lt;&lt;/code&gt; 和 &lt;code&gt;\&amp;gt;&lt;/code&gt; 分别是 &lt;code&gt;[[:&amp;lt;:]]&lt;/code&gt; 和 &lt;code&gt;[[:&amp;gt;:]]&lt;/code&gt; 的同义词； BRE中没有其他可用的转义符。</target>
        </trans-unit>
        <trans-unit id="b45363f80402fee41de7af6a2bc3803bd8fcc804" translate="yes" xml:space="preserve">
          <source>BRIN Indexes: Built-in Operator Classes</source>
          <target state="translated">BRIN索引。内建操作类</target>
        </trans-unit>
        <trans-unit id="610805949da9a921d5d35ddef0174271633dc849" translate="yes" xml:space="preserve">
          <source>BRIN Indexes: Extensibility</source>
          <target state="translated">BRIN索引。可扩展性</target>
        </trans-unit>
        <trans-unit id="e9ea37807ed02774eb4219265e764033548569ae" translate="yes" xml:space="preserve">
          <source>BRIN indexes (a shorthand for Block Range INdexes) store summaries about the values stored in consecutive physical block ranges of a table. Like GiST, SP-GiST and GIN, BRIN can support many different indexing strategies, and the particular operators with which a BRIN index can be used vary depending on the indexing strategy. For data types that have a linear sort order, the indexed data corresponds to the minimum and maximum values of the values in the column for each block range. This supports indexed queries using these operators:</source>
          <target state="translated">BRIN索引(Block Range INdexes的简写)存储了关于存储在表的连续物理块范围内的值的摘要。与GiST、SP-GiST和GIN一样,BRIN可以支持许多不同的索引策略,BRIN索引可以使用的特定运算符根据索引策略的不同而不同。对于具有线性排序顺序的数据类型,索引数据对应于每个块范围内的列中值的最小值和最大值。这支持使用这些运算符进行索引查询。</target>
        </trans-unit>
        <trans-unit id="192104c1f501554301510ea5a728a13a08ab43a4" translate="yes" xml:space="preserve">
          <source>BRIN indexes accept different parameters:</source>
          <target state="translated">BRIN索引接受不同的参数。</target>
        </trans-unit>
        <trans-unit id="b838c564f224f8b8543683d11eed0d0437e44e11" translate="yes" xml:space="preserve">
          <source>BRIN indexes can satisfy queries via regular bitmap index scans, and will return all tuples in all pages within each range if the summary info stored by the index is &lt;em&gt;consistent&lt;/em&gt; with the query conditions. The query executor is in charge of rechecking these tuples and discarding those that do not match the query conditions &amp;mdash; in other words, these indexes are lossy. Because a BRIN index is very small, scanning the index adds little overhead compared to a sequential scan, but may avoid scanning large parts of the table that are known not to contain matching tuples.</source>
          <target state="translated">BRIN索引可以通过常规的位图索引扫描满足查询，如果索引存储的摘要信息与查询条件&lt;em&gt;一致&lt;/em&gt;，则BRIN索引将返回每个范围内所有页面中的所有元组。查询执行程序负责重新检查这些元组，并丢弃不符合查询条件的元组，换句话说，这些索引是有损的。由于BRIN索引非常小，因此与顺序扫描相比，扫描索引几乎不会增加开销，但是可以避免扫描表的大部分不包含匹配元组的部分。</target>
        </trans-unit>
        <trans-unit id="55b3c9c4efac0d4d71eaa3d4c8cc93a475582a37" translate="yes" xml:space="preserve">
          <source>BRIN stands for Block Range Index. BRIN is designed for handling very large tables in which certain columns have some natural correlation with their physical location within the table. A &lt;em&gt;block range&lt;/em&gt; is a group of pages that are physically adjacent in the table; for each block range, some summary info is stored by the index. For example, a table storing a store's sale orders might have a date column on which each order was placed, and most of the time the entries for earlier orders will appear earlier in the table as well; a table storing a ZIP code column might have all codes for a city grouped together naturally.</source>
          <target state="translated">BRIN代表块范围索引。 BRIN设计用于处理非常大的表，其中某些列与其在表中的物理位置具有某些自然相关性。阿&lt;em&gt;块范围&lt;/em&gt;是一组属于在表中物理相邻的页;对于每个块范围，索引都会存储一些摘要信息。例如，存储商店销售订单的表中可能有一个日期列，每个订单都放置在该列上，大多数时候，较早订单的条目也会在表格中更早出现。储存邮递区号栏的表格可能会将某个城市的所有编码自然地组合在一起。</target>
        </trans-unit>
        <trans-unit id="c5bca0a807cb4e3535b6c51a06c3bccf47631d7c" translate="yes" xml:space="preserve">
          <source>BSD Authentication</source>
          <target state="translated">BSD认证</target>
        </trans-unit>
        <trans-unit id="f1a97c299183923139e5920b8bda3da33aa50cdf" translate="yes" xml:space="preserve">
          <source>BSD Authentication in PostgreSQL uses the &lt;code&gt;auth-postgresql&lt;/code&gt; login type and authenticates with the &lt;code&gt;postgresql&lt;/code&gt; login class if that's defined in &lt;code&gt;login.conf&lt;/code&gt;. By default that login class does not exist, and PostgreSQL will use the default login class.</source>
          <target state="translated">PostgreSQL中的BSD身份验证使用 &lt;code&gt;auth-postgresql&lt;/code&gt; 登录类型，并使用 &lt;code&gt;postgresql&lt;/code&gt; 登录类（如果在 &lt;code&gt;login.conf&lt;/code&gt; 中定义）进行身份验证。默认情况下，该登录类不存在，而PostgreSQL将使用默认的登录类。</target>
        </trans-unit>
        <trans-unit id="eebf5442eb861b0130ab1dbae1411845a2d52d61" translate="yes" xml:space="preserve">
          <source>Backend (process)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99affebb8bc98ca77c8c04882ebec0dea90a3114" translate="yes" xml:space="preserve">
          <source>Backend Interface</source>
          <target state="translated">后端接口</target>
        </trans-unit>
        <trans-unit id="328769872d8232ec584540b9757369093134e160" translate="yes" xml:space="preserve">
          <source>Backend type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc32da7c82d0789e65952daa2c9def14b3058549" translate="yes" xml:space="preserve">
          <source>Background worker (process)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b848315d26f8ea5458744e8623f2ff6b2080f8c1" translate="yes" xml:space="preserve">
          <source>Background writer (process)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60f8490b7625580e80d17d5a1df23b1d4de6ebc4" translate="yes" xml:space="preserve">
          <source>Backslash &lt;code&gt;x&lt;/code&gt; followed by one or two hex digits specifies the character with that numeric code</source>
          <target state="translated">反斜杠 &lt;code&gt;x&lt;/code&gt; 后跟一个或两个十六进制数字指定具有该数字代码的字符</target>
        </trans-unit>
        <trans-unit id="f71436b4e34992baf3c146d9f7bcd610fe7bd64e" translate="yes" xml:space="preserve">
          <source>Backslash Escape Sequence</source>
          <target state="translated">反斜杠转义序列</target>
        </trans-unit>
        <trans-unit id="08da95faebff9b822ea5284de54543cc7bd092f0" translate="yes" xml:space="preserve">
          <source>Backslash characters (&lt;code&gt;\&lt;/code&gt;) can be used in the &lt;code&gt;COPY&lt;/code&gt; data to quote data characters that might otherwise be taken as row or column delimiters. In particular, the following characters &lt;em&gt;must&lt;/em&gt; be preceded by a backslash if they appear as part of a column value: backslash itself, newline, carriage return, and the current delimiter character.</source>
          <target state="translated">可以在 &lt;code&gt;COPY&lt;/code&gt; 数据中使用反斜杠字符（ &lt;code&gt;\&lt;/code&gt; ）引用数据字符，否则这些数据字符可能被当作行或列定界符。特别是，如果以下字符作为列值的一部分出现，则&lt;em&gt;必须&lt;/em&gt;在其后加上反斜杠：反斜杠本身，换行符，回车符和当前定界符。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="79f7f8eb79d3eb20be7d5f2fdb2c6cb1e00c749f" translate="yes" xml:space="preserve">
          <source>Backslash followed by one to three octal digits specifies the character with that numeric code</source>
          <target state="translated">后面的反斜杠和一至三位八位数指定了该数字代码的字符。</target>
        </trans-unit>
        <trans-unit id="7b77925a9192b55418069493a221c26ff154c448" translate="yes" xml:space="preserve">
          <source>Backslash-semicolon is not a meta-command in the same way as the preceding commands; rather, it simply causes a semicolon to be added to the query buffer without any further processing.</source>
          <target state="translated">Backslash-semicolon并不是一个元命令,与前面的命令不同,它只是将分号添加到查询缓冲区中,而不做任何进一步处理。</target>
        </trans-unit>
        <trans-unit id="3415ee42fbdf165d3ab63673dafeffa9121924ae" translate="yes" xml:space="preserve">
          <source>Backspace (ASCII 8)</source>
          <target state="translated">退格键(ASCII 8)</target>
        </trans-unit>
        <trans-unit id="ee100250b3b61b298848fb969f8f888fd07a7761" translate="yes" xml:space="preserve">
          <source>Backtrace support is not available on all platforms, and the quality of the backtraces depends on compilation options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d331ac3f1a6cac9c6991fe1fa25efc25e1bcefe8" translate="yes" xml:space="preserve">
          <source>Backup Manifest File Object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="379196baf790f4b6fa0825b0de670c43e08df23a" translate="yes" xml:space="preserve">
          <source>Backup Manifest Format</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22c6cad75143d38691a0caaf6de1d84dce170459" translate="yes" xml:space="preserve">
          <source>Backup Manifest Top-level Object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e141d2d8691eaa6fba3c4489c0fc0d8b0d463b66" translate="yes" xml:space="preserve">
          <source>Backup Manifest WAL Range Object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5932464fe7ee7685cdde1f28a54e89455da1784" translate="yes" xml:space="preserve">
          <source>Backup and Restore</source>
          <target state="translated">备份和恢复</target>
        </trans-unit>
        <trans-unit id="171ec47bee8f29611873a226142872b637cc0954" translate="yes" xml:space="preserve">
          <source>Backup verification proceeds in four stages. First, &lt;code&gt;pg_verifybackup&lt;/code&gt; reads the &lt;code&gt;backup_manifest&lt;/code&gt; file. If that file does not exist, cannot be read, is malformed, or fails verification against its own internal checksum, &lt;code&gt;pg_verifybackup&lt;/code&gt; will terminate with a fatal error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86e2f1a9ee8c86cb8243f522b50b65e6423c34d6" translate="yes" xml:space="preserve">
          <source>Backward compatibility syntax for removing the &lt;code&gt;oid&lt;/code&gt; system column. As &lt;code&gt;oid&lt;/code&gt; system columns cannot be added anymore, this never has an effect.</source>
          <target state="translated">向后兼容语法，用于删除 &lt;code&gt;oid&lt;/code&gt; 系统列。由于无法再添加 &lt;code&gt;oid&lt;/code&gt; 系统列，因此永远不会起作用。</target>
        </trans-unit>
        <trans-unit id="3ea614d7d0d66375e7b59ad1603ddbf9c6954a56" translate="yes" xml:space="preserve">
          <source>Backward fetches are also disallowed when the query includes &lt;code&gt;FOR UPDATE&lt;/code&gt; or &lt;code&gt;FOR SHARE&lt;/code&gt;; therefore &lt;code&gt;SCROLL&lt;/code&gt; may not be specified in this case.</source>
          <target state="translated">当查询包含 &lt;code&gt;FOR UPDATE&lt;/code&gt; 或 &lt;code&gt;FOR SHARE&lt;/code&gt; 时，也不允许向后提取；因此在这种情况下可能无法指定 &lt;code&gt;SCROLL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="92077d51292270928790f0d07fb2a1301d60ee31" translate="yes" xml:space="preserve">
          <source>Backward-compatible syntax for removing the &lt;code&gt;oid&lt;/code&gt; system column. As &lt;code&gt;oid&lt;/code&gt; system columns cannot be added anymore, this never has an effect.</source>
          <target state="translated">向后兼容的语法，用于删除 &lt;code&gt;oid&lt;/code&gt; 系统列。由于无法再添加 &lt;code&gt;oid&lt;/code&gt; 系统列，因此永远不会起作用。</target>
        </trans-unit>
        <trans-unit id="044409ea2cd85fda028f96eed9a84a9fcc920931" translate="yes" xml:space="preserve">
          <source>Baltic</source>
          <target state="translated">Baltic</target>
        </trans-unit>
        <trans-unit id="485c014f257e394c215c16b50018b7e0c80f4130" translate="yes" xml:space="preserve">
          <source>Base 10 logarithm</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b9f28dd05a6a2df955f43acccdc39e58fea4d0c" translate="yes" xml:space="preserve">
          <source>Base 10 logarithm (same as &lt;code&gt;log&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb6d805e2be11428f917d98dd4e9cac7ed971f88" translate="yes" xml:space="preserve">
          <source>Base Types</source>
          <target state="translated">基础类型</target>
        </trans-unit>
        <trans-unit id="7d67a1e0565652b8a1f39922bf439ec06adfe28a" translate="yes" xml:space="preserve">
          <source>Basically a thesaurus dictionary replaces all non-preferred terms by one preferred term and, optionally, preserves the original terms for indexing as well. PostgreSQL's current implementation of the thesaurus dictionary is an extension of the synonym dictionary with added &lt;em&gt;phrase&lt;/em&gt; support. A thesaurus dictionary requires a configuration file of the following format:</source>
          <target state="translated">基本上，词库词典将所有非首选术语替换为一个首选术语，并有选择地保留原始术语以供索引。PostgreSQL当前对同义词词典的实现是对同义词词典的扩展，增加了&lt;em&gt;短语&lt;/em&gt;支持。同义词库字典需要以下格式的配置文件：</target>
        </trans-unit>
        <trans-unit id="e1ddc988e6d784f9a638904386d7cd96020404d0" translate="yes" xml:space="preserve">
          <source>Batching WAL files so that they are transferred every three hours, rather than one at a time</source>
          <target state="translated">批量传输WAL文件,使其每三小时传输一次,而不是一次一个。</target>
        </trans-unit>
        <trans-unit id="56ac908a2429c8b6f57e6b53eb261c2b37853b9f" translate="yes" xml:space="preserve">
          <source>Be aware however that such a query will be very inefficient.</source>
          <target state="translated">但要知道,这样的查询效率会很低。</target>
        </trans-unit>
        <trans-unit id="dd8576c5e404ad1333289b223aeb849843ea4d63" translate="yes" xml:space="preserve">
          <source>Be aware that &lt;code&gt;COPY&lt;/code&gt; ignores rules. If you want to use &lt;code&gt;COPY&lt;/code&gt; to insert data, you'll need to copy into the correct child table rather than directly into the master. &lt;code&gt;COPY&lt;/code&gt; does fire triggers, so you can use it normally if you use the trigger approach.</source>
          <target state="translated">请注意， &lt;code&gt;COPY&lt;/code&gt; 会忽略规则。如果要使用 &lt;code&gt;COPY&lt;/code&gt; 插入数据，则需要复制到正确的子表中，而不是直接复制到主表中。 &lt;code&gt;COPY&lt;/code&gt; 会触发触发器，因此，如果使用触发器方法，则可以正常使用它。</target>
        </trans-unit>
        <trans-unit id="3ec6516cf2acdacef6ec02909f23a042de655757" translate="yes" xml:space="preserve">
          <source>Be careful that the names and types of the view's columns will be assigned the way you want. For example:</source>
          <target state="translated">要注意,视图的列名和类型会按照你想要的方式分配。例如:</target>
        </trans-unit>
        <trans-unit id="2ecd0bd78d58da0c631755bb828f27e267549d1c" translate="yes" xml:space="preserve">
          <source>Be careful to specify the schema in which you installed the existing &lt;code&gt;hstore&lt;/code&gt; objects.</source>
          <target state="translated">请小心指定安装现有 &lt;code&gt;hstore&lt;/code&gt; 对象的架构。</target>
        </trans-unit>
        <trans-unit id="3286148c08a1b92253bcb1e687624659972203da" translate="yes" xml:space="preserve">
          <source>Be careful with the &lt;code&gt;CREATEROLE&lt;/code&gt; privilege. There is no concept of inheritance for the privileges of a &lt;code&gt;CREATEROLE&lt;/code&gt;-role. That means that even if a role does not have a certain privilege but is allowed to create other roles, it can easily create another role with different privileges than its own (except for creating roles with superuser privileges). For example, if the role &amp;ldquo;user&amp;rdquo; has the &lt;code&gt;CREATEROLE&lt;/code&gt; privilege but not the &lt;code&gt;CREATEDB&lt;/code&gt; privilege, nonetheless it can create a new role with the &lt;code&gt;CREATEDB&lt;/code&gt; privilege. Therefore, regard roles that have the &lt;code&gt;CREATEROLE&lt;/code&gt; privilege as almost-superuser-roles.</source>
          <target state="translated">注意 &lt;code&gt;CREATEROLE&lt;/code&gt; 特权。对于 &lt;code&gt;CREATEROLE&lt;/code&gt; -role 的特权，没有继承的概念。这意味着，即使一个角色没有特定的特权，但被允许创建其他角色，它也可以轻松地创建另一个角色，而该角色的特权不同于其自己的角色（创建具有超级用户特权的角色除外）。例如，如果角色&amp;ldquo;用户&amp;rdquo;具有 &lt;code&gt;CREATEROLE&lt;/code&gt; 特权，但没有 &lt;code&gt;CREATEDB&lt;/code&gt; 特权，则它仍可以使用 &lt;code&gt;CREATEDB&lt;/code&gt; 特权创建新角色。因此，将具有 &lt;code&gt;CREATEROLE&lt;/code&gt; 特权的角色视为几乎超级用户角色。</target>
        </trans-unit>
        <trans-unit id="e9a084e06d49f90e432ff228c5d493ff5d910d84" translate="yes" xml:space="preserve">
          <source>Be certain that your backup includes all of the files under the database cluster directory (e.g., &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt;). If you are using tablespaces that do not reside underneath this directory, be careful to include them as well (and be sure that your backup archives symbolic links as links, otherwise the restore will corrupt your tablespaces).</source>
          <target state="translated">确保您的备份包括数据库集群目录下的所有文件（例如， &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt; ）。如果您使用的表空间不位于该目录下，则还应小心地将它们包括在内（并确保备份将符号链接归档为链接，否则还原将破坏您的表空间）。</target>
        </trans-unit>
        <trans-unit id="1cca2cb275ffb0ac1d90a9275a182dd9576c7cb7" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;glossary#GLOSSARY-NULL&quot;&gt;null values&lt;/a&gt; are not considered equal to each other, multiple rows with null values are allowed to exist without violating the unique constraint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8050bf055d69a2c17aebfa6f23142af8cc972e31" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;...&lt;/code&gt; is widely used in data sources, it is allowed as an alternative spelling of &lt;code&gt;..&lt;/code&gt;. Unfortunately, this creates a parsing ambiguity: it is not clear whether the upper bound in &lt;code&gt;0...23&lt;/code&gt; is meant to be &lt;code&gt;23&lt;/code&gt; or &lt;code&gt;0.23&lt;/code&gt;. This is resolved by requiring at least one digit before the decimal point in all numbers in &lt;code&gt;seg&lt;/code&gt; input.</source>
          <target state="translated">因为 &lt;code&gt;...&lt;/code&gt; 在数据源中广泛使用，所以可以将...作为 &lt;code&gt;..&lt;/code&gt; 的替代拼写。不幸的是，这会造成解析模糊性：尚不清楚 &lt;code&gt;0...23&lt;/code&gt; 的上限是 &lt;code&gt;23&lt;/code&gt; 还是 &lt;code&gt;0.23&lt;/code&gt; 。通过在 &lt;code&gt;seg&lt;/code&gt; 输入中所有数字中的小数点前至少需要一位数字来解决。</target>
        </trans-unit>
        <trans-unit id="786d48aa791887748b32e63ec202e2ae60a5fb6e" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;CLUSTER&lt;/code&gt; remembers which indexes are clustered, one can cluster the tables one wants clustered manually the first time, then set up a periodic maintenance script that executes &lt;code&gt;CLUSTER&lt;/code&gt; without any parameters, so that the desired tables are periodically reclustered.</source>
          <target state="translated">因为 &lt;code&gt;CLUSTER&lt;/code&gt; 会记住哪些索引是集群的，所以人们可以第一次将要集群的表集群，然后设置一个定期维护脚本，该脚本无需任何参数即可执行 &lt;code&gt;CLUSTER&lt;/code&gt; ，以便定期重新集群所需的表。</target>
        </trans-unit>
        <trans-unit id="483573a468db7932cd30d693208c560bce934759" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;float8&lt;/code&gt; has no meaningful &amp;ldquo;step&amp;rdquo;, we do not define a canonicalization function in this example.</source>
          <target state="translated">因为 &lt;code&gt;float8&lt;/code&gt; 没有有意义的&amp;ldquo;步骤&amp;rdquo;，所以在此示例中我们没有定义规范化函数。</target>
        </trans-unit>
        <trans-unit id="8c58240b228b0ae5aff4efd20c01cc67a3bd5a52" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;nextval&lt;/code&gt; and &lt;code&gt;setval&lt;/code&gt; calls are never rolled back, sequence objects cannot be used if &amp;ldquo;gapless&amp;rdquo; assignment of sequence numbers is needed. It is possible to build gapless assignment by using exclusive locking of a table containing a counter; but this solution is much more expensive than sequence objects, especially if many transactions need sequence numbers concurrently.</source>
          <target state="translated">因为 &lt;code&gt;nextval&lt;/code&gt; 和 &lt;code&gt;setval&lt;/code&gt; 调用不会回滚，所以如果需要&amp;ldquo;无间隙&amp;rdquo;分配序列号，则不能使用序列对象。通过使用包含计数器的表的互斥锁定，可以建立无缝分配。但是此解决方案比序列对象昂贵得多，尤其是在许多事务同时需要序列号的情况下。</target>
        </trans-unit>
        <trans-unit id="57fa06eff5bff23d9975c881fe012eee591895a8" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;smallserial&lt;/code&gt;, &lt;code&gt;serial&lt;/code&gt; and &lt;code&gt;bigserial&lt;/code&gt; are implemented using sequences, there may be &quot;holes&quot; or gaps in the sequence of values which appears in the column, even if no rows are ever deleted. A value allocated from the sequence is still &quot;used up&quot; even if a row containing that value is never successfully inserted into the table column. This may happen, for example, if the inserting transaction rolls back. See &lt;code&gt;nextval()&lt;/code&gt; in &lt;a href=&quot;functions-sequence&quot;&gt;Section 9.16&lt;/a&gt; for details.</source>
          <target state="translated">因为 &lt;code&gt;smallserial&lt;/code&gt; ， &lt;code&gt;serial&lt;/code&gt; 和 &lt;code&gt;bigserial&lt;/code&gt; 是使用序列实现的，所以即使没有删除任何行，在列中出现的值序列中也可能存在&amp;ldquo;空洞&amp;rdquo;或间隙。即使从未成功将包含该值的行插入表列，也仍会&amp;ldquo;用完&amp;rdquo;从序列中分配的值。例如，如果插入事务回滚，则可能会发生这种情况。见 &lt;code&gt;nextval()&lt;/code&gt; 会在&lt;a href=&quot;functions-sequence&quot;&gt;9.16节&lt;/a&gt;了解详情。</target>
        </trans-unit>
        <trans-unit id="3bffe320d485976bda24d70a1ca1896c9923ad97" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;smallserial&lt;/code&gt;, &lt;code&gt;serial&lt;/code&gt; and &lt;code&gt;bigserial&lt;/code&gt; are implemented using sequences, there may be &quot;holes&quot; or gaps in the sequence of values which appears in the column, even if no rows are ever deleted. A value allocated from the sequence is still &quot;used up&quot; even if a row containing that value is never successfully inserted into the table column. This may happen, for example, if the inserting transaction rolls back. See &lt;code&gt;nextval()&lt;/code&gt; in &lt;a href=&quot;functions-sequence&quot;&gt;Section 9.17&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2055271ae8273a98d1c3120c9ad69e5bbb4dabd7" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;to_tsvector&lt;/code&gt;(&lt;code&gt;NULL&lt;/code&gt;) will return &lt;code&gt;NULL&lt;/code&gt;, it is recommended to use &lt;code&gt;coalesce&lt;/code&gt; whenever a field might be null. Here is the recommended method for creating a &lt;code&gt;tsvector&lt;/code&gt; from a structured document:</source>
          <target state="translated">因为 &lt;code&gt;to_tsvector&lt;/code&gt; （ &lt;code&gt;NULL&lt;/code&gt; ）将返回 &lt;code&gt;NULL&lt;/code&gt; ，所以建议在字段可能为空时使用 &lt;code&gt;coalesce&lt;/code&gt; 。这是从结构化文档创建 &lt;code&gt;tsvector&lt;/code&gt; 的推荐方法：</target>
        </trans-unit>
        <trans-unit id="e67190c3b34212fbd9608f10ce1643e97f3b598d" translate="yes" xml:space="preserve">
          <source>Because JSON containment is nested, an appropriate query can skip explicit selection of sub-objects. As an example, suppose that we have a &lt;code&gt;doc&lt;/code&gt; column containing objects at the top level, with most objects containing &lt;code&gt;tags&lt;/code&gt; fields that contain arrays of sub-objects. This query finds entries in which sub-objects containing both &lt;code&gt;&quot;term&quot;:&quot;paris&quot;&lt;/code&gt; and &lt;code&gt;&quot;term&quot;:&quot;food&quot;&lt;/code&gt; appear, while ignoring any such keys outside the &lt;code&gt;tags&lt;/code&gt; array:</source>
          <target state="translated">由于JSON包含嵌套，因此适当的查询可以跳过对子对象的显式选择。举例来说，假设我们有一个 &lt;code&gt;doc&lt;/code&gt; 列，其中包含顶级对象，而大多数对象包含包含子对象数组的 &lt;code&gt;tags&lt;/code&gt; 字段。该查询查找条目，在其中包含 &lt;code&gt;&quot;term&quot;:&quot;paris&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;term&quot;:&quot;food&quot;&lt;/code&gt; 子对象出现，而忽略 &lt;code&gt;tags&lt;/code&gt; 数组外的任何此类键：</target>
        </trans-unit>
        <trans-unit id="9a6a9b9301894dfb915e7f65b2cfd52739126757" translate="yes" xml:space="preserve">
          <source>Because PostgreSQL does not require constraint names to be unique within a schema (but only per-table), it is possible that there is more than one match for a specified constraint name. In this case &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; will act on all matches. For a non-schema-qualified name, once a match or matches have been found in some schema in the search path, schemas appearing later in the path are not searched.</source>
          <target state="translated">因为PostgreSQL不需要约束名称在模式中唯一（仅按表），所以指定约束名称可能有多个匹配项。在这种情况下， &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; 将对所有比赛起作用。对于非模式限定的名称，一旦在搜索路径中的某些模式中找到一个或多个匹配项，就不会搜索路径中稍后出现的模式。</target>
        </trans-unit>
        <trans-unit id="1054531abd84ea6ab456598b0cbf13df62bd8f3f" translate="yes" xml:space="preserve">
          <source>Because PostgreSQL is open source and easily extended, a number of companies have taken PostgreSQL and created commercial closed-source solutions with unique failover, replication, and load balancing capabilities.</source>
          <target state="translated">由于PostgreSQL是开源的,而且容易扩展,所以有很多公司已经采用PostgreSQL,并创建了具有独特的故障转移、复制和负载平衡功能的商业闭源解决方案。</target>
        </trans-unit>
        <trans-unit id="7c927394e6733d9a2cd5092ccd59b8f1d233eaee" translate="yes" xml:space="preserve">
          <source>Because Read Committed mode starts each command with a new snapshot that includes all transactions committed up to that instant, subsequent commands in the same transaction will see the effects of the committed concurrent transaction in any case. The point at issue above is whether or not a &lt;em&gt;single&lt;/em&gt; command sees an absolutely consistent view of the database.</source>
          <target state="translated">由于&amp;ldquo;读取已提交&amp;rdquo;模式会以一个新快照开始每个命令，其中包括该瞬间之前已提交的所有事务，因此无论如何，同一事务中的后续命令都会看到已提交并发事务的效果。上面的问题是&lt;em&gt;单个&lt;/em&gt;命令是否看到数据库的绝对一致视图。</target>
        </trans-unit>
        <trans-unit id="cb5cad886e41acd11550eebbf5881fb1ea7474ee" translate="yes" xml:space="preserve">
          <source>Because WAL restores database file contents after a crash, journaled file systems are not necessary for reliable storage of the data files or WAL files. In fact, journaling overhead can reduce performance, especially if journaling causes file system &lt;em&gt;data&lt;/em&gt; to be flushed to disk. Fortunately, data flushing during journaling can often be disabled with a file system mount option, e.g. &lt;code&gt;data=writeback&lt;/code&gt; on a Linux ext3 file system. Journaled file systems do improve boot speed after a crash.</source>
          <target state="translated">由于WAL在崩溃后会还原数据库文件的内容，因此日记记录文件系统对于可靠地存储数据文件或WAL文件不是必需的。实际上，日志记录开销可能会降低性能，特别是如果日志记录导致文件系统&lt;em&gt;数据&lt;/em&gt;刷新到磁盘上，则尤其如此。幸运的是，通常可以使用文件系统挂载选项来禁用日志记录期间的数据刷新，例如，Linux ext3文件系统上的 &lt;code&gt;data=writeback&lt;/code&gt; 。日志文件系统在崩溃后确实可以提高启动速度。</target>
        </trans-unit>
        <trans-unit id="8e8b8c9914b76b9dd74e86a1ad52e4f86cc8bc3d" translate="yes" xml:space="preserve">
          <source>Because WAL restores database file contents after a crash, journaled file systems are not necessary for reliable storage of the data files or WAL files. In fact, journaling overhead can reduce performance, especially if journaling causes file system &lt;em&gt;data&lt;/em&gt; to be flushed to disk. Fortunately, data flushing during journaling can often be disabled with a file system mount option, e.g., &lt;code&gt;data=writeback&lt;/code&gt; on a Linux ext3 file system. Journaled file systems do improve boot speed after a crash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af002f2ced30c87d8ca2cfc786b9d6c148a8b054" translate="yes" xml:space="preserve">
          <source>Because a &lt;code&gt;SECURITY DEFINER&lt;/code&gt; function is executed with the privileges of the user that owns it, care is needed to ensure that the function cannot be misused. For security, &lt;a href=&quot;runtime-config-client#GUC-SEARCH-PATH&quot;&gt;search_path&lt;/a&gt; should be set to exclude any schemas writable by untrusted users. This prevents malicious users from creating objects (e.g., tables, functions, and operators) that mask objects intended to be used by the function. Particularly important in this regard is the temporary-table schema, which is searched first by default, and is normally writable by anyone. A secure arrangement can be obtained by forcing the temporary schema to be searched last. To do this, write &lt;code&gt;pg_temp&lt;/code&gt; as the last entry in &lt;code&gt;search_path&lt;/code&gt;. This function illustrates safe usage:</source>
          <target state="translated">由于 &lt;code&gt;SECURITY DEFINER&lt;/code&gt; 函数是使用拥有它的用户的特权执行的，因此需要小心以确保该函数不会被滥用。为了安全起见，应将&lt;a href=&quot;runtime-config-client#GUC-SEARCH-PATH&quot;&gt;search_path&lt;/a&gt;设置为排除不受信任用户可写的任何架构。这可以防止恶意用户创建对象（例如，表，函数和运算符），以掩盖该函数打算使用的对象。在这方面，特别重要的是临时表架构，它是默认情况下首先搜索的，通常任何人都可以写。通过强制最后搜索临时模式可以获得安全的安排。要做到这一点，写 &lt;code&gt;pg_temp&lt;/code&gt; 作为最后一项 &lt;code&gt;search_path&lt;/code&gt; 。此功能说明了安全用法：</target>
        </trans-unit>
        <trans-unit id="7ccf103cb4c217d06785a0ccdc57267c861dec31" translate="yes" xml:space="preserve">
          <source>Because backslash is not a special character in the &lt;code&gt;CSV&lt;/code&gt; format, &lt;code&gt;\.&lt;/code&gt;, the end-of-data marker, could also appear as a data value. To avoid any misinterpretation, a &lt;code&gt;\.&lt;/code&gt; data value appearing as a lone entry on a line is automatically quoted on output, and on input, if quoted, is not interpreted as the end-of-data marker. If you are loading a file created by another application that has a single unquoted column and might have a value of &lt;code&gt;\.&lt;/code&gt;, you might need to quote that value in the input file.</source>
          <target state="translated">因为反斜杠不是 &lt;code&gt;CSV&lt;/code&gt; 格式的特殊字符，所以 &lt;code&gt;\.&lt;/code&gt; ，数据结束标记，也可以显示为数据值。为避免任何误解，请使用 &lt;code&gt;\.&lt;/code&gt; 在行上显示为单独条目的数据值将在输出时自动加引号，并且在输入时（如果加引号）不会被解释为数据结束标记。如果要加载由另一个应用程序创建的文件，该文件具有一个未加引号的列，并且值可能为 &lt;code&gt;\.&lt;/code&gt; ，您可能需要在输入文件中引用该值。</target>
        </trans-unit>
        <trans-unit id="8837df7b2c1fb8da3ce2a114226b6b81d22d5575" translate="yes" xml:space="preserve">
          <source>Because column &lt;code&gt;y&lt;/code&gt; is not part of the index's search key, it does not have to be of a data type that the index can handle; it's merely stored in the index and is not interpreted by the index machinery. Also, if the index is a unique index, that is</source>
          <target state="translated">因为 &lt;code&gt;y&lt;/code&gt; 列不是索引搜索键的一部分，所以它不必是索引可以处理的数据类型；它仅存储在索引中，而不会被索引机制解释。另外，如果索引是唯一索引，则</target>
        </trans-unit>
        <trans-unit id="3d96d2addf447433c224777bf906ab67b3fda87a" translate="yes" xml:space="preserve">
          <source>Because custom options may need to be set in processes that have not loaded the relevant extension module, PostgreSQL will accept a setting for any two-part parameter name. Such variables are treated as placeholders and have no function until the module that defines them is loaded. When an extension module is loaded, it will add its variable definitions, convert any placeholder values according to those definitions, and issue warnings for any unrecognized placeholders that begin with its extension name.</source>
          <target state="translated">由于在没有加载相关扩展模块的进程中可能需要设置自定义选项,PostgreSQL将接受任何两部分参数名称的设置。这样的变量被视为占位符,在定义它们的模块被加载之前没有任何功能。当一个扩展模块被加载后,它将添加其变量定义,根据这些定义转换任何占位符值,并对任何以其扩展名开头的未识别的占位符发出警告。</target>
        </trans-unit>
        <trans-unit id="501d8e61189d0ec14bdd409d7b3e2083ee96580b" translate="yes" xml:space="preserve">
          <source>Because each btree operator class imposes a sort order on its data type, btree operator classes (or, really, operator families) have come to be used as PostgreSQL's general representation and understanding of sorting semantics. Therefore, they've acquired some features that go beyond what would be needed just to support btree indexes, and parts of the system that are quite distant from the btree AM make use of them.</source>
          <target state="translated">因为每个btree操作类都对其数据类型施加一个排序顺序,所以btree操作类(或者说,真正的操作族)已经被用作PostgreSQL对排序语义的一般表示和理解。因此,它们已经获得了一些功能,超出了仅仅支持btree索引所需要的功能,系统中与btree AM有相当距离的部分也利用了它们。</target>
        </trans-unit>
        <trans-unit id="1cf84fc42fc11690b4a8d7c72f78d6f59379bbaa" translate="yes" xml:space="preserve">
          <source>Because each worker executes the parallel portion of the plan to completion, it is not possible to simply take an ordinary query plan and run it using multiple workers. Each worker would produce a full copy of the output result set, so the query would not run any faster than normal but would produce incorrect results. Instead, the parallel portion of the plan must be what is known internally to the query optimizer as a &lt;em&gt;partial plan&lt;/em&gt;; that is, it must be constructed so that each process which executes the plan will generate only a subset of the output rows in such a way that each required output row is guaranteed to be generated by exactly one of the cooperating processes. Generally, this means that the scan on the driving table of the query must be a parallel-aware scan.</source>
          <target state="translated">因为每个工作人员都执行计划的并行部分直到完成，所以不可能简单地采用一个普通的查询计划并使用多个工作人员来运行它。每个工作人员都会生成输出结果集的完整副本，因此查询的运行速度不会比正常情况下快，但是会产生错误的结果。相反，计划的并行部分必须是查询优化器内部称为&lt;em&gt;部分计划&lt;/em&gt;的&lt;em&gt;部分&lt;/em&gt;；也就是说，必须进行构造，以使执行计划的每个流程将仅生成输出行的一个子集，以确保每个所需的输出行都由其中一个协作流程准确地生成。通常，这意味着对查询的驱动表的扫描必须是并行感知的扫描。</target>
        </trans-unit>
        <trans-unit id="f7c3975c53757320af8c077a7aa386b120a149d9" translate="yes" xml:space="preserve">
          <source>Because logical replication is based on a similar architecture as &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;physical streaming replication&lt;/a&gt;, the monitoring on a publication node is similar to monitoring of a physical replication master (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-MONITORING&quot;&gt;Section 26.2.5.2&lt;/a&gt;).</source>
          <target state="translated">因为逻辑复制基于与&lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;物理流复制&lt;/a&gt;类似的体系结构，所以对发布节点的监视类似于对物理复制主数据库的监视（请参见&lt;a href=&quot;warm-standby#STREAMING-REPLICATION-MONITORING&quot;&gt;26.2.5.2节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a2196adb2d7ec23f760e34a49d8237be649fa41e" translate="yes" xml:space="preserve">
          <source>Because of MVCC, it is always necessary to allow duplicate entries to exist physically in an index: the entries might refer to successive versions of a single logical row. The behavior we actually want to enforce is that no MVCC snapshot could include two rows with equal index keys. This breaks down into the following cases that must be checked when inserting a new row into a unique index:</source>
          <target state="translated">由于MVCC,总是需要允许重复的条目在索引中物理存在:这些条目可能指的是一个逻辑行的连续版本。我们实际要强制执行的行为是,任何MVCC快照都不能包含两个索引键相等的行。这分为以下几种情况,在向唯一索引中插入一条新行时必须进行检查。</target>
        </trans-unit>
        <trans-unit id="92df70087fcf249f647fdf27a084f1becf03071e" translate="yes" xml:space="preserve">
          <source>Because of limited &lt;code&gt;maintenance_work_mem&lt;/code&gt;, &lt;code&gt;ambulkdelete&lt;/code&gt; might need to be called more than once when many tuples are to be deleted. The &lt;code&gt;stats&lt;/code&gt; argument is the result of the previous call for this index (it is NULL for the first call within a &lt;code&gt;VACUUM&lt;/code&gt; operation). This allows the AM to accumulate statistics across the whole operation. Typically, &lt;code&gt;ambulkdelete&lt;/code&gt; will modify and return the same struct if the passed &lt;code&gt;stats&lt;/code&gt; is not null.</source>
          <target state="translated">由于 &lt;code&gt;maintenance_work_mem&lt;/code&gt; 的限制，要删除多个元组时，可能需要多次调用 &lt;code&gt;ambulkdelete&lt;/code&gt; 。的 &lt;code&gt;stats&lt;/code&gt; 参数是先前呼叫此索引的结果（它是一个内的第一呼叫NULL &lt;code&gt;VACUUM&lt;/code&gt; 操作）。这允许AM在整个操作中累积统计信息。通常，如果传递的 &lt;code&gt;stats&lt;/code&gt; 不为null ，则 &lt;code&gt;ambulkdelete&lt;/code&gt; 将修改并返回相同的结构。</target>
        </trans-unit>
        <trans-unit id="af06227e43627d5f9e3c80ba9b58e41dee4f1bd3" translate="yes" xml:space="preserve">
          <source>Because of the above rules, it is possible for an updating command to see an inconsistent snapshot: it can see the effects of concurrent updating commands on the same rows it is trying to update, but it does not see effects of those commands on other rows in the database. This behavior makes Read Committed mode unsuitable for commands that involve complex search conditions; however, it is just right for simpler cases. For example, consider updating bank balances with transactions like:</source>
          <target state="translated">由于上述规则,更新命令有可能看到一个不一致的快照:它可以看到并发更新命令对它试图更新的同一行的影响,但它看不到这些命令对数据库中其他行的影响。这种行为使得读取提交模式不适合涉及复杂搜索条件的命令;但是,对于简单的情况,它却恰到好处。例如,考虑用这样的事务更新银行余额。</target>
        </trans-unit>
        <trans-unit id="094a085e303baa417739feb6622a057e4139e4ba" translate="yes" xml:space="preserve">
          <source>Because of this behavior, it's unwise to give a function that takes a single composite-type argument the same name as any of the fields of that composite type. If there is ambiguity, the field-name interpretation will be chosen if field-name syntax is used, while the function will be chosen if function-call syntax is used. However, PostgreSQL versions before 11 always chose the field-name interpretation, unless the syntax of the call required it to be a function call. One way to force the function interpretation in older versions is to schema-qualify the function name, that is, write &lt;code&gt;schema.func(compositevalue)&lt;/code&gt;.</source>
          <target state="translated">由于这种行为，给一个采用单个复合类型实参与该复合类型的任何字段同名的函数是不明智的。如果存在歧义，如果使用字段名语法，则将选择字段名解释，而如果使用函数调用语法，则将选择函数。但是，PostgreSQL 11之前的版本始终选择字段名解释，除非调用的语法要求它是函数调用。在旧版本中强制进行函数解释的一种方法是对函数名称进行模式限定，即编写 &lt;code&gt;schema.func(compositevalue)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6916a8fbcc68029c3a341e8400e967ac545c917" translate="yes" xml:space="preserve">
          <source>Because of this behavior, putting more than one SQL command in a single &lt;code&gt;-c&lt;/code&gt; string often has unexpected results. It's better to use repeated &lt;code&gt;-c&lt;/code&gt; commands or feed multiple commands to psql's standard input, either using echo as illustrated above, or via a shell here-document, for example:</source>
          <target state="translated">由于这种行为，在单个 &lt;code&gt;-c&lt;/code&gt; 字符串中放置多个SQL命令通常会产生意外的结果。最好使用重复的 &lt;code&gt;-c&lt;/code&gt; 命令或将多个命令提供给psql的标准输入，例如使用上面说明的echo或通过shell here-document，例如：</target>
        </trans-unit>
        <trans-unit id="1e30503a8aa4dc4dd17e2394f194dfc73877aea7" translate="yes" xml:space="preserve">
          <source>Because of this convention of possibly renumbering OIDs assigned by patches, the OIDs assigned by a patch should not be considered stable until the patch has been included in an official release. We do not change manually-assigned object OIDs once released, however, as that would create assorted compatibility problems.</source>
          <target state="translated">由于这个惯例可能会对补丁分配的 OID 进行重新编号,因此在补丁被包含在正式发布的版本中之前,补丁分配的 OID 不应被视为稳定。然而,一旦发布,我们不会改变手动分配的对象OID,因为那会造成各种兼容性问题。</target>
        </trans-unit>
        <trans-unit id="167e13b17a2cb4d9e247d60e890e572062fe98da" translate="yes" xml:space="preserve">
          <source>Because of this indeterminacy, referencing other tables only within sub-selects is safer, though often harder to read and slower than using a join.</source>
          <target state="translated">由于这种不确定性,只在子选择中引用其他表是比较安全的,尽管通常比使用连接更难读,速度更慢。</target>
        </trans-unit>
        <trans-unit id="71a8fc6262b2555f78a8d5aeb3468844fc9b3fb8" translate="yes" xml:space="preserve">
          <source>Because optimizer statistics are not transferred by &lt;code&gt;pg_upgrade&lt;/code&gt;, you will be instructed to run a command to regenerate that information at the end of the upgrade. You might need to set connection parameters to match your new cluster.</source>
          <target state="translated">由于 &lt;code&gt;pg_upgrade&lt;/code&gt; 不会传输优化器统计信息，因此在升级结束时，系统将指示您运行命令以重新生成该信息。您可能需要设置连接参数以匹配新集群。</target>
        </trans-unit>
        <trans-unit id="c35cef2d44681e7faa9cdda9938f800f990d4dc8" translate="yes" xml:space="preserve">
          <source>Because pg_dump is used to transfer data to newer versions of PostgreSQL, the output of pg_dump can be expected to load into PostgreSQL server versions newer than pg_dump's version. pg_dump can also dump from PostgreSQL servers older than its own version. (Currently, servers back to version 8.0 are supported.) However, pg_dump cannot dump from PostgreSQL servers newer than its own major version; it will refuse to even try, rather than risk making an invalid dump. Also, it is not guaranteed that pg_dump's output can be loaded into a server of an older major version &amp;mdash; not even if the dump was taken from a server of that version. Loading a dump file into an older server may require manual editing of the dump file to remove syntax not understood by the older server. Use of the &lt;code&gt;--quote-all-identifiers&lt;/code&gt; option is recommended in cross-version cases, as it can prevent problems arising from varying reserved-word lists in different PostgreSQL versions.</source>
          <target state="translated">因为pg_dump用于将数据传输到PostgreSQL的较新版本，所以可以预期pg_dump的输出将加载到比pg_dump的版本新的PostgreSQL服务器版本中。 pg_dump也可以从比它自己的版本旧的PostgreSQL服务器中转储。 （当前支持回溯到8.0版的服务器。）但是，pg_dump不能从PostgreSQL服务器上转储比其主要版本更新的服务器。它将拒绝尝试，而不是冒险进行无效的转储。另外，不能保证pg_dump的输出可以加载到主版本较旧的服务器上-即使转储是从该版本的服务器上获取的也不行。将转储文件加载到旧服务器中可能需要手动编辑转储文件，以删除旧服务器无法理解的语法。使用的 &lt;code&gt;--quote-all-identifiers&lt;/code&gt; 在跨版本的情况下建议使用option选项，因为它可以防止由于不同PostgreSQL版本中的保留字列表不同而引起的问题。</target>
        </trans-unit>
        <trans-unit id="74ecae8ce7298adddc06312de549cde5a1f05bfd" translate="yes" xml:space="preserve">
          <source>Because roles can own database objects and can hold privileges to access other objects, dropping a role is often not just a matter of a quick &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt;. Any objects owned by the role must first be dropped or reassigned to other owners; and any permissions granted to the role must be revoked.</source>
          <target state="translated">因为角色可以拥有数据库对象并且可以拥有访问其他对象的特权，所以删除角色通常不仅仅是快速&lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE的问题&lt;/a&gt;。角色拥有的任何对象都必须首先删除或重新分配给其他所有者；并且授予该角色的所有权限都必须撤销。</target>
        </trans-unit>
        <trans-unit id="3c6bd276df7f7795dcf1ec012b5fa318dae1fa92" translate="yes" xml:space="preserve">
          <source>Because sequences are non-transactional, changes made by &lt;code&gt;setval&lt;/code&gt; are not undone if the transaction rolls back.</source>
          <target state="translated">因为序列是非事务性的，所以如果事务回滚，则 &lt;code&gt;setval&lt;/code&gt; 所做的更改不会撤消。</target>
        </trans-unit>
        <trans-unit id="045cb510a11b664aff1ae0f9d4a4e6bf852e98a6" translate="yes" xml:space="preserve">
          <source>Because that day was a spring-forward transition date in that time zone, there was no civil time instant 2:30AM; clocks jumped forward from 2AM EST to 3AM EDT. PostgreSQL interprets the given time as if it were standard time (UTC-5), which then renders as 3:30AM EDT (UTC-4).</source>
          <target state="translated">因为那一天是时区的春秋过渡日,所以没有民用时间2:30AM的瞬间;时钟从美国东部时间2AM跳到了东部时间3AM。PostgreSQL将给定的时间解释为标准时间(UTC-5),然后渲染为3:30AM EDT(UTC-4)。</target>
        </trans-unit>
        <trans-unit id="f0a1c41a7fd794b4e227af5602d5ab126f9a65b2" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;...&lt;/code&gt; operator is widely used in data sources, it is allowed as an alternative spelling of the &lt;code&gt;..&lt;/code&gt; operator. Unfortunately, this creates a parsing ambiguity: it is not clear whether the upper bound in &lt;code&gt;0...23&lt;/code&gt; is meant to be &lt;code&gt;23&lt;/code&gt; or &lt;code&gt;0.23&lt;/code&gt;. This is resolved by requiring at least one digit before the decimal point in all numbers in &lt;code&gt;seg&lt;/code&gt; input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4c15eb3326253a984503903ababbb5a012e0e63" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;Finalize Aggregate&lt;/code&gt; node runs on the leader process, queries which produce a relatively large number of groups in comparison to the number of input rows will appear less favorable to the query planner. For example, in the worst-case scenario the number of groups seen by the &lt;code&gt;Finalize Aggregate&lt;/code&gt; node could be as many as the number of input rows which were seen by all worker processes in the &lt;code&gt;Partial Aggregate&lt;/code&gt; stage. For such cases, there is clearly going to be no performance benefit to using parallel aggregation. The query planner takes this into account during the planning process and is unlikely to choose parallel aggregate in this scenario.</source>
          <target state="translated">由于 &lt;code&gt;Finalize Aggregate&lt;/code&gt; 节点是在领导者进程上运行的，因此与输入行数相比，产生相对大量组的查询对查询计划者而言不太有利。例如，在最坏的情况下，&amp;ldquo; &lt;code&gt;Finalize Aggregate&lt;/code&gt; 节点所看到的组数可能与&amp;ldquo; &lt;code&gt;Partial Aggregate&lt;/code&gt; 阶段中所有工作进程所看到的输入行数一样多。对于这种情况，使用并行聚合显然不会对性能产生任何好处。查询计划者在计划过程中会考虑到这一点，并且在这种情况下不太可能选择并行聚合。</target>
        </trans-unit>
        <trans-unit id="c37bfc8193816ef9726582311c95eb690d59a5d3" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;json&lt;/code&gt; type stores an exact copy of the input text, it will preserve semantically-insignificant white space between tokens, as well as the order of keys within JSON objects. Also, if a JSON object within the value contains the same key more than once, all the key/value pairs are kept. (The processing functions consider the last value as the operative one.) By contrast, &lt;code&gt;jsonb&lt;/code&gt; does not preserve white space, does not preserve the order of object keys, and does not keep duplicate object keys. If duplicate keys are specified in the input, only the last value is kept.</source>
          <target state="translated">因为 &lt;code&gt;json&lt;/code&gt; 类型存储输入文本的精确副本，所以它将保留标记之间语义上无关紧要的空白以及JSON对象中键的顺序。另外，如果值中的JSON对象包含相同的键不止一次，则所有键/值对都会保留。 （处理函数将最后一个值视为可操作的值。）相反， &lt;code&gt;jsonb&lt;/code&gt; 不会保留空格，不会保留对象键的顺序，也不会保留重复的对象键。如果在输入中指定了重复的键，则仅保留最后一个值。</target>
        </trans-unit>
        <trans-unit id="a2b58f4e608829c960ebd5345ab5c69ff0a6f48c" translate="yes" xml:space="preserve">
          <source>Because the cache is shared by all the databases, there will normally be pages from relations not belonging to the current database. This means that there may not be matching join rows in &lt;code&gt;pg_class&lt;/code&gt; for some rows, or that there could even be incorrect joins. If you are trying to join against &lt;code&gt;pg_class&lt;/code&gt;, it's a good idea to restrict the join to rows having &lt;code&gt;reldatabase&lt;/code&gt; equal to the current database's OID or zero.</source>
          <target state="translated">因为所有数据库都共享高速缓存，所以通常会有不属于当前数据库的关系中的页面。这意味着在 &lt;code&gt;pg_class&lt;/code&gt; 中对于某些行可能没有匹配的联接行，或者甚至可能有不正确的联接。如果您要针对 &lt;code&gt;pg_class&lt;/code&gt; 进行 &lt;code&gt;reldatabase&lt;/code&gt; ，则最好将联接限制为reldatabase等于当前数据库的OID或零的行。</target>
        </trans-unit>
        <trans-unit id="db3d427c20974c56be935e79b307fe146f033de0" translate="yes" xml:space="preserve">
          <source>Because the data directory contains all the data stored in the database, it is essential that it be secured from unauthorized access. &lt;code&gt;initdb&lt;/code&gt; therefore revokes access permissions from everyone but the PostgreSQL user, and optionally, group. Group access, when enabled, is read-only. This allows an unprivileged user in the same group as the cluster owner to take a backup of the cluster data or perform other operations that only require read access.</source>
          <target state="translated">由于数据目录包含数据库中存储的所有数据，因此必须防止未经授权的访问，这是至关重要的。因此， &lt;code&gt;initdb&lt;/code&gt; 撤消了除PostgreSQL用户（以及可选的组）以外的所有用户的访问权限。组访问（如果启用）是只读的。这允许与群集所有者在同一组中的非特权用户进行群集数据的备份或执行仅需要读取访问权限的其他操作。</target>
        </trans-unit>
        <trans-unit id="1b1433bfc602856fd35d38e930969e2b25fd0ae1" translate="yes" xml:space="preserve">
          <source>Because the index machinery does not check access permissions on functions before using them, including a function or operator in an operator class is tantamount to granting public execute permission on it. This is usually not an issue for the sorts of functions that are useful in an operator class.</source>
          <target state="translated">由于索引机制在使用函数之前并不检查函数的访问权限,所以在一个操作符类中包含一个函数或操作符就等于授予它公共执行权限。对于操作符类中有用的各类函数来说,这通常不是问题。</target>
        </trans-unit>
        <trans-unit id="12e05e286bda0df5f833a009aa68ad96a2c3e153" translate="yes" xml:space="preserve">
          <source>Because the index machinery does not check access permissions on functions before using them, including a function or operator in an operator family is tantamount to granting public execute permission on it. This is usually not an issue for the sorts of functions that are useful in an operator family.</source>
          <target state="translated">由于索引机制在使用函数之前并不检查函数的访问权限,因此将一个函数或操作符包含在操作符族中就等于授予它公共执行权限。对于操作符族中有用的函数种类,这通常不是问题。</target>
        </trans-unit>
        <trans-unit id="05ce34a0d540aca4ce52a5f0344a9da290661688" translate="yes" xml:space="preserve">
          <source>Because the number of possible column combinations is very large, it's impractical to compute multivariate statistics automatically. Instead, &lt;em&gt;extended statistics objects&lt;/em&gt;, more often called just &lt;em&gt;statistics objects&lt;/em&gt;, can be created to instruct the server to obtain statistics across interesting sets of columns.</source>
          <target state="translated">由于可能的列组合数量非常多，因此自动计算多元统计信息是不切实际的。取而代之的是，可以创建&lt;em&gt;扩展的统计对象&lt;/em&gt;（通常称为&lt;em&gt;统计对象）&lt;/em&gt;，以指示服务器跨有趣的列集获取统计信息。</target>
        </trans-unit>
        <trans-unit id="4d0acad31e5ac16c376a00a683ae533e823a54c5" translate="yes" xml:space="preserve">
          <source>Because the planner records statistics about the ordering of tables, it is advisable to run &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; on the newly clustered table. Otherwise, the planner might make poor choices of query plans.</source>
          <target state="translated">因为计划者记录了有关表顺序的统计信息，所以建议在新的群集表上运行&lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt;。否则，计划者可能会选择错误的查询计划。</target>
        </trans-unit>
        <trans-unit id="2d35897de153aa519a54a8b8fb6f5606c68e7ee1" translate="yes" xml:space="preserve">
          <source>Because the two-argument version of &lt;code&gt;to_tsvector&lt;/code&gt; was used in the index above, only a query reference that uses the 2-argument version of &lt;code&gt;to_tsvector&lt;/code&gt; with the same configuration name will use that index. That is, &lt;code&gt;WHERE to_tsvector('english', body) @@ 'a &amp;amp; b'&lt;/code&gt; can use the index, but &lt;code&gt;WHERE to_tsvector(body) @@ 'a &amp;amp; b'&lt;/code&gt; cannot. This ensures that an index will be used only with the same configuration used to create the index entries.</source>
          <target state="translated">因为在上面的索引中使用了 &lt;code&gt;to_tsvector&lt;/code&gt; 的两个参数的版本，所以只有使用具有相同配置名称的 &lt;code&gt;to_tsvector&lt;/code&gt; 的两个参数的查询引用才可以使用该索引。也就是说， &lt;code&gt;WHERE to_tsvector('english', body) @@ 'a &amp;amp; b'&lt;/code&gt; 可以使用索引，而 &lt;code&gt;WHERE to_tsvector(body) @@ 'a &amp;amp; b'&lt;/code&gt; 则不能使用索引。这样可以确保仅将索引与创建索引条目所使用的配置相同。</target>
        </trans-unit>
        <trans-unit id="3db556aa68ed6f557f519e10166a776c7f49e136" translate="yes" xml:space="preserve">
          <source>Because there are no restrictions on use of a data type once it's been created, creating a base type or range type is tantamount to granting public execute permission on the functions mentioned in the type definition. This is usually not an issue for the sorts of functions that are useful in a type definition. But you might want to think twice before designing a type in a way that would require &amp;ldquo;secret&amp;rdquo; information to be used while converting it to or from external form.</source>
          <target state="translated">因为一旦创建数据类型就没有使用限制，所以创建基本类型或范围类型无异于授予对类型定义中提到的函数的公共执行权限。对于类型定义中有用的各种函数来说，这通常不是问题。但是您可能需要三思而后行，在设计一种类型时，需要一种在将其转换为外部形式或从外部形式转换时使用&amp;ldquo;秘密&amp;rdquo;信息的方式。</target>
        </trans-unit>
        <trans-unit id="21ceed46db3017cd5cd38ced3fddd77a8ce650db" translate="yes" xml:space="preserve">
          <source>Because these functions return detailed page-level information, access is restricted by default. By default, only the role &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; has &lt;code&gt;EXECUTE&lt;/code&gt; privilege. Superusers of course bypass this restriction. After the extension has been installed, users may issue &lt;code&gt;GRANT&lt;/code&gt; commands to change the privileges on the functions to allow others to execute them. However, it might be preferable to add those users to the &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; role instead.</source>
          <target state="translated">由于这些函数返回详细的页面级信息，因此默认情况下限制访问。默认情况下，只有角色 &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; 具有 &lt;code&gt;EXECUTE&lt;/code&gt; 特权。超级用户当然会绕过此限制。安装扩展程序后，用户可以发出 &lt;code&gt;GRANT&lt;/code&gt; 命令来更改功能的特权，以允许其他人执行它们。但是，最好将这些用户添加到 &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; 角色。</target>
        </trans-unit>
        <trans-unit id="cab3b5bbab6ef84f87ff0c28b63da48ab8adbf53" translate="yes" xml:space="preserve">
          <source>Because user identities are cluster-wide, &lt;code&gt;pg_auth_members&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_auth_members&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">因为用户身份在整个群集范围内， &lt;code&gt;pg_auth_members&lt;/code&gt; 在群集的所有数据库之间共享：每个群集只有一个 &lt;code&gt;pg_auth_members&lt;/code&gt; 副本，而不是每个数据库一个。</target>
        </trans-unit>
        <trans-unit id="0a9b4bf1d549fcf042c9f5eb8f3493cb9cfe27e7" translate="yes" xml:space="preserve">
          <source>Because user identities are cluster-wide, &lt;code&gt;pg_authid&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_authid&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">由于用户身份在整个群集范围内，因此 &lt;code&gt;pg_authid&lt;/code&gt; 在群集的所有数据库之间共享：每个群集只有一个 &lt;code&gt;pg_authid&lt;/code&gt; 副本，而不是每个数据库一个。</target>
        </trans-unit>
        <trans-unit id="b7824c0664ad3fb70745076ae899f66946c9584d" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 8.1, the arguments of the sequence functions were of type &lt;code&gt;text&lt;/code&gt;, not &lt;code&gt;regclass&lt;/code&gt;, and the above-described conversion from a text string to an OID value would happen at run time during each call. For backward compatibility, this facility still exists, but internally it is now handled as an implicit coercion from &lt;code&gt;text&lt;/code&gt; to &lt;code&gt;regclass&lt;/code&gt; before the function is invoked.</source>
          <target state="translated">在PostgreSQL 8.1之前，序列函数的参数是 &lt;code&gt;text&lt;/code&gt; 类型，而不是 &lt;code&gt;regclass&lt;/code&gt; 类型，并且上述描述从文本字符串到OID值的转换将在每次调用时在运行时发生。为了向后兼容，此功能仍然存在，但是在内部，在调用函数之前，现在将其作为从 &lt;code&gt;text&lt;/code&gt; 到 &lt;code&gt;regclass&lt;/code&gt; 的隐式强制处理。</target>
        </trans-unit>
        <trans-unit id="5fe2f878504da2e1db73277f0e33ea8b96b5ad9c" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 8.2, the &lt;code&gt;.*&lt;/code&gt; syntax was not expanded in row constructors, so that writing &lt;code&gt;ROW(t.*, 42)&lt;/code&gt; created a two-field row whose first field was another row value. The new behavior is usually more useful. If you need the old behavior of nested row values, write the inner row value without &lt;code&gt;.*&lt;/code&gt;, for instance &lt;code&gt;ROW(t, 42)&lt;/code&gt;.</source>
          <target state="translated">在PostgreSQL 8.2之前， &lt;code&gt;.*&lt;/code&gt; 语法没有在行构造函数中扩展，因此编写 &lt;code&gt;ROW(t.*, 42)&lt;/code&gt; 创建了一个两字段行，其第一个字段是另一个行值。新行为通常更有用。如果您需要旧的嵌套行值行为，请编写不带 &lt;code&gt;.*&lt;/code&gt; 的内部行值，例如 &lt;code&gt;ROW(t, 42)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e8d01c186f775230385d810745e30ede0c0292d2" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 8.2, the containment operators &lt;code&gt;@&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;@&lt;/code&gt; were respectively called &lt;code&gt;~&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt;. These names are still available, but are deprecated and will eventually be removed.</source>
          <target state="translated">在PostgreSQL 8.2之前，包含运算符 &lt;code&gt;@&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;@&lt;/code&gt; 分别称为 &lt;code&gt;~&lt;/code&gt; 和 &lt;code&gt;@&lt;/code&gt; 。这些名称仍然可用，但已过时，最终将被删除。</target>
        </trans-unit>
        <trans-unit id="c036ccc0fef09aace79d8f72b4bc4956e2e6b969" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 8.3, these functions would silently accept values of several non-string data types as well, due to the presence of implicit coercions from those data types to &lt;code&gt;text&lt;/code&gt;. Those coercions have been removed because they frequently caused surprising behaviors. However, the string concatenation operator (&lt;code&gt;||&lt;/code&gt;) still accepts non-string input, so long as at least one input is of a string type, as shown in &lt;a href=&quot;functions-string#FUNCTIONS-STRING-SQL&quot;&gt;Table 9.9&lt;/a&gt;. For other cases, insert an explicit coercion to &lt;code&gt;text&lt;/code&gt; if you need to duplicate the previous behavior.</source>
          <target state="translated">在PostgreSQL 8.3之前，由于存在从这些数据类型到 &lt;code&gt;text&lt;/code&gt; 的隐式强制，这些函数也将静默接受几种非字符串数据类型的值。这些强制已被删除，因为它们经常引起令人惊讶的行为。但是，字符串连接运算符（ &lt;code&gt;||&lt;/code&gt; ）仍接受非字符串输入，只要至少一个输入为字符串类型即可，如&lt;a href=&quot;functions-string#FUNCTIONS-STRING-SQL&quot;&gt;表9.9&lt;/a&gt;所示。对于其他情况，如果您需要复制以前的行为，请在 &lt;code&gt;text&lt;/code&gt; 插入显式强制。</target>
        </trans-unit>
        <trans-unit id="3b8019c3d24fcdf13fb68d8305a1528d20dff010" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 8.4, psql allowed the first argument of a single-letter backslash command to start directly after the command, without intervening whitespace. Now, some whitespace is required.</source>
          <target state="translated">在PostgreSQL 8.4之前,psql允许单字母反斜杠命令的第一个参数直接在命令后面开始,而不需要中间的空白。现在,需要一些空格。</target>
        </trans-unit>
        <trans-unit id="95fbf31e963d4b484912ba157149b28d1649f2d4" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 8.4, the &lt;code&gt;OPERATOR&lt;/code&gt; clause could include a &lt;code&gt;RECHECK&lt;/code&gt; option. This is no longer supported because whether an index operator is &amp;ldquo;lossy&amp;rdquo; is now determined on-the-fly at run time. This allows efficient handling of cases where an operator might or might not be lossy.</source>
          <target state="translated">在PostgreSQL 8.4之前， &lt;code&gt;OPERATOR&lt;/code&gt; 子句可以包含 &lt;code&gt;RECHECK&lt;/code&gt; 选项。不再支持此操作，因为现在可以在运行时即时确定索引运算符是否&amp;ldquo;有损&amp;rdquo;。这样可以有效地处理操作员可能会或可能不会有损失的情况。</target>
        </trans-unit>
        <trans-unit id="5824a92b6b2740af57b007a3a86225a310d091b7" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 9.6, &lt;code&gt;pg_am&lt;/code&gt; contained many additional columns representing properties of index access methods. That data is now only directly visible at the C code level. However, &lt;code&gt;pg_index_column_has_property()&lt;/code&gt; and related functions have been added to allow SQL queries to inspect index access method properties; see &lt;a href=&quot;functions-info#FUNCTIONS-INFO-CATALOG-TABLE&quot;&gt;Table 9.68&lt;/a&gt;.</source>
          <target state="translated">在PostgreSQL 9.6之前， &lt;code&gt;pg_am&lt;/code&gt; 包含许多其他列，它们代表索引访问方法的属性。现在，该数据仅在C代码级别直接可见。但是，已添加 &lt;code&gt;pg_index_column_has_property()&lt;/code&gt; 和相关函数，以允许SQL查询检查索引访问方法的属性。见&lt;a href=&quot;functions-info#FUNCTIONS-INFO-CATALOG-TABLE&quot;&gt;表9.68&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a4765a073d10eb89d73b00161ddb8dddb0be1ef8" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 9.6, SQL commands in script files were terminated by newlines, and so they could not be continued across lines. Now a semicolon is &lt;em&gt;required&lt;/em&gt; to separate consecutive SQL commands (though a SQL command does not need one if it is followed by a meta command). If you need to create a script file that works with both old and new versions of pgbench, be sure to write each SQL command on a single line ending with a semicolon.</source>
          <target state="translated">在PostgreSQL 9.6之前，脚本文件中的SQL命令以换行符终止，因此不能跨行继续。现在，&lt;em&gt;需要&lt;/em&gt;使用分号来分隔连续的SQL命令（尽管如果SQL命令后面跟有meta命令，则&lt;em&gt;不需要&lt;/em&gt;一个分号）。如果您需要创建一个适用于新旧版本pgbench的脚本文件，请确保将每条SQL命令写在以分号结尾的一行上。</target>
        </trans-unit>
        <trans-unit id="25a91312b02bab209e6a6f9a691f6a084f05d75d" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 9.6, the &lt;code&gt;-c&lt;/code&gt; option implied &lt;code&gt;-X&lt;/code&gt; (&lt;code&gt;--no-psqlrc&lt;/code&gt;); this is no longer the case.</source>
          <target state="translated">在PostgreSQL 9.6之前， &lt;code&gt;-c&lt;/code&gt; 选项暗含 &lt;code&gt;-X&lt;/code&gt; （ &lt;code&gt;--no-psqlrc&lt;/code&gt; ）; 这已不再是这种情况。</target>
        </trans-unit>
        <trans-unit id="e88cb3afc9e7c5edbb82c8ba3662818b28a3aaef" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL had the &lt;code&gt;INCLUDE&lt;/code&gt; feature, people sometimes made covering indexes by writing the payload columns as ordinary index columns, that is writing</source>
          <target state="translated">在PostgreSQL具有 &lt;code&gt;INCLUDE&lt;/code&gt; 功能之前，人们有时通过将有效载荷列写为普通索引列来覆盖索引，即</target>
        </trans-unit>
        <trans-unit id="b6ecfe47fb55ef8a0352cf146e2122df69c11049" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL version 8.2, the shell-type creation syntax &lt;code&gt;CREATE TYPE name&lt;/code&gt; did not exist. The way to create a new base type was to create its input function first. In this approach, PostgreSQL will first see the name of the new data type as the return type of the input function. The shell type is implicitly created in this situation, and then it can be referenced in the definitions of the remaining I/O functions. This approach still works, but is deprecated and might be disallowed in some future release. Also, to avoid accidentally cluttering the catalogs with shell types as a result of simple typos in function definitions, a shell type will only be made this way when the input function is written in C.</source>
          <target state="translated">在PostgreSQL 8.2版之前，shell类型创建语法 &lt;code&gt;CREATE TYPE name&lt;/code&gt; 不存在。创建新基本类型的方法是先创建其输入函数。通过这种方法，PostgreSQL首先会看到新数据类型的名称作为输入函数的返回类型。在这种情况下将隐式创建shell类型，然后可以在其余I / O函数的定义中引用它。该方法仍然有效，但已被弃用，并且在将来的某些发行版中可能不允许使用。另外，为避免由于函数定义中的简单错字而导致shell类型的目录意外地混乱，仅当输入函数用C编写时，才以这种方式创建shell类型。</target>
        </trans-unit>
        <trans-unit id="133cff6a54d531aaca5754e3dd9245f0764b14c3" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL version 8.3, the &lt;code&gt;SET&lt;/code&gt; clause was not available, and so older functions may contain rather complicated logic to save, set, and restore &lt;code&gt;search_path&lt;/code&gt;. The &lt;code&gt;SET&lt;/code&gt; clause is far easier to use for this purpose.</source>
          <target state="translated">在PostgreSQL 8.3版之前， &lt;code&gt;SET&lt;/code&gt; 子句不可用，因此较早的函数可能包含相当复杂的逻辑来保存，设置和恢复 &lt;code&gt;search_path&lt;/code&gt; 。在 &lt;code&gt;SET&lt;/code&gt; 子句是更容易使用这个目的。</target>
        </trans-unit>
        <trans-unit id="d40dc4e81bdd5f6ad72cddc10364e0a47323f2d2" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL version 8.3, the name of a generated array type was always exactly the element type's name with one underscore character (&lt;code&gt;_&lt;/code&gt;) prepended. (Type names were therefore restricted in length to one less character than other names.) While this is still usually the case, the array type name may vary from this in case of maximum-length names or collisions with user type names that begin with underscore. Writing code that depends on this convention is therefore deprecated. Instead, use &lt;code&gt;pg_type&lt;/code&gt;.&lt;code&gt;typarray&lt;/code&gt; to locate the array type associated with a given type.</source>
          <target state="translated">在PostgreSQL 8.3版之前，生成的数组类型的名称始终与元素类型的名称完全相同，并带有一个下划线字符（ &lt;code&gt;_&lt;/code&gt; ）。 （因此，类型名称的长度不得超过其他名称一个字符。）虽然通常仍是这种情况，但在最大长度名称或与以下划线开头的用户类型名称冲突的情况下，数组类型名称可能与此有所不同。 。因此，不赞成依赖此约定编写代码。而是使用 &lt;code&gt;pg_type&lt;/code&gt; 。 &lt;code&gt;typarray&lt;/code&gt; 查找与给定类型关联的数组类型。</target>
        </trans-unit>
        <trans-unit id="6cde500737c3794e75266509d120c3f451ce96fd" translate="yes" xml:space="preserve">
          <source>Before anyone can access the database, you must start the database server. The database server program is called &lt;code&gt;postgres&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96a33375376d06d4d560a6a1c1041e7d31e19935" translate="yes" xml:space="preserve">
          <source>Before anyone can access the database, you must start the database server. The database server program is called &lt;code&gt;postgres&lt;/code&gt;. The &lt;code&gt;postgres&lt;/code&gt; program must know where to find the data it is supposed to use. This is done with the &lt;code&gt;-D&lt;/code&gt; option. Thus, the simplest way to start the server is:</source>
          <target state="translated">在任何人都可以访问数据库之前，您必须启动数据库服务器。数据库服务器程序称为 &lt;code&gt;postgres&lt;/code&gt; 。该 &lt;code&gt;postgres&lt;/code&gt; 程序必须知道在哪里可以找到它应该使用数据。这是通过 &lt;code&gt;-D&lt;/code&gt; 选项完成的。因此，启动服务器的最简单方法是：</target>
        </trans-unit>
        <trans-unit id="222bfa6cd0afdad9a2e9f50eb2cacfa866429974" translate="yes" xml:space="preserve">
          <source>Before doing so, the function should check the sign of &lt;code&gt;offset&lt;/code&gt;: if it is less than zero, raise error &lt;code&gt;ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE&lt;/code&gt; (22013) with error text like &amp;ldquo;invalid preceding or following size in window function&amp;rdquo;. (This is required by the SQL standard, although nonstandard operator families might perhaps choose to ignore this restriction, since there seems to be little semantic necessity for it.) This requirement is delegated to the &lt;code&gt;in_range&lt;/code&gt; function so that the core code needn't understand what &amp;ldquo;less than zero&amp;rdquo; means for a particular data type.</source>
          <target state="translated">在执行此操作之前，函数应检查 &lt;code&gt;offset&lt;/code&gt; 的符号：如果偏移量小于零，则引发错误 &lt;code&gt;ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE&lt;/code&gt; （22013），并带有诸如&amp;ldquo;窗口函数中的前或后尺寸无效&amp;rdquo;之类的错误文本。 （这是SQL标准所必需的，尽管非标准的运算符家族可能选择忽略此限制，因为似乎没有语义上的必要性。）此要求委托给 &lt;code&gt;in_range&lt;/code&gt; 函数，因此核心代码无需理解对于特定的数据类型，&amp;ldquo;小于零&amp;rdquo;意味着什么。</target>
        </trans-unit>
        <trans-unit id="9433a751fdf2c9c611a9f86077418abf326bf14a" translate="yes" xml:space="preserve">
          <source>Before restoring an SQL dump, all the users who own objects or were granted permissions on objects in the dumped database must already exist. If they do not, the restore will fail to recreate the objects with the original ownership and/or permissions. (Sometimes this is what you want, but usually it is not.)</source>
          <target state="translated">在恢复SQL转储之前,所有拥有对象或被授予转储数据库中对象权限的用户必须已经存在。如果他们不存在,则还原将无法以原始所有权和/或权限重新创建对象。(有时这是你想要的,但通常不是。)</target>
        </trans-unit>
        <trans-unit id="5350218eee7862579014da56e03f9c4a8c7df37f" translate="yes" xml:space="preserve">
          <source>Before running the &lt;code&gt;ATTACH PARTITION&lt;/code&gt; command, it is recommended to create a &lt;code&gt;CHECK&lt;/code&gt; constraint on the table to be attached matching the desired partition constraint. That way, the system will be able to skip the scan to validate the implicit partition constraint. Without the &lt;code&gt;CHECK&lt;/code&gt; constraint, the table will be scanned to validate the partition constraint while holding an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock on that partition and a &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock on the parent table. It may be desired to drop the redundant &lt;code&gt;CHECK&lt;/code&gt; constraint after &lt;code&gt;ATTACH PARTITION&lt;/code&gt; is finished.</source>
          <target state="translated">在运行 &lt;code&gt;ATTACH PARTITION&lt;/code&gt; 命令之前，建议在要附加的表上创建与所需分区约束匹配的 &lt;code&gt;CHECK&lt;/code&gt; 约束。这样，系统将能够跳过扫描以验证隐式分区约束。如果没有 &lt;code&gt;CHECK&lt;/code&gt; 约束，则将扫描表以验证分区约束，同时在该分区上保留 &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; 锁，并在父表上保持 &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; 锁。在 &lt;code&gt;ATTACH PARTITION&lt;/code&gt; 完成后，可能需要删除冗余的 &lt;code&gt;CHECK&lt;/code&gt; 约束。</target>
        </trans-unit>
        <trans-unit id="0534112e08b3f377dcff7dae34fa42dedf03836d" translate="yes" xml:space="preserve">
          <source>Before running the &lt;code&gt;ATTACH PARTITION&lt;/code&gt; command, it is recommended to create a &lt;code&gt;CHECK&lt;/code&gt; constraint on the table to be attached matching the desired partition constraint. That way, the system will be able to skip the scan which is otherwise needed to validate the implicit partition constraint. Without the &lt;code&gt;CHECK&lt;/code&gt; constraint, the table will be scanned to validate the partition constraint while holding an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock on that partition and a &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock on the parent table. It may be desired to drop the redundant &lt;code&gt;CHECK&lt;/code&gt; constraint after &lt;code&gt;ATTACH PARTITION&lt;/code&gt; is finished.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cd8ecaf3b3090d8469e126e6ec0aadfd531ece9" translate="yes" xml:space="preserve">
          <source>Before we proceed, you should understand the basic PostgreSQL system architecture. Understanding how the parts of PostgreSQL interact will make this chapter somewhat clearer.</source>
          <target state="translated">在我们继续之前,你应该了解PostgreSQL的基本系统架构。了解PostgreSQL的各个部分是如何相互作用的,会使本章更加清晰。</target>
        </trans-unit>
        <trans-unit id="2bd6b34f5ab63eba4552e311eedb5465ee67a88a" translate="yes" xml:space="preserve">
          <source>Before you can do anything, you must initialize a database storage area on disk. We call this a &lt;em&gt;database cluster&lt;/em&gt;. (The SQL standard uses the term catalog cluster.) A database cluster is a collection of databases that is managed by a single instance of a running database server. After initialization, a database cluster will contain a database named &lt;code&gt;postgres&lt;/code&gt;, which is meant as a default database for use by utilities, users and third party applications. The database server itself does not require the &lt;code&gt;postgres&lt;/code&gt; database to exist, but many external utility programs assume it exists. Another database created within each cluster during initialization is called &lt;code&gt;template1&lt;/code&gt;. As the name suggests, this will be used as a template for subsequently created databases; it should not be used for actual work. (See &lt;a href=&quot;https://www.postgresql.org/docs/12/managing-databases.html&quot;&gt;Chapter 22&lt;/a&gt; for information about creating new databases within a cluster.)</source>
          <target state="translated">在执行任何操作之前，必须初始化磁盘上的数据库存储区域。我们称其为&lt;em&gt;数据库集群&lt;/em&gt;。 （SQL标准使用术语目录集群。）数据库集群是由运行中的数据库服务器的单个实例管理的数据库的集合。初始化之后，数据库集群将包含一个名为 &lt;code&gt;postgres&lt;/code&gt; 的数据库，这是公用程序，用户和第三方应用程序使用的默认数据库。数据库服务器本身不需要 &lt;code&gt;postgres&lt;/code&gt; 数据库存在，但是许多外部实用程序都假定它存在。在初始化期间在每个集群中创建的另一个数据库称为 &lt;code&gt;template1&lt;/code&gt; 。顾名思义，它将用作后续创建的数据库的模板；它不应该用于实际工作。（有关在群集中创建新数据库的信息，请参见&lt;a href=&quot;https://www.postgresql.org/docs/12/managing-databases.html&quot;&gt;第22章&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="80b6d48dacb8cea98d5f49fb8a5fb0ff5e17a88f" translate="yes" xml:space="preserve">
          <source>Before you can do anything, you must initialize a database storage area on disk. We call this a &lt;em&gt;database cluster&lt;/em&gt;. (The SQL standard uses the term catalog cluster.) A database cluster is a collection of databases that is managed by a single instance of a running database server. After initialization, a database cluster will contain a database named &lt;code&gt;postgres&lt;/code&gt;, which is meant as a default database for use by utilities, users and third party applications. The database server itself does not require the &lt;code&gt;postgres&lt;/code&gt; database to exist, but many external utility programs assume it exists. Another database created within each cluster during initialization is called &lt;code&gt;template1&lt;/code&gt;. As the name suggests, this will be used as a template for subsequently created databases; it should not be used for actual work. (See &lt;a href=&quot;https://www.postgresql.org/docs/13/managing-databases.html&quot;&gt;Chapter 22&lt;/a&gt; for information about creating new databases within a cluster.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5021e6ec2c149bc593346cdbced55fdf083dae8" translate="yes" xml:space="preserve">
          <source>Before you can use &lt;code&gt;CREATE EXTENSION&lt;/code&gt; to load an extension into a database, the extension's supporting files must be installed. Information about installing the extensions supplied with PostgreSQL can be found in &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;Additional Supplied Modules&lt;/a&gt;.</source>
          <target state="translated">必须先安装扩展的支持文件，然后才能使用 &lt;code&gt;CREATE EXTENSION&lt;/code&gt; 将扩展加载到数据库中。有关安装PostgreSQL附带的扩展的信息，可以在&amp;ldquo; &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;其他提供的模块&amp;rdquo;中&lt;/a&gt;找到。</target>
        </trans-unit>
        <trans-unit id="083511ee8f3db20d9fdeeef0f34879a74ab033ad" translate="yes" xml:space="preserve">
          <source>Before you can use &lt;code&gt;CREATE EXTENSION&lt;/code&gt; to load an extension into a database, the extension's supporting files must be installed. Information about installing the extensions supplied with PostgreSQL can be found in &lt;a href=&quot;https://www.postgresql.org/docs/13/contrib.html&quot;&gt;Additional Supplied Modules&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b42b034c7e4f7289aaf07ce4a58233afbf01dc95" translate="yes" xml:space="preserve">
          <source>Before you can use PostgreSQL you need to install it, of course. It is possible that PostgreSQL is already installed at your site, either because it was included in your operating system distribution or because the system administrator already installed it. If that is the case, you should obtain information from the operating system documentation or your system administrator about how to access PostgreSQL.</source>
          <target state="translated">在你使用PostgreSQL之前,你当然需要安装它。有可能PostgreSQL已经安装在你的网站上,因为它已经包含在你的操作系统发行版中,或者因为系统管理员已经安装了它。如果是这种情况,你应该从操作系统文档或系统管理员那里获得关于如何访问PostgreSQL的信息。</target>
        </trans-unit>
        <trans-unit id="b26dbac1aa32ad5c0e931ef76f5f13b493f4cca5" translate="yes" xml:space="preserve">
          <source>Begin recovery on the standby server from the local WAL archive, using &lt;code&gt;restore_command&lt;/code&gt; that waits as described previously (see &lt;a href=&quot;continuous-archiving#BACKUP-PITR-RECOVERY&quot;&gt;Section 25.3.4&lt;/a&gt;).</source>
          <target state="translated">使用如前所述等待的 &lt;code&gt;restore_command&lt;/code&gt; 从本地WAL存档开始在备用服务器上进行恢复（请参阅&lt;a href=&quot;continuous-archiving#BACKUP-PITR-RECOVERY&quot;&gt;第25.3.4节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b089abb1b8e490f01578f107a306004e919d4fa6" translate="yes" xml:space="preserve">
          <source>Begin streaming changes from the logical replication slot specified by &lt;code&gt;--slot&lt;/code&gt;, continuing until terminated by a signal. If the server side change stream ends with a server shutdown or disconnect, retry in a loop unless &lt;code&gt;--no-loop&lt;/code&gt; is specified.</source>
          <target state="translated">从 &lt;code&gt;--slot&lt;/code&gt; 指定的逻辑复制插槽开始流式传输更改，一直持续到信号终止为止。如果服务器端更改流以服务器关闭或断开连接结束，则除非指定了 &lt;code&gt;--no-loop&lt;/code&gt; ,否则请循环尝试。</target>
        </trans-unit>
        <trans-unit id="5723f3fda46717e1c7feda49b72b28e567ff2c36" translate="yes" xml:space="preserve">
          <source>Begin the output with a command to create the database itself and reconnect to the created database. (With a script of this form, it doesn't matter which database in the destination installation you connect to before running the script.) If &lt;code&gt;--clean&lt;/code&gt; is also specified, the script drops and recreates the target database before reconnecting to it.</source>
          <target state="translated">从命令开始输出，以创建数据库本身并重新连接到创建的数据库。（使用这种形式的脚本，在运行脚本之前连接到目标安装中的哪个数据库都没有关系。）如果还指定了 &lt;code&gt;--clean&lt;/code&gt; ，则脚本会删除并在重新连接目标数据库之前重新创建它。</target>
        </trans-unit>
        <trans-unit id="039cd3e67eb5290833876444452a3461967b021e" translate="yes" xml:space="preserve">
          <source>Beginning in PostgreSQL 9.1, these index types also support index searches for &lt;code&gt;LIKE&lt;/code&gt; and &lt;code&gt;ILIKE&lt;/code&gt;, for example</source>
          <target state="translated">从PostgreSQL 9.1开始，这些索引类型还支持对 &lt;code&gt;LIKE&lt;/code&gt; 和 &lt;code&gt;ILIKE&lt;/code&gt; 的索引搜索，例如</target>
        </trans-unit>
        <trans-unit id="50f6ae535e6d21e272577a4aeb90ccdf9bd1fc99" translate="yes" xml:space="preserve">
          <source>Beginning in PostgreSQL 9.3, these index types also support index searches for regular-expression matches (&lt;code&gt;~&lt;/code&gt; and &lt;code&gt;~*&lt;/code&gt; operators), for example</source>
          <target state="translated">从PostgreSQL 9.3开始，这些索引类型还支持对正则表达式匹配（ &lt;code&gt;~&lt;/code&gt; 和 &lt;code&gt;~*&lt;/code&gt; 运算符）的索引搜索，例如</target>
        </trans-unit>
        <trans-unit id="e18ae86eb6dacc56f3e992def21c4e72f662c365" translate="yes" xml:space="preserve">
          <source>Behaves just like the &lt;code&gt;pg_logical_slot_get_changes()&lt;/code&gt; function, except that changes are not consumed; that is, they will be returned again on future calls.</source>
          <target state="translated">行为与 &lt;code&gt;pg_logical_slot_get_changes()&lt;/code&gt; 函数类似，但不消耗更改；也就是说，它们将在以后的通话中再次返回。</target>
        </trans-unit>
        <trans-unit id="2cc29d4604bab2d23897cf42e9aa658714f98b76" translate="yes" xml:space="preserve">
          <source>Behaves just like the &lt;code&gt;pg_logical_slot_get_changes()&lt;/code&gt; function, except that changes are returned as &lt;code&gt;bytea&lt;/code&gt; and that changes are not consumed; that is, they will be returned again on future calls.</source>
          <target state="translated">行为与 &lt;code&gt;pg_logical_slot_get_changes()&lt;/code&gt; 函数类似，不同之处在于，更改是作为 &lt;code&gt;bytea&lt;/code&gt; 返回的，并且不消耗更改；也就是说，它们将在以后的通话中再次返回。</target>
        </trans-unit>
        <trans-unit id="0d8b3d76c539629fdd464e88d07fda0a141c2719" translate="yes" xml:space="preserve">
          <source>Behaves just like the &lt;code&gt;pg_logical_slot_get_changes()&lt;/code&gt; function, except that changes are returned as &lt;code&gt;bytea&lt;/code&gt;.</source>
          <target state="translated">行为类似于 &lt;code&gt;pg_logical_slot_get_changes()&lt;/code&gt; 函数，除了更改以 &lt;code&gt;bytea&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="52757979ec3d8a6995e55b22d0069c2c9da4e33a" translate="yes" xml:space="preserve">
          <source>Behaves just like the &lt;code&gt;pg_logical_slot_peek_changes()&lt;/code&gt; function, except that changes are returned as &lt;code&gt;bytea&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10e28951f118886fb1db9aad1518cc8230f657d1" translate="yes" xml:space="preserve">
          <source>Behaves similarly to &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt;, except that it acquires a shared lock rather than exclusive lock on each retrieved row. A shared lock blocks other transactions from performing &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; or &lt;code&gt;SELECT FOR NO KEY UPDATE&lt;/code&gt; on these rows, but it does not prevent them from performing &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; or &lt;code&gt;SELECT FOR KEY SHARE&lt;/code&gt;.</source>
          <target state="translated">行为与 &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt; 相似，不同之处在于它在每个检索到的行上获取一个共享锁而不是互斥锁。共享锁可以阻止其他事务在这些行上执行 &lt;code&gt;UPDATE&lt;/code&gt; ， &lt;code&gt;DELETE&lt;/code&gt; ， &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 或 &lt;code&gt;SELECT FOR NO KEY UPDATE&lt;/code&gt; ，但是不会阻止它们执行 &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; 或 &lt;code&gt;SELECT FOR KEY SHARE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4166e40468956f25d587c502c88de582346f3e60" translate="yes" xml:space="preserve">
          <source>Behaves similarly to &lt;code&gt;FOR SHARE&lt;/code&gt;, except that the lock is weaker: &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; is blocked, but not &lt;code&gt;SELECT FOR NO KEY UPDATE&lt;/code&gt;. A key-shared lock blocks other transactions from performing &lt;code&gt;DELETE&lt;/code&gt; or any &lt;code&gt;UPDATE&lt;/code&gt; that changes the key values, but not other &lt;code&gt;UPDATE&lt;/code&gt;, and neither does it prevent &lt;code&gt;SELECT FOR NO KEY UPDATE&lt;/code&gt;, &lt;code&gt;SELECT FOR SHARE&lt;/code&gt;, or &lt;code&gt;SELECT FOR KEY SHARE&lt;/code&gt;.</source>
          <target state="translated">行为与 &lt;code&gt;FOR SHARE&lt;/code&gt; 类似，除了锁较弱： &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 被阻止，而不是 &lt;code&gt;SELECT FOR NO KEY UPDATE&lt;/code&gt; 。一个关键的共享锁定块其它事务执行 &lt;code&gt;DELETE&lt;/code&gt; 或任何 &lt;code&gt;UPDATE&lt;/code&gt; 改变密钥值，而不是其他 &lt;code&gt;UPDATE&lt;/code&gt; ，并且它也不防止 &lt;code&gt;SELECT FOR NO KEY UPDATE&lt;/code&gt; ， &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; 或 &lt;code&gt;SELECT FOR KEY SHARE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3975839e55e061601c3038a505012e75c26cc40" translate="yes" xml:space="preserve">
          <source>Behaves similarly to &lt;code&gt;FOR UPDATE&lt;/code&gt;, except that the lock acquired is weaker: this lock will not block &lt;code&gt;SELECT FOR KEY SHARE&lt;/code&gt; commands that attempt to acquire a lock on the same rows. This lock mode is also acquired by any &lt;code&gt;UPDATE&lt;/code&gt; that does not acquire a &lt;code&gt;FOR UPDATE&lt;/code&gt; lock.</source>
          <target state="translated">行为与 &lt;code&gt;FOR UPDATE&lt;/code&gt; 类似，除了获取的锁较弱：此锁不会阻止试图获取同一行上的锁的 &lt;code&gt;SELECT FOR KEY SHARE&lt;/code&gt; 命令。任何不获取 &lt;code&gt;FOR UPDATE&lt;/code&gt; 锁定的 &lt;code&gt;UPDATE&lt;/code&gt; 也会获取此锁定模式。</target>
        </trans-unit>
        <trans-unit id="bfbd41304878c2d772d5d897e0245d1caed66504" translate="yes" xml:space="preserve">
          <source>Behavior of B-Tree Operator Classes</source>
          <target state="translated">B-Tree操作类的行为</target>
        </trans-unit>
        <trans-unit id="126af5216968b8a395d1e58cbc6d82b4d656f6fb" translate="yes" xml:space="preserve">
          <source>Below is a larger example of how this feature can be used in production environments. The table &lt;code&gt;passwd&lt;/code&gt; emulates a Unix password file:</source>
          <target state="translated">下面是在生产环境中如何使用此功能的更大示例。表 &lt;code&gt;passwd&lt;/code&gt; 模拟Unix密码文件：</target>
        </trans-unit>
        <trans-unit id="7fca4fa390ed5f3e5c9eff1ebae50bc1ae5a07f1" translate="yes" xml:space="preserve">
          <source>Below we create a dictionary and bind some token types to an astronomical thesaurus and English stemmer:</source>
          <target state="translated">下面我们创建一个字典,并将一些令牌类型绑定到天文词库和英语干货上。</target>
        </trans-unit>
        <trans-unit id="870f5d9661b7407b932b1598182f5f2d810cf9fe" translate="yes" xml:space="preserve">
          <source>Benchmarking Options</source>
          <target state="translated">基准选择</target>
        </trans-unit>
        <trans-unit id="2fb7c98fc75cb4f79b347af89afb1652e417df34" translate="yes" xml:space="preserve">
          <source>Besides the configuration parameters documented in &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt;, there are a few that can only be adjusted using the &lt;code&gt;SET&lt;/code&gt; command or that have a special syntax:</source>
          <target state="translated">除了&lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;第19章中介绍&lt;/a&gt;的配置参数外，还有一些只能使用 &lt;code&gt;SET&lt;/code&gt; 命令进行调整或具有特殊语法的参数：</target>
        </trans-unit>
        <trans-unit id="ef6d7a0bd27a4a7a7898b15686b3e50c0c08dc1a" translate="yes" xml:space="preserve">
          <source>Besides the configuration parameters documented in &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt;, there are a few that can only be adjusted using the &lt;code&gt;SET&lt;/code&gt; command or that have a special syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcdcdb56c299825a17bc63b94d508dafd4fc2a95" translate="yes" xml:space="preserve">
          <source>Between (inclusive of the range endpoints).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6c66d70ecd66ce14264e1d077f56c53c9c3ae8a" translate="yes" xml:space="preserve">
          <source>Between, after sorting the two endpoint values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60abe3d5ae299760f0dd57db1ab7b6b69b7cc66b" translate="yes" xml:space="preserve">
          <source>Beware that recent releases of macOS ignore attempts to set &lt;code&gt;SHMMAX&lt;/code&gt; to a value that isn't an exact multiple of 4096.</source>
          <target state="translated">请注意，最新发行的macOS会忽略将 &lt;code&gt;SHMMAX&lt;/code&gt; 设置为不是4096的整数倍的值的尝试。</target>
        </trans-unit>
        <trans-unit id="b80b5f7ca59611a24bc9604afc3876b56110cee0" translate="yes" xml:space="preserve">
          <source>Beware that the &lt;code&gt;ROWS&lt;/code&gt; mode can produce unpredictable results if the &lt;code&gt;ORDER BY&lt;/code&gt; ordering does not order the rows uniquely. The &lt;code&gt;RANGE&lt;/code&gt; and &lt;code&gt;GROUPS&lt;/code&gt; modes are designed to ensure that rows that are peers in the &lt;code&gt;ORDER BY&lt;/code&gt; ordering are treated alike: all rows of a given peer group will be in the frame or excluded from it.</source>
          <target state="translated">请注意，如果 &lt;code&gt;ORDER BY&lt;/code&gt; 排序不能唯一地对行进行排序，则 &lt;code&gt;ROWS&lt;/code&gt; 模式可能会产生不可预测的结果。的 &lt;code&gt;RANGE&lt;/code&gt; 和 &lt;code&gt;GROUPS&lt;/code&gt; 的模式被设计成确保行是在对等体 &lt;code&gt;ORDER BY&lt;/code&gt; 排序被处理一样：一个给定的对等体组中的所有行会在框架或从中排除。</target>
        </trans-unit>
        <trans-unit id="774be1cf4f3a522f1a25f2b6316b0d501136298e" translate="yes" xml:space="preserve">
          <source>Beware that this approach can fail if the outer query level contains additional processing, such as a join, because that might cause the subquery's output to be reordered before the aggregate is computed.</source>
          <target state="translated">要注意的是,如果外层查询层包含额外的处理,如连接,这种方法可能会失败,因为这可能会导致子查询的输出在汇总计算之前被重新排序。</target>
        </trans-unit>
        <trans-unit id="619d65e1ae1a2704aa306451ac2a75a0cde345a8" translate="yes" xml:space="preserve">
          <source>Bibliography</source>
          <target state="translated">Bibliography</target>
        </trans-unit>
        <trans-unit id="4afac498b0186c05ae272a50fdfb777d86f83f5a" translate="yes" xml:space="preserve">
          <source>Big Five</source>
          <target state="translated">五大</target>
        </trans-unit>
        <trans-unit id="05792c2e47b633979450a4d3fdc731bebb67e917" translate="yes" xml:space="preserve">
          <source>Binary Data Types</source>
          <target state="translated">二进制数据类型</target>
        </trans-unit>
        <trans-unit id="d978fc265919867464402ead8b5aa5056e5fbd19" translate="yes" xml:space="preserve">
          <source>Binary Data Types: bytea</source>
          <target state="translated">二进制数据类型:bytea</target>
        </trans-unit>
        <trans-unit id="be10328dd5eb2024df80c19f0915f781f57e2ed4" translate="yes" xml:space="preserve">
          <source>Binary Format</source>
          <target state="translated">二进制格式</target>
        </trans-unit>
        <trans-unit id="eea185b10ff34a7d0730fbc39d8d1573222be81b" translate="yes" xml:space="preserve">
          <source>Binary String Functions and Operators</source>
          <target state="translated">二进制字符串函数和运算符</target>
        </trans-unit>
        <trans-unit id="cbcfd399e3b6e28f48b32806c48d9294b5084ef2" translate="yes" xml:space="preserve">
          <source>Binary String: bit_length</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8dff4368de0e3c40124e448acd2ca6783cd44df" translate="yes" xml:space="preserve">
          <source>Binary String: btrim</source>
          <target state="translated">二进制字符串:btrim</target>
        </trans-unit>
        <trans-unit id="3d3110a88c097ff95d0ceb59cb2d12b59b1aeb9f" translate="yes" xml:space="preserve">
          <source>Binary String: convert</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af8938914c9b70ca934924b934ba9839025c7024" translate="yes" xml:space="preserve">
          <source>Binary String: convert_from</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e921f5d76c05cb18ae66971b494afa6830c1fe08" translate="yes" xml:space="preserve">
          <source>Binary String: convert_to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dab4683aaea619005a4200cd9a5215872f4f193a" translate="yes" xml:space="preserve">
          <source>Binary String: decode</source>
          <target state="translated">二进制字符串:解码</target>
        </trans-unit>
        <trans-unit id="1bb599e86584900c656608c4be089126932fb4ca" translate="yes" xml:space="preserve">
          <source>Binary String: encode</source>
          <target state="translated">二进制字符串:编码</target>
        </trans-unit>
        <trans-unit id="ed9e62f8973e5d6bffd91187c9e478de6423b5ec" translate="yes" xml:space="preserve">
          <source>Binary String: get_bit</source>
          <target state="translated">二进制字符串:get_bit</target>
        </trans-unit>
        <trans-unit id="a7dc78314758d39820bb026c008feb884ce531ff" translate="yes" xml:space="preserve">
          <source>Binary String: get_byte</source>
          <target state="translated">二进制字符串:get_byte</target>
        </trans-unit>
        <trans-unit id="3b3dfd58346ed838c2d28b9b46ab8febf746666b" translate="yes" xml:space="preserve">
          <source>Binary String: length</source>
          <target state="translated">二进制字符串:长度</target>
        </trans-unit>
        <trans-unit id="3d6bb6f2a913f2fe4e19cd19b79eb492e8027877" translate="yes" xml:space="preserve">
          <source>Binary String: md5</source>
          <target state="translated">二进制字符串:md5</target>
        </trans-unit>
        <trans-unit id="2b6e00319f3a8699a801221f672b9e6fae165f94" translate="yes" xml:space="preserve">
          <source>Binary String: octet_length</source>
          <target state="translated">二进制字符串:octet_length</target>
        </trans-unit>
        <trans-unit id="549d7f8bb245593c2f0ec51b5eecfcb99bfc4c36" translate="yes" xml:space="preserve">
          <source>Binary String: overlay</source>
          <target state="translated">二进制字符串:覆盖</target>
        </trans-unit>
        <trans-unit id="317470b7465e50bb01ea0ed9d647db9aa1569cbc" translate="yes" xml:space="preserve">
          <source>Binary String: position</source>
          <target state="translated">二进制字符串:位置</target>
        </trans-unit>
        <trans-unit id="9434d0dc118c447e4ee164199720303685e8f31a" translate="yes" xml:space="preserve">
          <source>Binary String: set_bit</source>
          <target state="translated">二进制字符串:set_bit</target>
        </trans-unit>
        <trans-unit id="f39a20b22ec73f10ccf2ff12ede513b3bf197e16" translate="yes" xml:space="preserve">
          <source>Binary String: set_byte</source>
          <target state="translated">二进制字符串:set_byte</target>
        </trans-unit>
        <trans-unit id="edd1f7f5db831e55c4404df9e415cec21d97ca8d" translate="yes" xml:space="preserve">
          <source>Binary String: sha224</source>
          <target state="translated">二进制字符串:sha224</target>
        </trans-unit>
        <trans-unit id="a4e5fd05bd7c2057fbb588451d73bc8e364bcd00" translate="yes" xml:space="preserve">
          <source>Binary String: sha256</source>
          <target state="translated">二进制字符串:sha256</target>
        </trans-unit>
        <trans-unit id="199ba90dac671366fc2d30018bc9cc60da6d8112" translate="yes" xml:space="preserve">
          <source>Binary String: sha384</source>
          <target state="translated">二进制字符串:sha384</target>
        </trans-unit>
        <trans-unit id="b17b7742692d6cc8900d5a09fbba1ba2dcf79e2d" translate="yes" xml:space="preserve">
          <source>Binary String: sha512</source>
          <target state="translated">二进制字符串:sha512</target>
        </trans-unit>
        <trans-unit id="138398c9ed1548fd9d09e373d02441ec780c3dba" translate="yes" xml:space="preserve">
          <source>Binary String: substr</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb754287eb3b8d22b0752ef54dea23d275538097" translate="yes" xml:space="preserve">
          <source>Binary String: substring</source>
          <target state="translated">二进制字符串:子串</target>
        </trans-unit>
        <trans-unit id="0880194133ad39b402dac81c879f4881bf8922df" translate="yes" xml:space="preserve">
          <source>Binary String: trim</source>
          <target state="translated">二进制字符串:修剪</target>
        </trans-unit>
        <trans-unit id="4b19a17003e3a215c61a3139f7843b960e175e71" translate="yes" xml:space="preserve">
          <source>Binary String: ||</source>
          <target state="translated">二进制字符串。||</target>
        </trans-unit>
        <trans-unit id="c41bc309d8cd529592e339f0c36e8e967a2fed13" translate="yes" xml:space="preserve">
          <source>Binary cursors are a PostgreSQL extension.</source>
          <target state="translated">二进制游标是PostgreSQL的一个扩展。</target>
        </trans-unit>
        <trans-unit id="6b44f09a82f5b765933694a9db3f15e511f15291" translate="yes" xml:space="preserve">
          <source>Binary cursors should be used carefully. Many applications, including psql, are not prepared to handle binary cursors and expect data to come back in the text format.</source>
          <target state="translated">二进制游标应该谨慎使用。许多应用程序,包括psql,都没有准备好处理二进制游标,而是希望数据以文本格式返回。</target>
        </trans-unit>
        <trans-unit id="253c59e522f194890c38a49fa034c56d5597e5ce" translate="yes" xml:space="preserve">
          <source>Bit 16</source>
          <target state="translated">位16</target>
        </trans-unit>
        <trans-unit id="b304e502a60fe2721a2acc2ea86477e058a5fc18" translate="yes" xml:space="preserve">
          <source>Bit String Functions and Operators</source>
          <target state="translated">位串函数和运算符</target>
        </trans-unit>
        <trans-unit id="e1ec8af5ed0ac3706706e7ca0257fb8472997bd9" translate="yes" xml:space="preserve">
          <source>Bit String Types</source>
          <target state="translated">位串类型</target>
        </trans-unit>
        <trans-unit id="26d5338edfde42da5636b07f3a1f7b3b99348954" translate="yes" xml:space="preserve">
          <source>Bit String: #</source>
          <target state="translated">Bit String:#</target>
        </trans-unit>
        <trans-unit id="54a89e1d14e86ab43af7735b61c206ac06fd6632" translate="yes" xml:space="preserve">
          <source>Bit String: &amp;amp;</source>
          <target state="translated">位字符串：＆</target>
        </trans-unit>
        <trans-unit id="25bf3896db23b3430dc3419d701ee4519f795bf6" translate="yes" xml:space="preserve">
          <source>Bit String: &amp;gt;&amp;gt;</source>
          <target state="translated">位字符串：&amp;gt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d52a6739aec041222c397e3ab3508452bbdace4c" translate="yes" xml:space="preserve">
          <source>Bit String: &amp;lt;&amp;lt;</source>
          <target state="translated">位字符串：&amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="698c5053f7fb4235a075904b83c81d0e7f75e767" translate="yes" xml:space="preserve">
          <source>Bit String: B&amp;#x27;10001&amp;#x27; # B&amp;#x27;01101&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fec3321c838e2393b12b6d782dae5847bd67b84" translate="yes" xml:space="preserve">
          <source>Bit String: B&amp;#x27;10001&amp;#x27; &amp;amp; B&amp;#x27;01101&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f80854d98441f5f666a756550418ab3915bb0869" translate="yes" xml:space="preserve">
          <source>Bit String: B&amp;#x27;10001&amp;#x27; &amp;gt;&amp;gt; 2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="020f62b450e6a960545b1de75bca157ae03bc7a2" translate="yes" xml:space="preserve">
          <source>Bit String: B&amp;#x27;10001&amp;#x27; &amp;lt;&amp;lt; 3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edcb968f9fd9173bd5d0d4f8617eb3f6d27f69c3" translate="yes" xml:space="preserve">
          <source>Bit String: B&amp;#x27;10001&amp;#x27; | B&amp;#x27;01101&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="292bdc723b3de75f45f35aaf3b8989a7fc5eb2b2" translate="yes" xml:space="preserve">
          <source>Bit String: bit_length</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="918db4fa99e0649c8060902f9a3e94ba75c279e0" translate="yes" xml:space="preserve">
          <source>Bit String: get_bit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6891e5dceae12938ae30b567970719872fccde2c" translate="yes" xml:space="preserve">
          <source>Bit String: length</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f5f6f7cb2e1bc80a507138569c25bed2001e0f1" translate="yes" xml:space="preserve">
          <source>Bit String: octet_length</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00634ec6386463ae42b1b7bb26891e1338c4b35c" translate="yes" xml:space="preserve">
          <source>Bit String: overlay</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a0d8c1cd0116787005f4bee7aff429712b20961" translate="yes" xml:space="preserve">
          <source>Bit String: position</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f3120e8f7e91a683313ad8017d180967d09509" translate="yes" xml:space="preserve">
          <source>Bit String: set_bit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb70e33ea681844ee935ae674a0a87b670e898dd" translate="yes" xml:space="preserve">
          <source>Bit String: substring</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e47fbeeacb2ccb2058a0e13885d27607dc2ff89" translate="yes" xml:space="preserve">
          <source>Bit String: |</source>
          <target state="translated">Bit String:</target>
        </trans-unit>
        <trans-unit id="a9f58217517f242096405bc47fb766301ddb90d4" translate="yes" xml:space="preserve">
          <source>Bit String: ||</source>
          <target state="translated">位串。||</target>
        </trans-unit>
        <trans-unit id="fb535d3c1297857f6c6638c764b59c16782c04dd" translate="yes" xml:space="preserve">
          <source>Bit String: ~</source>
          <target state="translated">比特字符串。~</target>
        </trans-unit>
        <trans-unit id="91c158702eba7e22d8c0b8480c6181f06bc8d6e5" translate="yes" xml:space="preserve">
          <source>Bit String: ~ B&amp;#x27;10001&amp;#x27;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2efae331bc5aa821406a784a6e78c0b9daf6c7df" translate="yes" xml:space="preserve">
          <source>Bit mask identifying trigger firing conditions</source>
          <target state="translated">位掩码识别触发点火条件</target>
        </trans-unit>
        <trans-unit id="35edcdbad2868d30fa30834e2406d3005ac8363c" translate="yes" xml:space="preserve">
          <source>Bit strings are strings of 1's and 0's. They can be used to store or visualize bit masks. There are two SQL bit types: &lt;code&gt;bit(n)&lt;/code&gt; and &lt;code&gt;bit varying(n)&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is a positive integer.</source>
          <target state="translated">位字符串是1和0的字符串。它们可用于存储或可视化位掩码。SQL有两种SQL位类型： &lt;code&gt;bit(n)&lt;/code&gt; 和 &lt;code&gt;bit varying(n)&lt;/code&gt; ，其中 &lt;code&gt;n&lt;/code&gt; 是一个正整数。</target>
        </trans-unit>
        <trans-unit id="440588c03e76a6dbf3a0dad3d94ffb56eaf0107d" translate="yes" xml:space="preserve">
          <source>Bit-string constants look like regular string constants with a &lt;code&gt;B&lt;/code&gt; (upper or lower case) immediately before the opening quote (no intervening whitespace), e.g., &lt;code&gt;B'1001'&lt;/code&gt;. The only characters allowed within bit-string constants are &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">位字符串常量看起来像正则字符串常量，在开引号之前（没有中间空格）带有 &lt;code&gt;B&lt;/code&gt; （大写或小写），例如 &lt;code&gt;B'1001'&lt;/code&gt; 。位字符串常量中唯一允许的字符是 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef8b2561e514bdc32792b41e10c969f64c960716" translate="yes" xml:space="preserve">
          <source>Bit-string types</source>
          <target state="translated">位串类型</target>
        </trans-unit>
        <trans-unit id="3119bee988c6c128ef1a7a4d003a2772fc4ae36a" translate="yes" xml:space="preserve">
          <source>BitmapAnd and BitmapOr nodes always report their actual row counts as zero, due to implementation limitations.</source>
          <target state="translated">由于实现上的限制,BitmapAnd和BitmapOr节点总是报告它们的实际行数为零。</target>
        </trans-unit>
        <trans-unit id="17e80e5f71e9b85954b350f117d4dfeb3c5cf70a" translate="yes" xml:space="preserve">
          <source>Bitwise AND</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2461564dd1b0dd1dfe10a6e27226bb4f00cb800c" translate="yes" xml:space="preserve">
          <source>Bitwise AND (inputs must be of equal length)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="136c3a93310929e09124297eaf66ab9f3782d009" translate="yes" xml:space="preserve">
          <source>Bitwise NOT</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4be0adcfa81c37e1e7bbf2e23630f30974d164f" translate="yes" xml:space="preserve">
          <source>Bitwise OR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3a7a98dcaae40a13757076e24af311dfee77860" translate="yes" xml:space="preserve">
          <source>Bitwise OR (inputs must be of equal length)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74269e9a4eb117ac43a93ed74bc3c8cd96fd4ff4" translate="yes" xml:space="preserve">
          <source>Bitwise XOR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ba80ac4bf1c4bbad0f4a7d6ddfd25841835e177" translate="yes" xml:space="preserve">
          <source>Bitwise exclusive OR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d16eb5b05790cd70e7dd8947da148a14b1c3b585" translate="yes" xml:space="preserve">
          <source>Bitwise exclusive OR (inputs must be of equal length)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8659c0b8789aa4ee715f09528a9e4eecaaa826e" translate="yes" xml:space="preserve">
          <source>Bitwise shift left</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b90f67d593a4af9275c5c94d26eb0e231cb737a" translate="yes" xml:space="preserve">
          <source>Bitwise shift left (string length is preserved)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50231ce6a71d579851db8fdf27b3184364b82e41" translate="yes" xml:space="preserve">
          <source>Bitwise shift right</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b8813dffcb464fd01e7635b2efefa7c701a1bc5" translate="yes" xml:space="preserve">
          <source>Bitwise shift right (string length is preserved)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bfd5b423062918623ca47aa91c65abf2e858720" translate="yes" xml:space="preserve">
          <source>Bloat</source>
          <target state="translated">Bloat</target>
        </trans-unit>
        <trans-unit id="6f50e3e14cce1a8627751575e909b4caa4d3a6a3" translate="yes" xml:space="preserve">
          <source>Bloom is better than btree in handling this type of search:</source>
          <target state="translated">Bloom在处理这类搜索方面比btree要好。</target>
        </trans-unit>
        <trans-unit id="a6a6cc1c6c34e00f61be8a8c251a0e48237ab0a0" translate="yes" xml:space="preserve">
          <source>Blowfish</source>
          <target state="translated">Blowfish</target>
        </trans-unit>
        <trans-unit id="92c882ac33d0ee2cd51460d3e115370fb18b7f64" translate="yes" xml:space="preserve">
          <source>Blowfish cipher</source>
          <target state="translated">河豚密码</target>
        </trans-unit>
        <trans-unit id="38d26af6e5082bc6e784c3815947a0f5acecada7" translate="yes" xml:space="preserve">
          <source>Blowfish crypt</source>
          <target state="translated">河豚地穴</target>
        </trans-unit>
        <trans-unit id="17d54f2a65a51558dd8c1f3e789157750ff7d6f8" translate="yes" xml:space="preserve">
          <source>Blowfish-based, variant 2a</source>
          <target state="translated">吹鱼型,变体2a</target>
        </trans-unit>
        <trans-unit id="58299c5eb711f9a461ff1240fa8b1c0679ab5056" translate="yes" xml:space="preserve">
          <source>Boolean AND</source>
          <target state="translated">布尔型和</target>
        </trans-unit>
        <trans-unit id="c69f2185492e832f7277d3fff7b42d01f558fb61" translate="yes" xml:space="preserve">
          <source>Boolean NOT</source>
          <target state="translated">布尔型非</target>
        </trans-unit>
        <trans-unit id="2c320907721a13b5dd2b75f194044bf4fb118e32" translate="yes" xml:space="preserve">
          <source>Boolean OR</source>
          <target state="translated">布尔型OR</target>
        </trans-unit>
        <trans-unit id="54bd3ce38554ce1715613858323d1049c39c0685" translate="yes" xml:space="preserve">
          <source>Boolean Type</source>
          <target state="translated">布尔型</target>
        </trans-unit>
        <trans-unit id="9656fd514386a9028815794334d9467f9f5a0c5e" translate="yes" xml:space="preserve">
          <source>Boolean Type: boolean</source>
          <target state="translated">布尔型:布尔型</target>
        </trans-unit>
        <trans-unit id="d602b755186d61e697c04da0a7d821ff7d4efa39" translate="yes" xml:space="preserve">
          <source>Boolean aggregates &lt;code&gt;bool_and&lt;/code&gt; and &lt;code&gt;bool_or&lt;/code&gt; correspond to standard SQL aggregates &lt;code&gt;every&lt;/code&gt; and &lt;code&gt;any&lt;/code&gt; or &lt;code&gt;some&lt;/code&gt;. As for &lt;code&gt;any&lt;/code&gt; and &lt;code&gt;some&lt;/code&gt;, it seems that there is an ambiguity built into the standard syntax:</source>
          <target state="translated">布尔聚集 &lt;code&gt;bool_and&lt;/code&gt; 和 &lt;code&gt;bool_or&lt;/code&gt; 对应标准的SQL聚集 &lt;code&gt;every&lt;/code&gt; 和 &lt;code&gt;any&lt;/code&gt; 或 &lt;code&gt;some&lt;/code&gt; 。对于 &lt;code&gt;any&lt;/code&gt; 和 &lt;code&gt;some&lt;/code&gt; ，似乎有内置的标准语法歧义：</target>
        </trans-unit>
        <trans-unit id="e7e48e64bd944bf0341a3c4f226c0c85bf62984d" translate="yes" xml:space="preserve">
          <source>Boolean constants can be represented in SQL queries by the SQL key words &lt;code&gt;TRUE&lt;/code&gt;, &lt;code&gt;FALSE&lt;/code&gt;, and &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">布尔常量可以在SQL查询中用SQL关键字 &lt;code&gt;TRUE&lt;/code&gt; ， &lt;code&gt;FALSE&lt;/code&gt; 和 &lt;code&gt;NULL&lt;/code&gt; 表示。</target>
        </trans-unit>
        <trans-unit id="52e1ee47a7ff1168010b326824ee21ddfeae28c3" translate="yes" xml:space="preserve">
          <source>Boolean types</source>
          <target state="translated">布尔类型</target>
        </trans-unit>
        <trans-unit id="fa793a8aacedef81b06cc550c19f522284580fd4" translate="yes" xml:space="preserve">
          <source>Boolean value tests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec240e7050d6f871548eb16c80190949f2f4c3c5" translate="yes" xml:space="preserve">
          <source>Boolean values can also be tested using the predicates</source>
          <target state="translated">布尔值也可以使用谓词</target>
        </trans-unit>
        <trans-unit id="61e93ae531636a2f7c54ab2267a73987c4067669" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;CHECK&lt;/code&gt; and &lt;code&gt;NOT NULL&lt;/code&gt; constraints of a partitioned table are always inherited by all its partitions. &lt;code&gt;CHECK&lt;/code&gt; constraints that are marked &lt;code&gt;NO INHERIT&lt;/code&gt; are not allowed to be created on partitioned tables.</source>
          <target state="translated">这两种 &lt;code&gt;CHECK&lt;/code&gt; 和 &lt;code&gt;NOT NULL&lt;/code&gt; 分区表的约束总是被它的所有分区继承。标记为 &lt;code&gt;NO INHERIT&lt;/code&gt; 的 &lt;code&gt;CHECK&lt;/code&gt; 约束不允许在分区表上创建。</target>
        </trans-unit>
        <trans-unit id="b889ca8993198c7004a576b1cf90c434b540954c" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;target&lt;/code&gt; can be any non-null string, with a maximum of 255 characters. The cost parameters specify how much to charge for a character insertion, deletion, or substitution, respectively. You can omit the cost parameters, as in the second version of the function; in that case they all default to 1.</source>
          <target state="translated">两个 &lt;code&gt;source&lt;/code&gt; 和 &lt;code&gt;target&lt;/code&gt; 可以是任何非空串，具有最多255个字符。费用参数分别指定对字符插入，删除或替换收取多少费用。您可以省略成本参数，如该函数的第二个版本中所示。在这种情况下，它们都默认为1。</target>
        </trans-unit>
        <trans-unit id="5ea32d54e6cfd34abb39f16058fc4fd6f2961804" translate="yes" xml:space="preserve">
          <source>Both advisory locks and regular locks are stored in a shared memory pool whose size is defined by the configuration variables &lt;a href=&quot;runtime-config-locks#GUC-MAX-LOCKS-PER-TRANSACTION&quot;&gt;max_locks_per_transaction&lt;/a&gt; and &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;. Care must be taken not to exhaust this memory or the server will be unable to grant any locks at all. This imposes an upper limit on the number of advisory locks grantable by the server, typically in the tens to hundreds of thousands depending on how the server is configured.</source>
          <target state="translated">咨询锁和常规锁都存储在共享内存池中，该共享内存池的大小由配置变量&lt;a href=&quot;runtime-config-locks#GUC-MAX-LOCKS-PER-TRANSACTION&quot;&gt;max_locks_per_transaction&lt;/a&gt;和&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;定义。必须注意不要耗尽此内存，否则服务器将根本无法授予任何锁定。这对服务器可授予的咨询锁的数量施加了上限，通常取决于服务器的配置方式，通常为数万至数十万。</target>
        </trans-unit>
        <trans-unit id="64fe65c7e1e3e888472be5adaa2902cc6b0a1a3b" translate="yes" xml:space="preserve">
          <source>Both forms of bit-string constant can be continued across lines in the same way as regular string constants. Dollar quoting cannot be used in a bit-string constant.</source>
          <target state="translated">这两种形式的位串常量都可以像普通字符串常量一样跨行延续。位串常量中不能使用美元引号。</target>
        </trans-unit>
        <trans-unit id="2b41d8e55f4edf059d0388795bf4f266c2e06c3f" translate="yes" xml:space="preserve">
          <source>Both minmax and inclusion operator classes support cross-data-type operators, though with these the dependencies become more complicated. The minmax operator class requires a full set of operators to be defined with both arguments having the same data type. It allows additional data types to be supported by defining extra sets of operators. Inclusion operator class operator strategies are dependent on another operator strategy as shown in &lt;a href=&quot;brin-extensibility#BRIN-EXTENSIBILITY-INCLUSION-TABLE&quot;&gt;Table 67.3&lt;/a&gt;, or the same operator strategy as themselves. They require the dependency operator to be defined with the &lt;code&gt;STORAGE&lt;/code&gt; data type as the left-hand-side argument and the other supported data type to be the right-hand-side argument of the supported operator. See &lt;code&gt;float4_minmax_ops&lt;/code&gt; as an example of minmax, and &lt;code&gt;box_inclusion_ops&lt;/code&gt; as an example of inclusion.</source>
          <target state="translated">minmax和include运算符类都支持跨数据类型的运算符，尽管这些依赖关系变得更加复杂。 minmax运算符类要求使用两个具有相同数据类型的参数来定义完整的运算符集。通过定义额外的运算符集，它允许支持其他数据类型。包含运算符类别的运算符策略取决于&lt;a href=&quot;brin-extensibility#BRIN-EXTENSIBILITY-INCLUSION-TABLE&quot;&gt;表67.3中&lt;/a&gt;所示的另一个运算符策略，或与它们自己相同的运算符策略。它们要求将依赖项运算符定义为 &lt;code&gt;STORAGE&lt;/code&gt; 数据类型作为左侧参数，将其他受支持的数据类型定义为所支持运算符的右侧参数。请参见 &lt;code&gt;float4_minmax_ops&lt;/code&gt; 作为minmax的示例，以及 &lt;code&gt;box_inclusion_ops&lt;/code&gt; 作为包含示例。</target>
        </trans-unit>
        <trans-unit id="d935d6e4440b7d13db8dea9774a168802ac598e0" translate="yes" xml:space="preserve">
          <source>Both star symbols and simple words can be quantified to restrict how many labels they can match:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b6bb44fe8014c95fc406791cc963af10b33bb29" translate="yes" xml:space="preserve">
          <source>Both the maximum precision and the maximum scale of a &lt;code&gt;numeric&lt;/code&gt; column can be configured. To declare a column of type &lt;code&gt;numeric&lt;/code&gt; use the syntax:</source>
          <target state="translated">可以配置 &lt;code&gt;numeric&lt;/code&gt; 列的最大精度和最大比例。要声明 &lt;code&gt;numeric&lt;/code&gt; 类型的列，请使用以下语法：</target>
        </trans-unit>
        <trans-unit id="ea3fb61640ce7586a68af124013d79c4c57b81a1" translate="yes" xml:space="preserve">
          <source>Both the scan position and the mark position (if any) must be maintained consistently in the face of concurrent insertions or deletions in the index. It is OK if a freshly-inserted entry is not returned by a scan that would have found the entry if it had existed when the scan started, or for the scan to return such an entry upon rescanning or backing up even though it had not been returned the first time through. Similarly, a concurrent delete might or might not be reflected in the results of a scan. What is important is that insertions or deletions not cause the scan to miss or multiply return entries that were not themselves being inserted or deleted.</source>
          <target state="translated">在同时插入或删除索引时,扫描位置和标记位置(如果有的话)都必须保持一致。如果一个新插入的条目没有被扫描返回,而扫描开始时该条目已经存在,那么扫描就会发现该条目,或者扫描在重新扫描或备份时返回该条目,即使第一次没有返回,也是可以的。同样,同时进行的删除也可能会或不会反映在扫描结果中。重要的是,插入或删除不会导致扫描错过或增加本身没有插入或删除的返回条目。</target>
        </trans-unit>
        <trans-unit id="3bce0a8d20dfad3adb1a5af3b099eec9aec7a17c" translate="yes" xml:space="preserve">
          <source>Both the system-wide startup file and the user's personal startup file can be made psql-version-specific by appending a dash and the PostgreSQL major or minor release number to the file name, for example &lt;code&gt;~/.psqlrc-9.2&lt;/code&gt; or &lt;code&gt;~/.psqlrc-9.2.5&lt;/code&gt;. The most specific version-matching file will be read in preference to a non-version-specific file.</source>
          <target state="translated">通过在文件名后附加破折号和PostgreSQL主要或次要发行版号（例如 &lt;code&gt;~/.psqlrc-9.2&lt;/code&gt; 或 &lt;code&gt;~/.psqlrc-9.2.5&lt;/code&gt; ，可以使系统范围内的启动文件和用户的个人启动文件都特定于psql版本。 psqlrc-9.2.5。与非版本特定的文件相比，将优先读取最特定的版本匹配文件。</target>
        </trans-unit>
        <trans-unit id="a9f1bcbf395b360aecae5c7aad8432687c5d0c98" translate="yes" xml:space="preserve">
          <source>Boxes are output using the second syntax.</source>
          <target state="translated">箱子是用第二种语法输出的。</target>
        </trans-unit>
        <trans-unit id="3b7172d9675205f8063e821e7bb335558a00ea56" translate="yes" xml:space="preserve">
          <source>Boxes are represented by pairs of points that are opposite corners of the box. Values of type &lt;code&gt;box&lt;/code&gt; are specified using any of the following syntaxes:</source>
          <target state="translated">框由与框的对角相对的点对表示。使用以下任何一种语法来指定类型 &lt;code&gt;box&lt;/code&gt; 的值：</target>
        </trans-unit>
        <trans-unit id="80edaabf28ae789b6d2df8969096454a0d5adc8a" translate="yes" xml:space="preserve">
          <source>Brackets (&lt;code&gt;[]&lt;/code&gt;) are used to select the elements of an array. See &lt;a href=&quot;arrays&quot;&gt;Section 8.15&lt;/a&gt; for more information on arrays.</source>
          <target state="translated">方括号（ &lt;code&gt;[]&lt;/code&gt; ）用于选择数组的元素。有关数组的更多信息，请参见&lt;a href=&quot;arrays&quot;&gt;第8.15节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a42247eae020c4a6a90987074cedeaeafefcb933" translate="yes" xml:space="preserve">
          <source>Break the input string into tokens and categorize each token as a string, time, time zone, or number.</source>
          <target state="translated">将输入字符串分解为标记,并将每个标记分类为字符串、时间、时区或数字。</target>
        </trans-unit>
        <trans-unit id="7f060d64f6791f16fa5efaff60c076733c80c6cc" translate="yes" xml:space="preserve">
          <source>Brian Gladman</source>
          <target state="translated">Brian Gladman</target>
        </trans-unit>
        <trans-unit id="ffa9096408246acd9955cddd88051877608e02b2" translate="yes" xml:space="preserve">
          <source>Bucardo</source>
          <target state="translated">Bucardo</target>
        </trans-unit>
        <trans-unit id="c8eea1b80ba437eb2c7d9d8e4a7a1c0c36ddce4e" translate="yes" xml:space="preserve">
          <source>Bugs</source>
          <target state="translated">Bugs</target>
        </trans-unit>
        <trans-unit id="8d8140d7cfbb395763a377b0065a8f622c660961" translate="yes" xml:space="preserve">
          <source>Build a new index. The index relation has been physically created, but is empty. It must be filled in with whatever fixed data the access method requires, plus entries for all tuples already existing in the table. Ordinarily the &lt;code&gt;ambuild&lt;/code&gt; function will call &lt;code&gt;table_index_build_scan()&lt;/code&gt; to scan the table for existing tuples and compute the keys that need to be inserted into the index. The function must return a palloc'd struct containing statistics about the new index.</source>
          <target state="translated">建立一个新索引。索引关系已经物理创建，但是为空。必须使用访问方法所需的任何固定数据以及表中已存在的所有元组的条目来填充它。通常， &lt;code&gt;ambuild&lt;/code&gt; 函数将调用 &lt;code&gt;table_index_build_scan()&lt;/code&gt; 来扫描表中的现有元组，并计算需要插入索引中的键。该函数必须返回一个包含有关新索引统计信息的palloc结构。</target>
        </trans-unit>
        <trans-unit id="5ab5f75a4f668c4f5eba6aa186b68fe6555350c4" translate="yes" xml:space="preserve">
          <source>Build an empty index, and write it to the initialization fork (&lt;code&gt;INIT_FORKNUM&lt;/code&gt;) of the given relation. This method is called only for unlogged indexes; the empty index written to the initialization fork will be copied over the main relation fork on each server restart.</source>
          <target state="translated">构建一个空索引，并将其写入给定关系的初始化派生（ &lt;code&gt;INIT_FORKNUM&lt;/code&gt; ）。仅对未记录的索引调用此方法。每次服务器重新启动时，写入初始化分支的空索引都将复制到主关系分支上。</target>
        </trans-unit>
        <trans-unit id="59b2f3dbb6bd6f1f5bde23a4b9bc5f2c1659dd06" translate="yes" xml:space="preserve">
          <source>Build the new PostgreSQL source with &lt;code&gt;configure&lt;/code&gt; flags that are compatible with the old cluster. pg_upgrade will check &lt;code&gt;pg_controldata&lt;/code&gt; to make sure all settings are compatible before starting the upgrade.</source>
          <target state="translated">使用与旧集群兼容的 &lt;code&gt;configure&lt;/code&gt; 标志构建新的PostgreSQL源。pg_upgrade将在开始升级之前检查 &lt;code&gt;pg_controldata&lt;/code&gt; 以确保所有设置兼容。</target>
        </trans-unit>
        <trans-unit id="b0efda5eef1ba866b7542374c8ece9a4b87bf621" translate="yes" xml:space="preserve">
          <source>Build time for a GIN index is very sensitive to the &lt;code&gt;maintenance_work_mem&lt;/code&gt; setting; it doesn't pay to skimp on work memory during index creation.</source>
          <target state="translated">GIN索引的构建时间对 &lt;code&gt;maintenance_work_mem&lt;/code&gt; 设置非常敏感。创建索引期间无需花时间在工作内存上。</target>
        </trans-unit>
        <trans-unit id="33f8808cf736a2f0f4fe91a19f0db395826f76fd" translate="yes" xml:space="preserve">
          <source>Building Indexes Concurrently</source>
          <target state="translated">同时建立指数</target>
        </trans-unit>
        <trans-unit id="39c26d35b65d38341a1a91676925e41df6b2055c" translate="yes" xml:space="preserve">
          <source>Building an index type that supports concurrent updates usually requires extensive and subtle analysis of the required behavior. For the b-tree and hash index types, you can read about the design decisions involved in &lt;code&gt;src/backend/access/nbtree/README&lt;/code&gt; and &lt;code&gt;src/backend/access/hash/README&lt;/code&gt;.</source>
          <target state="translated">构建支持并发更新的索引类型通常需要对所需行为进行广泛而细微的分析。对于b树和哈希索引类型，您可以阅读有关 &lt;code&gt;src/backend/access/nbtree/README&lt;/code&gt; 和 &lt;code&gt;src/backend/access/hash/README&lt;/code&gt; 涉及的设计决策。</target>
        </trans-unit>
        <trans-unit id="47e5cdcd370dad05acde9abb1ab525b1924edb0a" translate="yes" xml:space="preserve">
          <source>Building large GiST indexes by simply inserting all the tuples tends to be slow, because if the index tuples are scattered across the index and the index is large enough to not fit in cache, the insertions need to perform a lot of random I/O. Beginning in version 9.2, PostgreSQL supports a more efficient method to build GiST indexes based on buffering, which can dramatically reduce the number of random I/Os needed for non-ordered data sets. For well-ordered data sets the benefit is smaller or non-existent, because only a small number of pages receive new tuples at a time, and those pages fit in cache even if the index as whole does not.</source>
          <target state="translated">通过简单地插入所有的元组来构建大型GiST索引往往会很慢,因为如果索引元组分散在索引中,而且索引大到无法放入缓存,那么插入时需要执行大量的随机I/O。从9.2版本开始,PostgreSQL支持一种更高效的基于缓冲的方法来构建GiST索引,这可以大大减少非有序数据集所需的随机I/O数量。对于井然有序的数据集来说,这种好处较小或不存在,因为每次只有少量的页面接收新的元组,而且这些页面适合缓存,即使整个索引不适合。</target>
        </trans-unit>
        <trans-unit id="802f99132933c7e50ae4b1dc60414e1dd9622319" translate="yes" xml:space="preserve">
          <source>Builds a JSON object out of a text array. The array must have either exactly one dimension with an even number of members, in which case they are taken as alternating key/value pairs, or two dimensions such that each inner array has exactly two elements, which are taken as a key/value pair.</source>
          <target state="translated">从一个文本数组中建立一个JSON对象。数组必须有一个维度,成员数为偶数,在这种情况下,它们被视为交替的键/值对,或者有两个维度,每个内部数组有两个元素,被视为键/值对。</target>
        </trans-unit>
        <trans-unit id="12655969a97b05cc10e81a0f90560ca3e925543c" translate="yes" xml:space="preserve">
          <source>Builds a JSON object out of a text array. The array must have either exactly one dimension with an even number of members, in which case they are taken as alternating key/value pairs, or two dimensions such that each inner array has exactly two elements, which are taken as a key/value pair. All values are converted to JSON strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2aecbff08d9f05062e48cef54ff41a7deab5245" translate="yes" xml:space="preserve">
          <source>Builds a JSON object out of a variadic argument list. By convention, the argument list consists of alternating keys and values.</source>
          <target state="translated">从一个变量参数列表中构建一个JSON对象。按照惯例,参数列表由交替的键和值组成。</target>
        </trans-unit>
        <trans-unit id="3f46fcc8bccbe3831f46147a1da2fc888d15802b" translate="yes" xml:space="preserve">
          <source>Builds a JSON object out of a variadic argument list. By convention, the argument list consists of alternating keys and values. Key arguments are coerced to text; value arguments are converted as per &lt;code&gt;to_json&lt;/code&gt; or &lt;code&gt;to_jsonb&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad91ede47a5280dfb0e7c89b0ab06f2bb7e0630d" translate="yes" xml:space="preserve">
          <source>Builds a possibly-heterogeneously-typed JSON array out of a variadic argument list.</source>
          <target state="translated">从变量参数列表中构建一个可能是异构类型的JSON数组。</target>
        </trans-unit>
        <trans-unit id="fc07e20c2337d94398080bc4db916907237b8429" translate="yes" xml:space="preserve">
          <source>Builds a possibly-heterogeneously-typed JSON array out of a variadic argument list. Each argument is converted as per &lt;code&gt;to_json&lt;/code&gt; or &lt;code&gt;to_jsonb&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b5998f67810590d9a53e6c46c1e94143e2a8d11" translate="yes" xml:space="preserve">
          <source>Builds an arbitrary record from a JSON object (see note below). As with all functions returning &lt;code&gt;record&lt;/code&gt;, the caller must explicitly define the structure of the record with an &lt;code&gt;AS&lt;/code&gt; clause.</source>
          <target state="translated">从JSON对象构建任意记录（请参见下面的注释）。与所有返回 &lt;code&gt;record&lt;/code&gt; 的函数一样，调用者必须使用 &lt;code&gt;AS&lt;/code&gt; 子句显式定义记录的结构。</target>
        </trans-unit>
        <trans-unit id="08637f34c0762d04a0506b89a280023ac2d9b88b" translate="yes" xml:space="preserve">
          <source>Builds an arbitrary set of records from a JSON array of objects (see note below). As with all functions returning &lt;code&gt;record&lt;/code&gt;, the caller must explicitly define the structure of the record with an &lt;code&gt;AS&lt;/code&gt; clause.</source>
          <target state="translated">根据对象的JSON数组构建任意记录集（请参见下面的注释）。与所有返回 &lt;code&gt;record&lt;/code&gt; 的函数一样，调用者必须使用 &lt;code&gt;AS&lt;/code&gt; 子句显式定义记录的结构。</target>
        </trans-unit>
        <trans-unit id="5cd7d28e330cbb1847ac7f97e57334ab1657662f" translate="yes" xml:space="preserve">
          <source>Built-In Functions</source>
          <target state="translated">内置功能</target>
        </trans-unit>
        <trans-unit id="20f409cc87c744070ec80e942947a590f8db80d1" translate="yes" xml:space="preserve">
          <source>Built-in</source>
          <target state="translated">Built-in</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
