<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="74ec56d1bf817c0befd406275e3cdc68acd63801" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.Unknown.field.cmsg_level&quot;&gt;&lt;code&gt;cmsg_level:&amp;nbsp;&lt;a href=&quot;../../../primitive.i32&quot;&gt;i32&lt;/a&gt;&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.Unknown.field.cmsg_level&quot;&gt;&lt;code&gt;cmsg_level:&amp;nbsp;&lt;a href=&quot;../../../primitive.i32&quot;&gt;i32&lt;/a&gt;&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="9f752b0935e93abaf0f9500cbb548195f26e0793" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.Unknown.field.cmsg_type&quot;&gt;&lt;code&gt;cmsg_type:&amp;nbsp;&lt;a href=&quot;../../../primitive.i32&quot;&gt;i32&lt;/a&gt;&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.Unknown.field.cmsg_type&quot;&gt;&lt;code&gt;cmsg_type:&amp;nbsp;&lt;a href=&quot;../../../primitive.i32&quot;&gt;i32&lt;/a&gt;&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="a8dd251a1207d4e11e3d10d61c6d014b2646ff37" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.V4&quot;&gt;&lt;code id=&quot;V4.v&quot;&gt;V4(&lt;a href=&quot;struct.ipv4addr&quot;&gt;Ipv4Addr&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.V4&quot;&gt;&lt;code id=&quot;V4.v&quot;&gt;V4(&lt;a href=&quot;struct.ipv4addr&quot;&gt;Ipv4Addr&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="900d145487fbb075cf35b7f31871559fc4e06aea" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.V4&quot;&gt;&lt;code id=&quot;V4.v&quot;&gt;V4(&lt;a href=&quot;struct.socketaddrv4&quot;&gt;SocketAddrV4&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.V4&quot;&gt;&lt;code id=&quot;V4.v&quot;&gt;V4(&lt;a href=&quot;struct.socketaddrv4&quot;&gt;SocketAddrV4&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="ccd5990162f9019755ca0861aec17eeb838635c5" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.V6&quot;&gt;&lt;code id=&quot;V6.v&quot;&gt;V6(&lt;a href=&quot;struct.ipv6addr&quot;&gt;Ipv6Addr&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.V6&quot;&gt;&lt;code id=&quot;V6.v&quot;&gt;V6(&lt;a href=&quot;struct.ipv6addr&quot;&gt;Ipv6Addr&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="df27b63255e5ca4dd10ee3931d89a214cb7a79e8" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.V6&quot;&gt;&lt;code id=&quot;V6.v&quot;&gt;V6(&lt;a href=&quot;struct.socketaddrv6&quot;&gt;SocketAddrV6&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.V6&quot;&gt;&lt;code id=&quot;V6.v&quot;&gt;V6(&lt;a href=&quot;struct.socketaddrv6&quot;&gt;SocketAddrV6&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="b1ea069ef9327f5c3a1a861557ea04c82575ae3c" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.Vacant&quot;&gt;&lt;code id=&quot;Vacant.v&quot;&gt;Vacant(&lt;a href=&quot;struct.rawvacantentrymut&quot;&gt;RawVacantEntryMut&lt;/a&gt;&amp;lt;'a, K, V, S&amp;gt;)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.Vacant&quot;&gt; &lt;code id=&quot;Vacant.v&quot;&gt;Vacant(&lt;a href=&quot;struct.rawvacantentrymut&quot;&gt;RawVacantEntryMut&lt;/a&gt;&amp;lt;'a, K, V, S&amp;gt;)&lt;/code&gt; &lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="a3f52e8e92525a9484f9ea21a413660d15607c54" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.Vacant&quot;&gt;&lt;code id=&quot;Vacant.v&quot;&gt;Vacant(&lt;a href=&quot;struct.vacantentry&quot;&gt;VacantEntry&lt;/a&gt;&amp;lt;'a, K, V&amp;gt;)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.Vacant&quot;&gt; &lt;code id=&quot;Vacant.v&quot;&gt;Vacant(&lt;a href=&quot;struct.vacantentry&quot;&gt;VacantEntry&lt;/a&gt;&amp;lt;'a, K, V&amp;gt;)&lt;/code&gt; &lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="cc590a03de1082f370b8b404e093e91ac5cb0306" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.Verbatim&quot;&gt;&lt;code id=&quot;Verbatim.v&quot;&gt;Verbatim(&amp;amp;'a &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;OsStr&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.Verbatim&quot;&gt; &lt;code id=&quot;Verbatim.v&quot;&gt;Verbatim(&amp;amp;'a &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;OsStr&lt;/a&gt;)&lt;/code&gt; &lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="5aa296add133e61d06a6d4259d1fb0881eb7bd39" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.VerbatimDisk&quot;&gt;&lt;code id=&quot;VerbatimDisk.v&quot;&gt;VerbatimDisk(&lt;a href=&quot;../primitive.u8&quot;&gt;u8&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.VerbatimDisk&quot;&gt;&lt;code id=&quot;VerbatimDisk.v&quot;&gt;VerbatimDisk(&lt;a href=&quot;../primitive.u8&quot;&gt;u8&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="f6b929546a75faa42e8181de8ca57bcfbd173f85" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.VerbatimUNC&quot;&gt;&lt;code id=&quot;VerbatimUNC.v&quot;&gt;VerbatimUNC(&amp;amp;'a &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;OsStr&lt;/a&gt;,&amp;nbsp;&amp;amp;'a &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;OsStr&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.VerbatimUNC&quot;&gt; &lt;code id=&quot;VerbatimUNC.v&quot;&gt;VerbatimUNC(&amp;amp;'a &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;OsStr&lt;/a&gt;,&amp;nbsp;&amp;amp;'a &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;OsStr&lt;/a&gt;)&lt;/code&gt; &lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="9cd9ad739de8cce934db346fc40fc958c8b3429e" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.WouldBlock&quot;&gt;&lt;code id=&quot;WouldBlock.v&quot;&gt;WouldBlock&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.WouldBlock&quot;&gt;&lt;code id=&quot;WouldBlock.v&quot;&gt;WouldBlock&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="31c97026aa6d07f6414185d909730c36779144a9" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.Write&quot;&gt;&lt;code id=&quot;Write.v&quot;&gt;Write&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.Write&quot;&gt;&lt;code id=&quot;Write.v&quot;&gt;Write&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="61e6c90d5de31882b090799d674e61ef0d0f389c" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.WriteZero&quot;&gt;&lt;code id=&quot;WriteZero.v&quot;&gt;WriteZero&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.WriteZero&quot;&gt;&lt;code id=&quot;WriteZero.v&quot;&gt;WriteZero&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="dc8ede49b45bb296751c2a5d3ace189c5a80e69c" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.Yielded&quot;&gt;&lt;code id=&quot;Yielded.v&quot;&gt;Yielded(Y)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.Yielded&quot;&gt;&lt;code id=&quot;Yielded.v&quot;&gt;Yielded(Y)&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="6b8f56e3c79b5975e1be195dd3734989bee366c7" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.Zero&quot;&gt;&lt;code id=&quot;Zero.v&quot;&gt;Zero&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.Zero&quot;&gt;&lt;code id=&quot;Zero.v&quot;&gt;Zero&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="8d30ecbd2f33931b54af81e7b1473f6ce8c0ba0d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/issues/10184&quot;&gt;NOTE: currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type&lt;/a&gt;&lt;/strong&gt;. This includes Inf and NaN. This is a bug and will be fixed.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/issues/10184&quot;&gt;注意：当前，如果四舍五入的值不能由目标整数类型表示，则这将导致未定义行为&lt;/a&gt;&lt;/strong&gt;。这包括Inf和NaN。这是一个错误，将得到修复。</target>
        </trans-unit>
        <trans-unit id="92971d62fe3186475f026398e7a0174099738633" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/issues/15536&quot;&gt;NOTE: currently this will cause Undefined Behavior if the value is finite but larger or smaller than the largest or smallest finite value representable by f32&lt;/a&gt;&lt;/strong&gt;. This is a bug and will be fixed.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/issues/15536&quot;&gt;注意：当前，如果该值是有限的但大于或小于f32可表示的最大或最小有限值，则将导致未定义行为&lt;/a&gt;&lt;/strong&gt;。这是一个错误，将得到修复。</target>
        </trans-unit>
        <trans-unit id="1afbb08e18a2a8950ebdff5b3534ae0f7e3fd83f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Note&lt;/em&gt;&lt;/strong&gt;: The &lt;code&gt;rustc&lt;/code&gt; compiler automatically inlines functions based on internal heuristics. Incorrectly inlining functions can make the program slower, so this attribute should be used with care.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;注意&lt;/em&gt;&lt;/strong&gt;： &lt;code&gt;rustc&lt;/code&gt; 编译器会根据内部启发法自动内联函数。不正确的内联函数会使程序变慢，因此应谨慎使用此属性。</target>
        </trans-unit>
        <trans-unit id="52af196e2df7d6d1d70d4b20971e00ada5feef77" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Warning:&lt;/em&gt;&lt;/strong&gt; Dereferencing an unaligned pointer is &lt;a href=&quot;behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt; and it is possible to &lt;a href=&quot;https://github.com/rust-lang/rust/issues/27060&quot;&gt;safely create unaligned pointers to &lt;code&gt;packed&lt;/code&gt; fields&lt;/a&gt;. Like all ways to create undefined behavior in safe Rust, this is a bug.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;警告：&lt;/em&gt;&lt;/strong&gt;取消引用未对齐的指针是&lt;a href=&quot;behavior-considered-undefined&quot;&gt;未定义的行为&lt;/a&gt;，并且可以&lt;a href=&quot;https://github.com/rust-lang/rust/issues/27060&quot;&gt;安全地创建指向 &lt;code&gt;packed&lt;/code&gt; 字段的未对齐的指针&lt;/a&gt;。像在安全Rust中创建未定义行为的所有方法一样，这是一个错误。</target>
        </trans-unit>
        <trans-unit id="641eae7d16c8e6d62bab0c62010b11532ce2de80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Warning:&lt;/em&gt;&lt;/strong&gt; For &lt;a href=&quot;../types/trait-object&quot;&gt;trait objects&lt;/a&gt;, if there is an inherent method of the same name as a trait method, it will give a compiler error when trying to call the method in a method call expression. Instead, you can call the method using &lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;disambiguating function call syntax&lt;/a&gt;, in which case it calls the trait method, not the inherent method. There is no way to call the inherent method. Just don't define inherent methods on trait objects with the same name a trait method and you'll be fine.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;警告：&lt;/em&gt;&lt;/strong&gt;对于&lt;a href=&quot;../types/trait-object&quot;&gt;特征对象&lt;/a&gt;，如果存在一个与特征方法同名的固有方法，则在尝试在方法调用表达式中调用该方法时，将产生编译器错误。相反，您可以使用&lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;歧义函数调用语法&lt;/a&gt;来调用该方法，在这种情况下，它将调用trait方法，而不是固有方法。无法调用固有方法。只是不要在与trait方法同名的trait对象上定义固有方法，就可以了。</target>
        </trans-unit>
        <trans-unit id="14f5badea1be2736539096eaf684db8c5d26b01b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Warning:&lt;/em&gt;&lt;/strong&gt; The following list is not exhaustive. There is no formal model of Rust's semantics for what is and is not allowed in unsafe code, so there may be more behavior considered unsafe. The following list is just what we know for sure is undefined behavior. Please read the &lt;a href=&quot;https://doc.rust-lang.org/nomicon/index.html&quot;&gt;Rustonomicon&lt;/a&gt; before writing unsafe code.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;警告：&lt;/em&gt;&lt;/strong&gt;以下列表并不详尽。对于不安全代码中允许和不允许的内容，没有Rust语义的形式化模型，因此可能有更多行为被认为是不安全的。以下列表是我们肯定知道的未定义行为。在编写不安全的代码之前，请先阅读&lt;a href=&quot;https://doc.rust-lang.org/nomicon/index.html&quot;&gt; Rustonomicon&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0029a09af0cc0f5afc1611697c9ad1ed7b7d0cfc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Warning:&lt;/em&gt;&lt;/strong&gt; With two trait object types, even when the complete set of traits is the same, if the base traits differ, the type is different. For example, &lt;code&gt;dyn Send + Sync&lt;/code&gt; is a different type from &lt;code&gt;dyn Sync + Send&lt;/code&gt;. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/33140&quot;&gt;issue 33140&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;警告：&lt;/em&gt;&lt;/strong&gt;对于两种特征对象类型，即使完整的一组特征相同，如果基本特征不同，则类型也不同。例如， &lt;code&gt;dyn Send + Sync&lt;/code&gt; 是与 &lt;code&gt;dyn Sync + Send&lt;/code&gt; 不同的类型。参见&lt;a href=&quot;https://github.com/rust-lang/rust/issues/33140&quot;&gt;问题33140&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ee107fe206809602998471109ca3cf88bae2bbb4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;sup&gt;Lexer 2015&lt;/sup&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;sup&gt;Lexer 2015&lt;/sup&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="086e314e305cc39ba4d4b327b89e5d7a0d8c6f03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;sup&gt;Lexer 2018+&lt;/sup&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;sup&gt;Lexer 2018+&lt;/sup&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="32563aa7feb766e8d7e65307f8bc48e47003b702" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;sup&gt;Lexer:&lt;/sup&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;sup&gt;Lexer:&lt;/sup&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a3ac7aad80402b534d708e407025f17f7772a4ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;sup&gt;Lexer&lt;/sup&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;sup&gt;Lexer&lt;/sup&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="13ea811ecc594e94181b24eb80a75c60e5e29672" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;sup&gt;Syntax:&lt;/sup&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;sup&gt;Syntax:&lt;/sup&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4284bd4d709ac711e8c06bbdaf51939ae42316ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;sup&gt;Syntax&lt;/sup&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;sup&gt;Syntax&lt;/sup&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="04d38a540329625df538c94f4f56761b0074d0fa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Character size&lt;/strong&gt; - C strings may use &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;wchar_t&lt;/code&gt;-sized characters; please &lt;strong&gt;note&lt;/strong&gt; that C's &lt;code&gt;char&lt;/code&gt; is different from Rust's. The C standard leaves the actual sizes of those types open to interpretation, but defines different APIs for strings made up of each character type. Rust strings are always UTF-8, so different Unicode characters will be encoded in a variable number of bytes each. The Rust type &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; represents a '&lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt;', which is similar to, but not the same as, a '&lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;Unicode code point&lt;/a&gt;'.</source>
          <target state="translated">&lt;strong&gt;字符大小&lt;/strong&gt; -C字符串可以使用 &lt;code&gt;char&lt;/code&gt; 或 &lt;code&gt;wchar_t&lt;/code&gt; 大小的字符；请&lt;strong&gt;注意&lt;/strong&gt;，C的 &lt;code&gt;char&lt;/code&gt; 与Rust的字符不同。C标准将这些类型的实际大小留待解释，但是为由每种字符类型组成的字符串定义了不同的API。Rust字符串始终为UTF-8，因此每个不同的Unicode字符将以可变的字节数进行编码。Rust类型的&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;表示一个&amp;ldquo; &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode标量值&lt;/a&gt; &amp;rdquo;，它与&amp;ldquo; &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;Unicode代码点&lt;/a&gt; &amp;rdquo; 相似但不相同。</target>
        </trans-unit>
        <trans-unit id="0ce042add186ebd327aa00b3f56f494c53302773" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Character size&lt;/strong&gt; - C strings may use &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;wchar_t&lt;/code&gt;-sized characters; please &lt;strong&gt;note&lt;/strong&gt; that C's &lt;code&gt;char&lt;/code&gt; is different from Rust's. The C standard leaves the actual sizes of those types open to interpretation, but defines different APIs for strings made up of each character type. Rust strings are always UTF-8, so different Unicode characters will be encoded in a variable number of bytes each. The Rust type &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.char.html&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; represents a '&lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt;', which is similar to, but not the same as, a '&lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;Unicode code point&lt;/a&gt;'.</source>
          <target state="translated">&lt;strong&gt;字符大小&lt;/strong&gt;-C字符串可以使用 &lt;code&gt;char&lt;/code&gt; 或 &lt;code&gt;wchar_t&lt;/code&gt; 大小的字符；请&lt;strong&gt;注意&lt;/strong&gt;，C的 &lt;code&gt;char&lt;/code&gt; 与Rust的字符不同。C标准将这些类型的实际大小留待解释，但为由每种字符类型组成的字符串定义了不同的API。Rust字符串始终为UTF-8，因此每个不同的Unicode字符将以可变的字节数进行编码。Rust类型的&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.char.html&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;表示一个&amp;ldquo; &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode标量值&lt;/a&gt;&amp;rdquo;，它与&amp;ldquo; &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;Unicode代码点&lt;/a&gt;&amp;rdquo;相似但不相同。</target>
        </trans-unit>
        <trans-unit id="c1da5390166def59a905c5a3bf23d0d789eae735" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Character size&lt;/strong&gt; - C strings may use &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;wchar_t&lt;/code&gt;-sized characters; please &lt;strong&gt;note&lt;/strong&gt; that C's &lt;code&gt;char&lt;/code&gt; is different from Rust's. The C standard leaves the actual sizes of those types open to interpretation, but defines different APIs for strings made up of each character type. Rust strings are always UTF-8, so different Unicode characters will be encoded in a variable number of bytes each. The Rust type &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.char.html&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; represents a '&lt;a href=&quot;https://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt;', which is similar to, but not the same as, a '&lt;a href=&quot;https://www.unicode.org/glossary/#code_point&quot;&gt;Unicode code point&lt;/a&gt;'.</source>
          <target state="translated">&lt;strong&gt;字符大小&lt;/strong&gt;-C字符串可以使用 &lt;code&gt;char&lt;/code&gt; 或 &lt;code&gt;wchar_t&lt;/code&gt; 大小的字符；请&lt;strong&gt;注意&lt;/strong&gt;，C的 &lt;code&gt;char&lt;/code&gt; 与Rust的字符不同。C标准将这些类型的实际大小留待解释，但为由每种字符类型组成的字符串定义了不同的API。Rust字符串始终为UTF-8，因此每个不同的Unicode字符将以可变的字节数进行编码。Rust类型的&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.char.html&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;表示一个&amp;ldquo; &lt;a href=&quot;https://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode标量值&lt;/a&gt;&amp;rdquo;，它与&amp;ldquo; &lt;a href=&quot;https://www.unicode.org/glossary/#code_point&quot;&gt;Unicode代码点&lt;/a&gt;&amp;rdquo;相似但不相同。</target>
        </trans-unit>
        <trans-unit id="700eaca40cee125f38cc4d75b02d62979fde8825" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Crates:&lt;/strong&gt; A tree of modules that produces a library or executable</source>
          <target state="translated">&lt;strong&gt;板条箱：&lt;/strong&gt;产生库或可执行文件的模块树</target>
        </trans-unit>
        <trans-unit id="e782bb6068e1aacf17c4b0b3ec1d9875e47c4925" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disclaimer:&lt;/strong&gt; These system calls might change over time.</source>
          <target state="translated">&lt;strong&gt;免责声明：&lt;/strong&gt;这些系统调用可能会随着时间而改变。</target>
        </trans-unit>
        <trans-unit id="6b8b3462b6d6c541b754f0aec381f7e706c421ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition Differences&lt;/strong&gt;: In the 2015 Edition, the crate root contains a variety of different items, including external crates, default crates such as &lt;code&gt;std&lt;/code&gt; and &lt;code&gt;core&lt;/code&gt;, and items in the top level of the crate (including &lt;code&gt;use&lt;/code&gt; imports).</source>
          <target state="translated">&lt;strong&gt;版本差异&lt;/strong&gt;：在2015版中，板条箱根包含各种不同的项目，包括外部板条箱，默认板条箱（例如 &lt;code&gt;std&lt;/code&gt; 和 &lt;code&gt;core&lt;/code&gt; ）以及板条箱中顶层的项目（包括 &lt;code&gt;use&lt;/code&gt; 进口）。</target>
        </trans-unit>
        <trans-unit id="e088bfe5ad018353c64bdbb01968dcde42ba3d14" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition Differences&lt;/strong&gt;: In the 2015 edition, &lt;code&gt;use&lt;/code&gt; paths also allow accessing items in the crate root. Using the example above, the following &lt;code&gt;use&lt;/code&gt; paths work in 2015 but not 2018:</source>
          <target state="translated">&lt;strong&gt;版本差异&lt;/strong&gt;：在2015版中， &lt;code&gt;use&lt;/code&gt; 路径还允许访问板条箱根目录中的项目。使用上面的示例，以下 &lt;code&gt;use&lt;/code&gt; 路径在2015年有效，但在2018年无效：</target>
        </trans-unit>
        <trans-unit id="627f712f9b93a0a851f59c926530c05272107ff4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition Differences&lt;/strong&gt;: In the 2015 edition, crates in the extern prelude cannot be referenced via &lt;a href=&quot;use-declarations&quot;&gt;use declarations&lt;/a&gt;, so it is generally standard practice to include &lt;code&gt;extern crate&lt;/code&gt; declarations to bring them into scope.</source>
          <target state="translated">&lt;strong&gt;版本差异&lt;/strong&gt;：在2015版中，不能通过&lt;a href=&quot;use-declarations&quot;&gt;use声明&lt;/a&gt;引用外部序曲中的板条箱，因此通常将 &lt;code&gt;extern crate&lt;/code&gt; 声明包括在内以将其纳入范围。</target>
        </trans-unit>
        <trans-unit id="f5085a0b269138950b893252f1966657953ef4b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition Differences&lt;/strong&gt;: In the 2015 edition, if the first bound of the trait object is a path that starts with &lt;code&gt;::&lt;/code&gt;, then the &lt;code&gt;dyn&lt;/code&gt; will be treated as a part of the path. The first path can be put in parenthesis to get around this. As such, if you want a trait object with the trait &lt;code&gt;::your_module::Trait&lt;/code&gt;, you should write it as &lt;code&gt;dyn (::your_module::Trait)&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;版本差异&lt;/strong&gt;：在2015版中，如果trait对象的第一个边界是以 &lt;code&gt;::&lt;/code&gt; 开头的路径，则 &lt;code&gt;dyn&lt;/code&gt; 将被视为该路径的一部分。可以将第一个路径放在括号中以解决此问题。这样，如果您想要具有特征 &lt;code&gt;::your_module::Trait&lt;/code&gt; 的特征对象，则应将其写为 &lt;code&gt;dyn (::your_module::Trait)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d876e32afa65f2d220b1dd922c7a25c124ae5c8d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition Differences&lt;/strong&gt;: In the 2015 edition, it is possible to declare trait methods with anonymous parameters (e.g. &lt;code&gt;fn foo(u8)&lt;/code&gt;). This is deprecated and an error as of the 2018 edition. All parameters must have an argument name.</source>
          <target state="translated">&lt;strong&gt;版本差异&lt;/strong&gt;：在2015版中，可以使用匿名参数声明trait方法（例如 &lt;code&gt;fn foo(u8)&lt;/code&gt; ）。自2018年版起已弃用此版本并出现错误。所有参数必须具有参数名称。</target>
        </trans-unit>
        <trans-unit id="d8a4eb3a8ecd26bd2a8200c1aa407e7c962a47c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition Differences&lt;/strong&gt;: In the 2015 edition, this syntax is valid that is disallowed as of the 2018 edition.</source>
          <target state="translated">&lt;strong&gt;版本差异&lt;/strong&gt;：在2015年版本中，此语法在2018年版本开始即无效。</target>
        </trans-unit>
        <trans-unit id="e6c48e95dbd2c5b344112038b2d6d28be512c6e3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition Differences&lt;/strong&gt;: Starting with the 2018 edition, paths for &lt;code&gt;pub(in path)&lt;/code&gt; must start with &lt;code&gt;crate&lt;/code&gt;, &lt;code&gt;self&lt;/code&gt;, or &lt;code&gt;super&lt;/code&gt;. The 2015 edition may also use paths starting with &lt;code&gt;::&lt;/code&gt; or modules from the crate root.</source>
          <target state="translated">&lt;strong&gt;版本差异&lt;/strong&gt;：从2018年版本开始， &lt;code&gt;pub(in path)&lt;/code&gt; 的路径必须以 &lt;code&gt;crate&lt;/code&gt; ， &lt;code&gt;self&lt;/code&gt; 或 &lt;code&gt;super&lt;/code&gt; 开头。2015年版还可以使用以 &lt;code&gt;::&lt;/code&gt; 开头的路径，也可以使用条板箱根目录中的模块。</target>
        </trans-unit>
        <trans-unit id="62a6b70d43483dfe4d5b7b6c6b58326793ee331d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition differences&lt;/strong&gt;: Async blocks are only available beginning with Rust 2018.</source>
          <target state="translated">&lt;strong&gt;版本差异&lt;/strong&gt;：异步块仅从Rust 2018开始可用。</target>
        </trans-unit>
        <trans-unit id="2ffeac211f4d5959ca339c3909c25a46b1449c9d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition differences&lt;/strong&gt;: Async functions are only available beginning with Rust 2018.</source>
          <target state="translated">&lt;strong&gt;版本差异&lt;/strong&gt;：异步功能仅从Rust 2018开始可用。</target>
        </trans-unit>
        <trans-unit id="fbba24256158782afff4e1bf3667267a636ed2ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition differences&lt;/strong&gt;: Await expressions are only available beginning with Rust 2018.</source>
          <target state="translated">&lt;strong&gt;版本差异&lt;/strong&gt;：Await表达式仅从Rust 2018开始可用。</target>
        </trans-unit>
        <trans-unit id="2bd803d8196215afbdb722ca42ff6863ebfdce05" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Encodings&lt;/strong&gt; - Rust strings are UTF-8, but C strings may use other encodings. If you are using a string from C, you should check its encoding explicitly, rather than just assuming that it is UTF-8 like you can do in Rust.</source>
          <target state="translated">&lt;strong&gt;编码&lt;/strong&gt; -Rust字符串是UTF-8，但是C字符串可以使用其他编码。如果您使用的是来自C的字符串，则应显式检查其编码，而不是像在Rust中那样假定它是UTF-8。</target>
        </trans-unit>
        <trans-unit id="c4744b4de56ac84ab4967b9e79393a7382d93137" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Errors&lt;/strong&gt;: If the function returns a &lt;code&gt;Result&lt;/code&gt;, describing the kinds of errors that might occur and what conditions might cause those errors to be returned can be helpful to callers so they can write code to handle the different kinds of errors in different ways.</source>
          <target state="translated">&lt;strong&gt;错误&lt;/strong&gt;：如果函数返回 &lt;code&gt;Result&lt;/code&gt; ，则描述可能发生的错误种类以及导致这些错误返回的条件可能对调用者有帮助，因此调用者可以编写代码以不同的方式处理各种错误。</target>
        </trans-unit>
        <trans-unit id="ab2c858e00d5352d65014ede49ecfd4f78f2629f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;From C to Rust:&lt;/strong&gt;&lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt; represents a borrowed C string; it is what you would use to wrap a raw &lt;code&gt;*const &lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt; that you got from a C function. A &lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt; is guaranteed to be a nul-terminated array of bytes. Once you have a &lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt;, you can convert it to a Rust &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; if it's valid UTF-8, or lossily convert it by adding replacement characters.</source>
          <target state="translated">&lt;strong&gt;从C到Rust：&lt;/strong&gt;&lt;a href=&quot;struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; &lt;/a&gt;代表借来的C字符串；这就是包装从C函数获得的原始 &lt;code&gt;*const &lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; 的方式&lt;/a&gt;。甲&lt;a href=&quot;struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; 的&lt;/a&gt;保证是字节空终止阵列。拥有&lt;a href=&quot;struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; 之后&lt;/a&gt;，如果它是有效的UTF-8，则可以将其转换为Rust &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;，或者通过添加替换字符有损地将其转换。</target>
        </trans-unit>
        <trans-unit id="be0edd96752d258e24714cab9620512785d60bc1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;From C to Rust:&lt;/strong&gt;&lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt; represents a borrowed C string; it is what you would use to wrap a raw &lt;code&gt;*const &lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt; that you got from a C function. A &lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt; is guaranteed to be a nul-terminated array of bytes. Once you have a &lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt;, you can convert it to a Rust &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; if it's valid UTF-8, or lossily convert it by adding replacement characters.</source>
          <target state="translated">&lt;strong&gt;从C到Rust：&lt;/strong&gt;&lt;a href=&quot;struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; &lt;/a&gt;代表借来的C字符串；这就是包装从C函数获得的原始 &lt;code&gt;*const &lt;/code&gt; &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt; &lt;code&gt;u8&lt;/code&gt; 的方式&lt;/a&gt;。甲&lt;a href=&quot;struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; 的&lt;/a&gt;保证是字节空终止阵列。一旦有了&lt;a href=&quot;struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; &lt;/a&gt;，就可以将其转换为Rust &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; (&lt;/a&gt;如果它是有效的UTF-8），或者可以通过添加替换字符来有损地转换它。</target>
        </trans-unit>
        <trans-unit id="6a880c7c09fd0c1f69a3098a3095ef95bac0a546" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;From Rust to C:&lt;/strong&gt;&lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt; represents an owned, C-friendly string: it is nul-terminated, and has no internal nul characters. Rust code can create a &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt; out of a normal string (provided that the string doesn't have nul characters in the middle), and then use a variety of methods to obtain a raw &lt;code&gt;*mut &lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt; that can then be passed as an argument to functions which use the C conventions for strings.</source>
          <target state="translated">&lt;strong&gt;从Rust到C：&lt;/strong&gt;&lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt;代表一个拥有的，对C友好的字符串：它是nul终止的，并且没有内部nul字符。Rust代码可以从普通字符串（假设字符串中间没有nul字符）创建&lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt;，然后使用多种方法来获取原始 &lt;code&gt;*mut &lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt;，然后可以将其作为参数传递给使用C约定的字符串的函数。</target>
        </trans-unit>
        <trans-unit id="aae173511f045be6a9f0dfcffd69891dd82a8b0b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;From Rust to C:&lt;/strong&gt;&lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt; represents an owned, C-friendly string: it is nul-terminated, and has no internal nul characters. Rust code can create a &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt; out of a normal string (provided that the string doesn't have nul characters in the middle), and then use a variety of methods to obtain a raw &lt;code&gt;*mut &lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt; that can then be passed as an argument to functions which use the C conventions for strings.</source>
          <target state="translated">&lt;strong&gt;从Rust到C：&lt;/strong&gt;&lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt;表示一个拥有的，对C友好的字符串：它是nul终止的，并且没有内部nul字符。 Rust代码可以使用普通字符串（前提是该字符串的中间没有nul字符）创建一个&lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt;，然后使用多种方法来获取原始 &lt;code&gt;*mut &lt;/code&gt; &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt;，然后可以将其作为参数传递给使用C约定的字符串的函数。</target>
        </trans-unit>
        <trans-unit id="c2238adb64a05e56adbe151507af6c19abcbbbc4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;From a Rust string&lt;/strong&gt;: &lt;code&gt;OsString&lt;/code&gt; implements &lt;a href=&quot;../convert/trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;, so you can use &lt;code&gt;my_string.from&lt;/code&gt; to create an &lt;code&gt;OsString&lt;/code&gt; from a normal Rust string.</source>
          <target state="translated">&lt;strong&gt;从锈字符串&lt;/strong&gt;： &lt;code&gt;OsString&lt;/code&gt; 工具&lt;a href=&quot;../convert/trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; ，所以你可以使用 &lt;code&gt;my_string.from&lt;/code&gt; 创建 &lt;code&gt;OsString&lt;/code&gt; 从一个正常的铁锈字符串。</target>
        </trans-unit>
        <trans-unit id="a856fdf688afa04d2bd84181c6260aaef0048cb5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;From slices:&lt;/strong&gt; Just like you can start with an empty Rust &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and then &lt;a href=&quot;../string/struct.string#method.push_str&quot;&gt;&lt;code&gt;String::push_str&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt; sub-string slices into it, you can create an empty &lt;code&gt;OsString&lt;/code&gt; with the &lt;a href=&quot;struct.osstring#method.new&quot;&gt;&lt;code&gt;OsString::new&lt;/code&gt;&lt;/a&gt; method and then push string slices into it with the &lt;a href=&quot;struct.osstring#method.push&quot;&gt;&lt;code&gt;OsString::push&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;strong&gt;从切片：&lt;/strong&gt;就像您可以先从一个空的Rust &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; 开始&lt;/a&gt;，然后是&lt;a href=&quot;../string/struct.string#method.push_str&quot;&gt; &lt;code&gt;String::push_str&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; 子字符串切片一样，您可以使用&lt;a href=&quot;struct.osstring#method.new&quot;&gt; &lt;code&gt;OsString::new&lt;/code&gt; &lt;/a&gt;方法创建一个空的 &lt;code&gt;OsString&lt;/code&gt; ，然后使用&lt;a href=&quot;struct.osstring#method.push&quot;&gt; &lt;code&gt;OsString::push&lt;/code&gt; &lt;/a&gt;将字符串切片推入其中:: push方法。</target>
        </trans-unit>
        <trans-unit id="adfbc9f4c9b7bf87cce69244480b633a8de2c39f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;From slices:&lt;/strong&gt; Just like you can start with an empty Rust &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and then &lt;a href=&quot;../string/struct.string#method.push_str&quot;&gt;&lt;code&gt;push_str&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt; sub-string slices into it, you can create an empty &lt;code&gt;OsString&lt;/code&gt; with the &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; method and then push string slices into it with the &lt;a href=&quot;#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;strong&gt;从片：&lt;/strong&gt;就像你可以用空的锈开始&lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;，然后&lt;a href=&quot;../string/struct.string#method.push_str&quot;&gt; &lt;code&gt;push_str&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; 子串片进去，你可以创建一个空 &lt;code&gt;OsString&lt;/code&gt; 用&lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt;方法，然后按串片放入它的&lt;a href=&quot;#method.push&quot;&gt; &lt;code&gt;push&lt;/code&gt; &lt;/a&gt;法。</target>
        </trans-unit>
        <trans-unit id="5663223157e2b3d6031e4a48c107b41038aa63b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important.&lt;/strong&gt; At least at present, you should avoid using &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; types for functions that are defined in C but invoked from Rust. In those cases, you should directly mirror the C types as closely as possible. Using types like &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; where the C definition is just using &lt;code&gt;T*&lt;/code&gt; can lead to undefined behavior, as described in &lt;a href=&quot;https://github.com/rust-lang/unsafe-code-guidelines/issues/198&quot;&gt;rust-lang/unsafe-code-guidelines#198&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;重要的。&lt;/strong&gt;至少目前，您应该避免将 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 类型用于在C中定义但从Rust调用的函数。在这些情况下，您应该尽可能直接地镜像C类型。使用诸如 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 类的类型（其中C定义仅使用 &lt;code&gt;T*&lt;/code&gt; 会导致未定义的行为，如&lt;a href=&quot;https://github.com/rust-lang/unsafe-code-guidelines/issues/198&quot;&gt;rust-lang / unsafe-code-guidelines＃198中所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="629ec911ccd79d718629d3b5e11521368319be97" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Internal nul characters&lt;/strong&gt; - When C strings have a nul terminator character, this usually means that they cannot have nul characters in the middle &amp;mdash; a nul character would essentially truncate the string. Rust strings &lt;em&gt;can&lt;/em&gt; have nul characters in the middle, because nul does not have to mark the end of the string in Rust.</source>
          <target state="translated">&lt;strong&gt;内部nul字符&lt;/strong&gt; -当C字符串具有nul终止符时，这通常意味着它们中间不能包含nul字符-nul字符实际上会截断字符串。Rust字符串的中间&lt;em&gt;可以&lt;/em&gt;有nul字符，因为nul不必在Rust中标记字符串的结尾。</target>
        </trans-unit>
        <trans-unit id="b41d1a37bb22ed7e91444167c781b032f81cc870" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Modules&lt;/strong&gt; and &lt;strong&gt;use:&lt;/strong&gt; Let you control the organization, scope, and privacy of paths</source>
          <target state="translated">&lt;strong&gt;模块&lt;/strong&gt;和&lt;strong&gt;用途：&lt;/strong&gt;让您控制路径的组织，范围和隐私</target>
        </trans-unit>
        <trans-unit id="41c40dd8ed6820329fca0f856e36989c1fdbd2b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NB.&lt;/strong&gt; The never type was expected to be stabilized in 1.41, but due to some last minute regressions detected the stabilization was temporarily reverted. The &lt;code&gt;!&lt;/code&gt; type can only appear in function return types presently. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/35121&quot;&gt;the tracking issue&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;strong&gt;注意 &lt;/strong&gt;永不类型预计会稳定在1.41，但是由于最后一刻的回归，检测到暂时恢复了稳定状态。该 &lt;code&gt;!&lt;/code&gt; 类型目前只能出现在函数返回类型中。有关更多详细信息，请参见&lt;a href=&quot;https://github.com/rust-lang/rust/issues/35121&quot;&gt;跟踪问题&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="060d89d923956472cc05e7319b76fa9d50a7e876" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE: The third invariant is currently unenforced due to historical oversight and significant reliance on the behaviour. It is currently undecided what to do about this going forward. Macros that do not respect the behaviour may become invalid in a future edition of Rust. See the &lt;a href=&quot;https://github.com/rust-lang/rust/issues/56575&quot;&gt;tracking issue&lt;/a&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;注意：由于历史监督和对行为的严重依赖，目前不强制使用第三个不变式。目前尚不确定该如何处理。在将来的Rust版本中，不遵守该行为的宏可能会失效。请参阅&lt;a href=&quot;https://github.com/rust-lang/rust/issues/56575&quot;&gt;跟踪问题&lt;/a&gt;。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="379a60c8e2b4b827557b233553a6bc6c82683fa1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: If a parent of the given path doesn't exist, this function will return an error. To create a directory and all its missing parents at the same time, use the &lt;a href=&quot;fn.create_dir_all&quot;&gt;&lt;code&gt;create_dir_all&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：如果给定路径的父级不存在，则此函数将返回错误。要同时创建目录及其所有丢失的父目录，请使用&lt;a href=&quot;fn.create_dir_all&quot;&gt; &lt;code&gt;create_dir_all&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="c177380835dd615160771cec4b0171b325482499" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;No matter what, Safe Rust can't cause Undefined Behavior&lt;/strong&gt;. This is referred to as &lt;a href=&quot;https://rust-lang.github.io/unsafe-code-guidelines/glossary.html#soundness-of-code--of-a-library&quot;&gt;soundness&lt;/a&gt;: a well-typed program actually has the desired properties. The &lt;a href=&quot;https://doc.rust-lang.org/nomicon/safe-unsafe-meaning.html&quot;&gt;Nomicon&lt;/a&gt; has a more detailed explanation on the subject.</source>
          <target state="translated">&lt;strong&gt;无论如何，Safe Rust都不会导致Undefined Behavior&lt;/strong&gt;。这被称为&lt;a href=&quot;https://rust-lang.github.io/unsafe-code-guidelines/glossary.html#soundness-of-code--of-a-library&quot;&gt;健全性&lt;/a&gt;：一个类型正确的程序实际上具有所需的属性。该&lt;a href=&quot;https://doc.rust-lang.org/nomicon/safe-unsafe-meaning.html&quot;&gt;Nomicon&lt;/a&gt;有关于这个问题的更详细的解释。</target>
        </trans-unit>
        <trans-unit id="6558cd07ee1a59a066bae7f1a7d1d4e7129c19ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note: This trait must not fail&lt;/strong&gt;. If the conversion can fail, use &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：此特征不能失败&lt;/strong&gt;。如果转换失败，请使用&lt;a href=&quot;trait.tryfrom&quot;&gt; &lt;code&gt;TryFrom&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fc7fd5e949a51b13efc359ef4faae3bf584089ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note: This trait must not fail&lt;/strong&gt;. If the conversion can fail, use &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：此特征不能失败&lt;/strong&gt;。如果转换失败，请使用&lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a5b6ef596678a6ec7ac86f37d73d853ca889a37a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note: This trait must not fail&lt;/strong&gt;. If the conversion can fail, use a dedicated method which returns an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：此特征不能失败&lt;/strong&gt;。如果转换失败，请使用专用的方法，该方法返回&lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9f7d81ecf2a6b96e00a858ce77d080e3c485f5c1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If you need to borrow a string that was allocated by foreign code, use &lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt;. If you need to take ownership of a string that was allocated by foreign code, you will need to make your own provisions for freeing it appropriately, likely with the foreign code's API to do that.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;如果需要借用外来代码分配的字符串，请使用&lt;a href=&quot;struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; &lt;/a&gt;。如果您需要拥有外来代码分配的字符串的所有权，则需要制定自己的规定以适当地释放它，这很可能是通过外来代码的API来实现的。</target>
        </trans-unit>
        <trans-unit id="64f82543ebfb5e0c22f3304371c4e50429156fcf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The future type that rustc generates is roughly equivalent to an enum with one variant per &lt;code&gt;await&lt;/code&gt; point, where each variant stores the data needed to resume from its corresponding point.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt; rustc生成的未来类型大致等效于每个 &lt;code&gt;await&lt;/code&gt; 点带有一个变体的枚举，其中每个变体存储从其对应点恢复所需的数据。</target>
        </trans-unit>
        <trans-unit id="d2eeefa40f9901be73a381ca76c97ef76a1ea8ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is only available on targets where &lt;code&gt;i16&lt;/code&gt; has an alignment of 2 bytes.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;此功能仅在 &lt;code&gt;i16&lt;/code&gt; 的对齐方式为2个字节的目标上可用。</target>
        </trans-unit>
        <trans-unit id="4c2293fd49da6801b825298bc259cec03257c7fa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is only available on targets where &lt;code&gt;i32&lt;/code&gt; has an alignment of 4 bytes.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;此功能仅在 &lt;code&gt;i32&lt;/code&gt; 的对齐方式为4字节的目标上可用。</target>
        </trans-unit>
        <trans-unit id="7b262d56cf8e8f408dcc17fe9b8801b4eb3fadab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is only available on targets where &lt;code&gt;i64&lt;/code&gt; has an alignment of 8 bytes.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;此功能仅在 &lt;code&gt;i64&lt;/code&gt; 的对齐方式为8字节的目标上可用。</target>
        </trans-unit>
        <trans-unit id="16b9eed4ac2d21cb27e6a0debb93f9f3a3bcc5a6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is only available on targets where &lt;code&gt;isize&lt;/code&gt; has an alignment of 8 bytes.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;此功能仅在 &lt;code&gt;isize&lt;/code&gt; 的对齐方式为8个字节的目标上可用。</target>
        </trans-unit>
        <trans-unit id="44eefe3185a3db0f5cea7158f26fe463c75dc726" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is only available on targets where &lt;code&gt;u16&lt;/code&gt; has an alignment of 2 bytes.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;此功能仅在 &lt;code&gt;u16&lt;/code&gt; 的对齐方式为2个字节的目标上可用。</target>
        </trans-unit>
        <trans-unit id="eb1fea0129a87e0a989b444fe1258f62a320490b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is only available on targets where &lt;code&gt;u32&lt;/code&gt; has an alignment of 4 bytes.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;此功能仅在 &lt;code&gt;u32&lt;/code&gt; 的对齐方式为4字节的目标上可用。</target>
        </trans-unit>
        <trans-unit id="28e50b005c31c5d32ebfdba7f184b17a96b48b58" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is only available on targets where &lt;code&gt;u64&lt;/code&gt; has an alignment of 8 bytes.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;此功能仅在 &lt;code&gt;u64&lt;/code&gt; 的对齐方式为8个字节的目标上可用。</target>
        </trans-unit>
        <trans-unit id="1bc61ff9f0824102bc626b9c7cdffa39c424b522" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is only available on targets where &lt;code&gt;usize&lt;/code&gt; has an alignment of 8 bytes.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;此功能仅在 &lt;code&gt;usize&lt;/code&gt; 的对齐方式为8个字节的目标上可用。</target>
        </trans-unit>
        <trans-unit id="7305f68e95514e24a7c95d0883b00ea54e7a5611" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This method is only available on platforms that support atomic operations on &lt;code&gt;u8&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;此方法仅在支持 &lt;code&gt;u8&lt;/code&gt; 上原子操作的平台上可用。</target>
        </trans-unit>
        <trans-unit id="3f9beca619923587f1e53345a612ee54183accda" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This method is only available on platforms that support atomic operations on pointers.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;此方法仅在支持对指针进行原子操作的平台上可用。</target>
        </trans-unit>
        <trans-unit id="b4637566695ac5a54cd62243b48c42f9fc2ba5a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This syntax only adds another restriction to the visibility of an item. It does not guarantee that the item is visible within all parts of the specified scope. To access an item, all of its parent items up to the current scope must still be visible as well.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;此语法仅对项目的可见性增加了另一个限制。它不保证该项目在指定范围的所有部分中都是可见的。要访问某项，直到当前作用域的所有父项也必须仍然可见。</target>
        </trans-unit>
        <trans-unit id="133699edea54cc02f638b728f6d305bf0c4eb4aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.i16&quot;&gt;&lt;code&gt;i16&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;此类型仅在支持原子加载和&lt;a href=&quot;../../primitive.i16&quot;&gt; &lt;code&gt;i16&lt;/code&gt; &lt;/a&gt;存储的平台上可用。</target>
        </trans-unit>
        <trans-unit id="24d47c135cd7e9598aabb084d4e238fb2da1f926" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;此类型仅在支持原子加载和&lt;a href=&quot;../../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt;存储的平台上可用。</target>
        </trans-unit>
        <trans-unit id="f12df48c2a5ede4cad5f196c278170c76aa69b27" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;此类型仅在支持原子加载和&lt;a href=&quot;../../primitive.i64&quot;&gt; &lt;code&gt;i64&lt;/code&gt; &lt;/a&gt;存储的平台上可用。</target>
        </trans-unit>
        <trans-unit id="770d30f50039965c0a80bc18afb0f57006c8ecf7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.i8&quot;&gt;&lt;code&gt;i8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;该类型仅在支持原子负载和&lt;a href=&quot;../../primitive.i8&quot;&gt; &lt;code&gt;i8&lt;/code&gt; &lt;/a&gt;存储的平台上可用。</target>
        </trans-unit>
        <trans-unit id="3770fb7d89c845d66075484dac6af6613879c5c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.isize&quot;&gt;&lt;code&gt;isize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;此类型仅在支持原子加载和&lt;a href=&quot;../../primitive.isize&quot;&gt; &lt;code&gt;isize&lt;/code&gt; &lt;/a&gt;存储的平台上可用。</target>
        </trans-unit>
        <trans-unit id="eb007ca7675d599d0fd1022828e893745c373c65" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.u16&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;此类型仅在支持原子加载和&lt;a href=&quot;../../primitive.u16&quot;&gt; &lt;code&gt;u16&lt;/code&gt; &lt;/a&gt;存储的平台上可用。</target>
        </trans-unit>
        <trans-unit id="3cf286238fb78dad77f34b185f05fcd2ccdeabb1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;此类型仅在支持原子加载和&lt;a href=&quot;../../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt;存储的平台上可用。</target>
        </trans-unit>
        <trans-unit id="6e3460e7cb91ab667e7a2edc5f99bef2b41f79b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.u64&quot;&gt;&lt;code&gt;u64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;此类型仅在支持原子加载和&lt;a href=&quot;../../primitive.u64&quot;&gt; &lt;code&gt;u64&lt;/code&gt; &lt;/a&gt;存储的平台上可用。</target>
        </trans-unit>
        <trans-unit id="fe0118a9443b5848b0cf822fd3a311a3f6ce113f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;此类型仅在支持原子负载和&lt;a href=&quot;../../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt;存储的平台上可用。</target>
        </trans-unit>
        <trans-unit id="de09eea9ef2bf2d098a984258c71927e3c4b2b70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;此类型仅在支持原子加载和&lt;a href=&quot;../../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt;存储的平台上可用。</target>
        </trans-unit>
        <trans-unit id="1bc278c534e3be01a1f5e2970b2fd676ed81d535" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Uninitialized memory is also implicitly invalid for any type that has a restricted set of valid values. In other words, the only cases in which reading uninitialized memory is permitted are inside &lt;code&gt;union&lt;/code&gt;s and in &quot;padding&quot; (the gaps between the fields/elements of a type).</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;对于具有有限有效值集的任何类型，未初始化的内存也隐式无效。换句话说，唯一允许读取未初始化内存的情况是在 &lt;code&gt;union&lt;/code&gt; s内部和&amp;ldquo; padding&amp;rdquo;（类型的字段/元素之间的间隙）中。</target>
        </trans-unit>
        <trans-unit id="2bb5d63cdf94e5456c6918112042bd1091e5e9f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;a href=&quot;variables&quot;&gt;variables&lt;/a&gt;, function parameters, &lt;a href=&quot;items/constant-items&quot;&gt;const&lt;/a&gt; items, and &lt;a href=&quot;items/static-items&quot;&gt;static&lt;/a&gt; items must be &lt;code&gt;Sized&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：&lt;a href=&quot;variables&quot;&gt;变量&lt;/a&gt;，函数参数，&lt;a href=&quot;items/constant-items&quot;&gt;const&lt;/a&gt;项目和&lt;a href=&quot;items/static-items&quot;&gt;静态&lt;/a&gt;项目必须为 &lt;code&gt;Sized&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d46ac6d8774740d98a4009a231d2213aeed2a7c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;rustc&lt;/code&gt; achieves this with the unstable &lt;code&gt;rustc_layout_scalar_valid_range_*&lt;/code&gt; attributes.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;： &lt;code&gt;rustc&lt;/code&gt; 通过不稳定的 &lt;code&gt;rustc_layout_scalar_valid_range_*&lt;/code&gt; 属性来实现此目的。</target>
        </trans-unit>
        <trans-unit id="c50c739d9eb5da5613037181f561652a032953a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Additional crates that ship with &lt;code&gt;rustc&lt;/code&gt;, such as &lt;a href=&quot;https://doc.rust-lang.org/alloc/index.html&quot;&gt;&lt;code&gt;alloc&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/test/index.html&quot;&gt;&lt;code&gt;test&lt;/code&gt;&lt;/a&gt;, are not automatically included with the &lt;code&gt;--extern&lt;/code&gt; flag when using Cargo. They must be brought into scope with an &lt;code&gt;extern crate&lt;/code&gt; declaration, even in the 2018 edition.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：使用 &lt;code&gt;rustc&lt;/code&gt; ，带有rustc的其他包装箱（例如&lt;a href=&quot;https://doc.rust-lang.org/alloc/index.html&quot;&gt; &lt;code&gt;alloc&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://doc.rust-lang.org/test/index.html&quot;&gt; &lt;code&gt;test&lt;/code&gt; &lt;/a&gt;）不会自动包含在 &lt;code&gt;--extern&lt;/code&gt; 标志中。即使在2018年版中，也必须使用 &lt;code&gt;extern crate&lt;/code&gt; 声明将它们纳入范围。</target>
        </trans-unit>
        <trans-unit id="bf68398fddb94f0a1abd51db31ce0b9347bd8495" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Additional crates that ship with &lt;code&gt;rustc&lt;/code&gt;, such as &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/index.html&quot;&gt;&lt;code&gt;proc_macro&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/alloc/index.html&quot;&gt;&lt;code&gt;alloc&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/test/index.html&quot;&gt;&lt;code&gt;test&lt;/code&gt;&lt;/a&gt;, are not automatically included with the &lt;code&gt;--extern&lt;/code&gt; flag when using Cargo. They must be brought into scope with an &lt;code&gt;extern crate&lt;/code&gt; declaration, even in the 2018 edition.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：当使用Cargo时，带有 &lt;code&gt;rustc&lt;/code&gt; 的其他包装箱（例如&lt;a href=&quot;https://doc.rust-lang.org/proc_macro/index.html&quot;&gt; &lt;code&gt;proc_macro&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://doc.rust-lang.org/alloc/index.html&quot;&gt; &lt;code&gt;alloc&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://doc.rust-lang.org/test/index.html&quot;&gt; &lt;code&gt;test&lt;/code&gt; &lt;/a&gt;）不会自动包含在 &lt;code&gt;--extern&lt;/code&gt; 标志中。即使在2018版中，也必须使用 &lt;code&gt;extern crate&lt;/code&gt; 声明将它们纳入范围。</target>
        </trans-unit>
        <trans-unit id="d2b504e0a31dcf2bae64d03c73c728e13b4132f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Configuration options with the key &lt;code&gt;feature&lt;/code&gt; are a convention used by &lt;a href=&quot;https://doc.rust-lang.org/cargo/reference/features.html&quot;&gt;Cargo&lt;/a&gt; for specifying compile-time options and optional dependencies.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：具有关键 &lt;code&gt;feature&lt;/code&gt; 配置选项是&lt;a href=&quot;https://doc.rust-lang.org/cargo/reference/features.html&quot;&gt;Cargo&lt;/a&gt;用来指定编译时选项和可选依赖项的约定。</target>
        </trans-unit>
        <trans-unit id="f8381d4f5be828c7771e48194e3784bf6556e9d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: For &lt;code&gt;rustc&lt;/code&gt;, arbitrary-set configuration options are set using the &lt;a href=&quot;https://doc.rust-lang.org/rustc/command-line-arguments.html#--cfg-configure-the-compilation-environment&quot;&gt;&lt;code&gt;--cfg&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：对于 &lt;code&gt;rustc&lt;/code&gt; ，使用&lt;a href=&quot;https://doc.rust-lang.org/rustc/command-line-arguments.html#--cfg-configure-the-compilation-environment&quot;&gt; &lt;code&gt;--cfg&lt;/code&gt; &lt;/a&gt;标志设置任意设置的配置选项。</target>
        </trans-unit>
        <trans-unit id="0e534aae954895e78357179a1ac94a40dd8cf86b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: For &lt;code&gt;rustc&lt;/code&gt;, arbitrary-set configuration options are set using the &lt;a href=&quot;https://doc.rust-lang.org/rustc/command-line-arguments.html#a--cfg-configure-the-compilation-environment&quot;&gt;&lt;code&gt;--cfg&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：对于 &lt;code&gt;rustc&lt;/code&gt; ，使用&lt;a href=&quot;https://doc.rust-lang.org/rustc/command-line-arguments.html#a--cfg-configure-the-compilation-environment&quot;&gt; &lt;code&gt;--cfg&lt;/code&gt; &lt;/a&gt;标志设置任意设置的配置选项。</target>
        </trans-unit>
        <trans-unit id="c424a34ea4d877226958104553992541e3787ae9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: In the past, the Rust community used the terms &quot;Unambiguous Function Call Syntax&quot;, &quot;Universal Function Call Syntax&quot;, or &quot;UFCS&quot;, in documentation, issues, RFCs, and other community writings. However, the term lacks descriptive power and potentially confuses the issue at hand. We mention it here for searchability's sake.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：过去，Rust社区在文档，问题，RFC和其他社区著作中使用了&amp;ldquo;明确的函数调用语法&amp;rdquo;，&amp;ldquo;通用函数调用语法&amp;rdquo;或&amp;ldquo; UFCS&amp;rdquo;。但是，该术语缺乏描述性，可能会使当前的问题混淆。为了方便搜索，我们在这里提到它。</target>
        </trans-unit>
        <trans-unit id="7e4168c7dfa2ff3fb21bdd3b2ee7e059ab5726bf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Lifetimes can be, and usually are, elided with this shorthand.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：此速记可以（通常）消除生命周期。</target>
        </trans-unit>
        <trans-unit id="bccc13cc797f7b85b663c8c0720dcbb028e2999f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Many pieces of Rust code may assume that pointers, &lt;code&gt;usize&lt;/code&gt;, and &lt;code&gt;isize&lt;/code&gt; are either 32-bit or 64-bit. As a consequence, 16-bit pointer support is limited and may require explicit care and acknowledgment from a library to support.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：许多Rust代码段可能都假定指针 &lt;code&gt;usize&lt;/code&gt; 和 &lt;code&gt;isize&lt;/code&gt; 为32位或64位。因此，对16位指针的支持是有限的，并且可能需要库的明确维护和确认才能提供支持。</target>
        </trans-unit>
        <trans-unit id="2ee6a6f44b42148913ce05336e8333f03b878a8a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: On platforms that do not support receiving spin-loop hints this function does not do anything at all.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：在不支持接收自旋循环提示的平台上，此功能完全不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="3cd7dc42d46fc1a7eaf8316e86e18b4771b7a37c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Previous to &lt;code&gt;rustc&lt;/code&gt; 1.30, using &lt;code&gt;mod.rs&lt;/code&gt; files was the way to load a module with nested children. It is encouraged to use the new naming convention as it is more consistent, and avoids having many files named &lt;code&gt;mod.rs&lt;/code&gt; within a project.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：在 &lt;code&gt;rustc&lt;/code&gt; 1.30之前，使用 &lt;code&gt;mod.rs&lt;/code&gt; 文件是使用嵌套子代加载模块的方法。鼓励使用新的命名约定，因为它更加一致，并且避免在项目中包含许多名为 &lt;code&gt;mod.rs&lt;/code&gt; 的文件。</target>
        </trans-unit>
        <trans-unit id="09dbeb2a0b5b6ab350517ca73457c241b60699f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The &lt;code&gt;cfg_attr&lt;/code&gt; can expand to another &lt;code&gt;cfg_attr&lt;/code&gt;. For example, &lt;code&gt;#[cfg_attr(linux, cfg_attr(feature = &quot;multithreaded&quot;, some_other_attribute))&lt;/code&gt; is valid. This example would be equivalent to &lt;code&gt;#[cfg_attr(all(linux, feature =&quot;multithreaded&quot;), some_other_attribute)]&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;： &lt;code&gt;cfg_attr&lt;/code&gt; 可以扩展到另一个 &lt;code&gt;cfg_attr&lt;/code&gt; 。例如， &lt;code&gt;#[cfg_attr(linux, cfg_attr(feature = &quot;multithreaded&quot;, some_other_attribute))&lt;/code&gt; 有效。此示例等效于 &lt;code&gt;#[cfg_attr(all(linux, feature =&quot;multithreaded&quot;), some_other_attribute)]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48afce94d3f617db585b69f838ac8fa2fe7c7c45" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The &lt;code&gt;cfg_attr&lt;/code&gt; can expand to another &lt;code&gt;cfg_attr&lt;/code&gt;. For example, &lt;code&gt;#[cfg_attr(target_os = &quot;linux&quot;, cfg_attr(feature = &quot;multithreaded&quot;, some_other_attribute))]&lt;/code&gt; is valid. This example would be equivalent to &lt;code&gt;#[cfg_attr(all(target_os = &quot;linux&quot;, feature =&quot;multithreaded&quot;), some_other_attribute)]&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;： &lt;code&gt;cfg_attr&lt;/code&gt; 可以扩展到另一个 &lt;code&gt;cfg_attr&lt;/code&gt; 。例如， &lt;code&gt;#[cfg_attr(target_os = &quot;linux&quot;, cfg_attr(feature = &quot;multithreaded&quot;, some_other_attribute))]&lt;/code&gt; 有效。此示例等效于 &lt;code&gt;#[cfg_attr(all(target_os = &quot;linux&quot;, feature =&quot;multithreaded&quot;), some_other_attribute)]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="542e5e434f17a5e7fe96f177447ca260c03e5782" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The &lt;code&gt;rustc&lt;/code&gt; test harness supports the &lt;code&gt;--include-ignored&lt;/code&gt; flag to force ignored tests to be run.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;： &lt;code&gt;rustc&lt;/code&gt; 测试工具支持--include &lt;code&gt;--include-ignored&lt;/code&gt; 标志，以强制运行忽略的测试。</target>
        </trans-unit>
        <trans-unit id="ee8746d1970619c1573d4cba9ddf4d37981ddfcf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The LLVM backend of the &lt;code&gt;rustc&lt;/code&gt; implementation aborts the process by executing an illegal instruction.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;： &lt;code&gt;rustc&lt;/code&gt; 实现的LLVM后端通过执行非法指令来中止进程。</target>
        </trans-unit>
        <trans-unit id="0b6a9b1648330a6c400057a929b0e006d7b0e3f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The exact rules for temporary lifetime extension are subject to change. This is describing the current behavior only.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：临时延长使用寿命的确切规则可能会发生变化。这仅描述了当前行为。</target>
        </trans-unit>
        <trans-unit id="9663ac595985a9b26dbb960d0c43b0ba63112b12" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The tuple index may include an &lt;code&gt;INTEGER_SUFFIX&lt;/code&gt;, but this is not intended to be valid, and may be removed in a future version. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/60210&quot;&gt;https://github.com/rust-lang/rust/issues/60210&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：元组索引可能包含 &lt;code&gt;INTEGER_SUFFIX&lt;/code&gt; ，但这不是有效的，并且在以后的版本中可能会删除它。有关更多信息，请参见&lt;a href=&quot;https://github.com/rust-lang/rust/issues/60210&quot;&gt;https://github.com/rust-lang/rust/issues/60210&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2e578eea7529dc499f5ab70e8ee02f1a3a04f7e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This function returns an array of length 2, 4 or 8 bytes depending on the target pointer size.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：此函数返回一个长度为2、4或8个字节的数组，具体取决于目标指针的大小。</target>
        </trans-unit>
        <trans-unit id="204f556d6eb284d02edf2bf12e7415dff429dcbd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This function takes an array of length 2, 4 or 8 bytes depending on the target pointer size.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：此函数需要一个长度为2、4或8个字节的数组，具体取决于目标指针的大小。</target>
        </trans-unit>
        <trans-unit id="205669dd54e34ac0f225ea4e8c1e039e92861b84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This is an example note.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：这是示例注释。</target>
        </trans-unit>
        <trans-unit id="4f8175ab0b6ced026c78c226ce62e4e0326a00cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is currently implemented as a 0-cost cast, but it is planned to alter its definition in the future to perform the length calculation whenever this method is called.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：该方法当前实现为零成本强制转换，但是计划在将来更改其定义以在调用此方法时执行长度计算。</target>
        </trans-unit>
        <trans-unit id="9364ca407d4e4789b372b4d12ec8ebcdd47debe7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is currently implemented as a constant-time cast, but it is planned to alter its definition in the future to perform the length calculation whenever this method is called.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：该方法当前实现为固定时间强制转换，但是计划在将来更改其定义以在调用此方法时执行长度计算。</target>
        </trans-unit>
        <trans-unit id="9acff81794f805a2a107dfa5d332d79517391aa9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is currently implemented to check for validity after a constant-time cast, but it is planned to alter its definition in the future to perform the length calculation in addition to the UTF-8 check whenever this method is called.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：目前已实现此方法以在固定时间强制转换后检查有效性，但是计划在将来调用UTF-8检查时，除了将来的UTF-8检查之外，还要更改其定义以执行长度计算。</target>
        </trans-unit>
        <trans-unit id="77e80de2eb59d874ef66f952f67864f1b6680268" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.i16&quot;&gt;&lt;code&gt;i16&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：此方法仅在支持&lt;a href=&quot;../../primitive.i16&quot;&gt; &lt;code&gt;i16&lt;/code&gt; &lt;/a&gt;上原子操作的平台上可用。</target>
        </trans-unit>
        <trans-unit id="416612bbf1909b1aaf73c8e8594ced2ad9b5958a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：此方法仅在支持&lt;a href=&quot;../../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt;上原子操作的平台上可用。</target>
        </trans-unit>
        <trans-unit id="798babd1633ffc3445fb72738f51aaf665f2e799" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：此方法仅在支持&lt;a href=&quot;../../primitive.i64&quot;&gt; &lt;code&gt;i64&lt;/code&gt; &lt;/a&gt;上原子操作的平台上可用。</target>
        </trans-unit>
        <trans-unit id="969f814fd42a6f3586c98e8e6d74c5e1cf0d998f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.i8&quot;&gt;&lt;code&gt;i8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：此方法仅在支持&lt;a href=&quot;../../primitive.i8&quot;&gt; &lt;code&gt;i8&lt;/code&gt; &lt;/a&gt;上原子操作的平台上可用。</target>
        </trans-unit>
        <trans-unit id="c3a8e7d995f2b7f517cfd0675f44c74f193e4d3d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.isize&quot;&gt;&lt;code&gt;isize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：此方法仅在支持&lt;a href=&quot;../../primitive.isize&quot;&gt; &lt;code&gt;isize&lt;/code&gt; &lt;/a&gt;上原子操作的平台上可用。</target>
        </trans-unit>
        <trans-unit id="1a7cf4f75cf7c1494a07e470c8288c8e67f0a8a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.u16&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：此方法仅在支持&lt;a href=&quot;../../primitive.u16&quot;&gt; &lt;code&gt;u16&lt;/code&gt; &lt;/a&gt;上原子操作的平台上可用。</target>
        </trans-unit>
        <trans-unit id="902c1326c59de40d4ee4bf24e303fa8f00886b0f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：此方法仅在支持&lt;a href=&quot;../../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt;上原子操作的平台上可用。</target>
        </trans-unit>
        <trans-unit id="b49fa7c747b4b2f8fc4c2e1fee0ddd570ecece9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.u64&quot;&gt;&lt;code&gt;u64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：此方法仅在支持&lt;a href=&quot;../../primitive.u64&quot;&gt; &lt;code&gt;u64&lt;/code&gt; &lt;/a&gt;上原子操作的平台上可用。</target>
        </trans-unit>
        <trans-unit id="c60105950473e3de294db7b21f197086831cb667" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：此方法仅在支持&lt;a href=&quot;../../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt;上原子操作的平台上可用。</target>
        </trans-unit>
        <trans-unit id="7be6463d1fafa0db1e322e03e3852c3a451379a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：此方法仅在支持&lt;a href=&quot;../../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt;上原子操作的平台上可用。</target>
        </trans-unit>
        <trans-unit id="d5c5be5853f961e5512f727adc94106859254411" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This operation is intended to be a 0-cost cast but it is currently implemented with an up-front calculation of the length of the string. This is not guaranteed to always be the case.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：此操作旨在进行零成本强制转换，但当前是通过预先计算字符串长度来实现的。不能保证总是这样。</target>
        </trans-unit>
        <trans-unit id="669d4b633ce688c467334ac7653c165183f2e3ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This section is incomplete.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：此部分不完整。</target>
        </trans-unit>
        <trans-unit id="543aaedbc9a3d7322ce93678b22b0281abf794f1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This type is only available on platforms that support atomic loads and stores of &lt;code&gt;u8&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：此类型仅在支持原子负载和 &lt;code&gt;u8&lt;/code&gt; 存储的平台上可用。</target>
        </trans-unit>
        <trans-unit id="245a6aeba0c030e92193a51c1b871f48d851f54f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This type is only available on platforms that support atomic loads and stores of pointers. Its size depends on the target pointer's size.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：此类型仅在支持原子加载和指针存储的平台上可用。它的大小取决于目标指针的大小。</target>
        </trans-unit>
        <trans-unit id="f5df3103e6447e1ad2ce9490f42afb19650917b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Undefined behavior affects the entire program. For example, calling a function in C that exhibits undefined behavior of C means your entire program contains undefined behaviour that can also affect the Rust code. And vice versa, undefined behavior in Rust can cause adverse affects on code executed by any FFI calls to other languages.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：未定义的行为会影响整个程序。例如，在C语言中调用表现出C语言未定义行为的函数意味着您的整个程序包含也会影响Rust代码的未定义行为。反之亦然，Rust中未定义的行为可能会对通过FFI调用其他语言执行的代码产生不利影响。</target>
        </trans-unit>
        <trans-unit id="9b1e7bb136e3f88a33c4a3167dcad6a39cd6165d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Unlike field access expressions, tuple index expressions can be the function operand of a &lt;a href=&quot;call-expr&quot;&gt;call expression&lt;/a&gt; as it cannot be confused with a method call since method names cannot be numbers.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：与字段访问表达式不同，元组索引表达式可以是&lt;a href=&quot;call-expr&quot;&gt;调用表达式&lt;/a&gt;的函数操作数，因为它不能与方法调用混淆，因为方法名不能为数字。</target>
        </trans-unit>
        <trans-unit id="9bf566863d0e6c1f93fa47ff736f9ade81dd38c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: When using Cargo, Procedural macro crates are defined with the &lt;code&gt;proc-macro&lt;/code&gt; key in your manifest:</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：使用货运时，程序宏包装箱在清单中使用 &lt;code&gt;proc-macro&lt;/code&gt; 键定义：</target>
        </trans-unit>
        <trans-unit id="a7f8ef7c18d1ebc911a4b8802c9c294409605f53" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Whitespace around the &lt;code&gt;=&lt;/code&gt; is ignored. &lt;code&gt;foo=&quot;bar&quot;&lt;/code&gt; and &lt;code&gt;foo = &quot;bar&quot;&lt;/code&gt; are equivalent configuration options.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;： &lt;code&gt;=&lt;/code&gt; 周围的空格将被忽略。 &lt;code&gt;foo=&quot;bar&quot;&lt;/code&gt; 和 &lt;code&gt;foo = &quot;bar&quot;&lt;/code&gt; 是等效的配置选项。</target>
        </trans-unit>
        <trans-unit id="c47f0cd1f3859cc5bbc515bae176883c35a2e5e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: that the outer &lt;code&gt;match&lt;/code&gt; is used to ensure that any &lt;a href=&quot;../expressions#temporaries&quot;&gt;temporary values&lt;/a&gt; in &lt;code&gt;iter_expr&lt;/code&gt; don't get dropped before the loop is finished. &lt;code&gt;next&lt;/code&gt; is declared before being assigned because it results in types being inferred correctly more often.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：该外部 &lt;code&gt;match&lt;/code&gt; 使用，以确保任何&lt;a href=&quot;../expressions#temporaries&quot;&gt;临时值&lt;/a&gt;在 &lt;code&gt;iter_expr&lt;/code&gt; 循环结束之前不要掉下来。在分配之前先声明 &lt;code&gt;next&lt;/code&gt; ,因为它会导致更频繁地正确推断类型。</target>
        </trans-unit>
        <trans-unit id="ca0b8f99436f4b7d93b7e3e4bd936fecc9cacde1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: that the outer &lt;code&gt;match&lt;/code&gt; is used to ensure that any &lt;a href=&quot;../expressions#temporary-lifetimes&quot;&gt;temporary values&lt;/a&gt; in &lt;code&gt;iter_expr&lt;/code&gt; don't get dropped before the loop is finished. &lt;code&gt;next&lt;/code&gt; is declared before being assigned because it results in types being inferred correctly more often.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：该外部 &lt;code&gt;match&lt;/code&gt; 使用，以确保任何&lt;a href=&quot;../expressions#temporary-lifetimes&quot;&gt;临时值&lt;/a&gt;在 &lt;code&gt;iter_expr&lt;/code&gt; 循环结束之前不要掉下来。在分配之前先声明 &lt;code&gt;next&lt;/code&gt; ,因为它会导致更频繁地正确推断类型。</target>
        </trans-unit>
        <trans-unit id="3d08b1d0d9771f64d914289f8a909594611ec769" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this list is more restrictive than what you can write in regular constants</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：此列表比常规常量中的限制更严格</target>
        </trans-unit>
        <trans-unit id="ff87edb614dc63eb552a33d527babfe470e595e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this module is unstable and is designed in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2504-fix-error.md&quot;&gt;RFC 2504&lt;/a&gt;, and you can learn more about its status in the &lt;a href=&quot;https://github.com/rust-lang/rust/issues/53487&quot;&gt;tracking issue&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：该模块是不稳定的，是在&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2504-fix-error.md&quot;&gt;RFC 2504中&lt;/a&gt;设计的，您可以在&lt;a href=&quot;https://github.com/rust-lang/rust/issues/53487&quot;&gt;跟踪问题中&lt;/a&gt;了解有关其状态的更多信息。</target>
        </trans-unit>
        <trans-unit id="f69af187844f3307c7ac46ebb6a50af4199d0748" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Notes&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Notes&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="b0d06bb798430870d22a876657b39e78b6fbe0c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Nul terminators and implicit string lengths&lt;/strong&gt; - Often, C strings are nul-terminated, i.e., they have a &lt;code&gt;\0&lt;/code&gt; character at the end. The length of a string buffer is not stored, but has to be calculated; to compute the length of a string, C code must manually call a function like &lt;code&gt;strlen()&lt;/code&gt; for &lt;code&gt;char&lt;/code&gt;-based strings, or &lt;code&gt;wcslen()&lt;/code&gt; for &lt;code&gt;wchar_t&lt;/code&gt;-based ones. Those functions return the number of characters in the string excluding the nul terminator, so the buffer length is really &lt;code&gt;len+1&lt;/code&gt; characters. Rust strings don't have a nul terminator; their length is always stored and does not need to be calculated. While in Rust accessing a string's length is a &lt;code&gt;O(1)&lt;/code&gt; operation (because the length is stored); in C it is an &lt;code&gt;O(length)&lt;/code&gt; operation because the length needs to be computed by scanning the string for the nul terminator.</source>
          <target state="translated">&lt;strong&gt;Nul终止符和隐式字符串长度&lt;/strong&gt;-C字符串通常以Nul终止，即，它们的末尾有一个 &lt;code&gt;\0&lt;/code&gt; 字符。字符串缓冲区的长度不存储，而是必须计算；要计算字符串的长度，C代码必须针对基于 &lt;code&gt;char&lt;/code&gt; 的字符串手动调用诸如 &lt;code&gt;strlen()&lt;/code&gt; 的函数，或针对基于 &lt;code&gt;wchar_t&lt;/code&gt; 的字符串手动调用诸如 &lt;code&gt;wcslen()&lt;/code&gt; 的函数。这些函数返回字符串中不包括nul终止符的字符数，因此缓冲区长度实际上是 &lt;code&gt;len+1&lt;/code&gt; 个字符。 Rust字符串没有nul终止符；它们的长度总是存储的，不需要计算。在Rust中访问字符串的长度为 &lt;code&gt;O(1)&lt;/code&gt; 操作（因为存储了长度）；在C中，这是 &lt;code&gt;O(length)&lt;/code&gt; 操作，因为需要通过扫描字符串中的nul终止符来计算长度。</target>
        </trans-unit>
        <trans-unit id="484956955d43e1da5356d63148d3bf3ffefed245" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Nul terminators and implicit string lengths&lt;/strong&gt; - Often, C strings are nul-terminated, i.e., they have a &lt;code&gt;\0&lt;/code&gt; character at the end. The length of a string buffer is not stored, but has to be calculated; to compute the length of a string, C code must manually call a function like &lt;code&gt;strlen()&lt;/code&gt; for &lt;code&gt;char&lt;/code&gt;-based strings, or &lt;code&gt;wcslen()&lt;/code&gt; for &lt;code&gt;wchar_t&lt;/code&gt;-based ones. Those functions return the number of characters in the string excluding the nul terminator, so the buffer length is really &lt;code&gt;len+1&lt;/code&gt; characters. Rust strings don't have a nul terminator; their length is always stored and does not need to be calculated. While in Rust accessing a string's length is a O(1) operation (because the length is stored); in C it is an O(length) operation because the length needs to be computed by scanning the string for the nul terminator.</source>
          <target state="translated">&lt;strong&gt;Nul终止符和隐式字符串长度&lt;/strong&gt; -C字符串通常以Nul终止，即，它们的末尾有一个 &lt;code&gt;\0&lt;/code&gt; 字符。字符串缓冲区的长度不存储，而是必须计算；要计算字符串的长度，C代码必须手动调用类似 &lt;code&gt;strlen()&lt;/code&gt; 的函数以用于基于 &lt;code&gt;char&lt;/code&gt; 的字符串，或使用 &lt;code&gt;wcslen()&lt;/code&gt; 来基于 &lt;code&gt;wchar_t&lt;/code&gt; 的字符串。这些函数返回字符串中不包含nul终止符的字符数，因此缓冲区长度实际上为 &lt;code&gt;len+1&lt;/code&gt; 字符。Rust字符串没有nul终止符；它们的长度总是存储的，不需要计算。在Rust中，访问字符串的长度是O（1）操作（因为存储了长度）；在C中，这是O（length）操作，因为需要通过扫描字符串中的nul终止符来计算长度。</target>
        </trans-unit>
        <trans-unit id="b3a55015f9b574b249377781d35ad1256b26e09a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Packages:&lt;/strong&gt; A Cargo feature that lets you build, test, and share crates</source>
          <target state="translated">&lt;strong&gt;包装：&lt;/strong&gt;货运功能，可让您构建，测试和共享包装箱</target>
        </trans-unit>
        <trans-unit id="b9614e48c420558746aa5a195f1ca3514d9bdb89" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Panics&lt;/strong&gt;: The scenarios in which the function being documented could panic. Callers of the function who don&amp;rsquo;t want their programs to panic should make sure they don&amp;rsquo;t call the function in these situations.</source>
          <target state="translated">&lt;strong&gt;恐慌&lt;/strong&gt;：在该函数被证明可能会出现混乱的场景。不想让程序惊慌的函数调用者应确保在这种情况下不要调用该函数。</target>
        </trans-unit>
        <trans-unit id="48ddec251d4b93c950c826aa556ff50e924f3f09" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Paths:&lt;/strong&gt; A way of naming an item, such as a struct, function, or module</source>
          <target state="translated">&lt;strong&gt;路径：&lt;/strong&gt;一种命名项目的方法，例如结构，函数或模块</target>
        </trans-unit>
        <trans-unit id="481513e92d2c79e9922e6fdaeaecbe26904d2dbb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Safety&lt;/strong&gt;: If the function is &lt;code&gt;unsafe&lt;/code&gt; to call (we discuss unsafety in Chapter 19), there should be a section explaining why the function is unsafe and covering the invariants that the function expects callers to uphold.</source>
          <target state="translated">&lt;strong&gt;安全性&lt;/strong&gt;：如果该函数调用 &lt;code&gt;unsafe&lt;/code&gt; （我们将在第19章中讨论不安全性），则应有一节解释该函数为何不安全的内容，并涵盖该函数希望调用者坚持的不变式。</target>
        </trans-unit>
        <trans-unit id="f938faca9bb27bfed4287077e548ce31cbf39365" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Stability note:&lt;/strong&gt; This impl does not yet exist, but we are &quot;reserving space&quot; to add it in the future. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/64715&quot;&gt;rust-lang/rust#64715&lt;/a&gt; for details.</source>
          <target state="translated">&lt;strong&gt;稳定性说明：&lt;/strong&gt;该暗示尚不存在，但我们正在&amp;ldquo;保留空间&amp;rdquo;以在将来添加它。有关详细信息，请参见&lt;a href=&quot;https://github.com/rust-lang/rust/issues/64715&quot;&gt;rust-lang / rust＃64715&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7e43e997b28aeec3b9c71554f3cb60497761adcd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Supertraits&lt;/strong&gt; are traits that are required to be implemented for a type to implement a specific trait. Furthermore, anywhere a &lt;a href=&quot;generics&quot;&gt;generic&lt;/a&gt; or &lt;a href=&quot;../types/trait-object&quot;&gt;trait object&lt;/a&gt; is bounded by a trait, it has access to the associated items of its supertraits.</source>
          <target state="translated">&lt;strong&gt;超&lt;/strong&gt;特征是一种类型必须具有的特征才能实现特定的特征。此外，在&lt;a href=&quot;generics&quot;&gt;通用&lt;/a&gt;&lt;a href=&quot;../types/trait-object&quot;&gt;对象&lt;/a&gt;或特征对象受特征限制的任何地方，它都可以访问其上特征的关联项。</target>
        </trans-unit>
        <trans-unit id="b38548e4d26b2038d4463b0d5471fd35986ae8ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This function is deprecated.&lt;/strong&gt; Use &lt;a href=&quot;union.maybeuninit&quot;&gt;&lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;strong&gt;不推荐使用此功能。&lt;/strong&gt;请改用&lt;a href=&quot;union.maybeuninit&quot;&gt; &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8f3ae627337dcbcd948c51fd96893635d151265e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This functon is deprecated.&lt;/strong&gt; Use &lt;a href=&quot;union.maybeuninit&quot;&gt;&lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;strong&gt;不推荐使用此功能。&lt;/strong&gt;请改用&lt;a href=&quot;union.maybeuninit&quot;&gt; &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="90d5331accb6d1f759b6d533c2ffbb7485074384" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This method is soft-deprecated.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;此方法已被软弃用。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c2492dfd60adc66b908569e7ad4f918b77633047" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Type coercions&lt;/strong&gt; are implicit operations that change the type of a value. They happen automatically at specific locations and are highly restricted in what types actually coerce.</source>
          <target state="translated">&lt;strong&gt;类型强制&lt;/strong&gt;是隐式操作，可更改值的类型。它们在特定位置自动发生，并且在实际强制类型上受到严格限制。</target>
        </trans-unit>
        <trans-unit id="7cd5055ffa46d984c313532603ca78647862a3d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Unix&lt;/strong&gt;: On Unix-like platforms, it is unlikely that all 32 bits of &lt;code&gt;exit&lt;/code&gt; will be visible to a parent process inspecting the exit code. On most Unix-like platforms, only the eight least-significant bits are considered.</source>
          <target state="translated">&lt;strong&gt;Unix的&lt;/strong&gt;：在类Unix平台上，它是不可能的，所有32位 &lt;code&gt;exit&lt;/code&gt; 将是检查的退出代码父进程可见。在大多数类Unix平台上，仅考虑八个最低有效位。</target>
        </trans-unit>
        <trans-unit id="4c1aa9b3c8e196e8c2b0242b80db4f7600ac8956" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Version &amp;amp; Edition Differences&lt;/strong&gt;: Prior to Rust 1.30, &lt;code&gt;$crate&lt;/code&gt; and &lt;code&gt;local_inner_macros&lt;/code&gt; (below) were unsupported. They were added alongside path-based imports of macros (described above), to ensure that helper macros did not need to be manually imported by users of a macro-exporting crate. Crates written for earlier versions of Rust that use helper macros need to be modified to use &lt;code&gt;$crate&lt;/code&gt; or &lt;code&gt;local_inner_macros&lt;/code&gt; to work well with path-based imports.</source>
          <target state="translated">&lt;strong&gt;版本差异&lt;/strong&gt;：在Rust 1.30之前，不支持 &lt;code&gt;$crate&lt;/code&gt; 和 &lt;code&gt;local_inner_macros&lt;/code&gt; 。将它们与基于路径的宏导入（如上所述）一起添加，以确保宏导出板条箱的用户不需要手动导入辅助宏。为使用Rust的早期版本使用辅助宏编写的板条箱，需要修改以使用 &lt;code&gt;$crate&lt;/code&gt; 或 &lt;code&gt;local_inner_macros&lt;/code&gt; 才能与基于路径的导入配合使用。</target>
        </trans-unit>
        <trans-unit id="a61fe7dcc9b944b7aa4bb3863418ae332c93ffba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;WARNING&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="70d92d3e972f8d8fddf85474fbc20df429ca9e9a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: While various forms of this were discussed in &lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/1937&quot;&gt;RFC #1937&lt;/a&gt;, it was ultimately cut from that RFC, and thus this type is more subject to change even than the usual unstable item churn.</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;：虽然在&lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/1937&quot;&gt;RFC＃1937&lt;/a&gt;中讨论了各种形式，但最终从RFC中删除了该形式，因此，与通常的不稳定项目搅动相比，这种类型更容易发生更改。</target>
        </trans-unit>
        <trans-unit id="430cf372e21694405a7f29b4ea7aae36bbc30335" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;1&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;1&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="0a5afaa9ee5bac968c87333877722aa1495b952b" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="488963209bc6867c0591ac82a1cb9c1a6a118fd7" translate="yes" xml:space="preserve">
          <source>A &quot;meta item&quot; is the syntax used for the &lt;em&gt;Attr&lt;/em&gt; rule by most &lt;a href=&quot;#built-in-attributes-index&quot;&gt;built-in attributes&lt;/a&gt;. It has the following grammar:</source>
          <target state="translated">&amp;ldquo;元项&amp;rdquo;是大多数&lt;a href=&quot;#built-in-attributes-index&quot;&gt;内置属性&lt;/a&gt;用于&lt;em&gt;Attr&lt;/em&gt;规则的语法。它具有以下语法：</target>
        </trans-unit>
        <trans-unit id="a4ab7f7217b5214e279ea052fb2ed3cfbd58c8f2" translate="yes" xml:space="preserve">
          <source>A &quot;meta item&quot; is the syntax used for the &lt;em&gt;Attr&lt;/em&gt; rule by most &lt;a href=&quot;attributes#built-in-attributes-index&quot;&gt;built-in attributes&lt;/a&gt; and the &lt;a href=&quot;macros-by-example&quot;&gt;&lt;code&gt;meta&lt;/code&gt; macro fragment specifier&lt;/a&gt;. It has the following grammar:</source>
          <target state="translated">&amp;ldquo;元项&amp;rdquo;是大多数&lt;a href=&quot;attributes#built-in-attributes-index&quot;&gt;内置属性&lt;/a&gt;和&lt;a href=&quot;macros-by-example&quot;&gt; &lt;code&gt;meta&lt;/code&gt; &lt;/a&gt;宏片段说明符用于&lt;em&gt;Attr&lt;/em&gt;规则的语法。它具有以下语法：</target>
        </trans-unit>
        <trans-unit id="22d3a6ec1e16d0b77c16e420bbe8e26c33c2811f" translate="yes" xml:space="preserve">
          <source>A &quot;stack allocated string&quot;:</source>
          <target state="translated">一个 &quot;堆栈分配的字符串&quot;。</target>
        </trans-unit>
        <trans-unit id="b64a876ef415d016ec9dc92ffaf76e9ab89ca04f" translate="yes" xml:space="preserve">
          <source>A 'radix' here is sometimes also called a 'base'. A radix of two indicates a binary number, a radix of ten, decimal, and a radix of sixteen, hexadecimal, to give some common values. Arbitrary radices are supported.</source>
          <target state="translated">这里的 &quot;弧度 &quot;有时也叫 &quot;基数&quot;。弧度为2的表示二进制数,弧度为10的表示十进制数,弧度为16的表示十六进制数,给出一些常用的数值。支持任意的基数。</target>
        </trans-unit>
        <trans-unit id="41c53bc2a64d3e62babdedd9c3047a7e08995ee3" translate="yes" xml:space="preserve">
          <source>A (half-open) range bounded inclusively below and exclusively above (&lt;code&gt;start..end&lt;/code&gt;).</source>
          <target state="translated">一个（半开）范围包括（开始 &lt;code&gt;start..end&lt;/code&gt; ）以下和范围之外。</target>
        </trans-unit>
        <trans-unit id="e85a39e82a0e6ccf8c895d65c91fa1d7ce99d7cb" translate="yes" xml:space="preserve">
          <source>A 32-bit floating point type (specifically, the &quot;binary32&quot; type defined in IEEE 754-2008).</source>
          <target state="translated">一个32位浮点类型(特别是IEEE 754-2008中定义的 &quot;binary32 &quot;类型)。</target>
        </trans-unit>
        <trans-unit id="10239381d11a9cda1bbf8cfa43daeb6653a356ab" translate="yes" xml:space="preserve">
          <source>A 64-bit floating point type (specifically, the &quot;binary64&quot; type defined in IEEE 754-2008).</source>
          <target state="translated">一个64位浮点类型(特别是IEEE 754-2008中定义的 &quot;binary64 &quot;类型)。</target>
        </trans-unit>
        <trans-unit id="3a791c9e3c1b8c3cb3ad7090a3f0956b3498d4ea" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#infinite-loops&quot;&gt;&lt;code&gt;loop&lt;/code&gt; expression&lt;/a&gt; denotes an infinite loop.</source>
          <target state="translated">甲&lt;a href=&quot;#infinite-loops&quot;&gt; &lt;code&gt;loop&lt;/code&gt; 表达式&lt;/a&gt;表示无限循环。</target>
        </trans-unit>
        <trans-unit id="c403143d347d88d290407287e086a1c24df257de" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#iterator-loops&quot;&gt;&lt;code&gt;for&lt;/code&gt; expression&lt;/a&gt; extracts values from an iterator, looping until the iterator is empty.</source>
          <target state="translated">甲&lt;a href=&quot;#iterator-loops&quot;&gt; &lt;code&gt;for&lt;/code&gt; 表达&lt;/a&gt;从一个迭代中提取的值，循环，直到迭代器是空的。</target>
        </trans-unit>
        <trans-unit id="3523931588ba19ab3285934f4c9625ad5b0ff3e8" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#predicate-loops&quot;&gt;&lt;code&gt;while&lt;/code&gt; expression&lt;/a&gt; loops until a predicate is false.</source>
          <target state="translated">甲&lt;a href=&quot;#predicate-loops&quot;&gt; &lt;code&gt;while&lt;/code&gt; 表达&lt;/a&gt;循环，直到谓词是假的。</target>
        </trans-unit>
        <trans-unit id="43257c2bbdee41f14d8f6aab49394bf581fd3e4e" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#predicate-pattern-loops&quot;&gt;&lt;code&gt;while let&lt;/code&gt; expression&lt;/a&gt; tests a pattern.</source>
          <target state="translated">甲&lt;a href=&quot;#predicate-pattern-loops&quot;&gt; &lt;code&gt;while let&lt;/code&gt; 表达&lt;/a&gt;测试图案。</target>
        </trans-unit>
        <trans-unit id="c1847a494c164bc5812c67ca50bfe2768f6e254d" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../expressions/closure-expr&quot;&gt;closure expression&lt;/a&gt; produces a closure value with a unique, anonymous type that cannot be written out. A closure type is approximately equivalent to a struct which contains the captured variables. For instance, the following closure:</source>
          <target state="translated">甲&lt;a href=&quot;../expressions/closure-expr&quot;&gt;闭合表达&lt;/a&gt;产生具有不能被写出一个独特的，匿名类型的封闭件的值。闭包类型大约等于包含捕获变量的结构。例如，以下关闭：</target>
        </trans-unit>
        <trans-unit id="3cfb72d2748a10ee8855d86ad887d39ff3f43dfe" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../paths&quot;&gt;path&lt;/a&gt; used as an expression context denotes either a local variable or an item. Path expressions that resolve to local or static variables are &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expressions&lt;/a&gt;, other paths are &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expressions&lt;/a&gt;. Using a &lt;a href=&quot;../items/static-items#mutable-statics&quot;&gt;&lt;code&gt;static mut&lt;/code&gt;&lt;/a&gt; variable requires an &lt;a href=&quot;block-expr#unsafe-blocks&quot;&gt;&lt;code&gt;unsafe&lt;/code&gt; block&lt;/a&gt;.</source>
          <target state="translated">甲&lt;a href=&quot;../paths&quot;&gt;路径&lt;/a&gt;用作表达上下文表示在本地变量或一个项目。解析为局部变量或静态变量的路径表达式为&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place表达式&lt;/a&gt;，其他路径为&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value表达式&lt;/a&gt;。使用&lt;a href=&quot;../items/static-items#mutable-statics&quot;&gt; &lt;code&gt;static mut&lt;/code&gt; &lt;/a&gt;变量需要&lt;a href=&quot;block-expr#unsafe-blocks&quot;&gt; &lt;code&gt;unsafe&lt;/code&gt; 块&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8c135626ccc454eee440ccf3a13f0ec15be919ba" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; is a &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value&lt;/a&gt;, which means that it is a &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;Code Point&lt;/a&gt;, but only ones within a certain range. &lt;code&gt;MAX&lt;/code&gt; is the highest valid code point that's a valid &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value&lt;/a&gt;.</source>
          <target state="translated">一个&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;是&lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode标量值&lt;/a&gt;，这意味着它是一个&lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;Code Point&lt;/a&gt;，但仅是在一定范围内的一个。 &lt;code&gt;MAX&lt;/code&gt; 是最高有效代码点，它是有效的&lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode标量值&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e348847ccb660c7b0b5c01ab1a1ba0e9112a0d13" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; is a &lt;a href=&quot;https://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value&lt;/a&gt;, which means that it is a &lt;a href=&quot;https://www.unicode.org/glossary/#code_point&quot;&gt;Code Point&lt;/a&gt;, but only ones within a certain range. &lt;code&gt;MAX&lt;/code&gt; is the highest valid code point that's a valid &lt;a href=&quot;https://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value&lt;/a&gt;.</source>
          <target state="translated">甲&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;是&lt;a href=&quot;https://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode标值&lt;/a&gt;，这意味着它是一个&lt;a href=&quot;https://www.unicode.org/glossary/#code_point&quot;&gt;码点&lt;/a&gt;，但在一定范围内唯一的。 &lt;code&gt;MAX&lt;/code&gt; 是最高有效代码点，它是有效的&lt;a href=&quot;https://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode标量值&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cc3502c112d8c240016de6db9fd46c1abe533f18" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; without structural pinning could &lt;code&gt;impl&amp;lt;T&amp;gt; Unpin for Vec&amp;lt;T&amp;gt;&lt;/code&gt;, because the contents are never pinned and the &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; itself is fine with being moved as well. At that point pinning just has no effect on the vector at all.</source>
          <target state="translated">甲&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;没有结构钉扎所能 &lt;code&gt;impl&amp;lt;T&amp;gt; Unpin for Vec&amp;lt;T&amp;gt;&lt;/code&gt; ，因为内容从未被钉扎和&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;本身是细跟移动为好。那时，固定对向量完全没有影响。</target>
        </trans-unit>
        <trans-unit id="3bd0f4f45a9992b5e83d00a801ad1d124dd353bf" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;enum.searchstep#variant.Match&quot;&gt;&lt;code&gt;Match&lt;/code&gt;&lt;/a&gt; result needs to contain the whole matched pattern, however &lt;a href=&quot;enum.searchstep#variant.Reject&quot;&gt;&lt;code&gt;Reject&lt;/code&gt;&lt;/a&gt; results may be split up into arbitrary many adjacent fragments. Both ranges may have zero length.</source>
          <target state="translated">甲&lt;a href=&quot;enum.searchstep#variant.Match&quot;&gt; &lt;code&gt;Match&lt;/code&gt; &lt;/a&gt;结果需要包含整个匹配的模式，但是&lt;a href=&quot;enum.searchstep#variant.Reject&quot;&gt; &lt;code&gt;Reject&lt;/code&gt; &lt;/a&gt;结果可以被分成任意许多相邻的片段。两个范围的长度都可以为零。</target>
        </trans-unit>
        <trans-unit id="817aefb1123a860203996fe1bc087199cf9a9301" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;fn.null&quot;&gt;null&lt;/a&gt; pointer is &lt;em&gt;never&lt;/em&gt; valid, not even for accesses of &lt;a href=&quot;https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts&quot;&gt;size zero&lt;/a&gt;.</source>
          <target state="translated">一个&lt;a href=&quot;fn.null&quot;&gt;空&lt;/a&gt;指针&lt;em&gt;永远不会&lt;/em&gt;有效，甚至没有为访问&lt;a href=&quot;https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts&quot;&gt;大小为零&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="64470c49d997c71e612fbbb1108517461ba5028e" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;items/associated-items#methods&quot;&gt;method&lt;/a&gt; defined in an &lt;a href=&quot;items/implementations#inherent-implementations&quot;&gt;inherent implementation&lt;/a&gt;, not in a trait implementation.</source>
          <target state="translated">在&lt;a href=&quot;items/implementations#inherent-implementations&quot;&gt;固有实现中&lt;/a&gt;定义的&lt;a href=&quot;items/associated-items#methods&quot;&gt;方法&lt;/a&gt;，而不是特征实现中定义的方法。</target>
        </trans-unit>
        <trans-unit id="2929c70726dc937049a9f5950f13c4723ad1c193" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;loop-expr#infinite-loops&quot;&gt;&lt;code&gt;loop&lt;/code&gt; expression&lt;/a&gt; denotes an infinite loop.</source>
          <target state="translated">甲&lt;a href=&quot;loop-expr#infinite-loops&quot;&gt; &lt;code&gt;loop&lt;/code&gt; 表达式&lt;/a&gt;表示无限循环。</target>
        </trans-unit>
        <trans-unit id="e86e93a58bbbbc71c44b9b885a659ff826ce9490" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;loop-expr#iterator-loops&quot;&gt;&lt;code&gt;for&lt;/code&gt; expression&lt;/a&gt; extracts values from an iterator, looping until the iterator is empty.</source>
          <target state="translated">甲&lt;a href=&quot;loop-expr#iterator-loops&quot;&gt; &lt;code&gt;for&lt;/code&gt; 表达&lt;/a&gt;从一个迭代中提取的值，循环，直到迭代器是空的。</target>
        </trans-unit>
        <trans-unit id="78d2df8a50ce969bca66a5211eeeb6570b3f1784" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;loop-expr#predicate-loops&quot;&gt;&lt;code&gt;while&lt;/code&gt; expression&lt;/a&gt; loops until a predicate is false.</source>
          <target state="translated">甲&lt;a href=&quot;loop-expr#predicate-loops&quot;&gt; &lt;code&gt;while&lt;/code&gt; 表达&lt;/a&gt;循环，直到谓词是假的。</target>
        </trans-unit>
        <trans-unit id="506fd8c66fe2c3330ab3ababc69a27680d58db08" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;loop-expr#predicate-pattern-loops&quot;&gt;&lt;code&gt;while let&lt;/code&gt; expression&lt;/a&gt; tests a pattern.</source>
          <target state="translated">甲&lt;a href=&quot;loop-expr#predicate-pattern-loops&quot;&gt; &lt;code&gt;while let&lt;/code&gt; 表达&lt;/a&gt;测试图案。</target>
        </trans-unit>
        <trans-unit id="33cacd9cafdfaf3ef4cf01b5b7dfb994c4cd9727" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;patterns#struct-patterns&quot;&gt;struct&lt;/a&gt;, &lt;a href=&quot;patterns#tuple-patterns&quot;&gt;tuple&lt;/a&gt;, &lt;a href=&quot;patterns#tuple-struct-patterns&quot;&gt;tuple struct&lt;/a&gt;, or &lt;a href=&quot;patterns#slice-patterns&quot;&gt;slice&lt;/a&gt; pattern where at least one of the direct subpatterns is a extending pattern.</source>
          <target state="translated">一种&lt;a href=&quot;patterns#struct-patterns&quot;&gt;struct&lt;/a&gt;，&lt;a href=&quot;patterns#tuple-patterns&quot;&gt;tuple&lt;/a&gt;，&lt;a href=&quot;patterns#tuple-struct-patterns&quot;&gt;tuple struct&lt;/a&gt;或&lt;a href=&quot;patterns#slice-patterns&quot;&gt;slice&lt;/a&gt;模式，其中直接子模式中的至少一个是扩展模式。</target>
        </trans-unit>
        <trans-unit id="8b1f2559cf32a60aeffbe295d8dcc8b7d2d1bc74" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; might contain non-Unicode data. This &lt;code&gt;struct&lt;/code&gt; implements the &lt;a href=&quot;../fmt/trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; trait in a way that mitigates that. It is created by the &lt;a href=&quot;struct.path#method.display&quot;&gt;&lt;code&gt;display&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">一个&lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt;可能包含非Unicode数据。此 &lt;code&gt;struct&lt;/code&gt; 以缓解这种情况的方式实现了&lt;a href=&quot;../fmt/trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt;特质。它是通过&lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.path#method.display&quot;&gt; &lt;code&gt;display&lt;/code&gt; &lt;/a&gt;方法创建的。</target>
        </trans-unit>
        <trans-unit id="8ad6cb9fb2de3ff94c9692c27c57c7195ec6d6cb" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt; ensures that the pointee of any pointer type &lt;code&gt;P&lt;/code&gt; has a stable location in memory, meaning it cannot be moved elsewhere and its memory cannot be deallocated until it gets dropped. We say that the pointee is &quot;pinned&quot;.</source>
          <target state="translated">甲&lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; &lt;/a&gt;确保任何指针类型的指针对象 &lt;code&gt;P&lt;/code&gt; 的存储器中存有稳定位置，这意味着它不能被移动到其它地方和它的存储器不能被释放，直到其被丢弃。我们说指向对象是&amp;ldquo;固定&amp;rdquo;的。</target>
        </trans-unit>
        <trans-unit id="a15e8cc8aa6158fcb3389cfdaf6e7e84bacae80c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;struct.sender&quot;&gt;&lt;code&gt;Sender&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.syncsender&quot;&gt;&lt;code&gt;SyncSender&lt;/code&gt;&lt;/a&gt; is used to send data to a &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt;. Both senders are clone-able (multi-producer) such that many threads can send simultaneously to one receiver (single-consumer).</source>
          <target state="translated">甲&lt;a href=&quot;struct.sender&quot;&gt; &lt;code&gt;Sender&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;struct.syncsender&quot;&gt; &lt;code&gt;SyncSender&lt;/code&gt; &lt;/a&gt;用于将数据发送到&lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt;。两个发送者都是可克隆的（多生产者），因此许多线程可以同时发送到一个接收者（单个消费者）。</target>
        </trans-unit>
        <trans-unit id="e878b6c48911644ea2ee908e204d14d9ba8414f3" translate="yes" xml:space="preserve">
          <source>A &lt;code id=&quot;a-worker-struct-responsible-for-sending-code-from-the-threadpool-to-a-thread&quot;&gt;Worker&lt;/code&gt; Struct Responsible for Sending Code from the &lt;code&gt;ThreadPool&lt;/code&gt; to a Thread</source>
          <target state="translated">一个 &lt;code id=&quot;a-worker-struct-responsible-for-sending-code-from-the-threadpool-to-a-thread&quot;&gt;Worker&lt;/code&gt; 结构负责从发送代码 &lt;code&gt;ThreadPool&lt;/code&gt; 的主题</target>
        </trans-unit>
        <trans-unit id="f340f8a1c0de4fb7863ae5c6dacd93b470ac42d8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;!&lt;/code&gt; (all values are invalid for this type).</source>
          <target state="translated">A &lt;code&gt;!&lt;/code&gt; （此类型的所有值均无效）。</target>
        </trans-unit>
        <trans-unit id="cb1329292e0705741bc6efb49bebc4980736dafb" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;#![feature]&lt;/code&gt; attribute was declared for a feature that is stable in the current edition, but not in all editions.</source>
          <target state="translated">一个 &lt;code&gt;#![feature]&lt;/code&gt; 属性被宣布为一个特点，就是在当前的版本稳定，但并不适用于所有版本。</target>
        </trans-unit>
        <trans-unit id="aaa8a708af81269c0b5576d02729333db199fa1d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;#![feature]&lt;/code&gt; attribute was declared multiple times.</source>
          <target state="translated">一个 &lt;code&gt;#![feature]&lt;/code&gt; 属性已多次声明。</target>
        </trans-unit>
        <trans-unit id="871ef5c0f72000286445ffa6aeaeb13201eef94a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;#[lang = &quot;..&quot;]&lt;/code&gt; attribute was placed on the wrong item type.</source>
          <target state="translated">甲 &lt;code&gt;#[lang = &quot;..&quot;]&lt;/code&gt; 的属性被放置在错误的项目类型。</target>
        </trans-unit>
        <trans-unit id="12a617fa960129a71a59055ffc0553333e4d1938" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;#[marker]&lt;/code&gt; trait contained an associated item.</source>
          <target state="translated">甲 &lt;code&gt;#[marker]&lt;/code&gt; 性状包含在相关联的项目。</target>
        </trans-unit>
        <trans-unit id="9dfceb8cd31c1c51915cc559ef8cce0d369c7062" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;#[repr(..)]&lt;/code&gt; attribute was placed on an unsupported item.</source>
          <target state="translated">甲 &lt;code&gt;#[repr(..)]&lt;/code&gt; 属性被放置在不支持的项目。</target>
        </trans-unit>
        <trans-unit id="0a9d6b916ce0da508f854e05a1feec7e0befaef9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;#[repr(inttype)]&lt;/code&gt; must be provided on an &lt;code&gt;enum&lt;/code&gt; if it has a non-unit variant with a discriminant, or where there are both unit variants with discriminants and non-unit variants. This restriction ensures that there is a well-defined way to extract a variant's discriminant from a value; for instance:</source>
          <target state="translated">甲 &lt;code&gt;#[repr(inttype)]&lt;/code&gt; 必须被设置在 &lt;code&gt;enum&lt;/code&gt; 如果它具有与一个判别非单元的变体，或其中有两个单元与判别和非变体单元的变体。此限制确保存在一种明确定义的方法，可从值中提取变量的判别式；例如：</target>
        </trans-unit>
        <trans-unit id="b12f48dd90abc9841d426a5fab9c2ec4ff61214a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;#[simd]&lt;/code&gt; attribute was applied to an empty tuple struct.</source>
          <target state="translated">甲 &lt;code&gt;#[simd]&lt;/code&gt; 属性被应用于空元组结构体。</target>
        </trans-unit>
        <trans-unit id="c012898141fc2cec018c7c222ae43346e5dd5f44" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;amp;T&lt;/code&gt; reference can be released to safe code and there it can co-exist with other &lt;code&gt;&amp;amp;T&lt;/code&gt; references, but not with a &lt;code&gt;&amp;amp;mut T&lt;/code&gt;</source>
          <target state="translated">一个 &lt;code&gt;&amp;amp;T&lt;/code&gt; 的参考可以被释放到安全的代码，有可以共存与其他 &lt;code&gt;&amp;amp;T&lt;/code&gt; 的参考，但不具有 &lt;code&gt;&amp;amp;mut T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ec5710ef1f0b84eb29b3c1cc1f924e822fb56fa" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;amp;mut T&lt;/code&gt; reference may be released to safe code provided neither other &lt;code&gt;&amp;amp;mut T&lt;/code&gt; nor &lt;code&gt;&amp;amp;T&lt;/code&gt; co-exist with it. A &lt;code&gt;&amp;amp;mut T&lt;/code&gt; must always be unique.</source>
          <target state="translated">如果没有其他 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 和 &lt;code&gt;&amp;amp;T&lt;/code&gt; 共存，则可以将 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 参考发布到安全代码。一个 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 必须是唯一的。</target>
        </trans-unit>
        <trans-unit id="40585fc29df20c1219babfcdddcfc95974719e32" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;amp;str&lt;/code&gt; is made up of two components: a pointer to some bytes, and a length. You can look at these with the &lt;a href=&quot;#method.as_ptr&quot;&gt;&lt;code&gt;as_ptr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; methods:</source>
          <target state="translated">甲 &lt;code&gt;&amp;amp;str&lt;/code&gt; 由两个部件组成：一个指向一些字节，和长度。您可以使用&lt;a href=&quot;#method.as_ptr&quot;&gt; &lt;code&gt;as_ptr&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#method.len&quot;&gt; &lt;code&gt;len&lt;/code&gt; &lt;/a&gt;方法查看这些内容：</target>
        </trans-unit>
        <trans-unit id="96eae277d841da5acce951109ccad7e43958c9c5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;amp;str&lt;/code&gt; is made up of two components: a pointer to some bytes, and a length. You can look at these with the &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html#method.as_ptr&quot;&gt;&lt;code&gt;as_ptr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; methods:</source>
          <target state="translated">甲 &lt;code&gt;&amp;amp;str&lt;/code&gt; 由两个部件组成：一个指向一些字节，和长度。您可以使用&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html#method.as_ptr&quot;&gt; &lt;code&gt;as_ptr&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html#method.len&quot;&gt; &lt;code&gt;len&lt;/code&gt; &lt;/a&gt;方法查看这些内容：</target>
        </trans-unit>
        <trans-unit id="d26915dade1d3ce3c223fcfcc944e12fb9d06d42" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;BarrierWaitResult&lt;/code&gt; is returned by &lt;a href=&quot;struct.barrier#method.wait&quot;&gt;&lt;code&gt;Barrier::wait()&lt;/code&gt;&lt;/a&gt; when all threads in the &lt;a href=&quot;struct.barrier&quot;&gt;&lt;code&gt;Barrier&lt;/code&gt;&lt;/a&gt; have rendezvoused.</source>
          <target state="translated">一个 &lt;code&gt;BarrierWaitResult&lt;/code&gt; 被返回&lt;a href=&quot;struct.barrier#method.wait&quot;&gt; &lt;code&gt;Barrier::wait()&lt;/code&gt; &lt;/a&gt;当所有线程&lt;a href=&quot;struct.barrier&quot;&gt; &lt;code&gt;Barrier&lt;/code&gt; &lt;/a&gt;已经约会了。</target>
        </trans-unit>
        <trans-unit id="35fb8d8640dfbea523c47310a34e3d854229d236" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;BarrierWaitResult&lt;/code&gt; is returned by &lt;a href=&quot;struct.barrier#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; when all threads in the &lt;a href=&quot;struct.barrier&quot;&gt;&lt;code&gt;Barrier&lt;/code&gt;&lt;/a&gt; have rendezvoused.</source>
          <target state="translated">一个 &lt;code&gt;BarrierWaitResult&lt;/code&gt; 由返回&lt;a href=&quot;struct.barrier#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;时的所有线程&lt;a href=&quot;struct.barrier&quot;&gt; &lt;code&gt;Barrier&lt;/code&gt; &lt;/a&gt;已经约会了。</target>
        </trans-unit>
        <trans-unit id="a33fe1ab5786729bf200982553a4a40b28677c12" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;BufRead&lt;/code&gt; is a type of &lt;code&gt;Read&lt;/code&gt;er which has an internal buffer, allowing it to perform extra ways of reading.</source>
          <target state="translated">一 &lt;code&gt;BufRead&lt;/code&gt; 是一种类型的 &lt;code&gt;Read&lt;/code&gt; 呃其中有一个内部缓冲区，允许它执行额外的阅读方式。</target>
        </trans-unit>
        <trans-unit id="c2a7d564e1881467808b1da26fc7f621d550ac35" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;BuildHasher&lt;/code&gt; is typically used (e.g., by &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;) to create &lt;a href=&quot;trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt;s for each key such that they are hashed independently of one another, since &lt;a href=&quot;trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt;s contain state.</source>
          <target state="translated">甲 &lt;code&gt;BuildHasher&lt;/code&gt; 通常用于（例如，通过&lt;a href=&quot;../collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; 中&lt;/a&gt;）来创建&lt;a href=&quot;trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt;为每个键这样s表示它们彼此独立地散列，由于&lt;a href=&quot;trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt;小号包含状态。</target>
        </trans-unit>
        <trans-unit id="5ac6d9ca4b25b818aa6f9cb17715ea50c25bf2ef" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CString&lt;/code&gt; is created from either a byte slice or a byte vector, or anything that implements &lt;a href=&quot;../convert/trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; (for example, you can build a &lt;code&gt;CString&lt;/code&gt; straight out of a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;, since both implement that trait).</source>
          <target state="translated">一个 &lt;code&gt;CString&lt;/code&gt; 的是，无论是从字节片或一个字节向量，或任何创造一个实现&lt;a href=&quot;../convert/trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; （例如，你可以建立一个 &lt;code&gt;CString&lt;/code&gt; 的直出的&lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;，因为这两种实现该特性）。</target>
        </trans-unit>
        <trans-unit id="a976b86b7133ebd168dd44069ca430099fb11fcd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CString&lt;/code&gt; is created from either a byte slice or a byte vector, or anything that implements &lt;a href=&quot;../convert/trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; (for example, you can build a &lt;code&gt;CString&lt;/code&gt; straight out of a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;, since both implement that trait).</source>
          <target state="translated">一个 &lt;code&gt;CString&lt;/code&gt; 的是，无论是从字节片或一个字节向量，或任何创造一个实现&lt;a href=&quot;../convert/trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; （例如，你可以建立一个 &lt;code&gt;CString&lt;/code&gt; 的直出的&lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;，因为这两种实现该特性）。</target>
        </trans-unit>
        <trans-unit id="bef22157720da42f049eda44831ae9039ff96672" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Component&lt;/code&gt; roughly corresponds to a substring between path separators (&lt;code&gt;/&lt;/code&gt; or ).</source>
          <target state="translated">甲 &lt;code&gt;Component&lt;/code&gt; 大致对应于路径分离器（之间的串 &lt;code&gt;/&lt;/code&gt; 或）。</target>
        </trans-unit>
        <trans-unit id="00d5a6a3fb8d035432bd26a66264da1cd9fcfcb1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Component&lt;/code&gt; roughly corresponds to a substring between path separators (&lt;code&gt;/&lt;/code&gt; or &lt;code&gt;\&lt;/code&gt;).</source>
          <target state="translated">甲 &lt;code&gt;Component&lt;/code&gt; 大致对应于路径的隔离层之间的子字符串（ &lt;code&gt;/&lt;/code&gt; 或 &lt;code&gt;\&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f8dc93d165313d1d53fe035b20236e511c258009" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Cursor&lt;/code&gt; is like an iterator, except that it can freely seek back-and-forth, and can safely mutate the list during iteration. This is because the lifetime of its yielded references is tied to its own lifetime, instead of just the underlying list. This means cursors cannot yield multiple elements at once.</source>
          <target state="translated">一个 &lt;code&gt;Cursor&lt;/code&gt; 就像是一个迭代器，但它可以自由寻找回来的往复，并且迭代过程中可以安全地发生变异的名单。这是因为其产生的引用的生存期与其自身的生存期相关联，而不仅仅是基础列表。这意味着游标不能一次产生多个元素。</target>
        </trans-unit>
        <trans-unit id="d1edbc893c845d675ae565c5adc4b48af73fbd0b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Cursor&lt;/code&gt; is like an iterator, except that it can freely seek back-and-forth.</source>
          <target state="translated">一个 &lt;code&gt;Cursor&lt;/code&gt; 就像是一个迭代器，但它可以自由寻找回往复。</target>
        </trans-unit>
        <trans-unit id="592f6bf36d948cda2dbd34364696113591fa1887" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Cursor&lt;/code&gt; wraps an in-memory buffer and provides it with a &lt;a href=&quot;trait.seek&quot;&gt;&lt;code&gt;Seek&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">一个 &lt;code&gt;Cursor&lt;/code&gt; 包装的内存缓冲区，并为它提供了一个&lt;a href=&quot;trait.seek&quot;&gt; &lt;code&gt;Seek&lt;/code&gt; &lt;/a&gt;实现。</target>
        </trans-unit>
        <trans-unit id="a89cb140638fa3cd771cb02496374d776ad6d007" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Duration&lt;/code&gt; type to represent a span of time, typically used for system timeouts.</source>
          <target state="translated">甲 &lt;code&gt;Duration&lt;/code&gt; 类型来表示的时间跨度，通常用于系统超时。</target>
        </trans-unit>
        <trans-unit id="e39d340a59cb5b2bb2e11548f7d50ffd50cdcaa5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Formatter&lt;/code&gt; represents various options related to formatting. Users do not construct &lt;code&gt;Formatter&lt;/code&gt;s directly; a mutable reference to one is passed to the &lt;code&gt;fmt&lt;/code&gt; method of all formatting traits, like &lt;a href=&quot;trait.debug&quot;&gt;&lt;code&gt;Debug&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">一个 &lt;code&gt;Formatter&lt;/code&gt; 表示与格式化的各种选项。用户不直接构造 &lt;code&gt;Formatter&lt;/code&gt; ；可变引用会传递给所有格式特征的 &lt;code&gt;fmt&lt;/code&gt; 方法，例如&lt;a href=&quot;trait.debug&quot;&gt; &lt;code&gt;Debug&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="921821ce37ee7be55d1f4cd9ec14a09989a7422f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;HashMap&lt;/code&gt; with fixed list of elements can be initialized from an array:</source>
          <target state="translated">甲 &lt;code&gt;HashMap&lt;/code&gt; 中的元素的固定列表可以从数组进行初始化：</target>
        </trans-unit>
        <trans-unit id="9e3e7578434780dbd4d9d999f38a9955ea8f8204" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;HashSet&lt;/code&gt; with fixed list of elements can be initialized from an array:</source>
          <target state="translated">甲 &lt;code&gt;HashSet&lt;/code&gt; 的与元件的固定列表可以从数组进行初始化：</target>
        </trans-unit>
        <trans-unit id="9b7c01af6b5011fee801753cdfcb67030ddd18ba" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;JoinHandle&lt;/code&gt;&lt;em&gt;detaches&lt;/em&gt; the associated thread when it is dropped, which means that there is no longer any handle to thread and no way to &lt;code&gt;join&lt;/code&gt; on it.</source>
          <target state="translated">一个 &lt;code&gt;JoinHandle&lt;/code&gt; &lt;em&gt;分离&lt;/em&gt;相关的线程，当它被删除，这意味着不再有任何处理线程，没办法 &lt;code&gt;join&lt;/code&gt; 就可以了。</target>
        </trans-unit>
        <trans-unit id="134a2452be93d4c2cdb1b9f1f0542b4b65ecae3d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;LocalKey&lt;/code&gt;'s initializer cannot recursively depend on itself, and using a &lt;code&gt;LocalKey&lt;/code&gt; in this way will cause the initializer to infinitely recurse on the first call to &lt;code&gt;with&lt;/code&gt;.</source>
          <target state="translated">一个 &lt;code&gt;LocalKey&lt;/code&gt; 的初始化不能递归地依赖于自身，并使用 &lt;code&gt;LocalKey&lt;/code&gt; 以这种方式将导致初始化无限递归的第一次调用 &lt;code&gt;with&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c72c40c2b2da09870992c3f25ebf2fd884c3cef5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Match&lt;/code&gt; result needs to contain the whole matched pattern, however &lt;code&gt;Reject&lt;/code&gt; results may be split up into arbitrary many adjacent fragments. Both ranges may have zero length.</source>
          <target state="translated">甲 &lt;code&gt;Match&lt;/code&gt; 结果需要包含整个匹配的模式，但是 &lt;code&gt;Reject&lt;/code&gt; 结果可以被分成任意许多相邻的片段。两个范围的长度都可以为零。</target>
        </trans-unit>
        <trans-unit id="14d52da7769e774ed02f1e53e420687489f136bc" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Pattern&amp;lt;'a&amp;gt;&lt;/code&gt; expresses that the implementing type can be used as a string pattern for searching in a &lt;a href=&quot;../../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;'a str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">甲 &lt;code&gt;Pattern&amp;lt;'a&amp;gt;&lt;/code&gt; 表示，各执行类型可以作为字符串模式用于在搜索&lt;a href=&quot;../../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;'a str&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5668f2d21fa477474ed4b8f6c89c068e50ff97ac" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Pattern&amp;lt;'a&amp;gt;&lt;/code&gt; expresses that the implementing type can be used as a string pattern for searching in a &lt;code&gt;&amp;amp;'a str&lt;/code&gt;.</source>
          <target state="translated">甲 &lt;code&gt;Pattern&amp;lt;'a&amp;gt;&lt;/code&gt; 表示，各执行类型可以作为字符串模式用于在搜索 &lt;code&gt;&amp;amp;'a str&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb85096bf6f841f9bc42b20ab21fbdaddee5e86c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;RawWaker&lt;/code&gt; allows the implementor of a task executor to create a &lt;a href=&quot;struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; which provides customized wakeup behavior.</source>
          <target state="translated">一个 &lt;code&gt;RawWaker&lt;/code&gt; 允许任务执行的实施者创建&lt;a href=&quot;struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt;提供定制唤醒行为。</target>
        </trans-unit>
        <trans-unit id="1193137c297d5cbd26cbbc2bf90d52838e50813a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;String&lt;/code&gt; can grow in size and its contents can change, just like the contents of a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, if you push more data into it. In addition, you can conveniently use the &lt;code&gt;+&lt;/code&gt; operator or the &lt;code&gt;format!&lt;/code&gt; macro to concatenate &lt;code&gt;String&lt;/code&gt; values.</source>
          <target state="translated">一个 &lt;code&gt;String&lt;/code&gt; 的大小可能会和它的内容可以改变，就像一个内容 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; ，如果你把更多的数据到它。另外，您可以方便地使用 &lt;code&gt;+&lt;/code&gt; 运算符或 &lt;code&gt;format!&lt;/code&gt; 宏以连接 &lt;code&gt;String&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="ad2a4c35b866459c9366f5bbd3c6f621ece58985" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;String&lt;/code&gt; is a wrapper over a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;. Let&amp;rsquo;s look at some of our properly encoded UTF-8 example strings from Listing 8-14. First, this one:</source>
          <target state="translated">甲 &lt;code&gt;String&lt;/code&gt; 是在一个包装 &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; 。让我们看一下清单8-14中一些正确编码的UTF-8示例字符串。首先，这个：</target>
        </trans-unit>
        <trans-unit id="dcd60f52764dfb12603585382f304c29b3d891eb" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;String&lt;/code&gt; is made up of three components: a pointer to some bytes, a length, and a capacity. The pointer points to an internal buffer &lt;code&gt;String&lt;/code&gt; uses to store its data. The length is the number of bytes currently stored in the buffer, and the capacity is the size of the buffer in bytes. As such, the length will always be less than or equal to the capacity.</source>
          <target state="translated">甲 &lt;code&gt;String&lt;/code&gt; 由三个组件构成：一个指向一些字节，长度和容量。指针指向 &lt;code&gt;String&lt;/code&gt; 用于存储其数据的内部缓冲区。长度是当前存储在缓冲区中的字节数，容量是缓冲区的大小（以字节为单位）。这样，长度将始终小于或等于容量。</target>
        </trans-unit>
        <trans-unit id="2ad19c9717a97c44c08a93976b602e0990d24669" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SystemTimeError&lt;/code&gt; is returned from the &lt;a href=&quot;struct.systemtime#method.duration_since&quot;&gt;&lt;code&gt;SystemTime::duration_since&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.systemtime#method.elapsed&quot;&gt;&lt;code&gt;SystemTime::elapsed&lt;/code&gt;&lt;/a&gt; methods whenever the second system time represents a point later in time than the &lt;code&gt;self&lt;/code&gt; of the method call.</source>
          <target state="translated">甲 &lt;code&gt;SystemTimeError&lt;/code&gt; 从返回&lt;a href=&quot;struct.systemtime#method.duration_since&quot;&gt; &lt;code&gt;SystemTime::duration_since&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;struct.systemtime#method.elapsed&quot;&gt; &lt;code&gt;SystemTime::elapsed&lt;/code&gt; &lt;/a&gt;每当第二系统时间以后表示的时间点比所述方法 &lt;code&gt;self&lt;/code&gt; 方法调用的。</target>
        </trans-unit>
        <trans-unit id="2815fef167ebe8b526c9b5e3287501b1039ea114" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SystemTimeError&lt;/code&gt; is returned from the &lt;a href=&quot;struct.systemtime#method.duration_since&quot;&gt;&lt;code&gt;duration_since&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.systemtime#method.elapsed&quot;&gt;&lt;code&gt;elapsed&lt;/code&gt;&lt;/a&gt; methods of &lt;a href=&quot;struct.systemtime&quot;&gt;&lt;code&gt;SystemTime&lt;/code&gt;&lt;/a&gt; whenever the second system time represents a point later in time than the &lt;code&gt;self&lt;/code&gt; of the method call.</source>
          <target state="translated">甲 &lt;code&gt;SystemTimeError&lt;/code&gt; 从返回&lt;a href=&quot;struct.systemtime#method.duration_since&quot;&gt; &lt;code&gt;duration_since&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;struct.systemtime#method.elapsed&quot;&gt; &lt;code&gt;elapsed&lt;/code&gt; &lt;/a&gt;的方法&lt;a href=&quot;struct.systemtime&quot;&gt; &lt;code&gt;SystemTime&lt;/code&gt; &lt;/a&gt;每当第二系统时间以后代表点在时间上比 &lt;code&gt;self&lt;/code&gt; 所述方法调用的。</target>
        </trans-unit>
        <trans-unit id="f0e9bc60c4e3276e60ae09f7f961f64e01c5bfbd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;ThreadId&lt;/code&gt; is an opaque object that has a unique value for each thread that creates one. &lt;code&gt;ThreadId&lt;/code&gt;s are not guaranteed to correspond to a thread's system-designated identifier. A &lt;code&gt;ThreadId&lt;/code&gt; can be retrieved from the &lt;a href=&quot;struct.thread#method.id&quot;&gt;&lt;code&gt;id&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;struct.thread&quot;&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">甲 &lt;code&gt;ThreadId&lt;/code&gt; 是具有用于创建一个每个线程的唯一值的不透明对象。不能保证 &lt;code&gt;ThreadId&lt;/code&gt; 与线程的系统指定标识符相对应。甲 &lt;code&gt;ThreadId&lt;/code&gt; 可以从被检索&lt;a href=&quot;struct.thread#method.id&quot;&gt; &lt;code&gt;id&lt;/code&gt; &lt;/a&gt;上的方法&lt;a href=&quot;struct.thread&quot;&gt; &lt;code&gt;Thread&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b1818d010b7b29b87c4502d46870a6345ca3ee68" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TypeId&lt;/code&gt; is currently only available for types which ascribe to &lt;code&gt;'static&lt;/code&gt;, but this limitation may be removed in the future.</source>
          <target state="translated">一个 &lt;code&gt;TypeId&lt;/code&gt; 是目前仅适用于类型的归于 &lt;code&gt;'static&lt;/code&gt; ，但这种限制可能在将来被移除。</target>
        </trans-unit>
        <trans-unit id="5b2832f9ef1617c1a164688031f12174b8e5931d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TypeId&lt;/code&gt; represents a globally unique identifier for a type.</source>
          <target state="translated">甲 &lt;code&gt;TypeId&lt;/code&gt; 表示用于类型的全局唯一标识符。</target>
        </trans-unit>
        <trans-unit id="05e63a516d556e9577522a23860139fad9899875" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Vec&lt;/code&gt; can be mutable. Slices, on the other hand, are read-only objects. To get a &lt;a href=&quot;../primitive.slice&quot;&gt;slice&lt;/a&gt;, use &lt;a href=&quot;../primitive.reference&quot;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/a&gt;. Example:</source>
          <target state="translated">一个 &lt;code&gt;Vec&lt;/code&gt; 可以是可变的。另一方面，切片是只读对象。要获取&lt;a href=&quot;../primitive.slice&quot;&gt;切片&lt;/a&gt;，请使用&lt;a href=&quot;../primitive.reference&quot;&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;/a&gt;。例子：</target>
        </trans-unit>
        <trans-unit id="345e82ed2183b66aaf325e8ad24887f5dd3ff3ad" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Vec&lt;/code&gt; can be mutable. Slices, on the other hand, are read-only objects. To get a slice, use &lt;code&gt;&amp;amp;&lt;/code&gt;. Example:</source>
          <target state="translated">一个 &lt;code&gt;Vec&lt;/code&gt; 可以是可变的。另一方面，切片是只读对象。要获取切片，请使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 。例：</target>
        </trans-unit>
        <trans-unit id="84a3e0757f03c2cf35d8f4ee02786937e5e0845a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Waker&lt;/code&gt; is a handle for waking up a task by notifying its executor that it is ready to be run.</source>
          <target state="translated">一 &lt;code&gt;Waker&lt;/code&gt; 是通过通知其执行者，它已准备好运行醒来任务的句柄。</target>
        </trans-unit>
        <trans-unit id="d9bc289fc584bbfaef86d0de4ba94863300845d3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Weak&lt;/code&gt; pointer is useful for keeping a temporary reference to the allocation managed by &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; without preventing its inner value from being dropped. It is also used to prevent circular references between &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; pointers, since mutual owning references would never allow either &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; to be dropped. For example, a tree could have strong &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;code&gt;Weak&lt;/code&gt; pointers from children back to their parents.</source>
          <target state="translated">甲 &lt;code&gt;Weak&lt;/code&gt; 指针是用于保持临时参考所管理的分配有用&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;而不妨碍被丢弃其内的值。它也用于防止&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;指针之间的循环引用，因为相互拥有的引用将永远不允许丢弃任何一个&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;。例如，一棵树可能具有从父节点到子节点的强&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;指针，而从子节点到其父节点的 &lt;code&gt;Weak&lt;/code&gt; 指针。</target>
        </trans-unit>
        <trans-unit id="a226c54ce6028079ee3f0e935344b03753cf6ea2" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Weak&lt;/code&gt; pointer is useful for keeping a temporary reference to the allocation managed by &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; without preventing its inner value from being dropped. It is also used to prevent circular references between &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers, since mutual owning references would never allow either &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; to be dropped. For example, a tree could have strong &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;code&gt;Weak&lt;/code&gt; pointers from children back to their parents.</source>
          <target state="translated">甲 &lt;code&gt;Weak&lt;/code&gt; 指针是用于保持临时参考所管理的分配有用&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;而不妨碍被丢弃其内的值。它也用于防止&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;指针之间的循环引用，因为相互拥有的引用永远不会丢弃&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;中的任何一个。例如，一棵树可能具有从父节点到子节点的强&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;指针，而从子节点到其父节点的 &lt;code&gt;Weak&lt;/code&gt; 指针。</target>
        </trans-unit>
        <trans-unit id="92c5425b2664515a7d6b0bd3279f583d1e16c172" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Weak&lt;/code&gt; pointer is useful for keeping a temporary reference to the value within &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; without extending its lifetime. It is also used to prevent circular references between &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; pointers, since mutual owning references would never allow either &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; to be dropped. For example, a tree could have strong &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;code&gt;Weak&lt;/code&gt; pointers from children back to their parents.</source>
          <target state="translated">甲 &lt;code&gt;Weak&lt;/code&gt; 指针是用于保持临时参照内的值有用的&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;而不延伸其寿命。它也用于防止&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;指针之间的循环引用，因为相互拥有的引用绝不允许丢弃任何一个&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;。例如，一棵树可能具有从父节点到子节点的强&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;指针，而从子节点到其父节点的 &lt;code&gt;Weak&lt;/code&gt; 指针。</target>
        </trans-unit>
        <trans-unit id="c317832e61e5046de4792c85bcf63089c251292c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Weak&lt;/code&gt; pointer is useful for keeping a temporary reference to the value within &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; without extending its lifetime. It is also used to prevent circular references between &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers, since mutual owning references would never allow either &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; to be dropped. For example, a tree could have strong &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;code&gt;Weak&lt;/code&gt; pointers from children back to their parents.</source>
          <target state="translated">甲 &lt;code&gt;Weak&lt;/code&gt; 指针是用于保持临时参照内的值有用&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;而不延伸其寿命。它也用于防止&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;指针之间的循环引用，因为相互拥有的引用将永远不允许丢弃&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;。例如，一棵树可能具有从父节点到子节点的强&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;指针，而从子节点到其父节点的 &lt;code&gt;Weak&lt;/code&gt; 指针。</target>
        </trans-unit>
        <trans-unit id="2ab6f5c59e2d0418f87950a3ebfb26ab14b557db" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; expression is normally associated with the innermost &lt;code&gt;loop&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; or &lt;code&gt;while&lt;/code&gt; loop enclosing the &lt;code&gt;break&lt;/code&gt; expression, but a &lt;a href=&quot;#loop-labels&quot;&gt;label&lt;/a&gt; can be used to specify which enclosing loop is affected. Example:</source>
          <target state="translated">一个 &lt;code&gt;break&lt;/code&gt; 表达式通常与最里面的 &lt;code&gt;loop&lt;/code&gt; 相关联， &lt;code&gt;for&lt;/code&gt; 或 &lt;code&gt;while&lt;/code&gt; 循环包含 &lt;code&gt;break&lt;/code&gt; 表达式，但是&lt;a href=&quot;#loop-labels&quot;&gt;标签&lt;/a&gt;可用于指定受影响的那个封闭循环。例子：</target>
        </trans-unit>
        <trans-unit id="4bf74475c310d76b2da5f50f50fec722f68f826f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; expression is normally associated with the innermost &lt;code&gt;loop&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; or &lt;code&gt;while&lt;/code&gt; loop enclosing the &lt;code&gt;break&lt;/code&gt; expression, but a &lt;a href=&quot;loop-expr#loop-labels&quot;&gt;label&lt;/a&gt; can be used to specify which enclosing loop is affected. Example:</source>
          <target state="translated">甲 &lt;code&gt;break&lt;/code&gt; 表达通常与最里面的相关 &lt;code&gt;loop&lt;/code&gt; ， &lt;code&gt;for&lt;/code&gt; 或 &lt;code&gt;while&lt;/code&gt; 环包围 &lt;code&gt;break&lt;/code&gt; 的表达，但一个&lt;a href=&quot;loop-expr#loop-labels&quot;&gt;标签&lt;/a&gt;可以被用来指定哪些封闭环路的影响。例：</target>
        </trans-unit>
        <trans-unit id="dc2182d07a207a24da6c811d0b8e308ce9f0619b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; expression is only permitted in the body of a loop, and has one of the forms &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;break 'label&lt;/code&gt; or (&lt;a href=&quot;#break-and-loop-values&quot;&gt;see below&lt;/a&gt;) &lt;code&gt;break EXPR&lt;/code&gt; or &lt;code&gt;break 'label EXPR&lt;/code&gt;.</source>
          <target state="translated">甲 &lt;code&gt;break&lt;/code&gt; 表达仅在一个循环体允许的，并且具有形式的一个 &lt;code&gt;break&lt;/code&gt; ， &lt;code&gt;break 'label&lt;/code&gt; 或（&lt;a href=&quot;#break-and-loop-values&quot;&gt;见下文&lt;/a&gt;） &lt;code&gt;break EXPR&lt;/code&gt; 或 &lt;code&gt;break 'label EXPR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1929ca3782f20314772673eb1b3076f6e73f81b3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; expression is only permitted in the body of a loop, and has one of the forms &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;break 'label&lt;/code&gt; or (&lt;a href=&quot;loop-expr#break-and-loop-values&quot;&gt;see below&lt;/a&gt;) &lt;code&gt;break EXPR&lt;/code&gt; or &lt;code&gt;break 'label EXPR&lt;/code&gt;.</source>
          <target state="translated">甲 &lt;code&gt;break&lt;/code&gt; 表达仅在一个循环体允许的，并且具有形式的一个 &lt;code&gt;break&lt;/code&gt; ， &lt;code&gt;break 'label&lt;/code&gt; 或（&lt;a href=&quot;loop-expr#break-and-loop-values&quot;&gt;见下文&lt;/a&gt;） &lt;code&gt;break EXPR&lt;/code&gt; 或 &lt;code&gt;break 'label EXPR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f212565caf5ca5d26733a24ecd450094943708a5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; statement with an argument appeared in a non-&lt;code&gt;loop&lt;/code&gt; loop.</source>
          <target state="translated">一个 &lt;code&gt;break&lt;/code&gt; 与参数的声明出现在非 &lt;code&gt;loop&lt;/code&gt; 回路。</target>
        </trans-unit>
        <trans-unit id="0719aea9e00a3f18488e8dec397e352b5e69370a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; statement without a label appeared inside a labeled block.</source>
          <target state="translated">一个 &lt;code&gt;break&lt;/code&gt; 没有标签声明标记块内出现。</target>
        </trans-unit>
        <trans-unit id="3cd69f4f6c3139636621e0e9a9e16305bdb70d6f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;char&lt;/code&gt; is a &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value&lt;/a&gt;, which means that it is a &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;Code Point&lt;/a&gt;, but only ones within a certain range. &lt;code&gt;MAX&lt;/code&gt; is the highest valid code point that's a valid &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value&lt;/a&gt;.</source>
          <target state="translated">甲 &lt;code&gt;char&lt;/code&gt; 是&lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode标值&lt;/a&gt;，这意味着它是一个&lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;码点&lt;/a&gt;，但在一定范围内唯一的。 &lt;code&gt;MAX&lt;/code&gt; 是最高有效代码点，它是有效的&lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode标量值&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e8ee25848e86a1b5a5cc249fddb42f44e3d6d658" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;char&lt;/code&gt; is a &lt;a href=&quot;https://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value&lt;/a&gt;, which means that it is a &lt;a href=&quot;https://www.unicode.org/glossary/#code_point&quot;&gt;Code Point&lt;/a&gt;, but only ones within a certain range. &lt;code&gt;MAX&lt;/code&gt; is the highest valid code point that's a valid &lt;a href=&quot;https://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value&lt;/a&gt;.</source>
          <target state="translated">甲 &lt;code&gt;char&lt;/code&gt; 是&lt;a href=&quot;https://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode标值&lt;/a&gt;，这意味着它是一个&lt;a href=&quot;https://www.unicode.org/glossary/#code_point&quot;&gt;码点&lt;/a&gt;，但在一定范围内唯一的。 &lt;code&gt;MAX&lt;/code&gt; 是最高有效代码点，它是有效的&lt;a href=&quot;https://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode标量值&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6de9c91a3e0c1eb1015d4865a476f244ccddf52f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;const&lt;/code&gt; represents a constant value that should never change. If one takes a &lt;code&gt;&amp;amp;&lt;/code&gt; reference to the constant, then one is taking a pointer to some memory location containing the value. Normally this is perfectly fine: most values can't be changed via a shared &lt;code&gt;&amp;amp;&lt;/code&gt; pointer, but interior mutability would allow it. That is, a constant value could be mutated. On the other hand, a &lt;code&gt;static&lt;/code&gt; is explicitly a single memory location, which can be mutated at will.</source>
          <target state="translated">一个 &lt;code&gt;const&lt;/code&gt; 代表一个恒定的值应该不会改变。如果对常量引用 &lt;code&gt;&amp;amp;&lt;/code&gt; ，则表示该指针指向包含该值的某个内存位置。通常，这是完全可以的：大多数值不能通过共享 &lt;code&gt;&amp;amp;&lt;/code&gt; 指针更改，但是内部可变性允许它。即，常数值可以被突变。另一方面， &lt;code&gt;static&lt;/code&gt; 明确是单个存储位置，可以随意对其进行更改。</target>
        </trans-unit>
        <trans-unit id="fcf892710236415af0f5e027b5569143cb3933af" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;for&lt;/code&gt; expression is a syntactic construct for looping over elements provided by an implementation of &lt;code&gt;std::iter::IntoIterator&lt;/code&gt;. If the iterator yields a value, that value is given the specified name and the body of the loop is executed, then control returns to the head of the &lt;code&gt;for&lt;/code&gt; loop. If the iterator is empty, the &lt;code&gt;for&lt;/code&gt; expression completes.</source>
          <target state="translated">甲 &lt;code&gt;for&lt;/code&gt; 表达对于遍历通过的实施方案提供元件语法构造 &lt;code&gt;std::iter::IntoIterator&lt;/code&gt; 。如果迭代器产生一个值，则为该值指定名称并执行循环的主体，然后控制返回到 &lt;code&gt;for&lt;/code&gt; 循环的开头。如果迭代器为空，则 &lt;code&gt;for&lt;/code&gt; 表达式完成。</target>
        </trans-unit>
        <trans-unit id="7cc2ad054c8700f44ee39d9eb760a19117e088af" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;for&lt;/code&gt; expression is a syntactic construct for looping over elements provided by an implementation of &lt;code&gt;std::iter::IntoIterator&lt;/code&gt;. If the iterator yields a value, that value is matched against the irrefutable pattern, the body of the loop is executed, and then control returns to the head of the &lt;code&gt;for&lt;/code&gt; loop. If the iterator is empty, the &lt;code&gt;for&lt;/code&gt; expression completes.</source>
          <target state="translated">甲 &lt;code&gt;for&lt;/code&gt; 表达对于遍历通过的实施方案提供元件语法构造 &lt;code&gt;std::iter::IntoIterator&lt;/code&gt; 。如果迭代器产生一个值，则该值与不可辩驳的模式匹配，则执行循环的主体，然后控制返回到 &lt;code&gt;for&lt;/code&gt; 循环的开头。如果迭代器为空，则 &lt;code&gt;for&lt;/code&gt; 表达式完成。</target>
        </trans-unit>
        <trans-unit id="d73920ce8bc8796a34637626ebd1ee2bfe7e1d77" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;for&lt;/code&gt; loop expands as shown:</source>
          <target state="translated">甲 &lt;code&gt;for&lt;/code&gt; 循环膨胀，如下所示：</target>
        </trans-unit>
        <trans-unit id="0dcdc530771d15a6a0db69b3817439a78d80a1af" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;loop&lt;/code&gt; expression repeats execution of its body continuously: &lt;code&gt;loop { println!(&quot;I live.&quot;); }&lt;/code&gt;.</source>
          <target state="translated">一个 &lt;code&gt;loop&lt;/code&gt; 式不断地重复它身体的执行： &lt;code&gt;loop { println!(&quot;I live.&quot;); }&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d617ef5af3dab30c4c49b4baffa8bfa3c5f2ec66" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;loop&lt;/code&gt; expression without an associated &lt;code&gt;break&lt;/code&gt; expression is diverging and has type &lt;a href=&quot;../types/never&quot;&gt;&lt;code&gt;!&lt;/code&gt;&lt;/a&gt;. A &lt;code&gt;loop&lt;/code&gt; expression containing associated &lt;a href=&quot;#break-expressions&quot;&gt;&lt;code&gt;break&lt;/code&gt; expression(s)&lt;/a&gt; may terminate, and must have type compatible with the value of the &lt;code&gt;break&lt;/code&gt; expression(s).</source>
          <target state="translated">一 &lt;code&gt;loop&lt;/code&gt; 不相关联的表达 &lt;code&gt;break&lt;/code&gt; 表达是发散，有型&lt;a href=&quot;../types/never&quot;&gt; &lt;code&gt;!&lt;/code&gt; &lt;/a&gt;。甲 &lt;code&gt;loop&lt;/code&gt; 含有相关的表达&lt;a href=&quot;#break-expressions&quot;&gt; &lt;code&gt;break&lt;/code&gt; 的表达（一个或多个）&lt;/a&gt;可以终止，并且必须键入与值兼容 &lt;code&gt;break&lt;/code&gt; 表达式（一个或多个）。</target>
        </trans-unit>
        <trans-unit id="e36c323c7511710c9caa566121cf59ed62c95bef" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;loop&lt;/code&gt; expression without an associated &lt;code&gt;break&lt;/code&gt; expression is diverging and has type &lt;a href=&quot;../types/never&quot;&gt;&lt;code&gt;!&lt;/code&gt;&lt;/a&gt;. A &lt;code&gt;loop&lt;/code&gt; expression containing associated &lt;a href=&quot;loop-expr#break-expressions&quot;&gt;&lt;code&gt;break&lt;/code&gt; expression(s)&lt;/a&gt; may terminate, and must have type compatible with the value of the &lt;code&gt;break&lt;/code&gt; expression(s).</source>
          <target state="translated">一 &lt;code&gt;loop&lt;/code&gt; 不相关联的表达 &lt;code&gt;break&lt;/code&gt; 表达是发散，有型&lt;a href=&quot;../types/never&quot;&gt; &lt;code&gt;!&lt;/code&gt; &lt;/a&gt;。甲 &lt;code&gt;loop&lt;/code&gt; 含有相关的表达&lt;a href=&quot;loop-expr#break-expressions&quot;&gt; &lt;code&gt;break&lt;/code&gt; 的表达（一个或多个）&lt;/a&gt;可以终止，并且必须键入与值兼容 &lt;code&gt;break&lt;/code&gt; 表达式（一个或多个）。</target>
        </trans-unit>
        <trans-unit id="27cdf38632ff8742feaafa6612389bb67003ed19" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;match&lt;/code&gt; behaves differently depending on whether or not the scrutinee expression is a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression or value expression&lt;/a&gt;. If the scrutinee expression is a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expression&lt;/a&gt;, it is first evaluated into a temporary location, and the resulting value is sequentially compared to the patterns in the arms until a match is found. The first arm with a matching pattern is chosen as the branch target of the &lt;code&gt;match&lt;/code&gt;, any variables bound by the pattern are assigned to local variables in the arm's block, and control enters the block.</source>
          <target state="translated">甲 &lt;code&gt;match&lt;/code&gt; 行为不同取决于scrutinee表达是否是一个&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;地方表达或值表达式&lt;/a&gt;。如果scrutinee表达式是一个&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;值表达式&lt;/a&gt;，则首先将其评估为一个临时位置，然后将所得值与两臂中的模式顺序进行比较，直到找到匹配项为止。选择具有匹配模式的第一个手臂作为 &lt;code&gt;match&lt;/code&gt; 的分支目标，该模式所绑定的任何变量都将分配给该手臂所在块中的局部变量，然后控制权进入该块。</target>
        </trans-unit>
        <trans-unit id="9d65cf4e1e473919c3773c077a67170ac8398876" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;match&lt;/code&gt; expression is made up of &lt;em&gt;arms&lt;/em&gt;. An arm consists of a &lt;em&gt;pattern&lt;/em&gt; and the code that should be run if the value given to the beginning of the &lt;code&gt;match&lt;/code&gt; expression fits that arm&amp;rsquo;s pattern. Rust takes the value given to &lt;code&gt;match&lt;/code&gt; and looks through each arm&amp;rsquo;s pattern in turn. The &lt;code&gt;match&lt;/code&gt; construct and patterns are powerful features in Rust that let you express a variety of situations your code might encounter and make sure that you handle them all. These features will be covered in detail in Chapter 6 and Chapter 18, respectively.</source>
          <target state="translated">甲 &lt;code&gt;match&lt;/code&gt; 表达式由高达&lt;em&gt;武器&lt;/em&gt;。一个手臂由一个&lt;em&gt;模式&lt;/em&gt;和如果 &lt;code&gt;match&lt;/code&gt; 表达式开头给出的值适合该手臂的模式应运行的代码组成。Rust会获得 &lt;code&gt;match&lt;/code&gt; 的值，并依次浏览每个手臂的模式。该 &lt;code&gt;match&lt;/code&gt; 结构和模式是铁锈，让你表达各种各样的情况你的代码可能遇到的，并确保你处理所有这些强大的功能。这些功能将分别在第6章和第18章中详细介绍。</target>
        </trans-unit>
        <trans-unit id="2653905e02c1a5978b97c0dfd21c1d160c036b3e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;repr(transparent)&lt;/code&gt; type was also annotated with other, incompatible representation hints.</source>
          <target state="translated">甲 &lt;code&gt;repr(transparent)&lt;/code&gt; 类型还注释与其他的，不兼容的表示提示。</target>
        </trans-unit>
        <trans-unit id="c5a4ca7ea6b5bc0339d74f8626989e641c9a4f2a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;return&lt;/code&gt; marks the end of an execution path in a function:</source>
          <target state="translated">甲 &lt;code&gt;return&lt;/code&gt; 标记在一个函数的执行路径的末尾：</target>
        </trans-unit>
        <trans-unit id="d04d984159639545c2a9b782d494bbc89f68eb09" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;enum&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt; which was defined in the current crate. This is not affected by applied type arguments. &lt;code&gt;struct Foo&lt;/code&gt; is considered local, but &lt;code&gt;Vec&amp;lt;Foo&amp;gt;&lt;/code&gt; is not. &lt;code&gt;LocalType&amp;lt;ForeignType&amp;gt;&lt;/code&gt; is local. Type aliases do not affect locality.</source>
          <target state="translated">甲 &lt;code&gt;struct&lt;/code&gt; ， &lt;code&gt;enum&lt;/code&gt; ，或 &lt;code&gt;union&lt;/code&gt; 其在当前的板条箱限定。这不受应用的类型参数的影响。 &lt;code&gt;struct Foo&lt;/code&gt; 被认为是本地的，但 &lt;code&gt;Vec&amp;lt;Foo&amp;gt;&lt;/code&gt; 不是。 &lt;code&gt;LocalType&amp;lt;ForeignType&amp;gt;&lt;/code&gt; 是本地的。类型别名不影响位置。</target>
        </trans-unit>
        <trans-unit id="0bcaf88ff1b66b63413f83d3b7d32c0a7ea7cbfe" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;struct&lt;/code&gt;&lt;em&gt;type&lt;/em&gt; is a heterogeneous product of other types, called the &lt;em&gt;fields&lt;/em&gt; of the type.&lt;sup&gt;&lt;a href=&quot;#structtype&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">甲 &lt;code&gt;struct&lt;/code&gt; &lt;em&gt;类型&lt;/em&gt;是其他类型的，被称为的异构产物&lt;em&gt;的字段&lt;/em&gt;的类型。&lt;sup&gt;&lt;a href=&quot;#structtype&quot;&gt;1个&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="e983e7b3d7471c078bb152c54f1d0e490ae64bff" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;struct&lt;/code&gt;&lt;em&gt;type&lt;/em&gt; is a heterogeneous product of other types, called the &lt;em&gt;fields&lt;/em&gt; of the type.&lt;sup&gt;&lt;a href=&quot;struct#structtype&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">甲 &lt;code&gt;struct&lt;/code&gt; &lt;em&gt;类型&lt;/em&gt;是其他类型的，被称为的异构产物&lt;em&gt;的字段&lt;/em&gt;的类型。&lt;sup&gt;&lt;a href=&quot;struct#structtype&quot;&gt;1个&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="5dc372cb983e81c62a84e7d307e5c691468779fc" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;trait&lt;/code&gt; is like an interface that data types can implement. When a type implements a trait it can be treated abstractly as that trait using generics or trait objects.</source>
          <target state="translated">甲 &lt;code&gt;trait&lt;/code&gt; 就是这样的数据类型可以实现一个接口。当类型实现特征时，可以使用泛型或特征对象将其抽象地视为该特征。</target>
        </trans-unit>
        <trans-unit id="2ad87d3d4edf2b4861565127275e5ad1afc1a755" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;trait&lt;/code&gt; which was defined in the current crate. A trait definition is local or not independent of applied type arguments. Given &lt;code&gt;trait Foo&amp;lt;T, U&amp;gt;&lt;/code&gt;, &lt;code&gt;Foo&lt;/code&gt; is always local, regardless of the types substituted for &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">当前包装箱中定义的 &lt;code&gt;trait&lt;/code&gt; 。特征定义是局部的，或者不独立于所应用的类型参数。给定 &lt;code&gt;trait Foo&amp;lt;T, U&amp;gt;&lt;/code&gt; ， &lt;code&gt;Foo&lt;/code&gt; 始终是局部的，而不考虑用 &lt;code&gt;T&lt;/code&gt; 和 &lt;code&gt;U&lt;/code&gt; 替换的类型。</target>
        </trans-unit>
        <trans-unit id="99ab68cda9330ceba3e059532d454bd1454a3c76" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;union&lt;/code&gt; cannot have fields with destructors.</source>
          <target state="translated">一个 &lt;code&gt;union&lt;/code&gt; 不能有析构函数领域。</target>
        </trans-unit>
        <trans-unit id="7456e28e3269b8fcb15b4e8220467fa67683b4bd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;union&lt;/code&gt; is similar to a &lt;code&gt;struct&lt;/code&gt;, but only one declared field is used in a particular instance at one time. Unions are primarily used to interface with unions in C code. Accessing union fields is unsafe because Rust can&amp;rsquo;t guarantee the type of the data currently being stored in the union instance. You can learn more about unions in &lt;a href=&quot;../reference/items/unions&quot;&gt;the reference&lt;/a&gt;.</source>
          <target state="translated">一个 &lt;code&gt;union&lt;/code&gt; 是类似 &lt;code&gt;struct&lt;/code&gt; ，但只有一个声明字段在特定的情况下在同一时间使用。联合主要用于与C代码中的联合接口。访问联合字段是不安全的，因为Rust无法保证当前存储在联合实例中的数据的类型。您可以在&lt;a href=&quot;../reference/items/unions&quot;&gt;参考资料中&lt;/a&gt;了解有关联合的更多信息。</target>
        </trans-unit>
        <trans-unit id="d933644dc98827f86adb027ad1edada503180c92" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;union&lt;/code&gt; looks like a &lt;a href=&quot;keyword.struct&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; in terms of declaration, but all of its fields exist in the same memory, superimposed over one another. For instance, if we wanted some bits in memory that we sometimes interpret as a &lt;code&gt;u32&lt;/code&gt; and sometimes as an &lt;code&gt;f32&lt;/code&gt;, we could write:</source>
          <target state="translated">一个 &lt;code&gt;union&lt;/code&gt; 看起来像一个&lt;a href=&quot;keyword.struct&quot;&gt; &lt;code&gt;struct&lt;/code&gt; &lt;/a&gt;中声明的条款，但其所有字段都在同一个内存中，相互叠加。例如，如果我们希望内存中的某些位有时被解释为 &lt;code&gt;u32&lt;/code&gt; ，有时又被解释为 &lt;code&gt;f32&lt;/code&gt; ，我们可以这样写：</target>
        </trans-unit>
        <trans-unit id="aae4dfd16f669123c1df46acb99529aa8db4f78e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;union&lt;/code&gt; was declared with fields with destructors.</source>
          <target state="translated">一个 &lt;code&gt;union&lt;/code&gt; 宣布与析构函数领域。</target>
        </trans-unit>
        <trans-unit id="31174f5a2be478aaee87f1f4ce26d9142eeb339c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while let&lt;/code&gt; loop is equivalent to a &lt;code&gt;loop&lt;/code&gt; expression containing a &lt;a href=&quot;match-expr&quot;&gt;&lt;code&gt;match&lt;/code&gt; expression&lt;/a&gt; as follows.</source>
          <target state="translated">甲 &lt;code&gt;while let&lt;/code&gt; 循环相当于一个 &lt;code&gt;loop&lt;/code&gt; 包含表达式&lt;a href=&quot;match-expr&quot;&gt; &lt;code&gt;match&lt;/code&gt; 表达式&lt;/a&gt;如下。</target>
        </trans-unit>
        <trans-unit id="132dd0b4198a0332783e039cb830e80e3a95c535" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while let&lt;/code&gt; loop is semantically similar to a &lt;code&gt;while&lt;/code&gt; loop but in place of a condition expression it expects the keyword &lt;code&gt;let&lt;/code&gt; followed by a pattern, an &lt;code&gt;=&lt;/code&gt;, a &lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt; expression and a block expression. If the value of the scrutinee matches the pattern, the loop body block executes then control returns to the pattern matching statement. Otherwise, the while expression completes.</source>
          <target state="translated">甲 &lt;code&gt;while let&lt;/code&gt; 循环在语义上类似于 &lt;code&gt;while&lt;/code&gt; 循环，但代替条件表达式，预计关键字 &lt;code&gt;let&lt;/code&gt; 后跟一个图案， &lt;code&gt;=&lt;/code&gt; ，一个&lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt;表达式和一个块的表达。如果scrutinee的值与模式匹配，则执行循环主体块，然后控制返回到模式匹配语句。否则，while表达式将完成。</target>
        </trans-unit>
        <trans-unit id="718179093a0d6e082dbdc6f07f43775afb09f0f9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while&lt;/code&gt; expression is used for predicate loops. The &lt;code&gt;while&lt;/code&gt; expression runs the conditional expression before running the loop body, then runs the loop body if the conditional expression evaluates to &lt;code&gt;true&lt;/code&gt;, or exits the loop otherwise.</source>
          <target state="translated">甲 &lt;code&gt;while&lt;/code&gt; 表达式用于谓词环路。的 &lt;code&gt;while&lt;/code&gt; 表达运行循环体之前运行条件表达式，然后运行循环体，如果条件表达式的计算结果为 &lt;code&gt;true&lt;/code&gt; ，否则退出该循环。</target>
        </trans-unit>
        <trans-unit id="283fcf53585988268a7d68d52030cb117688b529" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while&lt;/code&gt; loop begins by evaluating the boolean loop conditional expression. If the loop conditional expression evaluates to &lt;code&gt;true&lt;/code&gt;, the loop body block executes, then control returns to the loop conditional expression. If the loop conditional expression evaluates to &lt;code&gt;false&lt;/code&gt;, the &lt;code&gt;while&lt;/code&gt; expression completes.</source>
          <target state="translated">甲 &lt;code&gt;while&lt;/code&gt; 循环开始通过评估布尔循环条件表达式。如果循环条件表达式的值为 &lt;code&gt;true&lt;/code&gt; ，则执行循环主体块，然后控制返回到循环条件表达式。如果循环条件表达式的计算结果为 &lt;code&gt;false&lt;/code&gt; ，则 &lt;code&gt;while&lt;/code&gt; 表达式完成。</target>
        </trans-unit>
        <trans-unit id="9024dfdf6115f20a47566e1a178072686b644d4c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;yield&lt;/code&gt; clause was used in an &lt;code&gt;async&lt;/code&gt; context.</source>
          <target state="translated">甲 &lt;code&gt;yield&lt;/code&gt; 子句物在使用 &lt;code&gt;async&lt;/code&gt; 上下文。</target>
        </trans-unit>
        <trans-unit id="9a98030fcb71c42d6137c8ff5fae0192e67a25d8" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;24-bit code point escape&lt;/em&gt; starts with &lt;code&gt;U+0075&lt;/code&gt; (&lt;code&gt;u&lt;/code&gt;) and is followed by up to six &lt;em&gt;hex digits&lt;/em&gt; surrounded by braces &lt;code&gt;U+007B&lt;/code&gt; (&lt;code&gt;{&lt;/code&gt;) and &lt;code&gt;U+007D&lt;/code&gt; (&lt;code&gt;}&lt;/code&gt;). It denotes the Unicode code point equal to the provided hex value.</source>
          <target state="translated">甲&lt;em&gt;24位代码点逃逸&lt;/em&gt;与开始 &lt;code&gt;U+0075&lt;/code&gt; （ &lt;code&gt;u&lt;/code&gt; ），接着是多达六个&lt;em&gt;十六进制数字&lt;/em&gt;由括号包围 &lt;code&gt;U+007B&lt;/code&gt; （ &lt;code&gt;{&lt;/code&gt; ）和 &lt;code&gt;U+007D&lt;/code&gt; （ &lt;code&gt;}&lt;/code&gt; ）。它表示Unicode代码点等于提供的十六进制值。</target>
        </trans-unit>
        <trans-unit id="869073214f1b9edb093744ef355f142778b07763" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;7-bit code point escape&lt;/em&gt; starts with &lt;code&gt;U+0078&lt;/code&gt; (&lt;code&gt;x&lt;/code&gt;) and is followed by exactly two &lt;em&gt;hex digits&lt;/em&gt; with value up to &lt;code&gt;0x7F&lt;/code&gt;. It denotes the ASCII character with value equal to the provided hex value. Higher values are not permitted because it is ambiguous whether they mean Unicode code points or byte values.</source>
          <target state="translated">阿&lt;em&gt;7位代码点逃逸&lt;/em&gt;的开头是 &lt;code&gt;U+0078&lt;/code&gt; （ &lt;code&gt;x&lt;/code&gt; ），接着是正好两个&lt;em&gt;十六进制数字&lt;/em&gt;与值高达 &lt;code&gt;0x7F&lt;/code&gt; 的。它表示ASCII字符，其值等于提供的十六进制值。不允许使用较高的值，因为它们是指Unicode代码点还是字节值，因此模棱两可。</target>
        </trans-unit>
        <trans-unit id="ba5e9b49178a0e6b5d252044b97fef65592fc293" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;&lt;code&gt;let&lt;/code&gt; statement&lt;/em&gt; introduces a new set of &lt;a href=&quot;variables&quot;&gt;variables&lt;/a&gt;, given by a &lt;a href=&quot;patterns&quot;&gt;pattern&lt;/a&gt;. The pattern is followed optionally by a type annotation and then optionally by an initializer expression. When no type annotation is given, the compiler will infer the type, or signal an error if insufficient type information is available for definite inference. Any variables introduced by a variable declaration are visible from the point of declaration until the end of the enclosing block scope.</source>
          <target state="translated">一个&lt;em&gt; &lt;code&gt;let&lt;/code&gt; 声明&lt;/em&gt;引入了一套新的&lt;a href=&quot;variables&quot;&gt;变量&lt;/a&gt;，通过给定的&lt;a href=&quot;patterns&quot;&gt;模式&lt;/a&gt;。该模式后面可以有一个类型注释，然后有一个初始化器表达式。如果没有给出类型注释，则编译器将推断类型，或者如果没有足够的类型信息来进行确定的推断，则编译器将发出错误信号。从声明的角度到封闭的块范围结束为止，变量声明引入的任何变量都是可见的。</target>
        </trans-unit>
        <trans-unit id="8ca18f2a30c6ddfd6e41efbe967d1604f354b083" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;&lt;code&gt;let&lt;/code&gt; statement&lt;/em&gt; introduces a new set of &lt;a href=&quot;variables&quot;&gt;variables&lt;/a&gt;, given by an irrefutable &lt;a href=&quot;patterns&quot;&gt;pattern&lt;/a&gt;. The pattern is followed optionally by a type annotation and then optionally by an initializer expression. When no type annotation is given, the compiler will infer the type, or signal an error if insufficient type information is available for definite inference. Any variables introduced by a variable declaration are visible from the point of declaration until the end of the enclosing block scope.</source>
          <target state="translated">一个&lt;em&gt; &lt;code&gt;let&lt;/code&gt; 声明&lt;/em&gt;引入了一套新的&lt;a href=&quot;variables&quot;&gt;变量&lt;/a&gt;，由一个无可辩驳给出&lt;a href=&quot;patterns&quot;&gt;的图案&lt;/a&gt;。该模式后面可以选择加上类型注释，然后可以选择后面带有初始化器表达式。如果没有给出类型注释，则编译器将推断类型，或者如果没有足够的类型信息来进行确定的推断，则编译器将发出错误信号。从声明点到封闭块作用域的结尾，变量声明引入的任何变量都是可见的。</target>
        </trans-unit>
        <trans-unit id="4965d161e4fa0b76aa8e253a8b735c3ef6585135" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;&lt;code&gt;match&lt;/code&gt; expression&lt;/em&gt; branches on a pattern. The exact form of matching that occurs depends on the &lt;a href=&quot;../patterns&quot;&gt;pattern&lt;/a&gt;. A &lt;code&gt;match&lt;/code&gt; expression has a &lt;em&gt;&lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt; expression&lt;/em&gt;, which is the value to compare to the patterns. The scrutinee expression and the patterns must have the same type.</source>
          <target state="translated">甲&lt;em&gt; &lt;code&gt;match&lt;/code&gt; 表达&lt;/em&gt;上的图案分支。匹配的确切形式取决于&lt;a href=&quot;../patterns&quot;&gt;模式&lt;/a&gt;。甲 &lt;code&gt;match&lt;/code&gt; 表达式具有&lt;em&gt;&lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt;表达&lt;/em&gt;，这是要比较的图案的值。注释表达式和模式必须具有相同的类型。</target>
        </trans-unit>
        <trans-unit id="58385518472acdb41b644cab1601f90a746d55aa" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;binary literal&lt;/em&gt; starts with the character sequence &lt;code&gt;U+0030&lt;/code&gt;&lt;code&gt;U+0062&lt;/code&gt; (&lt;code&gt;0b&lt;/code&gt;) and continues as any mixture (with at least one digit) of binary digits and underscores.</source>
          <target state="translated">甲&lt;em&gt;二进制文字&lt;/em&gt;与字符序列开始 &lt;code&gt;U+0030&lt;/code&gt; &lt;code&gt;U+0062&lt;/code&gt; （ &lt;code&gt;0b&lt;/code&gt; ），并继续作为二进制数字和下划线的任何混合物（至少一位）。</target>
        </trans-unit>
        <trans-unit id="e1bc1112f211249d5a018412bd10ed929678eeda" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;block expression&lt;/em&gt;, or &lt;em&gt;block&lt;/em&gt;, is a control flow expression and anonymous namespace scope for items and variable declarations. As a control flow expression, a block sequentially executes its component non-item declaration statements and then its final optional expression. As an anonymous namespace scope, item declarations are only in scope inside the block itself and variables declared by &lt;code&gt;let&lt;/code&gt; statements are in scope from the next statement until the end of the block.</source>
          <target state="translated">阿&lt;em&gt;块表达&lt;/em&gt;，或&lt;em&gt;块&lt;/em&gt;，是对物品和变量声明的控制流程的表达和匿名命名空间范围。作为控制流表达式，块顺序执行其组件非项目声明语句，然后执行其最终的可选表达式。作为匿名命名空间作用域，项目声明仅在块本身内部的范围内，而 &lt;code&gt;let&lt;/code&gt; 语句声明的变量在从下一条语句到块末尾的范围内。</target>
        </trans-unit>
        <trans-unit id="d959096d425f9582c596a1eece69230b21ea3b75" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;byte escape&lt;/em&gt; escape starts with &lt;code&gt;U+0078&lt;/code&gt; (&lt;code&gt;x&lt;/code&gt;) and is followed by exactly two &lt;em&gt;hex digits&lt;/em&gt;. It denotes the byte equal to the provided hex value.</source>
          <target state="translated">甲&lt;em&gt;字节转义&lt;/em&gt;逃逸开头 &lt;code&gt;U+0078&lt;/code&gt; （ &lt;code&gt;x&lt;/code&gt; ），接着是正好两个&lt;em&gt;十六进制数字&lt;/em&gt;。它表示等于提供的十六进制值的字节。</target>
        </trans-unit>
        <trans-unit id="08d56300cad1166d8bb2fb927ceda10d77863d64" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;byte literal&lt;/em&gt; is a single ASCII character (in the &lt;code&gt;U+0000&lt;/code&gt; to &lt;code&gt;U+007F&lt;/code&gt; range) or a single &lt;em&gt;escape&lt;/em&gt; preceded by the characters &lt;code&gt;U+0062&lt;/code&gt; (&lt;code&gt;b&lt;/code&gt;) and &lt;code&gt;U+0027&lt;/code&gt; (single-quote), and followed by the character &lt;code&gt;U+0027&lt;/code&gt;. If the character &lt;code&gt;U+0027&lt;/code&gt; is present within the literal, it must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) character. It is equivalent to a &lt;code&gt;u8&lt;/code&gt; unsigned 8-bit integer &lt;em&gt;number literal&lt;/em&gt;.</source>
          <target state="translated">甲&lt;em&gt;字节文字&lt;/em&gt;是单个ASCII字符（在 &lt;code&gt;U+0000&lt;/code&gt; 到 &lt;code&gt;U+007F&lt;/code&gt; 范围）或单&lt;em&gt;逃逸&lt;/em&gt;用字符之前 &lt;code&gt;U+0062&lt;/code&gt; （ &lt;code&gt;b&lt;/code&gt; ）和 &lt;code&gt;U+0027&lt;/code&gt; （单引号），和随后的字符 &lt;code&gt;U+0027&lt;/code&gt; 。如果文字中存在字符 &lt;code&gt;U+0027&lt;/code&gt; ，则必须在前面的 &lt;code&gt;U+005C&lt;/code&gt; （ &lt;code&gt;\&lt;/code&gt; ）字符中对其进行&lt;em&gt;转义&lt;/em&gt;。等效于 &lt;code&gt;u8&lt;/code&gt; 无符号8位整数&lt;em&gt;数字常量&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="82cbcd824290282b86dc09637a06221aa40fcffe" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;call expression&lt;/em&gt; consists of an expression followed by a parenthesized expression-list. It invokes a function, providing zero or more input variables. If the function eventually returns, then the expression completes. For &lt;a href=&quot;../types/function-item&quot;&gt;non-function types&lt;/a&gt;, the expression f(...) uses the method on one of the &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt;&lt;code&gt;std::ops::Fn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt;&lt;code&gt;std::ops::FnMut&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../std/ops/trait.fnonce&quot;&gt;&lt;code&gt;std::ops::FnOnce&lt;/code&gt;&lt;/a&gt; traits, which differ in whether they take the type by reference, mutable reference, or take ownership respectively. An automatic borrow will be taken if needed. Rust will also automatically dereference &lt;code&gt;f&lt;/code&gt; as required. Some examples of call expressions:</source>
          <target state="translated">甲&lt;em&gt;调用表达式&lt;/em&gt;由表达式后跟带括号表达式列表的。它调用一个函数，提供零个或多个输入变量。如果函数最终返回，则表达式完成。对于&lt;a href=&quot;../types/function-item&quot;&gt;非函数类型&lt;/a&gt;，表达式f（...）在&lt;a href=&quot;../../std/ops/trait.fn&quot;&gt; &lt;code&gt;std::ops::Fn&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt; &lt;code&gt;std::ops::FnMut&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../std/ops/trait.fnonce&quot;&gt; &lt;code&gt;std::ops::FnOnce&lt;/code&gt; &lt;/a&gt;特性之一上使用方法，这两种特性在它们分别通过引用，可变引用或所有权来获取类型。如果需要，将自动借用。 Rust还将根据需要自动取消对 &lt;code&gt;f&lt;/code&gt; 的引用。调用表达式的一些示例：</target>
        </trans-unit>
        <trans-unit id="30fdc766ea9fe7cd1ba45798e3f6d282c53ef441" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;character literal&lt;/em&gt; is a single Unicode character enclosed within two &lt;code&gt;U+0027&lt;/code&gt; (single-quote) characters, with the exception of &lt;code&gt;U+0027&lt;/code&gt; itself, which must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; character (&lt;code&gt;\&lt;/code&gt;).</source>
          <target state="translated">甲&lt;em&gt;字符文字&lt;/em&gt;是一个单一的Unicode字符2内封入 &lt;code&gt;U+0027&lt;/code&gt; （单引号）字符，以下除外 &lt;code&gt;U+0027&lt;/code&gt; 本身，其必须被&lt;em&gt;转义&lt;/em&gt;通过前一 &lt;code&gt;U+005C&lt;/code&gt; 字符（ &lt;code&gt;\&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="3c6b198e97c9744354ac6c754b38292587c4fb26" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;closure expression&lt;/em&gt; defines a closure and denotes it as a value, in a single expression. A closure expression is a pipe-symbol-delimited (&lt;code&gt;|&lt;/code&gt;) list of irrefutable &lt;a href=&quot;../patterns&quot;&gt;patterns&lt;/a&gt; followed by an expression. Type annotations may optionally be added for the type of the parameters or for the return type. If there is a return type, the expression used for the body of the closure must be a normal &lt;a href=&quot;block-expr&quot;&gt;block&lt;/a&gt;. A closure expression also may begin with the &lt;code&gt;move&lt;/code&gt; keyword before the initial &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">甲&lt;em&gt;闭合表达式&lt;/em&gt;定义了一个封闭件和表示它作为一个值，在一个单一的表达。闭包表达式是由管道符号分隔的（ &lt;code&gt;|&lt;/code&gt; ）不可辩驳的&lt;a href=&quot;../patterns&quot;&gt;模式&lt;/a&gt;列表，后跟一个表达式。可以为参数的类型或返回类型添加类型注释。如果存在返回类型，则用于闭包主体的表达式必须为normal &lt;a href=&quot;block-expr&quot;&gt;block&lt;/a&gt;。闭包表达式也可以在开头 &lt;code&gt;|&lt;/code&gt; 之前以 &lt;code&gt;move&lt;/code&gt; 关键字开头。。</target>
        </trans-unit>
        <trans-unit id="339cfc7fe9f16f898782c7f7150b6fb18b64f9c3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;closure expression&lt;/em&gt;, also know as a lambda expression or a lambda, defines a closure and denotes it as a value, in a single expression. A closure expression is a pipe-symbol-delimited (&lt;code&gt;|&lt;/code&gt;) list of irrefutable &lt;a href=&quot;../patterns&quot;&gt;patterns&lt;/a&gt; followed by an expression. Type annotations may optionally be added for the type of the parameters or for the return type. If there is a return type, the expression used for the body of the closure must be a normal &lt;a href=&quot;block-expr&quot;&gt;block&lt;/a&gt;. A closure expression also may begin with the &lt;code&gt;move&lt;/code&gt; keyword before the initial &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">甲&lt;em&gt;闭合表达&lt;/em&gt;，也称为lambda表达式或&amp;lambda;，定义了一个封闭件和表示它作为一个值，在一个单一的表达。闭包表达式是用管道符号分隔的（ &lt;code&gt;|&lt;/code&gt; ）不可辩驳&lt;a href=&quot;../patterns&quot;&gt;模式的&lt;/a&gt;列表，后跟一个表达式。可以选择为参数的类型或返回类型添加类型注释。如果存在返回类型，则用于闭包主体的表达式必须为normal &lt;a href=&quot;block-expr&quot;&gt;block&lt;/a&gt;。闭包表达式也可以在开头 &lt;code&gt;|&lt;/code&gt; 之前以 &lt;code&gt;move&lt;/code&gt; 关键字开头。。</target>
        </trans-unit>
        <trans-unit id="12a150efcf9ffb345d5ef3ddd2a2876cc8ac7c18" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;cons list&lt;/em&gt; is a data structure that comes from the Lisp programming language and its dialects. In Lisp, the &lt;code&gt;cons&lt;/code&gt; function (short for &amp;ldquo;construct function&amp;rdquo;) constructs a new pair from its two arguments, which usually are a single value and another pair. These pairs containing pairs form a list.</source>
          <target state="translated">一个&lt;em&gt;利弊清单&lt;/em&gt;是来自Lisp程序设计语言及其方言的数据结构。在Lisp中， &lt;code&gt;cons&lt;/code&gt; 函数（&amp;ldquo;构造函数&amp;rdquo;的缩写）从其两个参数构造一个新的对，它们通常是一个值和另一个对。这些包含对的对构成一个列表。</target>
        </trans-unit>
        <trans-unit id="cfba0b21b720ac42e28e2be5d6bab07c901fa318" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;const context&lt;/em&gt; is one of the following:</source>
          <target state="translated">甲&lt;em&gt;常量上下文&lt;/em&gt;是下列之一：</target>
        </trans-unit>
        <trans-unit id="493b2f63697e56331a49f53a0195846cde72e171" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;const fn&lt;/em&gt; is a function that one is permitted to call from a const context. Declaring a function &lt;code&gt;const&lt;/code&gt; has no effect on any existing uses, it only restricts the types that arguments and the return type may use, as well as prevent various expressions from being used within it. You can freely do anything with a const function that you can do with a regular function.</source>
          <target state="translated">甲&lt;em&gt;常量FN&lt;/em&gt;是一个函数，一个被允许从一个const上下文调用。声明函数 &lt;code&gt;const&lt;/code&gt; 不会影响任何现有用法，它只会限制参数和返回类型可能使用的类型，并防止在其中使用各种表达式。您可以使用const函数自由地执行任何操作，就像使用常规函数一样。</target>
        </trans-unit>
        <trans-unit id="c36e88175514c7e87236cec6eff5e35e2ff35de3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;constant item&lt;/em&gt; is an optionally named &lt;em&gt;&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant value&lt;/a&gt;&lt;/em&gt; which is not associated with a specific memory location in the program. Constants are essentially inlined wherever they are used, meaning that they are copied directly into the relevant context when used. References to the same constant are not necessarily guaranteed to refer to the same memory address.</source>
          <target state="translated">甲&lt;em&gt;常数项&lt;/em&gt;为任选命名&lt;em&gt;&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;恒定值&lt;/a&gt;&lt;/em&gt;不与在程序中的特定存储器位置相关联。本质上，无论在何处使用常量，都必须内联常量，这意味着在使用常量时，会将它们直接复制到相关上下文中。引用相同的常数不一定保证引用相同的存储器地址。</target>
        </trans-unit>
        <trans-unit id="2e06b409839c096ae71106f8baaaf9f78507004d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;constant item&lt;/em&gt; is an optionally named &lt;em&gt;&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant value&lt;/a&gt;&lt;/em&gt; which is not associated with a specific memory location in the program. Constants are essentially inlined wherever they are used, meaning that they are copied directly into the relevant context when used. This includes usage of constants from external crates, and non-&lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; types. References to the same constant are not necessarily guaranteed to refer to the same memory address.</source>
          <target state="translated">甲&lt;em&gt;常数项&lt;/em&gt;为任选命名&lt;em&gt;&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;恒定值&lt;/a&gt;&lt;/em&gt;不与在程序中的特定存储器位置相关联。常量本质上是内联的，无论它们在哪里使用，这意味着它们在使用时直接复制到相关的上下文中。这包括使用外部包装箱中的常量和非&lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;类型。引用相同的常数不一定要保证引用相同的内存地址。</target>
        </trans-unit>
        <trans-unit id="f7145ab5c52684eb21ecb032f3560fae33132c02" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;crate&lt;/em&gt; is a unit of compilation and linking, as well as versioning, distribution and runtime loading. A crate contains a &lt;em&gt;tree&lt;/em&gt; of nested &lt;a href=&quot;items/modules&quot;&gt;module&lt;/a&gt; scopes. The top level of this tree is a module that is anonymous (from the point of view of paths within the module) and any item within a crate has a canonical &lt;a href=&quot;paths&quot;&gt;module path&lt;/a&gt; denoting its location within the crate's module tree.</source>
          <target state="translated">甲&lt;em&gt;箱&lt;/em&gt;是编译和链接，以及版本，分布和运行时加载的单元。一个板条箱包含&lt;em&gt;一棵&lt;/em&gt;嵌套&lt;a href=&quot;items/modules&quot;&gt;模块&lt;/a&gt;作用域的&lt;em&gt;树&lt;/em&gt;。该树的顶层是一个匿名模块（从模块内路径的角度来看），并且条板箱内的任何项目均具有规范的&lt;a href=&quot;paths&quot;&gt;模块路径，&lt;/a&gt;该路径表示其在条板箱模块树内的位置。</target>
        </trans-unit>
        <trans-unit id="7dbd934a0d90b722d503e93f98eb0c64d5f9ddfa" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;crate&lt;/em&gt; is a unit of compilation and linking, as well as versioning, distribution, and runtime loading. A crate contains a &lt;em&gt;tree&lt;/em&gt; of nested &lt;a href=&quot;items/modules&quot;&gt;module&lt;/a&gt; scopes. The top level of this tree is a module that is anonymous (from the point of view of paths within the module) and any item within a crate has a canonical &lt;a href=&quot;paths&quot;&gt;module path&lt;/a&gt; denoting its location within the crate's module tree.</source>
          <target state="translated">甲&lt;em&gt;箱&lt;/em&gt;是编译和链接，以及版本，分布和运行时加载的单元。一个板条箱包含&lt;em&gt;一棵&lt;/em&gt;嵌套&lt;a href=&quot;items/modules&quot;&gt;模块&lt;/a&gt;作用域的&lt;em&gt;树&lt;/em&gt;。这棵树的顶层是一个匿名模块（从模块内路径的角度来看），一个板条箱中的任何项目都有一个规范的&lt;a href=&quot;paths&quot;&gt;模块路径，&lt;/a&gt;表示其在板条箱模块树中的位置。</target>
        </trans-unit>
        <trans-unit id="2299b04cb26521f6ac83c838a00ce161fe3ebdb6" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;decimal literal&lt;/em&gt; followed by a period character &lt;code&gt;U+002E&lt;/code&gt; (&lt;code&gt;.&lt;/code&gt;). This is optionally followed by another decimal literal, with an optional &lt;em&gt;exponent&lt;/em&gt;.</source>
          <target state="translated">甲&lt;em&gt;十进制字面&lt;/em&gt;后跟一个句点字符 &lt;code&gt;U+002E&lt;/code&gt; （ &lt;code&gt;.&lt;/code&gt; ）。可以选择在其后跟随另一个带有可选&lt;em&gt;指数的&lt;/em&gt;十进制文字。</target>
        </trans-unit>
        <trans-unit id="8945005fcfd339455451ef03bfa95bfaaedef426" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;decimal literal&lt;/em&gt; starts with a &lt;em&gt;decimal digit&lt;/em&gt; and continues with any mixture of &lt;em&gt;decimal digits&lt;/em&gt; and &lt;em&gt;underscores&lt;/em&gt;.</source>
          <target state="translated">甲&lt;em&gt;十进制文字&lt;/em&gt;与开始&lt;em&gt;十进制数&lt;/em&gt;，并继续用的任何混合物&lt;em&gt;十进制数字&lt;/em&gt;和&lt;em&gt;下划线&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="766049e827df03480f975a74379f283f50ff3914" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;declaration statement&lt;/em&gt; is one that introduces one or more &lt;em&gt;names&lt;/em&gt; into the enclosing statement block. The declared names may denote new variables or new &lt;a href=&quot;items&quot;&gt;items&lt;/a&gt;.</source>
          <target state="translated">一个&lt;em&gt;声明语句&lt;/em&gt;是指引入一个或多个&lt;em&gt;名称&lt;/em&gt;进入封闭语句块。声明的名称可能表示新变量或新&lt;a href=&quot;items&quot;&gt;项目&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="50530b588ed49ed96a8c5783ad73ba3e37c6ea25" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;field expression&lt;/em&gt; consists of an expression followed by a single dot and an &lt;a href=&quot;../identifiers&quot;&gt;identifier&lt;/a&gt;, when not immediately followed by a parenthesized expression-list (the latter is always a &lt;a href=&quot;method-call-expr&quot;&gt;method call expression&lt;/a&gt;). A field expression denotes a field of a &lt;a href=&quot;../items/structs&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;../items/unions&quot;&gt;union&lt;/a&gt;. To call a function stored in a struct, parentheses are needed around the field expression.</source>
          <target state="translated">甲&lt;em&gt;字段表达式&lt;/em&gt;由表达式后跟单个点和的&lt;a href=&quot;../identifiers&quot;&gt;标识符&lt;/a&gt;，当没有紧跟带括号表达式列表（后者总是一个&lt;a href=&quot;method-call-expr&quot;&gt;方法调用表达式&lt;/a&gt;）。字段表达式表示&lt;a href=&quot;../items/structs&quot;&gt;struct&lt;/a&gt;或&lt;a href=&quot;../items/unions&quot;&gt;union&lt;/a&gt;的字段。要调用存储在结构中的函数，需要在字段表达式两边加上括号。</target>
        </trans-unit>
        <trans-unit id="cf5014cd7ac2068f18f118543ff07241eda10fbd" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;floating-point literal&lt;/em&gt; has one of two forms:</source>
          <target state="translated">一个&lt;em&gt;浮点文字&lt;/em&gt;有两种形式：</target>
        </trans-unit>
        <trans-unit id="4f4b1ebbfdc25acf10623629374f684851ce4095" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;function&lt;/em&gt; consists of a &lt;a href=&quot;../expressions/block-expr&quot;&gt;block&lt;/a&gt;, along with a name and a set of parameters. Other than a name, all these are optional. Functions are declared with the keyword &lt;code&gt;fn&lt;/code&gt;. Functions may declare a set of &lt;em&gt;input&lt;/em&gt;&lt;a href=&quot;../variables&quot;&gt;&lt;em&gt;variables&lt;/em&gt;&lt;/a&gt; as parameters, through which the caller passes arguments into the function, and the &lt;em&gt;output&lt;/em&gt;&lt;a href=&quot;../types#type-expressions&quot;&gt;&lt;em&gt;type&lt;/em&gt;&lt;/a&gt; of the value the function will return to its caller on completion.</source>
          <target state="translated">甲&lt;em&gt;功能&lt;/em&gt;由一个的&lt;a href=&quot;../expressions/block-expr&quot;&gt;块&lt;/a&gt;，具有名称和一组参数一起。除了名称，所有这些都是可选的。函数用关键字 &lt;code&gt;fn&lt;/code&gt; 声明。函数可以将一组&lt;em&gt;输入&lt;/em&gt;&lt;a href=&quot;../variables&quot;&gt;&lt;em&gt;变量&lt;/em&gt;&lt;/a&gt;声明为参数，调用者通过该&lt;em&gt;变量&lt;/em&gt;将参数传递给函数，并且值的&lt;em&gt;输出&lt;/em&gt;&lt;a href=&quot;../types#type-expressions&quot;&gt;&lt;em&gt;类型&lt;/em&gt;&lt;/a&gt;将在完成时返回给其调用者。</target>
        </trans-unit>
        <trans-unit id="8f85371a9c250b84e230a898102f42e92fb5ad83" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;generic function&lt;/em&gt; allows one or more &lt;em&gt;parameterized types&lt;/em&gt; to appear in its signature. Each type parameter must be explicitly declared in an angle-bracket-enclosed and comma-separated list, following the function name.</source>
          <target state="translated">一个&lt;em&gt;泛型函数&lt;/em&gt;允许一个或多个&lt;em&gt;参数化类型&lt;/em&gt;出现在其签名。每个类型参数必须在函数名称后面的尖括号括起来且用逗号分隔的列表中明确声明。</target>
        </trans-unit>
        <trans-unit id="e5b0c06878c29b647a5cee7cefa81c23fca43579" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;hash map&lt;/em&gt; allows you to associate a value with a particular key. It&amp;rsquo;s a particular implementation of the more general data structure called a &lt;em&gt;map&lt;/em&gt;.</source>
          <target state="translated">一个&lt;em&gt;哈希表&lt;/em&gt;，您可以将值与特定的键关联。这是称为&lt;em&gt;map&lt;/em&gt;的更通用数据结构的特定实现。</target>
        </trans-unit>
        <trans-unit id="d2dddac086e471872aa5bba992c51dee8e784e1c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;hex literal&lt;/em&gt; starts with the character sequence &lt;code&gt;U+0030&lt;/code&gt;&lt;code&gt;U+0078&lt;/code&gt; (&lt;code&gt;0x&lt;/code&gt;) and continues as any mixture (with at least one digit) of hex digits and underscores.</source>
          <target state="translated">甲&lt;em&gt;十六进制文字&lt;/em&gt;开始与字符序列 &lt;code&gt;U+0030&lt;/code&gt; &lt;code&gt;U+0078&lt;/code&gt; （ &lt;code&gt;0x&lt;/code&gt; ），并继续作为十六进制数字和下划线的任何混合物（至少一位）。</target>
        </trans-unit>
        <trans-unit id="9e38a4ee6fc96f56c22e46e8162db6bbee2c0881" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;literal expression&lt;/em&gt; consists of one of the &lt;a href=&quot;../tokens#literals&quot;&gt;literal&lt;/a&gt; forms described earlier. It directly describes a number, character, string, or boolean value.</source>
          <target state="translated">甲&lt;em&gt;文字表达&lt;/em&gt;由所述一个的&lt;a href=&quot;../tokens#literals&quot;&gt;文字&lt;/a&gt;前面描述的形式。它直接描述数字，字符，字符串或布尔值。</target>
        </trans-unit>
        <trans-unit id="ad9efa9913447a56224684e0aa75e5aeea6b8381" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;local variable&lt;/em&gt; (or &lt;em&gt;stack-local&lt;/em&gt; allocation) holds a value directly, allocated within the stack's memory. The value is a part of the stack frame.</source>
          <target state="translated">甲&lt;em&gt;局部变量&lt;/em&gt;（或&lt;em&gt;堆栈的局部&lt;/em&gt;分配）直接持有的值，堆栈的存储器内分配的。该值是堆栈框架的一部分。</target>
        </trans-unit>
        <trans-unit id="5494ba7068df28e0c7f4a4e2a11fa8f85cf97050" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;match guard&lt;/em&gt; is an additional &lt;code&gt;if&lt;/code&gt; condition specified after the pattern in a &lt;code&gt;match&lt;/code&gt; arm that must also match, along with the pattern matching, for that arm to be chosen. Match guards are useful for expressing more complex ideas than a pattern alone allows.</source>
          <target state="translated">甲&lt;em&gt;匹配后卫&lt;/em&gt;是一个额外的 &lt;code&gt;if&lt;/code&gt; 在一个图案后条件中指定 &lt;code&gt;match&lt;/code&gt; 臂也必须匹配，与图案匹配沿，对于待选择的那个臂。匹配保护器对于表达比单独模式更复杂的想法很有用。</target>
        </trans-unit>
        <trans-unit id="99824c60f6f2f15272aa4440e52b0f6ee9405ef8" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;method call&lt;/em&gt; consists of an expression (the &lt;em&gt;receiver&lt;/em&gt;) followed by a single dot, an expression path segment, and a parenthesized expression-list. Method calls are resolved to associated &lt;a href=&quot;../items/associated-items#methods&quot;&gt;methods&lt;/a&gt; on specific traits, either statically dispatching to a method if the exact &lt;code&gt;self&lt;/code&gt;-type of the left-hand-side is known, or dynamically dispatching if the left-hand-side expression is an indirect &lt;a href=&quot;../types/trait-object&quot;&gt;trait object&lt;/a&gt;.</source>
          <target state="translated">甲&lt;em&gt;方法调用&lt;/em&gt;由表达式（的&lt;em&gt;接收器&lt;/em&gt;，随后通过单个点，表达路径段，和一个圆括弧表达式列表）。方法调用将解析为特定特征上的关联&lt;a href=&quot;../items/associated-items#methods&quot;&gt;方法&lt;/a&gt;，如果已知左侧的确切 &lt;code&gt;self&lt;/code&gt; 类型，则静态分配给方法，如果左侧表达式是间接&lt;a href=&quot;../types/trait-object&quot;&gt;特征对象&lt;/a&gt;，则动态分配给方法。</target>
        </trans-unit>
        <trans-unit id="4326f6a26736f9868551af52753b80b0248e3c0e" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;module item&lt;/em&gt; is a module, surrounded in braces, named, and prefixed with the keyword &lt;code&gt;mod&lt;/code&gt;. A module item introduces a new, named module into the tree of modules making up a crate. Modules can nest arbitrarily.</source>
          <target state="translated">一个&lt;em&gt;模块项目&lt;/em&gt;是一个模块，环绕在括号，命名并以关键字前缀 &lt;code&gt;mod&lt;/code&gt; 。模块项将新的命名模块引入到组成板条箱的模块树中。模块可以任意嵌套。</target>
        </trans-unit>
        <trans-unit id="4782354728434eca4d6ed0db530842093ebdfbdf" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;number literal&lt;/em&gt; is either an &lt;em&gt;integer literal&lt;/em&gt; or a &lt;em&gt;floating-point literal&lt;/em&gt;. The grammar for recognizing the two kinds of literals is mixed.</source>
          <target state="translated">甲&lt;em&gt;数字面&lt;/em&gt;或者是一个&lt;em&gt;整数字面&lt;/em&gt;或&lt;em&gt;浮点文字&lt;/em&gt;。识别两种文字的语法是混合的。</target>
        </trans-unit>
        <trans-unit id="7a1aa14aba61f76729922fa97eab5dfb14fd43e6" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;path&lt;/em&gt; is a sequence of one or more path segments &lt;em&gt;logically&lt;/em&gt; separated by a namespace qualifier (&lt;code&gt;::&lt;/code&gt;). If a path consists of only one segment, it refers to either an &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; or a &lt;a href=&quot;variables&quot;&gt;variable&lt;/a&gt; in a local control scope. If a path has multiple segments, it always refers to an item.</source>
          <target state="translated">甲&lt;em&gt;路径&lt;/em&gt;是一个或多个路径段的序列&lt;em&gt;逻辑&lt;/em&gt;由一个命名空间限定符（分离 &lt;code&gt;::&lt;/code&gt; ）。如果路径仅包含一个段，则它指的是本地控制范围中的&lt;a href=&quot;items&quot;&gt;项目&lt;/a&gt;或&lt;a href=&quot;variables&quot;&gt;变量&lt;/a&gt;。如果路径具有多个段，则始终引用一个项目。</target>
        </trans-unit>
        <trans-unit id="bb92d4c241b315859972fd645fc7612b4dfc9464" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;place expression&lt;/em&gt; is an expression that represents a memory location. These expressions are &lt;a href=&quot;expressions/path-expr&quot;&gt;paths&lt;/a&gt; which refer to local variables, &lt;a href=&quot;items/static-items&quot;&gt;static variables&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereferences&lt;/a&gt; (&lt;code&gt;*expr&lt;/code&gt;), &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;array indexing&lt;/a&gt; expressions (&lt;code&gt;expr[expr]&lt;/code&gt;), &lt;a href=&quot;expressions/field-expr&quot;&gt;field&lt;/a&gt; references (&lt;code&gt;expr.f&lt;/code&gt;) and parenthesized place expressions. All other expressions are value expressions.</source>
          <target state="translated">甲&lt;em&gt;地方表达&lt;/em&gt;是表示存储器位置的表达。这些表达式&lt;a href=&quot;expressions/path-expr&quot;&gt;的路径&lt;/a&gt;，其是指局部变量，&lt;a href=&quot;items/static-items&quot;&gt;静态变量&lt;/a&gt;，&lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;解除引用&lt;/a&gt;（ &lt;code&gt;*expr&lt;/code&gt; ），&lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;数组索引&lt;/a&gt;表达式（ &lt;code&gt;expr[expr]&lt;/code&gt; ），&lt;a href=&quot;expressions/field-expr&quot;&gt;场&lt;/a&gt;的引用（ &lt;code&gt;expr.f&lt;/code&gt; ）和括号的地方表达式。所有其他表达式都是值表达式。</target>
        </trans-unit>
        <trans-unit id="53e179d5349063cc7a43deec2333f4a66dd27469" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;pointer&lt;/em&gt; is a general concept for a variable that contains an address in memory. This address refers to, or &amp;ldquo;points at,&amp;rdquo; some other data. The most common kind of pointer in Rust is a reference, which you learned about in Chapter 4. References are indicated by the &lt;code&gt;&amp;amp;&lt;/code&gt; symbol and borrow the value they point to. They don&amp;rsquo;t have any special capabilities other than referring to data. Also, they don&amp;rsquo;t have any overhead and are the kind of pointer we use most often.</source>
          <target state="translated">甲&lt;em&gt;指针&lt;/em&gt;是包含在存储器中的地址的变量的一般概念。此地址引用或&amp;ldquo;指向&amp;rdquo;其他一些数据。Rust中最常见的一种指针是引用，您已在第4章中了解到。引用由 &lt;code&gt;&amp;amp;&lt;/code&gt; 符号表示，并借用它们指向的值。除了引用数据外，它们没有任何其他特殊功能。而且，它们没有任何开销，是我们最常使用的指针。</target>
        </trans-unit>
        <trans-unit id="7fe098911943171d28affe53c0c7d6311adf867c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;relative path&lt;/em&gt; starts from the current module and uses &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;super&lt;/code&gt;, or an identifier in the current module.</source>
          <target state="translated">甲&lt;em&gt;相对路径&lt;/em&gt;从当前模块和用途开始 &lt;code&gt;self&lt;/code&gt; ， &lt;code&gt;super&lt;/code&gt; ，或在当前模块中的标识符。</target>
        </trans-unit>
        <trans-unit id="b7be095308c163f67b48127967466163200c85dc" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;scalar&lt;/em&gt; type represents a single value. Rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters. You may recognize these from other programming languages. Let&amp;rsquo;s jump into how they work in Rust.</source>
          <target state="translated">甲&lt;em&gt;标量&lt;/em&gt;类型表示一个单一的值。Rust具有四种主要的标量类型：整数，浮点数，布尔值和字符。您可能会从其他编程语言中识别这些。让我们跳到他们在Rust中的工作方式。</target>
        </trans-unit>
        <trans-unit id="5e00452619a2cd4e10d7a42ab9898d401215bca3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;statement&lt;/em&gt; is a component of a &lt;a href=&quot;expressions/block-expr&quot;&gt;block&lt;/a&gt;, which is in turn a component of an outer &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; or &lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt;.</source>
          <target state="translated">甲&lt;em&gt;语句&lt;/em&gt;是一个的部件&lt;a href=&quot;expressions/block-expr&quot;&gt;块&lt;/a&gt;，其又一个外的组分&lt;a href=&quot;expressions&quot;&gt;的表达&lt;/a&gt;或&lt;a href=&quot;items/functions&quot;&gt;功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9cd3832cf111028f53f6cad959deb6ad53f56ca0" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;static item&lt;/em&gt; is similar to a &lt;a href=&quot;constant-items&quot;&gt;constant&lt;/a&gt;, except that it represents a precise memory location in the program. All references to the static refer to the same memory location. Static items have the &lt;code&gt;static&lt;/code&gt; lifetime, which outlives all other lifetimes in a Rust program. Non-&lt;code&gt;mut&lt;/code&gt; static items that contain a type that is not &lt;a href=&quot;../interior-mutability&quot;&gt;interior mutable&lt;/a&gt; may be placed in read-only memory. Static items do not call &lt;a href=&quot;../destructors&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; at the end of the program.</source>
          <target state="translated">甲&lt;em&gt;静态项&lt;/em&gt;类似于&lt;a href=&quot;constant-items&quot;&gt;恒定&lt;/a&gt;，不同之处在于它代表在该程序的精确的存储器位置。所有对静态的引用都指向相同的存储位置。静态项的 &lt;code&gt;static&lt;/code&gt; 生存期超过了Rust程序中的所有其他生存期。包含非&lt;a href=&quot;../interior-mutability&quot;&gt;内部可变&lt;/a&gt;类型的非 &lt;code&gt;mut&lt;/code&gt; 静态项目可以放置在只读存储器中。静态项目不会在程序结束时调用&lt;a href=&quot;../destructors&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9ed445848ff0ebfb7d1082c79316c3f0dc94cf17" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;static item&lt;/em&gt; is similar to a &lt;a href=&quot;constant-items&quot;&gt;constant&lt;/a&gt;, except that it represents a precise memory location in the program. All references to the static refer to the same memory location. Static items have the &lt;code&gt;static&lt;/code&gt; lifetime, which outlives all other lifetimes in a Rust program. Static items do not call &lt;a href=&quot;../destructors&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; at the end of the program.</source>
          <target state="translated">甲&lt;em&gt;静态项&lt;/em&gt;类似于&lt;a href=&quot;constant-items&quot;&gt;恒定&lt;/a&gt;，不同之处在于它代表在该程序的精确的存储器位置。所有对静态的引用都指向相同的存储位置。静态项目的 &lt;code&gt;static&lt;/code&gt; 生存期超过了Rust程序中的所有其他生存期。静态项目不会在程序结束时调用&lt;a href=&quot;../destructors&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="045ded2942d599b289c8f6860ad989b955a99d7c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;string literal&lt;/em&gt; is a sequence of any Unicode characters enclosed within two &lt;code&gt;U+0022&lt;/code&gt; (double-quote) characters, with the exception of &lt;code&gt;U+0022&lt;/code&gt; itself, which must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; character (&lt;code&gt;\&lt;/code&gt;).</source>
          <target state="translated">甲&lt;em&gt;字符串文字&lt;/em&gt;是两个内封入任何Unicode字符序列 &lt;code&gt;U+0022&lt;/code&gt; （双引号）字符，以下除外 &lt;code&gt;U+0022&lt;/code&gt; 本身，其必须被&lt;em&gt;转义&lt;/em&gt;通过前一 &lt;code&gt;U+005C&lt;/code&gt; 字符（ &lt;code&gt;\&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f12122f88fa635dd2b58aa377fdb09d19aba988d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;string slice&lt;/em&gt; is a reference to part of a &lt;code&gt;String&lt;/code&gt;, and it looks like this:</source>
          <target state="translated">一个&lt;em&gt;串片&lt;/em&gt;是一个组成部分的引用 &lt;code&gt;String&lt;/code&gt; ，它看起来是这样的：</target>
        </trans-unit>
        <trans-unit id="691e369dd4289704604ecf4cd7dd7181b87971ad" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;string&lt;/em&gt; is a collection of characters. We&amp;rsquo;ve mentioned the &lt;code&gt;String&lt;/code&gt; type previously, but in this chapter we&amp;rsquo;ll talk about it in depth.</source>
          <target state="translated">一个&lt;em&gt;字符串&lt;/em&gt;是字符的集合。前面我们已经提到了 &lt;code&gt;String&lt;/code&gt; 类型，但是在本章中我们将深入讨论它。</target>
        </trans-unit>
        <trans-unit id="ac2f7e212f4d47b7d6ba3c1b79c057cc109911ff" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;struct expression&lt;/em&gt; creates a struct or union value. It consists of a path to a &lt;a href=&quot;../items/structs&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;../items/unions&quot;&gt;union&lt;/a&gt; item followed by the values for the fields of the item. There are three forms of struct expressions: struct, tuple, and unit.</source>
          <target state="translated">甲&lt;em&gt;结构表达式&lt;/em&gt;创建结构或联合值。它包含一个&lt;a href=&quot;../items/structs&quot;&gt;结构&lt;/a&gt;或&lt;a href=&quot;../items/unions&quot;&gt;联合&lt;/a&gt;项目的路径，后跟该项目字段的值。结构表达式有三种形式：struct，tuple和unit。</target>
        </trans-unit>
        <trans-unit id="d65205e4e512b884279b051d3f883110c3677542" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;struct&lt;/em&gt; is a nominal &lt;a href=&quot;../types/struct&quot;&gt;struct type&lt;/a&gt; defined with the keyword &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">甲&lt;em&gt;结构&lt;/em&gt;是标称&lt;a href=&quot;../types/struct&quot;&gt;结构类型&lt;/a&gt;与关键字定义 &lt;code&gt;struct&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b38ad3b7538f97629f5686d68a34da8981cf5d0" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;struct&lt;/em&gt;, or &lt;em&gt;structure&lt;/em&gt;, is a custom data type that lets you name and package together multiple related values that make up a meaningful group. If you&amp;rsquo;re familiar with an object-oriented language, a &lt;em&gt;struct&lt;/em&gt; is like an object&amp;rsquo;s data attributes. In this chapter, we&amp;rsquo;ll compare and contrast tuples with structs, demonstrate how to use structs, and discuss how to define methods and associated functions to specify behavior associated with a struct&amp;rsquo;s data. Structs and enums (discussed in Chapter 6) are the building blocks for creating new types in your program&amp;rsquo;s domain to take full advantage of Rust&amp;rsquo;s compile time type checking.</source>
          <target state="translated">一个&lt;em&gt;结构&lt;/em&gt;或&lt;em&gt;结构&lt;/em&gt;，是让你命名并一起打包多个相关值，使一个有意义的组自定义数据类型。如果您熟悉面向对象的语言，则&lt;em&gt;结构&lt;/em&gt;就像对象的数据属性一样。在本章中，我们将比较元组和结构，演示如何使用结构，并讨论如何定义方法和相关函数以指定与结构数据相关的行为。结构和枚举（在第6章中进行了讨论）是在程序域中创建新类型以充分利用Rust的编译时类型检查的构造块。</target>
        </trans-unit>
        <trans-unit id="c2b858ff2e5a4ed485b3e5e4a18471183d07402f" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;test double&lt;/em&gt; is the general programming concept for a type used in place of another type during testing. &lt;em&gt;Mock objects&lt;/em&gt; are specific types of test doubles that record what happens during a test so you can assert that the correct actions took place.</source>
          <target state="translated">甲&lt;em&gt;测试双&lt;/em&gt;对于测试期间来代替另一种类型的使用的类型的通用编程的概念。&lt;em&gt;模拟对象&lt;/em&gt;是特定类型的测试双打，记录测试期间发生的情况，因此您可以断言已执行了正确的操作。</target>
        </trans-unit>
        <trans-unit id="9a0e24d887e877ac9c41e5667ab7a119a4c29456" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;thread pool&lt;/em&gt; is a group of spawned threads that are waiting and ready to handle a task. When the program receives a new task, it assigns one of the threads in the pool to the task, and that thread will process the task. The remaining threads in the pool are available to handle any other tasks that come in while the first thread is processing. When the first thread is done processing its task, it&amp;rsquo;s returned to the pool of idle threads, ready to handle a new task. A thread pool allows you to process connections concurrently, increasing the throughput of your server.</source>
          <target state="translated">一个&lt;em&gt;线程池&lt;/em&gt;是一组正在等待并准备好处理任务产生的线程的。当程序接收到新任务时，它会将池中的线程之一分配给该任务，并且该线程将处理该任务。池中的其余线程可用于处理第一个线程正在处理时出现的任何其他任务。当第一个线程完成其任务的处理后，它将返回到空闲线程池中，准备处理新任务。线程池使您可以同时处理连接，从而提高服务器的吞吐量。</target>
        </trans-unit>
        <trans-unit id="313b18e83bc534426ba5a3363e3ef30c68738ffe" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait implementation&lt;/em&gt; is defined like an inherent implementation except that the optional generic type declarations is followed by a &lt;a href=&quot;traits&quot;&gt;trait&lt;/a&gt; followed by the keyword &lt;code&gt;for&lt;/code&gt;. Followed by a path to a nominal type.</source>
          <target state="translated">甲&lt;em&gt;性状实现&lt;/em&gt;被定义相似，但可选的通用类型声明之后是一个固有的执行&lt;a href=&quot;traits&quot;&gt;特征&lt;/a&gt;后跟关键字 &lt;code&gt;for&lt;/code&gt; 。紧随其后的是通向标称类型的路径。</target>
        </trans-unit>
        <trans-unit id="61547573b3bf424e11f1f4f9cd8d9184f5546ee1" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait object&lt;/em&gt; is an opaque value of another type that implements a set of traits. A trait object implements all specified traits as well as their supertraits (if any).</source>
          <target state="translated">甲&lt;em&gt;性状对象&lt;/em&gt;是另一类型的实现一组性状方面的不透明值。特征对象实现所有指定的特征及其上级特征（如果有）。</target>
        </trans-unit>
        <trans-unit id="2ba7bca2e53443f2e59cd9b7a5cdc8e34241ae48" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait object&lt;/em&gt; is an opaque value of another type that implements a set of traits. The set of traits is made up of an &lt;a href=&quot;../items/traits#object-safety&quot;&gt;object safe&lt;/a&gt;&lt;em&gt;base trait&lt;/em&gt; plus any number of &lt;a href=&quot;../special-types-and-traits#auto-traits&quot;&gt;auto traits&lt;/a&gt;.</source>
          <target state="translated">甲&lt;em&gt;性状对象&lt;/em&gt;是另一类型的实现一组性状方面的不透明值。特征集由&lt;a href=&quot;../items/traits#object-safety&quot;&gt;对象安全&lt;/a&gt;&lt;em&gt;基本特征&lt;/em&gt;加上任意数量的&lt;a href=&quot;../special-types-and-traits#auto-traits&quot;&gt;自动特征组成&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5df129cc6b630156d556e5813378ed108b2ab443" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait&lt;/em&gt; describes an abstract interface that types can implement. This interface consists of &lt;a href=&quot;associated-items&quot;&gt;associated items&lt;/a&gt;, which come in three varieties:</source>
          <target state="translated">一个&lt;em&gt;特征&lt;/em&gt;描述了一个抽象的接口类型可以实现。该界面由&lt;a href=&quot;associated-items&quot;&gt;相关的项目&lt;/a&gt;组成，有以下三种：</target>
        </trans-unit>
        <trans-unit id="a413d8d80703ed47836b183924cabc19246e5f7c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait&lt;/em&gt; tells the Rust compiler about functionality a particular type has and can share with other types. We can use traits to define shared behavior in an abstract way. We can use trait bounds to specify that a generic can be any type that has certain behavior.</source>
          <target state="translated">甲&lt;em&gt;性状&lt;/em&gt;告诉编译器锈大约功能的特定类型的具有可与其他类型的共享。我们可以使用特征以抽象的方式定义共享行为。我们可以使用特征范围来指定泛型可以是具有特定行为的任何类型。</target>
        </trans-unit>
        <trans-unit id="9018c5e20d838075d5b138f7d86d8d8c684fb244" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;tuple index&lt;/em&gt; is either &lt;code&gt;0&lt;/code&gt;, or starts with a &lt;em&gt;non-zero decimal digit&lt;/em&gt; and continues with zero or more decimal digits. Tuple indexes are used to refer to the fields of &lt;a href=&quot;types/tuple&quot;&gt;tuples&lt;/a&gt;, &lt;a href=&quot;items/structs&quot;&gt;tuple structs&lt;/a&gt; and &lt;a href=&quot;items/enumerations&quot;&gt;tuple variants&lt;/a&gt;.</source>
          <target state="translated">甲&lt;em&gt;元组索引&lt;/em&gt;或者是 &lt;code&gt;0&lt;/code&gt; ，或具有开始&lt;em&gt;非零十进制数字&lt;/em&gt;，并与零个或多个十进制数字继续。元组索引用于引用&lt;a href=&quot;types/tuple&quot;&gt;元组&lt;/a&gt;，&lt;a href=&quot;items/structs&quot;&gt;元组结构&lt;/a&gt;和&lt;a href=&quot;items/enumerations&quot;&gt;元组变体&lt;/a&gt;的字段。</target>
        </trans-unit>
        <trans-unit id="c47a882c5415e255f49931b3989ce3cbb03e65f7" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;tuple struct&lt;/em&gt; is a nominal &lt;a href=&quot;../types/tuple&quot;&gt;tuple type&lt;/a&gt;, also defined with the keyword &lt;code&gt;struct&lt;/code&gt;. For example:</source>
          <target state="translated">甲&lt;em&gt;元组结构&lt;/em&gt;是标称&lt;a href=&quot;../types/tuple&quot;&gt;元组类型&lt;/a&gt;，也与关键字定义 &lt;code&gt;struct&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="e97b14c685e031728ecd4469c910a8f3603e601d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;tuple struct&lt;/em&gt; type is just like a struct type, except that the fields are anonymous.</source>
          <target state="translated">一个&lt;em&gt;元组结构&lt;/em&gt;类型就像是一个结构类型，除了字段是匿名的。</target>
        </trans-unit>
        <trans-unit id="57b75c1dd6681cfbd15ca11a1f0f5681b515a0f3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;type alias&lt;/em&gt; defines a new name for an existing &lt;a href=&quot;../types&quot;&gt;type&lt;/a&gt;. Type aliases are declared with the keyword &lt;code&gt;type&lt;/code&gt;. Every value has a single, specific type, but may implement several different traits, or be compatible with several different type constraints.</source>
          <target state="translated">一个&lt;em&gt;类型别名&lt;/em&gt;定义为现有的新名称&lt;a href=&quot;../types&quot;&gt;类型&lt;/a&gt;。类型别名用关键字 &lt;code&gt;type&lt;/code&gt; 声明。每个值都有一个特定的类型，但是可以实现多个不同的特征，或者与多个不同的类型约束兼容。</target>
        </trans-unit>
        <trans-unit id="64ff4b8d7e3ee42067c7072aacfc14cd027c093c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;type expression&lt;/em&gt; as defined in the &lt;em&gt;Type&lt;/em&gt; grammar rule above is the syntax for referring to a type. It may refer to:</source>
          <target state="translated">上面的&amp;ldquo; &lt;em&gt;类型&amp;rdquo;&lt;/em&gt;文法规则中定义的&lt;em&gt;类型表达式&lt;/em&gt;是引用类型的语法。它可能指的是：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="50c0af6b4bb64ca1523e3b2abba8e82a69abff5a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;union type&lt;/em&gt; is a nominal, heterogeneous C-like union, denoted by the name of a &lt;a href=&quot;../items/unions&quot;&gt;&lt;code&gt;union&lt;/code&gt; item&lt;/a&gt;.</source>
          <target state="translated">甲&lt;em&gt;联合类型&lt;/em&gt;是标称的，异构的类C的结合，由名称表示&lt;a href=&quot;../items/unions&quot;&gt; &lt;code&gt;union&lt;/code&gt; 项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="96e68805af9609cb7109b9bd3ef8c3be60b740ca" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;unit-like struct&lt;/em&gt; is a struct without any fields, defined by leaving off the list of fields entirely. Such a struct implicitly defines a constant of its type with the same name. For example:</source>
          <target state="translated">类&lt;em&gt;单元结构&lt;/em&gt;是没有任何字段的结构，通过完全省略字段列表来定义。这样的结构隐式定义了一个具有相同名称的类型常量。例如：</target>
        </trans-unit>
        <trans-unit id="6075d4cd12c28e60ac874060f12974e3762a509a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;unit-like struct&lt;/em&gt; type is like a struct type, except that it has no fields. The one value constructed by the associated &lt;a href=&quot;../expressions/struct-expr&quot;&gt;struct expression&lt;/a&gt; is the only value that inhabits such a type.</source>
          <target state="translated">甲&lt;em&gt;单元状结构&lt;/em&gt;类型是像结构类型，不同之处在于它没有字段。由关联的&lt;a href=&quot;../expressions/struct-expr&quot;&gt;struct表达式&lt;/a&gt;构造的一个值是唯一一个占用这种类型的值。</target>
        </trans-unit>
        <trans-unit id="ed7d45b3f3a4f92438f32980c894150a8a0dee9d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;use declaration&lt;/em&gt; creates one or more local name bindings synonymous with some other &lt;a href=&quot;../paths&quot;&gt;path&lt;/a&gt;. Usually a &lt;code&gt;use&lt;/code&gt; declaration is used to shorten the path required to refer to a module item. These declarations may appear in &lt;a href=&quot;modules&quot;&gt;modules&lt;/a&gt; and &lt;a href=&quot;../expressions/block-expr&quot;&gt;blocks&lt;/a&gt;, usually at the top.</source>
          <target state="translated">一个&lt;em&gt;使用声明&lt;/em&gt;创建一个或多个本地名称绑定的代名词，一些其他的&lt;a href=&quot;../paths&quot;&gt;路径&lt;/a&gt;。通常， &lt;code&gt;use&lt;/code&gt; 声明用于缩短引用模块项所需的路径。这些声明可能出现在&lt;a href=&quot;modules&quot;&gt;模块&lt;/a&gt;和&lt;a href=&quot;../expressions/block-expr&quot;&gt;块中&lt;/a&gt;，通常在顶部。</target>
        </trans-unit>
        <trans-unit id="2d8a654904db4cbe04f06da827ae2d7d450774ec" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;value expression&lt;/em&gt; is an expression that represents an actual value.</source>
          <target state="translated">甲&lt;em&gt;值表达式&lt;/em&gt;是表示实际值的表达式。</target>
        </trans-unit>
        <trans-unit id="e6fd1c9fb448dc3050e431f7efdd6fccf7fb69e9" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;variable&lt;/em&gt; is a component of a stack frame, either a named function parameter, an anonymous &lt;a href=&quot;expressions#temporaries&quot;&gt;temporary&lt;/a&gt;, or a named local variable.</source>
          <target state="translated">甲&lt;em&gt;变量&lt;/em&gt;是一个堆栈帧的组成部分，包括命名功能参数，一个匿名&lt;a href=&quot;expressions#temporaries&quot;&gt;临时&lt;/a&gt;或命名局部变量。</target>
        </trans-unit>
        <trans-unit id="729fdc3c2a54819bca891fd0485aedb791a49cea" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;variable&lt;/em&gt; is a component of a stack frame, either a named function parameter, an anonymous &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;temporary&lt;/a&gt;, or a named local variable.</source>
          <target state="translated">甲&lt;em&gt;变量&lt;/em&gt;是一个堆栈帧的组成部分，包括命名功能参数，一个匿名&lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;临时&lt;/a&gt;或命名局部变量。</target>
        </trans-unit>
        <trans-unit id="81028e39252e1de4d0939b21f1ccc9432b693d6d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;vector&lt;/em&gt; allows you to store a variable number of values next to each other.</source>
          <target state="translated">甲&lt;em&gt;矢量&lt;/em&gt;允许你值的可变数量的存储彼此相邻。</target>
        </trans-unit>
        <trans-unit id="cbf31b3f11b4472e6a3c452469774ef2fe901798" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;whitespace escape&lt;/em&gt; is one of the characters &lt;code&gt;U+006E&lt;/code&gt; (&lt;code&gt;n&lt;/code&gt;), &lt;code&gt;U+0072&lt;/code&gt; (&lt;code&gt;r&lt;/code&gt;), or &lt;code&gt;U+0074&lt;/code&gt; (&lt;code&gt;t&lt;/code&gt;), denoting the Unicode values &lt;code&gt;U+000A&lt;/code&gt; (LF), &lt;code&gt;U+000D&lt;/code&gt; (CR) or &lt;code&gt;U+0009&lt;/code&gt; (HT) respectively.</source>
          <target state="translated">甲&lt;em&gt;空白逃逸&lt;/em&gt;是字符中的一个 &lt;code&gt;U+006E&lt;/code&gt; （ &lt;code&gt;n&lt;/code&gt; ）， &lt;code&gt;U+0072&lt;/code&gt; （ &lt;code&gt;r&lt;/code&gt; 或 &lt;code&gt;U+0074&lt;/code&gt; （ &lt;code&gt;t&lt;/code&gt; ），表示的Unicode值 &lt;code&gt;U+000A&lt;/code&gt; （LF）， &lt;code&gt;U+000D&lt;/code&gt; （CR）或 &lt;code&gt;U+0009&lt;/code&gt; （HT）分别。</target>
        </trans-unit>
        <trans-unit id="733e62321cc2dbb502882e64ee8c595f1cf223e3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;whitespace escape&lt;/em&gt; is one of the characters &lt;code&gt;U+006E&lt;/code&gt; (&lt;code&gt;n&lt;/code&gt;), &lt;code&gt;U+0072&lt;/code&gt; (&lt;code&gt;r&lt;/code&gt;), or &lt;code&gt;U+0074&lt;/code&gt; (&lt;code&gt;t&lt;/code&gt;), denoting the bytes values &lt;code&gt;0x0A&lt;/code&gt; (ASCII LF), &lt;code&gt;0x0D&lt;/code&gt; (ASCII CR) or &lt;code&gt;0x09&lt;/code&gt; (ASCII HT) respectively.</source>
          <target state="translated">甲&lt;em&gt;空白逃逸&lt;/em&gt;是字符中的一个 &lt;code&gt;U+006E&lt;/code&gt; （ &lt;code&gt;n&lt;/code&gt; ）， &lt;code&gt;U+0072&lt;/code&gt; （ &lt;code&gt;r&lt;/code&gt; 或 &lt;code&gt;U+0074&lt;/code&gt; （ &lt;code&gt;t&lt;/code&gt; ），表示该字节值 &lt;code&gt;0x0A&lt;/code&gt; （ASCII LF）， &lt;code&gt;0x0D&lt;/code&gt; （ASCII CR）或 &lt;code&gt;0x09&lt;/code&gt; （ASCII HT ） 分别。</target>
        </trans-unit>
        <trans-unit id="17736723b13336b3d27ceb298ec5fb02952febad" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;workspace&lt;/em&gt; is a set of packages that share the same &lt;em&gt;Cargo.lock&lt;/em&gt; and output directory. Let&amp;rsquo;s make a project using a workspace&amp;mdash;we&amp;rsquo;ll use trivial code so we can concentrate on the structure of the workspace. There are multiple ways to structure a workspace; we&amp;rsquo;re going to show one common way. We&amp;rsquo;ll have a workspace containing a binary and two libraries. The binary, which will provide the main functionality, will depend on the two libraries. One library will provide an &lt;code&gt;add_one&lt;/code&gt; function, and a second library an &lt;code&gt;add_two&lt;/code&gt; function. These three crates will be part of the same workspace. We&amp;rsquo;ll start by creating a new directory for the workspace:</source>
          <target state="translated">一个&lt;em&gt;工作空间&lt;/em&gt;是一组共享相同的封装&lt;em&gt;Cargo.lock&lt;/em&gt;和输出目录。让我们使用工作区进行项目&amp;mdash;我们将使用简单的代码，以便我们专注于工作区的结构。有多种方法来构造工作空间。我们将展示一种常见的方式。我们将有一个包含二进制文件和两个库的工作区。二进制文件将提供主要功能，将取决于这两个库。一个库将提供 &lt;code&gt;add_one&lt;/code&gt; 函数，第二个库将提供 &lt;code&gt;add_two&lt;/code&gt; 函数。这三个板条箱将属于同一工作区。我们将从为工作空间创建一个新目录开始：</target>
        </trans-unit>
        <trans-unit id="57b97a971f9a5924055674cfb5ecccdeda84f005" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;multiprocessor&lt;/strong&gt; system executing multiple hardware threads at the same time: In multi-threaded scenarios, you can use two kinds of primitives to deal with synchronization:</source>
          <target state="translated">同时执行多个硬件线程的&lt;strong&gt;多处理器&lt;/strong&gt;系统：在多线程方案中，可以使用两种原语来处理同步：</target>
        </trans-unit>
        <trans-unit id="9915cb86be4513e2479c88bd6630c4bace88619c" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;send&lt;/strong&gt; operation can only fail if the receiving end of a channel is disconnected, implying that the data could never be received. The error contains the data being sent as a payload so it can be recovered.</source>
          <target state="translated">甲&lt;strong&gt;发送&lt;/strong&gt;如果一个信道的接收端断开时，这意味着该数据不可能被接收操作只能失败。错误包含正在作为有效负载发送的数据，因此可以将其恢复。</target>
        </trans-unit>
        <trans-unit id="45d6b0e56e209127760ab52ba9ab193c0dce03db" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;single processor&lt;/strong&gt; executing instructions &lt;a href=&quot;https://en.wikipedia.org/wiki/Out-of-order_execution&quot;&gt;out-of-order&lt;/a&gt;: Modern CPUs are capable of &lt;a href=&quot;https://en.wikipedia.org/wiki/Superscalar_processor&quot;&gt;superscalar&lt;/a&gt; execution, i.e., multiple instructions might be executing at the same time, even though the machine code describes a sequential process.</source>
          <target state="translated">甲&lt;strong&gt;单个处理器&lt;/strong&gt;执行指令&lt;a href=&quot;https://en.wikipedia.org/wiki/Out-of-order_execution&quot;&gt;外的顺序&lt;/a&gt;：现代的CPU能够&lt;a href=&quot;https://en.wikipedia.org/wiki/Superscalar_processor&quot;&gt;超标量&lt;/a&gt;执行，即，多个指令可以在同一时间被执行，即使机器代码描述为顺序过程。</target>
        </trans-unit>
        <trans-unit id="f80e6281478ac21b10d3f64a5db5116d11300661" translate="yes" xml:space="preserve">
          <source>A B-Tree instead makes each node contain B-1 to 2B-1 elements in a contiguous array. By doing this, we reduce the number of allocations by a factor of B, and improve cache efficiency in searches. However, this does mean that searches will have to do &lt;em&gt;more&lt;/em&gt; comparisons on average. The precise number of comparisons depends on the node search strategy used. For optimal cache efficiency, one could search the nodes linearly. For optimal comparisons, one could search the node using binary search. As a compromise, one could also perform a linear search that initially only checks every i&lt;sup&gt;th&lt;/sup&gt; element for some choice of i.</source>
          <target state="translated">相反，B树使每个节点在连续数组中包含B-1至2B-1元素。通过这样做，我们将分配数量减少了B倍，并提高了搜索中的缓存效率。但是，这确实意味着搜索平均需要进行&lt;em&gt;更多的&lt;/em&gt;比较。比较的精确数量取决于所使用的节点搜索策略。为了获得最佳的缓存效率，可以线性搜索节点。为了进行最佳比较，可以使用二进制搜索来搜索节点。作为一种折衷，也可以执行线性搜索，该搜索最初仅检查每个&lt;sup&gt;第&lt;/sup&gt; i &lt;sup&gt;个&lt;/sup&gt;元素以选择i。</target>
        </trans-unit>
        <trans-unit id="4c64fcf1b73694ea8bba81897d2a64705afb1b18" translate="yes" xml:space="preserve">
          <source>A C-variadic type is used to give an undefined number of parameters to a given function (like &lt;code&gt;printf&lt;/code&gt; in C). The equivalent in Rust would be to use macros directly (like &lt;code&gt;println!&lt;/code&gt; for example).</source>
          <target state="translated">C变量类型用于为给定的函数提供不确定数量的参数（例如 &lt;code&gt;printf&lt;/code&gt; 中的printf）。Rust中的等效项是直接使用宏（例如 &lt;code&gt;println!&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c719a71ad064f07814cb183dc83cacff56d42170" translate="yes" xml:space="preserve">
          <source>A Closer Look at an HTTP Request</source>
          <target state="translated">仔细观察HTTP请求</target>
        </trans-unit>
        <trans-unit id="225f2cd7742ef94df62bae5174a9097b85507248" translate="yes" xml:space="preserve">
          <source>A Condition Variable</source>
          <target state="translated">一个条件变量</target>
        </trans-unit>
        <trans-unit id="e89d14f838ea1a71651772640c4009592aced676" translate="yes" xml:space="preserve">
          <source>A Rust binary or library.</source>
          <target state="translated">一个Rust二进制或库。</target>
        </trans-unit>
        <trans-unit id="16eac1f550799edbb7e48476dda921af52e9a679" translate="yes" xml:space="preserve">
          <source>A Rust program has identical meaning if each whitespace element is replaced with any other legal whitespace element, such as a single space character.</source>
          <target state="translated">如果每个whitespace元素被任何其他合法的whitespace元素替换,例如一个空格字符,那么Rust程序就具有相同的意义。</target>
        </trans-unit>
        <trans-unit id="3436eb9d1ac524996565fc93c80cf6376e000505" translate="yes" xml:space="preserve">
          <source>A Rust source file describes a module, the name and location of which &amp;mdash; in the module tree of the current crate &amp;mdash; are defined from outside the source file: either by an explicit &lt;a href=&quot;items/modules&quot;&gt;&lt;em&gt;Module&lt;/em&gt;&lt;/a&gt; item in a referencing source file, or by the name of the crate itself. Every source file is a module, but not every module needs its own source file: &lt;a href=&quot;items/modules&quot;&gt;module definitions&lt;/a&gt; can be nested within one file.</source>
          <target state="translated">Rust源文件描述了一个模块，该模块的名称和位置（在当前包装箱的模块树中）是从源文件外部定义的：是通过引用源文件中的显式&lt;a href=&quot;items/modules&quot;&gt;&lt;em&gt;Module&lt;/em&gt;&lt;/a&gt;项，还是通过名称板条箱本身。每个源文件都是一个模块，但是并不是每个模块都需要自己的源文件：&lt;a href=&quot;items/modules&quot;&gt;模块定义&lt;/a&gt;可以嵌套在一个文件中。</target>
        </trans-unit>
        <trans-unit id="7e4ee862d170940577240b6a363de9c90118288a" translate="yes" xml:space="preserve">
          <source>A Shortcut for Propagating Errors: the &lt;code id=&quot;a-shortcut-for-propagating-errors-the--operator&quot;&gt;?&lt;/code&gt; Operator</source>
          <target state="translated">传播错误的捷径： &lt;code id=&quot;a-shortcut-for-propagating-errors-the--operator&quot;&gt;?&lt;/code&gt; 操作员</target>
        </trans-unit>
        <trans-unit id="e0701ba8496c6c0ce0663c50dfed3d1742ffe428" translate="yes" xml:space="preserve">
          <source>A TCP socket server, listening for connections.</source>
          <target state="translated">一个TCP套接字服务器,监听连接。</target>
        </trans-unit>
        <trans-unit id="18b391c1b0a22ff1e173b47c159e749d6face6b8" translate="yes" xml:space="preserve">
          <source>A TCP stream between a local and a remote socket.</source>
          <target state="translated">本地和远程套接字之间的TCP流。</target>
        </trans-unit>
        <trans-unit id="14cd46b40ffb5428999e053c5d3b3c28ef9b4547" translate="yes" xml:space="preserve">
          <source>A Touch of Refactoring</source>
          <target state="translated">触摸重构</target>
        </trans-unit>
        <trans-unit id="f8b80e8d44eb439e0e6a949110529d41c8e00ad6" translate="yes" xml:space="preserve">
          <source>A Tour of The Rust Standard Library</source>
          <target state="translated">锈迹斑斑的标准图书馆之旅</target>
        </trans-unit>
        <trans-unit id="816b40a1a34bc0276678819c021264566903408c" translate="yes" xml:space="preserve">
          <source>A UDP socket.</source>
          <target state="translated">一个UDP插座。</target>
        </trans-unit>
        <trans-unit id="276e8a17fbe2956e663b37ba194fe05fa5a8f2c4" translate="yes" xml:space="preserve">
          <source>A UTF-8 encoded, growable string.</source>
          <target state="translated">一个UTF-8编码的、可增长的字符串。</target>
        </trans-unit>
        <trans-unit id="9de745a43beb358e074abd87790ad347e9b21ca2" translate="yes" xml:space="preserve">
          <source>A UTF-8&amp;ndash;encoded, growable string.</source>
          <target state="translated">一个UTF-8编码的可增长字符串。</target>
        </trans-unit>
        <trans-unit id="bb20973ca0b74c01c90760f89fd1e1ce6ddd0490" translate="yes" xml:space="preserve">
          <source>A Unix datagram socket.</source>
          <target state="translated">一个Unix数据报插口。</target>
        </trans-unit>
        <trans-unit id="735c3a01ab88f3b77275bbda413fc5d0f8e00e4c" translate="yes" xml:space="preserve">
          <source>A Unix socket Ancillary data struct.</source>
          <target state="translated">一个Unix socket辅助数据结构。</target>
        </trans-unit>
        <trans-unit id="a23c9f511bfc020ca8a27e2556501e3c327d1d73" translate="yes" xml:space="preserve">
          <source>A Unix stream socket.</source>
          <target state="translated">一个Unix流套接字。</target>
        </trans-unit>
        <trans-unit id="3ad52f3aeb1d324427854f3ea2a73655c8ec06e9" translate="yes" xml:space="preserve">
          <source>A Use Case for Interior Mutability: Mock Objects</source>
          <target state="translated">内部可变性的使用案例。模拟对象</target>
        </trans-unit>
        <trans-unit id="822d2ee37fadc9a2c447d0ca642e7e4a4d011579" translate="yes" xml:space="preserve">
          <source>A Windows path prefix, e.g., &lt;code&gt;C:&lt;/code&gt; or &lt;code&gt;\\server\share&lt;/code&gt;.</source>
          <target state="translated">Windows路径前缀，例如 &lt;code&gt;C:&lt;/code&gt; 或 &lt;code&gt;\\server\share&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="37a911d0c1b6b4316ddb2ac619c44257424a4bb3" translate="yes" xml:space="preserve">
          <source>A Windows path prefix, e.g., &lt;code&gt;C:&lt;/code&gt; or &lt;code&gt;\server\share&lt;/code&gt;.</source>
          <target state="translated">Windows路径前缀，例如 &lt;code&gt;C:&lt;/code&gt; 或 &lt;code&gt;\server\share&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="41a63844a54d0452136942153b7bfc3f9e8d7950" translate="yes" xml:space="preserve">
          <source>A backtrace has been captured and the &lt;code&gt;Backtrace&lt;/code&gt; should print reasonable information when rendered.</source>
          <target state="translated">已经捕获了 &lt;code&gt;Backtrace&lt;/code&gt; 并且在渲染时回溯应该打印合理的信息。</target>
        </trans-unit>
        <trans-unit id="063c41d44c26a8e514637789567756dedf001744" translate="yes" xml:space="preserve">
          <source>A backtrace is typically quite handy to attach to errors (e.g. types implementing &lt;code&gt;std::error::Error&lt;/code&gt;) to get a causal chain of where an error was generated.</source>
          <target state="translated">回溯通常很容易附加到错误（例如，实现 &lt;code&gt;std::error::Error&lt;/code&gt; 类型）以获取产生错误的原因的因果链。</target>
        </trans-unit>
        <trans-unit id="ff93a614690d1d51c188c5129e768aec7cd0c763" translate="yes" xml:space="preserve">
          <source>A barrier enables multiple threads to synchronize the beginning of some computation.</source>
          <target state="translated">屏障使多个线程能够同步开始一些计算。</target>
        </trans-unit>
        <trans-unit id="c1ac9e66093aa4ca440868ee501f91a3a0e906b0" translate="yes" xml:space="preserve">
          <source>A barrier will block &lt;code&gt;n&lt;/code&gt;-1 threads which call &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; and then wake up all threads at once when the &lt;code&gt;n&lt;/code&gt;th thread calls &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">屏障将阻塞调用&lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; 的&lt;/a&gt; &lt;code&gt;n&lt;/code&gt; -1个线程，然后在第 &lt;code&gt;n&lt;/code&gt; 个线程调用&lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;时立即唤醒所有线程。</target>
        </trans-unit>
        <trans-unit id="62ccc167e0423bac501b2cd57e5b7720dec15103" translate="yes" xml:space="preserve">
          <source>A barrier will block &lt;code&gt;n&lt;/code&gt;-1 threads which call &lt;a href=&quot;struct.barrier#method.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; and then wake up all threads at once when the &lt;code&gt;n&lt;/code&gt;th thread calls &lt;a href=&quot;struct.barrier#method.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">屏障将阻塞调用&lt;a href=&quot;struct.barrier#method.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; 的&lt;/a&gt; &lt;code&gt;n&lt;/code&gt; -1个线程，然后在第 &lt;code&gt;n&lt;/code&gt; 个线程调用&lt;a href=&quot;struct.barrier#method.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt;时立即唤醒所有线程。</target>
        </trans-unit>
        <trans-unit id="58cdbd4e4749375a003884d9f4eb272538b31a8e" translate="yes" xml:space="preserve">
          <source>A basic example:</source>
          <target state="translated">一个基本的例子。</target>
        </trans-unit>
        <trans-unit id="b427e17a0965dfac7d96b4ee22a549d95854674d" translate="yes" xml:space="preserve">
          <source>A basic string declaration of &lt;code&gt;&amp;amp;str&lt;/code&gt; type:</source>
          <target state="translated">&lt;code&gt;&amp;amp;str&lt;/code&gt; 类型的基本字符串声明：</target>
        </trans-unit>
        <trans-unit id="e58e2e213f635868b8917c1f64d97bcd94087385" translate="yes" xml:space="preserve">
          <source>A binary assignment operator like &lt;code&gt;+=&lt;/code&gt; or &lt;code&gt;^=&lt;/code&gt; was applied to a type that doesn't support it.</source>
          <target state="translated">像 &lt;code&gt;+=&lt;/code&gt; 或 &lt;code&gt;^=&lt;/code&gt; 这样的二进制赋值运算符应用于了不支持它的类型。</target>
        </trans-unit>
        <trans-unit id="807a8b4172841ae84d2493b466a14c239a712c9e" translate="yes" xml:space="preserve">
          <source>A binary can only have one entry point, and by default that entry point is the &lt;code&gt;main()&lt;/code&gt; function. If there are multiple instances of this function, please rename one of them.</source>
          <target state="translated">二进制文件只能有一个入口点，默认情况下，该入口点是 &lt;code&gt;main()&lt;/code&gt; 函数。如果此功能有多个实例，请重命名其中之一。</target>
        </trans-unit>
        <trans-unit id="5f95a7b46c7703730f6563de2663542b39249317" translate="yes" xml:space="preserve">
          <source>A binary can only have one entry point, and by default that entry point is the function &lt;code&gt;main()&lt;/code&gt;. If there are multiple such functions, please rename one.</source>
          <target state="translated">二进制文件只能有一个入口点，默认情况下，该入口点是函数 &lt;code&gt;main()&lt;/code&gt; 。如果有多个这样的功能，请重命名一个。</target>
        </trans-unit>
        <trans-unit id="66f8440b5cbe5979ef5cd4aca43bf502a1ba0914" translate="yes" xml:space="preserve">
          <source>A binary operation was attempted on a type which doesn't support it.</source>
          <target state="translated">在一个不支持二进制操作的类型上尝试了一个二进制操作。</target>
        </trans-unit>
        <trans-unit id="b38f665f61e73d6f968e8571206665e15cc36346" translate="yes" xml:space="preserve">
          <source>A binary operation was attempted on a type which doesn't support it. Erroneous code example:</source>
          <target state="translated">在一个不支持二进制操作的类型上尝试了二进制操作。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="aa172e5751306c59c090e9db789e410971427e9e" translate="yes" xml:space="preserve">
          <source>A binding shadowed something it shouldn't.</source>
          <target state="translated">绑定了不该有的阴影。</target>
        </trans-unit>
        <trans-unit id="2196fa2a21cb36f1296a2eab8560f7f044fc56a6" translate="yes" xml:space="preserve">
          <source>A block expression as the tail expression of another block expression.</source>
          <target state="translated">一个区块表达式作为另一个区块表达式的尾部表达式。</target>
        </trans-unit>
        <trans-unit id="a693c9a42f3c8985b5be041d70547d78d1d2e744" translate="yes" xml:space="preserve">
          <source>A block of code can be prefixed with the &lt;code&gt;unsafe&lt;/code&gt; keyword to permit &lt;a href=&quot;../unsafety&quot;&gt;unsafe operations&lt;/a&gt;. Examples:</source>
          <target state="translated">可以在代码块的前面加上 &lt;code&gt;unsafe&lt;/code&gt; 关键字，以允许进行&lt;a href=&quot;../unsafety&quot;&gt;不安全的操作&lt;/a&gt;。例子：</target>
        </trans-unit>
        <trans-unit id="3f1de3ecbc17ea9a1f67c2ee7ad38362f83951f6" translate="yes" xml:space="preserve">
          <source>A block of code can be prefixed with the &lt;code&gt;unsafe&lt;/code&gt; keyword, to permit calling &lt;code&gt;unsafe&lt;/code&gt; functions or dereferencing raw pointers within a safe function.</source>
          <target state="translated">可以在代码块的前面加上 &lt;code&gt;unsafe&lt;/code&gt; 关键字，以允许调用 &lt;code&gt;unsafe&lt;/code&gt; 函数或取消引用安全函数内的原始指针。</target>
        </trans-unit>
        <trans-unit id="e2aaacb371035dfa3169004d8d112f1e5b1ca71a" translate="yes" xml:space="preserve">
          <source>A blog post starts as an empty draft.</source>
          <target state="translated">一篇博文开始时是空稿。</target>
        </trans-unit>
        <trans-unit id="beb16f573b8715d8a98aa06e002398f8060629f2" translate="yes" xml:space="preserve">
          <source>A boolean type which can be safely shared between threads.</source>
          <target state="translated">一个可以在线程之间安全共享的布尔类型。</target>
        </trans-unit>
        <trans-unit id="eb779fca6863a6a0d358d8e696c27d09f35c87e4" translate="yes" xml:space="preserve">
          <source>A borrow of a constant containing interior mutability was attempted.</source>
          <target state="translated">尝试了一种包含内部突变性的常数的借用。</target>
        </trans-unit>
        <trans-unit id="3d64914b686b3e740569b7a037982d02419990a4" translate="yes" xml:space="preserve">
          <source>A borrow of a constant containing interior mutability was attempted. Erroneous code example:</source>
          <target state="translated">试图借用一个包含内部突变性的常量。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="6c3704913d69bb40474f716695cc894d7bfa528c" translate="yes" xml:space="preserve">
          <source>A borrow of a thread-local variable was made inside a function which outlived the lifetime of the function.</source>
          <target state="translated">在函数内部借用了一个线程局部变量,该变量超过了函数的寿命。</target>
        </trans-unit>
        <trans-unit id="f237c3c1919eddd418933b1a63f322a0d0d2a0eb" translate="yes" xml:space="preserve">
          <source>A borrowed value was moved out.</source>
          <target state="translated">一个借来的价值被搬了出来。</target>
        </trans-unit>
        <trans-unit id="9b2fc820fbc3d301d2c71b19ff6713c60dff7377" translate="yes" xml:space="preserve">
          <source>A borrowed variable was used by a closure.</source>
          <target state="translated">一个借来的变量被封闭使用。</target>
        </trans-unit>
        <trans-unit id="c83fc1310c1c04b54cc7e1f86e92066f4da726ab" translate="yes" xml:space="preserve">
          <source>A borrowed variable was used by a closure. Example of erroneous code:</source>
          <target state="translated">借用的变量被一个闭包使用。错误代码的例子。</target>
        </trans-unit>
        <trans-unit id="b7c0d93da848c216d8d60ef97d23c6ae7dfef33f" translate="yes" xml:space="preserve">
          <source>A break expression is normally associated with the innermost loop enclosing the &lt;code&gt;break&lt;/code&gt; but a label can be used to specify which enclosing loop is affected.</source>
          <target state="translated">break表达式通常与包围该 &lt;code&gt;break&lt;/code&gt; 的最里面的循环相关联，但是可以使用标签来指定哪个包围环受到影响。</target>
        </trans-unit>
        <trans-unit id="4584a71b04a4125f9586dd4d0599984c41f8d406" translate="yes" xml:space="preserve">
          <source>A broadcast address has all octets set to 255 as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc919&quot;&gt;IETF RFC 919&lt;/a&gt;.</source>
          <target state="translated">广播地址的所有八位位组都设置为&lt;a href=&quot;https://tools.ietf.org/html/rfc919&quot;&gt;IETF RFC 919中&lt;/a&gt;定义的255 。</target>
        </trans-unit>
        <trans-unit id="a5ed95e144c4e88ac8aa93a227c762654f2cb478" translate="yes" xml:space="preserve">
          <source>A buffer that's too small:</source>
          <target state="translated">缓冲区太小。</target>
        </trans-unit>
        <trans-unit id="4b481eff295b8689efc0884b27cfb033e7e5efe6" translate="yes" xml:space="preserve">
          <source>A buffer type used with &lt;code&gt;Read::read_vectored&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;Read::read_vectored&lt;/code&gt; 一起使用的缓冲区类型。</target>
        </trans-unit>
        <trans-unit id="bc33ba1a0c8fc7e0d6803cc242c896b07605dc58" translate="yes" xml:space="preserve">
          <source>A buffer type used with &lt;code&gt;Write::write_vectored&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;Write::write_vectored&lt;/code&gt; 一起使用的缓冲区类型。</target>
        </trans-unit>
        <trans-unit id="9634bddc5eaddedf795f81dbe84a65e742c0b750" translate="yes" xml:space="preserve">
          <source>A builder for computing where in a HashMap a key-value pair would be stored.</source>
          <target state="translated">一个用于计算HashMap中键值对存储位置的构建器。</target>
        </trans-unit>
        <trans-unit id="164e9f9ed41b273049862041cd75d7cccf4e70e8" translate="yes" xml:space="preserve">
          <source>A builder used to create directories in various manners.</source>
          <target state="translated">用于以各种方式创建目录的构建器。</target>
        </trans-unit>
        <trans-unit id="d9b7dd70756681f35180b19cd1bfebd1be340c71" translate="yes" xml:space="preserve">
          <source>A builtin-macro was defined more than once.</source>
          <target state="translated">一个内置的宏被定义了不止一次。</target>
        </trans-unit>
        <trans-unit id="3712794ff88bfb37526db3c27354e391cdfb3531" translate="yes" xml:space="preserve">
          <source>A by-value &lt;a href=&quot;../primitive.array&quot;&gt;array&lt;/a&gt; iterator.</source>
          <target state="translated">一个按值&lt;a href=&quot;../primitive.array&quot;&gt;数组&lt;/a&gt;迭代器。</target>
        </trans-unit>
        <trans-unit id="db1dde52635a5e1dfcc3c9c412ee03038fd5a1fd" translate="yes" xml:space="preserve">
          <source>A byte constant wasn't correctly ended.</source>
          <target state="translated">一个字节常量没有正确结束。</target>
        </trans-unit>
        <trans-unit id="358ac47a7f574535f0a6c2b6627900a1db482bcb" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;Drop::drop&lt;/code&gt; for that value, if this special &lt;code&gt;Drop&lt;/code&gt; trait is implemented for its type.</source>
          <target state="translated">如果为此类型实现了特殊的 &lt;code&gt;Drop&lt;/code&gt; 特性，则调用该值的 &lt;code&gt;Drop::drop&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f6bbc745c6c0811da9c03d5975cfda20a1ec075" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;park&lt;/code&gt; does not guarantee that the thread will remain parked forever, and callers should be prepared for this possibility.</source>
          <target state="translated">要在通话 &lt;code&gt;park&lt;/code&gt; 不保证该线程将永远保持停放，并应呼叫者这种可能性进行制备。</target>
        </trans-unit>
        <trans-unit id="310114efe1d071325aac9ee697835f3fab748547" translate="yes" xml:space="preserve">
          <source>A captured OS thread stack backtrace.</source>
          <target state="translated">捕获的操作系统线程栈回溯。</target>
        </trans-unit>
        <trans-unit id="068d1bfcec9a1ae7628a6bb97579dd58498f1145" translate="yes" xml:space="preserve">
          <source>A captured variable in a closure may not live long enough.</source>
          <target state="translated">封闭中捕获的变量可能寿命不够长。</target>
        </trans-unit>
        <trans-unit id="87031d3ddac7dc2da2592a12784d3310334c67dd" translate="yes" xml:space="preserve">
          <source>A cast between a thin and a fat pointer was attempted.</source>
          <target state="translated">在瘦子和胖子的指针之间尝试了一次投掷。</target>
        </trans-unit>
        <trans-unit id="fa8c8681d28baf8dc8f1366a76e05505996e07da" translate="yes" xml:space="preserve">
          <source>A cast to &lt;code&gt;char&lt;/code&gt; was attempted on a type other than &lt;code&gt;u8&lt;/code&gt;.</source>
          <target state="translated">尝试对 &lt;code&gt;u8&lt;/code&gt; 以外的类型进行强制转换为 &lt;code&gt;char&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d806d6a4232967c179bddb0726f09f0a0c1cae9" translate="yes" xml:space="preserve">
          <source>A cast to an unsized type was attempted.</source>
          <target state="translated">试图投向一个无尺寸的类型。</target>
        </trans-unit>
        <trans-unit id="8ca946f31b782b50520401ae5f6d2242f47dbf2a" translate="yes" xml:space="preserve">
          <source>A cell which can be written to only once.</source>
          <target state="translated">一个单元格只能被写入一次。</target>
        </trans-unit>
        <trans-unit id="7ab45f97583623706555b717305df511d6d6755b" translate="yes" xml:space="preserve">
          <source>A channel in programming has two halves: a transmitter and a receiver. The transmitter half is the upstream location where you put rubber ducks into the river, and the receiver half is where the rubber duck ends up downstream. One part of your code calls methods on the transmitter with the data you want to send, and another part checks the receiving end for arriving messages. A channel is said to be &lt;em&gt;closed&lt;/em&gt; if either the transmitter or receiver half is dropped.</source>
          <target state="translated">编程中的通道有两个部分：发送器和接收器。发射器的一半是在上游放置橡皮鸭的位置，接收器的一半是在下游橡皮鸭的位置。代码的一部分用要发送的数据调用发送器上的方法，另一部分检查接收端的到达消息。如果发射器或接收器的一半掉落，则称通道已&lt;em&gt;关闭&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="9b271c9cb4969ff9e8017b48dea5ee7ea287981f" translate="yes" xml:space="preserve">
          <source>A character literal wasn't ended with a quote.</source>
          <target state="translated">一个字的字面意思并没有用引号结束。</target>
        </trans-unit>
        <trans-unit id="730c231d230d4d65e9a1cdedca314d8b69b7866c" translate="yes" xml:space="preserve">
          <source>A character type.</source>
          <target state="translated">一个字符类型。</target>
        </trans-unit>
        <trans-unit id="195b8c50281f62fd27ad7158cd7ae79ac4f9afca" translate="yes" xml:space="preserve">
          <source>A classification of floating point numbers.</source>
          <target state="translated">浮点数的分类。</target>
        </trans-unit>
        <trans-unit id="dea8ae8b6b70c73b2cce436aaeecb02e010d0c2b" translate="yes" xml:space="preserve">
          <source>A clobber was surrounded by braces in the &lt;code&gt;llvm_asm&lt;/code&gt; macro.</source>
          <target state="translated">在 &lt;code&gt;llvm_asm&lt;/code&gt; 宏中，括号被括号包围。</target>
        </trans-unit>
        <trans-unit id="52397aa21f3cbabb1bcadcab29fd5a79bd3be6ee" translate="yes" xml:space="preserve">
          <source>A clone-on-write smart pointer.</source>
          <target state="translated">克隆写时的智能指针。</target>
        </trans-unit>
        <trans-unit id="17d70d4cf5c4adf5f0753809fb9cb729a2f8379d" translate="yes" xml:space="preserve">
          <source>A closure expression denotes a function that maps a list of parameters onto the expression that follows the parameters. Just like a &lt;a href=&quot;../statements#let-statements&quot;&gt;&lt;code&gt;let&lt;/code&gt; binding&lt;/a&gt;, the parameters are irrefutable &lt;a href=&quot;../patterns&quot;&gt;patterns&lt;/a&gt;, whose type annotation is optional and will be inferred from context if not given. Each closure expression has a unique, anonymous type.</source>
          <target state="translated">闭包表达式表示将参数列表映射到参数之后的表达式的函数。就像&lt;a href=&quot;../statements#let-statements&quot;&gt; &lt;code&gt;let&lt;/code&gt; 绑定一样&lt;/a&gt;，参数是不可辩驳的&lt;a href=&quot;../patterns&quot;&gt;模式&lt;/a&gt;，其类型注释是可选的，如果没有给出，将根据上下文进行推断。每个闭包表达式都有一个唯一的匿名类型。</target>
        </trans-unit>
        <trans-unit id="229f7ae12c2338583566d98b6347b250aaf7fe51" translate="yes" xml:space="preserve">
          <source>A closure has been used as &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">闭包已用作 &lt;code&gt;static&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9e518044a28e364a6d5caf649a49a37d36a9e44" translate="yes" xml:space="preserve">
          <source>A closure is &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; if it does not capture any values by unique immutable or mutable reference, and if all values it captures by copy or move are &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, respectively.</source>
          <target state="translated">闭包是&lt;a href=&quot;../special-types-and-traits#clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;，如果它不捕捉唯一不变或可变引用任何价值，如果它通过捕获复制或移动所有值都&lt;a href=&quot;../special-types-and-traits#clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;分别。</target>
        </trans-unit>
        <trans-unit id="f47eb76e99123d39021af1de1b77a6fbf1ed2931" translate="yes" xml:space="preserve">
          <source>A closure is &lt;a href=&quot;../special-types-and-traits#send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; if all variables captured by non-unique immutable reference are &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;, and all values captured by unique immutable or mutable reference, copy, or move are &lt;a href=&quot;../special-types-and-traits#send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果非唯一不可变引用捕获的所有变量均为&lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;，而唯一不可变或可变引用，复制或移动捕获的所有值均为，则闭包为&lt;a href=&quot;../special-types-and-traits#send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; 。&lt;/a&gt;&lt;a href=&quot;../special-types-and-traits#send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0d261d9dcf84a04b55a505f635cb5d6d0068277d" translate="yes" xml:space="preserve">
          <source>A closure is &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; if all captured variables are &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">闭包是&lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;，如果所有捕获的变量是&lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f3dcf856d438dee9833c1d37d61c6e01baf7766e" translate="yes" xml:space="preserve">
          <source>A closure or generator was constructed that references its own type.</source>
          <target state="translated">构造了一个引用自己类型的闭合或生成器。</target>
        </trans-unit>
        <trans-unit id="3bcd57420ec9a5b5481261d30eb81ca537f99421" translate="yes" xml:space="preserve">
          <source>A closure was used but didn't implement the expected trait.</source>
          <target state="translated">使用了封闭,但没有实现预期的性状。</target>
        </trans-unit>
        <trans-unit id="c9d5fcd074a946b081167d5c176a725de44ced3d" translate="yes" xml:space="preserve">
          <source>A closure which does not move out of any captured variables implements &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, indicating that it can be called by mutable reference.</source>
          <target state="translated">不移出任何捕获变量的闭包实现&lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt;，指示可以通过可变引用来调用它。</target>
        </trans-unit>
        <trans-unit id="cd4b51e9607f8ce4ec972f070cc5a727f780aa02" translate="yes" xml:space="preserve">
          <source>A closure which does not mutate or move out of any captured variables implements &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt;, indicating that it can be called by shared reference.</source>
          <target state="translated">不会改变或移出任何捕获变量的闭包实现&lt;a href=&quot;../../std/ops/trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt;，指示可以由共享引用调用它。</target>
        </trans-unit>
        <trans-unit id="e935c8f48fd175281f69484ea6d8e34c3df1f772" translate="yes" xml:space="preserve">
          <source>A coercion can only occur at certain coercion sites in a program; these are typically places where the desired type is explicit or can be derived by propagation from explicit types (without type inference). Possible coercion sites are:</source>
          <target state="translated">一个胁迫只能发生在程序中的某些胁迫点;这些地方通常是所需类型是显式的,或者可以通过从显式类型的传播(没有类型推理)来推导。可能的胁迫位点有:</target>
        </trans-unit>
        <trans-unit id="3d399a6fb5b1366dacbcbc3c485166cb44a8fe4f" translate="yes" xml:space="preserve">
          <source>A collection of methods that are required to format a message into a stream.</source>
          <target state="translated">将消息格式化为流的方法的集合。</target>
        </trans-unit>
        <trans-unit id="2a7f703e336c6bdb6cbae32714276165fd6dcc43" translate="yes" xml:space="preserve">
          <source>A common example is the &lt;code&gt;collect&lt;/code&gt; method on &lt;code&gt;Iterator&lt;/code&gt;. It has a generic type parameter with a &lt;code&gt;FromIterator&lt;/code&gt; bound, which for a &lt;code&gt;char&lt;/code&gt; iterator is implemented by &lt;code&gt;Vec&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; among others. Consider the following snippet that reverses the characters of a string:</source>
          <target state="translated">一个常见的示例是 &lt;code&gt;Iterator&lt;/code&gt; 上的 &lt;code&gt;collect&lt;/code&gt; 方法。它具有一个带有 &lt;code&gt;FromIterator&lt;/code&gt; 绑定的通用类型参数，对于一个 &lt;code&gt;char&lt;/code&gt; 迭代器，该参数由 &lt;code&gt;Vec&lt;/code&gt; 实现。和 &lt;code&gt;String&lt;/code&gt; 等实现。考虑下面的代码片段，它反转字符串的字符：</target>
        </trans-unit>
        <trans-unit id="e2236ceee783d907728a27d889b17b89679caa37" translate="yes" xml:space="preserve">
          <source>A common interface for a class of types.</source>
          <target state="translated">一类类型的通用接口。</target>
        </trans-unit>
        <trans-unit id="8baf44157a38997462218326dfa5b36c89567539" translate="yes" xml:space="preserve">
          <source>A common interface for a group of types.</source>
          <target state="translated">一组类型的通用接口。</target>
        </trans-unit>
        <trans-unit id="23bb5a3938b6b7101f14bfe5b204b2401bdf9250" translate="yes" xml:space="preserve">
          <source>A common mis-conception is to think that &quot;unicast link-local addresses start with &lt;code&gt;fe80::&lt;/code&gt;&quot;, but the &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt; actually defines a stricter format for these addresses:</source>
          <target state="translated">一个常见的误解是认为&amp;ldquo;单播链接本地地址以 &lt;code&gt;fe80::&lt;/code&gt; 开头&amp;rdquo;，但是&lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt; IETF RFC 4291&lt;/a&gt;实际上为这些地址定义了更严格的格式：</target>
        </trans-unit>
        <trans-unit id="4615ae2634801f990b77ad209e23e9d53e5c0d34" translate="yes" xml:space="preserve">
          <source>A common problem with using return values to indicate errors is that it is easy to ignore the return value, thus failing to handle the error. &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; is annotated with the &lt;code&gt;#[must_use]&lt;/code&gt; attribute, which will cause the compiler to issue a warning when a Result value is ignored. This makes &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; especially useful with functions that may encounter errors but don't otherwise return a useful value.</source>
          <target state="translated">使用返回值指示错误的一个常见问题是，很容易忽略返回值，从而无法处理错误。使用 &lt;code&gt;#[must_use]&lt;/code&gt; 属性注释&lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;，这将导致编译器在忽略Result值时发出警告。这使得&lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;对于可能遇到错误但不返回有用值的函数特别有用。</target>
        </trans-unit>
        <trans-unit id="9e6af95ab7d6f1c50d97f5f2eb1a6e3eebe549bf" translate="yes" xml:space="preserve">
          <source>A common trait for the ability to explicitly duplicate an object.</source>
          <target state="translated">显式复制对象的能力的常见特征。</target>
        </trans-unit>
        <trans-unit id="f3fcc76ff39756ffd2b4cb1d33e25cb209dbe4a4" translate="yes" xml:space="preserve">
          <source>A common use case for &lt;code&gt;spin_loop&lt;/code&gt; is implementing bounded optimistic spinning in a CAS loop in synchronization primitives. To avoid problems like priority inversion, it is strongly recommended that the spin loop is terminated after a finite amount of iterations and an appropriate blocking syscall is made.</source>
          <target state="translated">&lt;code&gt;spin_loop&lt;/code&gt; 的一个常见用例是在CAS循环中的同步原语中实现有界的乐观旋转。为避免优先级倒置之类的问题，强烈建议在有限次数的迭代后终止旋转循环，并进行适当的阻塞系统调用。</target>
        </trans-unit>
        <trans-unit id="0f3bf37cba543ca385f5031852ec32495e2e84e3" translate="yes" xml:space="preserve">
          <source>A common use case for &lt;code&gt;spin_loop_hint&lt;/code&gt; is implementing bounded optimistic spinning in a CAS loop in synchronization primitives. To avoid problems like priority inversion, it is strongly recommended that the spin loop is terminated after a finite amount of iterations and an appropriate blocking syscall is made.</source>
          <target state="translated">&lt;code&gt;spin_loop_hint&lt;/code&gt; 的一个常见用例是在同步原语中的CAS循环中实现有界乐观旋转。为避免优先级倒置之类的问题，强烈建议在有限次数的迭代后终止旋转循环，并进行适当的阻塞系统调用。</target>
        </trans-unit>
        <trans-unit id="3e2c1919c7a821f5f3bf3a38d0ef8acb4190a932" translate="yes" xml:space="preserve">
          <source>A common use for &lt;code&gt;format!&lt;/code&gt; is concatenation and interpolation of strings. The same convention is used with &lt;a href=&quot;macro.print&quot;&gt;&lt;code&gt;print!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt; macros, depending on the intended destination of the string.</source>
          <target state="translated">&lt;code&gt;format!&lt;/code&gt; 的常见用法！是字符串的串联和内插。&lt;a href=&quot;macro.print&quot;&gt; &lt;code&gt;print!&lt;/code&gt; &lt;/a&gt;使用相同的约定！而&lt;a href=&quot;macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt;宏，具体取决于字符串的预期目标。</target>
        </trans-unit>
        <trans-unit id="44fea0684e72cef1ddaf4be0010340215dffbec7" translate="yes" xml:space="preserve">
          <source>A common use of this feature is to poison shared resources when writing unsafe code, by checking &lt;code&gt;panicking&lt;/code&gt; when the &lt;code&gt;drop&lt;/code&gt; is called.</source>
          <target state="translated">这个特征的一个常见用途写不安全代码时，通过检查是毒药共享资源 &lt;code&gt;panicking&lt;/code&gt; 当 &lt;code&gt;drop&lt;/code&gt; 是在调用drop。</target>
        </trans-unit>
        <trans-unit id="3016e8bc4b1ae0cb5dbf3daaacd9d48f6d65eed5" translate="yes" xml:space="preserve">
          <source>A common way to test functionality is to compare the result of the code under test to the value you expect the code to return to make sure they&amp;rsquo;re equal. You could do this using the &lt;code&gt;assert!&lt;/code&gt; macro and passing it an expression using the &lt;code&gt;==&lt;/code&gt; operator. However, this is such a common test that the standard library provides a pair of macros&amp;mdash;&lt;code&gt;assert_eq!&lt;/code&gt; and &lt;code&gt;assert_ne!&lt;/code&gt;&amp;mdash;to perform this test more conveniently. These macros compare two arguments for equality or inequality, respectively. They&amp;rsquo;ll also print the two values if the assertion fails, which makes it easier to see &lt;em&gt;why&lt;/em&gt; the test failed; conversely, the &lt;code&gt;assert!&lt;/code&gt; macro only indicates that it got a &lt;code&gt;false&lt;/code&gt; value for the &lt;code&gt;==&lt;/code&gt; expression, not the values that lead to the &lt;code&gt;false&lt;/code&gt; value.</source>
          <target state="translated">测试功能的一种常用方法是将被测代码的结果与您希望代码返回的值进行比较，以确保它们相等。您可以使用 &lt;code&gt;assert!&lt;/code&gt; 来做到这一点！宏并使用 &lt;code&gt;==&lt;/code&gt; 运算符将其传递给表达式。但是，这是一种常见的测试，标准库提供了一对宏&amp;mdash; &lt;code&gt;assert_eq!&lt;/code&gt; 。和 &lt;code&gt;assert_ne!&lt;/code&gt; &amp;mdash;更方便地执行此测试。这些宏分别比较相等或不相等的两个参数。他们还将打印两个值，如果断言失败，这使得它更容易看到&lt;em&gt;为什么&lt;/em&gt;测试失败; 相反， &lt;code&gt;assert!&lt;/code&gt; 宏仅表明它有一个 &lt;code&gt;false&lt;/code&gt; &lt;code&gt;==&lt;/code&gt; 的值表达式，而不是导致 &lt;code&gt;false&lt;/code&gt; 的值值。</target>
        </trans-unit>
        <trans-unit id="6f72785cb8deaf70098be764432ad287d8764020" translate="yes" xml:space="preserve">
          <source>A common way to use &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; is in combination with &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;. Recall that &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; lets you have multiple owners of some data, but it only gives immutable access to that data. If you have an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; that holds a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, you can get a value that can have multiple owners &lt;em&gt;and&lt;/em&gt; that you can mutate!</source>
          <target state="translated">使用 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 常见方法是与 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 结合使用。回想一下， &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 可以让您拥有某些数据的多个所有者，但它仅提供对该数据的不变访问。如果您的 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 拥有 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; ，那么您可以获得一个可以具有多个所有者&lt;em&gt;并且&lt;/em&gt;可以变异的值！</target>
        </trans-unit>
        <trans-unit id="c3a2eb5105511775d59e5e4cd686eb5579136f33" translate="yes" xml:space="preserve">
          <source>A comparison like the one above, which ignores some fields of the struct, can be dangerous. It can easily lead to an unintended violation of the requirements for a partial equivalence relation. For example, if we kept the above implementation of &lt;code&gt;PartialEq&amp;lt;Book&amp;gt;&lt;/code&gt; for &lt;code&gt;BookFormat&lt;/code&gt; and added an implementation of &lt;code&gt;PartialEq&amp;lt;Book&amp;gt;&lt;/code&gt; for &lt;code&gt;Book&lt;/code&gt; (either via a &lt;code&gt;#[derive]&lt;/code&gt; or via the manual implementation from the first example) then the result would violate transitivity:</source>
          <target state="translated">像上面的比较之类的比较会忽略该结构的某些字段，因此可能很危险。这很容易导致意外违反部分等价关系的要求。例如，如果我们保持在上述实施 &lt;code&gt;PartialEq&amp;lt;Book&amp;gt;&lt;/code&gt; 为 &lt;code&gt;BookFormat&lt;/code&gt; 和加入的实施方案 &lt;code&gt;PartialEq&amp;lt;Book&amp;gt;&lt;/code&gt; 为 &lt;code&gt;Book&lt;/code&gt; （通过任一 &lt;code&gt;#[derive]&lt;/code&gt; 或通过从第一实施例的手工执行），那么结果将违反可传递性：</target>
        </trans-unit>
        <trans-unit id="1b20c9de094581b8f84861af4164c5552e60a2ee" translate="yes" xml:space="preserve">
          <source>A compile time error is never emitted when using this macro regardless of whether the environment variable is present or not.</source>
          <target state="translated">当使用这个宏时,无论环境变量是否存在,都不会发出编译时的错误。</target>
        </trans-unit>
        <trans-unit id="378954a8b28d0b17cfcc628e2457199a86abdd79" translate="yes" xml:space="preserve">
          <source>A compiler memory fence.</source>
          <target state="translated">一个编译器内存栅栏。</target>
        </trans-unit>
        <trans-unit id="592fedd9ba4ca1ae2681effb1b9b42a165b45c38" translate="yes" xml:space="preserve">
          <source>A compiler-only memory barrier.</source>
          <target state="translated">一个编译器专用的内存屏障。</target>
        </trans-unit>
        <trans-unit id="5af9d265d7cc350d6c8dd5eca2e52c0984df494d" translate="yes" xml:space="preserve">
          <source>A configuration option. It is true if the option is set and false if it is unset.</source>
          <target state="translated">一个配置选项。如果设置了该选项,则为真,如果未设置,则为假。</target>
        </trans-unit>
        <trans-unit id="3457f182555f50a2c7cffa76112cf04e013ed4c3" translate="yes" xml:space="preserve">
          <source>A consequence of the borrowing rules is that when you have an immutable value, you can&amp;rsquo;t borrow it mutably. For example, this code won&amp;rsquo;t compile:</source>
          <target state="translated">借用规则的结果是，当您拥有不变的价值时，就不能可变地借用它。例如，此代码将不会编译：</target>
        </trans-unit>
        <trans-unit id="82e92c5c9841d5d2d3e69bff0f6aeb9309a13f00" translate="yes" xml:space="preserve">
          <source>A constant item was initialized with something that is not a constant expression.</source>
          <target state="translated">一个常量项被初始化为非常量表达式的东西。</target>
        </trans-unit>
        <trans-unit id="5ce86a2e004403aa5ba6b72a885c67d143829985" translate="yes" xml:space="preserve">
          <source>A constant value failed to get evaluated.</source>
          <target state="translated">一个常量值没有得到评估。</target>
        </trans-unit>
        <trans-unit id="2574c153f328b1e202d9e64649cb65b6702dbcde" translate="yes" xml:space="preserve">
          <source>A contiguous growable array type with heap-allocated contents, written &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">具有堆分配内容的连续可增长数组类型，写为 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ceaa636b8440544799d1a505ee00079d04849fb0" translate="yes" xml:space="preserve">
          <source>A contiguous growable array type, written &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; but pronounced 'vector'.</source>
          <target state="translated">连续的可增长数组类型，写为 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 但发音为&amp;ldquo; vector&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="821a3f39751014be2886a42509e99ef71f4b3a2f" translate="yes" xml:space="preserve">
          <source>A control-flow expression was used inside a const context.</source>
          <target state="translated">在const上下文中使用了一个控制流表达式。</target>
        </trans-unit>
        <trans-unit id="0490b6e232133e0013be8f4fef9d50c9926445a5" translate="yes" xml:space="preserve">
          <source>A convenience function that bubbles an &lt;code&gt;io::Result&lt;/code&gt; to its caller:</source>
          <target state="translated">将 &lt;code&gt;io::Result&lt;/code&gt; 冒泡给调用者的便捷函数：</target>
        </trans-unit>
        <trans-unit id="16d79d851ab24be5a7dea27948897afa80e31902" translate="yes" xml:space="preserve">
          <source>A convenience impl that delegates to the impl for &lt;code&gt;&amp;amp;str&lt;/code&gt;</source>
          <target state="translated">一个方便的impl，它委派给 &lt;code&gt;&amp;amp;str&lt;/code&gt; 的impl</target>
        </trans-unit>
        <trans-unit id="35a7bd82b1e1370c217a40362b5ca9b11be11f9d" translate="yes" xml:space="preserve">
          <source>A convenience impl that delegates to the impl for &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">方便的impl，它委派给 &lt;code&gt;&amp;amp;str&lt;/code&gt; 的impl 。</target>
        </trans-unit>
        <trans-unit id="c5815609ea9bdc6c8447adfe133c418ba6a0e628" translate="yes" xml:space="preserve">
          <source>A correct implementation could look like:</source>
          <target state="translated">正确的实施方式可以是:</target>
        </trans-unit>
        <trans-unit id="0847e6a8b80cb99079b74075a954fd750b19a38b" translate="yes" xml:space="preserve">
          <source>A crate is somewhat analogous to an &lt;em&gt;assembly&lt;/em&gt; in the ECMA-335 CLI model, a &lt;em&gt;library&lt;/em&gt; in the SML/NJ Compilation Manager, a &lt;em&gt;unit&lt;/em&gt; in the Owens and Flatt module system, or a &lt;em&gt;configuration&lt;/em&gt; in Mesa.</source>
          <target state="translated">一个条板箱有点类似于ECMA-335 CLI模型中的&lt;em&gt;程序集&lt;/em&gt;，SML / NJ编译管理器中的&lt;em&gt;库&lt;/em&gt;，Owens和Flatt模块系统中的&lt;em&gt;单元&lt;/em&gt;或&lt;em&gt;配置&lt;/em&gt; Mesa中。</target>
        </trans-unit>
        <trans-unit id="6436f7757ac841fe0b93278e071a64e419b3a404" translate="yes" xml:space="preserve">
          <source>A crate needs a global available &quot;helper module&quot; to itself, but it doesn't want to expose the helper module as a public API. To accomplish this, the root of the crate's hierarchy would have a private module which then internally has a &quot;public API&quot;. Because the entire crate is a descendant of the root, then the entire local crate can access this private module through the second case.</source>
          <target state="translated">一个箱子需要一个全局可用的 &quot;帮助模块 &quot;给自己,但它不想把帮助模块作为一个公共API暴露出来。为了达到这个目的,箱子的层次结构的根部将有一个私有模块,然后内部有一个 &quot;公共API&quot;。因为整个箱子是根的子孙,那么整个本地箱子都可以通过第二种情况访问这个私有模块。</target>
        </trans-unit>
        <trans-unit id="bc65255cb2d6b61579af61c12db502f3b72ad815" translate="yes" xml:space="preserve">
          <source>A crate that contains a &lt;code&gt;main&lt;/code&gt;&lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; can be compiled to an executable. If a &lt;code&gt;main&lt;/code&gt; function is present, it must take no arguments, must not declare any &lt;a href=&quot;trait-bounds&quot;&gt;trait or lifetime bounds&lt;/a&gt;, must not have any &lt;a href=&quot;items/generics#where-clauses&quot;&gt;where clauses&lt;/a&gt;, and its return type must be one of the following:</source>
          <target state="translated">包含 &lt;code&gt;main&lt;/code&gt; &lt;a href=&quot;items/functions&quot;&gt;功能的&lt;/a&gt;板条箱可以编译为可执行文件。如果存在 &lt;code&gt;main&lt;/code&gt; 函数，则该函数不得带任何参数，不得声明任何&lt;a href=&quot;trait-bounds&quot;&gt;特征或生命周期边界&lt;/a&gt;，不得具有任何&lt;a href=&quot;items/generics#where-clauses&quot;&gt;where子句&lt;/a&gt;，并且其返回类型必须为以下之一：</target>
        </trans-unit>
        <trans-unit id="1dd52734851cf6f3cf436dc5839dcfddfdcaf815" translate="yes" xml:space="preserve">
          <source>A crate will group related functionality together in a scope so the functionality is easy to share between multiple projects. For example, the &lt;code&gt;rand&lt;/code&gt; crate we used in &lt;a href=&quot;ch02-00-guessing-game-tutorial#generating-a-random-number&quot;&gt;Chapter 2&lt;/a&gt; provides functionality that generates random numbers. We can use that functionality in our own projects by bringing the &lt;code&gt;rand&lt;/code&gt; crate into our project&amp;rsquo;s scope. All the functionality provided by the &lt;code&gt;rand&lt;/code&gt; crate is accessible through the crate&amp;rsquo;s name, &lt;code&gt;rand&lt;/code&gt;.</source>
          <target state="translated">板条箱会将范围内的相关功能分组在一起，因此该功能易于在多个项目之间共享。例如，我们在&lt;a href=&quot;ch02-00-guessing-game-tutorial#generating-a-random-number&quot;&gt;第2章中&lt;/a&gt;使用的 &lt;code&gt;rand&lt;/code&gt; crate 提供了生成随机数的功能。通过将 &lt;code&gt;rand&lt;/code&gt; Crate放入我们项目的范围，我们可以在自己的项目中使用该功能。 &lt;code&gt;rand&lt;/code&gt; 箱子提供的所有功能都可以通过箱子的名称 &lt;code&gt;rand&lt;/code&gt; 访问。</target>
        </trans-unit>
        <trans-unit id="9489488427833bc0214d8f4c5f5a907ee47ae129" translate="yes" xml:space="preserve">
          <source>A cross-crate opt-out trait was implemented on something which wasn't a struct or enum type.</source>
          <target state="translated">在非结构体或枚举类型的东西上实现了一个cross-crate opt-out特征。</target>
        </trans-unit>
        <trans-unit id="00851a5c172b45fa5d81433f76656b498876dd4d" translate="yes" xml:space="preserve">
          <source>A cross-crate opt-out trait was implemented on something which wasn't a struct or enum type. Erroneous code example:</source>
          <target state="translated">在非结构体或枚举类型的东西上实现了一个cross-crate opt-out特征。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="521073eb4a9d5dea34971bbf2d3b43472252d22c" translate="yes" xml:space="preserve">
          <source>A cursor over a &lt;code&gt;LinkedList&lt;/code&gt; with editing operations.</source>
          <target state="translated">将光标放在具有编辑操作的 &lt;code&gt;LinkedList&lt;/code&gt; 上。</target>
        </trans-unit>
        <trans-unit id="e765e383228431ae063a8d9a831d2b82107b6c73" translate="yes" xml:space="preserve">
          <source>A cursor over a &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;LinkedList&lt;/code&gt; 上的光标。</target>
        </trans-unit>
        <trans-unit id="36316fe5916fd156e2a88a749ac433147a8da4cc" translate="yes" xml:space="preserve">
          <source>A cycle between &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers will never be deallocated. For this reason, &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; is used to break cycles. For example, a tree could have strong &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers from children back to their parents.</source>
          <target state="translated">&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;指针之间的循环永远不会被释放。因此，&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;用于中断周期。例如，一棵树可能具有从父节点到子节点的强&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;指针，而从子节点到其父节点的&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;指针。</target>
        </trans-unit>
        <trans-unit id="3b90e3c2a1d2a35888ed9e0be0c1ef31680e920a" translate="yes" xml:space="preserve">
          <source>A cycle between &lt;code&gt;Arc&lt;/code&gt; pointers will never be deallocated. For this reason, &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; is used to break cycles. For example, a tree could have strong &lt;code&gt;Arc&lt;/code&gt; pointers from parent nodes to children, and &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers from children back to their parents.</source>
          <target state="translated">&lt;code&gt;Arc&lt;/code&gt; 指针之间的循环永远不会释放。因此，&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;用于中断周期。例如，一棵树可能具有从父节点到子节点的强 &lt;code&gt;Arc&lt;/code&gt; 指针，而从子节点到其父节点的&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;指针。</target>
        </trans-unit>
        <trans-unit id="cd0e6a515d806f28a3a9117a215e0567225d9f11" translate="yes" xml:space="preserve">
          <source>A data structure is in a temporarily invalid state when the thread panics.</source>
          <target state="translated">当线程恐慌时,数据结构处于暂时无效状态。</target>
        </trans-unit>
        <trans-unit id="590870896f27fcf4f2a0264dabbc0794e9042402" translate="yes" xml:space="preserve">
          <source>A default configuration can be generated using &lt;code&gt;Command::new(program)&lt;/code&gt;, where &lt;code&gt;program&lt;/code&gt; gives a path to the program to be executed. Additional builder methods allow the configuration to be changed (for example, by adding arguments) prior to spawning:</source>
          <target state="translated">可以使用 &lt;code&gt;Command::new(program)&lt;/code&gt; 生成默认配置，其中 &lt;code&gt;program&lt;/code&gt; 给出了要执行的程序的路径。其他生成器方法允许在生成之前更改配置（例如，通过添加参数）：</target>
        </trans-unit>
        <trans-unit id="cc1e47ebf18eca6629966fd3d1126236437b08eb" translate="yes" xml:space="preserve">
          <source>A definition of a method not in the implemented trait was given in a trait implementation.</source>
          <target state="translated">在一个特质实现中给出了一个不在实现的特质中的方法的定义。</target>
        </trans-unit>
        <trans-unit id="74bdee4c01f0e2a5b888cedf761fad306ec9d91d" translate="yes" xml:space="preserve">
          <source>A discriminant in an &lt;code&gt;enum&lt;/code&gt; not included in the type definition.</source>
          <target state="translated">类型定义中未包含的 &lt;code&gt;enum&lt;/code&gt; 的判别式。</target>
        </trans-unit>
        <trans-unit id="1d4413773858071be2cda9c035b93d8adb5ed9c4" translate="yes" xml:space="preserve">
          <source>A discriminant value is present more than once.</source>
          <target state="translated">一个判别值出现一次以上。</target>
        </trans-unit>
        <trans-unit id="e33398f8a1c82819cfc272eb4db0376550aceebc" translate="yes" xml:space="preserve">
          <source>A doc comment that is not attached to anything has been encountered.</source>
          <target state="translated">遇到了一个没有附加任何东西的文档注释。</target>
        </trans-unit>
        <trans-unit id="449c61354d124e018f4ac7cc6a32776bf259e4bc" translate="yes" xml:space="preserve">
          <source>A documentation comment that doesn't document anything was found.</source>
          <target state="translated">发现了一个没有记录任何东西的文档评论。</target>
        </trans-unit>
        <trans-unit id="b5da65d7d41e577505a8697b6d53146c919ad568" translate="yes" xml:space="preserve">
          <source>A double quote byte string (&lt;code&gt;b&quot;&lt;/code&gt;) was not terminated.</source>
          <target state="translated">双引号字节字符串（ &lt;code&gt;b&quot;&lt;/code&gt; ）没有终止。</target>
        </trans-unit>
        <trans-unit id="6c189219618ff090bbaf1c282c8ad43303eb7709" translate="yes" xml:space="preserve">
          <source>A double quote string (&lt;code&gt;&quot;&lt;/code&gt;) was not terminated.</source>
          <target state="translated">双引号字符串（ &lt;code&gt;&quot;&lt;/code&gt; ）未终止。</target>
        </trans-unit>
        <trans-unit id="844fc94f2ec6c20bbd8c3c61aa63bf0f8f4c60a0" translate="yes" xml:space="preserve">
          <source>A double-ended iterator with the direction inverted.</source>
          <target state="translated">一个方向倒置的双端迭代器。</target>
        </trans-unit>
        <trans-unit id="9e374237ea1be12ca52873f6b8cd4c6757ef72d7" translate="yes" xml:space="preserve">
          <source>A double-ended queue implemented with a growable ring buffer.</source>
          <target state="translated">用一个可增长的环形缓冲区实现的双端队列。</target>
        </trans-unit>
        <trans-unit id="28050b20d2fb7eccf5c8a8ecb22f1b2923430db5" translate="yes" xml:space="preserve">
          <source>A doubly-linked list with owned nodes.</source>
          <target state="translated">一个拥有节点的双链路列表。</target>
        </trans-unit>
        <trans-unit id="7fb38950784a1933e77430becd7b735f7149cba0" translate="yes" xml:space="preserve">
          <source>A draining iterator for &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 的排水迭代器。</target>
        </trans-unit>
        <trans-unit id="4c37906477f09b5f321b2effe6bce9b886812638" translate="yes" xml:space="preserve">
          <source>A draining iterator for &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 排放迭代器。</target>
        </trans-unit>
        <trans-unit id="429ad4a5f6fa96f2bca9279ba7532d1e6d671a36" translate="yes" xml:space="preserve">
          <source>A draining iterator over the elements of a &lt;code&gt;BinaryHeap&lt;/code&gt;.</source>
          <target state="translated">一个 &lt;code&gt;BinaryHeap&lt;/code&gt; 元素上的耗费迭代器。</target>
        </trans-unit>
        <trans-unit id="91b15bef979787193522a6fe820b65bca6b71b6d" translate="yes" xml:space="preserve">
          <source>A draining iterator over the elements of a &lt;code&gt;VecDeque&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;VecDeque&lt;/code&gt; 元素上的耗费迭代器。</target>
        </trans-unit>
        <trans-unit id="6e8fa0dd341d84cbc1afdb686f6037ff7ef3d24c" translate="yes" xml:space="preserve">
          <source>A draining iterator over the entries of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;HashMap&lt;/code&gt; 的条目上进行耗费精力的迭代器。</target>
        </trans-unit>
        <trans-unit id="3f3d65aa6b0bc2c1da1319190787588eadcf2d84" translate="yes" xml:space="preserve">
          <source>A draining iterator over the items of a &lt;code&gt;HashSet&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;HashSet&lt;/code&gt; 的项目上进行耗费精力的迭代器。</target>
        </trans-unit>
        <trans-unit id="d0414ecefaa3523675384470efb07b95159dba45" translate="yes" xml:space="preserve">
          <source>A draining, filtering iterator over the entries of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 条目上的排水过滤迭代器。</target>
        </trans-unit>
        <trans-unit id="bdb2903d11786dcb8b8844e91d87fb7f80657414" translate="yes" xml:space="preserve">
          <source>A draining, filtering iterator over the items of a &lt;code&gt;HashSet&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;HashSet&lt;/code&gt; 的项目上进行的排水过滤迭代器。</target>
        </trans-unit>
        <trans-unit id="c40d5a17630e0b8c5262cd5da85143e19cf981ab" translate="yes" xml:space="preserve">
          <source>A duration of zero time.</source>
          <target state="translated">持续时间为零。</target>
        </trans-unit>
        <trans-unit id="cc90bdb96c97b6e432d2ff036bf4b852213faf58" translate="yes" xml:space="preserve">
          <source>A dynamically sized type (DST) is a type without a statically known size or alignment.</source>
          <target state="translated">动态大小类型(DST)是一个没有静态已知大小或对齐方式的类型。</target>
        </trans-unit>
        <trans-unit id="211aeaeaf569d6a37ba4f9e761ab58dda09c15a6" translate="yes" xml:space="preserve">
          <source>A dynamically-sized view into a contiguous sequence, &lt;code&gt;[T]&lt;/code&gt;.</source>
          <target state="translated">进入连续序列 &lt;code&gt;[T]&lt;/code&gt; 的动态大小视图。</target>
        </trans-unit>
        <trans-unit id="c9b7bf32fab7bb231166bbede96c90271ed78811" translate="yes" xml:space="preserve">
          <source>A dynamically-sized view into a contiguous sequence, &lt;code&gt;[T]&lt;/code&gt;. Contiguous here means that elements are laid out so that every element is the same distance from its neighbors.</source>
          <target state="translated">到连续序列 &lt;code&gt;[T]&lt;/code&gt; 中的动态大小视图。这里的连续意味着元素的布局应使每个元素与其相邻元素之间的距离相同。</target>
        </trans-unit>
        <trans-unit id="31f05f23c58b03a01fb9e427108a188fcf6b07f3" translate="yes" xml:space="preserve">
          <source>A feature attribute named a feature that has been removed.</source>
          <target state="translated">命名为已被删除的特征属性。</target>
        </trans-unit>
        <trans-unit id="dd28c7fe46ecde36f6e0a91f768af6503a5d1816" translate="yes" xml:space="preserve">
          <source>A feature attribute named a feature that was disallowed in the compiler command line flags.</source>
          <target state="translated">一个特征属性命名了编译器命令行标志中不允许的特征。</target>
        </trans-unit>
        <trans-unit id="7d16601ad6554f548eab3701b5a36e77bca297da" translate="yes" xml:space="preserve">
          <source>A feature name is missing.</source>
          <target state="translated">缺少一个特征名称。</target>
        </trans-unit>
        <trans-unit id="80c1f2d8465e2f0474908b699c574231c3f93ea8" translate="yes" xml:space="preserve">
          <source>A fence 'A' which has (at least) &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; ordering semantics, synchronizes with a fence 'B' with (at least) &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; semantics, if and only if there exist operations X and Y, both operating on some atomic object 'M' such that A is sequenced before X, Y is synchronized before B and Y observes the change to M. This provides a happens-before dependence between A and B.</source>
          <target state="translated">具有（至少）&lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt;顺序语义的篱笆&amp;ldquo; A&amp;rdquo;与具有（至少）&amp;ldquo; &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;语义的篱笆&amp;ldquo; B&amp;rdquo;同步（当且仅当存在同时在某个原子对象&amp;ldquo; M&amp;rdquo;上运行的操作X和Y时）这样，A在X之前被排序，Y在B和Y观察到M的变化之前被同步。这提供了A和B之间的依赖之前发生的情况。</target>
        </trans-unit>
        <trans-unit id="55e68042fec783cba9aad8dce1b35e99ef85dbdf" translate="yes" xml:space="preserve">
          <source>A fence which has &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;SeqCst&lt;/code&gt;&lt;/a&gt; ordering, in addition to having both &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; semantics, participates in the global program order of the other &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;SeqCst&lt;/code&gt;&lt;/a&gt; operations and/or fences.</source>
          <target state="translated">除了具有&lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt;语义外，具有&lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;SeqCst&lt;/code&gt; &lt;/a&gt;顺序的围栅还参与其他&lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;SeqCst&lt;/code&gt; &lt;/a&gt;操作和/或围栅的全局程序顺序。</target>
        </trans-unit>
        <trans-unit id="1cb36d0ee361d78dbe2fa3dcfcac72e9a2dee2b5" translate="yes" xml:space="preserve">
          <source>A field access is a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt; referring to the location of that field. When the subexpression is &lt;a href=&quot;../expressions#mutability&quot;&gt;mutable&lt;/a&gt;, the field expression is also mutable.</source>
          <target state="translated">字段访问是指该字段位置的&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;位置表达式&lt;/a&gt;。当子表达式&lt;a href=&quot;../expressions#mutability&quot;&gt;可变时&lt;/a&gt;，字段表达式也是可变的。</target>
        </trans-unit>
        <trans-unit id="f7e446184b876f98fd13cf13bfdf4f57607ba15b" translate="yes" xml:space="preserve">
          <source>A file wasn't found for an out-of-line module.</source>
          <target state="translated">没有找到一个行外模块的文件。</target>
        </trans-unit>
        <trans-unit id="730142c15726a49fe7ebbd5c1ceae068d1e76798" translate="yes" xml:space="preserve">
          <source>A final reason Rust doesn&amp;rsquo;t allow us to index into a &lt;code&gt;String&lt;/code&gt; to get a character is that indexing operations are expected to always take constant time (O(1)). But it isn&amp;rsquo;t possible to guarantee that performance with a &lt;code&gt;String&lt;/code&gt;, because Rust would have to walk through the contents from the beginning to the index to determine how many valid characters there were.</source>
          <target state="translated">Rust不允许我们索引到 &lt;code&gt;String&lt;/code&gt; 中以获取字符的最后一个原因是，索引操作通常需要恒定的时间（O（1））。但是用 &lt;code&gt;String&lt;/code&gt; 不能保证性能，因为Rust必须从头到尾遍历所有内容以确定有多少个有效字符。</target>
        </trans-unit>
        <trans-unit id="0106151a82df636bbbb97134363a6aef4336540d" translate="yes" xml:space="preserve">
          <source>A finite heterogeneous sequence, &lt;code&gt;(T, U, ..)&lt;/code&gt;.</source>
          <target state="translated">有限异构序列 &lt;code&gt;(T, U, ..)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="405c2e4c1352a9dd275d0dcf43af6465cfa06fc2" translate="yes" xml:space="preserve">
          <source>A fixed-size array, denoted &lt;code&gt;[T; N]&lt;/code&gt;, for the element type, &lt;code&gt;T&lt;/code&gt;, and the non-negative compile-time constant size, &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">固定大小的数组，表示为 &lt;code&gt;[T; N]&lt;/code&gt; ，元素类型， &lt;code&gt;T&lt;/code&gt; ，和非负编译时间常数的大小， &lt;code&gt;N&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="01e8ae155635ffa00df108a976552eb0550b9e9b" translate="yes" xml:space="preserve">
          <source>A for loop is equivalent to the following block expression.</source>
          <target state="translated">for循环相当于下面的块状表达式。</target>
        </trans-unit>
        <trans-unit id="b694a59d19302341ecbd00f4fa0cb3b358a2f81b" translate="yes" xml:space="preserve">
          <source>A format string is required to use all of its arguments, otherwise it is a compile-time error. You may refer to the same argument more than once in the format string.</source>
          <target state="translated">格式字符串必须使用所有的参数,否则会出现编译时错误。你可以在格式字符串中多次引用同一个参数。</target>
        </trans-unit>
        <trans-unit id="01b7129399ded6b05b30578334c78e0c28495f39" translate="yes" xml:space="preserve">
          <source>A function annotated with the &lt;code&gt;test&lt;/code&gt; attribute can also be annotated with the &lt;code&gt;ignore&lt;/code&gt; attribute. The &lt;em&gt;&lt;code&gt;ignore&lt;/code&gt; attribute&lt;/em&gt; tells the test harness to not execute that function as a test. It will still be compiled when in test mode.</source>
          <target state="translated">用 &lt;code&gt;test&lt;/code&gt; 属性注释的函数也可以用 &lt;code&gt;ignore&lt;/code&gt; 属性注释。该&lt;em&gt; &lt;code&gt;ignore&lt;/code&gt; 属性&lt;/em&gt;告诉测试工具不执行该功能测试。在测试模式下，仍将编译它。</target>
        </trans-unit>
        <trans-unit id="05308286e6d20f1bc15a1d74d19f5246b35ba29f" translate="yes" xml:space="preserve">
          <source>A function annotated with the &lt;code&gt;test&lt;/code&gt; attribute that returns &lt;code&gt;()&lt;/code&gt; can also be annotated with the &lt;code&gt;should_panic&lt;/code&gt; attribute. The &lt;em&gt;&lt;code&gt;should_panic&lt;/code&gt; attribute&lt;/em&gt; makes the test only pass if it actually panics.</source>
          <target state="translated">返回值 &lt;code&gt;()&lt;/code&gt; 的带有 &lt;code&gt;test&lt;/code&gt; 属性的函数也可以带有 &lt;code&gt;should_panic&lt;/code&gt; 属性。该&lt;em&gt; &lt;code&gt;should_panic&lt;/code&gt; &lt;/em&gt;&lt;em&gt;属性&lt;/em&gt;使得测试题库，如果它实际上是恐慌。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d9fe742a8fa7d8036e041c35d1e5b1052fe5c884" translate="yes" xml:space="preserve">
          <source>A function call isn't allowed in the const's initialization expression because the expression's value must be known at compile-time. Erroneous code example:</source>
          <target state="translated">const的初始化表达式中不允许调用函数,因为表达式的值必须在编译时已知。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="cdbab3b7a45160aa6bbfe85128d0bf7bac272328" translate="yes" xml:space="preserve">
          <source>A function declared in an extern block is implicitly &lt;code&gt;unsafe&lt;/code&gt;. When coerced to a function pointer, a function declared in an extern block has type &lt;code&gt;unsafe extern &quot;abi&quot; for&amp;lt;'l1, ..., 'lm&amp;gt; fn(A1, ..., An) -&amp;gt; R&lt;/code&gt;, where &lt;code&gt;'l1&lt;/code&gt;, ... &lt;code&gt;'lm&lt;/code&gt; are its lifetime parameters, &lt;code&gt;A1&lt;/code&gt;, ..., &lt;code&gt;An&lt;/code&gt; are the declared types of its parameters and &lt;code&gt;R&lt;/code&gt; is the declared return type.</source>
          <target state="translated">在extern块中声明的函数是隐式 &lt;code&gt;unsafe&lt;/code&gt; 。当强制为函数指针时，在extern块中声明的函数的类型为 &lt;code&gt;unsafe extern &quot;abi&quot; for&amp;lt;'l1, ..., 'lm&amp;gt; fn(A1, ..., An) -&amp;gt; R&lt;/code&gt; ，其中 &lt;code&gt;'l1&lt;/code&gt; ，... &lt;code&gt;'lm&lt;/code&gt; 是其生命周期参数， &lt;code&gt;A1&lt;/code&gt; ，...， &lt;code&gt;An&lt;/code&gt; 是其参数的声明类型， &lt;code&gt;R&lt;/code&gt; 是声明的返回类型。</target>
        </trans-unit>
        <trans-unit id="d0692343f061c0cd9d5ae6d4139b26c55c59ad9f" translate="yes" xml:space="preserve">
          <source>A function is using &lt;code&gt;continue&lt;/code&gt; keyword incorrectly.</source>
          <target state="translated">一个函数错误地使用了 &lt;code&gt;continue&lt;/code&gt; 关键字。</target>
        </trans-unit>
        <trans-unit id="0055fb8a733d1b0d5afb4ae44802bb8e5a0c86da" translate="yes" xml:space="preserve">
          <source>A function or function pointer.</source>
          <target state="translated">一个函数或函数指针。</target>
        </trans-unit>
        <trans-unit id="b5bfe20067693f41e9be24910b3f1d1c865c4b39" translate="yes" xml:space="preserve">
          <source>A function signature must declare the number and type of parameters the function has. Macros, on the other hand, can take a variable number of parameters: we can call &lt;code&gt;println!(&quot;hello&quot;)&lt;/code&gt; with one argument or &lt;code&gt;println!(&quot;hello {}&quot;, name)&lt;/code&gt; with two arguments. Also, macros are expanded before the compiler interprets the meaning of the code, so a macro can, for example, implement a trait on a given type. A function can&amp;rsquo;t, because it gets called at runtime and a trait needs to be implemented at compile time.</source>
          <target state="translated">函数签名必须声明函数具有的参数的数量和类型。另一方面，宏可以使用可变数量的参数：我们可以使用一个参数调用 &lt;code&gt;println!(&quot;hello&quot;)&lt;/code&gt; 或使用两个参数调用 &lt;code&gt;println!(&quot;hello {}&quot;, name)&lt;/code&gt; 。同样，宏在编译器解释代码含义之前就已展开，因此，宏可以例如对给定类型实现特征。函数不能，因为它在运行时被调用，并且特征需要在编译时实现。</target>
        </trans-unit>
        <trans-unit id="cfea53bdada8b3687c10319a4dd10194cef976b7" translate="yes" xml:space="preserve">
          <source>A function that has a parameter or returns only numbers between 1 and 100 could then declare in its signature that it takes or returns a &lt;code&gt;Guess&lt;/code&gt; rather than an &lt;code&gt;i32&lt;/code&gt; and wouldn&amp;rsquo;t need to do any additional checks in its body.</source>
          <target state="translated">具有参数或仅返回1到100之间的数字的函数可以在其签名中声明它采用或返回 &lt;code&gt;Guess&lt;/code&gt; 而不是 &lt;code&gt;i32&lt;/code&gt; ,并且不需要在其主体中进行任何其他检查。</target>
        </trans-unit>
        <trans-unit id="330c21e7bd84509b137caeeff4bed7a7da24e5b7" translate="yes" xml:space="preserve">
          <source>A function that is opaque to the optimizer, to allow benchmarks to pretend to use outputs to assist in avoiding dead-code elimination.</source>
          <target state="translated">一个对优化器不透明的函数,以允许基准假装使用输出来协助避免死码消除。</target>
        </trans-unit>
        <trans-unit id="d2ed9af48e681bbf5a9216d3deb00de57795222b" translate="yes" xml:space="preserve">
          <source>A function with the &lt;code&gt;start&lt;/code&gt; attribute was declared with type parameters.</source>
          <target state="translated">与A功能 &lt;code&gt;start&lt;/code&gt; 属性声明与类型参数。</target>
        </trans-unit>
        <trans-unit id="cc716e4e83b4efb34e4101d17ccb62e4b2b1eb26" translate="yes" xml:space="preserve">
          <source>A fundamental trait is one where adding an impl of it for an existing type is a breaking change. The &lt;code&gt;Fn&lt;/code&gt; traits and &lt;code&gt;Sized&lt;/code&gt; are fundamental.</source>
          <target state="translated">一种基本特征是在现有类型中添加它的隐含意义是一项重大变化。该 &lt;code&gt;Fn&lt;/code&gt; 特点和 &lt;code&gt;Sized&lt;/code&gt; 是根本。</target>
        </trans-unit>
        <trans-unit id="0649f34bf1c96947359554a4e3b1fb6bd7f77d90" translate="yes" xml:space="preserve">
          <source>A fundamental type constructor is a type where implementing a &lt;a href=&quot;#blanket-implementation&quot;&gt;blanket implementation&lt;/a&gt; over it is a breaking change. &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;&amp;amp;mut&lt;/code&gt;, &lt;code&gt;Box&lt;/code&gt;, and &lt;code&gt;Pin&lt;/code&gt; are fundamental.</source>
          <target state="translated">基本类型构造函数是一种类型，在该类型上对其进行&lt;a href=&quot;#blanket-implementation&quot;&gt;总体实现&lt;/a&gt;是一项重大更改。 &lt;code&gt;&amp;amp;&lt;/code&gt; ， &lt;code&gt;&amp;amp;mut&lt;/code&gt; ， &lt;code&gt;Box&lt;/code&gt; 和 &lt;code&gt;Pin&lt;/code&gt; 是基础。</target>
        </trans-unit>
        <trans-unit id="b104136e74bd26ea4949e609270e7bafb60abae9" translate="yes" xml:space="preserve">
          <source>A future is a value that may not have finished computing yet. This kind of &quot;asynchronous value&quot; makes it possible for a thread to continue doing useful work while it waits for the value to become available.</source>
          <target state="translated">未来是一个可能还没有完成计算的值。这种 &quot;异步值 &quot;使得一个线程在等待值变得可用的时候可以继续做有用的工作。</target>
        </trans-unit>
        <trans-unit id="7c377e6c372ce66665ebea21944588366ee85648" translate="yes" xml:space="preserve">
          <source>A future represents an asynchronous computation.</source>
          <target state="translated">一个未来代表一个异步计算。</target>
        </trans-unit>
        <trans-unit id="c1da397a075afa74abc70c7bb33c6bfaa50fd933" translate="yes" xml:space="preserve">
          <source>A generalization of &lt;code&gt;Clone&lt;/code&gt; to borrowed data.</source>
          <target state="translated">将 &lt;code&gt;Clone&lt;/code&gt; 推广到借用数据。</target>
        </trans-unit>
        <trans-unit id="851d3775359dee45f6fc12b7c593dac300677e98" translate="yes" xml:space="preserve">
          <source>A generic function must be treated similarly:</source>
          <target state="translated">一个通用函数必须得到类似的处理。</target>
        </trans-unit>
        <trans-unit id="47dc8336e1d401035013095c768eec4aaa7de80d" translate="yes" xml:space="preserve">
          <source>A generic type was described using parentheses rather than angle brackets.</source>
          <target state="translated">使用括号而不是角括号来描述一个通用类型。</target>
        </trans-unit>
        <trans-unit id="b9e2cdc9d185c52c49734ce26b1038e50519630f" translate="yes" xml:space="preserve">
          <source>A generic type was described using parentheses rather than angle brackets. For example:</source>
          <target state="translated">使用括号而不是角括号来描述一个通用类型。例如:</target>
        </trans-unit>
        <trans-unit id="d667559155454841982582189ab274f14a49b2bf" translate="yes" xml:space="preserve">
          <source>A generic type where one or more associated types have specific assignments (e.g., &lt;code&gt;Iterator&amp;lt;Item=T&amp;gt;&lt;/code&gt;)</source>
          <target state="translated">一种通用类型，其中一个或多个关联类型具有特定分配（例如， &lt;code&gt;Iterator&amp;lt;Item=T&amp;gt;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="6f0496f55807a095b66d7d51e944864622ad78d2" translate="yes" xml:space="preserve">
          <source>A ghastly note 👻👻👻</source>
          <target state="translated">惨烈的音符&quot;■▄▄■▓。</target>
        </trans-unit>
        <trans-unit id="91fcac820244ae988bc857941377bad5a84fac8d" translate="yes" xml:space="preserve">
          <source>A given matcher M maps to three sets: FIRST(M), LAST(M) and FOLLOW(M).</source>
          <target state="translated">一个给定的匹配器M映射到三个集合。FIRST(M)、LAST(M)和FOLLOW(M)。</target>
        </trans-unit>
        <trans-unit id="ce503e49f8d95cbc61a21e14a3b1dd613e9d99ae" translate="yes" xml:space="preserve">
          <source>A great example of a situation where this technique is useful is with operator overloading. &lt;em&gt;Operator overloading&lt;/em&gt; is customizing the behavior of an operator (such as &lt;code&gt;+&lt;/code&gt;) in particular situations.</source>
          <target state="translated">这种技术很有用的情况的一个很好的例子是操作符重载。&lt;em&gt;运算符重载&lt;/em&gt;是在特定情况下自定义运算符的行为（例如 &lt;code&gt;+&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="77b606312f70d0e0e8a4e81eb457af73b41943c1" translate="yes" xml:space="preserve">
          <source>A guard for unsafe functions that cannot ever be executed if &lt;code&gt;T&lt;/code&gt; does not permit zero-initialization: This will statically either panic, or do nothing.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 不允许零初始化，则永远无法执行的不安全功能的防护措施：这将静态或紧急或不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="73d1fa93ccd1713ed23cb21dd7e4493abed0a332" translate="yes" xml:space="preserve">
          <source>A guard for unsafe functions that cannot ever be executed if &lt;code&gt;T&lt;/code&gt; has invalid bit patterns: This will statically either panic, or do nothing.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 具有无效的位模式，则永远无法执行的不安全功能的防护措施：这将静态地导致紧急情况或不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="e24815403ad3a79092fe51890734de71f5057ede" translate="yes" xml:space="preserve">
          <source>A guard for unsafe functions that cannot ever be executed if &lt;code&gt;T&lt;/code&gt; is uninhabited: This will statically either panic, or do nothing.</source>
          <target state="translated">防范不安全的功能的防护措施，如果无人居住的 &lt;code&gt;T&lt;/code&gt; 永远无法执行：这将静态地引起恐慌，或者什么都不做。</target>
        </trans-unit>
        <trans-unit id="7a319cd7f43cac10207753e127b6908e7ad723f6" translate="yes" xml:space="preserve">
          <source>A handle to a child process's standard input (stdin).</source>
          <target state="translated">子进程的标准输入(stdin)的句柄。</target>
        </trans-unit>
        <trans-unit id="1c0c017d7e2d5d79869d31d54d7aed18a0e39b40" translate="yes" xml:space="preserve">
          <source>A handle to a child process's standard output (stdout).</source>
          <target state="translated">子进程的标准输出(stdout)的句柄。</target>
        </trans-unit>
        <trans-unit id="36463654df6f05a2c5f7eb7e4b2efec9b5402d6f" translate="yes" xml:space="preserve">
          <source>A handle to a child process's stderr.</source>
          <target state="translated">子进程stderr的句柄。</target>
        </trans-unit>
        <trans-unit id="539b8b33fb86eae0a19eb8338bbb41567108f8bd" translate="yes" xml:space="preserve">
          <source>A handle to a thread.</source>
          <target state="translated">一根线的手柄。</target>
        </trans-unit>
        <trans-unit id="e4354965858e59daba47e025f6bf432587785439" translate="yes" xml:space="preserve">
          <source>A handle to the global standard output stream of the current process.</source>
          <target state="translated">当前进程的全局标准输出流的句柄。</target>
        </trans-unit>
        <trans-unit id="4e5458b43a1ef2ac995209fb2fb9a0f1f086d8ff" translate="yes" xml:space="preserve">
          <source>A handle to the standard error stream of a process.</source>
          <target state="translated">过程的标准误差流的句柄。</target>
        </trans-unit>
        <trans-unit id="c04e6d93f5332bb8558883edf3c0666a1ead6820" translate="yes" xml:space="preserve">
          <source>A handle to the standard input stream of a process.</source>
          <target state="translated">过程的标准输入流的句柄。</target>
        </trans-unit>
        <trans-unit id="52f29960ee00cd31852f436ce3c064a63d21c4a9" translate="yes" xml:space="preserve">
          <source>A hash map implemented with linear probing and Robin Hood bucket stealing.</source>
          <target state="translated">用线性探测和罗宾汉桶窃取实现的哈希图。</target>
        </trans-unit>
        <trans-unit id="1b24fb3ba32189304beb3027b487b7bde1af7301" translate="yes" xml:space="preserve">
          <source>A hash map implemented with quadratic probing and SIMD lookup.</source>
          <target state="translated">用二次探测和SIMD查找实现的哈希图。</target>
        </trans-unit>
        <trans-unit id="3236fb9d674df64208b5e1cf2d78d481f577b4f2" translate="yes" xml:space="preserve">
          <source>A hash set implemented as a &lt;code&gt;HashMap&lt;/code&gt; where the value is &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">实现为 &lt;code&gt;HashMap&lt;/code&gt; 的哈希集，其中值为 &lt;code&gt;()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4944fd02934cfc33b70591237170d7c0599ffebd" translate="yes" xml:space="preserve">
          <source>A hashable type.</source>
          <target state="translated">一个可哈希类型。</target>
        </trans-unit>
        <trans-unit id="4d0ef9738cd0ca2c9edcc6b3b923fd916c2b5807" translate="yes" xml:space="preserve">
          <source>A helper struct for reverse ordering.</source>
          <target state="translated">一个反向排序的辅助结构。</target>
        </trans-unit>
        <trans-unit id="2fcfddbae21727b9845f52dbf5c24515e281ef8f" translate="yes" xml:space="preserve">
          <source>A helper trait used for indexing operations.</source>
          <target state="translated">一个用于索引操作的辅助性状。</target>
        </trans-unit>
        <trans-unit id="29862de09ef195f3021bf8c1026b55bc84123b69" translate="yes" xml:space="preserve">
          <source>A incorrectly formatted &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; will produce an error.</source>
          <target state="translated">格式错误的&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt;将产生错误。</target>
        </trans-unit>
        <trans-unit id="2e3f1a456a73954f3da04455c2ebc9a53acd9daf" translate="yes" xml:space="preserve">
          <source>A lang item was redefined.</source>
          <target state="translated">重新定义了一个lang项。</target>
        </trans-unit>
        <trans-unit id="6ffd27d3b6539a3465361b45b3e5461748a1b187" translate="yes" xml:space="preserve">
          <source>A large number of the structures provided by &lt;code&gt;std::io&lt;/code&gt; are for various ways of iterating over I/O. For example, &lt;a href=&quot;struct.lines&quot;&gt;&lt;code&gt;Lines&lt;/code&gt;&lt;/a&gt; is used to split over lines:</source>
          <target state="translated">&lt;code&gt;std::io&lt;/code&gt; 提供的大量结构用于通过I / O进行迭代的各种方式。例如，&amp;ldquo; &lt;a href=&quot;struct.lines&quot;&gt; &lt;code&gt;Lines&lt;/code&gt; &lt;/a&gt;用于分割行：</target>
        </trans-unit>
        <trans-unit id="662b6a3ff994171dfffca1e061e7e8ce70b26c02" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the difference of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="translated">一个懒惰的迭代器，它产生 &lt;code&gt;BTreeSet&lt;/code&gt; 的差值中的元素。</target>
        </trans-unit>
        <trans-unit id="78a980f05e3a46c3d69eb02390416d427839b9ce" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the difference of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="translated">一个延迟迭代器，它产生 &lt;code&gt;HashSet&lt;/code&gt; 的差值中的元素。</target>
        </trans-unit>
        <trans-unit id="b8f2ea928876732f6cdd8b20aeb46e1a07becd11" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the intersection of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="translated">一个懒惰的迭代器，它在 &lt;code&gt;BTreeSet&lt;/code&gt; 的交集中生成元素。</target>
        </trans-unit>
        <trans-unit id="298c27c033e43f06428f6ee3aa3dd406f79bfc1d" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the intersection of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="translated">一个在 &lt;code&gt;HashSet&lt;/code&gt; 的交集中生成元素的惰性迭代器。</target>
        </trans-unit>
        <trans-unit id="5e5f0a0d812adca265e03240d1f5f96e6f3c302c" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the symmetric difference of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="translated">一个延迟迭代器，它产生 &lt;code&gt;BTreeSet&lt;/code&gt; 的对称差中的元素。</target>
        </trans-unit>
        <trans-unit id="5248d39b20b8a278703de3ef71e840882448f153" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the symmetric difference of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="translated">一个延迟迭代器，它产生 &lt;code&gt;HashSet&lt;/code&gt; 对称差中的元素。</target>
        </trans-unit>
        <trans-unit id="0f9f2f9fdddb7747ea07bd3f3640c23d49782e5c" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the union of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="translated">一个惰性迭代器，它在 &lt;code&gt;BTreeSet&lt;/code&gt; 的并集中生成元素。</target>
        </trans-unit>
        <trans-unit id="fc9bf6d7c1e4850a63411aee9c08fbc8782aa61a" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the union of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="translated">一个在 &lt;code&gt;HashSet&lt;/code&gt; 的并集中生成元素的惰性迭代器。</target>
        </trans-unit>
        <trans-unit id="32415c91edd2506ae578a648363d87b8a79c9954" translate="yes" xml:space="preserve">
          <source>A library developer needs to expose functionality to crates which link against their library. As a consequence of the first case, this means that anything which is usable externally must be &lt;code&gt;pub&lt;/code&gt; from the root down to the destination item. Any private item in the chain will disallow external accesses.</source>
          <target state="translated">库开发人员需要向与库链接的板条箱提供功能。作为第一种情况的结果，这意味着必须从外部使用任何东西。 &lt;code&gt;pub&lt;/code&gt; 从根向下到目标项。链中的任何私人物品都将禁止外部访问。</target>
        </trans-unit>
        <trans-unit id="6ffc7aa510e5357070634b59c577ca85e2c2292b" translate="yes" xml:space="preserve">
          <source>A lifetime appears only in an associated-type binding, and not in the input types to the trait.</source>
          <target state="translated">终身只出现在关联类型绑定中,而不出现在性状的输入类型中。</target>
        </trans-unit>
        <trans-unit id="15786eaf619ace068790ae58d796d7da4d047a8c" translate="yes" xml:space="preserve">
          <source>A lifetime bound on a trait implementation was captured at an incorrect place.</source>
          <target state="translated">在错误的地方捕获了一个特质实现的寿命约束。</target>
        </trans-unit>
        <trans-unit id="7c38295bdcc0eafcba2929a676ec6ceb8e9304c9" translate="yes" xml:space="preserve">
          <source>A lifetime bound was not satisfied.</source>
          <target state="translated">一辈子的约束都没有满足。</target>
        </trans-unit>
        <trans-unit id="f5eb99d9ba1d633f5bab932159c4263f91c6e225" translate="yes" xml:space="preserve">
          <source>A lifetime cannot be determined in the given situation.</source>
          <target state="translated">在给定的情况下无法确定一生。</target>
        </trans-unit>
        <trans-unit id="f5cad79ba7fd3784fc14fc3f6b2c2d3527062c63" translate="yes" xml:space="preserve">
          <source>A lifetime didn't match what was expected.</source>
          <target state="translated">一辈子都没有符合预期。</target>
        </trans-unit>
        <trans-unit id="f2036255cc30a38458aebc41a1b7522c2030656d" translate="yes" xml:space="preserve">
          <source>A lifetime is only present in an associated-type binding, and not in the input types to the trait.</source>
          <target state="translated">终身只存在于关联类型绑定中,而不存在于性状的输入类型中。</target>
        </trans-unit>
        <trans-unit id="7b0bc06cbbd42c2c42f3c7edb056daf04c8c1022" translate="yes" xml:space="preserve">
          <source>A lifetime name cannot be declared more than once in the same scope. For example:</source>
          <target state="translated">终身名不能在同一个作用域中声明多于一次。例如:</target>
        </trans-unit>
        <trans-unit id="315c1653fb8738d323beeedab26038fcdebdd0a1" translate="yes" xml:space="preserve">
          <source>A lifetime name is shadowing another lifetime name.</source>
          <target state="translated">一辈子的名字是影子另一个一辈子的名字。</target>
        </trans-unit>
        <trans-unit id="24a3a2bd418c09a4c4c2d74fd258bdb9f00cd151" translate="yes" xml:space="preserve">
          <source>A lifetime name is shadowing another lifetime name. Erroneous code example:</source>
          <target state="translated">一个终身名在影子另一个终身名。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="60dd9352a1988e94c38ce60166a9c885adb54457" translate="yes" xml:space="preserve">
          <source>A lifetime was declared more than once in the same scope.</source>
          <target state="translated">在同一个作用域中,一个寿命被声明了不止一次。</target>
        </trans-unit>
        <trans-unit id="6c742ea21e8d68de6fe9c8cd053579ea9357b0ab" translate="yes" xml:space="preserve">
          <source>A link name was given with an empty name.</source>
          <target state="translated">给了一个空名的链接名。</target>
        </trans-unit>
        <trans-unit id="e76bb7dad8b82c5bd8c5e995749d2ddcac1434e4" translate="yes" xml:space="preserve">
          <source>A link name was given with an empty name. Erroneous code example:</source>
          <target state="translated">给出了一个空名的链接名。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="7aff8ae0fa99ab18b982ebf4bf49db472c773b53" translate="yes" xml:space="preserve">
          <source>A link was used without a name parameter.</source>
          <target state="translated">使用了一个没有名称参数的链接。</target>
        </trans-unit>
        <trans-unit id="916890e2e829b39ca74b6c85b7ab19a70dff37fc" translate="yes" xml:space="preserve">
          <source>A link was used without a name parameter. Erroneous code example:</source>
          <target state="translated">使用了一个没有名称参数的链接。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="ac64cfd6177747480c1f0a80dd27bc3c2253949c" translate="yes" xml:space="preserve">
          <source>A lint check attribute was overruled by a &lt;code&gt;forbid&lt;/code&gt; directive set as an attribute on an enclosing scope, or on the command line with the &lt;code&gt;-F&lt;/code&gt; option.</source>
          <target state="translated">棉签检查属性被 &lt;code&gt;forbid&lt;/code&gt; 指令设置为覆盖范围内或命令行上带有属性的禁止指令设置 &lt;code&gt;-F&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="4ec2e82a43ec2456c074c084d9bde606ea9ab3b3" translate="yes" xml:space="preserve">
          <source>A lint check names a potentially undesirable coding pattern, such as unreachable code or omitted documentation. The lint attributes &lt;code&gt;allow&lt;/code&gt;, &lt;code&gt;warn&lt;/code&gt;, &lt;code&gt;deny&lt;/code&gt;, and &lt;code&gt;forbid&lt;/code&gt; use the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListPaths&lt;/em&gt;&lt;/a&gt; syntax to specify a list of lint names to change the lint level for the entity to which the attribute applies.</source>
          <target state="translated">棉绒检查会指出潜在的不良编码模式，例如无法访问的代码或省略的文档。lint属性 &lt;code&gt;allow&lt;/code&gt; ， &lt;code&gt;warn&lt;/code&gt; ， &lt;code&gt;deny&lt;/code&gt; 和 &lt;code&gt;forbid&lt;/code&gt; 使用&lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListPaths&lt;/em&gt;&lt;/a&gt;语法来指定一个lint名称列表，以更改该属性所应用实体的lint级别。</target>
        </trans-unit>
        <trans-unit id="2f470d70068148b9c3f60f9da5c6e02f3a36f8a9" translate="yes" xml:space="preserve">
          <source>A list of available external lang items is available in &lt;code&gt;src/librustc/middle/weak_lang_items.rs&lt;/code&gt;. Example:</source>
          <target state="translated">可用的外部lang项目列表在 &lt;code&gt;src/librustc/middle/weak_lang_items.rs&lt;/code&gt; 中。例：</target>
        </trans-unit>
        <trans-unit id="a93ce4eba1c20223d4f7efd374435922dc780a28" translate="yes" xml:space="preserve">
          <source>A list of available external lang items is available in &lt;code&gt;src/librustc_middle/middle/weak_lang_items.rs&lt;/code&gt;. Example:</source>
          <target state="translated">可用的外部lang项目列表在 &lt;code&gt;src/librustc_middle/middle/weak_lang_items.rs&lt;/code&gt; 中。例子：</target>
        </trans-unit>
        <trans-unit id="508df8833b23d4b6921f12bfae0871fdb8efa7ce" translate="yes" xml:space="preserve">
          <source>A list specifying general categories of I/O error.</source>
          <target state="translated">指定I/O错误一般类别的列表。</target>
        </trans-unit>
        <trans-unit id="6afbc1cd2e7b35cec4d1c86812f59ca981f43d9f" translate="yes" xml:space="preserve">
          <source>A list with each element, i.e., &lt;code&gt;[x, y, z]&lt;/code&gt;.</source>
          <target state="translated">每个元素的列表，即 &lt;code&gt;[x, y, z]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="15c8d2d5a110eff4a4e3eff0337b45af3836ff58" translate="yes" xml:space="preserve">
          <source>A literal is an expression consisting of a single token, rather than a sequence of tokens, that immediately and directly denotes the value it evaluates to, rather than referring to it by name or some other evaluation rule. A literal is a form of &lt;a href=&quot;const_eval#constant-expressions&quot;&gt;constant expression&lt;/a&gt;, so is evaluated (primarily) at compile time.</source>
          <target state="translated">文字是由单个标记（而不是一系列标记）组成的表达式，该表达式立即且直接表示其求值的值，而不是通过名称或其他评估规则进行引用。文字是&lt;a href=&quot;const_eval#constant-expressions&quot;&gt;常量表达式的&lt;/a&gt;一种形式，因此在编译时进行评估（主要是）。</target>
        </trans-unit>
        <trans-unit id="1857afd88875f6678401e5a6388b40ec5e076688" translate="yes" xml:space="preserve">
          <source>A literal value was used inside &lt;code&gt;#[derive]&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;#[derive]&lt;/code&gt; 中使用了文字值。</target>
        </trans-unit>
        <trans-unit id="7acc2bbca8147fd009370161f8e9ac4665c257d0" translate="yes" xml:space="preserve">
          <source>A literal was used in a built-in attribute that doesn't support literals.</source>
          <target state="translated">在一个不支持文字的内置属性中使用了文字。</target>
        </trans-unit>
        <trans-unit id="efa9c544d88ff2ed4857caf7a6d5b87ab71f9e34" translate="yes" xml:space="preserve">
          <source>A little reminder: a doc comment has to be placed before the item it's supposed to document. So if you want to document the &lt;code&gt;Island&lt;/code&gt; trait, you need to put a doc comment before it, not inside it. Same goes for the &lt;code&gt;lost&lt;/code&gt; method: the doc comment needs to be before it:</source>
          <target state="translated">提醒一下：doc注释必须放置在应记录的项目之前。因此，如果要记录 &lt;code&gt;Island&lt;/code&gt; 特征，则需要在其之前而不是在内部添加文档注释。这同样适用于 &lt;code&gt;lost&lt;/code&gt; 方法：在文档注释必须收到：</target>
        </trans-unit>
        <trans-unit id="8c7298eaf33d5d7b34d2bf261698fdf05d319588" translate="yes" xml:space="preserve">
          <source>A locked reference to the &lt;code&gt;Stderr&lt;/code&gt; handle.</source>
          <target state="translated">对 &lt;code&gt;Stderr&lt;/code&gt; 手柄的锁定引用。</target>
        </trans-unit>
        <trans-unit id="e64008e4cbb40a24042f57f0ba8206541604d8ca" translate="yes" xml:space="preserve">
          <source>A locked reference to the &lt;code&gt;Stdin&lt;/code&gt; handle.</source>
          <target state="translated">对 &lt;code&gt;Stdin&lt;/code&gt; 句柄的锁定引用。</target>
        </trans-unit>
        <trans-unit id="27f936b73151ca7329818fe3daa46cf14b38bc95" translate="yes" xml:space="preserve">
          <source>A locked reference to the &lt;code&gt;Stdout&lt;/code&gt; handle.</source>
          <target state="translated">对 &lt;code&gt;Stdout&lt;/code&gt; 句柄的锁定引用。</target>
        </trans-unit>
        <trans-unit id="209614c8cbb6478d39bb33efacb63355ac82d199" translate="yes" xml:space="preserve">
          <source>A locked standard input implements &lt;code&gt;BufRead&lt;/code&gt;:</source>
          <target state="translated">锁定的标准输入实现 &lt;code&gt;BufRead&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3af527db8725fae95a62589160c6f0f2118456fd" translate="yes" xml:space="preserve">
          <source>A loop expression may optionally have a &lt;em&gt;label&lt;/em&gt;. The label is written as a lifetime preceding the loop expression, as in &lt;code&gt;'foo: loop { break 'foo; }&lt;/code&gt;, &lt;code&gt;'bar: while false {}&lt;/code&gt;, &lt;code&gt;'humbug: for _ in 0..0 {}&lt;/code&gt;. If a label is present, then labeled &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; expressions nested within this loop may exit out of this loop or return control to its head. See &lt;a href=&quot;#break-expressions&quot;&gt;break expressions&lt;/a&gt; and &lt;a href=&quot;#continue-expressions&quot;&gt;continue expressions&lt;/a&gt;.</source>
          <target state="translated">循环表达式可以选择具有&lt;em&gt;标签&lt;/em&gt;。标签被写为循环表达式之前的生存期，如 &lt;code&gt;'foo: loop { break 'foo; }&lt;/code&gt; ， &lt;code&gt;'bar: while false {}&lt;/code&gt; ， &lt;code&gt;'humbug: for _ in 0..0 {}&lt;/code&gt; 。如果存在标签，则嵌套在此循环中的标记为 &lt;code&gt;break&lt;/code&gt; 和 &lt;code&gt;continue&lt;/code&gt; 的表达式可能会退出该循环或将控制权返回到其头部。请参见&lt;a href=&quot;#break-expressions&quot;&gt;中断表达式&lt;/a&gt;和&lt;a href=&quot;#continue-expressions&quot;&gt;继续表达式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3748fe7789bb3fdcadf97f48b577f7242f80249c" translate="yes" xml:space="preserve">
          <source>A loop expression may optionally have a &lt;em&gt;label&lt;/em&gt;. The label is written as a lifetime preceding the loop expression, as in &lt;code&gt;'foo: loop { break 'foo; }&lt;/code&gt;, &lt;code&gt;'bar: while false {}&lt;/code&gt;, &lt;code&gt;'humbug: for _ in 0..0 {}&lt;/code&gt;. If a label is present, then labeled &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; expressions nested within this loop may exit out of this loop or return control to its head. See &lt;a href=&quot;loop-expr#break-expressions&quot;&gt;break expressions&lt;/a&gt; and &lt;a href=&quot;loop-expr#continue-expressions&quot;&gt;continue expressions&lt;/a&gt;.</source>
          <target state="translated">循环表达式可以选择具有&lt;em&gt;标签&lt;/em&gt;。标签被写为循环表达式之前的生存期，如 &lt;code&gt;'foo: loop { break 'foo; }&lt;/code&gt; ， &lt;code&gt;'bar: while false {}&lt;/code&gt; ， &lt;code&gt;'humbug: for _ in 0..0 {}&lt;/code&gt; 。如果存在标签，则嵌套在此循环中的标记为 &lt;code&gt;break&lt;/code&gt; 和 &lt;code&gt;continue&lt;/code&gt; 的表达式可能会退出该循环或将控制权返回到其头部。查看&lt;a href=&quot;loop-expr#break-expressions&quot;&gt;中断表达式&lt;/a&gt;并&lt;a href=&quot;loop-expr#continue-expressions&quot;&gt;继续表达式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="621a2333164d1c1ddcc3e28445c529a5edcd0f4d" translate="yes" xml:space="preserve">
          <source>A loop keyword (&lt;code&gt;break&lt;/code&gt; or &lt;code&gt;continue&lt;/code&gt;) was used inside a closure but outside of any loop.</source>
          <target state="translated">在闭包内部但在任何循环外部都使用了一个循环关键字（ &lt;code&gt;break&lt;/code&gt; 或 &lt;code&gt;continue&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f49094ffad160345ac5b867a45ab1d0476b39ead" translate="yes" xml:space="preserve">
          <source>A loop keyword (&lt;code&gt;break&lt;/code&gt; or &lt;code&gt;continue&lt;/code&gt;) was used outside of a loop.</source>
          <target state="translated">在循环外部使用了循环关键字（ &lt;code&gt;break&lt;/code&gt; 或 &lt;code&gt;continue&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="511e4a1a5b552d0daef468f2387fb6edd0e92546" translate="yes" xml:space="preserve">
          <source>A lossy decoder can be obtained by replacing &lt;code&gt;Err&lt;/code&gt; results with the replacement character:</source>
          <target state="translated">可以通过替换 &lt;code&gt;Err&lt;/code&gt; 获得有损解码器使用替换字符结果，：</target>
        </trans-unit>
        <trans-unit id="aaa61df7a5c37f0e9baf2b1d7a2af95d48009664" translate="yes" xml:space="preserve">
          <source>A lower range wasn't less than the upper range.</source>
          <target state="translated">下限范围不比上限范围小。</target>
        </trans-unit>
        <trans-unit id="d97f1261b9b58d3e3fe4caf6b3ed4e3d57f050f7" translate="yes" xml:space="preserve">
          <source>A macro invocation executes a macro at compile time and replaces the invocation with the result of the macro. Macros may be invoked in the following situations:</source>
          <target state="translated">宏调用在编译时执行一个宏,并以宏的结果代替调用。在以下情况下可以调用宏。</target>
        </trans-unit>
        <trans-unit id="604f17220a435dfda6ce25b3286e96cae9c124f4" translate="yes" xml:space="preserve">
          <source>A macro listed for import was not found.</source>
          <target state="translated">没有找到一个列入进口的宏。</target>
        </trans-unit>
        <trans-unit id="2e0526607109d7012469029a56fd3ee785be2e0d" translate="yes" xml:space="preserve">
          <source>A macro to test at &lt;em&gt;runtime&lt;/em&gt; whether a CPU feature is available on x86/x86-64 platforms.</source>
          <target state="translated">要在&lt;em&gt;运行时&lt;/em&gt;测试的宏&lt;em&gt;&lt;/em&gt; x86 / x86-64平台上是否具有CPU功能的。</target>
        </trans-unit>
        <trans-unit id="5b9ba25200988be7523c79ceef0a08b5dbf3a289" translate="yes" xml:space="preserve">
          <source>A major goal of the compiler is to ensure that a library never appears more than once in any artifact. For example, if dynamic libraries B and C were each statically linked to library A, then a crate could not link to B and C together because there would be two copies of A. The compiler allows mixing the rlib and dylib formats, but this restriction must be satisfied.</source>
          <target state="translated">编译器的一个主要目标是确保一个库永远不会在任何工件中出现一次以上。例如,如果动态库B和C分别与库A静态链接,那么一个箱子就不能同时链接到B和C,因为A会有两个拷贝。编译器允许混合rlib和dylib格式,但必须满足这个限制。</target>
        </trans-unit>
        <trans-unit id="416ce06261874aaff012fa6c737cea866a967092" translate="yes" xml:space="preserve">
          <source>A map based on a B-Tree.</source>
          <target state="translated">基于B-Tree的地图。</target>
        </trans-unit>
        <trans-unit id="f2df32e1b651fa8937f10fb914a69befa91dcf32" translate="yes" xml:space="preserve">
          <source>A marker trait representing types where a shared reference is considered unwind safe.</source>
          <target state="translated">代表共享引用被认为是解除安全的类型的标记特征。</target>
        </trans-unit>
        <trans-unit id="3bc97c0d55aa2cae1126bc3f3d83ef27e23658de" translate="yes" xml:space="preserve">
          <source>A marker trait to express that a &lt;a href=&quot;trait.reversesearcher&quot;&gt;&lt;code&gt;ReverseSearcher&lt;/code&gt;&lt;/a&gt; can be used for a &lt;a href=&quot;../../iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">标记特征，它表示&lt;a href=&quot;trait.reversesearcher&quot;&gt; &lt;code&gt;ReverseSearcher&lt;/code&gt; &lt;/a&gt;可用于&lt;a href=&quot;../../iter/trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; &lt;/a&gt;实现。</target>
        </trans-unit>
        <trans-unit id="ba67e3276d83805bffe74ea0a7a327593cf9467b" translate="yes" xml:space="preserve">
          <source>A marker trait to express that a &lt;code&gt;ReverseSearcher&lt;/code&gt; can be used for a &lt;code&gt;DoubleEndedIterator&lt;/code&gt; implementation.</source>
          <target state="translated">标记特征，表示 &lt;code&gt;ReverseSearcher&lt;/code&gt; 可用于 &lt;code&gt;DoubleEndedIterator&lt;/code&gt; 实现。</target>
        </trans-unit>
        <trans-unit id="2f67969c6f12d96330ceaae49a9df5d58837b264" translate="yes" xml:space="preserve">
          <source>A marker trait which represents &quot;panic safe&quot; types in Rust.</source>
          <target state="translated">Rust中代表 &quot;恐慌性安全 &quot;类型的标记性状。</target>
        </trans-unit>
        <trans-unit id="7c9160659faee9d41f691cb8f88f2f8a49c219c0" translate="yes" xml:space="preserve">
          <source>A marker type which does not implement &lt;code&gt;Unpin&lt;/code&gt;.</source>
          <target state="translated">没有实现 &lt;code&gt;Unpin&lt;/code&gt; 的标记类型。</target>
        </trans-unit>
        <trans-unit id="2cd086d02e989df16ae8561bd2410188577f706c" translate="yes" xml:space="preserve">
          <source>A measurement of a monotonically nondecreasing clock. Opaque and useful only with &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">单调非递减时钟的度量。不透明，仅在 &lt;code&gt;Duration&lt;/code&gt; 时有用。</target>
        </trans-unit>
        <trans-unit id="f1b2d1acc7998286a04c3bbe416b5e64b3d2a408" translate="yes" xml:space="preserve">
          <source>A measurement of the system clock, useful for talking to external entities like the file system or other processes.</source>
          <target state="translated">系统时钟的测量,用于与文件系统或其他进程等外部实体对话。</target>
        </trans-unit>
        <trans-unit id="ab0a8ccacb7225c2d2eaa3d61513ce8be0301515" translate="yes" xml:space="preserve">
          <source>A memory allocator that can be registered as the standard library&amp;rsquo;s default though the &lt;code&gt;#[global_allocator]&lt;/code&gt; attributes.</source>
          <target state="translated">通过 &lt;code&gt;#[global_allocator]&lt;/code&gt; 属性，可以将其分配为标准库的默认内存分配器。</target>
        </trans-unit>
        <trans-unit id="36390b8dd6062ca0b9666a02db751bef68ddc91f" translate="yes" xml:space="preserve">
          <source>A memory allocator that can be registered as the standard library&amp;rsquo;s default through the &lt;code&gt;#[global_allocator]&lt;/code&gt; attribute.</source>
          <target state="translated">可以通过 &lt;code&gt;#[global_allocator]&lt;/code&gt; 属性将其分配为标准库的默认内存分配器。</target>
        </trans-unit>
        <trans-unit id="f52897b7b1a254a773b596ff34aeb774856f7c04" translate="yes" xml:space="preserve">
          <source>A metavariable must appear in exactly the same number, kind, and nesting order of repetitions in the transcriber as it did in the matcher. So for the matcher &lt;code&gt;$( $i:ident ),*&lt;/code&gt;, the transcribers &lt;code&gt;=&amp;gt; { $i }&lt;/code&gt;, &lt;code&gt;=&amp;gt; { $( $( $i)* )* }&lt;/code&gt;, and &lt;code&gt;=&amp;gt; { $( $i )+ }&lt;/code&gt; are all illegal, but &lt;code&gt;=&amp;gt; { $( $i );* }&lt;/code&gt; is correct and replaces a comma-separated list of identifiers with a semicolon-separated list.</source>
          <target state="translated">一个元变量必须在抄写器中以与匹配器中完全相同的数量，种类和嵌套顺序出现。因此，对于匹配器 &lt;code&gt;$( $i:ident ),*&lt;/code&gt; ，转录器 &lt;code&gt;=&amp;gt; { $i }&lt;/code&gt; ， &lt;code&gt;=&amp;gt; { $( $( $i)* )* }&lt;/code&gt; 和 &lt;code&gt;=&amp;gt; { $( $i )+ }&lt;/code&gt; 是全部非法，但 &lt;code&gt;=&amp;gt; { $( $i );* }&lt;/code&gt; 是正确的，并将标识符的逗号分隔列表替换为以分号分隔的列表。</target>
        </trans-unit>
        <trans-unit id="8b9a4a11c65ef071b5b26c72c1c0d6cc7317036f" translate="yes" xml:space="preserve">
          <source>A method or constant was implemented on a primitive type.</source>
          <target state="translated">一个方法或常量是在一个基元类型上实现的。</target>
        </trans-unit>
        <trans-unit id="801757bf4a897de3dc38db9dc1b65e4429ae7c96" translate="yes" xml:space="preserve">
          <source>A method was called on a raw pointer whose inner type wasn't completely known.</source>
          <target state="translated">在一个原始指针上调用了一个方法,这个指针的内部类型并不完全清楚。</target>
        </trans-unit>
        <trans-unit id="da23ec6794439455d8bda2444d9dc191c1a91b2b" translate="yes" xml:space="preserve">
          <source>A method was called on an ambiguous numeric type.</source>
          <target state="translated">一个方法被调用在一个模糊的数字类型上。</target>
        </trans-unit>
        <trans-unit id="cb6424b2d67ae2d104f32890640da913ac560f8f" translate="yes" xml:space="preserve">
          <source>A method was implemented on a primitive type.</source>
          <target state="translated">在一个基元类型上实现了一个方法。</target>
        </trans-unit>
        <trans-unit id="b83bd54b545ece8364d586c3e7f838baf02e8c65" translate="yes" xml:space="preserve">
          <source>A method was implemented when another trait item was expected.</source>
          <target state="translated">当预期有另一个性状项目时,实施了一种方法。</target>
        </trans-unit>
        <trans-unit id="0b9ba16b85d0fa75f6c2790fe89555c2da2a5ee8" translate="yes" xml:space="preserve">
          <source>A method was implemented when another trait item was expected. Erroneous code example:</source>
          <target state="translated">当预期有另一个性状项目时,实施了一个方法。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="30d915c6907e57ec215e0d955c2fea0a426c859a" translate="yes" xml:space="preserve">
          <source>A module can import both &lt;code&gt;std::fmt::Write&lt;/code&gt; and &lt;code&gt;std::io::Write&lt;/code&gt; and call &lt;code&gt;write!&lt;/code&gt; on objects implementing either, as objects do not typically implement both. However, the module must import the traits qualified so their names do not conflict:</source>
          <target state="translated">模块可以同时导入 &lt;code&gt;std::fmt::Write&lt;/code&gt; 和 &lt;code&gt;std::io::Write&lt;/code&gt; 并调用 &lt;code&gt;write!&lt;/code&gt; 在实现这两者的对象上，因为对象通常不会同时实现两者。但是，模块必须导入限定的特征，以便其名称不会冲突：</target>
        </trans-unit>
        <trans-unit id="8df0b4f7cbe7a3d63c8935c00a09e49b670eda46" translate="yes" xml:space="preserve">
          <source>A module cannot be found and therefore, the visibility cannot be determined.</source>
          <target state="translated">找不到模块,因此无法确定可见性。</target>
        </trans-unit>
        <trans-unit id="9b81303b4be9b1fd6a4b7a6468837e80d06c4579" translate="yes" xml:space="preserve">
          <source>A module for working with borrowed data.</source>
          <target state="translated">一个处理借来的数据的模块。</target>
        </trans-unit>
        <trans-unit id="279721754abe896ed73051fc4e21afc678f9887f" translate="yes" xml:space="preserve">
          <source>A module for working with processes.</source>
          <target state="translated">一个处理流程的模块。</target>
        </trans-unit>
        <trans-unit id="6a05a78578f1dbd0078ba611f8fe4d06c249f5a6" translate="yes" xml:space="preserve">
          <source>A module is a container for zero or more &lt;a href=&quot;../items&quot;&gt;items&lt;/a&gt;.</source>
          <target state="translated">模块是零个或多个&lt;a href=&quot;../items&quot;&gt;项目&lt;/a&gt;的容器。</target>
        </trans-unit>
        <trans-unit id="c04981413bae044ff3db488edfd9ac3f31ccdfa7" translate="yes" xml:space="preserve">
          <source>A module without a body is loaded from an external file. When the module does not have a &lt;code&gt;path&lt;/code&gt; attribute, the path to the file mirrors the logical &lt;a href=&quot;../paths&quot;&gt;module path&lt;/a&gt;. Ancestor module path components are directories, and the module's contents are in a file with the name of the module plus the &lt;code&gt;.rs&lt;/code&gt; extension. For example, the following module structure can have this corresponding filesystem structure:</source>
          <target state="translated">没有主体的模块是从外部文件加载的。当模块不具有 &lt;code&gt;path&lt;/code&gt; 属性时，文件的路径将镜像逻辑&lt;a href=&quot;../paths&quot;&gt;模块path&lt;/a&gt;。祖先模块路径组件是目录，而模块的内容在文件中，其中包含模块名称加 &lt;code&gt;.rs&lt;/code&gt; 扩展名。例如，以下模块结构可以具有此对应的文件系统结构：</target>
        </trans-unit>
        <trans-unit id="29558e1ce9256ba552f6d5cea0ac0d8f0b314326" translate="yes" xml:space="preserve">
          <source>A more complex example:</source>
          <target state="translated">一个比较复杂的例子。</target>
        </trans-unit>
        <trans-unit id="d3b971a729c5c72b8be0c4aea17fd6538988f22d" translate="yes" xml:space="preserve">
          <source>A more complex pattern, using a closure:</source>
          <target state="translated">一个比较复杂的模式,使用闭合。</target>
        </trans-unit>
        <trans-unit id="3dd589b621cc1adc060715bf9a9ed158d11abe3d" translate="yes" xml:space="preserve">
          <source>A more experienced Rustacean would write the signature shown in Listing 4-9 instead because it allows us to use the same function on both &lt;code&gt;&amp;amp;String&lt;/code&gt; values and &lt;code&gt;&amp;amp;str&lt;/code&gt; values.</source>
          <target state="translated">经验丰富的Rustacean会写清单4-9所示的签名，因为它允许我们在 &lt;code&gt;&amp;amp;String&lt;/code&gt; 值和 &lt;code&gt;&amp;amp;str&lt;/code&gt; 值上使用相同的函数。</target>
        </trans-unit>
        <trans-unit id="e13722d1be852ba526aeffb3cbbf03d8cad62a98" translate="yes" xml:space="preserve">
          <source>A more realistic usage of &lt;code&gt;!&lt;/code&gt; is in this code:</source>
          <target state="translated">更现实的用法 &lt;code&gt;!&lt;/code&gt; 在这段代码中：</target>
        </trans-unit>
        <trans-unit id="47b3111cf8992e03f361ef35402077d40b862b00" translate="yes" xml:space="preserve">
          <source>A more user-friendly and stable version of this operation is &lt;a href=&quot;../process/fn.abort&quot;&gt;&lt;code&gt;std::process::abort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此操作的更用户友好和稳定的版本是&lt;a href=&quot;../process/fn.abort&quot;&gt; &lt;code&gt;std::process::abort&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e80c7507fc9ff231be351f8cae94b1cf2dae1652" translate="yes" xml:space="preserve">
          <source>A multi-line (doc-)comment is unterminated.</source>
          <target state="translated">多行(doc-)注释是无尾的。</target>
        </trans-unit>
        <trans-unit id="a85c20eab8c8f59bbb7b3375434e1c4c2a5fba1b" translate="yes" xml:space="preserve">
          <source>A mutable binding, reference, or pointer.</source>
          <target state="translated">一个可变更的绑定、引用或指针。</target>
        </trans-unit>
        <trans-unit id="8cd7d09d26092ca44a3f65ffe3c3325410d6931b" translate="yes" xml:space="preserve">
          <source>A mutable iterator over a sub-range of entries in a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; 中条目子范围上的可变迭代器。</target>
        </trans-unit>
        <trans-unit id="0adc791ed0f0c19141af510a4b25898187d82ab6" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the elements of a &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;LinkedList&lt;/code&gt; 的元素上的可变迭代器。</target>
        </trans-unit>
        <trans-unit id="ad89e0aaae2a988478ed905cd86eb0dc9435d0ff" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the elements of a &lt;code&gt;VecDeque&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;VecDeque&lt;/code&gt; 元素上的可变迭代器。</target>
        </trans-unit>
        <trans-unit id="79c92db5fb2c00374466341575412a72b346b96d" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the entries of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; 条目上的可变迭代器。</target>
        </trans-unit>
        <trans-unit id="82c043e3bfeb960195491db7d3d334e90cb7714f" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the entries of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 条目上的可变迭代器。</target>
        </trans-unit>
        <trans-unit id="d985ac327f38804e748201a497e2781eda7b7dde" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the values of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; 的值上的可变迭代器。</target>
        </trans-unit>
        <trans-unit id="3180573575f9ee53aeac5bbb0709534becff511d" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the values of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 的值上的可变迭代器。</target>
        </trans-unit>
        <trans-unit id="8b90716d837b7248d5e9906c50d0a99bd6595870" translate="yes" xml:space="preserve">
          <source>A mutable memory location with dynamically checked borrow rules</source>
          <target state="translated">具有动态检查借用规则的可变内存位置</target>
        </trans-unit>
        <trans-unit id="c91e5fa32d436ead641cd9a3940ea6b760cc8d42" translate="yes" xml:space="preserve">
          <source>A mutable memory location.</source>
          <target state="translated">一个可变更的内存位置。</target>
        </trans-unit>
        <trans-unit id="0b14b941c806b921d8ab056b2552003af1435118" translate="yes" xml:space="preserve">
          <source>A mutable reference can be created with &lt;code&gt;&amp;amp;mut&lt;/code&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;&amp;amp;mut&lt;/code&gt; 创建可变引用。</target>
        </trans-unit>
        <trans-unit id="aa831fb6e4681d63ec9057ce3580c443fec9edb2" translate="yes" xml:space="preserve">
          <source>A mutable reference was used in a constant.</source>
          <target state="translated">在一个常数中使用了一个可突变的参照物。</target>
        </trans-unit>
        <trans-unit id="7ad0f3cf407381fd22bba2cf586e95f6a6a15615" translate="yes" xml:space="preserve">
          <source>A mutable variable is used but it is already captured by a closure.</source>
          <target state="translated">使用了一个可变的变量,但它已经被一个闭包所捕获。</target>
        </trans-unit>
        <trans-unit id="1ceef8798472360db16ce7d238d9ede4272142f3" translate="yes" xml:space="preserve">
          <source>A mutable variable, reference, or pointer.</source>
          <target state="translated">一个可变的变量、引用或指针。</target>
        </trans-unit>
        <trans-unit id="0f8c1096d067dc232cad356da19d2cbebed307a4" translate="yes" xml:space="preserve">
          <source>A mutual exclusion primitive useful for protecting shared data</source>
          <target state="translated">一个用于保护共享数据的互斥基元。</target>
        </trans-unit>
        <trans-unit id="342f794408fe251ce7add66c87de4ca58808181b" translate="yes" xml:space="preserve">
          <source>A named address:</source>
          <target state="translated">一个指定的地址;</target>
        </trans-unit>
        <trans-unit id="01a291706f0b443b495b0b8c907121279cbace5d" translate="yes" xml:space="preserve">
          <source>A negative impl was made default impl.</source>
          <target state="translated">一个消极的内涵被成为默认内涵。</target>
        </trans-unit>
        <trans-unit id="da1879858ed2ef626482e4f36f37eea0d652d696" translate="yes" xml:space="preserve">
          <source>A negative implementation is one that excludes a type from implementing a particular trait. Not being able to use a trait is always a safe operation, so negative implementations are always safe and never need to be marked as unsafe.</source>
          <target state="translated">消极实现是指排除一个类型实现某个特质。不能使用一个特质总是安全的操作,所以消极实现总是安全的,永远不需要标记为不安全。</target>
        </trans-unit>
        <trans-unit id="64f76de0f189c143b75250fce4afe6feb8fa06dc" translate="yes" xml:space="preserve">
          <source>A negative implementation was marked as unsafe.</source>
          <target state="translated">否定的执行被标记为不安全。</target>
        </trans-unit>
        <trans-unit id="4ca3ab38594dcb0b01232bdbb9c6f42b411e7856" translate="yes" xml:space="preserve">
          <source>A new pipe should be arranged to connect the parent and child processes.</source>
          <target state="translated">应安排一个新的管道来连接父进程和子进程。</target>
        </trans-unit>
        <trans-unit id="9ef1ea249a1150bef2505217b3c43c59ac961084" translate="yes" xml:space="preserve">
          <source>A new thread can be configured before it is spawned via the &lt;a href=&quot;struct.builder&quot;&gt;&lt;code&gt;Builder&lt;/code&gt;&lt;/a&gt; type, which currently allows you to set the name and stack size for the child thread:</source>
          <target state="translated">通过&lt;a href=&quot;struct.builder&quot;&gt; &lt;code&gt;Builder&lt;/code&gt; 生成&lt;/a&gt;新线程之前，可以对其进行配置类型类型当前允许您设置子线程的名称和堆栈大小：</target>
        </trans-unit>
        <trans-unit id="5e4ae553ae5846b13d461bd059795986a05e550e" translate="yes" xml:space="preserve">
          <source>A new thread can be spawned using the &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;thread::spawn&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">可以使用&lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;thread::spawn&lt;/code&gt; &lt;/a&gt;函数生成一个新线程：</target>
        </trans-unit>
        <trans-unit id="012e80e619e9a75c91e5b48d3d4ff0741fba078e" translate="yes" xml:space="preserve">
          <source>A node will be able to refer to its parent node but doesn&amp;rsquo;t own its parent. In Listing 15-28, we update &lt;code&gt;main&lt;/code&gt; to use this new definition so the &lt;code&gt;leaf&lt;/code&gt; node will have a way to refer to its parent, &lt;code&gt;branch&lt;/code&gt;:</source>
          <target state="translated">节点将能够引用其父节点，但不拥有其父节点。在清单15-28中，我们更新 &lt;code&gt;main&lt;/code&gt; 以使用此新定义，因此 &lt;code&gt;leaf&lt;/code&gt; 节点将可以引用其父 &lt;code&gt;branch&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0d77bcf0653e102d2dc04011199024bd95fbb9db" translate="yes" xml:space="preserve">
          <source>A non-&lt;code&gt;'static&lt;/code&gt; lifetime was used in a const generic. This is currently not allowed.</source>
          <target state="translated">在const泛型中使用了非 &lt;code&gt;'static&lt;/code&gt; 生存期。目前不允许这样做。</target>
        </trans-unit>
        <trans-unit id="1c1956450560b920c7d29f562d8c785a2a837c6c" translate="yes" xml:space="preserve">
          <source>A non-constant value was used in a constant expression.</source>
          <target state="translated">常量表达式中使用了一个非常量值。</target>
        </trans-unit>
        <trans-unit id="1eee5bad5b1b537626b09062a59e028d86d55ec2" translate="yes" xml:space="preserve">
          <source>A non-default implementation was already made on this type so it cannot be specialized further.</source>
          <target state="translated">在这个类型上已经做了一个非默认的实现,所以不能再专门化。</target>
        </trans-unit>
        <trans-unit id="f749bb15fde0e4ed5d6ca2223f09a3999408a077" translate="yes" xml:space="preserve">
          <source>A non-default implementation was already made on this type so it cannot be specialized further. Erroneous code example:</source>
          <target state="translated">已经对该类型做了一个非默认的实现,所以不能再专门化。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="945520bcba1761f9fc7afafe8dcc369bff6ec8f2" translate="yes" xml:space="preserve">
          <source>A non-final component in path is not a directory.</source>
          <target state="translated">路径中的非最终成分不是目录。</target>
        </trans-unit>
        <trans-unit id="c1d61674888a79b8d093da31552849442beb0211" translate="yes" xml:space="preserve">
          <source>A non-ident or non-wildcard pattern has been used as a parameter of a function pointer type.</source>
          <target state="translated">一个非ident或非wildcard模式被用作函数指针类型的参数。</target>
        </trans-unit>
        <trans-unit id="3c2d2a8d307a0d585bf4d4468aa00fb158ce3e7d" translate="yes" xml:space="preserve">
          <source>A non-mutable value was assigned a value.</source>
          <target state="translated">一个不可变的值被分配了一个值。</target>
        </trans-unit>
        <trans-unit id="6d5a3ee2105e8888d79910fc840ffa44f6ec8258" translate="yes" xml:space="preserve">
          <source>A non-raw &lt;em&gt;byte string literal&lt;/em&gt; is a sequence of ASCII characters and &lt;em&gt;escapes&lt;/em&gt;, preceded by the characters &lt;code&gt;U+0062&lt;/code&gt; (&lt;code&gt;b&lt;/code&gt;) and &lt;code&gt;U+0022&lt;/code&gt; (double-quote), and followed by the character &lt;code&gt;U+0022&lt;/code&gt;. If the character &lt;code&gt;U+0022&lt;/code&gt; is present within the literal, it must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) character. Alternatively, a byte string literal can be a &lt;em&gt;raw byte string literal&lt;/em&gt;, defined below. The type of a byte string literal of length &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;&amp;amp;'static [u8; n]&lt;/code&gt;.</source>
          <target state="translated">非原始&lt;em&gt;字节字符串文字&lt;/em&gt;是ASCII字符和&lt;em&gt;转义&lt;/em&gt;符的序列，其后是字符 &lt;code&gt;U+0062&lt;/code&gt; （ &lt;code&gt;b&lt;/code&gt; ）和 &lt;code&gt;U+0022&lt;/code&gt; （双引号），然后是字符 &lt;code&gt;U+0022&lt;/code&gt; 。如果字符 &lt;code&gt;U+0022&lt;/code&gt; 存在于文字中，则必须由前面的 &lt;code&gt;U+005C&lt;/code&gt; （ &lt;code&gt;\&lt;/code&gt; ）字符对其进行&lt;em&gt;转义&lt;/em&gt;。另外，字节字符串文字可以是下面定义的&lt;em&gt;原始字节字符串文字&lt;/em&gt;。长度为 &lt;code&gt;n&lt;/code&gt; 的字节字符串文字的类型为 &lt;code&gt;&amp;amp;'static [u8; n]&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5c51fee9eaaa31ddc4415e9556f81e14c7ecfe88" translate="yes" xml:space="preserve">
          <source>A non-root module attempts to import macros from another crate.</source>
          <target state="translated">一个非root模块试图从另一个箱子中导入宏。</target>
        </trans-unit>
        <trans-unit id="0f7f88934a0864a48a1aa3e075daab332c8783a0" translate="yes" xml:space="preserve">
          <source>A non-root module tried to import macros from another crate.</source>
          <target state="translated">一个非root模块试图从另一个箱子中导入宏。</target>
        </trans-unit>
        <trans-unit id="84ccf07b47b66963a7e3e32486b9dba6e199bf07" translate="yes" xml:space="preserve">
          <source>A non-structural-match type was used as the type of a const generic parameter.</source>
          <target state="translated">一个非结构匹配类型被用作一个const通用参数的类型。</target>
        </trans-unit>
        <trans-unit id="2fa1a2ea6af29cff8cb26708218d5730128ed29d" translate="yes" xml:space="preserve">
          <source>A nonexistent interface was requested or the requested address was not local.</source>
          <target state="translated">请求了一个不存在的接口,或者请求的地址不是本地的。</target>
        </trans-unit>
        <trans-unit id="96ce721c887ff14a23c8684eb9a885bd0450c6a3" translate="yes" xml:space="preserve">
          <source>A normal component, e.g., &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; in &lt;code&gt;a/b&lt;/code&gt;.</source>
          <target state="translated">一个正常的组件，例如， &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 中 &lt;code&gt;a/b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5782d98ce3a8ef05d6f0d54e23bbea53e593ec4e" translate="yes" xml:space="preserve">
          <source>A note regarding zero-sized types and zero-sized layouts: many methods in the &lt;code&gt;Alloc&lt;/code&gt; trait state that allocation requests must be non-zero size, or else undefined behavior can result.</source>
          <target state="translated">关于零大小的类型和零大小的布局的注释： &lt;code&gt;Alloc&lt;/code&gt; 特质中的许多方法都指出分配请求必须为非零大小，否则可能导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="d70ff5d8ac6ec719cfc0758b679c32b46a7a0fdd" translate="yes" xml:space="preserve">
          <source>A null &lt;code&gt;fn&lt;/code&gt; pointer.</source>
          <target state="translated">空的 &lt;code&gt;fn&lt;/code&gt; 指针。</target>
        </trans-unit>
        <trans-unit id="dbd524388dc48721a46df11a0e678684cddc1ff5" translate="yes" xml:space="preserve">
          <source>A number in a non-decimal base has no digits.</source>
          <target state="translated">非小数基数的数字没有数字。</target>
        </trans-unit>
        <trans-unit id="79055d577bd4470f262c27ac3d7f2c814ba28782" translate="yes" xml:space="preserve">
          <source>A panic upon overflow:</source>
          <target state="translated">溢出后的恐慌。</target>
        </trans-unit>
        <trans-unit id="7e451dc65737a3d0078f0a0cdca0352afd247852" translate="yes" xml:space="preserve">
          <source>A parameter type is missing a lifetime constraint or has a lifetime that does not live long enough.</source>
          <target state="translated">一个参数类型缺少寿命约束或寿命不够长。</target>
        </trans-unit>
        <trans-unit id="c17681e220340a047c028939b5c9a6007c707423" translate="yes" xml:space="preserve">
          <source>A parameter type is missing an explicit lifetime bound and may not live long enough.</source>
          <target state="translated">一个参数类型缺少明确的寿命约束,可能寿命不够长。</target>
        </trans-unit>
        <trans-unit id="bd0627aebae59febc951bf56bcbbb5c77e2a3cca" translate="yes" xml:space="preserve">
          <source>A parameter was incorrect.</source>
          <target state="translated">一个参数不正确。</target>
        </trans-unit>
        <trans-unit id="8faec6289671e90add0a6793ff7c83244ee9ad52" translate="yes" xml:space="preserve">
          <source>A parent of the given path doesn't exist. (To create a directory and all its missing parents at the same time, use the &lt;a href=&quot;fn.create_dir_all&quot;&gt;&lt;code&gt;create_dir_all&lt;/code&gt;&lt;/a&gt; function.)</source>
          <target state="translated">给定路径的父级不存在。（要同时创建目录及其所有丢失的父目录，请使用&lt;a href=&quot;fn.create_dir_all&quot;&gt; &lt;code&gt;create_dir_all&lt;/code&gt; &lt;/a&gt;函数。）</target>
        </trans-unit>
        <trans-unit id="3c44a59945c31a15632dad83502ad5c534fa6460" translate="yes" xml:space="preserve">
          <source>A particular instance &lt;code&gt;RandomState&lt;/code&gt; will create the same instances of &lt;a href=&quot;../../hash/trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt;, but the hashers created by two different &lt;code&gt;RandomState&lt;/code&gt; instances are unlikely to produce the same result for the same values.</source>
          <target state="translated">一个特定的实例 &lt;code&gt;RandomState&lt;/code&gt; 将创建相同的&lt;a href=&quot;../../hash/trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt;实例，但是由两个不同的 &lt;code&gt;RandomState&lt;/code&gt; 实例创建的散列对于相同的值不太可能产生相同的结果。</target>
        </trans-unit>
        <trans-unit id="83b0cbf0a90bcfe2367c6fdcc070513f6d4d75f8" translate="yes" xml:space="preserve">
          <source>A particular pattern &lt;code&gt;_&lt;/code&gt; will match anything, but it never binds to a variable, so it&amp;rsquo;s often used in the last match arm. The &lt;code&gt;_&lt;/code&gt; pattern can be useful when you want to ignore any value not specified, for example. We&amp;rsquo;ll cover the &lt;code&gt;_&lt;/code&gt; pattern in more detail in the &lt;a href=&quot;ch18-03-pattern-syntax#ignoring-values-in-a-pattern&quot;&gt;&amp;ldquo;Ignoring Values in a Pattern&amp;rdquo;&lt;/a&gt; section later in this chapter.</source>
          <target state="translated">特定的模式 &lt;code&gt;_&lt;/code&gt; 可以匹配任何内容，但是它永远不会绑定到变量，因此通常在最后一个匹配臂中使用。例如，当您想忽略任何未指定的值时， &lt;code&gt;_&lt;/code&gt; 模式很有用。我们将在本章后面的&lt;a href=&quot;ch18-03-pattern-syntax#ignoring-values-in-a-pattern&quot;&gt;&amp;ldquo;忽略模式中的值&amp;rdquo;&lt;/a&gt;一节中详细介绍 &lt;code&gt;_&lt;/code&gt; 模式。</target>
        </trans-unit>
        <trans-unit id="1f72278829757d575931ca8a320129aa5f0521b4" translate="yes" xml:space="preserve">
          <source>A path can take two forms:</source>
          <target state="translated">一条路径可以有两种形式。</target>
        </trans-unit>
        <trans-unit id="7908f4aa852c1de2737ef7d2b9796ba4b3783229" translate="yes" xml:space="preserve">
          <source>A pattern a &lt;code&gt;..=&lt;/code&gt; b must always have a &amp;le; b. It is an error to have a range pattern &lt;code&gt;10..=0&lt;/code&gt;, for example.</source>
          <target state="translated">模式a &lt;code&gt;..=&lt;/code&gt; b必须始终具有&amp;le;b。例如，具有范围模式 &lt;code&gt;10..=0&lt;/code&gt; 是错误的。</target>
        </trans-unit>
        <trans-unit id="891da3d988f6fc5238b5b4fb583d072b5a0287dc" translate="yes" xml:space="preserve">
          <source>A pattern attempted to extract an incorrect number of fields from a variant.</source>
          <target state="translated">一个模式试图从一个变体中提取一个错误的字段数。</target>
        </trans-unit>
        <trans-unit id="6d6b7416ed8a3ba7b4dcdc0423f76b297ea15288" translate="yes" xml:space="preserve">
          <source>A pattern binding is using the same name as one of the variants of a type.</source>
          <target state="translated">模式绑定是使用与类型的一个变体相同的名称。</target>
        </trans-unit>
        <trans-unit id="53b95bece3c7641fd29f13b871ae1a3d402281d9" translate="yes" xml:space="preserve">
          <source>A pattern for a struct fails to specify a sub-pattern for every one of the struct's fields.</source>
          <target state="translated">一个结构的模式不能为结构的每个字段指定一个子模式。</target>
        </trans-unit>
        <trans-unit id="2c3ec235405c966e5db61078265ddd06c38fdf87" translate="yes" xml:space="preserve">
          <source>A pattern guard may refer to the variables bound within the pattern they follow. Before evaluating the guard, a shared reference is taken to the part of the scrutinee the variable matches on. While evaluating the guard, this shared reference is then used when accessing the variable. Only when the guard evaluates to true is the value moved, or copied, from the scrutinee into the variable. This allows shared borrows to be used inside guards without moving out of the scrutinee in case guard fails to match. Moreover, by holding a shared reference while evaluating the guard, mutation inside guards is also prevented.</source>
          <target state="translated">模式卫士可以引用它们所遵循的模式内绑定的变量。在评估守护之前,变量所匹配的那部分审视者会有一个共享的引用,在评估守护时,这个共享的引用会在访问变量时被使用。在评估守护时,这个共享引用会在访问变量时被使用。只有当守护评估为真时,值才会从审查对象中移动或复制到变量中。这使得共享引用可以在guards内部使用,而不会在guards不匹配的情况下从审查对象中移出。此外,通过在评估守卫时持有共享引用,还可以防止守卫内部的突变。</target>
        </trans-unit>
        <trans-unit id="bf85ec7c19381f75fc673dab8bb0b15ce1a79c9a" translate="yes" xml:space="preserve">
          <source>A pattern is said to be &lt;em&gt;refutable&lt;/em&gt; when it has the possibility of not being matched by the value it is being matched against. &lt;em&gt;Irrefutable&lt;/em&gt; patterns, on the other hand, always match the value they are being matched against. Examples:</source>
          <target state="translated">的图案被认为是&lt;em&gt;可辩驳&lt;/em&gt;当它具有不被它正在针对匹配的值相匹配的可能性。另一方面，&lt;em&gt;无可辩驳的&lt;/em&gt;模式始终与要匹配的值匹配。例子：</target>
        </trans-unit>
        <trans-unit id="50718096ba0e9d977821568bde4dc051a6527468" translate="yes" xml:space="preserve">
          <source>A pattern used to match against an enum variant must provide a sub-pattern for each field of the enum variant.</source>
          <target state="translated">用于与枚举变体匹配的模式必须为枚举变体的每个字段提供一个子模式。</target>
        </trans-unit>
        <trans-unit id="bf12d88e1623c0c22171573d10a1573941789f14" translate="yes" xml:space="preserve">
          <source>A pattern used to match against an enum variant must provide a sub-pattern for each field of the enum variant. This error indicates that a pattern attempted to extract an incorrect number of fields from a variant.</source>
          <target state="translated">用于与枚举变体匹配的模式必须为枚举变体的每个字段提供一个子模式。该错误表明,模式试图从变体中提取错误的字段数。</target>
        </trans-unit>
        <trans-unit id="27a0056206e19a4b052630f19a00fbd4710c685a" translate="yes" xml:space="preserve">
          <source>A pattern was declared as an argument in a foreign function declaration.</source>
          <target state="translated">在一个外来函数声明中,一个模式被声明为一个参数。</target>
        </trans-unit>
        <trans-unit id="d00f0437e6924080d1afab40ce4328811dd1cc4e" translate="yes" xml:space="preserve">
          <source>A pinned pointer.</source>
          <target state="translated">一个销魂的指针。</target>
        </trans-unit>
        <trans-unit id="a57ac3109ff2b056cae1f3bd5a56c84d66c44184" translate="yes" xml:space="preserve">
          <source>A place that is valid for the duration of a program.</source>
          <target state="translated">一个在方案有效期内的地方。</target>
        </trans-unit>
        <trans-unit id="7d0a1c9d0822781050522c413844b46b3f9e19ec" translate="yes" xml:space="preserve">
          <source>A plugin/crate was declared but cannot be found.</source>
          <target state="translated">申报了一个插件/箱,但找不到。</target>
        </trans-unit>
        <trans-unit id="de1781b485888ee330b207b934e4f4c6b09830cf" translate="yes" xml:space="preserve">
          <source>A plugin/crate was declared but cannot be found. Erroneous code example:</source>
          <target state="translated">声明了一个插件/箱,但找不到。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="2db11183c5e69392e41fbe166caeebf1df741e85" translate="yes" xml:space="preserve">
          <source>A pointer to a trait type cannot be implicitly dereferenced by a pattern. Every trait defines a type, but because the size of trait implementers isn't fixed, this type has no compile-time size. Therefore, all accesses to trait types must be through pointers. If you encounter this error you should try to avoid dereferencing the pointer.</source>
          <target state="translated">一个指向trait类型的指针不能被模式隐式地派生。每个trait都定义了一个类型,但由于trait实现者的大小并不固定,这个类型没有编译时的大小。因此,所有对trait类型的访问都必须通过指针。如果遇到这个错误,你应该尽量避免去引用指针。</target>
        </trans-unit>
        <trans-unit id="34017de9c0f653b0f37f4a6965f6e339b6e3eb8f" translate="yes" xml:space="preserve">
          <source>A pointer type for heap allocation.</source>
          <target state="translated">一个用于堆分配的指针类型。</target>
        </trans-unit>
        <trans-unit id="068b4756f4660015d453841abd0c47d397debbf3" translate="yes" xml:space="preserve">
          <source>A poisoned &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">中毒&lt;a href=&quot;struct.once&quot;&gt; &lt;code&gt;Once&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="a8f3faefa5c5d4137483f566406d69333a9e2fb7" translate="yes" xml:space="preserve">
          <source>A poisoned &lt;code&gt;Once&lt;/code&gt;:</source>
          <target state="translated">中毒 &lt;code&gt;Once&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="929b0eef10b3144f1332f3b71eafbab8eba71fe6" translate="yes" xml:space="preserve">
          <source>A poisoned mutex, however, does not prevent all access to the underlying data. The &lt;a href=&quot;struct.poisonerror&quot;&gt;&lt;code&gt;PoisonError&lt;/code&gt;&lt;/a&gt; type has an &lt;a href=&quot;struct.poisonerror#method.into_inner&quot;&gt;&lt;code&gt;into_inner&lt;/code&gt;&lt;/a&gt; method which will return the guard that would have otherwise been returned on a successful lock. This allows access to the data, despite the lock being poisoned.</source>
          <target state="translated">但是，中毒的互斥锁不会阻止对底层数据的所有访问。该&lt;a href=&quot;struct.poisonerror&quot;&gt; &lt;code&gt;PoisonError&lt;/code&gt; &lt;/a&gt;类型有一个&lt;a href=&quot;struct.poisonerror#method.into_inner&quot;&gt; &lt;code&gt;into_inner&lt;/code&gt; &lt;/a&gt;方法将返回否则将被上成功锁定返回的后卫。尽管锁被中毒，这仍允许访问数据。</target>
        </trans-unit>
        <trans-unit id="73fd6c45e77753ba09fc6ae1f1a84a2bc4c2f7fb" translate="yes" xml:space="preserve">
          <source>A possible error value when converting a &lt;code&gt;String&lt;/code&gt; from a UTF-16 byte slice.</source>
          <target state="translated">从UTF-16字节片转换 &lt;code&gt;String&lt;/code&gt; 时可能出现的错误值。</target>
        </trans-unit>
        <trans-unit id="ffac94ea92c56dd95950816abb00c940a0255f3a" translate="yes" xml:space="preserve">
          <source>A possible error value when converting a &lt;code&gt;String&lt;/code&gt; from a UTF-8 byte vector.</source>
          <target state="translated">从UTF-8字节向量转换 &lt;code&gt;String&lt;/code&gt; 时可能出现的错误值。</target>
        </trans-unit>
        <trans-unit id="de325cfd40d79951f0c1e349c34b7cd70df1fbf9" translate="yes" xml:space="preserve">
          <source>A prelude for conveniently writing platform-specific code.</source>
          <target state="translated">方便编写平台专用代码的前奏。</target>
        </trans-unit>
        <trans-unit id="c5e33e24aca6a074f404567a2953c71b3f5c603f" translate="yes" xml:space="preserve">
          <source>A priority queue implemented with a binary heap.</source>
          <target state="translated">一个用二进制堆实现的优先级队列。</target>
        </trans-unit>
        <trans-unit id="839f5fda33c60277611f831c62b151f9e603547e" translate="yes" xml:space="preserve">
          <source>A private item was used outside its scope.</source>
          <target state="translated">一件私人物品在其范围外被使用。</target>
        </trans-unit>
        <trans-unit id="519be8a210afc21029c91c0c6f7917299f8dedbe" translate="yes" xml:space="preserve">
          <source>A private item was used outside of its scope.</source>
          <target state="translated">一件私人物品在其范围之外被使用。</target>
        </trans-unit>
        <trans-unit id="b050bad5b423d40a7cbc2510e0a714043fcaa01a" translate="yes" xml:space="preserve">
          <source>A private trait was used on a public type parameter bound.</source>
          <target state="translated">在一个公共类型参数绑定上使用了一个私有特征。</target>
        </trans-unit>
        <trans-unit id="94c921f0636467349880453e7613dadeb16d5d80" translate="yes" xml:space="preserve">
          <source>A private trait was used on a public type parameter bound. Erroneous code examples:</source>
          <target state="translated">在公共类型参数绑定上使用了一个私有性状。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="9a0df3af8cfe7414b96a23dc7a41a25700bb086e" translate="yes" xml:space="preserve">
          <source>A private type was used in a public type signature.</source>
          <target state="translated">在公共类型签名中使用了一个私有类型。</target>
        </trans-unit>
        <trans-unit id="5e925db174af759a11ddedae27575f0f853ed111" translate="yes" xml:space="preserve">
          <source>A private type was used in a public type signature. Erroneous code example:</source>
          <target state="translated">在公共类型签名中使用了一个私有类型。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="c311fafb046b4454c158177c3e7c9d9343861f7d" translate="yes" xml:space="preserve">
          <source>A process builder, providing fine-grained control over how a new process should be spawned.</source>
          <target state="translated">流程生成器,对新流程的生成方式提供精细的控制。</target>
        </trans-unit>
        <trans-unit id="b012d3c393a9f2ccaba1d026e4a05fd4cbe591b1" translate="yes" xml:space="preserve">
          <source>A quick refresher on memory ordering:</source>
          <target state="translated">快速复习记忆排序。</target>
        </trans-unit>
        <trans-unit id="63343f59c96578fe01a096392dc2051b122408d3" translate="yes" xml:space="preserve">
          <source>A random number that will generate some variety in the workout plans</source>
          <target state="translated">一个随机的数字,会产生一些不同的锻炼计划</target>
        </trans-unit>
        <trans-unit id="72b92a764b3becb3cc5dd577eea9f2e87d42d804" translate="yes" xml:space="preserve">
          <source>A range bounded inclusively below and above (&lt;code&gt;start..=end&lt;/code&gt;).</source>
          <target state="translated">范围包括上下两个边界（ &lt;code&gt;start..=end&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="79fc3105ea5313c5378041705247103257830779" translate="yes" xml:space="preserve">
          <source>A range only bounded exclusively above (&lt;code&gt;..end&lt;/code&gt;).</source>
          <target state="translated">仅在（ &lt;code&gt;..end&lt;/code&gt; ）上方限定范围。</target>
        </trans-unit>
        <trans-unit id="e19446803edcf89ddaf7319d7c6427759416990d" translate="yes" xml:space="preserve">
          <source>A range only bounded inclusively above (&lt;code&gt;..=end&lt;/code&gt;).</source>
          <target state="translated">一个范围仅包括（ &lt;code&gt;..=end&lt;/code&gt; ）以上的范围。</target>
        </trans-unit>
        <trans-unit id="74324727cee50500895944c74cdd394c1b31fc07" translate="yes" xml:space="preserve">
          <source>A range only bounded inclusively below (&lt;code&gt;start..&lt;/code&gt;).</source>
          <target state="translated">范围仅包括（ &lt;code&gt;start..&lt;/code&gt; ）以下范围。</target>
        </trans-unit>
        <trans-unit id="4f00d04637794ce3f904922bdb42fa3ce7f3d5fe" translate="yes" xml:space="preserve">
          <source>A raw identifier is like a normal identifier, but prefixed by &lt;code&gt;r#&lt;/code&gt;. (Note that the &lt;code&gt;r#&lt;/code&gt; prefix is not included as part of the actual identifier.) Unlike a normal identifier, a raw identifier may be any strict or reserved keyword except the ones listed above for &lt;code&gt;RAW_IDENTIFIER&lt;/code&gt;.</source>
          <target state="translated">原始标识符类似于普通标识符，但以 &lt;code&gt;r#&lt;/code&gt; 为前缀。（请注意， &lt;code&gt;r#&lt;/code&gt; 前缀不包含在实际标识符中。）与普通标识符不同，原始标识符可以是任何严格或保留的关键字，但上面列出的 &lt;code&gt;RAW_IDENTIFIER&lt;/code&gt; 除外。</target>
        </trans-unit>
        <trans-unit id="ffc636325c67605fadec2b68ebb55669b2cd9c34" translate="yes" xml:space="preserve">
          <source>A raw pointer type which can be safely shared between threads.</source>
          <target state="translated">一个可以在线程之间安全共享的原始指针类型。</target>
        </trans-unit>
        <trans-unit id="f1f955686d561bc8208f2ce3b12ca99c3765110a" translate="yes" xml:space="preserve">
          <source>A raw string isn't correctly terminated because the trailing &lt;code&gt;#&lt;/code&gt; count doesn't match its leading &lt;code&gt;#&lt;/code&gt; count.</source>
          <target state="translated">原始字符串未正确终止，因为结尾的 &lt;code&gt;#&lt;/code&gt; 计数与其前导的 &lt;code&gt;#&lt;/code&gt; 计数不匹配。</target>
        </trans-unit>
        <trans-unit id="20341b33140e6b08a4b41c1574d7c2c86bdc7608" translate="yes" xml:space="preserve">
          <source>A reader which is always at EOF.</source>
          <target state="translated">始终处于EOF的阅读器。</target>
        </trans-unit>
        <trans-unit id="5c0eac8aa6da425e06c685e18fd91d499e3c16f1" translate="yes" xml:space="preserve">
          <source>A reader which yields one byte over and over and over and over and over and...</source>
          <target state="translated">读取器会不断地产生一个字节,不断地产生一个字节,不断地产生一个字节,不断地产生一个字节......</target>
        </trans-unit>
        <trans-unit id="0187c58d40ebb5aaa0b543a6b1bda48ead05f016" translate="yes" xml:space="preserve">
          <source>A reader-writer lock</source>
          <target state="translated">读写器锁</target>
        </trans-unit>
        <trans-unit id="2d89d8dfb8b1c58f5d841e5165fcf975a6c55e6a" translate="yes" xml:space="preserve">
          <source>A recursive type has infinite size because it doesn't have an indirection.</source>
          <target state="translated">递归类型的大小是无限的,因为它没有内向性。</target>
        </trans-unit>
        <trans-unit id="414e2acfb8956698eab95c0efb754ad454841ffa" translate="yes" xml:space="preserve">
          <source>A reference has a longer lifetime than the data it references.</source>
          <target state="translated">一个引用比它所引用的数据有更长的寿命。</target>
        </trans-unit>
        <trans-unit id="8299c0d135b8f5441cc8858d8675b0fc5f91fcc2" translate="yes" xml:space="preserve">
          <source>A reference or &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; that is dangling, unaligned, or points to an invalid value.</source>
          <target state="translated">悬空，未对齐或指向无效值的引用或 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9108b5b496b508ef46e829906b2e7b5524691e8f" translate="yes" xml:space="preserve">
          <source>A reference represents a borrow of some owned value. You can get one by using the &lt;code&gt;&amp;amp;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut&lt;/code&gt; operators on a value, or by using a &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;ref mut&lt;/code&gt; pattern.</source>
          <target state="translated">参考代表某些拥有价值的借款。您可以通过在值上使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 或 &lt;code&gt;&amp;amp;mut&lt;/code&gt; 运算符，或使用 &lt;code&gt;ref&lt;/code&gt; 或 &lt;code&gt;ref mut&lt;/code&gt; 模式来获得一个。</target>
        </trans-unit>
        <trans-unit id="def229fac786a814e540383a36be7448c81c2810" translate="yes" xml:space="preserve">
          <source>A reference to a local variable was returned.</source>
          <target state="translated">返回了对一个局部变量的引用。</target>
        </trans-unit>
        <trans-unit id="9b45e7cfae560003198e2ac81c9a7e5c60325d0a" translate="yes" xml:space="preserve">
          <source>A reference to an open file on the filesystem.</source>
          <target state="translated">对文件系统中打开的文件的引用。</target>
        </trans-unit>
        <trans-unit id="cbf7d17da7f9b8415b894a96d3c62639060d8148" translate="yes" xml:space="preserve">
          <source>A reference to the current directory, i.e., &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="translated">对当前目录的引用，即 &lt;code&gt;.&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="54c4ba3b0f946cb73000b704747ed0cc043ef985" translate="yes" xml:space="preserve">
          <source>A reference to the parent directory, i.e., &lt;code&gt;..&lt;/code&gt;.</source>
          <target state="translated">父目录的引用，即 &lt;code&gt;..&lt;/code&gt; .。</target>
        </trans-unit>
        <trans-unit id="b305ff2e1e8a128729de5a06db133ccf46d493cc" translate="yes" xml:space="preserve">
          <source>A reference/pointer is &quot;dangling&quot; if it is null or not all of the bytes it points to are part of the same allocation (so in particular they all have to be part of &lt;em&gt;some&lt;/em&gt; allocation). The span of bytes it points to is determined by the pointer value and the size of the pointee type (using &lt;code&gt;size_of_val&lt;/code&gt;). As a consequence, if the span is empty, &quot;dangling&quot; is the same as &quot;non-null&quot;. Note that slices and strings point to their entire range, so it is important that the length metadata is never too large. In particular, allocations and therefore slices and strings cannot be bigger than &lt;code&gt;isize::MAX&lt;/code&gt; bytes.</source>
          <target state="translated">如果引用/指针为null或它指向的所有字节都不是同一分配的一部分，则它是&amp;ldquo;悬挂的&amp;rdquo;（因此特别是它们都必须是&lt;em&gt;某个&lt;/em&gt;分配的一部分）。它指向的字节范围由指针值和指针类型的大小确定（使用 &lt;code&gt;size_of_val&lt;/code&gt; ）。结果，如果跨度为空，则&amp;ldquo;悬挂&amp;rdquo;与&amp;ldquo;非空&amp;rdquo;相同。请注意，切片和字符串指向它们的整个范围，因此，长度元数据永远不要太大是很重要的。特别是，分配以及因此的切片和字符串不能大于 &lt;code&gt;isize::MAX&lt;/code&gt; 字节。</target>
        </trans-unit>
        <trans-unit id="771deb0451fb407b0fb913d5488c53c42558785c" translate="yes" xml:space="preserve">
          <source>A regular floating point number.</source>
          <target state="translated">一个常规的浮点数。</target>
        </trans-unit>
        <trans-unit id="cd85c1b05128e75e217b61f7154c9636692d1cea" translate="yes" xml:space="preserve">
          <source>A regular reference is a type of pointer, and one way to think of a pointer is as an arrow to a value stored somewhere else. In Listing 15-6, we create a reference to an &lt;code&gt;i32&lt;/code&gt; value and then use the dereference operator to follow the reference to the data:</source>
          <target state="translated">常规引用是指针的一种，想到指针的一种方式是将箭头指向存储在其他位置的值。在清单15-6中，我们创建对 &lt;code&gt;i32&lt;/code&gt; 值的引用，然后使用解引用运算符跟随对数据的引用：</target>
        </trans-unit>
        <trans-unit id="461658f899b03c712ef32df7b204d3908a10ea3a" translate="yes" xml:space="preserve">
          <source>A related concept is scope: the nested context in which code is written has a set of names that are defined as &amp;ldquo;in scope.&amp;rdquo; When reading, writing, and compiling code, programmers and compilers need to know whether a particular name at a particular spot refers to a variable, function, struct, enum, module, constant, or other item and what that item means. You can create scopes and change which names are in or out of scope. You can&amp;rsquo;t have two items with the same name in the same scope; tools are available to resolve name conflicts.</source>
          <target state="translated">一个相关的概念是范围：在其中编写代码的嵌套上下文具有一组定义为&amp;ldquo;在范围内&amp;rdquo;的名称。在读取，编写和编译代码时，程序员和编译器需要知道特定位置的特定名称是否指向变量，函数，结构，枚举，模块，常量或其他项目，以及该项目的含义。您可以创建范围并更改哪些名称在范围内或范围外。同一范围内不能有两个具有相同名称的项目。提供了一些工具来解决名称冲突。</target>
        </trans-unit>
        <trans-unit id="4629afc869292537f9c628724559e37eef9a2cb2" translate="yes" xml:space="preserve">
          <source>A repeat expression &lt;code&gt;[x; N]&lt;/code&gt;, which produces an array with &lt;code&gt;N&lt;/code&gt; copies of &lt;code&gt;x&lt;/code&gt;. The type of &lt;code&gt;x&lt;/code&gt; must be &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">重复表达式 &lt;code&gt;[x; N]&lt;/code&gt; ，这将产生一个数组，其中包含 &lt;code&gt;x&lt;/code&gt; 的 &lt;code&gt;N&lt;/code&gt; 个副本。 &lt;code&gt;x&lt;/code&gt; 的类型必须为&lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3238c87767b981c84fc407d2a6b89dd0a8979fcd" translate="yes" xml:space="preserve">
          <source>A restriction is imposed on the shebang syntax to avoid confusion with an &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt;. The &lt;code&gt;#!&lt;/code&gt; characters must not be followed by a &lt;code&gt;[&lt;/code&gt; token, ignoring intervening &lt;a href=&quot;comments&quot;&gt;comments&lt;/a&gt; or &lt;a href=&quot;whitespace&quot;&gt;whitespace&lt;/a&gt;. If this restriction fails, then it is not treated as a shebang, but instead as the start of an attribute.</source>
          <target state="translated">对shebang语法施加了限制，以避免与&lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;混淆。该 &lt;code&gt;#!&lt;/code&gt; 字符后不能带 &lt;code&gt;[&lt;/code&gt; 标记，忽略中间的&lt;a href=&quot;comments&quot;&gt;注释&lt;/a&gt;或&lt;a href=&quot;whitespace&quot;&gt;空格&lt;/a&gt;。如果此限制失败，则不会将其视为shebang，而是将其视为属性的开始。</target>
        </trans-unit>
        <trans-unit id="6bdd3de922c246975bfd1cbfd244a2a660fcbad2" translate="yes" xml:space="preserve">
          <source>A return statement was found outside of a function body.</source>
          <target state="translated">在函数体外发现一条返回语句。</target>
        </trans-unit>
        <trans-unit id="80cb47a4163ef3f70e5ddff5f65587e6f1ef80e1" translate="yes" xml:space="preserve">
          <source>A reverse searcher for a string pattern.</source>
          <target state="translated">一个字符串模式的反向搜索器。</target>
        </trans-unit>
        <trans-unit id="4d45eae920f51ae4fa809b8359142e43a5dccbee" translate="yes" xml:space="preserve">
          <source>A scrutinee is the expression that is matched on in &lt;code&gt;match&lt;/code&gt; expressions and similar pattern matching constructs. For example, in &lt;code&gt;match x { A =&amp;gt; 1, B =&amp;gt; 2 }&lt;/code&gt;, the expression &lt;code&gt;x&lt;/code&gt; is the scrutinee.</source>
          <target state="translated">scrutinee是在 &lt;code&gt;match&lt;/code&gt; 表达式和类似模式匹配构造中匹配的表达式。例如，在 &lt;code&gt;match x { A =&amp;gt; 1, B =&amp;gt; 2 }&lt;/code&gt; ，表达式 &lt;code&gt;x&lt;/code&gt; 是scrutinee。</target>
        </trans-unit>
        <trans-unit id="090be4c47ade9f54015d614891f57e36867218e4" translate="yes" xml:space="preserve">
          <source>A searcher for a string pattern.</source>
          <target state="translated">一个字符串模式的搜索器。</target>
        </trans-unit>
        <trans-unit id="805b0de6f894d8345c096cc31db6d9d15c14c18a" translate="yes" xml:space="preserve">
          <source>A seek beyond the end of a stream is allowed, but behavior is defined by the implementation.</source>
          <target state="translated">允许在流的末端之外进行寻找,但行为由实现来定义。</target>
        </trans-unit>
        <trans-unit id="187cb85d876dbb3e8278047d50cee3e8447cafbc" translate="yes" xml:space="preserve">
          <source>A set based on a B-Tree.</source>
          <target state="translated">基于B树的集合。</target>
        </trans-unit>
        <trans-unit id="89f39617bf1d1e8280f2895b2baeee66b493c8f3" translate="yes" xml:space="preserve">
          <source>A similar error is E0201. The difference is whether there is one declaration block or not. To avoid this error, you must give each &lt;code&gt;fn&lt;/code&gt; a unique name.</source>
          <target state="translated">类似的错误是E0201。区别在于是否有一个声明块。为避免此错误，必须为每个 &lt;code&gt;fn&lt;/code&gt; 赋予唯一的名称。</target>
        </trans-unit>
        <trans-unit id="6f6761295ae70019a0d2d6374dca4eaf6df07696" translate="yes" xml:space="preserve">
          <source>A similar rule exists for combining mutable and immutable references. This code results in an error:</source>
          <target state="translated">类似的规则也存在于可变和不可变引用的组合。这段代码会导致一个错误。</target>
        </trans-unit>
        <trans-unit id="8e839688e01ba01e9dfe145feb09335f1aa963d0" translate="yes" xml:space="preserve">
          <source>A simple example:</source>
          <target state="translated">一个简单的例子。</target>
        </trans-unit>
        <trans-unit id="823d579a067f8a96f5626154ea604d86f19d68ef" translate="yes" xml:space="preserve">
          <source>A simple function returning &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; might be defined and used like so:</source>
          <target state="translated">返回&lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;的简单函数可以这样定义和使用：</target>
        </trans-unit>
        <trans-unit id="d53eef6dd046b01cc7902a1c3902a172dad006e2" translate="yes" xml:space="preserve">
          <source>A simple spinlock:</source>
          <target state="translated">一个简单的旋锁。</target>
        </trans-unit>
        <trans-unit id="a2f952715a286d980e4f33b8e4525dcb3eac03bb" translate="yes" xml:space="preserve">
          <source>A simple workaround is to use a helper method instead:</source>
          <target state="translated">一个简单的变通方法是使用辅助方法来代替。</target>
        </trans-unit>
        <trans-unit id="054dbf6f392fa38162c0d62e6ead09a79999e53b" translate="yes" xml:space="preserve">
          <source>A simple wrapper around a type to assert that it is unwind safe.</source>
          <target state="translated">一个简单的包装器,围绕着一个类型来断言它是安全的。</target>
        </trans-unit>
        <trans-unit id="b53617da96fc2eac5eec0b6bb0e92f32c47fc76e" translate="yes" xml:space="preserve">
          <source>A single (arbitrary) thread will receive a &lt;a href=&quot;struct.barrierwaitresult&quot;&gt;&lt;code&gt;BarrierWaitResult&lt;/code&gt;&lt;/a&gt; that returns &lt;code&gt;true&lt;/code&gt; from &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt;&lt;code&gt;BarrierWaitResult::is_leader()&lt;/code&gt;&lt;/a&gt; when returning from this function, and all other threads will receive a result that will return &lt;code&gt;false&lt;/code&gt; from &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt;&lt;code&gt;BarrierWaitResult::is_leader()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">从该函数返回时，单个（任意）线程将收到&lt;a href=&quot;struct.barrierwaitresult&quot;&gt; &lt;code&gt;BarrierWaitResult&lt;/code&gt; &lt;/a&gt;，该结果从&lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt; &lt;code&gt;BarrierWaitResult::is_leader()&lt;/code&gt; &lt;/a&gt;返回 &lt;code&gt;true&lt;/code&gt; ，所有其他线程将从&lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt; &lt;code&gt;BarrierWaitResult::is_leader()&lt;/code&gt; &lt;/a&gt;返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd3fd0649d54745c9dde4e2f256bda95babba9f6" translate="yes" xml:space="preserve">
          <source>A single (arbitrary) thread will receive a &lt;a href=&quot;struct.barrierwaitresult&quot;&gt;&lt;code&gt;BarrierWaitResult&lt;/code&gt;&lt;/a&gt; that returns &lt;code&gt;true&lt;/code&gt; from &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt;&lt;code&gt;is_leader&lt;/code&gt;&lt;/a&gt; when returning from this function, and all other threads will receive a result that will return &lt;code&gt;false&lt;/code&gt; from &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt;&lt;code&gt;is_leader&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">单（任意）线程将收到一个&lt;a href=&quot;struct.barrierwaitresult&quot;&gt; &lt;code&gt;BarrierWaitResult&lt;/code&gt; &lt;/a&gt;回返 &lt;code&gt;true&lt;/code&gt; 从&lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt; &lt;code&gt;is_leader&lt;/code&gt; &lt;/a&gt;从这个函数返回时，和所有其他的线程将收到一个结果，将返回 &lt;code&gt;false&lt;/code&gt; 的&lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt; &lt;code&gt;is_leader&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0e774847b8b17cfc775f96b4b6ba3419133c2ae2" translate="yes" xml:space="preserve">
          <source>A single &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; may be encoded as more than one byte. This method can only succeed if the entire byte sequence was successfully written, and this method will not return until all data has been written or an error occurs.</source>
          <target state="translated">单个&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;可以被编码为一个以上的字节。仅当成功写入了整个字节序列后，此方法才能成功，并且直到所有数据都已写入或发生错误后，该方法才会返回。</target>
        </trans-unit>
        <trans-unit id="a7ad66dadfa2951ac2cd349b4d260c6f6b28c527" translate="yes" xml:space="preserve">
          <source>A single &lt;em&gt;decimal literal&lt;/em&gt; followed by an &lt;em&gt;exponent&lt;/em&gt;.</source>
          <target state="translated">单个&lt;em&gt;十进制文字，&lt;/em&gt;后跟一个&lt;em&gt;指数&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="538d82224c466a3fa46957bd1dad7926fc97c926" translate="yes" xml:space="preserve">
          <source>A single component of a path.</source>
          <target state="translated">路径的一个组成部分。</target>
        </trans-unit>
        <trans-unit id="2286204503218f0f2c8d94ba2bb110e020e0bc00" translate="yes" xml:space="preserve">
          <source>A single-threaded reference-counting pointer. 'Rc' stands for 'Reference Counted'.</source>
          <target state="translated">一个单线程的引用计数指针。Rc'代表'Reference Counted'。</target>
        </trans-unit>
        <trans-unit id="5b101d21362e496b89adfac2fbb37a58e0757a7e" translate="yes" xml:space="preserve">
          <source>A slice is a &lt;a href=&quot;../dynamically-sized-types&quot;&gt;dynamically sized type&lt;/a&gt; representing a 'view' into a sequence of elements of type &lt;code&gt;T&lt;/code&gt;. The slice type is written as &lt;code&gt;[T]&lt;/code&gt;.</source>
          <target state="translated">切片是&lt;a href=&quot;../dynamically-sized-types&quot;&gt;动态大小的类型，&lt;/a&gt;表示对类型 &lt;code&gt;T&lt;/code&gt; 的元素序列的&amp;ldquo;视图&amp;rdquo; 。切片类型写为 &lt;code&gt;[T]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aba616073ac3de8beab95ccfac7bd633d599946d" translate="yes" xml:space="preserve">
          <source>A slice is dynamically-sized view into a contiguous sequence, written as &lt;code&gt;[T]&lt;/code&gt;.</source>
          <target state="translated">切片是动态大小的视图，显示为连续序列，写为 &lt;code&gt;[T]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe635e064516decbfbc3e3d9ce043f9d25e8ca9f" translate="yes" xml:space="preserve">
          <source>A slice of a path (akin to &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">路径的一部分（类似于&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2759e6b662ba691ba47b65069c920c9b980fcd79" translate="yes" xml:space="preserve">
          <source>A slice of a path (akin to &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">路径的一部分（类似于&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="11824dd936b3023e24b3affd0ef64f49ba6ed2c9" translate="yes" xml:space="preserve">
          <source>A slightly sad example of not reading anything into a buffer:</source>
          <target state="translated">一个略带悲哀的例子,没有将任何东西读入缓冲区。</target>
        </trans-unit>
        <trans-unit id="45dafb0f63eaca5bfb7f56b27e11fa2b7d396e89" translate="yes" xml:space="preserve">
          <source>A socket address could not be bound because the address is already in use elsewhere.</source>
          <target state="translated">套接字地址不能被绑定,因为该地址已经在其他地方使用。</target>
        </trans-unit>
        <trans-unit id="ac2b051bc6a92539c672158c6142e1d18c98d73f" translate="yes" xml:space="preserve">
          <source>A somewhat surprising consequence of the definition is that &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt; (if &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt;) even though it seems like that might provide unsynchronized mutation. The trick is that a mutable reference behind a shared reference (that is, &lt;code&gt;&amp;amp; &amp;amp;mut T&lt;/code&gt;) becomes read-only, as if it were a &lt;code&gt;&amp;amp; &amp;amp;T&lt;/code&gt;. Hence there is no risk of a data race.</source>
          <target state="translated">该定义的一个令人惊讶的结果是 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 是 &lt;code&gt;Sync&lt;/code&gt; （如果 &lt;code&gt;T&lt;/code&gt; 是 &lt;code&gt;Sync&lt;/code&gt; ），即使看起来可能提供了不同步的突变。诀窍是，共享引用（即 &lt;code&gt;&amp;amp; &amp;amp;mut T&lt;/code&gt; ）后面的可变引用变为只读，就好像它是 &lt;code&gt;&amp;amp; &amp;amp;T&lt;/code&gt; 。因此，不存在数据争用的风险。</target>
        </trans-unit>
        <trans-unit id="2194c015edca7318deaf09554d0cad9263a5128b" translate="yes" xml:space="preserve">
          <source>A source file can have a &lt;a href=&quot;https://en.wikipedia.org/wiki/Shebang_(Unix)&quot;&gt;&lt;em&gt;shebang&lt;/em&gt;&lt;/a&gt; (SHEBANG production), which indicates to the operating system what program to use to execute this file. It serves essentially to treat the source file as an executable script. The shebang can only occur at the beginning of the file (but after the optional &lt;em&gt;UTF8BOM&lt;/em&gt;). It is ignored by the compiler. For example:</source>
          <target state="translated">源文件可以具有&lt;a href=&quot;https://en.wikipedia.org/wiki/Shebang_(Unix)&quot;&gt;&lt;em&gt;shebang&lt;/em&gt;&lt;/a&gt;（SHEBANG生产），它向操作系统指示要使用什么程序来执行此文件。它本质上用于将源文件视为可执行脚本。shebang只能出现在文件的开头（但是在可选的&lt;em&gt;UTF8BOM之后&lt;/em&gt;）。编译器将忽略它。例如：</target>
        </trans-unit>
        <trans-unit id="5ec62fb18603ebc6519f469782df4169fc5a681f" translate="yes" xml:space="preserve">
          <source>A source stage in an iterator pipeline.</source>
          <target state="translated">迭代器管道中的源阶段。</target>
        </trans-unit>
        <trans-unit id="3a13e4ab897112a5bbfa779986c13ffc8249c723" translate="yes" xml:space="preserve">
          <source>A specialized &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type for I/O operations.</source>
          <target state="translated">I / O操作的特殊&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;类型。</target>
        </trans-unit>
        <trans-unit id="29c08563a92ed84161c48f32442e9c55ea57c60e" translate="yes" xml:space="preserve">
          <source>A specialized &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type for threads.</source>
          <target state="translated">线程的特殊&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;类型。</target>
        </trans-unit>
        <trans-unit id="c3d479aee422ab65a96675342bd98a8476bf0c50" translate="yes" xml:space="preserve">
          <source>A splicing iterator for &lt;code&gt;Vec&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Vec&lt;/code&gt; 的拼接迭代器。</target>
        </trans-unit>
        <trans-unit id="382d455769d00569a95a026174c2cb511f9bbb7a" translate="yes" xml:space="preserve">
          <source>A stability attribute has been used outside of the standard library.</source>
          <target state="translated">在标准库之外还使用了一个稳定性属性。</target>
        </trans-unit>
        <trans-unit id="9c6a5b448820983a6050fcd10b6c3d4dd333f376" translate="yes" xml:space="preserve">
          <source>A stability attribute was used outside of the standard library.</source>
          <target state="translated">在标准库之外使用了一个稳定性属性。</target>
        </trans-unit>
        <trans-unit id="7208bc1e59d67cb800b9b249868cce02c7e08ab0" translate="yes" xml:space="preserve">
          <source>A stability attribute was used outside of the standard library. Erroneous code example:</source>
          <target state="translated">在标准库之外使用了一个稳定性属性。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="c28a8a30c83d119da8eeb5ad945a45667f90aa8f" translate="yes" xml:space="preserve">
          <source>A statement is the smallest standalone element of a programming language that commands a computer to perform an action.</source>
          <target state="translated">语句是编程语言中最小的独立元素,它命令计算机执行一个动作。</target>
        </trans-unit>
        <trans-unit id="7993655a3c3f53e3aa0f9baecc01e8b1f97ae73b" translate="yes" xml:space="preserve">
          <source>A statement.</source>
          <target state="translated">一份声明;</target>
        </trans-unit>
        <trans-unit id="d137e324ac57303f829812294caa15b53500d48e" translate="yes" xml:space="preserve">
          <source>A static item is a value which is valid for the entire duration of your program (a &lt;code&gt;'static&lt;/code&gt; lifetime).</source>
          <target state="translated">静态项目是在程序的整个持续时间内有效的值（ &lt;code&gt;'static&lt;/code&gt; 生命周期&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="1525834046325d03a0ffcca63064524577af3217" translate="yes" xml:space="preserve">
          <source>A string (&lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;) is made of bytes (&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;), and a vector of bytes (&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;&lt;/a&gt;) is made of bytes, so this function converts between the two. Not all byte slices are valid &lt;code&gt;String&lt;/code&gt;s, however: &lt;code&gt;String&lt;/code&gt; requires that it is valid UTF-8. &lt;code&gt;from_utf8()&lt;/code&gt; checks to ensure that the bytes are valid UTF-8, and then does the conversion.</source>
          <target state="translated">字符串（&lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;）由字节（&lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt;）组成，字节向量（&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; &lt;/a&gt;）由字节组成，因此此函数在两者之间进行转换。并非所有的字节片都是有效的 &lt;code&gt;String&lt;/code&gt; ，但是： &lt;code&gt;String&lt;/code&gt; 要求它是有效的UTF-8。 &lt;code&gt;from_utf8()&lt;/code&gt; 检查以确保字节有效的UTF-8，然后进行转换。</target>
        </trans-unit>
        <trans-unit id="d8b0000fb42f01e7695f858d20347ce505d823eb" translate="yes" xml:space="preserve">
          <source>A string describing the architecture of the CPU that is currently in use.</source>
          <target state="translated">描述当前使用的CPU架构的字符串。</target>
        </trans-unit>
        <trans-unit id="5df1b3a45cf6eb695745e50e624d24676a48e8a7" translate="yes" xml:space="preserve">
          <source>A string describing the specific operating system in use. Example value is &lt;code&gt;linux&lt;/code&gt;.</source>
          <target state="translated">描述正在使用的特定操作系统的字符串。示例值为 &lt;code&gt;linux&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8947468201a55a4ba9cd06d3d0a2f1ff1271df73" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. 'Left' in this context means the first position of that byte string; for a language like Arabic or Hebrew which are 'right to left' rather than 'left to right', this will be the &lt;em&gt;right&lt;/em&gt; side, not the left.</source>
          <target state="translated">字符串是字节序列。在这种情况下，&amp;ldquo;左&amp;rdquo;是指该字节字符串的第一个位置；对于像阿拉伯语或希伯来语这样的语言，&amp;ldquo;从右到左&amp;rdquo;而不是&amp;ldquo;从左到右&amp;rdquo;，这将是&lt;em&gt;右侧&lt;/em&gt;，而不是左侧。</target>
        </trans-unit>
        <trans-unit id="0bc83c493a049c765d2dfbebad0f09d82d1b6fde" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. 'Right' in this context means the last position of that byte string; for a language like Arabic or Hebrew which are 'right to left' rather than 'left to right', this will be the &lt;em&gt;left&lt;/em&gt; side, not the right.</source>
          <target state="translated">字符串是字节序列。在这种情况下，&amp;ldquo;右&amp;rdquo;表示该字节字符串的最后位置；对于像阿拉伯语或希伯来语这样的语言，&amp;ldquo;从右到左&amp;rdquo;而不是&amp;ldquo;从左到右&amp;rdquo;，这将是&lt;em&gt;左侧&lt;/em&gt;，而不是右侧。</target>
        </trans-unit>
        <trans-unit id="a7d73837e1ae6f385cc7b12b321574d70650bd43" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. &lt;code&gt;end&lt;/code&gt; in this context means the last position of that byte string; for a left-to-right language like English or Russian, this will be right side, and for right-to-left languages like Arabic or Hebrew, this will be the left side.</source>
          <target state="translated">字符串是字节序列。在此上下文中的 &lt;code&gt;end&lt;/code&gt; 表示该字节字符串的最后位置；对于从左到右的语言（例如英语或俄语），这将在右侧；对于从右到左的语言（例如阿拉伯语或希伯来语），将在左侧。</target>
        </trans-unit>
        <trans-unit id="fd472172ba3e393c6a98b65077b0a65554fdb8e3" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. &lt;code&gt;end&lt;/code&gt; in this context means the last position of that byte string; for a left-to-right language like English or Russian, this will be right side, and for right-to-left languages like like Arabic or Hebrew, this will be the left side.</source>
          <target state="translated">字符串是字节序列。在此上下文中的 &lt;code&gt;end&lt;/code&gt; 表示该字节字符串的最后位置；对于像英语或俄语这样的从左到右的语言，这将是右侧；对于像阿拉伯语或希伯来语这样的从右到左的语言，它将是左侧。</target>
        </trans-unit>
        <trans-unit id="8add450b8d835c6c86dcce6d9f4412fe207173ed" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. &lt;code&gt;start&lt;/code&gt; in this context means the first position of that byte string; for a left-to-right language like English or Russian, this will be left side, and for right-to-left languages like Arabic or Hebrew, this will be the right side.</source>
          <target state="translated">字符串是字节序列。在此上下文中，&amp;ldquo; &lt;code&gt;start&lt;/code&gt; 表示该字节字符串的第一个位置；对于从左到右的语言（例如英语或俄语），这将是左侧；对于从右到左的语言（例如阿拉伯语或希伯来语），这将是右侧。</target>
        </trans-unit>
        <trans-unit id="b8e69c41862936bd74ab07a7db3ea33fabc1421d" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. &lt;code&gt;start&lt;/code&gt; in this context means the first position of that byte string; for a left-to-right language like English or Russian, this will be left side, and for right-to-left languages like like Arabic or Hebrew, this will be the right side.</source>
          <target state="translated">字符串是字节序列。在这种情况下， &lt;code&gt;start&lt;/code&gt; 表示该字节字符串的第一个位置；对于从左到右的语言（例如英语或俄语），这将是左侧；对于从右到左的语言（例如阿拉伯语或希伯来语），这将是右侧。</target>
        </trans-unit>
        <trans-unit id="3af90a5c6860195d31687a2b123d3690f30cc3df" translate="yes" xml:space="preserve">
          <source>A string literal is a string stored directly in the final binary, and so will be valid for the &lt;code&gt;'static&lt;/code&gt; duration.</source>
          <target state="translated">字符串文字是直接存储在最终二进制文件中的字符串，因此在 &lt;code&gt;'static&lt;/code&gt; 持续时间&amp;rdquo;内有效。</target>
        </trans-unit>
        <trans-unit id="72d1187b478d157904cca7877538ced2b416e35f" translate="yes" xml:space="preserve">
          <source>A string pattern.</source>
          <target state="translated">一个字符串模式。</target>
        </trans-unit>
        <trans-unit id="067ff927875044f01fc32c9a4450dd787608c362" translate="yes" xml:space="preserve">
          <source>A string slice (&lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;) is made of bytes (&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;), and a byte slice (&lt;a href=&quot;../primitive.slice&quot;&gt;&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;&lt;/a&gt;) is made of bytes, so this function converts between the two. Not all byte slices are valid string slices, however: &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; requires that it is valid UTF-8. &lt;code&gt;from_utf8()&lt;/code&gt; checks to ensure that the bytes are valid UTF-8, and then does the conversion.</source>
          <target state="translated">字符串切片（&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;）由字节（&lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt;）组成，而字节切片（&lt;a href=&quot;../primitive.slice&quot;&gt; &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; &lt;/a&gt;）由字节组成，因此此函数在两者之间进行转换。并非所有的字节片都是有效的字符串片，但是：&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;要求它是有效的UTF-8。 &lt;code&gt;from_utf8()&lt;/code&gt; 检查以确保字节有效的UTF-8，然后进行转换。</target>
        </trans-unit>
        <trans-unit id="e7464828dc4f92a12dd0ad9693849275688a2fde" translate="yes" xml:space="preserve">
          <source>A string slice (&lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;) is made of bytes (&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;), and a vector of bytes (&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;&lt;/a&gt;) is made of bytes, so this function converts between the two. Not all byte slices are valid &lt;code&gt;String&lt;/code&gt;s, however: &lt;code&gt;String&lt;/code&gt; requires that it is valid UTF-8. &lt;code&gt;from_utf8()&lt;/code&gt; checks to ensure that the bytes are valid UTF-8, and then does the conversion.</source>
          <target state="translated">字符串切片（&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;）由字节（&lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt;）组成，字节向量（&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; &lt;/a&gt;）由字节组成，因此此函数在两者之间进行转换。并非所有的字节片都是有效的 &lt;code&gt;String&lt;/code&gt; ，但是： &lt;code&gt;String&lt;/code&gt; 要求它是有效的UTF-8。 &lt;code&gt;from_utf8()&lt;/code&gt; 检查以确保字节有效的UTF-8，然后进行转换。</target>
        </trans-unit>
        <trans-unit id="185b4c50dbb326aeb04eb1f2bab9a2d41dd7280a" translate="yes" xml:space="preserve">
          <source>A string slice is the most primitive string type in Rust, written as &lt;code&gt;str&lt;/code&gt;. It is often seen in its borrowed forms, either mutable or shared. The shared string slice type is &lt;code&gt;&amp;amp;str&lt;/code&gt;, while the mutable string slice type is &lt;code&gt;&amp;amp;mut str&lt;/code&gt;.</source>
          <target state="translated">字符串切片是Rust中最原始的字符串类型，写为 &lt;code&gt;str&lt;/code&gt; 。它经常以借用的形式出现，可以是可变的也可以是共享的。共享的字符串切片类型为 &lt;code&gt;&amp;amp;str&lt;/code&gt; ，而可变的字符串切片类型为 &lt;code&gt;&amp;amp;mut str&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="696c15b61497eb0b1cb08d222cb16dce5b4582da" translate="yes" xml:space="preserve">
          <source>A struct can be &lt;code&gt;Copy&lt;/code&gt;, and &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;Copy&lt;/code&gt;, therefore &lt;code&gt;Point&lt;/code&gt; is eligible to be &lt;code&gt;Copy&lt;/code&gt;. By contrast, consider</source>
          <target state="translated">struct可以是 &lt;code&gt;Copy&lt;/code&gt; ，而&lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt;是 &lt;code&gt;Copy&lt;/code&gt; ，因此 &lt;code&gt;Point&lt;/code&gt; 可以被 &lt;code&gt;Copy&lt;/code&gt; 。相比之下，考虑</target>
        </trans-unit>
        <trans-unit id="eb9b96b59ca1189f15dc2a933aeadc425813dff3" translate="yes" xml:space="preserve">
          <source>A struct constructor with private fields was invoked.</source>
          <target state="translated">调用了一个带有私有字段的结构体构造函数。</target>
        </trans-unit>
        <trans-unit id="f5d13af10075668c4266bfa2af5c2d787c33d9d3" translate="yes" xml:space="preserve">
          <source>A struct constructor with private fields was invoked. Erroneous code example:</source>
          <target state="translated">调用了一个带有私有字段的结构体构造函数。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="d5d8cb072da62f16419c7934c8ea02767949e9d6" translate="yes" xml:space="preserve">
          <source>A struct containing information about the location of a panic.</source>
          <target state="translated">一个包含恐慌位置信息的结构。</target>
        </trans-unit>
        <trans-unit id="4cbc7f2982657f6ecdc97f40e8df1ad547c2b1e9" translate="yes" xml:space="preserve">
          <source>A struct expression can terminate with the syntax &lt;code&gt;..&lt;/code&gt; followed by an expression to denote a functional update. The expression following &lt;code&gt;..&lt;/code&gt; (the base) must have the same struct type as the new struct type being formed.</source>
          <target state="translated">结构表达式可以以 &lt;code&gt;..&lt;/code&gt; 语法结尾，后跟表示功能更新的表达式。 &lt;code&gt;..&lt;/code&gt; （基本）之后的表达式必须具有与正在形成的新结构类型相同的结构类型。</target>
        </trans-unit>
        <trans-unit id="86c4b8e1d72da61f04333be84148a5de11fccd79" translate="yes" xml:space="preserve">
          <source>A struct expression with fields enclosed in curly braces allows you to specify the value for each individual field in any order. The field name is separated from its value with a colon.</source>
          <target state="translated">用大括号括住字段的结构表达式允许你以任何顺序指定每个字段的值。字段名与其值之间用冒号分开。</target>
        </trans-unit>
        <trans-unit id="89ddcc2481a3b96d64219755d7c1825c0ff65c03" translate="yes" xml:space="preserve">
          <source>A struct expression with fields enclosed in parentheses constructs a tuple struct. Though it is listed here as a specific expression for completeness, it is equivalent to a &lt;a href=&quot;call-expr&quot;&gt;call expression&lt;/a&gt; to the tuple struct's constructor. For example:</source>
          <target state="translated">带有括在括号中的字段的结构表达式构造一个元组结构。尽管此处出于完整性考虑将其列为特定的表达式，但它等效于元组结构的构造函数的&lt;a href=&quot;call-expr&quot;&gt;调用表达式&lt;/a&gt;。例如：</target>
        </trans-unit>
        <trans-unit id="4a5683978535ef36d2f4a36fc97769f59882d764" translate="yes" xml:space="preserve">
          <source>A struct pattern attempted to extract a non-existent field from a struct.</source>
          <target state="translated">一个结构模式试图从一个结构中提取一个不存在的字段。</target>
        </trans-unit>
        <trans-unit id="fed041bebb665ccd5885e8c57eed09e9404a7bab" translate="yes" xml:space="preserve">
          <source>A struct pattern is refutable when one of its subpatterns is refutable.</source>
          <target state="translated">当一个结构模式的一个子模式是可反驳的。</target>
        </trans-unit>
        <trans-unit id="7845438dcb42a82b5f335b8afeff28c09f01fb02" translate="yes" xml:space="preserve">
          <source>A struct providing information about a panic.</source>
          <target state="translated">提供恐慌信息的结构。</target>
        </trans-unit>
        <trans-unit id="2e74ee410a88a7bd4dc9ec3e4439e1be7c03f52f" translate="yes" xml:space="preserve">
          <source>A struct to help with &lt;a href=&quot;trait.debug&quot;&gt;&lt;code&gt;fmt::Debug&lt;/code&gt;&lt;/a&gt; implementations.</source>
          <target state="translated">帮助&lt;a href=&quot;trait.debug&quot;&gt; &lt;code&gt;fmt::Debug&lt;/code&gt; &lt;/a&gt;实现的结构。</target>
        </trans-unit>
        <trans-unit id="878d9a84ea5b4c1dd0e00cf0901eb339704e2d00" translate="yes" xml:space="preserve">
          <source>A struct was declared with two fields having the same name.</source>
          <target state="translated">声明了一个结构,其中有两个名称相同的字段。</target>
        </trans-unit>
        <trans-unit id="5cc6e14f7d3ffa0d43917de969f7811f2b833f5b" translate="yes" xml:space="preserve">
          <source>A struct with a single field which is accessible by dereferencing the struct.</source>
          <target state="translated">一个带有单个字段的结构,可以通过对该结构的引申来访问。</target>
        </trans-unit>
        <trans-unit id="804d90713791042aa7ae7163ec47b488d14fba5e" translate="yes" xml:space="preserve">
          <source>A struct with a single field which is modifiable by dereferencing the struct.</source>
          <target state="translated">一个带有单个字段的结构,可以通过对该结构的引用进行修改。</target>
        </trans-unit>
        <trans-unit id="0888572f00b05df1f9ff3f22503c0dc7eb90c709" translate="yes" xml:space="preserve">
          <source>A struct with more than one field containing an unsized type cannot implement &lt;code&gt;CoerceUnsized&lt;/code&gt;. This only occurs when you are trying to coerce one of the types in your struct to another type in the struct. In this case we try to impl &lt;code&gt;CoerceUnsized&lt;/code&gt; from &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;U&lt;/code&gt; which are both types that the struct takes. An &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;unsized type&lt;/a&gt; is any type that the compiler doesn't know the length or alignment of at compile time. Any struct containing an unsized type is also unsized.</source>
          <target state="translated">具有多个字段且包含 &lt;code&gt;CoerceUnsized&lt;/code&gt; 类型的结构不能实现CoerceUnsized。仅当您尝试将结构中的一种类型强制转换为结构中的另一种类型时，才会发生这种情况。在这种情况下，我们尝试将 &lt;code&gt;CoerceUnsized&lt;/code&gt; 从 &lt;code&gt;T&lt;/code&gt; 暗示为 &lt;code&gt;U&lt;/code&gt; ，这两种都是该结构采用的类型。一个&lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;未施胶类型&lt;/a&gt;是任何类型的，该编译器不知道在编译时间的长度或对准。包含未调整大小类型的任何结构也是未调整大小的。</target>
        </trans-unit>
        <trans-unit id="fd90f531eb1d0ac938c6ffc13d21933bccfecc8d" translate="yes" xml:space="preserve">
          <source>A struct with the representation hint &lt;code&gt;repr(transparent)&lt;/code&gt; had zero or more than one fields that were not guaranteed to be zero-sized.</source>
          <target state="translated">具有表示提示 &lt;code&gt;repr(transparent)&lt;/code&gt; 的结构具有零个或多个不能保证大小为零的字段。</target>
        </trans-unit>
        <trans-unit id="b1c33e6a538a3d99ccd128f7c3f5572cd613b66b" translate="yes" xml:space="preserve">
          <source>A struct without a field containing an unsized type cannot implement &lt;code&gt;CoerceUnsized&lt;/code&gt;. An &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;unsized type&lt;/a&gt; is any type that the compiler doesn't know the length or alignment of at compile time. Any struct containing an unsized type is also unsized.</source>
          <target state="translated">没有字段包含未调整大小类型的结构 &lt;code&gt;CoerceUnsized&lt;/code&gt; 。一个&lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;未施胶类型&lt;/a&gt;是任何类型的，该编译器不知道在编译时间的长度或对准。包含未调整大小类型的任何结构也是未调整大小的。</target>
        </trans-unit>
        <trans-unit id="bfe3d05f336ffd910d212738048395d48df402c2" translate="yes" xml:space="preserve">
          <source>A struct's or struct-like enum variant's field was not provided.</source>
          <target state="translated">没有提供结构或类似结构的枚举变体的字段。</target>
        </trans-unit>
        <trans-unit id="5bcfe0f822e1b5462565a584546dacf4f3c36744" translate="yes" xml:space="preserve">
          <source>A struct's or struct-like enum variant's field was specified more than once.</source>
          <target state="translated">一个struct的或类似struct的枚举变体的字段被指定了一次以上。</target>
        </trans-unit>
        <trans-unit id="d312c16b162889c1bce1669ed072c5b476d65baa" translate="yes" xml:space="preserve">
          <source>A struct, enum, or union with the &lt;code&gt;repr(transparent)&lt;/code&gt; representation hint contains a zero-sized field that requires non-trivial alignment.</source>
          <target state="translated">具有 &lt;code&gt;repr(transparent)&lt;/code&gt; 表示提示的结构，枚举或联合包含零大小的字段，该字段要求非平凡的对齐方式。</target>
        </trans-unit>
        <trans-unit id="87c6cf95d3e0451e702dc377209e4618399b1fa6" translate="yes" xml:space="preserve">
          <source>A structure representing a Unix domain socket server.</source>
          <target state="translated">一个代表Unix域套接字服务器的结构。</target>
        </trans-unit>
        <trans-unit id="369143bfa607c6bacd39b080c8d08420dc95dcbd" translate="yes" xml:space="preserve">
          <source>A structure representing a type of file with accessors for each file type. It is returned by &lt;a href=&quot;struct.metadata#method.file_type&quot;&gt;&lt;code&gt;Metadata::file_type&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">表示文件类型的结构，每种文件类型都有访问器。它由&lt;a href=&quot;struct.metadata#method.file_type&quot;&gt; &lt;code&gt;Metadata::file_type&lt;/code&gt; &lt;/a&gt;方法返回。</target>
        </trans-unit>
        <trans-unit id="2859b7dadbca8f1bc62c1ff5e0e2a9f89b18f533" translate="yes" xml:space="preserve">
          <source>A structure wrapping a Windows path prefix as well as its unparsed string representation.</source>
          <target state="translated">一个包装Windows路径前缀及其未解析字符串的结构。</target>
        </trans-unit>
        <trans-unit id="a18cd960fc14986c70aa975cf92200531a20ff48" translate="yes" xml:space="preserve">
          <source>A structure-literal syntax was used to create an item that is not a structure or enum variant.</source>
          <target state="translated">在创建一个不是结构体或枚举变体的项目时,使用了结构体-词条语法。</target>
        </trans-unit>
        <trans-unit id="450ed556ad629fd6ee6dd398c15074a8c129be66" translate="yes" xml:space="preserve">
          <source>A successful conversion will produce the same result as &lt;a href=&quot;struct.cstring#method.new&quot;&gt;&lt;code&gt;CString::new&lt;/code&gt;&lt;/a&gt; when called without the ending nul byte.</source>
          <target state="translated">成功的转换将在没有结尾nul字节的情况下产生与&lt;a href=&quot;struct.cstring#method.new&quot;&gt; &lt;code&gt;CString::new&lt;/code&gt; &lt;/a&gt;相同的结果。</target>
        </trans-unit>
        <trans-unit id="d24a2a657ceada76d6bbbb3c74ce41c5696fa9c3" translate="yes" xml:space="preserve">
          <source>A successful send occurs when it is determined that the other end of the channel has not hung up already. An unsuccessful send would be one where the corresponding receiver has already been deallocated. Note that a return value of &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; means that the data will never be received, but a return value of &lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; does &lt;em&gt;not&lt;/em&gt; mean that the data will be received. It is possible for the corresponding receiver to hang up immediately after this function returns &lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当确定通道的另一端尚未挂断时，发送成功。不成功的发送将是相应的接收器已被重新分配的发送。注意的返回值&lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;意味着数据永远不会被接受，但返回值&lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt;它&lt;em&gt;不是&lt;/em&gt;意味着数据将被接收。此函数返回&lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt;之后，相应的接收方可能会立即挂断。</target>
        </trans-unit>
        <trans-unit id="74d74f5ba0d4e61c19c1486af3bde440292622e8" translate="yes" xml:space="preserve">
          <source>A suffix is a non-raw identifier immediately (without whitespace) following the primary part of a literal.</source>
          <target state="translated">后缀是紧跟在文字的主要部分之后的一个非raw标识符(没有空格)。</target>
        </trans-unit>
        <trans-unit id="01225be668ae4fcd869b26b266eae668b00e87f5" translate="yes" xml:space="preserve">
          <source>A super trait has been added to an auto trait.</source>
          <target state="translated">在自动特质中增加了一个超级特质。</target>
        </trans-unit>
        <trans-unit id="fcd1d7403a3a0b004c92da849e81f0a2dc9aaf82" translate="yes" xml:space="preserve">
          <source>A synchronization primitive which can be used to run a one-time global initialization. Useful for one-time initialization for FFI or related functionality. This type can only be constructed with &lt;a href=&quot;struct.once#method.new&quot;&gt;&lt;code&gt;Once::new()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">同步原语，可用于运行一次性全局初始化。对于FFI或相关功能的一次性初始化很有用。此类型只能使用&lt;a href=&quot;struct.once#method.new&quot;&gt; &lt;code&gt;Once::new()&lt;/code&gt; &lt;/a&gt;构造。</target>
        </trans-unit>
        <trans-unit id="a56a331926b2603c064792db84cd20c38dc32bf0" translate="yes" xml:space="preserve">
          <source>A synchronization primitive which can be used to run a one-time global initialization. Useful for one-time initialization for FFI or related functionality. This type can only be constructed with the &lt;a href=&quot;constant.once_init&quot;&gt;&lt;code&gt;ONCE_INIT&lt;/code&gt;&lt;/a&gt; value or the equivalent &lt;a href=&quot;struct.once#method.new&quot;&gt;&lt;code&gt;Once::new&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">同步原语，可用于运行一次性全局初始化。对于FFI或相关功能的一次性初始化很有用。该类型只能使用&lt;a href=&quot;constant.once_init&quot;&gt; &lt;code&gt;ONCE_INIT&lt;/code&gt; &lt;/a&gt;值或等效的&lt;a href=&quot;struct.once#method.new&quot;&gt; &lt;code&gt;Once::new&lt;/code&gt; &lt;/a&gt;构造函数构造。</target>
        </trans-unit>
        <trans-unit id="7ae033712f05c69a86c1b61d9806f301efbdf2ee" translate="yes" xml:space="preserve">
          <source>A synchronization primitive which can be written to only once.</source>
          <target state="translated">一个同步基元,只能被写入一次。</target>
        </trans-unit>
        <trans-unit id="ec350722ecdc068b18a23660d975deaef83608f5" translate="yes" xml:space="preserve">
          <source>A synchronous, bounded channel. The &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt; function will return a &lt;code&gt;(SyncSender, Receiver)&lt;/code&gt; tuple where the storage for pending messages is a pre-allocated buffer of a fixed size. All sends will be &lt;strong&gt;synchronous&lt;/strong&gt; by blocking until there is buffer space available. Note that a bound of 0 is allowed, causing the channel to become a &quot;rendezvous&quot; channel where each sender atomically hands off a message to a receiver.</source>
          <target state="translated">同步的有界通道。该&lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; &lt;/a&gt;函数将返回一个 &lt;code&gt;(SyncSender, Receiver)&lt;/code&gt; 元组其中对于待处理消息存储为固定大小的预分配的缓冲区。所有发送将通过阻塞进行&lt;strong&gt;同步&lt;/strong&gt;，直到有可用缓冲区空间为止。请注意，允许范围为0，导致该通道成为&amp;ldquo;集合&amp;rdquo;通道，在此通道中，每个发送方原子地将消息传递给接收方。</target>
        </trans-unit>
        <trans-unit id="cba628809f9496f1476d8b33de698410511ed6a9" translate="yes" xml:space="preserve">
          <source>A syntactical production</source>
          <target state="translated">句法生产</target>
        </trans-unit>
        <trans-unit id="a737498d76fd77a9ff17becf5c122eff8eaa0e65" translate="yes" xml:space="preserve">
          <source>A temporary value is being dropped while a borrow is still in active use.</source>
          <target state="translated">正在借使还正在运用中的时分,一个暂时值就会被丢弃。</target>
        </trans-unit>
        <trans-unit id="96826c24c299b2bf43fb19f0b4fbba10405e86b7" translate="yes" xml:space="preserve">
          <source>A thread can also return a value through its &lt;a href=&quot;struct.joinhandle&quot;&gt;&lt;code&gt;JoinHandle&lt;/code&gt;&lt;/a&gt;, you can use this to make asynchronous computations (futures might be more appropriate though).</source>
          <target state="translated">线程也可以通过其&lt;a href=&quot;struct.joinhandle&quot;&gt; &lt;code&gt;JoinHandle&lt;/code&gt; &lt;/a&gt;返回值，您可以使用它进行异步计算（不过，将来可能更合适）。</target>
        </trans-unit>
        <trans-unit id="ca6a08446cfa59c90fd402f951ed8784aa3d5f4c" translate="yes" xml:space="preserve">
          <source>A thread local storage key which owns its contents.</source>
          <target state="translated">一个拥有其内容的线程本地存储键。</target>
        </trans-unit>
        <trans-unit id="a566c05b188249907018616799317e8f6688426e" translate="yes" xml:space="preserve">
          <source>A thread that completes without panicking is considered to exit successfully.</source>
          <target state="translated">线程完成后,不慌不忙,即视为退出成功。</target>
        </trans-unit>
        <trans-unit id="cd2f16a831072bb59e0c5fa9974e56f23c534e74" translate="yes" xml:space="preserve">
          <source>A thread-local key owns the value it contains and will destroy the value when the thread exits. It is created with the &lt;a href=&quot;../macro.thread_local&quot;&gt;&lt;code&gt;thread_local!&lt;/code&gt;&lt;/a&gt; macro and can contain any value that is &lt;code&gt;'static&lt;/code&gt; (no borrowed pointers). It provides an accessor function, &lt;a href=&quot;struct.localkey#method.with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt;, that yields a shared reference to the value to the specified closure. Thread-local keys allow only shared access to values, as there would be no way to guarantee uniqueness if mutable borrows were allowed. Most values will want to make use of some form of &lt;strong&gt;interior mutability&lt;/strong&gt; through the &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt; types.</source>
          <target state="translated">线程局部键拥有它包含的值，并且在线程退出时将销毁该值。它是用&lt;a href=&quot;../macro.thread_local&quot;&gt; &lt;code&gt;thread_local!&lt;/code&gt; &lt;/a&gt;创建的！宏，并且可以包含任何 &lt;code&gt;'static&lt;/code&gt; 值（无借入指针）。它提供了一个存取功能，&lt;a href=&quot;struct.localkey#method.with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt;，其产率的共享参考值到指定的闭合。线程局部键仅允许共享访问值，因为如果允许可变借用，则无法保证唯一性。大多数值都希望通过&lt;a href=&quot;../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; &lt;/a&gt;类型利用某种形式的&lt;strong&gt;内部可变性&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="7c1b3e385815bb55356e10c862b54219c0c9bb61" translate="yes" xml:space="preserve">
          <source>A thread-safe reference-counting pointer. 'Arc' stands for 'Atomically Reference Counted'.</source>
          <target state="translated">一个线程安全的引用计数指针,'Arc'代表'原子引用计数'。Arc'代表'原子引用计数'。</target>
        </trans-unit>
        <trans-unit id="c20fcb5862a17955d3c9171cc540c5db72364cad" translate="yes" xml:space="preserve">
          <source>A token produced by the lexer</source>
          <target state="translated">词法学家产生的标记</target>
        </trans-unit>
        <trans-unit id="507266de8c913e006a522a90feaa72cf485f935b" translate="yes" xml:space="preserve">
          <source>A trailing slash is normalized away, &lt;code&gt;/a/b&lt;/code&gt; and &lt;code&gt;/a/b/&lt;/code&gt; are equivalent.</source>
          <target state="translated">尾部的斜杠被标准化， &lt;code&gt;/a/b&lt;/code&gt; 和 &lt;code&gt;/a/b/&lt;/code&gt; 是等效的。</target>
        </trans-unit>
        <trans-unit id="4ac633f47782fcea3e3cdbd2b28541d42f49cb1e" translate="yes" xml:space="preserve">
          <source>A trait bound on &lt;code&gt;?Sized&lt;/code&gt; is the opposite of a trait bound on &lt;code&gt;Sized&lt;/code&gt;: we would read this as &amp;ldquo;&lt;code&gt;T&lt;/code&gt; may or may not be &lt;code&gt;Sized&lt;/code&gt;.&amp;rdquo; This syntax is only available for &lt;code&gt;Sized&lt;/code&gt;, not any other traits.</source>
          <target state="translated">绑定，该特点 &lt;code&gt;?Sized&lt;/code&gt; 是绑定在性状的相对 &lt;code&gt;Sized&lt;/code&gt; ：我们会看这是&amp;ldquo; &lt;code&gt;T&lt;/code&gt; 可能会或可能不会是 &lt;code&gt;Sized&lt;/code&gt; 。&amp;rdquo; 此语法仅适用于 &lt;code&gt;Sized&lt;/code&gt; ，不适用于其他任何特征。</target>
        </trans-unit>
        <trans-unit id="a7f257ac376cb00e120748ca01c24ce026b8963b" translate="yes" xml:space="preserve">
          <source>A trait can have multiple methods in its body: the method signatures are listed one per line and each line ends in a semicolon.</source>
          <target state="translated">一个特质在其主体中可以有多个方法:方法签名每行列出一个,每行以分号结束。</target>
        </trans-unit>
        <trans-unit id="9262128bd94142a9efd03c6641a2bff3a39b5b73" translate="yes" xml:space="preserve">
          <source>A trait for borrowing data.</source>
          <target state="translated">借用数据的特质。</target>
        </trans-unit>
        <trans-unit id="7529a2277a29d3ff854565242eed7e5e7895a272" translate="yes" xml:space="preserve">
          <source>A trait for converting a value to a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">用于将值转换为 &lt;code&gt;String&lt;/code&gt; 的特征。</target>
        </trans-unit>
        <trans-unit id="1e3010340eda1a0df2c156c88d0e99044a3b58ec" translate="yes" xml:space="preserve">
          <source>A trait for creating instances of &lt;a href=&quot;trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">创建&lt;a href=&quot;trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt;实例的特征。</target>
        </trans-unit>
        <trans-unit id="c6d9b8a4582a6d812cf132a7f8cdac8ff53fc3aa" translate="yes" xml:space="preserve">
          <source>A trait for customizing the behavior of the &lt;code&gt;?&lt;/code&gt; operator.</source>
          <target state="translated">自定义 &lt;code&gt;?&lt;/code&gt; 行为的特征？操作员。</target>
        </trans-unit>
        <trans-unit id="976dcd2549faab554b8e6bbecaabfc30542917fd" translate="yes" xml:space="preserve">
          <source>A trait for giving a type a useful default value.</source>
          <target state="translated">给予类型一个有用的默认值的特性。</target>
        </trans-unit>
        <trans-unit id="e18827eba48f91a1c885aefb421b9657624cb210" translate="yes" xml:space="preserve">
          <source>A trait for hashing an arbitrary stream of bytes.</source>
          <target state="translated">用于对任意字节流进行散列的特征。</target>
        </trans-unit>
        <trans-unit id="bdee9213c6e4170b3110b9dd5eaa365239c9d83d" translate="yes" xml:space="preserve">
          <source>A trait for implementing arbitrary return types in the &lt;code&gt;main&lt;/code&gt; function.</source>
          <target state="translated">在 &lt;code&gt;main&lt;/code&gt; 函数中实现任意返回类型的特征。</target>
        </trans-unit>
        <trans-unit id="20b8f1b86976a3452526ed169982978b3d0e907f" translate="yes" xml:space="preserve">
          <source>A trait for mutably borrowing data.</source>
          <target state="translated">一个用于突变借用数据的特征。</target>
        </trans-unit>
        <trans-unit id="d1ed2c9d8583af1348e3be7781420c71c940ca4b" translate="yes" xml:space="preserve">
          <source>A trait for objects which are byte-oriented sinks.</source>
          <target state="translated">面向字节汇的对象的特征。</target>
        </trans-unit>
        <trans-unit id="754c048641e5a68c7fd81cc8028cfbaf095e1cb7" translate="yes" xml:space="preserve">
          <source>A trait for objects which can be converted or resolved to one or more &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; values.</source>
          <target state="translated">可以转换或解析为一个或多个&lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt;值的对象的特征。</target>
        </trans-unit>
        <trans-unit id="20da43414d9faf5772a30fd6329b8b6d3aa3e3b4" translate="yes" xml:space="preserve">
          <source>A trait for writing or formatting into Unicode-accepting buffers or streams.</source>
          <target state="translated">用于写入或格式化成Unicode接受的缓冲区或流的特征。</target>
        </trans-unit>
        <trans-unit id="23adce518b9b9c7fb3e196dc3fd75bab1e5f0059" translate="yes" xml:space="preserve">
          <source>A trait implementation has stricter requirements than the trait definition.</source>
          <target state="translated">特质实现比特质定义有更严格的要求。</target>
        </trans-unit>
        <trans-unit id="bc29685de3e170d55184516a7b3d199864139684" translate="yes" xml:space="preserve">
          <source>A trait implementation is considered incoherent if either the orphan check fails or there are overlapping implementation instances.</source>
          <target state="translated">如果孤儿检查失败或有重叠的实现实例,则认为一个特质实现是不连贯的。</target>
        </trans-unit>
        <trans-unit id="a4884230017ffb802f52c6721c470c8593e7fcd5" translate="yes" xml:space="preserve">
          <source>A trait implementation is considered incoherent if either the orphan rules check fails or there are overlapping implementation instances.</source>
          <target state="translated">如果孤儿规则检查失败或有重叠的实现实例,则认为一个特质实现是不连贯的。</target>
        </trans-unit>
        <trans-unit id="bb0a26a692dfe7bee9af7137b27b0e076260ccbc" translate="yes" xml:space="preserve">
          <source>A trait implementation must define all non-default associated items declared by the implemented trait, may redefine default associated items defined by the implemented trait, and cannot define any other items.</source>
          <target state="translated">特质实现必须定义所有被实现的特质所声明的非默认关联项,可以重新定义被实现的特质所定义的默认关联项,不能定义任何其他项目。</target>
        </trans-unit>
        <trans-unit id="d0010f4426c0d6cbe2dc68d818b29e968be48db6" translate="yes" xml:space="preserve">
          <source>A trait implementation was marked as unsafe while the trait is safe.</source>
          <target state="translated">一个特质实现被标记为不安全,而该特质是安全的。</target>
        </trans-unit>
        <trans-unit id="1951065ab3447cdfa4016a3198b5e5dd606d4a6b" translate="yes" xml:space="preserve">
          <source>A trait is a language item that is used for describing the functionalities a type must provide. It allows a type to make certain promises about its behavior.</source>
          <target state="translated">特质是一个语言项目,用于描述类型必须提供的功能。它允许一个类型对其行为做出某些承诺。</target>
        </trans-unit>
        <trans-unit id="c9de8e0634dfdc7f3f2e02723351cb17b73aefe4" translate="yes" xml:space="preserve">
          <source>A trait may be implemented for &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; in the same crate as &lt;code&gt;T&lt;/code&gt;, which the &lt;a href=&quot;items/implementations#trait-implementation-coherence&quot;&gt;orphan rules&lt;/a&gt; prevent for other generic types.</source>
          <target state="translated">可以在与 &lt;code&gt;T&lt;/code&gt; 相同的板条箱中为 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 实现特征，而&lt;a href=&quot;items/implementations#trait-implementation-coherence&quot;&gt;孤立规则则&lt;/a&gt;禁止其他通用类型。</target>
        </trans-unit>
        <trans-unit id="1b745de10511ea796795a51c79ea5a4b196da151" translate="yes" xml:space="preserve">
          <source>A trait method was declared const.</source>
          <target state="translated">一个特质方法被声明为const。</target>
        </trans-unit>
        <trans-unit id="c934c2073046ff60e5d7154f42129a33305f83af" translate="yes" xml:space="preserve">
          <source>A trait object is defined over a single, fully-defined trait. With a regular default parameter, this parameter can just be substituted in. However, if the default parameter is &lt;code&gt;Self&lt;/code&gt;, the trait changes for each concrete type; i.e. &lt;code&gt;i32&lt;/code&gt; will be expected to implement &lt;code&gt;A&amp;lt;i32&amp;gt;&lt;/code&gt;, &lt;code&gt;bool&lt;/code&gt; will be expected to implement &lt;code&gt;A&amp;lt;bool&amp;gt;&lt;/code&gt;, etc... These types will not share an implementation of a fully-defined trait; instead they share implementations of a trait with different parameters substituted in for each implementation. This is irreconcilable with what we need to make a trait object work, and is thus disallowed. Making the trait concrete by explicitly specifying the value of the defaulted parameter will fix this issue. Fixed example:</source>
          <target state="translated">特征对象是在单个完全定义的特征上定义的。使用常规的默认参数，就可以替换此参数。但是，如果默认参数是 &lt;code&gt;Self&lt;/code&gt; ，则每种具体类型的特征都会改变；否则，默认值会更改。即 &lt;code&gt;i32&lt;/code&gt; 将实现 &lt;code&gt;A&amp;lt;i32&amp;gt;&lt;/code&gt; ， &lt;code&gt;bool&lt;/code&gt; 将实现 &lt;code&gt;A&amp;lt;bool&amp;gt;&lt;/code&gt; 等等。这些类型将不会共享完全定义的特征的实现。取而代之的是，它们共享特征的实现，每个实现都替换了不同的参数。这与使特征对象起作用所需的东西不可调和，因此是不允许的。通过显式指定默认参数的值来使特征具体化将解决此问题。固定示例：</target>
        </trans-unit>
        <trans-unit id="09ed217e59efc6a63ebd08cd2d7fd8370e33eb53" translate="yes" xml:space="preserve">
          <source>A trait object was declared with no traits.</source>
          <target state="translated">声明了一个没有特质的特质对象。</target>
        </trans-unit>
        <trans-unit id="16935dd0c42b10d2b4960eb5cbdc15bbae87c965" translate="yes" xml:space="preserve">
          <source>A trait to emulate dynamic typing.</source>
          <target state="translated">一个模拟动态输入的特征。</target>
        </trans-unit>
        <trans-unit id="2977e50a37e0d1dad52d9fd5a6a043035b25bd2b" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to construct an object from a raw file descriptor.</source>
          <target state="translated">表示从原始文件描述符构造对象的能力的特征。</target>
        </trans-unit>
        <trans-unit id="d60c5c028a11d7b4ae9ad91367b8c4ed38349307" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to consume an object and acquire ownership of its raw &lt;code&gt;HANDLE&lt;/code&gt;.</source>
          <target state="translated">表示消费对象并获得其原始 &lt;code&gt;HANDLE&lt;/code&gt; 所有权的能力的特征。</target>
        </trans-unit>
        <trans-unit id="c1f9b5c774891d37ad148a2229500ad192b8b52c" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to consume an object and acquire ownership of its raw &lt;code&gt;SOCKET&lt;/code&gt;.</source>
          <target state="translated">表达消费对象并获得其原始 &lt;code&gt;SOCKET&lt;/code&gt; 所有权的能力的一种特征。</target>
        </trans-unit>
        <trans-unit id="a98e8ff575c7077546911de64edefa1e0d617067" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to consume an object and acquire ownership of its raw file descriptor.</source>
          <target state="translated">一个特质,用于表达消费对象的能力,并获得其原始文件描述符的所有权。</target>
        </trans-unit>
        <trans-unit id="25a11a87d2f4adf0083235ec32efcdd357ad1b14" translate="yes" xml:space="preserve">
          <source>A trait to extract the raw unix file descriptor from an underlying object.</source>
          <target state="translated">从底层对象中提取原始unix文件描述符的特征。</target>
        </trans-unit>
        <trans-unit id="74dfee4318a470e1c8aa720bcf48b06f65b677a2" translate="yes" xml:space="preserve">
          <source>A trait type has been dereferenced.</source>
          <target state="translated">一个特征类型已被取消引用。</target>
        </trans-unit>
        <trans-unit id="a3b4acf36ca74c434adb6226f16d93f351b2c3d1" translate="yes" xml:space="preserve">
          <source>A trait was implemented on another which already automatically implemented it.</source>
          <target state="translated">一个特征被实施在另一个已经自动实施的特征上。</target>
        </trans-unit>
        <trans-unit id="1af6d624d68ca3ca313d81ebc03c7ca717454c50" translate="yes" xml:space="preserve">
          <source>A transparent struct, enum, or union is supposed to be represented exactly like the piece of data it contains. Zero-sized fields with different alignment requirements potentially conflict with this property. In the example above, &lt;code&gt;Wrapper&lt;/code&gt; would have to be aligned to 32 bytes even though &lt;code&gt;f32&lt;/code&gt; has a smaller alignment requirement.</source>
          <target state="translated">透明的struct，enum或union应该像它所包含的数据一样精确地表示。具有不同对齐要求的零大小字段可能与此属性冲突。在上面的示例中，即使 &lt;code&gt;f32&lt;/code&gt; 的对齐要求更小， &lt;code&gt;Wrapper&lt;/code&gt; 也必须对齐到32个字节。</target>
        </trans-unit>
        <trans-unit id="490336a5e305f2d2e8d1363f03a6314c497a78fa" translate="yes" xml:space="preserve">
          <source>A tricky example, with sigma:</source>
          <target state="translated">一个棘手的例子,与西格玛。</target>
        </trans-unit>
        <trans-unit id="2d6e480d45ae2d8d8e393f568dbe81e3240a2b6b" translate="yes" xml:space="preserve">
          <source>A trivial example of the usage of &lt;code&gt;bool&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 用法的一个简单例子，</target>
        </trans-unit>
        <trans-unit id="26204199326019f143410da0c8e1f31498a99258" translate="yes" xml:space="preserve">
          <source>A tuple &lt;em&gt;type&lt;/em&gt; is a heterogeneous product of other types, called the &lt;em&gt;elements&lt;/em&gt; of the tuple. It has no nominal name and is instead structurally typed.</source>
          <target state="translated">元组&lt;em&gt;类型&lt;/em&gt;是其他类型的异构产品，称为元组的&lt;em&gt;元素&lt;/em&gt;。它没有名义名称，而是结构化类型。</target>
        </trans-unit>
        <trans-unit id="e9dbb3e94f53ac8e3a8ca087dfd88ec94acc48f5" translate="yes" xml:space="preserve">
          <source>A tuple index is used to refer to the fields of &lt;a href=&quot;types/tuple&quot;&gt;tuples&lt;/a&gt;, &lt;a href=&quot;items/structs&quot;&gt;tuple structs&lt;/a&gt;, and &lt;a href=&quot;items/enumerations&quot;&gt;tuple variants&lt;/a&gt;.</source>
          <target state="translated">元组索引用于引用&lt;a href=&quot;types/tuple&quot;&gt;元组&lt;/a&gt;，&lt;a href=&quot;items/structs&quot;&gt;元组结构&lt;/a&gt;和&lt;a href=&quot;items/enumerations&quot;&gt;元组变体&lt;/a&gt;的字段。</target>
        </trans-unit>
        <trans-unit id="7b0541e4cbc97c5e40f947c03ae1731aeaba596f" translate="yes" xml:space="preserve">
          <source>A tuple is a general way of grouping together a number of values with a variety of types into one compound type. Tuples have a fixed length: once declared, they cannot grow or shrink in size.</source>
          <target state="translated">元组是一种通用的方式,它将一些具有不同类型的值组合成一个复合类型。图元组有一个固定的长度:一旦声明,它们的大小就不能增加或缩小。</target>
        </trans-unit>
        <trans-unit id="402bd39bb6c42541595f5aba7871ff88c655396e" translate="yes" xml:space="preserve">
          <source>A tuple is a general way of grouping together some number of other values with a variety of types into one compound type. Tuples have a fixed length: once declared, they cannot grow or shrink in size.</source>
          <target state="translated">元组是将一些具有不同类型的其他值组合成一个复合类型的一般方法。图元组有一个固定的长度:一旦被声明,它们的大小就不能增加或缩小。</target>
        </trans-unit>
        <trans-unit id="8d3a96e70924f2a82e85cf6036b452ac805c64ec" translate="yes" xml:space="preserve">
          <source>A tuple struct or tuple variant was used in a pattern as if it were a struct or struct variant.</source>
          <target state="translated">一个元组结构或元组变体被当作一个结构或结构变体在模式中使用。</target>
        </trans-unit>
        <trans-unit id="1696a724c358dd0091f73a52db83c7a8082d2750" translate="yes" xml:space="preserve">
          <source>A tuple struct pattern is refutable when one of its subpatterns is refutable.</source>
          <target state="translated">当一个元组结构模式的一个子模式是可反驳的。</target>
        </trans-unit>
        <trans-unit id="8f5d8407de99f6165aaf419c7f8aaf0ecf33a5a2" translate="yes" xml:space="preserve">
          <source>A tuple struct's element isn't a machine type when using the &lt;code&gt;#[simd]&lt;/code&gt; attribute.</source>
          <target state="translated">使用 &lt;code&gt;#[simd]&lt;/code&gt; 属性时，元组struct的元素不是机器类型。</target>
        </trans-unit>
        <trans-unit id="63c229f3f830c234653affc74d3c7117a6730da6" translate="yes" xml:space="preserve">
          <source>A type alias for &lt;a href=&quot;../convert/enum.infallible&quot;&gt;&lt;code&gt;Infallible&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../convert/enum.infallible&quot;&gt; &lt;code&gt;Infallible&lt;/code&gt; &lt;/a&gt;的类型别名。</target>
        </trans-unit>
        <trans-unit id="1009527a15bba1ad137f4f63c037795bd4a2bfe2" translate="yes" xml:space="preserve">
          <source>A type alias for the result of a lock method which can be poisoned.</source>
          <target state="translated">锁定方法的结果的类型别名,可以中毒。</target>
        </trans-unit>
        <trans-unit id="aae3cf8f6eb9071486813bec542109175b1464e5" translate="yes" xml:space="preserve">
          <source>A type alias for the result of a nonblocking locking method.</source>
          <target state="translated">一个非阻塞锁定方法结果的类型别名。</target>
        </trans-unit>
        <trans-unit id="811e3fb59c28acd0a23a2498fc25dd5079b4be0d" translate="yes" xml:space="preserve">
          <source>A type alias makes this code more manageable by reducing the repetition. In Listing 19-25, we&amp;rsquo;ve introduced an alias named &lt;code&gt;Thunk&lt;/code&gt; for the verbose type and can replace all uses of the type with the shorter alias &lt;code&gt;Thunk&lt;/code&gt;.</source>
          <target state="translated">类型别名通过减少重复使此代码更易于管理。在清单19-25中，我们为详细类型引入了一个名为 &lt;code&gt;Thunk&lt;/code&gt; 的别名，并且可以使用较短的别名 &lt;code&gt;Thunk&lt;/code&gt; 替换该类型的所有用法。</target>
        </trans-unit>
        <trans-unit id="4e38a79e72762fd78e402d5747ab629fd9e3cf95" translate="yes" xml:space="preserve">
          <source>A type alias to a tuple-struct or unit-struct cannot be used to qualify that type's constructor:</source>
          <target state="translated">元组结构或单元结构的类型别名不能用于限定该类型的构造函数。</target>
        </trans-unit>
        <trans-unit id="872091a52699e1a821b52be55e9443115016332c" translate="yes" xml:space="preserve">
          <source>A type alias to an enum type cannot be used to qualify the constructors:</source>
          <target state="translated">枚举类型的类型别名不能用于限定构造函数。</target>
        </trans-unit>
        <trans-unit id="9e407e83d82ec15858c1c29f981a47a04ebb8636" translate="yes" xml:space="preserve">
          <source>A type annotated as &lt;code&gt;repr(transparent)&lt;/code&gt; delegates all representation concerns to another type, so adding more representation hints is contradictory. Remove either the &lt;code&gt;transparent&lt;/code&gt; hint or the other hints, like this:</source>
          <target state="translated">注释为 &lt;code&gt;repr(transparent)&lt;/code&gt; 的类型将所有表示形式问题委托给另一种类型，因此添加更多表示形式提示是矛盾的。删除 &lt;code&gt;transparent&lt;/code&gt; 提示或其他提示，如下所示：</target>
        </trans-unit>
        <trans-unit id="cb5e8aa2faa836eb0e6e33148484b741b2f52f31" translate="yes" xml:space="preserve">
          <source>A type can also have multiple inherent implementations. An implementing type must be defined within the same crate as the original type definition.</source>
          <target state="translated">一个类型也可以有多个固有的实现。一个实现类型必须和原始类型定义在同一个箱子里。</target>
        </trans-unit>
        <trans-unit id="ec397cd955b41db47c056843b89f1c979b1499b9" translate="yes" xml:space="preserve">
          <source>A type can implement &lt;code&gt;Copy&lt;/code&gt; if all of its components implement &lt;code&gt;Copy&lt;/code&gt;. For example, this struct can be &lt;code&gt;Copy&lt;/code&gt;:</source>
          <target state="translated">如果类型的所有组件都实现 &lt;code&gt;Copy&lt;/code&gt; ,则该类型可以实现 &lt;code&gt;Copy&lt;/code&gt; 。例如，此结构可以是 &lt;code&gt;Copy&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a1e5e79c85877ceec782fbfaa18c2c4e5b9b2282" translate="yes" xml:space="preserve">
          <source>A type cast expression is denoted with the binary operator &lt;code&gt;as&lt;/code&gt;.</source>
          <target state="translated">类型转换表达式用二进制运算符表示 &lt;code&gt;as&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b97b41bd9c7eae77d5c3b940d4a5832d7e972fb" translate="yes" xml:space="preserve">
          <source>A type dependency cycle has been encountered.</source>
          <target state="translated">遇到了一个类型依赖循环。</target>
        </trans-unit>
        <trans-unit id="2904374f2c0e91251791d02f72bd6378c8bccc80" translate="yes" xml:space="preserve">
          <source>A type has both &lt;code&gt;packed&lt;/code&gt; and &lt;code&gt;align&lt;/code&gt; representation hints.</source>
          <target state="translated">一个类型具有 &lt;code&gt;packed&lt;/code&gt; 和 &lt;code&gt;align&lt;/code&gt; 表示提示。</target>
        </trans-unit>
        <trans-unit id="77f0b7a28b6f2753f1d76d09de19c12454b7888f" translate="yes" xml:space="preserve">
          <source>A type has conflicting &lt;code&gt;packed&lt;/code&gt; representation hints.</source>
          <target state="translated">类型具有相互冲突的 &lt;code&gt;packed&lt;/code&gt; 表示提示。</target>
        </trans-unit>
        <trans-unit id="995f457de088e34d1af6ab0e7cbed95033f1f938" translate="yes" xml:space="preserve">
          <source>A type implementing &lt;code&gt;Try&lt;/code&gt; is one that has a canonical way to view it in terms of a success/failure dichotomy. This trait allows both extracting those success or failure values from an existing instance and creating a new instance from a success or failure value.</source>
          <target state="translated">实现 &lt;code&gt;Try&lt;/code&gt; 的类型是一种以成功/失败二分法来规范地查看它的类型。此特征既可以从现有实例中提取成功或失败值，也可以从成功或失败值创建新实例。</target>
        </trans-unit>
        <trans-unit id="f5199d6683f66f6377d3e5c541ab1e1a45f0a440" translate="yes" xml:space="preserve">
          <source>A type indicating whether a timed wait on a condition variable returned due to a time out or not.</source>
          <target state="translated">表示条件变量的定时等待是否因超时而返回的类型。</target>
        </trans-unit>
        <trans-unit id="bcb42c5f4b4345c9c33893996e574612ab86b0f7" translate="yes" xml:space="preserve">
          <source>A type is inhabited if it has constructors and therefore can be instantiated. An inhabited type is not &quot;empty&quot; in the sense that there can be values of the type. Opposite of &lt;a href=&quot;#uninhabited&quot;&gt;Uninhabited&lt;/a&gt;.</source>
          <target state="translated">如果类型具有构造函数，则可以使用它，因此可以实例化它。从可以存在该类型的值的意义上说，有人居住的类型不是&amp;ldquo;空&amp;rdquo;的。在&lt;a href=&quot;#uninhabited&quot;&gt;无人居住的&lt;/a&gt;对面。</target>
        </trans-unit>
        <trans-unit id="61c125cceb1922063b5ac33f0666ef79257f43a2" translate="yes" xml:space="preserve">
          <source>A type is uninhabited if it has no constructors and therefore can never be instantiated. An uninhabited type is &quot;empty&quot; in the sense that there are no values of the type. The canonical example of an uninhabited type is the &lt;a href=&quot;types/never&quot;&gt;never type&lt;/a&gt;&lt;code&gt;!&lt;/code&gt;, or an enum with no variants &lt;code&gt;enum Never { }&lt;/code&gt;. Opposite of &lt;a href=&quot;#inhabited&quot;&gt;Inhabited&lt;/a&gt;.</source>
          <target state="translated">如果类型没有构造函数，则它是无人居住的，因此永远无法实例化。在没有类型值的意义上，无人类型是&amp;ldquo;空&amp;rdquo;的。无人居住类型的典型例子是&lt;a href=&quot;types/never&quot;&gt;永不类型&lt;/a&gt; &lt;code&gt;!&lt;/code&gt; ，或没有变体的 &lt;code&gt;enum Never { }&lt;/code&gt; 。与&lt;a href=&quot;#inhabited&quot;&gt;居住区&lt;/a&gt;相反。</target>
        </trans-unit>
        <trans-unit id="d3666c5137a8c2f5bd25b41e59026d010547814d" translate="yes" xml:space="preserve">
          <source>A type mismatched an associated type of a trait.</source>
          <target state="translated">一个类型不匹配的性状的相关类型。</target>
        </trans-unit>
        <trans-unit id="195d3e2324eafc4b95d0787028892dc2ce75ef57" translate="yes" xml:space="preserve">
          <source>A type of error which can be returned whenever a lock is acquired.</source>
          <target state="translated">一种错误类型,每当获得一个锁时就会被返回。</target>
        </trans-unit>
        <trans-unit id="e09ee31e80fe4ed67d90fe93645d23ccc6bd8f11" translate="yes" xml:space="preserve">
          <source>A type or lifetime parameter has been declared but is not actually used.</source>
          <target state="translated">类型或寿命参数已被声明,但未实际使用。</target>
        </trans-unit>
        <trans-unit id="c7fb190bd9cd84e642f9c437ffcc3a0470b68cd6" translate="yes" xml:space="preserve">
          <source>A type or module has been defined more than once.</source>
          <target state="translated">一个类型或模块已经被定义了不止一次。</target>
        </trans-unit>
        <trans-unit id="630bff58f7c530334c09b287d02fb5f603530515" translate="yes" xml:space="preserve">
          <source>A type parameter that is specified for &lt;code&gt;impl&lt;/code&gt; is not constrained.</source>
          <target state="translated">为 &lt;code&gt;impl&lt;/code&gt; 指定的类型参数不受限制。</target>
        </trans-unit>
        <trans-unit id="7a60e8550db7fb8bf181c3c2af427df857c9bf7d" translate="yes" xml:space="preserve">
          <source>A type parameter was declared which shadows an existing one. An example of this error:</source>
          <target state="translated">声明了一个类型参数,该类型参数对现有的类型参数产生了影响。这是一个错误的例子。</target>
        </trans-unit>
        <trans-unit id="0e1d3a1b69ee90016db302de62e4dd15a2f4ff16" translate="yes" xml:space="preserve">
          <source>A type parameter which references &lt;code&gt;Self&lt;/code&gt; in its default value was not specified.</source>
          <target state="translated">未指定在默认值中引用 &lt;code&gt;Self&lt;/code&gt; 的类型参数。</target>
        </trans-unit>
        <trans-unit id="25fe9cd48afec311fa3f403a24aafba6272aeca5" translate="yes" xml:space="preserve">
          <source>A type parameter which references &lt;code&gt;Self&lt;/code&gt; in its default value was not specified. Example of erroneous code:</source>
          <target state="translated">未指定在默认值中引用 &lt;code&gt;Self&lt;/code&gt; 的类型参数。错误代码示例：</target>
        </trans-unit>
        <trans-unit id="5ff8db748ed5eaad6145c2ecc683c1493e2ac732" translate="yes" xml:space="preserve">
          <source>A type parameter with default value is using forward declared identifier.</source>
          <target state="translated">类型参数的默认值是使用正向声明的标识符。</target>
        </trans-unit>
        <trans-unit id="7d790d10f882d09d23c776016863815c5b3e2b81" translate="yes" xml:space="preserve">
          <source>A type representing an owned, C-compatible, nul-terminated string with no nul bytes in the middle.</source>
          <target state="translated">一个类型,表示一个拥有的、C兼容的、中间没有nul字节的nul结尾的字符串。</target>
        </trans-unit>
        <trans-unit id="b3b99d63ae795914f8001d38731a170b595e6b2b" translate="yes" xml:space="preserve">
          <source>A type that can be any one of several variants.</source>
          <target state="translated">一种类型,可以是几种变体中的任何一种。</target>
        </trans-unit>
        <trans-unit id="090b303bdd4057540547275158d9e42939d01cec" translate="yes" xml:space="preserve">
          <source>A type that can represent owned, mutable platform-native strings, but is cheaply inter-convertible with Rust strings.</source>
          <target state="translated">一个可以表示拥有的、可突变的平台原生字符串的类型,但可以廉价地与 Rust 字符串相互转换。</target>
        </trans-unit>
        <trans-unit id="220ecc56d2012059c1d8cd78943adf0ed8ed7d8e" translate="yes" xml:space="preserve">
          <source>A type that is composed of other types.</source>
          <target state="translated">由其他类型组成的类型。</target>
        </trans-unit>
        <trans-unit id="0a851afebbaf8a3f378080846c51bf756d8476cc" translate="yes" xml:space="preserve">
          <source>A type that is not a trait was used in a trait position, such as a bound or &lt;code&gt;impl&lt;/code&gt;.</source>
          <target state="translated">在特征位置使用了不是特征的类型，例如bound或 &lt;code&gt;impl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48dabc713e66c06bf48c0ba95cf5b1b2867095db" translate="yes" xml:space="preserve">
          <source>A type to emulate dynamic typing.</source>
          <target state="translated">一个模拟动态类型的类型。</target>
        </trans-unit>
        <trans-unit id="18995bad7092858c6b32d35a26167b88faf2e216" translate="yes" xml:space="preserve">
          <source>A type used to conditionally initialize buffers passed to &lt;code&gt;Read&lt;/code&gt; methods.</source>
          <target state="translated">一种类型，用于有条件地初始化传递给 &lt;code&gt;Read&lt;/code&gt; 方法的缓冲区。</target>
        </trans-unit>
        <trans-unit id="8a527d3dadad04c815571442c7e455c6295d0179" translate="yes" xml:space="preserve">
          <source>A type which does not appear as an argument to another type. For example, &lt;code&gt;T&lt;/code&gt; is uncovered, but the &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; is covered. This is only relevant for type arguments.</source>
          <target state="translated">一个不会作为其他类型的参数出现的类型。例如， &lt;code&gt;T&lt;/code&gt; 未被覆盖，但 &lt;code&gt;T&lt;/code&gt; 在 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 被覆盖。这仅与类型参数有关。</target>
        </trans-unit>
        <trans-unit id="48a3662dff4bc918fde00d869523d6a4f45ec09b" translate="yes" xml:space="preserve">
          <source>A type with &lt;code&gt;packed&lt;/code&gt; representation hint has a field with &lt;code&gt;align&lt;/code&gt; representation hint.</source>
          <target state="translated">具有 &lt;code&gt;packed&lt;/code&gt; 表示形式提示的类型的字段具有 &lt;code&gt;align&lt;/code&gt; 表示形式提示。</target>
        </trans-unit>
        <trans-unit id="f40b2b31a159196f4517607c9d76ab5a80f0274d" translate="yes" xml:space="preserve">
          <source>A type&amp;rsquo;s behavior consists of the methods we can call on that type. Different types share the same behavior if we can call the same methods on all of those types. Trait definitions are a way to group method signatures together to define a set of behaviors necessary to accomplish some purpose.</source>
          <target state="translated">类型的行为由我们可以在该类型上调用的方法组成。如果我们可以对所有这些类型调用相同的方法，则不同的类型具有相同的行为。特性定义是一种将方法签名分组在一起以定义实现某些目的所需的行为的方法。</target>
        </trans-unit>
        <trans-unit id="3b6ddcc149faf5698a16d1a853b87785df3d76f9" translate="yes" xml:space="preserve">
          <source>A union access transmutes the content of the union to the type of the accessed field. Since transmutes can cause unexpected or undefined behaviour, &lt;code&gt;unsafe&lt;/code&gt; is required to read from a union field or to write to a field that doesn't implement &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">联合访问将联合的内容转换为访问字段的类型。由于转换会导致意外或不确定的行为，因此从联合字段读取或写入未实现&lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;的字段要求 &lt;code&gt;unsafe&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5466b2051b7ddfaa4d58e8a7c5e165f16f139371" translate="yes" xml:space="preserve">
          <source>A union declaration uses the same syntax as a struct declaration, except with &lt;code&gt;union&lt;/code&gt; in place of &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">联合声明使用与struct声明相同的语法，但用 &lt;code&gt;union&lt;/code&gt; 代替 &lt;code&gt;struct&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca484ccd859cf11dbaf1461b26fb4e6e0c1155bd" translate="yes" xml:space="preserve">
          <source>A union declared with &lt;code&gt;#[repr(C)]&lt;/code&gt; will have the same size and alignment as an equivalent C union declaration in the C language for the target platform. The union will have a size of the maximum size of all of its fields rounded to its alignment, and an alignment of the maximum alignment of all of its fields. These maximums may come from different fields.</source>
          <target state="translated">用 &lt;code&gt;#[repr(C)]&lt;/code&gt; 声明的联合将具有与目标平台的C语言中等效的C联合声明相同的大小和对齐方式。联合的大小将四舍五入到其对齐方式的所有字段的最大大小，并对齐其所有字段的最大对齐方式。这些最大值可能来自不同的领域。</target>
        </trans-unit>
        <trans-unit id="a5f776fff8bd64de524df1b33719d9e03226007b" translate="yes" xml:space="preserve">
          <source>A unique identifier for a running thread.</source>
          <target state="translated">正在运行的线程的唯一标识符。</target>
        </trans-unit>
        <trans-unit id="10b778820b33fd4a7dd6fe5ae783d38d25f8f4be" translate="yes" xml:space="preserve">
          <source>A unit struct expression is just the path to a unit struct item. This refers to the unit struct's implicit constant of its value. The unit struct value can also be constructed with a fieldless struct expression. For example:</source>
          <target state="translated">单元结构表达式只是单元结构项的路径。这指的是单元结构的值的隐含常量。单位结构的值也可以用无字段结构表达式来构造。例如</target>
        </trans-unit>
        <trans-unit id="e1ccfef1f9d17695dcb29cad8794e8d363ce8a2b" translate="yes" xml:space="preserve">
          <source>A unrecognized representation attribute was used.</source>
          <target state="translated">使用了一个未识别的表示属性。</target>
        </trans-unit>
        <trans-unit id="5b4c71cc75880bc2daa87d6294e45d4e462f56c4" translate="yes" xml:space="preserve">
          <source>A used type name is not in scope.</source>
          <target state="translated">使用过的类型名称不在范围内。</target>
        </trans-unit>
        <trans-unit id="bb363e92161ec8a647cc462201572019f30fe79b" translate="yes" xml:space="preserve">
          <source>A vacant entry.</source>
          <target state="translated">一个空缺的条目。</target>
        </trans-unit>
        <trans-unit id="ac311baab6584071250fc9bbbfdd8d2bebd0c9e9" translate="yes" xml:space="preserve">
          <source>A value in a &lt;code&gt;char&lt;/code&gt; which is a surrogate or above &lt;code&gt;char::MAX&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 中的一个值，它是替代值或大于 &lt;code&gt;char::MAX&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0cd18e9d0df56f2d91218b99bcfa24832cc2e846" translate="yes" xml:space="preserve">
          <source>A value of a &lt;a href=&quot;../items/unions&quot;&gt;union&lt;/a&gt; type can also be created using this syntax, except that it must specify exactly one field.</source>
          <target state="translated">除必须精确指定一个字段外，还可以使用此语法创建&lt;a href=&quot;../items/unions&quot;&gt;联合&lt;/a&gt;类型的值。</target>
        </trans-unit>
        <trans-unit id="9f77849f445f82a7dac2f95551cd7b942f343391" translate="yes" xml:space="preserve">
          <source>A value of a union type can be created using the same syntax that is used for struct types, except that it must specify exactly one field:</source>
          <target state="translated">联合类型的值可以使用与结构类型相同的语法来创建,但它必须只指定一个字段。</target>
        </trans-unit>
        <trans-unit id="2edc0a57205327b0c616a8834c05686bc2cd3aab" translate="yes" xml:space="preserve">
          <source>A value of type &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; representing logical &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">类型为&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt;的值，表示逻辑&lt;strong&gt;false&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="7083e77e4fd9ce896b8de61f936c4776bbf66b89" translate="yes" xml:space="preserve">
          <source>A value of type &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; representing logical &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">类型为&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt;的值，表示逻辑&lt;strong&gt;true&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="c8dd18f78fe47645f4c465046226e5bceaa87924" translate="yes" xml:space="preserve">
          <source>A value of type &lt;a href=&quot;primitive.bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; representing logical &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">类型为&lt;a href=&quot;primitive.bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt;的值，表示逻辑&lt;strong&gt;false&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="5f389328467f7ba3f2c3abda8662442b712ffb60" translate="yes" xml:space="preserve">
          <source>A value of type &lt;a href=&quot;primitive.bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; representing logical &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">&lt;a href=&quot;primitive.bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt;类型的值，表示逻辑&lt;strong&gt;true&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="b855bdd2c1132135fcde425660863334401f8ec6" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;char&lt;/code&gt; is a &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt; (i.e. a code point that is not a surrogate), represented as a 32-bit unsigned word in the 0x0000 to 0xD7FF or 0xE000 to 0x10FFFF range. A &lt;code&gt;[char]&lt;/code&gt; is effectively a UCS-4 / UTF-32 string.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 类型的值是&lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode标量值&lt;/a&gt;（即不是代理的代码点），表示为0x0000至0xD7FF或0xE000至0x10FFFF范围内的32位无符号字。阿 &lt;code&gt;[char]&lt;/code&gt; 实际上是一个UCS-4 / UTF-32字符串。</target>
        </trans-unit>
        <trans-unit id="d1f3055da898f22398d4fbd4a38fa84ee1e65f98" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;char&lt;/code&gt; is a &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt; (i.e. a code point that is not a surrogate), represented as a 32-bit unsigned word in the 0x0000 to 0xD7FF or 0xE000 to 0x10FFFF range. It is immediate &lt;a href=&quot;../behavior-considered-undefined&quot;&gt;Undefined Behavior&lt;/a&gt; to create a &lt;code&gt;char&lt;/code&gt; that falls outside this range. A &lt;code&gt;[char]&lt;/code&gt; is effectively a UCS-4 / UTF-32 string of length 1.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 类型的值是&lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode标量值&lt;/a&gt;（即不是代理的代码点），表示为0x0000至0xD7FF或0xE000至0x10FFFF范围内的32位无符号字。创建超出此范围的 &lt;code&gt;char&lt;/code&gt; 是立即&lt;a href=&quot;../behavior-considered-undefined&quot;&gt;未定义行为&lt;/a&gt;。阿 &lt;code&gt;[char]&lt;/code&gt; 实际上是一个UCS-4 / UTF-32长度为1的串。</target>
        </trans-unit>
        <trans-unit id="3e06926f845b74d33c5ef28adb8bb299e3388cd7" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;char&lt;/code&gt; is a &lt;a href=&quot;https://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt; (i.e. a code point that is not a surrogate), represented as a 32-bit unsigned word in the 0x0000 to 0xD7FF or 0xE000 to 0x10FFFF range. It is immediate &lt;a href=&quot;../behavior-considered-undefined&quot;&gt;Undefined Behavior&lt;/a&gt; to create a &lt;code&gt;char&lt;/code&gt; that falls outside this range. A &lt;code&gt;[char]&lt;/code&gt; is effectively a UCS-4 / UTF-32 string of length 1.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 类型的值是&lt;a href=&quot;https://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode标量值&lt;/a&gt;（即不是代理的代码点），表示为0x0000至0xD7FF或0xE000至0x10FFFF范围内的32位无符号字。创建超出此范围的 &lt;code&gt;char&lt;/code&gt; 是立即&lt;a href=&quot;../behavior-considered-undefined&quot;&gt;未定义行为&lt;/a&gt;。阿 &lt;code&gt;[char]&lt;/code&gt; 实际上是一个UCS-4 / UTF-32长度为1的串。</target>
        </trans-unit>
        <trans-unit id="59d76a5d3d80327c3f37cdc56ddfd9ab850292ae" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;str&lt;/code&gt; is a Unicode string, represented as an array of 8-bit unsigned bytes holding a sequence of UTF-8 code points. Since &lt;code&gt;str&lt;/code&gt; is a &lt;a href=&quot;../dynamically-sized-types&quot;&gt;dynamically sized type&lt;/a&gt;, it is not a &lt;em&gt;first-class&lt;/em&gt; type, but can only be instantiated through a pointer type, such as &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 类型的值是Unicode字符串，表示为一个8位无符号字节的数组，其中包含一系列UTF-8代码点。由于 &lt;code&gt;str&lt;/code&gt; 是&lt;a href=&quot;../dynamically-sized-types&quot;&gt;动态大小的类型&lt;/a&gt;，因此它不是&lt;em&gt;一流的&lt;/em&gt;类型，只能通过指针类型（例如 &lt;code&gt;&amp;amp;str&lt;/code&gt; )实例化。</target>
        </trans-unit>
        <trans-unit id="bbb241cb793b74334bb4ee4c800e211086ca2124" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;str&lt;/code&gt; is represented the same way as &lt;code&gt;[u8]&lt;/code&gt;, it is a slice of 8-bit unsigned bytes. However, the Rust standard library makes extra assumptions about &lt;code&gt;str&lt;/code&gt;: methods working on &lt;code&gt;str&lt;/code&gt; assume and ensure that the data in there is valid UTF-8. Calling a &lt;code&gt;str&lt;/code&gt; method with a non-UTF-8 buffer can cause &lt;a href=&quot;../behavior-considered-undefined&quot;&gt;Undefined Behavior&lt;/a&gt; now or in the future.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 类型的值以与 &lt;code&gt;[u8]&lt;/code&gt; 相同的方式表示，它是8位无符号字节的切片。然而，防锈标准库，使额外的假设约 &lt;code&gt;str&lt;/code&gt; ：工作方法 &lt;code&gt;str&lt;/code&gt; 承担并确保数据在没有有效的UTF-8。使用非UTF-8缓冲区调用 &lt;code&gt;str&lt;/code&gt; 方法可能会导致现在或将来出现&lt;a href=&quot;../behavior-considered-undefined&quot;&gt;未定义行为&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a63b20136e367659035b6e689b2afe4c29bd6017" translate="yes" xml:space="preserve">
          <source>A value other than &lt;code&gt;false&lt;/code&gt; (&lt;code&gt;0&lt;/code&gt;) or &lt;code&gt;true&lt;/code&gt; (&lt;code&gt;1&lt;/code&gt;) in a &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 值中除 &lt;code&gt;false&lt;/code&gt; （ &lt;code&gt;0&lt;/code&gt; ）或 &lt;code&gt;true&lt;/code&gt; （ &lt;code&gt;1&lt;/code&gt; ）以外的值。</target>
        </trans-unit>
        <trans-unit id="b4cba545fd19cda1128ffaf1d3286b9b7d56cde6" translate="yes" xml:space="preserve">
          <source>A value was moved out of a non-copy fixed-size array.</source>
          <target state="translated">一个值被从一个非复制的固定大小的阵列中移出。</target>
        </trans-unit>
        <trans-unit id="b42cffab7e9c15b342f66d8f5259941653a63c96" translate="yes" xml:space="preserve">
          <source>A value was moved out while it was still borrowed.</source>
          <target state="translated">在还在借钱的时候,就把一个值搬出来了。</target>
        </trans-unit>
        <trans-unit id="82027756f29be28c79aeae3975a5766aa1d2efa8" translate="yes" xml:space="preserve">
          <source>A value was moved whose size was not known at compile time.</source>
          <target state="translated">一个在编译时不知道其大小的值被移动了。</target>
        </trans-unit>
        <trans-unit id="9706341e2da60c066ce6e7cf05178b38f120d103" translate="yes" xml:space="preserve">
          <source>A value was moved. However, its size was not known at compile time, and only values of a known size can be moved.</source>
          <target state="translated">一个值被移动了。但是,在编译时不知道它的大小,只有已知大小的值才能被移动。</target>
        </trans-unit>
        <trans-unit id="44837e659d57e9e8963db42f2a8ff432184c868b" translate="yes" xml:space="preserve">
          <source>A value was used after it was mutably borrowed.</source>
          <target state="translated">价值被突变借用后使用。</target>
        </trans-unit>
        <trans-unit id="a269a1265b9da40e02988ddb4b935f3e57685c81" translate="yes" xml:space="preserve">
          <source>A value which is initialized on the first access.</source>
          <target state="translated">第一次访问时初始化的值。</target>
        </trans-unit>
        <trans-unit id="0a9fd9c77be9db665eaa8aa09f7c11046598c96c" translate="yes" xml:space="preserve">
          <source>A value with a custom &lt;code&gt;Drop&lt;/code&gt; implementation may be dropped during const-eval.</source>
          <target state="translated">在const-eval期间，可能会删除具有自定义 &lt;code&gt;Drop&lt;/code&gt; 实现的值。</target>
        </trans-unit>
        <trans-unit id="ce9baf105eb065b4e2e707a1c70964d52846271c" translate="yes" xml:space="preserve">
          <source>A value, once pinned, must remain pinned forever (unless its type implements &lt;code&gt;Unpin&lt;/code&gt;).</source>
          <target state="translated">固定后的值必须永远固定（除非其类型实现 &lt;code&gt;Unpin&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f834afc88c6404de279c7c8f515cfb4300b16ac9" translate="yes" xml:space="preserve">
          <source>A value-to-value conversion that consumes the input value. The opposite of &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">消耗输入值的值到值转换。与&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt;相反。</target>
        </trans-unit>
        <trans-unit id="0ec26c2f12c942e7a95c50dd2e23886df77a4d3b" translate="yes" xml:space="preserve">
          <source>A variable already borrowed as immutable was borrowed as mutable.</source>
          <target state="translated">已经借为不可变的变量被借为可变。</target>
        </trans-unit>
        <trans-unit id="e13d6f0eba74b4bdfc6f5572578b32920b145941" translate="yes" xml:space="preserve">
          <source>A variable is initialized if it has been assigned a value and hasn't since been moved from. All other memory locations are assumed to be uninitialized. Only unsafe Rust can create such a memory without initializing it.</source>
          <target state="translated">如果一个变量被分配了一个值,并且没有被移动过,那么这个变量就被初始化了。所有其他的内存位置被认为是未初始化的。只有不安全的Rust才能在不初始化的情况下创建这样的内存。</target>
        </trans-unit>
        <trans-unit id="bcb706d6a23f6a1ef0d6e932c9012ea02de89d1f" translate="yes" xml:space="preserve">
          <source>A variable used inside an inner function comes from a dynamic environment.</source>
          <target state="translated">内部函数内部使用的变量来自于动态环境。</target>
        </trans-unit>
        <trans-unit id="624b6ee4bba7ea4936aac9cd4851655dde5b7367" translate="yes" xml:space="preserve">
          <source>A variable was borrowed as mutable more than once.</source>
          <target state="translated">一个变量被不止一次地借用为可突变变量。</target>
        </trans-unit>
        <trans-unit id="d671f0302da4834f34c2a582f5308578a61da28e" translate="yes" xml:space="preserve">
          <source>A variable was borrowed as mutable more than once. Erroneous code example:</source>
          <target state="translated">一个变量被借用为mutable不止一次。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="8f68dfea86962d0e6496e5ee7e7ba76db7429014" translate="yes" xml:space="preserve">
          <source>A variable was used after its contents have been moved elsewhere.</source>
          <target state="translated">变量的内容被移到其他地方后被使用。</target>
        </trans-unit>
        <trans-unit id="7373f15283d19d70ccdc1ebdabd671b6fa35a616" translate="yes" xml:space="preserve">
          <source>A variable which requires unique access is being used in more than one closure at the same time.</source>
          <target state="translated">一个需要唯一访问的变量在多个闭合中同时使用。</target>
        </trans-unit>
        <trans-unit id="179ae2668e7ec007982c4f5de54552aaba759982" translate="yes" xml:space="preserve">
          <source>A very common source of input is standard input:</source>
          <target state="translated">一个很常见的输入源是标准输入。</target>
        </trans-unit>
        <trans-unit id="8fd033d78acbcd4754d1027990e8d5a9b9826bd0" translate="yes" xml:space="preserve">
          <source>A very simple implementation of a &lt;code&gt;Balance&lt;/code&gt; struct that has two sides, where each can be indexed mutably and immutably.</source>
          <target state="translated">&lt;code&gt;Balance&lt;/code&gt; 结构的非常简单的实现，它具有两个面，每个面都可以可变和不可变地进行索引。</target>
        </trans-unit>
        <trans-unit id="97a780f793593419e0ff592febcf6977a93355f0" translate="yes" xml:space="preserve">
          <source>A view into a single entry in a map, which may either be vacant or occupied.</source>
          <target state="translated">查看地图中的单个条目,该条目可能是空置的,也可能是被占用的。</target>
        </trans-unit>
        <trans-unit id="8b25993b294c4224a4cf2b72c86b09f4a1df51e2" translate="yes" xml:space="preserve">
          <source>A view into a vacant entry in a &lt;code&gt;BTreeMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; 中的空闲条目的视图。它是&lt;a href=&quot;enum.entry&quot;&gt; &lt;code&gt;Entry&lt;/code&gt; &lt;/a&gt;枚举的一部分。</target>
        </trans-unit>
        <trans-unit id="7403429e7fd780dc27d8a13d9952581d4b4e445e" translate="yes" xml:space="preserve">
          <source>A view into a vacant entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 中的空条目的视图。它是&lt;a href=&quot;enum.entry&quot;&gt; &lt;code&gt;Entry&lt;/code&gt; &lt;/a&gt;枚举的一部分。</target>
        </trans-unit>
        <trans-unit id="e122826d4e223005f70614b786e8ddc75140b027" translate="yes" xml:space="preserve">
          <source>A view into a vacant entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.rawentrymut&quot;&gt;&lt;code&gt;RawEntryMut&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 中的空条目的视图。它是&lt;a href=&quot;enum.rawentrymut&quot;&gt; &lt;code&gt;RawEntryMut&lt;/code&gt; &lt;/a&gt;枚举的一部分。</target>
        </trans-unit>
        <trans-unit id="ce99b5e5cd3ea34b7d4c0f89a8831922c382a6d4" translate="yes" xml:space="preserve">
          <source>A view into an occupied entry in a &lt;code&gt;BTreeMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; 中已占用条目的视图。它是&lt;a href=&quot;enum.entry&quot;&gt; &lt;code&gt;Entry&lt;/code&gt; &lt;/a&gt;枚举的一部分。</target>
        </trans-unit>
        <trans-unit id="be269036f18f5f092608a130f8ea68df4394d390" translate="yes" xml:space="preserve">
          <source>A view into an occupied entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 中已占用条目的视图。它是&lt;a href=&quot;enum.entry&quot;&gt; &lt;code&gt;Entry&lt;/code&gt; &lt;/a&gt;枚举的一部分。</target>
        </trans-unit>
        <trans-unit id="097a52eaa6538170318bb496b2404a2534b2fc4c" translate="yes" xml:space="preserve">
          <source>A view into an occupied entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.rawentrymut&quot;&gt;&lt;code&gt;RawEntryMut&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 中已占用条目的视图。它是&lt;a href=&quot;enum.rawentrymut&quot;&gt; &lt;code&gt;RawEntryMut&lt;/code&gt; &lt;/a&gt;枚举的一部分。</target>
        </trans-unit>
        <trans-unit id="1dcb56819c21811e53111728b70cf9c4d536f34f" translate="yes" xml:space="preserve">
          <source>A virtual function pointer table (vtable) that specifies the behavior of a &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">一个虚拟函数指针表（vtable），用于指定&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt;的行为。</target>
        </trans-unit>
        <trans-unit id="9f3a191fe5eca1034f9485c5579c98bfcc0c4efc" translate="yes" xml:space="preserve">
          <source>A visibility qualifier was used when it was unnecessary.</source>
          <target state="translated">在没有必要的情况下,使用了知名度限定词。</target>
        </trans-unit>
        <trans-unit id="ac7d35f82dab2d813057ea592ffddd469b64e834" translate="yes" xml:space="preserve">
          <source>A visibility qualifier was used when it was unnecessary. Erroneous code examples:</source>
          <target state="translated">在不必要的情况下使用了可见性限定词。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="b3fc7b3827a6fcc8a59a000c786e3c02a55a53ac" translate="yes" xml:space="preserve">
          <source>A while-let pattern attempts to match the pattern, and enters the body if the match was successful. If the match is irrefutable (when it cannot fail to match), use a regular &lt;code&gt;let&lt;/code&gt;-binding inside a &lt;code&gt;loop&lt;/code&gt; instead. For instance:</source>
          <target state="translated">While允许模式尝试匹配该模式，如果匹配成功，则进入正文。如果匹配是不可辩驳的（当匹配不能失败时），请在 &lt;code&gt;loop&lt;/code&gt; 内使用常规的 &lt;code&gt;let&lt;/code&gt; -binding 。例如：</target>
        </trans-unit>
        <trans-unit id="410ed7d62125fc62e5f4dca9f96376b96589d768" translate="yes" xml:space="preserve">
          <source>A windowed iterator over a slice in overlapping chunks (&lt;code&gt;N&lt;/code&gt; elements at a time), starting at the beginning of the slice</source>
          <target state="translated">在切片上以重叠块（每次 &lt;code&gt;N&lt;/code&gt; 个元素）的窗口迭代器，从切片的开头开始</target>
        </trans-unit>
        <trans-unit id="fc142166b026c4503335a66425ed02745d313757" translate="yes" xml:space="preserve">
          <source>A workaround for this problem is to wrap the trait up in a struct, and implement Drop on that. An example is shown below:</source>
          <target state="translated">这个问题的变通方法是将trait包在一个结构中,并在其上实现Drop。下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="f617743555e205f1a8f890d184cd3c23b7f7c1f7" translate="yes" xml:space="preserve">
          <source>A workaround for this problem is to wrap the trait up in a struct, and implement Drop on that:</source>
          <target state="translated">这个问题的变通方法是将trait包在一个结构中,并在其上实现Drop。</target>
        </trans-unit>
        <trans-unit id="2126e0b1e41989d782fb5cb045faec8bb5419d59" translate="yes" xml:space="preserve">
          <source>A working version would be:</source>
          <target state="translated">一个工作版本将是:</target>
        </trans-unit>
        <trans-unit id="0d662f80f6ce134ee94f8241854c8eb7d0a73167" translate="yes" xml:space="preserve">
          <source>A wrapper for a &lt;code&gt;va_list&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;va_list&lt;/code&gt; 的包装器</target>
        </trans-unit>
        <trans-unit id="b7d2953f481ad207e80e2b4f3ea38a3fc7fdbf37" translate="yes" xml:space="preserve">
          <source>A wrapper to inhibit compiler from automatically calling &lt;code&gt;T&lt;/code&gt;&amp;rsquo;s destructor.</source>
          <target state="translated">包装器，用于禁止编译器自动调用 &lt;code&gt;T&lt;/code&gt; 的析构函数。</target>
        </trans-unit>
        <trans-unit id="fd107425d645d1765a8fa8c1d57cb5b2986006a8" translate="yes" xml:space="preserve">
          <source>A wrapper to inhibit compiler from automatically calling &lt;code&gt;T&lt;/code&gt;&amp;rsquo;s destructor. This wrapper is 0-cost.</source>
          <target state="translated">包装器，用于禁止编译器自动调用 &lt;code&gt;T&lt;/code&gt; 的析构函数。该包装器的成本为0。</target>
        </trans-unit>
        <trans-unit id="27e603a9954cbc24a31a5ec5bf12ad7cbfb65091" translate="yes" xml:space="preserve">
          <source>A wrapper type for a mutably borrowed value from a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 可变借入的值的包装器类型。</target>
        </trans-unit>
        <trans-unit id="76e573ae156cec07995313b0af472777485c1ac4" translate="yes" xml:space="preserve">
          <source>A wrapper type to construct uninitialized instances of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">包装器类型，用于构造 &lt;code&gt;T&lt;/code&gt; 的未初始化实例。</target>
        </trans-unit>
        <trans-unit id="4e4e6894ffe01981313c8a0bdd641986bcbb13e0" translate="yes" xml:space="preserve">
          <source>A writer which will move data into the void.</source>
          <target state="translated">一个将数据移入虚空的写入器。</target>
        </trans-unit>
        <trans-unit id="3c1aa63d0f65966b349901d79576dfb3a03d713a" translate="yes" xml:space="preserve">
          <source>A yank &lt;em&gt;does not&lt;/em&gt; delete any code. For example, the yank feature is not intended for deleting accidentally uploaded secrets. If that happens, you must reset those secrets immediately.</source>
          <target state="translated">猛拉&lt;em&gt;不会&lt;/em&gt;删除任何代码。例如，猛拉功能不旨在删除意外上载的机密。如果发生这种情况，您必须立即重置这些机密。</target>
        </trans-unit>
        <trans-unit id="c0f586bae86592aff79f5cdbd80a984e38bc5729" translate="yes" xml:space="preserve">
          <source>A yield expression was used outside of the generator literal.</source>
          <target state="translated">在生成器文字外使用了一个屈服表达式。</target>
        </trans-unit>
        <trans-unit id="441d954d4dd0146ecde4bbe0bfe1d8d54e840f8a" translate="yes" xml:space="preserve">
          <source>ABI</source>
          <target state="translated">ABI</target>
        </trans-unit>
        <trans-unit id="f7f4dbec39b0ff3d85b8eb96500c85b0c6447c9c" translate="yes" xml:space="preserve">
          <source>ABI, linking, symbols, and FFI</source>
          <target state="translated">ABI、链接、符号和FFI。</target>
        </trans-unit>
        <trans-unit id="6984d7f2e63fc7e0a74bddee5e62b9dd8e8c052e" translate="yes" xml:space="preserve">
          <source>API not fully fleshed out and ready to be stabilized</source>
          <target state="translated">原料药尚未完全成熟,准备稳定下来</target>
        </trans-unit>
        <trans-unit id="711248439308ea2477b7d1f8ab4f7bd34663bf23" translate="yes" xml:space="preserve">
          <source>APIs like &lt;code&gt;try_for_each&lt;/code&gt; don't need values with &lt;code&gt;Break&lt;/code&gt;, so this provides a way to avoid typing &lt;code&gt;(())&lt;/code&gt;, if you prefer it.</source>
          <target state="translated">像 &lt;code&gt;try_for_each&lt;/code&gt; 这样的API不需要带有 &lt;code&gt;Break&lt;/code&gt; 的值，因此，如果愿意，这提供了一种避免输入 &lt;code&gt;(())&lt;/code&gt; 的方法。</target>
        </trans-unit>
        <trans-unit id="623cb147c595ee00f55c9bfbece2fd89256c0ca0" translate="yes" xml:space="preserve">
          <source>ARCH</source>
          <target state="translated">ARCH</target>
        </trans-unit>
        <trans-unit id="ebb42dcc0b64c9c253b3563c217764b64d93cc3b" translate="yes" xml:space="preserve">
          <source>ARM platforms like &lt;code&gt;armv5te&lt;/code&gt; that aren't for Linux do not have any atomics at all.</source>
          <target state="translated">并非适用于Linux的ARM平台（如 &lt;code&gt;armv5te&lt;/code&gt; )根本没有任何原子。</target>
        </trans-unit>
        <trans-unit id="9c08db2a34e8bae40e385191593c075648426189" translate="yes" xml:space="preserve">
          <source>ARM platforms like &lt;code&gt;armv5te&lt;/code&gt; that aren't for Linux only provide &lt;code&gt;load&lt;/code&gt; and &lt;code&gt;store&lt;/code&gt; operations, and do not support Compare and Swap (CAS) operations, such as &lt;code&gt;swap&lt;/code&gt;, &lt;code&gt;fetch_add&lt;/code&gt;, etc. Additionally on Linux, these CAS operations are implemented via &lt;a href=&quot;https://www.kernel.org/doc/Documentation/arm/kernel_user_helpers.txt&quot;&gt;operating system support&lt;/a&gt;, which may come with a performance penalty.</source>
          <target state="translated">不适用于Linux的ARM平台（例如 &lt;code&gt;armv5te&lt;/code&gt; )仅提供 &lt;code&gt;load&lt;/code&gt; 和 &lt;code&gt;store&lt;/code&gt; 操作，并且不支持比较和交换（CAS）操作，例如 &lt;code&gt;swap&lt;/code&gt; ， &lt;code&gt;fetch_add&lt;/code&gt; 等。此外，在Linux上，这些CAS操作是通过&lt;a href=&quot;https://www.kernel.org/doc/Documentation/arm/kernel_user_helpers.txt&quot;&gt;操作系统支持&lt;/a&gt;来实现的，这可能会带来性能损失。</target>
        </trans-unit>
        <trans-unit id="5d8a36ef8e4b107d52ef5f736828e510925b8177" translate="yes" xml:space="preserve">
          <source>ARM targets with &lt;code&gt;thumbv6m&lt;/code&gt; do not have atomic operations at all.</source>
          <target state="translated">带有 &lt;code&gt;thumbv6m&lt;/code&gt; 的 ARM目标完全没有原子操作。</target>
        </trans-unit>
        <trans-unit id="f34ee041311ae3f08813e81fbedc2a8cd4a047c6" translate="yes" xml:space="preserve">
          <source>ARM targets with &lt;code&gt;thumbv6m&lt;/code&gt; only provide &lt;code&gt;load&lt;/code&gt; and &lt;code&gt;store&lt;/code&gt; operations, and do not support Compare and Swap (CAS) operations, such as &lt;code&gt;swap&lt;/code&gt;, &lt;code&gt;fetch_add&lt;/code&gt;, etc.</source>
          <target state="translated">带有 &lt;code&gt;thumbv6m&lt;/code&gt; 的ARM目标仅提供 &lt;code&gt;load&lt;/code&gt; 和 &lt;code&gt;store&lt;/code&gt; 操作，不支持比较和交换（CAS）操作，例如 &lt;code&gt;swap&lt;/code&gt; ， &lt;code&gt;fetch_add&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="bb0279d84c9ab08002a8ea7634cd21f2283a6099" translate="yes" xml:space="preserve">
          <source>ASCII :</source>
          <target state="translated">ASCII码 :</target>
        </trans-unit>
        <trans-unit id="317e8901215d42ccc7940d34b4ce9490884463f7" translate="yes" xml:space="preserve">
          <source>ASCII byte literal</source>
          <target state="translated">ASCII字节文字</target>
        </trans-unit>
        <trans-unit id="4d8ae89e872f4c2b2dd8feb9252c9a119be50b1e" translate="yes" xml:space="preserve">
          <source>ASCII escapes</source>
          <target state="translated">ASCII码逃逸</target>
        </trans-unit>
        <trans-unit id="ca370d4b69baa6a205bc27d7c92d683f7ec62f70" translate="yes" xml:space="preserve">
          <source>ASCII letters 'A' to 'Z' are mapped to 'a' to 'z', but non-ASCII letters are unchanged.</source>
          <target state="translated">ASCII字母'A'至'Z'被映射为'a'至'z',但非ASCII字母不变。</target>
        </trans-unit>
        <trans-unit id="2e3db4ca30bac04610a9ba330ec0d3d5c61cf4d8" translate="yes" xml:space="preserve">
          <source>ASCII letters 'a' to 'z' are mapped to 'A' to 'Z', but non-ASCII letters are unchanged.</source>
          <target state="translated">ASCII字母'a'至'z'被映射为'A'至'Z',但非ASCII字母不变。</target>
        </trans-unit>
        <trans-unit id="958cc1148f8aff5543459cc62e998e9d661990e7" translate="yes" xml:space="preserve">
          <source>ASCII_ESCAPE :</source>
          <target state="translated">ASCII_ESCAPE :</target>
        </trans-unit>
        <trans-unit id="8d6c4817508ef1c56c15761069329bc78c08e97c" translate="yes" xml:space="preserve">
          <source>ASCII_FOR_CHAR :</source>
          <target state="translated">ASCII_FOR_CHAR :</target>
        </trans-unit>
        <trans-unit id="1e976fbca3f1cd1471746ec2b3ff6a7a5d15936f" translate="yes" xml:space="preserve">
          <source>ASCII_FOR_STRING :</source>
          <target state="translated">ASCII_FOR_STRING :</target>
        </trans-unit>
        <trans-unit id="b6453d9f657d21e7c289076ce98028e47dc7282d" translate="yes" xml:space="preserve">
          <source>ATOMIC_BOOL_INIT</source>
          <target state="translated">ATOMIC_BOOL_INIT</target>
        </trans-unit>
        <trans-unit id="2b9c513ccbb146434eeb5bd6802254d3e9319214" translate="yes" xml:space="preserve">
          <source>ATOMIC_I16_INIT</source>
          <target state="translated">ATOMIC_I16_INIT</target>
        </trans-unit>
        <trans-unit id="6eacbfe2c8c788ffc6b7a2bdbffc94fa45c82d1a" translate="yes" xml:space="preserve">
          <source>ATOMIC_I32_INIT</source>
          <target state="translated">ATOMIC_I32_INIT</target>
        </trans-unit>
        <trans-unit id="66f562d6648e128b70300462dcad7b8fc4608b4d" translate="yes" xml:space="preserve">
          <source>ATOMIC_I64_INIT</source>
          <target state="translated">ATOMIC_I64_INIT</target>
        </trans-unit>
        <trans-unit id="3fed299eb934560d34d135ac41857a8fb36ef0bf" translate="yes" xml:space="preserve">
          <source>ATOMIC_I8_INIT</source>
          <target state="translated">ATOMIC_I8_INIT</target>
        </trans-unit>
        <trans-unit id="bdb0440ba3e33135f2c764f4348aac2801df19e3" translate="yes" xml:space="preserve">
          <source>ATOMIC_ISIZE_INIT</source>
          <target state="translated">ATOMIC_ISIZE_INIT</target>
        </trans-unit>
        <trans-unit id="8666b79dcee9e5c85aa6e1517921389330c7bb56" translate="yes" xml:space="preserve">
          <source>ATOMIC_U16_INIT</source>
          <target state="translated">ATOMIC_U16_INIT</target>
        </trans-unit>
        <trans-unit id="5463cfe71666bd3cbb7e7bd93e1dea5283405daf" translate="yes" xml:space="preserve">
          <source>ATOMIC_U32_INIT</source>
          <target state="translated">ATOMIC_U32_INIT</target>
        </trans-unit>
        <trans-unit id="fee37bb8c4ae8ff95ead7263aeefbf92f4fb076f" translate="yes" xml:space="preserve">
          <source>ATOMIC_U64_INIT</source>
          <target state="translated">ATOMIC_U64_INIT</target>
        </trans-unit>
        <trans-unit id="b5fd0a39697ab3a5f13871b24404fa76ef7723d2" translate="yes" xml:space="preserve">
          <source>ATOMIC_U8_INIT</source>
          <target state="translated">ATOMIC_U8_INIT</target>
        </trans-unit>
        <trans-unit id="b775de59887a198b8bb80812de87ea9a271a97f2" translate="yes" xml:space="preserve">
          <source>ATOMIC_USIZE_INIT</source>
          <target state="translated">ATOMIC_USIZE_INIT</target>
        </trans-unit>
        <trans-unit id="931aa76f7d621b2bd9a484f56b5e9a93cf07c3f7" translate="yes" xml:space="preserve">
          <source>Abort on memory allocation error or failure.</source>
          <target state="translated">内存分配错误或失败时中止。</target>
        </trans-unit>
        <trans-unit id="df06ef34b8240a09fa9f161ea99137607ac00a56" translate="yes" xml:space="preserve">
          <source>Aborts the execution of the process.</source>
          <target state="translated">中止进程的执行。</target>
        </trans-unit>
        <trans-unit id="b619665e057a59c1a1dbdf52957bcc9212748104" translate="yes" xml:space="preserve">
          <source>Abstract return types</source>
          <target state="translated">抽象的返回类型</target>
        </trans-unit>
        <trans-unit id="db7472b4d6bc69237c01f48a8b625cef374de6c1" translate="yes" xml:space="preserve">
          <source>Abstract return types (written &lt;code&gt;impl Trait&lt;/code&gt; for some trait &lt;code&gt;Trait&lt;/code&gt;) are only allowed as function and inherent impl return types.</source>
          <target state="translated">抽象返回类型（为某些特征 &lt;code&gt;Trait&lt;/code&gt; 编写了 &lt;code&gt;impl Trait&lt;/code&gt; ）仅用作函数和固有的impl返回类型。</target>
        </trans-unit>
        <trans-unit id="bdd7aedb4bc31655563e1852b48c298d5ec5570e" translate="yes" xml:space="preserve">
          <source>Abstract syntax tree</source>
          <target state="translated">抽象语法树</target>
        </trans-unit>
        <trans-unit id="8a308b160b478c6d80c833cea5942381a0eb8138" translate="yes" xml:space="preserve">
          <source>Accept a new incoming connection from this listener.</source>
          <target state="translated">接受来自该监听器的新传入连接。</target>
        </trans-unit>
        <trans-unit id="9d161ad935c554382c0d645c53e65dd6566a4bb5" translate="yes" xml:space="preserve">
          <source>Accepting Command Line Arguments</source>
          <target state="translated">接受命令行参数</target>
        </trans-unit>
        <trans-unit id="5c44c9a8bf41c1458082624764926e9e452b0f9a" translate="yes" xml:space="preserve">
          <source>Accepts &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;AcqRel&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;SeqCst&lt;/code&gt;&lt;/a&gt; orderings.</source>
          <target state="translated">接受&lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;AcqRel&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;SeqCst&lt;/code&gt; &lt;/a&gt;排序。</target>
        </trans-unit>
        <trans-unit id="a053fb66cacbf9febf839206d8e07b27aeeb3488" translate="yes" xml:space="preserve">
          <source>Accepts a new incoming connection to this listener.</source>
          <target state="translated">接受一个新传入的连接到这个监听器。</target>
        </trans-unit>
        <trans-unit id="41aadfd41c1a6581a617dbde4d22fdb01baa3e91" translate="yes" xml:space="preserve">
          <source>Access an entry by a key and its hash.</source>
          <target state="translated">通过密钥及其哈希值访问一个条目。</target>
        </trans-unit>
        <trans-unit id="51a3abe326b3c0792015c0e4fe719586def474a7" translate="yes" xml:space="preserve">
          <source>Access an entry by hash.</source>
          <target state="translated">通过哈希值访问一个条目。</target>
        </trans-unit>
        <trans-unit id="fab65c5f7333ea79c15d33939860036f46df2b02" translate="yes" xml:space="preserve">
          <source>Access an entry by key.</source>
          <target state="translated">通过钥匙进入一个条目。</target>
        </trans-unit>
        <trans-unit id="f8d8572e08e06ee9c752f760cd0d14aa8e2826f1" translate="yes" xml:space="preserve">
          <source>Access fields in a packed struct:</source>
          <target state="translated">访问打包结构中的字段。</target>
        </trans-unit>
        <trans-unit id="dcc61ae90f40e1ace5937cd1dcd9d685d9053fd4" translate="yes" xml:space="preserve">
          <source>Access fields of &lt;a href=&quot;keyword.union&quot;&gt;&lt;code&gt;union&lt;/code&gt;&lt;/a&gt;s</source>
          <target state="translated">&lt;a href=&quot;keyword.union&quot;&gt; &lt;code&gt;union&lt;/code&gt; &lt;/a&gt;的访问字段</target>
        </trans-unit>
        <trans-unit id="b465e0094928c80bf2ab2af5859dca5bafc8fa28" translate="yes" xml:space="preserve">
          <source>Access fields of &lt;code&gt;union&lt;/code&gt;s</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; 的访问字段</target>
        </trans-unit>
        <trans-unit id="9ea16fa6ced966020c4bffbd61fb4353757d0cf8" translate="yes" xml:space="preserve">
          <source>Access members of a packed struct by reference:</source>
          <target state="translated">通过引用访问一个打包结构的成员。</target>
        </trans-unit>
        <trans-unit id="8b8e97faa7739e19473f47e07608526221b515e7" translate="yes" xml:space="preserve">
          <source>Access or modify a mutable static variable</source>
          <target state="translated">访问或修改一个可变的静态变量</target>
        </trans-unit>
        <trans-unit id="cd54de93b3358e522ad1a3c574f8befd63e8ca75" translate="yes" xml:space="preserve">
          <source>Access the underlying UTF-8 error that was the cause of this error.</source>
          <target state="translated">访问导致该错误的潜在UTF-8错误。</target>
        </trans-unit>
        <trans-unit id="46164e9a717820065d93ac43f40d916b0e4e7553" translate="yes" xml:space="preserve">
          <source>AccessError</source>
          <target state="translated">AccessError</target>
        </trans-unit>
        <trans-unit id="ce24154072e2c91b2d63af9c452a4cc41adea723" translate="yes" xml:space="preserve">
          <source>AccessError::borrow</source>
          <target state="translated">AccessError::borrow</target>
        </trans-unit>
        <trans-unit id="0cc742fcaecb2fa19742b5bc67e762feaa6f37c0" translate="yes" xml:space="preserve">
          <source>AccessError::borrow_mut</source>
          <target state="translated">AccessError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="a94e2b3363d2d1a8ced8c51a5e15ff4f96e5bb39" translate="yes" xml:space="preserve">
          <source>AccessError::fmt</source>
          <target state="translated">AccessError::fmt</target>
        </trans-unit>
        <trans-unit id="2c2380ad9f60011344ab503262723a632ed3c1d2" translate="yes" xml:space="preserve">
          <source>AccessError::from</source>
          <target state="translated">AccessError::from</target>
        </trans-unit>
        <trans-unit id="7621469337a4b2f74d2a377616bccd38326a7edd" translate="yes" xml:space="preserve">
          <source>AccessError::into</source>
          <target state="translated">AccessError::into</target>
        </trans-unit>
        <trans-unit id="57d0ff4e6d1785ba4d9a1781d3047ed655772b49" translate="yes" xml:space="preserve">
          <source>AccessError::to_string</source>
          <target state="translated">AccessError::to_string</target>
        </trans-unit>
        <trans-unit id="c9ce68542ae4f2f8f818a2b5731ce826d35da932" translate="yes" xml:space="preserve">
          <source>AccessError::try_from</source>
          <target state="translated">AccessError::try_from</target>
        </trans-unit>
        <trans-unit id="cbc880d00714a36a28ddfefa1107fb401f040376" translate="yes" xml:space="preserve">
          <source>AccessError::try_into</source>
          <target state="translated">AccessError::try_into</target>
        </trans-unit>
        <trans-unit id="f18106e890f07e143593c942859c5df6ac97bdb0" translate="yes" xml:space="preserve">
          <source>AccessError::type_id</source>
          <target state="translated">AccessError::type_id</target>
        </trans-unit>
        <trans-unit id="6260b03bb183bb1a54da2dc8ffad6ed6483c869e" translate="yes" xml:space="preserve">
          <source>Accessing Array Elements</source>
          <target state="translated">访问阵列元素</target>
        </trans-unit>
        <trans-unit id="0457e6128b17f06deb434a0c2873ebd99b60eb0d" translate="yes" xml:space="preserve">
          <source>Accessing Fields of a Union</source>
          <target state="translated">访问联盟的字段</target>
        </trans-unit>
        <trans-unit id="6a8c72aa13ec7be5fc27578400a1a226881f478c" translate="yes" xml:space="preserve">
          <source>Accessing Values in a Hash Map</source>
          <target state="translated">访问哈希图中的值</target>
        </trans-unit>
        <trans-unit id="b06fec963d87626314583ae2b00b8c48fde3efce" translate="yes" xml:space="preserve">
          <source>Accessing a field of a &lt;a href=&quot;items/unions&quot;&gt;&lt;code&gt;union&lt;/code&gt;&lt;/a&gt;, other than to assign to it.</source>
          <target state="translated">访问&lt;a href=&quot;items/unions&quot;&gt; &lt;code&gt;union&lt;/code&gt; &lt;/a&gt;字段，而不是为其分配字段。</target>
        </trans-unit>
        <trans-unit id="a0cd0bd48f335ea136bd217d77f1a368ccbcee58" translate="yes" xml:space="preserve">
          <source>Accessing adjacent &lt;code&gt;u8&lt;/code&gt; as &lt;code&gt;u16&lt;/code&gt;</source>
          <target state="translated">以 &lt;code&gt;u16&lt;/code&gt; 身份访问相邻的 &lt;code&gt;u8&lt;/code&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
