<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="545e192087f2dee8a1244b50285f56354faded13" translate="yes" xml:space="preserve">
          <source>The warning suggests that we use &lt;code&gt;_i&lt;/code&gt; as a name instead: the underscore indicates that we intend for this variable to be unused. We can automatically apply that suggestion using the &lt;code&gt;rustfix&lt;/code&gt; tool by running the command &lt;code&gt;cargo fix&lt;/code&gt;:</source>
          <target state="translated">该警告表明我们改为使用 &lt;code&gt;_i&lt;/code&gt; 作为名称：下划线表示我们打算使该变量不使用。我们可以通过运行command &lt;code&gt;cargo fix&lt;/code&gt; 命令，使用 &lt;code&gt;rustfix&lt;/code&gt; 工具自动应用该建议：</target>
        </trans-unit>
        <trans-unit id="71e5980a6bfd716abaaef858ffaa58512cff6b9e" translate="yes" xml:space="preserve">
          <source>The warning we get is this:</source>
          <target state="translated">我们得到的警告是这样的。</target>
        </trans-unit>
        <trans-unit id="01d3cf24ed7ac31e045df84ed43b543301d5071c" translate="yes" xml:space="preserve">
          <source>The way in which you need to specify lifetime parameters depends on what your function is doing. For example, if we changed the implementation of the &lt;code&gt;longest&lt;/code&gt; function to always return the first parameter rather than the longest string slice, we wouldn&amp;rsquo;t need to specify a lifetime on the &lt;code&gt;y&lt;/code&gt; parameter. The following code will compile:</source>
          <target state="translated">您需要指定生存期参数的方式取决于函数的功能。例如，如果我们将 &lt;code&gt;longest&lt;/code&gt; 函数的实现更改为始终返回第一个参数而不是最长字符串切片，则不需要在 &lt;code&gt;y&lt;/code&gt; 参数上指定生存期。以下代码将编译：</target>
        </trans-unit>
        <trans-unit id="5b549318fc3f4ca028012969aeab8043ad858528" translate="yes" xml:space="preserve">
          <source>The way privacy works in Rust is that all items (functions, methods, structs, enums, modules, and constants) are private by default. Items in a parent module can&amp;rsquo;t use the private items inside child modules, but items in child modules can use the items in their ancestor modules. The reason is that child modules wrap and hide their implementation details, but the child modules can see the context in which they&amp;rsquo;re defined. To continue with the restaurant metaphor, think of the privacy rules as being like the back office of a restaurant: what goes on in there is private to restaurant customers, but office managers can see and do everything in the restaurant in which they operate.</source>
          <target state="translated">Rust中隐私的工作方式是默认情况下所有项目（函数，方法，结构，枚举，模块和常量）都是私有的。父模块中的项目不能使用子模块中的私有项目，但是子模块中的项目可以使用其祖先模块中的项目。原因是子模块包装和隐藏了它们的实现细节，但是子模块可以看到定义它们的上下文。要继续使用餐厅的隐喻，可以将隐私规则视为餐厅的后台办公室：餐厅客户对餐厅的隐私是私密的，但是办公室经理可以在他们经营的餐厅中看到并做所有事情。</target>
        </trans-unit>
        <trans-unit id="c954766baf952dffb19514bc82ccc04508ad4747" translate="yes" xml:space="preserve">
          <source>The way to define helper attributes is to put an &lt;code&gt;attributes&lt;/code&gt; key in the &lt;code&gt;proc_macro_derive&lt;/code&gt; macro with a comma separated list of identifiers that are the names of the helper attributes.</source>
          <target state="translated">定义帮助程序属性的方法是将 &lt;code&gt;attributes&lt;/code&gt; 键放在 &lt;code&gt;proc_macro_derive&lt;/code&gt; 宏中，并用逗号分隔的标识符列表作为帮助程序属性的名称。</target>
        </trans-unit>
        <trans-unit id="b4ad5969b00a7de4e50dcfbec4f420300a121d22" translate="yes" xml:space="preserve">
          <source>The way to demonstrate this behavior is by running the program with &lt;code&gt;&amp;gt;&lt;/code&gt; and the filename, &lt;em&gt;output.txt&lt;/em&gt;, that we want to redirect the standard output stream to. We won&amp;rsquo;t pass any arguments, which should cause an error:</source>
          <target state="translated">演示此行为的方法是使用 &lt;code&gt;&amp;gt;&lt;/code&gt; 和文件名&lt;em&gt;output.txt&lt;/em&gt;运行程序，我们要将标准输出流重定向到该文件名。我们不会传递任何参数，这会导致错误：</target>
        </trans-unit>
        <trans-unit id="4860fccc5b2b1b15ffbccd4a99af016a4e435d30" translate="yes" xml:space="preserve">
          <source>The wildcard pattern is always irrefutable.</source>
          <target state="translated">通配符模式总是无可辩驳的。</target>
        </trans-unit>
        <trans-unit id="6ed876d97357afb4218b62acc26e1fb7fcb7f367" translate="yes" xml:space="preserve">
          <source>The workspace has one &lt;em&gt;target&lt;/em&gt; directory at the top level for the compiled artifacts to be placed into; the &lt;code&gt;adder&lt;/code&gt; crate doesn&amp;rsquo;t have its own &lt;em&gt;target&lt;/em&gt; directory. Even if we were to run &lt;code&gt;cargo build&lt;/code&gt; from inside the &lt;em&gt;adder&lt;/em&gt; directory, the compiled artifacts would still end up in &lt;em&gt;add/target&lt;/em&gt; rather than &lt;em&gt;add/adder/target&lt;/em&gt;. Cargo structures the &lt;em&gt;target&lt;/em&gt; directory in a workspace like this because the crates in a workspace are meant to depend on each other. If each crate had its own &lt;em&gt;target&lt;/em&gt; directory, each crate would have to recompile each of the other crates in the workspace to have the artifacts in its own &lt;em&gt;target&lt;/em&gt; directory. By sharing one &lt;em&gt;target&lt;/em&gt; directory, the crates can avoid unnecessary rebuilding.</source>
          <target state="translated">工作空间在顶层有一个&lt;em&gt;目标&lt;/em&gt;目录，用于放置编译后的工件。在 &lt;code&gt;adder&lt;/code&gt; 箱没有自己的&lt;em&gt;目标&lt;/em&gt;目录。即使我们要在&lt;em&gt;adder&lt;/em&gt;目录中运行 &lt;code&gt;cargo build&lt;/code&gt; ，编译后的工件仍将以&lt;em&gt;add / target&lt;/em&gt;而不是&lt;em&gt;add / adder / target结束&lt;/em&gt;。 Cargo 像这样在工作区中构造&lt;em&gt;目标&lt;/em&gt;目录，因为工作区中的板条箱相互依赖。如果每个板条箱都有其自己的&lt;em&gt;目标&lt;/em&gt;目录，则每个板条箱都必须重新编译工作空间中的其他每个板条箱，以使工件具有自己的工件&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;目标&lt;/em&gt;目录。通过共享一个&lt;em&gt;目标&lt;/em&gt;目录，板条箱可以避免不必要的重建。</target>
        </trans-unit>
        <trans-unit id="94338f88d478ec6b62411179604be0f6a0e553b2" translate="yes" xml:space="preserve">
          <source>The workspace has one &lt;em&gt;target&lt;/em&gt; directory at the top level for the compiled artifacts to be placed into; the &lt;code&gt;adder&lt;/code&gt; package doesn&amp;rsquo;t have its own &lt;em&gt;target&lt;/em&gt; directory. Even if we were to run &lt;code&gt;cargo build&lt;/code&gt; from inside the &lt;em&gt;adder&lt;/em&gt; directory, the compiled artifacts would still end up in &lt;em&gt;add/target&lt;/em&gt; rather than &lt;em&gt;add/adder/target&lt;/em&gt;. Cargo structures the &lt;em&gt;target&lt;/em&gt; directory in a workspace like this because the crates in a workspace are meant to depend on each other. If each crate had its own &lt;em&gt;target&lt;/em&gt; directory, each crate would have to recompile each of the other crates in the workspace to have the artifacts in its own &lt;em&gt;target&lt;/em&gt; directory. By sharing one &lt;em&gt;target&lt;/em&gt; directory, the crates can avoid unnecessary rebuilding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77f8b60c8bbd1e207542248a0d2f457b8e7e406f" translate="yes" xml:space="preserve">
          <source>The worst case cost of &lt;code&gt;pop&lt;/code&gt; on a heap containing &lt;em&gt;n&lt;/em&gt; elements is &lt;em&gt;O&lt;/em&gt;(log(&lt;em&gt;n&lt;/em&gt;)).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99d51b0abe084f304807f0bb44acfa16e7f4af5a" translate="yes" xml:space="preserve">
          <source>The worst case cost of &lt;code&gt;pop&lt;/code&gt; on a heap containing &lt;em&gt;n&lt;/em&gt; elements is O(log n).</source>
          <target state="translated">在包含&lt;em&gt;n个&lt;/em&gt;元素的堆上 &lt;code&gt;pop&lt;/code&gt; 的最坏情况是O（log n）。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fc0b397ce3728851f33d0ec0d540c025798521e0" translate="yes" xml:space="preserve">
          <source>The worst case cost of a &lt;em&gt;single&lt;/em&gt; call to &lt;code&gt;push&lt;/code&gt; is &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;). The worst case occurs when capacity is exhausted and needs a resize. The resize cost has been amortized in the previous figures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="238b65c05553bd00df49cce92fea6a1b783b67b3" translate="yes" xml:space="preserve">
          <source>The worst case cost of a &lt;em&gt;single&lt;/em&gt; call to &lt;code&gt;push&lt;/code&gt; is O(n). The worst case occurs when capacity is exhausted and needs a resize. The resize cost has been amortized in the previous figures.</source>
          <target state="translated">&lt;em&gt;单次&lt;/em&gt; &lt;code&gt;push&lt;/code&gt; 请求的最坏情况成本为O（n）。最坏的情况发生在容量用尽并需要调整大小时。调整大小成本已在之前的数字中摊销。</target>
        </trans-unit>
        <trans-unit id="9abd2f24e6d1b46930e8a99311ffd002b596e31a" translate="yes" xml:space="preserve">
          <source>The writing portion of the &lt;a href=&quot;struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt; should be shut down.</source>
          <target state="translated">&lt;a href=&quot;struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; &lt;/a&gt;的写入部分应关闭。</target>
        </trans-unit>
        <trans-unit id="4a689baec3acd327f6907f5ce5547d1d13e010a8" translate="yes" xml:space="preserve">
          <source>Their definition should always match the ABI defined in &lt;code&gt;rustc::back::abi&lt;/code&gt;.</source>
          <target state="translated">它们的定义应始终与 &lt;code&gt;rustc::back::abi&lt;/code&gt; 定义的ABI相匹配。</target>
        </trans-unit>
        <trans-unit id="1e1df95ca1bc76e0d356b0c10d06f6035304f599" translate="yes" xml:space="preserve">
          <source>Their definition should always match the ABI defined in &lt;code&gt;rustc_middle::ty::layout&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="534bcf9b4ee06ae0b390b746db849c9e3d0f83df" translate="yes" xml:space="preserve">
          <source>Then create a new directory, &lt;em&gt;src/bin&lt;/em&gt;, and move the binary crate rooted in &lt;em&gt;src/main.rs&lt;/em&gt; into &lt;em&gt;src/bin/main.rs&lt;/em&gt;. Doing so will make the library crate the primary crate in the &lt;em&gt;hello&lt;/em&gt; directory; we can still run the binary in &lt;em&gt;src/bin/main.rs&lt;/em&gt; using &lt;code&gt;cargo run&lt;/code&gt;. After moving the &lt;em&gt;main.rs&lt;/em&gt; file, edit it to bring the library crate in and bring &lt;code&gt;ThreadPool&lt;/code&gt; into scope by adding the following code to the top of &lt;em&gt;src/bin/main.rs&lt;/em&gt;:</source>
          <target state="translated">然后创建一个新目录&lt;em&gt;src / bin&lt;/em&gt;，并将以&lt;em&gt;src / main.rs&lt;/em&gt;为根的二进制文件箱移动到&lt;em&gt;src / bin / main.rs中&lt;/em&gt;。这样做将使库箱成为&lt;em&gt;hello&lt;/em&gt;目录中的主箱；我们仍然可以使用 &lt;code&gt;cargo run&lt;/code&gt; 在&lt;em&gt;src / bin / main.rs中&lt;/em&gt;运行二进制文件。移动&lt;em&gt;main.rs&lt;/em&gt;文件后，对其进行编辑以将库文件箱放入其中，并通过在&lt;em&gt;src / bin / main.rs&lt;/em&gt;顶部添加以下代码来将 &lt;code&gt;ThreadPool&lt;/code&gt; 纳入范围：&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="848cf8d4f1542ccd5c9500b227f162479dfe2c8c" translate="yes" xml:space="preserve">
          <source>Then generate a new library crate named &lt;code&gt;add-one&lt;/code&gt;:</source>
          <target state="translated">然后生成一个名为 &lt;code&gt;add-one&lt;/code&gt; 的新库箱：</target>
        </trans-unit>
        <trans-unit id="02ec96ae1b226ff410efb69c0d4d60e58a7042ce" translate="yes" xml:space="preserve">
          <source>Then implementing the &lt;code&gt;OutlinePrint&lt;/code&gt; trait on &lt;code&gt;Point&lt;/code&gt; will compile successfully, and we can call &lt;code&gt;outline_print&lt;/code&gt; on a &lt;code&gt;Point&lt;/code&gt; instance to display it within an outline of asterisks.</source>
          <target state="translated">然后在 &lt;code&gt;Point&lt;/code&gt; 上实现 &lt;code&gt;OutlinePrint&lt;/code&gt; 特征将成功编译，我们可以在 &lt;code&gt;Point&lt;/code&gt; 实例上调用 &lt;code&gt;outline_print&lt;/code&gt; ，以在星号轮廓内显示它。</target>
        </trans-unit>
        <trans-unit id="3aac37973a618f0b45f35c262a8297327ce65a0e" translate="yes" xml:space="preserve">
          <source>Then install the language server support in your particular IDE; you&amp;rsquo;ll gain abilities such as autocompletion, jump to definition, and inline errors.</source>
          <target state="translated">然后在特定的IDE中安装语言服务器支持；您将获得自动补全，跳转到定义以及内联错误等功能。</target>
        </trans-unit>
        <trans-unit id="636019afbd1be275dc1f855f27602c31a7743704" translate="yes" xml:space="preserve">
          <source>Then run &lt;code&gt;cargo test&lt;/code&gt; again. The output now shows &lt;code&gt;exploration&lt;/code&gt; instead of &lt;code&gt;it_works&lt;/code&gt;:</source>
          <target state="translated">然后再次运行 &lt;code&gt;cargo test&lt;/code&gt; 。现在，输出显示 &lt;code&gt;exploration&lt;/code&gt; 而不是 &lt;code&gt;it_works&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7eae4a5123d629fb5914cfbce2d33e244889b442" translate="yes" xml:space="preserve">
          <source>Then the compiler applies the first rule, which specifies that each parameter gets its own lifetime. We&amp;rsquo;ll call it &lt;code&gt;'a&lt;/code&gt; as usual, so now the signature is this:</source>
          <target state="translated">然后，编译器将应用第一条规则，该规则指定每个参数都有其自己的生存期。我们将其称为 &lt;code&gt;'a&lt;/code&gt; &amp;rdquo;，因此现在的签名是：</target>
        </trans-unit>
        <trans-unit id="fe1bb69db1725d721fdb3af05034044cb61cb940" translate="yes" xml:space="preserve">
          <source>Then we add five new lines at the bottom that use the &lt;code&gt;Ordering&lt;/code&gt; type. The &lt;code&gt;cmp&lt;/code&gt; method compares two values and can be called on anything that can be compared. It takes a reference to whatever you want to compare with: here it&amp;rsquo;s comparing the &lt;code&gt;guess&lt;/code&gt; to the &lt;code&gt;secret_number&lt;/code&gt;. Then it returns a variant of the &lt;code&gt;Ordering&lt;/code&gt; enum we brought into scope with the &lt;code&gt;use&lt;/code&gt; statement. We use a &lt;a href=&quot;ch06-02-match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; expression to decide what to do next based on which variant of &lt;code&gt;Ordering&lt;/code&gt; was returned from the call to &lt;code&gt;cmp&lt;/code&gt; with the values in &lt;code&gt;guess&lt;/code&gt; and &lt;code&gt;secret_number&lt;/code&gt;.</source>
          <target state="translated">然后，我们在底部添加五行使用 &lt;code&gt;Ordering&lt;/code&gt; 类型的新行。该 &lt;code&gt;cmp&lt;/code&gt; 方法比较两个值，并且可以在任何可以比较被调用。它引用了您想与之进行比较的任何内容：在这里，它将 &lt;code&gt;guess&lt;/code&gt; 与 &lt;code&gt;secret_number&lt;/code&gt; 相比较。然后它返回我们在 &lt;code&gt;use&lt;/code&gt; 语句中纳入范围的 &lt;code&gt;Ordering&lt;/code&gt; 枚举的变体。我们使用&lt;a href=&quot;ch06-02-match&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt;表达式根据对 &lt;code&gt;cmp&lt;/code&gt; 的调用返回的 &lt;code&gt;Ordering&lt;/code&gt; 的哪个变体（带有 &lt;code&gt;guess&lt;/code&gt; 和 &lt;code&gt;secret_number&lt;/code&gt; 中的值）来决定下一步要做什么。</target>
        </trans-unit>
        <trans-unit id="42504942265ee7c7c73ee70d30a7653d906cc136" translate="yes" xml:space="preserve">
          <source>Then we create a &lt;em&gt;src/front_of_house&lt;/em&gt; directory and a file &lt;em&gt;src/front_of_house/hosting.rs&lt;/em&gt; to contain the definitions made in the &lt;code&gt;hosting&lt;/code&gt; module:</source>
          <target state="translated">然后，我们创建一个&lt;em&gt;src / front_of_house&lt;/em&gt;目录和一个文件&lt;em&gt;src / front_of_house / hosting.rs，&lt;/em&gt;以包含在 &lt;code&gt;hosting&lt;/code&gt; 模块中进行的定义：</target>
        </trans-unit>
        <trans-unit id="8c054131a62b68de933e0bf587b858ee6793392b" translate="yes" xml:space="preserve">
          <source>Then we create a new &lt;code&gt;String&lt;/code&gt; in variable &lt;code&gt;s&lt;/code&gt; and call the &lt;code&gt;read_to_string&lt;/code&gt; method on the file handle in &lt;code&gt;f&lt;/code&gt; to read the contents of the file into &lt;code&gt;s&lt;/code&gt;. The &lt;code&gt;read_to_string&lt;/code&gt; method also returns a &lt;code&gt;Result&lt;/code&gt; because it might fail, even though &lt;code&gt;File::open&lt;/code&gt; succeeded. So we need another &lt;code&gt;match&lt;/code&gt; to handle that &lt;code&gt;Result&lt;/code&gt;: if &lt;code&gt;read_to_string&lt;/code&gt; succeeds, then our function has succeeded, and we return the username from the file that&amp;rsquo;s now in &lt;code&gt;s&lt;/code&gt; wrapped in an &lt;code&gt;Ok&lt;/code&gt;. If &lt;code&gt;read_to_string&lt;/code&gt; fails, we return the error value in the same way that we returned the error value in the &lt;code&gt;match&lt;/code&gt; that handled the return value of &lt;code&gt;File::open&lt;/code&gt;. However, we don&amp;rsquo;t need to explicitly say &lt;code&gt;return&lt;/code&gt;, because this is the last expression in the function.</source>
          <target state="translated">然后，在变量 &lt;code&gt;s&lt;/code&gt; 中创建一个新的 &lt;code&gt;String&lt;/code&gt; ，并在 &lt;code&gt;f&lt;/code&gt; 中的文件句柄上调用 &lt;code&gt;read_to_string&lt;/code&gt; 方法，以将文件内容读入 &lt;code&gt;s&lt;/code&gt; 。该 &lt;code&gt;read_to_string&lt;/code&gt; 方法也返回一个 &lt;code&gt;Result&lt;/code&gt; ，因为它可能会失败，即使 &lt;code&gt;File::open&lt;/code&gt; 成功。因此，我们需要另一 &lt;code&gt;match&lt;/code&gt; 来处理 &lt;code&gt;Result&lt;/code&gt; ：如果 &lt;code&gt;read_to_string&lt;/code&gt; 成功，那么我们的功能已经成功，并且我们从现在在返回文件中的用户名 &lt;code&gt;s&lt;/code&gt; 包裹在一个 &lt;code&gt;Ok&lt;/code&gt; 。如果 &lt;code&gt;read_to_string&lt;/code&gt; 失败，我们以 &lt;code&gt;match&lt;/code&gt; 处理 &lt;code&gt;File::open&lt;/code&gt; 的返回值的匹配中返回错误值的方式相同的方式返回错误值。但是，我们不需要明确地说 &lt;code&gt;return&lt;/code&gt; ，因为这是函数中的最后一个表达式。</target>
        </trans-unit>
        <trans-unit id="deae9012508053fe94f96907583eae7e4c8a687f" translate="yes" xml:space="preserve">
          <source>Then we implement an associated function named &lt;code&gt;new&lt;/code&gt; on &lt;code&gt;Guess&lt;/code&gt; that creates instances of &lt;code&gt;Guess&lt;/code&gt; values. The &lt;code&gt;new&lt;/code&gt; function is defined to have one parameter named &lt;code&gt;value&lt;/code&gt; of type &lt;code&gt;i32&lt;/code&gt; and to return a &lt;code&gt;Guess&lt;/code&gt;. The code in the body of the &lt;code&gt;new&lt;/code&gt; function tests &lt;code&gt;value&lt;/code&gt; to make sure it&amp;rsquo;s between 1 and 100. If &lt;code&gt;value&lt;/code&gt; doesn&amp;rsquo;t pass this test, we make a &lt;code&gt;panic!&lt;/code&gt; call, which will alert the programmer who is writing the calling code that they have a bug they need to fix, because creating a &lt;code&gt;Guess&lt;/code&gt; with a &lt;code&gt;value&lt;/code&gt; outside this range would violate the contract that &lt;code&gt;Guess::new&lt;/code&gt; is relying on. The conditions in which &lt;code&gt;Guess::new&lt;/code&gt; might panic should be discussed in its public-facing API documentation; we&amp;rsquo;ll cover documentation conventions indicating the possibility of a &lt;code&gt;panic!&lt;/code&gt; in the API documentation that you create in Chapter 14. If &lt;code&gt;value&lt;/code&gt; does pass the test, we create a new &lt;code&gt;Guess&lt;/code&gt; with its &lt;code&gt;value&lt;/code&gt; field set to the &lt;code&gt;value&lt;/code&gt; parameter and return the &lt;code&gt;Guess&lt;/code&gt;.</source>
          <target state="translated">然后，我们在 &lt;code&gt;Guess&lt;/code&gt; 上实现一个名为 &lt;code&gt;new&lt;/code&gt; 的关联函数，该函数创建 &lt;code&gt;Guess&lt;/code&gt; 值实例。该 &lt;code&gt;new&lt;/code&gt; 功能被定义为有一个名为参数 &lt;code&gt;value&lt;/code&gt; 类型的 &lt;code&gt;i32&lt;/code&gt; ，并返回一个 &lt;code&gt;Guess&lt;/code&gt; 。 &lt;code&gt;new&lt;/code&gt; 函数主体中的代码将测试 &lt;code&gt;value&lt;/code&gt; 以确保其值在1到100之间。如果 &lt;code&gt;value&lt;/code&gt; 未通过此测试，我们将感到 &lt;code&gt;panic!&lt;/code&gt; 调用，这将警告正在编写调用代码的程序员他们需要修复的错误，因为创建带有 &lt;code&gt;value&lt;/code&gt; 的 &lt;code&gt;Guess&lt;/code&gt; 超出此范围将违反 &lt;code&gt;Guess::new&lt;/code&gt; 所依赖的合同。在何种条件下 &lt;code&gt;Guess::new&lt;/code&gt; 可能出现紧急情况应在其面向公众的API文档中讨论; 我们将介绍表明可能发生 &lt;code&gt;panic!&lt;/code&gt; 文档约定！在您在第14章中创建的API文档中。如果 &lt;code&gt;value&lt;/code&gt; 通过测试，我们将创建一个新的 &lt;code&gt;Guess&lt;/code&gt; ，并将其 &lt;code&gt;value&lt;/code&gt; 字段设置为 &lt;code&gt;value&lt;/code&gt; 参数，并返回 &lt;code&gt;Guess&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="06b6b70a87228a4df8ed0e498c6c809f243dabd9" translate="yes" xml:space="preserve">
          <source>Then we return two mutable slices in a tuple: one from the start of the original slice to the &lt;code&gt;mid&lt;/code&gt; index and another from &lt;code&gt;mid&lt;/code&gt; to the end of the slice.</source>
          <target state="translated">然后，我们在一个元组中返回两个可变切片：一个从原始切片的开始到 &lt;code&gt;mid&lt;/code&gt; 索引，另一个从切片的 &lt;code&gt;mid&lt;/code&gt; 到结尾。</target>
        </trans-unit>
        <trans-unit id="d29498b87e97b7beddcde1cb5378fcb2cbabe3a8" translate="yes" xml:space="preserve">
          <source>Then you must define an implementation for &lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt;&lt;code&gt;cmp&lt;/code&gt;&lt;/a&gt;. You may find it useful to use &lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt;&lt;code&gt;cmp&lt;/code&gt;&lt;/a&gt; on your type's fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="884190657324310c04e2504f5fc0e76845d895ae" translate="yes" xml:space="preserve">
          <source>Then you must define an implementation for &lt;code&gt;cmp()&lt;/code&gt;. You may find it useful to use &lt;code&gt;cmp()&lt;/code&gt; on your type's fields.</source>
          <target state="translated">然后，您必须为 &lt;code&gt;cmp()&lt;/code&gt; 定义一个实现。您可能会发现在类型的字段上使用 &lt;code&gt;cmp()&lt;/code&gt; 很有用。</target>
        </trans-unit>
        <trans-unit id="0d177ce772cf21906084a9438690b47406434422" translate="yes" xml:space="preserve">
          <source>Then you&amp;rsquo;ll learn how to use &lt;em&gt;traits&lt;/em&gt; to define behavior in a generic way. You can combine traits with generic types to constrain a generic type to only those types that have a particular behavior, as opposed to just any type.</source>
          <target state="translated">然后，您将学习如何使用&lt;em&gt;特征&lt;/em&gt;以一般方式定义行为。您可以将特征与泛型类型结合使用，以将泛型类型限制为仅具有特定行为的那些类型，而不是任何类型。</target>
        </trans-unit>
        <trans-unit id="ddeec83a6e1ebd77d0b40c2a12564ec960334a02" translate="yes" xml:space="preserve">
          <source>Then, for each candidate type &lt;code&gt;T&lt;/code&gt;, search for a &lt;a href=&quot;../visibility-and-privacy&quot;&gt;visible&lt;/a&gt; method with a receiver of that type in the following places:</source>
          <target state="translated">然后，对于每个候选类型 &lt;code&gt;T&lt;/code&gt; ，在以下位置使用该类型的接收器搜索&lt;a href=&quot;../visibility-and-privacy&quot;&gt;可见&lt;/a&gt;方法：</target>
        </trans-unit>
        <trans-unit id="c7f32ff9ae959e326529e5b742ae1c333e7b2254" translate="yes" xml:space="preserve">
          <source>Then, in your new &lt;em&gt;variables&lt;/em&gt; directory, open &lt;em&gt;src/main.rs&lt;/em&gt; and replace its code with the following code that won&amp;rsquo;t compile just yet:</source>
          <target state="translated">然后，在新的&lt;em&gt;变量&lt;/em&gt;目录中，打开&lt;em&gt;src / main.rs&lt;/em&gt;并将其代码替换为尚未编译的以下代码：</target>
        </trans-unit>
        <trans-unit id="0c8f840e153942ef31581018e9e810864accdec7" translate="yes" xml:space="preserve">
          <source>Then, to bring &lt;code&gt;rand&lt;/code&gt; definitions into the scope of our package, we added a &lt;code&gt;use&lt;/code&gt; line starting with the name of the crate, &lt;code&gt;rand&lt;/code&gt;, and listed the items we wanted to bring into scope. Recall that in the &lt;a href=&quot;ch02-00-guessing-game-tutorial#generating-a-random-number&quot;&gt;&amp;ldquo;Generating a Random Number&amp;rdquo;&lt;/a&gt; section in Chapter 2, we brought the &lt;code&gt;Rng&lt;/code&gt; trait into scope and called the &lt;code&gt;rand::thread_rng&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbbc8078ba28a9ecb4224d46afd42558773fa640" translate="yes" xml:space="preserve">
          <source>Then, to bring &lt;code&gt;rand&lt;/code&gt; definitions into the scope of our package, we added a &lt;code&gt;use&lt;/code&gt; line starting with the name of the package, &lt;code&gt;rand&lt;/code&gt;, and listed the items we wanted to bring into scope. Recall that in the &lt;a href=&quot;ch02-00-guessing-game-tutorial#generating-a-random-number&quot;&gt;&amp;ldquo;Generating a Random Number&amp;rdquo;&lt;/a&gt; section in Chapter 2, we brought the &lt;code&gt;Rng&lt;/code&gt; trait into scope and called the &lt;code&gt;rand::thread_rng&lt;/code&gt; function:</source>
          <target state="translated">然后，为了将 &lt;code&gt;rand&lt;/code&gt; 定义带入我们的包范围，我们添加了一个 &lt;code&gt;use&lt;/code&gt; 行，该行以包的名称 &lt;code&gt;rand&lt;/code&gt; 开头，并列出了我们想要纳入范围的项目。回想一下，在第2章的&lt;a href=&quot;ch02-00-guessing-game-tutorial#generating-a-random-number&quot;&gt;&amp;ldquo;生成随机数&amp;rdquo;&lt;/a&gt;部分中，我们将 &lt;code&gt;Rng&lt;/code&gt; 特性引入了范围，并调用了 &lt;code&gt;rand::thread_rng&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="ea0671790854fadbc007a7d3ab3c99a7a0c53f74" translate="yes" xml:space="preserve">
          <source>Theoretically, this code should compile. Unfortunately, the Rust compiler isn&amp;rsquo;t perfect yet, and we get this error:</source>
          <target state="translated">从理论上讲，此代码应编译。不幸的是，Rust编译器还不是完美的，我们得到这个错误：</target>
        </trans-unit>
        <trans-unit id="7bb0fb711ce84d52df9718e0b2a2ec2dabc6a07f" translate="yes" xml:space="preserve">
          <source>There are a couple of solutions for this.</source>
          <target state="translated">对此,有几种解决办法。</target>
        </trans-unit>
        <trans-unit id="530488aa6f064fc1ecb7dc7a5a0bf4b2dc63964c" translate="yes" xml:space="preserve">
          <source>There are a few things that &lt;code&gt;transmute&lt;/code&gt; is really useful for.</source>
          <target state="translated">有几件事情， &lt;code&gt;transmute&lt;/code&gt; 为真正有用的。</target>
        </trans-unit>
        <trans-unit id="e38257a0874550d292627aecb2605763613ccaf1" translate="yes" xml:space="preserve">
          <source>There are a handful of shortcuts provided to make writing constructors more convenient, most common of which is the Field Init shorthand. When there is a variable and a field of the same name, the assignment can be simplified from &lt;code&gt;field: field&lt;/code&gt; into simply &lt;code&gt;field&lt;/code&gt;. The following example of a hypothetical constructor demonstrates this:</source>
          <target state="translated">提供了一些快捷方式，使编写构造函数更加方便，其中最常见的是Field Init的简写形式。当存在一个变量和一个同名字段时，可以将分配从 &lt;code&gt;field: field&lt;/code&gt; 简化为 &lt;code&gt;field&lt;/code&gt; 。假设的构造函数的以下示例说明了这一点：</target>
        </trans-unit>
        <trans-unit id="63a966968ec2346aede6a0d18395aa406c237072" translate="yes" xml:space="preserve">
          <source>There are a number of &lt;a href=&quot;#functions-1&quot;&gt;functions&lt;/a&gt; that offer access to various features. For example, we can use three of these functions to copy everything from standard input to standard output:</source>
          <target state="translated">有许多&lt;a href=&quot;#functions-1&quot;&gt;功能&lt;/a&gt;可以访问各种功能。例如，我们可以使用以下三个函数来复制从标准输入到标准输出的所有内容：</target>
        </trans-unit>
        <trans-unit id="1f79d0ffb253cf5d15cccef1c760f3edf4c3cd7b" translate="yes" xml:space="preserve">
          <source>There are a number of &lt;code&gt;debug_*&lt;/code&gt; methods on &lt;a href=&quot;struct.formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; to help you with manual implementations, such as &lt;a href=&quot;struct.formatter#method.debug_struct&quot;&gt;&lt;code&gt;debug_struct&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt;上有许多 &lt;code&gt;debug_*&lt;/code&gt; 方法可帮助您实现手动实现，例如&lt;a href=&quot;struct.formatter#method.debug_struct&quot;&gt; &lt;code&gt;debug_struct&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8e1d6f0ae7b1514d15119ee9f085506bcbaba7ce" translate="yes" xml:space="preserve">
          <source>There are a number of helper methods on the &lt;a href=&quot;struct.formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; struct to help you with manual implementations, such as &lt;a href=&quot;struct.formatter#method.debug_struct&quot;&gt;&lt;code&gt;debug_struct&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="087920b8740a66ec282180bff3885f708e5bb842" translate="yes" xml:space="preserve">
          <source>There are a number of related macros in the &lt;a href=&quot;../macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt; family. The ones that are currently implemented are:</source>
          <target state="translated">&lt;a href=&quot;../macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt;中有许多相关的宏！家庭。当前实现的是：</target>
        </trans-unit>
        <trans-unit id="28043d56de08a63f7e30e165bfcf6d512b961039" translate="yes" xml:space="preserve">
          <source>There are also some platform-specific ABI strings:</source>
          <target state="translated">还有一些平台特有的ABI字符串。</target>
        </trans-unit>
        <trans-unit id="4e3263bd4c02d9329fee29d313cf8ea903653894" translate="yes" xml:space="preserve">
          <source>There are both a positive and negative trait implementation for the same type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dfc0ac14db9531a0dcf3d9f3c7feabed396e9c2" translate="yes" xml:space="preserve">
          <source>There are conflicting trait implementations for the same type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb600a231699778e7c442e8d1b0c5af1c6ce3e98" translate="yes" xml:space="preserve">
          <source>There are conflicting trait implementations for the same type. Example of erroneous code:</source>
          <target state="translated">同一类型的性状实现有冲突。错误代码的例子。</target>
        </trans-unit>
        <trans-unit id="c7d32d1dc6c93776049af2c0d8da18ad1a5c107b" translate="yes" xml:space="preserve">
          <source>There are insufficient permissions to access the current directory.</source>
          <target state="translated">当前目录的访问权限不足。</target>
        </trans-unit>
        <trans-unit id="320a725df7a67ccef8f0da8b29889ac40ad1812c" translate="yes" xml:space="preserve">
          <source>There are limitations when matching on non-exhaustive types outside of the defining crate:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c57d9d7a8463095f936949e3bd422fd7ce763db3" translate="yes" xml:space="preserve">
          <source>There are multiple trade-offs to consider in addition to the prevention of bugs. For example, in cases where you&amp;rsquo;re using large data structures, mutating an instance in place may be faster than copying and returning newly allocated instances. With smaller data structures, creating new instances and writing in a more functional programming style may be easier to think through, so lower performance might be a worthwhile penalty for gaining that clarity.</source>
          <target state="translated">除了防止错误外，还需要考虑多个折衷方案。例如，在使用大型数据结构的情况下，对实例进行原地更改可能比复制并返回新分配的实例要快。对于较小的数据结构，创建新实例并以更具功能性的编程风格进行编写可能更容易考虑，因此，降低性能可能是获得这种清晰度的一个值得付出的代价。</target>
        </trans-unit>
        <trans-unit id="d53022046c1585c76ce2c3d1de0757bc5d58a5d7" translate="yes" xml:space="preserve">
          <source>There are multiple ways to create a new &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; from a string literal:</source>
          <target state="translated">有多种方法可以创建一个新的&lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;从一个字符串：</target>
        </trans-unit>
        <trans-unit id="b89e39f486cb11ae236a0c1ba092d84b1be61d5a" translate="yes" xml:space="preserve">
          <source>There are multiple ways we could change how our web server works to avoid having more requests back up behind a slow request; the one we&amp;rsquo;ll implement is a thread pool.</source>
          <target state="translated">我们可以通过多种方式来更改Web服务器的工作方式，以避免在缓慢的请求后再备份更多的请求。我们将实现的是一个线程池。</target>
        </trans-unit>
        <trans-unit id="cbbb8fb2683dd85eb0ca22283c9bb44fdd37598e" translate="yes" xml:space="preserve">
          <source>There are no function calls, macros, or even &lt;code&gt;let&lt;/code&gt; statements in the &lt;code&gt;five&lt;/code&gt; function&amp;mdash;just the number &lt;code&gt;5&lt;/code&gt; by itself. That&amp;rsquo;s a perfectly valid function in Rust. Note that the function&amp;rsquo;s return type is specified too, as &lt;code&gt;-&amp;gt; i32&lt;/code&gt;. Try running this code; the output should look like this:</source>
          <target state="translated">这 &lt;code&gt;five&lt;/code&gt; 函数中没有函数调用，宏，甚至没有 &lt;code&gt;let&lt;/code&gt; 语句-仅是数字 &lt;code&gt;5&lt;/code&gt; 。在Rust中，这是一个非常有效的函数。注意，函数的返回类型也被指定为 &lt;code&gt;-&amp;gt; i32&lt;/code&gt; 。尝试运行此代码；输出应如下所示：</target>
        </trans-unit>
        <trans-unit id="e3048305fc74fc67f0b28e1af09fa647633b200c" translate="yes" xml:space="preserve">
          <source>There are no generic type parameters.</source>
          <target state="translated">没有通用类型参数。</target>
        </trans-unit>
        <trans-unit id="6dc334d98456ba931a1cb0e3e3cebe2b287fda18" translate="yes" xml:space="preserve">
          <source>There are no guarantees of data layout made by this representation.</source>
          <target state="translated">这种表示方法对数据布局没有任何保证。</target>
        </trans-unit>
        <trans-unit id="73292d3af30172448139b6d5386689eb5562d30e" translate="yes" xml:space="preserve">
          <source>There are no guarantees whatsoever that offsetting the pointer will not overflow or go beyond the allocation that the pointer points into. It is up to the caller to ensure that the returned offset is correct in all terms other than alignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a86100f636fbb472fb5b1863356f0448a9ae85a5" translate="yes" xml:space="preserve">
          <source>There are no guarantees whatsover that offsetting the pointer will not overflow or go beyond the allocation that the pointer points into. It is up to the caller to ensure that the returned offset is correct in all terms other than alignment.</source>
          <target state="translated">我们不能保证偏移指针不会溢出或超出指针指向的分配。调用者要保证返回的偏移量除了对齐以外的所有方面都是正确的。</target>
        </trans-unit>
        <trans-unit id="19e4b768de5872c5fc351b9acc570966e33874d6" translate="yes" xml:space="preserve">
          <source>There are several functions and structs in this module that have a counterpart ending in &lt;code&gt;os&lt;/code&gt;. Those ending in &lt;code&gt;os&lt;/code&gt; will return an &lt;a href=&quot;../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; and those without will be returning a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此模块中有几个函数和结构，其对应的结尾是 &lt;code&gt;os&lt;/code&gt; 。那些以 &lt;code&gt;os&lt;/code&gt; 结尾的将返回&lt;a href=&quot;../ffi/struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt;，而没有os的将返回&lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dc0876b472387aa80fcef964fda60c94ca27eb85" translate="yes" xml:space="preserve">
          <source>There are several functions and structs in this module that have a counterpart ending in &lt;code&gt;os&lt;/code&gt;. Those ending in &lt;code&gt;os&lt;/code&gt; will return an &lt;a href=&quot;../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; and those without will return a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="171ee597fab4c6d0bdea510dd3f56d6a9c12c0b6" translate="yes" xml:space="preserve">
          <source>There are several implementations of common traits for slices. Some examples include:</source>
          <target state="translated">片子的常见特征有几种实现方式。一些例子包括:</target>
        </trans-unit>
        <trans-unit id="0f5d6b4dc4e0f0d18f10b896c43b04863d873b17" translate="yes" xml:space="preserve">
          <source>There are several kinds of items:</source>
          <target state="translated">有几种项目。</target>
        </trans-unit>
        <trans-unit id="5ab16cf7d574dfc1dbe1b281f7a85326a916ba94" translate="yes" xml:space="preserve">
          <source>There are several structs that are useful for slices, such as &lt;a href=&quot;struct.iter&quot;&gt;&lt;code&gt;Iter&lt;/code&gt;&lt;/a&gt;, which represents iteration over a slice.</source>
          <target state="translated">有几种对切片有用的结构，例如&lt;a href=&quot;struct.iter&quot;&gt; &lt;code&gt;Iter&lt;/code&gt; &lt;/a&gt;，它表示切片上的迭代。</target>
        </trans-unit>
        <trans-unit id="567ae72d32f4d2be3989eaf8a9904e62f889b537" translate="yes" xml:space="preserve">
          <source>There are six &lt;code&gt;char&lt;/code&gt; values here, but the fourth and sixth are not letters: they&amp;rsquo;re diacritics that don&amp;rsquo;t make sense on their own. Finally, if we look at them as grapheme clusters, we&amp;rsquo;d get what a person would call the four letters that make up the Hindi word:</source>
          <target state="translated">这里有六个 &lt;code&gt;char&lt;/code&gt; 值，但是第四个和第六个不是字母：它们是变音符号，它们自己没有意义。最后，如果我们将它们视为字素簇，我们将得到一个人所说的构成印地语单词的四个字母：</target>
        </trans-unit>
        <trans-unit id="6ce75e9d71dbebf75ae807b3a16056d1528fd37b" translate="yes" xml:space="preserve">
          <source>There are some known bugs that trigger this message.</source>
          <target state="translated">有一些已知的错误会触发此消息。</target>
        </trans-unit>
        <trans-unit id="926439ef5401fe133e30f193394b46730a6ce040" translate="yes" xml:space="preserve">
          <source>There are some strange edge cases with &lt;code&gt;macro_rules!&lt;/code&gt;. In the future, Rust will have a second kind of declarative macro that will work in a similar fashion but fix some of these edge cases. After that update, &lt;code&gt;macro_rules!&lt;/code&gt; will be effectively deprecated. With this in mind, as well as the fact that most Rust programmers will &lt;em&gt;use&lt;/em&gt; macros more than &lt;em&gt;write&lt;/em&gt; macros, we won&amp;rsquo;t discuss &lt;code&gt;macro_rules!&lt;/code&gt; any further. To learn more about how to write macros, consult the online documentation or other resources, such as &lt;a href=&quot;https://danielkeep.github.io/tlborm/book/index.html&quot;&gt;&amp;ldquo;The Little Book of Rust Macros&amp;rdquo;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;macro_rules!&lt;/code&gt; 有一些奇怪的情况！。将来，Rust将具有第二种声明性宏，该宏将以类似的方式工作，但会修复其中一些极端情况。更新之后，请执行 &lt;code&gt;macro_rules!&lt;/code&gt; 将被弃用。考虑到这一点，以及大多数Rust程序员&lt;em&gt;使用&lt;/em&gt;宏而不是&lt;em&gt;编写&lt;/em&gt;宏的事实，我们不会讨论 &lt;code&gt;macro_rules!&lt;/code&gt; 再进一步。要了解有关如何编写宏的更多信息，请查阅在线文档或其他资源，例如&lt;a href=&quot;https://danielkeep.github.io/tlborm/book/index.html&quot;&gt;&amp;ldquo;锈宏小书&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="720348f040959c3669acec057ca2d47ad7fb3d69" translate="yes" xml:space="preserve">
          <source>There are three ABI strings which are cross-platform, and which all compilers are guaranteed to support:</source>
          <target state="translated">有三个ABI字符串是跨平台的,保证所有编译器都支持。</target>
        </trans-unit>
        <trans-unit id="0142bb3f41cab04708310e3fe823a323c32ee0b3" translate="yes" xml:space="preserve">
          <source>There are three common methods which can create iterators from a collection:</source>
          <target state="translated">有三种常见的方法可以从一个集合中创建迭代器。</target>
        </trans-unit>
        <trans-unit id="987579e087a6ff5bbf6e70931c97c8842a5d0e0c" translate="yes" xml:space="preserve">
          <source>There are three possible ways to specify the desired &lt;code&gt;precision&lt;/code&gt;:</source>
          <target state="translated">有三种方法可以指定所需的 &lt;code&gt;precision&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3a65e426e444ff8c29bebad4488c8514ade91574" translate="yes" xml:space="preserve">
          <source>There are three ways to use the inline attribute:</source>
          <target state="translated">内联属性有三种使用方法。</target>
        </trans-unit>
        <trans-unit id="481486972e8a90ddff463b54cf1c4f208b0477e6" translate="yes" xml:space="preserve">
          <source>There are two input lifetimes, so Rust applies the first lifetime elision rule and gives both &lt;code&gt;&amp;amp;self&lt;/code&gt; and &lt;code&gt;announcement&lt;/code&gt; their own lifetimes. Then, because one of the parameters is &lt;code&gt;&amp;amp;self&lt;/code&gt;, the return type gets the lifetime of &lt;code&gt;&amp;amp;self&lt;/code&gt;, and all lifetimes have been accounted for.</source>
          <target state="translated">输入生命周期有两个，因此Rust会应用第一个生命周期省略规则，并给 &lt;code&gt;&amp;amp;self&lt;/code&gt; 和 &lt;code&gt;announcement&lt;/code&gt; 它们自己的生命周期。然后，由于参数之一是 &lt;code&gt;&amp;amp;self&lt;/code&gt; ，返回类型将获得 &lt;code&gt;&amp;amp;self&lt;/code&gt; 的生存期，并且所有生存期均已考虑在内。</target>
        </trans-unit>
        <trans-unit id="ffdf24d7c3a95e9cacfa7c11d178ec9960ec72fd" translate="yes" xml:space="preserve">
          <source>There are two issues with the above example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1575bd4949a087cd0961e57e825f5b7d2464821" translate="yes" xml:space="preserve">
          <source>There are two main ways to read this document.</source>
          <target state="translated">阅读本文件主要有两种方式。</target>
        </trans-unit>
        <trans-unit id="86663982f114c71c4b638d9b0fa35d92d8fc55c4" translate="yes" xml:space="preserve">
          <source>There are two options that would work instead. The first would be to change the line &lt;code&gt;example_func(&amp;amp;example_string);&lt;/code&gt; to &lt;code&gt;example_func(example_string.as_str());&lt;/code&gt;, using the method &lt;a href=&quot;struct.string#method.as_str&quot;&gt;&lt;code&gt;as_str()&lt;/code&gt;&lt;/a&gt; to explicitly extract the string slice containing the string. The second way changes &lt;code&gt;example_func(&amp;amp;example_string);&lt;/code&gt; to &lt;code&gt;example_func(&amp;amp;*example_string);&lt;/code&gt;. In this case we are dereferencing a &lt;code&gt;String&lt;/code&gt; to a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, then referencing the &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; back to &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;. The second way is more idiomatic, however both work to do the conversion explicitly rather than relying on the implicit conversion.</source>
          <target state="translated">有两种选择可以代替。第一种是更改 &lt;code&gt;example_func(&amp;amp;example_string);&lt;/code&gt; 行。到 &lt;code&gt;example_func(example_string.as_str());&lt;/code&gt; ，使用&lt;a href=&quot;struct.string#method.as_str&quot;&gt; &lt;code&gt;as_str()&lt;/code&gt; &lt;/a&gt;方法显式提取包含字符串的字符串片段。第二种方式更改 &lt;code&gt;example_func(&amp;amp;example_string);&lt;/code&gt; 到 &lt;code&gt;example_func(&amp;amp;*example_string);&lt;/code&gt; 。在这种情况下，我们将 &lt;code&gt;String&lt;/code&gt; 引用到&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;，然后将&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;引用回到&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;。第二种方法更惯用，但是两种方法都可以显式地进行转换，而不是依赖隐式转换。</target>
        </trans-unit>
        <trans-unit id="022a56e5687a1a83c185eae56c2be99a7be6379c" translate="yes" xml:space="preserve">
          <source>There are two options to work around this issue. The first is simply to rename one of the types. Alternatively, one can specify the intended type using the following syntax:</source>
          <target state="translated">有两种方法可以解决这个问题。第一个是简单地重命名其中一个类型。或者,可以使用下面的语法来指定想要的类型。</target>
        </trans-unit>
        <trans-unit id="7601f9a3aa302729abcf51730ab0dacad11e1f7d" translate="yes" xml:space="preserve">
          <source>There are two possible solutions:</source>
          <target state="translated">有两种可能的解决办法。</target>
        </trans-unit>
        <trans-unit id="3f08d38f311f1d8aebf1cc8c4c04305ba58884d5" translate="yes" xml:space="preserve">
          <source>There are two syntactic forms for creating an array:</source>
          <target state="translated">创建数组有两种语法形式。</target>
        </trans-unit>
        <trans-unit id="63a18bac877b16a7425895e1b31ade8a29a01453" translate="yes" xml:space="preserve">
          <source>There are two types of &lt;code&gt;static&lt;/code&gt; items: those declared in association with the &lt;a href=&quot;keyword.mut&quot;&gt;&lt;code&gt;mut&lt;/code&gt;&lt;/a&gt; keyword and those without.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86a631e5c1cd817983c93f98903db4ea59d68db2" translate="yes" xml:space="preserve">
          <source>There are two types of implementations:</source>
          <target state="translated">有两种类型的实施方式。</target>
        </trans-unit>
        <trans-unit id="fa155718008a683c96cef5cc6a71a54ea03f305c" translate="yes" xml:space="preserve">
          <source>There are two ways to define new macros:</source>
          <target state="translated">有两种方法可以定义新的宏。</target>
        </trans-unit>
        <trans-unit id="9880ebdf9a583de2d652297bd89e0b5ff4d36ffb" translate="yes" xml:space="preserve">
          <source>There are two ways to implement &lt;code&gt;Copy&lt;/code&gt; on your type. The simplest is to use &lt;code&gt;derive&lt;/code&gt;:</source>
          <target state="translated">有两种方法可以在您的类型上实现 &lt;code&gt;Copy&lt;/code&gt; 。最简单的方法是使用 &lt;code&gt;derive&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b2a9fbbbcf33cff3a0df902072d56db76dfeaf3c" translate="yes" xml:space="preserve">
          <source>There are two ways to solve this error. The first is to make the public type signature only public to a module that also has access to the private type. This is done by using pub(crate) or pub(in crate::my_mod::etc) Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc647999e3aa70d53b9f18def550d41889259047" translate="yes" xml:space="preserve">
          <source>There are various restrictions on transmuting between types in Rust; for example types being transmuted must have the same size. To apply all these restrictions, the compiler must know the exact types that may be transmuted. When type parameters are involved, this cannot always be done.</source>
          <target state="translated">在 Rust 中,类型之间的转换有各种限制,例如被转换的类型必须具有相同的大小。为了应用所有这些限制,编译器必须知道可能被转换的确切类型。当涉及到类型参数时,就不能总是这样做。</target>
        </trans-unit>
        <trans-unit id="0019607d06d61b11d32e87172ee0ea679ebbb977" translate="yes" xml:space="preserve">
          <source>There are various rules:</source>
          <target state="translated">有各种规则。</target>
        </trans-unit>
        <trans-unit id="0d6ed4037ecbcc5953e35640da903ed6a8a40981" translate="yes" xml:space="preserve">
          <source>There can only be one owner at a time.</source>
          <target state="translated">一次只能有一个主人。</target>
        </trans-unit>
        <trans-unit id="f4471e590e73989497aca327361dde4b0c93c59c" translate="yes" xml:space="preserve">
          <source>There is a difference between what the &lt;code&gt;match&lt;/code&gt; expression from Listing 9-6 and the &lt;code&gt;?&lt;/code&gt; operator do: error values that have the &lt;code&gt;?&lt;/code&gt; operator called on them go through the &lt;code&gt;from&lt;/code&gt; function, defined in the &lt;code&gt;From&lt;/code&gt; trait in the standard library, which is used to convert errors from one type into another. When the &lt;code&gt;?&lt;/code&gt; operator calls the &lt;code&gt;from&lt;/code&gt; function, the error type received is converted into the error type defined in the return type of the current function. This is useful when a function returns one error type to represent all the ways a function might fail, even if parts might fail for many different reasons. As long as each error type implements the &lt;code&gt;from&lt;/code&gt; function to define how to convert itself to the returned error type, the &lt;code&gt;?&lt;/code&gt; operator takes care of the conversion automatically.</source>
          <target state="translated">清单9-6中的 &lt;code&gt;match&lt;/code&gt; 表达式和 &lt;code&gt;?&lt;/code&gt; 之间有区别。运算符do：具有 &lt;code&gt;?&lt;/code&gt; 的错误值调用它们的运算符通过标准库中 &lt;code&gt;From&lt;/code&gt; 特性定义的 &lt;code&gt;from&lt;/code&gt; 函数，该函数用于将错误从一种类型转换为另一种类型。什么时候 &lt;code&gt;?&lt;/code&gt; 如果操作员调用 &lt;code&gt;from&lt;/code&gt; 函数，则将收到的错误类型转换为在当前函数的返回类型中定义的错误类型。当一个函数返回一种错误类型来表示该函数可能发生故障的所有方式时，即使部件可能由于许多不同的原因而发生故障，这也很有用。只要每种错误类型都实现了 &lt;code&gt;from&lt;/code&gt; 函数定义如何将自身转换为返回的错误类型 &lt;code&gt;?&lt;/code&gt; 操作员会自动进行转换。</target>
        </trans-unit>
        <trans-unit id="42bfb7d2a182c3982d4afcf52f4999394d469590" translate="yes" xml:space="preserve">
          <source>There is a difference between what the &lt;code&gt;match&lt;/code&gt; expression from Listing 9-6 does and what the &lt;code&gt;?&lt;/code&gt; operator does: error values that have the &lt;code&gt;?&lt;/code&gt; operator called on them go through the &lt;code&gt;from&lt;/code&gt; function, defined in the &lt;code&gt;From&lt;/code&gt; trait in the standard library, which is used to convert errors from one type into another. When the &lt;code&gt;?&lt;/code&gt; operator calls the &lt;code&gt;from&lt;/code&gt; function, the error type received is converted into the error type defined in the return type of the current function. This is useful when a function returns one error type to represent all the ways a function might fail, even if parts might fail for many different reasons. As long as each error type implements the &lt;code&gt;from&lt;/code&gt; function to define how to convert itself to the returned error type, the &lt;code&gt;?&lt;/code&gt; operator takes care of the conversion automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b478d4cf3daf7fb5af886fd070b460cffb3f99a" translate="yes" xml:space="preserve">
          <source>There is a large variety of prefix types, see &lt;a href=&quot;enum.prefix&quot;&gt;&lt;code&gt;Prefix&lt;/code&gt;&lt;/a&gt;'s documentation for more.</source>
          <target state="translated">前缀类型种类繁多，有关更多信息，请参见&lt;a href=&quot;enum.prefix&quot;&gt; &lt;code&gt;Prefix&lt;/code&gt; &lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="b6a45e45d5b815dc5996fef1ade397970afb9eee" translate="yes" xml:space="preserve">
          <source>There is a natural point at which we can return the memory our &lt;code&gt;String&lt;/code&gt; needs to the allocator: when &lt;code&gt;s&lt;/code&gt; goes out of scope. When a variable goes out of scope, Rust calls a special function for us. This function is called &lt;code&gt;drop&lt;/code&gt;, and it&amp;rsquo;s where the author of &lt;code&gt;String&lt;/code&gt; can put the code to return the memory. Rust calls &lt;code&gt;drop&lt;/code&gt; automatically at the closing curly bracket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b02d233f669a1e206e4e2c20ce1d2df695bab4c" translate="yes" xml:space="preserve">
          <source>There is a natural point at which we can return the memory our &lt;code&gt;String&lt;/code&gt; needs to the operating system: when &lt;code&gt;s&lt;/code&gt; goes out of scope. When a variable goes out of scope, Rust calls a special function for us. This function is called &lt;code&gt;drop&lt;/code&gt;, and it&amp;rsquo;s where the author of &lt;code&gt;String&lt;/code&gt; can put the code to return the memory. Rust calls &lt;code&gt;drop&lt;/code&gt; automatically at the closing curly bracket.</source>
          <target state="translated">我们可以很自然地将 &lt;code&gt;String&lt;/code&gt; 需要的内存返回给操作系统：当 &lt;code&gt;s&lt;/code&gt; 超出范围时。当变量超出范围时，Rust为我们调用一个特殊函数。此函数称为 &lt;code&gt;drop&lt;/code&gt; ，它是 &lt;code&gt;String&lt;/code&gt; 的作者可以在其中放置代码以返回内存的地方。Rust通话 &lt;code&gt;drop&lt;/code&gt; 自动在右大括号处掉线。</target>
        </trans-unit>
        <trans-unit id="f99c36775b0b7e1c59faa2f7b94f6fd5d85206bb" translate="yes" xml:space="preserve">
          <source>There is a small difference between the two: the &lt;code&gt;derive&lt;/code&gt; strategy will also place a &lt;code&gt;Copy&lt;/code&gt; bound on type parameters, which isn't always desired.</source>
          <target state="translated">两者之间有一个小的区别： &lt;code&gt;derive&lt;/code&gt; 策略还将在类型参数上放置一个 &lt;code&gt;Copy&lt;/code&gt; 绑定，这并不总是需要的。</target>
        </trans-unit>
        <trans-unit id="ba88e1e16f5f4f6fd310c5a8bb2e8dd5b7b7dc78" translate="yes" xml:space="preserve">
          <source>There is currently a known issue (see &lt;a href=&quot;https://github.com/rust-lang/rust/issues/39364&quot;&gt;&lt;code&gt;#39364&lt;/code&gt;&lt;/a&gt;) that causes &lt;code&gt;recv_timeout&lt;/code&gt; to panic unexpectedly with the following example:</source>
          <target state="translated">当前存在一个已知问题（请参阅&lt;a href=&quot;https://github.com/rust-lang/rust/issues/39364&quot;&gt; &lt;code&gt;#39364&lt;/code&gt; &lt;/a&gt;），该错误导致 &lt;code&gt;recv_timeout&lt;/code&gt; 在以下示例中意外恐慌：</target>
        </trans-unit>
        <trans-unit id="ac69e37cd6f18587422e7c6b701f3aed59b4a925" translate="yes" xml:space="preserve">
          <source>There is currently no supported way to create a raw pointer or reference to a field of a struct inside &lt;code&gt;MaybeUninit&amp;lt;Struct&amp;gt;&lt;/code&gt;. That means it is not possible to create a struct by calling &lt;code&gt;MaybeUninit::uninit::&amp;lt;Struct&amp;gt;()&lt;/code&gt; and then writing to its fields.</source>
          <target state="translated">当前尚不支持在 &lt;code&gt;MaybeUninit&amp;lt;Struct&amp;gt;&lt;/code&gt; 内部创建原始指针或引用结构字段的方法。这意味着无法通过调用 &lt;code&gt;MaybeUninit::uninit::&amp;lt;Struct&amp;gt;()&lt;/code&gt; 然后写入其字段来创建结构。</target>
        </trans-unit>
        <trans-unit id="06e1ced9251455647a44280e8880c2f024531277" translate="yes" xml:space="preserve">
          <source>There is no consensus in the programming community about what features a language must have to be considered object oriented. Rust is influenced by many programming paradigms, including OOP; for example, we explored the features that came from functional programming in Chapter 13. Arguably, OOP languages share certain common characteristics, namely objects, encapsulation, and inheritance. Let&amp;rsquo;s look at what each of those characteristics means and whether Rust supports it.</source>
          <target state="translated">在编程社区中，对于必须将某种语言视为面向对象的功能尚未达成共识。 Rust受许多编程范例（包括OOP）的影响；例如，我们在第13章中探讨了函数式编程的功能。可以说，OOP语言具有某些共同的特征，即对象，封装和继承。让我们看看这些特征的含义以及Rust是否支持它。</target>
        </trans-unit>
        <trans-unit id="3940029042247daa011ed3a6db287dfc70d15650" translate="yes" xml:space="preserve">
          <source>There is no guarantee that an all-zero byte-pattern represents a valid value of some type &lt;code&gt;T&lt;/code&gt;. For example, the all-zero byte-pattern is not a valid value for reference types (&lt;code&gt;&amp;amp;T&lt;/code&gt; and &lt;code&gt;&amp;amp;mut T&lt;/code&gt;). Using &lt;code&gt;zeroed&lt;/code&gt; on such types causes immediate &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt; because &lt;a href=&quot;union.maybeuninit#initialization-invariant&quot;&gt;the Rust compiler assumes&lt;/a&gt; that there always is a valid value in a variable it considers initialized.</source>
          <target state="translated">无法保证全零字节模式代表某种类型 &lt;code&gt;T&lt;/code&gt; 的有效值。例如，全零字节模式对于引用类型（ &lt;code&gt;&amp;amp;T&lt;/code&gt; 和 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; ）不是有效值。在此类类型上使用 &lt;code&gt;zeroed&lt;/code&gt; 会导致立即发生&lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;未定义的行为，&lt;/a&gt;因为&lt;a href=&quot;union.maybeuninit#initialization-invariant&quot;&gt;Rust编译器假定&lt;/a&gt;在它认为已初始化的变量中始终存在有效值。</target>
        </trans-unit>
        <trans-unit id="3d516718a20e6c51e7b81919f2ed7f10da7e19e0" translate="yes" xml:space="preserve">
          <source>There is no guarantee that an all-zero byte-pattern represents a valid value of some type &lt;code&gt;T&lt;/code&gt;. For example, the all-zero byte-pattern is not a valid value for reference types (&lt;code&gt;&amp;amp;T&lt;/code&gt;, &lt;code&gt;&amp;amp;mut T&lt;/code&gt;) and functions pointers. Using &lt;code&gt;zeroed&lt;/code&gt; on such types causes immediate &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt; because &lt;a href=&quot;union.maybeuninit#initialization-invariant&quot;&gt;the Rust compiler assumes&lt;/a&gt; that there always is a valid value in a variable it considers initialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77cd938f61b73cdc8199024bd862cf47becca43c" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the memory pointed to by &lt;code&gt;ptr&lt;/code&gt; contains a valid nul terminator byte at the end of the string.</source>
          <target state="translated">无法保证 &lt;code&gt;ptr&lt;/code&gt; 指向的内存在字符串末尾包含有效的nul终止符字节。</target>
        </trans-unit>
        <trans-unit id="37d385330ea581c420be55585ac9b53b42ed4426" translate="yes" xml:space="preserve">
          <source>There is no guarantee to the validity of &lt;code&gt;ptr&lt;/code&gt;.</source>
          <target state="translated">无法保证 &lt;code&gt;ptr&lt;/code&gt; 的有效性。</target>
        </trans-unit>
        <trans-unit id="90b4dcdc90eb015a6d81f3692edc057c91c2b6f8" translate="yes" xml:space="preserve">
          <source>There is no implementation of &lt;a href=&quot;../ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; for child processes, so if you do not ensure the &lt;code&gt;Child&lt;/code&gt; has exited then it will continue to run, even after the &lt;code&gt;Child&lt;/code&gt; handle to the child process has gone out of scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96d59d760142fd31188eb3940b02911fcbc69887" translate="yes" xml:space="preserve">
          <source>There is no implementation of &lt;a href=&quot;https://doc.rust-lang.org/core/ops/trait.Drop.html&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; for child processes, so if you do not ensure the &lt;code&gt;Child&lt;/code&gt; has exited then it will continue to run, even after the &lt;code&gt;Child&lt;/code&gt; handle to the child process has gone out of scope.</source>
          <target state="translated">没有执行&lt;a href=&quot;https://doc.rust-lang.org/core/ops/trait.Drop.html&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; &lt;/a&gt;子进程，因此，如果您不能确保 &lt;code&gt;Child&lt;/code&gt; 已退出然后它会继续运行，偶数后 &lt;code&gt;Child&lt;/code&gt; 句柄子进程已经超出了范围。</target>
        </trans-unit>
        <trans-unit id="f7865277b670de1ac383b78686d6c6c3ef225ff1" translate="yes" xml:space="preserve">
          <source>There is no implicit capture of the containing function's generic parameters, parameters, and local variables. For example, &lt;code&gt;inner&lt;/code&gt; may not access &lt;code&gt;outer_var&lt;/code&gt;.</source>
          <target state="translated">没有隐式捕获包含函数的通用参数，参数和局部变量。例如， &lt;code&gt;inner&lt;/code&gt; 可能无法访问 &lt;code&gt;outer_var&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98bc5a98bb823e7a07123a40b084c3311e58d239" translate="yes" xml:space="preserve">
          <source>There is no meaningful value to associate with your keys.</source>
          <target state="translated">没有任何有意义的价值与你的钥匙相关联。</target>
        </trans-unit>
        <trans-unit id="e47f071471a1ed59d24ce5598360fe16b663897e" translate="yes" xml:space="preserve">
          <source>There is no syntax that directly refers to a function item type, but the compiler will display the type as something like &lt;code&gt;fn(u32) -&amp;gt; i32 {fn_name}&lt;/code&gt; in error messages.</source>
          <target state="translated">没有语法可以直接引用功能项类型，但是编译器将在错误消息中将类型显示为类似 &lt;code&gt;fn(u32) -&amp;gt; i32 {fn_name}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6352ff90262f746d2ceb9b5382b99f239203c508" translate="yes" xml:space="preserve">
          <source>There is no way to express the &lt;code&gt;if x &amp;lt; 5&lt;/code&gt; condition within a pattern, so the match guard gives us the ability to express this logic.</source>
          <target state="translated">无法在模式中表达 &lt;code&gt;if x &amp;lt; 5&lt;/code&gt; 条件，因此比赛防护使我们能够表达这种逻辑。</target>
        </trans-unit>
        <trans-unit id="f04c5e1cecb9254e859f18bc80c9ad5ecd03b1f1" translate="yes" xml:space="preserve">
          <source>There is no way to refer to all trait objects generically, so the only way to create values of this type is with functions like &lt;a href=&quot;../intrinsics/fn.transmute&quot;&gt;&lt;code&gt;std::mem::transmute&lt;/code&gt;&lt;/a&gt;. Similarly, the only way to create a true trait object from a &lt;code&gt;TraitObject&lt;/code&gt; value is with &lt;code&gt;transmute&lt;/code&gt;.</source>
          <target state="translated">无法通用地引用所有特征对象，因此创建此类型值的唯一方法是使用诸如&lt;a href=&quot;../intrinsics/fn.transmute&quot;&gt; &lt;code&gt;std::mem::transmute&lt;/code&gt; &lt;/a&gt;类的函数。同样，创建从一个真正的特质对象的唯一途径 &lt;code&gt;TraitObject&lt;/code&gt; 值与 &lt;code&gt;transmute&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ac27f2fb34cee3cbd54d9db13f601fadc62dc92" translate="yes" xml:space="preserve">
          <source>There is no way to refer to all trait objects generically, so the only way to create values of this type is with functions like &lt;a href=&quot;../mem/fn.transmute&quot;&gt;&lt;code&gt;std::mem::transmute&lt;/code&gt;&lt;/a&gt;. Similarly, the only way to create a true trait object from a &lt;code&gt;TraitObject&lt;/code&gt; value is with &lt;code&gt;transmute&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9f689cb8e372a1fb3e4dbcf70bbf33a833163e2" translate="yes" xml:space="preserve">
          <source>There is no wrong way to read this book: if you want to skip ahead, go for it! You might have to jump back to earlier chapters if you experience any confusion. But do whatever works for you.</source>
          <target state="translated">阅读本书的方法没有错:如果你想跳过前面的章节,就去吧! 如果你遇到任何困惑,你可能不得不跳回前面的章节。但是,无论做什么都适合你。</target>
        </trans-unit>
        <trans-unit id="f89524ca0c10b9d4f1257c768a5b98aab1c4ca9b" translate="yes" xml:space="preserve">
          <source>There is one more similarity between enums and structs: just as we&amp;rsquo;re able to define methods on structs using &lt;code&gt;impl&lt;/code&gt;, we&amp;rsquo;re also able to define methods on enums. Here&amp;rsquo;s a method named &lt;code&gt;call&lt;/code&gt; that we could define on our &lt;code&gt;Message&lt;/code&gt; enum:</source>
          <target state="translated">枚举和结构之间还有另外一个相似之处：正如我们可以使用 &lt;code&gt;impl&lt;/code&gt; 在结构上定义方法一样，我们也可以在枚举上定义方法。这是一个可以在 &lt;code&gt;Message&lt;/code&gt; 枚举上定义的名为 &lt;code&gt;call&lt;/code&gt; 的方法：</target>
        </trans-unit>
        <trans-unit id="dd5de49f07fcfe0b32f34685bec57fc973c95f95" translate="yes" xml:space="preserve">
          <source>There is possibly no limit to the number of &lt;code&gt;else&lt;/code&gt; blocks that could follow an &lt;code&gt;if&lt;/code&gt; expression however if you have several then a &lt;a href=&quot;keyword.match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; expression might be preferable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="602b0e48a3f43914053d4b199337461ae231047f" translate="yes" xml:space="preserve">
          <source>There is usually no need to create a &lt;code&gt;Thread&lt;/code&gt; struct yourself, one should instead use a function like &lt;code&gt;spawn&lt;/code&gt; to create new threads, see the docs of &lt;a href=&quot;struct.builder&quot;&gt;&lt;code&gt;Builder&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;spawn&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">通常不需要自己创建 &lt;code&gt;Thread&lt;/code&gt; 结构，而应该使用诸如 &lt;code&gt;spawn&lt;/code&gt; 的函数来创建新线程，有关更多详细信息，请参见&lt;a href=&quot;struct.builder&quot;&gt; &lt;code&gt;Builder&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;spawn&lt;/code&gt; &lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="f5aa017ba54ffa17080a39771f2c83f220593384" translate="yes" xml:space="preserve">
          <source>There will be an error about &lt;code&gt;bool&lt;/code&gt; not implementing &lt;code&gt;Index&amp;lt;u8&amp;gt;&lt;/code&gt;, followed by a note saying &quot;the type &lt;code&gt;bool&lt;/code&gt; cannot be indexed by &lt;code&gt;u8&lt;/code&gt;&quot;.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 不实现 &lt;code&gt;Index&amp;lt;u8&amp;gt;&lt;/code&gt; 会出现错误，然后出现一条注释，指出&amp;ldquo; &lt;code&gt;bool&lt;/code&gt; 类型不能被 &lt;code&gt;u8&lt;/code&gt; 索引&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="7649fb68743c30fa670731965f40aa4090d73b82" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a lot more to say about &lt;a href=&quot;http://doc.crates.io&quot;&gt;Cargo&lt;/a&gt; and &lt;a href=&quot;http://doc.crates.io/crates-io.html&quot;&gt;its ecosystem&lt;/a&gt; which we&amp;rsquo;ll discuss in Chapter 14, but for now, that&amp;rsquo;s all you need to know. Cargo makes it very easy to reuse libraries, so Rustaceans are able to write smaller projects that are assembled from a number of packages.</source>
          <target state="translated">还有很多更多要说&lt;a href=&quot;http://doc.crates.io&quot;&gt;货物&lt;/a&gt;和&lt;a href=&quot;http://doc.crates.io/crates-io.html&quot;&gt;它的生态系统&lt;/a&gt;，我们将在第14章讨论，但现在，这就是你需要知道的。 Cargo使重用库变得非常容易，因此Rustaceans能够编写由许多程序包组装而成的较小项目。</target>
        </trans-unit>
        <trans-unit id="2bf65550ac389c6cc7469a24526e0ae8bf661af9" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a tendency among many Rustaceans to avoid using &lt;code&gt;clone&lt;/code&gt; to fix ownership problems because of its runtime cost. In &lt;a href=&quot;ch13-00-functional-features&quot;&gt;Chapter 13&lt;/a&gt;, you&amp;rsquo;ll learn how to use more efficient methods in this type of situation. But for now, it&amp;rsquo;s okay to copy a few strings to continue making progress because you&amp;rsquo;ll make these copies only once and your filename and query string are very small. It&amp;rsquo;s better to have a working program that&amp;rsquo;s a bit inefficient than to try to hyperoptimize code on your first pass. As you become more experienced with Rust, it&amp;rsquo;ll be easier to start with the most efficient solution, but for now, it&amp;rsquo;s perfectly acceptable to call &lt;code&gt;clone&lt;/code&gt;.</source>
          <target state="translated">由于其运行时成本，许多Rustaceans中有一种避免使用 &lt;code&gt;clone&lt;/code&gt; 来解决所有权问题的趋势。在&lt;a href=&quot;ch13-00-functional-features&quot;&gt;第13章中&lt;/a&gt;，您将学习如何在这种情况下使用更有效的方法。但是就目前而言，可以复制一些字符串以继续取得进展是可以的，因为您将只复制一次这些副本，并且文件名和查询字符串非常小。最好有一个效率低下的工作程序，而不是在初次尝试时就对代码进行超优化。随着您对Rust的使用越来越丰富，从最有效的解决方案开始将变得更加容易，但是就目前而言，调用 &lt;code&gt;clone&lt;/code&gt; 完全可以接受。</target>
        </trans-unit>
        <trans-unit id="66fb5ab158cd4be714eaa0eeb00d2ccbb6eb7bd5" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s another advantage to using an enum rather than a struct: each variant can have different types and amounts of associated data. Version four type IP addresses will always have four numeric components that will have values between 0 and 255. If we wanted to store &lt;code&gt;V4&lt;/code&gt; addresses as four &lt;code&gt;u8&lt;/code&gt; values but still express &lt;code&gt;V6&lt;/code&gt; addresses as one &lt;code&gt;String&lt;/code&gt; value, we wouldn&amp;rsquo;t be able to with a struct. Enums handle this case with ease:</source>
          <target state="translated">使用枚举而不是结构还有另一个优点：每个变体可以具有不同类型和数量的关联数据。版本4类型的IP地址将始终具有四个数字部分，其值将介于0到255之间。如果我们想将 &lt;code&gt;V4&lt;/code&gt; 地址存储为四个 &lt;code&gt;u8&lt;/code&gt; 值，但仍将 &lt;code&gt;V6&lt;/code&gt; 地址表示为一个 &lt;code&gt;String&lt;/code&gt; 值，则无法使用结构。枚举可以轻松处理这种情况：</target>
        </trans-unit>
        <trans-unit id="a401bf0a884425f212fc0c2849df8bdacf839a70" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s another solution to the problem of bringing two types of the same name into the same scope with &lt;code&gt;use&lt;/code&gt;: after the path, we can specify &lt;code&gt;as&lt;/code&gt; and a new local name, or alias, for the type. Listing 7-16 shows another way to write the code in Listing 7-15 by renaming one of the two &lt;code&gt;Result&lt;/code&gt; types using &lt;code&gt;as&lt;/code&gt;.</source>
          <target state="translated">对于 &lt;code&gt;use&lt;/code&gt; 将相同名称的两种类型引入同一作用域的问题，还有另一种解决方案：在路径之后，我们可以 &lt;code&gt;as&lt;/code&gt; 指定一个新的本地名称或别名。清单7-16显示了另一种编写清单7-15中代码的方法，即使用 &lt;code&gt;as&lt;/code&gt; 重命名两个 &lt;code&gt;Result&lt;/code&gt; 类型之一。</target>
        </trans-unit>
        <trans-unit id="e2494d175673de3a22a42c411f830ff3208f6ec7" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s another wrinkle we haven&amp;rsquo;t talked about yet. This code using integers &amp;ndash; part of which was shown in Listing 4-2 &amp;ndash; works and is valid:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04733e00c121b49528c905aab2fa6e90d06dc6c3" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s another wrinkle we haven&amp;rsquo;t talked about yet. This code using integers, part of which was shown in Listing 4-2, works and is valid:</source>
          <target state="translated">我们还没有谈论过另一个皱纹。这段使用整数的代码有效且有效：部分代码如清单4-2所示：</target>
        </trans-unit>
        <trans-unit id="6058c5e16c87f1a91c60dc38f9f510ce010e9805" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s debate within the testing community about whether or not private functions should be tested directly, and other languages make it difficult or impossible to test private functions. Regardless of which testing ideology you adhere to, Rust&amp;rsquo;s privacy rules do allow you to test private functions. Consider the code in Listing 11-12 with the private function &lt;code&gt;internal_adder&lt;/code&gt;.</source>
          <target state="translated">在测试社区中，关于是否应直接测试私有功能存在争论，而其他语言使测试私有功能变得困难或不可能。无论您遵循哪种测试意识形态，Rust的隐私规则都允许您测试私有功能。考虑清单11-12中带有私有函数 &lt;code&gt;internal_adder&lt;/code&gt; 的代码。</target>
        </trans-unit>
        <trans-unit id="908f1205edb5e08b15769591fe9ecf304d371a0b" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s no mechanism being used to synchronize access to the data.</source>
          <target state="translated">没有用于同步对数据的访问的机制。</target>
        </trans-unit>
        <trans-unit id="8e1fa626ffc94c26aaee1b60bc06a3539eef3bfd" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s no reason to separate these methods into multiple &lt;code&gt;impl&lt;/code&gt; blocks here, but this is valid syntax. We&amp;rsquo;ll see a case in which multiple &lt;code&gt;impl&lt;/code&gt; blocks are useful in Chapter 10, where we discuss generic types and traits.</source>
          <target state="translated">这里没有理由将这些方法分为多个 &lt;code&gt;impl&lt;/code&gt; 块，但这是有效的语法。在第10章中，我们将讨论一种情况，其中多个 &lt;code&gt;impl&lt;/code&gt; 块很有用，我们在这里讨论了泛型类型和特征。</target>
        </trans-unit>
        <trans-unit id="68d4631903746cfba7c6e6864ab36c77a56f918c" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s no strong reason behind this idiom: it&amp;rsquo;s just the convention that has emerged, and folks have gotten used to reading and writing Rust code this way.</source>
          <target state="translated">这个习惯用法没有充分的理由：这只是惯例的出现，人们已经习惯了以这种方式读取和编写Rust代码。</target>
        </trans-unit>
        <trans-unit id="c6cc13f913f5af22a31d9a866ef0ab4e915bc64e" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s not a good way to encode this information in the types you use.</source>
          <target state="translated">没有一种很好的方法将这种信息编码为您使用的类型。</target>
        </trans-unit>
        <trans-unit id="42ede15289d883de11e0a80cc68d82337478321c" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s one more catch with this release model: unstable features. Rust uses a technique called &amp;ldquo;feature flags&amp;rdquo; to determine what features are enabled in a given release. If a new feature is under active development, it lands on &lt;code&gt;master&lt;/code&gt;, and therefore, in nightly, but behind a &lt;em&gt;feature flag&lt;/em&gt;. If you, as a user, wish to try out the work-in-progress feature, you can, but you must be using a nightly release of Rust and annotate your source code with the appropriate flag to opt in.</source>
          <target state="translated">此发行模型还有另外一个特点：不稳定的功能。Rust使用一种称为&amp;ldquo;功能标记&amp;rdquo;的技术来确定在给定发行版中启用了哪些功能。如果正在积极开发新功能，则它将降落在 &lt;code&gt;master&lt;/code&gt; 上，因此在夜间降落，但位于&lt;em&gt;功能标志的&lt;/em&gt;后面。如果您作为用户希望尝试进行中的功能，则可以，但是您必须使用每晚发布的Rust，并使用适当的标记来注释源代码以选择加入。</target>
        </trans-unit>
        <trans-unit id="daaeaab720a0d66e562ebf5f2bea02ac0a5abbb2" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s one more situation involving &lt;code&gt;pub&lt;/code&gt; that we haven&amp;rsquo;t covered, and that is our last module system feature: the &lt;code&gt;use&lt;/code&gt; keyword. We&amp;rsquo;ll cover &lt;code&gt;use&lt;/code&gt; by itself first, and then we&amp;rsquo;ll show how to combine &lt;code&gt;pub&lt;/code&gt; and &lt;code&gt;use&lt;/code&gt;.</source>
          <target state="translated">我们还没有涉及涉及 &lt;code&gt;pub&lt;/code&gt; 的另一种情况，这是我们的最后一个模块系统功能： &lt;code&gt;use&lt;/code&gt; 关键字。我们将首先介绍 &lt;code&gt;use&lt;/code&gt; ，然后说明如何结合 &lt;code&gt;pub&lt;/code&gt; 和 &lt;code&gt;use&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5e8c77371d51b56070c8afcedaaaf9336a342d93" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s one other aspect of &lt;code&gt;match&lt;/code&gt; we need to discuss. Consider this version of our &lt;code&gt;plus_one&lt;/code&gt; function that has a bug and won&amp;rsquo;t compile:</source>
          <target state="translated">我们还需要讨论 &lt;code&gt;match&lt;/code&gt; 另一方面。考虑我们的 &lt;code&gt;plus_one&lt;/code&gt; 函数的此版本，该版本存在错误并且无法编译：</target>
        </trans-unit>
        <trans-unit id="3cab02a3373b42bd604f431d95c5d649fedd71e0" translate="yes" xml:space="preserve">
          <source>There's a trait in the standard library for converting something into an iterator: &lt;a href=&quot;trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt;. This trait has one method, &lt;a href=&quot;trait.intoiterator#tymethod.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt;, which converts the thing implementing &lt;a href=&quot;trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; into an iterator. Let's take a look at that &lt;code&gt;for&lt;/code&gt; loop again, and what the compiler converts it into:</source>
          <target state="translated">标准库中有一个特征，可以将某些东西转换为迭代器：&lt;a href=&quot;trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt;。此特征具有一个方法&lt;a href=&quot;trait.intoiterator#tymethod.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; &lt;/a&gt;，它将实现&lt;a href=&quot;trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt;的东西转换为迭代器。让我们再次看一下 &lt;code&gt;for&lt;/code&gt; 循环，以及编译器将其转换为什么：</target>
        </trans-unit>
        <trans-unit id="126dd99b7c8920c551aa5435d3f5f50326fcb2aa" translate="yes" xml:space="preserve">
          <source>There's no easy fix for this, generally code will need to be refactored so that you no longer need to derive from &lt;code&gt;Super&amp;lt;Self&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">对此没有简单的解决方法，通常需要重构代码，以使您不再需要从 &lt;code&gt;Super&amp;lt;Self&amp;gt;&lt;/code&gt; 派生。</target>
        </trans-unit>
        <trans-unit id="488dc2b946582ce5502bb699e0ad78fcce8b394c" translate="yes" xml:space="preserve">
          <source>There's one more subtle bit here: the standard library contains an interesting implementation of &lt;a href=&quot;trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">这里还有一点微妙之处：标准库包含一个有趣的&lt;a href=&quot;trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt;实现：</target>
        </trans-unit>
        <trans-unit id="fd800f0b62b0c62a6a6fb9b356e68d3a2d4685be" translate="yes" xml:space="preserve">
          <source>There, the where clause &lt;code&gt;T: 'a&lt;/code&gt; that appears on the impl is not known to be satisfied on the struct. To make this example compile, you have to add a where-clause like &lt;code&gt;T: 'a&lt;/code&gt; to the struct definition:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="943a55d68bc8d1a8af15546966743386da3f91a8" translate="yes" xml:space="preserve">
          <source>Therefore, Rust&amp;rsquo;s type system and trait bounds ensure that you can never accidentally send an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value across threads unsafely. When we tried to do this in Listing 16-14, we got the error &lt;code&gt;the trait Send is not implemented for Rc&amp;lt;Mutex&amp;lt;i32&amp;gt;&amp;gt;&lt;/code&gt;. When we switched to &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt;, which is &lt;code&gt;Send&lt;/code&gt;, the code compiled.</source>
          <target state="translated">因此，Rust的类型系统和特征范围可确保您绝不会不安全地跨线程意外发送 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 值。当我们尝试在清单16-14中执行此操作时，遇到错误 &lt;code&gt;the trait Send is not implemented for Rc&amp;lt;Mutex&amp;lt;i32&amp;gt;&amp;gt;&lt;/code&gt; 。当我们切换到 &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; ，即 &lt;code&gt;Send&lt;/code&gt; 时，将编译代码。</target>
        </trans-unit>
        <trans-unit id="92887ab1d8d0b7fee43ce74855c566c18dd9ff66" translate="yes" xml:space="preserve">
          <source>Therefore, pinning also comes with a &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt;-related guarantee.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a965d0af2f94e5f3318be18d630d6ce398f8ad8c" translate="yes" xml:space="preserve">
          <source>Therefore, pinning also comes with a &lt;code&gt;drop&lt;/code&gt;-related guarantee.</source>
          <target state="translated">因此，固定还附带与 &lt;code&gt;drop&lt;/code&gt; 相关的保证。</target>
        </trans-unit>
        <trans-unit id="0034e8adfe6fdcd359b83e7e3154391d1a05f64e" translate="yes" xml:space="preserve">
          <source>Therefore, we cannot rely on naive check for &lt;code&gt;StructuralPartialEq&lt;/code&gt; and mere &lt;code&gt;Eq&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3da5db36b6a5c8b63c646979b9f9638e2ffed72" translate="yes" xml:space="preserve">
          <source>These abstractions can be built out of lower-level primitives. For efficiency, the sync objects in the standard library are usually implemented with help from the operating system's kernel, which is able to reschedule the threads while they are blocked on acquiring a lock.</source>
          <target state="translated">这些抽象可以从低级基元中构建出来。为了提高效率,标准库中的同步对象通常是在操作系统内核的帮助下实现的,内核能够在线程获取锁时被阻塞的情况下重新安排线程的时间。</target>
        </trans-unit>
        <trans-unit id="0b4543381c3d34027ca13b9d929f743b5e4c9c39" translate="yes" xml:space="preserve">
          <source>These also point to memory owned by some other value. A mutable reference type is written &lt;code&gt;&amp;amp;mut type&lt;/code&gt; or &lt;code&gt;&amp;amp;'a mut type&lt;/code&gt;. A mutable reference (that hasn't been borrowed) is the only way to access the value it points to, so is not &lt;code&gt;Copy&lt;/code&gt;.</source>
          <target state="translated">这些还指向其他值所拥有的内存。可变的引用类型是 &lt;code&gt;&amp;amp;mut type&lt;/code&gt; 或 &lt;code&gt;&amp;amp;'a mut type&lt;/code&gt; 。可变引用（尚未借用）是访问其指向的值的唯一方法，因此不是 &lt;code&gt;Copy&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1edbd620f4ea3fb93fdd0d7dd71adad12120dfa7" translate="yes" xml:space="preserve">
          <source>These ampersands are &lt;em&gt;references&lt;/em&gt;, and they allow you to refer to some value without taking ownership of it. Figure 4-5 shows a diagram.</source>
          <target state="translated">这些与符号是&lt;em&gt;reference&lt;/em&gt;，它们使您可以引用某些值而无需拥有所有权。图4-5显示了一个示意图。</target>
        </trans-unit>
        <trans-unit id="c26ef3d23f517e371ad3e5a198bcf65faf103392" translate="yes" xml:space="preserve">
          <source>These are all flags altering the behavior of the formatter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fbf8436660d61da218272cb68549a2354d27ae0" translate="yes" xml:space="preserve">
          <source>These are equivalent to the following explicit lifetime annotations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f42eae85e77f8aae9c5335f688c216fd7101df0" translate="yes" xml:space="preserve">
          <source>These are fairly high-level and quick break-downs of when each collection should be considered. Detailed discussions of strengths and weaknesses of individual collections can be found on their own documentation pages.</source>
          <target state="translated">这些都是相当高层次和快速的细分,说明何时应该考虑每个系列。关于各个系列的优缺点的详细讨论可在其各自的文件页上找到。</target>
        </trans-unit>
        <trans-unit id="f5b38a7809c6c63bf242f85f557b82e6e93c16bc" translate="yes" xml:space="preserve">
          <source>These are often used in combination with &lt;a href=&quot;external-blocks&quot;&gt;external block&lt;/a&gt; items which provide function &lt;em&gt;declarations&lt;/em&gt; that can be used to call functions without providing their &lt;em&gt;definition&lt;/em&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69b2114a065741874c57309ba27c70784c7ddedd" translate="yes" xml:space="preserve">
          <source>These are the last two unary operators. This table summarizes the behavior of them on primitive types and which traits are used to overload these operators for other types. Remember that signed integers are always represented using two's complement. The operands of all of these operators are evaluated in &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expression context&lt;/a&gt; so are moved or copied.</source>
          <target state="translated">这是最后两个一元运算符。该表总结了它们在原始类型上的行为，以及哪些特征用于使其他类型的这些运算符超载。请记住，带符号整数始终使用二进制补码表示。所有这些运算符的操作数都是在&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;值表达式上下文&lt;/a&gt;中评估的，因此可以移动或复制。</target>
        </trans-unit>
        <trans-unit id="25cb76396a6daa0dab5184b03f4b6697d1acd40a" translate="yes" xml:space="preserve">
          <source>These attributes are meant to only be used by the standard library and are rejected in your own crates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6db5a380dbbbf8a2cd7b3c9d1a9637a5d119ab4" translate="yes" xml:space="preserve">
          <source>These attributes do not work on typedefs, since typedefs are just aliases.</source>
          <target state="translated">这些属性对 typedefs 不起作用,因为 typedefs 只是别名。</target>
        </trans-unit>
        <trans-unit id="45e9c8e478d7d23050c1bb7760888996d75acd57" translate="yes" xml:space="preserve">
          <source>These axioms, along with careful use of &lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/a&gt; for pointer arithmetic, are enough to correctly implement many useful things in unsafe code. Stronger guarantees will be provided eventually, as the &lt;a href=&quot;https://doc.rust-lang.org/nomicon/aliasing.html&quot;&gt;aliasing&lt;/a&gt; rules are being determined. For more information, see the &lt;a href=&quot;../../book/ch19-01-unsafe-rust#dereferencing-a-raw-pointer&quot;&gt;book&lt;/a&gt; as well as the section in the reference devoted to &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt;.</source>
          <target state="translated">这些公理以及谨慎地使用&lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/a&gt;进行指针运算，足以在不安全的代码中正确实现许多有用的功能。随着确定&lt;a href=&quot;https://doc.rust-lang.org/nomicon/aliasing.html&quot;&gt;混叠&lt;/a&gt;规则，最终将提供更强有力的保证。有关更多信息，请参见&lt;a href=&quot;../../book/ch19-01-unsafe-rust#dereferencing-a-raw-pointer&quot;&gt;本书&lt;/a&gt;以及参考资料中有关&lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;未定义行为的部分&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7913b3c72a22fc6b243e0539a47297d89428aedf" translate="yes" xml:space="preserve">
          <source>These can all be interpreted as flags for a particular formatter.</source>
          <target state="translated">这些都可以解释为特定格式器的标志。</target>
        </trans-unit>
        <trans-unit id="0e39a0bd16ba8ecfd732cbb117c3248fda60a735" translate="yes" xml:space="preserve">
          <source>These can be fixed by declaring lifetime parameters:</source>
          <target state="translated">这些可以通过声明寿命参数来解决。</target>
        </trans-unit>
        <trans-unit id="d454f3116d0aed2fb7a537cae1b229f52b361113" translate="yes" xml:space="preserve">
          <source>These channels come in two flavors:</source>
          <target state="translated">这些渠道有两种口味。</target>
        </trans-unit>
        <trans-unit id="c31b94922e5b65f02fef2f529b0b7e4859486143" translate="yes" xml:space="preserve">
          <source>These components describe the shape of the data we&amp;rsquo;re working with, which we then match against values to determine whether our program has the correct data to continue running a particular piece of code.</source>
          <target state="translated">这些组件描述了我们正在使用的数据的形状，然后将它们与值进行匹配，以确定我们的程序是否具有正确的数据以继续运行特定的代码。</target>
        </trans-unit>
        <trans-unit id="01d073371ba3433dace28c44e03a57f2a2d8dbcd" translate="yes" xml:space="preserve">
          <source>These default object lifetime bounds are used instead of the lifetime parameter elision rules defined above when the lifetime bound is omitted entirely. If &lt;code&gt;'_&lt;/code&gt; is used as the lifetime bound then the bound follows the usual elision rules.</source>
          <target state="translated">当完全省略生命周期限制时，将使用这些默认对象生命周期界限来代替上面定义的生命周期参数省略规则。如果将 &lt;code&gt;'_&lt;/code&gt; 用作生存期界限，则界限遵循通常的省略规则。</target>
        </trans-unit>
        <trans-unit id="3cb556ed4e688a43a755806e0180a1ae20f4245d" translate="yes" xml:space="preserve">
          <source>These enumerations can be cast to integer types with the &lt;code&gt;as&lt;/code&gt; operator by a &lt;a href=&quot;../expressions/operator-expr#semantics&quot;&gt;numeric cast&lt;/a&gt;. The enumeration can optionally specify which integer each discriminant gets by following the variant name with &lt;code&gt;=&lt;/code&gt; followed by a &lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant expression&lt;/a&gt;. If the first variant in the declaration is unspecified, then it is set to zero. For every other unspecified discriminant, it is set to one higher than the previous variant in the declaration.</source>
          <target state="translated">这些枚举可以通过&lt;a href=&quot;../expressions/operator-expr#semantics&quot;&gt;数字转换&lt;/a&gt;使用 &lt;code&gt;as&lt;/code&gt; 运算符转换为整数类型。枚举可以有选择地指定每个判别式获得哪个整数，方法是在变量名称之后加上 &lt;code&gt;=&lt;/code&gt; ,后跟一个&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;常量表达式&lt;/a&gt;。如果声明中的第一个变量未指定，则将其设置为零。对于所有其他未指定的判别式，将其设置为比声明中的先前变体高一个。</target>
        </trans-unit>
        <trans-unit id="56f44a74054755cd230d668bfd5dc0a8f5aa2ac0" translate="yes" xml:space="preserve">
          <source>These keywords aren't used yet, but they are reserved for future use. They have the same restrictions as strict keywords. The reasoning behind this is to make current programs forward compatible with future versions of Rust by forbidding them to use these keywords.</source>
          <target state="translated">这些关键字还没有使用,但它们保留给将来使用。它们与严格关键字有相同的限制。这背后的原因是通过禁止当前程序使用这些关键字,使其与未来版本的Rust兼容。</target>
        </trans-unit>
        <trans-unit id="f2eab53396d35c8dd4df2e3ab58dfee415a7015e" translate="yes" xml:space="preserve">
          <source>These keywords can only be used in their correct contexts. They cannot be used as the names of:</source>
          <target state="translated">这些关键词只能在正确的上下文中使用。它们不能作为下列机构的名称使用:</target>
        </trans-unit>
        <trans-unit id="aec421e6db4795c07bbf5e8ae6411e119af0b089" translate="yes" xml:space="preserve">
          <source>These keywords have special meaning only in certain contexts. For example, it is possible to declare a variable or method with the name &lt;code&gt;union&lt;/code&gt;.</source>
          <target state="translated">这些关键字仅在某些情况下具有特殊含义。例如，可以使用名称 &lt;code&gt;union&lt;/code&gt; 声明变量或方法。</target>
        </trans-unit>
        <trans-unit id="24355b40ed9274fe2bce5ed7512a65c55ffdfb11" translate="yes" xml:space="preserve">
          <source>These lines define a function in Rust. The &lt;code&gt;main&lt;/code&gt; function is special: it is always the first code that runs in every executable Rust program. The first line declares a function named &lt;code&gt;main&lt;/code&gt; that has no parameters and returns nothing. If there were parameters, they would go inside the parentheses, &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">这些行定义了Rust中的功能。的 &lt;code&gt;main&lt;/code&gt; 功能是特殊的：它总是第一个代码，在每个可执行锈程序运行。第一行声明了一个名为 &lt;code&gt;main&lt;/code&gt; 的函数，该函数没有参数，也不返回任何内容。如果有参数，它们将放在括号 &lt;code&gt;()&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="78ee21b3b578a8828b900a4d7bb5e92af7fdfb9f" translate="yes" xml:space="preserve">
          <source>These lines show Cargo only updates the build with your tiny change to the &lt;em&gt;src/main.rs&lt;/em&gt; file. Your dependencies haven&amp;rsquo;t changed, so Cargo knows it can reuse what it has already downloaded and compiled for those. It just rebuilds your part of the code.</source>
          <target state="translated">这些行显示Cargo仅对&lt;em&gt;src / main.rs&lt;/em&gt;文件进行了很小的更改即可更新构建。您的依存关系没有改变，因此Cargo知道它可以重复使用已经为它们下载和编译的内容。它只是重建您的部分代码。</target>
        </trans-unit>
        <trans-unit id="ba54db094123009e0eb01fa8adef8c82df9419e8" translate="yes" xml:space="preserve">
          <source>These macros are defined by a &lt;a href=&quot;visibility-and-privacy&quot;&gt;public&lt;/a&gt;&lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; with the &lt;code&gt;proc_macro&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; and a signature of &lt;code&gt;(TokenStream) -&amp;gt; TokenStream&lt;/code&gt;. The input &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is what is inside the delimiters of the macro invocation and the output &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; replaces the entire macro invocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c77584f3dda90ac8527f5ef32d9ad1f6daeca4c8" translate="yes" xml:space="preserve">
          <source>These macros are defined by a &lt;a href=&quot;visibility-and-privacy&quot;&gt;public&lt;/a&gt;&lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; with the &lt;code&gt;proc_macro&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; and a signature of &lt;code&gt;(TokenStream) -&amp;gt; TokenStream&lt;/code&gt;. The input &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is what is inside the delimiters of the macro invocation and the output &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; replaces the entire macro invocation. It may contain an arbitrary number of &lt;a href=&quot;items&quot;&gt;items&lt;/a&gt;. These macros cannot expand to syntax that defines new &lt;code&gt;macro_rules&lt;/code&gt; style macros.</source>
          <target state="translated">这些宏由具有 &lt;code&gt;proc_macro&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;和 &lt;code&gt;(TokenStream) -&amp;gt; TokenStream&lt;/code&gt; 签名的&lt;a href=&quot;visibility-and-privacy&quot;&gt;公共&lt;/a&gt;&lt;a href=&quot;items/functions&quot;&gt;函数&lt;/a&gt;定义。输入&lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt;是宏调用的定界符之内，输出&lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt;替换整个宏调用。它可以包含任意数量的&lt;a href=&quot;items&quot;&gt;项目&lt;/a&gt;。这些宏不能扩展为定义新的 &lt;code&gt;macro_rules&lt;/code&gt; 样式宏的语法。</target>
        </trans-unit>
        <trans-unit id="254739acb173823a2863a1c41d3ebb09cfa13aeb" translate="yes" xml:space="preserve">
          <source>These macros are only invokable in &lt;a href=&quot;items/modules&quot;&gt;modules&lt;/a&gt;. They cannot even be invoked to create &lt;a href=&quot;statements#item-declarations&quot;&gt;item declaration statements&lt;/a&gt;. Furthermore, they must either be invoked with curly braces and no semicolon or a different delimiter followed by a semicolon. For example, &lt;code&gt;make_answer&lt;/code&gt; from the previous example can be invoked as &lt;code&gt;make_answer!{}&lt;/code&gt;, &lt;code&gt;make_answer!();&lt;/code&gt; or &lt;code&gt;make_answer![];&lt;/code&gt;.</source>
          <target state="translated">这些宏只能在&lt;a href=&quot;items/modules&quot;&gt;模块中&lt;/a&gt;调用。甚至不能调用它们来创建&lt;a href=&quot;statements#item-declarations&quot;&gt;项目声明语句&lt;/a&gt;。此外，必须使用大括号而不使用分号或使用分号后跟分号来调用它们。例如， &lt;code&gt;make_answer&lt;/code&gt; 从前面的例子可被调用 &lt;code&gt;make_answer!{}&lt;/code&gt; ， &lt;code&gt;make_answer!();&lt;/code&gt; 或 &lt;code&gt;make_answer![];&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5391198458bfd8d81a447bc30f66734e6f03394d" translate="yes" xml:space="preserve">
          <source>These markers can be combined, so &lt;code&gt;unsafe extern &quot;stdcall&quot; fn()&lt;/code&gt; is a valid type.</source>
          <target state="translated">这些标记可以组合，因此 &lt;code&gt;unsafe extern &quot;stdcall&quot; fn()&lt;/code&gt; 是有效类型。</target>
        </trans-unit>
        <trans-unit id="8c3ea3ec32e230deeef1943701b442105e65b661" translate="yes" xml:space="preserve">
          <source>These operators cannot be overloaded.</source>
          <target state="translated">这些运算符不能过载。</target>
        </trans-unit>
        <trans-unit id="12f02bfbd76d4dd6ccf6a1d0f95634f64537447a" translate="yes" xml:space="preserve">
          <source>These point to memory &lt;em&gt;owned by some other value&lt;/em&gt;. When a shared reference to a value is created it prevents direct mutation of the value. &lt;a href=&quot;../interior-mutability&quot;&gt;Interior mutability&lt;/a&gt; provides an exception for this in certain circumstances. As the name suggests, any number of shared references to a value may exist. A shared reference type is written &lt;code&gt;&amp;amp;type&lt;/code&gt;, or &lt;code&gt;&amp;amp;'a type&lt;/code&gt; when you need to specify an explicit lifetime. Copying a reference is a &quot;shallow&quot; operation: it involves only copying the pointer itself, that is, pointers are &lt;code&gt;Copy&lt;/code&gt;. Releasing a reference has no effect on the value it points to, but referencing of a &lt;a href=&quot;../expressions#temporaries&quot;&gt;temporary value&lt;/a&gt; will keep it alive during the scope of the reference itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fc236a778b843e2aeed416fa4b2cc9e1a08823c" translate="yes" xml:space="preserve">
          <source>These point to memory &lt;em&gt;owned by some other value&lt;/em&gt;. When a shared reference to a value is created it prevents direct mutation of the value. &lt;a href=&quot;../interior-mutability&quot;&gt;Interior mutability&lt;/a&gt; provides an exception for this in certain circumstances. As the name suggests, any number of shared references to a value may exist. A shared reference type is written &lt;code&gt;&amp;amp;type&lt;/code&gt;, or &lt;code&gt;&amp;amp;'a type&lt;/code&gt; when you need to specify an explicit lifetime. Copying a reference is a &quot;shallow&quot; operation: it involves only copying the pointer itself, that is, pointers are &lt;code&gt;Copy&lt;/code&gt;. Releasing a reference has no effect on the value it points to, but referencing of a &lt;a href=&quot;../expressions#temporary-lifetimes&quot;&gt;temporary value&lt;/a&gt; will keep it alive during the scope of the reference itself.</source>
          <target state="translated">这些指向&lt;em&gt;由其他值拥有的&lt;/em&gt;内存。当创建对值的共享引用时，它将防止值的直接突变。&lt;a href=&quot;../interior-mutability&quot;&gt;内部可变性&lt;/a&gt;在某些情况下为此提供了例外。顾名思义，可以存在任意数量的共享引用。当您需要指定显式生存期时，共享引用类型将写为 &lt;code&gt;&amp;amp;type&lt;/code&gt; 或 &lt;code&gt;&amp;amp;'a type&lt;/code&gt; 。复制引用是一种&amp;ldquo;浅&amp;rdquo;操作：它仅涉及复制指针本身，即指针为 &lt;code&gt;Copy&lt;/code&gt; 。释放引用对其所指向的值没有影响，但是引用&lt;a href=&quot;../expressions#temporary-lifetimes&quot;&gt;临时值&lt;/a&gt;将使其在引用本身的范围内保持活动状态。</target>
        </trans-unit>
        <trans-unit id="e5e8141a80455494c8061b88eb7d52c5630351cf" translate="yes" xml:space="preserve">
          <source>These profile names might be familiar from the output of your builds:</source>
          <target state="translated">这些配置文件的名字可能在你的构建的输出中很熟悉。</target>
        </trans-unit>
        <trans-unit id="1ad28c50cb4ab16e536724b4f61aca4d7477f454" translate="yes" xml:space="preserve">
          <source>These safety checks can be relaxed for a section of the code by wrapping the unsafe instructions with an &lt;code&gt;unsafe&lt;/code&gt; block. For instance:</source>
          <target state="translated">这些安全检查可通过用包裹不安全的指令来放宽的代码的部分 &lt;code&gt;unsafe&lt;/code&gt; 块。例如：</target>
        </trans-unit>
        <trans-unit id="7c9be14b653ccb0fc4412a262bd32a7bb0662862" translate="yes" xml:space="preserve">
          <source>These traits, along with &lt;a href=&quot;../../../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt;, work in conjunction so that it is possible to &lt;strong&gt;round-trip&lt;/strong&gt; strings from Windows and back, with no loss of data, even if the strings are ill-formed UTF-16.</source>
          <target state="translated">这些特性与&lt;a href=&quot;../../../ffi/struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt;一起使用，以便即使Windows字符串格式不正确，也可以从Windows &lt;strong&gt;来回&lt;/strong&gt;传递字符串，而不会丢失数据。</target>
        </trans-unit>
        <trans-unit id="0cc726c49519e90aab3de25bfe65c626d294217a" translate="yes" xml:space="preserve">
          <source>These two cases are surprisingly powerful for creating module hierarchies exposing public APIs while hiding internal implementation details. To help explain, here's a few use cases and what they would entail:</source>
          <target state="translated">这两个案例对于创建暴露公共API的模块层次结构,同时隐藏内部实现细节来说,是出奇的强大。为了帮助解释,这里有几个用例以及它们会带来什么。</target>
        </trans-unit>
        <trans-unit id="8ac19292e9dd15d2d45f1f79b996a19bf6206f30" translate="yes" xml:space="preserve">
          <source>These two examples illustrate the problem:</source>
          <target state="translated">这两个例子说明了这个问题。</target>
        </trans-unit>
        <trans-unit id="dca9d4b1de7c5a2be4c4d5727e7917fd8aab654c" translate="yes" xml:space="preserve">
          <source>These two formatting traits have distinct purposes:</source>
          <target state="translated">这两种格式特征有不同的目的。</target>
        </trans-unit>
        <trans-unit id="742fffc208f85aff3d0f6f3059eddfffa585c4ab" translate="yes" xml:space="preserve">
          <source>These two functions might be implemented in Rust as follows. Here, the &lt;code&gt;struct Foo*&lt;/code&gt; type from C is translated to &lt;code&gt;Box&amp;lt;Foo&amp;gt;&lt;/code&gt;, which captures the ownership constraints. Note also that the nullable argument to &lt;code&gt;foo_delete&lt;/code&gt; is represented in Rust as &lt;code&gt;Option&amp;lt;Box&amp;lt;Foo&amp;gt;&amp;gt;&lt;/code&gt;, since &lt;code&gt;Box&amp;lt;Foo&amp;gt;&lt;/code&gt; cannot be null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f982f08c4e46524b8318daa35d1f6508b56f9c5" translate="yes" xml:space="preserve">
          <source>These two terms are often used interchangeably, and what they are attempting to convey is the answer to the question &quot;Can this item be used at this location?&quot;</source>
          <target state="translated">这两个术语经常交替使用,它们所要表达的是对 &quot;这个项目能否在这个地点使用?&quot;这个问题的回答。</target>
        </trans-unit>
        <trans-unit id="327e657798ef3a0fe98594c42be8998daff24b69" translate="yes" xml:space="preserve">
          <source>These types provide access to the underlying data through references to the type of that data. They are said to be &amp;lsquo;borrowed as&amp;rsquo; that type. For instance, a &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; can be borrowed as &lt;code&gt;T&lt;/code&gt; while a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; can be borrowed as &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">这些类型通过对数据类型的引用来提供对基础数据的访问。据说它们是&amp;ldquo;借来的&amp;rdquo;那种类型的。例如，可以将&lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;T&lt;/code&gt; 借用，而可以将&lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;str&lt;/code&gt; 借用。</target>
        </trans-unit>
        <trans-unit id="a24b18110788da060d08a87d6e0370b2f3f11b2d" translate="yes" xml:space="preserve">
          <source>These will always be ORed with &lt;code&gt;CREATE_UNICODE_ENVIRONMENT&lt;/code&gt;.</source>
          <target state="translated">这些将始终与 &lt;code&gt;CREATE_UNICODE_ENVIRONMENT&lt;/code&gt; 进行&amp;ldquo;或&amp;rdquo;运算。</target>
        </trans-unit>
        <trans-unit id="4d9283345c9b012905e98bac4c4ff6bf77874d49" translate="yes" xml:space="preserve">
          <source>They are &lt;code&gt;'static&lt;/code&gt; because they're stored directly in the final binary, and so will be valid for the &lt;code&gt;'static&lt;/code&gt; duration.</source>
          <target state="translated">它们是 &lt;code&gt;'static&lt;/code&gt; 因为它们直接存储在最终二进制文件中，因此在 &lt;code&gt;'static&lt;/code&gt; 持续时间内有效。</target>
        </trans-unit>
        <trans-unit id="86b3fa967e9ddc952d15703cad09add6ed0fe12c" translate="yes" xml:space="preserve">
          <source>They are never allowed before:</source>
          <target state="translated">他们以前从不允许。</target>
        </trans-unit>
        <trans-unit id="a91c6bc4d714ec79e34b3b499dac181a1c8a5b61" translate="yes" xml:space="preserve">
          <source>They are written as &lt;code&gt;impl&lt;/code&gt; followed by a set of trait bounds.</source>
          <target state="translated">它们被写为 &lt;code&gt;impl&lt;/code&gt; ,后跟一组特征边界。</target>
        </trans-unit>
        <trans-unit id="d6f10b3f0570fbded7ab662d2bff2e38078266a6" translate="yes" xml:space="preserve">
          <source>They can be used as targets of transmutes in unsafe code for manipulating the raw representations directly.</source>
          <target state="translated">它们可以在不安全的代码中作为转码的目标,直接操作原始表示。</target>
        </trans-unit>
        <trans-unit id="81857ae63bf1641ca750521f716199457233e82d" translate="yes" xml:space="preserve">
          <source>They never take parameters and never return types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb09871747750e3ee06b75fa9a63f7cfbbd1d29" translate="yes" xml:space="preserve">
          <source>Thin pointers are &quot;simple&quot; pointers: they are purely a reference to a memory address.</source>
          <target state="translated">薄指针是 &quot;简单 &quot;的指针:它们纯粹是对内存地址的引用。</target>
        </trans-unit>
        <trans-unit id="4d4a58caf1c3fd49804715c525d371aaf6cc87c9" translate="yes" xml:space="preserve">
          <source>Things can get a little tricky once you start intermingling the two types of positional specifiers. The &quot;next argument&quot; specifier can be thought of as an iterator over the argument. Each time a &quot;next argument&quot; specifier is seen, the iterator advances. This leads to behavior like this:</source>
          <target state="translated">一旦你开始混合两种类型的位置指定符,事情就会变得有点棘手。&quot;下一个参数 &quot;指定符可以被认为是参数的迭代器。每次看到 &quot;下一个参数 &quot;指定符,迭代器就会前进。这就导致了这样的行为。</target>
        </trans-unit>
        <trans-unit id="9af9ddcb5af382b3006b61fbf3f41b42b2b57797" translate="yes" xml:space="preserve">
          <source>Think of a &lt;code&gt;match&lt;/code&gt; expression as being like a coin-sorting machine: coins slide down a track with variously sized holes along it, and each coin falls through the first hole it encounters that it fits into. In the same way, values go through each pattern in a &lt;code&gt;match&lt;/code&gt;, and at the first pattern the value &amp;ldquo;fits,&amp;rdquo; the value falls into the associated code block to be used during execution.</source>
          <target state="translated">可以将 &lt;code&gt;match&lt;/code&gt; 表达式想像成硬币分类机：硬币沿着轨道滑动，轨道上有各种大小的孔，每枚硬币都从它遇到的第一个孔中掉落。以相同的方式，值通过 &lt;code&gt;match&lt;/code&gt; 中的每个模式，并且在第一个模式中值&amp;ldquo;适合&amp;rdquo;，该值落入要在执行期间使用的关联代码块。</target>
        </trans-unit>
        <trans-unit id="1fdd8b4a97ce68f59e33b3f6b509748be1aa6f2f" translate="yes" xml:space="preserve">
          <source>Think of being seated at a restaurant. When you enter, you state the number of people in your group, and the staff finds an empty table that fits everyone and leads you there. If someone in your group comes late, they can ask where you&amp;rsquo;ve been seated to find you.</source>
          <target state="translated">想想坐在餐厅里。输入时，说明组中的人数，工作人员会找到一个适合所有人的空表，并带您到那里。如果您小组中的某人迟到，他们可以询问您在哪里坐下来找到您。</target>
        </trans-unit>
        <trans-unit id="0748eff7f6f3425a675a552a35d84af9fe1be56c" translate="yes" xml:space="preserve">
          <source>Thinking about the relationships another way, a parent node should own its children: if a parent node is dropped, its child nodes should be dropped as well. However, a child should not own its parent: if we drop a child node, the parent should still exist. This is a case for weak references!</source>
          <target state="translated">从另一个角度思考这些关系,父节点应该拥有它的子节点:如果一个父节点被删除,它的子节点也应该被删除。然而,子节点不应该拥有它的父节点:如果我们放弃一个子节点,父节点应该仍然存在。这就是一个弱引用的案例!</target>
        </trans-unit>
        <trans-unit id="399cffdf26999603bae93a3715241addff90c419" translate="yes" xml:space="preserve">
          <source>Thinking in Terms of Lifetimes</source>
          <target state="translated">从寿命的角度思考</target>
        </trans-unit>
        <trans-unit id="7407b5aadd0d88118f5b7bf8fb59e7e1d6d93882" translate="yes" xml:space="preserve">
          <source>Third, the &lt;code&gt;run&lt;/code&gt; function now returns an &lt;code&gt;Ok&lt;/code&gt; value in the success case. We&amp;rsquo;ve declared the &lt;code&gt;run&lt;/code&gt; function&amp;rsquo;s success type as &lt;code&gt;()&lt;/code&gt; in the signature, which means we need to wrap the unit type value in the &lt;code&gt;Ok&lt;/code&gt; value. This &lt;code&gt;Ok(())&lt;/code&gt; syntax might look a bit strange at first, but using &lt;code&gt;()&lt;/code&gt; like this is the idiomatic way to indicate that we&amp;rsquo;re calling &lt;code&gt;run&lt;/code&gt; for its side effects only; it doesn&amp;rsquo;t return a value we need.</source>
          <target state="translated">第三，在成功情况下， &lt;code&gt;run&lt;/code&gt; 函数现在返回 &lt;code&gt;Ok&lt;/code&gt; 值。我们已经在签名中将 &lt;code&gt;run&lt;/code&gt; 函数的成功类型声明为 &lt;code&gt;()&lt;/code&gt; ，这意味着我们需要将单元类型值包装在 &lt;code&gt;Ok&lt;/code&gt; 值中。这种 &lt;code&gt;Ok(())&lt;/code&gt; 语法起初可能看起来有些奇怪，但是像这样使用 &lt;code&gt;()&lt;/code&gt; 是惯用的方式，它表明我们仅出于其副作用调用 &lt;code&gt;run&lt;/code&gt; 。它不会返回我们需要的值。</target>
        </trans-unit>
        <trans-unit id="5ed975d1877254eff4f647cec29b338bbca64ef4" translate="yes" xml:space="preserve">
          <source>Third, the standard library defines &lt;a href=&quot;prelude/index&quot;&gt;The Rust Prelude&lt;/a&gt;, a small collection of items - mostly traits - that are imported into every module of every crate. The traits in the prelude are pervasive, making the prelude documentation a good entry point to learning about the library.</source>
          <target state="translated">第三，标准库定义了&lt;a href=&quot;prelude/index&quot;&gt;Rust Prelude&lt;/a&gt;，这是少量物品（主要是特征）的集合，这些物品被导入到每个板条箱的每个模块中。前奏中的特征无处不在，这使前奏文档成为学习图书馆的一个很好的切入点。</target>
        </trans-unit>
        <trans-unit id="2c016402b0d7abec88d04b55dd5a8f4c018ceb4a" translate="yes" xml:space="preserve">
          <source>Third, you see the &lt;code&gt;&quot;Hello, world!&quot;&lt;/code&gt; string. We pass this string as an argument to &lt;code&gt;println!&lt;/code&gt;, and the string is printed to the screen.</source>
          <target state="translated">第三，您看到的是 &lt;code&gt;&quot;Hello, world!&quot;&lt;/code&gt; 串。我们将此字符串作为参数传递给 &lt;code&gt;println!&lt;/code&gt; ，然后字符串将显示在屏幕上。</target>
        </trans-unit>
        <trans-unit id="756c69ab3ae5844d50aa9add76723030b90c2e84" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt; will be an &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; if there's some sort of intermittent IO error during iteration.</source>
          <target state="translated">这个&lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt;将是一个&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;，如果有迭代过程中某种间歇IO错误。</target>
        </trans-unit>
        <trans-unit id="45e5b6731a2eea68db70299dc76799ac1e3d8403" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt;'s receiving half has disconnected, so the data could not be sent. The data is returned back to the callee in this case.</source>
          <target state="translated">此&lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; &lt;/a&gt;的接收一半已断开连接，因此无法发送数据。在这种情况下，数据将返回给被调用方。</target>
        </trans-unit>
        <trans-unit id="e029dc532e12308a313b095f5b88bb0b2db85884" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;#[route]&lt;/code&gt; attribute would be defined by the framework as a procedural macro. The signature of the macro definition function would look like this:</source>
          <target state="translated">该 &lt;code&gt;#[route]&lt;/code&gt; 属性将由框架定义为程序宏。宏定义函数的签名如下所示：</target>
        </trans-unit>
        <trans-unit id="dc8fa4acf3fa662b100c7f01811572d66ca46b05" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;Message&lt;/code&gt; enum will either be a &lt;code&gt;NewJob&lt;/code&gt; variant that holds the &lt;code&gt;Job&lt;/code&gt; the thread should run, or it will be a &lt;code&gt;Terminate&lt;/code&gt; variant that will cause the thread to exit its loop and stop.</source>
          <target state="translated">此 &lt;code&gt;Message&lt;/code&gt; 枚举将是一个 &lt;code&gt;NewJob&lt;/code&gt; 变量，该变量保存线程应运行的 &lt;code&gt;Job&lt;/code&gt; ，或者它将是 &lt;code&gt;Terminate&lt;/code&gt; 变量，它将导致线程退出其循环并停止。</target>
        </trans-unit>
        <trans-unit id="2ac2c44f291b0094f7e740b5540fe932bd4487e6" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is constructed from the &lt;a href=&quot;../struct.btreemap#method.entry&quot;&gt;&lt;code&gt;entry&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c64bdd9b3fc3f77ac39443372876ff3d0846511f" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is constructed from the &lt;a href=&quot;../struct.hashmap#method.entry&quot;&gt;&lt;code&gt;entry&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df201a49abc9a95b4b9db82dff3855ec3856b74c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is constructed from the &lt;a href=&quot;struct.btreemap#method.entry&quot;&gt;&lt;code&gt;entry&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这个 &lt;code&gt;enum&lt;/code&gt; 是根据&lt;a href=&quot;struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.btreemap#method.entry&quot;&gt; &lt;code&gt;entry&lt;/code&gt; &lt;/a&gt;方法构造的。</target>
        </trans-unit>
        <trans-unit id="78b77c0bae34af9fbe0dd6db2b8a03354e7c6a07" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is constructed from the &lt;a href=&quot;struct.hashmap#method.entry&quot;&gt;&lt;code&gt;entry&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这个 &lt;code&gt;enum&lt;/code&gt; 是从&lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.hashmap#method.entry&quot;&gt; &lt;code&gt;entry&lt;/code&gt; &lt;/a&gt;方法构造的。</target>
        </trans-unit>
        <trans-unit id="e4ed5614390f8cd7c309ba2eff1ecf5972023c00" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is constructed through the &lt;a href=&quot;../struct.hashmap#method.raw_entry_mut&quot;&gt;&lt;code&gt;raw_entry_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;, then calling one of the methods of that &lt;a href=&quot;struct.rawentrybuildermut&quot;&gt;&lt;code&gt;RawEntryBuilderMut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e49b2cde36d96ef41241461160aaa7f39ffe4733" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is constructed through the &lt;a href=&quot;struct.hashmap#method.raw_entry_mut&quot;&gt;&lt;code&gt;raw_entry_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;, then calling one of the methods of that &lt;a href=&quot;struct.rawentrybuildermut&quot;&gt;&lt;code&gt;RawEntryBuilderMut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;enum&lt;/code&gt; 是通过&lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.hashmap#method.raw_entry_mut&quot;&gt; &lt;code&gt;raw_entry_mut&lt;/code&gt; &lt;/a&gt;方法构造的，然后调用该&lt;a href=&quot;struct.rawentrybuildermut&quot;&gt; &lt;code&gt;RawEntryBuilderMut&lt;/code&gt; &lt;/a&gt;的方法之一。</target>
        </trans-unit>
        <trans-unit id="484cddb60aced3f0fd2c66d36c2d02b11434898c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is created by iterating over &lt;a href=&quot;struct.components&quot;&gt;&lt;code&gt;Components&lt;/code&gt;&lt;/a&gt;, which in turn is created by the &lt;a href=&quot;struct.path#method.components&quot;&gt;&lt;code&gt;components&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;enum&lt;/code&gt; 是通过对&lt;a href=&quot;struct.components&quot;&gt; &lt;code&gt;Components&lt;/code&gt; &lt;/a&gt;进行迭代来创建的，而Components又由&lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.path#method.components&quot;&gt; &lt;code&gt;components&lt;/code&gt; &lt;/a&gt;方法创建的。</target>
        </trans-unit>
        <trans-unit id="94a9ddcdadd6c80893c9aa067a5c5342d16c5ca8" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is slightly awkward: it will never actually exist. This error is part of the type signature of the implementation of &lt;a href=&quot;../str/trait.fromstr&quot;&gt;&lt;code&gt;FromStr&lt;/code&gt;&lt;/a&gt; on &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;. The return type of &lt;a href=&quot;../str/trait.fromstr#tymethod.from_str&quot;&gt;&lt;code&gt;from_str&lt;/code&gt;&lt;/a&gt;, requires that an error be defined, but, given that a &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; can always be made into a new &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; without error, this type will never actually be returned. As such, it is only here to satisfy said signature, and is useless otherwise.</source>
          <target state="translated">这个 &lt;code&gt;enum&lt;/code&gt; 有点尴尬：它实际上不会存在。这个错误的实现的类型签名的一部分&lt;a href=&quot;../str/trait.fromstr&quot;&gt; &lt;code&gt;FromStr&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;。返回类型&lt;a href=&quot;../str/trait.fromstr#tymethod.from_str&quot;&gt; &lt;code&gt;from_str&lt;/code&gt; &lt;/a&gt;，需要定义一个错误，但是，鉴于始终可以将一个&lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;正确地转换为一个新的&lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; 且&lt;/a&gt;没有错误，因此这种类型实际上不会返回。这样，只有在这里满足所述签名，否则是没有用的。</target>
        </trans-unit>
        <trans-unit id="7bafcd26f5f930140b3a1e3e5a967a8f857b2aca" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is used as the return type for &lt;a href=&quot;../primitive.f32#method.classify&quot;&gt;&lt;code&gt;f32::classify&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.f64#method.classify&quot;&gt;&lt;code&gt;f64::classify&lt;/code&gt;&lt;/a&gt;. See their documentation for more.</source>
          <target state="translated">该 &lt;code&gt;enum&lt;/code&gt; 用作&lt;a href=&quot;../primitive.f32#method.classify&quot;&gt; &lt;code&gt;f32::classify&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../primitive.f64#method.classify&quot;&gt; &lt;code&gt;f64::classify&lt;/code&gt; &lt;/a&gt;的返回类型。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="779a09142baa1b4c0c25a858cbd603a82e00fb14" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;new&lt;/code&gt; function creates a new, empty string. You&amp;rsquo;ll find a &lt;code&gt;new&lt;/code&gt; function on many types, because it&amp;rsquo;s a common name for a function that makes a new value of some kind.</source>
          <target state="translated">此 &lt;code&gt;new&lt;/code&gt; 函数创建一个新的空字符串。您会发现许多类型的 &lt;code&gt;new&lt;/code&gt; 函数，因为它是产生某种新值的函数的通用名称。</target>
        </trans-unit>
        <trans-unit id="87637c77d83fe48f3ea16980edd287161d7c7814" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by &lt;a href=&quot;../struct.binaryheap#method.drain&quot;&gt;&lt;code&gt;BinaryHeap::drain()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="710441e6744b3faabea4c32e6f7f503845ba9cca" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by &lt;a href=&quot;../struct.binaryheap#method.drain_sorted&quot;&gt;&lt;code&gt;BinaryHeap::drain_sorted()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f1beb7abacff5cc6b2aa66c11f692cb37b24895" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by &lt;a href=&quot;../struct.binaryheap#method.into_iter&quot;&gt;&lt;code&gt;BinaryHeap::into_iter()&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19187356eb493c3adfe1d6a3c45949ebe90718ce" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by &lt;a href=&quot;../struct.binaryheap#method.iter&quot;&gt;&lt;code&gt;BinaryHeap::iter()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea9db5c8e782224fe1f85e1a720f71f672146c1f" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by &lt;a href=&quot;../struct.linkedlist#method.iter&quot;&gt;&lt;code&gt;LinkedList::iter()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="365f4e6ab5c3e3c131d4abcf66926cc6d747c3d0" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by &lt;a href=&quot;../struct.linkedlist#method.iter_mut&quot;&gt;&lt;code&gt;LinkedList::iter_mut()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a70b0d26c2b2bbcfc4bcd9397bbda3af835a2c7" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by &lt;a href=&quot;fn.pending&quot;&gt;&lt;code&gt;pending()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0010fa18c26eb3966e8839f207aad6f2ebfdb7b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by &lt;a href=&quot;fn.ready&quot;&gt;&lt;code&gt;ready()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffa5a9dc90635ee7464510b7b23324baed884a35" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by &lt;a href=&quot;struct.cstring#method.into_string&quot;&gt;&lt;code&gt;CString::into_string()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a98a7a0b86bcb3ca3daaeceee9ee6241f18b9ac" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by &lt;a href=&quot;struct.vec#method.drain&quot;&gt;&lt;code&gt;Vec::drain&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc70d905416c075e472dedc5615406f53740db49" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;&lt;code&gt;Iterator::chain&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05ed5bb9307267a5e340c3a66e14a4d93b6b2120" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by &lt;a href=&quot;trait.iterator#method.flat_map&quot;&gt;&lt;code&gt;Iterator::flat_map&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f04b21219d876a2efb53733e31a16e7043a08a65" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt;&lt;code&gt;Iterator::fuse&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b34a5adfa6d1f401a24be7fc9f321c6bf3e63061" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by &lt;a href=&quot;trait.iterator#method.zip&quot;&gt;&lt;code&gt;Iterator::zip&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f5b4ce43667b25dc7c0338aa4a9d348ba82ad8b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../../iter/trait.intoiterator#tymethod.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c15db34b76ad48367be1e50fb80a630f7544ccea" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../../iter/trait.intoiterator#tymethod.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8af255e3f384d8c63465da3dc3dea71b03731e21" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../../iter/trait.intoiterator#tymethod.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04527249225c0957b4a2dad0cb713b606320b989" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../primitive.char#method.escape_debug&quot;&gt;&lt;code&gt;escape_debug&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../primitive.char#method.escape_debug&quot;&gt; &lt;code&gt;escape_debug&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="db12edeeb870acc98aa06b33b39a8bb3d306d517" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../primitive.char#method.escape_default&quot;&gt;&lt;code&gt;escape_default&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;../primitive.char#method.escape_default&quot;&gt; &lt;code&gt;escape_default&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="cc81870e647a4c66d45285572c3d1fa6c0473baa" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../primitive.char#method.escape_unicode&quot;&gt;&lt;code&gt;escape_unicode&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../primitive.char#method.escape_unicode&quot;&gt; &lt;code&gt;escape_unicode&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="1fe84815a63364d86bf9311c9ac78e8bdb20701b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../primitive.char#method.to_lowercase&quot;&gt;&lt;code&gt;to_lowercase&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">此 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../primitive.char#method.to_lowercase&quot;&gt; &lt;code&gt;to_lowercase&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="27eb64d64fc617e07c6f09849f8a1efd113c9e7c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../primitive.char#method.to_uppercase&quot;&gt;&lt;code&gt;to_uppercase&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">此 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;../primitive.char#method.to_uppercase&quot;&gt; &lt;code&gt;to_uppercase&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="23afadfd08d170366a910c9a9eb67a47d53c58e4" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.binaryheap#method.peek_mut&quot;&gt;&lt;code&gt;peek_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.binaryheap&quot;&gt;&lt;code&gt;BinaryHeap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="600939e3b3f6d85fd06ffcedc1a550628427f081" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreemap#method.into_keys&quot;&gt;&lt;code&gt;into_keys&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a19a52d05723c4f0efb8bd5c1f2d68262e4edffd" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreemap#method.into_values&quot;&gt;&lt;code&gt;into_values&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3045bd58f26065df50d0790fb43c60769a4e62d7" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreemap#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="946c012883128ea40231fbdcbdc1a628bae08f1e" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreemap#method.iter_mut&quot;&gt;&lt;code&gt;iter_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74b659096d73f7bbdedbdc8e5c8915fc609d68c8" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreemap#method.keys&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dc938cc7827ae09ff7a33e57fec9dc1ea67e47b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreemap#method.range&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d48ee20f7abe01686d61e8b564a9e2e8709cc261" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreemap#method.range_mut&quot;&gt;&lt;code&gt;range_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a6de9bc6d12983868c379e76acf4b7b905e3489" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreemap#method.values&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d705a35c8c3bfa5da6919c4661f259de8364f195" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreemap#method.values_mut&quot;&gt;&lt;code&gt;values_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61f91f31f3bd872cb2fbd24fadf5b75ed09458a4" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreeset#method.difference&quot;&gt;&lt;code&gt;difference&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e1d52e053b2cbaba0cc8f9612b34ec9509994b9" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreeset#method.intersection&quot;&gt;&lt;code&gt;intersection&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="954e936cd5243200003d839739bf6bf3e1d2ccbf" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreeset#method.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c45f5db49cb3dd47f14e3527ee6323bafd674c6" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreeset#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53de499d6a94e0c9ad1a96537dd61a0c1c130aff" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreeset#method.range&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c55b8ab08d80bad9c8193338715f67b024c7ee2c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreeset#method.symmetric_difference&quot;&gt;&lt;code&gt;symmetric_difference&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34001f1785210d90fc10385cb9a1251eed89d761" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.btreeset#method.union&quot;&gt;&lt;code&gt;union&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6645dd14e44dee8f928de9c50e60665ec2facacc" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashmap#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="305c738458e34e26e1734f78e5058c6e48d5e7b3" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashmap#method.drain_filter&quot;&gt;&lt;code&gt;drain_filter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1bd35d1cd7726da10e33bba8ce8805e4d7d627f" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashmap#method.into_keys&quot;&gt;&lt;code&gt;into_keys&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="774e7d6c5f4fef0d016668cc714ac56903ab5226" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashmap#method.into_values&quot;&gt;&lt;code&gt;into_values&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50fc5746ddfb14a344eb233b7116066c64b4c8c4" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashmap#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a09bcc28d870cda3d50f44865ac154f6c773dbcc" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashmap#method.iter_mut&quot;&gt;&lt;code&gt;iter_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3485f5d7a78d5f8bb97e7e58730359d2b64777f" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashmap#method.keys&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b03cef3dcf96a8183c51975b4910dd74475edf71" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashmap#method.values&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53c20090054cf2ac21ecbfded86e3ada5a3c452b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashmap#method.values_mut&quot;&gt;&lt;code&gt;values_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92667a13f4b88964b565e8c1428280771a1f58ae" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashset#method.difference&quot;&gt;&lt;code&gt;difference&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b53023bc8c2f123d3aa8476357c0065c17e5bc5" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashset#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f3f79e8e523849b31d44d7222fee9b2cd8c8e08" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashset#method.drain_filter&quot;&gt;&lt;code&gt;drain_filter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0c7b733ae497921c7ee1e58f9d3737d0bc5abf0" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashset#method.intersection&quot;&gt;&lt;code&gt;intersection&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7faf396162375db95ee521b7f44471b3dddb5889" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashset#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14c7d030bde45fb3ec268ba764828f4e1837eb77" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashset#method.symmetric_difference&quot;&gt;&lt;code&gt;symmetric_difference&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fce08bc41dc77fbc27830928bbf1bf5b41c36d96" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.hashset#method.union&quot;&gt;&lt;code&gt;union&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="265bcebc25d757509c4b717937ff253a8b8647e5" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.linkedlist#method.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.linkedlist&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae30ff0dcb4ca01b32359edc18207fe2e8799225" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.vecdeque#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0622f000a63c5582f4bf61c6400ba69e79c3e9b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.vecdeque#method.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c39e95770f6e995aeb4f6547fcd0d3b5d042bb7" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.vecdeque#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2950ed2e16c6715dede3635ac1905a727cb8d87" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;../struct.vecdeque#method.iter_mut&quot;&gt;&lt;code&gt;iter_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df020e51f3f4500bc1f8be7714b7e55fb7923be6" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;enum.option#method.into_iter&quot;&gt;&lt;code&gt;Option::into_iter&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;enum.option#method.into_iter&quot;&gt; &lt;code&gt;Option::into_iter&lt;/code&gt; &lt;/a&gt;函数创建。</target>
        </trans-unit>
        <trans-unit id="ed85839c71b9b41d697c086ba092e08ee354cb7a" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;enum.option#method.iter&quot;&gt;&lt;code&gt;Option::iter&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;enum.option#method.iter&quot;&gt; &lt;code&gt;Option::iter&lt;/code&gt; &lt;/a&gt;函数创建。</target>
        </trans-unit>
        <trans-unit id="f832fbc0a1897989e972bccbdf14ab8c06df2a8b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;enum.option#method.iter_mut&quot;&gt;&lt;code&gt;Option::iter_mut&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;enum.option#method.iter_mut&quot;&gt; &lt;code&gt;Option::iter_mut&lt;/code&gt; &lt;/a&gt;函数创建的。</target>
        </trans-unit>
        <trans-unit id="29c33d9d981b66ee3e763795fb7a865338012f4a" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.empty&quot;&gt;&lt;code&gt;empty()&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c09e42d5e7d0d1aee87da5c6a31ae546137c1a" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.empty&quot;&gt;&lt;code&gt;empty&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">此 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;fn.empty&quot;&gt; &lt;code&gt;empty&lt;/code&gt; &lt;/a&gt;函数创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="583b1959fdeeb9dda8ffebe215f3e85158c8bc2e" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.escape_default&quot;&gt;&lt;code&gt;escape_default&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;fn.escape_default&quot;&gt; &lt;code&gt;escape_default&lt;/code&gt; &lt;/a&gt;函数创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="2441b8d854782799a5af16365bc544396e7a30e1" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.from_fn&quot;&gt;&lt;code&gt;iter::from_fn()&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be7c13071482b2c3923f2e736bd014b0019bfa3c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.from_fn&quot;&gt;&lt;code&gt;iter::from_fn&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;fn.from_fn&quot;&gt; &lt;code&gt;iter::from_fn&lt;/code&gt; &lt;/a&gt;函数创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="94d40c5fdbd8b948ffc41faa923b27505f807e3f" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.once&quot;&gt;&lt;code&gt;once()&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2d0d0c848c068f0195f43a41a604e9ed15435ea" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.once&quot;&gt;&lt;code&gt;once&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;fn.once&quot;&gt; &lt;code&gt;once&lt;/code&gt; &lt;/a&gt;函数创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="8bb25d152dad7b00112a30e9ef34eaf19e870657" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.once_with&quot;&gt;&lt;code&gt;once_with()&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="582110272ac53674cd7341259d0b80e92c531007" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.once_with&quot;&gt;&lt;code&gt;once_with&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;fn.once_with&quot;&gt; &lt;code&gt;once_with&lt;/code&gt; &lt;/a&gt;函数创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="c2e53dc5041d32296d06a4432a5dc5ef029bc8fa" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.repeat&quot;&gt;&lt;code&gt;repeat()&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f750c0f224dd89d4b261959a2e6c2e0e53f46764" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.repeat&quot;&gt;&lt;code&gt;repeat&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;fn.repeat&quot;&gt; &lt;code&gt;repeat&lt;/code&gt; &lt;/a&gt;函数创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="66f063558b4204049186f9de5672edf7bb33b08f" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.repeat_with&quot;&gt;&lt;code&gt;repeat_with()&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="937c3c66fd7a919cfaca746517ec0915d37c92b5" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.repeat_with&quot;&gt;&lt;code&gt;repeat_with&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;fn.repeat_with&quot;&gt; &lt;code&gt;repeat_with&lt;/code&gt; &lt;/a&gt;函数创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="aab81d3f94443c5e362d592846bb5f615688f696" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;thread::spawn&lt;/code&gt;&lt;/a&gt; function and the &lt;a href=&quot;struct.builder#method.spawn&quot;&gt;&lt;code&gt;thread::Builder::spawn&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;thread::spawn&lt;/code&gt; &lt;/a&gt;函数和&lt;a href=&quot;struct.builder#method.spawn&quot;&gt; &lt;code&gt;thread::Builder::spawn&lt;/code&gt; &lt;/a&gt;方法创建的。</target>
        </trans-unit>
        <trans-unit id="721e1f5adffa977a66b66d77bbfc4af0a336248f" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.successors&quot;&gt;&lt;code&gt;iter::successors()&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bba3b7b1d3ddee116465f88074412d173b46ad3" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;fn.successors&quot;&gt;&lt;code&gt;successors&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">此 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;fn.successors&quot;&gt; &lt;code&gt;successors&lt;/code&gt; &lt;/a&gt;函数创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="750025df63cee4f9476b600e410c271d4dc26282" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.binaryheap#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.binaryheap&quot;&gt;&lt;code&gt;BinaryHeap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">此 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;struct.binaryheap#method.drain&quot;&gt; &lt;code&gt;drain&lt;/code&gt; &lt;/a&gt;上的方法&lt;a href=&quot;struct.binaryheap&quot;&gt; &lt;code&gt;BinaryHeap&lt;/code&gt; &lt;/a&gt;。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="e18a9e9bb705ac20d27c1b54b01a06909af9f5aa" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.binaryheap#method.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.binaryheap&quot;&gt;&lt;code&gt;BinaryHeap&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="translated">此 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;struct.binaryheap#method.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; &lt;/a&gt;上方法&lt;a href=&quot;struct.binaryheap&quot;&gt; &lt;code&gt;BinaryHeap&lt;/code&gt; &lt;/a&gt;（通过所提供的 &lt;code&gt;IntoIterator&lt;/code&gt; 性状）。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="41506355b29f22e9b8811a8d2b60d92fed5ea6d5" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.binaryheap#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.binaryheap&quot;&gt;&lt;code&gt;BinaryHeap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;struct.binaryheap&quot;&gt; &lt;code&gt;BinaryHeap&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.binaryheap#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="e9675a6cb1b893dbb78e5cb9089bf79a6f234027" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.binaryheap#method.peek_mut&quot;&gt;&lt;code&gt;peek_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.binaryheap&quot;&gt;&lt;code&gt;BinaryHeap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">这种 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;struct.binaryheap#method.peek_mut&quot;&gt; &lt;code&gt;peek_mut&lt;/code&gt; &lt;/a&gt;的方法&lt;a href=&quot;struct.binaryheap&quot;&gt; &lt;code&gt;BinaryHeap&lt;/code&gt; &lt;/a&gt;。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="a3e0e69a8fe926bff3713eb4f60caf8069defb24" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreemap#method.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="translated">此 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;struct.btreemap#method.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; &lt;/a&gt;上方法&lt;a href=&quot;struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt;（通过所提供的 &lt;code&gt;IntoIterator&lt;/code&gt; 性状）。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="514e5b56a0002147cc9f7ac8a43433a6a65225d9" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreemap#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.btreemap#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="f716d42a3e459fcee9b6f36db5dc5c8168d480b5" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreemap#method.iter_mut&quot;&gt;&lt;code&gt;iter_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">这种 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;struct.btreemap#method.iter_mut&quot;&gt; &lt;code&gt;iter_mut&lt;/code&gt; &lt;/a&gt;的方法&lt;a href=&quot;struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt;。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="1f4535b44687ead67d4ff87d0edaec473f93f580" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreemap#method.keys&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.btreemap#method.keys&quot;&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="d31858adce6dfcdec67ca057f391304b96efe373" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreemap#method.range&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.btreemap#method.range&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="beff4242dfe6af7e412bdc0cbf43b9ab3e974e59" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreemap#method.range_mut&quot;&gt;&lt;code&gt;range_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">这种 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;struct.btreemap#method.range_mut&quot;&gt; &lt;code&gt;range_mut&lt;/code&gt; &lt;/a&gt;的方法&lt;a href=&quot;struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt;。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="61ccad7bbc2caef64224c9df6c46da6d30f71236" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreemap#method.values&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">此 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.btreemap#method.values&quot;&gt; &lt;code&gt;values&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="32f656567e75b1c61207668fdcd4fee681fb158f" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreemap#method.values_mut&quot;&gt;&lt;code&gt;values_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreemap&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">这种 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;struct.btreemap#method.values_mut&quot;&gt; &lt;code&gt;values_mut&lt;/code&gt; &lt;/a&gt;的方法&lt;a href=&quot;struct.btreemap&quot;&gt; &lt;code&gt;BTreeMap&lt;/code&gt; &lt;/a&gt;。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="954c25018729177ec5a7cd425af966f38ad45de9" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreeset#method.difference&quot;&gt;&lt;code&gt;difference&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;struct.btreeset&quot;&gt; &lt;code&gt;BTreeSet&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.btreeset#method.difference&quot;&gt; &lt;code&gt;difference&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="311036e0ac34eb0ce755d849d1ee9dcf0da2fa6d" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreeset#method.intersection&quot;&gt;&lt;code&gt;intersection&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;struct.btreeset&quot;&gt; &lt;code&gt;BTreeSet&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.btreeset#method.intersection&quot;&gt; &lt;code&gt;intersection&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="cd64d67da228b8471603fbb0b2df44241b404edf" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreeset#method.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="translated">此 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;struct.btreeset#method.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; &lt;/a&gt;上方法&lt;a href=&quot;struct.btreeset&quot;&gt; &lt;code&gt;BTreeSet&lt;/code&gt; &lt;/a&gt;（通过所提供的 &lt;code&gt;IntoIterator&lt;/code&gt; 性状）。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="b2d51f3eed3f11c0fe92a56c05aa30ba63101b5b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreeset#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;struct.btreeset&quot;&gt; &lt;code&gt;BTreeSet&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.btreeset#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="4952396a08a80db78884e7472ef4fcdc98f30b89" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreeset#method.range&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;struct.btreeset&quot;&gt; &lt;code&gt;BTreeSet&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.btreeset#method.range&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="03065ec43e94189db8db5b6c22bcd04c4d9e3d5f" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreeset#method.symmetric_difference&quot;&gt;&lt;code&gt;symmetric_difference&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;struct.btreeset&quot;&gt; &lt;code&gt;BTreeSet&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.btreeset#method.symmetric_difference&quot;&gt; &lt;code&gt;symmetric_difference&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="06c95a89e54823ffe6dff81406fba47c36a4dc6c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.btreeset#method.union&quot;&gt;&lt;code&gt;union&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.btreeset&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;struct.btreeset&quot;&gt; &lt;code&gt;BTreeSet&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.btreeset#method.union&quot;&gt; &lt;code&gt;union&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="512853e49000d203253875f2ca8249d15ea7353e" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.cstring#method.into_string&quot;&gt;&lt;code&gt;into_string&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.cstring#method.into_string&quot;&gt; &lt;code&gt;into_string&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="faa8b1395fad10dcbfc423094256b61e6d205866" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashmap#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">此 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;struct.hashmap#method.drain&quot;&gt; &lt;code&gt;drain&lt;/code&gt; &lt;/a&gt;上的方法&lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; 中&lt;/a&gt;。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="0800ef408d255e0937c01c82d43d77be20d45343" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashmap#method.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.hashmap#method.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; &lt;/a&gt;方法创建的（由 &lt;code&gt;IntoIterator&lt;/code&gt; 特性提供）。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="0608e2c033c0bbc3bd28c971540c2b970498e946" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashmap#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.hashmap#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="0d3d57080a3c9ea2da73c2cffa1d26e9e4a02705" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashmap#method.iter_mut&quot;&gt;&lt;code&gt;iter_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.hashmap#method.iter_mut&quot;&gt; &lt;code&gt;iter_mut&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="24475378883de5203105dba62856d4abf99e3544" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashmap#method.keys&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.hashmap#method.keys&quot;&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="9d0295f8ffe26eaa9c9d5777a9c742f561e9829a" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashmap#method.values&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.hashmap#method.values&quot;&gt; &lt;code&gt;values&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="29c5ae45f57800a030c9d11a0a477ba58c24833e" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashmap#method.values_mut&quot;&gt;&lt;code&gt;values_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.hashmap#method.values_mut&quot;&gt; &lt;code&gt;values_mut&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="7513d477a389bb5cb5a430e327122b1af796c3fd" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashset#method.difference&quot;&gt;&lt;code&gt;difference&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.hashset#method.difference&quot;&gt; &lt;code&gt;difference&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="86301ec13deb5075922cbd995e23feac257a9d81" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashset#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">此 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;struct.hashset#method.drain&quot;&gt; &lt;code&gt;drain&lt;/code&gt; &lt;/a&gt;上的方法&lt;a href=&quot;struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt;。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="3ebb8dfa5cf525c05fe6f08d21ee543480482796" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashset#method.intersection&quot;&gt;&lt;code&gt;intersection&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.hashset#method.intersection&quot;&gt; &lt;code&gt;intersection&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="b4fe9a5189ce4199be4828187c5779ad99c77194" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashset#method.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.hashset#method.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; &lt;/a&gt;方法创建的（由 &lt;code&gt;IntoIterator&lt;/code&gt; 特性提供）。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="d0c83c37cc0812ff3b4a5b7bded4f379cae37eda" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashset#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.hashset#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="2eb620627c49c8366b81c168c1e2da24ad0ba352" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashset#method.symmetric_difference&quot;&gt;&lt;code&gt;symmetric_difference&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.hashset#method.symmetric_difference&quot;&gt; &lt;code&gt;symmetric_difference&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="150f20ec4e603307925c0aee02dfd449f9a510cf" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.hashset#method.union&quot;&gt;&lt;code&gt;union&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是由&lt;a href=&quot;struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.hashset#method.union&quot;&gt; &lt;code&gt;union&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="2d89966c70887a327798b302de57b322446d731d" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.linkedlist#method.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.linkedlist&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;struct.linkedlist&quot;&gt; &lt;code&gt;LinkedList&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.linkedlist#method.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; &lt;/a&gt;方法创建的（由 &lt;code&gt;IntoIterator&lt;/code&gt; 特性提供）。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="58115891c3a0ac7312c6ea2a52ac61968cc4906c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.linkedlist#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.linkedlist&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;struct.linkedlist&quot;&gt; &lt;code&gt;LinkedList&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.linkedlist#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="f0659eea6bed999fa3680d324080162cd5e8a132" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.linkedlist#method.iter_mut&quot;&gt;&lt;code&gt;iter_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.linkedlist&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;struct.linkedlist&quot;&gt; &lt;code&gt;LinkedList&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.linkedlist#method.iter_mut&quot;&gt; &lt;code&gt;iter_mut&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="0aae0dd86db056d40eff085617d4cf75e5ca4cd1" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.path#method.ancestors&quot;&gt;&lt;code&gt;ancestors&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">此 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.path#method.ancestors&quot;&gt; &lt;code&gt;ancestors&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="678416258ee794f65fdd4a1cd12a337537c5938c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.path#method.components&quot;&gt;&lt;code&gt;components&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.path#method.components&quot;&gt; &lt;code&gt;components&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="f7998e185f302bc549a882f13518743e61ee46ed" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.path#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.path#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="2cd612b3807ec02a5c6d66e1f1c48af60492df83" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.path#method.strip_prefix&quot;&gt;&lt;code&gt;strip_prefix&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.path#method.strip_prefix&quot;&gt; &lt;code&gt;strip_prefix&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="088542ff6ce5390ea17e8720dd59c0a74e6b5452" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.tcplistener#method.incoming&quot;&gt;&lt;code&gt;TcpListener::incoming&lt;/code&gt;&lt;/a&gt; method. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b5816e88e64a2f2821568b7180ce9b608c65d11" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.tcplistener#method.incoming&quot;&gt;&lt;code&gt;incoming&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.tcplistener&quot;&gt;&lt;code&gt;TcpListener&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;struct.tcplistener&quot;&gt; &lt;code&gt;TcpListener&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.tcplistener#method.incoming&quot;&gt; &lt;code&gt;incoming&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="1f4d8367fad76ae04d5e19a5385a27f59c0aaf13" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.vec#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;struct.vec#method.drain&quot;&gt; &lt;code&gt;drain&lt;/code&gt; &lt;/a&gt;上的方法&lt;a href=&quot;struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5f3bc5ceaa1713a6dc6144c9424b5691a097a496" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.vecdeque#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">此 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;struct.vecdeque#method.drain&quot;&gt; &lt;code&gt;drain&lt;/code&gt; &lt;/a&gt;上的方法&lt;a href=&quot;struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt;。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="b345fb68ea41cbf5a17dfb308f9d1a6e9820cc06" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.vecdeque#method.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt; (provided by the &lt;code&gt;IntoIterator&lt;/code&gt; trait). See its documentation for more.</source>
          <target state="translated">此 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;struct.vecdeque#method.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; &lt;/a&gt;上方法&lt;a href=&quot;struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt;（通过所提供的 &lt;code&gt;IntoIterator&lt;/code&gt; 性状）。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="5c15922d5946c2fdadf8c55e5b28d91817f56274" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.vecdeque#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.vecdeque#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="6dcf16ee1a7554354a5a44529cc2c194dcf3a513" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;struct.vecdeque#method.iter_mut&quot;&gt;&lt;code&gt;iter_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">这种 &lt;code&gt;struct&lt;/code&gt; 是由创建&lt;a href=&quot;struct.vecdeque#method.iter_mut&quot;&gt; &lt;code&gt;iter_mut&lt;/code&gt; &lt;/a&gt;的方法&lt;a href=&quot;struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt;。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="c378dde9d0a6525bd047bdf905231180a99f3491" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;&lt;code&gt;chain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;trait.iterator#method.chain&quot;&gt; &lt;code&gt;chain&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="b7e65fcf3ce565260fcf0013397e867c30f8522f" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.cloned&quot;&gt;&lt;code&gt;cloned&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;trait.iterator#method.cloned&quot;&gt; &lt;code&gt;cloned&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="f5b898ca8f830f2683dbb470bc2669fdcc151557" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.copied&quot;&gt;&lt;code&gt;copied&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;trait.iterator#method.copied&quot;&gt; &lt;code&gt;copied&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="6792715370c3a92e84d28374f5832cff5986bd03" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.cycle&quot;&gt;&lt;code&gt;cycle&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;trait.iterator#method.cycle&quot;&gt; &lt;code&gt;cycle&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="eef34875ae92021a31b6bedf0e5ef3ef03a55346" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.enumerate&quot;&gt;&lt;code&gt;enumerate&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;trait.iterator#method.enumerate&quot;&gt; &lt;code&gt;enumerate&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="9fb0d2f619194cb6fd2c5912cd0ab4f8aa1436b0" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;trait.iterator#method.filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="7b10e5f9bf83042ee3e1d8a41324ee574deb204c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.filter_map&quot;&gt;&lt;code&gt;filter_map&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;trait.iterator#method.filter_map&quot;&gt; &lt;code&gt;filter_map&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="e8efe5c2b3a46412d14b079c4efde7503ec17047" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.flat_map&quot;&gt;&lt;code&gt;flat_map&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;trait.iterator#method.flat_map&quot;&gt; &lt;code&gt;flat_map&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="06ac94503cae6df0f4ea2938d28112afa01fe8f9" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.flatten&quot;&gt;&lt;code&gt;flatten&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;trait.iterator#method.flatten&quot;&gt; &lt;code&gt;flatten&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="b8c0c8898fdf0a69bb894be3b262576aa94693ed" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt;&lt;code&gt;fuse&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;trait.iterator#method.fuse&quot;&gt; &lt;code&gt;fuse&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="16538eabad39936ba061176498ea306e212f6f92" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.inspect&quot;&gt;&lt;code&gt;inspect&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;trait.iterator#method.inspect&quot;&gt; &lt;code&gt;inspect&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="a0b5389b001bb0bbe98e28bcb36e5aebd8a66723" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;trait.iterator#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="b50dc251fa4cf84989ab18f9a900ba7288f0b114" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.map_while&quot;&gt;&lt;code&gt;map_while&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a63b8c96bdf4e631228dfff76c51a72895aa1c2" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.peekable&quot;&gt;&lt;code&gt;peekable&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;trait.iterator#method.peekable&quot;&gt; &lt;code&gt;peekable&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="77b9d3dc967cfc65e7923a1d25d998d0359bf8da" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.rev&quot;&gt;&lt;code&gt;rev&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;trait.iterator#method.rev&quot;&gt; &lt;code&gt;rev&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="0c534d67b85da417a0620daeb199532327c51e03" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.scan&quot;&gt;&lt;code&gt;scan&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;trait.iterator#method.scan&quot;&gt; &lt;code&gt;scan&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="d55ea7e68cc78050a3929f56a9674ef3cbe9031c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.skip&quot;&gt;&lt;code&gt;skip&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;trait.iterator#method.skip&quot;&gt; &lt;code&gt;skip&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="752b3b9ee442b1ede4f01e7280612ee155b893b6" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.skip_while&quot;&gt;&lt;code&gt;skip_while&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;trait.iterator#method.skip_while&quot;&gt; &lt;code&gt;skip_while&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="e4194d8e81f0d479a0971b522dc10170de8177ce" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.step_by&quot;&gt;&lt;code&gt;step_by&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;trait.iterator#method.step_by&quot;&gt; &lt;code&gt;step_by&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="ae2f32a2383fa23779c3295dfc6285ad6be64c98" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;trait.iterator#method.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="431a8793b970c81fcc0ab5b7d979a63311ac642a" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.take_while&quot;&gt;&lt;code&gt;take_while&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 由&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;trait.iterator#method.take_while&quot;&gt; &lt;code&gt;take_while&lt;/code&gt; &lt;/a&gt;方法创建。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="f6420f53e024dcbfd568efb25b94839f7a579e39" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;a href=&quot;trait.iterator#method.zip&quot;&gt;&lt;code&gt;zip&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;trait.iterator#method.zip&quot;&gt; &lt;code&gt;zip&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="8be96a57f8e063c35aa0cfee79161d9fbe1f4027" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is created by the &lt;code&gt;into_iter&lt;/code&gt; method on &lt;a href=&quot;struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; (provided by the &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; trait).</source>
          <target state="translated">此 &lt;code&gt;struct&lt;/code&gt; 是通过&lt;a href=&quot;struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt;上的 &lt;code&gt;into_iter&lt;/code&gt; 方法创建的（由&lt;a href=&quot;../iter/trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt;特性提供）。</target>
        </trans-unit>
        <trans-unit id="75da1f33c5a1b29ca9ce3084de81aca63a2c8c06" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;struct&lt;/code&gt; is used to represent the exit status of a child process. Child processes are created via the &lt;a href=&quot;struct.command&quot;&gt;&lt;code&gt;Command&lt;/code&gt;&lt;/a&gt; struct and their exit status is exposed through the &lt;a href=&quot;struct.command#method.status&quot;&gt;&lt;code&gt;status&lt;/code&gt;&lt;/a&gt; method, or the &lt;a href=&quot;struct.child#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; method of a &lt;a href=&quot;struct.child&quot;&gt;&lt;code&gt;Child&lt;/code&gt;&lt;/a&gt; process.</source>
          <target state="translated">该 &lt;code&gt;struct&lt;/code&gt; 用于表示子进程的退出状态。子进程是通过&lt;a href=&quot;struct.command&quot;&gt; &lt;code&gt;Command&lt;/code&gt; &lt;/a&gt;结构创建的，其退出状态通过&lt;a href=&quot;struct.command#method.status&quot;&gt; &lt;code&gt;status&lt;/code&gt; &lt;/a&gt;方法或&lt;a href=&quot;struct.child&quot;&gt; &lt;code&gt;Child&lt;/code&gt; &lt;/a&gt;进程的&lt;a href=&quot;struct.child#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;方法公开。</target>
        </trans-unit>
        <trans-unit id="5f5bb1decbaa26846cd44955c2f8ab7127199a37" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;use&lt;/code&gt; statement brings all public items defined in &lt;code&gt;std::collections&lt;/code&gt; into the current scope. Be careful when using the glob operator! Glob can make it harder to tell what names are in scope and where a name used in your program was defined.</source>
          <target state="translated">该 &lt;code&gt;use&lt;/code&gt; 语句将 &lt;code&gt;std::collections&lt;/code&gt; 定义的所有公共项带入当前范围。使用glob运算符时要小心！Glob使得更难分辨作用域中的名称以及程序中使用的名称的定义位置。</target>
        </trans-unit>
        <trans-unit id="caecafb5a4fb0937d47c4a448338d709acd25fe7" translate="yes" xml:space="preserve">
          <source>This &lt;strong&gt;channel&lt;/strong&gt; is currently empty, but the &lt;strong&gt;Sender&lt;/strong&gt;(s) have not yet disconnected, so data may yet become available.</source>
          <target state="translated">该&lt;strong&gt;通道&lt;/strong&gt;当前为空，但&lt;strong&gt;发件人&lt;/strong&gt;尚未断开连接，因此数据可能仍可用。</target>
        </trans-unit>
        <trans-unit id="8266d9d9a47bf63d7284fb3019e831be816c08a4" translate="yes" xml:space="preserve">
          <source>This Greek letter convention is usually just employed when the presence of a sequence is a technical detail; in particular, when we wish to &lt;em&gt;emphasize&lt;/em&gt; that we are operating on a sequence of token-trees, we will use the notation &quot;tt ...&quot; for the sequence, not a Greek letter.</source>
          <target state="translated">当序列的存在是技术细节时，通常只使用希腊字母约定。特别是，当我们希望&lt;em&gt;强调&lt;/em&gt;我们正在对令牌树序列进行操作时，我们将对该序列使用符号&amp;ldquo; tt ...&amp;rdquo;，而不是希腊字母。</target>
        </trans-unit>
        <trans-unit id="75b75d5ae6c1390e9d9181dd6cf33a8dbc7fda14" translate="yes" xml:space="preserve">
          <source>This alias exists for backwards compatibility, and may be eventually deprecated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b20bc4e00b7823d1d79ae42b369f4aec802629c" translate="yes" xml:space="preserve">
          <source>This allows a program to terminate immediately and provide feedback to the caller of the program. &lt;code&gt;panic!&lt;/code&gt; should be used when a program reaches an unrecoverable state.</source>
          <target state="translated">这允许程序立即终止并向程序调用者提供反馈。 &lt;code&gt;panic!&lt;/code&gt; 当程序达到不可恢复的状态时应使用。</target>
        </trans-unit>
        <trans-unit id="720612fc48419da4fea633357e945fe3ab75a62a" translate="yes" xml:space="preserve">
          <source>This allows creating a custom iterator with any behavior without using the more verbose syntax of creating a dedicated type and implementing the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; trait for it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8257259a712f5169c7b4c3c0a8b238e35c31bcfe" translate="yes" xml:space="preserve">
          <source>This allows creating a custom iterator with any behavior without using the more verbose syntax of creating a dedicated type and implementing the &lt;code&gt;Iterator&lt;/code&gt; trait for it.</source>
          <target state="translated">这允许创建具有任何行为的自定义迭代器，而无需使用更冗长的语法来创建专用类型并为其实现 &lt;code&gt;Iterator&lt;/code&gt; 特征。</target>
        </trans-unit>
        <trans-unit id="df65a862360a6e0bd203ebc75d215550a55a7ec8" translate="yes" xml:space="preserve">
          <source>This allows the value to be dropped again.</source>
          <target state="translated">这样就可以再次放弃该值。</target>
        </trans-unit>
        <trans-unit id="6f7c82b24f94be6c3280942f62546df8a8a85985" translate="yes" xml:space="preserve">
          <source>This allows writing a projection that creates a &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt;, thus witnessing that the field is pinned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e583956f9df46a2ff992eeadbf1d346839209a48" translate="yes" xml:space="preserve">
          <source>This allows writing a projection that creates a &lt;code&gt;Pin&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt;, thus witnessing that the field is pinned:</source>
          <target state="translated">这允许编写一个创建 &lt;code&gt;Pin&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; 的投影，从而见证该字段已固定：</target>
        </trans-unit>
        <trans-unit id="9ed737638d9ae3e5d76efaebf6336aa8e810e97d" translate="yes" xml:space="preserve">
          <source>This allows your code to type-check, which is useful if you are prototyping or implementing a trait that requires multiple methods which you don't plan of using all of.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d056f20cad4a501761c404be3055779184b1614f" translate="yes" xml:space="preserve">
          <source>This also in turn requires the annotation &lt;code&gt;T: 'a&lt;/code&gt;, indicating that any references in &lt;code&gt;T&lt;/code&gt; are valid over the lifetime &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="translated">这反过来又需要注释 &lt;code&gt;T: 'a&lt;/code&gt; ，指示 &lt;code&gt;T&lt;/code&gt; 中的所有引用在整个生命周期内都是有效 &lt;code&gt;'a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60e1ada09db527973a7bebfb74dc7b9bbc576185" translate="yes" xml:space="preserve">
          <source>This also means that all resources such as file descriptors and memory-mapped regions got duplicated. It is your responsibility to make sure that the closure does not violate library invariants by making invalid use of these duplicates.</source>
          <target state="translated">这也意味着所有资源,如文件描述符和内存映射区域都被复制了。你有责任确保闭包不会因为无效使用这些重复的资源而违反库的不变性。</target>
        </trans-unit>
        <trans-unit id="c5dab5f83abd965944fb4f235779eceb37146b12" translate="yes" xml:space="preserve">
          <source>This and &lt;a href=&quot;../macro.println&quot;&gt;&lt;code&gt;println!&lt;/code&gt;&lt;/a&gt; emit their output to stdout. Similarly to the &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt; macro, the goal of these macros is to avoid intermediate allocations when printing output. Example usage is:</source>
          <target state="translated">这和&lt;a href=&quot;../macro.println&quot;&gt; &lt;code&gt;println!&lt;/code&gt; &lt;/a&gt;将其输出发送到stdout。类似于&lt;a href=&quot;../macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt;宏，这些宏的目标是避免在打印输出时进行中间分配。用法示例是：</target>
        </trans-unit>
        <trans-unit id="acaf201fd6cc02b279b5987151a707c144a7e5c9" translate="yes" xml:space="preserve">
          <source>This and &lt;a href=&quot;../macro.writeln&quot;&gt;&lt;code&gt;writeln!&lt;/code&gt;&lt;/a&gt; are two macros which are used to emit the format string to a specified stream. This is used to prevent intermediate allocations of format strings and instead directly write the output. Under the hood, this function is actually invoking the &lt;a href=&quot;../io/trait.write#method.write_fmt&quot;&gt;&lt;code&gt;write_fmt&lt;/code&gt;&lt;/a&gt; function defined on the &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;std::io::Write&lt;/code&gt;&lt;/a&gt; trait. Example usage is:</source>
          <target state="translated">这和&lt;a href=&quot;../macro.writeln&quot;&gt; &lt;code&gt;writeln!&lt;/code&gt; &lt;/a&gt;有两个宏，用于将格式字符串发送到指定的流。这用于防止格式字符串的中间分配，而是直接写入输出。在&lt;a href=&quot;../io/trait.write#method.write_fmt&quot;&gt; &lt;code&gt;write_fmt&lt;/code&gt; &lt;/a&gt;，此函数实际上是调用在&lt;a href=&quot;../io/trait.write&quot;&gt; &lt;code&gt;std::io::Write&lt;/code&gt; &lt;/a&gt;特征上定义的write_fmt函数。用法示例是：</target>
        </trans-unit>
        <trans-unit id="7dd14a6dd33e863c7c3a9afcbc1b94db44474940" translate="yes" xml:space="preserve">
          <source>This appendix contains a glossary of Rust&amp;rsquo;s syntax, including operators and other symbols that appear by themselves or in the context of paths, generics, trait bounds, macros, attributes, comments, tuples, and brackets.</source>
          <target state="translated">本附录包含Rust语法的词汇表，包括单独出现或在路径，泛型，特征范围，宏，属性，注释，元组和括号内出现的运算符和其他符号。</target>
        </trans-unit>
        <trans-unit id="98f7d37c50386fc1a7bc45c602df60e2a6b2f88d" translate="yes" xml:space="preserve">
          <source>This appendix is about how Rust is made and how that affects you as a Rust developer.</source>
          <target state="translated">这个附录是关于Rust是如何制作的,以及如何影响你作为一个Rust开发者。</target>
        </trans-unit>
        <trans-unit id="0a5a5ca6ad8b433739f4a95c725e50e77d092d65" translate="yes" xml:space="preserve">
          <source>This applies even if the result of this method is unused!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b1ddafbbcba87aafd5e8ce9688cb9d0214c48d2" translate="yes" xml:space="preserve">
          <source>This applies even if the result of this method is unused! (The part about being initialized is not yet fully decided, but until it is, the only safe approach is to ensure that they are indeed initialized.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf4d5070c48104546a550c9a051a5f05bc584068" translate="yes" xml:space="preserve">
          <source>This associated type corresponds to the &lt;code&gt;yield&lt;/code&gt; expression and the values which are allowed to be returned each time a generator yields. For example an iterator-as-a-generator would likely have this type as &lt;code&gt;T&lt;/code&gt;, the type being iterated over.</source>
          <target state="translated">这种关联的类型对应于 &lt;code&gt;yield&lt;/code&gt; 表达式和每次生成器yield时允许返回的值。例如，作为迭代器的迭代器可能将这种类型作为 &lt;code&gt;T&lt;/code&gt; 进行迭代。</target>
        </trans-unit>
        <trans-unit id="fe55ae487fde4fa4dff7b2d6d6cdbe76cfbf6518" translate="yes" xml:space="preserve">
          <source>This attribute allows configuring the choice of global allocator. You can use this to implement a completely custom global allocator to route all default allocation requests to a custom object.</source>
          <target state="translated">这个属性允许配置全局分配器的选择。你可以用它来实现一个完全自定义的全局分配器,将所有的默认分配请求路由到一个自定义对象。</target>
        </trans-unit>
        <trans-unit id="ef26e5c3cab23c11bb733ef68934315ad78b85fb" translate="yes" xml:space="preserve">
          <source>This avoids reallocating where possible, but the conditions for that are strict, and subject to change, and so shouldn't be relied upon unless the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; came from &lt;code&gt;From&amp;lt;VecDeque&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; and hasn't been reallocated.</source>
          <target state="translated">这样可以避免在可能的情况下进行重新分配，但是这样做的条件很严格，并且随时可能更改，因此除非 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 来自 &lt;code&gt;From&amp;lt;VecDeque&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 并且没有进行重新分配，否则不应该依赖它。</target>
        </trans-unit>
        <trans-unit id="83aca27198b7bcda96ac6aa2d82d76c078c81a23" translate="yes" xml:space="preserve">
          <source>This behavior is no longer valid in edition 2018.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c09355cbc8b51304e7c4f53224a50044b1a70814" translate="yes" xml:space="preserve">
          <source>This book also does not serve as a reference to the &lt;a href=&quot;../std/index&quot;&gt;standard library&lt;/a&gt; included in the language distribution. Those libraries are documented separately by extracting documentation attributes from their source code. Many of the features that one might expect to be language features are library features in Rust, so what you're looking for may be there, not here.</source>
          <target state="translated">本书也不用作语言分发中包含的&lt;a href=&quot;../std/index&quot;&gt;标准库&lt;/a&gt;的参考。通过从源代码中提取文档属性来分别记录这些库。Rust的库功能可能是人们可能希望成为语言功能的许多功能，因此您所需要的可能不在这里。</target>
        </trans-unit>
        <trans-unit id="8e20080fb8e1699ed580bf1c766151d2b69a59c9" translate="yes" xml:space="preserve">
          <source>This book also only serves as a reference to what is available in stable Rust. For unstable features being worked on, see the &lt;a href=&quot;https://doc.rust-lang.org/nightly/unstable-book/index.html&quot;&gt;Unstable Book&lt;/a&gt;.</source>
          <target state="translated">本书还仅作为稳定Rust中可用的参考。有关正在处理的不稳定功能，请参见&lt;a href=&quot;https://doc.rust-lang.org/nightly/unstable-book/index.html&quot;&gt;不稳定书&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="32b7e021bdc132a2756c978c8a1d27d9e8d25d04" translate="yes" xml:space="preserve">
          <source>This book assumes that you&amp;rsquo;ve written code in another programming language but doesn&amp;rsquo;t make any assumptions about which one. We&amp;rsquo;ve tried to make the material broadly accessible to those from a wide variety of programming backgrounds. We don&amp;rsquo;t spend a lot of time talking about what programming &lt;em&gt;is&lt;/em&gt; or how to think about it. If you&amp;rsquo;re entirely new to programming, you would be better served by reading a book that specifically provides an introduction to programming.</source>
          <target state="translated">本书假定您已经用另一种编程语言编写了代码，但是没有对哪种编程语言做任何假设。我们已尝试使各种编程背景的人员都可以广泛使用该材料。我们不会花很多时间来谈论什么编程&lt;em&gt;是&lt;/em&gt;或如何去想它。如果您是编程的新手，那么最好阅读一本专门介绍编程的书，为您提供更好的服务。</target>
        </trans-unit>
        <trans-unit id="fb8d9819998123cf06ddd8f5a1ff9953b5c7298e" translate="yes" xml:space="preserve">
          <source>This book does not assume you are reading this book sequentially. Each chapter generally can be read standalone, but will cross-link to other chapters for facets of the language they refer to, but do not discuss.</source>
          <target state="translated">本书不假设你是按顺序阅读本书。每一章一般都可以单独阅读,但会与其他章节交叉链接,以了解它们所提及但不讨论的语言方面。</target>
        </trans-unit>
        <trans-unit id="74d346bfc5c0837e4df013dba9f47fd4b57ffe9b" translate="yes" xml:space="preserve">
          <source>This book does not serve as an introduction to the language. Background familiarity with the language is assumed. A separate &lt;a href=&quot;../index&quot;&gt;book&lt;/a&gt; is available to help acquire such background familiarity.</source>
          <target state="translated">本书不作为该语言的简介。假定对语言有背景知识。另有&lt;a href=&quot;../index&quot;&gt;一本书&lt;/a&gt;可帮助您获得这种背景知识。</target>
        </trans-unit>
        <trans-unit id="4589512ba2ae3140ba2d5cf22da84c708acf0a3c" translate="yes" xml:space="preserve">
          <source>This book fully embraces the potential of Rust to empower its users. It&amp;rsquo;s a friendly and approachable text intended to help you level up not just your knowledge of Rust, but also your reach and confidence as a programmer in general. So dive in, get ready to learn&amp;mdash;and welcome to the Rust community!</source>
          <target state="translated">本书充分体现了Rust增强用户能力的潜力。这是一种友好且易于理解的文本，旨在帮助您不仅提高对Rust的知识，而且还可以提高您作为程序员的影响力和信心。因此，深入学习，准备学习吧，欢迎加入Rust社区！</target>
        </trans-unit>
        <trans-unit id="5eac84b162d067e7c7224575575cec18251ae81c" translate="yes" xml:space="preserve">
          <source>This book is the primary reference for the Rust programming language. It provides three kinds of material:</source>
          <target state="translated">本书是Rust编程语言的主要参考书。它提供了三种材料。</target>
        </trans-unit>
        <trans-unit id="4dac54ff1b6d498bb0e5ad5ca44a29d6b2c3c87b" translate="yes" xml:space="preserve">
          <source>This book only contains information about stable features, as in-progress features are still changing, and surely they&amp;rsquo;ll be different between when this book was written and when they get enabled in stable builds. You can find documentation for nightly-only features online.</source>
          <target state="translated">本书仅包含有关稳定功能的信息，因为正在开发的功能仍在变化，并且在本书撰写时和在稳定版本中启用它们之间，肯定会有所不同。您可以在线查找仅夜间功能的文档。</target>
        </trans-unit>
        <trans-unit id="9b40452b3457baf6eb9c9eb4c95b596dc78a3493" translate="yes" xml:space="preserve">
          <source>This broken invariant is then later observed.</source>
          <target state="translated">这个破除的不变性后来被观察到了。</target>
        </trans-unit>
        <trans-unit id="626674212943f16d78b9c64b216d4813683d4bcd" translate="yes" xml:space="preserve">
          <source>This buffer is always stored on the heap.</source>
          <target state="translated">这个缓冲区总是存储在堆上。</target>
        </trans-unit>
        <trans-unit id="533f834501c9981cf01926064551726140f691d1" translate="yes" xml:space="preserve">
          <source>This builder also supports platform-specific options.</source>
          <target state="translated">该构建器还支持特定平台的选项。</target>
        </trans-unit>
        <trans-unit id="828127de31395e4a312b7fc3b3384b3f2a31aa51" translate="yes" xml:space="preserve">
          <source>This builder exposes the ability to configure how a &lt;a href=&quot;struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; is opened and what operations are permitted on the open file. The &lt;a href=&quot;struct.file#method.open&quot;&gt;&lt;code&gt;File::open&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.file#method.create&quot;&gt;&lt;code&gt;File::create&lt;/code&gt;&lt;/a&gt; methods are aliases for commonly used options using this builder.</source>
          <target state="translated">此构建器提供了配置&lt;a href=&quot;struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt;方式以及打开文件所允许的操作的能力。该&lt;a href=&quot;struct.file#method.open&quot;&gt; &lt;code&gt;File::open&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;struct.file#method.create&quot;&gt; &lt;code&gt;File::create&lt;/code&gt; &lt;/a&gt;方法是使用该生成器常用选项的别名。</target>
        </trans-unit>
        <trans-unit id="e3a75e262b3ddd48064e08eaf81396d4af4ef1e5" translate="yes" xml:space="preserve">
          <source>This call borrows &lt;code&gt;Cell&lt;/code&gt; mutably (at compile-time) which guarantees that we possess the only reference.</source>
          <target state="translated">此调用是可变地借用 &lt;code&gt;Cell&lt;/code&gt; 的（在编译时），这保证了我们拥有唯一的引用。</target>
        </trans-unit>
        <trans-unit id="5a4e17ce4bfa3ac12c6fb727cdafac307c2e7b00" translate="yes" xml:space="preserve">
          <source>This call borrows &lt;code&gt;RefCell&lt;/code&gt; mutably (at compile-time) so there is no need for dynamic checks.</source>
          <target state="translated">此调用 &lt;code&gt;RefCell&lt;/code&gt; 借用RefCell（在编译时），因此不需要动态检查。</target>
        </trans-unit>
        <trans-unit id="6f04390b2a6147633d5eca54b6b75468f6c87ab6" translate="yes" xml:space="preserve">
          <source>This call borrows the &lt;code&gt;UnsafeCell&lt;/code&gt; mutably (at compile-time) which guarantees that we possess the only reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07dea4d9325843f5f46d2875aa2d7fc09a6140cf" translate="yes" xml:space="preserve">
          <source>This call is similar to &lt;a href=&quot;#method.get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt; but more specialized. It borrows &lt;code&gt;RefCell&lt;/code&gt; mutably to ensure no borrows exist and then resets the state tracking shared borrows. This is relevant if some &lt;code&gt;Ref&lt;/code&gt; or &lt;code&gt;RefMut&lt;/code&gt; borrows have been leaked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bafb9cba9c70e76a1a3bb46e83a3fb5e4a1e4a73" translate="yes" xml:space="preserve">
          <source>This can also be thought of as the fallible form of &lt;a href=&quot;#method.for_each&quot;&gt;&lt;code&gt;for_each()&lt;/code&gt;&lt;/a&gt; or as the stateless version of &lt;a href=&quot;#method.try_fold&quot;&gt;&lt;code&gt;try_fold()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">也可以将其视为&lt;a href=&quot;#method.for_each&quot;&gt; &lt;code&gt;for_each()&lt;/code&gt; &lt;/a&gt;的错误形式或&lt;a href=&quot;#method.try_fold&quot;&gt; &lt;code&gt;try_fold()&lt;/code&gt; &lt;/a&gt;的无状态版本。</target>
        </trans-unit>
        <trans-unit id="561a3555fef68cbba4ae35243cef025c7f810a34" translate="yes" xml:space="preserve">
          <source>This can also be thought of as the fallible form of &lt;a href=&quot;trait.iterator#method.for_each&quot;&gt;&lt;code&gt;for_each()&lt;/code&gt;&lt;/a&gt; or as the stateless version of &lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;try_fold()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc5e7768aa508543b82b361f251df561c08e6d32" translate="yes" xml:space="preserve">
          <source>This can also be used in multithreaded applications, in order to send a message to other threads warning that a thread has panicked (e.g., for monitoring purposes).</source>
          <target state="translated">这也可以在多线程应用程序中使用,以便向其他线程发送消息,警告某个线程已经恐慌(例如,出于监控目的)。</target>
        </trans-unit>
        <trans-unit id="3ff7f3a5aeb76318844d8c8fdfdc79fcab462b99" translate="yes" xml:space="preserve">
          <source>This can also happen when using a type implementing &lt;code&gt;Fn&lt;/code&gt; or &lt;code&gt;FnMut&lt;/code&gt;, as neither allows moving out of them (they usually represent closures which can be called more than once). Much of the text following applies equally well to non-&lt;code&gt;FnOnce&lt;/code&gt; closure bodies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="115ef26a79f6ceeca6376e7547342f4fb025dc8d" translate="yes" xml:space="preserve">
          <source>This can be cast to a pointer of any kind. Ensure that the access is unique (no active references, mutable or not) when casting to &lt;code&gt;&amp;amp;mut T&lt;/code&gt;, and ensure that there are no mutations or mutable aliases going on when casting to &lt;code&gt;&amp;amp;T&lt;/code&gt;</source>
          <target state="translated">可以将其强制转换为任何类型的指针。强制转换为 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 时，确保访问是唯一的（无活动引用，是否可变），并确保转换为 &lt;code&gt;&amp;amp;T&lt;/code&gt; 时没有发生任何突变或可变别名。</target>
        </trans-unit>
        <trans-unit id="214edc09ead3c27edfef862878240910ed92a93e" translate="yes" xml:space="preserve">
          <source>This can be constructed by the &lt;a href=&quot;struct.formatter#method.debug_list&quot;&gt;&lt;code&gt;Formatter::debug_list&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">这可以通过&lt;a href=&quot;struct.formatter#method.debug_list&quot;&gt; &lt;code&gt;Formatter::debug_list&lt;/code&gt; &lt;/a&gt;方法构造。</target>
        </trans-unit>
        <trans-unit id="c7514961910752b90460d88f227b5817215d7f6e" translate="yes" xml:space="preserve">
          <source>This can be constructed by the &lt;a href=&quot;struct.formatter#method.debug_map&quot;&gt;&lt;code&gt;Formatter::debug_map&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">这可以通过&lt;a href=&quot;struct.formatter#method.debug_map&quot;&gt; &lt;code&gt;Formatter::debug_map&lt;/code&gt; &lt;/a&gt;方法构造。</target>
        </trans-unit>
        <trans-unit id="db45b1697100bb4357e93b4848fb22d93091bccd" translate="yes" xml:space="preserve">
          <source>This can be constructed by the &lt;a href=&quot;struct.formatter#method.debug_set&quot;&gt;&lt;code&gt;Formatter::debug_set&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">这可以通过&lt;a href=&quot;struct.formatter#method.debug_set&quot;&gt; &lt;code&gt;Formatter::debug_set&lt;/code&gt; &lt;/a&gt;方法构造。</target>
        </trans-unit>
        <trans-unit id="efbf03337e671dc0f2d75f1c2d72ed7746b99e34" translate="yes" xml:space="preserve">
          <source>This can be constructed by the &lt;a href=&quot;struct.formatter#method.debug_struct&quot;&gt;&lt;code&gt;Formatter::debug_struct&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">这可以通过&lt;a href=&quot;struct.formatter#method.debug_struct&quot;&gt; &lt;code&gt;Formatter::debug_struct&lt;/code&gt; &lt;/a&gt;方法构造。</target>
        </trans-unit>
        <trans-unit id="daed88198496b5861ca72aa01db8f1e07a7a1fbc" translate="yes" xml:space="preserve">
          <source>This can be constructed by the &lt;a href=&quot;struct.formatter#method.debug_tuple&quot;&gt;&lt;code&gt;Formatter::debug_tuple&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">这可以通过&lt;a href=&quot;struct.formatter#method.debug_tuple&quot;&gt; &lt;code&gt;Formatter::debug_tuple&lt;/code&gt; &lt;/a&gt;方法构造。</target>
        </trans-unit>
        <trans-unit id="f00711c55f275b9886eb0ce781693c9e5c9caed4" translate="yes" xml:space="preserve">
          <source>This can be resolved by changing the type annotation or removing it entirely if it can be inferred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21c003ed23b457ffebe1b7112c3e64636889beae" translate="yes" xml:space="preserve">
          <source>This can be used to avoid allocations in the most trivial case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2479ae89d6780ca289ef37404c0461658bc53872" translate="yes" xml:space="preserve">
          <source>This can be used to compare &lt;code&gt;&amp;amp;T&lt;/code&gt; references (which coerce to &lt;code&gt;*const T&lt;/code&gt; implicitly) by their address rather than comparing the values they point to (which is what the &lt;code&gt;PartialEq for &amp;amp;T&lt;/code&gt; implementation does).</source>
          <target state="translated">这可用于按地址比较 &lt;code&gt;&amp;amp;T&lt;/code&gt; 引用（隐式强制为 &lt;code&gt;*const T&lt;/code&gt; ），而不是比较它们指向的值（这是 &lt;code&gt;PartialEq for &amp;amp;T&lt;/code&gt; 实现的PartialEq所做的事情）。</target>
        </trans-unit>
        <trans-unit id="b3720c96ba6b1476408a923be1876044bc567298" translate="yes" xml:space="preserve">
          <source>This can be used to compare enums that carry data, while disregarding the actual data:</source>
          <target state="translated">这可以用来比较携带数据的枚举,而不考虑实际数据。</target>
        </trans-unit>
        <trans-unit id="27925db5758baea8a7b4ada29852f78f4d3d7a94" translate="yes" xml:space="preserve">
          <source>This can be used to handle errors that would otherwise only be caught when the &lt;code&gt;File&lt;/code&gt; is closed. Dropping a file will ignore errors in synchronizing this in-memory data.</source>
          <target state="translated">这可用于处理错误，否则这些错误仅在 &lt;code&gt;File&lt;/code&gt; 关闭时才会被捕获。删除文件将忽略同步此内存中数据的错误。</target>
        </trans-unit>
        <trans-unit id="9856559b29a29e0f25c3e61f2c093f50c7905e19" translate="yes" xml:space="preserve">
          <source>This can be used to hash a &lt;code&gt;&amp;amp;T&lt;/code&gt; reference (which coerces to &lt;code&gt;*const T&lt;/code&gt; implicitly) by its address rather than the value it points to (which is what the &lt;code&gt;Hash for &amp;amp;T&lt;/code&gt; implementation does).</source>
          <target state="translated">这可用于通过其地址而不是其指向的值（这是 &lt;code&gt;Hash for &amp;amp;T&lt;/code&gt; 实现的作用）对 &lt;code&gt;&amp;amp;T&lt;/code&gt; 参考（隐式强制为 &lt;code&gt;*const T&lt;/code&gt; ）进行哈希处理。</target>
        </trans-unit>
        <trans-unit id="13a7b507773148ef054095424c9d9ac4d8251d3e" translate="yes" xml:space="preserve">
          <source>This can be used to safely get a strong reference (by calling &lt;a href=&quot;struct.weak#method.upgrade&quot;&gt;&lt;code&gt;upgrade&lt;/code&gt;&lt;/a&gt; later) or to deallocate the weak count by dropping the &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">这可用于安全地获得强引用（稍后调用&lt;a href=&quot;struct.weak#method.upgrade&quot;&gt; &lt;code&gt;upgrade&lt;/code&gt; &lt;/a&gt;）或通过删除 &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; 来释放弱计数。</target>
        </trans-unit>
        <trans-unit id="fb4c5fc4f14344c508855aa0c67808589d2ea5df" translate="yes" xml:space="preserve">
          <source>This can be useful if you are prototyping and are just looking to have your code type-check, or if you're implementing a trait that requires multiple methods, and you're only planning on using one of them.</source>
          <target state="translated">如果你正在做原型设计,只是想让你的代码进行类型检查,或者如果你正在实现一个需要多个方法的特质,而你只打算使用其中的一个方法,那么这就很有用。</target>
        </trans-unit>
        <trans-unit id="1ab14e32989b6a2b12b8a3fb1b8ae13359f650e9" translate="yes" xml:space="preserve">
          <source>This can be useful if you are prototyping and are just looking to have your code typecheck.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13e97c3892555defded3caf3fd786d6a9bf7c197" translate="yes" xml:space="preserve">
          <source>This can be useful if you are prototyping and are just looking to have your code typecheck. &lt;code&gt;todo!&lt;/code&gt; works exactly like &lt;code&gt;unimplemented!&lt;/code&gt;. The only difference between the two macros is the name.</source>
          <target state="translated">如果您要进行原型设计并且只是在检查代码类型，这可能会很有用。 &lt;code&gt;todo!&lt;/code&gt; 完全像 &lt;code&gt;unimplemented!&lt;/code&gt; 一样工作！。这两个宏之间的唯一区别是名称。</target>
        </trans-unit>
        <trans-unit id="8c8e1855be0fe981425a92585a82ff10846bce81" translate="yes" xml:space="preserve">
          <source>This can be useful when we want to access a &lt;code&gt;MaybeUninit&lt;/code&gt; that has been initialized but don't have ownership of the &lt;code&gt;MaybeUninit&lt;/code&gt; (preventing the use of &lt;code&gt;.assume_init()&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ab94494ce69e91c90f0acb5a81528e74b707291" translate="yes" xml:space="preserve">
          <source>This can never cause a problem in safe code because implementing a type that relies on pinning requires unsafe code, but be aware that deciding to make use of pinning in your type (for example by implementing some operation on &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;Self&amp;gt;&lt;/code&gt; or &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt;) has consequences for your &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; implementation as well: if an element of your type could have been pinned, you must treat &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; as implicitly taking &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8075fc432fec0682f4342dc70f37276a8d8a19f" translate="yes" xml:space="preserve">
          <source>This can never cause a problem in safe code because implementing a type that relies on pinning requires unsafe code, but be aware that deciding to make use of pinning in your type (for example by implementing some operation on &lt;code&gt;Pin&amp;lt;&amp;amp;Self&amp;gt;&lt;/code&gt; or &lt;code&gt;Pin&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt;) has consequences for your &lt;code&gt;Drop&lt;/code&gt; implementation as well: if an element of your type could have been pinned, you must treat Drop as implicitly taking &lt;code&gt;Pin&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">这永远不会在安全代码中引起问题，因为实现依赖于固定的类型需要不安全的代码，但是请注意，决定在您的类型中使用固定（例如，通过对 &lt;code&gt;Pin&amp;lt;&amp;amp;Self&amp;gt;&lt;/code&gt; 或 &lt;code&gt;Pin&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt; 实现一些操作）Self&amp;gt;）也会对 &lt;code&gt;Drop&lt;/code&gt; 的实现产生影响：如果可以固定您类型的元素，则必须将Drop视为使用 &lt;code&gt;Pin&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt; 隐式对待。</target>
        </trans-unit>
        <trans-unit id="cadc6079abb6a4bbc592c234ce0da222e1a2fdc1" translate="yes" xml:space="preserve">
          <source>This change unifies all the calls to &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; and solves the problem of the first &lt;code&gt;if&lt;/code&gt; block unnecessarily calling the function twice. Unfortunately, we&amp;rsquo;re now calling this function and waiting for the result in all cases, which includes the inner &lt;code&gt;if&lt;/code&gt; block that doesn&amp;rsquo;t use the result value at all.</source>
          <target state="translated">此更改统一了对 &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; 的所有调用，并解决了第一个 &lt;code&gt;if&lt;/code&gt; 块不必要地两次调用该函数的问题。不幸的是，我们现在调用此函数并在所有情况下都等待结果，其中包括内部的 &lt;code&gt;if&lt;/code&gt; 块，它根本不使用结果值。</target>
        </trans-unit>
        <trans-unit id="d160910b055fc36b0155788ef2b0b90383b734d2" translate="yes" xml:space="preserve">
          <source>This channel has an internal buffer on which messages will be queued. &lt;code&gt;bound&lt;/code&gt; specifies the buffer size. When the internal buffer becomes full, future sends will &lt;em&gt;block&lt;/em&gt; waiting for the buffer to open up. Note that a buffer size of 0 is valid, in which case this becomes &quot;rendezvous channel&quot; where each &lt;a href=&quot;struct.syncsender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; will not return until a &lt;a href=&quot;struct.receiver#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; is paired with it.</source>
          <target state="translated">该通道具有内部缓冲区，消息将在该缓冲区上排队。 &lt;code&gt;bound&lt;/code&gt; 指定缓冲区大小。当内部缓冲区已满时，将来的发送将&lt;em&gt;阻塞，&lt;/em&gt;等待缓冲区打开。请注意，缓冲区大小为0是有效的，在这种情况下，它变为&amp;ldquo;集合通道&amp;rdquo;，其中每个&lt;a href=&quot;struct.syncsender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt;都不会返回，直到&lt;a href=&quot;struct.receiver#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt;与之配对。</target>
        </trans-unit>
        <trans-unit id="fb1d7eb08fcc70de9ba8181af70c6fc4dce88829" translate="yes" xml:space="preserve">
          <source>This chapter covered how to use smart pointers to make different guarantees and trade-offs from those Rust makes by default with regular references. The &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; type has a known size and points to data allocated on the heap. The &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; type keeps track of the number of references to data on the heap so that data can have multiple owners. The &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; type with its interior mutability gives us a type that we can use when we need an immutable type but need to change an inner value of that type; it also enforces the borrowing rules at runtime instead of at compile time.</source>
          <target state="translated">本章介绍了如何使用智能指针与那些默认使用常规引用的Rust做出不同的保证和权衡。的 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 类型具有已知的尺寸和指向在堆上分配数据。所述 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 型跟踪上堆到数据的引用的数目，以使得数据可以有多个拥有者。具有内部可变性的 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 类型为我们提供了一种类型，当我们需要一个不可变类型但需要更改该类型的内部值时，可以使用该类型。它还在运行时而不是在编译时强制执行借用规则。</target>
        </trans-unit>
        <trans-unit id="d76b58ff9e32a83f32bdf3cb1438b47bc33ded06" translate="yes" xml:space="preserve">
          <source>This chapter covers concepts that appear in almost every programming language and how they work in Rust. Many programming languages have much in common at their core. None of the concepts presented in this chapter are unique to Rust, but we&amp;rsquo;ll discuss them in the context of Rust and explain the conventions around using these concepts.</source>
          <target state="translated">本章涵盖了几乎每种编程语言中出现的概念以及它们在Rust中的工作方式。许多编程语言的核心都有很多共同点。本章介绍的概念都不是Rust独有的，但我们将在Rust的背景下进行讨论，并解释有关使用这些概念的约定。</target>
        </trans-unit>
        <trans-unit id="29ea0fbfb2601396e36f35e6ef2ff2eccf09482a" translate="yes" xml:space="preserve">
          <source>This chapter is a recap of the many skills you&amp;rsquo;ve learned so far and an exploration of a few more standard library features. We&amp;rsquo;ll build a command line tool that interacts with file and command line input/output to practice some of the Rust concepts you now have under your belt.</source>
          <target state="translated">本章概述了到目前为止您已经学到的许多技能，并探讨了其他一些标准库功能。我们将构建一个命令行工具，与文件和命令行输入/输出交互，以练习您现在掌握的一些Rust概念。</target>
        </trans-unit>
        <trans-unit id="ba9d120769583a2b06ff5bcafb1b013c4c1c420a" translate="yes" xml:space="preserve">
          <source>This chapter is a reference on all things related to patterns. We&amp;rsquo;ll cover the valid places to use patterns, the difference between refutable and irrefutable patterns, and the different kinds of pattern syntax that you might see. By the end of the chapter, you&amp;rsquo;ll know how to use patterns to express many concepts in a clear way.</source>
          <target state="translated">本章是与模式相关的所有内容的参考。我们将介绍使用模式的有效位置，可重用和不可重用模式之间的区别以及您可能会看到的各种类型的语法。在本章结束时，您将了解如何使用模式以清晰的方式表达许多概念。</target>
        </trans-unit>
        <trans-unit id="4ca695707d3d924a4c7520a559258f62a52be801" translate="yes" xml:space="preserve">
          <source>This chapter recapped some of the major concepts you&amp;rsquo;ve learned so far and covered how to perform common I/O operations in Rust. By using command line arguments, files, environment variables, and the &lt;code&gt;eprintln!&lt;/code&gt; macro for printing errors, you&amp;rsquo;re now prepared to write command line applications. By using the concepts in previous chapters, your code will be well organized, store data effectively in the appropriate data structures, handle errors nicely, and be well tested.</source>
          <target state="translated">本章回顾了您到目前为止已学习的一些主要概念，并介绍了如何在Rust中执行常见的I / O操作。通过使用命令行参数，文件，环境变量和 &lt;code&gt;eprintln!&lt;/code&gt; 用于打印错误的宏，现在您准备编写命令行应用程序。通过使用前几章中的概念，您的代码将井井有条，可以将数据有效地存储在适当的数据结构中，可以很好地处理错误，并且可以进行良好的测试。</target>
        </trans-unit>
        <trans-unit id="4f14f23451903925edc1325ae4f6812d472301ab" translate="yes" xml:space="preserve">
          <source>This closure will be run in the context of the child process after a &lt;code&gt;fork&lt;/code&gt;. This primarily means that any modifications made to memory on behalf of this closure will &lt;strong&gt;not&lt;/strong&gt; be visible to the parent process. This is often a very constrained environment where normal operations like &lt;code&gt;malloc&lt;/code&gt; or acquiring a mutex are not guaranteed to work (due to other threads perhaps still running when the &lt;code&gt;fork&lt;/code&gt; was run).</source>
          <target state="translated">在 &lt;code&gt;fork&lt;/code&gt; 之后，此关闭将在子进程的上下文中运行。这主要意味着，代表此闭包对内存所做的任何修改对于父进程都是&lt;strong&gt;不&lt;/strong&gt;可见的。这通常是一个非常受限制的环境，无法保证正常执行诸如 &lt;code&gt;malloc&lt;/code&gt; 或获取互斥锁之类的正常操作（由于在运行 &lt;code&gt;fork&lt;/code&gt; 时可能仍在运行其他线程）。</target>
        </trans-unit>
        <trans-unit id="22a1461b442324db65b2ce2aa52db0c09471bd28" translate="yes" xml:space="preserve">
          <source>This code also sets &lt;code&gt;s&lt;/code&gt; to &lt;code&gt;tic-tac-toe&lt;/code&gt;. The &lt;code&gt;format!&lt;/code&gt; macro works in the same way as &lt;code&gt;println!&lt;/code&gt;, but instead of printing the output to the screen, it returns a &lt;code&gt;String&lt;/code&gt; with the contents. The version of the code using &lt;code&gt;format!&lt;/code&gt; is much easier to read and doesn&amp;rsquo;t take ownership of any of its parameters.</source>
          <target state="translated">此代码还将 &lt;code&gt;s&lt;/code&gt; 设置为 &lt;code&gt;tic-tac-toe&lt;/code&gt; 。该 &lt;code&gt;format!&lt;/code&gt; 宏的工作方式与 &lt;code&gt;println!&lt;/code&gt; 相同！，而不是将输出打印到屏幕上，而是返回包含内容的 &lt;code&gt;String&lt;/code&gt; 。该版本的代码使用 &lt;code&gt;format!&lt;/code&gt; 更容易阅读，并且不拥有任何参数的所有权。</target>
        </trans-unit>
        <trans-unit id="d361c400527932085f404cf9d818fa511cfc4bc4" translate="yes" xml:space="preserve">
          <source>This code block contains unsafe code.</source>
          <target state="translated">此代码块包含不安全代码。</target>
        </trans-unit>
        <trans-unit id="d2b577d02f895994167db7646bcb5bc51980294d" translate="yes" xml:space="preserve">
          <source>This code compiles and runs but doesn&amp;rsquo;t result in the desired threading behavior: a slow request will still cause other requests to wait to be processed. The reason is somewhat subtle: the &lt;code&gt;Mutex&lt;/code&gt; struct has no public &lt;code&gt;unlock&lt;/code&gt; method because the ownership of the lock is based on the lifetime of the &lt;code&gt;MutexGuard&amp;lt;T&amp;gt;&lt;/code&gt; within the &lt;code&gt;LockResult&amp;lt;MutexGuard&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; that the &lt;code&gt;lock&lt;/code&gt; method returns. At compile time, the borrow checker can then enforce the rule that a resource guarded by a &lt;code&gt;Mutex&lt;/code&gt; cannot be accessed unless we hold the lock. But this implementation can also result in the lock being held longer than intended if we don&amp;rsquo;t think carefully about the lifetime of the &lt;code&gt;MutexGuard&amp;lt;T&amp;gt;&lt;/code&gt;. Because the values in the &lt;code&gt;while let&lt;/code&gt; expression remain in scope for the duration of the block, the lock remains held for the duration of the call to &lt;code&gt;job()&lt;/code&gt;, meaning other workers cannot receive jobs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8be923288a70fe6e854b5bc75a5a5f3ea2e87376" translate="yes" xml:space="preserve">
          <source>This code compiles and runs but doesn&amp;rsquo;t result in the desired threading behavior: a slow request will still cause other requests to wait to be processed. The reason is somewhat subtle: the &lt;code&gt;Mutex&lt;/code&gt; struct has no public &lt;code&gt;unlock&lt;/code&gt; method because the ownership of the lock is based on the lifetime of the &lt;code&gt;MutexGuard&amp;lt;T&amp;gt;&lt;/code&gt; within the &lt;code&gt;LockResult&amp;lt;MutexGuard&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; that the &lt;code&gt;lock&lt;/code&gt; method returns. At compile time, the borrow checker can then enforce the rule that a resource guarded by a &lt;code&gt;Mutex&lt;/code&gt; cannot be accessed unless we hold the lock. But this implementation can also result in the lock being held longer than intended if we don&amp;rsquo;t think carefully about the lifetime of the &lt;code&gt;MutexGuard&amp;lt;T&amp;gt;&lt;/code&gt;. Because the values in the &lt;code&gt;while&lt;/code&gt; expression remain in scope for the duration of the block, the lock remains held for the duration of the call to &lt;code&gt;job.call_box()&lt;/code&gt;, meaning other workers cannot receive jobs.</source>
          <target state="translated">该代码可以编译并运行，但不会导致所需的线程行为：缓慢的请求仍将导致其他请求等待处理。原因有些微妙： &lt;code&gt;Mutex&lt;/code&gt; 结构没有公共 &lt;code&gt;unlock&lt;/code&gt; 方法，因为锁的所有权基于 &lt;code&gt;lock&lt;/code&gt; 方法返回的 &lt;code&gt;LockResult&amp;lt;MutexGuard&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 中 &lt;code&gt;MutexGuard&amp;lt;T&amp;gt;&lt;/code&gt; 的生存期。然后，在编译时，借用检查器可以执行以下规则：除非拥有锁，否则 &lt;code&gt;Mutex&lt;/code&gt; 保护的资源将无法访问。但是，如果我们不仔细考虑 &lt;code&gt;MutexGuard&amp;lt;T&amp;gt;&lt;/code&gt; 的寿命，则此实现还可能导致锁的持有时间比预期的长。因为 &lt;code&gt;while&lt;/code&gt; 表达式中的值在块的持续时间内保持作用域，所以锁定在对 &lt;code&gt;job.call_box()&lt;/code&gt; 的调用期间保持不变，这意味着其他工作程序无法接收作业。</target>
        </trans-unit>
        <trans-unit id="a9ddcc8d0db1cdd5bd0507394434501db1a0bedf" translate="yes" xml:space="preserve">
          <source>This code contains a lot of information, so let&amp;rsquo;s go over it line by line. To obtain user input and then print the result as output, we need to bring the &lt;code&gt;io&lt;/code&gt; (input/output) library into scope. The &lt;code&gt;io&lt;/code&gt; library comes from the standard library (which is known as &lt;code&gt;std&lt;/code&gt;):</source>
          <target state="translated">这段代码包含很多信息，因此让我们逐行进行介绍。为了获得用户输入，然后将结果打印为输出，我们需要将 &lt;code&gt;io&lt;/code&gt; （输入/输出）库纳入范围。该 &lt;code&gt;io&lt;/code&gt; 库来自标准库（其被称为 &lt;code&gt;std&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="a2cf7c9b3ea591cd958e0136c121e6bf9f333d13" translate="yes" xml:space="preserve">
          <source>This code creates a string containing &lt;code&gt;initial contents&lt;/code&gt;.</source>
          <target state="translated">此代码创建一个包含 &lt;code&gt;initial contents&lt;/code&gt; 的字符串。</target>
        </trans-unit>
        <trans-unit id="37eb73353618177bcb3ef1d909b78d97976287b7" translate="yes" xml:space="preserve">
          <source>This code creates the variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; that match the values of the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; fields of the &lt;code&gt;p&lt;/code&gt; struct. This example shows that the names of the variables in the pattern don&amp;rsquo;t have to match the field names of the struct. But it&amp;rsquo;s common to want the variable names to match the field names to make it easier to remember which variables came from which fields.</source>
          <target state="translated">该代码创建与 &lt;code&gt;p&lt;/code&gt; 结构的 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 字段值匹配的变量 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 。此示例显示了模式中变量的名称不必与该结构的字段名称匹配。但是通常希望变量名与字段名匹配，以便更容易记住哪些变量来自哪个字段。</target>
        </trans-unit>
        <trans-unit id="4c6b27e7fab9563bf2abcf70ff023ebf232f1887" translate="yes" xml:space="preserve">
          <source>This code creates the variables &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; that match the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; fields of the &lt;code&gt;p&lt;/code&gt; variable. The outcome is that the variables &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; contain the values from the &lt;code&gt;p&lt;/code&gt; struct.</source>
          <target state="translated">此代码创建的变量 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 匹配该 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 所述的字段 &lt;code&gt;p&lt;/code&gt; 可变。结果是变量 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 包含 &lt;code&gt;p&lt;/code&gt; 结构的值。</target>
        </trans-unit>
        <trans-unit id="519fd3df45d223b502667d31300a65c73f22de3a" translate="yes" xml:space="preserve">
          <source>This code does not compile!</source>
          <target state="translated">这段代码无法编译</target>
        </trans-unit>
        <trans-unit id="a8563da8c7fd875eb235c5cf17bc917dd4b6aba0" translate="yes" xml:space="preserve">
          <source>This code does not produce the desired behavior.</source>
          <target state="translated">这段代码没有产生预期的行为。</target>
        </trans-unit>
        <trans-unit id="0426964d440764948892b9452f7b1a751866e79c" translate="yes" xml:space="preserve">
          <source>This code illustrates that you can put any kind of data inside an enum variant: strings, numeric types, or structs, for example. You can even include another enum! Also, standard library types are often not much more complicated than what you might come up with.</source>
          <target state="translated">这段代码说明了你可以将任何类型的数据放在一个枚举变体中:例如,字符串、数字类型或结构。你甚至可以包含另一个枚举。另外,标准库类型通常不会比你想出来的复杂得多。</target>
        </trans-unit>
        <trans-unit id="23d4be6e177cb0763cfd5315e376249487e60755" translate="yes" xml:space="preserve">
          <source>This code is a bit messy, but it&amp;rsquo;s good enough for simulation purposes. We created a second request &lt;code&gt;sleep&lt;/code&gt;, whose data our server recognizes. We added an &lt;code&gt;else if&lt;/code&gt; after the &lt;code&gt;if&lt;/code&gt; block to check for the request to &lt;em&gt;/sleep&lt;/em&gt;. When that request is received, the server will sleep for 5 seconds before rendering the successful HTML page.</source>
          <target state="translated">这段代码有点凌乱，但是足以用于仿真目的。我们创建了第二个请求 &lt;code&gt;sleep&lt;/code&gt; ，我们的服务器可以识别该数据。我们在 &lt;code&gt;if&lt;/code&gt; 块之后添加了 &lt;code&gt;else if&lt;/code&gt; 来检查对&lt;em&gt;/ sleep&lt;/em&gt;的请求。收到该请求后，服务器将休眠5秒钟，然后呈现成功的HTML页面。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9400019c8ed3d0b61a4a67558c972e785c9498d4" translate="yes" xml:space="preserve">
          <source>This code is a bit nicer, isn&amp;rsquo;t it?</source>
          <target state="translated">这段代码好一点了，不是吗？</target>
        </trans-unit>
        <trans-unit id="a9d573288ab51576cf8efa92e3fc2409e71975a4" translate="yes" xml:space="preserve">
          <source>This code is for an animal shelter that wants to name all puppies Spot, which is implemented in the &lt;code&gt;baby_name&lt;/code&gt; associated function that is defined on &lt;code&gt;Dog&lt;/code&gt;. The &lt;code&gt;Dog&lt;/code&gt; type also implements the trait &lt;code&gt;Animal&lt;/code&gt;, which describes characteristics that all animals have. Baby dogs are called puppies, and that is expressed in the implementation of the &lt;code&gt;Animal&lt;/code&gt; trait on &lt;code&gt;Dog&lt;/code&gt; in the &lt;code&gt;baby_name&lt;/code&gt; function associated with the &lt;code&gt;Animal&lt;/code&gt; trait.</source>
          <target state="translated">该代码用于想要命名所有幼犬Spot的动物收容所，该动物收容所在 &lt;code&gt;Dog&lt;/code&gt; 上定义的 &lt;code&gt;baby_name&lt;/code&gt; 关联函数中实现。该 &lt;code&gt;Dog&lt;/code&gt; 型也实现了性状 &lt;code&gt;Animal&lt;/code&gt; ，它描述的特征，所有的动物都有。宝贝狗被称为小狗，并在实施中表达 &lt;code&gt;Animal&lt;/code&gt; 对性状 &lt;code&gt;Dog&lt;/code&gt; 在 &lt;code&gt;baby_name&lt;/code&gt; 与相关的功能 &lt;code&gt;Animal&lt;/code&gt; 的特征。</target>
        </trans-unit>
        <trans-unit id="28ab5f7e147cb2d4d661943464a31c7e543917cd" translate="yes" xml:space="preserve">
          <source>This code is much easier to read and write! Choosing a meaningful name for a type alias can help communicate your intent as well (&lt;em&gt;thunk&lt;/em&gt; is a word for code to be evaluated at a later time, so it&amp;rsquo;s an appropriate name for a closure that gets stored).</source>
          <target state="translated">这段代码更容易阅读和编写！为类型别名选择一个有意义的名称也可以帮助传达您的意图（&lt;em&gt;thunk&lt;/em&gt;是以后要评估的代码的意思，因此它是用于存储闭包的适当名称）。</target>
        </trans-unit>
        <trans-unit id="49a0f8f422e51179065e97042cbf65579f27fccc" translate="yes" xml:space="preserve">
          <source>This code is not legal: it is not possible to specialize &lt;code&gt;Drop&lt;/code&gt; to a subset of implementations of a generic type. In order for this code to work, &lt;code&gt;MyStruct&lt;/code&gt; must also require that &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Foo&lt;/code&gt;. Alternatively, another option is to wrap the generic type in another that specializes appropriately:</source>
          <target state="translated">该代码不合法​​：无法将 &lt;code&gt;Drop&lt;/code&gt; 专用于泛型类型的实现子集。为了使此代码起作用， &lt;code&gt;MyStruct&lt;/code&gt; 还必须要求 &lt;code&gt;T&lt;/code&gt; 实现 &lt;code&gt;Foo&lt;/code&gt; 。另外，另一种选择是将泛型类型包装在适当专门化的另一种类型中：</target>
        </trans-unit>
        <trans-unit id="e6419e6d86ad5d4d771d701592b7c8059bf718cc" translate="yes" xml:space="preserve">
          <source>This code is not legal: it is not possible to specialize &lt;code&gt;Drop&lt;/code&gt; to a subset of implementations of a generic type. One workaround for this is to wrap the generic type, as shown below:</source>
          <target state="translated">该代码不合法​​：无法将 &lt;code&gt;Drop&lt;/code&gt; 专用于泛型类型的实现子集。一种解决方法是包装通用类型，如下所示：</target>
        </trans-unit>
        <trans-unit id="7561545f94912a4c2f636ef3be71bf5e25ba09fc" translate="yes" xml:space="preserve">
          <source>This code is printing a prompt stating what the game is and requesting input from the user.</source>
          <target state="translated">这段代码是打印一个提示,说明游戏是什么,并要求用户输入。</target>
        </trans-unit>
        <trans-unit id="7103520ca1aa03619df8713fc5365e846d9c5ad3" translate="yes" xml:space="preserve">
          <source>This code is read as &amp;ldquo;the function &lt;code&gt;bar&lt;/code&gt; returns never.&amp;rdquo; Functions that return never are called &lt;em&gt;diverging functions&lt;/em&gt;. We can&amp;rsquo;t create values of the type &lt;code&gt;!&lt;/code&gt; so &lt;code&gt;bar&lt;/code&gt; can never possibly return.</source>
          <target state="translated">将此代码读作&amp;ldquo;功能 &lt;code&gt;bar&lt;/code&gt; 永不返回&amp;rdquo;。永不返回的&lt;em&gt;函数&lt;/em&gt;称为&lt;em&gt;发散函数&lt;/em&gt;。我们无法创建类型的值 &lt;code&gt;!&lt;/code&gt; 所以 &lt;code&gt;bar&lt;/code&gt; 永远不可能回来。</target>
        </trans-unit>
        <trans-unit id="bcd0c3078c2294c0e6fda3c229de0e1561bef882" translate="yes" xml:space="preserve">
          <source>This code is similar to &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#creating-custom-types-for-validation&quot;&gt;the &lt;code&gt;Guess::new&lt;/code&gt; function we wrote in Listing 9-10&lt;/a&gt;, where we called &lt;code&gt;panic!&lt;/code&gt; when the &lt;code&gt;value&lt;/code&gt; argument was out of the range of valid values. Instead of checking for a range of values here, we&amp;rsquo;re checking that the length of &lt;code&gt;args&lt;/code&gt; is at least 3 and the rest of the function can operate under the assumption that this condition has been met. If &lt;code&gt;args&lt;/code&gt; has fewer than three items, this condition will be true, and we call the &lt;code&gt;panic!&lt;/code&gt; macro to end the program immediately.</source>
          <target state="translated">这段代码类似于&lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#creating-custom-types-for-validation&quot;&gt;清单9-10中编写&lt;/a&gt;的 &lt;code&gt;Guess::new&lt;/code&gt; 函数，我们称之为 &lt;code&gt;panic!&lt;/code&gt; 。当 &lt;code&gt;value&lt;/code&gt; 参数超出有效值范围时。在此，我们将检查 &lt;code&gt;args&lt;/code&gt; 的长度至少为3，并且其余功能可以在满足此条件的假设下运行，而不是在此处检查值的范围。如果 &lt;code&gt;args&lt;/code&gt; 少于三个项目，则此条件成立，我们称之为 &lt;code&gt;panic!&lt;/code&gt; 宏以立即结束程序。</target>
        </trans-unit>
        <trans-unit id="7a83ac1e4ecf68353438d16df2a11f1d38c56035" translate="yes" xml:space="preserve">
          <source>This code is the automatically generated test module. The attribute &lt;code&gt;cfg&lt;/code&gt; stands for &lt;em&gt;configuration&lt;/em&gt; and tells Rust that the following item should only be included given a certain configuration option. In this case, the configuration option is &lt;code&gt;test&lt;/code&gt;, which is provided by Rust for compiling and running tests. By using the &lt;code&gt;cfg&lt;/code&gt; attribute, Cargo compiles our test code only if we actively run the tests with &lt;code&gt;cargo test&lt;/code&gt;. This includes any helper functions that might be within this module, in addition to the functions annotated with &lt;code&gt;#[test]&lt;/code&gt;.</source>
          <target state="translated">此代码是自动生成的测试模块。 &lt;code&gt;cfg&lt;/code&gt; 属性代表&lt;em&gt;配置，&lt;/em&gt;并告诉Rust仅在具有特定配置选项的情况下才应包括以下项目。在这种情况下，配置选项是 &lt;code&gt;test&lt;/code&gt; ，由Rust提供，用于编译和运行测试。通过使用 &lt;code&gt;cfg&lt;/code&gt; 属性，仅当我们使用 &lt;code&gt;cargo test&lt;/code&gt; 积极运行测试时，Cargo才会编译测试代码。除了用 &lt;code&gt;#[test]&lt;/code&gt; 注释的功能之外，它还包括此模块中可能包含的所有辅助功能。</target>
        </trans-unit>
        <trans-unit id="fb14b558eed9a012f6129027202f61756e6e0b8d" translate="yes" xml:space="preserve">
          <source>This code lets us break complex types into their component parts so we can use the values we&amp;rsquo;re interested in separately.</source>
          <target state="translated">该代码使我们可以将复杂类型分解为它们的组成部分，以便我们可以分别使用我们感兴趣的值。</target>
        </trans-unit>
        <trans-unit id="bf80b97b3cceef068893acf5a419fa57178f1aed" translate="yes" xml:space="preserve">
          <source>This code means the type &lt;code&gt;Point&amp;lt;f32&amp;gt;&lt;/code&gt; will have a method named &lt;code&gt;distance_from_origin&lt;/code&gt; and other instances of &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; is not of type &lt;code&gt;f32&lt;/code&gt; will not have this method defined. The method measures how far our point is from the point at coordinates (0.0, 0.0) and uses mathematical operations that are available only for floating point types.</source>
          <target state="translated">此代码意味着 &lt;code&gt;Point&amp;lt;f32&amp;gt;&lt;/code&gt; 类型将具有一个名为 &lt;code&gt;distance_from_origin&lt;/code&gt; 的方法，而 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 其他实例（其中 &lt;code&gt;T&lt;/code&gt; 不是 &lt;code&gt;f32&lt;/code&gt; 类型）将没有定义此方法。该方法测量我们的点距坐标（0.0，0.0）处的点的距离，并使用仅适用于浮点类型的数学运算。</target>
        </trans-unit>
        <trans-unit id="edb9c9f6097f3c4e5bd16a047b4ef0c91c5eda3e" translate="yes" xml:space="preserve">
          <source>This code overrides the default setting of &lt;code&gt;0&lt;/code&gt;. Now when we run &lt;code&gt;cargo build&lt;/code&gt;, Cargo will use the defaults for the &lt;code&gt;dev&lt;/code&gt; profile plus our customization to &lt;code&gt;opt-level&lt;/code&gt;. Because we set &lt;code&gt;opt-level&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt;, Cargo will apply more optimizations than the default, but not as many as in a release build.</source>
          <target state="translated">此代码将覆盖默认设置 &lt;code&gt;0&lt;/code&gt; 。现在，当我们运行 &lt;code&gt;cargo build&lt;/code&gt; 时，Cargo将使用 &lt;code&gt;dev&lt;/code&gt; 配置文件的默认值以及我们对 &lt;code&gt;opt-level&lt;/code&gt; 的自定义。因为我们将 &lt;code&gt;opt-level&lt;/code&gt; 设置为 &lt;code&gt;1&lt;/code&gt; ，所以Cargo将应用比默认设置更多的优化，但不如发布版本中的优化多。</target>
        </trans-unit>
        <trans-unit id="cbd474aff68e6272a4d817ab514ba2ba338dc2b1" translate="yes" xml:space="preserve">
          <source>This code panics!</source>
          <target state="translated">这个代码慌了!</target>
        </trans-unit>
        <trans-unit id="1520d0fd722c3577359ba16db239ceb0ddeebd5f" translate="yes" xml:space="preserve">
          <source>This code prints &lt;code&gt;1 new tweet: (Read more from @horse_ebooks...)&lt;/code&gt;.</source>
          <target state="translated">这段代码显示了 &lt;code&gt;1 new tweet: (Read more from @horse_ebooks...)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6d78693e95ef2bffb056748f86ea7d4fd87f6784" translate="yes" xml:space="preserve">
          <source>This code prints &lt;code&gt;1 new tweet: horse_ebooks: of course, as you probably already know, people&lt;/code&gt;.</source>
          <target state="translated">这段代码显示了 &lt;code&gt;1 new tweet: horse_ebooks: of course, as you probably already know, people&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4e90b820e3471ed9be465d87743c5461551a7f0" translate="yes" xml:space="preserve">
          <source>This code prints &lt;code&gt;Current location: (3, 5)&lt;/code&gt;. The values &lt;code&gt;&amp;amp;(3, 5)&lt;/code&gt; match the pattern &lt;code&gt;&amp;amp;(x, y)&lt;/code&gt;, so &lt;code&gt;x&lt;/code&gt; is the value &lt;code&gt;3&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is the value &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="translated">此代码显示 &lt;code&gt;Current location: (3, 5)&lt;/code&gt; 。值 &lt;code&gt;&amp;amp;(3, 5)&lt;/code&gt; 与模式 &lt;code&gt;&amp;amp;(x, y)&lt;/code&gt; ）匹配，因此 &lt;code&gt;x&lt;/code&gt; 是值 &lt;code&gt;3&lt;/code&gt; ,而 &lt;code&gt;y&lt;/code&gt; 是值 &lt;code&gt;5&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb3c413eeb04880ff8b53ff489dddef4151c97bb" translate="yes" xml:space="preserve">
          <source>This code prints &lt;code&gt;New article available! (Read more...)&lt;/code&gt;.</source>
          <target state="translated">此代码可打印 &lt;code&gt;New article available! (Read more...)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4bdc1d17208e27666bda4fd318b994f6acf7818b" translate="yes" xml:space="preserve">
          <source>This code prints &lt;code&gt;The answer is: 12&lt;/code&gt;. We specify that the parameter &lt;code&gt;f&lt;/code&gt; in &lt;code&gt;do_twice&lt;/code&gt; is an &lt;code&gt;fn&lt;/code&gt; that takes one parameter of type &lt;code&gt;i32&lt;/code&gt; and returns an &lt;code&gt;i32&lt;/code&gt;. We can then call &lt;code&gt;f&lt;/code&gt; in the body of &lt;code&gt;do_twice&lt;/code&gt;. In &lt;code&gt;main&lt;/code&gt;, we can pass the function name &lt;code&gt;add_one&lt;/code&gt; as the first argument to &lt;code&gt;do_twice&lt;/code&gt;.</source>
          <target state="translated">这段代码打印出来 &lt;code&gt;The answer is: 12&lt;/code&gt; 。我们指定的参数 &lt;code&gt;f&lt;/code&gt; 在 &lt;code&gt;do_twice&lt;/code&gt; 是 &lt;code&gt;fn&lt;/code&gt; 是需要一个类型的一个参数 &lt;code&gt;i32&lt;/code&gt; ，并返回一个 &lt;code&gt;i32&lt;/code&gt; 。然后，我们可以在 &lt;code&gt;do_twice&lt;/code&gt; 的主体中调用 &lt;code&gt;f&lt;/code&gt; 。在 &lt;code&gt;main&lt;/code&gt; 中，我们可以将函数名称 &lt;code&gt;add_one&lt;/code&gt; 作为第一个参数传递给 &lt;code&gt;do_twice&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f51af940300a3743a5ab26b4b6248a93015d25fc" translate="yes" xml:space="preserve">
          <source>This code prints &lt;code&gt;one or two&lt;/code&gt;.</source>
          <target state="translated">此代码打印 &lt;code&gt;one or two&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa3fc2ca0fc1e2ca4079f6b9c2e26f148c6f028f" translate="yes" xml:space="preserve">
          <source>This code prints &lt;code&gt;one&lt;/code&gt; because the value in &lt;code&gt;x&lt;/code&gt; is 1. This syntax is useful when you want your code to take an action if it gets a particular concrete value.</source>
          <target state="translated">由于 &lt;code&gt;x&lt;/code&gt; 中的值为1，因此此代码将打印 &lt;code&gt;one&lt;/code&gt; 。如果希望代码获得特定的具体值，则该代码很有用。</target>
        </trans-unit>
        <trans-unit id="f76e20cf8d5177f5195a6770ae0f2388492d5a80" translate="yes" xml:space="preserve">
          <source>This code prints the following:</source>
          <target state="translated">这段代码打印的内容如下:</target>
        </trans-unit>
        <trans-unit id="2da1adcf6ac7d40ff872dbb16e9f7a36210c0c52" translate="yes" xml:space="preserve">
          <source>This code should compile and produce the result we want when we use it with the &lt;code&gt;main&lt;/code&gt; function in Listing 10-20.</source>
          <target state="translated">当我们将其与清单10-20中的 &lt;code&gt;main&lt;/code&gt; 函数一起使用时，该代码应编译并产生所需的结果。</target>
        </trans-unit>
        <trans-unit id="fc992e6806cb1bd5a9c534e91522711af45f4b36" translate="yes" xml:space="preserve">
          <source>This code should look generally familiar: a trait with one method and an associated type. The new part is &lt;code&gt;RHS=Self&lt;/code&gt;: this syntax is called &lt;em&gt;default type parameters&lt;/em&gt;. The &lt;code&gt;RHS&lt;/code&gt; generic type parameter (short for &amp;ldquo;right hand side&amp;rdquo;) defines the type of the &lt;code&gt;rhs&lt;/code&gt; parameter in the &lt;code&gt;add&lt;/code&gt; method. If we don&amp;rsquo;t specify a concrete type for &lt;code&gt;RHS&lt;/code&gt; when we implement the &lt;code&gt;Add&lt;/code&gt; trait, the type of &lt;code&gt;RHS&lt;/code&gt; will default to &lt;code&gt;Self&lt;/code&gt;, which will be the type we&amp;rsquo;re implementing &lt;code&gt;Add&lt;/code&gt; on.</source>
          <target state="translated">该代码通常看起来很熟悉：具有一个方法和一个关联类型的特征。新部分是 &lt;code&gt;RHS=Self&lt;/code&gt; ：此语法称为&lt;em&gt;默认类型参数&lt;/em&gt;。在 &lt;code&gt;RHS&lt;/code&gt; 泛型类型参数（以下简称&amp;ldquo;右侧&amp;rdquo;）定义的类型 &lt;code&gt;rhs&lt;/code&gt; 在参数 &lt;code&gt;add&lt;/code&gt; 方法。如果我们不指定具体类型 &lt;code&gt;RHS&lt;/code&gt; 当我们执行的 &lt;code&gt;Add&lt;/code&gt; 特征，类型 &lt;code&gt;RHS&lt;/code&gt; 将默认为 &lt;code&gt;Self&lt;/code&gt; ，这将是我们正在实施的类型 &lt;code&gt;Add&lt;/code&gt; 上。</target>
        </trans-unit>
        <trans-unit id="58a84861deaa80c4db75f055d7277e059fbe6bb3" translate="yes" xml:space="preserve">
          <source>This code should look generally familiar: a trait with one method and an associated type. The new part is &lt;code&gt;Rhs=Self&lt;/code&gt;: this syntax is called &lt;em&gt;default type parameters&lt;/em&gt;. The &lt;code&gt;Rhs&lt;/code&gt; generic type parameter (short for &amp;ldquo;right hand side&amp;rdquo;) defines the type of the &lt;code&gt;rhs&lt;/code&gt; parameter in the &lt;code&gt;add&lt;/code&gt; method. If we don&amp;rsquo;t specify a concrete type for &lt;code&gt;Rhs&lt;/code&gt; when we implement the &lt;code&gt;Add&lt;/code&gt; trait, the type of &lt;code&gt;Rhs&lt;/code&gt; will default to &lt;code&gt;Self&lt;/code&gt;, which will be the type we&amp;rsquo;re implementing &lt;code&gt;Add&lt;/code&gt; on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9916bd76554811c91bac8fdab30ae1e7bf834537" translate="yes" xml:space="preserve">
          <source>This code still won&amp;rsquo;t work, but let&amp;rsquo;s check it again to get the next error that we need to address:</source>
          <target state="translated">这段代码仍然无法正常工作，但是让我们再次检查一下以获取我们需要解决的下一个错误：</target>
        </trans-unit>
        <trans-unit id="d27513508379ea6cd339c0bb4a46ef6e82c466b9" translate="yes" xml:space="preserve">
          <source>This code stores a list of integers in the variable &lt;code&gt;number_list&lt;/code&gt; and places the first number in the list in a variable named &lt;code&gt;largest&lt;/code&gt;. Then it iterates through all the numbers in the list, and if the current number is greater than the number stored in &lt;code&gt;largest&lt;/code&gt;, it replaces the number in that variable. However, if the current number is less than or equal to the largest number seen so far, the variable doesn&amp;rsquo;t change, and the code moves on to the next number in the list. After considering all the numbers in the list, &lt;code&gt;largest&lt;/code&gt; should hold the largest number, which in this case is 100.</source>
          <target state="translated">此代码存储在变量整数列表 &lt;code&gt;number_list&lt;/code&gt; 并在一个名为变量放在列表中的第一个号码 &lt;code&gt;largest&lt;/code&gt; 。然后，它通过迭代列表中的所有号码，如果当前数目比存储在数量较大的 &lt;code&gt;largest&lt;/code&gt; ，它在变量替换的数量。但是，如果当前数字小于或等于到目前为止所看到的最大数字，则变量不会更改，并且代码将移至列表中的下一个数字。在考虑了列表中的所有数字之后， &lt;code&gt;largest&lt;/code&gt; 应该拥有最大的数字，在这种情况下为100。</target>
        </trans-unit>
        <trans-unit id="65e3fdd29c21c5766164366857eab04eba8f916b" translate="yes" xml:space="preserve">
          <source>This code will compile and will store the number of &lt;code&gt;Worker&lt;/code&gt; instances we specified as an argument to &lt;code&gt;ThreadPool::new&lt;/code&gt;. But we&amp;rsquo;re &lt;em&gt;still&lt;/em&gt; not processing the closure that we get in &lt;code&gt;execute&lt;/code&gt;. Let&amp;rsquo;s look at how to do that next.</source>
          <target state="translated">该代码将编译并存储我们指定为 &lt;code&gt;ThreadPool::new&lt;/code&gt; 的参数的 &lt;code&gt;Worker&lt;/code&gt; 实例的数量。但是我们&lt;em&gt;仍然&lt;/em&gt;没有处理 &lt;code&gt;execute&lt;/code&gt; 的闭包。接下来让我们看看如何做。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="045fdd180c10e009660c1c81e0cc6eab5a5aa968" translate="yes" xml:space="preserve">
          <source>This code will compile just fine. For more about trait objects, refer to the section &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;Using Trait Objects That Allow for Values of Different Types&amp;rdquo;&lt;/a&gt; in Chapter 17.</source>
          <target state="translated">这段代码可以很好地编译。有关特征对象的更多信息，请参见第17章中的&lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;使用允许使用不同类型值的特征对象&amp;rdquo;&lt;/a&gt;一节。</target>
        </trans-unit>
        <trans-unit id="457c8af0abaf5c3ca5e095102658cc6466fc1c3e" translate="yes" xml:space="preserve">
          <source>This code will compile without any errors. Note the &lt;code&gt;r#&lt;/code&gt; prefix on the function name in its definition as well as where the function is called in &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">该代码将编译而没有任何错误。注意函数名称中的 &lt;code&gt;r#&lt;/code&gt; 前缀及其定义，以及在 &lt;code&gt;main&lt;/code&gt; 中调用该函数的位置。</target>
        </trans-unit>
        <trans-unit id="a4e6558f8bd1055ab8e1efd4008b36e362cb01bc" translate="yes" xml:space="preserve">
          <source>This code will completely ignore the value passed as the first argument, &lt;code&gt;3&lt;/code&gt;, and will print &lt;code&gt;This code only uses the y parameter: 4&lt;/code&gt;.</source>
          <target state="translated">该代码将完全忽略作为第一个参数 &lt;code&gt;3&lt;/code&gt; 传递的值，并且将打印 &lt;code&gt;This code only uses the y parameter: 4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f597cb1c1231379b4a9ac9b16a64f6f09dac15f9" translate="yes" xml:space="preserve">
          <source>This code will now print &lt;code&gt;Default case, x = Some(5)&lt;/code&gt;. The pattern in the second match arm doesn&amp;rsquo;t introduce a new variable &lt;code&gt;y&lt;/code&gt; that would shadow the outer &lt;code&gt;y&lt;/code&gt;, meaning we can use the outer &lt;code&gt;y&lt;/code&gt; in the match guard. Instead of specifying the pattern as &lt;code&gt;Some(y)&lt;/code&gt;, which would have shadowed the outer &lt;code&gt;y&lt;/code&gt;, we specify &lt;code&gt;Some(n)&lt;/code&gt;. This creates a new variable &lt;code&gt;n&lt;/code&gt; that doesn&amp;rsquo;t shadow anything because there is no &lt;code&gt;n&lt;/code&gt; variable outside the &lt;code&gt;match&lt;/code&gt;.</source>
          <target state="translated">现在，此代码将显示 &lt;code&gt;Default case, x = Some(5)&lt;/code&gt; 。第二个比赛臂中的模式没有引入新的变量 &lt;code&gt;y&lt;/code&gt; ，该变量会遮蔽外部 &lt;code&gt;y&lt;/code&gt; ，这意味着我们可以在比赛后卫中使用外部 &lt;code&gt;y&lt;/code&gt; 。我们将指定 &lt;code&gt;Some(n)&lt;/code&gt; 而不是将模式指定为 &lt;code&gt;Some(y)&lt;/code&gt; ，该模式会遮盖外部 &lt;code&gt;y&lt;/code&gt; 。这将创建一个新的变量 &lt;code&gt;n&lt;/code&gt; ，该变量不会隐藏任何内容，因为在 &lt;code&gt;match&lt;/code&gt; 之外没有 &lt;code&gt;n&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="1bcf93c595538a9e0c98606ec2aa75cae859981c" translate="yes" xml:space="preserve">
          <source>This code will print &lt;code&gt;Can't overwrite an existing customized value&lt;/code&gt; and then &lt;code&gt;setting is Some(5)&lt;/code&gt;. In the first match arm, we don&amp;rsquo;t need to match on or use the values inside either &lt;code&gt;Some&lt;/code&gt; variant, but we do need to test for the case when &lt;code&gt;setting_value&lt;/code&gt; and &lt;code&gt;new_setting_value&lt;/code&gt; are the &lt;code&gt;Some&lt;/code&gt; variant. In that case, we print why we&amp;rsquo;re not changing &lt;code&gt;setting_value&lt;/code&gt;, and it doesn&amp;rsquo;t get changed.</source>
          <target state="translated">该代码将打印 &lt;code&gt;Can't overwrite an existing customized value&lt;/code&gt; ，然后 &lt;code&gt;setting is Some(5)&lt;/code&gt; 。在第一场比赛的胳膊，我们并不需要匹配或使用任何内部的价值观 &lt;code&gt;Some&lt;/code&gt; 变形，但我们确实需要测试的情况下 &lt;code&gt;setting_value&lt;/code&gt; 和 &lt;code&gt;new_setting_value&lt;/code&gt; 是 &lt;code&gt;Some&lt;/code&gt; 变种。在这种情况下，我们将打印为什么不更改 &lt;code&gt;setting_value&lt;/code&gt; ，并且不更改它。</target>
        </trans-unit>
        <trans-unit id="59fe6f0c2e0e4f24920973a91f227ffd825f4348" translate="yes" xml:space="preserve">
          <source>This code will print &lt;code&gt;Change the color to red 0, green 160, and blue 255&lt;/code&gt;. Try changing the value of &lt;code&gt;msg&lt;/code&gt; to see the code from the other arms run.</source>
          <target state="translated">将打印此代码，将 &lt;code&gt;Change the color to red 0, green 160, and blue 255&lt;/code&gt; 。尝试更改 &lt;code&gt;msg&lt;/code&gt; 的值以查看其他程序运行的代码。</target>
        </trans-unit>
        <trans-unit id="3c54f68158af593ed8370c89b1e792c808e333b9" translate="yes" xml:space="preserve">
          <source>This code will print &lt;code&gt;Hello, Macro! My name is Pancakes!&lt;/code&gt; when we&amp;rsquo;re done. The first step is to make a new library crate, like this:</source>
          <target state="translated">此代码将打印 &lt;code&gt;Hello, Macro! My name is Pancakes!&lt;/code&gt; 当我们完成时。第一步是制作一个新的库条板箱，如下所示：</target>
        </trans-unit>
        <trans-unit id="6ef0c24b1ac6e78f32662fb7a47aa078602f7661" translate="yes" xml:space="preserve">
          <source>This code will print &lt;code&gt;Some numbers: 2, 8, 32&lt;/code&gt;, and the values 4 and 16 will be ignored.</source>
          <target state="translated">此代码将打印 &lt;code&gt;Some numbers: 2, 8, 32&lt;/code&gt; 和值4和16将被忽略。</target>
        </trans-unit>
        <trans-unit id="6e7f6cc166031d911beb7caaef0389c2805500c8" translate="yes" xml:space="preserve">
          <source>This code will print &lt;code&gt;{&quot;Blue&quot;: 25}&lt;/code&gt;. The original value of &lt;code&gt;10&lt;/code&gt; has been overwritten.</source>
          <target state="translated">此代码将打印 &lt;code&gt;{&quot;Blue&quot;: 25}&lt;/code&gt; 。原始值 &lt;code&gt;10&lt;/code&gt; 已被覆盖。</target>
        </trans-unit>
        <trans-unit id="4c7854ef3442e5dc7384d2ebe52264fddb2a172b" translate="yes" xml:space="preserve">
          <source>This code will print &lt;code&gt;{&quot;world&quot;: 2, &quot;hello&quot;: 1, &quot;wonderful&quot;: 1}&lt;/code&gt;. The &lt;code&gt;or_insert&lt;/code&gt; method actually returns a mutable reference (&lt;code&gt;&amp;amp;mut V&lt;/code&gt;) to the value for this key. Here we store that mutable reference in the &lt;code&gt;count&lt;/code&gt; variable, so in order to assign to that value, we must first dereference &lt;code&gt;count&lt;/code&gt; using the asterisk (&lt;code&gt;*&lt;/code&gt;). The mutable reference goes out of scope at the end of the &lt;code&gt;for&lt;/code&gt; loop, so all of these changes are safe and allowed by the borrowing rules.</source>
          <target state="translated">此代码将显示 &lt;code&gt;{&quot;world&quot;: 2, &quot;hello&quot;: 1, &quot;wonderful&quot;: 1}&lt;/code&gt; 。该 &lt;code&gt;or_insert&lt;/code&gt; 方法实际上返回一个可变的参考（ &lt;code&gt;&amp;amp;mut V&lt;/code&gt; ），以该键的值。在这里，我们将该可变引用存储在 &lt;code&gt;count&lt;/code&gt; 变量中，因此，为了分配给该值，我们必须首先使用星号（ &lt;code&gt;*&lt;/code&gt; ）取消引用 &lt;code&gt;count&lt;/code&gt; 。可变引用在 &lt;code&gt;for&lt;/code&gt; 循环的末尾超出范围，因此所有这些更改都是安全的，并且借用规则允许。</target>
        </trans-unit>
        <trans-unit id="d2527fb52597f9416819ef1fc01a194d639282f6" translate="yes" xml:space="preserve">
          <source>This code will print each pair in an arbitrary order:</source>
          <target state="translated">这段代码将按任意顺序打印每一对。</target>
        </trans-unit>
        <trans-unit id="bacd4441a056463b6c76d4dcb3493a2106b165e0" translate="yes" xml:space="preserve">
          <source>This code will print the 18 bytes that make up this &lt;code&gt;String&lt;/code&gt;:</source>
          <target state="translated">此代码将打印组成此 &lt;code&gt;String&lt;/code&gt; 的18个字节：</target>
        </trans-unit>
        <trans-unit id="df66479dcc3e1d9cca2a55caf3dadeea76d13542" translate="yes" xml:space="preserve">
          <source>This code will print the following:</source>
          <target state="translated">该代码将打印以下内容。</target>
        </trans-unit>
        <trans-unit id="6cf1c1dee0071b4d526326a9881c97e561ec0f1a" translate="yes" xml:space="preserve">
          <source>This code will result in the following error:</source>
          <target state="translated">该代码将导致以下错误。</target>
        </trans-unit>
        <trans-unit id="bd9279581006b04d3fb15d53d9a31240a9bda944" translate="yes" xml:space="preserve">
          <source>This code works just fine because we never bind &lt;code&gt;s&lt;/code&gt; to anything; it isn&amp;rsquo;t moved.</source>
          <target state="translated">这段代码很好用，因为我们永远不会将 &lt;code&gt;s&lt;/code&gt; 绑定到任何东西。它没有动。</target>
        </trans-unit>
        <trans-unit id="a72012f28327d683a9fda9d6b4835b6ec97dd74b" translate="yes" xml:space="preserve">
          <source>This code works the way the business wants it to now, but let&amp;rsquo;s say the data science team decides that we need to make some changes to the way we call the &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; function in the future. To simplify the update when those changes happen, we want to refactor this code so it calls the &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; function only once. We also want to cut the place where we&amp;rsquo;re currently unnecessarily calling the function twice without adding any other calls to that function in the process. That is, we don&amp;rsquo;t want to call it if the result isn&amp;rsquo;t needed, and we still want to call it only once.</source>
          <target state="translated">这段代码可以按照企业现在想要的方式工作，但是让我们说，数据科学团队决定，我们需要在未来对调用 &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; 函数的方式进行一些更改。为了在发生这些更改时简化更新，我们希望重构此代码，以便它仅调用一次 &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; 函数。我们还希望减少当前不必要地调用该函数两次的位置，而不在该过程中添加对该函数的任何其他调用。也就是说，如果不需要结果，我们不想调用它，而我们仍然只想调用一次。</target>
        </trans-unit>
        <trans-unit id="29594b80ae15e7f3a6760f8d699f1007a88ab197" translate="yes" xml:space="preserve">
          <source>This code would attempt to link with &lt;code&gt;libmy_c_library.so&lt;/code&gt; on unix-like systems and &lt;code&gt;my_c_library.dll&lt;/code&gt; on Windows at runtime, and panic if it can't find something to link to. Rust code could then use &lt;code&gt;my_c_function&lt;/code&gt; as if it were any other unsafe Rust function. Working with non-Rust languages and FFI is inherently unsafe, so wrappers are usually built around C APIs.</source>
          <target state="translated">此代码将尝试与链接 &lt;code&gt;libmy_c_library.so&lt;/code&gt; 在类Unix系统和 &lt;code&gt;my_c_library.dll&lt;/code&gt; 在运行在Windows和惊恐，如果它不能找点链接。然后，Rust代码可以使用 &lt;code&gt;my_c_function&lt;/code&gt; ，就好像它是其他任何不安全的Rust函数一样。使用非Rust语言和FFI本质上是不安全的，因此包装程序通常围绕C API构建。</target>
        </trans-unit>
        <trans-unit id="94ac7a59ef0f9f139e040ad72861c14b2eb19308" translate="yes" xml:space="preserve">
          <source>This code would print &lt;code&gt;x = 5 and y = 10&lt;/code&gt;.</source>
          <target state="translated">此代码将输出 &lt;code&gt;x = 5 and y = 10&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0be10b63965c309b87ed0545b477401b58dc21cb" translate="yes" xml:space="preserve">
          <source>This command creates an executable file in &lt;em&gt;target/debug/hello_cargo&lt;/em&gt; (or &lt;em&gt;target\debug\hello_cargo.exe&lt;/em&gt; on Windows) rather than in your current directory. You can run the executable with this command:</source>
          <target state="translated">此命令在&lt;em&gt;target / debug / hello_cargo&lt;/em&gt;（或Windows上的&lt;em&gt;target \ debug \ hello_cargo.exe&lt;/em&gt;）中而非当前目录中创建一个可执行文件。您可以使用以下命令运行可执行文件：</target>
        </trans-unit>
        <trans-unit id="4dd02fcb167dbab5d0f3cc67c54c6c5da2a62c5e" translate="yes" xml:space="preserve">
          <source>This command gives you &lt;code&gt;rustfmt&lt;/code&gt; and &lt;code&gt;cargo-fmt&lt;/code&gt;, similar to how Rust gives you both &lt;code&gt;rustc&lt;/code&gt; and &lt;code&gt;cargo&lt;/code&gt;. To format any Cargo project, enter the following:</source>
          <target state="translated">该命令为您提供 &lt;code&gt;rustfmt&lt;/code&gt; 和 &lt;code&gt;cargo-fmt&lt;/code&gt; ，类似于Rust为您提供 &lt;code&gt;rustc&lt;/code&gt; 和 &lt;code&gt;cargo&lt;/code&gt; 的方式。要格式化任何货运项目，请输入以下内容：</target>
        </trans-unit>
        <trans-unit id="616fc540cd704c55f34b7ddb4249c489ab431fea" translate="yes" xml:space="preserve">
          <source>This command ran all tests with &lt;code&gt;add&lt;/code&gt; in the name and filtered out the test named &lt;code&gt;one_hundred&lt;/code&gt;. Also note that the module in which a test appears becomes part of the test&amp;rsquo;s name, so we can run all the tests in a module by filtering on the module&amp;rsquo;s name.</source>
          <target state="translated">该命令使用 &lt;code&gt;add&lt;/code&gt; 名称运行所有测试，并过滤掉名为 &lt;code&gt;one_hundred&lt;/code&gt; 的测试。还要注意，其中出现测试的模块已成为测试名称的一部分，因此我们可以通过过滤模块名称来运行模块中的所有测试。</target>
        </trans-unit>
        <trans-unit id="8ea7582e38a836907de1d30ee5b58334fa20a196" translate="yes" xml:space="preserve">
          <source>This command runs only the tests in the &lt;em&gt;tests/integration_test.rs&lt;/em&gt; file.</source>
          <target state="translated">此命令仅运行&lt;em&gt;tests / integration_test.rs&lt;/em&gt;文件中的&lt;em&gt;测试&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="0760093e6150870ee34facc6b7a5327edc5dc69d" translate="yes" xml:space="preserve">
          <source>This command will inform Cargo of your API token and store it locally in &lt;em&gt;~/.cargo/credentials&lt;/em&gt;. Note that this token is a &lt;em&gt;secret&lt;/em&gt;: do not share it with anyone else. If you do share it with anyone for any reason, you should revoke it and generate a new token on &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;.</source>
          <target state="translated">此命令会将您的API令牌通知Cargo并将其本地存储在&lt;em&gt;〜/ .cargo / credentials中&lt;/em&gt;。请注意，此令牌是一个&lt;em&gt;秘密&lt;/em&gt;：请勿与其他任何人共享。如果您确实出于任何原因与任何人共享它，则应该撤消它并在&lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;上生成一个新令牌。</target>
        </trans-unit>
        <trans-unit id="5e88705efdf159f3ff9b6126f1c10159a182f8df" translate="yes" xml:space="preserve">
          <source>This compiles because &lt;code&gt;longer&lt;/code&gt; outlives &lt;code&gt;shorter&lt;/code&gt;, thus the constraint is respected:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f29dc82f5ad5c21f66ea4c65c4df005f9bfa118" translate="yes" xml:space="preserve">
          <source>This computes the integer &lt;code&gt;n&lt;/code&gt; such that &lt;code&gt;self = n * rhs + self.rem_euclid(rhs)&lt;/code&gt;, with &lt;code&gt;0 &amp;lt;= self.rem_euclid(rhs) &amp;lt; rhs&lt;/code&gt;.</source>
          <target state="translated">这将计算整数 &lt;code&gt;n&lt;/code&gt; ，使得 &lt;code&gt;self = n * rhs + self.rem_euclid(rhs)&lt;/code&gt; ，且 &lt;code&gt;0 &amp;lt;= self.rem_euclid(rhs) &amp;lt; rhs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="92466c99e75537fb86fdcb8b6177060d58e36e85" translate="yes" xml:space="preserve">
          <source>This computes the integer &lt;code&gt;n&lt;/code&gt; such that &lt;code&gt;self = n * rhs + self.rem_euclid(rhs)&lt;/code&gt;. In other words, the result is &lt;code&gt;self / rhs&lt;/code&gt; rounded to the integer &lt;code&gt;n&lt;/code&gt; such that &lt;code&gt;self &amp;gt;= n * rhs&lt;/code&gt;.</source>
          <target state="translated">这将计算整数 &lt;code&gt;n&lt;/code&gt; ，使得 &lt;code&gt;self = n * rhs + self.rem_euclid(rhs)&lt;/code&gt; 。换句话说，结果是将 &lt;code&gt;self / rhs&lt;/code&gt; 舍入为整数 &lt;code&gt;n&lt;/code&gt; ,从而使 &lt;code&gt;self &amp;gt;= n * rhs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="30ff452f5fae3358ab149e5ae5cfa16c08f607d2" translate="yes" xml:space="preserve">
          <source>This concept&amp;mdash;of being concerned only with the messages a value responds to rather than the value&amp;rsquo;s concrete type&amp;mdash;is similar to the concept &lt;em&gt;duck typing&lt;/em&gt; in dynamically typed languages: if it walks like a duck and quacks like a duck, then it must be a duck! In the implementation of &lt;code&gt;run&lt;/code&gt; on &lt;code&gt;Screen&lt;/code&gt; in Listing 17-5, &lt;code&gt;run&lt;/code&gt; doesn&amp;rsquo;t need to know what the concrete type of each component is. It doesn&amp;rsquo;t check whether a component is an instance of a &lt;code&gt;Button&lt;/code&gt; or a &lt;code&gt;SelectBox&lt;/code&gt;, it just calls the &lt;code&gt;draw&lt;/code&gt; method on the component. By specifying &lt;code&gt;Box&amp;lt;dyn Draw&amp;gt;&lt;/code&gt; as the type of the values in the &lt;code&gt;components&lt;/code&gt; vector, we&amp;rsquo;ve defined &lt;code&gt;Screen&lt;/code&gt; to need values that we can call the &lt;code&gt;draw&lt;/code&gt; method on.</source>
          <target state="translated">这个概念（只关注值响应的消息，而不是值的具体类型）类似于动态输入语言中的&lt;em&gt;鸭子（Duck）&lt;/em&gt;概念：如果它走路像鸭子，而鸭子像鸭子，那么它一定是鸭！在清单17-5中的在 &lt;code&gt;Screen&lt;/code&gt; 上 &lt;code&gt;run&lt;/code&gt; 的实现中， &lt;code&gt;run&lt;/code&gt; 不需要知道每个组件的具体类型是什么。它不检查组件是 &lt;code&gt;Button&lt;/code&gt; 还是 &lt;code&gt;SelectBox&lt;/code&gt; 的实例，它只是在组件上调用 &lt;code&gt;draw&lt;/code&gt; 方法。通过指定 &lt;code&gt;Box&amp;lt;dyn Draw&amp;gt;&lt;/code&gt; 作为 &lt;code&gt;components&lt;/code&gt; 向量中值的类型，我们定义了 &lt;code&gt;Screen&lt;/code&gt; 上需要我们可以调用 &lt;code&gt;draw&lt;/code&gt; 方法的值。</target>
        </trans-unit>
        <trans-unit id="80fbf38c87a2fe3d71541d31605bf9ab62ed6238" translate="yes" xml:space="preserve">
          <source>This concept&amp;mdash;of being concerned only with the messages a value responds to rather than the value&amp;rsquo;s concrete type&amp;mdash;is similar to the concept of &lt;em&gt;duck typing&lt;/em&gt; in dynamically typed languages: if it walks like a duck and quacks like a duck, then it must be a duck! In the implementation of &lt;code&gt;run&lt;/code&gt; on &lt;code&gt;Screen&lt;/code&gt; in Listing 17-5, &lt;code&gt;run&lt;/code&gt; doesn&amp;rsquo;t need to know what the concrete type of each component is. It doesn&amp;rsquo;t check whether a component is an instance of a &lt;code&gt;Button&lt;/code&gt; or a &lt;code&gt;SelectBox&lt;/code&gt;, it just calls the &lt;code&gt;draw&lt;/code&gt; method on the component. By specifying &lt;code&gt;Box&amp;lt;dyn Draw&amp;gt;&lt;/code&gt; as the type of the values in the &lt;code&gt;components&lt;/code&gt; vector, we&amp;rsquo;ve defined &lt;code&gt;Screen&lt;/code&gt; to need values that we can call the &lt;code&gt;draw&lt;/code&gt; method on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="918897f830b93edc22b990902ff69a6fc36b08cc" translate="yes" xml:space="preserve">
          <source>This conditional structure lets us support complex requirements. With the hardcoded values we have here, this example will print &lt;code&gt;Using purple as the background color&lt;/code&gt;.</source>
          <target state="translated">这种条件结构使我们能够支持复杂的需求。使用此处具有的硬编码值，此示例将打印 &lt;code&gt;Using purple as the background color&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3dcd38b0035fd15b13996ae1be8e3f24e8144a2a" translate="yes" xml:space="preserve">
          <source>This constant is defined to be &quot;1970-01-01 00:00:00 UTC&quot; on all systems with respect to the system clock. Using &lt;code&gt;duration_since&lt;/code&gt; on an existing &lt;a href=&quot;struct.systemtime&quot;&gt;&lt;code&gt;SystemTime&lt;/code&gt;&lt;/a&gt; instance can tell how far away from this point in time a measurement lies, and using &lt;code&gt;UNIX_EPOCH + duration&lt;/code&gt; can be used to create a &lt;a href=&quot;struct.systemtime&quot;&gt;&lt;code&gt;SystemTime&lt;/code&gt;&lt;/a&gt; instance to represent another fixed point in time.</source>
          <target state="translated">在所有系统上，相对于系统时钟，此常数定义为&amp;ldquo; 1970-01-01 00:00:00 UTC&amp;rdquo;。在现有的&lt;a href=&quot;struct.systemtime&quot;&gt; &lt;code&gt;SystemTime&lt;/code&gt; &lt;/a&gt;实例上使用 &lt;code&gt;duration_since&lt;/code&gt; 可以知道距该时间点的距离，而使用 &lt;code&gt;UNIX_EPOCH + duration&lt;/code&gt; 可以用来创建&lt;a href=&quot;struct.systemtime&quot;&gt; &lt;code&gt;SystemTime&lt;/code&gt; &lt;/a&gt;实例来表示另一个固定时间点。</target>
        </trans-unit>
        <trans-unit id="b5d0e066df6c05d48b8ed4d894544fa1aeed7cdf" translate="yes" xml:space="preserve">
          <source>This constant is defined to be &quot;1970-01-01 00:00:00 UTC&quot; on all systems with respect to the system clock. Using &lt;code&gt;duration_since&lt;/code&gt; on an existing &lt;code&gt;SystemTime&lt;/code&gt; instance can tell how far away from this point in time a measurement lies, and using &lt;code&gt;UNIX_EPOCH + duration&lt;/code&gt; can be used to create a &lt;code&gt;SystemTime&lt;/code&gt; instance to represent another fixed point in time.</source>
          <target state="translated">在所有系统上，相对于系统时钟，此常数定义为&amp;ldquo; 1970-01-01 00:00:00 UTC&amp;rdquo;。在现有的 &lt;code&gt;SystemTime&lt;/code&gt; 实例上使用 &lt;code&gt;duration_since&lt;/code&gt; 可以知道距该时间点的距离，而使用 &lt;code&gt;UNIX_EPOCH + duration&lt;/code&gt; 可以用来创建 &lt;code&gt;SystemTime&lt;/code&gt; 实例来表示另一个固定时间点。</target>
        </trans-unit>
        <trans-unit id="b2173ef48f94c265cfdd9db0c9cedd205cdc4005" translate="yes" xml:space="preserve">
          <source>This construct eliminates a lot of nesting that would be necessary if you used &lt;code&gt;loop&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt;, and &lt;code&gt;break&lt;/code&gt;, and it&amp;rsquo;s clearer. While a condition holds true, the code runs; otherwise, it exits the loop.</source>
          <target state="translated">如果您使用 &lt;code&gt;loop&lt;/code&gt; ， &lt;code&gt;if&lt;/code&gt; ， &lt;code&gt;else&lt;/code&gt; 和 &lt;code&gt;break&lt;/code&gt; ，则此构造消除了很多嵌套的必要，而且更加清楚。当条件成立时，代码将运行；否则，它退出循环。</target>
        </trans-unit>
        <trans-unit id="0f3921b041a98aaf2f8084439e4ed88136086a63" translate="yes" xml:space="preserve">
          <source>This construct is allowed because the first &lt;code&gt;spaces&lt;/code&gt; variable is a string type and the second &lt;code&gt;spaces&lt;/code&gt; variable, which is a brand-new variable that happens to have the same name as the first one, is a number type. Shadowing thus spares us from having to come up with different names, such as &lt;code&gt;spaces_str&lt;/code&gt; and &lt;code&gt;spaces_num&lt;/code&gt;; instead, we can reuse the simpler &lt;code&gt;spaces&lt;/code&gt; name. However, if we try to use &lt;code&gt;mut&lt;/code&gt; for this, as shown here, we&amp;rsquo;ll get a compile-time error:</source>
          <target state="translated">之所以允许这种构造，是因为第一个 &lt;code&gt;spaces&lt;/code&gt; 变量是字符串类型，而第二个空格变量是数字类型，而第二个 &lt;code&gt;spaces&lt;/code&gt; 变量是一个刚好与第一个名称相同的全新变量。因此，阴影使我们免于不得不提出不同的名称，例如 &lt;code&gt;spaces_str&lt;/code&gt; 和 &lt;code&gt;spaces_num&lt;/code&gt; ；相反，我们可以重用更简单的 &lt;code&gt;spaces&lt;/code&gt; 名称。但是，如果我们尝试为此使用 &lt;code&gt;mut&lt;/code&gt; ，如此处所示，则会收到编译时错误：</target>
        </trans-unit>
        <trans-unit id="2fc6477635d5d363ee444b003b473b1635177727" translate="yes" xml:space="preserve">
          <source>This constructor is unsafe because we cannot guarantee that the data pointed to by &lt;code&gt;pointer&lt;/code&gt; is pinned, meaning that the data will not be moved or its storage invalidated until it gets dropped. If the constructed &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; does not guarantee that the data &lt;code&gt;P&lt;/code&gt; points to is pinned, that is a violation of the API contract and may lead to undefined behavior in later (safe) operations.</source>
          <target state="translated">此构造函数是不安全的，因为我们不能保证 &lt;code&gt;pointer&lt;/code&gt; 的数据是固定的，这意味着直到将其删除之前，数据都不会移动或存储无效。如果构造的 &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; 不能保证数据 &lt;code&gt;P&lt;/code&gt; 指向的是固定的，则违反了API约定，并可能在以后的（安全）操作中导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="ff43397602787e15a0f1ce39d92c367ec0e4e2ba" translate="yes" xml:space="preserve">
          <source>This constructor will panic if &lt;code&gt;secs&lt;/code&gt; is not finite, negative or overflows &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;secs&lt;/code&gt; 不是有限的，负数或 &lt;code&gt;Duration&lt;/code&gt; ，则此构造函数将感到恐慌。</target>
        </trans-unit>
        <trans-unit id="62c6e72ea916575b1c7e9925b7cd6a1ec78f970b" translate="yes" xml:space="preserve">
          <source>This constructor will panic if the carry from the nanoseconds overflows the seconds counter.</source>
          <target state="translated">如果来自纳秒的携带量超过了秒计数器,这个构造函数将恐慌。</target>
        </trans-unit>
        <trans-unit id="6b22e102a899811cfc691dccd223a5bfd8615f73" translate="yes" xml:space="preserve">
          <source>This consumes the &lt;code&gt;String&lt;/code&gt; on the left-hand side and re-uses its buffer (growing it if necessary). This is done to avoid allocating a new &lt;code&gt;String&lt;/code&gt; and copying the entire contents on every operation, which would lead to &lt;code&gt;O(n^2)&lt;/code&gt; running time when building an &lt;code&gt;n&lt;/code&gt;-byte string by repeated concatenation.</source>
          <target state="translated">这将消耗左侧的 &lt;code&gt;String&lt;/code&gt; 并重新使用其缓冲区（如有必要，将其增大）。这样做是为了避免分配新的 &lt;code&gt;String&lt;/code&gt; 并在每个操作上复制整个内容，这在通过重复连接构建 &lt;code&gt;n&lt;/code&gt; 字节的字符串时会导致 &lt;code&gt;O(n^2)&lt;/code&gt; 运行时间。</target>
        </trans-unit>
        <trans-unit id="ff15f14738d56f849296682dc30e5c72af4309e0" translate="yes" xml:space="preserve">
          <source>This consumes the &lt;code&gt;String&lt;/code&gt; on the left-hand side and re-uses its buffer (growing it if necessary). This is done to avoid allocating a new &lt;code&gt;String&lt;/code&gt; and copying the entire contents on every operation, which would lead to &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;^2) running time when building an &lt;em&gt;n&lt;/em&gt;-byte string by repeated concatenation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c1a59da820eab802e08d64caefd05fd88b5910a" translate="yes" xml:space="preserve">
          <source>This consumes the &lt;code&gt;String&lt;/code&gt;, so we do not need to copy its contents.</source>
          <target state="translated">这消耗了 &lt;code&gt;String&lt;/code&gt; ，因此我们不需要复制其内容。</target>
        </trans-unit>
        <trans-unit id="bdf3d0a305b0dd41c0720025809f7bbdfc2e29a7" translate="yes" xml:space="preserve">
          <source>This conversion allocates a new error with a simple representation of error kind.</source>
          <target state="translated">这个转换分配了一个新的错误,并对错误种类进行了简单的表示。</target>
        </trans-unit>
        <trans-unit id="680616b748f55e8f2a3a0b7bc442fa697101f3ab" translate="yes" xml:space="preserve">
          <source>This conversion allocates on the heap and performs a copy of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">此转换在堆上分配并执行 &lt;code&gt;s&lt;/code&gt; 的副本。</target>
        </trans-unit>
        <trans-unit id="9a31c836c91541651df449cd7fae82a0fb324fe3" translate="yes" xml:space="preserve">
          <source>This conversion allocates on the heap and performs a copy of &lt;code&gt;slice&lt;/code&gt;.</source>
          <target state="translated">此转换在堆上分配并执行 &lt;code&gt;slice&lt;/code&gt; 的副本。</target>
        </trans-unit>
        <trans-unit id="9fa8116281488d60de9f3c4d7eaa019ecce22d9b" translate="yes" xml:space="preserve">
          <source>This conversion always returns &lt;code&gt;RecvTimeoutError::Disconnected&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1ed0a334eeab7a53114c9e9ec5ed0ef897b2581" translate="yes" xml:space="preserve">
          <source>This conversion always returns &lt;code&gt;TryRecvError::Disconnected&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82865c3f0e8956130ac1b56ac62e2b0276fe13c6" translate="yes" xml:space="preserve">
          <source>This conversion always returns a &lt;code&gt;TrySendError::Disconnected&lt;/code&gt; containing the data in the &lt;code&gt;SendError&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="191fbbeba587abac9c4a996c422eb2e1a86f8da6" translate="yes" xml:space="preserve">
          <source>This conversion creates a &lt;a href=&quot;../net/enum.socketaddr#variant.V4&quot;&gt;&lt;code&gt;SocketAddr::V4&lt;/code&gt;&lt;/a&gt; for a &lt;a href=&quot;../net/enum.ipaddr#variant.V4&quot;&gt;&lt;code&gt;IpAddr::V4&lt;/code&gt;&lt;/a&gt; and creates a &lt;a href=&quot;../net/enum.socketaddr#variant.V6&quot;&gt;&lt;code&gt;SocketAddr::V6&lt;/code&gt;&lt;/a&gt; for a &lt;a href=&quot;../net/enum.ipaddr#variant.V6&quot;&gt;&lt;code&gt;IpAddr::V6&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这种转换将创建一个&lt;a href=&quot;../net/enum.socketaddr#variant.V4&quot;&gt; &lt;code&gt;SocketAddr::V4&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;../net/enum.ipaddr#variant.V4&quot;&gt; &lt;code&gt;IpAddr::V4&lt;/code&gt; &lt;/a&gt;，并创建一个&lt;a href=&quot;../net/enum.socketaddr#variant.V6&quot;&gt; &lt;code&gt;SocketAddr::V6&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;../net/enum.ipaddr#variant.V6&quot;&gt; &lt;code&gt;IpAddr::V6&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e3e202dba3c3f87c15f9baf72668c6b89f20fb13" translate="yes" xml:space="preserve">
          <source>This conversion creates a &lt;a href=&quot;enum.socketaddr#variant.V4&quot;&gt;&lt;code&gt;SocketAddr::V4&lt;/code&gt;&lt;/a&gt; for a &lt;a href=&quot;enum.ipaddr#variant.V4&quot;&gt;&lt;code&gt;IpAddr::V4&lt;/code&gt;&lt;/a&gt; and creates a &lt;a href=&quot;enum.socketaddr#variant.V6&quot;&gt;&lt;code&gt;SocketAddr::V6&lt;/code&gt;&lt;/a&gt; for a &lt;a href=&quot;enum.ipaddr#variant.V6&quot;&gt;&lt;code&gt;IpAddr::V6&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这种转换将创建一个&lt;a href=&quot;enum.socketaddr#variant.V4&quot;&gt; &lt;code&gt;SocketAddr::V4&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;enum.ipaddr#variant.V4&quot;&gt; &lt;code&gt;IpAddr::V4&lt;/code&gt; &lt;/a&gt;，并创建一个&lt;a href=&quot;enum.socketaddr#variant.V6&quot;&gt; &lt;code&gt;SocketAddr::V6&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;enum.ipaddr#variant.V6&quot;&gt; &lt;code&gt;IpAddr::V6&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3b1a65936a10e1c346d064991eab656396fb2bba" translate="yes" xml:space="preserve">
          <source>This conversion currently should not allocate memory, but this behavior is not guaranteed on all platforms or in all future versions.</source>
          <target state="translated">这种转换目前不应该分配内存,但这种行为在所有平台或所有未来版本中都不能保证。</target>
        </trans-unit>
        <trans-unit id="e7f2cebd3b32b1fc620100acfba14583ac5721f8" translate="yes" xml:space="preserve">
          <source>This conversion does not allocate on the heap and happens in place.</source>
          <target state="translated">这种转换不在堆上分配,而是就地发生。</target>
        </trans-unit>
        <trans-unit id="ece3abafa7c5e7855afc6b2c712b92113a0c3cfa" translate="yes" xml:space="preserve">
          <source>This conversion does not allocate or copy memory.</source>
          <target state="translated">这种转换不会分配或复制内存。</target>
        </trans-unit>
        <trans-unit id="bfaed574bc93990621932481bdc991a5d31277ba" translate="yes" xml:space="preserve">
          <source>This conversion happens in-place, and has &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) time complexity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb0a6b0407963e31db76813c54686486ddeb6e67" translate="yes" xml:space="preserve">
          <source>This conversion may entail doing a check for UTF-8 validity.</source>
          <target state="translated">这种转换可能需要对UTF-8的有效性进行检查。</target>
        </trans-unit>
        <trans-unit id="0fd6ab28cb16ba2dd2d81ceb7549687e9cec1f65" translate="yes" xml:space="preserve">
          <source>This conversion may entail doing a check for UTF-8 validity. Note that validation is performed because non-UTF-8 strings are perfectly valid for some OS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8330bc0df78d6eb52dcc8484b74d30aa78ea3703" translate="yes" xml:space="preserve">
          <source>This conversion moves the array to newly heap-allocated memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d8209ee4e143c8cb222975b9c2887b40d4af1c6" translate="yes" xml:space="preserve">
          <source>This conversion requires no data movement or allocation, and has constant time complexity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2f146b8b2fc9fbff68e3aacb1296a0b784db40b" translate="yes" xml:space="preserve">
          <source>This converts the weak pointer into a raw pointer, preserving the original weak count. It can be turned back into the &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; with &lt;a href=&quot;struct.weak#method.from_raw&quot;&gt;&lt;code&gt;from_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这会将弱指针转换为原始指针，从而保留原始的弱计数。可以使用&lt;a href=&quot;struct.weak#method.from_raw&quot;&gt; &lt;code&gt;from_raw&lt;/code&gt; &lt;/a&gt;将其转换为 &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="068161e531a8b3af305ba6f7bb36fd2b7ca30a9c" translate="yes" xml:space="preserve">
          <source>This converts the weak pointer into a raw pointer, while still preserving the ownership of one weak reference (the weak count is not modified by this operation). It can be turned back into the &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; with &lt;a href=&quot;struct.weak#method.from_raw&quot;&gt;&lt;code&gt;from_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c699db8a5191d953bd2f9a766d34a17f9fc7bd1" translate="yes" xml:space="preserve">
          <source>This corresponds to the type returned from a generator either with a &lt;code&gt;return&lt;/code&gt; statement or implicitly as the last expression of a generator literal. For example futures would use this as &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; as it represents a completed future.</source>
          <target state="translated">这对应于从带有 &lt;code&gt;return&lt;/code&gt; 语句的生成器返回的类型，或者隐式地作为生成器文字的最后一个表达式。例如，期货将其用作 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 因为它表示已完成的期货。</target>
        </trans-unit>
        <trans-unit id="4049b3c18034165d976b921c99656187a99b1c48" translate="yes" xml:space="preserve">
          <source>This could be called as &lt;code&gt;&amp;lt;Foo as Foo&amp;gt;::foo()&lt;/code&gt;, which would not be able to pick an implementation.</source>
          <target state="translated">这可以称为 &lt;code&gt;&amp;lt;Foo as Foo&amp;gt;::foo()&lt;/code&gt; ，它将无法选择实现。</target>
        </trans-unit>
        <trans-unit id="287539a4f23b39a26818b82e9ae17d404cfd326d" translate="yes" xml:space="preserve">
          <source>This could be caused by a typo. Did you misspell the macro's name?</source>
          <target state="translated">这可能是打字错误造成的。你是不是拼错了宏的名字?</target>
        </trans-unit>
        <trans-unit id="13b235947bdbb45d737ce6790102efc941982f83" translate="yes" xml:space="preserve">
          <source>This crate primarily contains a &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; type. Procedural macros operate over &lt;em&gt;token streams&lt;/em&gt; instead of AST nodes, which is a far more stable interface over time for both the compiler and for procedural macros to target. A &lt;em&gt;token stream&lt;/em&gt; is roughly equivalent to &lt;code&gt;Vec&amp;lt;TokenTree&amp;gt;&lt;/code&gt; where a &lt;code&gt;TokenTree&lt;/code&gt; can roughly be thought of as lexical token. For example &lt;code&gt;foo&lt;/code&gt; is an &lt;code&gt;Ident&lt;/code&gt; token, &lt;code&gt;.&lt;/code&gt; is a &lt;code&gt;Punct&lt;/code&gt; token, and &lt;code&gt;1.2&lt;/code&gt; is a &lt;code&gt;Literal&lt;/code&gt; token. The &lt;code&gt;TokenStream&lt;/code&gt; type, unlike &lt;code&gt;Vec&amp;lt;TokenTree&amp;gt;&lt;/code&gt;, is cheap to clone.</source>
          <target state="translated">此板条箱主要包含&lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt;类型。程序宏通过&lt;em&gt;令牌流&lt;/em&gt;而不是AST节点进行操作，这对于编译器和程序宏而言都是一个长期稳定的接口。甲&lt;em&gt;令牌流&lt;/em&gt;是大致相当于 &lt;code&gt;Vec&amp;lt;TokenTree&amp;gt;&lt;/code&gt; 其中 &lt;code&gt;TokenTree&lt;/code&gt; 大致可以认为是词法标记。例如 &lt;code&gt;foo&lt;/code&gt; 是一个 &lt;code&gt;Ident&lt;/code&gt; 令牌 &lt;code&gt;.&lt;/code&gt; 是 &lt;code&gt;Punct&lt;/code&gt; 令牌，而 &lt;code&gt;1.2&lt;/code&gt; 是 &lt;code&gt;Literal&lt;/code&gt; 令牌。与 &lt;code&gt;Vec&amp;lt;TokenTree&amp;gt;&lt;/code&gt; 不同， &lt;code&gt;TokenStream&lt;/code&gt; 类型易于克隆。</target>
        </trans-unit>
        <trans-unit id="5fc5d0b91b345a05b4241830102cb300bf80ef47" translate="yes" xml:space="preserve">
          <source>This creates another pointer to the same allocation, increasing the strong reference count.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cff1a339d3f6091f32453655f9ee1f32c7930920" translate="yes" xml:space="preserve">
          <source>This creates another pointer to the same inner value, increasing the strong reference count.</source>
          <target state="translated">这将创建另一个指向相同内值的指针,增加强引用数。</target>
        </trans-unit>
        <trans-unit id="c793b99248db7ed16f6d7097d8baba33c4688bf2" translate="yes" xml:space="preserve">
          <source>This defines a trait with two methods. All values that have &lt;a href=&quot;implementations&quot;&gt;implementations&lt;/a&gt; of this trait while the trait is in scope can have their &lt;code&gt;draw&lt;/code&gt; and &lt;code&gt;bounding_box&lt;/code&gt; methods called.</source>
          <target state="translated">这用两种方法定义了特征。当特征在范围内时，具有该特征的所有&lt;a href=&quot;implementations&quot;&gt;实现&lt;/a&gt;的值都可以调用其 &lt;code&gt;draw&lt;/code&gt; 和 &lt;code&gt;bounding_box&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="1d48ec195193e5a8a6ddc6d7306e5931fc440ce0" translate="yes" xml:space="preserve">
          <source>This definition is similar to the custom derive macro&amp;rsquo;s signature: we receive the tokens that are inside the parentheses and return the code we wanted to generate.</source>
          <target state="translated">此定义类似于自定义衍生宏的签名：我们收到括号内的标记，并返回要生成的代码。</target>
        </trans-unit>
        <trans-unit id="7ec7ae52304bec8c18c92988cc904eba30640fe1" translate="yes" xml:space="preserve">
          <source>This definition should now make more sense to you. As you can see, &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; is an enum that is generic over type &lt;code&gt;T&lt;/code&gt; and has two variants: &lt;code&gt;Some&lt;/code&gt;, which holds one value of type &lt;code&gt;T&lt;/code&gt;, and a &lt;code&gt;None&lt;/code&gt; variant that doesn&amp;rsquo;t hold any value. By using the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; enum, we can express the abstract concept of having an optional value, and because &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; is generic, we can use this abstraction no matter what the type of the optional value is.</source>
          <target state="translated">现在，该定义对您应该更有意义。正如你所看到的， &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 是一个枚举是在类型上是通用 &lt;code&gt;T&lt;/code&gt; ，有两个变种： &lt;code&gt;Some&lt;/code&gt; ，持有型的一个值 &lt;code&gt;T&lt;/code&gt; ，并且 &lt;code&gt;None&lt;/code&gt; 不持有任何价值的变体。通过使用 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 枚举，我们可以表达具有可选值的抽象概念，并且由于 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 是通用的，因此无论可选值的类型是什么，我们都可以使用此抽象。</target>
        </trans-unit>
        <trans-unit id="a1dc77bf501a21c3fcf8fcfdb984f36618d4b9d8" translate="yes" xml:space="preserve">
          <source>This demonstrates that we&amp;rsquo;re now using standard output for successful output and standard error for error output as appropriate.</source>
          <target state="translated">这表明我们现在将标准输出用于成功输出，将标准错误用于错误输出。</target>
        </trans-unit>
        <trans-unit id="fab63306db027b7791c0993bab148aa9b72c14e9" translate="yes" xml:space="preserve">
          <source>This description is obviously informal. Making it more precise is expected to proceed as part of a general effort to specify the Rust type checker more precisely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5155c706e717eca62f9640a389101247c0cf2c80" translate="yes" xml:space="preserve">
          <source>This destructor consists of two components:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0501267bf2be740a305fdf189b227a4c7486d27e" translate="yes" xml:space="preserve">
          <source>This distinction would also exist in an interpreter. Static checks like syntactic analysis, type checking, and lints should happen before the program is executed regardless of when it is executed.</source>
          <target state="translated">这种区别在解释器中也会存在。语法分析、类型检查和lints等静态检查应该在程序执行之前进行,而不是在程序执行的时候进行。</target>
        </trans-unit>
        <trans-unit id="f074ad4712bf36f567466c2e78802eda538edf52" translate="yes" xml:space="preserve">
          <source>This documentation describes a number of methods and trait implementations on the &lt;code&gt;char&lt;/code&gt; type. For technical reasons, there is additional, separate documentation in &lt;a href=&quot;char/index&quot;&gt;the &lt;code&gt;std::char&lt;/code&gt; module&lt;/a&gt; as well.</source>
          <target state="translated">本文档描述了有关 &lt;code&gt;char&lt;/code&gt; 类型的许多方法和特征实现。由于技术原因，还有额外的，单独的文档&lt;a href=&quot;char/index&quot;&gt;中 &lt;code&gt;std::char&lt;/code&gt; 模块&lt;/a&gt;为好。</target>
        </trans-unit>
        <trans-unit id="68839ac29f4116303cf30db2371868d96097990a" translate="yes" xml:space="preserve">
          <source>This does call the argument's implementation of &lt;a href=&quot;../ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这确实调用了参数的&lt;a href=&quot;../ops/trait.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; &lt;/a&gt;的实现。</target>
        </trans-unit>
        <trans-unit id="e9a625eacba45783e02d255cb539fbdd648ae63a" translate="yes" xml:space="preserve">
          <source>This does not include the path to the program as the first argument; it only includes the arguments specified with &lt;a href=&quot;struct.command#method.arg&quot;&gt;&lt;code&gt;Command::arg&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.command#method.args&quot;&gt;&lt;code&gt;Command::args&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46fdf1d9a29edff79b3169310e8e3c74c04e6cd6" translate="yes" xml:space="preserve">
          <source>This does not preserve ordering, but is &lt;em&gt;O&lt;/em&gt;(1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc3143ca0c8ed5c4ad51a7f5632b38d278a744be" translate="yes" xml:space="preserve">
          <source>This does not preserve ordering, but is O(1).</source>
          <target state="translated">这并没有保留排序,但是是O(1)。</target>
        </trans-unit>
        <trans-unit id="302cbd1c584e8c39bda1206e23be2bed7460cc52" translate="yes" xml:space="preserve">
          <source>This does not take ownership of the original allocation and requires no resource management later, but you must not use the pointer after its lifetime.</source>
          <target state="translated">这样做并不占有原始分配的所有权,以后也不需要资源管理,但在指针寿命结束后不得使用。</target>
        </trans-unit>
        <trans-unit id="601f0aa53280d7fb3fab96e73d4cc042d197513d" translate="yes" xml:space="preserve">
          <source>This does so by calling the argument's implementation of &lt;a href=&quot;../ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ec03adb1087f5abb7a8507c877e74407679b28c" translate="yes" xml:space="preserve">
          <source>This doesn't actually allocate if &lt;code&gt;T&lt;/code&gt; is zero-sized.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 大小为零，则实际上不会分配。</target>
        </trans-unit>
        <trans-unit id="1a27813265527dd550d73a565f67475ec4a26516" translate="yes" xml:space="preserve">
          <source>This effectively does nothing for types which implement &lt;code&gt;Copy&lt;/code&gt;, e.g. integers. Such values are copied and &lt;em&gt;then&lt;/em&gt; moved into the function, so the value persists after this function call.</source>
          <target state="translated">对于实现 &lt;code&gt;Copy&lt;/code&gt; 的类型，例如整数，这实际上不起作用。此类值将被复制，&lt;em&gt;然后&lt;/em&gt;移入函数，因此该值在此函数调用后仍然存在。</target>
        </trans-unit>
        <trans-unit id="eb1f652575dd2244737e0203d7e6859c386e1f92" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroI128&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;i128&lt;/code&gt;:</source>
          <target state="translated">这样可以优化一些内存布局。例如， &lt;code&gt;Option&amp;lt;NonZeroI128&amp;gt;&lt;/code&gt; 与 &lt;code&gt;i128&lt;/code&gt; 的大小相同：</target>
        </trans-unit>
        <trans-unit id="f67f6cc0c2c10dc19997b3839443098a644f1d26" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroI16&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;i16&lt;/code&gt;:</source>
          <target state="translated">这样可以优化一些内存布局。例如， &lt;code&gt;Option&amp;lt;NonZeroI16&amp;gt;&lt;/code&gt; 与 &lt;code&gt;i16&lt;/code&gt; 的大小相同：</target>
        </trans-unit>
        <trans-unit id="734061adf87b0795fad2886322ea47c0aec2f2ad" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroI32&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;i32&lt;/code&gt;:</source>
          <target state="translated">这样可以优化一些内存布局。例如， &lt;code&gt;Option&amp;lt;NonZeroI32&amp;gt;&lt;/code&gt; 与 &lt;code&gt;i32&lt;/code&gt; 的大小相同：</target>
        </trans-unit>
        <trans-unit id="00340c6c435ce7c1fdb4cf194be81cf07905d3dd" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroI64&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;i64&lt;/code&gt;:</source>
          <target state="translated">这样可以优化一些内存布局。例如， &lt;code&gt;Option&amp;lt;NonZeroI64&amp;gt;&lt;/code&gt; 与 &lt;code&gt;i64&lt;/code&gt; 的大小相同：</target>
        </trans-unit>
        <trans-unit id="278e3b6e04cd3eac83950c68db7f2e8e510eb775" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroI8&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;i8&lt;/code&gt;:</source>
          <target state="translated">这样可以优化一些内存布局。例如， &lt;code&gt;Option&amp;lt;NonZeroI8&amp;gt;&lt;/code&gt; 与 &lt;code&gt;i8&lt;/code&gt; 的大小相同：</target>
        </trans-unit>
        <trans-unit id="d6a41567af1e9968e9c90e92ec21b8804316cfe8" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroIsize&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;isize&lt;/code&gt;:</source>
          <target state="translated">这样可以优化一些内存布局。例如， &lt;code&gt;Option&amp;lt;NonZeroIsize&amp;gt;&lt;/code&gt; 与 &lt;code&gt;isize&lt;/code&gt; 的大小相同：</target>
        </trans-unit>
        <trans-unit id="cf2e6ed40009c7af3e4c82c9a64e0f2f0797bce2" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroU128&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;u128&lt;/code&gt;:</source>
          <target state="translated">这样可以优化一些内存布局。例如， &lt;code&gt;Option&amp;lt;NonZeroU128&amp;gt;&lt;/code&gt; 与 &lt;code&gt;u128&lt;/code&gt; 的大小相同：</target>
        </trans-unit>
        <trans-unit id="76da8b2ba60cec40f8f5e62e107f1dbcb755bbbb" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroU16&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;u16&lt;/code&gt;:</source>
          <target state="translated">这样可以优化一些内存布局。例如， &lt;code&gt;Option&amp;lt;NonZeroU16&amp;gt;&lt;/code&gt; 与 &lt;code&gt;u16&lt;/code&gt; 的大小相同：</target>
        </trans-unit>
        <trans-unit id="ccbf5b5bf97bc9198c28f18b82543d27c5b27285" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroU32&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;u32&lt;/code&gt;:</source>
          <target state="translated">这样可以优化一些内存布局。例如， &lt;code&gt;Option&amp;lt;NonZeroU32&amp;gt;&lt;/code&gt; 是大小为相同 &lt;code&gt;u32&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="538d2876995cecf5e64928ddfeb01ab1a800bbde" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroU64&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;u64&lt;/code&gt;:</source>
          <target state="translated">这样可以优化一些内存布局。例如， &lt;code&gt;Option&amp;lt;NonZeroU64&amp;gt;&lt;/code&gt; 与 &lt;code&gt;u64&lt;/code&gt; 的大小相同：</target>
        </trans-unit>
        <trans-unit id="d0129491a9c802e31402a256b2ed3248526999bd" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroU8&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;u8&lt;/code&gt;:</source>
          <target state="translated">这样可以优化一些内存布局。例如， &lt;code&gt;Option&amp;lt;NonZeroU8&amp;gt;&lt;/code&gt; 与 &lt;code&gt;u8&lt;/code&gt; 的大小相同：</target>
        </trans-unit>
        <trans-unit id="444ef8a1b6149aa40edb45ac918d2fcc6dd0e6a5" translate="yes" xml:space="preserve">
          <source>This enables some memory layout optimization. For example, &lt;code&gt;Option&amp;lt;NonZeroUsize&amp;gt;&lt;/code&gt; is the same size as &lt;code&gt;usize&lt;/code&gt;:</source>
          <target state="translated">这样可以优化一些内存布局。例如， &lt;code&gt;Option&amp;lt;NonZeroUsize&amp;gt;&lt;/code&gt; 与 &lt;code&gt;usize&lt;/code&gt; 的大小相同：</target>
        </trans-unit>
        <trans-unit id="05b9c29faea2a683215e0b23ceda6c29cb84253c" translate="yes" xml:space="preserve">
          <source>This enum can contain either an &lt;a href=&quot;struct.ipv4addr&quot;&gt;&lt;code&gt;Ipv4Addr&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;struct.ipv6addr&quot;&gt;&lt;code&gt;Ipv6Addr&lt;/code&gt;&lt;/a&gt;, see their respective documentation for more details.</source>
          <target state="translated">该枚举可以包含&lt;a href=&quot;struct.ipv4addr&quot;&gt; &lt;code&gt;Ipv4Addr&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;struct.ipv6addr&quot;&gt; &lt;code&gt;Ipv6Addr&lt;/code&gt; &lt;/a&gt;，有关更多详细信息，请参见其各自的文档。</target>
        </trans-unit>
        <trans-unit id="760b8f1ec007bba813777fc9f56dd941c92b8841" translate="yes" xml:space="preserve">
          <source>This enum has four variants with different types:</source>
          <target state="translated">这个枚举有四个不同类型的变体。</target>
        </trans-unit>
        <trans-unit id="ced6caa3ad1703b55bcd5c2e59bf560b6691cb01" translate="yes" xml:space="preserve">
          <source>This enum has the same role as &lt;a href=&quot;../primitive.never&quot;&gt;the &lt;code&gt;!&lt;/code&gt; &amp;ldquo;never&amp;rdquo; type&lt;/a&gt;, which is unstable in this version of Rust. When &lt;code&gt;!&lt;/code&gt; is stabilized, we plan to make &lt;code&gt;Infallible&lt;/code&gt; a type alias to it:</source>
          <target state="translated">该枚举&lt;a href=&quot;../primitive.never&quot;&gt;与 &lt;code&gt;!&lt;/code&gt; 的&lt;/a&gt;作用相同。&amp;ldquo;从不&amp;rdquo;类型，在此版本的Rust中不稳定。什么时候 &lt;code&gt;!&lt;/code&gt; 稳定之后，我们计划将 &lt;code&gt;Infallible&lt;/code&gt; 设为它的类型别名：</target>
        </trans-unit>
        <trans-unit id="6ee104c9c1676af30fcb1ff39c18e2ed9e455f59" translate="yes" xml:space="preserve">
          <source>This enum is returned from the &lt;code&gt;Generator::resume&lt;/code&gt; method and indicates the possible return values of a generator. Currently this corresponds to either a suspension point (&lt;code&gt;Yielded&lt;/code&gt;) or a termination point (&lt;code&gt;Complete&lt;/code&gt;).</source>
          <target state="translated">该枚举从 &lt;code&gt;Generator::resume&lt;/code&gt; 方法返回，并指示生成器的可能返回值。当前，它对应于一个悬挂点（ &lt;code&gt;Yielded&lt;/code&gt; ）或一个终止点（ &lt;code&gt;Complete&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1703fcf1fccea6643fefc20e49e4c80e84f95499" translate="yes" xml:space="preserve">
          <source>This enumeration is the list of possible errors that made &lt;a href=&quot;struct.receiver#method.recv_timeout&quot;&gt;&lt;code&gt;recv_timeout&lt;/code&gt;&lt;/a&gt; unable to return data when called. This can occur with both a &lt;a href=&quot;fn.channel&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt; and a &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此枚举是导致&lt;a href=&quot;struct.receiver#method.recv_timeout&quot;&gt; &lt;code&gt;recv_timeout&lt;/code&gt; &lt;/a&gt;在调用时无法返回数据的可能错误的列表。这可能同时发生在&lt;a href=&quot;fn.channel&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; 上&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cbe05c4f5a229c7e20d58b03f49460f0df3da02f" translate="yes" xml:space="preserve">
          <source>This enumeration is the list of the possible error outcomes for the &lt;a href=&quot;struct.syncsender#method.try_send&quot;&gt;&lt;code&gt;try_send&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">此枚举是&lt;a href=&quot;struct.syncsender#method.try_send&quot;&gt; &lt;code&gt;try_send&lt;/code&gt; &lt;/a&gt;方法的可能错误结果列表。</target>
        </trans-unit>
        <trans-unit id="6dc63139830daa8f080f2bf636d153d6ed98ad21" translate="yes" xml:space="preserve">
          <source>This enumeration is the list of the possible reasons that &lt;a href=&quot;struct.receiver#method.try_recv&quot;&gt;&lt;code&gt;try_recv&lt;/code&gt;&lt;/a&gt; could not return data when called. This can occur with both a &lt;a href=&quot;fn.channel&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt; and a &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此枚举是&lt;a href=&quot;struct.receiver#method.try_recv&quot;&gt; &lt;code&gt;try_recv&lt;/code&gt; &lt;/a&gt;在调用时无法返回数据的可能原因的列表。这可能同时发生在&lt;a href=&quot;fn.channel&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; 上&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c1093396faf4de8ad558d41dcf5187f56b3280a8" translate="yes" xml:space="preserve">
          <source>This error also frequently arises with iteration:</source>
          <target state="translated">迭代时也经常出现这种错误。</target>
        </trans-unit>
        <trans-unit id="94b9a993ad00befb67d90a954bbd93d2df863b1b" translate="yes" xml:space="preserve">
          <source>This error appears when the curly braces contain an identifier which doesn't match with any of the type parameters or the string &lt;code&gt;Self&lt;/code&gt;. This might happen if you misspelled a type parameter, or if you intended to use literal curly braces. If it is the latter, escape the curly braces with a second curly brace of the same type; e.g., a literal &lt;code&gt;{&lt;/code&gt; is &lt;code&gt;{{&lt;/code&gt;.</source>
          <target state="translated">当花括号包含与任何类型参数或字符串 &lt;code&gt;Self&lt;/code&gt; 不匹配的标识符时，将出现此错误。如果您拼写了一个类型参数，或者打算使用文字花括号，则可能会发生这种情况。如果是后者，则用另一个相同类型的花括号将花括号转义；例如，文字 &lt;code&gt;{&lt;/code&gt; 是 &lt;code&gt;{{&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="584182c12fbcdc7236283566d4fe892f8514a84a" translate="yes" xml:space="preserve">
          <source>This error appears when the curly braces do not contain an identifier. Please add one of the same name as a type parameter. If you intended to use literal braces, use &lt;code&gt;{{&lt;/code&gt; and &lt;code&gt;}}&lt;/code&gt; to escape them.</source>
          <target state="translated">当花括号不包含标识符时，会出现此错误。请添加一个与类型参数相同的名称。如果打算使用文字大括号，请使用 &lt;code&gt;{{&lt;/code&gt; 和 &lt;code&gt;}}&lt;/code&gt; 对其进行转义。</target>
        </trans-unit>
        <trans-unit id="0250b09263b0cf211b3144438a4935e1e43d799a" translate="yes" xml:space="preserve">
          <source>This error can be fixed by changing &lt;code&gt;demo&lt;/code&gt; so that the destructor does not run while the string-data is borrowed; for example by taking &lt;code&gt;S&lt;/code&gt; by reference:</source>
          <target state="translated">可以通过更改 &lt;code&gt;demo&lt;/code&gt; 来解决此错误，以使借用字符串数据时析构函数不会运行。例如，以 &lt;code&gt;S&lt;/code&gt; 为参考：</target>
        </trans-unit>
        <trans-unit id="cf00137495add2df4af51c96509efb72f8de11bd" translate="yes" xml:space="preserve">
          <source>This error can be fixed by creating a reference to the fields of a struct, enum, or tuple using the &lt;code&gt;ref&lt;/code&gt; keyword:</source>
          <target state="translated">可以通过使用 &lt;code&gt;ref&lt;/code&gt; 关键字创建对struct，enum或tuple的字段的引用来解决此错误：</target>
        </trans-unit>
        <trans-unit id="0dff7bc132443224671e948d9ffe4c7e1624395f" translate="yes" xml:space="preserve">
          <source>This error can be fixed by fully reinitializing the structure in question:</source>
          <target state="translated">这个错误可以通过完全重新初始化相关结构来解决。</target>
        </trans-unit>
        <trans-unit id="9c719c44866ac61477960cb8b276b7f76f8c6533" translate="yes" xml:space="preserve">
          <source>This error can be fixed by making the container mutable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="413b5d16e5f0759b900c5fe5dc8c6c4f80d50366" translate="yes" xml:space="preserve">
          <source>This error can be solved by adding type annotations that provide the missing information to the compiler. In this case, the solution is to use a concrete type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f0e10eb9c6b47c452a0e1f4fb8a082452a2d703" translate="yes" xml:space="preserve">
          <source>This error code indicates a mismatch between the lifetimes appearing in the function signature (i.e., the parameter types and the return type) and the data-flow found in the function body.</source>
          <target state="translated">这个错误代码表示函数签名中出现的寿命(即参数类型和返回类型)与函数主体中的数据流不匹配。</target>
        </trans-unit>
        <trans-unit id="21caa47590bc7c04cd88dfba7269f8c13368e7a3" translate="yes" xml:space="preserve">
          <source>This error generally appears when two items with the same name are imported into a module. Here, the &lt;code&gt;foo&lt;/code&gt; functions are imported and reexported from the &lt;code&gt;collider&lt;/code&gt; module and therefore, when we're using &lt;code&gt;collider::foo()&lt;/code&gt;, both functions collide.</source>
          <target state="translated">当两个具有相同名称的项目导入模块时，通常会出现此错误。在这里， &lt;code&gt;foo&lt;/code&gt; 函数是从 &lt;code&gt;collider&lt;/code&gt; 模块导入和重新导出的，因此，当我们使用 &lt;code&gt;collider::foo()&lt;/code&gt; ，两个函数都会碰撞。</target>
        </trans-unit>
        <trans-unit id="3dfae522bf711393bcf17e2c72e0d218bd40909c" translate="yes" xml:space="preserve">
          <source>This error indicates a type mismatch in closure arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f7e9e73655654d551ddbe67dfdca41396aade3d" translate="yes" xml:space="preserve">
          <source>This error indicates a violation of one of Rust's orphan rules for trait implementations. The rule concerns the use of type parameters in an implementation of a foreign trait (a trait defined in another crate), and states that type parameters must be &quot;covered&quot; by a local type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5926fa6825473ce8b14051d29bff524913459d93" translate="yes" xml:space="preserve">
          <source>This error indicates a violation of one of Rust's orphan rules for trait implementations. The rule concerns the use of type parameters in an implementation of a foreign trait (a trait defined in another crate), and states that type parameters must be &quot;covered&quot; by a local type. To understand what this means, it is perhaps easiest to consider a few examples.</source>
          <target state="translated">这个错误表明违反了Rust对trait实现的一个孤儿规则。这条规则涉及到在一个外来trait(在另一个箱子中定义的trait)的实现中使用类型参数,并指出类型参数必须由本地类型 &quot;覆盖&quot;。要理解这意味着什么,也许最简单的方法就是看几个例子。</target>
        </trans-unit>
        <trans-unit id="62c66f8f6d53d3993670c86c1f09308676282e5b" translate="yes" xml:space="preserve">
          <source>This error indicates a violation of one of Rust's orphan rules for trait implementations. The rule prohibits any implementation of a foreign trait (a trait defined in another crate) where</source>
          <target state="translated">这个错误表明违反了Rust对trait实现的一个孤儿规则。该规则禁止在以下情况下实现外来特质(在另一个箱子中定义的特质)。</target>
        </trans-unit>
        <trans-unit id="447a5e9fa4c8cf25c5cd5302f4311b3fbd33ec5e" translate="yes" xml:space="preserve">
          <source>This error indicates that a &lt;code&gt;#[lang = &quot;..&quot;]&lt;/code&gt; attribute was placed on the wrong type of item.</source>
          <target state="translated">此错误表明在错误的项目类型上放置了一个 &lt;code&gt;#[lang = &quot;..&quot;]&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="04b6c6e07e059a0181ccbe377eeeabdfa436d081" translate="yes" xml:space="preserve">
          <source>This error indicates that a &lt;code&gt;#[non_exhaustive]&lt;/code&gt; attribute was incorrectly placed on something other than a struct or enum.</source>
          <target state="translated">该错误表明 &lt;code&gt;#[non_exhaustive]&lt;/code&gt; 属性被错误地放置在struct或enum以外的其他对象上。</target>
        </trans-unit>
        <trans-unit id="7022f431bbd32573cf9101aaa229f54136c6e815" translate="yes" xml:space="preserve">
          <source>This error indicates that a &lt;code&gt;#[repr(..)]&lt;/code&gt; attribute was placed on an unsupported item.</source>
          <target state="translated">此错误表明 &lt;code&gt;#[repr(..)]&lt;/code&gt; 属性被放置在不受支持的项目上。</target>
        </trans-unit>
        <trans-unit id="ca9d1588d95295137d9296e3cc73990ee881720a" translate="yes" xml:space="preserve">
          <source>This error indicates that a binary assignment operator like &lt;code&gt;+=&lt;/code&gt; or &lt;code&gt;^=&lt;/code&gt; was applied to a type that doesn't support it. For example:</source>
          <target state="translated">此错误表明，将二进制赋值运算符（例如 &lt;code&gt;+=&lt;/code&gt; 或 &lt;code&gt;^=&lt;/code&gt; ）应用于了不支持它的类型。例如：</target>
        </trans-unit>
        <trans-unit id="942586ad68f246da14ea422c40de5e3f0b9face6" translate="yes" xml:space="preserve">
          <source>This error indicates that a incorrect visibility restriction was specified.</source>
          <target state="translated">该错误表明指定的可见性限制不正确。</target>
        </trans-unit>
        <trans-unit id="0ed5220e5bb81a5a254920c1211412f9ef92a217" translate="yes" xml:space="preserve">
          <source>This error indicates that a lifetime is missing from a type. If it is an error inside a function signature, the problem may be with failing to adhere to the lifetime elision rules (see below).</source>
          <target state="translated">该错误表明,类型中缺少了一个生命周期,如果是函数签名中的错误,那么问题可能是没有遵守生命周期的删除规则(见下文)。如果是函数签名中的错误,问题可能是没有遵守生命周期的删除规则(见下文)。</target>
        </trans-unit>
        <trans-unit id="163c07e3082230bfd9dd310e7a36d455707b90b1" translate="yes" xml:space="preserve">
          <source>This error indicates that a mutable variable is being used while it is still captured by a closure. Because the closure has borrowed the variable, it is not available for use until the closure goes out of scope.</source>
          <target state="translated">这个错误表明,当一个可变的变量仍被闭包捕获时,它正在被使用。因为闭包已经借用了这个变量,所以在闭包退出范围之前,这个变量是不能使用的。</target>
        </trans-unit>
        <trans-unit id="5f5aeaeedbb41e69e7d361beb7e7f664611c650d" translate="yes" xml:space="preserve">
          <source>This error indicates that a mutable variable is used while it is still captured by a closure. Because the closure has borrowed the variable, it is not available until the closure goes out of scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f276e617d109dc1e2831917bc3e9ec17e8a46ef1" translate="yes" xml:space="preserve">
          <source>This error indicates that a pattern for a struct fails to specify a sub-pattern for every one of the struct's fields. Ensure that each field from the struct's definition is mentioned in the pattern, or use &lt;code&gt;..&lt;/code&gt; to ignore unwanted fields.</source>
          <target state="translated">此错误表明结构的模式无法为该结构的每个字段指定子模式。确保模式中提到结构定义中的每个字段，或使用 &lt;code&gt;..&lt;/code&gt; 忽略不需要的字段。</target>
        </trans-unit>
        <trans-unit id="cf2673db078cb233aef2cf4d975d04209851d888" translate="yes" xml:space="preserve">
          <source>This error indicates that a pointer to a trait type cannot be implicitly dereferenced by a pattern. Every trait defines a type, but because the size of trait implementors isn't fixed, this type has no compile-time size. Therefore, all accesses to trait types must be through pointers. If you encounter this error you should try to avoid dereferencing the pointer.</source>
          <target state="translated">这个错误表明指向trait类型的指针不能被模式隐式地导出引用。每个trait都定义了一个类型,但由于trait实现者的大小并不固定,这个类型没有编译时的大小。因此,所有对trait类型的访问都必须通过指针。如果遇到这个错误,你应该尽量避免去引用指针。</target>
        </trans-unit>
        <trans-unit id="828017bc333a648d7ba2ba05b6d8defb66538498" translate="yes" xml:space="preserve">
          <source>This error indicates that a struct pattern attempted to extract a non-existent field from a struct. Struct fields are identified by the name used before the colon &lt;code&gt;:&lt;/code&gt; so struct patterns should resemble the declaration of the struct type being matched.</source>
          <target state="translated">此错误表明结构模式试图从结构中提取不存在的字段。结构字段由冒号之前使用的名称标识 &lt;code&gt;:&lt;/code&gt; 因此结构模式应类似于所匹配结构类型的声明。</target>
        </trans-unit>
        <trans-unit id="8fe4ff510197fbaaaaa06c8b33b203c1e4dc7f1a" translate="yes" xml:space="preserve">
          <source>This error indicates that a temporary value is being dropped while a borrow is still in active use.</source>
          <target state="translated">该错误表明,当借款仍在使用中时,一个临时值正在被删除。</target>
        </trans-unit>
        <trans-unit id="29f636e2d8527491e9c968890f3142a6d2d79a49" translate="yes" xml:space="preserve">
          <source>This error indicates that a type or lifetime parameter has been declared but not actually used. Here is an example that demonstrates the error:</source>
          <target state="translated">这个错误表明类型或寿命参数已经声明,但没有实际使用。下面是一个证明该错误的例子。</target>
        </trans-unit>
        <trans-unit id="021899c7481112f5b1115194dfebb6c6433d75e6" translate="yes" xml:space="preserve">
          <source>This error indicates that a variable usage inside an inner function is invalid because the variable comes from a dynamic environment. Inner functions do not have access to their containing environment.</source>
          <target state="translated">该错误表明内部函数中的变量使用无效,因为该变量来自动态环境。内部函数不能访问其包含的环境。</target>
        </trans-unit>
        <trans-unit id="ee2b7895f62fe245340d50c3f8c134d38d139ea0" translate="yes" xml:space="preserve">
          <source>This error indicates that an &lt;code&gt;#[inline(..)]&lt;/code&gt; attribute was incorrectly placed on something other than a function or method.</source>
          <target state="translated">此错误表明 &lt;code&gt;#[inline(..)]&lt;/code&gt; 属性被错误地放置在函数或方法以外的其他东西上。</target>
        </trans-unit>
        <trans-unit id="b354ce81cf352c1f70206a250c5709ec2f51795d" translate="yes" xml:space="preserve">
          <source>This error indicates that an attempted implementation of a trait method has the wrong number of function parameters.</source>
          <target state="translated">该错误表明,一个特质方法的尝试实现有错误的函数参数数量。</target>
        </trans-unit>
        <trans-unit id="e0c31ba5c6bda555cd8ea81a836bf176c496c77b" translate="yes" xml:space="preserve">
          <source>This error indicates that an attempted implementation of a trait method has the wrong number of type or const parameters.</source>
          <target state="translated">该错误表明,试图实现的特质方法的类型或const参数数量错误。</target>
        </trans-unit>
        <trans-unit id="b75e5fdc31d31d1c4e71b1b39da466c4c14335c3" translate="yes" xml:space="preserve">
          <source>This error indicates that an empty match expression is invalid because the type it is matching on is non-empty (there exist values of this type). In safe code it is impossible to create an instance of an empty type, so empty match expressions are almost never desired. This error is typically fixed by adding one or more cases to the match expression.</source>
          <target state="translated">这个错误表明空匹配表达式无效,因为它所匹配的类型是非空的(存在该类型的值)。在安全代码中,不可能创建一个空类型的实例,所以几乎不希望使用空匹配表达式。这个错误通常通过在匹配表达式中添加一个或多个情况来解决。</target>
        </trans-unit>
        <trans-unit id="aa5d0ed3544dd02116d741311bf5dc31cbf1e877" translate="yes" xml:space="preserve">
          <source>This error indicates that during an attempt to build a struct or struct-like enum variant, one of the fields was not provided. Erroneous code example:</source>
          <target state="translated">该错误表明,在尝试构建一个结构或类似结构的枚举变体时,其中一个字段没有提供。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="4fe613edd2e0d9ed1781cdd172cb95fcc86dda95" translate="yes" xml:space="preserve">
          <source>This error indicates that during an attempt to build a struct or struct-like enum variant, one of the fields was specified more than once. Each field should be specified exactly one time. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e8ed17cc79bcd070351fc2c779882f025c94d0d" translate="yes" xml:space="preserve">
          <source>This error indicates that during an attempt to build a struct or struct-like enum variant, one of the fields was specified more than once. Erroneous code example:</source>
          <target state="translated">该错误表明,在尝试构建结构或类结构枚举变体的过程中,其中一个字段被指定了一次以上。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="184a0c9f21c2159367397ab03b1af11810a4b7a9" translate="yes" xml:space="preserve">
          <source>This error indicates that next we need to create an associated function named &lt;code&gt;new&lt;/code&gt; for &lt;code&gt;ThreadPool&lt;/code&gt;. We also know that &lt;code&gt;new&lt;/code&gt; needs to have one parameter that can accept &lt;code&gt;4&lt;/code&gt; as an argument and should return a &lt;code&gt;ThreadPool&lt;/code&gt; instance. Let&amp;rsquo;s implement the simplest &lt;code&gt;new&lt;/code&gt; function that will have those characteristics:</source>
          <target state="translated">此错误表明，接下来我们需要为 &lt;code&gt;ThreadPool&lt;/code&gt; 创建一个名为 &lt;code&gt;new&lt;/code&gt; 的关联函数。我们也知道， &lt;code&gt;new&lt;/code&gt; 需要有一个可以接受 &lt;code&gt;4&lt;/code&gt; 作为参数的参数，并且应该返回 &lt;code&gt;ThreadPool&lt;/code&gt; 实例。让我们实现具有这些特征的最简单的 &lt;code&gt;new&lt;/code&gt; 功能：</target>
        </trans-unit>
        <trans-unit id="2dad13e650883f25d2104ae52eca1fef407497bf" translate="yes" xml:space="preserve">
          <source>This error indicates that not enough type parameters were found in a type or trait.</source>
          <target state="translated">该错误表明在类型或特征中没有找到足够的类型参数。</target>
        </trans-unit>
        <trans-unit id="ca21a72c98d3df2023442d374a3dadbb098c691b" translate="yes" xml:space="preserve">
          <source>This error indicates that some types or traits depend on each other and therefore cannot be constructed.</source>
          <target state="translated">该错误表明,一些类型或特征相互依赖,因此无法构建。</target>
        </trans-unit>
        <trans-unit id="04671a501f0a2d188e9fcc11f1a02fbc634b9fe6" translate="yes" xml:space="preserve">
          <source>This error indicates that the bindings in a match arm would require a value to be moved into more than one location, thus violating unique ownership. Code like the following is invalid as it requires the entire &lt;code&gt;Option&amp;lt;String&amp;gt;&lt;/code&gt; to be moved into a variable called &lt;code&gt;op_string&lt;/code&gt; while simultaneously requiring the inner &lt;code&gt;String&lt;/code&gt; to be moved into a variable called &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">此错误表明匹配臂中的绑定需要将值移到多个位置，从而违反了唯一所有权。如下所示的代码无效，因为它要求将整个 &lt;code&gt;Option&amp;lt;String&amp;gt;&lt;/code&gt; 移入名为 &lt;code&gt;op_string&lt;/code&gt; 的变量，同时要求将内部 &lt;code&gt;String&lt;/code&gt; 移入名为 &lt;code&gt;s&lt;/code&gt; 的变量。</target>
        </trans-unit>
        <trans-unit id="0593569b391769294fc0cbd6c435421f4f05566e" translate="yes" xml:space="preserve">
          <source>This error indicates that the compiler cannot guarantee a matching pattern for one or more possible inputs to a match expression. Guaranteed matches are required in order to assign values to match expressions, or alternatively, determine the flow of execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6ec80fb058ca19fb5e7892d541e007d08b04d8f" translate="yes" xml:space="preserve">
          <source>This error indicates that the compiler cannot guarantee a matching pattern for one or more possible inputs to a match expression. Guaranteed matches are required in order to assign values to match expressions, or alternatively, determine the flow of execution. Erroneous code example:</source>
          <target state="translated">该错误表明编译器无法保证匹配表达式的一个或多个可能输入的匹配模式。为了给匹配表达式赋值,或者确定执行流程,需要保证匹配。错误的代码示例。</target>
        </trans-unit>
        <trans-unit id="561856cda5e25152013aec070f3d54bab7aa1df8" translate="yes" xml:space="preserve">
          <source>This error indicates that the compiler found multiple functions with the &lt;code&gt;#[main]&lt;/code&gt; attribute. This is an error because there must be a unique entry point into a Rust program. Example:</source>
          <target state="translated">该错误表明编译器使用 &lt;code&gt;#[main]&lt;/code&gt; 属性找到了多个函数。这是一个错误，因为在Rust程序中必须有一个唯一的入口点。例：</target>
        </trans-unit>
        <trans-unit id="5bea3375dcc80f531e3766516bd9f6d7115c2ccf" translate="yes" xml:space="preserve">
          <source>This error indicates that the compiler found multiple functions with the &lt;code&gt;#[start]&lt;/code&gt; attribute. This is an error because there must be a unique entry point into a Rust program. Example:</source>
          <target state="translated">该错误表明编译器使用 &lt;code&gt;#[start]&lt;/code&gt; 属性找到了多个函数。这是一个错误，因为在Rust程序中必须有一个唯一的入口点。例：</target>
        </trans-unit>
        <trans-unit id="8f30ae6ab3b3757a6fafd59d7ba821bfd1db82b1" translate="yes" xml:space="preserve">
          <source>This error indicates that the compiler was unable to sensibly evaluate a constant expression that had to be evaluated. Attempting to divide by 0 or causing an integer overflow are two ways to induce this error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f36d8b8d1d8446198729b807cb2a4a2419af004e" translate="yes" xml:space="preserve">
          <source>This error indicates that the compiler was unable to sensibly evaluate an constant expression that had to be evaluated. Attempting to divide by 0 or causing integer overflow are two ways to induce this error. For example:</source>
          <target state="translated">这个错误表明编译器无法合理地评估一个必须要评估的常量表达式。试图除以0或导致整数溢出是诱发此错误的两种方式。例如</target>
        </trans-unit>
        <trans-unit id="6a1e2255560b86b2d9499ff55662d827b519b332" translate="yes" xml:space="preserve">
          <source>This error indicates that the numeric value for the method being passed exists but the type of the numeric value or binding could not be identified.</source>
          <target state="translated">该错误表明,被传递的方法的数值存在,但无法识别数值或绑定的类型。</target>
        </trans-unit>
        <trans-unit id="148347b598d68fa69c31f92c37c1da55d76c0063" translate="yes" xml:space="preserve">
          <source>This error indicates that the struct, enum or enum variant cannot be instantiated from outside of the defining crate as it has been marked as &lt;code&gt;non_exhaustive&lt;/code&gt; and as such more fields/variants may be added in future that could cause adverse side effects for this code.</source>
          <target state="translated">此错误表明struct，enum或enum变体无法从定义的板条箱外部实例化，因为它已被标记 &lt;code&gt;non_exhaustive&lt;/code&gt; ，因此将来可能会添加更多字段/变体，可能对此代码产生不利的副作用。</target>
        </trans-unit>
        <trans-unit id="fcad2c51ea5b37a57bae2601eed616fe3e726b2e" translate="yes" xml:space="preserve">
          <source>This error indicates that the struct, enum or enum variant must be matched non-exhaustively as it has been marked as &lt;code&gt;non_exhaustive&lt;/code&gt;.</source>
          <target state="translated">此错误表明struct，enum或enum变体必须完全穷尽地匹配，因为它已被标记为 &lt;code&gt;non_exhaustive&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="37c7a2a28ca533246457e808e16c999f3f050492" translate="yes" xml:space="preserve">
          <source>This error indicates that there is a mismatch between generic parameters and impl Trait parameters in a trait declaration versus its impl.</source>
          <target state="translated">该错误表明,在trait声明中的通用参数和 impl Trait参数与其 impl之间不匹配。</target>
        </trans-unit>
        <trans-unit id="51a28020fb3170ca33d27d23beb6ff4c2ae9ce5c" translate="yes" xml:space="preserve">
          <source>This error indicates that too many type parameters were found in a type or trait.</source>
          <target state="translated">该错误表明,在类型或性状中发现了太多的类型参数。</target>
        </trans-unit>
        <trans-unit id="52a40c02e70b32e434b6bbe135867f805601219b" translate="yes" xml:space="preserve">
          <source>This error indicates that type inference did not result in one unique possible type, and extra information is required. In most cases this can be provided by adding a type annotation. Sometimes you need to specify a generic type parameter manually.</source>
          <target state="translated">这个错误表明,类型推理没有得出一个唯一的可能类型,需要额外的信息。在大多数情况下,这可以通过添加类型注释来提供。有时您需要手动指定一个通用类型参数。</target>
        </trans-unit>
        <trans-unit id="4c3b94702358e1162bf8effa04b8b4b7e098714c" translate="yes" xml:space="preserve">
          <source>This error indicates that you are trying to borrow a variable as mutable when it has already been borrowed as immutable.</source>
          <target state="translated">这个错误表明,你正试图将一个变量借用为可变型,而它已经被借用为不可变型。</target>
        </trans-unit>
        <trans-unit id="5d266dd2a168d28b90102ea5f40d828bae3909b4" translate="yes" xml:space="preserve">
          <source>This error indicates the use of a loop keyword (&lt;code&gt;break&lt;/code&gt; or &lt;code&gt;continue&lt;/code&gt;) inside a closure but outside of any loop. Erroneous code example:</source>
          <target state="translated">此错误表示在闭包内但在任何循环外都使用了循环关键字（ &lt;code&gt;break&lt;/code&gt; 或 &lt;code&gt;continue&lt;/code&gt; ）。错误代码示例：</target>
        </trans-unit>
        <trans-unit id="a14d78d3da966b89fe122674705e062ddb4c4c41" translate="yes" xml:space="preserve">
          <source>This error indicates the use of a loop keyword (&lt;code&gt;break&lt;/code&gt; or &lt;code&gt;continue&lt;/code&gt;) outside of a loop. Without a loop to break out of or continue in, no sensible action can be taken. Erroneous code example:</source>
          <target state="translated">此错误表示在循环外使用了循环关键字（ &lt;code&gt;break&lt;/code&gt; 或 &lt;code&gt;continue&lt;/code&gt; ）。没有循环来突破或继续前进，就不会采取明智的行动。错误代码示例：</target>
        </trans-unit>
        <trans-unit id="50520313e8b1d1b1c6569c98ff40cb57f7812069" translate="yes" xml:space="preserve">
          <source>This error is created by the &lt;a href=&quot;struct.cstr#method.from_bytes_with_nul&quot;&gt;&lt;code&gt;CStr::from_bytes_with_nul&lt;/code&gt;&lt;/a&gt; method. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b9e91e9541342a47e9d0b1ac521444fa8e68a88" translate="yes" xml:space="preserve">
          <source>This error is created by the &lt;a href=&quot;struct.cstr#method.from_bytes_with_nul&quot;&gt;&lt;code&gt;from_bytes_with_nul&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">此错误是由&lt;a href=&quot;struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;struct.cstr#method.from_bytes_with_nul&quot;&gt; &lt;code&gt;from_bytes_with_nul&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="bbb5b15b9e8658856b49fb418cbe7dfc72c8452a" translate="yes" xml:space="preserve">
          <source>This error is created by the &lt;a href=&quot;struct.cstring#method.from_vec_with_nul&quot;&gt;&lt;code&gt;CString::from_vec_with_nul&lt;/code&gt;&lt;/a&gt; method. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f88231c82f77383d008a182af5374b0e8d20578" translate="yes" xml:space="preserve">
          <source>This error is created by the &lt;a href=&quot;struct.cstring#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">此错误是由&lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;struct.cstring#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt;方法创建的。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="e66887716e5bc2fbc972f3ffc3450120cd6c7b7e" translate="yes" xml:space="preserve">
          <source>This error is fairly cryptic because the problem is fairly cryptic. To call a &lt;code&gt;FnOnce&lt;/code&gt; closure that is stored in a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; (which is what our &lt;code&gt;Job&lt;/code&gt; type alias is), the closure needs to move itself &lt;em&gt;out&lt;/em&gt; of the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; because the closure takes ownership of &lt;code&gt;self&lt;/code&gt; when we call it. In general, Rust doesn&amp;rsquo;t allow us to move a value out of a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; because Rust doesn&amp;rsquo;t know how big the value inside the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; will be: recall in Chapter 15 that we used &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; precisely because we had something of an unknown size that we wanted to store in a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; to get a value of a known size.</source>
          <target state="translated">此错误相当隐蔽，因为问题相当隐秘。要调用存储在 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 的 &lt;code&gt;FnOnce&lt;/code&gt; 闭包（这是我们的 &lt;code&gt;Job&lt;/code&gt; 类型别名），闭包需要将自身&lt;em&gt;从&lt;/em&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;em&gt;移出&lt;/em&gt;，因为在我们调用闭包时，它会获取 &lt;code&gt;self&lt;/code&gt; 所有权。通常，Rust不允许我们将值从 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 移出，因为Rust不知道 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 内部的值会有多大：在第15章中我们曾使用 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 正是因为我们有一个未知大小的东西想要存储在 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 以获得已知大小的值。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ac1c7bfe67c403881a0d5e5220daf766f18ab15b" translate="yes" xml:space="preserve">
          <source>This error is used as the error type for the &lt;a href=&quot;../str/trait.fromstr&quot;&gt;&lt;code&gt;FromStr&lt;/code&gt;&lt;/a&gt; implementation for &lt;a href=&quot;../primitive.f32&quot;&gt;&lt;code&gt;f32&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.f64&quot;&gt;&lt;code&gt;f64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该错误用作&lt;a href=&quot;../primitive.f32&quot;&gt; &lt;code&gt;f32&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../primitive.f64&quot;&gt; &lt;code&gt;f64&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;../str/trait.fromstr&quot;&gt; &lt;code&gt;FromStr&lt;/code&gt; &lt;/a&gt;实现的错误类型。</target>
        </trans-unit>
        <trans-unit id="a413bd30b0780353f6f0cb9ec7112a60510b4c1b" translate="yes" xml:space="preserve">
          <source>This error is used as the error type for the &lt;a href=&quot;../str/trait.fromstr&quot;&gt;&lt;code&gt;FromStr&lt;/code&gt;&lt;/a&gt; implementation for &lt;a href=&quot;enum.ipaddr&quot;&gt;&lt;code&gt;IpAddr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.ipv4addr&quot;&gt;&lt;code&gt;Ipv4Addr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.ipv6addr&quot;&gt;&lt;code&gt;Ipv6Addr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.socketaddrv4&quot;&gt;&lt;code&gt;SocketAddrV4&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;struct.socketaddrv6&quot;&gt;&lt;code&gt;SocketAddrV6&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此错误用作&lt;a href=&quot;enum.ipaddr&quot;&gt; &lt;code&gt;IpAddr&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;struct.ipv4addr&quot;&gt; &lt;code&gt;Ipv4Addr&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;struct.ipv6addr&quot;&gt; &lt;code&gt;Ipv6Addr&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;struct.socketaddrv4&quot;&gt; &lt;code&gt;SocketAddrV4&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;struct.socketaddrv6&quot;&gt; &lt;code&gt;SocketAddrV6&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;../str/trait.fromstr&quot;&gt; &lt;code&gt;FromStr&lt;/code&gt; &lt;/a&gt;实现的错误类型。</target>
        </trans-unit>
        <trans-unit id="dbd5a817ebd0158354fc9b6704f3a0f2b0fc517f" translate="yes" xml:space="preserve">
          <source>This error is used as the error type for the &lt;code&gt;from_str_radix()&lt;/code&gt; functions on the primitive integer types, such as &lt;a href=&quot;../primitive.i8#method.from_str_radix&quot;&gt;&lt;code&gt;i8::from_str_radix&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此错误用作原始整数类型（例如&lt;a href=&quot;../primitive.i8#method.from_str_radix&quot;&gt; &lt;code&gt;i8::from_str_radix&lt;/code&gt; &lt;/a&gt; &lt;code&gt;from_str_radix()&lt;/code&gt; 上from_str_radix（）函数的错误类型。</target>
        </trans-unit>
        <trans-unit id="022d759f57798a79780636ae9f03f6fedf32312c" translate="yes" xml:space="preserve">
          <source>This error lets us know that either we&amp;rsquo;re passing something to &lt;code&gt;Screen&lt;/code&gt; we didn&amp;rsquo;t mean to pass and we should pass a different type or we should implement &lt;code&gt;Draw&lt;/code&gt; on &lt;code&gt;String&lt;/code&gt; so that &lt;code&gt;Screen&lt;/code&gt; is able to call &lt;code&gt;draw&lt;/code&gt; on it.</source>
          <target state="translated">这个错误让我们知道，要么是我们向 &lt;code&gt;Screen&lt;/code&gt; 传递了我们本不希望传递的东西，而我们应该传递不同的类型，要么应该实现 &lt;code&gt;Draw&lt;/code&gt; on &lt;code&gt;String&lt;/code&gt; ,以便 &lt;code&gt;Screen&lt;/code&gt; 能够在其上调用 &lt;code&gt;draw&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7089a49860a1eeefd308980067bc3b5e6f3e5841" translate="yes" xml:space="preserve">
          <source>This error lets you know that Rust has this constant defined more precisely and that your program would be more correct if you used the constant instead. You would then change your code to use the &lt;code&gt;PI&lt;/code&gt; constant. The following code doesn&amp;rsquo;t result in any errors or warnings from Clippy:</source>
          <target state="translated">该错误使您知道Rust具有更精确的定义此常数，并且如果改用该常数，则程序将更正确。然后，您将更改代码以使用 &lt;code&gt;PI&lt;/code&gt; 常量。以下代码不会导致Clippy出现任何错误或警告：</target>
        </trans-unit>
        <trans-unit id="7527f99b3dbab9d3281da26cc0de240205ca3ed7" translate="yes" xml:space="preserve">
          <source>This error may also commonly be found when working with unsafe code. For example, when using raw pointers one may wish to specify the lifetime for which the pointed-at data is valid. An initial attempt (below) causes this error:</source>
          <target state="translated">当使用不安全的代码时,也会经常发现这个错误。例如,当使用原始指针时,人们可能希望指定指向数据的有效期。最初的尝试(如下)会导致这个错误。</target>
        </trans-unit>
        <trans-unit id="1e7204b5ea49e32896ab0ba12a29a6e3937bc0f3" translate="yes" xml:space="preserve">
          <source>This error means that an attempt was made to match a struct type enum variant as a non-struct type:</source>
          <target state="translated">该错误意味着试图将结构类型枚举变体匹配为非结构类型。</target>
        </trans-unit>
        <trans-unit id="76d97f884e0ba6f5c3488397207d55a3b212ce21" translate="yes" xml:space="preserve">
          <source>This error means that an attempt was made to match something which is neither a tuple struct nor a tuple variant. Only these two elements are allowed as a pattern:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1988ee636e2a4d68092372fb6c89de2473339d3" translate="yes" xml:space="preserve">
          <source>This error means that an incorrect number of generic arguments were provided:</source>
          <target state="translated">该错误意味着提供的通用参数数量不正确。</target>
        </trans-unit>
        <trans-unit id="368e8d1bf22974707354d4d21e3f6ab34ed1757e" translate="yes" xml:space="preserve">
          <source>This error means you can&amp;rsquo;t use this trait as a trait object in this way. If you&amp;rsquo;re interested in more details on object safety, see &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md&quot;&gt;Rust RFC 255&lt;/a&gt;.</source>
          <target state="translated">此错误意味着您不能以这种方式将此特征用作特征对象。如果您对对象安全性的更多详细信息感兴趣，请参阅&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md&quot;&gt;Rust RFC 255&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="027a2fdf6a3f9948a9c92b0f1c99c26f859c6929" translate="yes" xml:space="preserve">
          <source>This error message refers to a feature we haven&amp;rsquo;t covered yet: lifetimes. We&amp;rsquo;ll discuss lifetimes in detail in Chapter 10. But, if you disregard the parts about lifetimes, the message does contain the key to why this code is a problem:</source>
          <target state="translated">此错误消息引用的是我们尚未涵盖的功能：生存期。我们将在第10章中详细讨论生命周期。但是，如果您忽略有关生命周期的部分，则消息的确包含了导致此代码出现问题的关键：</target>
        </trans-unit>
        <trans-unit id="b934f7e266f094b4b999e8bf2f04c71dea6d6829" translate="yes" xml:space="preserve">
          <source>This error message states that we&amp;rsquo;re not allowed to explicitly call &lt;code&gt;drop&lt;/code&gt;. The error message uses the term &lt;em&gt;destructor&lt;/em&gt;, which is the general programming term for a function that cleans up an instance. A &lt;em&gt;destructor&lt;/em&gt; is analogous to a &lt;em&gt;constructor&lt;/em&gt;, which creates an instance. The &lt;code&gt;drop&lt;/code&gt; function in Rust is one particular destructor.</source>
          <target state="translated">此错误消息指出，我们不允许显式调用 &lt;code&gt;drop&lt;/code&gt; 。错误消息使用术语&lt;em&gt;destructor&lt;/em&gt;，这是清理实例的函数的通用编程术语。甲&lt;em&gt;析构函数&lt;/em&gt;类似于一个&lt;em&gt;构造函数&lt;/em&gt;，它创建一个实例。Rust中的 &lt;code&gt;drop&lt;/code&gt; 函数是一种特定的析构函数。</target>
        </trans-unit>
        <trans-unit id="2c2b32b5586db42f3b0dff4da46b1782d86e698e" translate="yes" xml:space="preserve">
          <source>This error occurs because a borrow in a generator persists across a yield point.</source>
          <target state="translated">发生这种错误的原因是生成器中的借贷持续跨越一个收益点。</target>
        </trans-unit>
        <trans-unit id="1e6bf835d8f1dd37c8b25ebb4f51cc6621c79aa9" translate="yes" xml:space="preserve">
          <source>This error occurs because a borrow of a thread-local variable was made inside a function which outlived the lifetime of the function.</source>
          <target state="translated">发生这个错误的原因是,在一个函数中借用了一个线程局部变量,而这个变量超过了函数的寿命。</target>
        </trans-unit>
        <trans-unit id="249f7bc8f6d82a80564f1c3f396aa42dbc6e451f" translate="yes" xml:space="preserve">
          <source>This error occurs because a value was dropped while it was still borrowed</source>
          <target state="translated">发生这个错误的原因是,当一个值还在被借用的时候,它就被丢弃了。</target>
        </trans-unit>
        <trans-unit id="074bebec9bc1d161aacdccb6e09fa091949d4c0d" translate="yes" xml:space="preserve">
          <source>This error occurs because you tried to mutably borrow a non-mutable variable.</source>
          <target state="translated">发生这个错误的原因是你试图以突变方式借用一个不可变的变量。</target>
        </trans-unit>
        <trans-unit id="1c3db0f8ef7d737dfd4c2dc90ac02bc9a5c77f3f" translate="yes" xml:space="preserve">
          <source>This error occurs when a bound in an implementation of a trait does not match the bounds specified in the original trait. For example:</source>
          <target state="translated">当一个特质实现中的边界与原始特质中指定的边界不匹配时,就会发生这个错误。例如:</target>
        </trans-unit>
        <trans-unit id="093dfc68eae74dcc328a7c8a1a3d68f0b36d7fb4" translate="yes" xml:space="preserve">
          <source>This error occurs when a method is used on a type which doesn't implement it:</source>
          <target state="translated">当一个方法被用于一个没有实现它的类型时,就会发生这个错误。</target>
        </trans-unit>
        <trans-unit id="da941b6947e460e43f6112767122feb782f16207" translate="yes" xml:space="preserve">
          <source>This error occurs when an &lt;code&gt;if&lt;/code&gt; expression without an &lt;code&gt;else&lt;/code&gt; block is used in a context where a type other than &lt;code&gt;()&lt;/code&gt; is expected, for example a &lt;code&gt;let&lt;/code&gt; expression:</source>
          <target state="translated">当在期望除 &lt;code&gt;()&lt;/code&gt; 以外的类型的上下文中使用不带 &lt;code&gt;else&lt;/code&gt; 块的 &lt;code&gt;if&lt;/code&gt; 表达式时，会发生此错误，例如 &lt;code&gt;let&lt;/code&gt; 表达式：</target>
        </trans-unit>
        <trans-unit id="5a28a2c48baba84d59c80917ee2d999515b5d378" translate="yes" xml:space="preserve">
          <source>This error occurs when an &lt;code&gt;if&lt;/code&gt; expression without an &lt;code&gt;else&lt;/code&gt; block is used in a context where a type other than &lt;code&gt;()&lt;/code&gt; is expected. In the previous code example, the &lt;code&gt;let&lt;/code&gt; expression was expecting a value but since there was no &lt;code&gt;else&lt;/code&gt;, no value was returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0370ddda8b1bb558216506bbbbafb414b273904" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to assign to a borrowed value.</source>
          <target state="translated">当试图分配给一个借来的值时,会发生这个错误。</target>
        </trans-unit>
        <trans-unit id="81568110c66c811e652efe84f4e84d35ccd0ca5f" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to borrow state past the end of the lifetime of a type that implements the &lt;code&gt;Drop&lt;/code&gt; trait.</source>
          <target state="translated">当尝试借用实现 &lt;code&gt;Drop&lt;/code&gt; 特性的类型的生命周期结束时的状态时，会发生此错误。</target>
        </trans-unit>
        <trans-unit id="552e357ec5f4118a4e87577f4bd866d88ddeba4b" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to move a borrowed variable into a closure.</source>
          <target state="translated">当试图将一个借来的变量移动到一个闭包中时,会发生这个错误。</target>
        </trans-unit>
        <trans-unit id="08dbd4d1c622d91c2a3b2e7680f087d95c0c0ad4" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to move out of a value whose type implements the &lt;code&gt;Drop&lt;/code&gt; trait.</source>
          <target state="translated">尝试移出其类型实现了 &lt;code&gt;Drop&lt;/code&gt; 特性的值时，会发生此错误。</target>
        </trans-unit>
        <trans-unit id="a382ee4f257c1e4d223e9634a0678761229064a5" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to mutate or mutably reference data that a closure has captured immutably.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0cd32a89f254835e1067e05e21bdf36f5041728" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to mutate or mutably reference data that a closure has captured immutably. Examples of this error are shown below:</source>
          <target state="translated">当试图变异或变异地引用闭包已不可变异地捕获的数据时,就会发生此错误。这种错误的例子如下所示。</target>
        </trans-unit>
        <trans-unit id="6dbb4812461df19f2be9097a66c157fbdbf8c85f" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to mutate the target of a mutable reference stored inside an immutable container.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e494d266acb1b46fd28c9cc0c8ca718e819da16c" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to partially reinitialize a structure that is currently uninitialized.</source>
          <target state="translated">当试图对当前未初始化的结构进行部分重新初始化时,会发生该错误。</target>
        </trans-unit>
        <trans-unit id="8feee21757ea4763c54c8d19077d7ff7e0dd5208" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to reassign an immutable variable. For example:</source>
          <target state="translated">当试图重新赋值一个不可变的变量时,会发生这个错误。例如:</target>
        </trans-unit>
        <trans-unit id="b105f193c377f1f9fe2f520a0094f3220a7d20d3" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to use a variable after its contents have been moved elsewhere. For example:</source>
          <target state="translated">当一个变量的内容被移到其他地方后,试图使用该变量时,会发生该错误。例如:</target>
        </trans-unit>
        <trans-unit id="7658c866cb10684f9a43de713daa72ba91346907" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to use data captured by a closure, when that data may no longer exist. It's most commonly seen when attempting to return a closure as shown in the previous code example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47a25aa9b1a97609269b45b233bf81af91519446" translate="yes" xml:space="preserve">
          <source>This error occurs when an attempt is made to use data captured by a closure, when that data may no longer exist. It's most commonly seen when attempting to return a closure:</source>
          <target state="translated">当试图使用闭包捕获的数据时,会发生该错误,而该数据可能已不存在。最常见的是在试图返回一个闭包时。</target>
        </trans-unit>
        <trans-unit id="25b45e0aeb2d0b344f458087fd222c2b9143243a" translate="yes" xml:space="preserve">
          <source>This error occurs when an expression was used in a place where the compiler expected an expression of a different type. It can occur in several cases, the most common being when calling a function and passing an argument which has a different type than the matching type in the function declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa2c4bec036eb23e59f4739f281ec16e241dd98a" translate="yes" xml:space="preserve">
          <source>This error occurs when the compiler doesn't have enough information to unambiguously choose an implementation.</source>
          <target state="translated">当编译器没有足够的信息来毫不含糊地选择一个实现时,就会出现这个错误。</target>
        </trans-unit>
        <trans-unit id="b03f07ba71f847bb7aaff9d23af91941f61b2264" translate="yes" xml:space="preserve">
          <source>This error occurs when the compiler is unable to infer the concrete type of a variable. It can occur in several cases, the most common being a mismatch between two types: the type the author explicitly assigned, and the type the compiler inferred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f68d6da4cba1c2fe73a0bdd6ed998a8c685d2f7a" translate="yes" xml:space="preserve">
          <source>This error occurs when the compiler is unable to unambiguously infer the return type of a function or method which is generic on return type, such as the &lt;code&gt;collect&lt;/code&gt; method for &lt;code&gt;Iterator&lt;/code&gt;s.</source>
          <target state="translated">当编译器无法明确推断出返回类型通用的函数或方法的返回类型（例如 &lt;code&gt;Iterator&lt;/code&gt; 的 &lt;code&gt;collect&lt;/code&gt; 方法）时，将发生此错误。</target>
        </trans-unit>
        <trans-unit id="f8852702dc84baa326e19b865b76e83190126314" translate="yes" xml:space="preserve">
          <source>This error occurs when the compiler was unable to infer the concrete type of a variable. It can occur for several cases, the most common of which is a mismatch in the expected type that the compiler inferred for a variable's initializing expression, and the actual type explicitly assigned to the variable.</source>
          <target state="translated">当编译器无法推断出一个变量的具体类型时,就会出现这个错误,它可能发生在几种情况下,最常见的是编译器为一个变量的初始化表达式推断的预期类型和明确分配给变量的实际类型不匹配。它可能发生在几种情况下,最常见的是编译器推断的变量初始化表达式的预期类型和实际类型不匹配。</target>
        </trans-unit>
        <trans-unit id="40572c6042150247d80f8e73ff85712050d543de" translate="yes" xml:space="preserve">
          <source>This error occurs when there was a recursive trait requirement that overflowed before it could be evaluated. Often this means that there is unbounded recursion in resolving some type bounds.</source>
          <target state="translated">当有一个递归特质要求在被评估之前就已经溢出时,就会发生这个错误。通常这意味着在解析某些类型界限时存在无界递归。</target>
        </trans-unit>
        <trans-unit id="4c98fdf7c35ee8cb8fdd6e9ff309c4211fcf94cf" translate="yes" xml:space="preserve">
          <source>This error occurs when there was a recursive trait requirement that overflowed before it could be evaluated. This often means that there is an unbounded recursion in resolving some type bounds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b6569d564fb77649858b1d55f9d8b2a0efd5a34" translate="yes" xml:space="preserve">
          <source>This error occurs when you defined methods or associated functions with same name.</source>
          <target state="translated">当你定义的方法或关联函数名称相同时,会出现这个错误。</target>
        </trans-unit>
        <trans-unit id="31aab3dcb3c76822f5a50ebdbab3c624e3384795" translate="yes" xml:space="preserve">
          <source>This error points at a file we didn&amp;rsquo;t write, &lt;em&gt;libcore/slice/mod.rs&lt;/em&gt;. That&amp;rsquo;s the implementation of &lt;code&gt;slice&lt;/code&gt; in the Rust source code. The code that gets run when we use &lt;code&gt;[]&lt;/code&gt; on our vector &lt;code&gt;v&lt;/code&gt; is in &lt;em&gt;libcore/slice/mod.rs&lt;/em&gt;, and that is where the &lt;code&gt;panic!&lt;/code&gt; is actually happening.</source>
          <target state="translated">在文件此错误点，我们没有写，&lt;em&gt;libcore /片/ mod.rs&lt;/em&gt;。那就是Rust源代码中 &lt;code&gt;slice&lt;/code&gt; 的实现。在向量 &lt;code&gt;v&lt;/code&gt; 上使用 &lt;code&gt;[]&lt;/code&gt; 时运行的代码在&lt;em&gt;libcore / slice / mod.rs中&lt;/em&gt;，这就是 &lt;code&gt;panic!&lt;/code&gt; 实际上正在发生。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="daff356f50087f066d8d7f295e45f7db503c47eb" translate="yes" xml:space="preserve">
          <source>This error points out that we&amp;rsquo;re only allowed to use the &lt;code&gt;?&lt;/code&gt; operator in a function that returns &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;. When you&amp;rsquo;re writing code in a function that doesn&amp;rsquo;t return &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;, and you want to use &lt;code&gt;?&lt;/code&gt; when you call other functions that return &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;, you have two choices to fix this problem. One technique is to change the return type of your function to be &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; if you have no restrictions preventing that. The other technique is to use a &lt;code&gt;match&lt;/code&gt; or one of the &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; methods to handle the &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; in whatever way is appropriate.</source>
          <target state="translated">这个错误指出我们只允许使用 &lt;code&gt;?&lt;/code&gt; 返回 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 的函数中的运算符。在不返回 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 的函数中编写代码时，您想使用 &lt;code&gt;?&lt;/code&gt; 当您调用其他返回 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 函数时，有两种选择可以解决此问题。一种技术是在没有限制的情况下将函数的返回类型更改为 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 。另一种技术是使用 &lt;code&gt;match&lt;/code&gt; 或 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 方法之一来以适当的方式处理 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef0f484866e508390ede392520c4e2f457d726bf" translate="yes" xml:space="preserve">
          <source>This error points out that we&amp;rsquo;re only allowed to use the &lt;code&gt;?&lt;/code&gt; operator in a function that returns &lt;code&gt;Result&lt;/code&gt; or &lt;code&gt;Option&lt;/code&gt; or another type that implements &lt;code&gt;std::ops::Try&lt;/code&gt;. When you&amp;rsquo;re writing code in a function that doesn&amp;rsquo;t return one of these types, and you want to use &lt;code&gt;?&lt;/code&gt; when you call other functions that return &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;, you have two choices to fix this problem. One technique is to change the return type of your function to be &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; if you have no restrictions preventing that. The other technique is to use a &lt;code&gt;match&lt;/code&gt; or one of the &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; methods to handle the &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; in whatever way is appropriate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5d927c97470a6bdf532b94621efe13e0092f99e" translate="yes" xml:space="preserve">
          <source>This error suggests that the expression arm corresponding to the noted pattern will never be reached as for all possible values of the expression being matched, one of the preceding patterns will match.</source>
          <target state="translated">该错误表明,与所指出的模式相对应的表达式臂将永远不会达到,因为对于正在匹配的表达式的所有可能的值,前面的模式之一将匹配。</target>
        </trans-unit>
        <trans-unit id="f4cd2a99a6de016ca859c1b751566814099aa1c3" translate="yes" xml:space="preserve">
          <source>This error type&amp;rsquo;s methods can be used to create functionality similar to &lt;code&gt;String::from_utf8_lossy&lt;/code&gt; without allocating heap memory:</source>
          <target state="translated">此错误类型的方法可用于创建类似于 &lt;code&gt;String::from_utf8_lossy&lt;/code&gt; 功能，而无需分配堆内存：</target>
        </trans-unit>
        <trans-unit id="fb422fab14fffbfe5c78207ee2ae02a65418bd40" translate="yes" xml:space="preserve">
          <source>This error usually happens when trying to pass in a value to an input inline assembly operand that is actually a pair of values. In particular, this can happen when trying to pass in a slice, for instance a &lt;code&gt;&amp;amp;str&lt;/code&gt;. In Rust, these values are represented internally as a pair of values, the pointer and its length. When passed as an input operand, this pair of values can not be coerced into a register and thus we must fail with an error.</source>
          <target state="translated">尝试将值传递给实际上是一对值的输入内联程序集操作数时，通常会发生此错误。特别是在尝试传递切片时，例如 &lt;code&gt;&amp;amp;str&lt;/code&gt; ，可能会发生这种情况。在Rust中，这些值在内部表示为一对值，指针及其长度。当将这对值作为输入操作数传递时，不能将其强制转换为寄存器，因此我们必须因错误而失败。</target>
        </trans-unit>
        <trans-unit id="46906d1c89db9bd7d3aa62947de98893bb4109ab" translate="yes" xml:space="preserve">
          <source>This error was returned when attempting to write the internal buffer.</source>
          <target state="translated">当尝试写入内部缓冲区时,返回该错误。</target>
        </trans-unit>
        <trans-unit id="3d919bd775721ac4d8e4678ab5d56f5c5d828138" translate="yes" xml:space="preserve">
          <source>This error will be emitted by the compiler when using an invalid receiver type, like in the following example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f5335a8d7c6f37faeab381d52fe1092a252bd8d" translate="yes" xml:space="preserve">
          <source>This example also shows how to use &lt;code&gt;move&lt;/code&gt;, in order to give ownership of values to a thread.</source>
          <target state="translated">此示例还显示了如何使用 &lt;code&gt;move&lt;/code&gt; ，以便将值的所有权授予线程。</target>
        </trans-unit>
        <trans-unit id="175716bea92c9d941f0898dc29c4ed209e64c353" translate="yes" xml:space="preserve">
          <source>This example builds a string, starting with an initial value and continuing with each element from the back until the front:</source>
          <target state="translated">这个例子建立了一个字符串,从一个初始值开始,从后面一直到前面的每个元素。</target>
        </trans-unit>
        <trans-unit id="4d013525fa73f401dcf7648ce7d8e69f8100f085" translate="yes" xml:space="preserve">
          <source>This example creates a &lt;code&gt;Point&lt;/code&gt; struct that implements &lt;a href=&quot;trait.add&quot;&gt;&lt;code&gt;Add&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.sub&quot;&gt;&lt;code&gt;Sub&lt;/code&gt;&lt;/a&gt;, and then demonstrates adding and subtracting two &lt;code&gt;Point&lt;/code&gt;s.</source>
          <target state="translated">本示例创建一个实现&lt;a href=&quot;trait.add&quot;&gt; &lt;code&gt;Add&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;trait.sub&quot;&gt; &lt;code&gt;Sub&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;Point&lt;/code&gt; 结构，然后演示添加和减去两个 &lt;code&gt;Point&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="612bd6352093018ae655e26b99b1150fb9f0d9dc" translate="yes" xml:space="preserve">
          <source>This example creates a &lt;code&gt;Point&lt;/code&gt; struct that implements the &lt;code&gt;AddAssign&lt;/code&gt; trait, and then demonstrates add-assigning to a mutable &lt;code&gt;Point&lt;/code&gt;.</source>
          <target state="translated">本示例创建一个实现 &lt;code&gt;AddAssign&lt;/code&gt; 特性的 &lt;code&gt;Point&lt;/code&gt; 结构，然后演示对可变 &lt;code&gt;Point&lt;/code&gt; 的添加分配。</target>
        </trans-unit>
        <trans-unit id="84b61046cfa323fa19b23ac20e12034ef787e01b" translate="yes" xml:space="preserve">
          <source>This example creates a &lt;code&gt;Point&lt;/code&gt; struct that implements the &lt;code&gt;SubAssign&lt;/code&gt; trait, and then demonstrates sub-assigning to a mutable &lt;code&gt;Point&lt;/code&gt;.</source>
          <target state="translated">本示例创建一个实现 &lt;code&gt;SubAssign&lt;/code&gt; 特性的 &lt;code&gt;Point&lt;/code&gt; 结构，然后演示向可变 &lt;code&gt;Point&lt;/code&gt; 的子分配。</target>
        </trans-unit>
        <trans-unit id="979ade7fbba01641154de5a065a6e6890cf54db4" translate="yes" xml:space="preserve">
          <source>This example creates a function with two parameters, both of which are &lt;code&gt;i32&lt;/code&gt; types. The function then prints the values in both of its parameters. Note that function parameters don&amp;rsquo;t all need to be the same type, they just happen to be in this example.</source>
          <target state="translated">本示例创建一个具有两个参数的函数，这两个参数均为 &lt;code&gt;i32&lt;/code&gt; 类型。然后，该函数在其两个参数中打印值。请注意，函数参数并不需要全部都是相同的类型，而在本示例中它们恰好是相同的。</target>
        </trans-unit>
        <trans-unit id="701db2e46c2038eecc101dd4ef0779ff5ad8d4cc" translate="yes" xml:space="preserve">
          <source>This example implements &lt;code&gt;Rem&lt;/code&gt; on a &lt;code&gt;SplitSlice&lt;/code&gt; object. After &lt;code&gt;Rem&lt;/code&gt; is implemented, one can use the &lt;code&gt;%&lt;/code&gt; operator to find out what the remaining elements of the slice would be after splitting it into equal slices of a given length.</source>
          <target state="translated">本示例在 &lt;code&gt;SplitSlice&lt;/code&gt; 对象上实现 &lt;code&gt;Rem&lt;/code&gt; 。实施 &lt;code&gt;Rem&lt;/code&gt; 后，可以使用 &lt;code&gt;%&lt;/code&gt; 运算符将切片拆分为给定长度的相等切片后，找出切片的其余元素。</target>
        </trans-unit>
        <trans-unit id="3d81c01c409b8ce1936b460c9219c2266b9648d9" translate="yes" xml:space="preserve">
          <source>This example prints 3, 2, and then 1. The &lt;code&gt;pop&lt;/code&gt; method takes the last element out of the vector and returns &lt;code&gt;Some(value)&lt;/code&gt;. If the vector is empty, &lt;code&gt;pop&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt;. The &lt;code&gt;while&lt;/code&gt; loop continues running the code in its block as long as &lt;code&gt;pop&lt;/code&gt; returns &lt;code&gt;Some&lt;/code&gt;. When &lt;code&gt;pop&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt;, the loop stops. We can use &lt;code&gt;while let&lt;/code&gt; to pop every element off our stack.</source>
          <target state="translated">本示例打印3、2，然后打印 &lt;code&gt;pop&lt;/code&gt; 方法将最后一个元素从向量中取出，并返回 &lt;code&gt;Some(value)&lt;/code&gt; 。如果向量为空，则 &lt;code&gt;pop&lt;/code&gt; 返回 &lt;code&gt;None&lt;/code&gt; 。只要 &lt;code&gt;pop&lt;/code&gt; 返回 &lt;code&gt;Some&lt;/code&gt; ， &lt;code&gt;while&lt;/code&gt; 循环就会继续在其块中运行代码。当 &lt;code&gt;pop&lt;/code&gt; 返回 &lt;code&gt;None&lt;/code&gt; 时，循环停止。我们可以在使用 &lt;code&gt;while let&lt;/code&gt; 将每个元素弹出堆栈。</target>
        </trans-unit>
        <trans-unit id="33bd3bf0b7b00466cfe4514bc631cc4d45b75356" translate="yes" xml:space="preserve">
          <source>This example shows an inner attribute on a function. The function will only be available while running tests.</source>
          <target state="translated">这个例子显示了一个函数的内部属性。该函数只有在运行测试时才能使用。</target>
        </trans-unit>
        <trans-unit id="02dcd48945408a840f3079c83663da1b30b196c7" translate="yes" xml:space="preserve">
          <source>This example shows how one can use &lt;code&gt;allow&lt;/code&gt; and &lt;code&gt;warn&lt;/code&gt; to toggle a particular check on and off:</source>
          <target state="translated">此示例显示了如何使用 &lt;code&gt;allow&lt;/code&gt; 和 &lt;code&gt;warn&lt;/code&gt; 来启用和禁用特定检查：</target>
        </trans-unit>
        <trans-unit id="b51a82804a004969c18f750e315e49a925f322a3" translate="yes" xml:space="preserve">
          <source>This example shows how one can use &lt;code&gt;forbid&lt;/code&gt; to disallow uses of &lt;code&gt;allow&lt;/code&gt; for that lint check:</source>
          <target state="translated">这个例子显示了一个如何使用 &lt;code&gt;forbid&lt;/code&gt; 来的不允许使用 &lt;code&gt;allow&lt;/code&gt; 的皮棉检查：</target>
        </trans-unit>
        <trans-unit id="20dcd5999998e80d936e0fa700c4a9a09932a423" translate="yes" xml:space="preserve">
          <source>This example shows how the compiler helps you find errors in your programs. Even though compiler errors can be frustrating, they only mean your program isn&amp;rsquo;t safely doing what you want it to do yet; they do &lt;em&gt;not&lt;/em&gt; mean that you&amp;rsquo;re not a good programmer! Experienced Rustaceans still get compiler errors.</source>
          <target state="translated">此示例说明了编译器如何帮助您发现程序中的错误。即使编译器错误令人沮丧，它们仅表示您的程序尚未安全地执行您想要的操作；它们&lt;em&gt;并不&lt;/em&gt;意味着您不是一个好的程序员！有经验的Rustaceans仍然会遇到编译器错误。</target>
        </trans-unit>
        <trans-unit id="2cb4570e4e31d810429621e0a69fd89abfdb2ea3" translate="yes" xml:space="preserve">
          <source>This example shows using a custom derive attribute to modify the meaning of a generic parameter.</source>
          <target state="translated">这个例子展示了使用自定义派生属性来修改通用参数的含义。</target>
        </trans-unit>
        <trans-unit id="e1b71afb4f7ccdfd339dd3d129a43084a3b35c6b" translate="yes" xml:space="preserve">
          <source>This example spawns a thread which will update the boolean value and then wait 100 milliseconds before notifying the condvar.</source>
          <target state="translated">这个例子产生了一个线程,这个线程将更新布尔值,然后在通知condvar之前等待100毫秒。</target>
        </trans-unit>
        <trans-unit id="b7617cea2234e7524bc25112d50668635c06f962" translate="yes" xml:space="preserve">
          <source>This example will print &lt;code&gt;Found an id in range: 5&lt;/code&gt;. By specifying &lt;code&gt;id_variable @&lt;/code&gt; before the range &lt;code&gt;3...7&lt;/code&gt;, we&amp;rsquo;re capturing whatever value matched the range while also testing that the value matched the range pattern.</source>
          <target state="translated">本示例将打印 &lt;code&gt;Found an id in range: 5&lt;/code&gt; 。通过在范围 &lt;code&gt;3...7&lt;/code&gt; 之前指定 &lt;code&gt;id_variable @&lt;/code&gt; ，我们可以捕获与范围匹配的任何值，同时还要测试该值是否与范围模式匹配。</target>
        </trans-unit>
        <trans-unit id="6bcb3e1c80011a7567e2eb18a8ff65f6e860aa55" translate="yes" xml:space="preserve">
          <source>This example will print &lt;code&gt;Found an id in range: 5&lt;/code&gt;. By specifying &lt;code&gt;id_variable @&lt;/code&gt; before the range &lt;code&gt;3..=7&lt;/code&gt;, we&amp;rsquo;re capturing whatever value matched the range while also testing that the value matched the range pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0792a7553f859fe5307a072fac84a140057b4ecf" translate="yes" xml:space="preserve">
          <source>This example will print &lt;code&gt;less than five: 4&lt;/code&gt;. When &lt;code&gt;num&lt;/code&gt; is compared to the pattern in the first arm, it matches, because &lt;code&gt;Some(4)&lt;/code&gt; matches &lt;code&gt;Some(x)&lt;/code&gt;. Then the match guard checks whether the value in &lt;code&gt;x&lt;/code&gt; is less than &lt;code&gt;5&lt;/code&gt;, and because it is, the first arm is selected.</source>
          <target state="translated">此示例将打印 &lt;code&gt;less than five: 4&lt;/code&gt; 。将 &lt;code&gt;num&lt;/code&gt; 与第一个手臂中的模式进行比较时，它会匹配，因为 &lt;code&gt;Some(4)&lt;/code&gt; 匹配 &lt;code&gt;Some(x)&lt;/code&gt; 。然后，比赛防护器检查 &lt;code&gt;x&lt;/code&gt; 中的值是否小于 &lt;code&gt;5&lt;/code&gt; ，并且因为是，所以选择了第一个手臂。</target>
        </trans-unit>
        <trans-unit id="e9c51ef5db1956234586460cd5d4e3f2d56f3c15" translate="yes" xml:space="preserve">
          <source>This exists solely for &lt;a href=&quot;../mem/fn.forget_unsized&quot;&gt;&lt;code&gt;mem::forget_unsized&lt;/code&gt;&lt;/a&gt;; normal &lt;code&gt;forget&lt;/code&gt; uses &lt;code&gt;ManuallyDrop&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13f35b34cb9f0940df9ede968c0941933fe5a63e" translate="yes" xml:space="preserve">
          <source>This explicitly states that you expect the trait object &lt;code&gt;SomeTrait&lt;/code&gt; to contain references (with a maximum lifetime of &lt;code&gt;'a&lt;/code&gt;).</source>
          <target state="translated">这明确表明您希望特征对象 &lt;code&gt;SomeTrait&lt;/code&gt; 包含引用（最大生存期为 &lt;code&gt;'a&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="55550702354f0f532a45a47534287ba31230892e" translate="yes" xml:space="preserve">
          <source>This expression:</source>
          <target state="translated">这种说法。</target>
        </trans-unit>
        <trans-unit id="d4d243a04a2e7c3baa5aaa70386526d20f9c61fb" translate="yes" xml:space="preserve">
          <source>This fails because &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is not &lt;code&gt;Copy&lt;/code&gt;, even when &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Copy&lt;/code&gt; (this differs from the behavior for &lt;code&gt;&amp;amp;T&lt;/code&gt;, which is always &lt;code&gt;Copy&lt;/code&gt;).</source>
          <target state="translated">这失败是因为 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 不是 &lt;code&gt;Copy&lt;/code&gt; ，即使 &lt;code&gt;T&lt;/code&gt; 是 &lt;code&gt;Copy&lt;/code&gt; （这与 &lt;code&gt;&amp;amp;T&lt;/code&gt; 的行为（始终为 &lt;code&gt;Copy&lt;/code&gt; ）不同）。</target>
        </trans-unit>
        <trans-unit id="96a49ec58cf9d3de1eca61f7643ce5de9d8c4e5e" translate="yes" xml:space="preserve">
          <source>This fails because &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; does not implement &lt;code&gt;Copy&lt;/code&gt; for any &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">之所以失败，是因为 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 没有为任何 &lt;code&gt;T&lt;/code&gt; 实现 &lt;code&gt;Copy&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="77c78e0cdd88af63c9805574659b7e0844c8f178" translate="yes" xml:space="preserve">
          <source>This fails to compile because &lt;code&gt;T&lt;/code&gt; does not appear in the trait or in the implementing type.</source>
          <target state="translated">由于 &lt;code&gt;T&lt;/code&gt; 没有出现在特征或实现类型中，因此无法编译。</target>
        </trans-unit>
        <trans-unit id="586c08bc607fd5a338c048e0f30142b22328caf5" translate="yes" xml:space="preserve">
          <source>This field contains the file system attribute information for a file or directory. For possible values and their descriptions, see &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/fileio/file-attribute-constants&quot;&gt;File Attribute Constants&lt;/a&gt; in the Windows Dev Center.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c5af671ad45076c8c92a16a6b71ec7dd6cf3c8d" translate="yes" xml:space="preserve">
          <source>This field contains the file system attribute information for a file or directory. For possible values and their descriptions, see &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/gg258117.aspx&quot;&gt;File Attribute Constants&lt;/a&gt; in the Windows Dev Center.</source>
          <target state="translated">该字段包含文件或目录的文件系统属性信息。有关可能的值及其说明，请参见Windows Dev Center中的&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/gg258117.aspx&quot;&gt;文件属性常量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a06da2f86acca1e87efa6c64e9e56d6bba45e46d" translate="yes" xml:space="preserve">
          <source>This field may not be available on all platforms, and will return an &lt;code&gt;Err&lt;/code&gt; on platforms or filesystems where it is not available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fed8ac050f10d4961483960b90a8bb5fa116bf7c" translate="yes" xml:space="preserve">
          <source>This field may not be available on all platforms, and will return an &lt;code&gt;Err&lt;/code&gt; on platforms where it is not available.</source>
          <target state="translated">此字段可能并非在所有平台上都可用，并且会在不可用的平台上返回 &lt;code&gt;Err&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5368359fd79a3572b28925e44099327d749ce6f1" translate="yes" xml:space="preserve">
          <source>This file is in the &lt;a href=&quot;https://github.com/toml-lang/toml&quot;&gt;&lt;em&gt;TOML&lt;/em&gt;&lt;/a&gt; (&lt;em&gt;Tom&amp;rsquo;s Obvious, Minimal Language&lt;/em&gt;) format, which is Cargo&amp;rsquo;s configuration format.</source>
          <target state="translated">该文件采用&lt;a href=&quot;https://github.com/toml-lang/toml&quot;&gt;&lt;em&gt;TOML&lt;/em&gt;&lt;/a&gt;（&lt;em&gt;汤姆的最小语言&lt;/em&gt;）格式，这是Cargo的配置格式。</target>
        </trans-unit>
        <trans-unit id="403b498b0ea95a8401971fc9fa18c953b57bf6c7" translate="yes" xml:space="preserve">
          <source>This file is in the &lt;a href=&quot;https://toml.io&quot;&gt;&lt;em&gt;TOML&lt;/em&gt;&lt;/a&gt; (&lt;em&gt;Tom&amp;rsquo;s Obvious, Minimal Language&lt;/em&gt;) format, which is Cargo&amp;rsquo;s configuration format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0537f20b3c4c0b16d4802ffcd175906f9816b83" translate="yes" xml:space="preserve">
          <source>This following example shows the stringified &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;s&lt;/a&gt; that the attribute macros see. The output will show in the output of the compiler. The output is shown in the comments after the function prefixed with &quot;out:&quot;.</source>
          <target state="translated">这下面的示例演示将字符串&lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; 小号&lt;/a&gt;的属性宏见。输出将显示在编译器的输出中。在以&amp;ldquo; out：&amp;rdquo;为前缀的函数之后，输出显示在注释中。</target>
        </trans-unit>
        <trans-unit id="a9c265b88652152ca2b28f53cb136d7ff3a25c8d" translate="yes" xml:space="preserve">
          <source>This function &lt;strong&gt;consumes ownership&lt;/strong&gt; of the specified file descriptor. The returned object will take responsibility for closing it when the object goes out of scope.</source>
          <target state="translated">此函数&lt;strong&gt;消耗&lt;/strong&gt;指定文件描述符的&lt;strong&gt;所有权&lt;/strong&gt;。当对象超出范围时，返回的对象将负责关闭它。</target>
        </trans-unit>
        <trans-unit id="7770f6814daf86198289168c0cb8b4e0eaa39b97" translate="yes" xml:space="preserve">
          <source>This function &lt;strong&gt;transfers ownership&lt;/strong&gt; of the underlying file descriptor to the caller. Callers are then the unique owners of the file descriptor and must close the descriptor once it's no longer needed.</source>
          <target state="translated">此函数&lt;strong&gt;将&lt;/strong&gt;基础文件描述符的&lt;strong&gt;所有权转移&lt;/strong&gt;给调用方。这样，调用者便是文件描述符的唯一所有者，一旦不再需要描述符，必须将其关闭。</target>
        </trans-unit>
        <trans-unit id="9e16870fdc5324388fb513d47d710cb2a9d23e70" translate="yes" xml:space="preserve">
          <source>This function &lt;strong&gt;transfers ownership&lt;/strong&gt; of the underlying handle to the caller. Callers are then the unique owners of the handle and must close it once it's no longer needed.</source>
          <target state="translated">此函数&lt;strong&gt;将&lt;/strong&gt;基础句柄的&lt;strong&gt;所有权转移&lt;/strong&gt;给调用方。这样，调用方便是该句柄的唯一所有者，一旦不再需要它就必须关闭它。</target>
        </trans-unit>
        <trans-unit id="90c9a08f16b0c10b615b5b0843cebfac39017e99" translate="yes" xml:space="preserve">
          <source>This function &lt;strong&gt;transfers ownership&lt;/strong&gt; of the underlying pthread_t to the caller. Callers are then the unique owners of the pthread_t and must either detach or join the pthread_t once it's no longer needed.</source>
          <target state="translated">此函数&lt;strong&gt;将&lt;/strong&gt;基础pthread_t的&lt;strong&gt;所有权转让&lt;/strong&gt;给调用方。这样，调用方便是pthread_t的唯一所有者，一旦不再需要，则必须分离或加入pthread_t。</target>
        </trans-unit>
        <trans-unit id="06669b18e93261495eb1fcf2252cb895da69c39a" translate="yes" xml:space="preserve">
          <source>This function &lt;strong&gt;transfers ownership&lt;/strong&gt; of the underlying socket to the caller. Callers are then the unique owners of the socket and must close it once it's no longer needed.</source>
          <target state="translated">此函数&lt;strong&gt;将&lt;/strong&gt;基础套接字的&lt;strong&gt;所有权转移&lt;/strong&gt;给调用方。这样，调用方便是套接字的唯一所有者，并且在不再需要套接字时必须将其关闭。</target>
        </trans-unit>
        <trans-unit id="3028ce76268abc4493b0febc5668a0c85baa5e06" translate="yes" xml:space="preserve">
          <source>This function accepts strings such as</source>
          <target state="translated">该函数接受的字符串包括</target>
        </trans-unit>
        <trans-unit id="3b6b07c29d146488fec502f1e37e5fcc2f92d5fd" translate="yes" xml:space="preserve">
          <source>This function allows inspecting the location, in code, of where an error happened. The returned &lt;code&gt;Backtrace&lt;/code&gt; contains information about the stack trace of the OS thread of execution of where the error originated from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcca4cdb6fc324905436b470716282df197ae1a7" translate="yes" xml:space="preserve">
          <source>This function behaves the same as &lt;code&gt;capture&lt;/code&gt; except that it ignores the values of the &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; and &lt;code&gt;RUST_LIB_BACKTRACE&lt;/code&gt; environment variables, always capturing a backtrace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1eb2ceefa3b664d9a9270981fa8cbdd469bffdd" translate="yes" xml:space="preserve">
          <source>This function can be used for control flow based on &lt;code&gt;Result&lt;/code&gt; values.</source>
          <target state="translated">此功能可用于基于&amp;ldquo; &lt;code&gt;Result&lt;/code&gt; 值的控制流。</target>
        </trans-unit>
        <trans-unit id="069d719c6868f05d1ad9a84a0abe1540eb6a83ca" translate="yes" xml:space="preserve">
          <source>This function can be used for control flow based on result values.</source>
          <target state="translated">该功能可用于基于结果值的控制流。</target>
        </trans-unit>
        <trans-unit id="1f2e8570607d30aa900e189937d7916fe8ed3230" translate="yes" xml:space="preserve">
          <source>This function can be used to compose the results of two functions.</source>
          <target state="translated">这个函数可以用来合成两个函数的结果。</target>
        </trans-unit>
        <trans-unit id="890b1ba5d17963460809400c8357e2da154ed2a6" translate="yes" xml:space="preserve">
          <source>This function can be used to pass through a successful result while handling an error.</source>
          <target state="translated">这个函数可以用来在处理错误时传递成功的结果。</target>
        </trans-unit>
        <trans-unit id="f898974fbfac52e97eb29d82afb416cf7dbf9a7a" translate="yes" xml:space="preserve">
          <source>This function can be used to unpack a successful result while handling an error.</source>
          <target state="translated">这个函数可以用来在处理错误的同时解开一个成功的结果。</target>
        </trans-unit>
        <trans-unit id="663e29d3010e4fe834fdfef457c75d87463c66ed" translate="yes" xml:space="preserve">
          <source>This function can be written in a much shorter way, but we&amp;rsquo;re going to start by doing a lot of it manually in order to explore error handling; at the end, we&amp;rsquo;ll show the shorter way. Let&amp;rsquo;s look at the return type of the function first: &lt;code&gt;Result&amp;lt;String, io::Error&amp;gt;&lt;/code&gt;. This means the function is returning a value of the type &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; where the generic parameter &lt;code&gt;T&lt;/code&gt; has been filled in with the concrete type &lt;code&gt;String&lt;/code&gt; and the generic type &lt;code&gt;E&lt;/code&gt; has been filled in with the concrete type &lt;code&gt;io::Error&lt;/code&gt;. If this function succeeds without any problems, the code that calls this function will receive an &lt;code&gt;Ok&lt;/code&gt; value that holds a &lt;code&gt;String&lt;/code&gt;&amp;mdash;the username that this function read from the file. If this function encounters any problems, the code that calls this function will receive an &lt;code&gt;Err&lt;/code&gt; value that holds an instance of &lt;code&gt;io::Error&lt;/code&gt; that contains more information about what the problems were. We chose &lt;code&gt;io::Error&lt;/code&gt; as the return type of this function because that happens to be the type of the error value returned from both of the operations we&amp;rsquo;re calling in this function&amp;rsquo;s body that might fail: the &lt;code&gt;File::open&lt;/code&gt; function and the &lt;code&gt;read_to_string&lt;/code&gt; method.</source>
          <target state="translated">可以用更短的方式编写此函数，但是为了探索错误处理，我们将首先手动进行很多操作。最后，我们将展示较短的方法。首先让我们看一下函数的返回类型： &lt;code&gt;Result&amp;lt;String, io::Error&amp;gt;&lt;/code&gt; 。这意味着函数将返回类型 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 的值，其中通用参数 &lt;code&gt;T&lt;/code&gt; 已用具体类型 &lt;code&gt;String&lt;/code&gt; 填充，而通用类型 &lt;code&gt;E&lt;/code&gt; 已用具体类型 &lt;code&gt;io::Error&lt;/code&gt; 填充。如果此函数成功执行而没有任何问题，则调用此函数的代码将收到一个包含 &lt;code&gt;String&lt;/code&gt; 的 &lt;code&gt;Ok&lt;/code&gt; 值。&amp;mdash;此函数从文件读取的用户名。如果此函数遇到任何问题，则调用此函数的代码将收到一个 &lt;code&gt;Err&lt;/code&gt; 值，其中包含 &lt;code&gt;io::Error&lt;/code&gt; 实例，该实例包含有关问题所在的更多信息。我们选择 &lt;code&gt;io::Error&lt;/code&gt; 作为此函数的返回类型，因为这恰好是我们在函数体内调用的两个操作可能返回的错误值的类型： &lt;code&gt;File::open&lt;/code&gt; 函数和 &lt;code&gt;read_to_string&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="cb45099429d3a43cd1fd9c5de5abe0335d7b7e9d" translate="yes" xml:space="preserve">
          <source>This function corresponds to &lt;a href=&quot;../mem/fn.replace&quot;&gt;&lt;code&gt;std::mem::replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该函数对应于&lt;a href=&quot;../mem/fn.replace&quot;&gt; &lt;code&gt;std::mem::replace&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bc55369db6754d8ec7579c34bfc5b97438f6a7f6" translate="yes" xml:space="preserve">
          <source>This function corresponds to &lt;a href=&quot;../mem/fn.swap&quot;&gt;&lt;code&gt;std::mem::swap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该函数对应于&lt;a href=&quot;../mem/fn.swap&quot;&gt; &lt;code&gt;std::mem::swap&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ac167c5922dc46db61626cca7bc837d30e8e8d77" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to &lt;code&gt;opendir&lt;/code&gt;, &lt;code&gt;lstat&lt;/code&gt;, &lt;code&gt;rm&lt;/code&gt; and &lt;code&gt;rmdir&lt;/code&gt; functions on Unix and the &lt;code&gt;FindFirstFile&lt;/code&gt;, &lt;code&gt;GetFileAttributesEx&lt;/code&gt;, &lt;code&gt;DeleteFile&lt;/code&gt;, and &lt;code&gt;RemoveDirectory&lt;/code&gt; functions on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">此函数当前对应于Unix上的 &lt;code&gt;opendir&lt;/code&gt; ， &lt;code&gt;lstat&lt;/code&gt; ， &lt;code&gt;rm&lt;/code&gt; 和 &lt;code&gt;rmdir&lt;/code&gt; 函数，以及Windows 上的 &lt;code&gt;FindFirstFile&lt;/code&gt; ， &lt;code&gt;GetFileAttributesEx&lt;/code&gt; ， &lt;code&gt;DeleteFile&lt;/code&gt; 和 &lt;code&gt;RemoveDirectory&lt;/code&gt; 函数。请注意，这&lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;将来可能会改变&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bea785a55c87ae52504d49f8f95ea16d8aa3ce9e" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;chmod&lt;/code&gt; function on Unix and the &lt;code&gt;SetFileAttributes&lt;/code&gt; function on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">该函数当前对应于Unix 上的 &lt;code&gt;chmod&lt;/code&gt; 函数和Windows 上的 &lt;code&gt;SetFileAttributes&lt;/code&gt; 函数。请注意，这&lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;将来可能会改变&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="04e383479b2228c3ffffa98975698e9dda256dbb" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;fchmod&lt;/code&gt; function on Unix and the &lt;code&gt;SetFileInformationByHandle&lt;/code&gt; function on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">该功能目前对应于 &lt;code&gt;fchmod&lt;/code&gt; 在Unix功能和 &lt;code&gt;SetFileInformationByHandle&lt;/code&gt; 在Windows功能。请注意，这&lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;将来可能会改变&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0176ddcd073fa8b60d6460114db8d5951e367349" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;link&lt;/code&gt; function on Unix and the &lt;code&gt;CreateHardLink&lt;/code&gt; function on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">该函数当前对应于Unix 上的 &lt;code&gt;link&lt;/code&gt; 函数和Windows 上的 &lt;code&gt;CreateHardLink&lt;/code&gt; 函数。请注意，这&lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;将来可能会改变&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="21169ffe61676853807722591cc30f485744220c" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;linkat&lt;/code&gt; function with no flags on Unix and the &lt;code&gt;CreateHardLink&lt;/code&gt; function on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01e2694d82da90e8f24cd10e750a58377e07410c" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;lstat&lt;/code&gt; function on Unix and the &lt;code&gt;GetFileAttributesEx&lt;/code&gt; function on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">该函数当前对应于Unix 上的 &lt;code&gt;lstat&lt;/code&gt; 函数和Windows 上的 &lt;code&gt;GetFileAttributesEx&lt;/code&gt; 函数。请注意，这&lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;将来可能会改变&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3537e3f2c9af1f7a17489b68fe05b364816b75fc" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;mkdir&lt;/code&gt; function on Unix and the &lt;code&gt;CreateDirectory&lt;/code&gt; function on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">该函数当前对应于Unix 上的 &lt;code&gt;mkdir&lt;/code&gt; 函数和Windows 上的 &lt;code&gt;CreateDirectory&lt;/code&gt; 函数。请注意，这&lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;将来可能会改变&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4ffbba2d718a3b3920d07fee5dfb64d2a84ce583" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;open&lt;/code&gt; function in Unix with &lt;code&gt;O_RDONLY&lt;/code&gt; for &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;O_WRONLY&lt;/code&gt;, &lt;code&gt;O_CREAT&lt;/code&gt;, and &lt;code&gt;O_TRUNC&lt;/code&gt; for &lt;code&gt;to&lt;/code&gt;. &lt;code&gt;O_CLOEXEC&lt;/code&gt; is set for returned file descriptors. On Windows, this function currently corresponds to &lt;code&gt;CopyFileEx&lt;/code&gt;. Alternate NTFS streams are copied but only the size of the main stream is returned by this function. On MacOS, this function corresponds to &lt;code&gt;fclonefileat&lt;/code&gt; and &lt;code&gt;fcopyfile&lt;/code&gt;. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">该功能目前对应于 &lt;code&gt;open&lt;/code&gt; 的Unix的功能与 &lt;code&gt;O_RDONLY&lt;/code&gt; 用于 &lt;code&gt;from&lt;/code&gt; 和 &lt;code&gt;O_WRONLY&lt;/code&gt; ， &lt;code&gt;O_CREAT&lt;/code&gt; 和 &lt;code&gt;O_TRUNC&lt;/code&gt; 为 &lt;code&gt;to&lt;/code&gt; 。为返回的文件描述符设置 &lt;code&gt;O_CLOEXEC&lt;/code&gt; 。在Windows上，此功能当前对应于 &lt;code&gt;CopyFileEx&lt;/code&gt; 。复制备用NTFS流，但此函数仅返回主流的大小。在MacOS上，此功能对应于 &lt;code&gt;fclonefileat&lt;/code&gt; 和 &lt;code&gt;fcopyfile&lt;/code&gt; 。请注意，这&lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;将来可能会改变&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="69a3d5683d593b686853078a406cbc99ddb7840f" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;opendir&lt;/code&gt; function on Unix and the &lt;code&gt;FindFirstFile&lt;/code&gt; function on Windows. Advancing the iterator currently corresponds to &lt;code&gt;readdir&lt;/code&gt; on Unix and &lt;code&gt;FindNextFile&lt;/code&gt; on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85bdcb1c22d0b90cfc515b44a49195abde2937e0" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;opendir&lt;/code&gt; function on Unix and the &lt;code&gt;FindFirstFile&lt;/code&gt; function on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">该函数当前对应于Unix 上的 &lt;code&gt;opendir&lt;/code&gt; 函数和Windows 上的 &lt;code&gt;FindFirstFile&lt;/code&gt; 函数。请注意，这&lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;将来可能会改变&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c6d0089b9c1b95a34e4ecb4a009ec095c9db172d" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;readlink&lt;/code&gt; function on Unix and the &lt;code&gt;CreateFile&lt;/code&gt; function with &lt;code&gt;FILE_FLAG_OPEN_REPARSE_POINT&lt;/code&gt; and &lt;code&gt;FILE_FLAG_BACKUP_SEMANTICS&lt;/code&gt; flags on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">该函数当前对应于Unix 上的 &lt;code&gt;readlink&lt;/code&gt; 函数以及Windows上带有 &lt;code&gt;FILE_FLAG_OPEN_REPARSE_POINT&lt;/code&gt; 和 &lt;code&gt;FILE_FLAG_BACKUP_SEMANTICS&lt;/code&gt; 标志的 &lt;code&gt;CreateFile&lt;/code&gt; 函数。请注意，这&lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;将来可能会改变&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="83d811fb4fcc08f1492a059a3536fbb7a2a90ca2" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;realpath&lt;/code&gt; function on Unix and the &lt;code&gt;CreateFile&lt;/code&gt; and &lt;code&gt;GetFinalPathNameByHandle&lt;/code&gt; functions on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">该函数当前对应于Unix 上的 &lt;code&gt;realpath&lt;/code&gt; 函数以及Windows上的 &lt;code&gt;CreateFile&lt;/code&gt; 和 &lt;code&gt;GetFinalPathNameByHandle&lt;/code&gt; 函数。请注意，这&lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;将来可能会改变&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e8892007c2c9e02432f47cff4848a4e40ebbc10c" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;rename&lt;/code&gt; function on Unix and the &lt;code&gt;MoveFileEx&lt;/code&gt; function with the &lt;code&gt;MOVEFILE_REPLACE_EXISTING&lt;/code&gt; flag on Windows.</source>
          <target state="translated">该函数当前对应于Unix 上的 &lt;code&gt;rename&lt;/code&gt; 函数和Windows上带有 &lt;code&gt;MOVEFILE_REPLACE_EXISTING&lt;/code&gt; 标志的 &lt;code&gt;MoveFileEx&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="8dd8f559f50531dc710476fe85e80e2f8d9753bd" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;rmdir&lt;/code&gt; function on Unix and the &lt;code&gt;RemoveDirectory&lt;/code&gt; function on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">该函数当前对应于Unix 上的 &lt;code&gt;rmdir&lt;/code&gt; 函数和Windows 上的 &lt;code&gt;RemoveDirectory&lt;/code&gt; 函数。请注意，这&lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;将来可能会改变&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b504889b373cb94fdb7ee56e28d937c2f36d6f0b" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;stat&lt;/code&gt; function on Unix and the &lt;code&gt;GetFileAttributesEx&lt;/code&gt; function on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">该函数当前对应于Unix 上的 &lt;code&gt;stat&lt;/code&gt; 函数和Windows 上的 &lt;code&gt;GetFileAttributesEx&lt;/code&gt; 函数。请注意，这&lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;将来可能会改变&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6672293739936665c26201ef3156432a0e98fd87" translate="yes" xml:space="preserve">
          <source>This function currently corresponds to the &lt;code&gt;unlink&lt;/code&gt; function on Unix and the &lt;code&gt;DeleteFile&lt;/code&gt; function on Windows. Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">该函数当前对应于Unix 上的 &lt;code&gt;unlink&lt;/code&gt; 函数和Windows 上的 &lt;code&gt;DeleteFile&lt;/code&gt; 函数。请注意，这&lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;将来可能会改变&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c94bdac48da7a0fc40fd1e5a086497b625f64825" translate="yes" xml:space="preserve">
          <source>This function does &lt;strong&gt;not&lt;/strong&gt; follow symbolic links and it will simply remove the symbolic link itself.</source>
          <target state="translated">此功能&lt;strong&gt;不&lt;/strong&gt;遵循符号链接，它会直接删除符号链接本身。</target>
        </trans-unit>
        <trans-unit id="977a8c203f0461d37e9d1afc3c85702bdcf54979" translate="yes" xml:space="preserve">
          <source>This function does not block.</source>
          <target state="translated">此功能不阻塞。</target>
        </trans-unit>
        <trans-unit id="99013d0e9f610e4b4ac531acb8d3cae6c5f35caf" translate="yes" xml:space="preserve">
          <source>This function does not provide any guarantees about whether it blocks waiting for data, but if an object needs to block for a read and cannot, it will typically signal this via an &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; return value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f6f2506f47f0d38fd935eda8f1d3f32af31d36c" translate="yes" xml:space="preserve">
          <source>This function does not provide any guarantees about whether it blocks waiting for data, but if an object needs to block for a read but cannot it will typically signal this via an &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; return value.</source>
          <target state="translated">该函数不提供有关是否阻塞等待数据的任何保证，但是如果对象需要阻塞以进行读取，但通常不能通过&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;返回值来发信号通知此对象。</target>
        </trans-unit>
        <trans-unit id="c9eb6fee31ded1ada354009451436d0884930106" translate="yes" xml:space="preserve">
          <source>This function does not provide any guarantees with respect to the ordering of whether contentious readers or writers will acquire the lock first.</source>
          <target state="translated">该功能并不保证有争议的读者或作者是否会先获得锁的顺序。</target>
        </trans-unit>
        <trans-unit id="710d2720b9947751fee0e57d2b8d496c47712e72" translate="yes" xml:space="preserve">
          <source>This function does not resolve trait objects, meaning that &lt;code&gt;type_name_of_val(&amp;amp;7u32 as &amp;amp;dyn Debug)&lt;/code&gt; may return &lt;code&gt;&quot;dyn Debug&quot;&lt;/code&gt;, but not &lt;code&gt;&quot;u32&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4305826482cc10423eedc0c48122ffd5b51fb63b" translate="yes" xml:space="preserve">
          <source>This function doesn't create the file if it doesn't exist. Use the &lt;a href=&quot;#method.create&quot;&gt;&lt;code&gt;create&lt;/code&gt;&lt;/a&gt; method to do so.</source>
          <target state="translated">如果该文件不存在，则该函数不会创建该文件。使用&lt;a href=&quot;#method.create&quot;&gt; &lt;code&gt;create&lt;/code&gt; &lt;/a&gt;方法这样做。</target>
        </trans-unit>
        <trans-unit id="33592db8fb3f9eb9295ccd92b371a923eae06e5a" translate="yes" xml:space="preserve">
          <source>This function doesn't create the file if it doesn't exist. Use the &lt;a href=&quot;struct.openoptions#method.create&quot;&gt;&lt;code&gt;OpenOptions::create&lt;/code&gt;&lt;/a&gt; method to do so.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2ecd58992bf3950332fa012ed014d7ac0b8bc7f" translate="yes" xml:space="preserve">
          <source>This function first gets the total length of the slice. Then it asserts that the index given as a parameter is within the slice by checking whether it&amp;rsquo;s less than or equal to the length. The assertion means that if we pass an index that is greater than the index to split the slice at, the function will panic before it attempts to use that index.</source>
          <target state="translated">此函数首先获取切片的总长度。然后，通过检查其长度是否小于或等于该长度，断言作为参数给出的索引在切片内。该断言意味着，如果我们传递一个大于索引的索引来分割切片，该函数将在尝试使用该索引之前发生恐慌。</target>
        </trans-unit>
        <trans-unit id="ef704585a456099301abe7c7cdfceffbef996018" translate="yes" xml:space="preserve">
          <source>This function first gets the total length of the slice. Then it asserts that the index given as a parameter is within the slice by checking whether it&amp;rsquo;s less than or equal to the length. The assertion means that if we pass an index that is greater than the length to split the slice at, the function will panic before it attempts to use that index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="457e092a949142d636a9e03fab0c159238f5daa4" translate="yes" xml:space="preserve">
          <source>This function forwards calls to the &lt;a href=&quot;trait.globalalloc#method.alloc_zeroed&quot;&gt;&lt;code&gt;GlobalAlloc::alloc_zeroed&lt;/code&gt;&lt;/a&gt; method of the allocator registered with the &lt;code&gt;#[global_allocator]&lt;/code&gt; attribute if there is one, or the &lt;code&gt;std&lt;/code&gt; crate&amp;rsquo;s default.</source>
          <target state="translated">此函数将调用转发到已使用 &lt;code&gt;#[global_allocator]&lt;/code&gt; 属性注册的分配器的&lt;a href=&quot;trait.globalalloc#method.alloc_zeroed&quot;&gt; &lt;code&gt;GlobalAlloc::alloc_zeroed&lt;/code&gt; &lt;/a&gt;方法（如果存在的话），或将其作为 &lt;code&gt;std&lt;/code&gt; 包装箱的默认值。</target>
        </trans-unit>
        <trans-unit id="dac6968f4833b95b4cfc0a37edb3317e41dafb8d" translate="yes" xml:space="preserve">
          <source>This function forwards calls to the &lt;a href=&quot;trait.globalalloc#method.realloc&quot;&gt;&lt;code&gt;GlobalAlloc::realloc&lt;/code&gt;&lt;/a&gt; method of the allocator registered with the &lt;code&gt;#[global_allocator]&lt;/code&gt; attribute if there is one, or the &lt;code&gt;std&lt;/code&gt; crate&amp;rsquo;s default.</source>
          <target state="translated">此函数将调用转发到已使用 &lt;code&gt;#[global_allocator]&lt;/code&gt; 属性注册的分配器的&lt;a href=&quot;trait.globalalloc#method.realloc&quot;&gt; &lt;code&gt;GlobalAlloc::realloc&lt;/code&gt; &lt;/a&gt;方法（如果存在的话），或者是 &lt;code&gt;std&lt;/code&gt; 包装箱的默认值。</target>
        </trans-unit>
        <trans-unit id="0ee226de8b2847b4bcaa66f0141bab39ef9c2e4e" translate="yes" xml:space="preserve">
          <source>This function forwards calls to the &lt;a href=&quot;trait.globalalloc#tymethod.alloc&quot;&gt;&lt;code&gt;GlobalAlloc::alloc&lt;/code&gt;&lt;/a&gt; method of the allocator registered with the &lt;code&gt;#[global_allocator]&lt;/code&gt; attribute if there is one, or the &lt;code&gt;std&lt;/code&gt; crate&amp;rsquo;s default.</source>
          <target state="translated">此函数将调用转发到已使用 &lt;code&gt;#[global_allocator]&lt;/code&gt; 属性注册的分配器的&lt;a href=&quot;trait.globalalloc#tymethod.alloc&quot;&gt; &lt;code&gt;GlobalAlloc::alloc&lt;/code&gt; &lt;/a&gt;方法（如果存在的话），或将其作为 &lt;code&gt;std&lt;/code&gt; 包装箱的默认值。</target>
        </trans-unit>
        <trans-unit id="43408a3e60cf657f5104a853eae37001a5663e2b" translate="yes" xml:space="preserve">
          <source>This function forwards calls to the &lt;a href=&quot;trait.globalalloc#tymethod.dealloc&quot;&gt;&lt;code&gt;GlobalAlloc::dealloc&lt;/code&gt;&lt;/a&gt; method of the allocator registered with the &lt;code&gt;#[global_allocator]&lt;/code&gt; attribute if there is one, or the &lt;code&gt;std&lt;/code&gt; crate&amp;rsquo;s default.</source>
          <target state="translated">此函数将调用转发到已使用 &lt;code&gt;#[global_allocator]&lt;/code&gt; 属性注册的分配器的&lt;a href=&quot;trait.globalalloc#tymethod.dealloc&quot;&gt; &lt;code&gt;GlobalAlloc::dealloc&lt;/code&gt; &lt;/a&gt;方法（如果存在的话），或将其作为 &lt;code&gt;std&lt;/code&gt; 包装箱的默认值。</target>
        </trans-unit>
        <trans-unit id="438ebff47f84838c22c79fbc8bfdda182cd513dc" translate="yes" xml:space="preserve">
          <source>This function gets called when a &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; gets dropped.</source>
          <target state="translated">删除&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt;时将调用此函数。</target>
        </trans-unit>
        <trans-unit id="13819f0b7aa144e5ea6bcb9cc9f9a6808e198851" translate="yes" xml:space="preserve">
          <source>This function has the same error semantics as &lt;a href=&quot;#method.read_until&quot;&gt;&lt;code&gt;read_until&lt;/code&gt;&lt;/a&gt; and will also return an error if the read bytes are not valid UTF-8. If an I/O error is encountered then &lt;code&gt;buf&lt;/code&gt; may contain some bytes already read in the event that all data read so far was valid UTF-8.</source>
          <target state="translated">该函数具有与&lt;a href=&quot;#method.read_until&quot;&gt; &lt;code&gt;read_until&lt;/code&gt; &lt;/a&gt;相同的错误语义，并且如果读取的字节无效的UTF-8，还将返回错误。如果遇到I / O错误，则 &lt;code&gt;buf&lt;/code&gt; 可能包含一些字节，如果到目前为止已读取的所有数据均为有效UTF-8，则该字节已被读取。</target>
        </trans-unit>
        <trans-unit id="2b30023fb932961fde08dc32d5756888772fda90" translate="yes" xml:space="preserve">
          <source>This function has the same error semantics as &lt;a href=&quot;trait.bufread#method.read_until&quot;&gt;&lt;code&gt;read_until&lt;/code&gt;&lt;/a&gt; and will also return an error if the read bytes are not valid UTF-8. If an I/O error is encountered then &lt;code&gt;buf&lt;/code&gt; may contain some bytes already read in the event that all data read so far was valid UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f52e89cf7de02d11dddd72bc5753735b903e55b9" translate="yes" xml:space="preserve">
          <source>This function has the same safety guarantees as the &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;Iterator::size_hint&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adea46a33368b546562d3adbbc93c24db07769c5" translate="yes" xml:space="preserve">
          <source>This function has the same safety guarantees as the &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;size_hint&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">此函数与&lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;size_hint&lt;/code&gt; &lt;/a&gt;函数具有相同的安全保证。</target>
        </trans-unit>
        <trans-unit id="1b144c49949055dde44dc3050173804acf39c11f" translate="yes" xml:space="preserve">
          <source>This function internally uses the &lt;a href=&quot;#method.write_all&quot;&gt;&lt;code&gt;write_all&lt;/code&gt;&lt;/a&gt; method on this trait and hence will continuously write data so long as no errors are received. This also means that partial writes are not indicated in this signature.</source>
          <target state="translated">此函数在内部使用此特征上的&lt;a href=&quot;#method.write_all&quot;&gt; &lt;code&gt;write_all&lt;/code&gt; &lt;/a&gt;方法，因此只要没有收到错误，就将连续写入数据。这也意味着此签名中未指示部分写入。</target>
        </trans-unit>
        <trans-unit id="66530779d87bba553e9df64d147255f7af9fe886" translate="yes" xml:space="preserve">
          <source>This function internally uses the &lt;a href=&quot;trait.write#method.write_all&quot;&gt;&lt;code&gt;write_all&lt;/code&gt;&lt;/a&gt; method on this trait and hence will continuously write data so long as no errors are received. This also means that partial writes are not indicated in this signature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f9b7d260474b82b56786f2b96849de01b420191" translate="yes" xml:space="preserve">
          <source>This function is a lower-level call. It needs to be paired with the &lt;a href=&quot;#tymethod.consume&quot;&gt;&lt;code&gt;consume&lt;/code&gt;&lt;/a&gt; method to function properly. When calling this method, none of the contents will be &quot;read&quot; in the sense that later calling &lt;code&gt;read&lt;/code&gt; may return the same contents. As such, &lt;a href=&quot;#tymethod.consume&quot;&gt;&lt;code&gt;consume&lt;/code&gt;&lt;/a&gt; must be called with the number of bytes that are consumed from this buffer to ensure that the bytes are never returned twice.</source>
          <target state="translated">此函数是较低级别的调用。它需要与&lt;a href=&quot;#tymethod.consume&quot;&gt; &lt;code&gt;consume&lt;/code&gt; &lt;/a&gt;方法配对才能正常运行。调用此方法时，任何内容都不会被&amp;ldquo;读取&amp;rdquo;，因为稍后调用 &lt;code&gt;read&lt;/code&gt; 可能会返回相同的内容。因此，&lt;a href=&quot;#tymethod.consume&quot;&gt; &lt;code&gt;consume&lt;/code&gt; &lt;/a&gt;必须与从该缓冲器消耗，确保字节再也没有回过两次的字节数被调用。</target>
        </trans-unit>
        <trans-unit id="1da3425b653a05b924f0c013401f366dcdf5aa2c" translate="yes" xml:space="preserve">
          <source>This function is a lower-level call. It needs to be paired with the &lt;a href=&quot;#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt; method to function properly. This function does not perform any I/O, it simply informs this object that some amount of its buffer, returned from &lt;a href=&quot;#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt;, has been consumed and should no longer be returned. As such, this function may do odd things if &lt;a href=&quot;#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt; isn't called before calling it.</source>
          <target state="translated">此函数是较低级别的调用。它需要与&lt;a href=&quot;#tymethod.fill_buf&quot;&gt; &lt;code&gt;fill_buf&lt;/code&gt; &lt;/a&gt;方法配对才能正常运行。该函数不执行任何I / O，它只是通知该对象从&lt;a href=&quot;#tymethod.fill_buf&quot;&gt; &lt;code&gt;fill_buf&lt;/code&gt; &lt;/a&gt;返回的一定数量的缓冲区已被消耗，不应再返回。因此，如果未在调用&lt;a href=&quot;#tymethod.fill_buf&quot;&gt; &lt;code&gt;fill_buf&lt;/code&gt; &lt;/a&gt;之前调用该函数，则该函数可能会做奇怪的事情。</target>
        </trans-unit>
        <trans-unit id="854ee5963ab7cb501fb556356449a0a75bec7aa8" translate="yes" xml:space="preserve">
          <source>This function is a lower-level call. It needs to be paired with the &lt;a href=&quot;trait.bufread#tymethod.consume&quot;&gt;&lt;code&gt;consume&lt;/code&gt;&lt;/a&gt; method to function properly. When calling this method, none of the contents will be &quot;read&quot; in the sense that later calling &lt;code&gt;read&lt;/code&gt; may return the same contents. As such, &lt;a href=&quot;trait.bufread#tymethod.consume&quot;&gt;&lt;code&gt;consume&lt;/code&gt;&lt;/a&gt; must be called with the number of bytes that are consumed from this buffer to ensure that the bytes are never returned twice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="579c281433d14ce69320e4d857132a7a2c6352d3" translate="yes" xml:space="preserve">
          <source>This function is a lower-level call. It needs to be paired with the &lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt; method to function properly. This function does not perform any I/O, it simply informs this object that some amount of its buffer, returned from &lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt;, has been consumed and should no longer be returned. As such, this function may do odd things if &lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt; isn't called before calling it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="415a263593c43f00d8f5a632e9e771b274ca8329" translate="yes" xml:space="preserve">
          <source>This function is a no-op, and does not even read from &lt;code&gt;dummy&lt;/code&gt;.</source>
          <target state="translated">此功能为空操作，甚至不会从 &lt;code&gt;dummy&lt;/code&gt; 读取。</target>
        </trans-unit>
        <trans-unit id="04e44698b394de41883f1cf69eb125285be21b0e" translate="yes" xml:space="preserve">
          <source>This function is also unsafe as the primitives currently returned have the contract that they are the sole owner of the file descriptor they are wrapping. Usage of this function could accidentally allow violating this contract which can cause memory unsafety in code that relies on it being true.</source>
          <target state="translated">这个函数也是不安全的,因为当前返回的基元有一个合同,即它们是它们所封装的文件描述符的唯一所有者。使用此函数可能会意外地允许违反此合同,这可能会在依赖该合同为真的代码中导致内存不安全。</target>
        </trans-unit>
        <trans-unit id="f34531fffd31ebc3903cc0f2c5f5bc232a9d53da" translate="yes" xml:space="preserve">
          <source>This function is blocking and should be used carefully: it is possible for an attacker to continuously send bytes without ever sending a newline or EOF.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="767fc2a16ab91407b9680a74099aea95b9c90341" translate="yes" xml:space="preserve">
          <source>This function is blocking and should be used carefully: it is possible for an attacker to continuously send bytes without ever sending the delimiter or EOF.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4f07981812bfb90d5d613f3cd12334bfad99018" translate="yes" xml:space="preserve">
          <source>This function is blocking, and should not be used in &lt;code&gt;async&lt;/code&gt; functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2491a3d7b07b5d574df89b38429aea33453977ac" translate="yes" xml:space="preserve">
          <source>This function is different from &lt;a href=&quot;../../thread/fn.yield_now&quot;&gt;&lt;code&gt;std::thread::yield_now&lt;/code&gt;&lt;/a&gt; which directly yields to the system's scheduler, whereas &lt;code&gt;spin_loop_hint&lt;/code&gt; does not interact with the operating system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98d00324eb55b3a641f30a2bb642d7084ef611a4" translate="yes" xml:space="preserve">
          <source>This function is different from &lt;a href=&quot;../thread/fn.yield_now&quot;&gt;&lt;code&gt;thread::yield_now&lt;/code&gt;&lt;/a&gt; which directly yields to the system's scheduler, whereas &lt;code&gt;spin_loop&lt;/code&gt; does not interact with the operating system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2844b634a91113f81bf8561b54a56d96807ba95f" translate="yes" xml:space="preserve">
          <source>This function is different than &lt;a href=&quot;../../thread/fn.yield_now&quot;&gt;&lt;code&gt;std::thread::yield_now&lt;/code&gt;&lt;/a&gt; which directly yields to the system's scheduler, whereas &lt;code&gt;spin_loop_hint&lt;/code&gt; only signals the processor that it is entering a busy-wait spin-loop without yielding control to the system's scheduler.</source>
          <target state="translated">此函数不同于&lt;a href=&quot;../../thread/fn.yield_now&quot;&gt; &lt;code&gt;std::thread::yield_now&lt;/code&gt; &lt;/a&gt;，后者直接屈服于系统的调度程序，而 &lt;code&gt;spin_loop_hint&lt;/code&gt; 仅向处理器发出信号，表明它正在进入忙碌的自旋循环，而不向系统的调度程序产生控制权。</target>
        </trans-unit>
        <trans-unit id="98f804e178831934e2704907d9977fcb07b49649" translate="yes" xml:space="preserve">
          <source>This function is different than &lt;a href=&quot;../thread/fn.yield_now&quot;&gt;&lt;code&gt;std::thread::yield_now&lt;/code&gt;&lt;/a&gt; which directly yields to the system's scheduler, whereas &lt;code&gt;spin_loop&lt;/code&gt; only signals the processor that it is entering a busy-wait spin-loop without yielding control to the system's scheduler.</source>
          <target state="translated">此函数不同于&lt;a href=&quot;../thread/fn.yield_now&quot;&gt; &lt;code&gt;std::thread::yield_now&lt;/code&gt; &lt;/a&gt;，后者直接屈服于系统的调度程序，而 &lt;code&gt;spin_loop&lt;/code&gt; 仅向处理器发出信号，表明它正在进入繁忙的自旋循环，而没有向系统的调度程序产生控制权。</target>
        </trans-unit>
        <trans-unit id="41b9515d2076760cfa3f4b5d6d17d095ddb905fd" translate="yes" xml:space="preserve">
          <source>This function is expected to be deprecated in favor of &lt;a href=&quot;../../hint/fn.spin_loop&quot;&gt;&lt;code&gt;hint::spin_loop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="467a74dd68a231eab8ded24aa170197676eb9466" translate="yes" xml:space="preserve">
          <source>This function is expected to be deprecated in favor of the &lt;code&gt;alloc&lt;/code&gt; method of the &lt;a href=&quot;struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; type when it and the &lt;a href=&quot;trait.alloc&quot;&gt;&lt;code&gt;Alloc&lt;/code&gt;&lt;/a&gt; trait become stable.</source>
          <target state="translated">当 &lt;code&gt;alloc&lt;/code&gt; 和&lt;a href=&quot;trait.alloc&quot;&gt; &lt;code&gt;Alloc&lt;/code&gt; &lt;/a&gt;特性变得稳定时，不建议使用此函数，而推荐使用&lt;a href=&quot;struct.global&quot;&gt; &lt;code&gt;Global&lt;/code&gt; &lt;/a&gt;类型的alloc方法。</target>
        </trans-unit>
        <trans-unit id="af165703deff9d928fee107e2b077ae27c60ea8e" translate="yes" xml:space="preserve">
          <source>This function is expected to be deprecated in favor of the &lt;code&gt;alloc&lt;/code&gt; method of the &lt;a href=&quot;struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; type when it and the &lt;a href=&quot;trait.allocref&quot;&gt;&lt;code&gt;AllocRef&lt;/code&gt;&lt;/a&gt; trait become stable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6654c3116763d1cd428eebcad450e10896b561da" translate="yes" xml:space="preserve">
          <source>This function is expected to be deprecated in favor of the &lt;code&gt;alloc_zeroed&lt;/code&gt; method of the &lt;a href=&quot;struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; type when it and the &lt;a href=&quot;trait.alloc&quot;&gt;&lt;code&gt;Alloc&lt;/code&gt;&lt;/a&gt; trait become stable.</source>
          <target state="translated">当该函数和&lt;a href=&quot;trait.alloc&quot;&gt; &lt;code&gt;Alloc&lt;/code&gt; &lt;/a&gt;特性变得稳定时，不建议使用此函数，而推荐使用&lt;a href=&quot;struct.global&quot;&gt; &lt;code&gt;Global&lt;/code&gt; &lt;/a&gt;类型的 &lt;code&gt;alloc_zeroed&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="bcbf3e248baf2acbd0ca22a0a9243de796c9b484" translate="yes" xml:space="preserve">
          <source>This function is expected to be deprecated in favor of the &lt;code&gt;alloc_zeroed&lt;/code&gt; method of the &lt;a href=&quot;struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; type when it and the &lt;a href=&quot;trait.allocref&quot;&gt;&lt;code&gt;AllocRef&lt;/code&gt;&lt;/a&gt; trait become stable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0400d9b530af2cdc75200e564b1d3df4717e5b0d" translate="yes" xml:space="preserve">
          <source>This function is expected to be deprecated in favor of the &lt;code&gt;dealloc&lt;/code&gt; method of the &lt;a href=&quot;struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; type when it and the &lt;a href=&quot;trait.alloc&quot;&gt;&lt;code&gt;Alloc&lt;/code&gt;&lt;/a&gt; trait become stable.</source>
          <target state="translated">当函数和&lt;a href=&quot;trait.alloc&quot;&gt; &lt;code&gt;Alloc&lt;/code&gt; &lt;/a&gt;特性变得稳定时，不建议使用此函数，而推荐使用&lt;a href=&quot;struct.global&quot;&gt; &lt;code&gt;Global&lt;/code&gt; &lt;/a&gt;类型的 &lt;code&gt;dealloc&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="9ed58253cb2bb6abe90cf553f72f373e1d0723cc" translate="yes" xml:space="preserve">
          <source>This function is expected to be deprecated in favor of the &lt;code&gt;dealloc&lt;/code&gt; method of the &lt;a href=&quot;struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; type when it and the &lt;a href=&quot;trait.allocref&quot;&gt;&lt;code&gt;AllocRef&lt;/code&gt;&lt;/a&gt; trait become stable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c9fc6e063817eb54b121ff88e105f246093f7ff" translate="yes" xml:space="preserve">
          <source>This function is expected to be deprecated in favor of the &lt;code&gt;realloc&lt;/code&gt; method of the &lt;a href=&quot;struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; type when it and the &lt;a href=&quot;trait.alloc&quot;&gt;&lt;code&gt;Alloc&lt;/code&gt;&lt;/a&gt; trait become stable.</source>
          <target state="translated">当该函数和&lt;a href=&quot;trait.alloc&quot;&gt; &lt;code&gt;Alloc&lt;/code&gt; &lt;/a&gt;特性变得稳定时，不建议使用此函数，而推荐使用&lt;a href=&quot;struct.global&quot;&gt; &lt;code&gt;Global&lt;/code&gt; &lt;/a&gt;类型的 &lt;code&gt;realloc&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="fa62f51911ddb19be8f5aa47587e29e20dee089f" translate="yes" xml:space="preserve">
          <source>This function is expected to be deprecated in favor of the &lt;code&gt;realloc&lt;/code&gt; method of the &lt;a href=&quot;struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; type when it and the &lt;a href=&quot;trait.allocref&quot;&gt;&lt;code&gt;AllocRef&lt;/code&gt;&lt;/a&gt; trait become stable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b11361fb076bd1f28fd827ccd142c64af2b467e" translate="yes" xml:space="preserve">
          <source>This function is just a shim intended to be removed when the &lt;code&gt;unsized_locals&lt;/code&gt; feature gets stabilized.</source>
          <target state="translated">此功能只是打算在 &lt;code&gt;unsized_locals&lt;/code&gt; 功能稳定后删除的垫片。</target>
        </trans-unit>
        <trans-unit id="bc7e9741757bc42e41e144d227e772dfb6ad20fc" translate="yes" xml:space="preserve">
          <source>This function is mainly useful for data that lives for the remainder of the program's life. Dropping the returned reference will cause a memory leak.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="177431c922c0d0a7a204582e17b86736e812c93b" translate="yes" xml:space="preserve">
          <source>This function is mainly useful for data that lives for the remainder of the program's life. Dropping the returned reference will cause a memory leak. If this is not acceptable, the reference should first be wrapped with the &lt;a href=&quot;struct.box#method.from_raw&quot;&gt;&lt;code&gt;Box::from_raw&lt;/code&gt;&lt;/a&gt; function producing a &lt;code&gt;Box&lt;/code&gt;. This &lt;code&gt;Box&lt;/code&gt; can then be dropped which will properly destroy &lt;code&gt;T&lt;/code&gt; and release the allocated memory.</source>
          <target state="translated">此功能主要用于在程序的剩余生命期内保留的数据。删除返回的引用将导致内存泄漏。如果这是不可接受的，则应首先使用&lt;a href=&quot;struct.box#method.from_raw&quot;&gt; &lt;code&gt;Box::from_raw&lt;/code&gt; &lt;/a&gt;函数将引用包装起来，产生 &lt;code&gt;Box&lt;/code&gt; 。然后可以放下此 &lt;code&gt;Box&lt;/code&gt; ，这将适当地破坏 &lt;code&gt;T&lt;/code&gt; 并释放分配的内存。</target>
        </trans-unit>
        <trans-unit id="59cb1896e3dcd115f785bf2479cb4580b1b9722d" translate="yes" xml:space="preserve">
          <source>This function is not magic; it is literally defined as</source>
          <target state="translated">这个功能并不神奇,它的字面定义为</target>
        </trans-unit>
        <trans-unit id="cc2ffe8b61942162bfcfde0b12c33ce86e8880cb" translate="yes" xml:space="preserve">
          <source>This function is only safe to call if the following conditions hold:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeccb3e706f48a212133104a654e31843b7b7b92" translate="yes" xml:space="preserve">
          <source>This function is primarily used for optimization purposes.</source>
          <target state="translated">该功能主要用于优化目的。</target>
        </trans-unit>
        <trans-unit id="93c7910f6179639ce884370e8d94a5595d080311" translate="yes" xml:space="preserve">
          <source>This function is primarily useful for allowing byte-wise pointer arithmetic on potentially fat pointers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cd0464bff7e9c8dd1499717db18b2f31952ba8c" translate="yes" xml:space="preserve">
          <source>This function is safe, but actually using the return value is unsafe. See the documentation of &lt;a href=&quot;../slice/fn.from_raw_parts&quot;&gt;&lt;code&gt;slice::from_raw_parts&lt;/code&gt;&lt;/a&gt; for slice safety requirements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47c5699202ba358abe356e82ca7c6c5715bfdeae" translate="yes" xml:space="preserve">
          <source>This function is safe, but actually using the return value is unsafe. See the documentation of &lt;a href=&quot;../slice/fn.from_raw_parts_mut&quot;&gt;&lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt;&lt;/a&gt; for slice safety requirements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="451ae39575c352f08886704c7ffa48d2181b8a99" translate="yes" xml:space="preserve">
          <source>This function is safe, but dereferencing the return value is unsafe. See the documentation of &lt;a href=&quot;../slice/fn.from_raw_parts&quot;&gt;&lt;code&gt;slice::from_raw_parts&lt;/code&gt;&lt;/a&gt; for slice safety requirements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a4d03cae95a52ccbe2043ee8d63640e5a40a11f" translate="yes" xml:space="preserve">
          <source>This function is safe, even when the non-null raw slice cannot be dereferenced to a slice because the pointer does not have a valid address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f368bea1b2408b163770a1c33d9edf8ea07be6d6" translate="yes" xml:space="preserve">
          <source>This function is safe, even when the raw slice cannot be cast to a slice reference because the pointer is null or unaligned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a9053fe38824d2de0054cbaba771d8a6b62c54f" translate="yes" xml:space="preserve">
          <source>This function is semantically equivalent to &lt;a href=&quot;../mem/fn.replace&quot;&gt;&lt;code&gt;mem::replace&lt;/code&gt;&lt;/a&gt; except that it operates on raw pointers instead of references. When references are available, &lt;a href=&quot;../mem/fn.replace&quot;&gt;&lt;code&gt;mem::replace&lt;/code&gt;&lt;/a&gt; should be preferred.</source>
          <target state="translated">此函数在语义上等效于&lt;a href=&quot;../mem/fn.replace&quot;&gt; &lt;code&gt;mem::replace&lt;/code&gt; &lt;/a&gt;但它对原始指针（而不是引用）进行操作。当引用可用时，应首选&lt;a href=&quot;../mem/fn.replace&quot;&gt; &lt;code&gt;mem::replace&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7bc2ee69e11ff49cf8f44aa7be972ea956317ef2" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;a href=&quot;struct.file#method.sync_all&quot;&gt;&lt;code&gt;sync_all&lt;/code&gt;&lt;/a&gt;, except that it may not synchronize file metadata to the filesystem.</source>
          <target state="translated">该函数类似于&lt;a href=&quot;struct.file#method.sync_all&quot;&gt; &lt;code&gt;sync_all&lt;/code&gt; &lt;/a&gt;，除了它可能不将文件元数据同步到文件系统。</target>
        </trans-unit>
        <trans-unit id="c9cbe9f2a91fb1ea199b620a6bb920ab34b40788" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;wake&lt;/code&gt;, but must not consume the provided data pointer.</source>
          <target state="translated">此函数类似于 &lt;code&gt;wake&lt;/code&gt; ，但一定不能使用提供的数据指针。</target>
        </trans-unit>
        <trans-unit id="3817c9c59ae829a4e4b6db71acecc27e54fc335a" translate="yes" xml:space="preserve">
          <source>This function is similar to the &lt;a href=&quot;../boxed/struct.box#method.leak&quot;&gt;&lt;code&gt;leak&lt;/code&gt;&lt;/a&gt; function on &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt; except that there is no way to recover the leaked memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4ebf22d46bf6517393acc377fdd446867946954" translate="yes" xml:space="preserve">
          <source>This function is similar to the &lt;code&gt;leak&lt;/code&gt; function on &lt;code&gt;Box&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2a62d49d2d0f2fe0fb6a0071ccf5e43d3885dc1" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of &lt;a href=&quot;#method.to_bytes&quot;&gt;&lt;code&gt;to_bytes&lt;/code&gt;&lt;/a&gt; except that it will retain the trailing nul terminator instead of chopping it off.</source>
          <target state="translated">此函数等效于&lt;a href=&quot;#method.to_bytes&quot;&gt; &lt;code&gt;to_bytes&lt;/code&gt; ,&lt;/a&gt;除了它将保留尾随的nul终止符而不是将其切掉。</target>
        </trans-unit>
        <trans-unit id="aa81adf357f1575ab28bd1d9c5804caf46b4ba04" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of &lt;a href=&quot;struct.cstr#method.to_bytes&quot;&gt;&lt;code&gt;CStr::to_bytes&lt;/code&gt;&lt;/a&gt; except that it will retain the trailing nul terminator instead of chopping it off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbca71aedd00db40d26ceff11e63bc8c656a9f3e" translate="yes" xml:space="preserve">
          <source>This function is the inverse of &lt;a href=&quot;#method.offset&quot;&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数是&lt;a href=&quot;#method.offset&quot;&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/a&gt;的反函数。</target>
        </trans-unit>
        <trans-unit id="60af8a75ca29fd4b9524979a42c65b475dac17ca" translate="yes" xml:space="preserve">
          <source>This function is the inverse of &lt;a href=&quot;#method.offset-1&quot;&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数是&lt;a href=&quot;#method.offset-1&quot;&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/a&gt;的反函数。</target>
        </trans-unit>
        <trans-unit id="a968e659e413eae940af237b572b89fdec65a1f7" translate="yes" xml:space="preserve">
          <source>This function is the mirror of &lt;a href=&quot;#method.guaranteed_eq&quot;&gt;&lt;code&gt;guaranteed_eq&lt;/code&gt;&lt;/a&gt;, but not its inverse. There are pointer comparisons for which both functions return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df5c6e62763bfc43519897ed41868fc1d62d6938" translate="yes" xml:space="preserve">
          <source>This function is the mirror of &lt;a href=&quot;#method.guaranteed_ne&quot;&gt;&lt;code&gt;guaranteed_ne&lt;/code&gt;&lt;/a&gt;, but not its inverse. There are pointer comparisons for which both functions return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4e91aa4b5730d86849f9ad126912325901a438a" translate="yes" xml:space="preserve">
          <source>This function is unsafe as it does not verify the preconditions from &lt;a href=&quot;#method.from_size_align&quot;&gt;&lt;code&gt;Layout::from_size_align&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数不安全，因为它不验证&lt;a href=&quot;#method.from_size_align&quot;&gt; &lt;code&gt;Layout::from_size_align&lt;/code&gt; &lt;/a&gt;的前提条件。</target>
        </trans-unit>
        <trans-unit id="8570a34fff9bbf02e64d50247313e6b25b11941e" translate="yes" xml:space="preserve">
          <source>This function is unsafe as it does not verify the preconditions from &lt;a href=&quot;struct.layout#method.from_size_align&quot;&gt;&lt;code&gt;Layout::from_size_align&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0adf1d1fbca05371274b33d836dbb8ba3b0da96" translate="yes" xml:space="preserve">
          <source>This function is unsafe as there is no guarantee that the given pointer is valid for &lt;code&gt;len&lt;/code&gt; elements, nor whether the lifetime inferred is a suitable lifetime for the returned slice.</source>
          <target state="translated">此函数不安全，因为不能保证给定的指针对 &lt;code&gt;len&lt;/code&gt; 元素有效，也不能保证推断的生存期是否适合返回的片。</target>
        </trans-unit>
        <trans-unit id="ead8661237451bd45c2559207ff2f0d2dcefd5f7" translate="yes" xml:space="preserve">
          <source>This function is unsafe because improper use may lead to memory problems. For example, a double-free may occur if the function is called twice on the same raw pointer.</source>
          <target state="translated">这个函数是不安全的,因为使用不当可能会导致内存问题。例如,如果在同一个原始指针上调用该函数两次,可能会出现双免。</target>
        </trans-unit>
        <trans-unit id="35f3e90c9d123dc330088febbcb755f29e299a96" translate="yes" xml:space="preserve">
          <source>This function is unsafe because improper use may lead to memory unsafety, even if the returned &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; is never accessed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8bd102f6698ee49286a5c128925e7efc3ca2420" translate="yes" xml:space="preserve">
          <source>This function is unsafe because improper use may lead to memory unsafety, even if the returned &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; is never accessed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f0606f18b84a9d14096f66fc981df0b42c6d0bf" translate="yes" xml:space="preserve">
          <source>This function is unsafe because it does not check that the bytes passed to it are valid UTF-8. If this constraint is violated, it may cause memory unsafety issues with future users of the &lt;code&gt;String&lt;/code&gt;, as the rest of the standard library assumes that &lt;code&gt;String&lt;/code&gt;s are valid UTF-8.</source>
          <target state="translated">此函数不安全，因为它不检查传递给它的字节是否为有效的UTF-8。如果违反了此约束，则将来的 &lt;code&gt;String&lt;/code&gt; 用户可能会导致内存不安全问题，因为标准库的其余部分都假定 &lt;code&gt;String&lt;/code&gt; 是有效的UTF-8。</target>
        </trans-unit>
        <trans-unit id="36c2b1be1ffd545e988489f24fde5b599256ff94" translate="yes" xml:space="preserve">
          <source>This function is unsafe because it does not check that the bytes passed to it are valid UTF-8. If this constraint is violated, undefined behavior results, as the rest of Rust assumes that &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;s are valid UTF-8.</source>
          <target state="translated">此函数不安全，因为它不检查传递给它的字节是否为有效的UTF-8。如果违反了此约束，则将导致未定义的行为，因为Rust的其余部分都假定&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;是有效的UTF-8。</target>
        </trans-unit>
        <trans-unit id="d26d0eb0451d8006697165ba21e7f4a6d2affd96" translate="yes" xml:space="preserve">
          <source>This function is unsafe because undefined behavior can result if the caller does not ensure all of the following:</source>
          <target state="translated">这个函数是不安全的,因为如果调用者没有确保以下所有条件,就会产生未定义的行为。</target>
        </trans-unit>
        <trans-unit id="42a04935e77664a45c1ca55344796f0f9622e5b5" translate="yes" xml:space="preserve">
          <source>This function is unsafe because undefined behavior can result if the caller does not ensure both:</source>
          <target state="translated">这个函数是不安全的,因为如果调用者不确保这两点,可能会导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="b81cd2be550f8d99eeb1700fa914c58868e2867c" translate="yes" xml:space="preserve">
          <source>This function is unsafe because undefined behavior can result if the caller does not ensure that &lt;code&gt;layout&lt;/code&gt; has non-zero size.</source>
          <target state="translated">此函数是不安全的，因为如果调用者不确保 &lt;code&gt;layout&lt;/code&gt; 大小为非零，则可能导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="454ec0a5acadcaac0aa85170f5ed93cb46c13302" translate="yes" xml:space="preserve">
          <source>This function is unsafe for the same reasons as &lt;a href=&quot;fn.from_raw_parts&quot;&gt;&lt;code&gt;from_raw_parts&lt;/code&gt;&lt;/a&gt;, as well as not being able to provide a non-aliasing guarantee of the returned mutable slice. &lt;code&gt;data&lt;/code&gt; must be non-null and aligned even for zero-length slices as with &lt;a href=&quot;fn.from_raw_parts&quot;&gt;&lt;code&gt;from_raw_parts&lt;/code&gt;&lt;/a&gt;. The total size of the slice must be no larger than &lt;code&gt;isize::MAX&lt;/code&gt;&lt;strong&gt;bytes&lt;/strong&gt; in memory.</source>
          <target state="translated">出于与&lt;a href=&quot;fn.from_raw_parts&quot;&gt; &lt;code&gt;from_raw_parts&lt;/code&gt; &lt;/a&gt;相同的原因，该函数是不安全的，并且不能为返回的可变切片提供非别名保证。 &lt;code&gt;data&lt;/code&gt; 必须是非null的，并且即使对于零长度的切片也必须与&lt;a href=&quot;fn.from_raw_parts&quot;&gt; &lt;code&gt;from_raw_parts&lt;/code&gt; 对齐&lt;/a&gt;。切片的总大小不得大于内存中的 &lt;code&gt;isize::MAX&lt;/code&gt; &lt;strong&gt;字节&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="eecdc0e72496ca31779009b14276f9c964f0fc63" translate="yes" xml:space="preserve">
          <source>This function is unsafe for the same reasons that &lt;code&gt;alloc&lt;/code&gt; is.</source>
          <target state="translated">出于与 &lt;code&gt;alloc&lt;/code&gt; 相同的原因，此函数不安全。</target>
        </trans-unit>
        <trans-unit id="f46ccfd28f902efc152ad3d0bc725d272999fa8f" translate="yes" xml:space="preserve">
          <source>This function is unsafe for the same reasons that &lt;code&gt;alloc&lt;/code&gt; is. However the allocated block of memory is guaranteed to be initialized.</source>
          <target state="translated">出于与 &lt;code&gt;alloc&lt;/code&gt; 相同的原因，此函数不安全。但是，保证已分配的内存块将被初始化。</target>
        </trans-unit>
        <trans-unit id="c8935ef267a58bf14edf52661928291938f416d8" translate="yes" xml:space="preserve">
          <source>This function is unsafe for the same reasons that &lt;code&gt;realloc&lt;/code&gt; is.</source>
          <target state="translated">出于与 &lt;code&gt;realloc&lt;/code&gt; 相同的原因，此函数不安全。</target>
        </trans-unit>
        <trans-unit id="010c54d09909e31d21b794c4e10275c4b255b332" translate="yes" xml:space="preserve">
          <source>This function is unsafe, as it may construct invalid &lt;code&gt;char&lt;/code&gt; values.</source>
          <target state="translated">此函数不安全，因为它可能构造无效的 &lt;code&gt;char&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="71a1e970e4af15e1e28b626518e246fe2beaa9ff" translate="yes" xml:space="preserve">
          <source>This function is unsafe. You must guarantee that the data you return will not move so long as the argument value does not move (for example, because it is one of the fields of that value), and also that you do not move out of the argument you receive to the interior function.</source>
          <target state="translated">这个函数是不安全的。你必须保证你返回的数据不会移动,只要参数值不移动(例如,因为它是该值的其中一个字段),也必须保证你接收到的参数不会移出内部函数。</target>
        </trans-unit>
        <trans-unit id="39a3dbf4634bdba5a0505dade8771f96ac64c22f" translate="yes" xml:space="preserve">
          <source>This function is unsafe. You must guarantee that you will continue to treat the pointer &lt;code&gt;P&lt;/code&gt; as pinned after you call this function, so that the invariants on the &lt;code&gt;Pin&lt;/code&gt; type can be upheld. If the code using the resulting &lt;code&gt;P&lt;/code&gt; does not continue to maintain the pinning invariants that is a violation of the API contract and may lead to undefined behavior in later (safe) operations.</source>
          <target state="translated">此功能不安全。您必须保证调用此函数后，将继续将指针 &lt;code&gt;P&lt;/code&gt; 视为固定的，以便可以保留 &lt;code&gt;Pin&lt;/code&gt; 类型的不变性。如果使用结果 &lt;code&gt;P&lt;/code&gt; 的代码不能继续维护固定不变，这违反了API约定，并且可能在以后的（安全）操作中导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="6c0c82733953c468905548df35ad6822c84f6c7f" translate="yes" xml:space="preserve">
          <source>This function is unsafe. You must guarantee that you will never move the data out of the mutable reference you receive when you call this function, so that the invariants on the &lt;code&gt;Pin&lt;/code&gt; type can be upheld.</source>
          <target state="translated">此功能不安全。您必须保证在调用此函数时永远不会将数据移出接收到的可变引用中，以便可以保留 &lt;code&gt;Pin&lt;/code&gt; 类型的不变性。</target>
        </trans-unit>
        <trans-unit id="a2e566f884f51c3384b3aa58f5bde7f2e2df2f79" translate="yes" xml:space="preserve">
          <source>This function is used to generically create I/O errors which do not originate from the OS itself. The &lt;code&gt;error&lt;/code&gt; argument is an arbitrary payload which will be contained in this &lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94b97e70917e2ec0dff12c2bd6e40f05c9be7d64" translate="yes" xml:space="preserve">
          <source>This function is used to generically create I/O errors which do not originate from the OS itself. The &lt;code&gt;error&lt;/code&gt; argument is an arbitrary payload which will be contained in this &lt;code&gt;Error&lt;/code&gt;.</source>
          <target state="translated">此功能通常用于创建并非源于OS本身的I / O错误。该 &lt;code&gt;error&lt;/code&gt; 参数是将被包含在该任意的有效载荷 &lt;code&gt;Error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5970a37a4fd89e4e4191139591e16ccec329bf2a" translate="yes" xml:space="preserve">
          <source>This function is useful for interacting with foreign interfaces which use two pointers to refer to a range of elements in memory, as is common in C++.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bf849f4d8fe700d85a6260475a19ac69c25acf8" translate="yes" xml:space="preserve">
          <source>This function is very easy to write, thanks to &lt;code&gt;match&lt;/code&gt;, and will look like Listing 6-5.</source>
          <target state="translated">借助 &lt;code&gt;match&lt;/code&gt; ，此函数非常易于编写，类似于清单6-5。</target>
        </trans-unit>
        <trans-unit id="19c2bab36fa633ea4bf26b73afdd5bd0e16edc9a" translate="yes" xml:space="preserve">
          <source>This function is, in some sense, the opposite of &lt;a href=&quot;#method.zip&quot;&gt;&lt;code&gt;zip&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在某种意义上，该功能与&lt;a href=&quot;#method.zip&quot;&gt; &lt;code&gt;zip&lt;/code&gt; &lt;/a&gt;相反。</target>
        </trans-unit>
        <trans-unit id="a37c6f8dc5c32c647225cb24a1c4f508d03c0fdf" translate="yes" xml:space="preserve">
          <source>This function is, in some sense, the opposite of &lt;a href=&quot;trait.iterator#method.zip&quot;&gt;&lt;code&gt;zip&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ee7b59ee419592da35ea7242eb2e8123baaf3cf" translate="yes" xml:space="preserve">
          <source>This function may &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; if it is used with more than one mutex over time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f705e261edec6d4798f68322cebb8b5768877e5d" translate="yes" xml:space="preserve">
          <source>This function may fail as the underlying system clock is susceptible to drift and updates (e.g., the system clock could go backwards), so this function may not always succeed. If successful, &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt; is returned where the duration represents the amount of time elapsed from this time measurement to the current time.</source>
          <target state="translated">由于基础系统时钟易于漂移和更新（例如，系统时钟可能倒退），因此此功能可能会失败，因此此功能可能并不总是成功。如果成功，则返回&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; &lt;code&gt;)&lt;/code&gt; ，其中持续时间表示从该时间测量到当前时间所经过的时间。</target>
        </trans-unit>
        <trans-unit id="a43d8a17e850a82c732c367bf89a844d3d96e4fe" translate="yes" xml:space="preserve">
          <source>This function may fail because measurements taken earlier are not guaranteed to always be before later measurements (due to anomalies such as the system clock being adjusted either forwards or backwards).</source>
          <target state="translated">该功能可能会失效,因为不能保证之前的测量值总是在后面的测量值之前(由于异常情况,如系统时钟被向前或向后调整)。</target>
        </trans-unit>
        <trans-unit id="8dd49c0cb240e2dbb52b64ec4b25e571052a70a5" translate="yes" xml:space="preserve">
          <source>This function may fail because measurements taken earlier are not guaranteed to always be before later measurements (due to anomalies such as the system clock being adjusted either forwards or backwards). &lt;a href=&quot;struct.instant&quot;&gt;&lt;code&gt;Instant&lt;/code&gt;&lt;/a&gt; can be used to measure elapsed time without this risk of failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5904fd4e8b5ae82205f779a00c5c8f588077b44a" translate="yes" xml:space="preserve">
          <source>This function may panic if &lt;code&gt;key&lt;/code&gt; is empty, contains an ASCII equals sign &lt;code&gt;'='&lt;/code&gt; or the NUL character &lt;code&gt;'\0'&lt;/code&gt;, or when the value contains the NUL character.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 为空，包含ASCII等于符号 &lt;code&gt;'='&lt;/code&gt; 或NUL字符 &lt;code&gt;'\0'&lt;/code&gt; 或值包含NUL字符，则此函数可能会出现紧急情况。</target>
        </trans-unit>
        <trans-unit id="9a0dc67c9d122eb74decfcdabf36a2e9b439b108" translate="yes" xml:space="preserve">
          <source>This function may panic if it is called after the &lt;code&gt;Complete&lt;/code&gt; variant has been returned previously. While generator literals in the language are guaranteed to panic on resuming after &lt;code&gt;Complete&lt;/code&gt;, this is not guaranteed for all implementations of the &lt;code&gt;Generator&lt;/code&gt; trait.</source>
          <target state="translated">如果在先前返回 &lt;code&gt;Complete&lt;/code&gt; 变体之后调用此函数，则可能会感到恐慌。尽管可以保证在 &lt;code&gt;Complete&lt;/code&gt; 语言后继续使用该语言的生成器文字会感到恐慌，但这并不能保证所有 &lt;code&gt;Generator&lt;/code&gt; 特征的实现都可以保证。</target>
        </trans-unit>
        <trans-unit id="22c11ebcd140410550c98ffdd0ada9fb8238ab32" translate="yes" xml:space="preserve">
          <source>This function may panic if the current time is earlier than this instant, which is something that can happen if an &lt;code&gt;Instant&lt;/code&gt; is produced synthetically.</source>
          <target state="translated">如果当前时间早于此瞬间，则此功能可能会出现紧急情况；如果综合生产 &lt;code&gt;Instant&lt;/code&gt; ,则可能会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="24a0a37cf3864874d04875e7b90815fd8bf61604" translate="yes" xml:space="preserve">
          <source>This function may panic if the resulting point in time cannot be represented by the underlying data structure. See &lt;a href=&quot;../time/struct.instant#method.checked_add&quot;&gt;&lt;code&gt;Instant::checked_add&lt;/code&gt;&lt;/a&gt; for a version without panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aed85a838914397cfff90a6f158e84b7b3b4829" translate="yes" xml:space="preserve">
          <source>This function may panic if the resulting point in time cannot be represented by the underlying data structure. See &lt;a href=&quot;../time/struct.instant#method.checked_add&quot;&gt;&lt;code&gt;checked_add&lt;/code&gt;&lt;/a&gt; for a version without panic.</source>
          <target state="translated">如果结果的时间点无法由基础数据结构表示，则此功能可能会出现紧急情况。参见&lt;a href=&quot;../time/struct.instant#method.checked_add&quot;&gt; &lt;code&gt;checked_add&lt;/code&gt; ,&lt;/a&gt;了解没有出现紧急情况的版本。</target>
        </trans-unit>
        <trans-unit id="9bc75e1d489664d08b58daa300cbacf1f7764cb4" translate="yes" xml:space="preserve">
          <source>This function may panic if the resulting point in time cannot be represented by the underlying data structure. See &lt;a href=&quot;../time/struct.systemtime#method.checked_add&quot;&gt;&lt;code&gt;SystemTime::checked_add&lt;/code&gt;&lt;/a&gt; for a version without panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="366269740ca74a1798b4e975775caf12fd1ce852" translate="yes" xml:space="preserve">
          <source>This function may panic if the resulting point in time cannot be represented by the underlying data structure. See &lt;a href=&quot;../time/struct.systemtime#method.checked_add&quot;&gt;&lt;code&gt;checked_add&lt;/code&gt;&lt;/a&gt; for a version without panic.</source>
          <target state="translated">如果结果的时间点无法由基础数据结构表示，则此功能可能会出现紧急情况。参见&lt;a href=&quot;../time/struct.systemtime#method.checked_add&quot;&gt; &lt;code&gt;checked_add&lt;/code&gt; ,&lt;/a&gt;了解没有出现紧急情况的版本。</target>
        </trans-unit>
        <trans-unit id="401bf91c85ca55e966355c7f85b21d7639dab4cd" translate="yes" xml:space="preserve">
          <source>This function may panic if the resulting point in time cannot be represented by the underlying data structure. See &lt;a href=&quot;struct.instant#method.checked_add&quot;&gt;&lt;code&gt;Instant::checked_add&lt;/code&gt;&lt;/a&gt; for a version without panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f02bfc3fdf0149848c26b5693e3c3c2e193c842" translate="yes" xml:space="preserve">
          <source>This function may panic if the resulting point in time cannot be represented by the underlying data structure. See &lt;a href=&quot;struct.instant#method.checked_add&quot;&gt;&lt;code&gt;checked_add&lt;/code&gt;&lt;/a&gt; for a version without panic.</source>
          <target state="translated">如果结果的时间点无法由基础数据结构表示，则此功能可能会出现紧急情况。参见&lt;a href=&quot;struct.instant#method.checked_add&quot;&gt; &lt;code&gt;checked_add&lt;/code&gt; ,&lt;/a&gt;了解没有出现紧急情况的版本。</target>
        </trans-unit>
        <trans-unit id="6625bc40abfc907779e7819cb337a56bc6be6b98" translate="yes" xml:space="preserve">
          <source>This function may panic if the resulting point in time cannot be represented by the underlying data structure. See &lt;a href=&quot;struct.systemtime#method.checked_add&quot;&gt;&lt;code&gt;SystemTime::checked_add&lt;/code&gt;&lt;/a&gt; for a version without panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df93ffa2c06e7d9c793296fff9096b1f4a09746a" translate="yes" xml:space="preserve">
          <source>This function may panic if the resulting point in time cannot be represented by the underlying data structure. See &lt;a href=&quot;struct.systemtime#method.checked_add&quot;&gt;&lt;code&gt;checked_add&lt;/code&gt;&lt;/a&gt; for a version without panic.</source>
          <target state="translated">如果结果的时间点无法由基础数据结构表示，则此功能可能会出现紧急情况。参见&lt;a href=&quot;struct.systemtime#method.checked_add&quot;&gt; &lt;code&gt;checked_add&lt;/code&gt; ,&lt;/a&gt;了解没有出现紧急情况的版本。</target>
        </trans-unit>
        <trans-unit id="f047ee1947a40935115c87e9ff5da84ba7c716fb" translate="yes" xml:space="preserve">
          <source>This function may panic on some platforms if a thread attempts to join itself or otherwise may create a deadlock with joining threads.</source>
          <target state="translated">如果一个线程试图加入自己,这个函数在某些平台上可能会恐慌,否则可能会造成加入线程的死锁。</target>
        </trans-unit>
        <trans-unit id="2aa9c9fbe6e7d8e79dbcc09f82ff622cc49e7e8c" translate="yes" xml:space="preserve">
          <source>This function might panic if the iterator has more than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">如果迭代器具有超过&lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt;元素，则此函数可能会感到恐慌。</target>
        </trans-unit>
        <trans-unit id="d1fc6a40a80536289c51eca2e61adf3162489e6d" translate="yes" xml:space="preserve">
          <source>This function might panic if the iterator has more than &lt;code&gt;usize::MAX&lt;/code&gt; non-matching elements.</source>
          <target state="translated">如果迭代器具有超过 &lt;code&gt;usize::MAX&lt;/code&gt; 不匹配元素，则此函数可能会感到恐慌。</target>
        </trans-unit>
        <trans-unit id="e85b3c94c6e63ddd25298570364b3a6122b73135" translate="yes" xml:space="preserve">
          <source>This function might panic when called if the lock is already held by the current thread.</source>
          <target state="translated">如果锁已经被当前线程持有,这个函数在调用时可能会惊慌失措。</target>
        </trans-unit>
        <trans-unit id="b3552c30ec404d25019fce8d0e95a821dc885077" translate="yes" xml:space="preserve">
          <source>This function panics if &lt;code&gt;T&lt;/code&gt; is a Zero-Sized Type (&quot;ZST&quot;).</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是零尺寸类型（&amp;ldquo; ZST&amp;rdquo;），则此函数会出现紧急情况。</target>
        </trans-unit>
        <trans-unit id="101814bfeeecf8436008ed4880368756ae5c8d29" translate="yes" xml:space="preserve">
          <source>This function panics if &lt;code&gt;T&lt;/code&gt; is a zero-sized type.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是零大小的类型，则此函数会出现紧急情况。</target>
        </trans-unit>
        <trans-unit id="9eaa9b63e5ef7b899f75363fe8681ac3e3da2fd4" translate="yes" xml:space="preserve">
          <source>This function panics if &lt;code&gt;radix&lt;/code&gt; is not in the range from 2 to 36.</source>
          <target state="translated">如果 &lt;code&gt;radix&lt;/code&gt; 不在2到36范围内，则此功能会出现紧急情况。</target>
        </trans-unit>
        <trans-unit id="f62c2a73ad1ab98a4ef40a980a80cd47e78cfc5e" translate="yes" xml:space="preserve">
          <source>This function reads as many bytes as necessary to completely fill the specified buffer &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">该函数读取所需的字节数以完全填充指定的缓冲区 &lt;code&gt;buf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c39eec7f7794b4915b46c58cff436d679c91fcab" translate="yes" xml:space="preserve">
          <source>This function reads the value of &lt;code&gt;errno&lt;/code&gt; for the target platform (e.g. &lt;code&gt;GetLastError&lt;/code&gt; on Windows) and will return a corresponding instance of &lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; for the error code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32152f76d2e83d5c89836d9aa45ce33c14bc03d9" translate="yes" xml:space="preserve">
          <source>This function reads the value of &lt;code&gt;errno&lt;/code&gt; for the target platform (e.g. &lt;code&gt;GetLastError&lt;/code&gt; on Windows) and will return a corresponding instance of &lt;code&gt;Error&lt;/code&gt; for the error code.</source>
          <target state="translated">此函数读取目标平台的 &lt;code&gt;errno&lt;/code&gt; 值（例如Windows上的 &lt;code&gt;GetLastError&lt;/code&gt; ），并将为错误代码返回相应的 &lt;code&gt;Error&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="1cc405a72fa71224d4a044b7593cdccf93a633ec" translate="yes" xml:space="preserve">
          <source>This function returning &lt;code&gt;false&lt;/code&gt; does not mean that &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; has not been executed. For example, it may have been executed in the time between when &lt;code&gt;is_completed&lt;/code&gt; starts executing and when it returns, in which case the &lt;code&gt;false&lt;/code&gt; return value would be stale (but still permissible).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05ed95f7312c1878141bc36d8d210b9fa11581c5" translate="yes" xml:space="preserve">
          <source>This function returns a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&amp;lt;'a, str&amp;gt;&lt;/code&gt;&lt;/a&gt;. If our byte slice is invalid UTF-8, then we need to insert the replacement characters, which will change the size of the string, and hence, require a &lt;code&gt;String&lt;/code&gt;. But if it's already valid UTF-8, we don't need a new allocation. This return type allows us to handle both cases.</source>
          <target state="translated">此函数返回&lt;a href=&quot;../borrow/enum.cow&quot;&gt; &lt;code&gt;Cow&amp;lt;'a, str&amp;gt;&lt;/code&gt; &lt;/a&gt;。如果字节片无效的UTF-8，则需要插入替换字符，这将改变字符串的大小，因此需要 &lt;code&gt;String&lt;/code&gt; 。但是，如果它已经是有效的UTF-8，则不需要新的分配。这种返回类型使我们能够处理两种情况。</target>
        </trans-unit>
        <trans-unit id="12ee7d651a482e6bf7ef02b5e21ea7e98deba17a" translate="yes" xml:space="preserve">
          <source>This function returns a new OpenOptions object that you can use to open or create a file with specific options if &lt;code&gt;open()&lt;/code&gt; or &lt;code&gt;create()&lt;/code&gt; are not appropriate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f72ba6fb91e1ce3e00f9d70494a4d758f1ff97b" translate="yes" xml:space="preserve">
          <source>This function returns a new instance of &lt;code&gt;Read&lt;/code&gt; which will read at most &lt;code&gt;limit&lt;/code&gt; bytes, after which it will always return EOF (&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(0)&lt;/code&gt;&lt;/a&gt;). Any read errors will not count towards the number of bytes read and future calls to &lt;a href=&quot;trait.read#tymethod.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt; may succeed.</source>
          <target state="translated">此函数返回 &lt;code&gt;Read&lt;/code&gt; 的新实例，该实例最多将读取 &lt;code&gt;limit&lt;/code&gt; 字节，此后它将始终返回EOF（&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(0)&lt;/code&gt; &lt;/a&gt;）。任何读取错误都不会计入读取的字节数，将来对&lt;a href=&quot;trait.read#tymethod.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; 的&lt;/a&gt;调用可能会成功。</target>
        </trans-unit>
        <trans-unit id="ef0ad46bb886f62fbf2201ba9b9f859d8daf73a5" translate="yes" xml:space="preserve">
          <source>This function returns:</source>
          <target state="translated">该函数返回:</target>
        </trans-unit>
        <trans-unit id="e286b47aa27a1649f35422e9cb038c26279f95e3" translate="yes" xml:space="preserve">
          <source>This function runs the destructor of the contained value and thus the wrapped value now represents uninitialized data. It is up to the user of this method to ensure the uninitialized data is not actually used.</source>
          <target state="translated">这个函数运行了包含值的析构器,因此现在被包装的值代表未初始化的数据。该方法的使用者要确保未初始化的数据没有被实际使用。</target>
        </trans-unit>
        <trans-unit id="d626c9a67f6c1bb6dde6295b947e23c4df085081" translate="yes" xml:space="preserve">
          <source>This function runs the destructor of the contained value. Other than changes made by the destructor itself, the memory is left unchanged, and so as far as the compiler is concerned still holds a bit-pattern which is valid for the type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7791922c183e6e6d1b0127e9349abae66c275dd6" translate="yes" xml:space="preserve">
          <source>This function semantically moves out the contained value without preventing further usage, leaving the state of this container unchanged. It is your responsibility to ensure that this &lt;code&gt;ManuallyDrop&lt;/code&gt; is not used again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e07f846f13b5b07afd4d29501d5ea48bcae4f64b" translate="yes" xml:space="preserve">
          <source>This function semantically moves out the contained value without preventing further usage. It is up to the user of this method to ensure that this container is not used again.</source>
          <target state="translated">这个函数在语义上将包含的值移出,而不阻止继续使用。本方法的使用者要确保这个容器不会被再次使用。</target>
        </trans-unit>
        <trans-unit id="b73fe46d5d15372cef97957fc6bcb2aba3a35b19" translate="yes" xml:space="preserve">
          <source>This function specifies a new multicast group for this socket to join. The address must be a valid multicast address, and &lt;code&gt;interface&lt;/code&gt; is the address of the local interface with which the system should join the multicast group. If it's equal to &lt;code&gt;INADDR_ANY&lt;/code&gt; then an appropriate interface is chosen by the system.</source>
          <target state="translated">此函数为此套接字指定一个新的多播组。该地址必须是有效的多播地址，而 &lt;code&gt;interface&lt;/code&gt; 是系统应加入多播组的本地接口的地址。如果等于 &lt;code&gt;INADDR_ANY&lt;/code&gt; ,则系统选择适当的接口。</target>
        </trans-unit>
        <trans-unit id="1f12ea05478bb3baf501603f551862b3ebf72f88" translate="yes" xml:space="preserve">
          <source>This function specifies a new multicast group for this socket to join. The address must be a valid multicast address, and &lt;code&gt;interface&lt;/code&gt; is the index of the interface to join/leave (or 0 to indicate any interface).</source>
          <target state="translated">此函数为此套接字指定一个新的多播组。该地址必须是有效的多播地址，而 &lt;code&gt;interface&lt;/code&gt; 是要加入/离开的接口的索引（或0表示任何接口）。</target>
        </trans-unit>
        <trans-unit id="24119e41ff16fdb059a46c613efe17ad7fc57293" translate="yes" xml:space="preserve">
          <source>This function takes a string slice and emits it to the internal buffer after applying the relevant formatting flags specified. The flags recognized for generic strings are:</source>
          <target state="translated">该函数接收一个字符串片断,并在应用相关的格式化标志后将其输出到内部缓冲区。对于通用字符串来说,识别的标志有:1:</target>
        </trans-unit>
        <trans-unit id="5aebd3cecb06bef11683a2b627652c498c3d60b0" translate="yes" xml:space="preserve">
          <source>This function will &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; if it is used with more than one mutex over time. Each condition variable is dynamically bound to exactly one mutex to ensure defined behavior across platforms. If this functionality is not desired, then unsafe primitives in &lt;code&gt;sys&lt;/code&gt; are provided.</source>
          <target state="translated">此功能会&lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;如果一段时间内它与多个互斥体一起使用。每个条件变量都动态地绑定到一个互斥体上，以确保跨平台定义行为。如果不需要此功能，则在 &lt;code&gt;sys&lt;/code&gt; 中提供不安全的原语。</target>
        </trans-unit>
        <trans-unit id="78327b333ccf6b689aaecb9ee26d119fa6c5777a" translate="yes" xml:space="preserve">
          <source>This function will &lt;code&gt;panic!()&lt;/code&gt; if the key currently has its destructor running, and it &lt;strong&gt;may&lt;/strong&gt; panic if the destructor has previously been run for this thread.</source>
          <target state="translated">如果该键当前正在运行其析构函数，则此函数将出现 &lt;code&gt;panic!()&lt;/code&gt; ;如果先前已为此线程运行了析构函数，则该函数&lt;strong&gt;可能会&lt;/strong&gt;处于恐慌状态。</target>
        </trans-unit>
        <trans-unit id="de2e867f0f0c2461353251de2093fad37d9de75b" translate="yes" xml:space="preserve">
          <source>This function will &lt;em&gt;block&lt;/em&gt; until space in the internal buffer becomes available or a receiver is available to hand off the message to.</source>
          <target state="translated">该功能将一直&lt;em&gt;阻塞，&lt;/em&gt;直到内部缓冲区中的空间可用或接收者可以将消息传递给它为止。</target>
        </trans-unit>
        <trans-unit id="aa7ba2de98a6c309498a7c489e34ef4ae855d255" translate="yes" xml:space="preserve">
          <source>This function will &lt;strong&gt;consume ownership&lt;/strong&gt; of the handle given, passing responsibility for closing the handle to the returned object.</source>
          <target state="translated">该函数将&lt;strong&gt;消耗&lt;/strong&gt;给定句柄的&lt;strong&gt;所有权&lt;/strong&gt;，将关闭句柄的责任传递给返回的对象。</target>
        </trans-unit>
        <trans-unit id="b6de52c208f12c4efe8542e2cc11b06fa42d2cf9" translate="yes" xml:space="preserve">
          <source>This function will &lt;strong&gt;consume ownership&lt;/strong&gt; of the socket provided and it will be closed when the returned object goes out of scope.</source>
          <target state="translated">此函数将&lt;strong&gt;使用&lt;/strong&gt;提供的套接字的&lt;strong&gt;所有权&lt;/strong&gt;，并且在返回的对象超出范围时将关闭它。</target>
        </trans-unit>
        <trans-unit id="34a9593fc439cb6bab67a9e273e42357e335b574" translate="yes" xml:space="preserve">
          <source>This function will &lt;strong&gt;overwrite&lt;/strong&gt; the contents of &lt;code&gt;to&lt;/code&gt;.</source>
          <target state="translated">此函数将&lt;strong&gt;覆盖&lt;/strong&gt; &lt;code&gt;to&lt;/code&gt; 的内容。</target>
        </trans-unit>
        <trans-unit id="b50d15cbddd54c77fb77c9639aae5bb9352e901e" translate="yes" xml:space="preserve">
          <source>This function will always block the current thread if there is no data available and it's possible for more data to be sent. Once a message is sent to the corresponding &lt;a href=&quot;struct.sender&quot;&gt;&lt;code&gt;Sender&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;struct.syncsender&quot;&gt;&lt;code&gt;SyncSender&lt;/code&gt;&lt;/a&gt;), then this receiver will wake up and return that message.</source>
          <target state="translated">如果没有可用数据，并且有可能发送更多数据，则此函数将始终阻止当前线程。将消息发送到相应的&lt;a href=&quot;struct.sender&quot;&gt; &lt;code&gt;Sender&lt;/code&gt; &lt;/a&gt;（或&lt;a href=&quot;struct.syncsender&quot;&gt; &lt;code&gt;SyncSender&lt;/code&gt; &lt;/a&gt;）后，此接收器将唤醒并返回该消息。</target>
        </trans-unit>
        <trans-unit id="2f7bc7c7785b26db5d2ba1d43d57ec9e10153387" translate="yes" xml:space="preserve">
          <source>This function will atomically unlock the mutex specified (represented by &lt;code&gt;guard&lt;/code&gt;) and block the current thread. This means that any calls to &lt;a href=&quot;#method.notify_one&quot;&gt;&lt;code&gt;notify_one&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#method.notify_all&quot;&gt;&lt;code&gt;notify_all&lt;/code&gt;&lt;/a&gt; which happen logically after the mutex is unlocked are candidates to wake this thread up. When this function call returns, the lock specified will have been re-acquired.</source>
          <target state="translated">此函数将自动解锁指定的互斥锁（由 &lt;code&gt;guard&lt;/code&gt; 表示）并阻塞当前线程。这意味着在互斥锁解锁后逻辑上发生的对&lt;a href=&quot;#method.notify_one&quot;&gt; &lt;code&gt;notify_one&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#method.notify_all&quot;&gt; &lt;code&gt;notify_all&lt;/code&gt; 的&lt;/a&gt;任何调用都是唤醒此线程的候选对象。当此函数调用返回时，将重新获得指定的锁。</target>
        </trans-unit>
        <trans-unit id="07010b30f6fb56afc898bded5d3cc83a49e39776" translate="yes" xml:space="preserve">
          <source>This function will atomically unlock the mutex specified (represented by &lt;code&gt;guard&lt;/code&gt;) and block the current thread. This means that any calls to &lt;a href=&quot;struct.condvar#method.notify_one&quot;&gt;&lt;code&gt;notify_one&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.condvar#method.notify_all&quot;&gt;&lt;code&gt;notify_all&lt;/code&gt;&lt;/a&gt; which happen logically after the mutex is unlocked are candidates to wake this thread up. When this function call returns, the lock specified will have been re-acquired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d633c453ad140c0449c1db8cbeeaa851bc2659b6" translate="yes" xml:space="preserve">
          <source>This function will attempt to ensure that all in-memory data reaches the filesystem before returning.</source>
          <target state="translated">该函数将尝试确保所有内存中的数据在返回之前到达文件系统。</target>
        </trans-unit>
        <trans-unit id="3cdc162bace3b7e0f3af0944a143fb84bab4d03d" translate="yes" xml:space="preserve">
          <source>This function will attempt to write the entire contents of &lt;code&gt;buf&lt;/code&gt;, but the entire write may not succeed, or the write may also generate an error. A call to &lt;code&gt;write&lt;/code&gt; represents &lt;em&gt;at most one&lt;/em&gt; attempt to write to any wrapped object.</source>
          <target state="translated">该函数将尝试写入 &lt;code&gt;buf&lt;/code&gt; 的全部内容，但是整个写入可能不会成功，或者写入可能还会生成错误。 &lt;code&gt;write&lt;/code&gt; 调用&lt;em&gt;最多&lt;/em&gt;表示一次写入任何包装对象的尝试。</target>
        </trans-unit>
        <trans-unit id="41d06b3c8e4189760b322760b47992d4717d7848" translate="yes" xml:space="preserve">
          <source>This function will be a noop if the &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; or &lt;code&gt;RUST_LIB_BACKTRACE&lt;/code&gt; backtrace variables are both not set. If either environment variable is set and enabled then this function will actually capture a backtrace. Capturing a backtrace can be both memory intensive and slow, so these environment variables allow liberally using &lt;code&gt;Backtrace::capture&lt;/code&gt; and only incurring a slowdown when the environment variables are set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d59143ff7e9860f113062c67363bd75c2092c35a" translate="yes" xml:space="preserve">
          <source>This function will be called when &lt;code&gt;wake&lt;/code&gt; is called on the &lt;a href=&quot;struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt;. It must wake up the task associated with this &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt;上调用 &lt;code&gt;wake&lt;/code&gt; 时，将调用此函数。它必须唤醒与此&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt;关联的任务。</target>
        </trans-unit>
        <trans-unit id="12cb59dc2a2a1b37303ef992097df532faaa8b94" translate="yes" xml:space="preserve">
          <source>This function will be called when &lt;code&gt;wake_by_ref&lt;/code&gt; is called on the &lt;a href=&quot;struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt;. It must wake up the task associated with this &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt;上调用 &lt;code&gt;wake_by_ref&lt;/code&gt; 时，将调用此函数。它必须唤醒与此&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt;关联的任务。</target>
        </trans-unit>
        <trans-unit id="76c72888278b0a8cb4941353a709e0ecd237c2c8" translate="yes" xml:space="preserve">
          <source>This function will be called when the &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; gets cloned, e.g. when the &lt;a href=&quot;struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; in which the &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; is stored gets cloned.</source>
          <target state="translated">当该功能将被称为&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt;被克隆，例如，当&lt;a href=&quot;struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt;在其中&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt;存储被克隆。</target>
        </trans-unit>
        <trans-unit id="83e27c1cac935244e1d8ce7e9b3bc5a49eb326cd" translate="yes" xml:space="preserve">
          <source>This function will block the calling thread until a new TCP connection is established. When established, the corresponding &lt;a href=&quot;struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt; and the remote peer's address will be returned.</source>
          <target state="translated">该函数将阻塞调用线程，直到建立新的TCP连接为止。建立后，将返回相应的&lt;a href=&quot;struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; &lt;/a&gt;和远程对等方的地址。</target>
        </trans-unit>
        <trans-unit id="b771e75bfd99083821bb9279c74d5a51cd594b6a" translate="yes" xml:space="preserve">
          <source>This function will block the calling thread until a new Unix connection is established. When established, the corresponding &lt;a href=&quot;struct.unixstream&quot;&gt;&lt;code&gt;UnixStream&lt;/code&gt;&lt;/a&gt; and the remote peer's address will be returned.</source>
          <target state="translated">该函数将阻塞调用线程，直到建立新的Unix连接为止。建立后，将返回相应的&lt;a href=&quot;struct.unixstream&quot;&gt; &lt;code&gt;UnixStream&lt;/code&gt; &lt;/a&gt;和远程对等方的地址。</target>
        </trans-unit>
        <trans-unit id="4d1cb142862a95e8531c0e6c5eeff4f29562add6" translate="yes" xml:space="preserve">
          <source>This function will block the local thread until it is available to acquire the mutex. Upon returning, the thread is the only thread with the lock held. An RAII guard is returned to allow scoped unlock of the lock. When the guard goes out of scope, the mutex will be unlocked.</source>
          <target state="translated">该函数将阻塞本地线程,直到它可以获取mutex。返回后,该线程是唯一一个拥有锁的线程。返回一个RAII守卫,允许在范围内解锁。当守护超出范围时,mutex将被解锁。</target>
        </trans-unit>
        <trans-unit id="1061d2d5e43718addf8cd833a952b821898f457c" translate="yes" xml:space="preserve">
          <source>This function will capture a stack backtrace of the current OS thread of execution, returning a &lt;code&gt;Backtrace&lt;/code&gt; type which can be later used to print the entire stack trace or render it to a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e63b5a3d38dde4813e2c02e7906910d9bbecad76" translate="yes" xml:space="preserve">
          <source>This function will cast the provided &lt;code&gt;bytes&lt;/code&gt; to a &lt;code&gt;CStr&lt;/code&gt; wrapper after ensuring that the byte slice is nul-terminated and does not contain any interior nul bytes.</source>
          <target state="translated">在确保字节片以nul终止并且不包含任何内部nul字节之后，此函数会将提供的 &lt;code&gt;bytes&lt;/code&gt; 转换为 &lt;code&gt;CStr&lt;/code&gt; 包装器。</target>
        </trans-unit>
        <trans-unit id="8c3891c10a9a0ae62223a6915ab48a717d1803e4" translate="yes" xml:space="preserve">
          <source>This function will cast the provided &lt;code&gt;bytes&lt;/code&gt; to a &lt;code&gt;CStr&lt;/code&gt; wrapper without performing any sanity checks. The provided slice &lt;strong&gt;must&lt;/strong&gt; be nul-terminated and not contain any interior nul bytes.</source>
          <target state="translated">此函数会将提供的 &lt;code&gt;bytes&lt;/code&gt; 转换为 &lt;code&gt;CStr&lt;/code&gt; 包装器，而不执行任何健全性检查。提供的片&lt;strong&gt;必须&lt;/strong&gt;以nul结尾，并且不包含任何内部nul字节。</target>
        </trans-unit>
        <trans-unit id="8f259ce0614bcf2d0063ac4400649f231860a760" translate="yes" xml:space="preserve">
          <source>This function will cause all pending and future I/O calls on the specified portions to immediately return with an appropriate value (see the documentation of &lt;a href=&quot;../../../net/enum.shutdown&quot;&gt;&lt;code&gt;Shutdown&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">此函数将导致指定部分上的所有未决和将来的I / O调用立即以适当的值返回（请参见&lt;a href=&quot;../../../net/enum.shutdown&quot;&gt; &lt;code&gt;Shutdown&lt;/code&gt; &lt;/a&gt;的文档）。</target>
        </trans-unit>
        <trans-unit id="f2081c3bcdd573e767785b3929fff378af8293c8" translate="yes" xml:space="preserve">
          <source>This function will cause all pending and future I/O on the specified portions to return immediately with an appropriate value (see the documentation of &lt;a href=&quot;enum.shutdown&quot;&gt;&lt;code&gt;Shutdown&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">此功能将导致指定部分上的所有未决和将来的I / O立即以适当的值返回（请参见&lt;a href=&quot;enum.shutdown&quot;&gt; &lt;code&gt;Shutdown&lt;/code&gt; &lt;/a&gt;的文档）。</target>
        </trans-unit>
        <trans-unit id="e9782cf601eece8d5d886326b28d5030905f50d6" translate="yes" xml:space="preserve">
          <source>This function will consume the provided data and use the underlying bytes to construct a new string, ensuring that there is a trailing 0 byte. This trailing 0 byte will be appended by this function; the provided data should &lt;em&gt;not&lt;/em&gt; contain any 0 bytes in it.</source>
          <target state="translated">此函数将使用提供的数据，并使用基础字节构造新的字符串，从而确保尾随0字节。这个尾随的0字节将被此函数附加；所提供的数据应&lt;em&gt;不&lt;/em&gt;包含在其中的任何0字节。</target>
        </trans-unit>
        <trans-unit id="4a81f58ae0af06c0e29ed9547bff428e9a075df5" translate="yes" xml:space="preserve">
          <source>This function will continuously read data from &lt;code&gt;reader&lt;/code&gt; and then write it into &lt;code&gt;writer&lt;/code&gt; in a streaming fashion until &lt;code&gt;reader&lt;/code&gt; returns EOF.</source>
          <target state="translated">该功能将不断读取数据 &lt;code&gt;reader&lt;/code&gt; ，然后将其写入 &lt;code&gt;writer&lt;/code&gt; 以流方式，直到 &lt;code&gt;reader&lt;/code&gt; 返回EOF。</target>
        </trans-unit>
        <trans-unit id="74b77ba5c4f9d07323cf0380138b2c4acac538aa" translate="yes" xml:space="preserve">
          <source>This function will correctly account for the flags provided as well as the minimum width. It will not take precision into account.</source>
          <target state="translated">该函数将正确地考虑所提供的标志以及最小宽度。它不会考虑精度。</target>
        </trans-unit>
        <trans-unit id="0e2de984561c8e2a215768e0c15afc535bb75bf0" translate="yes" xml:space="preserve">
          <source>This function will create a file if it does not exist, and will entirely replace its contents if it does.</source>
          <target state="translated">如果文件不存在,该函数将创建一个文件,如果存在,将完全替换其内容。</target>
        </trans-unit>
        <trans-unit id="f65976cf8345e044488976485c5a6e346af5a578" translate="yes" xml:space="preserve">
          <source>This function will create a file if it does not exist, and will truncate it if it does.</source>
          <target state="translated">如果文件不存在,该函数将创建一个文件,如果存在,该函数将截断它。</target>
        </trans-unit>
        <trans-unit id="0e1b8893ba63c7e2758784f05b5644780ac55d15" translate="yes" xml:space="preserve">
          <source>This function will ignore all instances of &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; and will otherwise return any errors returned by &lt;a href=&quot;#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数将忽略&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;所有实例，否则将返回&lt;a href=&quot;#tymethod.fill_buf&quot;&gt; &lt;code&gt;fill_buf&lt;/code&gt; &lt;/a&gt;返回的所有错误。</target>
        </trans-unit>
        <trans-unit id="a56b9fb350dbbed0024c336c03c94d6b856e68cd" translate="yes" xml:space="preserve">
          <source>This function will ignore all instances of &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; and will otherwise return any errors returned by &lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="326c8120454de566fb3a6866a530ebb7b6b992dc" translate="yes" xml:space="preserve">
          <source>This function will never panic, but it may return &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; if the &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt; has disconnected and is no longer able to receive information.</source>
          <target state="translated">此函数将永远不会崩溃，但是如果&lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt;断开连接并且不再能够接收信息，则它可能会返回&lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9fc6b983aea89da54a39cad92dbfed108559d536" translate="yes" xml:space="preserve">
          <source>This function will never return and will immediately terminate the current process. The exit code is passed through to the underlying OS and will be available for consumption by another process.</source>
          <target state="translated">这个函数永远不会返回,并将立即终止当前进程。退出代码会传递给底层操作系统,并供另一个进程使用。</target>
        </trans-unit>
        <trans-unit id="c4fd0f129a9f8ea495fd3f5d41ad244c1f805fd1" translate="yes" xml:space="preserve">
          <source>This function will not block the calling thread and will only check to see if the child process has exited or not. If the child has exited then on Unix the process ID is reaped. This function is guaranteed to repeatedly return a successful exit status so long as the child has already exited.</source>
          <target state="translated">这个函数不会阻塞调用线程,只会检查子进程是否已经退出。如果子进程已经退出,那么在Unix上就会收获进程ID。只要子进程已经退出,这个函数就能保证反复返回成功退出状态。</target>
        </trans-unit>
        <trans-unit id="db8a9f6074ffbe2434b96b3349b436c824d317bf" translate="yes" xml:space="preserve">
          <source>This function will not return while other writers or other readers currently have access to the lock.</source>
          <target state="translated">当其他写手或其他读者当前有访问锁的权限时,该函数不会返回。</target>
        </trans-unit>
        <trans-unit id="f40a0312ebfb2b0e54e13329e7ace227d51b5cf1" translate="yes" xml:space="preserve">
          <source>This function will not traverse symlinks if this entry points at a symlink.</source>
          <target state="translated">如果该条目指向一个符号链接,该函数将不会遍历符号链接。</target>
        </trans-unit>
        <trans-unit id="30de93c6705afd606c5b68502e92fede48ab8cb8" translate="yes" xml:space="preserve">
          <source>This function will not traverse symlinks if this entry points at a symlink. To traverse symlinks use &lt;a href=&quot;fn.metadata&quot;&gt;&lt;code&gt;fs::metadata&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.file#method.metadata&quot;&gt;&lt;code&gt;fs::File::metadata&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c834f424a9053dbdf6234c9da264d70e8ba7b880" translate="yes" xml:space="preserve">
          <source>This function will panic if &lt;code&gt;earlier&lt;/code&gt; is later than &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;earlier&lt;/code&gt; 于 &lt;code&gt;self&lt;/code&gt; ,则此功能会出现紧急情况。</target>
        </trans-unit>
        <trans-unit id="255f788a8373ceb0a89289a41ca323624e5b7999" translate="yes" xml:space="preserve">
          <source>This function will panic if &lt;code&gt;k&lt;/code&gt; is greater than the length of the slice. Note that &lt;code&gt;k == self.len()&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; panic and is a no-op rotation.</source>
          <target state="translated">如果 &lt;code&gt;k&lt;/code&gt; 大于切片的长度，则此函数将出现紧急情况。需要注意的是 &lt;code&gt;k == self.len()&lt;/code&gt; 并&lt;em&gt;没有&lt;/em&gt;恐慌，是一种无操作旋转。</target>
        </trans-unit>
        <trans-unit id="95270b721e4d05b72ba071aee1067eda4042613d" translate="yes" xml:space="preserve">
          <source>This function will panic if &lt;code&gt;mid&lt;/code&gt; is greater than the length of the slice. Note that &lt;code&gt;mid == self.len()&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; panic and is a no-op rotation.</source>
          <target state="translated">如果 &lt;code&gt;mid&lt;/code&gt; 大于切片的长度，则此功能将出现紧急情况。需要注意的是 &lt;code&gt;mid == self.len()&lt;/code&gt; 并&lt;em&gt;没有&lt;/em&gt;恐慌，是一种无操作旋转。</target>
        </trans-unit>
        <trans-unit id="e717b0d6a1e36e01967338ee832d65ba4d48839e" translate="yes" xml:space="preserve">
          <source>This function will panic if &lt;code&gt;rhs&lt;/code&gt; is 0 or the division results in overflow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46e96193daf65415936b126b06264ed8418f5b5e" translate="yes" xml:space="preserve">
          <source>This function will panic if &lt;code&gt;rhs&lt;/code&gt; is 0.</source>
          <target state="translated">如果 &lt;code&gt;rhs&lt;/code&gt; 为0，则此功能会出现紧急情况。</target>
        </trans-unit>
        <trans-unit id="d72d270dceb6908b40e770de6a7cca4ee6d954fb" translate="yes" xml:space="preserve">
          <source>This function will panic if either range exceeds the end of the slice, or if the end of &lt;code&gt;src&lt;/code&gt; is before the start.</source>
          <target state="translated">如果范围超出切片的末尾，或者 &lt;code&gt;src&lt;/code&gt; 的末尾早于开始，则此函数将出现紧急情况。</target>
        </trans-unit>
        <trans-unit id="ffa5cde970751a9af3f3c95b9bc636f122bbdd4f" translate="yes" xml:space="preserve">
          <source>This function will panic if the capacity would overflow.</source>
          <target state="translated">如果容量溢出,该功能将恐慌。</target>
        </trans-unit>
        <trans-unit id="157be01a917f2466c041055463b9f02120a94753" translate="yes" xml:space="preserve">
          <source>This function will panic if the position of the inner reader is smaller than the amount of buffered data. That can happen if the inner reader has an incorrect implementation of &lt;a href=&quot;trait.seek#method.stream_position&quot;&gt;&lt;code&gt;Seek::stream_position&lt;/code&gt;&lt;/a&gt;, or if the position has gone out of sync due to calling &lt;a href=&quot;trait.seek#tymethod.seek&quot;&gt;&lt;code&gt;Seek::seek&lt;/code&gt;&lt;/a&gt; directly on the underlying reader.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b80c161450352b3f264fa270e71aafac41ce5a3b" translate="yes" xml:space="preserve">
          <source>This function will panic if the two slices have different lengths.</source>
          <target state="translated">如果两个片子的长度不一样,这个功能就会恐慌。</target>
        </trans-unit>
        <trans-unit id="f9a04d3eaea11b5bf70c2b1e292fe13090c46ff0" translate="yes" xml:space="preserve">
          <source>This function will read bytes from the underlying stream until the delimiter or EOF is found. Once found, all bytes up to, and including, the delimiter (if found) will be appended to &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">此函数将从底层流读取字节，直到找到定界符或EOF。找到后，直到定界符（包括定界符）的所有字节（如果找到）都将附加到 &lt;code&gt;buf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1dad503d6df9a455b05b17e9982a9b93c55eab53" translate="yes" xml:space="preserve">
          <source>This function will read bytes from the underlying stream until the newline delimiter (the 0xA byte) or EOF is found. Once found, all bytes up to, and including, the delimiter (if found) will be appended to &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">该函数将从底层流中读取字节，直到找到换行符（0xA字节）或EOF。找到后，直到定界符（包括定界符）的所有字节（如果找到）都将附加到 &lt;code&gt;buf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4641b6a37e2fa63178c9c82e80780dcf197015e4" translate="yes" xml:space="preserve">
          <source>This function will read bytes from the underlying stream until the newline delimiter (the &lt;code&gt;0xA&lt;/code&gt; byte) or EOF is found. Once found, all bytes up to, and including, the delimiter (if found) will be appended to &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5509bdb3a49d4f3afca9be3c4e49fc0d8f43d023" translate="yes" xml:space="preserve">
          <source>This function will resume execution of the generator or start execution if it hasn't already. This call will return back into the generator's last suspension point, resuming execution from the latest &lt;code&gt;yield&lt;/code&gt;. The generator will continue executing until it either yields or returns, at which point this function will return.</source>
          <target state="translated">此函数将恢复生成器的执行，如果尚未执行，则开始执行。该调用将返回到生成器的最后一个挂起点，从最新 &lt;code&gt;yield&lt;/code&gt; 继续执行。生成器将继续执行，直到它屈服或返回为止，然后该函数将返回。</target>
        </trans-unit>
        <trans-unit id="379fb0237a1103a33f0bdfcecfb22299eb043557" translate="yes" xml:space="preserve">
          <source>This function will return &lt;code&gt;Ok&lt;/code&gt; with the closure's result if the closure does not panic, and will return &lt;code&gt;Err(cause)&lt;/code&gt; if the closure panics. The &lt;code&gt;cause&lt;/code&gt; returned is the object with which panic was originally invoked.</source>
          <target state="translated">如果关闭不紧急，此函数将返回 &lt;code&gt;Ok&lt;/code&gt; 并返回关闭的结果；如果关闭紧急，此函数将返回 &lt;code&gt;Err(cause)&lt;/code&gt; 。返回的 &lt;code&gt;cause&lt;/code&gt; 是最初调用panic的对象。</target>
        </trans-unit>
        <trans-unit id="d89140f93781fe909c3c1a3e0e29b63c7e369dd7" translate="yes" xml:space="preserve">
          <source>This function will return an I/O error if the underlying reader was read, but returned an error.</source>
          <target state="translated">如果底层读卡器被读取,但返回错误,该函数将返回一个I/O错误。</target>
        </trans-unit>
        <trans-unit id="53872c0f37fe2cee76394788d7b1f123503054e5" translate="yes" xml:space="preserve">
          <source>This function will return an error if &lt;code&gt;path&lt;/code&gt; does not already exist. Other errors may also be returned according to &lt;a href=&quot;struct.openoptions#method.open&quot;&gt;&lt;code&gt;OpenOptions::open&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;path&lt;/code&gt; 尚不存在，则此函数将返回错误。其他错误也可能根据&lt;a href=&quot;struct.openoptions#method.open&quot;&gt; &lt;code&gt;OpenOptions::open&lt;/code&gt; &lt;/a&gt;返回。</target>
        </trans-unit>
        <trans-unit id="89c6971a5e8debeb3922f37bf3a67af3e6b7d708" translate="yes" xml:space="preserve">
          <source>This function will return an error if the RwLock is poisoned. An RwLock is poisoned whenever a writer panics while holding an exclusive lock. An error will be returned when the lock is acquired.</source>
          <target state="translated">如果RwLock中毒,这个函数将返回一个错误。每当写入者在持有独占锁时感到恐慌时,RwLock就会中毒。当锁被获取时,将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="dd9f12f8f4834cac09e7d8702d9c30c5d7a3ff26" translate="yes" xml:space="preserve">
          <source>This function will return an error if the RwLock is poisoned. An RwLock is poisoned whenever a writer panics while holding an exclusive lock. An error will only be returned if the lock would have otherwise been acquired.</source>
          <target state="translated">如果RwLock中毒,这个函数将返回一个错误。每当写入者在持有独占锁时感到恐慌时,RwLock就会中毒。只有当锁在其他情况下被获取时,才会返回错误。</target>
        </trans-unit>
        <trans-unit id="853f4abcb0adc2f4d392d459e3d4bcbfc1ffde02" translate="yes" xml:space="preserve">
          <source>This function will return an error if the RwLock is poisoned. An RwLock is poisoned whenever a writer panics while holding an exclusive lock. The failure will occur immediately after the lock has been acquired.</source>
          <target state="translated">如果RwLock中毒,这个函数将返回一个错误。每当写入者在持有独占锁时惊慌失措时,RwLock就会中毒。失败将在锁被获取后立即发生。</target>
        </trans-unit>
        <trans-unit id="08332f9ce278762f6fd52afefe704489d0688f37" translate="yes" xml:space="preserve">
          <source>This function will return an error if the file is not opened for writing.</source>
          <target state="translated">如果文件没有被打开写入,该函数将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="cdbfb4a0b16adba4591761f7aedf5e4a9ea34196" translate="yes" xml:space="preserve">
          <source>This function will return an error if the file is not opened for writing. Also, std::io::ErrorKind::InvalidInput will be returned if the desired length would cause an overflow due to the implementation specifics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6cdf441223c3eb9f4334399883d69c73ecd1bf4" translate="yes" xml:space="preserve">
          <source>This function will return an error if the mutex being waited on is poisoned when this thread re-acquires the lock. For more information, see information about &lt;a href=&quot;struct.mutex#poisoning&quot;&gt;poisoning&lt;/a&gt; on the &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="translated">如果正在等待等待的互斥锁在此线程重新获取锁时中毒，则此函数将返回错误。欲了解更多信息，请参阅有关信息&lt;a href=&quot;struct.mutex#poisoning&quot;&gt;毒害&lt;/a&gt;的&lt;a href=&quot;struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; &lt;/a&gt;类型。</target>
        </trans-unit>
        <trans-unit id="27a931587ff628dc51ea9585254e81a44150f056" translate="yes" xml:space="preserve">
          <source>This function will return an error if the supplied bytes contain an internal 0 byte. The &lt;a href=&quot;struct.nulerror&quot;&gt;&lt;code&gt;NulError&lt;/code&gt;&lt;/a&gt; returned will contain the bytes as well as the position of the nul byte.</source>
          <target state="translated">如果提供的字节包含内部0字节，则此函数将返回错误。返回的&lt;a href=&quot;struct.nulerror&quot;&gt; &lt;code&gt;NulError&lt;/code&gt; &lt;/a&gt;将包含字节以及nul字节的位置。</target>
        </trans-unit>
        <trans-unit id="dbf84289e9d9e4926b496bd897b3083ec6312b71" translate="yes" xml:space="preserve">
          <source>This function will return an error if the user lacks permission change attributes on the underlying file. It may also return an error in other os-specific unspecified cases.</source>
          <target state="translated">如果用户在底层文件上缺乏权限更改属性,这个函数将返回一个错误。在其他os特有的未指定的情况下,它也可能返回一个错误。</target>
        </trans-unit>
        <trans-unit id="5d42b76127c0c24013b14924e889090949109ff6" translate="yes" xml:space="preserve">
          <source>This function will return an error immediately if any call to &lt;a href=&quot;trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; returns an error. All instances of &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; are handled by this function and the underlying operation is retried.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6020fefae74dafb3cbf7677aedde54d28946007d" translate="yes" xml:space="preserve">
          <source>This function will return an error immediately if any call to &lt;code&gt;read&lt;/code&gt; or &lt;code&gt;write&lt;/code&gt; returns an error. All instances of &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; are handled by this function and the underlying operation is retried.</source>
          <target state="translated">如果任何 &lt;code&gt;read&lt;/code&gt; 或 &lt;code&gt;write&lt;/code&gt; 调用返回错误，则此函数将立即返回错误。此函数处理 &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; 所有实例，并重试基础操作。</target>
        </trans-unit>
        <trans-unit id="789ed5daa8073ac179354d082eb69d8ff28cdee6" translate="yes" xml:space="preserve">
          <source>This function will return an error in the following situations, but is not limited to just these cases:</source>
          <target state="translated">该函数将在以下情况下返回错误,但不限于这些情况。</target>
        </trans-unit>
        <trans-unit id="6c2926688126ed0bb4700cfc41330adcd34075d1" translate="yes" xml:space="preserve">
          <source>This function will return an error under a number of different circumstances. Some of these error conditions are listed here, together with their &lt;a href=&quot;../io/enum.errorkind&quot;&gt;&lt;code&gt;ErrorKind&lt;/code&gt;&lt;/a&gt;. The mapping to &lt;a href=&quot;../io/enum.errorkind&quot;&gt;&lt;code&gt;ErrorKind&lt;/code&gt;&lt;/a&gt;s is not part of the compatibility contract of the function, especially the &lt;code&gt;Other&lt;/code&gt; kind might change to more specific kinds in the future.</source>
          <target state="translated">在许多不同的情况下，此函数将返回错误。这里列出了其中一些错误条件，以及它们的&lt;a href=&quot;../io/enum.errorkind&quot;&gt; &lt;code&gt;ErrorKind&lt;/code&gt; &lt;/a&gt;。到&lt;a href=&quot;../io/enum.errorkind&quot;&gt; &lt;code&gt;ErrorKind&lt;/code&gt; &lt;/a&gt;的映射不是该功能的兼容性合同的一部分，尤其是将来 &lt;code&gt;Other&lt;/code&gt; 类型可能会更改为更特定的类型。</target>
        </trans-unit>
        <trans-unit id="dbf346cba719ecc4a64a28fdc51747223ea1ead1" translate="yes" xml:space="preserve">
          <source>This function will return an error under a number of different circumstances. Some of these error conditions are listed here, together with their &lt;a href=&quot;../io/enum.errorkind&quot;&gt;&lt;code&gt;io::ErrorKind&lt;/code&gt;&lt;/a&gt;. The mapping to &lt;a href=&quot;../io/enum.errorkind&quot;&gt;&lt;code&gt;io::ErrorKind&lt;/code&gt;&lt;/a&gt;s is not part of the compatibility contract of the function, especially the &lt;a href=&quot;../io/enum.errorkind#variant.Other&quot;&gt;&lt;code&gt;Other&lt;/code&gt;&lt;/a&gt; kind might change to more specific kinds in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6a8bd83b584fa0f13cb1bcd08f12c3e0060dff9" translate="yes" xml:space="preserve">
          <source>This function will return an instance of &lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; on error.</source>
          <target state="translated">此函数将在错误时返回一个&lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt;实例。</target>
        </trans-unit>
        <trans-unit id="6fae4edeb2bc2b830762c223977c0f9e31e7f71d" translate="yes" xml:space="preserve">
          <source>This function will return any I/O error reported while formatting.</source>
          <target state="translated">该函数将返回格式化时报告的任何I/O错误。</target>
        </trans-unit>
        <trans-unit id="82d9dcac7df30707ace2de701aba5471ae21281c" translate="yes" xml:space="preserve">
          <source>This function will return the first error of non-&lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind that &lt;a href=&quot;#tymethod.write_at&quot;&gt;&lt;code&gt;write_at&lt;/code&gt;&lt;/a&gt; returns.</source>
          <target state="translated">该函数将返回非的第一个错误&lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;那种&lt;a href=&quot;#tymethod.write_at&quot;&gt; &lt;code&gt;write_at&lt;/code&gt; &lt;/a&gt;回报。</target>
        </trans-unit>
        <trans-unit id="cbfac2234e26fd5ad38b1fb7d157edb650781848" translate="yes" xml:space="preserve">
          <source>This function will return the first error of non-&lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind that &lt;a href=&quot;trait.fileext#tymethod.write_at&quot;&gt;&lt;code&gt;write_at&lt;/code&gt;&lt;/a&gt; returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e505864f4a28d60809a69e771d2b212f82c7410c" translate="yes" xml:space="preserve">
          <source>This function will return the first error of non-&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind that &lt;a href=&quot;#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; returns.</source>
          <target state="translated">此函数将返回&lt;a href=&quot;#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;返回的非&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;类型的第一个错误。</target>
        </trans-unit>
        <trans-unit id="e4e34f750f27d3b0d205fe34d5653142bb6c6abe" translate="yes" xml:space="preserve">
          <source>This function will return the first error of non-&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind that &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="749cf49b6adfac5a93f23dcbbade901579686611" translate="yes" xml:space="preserve">
          <source>This function will still &lt;code&gt;panic!()&lt;/code&gt; if the key is uninitialized and the key's initializer panics.</source>
          <target state="translated">如果该键未初始化并且该键的初始化程序出现紧急情况，则此函数仍然会 &lt;code&gt;panic!()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa2dcaf81660e38d976b3c073799f64e35c409b8" translate="yes" xml:space="preserve">
          <source>This function will traverse symbolic links to query information about the destination file.</source>
          <target state="translated">该函数将遍历符号链接,查询目标文件的信息。</target>
        </trans-unit>
        <trans-unit id="7a60f9a71c97e3c48d6ddbb61757095cfb7454e6" translate="yes" xml:space="preserve">
          <source>This function will traverse symbolic links to query information about the destination file. In case of broken symbolic links this will return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">此函数将遍历符号链接以查询有关目标文件的信息。如果符号链接断开，则将返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2e9a4f19c05867342225932a802795ba8df8be2" translate="yes" xml:space="preserve">
          <source>This function will unsafely assume the pointer &lt;code&gt;src&lt;/code&gt; is valid for &lt;a href=&quot;fn.size_of&quot;&gt;&lt;code&gt;size_of::&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt; bytes by transmuting &lt;code&gt;&amp;amp;T&lt;/code&gt; to &lt;code&gt;&amp;amp;U&lt;/code&gt; and then reading the &lt;code&gt;&amp;amp;U&lt;/code&gt; (except that this is done in a way that is correct even when &lt;code&gt;&amp;amp;U&lt;/code&gt; makes stricter alignment requirements than &lt;code&gt;&amp;amp;T&lt;/code&gt;). It will also unsafely create a copy of the contained value instead of moving out of &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2144ac018e241484dd88280c401709723264165b" translate="yes" xml:space="preserve">
          <source>This function will unsafely assume the pointer &lt;code&gt;src&lt;/code&gt; is valid for &lt;a href=&quot;fn.size_of&quot;&gt;&lt;code&gt;size_of::&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt; bytes by transmuting &lt;code&gt;&amp;amp;T&lt;/code&gt; to &lt;code&gt;&amp;amp;U&lt;/code&gt; and then reading the &lt;code&gt;&amp;amp;U&lt;/code&gt;. It will also unsafely create a copy of the contained value instead of moving out of &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">此功能将不安全假设指针 &lt;code&gt;src&lt;/code&gt; 是有效的&lt;a href=&quot;fn.size_of&quot;&gt; &lt;code&gt;size_of::&amp;lt;U&amp;gt;&lt;/code&gt; &lt;/a&gt;通过嬗变字节 &lt;code&gt;&amp;amp;T&lt;/code&gt; 到 &lt;code&gt;&amp;amp;U&lt;/code&gt; ，然后读取 &lt;code&gt;&amp;amp;U&lt;/code&gt; 。它还将不安全地创建包含值的副本，而不是移出 &lt;code&gt;src&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="be98532def31c781d65ddc0b9dc20df02eb564e6" translate="yes" xml:space="preserve">
          <source>This function will wrap the provided &lt;code&gt;ptr&lt;/code&gt; with a &lt;code&gt;CStr&lt;/code&gt; wrapper, which allows inspection and interoperation of non-owned C strings. The total size of the raw C string must be smaller than &lt;code&gt;isize::MAX&lt;/code&gt;&lt;strong&gt;bytes&lt;/strong&gt; in memory due to calling the &lt;code&gt;slice::from_raw_parts&lt;/code&gt; function. This method is unsafe for a number of reasons:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5bb3f5f774e85331b120930c24070df4dbb7ef1" translate="yes" xml:space="preserve">
          <source>This function will wrap the provided &lt;code&gt;ptr&lt;/code&gt; with a &lt;code&gt;CStr&lt;/code&gt; wrapper, which allows inspection and interoperation of non-owned C strings. This method is unsafe for a number of reasons:</source>
          <target state="translated">此函数将使用 &lt;code&gt;CStr&lt;/code&gt; 包装器包装提供的 &lt;code&gt;ptr&lt;/code&gt; ，该包装器允许检查和互斥非拥有的C字符串。由于多种原因，此方法不安全：</target>
        </trans-unit>
        <trans-unit id="eb6de22f90abba9d8b2e22f07508357043cd45b1" translate="yes" xml:space="preserve">
          <source>This function will yield errors whenever &lt;a href=&quot;#method.read_until&quot;&gt;&lt;code&gt;read_until&lt;/code&gt;&lt;/a&gt; would have also yielded an error.</source>
          <target state="translated">只要&lt;a href=&quot;#method.read_until&quot;&gt; &lt;code&gt;read_until&lt;/code&gt; &lt;/a&gt;也产生错误，此函数就会产生错误。</target>
        </trans-unit>
        <trans-unit id="0ec10f22723b4146e4ed97d9a1ccb195f6666569" translate="yes" xml:space="preserve">
          <source>This function will yield errors whenever &lt;a href=&quot;trait.bufread#method.read_until&quot;&gt;&lt;code&gt;read_until&lt;/code&gt;&lt;/a&gt; would have also yielded an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="761c3823fedfe961f64b60f5bbf8dadb1c015978" translate="yes" xml:space="preserve">
          <source>This function works on a best-effort basis, and may return false even when the &lt;code&gt;Waker&lt;/code&gt;s would awaken the same task. However, if this function returns &lt;code&gt;true&lt;/code&gt;, it is guaranteed that the &lt;code&gt;Waker&lt;/code&gt;s will awaken the same task.</source>
          <target state="translated">此函数尽力而为，即使 &lt;code&gt;Waker&lt;/code&gt; 唤醒了同一任务，它也可能返回false 。但是，如果此函数返回 &lt;code&gt;true&lt;/code&gt; ，则可以确保 &lt;code&gt;Waker&lt;/code&gt; 可以唤醒同一任务。</target>
        </trans-unit>
        <trans-unit id="0fef1eb994767850b63d5d3191f1364d1d996711" translate="yes" xml:space="preserve">
          <source>This function works similar to &lt;a href=&quot;../iter/trait.iterator#method.filter&quot;&gt;&lt;code&gt;Iterator::filter()&lt;/code&gt;&lt;/a&gt;. You can imagine the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; being an iterator over one or zero elements. &lt;code&gt;filter()&lt;/code&gt; lets you decide which elements to keep.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ae0840523d6333733f66bb75a006add83e1ec36" translate="yes" xml:space="preserve">
          <source>This function works similar to &lt;code&gt;Iterator::filter()&lt;/code&gt;. You can imagine the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; being an iterator over one or zero elements. &lt;code&gt;filter()&lt;/code&gt; lets you decide which elements to keep.</source>
          <target state="translated">该函数的工作原理类似于 &lt;code&gt;Iterator::filter()&lt;/code&gt; 。您可以想象 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 是一个或零个元素的迭代器。 &lt;code&gt;filter()&lt;/code&gt; 使您可以决定保留哪些元素。</target>
        </trans-unit>
        <trans-unit id="113d936138ddc7ae4f63a1a50d8105ac5a7add0d" translate="yes" xml:space="preserve">
          <source>This function&amp;rsquo;s signature is less cluttered: the function name, parameter list, and return type are close together, similar to a function without lots of trait bounds.</source>
          <target state="translated">该函数的签名不太混乱：函数名称，参数列表和返回类型紧密靠近，类似于没有很多特征界限的函数。</target>
        </trans-unit>
        <trans-unit id="59db1f1ce2d556d00a44653625d9c4310aa82a71" translate="yes" xml:space="preserve">
          <source>This function, &lt;code&gt;first_word&lt;/code&gt;, has a &lt;code&gt;&amp;amp;String&lt;/code&gt; as a parameter. We don&amp;rsquo;t want ownership, so this is fine. But what should we return? We don&amp;rsquo;t really have a way to talk about &lt;em&gt;part&lt;/em&gt; of a string. However, we could return the index of the end of the word. Let&amp;rsquo;s try that, as shown in Listing 4-7.</source>
          <target state="translated">此函数 &lt;code&gt;first_word&lt;/code&gt; 具有 &lt;code&gt;&amp;amp;String&lt;/code&gt; 作为参数。我们不需要所有权，所以很好。但是，我们应该返回什么呢？我们真的没有办法谈论字符串的&lt;em&gt;一部分&lt;/em&gt;。但是，我们可以返回单词结尾的索引。让我们尝试一下，如清单4-7所示。</target>
        </trans-unit>
        <trans-unit id="c0b65dd63b8d87baa6cb2781b4c83fe9b710f211" translate="yes" xml:space="preserve">
          <source>This function, unlike &lt;code&gt;spawn&lt;/code&gt;, will &lt;strong&gt;not&lt;/strong&gt;&lt;code&gt;fork&lt;/code&gt; the process to create a new child. Like spawn, however, the default behavior for the stdio descriptors will be to inherited from the current process.</source>
          <target state="translated">与 &lt;code&gt;spawn&lt;/code&gt; 不同，此功能&lt;strong&gt;不会&lt;/strong&gt; &lt;code&gt;fork&lt;/code&gt; 创建新子进程。但是，像spawn一样，stdio描述符的默认行为将从当前进程继承。</target>
        </trans-unit>
        <trans-unit id="a7e07fc3dba284598652a13174e554562e5525f8" translate="yes" xml:space="preserve">
          <source>This handle encapsulates a &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; instance, which defines the executor-specific wakeup behavior.</source>
          <target state="translated">该句柄封装了&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt;实例，该实例定义了特定于执行者的唤醒行为。</target>
        </trans-unit>
        <trans-unit id="d605d26d55dc2758f0b6de9e17a49a349f074534" translate="yes" xml:space="preserve">
          <source>This handle implements both the &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.bufread&quot;&gt;&lt;code&gt;BufRead&lt;/code&gt;&lt;/a&gt; traits, and is constructed via the &lt;a href=&quot;struct.stdin#method.lock&quot;&gt;&lt;code&gt;Stdin::lock&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">该句柄同时实现&lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;trait.bufread&quot;&gt; &lt;code&gt;BufRead&lt;/code&gt; &lt;/a&gt;特性，并通过&lt;a href=&quot;struct.stdin#method.lock&quot;&gt; &lt;code&gt;Stdin::lock&lt;/code&gt; &lt;/a&gt;方法构造。</target>
        </trans-unit>
        <trans-unit id="f7258bae2e88ec63ae3dd338b65d64451a9b331b" translate="yes" xml:space="preserve">
          <source>This handle implements the &lt;a href=&quot;trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt; trait, and is constructed via the &lt;a href=&quot;struct.stdout#method.lock&quot;&gt;&lt;code&gt;Stdout::lock&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">该句柄实现&lt;a href=&quot;trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt;特性，并通过&lt;a href=&quot;struct.stdout#method.lock&quot;&gt; &lt;code&gt;Stdout::lock&lt;/code&gt; &lt;/a&gt;方法构造。</target>
        </trans-unit>
        <trans-unit id="d288bcdc54960c2a1210bed705519ebb1c8b509b" translate="yes" xml:space="preserve">
          <source>This handle implements the &lt;code&gt;Read&lt;/code&gt; trait, but beware that concurrent reads of &lt;code&gt;Stdin&lt;/code&gt; must be executed with care.</source>
          <target state="translated">该句柄实现了 &lt;code&gt;Read&lt;/code&gt; 特质，但请注意必须同时执行对 &lt;code&gt;Stdin&lt;/code&gt; 的并发读取。</target>
        </trans-unit>
        <trans-unit id="01441d3c1d26b75fb46c2c721477af0652ee7979" translate="yes" xml:space="preserve">
          <source>This handle implements the &lt;code&gt;Write&lt;/code&gt; trait and is constructed via the &lt;a href=&quot;struct.stderr#method.lock&quot;&gt;&lt;code&gt;Stderr::lock&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">该句柄实现 &lt;code&gt;Write&lt;/code&gt; 特性，并通过&lt;a href=&quot;struct.stderr#method.lock&quot;&gt; &lt;code&gt;Stderr::lock&lt;/code&gt; &lt;/a&gt;方法构造。</target>
        </trans-unit>
        <trans-unit id="2708f4eb8582ea4d70309feff62a1d2748e13184" translate="yes" xml:space="preserve">
          <source>This handle is not buffered.</source>
          <target state="translated">这个句柄是没有缓冲的。</target>
        </trans-unit>
        <trans-unit id="6c48d5f61a1b6b181a01656b1e94697dc7bb9249" translate="yes" xml:space="preserve">
          <source>This happens because the pointer returned by &lt;code&gt;as_ptr&lt;/code&gt; does not carry any lifetime information and the &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt; is deallocated immediately after the &lt;code&gt;CString::new(&quot;Hello&quot;).expect(&quot;CString::new failed&quot;).as_ptr()&lt;/code&gt; expression is evaluated. To fix the problem, bind the &lt;code&gt;CString&lt;/code&gt; to a local variable:</source>
          <target state="translated">这是因为通过返回的指针 &lt;code&gt;as_ptr&lt;/code&gt; 不携带任何寿命信息和&lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; 的&lt;/a&gt;是后立即释放 &lt;code&gt;CString::new(&quot;Hello&quot;).expect(&quot;CString::new failed&quot;).as_ptr()&lt;/code&gt; 表达式。要解决此问题，请将 &lt;code&gt;CString&lt;/code&gt; 绑定到本地变量：</target>
        </trans-unit>
        <trans-unit id="6047b82331195849fba72da79674452a117df64d" translate="yes" xml:space="preserve">
          <source>This happens when a trait has a method like the following:</source>
          <target state="translated">当一个特质有一个类似下面的方法时,就会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="863bad715d4f6d1bd75efa3884a2cc5b250ca381" translate="yes" xml:space="preserve">
          <source>This has the same behavior as the &lt;a href=&quot;../string/struct.string#method.push_str&quot;&gt;&lt;code&gt;push_str&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">这具有与&lt;a href=&quot;../string/struct.string#method.push_str&quot;&gt; &lt;code&gt;push_str&lt;/code&gt; &lt;/a&gt;方法相同的行为。</target>
        </trans-unit>
        <trans-unit id="6a3c452ab4ee63f33d895b0f991faaa23887feb8" translate="yes" xml:space="preserve">
          <source>This has the same behavior as the &lt;a href=&quot;struct.string#method.push_str&quot;&gt;&lt;code&gt;push_str&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">这具有与&lt;a href=&quot;struct.string#method.push_str&quot;&gt; &lt;code&gt;push_str&lt;/code&gt; &lt;/a&gt;方法相同的行为。</target>
        </trans-unit>
        <trans-unit id="b58a8c2add590746e5048b4f132cbbc19047500f" translate="yes" xml:space="preserve">
          <source>This has the same effect as &lt;a href=&quot;union.maybeuninit#method.zeroed&quot;&gt;&lt;code&gt;MaybeUninit::zeroed().assume_init()&lt;/code&gt;&lt;/a&gt;. It is useful for FFI sometimes, but should generally be avoided.</source>
          <target state="translated">这与&lt;a href=&quot;union.maybeuninit#method.zeroed&quot;&gt; &lt;code&gt;MaybeUninit::zeroed().assume_init()&lt;/code&gt; &lt;/a&gt;。assume_init（）具有相同的效果。有时对FFI很有用，但通常应避免使用。</target>
        </trans-unit>
        <trans-unit id="c7eb4340faf9e85d2da20b4776ce2bebbe29c12a" translate="yes" xml:space="preserve">
          <source>This has the same lifetime as the original slice, and so the iterator can continue to be used while this exists.</source>
          <target state="translated">这和原来的分片有相同的寿命,所以在这个存在的时候,迭代器可以继续使用。</target>
        </trans-unit>
        <trans-unit id="65d35375dd8acb85bc9eba434584e8313fb0a245" translate="yes" xml:space="preserve">
          <source>This hasher is not guaranteed to be the same as all other &lt;code&gt;DefaultHasher&lt;/code&gt; instances, but is the same as all other &lt;code&gt;DefaultHasher&lt;/code&gt; instances created through &lt;code&gt;new&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">不保证此哈希器与所有其他 &lt;code&gt;DefaultHasher&lt;/code&gt; 实例相同，但与通过 &lt;code&gt;new&lt;/code&gt; 或 &lt;code&gt;default&lt;/code&gt; 创建的所有其他 &lt;code&gt;DefaultHasher&lt;/code&gt; 实例相同。</target>
        </trans-unit>
        <trans-unit id="90feee4915436dfe2be982f4c15a9da7834c5004" translate="yes" xml:space="preserve">
          <source>This implementation is specialized for slice iterators, where it uses &lt;a href=&quot;../primitive.slice#method.copy_from_slice&quot;&gt;&lt;code&gt;copy_from_slice&lt;/code&gt;&lt;/a&gt; to append the entire slice at once.</source>
          <target state="translated">此实现专用于切片迭代器，它使用&lt;a href=&quot;../primitive.slice#method.copy_from_slice&quot;&gt; &lt;code&gt;copy_from_slice&lt;/code&gt; &lt;/a&gt;一次附加整个切片。</target>
        </trans-unit>
        <trans-unit id="0b6b99c1c8632506c647afb83336adc1ee13b73f" translate="yes" xml:space="preserve">
          <source>This information corresponds to the &lt;code&gt;sin6_flowinfo&lt;/code&gt; field in C's &lt;code&gt;netinet/in.h&lt;/code&gt;, as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553, Section 3.3&lt;/a&gt;. It combines information about the flow label and the traffic class as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc2460&quot;&gt;IETF RFC 2460&lt;/a&gt;, respectively &lt;a href=&quot;https://tools.ietf.org/html/rfc2460#section-6&quot;&gt;Section 6&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc2460#section-7&quot;&gt;Section 7&lt;/a&gt;.</source>
          <target state="translated">此信息对应于&lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553第3.3节中&lt;/a&gt;指定的C的 &lt;code&gt;netinet/in.h&lt;/code&gt; 中的 &lt;code&gt;sin6_flowinfo&lt;/code&gt; 字段。它根据&lt;a href=&quot;https://tools.ietf.org/html/rfc2460&quot;&gt;IETF RFC 2460的&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2460#section-6&quot;&gt;第6 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2460#section-7&quot;&gt;节&lt;/a&gt;和第7节分别结合了有关流标签和流量类的信息。</target>
        </trans-unit>
        <trans-unit id="3af31b70c11ef4a3b608a04beaf7ba9284e068c3" translate="yes" xml:space="preserve">
          <source>This information corresponds to the &lt;code&gt;sin6_scope_id&lt;/code&gt; field in C's &lt;code&gt;netinet/in.h&lt;/code&gt;, as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553, Section 3.3&lt;/a&gt;.</source>
          <target state="translated">此信息对应于&lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553第3.3节中&lt;/a&gt;指定的C的 &lt;code&gt;netinet/in.h&lt;/code&gt; 中的 &lt;code&gt;sin6_scope_id&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="ec67651ac375d4791b71fe8abc3629f814f16ccf" translate="yes" xml:space="preserve">
          <source>This information is a hint and implementations are not required to preserve it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63ed31757d724807cc9238c95c5432cd39c9735a" translate="yes" xml:space="preserve">
          <source>This instance may reach &lt;code&gt;EOF&lt;/code&gt; after reading fewer bytes than indicated by this method if the underlying &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; instance reaches EOF.</source>
          <target state="translated">这种情况下可能达到 &lt;code&gt;EOF&lt;/code&gt; 读取比通过该方法表明，如果基础更少的字节后&lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt;实例达到EOF。</target>
        </trans-unit>
        <trans-unit id="3e890a8fb1ba0d0cd9928016f0c75ede3fcfd9a0" translate="yes" xml:space="preserve">
          <source>This intrinsic does not have a stable counterpart.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4ee533fa428c42a5629056a56b7692fc9445d45" translate="yes" xml:space="preserve">
          <source>This intrinsic should not be used outside of the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fa64cf4a4634521305dce783239fdfdeec13027" translate="yes" xml:space="preserve">
          <source>This is a &quot;helper marker trait&quot; used to provide impl blocks for the &lt;a href=&quot;trait.unwindsafe&quot;&gt;&lt;code&gt;UnwindSafe&lt;/code&gt;&lt;/a&gt; trait, for more information see that documentation.</source>
          <target state="translated">这是一个&amp;ldquo;帮助标记特征&amp;rdquo;，用于为&lt;a href=&quot;trait.unwindsafe&quot;&gt; &lt;code&gt;UnwindSafe&lt;/code&gt; &lt;/a&gt;特征提供impl块，有关更多信息，请参阅该文档。</target>
        </trans-unit>
        <trans-unit id="dca2a0780f1a583478627dae521a3cd19fa18332" translate="yes" xml:space="preserve">
          <source>This is a convenience function for using &lt;a href=&quot;struct.file#method.create&quot;&gt;&lt;code&gt;File::create&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../io/trait.write#method.write_all&quot;&gt;&lt;code&gt;write_all&lt;/code&gt;&lt;/a&gt; with fewer imports.</source>
          <target state="translated">这是使用&lt;a href=&quot;struct.file#method.create&quot;&gt; &lt;code&gt;File::create&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../io/trait.write#method.write_all&quot;&gt; &lt;code&gt;write_all&lt;/code&gt; &lt;/a&gt;且导入次数较少的便捷功能。</target>
        </trans-unit>
        <trans-unit id="8a3e47d631d6356541264338a28634452afdd7c3" translate="yes" xml:space="preserve">
          <source>This is a convenience function for using &lt;a href=&quot;struct.file#method.open&quot;&gt;&lt;code&gt;File::open&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../io/trait.read#method.read_to_end&quot;&gt;&lt;code&gt;read_to_end&lt;/code&gt;&lt;/a&gt; with fewer imports and without an intermediate variable. It pre-allocates a buffer based on the file size when available, so it is generally faster than reading into a vector created with &lt;a href=&quot;../vec/struct.vec#method.new&quot;&gt;&lt;code&gt;Vec::new()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="187131cff0eb9e697908b49a26f702ec337c3799" translate="yes" xml:space="preserve">
          <source>This is a convenience function for using &lt;a href=&quot;struct.file#method.open&quot;&gt;&lt;code&gt;File::open&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../io/trait.read#method.read_to_end&quot;&gt;&lt;code&gt;read_to_end&lt;/code&gt;&lt;/a&gt; with fewer imports and without an intermediate variable. It pre-allocates a buffer based on the file size when available, so it is generally faster than reading into a vector created with &lt;code&gt;Vec::new()&lt;/code&gt;.</source>
          <target state="translated">这是使用&lt;a href=&quot;struct.file#method.open&quot;&gt; &lt;code&gt;File::open&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../io/trait.read#method.read_to_end&quot;&gt; &lt;code&gt;read_to_end&lt;/code&gt; &lt;/a&gt;且导入次数较少且没有中间变量的便捷功能。它会根据文件大小（如果有）预先分配一个缓冲区，因此通常比读入 &lt;code&gt;Vec::new()&lt;/code&gt; 创建的向量要快。</target>
        </trans-unit>
        <trans-unit id="4ad096cd1a7e9fdbf72506102cbfdd2fbcf9b981" translate="yes" xml:space="preserve">
          <source>This is a convenience function for using &lt;a href=&quot;struct.file#method.open&quot;&gt;&lt;code&gt;File::open&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../io/trait.read#method.read_to_string&quot;&gt;&lt;code&gt;read_to_string&lt;/code&gt;&lt;/a&gt; with fewer imports and without an intermediate variable. It pre-allocates a buffer based on the file size when available, so it is generally faster than reading into a string created with &lt;a href=&quot;../string/struct.string#method.new&quot;&gt;&lt;code&gt;String::new()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c7392177420bfa03e5c328d086366669dabd90c" translate="yes" xml:space="preserve">
          <source>This is a convenience function for using &lt;a href=&quot;struct.file#method.open&quot;&gt;&lt;code&gt;File::open&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../io/trait.read#method.read_to_string&quot;&gt;&lt;code&gt;read_to_string&lt;/code&gt;&lt;/a&gt; with fewer imports and without an intermediate variable. It pre-allocates a buffer based on the file size when available, so it is generally faster than reading into a string created with &lt;code&gt;String::new()&lt;/code&gt;.</source>
          <target state="translated">这是使用&lt;a href=&quot;struct.file#method.open&quot;&gt; &lt;code&gt;File::open&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../io/trait.read#method.read_to_string&quot;&gt; &lt;code&gt;read_to_string&lt;/code&gt; &lt;/a&gt;且导入次数较少且没有中间变量的便捷功能。它会根据文件大小（如果有）预先分配一个缓冲区，因此通常比读取用 &lt;code&gt;String::new()&lt;/code&gt; 创建的字符串更快。</target>
        </trans-unit>
        <trans-unit id="6368465bb72af615f875d8e839f3e68ea414aaaa" translate="yes" xml:space="preserve">
          <source>This is a convenience function that coerces errors to false. If you want to check errors, call &lt;a href=&quot;../fs/fn.metadata&quot;&gt;&lt;code&gt;fs::metadata&lt;/code&gt;&lt;/a&gt; and handle its &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;. Then call &lt;a href=&quot;../fs/struct.metadata#method.is_dir&quot;&gt;&lt;code&gt;fs::Metadata::is_dir&lt;/code&gt;&lt;/a&gt; if it was &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ec158d2dde1ce8ee75d1772394d851e65f39fd6" translate="yes" xml:space="preserve">
          <source>This is a convenience function that coerces errors to false. If you want to check errors, call &lt;a href=&quot;../fs/fn.metadata&quot;&gt;&lt;code&gt;fs::metadata&lt;/code&gt;&lt;/a&gt; and handle its &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;. Then call &lt;a href=&quot;../fs/struct.metadata#method.is_file&quot;&gt;&lt;code&gt;fs::Metadata::is_file&lt;/code&gt;&lt;/a&gt; if it was &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f680ca8918b755dd586b16c26d23dbb3dd42957" translate="yes" xml:space="preserve">
          <source>This is a convenience function that coerces errors to false. If you want to check errors, call &lt;a href=&quot;../fs/fn.metadata&quot;&gt;&lt;code&gt;fs::metadata&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dac9be08ca6ab3c0d6956dc411e028285b59848d" translate="yes" xml:space="preserve">
          <source>This is a convenience function that coerces errors to false. If you want to check errors, call &lt;a href=&quot;../fs/fn.metadata&quot;&gt;fs::metadata&lt;/a&gt; and handle its Result. Then call &lt;a href=&quot;../fs/struct.metadata#method.is_dir&quot;&gt;fs::Metadata::is_dir&lt;/a&gt; if it was Ok.</source>
          <target state="translated">这是一种便利功能，可将错误强制为false。如果要检查错误，请调用&lt;a href=&quot;../fs/fn.metadata&quot;&gt;fs :: metadata&lt;/a&gt;并处理其结果。如果还可以，则调用&lt;a href=&quot;../fs/struct.metadata#method.is_dir&quot;&gt;fs :: Metadata :: is_dir&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="78d539aab76737f8cf396eefb6d1ce6f5b6f255b" translate="yes" xml:space="preserve">
          <source>This is a convenience function that coerces errors to false. If you want to check errors, call &lt;a href=&quot;../fs/fn.metadata&quot;&gt;fs::metadata&lt;/a&gt; and handle its Result. Then call &lt;a href=&quot;../fs/struct.metadata#method.is_file&quot;&gt;fs::Metadata::is_file&lt;/a&gt; if it was Ok.</source>
          <target state="translated">这是一种便利功能，可将错误强制为false。如果要检查错误，请调用&lt;a href=&quot;../fs/fn.metadata&quot;&gt;fs :: metadata&lt;/a&gt;并处理其结果。如果还可以，则调用&lt;a href=&quot;../fs/struct.metadata#method.is_file&quot;&gt;fs :: Metadata :: is_file&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="63bfc9edacf3bb27391de3d729c554b4c3c2df6a" translate="yes" xml:space="preserve">
          <source>This is a convenience function that coerces errors to false. If you want to check errors, call &lt;a href=&quot;../fs/fn.metadata&quot;&gt;fs::metadata&lt;/a&gt;.</source>
          <target state="translated">这是一种便利功能，可将错误强制为false。如果要检查错误，请致电&lt;a href=&quot;../fs/fn.metadata&quot;&gt;fs :: metadata&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="748753921bdcefd01924d5e43ae2dad4f042e3b3" translate="yes" xml:space="preserve">
          <source>This is a cost-free conversion.</source>
          <target state="translated">这是一种无成本的转换。</target>
        </trans-unit>
        <trans-unit id="0bed32ad8a4ac210351c4fe08ac569f4ede1369a" translate="yes" xml:space="preserve">
          <source>This is a curious macro used to safely pass around an opaque object describing the format string. This object does not require any heap allocations to create, and it only references information on the stack. Under the hood, all of the related macros are implemented in terms of this. First off, some example usage is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29fa7c971247c161eeccc64d10b730dfdf57cf6f" translate="yes" xml:space="preserve">
          <source>This is a curious macro which is used to safely pass around an opaque object describing the format string. This object does not require any heap allocations to create, and it only references information on the stack. Under the hood, all of the related macros are implemented in terms of this. First off, some example usage is:</source>
          <target state="translated">这是一个奇特的宏,用于安全地传递一个描述格式字符串的不透明对象。这个对象不需要任何堆分配来创建,它只引用栈上的信息。在下面,所有相关的宏都是用这个来实现的。首先,一些使用实例是。</target>
        </trans-unit>
        <trans-unit id="a5cb34f6e2e869f23ba4b01f87c2789e85bd0de1" translate="yes" xml:space="preserve">
          <source>This is a generic method to go from &lt;code&gt;&amp;amp;Pin&amp;lt;Pointer&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; to &lt;code&gt;Pin&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt;. It is safe because, as part of the contract of &lt;code&gt;Pin::new_unchecked&lt;/code&gt;, the pointee cannot move after &lt;code&gt;Pin&amp;lt;Pointer&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; got created. &quot;Malicious&quot; implementations of &lt;code&gt;Pointer::Deref&lt;/code&gt; are likewise ruled out by the contract of &lt;code&gt;Pin::new_unchecked&lt;/code&gt;.</source>
          <target state="translated">这是从 &lt;code&gt;&amp;amp;Pin&amp;lt;Pointer&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 到 &lt;code&gt;Pin&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; 的通用方法。这是安全的，因为作为 &lt;code&gt;Pin::new_unchecked&lt;/code&gt; 合同的一部分，在创建 &lt;code&gt;Pin&amp;lt;Pointer&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 后，承办人无法移动。同样， &lt;code&gt;Pin::new_unchecked&lt;/code&gt; 的合同也排除了 &lt;code&gt;Pointer::Deref&lt;/code&gt; &amp;ldquo;恶意&amp;rdquo;实现。</target>
        </trans-unit>
        <trans-unit id="56c4f5951c7828ae5ee50cc814a919ce365cfc61" translate="yes" xml:space="preserve">
          <source>This is a generic method to go from &lt;code&gt;&amp;amp;mut Pin&amp;lt;Pointer&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; to &lt;code&gt;Pin&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt;. It is safe because, as part of the contract of &lt;code&gt;Pin::new_unchecked&lt;/code&gt;, the pointee cannot move after &lt;code&gt;Pin&amp;lt;Pointer&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; got created. &quot;Malicious&quot; implementations of &lt;code&gt;Pointer::DerefMut&lt;/code&gt; are likewise ruled out by the contract of &lt;code&gt;Pin::new_unchecked&lt;/code&gt;.</source>
          <target state="translated">这是从 &lt;code&gt;&amp;amp;mut Pin&amp;lt;Pointer&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 到 &lt;code&gt;Pin&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; 的通用方法。这是安全的，因为作为 &lt;code&gt;Pin::new_unchecked&lt;/code&gt; 合同的一部分，在创建 &lt;code&gt;Pin&amp;lt;Pointer&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 后，承办人无法移动。同样， &lt;code&gt;Pin::new_unchecked&lt;/code&gt; 的合同也排除了 &lt;code&gt;Pointer::DerefMut&lt;/code&gt; &amp;ldquo;恶意&amp;rdquo;实现。</target>
        </trans-unit>
        <trans-unit id="89763ee5b7958c417ffa6362fe62836bd12504df" translate="yes" xml:space="preserve">
          <source>This is a great time to build a more substantial program to get used to reading and writing Rust code. So, in Chapter 2, we&amp;rsquo;ll build a guessing game program. If you would rather start by learning how common programming concepts work in Rust, see Chapter 3 and then return to Chapter 2.</source>
          <target state="translated">这是构建更强大的程序以习惯于阅读和编写Rust代码的好时机。因此，在第二章中，我们将构建一个猜测游戏程序。如果您想开始学习Rust中常见的编程概念的工作原理，请参阅第3章，然后返回第2章。</target>
        </trans-unit>
        <trans-unit id="b462da8b85a8420993ace33b35e2459c3b0f94de" translate="yes" xml:space="preserve">
          <source>This is a hack to workaround a limitation in our type-system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88ca2eb8b4f8037d6f9bc35aac9a7c204a66255a" translate="yes" xml:space="preserve">
          <source>This is a larger example that implements &lt;a href=&quot;http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm&quot;&gt;Dijkstra's algorithm&lt;/a&gt; to solve the &lt;a href=&quot;http://en.wikipedia.org/wiki/Shortest_path_problem&quot;&gt;shortest path problem&lt;/a&gt; on a &lt;a href=&quot;http://en.wikipedia.org/wiki/Directed_graph&quot;&gt;directed graph&lt;/a&gt;. It shows how to use &lt;a href=&quot;struct.binaryheap&quot;&gt;&lt;code&gt;BinaryHeap&lt;/code&gt;&lt;/a&gt; with custom types.</source>
          <target state="translated">这是一个较大的示例，该示例实现了&lt;a href=&quot;http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm&quot;&gt;Dijkstra的算法&lt;/a&gt;来解决有&lt;a href=&quot;http://en.wikipedia.org/wiki/Directed_graph&quot;&gt;向图&lt;/a&gt;上的&lt;a href=&quot;http://en.wikipedia.org/wiki/Shortest_path_problem&quot;&gt;最短路径问题&lt;/a&gt;。它显示了如何将&lt;a href=&quot;struct.binaryheap&quot;&gt; &lt;code&gt;BinaryHeap&lt;/code&gt; &lt;/a&gt;与自定义类型一起使用。</target>
        </trans-unit>
        <trans-unit id="0ce22a5b8db2ccd4642599318fe60aee2faa03ed" translate="yes" xml:space="preserve">
          <source>This is a larger example that implements &lt;a href=&quot;https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm&quot;&gt;Dijkstra's algorithm&lt;/a&gt; to solve the &lt;a href=&quot;https://en.wikipedia.org/wiki/Shortest_path_problem&quot;&gt;shortest path problem&lt;/a&gt; on a &lt;a href=&quot;https://en.wikipedia.org/wiki/Directed_graph&quot;&gt;directed graph&lt;/a&gt;. It shows how to use &lt;a href=&quot;../struct.binaryheap&quot;&gt;&lt;code&gt;BinaryHeap&lt;/code&gt;&lt;/a&gt; with custom types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26c511330b7bfd645fe1ae62ba92f808907b836b" translate="yes" xml:space="preserve">
          <source>This is a low-level operation that maintains none of the normal invariants of the type. Normally changing the length of a vector is done using one of the safe operations instead, such as &lt;a href=&quot;#method.truncate&quot;&gt;&lt;code&gt;truncate&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#method.resize&quot;&gt;&lt;code&gt;resize&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#method.extend-1&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#method.clear&quot;&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是一个低级操作，不保留该类型的任何普通不变式。通常，向量的长度更改是使用安全操作之一来完成的，例如&lt;a href=&quot;#method.truncate&quot;&gt; &lt;code&gt;truncate&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#method.resize&quot;&gt; &lt;code&gt;resize&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#method.extend-1&quot;&gt; &lt;code&gt;extend&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#method.clear&quot;&gt; &lt;code&gt;clear&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f83da737778161016a797e059513bd95b7a1b562" translate="yes" xml:space="preserve">
          <source>This is a low-level operation that maintains none of the normal invariants of the type. Normally changing the length of a vector is done using one of the safe operations instead, such as &lt;a href=&quot;struct.vec#method.truncate&quot;&gt;&lt;code&gt;truncate&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.vec#method.resize&quot;&gt;&lt;code&gt;resize&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../iter/trait.extend#tymethod.extend&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;struct.vec#method.clear&quot;&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5a83358209b9d321dd626221b446c20e90a835f" translate="yes" xml:space="preserve">
          <source>This is a lower-level version of &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是&lt;a href=&quot;enum.entry&quot;&gt; &lt;code&gt;Entry&lt;/code&gt; &lt;/a&gt;的较低版本。</target>
        </trans-unit>
        <trans-unit id="d779513c1e09f65a072541be686df3371c86d19d" translate="yes" xml:space="preserve">
          <source>This is a minimal HTML5 document with a heading and some text. To return this from the server when a request is received, we&amp;rsquo;ll modify &lt;code&gt;handle_connection&lt;/code&gt; as shown in Listing 20-5 to read the HTML file, add it to the response as a body, and send it.</source>
          <target state="translated">这是一个带有标题和一些文本的最小HTML5文档。为了在收到请求时从服务器返回此消息，我们将如清单20-5所示修改 &lt;code&gt;handle_connection&lt;/code&gt; ，以读取HTML文件，将其作为正文添加到响应中，然后发送它。</target>
        </trans-unit>
        <trans-unit id="b1799e7b3d355702a52652e9f785dc24c41920f9" translate="yes" xml:space="preserve">
          <source>This is a parameter for the &quot;minimum width&quot; that the format should take up. If the value's string does not fill up this many characters, then the padding specified by fill/alignment will be used to take up the required space (see below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a7bcaac4b774ad822d1d354cccc21a6015fca6e" translate="yes" xml:space="preserve">
          <source>This is a parameter for the &quot;minimum width&quot; that the format should take up. If the value's string does not fill up this many characters, then the padding specified by fill/alignment will be used to take up the required space.</source>
          <target state="translated">这是格式应占用的 &quot;最小宽度 &quot;的参数,如果值的字符串没有填满这么多字符,那么将使用fill/alignment指定的padding来占用所需空间。如果值的字符串没有填满这个字符,那么将使用fill/alignment指定的padding来占用所需空间。</target>
        </trans-unit>
        <trans-unit id="b084ef158428b63f0e7eeac68dee8b3d095bdb3c" translate="yes" xml:space="preserve">
          <source>This is a situation in which interior mutability can help! We&amp;rsquo;ll store the &lt;code&gt;sent_messages&lt;/code&gt; within a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, and then the &lt;code&gt;send&lt;/code&gt; message will be able to modify &lt;code&gt;sent_messages&lt;/code&gt; to store the messages we&amp;rsquo;ve seen. Listing 15-22 shows what that looks like:</source>
          <target state="translated">在这种情况下，内部可变性可以提供帮助！我们将 &lt;code&gt;sent_messages&lt;/code&gt; 存储在 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; ，然后 &lt;code&gt;send&lt;/code&gt; 消息将能够修改 &lt;code&gt;sent_messages&lt;/code&gt; 以存储我们已经看到的消息。清单15-22显示了如下内容：</target>
        </trans-unit>
        <trans-unit id="871d091695de2003c7e2185527248e9604155d93" translate="yes" xml:space="preserve">
          <source>This is a syntax error at the level of attribute declarations. The proper syntax for &lt;code&gt;align&lt;/code&gt; representation hint is the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e698a362ad50285269b0f450993154391ed3fb9c" translate="yes" xml:space="preserve">
          <source>This is a syntax error at the level of attribute declarations. The proper syntax for macro imports is the following:</source>
          <target state="translated">这是一个属性声明层面的语法错误。宏导入的正确语法如下:</target>
        </trans-unit>
        <trans-unit id="7207d1f263b95ee330100ad60d168c6bbd00e341" translate="yes" xml:space="preserve">
          <source>This is a very simple case, of course. In more complex cases, we may wish to have more than one reference to the value that was borrowed -- in those cases, something like the &lt;code&gt;Rc&lt;/code&gt; or &lt;code&gt;Arc&lt;/code&gt; types may be useful.</source>
          <target state="translated">当然，这是一个非常简单的情况。在更复杂的情况下，我们可能希望引用多个借用的值-在这种情况下，类似于 &lt;code&gt;Rc&lt;/code&gt; 或 &lt;code&gt;Arc&lt;/code&gt; 类型可能有用。</target>
        </trans-unit>
        <trans-unit id="795aa426a1aadc3299f800d117f15424e179c91c" translate="yes" xml:space="preserve">
          <source>This is a wrapper around a kind of pointer which makes that pointer &quot;pin&quot; its value in place, preventing the value referenced by that pointer from being moved unless it implements &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是一种指针的包装，该指针使该指针&amp;ldquo;固定&amp;rdquo;在适当的位置，除非该指针实现&lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; ,&lt;/a&gt;否则防止该指针引用的值移动。</target>
        </trans-unit>
        <trans-unit id="40cc1dd050d81853f1d6473844a8f5105ed4ba71" translate="yes" xml:space="preserve">
          <source>This is also available via &lt;a href=&quot;../convert/trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">也可以通过&lt;a href=&quot;../convert/trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; 获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="69c7de76e4d6cac4ead699615a01132090109223" translate="yes" xml:space="preserve">
          <source>This is an &lt;code&gt;O(n)&lt;/code&gt; operation as it requires copying every element in the buffer.</source>
          <target state="translated">这是 &lt;code&gt;O(n)&lt;/code&gt; 操作，因为它需要复制缓冲区中的每个元素。</target>
        </trans-unit>
        <trans-unit id="7714852846e41026b7148ab604a67c761a44e811" translate="yes" xml:space="preserve">
          <source>This is an &lt;code&gt;O(n)&lt;/code&gt; operation, as it requires copying every element in the buffer.</source>
          <target state="translated">这是一个 &lt;code&gt;O(n)&lt;/code&gt; 操作，因为它需要复制缓冲区中的每个元素。</target>
        </trans-unit>
        <trans-unit id="0851cea6a2c1ead7bc3e7afcac1e76a989dd5af9" translate="yes" xml:space="preserve">
          <source>This is an &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) operation as it requires copying every element in the buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebfdb05e0c25e262e85513236d16ce28096eaa2c" translate="yes" xml:space="preserve">
          <source>This is an &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) operation, as it requires copying every element in the buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7773930b7607b5b74b44eb47accc2cfca7d33e4" translate="yes" xml:space="preserve">
          <source>This is an &lt;em&gt;unsized&lt;/em&gt; type, meaning that it must always be used behind a pointer like &lt;code&gt;&amp;amp;&lt;/code&gt; or &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;. For an owned version of this type, see &lt;a href=&quot;struct.pathbuf&quot;&gt;&lt;code&gt;PathBuf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是一个&lt;em&gt;无大小的&lt;/em&gt;类型，这意味着必须始终在 &lt;code&gt;&amp;amp;&lt;/code&gt; 或&lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&lt;/code&gt; 之&lt;/a&gt;类的指针后面使用它。有关此类型的拥有版本，请参见&lt;a href=&quot;struct.pathbuf&quot;&gt; &lt;code&gt;PathBuf&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ae5b715f0a76526280a5abae050e91bd520680ba" translate="yes" xml:space="preserve">
          <source>This is an absolute path starting with &lt;code&gt;std&lt;/code&gt;, the name of the standard library crate.</source>
          <target state="translated">这是一个以 &lt;code&gt;std&lt;/code&gt; 开头的绝对路径，std是标准库箱的名称。</target>
        </trans-unit>
        <trans-unit id="fb3851cbc0fb3af560d20b0226cbd7a0adc72483" translate="yes" xml:space="preserve">
          <source>This is an alias to &lt;a href=&quot;../fs/fn.canonicalize&quot;&gt;&lt;code&gt;fs::canonicalize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是&lt;a href=&quot;../fs/fn.canonicalize&quot;&gt; &lt;code&gt;fs::canonicalize&lt;/code&gt; &lt;/a&gt;的别名。</target>
        </trans-unit>
        <trans-unit id="ccff757092656f4cd5645f893d07b3a2270144b9" translate="yes" xml:space="preserve">
          <source>This is an alias to &lt;a href=&quot;../fs/fn.metadata&quot;&gt;&lt;code&gt;fs::metadata&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是&lt;a href=&quot;../fs/fn.metadata&quot;&gt; &lt;code&gt;fs::metadata&lt;/code&gt; &lt;/a&gt;的别名。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
