<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="6e5a92b697e11f4f97be1cb92bf8a2c8203571cd" translate="yes" xml:space="preserve">
          <source>Fuse::is_sorted_by_key</source>
          <target state="translated">Fuse::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="c01cf3c78cdbb7fdd9e68eeecd85fe4f5fc5bcc7" translate="yes" xml:space="preserve">
          <source>Fuse::last</source>
          <target state="translated">Fuse::last</target>
        </trans-unit>
        <trans-unit id="fca9c9805a04224315e282c3be9b6a888b5ed9a1" translate="yes" xml:space="preserve">
          <source>Fuse::le</source>
          <target state="translated">Fuse::le</target>
        </trans-unit>
        <trans-unit id="53bec7ede087d7f3b55b0287278a68b38404a6d6" translate="yes" xml:space="preserve">
          <source>Fuse::len</source>
          <target state="translated">Fuse::len</target>
        </trans-unit>
        <trans-unit id="7b4183ba0f386cd9443aa4992eba62aa3b6deb95" translate="yes" xml:space="preserve">
          <source>Fuse::lt</source>
          <target state="translated">Fuse::lt</target>
        </trans-unit>
        <trans-unit id="5c262325339cd3156152addc6dd873caf49ad2b7" translate="yes" xml:space="preserve">
          <source>Fuse::map</source>
          <target state="translated">Fuse::map</target>
        </trans-unit>
        <trans-unit id="f34722d429c594a066614633112c87b369af6d10" translate="yes" xml:space="preserve">
          <source>Fuse::max</source>
          <target state="translated">Fuse::max</target>
        </trans-unit>
        <trans-unit id="74cd81b2b264540f6cf86176ce650c3ace7df66c" translate="yes" xml:space="preserve">
          <source>Fuse::max_by</source>
          <target state="translated">Fuse::max_by</target>
        </trans-unit>
        <trans-unit id="6363e416dfff32dea4b85f002985261e301ff120" translate="yes" xml:space="preserve">
          <source>Fuse::max_by_key</source>
          <target state="translated">Fuse::max_by_key</target>
        </trans-unit>
        <trans-unit id="ea71fbd8ca048cb3a4327bc3c665fd836b260d15" translate="yes" xml:space="preserve">
          <source>Fuse::min</source>
          <target state="translated">Fuse::min</target>
        </trans-unit>
        <trans-unit id="3e45b43694c4d735e3284df51fc1d5afa72689a1" translate="yes" xml:space="preserve">
          <source>Fuse::min_by</source>
          <target state="translated">Fuse::min_by</target>
        </trans-unit>
        <trans-unit id="460a4dae2436a52e10ab6fe47215192d0d2cc26c" translate="yes" xml:space="preserve">
          <source>Fuse::min_by_key</source>
          <target state="translated">Fuse::min_by_key</target>
        </trans-unit>
        <trans-unit id="fdbe92dea6e61847df85f41bba1c90d74049ae28" translate="yes" xml:space="preserve">
          <source>Fuse::ne</source>
          <target state="translated">Fuse::ne</target>
        </trans-unit>
        <trans-unit id="5230c2613200a1d46de34a7083facac940e009ab" translate="yes" xml:space="preserve">
          <source>Fuse::next</source>
          <target state="translated">Fuse::next</target>
        </trans-unit>
        <trans-unit id="51b95d33641283d83b2d3ca707d3b05b32955f7c" translate="yes" xml:space="preserve">
          <source>Fuse::next_back</source>
          <target state="translated">Fuse::next_back</target>
        </trans-unit>
        <trans-unit id="732184abb4e4b26b7896c98d0f1f6fb79face59a" translate="yes" xml:space="preserve">
          <source>Fuse::nth</source>
          <target state="translated">Fuse::nth</target>
        </trans-unit>
        <trans-unit id="ecf2d99b326b90bba4e5e94a2cfcb8fca5d36bf8" translate="yes" xml:space="preserve">
          <source>Fuse::nth_back</source>
          <target state="translated">Fuse::nth_back</target>
        </trans-unit>
        <trans-unit id="645b953e826c63fc9e513fa454ed5315f66f63e7" translate="yes" xml:space="preserve">
          <source>Fuse::partial_cmp</source>
          <target state="translated">Fuse::partial_cmp</target>
        </trans-unit>
        <trans-unit id="909f5215d0717af781bec722f3b0dd010a16016b" translate="yes" xml:space="preserve">
          <source>Fuse::partition</source>
          <target state="translated">Fuse::partition</target>
        </trans-unit>
        <trans-unit id="01e3171662432979d4756fdb5c7d60d5e3d3688a" translate="yes" xml:space="preserve">
          <source>Fuse::peekable</source>
          <target state="translated">Fuse::peekable</target>
        </trans-unit>
        <trans-unit id="6b80140311ab3ce2aaec8ebfd30dcf2e8f274077" translate="yes" xml:space="preserve">
          <source>Fuse::position</source>
          <target state="translated">Fuse::position</target>
        </trans-unit>
        <trans-unit id="cdf77414329bacb067e1a8328f80ce08984f20c6" translate="yes" xml:space="preserve">
          <source>Fuse::product</source>
          <target state="translated">Fuse::product</target>
        </trans-unit>
        <trans-unit id="8ef76fc13b788c76e379230ed857338ce665522c" translate="yes" xml:space="preserve">
          <source>Fuse::rev</source>
          <target state="translated">Fuse::rev</target>
        </trans-unit>
        <trans-unit id="c6ceda460157839498baef5d44fcbf90dfa55a4d" translate="yes" xml:space="preserve">
          <source>Fuse::rfind</source>
          <target state="translated">Fuse::rfind</target>
        </trans-unit>
        <trans-unit id="d330c64599fdb09d15b95c557b4d7892f68af3e1" translate="yes" xml:space="preserve">
          <source>Fuse::rfold</source>
          <target state="translated">Fuse::rfold</target>
        </trans-unit>
        <trans-unit id="4b3396affd9754021af0b44df2dd12d80df33ae6" translate="yes" xml:space="preserve">
          <source>Fuse::rposition</source>
          <target state="translated">Fuse::rposition</target>
        </trans-unit>
        <trans-unit id="ab43bd0b883653041efa0ea7cc154b6bf9af47c1" translate="yes" xml:space="preserve">
          <source>Fuse::scan</source>
          <target state="translated">Fuse::scan</target>
        </trans-unit>
        <trans-unit id="1b8b4c672f99a52b32d55c7bb8972a6f72ece7cf" translate="yes" xml:space="preserve">
          <source>Fuse::size_hint</source>
          <target state="translated">Fuse::size_hint</target>
        </trans-unit>
        <trans-unit id="d347c87cd849d9a01c9a979b0311dbcf96965bae" translate="yes" xml:space="preserve">
          <source>Fuse::skip</source>
          <target state="translated">Fuse::skip</target>
        </trans-unit>
        <trans-unit id="ecd51b0feeb4bb83cc2ee12bb364791884b19e9f" translate="yes" xml:space="preserve">
          <source>Fuse::skip_while</source>
          <target state="translated">Fuse::skip_while</target>
        </trans-unit>
        <trans-unit id="31f474af09ad27dc8cad30dd87438f396efab185" translate="yes" xml:space="preserve">
          <source>Fuse::step_by</source>
          <target state="translated">Fuse::step_by</target>
        </trans-unit>
        <trans-unit id="a8a56103bdd56576e7451868c2de237a02390598" translate="yes" xml:space="preserve">
          <source>Fuse::sum</source>
          <target state="translated">Fuse::sum</target>
        </trans-unit>
        <trans-unit id="29656f53c0fe5965acddeba06fd4f327a57a6b22" translate="yes" xml:space="preserve">
          <source>Fuse::take</source>
          <target state="translated">Fuse::take</target>
        </trans-unit>
        <trans-unit id="70ed5974147d5d5c47345358f79e9fe42830a0e2" translate="yes" xml:space="preserve">
          <source>Fuse::take_while</source>
          <target state="translated">Fuse::take_while</target>
        </trans-unit>
        <trans-unit id="c61f9148a2472fccbc543adcedcaef00ebc36916" translate="yes" xml:space="preserve">
          <source>Fuse::to_owned</source>
          <target state="translated">Fuse::to_owned</target>
        </trans-unit>
        <trans-unit id="9b8e9e88c43c584957c03c4a9790125c18a326dc" translate="yes" xml:space="preserve">
          <source>Fuse::try_fold</source>
          <target state="translated">Fuse::try_fold</target>
        </trans-unit>
        <trans-unit id="019976673022e8a2538f04e41619085b0509b968" translate="yes" xml:space="preserve">
          <source>Fuse::try_for_each</source>
          <target state="translated">Fuse::try_for_each</target>
        </trans-unit>
        <trans-unit id="fe419dd037d95472b807e093d3ea02ccb57032fd" translate="yes" xml:space="preserve">
          <source>Fuse::try_from</source>
          <target state="translated">Fuse::try_from</target>
        </trans-unit>
        <trans-unit id="f05020a71bfc101fbe84356da0aa7b927615342b" translate="yes" xml:space="preserve">
          <source>Fuse::try_into</source>
          <target state="translated">Fuse::try_into</target>
        </trans-unit>
        <trans-unit id="c841af43e247c2928b1064e08f72070c26de3b92" translate="yes" xml:space="preserve">
          <source>Fuse::try_rfold</source>
          <target state="translated">Fuse::try_rfold</target>
        </trans-unit>
        <trans-unit id="5d8927e5ec76098e5f2f5c0d2886eb49af8b8071" translate="yes" xml:space="preserve">
          <source>Fuse::type_id</source>
          <target state="translated">Fuse::type_id</target>
        </trans-unit>
        <trans-unit id="11c88abe9b80924ead19e08c32a0e7d6ff055afa" translate="yes" xml:space="preserve">
          <source>Fuse::unzip</source>
          <target state="translated">Fuse::unzip</target>
        </trans-unit>
        <trans-unit id="6e1886d4b16f1cab13382140a5a4f1a5275134bc" translate="yes" xml:space="preserve">
          <source>Fuse::zip</source>
          <target state="translated">Fuse::zip</target>
        </trans-unit>
        <trans-unit id="9c86bce2cc6fe0fed1d906293dbdc3155ee68bd1" translate="yes" xml:space="preserve">
          <source>Fused multiply-add. Computes &lt;code&gt;(self * a) + b&lt;/code&gt; with only one rounding error, yielding a more accurate result than an unfused multiply-add.</source>
          <target state="translated">融合乘法加法。仅以一个舍入误差计算 &lt;code&gt;(self * a) + b&lt;/code&gt; 与未融合的乘法加法相比，得出的结果更准确。</target>
        </trans-unit>
        <trans-unit id="b5bb5c0c622a64179c02df6d378fd9fe00019e5d" translate="yes" xml:space="preserve">
          <source>FusedIterator</source>
          <target state="translated">FusedIterator</target>
        </trans-unit>
        <trans-unit id="047ca54032a1756c098d3bc1a941a0ed8e583df8" translate="yes" xml:space="preserve">
          <source>Future</source>
          <target state="translated">Future</target>
        </trans-unit>
        <trans-unit id="34f9f68cc95c47f600ff51f98b51efdc1e4973b7" translate="yes" xml:space="preserve">
          <source>Future compatibility</source>
          <target state="translated">未来的兼容性</target>
        </trans-unit>
        <trans-unit id="fe870fd01f0abd72a18fbaf5c5cbed77f351525a" translate="yes" xml:space="preserve">
          <source>Future::poll</source>
          <target state="translated">Future::poll</target>
        </trans-unit>
        <trans-unit id="5404be636a9f63c6aa8f665b2d42ad260f8e8dfb" translate="yes" xml:space="preserve">
          <source>Futures alone are &lt;em&gt;inert&lt;/em&gt;; they must be &lt;em&gt;actively&lt;/em&gt;&lt;code&gt;poll&lt;/code&gt;ed to make progress, meaning that each time the current task is woken up, it should actively re-&lt;code&gt;poll&lt;/code&gt; pending futures that it still has an interest in.</source>
          <target state="translated">期货本身是&lt;em&gt;惰性的&lt;/em&gt; ; 必须&lt;em&gt;积极地&lt;/em&gt; &lt;code&gt;poll&lt;/code&gt; 它们以取得进展，这意味着每次唤醒当前任务时，它都应该主动重新 &lt;code&gt;poll&lt;/code&gt; 仍对其感兴趣的未决期货。</target>
        </trans-unit>
        <trans-unit id="271eac5352b0f5dcc6b36ba90bfc074be7357d5e" translate="yes" xml:space="preserve">
          <source>Futures created through this function are functionally similar to those created through &lt;code&gt;async {}&lt;/code&gt;. The main difference is that futures created through this function are named and implement &lt;code&gt;Unpin&lt;/code&gt;.</source>
          <target state="translated">通过此函数创建的期货在功能上类似于通过 &lt;code&gt;async {}&lt;/code&gt; 创建的期货。主要区别在于，通过此功能创建的期货被命名并实现 &lt;code&gt;Unpin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="170618a3c56100e7f9817b28534dee7fda36bd36" translate="yes" xml:space="preserve">
          <source>GNU C library Bugzilla</source>
          <target state="translated">GNU C 库 Bugzilla</target>
        </trans-unit>
        <trans-unit id="ae44bdb1ff1d7f62acdd7de8bfa0f16c08c76789" translate="yes" xml:space="preserve">
          <source>Gain a reference to the underlying &lt;code&gt;stat&lt;/code&gt; structure which contains the raw information returned by the OS.</source>
          <target state="translated">获取对基础 &lt;code&gt;stat&lt;/code&gt; 结构的引用，其中包含操作系统返回的原始信息。</target>
        </trans-unit>
        <trans-unit id="28e18309d45539def481f7786d4cc8d73b9f5aec" translate="yes" xml:space="preserve">
          <source>Gain a reference to the underlying &lt;code&gt;stat&lt;/code&gt; structure which contains the raw information returned by the OS. &lt;a href=&quot;../os/linux/fs/trait.metadataext#tymethod.as_raw_stat&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">获取对基础 &lt;code&gt;stat&lt;/code&gt; 结构的引用，其中包含操作系统返回的原始信息。&lt;a href=&quot;../os/linux/fs/trait.metadataext#tymethod.as_raw_stat&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5023fde21a93efcc45f3ef1278a03020db274d7f" translate="yes" xml:space="preserve">
          <source>Ge</source>
          <target state="translated">Ge</target>
        </trans-unit>
        <trans-unit id="826e54d9f3341da0639215d591e03f7d7c85bcf1" translate="yes" xml:space="preserve">
          <source>Generalizing the latter case, any type implementing &lt;a href=&quot;../ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; can't be &lt;code&gt;Copy&lt;/code&gt;, because it's managing some resource besides its own &lt;a href=&quot;../mem/fn.size_of&quot;&gt;&lt;code&gt;size_of::&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; bytes.</source>
          <target state="translated">概括后一种情况，实现&lt;a href=&quot;../ops/trait.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; 的&lt;/a&gt;任何类型都不能为 &lt;code&gt;Copy&lt;/code&gt; ，因为它除了管理自己的&lt;a href=&quot;../mem/fn.size_of&quot;&gt; &lt;code&gt;size_of::&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;字节外还管理某些资源。</target>
        </trans-unit>
        <trans-unit id="b3f505d3f65e19757f523841da2ceb51bc20ba3c" translate="yes" xml:space="preserve">
          <source>Generally speaking, if your type &lt;em&gt;can&lt;/em&gt; implement &lt;code&gt;Copy&lt;/code&gt;, it should. Keep in mind, though, that implementing &lt;code&gt;Copy&lt;/code&gt; is part of the public API of your type. If the type might become non-&lt;code&gt;Copy&lt;/code&gt; in the future, it could be prudent to omit the &lt;code&gt;Copy&lt;/code&gt; implementation now, to avoid a breaking API change.</source>
          <target state="translated">一般来说，如果您的类型&lt;em&gt;可以&lt;/em&gt;实现 &lt;code&gt;Copy&lt;/code&gt; ，则应该实现。但是请记住，实现 &lt;code&gt;Copy&lt;/code&gt; 是您类型的公共API的一部分。如果该类型将来可能变为非 &lt;code&gt;Copy&lt;/code&gt; ，则最好现在省略 &lt;code&gt;Copy&lt;/code&gt; 实现，以免API发生重大更改。</target>
        </trans-unit>
        <trans-unit id="5f188724c393355d9852c11495e877635da2c7cf" translate="yes" xml:space="preserve">
          <source>Generally speaking, when using &lt;code&gt;OpenOptions&lt;/code&gt;, you'll first call &lt;a href=&quot;struct.openoptions#method.new&quot;&gt;&lt;code&gt;OpenOptions::new&lt;/code&gt;&lt;/a&gt;, then chain calls to methods to set each option, then call &lt;a href=&quot;struct.openoptions#method.open&quot;&gt;&lt;code&gt;OpenOptions::open&lt;/code&gt;&lt;/a&gt;, passing the path of the file you're trying to open. This will give you a &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt; with a &lt;a href=&quot;struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; inside that you can further operate on.</source>
          <target state="translated">一般而言，使用 &lt;code&gt;OpenOptions&lt;/code&gt; 时，您将首先调用&lt;a href=&quot;struct.openoptions#method.new&quot;&gt; &lt;code&gt;OpenOptions::new&lt;/code&gt; &lt;/a&gt;，然后将对方法的链式调用设置为每个选项，然后调用&lt;a href=&quot;struct.openoptions#method.open&quot;&gt; &lt;code&gt;OpenOptions::open&lt;/code&gt; &lt;/a&gt;，传递您要打开的文件的路径。这将为您提供&lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt;其中包含一个&lt;a href=&quot;struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt;，您可以进一步对其进行操作。</target>
        </trans-unit>
        <trans-unit id="f413a99b90fcebaf815708bcac6bf2c609712621" translate="yes" xml:space="preserve">
          <source>Generally speaking, when using &lt;code&gt;OpenOptions&lt;/code&gt;, you'll first call &lt;a href=&quot;struct.openoptions#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt;, then chain calls to methods to set each option, then call &lt;a href=&quot;struct.openoptions#method.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt;, passing the path of the file you're trying to open. This will give you a &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt; with a &lt;a href=&quot;struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; inside that you can further operate on.</source>
          <target state="translated">一般来说，使用 &lt;code&gt;OpenOptions&lt;/code&gt; 时，您将首先调用&lt;a href=&quot;struct.openoptions#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt;，然后将调用链接到方法以设置每个选项，然后调用&lt;a href=&quot;struct.openoptions#method.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt;，并传递您要打开的文件的路径。这将为您提供&lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt;其中包含一个&lt;a href=&quot;struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt;，您可以进一步对其进行操作。</target>
        </trans-unit>
        <trans-unit id="ef7a9d88d07b5708f08d417b4551f7e7322bf0bc" translate="yes" xml:space="preserve">
          <source>Generally speaking, you should just &lt;code&gt;derive&lt;/code&gt; a &lt;code&gt;Debug&lt;/code&gt; implementation.</source>
          <target state="translated">一般来说，你应该 &lt;code&gt;derive&lt;/code&gt; 一个 &lt;code&gt;Debug&lt;/code&gt; 的实现。</target>
        </trans-unit>
        <trans-unit id="732f11f2232d28d3cd17a16f8d12c4158ae671a2" translate="yes" xml:space="preserve">
          <source>Generally, &lt;code&gt;Self: Sized&lt;/code&gt; is used to indicate that the trait should not be used as a trait object. If the trait comes from your own crate, consider removing this restriction.</source>
          <target state="translated">通常， &lt;code&gt;Self: Sized&lt;/code&gt; 用于表示不应将特征用作特征对象。如果特征来自您自己的箱子，请考虑删除此限制。</target>
        </trans-unit>
        <trans-unit id="4e2b4a1c449efa70704f19e5e57263ca0c4ffc22" translate="yes" xml:space="preserve">
          <source>Generally, for smart pointers you will implement &lt;code&gt;CoerceUnsized&amp;lt;Ptr&amp;lt;U&amp;gt;&amp;gt; for Ptr&amp;lt;T&amp;gt; where T: Unsize&amp;lt;U&amp;gt;, U: ?Sized&lt;/code&gt;, with an optional &lt;code&gt;?Sized&lt;/code&gt; bound on &lt;code&gt;T&lt;/code&gt; itself. For wrapper types that directly embed &lt;code&gt;T&lt;/code&gt; like &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, you can directly implement &lt;code&gt;CoerceUnsized&amp;lt;Wrap&amp;lt;U&amp;gt;&amp;gt; for Wrap&amp;lt;T&amp;gt; where T: CoerceUnsized&amp;lt;U&amp;gt;&lt;/code&gt;. This will let coercions of types like &lt;code&gt;Cell&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; work.</source>
          <target state="translated">通常，对于智能指针，您将为 &lt;code&gt;CoerceUnsized&amp;lt;Ptr&amp;lt;U&amp;gt;&amp;gt; for Ptr&amp;lt;T&amp;gt; where T: Unsize&amp;lt;U&amp;gt;, U: ?Sized&lt;/code&gt; 实现CoerceUnsize &amp;lt;Ptr &amp;lt;U &amp;gt;&amp;gt;，其中T：Unsize &amp;lt;U&amp;gt;，U：？Sized，对 &lt;code&gt;T&lt;/code&gt; 本身绑定可选的 &lt;code&gt;?Sized&lt;/code&gt; 。对于直接嵌入 &lt;code&gt;T&lt;/code&gt; 的包装器类型（如 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; ，您可以直接 &lt;code&gt;CoerceUnsized&amp;lt;Wrap&amp;lt;U&amp;gt;&amp;gt; for Wrap&amp;lt;T&amp;gt; where T: CoerceUnsized&amp;lt;U&amp;gt;&lt;/code&gt; 实现CoerceUnsize &amp;lt;Wrap &amp;lt;U &amp;gt;&amp;gt;，其中T：CoerceUnsized &amp;lt;U&amp;gt;。这将使像 &lt;code&gt;Cell&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 之类的强制转换起作用。</target>
        </trans-unit>
        <trans-unit id="5a24acc6c6f1f6f5fa4a70e0c8ec97be7ad2c8f4" translate="yes" xml:space="preserve">
          <source>Generate the nth Fibonacci number.</source>
          <target state="translated">产生第n个斐波那契数。</target>
        </trans-unit>
        <trans-unit id="4055bcedf4ef42a40655c354d55e695956e52c99" translate="yes" xml:space="preserve">
          <source>Generates a wide character sequence for potentially ill-formed UTF-16.</source>
          <target state="translated">为潜在的不规则UTF-16生成一个宽字符序列。</target>
        </trans-unit>
        <trans-unit id="2358686f35ad9babf41475908fbf7fb94c7fb8f0" translate="yes" xml:space="preserve">
          <source>Generates the base configuration for spawning a thread, from which configuration methods can be chained.</source>
          <target state="translated">生成用于产卵线程的基本配置,配置方法可以从这个配置方法中链起来。</target>
        </trans-unit>
        <trans-unit id="4eed3f4ef0910be56eecb5b88bc01f17517c6c08" translate="yes" xml:space="preserve">
          <source>Generating a Random Number</source>
          <target state="translated">生成一个随机数</target>
        </trans-unit>
        <trans-unit id="4344ed85b4c6edaff3d6a74283da67d4030e7149" translate="yes" xml:space="preserve">
          <source>Generating a Secret Number</source>
          <target state="translated">生成一个秘密号码</target>
        </trans-unit>
        <trans-unit id="1d20de03126b297e05c13a7d280f33e24c72c537" translate="yes" xml:space="preserve">
          <source>Generator</source>
          <target state="translated">Generator</target>
        </trans-unit>
        <trans-unit id="be3352ebf40a7e8e4b021ce3ac0440a124629bf5" translate="yes" xml:space="preserve">
          <source>Generator::resume</source>
          <target state="translated">Generator::resume</target>
        </trans-unit>
        <trans-unit id="8a05177b6fef574c9007b27a5b9c1d6d147b496c" translate="yes" xml:space="preserve">
          <source>GeneratorState</source>
          <target state="translated">GeneratorState</target>
        </trans-unit>
        <trans-unit id="d04f291cf43bb98ceb2d5124b4e75aa6ba1544d4" translate="yes" xml:space="preserve">
          <source>GeneratorState::borrow</source>
          <target state="translated">GeneratorState::borrow</target>
        </trans-unit>
        <trans-unit id="e237a5c5d934ed2bcc036a7ec579e8363436fa8f" translate="yes" xml:space="preserve">
          <source>GeneratorState::borrow_mut</source>
          <target state="translated">GeneratorState::borrow_mut</target>
        </trans-unit>
        <trans-unit id="2502b2db43ac135d156ec67093f193a1d551ada7" translate="yes" xml:space="preserve">
          <source>GeneratorState::clamp</source>
          <target state="translated">GeneratorState::clamp</target>
        </trans-unit>
        <trans-unit id="14c55996161a4d9905bb442a79bebdda60c0a770" translate="yes" xml:space="preserve">
          <source>GeneratorState::clone</source>
          <target state="translated">GeneratorState::clone</target>
        </trans-unit>
        <trans-unit id="3f7f8fe2855b988679d6469ba23b116c95fb7f94" translate="yes" xml:space="preserve">
          <source>GeneratorState::clone_from</source>
          <target state="translated">GeneratorState::clone_from</target>
        </trans-unit>
        <trans-unit id="80b100a3f0da64d40e398e415f7da34b79e8c141" translate="yes" xml:space="preserve">
          <source>GeneratorState::clone_into</source>
          <target state="translated">GeneratorState::clone_into</target>
        </trans-unit>
        <trans-unit id="e257c93690e4d8869ec57678eef2e65d13e430ee" translate="yes" xml:space="preserve">
          <source>GeneratorState::cmp</source>
          <target state="translated">GeneratorState::cmp</target>
        </trans-unit>
        <trans-unit id="8a2e0ed5e7b43d7400dac081e69edcd39c918c34" translate="yes" xml:space="preserve">
          <source>GeneratorState::eq</source>
          <target state="translated">GeneratorState::eq</target>
        </trans-unit>
        <trans-unit id="89c2703dea761c8c48ffa4254fb375381596d10f" translate="yes" xml:space="preserve">
          <source>GeneratorState::fmt</source>
          <target state="translated">GeneratorState::fmt</target>
        </trans-unit>
        <trans-unit id="eda2eb9f12fc2973fa0ac082be186f3fadfe23bd" translate="yes" xml:space="preserve">
          <source>GeneratorState::from</source>
          <target state="translated">GeneratorState::from</target>
        </trans-unit>
        <trans-unit id="a10861d2a70c2a97bea18ae69516399a36bee43f" translate="yes" xml:space="preserve">
          <source>GeneratorState::ge</source>
          <target state="translated">GeneratorState::ge</target>
        </trans-unit>
        <trans-unit id="72a246cb6eeb7bd47306411db8d35d82c5c697bd" translate="yes" xml:space="preserve">
          <source>GeneratorState::gt</source>
          <target state="translated">GeneratorState::gt</target>
        </trans-unit>
        <trans-unit id="f47d401161e51de0bd3708a6aa6b0162f13c3a4d" translate="yes" xml:space="preserve">
          <source>GeneratorState::hash</source>
          <target state="translated">GeneratorState::hash</target>
        </trans-unit>
        <trans-unit id="0d2cf74073e99ac2f7b4a8d84ac45a2dec7d63a3" translate="yes" xml:space="preserve">
          <source>GeneratorState::hash_slice</source>
          <target state="translated">GeneratorState::hash_slice</target>
        </trans-unit>
        <trans-unit id="d362c3c3176b8bb099ef83d916f2d082b1a7c9b7" translate="yes" xml:space="preserve">
          <source>GeneratorState::into</source>
          <target state="translated">GeneratorState::into</target>
        </trans-unit>
        <trans-unit id="b756ce5dda7c46f9d07b0d1aca348d701a969f8c" translate="yes" xml:space="preserve">
          <source>GeneratorState::le</source>
          <target state="translated">GeneratorState::le</target>
        </trans-unit>
        <trans-unit id="93e42bf71e3b440df1059a94e8e0dc45070ae52f" translate="yes" xml:space="preserve">
          <source>GeneratorState::lt</source>
          <target state="translated">GeneratorState::lt</target>
        </trans-unit>
        <trans-unit id="6d1cac78c83d7c9a11d1fbbd289720c9f3206ab7" translate="yes" xml:space="preserve">
          <source>GeneratorState::max</source>
          <target state="translated">GeneratorState::max</target>
        </trans-unit>
        <trans-unit id="37560d6c837e27a56cbfe576d408ec65983cd14a" translate="yes" xml:space="preserve">
          <source>GeneratorState::min</source>
          <target state="translated">GeneratorState::min</target>
        </trans-unit>
        <trans-unit id="3549d5021f412f184a2ec1f2eb1ad44c8d1d5469" translate="yes" xml:space="preserve">
          <source>GeneratorState::ne</source>
          <target state="translated">GeneratorState::ne</target>
        </trans-unit>
        <trans-unit id="eaf2826ae0eabec3e56edf7fd20219fdbd1719d8" translate="yes" xml:space="preserve">
          <source>GeneratorState::partial_cmp</source>
          <target state="translated">GeneratorState::partial_cmp</target>
        </trans-unit>
        <trans-unit id="bc63dfa2c5dc307fd7de8a64413574342399b682" translate="yes" xml:space="preserve">
          <source>GeneratorState::to_owned</source>
          <target state="translated">GeneratorState::to_owned</target>
        </trans-unit>
        <trans-unit id="50328fd3c1aba2c5f8f065dcd6362c0cc51dfd2c" translate="yes" xml:space="preserve">
          <source>GeneratorState::try_from</source>
          <target state="translated">GeneratorState::try_from</target>
        </trans-unit>
        <trans-unit id="98ea27a003d07dda294e378b634a2c17ba4c3a3e" translate="yes" xml:space="preserve">
          <source>GeneratorState::try_into</source>
          <target state="translated">GeneratorState::try_into</target>
        </trans-unit>
        <trans-unit id="87741a9ed7c3b2106ba319e6c46fba99b623309a" translate="yes" xml:space="preserve">
          <source>GeneratorState::type_id</source>
          <target state="translated">GeneratorState::type_id</target>
        </trans-unit>
        <trans-unit id="7f39e996a867af2cbe188c7b44ecc3d06e5acc04" translate="yes" xml:space="preserve">
          <source>Generators, also commonly referred to as coroutines, are currently an experimental language feature in Rust. Added in &lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/2033&quot;&gt;RFC 2033&lt;/a&gt; generators are currently intended to primarily provide a building block for async/await syntax but will likely extend to also providing an ergonomic definition for iterators and other primitives.</source>
          <target state="translated">生成器，通常也称为协程，目前是Rust中的一种实验语言功能。&lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/2033&quot;&gt;RFC 2033中&lt;/a&gt;添加的生成器目前主要用于为异步/等待语法提供构造块，但可能会扩展为还为迭代器和其他原语提供符合人体工程学的定义。</target>
        </trans-unit>
        <trans-unit id="326f639e29705946500c3f82d8731c2e1774c768" translate="yes" xml:space="preserve">
          <source>Generic &lt;a href=&quot;types/parameters&quot;&gt;type parameters&lt;/a&gt;.</source>
          <target state="translated">通用&lt;a href=&quot;types/parameters&quot;&gt;类型参数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1807cc787d281913c23f12bd3560541d8f00b032" translate="yes" xml:space="preserve">
          <source>Generic Data Types</source>
          <target state="translated">通用数据类型</target>
        </trans-unit>
        <trans-unit id="98f64976fc4f70ae5ee15f3bc5b13a2d6b9d672a" translate="yes" xml:space="preserve">
          <source>Generic Implementations</source>
          <target state="translated">通用实施</target>
        </trans-unit>
        <trans-unit id="f072da836e4d916032d518ff0f18fd650d4581ad" translate="yes" xml:space="preserve">
          <source>Generic Lifetimes in Functions</source>
          <target state="translated">函数中的通用寿命</target>
        </trans-unit>
        <trans-unit id="27eeb642b1a0c27c15bf839571b69f7e44c24936" translate="yes" xml:space="preserve">
          <source>Generic Traits</source>
          <target state="translated">通用特征</target>
        </trans-unit>
        <trans-unit id="efb89da0fe84fb1c10e0e67f29f7eeede9f0ba20" translate="yes" xml:space="preserve">
          <source>Generic Type Parameters, Trait Bounds, and Lifetimes Together</source>
          <target state="translated">通用类型参数、特质边界和寿命的结合。</target>
        </trans-unit>
        <trans-unit id="9cd42050d57736e2d4fca7655d0893381fa92cbb" translate="yes" xml:space="preserve">
          <source>Generic Types, Traits, and Lifetimes</source>
          <target state="translated">通用类型、特征和寿命</target>
        </trans-unit>
        <trans-unit id="8d490f5f674a359f8f4f73405d1a00a44fb2ed0a" translate="yes" xml:space="preserve">
          <source>Generic arguments were not provided in the same order as the corresponding generic parameters are declared.</source>
          <target state="translated">通用参数的提供顺序与相应通用参数的声明顺序不一致。</target>
        </trans-unit>
        <trans-unit id="37f5365cdbef14515226dcd384583192170cc525" translate="yes" xml:space="preserve">
          <source>Generic functions</source>
          <target state="translated">通用功能</target>
        </trans-unit>
        <trans-unit id="1f4659089d7ab3bbc1fbc01f1bd9729f123901fd" translate="yes" xml:space="preserve">
          <source>Generic functions and generic structs can use traits to constrain, or bound, the types they accept.</source>
          <target state="translated">通用函数和通用结构可以使用特征来约束,或者说约束它们所接受的类型。</target>
        </trans-unit>
        <trans-unit id="eae8cd46084865929b442cf8ea6d11173b23b60b" translate="yes" xml:space="preserve">
          <source>Generic functions and types with a &lt;code&gt;T: Trait&lt;/code&gt; bounds can be used with &lt;code&gt;Ty&lt;/code&gt; being used for &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">通用功能和类型与 &lt;code&gt;T: Trait&lt;/code&gt; 界限可与使用 &lt;code&gt;Ty&lt;/code&gt; 被用于 &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4bcab43ed4f07d581db4e91c1af83663a27b91de" translate="yes" xml:space="preserve">
          <source>Generic hashing support.</source>
          <target state="translated">通用哈希支持。</target>
        </trans-unit>
        <trans-unit id="5c44d31fa6749df8167db78b7f69c1e6b8112cff" translate="yes" xml:space="preserve">
          <source>Generic items may use traits as &lt;a href=&quot;../trait-bounds&quot;&gt;bounds&lt;/a&gt; on their type parameters.</source>
          <target state="translated">泛型项目可以将特征用作其类型参数的&lt;a href=&quot;../trait-bounds&quot;&gt;界限&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="910a23e27585722660fb101574581723e9023985" translate="yes" xml:space="preserve">
          <source>Generic lifetime &lt;code&gt;'b&lt;/code&gt; must outlive lifetime &lt;code&gt;'a&lt;/code&gt;</source>
          <target state="translated">通用寿命 &lt;code&gt;'b&lt;/code&gt; 必须寿命超过寿命 &lt;code&gt;'a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7374523f7aaffe9d327555dcc2269e6002424197" translate="yes" xml:space="preserve">
          <source>Generic lifetime and type parameters allow &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; on them. There are no built-in attributes that do anything in this position, although custom derive attributes may give meaning to it.</source>
          <target state="translated">通用生存期和类型参数允许使用&lt;a href=&quot;../attributes&quot;&gt;属性&lt;/a&gt;。尽管自定义派生属性可能为其赋予了含义，但没有内置属性可以在此位置执行任何操作。</target>
        </trans-unit>
        <trans-unit id="070d7b64bfe57bcc62addca63e2c1cff8dd83211" translate="yes" xml:space="preserve">
          <source>Generic parameter &lt;code&gt;T&lt;/code&gt; constrained to types that implement &lt;code&gt;U&lt;/code&gt;</source>
          <target state="translated">通用参数 &lt;code&gt;T&lt;/code&gt; 限制为实现 &lt;code&gt;U&lt;/code&gt; 的类型</target>
        </trans-unit>
        <trans-unit id="358eed37fa63fd6b1e5193acd34abc17d6db4cd2" translate="yes" xml:space="preserve">
          <source>Generic parameters are implicit with &lt;code&gt;Self&lt;/code&gt;:</source>
          <target state="translated">通用参数在 &lt;code&gt;Self&lt;/code&gt; 中是隐式的：</target>
        </trans-unit>
        <trans-unit id="a0662e93a0c0518f55b130b80b54fb79df0d0c94" translate="yes" xml:space="preserve">
          <source>Generic type &lt;code&gt;T&lt;/code&gt; contains no borrowed references other than &lt;code&gt;'static&lt;/code&gt; ones</source>
          <target state="translated">通用型 &lt;code&gt;T&lt;/code&gt; 不包含借用其他参考比 &lt;code&gt;'static&lt;/code&gt; 者</target>
        </trans-unit>
        <trans-unit id="aff0c7dbfb36e71d34305b173306f472b0221612" translate="yes" xml:space="preserve">
          <source>Generic type &lt;code&gt;T&lt;/code&gt; must outlive lifetime &lt;code&gt;'a&lt;/code&gt; (meaning the type cannot transitively contain any references with lifetimes shorter than &lt;code&gt;'a&lt;/code&gt;)</source>
          <target state="translated">通用类型 &lt;code&gt;T&lt;/code&gt; 必须超过生存期 &lt;code&gt;'a&lt;/code&gt; （这意味着该类型不能可传递地包含任何生存期短于 &lt;code&gt;'a&lt;/code&gt; 的引用）</target>
        </trans-unit>
        <trans-unit id="e6e64547108bd126e5d53a717612fe87ff383d16" translate="yes" xml:space="preserve">
          <source>Generic type parameters in a struct definition aren&amp;rsquo;t always the same as those you use in that struct&amp;rsquo;s method signatures. For example, Listing 10-11 defines the method &lt;code&gt;mixup&lt;/code&gt; on the &lt;code&gt;Point&amp;lt;T, U&amp;gt;&lt;/code&gt; struct from Listing 10-8. The method takes another &lt;code&gt;Point&lt;/code&gt; as a parameter, which might have different types from the &lt;code&gt;self&lt;/code&gt;&lt;code&gt;Point&lt;/code&gt; we&amp;rsquo;re calling &lt;code&gt;mixup&lt;/code&gt; on. The method creates a new &lt;code&gt;Point&lt;/code&gt; instance with the &lt;code&gt;x&lt;/code&gt; value from the &lt;code&gt;self&lt;/code&gt;&lt;code&gt;Point&lt;/code&gt; (of type &lt;code&gt;T&lt;/code&gt;) and the &lt;code&gt;y&lt;/code&gt; value from the passed-in &lt;code&gt;Point&lt;/code&gt; (of type &lt;code&gt;W&lt;/code&gt;).</source>
          <target state="translated">结构定义中的泛型类型参数并不总是与该结构的方法签名中使用的参数相同。例如，清单10-11在清单10-8中的 &lt;code&gt;Point&amp;lt;T, U&amp;gt;&lt;/code&gt; 结构上定义了方法 &lt;code&gt;mixup&lt;/code&gt; 。该方法将另一个 &lt;code&gt;Point&lt;/code&gt; 用作参数，该类型可能与我们在其上调用 &lt;code&gt;mixup&lt;/code&gt; 的 &lt;code&gt;self&lt;/code&gt; &lt;code&gt;Point&lt;/code&gt; 的类型不同。该方法使用来自 &lt;code&gt;self&lt;/code&gt; &lt;code&gt;Point&lt;/code&gt; 的 &lt;code&gt;x&lt;/code&gt; 值（类型 &lt;code&gt;T&lt;/code&gt; ）和来自传入的 &lt;code&gt;Point&lt;/code&gt; 的 &lt;code&gt;y&lt;/code&gt; 值（类型 &lt;code&gt;W&lt;/code&gt; ）创建一个新的 &lt;code&gt;Point&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="24a4c08697368c16f5fbbfbba45a86f6181cd53e" translate="yes" xml:space="preserve">
          <source>Generics have been used on an auto trait.</source>
          <target state="translated">仿制药已经用在了自动性状上。</target>
        </trans-unit>
        <trans-unit id="0504e570433bf881c8e4f524e7865541e64b7072" translate="yes" xml:space="preserve">
          <source>Get a pinned mutable reference from a static mutable reference.</source>
          <target state="translated">从一个静态可变引用中获取一个钉住的可变引用。</target>
        </trans-unit>
        <trans-unit id="eb95181a8c4c34e71821bcb5b2d547968b70fff0" translate="yes" xml:space="preserve">
          <source>Get a pinned reference from a static reference.</source>
          <target state="translated">从静态引用中获取一个钉住的引用。</target>
        </trans-unit>
        <trans-unit id="4be352f47b5e6ad288f45c1ffb564c03acea5928" translate="yes" xml:space="preserve">
          <source>Get atomic access to a &lt;code&gt;&amp;amp;mut bool&lt;/code&gt;.</source>
          <target state="translated">获得对 &lt;code&gt;&amp;amp;mut bool&lt;/code&gt; 的原子访问。</target>
        </trans-unit>
        <trans-unit id="be6a3b4e003eb4b0da26051861e6a8afd27a77f2" translate="yes" xml:space="preserve">
          <source>Get atomic access to a &lt;code&gt;&amp;amp;mut i16&lt;/code&gt;.</source>
          <target state="translated">获得对 &lt;code&gt;&amp;amp;mut i16&lt;/code&gt; 的原子访问。</target>
        </trans-unit>
        <trans-unit id="dfaa4b24fd6ed6fa9005fce55a46cedaf4873afb" translate="yes" xml:space="preserve">
          <source>Get atomic access to a &lt;code&gt;&amp;amp;mut i32&lt;/code&gt;.</source>
          <target state="translated">获得对 &lt;code&gt;&amp;amp;mut i32&lt;/code&gt; 的原子访问。</target>
        </trans-unit>
        <trans-unit id="0d0fbe251cddfe77d2382a7fe1ddccda6727f7dc" translate="yes" xml:space="preserve">
          <source>Get atomic access to a &lt;code&gt;&amp;amp;mut i64&lt;/code&gt;.</source>
          <target state="translated">获得对 &lt;code&gt;&amp;amp;mut i64&lt;/code&gt; 的原子访问。</target>
        </trans-unit>
        <trans-unit id="f94480ecfd23dbc87f67caa39256ed88bbd75535" translate="yes" xml:space="preserve">
          <source>Get atomic access to a &lt;code&gt;&amp;amp;mut i8&lt;/code&gt;.</source>
          <target state="translated">获得对 &lt;code&gt;&amp;amp;mut i8&lt;/code&gt; 的原子访问。</target>
        </trans-unit>
        <trans-unit id="995c7f0c6e5302e5c0b1595c6739a6650e6aa199" translate="yes" xml:space="preserve">
          <source>Get atomic access to a &lt;code&gt;&amp;amp;mut isize&lt;/code&gt;.</source>
          <target state="translated">获得对 &lt;code&gt;&amp;amp;mut isize&lt;/code&gt; 的原子访问。</target>
        </trans-unit>
        <trans-unit id="ec51732ae25a09c8ca12e18b2914268b7138ae43" translate="yes" xml:space="preserve">
          <source>Get atomic access to a &lt;code&gt;&amp;amp;mut u16&lt;/code&gt;.</source>
          <target state="translated">获得对 &lt;code&gt;&amp;amp;mut u16&lt;/code&gt; 的原子访问。</target>
        </trans-unit>
        <trans-unit id="be052f4c09cb9e78d37bcccedbd0ef6b81373d25" translate="yes" xml:space="preserve">
          <source>Get atomic access to a &lt;code&gt;&amp;amp;mut u32&lt;/code&gt;.</source>
          <target state="translated">获得对 &lt;code&gt;&amp;amp;mut u32&lt;/code&gt; 的原子访问。</target>
        </trans-unit>
        <trans-unit id="b64feb94dc70a119380d14818e3261d6eef2ff01" translate="yes" xml:space="preserve">
          <source>Get atomic access to a &lt;code&gt;&amp;amp;mut u64&lt;/code&gt;.</source>
          <target state="translated">获得对 &lt;code&gt;&amp;amp;mut u64&lt;/code&gt; 的原子访问。</target>
        </trans-unit>
        <trans-unit id="93c9e695d154c5f3dd3abe64bcd503125f1a6943" translate="yes" xml:space="preserve">
          <source>Get atomic access to a &lt;code&gt;&amp;amp;mut u8&lt;/code&gt;.</source>
          <target state="translated">获得对 &lt;code&gt;&amp;amp;mut u8&lt;/code&gt; 的原子访问。</target>
        </trans-unit>
        <trans-unit id="1606b3b4a9988dd96e8df625d37ad2f352009b53" translate="yes" xml:space="preserve">
          <source>Get atomic access to a &lt;code&gt;&amp;amp;mut usize&lt;/code&gt;.</source>
          <target state="translated">获得对 &lt;code&gt;&amp;amp;mut usize&lt;/code&gt; 的原子访问。</target>
        </trans-unit>
        <trans-unit id="f6d022441dfa4197ede9226c6cd05c31e113bcb1" translate="yes" xml:space="preserve">
          <source>Get atomic access to a pointer.</source>
          <target state="translated">获取对指针的原子访问。</target>
        </trans-unit>
        <trans-unit id="03047b085ab60076b8b26738a1a62365d995e574" translate="yes" xml:space="preserve">
          <source>Get the current GID.</source>
          <target state="translated">获取当前的GID。</target>
        </trans-unit>
        <trans-unit id="8945f7a266eefc6bf07f2239fdd9c0dc33d3e224" translate="yes" xml:space="preserve">
          <source>Get the current PID.</source>
          <target state="translated">获取当前的PID。</target>
        </trans-unit>
        <trans-unit id="dd153c60f59c83db40eeb94de7076e0f98b38c04" translate="yes" xml:space="preserve">
          <source>Get the current UID.</source>
          <target state="translated">获取当前UID。</target>
        </trans-unit>
        <trans-unit id="64dd863243ce484b66cb85ade55ee85842813c0e" translate="yes" xml:space="preserve">
          <source>Get the current value of the socket for passing unix credentials in &lt;a href=&quot;struct.socketancillary&quot;&gt;&lt;code&gt;SocketAncillary&lt;/code&gt;&lt;/a&gt;. This value can be change by &lt;a href=&quot;struct.unixdatagram#method.set_passcred&quot;&gt;&lt;code&gt;set_passcred&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">获取用于在&lt;a href=&quot;struct.socketancillary&quot;&gt; &lt;code&gt;SocketAncillary&lt;/code&gt; 中&lt;/a&gt;传递UNIX凭据的套接字的当前值。可以通过&lt;a href=&quot;struct.unixdatagram#method.set_passcred&quot;&gt; &lt;code&gt;set_passcred&lt;/code&gt; &lt;/a&gt;更改此值。</target>
        </trans-unit>
        <trans-unit id="077ec7a9f176dd6038264d0f5906cfb8e051373a" translate="yes" xml:space="preserve">
          <source>Get the current value of the socket for passing unix credentials in &lt;a href=&quot;struct.socketancillary&quot;&gt;&lt;code&gt;SocketAncillary&lt;/code&gt;&lt;/a&gt;. This value can be change by &lt;a href=&quot;struct.unixstream#method.set_passcred&quot;&gt;&lt;code&gt;set_passcred&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">获取用于在&lt;a href=&quot;struct.socketancillary&quot;&gt; &lt;code&gt;SocketAncillary&lt;/code&gt; 中&lt;/a&gt;传递UNIX凭据的套接字的当前值。可以通过&lt;a href=&quot;struct.unixstream#method.set_passcred&quot;&gt; &lt;code&gt;set_passcred&lt;/code&gt; &lt;/a&gt;更改此值。</target>
        </trans-unit>
        <trans-unit id="cf81408f02d917373b6c30a23d98790dc9a5d471" translate="yes" xml:space="preserve">
          <source>Get the formatted string, if it has no arguments to be formatted.</source>
          <target state="translated">获取格式化的字符串,如果没有参数要格式化。</target>
        </trans-unit>
        <trans-unit id="b172d14fff389b8c0c1fba16e9b5b4943c2e280c" translate="yes" xml:space="preserve">
          <source>Get the socket option &lt;code&gt;SO_PASSCRED&lt;/code&gt;.</source>
          <target state="translated">获取套接字选项 &lt;code&gt;SO_PASSCRED&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a5cd7c90099ca5a967101e4cfad667e3decbf3d" translate="yes" xml:space="preserve">
          <source>Gets a handle to the thread that invokes it.</source>
          <target state="translated">获取调用它的线程的句柄。</target>
        </trans-unit>
        <trans-unit id="76d4e2388fe5518e4d670520e3733f09619ee790" translate="yes" xml:space="preserve">
          <source>Gets a mutable (unique) reference to the contained value.</source>
          <target state="translated">获取对包含值的一个可变的(唯一的)引用。</target>
        </trans-unit>
        <trans-unit id="d82a8f0547b098b3e15a8465f846472c994e131e" translate="yes" xml:space="preserve">
          <source>Gets a mutable iterator over the entries of the map, sorted by key.</source>
          <target state="translated">获取一个按键排序的地图条目的可变迭器。</target>
        </trans-unit>
        <trans-unit id="1ac6a489d416bd5c5ef9fe3e6c54e36610970d42" translate="yes" xml:space="preserve">
          <source>Gets a mutable iterator over the values of the map, in order by key.</source>
          <target state="translated">获取映射值的可变迭器,按键的顺序排列。</target>
        </trans-unit>
        <trans-unit id="c387218a90a9bb1918a7924816b86e529b82f080" translate="yes" xml:space="preserve">
          <source>Gets a mutable pointer to the contained value. Reading from this pointer or turning it into a reference is undefined behavior unless the &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; is initialized.</source>
          <target state="translated">获取指向包含值的可变指针。除非初始化 &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 否则从该指针读取或将其转换为引用是未定义的行为。</target>
        </trans-unit>
        <trans-unit id="b569ba746c83e8a3f0560e8c5640e4d7d0cf471a" translate="yes" xml:space="preserve">
          <source>Gets a mutable pointer to the first element of the array.</source>
          <target state="translated">获取一个指向数组中第一个元素的可变指针。</target>
        </trans-unit>
        <trans-unit id="93221faf609cb53b66eed583ddd8ff4650ad1090" translate="yes" xml:space="preserve">
          <source>Gets a mutable pointer to the wrapped value.</source>
          <target state="translated">获取一个指向封装值的可变指针。</target>
        </trans-unit>
        <trans-unit id="1afb8b1fa7a141c132899f91a60cb50d53c480a9" translate="yes" xml:space="preserve">
          <source>Gets a mutable pointer to the wrapped value. The difference to &lt;a href=&quot;#method.get&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; is that this function accepts a raw pointer, which is useful to avoid the creation of temporary references.</source>
          <target state="translated">获取指向包装值的可变指针。&lt;a href=&quot;#method.get&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt;的区别是此函数接受原始指针，这对于避免创建临时引用很有用。</target>
        </trans-unit>
        <trans-unit id="1c86d9d548b33fa9b1e8333a56862606cf9f996b" translate="yes" xml:space="preserve">
          <source>Gets a mutable pointer to the wrapped value. The difference to &lt;a href=&quot;struct.unsafecell#method.get&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; is that this function accepts a raw pointer, which is useful to avoid the creation of temporary references.</source>
          <target state="translated">获取指向包装值的可变指针。&lt;a href=&quot;struct.unsafecell#method.get&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt;的区别是此函数接受原始指针，这对于避免创建临时引用很有用。</target>
        </trans-unit>
        <trans-unit id="6d7b2240ef54c761d6faa307793ba693f884b564" translate="yes" xml:space="preserve">
          <source>Gets a mutable reference to the contained value.</source>
          <target state="translated">获取对包含的值的可变引用。</target>
        </trans-unit>
        <trans-unit id="baa6d6ef07f8226c5636c761217972d8dab55984" translate="yes" xml:space="preserve">
          <source>Gets a mutable reference to the data inside of this &lt;code&gt;Pin&lt;/code&gt;.</source>
          <target state="translated">获取对此 &lt;code&gt;Pin&lt;/code&gt; 内部数据的可变引用。</target>
        </trans-unit>
        <trans-unit id="be59995f2e9c7b5e3f2085e347793a76d09f5142" translate="yes" xml:space="preserve">
          <source>Gets a mutable reference to the key and value in the entry.</source>
          <target state="translated">获取条目中键和值的可变引用。</target>
        </trans-unit>
        <trans-unit id="392a07775c4cbc76c6f5c44ba9a3213fc2da81fd" translate="yes" xml:space="preserve">
          <source>Gets a mutable reference to the key in the entry.</source>
          <target state="translated">获取条目中键的可变引用。</target>
        </trans-unit>
        <trans-unit id="5011a90347126d03d01127126a86107c5208ff3e" translate="yes" xml:space="preserve">
          <source>Gets a mutable reference to the underlying reader.</source>
          <target state="translated">获取对底层读者的可变更引用。</target>
        </trans-unit>
        <trans-unit id="f2e7f5b6ab637a03072f9c7e9b6f73027700454e" translate="yes" xml:space="preserve">
          <source>Gets a mutable reference to the underlying value in this cursor.</source>
          <target state="translated">获取对该游标底层值的可变引用。</target>
        </trans-unit>
        <trans-unit id="dec4b0e863c4ca94f197dad1d6d087c7c4489b09" translate="yes" xml:space="preserve">
          <source>Gets a mutable reference to the underlying writer.</source>
          <target state="translated">获取对底层写作者的可变引用。</target>
        </trans-unit>
        <trans-unit id="46ecc0b581f4368e77b78de6bcf33878428bee2b" translate="yes" xml:space="preserve">
          <source>Gets a mutable reference to the value in the entry.</source>
          <target state="translated">获取对条目中的值的可变引用。</target>
        </trans-unit>
        <trans-unit id="325584547464337b8a139f4e032f2c9235b63738" translate="yes" xml:space="preserve">
          <source>Gets a pinned mutable reference from this pinned pointer.</source>
          <target state="translated">从这个被钉住的指针中获取一个被钉住的可变引用。</target>
        </trans-unit>
        <trans-unit id="b99a2e7f3dd3f0850a631d924a0f85ceb5ab793c" translate="yes" xml:space="preserve">
          <source>Gets a pinned shared reference from this pinned pointer.</source>
          <target state="translated">从这个钉住的指针中获取一个钉住的共享引用。</target>
        </trans-unit>
        <trans-unit id="4518638a3643d66963581854e8f287c3740674d7" translate="yes" xml:space="preserve">
          <source>Gets a pointer to the contained value. Reading from this pointer or turning it into a reference is undefined behavior unless the &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; is initialized. Writing to memory that this pointer (non-transitively) points to is undefined behavior (except inside an &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">获取指向包含值的指针。除非初始化 &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 否则从该指针读取或将其转换为引用是未定义的行为。写入此指针（非传递性地）指向的内存是未定义的行为（ &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 内部除外）。</target>
        </trans-unit>
        <trans-unit id="df26339f7815b59c7db8559b2dc091cf260e6a95" translate="yes" xml:space="preserve">
          <source>Gets a pointer to the first element of the array.</source>
          <target state="translated">获取一个指向数组中第一个元素的指针。</target>
        </trans-unit>
        <trans-unit id="51fc3b713ce675163511b6b7c0001b3242a0e070" translate="yes" xml:space="preserve">
          <source>Gets a reference to a static &lt;code&gt;Location&lt;/code&gt; indicating where it was called.</source>
          <target state="translated">获取对一个静态 &lt;code&gt;Location&lt;/code&gt; 的引用，该引用指示在何处调用它。</target>
        </trans-unit>
        <trans-unit id="de0b41d5362a52c7e2047db8d30137b1ccf260d5" translate="yes" xml:space="preserve">
          <source>Gets a reference to the contained value.</source>
          <target state="translated">获取对包含值的引用。</target>
        </trans-unit>
        <trans-unit id="cff65263d72903c422d0a7597523c0375366ab3b" translate="yes" xml:space="preserve">
          <source>Gets a reference to the key and value in the entry.</source>
          <target state="translated">获取对条目中的键和值的引用。</target>
        </trans-unit>
        <trans-unit id="a73b6b64fba7c9a4c0709973dbffd936a0e9fbd2" translate="yes" xml:space="preserve">
          <source>Gets a reference to the key in the entry.</source>
          <target state="translated">获取条目中钥匙的引用。</target>
        </trans-unit>
        <trans-unit id="feddda07d6595d79eeaf54c555c5ae797d32fafa" translate="yes" xml:space="preserve">
          <source>Gets a reference to the key that would be used when inserting a value through the &lt;code&gt;VacantEntry&lt;/code&gt;.</source>
          <target state="translated">获取对通过 &lt;code&gt;VacantEntry&lt;/code&gt; 插入值时将使用的键的引用。</target>
        </trans-unit>
        <trans-unit id="7ec6e3eeb0b6ad5023996187968d591cae5085ca" translate="yes" xml:space="preserve">
          <source>Gets a reference to the key that would be used when inserting a value through the VacantEntry.</source>
          <target state="translated">获取通过VacantEntry插入一个值时使用的键的引用。</target>
        </trans-unit>
        <trans-unit id="cf505aa88d1d27b7fd7210fea3eb5f424893e421" translate="yes" xml:space="preserve">
          <source>Gets a reference to the underlying reader.</source>
          <target state="translated">获取对底层读者的引用。</target>
        </trans-unit>
        <trans-unit id="bcf7058743e55a29769e9f52c6d7eb995745282c" translate="yes" xml:space="preserve">
          <source>Gets a reference to the underlying value in this cursor.</source>
          <target state="translated">获取这个游标的基础值的引用。</target>
        </trans-unit>
        <trans-unit id="cb7cc9508e37a0159bd3a7b3b0845509f330a592" translate="yes" xml:space="preserve">
          <source>Gets a reference to the underlying writer.</source>
          <target state="translated">获取对底层作者的引用。</target>
        </trans-unit>
        <trans-unit id="a9eb138b06bc622e04583407ce48c73c001c324e" translate="yes" xml:space="preserve">
          <source>Gets a reference to the value in the entry.</source>
          <target state="translated">获取对条目中数值的引用。</target>
        </trans-unit>
        <trans-unit id="bf39c650c88ad522e7aa25fef3aa0cf8f15445c4" translate="yes" xml:space="preserve">
          <source>Gets a shared reference out of a pin.</source>
          <target state="translated">从引脚中获取一个共享引用。</target>
        </trans-unit>
        <trans-unit id="c8d67ec62dc724790a39413d95104cb2f25712dc" translate="yes" xml:space="preserve">
          <source>Gets a shared reference to the contained value.</source>
          <target state="translated">获取对包含值的共享引用。</target>
        </trans-unit>
        <trans-unit id="7979bb5a2e24a20633426914599d65cc13e380ce" translate="yes" xml:space="preserve">
          <source>Gets a static string slice containing the name of a type.</source>
          <target state="translated">获取一个包含类型名称的静态字符串片断。</target>
        </trans-unit>
        <trans-unit id="a1f0dbc00515171edea6468d519fe0276ba8e73e" translate="yes" xml:space="preserve">
          <source>Gets an approximation of the number of &lt;code&gt;Weak&lt;/code&gt; pointers pointing to this allocation.</source>
          <target state="translated">获取指向该分配的 &lt;code&gt;Weak&lt;/code&gt; 指针数量的近似值。</target>
        </trans-unit>
        <trans-unit id="fe0c54b937e7b93e8f39dc4887850e732a02eae2" translate="yes" xml:space="preserve">
          <source>Gets an approximation of the number of &lt;code&gt;Weak&lt;/code&gt; pointers pointing to this value.</source>
          <target state="translated">获取指向该值的 &lt;code&gt;Weak&lt;/code&gt; 指针数量的近似值。</target>
        </trans-unit>
        <trans-unit id="234ebcadb6ac6bb0def6ad4173e0e189daeb1439" translate="yes" xml:space="preserve">
          <source>Gets an identifier which is globally unique to the specified type. This function will return the same value for a type regardless of whichever crate it is invoked in.</source>
          <target state="translated">获取指定类型的全局唯一标识符。无论在哪个箱子中调用,这个函数都会返回相同的值。</target>
        </trans-unit>
        <trans-unit id="77e393eb1ab1f3573f4cc8c8d9a6214bd3e5808e" translate="yes" xml:space="preserve">
          <source>Gets an iterator for moving out the &lt;code&gt;BTreeSet&lt;/code&gt;'s contents.</source>
          <target state="translated">获取用于移出 &lt;code&gt;BTreeSet&lt;/code&gt; 的内容的迭代器。</target>
        </trans-unit>
        <trans-unit id="11b43ebc9818fa3526a8e800dba2a829340904c9" translate="yes" xml:space="preserve">
          <source>Gets an iterator over the entries of the map, sorted by key.</source>
          <target state="translated">获取地图中按键排序的迭代器。</target>
        </trans-unit>
        <trans-unit id="4282f4ebb370a2d3e37842bf8bea7691a93cc17f" translate="yes" xml:space="preserve">
          <source>Gets an iterator over the keys of the map, in sorted order.</source>
          <target state="translated">获取地图中键的迭代器,按顺序排列。</target>
        </trans-unit>
        <trans-unit id="88cd2b443e0410f773c3db3b4b02c30273a29587" translate="yes" xml:space="preserve">
          <source>Gets an iterator over the values of the map, in order by key.</source>
          <target state="translated">获取一个迭代器,按照键的顺序遍历map的值。</target>
        </trans-unit>
        <trans-unit id="f7d58dcf7a90c88a6dd8d8e2a936de88caad9b01" translate="yes" xml:space="preserve">
          <source>Gets an iterator that visits the values in the &lt;code&gt;BTreeSet&lt;/code&gt; in ascending order.</source>
          <target state="translated">获取一个迭代器，该迭代器以升序访问 &lt;code&gt;BTreeSet&lt;/code&gt; 中的值。</target>
        </trans-unit>
        <trans-unit id="bf50547bde43305eadfc81da6c51963036f0b0bc" translate="yes" xml:space="preserve">
          <source>Gets mutable references to the underlying readers in this &lt;code&gt;Chain&lt;/code&gt;.</source>
          <target state="translated">获取对该 &lt;code&gt;Chain&lt;/code&gt; 中基础读者的可变引用。</target>
        </trans-unit>
        <trans-unit id="c5d75c4c07b578c3182dd1391a22f0515f568828" translate="yes" xml:space="preserve">
          <source>Gets references to the underlying readers in this &lt;code&gt;Chain&lt;/code&gt;.</source>
          <target state="translated">获取此 &lt;code&gt;Chain&lt;/code&gt; 中基础读者的引用。</target>
        </trans-unit>
        <trans-unit id="4099d19a8a1a54e1ad72f73ecdd2402a0b7a3136" translate="yes" xml:space="preserve">
          <source>Gets the &lt;code&gt;TypeId&lt;/code&gt; of &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">获取 &lt;code&gt;TypeId&lt;/code&gt; 的 &lt;code&gt;self&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="41602bda251eaed54ccea25679c0483e128331bf" translate="yes" xml:space="preserve">
          <source>Gets the &lt;code&gt;TypeId&lt;/code&gt; of &lt;code&gt;self&lt;/code&gt;. &lt;a href=&quot;../../../any/trait.any#tymethod.type_id&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">获取 &lt;code&gt;TypeId&lt;/code&gt; 的 &lt;code&gt;self&lt;/code&gt; 。&lt;a href=&quot;../../../any/trait.any#tymethod.type_id&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7397491fe536b6ab323bc3962fba8e1fb15e1948" translate="yes" xml:space="preserve">
          <source>Gets the &lt;code&gt;TypeId&lt;/code&gt; of &lt;code&gt;self&lt;/code&gt;. &lt;a href=&quot;../../any/trait.any#tymethod.type_id&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">获取 &lt;code&gt;TypeId&lt;/code&gt; 的 &lt;code&gt;self&lt;/code&gt; 。&lt;a href=&quot;../../any/trait.any#tymethod.type_id&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d0958a5367c67c57557138ce54a3c5f59d233668" translate="yes" xml:space="preserve">
          <source>Gets the &lt;code&gt;TypeId&lt;/code&gt; of &lt;code&gt;self&lt;/code&gt;. &lt;a href=&quot;../any/trait.any#tymethod.type_id&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">获取 &lt;code&gt;TypeId&lt;/code&gt; 的 &lt;code&gt;self&lt;/code&gt; 。&lt;a href=&quot;../any/trait.any#tymethod.type_id&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e0dc7f61a814ccb0f4c7bc6d983b16e56f33b8b7" translate="yes" xml:space="preserve">
          <source>Gets the &lt;code&gt;TypeId&lt;/code&gt; of &lt;code&gt;self&lt;/code&gt;. &lt;a href=&quot;any/trait.any#tymethod.type_id&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">获取 &lt;code&gt;TypeId&lt;/code&gt; 的 &lt;code&gt;self&lt;/code&gt; 。&lt;a href=&quot;any/trait.any#tymethod.type_id&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d6053452902f00975747e0db67cb9da5bcc78254" translate="yes" xml:space="preserve">
          <source>Gets the &lt;code&gt;TypeId&lt;/code&gt; of &lt;code&gt;self&lt;/code&gt;. &lt;a href=&quot;trait.any#tymethod.type_id&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">获取 &lt;code&gt;TypeId&lt;/code&gt; 的 &lt;code&gt;self&lt;/code&gt; 。&lt;a href=&quot;trait.any#tymethod.type_id&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d07cea866f98bd65675b9dd23738ccd196ac1cc2" translate="yes" xml:space="preserve">
          <source>Gets the contents of the cell, initializing it with &lt;code&gt;f&lt;/code&gt; if the cell was empty.</source>
          <target state="translated">获取单元格的内容，如果单元格为空，则使用 &lt;code&gt;f&lt;/code&gt; 对其进行初始化。</target>
        </trans-unit>
        <trans-unit id="9ab174bccc0a148e51be9702f79ce415dcabcb9d" translate="yes" xml:space="preserve">
          <source>Gets the contents of the cell, initializing it with &lt;code&gt;f&lt;/code&gt; if the cell was empty. If the cell was empty and &lt;code&gt;f&lt;/code&gt; failed, an error is returned.</source>
          <target state="translated">获取单元格的内容，如果单元格为空，则使用 &lt;code&gt;f&lt;/code&gt; 对其进行初始化。如果单元为空且 &lt;code&gt;f&lt;/code&gt; 失败，则返回错误。</target>
        </trans-unit>
        <trans-unit id="c3d8aeac371c3726d0823d3e47870ae432d791d1" translate="yes" xml:space="preserve">
          <source>Gets the entire contents of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; as an array, if its size exactly matches that of the requested array.</source>
          <target state="translated">如果 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 的大小与请求的数组的大小完全匹配，则以数组的形式获取Vec &amp;lt;T&amp;gt;的全部内容。</target>
        </trans-unit>
        <trans-unit id="cfed0516ca0cceacbef295ac249aa061f2675ee1" translate="yes" xml:space="preserve">
          <source>Gets the given key's corresponding entry in the map for in-place manipulation.</source>
          <target state="translated">获取给定的键在地图中的对应条目,进行原地操作。</target>
        </trans-unit>
        <trans-unit id="a6710692fb74181ac5da470b1ed946b91a9cf3b9" translate="yes" xml:space="preserve">
          <source>Gets the mutable reference to the underlying value.</source>
          <target state="translated">获取对底层值的可变引用。</target>
        </trans-unit>
        <trans-unit id="4c299d04fef3ac60e871ddceb7fed1d58a4373a4" translate="yes" xml:space="preserve">
          <source>Gets the number of &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to this allocation.</source>
          <target state="translated">获取此分配的&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;指针的数量。</target>
        </trans-unit>
        <trans-unit id="82785258c5148ac429e819aa10802824ac7d2a46" translate="yes" xml:space="preserve">
          <source>Gets the number of &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to this value.</source>
          <target state="translated">获取指向该值的&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;指针的数量。</target>
        </trans-unit>
        <trans-unit id="ea2a4acdf77bc69347663f277f505d5ad15cc026" translate="yes" xml:space="preserve">
          <source>Gets the number of &lt;code&gt;Weak&lt;/code&gt; pointers pointing to this allocation.</source>
          <target state="translated">获取指向该分配的 &lt;code&gt;Weak&lt;/code&gt; 指针的数量。</target>
        </trans-unit>
        <trans-unit id="2d6bb90de6f3314e5b0aa7676e3fa2574049a5b1" translate="yes" xml:space="preserve">
          <source>Gets the number of &lt;code&gt;Weak&lt;/code&gt; pointers pointing to this value.</source>
          <target state="translated">获取指向该值的 &lt;code&gt;Weak&lt;/code&gt; 指针的数量。</target>
        </trans-unit>
        <trans-unit id="266325732ccd237fd7f26bfdb76bb89eb62a4114" translate="yes" xml:space="preserve">
          <source>Gets the number of strong (&lt;code&gt;Arc&lt;/code&gt;) pointers pointing to this allocation.</source>
          <target state="translated">获取指向此分配的强（ &lt;code&gt;Arc&lt;/code&gt; ）指针的数量。</target>
        </trans-unit>
        <trans-unit id="55f33a15ae6da7b8fd099c7f81c55a8c43992a9c" translate="yes" xml:space="preserve">
          <source>Gets the number of strong (&lt;code&gt;Arc&lt;/code&gt;) pointers pointing to this value.</source>
          <target state="translated">获取指向此值的强（ &lt;code&gt;Arc&lt;/code&gt; ）指针的数量。</target>
        </trans-unit>
        <trans-unit id="acc981beee8d18e67fc3a5059aa645efdb5cb013" translate="yes" xml:space="preserve">
          <source>Gets the number of strong (&lt;code&gt;Arc&lt;/code&gt;) pointers to this allocation.</source>
          <target state="translated">获取此分配的强（ &lt;code&gt;Arc&lt;/code&gt; ）指针的数量。</target>
        </trans-unit>
        <trans-unit id="8c9d8a68862d17ae50fe9b2191b4bc755a3b2c57" translate="yes" xml:space="preserve">
          <source>Gets the number of strong (&lt;code&gt;Arc&lt;/code&gt;) pointers to this value.</source>
          <target state="translated">获取指向此值的强（ &lt;code&gt;Arc&lt;/code&gt; ）指针的数量。</target>
        </trans-unit>
        <trans-unit id="86df16ff86121c6f4046474b56b37a148e7c840c" translate="yes" xml:space="preserve">
          <source>Gets the number of strong (&lt;code&gt;Rc&lt;/code&gt;) pointers pointing to this allocation.</source>
          <target state="translated">获取指向此分配的强（ &lt;code&gt;Rc&lt;/code&gt; ）指针的数量。</target>
        </trans-unit>
        <trans-unit id="6dfd6b399c6a7a5e5c213f4220d6a406180d8d29" translate="yes" xml:space="preserve">
          <source>Gets the number of strong (&lt;code&gt;Rc&lt;/code&gt;) pointers pointing to this value.</source>
          <target state="translated">获取指向此值的强（ &lt;code&gt;Rc&lt;/code&gt; ）指针的数量。</target>
        </trans-unit>
        <trans-unit id="86da648c891a7c42ebdf312b33a4ab9ada05ef68" translate="yes" xml:space="preserve">
          <source>Gets the number of strong (&lt;code&gt;Rc&lt;/code&gt;) pointers to this allocation.</source>
          <target state="translated">获取指向此分配的强（ &lt;code&gt;Rc&lt;/code&gt; ）指针的数量。</target>
        </trans-unit>
        <trans-unit id="62256e04434cb17270e60d73bd90064ac287c70a" translate="yes" xml:space="preserve">
          <source>Gets the number of strong (&lt;code&gt;Rc&lt;/code&gt;) pointers to this value.</source>
          <target state="translated">获取指向此值的强（ &lt;code&gt;Rc&lt;/code&gt; ）指针的数量。</target>
        </trans-unit>
        <trans-unit id="7b980936990012ea161b866d1758615b20bb0b9e" translate="yes" xml:space="preserve">
          <source>Gets the peer credentials for this Unix domain socket.</source>
          <target state="translated">获取此Unix域套接字的对等体凭证。</target>
        </trans-unit>
        <trans-unit id="a3996e0805427dc73c97f253744be6821d4757b9" translate="yes" xml:space="preserve">
          <source>Gets the reference to the underlying value.</source>
          <target state="translated">获取对基础值的引用。</target>
        </trans-unit>
        <trans-unit id="9a803af3c996a7aeaae26131be70879a8de1e8ca" translate="yes" xml:space="preserve">
          <source>Gets the thread's name.</source>
          <target state="translated">获取线程的名称。</target>
        </trans-unit>
        <trans-unit id="49ee03c4c760e66b9e940fbfa2d32f04a888601b" translate="yes" xml:space="preserve">
          <source>Gets the thread's unique identifier.</source>
          <target state="translated">获取线程的唯一标识符。</target>
        </trans-unit>
        <trans-unit id="e80f24c5e15d0db75eb52ca4f146d8328ad163c8" translate="yes" xml:space="preserve">
          <source>Gets the underlying byte view of the &lt;a href=&quot;../../../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; slice.</source>
          <target state="translated">获取&lt;a href=&quot;../../../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt;切片的基础字节视图。</target>
        </trans-unit>
        <trans-unit id="7d3e5946e7ecbe9a325741ceead9ec7679286f06" translate="yes" xml:space="preserve">
          <source>Gets the underlying byte view of the &lt;a href=&quot;struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; slice. &lt;a href=&quot;../os/unix/ffi/trait.osstrext#tymethod.as_bytes&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">获取&lt;a href=&quot;struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt;切片的基础字节视图。&lt;a href=&quot;../os/unix/ffi/trait.osstrext#tymethod.as_bytes&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6ce976fab972b71cb3689e58f2c81f4c1b2c23c3" translate="yes" xml:space="preserve">
          <source>Gets the underlying byte view of the [&lt;code&gt;OsStr&lt;/code&gt;] slice. &lt;a href=&quot;../os/unix/ffi/trait.osstrext#tymethod.as_bytes&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">获取[ &lt;code&gt;OsStr&lt;/code&gt; ] slice 的基础字节视图。&lt;a href=&quot;../os/unix/ffi/trait.osstrext#tymethod.as_bytes&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b70bb73da43a0dacb273f9c29de1ad90c047f9b2" translate="yes" xml:space="preserve">
          <source>Gets the value of the &lt;code&gt;IPV6_MULTICAST_LOOP&lt;/code&gt; option for this socket.</source>
          <target state="translated">获取此套接字的 &lt;code&gt;IPV6_MULTICAST_LOOP&lt;/code&gt; 选项的值。</target>
        </trans-unit>
        <trans-unit id="541e09715c0e448d9ee0ceae38a6c62a42e062e7" translate="yes" xml:space="preserve">
          <source>Gets the value of the &lt;code&gt;IP_MULTICAST_LOOP&lt;/code&gt; option for this socket.</source>
          <target state="translated">获取此套接字的 &lt;code&gt;IP_MULTICAST_LOOP&lt;/code&gt; 选项的值。</target>
        </trans-unit>
        <trans-unit id="ee99abd672fa0bc29c2f53bc51cd2022f7fe6174" translate="yes" xml:space="preserve">
          <source>Gets the value of the &lt;code&gt;IP_MULTICAST_TTL&lt;/code&gt; option for this socket.</source>
          <target state="translated">获取此套接字的 &lt;code&gt;IP_MULTICAST_TTL&lt;/code&gt; 选项的值。</target>
        </trans-unit>
        <trans-unit id="ca264fa81bb9d68241254fa46d7aa2c2cda498bc" translate="yes" xml:space="preserve">
          <source>Gets the value of the &lt;code&gt;IP_TTL&lt;/code&gt; option for this socket.</source>
          <target state="translated">获取此套接字的 &lt;code&gt;IP_TTL&lt;/code&gt; 选项的值。</target>
        </trans-unit>
        <trans-unit id="081675c2121b5c0eba69352ff7f20ab17e65e3d1" translate="yes" xml:space="preserve">
          <source>Gets the value of the &lt;code&gt;SO_BROADCAST&lt;/code&gt; option for this socket.</source>
          <target state="translated">获取此套接字的 &lt;code&gt;SO_BROADCAST&lt;/code&gt; 选项的值。</target>
        </trans-unit>
        <trans-unit id="0f6a73f5b7aaab6427c36574dc2e96dbd9e394ff" translate="yes" xml:space="preserve">
          <source>Gets the value of the &lt;code&gt;SO_ERROR&lt;/code&gt; option on this socket.</source>
          <target state="translated">获取此套接字上的 &lt;code&gt;SO_ERROR&lt;/code&gt; 选项的值。</target>
        </trans-unit>
        <trans-unit id="fd9694065ed8ce77dc78229e63dba85fa8ab43e4" translate="yes" xml:space="preserve">
          <source>Gets the value of the &lt;code&gt;TCP_NODELAY&lt;/code&gt; option on this socket.</source>
          <target state="translated">获取此套接字上的 &lt;code&gt;TCP_NODELAY&lt;/code&gt; 选项的值。</target>
        </trans-unit>
        <trans-unit id="a351f54361bf1111912e96b2243de3d3ba2e710e" translate="yes" xml:space="preserve">
          <source>Getter for the underlying string to be searched in</source>
          <target state="translated">要搜索的底层字符串的获取器。</target>
        </trans-unit>
        <trans-unit id="946249472d59c612c049bc459ef794710e06ea0f" translate="yes" xml:space="preserve">
          <source>Getter for the underlying string to be searched in &lt;a href=&quot;trait.searcher#tymethod.haystack&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">在要搜索getter方法基础字符串&lt;a href=&quot;trait.searcher#tymethod.haystack&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">入门</target>
        </trans-unit>
        <trans-unit id="5995d36c171cb98f5012509471c6af75ae9b7b83" translate="yes" xml:space="preserve">
          <source>Getting a handle to the current thread with &lt;code&gt;thread::current()&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;thread::current()&lt;/code&gt; 获取当前线程的句柄：</target>
        </trans-unit>
        <trans-unit id="18ecec4eaf70488e9516f42f4c700b0d3f3801c9" translate="yes" xml:space="preserve">
          <source>Getting grapheme clusters from strings is complex, so this functionality is not provided by the standard library. Crates are available on &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; if this is the functionality you need.</source>
          <target state="translated">从字符串获取字素簇很复杂，因此标准库不提供此功能。如果您需要此功能，则可在&lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;上使用板条箱。</target>
        </trans-unit>
        <trans-unit id="40b8f0b0dd8c757df38c0efb486cc65a37413fd0" translate="yes" xml:space="preserve">
          <source>Getting immutable access to the contiguous slice.</source>
          <target state="translated">获得对毗连片的不可更改的访问。</target>
        </trans-unit>
        <trans-unit id="6ce1a3d0561d101c4db29f248d240d379840a525" translate="yes" xml:space="preserve">
          <source>Give it text interactively by running the executable directly, in which case it will wait for the Enter key to be pressed before continuing</source>
          <target state="translated">通过直接运行可执行文件给它交互式的文本,在这种情况下,它将等待按下回车键后再继续运行。</target>
        </trans-unit>
        <trans-unit id="81432d4fe569ad1c70c83fd457057f8aff028c0e" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;impl&amp;lt;P1..=Pn&amp;gt; Trait&amp;lt;T1..=Tn&amp;gt; for T0&lt;/code&gt;, an &lt;code&gt;impl&lt;/code&gt; is valid only if at least one of the following is true:</source>
          <target state="translated">给定 &lt;code&gt;impl&amp;lt;P1..=Pn&amp;gt; Trait&amp;lt;T1..=Tn&amp;gt; for T0&lt;/code&gt; ，仅当以下至少一项为true时， &lt;code&gt;impl&lt;/code&gt; 才有效：</target>
        </trans-unit>
        <trans-unit id="2c541ca5b28906f0b0b887376717739a6ff63fa9" translate="yes" xml:space="preserve">
          <source>Given a function, or closure, there are drop scopes for:</source>
          <target state="translated">给定一个函数,或闭合,有下降范围为。</target>
        </trans-unit>
        <trans-unit id="460459e684630e18d67dce5af60c9aa1a9d7fe48" translate="yes" xml:space="preserve">
          <source>Given a list of integers, use a vector and return the mean (the average value), median (when sorted, the value in the middle position), and mode (the value that occurs most often; a hash map will be helpful here) of the list.</source>
          <target state="translated">给定一个整数列表,使用一个向量,并返回列表的平均值(平均值)、中位数(排序时,中间位置的值)和模式(出现频率最高的值;这里的哈希图会有帮助)。</target>
        </trans-unit>
        <trans-unit id="ea3d2794af8f5c0a103590ed2dfa3cbed7263acb" translate="yes" xml:space="preserve">
          <source>Given a path, query the file system to get information about a file, directory, etc.</source>
          <target state="translated">给定一个路径,查询文件系统以获取文件、目录等信息。</target>
        </trans-unit>
        <trans-unit id="caef16517cee4d24248fc21d836a1a72f7d7936b" translate="yes" xml:space="preserve">
          <source>Given an element the closure must return &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. The returned iterator will yield only the elements for which the closure returns true.</source>
          <target state="translated">给定一个元素，闭包必须返回 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 。返回的迭代器将仅产生闭包为其返回true的元素。</target>
        </trans-unit>
        <trans-unit id="30386826e248fa1c007d69f26e43a06ce7da9de9" translate="yes" xml:space="preserve">
          <source>Given that a &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; will call &lt;code&gt;drop&lt;/code&gt; as it unwinds, any &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; in a &lt;code&gt;drop&lt;/code&gt; implementation will likely abort.</source>
          <target state="translated">鉴于&lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;放松时会叫 &lt;code&gt;drop&lt;/code&gt; ，任何&lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;在 &lt;code&gt;drop&lt;/code&gt; 实现中可能会中止。</target>
        </trans-unit>
        <trans-unit id="6263eb5ed7ee7fa0481696a92c8f43d9efb00e4c" translate="yes" xml:space="preserve">
          <source>Given that a &lt;a href=&quot;https://doc.rust-lang.org/core/macro.panic.html&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; will call &lt;code&gt;drop&lt;/code&gt; as it unwinds, any &lt;a href=&quot;https://doc.rust-lang.org/core/macro.panic.html&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; in a &lt;code&gt;drop&lt;/code&gt; implementation will likely abort.</source>
          <target state="translated">鉴于&lt;a href=&quot;https://doc.rust-lang.org/core/macro.panic.html&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;放松时会叫 &lt;code&gt;drop&lt;/code&gt; ，任何&lt;a href=&quot;https://doc.rust-lang.org/core/macro.panic.html&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;在 &lt;code&gt;drop&lt;/code&gt; 实现中很可能会中止。</target>
        </trans-unit>
        <trans-unit id="e523f1998c41a0b9adf80292e1554bbf7101fb13" translate="yes" xml:space="preserve">
          <source>Given that the &lt;code&gt;String&lt;/code&gt; is empty, this will not allocate any initial buffer. While that means that this initial operation is very inexpensive, it may cause excessive allocation later when you add data. If you have an idea of how much data the &lt;code&gt;String&lt;/code&gt; will hold, consider the &lt;a href=&quot;#method.with_capacity&quot;&gt;&lt;code&gt;with_capacity&lt;/code&gt;&lt;/a&gt; method to prevent excessive re-allocation.</source>
          <target state="translated">假设 &lt;code&gt;String&lt;/code&gt; 为空，则不会分配任何初始缓冲区。虽然这意味着该初始操作非常便宜，但在以后添加数据时可能会导致过多的分配。如果您对 &lt;code&gt;String&lt;/code&gt; 可以容纳多少数据有所了解，请考虑使用&lt;a href=&quot;#method.with_capacity&quot;&gt; &lt;code&gt;with_capacity&lt;/code&gt; &lt;/a&gt;方法来防止过多的重新分配。</target>
        </trans-unit>
        <trans-unit id="a59bf69ea093a125173bce72323495b1305959b6" translate="yes" xml:space="preserve">
          <source>Given that the &lt;code&gt;String&lt;/code&gt; is empty, this will not allocate any initial buffer. While that means that this initial operation is very inexpensive, it may cause excessive allocation later when you add data. If you have an idea of how much data the &lt;code&gt;String&lt;/code&gt; will hold, consider the &lt;a href=&quot;struct.string#method.with_capacity&quot;&gt;&lt;code&gt;with_capacity&lt;/code&gt;&lt;/a&gt; method to prevent excessive re-allocation.</source>
          <target state="translated">假设 &lt;code&gt;String&lt;/code&gt; 为空，则不会分配任何初始缓冲区。虽然这意味着该初始操作非常便宜，但在以后添加数据时可能会导致过多的分配。如果您对 &lt;code&gt;String&lt;/code&gt; 可以容纳多少数据有所了解，请考虑使用&lt;a href=&quot;struct.string#method.with_capacity&quot;&gt; &lt;code&gt;with_capacity&lt;/code&gt; &lt;/a&gt;方法来防止过多的重新分配。</target>
        </trans-unit>
        <trans-unit id="ad539d6fb0976a5b2b95b62832510a1f84220951" translate="yes" xml:space="preserve">
          <source>Given that the smart pointer pattern is a general design pattern used frequently in Rust, this chapter won&amp;rsquo;t cover every existing smart pointer. Many libraries have their own smart pointers, and you can even write your own. We&amp;rsquo;ll cover the most common smart pointers in the standard library:</source>
          <target state="translated">鉴于智能指针模式是Rust中经常使用的通用设计模式，因此本章不会涵盖所有现有的智能指针。许多库都有自己的智能指针，您甚至可以编写自己的指针。我们将介绍标准库中最常见的智能指针：</target>
        </trans-unit>
        <trans-unit id="4a31e9d96bd27c24e6fc00ba6a064634849de284" translate="yes" xml:space="preserve">
          <source>Given that we don't know what type the pointer is, and there's potential ambiguity for some types, we disallow calling methods on raw pointers when the type is unknown.</source>
          <target state="translated">考虑到我们不知道指针是什么类型,而且对某些类型有潜在的歧义,我们不允许在未知类型时调用原始指针上的方法。</target>
        </trans-unit>
        <trans-unit id="5f1184f7df96c5928092ad9c6b550699bf887826" translate="yes" xml:space="preserve">
          <source>Global</source>
          <target state="translated">Global</target>
        </trans-unit>
        <trans-unit id="597030c6c4f56fe393a1ab438473028f6c480a3f" translate="yes" xml:space="preserve">
          <source>Global::alloc</source>
          <target state="translated">Global::alloc</target>
        </trans-unit>
        <trans-unit id="bc8440f1b0fd5e4f27413dbc2c9588f0ac4b35e6" translate="yes" xml:space="preserve">
          <source>Global::alloc_array</source>
          <target state="translated">Global::alloc_array</target>
        </trans-unit>
        <trans-unit id="286809b4d3acafb6b79ba2357ef09d081752bcd8" translate="yes" xml:space="preserve">
          <source>Global::alloc_excess</source>
          <target state="translated">Global::alloc_excess</target>
        </trans-unit>
        <trans-unit id="055e192998c987cc2408347852310a7d777d50b2" translate="yes" xml:space="preserve">
          <source>Global::alloc_one</source>
          <target state="translated">Global::alloc_one</target>
        </trans-unit>
        <trans-unit id="4916367e840ff297f5f655976deb8d56431c82b1" translate="yes" xml:space="preserve">
          <source>Global::alloc_zeroed</source>
          <target state="translated">Global::alloc_zeroed</target>
        </trans-unit>
        <trans-unit id="422dfaa437889aa6a38e0ce319516d4e1aa7ccbe" translate="yes" xml:space="preserve">
          <source>Global::borrow</source>
          <target state="translated">Global::borrow</target>
        </trans-unit>
        <trans-unit id="7a0370da6de58c97a35cfc99cd0bed7729121756" translate="yes" xml:space="preserve">
          <source>Global::borrow_mut</source>
          <target state="translated">Global::borrow_mut</target>
        </trans-unit>
        <trans-unit id="f77b715da0c371e387a1c0cabbb0d1af068041af" translate="yes" xml:space="preserve">
          <source>Global::clone</source>
          <target state="translated">Global::clone</target>
        </trans-unit>
        <trans-unit id="50d4c87192aeed0b09b4440b16be390f6a750a2f" translate="yes" xml:space="preserve">
          <source>Global::clone_from</source>
          <target state="translated">Global::clone_from</target>
        </trans-unit>
        <trans-unit id="9cfb69614980015da407f6e7048f1148f4930023" translate="yes" xml:space="preserve">
          <source>Global::clone_into</source>
          <target state="translated">Global::clone_into</target>
        </trans-unit>
        <trans-unit id="7b2c4b961ebce1561e240a7194da73b5841efb82" translate="yes" xml:space="preserve">
          <source>Global::dealloc</source>
          <target state="translated">Global::dealloc</target>
        </trans-unit>
        <trans-unit id="1a080a708cdd5439e5302ec1934574d59cf90d7d" translate="yes" xml:space="preserve">
          <source>Global::dealloc_array</source>
          <target state="translated">Global::dealloc_array</target>
        </trans-unit>
        <trans-unit id="d428b88cec77fa2bb91fead3f27848981c76580d" translate="yes" xml:space="preserve">
          <source>Global::dealloc_one</source>
          <target state="translated">Global::dealloc_one</target>
        </trans-unit>
        <trans-unit id="995b6ad6ac004f90a18a104ffb9147bf847cb8d1" translate="yes" xml:space="preserve">
          <source>Global::default</source>
          <target state="translated">Global::default</target>
        </trans-unit>
        <trans-unit id="76169c6a841dcf12cff8e0b09058ec8d2b45201d" translate="yes" xml:space="preserve">
          <source>Global::fmt</source>
          <target state="translated">Global::fmt</target>
        </trans-unit>
        <trans-unit id="5c3cece4620e1e6edac7a400fcf912adfe0d27cb" translate="yes" xml:space="preserve">
          <source>Global::from</source>
          <target state="translated">Global::from</target>
        </trans-unit>
        <trans-unit id="a59d2fc290a04b6f0c31c9e50dafd716b2e306ed" translate="yes" xml:space="preserve">
          <source>Global::grow_in_place</source>
          <target state="translated">Global::grow_in_place</target>
        </trans-unit>
        <trans-unit id="25a7d5ad4d365ca4c966f334f3295d6b1ceaaf1d" translate="yes" xml:space="preserve">
          <source>Global::into</source>
          <target state="translated">Global::into</target>
        </trans-unit>
        <trans-unit id="ce7a411799e0b5091e1cb6d261729a98fde69476" translate="yes" xml:space="preserve">
          <source>Global::realloc</source>
          <target state="translated">Global::realloc</target>
        </trans-unit>
        <trans-unit id="55cd704a6f196baec10e6f8fc46f13be6be1a4da" translate="yes" xml:space="preserve">
          <source>Global::realloc_array</source>
          <target state="translated">Global::realloc_array</target>
        </trans-unit>
        <trans-unit id="2dc3bca035c872b5fad904a8f47f338aa69c712d" translate="yes" xml:space="preserve">
          <source>Global::realloc_excess</source>
          <target state="translated">Global::realloc_excess</target>
        </trans-unit>
        <trans-unit id="2eba0652c97a930f2bb92b95f7d1bce1986c871b" translate="yes" xml:space="preserve">
          <source>Global::shrink_in_place</source>
          <target state="translated">Global::shrink_in_place</target>
        </trans-unit>
        <trans-unit id="736720c59f4f431a038c46cc3aa525e5758a39ba" translate="yes" xml:space="preserve">
          <source>Global::to_owned</source>
          <target state="translated">Global::to_owned</target>
        </trans-unit>
        <trans-unit id="8ce6860d43ee49cdb5334bdd351c1035cc8ff38c" translate="yes" xml:space="preserve">
          <source>Global::try_from</source>
          <target state="translated">Global::try_from</target>
        </trans-unit>
        <trans-unit id="617366a681bd521ad66de932f01b46a609e71cb1" translate="yes" xml:space="preserve">
          <source>Global::try_into</source>
          <target state="translated">Global::try_into</target>
        </trans-unit>
        <trans-unit id="a23ee2c26cf33d2d9d02972f8660c76e5304674f" translate="yes" xml:space="preserve">
          <source>Global::type_id</source>
          <target state="translated">Global::type_id</target>
        </trans-unit>
        <trans-unit id="af4b996fed7b58c24cbe5ab00c833b6e42a8a4d4" translate="yes" xml:space="preserve">
          <source>Global::usable_size</source>
          <target state="translated">Global::usable_size</target>
        </trans-unit>
        <trans-unit id="240acfbbf20ecc23d32a755b89f3059599c547b8" translate="yes" xml:space="preserve">
          <source>GlobalAlloc</source>
          <target state="translated">GlobalAlloc</target>
        </trans-unit>
        <trans-unit id="fc670f003f08164e69bb95fb98d8c6ed228f9f51" translate="yes" xml:space="preserve">
          <source>GlobalAlloc::alloc</source>
          <target state="translated">GlobalAlloc::alloc</target>
        </trans-unit>
        <trans-unit id="90c20880262c918bb85b13b512a72e9595a71d28" translate="yes" xml:space="preserve">
          <source>GlobalAlloc::alloc_zeroed</source>
          <target state="translated">GlobalAlloc::alloc_zeroed</target>
        </trans-unit>
        <trans-unit id="aebfa8de2c70a18e38a89cd348582fe45986c6b2" translate="yes" xml:space="preserve">
          <source>GlobalAlloc::dealloc</source>
          <target state="translated">GlobalAlloc::dealloc</target>
        </trans-unit>
        <trans-unit id="fe2c144d895a892ee23f306ecdb0f1fde3f96ad7" translate="yes" xml:space="preserve">
          <source>GlobalAlloc::realloc</source>
          <target state="translated">GlobalAlloc::realloc</target>
        </trans-unit>
        <trans-unit id="7427cf697be16a4ec1d916910128a59d920125e7" translate="yes" xml:space="preserve">
          <source>Glossary</source>
          <target state="translated">Glossary</target>
        </trans-unit>
        <trans-unit id="2514908c36408ef2ed4444834c9f5ccbe93b670b" translate="yes" xml:space="preserve">
          <source>Glue for usage of the &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt; macro with implementors of this trait.</source>
          <target state="translated">胶水的用法&lt;a href=&quot;../macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt;具有此特征的实现者的宏。</target>
        </trans-unit>
        <trans-unit id="3a1c017ccb35f05e8443d7a3eddb7ce45674e092" translate="yes" xml:space="preserve">
          <source>Glue for usage of the &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt; macro with implementors of this trait. &lt;a href=&quot;../fmt/trait.write#method.write_fmt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">胶水的用法&lt;a href=&quot;../macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt;具有此特征的实现者的宏。&lt;a href=&quot;../fmt/trait.write#method.write_fmt&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d1dbe04d6160f33e99282ce3fd010eb4fb67bcb2" translate="yes" xml:space="preserve">
          <source>Glue for usage of the &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt; macro with implementors of this trait. &lt;a href=&quot;trait.write#method.write_fmt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">胶水的用法&lt;a href=&quot;../macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt;具有此特征的实现者的宏。&lt;a href=&quot;trait.write#method.write_fmt&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="801bded4f0d6ed0381cd90ad308e8e87612227ff" translate="yes" xml:space="preserve">
          <source>Glue for usage of the &lt;a href=&quot;macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt; macro with implementors of this trait. &lt;a href=&quot;fmt/trait.write#method.write_fmt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">胶水的用法&lt;a href=&quot;macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt;具有此特征的实现者的宏。&lt;a href=&quot;fmt/trait.write#method.write_fmt&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="63f9aa2e6d4ad074b5cfe6a907121a6231effb73" translate="yes" xml:space="preserve">
          <source>Glue for usage of the [&lt;code&gt;write!&lt;/code&gt;] macro with implementors of this trait. &lt;a href=&quot;../fmt/trait.write#method.write_fmt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">胶水用于[ &lt;code&gt;write!&lt;/code&gt; ]宏以及该特性的实现者。&lt;a href=&quot;../fmt/trait.write#method.write_fmt&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="34773aa1db362e995011ad93000d8b9d338dfdd1" translate="yes" xml:space="preserve">
          <source>Glue for usage of the [&lt;code&gt;write!&lt;/code&gt;] macro with implementors of this trait. &lt;a href=&quot;fmt/trait.write#method.write_fmt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">胶水用于[ &lt;code&gt;write!&lt;/code&gt; ]宏以及该特性的实现者。&lt;a href=&quot;fmt/trait.write#method.write_fmt&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bbef5a72f8aabf3ae93fcc57e62c0a0223a518e5" translate="yes" xml:space="preserve">
          <source>Glue for usage of the [&lt;code&gt;write!&lt;/code&gt;] macro with implementors of this trait. &lt;a href=&quot;trait.write#method.write_fmt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">胶水用于[ &lt;code&gt;write!&lt;/code&gt; ]宏以及该特性的实现者。&lt;a href=&quot;trait.write#method.write_fmt&quot;&gt;阅读更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="103e6499a37e08740be45a6eeb4c1b026a8ac079" translate="yes" xml:space="preserve">
          <source>Go into the &lt;em&gt;hello_cargo&lt;/em&gt; directory and list the files. You&amp;rsquo;ll see that Cargo has generated two files and one directory for us: a &lt;em&gt;Cargo.toml&lt;/em&gt; file and a &lt;em&gt;src&lt;/em&gt; directory with a &lt;em&gt;main.rs&lt;/em&gt; file inside.</source>
          <target state="translated">进入&lt;em&gt;hello_cargo&lt;/em&gt;目录并列出文件。您会看到Cargo为我们生成了两个文件和一个目录：一个&lt;em&gt;Cargo.toml&lt;/em&gt;文件和一个其中包含&lt;em&gt;main.rs&lt;/em&gt;文件的&lt;em&gt;src&lt;/em&gt;目录。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2c5134e463153b73435701f263a503592ab3d53a" translate="yes" xml:space="preserve">
          <source>Go into the &lt;em&gt;hello_cargo&lt;/em&gt; directory and list the files. You&amp;rsquo;ll see that Cargo has generated two files and one directory for us: a &lt;em&gt;Cargo.toml&lt;/em&gt; file and a &lt;em&gt;src&lt;/em&gt; directory with a &lt;em&gt;main.rs&lt;/em&gt; file inside. It has also initialized a new Git repository along with a &lt;em&gt;.gitignore&lt;/em&gt; file.</source>
          <target state="translated">进入&lt;em&gt;hello_cargo&lt;/em&gt;目录并列出文件。您会看到Cargo为我们生成了两个文件和一个目录：一个&lt;em&gt;Cargo.toml&lt;/em&gt;文件和一个其中带有&lt;em&gt;main.rs&lt;/em&gt;文件的&lt;em&gt;src&lt;/em&gt;目录。它还已经初始化了一个新的Git存储库以及&lt;em&gt;.gitignore&lt;/em&gt;文件。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="50e6889164bb8054d882b924cda71582b6d6d180" translate="yes" xml:space="preserve">
          <source>Going finite with &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;Iterator::take()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">用&lt;a href=&quot;trait.iterator#method.take&quot;&gt; &lt;code&gt;Iterator::take()&lt;/code&gt; &lt;/a&gt;有限化：</target>
        </trans-unit>
        <trans-unit id="b6849789947c3320fec7645aaddce84614976c34" translate="yes" xml:space="preserve">
          <source>Going finite with &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;trait.iterator#method.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt;有限：</target>
        </trans-unit>
        <trans-unit id="62320f24d2e67e3a996b5eb69a47e8e61772abe1" translate="yes" xml:space="preserve">
          <source>Graceful Shutdown and Cleanup</source>
          <target state="translated">优雅的关机和清理</target>
        </trans-unit>
        <trans-unit id="14b567b853879017732fc7e6b51b1225fb2590d3" translate="yes" xml:space="preserve">
          <source>Gradual initialization of an &lt;code&gt;UnsafeCell&lt;/code&gt; requires &lt;code&gt;raw_get&lt;/code&gt;, as calling &lt;code&gt;get&lt;/code&gt; would require creating a reference to uninitialized data:</source>
          <target state="translated">&lt;code&gt;UnsafeCell&lt;/code&gt; 的逐步初始化需要 &lt;code&gt;raw_get&lt;/code&gt; ，因为调用 &lt;code&gt;get&lt;/code&gt; 将需要创建对未初始化数据的引用：</target>
        </trans-unit>
        <trans-unit id="dd17342cb47b948d64f169d73cfeec3f8b3e3f31" translate="yes" xml:space="preserve">
          <source>Grammar</source>
          <target state="translated">Grammar</target>
        </trans-unit>
        <trans-unit id="78e61d853fc7dbe21e195185b06132c0a0b3267c" translate="yes" xml:space="preserve">
          <source>Great! The code read and then printed the contents of the file. But the code has a few flaws. The &lt;code&gt;main&lt;/code&gt; function has multiple responsibilities: generally, functions are clearer and easier to maintain if each function is responsible for only one idea. The other problem is that we&amp;rsquo;re not handling errors as well as we could. The program is still small, so these flaws aren&amp;rsquo;t a big problem, but as the program grows, it will be harder to fix them cleanly. It&amp;rsquo;s good practice to begin refactoring early on when developing a program, because it&amp;rsquo;s much easier to refactor smaller amounts of code. We&amp;rsquo;ll do that next.</source>
          <target state="translated">大！代码读取并打印了文件的内容。但是代码有一些缺陷。的 &lt;code&gt;main&lt;/code&gt; 功能有多重责任：通常，功能更清晰，更易于维护，如果每个功能只负责一个想法。另一个问题是我们没有尽力处理错误。该程序仍然很小，因此这些缺陷并不是什么大问题，但是随着程序的发展，将很难对其进行彻底修复。在开发程序时尽早开始重构是个好习惯，因为重构少量代码要容易得多。接下来，我们将做。</target>
        </trans-unit>
        <trans-unit id="24a6854de536fe8272a59608dce7cfe696deeaaa" translate="yes" xml:space="preserve">
          <source>Great! They passed. Now, let&amp;rsquo;s call the new &lt;code&gt;search_case_insensitive&lt;/code&gt; function from the &lt;code&gt;run&lt;/code&gt; function. First, we&amp;rsquo;ll add a configuration option to the &lt;code&gt;Config&lt;/code&gt; struct to switch between case-sensitive and case-insensitive search. Adding this field will cause compiler errors because we aren&amp;rsquo;t initializing this field anywhere yet:</source>
          <target state="translated">大！他们通过了。现在，让我们从 &lt;code&gt;run&lt;/code&gt; 函数中调用新的 &lt;code&gt;search_case_insensitive&lt;/code&gt; 函数。首先，我们将配置选项添加到 &lt;code&gt;Config&lt;/code&gt; 结构中，以在区分大小写的搜索和不区分大小写的搜索之间切换。添加此字段将导致编译器错误，因为我们尚未在任何地方初始化此字段：</target>
        </trans-unit>
        <trans-unit id="64d373f5a71955e4f9210539868f04851ae696bb" translate="yes" xml:space="preserve">
          <source>Great! This error tells us we need a &lt;code&gt;ThreadPool&lt;/code&gt; type or module, so we&amp;rsquo;ll build one now. Our &lt;code&gt;ThreadPool&lt;/code&gt; implementation will be independent of the kind of work our web server is doing. So, let&amp;rsquo;s switch the &lt;code&gt;hello&lt;/code&gt; crate from a binary crate to a library crate to hold our &lt;code&gt;ThreadPool&lt;/code&gt; implementation. After we change to a library crate, we could also use the separate thread pool library for any work we want to do using a thread pool, not just for serving web requests.</source>
          <target state="translated">大！这个错误告诉我们我们需要一个 &lt;code&gt;ThreadPool&lt;/code&gt; 类型或模块，因此我们现在将构建一个。我们的 &lt;code&gt;ThreadPool&lt;/code&gt; 实现将独立于Web服务器正在执行的工作。因此，让我们将 &lt;code&gt;hello&lt;/code&gt; 板条箱从二进制板条箱切换到库板条箱以容纳 &lt;code&gt;ThreadPool&lt;/code&gt; 实现。更改为库箱后，我们还可以将单独的线程池库用于我们想要使用线程池进行的任何工作，而不仅仅是服务于Web请求。</target>
        </trans-unit>
        <trans-unit id="99b891e6f196f47f49f63f0b20ce223eaba55683" translate="yes" xml:space="preserve">
          <source>Great! This output is much friendlier for our users.</source>
          <target state="translated">厉害了! 这样的输出对我们的用户来说更友好了。</target>
        </trans-unit>
        <trans-unit id="2929f4d3537f13046a6a6654b391acff14ad5b53" translate="yes" xml:space="preserve">
          <source>Great, the program is working! The values of the arguments we need are being saved into the right variables. Later we&amp;rsquo;ll add some error handling to deal with certain potential erroneous situations, such as when the user provides no arguments; for now, we&amp;rsquo;ll ignore that situation and work on adding file-reading capabilities instead.</source>
          <target state="translated">很好，程序正在运行！我们需要的参数值将保存到正确的变量中。稍后，我们将添加一些错误处理以处理某些潜在的错误情况，例如当用户不提供参数时；目前，我们将忽略这种情况，而改为添加文件读取功能。</target>
        </trans-unit>
        <trans-unit id="c5f93da0af9ef56fee44e82925405c317fbf7afc" translate="yes" xml:space="preserve">
          <source>Great, the test fails, exactly as we expected. Let&amp;rsquo;s get the test to pass!</source>
          <target state="translated">太好了，测试失败了，完全符合我们的预期。让测试通过！</target>
        </trans-unit>
        <trans-unit id="599294f23ef04a992bc69ba465066344c3c7cf34" translate="yes" xml:space="preserve">
          <source>Greater than</source>
          <target state="translated">大于</target>
        </trans-unit>
        <trans-unit id="cc21fdb8f5e4e1d5b5c729ed455db20a348682c5" translate="yes" xml:space="preserve">
          <source>Greater than comparison</source>
          <target state="translated">大于比较</target>
        </trans-unit>
        <trans-unit id="a2919540599e9df0beb579ca8d46bdc142657611" translate="yes" xml:space="preserve">
          <source>Greater than or equal to</source>
          <target state="translated">大于或等于</target>
        </trans-unit>
        <trans-unit id="17e61387621cb5a7a3632ffc26d2a8ab3f16e769" translate="yes" xml:space="preserve">
          <source>Greater than or equal to comparison</source>
          <target state="translated">大于或等于比较</target>
        </trans-unit>
        <trans-unit id="d667800b5ed7b98aa0dde326047666b10d805fc3" translate="yes" xml:space="preserve">
          <source>Greater-than comparison for two &lt;code&gt;Arc&lt;/code&gt;s.</source>
          <target state="translated">两个 &lt;code&gt;Arc&lt;/code&gt; 的大于比较。</target>
        </trans-unit>
        <trans-unit id="3f06e7136cc69760b0d1c2aa5adb37088b0a0311" translate="yes" xml:space="preserve">
          <source>Greater-than comparison for two &lt;code&gt;Rc&lt;/code&gt;s.</source>
          <target state="translated">两个 &lt;code&gt;Rc&lt;/code&gt; 大于比较。</target>
        </trans-unit>
        <trans-unit id="f464c4ed26773e9c5252581a89a104e8de23d490" translate="yes" xml:space="preserve">
          <source>Greek letters &quot;&amp;alpha;&quot; &quot;&amp;beta;&quot; &quot;&amp;gamma;&quot; &quot;&amp;delta;&quot; stand for potentially empty token-tree sequences. (However, the Greek letter &quot;&amp;epsilon;&quot; (epsilon) has a special role in the presentation and does not stand for a token-tree sequence.)</source>
          <target state="translated">希腊字母&amp;ldquo;&amp;alpha;&amp;rdquo;，&amp;ldquo;&amp;beta;&amp;rdquo;，&amp;ldquo;&amp;gamma;&amp;rdquo;，&amp;ldquo;&amp;delta;&amp;rdquo;代表可能为空的令牌树序列。（但是，希腊字母&amp;ldquo;&amp;epsilon;&amp;rdquo;（epsilon）在表示中具有特殊作用，并不代表令牌树序列。）</target>
        </trans-unit>
        <trans-unit id="90accf7e4de3f988bebb9b0fcc656094cc41c05f" translate="yes" xml:space="preserve">
          <source>Group expression attributes</source>
          <target state="translated">集团表达式属性</target>
        </trans-unit>
        <trans-unit id="ef7a9bb1a692431ae6d8dff02418977a8053e1b7" translate="yes" xml:space="preserve">
          <source>Grouped expressions</source>
          <target state="translated">分组表达式</target>
        </trans-unit>
        <trans-unit id="13970f54032da4ae14dbff0318664d8c8f7ae9de" translate="yes" xml:space="preserve">
          <source>Grouped patterns</source>
          <target state="translated">分组模式</target>
        </trans-unit>
        <trans-unit id="990b2d14bf2da723821496eca71bc9a4f287e41e" translate="yes" xml:space="preserve">
          <source>Grouping Configuration Values</source>
          <target state="translated">分组配置值</target>
        </trans-unit>
        <trans-unit id="ad08922b155e0f0ecfa878359b6bdba11de6fcc5" translate="yes" xml:space="preserve">
          <source>Groups items</source>
          <target state="translated">分组项目</target>
        </trans-unit>
        <trans-unit id="1dee13ac09a18c736a85fb7212501ca3f0535655" translate="yes" xml:space="preserve">
          <source>Gt</source>
          <target state="translated">Gt</target>
        </trans-unit>
        <trans-unit id="e72af43a28130c6f52db641d01a37aabf78c282e" translate="yes" xml:space="preserve">
          <source>Guarantees</source>
          <target state="translated">Guarantees</target>
        </trans-unit>
        <trans-unit id="643a27fb6062be0d6499f01fc4bde0f4334880b4" translate="yes" xml:space="preserve">
          <source>Guidance on which license is appropriate for your project is beyond the scope of this book. Many people in the Rust community license their projects in the same way as Rust by using a dual license of &lt;code&gt;MIT OR Apache-2.0&lt;/code&gt;. This practice demonstrates that you can also specify multiple license identifiers separated by &lt;code&gt;OR&lt;/code&gt; to have multiple licenses for your project.</source>
          <target state="translated">关于哪种许可证适合您的项目的指导超出了本书的范围。Rust社区中的许多人都使用 &lt;code&gt;MIT OR Apache-2.0&lt;/code&gt; 的双重许可以与Rust相同的方式许可他们的项目。此实践表明，您还可以指定多个许可证标识符，并用 &lt;code&gt;OR&lt;/code&gt; 分隔，以为您的项目拥有多个许可证。</target>
        </trans-unit>
        <trans-unit id="bf073fae640ded81eeb7a4cee70faff4a623c16c" translate="yes" xml:space="preserve">
          <source>Guide</source>
          <target state="translated">Guide</target>
        </trans-unit>
        <trans-unit id="5662999f81a9d63d43963dff643c8f2e0db48c56" translate="yes" xml:space="preserve">
          <source>Guidelines for Error Handling</source>
          <target state="translated">错误处理指南</target>
        </trans-unit>
        <trans-unit id="0b19d1e1b8a5918571f9c9d135638b9f04547d8f" translate="yes" xml:space="preserve">
          <source>HANDLE</source>
          <target state="translated">HANDLE</target>
        </trans-unit>
        <trans-unit id="1a486ce8f36726233061ec65b3f6bda493fd48c9" translate="yes" xml:space="preserve">
          <source>HEX_DIGIT : [&lt;code&gt;0&lt;/code&gt;-&lt;code&gt;9&lt;/code&gt;&lt;code&gt;a&lt;/code&gt;-&lt;code&gt;f&lt;/code&gt;&lt;code&gt;A&lt;/code&gt;-&lt;code&gt;F&lt;/code&gt;]</source>
          <target state="translated">16进制数字：[ &lt;code&gt;0&lt;/code&gt; - &lt;code&gt;9&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; - &lt;code&gt;f&lt;/code&gt; &lt;code&gt;A&lt;/code&gt; - &lt;code&gt;F&lt;/code&gt; ]</target>
        </trans-unit>
        <trans-unit id="e195a9555456bea0e92fe340c3ae06ff639810c6" translate="yes" xml:space="preserve">
          <source>HEX_DIGIT&lt;sup&gt;1..6&lt;/sup&gt;</source>
          <target state="translated">HEX_DIGIT&lt;sup&gt;1..6&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="5f9c36747e4699e63511061195cedb992801b9d3" translate="yes" xml:space="preserve">
          <source>HEX_LITERAL :</source>
          <target state="translated">HEX_LITERAL :</target>
        </trans-unit>
        <trans-unit id="85b770e7ec266276f5de99706626234eb555c7b0" translate="yes" xml:space="preserve">
          <source>HTTP is a text-based protocol, and a request takes this format:</source>
          <target state="translated">HTTP是一种基于文本的协议,请求采用这种格式。</target>
        </trans-unit>
        <trans-unit id="3c47a723a85c131d97bf2d4bd392d2947fe77f70" translate="yes" xml:space="preserve">
          <source>Had &lt;code&gt;path&lt;/code&gt; contained invalid unicode, the &lt;code&gt;to_string_lossy&lt;/code&gt; call might have returned &lt;code&gt;&quot;fo�.txt&quot;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;path&lt;/code&gt; 包含无效的unicode，则 &lt;code&gt;to_string_lossy&lt;/code&gt; 调用可能返回了 &lt;code&gt;&quot;fo�.txt&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ee4aa46e82881f4a75375987b71c3131634f94f" translate="yes" xml:space="preserve">
          <source>Handling Errors Returned from &lt;code id=&quot;handling-errors-returned-from-run-in-main&quot;&gt;run&lt;/code&gt; in &lt;code&gt;main&lt;/code&gt;</source>
          <target state="translated">处理返回的错误从 &lt;code id=&quot;handling-errors-returned-from-run-in-main&quot;&gt;run&lt;/code&gt; 在 &lt;code&gt;main&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="187689d6fbeb450bd6ea4e652dae8dbfd0f10e3e" translate="yes" xml:space="preserve">
          <source>Handling I/O</source>
          <target state="translated">处理I/O</target>
        </trans-unit>
        <trans-unit id="f85b58414971efcc7eee439597523a8f745698cd" translate="yes" xml:space="preserve">
          <source>Handling Invalid Input</source>
          <target state="translated">处理无效输入</target>
        </trans-unit>
        <trans-unit id="99ae89ce9129c070f0e68c272cb53e5ebe7623fe" translate="yes" xml:space="preserve">
          <source>Handling Multiple Conditions with &lt;code id=&quot;handling-multiple-conditions-with-else-if&quot;&gt;else if&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code id=&quot;handling-multiple-conditions-with-else-if&quot;&gt;else if&lt;/code&gt; 处理多个条件</target>
        </trans-unit>
        <trans-unit id="59aadebe3071fa59f50f2105cef14ad03fb21914" translate="yes" xml:space="preserve">
          <source>Handling Potential Failure with the &lt;code id=&quot;handling-potential-failure-with-the-result-type&quot;&gt;Result&lt;/code&gt; Type</source>
          <target state="translated">使用 &lt;code id=&quot;handling-potential-failure-with-the-result-type&quot;&gt;Result&lt;/code&gt; 类型处理潜在故障</target>
        </trans-unit>
        <trans-unit id="90b8d168f939ff8e48ed694781964a3efae61546" translate="yes" xml:space="preserve">
          <source>Handling concurrent programming safely and efficiently is another of Rust&amp;rsquo;s major goals. &lt;em&gt;Concurrent programming&lt;/em&gt;, where different parts of a program execute independently, and &lt;em&gt;parallel programming&lt;/em&gt;, where different parts of a program execute at the same time, are becoming increasingly important as more computers take advantage of their multiple processors. Historically, programming in these contexts has been difficult and error prone: Rust hopes to change that.</source>
          <target state="translated">安全有效地处理并发编程是Rust的另一个主要目标。&lt;em&gt;并发编程&lt;/em&gt;，其中一个程序的不同部分独立地执行，以及&lt;em&gt;并行编程&lt;/em&gt;，其中一个程序的不同部分执行的同时，随着越来越多的计算机把他们的多处理器的优点变得越来越重要。从历史上看，在这些情况下进行编程一直很困难且容易出错：Rust希望改变这种情况。</target>
        </trans-unit>
        <trans-unit id="8f7b16e3844bb9bbaa86ba42b5bf793b3b5747f5" translate="yes" xml:space="preserve">
          <source>Handling errors (&lt;a href=&quot;ch09-00-error-handling&quot;&gt;Chapter 9&lt;/a&gt;)</source>
          <target state="translated">处理错误（&lt;a href=&quot;ch09-00-error-handling&quot;&gt;第9章&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="a8a516b582d8ee827caa06b852f0927dd7ea1aa9" translate="yes" xml:space="preserve">
          <source>Handling the error if &lt;code&gt;run&lt;/code&gt; returns an error</source>
          <target state="translated">如果 &lt;code&gt;run&lt;/code&gt; 返回错误，则处理错误</target>
        </trans-unit>
        <trans-unit id="9779c3f0bfcc6c7bd84ac8dc1d7d0faaf0886246" translate="yes" xml:space="preserve">
          <source>Has no effect and returns &lt;code&gt;None&lt;/code&gt; if the &lt;code&gt;OnceCell&lt;/code&gt; hasn't been initialized.</source>
          <target state="translated">没有任何效果，如果尚未初始化 &lt;code&gt;OnceCell&lt;/code&gt; ，则返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="59701e203928fde4afc37f856c0fe1389efbf77a" translate="yes" xml:space="preserve">
          <source>Has no effect and returns &lt;code&gt;None&lt;/code&gt; if the &lt;code&gt;SyncOnceCell&lt;/code&gt; hasn't been initialized.</source>
          <target state="translated">没有任何效果，如果尚未初始化 &lt;code&gt;SyncOnceCell&lt;/code&gt; ，则返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="605c9af0dc3550ddfefeee4d42138a7f1adc2bd1" translate="yes" xml:space="preserve">
          <source>Has the effects of both &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; together: For loads it uses &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; ordering. For stores it uses the &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; ordering.</source>
          <target state="translated">同时具有&amp;ldquo;&lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;和&amp;ldquo;&lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt;的效果：对于负载，它使用&amp;ldquo;&lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;排序&amp;rdquo;。对于商店，它使用&lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt;顺序。</target>
        </trans-unit>
        <trans-unit id="72f36c92a5a7396e8365dbdfe793e5eef4ad9431" translate="yes" xml:space="preserve">
          <source>Has the effects of both &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; together: For loads it uses &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; ordering. For stores it uses the &lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; ordering.</source>
          <target state="translated">同时具有&lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt;的效果：对于负载，它使用&lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;排序。对于商店，它使用&lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt;顺序。</target>
        </trans-unit>
        <trans-unit id="873507a022b58de26a88deae87268cbd8d6af5b1" translate="yes" xml:space="preserve">
          <source>Hash</source>
          <target state="translated">Hash</target>
        </trans-unit>
        <trans-unit id="d16b2d08d75092ccdbc53063c23e2c3fe71d7f34" translate="yes" xml:space="preserve">
          <source>Hash Maps and Ownership</source>
          <target state="translated">散列图和所有权</target>
        </trans-unit>
        <trans-unit id="49d09ebb7291bff93c80ac3f381f55fe8a3c4cbf" translate="yes" xml:space="preserve">
          <source>Hash a raw pointer.</source>
          <target state="translated">哈希一个原始指针。</target>
        </trans-unit>
        <trans-unit id="6c5bfe7d7f5d3cec7864d666ab67d3faebb741c0" translate="yes" xml:space="preserve">
          <source>Hash maps are useful when you want to look up data not by using an index, as you can with vectors, but by using a key that can be of any type. For example, in a game, you could keep track of each team&amp;rsquo;s score in a hash map in which each key is a team&amp;rsquo;s name and the values are each team&amp;rsquo;s score. Given a team name, you can retrieve its score.</source>
          <target state="translated">当您不希望像使用向量那样使用索引来查找数据时，而是通过使用可以是任何类型的键来查找数据时，哈希映射很有用。例如，在游戏中，您可以在哈希图中跟踪每个团队的得分，其中每个键是一个团队的名称，值是每个团队的得分。给定一个团队名称，您可以检索其得分。</target>
        </trans-unit>
        <trans-unit id="f26fb9fba1361d959b70bbd8e0907090c8a67651" translate="yes" xml:space="preserve">
          <source>Hash memoization</source>
          <target state="translated">散列记忆</target>
        </trans-unit>
        <trans-unit id="1ca569e43628039695db4d117d37cb0433c51032" translate="yes" xml:space="preserve">
          <source>Hash::hash</source>
          <target state="translated">Hash::hash</target>
        </trans-unit>
        <trans-unit id="bac71fb916a479ac2558a2194819bf301931ca8b" translate="yes" xml:space="preserve">
          <source>Hash::hash_slice</source>
          <target state="translated">Hash::hash_slice</target>
        </trans-unit>
        <trans-unit id="ba62d7b8d0b157f714c6a6132554b38789c6ada5" translate="yes" xml:space="preserve">
          <source>HashMap</source>
          <target state="translated">HashMap</target>
        </trans-unit>
        <trans-unit id="fb7d8a23eadd1e4ece9d9a20a984c6c31289cb8b" translate="yes" xml:space="preserve">
          <source>HashMap::borrow</source>
          <target state="translated">HashMap::borrow</target>
        </trans-unit>
        <trans-unit id="610c174a39c8908fe163a07919237940fc37c1ca" translate="yes" xml:space="preserve">
          <source>HashMap::borrow_mut</source>
          <target state="translated">HashMap::borrow_mut</target>
        </trans-unit>
        <trans-unit id="5b073a19c1d948d2ff7ea181c3e6faa47ac950b7" translate="yes" xml:space="preserve">
          <source>HashMap::capacity</source>
          <target state="translated">HashMap::capacity</target>
        </trans-unit>
        <trans-unit id="290ef182063e668dbc9d6f81f0f99bd696eaa3ad" translate="yes" xml:space="preserve">
          <source>HashMap::clear</source>
          <target state="translated">HashMap::clear</target>
        </trans-unit>
        <trans-unit id="4504d7762629b3f09d106b8b2c49316387f83111" translate="yes" xml:space="preserve">
          <source>HashMap::clone</source>
          <target state="translated">HashMap::clone</target>
        </trans-unit>
        <trans-unit id="755ecc8e2fe0d53bf8d40f09d15dc41f5c72dee3" translate="yes" xml:space="preserve">
          <source>HashMap::clone_from</source>
          <target state="translated">HashMap::clone_from</target>
        </trans-unit>
        <trans-unit id="18149fd5a2f0ddb0a754ee5b20ae060122824af4" translate="yes" xml:space="preserve">
          <source>HashMap::clone_into</source>
          <target state="translated">HashMap::clone_into</target>
        </trans-unit>
        <trans-unit id="c981dd589a66a9541ad1bd942f956a943a21c776" translate="yes" xml:space="preserve">
          <source>HashMap::contains_key</source>
          <target state="translated">HashMap::contains_key</target>
        </trans-unit>
        <trans-unit id="6790c064706283f72985a00fd5d63757494362ee" translate="yes" xml:space="preserve">
          <source>HashMap::default</source>
          <target state="translated">HashMap::default</target>
        </trans-unit>
        <trans-unit id="ef89e29aa59c76930b39d07bb7c27f4f62ca4bc9" translate="yes" xml:space="preserve">
          <source>HashMap::drain</source>
          <target state="translated">HashMap::drain</target>
        </trans-unit>
        <trans-unit id="5c70bb5f39da25e4a3243cd372f9722cdd0aaa06" translate="yes" xml:space="preserve">
          <source>HashMap::entry</source>
          <target state="translated">HashMap::entry</target>
        </trans-unit>
        <trans-unit id="16580b886dde904eb2189a50aaa2ec8e66754a76" translate="yes" xml:space="preserve">
          <source>HashMap::eq</source>
          <target state="translated">HashMap::eq</target>
        </trans-unit>
        <trans-unit id="006972122bed4c52275751aaa6b1a76aa26a72f6" translate="yes" xml:space="preserve">
          <source>HashMap::extend</source>
          <target state="translated">HashMap::extend</target>
        </trans-unit>
        <trans-unit id="eef27e5aeaaee7ca97ef32c4174c3b7aefbfc638" translate="yes" xml:space="preserve">
          <source>HashMap::fmt</source>
          <target state="translated">HashMap::fmt</target>
        </trans-unit>
        <trans-unit id="2bac685119eec98678bcc3e2df09e34b76b251fb" translate="yes" xml:space="preserve">
          <source>HashMap::from</source>
          <target state="translated">HashMap::from</target>
        </trans-unit>
        <trans-unit id="23702b4af8c6608c05d1fc72b700af47889b23e4" translate="yes" xml:space="preserve">
          <source>HashMap::from_iter</source>
          <target state="translated">HashMap::from_iter</target>
        </trans-unit>
        <trans-unit id="688fd04b9fb0128d305e248d2f3d8f8222392c9c" translate="yes" xml:space="preserve">
          <source>HashMap::get</source>
          <target state="translated">HashMap::get</target>
        </trans-unit>
        <trans-unit id="ecd394b5e97d505b5180c88396d32eb04f7a2ef5" translate="yes" xml:space="preserve">
          <source>HashMap::get_key_value</source>
          <target state="translated">HashMap::get_key_value</target>
        </trans-unit>
        <trans-unit id="59fd726634d31c7b61261668c05f7485bf9decb1" translate="yes" xml:space="preserve">
          <source>HashMap::get_mut</source>
          <target state="translated">HashMap::get_mut</target>
        </trans-unit>
        <trans-unit id="9e2f5e352b69c23e1f8634441216dbbc589410a2" translate="yes" xml:space="preserve">
          <source>HashMap::hasher</source>
          <target state="translated">HashMap::hasher</target>
        </trans-unit>
        <trans-unit id="977407424016d1150ed5a54f71aa720d8b5fc1e0" translate="yes" xml:space="preserve">
          <source>HashMap::index</source>
          <target state="translated">HashMap::index</target>
        </trans-unit>
        <trans-unit id="575b9b99b8b6536e98f82916772ec179324759de" translate="yes" xml:space="preserve">
          <source>HashMap::insert</source>
          <target state="translated">HashMap::insert</target>
        </trans-unit>
        <trans-unit id="4241974ff3713d57ec86ed4fb2960fb964b4c28f" translate="yes" xml:space="preserve">
          <source>HashMap::into</source>
          <target state="translated">HashMap::into</target>
        </trans-unit>
        <trans-unit id="2ee397e85e03d2df5163ed8c1f36f63a8275c934" translate="yes" xml:space="preserve">
          <source>HashMap::into_iter</source>
          <target state="translated">HashMap::into_iter</target>
        </trans-unit>
        <trans-unit id="a649d7141d86759b290a9b727d47ad161b114361" translate="yes" xml:space="preserve">
          <source>HashMap::is_empty</source>
          <target state="translated">HashMap::is_empty</target>
        </trans-unit>
        <trans-unit id="cfdbb20825a41950e4f6625ab41ffc0a12e6cfd4" translate="yes" xml:space="preserve">
          <source>HashMap::iter</source>
          <target state="translated">HashMap::iter</target>
        </trans-unit>
        <trans-unit id="2bfca7b0b17c04d487077c012bec3c640635d95c" translate="yes" xml:space="preserve">
          <source>HashMap::iter_mut</source>
          <target state="translated">HashMap::iter_mut</target>
        </trans-unit>
        <trans-unit id="15748fe38a254ba57dde931f14941b25230915de" translate="yes" xml:space="preserve">
          <source>HashMap::keys</source>
          <target state="translated">HashMap::keys</target>
        </trans-unit>
        <trans-unit id="013a2db0fc0510df2be8bb9a81336355dd6c81f5" translate="yes" xml:space="preserve">
          <source>HashMap::len</source>
          <target state="translated">HashMap::len</target>
        </trans-unit>
        <trans-unit id="bbd14da0450a45b2de193fcab5c00bb0eb5903d6" translate="yes" xml:space="preserve">
          <source>HashMap::ne</source>
          <target state="translated">HashMap::ne</target>
        </trans-unit>
        <trans-unit id="7a43b41cd29931fa0443de6420eab17418a5775e" translate="yes" xml:space="preserve">
          <source>HashMap::new</source>
          <target state="translated">HashMap::new</target>
        </trans-unit>
        <trans-unit id="292e274cb26beafe87f9986cd7a69d6e80f0d70e" translate="yes" xml:space="preserve">
          <source>HashMap::raw_entry</source>
          <target state="translated">HashMap::raw_entry</target>
        </trans-unit>
        <trans-unit id="ddac1348f5646998be5c764f10f7f59d986ae24a" translate="yes" xml:space="preserve">
          <source>HashMap::raw_entry_mut</source>
          <target state="translated">HashMap::raw_entry_mut</target>
        </trans-unit>
        <trans-unit id="eb7e68ea1cad35b4a180ddda2294c0954904ff9c" translate="yes" xml:space="preserve">
          <source>HashMap::remove</source>
          <target state="translated">HashMap::remove</target>
        </trans-unit>
        <trans-unit id="daa065a9f2946c9de97f049237fe61d1096fd3ad" translate="yes" xml:space="preserve">
          <source>HashMap::remove_entry</source>
          <target state="translated">HashMap::remove_entry</target>
        </trans-unit>
        <trans-unit id="0121bfc051e62887774fc3f9ec592514d686885b" translate="yes" xml:space="preserve">
          <source>HashMap::reserve</source>
          <target state="translated">HashMap::reserve</target>
        </trans-unit>
        <trans-unit id="88a2076f3660ecd79e0adb0243f0e9d4a8862721" translate="yes" xml:space="preserve">
          <source>HashMap::retain</source>
          <target state="translated">HashMap::retain</target>
        </trans-unit>
        <trans-unit id="f4991ea8c7797b408f7805334922bf7e0c8d10d6" translate="yes" xml:space="preserve">
          <source>HashMap::shrink_to</source>
          <target state="translated">HashMap::shrink_to</target>
        </trans-unit>
        <trans-unit id="dc8f377e69db6a1e9ed141ae6bf011880bd42c53" translate="yes" xml:space="preserve">
          <source>HashMap::shrink_to_fit</source>
          <target state="translated">HashMap::shrink_to_fit</target>
        </trans-unit>
        <trans-unit id="bab5c2ac135dfe90b9b32c652153883ceeee3b33" translate="yes" xml:space="preserve">
          <source>HashMap::to_owned</source>
          <target state="translated">HashMap::to_owned</target>
        </trans-unit>
        <trans-unit id="391acc19f610e927b497bb4e11b352a7b2af949e" translate="yes" xml:space="preserve">
          <source>HashMap::try_from</source>
          <target state="translated">HashMap::try_from</target>
        </trans-unit>
        <trans-unit id="2893c51bf9c281d2ca7aba047803684d9a1aa860" translate="yes" xml:space="preserve">
          <source>HashMap::try_into</source>
          <target state="translated">HashMap::try_into</target>
        </trans-unit>
        <trans-unit id="9e7015c3cc0d5bc1003d09ff24337d2b0ad55c7b" translate="yes" xml:space="preserve">
          <source>HashMap::try_reserve</source>
          <target state="translated">HashMap::try_reserve</target>
        </trans-unit>
        <trans-unit id="b2ebec04fba53bc16fb11b0073bb6cc66af50890" translate="yes" xml:space="preserve">
          <source>HashMap::type_id</source>
          <target state="translated">HashMap::type_id</target>
        </trans-unit>
        <trans-unit id="d17a786e030134db4f1882f47a85dce856cb6c49" translate="yes" xml:space="preserve">
          <source>HashMap::values</source>
          <target state="translated">HashMap::values</target>
        </trans-unit>
        <trans-unit id="162e585c9055d46d3b3067b924bb60d67e948304" translate="yes" xml:space="preserve">
          <source>HashMap::values_mut</source>
          <target state="translated">HashMap::values_mut</target>
        </trans-unit>
        <trans-unit id="01bde569a6ca247f70b925283ac4eabf1fae164b" translate="yes" xml:space="preserve">
          <source>HashMap::with_capacity</source>
          <target state="translated">HashMap::with_capacity</target>
        </trans-unit>
        <trans-unit id="c95ee5e43e53e6378ec649a9c2e69ab43598f8fb" translate="yes" xml:space="preserve">
          <source>HashMap::with_capacity_and_hasher</source>
          <target state="translated">HashMap::with_capacity_and_hasher</target>
        </trans-unit>
        <trans-unit id="e7c4071d4f77cdf1820942e0c1ab3de0a91ed2cf" translate="yes" xml:space="preserve">
          <source>HashMap::with_hasher</source>
          <target state="translated">HashMap::with_hasher</target>
        </trans-unit>
        <trans-unit id="cac17f9bdb6febebe0052a72f2ab8a6828d20944" translate="yes" xml:space="preserve">
          <source>HashSet</source>
          <target state="translated">HashSet</target>
        </trans-unit>
        <trans-unit id="b68646e63dfce36d83be9cbaa54a303ef6a007af" translate="yes" xml:space="preserve">
          <source>HashSet::bitand</source>
          <target state="translated">HashSet::bitand</target>
        </trans-unit>
        <trans-unit id="1ab81639812d7d4b62dc39b7419600230fdcf25f" translate="yes" xml:space="preserve">
          <source>HashSet::bitor</source>
          <target state="translated">HashSet::bitor</target>
        </trans-unit>
        <trans-unit id="8075cc2581f90ca9a8938fc5f82b21b6e3d28edf" translate="yes" xml:space="preserve">
          <source>HashSet::bitxor</source>
          <target state="translated">HashSet::bitxor</target>
        </trans-unit>
        <trans-unit id="c77b68f5068bcecde6e8ffd8572dfb041513399a" translate="yes" xml:space="preserve">
          <source>HashSet::borrow</source>
          <target state="translated">HashSet::borrow</target>
        </trans-unit>
        <trans-unit id="03d0b56c31db1f8ba8c12e20646074ec753d52c9" translate="yes" xml:space="preserve">
          <source>HashSet::borrow_mut</source>
          <target state="translated">HashSet::borrow_mut</target>
        </trans-unit>
        <trans-unit id="bdd5342708fbc173156c0ad0e7ccdcf72b87bbec" translate="yes" xml:space="preserve">
          <source>HashSet::capacity</source>
          <target state="translated">HashSet::capacity</target>
        </trans-unit>
        <trans-unit id="b496a7fc22db5dfee5a71eb5501bd54af27226af" translate="yes" xml:space="preserve">
          <source>HashSet::clear</source>
          <target state="translated">HashSet::clear</target>
        </trans-unit>
        <trans-unit id="f6f7e84776c0a1492c95ca329cccd559dae22239" translate="yes" xml:space="preserve">
          <source>HashSet::clone</source>
          <target state="translated">HashSet::clone</target>
        </trans-unit>
        <trans-unit id="ad872e535653208fd311ddac1851f60e92c27461" translate="yes" xml:space="preserve">
          <source>HashSet::clone_from</source>
          <target state="translated">HashSet::clone_from</target>
        </trans-unit>
        <trans-unit id="30071df27bb602cc36f2524cd6272f86cf175d82" translate="yes" xml:space="preserve">
          <source>HashSet::clone_into</source>
          <target state="translated">HashSet::clone_into</target>
        </trans-unit>
        <trans-unit id="e9929a76352b9c6c4517057784d174ca502e4659" translate="yes" xml:space="preserve">
          <source>HashSet::contains</source>
          <target state="translated">HashSet::contains</target>
        </trans-unit>
        <trans-unit id="ee9499c5d925a80b927374f5fc18c8cf7acba286" translate="yes" xml:space="preserve">
          <source>HashSet::default</source>
          <target state="translated">HashSet::default</target>
        </trans-unit>
        <trans-unit id="c5666651d6d13e045665faaee91da5ee35aefa99" translate="yes" xml:space="preserve">
          <source>HashSet::difference</source>
          <target state="translated">HashSet::difference</target>
        </trans-unit>
        <trans-unit id="559bf337908631f9dc2cd3ab1c34c4b7158b1609" translate="yes" xml:space="preserve">
          <source>HashSet::drain</source>
          <target state="translated">HashSet::drain</target>
        </trans-unit>
        <trans-unit id="f25e9846b65f287b930b9d456cbbec8f01e240e9" translate="yes" xml:space="preserve">
          <source>HashSet::eq</source>
          <target state="translated">HashSet::eq</target>
        </trans-unit>
        <trans-unit id="6a91f6923c3310862ee3596940ed5b097a1bf087" translate="yes" xml:space="preserve">
          <source>HashSet::extend</source>
          <target state="translated">HashSet::extend</target>
        </trans-unit>
        <trans-unit id="8be48241f0d314ab0acacea29d3d926070bb5fa9" translate="yes" xml:space="preserve">
          <source>HashSet::fmt</source>
          <target state="translated">HashSet::fmt</target>
        </trans-unit>
        <trans-unit id="b4f60277034657d60f3728ccd3956ff96b1819e2" translate="yes" xml:space="preserve">
          <source>HashSet::from</source>
          <target state="translated">HashSet::from</target>
        </trans-unit>
        <trans-unit id="60f387d38899e1b57c8d30e798c352963e26a097" translate="yes" xml:space="preserve">
          <source>HashSet::from_iter</source>
          <target state="translated">HashSet::from_iter</target>
        </trans-unit>
        <trans-unit id="33cae8d46ad9832e17073c4a9f1abb51a6504d81" translate="yes" xml:space="preserve">
          <source>HashSet::get</source>
          <target state="translated">HashSet::get</target>
        </trans-unit>
        <trans-unit id="6c7ba6a45c151f970088dcc70a1b7618e6395baf" translate="yes" xml:space="preserve">
          <source>HashSet::get_or_insert</source>
          <target state="translated">HashSet::get_or_insert</target>
        </trans-unit>
        <trans-unit id="3c9bf791b1bc89ff50ed8e094f3d77efdc799512" translate="yes" xml:space="preserve">
          <source>HashSet::get_or_insert_with</source>
          <target state="translated">HashSet::get_or_insert_with</target>
        </trans-unit>
        <trans-unit id="01c1744d870244b7145beb071040d269b906cc15" translate="yes" xml:space="preserve">
          <source>HashSet::hasher</source>
          <target state="translated">HashSet::hasher</target>
        </trans-unit>
        <trans-unit id="6f9a670d4aa69b73fdbaf199b1f0dd8253423bff" translate="yes" xml:space="preserve">
          <source>HashSet::insert</source>
          <target state="translated">HashSet::insert</target>
        </trans-unit>
        <trans-unit id="5c5bf765bc94406fc16ab265fee5caf8d4d6d147" translate="yes" xml:space="preserve">
          <source>HashSet::intersection</source>
          <target state="translated">HashSet::intersection</target>
        </trans-unit>
        <trans-unit id="1847c872f1c798ce2ed7fda1f927b3db87be02ae" translate="yes" xml:space="preserve">
          <source>HashSet::into</source>
          <target state="translated">HashSet::into</target>
        </trans-unit>
        <trans-unit id="06dc65fe61329213ae7394dadf80b120758e58bf" translate="yes" xml:space="preserve">
          <source>HashSet::into_iter</source>
          <target state="translated">HashSet::into_iter</target>
        </trans-unit>
        <trans-unit id="67c6eb738c50bfb089cc9e9dd3c556b76c5e5a19" translate="yes" xml:space="preserve">
          <source>HashSet::is_disjoint</source>
          <target state="translated">HashSet::is_disjoint</target>
        </trans-unit>
        <trans-unit id="9463f6acefaba610600eb7b086516e06a56e7415" translate="yes" xml:space="preserve">
          <source>HashSet::is_empty</source>
          <target state="translated">HashSet::is_empty</target>
        </trans-unit>
        <trans-unit id="3494ecfcdfcc0fd49b4716ada245492c590484c8" translate="yes" xml:space="preserve">
          <source>HashSet::is_subset</source>
          <target state="translated">HashSet::is_subset</target>
        </trans-unit>
        <trans-unit id="5a5bed7c64ac7bd90ff2fd3978bbf37d738addfa" translate="yes" xml:space="preserve">
          <source>HashSet::is_superset</source>
          <target state="translated">HashSet::is_superset</target>
        </trans-unit>
        <trans-unit id="d4aa44a96215a84918fccfb358fa46f4343aa9e3" translate="yes" xml:space="preserve">
          <source>HashSet::iter</source>
          <target state="translated">HashSet::iter</target>
        </trans-unit>
        <trans-unit id="e772fc3259c95bf6f1d149e4fe5b58f7beb84957" translate="yes" xml:space="preserve">
          <source>HashSet::len</source>
          <target state="translated">HashSet::len</target>
        </trans-unit>
        <trans-unit id="9d950bd82fcd2e87760e296232658decf6487907" translate="yes" xml:space="preserve">
          <source>HashSet::ne</source>
          <target state="translated">HashSet::ne</target>
        </trans-unit>
        <trans-unit id="faff6aa961e961cb5d0e5be8b0c1765f5a91c089" translate="yes" xml:space="preserve">
          <source>HashSet::new</source>
          <target state="translated">HashSet::new</target>
        </trans-unit>
        <trans-unit id="ab12b0529a6e1a5dea72839456e2d81f89fbb648" translate="yes" xml:space="preserve">
          <source>HashSet::remove</source>
          <target state="translated">HashSet::remove</target>
        </trans-unit>
        <trans-unit id="11dfa3918fa59c9dba2c405236023985e68113d1" translate="yes" xml:space="preserve">
          <source>HashSet::replace</source>
          <target state="translated">HashSet::replace</target>
        </trans-unit>
        <trans-unit id="f3111bd9bb9284dd24b994e9c70b335390828fac" translate="yes" xml:space="preserve">
          <source>HashSet::reserve</source>
          <target state="translated">HashSet::reserve</target>
        </trans-unit>
        <trans-unit id="ce64d74e2bc22c15cfa1eaba2edb312838993eda" translate="yes" xml:space="preserve">
          <source>HashSet::retain</source>
          <target state="translated">HashSet::retain</target>
        </trans-unit>
        <trans-unit id="029a9cdc9ae9ee65ed460a0ec02d113e093964b2" translate="yes" xml:space="preserve">
          <source>HashSet::shrink_to</source>
          <target state="translated">HashSet::shrink_to</target>
        </trans-unit>
        <trans-unit id="3aba29e196a563c0a26e6c5d67e4388b6713cebf" translate="yes" xml:space="preserve">
          <source>HashSet::shrink_to_fit</source>
          <target state="translated">HashSet::shrink_to_fit</target>
        </trans-unit>
        <trans-unit id="137d5ee967421f3423450e1436080f3b38640647" translate="yes" xml:space="preserve">
          <source>HashSet::sub</source>
          <target state="translated">HashSet::sub</target>
        </trans-unit>
        <trans-unit id="39cf21ce1dee41e9b1e7cb0c554d9ccf20702455" translate="yes" xml:space="preserve">
          <source>HashSet::symmetric_difference</source>
          <target state="translated">HashSet::symmetric_difference</target>
        </trans-unit>
        <trans-unit id="b78b12fa7d65d7ed557c2e12c743c86bcbc88775" translate="yes" xml:space="preserve">
          <source>HashSet::take</source>
          <target state="translated">HashSet::take</target>
        </trans-unit>
        <trans-unit id="93138236c5609c2dee4b1e913e9fcc9e3e9fdf44" translate="yes" xml:space="preserve">
          <source>HashSet::to_owned</source>
          <target state="translated">HashSet::to_owned</target>
        </trans-unit>
        <trans-unit id="96f13425b733a2e08673b87dffc523aee111609b" translate="yes" xml:space="preserve">
          <source>HashSet::try_from</source>
          <target state="translated">HashSet::try_from</target>
        </trans-unit>
        <trans-unit id="85d076b1561829592d046d057f0210cf9a4ff355" translate="yes" xml:space="preserve">
          <source>HashSet::try_into</source>
          <target state="translated">HashSet::try_into</target>
        </trans-unit>
        <trans-unit id="a9c0b3c82611415705e046ee581719e01be9eecc" translate="yes" xml:space="preserve">
          <source>HashSet::try_reserve</source>
          <target state="translated">HashSet::try_reserve</target>
        </trans-unit>
        <trans-unit id="105a18b817256119cb17af97da897c56eba29e40" translate="yes" xml:space="preserve">
          <source>HashSet::type_id</source>
          <target state="translated">HashSet::type_id</target>
        </trans-unit>
        <trans-unit id="685fa7682d344986ee2f2ae55086a7531364bc35" translate="yes" xml:space="preserve">
          <source>HashSet::union</source>
          <target state="translated">HashSet::union</target>
        </trans-unit>
        <trans-unit id="c3204331b41dcd6ae424437b8e36081a10f0c506" translate="yes" xml:space="preserve">
          <source>HashSet::with_capacity</source>
          <target state="translated">HashSet::with_capacity</target>
        </trans-unit>
        <trans-unit id="6bb25440ddefbed0a8db0d432f23f0ca38d089d8" translate="yes" xml:space="preserve">
          <source>HashSet::with_capacity_and_hasher</source>
          <target state="translated">HashSet::with_capacity_and_hasher</target>
        </trans-unit>
        <trans-unit id="550d3800dfa4eb2bdb493d733dabf4b1ffabf984" translate="yes" xml:space="preserve">
          <source>HashSet::with_hasher</source>
          <target state="translated">HashSet::with_hasher</target>
        </trans-unit>
        <trans-unit id="fc0f48d98ae0d2092a247d5cee9ccdb867d1d001" translate="yes" xml:space="preserve">
          <source>Hasher</source>
          <target state="translated">Hasher</target>
        </trans-unit>
        <trans-unit id="e9a193bcbf138ba881c64b5b1a29eba015da6009" translate="yes" xml:space="preserve">
          <source>Hasher::finish</source>
          <target state="translated">Hasher::finish</target>
        </trans-unit>
        <trans-unit id="2b1c79f133b4285e8cbe820d3b0dbaa110a81b6c" translate="yes" xml:space="preserve">
          <source>Hasher::write</source>
          <target state="translated">Hasher::write</target>
        </trans-unit>
        <trans-unit id="aea45433ea07ad24495217b0093e410e9770ebb6" translate="yes" xml:space="preserve">
          <source>Hasher::write_i128</source>
          <target state="translated">Hasher::write_i128</target>
        </trans-unit>
        <trans-unit id="f97466e2fd5ec3a618a0b518a5dd39118b1b15e0" translate="yes" xml:space="preserve">
          <source>Hasher::write_i16</source>
          <target state="translated">Hasher::write_i16</target>
        </trans-unit>
        <trans-unit id="10de8ddcd6d092ee0ae793c2f146d59545948d06" translate="yes" xml:space="preserve">
          <source>Hasher::write_i32</source>
          <target state="translated">Hasher::write_i32</target>
        </trans-unit>
        <trans-unit id="fa2e80124215b4059a687baa99ddde7e8adc899d" translate="yes" xml:space="preserve">
          <source>Hasher::write_i64</source>
          <target state="translated">Hasher::write_i64</target>
        </trans-unit>
        <trans-unit id="fe5b0947dfe31def847c17d1e11ec3d408a4124c" translate="yes" xml:space="preserve">
          <source>Hasher::write_i8</source>
          <target state="translated">Hasher::write_i8</target>
        </trans-unit>
        <trans-unit id="53164f3f3dd297fb85292187a041f87e1d16695e" translate="yes" xml:space="preserve">
          <source>Hasher::write_isize</source>
          <target state="translated">Hasher::write_isize</target>
        </trans-unit>
        <trans-unit id="e477fb5169da10ce163639bd122b949d5314f471" translate="yes" xml:space="preserve">
          <source>Hasher::write_u128</source>
          <target state="translated">Hasher::write_u128</target>
        </trans-unit>
        <trans-unit id="05c5de3720de3f253e1541c3b244cb58450b4be2" translate="yes" xml:space="preserve">
          <source>Hasher::write_u16</source>
          <target state="translated">Hasher::write_u16</target>
        </trans-unit>
        <trans-unit id="1cf90d27fda48a3335fb25c8aa60e25c50bc3767" translate="yes" xml:space="preserve">
          <source>Hasher::write_u32</source>
          <target state="translated">Hasher::write_u32</target>
        </trans-unit>
        <trans-unit id="420bdb25cc27d8fac4c5399c4359ccee510eacbd" translate="yes" xml:space="preserve">
          <source>Hasher::write_u64</source>
          <target state="translated">Hasher::write_u64</target>
        </trans-unit>
        <trans-unit id="82a921392efa7001c790d5b80024db7be281f9cb" translate="yes" xml:space="preserve">
          <source>Hasher::write_u8</source>
          <target state="translated">Hasher::write_u8</target>
        </trans-unit>
        <trans-unit id="d1a0408c2f79ae7c9f420468772c41716a5e1a04" translate="yes" xml:space="preserve">
          <source>Hasher::write_usize</source>
          <target state="translated">Hasher::write_usize</target>
        </trans-unit>
        <trans-unit id="461629db972167b8f4c1f8c130db9885c4944304" translate="yes" xml:space="preserve">
          <source>Hashing Functions</source>
          <target state="translated">哈希函数</target>
        </trans-unit>
        <trans-unit id="baf48f49b04e2fe65712d113e9024e4c5a00d1bc" translate="yes" xml:space="preserve">
          <source>Haskell (GHC): typeclasses, type families</source>
          <target state="translated">Haskell (GHC):类型类,类型族。</target>
        </trans-unit>
        <trans-unit id="0561de3a6257f6d36364146fd6581f1315dd2333" translate="yes" xml:space="preserve">
          <source>Having &lt;code&gt;common&lt;/code&gt; appear in the test results with &lt;code&gt;running 0 tests&lt;/code&gt; displayed for it is not what we wanted. We just wanted to share some code with the other integration test files.</source>
          <target state="translated">在测试结果中出现 &lt;code&gt;common&lt;/code&gt; 变量并显示 &lt;code&gt;running 0 tests&lt;/code&gt; 不是我们想要的。我们只想与其他集成测试文件共享一些代码。</target>
        </trans-unit>
        <trans-unit id="11f087b15a668ce62e66a014863909ef9d55cd94" translate="yes" xml:space="preserve">
          <source>Having Multiple Owners of Mutable Data by Combining &lt;code id=&quot;having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt&quot;&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="translated">通过组合 &lt;code id=&quot;having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt&quot;&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 具有可变数据的多个所有者</target>
        </trans-unit>
        <trans-unit id="b3039ad6abf86928bcfdadaa49d3256f9e624f29" translate="yes" xml:space="preserve">
          <source>Having multiple relaxed default bounds is unsupported.</source>
          <target state="translated">拥有多个放宽的默认边界是不支持的。</target>
        </trans-unit>
        <trans-unit id="6b19652c5d2b3e9984ece4975d1cc403d1ab4a0a" translate="yes" xml:space="preserve">
          <source>Having one mutable reference (&lt;code&gt;&amp;amp;mut T&lt;/code&gt;) to the object (also known as &lt;strong&gt;mutability&lt;/strong&gt;).</source>
          <target state="translated">对对象有一个可变引用（ &lt;code&gt;&amp;amp;mut T&lt;/code&gt; ）（也称为&lt;strong&gt;mutability&lt;/strong&gt;）。</target>
        </trans-unit>
        <trans-unit id="08041929016b8a695800e1c093d6357eb61d9428" translate="yes" xml:space="preserve">
          <source>Having several immutable references (&lt;code&gt;&amp;amp;T&lt;/code&gt;) to the object (also known as &lt;strong&gt;aliasing&lt;/strong&gt;).</source>
          <target state="translated">对对象有几个不可变的引用（ &lt;code&gt;&amp;amp;T&lt;/code&gt; ）（也称为&lt;strong&gt;别名&lt;/strong&gt;）。</target>
        </trans-unit>
        <trans-unit id="89c8fa1c2c4d0b146e76f764a7dc959cbfc87737" translate="yes" xml:space="preserve">
          <source>Having to worry about the index in &lt;code&gt;word&lt;/code&gt; getting out of sync with the data in &lt;code&gt;s&lt;/code&gt; is tedious and error prone! Managing these indices is even more brittle if we write a &lt;code&gt;second_word&lt;/code&gt; function. Its signature would have to look like this:</source>
          <target state="translated">不必担心 &lt;code&gt;word&lt;/code&gt; 中的索引与 &lt;code&gt;s&lt;/code&gt; 中的数据不同步，这既繁琐又容易出错！如果我们编写 &lt;code&gt;second_word&lt;/code&gt; 函数，则管理这些索引的难度更大。其签名必须如下所示：</target>
        </trans-unit>
        <trans-unit id="257810d9a0b57b3d3f2b083b4e88460a9ed6c299" translate="yes" xml:space="preserve">
          <source>Hello, Cargo!</source>
          <target state="translated">你好,货郎!</target>
        </trans-unit>
        <trans-unit id="0a0a9f2a6772942557ab5355d76af442f8f65e01" translate="yes" xml:space="preserve">
          <source>Hello, World!</source>
          <target state="translated">你好,世界!</target>
        </trans-unit>
        <trans-unit id="d9d2b1e388fd73fa4e7cc0203db99342ed1255e1" translate="yes" xml:space="preserve">
          <source>Helper struct for safely printing paths with &lt;a href=&quot;../macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;{}&lt;/code&gt;.</source>
          <target state="translated">帮助程序结构，可安全打印带有&lt;a href=&quot;../macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt;路径！和 &lt;code&gt;{}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e8498955fde08da370bacddfd1434e8493282db8" translate="yes" xml:space="preserve">
          <source>Helper trait for &lt;a href=&quot;../primitive.slice#method.concat&quot;&gt;&lt;code&gt;[T]::concat&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../primitive.slice#method.concat&quot;&gt; &lt;code&gt;[T]::concat&lt;/code&gt; 的&lt;/a&gt;辅助特性。</target>
        </trans-unit>
        <trans-unit id="bbdd82587ac5843ce3d9f6e79bf40efba742c5a2" translate="yes" xml:space="preserve">
          <source>Helper trait for &lt;a href=&quot;../primitive.slice#method.join&quot;&gt;&lt;code&gt;[T]::join&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../primitive.slice#method.join&quot;&gt; &lt;code&gt;[T]::join&lt;/code&gt; 的&lt;/a&gt;辅助特征</target>
        </trans-unit>
        <trans-unit id="d8870a3f309d445b4b67cf35abad15e6e3e773d8" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;T&lt;/code&gt; is a trait object with two explicit lifetime bounds, 'a and 'b.</source>
          <target state="translated">这里 &lt;code&gt;T&lt;/code&gt; 是具有两个显式生命周期边界'a和'b的特征对象。</target>
        </trans-unit>
        <trans-unit id="5c4fbb21f9ed5068758832ea51d122515fab93c7" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;X&lt;/code&gt; will have already been specified the discriminant 0 by the time &lt;code&gt;Y&lt;/code&gt; is encountered, so a conflict occurs.</source>
          <target state="translated">在这里，到遇到 &lt;code&gt;Y&lt;/code&gt; 时，已经将 &lt;code&gt;X&lt;/code&gt; 指定为判别式0 ，因此发生冲突。</target>
        </trans-unit>
        <trans-unit id="b3f6e00f3163ec48a9acfd477c8ec87919fc2c8c" translate="yes" xml:space="preserve">
          <source>Here are a couple examples of this error:</source>
          <target state="translated">这里有几个例子可以说明这个错误。</target>
        </trans-unit>
        <trans-unit id="8ff34494ac843686469f6f02e338741820201079" translate="yes" xml:space="preserve">
          <source>Here are examples of the comparison operators being used.</source>
          <target state="translated">下面是使用比较运算符的例子。</target>
        </trans-unit>
        <trans-unit id="bca374bff5c3dac21037ded7599cd1fe12249f7d" translate="yes" xml:space="preserve">
          <source>Here are examples of these operators being used.</source>
          <target state="translated">下面是这些运算符的使用实例。</target>
        </trans-unit>
        <trans-unit id="07272e166a1d2e40b130f94ad3a0aa3df774ca3b" translate="yes" xml:space="preserve">
          <source>Here are similar examples but now for LAST.</source>
          <target state="translated">这里有类似的例子,但现在是LAST。</target>
        </trans-unit>
        <trans-unit id="0a1abd5c7569db9404cdcd75f1cc6cdc0c6dca93" translate="yes" xml:space="preserve">
          <source>Here are some example of these operators</source>
          <target state="translated">下面是这些运算符的一些例子</target>
        </trans-unit>
        <trans-unit id="4684b015ded3bc0731a2cef8198e5596403f6b07" translate="yes" xml:space="preserve">
          <source>Here are some examples of elision errors:</source>
          <target state="translated">下面是一些洗脱错误的例子。</target>
        </trans-unit>
        <trans-unit id="4bcc69e7a08f9cc053bd0cff82d93712f586660e" translate="yes" xml:space="preserve">
          <source>Here are some examples where expressions don't have extended temporary scopes:</source>
          <target state="translated">下面是一些表达式没有扩展临时范围的例子。</target>
        </trans-unit>
        <trans-unit id="c92962597dc4ffea4ff897a85b4d5e4dec6ca581" translate="yes" xml:space="preserve">
          <source>Here are some examples where expressions have extended temporary scopes:</source>
          <target state="translated">下面是一些表达式具有扩展临时范围的例子。</target>
        </trans-unit>
        <trans-unit id="0931022beea83b3afc095873234631b7243eeca4" translate="yes" xml:space="preserve">
          <source>Here are some examples:</source>
          <target state="translated">下面是一些例子。</target>
        </trans-unit>
        <trans-unit id="51de71d79af0f5165810b64b8288dc0e2f418033" translate="yes" xml:space="preserve">
          <source>Here are some examples: a reference to an &lt;code&gt;i32&lt;/code&gt; without a lifetime parameter, a reference to an &lt;code&gt;i32&lt;/code&gt; that has a lifetime parameter named &lt;code&gt;'a&lt;/code&gt;, and a mutable reference to an &lt;code&gt;i32&lt;/code&gt; that also has the lifetime &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="translated">下面是一些例子：一个基准 &lt;code&gt;i32&lt;/code&gt; 没有寿命参数，所涉及的参考 &lt;code&gt;i32&lt;/code&gt; 具有命名为寿命参数 &lt;code&gt;'a&lt;/code&gt; ，和一个可变引用到 &lt;code&gt;i32&lt;/code&gt; 也具有寿命 &lt;code&gt;'a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="20d5c7a1de98768721ba1e4861f1afaf92322548" translate="yes" xml:space="preserve">
          <source>Here are some of the things this module contains:</source>
          <target state="translated">下面是这个模块包含的一些内容。</target>
        </trans-unit>
        <trans-unit id="2a92602de41a70e7040e9f2a4fb9598c573570c2" translate="yes" xml:space="preserve">
          <source>Here are some simple examples of where you'll run into this error:</source>
          <target state="translated">下面是一些简单的例子,说明你会在哪里遇到这个错误。</target>
        </trans-unit>
        <trans-unit id="3a02d5c5d61bf51906767acca68761775d677fe8" translate="yes" xml:space="preserve">
          <source>Here are the abilities Unsafe Rust has in addition to Safe Rust:</source>
          <target state="translated">下面是不安全锈除了安全锈之外的能力。</target>
        </trans-unit>
        <trans-unit id="5b8f26110eb51a4ab181ea0b693d59c927775bab" translate="yes" xml:space="preserve">
          <source>Here are the topics we&amp;rsquo;ll cover in this chapter:</source>
          <target state="translated">以下是本章将涉及的主题：</target>
        </trans-unit>
        <trans-unit id="bc16616a997e1c54d6f12cfc92a13207a77b9160" translate="yes" xml:space="preserve">
          <source>Here are the two primary ways in which &lt;code&gt;entry&lt;/code&gt; is used. First, a simple example where the logic performed on the values is trivial.</source>
          <target state="translated">这是使用 &lt;code&gt;entry&lt;/code&gt; 的两种主要方法。首先，一个简单的示例，其中对值执行的逻辑很简单。</target>
        </trans-unit>
        <trans-unit id="8d3de595e318046b488878fdfd592e24474accd6" translate="yes" xml:space="preserve">
          <source>Here executing &lt;code&gt;x = None&lt;/code&gt; would modify the value being matched and require us to go &quot;back in time&quot; to the &lt;code&gt;None&lt;/code&gt; arm.</source>
          <target state="translated">在这里执行 &lt;code&gt;x = None&lt;/code&gt; 将修改匹配的值，并要求我们&amp;ldquo;及时&amp;rdquo;返回 &lt;code&gt;None&lt;/code&gt; 分支。</target>
        </trans-unit>
        <trans-unit id="b54fff02e5e3fe8139f3151b798d2ca6781ef79d" translate="yes" xml:space="preserve">
          <source>Here executing &lt;code&gt;x = None&lt;/code&gt; would modify the value being matched and require us to go &quot;back in time&quot; to the &lt;code&gt;None&lt;/code&gt; arm. To fix it, change the value in the match arm:</source>
          <target state="translated">在这里执行 &lt;code&gt;x = None&lt;/code&gt; 将修改匹配的值，并要求我们&amp;ldquo;回到过去&amp;rdquo;到 &lt;code&gt;None&lt;/code&gt; 分支。要解决此问题，请更改匹配臂中的值：</target>
        </trans-unit>
        <trans-unit id="87b503ee6f76be5b3f344961161f897b4c2e8a33" translate="yes" xml:space="preserve">
          <source>Here is a basic example:</source>
          <target state="translated">下面是一个基本的例子。</target>
        </trans-unit>
        <trans-unit id="40d986bccf61bb4616c6b2d5e45138cb6f650868" translate="yes" xml:space="preserve">
          <source>Here is a recap of the reasons to choose &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;, or &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">这是选择 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; ， &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 或 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 的原因的概述：</target>
        </trans-unit>
        <trans-unit id="2fd70c4f72651018616cf4fae80bda013db29aef" translate="yes" xml:space="preserve">
          <source>Here is a variation on the previous example, showing that no further elements are taken from &lt;code&gt;iter&lt;/code&gt; after the first &lt;code&gt;Err&lt;/code&gt;.</source>
          <target state="translated">这是前一个示例的变体，显示在第一个 &lt;code&gt;Err&lt;/code&gt; 之后没有从 &lt;code&gt;iter&lt;/code&gt; 中获取其他元素。</target>
        </trans-unit>
        <trans-unit id="f2d33e000bef3fae0bc1e18459c72a6974d4c8ec" translate="yes" xml:space="preserve">
          <source>Here is a variation on the previous example, showing that no further elements are taken from &lt;code&gt;iter&lt;/code&gt; after the first &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">这是前一个示例的变体，显示在第一个 &lt;code&gt;None&lt;/code&gt; 之后没有从 &lt;code&gt;iter&lt;/code&gt; 中获取其他元素。</target>
        </trans-unit>
        <trans-unit id="64fa9f151e952c55124309eb57d3e7e04cdb27ce" translate="yes" xml:space="preserve">
          <source>Here is an example of the same &lt;code&gt;Point&lt;/code&gt; struct implementing the &lt;code&gt;Add&lt;/code&gt; trait using generics.</source>
          <target state="translated">这是使用泛型实现 &lt;code&gt;Add&lt;/code&gt; trait 的相同 &lt;code&gt;Point&lt;/code&gt; 结构的示例。</target>
        </trans-unit>
        <trans-unit id="f4eeb15c7a7b93e1eb2dc6a8750be5fd94bbc8b2" translate="yes" xml:space="preserve">
          <source>Here is an example of the same &lt;code&gt;Point&lt;/code&gt; struct implementing the &lt;code&gt;Sub&lt;/code&gt; trait using generics.</source>
          <target state="translated">这是使用泛型实现 &lt;code&gt;Sub&lt;/code&gt; trait 的相同 &lt;code&gt;Point&lt;/code&gt; 结构的示例。</target>
        </trans-unit>
        <trans-unit id="e2a455b6868a34c4c660661290fdc27380049549" translate="yes" xml:space="preserve">
          <source>Here is an example response that uses HTTP version 1.1, has a status code of 200, an OK reason phrase, no headers, and no body:</source>
          <target state="translated">下面是一个使用HTTP版本1.1的响应示例,状态码为200,有一个OK的原因短语,没有头信息,也没有正文。</target>
        </trans-unit>
        <trans-unit id="8d3dccad44a11aba4a0bfd15fb7b2845992244bd" translate="yes" xml:space="preserve">
          <source>Here is an example showcasing how to soundly mutate the contents of an &lt;code&gt;UnsafeCell&amp;lt;_&amp;gt;&lt;/code&gt; despite there being multiple references aliasing the cell:</source>
          <target state="translated">这是一个示例，展示了如何对 &lt;code&gt;UnsafeCell&amp;lt;_&amp;gt;&lt;/code&gt; 的内容进行合理的突变，尽管有多个引用使单元格出现别名：</target>
        </trans-unit>
        <trans-unit id="f7c4ae388ef10758f9c1ee112d05af3dedb5a8c1" translate="yes" xml:space="preserve">
          <source>Here is an example that demonstrates the error:</source>
          <target state="translated">这里有一个例子可以证明这个错误。</target>
        </trans-unit>
        <trans-unit id="eb168180e8af601284ef4a6f97cd122e9d48a93f" translate="yes" xml:space="preserve">
          <source>Here is an example using ranges of &lt;code&gt;char&lt;/code&gt; values:</source>
          <target state="translated">这是使用 &lt;code&gt;char&lt;/code&gt; 值范围的示例：</target>
        </trans-unit>
        <trans-unit id="2190806deeaf3eb0d2b99ddd8ded1889adb9e2dc" translate="yes" xml:space="preserve">
          <source>Here is an example where the third lifetime elision rule applies:</source>
          <target state="translated">下面是一个适用于第三种终身洗脱规则的例子。</target>
        </trans-unit>
        <trans-unit id="8be714949bc61ee0dfb58dd8b6d077f499efa300" translate="yes" xml:space="preserve">
          <source>Here is an example which increments every integer in a vector, checking for overflow:</source>
          <target state="translated">下面是一个例子,它对一个向量中的每一个整数进行递增,检查是否有溢出。</target>
        </trans-unit>
        <trans-unit id="b8d2a1ec18a168b45aede187d064b1d87d98387f" translate="yes" xml:space="preserve">
          <source>Here is an example which increments every integer in a vector. We use the checked variant of &lt;code&gt;add&lt;/code&gt; that returns &lt;code&gt;None&lt;/code&gt; when the calculation would result in an overflow.</source>
          <target state="translated">这是一个使向量中的每个整数递增的示例。我们使用选中的 &lt;code&gt;add&lt;/code&gt; 变体，当计算将导致溢出时，该变体返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="669e450458761957293db53fc0e8c919ba0f5a7a" translate="yes" xml:space="preserve">
          <source>Here is an unsafe function named &lt;code&gt;dangerous&lt;/code&gt; that doesn&amp;rsquo;t do anything in its body:</source>
          <target state="translated">这是一个不安全的函数，名称为 &lt;code&gt;dangerous&lt;/code&gt; ，不会在体内起作用：</target>
        </trans-unit>
        <trans-unit id="d9606eca0f59289409929077841f751f72b656be" translate="yes" xml:space="preserve">
          <source>Here is another example that tries to subtract one from another list of integers, this time checking for underflow:</source>
          <target state="translated">下面是另一个试图从另一个整数列表中减去一个的例子,这次是检查是否有下溢。</target>
        </trans-unit>
        <trans-unit id="967e8f702b29651ccfd3eff162bdd1236f185e1b" translate="yes" xml:space="preserve">
          <source>Here is how you would define and use a &lt;code&gt;calculate_length&lt;/code&gt; function that has a reference to an object as a parameter instead of taking ownership of the value:</source>
          <target state="translated">这是定义和使用对对象的引用作为参数而不是拥有值所有权的 &lt;code&gt;calculate_length&lt;/code&gt; 函数的方式：</target>
        </trans-unit>
        <trans-unit id="853cb0e889b6e921d08e41239a16f75171fa3cf1" translate="yes" xml:space="preserve">
          <source>Here is that same example again, with some explanatory comments:</source>
          <target state="translated">下面是同样的例子,再加上一些解释性的评论。</target>
        </trans-unit>
        <trans-unit id="183c940df02f2ac1c7e0b320aa5e4607c7fd14f0" translate="yes" xml:space="preserve">
          <source>Here is the error we get when we compile this code:</source>
          <target state="translated">这是我们编译这段代码时得到的错误。</target>
        </trans-unit>
        <trans-unit id="20e589c1d30a718b69866f0e87eb12f8b53bb806" translate="yes" xml:space="preserve">
          <source>Here is the plan to build the web server:</source>
          <target state="translated">以下是构建Web服务器的计划。</target>
        </trans-unit>
        <trans-unit id="c50f83c6cf619c1c5fb8951e5f26cafe1c807151" translate="yes" xml:space="preserve">
          <source>Here is the previous example again, with the correct order:</source>
          <target state="translated">这里又是前面的例子,顺序正确。</target>
        </trans-unit>
        <trans-unit id="c6b6ce6ac56caf7839b74c32ae618de3ed902bea" translate="yes" xml:space="preserve">
          <source>Here is this algorithm described in pseudocode.</source>
          <target state="translated">下面是用伪代码描述的这个算法。</target>
        </trans-unit>
        <trans-unit id="5ade7d43a649a8f35a37c5c4df50d404ac17d264" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;Apple&lt;/code&gt; variant has two fields, and should be matched against like so:</source>
          <target state="translated">在这里， &lt;code&gt;Apple&lt;/code&gt; 变体有两个字段，应该像这样进行匹配：</target>
        </trans-unit>
        <trans-unit id="847a36b4e8f5bc18d0a990ee9501fe6c952a3db3" translate="yes" xml:space="preserve">
          <source>Here the type &lt;code&gt;T&lt;/code&gt; cannot have a relaxed bound for multiple default traits (&lt;code&gt;Sized&lt;/code&gt; and &lt;code&gt;Send&lt;/code&gt;). This can be fixed by only using one relaxed bound.</source>
          <target state="translated">在这里，类型 &lt;code&gt;T&lt;/code&gt; 不能对多个默认特征（ &lt;code&gt;Sized&lt;/code&gt; 和 &lt;code&gt;Send&lt;/code&gt; ）具有宽松的界限。只能使用一个宽松的界限来解决此问题。</target>
        </trans-unit>
        <trans-unit id="77492962523ab1872ec0db64f3e31206c8e37741" translate="yes" xml:space="preserve">
          <source>Here we create &lt;code&gt;Status::Value&lt;/code&gt; instances using each &lt;code&gt;u32&lt;/code&gt; value in the range that &lt;code&gt;map&lt;/code&gt; is called on by using the initializer function of &lt;code&gt;Status::Value&lt;/code&gt;. Some people prefer this style, and some people prefer to use closures. They compile to the same code, so use whichever style is clearer to you.</source>
          <target state="translated">在这里，我们创建 &lt;code&gt;Status::Value&lt;/code&gt; 使用每个实例 &lt;code&gt;u32&lt;/code&gt; 范围内的值 &lt;code&gt;map&lt;/code&gt; 是通过使用的初始化函数呼吁 &lt;code&gt;Status::Value&lt;/code&gt; 。有些人喜欢这种样式，有些人喜欢使用闭包。它们将编译为相同的代码，因此请使用对您更清晰的样式。</target>
        </trans-unit>
        <trans-unit id="ab78b83024b9be055a5f592dcee8323d7eae1a44" translate="yes" xml:space="preserve">
          <source>Here we get a warning about not using the variable &lt;code&gt;y&lt;/code&gt;, but we don&amp;rsquo;t get a warning about not using the variable preceded by the underscore.</source>
          <target state="translated">在这里，我们收到关于不使用变量 &lt;code&gt;y&lt;/code&gt; 的警告，但没有收到关于不使用下划线开头的变量的警告。</target>
        </trans-unit>
        <trans-unit id="c5caa2018a964f99eaa055d4bd09b35c0163bd0e" translate="yes" xml:space="preserve">
          <source>Here we have an addition of &lt;code&gt;d&lt;/code&gt; and &lt;code&gt;n.into()&lt;/code&gt;. Hence, &lt;code&gt;n.into()&lt;/code&gt; can return any type &lt;code&gt;T&lt;/code&gt; where &lt;code&gt;u64: Add&amp;lt;T&amp;gt;&lt;/code&gt;. On the other hand, the &lt;code&gt;into&lt;/code&gt; method can return any type where &lt;code&gt;u32: Into&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">在这里，我们添加了 &lt;code&gt;d&lt;/code&gt; 和 &lt;code&gt;n.into()&lt;/code&gt; 。因此， &lt;code&gt;n.into()&lt;/code&gt; 可以返回任何类型 &lt;code&gt;T&lt;/code&gt; ，其中 &lt;code&gt;u64: Add&amp;lt;T&amp;gt;&lt;/code&gt; 。在另一方面，所述 &lt;code&gt;into&lt;/code&gt; 方法可以返回任何类型，其中 &lt;code&gt;u32: Into&amp;lt;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6c5079a1585dd8c6aa581475ab7d948402fef68" translate="yes" xml:space="preserve">
          <source>Here we have an iterator &lt;code&gt;results&lt;/code&gt; over &lt;code&gt;Result&amp;lt;bool, ()&amp;gt;&lt;/code&gt;. Hence, &lt;code&gt;results.collect()&lt;/code&gt; can return any type implementing &lt;code&gt;FromIterator&amp;lt;Result&amp;lt;bool, ()&amp;gt;&amp;gt;&lt;/code&gt;. On the other hand, the &lt;code&gt;?&lt;/code&gt; operator can accept any type implementing &lt;code&gt;Try&lt;/code&gt;.</source>
          <target state="translated">在这里，我们在 &lt;code&gt;Result&amp;lt;bool, ()&amp;gt;&lt;/code&gt; 有一个迭代器 &lt;code&gt;results&lt;/code&gt; 。因此， &lt;code&gt;results.collect()&lt;/code&gt; 可以返回实现 &lt;code&gt;FromIterator&amp;lt;Result&amp;lt;bool, ()&amp;gt;&amp;gt;&lt;/code&gt; 任何类型。另一方面， &lt;code&gt;?&lt;/code&gt; 操作员可以接受实现 &lt;code&gt;Try&lt;/code&gt; 的任何类型。</target>
        </trans-unit>
        <trans-unit id="cb5b6fe6a43391cbaff0a797a1749d4999cf682c" translate="yes" xml:space="preserve">
          <source>Here we have declared a string literal, also known as a string slice. String literals have a static lifetime, which means the string &lt;code&gt;hello_world&lt;/code&gt; is guaranteed to be valid for the duration of the entire program. We can explicitly specify &lt;code&gt;hello_world&lt;/code&gt;'s lifetime as well:</source>
          <target state="translated">在这里，我们声明了字符串文字，也称为字符串切片。字符串文字具有静态的生存期，这意味着字符串 &lt;code&gt;hello_world&lt;/code&gt; 在整个程序期间均有效。我们还可以显式指定 &lt;code&gt;hello_world&lt;/code&gt; 的生存期：</target>
        </trans-unit>
        <trans-unit id="4f6025ae753da089e1d8586a3532b960124e6dc6" translate="yes" xml:space="preserve">
          <source>Here we have used the &lt;code&gt;continue&lt;/code&gt; keyword incorrectly. As we have seen above that &lt;code&gt;continue&lt;/code&gt; pointing to a labeled block.</source>
          <target state="translated">在这里，我们错误地使用了 &lt;code&gt;continue&lt;/code&gt; 关键字。正如我们在上面看到的， &lt;code&gt;continue&lt;/code&gt; 指向标记的块。</target>
        </trans-unit>
        <trans-unit id="c6a5e69251fb02d97a8da5895df070cb741e7a14" translate="yes" xml:space="preserve">
          <source>Here we see that &lt;code&gt;flatten()&lt;/code&gt; does not perform a &quot;deep&quot; flatten. Instead, only one level of nesting is removed. That is, if you &lt;code&gt;flatten()&lt;/code&gt; a three-dimensional array the result will be two-dimensional and not one-dimensional. To get a one-dimensional structure, you have to &lt;code&gt;flatten()&lt;/code&gt; again.</source>
          <target state="translated">在这里，我们看到 &lt;code&gt;flatten()&lt;/code&gt; 不会执行&amp;ldquo;深度&amp;rdquo;展平。相反，仅删除了一层嵌套。也就是说，如果您 &lt;code&gt;flatten()&lt;/code&gt; 一个三维数组，结果将是二维的，而不是一维的。要获得一维结构，您必须再次 &lt;code&gt;flatten()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a68f46a9824264b24451a84ac750d17db4375f1c" translate="yes" xml:space="preserve">
          <source>Here we see that &lt;code&gt;flatten()&lt;/code&gt; does not perform a &quot;deep&quot; flatten. Instead, only one level of nesting is removed. That is, if you &lt;code&gt;flatten()&lt;/code&gt; a three-dimensional array, the result will be two-dimensional and not one-dimensional. To get a one-dimensional structure, you have to &lt;code&gt;flatten()&lt;/code&gt; again.</source>
          <target state="translated">在这里，我们看到 &lt;code&gt;flatten()&lt;/code&gt; 不会执行&amp;ldquo;深度&amp;rdquo;展平。取而代之的是，仅删除了一层嵌套。也就是说，如果您 &lt;code&gt;flatten()&lt;/code&gt; 一个三维数组，结果将是二维而不是一维的。要获得一维结构，您必须再次 &lt;code&gt;flatten()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="72ccb25410f6e8d0ac401f0e115875ab4db2e28c" translate="yes" xml:space="preserve">
          <source>Here we tell Rust that when the result is &lt;code&gt;Ok&lt;/code&gt;, return the inner &lt;code&gt;file&lt;/code&gt; value out of the &lt;code&gt;Ok&lt;/code&gt; variant, and we then assign that file handle value to the variable &lt;code&gt;f&lt;/code&gt;. After the &lt;code&gt;match&lt;/code&gt;, we can use the file handle for reading or writing.</source>
          <target state="translated">在这里，我们告诉Rust，当结果为 &lt;code&gt;Ok&lt;/code&gt; 时，从 &lt;code&gt;Ok&lt;/code&gt; 变量中返回内部 &lt;code&gt;file&lt;/code&gt; 值，然后将文件句柄值分配给变量 &lt;code&gt;f&lt;/code&gt; 。 &lt;code&gt;match&lt;/code&gt; 结束后，我们可以使用文件句柄进行读取或写入。</target>
        </trans-unit>
        <trans-unit id="80012795e5bb9f7fa353370133e88ca78ecd6ec8" translate="yes" xml:space="preserve">
          <source>Here we&amp;rsquo;re calling the &lt;code&gt;hello&lt;/code&gt; function with the argument &lt;code&gt;&amp;amp;m&lt;/code&gt;, which is a reference to a &lt;code&gt;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; value. Because we implemented the &lt;code&gt;Deref&lt;/code&gt; trait on &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; in Listing 15-10, Rust can turn &lt;code&gt;&amp;amp;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; into &lt;code&gt;&amp;amp;String&lt;/code&gt; by calling &lt;code&gt;deref&lt;/code&gt;. The standard library provides an implementation of &lt;code&gt;Deref&lt;/code&gt; on &lt;code&gt;String&lt;/code&gt; that returns a string slice, and this is in the API documentation for &lt;code&gt;Deref&lt;/code&gt;. Rust calls &lt;code&gt;deref&lt;/code&gt; again to turn the &lt;code&gt;&amp;amp;String&lt;/code&gt; into &lt;code&gt;&amp;amp;str&lt;/code&gt;, which matches the &lt;code&gt;hello&lt;/code&gt; function&amp;rsquo;s definition.</source>
          <target state="translated">在这里，我们使用参数 &lt;code&gt;&amp;amp;m&lt;/code&gt; 调用 &lt;code&gt;hello&lt;/code&gt; 函数，该参数是对 &lt;code&gt;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; 值的引用。因为我们在清单15-10中在 &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; 上实现了 &lt;code&gt;Deref&lt;/code&gt; 特征，所以Rust可以通过调用 &lt;code&gt;deref&lt;/code&gt; 将 &lt;code&gt;&amp;amp;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; 转换为 &lt;code&gt;&amp;amp;String&lt;/code&gt; 。标准库提供了对 &lt;code&gt;String&lt;/code&gt; 的 &lt;code&gt;Deref&lt;/code&gt; 的实现，该实现返回一个字符串切片，这在 &lt;code&gt;Deref&lt;/code&gt; 的API文档中。 Rust 再次调用 &lt;code&gt;deref&lt;/code&gt; 将 &lt;code&gt;&amp;amp;String&lt;/code&gt; 变成 &lt;code&gt;&amp;amp;str&lt;/code&gt; ，它与 &lt;code&gt;hello&lt;/code&gt; 匹配 函数的定义。</target>
        </trans-unit>
        <trans-unit id="466e3552c39fe3a92c2d4c054173a56d883575cc" translate="yes" xml:space="preserve">
          <source>Here we&amp;rsquo;ve defined a struct and named it &lt;code&gt;Rectangle&lt;/code&gt;. Inside the curly brackets, we defined the fields as &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt;, both of which have type &lt;code&gt;u32&lt;/code&gt;. Then in &lt;code&gt;main&lt;/code&gt;, we created a particular instance of &lt;code&gt;Rectangle&lt;/code&gt; that has a width of 30 and a height of 50.</source>
          <target state="translated">在这里，我们定义了一个结构并将其命名为 &lt;code&gt;Rectangle&lt;/code&gt; 。在花括号内，我们将字段定义为 &lt;code&gt;width&lt;/code&gt; 和 &lt;code&gt;height&lt;/code&gt; ，它们的类型均为 &lt;code&gt;u32&lt;/code&gt; 。然后在 &lt;code&gt;main&lt;/code&gt; 中，我们创建了一个 &lt;code&gt;Rectangle&lt;/code&gt; 的特定实例，该实例的宽度为30，高度为50。</target>
        </trans-unit>
        <trans-unit id="817f9efff3a295f34cca74e6a4819cd4626be8b2" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a simple comment:</source>
          <target state="translated">这是一个简单的注释：</target>
        </trans-unit>
        <trans-unit id="539936e83a01369f912b07f9a46070e22c533c8a" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a small programming problem: write a function that takes a string and returns the first word it finds in that string. If the function doesn&amp;rsquo;t find a space in the string, the whole string must be one word, so the entire string should be returned.</source>
          <target state="translated">这是一个小的编程问题：编写一个函数，该函数接受一个字符串并返回在该字符串中找到的第一个单词。如果函数在字符串中找不到空格，则整个字符串必须是一个单词，因此应返回整个字符串。</target>
        </trans-unit>
        <trans-unit id="7f3b7e87f399f43770545cc13990ab6cc8dd6c83" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a constant declaration where the constant&amp;rsquo;s name is &lt;code&gt;MAX_POINTS&lt;/code&gt; and its value is set to 100,000. (Rust&amp;rsquo;s naming convention for constants is to use all uppercase with underscores between words, and underscores can be inserted in numeric literals to improve readability):</source>
          <target state="translated">这是一个常量声明的示例，其中常量的名称为 &lt;code&gt;MAX_POINTS&lt;/code&gt; ，其值设置为100,000。 （Rust常量的命名约定是使用所有大写字母在单词之间使用下划线，并且可以在数字文字中插入下划线以提高可读性）：</target>
        </trans-unit>
        <trans-unit id="0e399b9c3b58dba78ca66c0c45518f8657e4f783" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of how the development and release process works: let&amp;rsquo;s assume that the Rust team is working on the release of Rust 1.5. That release happened in December of 2015, but it will provide us with realistic version numbers. A new feature is added to Rust: a new commit lands on the &lt;code&gt;master&lt;/code&gt; branch. Each night, a new nightly version of Rust is produced. Every day is a release day, and these releases are created by our release infrastructure automatically. So as time passes, our releases look like this, once a night:</source>
          <target state="translated">这是一个开发和发布过程如何工作的示例：假设Rust团队正在研究Rust 1.5的发布。该版本发生在2015年12月，但它将为我们提供实际的版本号。Rust中增加了一个新功能：新的提交位于 &lt;code&gt;master&lt;/code&gt; 分支上。每天晚上，都会产生一个每晚的Rust版本。每天都是发布日，这些发布是由我们的发布基础结构自动创建的。因此，随着时间的流逝，我们的发布会像这样，每晚一次：</target>
        </trans-unit>
        <trans-unit id="dd2c057fc04f01fae93788be5795a76d18a55fe9" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of the &lt;code&gt;clone&lt;/code&gt; method in action:</source>
          <target state="translated">这是运行中的 &lt;code&gt;clone&lt;/code&gt; 方法的示例：</target>
        </trans-unit>
        <trans-unit id="01162de636320bfb3aac73f8ee64a4ca8f8b3f36" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example that shows floating-point numbers in action:</source>
          <target state="translated">这是一个显示浮点数的示例：</target>
        </trans-unit>
        <trans-unit id="b756692957834549ddc1e80ed843e1c05120a8e7" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how it works: when you call a method with &lt;code&gt;object.something()&lt;/code&gt;, Rust automatically adds in &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;&amp;amp;mut&lt;/code&gt;, or &lt;code&gt;*&lt;/code&gt; so &lt;code&gt;object&lt;/code&gt; matches the signature of the method. In other words, the following are the same:</source>
          <target state="translated">它的工作方式如下：当使用 &lt;code&gt;object.something()&lt;/code&gt; 调用方法时，Rust自动添加 &lt;code&gt;&amp;amp;&lt;/code&gt; ， &lt;code&gt;&amp;amp;mut&lt;/code&gt; 或 &lt;code&gt;*&lt;/code&gt; ,从而使 &lt;code&gt;object&lt;/code&gt; 与方法的签名匹配。换句话说，以下是相同的：</target>
        </trans-unit>
        <trans-unit id="bbfc2aa9173a426f43e60848a0174bac37b702fe" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the compiler error:</source>
          <target state="translated">这是编译器错误：</target>
        </trans-unit>
        <trans-unit id="7ba4bf6763c0003ca703ce8f7299229f35cbda9a" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the error:</source>
          <target state="translated">这是错误：</target>
        </trans-unit>
        <trans-unit id="916eb038e9d9b0f05a6d2dec1a88d2849aef616b" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the full code for reference:</source>
          <target state="translated">这是完整的代码供参考：</target>
        </trans-unit>
        <trans-unit id="815ea8397604a0309cd918e79463e69ce092e31e" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the resulting compilation error:</source>
          <target state="translated">这是产生的编译错误：</target>
        </trans-unit>
        <trans-unit id="0221cef214e9504c84ca1c9204c7ee34f36785b0" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the scenario we&amp;rsquo;ll test: we&amp;rsquo;ll create a library that tracks a value against a maximum value and sends messages based on how close to the maximum value the current value is. This library could be used to keep track of a user&amp;rsquo;s quota for the number of API calls they&amp;rsquo;re allowed to make, for example.</source>
          <target state="translated">我们将测试以下情况：我们将创建一个库，该库针对最大值跟踪值，并根据当前值与最大值的接近程度发送消息。例如，该库可用于跟踪用户允许他们进行的API调用次数的配额。</target>
        </trans-unit>
        <trans-unit id="3d29162aaec04ffdbb58bf12aa825c48d5666dd6" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s what the countdown would look like using a &lt;code&gt;for&lt;/code&gt; loop and another method we&amp;rsquo;ve not yet talked about, &lt;code&gt;rev&lt;/code&gt;, to reverse the range:</source>
          <target state="translated">这是使用 &lt;code&gt;for&lt;/code&gt; 循环和我们尚未讨论的另一种方法 &lt;code&gt;rev&lt;/code&gt; 来倒数范围的倒数形式：</target>
        </trans-unit>
        <trans-unit id="d3bb7457d5469dff80002a12eb2b6537482105f8" translate="yes" xml:space="preserve">
          <source>Here's an example of a program which exemplifies the three cases outlined above:</source>
          <target state="translated">下面是一个程序的例子,它体现了上述三种情况。</target>
        </trans-unit>
        <trans-unit id="8f4d98d4c0a8996c7a0518c8611a7d795ca5c7fb" translate="yes" xml:space="preserve">
          <source>Here's an example of a struct that has this problem:</source>
          <target state="translated">下面是一个存在这个问题的结构的例子。</target>
        </trans-unit>
        <trans-unit id="38707ff87f1d5297f1ba77c802780450fd07e571" translate="yes" xml:space="preserve">
          <source>Here's an example of how a collection might make use of &lt;code&gt;needs_drop&lt;/code&gt;:</source>
          <target state="translated">这是一个示例，说明集合如何利用 &lt;code&gt;needs_drop&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6b4165c575ea75c83f4faaec0830fc7c979ed3b7" translate="yes" xml:space="preserve">
          <source>Here's an example of some in-progress code. We have a trait &lt;code&gt;Foo&lt;/code&gt;:</source>
          <target state="translated">这是一些正在进行的代码的示例。我们有一个特质 &lt;code&gt;Foo&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f441ef09b0ea3aff9bb06d2bb0621baad2037ee9" translate="yes" xml:space="preserve">
          <source>Here's an example of this error:</source>
          <target state="translated">下面是这个错误的一个例子。</target>
        </trans-unit>
        <trans-unit id="c9ee387ebc736d2db87034681c5da1089287c37d" translate="yes" xml:space="preserve">
          <source>Here's an example where you want to sort people by height only, disregarding &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt;:</source>
          <target state="translated">这是一个示例，您只想按身高对人进行排序，而不考虑 &lt;code&gt;id&lt;/code&gt; 和 &lt;code&gt;name&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="51e85e4e8113fb3e1f07e1727e78d73f5f0043e6" translate="yes" xml:space="preserve">
          <source>Here's an example:</source>
          <target state="translated">这里有一个例子。</target>
        </trans-unit>
        <trans-unit id="4cce1c09bcbbaec9487020ee6e7f8025e34bed6b" translate="yes" xml:space="preserve">
          <source>Here's another example but here we do not try and return an expression:</source>
          <target state="translated">这是另一个例子,但这里我们不尝试返回一个表达式。</target>
        </trans-unit>
        <trans-unit id="52eb68597e531c606446cb2bd5c17dccc5e369fd" translate="yes" xml:space="preserve">
          <source>Here's another example that will fail:</source>
          <target state="translated">这里还有一个例子,会失败。</target>
        </trans-unit>
        <trans-unit id="cb729976f0325910542c6a857a3758115eda6f00" translate="yes" xml:space="preserve">
          <source>Here's one example of this error:</source>
          <target state="translated">下面是这个错误的一个例子。</target>
        </trans-unit>
        <trans-unit id="4919036b58ea25eeee47e5a5bbcefebd8f5446fd" translate="yes" xml:space="preserve">
          <source>Here's the same example, but with &lt;a href=&quot;#method.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">这是相同的示例，但带有&lt;a href=&quot;#method.filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="f461dd8cfe66dce3c71bb1a0db34025a57dc2b4e" translate="yes" xml:space="preserve">
          <source>Here's the same example, but with &lt;a href=&quot;trait.iterator#method.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">这是相同的示例，但是具有&lt;a href=&quot;trait.iterator#method.filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;trait.iterator#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="b538038816d2b9d80e3095023dd492b1ae3c134a" translate="yes" xml:space="preserve">
          <source>Here's the same example, but with &lt;a href=&quot;trait.iterator#method.take_while&quot;&gt;&lt;code&gt;take_while&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">这是相同的示例，但是带有&lt;a href=&quot;trait.iterator#method.take_while&quot;&gt; &lt;code&gt;take_while&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;trait.iterator#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="3adc3a6ab8335913c0c03d10dd56aa70986ccdbc" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;&amp;amp;mut fancy&lt;/code&gt; is mutable, but &lt;code&gt;&amp;amp;(&amp;amp;mut fancy)&lt;/code&gt; is not. Creating an immutable reference to a value borrows it immutably. There can be multiple references of type &lt;code&gt;&amp;amp;(&amp;amp;mut T)&lt;/code&gt; that point to the same value, so they must be immutable to prevent multiple mutable references to the same value.</source>
          <target state="translated">在这里， &lt;code&gt;&amp;amp;mut fancy&lt;/code&gt; 是可变的，但 &lt;code&gt;&amp;amp;(&amp;amp;mut fancy)&lt;/code&gt; 不是。创建对值的不可变引用将不可变地借用它。可能存在 &lt;code&gt;&amp;amp;(&amp;amp;mut T)&lt;/code&gt; 送到一部呢一部一部一部一部一部很一部很一部很一部电影作为主角的唱片公司的唱片公司的唱片公司）的唱片公司的公司，才可能出现的唱片公司）的公司的公司，它们的公司。&amp;amp;＆ &amp;amp;＆（＆mut＆M＆T＆T＆GT;＆GT;＆GT;＆GT;＆GT;＆QUOT ;;</target>
        </trans-unit>
        <trans-unit id="ae9903eacaebe1bfadd3100f5d35d502f8c50279" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Grams2&lt;/code&gt; is a not equivalent to &lt;code&gt;Grams&lt;/code&gt; -- the former transparently wraps a (non-transparent) struct containing a single float, while &lt;code&gt;Grams&lt;/code&gt; is a transparent wrapper around a float. This can make a difference for the ABI.</source>
          <target state="translated">在这里， &lt;code&gt;Grams2&lt;/code&gt; 不等同于 &lt;code&gt;Grams&lt;/code&gt; －前者透明地包装包含单个浮点的（非透明）结构，而 &lt;code&gt;Grams&lt;/code&gt; 是围绕浮点的透明包装。这对于ABI可以有所作为。</target>
        </trans-unit>
        <trans-unit id="dc33c2bfb4ee352bfa1ddf50a16705d99896734f" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;demo&lt;/code&gt; tries to borrow the string data held within its argument &lt;code&gt;s&lt;/code&gt; and then return that borrow. However, &lt;code&gt;S&lt;/code&gt; is declared as implementing &lt;code&gt;Drop&lt;/code&gt;.</source>
          <target state="translated">在这里， &lt;code&gt;demo&lt;/code&gt; 尝试借用其参数 &lt;code&gt;s&lt;/code&gt; 中保存的字符串数据，然后返回该借用。但是， &lt;code&gt;S&lt;/code&gt; 被声明为实现 &lt;code&gt;Drop&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d42c53fe9a57832c14dca225308392012e6122d1" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;fancy_num&lt;/code&gt; is borrowed by &lt;code&gt;fancy_ref&lt;/code&gt; and so cannot be moved into the closure &lt;code&gt;x&lt;/code&gt;. There is no way to move a value into a closure while it is borrowed, as that would invalidate the borrow.</source>
          <target state="translated">在这里， &lt;code&gt;fancy_num&lt;/code&gt; 被借用 &lt;code&gt;fancy_ref&lt;/code&gt; ，所以不能被移动到关闭 &lt;code&gt;x&lt;/code&gt; 。借入值时，无法将其移至封闭中，因为这会使借入无效。</target>
        </trans-unit>
        <trans-unit id="125b181d950db988334868421de4a90fab534474" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;first&lt;/code&gt; has type &lt;code&gt;A&lt;/code&gt;, referring to &lt;code&gt;to_vec&lt;/code&gt;'s &lt;code&gt;A&lt;/code&gt; type parameter; and &lt;code&gt;rest&lt;/code&gt; has type &lt;code&gt;Vec&amp;lt;A&amp;gt;&lt;/code&gt;, a vector with element type &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">在这里， &lt;code&gt;first&lt;/code&gt; 具有类型 &lt;code&gt;A&lt;/code&gt; ，引用 &lt;code&gt;to_vec&lt;/code&gt; 的 &lt;code&gt;A&lt;/code&gt; 类型参数；和 &lt;code&gt;rest&lt;/code&gt; 具有类型 &lt;code&gt;Vec&amp;lt;A&amp;gt;&lt;/code&gt; ，与元素类型的载体 &lt;code&gt;A&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="843f8d3cb9b3a29d042bd0b638e62192879181c8" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;i32&lt;/code&gt; is the type of each element. After the semicolon, the number &lt;code&gt;5&lt;/code&gt; indicates the array contains five elements.</source>
          <target state="translated">在此， &lt;code&gt;i32&lt;/code&gt; 是每个元素的类型。在分号之后，数字 &lt;code&gt;5&lt;/code&gt; 表示数组包含五个元素。</target>
        </trans-unit>
        <trans-unit id="df5a4c41f4c7ffd30b5c670cb408c350a9013b94" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;i32&lt;/code&gt; is the type of each element. After the semicolon, the number &lt;code&gt;5&lt;/code&gt; indicates the element contains five items.</source>
          <target state="translated">在此， &lt;code&gt;i32&lt;/code&gt; 是每个元素的类型。在分号之后，数字 &lt;code&gt;5&lt;/code&gt; 表示元素包含五项。</target>
        </trans-unit>
        <trans-unit id="1068c0619a68aa52935f67e1c63f9f6ef1422570" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;s&lt;/code&gt; will be a &lt;code&gt;&amp;amp;str&lt;/code&gt; that contains the first 4 bytes of the string. Earlier, we mentioned that each of these characters was 2 bytes, which means &lt;code&gt;s&lt;/code&gt; will be &lt;code&gt;Зд&lt;/code&gt;.</source>
          <target state="translated">在这里， &lt;code&gt;s&lt;/code&gt; 将是一个 &lt;code&gt;&amp;amp;str&lt;/code&gt; ，它包含字符串的前4个字节。之前，我们提到了每个字符都是2个字节，这意味着 &lt;code&gt;s&lt;/code&gt; 将是 &lt;code&gt;Зд&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75b866d15247e93817fc99798a57f0ab2950be56" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;score&lt;/code&gt; will have the value that&amp;rsquo;s associated with the Blue team, and the result will be &lt;code&gt;Some(&amp;amp;10)&lt;/code&gt;. The result is wrapped in &lt;code&gt;Some&lt;/code&gt; because &lt;code&gt;get&lt;/code&gt; returns an &lt;code&gt;Option&amp;lt;&amp;amp;V&amp;gt;&lt;/code&gt;; if there&amp;rsquo;s no value for that key in the hash map, &lt;code&gt;get&lt;/code&gt; will return &lt;code&gt;None&lt;/code&gt;. The program will need to handle the &lt;code&gt;Option&lt;/code&gt; in one of the ways that we covered in Chapter 6.</source>
          <target state="translated">在这里， &lt;code&gt;score&lt;/code&gt; 将具有与Blue团队相关联的值，结果将是 &lt;code&gt;Some(&amp;amp;10)&lt;/code&gt; 。结果包装在 &lt;code&gt;Some&lt;/code&gt; 中,因为 &lt;code&gt;get&lt;/code&gt; 返回 &lt;code&gt;Option&amp;lt;&amp;amp;V&amp;gt;&lt;/code&gt; ;如果哈希图中没有该键的值，则 &lt;code&gt;get&lt;/code&gt; 将返回 &lt;code&gt;None&lt;/code&gt; 。该程序将需要以我们在第6章中介绍的一种方式来处理 &lt;code&gt;Option&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8bd05f4a31a90f3b6414a315addec81f40aa24ad" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;x&lt;/code&gt; has the lifetime &lt;code&gt;'b&lt;/code&gt;, which in this case is larger than &lt;code&gt;'a&lt;/code&gt;. This means &lt;code&gt;r&lt;/code&gt; can reference &lt;code&gt;x&lt;/code&gt; because Rust knows that the reference in &lt;code&gt;r&lt;/code&gt; will always be valid while &lt;code&gt;x&lt;/code&gt; is valid.</source>
          <target state="translated">在此， &lt;code&gt;x&lt;/code&gt; 具有寿命 &lt;code&gt;'b&lt;/code&gt; ，在这种情况下，寿命大于 &lt;code&gt;'a&lt;/code&gt; 。这意味着 &lt;code&gt;r&lt;/code&gt; 可以引用 &lt;code&gt;x&lt;/code&gt; ,因为Rust知道 &lt;code&gt;r&lt;/code&gt; 在 &lt;code&gt;x&lt;/code&gt; 有效时将始终有效。</target>
        </trans-unit>
        <trans-unit id="e10c369ea788e27a00713fc168a85308c89bf1c9" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;y&lt;/code&gt; is bound by-value in one case and by-reference in the other.</source>
          <target state="translated">在此， &lt;code&gt;y&lt;/code&gt; 在一种情况下受值约束，而在另一种情况下受引用约束。</target>
        </trans-unit>
        <trans-unit id="7d5607669abd7c37655a986b9a8d2fca66769741" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;y&lt;/code&gt; is bound to the contents of the &lt;code&gt;Some&lt;/code&gt; and can be used within the block corresponding to the match arm. However, in case &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, we have not specified what &lt;code&gt;y&lt;/code&gt; is, and the block will use a nonexistent variable.</source>
          <target state="translated">此处， &lt;code&gt;y&lt;/code&gt; 绑定到 &lt;code&gt;Some&lt;/code&gt; 的内容，并且可以在与匹配臂相对应的块中使用。但是，如果 &lt;code&gt;x&lt;/code&gt; 为 &lt;code&gt;None&lt;/code&gt; ，则我们没有指定 &lt;code&gt;y&lt;/code&gt; 是什么，并且该块将使用不存在的变量。</target>
        </trans-unit>
        <trans-unit id="a792c6d2920136f42b2c0328d50b11b4b1f68c36" translate="yes" xml:space="preserve">
          <source>Here, all types implementing &lt;code&gt;Foo&lt;/code&gt; must have a method &lt;code&gt;foo&amp;lt;T&amp;gt;(x: T)&lt;/code&gt; which can take any type &lt;code&gt;T&lt;/code&gt;. However, in the &lt;code&gt;impl&lt;/code&gt; for &lt;code&gt;bool&lt;/code&gt;, we have added an extra bound that &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Copy&lt;/code&gt;, which isn't compatible with the original trait.</source>
          <target state="translated">在此，实现所有类型 &lt;code&gt;Foo&lt;/code&gt; 必须有一个方法 &lt;code&gt;foo&amp;lt;T&amp;gt;(x: T)&lt;/code&gt; 可采取任何类型 &lt;code&gt;T&lt;/code&gt; 。然而，在 &lt;code&gt;impl&lt;/code&gt; 针对 &lt;code&gt;bool&lt;/code&gt; ，我们增加了一个额外的约束，且 &lt;code&gt;T&lt;/code&gt; 的 &lt;code&gt;Copy&lt;/code&gt; ，这是不符合原来的特质兼容。</target>
        </trans-unit>
        <trans-unit id="e86bf62ea38db4534581f774aebf9c330891b88f" translate="yes" xml:space="preserve">
          <source>Here, even though &lt;code&gt;x&lt;/code&gt; is not one of the parameters of &lt;code&gt;equal_to_x&lt;/code&gt;, the &lt;code&gt;equal_to_x&lt;/code&gt; closure is allowed to use the &lt;code&gt;x&lt;/code&gt; variable that&amp;rsquo;s defined in the same scope that &lt;code&gt;equal_to_x&lt;/code&gt; is defined in.</source>
          <target state="translated">在这里，即使 &lt;code&gt;x&lt;/code&gt; 不是 &lt;code&gt;equal_to_x&lt;/code&gt; 的参数之一，也允许 &lt;code&gt;equal_to_x&lt;/code&gt; 闭包使用在与 &lt;code&gt;equal_to_x&lt;/code&gt; 相同的作用域中定义的 &lt;code&gt;x&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="3efa2682153806eb1dbead68e3ef30ae590912ca" translate="yes" xml:space="preserve">
          <source>Here, even though we&amp;rsquo;ve specified a lifetime parameter &lt;code&gt;'a&lt;/code&gt; for the return type, this implementation will fail to compile because the return value lifetime is not related to the lifetime of the parameters at all. Here is the error message we get:</source>
          <target state="translated">在这里，即使我们为返回类型指定了生命周期参数 &lt;code&gt;'a&lt;/code&gt; ，该实现也将无法编译，因为返回值生命周期与参数的生命周期完全无关。这是我们得到的错误消息：</target>
        </trans-unit>
        <trans-unit id="da2b63d2db9c34aa4fad7b681faf1cae153440c5" translate="yes" xml:space="preserve">
          <source>Here, our response has a status line with status code 404 and the reason phrase &lt;code&gt;NOT FOUND&lt;/code&gt;. We&amp;rsquo;re still not returning headers, and the body of the response will be the HTML in the file &lt;em&gt;404.html&lt;/em&gt;. You&amp;rsquo;ll need to create a &lt;em&gt;404.html&lt;/em&gt; file next to &lt;em&gt;hello.html&lt;/em&gt; for the error page; again feel free to use any HTML you want or use the example HTML in Listing 20-8.</source>
          <target state="translated">在此，我们的响应包含一条状态行，其状态码为404，原因短语 &lt;code&gt;NOT FOUND&lt;/code&gt; 。我们仍然没有返回标头，响应的主体将是文件&lt;em&gt;404.html中&lt;/em&gt;的HTML 。您需要在&lt;em&gt;hello.html&lt;/em&gt;旁边为错误页面创建&lt;em&gt;404.html&lt;/em&gt;文件；再次随意使用您想要的任何HTML或使用清单20-8中的示例HTML。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a2749e5eb8656bede400f4e0b8d184580a4d9adf" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;BitAndAssign&lt;/code&gt; trait is implemented for a wrapper around &lt;code&gt;Vec&amp;lt;bool&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">在这里，为围绕 &lt;code&gt;Vec&amp;lt;bool&amp;gt;&lt;/code&gt; 的包装器实现了 &lt;code&gt;BitAndAssign&lt;/code&gt; 特性。</target>
        </trans-unit>
        <trans-unit id="73314800534c2c9290a895f1b2e09cd5c74b13fa" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;nothing_is_true&lt;/code&gt; method takes the ownership of &lt;code&gt;self&lt;/code&gt;. However, &lt;code&gt;self&lt;/code&gt; cannot be moved because &lt;code&gt;.borrow()&lt;/code&gt; only provides an &lt;code&gt;&amp;amp;TheDarkKnight&lt;/code&gt;, which is a borrow of the content owned by the &lt;code&gt;RefCell&lt;/code&gt;. To fix this error, you have three choices:</source>
          <target state="translated">在这里， &lt;code&gt;nothing_is_true&lt;/code&gt; 方法采用了 &lt;code&gt;self&lt;/code&gt; 的所有权。但是， &lt;code&gt;self&lt;/code&gt; 不能移动，因为 &lt;code&gt;.borrow()&lt;/code&gt; 仅提供 &lt;code&gt;&amp;amp;TheDarkKnight&lt;/code&gt; ，它是 &lt;code&gt;RefCell&lt;/code&gt; 拥有的内容的借用。要解决此错误，您可以选择三个选项：</target>
        </trans-unit>
        <trans-unit id="9ecdeb34514236dc334d979e1fa6dac1a4f47ca1" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;yield&lt;/code&gt; keyword is used in an &lt;code&gt;async&lt;/code&gt; block, which is not yet supported.</source>
          <target state="translated">此处， &lt;code&gt;yield&lt;/code&gt; 关键字用于 &lt;code&gt;async&lt;/code&gt; 块中，尚不支持。</target>
        </trans-unit>
        <trans-unit id="a5f1ad21d4790c6fa776cb2d79a7da13085bbb0b" translate="yes" xml:space="preserve">
          <source>Here, the code counts up through the elements in the array. It starts at index &lt;code&gt;0&lt;/code&gt;, and then loops until it reaches the final index in the array (that is, when &lt;code&gt;index &amp;lt; 5&lt;/code&gt; is no longer true). Running this code will print every element in the array:</source>
          <target state="translated">在这里，代码通过数组中的元素递增计数。它从索引 &lt;code&gt;0&lt;/code&gt; 开始，然后循环直到到达数组中的最终索引（也就是说，当 &lt;code&gt;index &amp;lt; 5&lt;/code&gt; 不再为true时）。运行以下代码将打印数组中的每个元素：</target>
        </trans-unit>
        <trans-unit id="f6e9fdb531b1a1a673e70ab403c2068ef72bf3e1" translate="yes" xml:space="preserve">
          <source>Here, the expression &lt;code&gt;&amp;amp;foo()&lt;/code&gt; is borrowing the expression &lt;code&gt;foo()&lt;/code&gt;. As &lt;code&gt;foo()&lt;/code&gt; is a call to a function, and not the name of a variable, this creates a &lt;strong&gt;temporary&lt;/strong&gt; -- that temporary stores the return value from &lt;code&gt;foo()&lt;/code&gt; so that it can be borrowed. You could imagine that &lt;code&gt;let p = bar(&amp;amp;foo());&lt;/code&gt; is equivalent to this:</source>
          <target state="translated">在这里，表达式 &lt;code&gt;&amp;amp;foo()&lt;/code&gt; 借用了表达式 &lt;code&gt;foo()&lt;/code&gt; 。由于 &lt;code&gt;foo()&lt;/code&gt; 是对函数的调用，而不是变量的名称，因此会创建一个&lt;strong&gt;临时文件&lt;/strong&gt; -该临时文件存储 &lt;code&gt;foo()&lt;/code&gt; 的返回值，以便可以借用它。您可以想象 &lt;code&gt;let p = bar(&amp;amp;foo());&lt;/code&gt; 等效于此：</target>
        </trans-unit>
        <trans-unit id="408c7fbfdfe961fb58eba63dc21b905f34fe6b5c" translate="yes" xml:space="preserve">
          <source>Here, the function &lt;code&gt;eat&lt;/code&gt; takes ownership of &lt;code&gt;x&lt;/code&gt;. However, &lt;code&gt;x&lt;/code&gt; cannot be moved because the borrow to &lt;code&gt;_ref_to_val&lt;/code&gt; needs to last till the function &lt;code&gt;borrow&lt;/code&gt;. To fix that you can do a few different things:</source>
          <target state="translated">在这里，函数 &lt;code&gt;eat&lt;/code&gt; 获得 &lt;code&gt;x&lt;/code&gt; 的所有权。但是，不能移动 &lt;code&gt;x&lt;/code&gt; ,因为对 &lt;code&gt;_ref_to_val&lt;/code&gt; 的借用需要持续到函数 &lt;code&gt;borrow&lt;/code&gt; 为止。要解决此问题，您可以做一些不同的事情：</target>
        </trans-unit>
        <trans-unit id="34b4fc7688b4cc55dbce35a5cbba7cf5aa481597" translate="yes" xml:space="preserve">
          <source>Here, the function &lt;code&gt;foo&lt;/code&gt; returns a value of type &lt;code&gt;Cell&amp;lt;&amp;amp;'x u32&amp;gt;&lt;/code&gt;, which references the lifetime &lt;code&gt;'x&lt;/code&gt;. However, the return type is declared as &lt;code&gt;impl Trait&amp;lt;'y&amp;gt;&lt;/code&gt; -- this indicates that &lt;code&gt;foo&lt;/code&gt; returns &quot;some type that implements &lt;code&gt;Trait&amp;lt;'y&amp;gt;&lt;/code&gt;&quot;, but it also indicates that the return type &lt;strong&gt;only captures data referencing the lifetime &lt;code&gt;'y&lt;/code&gt;&lt;/strong&gt;. In this case, though, we are referencing data with lifetime &lt;code&gt;'x&lt;/code&gt;, so this function is in error.</source>
          <target state="translated">在此，函数 &lt;code&gt;foo&lt;/code&gt; 返回类型为 &lt;code&gt;Cell&amp;lt;&amp;amp;'x u32&amp;gt;&lt;/code&gt; ，该值引用生存期 &lt;code&gt;'x&lt;/code&gt; 。但是，返回类型被声明为 &lt;code&gt;impl Trait&amp;lt;'y&amp;gt;&lt;/code&gt; －这表明 &lt;code&gt;foo&lt;/code&gt; 返回&amp;ldquo;实现 &lt;code&gt;Trait&amp;lt;'y&amp;gt;&lt;/code&gt; 某种类型&amp;rdquo;，但它也表明该返回类型&lt;strong&gt;仅捕获引用生存期 &lt;code&gt;'y&lt;/code&gt; 的数据&lt;/strong&gt;。但是，在这种情况下，我们引用的生命期为 &lt;code&gt;'x&lt;/code&gt; ，因此此函数有错误。</target>
        </trans-unit>
        <trans-unit id="89055a364d466030b4b32dbb99ee9d2965691a35" translate="yes" xml:space="preserve">
          <source>Here, the loop never ends, so &lt;code&gt;!&lt;/code&gt; is the value of the expression. However, this wouldn&amp;rsquo;t be true if we included a &lt;code&gt;break&lt;/code&gt;, because the loop would terminate when it got to the &lt;code&gt;break&lt;/code&gt;.</source>
          <target state="translated">在这里，循环永远不会结束，所以 &lt;code&gt;!&lt;/code&gt; 是表达式的值。但是，如果我们包含 &lt;code&gt;break&lt;/code&gt; ，则情况并非如此，因为循环将在到达 &lt;code&gt;break&lt;/code&gt; 时终止。</target>
        </trans-unit>
        <trans-unit id="df47ee6ed5cabbf7215bb10c59a544458415fee2" translate="yes" xml:space="preserve">
          <source>Here, the problem is that a reference type like &lt;code&gt;&amp;amp;'a T&lt;/code&gt; is only valid if all the data in T outlives the lifetime &lt;code&gt;'a&lt;/code&gt;. But this impl as written is applicable to any lifetime &lt;code&gt;'a&lt;/code&gt; and any type &lt;code&gt;T&lt;/code&gt; -- we have no guarantee that &lt;code&gt;T&lt;/code&gt; outlives &lt;code&gt;'a&lt;/code&gt;. To fix this, you can add a where clause like &lt;code&gt;where T: 'a&lt;/code&gt;.</source>
          <target state="translated">这里的问题是，仅当 &lt;code&gt;&amp;amp;'a T&lt;/code&gt; 中的所有数据都超过生存期 &lt;code&gt;'a&lt;/code&gt; 时,类似＆'a T的引用类型才有效。但是，该隐含含义适用于任何生存期 &lt;code&gt;'a&lt;/code&gt; 和任何类型 &lt;code&gt;T&lt;/code&gt; -我们无法保证 &lt;code&gt;T&lt;/code&gt; 的寿命超过 &lt;code&gt;'a&lt;/code&gt; 。要解决此问题，您可以添加where子句，例如 &lt;code&gt;where T: 'a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0ef28f4a5284b6e2516b2e042ed2f018d33a029" translate="yes" xml:space="preserve">
          <source>Here, the problem is that the compiler cannot be sure that the &lt;code&gt;'b&lt;/code&gt; lifetime will live longer than &lt;code&gt;'a&lt;/code&gt;, which should be mandatory in order to be sure that &lt;code&gt;Trait::Out&lt;/code&gt; will always have a reference pointing to an existing type. So in this case, we just need to tell the compiler than &lt;code&gt;'b&lt;/code&gt; must outlive &lt;code&gt;'a&lt;/code&gt;:</source>
          <target state="translated">在这里，问题在于编译器无法确保 &lt;code&gt;'b&lt;/code&gt; 生存期比 &lt;code&gt;'a&lt;/code&gt; 更长寿，这是必须执行的，以确保 &lt;code&gt;Trait::Out&lt;/code&gt; 始终具有指向现有类型的引用。因此，在这种情况下，我们只需要告诉编译器 &lt;code&gt;'b&lt;/code&gt; 必须超过 &lt;code&gt;'a&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="362d656c8582920eb1fa6e2f837dcd77621e2783" translate="yes" xml:space="preserve">
          <source>Here, the supertrait might have methods as follows:</source>
          <target state="translated">在这里,超纲可能有如下方法。</target>
        </trans-unit>
        <trans-unit id="09d377b97ceff52f388bef9d69ecd4e08de82e8e" translate="yes" xml:space="preserve">
          <source>Here, the type of &lt;code&gt;bar&lt;/code&gt; isn't known; it could be a pointer to anything. Instead, specify a type for the pointer (preferably something that makes sense for the thing you're pointing to):</source>
          <target state="translated">这里， &lt;code&gt;bar&lt;/code&gt; 的类型未知。它可能是任何东西的指针。相反，请为指针指定一种类型（最好是对您要指向的东西有意义的一种）：</target>
        </trans-unit>
        <trans-unit id="6683d46fded95c67df0b49024b3446d80dd204a6" translate="yes" xml:space="preserve">
          <source>Here, the where clause &lt;code&gt;T: 'a&lt;/code&gt; that appears on the impl is not known to be satisfied on the struct. To make this example compile, you have to add a where-clause like &lt;code&gt;T: 'a&lt;/code&gt; to the struct definition:</source>
          <target state="translated">在这里，不知道在impl上出现的where子句 &lt;code&gt;T: 'a&lt;/code&gt; 在struct上是不满足的。要编译此示例，您必须在结构定义中添加一个类似 &lt;code&gt;T: 'a&lt;/code&gt; 的子句：</target>
        </trans-unit>
        <trans-unit id="5f5bdb12ef17925552b810b20339fc4188e58923" translate="yes" xml:space="preserve">
          <source>Here, there's no need to allocate more memory inside the loop.</source>
          <target state="translated">这里,不需要在循环里面分配更多的内存。</target>
        </trans-unit>
        <trans-unit id="64f50e4beb0199dca819447bd86bfb2e950cfebb" translate="yes" xml:space="preserve">
          <source>Here, transmute is being used to convert the types of the fn arguments. This pattern is incorrect because, because the type of &lt;code&gt;foo&lt;/code&gt; is a function &lt;strong&gt;item&lt;/strong&gt; (&lt;code&gt;typeof(foo)&lt;/code&gt;), which is zero-sized, and the target type (&lt;code&gt;fn()&lt;/code&gt;) is a function pointer, which is not zero-sized. This pattern should be rewritten. There are a few possible ways to do this:</source>
          <target state="translated">在这里，transmute用于转换fn参数的类型。这种模式是不正确的，因为因为 &lt;code&gt;foo&lt;/code&gt; 的类型是一个零大小的函数&lt;strong&gt;项&lt;/strong&gt;（ &lt;code&gt;typeof(foo)&lt;/code&gt; ），而目标类型（ &lt;code&gt;fn()&lt;/code&gt; ）是一个非零大小的函数指针。此模式应重写。有几种方法可以做到这一点：</target>
        </trans-unit>
        <trans-unit id="11f7e7a9427d5e270e6bb9180be033e23a1b7abb" translate="yes" xml:space="preserve">
          <source>Here, we are still borrowing &lt;code&gt;foo()&lt;/code&gt;, but as the borrow is assigned directly into a variable, the temporary will not be dropped until the end of the enclosing block. Similar rules apply when temporaries are stored into aggregate structures like a tuple or struct:</source>
          <target state="translated">在这里，我们仍在借用 &lt;code&gt;foo()&lt;/code&gt; ，但是由于借用是直接分配给变量的，因此直到封闭块的末尾，临时变量才会被删除。当临时变量存储到诸如元组或结构的聚合结构中时，适用类似的规则：</target>
        </trans-unit>
        <trans-unit id="2fe93444419186b520c70f702a92a3495d890ab8" translate="yes" xml:space="preserve">
          <source>Here, we create a new variable &lt;code&gt;case_sensitive&lt;/code&gt;. To set its value, we call the &lt;code&gt;env::var&lt;/code&gt; function and pass it the name of the &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; environment variable. The &lt;code&gt;env::var&lt;/code&gt; function returns a &lt;code&gt;Result&lt;/code&gt; that will be the successful &lt;code&gt;Ok&lt;/code&gt; variant that contains the value of the environment variable if the environment variable is set. It will return the &lt;code&gt;Err&lt;/code&gt; variant if the environment variable is not set.</source>
          <target state="translated">在这里，我们创建一个新变量 &lt;code&gt;case_sensitive&lt;/code&gt; 。要设置其值，我们调用 &lt;code&gt;env::var&lt;/code&gt; 函数并将其传递给 &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; 环境变量的名称。该 &lt;code&gt;env::var&lt;/code&gt; 函数返回一个 &lt;code&gt;Result&lt;/code&gt; ，这将是成功的 &lt;code&gt;Ok&lt;/code&gt; 包含环境变量的值，如果环境变量设置的变体。如果未设置环境变量，它将返回 &lt;code&gt;Err&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="629de8d4fd404424f68755750d18203229995313" translate="yes" xml:space="preserve">
          <source>Here, we declare a trait using the &lt;code&gt;trait&lt;/code&gt; keyword and then the trait&amp;rsquo;s name, which is &lt;code&gt;Summary&lt;/code&gt; in this case. Inside the curly brackets, we declare the method signatures that describe the behaviors of the types that implement this trait, which in this case is &lt;code&gt;fn summarize(&amp;amp;self) -&amp;gt; String&lt;/code&gt;.</source>
          <target state="translated">在这里，我们使用 &lt;code&gt;trait&lt;/code&gt; 关键字声明一个特征，然后使用该特征的名称，在本例中为 &lt;code&gt;Summary&lt;/code&gt; 。在大括号内，我们声明方法签名，这些签名描述实现此特征的类型的行为，在这种情况下为 &lt;code&gt;fn summarize(&amp;amp;self) -&amp;gt; String&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5d31c7a816695d5663a1af214bdd61a0f312631" translate="yes" xml:space="preserve">
          <source>Here, we first call &lt;code&gt;lock&lt;/code&gt; on the &lt;code&gt;receiver&lt;/code&gt; to acquire the mutex, and then we call &lt;code&gt;unwrap&lt;/code&gt; to panic on any errors. Acquiring a lock might fail if the mutex is in a &lt;em&gt;poisoned&lt;/em&gt; state, which can happen if some other thread panicked while holding the lock rather than releasing the lock. In this situation, calling &lt;code&gt;unwrap&lt;/code&gt; to have this thread panic is the correct action to take. Feel free to change this &lt;code&gt;unwrap&lt;/code&gt; to an &lt;code&gt;expect&lt;/code&gt; with an error message that is meaningful to you.</source>
          <target state="translated">在这里，我们第一个电话 &lt;code&gt;lock&lt;/code&gt; 在 &lt;code&gt;receiver&lt;/code&gt; 获得互斥体，然后我们呼吁 &lt;code&gt;unwrap&lt;/code&gt; 恐慌的任何错误。如果互斥锁处于&lt;em&gt;中毒&lt;/em&gt;状态，则获取锁可能会失败，而如果其他一些线程在持有锁而不是释放锁的情况下发生了恐慌，则可能会发生这种情况。在这种情况下，调用 &lt;code&gt;unwrap&lt;/code&gt; 使此线程紧急状态是正确的操作。随意更改此 &lt;code&gt;unwrap&lt;/code&gt; 来的 &lt;code&gt;expect&lt;/code&gt; 与对您有意义的错误消息。</target>
        </trans-unit>
        <trans-unit id="90ed3acfd08d6add91c92898299f8f082c9b0a5d" translate="yes" xml:space="preserve">
          <source>Here, we give a description of what the &lt;code&gt;add_one&lt;/code&gt; function does, start a section with the heading &lt;code&gt;Examples&lt;/code&gt;, and then provide code that demonstrates how to use the &lt;code&gt;add_one&lt;/code&gt; function. We can generate the HTML documentation from this documentation comment by running &lt;code&gt;cargo doc&lt;/code&gt;. This command runs the &lt;code&gt;rustdoc&lt;/code&gt; tool distributed with Rust and puts the generated HTML documentation in the &lt;em&gt;target/doc&lt;/em&gt; directory.</source>
          <target state="translated">在这里，我们给什么样的描述 &lt;code&gt;add_one&lt;/code&gt; 功能呢，先从标题一节 &lt;code&gt;Examples&lt;/code&gt; ，然后提供演示如何使用代码 &lt;code&gt;add_one&lt;/code&gt; 功能。我们可以通过运行 &lt;code&gt;cargo doc&lt;/code&gt; 从此文档注释生成HTML文档。此命令运行随Rust &lt;code&gt;rustdoc&lt;/code&gt; 分发的rustdoc工具，并将生成的HTML文档放入&lt;em&gt;target / doc&lt;/em&gt;目录。</target>
        </trans-unit>
        <trans-unit id="509084bc1cc2854ecab3677678733d63bccc2260" translate="yes" xml:space="preserve">
          <source>Here, we have a package that only contains &lt;em&gt;src/main.rs&lt;/em&gt;, meaning it only contains a binary crate named &lt;code&gt;my-project&lt;/code&gt;. If a package contains &lt;em&gt;src/main.rs&lt;/em&gt; and &lt;em&gt;src/lib.rs&lt;/em&gt;, it has two crates: a library and a binary, both with the same name as the package. A package can have multiple binary crates by placing files in the &lt;em&gt;src/bin&lt;/em&gt; directory: each file will be a separate binary crate.</source>
          <target state="translated">在这里，我们有一个仅包含&lt;em&gt;src / main.rs&lt;/em&gt;的软件包，这意味着它仅包含一个名为 &lt;code&gt;my-project&lt;/code&gt; 的二进制板条箱。如果软件包包含&lt;em&gt;src / main.rs&lt;/em&gt;和&lt;em&gt;src / lib.rs&lt;/em&gt;，则它有两个包装箱：库和二进制文件，两者的名称与软件包相同。通过将文件放在&lt;em&gt;src / bin&lt;/em&gt;目录中，一个软件包可以具有多个二进制文件&lt;em&gt;箱&lt;/em&gt;：每个文件将是一个单独的二进制文件箱。</target>
        </trans-unit>
        <trans-unit id="214685b848acbf415bb3dbd9186c1466aa631aa7" translate="yes" xml:space="preserve">
          <source>Here, we have two parameters of type &lt;code&gt;TokenStream&lt;/code&gt;. The first is for the contents of the attribute: the &lt;code&gt;GET, &quot;/&quot;&lt;/code&gt; part. The second is the body of the item the attribute is attached to: in this case, &lt;code&gt;fn index() {}&lt;/code&gt; and the rest of the function&amp;rsquo;s body.</source>
          <target state="translated">在这里，我们有两个类型为 &lt;code&gt;TokenStream&lt;/code&gt; 的参数。第一个用于属性的内容： &lt;code&gt;GET, &quot;/&quot;&lt;/code&gt; 部分。第二个是属性附加到的项目的主体：在这种情况下，为 &lt;code&gt;fn index() {}&lt;/code&gt; 和函数主体的其余部分。</target>
        </trans-unit>
        <trans-unit id="9da25d2edfbc8a834054d09a3a531a79272bf467" translate="yes" xml:space="preserve">
          <source>Here, we match a tuple against a pattern. Rust compares the value &lt;code&gt;(1, 2, 3)&lt;/code&gt; to the pattern &lt;code&gt;(x, y, z)&lt;/code&gt; and sees that the value matches the pattern, so Rust binds &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; to &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;3&lt;/code&gt; to &lt;code&gt;z&lt;/code&gt;. You can think of this tuple pattern as nesting three individual variable patterns inside it.</source>
          <target state="translated">在这里，我们将元组与模式匹配。Rust将值 &lt;code&gt;(1, 2, 3)&lt;/code&gt; 与模式 &lt;code&gt;(x, y, z)&lt;/code&gt; ，发现该值与模式匹配，因此Rust将 &lt;code&gt;1&lt;/code&gt; 绑定到 &lt;code&gt;x&lt;/code&gt; ，将 &lt;code&gt;2&lt;/code&gt; 绑定到 &lt;code&gt;y&lt;/code&gt; ，将 &lt;code&gt;3&lt;/code&gt; 绑定到 &lt;code&gt;z&lt;/code&gt; 。您可以将这个元组模式视为在其中嵌套三个单独的变量模式。</target>
        </trans-unit>
        <trans-unit id="3807aec2b6a72b122da57a852fc8dc8b9b746c8b" translate="yes" xml:space="preserve">
          <source>Here, we tried to move a field out of a struct of type &lt;code&gt;DropStruct&lt;/code&gt; which implements the &lt;code&gt;Drop&lt;/code&gt; trait. However, a struct cannot be dropped if one or more of its fields have been moved.</source>
          <target state="translated">在这里，我们尝试将字段移出实现 &lt;code&gt;Drop&lt;/code&gt; 特性的 &lt;code&gt;DropStruct&lt;/code&gt; 类型的结构。但是，如果一个结构的一个或多个字段已移动，则不能删除该结构。</target>
        </trans-unit>
        <trans-unit id="182fd49127f0c327471148134a76b7aecc6837c0" translate="yes" xml:space="preserve">
          <source>Here, we try to print &lt;code&gt;val&lt;/code&gt; after we&amp;rsquo;ve sent it down the channel via &lt;code&gt;tx.send&lt;/code&gt;. Allowing this would be a bad idea: once the value has been sent to another thread, that thread could modify or drop it before we try to use the value again. Potentially, the other thread&amp;rsquo;s modifications could cause errors or unexpected results due to inconsistent or nonexistent data. However, Rust gives us an error if we try to compile the code in Listing 16-9:</source>
          <target state="translated">在这里，我们通过 &lt;code&gt;tx.send&lt;/code&gt; 将其发送到通道后尝试打印 &lt;code&gt;val&lt;/code&gt; 。允许这样做是一个坏主意：一旦将值发送到另一个线程，该线程可以在我们再次尝试使用该值之前对其进行修改或删除。潜在的是，另一个线程的修改可能由于数据不一致或不存在而导致错误或意外结果。但是，如果我们尝试编译清单16-9中的代码，Rust给我们一个错误：</target>
        </trans-unit>
        <trans-unit id="e6e942400049c5831b3b39dbc83c98fc061c7f27" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;ll work up to a program that has one thread to generate values and send them down a channel, and another thread that will receive the values and print them out. We&amp;rsquo;ll be sending simple values between threads using a channel to illustrate the feature. Once you&amp;rsquo;re familiar with the technique, you could use channels to implement a chat system or a system where many threads perform parts of a calculation and send the parts to one thread that aggregates the results.</source>
          <target state="translated">在这里，我们将处理一个程序，该程序具有一个线程来生成值并将其发送到一个通道，而另一个线程将接收值并打印出来。我们将使用通道来说明功能在线程之间发送简单值。熟悉这项技术后，您就可以使用渠道来实现聊天系统或由许多线程执行一部分计算并将这些部分发送到一个汇总结果的线程的系统。</target>
        </trans-unit>
        <trans-unit id="2b30624caca04c6adde1f0c4c5c0896dda9444b6" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;re attempting to access the 100th element of our vector (which is at index 99 because indexing starts at zero), but it has only 3 elements. In this situation, Rust will panic. Using &lt;code&gt;[]&lt;/code&gt; is supposed to return an element, but if you pass an invalid index, there&amp;rsquo;s no element that Rust could return here that would be correct.</source>
          <target state="translated">在这里，我们尝试访问向量的第100个元素（由于索引从零开始，因此位于索引99处），但是它只有3个元素。在这种情况下，Rust会惊慌。应该使用 &lt;code&gt;[]&lt;/code&gt; 返回一个元素，但是如果传递无效索引，则Rust不会在此处返回正确的元素。</target>
        </trans-unit>
        <trans-unit id="5696f367dcde9c29280ed019893b8b93043b4ae3" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;re calling the &lt;code&gt;do_something&lt;/code&gt; function 100 times, but we never use the variable &lt;code&gt;i&lt;/code&gt; in the body of the &lt;code&gt;for&lt;/code&gt; loop. Rust warns us about that:</source>
          <target state="translated">在这里，我们要调用 &lt;code&gt;do_something&lt;/code&gt; 函数100次，但是我们永远不会在 &lt;code&gt;for&lt;/code&gt; 循环的主体中使用变量 &lt;code&gt;i&lt;/code&gt; 。Rust对此警告我们：</target>
        </trans-unit>
        <trans-unit id="0738694c0b9e33967ee0ed11850ca18af144e2e8" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;re creating a new instance of the &lt;code&gt;User&lt;/code&gt; struct, which has a field named &lt;code&gt;email&lt;/code&gt;. We want to set the &lt;code&gt;email&lt;/code&gt; field&amp;rsquo;s value to the value in the &lt;code&gt;email&lt;/code&gt; parameter of the &lt;code&gt;build_user&lt;/code&gt; function. Because the &lt;code&gt;email&lt;/code&gt; field and the &lt;code&gt;email&lt;/code&gt; parameter have the same name, we only need to write &lt;code&gt;email&lt;/code&gt; rather than &lt;code&gt;email: email&lt;/code&gt;.</source>
          <target state="translated">在这里，我们正在创建 &lt;code&gt;User&lt;/code&gt; 结构的新实例，该实例具有一个名为 &lt;code&gt;email&lt;/code&gt; 的字段。我们想将 &lt;code&gt;email&lt;/code&gt; 字段的值设置为 &lt;code&gt;build_user&lt;/code&gt; 函数的 &lt;code&gt;email&lt;/code&gt; 参数中的值。因为 &lt;code&gt;email&lt;/code&gt; 字段和 &lt;code&gt;email&lt;/code&gt; 参数具有相同的名称，所以我们只需要编写 &lt;code&gt;email&lt;/code&gt; 而不是 &lt;code&gt;email: email&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2e907cc8b08cfb8b71a6716a55c4e7e4751a1f7" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;ve annotated the lifetime of &lt;code&gt;r&lt;/code&gt; with &lt;code&gt;'a&lt;/code&gt; and the lifetime of &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;'b&lt;/code&gt;. As you can see, the inner &lt;code&gt;'b&lt;/code&gt; block is much smaller than the outer &lt;code&gt;'a&lt;/code&gt; lifetime block. At compile time, Rust compares the size of the two lifetimes and sees that &lt;code&gt;r&lt;/code&gt; has a lifetime of &lt;code&gt;'a&lt;/code&gt; but that it refers to memory with a lifetime of &lt;code&gt;'b&lt;/code&gt;. The program is rejected because &lt;code&gt;'b&lt;/code&gt; is shorter than &lt;code&gt;'a&lt;/code&gt;: the subject of the reference doesn&amp;rsquo;t live as long as the reference.</source>
          <target state="translated">在这里，我们用 &lt;code&gt;'a&lt;/code&gt; 标注 &lt;code&gt;r&lt;/code&gt; 的生命周期，用 &lt;code&gt;'b&lt;/code&gt; 标注 &lt;code&gt;x&lt;/code&gt; 的生命周期。如您所见，内部的 &lt;code&gt;'b&lt;/code&gt; 块比外部的 &lt;code&gt;'a&lt;/code&gt; 生存期块小得多。在编译时，Rust比较两个生存期的大小，发现 &lt;code&gt;r&lt;/code&gt; 的生存期为 &lt;code&gt;'a&lt;/code&gt; ,但它引用的生存期为 &lt;code&gt;'b&lt;/code&gt; 。该程序被拒绝，因为 &lt;code&gt;'b&lt;/code&gt; 短于 &lt;code&gt;'a&lt;/code&gt; ：引用的主题没有引用那么长。</target>
        </trans-unit>
        <trans-unit id="1d072835ae81d38506d756c212f27d937b407880" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;ve defined a method named &lt;code&gt;x&lt;/code&gt; on &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; that returns a reference to the data in the field &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">在这里，我们在 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 上定义了一个名为 &lt;code&gt;x&lt;/code&gt; 的方法，该方法返回对字段 &lt;code&gt;x&lt;/code&gt; 中数据的引用。</target>
        </trans-unit>
        <trans-unit id="b22056ea03c2bfc7c7131245d47003a6d2f7232e" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;ve defined a struct &lt;code&gt;IpAddr&lt;/code&gt; that has two fields: a &lt;code&gt;kind&lt;/code&gt; field that is of type &lt;code&gt;IpAddrKind&lt;/code&gt; (the enum we defined previously) and an &lt;code&gt;address&lt;/code&gt; field of type &lt;code&gt;String&lt;/code&gt;. We have two instances of this struct. The first, &lt;code&gt;home&lt;/code&gt;, has the value &lt;code&gt;IpAddrKind::V4&lt;/code&gt; as its &lt;code&gt;kind&lt;/code&gt; with associated address data of &lt;code&gt;127.0.0.1&lt;/code&gt;. The second instance, &lt;code&gt;loopback&lt;/code&gt;, has the other variant of &lt;code&gt;IpAddrKind&lt;/code&gt; as its &lt;code&gt;kind&lt;/code&gt; value, &lt;code&gt;V6&lt;/code&gt;, and has address &lt;code&gt;::1&lt;/code&gt; associated with it. We&amp;rsquo;ve used a struct to bundle the &lt;code&gt;kind&lt;/code&gt; and &lt;code&gt;address&lt;/code&gt; values together, so now the variant is associated with the value.</source>
          <target state="translated">在这里，我们定义了一个结构 &lt;code&gt;IpAddr&lt;/code&gt; ，它具有两个字段：一个 &lt;code&gt;kind&lt;/code&gt; 字段，其类型为 &lt;code&gt;IpAddrKind&lt;/code&gt; （我们之前定义的枚举），另一个 &lt;code&gt;address&lt;/code&gt; 类型为 &lt;code&gt;String&lt;/code&gt; 。我们有此结构的两个实例。第一个为 &lt;code&gt;home&lt;/code&gt; ，其值为 &lt;code&gt;IpAddrKind::V4&lt;/code&gt; 作为其 &lt;code&gt;kind&lt;/code&gt; 具有关联的地址数据 &lt;code&gt;127.0.0.1&lt;/code&gt; 。第二个实例 &lt;code&gt;loopback&lt;/code&gt; 具有 &lt;code&gt;IpAddrKind&lt;/code&gt; 的另一个变体作为其 &lt;code&gt;kind&lt;/code&gt; 值 &lt;code&gt;V6&lt;/code&gt; ，并具有与 &lt;code&gt;::1&lt;/code&gt; 关联的地址。我们使用了一个结构将 &lt;code&gt;kind&lt;/code&gt; 和 &lt;code&gt;address&lt;/code&gt; 值一起使用，因此现在变量与值相关联。</target>
        </trans-unit>
        <trans-unit id="046091a3f10b4e94cc5b7d93ba3518dfd24f4c0f" translate="yes" xml:space="preserve">
          <source>Here, we're saying that the implementation exists on Wrapper only when the wrapped type &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Clone&lt;/code&gt;. The &lt;code&gt;where&lt;/code&gt; clause is important because some types will not implement &lt;code&gt;Clone&lt;/code&gt;, and thus will not get this method.</source>
          <target state="translated">在这里，我们说的是只有包装类型 &lt;code&gt;T&lt;/code&gt; 实现 &lt;code&gt;Clone&lt;/code&gt; 时，该实现才存在于Wrapper上。在 &lt;code&gt;where&lt;/code&gt; ，因为某些类型将不执行条款是很重要的 &lt;code&gt;Clone&lt;/code&gt; ，因而不会得到这种方法。</target>
        </trans-unit>
        <trans-unit id="84c52d06e43bddd068876e6b5771442213f18d2a" translate="yes" xml:space="preserve">
          <source>Here, you have used the inappropriate lifetime in the &lt;code&gt;impl Trait&lt;/code&gt;, The &lt;code&gt;impl Trait&lt;/code&gt; can only capture lifetimes bound at the fn or impl level.</source>
          <target state="translated">在这里，您在 &lt;code&gt;impl Trait&lt;/code&gt; 中使用了不适当的生存期，而 &lt;code&gt;impl Trait&lt;/code&gt; 仅可以捕获在fn或impl级别上绑定的生存期。</target>
        </trans-unit>
        <trans-unit id="2eb18b6c522d039c3c0dcd7089256c0ad6492059" translate="yes" xml:space="preserve">
          <source>Hex</source>
          <target state="translated">Hex</target>
        </trans-unit>
        <trans-unit id="91ed5d7ea6cd895e371f61ed45ccc686b068fc10" translate="yes" xml:space="preserve">
          <source>Hex integer</source>
          <target state="translated">十六进制整数</target>
        </trans-unit>
        <trans-unit id="df212c2ac8dde3b394685d24542d906c68321356" translate="yes" xml:space="preserve">
          <source>Higher-level synchronization objects</source>
          <target state="translated">更高级别的同步对象</target>
        </trans-unit>
        <trans-unit id="7319d8cc88397a63e7ae82683fed6023e2ba482c" translate="yes" xml:space="preserve">
          <source>Higher-ranked lifetime bounds</source>
          <target state="translated">排名较高的一生界限</target>
        </trans-unit>
        <trans-unit id="699f2601254a23df8fa1d5fed485a0da27f47873" translate="yes" xml:space="preserve">
          <source>Higher-ranked lifetimes may also be specified just before the trait, the only difference is the scope of the lifetime parameter, which extends only to the end of the following trait instead of the whole bound. This function is equivalent to the last one.</source>
          <target state="translated">也可以在特质之前指定更高等级的寿命,唯一不同的是寿命参数的范围,它只延伸到下面特质的末端,而不是整个边界。这个函数相当于上一个函数。</target>
        </trans-unit>
        <trans-unit id="33df4c2b13cbd6c2495bdbed3c2c401ea9db0b73" translate="yes" xml:space="preserve">
          <source>Higher-ranked trait bounds</source>
          <target state="translated">较高等级的特质界限</target>
        </trans-unit>
        <trans-unit id="02d9e95b138a4fba666ec5899da0c73598dfb07a" translate="yes" xml:space="preserve">
          <source>Hints to compiler that affects how code should be emitted or optimized.</source>
          <target state="translated">对编译器的提示,影响代码应该如何发出或优化。</target>
        </trans-unit>
        <trans-unit id="410abe45925442482c6a1847631462e1f9e2aa9a" translate="yes" xml:space="preserve">
          <source>Hints to compiler that affects how code should be emitted or optimized. Hints may be compile time or runtime.</source>
          <target state="translated">给编译器的提示,影响代码应该如何发射或优化。提示可能是编译时或运行时的。</target>
        </trans-unit>
        <trans-unit id="8fa3a5e1e29277a4a2b8f85784650b518cec2c19" translate="yes" xml:space="preserve">
          <source>Hints to the compiler that branch condition is likely to be false. Returns the value passed to it.</source>
          <target state="translated">向编译器提示分支条件可能为假。返回传递给它的值。</target>
        </trans-unit>
        <trans-unit id="97a557b0407c848d7b5a674a63e1f75673a72a22" translate="yes" xml:space="preserve">
          <source>Hints to the compiler that branch condition is likely to be true. Returns the value passed to it.</source>
          <target state="translated">向编译器提示分支条件可能为真。返回传递给它的值。</target>
        </trans-unit>
        <trans-unit id="80fd9958e4052dae4a04ec25478352520d67b4b8" translate="yes" xml:space="preserve">
          <source>Hooray! Rust 1.5 is done! However, we&amp;rsquo;ve forgotten one thing: because the six weeks have gone by, we also need a new beta of the &lt;em&gt;next&lt;/em&gt; version of Rust, 1.6. So after &lt;code&gt;stable&lt;/code&gt; branches off of &lt;code&gt;beta&lt;/code&gt;, the next version of &lt;code&gt;beta&lt;/code&gt; branches off of &lt;code&gt;nightly&lt;/code&gt; again:</source>
          <target state="translated">万岁！Rust 1.5完成了！但是，我们已经忘记了一件事：由于已经过去了六个星期，因此我们还需要&lt;em&gt;下一个&lt;/em&gt; Rust版本1.6 的新Beta 。因此，在 &lt;code&gt;beta&lt;/code&gt; &lt;code&gt;stable&lt;/code&gt; 分支之后， &lt;code&gt;nightly&lt;/code&gt; 版本的 &lt;code&gt;beta&lt;/code&gt; 再次分支一次：</target>
        </trans-unit>
        <trans-unit id="a341da978b3cbbea425da4874e79958a3be6b854" translate="yes" xml:space="preserve">
          <source>How Deref Coercion Interacts with Mutability</source>
          <target state="translated">Deref Coercion如何与Mutability相互作用?</target>
        </trans-unit>
        <trans-unit id="d344cc5f79b7b6e913f964dbbc4e02bc173d4e92" translate="yes" xml:space="preserve">
          <source>How can I compare two different types?</source>
          <target state="translated">如何比较两种不同的类型?</target>
        </trans-unit>
        <trans-unit id="b9691dd477ecb76d1a6f3d5bbee24f86998a66d9" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Clone&lt;/code&gt;?</source>
          <target state="translated">如何实现 &lt;code&gt;Clone&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="a983251965c63473a1e84135e053268152b20692" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Copy&lt;/code&gt;?</source>
          <target state="translated">如何实现 &lt;code&gt;Copy&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="90084b4cc636cc9404dd416f2e580ffcac6958d2" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Default&lt;/code&gt;?</source>
          <target state="translated">如何实现 &lt;code&gt;Default&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="d8e36d59adc904734a7c5575517b6fe0eeceec60" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Eq&lt;/code&gt;?</source>
          <target state="translated">如何实现 &lt;code&gt;Eq&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="abe50871479611eca84afd8dcffaec7414f4b665" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Ord&lt;/code&gt;?</source>
          <target state="translated">如何实施 &lt;code&gt;Ord&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="a86f0c480a53af07a5339e4a6426e55601cb46dc" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;PartialEq&lt;/code&gt;?</source>
          <target state="translated">如何实现 &lt;code&gt;PartialEq&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="a00e532c303bae49fb14eef74bc7c06484efea04" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;PartialOrd&lt;/code&gt;?</source>
          <target state="translated">如何实现 &lt;code&gt;PartialOrd&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="8bcb70d690260ea744efd091583de3413f03f2d0" translate="yes" xml:space="preserve">
          <source>How can we define some default values? You can use &lt;code&gt;Default&lt;/code&gt;:</source>
          <target state="translated">我们如何定义一些默认值？您可以使用 &lt;code&gt;Default&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ac97bbda97cfacdb06a7fbecfd828bfbc649940c" translate="yes" xml:space="preserve">
          <source>How do we know &lt;code&gt;File::open&lt;/code&gt; returns a &lt;code&gt;Result&lt;/code&gt;? We could look at the &lt;a href=&quot;../std/index&quot;&gt;standard library API documentation&lt;/a&gt;, or we could ask the compiler! If we give &lt;code&gt;f&lt;/code&gt; a type annotation that we know is &lt;em&gt;not&lt;/em&gt; the return type of the function and then try to compile the code, the compiler will tell us that the types don&amp;rsquo;t match. The error message will then tell us what the type of &lt;code&gt;f&lt;/code&gt;&lt;em&gt;is&lt;/em&gt;. Let&amp;rsquo;s try it! We know that the return type of &lt;code&gt;File::open&lt;/code&gt; isn&amp;rsquo;t of type &lt;code&gt;u32&lt;/code&gt;, so let&amp;rsquo;s change the &lt;code&gt;let f&lt;/code&gt; statement to this:</source>
          <target state="translated">我们怎么知道 &lt;code&gt;File::open&lt;/code&gt; 返回 &lt;code&gt;Result&lt;/code&gt; ？我们可以看一下&lt;a href=&quot;../std/index&quot;&gt;标准库API文档&lt;/a&gt;，也可以询问编译器！如果给 &lt;code&gt;f&lt;/code&gt; 一个我们知道&lt;em&gt;不是&lt;/em&gt;函数的返回类型的类型注释，然后尝试编译代码，则编译器会告诉我们类型不匹配。错误消息将告诉我们 &lt;code&gt;f&lt;/code&gt; 的类型&lt;em&gt;是&lt;/em&gt;什么。试试吧！我们知道 &lt;code&gt;File::open&lt;/code&gt; 的返回类型不是 &lt;code&gt;u32&lt;/code&gt; 类型，因此让我们将 &lt;code&gt;let f&lt;/code&gt; 语句更改为：</target>
        </trans-unit>
        <trans-unit id="c77df57666e7d061d1c5eeb6d1b1b4663f41398a" translate="yes" xml:space="preserve">
          <source>How to Use This Book</source>
          <target state="translated">如何使用这本书</target>
        </trans-unit>
        <trans-unit id="9264c72068f4a42ab4bf1cb16708fbe650c704ec" translate="yes" xml:space="preserve">
          <source>How to Write Tests</source>
          <target state="translated">如何编写测试</target>
        </trans-unit>
        <trans-unit id="fc0a5ea77505e42cd0dd485ee502c0a345de0fc4" translate="yes" xml:space="preserve">
          <source>How to Write a Custom &lt;code id=&quot;how-to-write-a-custom-derive-macro&quot;&gt;derive&lt;/code&gt; Macro</source>
          <target state="translated">如何编写自定义 &lt;code id=&quot;how-to-write-a-custom-derive-macro&quot;&gt;derive&lt;/code&gt; 宏</target>
        </trans-unit>
        <trans-unit id="ad4a0038f92fbf9afa07ab6d269a6a337b56f053" translate="yes" xml:space="preserve">
          <source>How to combine the sub-expressions' values to obtain the value of the expression</source>
          <target state="translated">如何将子表达式的值组合起来,得到表达式的值</target>
        </trans-unit>
        <trans-unit id="9a65f179439d735746c8cd2892082ebe3669f2c2" translate="yes" xml:space="preserve">
          <source>How to create threads to run multiple pieces of code at the same time</source>
          <target state="translated">如何创建线程来同时运行多段代码?</target>
        </trans-unit>
        <trans-unit id="62c635e88978649a0009198984dfd524bc6937d1" translate="yes" xml:space="preserve">
          <source>How to read this documentation</source>
          <target state="translated">如何阅读本文件</target>
        </trans-unit>
        <trans-unit id="2ef34f8c5ce17d8eb29baa4d5f6535815ba4013f" translate="yes" xml:space="preserve">
          <source>How to use these two features to improve the I/O project in Chapter 12</source>
          <target state="translated">第12章如何使用这两个功能来改进I/O项目?</target>
        </trans-unit>
        <trans-unit id="f5abcbd8d5f910274d31d405f70ebd71158dda69" translate="yes" xml:space="preserve">
          <source>However be careful: if you try to access an index which isn't in the &lt;code&gt;Vec&lt;/code&gt;, your software will panic! You cannot do this:</source>
          <target state="translated">但是要当心：如果您尝试访问 &lt;code&gt;Vec&lt;/code&gt; 中没有的索引，则您的软件将崩溃！你不能做这个：</target>
        </trans-unit>
        <trans-unit id="9a3761438ee9135873d2d6c4d19984a1561781e6" translate="yes" xml:space="preserve">
          <source>However be cautious: this method expects &lt;code&gt;self&lt;/code&gt; to be mutable, which is generally not the case when using a &lt;code&gt;RefCell&lt;/code&gt;. Take a look at the &lt;a href=&quot;#method.borrow_mut&quot;&gt;&lt;code&gt;borrow_mut&lt;/code&gt;&lt;/a&gt; method instead if &lt;code&gt;self&lt;/code&gt; isn't mutable.</source>
          <target state="translated">但是要小心：此方法期望 &lt;code&gt;self&lt;/code&gt; 是可变的，通常在使用 &lt;code&gt;RefCell&lt;/code&gt; 时不是这种情况。如果 &lt;code&gt;self&lt;/code&gt; 不可变，请看一下&lt;a href=&quot;#method.borrow_mut&quot;&gt; &lt;code&gt;borrow_mut&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="a589771e9e0d721829c806425bd05e6c296a62c6" translate="yes" xml:space="preserve">
          <source>However be cautious: this method expects &lt;code&gt;self&lt;/code&gt; to be mutable, which is generally not the case when using a &lt;code&gt;RefCell&lt;/code&gt;. Take a look at the &lt;a href=&quot;struct.refcell#method.borrow_mut&quot;&gt;&lt;code&gt;borrow_mut&lt;/code&gt;&lt;/a&gt; method instead if &lt;code&gt;self&lt;/code&gt; isn't mutable.</source>
          <target state="translated">但是要小心：此方法期望 &lt;code&gt;self&lt;/code&gt; 是可变的，通常在使用 &lt;code&gt;RefCell&lt;/code&gt; 时不是这种情况。如果 &lt;code&gt;self&lt;/code&gt; 不可变，请看一下&lt;a href=&quot;struct.refcell#method.borrow_mut&quot;&gt; &lt;code&gt;borrow_mut&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="98f7e0f867227ba5004f997a2d43f7281873ef09" translate="yes" xml:space="preserve">
          <source>However it remains possible to implement the others separately for types which do not have a total order. For example, for floating point numbers, &lt;code&gt;NaN &amp;lt; 0 == false&lt;/code&gt; and &lt;code&gt;NaN &amp;gt;= 0 == false&lt;/code&gt; (cf. IEEE 754-2008 section 5.11).</source>
          <target state="translated">但是，对于没有总订单的类型，仍然可以单独实现其他类型。例如，对于浮点数， &lt;code&gt;NaN &amp;lt; 0 == false&lt;/code&gt; 和 &lt;code&gt;NaN &amp;gt;= 0 == false&lt;/code&gt; （请参阅IEEE 754-2008第5.11节）。</target>
        </trans-unit>
        <trans-unit id="06b5f47175aeebdf26128c567eba8d39893966c4" translate="yes" xml:space="preserve">
          <source>However programmers will usually prefer to use &lt;a href=&quot;../sync/mpsc/index&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt;s, &lt;a href=&quot;../sync/struct.condvar&quot;&gt;&lt;code&gt;Condvar&lt;/code&gt;&lt;/a&gt;s, &lt;a href=&quot;../sync/struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt;es or &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; for their synchronization routines, as they avoid thinking about thread scheduling.</source>
          <target state="translated">但是，程序员通常更喜欢使用&lt;a href=&quot;../sync/mpsc/index&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../sync/struct.condvar&quot;&gt; &lt;code&gt;Condvar&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../sync/struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;struct.joinhandle#method.join&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt;作为其同步例程，因为他们避免考虑线程调度。</target>
        </trans-unit>
        <trans-unit id="99de4c47e704419c664802a54254a42292d00132" translate="yes" xml:space="preserve">
          <source>However remember that a type &lt;em&gt;containing&lt;/em&gt; a &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; is not necessarily the same layout; Rust does not in general guarantee that the fields of a &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; have the same order as a &lt;code&gt;Foo&amp;lt;U&amp;gt;&lt;/code&gt; even if &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; have the same size and alignment. Furthermore because any bit value is valid for a &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; the compiler can't apply non-zero/niche-filling optimizations, potentially resulting in a larger size:</source>
          <target state="translated">但是请记住，一个类型&lt;em&gt;包含&lt;/em&gt;一个 &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 不一定是相同的布局; Rust通常不保证 &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; 的字段具有与 &lt;code&gt;Foo&amp;lt;U&amp;gt;&lt;/code&gt; 相同的顺序，即使 &lt;code&gt;T&lt;/code&gt; 和 &lt;code&gt;U&lt;/code&gt; 具有相同的大小和对齐方式。此外，由于任何位值对于 &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 有效，因此编译器无法应用非零/小生境填充优化，可能会导致更大的尺寸：</target>
        </trans-unit>
        <trans-unit id="78a2c549597916b72868a0675d936d5af7b87a27" translate="yes" xml:space="preserve">
          <source>However there is one case where &lt;code&gt;!&lt;/code&gt; syntax can be used before &lt;code&gt;!&lt;/code&gt; is stabilized as a full-fledged type: in the position of a function&amp;rsquo;s return type. Specifically, it is possible implementations for two different function pointer types:</source>
          <target state="translated">但是，有一种情况 &lt;code&gt;!&lt;/code&gt; 语法可以在之前使用 &lt;code&gt;!&lt;/code&gt; 被稳定为完整类型：在函数的返回类型的位置。具体来说，可以实现两种不同的函数指针类型：</target>
        </trans-unit>
        <trans-unit id="cbb72443619bbca435164ca1a76cab29482ce889" translate="yes" xml:space="preserve">
          <source>However there is one case where &lt;code&gt;!&lt;/code&gt; syntax can be used before &lt;code&gt;!&lt;/code&gt; is stabilized as a full-fleged type: in the position of a function&amp;rsquo;s return type. Specifically, it is possible implementations for two different function pointer types:</source>
          <target state="translated">但是，有一种情况 &lt;code&gt;!&lt;/code&gt; 语法可以在之前使用 &lt;code&gt;!&lt;/code&gt; 稳定为全功能类型：在函数的返回类型位置。具体来说，可以实现两种不同的函数指针类型：</target>
        </trans-unit>
        <trans-unit id="d670e0e16c2745ec16c6eaa903327038d8c0e422" translate="yes" xml:space="preserve">
          <source>However there is one caveat: prior to the 2008 version of IEEE-754, how to interpret the NaN signaling bit wasn't actually specified. Most platforms (notably x86 and ARM) picked the interpretation that was ultimately standardized in 2008, but some didn't (notably MIPS). As a result, all signaling NaNs on MIPS are quiet NaNs on x86, and vice-versa.</source>
          <target state="translated">然而有一个注意事项:在2008年的IEEE-754版本之前,如何解释NaN信号位实际上并没有被指定。大多数平台(尤其是x86和ARM)选择了最终在2008年标准化的解释,但有些平台没有(尤其是MIPS)。因此,MIPS上所有的信号NaN都是x86上的安静NaN,反之亦然。</target>
        </trans-unit>
        <trans-unit id="0351e6925d735478389ca7fa9374b4cd22a63b09" translate="yes" xml:space="preserve">
          <source>However, &lt;a href=&quot;struct.pathbuf#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; is best used for dynamic situations. This is a better way to do this when you know all of the components ahead of time:</source>
          <target state="translated">但是，&lt;a href=&quot;struct.pathbuf#method.push&quot;&gt; &lt;code&gt;push&lt;/code&gt; &lt;/a&gt;最好用于动态情况。当您提前了解所有组件时，这是一种更好的方法：</target>
        </trans-unit>
        <trans-unit id="3371f3c5522eaf5798eeaab8876eaa7be0179a80" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;dyn Trait&lt;/code&gt; is likely to produce smaller code than &lt;code&gt;impl Trait&lt;/code&gt; / generic parameters as the method won't be duplicated for each concrete type.</source>
          <target state="translated">但是， &lt;code&gt;dyn Trait&lt;/code&gt; 可能会产生比 &lt;code&gt;impl Trait&lt;/code&gt; /泛型参数小的代码，因为该方法不会针对每种具体类型重复。</target>
        </trans-unit>
        <trans-unit id="9e9143c027c4bd572f82aee5fcf41df94d158757" translate="yes" xml:space="preserve">
          <source>However, a better solution would be using fully explicit naming of type and trait:</source>
          <target state="translated">然而,更好的解决方案是使用类型和特质的完全显式命名。</target>
        </trans-unit>
        <trans-unit id="ee975de6dd0772652ad342b32f8653a59db9e61f" translate="yes" xml:space="preserve">
          <source>However, a single argument with a trailing comma will still not be treated as a tuple, following the convention of ignoring trailing commas in macro invocations. You can use a 1-tuple directly if you need one:</source>
          <target state="translated">但是,带尾部逗号的单个参数仍然不会被视为元组,遵循在宏调用中忽略尾部逗号的惯例。如果需要的话,可以直接使用1-元组。</target>
        </trans-unit>
        <trans-unit id="b007fe5fc274829b5c0d27c599f3eea8f9ba132a" translate="yes" xml:space="preserve">
          <source>However, associated functions that are part of traits don&amp;rsquo;t have a &lt;code&gt;self&lt;/code&gt; parameter. When two types in the same scope implement that trait, Rust can&amp;rsquo;t figure out which type you mean unless you use &lt;em&gt;fully qualified syntax&lt;/em&gt;. For example, the &lt;code&gt;Animal&lt;/code&gt; trait in Listing 19-19 has the associated function &lt;code&gt;baby_name&lt;/code&gt;, the implementation of &lt;code&gt;Animal&lt;/code&gt; for the struct &lt;code&gt;Dog&lt;/code&gt;, and the associated function &lt;code&gt;baby_name&lt;/code&gt; defined on &lt;code&gt;Dog&lt;/code&gt; directly.</source>
          <target state="translated">但是，作为特征的一部分的关联函数没有 &lt;code&gt;self&lt;/code&gt; 参数。当同一作用域中的两个类型实现该特性时，Rust无法确定您指的是哪种类型，除非您使用&lt;em&gt;完全限定的语法&lt;/em&gt;。例如，清单19-19中的 &lt;code&gt;Animal&lt;/code&gt; trait具有关联的功能 &lt;code&gt;baby_name&lt;/code&gt; ，结构 &lt;code&gt;Dog&lt;/code&gt; 的 &lt;code&gt;Animal&lt;/code&gt; 的实现以及直接在 &lt;code&gt;Dog&lt;/code&gt; 上定义的关联的功能 &lt;code&gt;baby_name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a8a92146e9c361c007de32df04115100977209af" translate="yes" xml:space="preserve">
          <source>However, be careful when two types have a common associated type:</source>
          <target state="translated">但是,当两种类型具有共同的关联类型时,要注意。</target>
        </trans-unit>
        <trans-unit id="7c05de5702d4d9921eaeead5a04ffacda460142d" translate="yes" xml:space="preserve">
          <source>However, because &lt;code&gt;a&lt;/code&gt; is still referencing the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; that was in &lt;code&gt;b&lt;/code&gt;, that &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; has a count of 1 rather than 0, so the memory the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; has on the heap won&amp;rsquo;t be dropped. The memory will just sit there with a count of 1, forever. To visualize this reference cycle, we&amp;rsquo;ve created a diagram in Figure 15-4.</source>
          <target state="translated">但是，因为 &lt;code&gt;a&lt;/code&gt; 仍然引用 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 这是在 &lt;code&gt;b&lt;/code&gt; ，即 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 具有1，而不是0的计数，所以存储器中的 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 对堆将不被丢弃。内存将永远坐在那里，计数为1。为了可视化该参考周期，我们在图15-4中创建了一个图表。</target>
        </trans-unit>
        <trans-unit id="0161534a8ade8082b05e52cb4b19d957b4c686da" translate="yes" xml:space="preserve">
          <source>However, being able to represent this wide range of numbers comes at the cost of precision: floats can only represent some of the real numbers and calculation with floats round to a nearby representable number. For example, &lt;code&gt;5.0&lt;/code&gt; and &lt;code&gt;1.0&lt;/code&gt; can be exactly represented as &lt;code&gt;f32&lt;/code&gt;, but &lt;code&gt;1.0 / 5.0&lt;/code&gt; results in &lt;code&gt;0.20000000298023223876953125&lt;/code&gt; since &lt;code&gt;0.2&lt;/code&gt; cannot be exactly represented as &lt;code&gt;f32&lt;/code&gt;. Note however, that printing floats with &lt;code&gt;println&lt;/code&gt; and friends will often discard insignificant digits: &lt;code&gt;println!(&quot;{}&quot;, 1.0f32 / 5.0f32)&lt;/code&gt; will print &lt;code&gt;0.2&lt;/code&gt;.</source>
          <target state="translated">但是，能够表示这么广泛的数字会以精度为代价：浮点数只能表示某些实数，而浮点数会四舍五入到附近的可表示数字。例如， &lt;code&gt;5.0&lt;/code&gt; 和 &lt;code&gt;1.0&lt;/code&gt; 可以精确地表示为 &lt;code&gt;f32&lt;/code&gt; ，但是 &lt;code&gt;1.0 / 5.0&lt;/code&gt; 得到 &lt;code&gt;0.20000000298023223876953125&lt;/code&gt; ,因为 &lt;code&gt;0.2&lt;/code&gt; 不能精确地表示为 &lt;code&gt;f32&lt;/code&gt; 。但是请注意，使用 &lt;code&gt;println&lt;/code&gt; 和友人进行打印浮动通常会舍弃无关紧要的数字： &lt;code&gt;println!(&quot;{}&quot;, 1.0f32 / 5.0f32)&lt;/code&gt; 将打印 &lt;code&gt;0.2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc86d5089c69372edd80eafac68df3ec0dbaefb7" translate="yes" xml:space="preserve">
          <source>However, being able to represent this wide range of numbers comes at the cost of precision: floats can only represent some of the real numbers and calculation with floats round to a nearby representable number. For example, &lt;code&gt;5.0&lt;/code&gt; and &lt;code&gt;1.0&lt;/code&gt; can be exactly represented as &lt;code&gt;f32&lt;/code&gt;, but &lt;code&gt;1.0 / 5.0&lt;/code&gt; results in &lt;code&gt;0.20000000298023223876953125&lt;/code&gt; since &lt;code&gt;0.2&lt;/code&gt; cannot be exactly represented as &lt;code&gt;f32&lt;/code&gt;. Note, however, that printing floats with &lt;code&gt;println&lt;/code&gt; and friends will often discard insignificant digits: &lt;code&gt;println!(&quot;{}&quot;, 1.0f32 / 5.0f32)&lt;/code&gt; will print &lt;code&gt;0.2&lt;/code&gt;.</source>
          <target state="translated">但是，能够表示这么广泛的数字会以精度为代价：浮点数只能表示某些实数，而浮点数会四舍五入到附近的可表示数字。例如， &lt;code&gt;5.0&lt;/code&gt; 和 &lt;code&gt;1.0&lt;/code&gt; 可以精确地表示为 &lt;code&gt;f32&lt;/code&gt; ，但是 &lt;code&gt;1.0 / 5.0&lt;/code&gt; 得到 &lt;code&gt;0.20000000298023223876953125&lt;/code&gt; ,因为 &lt;code&gt;0.2&lt;/code&gt; 不能精确地表示为 &lt;code&gt;f32&lt;/code&gt; 。但是请注意，带有 &lt;code&gt;println&lt;/code&gt; 和友人的打印浮点数通常会舍弃无关紧要的数字： &lt;code&gt;println!(&quot;{}&quot;, 1.0f32 / 5.0f32)&lt;/code&gt; 将打印 &lt;code&gt;0.2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a75f8c79454007f698be22ee125cb88b1db6c03c" translate="yes" xml:space="preserve">
          <source>However, for clients that do not wish to track the capacity returned by &lt;code&gt;alloc_excess&lt;/code&gt; locally, this method is likely to produce useful results.</source>
          <target state="translated">但是，对于不希望在本地跟踪 &lt;code&gt;alloc_excess&lt;/code&gt; 返回的容量的客户端，此方法可能会产生有用的结果。</target>
        </trans-unit>
        <trans-unit id="c6f1d589fbc14406ddd7e944ec737df44d57ed77" translate="yes" xml:space="preserve">
          <source>However, having lots of error checks in all of your functions would be verbose and annoying. Fortunately, you can use Rust&amp;rsquo;s type system (and thus the type checking the compiler does) to do many of the checks for you. If your function has a particular type as a parameter, you can proceed with your code&amp;rsquo;s logic knowing that the compiler has already ensured you have a valid value. For example, if you have a type rather than an &lt;code&gt;Option&lt;/code&gt;, your program expects to have &lt;em&gt;something&lt;/em&gt; rather than &lt;em&gt;nothing&lt;/em&gt;. Your code then doesn&amp;rsquo;t have to handle two cases for the &lt;code&gt;Some&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt; variants: it will only have one case for definitely having a value. Code trying to pass nothing to your function won&amp;rsquo;t even compile, so your function doesn&amp;rsquo;t have to check for that case at runtime. Another example is using an unsigned integer type such as &lt;code&gt;u32&lt;/code&gt;, which ensures the parameter is never negative.</source>
          <target state="translated">但是，在所有功能中进行大量错误检查会很麻烦。幸运的是，您可以使用Rust的类型系统（从而检查编译器的类型）来为您做许多检查。如果您的函数具有特定类型的参数，则可以在知道编译器已经确保您具有有效值的情况下继续执行代码的逻辑。例如，如果您使用类型而不是 &lt;code&gt;Option&lt;/code&gt; ，则程序期望的是&lt;em&gt;某些内容&lt;/em&gt;而不是&lt;em&gt;没有内容&lt;/em&gt;。然后，您的代码不必处理 &lt;code&gt;Some&lt;/code&gt; 和 &lt;code&gt;None&lt;/code&gt; 的两种情况变体：只有一种情况肯定具有价值。尝试不向函数传递任何内容的代码甚至不会编译，因此您的函数不必在运行时检查这种情况。另一个示例是使用无符号整数类型（例如 &lt;code&gt;u32&lt;/code&gt; )，以确保参数永远不会为负。</target>
        </trans-unit>
        <trans-unit id="c47ddb353392208fbaf5c29553d62da521ea2e56" translate="yes" xml:space="preserve">
          <source>However, if a type implements &lt;code&gt;Copy&lt;/code&gt;, it instead has 'copy semantics':</source>
          <target state="translated">但是，如果类型实现 &lt;code&gt;Copy&lt;/code&gt; ，则它具有&amp;ldquo;复制语义&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="601ae6aeca914c05ec96fb8df8c9c4178c5a0a78" translate="yes" xml:space="preserve">
          <source>However, if it derives from &lt;code&gt;Super&amp;lt;Self&amp;gt;&lt;/code&gt;, even though &lt;code&gt;Super&lt;/code&gt; is object safe, the method &lt;code&gt;get_a()&lt;/code&gt; would return an object of unknown type when called on the function. &lt;code&gt;Self&lt;/code&gt; type parameters let us make object safe traits no longer safe, so they are forbidden when specifying supertraits.</source>
          <target state="translated">但是，即使它是从 &lt;code&gt;Super&amp;lt;Self&amp;gt;&lt;/code&gt; 派生的，即使 &lt;code&gt;Super&lt;/code&gt; 是对象安全的，方法 &lt;code&gt;get_a()&lt;/code&gt; 也会在函数上调用时返回未知类型的对象。 &lt;code&gt;Self&lt;/code&gt; 类型参数使我们可以使对象安全特征不再安全，因此在指定超级特征时将其禁止使用。</target>
        </trans-unit>
        <trans-unit id="7fad1dff57715fb5c533987e92e806ddbde896cc" translate="yes" xml:space="preserve">
          <source>However, if you still wish to use these types, you can achieve this by an unsafe wrapper:</source>
          <target state="translated">但是,如果你仍然希望使用这些类型,你可以通过一个不安全的封装器来实现。</target>
        </trans-unit>
        <trans-unit id="2f1b0df6bf40f54deee89e8870694822d74c8932" translate="yes" xml:space="preserve">
          <source>However, if you wanted to access a field of a struct check that the field name is spelled correctly. Example:</source>
          <target state="translated">但是,如果你想访问一个结构的字段,请检查字段名的拼写是否正确。例子:如果你想访问一个结构的字段,请检查字段名的拼写是否正确。</target>
        </trans-unit>
        <trans-unit id="692ecbc0723f2163cd918161474068cb36f04e45" translate="yes" xml:space="preserve">
          <source>However, one long line is difficult to read, so it&amp;rsquo;s best to divide it. Now let&amp;rsquo;s discuss what this line does.</source>
          <target state="translated">但是，一长行很难阅读，因此最好将其分开。现在，让我们讨论一下这行代码的作用。</target>
        </trans-unit>
        <trans-unit id="26830adb8373fabf090d221485ccd723186cf9b8" translate="yes" xml:space="preserve">
          <source>However, one long line is difficult to read, so it&amp;rsquo;s best to divide it: two lines for two method calls. Now let&amp;rsquo;s discuss what this line does.</source>
          <target state="translated">但是，一长行很难阅读，因此最好将其划分：用于两个方法调用的两行。现在让我们讨论一下这行代码的作用。</target>
        </trans-unit>
        <trans-unit id="dd472996f3f286211f48a487c70490ad383642d1" translate="yes" xml:space="preserve">
          <source>However, our intention in this chapter is to help you learn, not to take the easy route. Because Rust is a systems programming language, we can choose the level of abstraction we want to work with and can go to a lower level than is possible or practical in other languages. We&amp;rsquo;ll write the basic HTTP server and thread pool manually so you can learn the general ideas and techniques behind the crates you might use in the future.</source>
          <target state="translated">但是，本章的目的是帮助您学习，而不是走简单的路线。因为Rust是一种系统编程语言，所以我们可以选择我们要使用的抽象级别，并且可以将其降到比其他语言可能或实用的更低的级别。我们将手动编写基本的HTTP服务器和线程池，以便您学习将来可能使用的板条箱背后的一般思想和技术。</target>
        </trans-unit>
        <trans-unit id="a3c7769e69d54d27cbd8d165bbdf117ddc427c2b" translate="yes" xml:space="preserve">
          <source>However, please keep in mind that the first solution should be preferred.</source>
          <target state="translated">但是,请记住,应该首选第一种解决方案。</target>
        </trans-unit>
        <trans-unit id="9e7ca595910d369d04059d59dd0f26ad24257742" translate="yes" xml:space="preserve">
          <source>However, some higher-level allocation methods (&lt;code&gt;alloc_one&lt;/code&gt;, &lt;code&gt;alloc_array&lt;/code&gt;) are well-defined on zero-sized types and can optionally support them: it is left up to the implementor whether to return &lt;code&gt;Err&lt;/code&gt;, or to return &lt;code&gt;Ok&lt;/code&gt; with some pointer.</source>
          <target state="translated">但是，一些较高级别的分配方法（ &lt;code&gt;alloc_one&lt;/code&gt; ， &lt;code&gt;alloc_array&lt;/code&gt; ）在零大小的类型上定义良好，并且可以选择支持它们：是否返回 &lt;code&gt;Err&lt;/code&gt; 或使用某些指针返回 &lt;code&gt;Ok&lt;/code&gt; 取决于实现者。</target>
        </trans-unit>
        <trans-unit id="bb26cd270c81cacb615098ed7b7796b24ddb7cc6" translate="yes" xml:space="preserve">
          <source>However, sometimes we want our library user to be able to extend the set of types that are valid in a particular situation. To show how we might achieve this, we&amp;rsquo;ll create an example graphical user interface (GUI) tool that iterates through a list of items, calling a &lt;code&gt;draw&lt;/code&gt; method on each one to draw it to the screen&amp;mdash;a common technique for GUI tools. We&amp;rsquo;ll create a library crate called &lt;code&gt;gui&lt;/code&gt; that contains the structure of a GUI library. This crate might include some types for people to use, such as &lt;code&gt;Button&lt;/code&gt; or &lt;code&gt;TextField&lt;/code&gt;. In addition, &lt;code&gt;gui&lt;/code&gt; users will want to create their own types that can be drawn: for instance, one programmer might add an &lt;code&gt;Image&lt;/code&gt; and another might add a &lt;code&gt;SelectBox&lt;/code&gt;.</source>
          <target state="translated">但是，有时我们希望我们的库用户能够扩展在特定情况下有效的类型集。为了显示如何实现此目的，我们将创建一个示例图形用户界面（GUI）工具，该工具可遍历项目列表，在每个项目上调用一个 &lt;code&gt;draw&lt;/code&gt; 方法以将其绘制到屏幕上-这是GUI工具的一种常用技术。我们将创建一个名为 &lt;code&gt;gui&lt;/code&gt; 的库箱，其中包含GUI库的结构。此板条箱可能包括一些供人们使用的类型，例如 &lt;code&gt;Button&lt;/code&gt; 或 &lt;code&gt;TextField&lt;/code&gt; 。此外， &lt;code&gt;gui&lt;/code&gt; 用户将需要创建自己可以绘制的类型：例如，一个程序员可能添加一个 &lt;code&gt;Image&lt;/code&gt; ，另一个程序员可能添加一个Image。 &lt;code&gt;SelectBox&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="090c640dded64692c1c679520894484188072e98" translate="yes" xml:space="preserve">
          <source>However, structural pinning comes with a few extra requirements:</source>
          <target state="translated">但是,结构销路有一些额外的要求。</target>
        </trans-unit>
        <trans-unit id="6446591953c7036afa44804569e6b2a76fecb194" translate="yes" xml:space="preserve">
          <source>However, suffixes on literal tokens parsed as Rust code are restricted.</source>
          <target state="translated">然而,作为Rust代码解析的文字标记的后缀是受限制的。</target>
        </trans-unit>
        <trans-unit id="fd97947a4cfc6a63fedbe7991de9dd273fb032fc" translate="yes" xml:space="preserve">
          <source>However, suffixes on literal tokens parsed as Rust code are restricted. Any suffixes are rejected on non-numeric literal tokens, and numeric literal tokens are accepted only with suffixes from the list below.</source>
          <target state="translated">然而,解析为 Rust 代码的文字标记的后缀是受限制的。任何后缀都会被拒绝在非数字文字标记上,而数字文字标记只接受以下列表中的后缀。</target>
        </trans-unit>
        <trans-unit id="e53d985c5c53455719af4369d5bd75e2e43f4f1b" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;match&lt;/code&gt; expression can be a bit wordy in a situation in which we care about only &lt;em&gt;one&lt;/em&gt; of the cases. For this situation, Rust provides &lt;code&gt;if let&lt;/code&gt;.</source>
          <target state="translated">然而， &lt;code&gt;match&lt;/code&gt; 的表达可以在我们所关心的只是一种情况有点罗嗦&lt;em&gt;一个&lt;/em&gt;案件。对于这种情况，Rust提供 &lt;code&gt;if let&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a11b9e584ed4976bfbc4897d2baa5077bb7ad3ff" translate="yes" xml:space="preserve">
          <source>However, the code in Listing 2-4 won&amp;rsquo;t compile yet. Let&amp;rsquo;s try it:</source>
          <target state="translated">但是，清单2-4中的代码尚未编译。让我们尝试一下：</target>
        </trans-unit>
        <trans-unit id="5ff36d97f387c34f0e3f89e3b84848ea32f28366" translate="yes" xml:space="preserve">
          <source>However, the concept that null is trying to express is still a useful one: a null is a value that is currently invalid or absent for some reason.</source>
          <target state="translated">不过,null所要表达的概念还是很有用的:null是指一个当前因某种原因而无效或不存在的值。</target>
        </trans-unit>
        <trans-unit id="cda87a9e6a4c7e24911050c4147eddad9fb1a4fd" translate="yes" xml:space="preserve">
          <source>However, the pointer may not actually point to allocated memory. In particular, if you construct a &lt;code&gt;Vec&lt;/code&gt; with capacity 0 via &lt;a href=&quot;struct.vec#method.new&quot;&gt;&lt;code&gt;Vec::new&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../macro.vec&quot;&gt;&lt;code&gt;vec![]&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.vec#method.with_capacity&quot;&gt;&lt;code&gt;Vec::with_capacity(0)&lt;/code&gt;&lt;/a&gt;, or by calling &lt;a href=&quot;struct.vec#method.shrink_to_fit&quot;&gt;&lt;code&gt;shrink_to_fit&lt;/code&gt;&lt;/a&gt; on an empty Vec, it will not allocate memory. Similarly, if you store zero-sized types inside a &lt;code&gt;Vec&lt;/code&gt;, it will not allocate space for them. &lt;em&gt;Note that in this case the &lt;code&gt;Vec&lt;/code&gt; may not report a &lt;a href=&quot;struct.vec#method.capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt; of 0&lt;/em&gt;. &lt;code&gt;Vec&lt;/code&gt; will allocate if and only if &lt;a href=&quot;../mem/fn.size_of&quot;&gt;&lt;code&gt;mem::size_of::&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;() * capacity() &amp;gt; 0&lt;/code&gt;. In general, &lt;code&gt;Vec&lt;/code&gt;'s allocation details are very subtle &amp;mdash; if you intend to allocate memory using a &lt;code&gt;Vec&lt;/code&gt; and use it for something else (either to pass to unsafe code, or to build your own memory-backed collection), be sure to deallocate this memory by using &lt;code&gt;from_raw_parts&lt;/code&gt; to recover the &lt;code&gt;Vec&lt;/code&gt; and then dropping it.</source>
          <target state="translated">但是，指针可能实际上没有指向已分配的内存。特别是，如果你建立一个 &lt;code&gt;Vec&lt;/code&gt; 通过与容量0 &lt;a href=&quot;struct.vec#method.new&quot;&gt; &lt;code&gt;Vec::new&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../macro.vec&quot;&gt; &lt;code&gt;vec![]&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;struct.vec#method.with_capacity&quot;&gt; &lt;code&gt;Vec::with_capacity(0)&lt;/code&gt; &lt;/a&gt;，或致电&lt;a href=&quot;struct.vec#method.shrink_to_fit&quot;&gt; &lt;code&gt;shrink_to_fit&lt;/code&gt; &lt;/a&gt;上的空白VEC，也不会分配内存。同样，如果将零大小的类型存储在 &lt;code&gt;Vec&lt;/code&gt; 内，则不会为它们分配空间。&lt;em&gt;注意，在这种情况下， &lt;code&gt;Vec&lt;/code&gt; 可能不会报告&lt;a href=&quot;struct.vec#method.capacity&quot;&gt; &lt;code&gt;capacity&lt;/code&gt; &lt;/a&gt;为0&lt;/em&gt;。仅当&lt;a href=&quot;../mem/fn.size_of&quot;&gt; &lt;code&gt;mem::size_of::&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;() * capacity() &amp;gt; 0&lt;/code&gt; &lt;code&gt;Vec&lt;/code&gt; 才会分配。一般来说， &lt;code&gt;Vec&lt;/code&gt; 的分配细节非常微妙-如果您打算使用 &lt;code&gt;Vec&lt;/code&gt; 分配内存并将其用于其他用途（传递给不安全的代码，或者构建自己的内存支持的集合），请确保使用释放内存。 &lt;code&gt;from_raw_parts&lt;/code&gt; 以恢复 &lt;code&gt;Vec&lt;/code&gt; ，然后将其删除。</target>
        </trans-unit>
        <trans-unit id="71a07da2ac46a34c0d6bf7a73675b61fc8ad742b" translate="yes" xml:space="preserve">
          <source>However, the reverse is not true: not all valid &lt;a href=&quot;../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s are valid &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s. &lt;code&gt;from_u32()&lt;/code&gt; will return &lt;code&gt;None&lt;/code&gt; if the input is not a valid value for a &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">但是，事实并非如此：并非所有有效的&lt;a href=&quot;../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt;都是有效的&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;。如果输入不是&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;的有效值，则 &lt;code&gt;from_u32()&lt;/code&gt; 将返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="627ab6996d8e9eb90f195c27a7e3d742a80e3b8e" translate="yes" xml:space="preserve">
          <source>However, the reverse is not true: not all valid &lt;a href=&quot;../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s are valid &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s. &lt;code&gt;from_u32_unchecked()&lt;/code&gt; will ignore this, and blindly cast to &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, possibly creating an invalid one.</source>
          <target state="translated">但是，事实并非如此：并非所有有效的&lt;a href=&quot;../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt;都是有效的&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;from_u32_unchecked()&lt;/code&gt; 将忽略此内容，并盲目地将其强制转换为&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;，可能会创建一个无效的字符。</target>
        </trans-unit>
        <trans-unit id="3551f079ee4c6634be3812dc148413baa86b8300" translate="yes" xml:space="preserve">
          <source>However, the reverse is not true: not all valid &lt;a href=&quot;primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s are valid &lt;code&gt;char&lt;/code&gt;s. &lt;code&gt;from_u32()&lt;/code&gt; will return &lt;code&gt;None&lt;/code&gt; if the input is not a valid value for a &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">但是，事实并非如此：并非所有有效的&lt;a href=&quot;primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt;都是有效的 &lt;code&gt;char&lt;/code&gt; 。如果输入不是 &lt;code&gt;char&lt;/code&gt; 的有效值，则 &lt;code&gt;from_u32()&lt;/code&gt; 将返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7eb7d7f1f319fa36dc03fb6cd45ffdc556ad5b67" translate="yes" xml:space="preserve">
          <source>However, the reverse is not true: not all valid &lt;a href=&quot;primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s are valid &lt;code&gt;char&lt;/code&gt;s. &lt;code&gt;from_u32_unchecked()&lt;/code&gt; will ignore this, and blindly cast to &lt;code&gt;char&lt;/code&gt;, possibly creating an invalid one.</source>
          <target state="translated">但是，事实并非如此：并非所有有效的&lt;a href=&quot;primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt;都是有效的 &lt;code&gt;char&lt;/code&gt; 。 &lt;code&gt;from_u32_unchecked()&lt;/code&gt; 将忽略此内容，并盲目地将其强制转换为 &lt;code&gt;char&lt;/code&gt; ，可能会创建一个无效的字符。</target>
        </trans-unit>
        <trans-unit id="1f5612bf46edfe618e917ff01d32fb9bebb43312" translate="yes" xml:space="preserve">
          <source>However, the second part is different. In languages with a &lt;em&gt;garbage collector (GC)&lt;/em&gt;, the GC keeps track and cleans up memory that isn&amp;rsquo;t being used anymore, and we don&amp;rsquo;t need to think about it. Without a GC, it&amp;rsquo;s our responsibility to identify when memory is no longer being used and call code to explicitly return it, just as we did to request it. Doing this correctly has historically been a difficult programming problem. If we forget, we&amp;rsquo;ll waste memory. If we do it too early, we&amp;rsquo;ll have an invalid variable. If we do it twice, that&amp;rsquo;s a bug too. We need to pair exactly one &lt;code&gt;allocate&lt;/code&gt; with exactly one &lt;code&gt;free&lt;/code&gt;.</source>
          <target state="translated">但是，第二部分是不同的。在具有&lt;em&gt;垃圾收集器（GC）的&lt;/em&gt;语言中，GC会跟踪并清理不再使用的内存，因此我们无需考虑它。如果没有GC，我们有责任确定何时不再使用内存，并像调用请求一样调用代码以显式返回内存。从历史上看，正确执行此操作一直是编程难题。如果我们忘记了，我们将浪费内存。如果我们做得太早，我们将有一个无效的变量。如果我们做两次，那也是一个错误。我们需要将一个 &lt;code&gt;allocate&lt;/code&gt; 恰好与一个 &lt;code&gt;free&lt;/code&gt; 分配配对。</target>
        </trans-unit>
        <trans-unit id="af229bc0a48ef0630b724d21dd6f456c48e60c69" translate="yes" xml:space="preserve">
          <source>However, there are situations in which it would be useful for a value to mutate itself in its methods but appear immutable to other code. Code outside the value&amp;rsquo;s methods would not be able to mutate the value. Using &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; is one way to get the ability to have interior mutability. But &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; doesn&amp;rsquo;t get around the borrowing rules completely: the borrow checker in the compiler allows this interior mutability, and the borrowing rules are checked at runtime instead. If you violate the rules, you&amp;rsquo;ll get a &lt;code&gt;panic!&lt;/code&gt; instead of a compiler error.</source>
          <target state="translated">但是，在某些情况下，值在其方法中进行自身变异会很有用，但对于其他代码而言却是不变的。值方法之外的代码将无法更改值。使用 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 是获得内部可变性的一种方法。但是 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 不能完全绕开借用规则：编译器中的借用检查器允许这种内部可变性，而是在运行时检查借用规则。如果您违反规则，就会感到 &lt;code&gt;panic!&lt;/code&gt; 而不是编译器错误。</target>
        </trans-unit>
        <trans-unit id="a0d46c846b73ae9a30e6ec8307068cbd57726662" translate="yes" xml:space="preserve">
          <source>However, there is a &lt;a href=&quot;../type-coercions&quot;&gt;coercion&lt;/a&gt; from function items to &lt;a href=&quot;function-pointer&quot;&gt;function pointers&lt;/a&gt; with the same signature, which is triggered not only when a function item is used when a function pointer is directly expected, but also when different function item types with the same signature meet in different arms of the same &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;match&lt;/code&gt;:</source>
          <target state="translated">但是，从功能项到具有相同签名的&lt;a href=&quot;function-pointer&quot;&gt;功能指针&lt;/a&gt;存在&lt;a href=&quot;../type-coercions&quot;&gt;强制&lt;/a&gt;转换，这不仅会在直接期望功能指针时使用功能项时触发，而且在具有相同签名的不同功能项类型遇到不同时也会触发相同的 &lt;code&gt;if&lt;/code&gt; 或 &lt;code&gt;match&lt;/code&gt; 的手臂：</target>
        </trans-unit>
        <trans-unit id="a66a1dddad283613aaa962e121910c064ac30ef0" translate="yes" xml:space="preserve">
          <source>However, there&amp;rsquo;s one problem with this test, as shown here:</source>
          <target state="translated">但是，此测试存在一个问题，如下所示：</target>
        </trans-unit>
        <trans-unit id="18f90c271b4c818c9717e731f31d20c5d63240c8" translate="yes" xml:space="preserve">
          <source>However, they would need to write the implementation block for each type they wanted to use with &lt;code&gt;hello_macro&lt;/code&gt;; we want to spare them from having to do this work.</source>
          <target state="translated">但是，他们需要为要与 &lt;code&gt;hello_macro&lt;/code&gt; 一起使用的每种类型编写实现块；我们想让他们不必做这项工作。</target>
        </trans-unit>
        <trans-unit id="4c27a12b4f8451e9cc5839d83f04460a9e92623c" translate="yes" xml:space="preserve">
          <source>However, this &quot;zombie&quot; value should not be exposed to safe code, and this function should not be called more than once. To use a value after it's been dropped, or drop a value multiple times, can cause Undefined Behavior (depending on what &lt;code&gt;drop&lt;/code&gt; does). This is normally prevented by the type system, but users of &lt;code&gt;ManuallyDrop&lt;/code&gt; must uphold those guarantees without assistance from the compiler.</source>
          <target state="translated">但是，此&amp;ldquo;僵尸&amp;rdquo;值不应暴露给安全代码，并且不应多次调用此函数。在删除某个值或多次删除某个值后使用该值可能会导致未定义行为（取决于 &lt;code&gt;drop&lt;/code&gt; 作用）。类型系统通常会阻止这种情况，但是 &lt;code&gt;ManuallyDrop&lt;/code&gt; 的用户必须坚持这些保证，而无需编译器的帮助。</target>
        </trans-unit>
        <trans-unit id="313fc636d6ceb50d6fb43efb8c2726a3510a1c57" translate="yes" xml:space="preserve">
          <source>However, this extra power comes with extra responsibilities: it is now up to you to ensure soundness. The &lt;code&gt;unsafe&lt;/code&gt; keyword helps by clearly marking the pieces of code that need to worry about this.</source>
          <target state="translated">但是，这种额外的权力还伴随着额外的责任：现在要确保声音的完整性。在 &lt;code&gt;unsafe&lt;/code&gt; 关键字有助于清楚地标记的代码片段是必要担心这一点。</target>
        </trans-unit>
        <trans-unit id="d3b75e55302f15f6020a4b2831ab78b8a9cd134e" translate="yes" xml:space="preserve">
          <source>However, this is not an ideal solution: if it was absolutely critical that the program only operated on values between 1 and 100, and it had many functions with this requirement, having a check like this in every function would be tedious (and might impact performance).</source>
          <target state="translated">然而,这并不是一个理想的解决方案:如果程序只对1和100之间的值进行操作是绝对重要的,而且它有许多函数有这样的要求,那么在每个函数中都要进行这样的检查就会很繁琐(而且可能会影响性能)。</target>
        </trans-unit>
        <trans-unit id="a824bb12ed66d349d925794b2e3920170b4c275c" translate="yes" xml:space="preserve">
          <source>However, this pattern is so common that Rust has a built-in language construct for it, called a &lt;code&gt;while&lt;/code&gt; loop. Listing 3-3 uses &lt;code&gt;while&lt;/code&gt;: the program loops three times, counting down each time, and then, after the loop, it prints another message and exits.</source>
          <target state="translated">但是，这种模式非常普遍，Rust具有内置的语言构造，称为 &lt;code&gt;while&lt;/code&gt; 循环。清单3-3使用 &lt;code&gt;while&lt;/code&gt; ：该程序循环循环3次，每次递减计数，然后在循环之后打印另一条消息并退出。</target>
        </trans-unit>
        <trans-unit id="ada98a89852cf14a520ca2427888843bc3fd0869" translate="yes" xml:space="preserve">
          <source>However, this won't:</source>
          <target state="translated">然而,这不会。</target>
        </trans-unit>
        <trans-unit id="2ba8355a99e10032076801bb58aaec6886066a15" translate="yes" xml:space="preserve">
          <source>However, two concurrency concepts are embedded in the language: the &lt;code&gt;std::marker&lt;/code&gt; traits &lt;code&gt;Sync&lt;/code&gt; and &lt;code&gt;Send&lt;/code&gt;.</source>
          <target state="translated">但是，该语言中嵌入了两个并发概念： &lt;code&gt;std::marker&lt;/code&gt; 特性 &lt;code&gt;Sync&lt;/code&gt; 和 &lt;code&gt;Send&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0fad3453f67fa7a8abf1de710cc99507cae5f79c" translate="yes" xml:space="preserve">
          <source>However, using &lt;code&gt;..&lt;/code&gt; must be unambiguous. If it is unclear which values are intended for matching and which should be ignored, Rust will give us an error. Listing 18-25 shows an example of using &lt;code&gt;..&lt;/code&gt; ambiguously, so it will not compile.</source>
          <target state="translated">但是，使用 &lt;code&gt;..&lt;/code&gt; 必须是明确的。如果不清楚哪些值适合匹配，哪些值应忽略，Rust会给我们一个错误。清单18-25显示了一个示例性地使用 &lt;code&gt;..&lt;/code&gt; 的示例，因此它不会被编译。</target>
        </trans-unit>
        <trans-unit id="f1a26fc372d073b9ed76f398473c3b964914605f" translate="yes" xml:space="preserve">
          <source>However, we&amp;rsquo;ve reintroduced one of the problems from Listing 13-3: we&amp;rsquo;re still calling the closure twice in the first &lt;code&gt;if&lt;/code&gt; block, which will call the expensive code twice and make the user wait twice as long as they need to. We could fix this problem by creating a variable local to that &lt;code&gt;if&lt;/code&gt; block to hold the result of calling the closure, but closures provide us with another solution. We&amp;rsquo;ll talk about that solution in a bit. But first let&amp;rsquo;s talk about why there aren&amp;rsquo;t type annotations in the closure definition and the traits involved with closures.</source>
          <target state="translated">但是，我们重新引入了清单13-3中的一个问题：我们仍然在第一个 &lt;code&gt;if&lt;/code&gt; 块中两次调用闭包，这将两次调用昂贵的代码，并使用户等待所需时间两次。我们可以通过在 &lt;code&gt;if&lt;/code&gt; 块的局部创建一个变量来解决此问题，以保存调用闭包的结果，但是闭包为我们提供了另一种解决方案。我们将稍后讨论该解决方案。但是首先让我们讨论一下为什么闭包定义中没有类型注释以及闭包所涉及的特征。</target>
        </trans-unit>
        <trans-unit id="aeba4f050e04fdf1cf910571a9c79d642b8343c4" translate="yes" xml:space="preserve">
          <source>However, when failure is expected, it&amp;rsquo;s more appropriate to return a &lt;code&gt;Result&lt;/code&gt; than to make a &lt;code&gt;panic!&lt;/code&gt; call. Examples include a parser being given malformed data or an HTTP request returning a status that indicates you have hit a rate limit. In these cases, returning a &lt;code&gt;Result&lt;/code&gt; indicates that failure is an expected possibility that the calling code must decide how to handle.</source>
          <target state="translated">但是，如果预期会失败，则返回 &lt;code&gt;Result&lt;/code&gt; 比 &lt;code&gt;panic!&lt;/code&gt; 更合适！呼叫。示例包括向解析器提供格式错误的数据或HTTP请求，返回的状态表明您已达到速率限制。在这些情况下，返回 &lt;code&gt;Result&lt;/code&gt; 表示失败是调用代码必须决定如何处理的预期可能性。</target>
        </trans-unit>
        <trans-unit id="bd1b29ca1d0594e55daa86076890956a32cf494f" translate="yes" xml:space="preserve">
          <source>However, with trait objects we have to make a table containing &lt;em&gt;every&lt;/em&gt; object that implements the trait. Now, if it has type parameters, we need to add implementations for every type that implements the trait, and there could theoretically be an infinite number of types.</source>
          <target state="translated">但是，对于特征对象，我们必须创建一个表，其中包含实现该特征的&lt;em&gt;每个&lt;/em&gt;对象。现在，如果它具有类型参数，则需要为实现该特征的每个类型添加实现，并且理论上可以有无数个类型。</target>
        </trans-unit>
        <trans-unit id="c83a1e89e4828f4c8e8c03978096139099426f82" translate="yes" xml:space="preserve">
          <source>However, you can only use &lt;code&gt;impl Trait&lt;/code&gt; if you&amp;rsquo;re returning a single type. For example, this code that returns either a &lt;code&gt;NewsArticle&lt;/code&gt; or a &lt;code&gt;Tweet&lt;/code&gt; with the return type specified as &lt;code&gt;impl Summary&lt;/code&gt; wouldn&amp;rsquo;t work:</source>
          <target state="translated">但是，如果要返回单个类型，则只能使用 &lt;code&gt;impl Trait&lt;/code&gt; 。例如，此代码返回的 &lt;code&gt;NewsArticle&lt;/code&gt; 或 &lt;code&gt;Tweet&lt;/code&gt; 的返回类型指定为 &lt;code&gt;impl Summary&lt;/code&gt; 将不起作用：</target>
        </trans-unit>
        <trans-unit id="e2fcea022d94a9775aabc30c1a2c51d018156b80" translate="yes" xml:space="preserve">
          <source>Hundreds of companies, large and small, use Rust in production for a variety of tasks. Those tasks include command line tools, web services, DevOps tooling, embedded devices, audio and video analysis and transcoding, cryptocurrencies, bioinformatics, search engines, Internet of Things applications, machine learning, and even major parts of the Firefox web browser.</source>
          <target state="translated">成百上千的公司,无论大小,都在生产中使用Rust完成各种任务。这些任务包括命令行工具、网络服务、DevOps工具、嵌入式设备、音频和视频分析和转码、加密货币、生物信息学、搜索引擎、物联网应用、机器学习,甚至Firefox网络浏览器的主要部分。</target>
        </trans-unit>
        <trans-unit id="37906f8372f8c377be7b1e328309d3c4f609ea59" translate="yes" xml:space="preserve">
          <source>Hygiene</source>
          <target state="translated">Hygiene</target>
        </trans-unit>
        <trans-unit id="ad65c5b3b86039ac673217b5d774ea59d147e7b7" translate="yes" xml:space="preserve">
          <source>Hyperbolic cosine function.</source>
          <target state="translated">双曲余弦函数。</target>
        </trans-unit>
        <trans-unit id="c686c752760e59aa04f64bbe28ff2dbeca59fd00" translate="yes" xml:space="preserve">
          <source>Hyperbolic sine function.</source>
          <target state="translated">双曲正弦函数。</target>
        </trans-unit>
        <trans-unit id="78df70baad8c07fe855fe47101a5902c14b1e359" translate="yes" xml:space="preserve">
          <source>Hyperbolic tangent function.</source>
          <target state="translated">双曲正切函数。</target>
        </trans-unit>
        <trans-unit id="bdf6cba1852f21a59de6863b8e6d7784db0851c8" translate="yes" xml:space="preserve">
          <source>I call it my billion-dollar mistake. At that time, I was designing the first comprehensive type system for references in an object-oriented language. My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn&amp;rsquo;t resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.</source>
          <target state="translated">我称之为我的十亿美元错误。当时，我正在设计第一个全面的类型系统，以面向对象的语言进行引用。我的目标是确保所有对引用的使用都绝对安全，并由编译器自动执行检查。但是我无法抗拒引入空引用的诱惑，仅仅是因为它是如此易于实现。这导致了无数错误，漏洞和系统崩溃，在最近四十年中可能造成十亿美元的痛苦和破坏。</target>
        </trans-unit>
        <trans-unit id="e7c23cd87ff8917afb8c94f0de55718d338f0dac" translate="yes" xml:space="preserve">
          <source>IDE Integration Using the Rust Language Server</source>
          <target state="translated">使用Rust语言服务器的IDE集成</target>
        </trans-unit>
        <trans-unit id="0e3b1f1fb38a7fe314d2f472da7f442366e6c3f3" translate="yes" xml:space="preserve">
          <source>IDENTIFIER</source>
          <target state="translated">IDENTIFIER</target>
        </trans-unit>
        <trans-unit id="55b1203af6cad8ae52e0d0a37f140db7910d8eda" translate="yes" xml:space="preserve">
          <source>IDENTIFIER :</source>
          <target state="translated">IDENTIFIER :</target>
        </trans-unit>
        <trans-unit id="c0fcd90425d895f40b307f4c7f56f5df18b1668f" translate="yes" xml:space="preserve">
          <source>IDENTIFIER_OR_KEYWORD :</source>
          <target state="translated">IDENTIFIER_OR_KEYWORD :</target>
        </trans-unit>
        <trans-unit id="b8dae77b24288c011d2b9b755b9a1a42811917e3" translate="yes" xml:space="preserve">
          <source>IEEE-754 very precisely specifies the bit layout of floats.</source>
          <target state="translated">IEEE-754非常精确地规定了浮点数的位布局。</target>
        </trans-unit>
        <trans-unit id="1852814b8596efd4647ef533b868ea9c6f371594" translate="yes" xml:space="preserve">
          <source>IETF RFC 4291 section 2.4</source>
          <target state="translated">IETF RFC 4291第2.4节</target>
        </trans-unit>
        <trans-unit id="aa0c0f5169dc17cce987a2ba8ef3419dba45ba72" translate="yes" xml:space="preserve">
          <source>IETF RFC 4291 section 2.5.6</source>
          <target state="translated">IETF RFC 4291第2.5.6条</target>
        </trans-unit>
        <trans-unit id="bb6e7841dba2c83d7f4685d9f749f0a969927ab9" translate="yes" xml:space="preserve">
          <source>INFINITY</source>
          <target state="translated">INFINITY</target>
        </trans-unit>
        <trans-unit id="a1a3b8cc81502982ba95837302feb61e65dd8a3d" translate="yes" xml:space="preserve">
          <source>INNER_BLOCK_DOC :</source>
          <target state="translated">INNER_BLOCK_DOC 。</target>
        </trans-unit>
        <trans-unit id="53a0430947a0edbae0af7f9e49d8f2dfe4e9afb4" translate="yes" xml:space="preserve">
          <source>INNER_LINE_DOC :</source>
          <target state="translated">INNER_LINE_DOC :</target>
        </trans-unit>
        <trans-unit id="cfbd240cfc0633423b9847728303e0a704bcd5d5" translate="yes" xml:space="preserve">
          <source>INTEGER_LITERAL</source>
          <target state="translated">INTEGER_LITERAL</target>
        </trans-unit>
        <trans-unit id="3f9135bee30f70c629387b1f17caf9d0de0eb83e" translate="yes" xml:space="preserve">
          <source>INTEGER_LITERAL :</source>
          <target state="translated">INTEGER_LITERAL :</target>
        </trans-unit>
        <trans-unit id="6371ddd611a0269a5bb8329b8b5ad2906b65b001" translate="yes" xml:space="preserve">
          <source>INTEGER_SUFFIX :</source>
          <target state="translated">INTEGER_SUFFIX :</target>
        </trans-unit>
        <trans-unit id="11cbb1f84a9535024b6452829b5548dd25b90335" translate="yes" xml:space="preserve">
          <source>IPv4 addresses are defined as 32-bit integers in &lt;a href=&quot;https://tools.ietf.org/html/rfc791&quot;&gt;IETF RFC 791&lt;/a&gt;. They are usually represented as four octets.</source>
          <target state="translated">IPv4地址在&lt;a href=&quot;https://tools.ietf.org/html/rfc791&quot;&gt;IETF RFC 791&lt;/a&gt;中定义为32位整数。它们通常表示为四个八位位组。</target>
        </trans-unit>
        <trans-unit id="f61d67f908f166f992bd96ab7aae0433beeddddf" translate="yes" xml:space="preserve">
          <source>IPv4 socket addresses consist of an &lt;a href=&quot;struct.ipv4addr&quot;&gt;&lt;code&gt;IPv4&lt;/code&gt; address&lt;/a&gt; and a 16-bit port number, as stated in &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793&lt;/a&gt;.</source>
          <target state="translated">如&lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793中&lt;/a&gt;所述，IPv4套接字地址由一个&lt;a href=&quot;struct.ipv4addr&quot;&gt; &lt;code&gt;IPv4&lt;/code&gt; 地址&lt;/a&gt;和一个16位端口号组成。</target>
        </trans-unit>
        <trans-unit id="125cc8de0dff730e4520fc003986c19a1b8554df" translate="yes" xml:space="preserve">
          <source>IPv4 socket addresses consist of an &lt;a href=&quot;struct.ipv4addr&quot;&gt;IPv4 address&lt;/a&gt; and a 16-bit port number, as stated in &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793&lt;/a&gt;.</source>
          <target state="translated">如&lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793中&lt;/a&gt;所述，IPv4套接字地址由一个&lt;a href=&quot;struct.ipv4addr&quot;&gt;IPv4地址&lt;/a&gt;和一个16位端口号组成。</target>
        </trans-unit>
        <trans-unit id="0fb594a9f230f62a93a2d236d355fee291f5f0ed" translate="yes" xml:space="preserve">
          <source>IPv6 addresses are defined as 128-bit integers in &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt;. They are usually represented as eight 16-bit segments.</source>
          <target state="translated">IPv6地址在&lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt;中定义为128位整数。它们通常表示为八个16位段。</target>
        </trans-unit>
        <trans-unit id="9506a43966237e091295db561358da8326a23b09" translate="yes" xml:space="preserve">
          <source>IPv6 socket addresses consist of an &lt;a href=&quot;struct.ipv6addr&quot;&gt;&lt;code&gt;IPv6&lt;/code&gt; address&lt;/a&gt;, a 16-bit port number, as well as fields containing the traffic class, the flow label, and a scope identifier (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553, Section 3.3&lt;/a&gt; for more details).</source>
          <target state="translated">IPv6套接字地址由一个&lt;a href=&quot;struct.ipv6addr&quot;&gt; &lt;code&gt;IPv6&lt;/code&gt; 地址&lt;/a&gt;，一个16位端口号以及包含流量类别，流标签和作用域标识符的字段组成（有关更多详细信息&lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;，&lt;/a&gt;请参见IETF RFC 2553，第3.3节）。</target>
        </trans-unit>
        <trans-unit id="3a88c8ad7ac15b70173172e130a9df32e2c85f47" translate="yes" xml:space="preserve">
          <source>IPv6 socket addresses consist of an &lt;a href=&quot;struct.ipv6addr&quot;&gt;Ipv6 address&lt;/a&gt;, a 16-bit port number, as well as fields containing the traffic class, the flow label, and a scope identifier (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553, Section 3.3&lt;/a&gt; for more details).</source>
          <target state="translated">IPv6套接字地址包括一个&lt;a href=&quot;struct.ipv6addr&quot;&gt;Ipv6地址&lt;/a&gt;，一个16位端口号以及包含流量类别，流标签和作用域标识符的字段（有关更多详细信息&lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;，&lt;/a&gt;请参见IETF RFC 2553，第3.3节）。</target>
        </trans-unit>
        <trans-unit id="5e75cacea0fd3b6b14f0b4659c3bb43c233b1bc1" translate="yes" xml:space="preserve">
          <source>Identifier patterns</source>
          <target state="translated">识别符模式</target>
        </trans-unit>
        <trans-unit id="2871ae9886988ebe4584f71645f1cfa54c50fb26" translate="yes" xml:space="preserve">
          <source>Identifier patterns are irrefutable if the &lt;code&gt;@&lt;/code&gt; subpattern is irrefutable or the subpattern is not specified.</source>
          <target state="translated">如果 &lt;code&gt;@&lt;/code&gt; 子模式不可更改或未指定子模式，则标识符模式不可更改。</target>
        </trans-unit>
        <trans-unit id="b14c125598d88502f5133a3afc5b567be6c1a2d3" translate="yes" xml:space="preserve">
          <source>Identifier patterns bind the value they match to a variable. The identifier must be unique within the pattern. The variable will shadow any variables of the same name in scope. The scope of the new binding depends on the context of where the pattern is used (such as a &lt;code&gt;let&lt;/code&gt; binding or a &lt;code&gt;match&lt;/code&gt; arm).</source>
          <target state="translated">标识符模式将它们匹配的值绑定到变量。标识符在模式中必须唯一。该变量将在作用域中隐藏任何同名变量。新绑定的范围取决于使用模式的上下文（如 &lt;code&gt;let&lt;/code&gt; 绑定或 &lt;code&gt;match&lt;/code&gt; 臂）。</target>
        </trans-unit>
        <trans-unit id="649d2864df18704de32e689e69e63f2483e8b76e" translate="yes" xml:space="preserve">
          <source>Identifiers</source>
          <target state="translated">Identifiers</target>
        </trans-unit>
        <trans-unit id="a28f079910fa2727e597ae224c9f3f8cbc529307" translate="yes" xml:space="preserve">
          <source>Identify duplicate code.</source>
          <target state="translated">识别重复的代码。</target>
        </trans-unit>
        <trans-unit id="9f0d27a694b397b392e1c0d4d2916d104a364051" translate="yes" xml:space="preserve">
          <source>If &amp;epsilon; &amp;isin; LAST(&lt;code&gt;uu ...&lt;/code&gt;), then LAST(M) = LAST(&lt;code&gt;tt&lt;/code&gt;) &amp;cup; (LAST(&lt;code&gt;uu ...&lt;/code&gt;) \ { &amp;epsilon; }).</source>
          <target state="translated">如果&amp;epsilon;&amp;isin;LAST（ &lt;code&gt;uu ...&lt;/code&gt; ），则LAST（M）= LAST（ &lt;code&gt;tt&lt;/code&gt; ）&amp;cup;（LAST（ &lt;code&gt;uu ...&lt;/code&gt; ）\ {&amp;epsilon;}）。</target>
        </trans-unit>
        <trans-unit id="96acc5da5a6cbbd203437fa84771d338d67204aa" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../struct.vecdeque#method.make_contiguous&quot;&gt;&lt;code&gt;make_contiguous&lt;/code&gt;&lt;/a&gt; was previously called, all elements of the &lt;code&gt;VecDeque&lt;/code&gt; will be in the first slice and the second slice will be empty.</source>
          <target state="translated">如果&lt;a href=&quot;../struct.vecdeque#method.make_contiguous&quot;&gt; &lt;code&gt;make_contiguous&lt;/code&gt; &lt;/a&gt;以前调用时，所有的元素 &lt;code&gt;VecDeque&lt;/code&gt; 将在第一层和第二层是空的。</target>
        </trans-unit>
        <trans-unit id="ed811da5d2f26e42527abd7d7393051a81f9fad7" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;struct.path#method.extension&quot;&gt;&lt;code&gt;self.extension&lt;/code&gt;&lt;/a&gt; is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, the extension is added; otherwise it is replaced.</source>
          <target state="translated">如果&lt;a href=&quot;struct.path#method.extension&quot;&gt; &lt;code&gt;self.extension&lt;/code&gt; &lt;/a&gt;为&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，则添加扩展名；否则为false。否则将被替换。</target>
        </trans-unit>
        <trans-unit id="e801c0aa2cecddf4c1a1f7baf739c356c501f4d3" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;struct.path#method.file_name&quot;&gt;&lt;code&gt;self.file_name&lt;/code&gt;&lt;/a&gt; was &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, this is equivalent to pushing &lt;code&gt;file_name&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;struct.path#method.file_name&quot;&gt; &lt;code&gt;self.file_name&lt;/code&gt; &lt;/a&gt;为&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，则等效于推送 &lt;code&gt;file_name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="534c6252638c1abdb91099e943245185bc915d7e" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;struct.pathbuf#method.extension&quot;&gt;&lt;code&gt;self.extension&lt;/code&gt;&lt;/a&gt; is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, the extension is added; otherwise it is replaced.</source>
          <target state="translated">如果&lt;a href=&quot;struct.pathbuf#method.extension&quot;&gt; &lt;code&gt;self.extension&lt;/code&gt; &lt;/a&gt;为&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，则添加扩展名。否则将被替换。</target>
        </trans-unit>
        <trans-unit id="01a2757701a9695cb15304f9062c5f6fe543e1d0" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;struct.pathbuf#method.file_name&quot;&gt;&lt;code&gt;self.file_name&lt;/code&gt;&lt;/a&gt; was &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, this is equivalent to pushing &lt;code&gt;file_name&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;struct.pathbuf#method.file_name&quot;&gt; &lt;code&gt;self.file_name&lt;/code&gt; &lt;/a&gt;为&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，则等效于推送 &lt;code&gt;file_name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29376b60b0b5a1ec52b8a24373266c830da3ba88" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;struct.vecdeque#method.make_contiguous&quot;&gt;&lt;code&gt;make_contiguous&lt;/code&gt;&lt;/a&gt; was previously called, all elements of the &lt;code&gt;VecDeque&lt;/code&gt; will be in the first slice and the second slice will be empty.</source>
          <target state="translated">如果&lt;a href=&quot;struct.vecdeque#method.make_contiguous&quot;&gt; &lt;code&gt;make_contiguous&lt;/code&gt; &lt;/a&gt;以前调用时，所有的元素 &lt;code&gt;VecDeque&lt;/code&gt; 将在第一层和第二层是空的。</target>
        </trans-unit>
        <trans-unit id="4087b2407c0523ab27c22d69edd0438fe2e50815" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;'static&lt;/code&gt; is used for any lifetime bound then &lt;code&gt;'static&lt;/code&gt; is used.</source>
          <target state="translated">如果将 &lt;code&gt;'static&lt;/code&gt; 用于任何生命周期限制，则使用 &lt;code&gt;'static&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2299b8f75754da8b24aff81fd36ddb6f9ef90ec2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;..&lt;/code&gt; is not used, it is required to match all fields:</source>
          <target state="translated">如果不使用 &lt;code&gt;..&lt;/code&gt; ，则必须匹配所有字段：</target>
        </trans-unit>
        <trans-unit id="f3b5be9d19759c8147145d2b3c53249ad84a368f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;.create_new(true)&lt;/code&gt; is set, &lt;a href=&quot;#method.create&quot;&gt;&lt;code&gt;.create()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.truncate&quot;&gt;&lt;code&gt;.truncate()&lt;/code&gt;&lt;/a&gt; are ignored.</source>
          <target state="translated">如果设置了 &lt;code&gt;.create_new(true)&lt;/code&gt; ，&lt;a href=&quot;#method.create&quot;&gt; &lt;code&gt;.create()&lt;/code&gt; &lt;/a&gt;忽略.create（）和&lt;a href=&quot;#method.truncate&quot;&gt; &lt;code&gt;.truncate()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="29bc21e0c15798e73a6dbc2093728d2f6a268b72" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;.create_new(true)&lt;/code&gt; is set, &lt;a href=&quot;struct.openoptions#method.create&quot;&gt;&lt;code&gt;.create()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.openoptions#method.truncate&quot;&gt;&lt;code&gt;.truncate()&lt;/code&gt;&lt;/a&gt; are ignored.</source>
          <target state="translated">如果设置了 &lt;code&gt;.create_new(true)&lt;/code&gt; ，&lt;a href=&quot;struct.openoptions#method.create&quot;&gt; &lt;code&gt;.create()&lt;/code&gt; &lt;/a&gt;忽略.create（）和&lt;a href=&quot;struct.openoptions#method.truncate&quot;&gt; &lt;code&gt;.truncate()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2ad0cab5b7af8f6f0d802cf376de0871197cd2fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Complete&lt;/code&gt; is returned then the generator has completely finished with the value provided. It is invalid for the generator to be resumed again.</source>
          <target state="translated">如果返回 &lt;code&gt;Complete&lt;/code&gt; ，则生成器将使用提供的值完全完成。再次恢复发电机无效。</target>
        </trans-unit>
        <trans-unit id="ac903d4e63c4f5e9053aaefd66eff84df6124016" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ForeignTrait&lt;/code&gt; is a trait defined in some external crate &lt;code&gt;foo&lt;/code&gt;, then the following trait &lt;code&gt;impl&lt;/code&gt; is an error:</source>
          <target state="translated">如果 &lt;code&gt;ForeignTrait&lt;/code&gt; 是在某些外部包装箱 &lt;code&gt;foo&lt;/code&gt; 中定义的特征，则以下特征 &lt;code&gt;impl&lt;/code&gt; 是错误：</target>
        </trans-unit>
        <trans-unit id="c1fd05b3bcfcb4d8ea20c271d94557cb3d13d52d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hello, world!&lt;/code&gt; did print, congratulations! You&amp;rsquo;ve officially written a Rust program. That makes you a Rust programmer&amp;mdash;welcome!</source>
          <target state="translated">如果 &lt;code&gt;Hello, world!&lt;/code&gt; 确实打印了，恭喜！您已经正式编写了一个Rust程序。这使您成为Rust程序员-欢迎您！</target>
        </trans-unit>
        <trans-unit id="7eb14007d446b8ddd9ae89463ae1a1d31374e8ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;N&lt;/code&gt; is greater than the size of the slice, it will return no windows.</source>
          <target state="translated">如果 &lt;code&gt;N&lt;/code&gt; 大于切片的大小，它将不返回任何窗口。</target>
        </trans-unit>
        <trans-unit id="11ac605f741ebf773252ac24fa49e72ab712c9a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T: Drop&lt;/code&gt;, calling &lt;a href=&quot;../std/ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;&amp;lt;T as std::ops::Drop&amp;gt;::drop&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">如果 &lt;code&gt;T: Drop&lt;/code&gt; ，调用&lt;a href=&quot;../std/ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;&amp;lt;T as std::ops::Drop&amp;gt;::drop&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2c3c7b96cb91a4bbdb1b6896643ea9e9a3c22921" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt; (implying reflexivity of equality), two &lt;code&gt;Arc&lt;/code&gt;s that point to the same allocation are always equal.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 还实现 &lt;code&gt;Eq&lt;/code&gt; （暗示相等的自反性），则指向相同分配的两个 &lt;code&gt;Arc&lt;/code&gt; 始终相等。</target>
        </trans-unit>
        <trans-unit id="eeac29050d6596e7248fbdb56f4b4514db570609" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt; (implying reflexivity of equality), two &lt;code&gt;Arc&lt;/code&gt;s that point to the same value are never unequal.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 还实现 &lt;code&gt;Eq&lt;/code&gt; （暗示相等的自反性），则指向相同值的两个 &lt;code&gt;Arc&lt;/code&gt; 永远不会相等。</target>
        </trans-unit>
        <trans-unit id="37e2b122febd728f5d8f178462e020b9f40dc3b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt; (implying reflexivity of equality), two &lt;code&gt;Rc&lt;/code&gt;s that point to the same allocation are always equal.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 还实现 &lt;code&gt;Eq&lt;/code&gt; （暗示相等的自反性），则指向同一分配的两个 &lt;code&gt;Rc&lt;/code&gt; 始终相等。</target>
        </trans-unit>
        <trans-unit id="39a40f9d20e095dacb94b9b37bf7db5ad95d17e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt; (implying reflexivity of equality), two &lt;code&gt;Rc&lt;/code&gt;s that point to the same allocation are never unequal.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 还实现了 &lt;code&gt;Eq&lt;/code&gt; （暗示相等的自反性），则指向同一分配的两个 &lt;code&gt;Rc&lt;/code&gt; 永远不会相等。</target>
        </trans-unit>
        <trans-unit id="5b6043d2d9c915604d4623e46635d9a9a232a5d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt;, two &lt;code&gt;Arc&lt;/code&gt;s that point to the same value are always equal.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 还实现 &lt;code&gt;Eq&lt;/code&gt; ，则指向相同值的两个 &lt;code&gt;Arc&lt;/code&gt; 始终相等。</target>
        </trans-unit>
        <trans-unit id="ec82a111c6092884516e8540e107bb1534de81bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt;, two &lt;code&gt;Arc&lt;/code&gt;s that point to the same value are never unequal.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 还实现 &lt;code&gt;Eq&lt;/code&gt; ，则指向相同值的两个 &lt;code&gt;Arc&lt;/code&gt; 永远不会相等。</target>
        </trans-unit>
        <trans-unit id="21cc57c8697439642e0504b016521d59698b000c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt;, two &lt;code&gt;Rc&lt;/code&gt;s that point to the same value are always equal.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 还实现 &lt;code&gt;Eq&lt;/code&gt; ，则指向相同值的两个 &lt;code&gt;Rc&lt;/code&gt; 始终相等。</target>
        </trans-unit>
        <trans-unit id="79dd19ff096e35ccdc8e2994890606a0f2b80c5b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt;, two &lt;code&gt;Rc&lt;/code&gt;s that point to the same value are never unequal.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 还实现 &lt;code&gt;Eq&lt;/code&gt; ，则指向相同值的两个 &lt;code&gt;Rc&lt;/code&gt; 永远不会相等。</target>
        </trans-unit>
        <trans-unit id="f0097c8e2ff22a2b90e167d6c061fa3e59f58a62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; does not implement &lt;code&gt;Copy&lt;/code&gt;, use &lt;a href=&quot;#method.clone_from_slice&quot;&gt;&lt;code&gt;clone_from_slice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 没有实现 &lt;code&gt;Copy&lt;/code&gt; ，请使用&lt;a href=&quot;#method.clone_from_slice&quot;&gt; &lt;code&gt;clone_from_slice&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f5398ba641ada77d7640ea03a73f4e48d75300f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; does not implement &lt;code&gt;Copy&lt;/code&gt;, use &lt;a href=&quot;union.maybeuninit#method.write_slice_cloned&quot;&gt;&lt;code&gt;write_slice_cloned&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 不实现 &lt;code&gt;Copy&lt;/code&gt; ，则使用&lt;a href=&quot;union.maybeuninit#method.write_slice_cloned&quot;&gt; &lt;code&gt;write_slice_cloned&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="26c4dc3d013511006bc6b284a2d4db3c7148b968" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Copy&lt;/code&gt;, it can be more performant to use &lt;a href=&quot;#method.copy_from_slice&quot;&gt;&lt;code&gt;copy_from_slice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 实现了 &lt;code&gt;Copy&lt;/code&gt; ，则使用&lt;a href=&quot;#method.copy_from_slice&quot;&gt; &lt;code&gt;copy_from_slice&lt;/code&gt; &lt;/a&gt;可能会更有效。</target>
        </trans-unit>
        <trans-unit id="06930a496fb610735a31508bb990c32c7ac9ae36" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Copy&lt;/code&gt;, use &lt;a href=&quot;union.maybeuninit#method.write_slice&quot;&gt;&lt;code&gt;write_slice&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 实现 &lt;code&gt;Copy&lt;/code&gt; ，则使用&lt;a href=&quot;union.maybeuninit#method.write_slice&quot;&gt; &lt;code&gt;write_slice&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2aad32f156303fc5a2bc63ee3fa5dad5cc0ca6bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Deref&amp;lt;Target = U&amp;gt;&lt;/code&gt;, and &lt;code&gt;x&lt;/code&gt; is a value of type &lt;code&gt;T&lt;/code&gt;, then:</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 实现 &lt;code&gt;Deref&amp;lt;Target = U&amp;gt;&lt;/code&gt; ，并且 &lt;code&gt;x&lt;/code&gt; 是 &lt;code&gt;T&lt;/code&gt; 类型的值，则：</target>
        </trans-unit>
        <trans-unit id="95d72afe0884b2306850bd095670df15024528ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;DerefMut&amp;lt;Target = U&amp;gt;&lt;/code&gt;, and &lt;code&gt;x&lt;/code&gt; is a value of type &lt;code&gt;T&lt;/code&gt;, then:</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 实现 &lt;code&gt;DerefMut&amp;lt;Target = U&amp;gt;&lt;/code&gt; ，并且 &lt;code&gt;x&lt;/code&gt; 是 &lt;code&gt;T&lt;/code&gt; 类型的值，则：</target>
        </trans-unit>
        <trans-unit id="23971030fbeb1cad27f55d0399b6d51a892fe825" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Sized&lt;/code&gt;, this function is always safe to call.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 为 &lt;code&gt;Sized&lt;/code&gt; ，则始终可以安全地调用此函数。</target>
        </trans-unit>
        <trans-unit id="8b6c90a17aa05dcdf98932b5f27171dbd2de33f3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is FFI-safe, then so is &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是FFI安全的，则 &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 也是如此。</target>
        </trans-unit>
        <trans-unit id="49964ef73f44405d2ac7053108ae2569108b6abf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is not an enum, calling this function will not result in undefined behavior, but the return value is unspecified.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 不是一个枚举，则调用此函数不会导致未定义的行为，但返回值未指定。</target>
        </trans-unit>
        <trans-unit id="8dca1b3ef01a1ffebdb81541f8580fb6c5190017" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is not an enum, calling this function will not result in undefined behavior, but the return value is unspecified. Equally, if &lt;code&gt;T&lt;/code&gt; is an enum with more variants than &lt;code&gt;usize::MAX&lt;/code&gt; the return value is unspecified. Uninhabited variants will be counted.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 不是一个枚举，则调用此函数不会导致未定义的行为，但是返回值未指定。同样，如果 &lt;code&gt;T&lt;/code&gt; 是一个具有比 &lt;code&gt;usize::MAX&lt;/code&gt; 更多的变体的枚举，则未指定返回值。无人居住的变种将被计算在内。</target>
        </trans-unit>
        <trans-unit id="70442d0f7a75e13703c9f3f655e0ebf8ba235584" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Ti&lt;/code&gt; can be coerced to the current target type &lt;code&gt;T_t&lt;/code&gt;, then no change is made.</source>
          <target state="translated">如果可以将 &lt;code&gt;Ti&lt;/code&gt; 强制为当前目标类型 &lt;code&gt;T_t&lt;/code&gt; ，则不会进行任何更改。</target>
        </trans-unit>
        <trans-unit id="f81fb6d8ced60b0cd6b321f060ac68460468aa0c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;addr&lt;/code&gt; yields multiple addresses, &lt;code&gt;bind&lt;/code&gt; will be attempted with each of the addresses until one succeeds and returns the listener. If none of the addresses succeed in creating a listener, the error returned from the last attempt (the last address) is returned.</source>
          <target state="translated">如果 &lt;code&gt;addr&lt;/code&gt; 产生多个地址，则将尝试与每个地址 &lt;code&gt;bind&lt;/code&gt; ，直到一个成功并返回侦听器为止。如果没有一个地址成功创建侦听器，则返回从上次尝试（最后一个地址）返回的错误。</target>
        </trans-unit>
        <trans-unit id="7f3c01a32008b38d419c728226a54e01a7d962fe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;addr&lt;/code&gt; yields multiple addresses, &lt;code&gt;bind&lt;/code&gt; will be attempted with each of the addresses until one succeeds and returns the socket. If none of the addresses succeed in creating a socket, the error returned from the last attempt (the last address) is returned.</source>
          <target state="translated">如果 &lt;code&gt;addr&lt;/code&gt; 产生多个地址，则将尝试与每个地址 &lt;code&gt;bind&lt;/code&gt; ，直到一个成功并返回套接字为止。如果没有一个地址成功创建套接字，则返回上一次尝试返回的错误（最后一个地址）。</target>
        </trans-unit>
        <trans-unit id="0c53eddc64c1e675eb29f0974efda41f4b33efd1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;addr&lt;/code&gt; yields multiple addresses, &lt;code&gt;connect&lt;/code&gt; will be attempted with each of the addresses until a connection is successful. If none of the addresses result in a successful connection, the error returned from the last connection attempt (the last address) is returned.</source>
          <target state="translated">如果 &lt;code&gt;addr&lt;/code&gt; 产生多个地址， &lt;code&gt;connect&lt;/code&gt; 将尝试与每个地址，直到连接成功。如果没有一个地址导致连接成功，则返回从上次连接尝试（最后一个地址）返回的错误。</target>
        </trans-unit>
        <trans-unit id="07f5c20249e5fa3260da27a7df45155885f3dd08" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;addr&lt;/code&gt; yields multiple addresses, &lt;code&gt;connect&lt;/code&gt; will be attempted with each of the addresses until the underlying OS function returns no error. Note that usually, a successful &lt;code&gt;connect&lt;/code&gt; call does not specify that there is a remote server listening on the port, rather, such an error would only be detected after the first send. If the OS returns an error for each of the specified addresses, the error returned from the last connection attempt (the last address) is returned.</source>
          <target state="translated">如果 &lt;code&gt;addr&lt;/code&gt; 产生多个地址，则将尝试使用每个地址进行 &lt;code&gt;connect&lt;/code&gt; ，直到基础OS函数未返回错误为止。请注意，通常，成功的 &lt;code&gt;connect&lt;/code&gt; 调用不会指定在端口上侦听远程服务器，而是仅在首次发送后才检测到此错误。如果操作系统为每个指定的地址返回错误，则返回从上次连接尝试（最后一个地址）返回的错误。</target>
        </trans-unit>
        <trans-unit id="acfc45781f88c4761baec8897c0ca4cf03d5120d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is not a prefix of &lt;code&gt;self&lt;/code&gt; (i.e., &lt;a href=&quot;#method.starts_with&quot;&gt;&lt;code&gt;starts_with&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt;), returns &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;base&lt;/code&gt; 不是 &lt;code&gt;self&lt;/code&gt; 的前缀（即，&lt;a href=&quot;#method.starts_with&quot;&gt; &lt;code&gt;starts_with&lt;/code&gt; &lt;/a&gt;返回 &lt;code&gt;false&lt;/code&gt; ），则返回&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c33668a2d69ed6be4cc49feb7054f832229cf3a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is not a prefix of &lt;code&gt;self&lt;/code&gt; (i.e., &lt;a href=&quot;struct.path#method.starts_with&quot;&gt;&lt;code&gt;starts_with&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt;), returns &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;base&lt;/code&gt; 不是 &lt;code&gt;self&lt;/code&gt; 的前缀（即，&lt;a href=&quot;struct.path#method.starts_with&quot;&gt; &lt;code&gt;starts_with&lt;/code&gt; &lt;/a&gt;返回 &lt;code&gt;false&lt;/code&gt; ），则返回&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1b461fd46fdb1045defa6bb08692a4c2d8f4230a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; start with the bytes in &lt;code&gt;get&lt;/code&gt;, it means we&amp;rsquo;ve received some other request. We&amp;rsquo;ll add code to the &lt;code&gt;else&lt;/code&gt; block in a moment to respond to all other requests.</source>
          <target state="translated">如果 &lt;code&gt;buffer&lt;/code&gt; 并&lt;em&gt;没有&lt;/em&gt;与该字节的初始 &lt;code&gt;get&lt;/code&gt; ，这意味着我们已经收到了一些其他的要求。我们将在稍后将代码添加到 &lt;code&gt;else&lt;/code&gt; 块中，以响应所有其他请求。</target>
        </trans-unit>
        <trans-unit id="65de2dbca56069ac5ddb30aad7c8e3292f2e853a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; panics, the panic is propagated to the caller, and the cell remains uninitialized.</source>
          <target state="translated">如果 &lt;code&gt;f&lt;/code&gt; 恐慌，恐慌传播给调用者，而细胞仍然未初始化。</target>
        </trans-unit>
        <trans-unit id="f00643b3b6dd6ef6ea56050255f61c8e0b9bb9ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;func&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; for the next value of this iterator, consume and return it. Otherwise, return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;func&lt;/code&gt; 对于此迭代器的下一个值返回 &lt;code&gt;true&lt;/code&gt; ，请使用并返回它。否则，返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb805fab8234f3a9b02923cee55ae95cc32673cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;k&lt;/code&gt; is greater than &lt;code&gt;len()&lt;/code&gt;. Note that &lt;code&gt;k == len()&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; panic and is a no-op rotation.</source>
          <target state="translated">如果 &lt;code&gt;k&lt;/code&gt; 大于 &lt;code&gt;len()&lt;/code&gt; 。需要注意的是 &lt;code&gt;k == len()&lt;/code&gt; 并&lt;em&gt;没有&lt;/em&gt;恐慌，是一种无操作旋转。</target>
        </trans-unit>
        <trans-unit id="f9e7bcd447817a79430b03e0a66dfa67f1d0816a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len&lt;/code&gt; is greater than the &lt;code&gt;VecDeque&lt;/code&gt;'s current length, this has no effect.</source>
          <target state="translated">如果 &lt;code&gt;len&lt;/code&gt; 大于 &lt;code&gt;VecDeque&lt;/code&gt; 的当前长度，则无效。</target>
        </trans-unit>
        <trans-unit id="3d4f7e3b9010f5f85b09ea6a7879139a55bd516a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len&lt;/code&gt; is greater than the vector's current length, this has no effect.</source>
          <target state="translated">如果 &lt;code&gt;len&lt;/code&gt; 大于矢量的当前长度，则无效。</target>
        </trans-unit>
        <trans-unit id="1cf8419e86a3170a30c5b069909ed1f0302b608f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mid&lt;/code&gt; is greater than &lt;code&gt;len()&lt;/code&gt;. Note that &lt;code&gt;mid == len()&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; panic and is a no-op rotation.</source>
          <target state="translated">如果 &lt;code&gt;mid&lt;/code&gt; 大于 &lt;code&gt;len()&lt;/code&gt; 。需要注意的是 &lt;code&gt;mid == len()&lt;/code&gt; 并&lt;em&gt;没有&lt;/em&gt;恐慌，是一种无操作旋转。</target>
        </trans-unit>
        <trans-unit id="5a6e0913f28771cf69b8d16954b1cc061c4e770a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; substrings are returned, the last substring (the &lt;code&gt;n&lt;/code&gt;th substring) will contain the remainder of the string.</source>
          <target state="translated">如果返回 &lt;code&gt;n&lt;/code&gt; 个子字符串，则最后一个子字符串（第 &lt;code&gt;n&lt;/code&gt; 个子字符串）将包含字符串的其余部分。</target>
        </trans-unit>
        <trans-unit id="705ee37ce1f2981d5872c521c36f0e77f17b6dcb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is greater than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is extended by the difference, with each additional slot filled with &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;Default::default()&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;new_len&lt;/code&gt; is less than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is simply truncated.</source>
          <target state="translated">如果 &lt;code&gt;new_len&lt;/code&gt; 大于 &lt;code&gt;len&lt;/code&gt; ，则将 &lt;code&gt;Vec&lt;/code&gt; 扩展差值，每个其他插槽都填充&lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt; &lt;code&gt;Default::default()&lt;/code&gt; &lt;/a&gt;。如果 &lt;code&gt;new_len&lt;/code&gt; 小于 &lt;code&gt;len&lt;/code&gt; ，则仅将 &lt;code&gt;Vec&lt;/code&gt; 截断。</target>
        </trans-unit>
        <trans-unit id="ad28de2b804b7bf236f81edae0db607218d0ac6e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is greater than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is extended by the difference, with each additional slot filled with &lt;code&gt;value&lt;/code&gt;. If &lt;code&gt;new_len&lt;/code&gt; is less than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is simply truncated.</source>
          <target state="translated">如果 &lt;code&gt;new_len&lt;/code&gt; 大于 &lt;code&gt;len&lt;/code&gt; ，则 &lt;code&gt;Vec&lt;/code&gt; 扩展差值，每个附加插槽均填充 &lt;code&gt;value&lt;/code&gt; 。如果 &lt;code&gt;new_len&lt;/code&gt; 小于 &lt;code&gt;len&lt;/code&gt; ，则仅将 &lt;code&gt;Vec&lt;/code&gt; 截断。</target>
        </trans-unit>
        <trans-unit id="c6a8aec540c240a392d0120d56829bf27ca15fcc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is greater than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is extended by the difference, with each additional slot filled with the result of calling the closure &lt;code&gt;f&lt;/code&gt;. The return values from &lt;code&gt;f&lt;/code&gt; will end up in the &lt;code&gt;Vec&lt;/code&gt; in the order they have been generated.</source>
          <target state="translated">如果 &lt;code&gt;new_len&lt;/code&gt; 大于 &lt;code&gt;len&lt;/code&gt; ，则将 &lt;code&gt;Vec&lt;/code&gt; 扩展该差值，并在每个附加插槽中填充调用闭包 &lt;code&gt;f&lt;/code&gt; 的结果。 &lt;code&gt;f&lt;/code&gt; 的返回值将按照生成顺序返回到 &lt;code&gt;Vec&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="57261354a67401e0b42f57fdd95ec00fffeda84c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is greater than the string's current length, this has no effect.</source>
          <target state="translated">如果 &lt;code&gt;new_len&lt;/code&gt; 大于字符串的当前长度，则无效。</target>
        </trans-unit>
        <trans-unit id="8e6148a2ee667e899f4bb89c993862e7efe20971" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is less than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is simply truncated.</source>
          <target state="translated">如果 &lt;code&gt;new_len&lt;/code&gt; 小于 &lt;code&gt;len&lt;/code&gt; ，则仅将 &lt;code&gt;Vec&lt;/code&gt; 截断。</target>
        </trans-unit>
        <trans-unit id="abb4fe85675ce478754ece04841053fa5e5c6a3e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num&lt;/code&gt; had been &lt;code&gt;Some(10)&lt;/code&gt; instead, the match guard in the first arm would have been false because 10 is not less than 5. Rust would then go to the second arm, which would match because the second arm doesn&amp;rsquo;t have a match guard and therefore matches any &lt;code&gt;Some&lt;/code&gt; variant.</source>
          <target state="translated">如果 &lt;code&gt;num&lt;/code&gt; 已经 &lt;code&gt;Some(10)&lt;/code&gt; 代替，在第一臂比赛后卫本来是假的，因为10不小于5锈会然后进入第二臂，这将匹配，因为第二臂不有匹配卫队，因此匹配任何 &lt;code&gt;Some&lt;/code&gt; 变体。</target>
        </trans-unit>
        <trans-unit id="21505a97d020f2eacb0b6f0a96c2c88886ac3ebc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;original&lt;/code&gt; names a symbolic link, it is platform-specific whether the symbolic link is followed. On platforms where it's possible to not follow it, it is not followed, and the created hard link points to the symbolic link itself.</source>
          <target state="translated">如果 &lt;code&gt;original&lt;/code&gt; 名称为符号链接，则是否遵循该符号链接是特定于平台的。在可能不遵循它的平台上，它不会被遵循，并且创建的硬链接指向符号链接本身。</target>
        </trans-unit>
        <trans-unit id="b32b62b97ea86132915f7572c0fc7127777250a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;parse&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; able to turn the string into a number, it will return an &lt;code&gt;Err&lt;/code&gt; value that contains more information about the error. The &lt;code&gt;Err&lt;/code&gt; value does not match the &lt;code&gt;Ok(num)&lt;/code&gt; pattern in the first &lt;code&gt;match&lt;/code&gt; arm, but it does match the &lt;code&gt;Err(_)&lt;/code&gt; pattern in the second arm. The underscore, &lt;code&gt;_&lt;/code&gt;, is a catchall value; in this example, we&amp;rsquo;re saying we want to match all &lt;code&gt;Err&lt;/code&gt; values, no matter what information they have inside them. So the program will execute the second arm&amp;rsquo;s code, &lt;code&gt;continue&lt;/code&gt;, which tells the program to go to the next iteration of the &lt;code&gt;loop&lt;/code&gt; and ask for another guess. So, effectively, the program ignores all errors that &lt;code&gt;parse&lt;/code&gt; might encounter!</source>
          <target state="translated">如果 &lt;code&gt;parse&lt;/code&gt; 是&lt;em&gt;不是&lt;/em&gt;能够把字符串转换成一个数字，它会返回一个 &lt;code&gt;Err&lt;/code&gt; ，其中包含有关错误的详细信息的价值。的 &lt;code&gt;Err&lt;/code&gt; 值不匹配 &lt;code&gt;Ok(num)&lt;/code&gt; 在第一图案 &lt;code&gt;match&lt;/code&gt; 臂，但它确实匹配 &lt;code&gt;Err(_)&lt;/code&gt; 在所述第二臂的图案。下划线 &lt;code&gt;_&lt;/code&gt; 是一个通用值；在本例中，我们要匹配所有 &lt;code&gt;Err&lt;/code&gt; 值，无论它们内部包含什么信息。因此，程序将执行第二臂代码， &lt;code&gt;continue&lt;/code&gt; ，告诉程序进入 &lt;code&gt;loop&lt;/code&gt; 的下一个迭代并要求另一个猜测。因此，有效地，程序将忽略 &lt;code&gt;parse&lt;/code&gt; 可能遇到的所有错误！</target>
        </trans-unit>
        <trans-unit id="40e42a10c4724a12b9d742d659e990cc0a90590e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;parse&lt;/code&gt; is able to successfully turn the string into a number, it will return an &lt;code&gt;Ok&lt;/code&gt; value that contains the resulting number. That &lt;code&gt;Ok&lt;/code&gt; value will match the first arm&amp;rsquo;s pattern, and the &lt;code&gt;match&lt;/code&gt; expression will just return the &lt;code&gt;num&lt;/code&gt; value that &lt;code&gt;parse&lt;/code&gt; produced and put inside the &lt;code&gt;Ok&lt;/code&gt; value. That number will end up right where we want it in the new &lt;code&gt;guess&lt;/code&gt; variable we&amp;rsquo;re creating.</source>
          <target state="translated">如果 &lt;code&gt;parse&lt;/code&gt; 能够成功将字符串转换为数字，则它将返回包含结果数字的 &lt;code&gt;Ok&lt;/code&gt; 值。那 &lt;code&gt;Ok&lt;/code&gt; 值将匹配第一臂的模式，以及 &lt;code&gt;match&lt;/code&gt; 表达式将只返回 &lt;code&gt;num&lt;/code&gt; 该值 &lt;code&gt;parse&lt;/code&gt; 生产，并把里面 &lt;code&gt;Ok&lt;/code&gt; 价值。该数字将最终在我们要创建的新 &lt;code&gt;guess&lt;/code&gt; 变量中的所需位置结束。</target>
        </trans-unit>
        <trans-unit id="a78bf9200d69e40c9e7de71399af9b041b718f05" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is absolute, it replaces the current path.</source>
          <target state="translated">如果 &lt;code&gt;path&lt;/code&gt; 是绝对路径，它将替换当前路径。</target>
        </trans-unit>
        <trans-unit id="73e4e153f655353974f6e6f2c813b5b3915ef1cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pointer&lt;/code&gt; dereferences to an &lt;code&gt;Unpin&lt;/code&gt; type, &lt;code&gt;Pin::new&lt;/code&gt; should be used instead.</source>
          <target state="translated">如果 &lt;code&gt;pointer&lt;/code&gt; 取消引用了 &lt;code&gt;Unpin&lt;/code&gt; 类型，则应使用 &lt;code&gt;Pin::new&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac86606be8e832102840dbcc4086a1857a76012b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;program&lt;/code&gt; is not an absolute path, the &lt;code&gt;PATH&lt;/code&gt; will be searched in an OS-defined way.</source>
          <target state="translated">如果 &lt;code&gt;program&lt;/code&gt; 不是绝对路径，则将以OS定义的方式搜索 &lt;code&gt;PATH&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a98fb4db9993bb6b25528d614208eeeedcf64c3a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self &amp;lt;= other&lt;/code&gt;: &lt;code&gt;0:0&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;self &amp;lt;= other&lt;/code&gt; ： &lt;code&gt;0:0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="822bf36472f08b6c870c4a7eb729d5b79300c331" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self.value&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, the code calls the closure stored in &lt;code&gt;self.calculation&lt;/code&gt;, saves the result in &lt;code&gt;self.value&lt;/code&gt; for future use, and returns the value as well.</source>
          <target state="translated">如果 &lt;code&gt;self.value&lt;/code&gt; 为 &lt;code&gt;None&lt;/code&gt; ，则代码将调用存储在 &lt;code&gt;self.calculation&lt;/code&gt; 中的闭包，将结果保存在 &lt;code&gt;self.value&lt;/code&gt; 中以备将来使用，并返回该值。</target>
        </trans-unit>
        <trans-unit id="0f62f6b36639e7064e0402d98d3c38179c58dd42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; already meets the prescribed alignment, then returns &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;self&lt;/code&gt; 已经满足指定的对齐方式，则返回 &lt;code&gt;self&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d19aaaae1a7aca6f98e6ea7cfd2e6a369fd25fbf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is &lt;code&gt;Some(s)&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; is &lt;code&gt;Some(o)&lt;/code&gt;, this method returns &lt;code&gt;Some((s, o))&lt;/code&gt;. Otherwise, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;self&lt;/code&gt; 是 &lt;code&gt;Some(s)&lt;/code&gt; ， &lt;code&gt;other&lt;/code&gt; 是 &lt;code&gt;Some(o)&lt;/code&gt; ，则此方法返回 &lt;code&gt;Some((s, o))&lt;/code&gt; 。否则， &lt;code&gt;None&lt;/code&gt; 返回None。</target>
        </trans-unit>
        <trans-unit id="9687d508d768393d6014b090a450d643c5917f35" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is &lt;code&gt;Some(s)&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; is &lt;code&gt;Some(o)&lt;/code&gt;, this method returns &lt;code&gt;Some(f(s, o))&lt;/code&gt;. Otherwise, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;self&lt;/code&gt; 是 &lt;code&gt;Some(s)&lt;/code&gt; ， &lt;code&gt;other&lt;/code&gt; 是 &lt;code&gt;Some(o)&lt;/code&gt; ，则此方法返回 &lt;code&gt;Some(f(s, o))&lt;/code&gt; 。否则， &lt;code&gt;None&lt;/code&gt; 返回None。</target>
        </trans-unit>
        <trans-unit id="14fb52988b52fdaf20fd6eb41395b17915e1caaa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; was created using &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;Weak::new&lt;/code&gt;&lt;/a&gt;, this will return 0.</source>
          <target state="translated">如果使用&lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;Weak::new&lt;/code&gt; &lt;/a&gt;创建 &lt;code&gt;self&lt;/code&gt; ，则将返回0。</target>
        </trans-unit>
        <trans-unit id="ffe2ed689988d142674d1aa54b3aa925c7f0ceb1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; was created using &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;Weak::new&lt;/code&gt;&lt;/a&gt;, this will return 0. If not, the returned value is at least 1, since &lt;code&gt;self&lt;/code&gt; still points to the value.</source>
          <target state="translated">如果 &lt;code&gt;self&lt;/code&gt; 是使用&lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;Weak::new&lt;/code&gt; &lt;/a&gt;创建的，则返回0。否则，返回值至少为1，因为 &lt;code&gt;self&lt;/code&gt; 仍指向该值。</target>
        </trans-unit>
        <trans-unit id="f7cf04a558af40a8692e8d38e72f630ad0f921d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; was created using &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;Weak::new&lt;/code&gt;&lt;/a&gt;, this will return &lt;code&gt;None&lt;/code&gt;. If not, the returned value is at least 1, since &lt;code&gt;self&lt;/code&gt; still points to the value.</source>
          <target state="translated">如果使用&lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;Weak::new&lt;/code&gt; &lt;/a&gt;创建 &lt;code&gt;self&lt;/code&gt; ，则将返回 &lt;code&gt;None&lt;/code&gt; 。如果不是，则返回值至少为1，因为 &lt;code&gt;self&lt;/code&gt; 仍指向该值。</target>
        </trans-unit>
        <trans-unit id="3bc7bb1c65b4b00e05db4f8ca6614cdf9fe6dd50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; was created using &lt;a href=&quot;struct.weak#method.new&quot;&gt;&lt;code&gt;Weak::new&lt;/code&gt;&lt;/a&gt;, or if there are no remaining strong pointers, this will return 0.</source>
          <target state="translated">如果 &lt;code&gt;self&lt;/code&gt; 是使用&lt;a href=&quot;struct.weak#method.new&quot;&gt; &lt;code&gt;Weak::new&lt;/code&gt; &lt;/a&gt;创建的，或者如果没有剩余的强指针，则它将返回0。</target>
        </trans-unit>
        <trans-unit id="5cfa0b57fd172f30232192cc8919edcc309955f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; was created using &lt;a href=&quot;struct.weak#method.new&quot;&gt;&lt;code&gt;Weak::new&lt;/code&gt;&lt;/a&gt;, this will return 0.</source>
          <target state="translated">如果使用&lt;a href=&quot;struct.weak#method.new&quot;&gt; &lt;code&gt;Weak::new&lt;/code&gt; &lt;/a&gt;创建 &lt;code&gt;self&lt;/code&gt; ，则将返回0。</target>
        </trans-unit>
        <trans-unit id="8ab90cc43346ebf820e0570ac8953d279713fad0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;some_option_value&lt;/code&gt; was a &lt;code&gt;None&lt;/code&gt; value, it would fail to match the pattern &lt;code&gt;Some(x)&lt;/code&gt;, meaning the pattern is refutable. However, the &lt;code&gt;let&lt;/code&gt; statement can only accept an irrefutable pattern because there is nothing valid the code can do with a &lt;code&gt;None&lt;/code&gt; value. At compile time, Rust will complain that we&amp;rsquo;ve tried to use a refutable pattern where an irrefutable pattern is required:</source>
          <target state="translated">如果 &lt;code&gt;some_option_value&lt;/code&gt; 为 &lt;code&gt;None&lt;/code&gt; 值，它将无法匹配 &lt;code&gt;Some(x)&lt;/code&gt; 模式，这意味着该模式是可重复使用的。但是， &lt;code&gt;let&lt;/code&gt; 语句只能接受一个不可辩驳的模式，因为代码对 &lt;code&gt;None&lt;/code&gt; 值不能执行任何有效的操作。在编译时，Rust会抱怨我们试图在需要不可辩驳的模式的情况下使用可辩驳的模式：</target>
        </trans-unit>
        <trans-unit id="7912a0b36bd857714b86c8f65975fd42323403e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;src&lt;/code&gt; does not implement &lt;code&gt;Copy&lt;/code&gt;, use &lt;a href=&quot;#method.clone_from_slice&quot;&gt;&lt;code&gt;clone_from_slice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;src&lt;/code&gt; 没有实现 &lt;code&gt;Copy&lt;/code&gt; ，请使用&lt;a href=&quot;#method.clone_from_slice&quot;&gt; &lt;code&gt;clone_from_slice&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d89aaab24b69c1dc1835d5c53542bd5dee44e824" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;src&lt;/code&gt; implements &lt;code&gt;Copy&lt;/code&gt;, it can be more performant to use &lt;a href=&quot;#method.copy_from_slice&quot;&gt;&lt;code&gt;copy_from_slice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;src&lt;/code&gt; 实现了 &lt;code&gt;Copy&lt;/code&gt; ，则使用&lt;a href=&quot;#method.copy_from_slice&quot;&gt; &lt;code&gt;copy_from_slice&lt;/code&gt; &lt;/a&gt;可能会更有效。</target>
        </trans-unit>
        <trans-unit id="f2fb513c03fabfd0da48ed321e5c2ec7c086217d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;src&lt;/code&gt; names a symbolic link, it is platform-specific whether the symbolic link is followed. On platforms where it's possible to not follow it, it is not followed, and the created hard link points to the symbolic link itself.</source>
          <target state="translated">如果 &lt;code&gt;src&lt;/code&gt; 命名符号链接，则是否遵循符号链接是特定于平台的。在可能不遵循它的平台上，它不会被遵循，并且创建的硬链接指向符号链接本身。</target>
        </trans-unit>
        <trans-unit id="e2f26bdddcd85ded44fb8dcca9f30dea327428d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; had been a &lt;code&gt;None&lt;/code&gt; value instead of &lt;code&gt;Some(5)&lt;/code&gt;, the patterns in the first two arms wouldn&amp;rsquo;t have matched, so the value would have matched to the underscore. We didn&amp;rsquo;t introduce the &lt;code&gt;x&lt;/code&gt; variable in the pattern of the underscore arm, so the &lt;code&gt;x&lt;/code&gt; in the expression is still the outer &lt;code&gt;x&lt;/code&gt; that hasn&amp;rsquo;t been shadowed. In this hypothetical case, the &lt;code&gt;match&lt;/code&gt; would print &lt;code&gt;Default case, x = None&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是 &lt;code&gt;None&lt;/code&gt; 值而不是 &lt;code&gt;Some(5)&lt;/code&gt; ，则前两个臂中的模式将不匹配，因此该值将与下划线匹配。我们没有引进 &lt;code&gt;x&lt;/code&gt; 在下划线臂的图案可变的，所以 &lt;code&gt;x&lt;/code&gt; 中的表达仍然是外 &lt;code&gt;x&lt;/code&gt; 尚未阴影。在这种假设的情况下， &lt;code&gt;match&lt;/code&gt; 将显示 &lt;code&gt;Default case, x = None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18bf4b6aafae989a7516ceac94bb945e71eddb6d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is 1, 2, 3, 4, or 5, the first arm will match. This syntax is more convenient than using the &lt;code&gt;|&lt;/code&gt; operator to express the same idea; instead of &lt;code&gt;1...5&lt;/code&gt;, we would have to specify &lt;code&gt;1 | 2 | 3 | 4 | 5&lt;/code&gt; if we used &lt;code&gt;|&lt;/code&gt;. Specifying a range is much shorter, especially if we want to match, say, any number between 1 and 1,000!</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 为1、2、3、4或5，则第一个手臂会匹配。此语法比使用 &lt;code&gt;|&lt;/code&gt; 更方便。操作员表达相同的想法；而不是 &lt;code&gt;1...5&lt;/code&gt; ，我们必须指定 &lt;code&gt;1 | 2 | 3 | 4 | 5&lt;/code&gt; 如果我们使用过 &lt;code&gt;|&lt;/code&gt; 。指定范围要短得多，特别是如果我们要匹配（例如1到1,000之间的任何数字）！</target>
        </trans-unit>
        <trans-unit id="03b71537ced2e70a9ffd0edf12930fd86baf512b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is 1, 2, 3, 4, or 5, the first arm will match. This syntax is more convenient than using the &lt;code&gt;|&lt;/code&gt; operator to express the same idea; instead of &lt;code&gt;1..=5&lt;/code&gt;, we would have to specify &lt;code&gt;1 | 2 | 3 | 4 | 5&lt;/code&gt; if we used &lt;code&gt;|&lt;/code&gt;. Specifying a range is much shorter, especially if we want to match, say, any number between 1 and 1,000!</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 为1、2、3、4或5，则第一个手臂会匹配。此语法比使用 &lt;code&gt;|&lt;/code&gt; 更方便。运营商表达相同的想法；而不是 &lt;code&gt;1..=5&lt;/code&gt; ，我们必须指定 &lt;code&gt;1 | 2 | 3 | 4 | 5&lt;/code&gt; 如果我们使用过 &lt;code&gt;|&lt;/code&gt; 。指定范围要短得多，特别是如果我们要匹配（例如，介于1到1,000之间的任何数字）！</target>
        </trans-unit>
        <trans-unit id="0dff0302c86fb6267157aaf01cdfa14adc4d52ab" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;main.rs&lt;/em&gt; was your &amp;ldquo;Hello, world!&amp;rdquo; program, this line would print &lt;code&gt;Hello, world!&lt;/code&gt; to your terminal.</source>
          <target state="translated">如果&lt;em&gt;main.rs&lt;/em&gt;是您的&amp;ldquo;您好，世界！&amp;rdquo; 程序，此行将打印 &lt;code&gt;Hello, world!&lt;/code&gt; 到您的终端。</target>
        </trans-unit>
        <trans-unit id="cb2cf548505fabb01a736215a09d7eb4359e58a1" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;main.rs&lt;/em&gt; was your Hello, world! program, this line would print &lt;code&gt;Hello, world!&lt;/code&gt; to your terminal.</source>
          <target state="translated">如果&lt;em&gt;main.rs&lt;/em&gt;是您的世界，您好！程序，此行将打印 &lt;code&gt;Hello, world!&lt;/code&gt; 到您的终端。</target>
        </trans-unit>
        <trans-unit id="d9079a0efb2b14490cdc2479436c152fdb5fa1c2" translate="yes" xml:space="preserve">
          <source>If Rust code &lt;em&gt;does&lt;/em&gt; need to look into those strings, it can convert them to valid UTF-8, possibly lossily, by substituting invalid sequences with &lt;a href=&quot;../../../char/constant.replacement_character&quot;&gt;&lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt;&lt;/a&gt;, as is conventionally done in other Rust APIs that deal with string encodings.</source>
          <target state="translated">如果Rust代码&lt;em&gt;确实&lt;/em&gt;需要查看这些字符串，则可以使用&lt;a href=&quot;../../../char/constant.replacement_character&quot;&gt; &lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt; &lt;/a&gt;替换无效的序列，从而可能有损地将它们转换为有效的UTF-8，这与其他处理字符串编码的Rust API常规上一样。</target>
        </trans-unit>
        <trans-unit id="197312fbd3b9939e66c78499e206ee75ae2c0258" translate="yes" xml:space="preserve">
          <source>If Rust didn&amp;rsquo;t implement deref coercion, we would have to write the code in Listing 15-13 instead of the code in Listing 15-12 to call &lt;code&gt;hello&lt;/code&gt; with a value of type &lt;code&gt;&amp;amp;MyBox&amp;lt;String&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">如果Rust没有实现deref强制，我们将不得不编写清单15-13中的代码而不是清单15-12中的代码来调用值为 &lt;code&gt;&amp;amp;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; 类型的 &lt;code&gt;hello&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b87cf1a5022226b7cc21cca4d2b0d16ec46dac6" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Read&lt;/code&gt;er does not override the default &lt;code&gt;read_vectored&lt;/code&gt; implementation, code using it may want to avoid the method all together and coalesce writes into a single buffer for higher performance.</source>
          <target state="translated">如果 &lt;code&gt;Read&lt;/code&gt; 器未覆盖默认的 &lt;code&gt;read_vectored&lt;/code&gt; 实现，则使用该阅读器的代码可能希望完全避免使用该方法，并合并写入单个缓冲区以提高性能。</target>
        </trans-unit>
        <trans-unit id="56ff52226d48b491c91c2959c2741fe1a5e96b46" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Read&lt;/code&gt;er guarantees that it can work properly with uninitialized memory, it should call &lt;a href=&quot;struct.initializer#method.nop&quot;&gt;&lt;code&gt;Initializer::nop()&lt;/code&gt;&lt;/a&gt;. See the documentation for &lt;a href=&quot;struct.initializer&quot;&gt;&lt;code&gt;Initializer&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">如果 &lt;code&gt;Read&lt;/code&gt; 保证它可以与未初始化的内存一起正常工作，则应调用&lt;a href=&quot;struct.initializer#method.nop&quot;&gt; &lt;code&gt;Initializer::nop()&lt;/code&gt; &lt;/a&gt;。有关详细信息，请参见&lt;a href=&quot;struct.initializer&quot;&gt; &lt;code&gt;Initializer&lt;/code&gt; &lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="6f382719afa245fe22b4489961298212f0dd9d4d" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;String&lt;/code&gt; has enough capacity, adding elements to it will not re-allocate. For example, consider this program:</source>
          <target state="translated">如果 &lt;code&gt;String&lt;/code&gt; 具有足够的容量，则向其添加元素不会重新分配。例如，考虑以下程序：</target>
        </trans-unit>
        <trans-unit id="9fa35bc4f2bce6280405afd54339a1d6674f6de7" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Vacant(entry)&lt;/code&gt; is yielded, then the key &lt;em&gt;was not&lt;/em&gt; found. In this case the only valid operation is to &lt;code&gt;insert&lt;/code&gt; a value into the entry. When this is done, the vacant entry is consumed and converted into a mutable reference to the value that was inserted. This allows for further manipulation of the value beyond the lifetime of the search itself. This is useful if complex logic needs to be performed on the value regardless of whether the value was just inserted.</source>
          <target state="translated">如果 &lt;code&gt;Vacant(entry)&lt;/code&gt; 的产生，那么关键&lt;em&gt;是没有&lt;/em&gt;找到。在这种情况下，唯一有效的操作是在条目中 &lt;code&gt;insert&lt;/code&gt; 一个值。完成此操作后，将使用空条目并将其转换为对插入值的可变引用。这允许在搜索本身的生命周期之外对值进行进一步操作。如果无论是否刚刚插入值都需要对值执行复杂的逻辑，这将很有用。</target>
        </trans-unit>
        <trans-unit id="cda87c5518b5b9027cd10d7cda1ac0257185a449" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Vec&lt;/code&gt;&lt;em&gt;has&lt;/em&gt; allocated memory, then the memory it points to is on the heap (as defined by the allocator Rust is configured to use by default), and its pointer points to &lt;a href=&quot;struct.vec#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; initialized, contiguous elements in order (what you would see if you coerced it to a slice), followed by &lt;a href=&quot;struct.vec#method.capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt;&lt;code&gt;-&lt;/code&gt;&lt;a href=&quot;struct.vec#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; logically uninitialized, contiguous elements.</source>
          <target state="translated">如果 &lt;code&gt;Vec&lt;/code&gt; &lt;em&gt;已&lt;/em&gt;分配内存，则它指向的内存在堆上（由分配器Rust定义为默认使用），并且其指针按顺序指向&lt;a href=&quot;struct.vec#method.len&quot;&gt; &lt;code&gt;len&lt;/code&gt; &lt;/a&gt;初始化的连续元素（您将看到什么）你它强制转换为片），随后&lt;a href=&quot;struct.vec#method.capacity&quot;&gt; &lt;code&gt;capacity&lt;/code&gt; &lt;/a&gt; &lt;code&gt;-&lt;/code&gt; &lt;a href=&quot;struct.vec#method.len&quot;&gt; &lt;code&gt;len&lt;/code&gt; 个&lt;/a&gt;逻辑上未初始化的，连续的元件。</target>
        </trans-unit>
        <trans-unit id="dd0874f4a42c7a12d138cfaedb4f719f3af9227c" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Write&lt;/code&gt;er does not override the default &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;&lt;code&gt;write_vectored&lt;/code&gt;&lt;/a&gt; implementation, code using it may want to avoid the method all together and coalesce writes into a single buffer for higher performance.</source>
          <target state="translated">如果 &lt;code&gt;Write&lt;/code&gt; 呃不覆盖默认&lt;a href=&quot;trait.write#method.write_vectored&quot;&gt; &lt;code&gt;write_vectored&lt;/code&gt; &lt;/a&gt;实现，使用它的代码可能希望避免的方法一起并凝聚写入到一个缓冲区以提高性能。</target>
        </trans-unit>
        <trans-unit id="fee5eb71bb852650931c3ef81bdc83d836b949df" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Write&lt;/code&gt;r does not override the default &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;&lt;code&gt;write_vectored&lt;/code&gt;&lt;/a&gt; implementation, code using it may want to avoid the method all together and coalesce writes into a single buffer for higher performance.</source>
          <target state="translated">如果 &lt;code&gt;Write&lt;/code&gt; r没有覆盖默认的&lt;a href=&quot;trait.write#method.write_vectored&quot;&gt; &lt;code&gt;write_vectored&lt;/code&gt; &lt;/a&gt;实现，则使用它的代码可能希望完全避免使用该方法，并将写入合并到单个缓冲区中以提高性能。</target>
        </trans-unit>
        <trans-unit id="887bcf39fbff642c3b328187978b79bee02328d7" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;const&lt;/code&gt; item contains some type that does not implement this trait, then that type either (1.) does not implement &lt;code&gt;PartialEq&lt;/code&gt; (which means the constant will not provide that comparison method, which code generation assumes is available), or (2.) it implements &lt;em&gt;its own&lt;/em&gt; version of &lt;code&gt;PartialEq&lt;/code&gt; (which we assume does not conform to a structural-equality comparison).</source>
          <target state="translated">如果 &lt;code&gt;const&lt;/code&gt; 项包含某种不实现此特征的类型，则该类型要么（1.）不实现 &lt;code&gt;PartialEq&lt;/code&gt; （这意味着该常量将不提供该比较方法（代码生成假定可用）），要么（2。 ）会实现&lt;em&gt;自己&lt;/em&gt;的 &lt;code&gt;PartialEq&lt;/code&gt; 版本（我们认为&lt;em&gt;该&lt;/em&gt;版本不符合结构平等比较）。</target>
        </trans-unit>
        <trans-unit id="7756c2df57a46e8ffe41d330e37036f813dca05f" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;static&lt;/code&gt; item is declared with the &lt;a href=&quot;keyword.mut&quot;&gt;&lt;code&gt;mut&lt;/code&gt;&lt;/a&gt; keyword, then it is allowed to be modified by the program. However, accessing mutable &lt;code&gt;static&lt;/code&gt;s can cause undefined behavior in a number of ways, for example due to data races in a multithreaded context. As such, all accesses to mutable &lt;code&gt;static&lt;/code&gt;s require an &lt;a href=&quot;keyword.unsafe&quot;&gt;&lt;code&gt;unsafe&lt;/code&gt;&lt;/a&gt; block.</source>
          <target state="translated">如果使用&lt;a href=&quot;keyword.mut&quot;&gt; &lt;code&gt;mut&lt;/code&gt; &lt;/a&gt;关键字声明了 &lt;code&gt;static&lt;/code&gt; 项目，则程序允许对其进行修改。但是，访问可变的 &lt;code&gt;static&lt;/code&gt; 可能以多种方式导致未定义的行为，例如由于多线程上下文中的数据争用。因此，对可变 &lt;code&gt;static&lt;/code&gt; 的所有访问都需要一个&lt;a href=&quot;keyword.unsafe&quot;&gt; &lt;code&gt;unsafe&lt;/code&gt; &lt;/a&gt;块。</target>
        </trans-unit>
        <trans-unit id="8c0ce05d92f7c594a3a90bea8f233df56be2f1d6" translate="yes" xml:space="preserve">
          <source>If a &lt;em&gt;new&lt;/em&gt; file is created because it does not yet exist and &lt;code&gt;.create(true)&lt;/code&gt; or &lt;code&gt;.create_new(true)&lt;/code&gt; are specified, the new file is given the attributes declared with &lt;code&gt;.attributes()&lt;/code&gt;.</source>
          <target state="translated">如果由于尚不存在而创建了&lt;em&gt;新&lt;/em&gt;文件，并且 &lt;code&gt;.create(true)&lt;/code&gt; 或 &lt;code&gt;.create_new(true)&lt;/code&gt; ，则将为新文件提供使用 &lt;code&gt;.attributes()&lt;/code&gt; 声明的属性。</target>
        </trans-unit>
        <trans-unit id="16c8daede20373077d8ff711c94e64a0b59b67bb" translate="yes" xml:space="preserve">
          <source>If a binding pattern does not explicitly have &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;ref mut&lt;/code&gt;, or &lt;code&gt;mut&lt;/code&gt;, then it uses the &lt;em&gt;default binding mode&lt;/em&gt; to determine how the variable is bound. The default binding mode starts in &quot;move&quot; mode which uses move semantics. When matching a pattern, the compiler starts from the outside of the pattern and works inwards. Each time a reference is matched using a non-reference pattern, it will automatically dereference the value and update the default binding mode. References will set the default binding mode to &lt;code&gt;ref&lt;/code&gt;. Mutable references will set the mode to &lt;code&gt;ref mut&lt;/code&gt; unless the mode is already &lt;code&gt;ref&lt;/code&gt; in which case it remains &lt;code&gt;ref&lt;/code&gt;. If the automatically dereferenced value is still a reference, it is dereferenced and this process repeats.</source>
          <target state="translated">如果绑定模式没有显式具有 &lt;code&gt;ref&lt;/code&gt; ， &lt;code&gt;ref mut&lt;/code&gt; 或 &lt;code&gt;mut&lt;/code&gt; ，则它将使用&lt;em&gt;默认绑定模式&lt;/em&gt;来确定如何绑定变量。默认绑定模式从使用移动语义的&amp;ldquo;移动&amp;rdquo;模式开始。匹配模式时，编译器从模式外部开始并向内工作。每次使用非参考模式匹配参考时，它将自动取消参考值并更新默认绑定模式。引用会将默认绑定模式设置为 &lt;code&gt;ref&lt;/code&gt; 。可变引用会将模式设置为 &lt;code&gt;ref mut&lt;/code&gt; ,除非该模式已经是 &lt;code&gt;ref&lt;/code&gt; ,在这种情况下它将保持为 &lt;code&gt;ref&lt;/code&gt; 。如果自动取消引用的值仍然是引用，则将其取消引用，然后重复此过程。</target>
        </trans-unit>
        <trans-unit id="9479998c1b13e05b48032e25e7379b48f06d377a" translate="yes" xml:space="preserve">
          <source>If a borrow, dereference, field, or tuple indexing expression has an extended temporary scope then so does its operand. If an indexing expression has an extended temporary scope then the indexed expression also has an extended temporary scope.</source>
          <target state="translated">如果一个借用、派生、字段或元组索引表达式具有扩展的临时作用域,那么它的操作数也具有扩展的临时作用域。如果一个索引表达式有一个扩展的临时范围,那么索引表达式也有一个扩展的临时范围。</target>
        </trans-unit>
        <trans-unit id="7cce383f10beb57ed085cf340ccb835736dad8de" translate="yes" xml:space="preserve">
          <source>If a character does not have a lowercase equivalent, the same character will be returned back by the iterator.</source>
          <target state="translated">如果一个字符没有对应的小写字母,迭代器将返回相同的字符。</target>
        </trans-unit>
        <trans-unit id="ef2f005976fec5c6467e7bb3fc454eb0cb7f06ed" translate="yes" xml:space="preserve">
          <source>If a character does not have an uppercase equivalent, the same character will be returned back by the iterator.</source>
          <target state="translated">如果一个字符没有等价的大写字母,迭代器将返回相同的字符。</target>
        </trans-unit>
        <trans-unit id="d0d13af4b33d582574dec6432db47608e7a6fcac" translate="yes" xml:space="preserve">
          <source>If a clean shutdown is needed it is recommended to only call this function at a known point where there are no more destructors left to run.</source>
          <target state="translated">如果需要干净的关机,建议只在一个已知的点上调用这个函数,在这个点上已经没有更多的destructors可以运行。</target>
        </trans-unit>
        <trans-unit id="886a069f8113863955194282ceeeed5e034c8b28" translate="yes" xml:space="preserve">
          <source>If a collection type &lt;code&gt;C&lt;/code&gt; provides &lt;code&gt;iter()&lt;/code&gt;, it usually also implements &lt;code&gt;IntoIterator&lt;/code&gt; for &lt;code&gt;&amp;amp;C&lt;/code&gt;, with an implementation that just calls &lt;code&gt;iter()&lt;/code&gt;. Likewise, a collection &lt;code&gt;C&lt;/code&gt; that provides &lt;code&gt;iter_mut()&lt;/code&gt; generally implements &lt;code&gt;IntoIterator&lt;/code&gt; for &lt;code&gt;&amp;amp;mut C&lt;/code&gt; by delegating to &lt;code&gt;iter_mut()&lt;/code&gt;. This enables a convenient shorthand:</source>
          <target state="translated">如果集合类型 &lt;code&gt;C&lt;/code&gt; 提供 &lt;code&gt;iter()&lt;/code&gt; ，则它通常还为 &lt;code&gt;&amp;amp;C&lt;/code&gt; 实现 &lt;code&gt;IntoIterator&lt;/code&gt; ，并且该实现只调用 &lt;code&gt;iter()&lt;/code&gt; 。同样地，收集 &lt;code&gt;C&lt;/code&gt; 提供 &lt;code&gt;iter_mut()&lt;/code&gt; 一般实现 &lt;code&gt;IntoIterator&lt;/code&gt; 为 &lt;code&gt;&amp;amp;mut C&lt;/code&gt; 通过委托给 &lt;code&gt;iter_mut()&lt;/code&gt; 。这样可以方便快捷地实现以下目的：</target>
        </trans-unit>
        <trans-unit id="90545bafc06a46b5933ce2daa0969b441705a55d" translate="yes" xml:space="preserve">
          <source>If a const function is called outside a &lt;a href=&quot;../const_eval#const-context&quot;&gt;const context&lt;/a&gt;, it is indistinguishable from any other function. You can freely do anything with a const function that you can do with a regular function.</source>
          <target state="translated">如果在&lt;a href=&quot;../const_eval#const-context&quot;&gt;const上下文&lt;/a&gt;之外调用const函数，则它与任何其他函数都没有区别。您可以使用const函数自由地执行任何操作，就像使用常规函数一样。</target>
        </trans-unit>
        <trans-unit id="ba510c5879ea4cc171f31422ae04de034d50983c" translate="yes" xml:space="preserve">
          <source>If a destructor must be run manually, such as when implementing your own smart pointer, &lt;a href=&quot;../std/ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;std::ptr::drop_in_place&lt;/code&gt;&lt;/a&gt; can be used.</source>
          <target state="translated">如果析构函数必须手动运行（例如在实现自己的智能指针时），则可以使用&lt;a href=&quot;../std/ptr/fn.drop_in_place&quot;&gt; &lt;code&gt;std::ptr::drop_in_place&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aac87c21fcf6474549d65e03ca36c8ec59d12740" translate="yes" xml:space="preserve">
          <source>If a dynamic library or an executable that is being dynamically linked is being produced, then the compiler will attempt to reconcile the available dependencies in either the rlib or dylib format to create a final product.</source>
          <target state="translated">如果正在生成一个动态库或正在动态链接的可执行文件,那么编译器将尝试以rlib或dylib格式协调可用的依赖关系,以创建最终产品。</target>
        </trans-unit>
        <trans-unit id="5cf3f34eab79e2589477387981185c179654267a" translate="yes" xml:space="preserve">
          <source>If a file is opened with both read and append access, beware that after opening, and after every write, the position for reading may be set at the end of the file. So, before writing, save the current position (using &lt;a href=&quot;../io/trait.seek#tymethod.seek&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;../io/enum.seekfrom&quot;&gt;&lt;code&gt;SeekFrom&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../io/enum.seekfrom#variant.Current&quot;&gt;&lt;code&gt;Current&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(0))&lt;/code&gt;), and restore it before the next read.</source>
          <target state="translated">如果打开文件同时具有读取和附加访问权限，请注意在打开之后以及每次写入之后，都可以在文件末尾设置读取位置。因此，在写入之前，请保存当前位置（使用&lt;a href=&quot;../io/trait.seek#tymethod.seek&quot;&gt; &lt;code&gt;seek&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;../io/enum.seekfrom&quot;&gt; &lt;code&gt;SeekFrom&lt;/code&gt; &lt;/a&gt; &lt;code&gt;::&lt;/code&gt; &lt;a href=&quot;../io/enum.seekfrom#variant.Current&quot;&gt; &lt;code&gt;Current&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(0))&lt;/code&gt; ），并在下一次读取之前将其还原。</target>
        </trans-unit>
        <trans-unit id="b25b09268442abcdc7a1f9b2c36f533d27627828" translate="yes" xml:space="preserve">
          <source>If a file is opened with both read and append access, beware that after opening, and after every write, the position for reading may be set at the end of the file. So, before writing, save the current position (using &lt;a href=&quot;struct.file#method.seek&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;../io/enum.seekfrom&quot;&gt;&lt;code&gt;SeekFrom&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../io/enum.seekfrom#variant.Current&quot;&gt;&lt;code&gt;Current&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(0))&lt;/code&gt;), and restore it before the next read.</source>
          <target state="translated">如果打开文件同时具有读取和附加访问权限，请注意在打开之后以及每次写入之后，都可以在文件末尾设置读取位置。因此，在写入之前，请保存当前位置（使用&lt;a href=&quot;struct.file#method.seek&quot;&gt; &lt;code&gt;seek&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;../io/enum.seekfrom&quot;&gt; &lt;code&gt;SeekFrom&lt;/code&gt; &lt;/a&gt; &lt;code&gt;::&lt;/code&gt; &lt;a href=&quot;../io/enum.seekfrom#variant.Current&quot;&gt; &lt;code&gt;Current&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(0))&lt;/code&gt; ），并在下一次读取之前将其还原。</target>
        </trans-unit>
        <trans-unit id="7ae8e9b37b3fae0e90c2e27255beba504df5f00d" translate="yes" xml:space="preserve">
          <source>If a file is successfully opened with this option set it will truncate the file to 0 length if it already exists.</source>
          <target state="translated">如果一个文件在设置了这个选项的情况下被成功打开,如果文件已经存在,它将把文件截断为0长度。</target>
        </trans-unit>
        <trans-unit id="d0abbc43e6eb90b8c51d1b76b304256ddf0362aa" translate="yes" xml:space="preserve">
          <source>If a floating-point type can be &lt;em&gt;uniquely&lt;/em&gt; determined from the surrounding program context, the unsuffixed floating-point literal has that type.</source>
          <target state="translated">如果可以从周围的程序上下文中&lt;em&gt;唯一&lt;/em&gt;确定浮点类型，则未加后缀的浮点文字将具有该类型。</target>
        </trans-unit>
        <trans-unit id="04efa2d88cc29b968e806cf715e0ee4d0b695c80" translate="yes" xml:space="preserve">
          <source>If a language must have inheritance to be an object-oriented language, then Rust is not one. There is no way to define a struct that inherits the parent struct&amp;rsquo;s fields and method implementations. However, if you&amp;rsquo;re used to having inheritance in your programming toolbox, you can use other solutions in Rust, depending on your reason for reaching for inheritance in the first place.</source>
          <target state="translated">如果一种语言必须具有继承才能成为面向对象的语言，那么Rust就是其中之一。无法定义继承父结构的字段和方法实现的结构。但是，如果您习惯在编程工具箱中继承继承，则可以在Rust中使用其他解决方案，这取决于您首先要继承的原因。</target>
        </trans-unit>
        <trans-unit id="442a02939139d9c59cef162a2647bac06f4e1997" translate="yes" xml:space="preserve">
          <source>If a method call fails in a test, you&amp;rsquo;d want the whole test to fail, even if that method isn&amp;rsquo;t the functionality under test. Because &lt;code&gt;panic!&lt;/code&gt; is how a test is marked as a failure, calling &lt;code&gt;unwrap&lt;/code&gt; or &lt;code&gt;expect&lt;/code&gt; is exactly what should happen.</source>
          <target state="translated">如果某个方法调用在测试中失败，则您希望整个测试都失败，即使该方法不是受测试的功能。因为 &lt;code&gt;panic!&lt;/code&gt; 测试被标记为失败，调用 &lt;code&gt;unwrap&lt;/code&gt; 或 &lt;code&gt;expect&lt;/code&gt; 方式正是应该发生的情况。</target>
        </trans-unit>
        <trans-unit id="9d96dca6a8141f4e31a24310383d3fa9b46a981c" translate="yes" xml:space="preserve">
          <source>If a new file is created as part of a &lt;code&gt;File::open_opts&lt;/code&gt; call then this specified &lt;code&gt;mode&lt;/code&gt; will be used as the permission bits for the new file. If no &lt;code&gt;mode&lt;/code&gt; is set, the default of &lt;code&gt;0o666&lt;/code&gt; will be used. The operating system masks out bits with the systems &lt;code&gt;umask&lt;/code&gt;, to produce the final permissions.</source>
          <target state="translated">如果在 &lt;code&gt;File::open_opts&lt;/code&gt; 调用中创建了一个新文件，则此指定的 &lt;code&gt;mode&lt;/code&gt; 将用作新文件的权限位。如果未设置任何 &lt;code&gt;mode&lt;/code&gt; ，则将使用默认值 &lt;code&gt;0o666&lt;/code&gt; 。操作系统使用系统 &lt;code&gt;umask&lt;/code&gt; 屏蔽掉某些位，以产生最终权限。</target>
        </trans-unit>
        <trans-unit id="29baa09d14f6cfea0e9d752b0246ef9148a54b0e" translate="yes" xml:space="preserve">
          <source>If a new file is created as part of an &lt;code&gt;OpenOptions::open&lt;/code&gt; call then this specified &lt;code&gt;mode&lt;/code&gt; will be used as the permission bits for the new file. If no &lt;code&gt;mode&lt;/code&gt; is set, the default of &lt;code&gt;0o666&lt;/code&gt; will be used. The operating system masks out bits with the system's &lt;code&gt;umask&lt;/code&gt;, to produce the final permissions.</source>
          <target state="translated">如果在 &lt;code&gt;OpenOptions::open&lt;/code&gt; 调用中创建了一个新文件，则此指定的 &lt;code&gt;mode&lt;/code&gt; 将用作新文件的权限位。如果未设置任何 &lt;code&gt;mode&lt;/code&gt; ，则将使用默认值 &lt;code&gt;0o666&lt;/code&gt; 。操作系统使用系统的 &lt;code&gt;umask&lt;/code&gt; 屏蔽掉某些位，以产生最终权限。</target>
        </trans-unit>
        <trans-unit id="58a088dab2a65affaf69dc6a26afc8c56ddf7d23" translate="yes" xml:space="preserve">
          <source>If a nul byte is present and not the last element or no nul bytes is present, an error will be returned.</source>
          <target state="translated">如果存在一个nul字节而不是最后一个元素,或者没有nul字节,将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="edf29e89879313dc8e8b20d286c6fbf984a0c2ff" translate="yes" xml:space="preserve">
          <source>If a panic occurs in a named thread, the thread name will be printed in the panic message.</source>
          <target state="translated">如果在命名的线程中发生恐慌,线程名称将被打印在恐慌信息中。</target>
        </trans-unit>
        <trans-unit id="ae66f71517007a8faed7e8f14069d9743a8fc1d6" translate="yes" xml:space="preserve">
          <source>If a program contains arithmetic overflow, the programmer has made an error. In the following discussion, we maintain a distinction between arithmetic overflow and wrapping arithmetic. The first is erroneous, while the second is intentional.</source>
          <target state="translated">如果一个程序中包含算术溢出,则说明程序员犯了错误。在下面的讨论中,我们保持对算术溢出和封装算术的区分。第一种是错误的,而第二种是故意的。</target>
        </trans-unit>
        <trans-unit id="9ed92fa5e7088a3110b1cc9346594a14bbfacbbf" translate="yes" xml:space="preserve">
          <source>If a static item is declared with the &lt;code&gt;mut&lt;/code&gt; keyword, then it is allowed to be modified by the program. One of Rust's goals is to make concurrency bugs hard to run into, and this is obviously a very large source of race conditions or other bugs. For this reason, an &lt;code&gt;unsafe&lt;/code&gt; block is required when either reading or writing a mutable static variable. Care should be taken to ensure that modifications to a mutable static are safe with respect to other threads running in the same process.</source>
          <target state="translated">如果使用 &lt;code&gt;mut&lt;/code&gt; 关键字声明了静态项目，则程序允许对其进行修改。Rust的目标之一是使并发错误难以运行，这显然是竞争条件或其他错误的很大来源。因此，在读取或写入可变静态变量时需要一个 &lt;code&gt;unsafe&lt;/code&gt; 块。应注意确保对可变静态变量的修改相对于在同一进程中运行的其他线程是安全的。</target>
        </trans-unit>
        <trans-unit id="a1766ce77343ee3ad45def8d871224ac057e5320" translate="yes" xml:space="preserve">
          <source>If a static library is being produced, all upstream dependencies are required to be available in &lt;code&gt;rlib&lt;/code&gt; formats. This requirement stems from the reason that a dynamic library cannot be converted into a static format.</source>
          <target state="translated">如果要生成静态库，则所有上游依赖项都必须以 &lt;code&gt;rlib&lt;/code&gt; 格式可用。此要求源于无法将动态库转换为静态格式的原因。</target>
        </trans-unit>
        <trans-unit id="7bac0e8b6805f499b0c443af2ab6fa54c5aa649c" translate="yes" xml:space="preserve">
          <source>If a step is reached where there is more than one possible method, such as where generic methods or traits are considered the same, then it is a compiler error. These cases require a &lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;disambiguating function call syntax&lt;/a&gt; for method and function invocation.</source>
          <target state="translated">如果在一个步骤中有多个可能的方法（例如，将通用方法或特性视为相同），则会导致编译器错误。这些情况需要用于方法和函数调用的&lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;歧义函数调用语法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7f3fff7995601b35f7065fae1e640e2f2eeb6214" translate="yes" xml:space="preserve">
          <source>If a string contains multiple contiguous separators, you will end up with empty strings in the output:</source>
          <target state="translated">如果一个字符串包含多个连续的分隔符,你将在输出中以空字符串结束。</target>
        </trans-unit>
        <trans-unit id="4ab14222518e8fb43884627c81d597c32a8700e2" translate="yes" xml:space="preserve">
          <source>If a type &lt;code&gt;Item&lt;/code&gt; has an associated type &lt;code&gt;Assoc&lt;/code&gt; from a trait &lt;code&gt;Trait&lt;/code&gt;, then &lt;code&gt;&amp;lt;Item as Trait&amp;gt;::Assoc&lt;/code&gt; is a type that is an alias of the type specified in the associated type definition. Furthermore, if &lt;code&gt;Item&lt;/code&gt; is a type parameter, then &lt;code&gt;Item::Assoc&lt;/code&gt; can be used in type parameters.</source>
          <target state="translated">如果类型 &lt;code&gt;Item&lt;/code&gt; 具有来自特征 &lt;code&gt;Trait&lt;/code&gt; 的关联类型 &lt;code&gt;Assoc&lt;/code&gt; ，则 &lt;code&gt;&amp;lt;Item as Trait&amp;gt;::Assoc&lt;/code&gt; 是作为关联类型定义中指定的类型的别名的类型。此外，如果 &lt;code&gt;Item&lt;/code&gt; 是类型参数，则可以在类型参数中使用 &lt;code&gt;Item::Assoc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98ce79152874ad30a4163310f54c79462c6fb1d7" translate="yes" xml:space="preserve">
          <source>If a type contains a &lt;code&gt;PhantomPinned&lt;/code&gt;, it will not implement &lt;code&gt;Unpin&lt;/code&gt; by default.</source>
          <target state="translated">如果类型包含 &lt;code&gt;PhantomPinned&lt;/code&gt; ，则默认情况下不会实现 &lt;code&gt;Unpin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1433c5d355e130cd227bc3635eea7b7161e572f3" translate="yes" xml:space="preserve">
          <source>If all goes well, &lt;code&gt;Hello, world!&lt;/code&gt; should print to the terminal. Running &lt;code&gt;cargo build&lt;/code&gt; for the first time also causes Cargo to create a new file at the top level: &lt;em&gt;Cargo.lock&lt;/em&gt;. This file keeps track of the exact versions of dependencies in your project. This project doesn&amp;rsquo;t have dependencies, so the file is a bit sparse. You won&amp;rsquo;t ever need to change this file manually; Cargo manages its contents for you.</source>
          <target state="translated">如果一切顺利， &lt;code&gt;Hello, world!&lt;/code&gt; 应该打印到终端。首次运行 &lt;code&gt;cargo build&lt;/code&gt; 还会使Cargo在顶层创建一个新文件：&lt;em&gt;Cargo.lock&lt;/em&gt;。此文件跟踪项目中依赖项的确切版本。该项目没有依赖项，因此文件有点稀疏。您将不再需要手动更改此文件。货运为您管理其内容。</target>
        </trans-unit>
        <trans-unit id="5ace79993641886b01cac522412b514b142053ea" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;Alloc&lt;/code&gt; implementation chooses to return &lt;code&gt;Ok&lt;/code&gt; in this case (i.e., the pointer denotes a zero-sized inaccessible block) then that returned pointer must be considered &quot;currently allocated&quot;. On such an allocator, &lt;em&gt;all&lt;/em&gt; methods that take currently-allocated pointers as inputs must accept these zero-sized pointers, &lt;em&gt;without&lt;/em&gt; causing undefined behavior.</source>
          <target state="translated">如果在这种情况下 &lt;code&gt;Alloc&lt;/code&gt; 实现选择返回 &lt;code&gt;Ok&lt;/code&gt; （即，指针表示大小为零的不可访问块），则必须将返回的指针视为&amp;ldquo;当前分配&amp;rdquo;。在这样的分配器上，&lt;em&gt;所有&lt;/em&gt;将当前分配的指针作为输入的方法必须接受这些零大小的指针，&lt;em&gt;而不会&lt;/em&gt;引起未定义的行为。</target>
        </trans-unit>
        <trans-unit id="766a342529319b1e212f056deacbe904859bc648" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;Err(e)&lt;/code&gt; result is returned, the value &lt;code&gt;e&lt;/code&gt; will be &quot;wrapped&quot; in the return type of the enclosing scope (which must itself implement &lt;code&gt;Try&lt;/code&gt;). Specifically, the value &lt;code&gt;X::from_error(From::from(e))&lt;/code&gt; is returned, where &lt;code&gt;X&lt;/code&gt; is the return type of the enclosing function.</source>
          <target state="translated">如果返回 &lt;code&gt;Err(e)&lt;/code&gt; 结果，则值 &lt;code&gt;e&lt;/code&gt; 将&amp;ldquo;封装&amp;rdquo;在封闭范围的返回类型中（该范围本身必须实现 &lt;code&gt;Try&lt;/code&gt; ）。具体来说，将返回值 &lt;code&gt;X::from_error(From::from(e))&lt;/code&gt; ，其中 &lt;code&gt;X&lt;/code&gt; 是封闭函数的返回类型。</target>
        </trans-unit>
        <trans-unit id="d07fb8a7b5eba0666b8e8c43c71f4a92c4cff59d" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;Occupied(entry)&lt;/code&gt; is yielded, then the key &lt;em&gt;was&lt;/em&gt; found. In this case, the user has several options: they can &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;insert&lt;/code&gt; or &lt;code&gt;remove&lt;/code&gt; the value of the occupied entry. Additionally, they can convert the occupied entry into a mutable reference to its value, providing symmetry to the vacant &lt;code&gt;insert&lt;/code&gt; case.</source>
          <target state="translated">如果 &lt;code&gt;Occupied(entry)&lt;/code&gt; 的产生，那么关键&lt;em&gt;是&lt;/em&gt;找到。在这种情况下，用户有几个选项：他们可以 &lt;code&gt;get&lt;/code&gt; ， &lt;code&gt;insert&lt;/code&gt; 或 &lt;code&gt;remove&lt;/code&gt; 占用项的值。此外，他们可以将占用的条目转换为其值的可变引用，从而为空的 &lt;code&gt;insert&lt;/code&gt; 情况提供对称性。</target>
        </trans-unit>
        <trans-unit id="6496ceefd96285c8c2e145eb325b81df30982dd9" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;rlib&lt;/code&gt; file is being produced, then there are no restrictions on what format the upstream dependencies are available in. It is simply required that all upstream dependencies be available for reading metadata from.</source>
          <target state="translated">如果正在生成 &lt;code&gt;rlib&lt;/code&gt; 文件，则对上游依赖项可用的格式没有任何限制。仅要求所有上游依赖项都可用于读取元数据。</target>
        </trans-unit>
        <trans-unit id="c8e60161efc2f2d7cfcdc0d31414bc493321f65f" translate="yes" xml:space="preserve">
          <source>If an &lt;em&gt;existing&lt;/em&gt; file is opened with &lt;code&gt;.create(true).truncate(true)&lt;/code&gt;, its existing attributes are preserved and combined with the ones declared with &lt;code&gt;.attributes()&lt;/code&gt;.</source>
          <target state="translated">如果使用 &lt;code&gt;.create(true).truncate(true)&lt;/code&gt; 打开&lt;em&gt;现有&lt;/em&gt;文件，则将保留其现有属性，并将其与 &lt;code&gt;.attributes()&lt;/code&gt; 声明的属性合并。</target>
        </trans-unit>
        <trans-unit id="f270e545d597563858cae4afcff9e37ad4508d2c" translate="yes" xml:space="preserve">
          <source>If an I/O error is encountered then all bytes read so far will be present in &lt;code&gt;buf&lt;/code&gt; and its length will have been adjusted appropriately.</source>
          <target state="translated">如果遇到I / O错误，那么到目前为止，所有读取的字节都将存在于 &lt;code&gt;buf&lt;/code&gt; 中,并且其长度已经适当调整。</target>
        </trans-unit>
        <trans-unit id="ace1a7d9bf9ec54c3308257f201a03fece98ab35" translate="yes" xml:space="preserve">
          <source>If an executable is being produced and the &lt;code&gt;-C prefer-dynamic&lt;/code&gt; flag is not specified, then dependencies are first attempted to be found in the &lt;code&gt;rlib&lt;/code&gt; format. If some dependencies are not available in an rlib format, then dynamic linking is attempted (see below).</source>
          <target state="translated">如果正在生成可执行文件，但未指定 &lt;code&gt;-C prefer-dynamic&lt;/code&gt; &lt;code&gt;rlib&lt;/code&gt; -dynamic标志，则首先尝试以rlib格式找到依赖项。如果某些依赖项无法以rlib格式提供，则尝试进行动态链接（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="45d869ce1ba972ba36ff54baa74eb31c5112c34d" translate="yes" xml:space="preserve">
          <source>If an executor supports a cheaper way to wake without consuming the waker, it should override this method. By default, it clones the &lt;a href=&quot;../sync/struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; and calls &lt;code&gt;wake&lt;/code&gt; on the clone.</source>
          <target state="translated">如果执行程序支持一种更便宜的唤醒方式而不消耗唤醒程序，则它应该重写此方法。默认情况下，它将克隆&lt;a href=&quot;../sync/struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;并在克隆上调用 &lt;code&gt;wake&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="246eecf3cfe47d66c6f45d4fd6c99d8afcbf27a5" translate="yes" xml:space="preserve">
          <source>If an impl has a generic parameter with the &lt;code&gt;#[may_dangle]&lt;/code&gt; attribute, then that impl must be declared as an &lt;code&gt;unsafe impl&lt;/code&gt;.</source>
          <target state="translated">如果impl具有带有 &lt;code&gt;#[may_dangle]&lt;/code&gt; 属性的通用参数，则必须将该impl声明为 &lt;code&gt;unsafe impl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5e13abdce3cf8ba0eee5f3efa1352739a357002e" translate="yes" xml:space="preserve">
          <source>If an impl has a generic parameter with the &lt;code&gt;#[may_dangle]&lt;/code&gt; attribute, then that impl must be declared as an `unsafe impl.</source>
          <target state="translated">如果impl具有带有 &lt;code&gt;#[may_dangle]&lt;/code&gt; 属性的通用参数，则必须将该impl声明为&amp;ldquo;不安全的impl&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="11945bca4b49d81520c3d9de6a4cbb63f81941bb" translate="yes" xml:space="preserve">
          <source>If an integer type can be &lt;em&gt;uniquely&lt;/em&gt; determined from the surrounding program context, the unsuffixed integer literal has that type.</source>
          <target state="translated">如果可以从周围的程序上下文中&lt;em&gt;唯一&lt;/em&gt;确定整数类型，则未加后缀的整数文字将具有该类型。</target>
        </trans-unit>
        <trans-unit id="8e63390dbf4949c326a2cfedfadab303b53fa34d" translate="yes" xml:space="preserve">
          <source>If an intrinsic is supposed to be used from a &lt;code&gt;const fn&lt;/code&gt; with a &lt;code&gt;rustc_const_stable&lt;/code&gt; attribute, the intrinsic's attribute must be &lt;code&gt;rustc_const_stable&lt;/code&gt;, too. Such a change should not be done without T-lang consultation, because it bakes a feature into the language that cannot be replicated in user code without compiler support.</source>
          <target state="translated">如果应该从具有 &lt;code&gt;rustc_const_stable&lt;/code&gt; 属性的 &lt;code&gt;const fn&lt;/code&gt; 使用内在函数，则内在函数的属性也必须是 &lt;code&gt;rustc_const_stable&lt;/code&gt; 。如果没有T-lang咨询，则不应进行此类更改，因为它会将语言中的一项功能烘焙到没有编译器支持的情况下无法在用户代码中复制。</target>
        </trans-unit>
        <trans-unit id="39805e5d14d8cab59f3ec2eabeee9744560e1fb2" translate="yes" xml:space="preserve">
          <source>If an item is private, it may be accessed by the current module and its descendants.</source>
          <target state="translated">如果一个项目是私有的,那么它可以被当前模块和它的后代访问。</target>
        </trans-unit>
        <trans-unit id="727527b77e366466861dd6da815129cfeb9a9374" translate="yes" xml:space="preserve">
          <source>If an item is public, then it can be accessed externally from some module &lt;code&gt;m&lt;/code&gt; if you can access all the item's ancestor modules from &lt;code&gt;m&lt;/code&gt;. You can also potentially be able to name the item through re-exports. See below.</source>
          <target state="translated">如果某个项目是公共项目，那么如果您可以从 &lt;code&gt;m&lt;/code&gt; 访问该项目的所有祖先模块，则可以从某个模块 &lt;code&gt;m&lt;/code&gt; 对其进行外部访问。您还可能可以通过重新导出来命名商品。见下文。</target>
        </trans-unit>
        <trans-unit id="07080131ca18f6d9e5b13a9d88dcf93cd9dc48cd" translate="yes" xml:space="preserve">
          <source>If an item is public, then it can be accessed externally from some module &lt;code&gt;m&lt;/code&gt; if you can access all the item's parent modules from &lt;code&gt;m&lt;/code&gt;. You can also potentially be able to name the item through re-exports. See below.</source>
          <target state="translated">如果某个项目是公共项目，那么如果您可以从 &lt;code&gt;m&lt;/code&gt; 访问该项目的所有父模块，则可以从某个模块 &lt;code&gt;m&lt;/code&gt; 对其进行外部访问。您也可能可以通过重新导出来命名商品。见下文。</target>
        </trans-unit>
        <trans-unit id="d8864aae63bb3ba2da5620b13b08d971e5c9ff9b" translate="yes" xml:space="preserve">
          <source>If an iterator adapter panics, the iterator will be in an unspecified (but memory safe) state. This state is also not guaranteed to stay the same across versions of Rust, so you should avoid relying on the exact values returned by an iterator which panicked.</source>
          <target state="translated">如果迭代器适配器恐慌,迭代器将处于未指定(但内存安全)的状态。这个状态也不能保证在不同版本的Rust中保持不变,所以你应该避免依赖一个恐慌的迭代器返回的确切值。</target>
        </trans-unit>
        <trans-unit id="63585324ac753447dc7a54f44e90a00d790fca2c" translate="yes" xml:space="preserve">
          <source>If another thread is active, the lock can still become poisoned at any time. You should not trust a &lt;code&gt;false&lt;/code&gt; value for program correctness without additional synchronization.</source>
          <target state="translated">如果另一个线程处于活动状态，则锁定仍可能随时中毒。如果没有其他同步，则不应信任 &lt;code&gt;false&lt;/code&gt; 的程序正确性值。</target>
        </trans-unit>
        <trans-unit id="109588b2017fbb996d88327d5cc6be15dd8d4ba0" translate="yes" xml:space="preserve">
          <source>If another thread is active, the mutex can still become poisoned at any time. You should not trust a &lt;code&gt;false&lt;/code&gt; value for program correctness without additional synchronization.</source>
          <target state="translated">如果另一个线程处于活动状态，则互斥体仍然可以随时中毒。如果没有其他同步，则不应信任 &lt;code&gt;false&lt;/code&gt; 的程序正确性值。</target>
        </trans-unit>
        <trans-unit id="78ea9516ec8ea7a6ed978cbfe197fc08ae18d0c1" translate="yes" xml:space="preserve">
          <source>If another user of this mutex panicked while holding the mutex, then this call will return an error if the mutex would otherwise be acquired.</source>
          <target state="translated">如果这个mutex的另一个用户在持有mutex时惊慌失措,那么如果这个mutex在其他情况下会被获取,这个调用将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="e8114d3ac34051321d85f9acd763dd0f154fb356" translate="yes" xml:space="preserve">
          <source>If another user of this mutex panicked while holding the mutex, then this call will return an error instead.</source>
          <target state="translated">如果这个mutex的另一个用户在持有mutex的时候惊慌失措,那么这个调用将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="937c1840433dcebbb1b2c20629e7140489485c5e" translate="yes" xml:space="preserve">
          <source>If another user of this mutex panicked while holding the mutex, then this call will return an error once the mutex is acquired.</source>
          <target state="translated">如果这个mutex的另一个用户在持有mutex时惊慌失措,那么这个调用将在获取mutex后返回一个错误。</target>
        </trans-unit>
        <trans-unit id="94a8b260ae2fd91c20d30826f0ac290f20d42663" translate="yes" xml:space="preserve">
          <source>If another user of this mutex panicked while holding the mutex, then this call will return failure if the mutex would otherwise be acquired.</source>
          <target state="translated">如果这个mutex的另一个用户在持有mutex时惊慌失措,那么如果这个mutex在其他情况下会被获取,这个调用将返回失败。</target>
        </trans-unit>
        <trans-unit id="b8a9fd6020c6344c3b4ec789d5cdc75685b6c76f" translate="yes" xml:space="preserve">
          <source>If any directory in the path specified by &lt;code&gt;path&lt;/code&gt; does not already exist and it could not be created otherwise. The specific error conditions for when a directory is being created (after it is determined to not exist) are outlined by &lt;a href=&quot;fn.create_dir&quot;&gt;&lt;code&gt;fs::create_dir&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果path指定的 &lt;code&gt;path&lt;/code&gt; 中的任何目录都不存在，否则无法创建。&lt;a href=&quot;fn.create_dir&quot;&gt; &lt;code&gt;fs::create_dir&lt;/code&gt; &lt;/a&gt;概述了创建目录时（确定目录不存在后）的特定错误情况。</target>
        </trans-unit>
        <trans-unit id="8c9733a4a8648c17f076f404425858c19e3e7e60" translate="yes" xml:space="preserve">
          <source>If any of the following conditions are violated, the result is Undefined Behavior:</source>
          <target state="translated">如果违反了以下任何一个条件,结果就是未定义行为。</target>
        </trans-unit>
        <trans-unit id="abfc6e25813ef681d155e66f1a056df288816b17" translate="yes" xml:space="preserve">
          <source>If any other read error is encountered then this function immediately returns. Any bytes which have already been read will be appended to &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">如果遇到任何其他读取错误，则此函数将立即返回。任何已读取的字节都将附加到 &lt;code&gt;buf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc672b538a09f0d8b7133f8175c1bdde7ae9dbbb" translate="yes" xml:space="preserve">
          <source>If any other read error is encountered then this function immediately returns. The contents of &lt;code&gt;buf&lt;/code&gt; are unspecified in this case.</source>
          <target state="translated">如果遇到任何其他读取错误，则此函数将立即返回。在这种情况下，未指定 &lt;code&gt;buf&lt;/code&gt; 的内容。</target>
        </trans-unit>
        <trans-unit id="c60fca22bff6a233bf25c6e3874996a91aad3287" translate="yes" xml:space="preserve">
          <source>If both do not exist, &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/userenv/nf-userenv-getuserprofiledirectorya&quot;&gt;&lt;code&gt;GetUserProfileDirectory&lt;/code&gt;&lt;/a&gt; is used to return the path.</source>
          <target state="translated">如果两者都不存在，则使用&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/userenv/nf-userenv-getuserprofiledirectorya&quot;&gt; &lt;code&gt;GetUserProfileDirectory&lt;/code&gt; &lt;/a&gt;返回路径。</target>
        </trans-unit>
        <trans-unit id="ddacadc60603d21344f24b6aa894045e4936178f" translate="yes" xml:space="preserve">
          <source>If both do not exist, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/bb762280(v=vs.85).aspx&quot;&gt;&lt;code&gt;GetUserProfileDirectory&lt;/code&gt;&lt;/a&gt; is used to return the path.</source>
          <target state="translated">如果两者都不存在，则使用&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/bb762280(v=vs.85).aspx&quot;&gt; &lt;code&gt;GetUserProfileDirectory&lt;/code&gt; &lt;/a&gt;返回路径。</target>
        </trans-unit>
        <trans-unit id="7fce57c290d26a88e07f0e0c3e4758aa4174e90c" translate="yes" xml:space="preserve">
          <source>If compiled as a dylib, the resulting .so could then be linked to from a C library, and the function could be used as if it was from any other library.</source>
          <target state="translated">如果编译成dylib,那么产生的.so可以从C库中链接到,并且函数可以像其他库一样使用。</target>
        </trans-unit>
        <trans-unit id="e7b59b345b11e01a4787fa859ca6ad581aae3ad3" translate="yes" xml:space="preserve">
          <source>If either iterator returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; from the zipped iterator will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. If the first iterator returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;zip&lt;/code&gt; will short-circuit and &lt;code&gt;next&lt;/code&gt; will not be called on the second iterator.</source>
          <target state="translated">如果任一迭代器返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，则压缩的迭代器中的&lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;迭代器将返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;。如果第一个迭代器返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;，则 &lt;code&gt;zip&lt;/code&gt; 将短路，第二个迭代器将不调用 &lt;code&gt;next&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="84103f8a5cb4506a8862655c59a4b3682ff15678" translate="yes" xml:space="preserve">
          <source>If enabled, multicast packets will be looped back to the local socket. Note that this may not have any affect on IPv6 sockets.</source>
          <target state="translated">如果启用,多播数据包将被循环回本地套接字。注意,这对IPv6套接字可能没有任何影响。</target>
        </trans-unit>
        <trans-unit id="2ee8e080132486e2d1085bc2a52cb053b7cbc535" translate="yes" xml:space="preserve">
          <source>If enabled, multicast packets will be looped back to the local socket. Note that this may not have any effect on IPv6 sockets.</source>
          <target state="translated">如果启用,多播数据包将被循环回本地套接字。注意,这对IPv6套接字可能没有任何影响。</target>
        </trans-unit>
        <trans-unit id="0fb4d55515faf0167f284803093db70ba6bdf600" translate="yes" xml:space="preserve">
          <source>If encapsulation is a required aspect for a language to be considered object oriented, then Rust meets that requirement. The option to use &lt;code&gt;pub&lt;/code&gt; or not for different parts of code enables encapsulation of implementation details.</source>
          <target state="translated">如果封装是将语言视为面向对象的必需方面，则Rust满足该要求。选择是否对不同的代码部分使用 &lt;code&gt;pub&lt;/code&gt; 选项可以实现实现细节的封装。</target>
        </trans-unit>
        <trans-unit id="f88c3e80e7b4d154c2577f1e634c78e02c1c42d5" translate="yes" xml:space="preserve">
          <source>If every type inside a tuple implements one of the following traits, then a tuple itself also implements it.</source>
          <target state="translated">如果一个元组中的每个类型都实现了下面的一个特性,那么一个元组本身也实现了它。</target>
        </trans-unit>
        <trans-unit id="b8129e0ab4f408174bb11267c05f089405b50c77" translate="yes" xml:space="preserve">
          <source>If generic code merely needs to work for all types that can provide a reference to related type &lt;code&gt;T&lt;/code&gt;, it is often better to use &lt;a href=&quot;../convert/trait.asref&quot;&gt;&lt;code&gt;AsRef&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; as more types can safely implement it.</source>
          <target state="translated">如果通用代码仅需要为可以提供对相关类型 &lt;code&gt;T&lt;/code&gt; 的引用的所有类型工作，则通常最好使用&lt;a href=&quot;../convert/trait.asref&quot;&gt; &lt;code&gt;AsRef&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;因为更多类型可以安全地实现它。</target>
        </trans-unit>
        <trans-unit id="281313906bc5aa3fa055587412d6aee7b2eda929" translate="yes" xml:space="preserve">
          <source>If generic code merely needs to work for all types that can provide a reference to related type &lt;code&gt;T&lt;/code&gt;, it is often better to use [&lt;code&gt;AsRef&amp;lt;T&amp;gt;&lt;/code&gt;] as more types can safely implement it.</source>
          <target state="translated">如果通用代码仅需要为可以提供对相关类型 &lt;code&gt;T&lt;/code&gt; 的引用的所有类型工作，则通常最好使用[ &lt;code&gt;AsRef&amp;lt;T&amp;gt;&lt;/code&gt; ]，因为更多类型可以安全地实现它。</target>
        </trans-unit>
        <trans-unit id="57c986c219a8db1074aab149e63ad254d155df91" translate="yes" xml:space="preserve">
          <source>If given a position, returns a reference to the element at that position or &lt;code&gt;None&lt;/code&gt; if out of bounds.</source>
          <target state="translated">如果给定位置，则返回对该位置处元素的引用；如果超出范围，则返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0807d56f2c6d8607e36641ca45b2207a499de182" translate="yes" xml:space="preserve">
          <source>If given a range, returns the subslice corresponding to that range, or &lt;code&gt;None&lt;/code&gt; if out of bounds.</source>
          <target state="translated">如果给定范围，则返回与该范围相对应的子切片；如果超出范围，则返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dfe4ffb9dd92d20a6a4139ebde5c4444a81b450b" translate="yes" xml:space="preserve">
          <source>If interpreted as the number of actual hardware threads, it may undercount on Windows systems with more than 64 hardware threads. If interpreted as the available concurrency for that process, it may overcount on Windows systems when limited by a process wide affinity mask or job object limitations, and it may overcount on Linux systems when limited by a process wide affinity mask or affected by cgroups limits.</source>
          <target state="translated">如果解释为实际的硬件线程数,在硬件线程数超过64个的Windows系统上,它可能会少算。如果解释为该进程的可用并发量,那么在Windows系统中,如果受到进程范围内的亲和力掩码或作业对象限制,它可能会多算;在Linux系统中,如果受到进程范围内的亲和力掩码限制或受到cgroups限制,它可能会多算。</target>
        </trans-unit>
        <trans-unit id="c78c81075548342c17a3cb41f1d7c207afd16e82" translate="yes" xml:space="preserve">
          <source>If it does, add it to the list of values we&amp;rsquo;re returning.</source>
          <target state="translated">如果是这样，请将其添加到我们要返回的值列表中。</target>
        </trans-unit>
        <trans-unit id="6eb8349ae4604f3200e1b12d72175fa1292b930e" translate="yes" xml:space="preserve">
          <source>If it doesn&amp;rsquo;t, do nothing.</source>
          <target state="translated">如果没有，则什么也不做。</target>
        </trans-unit>
        <trans-unit id="77f0c7f8e7e8804708118486c51110234f91b9ca" translate="yes" xml:space="preserve">
          <source>If it is not possible to align the pointer, the implementation returns &lt;code&gt;usize::MAX&lt;/code&gt;. It is permissible for the implementation to &lt;em&gt;always&lt;/em&gt; return &lt;code&gt;usize::MAX&lt;/code&gt;. Only your algorithm's performance can depend on getting a usable offset here, not its correctness.</source>
          <target state="translated">如果无法对齐指针，则实现将返回 &lt;code&gt;usize::MAX&lt;/code&gt; 。允许实现&lt;em&gt;始终&lt;/em&gt;返回 &lt;code&gt;usize::MAX&lt;/code&gt; 。只有算法的性能可以取决于此处是否可获得可用的偏移量，而不取决于其正确性。</target>
        </trans-unit>
        <trans-unit id="9651a04b746a289895c0ff4ac7dbbd9c6c4bd1d9" translate="yes" xml:space="preserve">
          <source>If it is not possible to align the pointer, the implementation returns &lt;code&gt;usize::max_value()&lt;/code&gt;.</source>
          <target state="translated">如果无法对齐指针，则实现返回 &lt;code&gt;usize::max_value()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36c410707c8ca092b792e6807c748e0afad6b271" translate="yes" xml:space="preserve">
          <source>If it's possible, hand-monomorphize the code by writing the function for each possible type substitution. It's possible to use traits to do this cleanly, for example:</source>
          <target state="translated">如果可能的话,通过为每一个可能的类型替换写函数来手工变形代码。可以使用特质来干净利落地完成这项工作,例如:。</target>
        </trans-unit>
        <trans-unit id="8fae40cdb468d4e5d03de42a624dd09250a5c8c7" translate="yes" xml:space="preserve">
          <source>If less than &lt;code&gt;n&lt;/code&gt; elements are available, &lt;code&gt;take&lt;/code&gt; will limit itself to the size of the underlying iterator:</source>
          <target state="translated">如果少于 &lt;code&gt;n&lt;/code&gt; 个元素可用，则 &lt;code&gt;take&lt;/code&gt; 将自身限制为基础迭代器的大小：</target>
        </trans-unit>
        <trans-unit id="c0e5a61966add37320ef9414096df3e05db3ac2b" translate="yes" xml:space="preserve">
          <source>If more code were added between the construction of &lt;code&gt;String&lt;/code&gt; and the invocation of &lt;code&gt;mem::forget()&lt;/code&gt;, a panic within it would cause a double free because the same memory is handled by both &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">如果在 &lt;code&gt;String&lt;/code&gt; 的构造和 &lt;code&gt;mem::forget()&lt;/code&gt; 的调用之间添加了更多代码，则内部恐慌将导致两次释放，因为 &lt;code&gt;v&lt;/code&gt; 和 &lt;code&gt;s&lt;/code&gt; 都处理相同的内存。</target>
        </trans-unit>
        <trans-unit id="9fbc54548355fd2192a8ba719e27f659cd206c5b" translate="yes" xml:space="preserve">
          <source>If multiple patterns are used in the same arm for a &lt;code&gt;match&lt;/code&gt; expression, then an unspecified pattern will be used to determine the drop order.</source>
          <target state="translated">如果在同一分支中为 &lt;code&gt;match&lt;/code&gt; 表达式使用了多个模式，则将使用未指定的模式来确定放置顺序。</target>
        </trans-unit>
        <trans-unit id="8c4391f80fe19e3beba14af1b68f867a8deafde6" translate="yes" xml:space="preserve">
          <source>If necessary, you can circumvent this check using custom target specifications.</source>
          <target state="translated">如果有必要,你可以使用自定义目标规格来规避这个检查。</target>
        </trans-unit>
        <trans-unit id="7c94321a1ed561693d40d9b66f1f46aeaaecd3c4" translate="yes" xml:space="preserve">
          <source>If neither of the above env vars are set, then &lt;code&gt;Backtrace::capture&lt;/code&gt; will be disabled.</source>
          <target state="translated">如果以上两个环境变量均未设置，则 &lt;code&gt;Backtrace::capture&lt;/code&gt; 将被禁用。</target>
        </trans-unit>
        <trans-unit id="b8e62341b0bd62d9e8cebd223a1dae7b6e2b460b" translate="yes" xml:space="preserve">
          <source>If neither of those rules apply, then the bounds on the trait are used:</source>
          <target state="translated">如果这两条规则都不适用,那么就使用性状的界限。</target>
        </trans-unit>
        <trans-unit id="f04e4c83d03462bae231d396fbd6bc133f04e581" translate="yes" xml:space="preserve">
          <source>If no custom hook is registered, the default hook will be returned.</source>
          <target state="translated">如果没有注册自定义钩子,将返回默认钩子。</target>
        </trans-unit>
        <trans-unit id="3ea6cae08b251d423319bdb503b4761220cd47ba" translate="yes" xml:space="preserve">
          <source>If no explicit implementation or negative implementation is written out for an auto trait for a given type, then the compiler implements it automatically according to the following rules:</source>
          <target state="translated">如果没有为给定类型的自动特征写出显式实现或否定式实现,那么编译器就会根据以下规则自动实现它。</target>
        </trans-unit>
        <trans-unit id="5d4b1cf8f992f711595955dfbd04de1463c70def" translate="yes" xml:space="preserve">
          <source>If no strong pointers remain, this will return zero.</source>
          <target state="translated">如果没有强指针残留,将返回零。</target>
        </trans-unit>
        <trans-unit id="8f530d6d6508b49e7ed96395312e1b09be42668f" translate="yes" xml:space="preserve">
          <source>If not, just run closures one at a time:</source>
          <target state="translated">如果没有,就一次一次地运行关闭。</target>
        </trans-unit>
        <trans-unit id="6f7fa92522a250a6d3be880c3209e2e00d855d4b" translate="yes" xml:space="preserve">
          <source>If not, try to compute a mutual supertype of &lt;code&gt;T_t&lt;/code&gt; and &lt;code&gt;Ti&lt;/code&gt;, which will become the new target type.</source>
          <target state="translated">如果不是，请尝试计算 &lt;code&gt;T_t&lt;/code&gt; 和 &lt;code&gt;Ti&lt;/code&gt; 的互超类型，它们将成为新的目标类型。</target>
        </trans-unit>
        <trans-unit id="902fe9b3f2f74127ecf6007749394b452c7a24b7" translate="yes" xml:space="preserve">
          <source>If one of the arguments is NaN, then the other argument is returned.</source>
          <target state="translated">如果其中一个参数是NaN,则返回另一个参数。</target>
        </trans-unit>
        <trans-unit id="fd66bf5358b1619dbf93c578d3488d32d0c0fca1" translate="yes" xml:space="preserve">
          <source>If one sequence is a prefix of another, the shorter sequence is lexicographically less than the other.</source>
          <target state="translated">如果一个序列是另一个序列的前缀,则较短的序列在词法上比另一个序列少。</target>
        </trans-unit>
        <trans-unit id="7ae9dd3ada03870a6668bdcb11d4ca3933501dde" translate="yes" xml:space="preserve">
          <source>If only some methods aren't object-safe, you can add a &lt;code&gt;where Self: Sized&lt;/code&gt; bound on them to mark them as explicitly unavailable to trait objects. The functionality will still be available to all other implementers, including &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt; which is itself sized (assuming you &lt;code&gt;impl Trait for Box&amp;lt;Trait&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">如果只有某些方法不是对象安全的，则可以在它们上添加一个 &lt;code&gt;where Self: Sized&lt;/code&gt; ，以将其标记为特征对象明确不可用。该功能仍将对所有其他实现者可用，包括 &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt; 本身的大小（假定您 &lt;code&gt;impl Trait for Box&amp;lt;Trait&amp;gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="df3400bc60a85af8ff3ace18e07d7c2d1864912a" translate="yes" xml:space="preserve">
          <source>If our project is a binary crate that only contains a &lt;em&gt;src/main.rs&lt;/em&gt; file and doesn&amp;rsquo;t have a &lt;em&gt;src/lib.rs&lt;/em&gt; file, we can&amp;rsquo;t create integration tests in the &lt;em&gt;tests&lt;/em&gt; directory and bring functions defined in the &lt;em&gt;src/main.rs&lt;/em&gt; file into scope with a &lt;code&gt;use&lt;/code&gt; statement. Only library crates expose functions that other crates can use; binary crates are meant to be run on their own.</source>
          <target state="translated">如果我们的项目是一个二进制箱只包含一个&lt;em&gt;SRC / main.rs&lt;/em&gt;文件，不具有&lt;em&gt;的src / lib.rs&lt;/em&gt;文件，我们不能建立在集成测试&lt;em&gt;的测试&lt;/em&gt;目录，并在规定带来功能&lt;em&gt;的src / main .rs&lt;/em&gt;通过 &lt;code&gt;use&lt;/code&gt; 语句进入作用域。只有库文件箱才能显示其他文件箱可以使用的功能；二进制板条箱应单独运行。</target>
        </trans-unit>
        <trans-unit id="e6324fa8ddd04d1618f1aebd83b3f76a15a2cd28" translate="yes" xml:space="preserve">
          <source>If our requirements change, and we also need to be able to traverse from &lt;code&gt;Owner&lt;/code&gt; to &lt;code&gt;Gadget&lt;/code&gt;, we will run into problems. An &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointer from &lt;code&gt;Owner&lt;/code&gt; to &lt;code&gt;Gadget&lt;/code&gt; introduces a cycle between the values. This means that their reference counts can never reach 0, and the values will remain allocated forever: a memory leak. In order to get around this, we can use &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers.</source>
          <target state="translated">如果我们的要求发生变化，并且我们还需要能够从 &lt;code&gt;Owner&lt;/code&gt; 到 &lt;code&gt;Gadget&lt;/code&gt; 遍历，我们将遇到问题。从 &lt;code&gt;Owner&lt;/code&gt; 到 &lt;code&gt;Gadget&lt;/code&gt; 的&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;指针会在值之间引入一个循环。这意味着它们的引用计数永远不会达到0，并且这些值将永远分配：内存泄漏。为了解决这个问题，我们可以使用&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;指针。</target>
        </trans-unit>
        <trans-unit id="921a182084c11bc25c06cdc6fb33da8acc45c85b" translate="yes" xml:space="preserve">
          <source>If our requirements change, and we also need to be able to traverse from &lt;code&gt;Owner&lt;/code&gt; to &lt;code&gt;Gadget&lt;/code&gt;, we will run into problems. An &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointer from &lt;code&gt;Owner&lt;/code&gt; to &lt;code&gt;Gadget&lt;/code&gt; introduces a cycle. This means that their reference counts can never reach 0, and the allocation will never be destroyed: a memory leak. In order to get around this, we can use &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers.</source>
          <target state="translated">如果我们的要求发生变化，并且我们还需要能够从 &lt;code&gt;Owner&lt;/code&gt; 到 &lt;code&gt;Gadget&lt;/code&gt; 遍历，我们将遇到问题。从 &lt;code&gt;Owner&lt;/code&gt; 到 &lt;code&gt;Gadget&lt;/code&gt; 的&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;指针引入了一个循环。这意味着它们的引用计数永远不会达到0，并且分配也永远不会被破坏：内存泄漏。为了解决这个问题，我们可以使用&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;指针。</target>
        </trans-unit>
        <trans-unit id="9b786199b10d931840d1086948f15c121bb97b51" translate="yes" xml:space="preserve">
          <source>If parsing succeeds, return the value inside &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;, otherwise when the string is ill-formatted return an error specific to the inside &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;. The error type is specific to implementation of the trait.</source>
          <target state="translated">如果解析成功，则返回&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt;内部的值，否则，当字符串格式错误时，返回内部&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;特定的错误。错误类型特定于特征的实现。</target>
        </trans-unit>
        <trans-unit id="1260ea15bf2742af82873380ef5cdc057469a6e9" translate="yes" xml:space="preserve">
          <source>If set, this option disables the Nagle algorithm. This means that segments are always sent as soon as possible, even if there is only a small amount of data. When not set, data is buffered until there is a sufficient amount to send out, thereby avoiding the frequent sending of small packets.</source>
          <target state="translated">如果设置,该选项将禁用Nagle算法。这意味着,即使只有少量数据,也总是尽快发送段。如果不设置,则会对数据进行缓冲,直到有足够的数据量发送出去,从而避免频繁发送小数据包。</target>
        </trans-unit>
        <trans-unit id="0161295a4165e472097a556bd12e3cb8153ce739" translate="yes" xml:space="preserve">
          <source>If several elements are equally maximum, the last element is returned. If the iterator is empty, &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">如果几个元素相等地最大，则返回最后一个元素。如果迭代器为空，则返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="949e58f9ba98c6ec3b36a7ff32fc3bb4b305461a" translate="yes" xml:space="preserve">
          <source>If several elements are equally minimum, the first element is returned. If the iterator is empty, &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">如果几个元素相等地最小，则返回第一个元素。如果迭代器为空，则返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b831b3eb60862f2e083acd74777a5de0ed02dd83" translate="yes" xml:space="preserve">
          <source>If someone calls your code and passes in values that don&amp;rsquo;t make sense, the best choice might be to call &lt;code&gt;panic!&lt;/code&gt; and alert the person using your library to the bug in their code so they can fix it during development. Similarly, &lt;code&gt;panic!&lt;/code&gt; is often appropriate if you&amp;rsquo;re calling external code that is out of your control and it returns an invalid state that you have no way of fixing.</source>
          <target state="translated">如果有人调用您的代码并传递了没有意义的值，那么最好的选择就是调用 &lt;code&gt;panic!&lt;/code&gt; 并提醒使用您的库的人员代码中的错误，以便他们可以在开发期间进行修复。同样， &lt;code&gt;panic!&lt;/code&gt; 如果您正在调用无法控制的外部代码，并且返回的是无法修复的无效状态，则通常是合适的。</target>
        </trans-unit>
        <trans-unit id="acb94f3e0ba146c655ce1db4be8cf7e52d6ff088" translate="yes" xml:space="preserve">
          <source>If someone using our library decides to implement a &lt;code&gt;SelectBox&lt;/code&gt; struct that has &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;, and &lt;code&gt;options&lt;/code&gt; fields, they implement the &lt;code&gt;Draw&lt;/code&gt; trait on the &lt;code&gt;SelectBox&lt;/code&gt; type as well, as shown in Listing 17-8:</source>
          <target state="translated">如果使用我们库的某人决定实现具有 &lt;code&gt;width&lt;/code&gt; ， &lt;code&gt;height&lt;/code&gt; 和 &lt;code&gt;options&lt;/code&gt; 字段的 &lt;code&gt;SelectBox&lt;/code&gt; 结构，那么他们也对 &lt;code&gt;SelectBox&lt;/code&gt; 类型实现 &lt;code&gt;Draw&lt;/code&gt; trait ，如清单17-8所示：</target>
        </trans-unit>
        <trans-unit id="c3e301e4e887fd636487b5cc6eb192ded20f6d8f" translate="yes" xml:space="preserve">
          <source>If successful, &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt; is returned where the duration represents the amount of time elapsed from the specified measurement to this one.</source>
          <target state="translated">如果成功，则返回&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; &lt;code&gt;)&lt;/code&gt; ，其中持续时间表示从指定的度量到此度量所经过的时间。</target>
        </trans-unit>
        <trans-unit id="89f232794c16a32779f42828429fca7b54b7471f" translate="yes" xml:space="preserve">
          <source>If successful, this function returns the number of bytes which were read and appended to &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">如果成功，此函数将返回已读取并附加到 &lt;code&gt;buf&lt;/code&gt; 的字节数。</target>
        </trans-unit>
        <trans-unit id="dbb9443efd5c60b83bc142aff81add19921534e6" translate="yes" xml:space="preserve">
          <source>If successful, this function will return the total number of bytes read.</source>
          <target state="translated">如果成功,该函数将返回读取的总字节数。</target>
        </trans-unit>
        <trans-unit id="8f3b4d7781f3d86f3d03470464550aa348524451" translate="yes" xml:space="preserve">
          <source>If taking ownership is not an option, using indices can work too:</source>
          <target state="translated">如果不能选择所有权,使用指数也可以。</target>
        </trans-unit>
        <trans-unit id="bf999049465c29583e4954eb5930504df7197d78" translate="yes" xml:space="preserve">
          <source>If that field has type &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt;, then &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; implements &lt;code&gt;Unsized&amp;lt;Bar&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">如果该字段的类型为 &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; ，则 &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; 实现 &lt;code&gt;Unsized&amp;lt;Bar&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9156e468bccd98925a16dabd42948c9bf77880b3" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt; is disconnected while trying to &lt;a href=&quot;struct.sender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; with the &lt;a href=&quot;struct.sender&quot;&gt;&lt;code&gt;Sender&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;struct.sender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; method will return a &lt;a href=&quot;struct.senderror&quot;&gt;&lt;code&gt;SendError&lt;/code&gt;&lt;/a&gt;. Similarly, if the &lt;a href=&quot;struct.sender&quot;&gt;&lt;code&gt;Sender&lt;/code&gt;&lt;/a&gt; is disconnected while trying to &lt;a href=&quot;struct.receiver#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;struct.receiver#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; method will return a &lt;a href=&quot;struct.recverror&quot;&gt;&lt;code&gt;RecvError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt;在尝试使用&lt;a href=&quot;struct.sender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;struct.sender&quot;&gt; &lt;code&gt;Sender&lt;/code&gt; &lt;/a&gt;进行发送时断开连接，则&lt;a href=&quot;struct.sender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt;方法将返回&lt;a href=&quot;struct.senderror&quot;&gt; &lt;code&gt;SendError&lt;/code&gt; &lt;/a&gt;。同样，如果&lt;a href=&quot;struct.sender&quot;&gt; &lt;code&gt;Sender&lt;/code&gt; &lt;/a&gt;试图断开&lt;a href=&quot;struct.receiver#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt;时，&lt;a href=&quot;struct.receiver#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; 的&lt;/a&gt;方法将返回一个&lt;a href=&quot;struct.recverror&quot;&gt; &lt;code&gt;RecvError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="84c875b11ce397c9d5300f965f6f873d7aacf46f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;documentation&lt;/code&gt; environment variable is not defined, you'll get the following error:</source>
          <target state="translated">如果未定义 &lt;code&gt;documentation&lt;/code&gt; 环境变量，则会出现以下错误：</target>
        </trans-unit>
        <trans-unit id="772ba2d0efb42bb291361897234d8c41bb1fcad0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;move&lt;/code&gt; keyword is used, then all captures are by move or, for &lt;code&gt;Copy&lt;/code&gt; types, by copy, regardless of whether a borrow would work. The &lt;code&gt;move&lt;/code&gt; keyword is usually used to allow the closure to outlive the captured values, such as if the closure is being returned or used to spawn a new thread.</source>
          <target state="translated">如果使用 &lt;code&gt;move&lt;/code&gt; 关键字，则所有捕获都是通过移动进行的，对于 &lt;code&gt;Copy&lt;/code&gt; 类型，则是通过复制进行的，而不管借用是否有效。该 &lt;code&gt;move&lt;/code&gt; 关键字通常用于允许闭合活得比捕获的值，例如，如果被返回或用于产生新线程关闭。</target>
        </trans-unit>
        <trans-unit id="9d0e8d596c36d8fd761ca63dbd3e067a9bd6e058" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;panic!&lt;/code&gt; macro from the &lt;code&gt;core&lt;/code&gt; crate (not from &lt;code&gt;std&lt;/code&gt;) was used with a formatting string and some additional arguments, returns that message ready to be used for example with &lt;a href=&quot;../fmt/fn.write&quot;&gt;&lt;code&gt;fmt::write&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">如果 &lt;code&gt;panic!&lt;/code&gt; &lt;code&gt;core&lt;/code&gt; 板条箱（不是 &lt;code&gt;std&lt;/code&gt; ）中的宏与格式化字符串和一些其他参数一起使用，返回该消息准备好与&lt;a href=&quot;../fmt/fn.write&quot;&gt; &lt;code&gt;fmt::write&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1aa7728f06aa3a7a4db7dd1c33587c7078d8308d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;push_str&lt;/code&gt; method took ownership of &lt;code&gt;s2&lt;/code&gt;, we wouldn&amp;rsquo;t be able to print its value on the last line. However, this code works as we&amp;rsquo;d expect!</source>
          <target state="translated">如果 &lt;code&gt;push_str&lt;/code&gt; 方法拥有 &lt;code&gt;s2&lt;/code&gt; 的所有权，我们将无法在最后一行打印其值。但是，此代码可以按我们期望的那样工作！</target>
        </trans-unit>
        <trans-unit id="dced1236ce3e008b86324aaba64ac8eb311fb832" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;self&lt;/code&gt; parameter is prefixed with &lt;code&gt;mut&lt;/code&gt;, it becomes a mutable variable, similar to regular parameters using a &lt;code&gt;mut&lt;/code&gt;&lt;a href=&quot;../patterns#identifier-patterns&quot;&gt;identifier pattern&lt;/a&gt;. For example:</source>
          <target state="translated">如果 &lt;code&gt;self&lt;/code&gt; 参数以 &lt;code&gt;mut&lt;/code&gt; 作为前缀，则它变为可变变量，类似于使用 &lt;code&gt;mut&lt;/code&gt; &lt;a href=&quot;../patterns#identifier-patterns&quot;&gt;标识符模式的&lt;/a&gt;常规参数。例如：</target>
        </trans-unit>
        <trans-unit id="7d8f23d79fbc7e291c341b29a3b5a67aa2ad2d40" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;size&lt;/code&gt; is less than the current file's size, then the file will be shrunk. If it is greater than the current file's size, then the file will be extended to &lt;code&gt;size&lt;/code&gt; and have all of the intermediate data filled in with 0s.</source>
          <target state="translated">如果 &lt;code&gt;size&lt;/code&gt; 小于当前文件的大小，则文件将缩小。如果它大于当前文件的大小，则该文件将扩展为 &lt;code&gt;size&lt;/code&gt; ，并且所有中间数据都用0填充。</target>
        </trans-unit>
        <trans-unit id="d57ee1700b4eb4f8d7a231756f83fc0d2f0976ae" translate="yes" xml:space="preserve">
          <source>If the access could not be granted at this time, then &lt;code&gt;Err&lt;/code&gt; is returned. Otherwise, an RAII guard is returned which will release the shared access when it is dropped.</source>
          <target state="translated">如果此时不能授予访问权限，则返回 &lt;code&gt;Err&lt;/code&gt; 。否则，将返回RAII保护，当该保护被删除时，该保护将释放共享访问。</target>
        </trans-unit>
        <trans-unit id="21bd5a18cb6b77fd8278b94aa3db19219a263b12" translate="yes" xml:space="preserve">
          <source>If the actual type neither requires drop glue nor implements &lt;code&gt;Copy&lt;/code&gt;, then may return &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果实际类型既不需要滴胶也不需要实现 &lt;code&gt;Copy&lt;/code&gt; ，则可能返回 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b0291a87b80d4892b3b8beac10c94678155d9e30" translate="yes" xml:space="preserve">
          <source>If the actual type neither requires drop glue nor implements &lt;code&gt;Copy&lt;/code&gt;, then the return value of this function is unspecified.</source>
          <target state="translated">如果实际类型既不需要滴胶也不需要实现 &lt;code&gt;Copy&lt;/code&gt; ，则此函数的返回值不确定。</target>
        </trans-unit>
        <trans-unit id="fc42b30b1c7732695b4b3457f14e9c116c60ba57" translate="yes" xml:space="preserve">
          <source>If the address different between the two pointers is not a multiple of &lt;code&gt;mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; then the result of the division is rounded towards zero.</source>
          <target state="translated">如果两个指针之间的地址不同不是 &lt;code&gt;mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 的倍数，则除法结果将取整为零。</target>
        </trans-unit>
        <trans-unit id="521a07de2e3c6e68db23d9d0aa394b57d65a9c91" translate="yes" xml:space="preserve">
          <source>If the array has 32 or fewer elements (see above), you can also use the array reference's &lt;a href=&quot;iter/trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; implementation:</source>
          <target state="translated">如果数组包含32个或更少的元素（请参见上文），则还可以使用数组引用的&lt;a href=&quot;iter/trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt;实现：</target>
        </trans-unit>
        <trans-unit id="cfb58ffddaf17c8830de11935999affae3277e66" translate="yes" xml:space="preserve">
          <source>If the author information that Cargo obtained from your environment is not correct, fix that in the file and save it again.</source>
          <target state="translated">如果Cargo从你的环境中获取的作者信息不正确,请在文件中修正,然后再保存。</target>
        </trans-unit>
        <trans-unit id="ff4681586c0fae7d47f1330c0decf48c60236eb4" translate="yes" xml:space="preserve">
          <source>If the buffer contains no data, this will never call &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;&lt;code&gt;write_vectored&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果缓冲区不包含任何数据，则永远不会调用&lt;a href=&quot;trait.write#method.write_vectored&quot;&gt; &lt;code&gt;write_vectored&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9e707e84e6d9e2a09dcbe7b44964291bac9543c0" translate="yes" xml:space="preserve">
          <source>If the buffer contains no data, this will never call &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果缓冲区不包含任何数据，则永远不会调用&lt;a href=&quot;trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2baf63139a4a500a73ca143a78e4d4794de4fa4c" translate="yes" xml:space="preserve">
          <source>If the call to &lt;code&gt;poll&lt;/code&gt; returns &lt;a href=&quot;../../std/task/enum.poll#variant.Pending&quot;&gt;&lt;code&gt;Poll::Pending&lt;/code&gt;&lt;/a&gt;, then the future returns &lt;code&gt;Poll::Pending&lt;/code&gt;, suspending its state so that, when the surrounding async context is re-polled, execution returns to step 2;</source>
          <target state="translated">如果对 &lt;code&gt;poll&lt;/code&gt; 的调用返回&lt;a href=&quot;../../std/task/enum.poll#variant.Pending&quot;&gt; &lt;code&gt;Poll::Pending&lt;/code&gt; &lt;/a&gt;，则将来返回 &lt;code&gt;Poll::Pending&lt;/code&gt; ，并暂停其状态，以便在对周围的异步上下文进行重新轮询时，执行返回到步骤2；否则，执行将返回步骤2。</target>
        </trans-unit>
        <trans-unit id="65f8dad0e6e0ed1617e67254f63f3538d64e8eee" translate="yes" xml:space="preserve">
          <source>If the capacity overflows &lt;code&gt;usize&lt;/code&gt;, or the allocator reports a failure, then an error is returned.</source>
          <target state="translated">如果容量溢出 &lt;code&gt;usize&lt;/code&gt; ，或者分配器报告失败，则返回错误。</target>
        </trans-unit>
        <trans-unit id="a413f73c6a00e8ec27d7656a64c0041d810a18fb" translate="yes" xml:space="preserve">
          <source>If the capacity overflows, or the allocator reports a failure, then an error is returned.</source>
          <target state="translated">如果容量溢出,或者分配器报告失败,则返回一个错误。</target>
        </trans-unit>
        <trans-unit id="d22b2ac0a0ad8bf3c9d2af95eda6c6dcbfb7f5e8" translate="yes" xml:space="preserve">
          <source>If the child has exited, then &lt;code&gt;Ok(Some(status))&lt;/code&gt; is returned. If the exit status is not available at this time then &lt;code&gt;Ok(None)&lt;/code&gt; is returned. If an error occurs, then that error is returned.</source>
          <target state="translated">如果孩子已经退出，则返回 &lt;code&gt;Ok(Some(status))&lt;/code&gt; 。如果此时退出状态不可用，则返回 &lt;code&gt;Ok(None)&lt;/code&gt; 。如果发生错误，则返回该错误。</target>
        </trans-unit>
        <trans-unit id="1f183ab05bb99521927fd36b3e847b7c523cd3b5" translate="yes" xml:space="preserve">
          <source>If the child thread panics, &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned with the parameter given to &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果子线程出现紧急情况，则返回&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;并提供给&lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;的参数！。</target>
        </trans-unit>
        <trans-unit id="c11de405bba2eb95a67f5ddf98e8d367a826811a" translate="yes" xml:space="preserve">
          <source>If the child thread panics, &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned with the parameter given to &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果子线程出现紧急情况，则使用指定给&lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic&lt;/code&gt; &lt;/a&gt;的参数返回&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="611996f7840618a761ac96c392b8f31568d8ec31" translate="yes" xml:space="preserve">
          <source>If the closure can't outlive the value being moved, try using a reference rather than moving:</source>
          <target state="translated">如果闭合不能超过被移动的值,可以尝试使用一个引用而不是移动。</target>
        </trans-unit>
        <trans-unit id="0f3013a1be5e1908d0fd59aee1eeb2a1559501d9" translate="yes" xml:space="preserve">
          <source>If the closure returns &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(element)&lt;/code&gt;&lt;/a&gt;, then that element is returned.</source>
          <target state="translated">如果闭包返回&lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(element)&lt;/code&gt; &lt;/a&gt;，则返回该元素。</target>
        </trans-unit>
        <trans-unit id="1cc29c4e531aec77355dc3263edbde0e02717ace" translate="yes" xml:space="preserve">
          <source>If the closure returns true, the element is removed from the map and yielded. If the closure returns false, or panics, the element remains in the map and will not be yielded.</source>
          <target state="translated">如果闭包返回true,该元素将从地图中移除并被屈服。如果闭合返回false,或者惊慌失措,该元素仍在地图中,不会被屈服。</target>
        </trans-unit>
        <trans-unit id="bb67b7c500cdec79f1ce3d7841c806209783608e" translate="yes" xml:space="preserve">
          <source>If the closure returns true, then the element is removed and yielded. If the closure returns false, the element will remain in the list and will not be yielded by the iterator.</source>
          <target state="translated">如果闭包返回true,那么该元素将被移除并产生。如果闭包返回false,则该元素将保留在列表中,不会被迭代器产生。</target>
        </trans-unit>
        <trans-unit id="6dd010d31dbb3764b4ed75ed86f6e32953c1d0d8" translate="yes" xml:space="preserve">
          <source>If the closure returns true, then the element is removed and yielded. If the closure returns false, the element will remain in the vector and will not be yielded by the iterator.</source>
          <target state="translated">如果闭包返回true,那么该元素将被移除并产生。如果闭包返回false,元素将保留在向量中,不会被迭代器产生。</target>
        </trans-unit>
        <trans-unit id="2a139e146ec9f48fd19a95af86148618a4801924" translate="yes" xml:space="preserve">
          <source>If the closure returns true, then the value is removed and yielded. If the closure returns false, the value will remain in the list and will not be yielded by the iterator.</source>
          <target state="translated">如果闭包返回true,那么该值就会被删除并产生。如果闭包返回false,该值将保留在列表中,不会被迭代器产生。</target>
        </trans-unit>
        <trans-unit id="214ba23b863f161492d3f9635dec38066733211c" translate="yes" xml:space="preserve">
          <source>If the contents of the &lt;code&gt;CStr&lt;/code&gt; are valid UTF-8 data, this function will return a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../borrow/enum.cow#variant.Borrowed&quot;&gt;&lt;code&gt;Borrowed&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt; with the corresponding &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; slice. Otherwise, it will replace any invalid UTF-8 sequences with &lt;a href=&quot;../char/constant.replacement_character&quot;&gt;&lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt;&lt;/a&gt; and return a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../borrow/enum.cow#variant.Owned&quot;&gt;&lt;code&gt;Owned&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt; with the result.</source>
          <target state="translated">如果 &lt;code&gt;CStr&lt;/code&gt; 的内容是有效的UTF-8数据，则此函数将返回带有对应的&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;切片的&lt;a href=&quot;../borrow/enum.cow&quot;&gt; &lt;code&gt;Cow&lt;/code&gt; &lt;/a&gt; &lt;code&gt;::&lt;/code&gt; &lt;a href=&quot;../borrow/enum.cow#variant.Borrowed&quot;&gt; &lt;code&gt;Borrowed&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; &lt;code&gt;)&lt;/code&gt; 。否则，它将用&lt;a href=&quot;../char/constant.replacement_character&quot;&gt; &lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt; &lt;/a&gt;替换所有无效的UTF-8序列，并返回带有结果的&lt;a href=&quot;../borrow/enum.cow&quot;&gt; &lt;code&gt;Cow&lt;/code&gt; &lt;/a&gt; &lt;code&gt;::&lt;/code&gt; &lt;a href=&quot;../borrow/enum.cow#variant.Owned&quot;&gt; &lt;code&gt;Owned&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; &lt;code&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31dba64d7d22c597dfce03fd7cdb2b9f96c2ab94" translate="yes" xml:space="preserve">
          <source>If the contents of the &lt;code&gt;CStr&lt;/code&gt; are valid UTF-8 data, this function will return a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../borrow/enum.cow#variant.Borrowed&quot;&gt;&lt;code&gt;Borrowed&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;[&lt;code&gt;&amp;amp;str&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt; with the corresponding [&lt;code&gt;&amp;amp;str&lt;/code&gt;] slice. Otherwise, it will replace any invalid UTF-8 sequences with &lt;a href=&quot;../char/constant.replacement_character&quot;&gt;&lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt;&lt;/a&gt; and return a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../borrow/enum.cow#variant.Owned&quot;&gt;&lt;code&gt;Owned&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt; with the result.</source>
          <target state="translated">如果 &lt;code&gt;CStr&lt;/code&gt; 的内容是有效的UTF-8数据，则此函数将返回&lt;a href=&quot;../borrow/enum.cow&quot;&gt; &lt;code&gt;Cow&lt;/code&gt; &lt;/a&gt; &lt;code&gt;::&lt;/code&gt; &lt;a href=&quot;../borrow/enum.cow#variant.Borrowed&quot;&gt; &lt;code&gt;Borrowed&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; [ &lt;code&gt;&amp;amp;str&lt;/code&gt; ] &lt;code&gt;)&lt;/code&gt; 和相应的[ &lt;code&gt;&amp;amp;str&lt;/code&gt; ]切片。否则，它将用&lt;a href=&quot;../char/constant.replacement_character&quot;&gt; &lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt; &lt;/a&gt;替换所有无效的UTF-8序列，并返回带有结果的&lt;a href=&quot;../borrow/enum.cow&quot;&gt; &lt;code&gt;Cow&lt;/code&gt; &lt;/a&gt; &lt;code&gt;::&lt;/code&gt; &lt;a href=&quot;../borrow/enum.cow#variant.Owned&quot;&gt; &lt;code&gt;Owned&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; &lt;code&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db9461413b5ee9b4f01c463f0ad906b75913f24c" translate="yes" xml:space="preserve">
          <source>If the contents of the &lt;code&gt;CStr&lt;/code&gt; are valid UTF-8 data, this function will return the corresponding &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; slice. Otherwise, it will return an error with details of where UTF-8 validation failed.</source>
          <target state="translated">如果 &lt;code&gt;CStr&lt;/code&gt; 的内容是有效的UTF-8数据，则此函数将返回相应的&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;切片。否则，它将返回错误，并详细说明UTF-8验证失败的位置。</target>
        </trans-unit>
        <trans-unit id="baae7bb665c0286cfaf2cbea5e20bdf6cf34d67d" translate="yes" xml:space="preserve">
          <source>If the contents of the &lt;code&gt;CStr&lt;/code&gt; are valid UTF-8 data, this function will return the corresponding &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; slice. Otherwise, it will return an error with details of where UTF-8 validation failed.</source>
          <target state="translated">如果 &lt;code&gt;CStr&lt;/code&gt; 的内容是有效的UTF-8数据，则此函数将返回相应的&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;切片。否则，它将返回错误，并详细说明UTF-8验证失败的位置。</target>
        </trans-unit>
        <trans-unit id="99bd91603a025b03597fd1f9cbdd0b5e23a815bb" translate="yes" xml:space="preserve">
          <source>If the corresponding &lt;a href=&quot;struct.sender&quot;&gt;&lt;code&gt;Sender&lt;/code&gt;&lt;/a&gt; has disconnected, or it disconnects while this call is blocking, this call will wake up and return &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; to indicate that no more messages can ever be received on this channel. However, since channels are buffered, messages sent before the disconnect will still be properly received.</source>
          <target state="translated">如果相应的&lt;a href=&quot;struct.sender&quot;&gt; &lt;code&gt;Sender&lt;/code&gt; &lt;/a&gt;已断开连接，或者在此呼叫阻塞时断开了连接，则此呼叫将唤醒并返回&lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; ,&lt;/a&gt;以指示该通道上再也不会收到任何消息。但是，由于通道已缓冲，因此在断开连接之前发送的消息仍将正确接收。</target>
        </trans-unit>
        <trans-unit id="91ebc4eb9040370bb60e1b55cb245ed551a2b766" translate="yes" xml:space="preserve">
          <source>If the cursor is currently pointing to the &quot;ghost&quot; non-element then no element is removed and &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">如果光标当前指向&amp;ldquo; ghost&amp;rdquo;非元素，则不删除任何元素，并返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4624b3463b579ff38cd7090e939e0664781afc4a" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing at the &quot;ghost&quot; non-element then the entire contents of the &lt;code&gt;LinkedList&lt;/code&gt; are moved.</source>
          <target state="translated">如果光标指向&amp;ldquo; ghost&amp;rdquo;非元素，则将移动 &lt;code&gt;LinkedList&lt;/code&gt; 的全部内容。</target>
        </trans-unit>
        <trans-unit id="d335a3b2bd9233a3fbdf7c96e469f75d1c5e365d" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing at the &quot;ghost&quot; non-element then the new element is inserted at the end of the &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="translated">如果光标指向&amp;ldquo; ghost&amp;rdquo;非元素，则将新元素插入 &lt;code&gt;LinkedList&lt;/code&gt; 的末尾。</target>
        </trans-unit>
        <trans-unit id="31375a5dbf525938d61772845c72aab093fab9cf" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing at the &quot;ghost&quot; non-element then the new element is inserted at the front of the &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="translated">如果光标指向&amp;ldquo; ghost&amp;rdquo;非元素，则将新元素插入 &lt;code&gt;LinkedList&lt;/code&gt; 的前面。</target>
        </trans-unit>
        <trans-unit id="58963dd2948fd819f86fd5e461e02e99ecc3a20a" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing at the &quot;ghost&quot; non-element then the new elements are inserted at the end of the &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="translated">如果光标指向&amp;ldquo; ghost&amp;rdquo;非元素，则将新元素插入 &lt;code&gt;LinkedList&lt;/code&gt; 的末尾。</target>
        </trans-unit>
        <trans-unit id="6f945e6d3050ed5d918eb8a5e109487061da86ff" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing at the &quot;ghost&quot; non-element then the new elements are inserted at the start of the &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="translated">如果光标指向&amp;ldquo; ghost&amp;rdquo;非元素，则将新元素插入 &lt;code&gt;LinkedList&lt;/code&gt; 的开头。</target>
        </trans-unit>
        <trans-unit id="9708432e377fc3315ff2743a227e5ee6ae976fb7" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing to the &quot;ghost&quot; non-element then this returns the first element of the &lt;code&gt;LinkedList&lt;/code&gt;. If it is pointing to the last element of the &lt;code&gt;LinkedList&lt;/code&gt; then this returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">如果光标指向&amp;ldquo; ghost&amp;rdquo;非元素，则返回 &lt;code&gt;LinkedList&lt;/code&gt; 的第一个元素。如果它指向 &lt;code&gt;LinkedList&lt;/code&gt; 的最后一个元素，则返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a515e2eb729ab1875351c8ecfe7942b25cd004cc" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing to the &quot;ghost&quot; non-element then this returns the last element of the &lt;code&gt;LinkedList&lt;/code&gt;. If it is pointing to the first element of the &lt;code&gt;LinkedList&lt;/code&gt; then this returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">如果光标指向&amp;ldquo; ghost&amp;rdquo;非元素，则返回 &lt;code&gt;LinkedList&lt;/code&gt; 的最后一个元素。如果它指向 &lt;code&gt;LinkedList&lt;/code&gt; 的第一个元素，则返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4bf96ffdc655962850c81ce839b17c859f11a67" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing to the &quot;ghost&quot; non-element then this will move it to the first element of the &lt;code&gt;LinkedList&lt;/code&gt;. If it is pointing to the last element of the &lt;code&gt;LinkedList&lt;/code&gt; then this will move it to the &quot;ghost&quot; non-element.</source>
          <target state="translated">如果光标指向&amp;ldquo; ghost&amp;rdquo;非元素，则将其移至 &lt;code&gt;LinkedList&lt;/code&gt; 的第一个元素。如果它指向 &lt;code&gt;LinkedList&lt;/code&gt; 的最后一个元素，则将其移到&amp;ldquo; ghost&amp;rdquo;非元素。</target>
        </trans-unit>
        <trans-unit id="825c50dec4e26dcdffad5ec9a6866af450b9f9e9" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing to the &quot;ghost&quot; non-element then this will move it to the last element of the &lt;code&gt;LinkedList&lt;/code&gt;. If it is pointing to the first element of the &lt;code&gt;LinkedList&lt;/code&gt; then this will move it to the &quot;ghost&quot; non-element.</source>
          <target state="translated">如果光标指向&amp;ldquo; ghost&amp;rdquo;非元素，则将其移至 &lt;code&gt;LinkedList&lt;/code&gt; 的最后一个元素。如果它指向 &lt;code&gt;LinkedList&lt;/code&gt; 的第一个元素，则将其移到&amp;ldquo; ghost&amp;rdquo;非元素。</target>
        </trans-unit>
        <trans-unit id="c9097bc3fc6399fb3bc83c93071781dffb279d65" translate="yes" xml:space="preserve">
          <source>If the data in this stream is &lt;em&gt;not&lt;/em&gt; valid UTF-8 then an error is returned and &lt;code&gt;buf&lt;/code&gt; is unchanged.</source>
          <target state="translated">如果此流中的数据&lt;em&gt;不是&lt;/em&gt;有效的UTF-8，则返回错误，并且 &lt;code&gt;buf&lt;/code&gt; 不变。</target>
        </trans-unit>
        <trans-unit id="10754b248a576fdba9d5228dc71f26ade299f007" translate="yes" xml:space="preserve">
          <source>If the definition of &lt;code&gt;foo&lt;/code&gt; is under your control, the simplest solution is to capture the data mutably. This can be done by defining &lt;code&gt;foo&lt;/code&gt; to take FnMut rather than Fn:</source>
          <target state="translated">如果 &lt;code&gt;foo&lt;/code&gt; 的定义在您的控制之下，则最简单的解决方案是可变捕获数据。这可以通过将 &lt;code&gt;foo&lt;/code&gt; 定义为采用FnMut而不是Fn来完成：</target>
        </trans-unit>
        <trans-unit id="42bdc1ae118555b88ae881099abace5a191c0219" translate="yes" xml:space="preserve">
          <source>If the destination type is not part of the current crate then you can't implement &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; directly. For example, take this code:</source>
          <target state="translated">如果目标类型不属于当前包装箱，则不能直接实现&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt;。例如，使用以下代码：</target>
        </trans-unit>
        <trans-unit id="587511482f256e8f952acfee186e5aefae6cf9ca" translate="yes" xml:space="preserve">
          <source>If the determination that the code is unreachable proves incorrect, the program immediately terminates with a &lt;a href=&quot;macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果确定无法访问该代码是不正确的，则该程序会立即&lt;a href=&quot;macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;终止！。</target>
        </trans-unit>
        <trans-unit id="4c5ab8621c8a741eb7e90c657432848573f050ef" translate="yes" xml:space="preserve">
          <source>If the element type of the iterator you need does not implement &lt;code&gt;Clone&lt;/code&gt;, or if you do not want to keep the repeated element in memory, you can instead use the &lt;a href=&quot;fn.repeat_with&quot;&gt;&lt;code&gt;repeat_with()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">如果迭代器的元素类型不需要实现 &lt;code&gt;Clone&lt;/code&gt; ，或者不想将重复的元素保留在内存中，则可以使用&lt;a href=&quot;fn.repeat_with&quot;&gt; &lt;code&gt;repeat_with()&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="480ada98c1c5ece146ecdc077a3e40775d89fd0e" translate="yes" xml:space="preserve">
          <source>If the element type of the iterator you need does not implement &lt;code&gt;Clone&lt;/code&gt;, or if you do not want to keep the repeated element in memory, you can instead use the &lt;a href=&quot;fn.repeat_with&quot;&gt;&lt;code&gt;repeat_with&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">如果所需的迭代器元素类型未实现 &lt;code&gt;Clone&lt;/code&gt; ，或者不想将重复的元素保留在内存中，则可以使用&lt;a href=&quot;fn.repeat_with&quot;&gt; &lt;code&gt;repeat_with&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="156fcf0995b1088c12c501a80ad16ba6aab2c6f4" translate="yes" xml:space="preserve">
          <source>If the element type of the iterator you need implements &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, and it is OK to keep the source element in memory, you should instead use the &lt;a href=&quot;fn.repeat&quot;&gt;&lt;code&gt;repeat()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">如果您需要的迭代器的元素类型实现&lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;，并且可以将源元素保留在内存中，则应该改用&lt;a href=&quot;fn.repeat&quot;&gt; &lt;code&gt;repeat()&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="3b5563e722ef79a66827ad237de3ff713088f72a" translate="yes" xml:space="preserve">
          <source>If the element type of the iterator you need implements &lt;code&gt;Clone&lt;/code&gt;, and it is OK to keep the source element in memory, you should instead use the &lt;a href=&quot;fn.repeat&quot;&gt;&lt;code&gt;repeat&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">如果您需要的迭代器的元素类型实现 &lt;code&gt;Clone&lt;/code&gt; ，并且可以将源元素保留在内存中，则应该使用&lt;a href=&quot;fn.repeat&quot;&gt; &lt;code&gt;repeat&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="fdfbdf49a01ecb81ac4dd4acab163dbc68e7e8c0" translate="yes" xml:space="preserve">
          <source>If the environment variable is not defined, then a compilation error will be emitted. To not emit a compile error, use the &lt;a href=&quot;macro.option_env&quot;&gt;&lt;code&gt;option_env!&lt;/code&gt;&lt;/a&gt; macro instead.</source>
          <target state="translated">如果未定义环境变量，则将发出编译错误。&lt;a href=&quot;macro.option_env&quot;&gt; &lt;code&gt;option_env!&lt;/code&gt; &lt;/a&gt;产生编译错误，请使用option_env！宏代替。</target>
        </trans-unit>
        <trans-unit id="6e8972418288b27e60b8fafe88d7c99a7d59e984" translate="yes" xml:space="preserve">
          <source>If the executable was invoked through a symbolic link, some platforms will return the path of the symbolic link and other platforms will return the path of the symbolic link&amp;rsquo;s target.</source>
          <target state="translated">如果可执行文件是通过符号链接调用的，则某些平台将返回符号链接的路径，而其他平台将返回符号链接目标的路径。</target>
        </trans-unit>
        <trans-unit id="fd55e486394dd1866434bdc5faf39742bfb2a2d4" translate="yes" xml:space="preserve">
          <source>If the expression in one of these coercion sites is a coercion-propagating expression, then the relevant sub-expressions in that expression are also coercion sites. Propagation recurses from these new coercion sites. Propagating expressions and their relevant sub-expressions are:</source>
          <target state="translated">如果这些胁迫位点中的一个表达是一个胁迫传播的表达,那么该表达中的相关子表达也是胁迫位点。传播从这些新的胁迫位点出发,反复进行。传播表达式及其相关的子表达式是:。</target>
        </trans-unit>
        <trans-unit id="da06749df21ae19d99c10837b4fef8698354acfb" translate="yes" xml:space="preserve">
          <source>If the feature is accepted, an issue is opened on the Rust repository, and someone can implement it. The person who implements it very well may not be the person who proposed the feature in the first place! When the implementation is ready, it lands on the &lt;code&gt;master&lt;/code&gt; branch behind a feature gate, as we discussed in the &lt;a href=&quot;#unstable-features&quot;&gt;&amp;ldquo;Unstable Features&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">如果该功能被接受，则将在Rust存储库上打开一个问题，并且有人可以实现它。实施得很好的人可能不是最初提出该功能的人！如我们在&lt;a href=&quot;#unstable-features&quot;&gt;&amp;ldquo;不稳定的功能&amp;rdquo;&lt;/a&gt;部分中所述，实现准备就绪后，它会落在功能门后面的 &lt;code&gt;master&lt;/code&gt; 分支上。</target>
        </trans-unit>
        <trans-unit id="3414a33407bd3dac73209f0f3c8c87238661b1ca" translate="yes" xml:space="preserve">
          <source>If the file already exists, any write calls on it will overwrite its contents, without truncating it.</source>
          <target state="translated">如果文件已经存在,对它的任何写入调用都会覆盖它的内容,而不会截断它。</target>
        </trans-unit>
        <trans-unit id="9132b3e3ab7219a34cb586c6f14321ce888d6773" translate="yes" xml:space="preserve">
          <source>If the first element is matched, an empty slice will be the first item returned by the iterator. Similarly, if the last element in the slice is matched, an empty slice will be the last item returned by the iterator:</source>
          <target state="translated">如果第一个元素被匹配,空分片将是迭代器返回的第一个项目。同样,如果分片中的最后一个元素被匹配,那么空分片将是迭代器返回的最后一个项目。</target>
        </trans-unit>
        <trans-unit id="a3fd11d96e62e4df934fdc1fa4662261ba86625c" translate="yes" xml:space="preserve">
          <source>If the given capacity is &lt;code&gt;0&lt;/code&gt;, no allocation will occur, and this method is identical to the &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">如果给定容量为 &lt;code&gt;0&lt;/code&gt; ，则不会进行分配，并且此方法与&lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt;方法相同。</target>
        </trans-unit>
        <trans-unit id="c71e4086428a9289ae6841638f980514baf4e1e2" translate="yes" xml:space="preserve">
          <source>If the given capacity is &lt;code&gt;0&lt;/code&gt;, no allocation will occur, and this method is identical to the &lt;a href=&quot;struct.string#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">如果给定容量为 &lt;code&gt;0&lt;/code&gt; ，则不会进行分配，并且此方法与&lt;a href=&quot;struct.string#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt;方法相同。</target>
        </trans-unit>
        <trans-unit id="c23f42fcc2aeb440c3d587979f6b3a221b95c0ef" translate="yes" xml:space="preserve">
          <source>If the given closure recursively invokes &lt;code&gt;call_once&lt;/code&gt; on the same &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; instance the exact behavior is not specified, allowed outcomes are a panic or a deadlock.</source>
          <target state="translated">如果给定的闭包在同一&amp;ldquo;&lt;a href=&quot;struct.once&quot;&gt; &lt;code&gt;Once&lt;/code&gt; &lt;/a&gt;实例上递归调用 &lt;code&gt;call_once&lt;/code&gt; ，则未指定确切的行为，则允许的结果是恐慌或死锁。</target>
        </trans-unit>
        <trans-unit id="3e650fcb37c79e73b248840291059fa9ab82facc" translate="yes" xml:space="preserve">
          <source>If the given closure recursively invokes &lt;code&gt;call_once&lt;/code&gt; on the same &lt;code&gt;Once&lt;/code&gt; instance the exact behavior is not specified, allowed outcomes are a panic or a deadlock.</source>
          <target state="translated">如果给定的闭包在同一&amp;ldquo; &lt;code&gt;Once&lt;/code&gt; 实例上递归调用 &lt;code&gt;call_once&lt;/code&gt; ，则未指定确切的行为，则允许的结果是恐慌或死锁。</target>
        </trans-unit>
        <trans-unit id="82cd743013a3edab20be44d34d8b246c9798bdd1" translate="yes" xml:space="preserve">
          <source>If the input isn't NaN, then there is no portability concern.</source>
          <target state="translated">如果输入的不是NaN,那么就不存在可移植性的问题。</target>
        </trans-unit>
        <trans-unit id="678a91cbb4ec06d73442b77832f91bad809fe51b" translate="yes" xml:space="preserve">
          <source>If the item is a function, you may use a closure:</source>
          <target state="translated">如果该项目是一个函数,你可以使用一个闭合。</target>
        </trans-unit>
        <trans-unit id="3955594d420a5299baca31b21b74e398d9cdcfd9" translate="yes" xml:space="preserve">
          <source>If the item is modified then the worst case time complexity is &lt;em&gt;O&lt;/em&gt;(log(&lt;em&gt;n&lt;/em&gt;)), otherwise it's &lt;em&gt;O&lt;/em&gt;(1).</source>
          <target state="translated">如果修改了该项目，则最坏情况下的时间复杂度为&lt;em&gt;O&lt;/em&gt;（log（&lt;em&gt;n&lt;/em&gt;）），否则为&lt;em&gt;O&lt;/em&gt;（1）。</target>
        </trans-unit>
        <trans-unit id="4e29e02642c9eb9601c44c59f05b7d126f43b3f4" translate="yes" xml:space="preserve">
          <source>If the item is not defined in the current module, it must be imported using a &lt;code&gt;use&lt;/code&gt; statement, like so:</source>
          <target state="translated">如果该项目未在当前模块中定义，则必须使用 &lt;code&gt;use&lt;/code&gt; 语句将其导入，如下所示：</target>
        </trans-unit>
        <trans-unit id="5030e30e9a190114fd41d37b0c1ba92d9eec8bbd" translate="yes" xml:space="preserve">
          <source>If the item you are importing is not defined in some super-module of the current module, then it must also be declared as public (e.g., &lt;code&gt;pub fn&lt;/code&gt;).</source>
          <target state="translated">如果要导入的项目未在当前模块的某些超级模块中定义，则还必须将其声明为public（例如 &lt;code&gt;pub fn&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="719a1576fd9e7210e99462a559c7958169595ce7" translate="yes" xml:space="preserve">
          <source>If the iterator is only partially consumed or not consumed at all, each of the remaining elements will still be subjected to the closure and removed and dropped if it returns true.</source>
          <target state="translated">如果迭代器只消耗了一部分或根本没有消耗,那么剩下的每个元素仍然会受到闭包,如果返回真,则会被删除并放弃。</target>
        </trans-unit>
        <trans-unit id="e4d63a01b8d322a8870de0053bcaa4759ed12bae" translate="yes" xml:space="preserve">
          <source>If the iterator is only partially consumed or not consumed at all, each of the remaining values will still be subjected to the closure and removed and dropped if it returns true.</source>
          <target state="translated">如果迭代器只消耗了一部分或根本没有消耗,那么剩下的每个值仍然会受到闭包,如果返回真,则会被删除并放弃。</target>
        </trans-unit>
        <trans-unit id="fc64622999ffaef4c074c0b3f6d2b93d8dbc840b" translate="yes" xml:space="preserve">
          <source>If the last element of the slice is matched, that element will be considered the terminator of the preceding slice. That slice will be the last item returned by the iterator.</source>
          <target state="translated">如果分片的最后一个元素被匹配,该元素将被视为前一个分片的结束符。该分片将是迭代器返回的最后一个项目。</target>
        </trans-unit>
        <trans-unit id="46e75edbffb14b1f9cbe211ae39152c93cbfb5b3" translate="yes" xml:space="preserve">
          <source>If the last element of the string is matched, that element will be considered the terminator of the preceding substring. That substring will be the last item returned by the iterator.</source>
          <target state="translated">如果字符串的最后一个元素被匹配,那么这个元素将被认为是前面子串的结束符。该子串将是迭代器返回的最后一项。</target>
        </trans-unit>
        <trans-unit id="6c2eb24f388c4f9da46dc55e06c2973845737ad4" translate="yes" xml:space="preserve">
          <source>If the length doesn't match, the input comes back in &lt;code&gt;Err&lt;/code&gt;:</source>
          <target state="translated">如果长度不匹配，则输入以 &lt;code&gt;Err&lt;/code&gt; 返回：</target>
        </trans-unit>
        <trans-unit id="c7f0b78af6a1f2b8da54724cc60c89fb090afb8c" translate="yes" xml:space="preserve">
          <source>If the lifetime of a reference isn't enough, such as in the case of threading, consider using an &lt;code&gt;Arc&lt;/code&gt; to create a reference-counted value:</source>
          <target state="translated">如果引用的生存期不够，例如在使用线程的情况下，请考虑使用 &lt;code&gt;Arc&lt;/code&gt; 来创建引用计数的值：</target>
        </trans-unit>
        <trans-unit id="0e305a8484a9cd9dc5c8361f54c572219ec9804c" translate="yes" xml:space="preserve">
          <source>If the lock could not be acquired at this time, then &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned. Otherwise, an RAII guard is returned. The lock will be unlocked when the guard is dropped.</source>
          <target state="translated">如果此时无法获取锁，则返回&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;。否则，将返回RAII警卫。放下防护装置时，锁将解锁。</target>
        </trans-unit>
        <trans-unit id="f8b222d65f3e5a011a407bdb03d5df29adfec456" translate="yes" xml:space="preserve">
          <source>If the lock could not be acquired at this time, then &lt;code&gt;Err&lt;/code&gt; is returned. Otherwise, an RAII guard is returned which will release the lock when it is dropped.</source>
          <target state="translated">如果此时无法获取锁，则返回 &lt;code&gt;Err&lt;/code&gt; 。否则，将返回RAII保护器，该保护器在被释放时将释放该锁。</target>
        </trans-unit>
        <trans-unit id="ecf781a8afe2a0c63a1d40b96befbc6c4dce088d" translate="yes" xml:space="preserve">
          <source>If the main thread panics it will terminate all your threads and end your program with code &lt;code&gt;101&lt;/code&gt;.</source>
          <target state="translated">如果主线程崩溃，它将终止所有线程并以代码 &lt;code&gt;101&lt;/code&gt; 结束程序。</target>
        </trans-unit>
        <trans-unit id="fedf3b811ad1f7726933bad19dd231acecc809fc" translate="yes" xml:space="preserve">
          <source>If the map did have this key present, the value is updated, and the old value is returned. The key is not updated, though; this matters for types that can be &lt;code&gt;==&lt;/code&gt; without being identical. See the &lt;a href=&quot;../index#insert-and-complex-keys&quot;&gt;module-level documentation&lt;/a&gt; for more.</source>
          <target state="translated">如果地图确实存在此键，则将更新值，并返回旧值。但是，密钥不会更新。这对于可以 &lt;code&gt;==&lt;/code&gt; 但不相同的类型很重要。有关更多信息，请参见&lt;a href=&quot;../index#insert-and-complex-keys&quot;&gt;模块级文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d96d894c9cb755e3982e02a5fa557e27c759b559" translate="yes" xml:space="preserve">
          <source>If the map did have this key present, the value is updated, and the old value is returned. The key is not updated, though; this matters for types that can be &lt;code&gt;==&lt;/code&gt; without being identical. See the &lt;a href=&quot;index#insert-and-complex-keys&quot;&gt;module-level documentation&lt;/a&gt; for more.</source>
          <target state="translated">如果地图确实存在此键，则更新值，并返回旧值。但是，密钥不会更新。这对于可以 &lt;code&gt;==&lt;/code&gt; 但不相同的类型很重要。有关更多信息，请参见&lt;a href=&quot;index#insert-and-complex-keys&quot;&gt;模块级文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a660d0d730c1d18357284ffbb42b24c56c1fea09" translate="yes" xml:space="preserve">
          <source>If the map did not have this key present, &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">如果地图上没有此密钥，则返回&lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="22fc8ad8eb7527fa9d4557d1bcf87a2d2bd7edcb" translate="yes" xml:space="preserve">
          <source>If the map did not have this key present, &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">如果地图上没有此密钥，则返回&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ce6ece3326d8becac91cb49d0dcc5a346e703bba" translate="yes" xml:space="preserve">
          <source>If the map did not have this key present, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">如果地图上没有此密钥，则返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c00b93ea8ff90e66022ac61d150c9d932705572a" translate="yes" xml:space="preserve">
          <source>If the named environment variable is present at compile time, this will expand into an expression of type &lt;code&gt;Option&amp;lt;&amp;amp;'static str&amp;gt;&lt;/code&gt; whose value is &lt;code&gt;Some&lt;/code&gt; of the value of the environment variable. If the environment variable is not present, then this will expand to &lt;code&gt;None&lt;/code&gt;. See &lt;a href=&quot;option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; for more information on this type.</source>
          <target state="translated">如果在编译时存在指定的环境变量，则它将扩展为 &lt;code&gt;Option&amp;lt;&amp;amp;'static str&amp;gt;&lt;/code&gt; 类型的表达式，其值是环境变量的 &lt;code&gt;Some&lt;/code&gt; 值。如果不存在环境变量，那么它将扩展为 &lt;code&gt;None&lt;/code&gt; 。有关此类型的更多信息，请参见&lt;a href=&quot;option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cc1523289d6738353278ad333a29d33483444f55" translate="yes" xml:space="preserve">
          <source>If the number of bytes to be written exceeds the size of the slice, write operations will return short writes: ultimately, &lt;code&gt;Ok(0)&lt;/code&gt;; in this situation, &lt;code&gt;write_all&lt;/code&gt; returns an error of kind &lt;code&gt;ErrorKind::WriteZero&lt;/code&gt;.</source>
          <target state="translated">如果要写入的字节数超过了分片的大小，则写入操作将返回短写入：最终， &lt;code&gt;Ok(0)&lt;/code&gt; ; 在这种情况下， &lt;code&gt;write_all&lt;/code&gt; 返回类型为 &lt;code&gt;ErrorKind::WriteZero&lt;/code&gt; 的错误。</target>
        </trans-unit>
        <trans-unit id="a6575b526f3c9f6ff8f51c0abc90eb128dc80c26" translate="yes" xml:space="preserve">
          <source>If the number of elements in the pattern doesn&amp;rsquo;t match the number of elements in the tuple, the overall type won&amp;rsquo;t match and we&amp;rsquo;ll get a compiler error. For example, Listing 18-5 shows an attempt to destructure a tuple with three elements into two variables, which won&amp;rsquo;t work.</source>
          <target state="translated">如果模式中的元素数量与元组中的元素数量不匹配，则整体类型将不匹配，并且会出现编译器错误。例如，清单18-5展示了将三个元素的元组分解为两个变量的尝试，但这种方法无效。</target>
        </trans-unit>
        <trans-unit id="0d2c1202b42295052cad83d3a70ac58e5c8cc86e" translate="yes" xml:space="preserve">
          <source>If the number of hardware threads is not known for the target platform.</source>
          <target state="translated">如果不知道目标平台的硬件线程数。</target>
        </trans-unit>
        <trans-unit id="d5f255ea3f66f81885c9b2fd50418cdf94440a9b" translate="yes" xml:space="preserve">
          <source>If the number of nanoseconds is greater than 1 billion (the number of nanoseconds in a second), then it will carry over into the seconds provided.</source>
          <target state="translated">如果纳秒数大于10亿(一秒内的纳秒数),则会延续到提供的秒数中。</target>
        </trans-unit>
        <trans-unit id="c7b893dcc899fca09569911e017ff49f116f8bab" translate="yes" xml:space="preserve">
          <source>If the option already contains a value, the old value is dropped.</source>
          <target state="translated">如果选项已经包含了一个值,那么旧的值就会被删除。</target>
        </trans-unit>
        <trans-unit id="7587948fbc56d5936df283dc95c30a87905bc378" translate="yes" xml:space="preserve">
          <source>If the path is a normal file, this is the file name. If it's the path of a directory, this is the directory name.</source>
          <target state="translated">如果路径是普通文件,这是文件名。如果是目录的路径,这是目录名。</target>
        </trans-unit>
        <trans-unit id="a7ef120bc4e6081962026d321af347e6c4f9a831" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;#method.rmatch_indices&quot;&gt;&lt;code&gt;rmatch_indices&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">如果模式允许反向搜索，但其结果可能与正向搜索不同，则可以使用&lt;a href=&quot;#method.rmatch_indices&quot;&gt; &lt;code&gt;rmatch_indices&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="04680e781abdf689365df53a980b052d9694289c" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;#method.rmatches&quot;&gt;&lt;code&gt;rmatches&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">如果模式允许反向搜索，但其结果可能与正向搜索不同，则可以使用&lt;a href=&quot;#method.rmatches&quot;&gt; &lt;code&gt;rmatches&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="fdde1b4f273f0ed1e791a6fe885f57ab847c6655" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;#method.rsplit&quot;&gt;&lt;code&gt;rsplit&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">如果模式允许反向搜索，但其结果可能与正向搜索不同，则可以使用&lt;a href=&quot;#method.rsplit&quot;&gt; &lt;code&gt;rsplit&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="7628f0f92ea01c70ac165a6fae25950d70760fc1" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;#method.rsplit_terminator&quot;&gt;&lt;code&gt;rsplit_terminator&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">如果该模式允许反向搜索，但其结果可能与正向搜索不同，则可以使用&lt;a href=&quot;#method.rsplit_terminator&quot;&gt; &lt;code&gt;rsplit_terminator&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="7b1dfc3434853d3f01995d02cf2021fd9cea4f38" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;../primitive.str#method.match_indices&quot;&gt;&lt;code&gt;rmatch_indices&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">如果该模式允许反向搜索，但其结果可能与正向搜索不同，则可以使用&lt;a href=&quot;../primitive.str#method.match_indices&quot;&gt; &lt;code&gt;rmatch_indices&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="ec2b2d41067456cd5ce092b8da0d00cd9c018667" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;../primitive.str#method.matches&quot;&gt;&lt;code&gt;rmatches&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">如果模式允许反向搜索，但其结果可能与正向搜索不同，则可以使用&lt;a href=&quot;../primitive.str#method.matches&quot;&gt; &lt;code&gt;rmatches&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="aa780fe3ad5330a6d715d8c1d30bd41ddfacfc03" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;../primitive.str#method.rsplit&quot;&gt;&lt;code&gt;rsplit&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">如果模式允许反向搜索，但其结果可能与正向搜索不同，则可以使用&lt;a href=&quot;../primitive.str#method.rsplit&quot;&gt; &lt;code&gt;rsplit&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="4b8ae88e59c6bfa2a36b4a334a350ee9f55b8244" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;../primitive.str#method.rsplit_terminator&quot;&gt;&lt;code&gt;rsplit_terminator&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">如果该模式允许反向搜索，但其结果可能与正向搜索不同，则可以使用&lt;a href=&quot;../primitive.str#method.rsplit_terminator&quot;&gt; &lt;code&gt;rsplit_terminator&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="8bcaec8982083667c5c84f44fc799e4d051fed01" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;primitive.str#method.match_indices&quot;&gt;&lt;code&gt;rmatch_indices&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">如果该模式允许反向搜索，但其结果可能与正向搜索不同，则可以使用&lt;a href=&quot;primitive.str#method.match_indices&quot;&gt; &lt;code&gt;rmatch_indices&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="e9c97ecf08e8a57f300f06fbed8336fddc8673ad" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;primitive.str#method.matches&quot;&gt;&lt;code&gt;rmatches&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">如果模式允许反向搜索，但其结果可能与正向搜索不同，则可以使用&lt;a href=&quot;primitive.str#method.matches&quot;&gt; &lt;code&gt;rmatches&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="8b3f51e25e82602ab5224623c59019342d6d26f3" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;primitive.str#method.rsplit&quot;&gt;&lt;code&gt;rsplit&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">如果模式允许反向搜索，但其结果可能与正向搜索不同，则可以使用&lt;a href=&quot;primitive.str#method.rsplit&quot;&gt; &lt;code&gt;rsplit&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="75ae87480dd359d1fa21ebc1f6510a38a90b5d25" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;primitive.str#method.rsplit_terminator&quot;&gt;&lt;code&gt;rsplit_terminator&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">如果该模式允许反向搜索，但其结果可能与正向搜索不同，则可以使用&lt;a href=&quot;primitive.str#method.rsplit_terminator&quot;&gt; &lt;code&gt;rsplit_terminator&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="02eda760b5bfe240d7c8b8f222a4d4b7100d666e" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search, the &lt;a href=&quot;#method.rsplitn&quot;&gt;&lt;code&gt;rsplitn&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">如果模式允许反向搜索，则可以使用&lt;a href=&quot;#method.rsplitn&quot;&gt; &lt;code&gt;rsplitn&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
